00:05:01 <hd_> I am interested in learning a functional language and I am liking clean and Haskell- anyone want to throw some propaganda my way to help me make a decision on which I should learn?
00:05:53 <mauke> #clean has 2 users
00:06:09 <hd_> and I am one of them :P
00:06:57 <mauke> on the other hand, #haskell is about as big as ##c
00:07:12 <lispy> hd_: Haskell as a production quality compiler, GHC
00:07:27 <Saizan_> haskell has utterly failed on its main goal
00:07:28 <lispy> eg., you can use Haskell for real-world apps today
00:07:33 <lispy> ?where rwh
00:07:33 <lambdabot> is http://www.realworldhaskell.org/blog/
00:07:42 <lispy> hd_: we have good books ^^ :)
00:07:51 <mauke> Saizan_: I agree
00:08:20 <hd_> lispy: what's wrong with Cleans compiler in comparison?
00:08:41 <hd_> Saizan_: how so?
00:09:07 <lispy> hd_: I've never tried it.  It might be great.
00:09:33 <lispy> hd_: but, I do know that GHC is used by real companies that really depend on it.
00:09:39 <Saizan_> hd_: the goal was "avoid success at all costs"
00:10:07 <hd_> lol :P
00:11:33 <pumpkin> http://antoniocangiano.com/2007/03/13/haskell-eye-for-the-ruby-guy/
00:11:36 <pumpkin> old post but fun
00:11:40 <lambdabot> Title: Haskell Eye for the Ruby Guy | Zen and the Art of Programming, http://tinyurl.com/57z64j
00:12:01 <jml> is there any way to have a data structure that maps from strings to objects that implement a particular typeclass?
00:13:55 <hd_> looks like GHC uses the MIT license?
00:14:15 <mauke> jml: yes, make an existential wrapper for the objects
00:14:39 <hd_> so if I wanted to, I wouldn't have to distribute the source to my programs or ?
00:14:44 <mauke> data Wrap = forall a. (SomeClass a) => Wrap a
00:14:56 <lispy> data ImplementsFoo = forall a. (Foo a) IF a
00:15:02 <mauke> hd_: huh? gcc is gpl'd and you don't have to distribute your sources either
00:15:13 <lispy> Data.Map String ImplementsFoo
00:15:38 <jml> mauke, lispy: thanks. I haven't come across forall before.
00:15:42 * jml researches further
00:15:52 <mauke> it's a ghc extension; look for "existential types"
00:16:31 <ski_> (also in hugs)
00:16:44 <hd_> good point mauke, but clean has a different approach: http://clean.cs.ru.nl/Download/License_Conditions/license_conditions.html
00:16:58 <lambdabot> Title: License Conditions, http://tinyurl.com/6n6tk7
00:17:23 <pumpkin> is there any effort on making n-tuples (where n /= 2) easier to use in haskell?
00:17:41 <mauke> hd_: doesn't that only apply if you want to redistribute clean?
00:18:08 <Beelsebob> pumpkin: the way to solve that problem is to get rid of n-tuples whene n /= 2
00:18:27 <Beelsebob> (and make (,) and operator)
00:19:00 <pumpkin> Beelsebob: they seem well suited (if they weren't so painful to extract stuff from and construct) to making vectors
00:19:05 <pumpkin> as in mathematical vectors
00:19:29 <pumpkin> but I couldn't make n-dimensional vectors at runtime for any n, which makes it less interesting
00:19:50 <hd_> mauke: that's what I initially thought, but the comment afterwards and relating to the commercial license makes me suspect they intended it to mean that any program you distribute must have source as well
00:19:50 <Beelsebob> yeh, but so is Num a => (a,(a,(a,a)))
00:19:52 <Beelsebob> and if (,) is just an operator, most of those parens disapear
00:20:05 <Beelsebob> and you get to Num a => a , a , a , a
00:20:06 <hd_> in anycase, I think I will give Haskell a go ;)
00:20:18 <Beelsebob> and now you can use things like fst and snd to get at any part of it
00:20:47 <pumpkin> Beelsebob: so you'd make it an infixr or something?
00:21:00 <Beelsebob> yep
00:21:05 <pumpkin> hrm
00:21:15 <the_unmaker> Im torn betwixt common lisp and haskell
00:21:18 <Beelsebob> the only casualty is that you'd need to get rid of the list syntactic sugar
00:21:28 <Beelsebob> and write them as x : y : z : []
00:21:34 <pumpkin> I guess I could pull out the nth item that way by iterating snd
00:21:41 <Beelsebob> indeed
00:21:48 <pumpkin> interesting interesting
00:22:19 <mauke> the_unmaker: enjoy your RPLACD :-)
00:22:36 * ski_ . o O ( x , y , z , () )
00:23:37 <Beelsebob> this does introduce one other annoyance -- which is that "tuples" would contain more bottoms
00:24:10 <Beelsebob> because (a,_|_) becomes a valid member of the type (a,a,a)
00:25:31 <the_unmaker> rplacd?
00:25:43 <the_unmaker> whats that?
00:25:46 <sbahra> What's up with hoogle?
00:25:48 <cpfr> side effects!
00:25:53 <sbahra> http://hackage.haskell.org/packages/archive/array/0.1.0.0/doc/html/Data-Array-Base.html
00:25:54 <sbahra> etc...
00:25:55 <cpfr> looks like its from lisp
00:25:57 <lispy> rplacd sounds like common lisp
00:26:02 <lambdabot> http://tinyurl.com/62z6j8
00:26:28 <cpfr> the_unmaker, you may embrace more than one language
00:26:49 <Twey> the_unmaker: They're both worth learning
00:27:19 <pumpkin> is the pattern matching on arithmetic expressions a special case, or is it something generalizable? the f (n + 1) = n kind of thing
00:27:40 <lispy> pumpkin: special case
00:27:42 <sbahra> f (n + 1) behavior is well-defined, no?
00:27:42 <Beelsebob> pumpkin: it's a special case, and one most people hate
00:27:46 <sbahra> s/is/is not/
00:27:50 <pumpkin> ah ok :)
00:28:10 <pumpkin> if I type f 0 there, it says non-exhaustive pattern :o
00:28:13 <lispy> > let 1+1 = 7 in let f (n+1) = n in f 2
00:28:14 <lambdabot>   1
00:28:15 <sbahra> I remember reading a haskell-cafe thread.
00:28:28 <lispy> > let 1+1 = 7 in let f (n+1) = n in f 1
00:28:30 <lambdabot>   0
00:28:32 <gio123> abgelegt is german word, does somebody knows it english translation?
00:28:39 <lispy> pumpkin: notice that it won't use my locally defined +
00:28:50 <pumpkin> yeah
00:28:53 <pumpkin> > let 1+1 = 7 in let f (n+1) = n in f 0
00:28:55 <lambdabot>   * Exception: /tmp/1860491672711809082:71:71-81: Non-exhaustive patterns in ...
00:29:03 <lispy> :t let f (n+1) = in in f
00:29:04 <lambdabot> parse error on input `in'
00:29:09 <lispy> :t let f (n+1) = n in f
00:29:11 <lambdabot> forall t. (Integral t) => t -> t
00:29:19 <lispy> pumpkin: but it says it will take any Integral instance
00:29:24 <pumpkin> yeah
00:29:27 <pumpkin> why does that happen then?
00:29:45 <lispy> pumpkin: and yes, it has some condition like f n | n > 0 let n' = n - 1
00:29:49 <ski_> it's meant for natural recursion
00:29:52 <pumpkin> oh
00:30:14 <lispy> pumpkin: have you looked at the Haskell report?
00:30:18 * pumpkin is curious how the generated code differs
00:30:21 <lispy> pumpkin: they explain this pretty nicely
00:30:33 <pumpkin> nope, haven't seen it
00:30:36 <lispy> pumpkin: that is, they tell you what it's equivalent too
00:30:41 <pumpkin> http://www.haskell.org/onlinereport/ this thing?
00:30:42 <lambdabot> Title: The Haskell 98 Language Report
00:30:46 <lispy> pumpkin: yeas
00:30:48 <ski_> @where report
00:30:48 <lambdabot> http://www.haskell.org/onlinereport/
00:30:58 <pumpkin> I'll take a look, thanks
00:31:02 <pumpkin> so much to soak in
00:31:04 * pumpkin enters sponge mode
00:31:28 <lispy> how deep would the ocean be without all those sponges?
00:31:36 <lispy> ?brain
00:31:37 <lambdabot> Now, Pinky, if by any chance you are captured during this mission,
00:31:37 <lambdabot> remember you are Gunther Heindriksen from Appenzell. You moved to Grindelwald
00:31:37 <lambdabot> to drive the cog train to Murren.  Can you repeat that?
00:31:42 <sbahra> @yow
00:31:43 <lambdabot> All of life is a blur of Republicans and meat!
00:31:44 <lispy> ?brain sponge
00:31:44 <lambdabot> I think so, Brain, but, the Rockettes? I mean, it's mostly girls, isn't it?
00:32:00 <pumpkin> ?help brain
00:32:00 <lambdabot> brain. Pinky and the Brain
00:32:07 <pumpkin> oh, of course
00:32:09 <pumpkin> ;)
00:32:27 <ski_> @keal
00:32:27 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
00:32:31 <Beelsebob> @brain are you thinking what I'm thinking pinky?
00:32:32 <lambdabot> There's only one ride that interests me - the incredible thrill ride of taking over the world!
00:32:41 <Beelsebob> o.O
00:32:45 <sbahra> @yow
00:32:45 <lambdabot> Why don't you ever enter any CONTESTS, Marvin??  Don't you know your
00:32:46 <lambdabot> own ZIPCODE?
00:33:01 * pumpkin is very confused now
00:33:03 <lispy> ?. elite yow
00:33:03 <lambdabot> 50 7|-|is i5 WhA7 iT Fe3LS |IKE TO BE PO+Ato 5aL4d
00:33:07 <sbahra> newlines should be removed
00:33:15 <sbahra> and replaced with spaces
00:33:20 <lispy> ?. vixen elite yow
00:33:21 <lambdabot>  key
00:33:23 <sbahra> ?help yow
00:33:24 <lambdabot> yow. The zippy man.
00:33:25 <lispy> ?. vixen elite yow
00:33:26 <lambdabot> Are we just wasting time?
00:33:28 <sbahra> ?help vixen
00:33:28 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
00:33:32 <lispy> ?. vixen elite yow
00:33:32 <lambdabot> do you have toys?
00:33:38 <pumpkin> crypto
00:33:51 <ski_> @. vixen . elite yow
00:33:52 <lambdabot> no
00:33:59 <sbahra> heh
00:34:01 <Beelsebob> @vixen no what?
00:34:01 <lambdabot> no?
00:34:10 <Beelsebob> @vixen yes, no!
00:34:10 <lambdabot> no?
00:34:13 <Beelsebob> :(
00:34:15 <pumpkin> damn it's cold outside
00:34:24 <sbahra> @vixen What?
00:34:25 <lambdabot> isn't it obvious?
00:34:25 <Beelsebob> @vixen damn it's cold outside
00:34:25 <lambdabot> i know, it's too bad
00:34:35 <sbahra> @vixen damn blah blah blah
00:34:36 <lambdabot> what's wrong?
00:34:54 <ski_> @fix vixen
00:34:55 <lambdabot> Maybe you meant: bid faq ft id thx
00:35:32 <ski_> what, no fixpoint LB command operator !?
00:36:41 <sbahra> heh, I thought vixen was doing something more intelligent than it actually is :-P
00:37:07 <Beelsebob> @vixen you are more intelligent than you seem though, aren't you \bot?
00:37:07 <lambdabot> no, how dare you ask if i'm a bot!
00:37:17 <Beelsebob> :D
00:37:19 <sbahra> haha
00:39:36 <lispy> ?vixen how is your new sentience module working?
00:39:37 <lambdabot> how? it depends...
00:40:32 <kfish> @botsnack
00:40:32 <lambdabot> :)
00:41:50 <pumpkin> @botsnack
00:41:50 <lambdabot> :)
00:46:03 <ski_> gwern : helium
00:49:16 <the_unmaker> are there DNS and or EMAIL MTA servers in haskell?
00:54:01 <lispy> the_unmaker: someone wrote hsemail that was used in an email server but I don't know if it was part of an MTA specifically.
00:54:06 <lispy> the_unmaker: look on hackage.haskell.org
00:54:13 <the_unmaker> hm
01:08:50 <pumpkin> does the author of randomhacks.net hang out in here?
01:08:54 <frederik> hey. When I try to install haskelldb with cabal-install I get lots of errors because of hidden packages. Is there any way to make those packages exposed to cabal without editing the cabal file of the package?
01:08:56 <pumpkin> eric kidd?
01:09:55 <Saizan_> frederik: no
01:10:20 <frederik> Saizan_: hm, that's not the answer I was hoping for ;-)
01:10:26 <Saizan_> frederik: you've to add those packages to haskelldb.cabal's build-depends field
01:10:58 <frederik> yes, I've changed the haskelldb package's cabal file
01:11:10 <frederik> but the same happens for its dependencies ...
01:12:06 <Saizan_> heh, haskelldb is not actively maintained
01:13:11 <frederik> Isn't it anymore?
01:13:15 <xenoblitz> hey guys... can anyone tell me why the following code is wrong on the 4th line? http://hpaste.org/12297
01:14:25 <frederik> Saizan_: last year there've been some updates
01:14:32 <Lemmih> xenoblitz: You can't deconstruct functions.
01:15:36 <xenoblitz> Lemmih: is it possible to write something of the form, simulate circuit input without requiring it being written as simulate $ circuit input ?
01:16:09 <frederik> xenoblitz: simulate (circuit input) ;) ?
01:16:56 <xenoblitz> frederik: hehe yes I want to make simulate a higher order function and remove the ( ) / $ but I don't know which is the way to go to achieve that
01:17:08 <Saizan_> if you want to write "simulate circuit input" then both circuit and input are two distinct argument to simulate
01:17:16 <ski_> xenoblitz : what are the intended types of `wire' and `func', there ?
01:17:50 <xenoblitz> Saizan: I tried to write a function to simulate a function but I couldn't get it right
01:18:14 <xenoblitz> ski_: take as an example func:: Wire -> Wire and wire :: Wire
01:18:26 <xenoblitz> i have managed to simulate a wire
01:18:36 <xenoblitz> but not a function which takes a wire and is then simulated
01:18:48 <xenoblitz> i hope I am explaining myself well
01:19:12 <ski_> is `Simulate Wire' an instance ?
01:19:21 <xenoblitz> ski: yes
01:19:25 <xenoblitz> let me add it
01:20:07 <xenoblitz> http://hpaste.org/12297#a1
01:20:22 <ski_> i'm not clear on why you want to have `Wire -> Wire' (et.c.) be an instance of `Simulate'
01:21:22 <xenoblitz> ski: I would like a mechanism so that I could later on have (Wire,Wire) -> Wire ... and so on
01:21:41 <ski_> i do not follow
01:21:59 <xenoblitz> imagine you have a circuit with 2 inputs or 3 inputs....
01:22:02 <Saizan_> if you want to go from (Wire -> Wire) to (Wire -> Bool) you just have to write (simulate . func)
01:22:03 <xenoblitz> then you could write
01:22:14 <xenoblitz> simulate circ (wire1,wire2)
01:22:22 <xenoblitz> or simulate circ (wire1, wire2, wire3)
01:22:38 <Lemmih> xenoblitz: Why won't 'simulate (circ (wire1,wire2)' do?
01:22:39 <Saizan_> (simulate . circ) (wire1,wire2)
01:23:06 <xenoblitz> Lemmih: cause I need it that way :P
01:23:10 <ski_> (.) simulate circut (wire0,wire1)  -- or this
01:24:05 <xenoblitz> is what I am asking for really impossible in haskell?
01:24:18 <ski_> i'm not sure what you're asking for
01:24:23 <Saizan_> we're not sure what you're asking..
01:24:29 <Lemmih> I'm lost too.
01:24:36 <xenoblitz> lol than I am not being clear, sorry
01:24:53 <Saizan_> maybe we need more context
01:24:57 <PeakerWork> How do you call "words" that takes the separation token?
01:25:31 <Saizan_> split?
01:25:53 <Saizan_> not in any libraries, afaik
01:26:04 <xenoblitz> ok wait... lets see... so far I got: simulate wire and it works
01:26:31 <xenoblitz> now imagine you have a circuit (not a wire) ... and you want to simulate it
01:26:31 <PeakerWork> bummer.. Haskell's string libraries kind of suck :P
01:26:49 <ski_> PeakerWork : maybe `unintercalate' ?
01:26:52 <xenoblitz> so you have simulate circuit ... but you need inputs
01:27:01 <PeakerWork> @t unintercalate
01:27:01 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
01:27:04 <frederik> PeakerWork: performance-wise?
01:27:05 <PeakerWork> @type unintercalate
01:27:06 <lambdabot> Not in scope: `unintercalate'
01:27:09 <xenoblitz> so you need something of the form simulate circuit inpx
01:27:10 <ski_> @type intercalate
01:27:11 <lambdabot> forall a. [a] -> [[a]] -> [a]
01:27:21 <PeakerWork> frederik: no, missing simple functions like "split", "replace", etc
01:27:32 <Lemmih> xenoblitz: Why not: simulate $ circuit inpx ?
01:27:41 <PeakerWork> I have to use regexps (which is not a trivial library at all) just to do reasonably-efficient string replace
01:28:07 <frederik> PeakerWork: http://cvs.haskell.org/Hugs/pages/libraries/base/Data-List.html
01:28:12 <lambdabot> Title: Data.List
01:28:17 <Lemmih> xenoblitz: For purely aesthetic reasons?
01:28:52 <xenoblitz> Lemmih: yeah that works but I wish to make simulate higher-order sort of... it takes any circuit, expects a number of inputs... lets say yes aesthetic... the reason is that if I would like to write a module for later use it would make things much less cluttered
01:29:44 <Lemmih> xenoblitz: It /can/ be done but not in any pretty way.
01:29:45 <ski_> (PeakerWork : btw, i thought you were looking for a name, for naming this operation ..)
01:29:57 <PeakerWork> frederik: where is replace in there?
01:30:06 <PeakerWork> ski_: nah, I was looking for an existing library function
01:30:20 <frederik> PeakerWork: split is in there, what do you need to replace?
01:30:25 <PeakerWork> There's no reason for Python to be easier at string handling than Haskell. I'll put a Pythonic string handling library in my TODO list
01:30:26 <xenoblitz> Lemmih: any examples I can follow?
01:30:42 <PeakerWork> frederik: I say "split" and I mean "unintercalate"
01:30:50 <PeakerWork> frederik: (its the Pythonic name of that function)
01:31:15 <PeakerWork> there's no need for there to be a high learning curve for simple functions anyone can understand
01:31:19 <Saizan_> xenoblitz: http://hpaste.org/12297#a2
01:31:24 <Lemmih> xenoblitz: I doubt there are any examples. This is not something you should ever do if you don't know how to do it.
01:31:34 <ski_> xenoblitz : wouldn't you then rather have something like `simulate circuit wire0 wire1 wire2' ?
01:31:57 <xenoblitz> Saizan: thanks I'll try to understand that
01:32:08 <xenoblitz> Lemmih: all the reason to learn more :)
01:32:12 <Saizan_> if got that right..
01:32:38 <xenoblitz> ski: that would work but having a tuple would work as well
01:32:53 <xenoblitz> Saizan: btw why is it not recommended?
01:32:53 <ski_> (Saizan_ : will that really work with `simulate circuit (wire1,wire2)' ;)
01:33:57 <Lemmih> xenoblitz: It's bad Haskell. I definitely wouldn't recommend it.
01:34:29 <Saizan_> *Main> :t simulate (undefined :: (Wire, Wire) -> Wire)
01:34:29 <Saizan_> simulate (undefined :: (Wire, Wire) -> Wire) :: (Wire, Wire) -> Bool
01:34:47 <Saizan_> as long as the return type is fixed it will work nicely
01:35:25 <Saizan_> xenoblitz: it misuses typeclasses for no clear advantage
01:35:34 <sbahra> PeakerWork, ByteString has the split you are thinking of (with the name split)
01:35:34 <xenoblitz> i c guys
01:35:57 <xenoblitz> I will try to use something else then
01:36:01 <ski_> (Saizan_ : you're right .. no extra constraints on the intermediate type)
01:36:48 <Saizan_> (ski_: it works in the curried form too)
01:36:59 <pumpkin> xenoblitz: what is not recommended btw? I'm just learning and the abuse of typeclasses for no clear advantage went off the top of my screen
01:37:34 <PeakerWork> sbahra: its better, but its still based on just 1 Word8, and not a whole substring (the more difficult case to get right)
01:37:42 <Saizan_> pumpkin: http://hpaste.org/12297#a2
01:38:09 <lispy> Which monad would instances would I need for ap :: [a -> b] -> [a] -> [b]
01:38:17 <lispy> :t ap
01:38:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:38:21 <ski_> (Saizan_ : yes, i could see that, the uncurried form was the one i initially doubted)
01:38:30 <lispy> I just need Monad [a], right
01:38:47 <jsn> why is this an abuse?
01:38:48 <ski_> Monad []
01:39:20 <lispy> :t \f xs ys zs -> zipWith f xs ys `ap` zs
01:39:21 <lambdabot> forall a b a1 b1. (a -> b -> a1 -> b1) -> [a] -> [b] -> [a1] -> [b1]
01:39:35 <ski_> > [(+),(*)] `ap` [20,30] `ap` [4,5]
01:39:36 <lambdabot>   [24,25,34,35,80,100,120,150]
01:39:41 <Saizan_> jsn: what i find most ugly is the type of simulate :: Simulate a r => a -> r, it doesn't say anything about what simulate is intended to do
01:39:46 <lispy> :t zipWith
01:39:47 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
01:40:06 <lispy> cool, so ap can be used to extend zipWith to zipWithN
01:40:20 <ski_> lispy : for `ZipList' (not `[]'), yes
01:40:31 <lispy> ski_: sorry?
01:40:44 <dolio> ZipList is the applicative functor for zipping.
01:40:50 <dolio> And it isn't a Monad.
01:40:59 <ski_> > runZipList $ ZipList [(+),(*)] <*> ZipList [20,30] <*> ZipList[4,5]
01:41:00 <lambdabot>   Not in scope: `runZipList'
01:41:01 <dolio> (It's a newtype wrapper around [])
01:41:18 <PeakerWork> lispy: you can use the Applicative <*> instead of the Monadic ap (and be a bit more general, if you want to apply to not-just-lists)
01:41:26 <ski_> > getZipList $ ZipList [(+),(*)] <*> ZipList [20,30] <*> ZipList[4,5]  -- bah
01:41:27 <lambdabot>   [24,150]
01:41:42 <lispy> > (\f xs ys zs -> zipWith f xs ys `ap` zs) (,,,) [1..10] "a..z" [1.0,1.1..2]
01:41:43 <lambdabot>       Overlapping instances for Show (d -> (a, Char, a1, d))
01:41:44 <lambdabot>        arising f...
01:42:16 <lispy> > (\f xs ys zs -> zipWith f xs ys `ap` zs) (,,) [1..10] "a..z" [1.0,1.1..2]
01:42:17 <lambdabot>   [(1,'a',1.0),(1,'a',1.1),(1,'a',1.2000000000000002),(1,'a',1.30000000000000...
01:42:52 <ski_> > (\f xs ys zs -> pure f <*> xs <*> ys <*> zs) (,,) [1..10] "a..z" [1.0,1.1..2]
01:42:54 <lambdabot>       Ambiguous occurrence `pure'
01:42:54 <lambdabot>      It could refer to either `Control.Appl...
01:42:54 <PeakerWork> lispy: note you're being assymetrical (only doing a cartesian product against zs, not between xs and ys)
01:43:30 <lispy> yeah, I don't actually want a cartesian product
01:43:38 <lispy> I want zipWith3
01:44:03 <ski_> > getZipList $ (\f xs ys zs -> Control.Applicative.pure f <*> xs <*> ys <*> zs) (,,) (ZipList [1..10]) (ZipList "a..z") (ZipList [1.0,1.1..2])
01:44:04 <lambdabot>   [(1,'a',1.0),(2,'.',1.1),(3,'.',1.2000000000000002),(4,'z',1.30000000000000...
01:44:07 <PeakerWork> lispy: non (,) tuples suck :)
01:44:27 <ski_> lispy : you wanted it that way ?
01:44:58 <PeakerWork> > foldr (<*>) Control.Applicative.pure (map ZipList [[1..10],['a'..'z'],[1,1.1..2]])
01:44:59 <lambdabot>   Couldn't match expected type `(->) a'
01:45:04 <ski_> @index zipWith3
01:45:04 <lambdabot> Data.List, Prelude
01:45:16 <lispy> ski_: yeah.  I'm reading this functional perl where they define (<<) :: [a -> b] -> [a] -> [b], so that zipWithN can be zipWith(N-1) .. << zs
01:45:28 <lispy> ski_: and I noticed that (<<) has the same type as ap
01:45:41 <lispy> so I had hopped that (<<) is not needed
01:45:47 <ski_> yes, it is `ap' for `ZipList'
01:45:57 <PeakerWork> @type (<<)
01:45:59 <lambdabot> Not in scope: `<<'
01:46:06 <ski_> (except `ZipList' isn't a full monad, so `(<*>)' ..)
01:46:19 <the_unmaker> maybe perl is the ultimate language!
01:46:28 <lispy> the_unmaker: yeah
01:46:30 <lispy> the_unmaker: maybe
01:46:30 <ski_> @index (<<)
01:46:31 <lambdabot> Text.Html
01:46:34 <PeakerWork> Isn't ZipList a monad for infinite lists, even?
01:46:46 <PeakerWork> if not, then we finally have a simple example of a non-monad applicative!
01:46:46 <ski_> @type (Text.Html.<<)
01:46:47 <lambdabot> forall b a. (Text.Html.HTML a) => (Text.Html.Html -> b) -> a -> b
01:46:59 <lispy> :t cycle
01:47:01 <lambdabot> forall a. [a] -> [a]
01:47:01 <dolio> Yes, but streams aren't elists.
01:47:05 <lispy> :t replicate
01:47:06 <lambdabot> forall a. Int -> a -> [a]
01:47:08 <dolio> Lists, even.
01:47:10 <ski_> PeakerWork : sure, for streams
01:47:12 <lispy> :t repeat
01:47:13 <lambdabot> forall a. a -> [a]
01:47:39 <dolio> It might be a monad for sized vectors, even.
01:47:40 <ski_> lispy : yes, that's `return' (or `pure' if you will)
01:47:45 <dolio> Not quite sure about that.
01:47:54 <PeakerWork> ski_: I wonder if it is that much trouble to separate the type of infinite lists from finite ones
01:48:06 <PeakerWork> ski_: and have an instance for infinite lists rather than ZipList
01:48:33 <dolio> return = replicate n, join = diagonal.
01:48:33 <PeakerWork> dolio: nope, I don't think its a Monad, how would join work and leave lists of the same length?
01:48:47 <lispy> ski_: this ZipList is likely based off this functional pearl work
01:48:54 <PeakerWork> > return 1 :: ZipList Int
01:48:55 <lambdabot>       No instance for (Show (ZipList Int))
01:48:55 <lambdabot>        arising from a use of `show...
01:49:08 <PeakerWork> @hoogle ZipList a -> [a]
01:49:09 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
01:49:09 <lambdabot> Prelude repeat :: a -> [a]
01:49:09 <lambdabot> Data.List repeat :: a -> [a]
01:49:14 <PeakerWork> > getZipList $ return 1 :: ZipList Int
01:49:15 <lambdabot>   Couldn't match expected type `ZipList Int'
01:49:19 <dolio> PeakerWork: List k (List k a) is a square matrix, so the diagonal is a List k.
01:49:21 <ski_> dolio : hm, istr something remniscent from a paper about vectorizing code ..
01:49:33 <ski_> (not sure)
01:49:37 <PeakerWork> dolio: why is your List *->*->* ?
01:49:39 <dolio> k being a type-level natural specifying the size.
01:49:44 <PeakerWork> ah
01:50:04 <ski_> (lispy : quite possible)
01:50:13 <PeakerWork> dolio: I thought quicksilver explained that join can't work for finite ZipLists
01:50:17 <PeakerWork> > getZipList $ (return 1 :: ZipList Int)
01:50:18 <lambdabot>       No instance for (Monad ZipList)
01:50:19 <lambdabot>        arising from a use of `return' a...
01:50:41 <ski_> dolio isn't talking about finite lists, but rather finitely-sized lists
01:50:46 <dolio> PeakerWork: I suspect that's for lists that can have arbitrary size.
01:51:01 <dolio> A List k (or Vec k) always has size k.
01:51:03 <lispy> ski_: the authors don't mention ZipList in this paper, but everything else in this discussion applies
01:51:16 <ski_> lispy : authors being ?
01:51:20 <dolio> Streams would be a 'special case' where the size is omega. :)
01:51:22 <lispy> such that repeat = zipWith0
01:51:42 <PeakerWork> does diagonal work out with the monad laws?
01:51:44 <lispy> ski_: http://www.brics.dk/RS/01/10/BRICS-RS-01-10.pdf
01:51:47 <lambdabot> Title: Do we Need Dependent Types?
01:51:48 <ski_> dolio : b-b-but that's not a natural :O
01:51:51 <Twey> 'zipWith0'?
01:51:59 <lispy> Twey: yeah, repeat :)
01:52:06 <dolio> ski_: We're using type-level ordinals, then!
01:52:33 <ski_> please specify them
01:52:48 <Twey> I don't get why we don't have just one zipWith :: ([a] -> a) -> [[a]] -> [a]
01:52:57 <lispy> Twey: given (<<) :: [a -> b] -> [a] -> [b] that is roguhly (<<) = map ($), then you can define zipWithN = repeat f << as1 << ... << asN
01:53:04 <Twey> I guess it's a little less typable :(
01:53:07 <ski_> PeakerWork : in the infinite case, it does, afaic remember
01:53:11 <lispy> :t map ($)
01:53:12 <lambdabot> forall a b. [a -> b] -> [a -> b]
01:53:26 <Saizan_> :t zipWith ($)
01:53:27 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
01:53:31 <Saizan_> ?src ap
01:53:31 <lambdabot> ap = liftM2 id
01:53:39 <peter1> looks like http://hackage.haskell.org/trac/ghc/login does not work, is anybody here who can fix it?
01:53:39 <peter1> I cannot login, trac reports some kind of internal error.
01:53:42 <dcoutts> Lemmih: is there any reason to override the global libdir for LHC, to specify that it is /usr/local/lib, irrespective of the $prefix ?
01:53:44 <Saizan_> zipWith = liftA2 :)
01:53:47 <lispy> Saizan_: thank you, i got that one wrong, (<<) = zipWith ($)
01:54:04 <dcoutts> Lemmih: by default it'll be /usr/local/lib, but because libdir is $prefix/lib and prefix is /usr/local
01:54:42 <PeakerWork> ski_: in dolio's List k type
01:55:28 <Lemmih> dcoutts: I guess not.
01:56:03 <dcoutts> Lemmih: ok, ta
01:56:25 * lispy made his ghc6.10 install find things in the right places by hacking the rts package conf...he didn't like the idea of adding things to env pathes for just one application
01:57:06 <ski_> (dolio : `data Ordinal = Zero | Succ Ordinal | Sup (Natural -> Ordinal)' ?)
01:57:25 <lispy> Sup?
01:57:30 <ski_> supremum
01:57:39 <lispy> What is Natural?
01:57:52 <ski_> data Natural = Z | S Natural  -- e.g.
01:58:21 <lispy> So...other than Sup, how are Ordinals different than Naturals?
01:58:25 <lispy> Why have both I mean
01:58:47 <lispy> why not Sup (Natural -> Natural)
01:58:49 <dolio> ski_: That's the way I've seen it. Not sure useful Sup would be at the type level.
01:59:22 <dolio> Or, doable in the first place, really.
01:59:23 <ski_> `Sup ([n_0,n_1,..] !!)' would be the least ordinal greater than all of the `n's
02:01:59 <ski_> (lispy : sure, `Natural' could be thought of as a subtype of `Ordinal')
02:02:31 <lispy> ski_: gah, that paper I linked you to is just a stupid short version :)  The discussion I want is in some longer version
02:03:32 <lispy> ski_: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.6103
02:03:33 <lambdabot> Title: Do we Need Dependent Types - CiteSeerX
02:03:45 <dcoutts> Lemmih: oh, and I guess the getInstalledPackages should be a dummy impl that returns empty, rather than it using ghc-pkg?
02:03:53 <ski_> (would it be impolite of me to mention that i didn't notice you linked to a paper before ?)
02:04:09 <Lemmih> dcoutts: Oh no, that wouldn't work.
02:04:22 <dcoutts> Lemmih: asking ghc-pkg certainly cannot work :-)
02:04:28 <Lemmih> dcoutts: Sure it can.
02:04:46 <dcoutts> huh? what ghc has installed is unrelated to what you've got installed for lhc
02:05:18 <dcoutts> Lemmih: or you mean that using what ghc has is a reasonable approximation, better than []
02:05:22 <Lemmih> dcoutts: That's why it's using its own package.conf file.
02:05:26 * ski_ wonders what newfangled nonsense this `citeseerx' is ..
02:05:30 <dcoutts> ohh
02:05:36 <dcoutts> Lemmih: sneaky
02:06:01 <Lemmih> dcoutts: I was/am too lazy to write something better.
02:06:22 <lispy> ski_: heh, citeseerx is cool.  I can get most papers in pdf plus decent bibtex entries
02:07:07 <ski_> i preferred the old CiteSeer where you could see some keywords of the paper in the link
02:07:46 <dcoutts> Lemmih: yep, fair enough
02:10:43 <Saizan_> ski_: yeah, also the saved pdf had a sensible name by default
02:19:12 <frederik> when I try to build and install hsql using Setup.lhs it works after adding some dependencies to the cabal file, but when I try to do a "cabal install" in the hsql directory an error occcurs  about Control.OldException being in base which is not exposed?
02:19:30 <frederik> while base is listed in the package's dependencies
02:20:04 <Saizan_> frederik: you should use "base >= 4"
02:21:09 <frederik> Saizan_: but why does using the Setup.lhs work?
02:21:13 <Saizan_> cabal-install uses hackage's supplied preferences, which tells it to use base-3 when possible
02:21:44 <Saizan_> while Setup just defaults to the latest version of everything when it has a choice
02:21:52 <frederik> Saizan_: ok, thanks a lot :)
02:22:55 <lispy> frederik: it's confusing, but for hard to explain reasons, using 'cabal' versus 'runghc Setup.hs' behave quite differentely
02:23:10 <frederik> It would be nice to get the fixed packages into hackage
02:24:00 <frederik> (hsql, haskelldb, haskelldb-hsql, haskelldb-hsql-mysql and so on)
02:26:45 <Saizan_> everyone with an account can upload a package for any library, but it's best to coordinate with the author/last maintainer
02:28:02 <dons> frederik: right. use cabal-install, ping maintainers (and send patches)
02:28:12 <dons> for non-constraint-solver based resolovers
02:29:56 <Saizan_> dons: what to do when you get no answer though?
02:31:43 <dcoutts> hostile takeover? :-)
02:33:51 <frederik> but cabal-install still confuses me, I first tried to install haskelldb, which didn't work, so I fixed the cabal file and installed it from the directory with the fixed cabal file
02:34:12 <frederik> afterwards i did the same for hsql
02:34:29 <Saizan_> dcoutts: btw, maybe cabal-install could print a notice when it uses preferences?
02:34:44 <dcoutts> Saizan_: mm, maybe so
02:34:47 <frederik> now when I try to install haskelldb-hsql cabal-install still tries to install the packages from the cache?!
02:35:22 <Saizan_> frederik: you should bump the version if you change dependencies
02:35:28 <dcoutts> frederik: see the output of cabal install -v --dry-run haskelldb-hsql. It'll tell you how it'd re-install them
02:35:55 <dcoutts> frederik: it assumes if they're the same version then they're the same, so yes, you should bump the version.
02:36:26 <lispy> frederik: best to add a new level tot he version number though
02:36:28 <dcoutts> frederik: the planner notices that the way it's planning to install haskelldb-hsql is different from the way it's currently installed, so it assumes it must re-install it.
02:36:57 <lispy> frederik: that way, the maintainer can't upload the same version number to hackage and you avoid potential grief later
02:37:15 <frederik> ok
02:37:41 <frederik> is cabal-install documented somewhere?
02:37:49 <Saizan_> hackage packages can only have four fields?
02:38:35 <Saizan_> in the version number, i mean
02:39:53 <frederik> cabal knows only one kind of version number, right (no seperate package and program version numbers, I mean)?
02:40:15 <dcoutts> frederik: only one
02:41:17 <frederik> dcoutts: wouldn't it be useful to have a package and a program version number, to distinguish between a change in the program and a change in the package (like, adapting it to a new ghc version)?
02:41:41 <dcoutts> frederik: we just use conventions on the version number
02:41:54 <dcoutts> frederik: see the package versioning policy
02:42:02 <frederik> ok
02:46:41 <frederik> dcoutts: aehem, sorry, but where do i find this described?
02:47:07 <frederik> dcoutts: I was looking at the hackage pages, but I couldn't find anything about a package versioning policy
02:47:23 <the_unmaker> your hask fu is weak
02:47:35 <the_unmaker> I challenge you to code a webserver faster than nginx!!!
02:47:59 <the_unmaker> something that can do more than 3000 requests a second on a p4 3Ghz with 4g ram
02:48:38 <dcoutts> frederik: good point, let me link it from there
02:48:55 <the_unmaker> 'show me the programs!'
02:49:05 <the_unmaker> haskell.org is long on explanatin
02:49:12 <the_unmaker> but where are the workin apps?
02:49:22 <ivanm> @where hackage
02:49:22 <lambdabot> http://hackage.haskell.org/
02:49:36 <ivanm> ;-)
02:50:05 <Lemmih> the_unmaker: There is not much point in reimplementing nginx.
02:51:51 <dcoutts> frederik: I've added the link under the quality control section
02:55:48 <lispy> http://en.wikipedia.org/wiki/Intuitionistic_type_theory
02:55:50 <lambdabot> Title: Intuitionistic type theory - Wikipedia, the free encyclopedia
02:55:56 <lispy> wikipedia is handy
02:56:03 <lispy> it does a good job of summarizing things
02:56:20 <lispy> I kept wondering why intuitionistic logic kept coming up when learning about type theory
02:56:24 <lispy> that's because they mean the same thing!
02:58:18 <Saizan_> and djinn was proving intuitionistic theorems that all this time, du du dun..
02:58:26 <cinimod> @djinn
02:58:26 <lambdabot> Cannot parse command
02:58:35 <RayNbow> @djinn a -> a
02:58:36 <lambdabot> f a = a
02:58:43 <cinimod> ah
02:58:56 <RayNbow> @djinn (a -> b) -> (b -> a)
02:58:56 <Saizan_> @djinn (Not (Not a)) -> a
02:58:57 <lambdabot> -- f cannot be realized.
02:58:57 <lambdabot> -- f cannot be realized.
02:59:12 <RayNbow> hmm...
02:59:18 <Saizan_> @djinn Not (Not ((Not (Not a)) -> a))
02:59:18 <lambdabot> f a = void (a (\ b -> void (b (\ c -> a (\ _ -> c)))))
02:59:37 <RayNbow> ah stupid me
02:59:44 <Saizan_> @djinn (a -> b) -> (Not b -> Not a)
02:59:44 <lambdabot> f a b c = b (a c)
02:59:51 <RayNbow> @djinn (a -> b -> c) -> (b -> a -> c)
02:59:51 <lambdabot> f a b c = a c b
03:05:53 <lispy> Can someone help me understand this: "In extensional Type Theory definitional (i.e. computational) equality is not distinguished from propositional equality, which requires proof."
03:06:07 <lispy> what is propositional equality?
03:06:40 <ivanm> equality of propositions? ;-)
03:06:42 <Twey> Equality of propositions?  *guesses*
03:06:47 <Twey> Heh
03:06:48 <vixey> A <-> B
03:06:50 <lispy> Oh, I think I get it.  They mean that definitional is computable.  And propositional requires a mathematical proof?
03:06:58 * Twey high-fives ivanm.
03:07:05 <gio123> is somebody here from post soviet union?
03:07:16 <lispy> vixey: <-> meaning if and only if?
03:07:26 <ivanm> Twey: heh
03:07:30 <vixey> yes
03:07:52 <lispy> I'm confused about the meaning of "requires proof"
03:08:25 <lispy> This is in the context of constructive mathematics, so what does it mean "requires proof"?  But then says it's undecidable
03:08:29 <vixey> lispy, an example might be,   Maybe a <-> (a,())
03:08:37 <lispy> If it's all constructive, can it stil be undecidable?  I guess so
03:08:45 <vixey> emmm........... bad example
03:08:49 <lispy> vixey: that doesn't help :)
03:08:56 <vixey> I know
03:08:57 <vixey> Maybe a <-> Either a ()
03:09:12 <lispy> vixey: is <-> the curry-howard isomorphism?
03:09:22 <opqdonut> no, just type isomorphism :)
03:09:22 <ski_> lispy : unifying the types `Vector A (n + 0)',`Vector A n', requires proof that `n + 0' equals `n'
03:09:32 <vixey> the proof could be,  Conj (maybe (Right ()) Left, either (const Nothing) Just)
03:09:58 <lispy> ski_: but that could be definitional?
03:10:00 <vixey> whereas something like  3 + 2 is definitionaly equal to 5
03:10:28 <vixey> ski gives a awkward case.. you have to look at the definition of + to know for sure
03:10:44 <ski_> agreed
03:10:55 * ski_ inducted on the left argument
03:11:14 <lispy> Oh, they mean extensional is undecidable because in general computability is undeciable and extensional requires computability in general.
03:11:19 <vixey> if you define + as   0 + y = y ; S x + y = S (x + y) then  n + 0 will not be definitionaly equal to n
03:11:30 <vixey> but if you defined it by induction on y then it would be
03:11:55 <ski_> lispy : yes
03:12:56 <vixey> lispy, I'm not even sure what curry-howard means anymore but <-> probably fits into it
03:13:06 <lispy> So, then when we constrain to total functional programming we are trying to use extensional type theory by making computation decidabel?
03:13:17 <vixey> by A <-> B I meant a pair of A -> B and A <- B
03:13:35 <lispy> B -> A, you mean?
03:13:50 <lispy> (I'm happy to define A <- B as B -> A, is what I mean)
03:13:51 * ski_ thinks type isomorphism proofs should also include proofs that the morphisms provided are inverses of each other
03:13:53 <vixey> well yeah, A <- B can be notation for B -> A if you want
03:15:13 <ski_> also, sometimes i'd like notation like `(a : A) <-{ R a b }-> (b : B)'
03:15:44 <lispy> ski_: that reminds me...i had just taken a year of graduate algebra and a CS friend said, "Hey those are isomorphic" and I immeditaly said, "Oh, what homomorphism do you use and are you sure it's invertible?" and he just looked at me crestfallen...this way I learned that isomorphism gets tossed around too much without justification :)
03:16:27 <ski_> (instead of `((a : A) -> (b : B) * R a b) * ((b : B) -> (a : A) * R a b)' .. probably plus some extra cruft to guarrantee these two parts cohere)
03:16:39 <vixey> lispy, actually.. you know how alpha-beta-equality is decidable for simply typed lambda calculus -- this is the conversion rule (called definitional equility) that lets something like  f x  typecheck when f :: A -> B and x :: (\p q -> q) Y A for example
03:17:04 <lispy> vixey: alpha-beta-equality?  not familiar :)
03:17:17 <vixey> \a -> a is alpha equal to \b -> b
03:17:18 * lispy has never actually studied type theory
03:17:28 <lispy> oh that alpha
03:17:33 <vixey> (\a -> a) x is beta equal to x
03:17:44 <lispy> beta = application?
03:17:48 <vixey> yes
03:18:45 <lispy> and what was eta again?  That's like, f = \x y -> ... == f x = \y ... == f x y = ... ?
03:18:53 <ski_> @pl \x -> f x
03:18:54 <lambdabot> f
03:18:59 <ski_> that's eta-reduction
03:18:59 <vixey> \x -> f x  is eta equal to  f
03:19:30 <vixey> if you add eta equality to the definitional equality of a type theory you will lose I think canonicity
03:19:39 <vixey> something goes haywire anyway..
03:19:55 <ski_> lispy : you might be thinking of the related `functional completeness' : `(forall x. f x = g x) => (f = g)'
03:19:58 <lispy> vixey: so you said x :: (\p q -> q) Y A, is that dependent typing? the (\p q -> q) looks like a value to me
03:20:30 <vixey> lispy, since types are values, you can just use the normal lambda to write type level programs
03:20:37 <vixey> so Y and A :: *
03:20:52 * dcoutts is hacking on a typed FilePath wrapper module
03:21:05 <vixey> but the type of x is alpha-beta-equal* to the domain of f
03:21:11 <ski_> (`(\p q -> q)' would presumable be a type abtraction here .. think like `\w -> Writer w a')
03:21:17 <dcoutts> distinguishing relative and absolute filepaths, eg abs </> abs makes no sense
03:21:58 <lispy> dcoutts: yeah, I was just telling the darcs-users list recently that's a problem with filepath
03:22:04 <vixey> (*in a real system they don't check equality so much as the type of x is < the domain of f)
03:22:20 <dcoutts> lispy: aye, I'm sure I've had bugs in Cabal due to this
03:23:18 <lispy> dcoutts: so you're just newtyping String to add information about being absolute or relative?
03:23:38 <dcoutts> lispy: yes, but then some ops need a type class, like </>
03:24:05 <dcoutts> (</>) :: SomeClass path => path -> RelativeFilePath -> path
03:24:07 <lispy> dcoutts: in that case you could use phantom types
03:24:32 <ski_> is '</>' left- or right-associative ?
03:24:35 <dcoutts> lispy: maybe, but the point is only certain combinations are correct, and we need a class to record that
03:24:48 <lispy> dcoutts: then gadts :)
03:25:14 <dcoutts> this needs to be portable :-)
03:25:23 <lispy> dcoutts: a type class isn't closed unless you use a trick of having a hidden class that is required to make the instance
03:25:30 <dcoutts> exactly
03:25:49 <dcoutts> anyway, I'm not that worried about deliberate subversion, just accidental
03:25:58 <lispy> True
03:26:09 <vixey> :i (</>)
03:26:29 <lispy> vixey: yeah, I've been thinking lambdabot should have :i to match having :t
03:26:41 <lispy> ?index (</>)
03:26:42 <lambdabot> Text.Html
03:26:50 <lispy> ?hoogle (</>)
03:26:50 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
03:26:50 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
03:27:06 <ski_> meep ?
03:27:23 <ski_> are those looking in different databases ?
03:27:36 <lispy> ski_: I think so yes
03:28:09 <lispy> ski_: iirc hoogle depends on data from haddock?
03:28:16 <lispy> ski_: I don't know what index uses
03:29:43 <Saizan_> dcoutts: in this case you can do without the class: newtype FP x = FP String, (</>) :: FP any -> FP Relative -> FP any
03:30:24 <dcoutts> Saizan_: true, I'm just checking the other ops
03:34:34 <lispy> I just updated this page, can someone look over it and tell me if it's accurate? http://en.wikipedia.org/wiki/Intuitionistic_type_theory#Extensional_versus_intensional
03:34:36 <lambdabot> http://tinyurl.com/72uku
03:38:14 <vixey> lispy, the stuff about turing complete and all that I don' think that should be mentioned
03:39:12 <lispy> vixey: That's the part I added -- the problem with the previous version is that it doesn't explain why extensional is undecidable
03:39:23 <vixey> and should it say "type theories" instead of "programming languages"?
03:39:36 <lispy> vixey: so if my explanation using TC is wrong, help me figure out the reason :)
03:40:24 <lispy> vixey: okay, I made the 'type theories' edit
03:40:48 <lispy> vixey: how would you explain why extensional is undecidable?
03:45:51 <vixey> lispy, I think typechecking is decideable for extentional type theories
03:46:08 <vixey> lispy, but you must give a type checking derivation
03:47:27 <vixey> I'm not having luck finding any reference for that
03:47:56 <lispy> vixey: ah, that part about it being undeciable was already in the article
03:48:17 <vixey> I'd not trust wikipedia on stuff like this..
03:48:40 <lispy> vixey: I just mean...I didn't make that up, so if it's wrong I'm glad you spotted it :)
03:49:07 <ivanm> Wikipedia: "I can haz fakts plz? Kthx, bye"
03:49:09 <ivanm> ;-)
03:49:43 <lispy> wikipedia is only as accurate is its citations :)
03:49:59 <gio123> does somebody knows such discipline: Basic Introduction of Infinite Products
03:50:09 <lispy> So, I'd trust WP over, say, CNN :)
03:50:09 <ivanm> lispy: as in the xkcd comic? ;-)
03:51:11 * lispy tries to picture a CNN anchor person doing a story on intuitionistic logic
03:52:18 <kynky> wonder how many takes it would take for them to pronounce it
03:54:14 <ivanm> kynky: 10 times, and they'll still stuff it up
03:54:48 <ivanm> or else they'll pronounce "intuistic logic" right, but stuff the pronounciation of everything else up
03:55:12 <FalconNL> Can anyone tell me how to get the directory or path of a haskell program? readFile can't find the file when the compiled application is run from a different directory
03:55:15 <kynky> lol
03:55:50 <kynky> would be an enviromental variable ?
03:58:56 <FalconNL> hm, there's getProgName, but it only returns the leafname.
03:59:01 <jmg> hi
03:59:03 <lispy> FalconNL: System.Directory.getCurrentDirectory
03:59:26 <lispy> FalconNL: or maybe I didn't quite get what you mean.
03:59:42 <lispy> FalconNL: I don't think you can know, in unix, what path the executable exists at
03:59:49 <jmg> does anybody know why Control.Monad.State is not in MonadPlus?
03:59:54 <lispy> not from within the program itself anyway
04:00:06 <FalconNL> Let me try to explain
04:00:31 <FalconNL> Folder D:\test contains test.hs and test.txt. test.hs does readFile "test.txt" >>= putStrLn.
04:00:51 <FalconNL> when you compile the program and run test.exe from D:\test everything works correctly
04:01:05 <FalconNL> however, when I run test\test from D:, readFile fails
04:01:28 <FalconNL> since D:\ is then the current directory
04:01:49 <lispy> right
04:02:22 <lispy> getAppDataDirectory or something like that can be used
04:02:23 <FalconNL> so is there any way of telling it to look for test.txt in the same folder as the exe?
04:02:50 <lispy> FalconNL: I don't think you can ask the OS where the exe was located, I could be wrong, but I don't think it tells
04:03:27 <FalconNL> It must be possible somehow, since C# has Application.Path() or something along those lines
04:03:35 <macron> you can, using /proc, I think
04:04:19 <lispy> FalconNL: oh, here we go: Use GetModuleFileName() which gives you the full path of the Executable inlcuding the executable file name.
04:04:40 <lispy> FalconNL: so you need to find GetModuleFileName in System.Win32
04:07:13 <aleator> How hard would it be to make a hack like "IO () -> Filepath -> IO ()" which magically would produce executable file of the first IO () at the filepath?
04:07:42 <lispy> aleator: say what?
04:08:07 <aleator> I mean, given an IO action produce an executable file that executes it?
04:08:08 <lispy> FalconNL: I can't find the GetModuleFileName binding under System.Win32.  Maybe you have to use the FFI to write this yourself.
04:08:46 <ski_> jmg : which instance would you propose ?
04:09:07 <jmg> are there multiple?
04:09:18 <lispy> ?hoogle IO FilePath
04:09:19 <lambdabot> Did you mean: :: IO FilePath /count=20
04:09:19 <lambdabot> System.Process.Internals withFilePathException :: FilePath -> IO a -> IO a
04:09:23 <FalconNL> lispy: there's the function getModuleFileName, which is HMODULE -> IO String. Unfortunately hackage doesn't have documentation for System.Win32, so I'm trying to figure out how it works
04:09:25 <ski_> multiple what ?
04:09:35 <jmg> multiple possible instances?
04:09:39 <lispy> FalconNL: http://www.haskell.org/ghc/docs/latest/html/libraries/
04:09:40 <lambdabot> Title: Haskell Hierarchical Libraries
04:09:50 <jmg> or is there a possible instance at all?
04:10:13 <FalconNL> lispy: thanks
04:10:58 <ski_> jmg : maybe i should first query whether you're inquiring about `State s' or `StateT s m' ..
04:10:59 <jmg> ski_: I use MonadPlus usually as a kind of improved if then else construct by `mplus`ing possible monadic actions/values
04:11:18 <jmg> I am talking about State s
04:11:30 <ski_> how would `instance MonadPlus (State s)' work ?
04:12:02 <jmg> ah ok, I see the problem
04:12:15 <jmg> there is probably no way to detect a fail
04:12:25 <BONUS> it wouldnt, really
04:12:44 <lispy> FalconNL: I think you'll find this handy: http://stackoverflow.com/questions/119706/how-to-get-my-own-codes-module-handle
04:12:50 <lambdabot> Title: How to get my own code's module handle? - Stack Overflow, http://tinyurl.com/57ppef
04:12:56 <ski_> @. djinn unmtl State s a
04:12:57 <lambdabot> -- f cannot be realized.
04:13:04 <ski_> @. djinn unmtl State s a -> State s a -> State s a
04:13:04 <lambdabot> Error: Undefined type State
04:13:13 <ski_> @djinn (s -> (a,s)) -> (s -> (a,s)) -> (s -> (a,s))
04:13:14 <lambdabot> f a b c =
04:13:14 <lambdabot>     case b c of
04:13:14 <lambdabot>     (_, d) -> case a c of
04:13:14 <lambdabot>               (e, _) -> (e, d)
04:13:39 <lispy> FalconNL: specifically, you'll want to do the haskell equivalent of GetModuleHandle(NULL) to get your handle to pass to getModuleFileName
04:14:13 <ski_> (however, that implementation of `mplus' is not vary sane, i'd say)
04:14:32 <jmg> no, it doesn't look so
04:15:07 <jmg> I guess the real problem is that fail is implemented as Prelude.error or Prelude.undefined
04:15:23 <ski_> however, possibly there's `instance MonadPlus m => MonadPlus (State s m)' ..
04:15:48 <jmg> you mean StateT s m ?
04:15:49 <ski_> why are you talking about `fail' ?
04:16:07 <ski_> (er, right, s/State/StateT/)
04:16:45 <FalconNL> lispy: success: getModuleHandle Nothing >>= getModuleFileName
04:16:47 <jmg> my intuition about MonadPlus is that allows me to `mplus` ing many possibly failing monadic actions
04:17:13 <jmg> and the semantics is to try each of it until one does not fail
04:17:15 <FalconNL> thanks everyone
04:20:06 <lispy> FalconNL: congrats :)
04:20:24 <ski_> @wiki MonadPlus
04:20:24 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
04:20:33 <ski_> @wiki MonadPlus_reform_proposal
04:20:33 <mikv> roconnor, ping
04:20:33 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
04:20:34 <Twey> getModuleHandle?
04:20:37 <EvilTerran> jmg, i think that fits the idea that mzero is the left- and right-identity of mplus
04:20:38 <Twey> @index getModuleHandle
04:20:38 <lambdabot> bzzt
04:20:41 <ski_> jmg : ^
04:20:45 <mikv> help?
04:21:12 <EvilTerran> well, assuming (fail s) is also a left-identity of mplus
04:22:31 <mikv> See http://hpaste.org/12295#a3, i am confused with almost identical lines #22-32 in this listing. How can i avoid this duplicate?
04:23:36 <jmg> fail s should be a left zero, or not?
04:25:50 <mikv> jmg, sorry. What do you mean?
04:28:27 <jmg> mikv: EvilTerrain said (fail s) would be left-identity of mplus, which means: (fail s) `mplus` m == m, while I think it should be a left-zero, which means: (fail s) `mplus` m == fail s
04:28:58 <EvilTerran> jmg, (fail s) should be left-zero of >>=, but a left-id of mplus, surely?
04:29:25 <jmg> EvilTerran: ups, yes you are right
04:29:28 <EvilTerran> @check \xs -> fail "blargh" `mplus` (xs :: [Int]) == xs
04:29:30 <lambdabot>   "OK, passed 500 tests."
04:29:40 <EvilTerran> @check \xs -> fail "blargh" >>= (xs :: [Int]) == fail "blargh"
04:29:42 <lambdabot>   Couldn't match expected type `a -> m b'
04:29:57 <EvilTerran> @check \xs -> fail "blargh" >>= const (xs :: [Int]) == fail "blargh"
04:29:58 <lambdabot>   Couldn't match expected type `a -> m b'
04:30:19 <EvilTerran> @check \xs -> (fail "blargh" >>= const (xs :: [Int])) == fail "blargh"
04:30:20 <lambdabot>   "OK, passed 500 tests."
04:30:28 <EvilTerran> there we go. durn precedence.
04:30:44 <dolio> @pl (>>= const m)
04:30:45 <lambdabot> (>> m)
04:31:14 <EvilTerran> i know, i know. i was illustrating a property of >>=, though, so i wanted >>= to textually appear
04:32:22 <dolio> @check \f -> (fail "foo" >>= (f :: Int -> [Int])) == fail "foo"
04:32:23 <lambdabot>       Overlapping instances for Show (Int -> [Int])
04:32:24 <lambdabot>        arising from a use...
04:32:36 <EvilTerran> buh
04:32:45 <dolio> Someone should fix that.
04:33:02 <EvilTerran> that's a completely counter-intuitive error
04:33:14 <dolio> Well...
04:33:19 <dolio> > \x -> x + 1
04:33:20 <lambdabot>       Overlapping instances for Show (a -> a)
04:33:20 <lambdabot>        arising from a use of `s...
04:33:46 <dolio> If there weren't overlapping instances for function showing, "@check \f -> ..." would work.
04:34:18 <EvilTerran> why does it need a Show instance?
04:34:34 <Saizan_> it wants to print arguments in the case a test fails
04:34:35 <dolio> It shows failure cases.
04:34:39 <EvilTerran> ahhh, of course
04:36:46 <dolio> That proof of the monad laws for vectors turned out to be a lot harder than I thought.
04:36:54 <dolio> I still haven't gotten associativity.
04:37:37 <dolio> 'Course, it doesn't help that I have to restart agda every so many reloads to clear up all the memory it's eating.
04:39:09 <vixey> ugh Agda is s obloody slow
04:39:37 <vixey> maybe Haskell will get a GC one day
04:39:39 <vixey> :D
04:40:03 <SubStack> @pl (\i -> replicate i i)
04:40:03 <lambdabot> join replicate
04:40:07 <SubStack> orite
04:41:40 <dolio> Yeah, it never seems to release any memory.
04:42:00 <lispy> can you guys explain this bet of Oleg to me: Dictionaries at run time reect context reductions at compile time,
04:42:03 <lispy> in a shining instance of the Curry-Howard correspondence.
04:42:05 <dolio> And the more complex proofs you write, the quicker it gets eaten.
04:42:30 <vixey> I wish they did something like proof general only checking the new bit of code you wrote
04:42:52 <vixey> I don't use agda enough it implement it though
04:43:07 <lispy> what is a context reduction at compile time and how is that a shining example of curry-howard?
04:43:31 <dolio> It manages to do that when you use C-space to insert something from a shed. But nowhere else.
04:44:43 <Saizan_> context reduction might be when you resolve a typeclass context to a particular instance?
04:45:24 <lispy> Saizan_: okay
04:45:30 <Raevel> is there a built-in function similar to this? (a,b) -> (a -> c,b -> d) -> (c,d) or am i dreaming? lambdabot didn't find it
04:45:46 <Saizan_> constructing and passing the appropriate dictionary can be seen as the proof that the context holds
04:45:52 <lispy> ?hoogle (a,b) -> (a -> c, b -> d) -> (c,d)
04:45:52 <lambdabot> No results found
04:45:58 <vixey> Raevel, I call it $$
04:46:04 <lispy> Raevel: looks like something people might use arrows to accomplish
04:46:05 <vixey> wait no I don't
04:46:06 <dolio> There'll be one in category-extras, called bimap or something.
04:46:06 <EvilTerran> ?type uncurry (***)
04:46:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
04:46:19 <lispy> Saizan_: oh, okay
04:46:23 <dolio> Oh yeah, and (***) since it's tuples.
04:46:24 <EvilTerran> > (f *** g) (x, y) :: (Expr, Expr)
04:46:25 <lambdabot>   (f x,g y)
04:46:26 <vixey> Raevel, I call, (p -> d, q -> b) -> (p,q) -> (d,b), $$
04:46:35 * dolio is getting too sleepy.
04:47:15 <Raevel> yeah i remember ***, but what do i have to import to get it?
04:47:17 <vixey> Raevel, (you can see the similarity with $ :: (o -> e) -> o -> o)
04:47:22 <Deewiant> Raevel: it's in Control.Arrow
04:47:29 <vixey> e*
04:47:34 <Raevel> thank you thank you
04:49:56 <Raevel> how about..
04:50:11 <Raevel> @hoogle (a,a) -> (a -> b) -> (b,b)
04:50:11 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
04:50:11 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
04:50:11 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
04:50:34 <dolio> @type join (***)
04:50:35 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
04:50:35 <Raevel> oh my, i'm not touching that one
04:51:00 <dolio> @type flip $ join (***)
04:51:01 <lambdabot> forall b c. (b, b) -> (b -> c) -> (c, c)
04:51:19 <zimbatm> @pl (\x->(div x 2) + 1)
04:51:20 <lambdabot> (1 +) . flip div 2
04:51:34 <Raevel> @type join
04:51:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:52:11 <EvilTerran> Raevel, the most commonly used instance of Arrow is (->)
04:52:11 <Raevel> crazy stuff
04:52:32 <EvilTerran> join (***) :: Arrow (~>) => (b ~> c) -> (b,b) ~> (c,c)
04:52:57 <EvilTerran> > join (***) f (x,y) :: (Expr,Expr)
04:52:58 <lambdabot>   (f x,f y)
04:53:00 <Raevel> it looks like an arrow alright, but unfortunately i know nothing about arrows
04:53:18 <EvilTerran> you don't need to; there's only one behaviour that fits that type when (~>) = (->)
04:53:30 <EvilTerran> ?djinn (b -> c) -> (b,b) -> (c,c)
04:53:30 <lambdabot> f a (b, _) = (a b, a b)
04:53:37 <EvilTerran> er
04:53:46 <EvilTerran> bad djinn, no cookie!
04:53:51 <lispy> This paper is genius: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
04:53:53 <lambdabot> Title: Functional Pearl: Implicit Configurations
04:54:02 <lispy> I mean, really good.
04:57:23 <lispy> "We extend our family of types with a type constant Nil and a binary
04:57:23 <lispy> type constructor Cons, to build singly-linked lists at the type level.system into a dictionary: the expression
04:57:27 <lispy> "
04:57:38 <lispy> er, that paste stucks
04:57:40 <lispy> sucks*
04:57:52 <lispy> but, the point is, he turns arbitrary lists into types :)
05:00:33 <dolio> Type-level lists aren't exactly hot stuff.
05:00:38 <Saizan_> eheh, he goes beyond :)
05:00:45 <dolio> The fact that he does it for arbitrary Storable stuff is more ridiculous.
05:01:00 <dolio> (Or whatever it is like that that he actually does.)
05:01:55 <lispy> yeah, the type level lists of Storable is awesome
05:02:16 <lispy> Okay, so the reason type level lists is awesome is because that's not far from type level sets
05:02:35 <lispy> And I have a novel application for those
05:02:59 <Saizan_> being?
05:04:07 <lispy> Saizan_: it has applications to the darcs source code, if we could model sets of changes at the type level we could use the type checker to more accurately model invariants of patch theory than we currently do
05:04:38 <lispy> We currently can model many invariants, but it's only approximated by our types
05:04:51 <lispy> eg., there are times when our encoding isn't 100% accurate
05:05:02 <Phyx-> Hi, i was wondering if there was an easy way to get the types of the parameters of a constructor at runtime?
05:05:07 <lispy> This means that certain classes of bugs are avoided and others are not
05:05:22 <lispy> Phyx-: typse of the parameters?
05:05:39 <lispy> Phyx-: do you mean the types of a type constructor?
05:05:42 <lispy> data constructor?
05:05:48 <lispy> Phyx-: can you provide an example :)
05:05:53 <Phyx-> yeah, that
05:06:00 <Phyx-> a simple one, Foo Int
05:06:17 <Phyx-> data M = Foo Int | Rec M M
05:06:41 <lispy> Phyx-: well, in that case, anytime you pattern match on Foo you know that the argument to Foo is Int
05:06:43 <Phyx-> i can pass both Foo and Rec to a function, but in order to apply them, i need to know which types to give them
05:06:59 <Phyx-> well yes, but i don't have "a' specific case
05:07:02 <lispy> Foo :: Int -> M
05:07:38 <lispy> Phyx-: I'm afraid I still don't understand :(
05:08:17 <lispy> :t asTypeOf
05:08:18 <lambdabot> forall a. a -> a -> a
05:08:33 <lispy> > 1 `asTypeOf` (undefined :: Double)
05:08:33 <Phyx-> ok, say i have a function f :: a -> Int -> b
05:08:34 <lambdabot>   1.0
05:08:41 <lispy> okay
05:09:07 <thoughtpolice> hm, hacking lhc isn't so bad :]
05:09:26 * thoughtpolice has lots of stuff he would like to clean up...
05:09:58 <Phyx-> a would be a constructor, either Foo or Rec, the int is the number of arguments it has, and b is the result of when i apply the constructor to it's arguments. but in case of Foo i just make the argyment an int and pass it, in case of Rec i have to recursively apply f to the arguments
05:10:00 <lispy> Phyx-: the quick answer is that if you need type reflection, you probably want Data.Typeable, but please continue your example it's interesting
05:10:50 <Phyx-> but i want to pass arbitrairy constructors, aslong as they're from the same data type
05:10:59 <lispy> Phyx-: so the type of b is dependent on a and the value of Int?
05:11:15 <Phyx-> yes
05:11:46 <lispy> It will be hard to do this in a type safe way, as haskell doesn't have dependent types.  I think you could fake it in this case, if you really want static type safety, FWIW
05:12:09 <Saizan_> Phyx-: you've to represent the constructors explicitly for that
05:12:21 <Phyx-> well, i do have a preprocessor in which i construct the argument list, i guess i could just give it the types along
05:13:10 <lispy> thoughtpolice: you're the kind of contributor that maintainers love :)  The ones that come in with a broom and make it all pretty again :)
05:13:20 <lispy> thoughtpolice: want to hack on darcs ;)
05:14:51 <lispy> Phyx-: I've read 2 papers just today that show how natural numbers can be represented in Haskell types and such that you can make an input function type depend on them...so you might be able to get rid of your preprocessor if that interests you.  I can give links too...
05:16:02 <Phyx-> the preprocessor does some other work aswell :P so i can't get rid of it, lol. just generates boring code that i guess i could have done with template haskell or something. yeah, sure link me :)
05:20:07 <lispy> Phyx-: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.25.6103&rep=rep1&type=pdf
05:20:09 <lambdabot> Title: Functional Pearl: Implicit Configurations
05:20:23 <lispy> Phyx-: those are the papers I was reading today, the second one is an easier read
05:20:25 <EvilTerran> grr... i just got distracted from what i intended to be getting on with by playing with Mu Endo again
05:20:33 <Phyx-> lispy: cool, thanks, i'll take a look
05:20:52 <Phyx-> hmm
05:20:52 <mohbana> hi is there a FP newsgroup not specific to Haskell?
05:21:02 <Phyx-> i get a 404
05:21:19 <lispy> Phyx-: try this http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.6103
05:21:24 <lambdabot> Title: Do we Need Dependent Types - CiteSeerX
05:21:27 <lispy> Phyx-: there is a PDF link
05:21:51 <Phyx-> ah yeah that works :)
05:25:35 <EvilTerran> ?type let inE = In . Endo; infixl 9 ?; (?) = appEndo . out; k = inE (inE.const); s = inE$ \f -> inE$ \g -> inE$ \x -> f ? x ? (g ? x) in inE$ \x -> x ? k ? s ? k
05:25:36 <lambdabot> Mu Endo
05:25:46 <EvilTerran> it's the Rosser X combinator! :D
05:27:06 <EvilTerran> (x?x)?x = k; x?(x?x) = s
05:27:20 <Phyx-> ooh, this is an interesting read
05:27:34 <EvilTerran> and everything has type Mu Endo :P
05:31:51 <lispy> Phyx-: right, you could define ordinals like they do, zero, one, two, etc for your data constructor and then have f :: one -> ... -> b,
05:32:13 <lispy> Phyx-: the example involving zipWithN I think is isomorphic to allowing arbitrary data constructors
05:32:24 <EvilTerran> Mu (Either a `O` Endo) would be more interesting, as it'd actually have concrete values
05:34:16 <EvilTerran> i think you can only tell values of Mu Endo apart by their strictness
05:35:05 <EvilTerran> mohbana, there's #oasis
05:35:12 <EvilTerran> "Zenny channel about programming languages where *semantics* is the issue and *syntax* is ignored, where both concepts and pragmatics are of interest"
05:35:40 <mohbana> EvilTerran: i'm talking about a news group, which i can access via gname for instance
05:36:05 <EvilTerran> i figured, that was just the closest i could think of
05:36:10 <EvilTerran> they might be able to suggest a newsgroup
05:38:06 <lispy> mohbana: yeah, there is comp.something.functional
05:39:02 <lispy> mohbana: ah, comp.lang.functional
05:43:06 <vixey> is there any channel where syntax is the issue?
05:43:15 <mohbana> strange, it's not available via gmane
05:43:52 <idnar> EvilTerran: what is O?
05:44:29 <twanvl> vixey: you want a #haskell-bikeshed?
05:45:02 <lispy> mohbana: it is on groups.google.com maybe you can find it in other sources that way
05:45:16 <mohbana> thanks. by
05:45:17 <mohbana> e
05:45:44 <lispy> I can haz news group?  kthxbai
05:45:57 * lispy chuckles
05:49:06 <EvilTerran> idnar, newtype (f `O` g) a = O { unO :: f (g a) }
05:49:14 <EvilTerran> type composition
05:49:17 <idnar> ah
05:49:45 <EvilTerran> Mu (Either a `O` Endo) ~~ data T a = A a | F (T a -> T a)
05:51:06 <vixey> twanvl, I don't understand
05:51:33 * dcoutts points out a nice example where polymorphism and monomorphism is quite subtle sometimes http://hpaste.org/12299
05:52:25 <twanvl> syntax is one of those 'bikshed' issues, people can go on forever about what color the bikeshed should be painted
05:52:28 <vixey> twanvl, I'm interested in the syntactic approach to programming languages -- stuff like type systems, operational semantics, .. I wasn't referring to whether indentation matters or if 'let' should be renamed to 'bind'
05:53:38 <lispy> :t assert
05:53:39 <lambdabot> Not in scope: `assert'
05:53:44 <lispy> ?hoogle assert
05:53:45 <lambdabot> Control.Exception assert :: Bool -> a -> a
05:53:45 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
05:53:45 <lambdabot> Test.HUnit.Base class Assertable t
05:54:09 <vixey> > join assert False
05:54:10 <lambdabot>   Not in scope: `assert'
05:54:19 <vixey> > join Control.Exception.assert False
05:54:20 <lambdabot>   /tmp/9034694277197104280:70:37:
05:54:20 <lambdabot>      Not in scope: `Control.Exception.assert'
05:54:28 <EvilTerran> , src 'assert
05:54:33 <lunabot>  luna: Not in scope: `assert'
05:54:35 <EvilTerran> oh well
05:54:45 <EvilTerran> @let assert p x | p = x
05:54:46 <lambdabot>  Defined.
05:54:56 <RayNbow> dcoutts++
05:54:58 <RayNbow> @karma dcoutts
05:54:58 <lambdabot> dcoutts has a karma of 4
05:55:03 <EvilTerran> preflex: karma dcoutts
05:55:04 <preflex>  karma for dcoutts: 19
05:55:17 <EvilTerran> > join assert False
05:55:18 <lambdabot>   * Exception: <local>:5:0-17: Non-exhaustive patterns in function assert
05:55:20 <lispy> dcoutts: oh wow, I get it now.  That is pretty crazy
06:00:32 <dcoutts> lispy: we could have made the original explicit using scoped type vars
06:01:18 <dcoutts> though a bit tricky, since we'd have to capture the type of the result
06:01:37 <dcoutts> and scoped type vars are usually easier for capturing the types of the inputs
06:02:07 <EvilTerran> foo x y = ... `asTypeOf` (foo x y) ... ?
06:03:30 <dcoutts> EvilTerran: or foo x y = z where (z :: a) = ... (.. :: a)
06:03:44 <lispy> I think asTypeOf can be made to work
06:03:48 <lispy> at least in principle
06:03:54 <lispy> but usually lexically scoped types are easier
06:03:58 <Saizan_> yeah, abusing the MR
06:04:32 <Saizan_> with scoped type var you just need to put a forall in the type signature and add an annotation to p'
06:04:36 <dcoutts> lispy: I'm not sure I see how
06:04:48 <dcoutts> Saizan_: yes
06:05:28 <QplQyer> anyone ever had succes using checkinstall to install ghc, cabal etc. ?
06:05:32 <EvilTerran> yeah, actually, i think you do need to abuse the DMR to use `asTypeOf` in that way
06:05:37 <Saizan_> mkPath p = r where r = assert (pathInvariant ((Path p) `asTypeOf` r)) (Path p `asTypeOf` r)
06:05:51 <dcoutts> oh, cunning
06:05:52 <lispy> dcoutts: I didn't think of how to apply asTypeOf in your example, but I've heard that in Hasell98 that asTypeOf is supposed to cover pretty much any case that you can use lexically scoped type vars
06:06:46 <dcoutts> lispy: it's probably true, though I expect the examples are non-obvious like Saizan_ points out
06:07:16 <lispy> The place where asTypeOf gets weird is when you have phantom types and some of the phantoms are existentially quantified and you some should be equal...in that case I haven't figured out how to make asTypeOf work
06:08:53 <lispy> data F a x z where F :: a x y -> F a y z -> F a x z; if you have a value of F, like, F a as, then the x and z might need to be the same as something else, but y is existential so you can't just stick in an asTypeOf easily
06:09:12 <lispy> er x and y might need to be the same
06:09:20 <lispy> oh no I said it right
06:11:41 <dcoutts> lispy: http://hpaste.org/12299#a1
06:11:42 <ski_> lispy : can't you just invent `..(dom as `asTypeOf` cod fish).. where dom :: F a x y -> a; dom = undefined; ..' ?
06:12:48 <lispy> dcoutts: right
06:12:54 <lispy> ski_: I'm not sure :)
06:14:36 <Saizan_> e.g. if you've 'v' of type x and you've to annotate the head you can use toFst :: x -> a x t; toFst = undefined; and then F (a `asTypeOf` toFst v) as
06:15:09 <Saizan_> t is fully polymorphic so it unifies with y
06:17:22 <PeakerWork> Haskell's syntax is not context-free, right?  Otherwise:  Blah.x -- composition or module access?
06:17:33 <olsner> @pl \x -> f x (g $ h x)
06:17:33 <lambdabot> ap f (g . h)
06:18:08 <lispy> PeakerWork: syntax can be context-free even if the semantics require context
06:18:27 <lispy> PeakerWork: if the parser changes based on context then that is not context-free
06:18:28 <PeakerWork> lispy: if you define composition and module lookup to be the same grammar?
06:18:50 <vixey> :t join ((f? .) . (g? . h?))
06:18:51 <lambdabot> parse error on input `.'
06:19:04 <vixey> :t join ((?f .) . (?g . ?h))
06:19:05 <lambdabot> forall b c a b1. (?h::a -> b1, ?g::b1 -> a -> b, ?f::b -> c) => a -> c
06:19:13 <vixey> :t ap ?f (?g . ?h)
06:19:14 <lambdabot> forall b b1 c a. (?h::a -> b1, ?g::b1 -> c, ?f::a -> c -> b) => a -> b
06:19:17 <PeakerWork> lispy: otherwise, how do you not change the parser for those 2 cases?
06:19:21 <Saizan_> Blah.x is always "module lookup" btw
06:19:30 <Saizan_> if you want composition you've to add spaces
06:19:42 <PeakerWork> Saizan_: ah, that explains it. Yikes :)
06:19:58 <Saizan_> but haskell grammar is not context-free because of patterns, or the layout rule, iirc
06:20:19 <PeakerWork> Saizan_: layouts can be considered "under" the grammar, I'd guess (That's what Python syntax does)
06:20:27 <ski_> @type id.id
06:20:28 <lambdabot> forall a. a -> a
06:20:39 <PeakerWork> @type Just.Just
06:20:40 <lambdabot> Couldn't find qualified module.
06:20:47 <PeakerWork> @type (Just . Just)
06:20:48 <lambdabot> forall a. a -> Maybe (Maybe a)
06:20:48 <lispy> Saizan_: I think layout can be made context-free by having the indentation level changes emit tokens in the tokenizer
06:20:51 <ski_> @type id.Just
06:20:52 <lambdabot> forall a. a -> Maybe a
06:21:08 <vixey> @type Just.id
06:21:10 <lambdabot> Couldn't find qualified module.
06:21:10 <PeakerWork> lispy: that's what I meant, yeah
06:21:26 <Saizan_> yeah, i see
06:21:53 <Saizan_> also, are fixities of infix operators to be interpreted as in-grammar?
06:21:55 <lispy> GHC uses Happy/Alex so, I suspect that Haskell is context-free as a grammar, but maybe it requires conditional lexing?
06:22:32 <vixey> why does it matter which class the parser is in?
06:22:50 <lispy> vixey: it determines the tools you can implement it in?
06:23:01 <Saizan_> lispy: from discussions here no haskell compiler implements the grammar 100% correctly
06:23:11 <lispy> vixey: and possible by extension the asymptotic complexity of parsing it?
06:23:39 <lispy> Saizan_: interesting.
06:24:37 <Saizan_> sorear could give you more details..
06:28:45 <thoughtpolice> @message Lemmih i've replaced lhc's readline with haskeline support since I was having issues with readline anyway; this is one thing for portability. also I got a profiled build going and here are the reports of compiling 'hello world': http://thoughtpolice.stringsandints.com/code/lhc-tests/lhc.prof
06:28:46 <lambdabot> Maybe you meant: messages messages?
06:28:57 <thoughtpolice> @tell Lemmih i've replaced lhc's readline with haskeline support since I was having issues with readline anyway; this is one thing for portability. also I got a profiled build going and here are the reports of compiling 'hello world': http://thoughtpolice.stringsandints.com/code/lhc-tests/lhc.prof
06:28:57 <lambdabot> Consider it noted.
06:37:05 <thoughtpolice> @tell Lemmih actually here - http://thoughtpolice.stringsandints.com/code/lhc-tests/hello-world/
06:37:06 <lambdabot> Consider it noted.
06:46:17 <Phyx-> hmm another dumb question, is there a way to say, apply f :: a -> a-> a -> a on for instance [1..3], so every element in the list is an argument. i could do it by writing a function to do it, but i was wondering if there's a build in way
06:47:10 <Saizan_> no, there isn't
06:47:21 <Phyx-> to bad, *writes*
06:53:09 <lispy> :t foldl ($)
06:53:10 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
06:53:10 <lambdabot>     Probable cause: `$' is applied to too many arguments
06:53:10 <lambdabot>     In the first argument of `foldl', namely `($)'
06:53:53 <lispy> :t \f -> foldl (f $)
06:53:54 <ka> Why does  map p [2]  not invocate p with [2] and pass the return value to map?
06:53:54 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:54:05 <ka> And instead pass p as an argument to map along with [2]
06:54:27 <opqdonut> ka: because application associates to the left
06:54:39 <ka> ah
06:54:41 <opqdonut> f g h x is (((f g) h) x)
06:54:42 <lispy> :t \f -> foldl1 (f $)
06:54:43 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:54:50 <opqdonut> which can be a bit confusing at first
06:54:58 <opqdonut> but it works wonderfully with currying
06:55:00 <lispy> :t \f -> foldr1 (f $)
06:55:01 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:55:05 <ka> And whats is $ ?
06:55:12 <opqdonut> $ is just application
06:55:13 <lispy> ?src ($)
06:55:13 <lambdabot> f $ x = f x
06:55:17 <opqdonut> but with a low precedence
06:55:21 <opqdonut> so you can say stuff like:
06:55:30 <opqdonut> f . g . h $ x
06:55:37 <opqdonut> instead of f (g (h x))
06:55:55 <lispy> Phyx-: so, you could do the thing you just asking using the stuff in that paper that asks if dependent types are needed
06:57:01 <vixey> well you can also write
06:57:02 <lispy> Phyx-: you need a function like foldr but with a type like (a -> b) -> [a] -> b, where b can be equal to things like (a -> b'), where b' is equal to things like (a -> b'') where ...
06:57:11 <lispy> Phyx-: at least, I think that could work :)
06:57:13 <vixey> apply f [x,y,z,w] = Just (f x y z w) ; apply _ _ = Nothing
06:57:36 <Phyx-> lispy: no, because i think in my case it was impossible to do with the way i had it basically it was trying to return a String or Int ot Float or Function and there's no type to satisfy that
06:58:25 <Phyx-> i'm gonna ask the teacher tomorow, but it seems to me, that the function misses information..
06:58:25 <rwbarton> Phyx-: you can do it using typeclass magic
06:58:32 <lispy> Phyx-: foo :: Typeable a => [b] -> a, ?
06:58:42 <Phyx-> oh?
06:58:51 <Phyx-> *reads up on typeable
06:59:06 <Phyx-> that would kinda make like alot easier
06:59:06 <lispy> ?instances Typeable
06:59:07 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
06:59:15 <lispy> ?instances Data.Typeable
06:59:16 <lambdabot> Couldn't find class `Data.Typeable'. Try @instances-importing
06:59:19 <lispy> bah
06:59:33 <vixey> you can do it without typeclasses too
06:59:52 <Phyx-> vixey: how so?
06:59:59 <rwbarton> ah yes, if you are willing to use a terminator symbol
07:00:24 <Phyx-> hm? what do you mean?
07:00:51 <opqdonut> or just with something like data Fun a b = Fun { givemore :: a->Fun a b, doit :: b}
07:00:53 <rwbarton> Oh actually, I was thinking of the reverse problem (passing several arguments to a function that wants a lits)
07:04:42 <vixey> *Main> apply (+) (Cons 1 (Cons 2 Nil))   3   *Main> apply (id) (Cons "foo" Nil)  "foo"
07:06:51 <vixey> except apply apply (Cons (+) (Cons (Cons 1 (Cons 2 Nil)) Nil)) gives a type error :(
07:07:04 <Phyx-> what's apply?
07:07:21 <vixey> apply has the obvious definition
07:07:53 <vixey> apply x Nil = x ; apply f (Cons x xs) = apply (f x) xs
07:08:23 <vixey> Phyx-, the puzzle is t o make it typecheck :)
07:08:37 <vixey> annoying that it can't be used to apply for itsself
07:09:20 <lispy> :t \f -> map (f $)
07:09:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:10:18 <lispy> > let apply f = map (f $) in apply (,,,) [1,2,3,4]
07:10:19 <lambdabot>       Overlapping instances for Show (b -> c -> d -> (a, b, c, d))
07:10:19 <lambdabot>        ari...
07:11:28 <lispy> oh right
07:11:32 <lispy> [b]
07:12:40 <lispy> ?hoogle (a -> b) -> [a] -> b
07:12:40 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
07:12:40 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
07:12:40 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:12:46 <lispy> ?hoogle (a -> b) -> [a] -> c
07:12:46 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
07:12:47 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
07:12:47 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
07:13:07 <ski_> @pl (f $)
07:13:07 <lambdabot> f
07:13:09 <Phyx-> well, what i have, is something like http://hpaste.org/12301
07:13:35 <vixey> Phyx-, using a GADT?
07:14:14 <Phyx-> vixey: no
07:14:21 * ski_ had a GADT idea ..
07:14:27 <vixey> it looks like that does't typechekc
07:14:29 <ski_>   data Context :: * -> * -> *
07:14:35 <ski_>     where
07:14:41 <ski_>     Here :: Context t t
07:14:49 <ski_>     Apply :: Context t (a -> b) -> a -> Context t b
07:14:55 <Phyx-> vixey: yes, that's my whole problem :P
07:14:55 <ski_>   apply :: Context t u -> (t -> u)
07:15:01 <ski_>   apply Here t = t
07:15:02 <vixey> Phyx-, So GADT can solve this
07:15:03 <ski_>   apply (Apply a c) t = apply c t a
07:15:16 <Phyx-> http://www.haskell.org/haskellwiki/GADT right?
07:15:17 <vixey> ski_, yeah, that's excatly what I have Nil and Cons .. :)
07:15:28 <lambdabot> Title: Generalised algebraic datatype - HaskellWiki
07:15:36 <ski_> vixey : oh ? .. i didn't notice
07:15:47 <vixey> ski_, (I didn't say just showed use)
07:17:43 <ski_> vixey : so your `apply (++) (Cons "a" (Cons "b" Nil))' would give `"ab"' or `"ba"' ?
07:17:56 <vixey> "ab"
07:18:01 <EmielRegis> oh hello
07:18:08 <EmielRegis> i desperately need your help guys
07:18:16 <lispy> oh hai
07:18:21 * vixey didn't use a snoc list
07:18:22 <lispy> invisible question!
07:18:25 <EmielRegis> my program based on Data.Map is somehow leaking,  or rather not releasing memory
07:18:26 <ski_> vixey : ok .. so your variant is "inside-out" wrt mine
07:18:56 * ski_ merely encoded `C[] ::= [] | [] E' ..
07:19:02 <ski_> er
07:19:02 <vixey> irritatingly, apply apply (Cons (+) (Cons (Cons 1 (Cons 2 Nil)) Nil)) seems to not work for eithe
07:19:07 <ski_>   C[] ::= [] | C[] E
07:19:08 <lispy> EmielRegis: I've heard people talk Data.Map being strict in the keys but not the values.  Sometimes people finds that it helps if they force the evalutaion of the values as they insert them.
07:19:22 <EmielRegis> well, I dont even isnert them
07:19:24 <EmielRegis> i use a singleton
07:19:27 <EmielRegis> then union it together
07:19:34 <EmielRegis> but the memory usage grows exponentially
07:19:37 <lispy> EmielRegis: I think they use ($!) for this
07:19:43 <lispy> :t ($!)
07:19:44 <lambdabot> forall a b. (a -> b) -> a -> b
07:19:47 <EmielRegis> if i use same code with lists, I get maximum of 5MB of usage
07:19:52 <EmielRegis> with data.map, it grows to 1.5GB
07:19:53 <EmielRegis> :|
07:20:17 <EmielRegis> http://hpaste.org/12302
07:20:28 <EmielRegis> thats my code, the main leaking function is the one applying HDR
07:20:46 <EmielRegis> id appreciate help as i tried to fix this silly thing for ages -.-
07:20:47 <lispy> EmielRegis: try foldl'
07:21:01 <lispy> :t foldl1'
07:21:02 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:21:18 <lispy> EmielRegis: foldl1 being lazy is a common source of leaks
07:21:18 <EmielRegis> wots the difference?
07:21:23 <EmielRegis> ahh
07:21:25 <lispy> but foldl1' is strict
07:22:16 <lispy> EmielRegis: also, you must have a very wide screen to write the code like that :)
07:22:22 <EmielRegis> yea i do :p
07:22:46 <EmielRegis> what library is foldl1' in?
07:23:21 <ski_> (s/a c/c a/)
07:24:04 <sebaseba> EmielRegis: hoogle says: Data.List
07:25:36 <shapr> @users
07:25:37 <lambdabot> Maximum users seen in #haskell: 558, currently: 519 (93.0%), active: 19 (3.7%)
07:25:52 <rwbarton> EmielRegis: I suggest not using tabs.  Especially like this. :)
07:26:02 <rwbarton> EmielRegis: What is your editor tab indent, like 1 or something?
07:26:08 <EmielRegis> probably
07:26:11 <EmielRegis> but i still get leaks ;(
07:26:19 <rwbarton> Yeah but we can't read your code :P
07:26:54 <EmielRegis> tahts notepad++ fault:P
07:27:49 <Phyx-> yeah
07:27:54 <Phyx-> wish you could turn that off
07:28:08 <Phyx-> notepad++ repeatedly gets me in hot waters with ghc
07:33:30 <EmielRegis> http://hpaste.org/12303
07:33:34 <EmielRegis> thats code with less tabs :p
07:33:51 <ka> With function = f . g   does the function composition automatically get passed an argument to 'function'?
07:33:56 <EmielRegis> gosh i hate doing pixel array stuff in haskell ;/
07:34:08 <vixey> ka, function x = (f . g) x = f (g x)
07:36:56 <rwbarton> EmielRegis: Does this code really work?
07:37:04 <EmielRegis> it does
07:37:10 <EmielRegis> but it uses way too much memory
07:37:17 <rwbarton> EmielRegis: You write ... where x' = x + fromIntegral off where x' :: Word16 and off :: Int
07:37:23 <rwbarton> but off might be negative
07:37:37 <rwbarton> > 3 :: Word16 + fromIntegral ((-2) :: Int)
07:37:38 <lambdabot>   <no location info>: parse error on input `-'
07:38:02 <rwbarton> > (3 :: Word16) + fromIntegral ((-2) :: Int)
07:38:03 <lambdabot>   1
07:38:11 <rwbarton> > (3 :: Word16) + fromIntegral ((-6) :: Int)
07:38:13 <lambdabot>   65533
07:38:13 <EmielRegis> (x') >= 0
07:38:24 <EmielRegis> urgh O-o
07:38:31 <rwbarton> I think that 65533 is your memory usage problem
07:38:37 <EmielRegis> well i actualyl changed ints to word16 to combat the battle of memory usage..
07:38:42 <EmielRegis> as it was leaking before too
07:39:23 <EmielRegis> moreover, it leaks a lot on renderRow function aswell
07:39:30 <EmielRegis> and it doesnt involve any of these calculations
07:39:31 <EmielRegis> ;/
07:40:12 <rwbarton> Well, just see whether your output contains pixels you didn't expect to be there I guess
07:41:16 <EmielRegis> rwbarton, no it doesnt. because at the moment im checking with just render function alone, with no HDR added, and it crashes on memory after eating all RAM and VRAM ;/
07:43:54 <ski_> vixey : apply (Here `Apply` (Here `Apply` 'a' `Apply` "b") `Apply` (:)) apply  -- works on this end ..
07:47:06 <BrokenClockwork> hey, is it possible to reload the currently file in GHCi?
07:47:19 <vixey> fus
07:47:21 <vixey> yes
07:47:23 <shapr> :r
07:47:23 <EmielRegis> :l <file>
07:47:32 <vixey> :middle
07:47:37 <ski_> :r #haskell
07:47:43 <shapr> :neartheend
07:47:45 <EmielRegis> oh lul
07:47:49 <EmielRegis> i didnt know about :r
07:48:28 <shapr> :! echo "hello ski!"
07:48:39 <BrokenClockwork> :r is good thanks, this will do things much easier
07:49:03 <shapr> BrokenClockwork: What editor are you using?
07:49:33 <BrokenClockwork> notepad++
07:49:52 <BrokenClockwork> I wanted to use gedit from gnome, but there is no compiled for windows
07:50:06 <shapr> Ah
07:50:21 <shapr> If you were using emacs, I could suggest lots of extra goodies, but I won't trouble you with them now :-)
07:50:29 <ski_> > appendFile "/home/shapr/.profile" "hej shapr !\n"
07:50:30 <lambdabot>   * Exception: "<IO ()>"
07:50:35 * shapr laughs
07:51:10 <shapr> /home/shae/.profile: No such file or directory
07:52:08 <shapr> write ski
07:52:10 <shapr> greetings!
07:52:12 <shapr> ^D
07:52:36 <olsner> shapr: I think you're misunderstanding something about IRC :P
07:52:42 <shapr> err, really?
07:52:45 * shapr laughs more
07:53:09 * shapr boings furiously
07:53:53 <shapr> So, what cool libs are on hackage lately?
07:53:54 * ski_ grins furiously
07:53:59 <shapr> hah
07:54:46 <vixey> not frisby  gr..
07:55:24 <olsner> heh, you could build some kind of social shell, like IRC but everything you type is commands, so you'd see e.g. "<olsner> [/home/olsner] ghc --make ..." and we all see what everyone else is doing
07:56:30 <thoughtpolice> would anyone happen to know off hand where i could find hbc 0.9999.5?
07:56:32 <shapr> If etherpad weren't so overloaded, I'd write a Haskell lib for that.
07:57:43 <shapr> It's too bad there's not some sort of http broadcast instant message service.
07:57:50 * shapr is joking, it already exists.
07:58:26 <olsner> there is a snapshot from 2003, which would seem to be newer than 0.9999.5
08:00:10 <shapr> When will we see ghc6.10 in debian?
08:00:40 <ski_> there seems to be `bin' packages for `hbc-0.9999.5b' at <http://www.cs.chalmers.se/pub/haskell/chalmers/>
08:00:54 <ski_> hm
08:01:06 <shapr> @Seen lennart
08:01:07 <lambdabot> I haven't seen lennart.
08:01:16 <ski_> @seen augustss
08:01:16 <lambdabot> I saw augustss leaving #haskell 1m 8d 14h 55m 52s ago, and .
08:01:19 <shapr> ah
08:02:10 <Botje> shapr: i've built a ghc 6.10 package for ubuntu
08:02:16 <skorpan> @pl \ps -> elol g $ map ($ps) (map eval fs)
08:02:16 <Botje> but i have no idea if it works
08:02:16 <lambdabot> elol g . flip map (map eval fs) . flip id
08:02:20 <Botje> and IANADD anyway :)
08:02:36 <shapr> I asked Lennart for the latest version of hbc sometime in the past few years, but I don't have anything in my Haskell archive dir.
08:03:34 <ddarius> http://haskell.org/haskellwiki/Implementations#HBI_and_HBC.2C_Chalmers.27_Haskell_Interpreter_and_Compiler
08:03:36 <lambdabot> Title: Implementations - HaskellWiki, http://tinyurl.com/y2epsa
08:03:46 <shapr> I also recently discovered that the Zeroth IOHCC is gone forever :-(
08:04:06 <lispy> shapr: I've heard debian will be shipping ghc 6.10 by the year 2013 +/- 1 year
08:04:12 <shapr> heh
08:04:23 <Botje> :t flip id
08:04:24 <lambdabot> forall b c. b -> (b -> c) -> c
08:05:24 <lispy> shapr: I'm kidding of course, but sadly I may be right
08:05:40 <shapr> heh, I hope not
08:05:55 <surgeon> hi all, I want to read a file from Stdin and I want to stop reading in, when the end of the file is reached, that's a EOF signal? how do I do this in haskell?
08:06:10 <shapr> surgeon: Have you seen Real World Haskell?
08:07:14 <lispy> surgeon: if your input buffer is set correctly you could use interact i believe
08:07:17 <lispy> :t interact
08:07:18 <lambdabot> (String -> String) -> IO ()
08:07:36 <lispy> or getContents
08:07:40 <lispy> :t getContens
08:07:41 <lambdabot> Not in scope: `getContens'
08:07:42 <lispy> :t getContents
08:07:43 <lambdabot> IO String
08:08:12 <lispy> and by input buffer, I meant input buffering
08:09:21 <surgeon> is there somewhere a good online reference where I find getcontents and interact?
08:09:38 <shapr> @src interact
08:09:39 <lambdabot> interact f = do s <- getContents; putStr (f s)
08:09:46 <shapr> @src getContents
08:09:47 <lambdabot> getContents = hGetContents stdin
08:09:49 <shapr> hmm
08:10:40 <surgeon> so input <-getContents, gives me input from stdin?
08:11:52 <Beelsebob> interact would be much neater as putStr . f
08:11:57 <Beelsebob> =<< getContents
08:12:05 <surgeon> shapr: ah thanks, that works great
08:13:37 <shapr> surgeon: Also there's:
08:13:42 <shapr> @index getContents
08:13:43 <lambdabot> System.IO, Prelude
08:13:48 <shapr> @docs Prelude
08:13:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
08:13:56 <surgeon> ah great
08:14:01 <Deewiant> @source Prelude
08:14:02 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
08:14:09 <surgeon> @docs getContents
08:14:10 <lambdabot> getContents not available
08:14:20 <surgeon> @docs Prelude.getContents
08:14:20 <lambdabot> Prelude.getContents not available
08:14:36 <shapr> surgeon: If you want to do lots of lambdabot traffic, it's better to do it private messages.
08:14:47 <surgeon> ah ic, thanks for your help!
08:15:11 <shapr> surgeon: There's also an embedding of lambdabot into ghci, called GHCi On Acid. I haven't tried it lately though, I don't know how difficult it is to install.
08:16:59 <ddarius> > 1.8*cos(pi/3)
08:17:01 <lambdabot>   0.9000000000000002
08:18:02 <Deewiant> > cos(-pi/3) :: CReal
08:18:04 <lambdabot>   -0.5
08:18:44 <BrokenClockwork> I tried to use _ as my wildcard for variables, but the compiler complains: Pattern syntax in compression syntax. What does that mean?
08:19:01 <shapr> BrokenClockwork: Can you hpaste your source?
08:19:15 <Deewiant> > let x :: Floating a => a; x = cos(-pi/3) in (x :: Float, x :: Double, x :: CReal)
08:19:16 <lambdabot>   (0.49999997,0.5000000000000001,-0.5)
08:19:19 <Cale> BrokenClockwork: compression syntax? Comprehension?
08:19:33 <BrokenClockwork> in expression
08:19:35 <BrokenClockwork> sorry
08:19:46 <rwbarton> > cos (-pi/3) :: CReal
08:19:47 <lambdabot>   -0.5
08:19:49 <rwbarton> Oops!
08:20:05 <Cale> BrokenClockwork: Oh, _ is a pattern, but not a valid identifier name.
08:20:10 <rwbarton> > cos (-0.01) :: CReal
08:20:11 <lambdabot>   0.9999500004166652777802579337522066732125
08:20:22 <vixey> am I supposed to know cos (-pi/3) off by heart?
08:20:30 <vixey> > cos (-pi/3)
08:20:30 * shapr hugs vixey 
08:20:30 <BrokenClockwork> http://hpaste.org/12304
08:20:31 <lambdabot>   0.5000000000000001
08:20:36 <BrokenClockwork> it's the last function
08:20:48 <vixey> shapr, :))
08:21:03 <BrokenClockwork> I need a dummy
08:21:14 <shapr> BrokenClockwork: Why?
08:21:21 <vixey> BrokenClockwork: type MyInt = Either () (Bool, Natural)
08:21:47 <rwbarton> > (cos (-0.488) :: CReal, cos (-0.489) :: CReal)
08:21:48 <lambdabot>   (0.8832723450938337546341641423727749738296,-0.8828030432534624684421409262...
08:21:51 <vixey> BrokenClockwork: even better data Int = Z | I Int | O Int
08:22:02 <Cale> BrokenClockwork: guards are supposed to be expressions which evaluate to a Bool
08:22:05 <Deewiant> rwbarton: Heh.
08:22:25 <BrokenClockwork> oh, k
08:22:36 <Cale> BrokenClockwork: also, there are tabs in this file
08:22:52 <Cale> BrokenClockwork: Make sure that you configure your editor to automatically convert them to spaces.
08:22:53 <BrokenClockwork> not recommended?
08:23:32 <Deewiant> Looking at how you're using them it's fine, just be careful.
08:23:33 <shapr> tabs can cause difficulties.
08:23:36 <Cale> Yeah, since Haskell is layout sensitive (and *alignment* sensitive, not just indentation), it's important not to have characters which are interpreted as different amounts of indentation.
08:24:07 <Cale> The compiler will always treat them as aligning to the next 8-space multiple.
08:24:09 <Deewiant> Or, it's important to use such characters with great care. It's much easier to use spaces, though, which is why people suggest it.
08:24:35 <Cale> There's no value in putting hard tabs in your source file, and it can only cause problems.
08:25:34 <olsner> so much tab hate in the world :)
08:25:53 <BrokenClockwork> lol
08:25:53 <Deewiant> The value is configurable indentation width and minor savings in disk space.
08:26:09 <Cale> I think the tab character should be abolished.
08:26:20 <Deewiant> I think it should be embraced. :-P
08:26:36 <skorpan> i think we all should just stick to A-Z, 0-9 and whitespaces
08:26:37 <Cale> I wouldn't mind seeing it treates as a lexical error by the compiler.
08:26:44 <Cale> treated*
08:26:44 <Deewiant> BrokenClockwork: But I still use spaces in Haskell because it's just so damn alignment-careful.
08:26:45 <olsner> {\t} <-- embrace the tab :)
08:27:05 <ski_> (olsner : there's also <http://darcs.augustsson.net/Darcs/hbc/> if you didn't know about that)
08:27:06 <BrokenClockwork> well :)
08:27:09 <Deewiant> Cale: -Wtabs -Werror. ;-)
08:28:44 <BrokenClockwork> When I use a tuple and I only want to treat one part of the tuble how can I ignore the other part without using any values for it?
08:29:01 <vixey> BrokenClockwork, foo (a,_) = ...
08:29:10 <dino-> BrokenClockwork: You can pattern match with _ like: (partIWant, _, _)
08:29:23 <vixey> oh but don't use a 3 tuple only 2 tuples
08:29:26 <BrokenClockwork> but why didn't it work with my implementation?
08:29:34 <dino-> vixey: Just for illustrative purposes.
08:29:35 <Cale> BrokenClockwork: Because you put it inside a guard.
08:29:40 <BrokenClockwork> ah
08:29:46 <BrokenClockwork> gnah
08:29:54 <BrokenClockwork> okay now I got it
08:30:45 <nominolo> @unpl foldr (ap . ap (return (:)) . g) (return [])
08:30:46 <lambdabot> foldr (\ c i -> ((return (:)) >>= \ o -> (g c) >>= \ n -> return (o n)) >>= \ e -> i >>= \ d -> return (e d)) (return [])
08:30:59 <nominolo> @unpl ap . ap (return (:)) . g
08:30:59 <lambdabot> (\ c i -> ((return (:)) >>= \ o -> (g c) >>= \ n -> return (o n)) >>= \ e -> i >>= \ d -> return (e d))
08:31:08 <Deewiant> ?ty foldr (ap . ap (return (:)) . g) (return [])
08:31:09 <lambdabot> forall a (m :: * -> *) a1. (SimpleReflect.FromExpr (m a), Show a1, Monad m) => [a1] -> m [a]
08:31:15 <Deewiant> ?ty \g -> foldr (ap . ap (return (:)) . g) (return [])
08:31:16 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
08:32:04 <surgeon> I included one Module into another and uses ghc --make on the bottom one and now I get the error: file name does not match module name `Main', what does this mean?
08:32:45 <nominolo> surgeon: your module containing the 'main' function must be called Main
08:32:54 <surgeon> why that?
08:32:54 <nominolo> but the file doesn't have to be called Main.hs
08:33:10 <surgeon> nominolo: oh yeah, it is called Main
08:33:19 <nominolo> surgeon: if you're using GHC you can try using the -main-is option
08:33:42 <inimino> if GHC is going to find a module, the file name has to be the same
08:33:48 <surgeon> nominolo: now it says: no input file
08:34:11 <inimino> so maybe it's the included module that it can't find
08:34:13 <surgeon> yeah, the filenames are the same
08:34:14 <nominolo> inimino: except main, which is the thing you give as the argument to ghc --make
08:34:22 <dino-> Does it have to be called Main.hs if you have a "module Main where" in it? I've had difficulty with this leading to just not using a module declaration on the (often thin) "entry point" file.
08:34:23 <inimino> nominolo: right
08:34:41 <surgeon> this is my "Mean"-file
08:34:42 <dino-> I mean, leading me to just not use a module declaration..
08:34:52 <rwbarton> surgeon: does the imported module have a module declaration?
08:34:56 <surgeon> and then there are to other files in the folder: Mittelwerte.hs and CSVParser.hs
08:34:59 <inimino> dino-: no, you don't have to have any Main.hs
08:35:15 <surgeon> rwbarton: yes it has: "Module Mittelwerte where"
08:35:38 <surgeon> Mittelwerte.hs: http://rafb.net/p/KMoSRa13.html
08:35:41 <dino-> I'll try another test. I thought as soon as you put "module Main where" in it, it does have to be called that.
08:35:43 <lambdabot> Title: Nopaste - Mittelwerte.hs
08:36:32 <nominolo> surgeon: why is it spelled "Module" with a capital letter?
08:36:52 <surgeon> nominolo: ahh, thank you
08:37:23 <inimino> good catch
08:43:30 <surgeon> can I define a variable in a do block? like:
08:43:51 <surgeon> do print 7\\print 8\\let a = 9\\in\\print a
08:43:55 <vixey> yes
08:43:56 <opqdonut> do { let a = something; foo a }
08:44:02 <vixey> you don't write 'in' though
08:44:02 <opqdonut> or then just let...in
08:44:15 <Cale> surgeon: ; is the statement separator in do-blocks
08:44:20 <FunctorSalad> surgeon: you can also use "ghc --make -main-is MyModule" if you don't want to call it Main
08:44:25 <surgeon> ah ok
08:44:36 <surgeon> FunctorSalad: thanks
08:46:58 <FunctorSalad> you can also write do { a <- return something; foo a }
08:47:32 <FunctorSalad> didn't know 'let' was possible too :)
08:48:41 <Taejo> surgeon: just beware that if you change the -main-is flag, you probably should do a clean build (it tends to confuse the linker)
08:52:55 <ddarius> > 2*pi*.1
08:52:56 <lambdabot>   Not in scope: `*.'
08:53:00 <ddarius> > 2*pi* .1
08:53:01 <lambdabot>   <no location info>: parse error on input `.'
08:53:06 <ddarius> > 2*pi* 0.1
08:53:07 <lambdabot>   0.6283185307179586
08:53:09 <Taejo> > 2*pi* 0.1
08:53:10 <lambdabot>   0.6283185307179586
08:53:16 <dino-> Huh, I wonder if this changed at some point. I thought a while back I had seen problems if you use module Main where in a file not called Main.hs
08:53:33 <dino-> But it's just fine with it now not filename matching.
08:53:46 <Raevel> dino-: i never had that problem, at least
08:54:05 <Saizan__> it's a problem if you ask ghc to compile a module Main instead of specifying a file
08:55:01 <Saizan> dino-: how did it go with hscurses?
08:55:29 <dino-> Saizan: Oh, I didn't get to touch any of it this week.
08:55:45 <dino-> real work-work. bleh
08:55:53 <Saizan> heh
08:58:37 <ddarius> > let h x2 x1 (x0:xs) ~(y1:y2:ys) = (x0 - x2 + .9*y1 - .81*y2):h x1 x0 xs (y2:ys); g xs = fix (h 0 0 xs . (0:) . (0:)); dot = (sum .) . zipWith (*); s n = map (cos . (.628319*)) [0,n..]; out = take 10 $ g (1:repeat 0) in map (dot out . s) [0,1..9]
08:58:38 <lambdabot>   <no location info>: parse error on input `.'
08:59:03 <ddarius> > let h x2 x1 (x0:xs) ~(y1:y2:ys) = (x0 - x2 + 0.9*y1 - 0.81*y2):h x1 x0 xs (y2:ys); g xs = fix (h 0 0 xs . (0:) . (0:)); dot = (sum .) . zipWith (*); s n = map (cos . (0.628319*)) [0,n..]; out = take 10 $ g (1:repeat 0) in map (dot out . s) [0,1..9]
08:59:04 <lambdabot>   [-5.50000503793971,-4.740259183352285,-4.038617434785186,-2.541906817166666...
08:59:35 <ddarius> > let h x2 x1 (x0:xs) ~(y1:y2:ys) = (x0 - x2 + 0.9*y1 - 0.81*y2):h x1 x0 xs (y2:ys); g xs = fix (h 0 0 xs . (0:) . (0:)); dot = (sum .) . zipWith (*); s n = map (cos . (0.628319*)) [0,n..]; out = take 10 $ g (1:repeat 0) in map (round . dot out . s) [0,1..9]
08:59:36 <lambdabot>   [-6,-5,-4,-3,4,31,4,-3,-4,-5]
09:03:29 <ddarius> > 1.8 * cos (pi/8)
09:03:30 <lambdabot>   1.662983158520316
09:03:58 <ddarius> > let h x2 x1 (x0:xs) ~(y1:y2:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y2:ys); g xs = fix (h 0 0 xs . (0:) . (0:)); dot = (sum .) . zipWith (*); s n = map (cos . (0.628319*)) [0,n..]; out = take 10 $ g (1:repeat 0) in map (round . dot out . s) [0,1..9]
09:03:59 <lambdabot>   [-44,-42,-36,-18,42,162,42,-18,-36,-42]
09:04:13 <ddarius> Bah
09:07:09 <Taejo> :t mapM_
09:07:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:08:34 <ddarius> > let h x2 x1 (x0:xs) ~(y1:y2:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y2:ys); g xs = fix (h 0 0 xs . (0:) . (0:)); dot = (sum .) . zipWith (*); s n = map (cos . (0.314159*)) [0,n..]; out = take 10 $ g (1:repeat 0) in map (round . dot out . s) [0,1..9]
09:08:36 <lambdabot>   [-44,45,-42,41,-36,31,-18,-1,42,-110]
09:10:29 <ddarius> > let h x2 x1 (x0:xs) ~(y1:y2:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y2:ys); g xs = fix (h 0 0 xs . (0:) . (0:)) out = take 10 $ g (1:repeat 0) in map (round . (100*)) out
09:10:30 <lambdabot>   <no location info>: parse error on input `='
09:10:57 <ddarius> > let h x2 x1 (x0:xs) ~(y1:y2:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y2:ys); g xs = fix (h 0 0 xs . (0:) . (0:)); out = take 10 $ g (1:repeat 0) in map (round . (100*)) out
09:10:58 <lambdabot>   [100,-81,132,-241,414,-735,1282,-2259,3959,-6957]
09:18:58 <olsner> hmm, what's the name for the rule f x = g x ==> f = g?
09:19:09 <ddarius> eta reduction
09:19:46 <vixey> extention?al equality
09:19:56 <vixey> consequence of eta
09:19:56 <olsner> eta reduction was what I was thinking about
09:20:03 <Taejo> vixey: isn't extentional equality only for sets?
09:20:09 <Millz> hmm
09:20:22 <vixey> I guess the term in from Set theory originaly? I don't realyl know
09:20:25 <Millz> why would ByteString.Lazy.Char8 behave slower than string in IO file writes? :|
09:20:50 <vixey> olsner, I phrase eta like  \x -> f x ~~> f
09:20:53 <Taejo> vixey: "In logic, extensionality refers to principles that judge objects to be equal if they have the same external properties."
09:21:17 <olsner> vixey: well, that's just different syntax :)
09:21:29 <vixey> different syntax for what??
09:22:37 <olsner> f x = g x is that same thing as saying f = \x -> g x, which after eta reduction gives f = g
09:22:46 <vixey> no
09:23:02 <olsner> it isn't?
09:25:17 <noecksit> hello everyone, what is the function for executing pipes in haskell?
09:25:59 <Saizan_> define executing pipes..
09:26:01 <noecksit> i think it was somewhere in System but I'm not sure
09:26:24 <noecksit> id like to execute an external command and grab its stdout for me to use
09:26:39 <Saizan_> you probably want something in System.Process then
09:28:01 <noecksit> Saizan_: oh yeah, i could use "runProcess", thanx
09:28:10 <vixey> olsner, http://www.lambda-bound.com/book/lambdacalc/node20.html implies http://planetmath.org/encyclopedia/AxiomOfExtensionality.html
09:28:15 <lambdabot> Title: Eta Conversion
09:31:59 <ski_> olsner : `forall x. f x = g x' is the same as `forall x. f x = (\x -> g x) x' by beta-expansion, which is the same as `f = \x -> g x' by extensional equality
09:32:55 <olsner> I'm not entirely sure what this means :)
09:33:39 <ski_> (note that `{x | phi}' can be interpreted as `\x -> phi' .. and `x \elem X' as `X x' .. compare the two formulations of extensional equality now)
09:33:41 <vixey> forall x, f x = g x -> f = g is a consequence of eta-conversion
09:34:25 <Saizan_> but in LC you don't usually have definitions of the form f x = g x at all
09:35:01 <ski_> (you don't need to have it as a definition ..)
09:36:19 <Saizan_> yeah, but i think olsner meant it to be, and "desugaring" that to f = \x -> g x seems fair
09:36:54 <Saizan_> or not?
09:37:01 <BrokenClockwork> I want to code a bracket test, for instance { [ ( ) ] } = true (  [ ) ] = false, any suggestions for useful function? I never made something in this direction
09:37:17 <vixey> BrokenClockwork, yeah I know how to do that
09:37:49 <vixey> BrokenClockwork, You've got 3 types of bracket so you need 3 counters,  type Situation = (Integer, Integer, Integer)
09:38:15 <vixey> BrokenClockwork, so imagine between ever character the situation changes,  (x,y,z) '{' (x,y,z+1) '[' (x,y+1,z+1), ...
09:38:26 <olsner> yes, when I was saying things like f x = g x, I really meant f = \x -> g x :P
09:39:17 <vixey> BrokenClockwork, on second thought that doesn't work when you have multilpe types of bracket :/
09:39:38 <BrokenClockwork> oh okay, and then I run a compare test?
09:39:39 <BrokenClockwork> oh
09:39:40 <BrokenClockwork> hmmm
09:40:02 <vixey> BrokenClockwork, yeah what I said can work for one kind of paren but not 3 types so sorry just forget that..
09:40:51 <vixey> olsner, f = \x -> f x is eta   (f = \x -> g x) => (f = g) is a consequence of eta
09:41:10 <ski_> you could use a `[Bracket]' where `data Bracket = Round | Square | Curly | ...', i think
09:41:13 <gio123> does somebody use software SPSS?
09:42:31 <BrokenClockwork> hmm
09:45:18 <ddarius> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)); out = take 10 $ g (1:repeat 0) in map (round . (100*)) out
09:45:19 <lambdabot>   [100,166,95,23,-39,-83,-107,-109,-95,-70]
09:45:39 <BrokenClockwork> well, how can I test a string if it contains "char" ?
09:45:46 <ddarius> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)); out = g (1:repeat 0) in map (round . (100*)) out
09:45:47 <lambdabot>   [100,166,95,23,-39,-83,-107,-109,-95,-70,-38,-7,19,37,47,47,41,29,15,2,-9,-...
09:45:53 <Raevel> okay, naming time. What should i call foo f g v = (f v, g v) ? :-)
09:46:03 <ddarius> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)); out = g (1:repeat 0) in map (round . (10*)) out
09:46:04 <lambdabot>   [10,17,9,2,-4,-8,-11,-11,-10,-7,-4,-1,2,4,5,5,4,3,2,0,-1,-2,-2,-2,-2,-1,-1,...
09:46:27 <ddarius> foo = (&&&)
09:47:08 <Raevel> oh thanks ddarius, lambdabot didn't help me out there
09:47:12 <vixey> just pattern matching
09:47:12 <ddarius> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)); dot = (sum .) . zipWith (*); s n = map (cos . (0.314159*)) [0,n..]; out = take 10 $ g (1:repeat 0) in map (round . dot out . s) [0,1..9]
09:47:13 <lambdabot>   [-1,6,4,0,1,0,0,0,0,0]
09:47:20 <ddarius> Excellent
09:48:01 <Heffalump> anyone able to help with some cabal-install problems? Specifically, I'm trying to install hsql-mysql on GHC 6.10.1, and having manually installed hsql-1.7 because the hackage version doesn't work for me, installing hsql-mysql insists on reinstalling hsql-1.7 from hackage even though it's already there
09:49:35 <gwern> sounds like my horrible containers problem from the other day
09:50:11 <gwern> Heffalump: I ultimately solved it by mucking around with cabal files and 'base >= 4' and stuff
09:50:41 <Saizan_> Heffalump: if you edit a .cabal file you should bump the version
09:51:22 <Saizan_> Heffalump: if not cabal-install will get confused with the one on hackage
09:51:59 * Heffalump tries that, thanks
09:53:05 <Heffalump> ok, now I'm back to the problem that configVerbose has disappeared somewhere
09:53:19 <eu-prleu-peupeu> hello Hppl
09:54:14 <BrokenClockwork> How can I test, if there is an 'a' in "Hallo" ? (Char<->[Char])
09:54:29 <Botje> types only go one way in haskell :)
09:54:31 <Heffalump> @type elem
09:54:32 <mauke> > 'a' `elem` "Hallo"
09:54:33 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:54:33 <lambdabot>   True
09:55:01 <vixey> BrokenClockwork: just pattern matching
09:55:13 <vixey> BrokenClockwork: check ('a':_) = True ; check (_:xs) = check xs
09:55:28 <mauke> that's not just pattern matching, that's pattern matching and recursion!
09:55:40 <mauke> and an incomplete definition
09:55:46 <BrokenClockwork> what's pattern matching itself, how can it be defined?
09:56:00 <vixey> defined in terms of what?
09:56:12 <BrokenClockwork> yes
09:56:20 <BrokenClockwork> or an example instead
09:56:30 <mauke> are you pokey the penguin?
09:56:32 <vixey> check ('a':_) = True ; check (_:xs) = check xs
09:56:45 <Heffalump> BrokenClockwork: it has to be defined by the implementation
09:57:08 <vixey> > let check ('a':_) = True ; check (_:xs) = check xs in check "Hallo"
09:57:10 <lambdabot>   True
09:57:23 <mauke> > let check ('a':_) = True ; check (_:xs) = check xs in check "Hello"
09:57:24 <lambdabot>   * Exception: /tmp/494188161403753564:71:36-81: Non-exhaustive patterns in f...
09:57:32 <vixey> stop breaking things mauke!
09:57:52 <mauke> result analysis clearly shows that the only real return value can be True
09:58:07 <vixey> ?? it can also return Non-exaust
09:58:08 <lambdabot>  it can also return Non-exaust
09:58:17 <vixey> even lambdabot agrees with me
09:58:22 <stevan> hi, is there an easy way to rewrite normalize and withIntegralModulus' in http://www.cs.rutgers.edu/~ccshan/prepose/Prepose.hs so that the code works on more recent versions of ghc? thanks.
09:58:35 <mauke> yeah,  is an unreal return value :-)
09:59:19 <Heffalump> stevan: what error do you get?
09:59:29 <stevan> Prepose.hs:39:0: Parse error in patter
09:59:54 <Heffalump> try adding {-# LANGUAGE PatternSignatures #-} to the top of the file
10:00:19 <Heffalump> or just get rid of the ':: M s a' bit of the line
10:03:54 <FunctorSalad> _|_ is basement cat
10:04:23 <stevan> the pragma doesn't help and getting rid of the bit breaks things :-/
10:08:45 <papermachine> BASEMENT CAT DOES NOT HALT FOR ANYONE!
10:20:46 <Saizan_> stevan: http://code.haskell.org/~Saizan/Prepose.hs
10:21:05 <noecksit> is there a function that returns a list that is the summation of all the common elements in a list?
10:21:20 <mauke> common?
10:21:31 <noecksit> i think i know how to do it using takeWhile and dropWhile but it would get messy
10:21:41 <sbahra> sum . filter?
10:21:45 <vixey> map sum . group . sort
10:22:44 <noecksit> sbahra: filter would need a parameter though
10:24:23 <noecksit> sorry, i didnt use the word summation right, it returns the number of common elements in a list
10:24:35 <vixey> map length . group . sort
10:26:16 <stevan> Saizan_: thanks
10:26:24 <noecksit> vixey: yeah that's what i wanted thanx
10:26:30 <mauke> M.toList . M.fromListWith (+) . map (flip (,) 0)
10:27:18 <Raevel> i'm looking for a function like (***), but i want it to be (a -> b) -> a -> a -> (b,b), anyone know which one that is? :-)
10:28:03 <mauke> @djinn (a -> b) -> a -> a -> (b, b)
10:28:04 <lambdabot> f a b _ = (a b, a b)
10:28:07 <mauke> :-|
10:28:21 <mm_freak_> @pl \k x -> x : k x
10:28:21 <lambdabot> ap (:)
10:28:29 <vixey> @hoogle (a -> b) -> (a,a) -> (b,b)
10:28:30 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
10:28:30 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
10:28:30 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
10:28:33 <mm_freak_> @src ap
10:28:34 <lambdabot> ap = liftM2 id
10:28:37 <mauke> @pl \f x y -> (f x, f y)
10:28:38 <lambdabot> flip =<< (((.) . (,)) .)
10:28:46 <vixey> :t (^<< ?f >>^)
10:28:47 <lambdabot> parse error on input `)'
10:28:48 <Raevel> yowza
10:28:53 <vixey> :t ((^<< ?f) >>^)
10:28:54 <lambdabot> forall c d (a :: * -> * -> *) b d1. (Arrow a, ?f::a b c) => (a b d -> d1) -> (c -> d) -> d1
10:29:00 <mauke> :t curry . join (***)
10:29:01 <lambdabot> forall b c. (b -> c) -> b -> b -> (c, c)
10:29:06 <mauke> huhu
10:29:33 <mm_freak_> where is the Monad instance for (-> a)?
10:29:34 <Raevel> i almost thought of that one! but i thought there was something already defined in Control.Arrow for some reason
10:29:45 <mauke> Control.Monad.Instances
10:29:56 <mm_freak_> thanks
10:30:38 <sbahra> vixey, why would you want him to use group . sort?
10:30:44 <sbahra> filter is O(n).
10:32:15 <Raevel> &&& sounds like what i want, or am i mistaken?
10:32:23 <vixey> :t (&&&)
10:32:25 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:32:51 <vixey> (&&&) :: Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
10:33:22 <Asztal> I wish it would do that ~> automatically for me :(
10:33:29 <vixey> me too :)
10:34:35 <ka> Why do functions often use a signature of something like this:  functionName :: Int -> IO ()  -- specifically, what is the () for after the IO?
10:35:19 <Heffalump> IO a is something that does some IO (input/output) and also produces a value of type a
10:35:23 <mauke> it's the return type of the IO action returned by functionName
10:35:27 <Raevel> okay so f&&&g is a -> (a, a) so not what i wanted i suppose
10:35:43 <mauke> :t f&&&g
10:35:44 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a, SimpleReflect.FromExpr (a b c'), SimpleReflect.FromExpr (a b c)) => a b (c, c')
10:35:46 <Heffalump> () is the empty type, that has just one (non-error) value, () [both pronounced "unit"]
10:36:02 <Heffalump> so IO () means it does some IO but doesn't produce a value
10:36:09 <Heffalump> (where does some IO = might do some IO)
10:36:18 <Raevel> or is what i said incorrect? id&&&id is a -> (a,a) at least :-)
10:37:03 <Raevel> f&&&g should be a -> (b, c)
10:37:12 <dons> ?users
10:37:12 <lambdabot> Maximum users seen in #haskell: 558, currently: 536 (96.1%), active: 19 (3.5%)
10:38:34 <byorgey> Raevel: right, if f :: a -> b  and g :: a -> c, then f &&& g :: a -> (b,c)
10:45:02 <newsham> ?check \a b -> (b :: Int) < a ==> let m = a + ((b-a)/2) in b <= m && m <= a
10:45:03 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
10:45:03 <lambdabot>           ...
10:45:09 <Raevel> is it possible to define data types in ghci?
10:45:13 <mauke> Raevel: no
10:45:20 <newsham> whats the proper way to write that?
10:45:23 <Raevel> alright
10:45:37 <mauke> newsham: use `div` for integers
10:45:59 <newsham> ?check \a b -> (b :: Int) < a ==> let m = a + ((b-a)`div`2) in b <= m && m <= a
10:46:00 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
10:46:02 <lambdabot>           ...
10:46:06 <newsham> thats not the cause of the error
10:46:12 <mauke> :-(
10:46:29 <Saizan_> ?check \a b -> ((b :: Int) < a) ==> (let m = a + ((b-a)`div`2) in b <= m && m <= a)
10:46:30 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
10:46:31 <lambdabot>           ...
10:47:10 <byorgey> wish we could see the rest of the error =(
10:47:23 <newsham> you can if you /msg it to lb
10:49:50 <byorgey> newsham: are you getting that error just with \bot? or do you get an error if you put it in a file and compile it too?
10:50:24 <newsham> i havent tried in a file
10:52:19 <newsham> american military contractor just passed EAL6+ verification for an OS they wrote.
10:52:47 <newsham> I wonder how sel4 is progressing and how their methods compare (havent seen much info from the non-sel4 project)
10:54:05 <hukolele> how can i do something like tachar (Just ():xs) = [Just():xs] ++ map (Nothing:) (tachar xs) using the monad notation?
10:54:22 <hukolele> is there a general rule to follow?
10:55:15 <newsham> is "hukolele" a hawaiian name?
10:55:23 <mauke> return (Just () : xs) ++ (tachar xs >>= return . (Nothing :))
10:55:56 <ddarius> liftM (Nothing:) (tachar xs)
10:56:06 <ddarius> ++ -> `mplus`
10:56:07 <hukolele> newsham sort of, im not hawaian its just my name is huko
10:56:10 <byorgey> hukolele: what do you mean by 'the monad notation' ?
10:56:25 <hukolele> byorgey : do ...
10:56:41 <hukolele> wrong said?
10:56:43 <byorgey> ok, that's what I thought.  usually that is called 'do-notation'
10:56:50 <u_quark> is there a module for indexing [[a]] as a two-dimensional array? or in general a two-dimensional array like data type ?
10:56:55 <hukolele> ok, thx
10:56:56 <ddarius> hukolele: Why do you want to do this anyway?
10:57:06 <roconnor> there is a cabal upload ?
10:57:07 <hukolele> just practicing
10:57:11 <ddarius> u_quark: Just use (!!)
10:57:28 * roconnor cabal fetch-beer
10:57:28 <byorgey> hukolele: actually I think translating this particular example into do-notation would be difficult
10:57:33 <mauke> u_quark: Data.Array
10:57:36 <byorgey> and probably not very illuminating.
10:57:49 <u_quark> mauke: tnx
10:58:29 <hukolele> i was training to do non-determinism with haskell
10:58:43 <byorgey> hukolele: you can only translate into do-notation list functions which act independently on each element of the input list.
10:58:57 <dons> http://www.reddit.com/r/programming/comments/7f6pm/haskell_and_the_arts_how_artists_can_benefit_from/
10:59:00 <dons> interesintg
10:59:03 <lambdabot> Title: Haskell and the Arts: How artists can benefit from FP :: PDF : programming, http://tinyurl.com/6fq255
10:59:12 <byorgey> your function uses the list history to make increasingly long lists as output.
10:59:39 <dons> roconnor: reminds me of python's joke about 'import bacon'
10:59:41 <byorgey> hm, I wonder if it could be expressed using the stream comonad =)
10:59:42 <dons> we need a haskell comic
11:00:05 <hukolele> comonad? lol sounds funny
11:00:23 <hukolele> is it related with the mdo notation?
11:00:28 <byorgey> hukolele: no
11:01:17 <byorgey> hukolele: comonads are the categorical duals of monads.  just take the types of 'return' and '>>=', switch all the arrows (more or less), and you've got the comonad methods
11:02:34 <ka> function :: (Int -> Int) -> Int        Will "function p q" be function(b q) here, but if the brackets were removed in the signature it be function b(q) ?
11:03:09 <byorgey> ka: the type of function has nothing to do with how 'function p q' will be parsed
11:03:17 <byorgey> 'function p q' always means '(function p) q'
11:03:29 <byorgey> is that what you are asking?
11:03:47 <ka> How would I pass function the value of (p q) then?
11:03:55 <byorgey> just write 'function (p q)'
11:04:35 <monochrom> haskell is the funnest :)
11:04:59 <lispy> byorgey: oh, I think I know what ka means.  depending on wether p is parameter to function or a function itself it may be a type error
11:05:27 <lispy> 'function p q' /= 'function (p q)' for some values of p
11:05:36 <ka> byorgey: though something like:  map p [1 .. 3] -- this won't parse as (map p) [1 .. 3]   will it?
11:05:42 <mauke> ka: yes, it will
11:05:44 <monochrom> It will.
11:05:51 <mauke> > (map f) [1 .. 3]
11:05:52 <lambdabot>   Add a type signature
11:05:57 <mauke> > (map f) [1 .. 3] :: Expr
11:05:58 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[b]'
11:06:02 <mauke> > (map f) [1 .. 3] :: [Expr]
11:06:03 <lambdabot>   [f 1,f 2,f 3]
11:06:06 <mauke> :-(
11:06:13 <byorgey> ka: in Haskell there are only one-argument functions.
11:06:42 <byorgey> functions which 'take multiple arguments' are really just functions which take one argument, and return another function (which can take another argument, and so on)
11:06:51 <Peaker> Beelsebob, dolio: have you seen http://lukepalmer.wordpress.com/2008/11/23/screw-laziness/ ?
11:06:53 <lambdabot> Title: Screw laziness (w.r.t. Fran semantics)  Luke Palmer
11:07:41 <ddarius> > (fun "map" f) [1..3] :: Expr
11:07:42 <lambdabot>   Add a type signature
11:07:52 <lispy> ka: and functions also bind the tightest, so map p [1 .. 3] always parses as (map p) [1 .. 3].  The one exception is that operators are functions too, but you can give them a difference precedence
11:08:18 <newsham> > let f = uncurry (+) in f(3,4)
11:08:19 <lambdabot>   7
11:08:26 <newsham> two argument function!
11:08:52 <lispy> > let f = uncurry (+) in f (,) 3 4
11:08:53 <lambdabot>   Couldn't match expected type `(a, a)'
11:08:58 <lispy> > let f = uncurry (+) in f ((,) 3 4)
11:08:59 <lambdabot>   7
11:09:01 <monochrom> I want screw laziness! Wouldn't it be nice: dad tells me to add screws to fasten something, and I just place the screws there lazily.
11:09:18 <dons> mm
11:09:36 <lispy> :t mm
11:09:37 <lambdabot> Not in scope: `mm'
11:09:53 <newsham> mono: but everytime someone takes a dish out of the pantry you'll have to run downstairs to wash and dry a dish
11:10:07 <newsham> s/pantry/cabinet/
11:12:31 <litb> ` print [ a:b:c:d | let q = ['a' .. 'z'] in a <- q, b <- q, c <- q, d <- q ]
11:12:36 <litb> > print [ a:b:c:d | let q = ['a' .. 'z'] in a <- q, b <- q, c <- q, d <- q ]
11:12:37 <lambdabot>   <no location info>: Parse error in pattern
11:12:40 <litb> why is it failing?
11:12:57 <litb> i thought that should work
11:13:04 <mauke> s/ in /, /
11:14:00 <litb> thanks works nicely (forgot :[] too)
11:14:46 <lispy> > print 1 -- lambdabot doesn't like print
11:14:48 <lambdabot>   * Exception: "<IO ()>"
11:15:05 <newsham> > print 1 :: String
11:15:06 <lambdabot>   Couldn't match expected type `String' against inferred type `IO ()'
11:15:09 <litb> oh right didnt remember
11:15:16 <newsham> oops thinking printf
11:15:34 <litb> isn't there a "sequence" function for that?
11:15:35 <Peaker> litb: note that a:b:c:d must mean that the type of d differs from the types of a,b,c
11:15:50 <litb> which takes the monad and executes it ?
11:15:58 <Peaker> @type (:)
11:15:59 <lambdabot> forall a. a -> [a] -> [a]
11:15:59 <litb> Peaker: yeah i figured :)
11:16:13 <lispy> :t \a b c d -> a:b:c:d
11:16:14 <lambdabot> forall a. a -> a -> a -> [a] -> [a]
11:16:30 <litb> it's right associative
11:16:43 <Peaker> litb: you don't need print for lambdabot, and list comprehensions "let", like "do" "let", don't have "in"
11:17:20 <Peaker> > [ a:b:c:d:[] | let q = ['a' .. 'z'], a <- q, b <- q, c <- q, d <- q ]
11:17:21 <lambdabot>   ["aaaa","aaab","aaac","aaad","aaae","aaaf","aaag","aaah","aaai","aaaj","aaa...
11:17:31 <litb> Peaker: oh ok
11:17:46 <Peaker> @type repeatN
11:17:47 <lambdabot> Not in scope: `repeatN'
11:17:52 <litb> here it was for this: http://stackoverflow.com/questions/312732/algorithm-for-creating-words i showed them how haskell is better :)
11:17:55 <mauke> :t \x -> mapM (const x) x
11:17:56 <lambdabot> forall b. [b] -> [[b]]
11:17:58 <lambdabot> Title: Algorithm for creating words - Stack Overflow, http://tinyurl.com/5osaf9
11:18:06 <Peaker> and indeed, this is just:
11:18:08 <Peaker> > sequence (take 4 (repeat ['a'..'z']))
11:18:10 <lambdabot>   ["aaaa","aaab","aaac","aaad","aaae","aaaf","aaag","aaah","aaai","aaaj","aaa...
11:18:17 <mauke> :t const >>= mapM
11:18:18 <lambdabot> forall b. [b] -> [[b]]
11:18:25 <mauke> > (const >>= mapM) "abc"
11:18:27 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
11:18:41 <litb> Peaker: wait wtf is that lol
11:18:42 <Peaker> litb: sequence takes a list of monadic actions, and binds them all to one big monadic action that evaluates to a list of their results
11:18:50 <Lemmih> thoughtpolice: ping.
11:18:50 <lambdabot> Lemmih: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:18:55 <Peaker> > take 4 (repeat ['a'..'z'])
11:18:57 <lambdabot>   ["abcdefghijklmnopqrstuvwxyz","abcdefghijklmnopqrstuvwxyz","abcdefghijklmno...
11:19:02 <Peaker> > take 4 (repeat ['a'..'c'])
11:19:03 <lambdabot>   ["abc","abc","abc","abc"]
11:19:05 <vixey> @let alphabet = ['a'..'z']
11:19:06 <lambdabot>  Defined.
11:19:27 <vixey> > let (^) = replicate in sequence (alphabet ^ 4)
11:19:28 <monochrom> monad is hard.
11:19:28 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
11:19:32 <vixey> > let (^) = flip replicate in sequence (alphabet ^ 4)
11:19:34 <litb> oh i see
11:19:34 <lambdabot>   ["aaaa","aaab","aaac","aaad","aaae","aaaf","aaag","aaah","aaai","aaaj","aaa...
11:19:34 <mauke> litb: sequence finds all paths through a list of lists
11:19:40 <vixey> > let (^) = flip replicate in sequence (alphabet ^ 7)
11:19:42 <lambdabot>   ["aaaaaaa","aaaaaab","aaaaaac","aaaaaad","aaaaaae","aaaaaaf","aaaaaag","aaa...
11:19:50 <Peaker> @type replicate
11:19:51 <lambdabot> forall a. Int -> a -> [a]
11:19:54 <mauke> > sequence ["abc", "12", "XY"]
11:19:55 <lambdabot>   ["a1X","a1Y","a2X","a2Y","b1X","b1Y","b2X","b2Y","c1X","c1Y","c2X","c2Y"]
11:20:04 <Peaker> litb: sequence is easier to understand in other monads first
11:20:09 <Peaker> litb: at least, IMO
11:20:31 <Peaker> > sequence [Just 5, Just 6, Just 7]
11:20:32 <lambdabot>   Just [5,6,7]
11:20:36 <Peaker> > sequence [Just 5, Just 6, Just 7, Nothing, Just 8]
11:20:38 <lambdabot>   Nothing
11:22:25 <ddarius> > replicateM 4 ['a'..'z']
11:22:26 <lambdabot>   ["aaaa","aaab","aaac","aaad","aaae","aaaf","aaag","aaah","aaai","aaaj","aaa...
11:22:38 <lispy> ?check \x -> (x :: Int) == head (take 100 (repeat x))
11:22:39 <lambdabot>   "OK, passed 500 tests."
11:23:01 <lispy> ?check \x y -> (x :: Int) == head (take y (repeat x))
11:23:02 <lambdabot>   "* Exception: Prelude.head: empty list
11:23:11 <litb> i think i get this.   first you have [[a..z], [a..z], [a..z], [a..z]] sequence does do { a <- [a..z]; b <- [a..z], c <- ...., return a /* and what comes now ? */ }
11:23:22 <lispy> ?check \x y -> y > 0 ==> (x :: Int) == head (take y (repeat x))
11:23:23 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
11:23:23 <lambdabot>           ...
11:23:42 <Peaker> ddarius: is replicateM so useful that it warrants its own function? Except for the list monad case?
11:23:52 <ddarius> Peaker: Yes!
11:24:00 <Peaker> (In which it is mildly useful, but can just compose replicate with sequence)
11:24:07 <ddarius> @src replicateM
11:24:08 <lambdabot> replicateM n x = sequence (replicate n x)
11:24:37 <Peaker> I don't like functions that just give a name to some f . g :)
11:24:46 <lispy> ?src concatMap
11:24:47 <lambdabot> concatMap f = foldr ((++) . f) []
11:25:10 <lispy> Peaker: I don't like functions.  We should replace all the verbs with nouns.
11:25:58 <dons> did anyone else know that people were using yahoo answers to ask haskell questions?
11:26:06 <ddarius> Peaker: 1) replicateM = (sequence .) . replicate 2) this is a functional programming language, functions are cheap, make them
11:26:33 <inimino> let g = id in "I don't like functions that just give a name to some f . g"
11:26:36 <dons> urgh, for example, http://uk.answers.yahoo.com/question/index;_ylt=AuH_9eFnkXaCYRCw6DxrUCxJBgx.;_ylv=3?qid=20080806071725AAAkSNH
11:26:38 <lambdabot> Title: Help with Haskell Program - Yahoo! UK & Ireland Answers, http://tinyurl.com/6l8v8h
11:26:49 <litb> @sc sequence
11:26:50 <lambdabot> Maybe you meant: rc src
11:26:52 <litb> @src sequence
11:26:52 <lambdabot> sequence []     = return []
11:26:52 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:26:52 <lambdabot> --OR
11:26:52 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:26:57 <litb> neat
11:27:15 <lispy> dons: I knew about stackoverflow, but not yahoo answers
11:27:19 <dons> Cale, or even haskell homework, http://answers.yahoo.com/question/index?qid=20081122133402AAtWBxe
11:27:21 <lambdabot> Title: Who can solve any of the following Haskell Programming tasks. Please do.? - Yaho ...
11:27:26 <litb> i like stackoverflow . i'm in there too
11:27:34 <dons> do we have people on stackoverflow answering things sensibly?
11:27:35 <inimino> I didn't even know Yahoo answers existed
11:27:48 <dons> inimino: its (in)-famous
11:27:55 <ddarius> dons: I love how the answer is in a C-like language and is not immediately translatable to Haskell
11:28:06 <dons> ddarius: yes :)
11:28:22 <dons> inimino: this is why it is famous, http://answers.yahoo.com/question/index?qid=20080810030304AAz4LT9
11:28:23 <lambdabot> Title: How is babby formed? - Yahoo! Answers
11:28:26 <dons> hehe
11:28:27 <lispy> dons: stackoverflow tends to be pretty good quality as you can use positive re-enforcemen for good answers.  Yahoo has notoriously bad answers :)
11:28:36 <dons> indeed.
11:28:53 <dons> i was just surprised that anyone would think of asking haskell questions there
11:29:06 <ddarius> If it was triangle(n) { return n == 0 ? 0 : n+triangle(n-1); } then it would at least be forgivable.
11:29:17 <inimino> ah, is that where that came from...
11:29:28 <dons> yup
11:29:43 <lispy> this babby thread is amazing
11:29:46 <ddarius> That James S person doesn't even know what he's talking about.  He's maybe thinking Pascal?
11:29:59 <inimino> I never knew how "how is babby formed" was formed.
11:30:35 <Peaker> ddarius: I really love it when code manages to solve problems by composing super-simple functions, rather than higher, more complicated ones
11:30:47 <Peaker> ddarius: but its a personal style thing, I guess
11:31:29 <lispy> the linked flash animation is so fitting
11:32:17 <ddarius> Peaker: Not naming the compositions doesn't make the code simpler.
11:32:43 <lispy> yeah, see exhibit A: Darcs source code.
11:32:50 <Peaker> ddarius: It makes the functions being composed simpler.. I prefer to see concat.map f   over concatMap, for example
11:33:00 <lispy> Long chains of function calls with on name + lots of case-expressions == huh?
11:33:10 <Botje> can we have \bot watch stackoverflow for haskell questions
11:33:22 <Peaker> ddarius: I read what I said and I sounded like an ass there, sorry :)
11:33:24 <lispy> Botje: heh, interesting idea.  Very possible.
11:33:52 <ddarius> Peaker: You want a bunch of small functions that are composed relatively simply at each level.  Learn you some Forth.
11:33:58 <lispy> xx2nons is not a good function name, BTW
11:34:13 <litb> Botje: hah, great idea
11:35:31 <Peaker> ddarius: I think if the abstraction, through its name or interface, exposing every one of the things its supposed to be abstracting, its probably best to use the underlying things directly
11:36:28 <Peaker> (concatMap f  vs  concat . map f)
11:36:32 <lispy> Peaker: but, I'd rather use foldl1 than foldl most of the time
11:36:37 <inimino> Peaker: but commonly used patterns can be made shorter
11:36:55 <eu-prleu-peupeu> hello
11:36:57 <Peaker> @src concatMap
11:36:57 <lambdabot> concatMap f = foldr ((++) . f) []
11:37:02 <eu-prleu-peupeu> is yampa still used ?
11:37:09 <eu-prleu-peupeu> isn't it deprecated ?
11:37:15 <eu-prleu-peupeu> or something :P
11:37:20 <vixey> @src concat
11:37:21 <lambdabot> concat = foldr (++) []
11:37:22 <vixey> @src map
11:37:22 <lambdabot> map _ []     = []
11:37:22 <lambdabot> map f (x:xs) = f x : map f xs
11:37:25 <vixey> grrrrr
11:37:25 <inimino> concatMap might save you some parentheses if nothing else
11:37:28 <Peaker> is concatMap a pre-stream-fusion optimization?
11:37:45 <vixey> concatMap is just sticking the folds togther
11:37:55 <vixey> someone though it was funny to write map out long without usig a fold though...
11:37:58 <Peaker> vixey: yeah, is it advantageous over composing concat with map f?
11:38:23 <Peaker> vixey: It sounds like a performance declaration, though if map was a foldr, a rewrite rule could probably do that fusion anyhow
11:38:40 <vixey> does rewrite rules look _inside_ the definitions?
11:38:50 <monochrom> No.
11:39:16 <monochrom> err nevermind, I don't understand the question.
11:39:32 <vixey> :t foldr ((:) . ?f) []
11:39:33 <lambdabot> forall b a. (?f::a -> b) => [a] -> [b]
11:39:35 <Peaker> if I have: myMap = map ;   myMap id blah   -- it wouldn't fire the map id = id   rewrite rule (because its "inside my definition")?
11:40:05 <vixey> foldr (++) [] . foldr ((:) . ?f) []   vs   foldr ((++) . f) []
11:40:23 <monochrom> first do inlining. then see "map id" and fires.
11:40:42 <Peaker> if it does fire, then why wouldn't  concat . map f       also fire the rewrite rule for:  foldr f same . foldr g same == foldr (f.g) same   (or something more general, perhaps)?
11:41:38 <Peaker> I guess my rewrite rule is not quite right :-)
11:41:45 <vixey> :t foldr ?f ?x . foldr ?g ?x
11:41:46 <lambdabot> forall a a1. (?f::a -> [a] -> [a], ?g::a1 -> [a] -> [a], ?x::[a]) => [a1] -> [a]
11:41:51 <vixey> :t foldr (?f . ?g) ?x
11:41:52 <lambdabot> forall b a b1. (?x::b1, ?g::a -> b, ?f::b -> b1 -> b1) => [a] -> b1
11:43:33 <Peaker> I guess the "same" there really ought to be [], or the left foldr will apply extra things
11:43:44 <Peaker> :t foldr ?f [] . foldr ?g []
11:43:45 <lambdabot> forall a a1 a2. (?g::a1 -> [a2] -> [a2], ?f::a2 -> [a] -> [a]) => [a1] -> [a]
11:43:51 <vixey> even then I think it's not true...
11:43:54 <vixey> Can you prove it?
11:43:56 <Peaker> :t foldr (?f . ?g) []
11:43:57 <lambdabot> forall b a a1. (?g::a -> b, ?f::b -> [a1] -> [a1]) => [a] -> [a1]
11:44:14 <Peaker> well, f and g are functions of 2 args, so its probably not as simple a composition as (.)
11:44:24 <vixey> @free foldr
11:44:25 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
11:45:35 <Peaker> I guess the rewrite rule has to really be specific for foldr with map, and not foldr with foldr :P
11:46:30 <Peaker> (still more general than the specific application for concatMap)
11:47:15 <eu-prleu-peupeu> is it ok for me to use yampa in reactive systems ?
11:48:40 <alexsuraci> what haskell debugging options are there nowadays?
11:48:45 <alexsuraci> is HOOD still relevant?
11:49:04 <Peaker> eu-prleu-peupeu: sure, but Reactive is newer and more exciting :)  (Though it still hasn't ironed out all the bugs)
11:49:30 <monochrom> ghc's interpreter has a breakpoint and stepping thing
11:49:48 <dons> alexsuraci: the ghci debugger
11:49:49 <eu-prleu-peupeu> oh, Peaker where can i find it ?
11:49:52 <dons> and ghc's built in -fhpc
11:50:02 <dons> eu-prleu-peupeu: yampa + reactive is on hackage.haskell.org
11:50:08 <dons> where all haskell code of value lives
11:50:25 <Peaker> @where Reactive
11:50:25 <lambdabot> I know nothing about reactive.
11:50:40 <alexsuraci> dons: thanks, I'll take a look
11:50:50 <Peaker> eu-prleu-peupeu: http://www.haskell.org/haskellwiki/Reactive
11:50:52 <lambdabot> Title: Reactive - HaskellWiki
11:51:07 <eu-prleu-peupeu> thanks :)
11:53:19 <litb> do v <- x; vs <- []; return (v:vs)   what happens there?
11:53:42 <litb> @src ([]) >>=
11:53:42 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:53:43 <vixey> litb,you get []
11:53:53 <vixey> (>>=) = flip concatMap
11:54:01 <vixey> > concatMap (+3) []
11:54:02 <lambdabot>       No instance for (Num [b])
11:54:03 <lambdabot>        arising from the literal `3' at <inter...
11:54:15 <vixey> > concatMap (return . (+3)) []
11:54:16 <lambdabot>   []
11:54:21 <litb> v will be set to each element of x in turn. then vs is an empty list. concatMap is going to do something strange?
11:54:25 <Cale> litb: the result will be empty, there are no choices for vs
11:54:26 <litb> oh
11:55:07 <pumpkin> > do v <- [1, 2, 3]; vs <- []; return (v:vs)
11:55:09 <lambdabot>   []
11:55:12 <pumpkin> muahahahaha
11:55:16 * pumpkin dies
11:55:25 <litb> oh lol
11:56:12 <Cale> > do v <- [1, 2, 3]; vs <- [[],[4]]; return (v:vs)
11:56:14 <lambdabot>   [[1],[1,4],[2],[2,4],[3],[3,4]]
11:56:27 <pumpkin> funky
11:56:40 <pragma_> double jeopardy
11:56:41 <litb> oh neat
11:56:57 <litb> makes sense
11:57:07 <Cale> > [v:vs | v <- [1,2,3], vs <- [[],[4]]]
11:57:09 <lambdabot>   [[1],[1,4],[2],[2,4],[3],[3,4]]
11:57:29 <Peaker> > (:) <$> [1,2,3] <*> [[],[4]]
11:57:30 <lambdabot>   [[1],[1,4],[2],[2,4],[3],[3,4]]
11:57:46 <litb> :p
11:58:00 <twanvl> > liftA2 [1,2,3] [[],[4]]
11:58:01 <lambdabot>   Couldn't match expected type `a -> b -> c'
11:58:06 <twanvl> > liftA2 (:) [1,2,3] [[],[4]]
11:58:07 <lambdabot>   [[1],[1,4],[2],[2,4],[3],[3,4]]
11:58:12 <pumpkin> > liftM2 (:) [1,2,3] [[], [4]]
11:58:14 <lambdabot>   [[1],[1,4],[2],[2,4],[3],[3,4]]
11:58:16 <pumpkin> lol
11:58:22 <vixey> > [[1],[1,4],[2],[2,4],[3],[3,4]]
11:58:23 <lambdabot>   [[1],[1,4],[2],[2,4],[3],[3,4]]
11:58:37 <Peaker> ;-)
11:59:08 <twanvl> > the_same_thing_as_above
11:59:09 <lambdabot>   [[1],[1,4],[2],[2,4],[3],[3,4]]
11:59:25 <Peaker> Secret @let's are cheating
11:59:30 <pumpkin> lol
12:00:01 <Quorer> hello! what's the easiest way to check if a file allready exists?
12:00:04 <mm_freak_> @faq can haskell guess what you mean?
12:00:04 <lambdabot> The answer is: Yes! Haskell can do that.
12:00:20 <twanvl> ?hoogle file exists
12:00:20 <lambdabot> No results found
12:00:23 <Lemmih> Quorer: doesFileExist.
12:00:42 <pumpkin> doesntFileExist
12:00:55 <Peaker> Quorer: note the inherent atomic-ness bug in separately checking for existence and then acting upon it, it may be best to use exclusive open mode, or some such
12:00:59 <mm_freak_> ?hoogle FilePath -> IO Bool
12:01:00 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
12:01:00 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
12:01:00 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
12:01:53 <Quorer> thank you
12:03:52 <litb> then how is sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)  ever going to work? if the vs <- sequence xs;  ends up in vs <- []; in the last recursive call, then the return returns an empty list. then in the recursion before, also an empty list is returned, and the one before that also. so wouldn't we and up with an empty list at all ?
12:04:25 <litb> i feel like i do miss the point
12:04:28 <vixey> @src sequence
12:04:28 <lambdabot> sequence []     = return []
12:04:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:04:28 <lambdabot> --OR
12:04:28 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:04:32 <ddarius> @src [] return
12:04:33 <lambdabot> return x    = [x]
12:04:33 <vixey> > sequence []
12:04:34 <lambdabot>       No instance for (Show (m [a]))
12:04:34 <lambdabot>        arising from a use of `show' at <...
12:04:35 <vixey> > sequence ["foo"]
12:04:36 <lambdabot>   ["f","o","o"]
12:04:39 <vixey> > sequence ["foo","bar"]
12:04:40 <lambdabot>   ["fb","fa","fr","ob","oa","or","ob","oa","or"]
12:05:01 <vixey> > do a <- "foo" ; b <- "bar" ; return [a,b]
12:05:02 <lambdabot>   ["fb","fa","fr","ob","oa","or","ob","oa","or"]
12:05:03 <ddarius> > transpose ["foo"]
12:05:05 <lambdabot>   ["f","o","o"]
12:05:18 <idnar> litb: why does the return return an empty list? you get (v:[])
12:05:58 <litb> > (do v <- [1, 2, 3]; vs <- []; return (v:vs))
12:05:59 <lambdabot>   []
12:06:02 <litb> there -.-
12:06:13 <vixey> > (do v <- [1, 2, 3]; vs <- return []; return (v:vs))
12:06:14 <lambdabot>   [[1],[2],[3]]
12:06:32 <pumpkin> there's nothing inside the []
12:06:53 <pumpkin> is my very technical explanation of the phenomenon
12:07:11 <Beelsebob> > [1,2,3] <^(:)^> [[]] -- ?
12:07:12 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
12:07:16 <Beelsebob> bah
12:07:27 <pumpkin> whoever designed an operator that looks like that should be shot :P
12:07:29 <Beelsebob> bad lambdabot, learn about InfixApplicative already
12:07:35 <Deewiant> litb: it doesn't end up in "vs <- []", it ends up in "vs <- return []", which is very different :-)
12:07:43 <Beelsebob> it's not an operator -- it's 3
12:07:50 <pumpkin> :o
12:08:01 <litb> Deewiant: ohh indeed. i've missed that.
12:08:27 <idnar> > [1,2,3] <~(:)~> [[]]
12:08:28 <lambdabot>   Not in scope: `<~'Not in scope: `~>'
12:08:32 <idnar> hm
12:08:49 <Beelsebob> the <^ and ^> are meant to look like "lifting"
12:08:56 <Beelsebob> they provide liftA2 in infix
12:09:18 <litb> > let (<~(.)~>) a b = a + b in 1 <~(.)~> 2
12:09:20 <lambdabot>   <no location info>: parse error on input `)'
12:09:21 <litb> :p
12:09:42 <litb> i suppose some weird characters in it
12:09:50 <Beelsebob> > let (<^) = filp fmap; (^>) = (<*>) in [1,2,3] <^(:)^> [[]]
12:09:51 <lambdabot>   Not in scope: `filp'
12:09:56 <Beelsebob> > let (<^) = filp fmap; (^>) = (<*>) in [1,2,3] <^(:)^> [[]]
12:09:57 <lambdabot>   Not in scope: `filp'
12:09:58 <Beelsebob> bah!
12:10:05 <Beelsebob> > let (<^) = flip fmap; (^>) = (<*>) in [1,2,3] <^(:)^> [[]]
12:10:06 <lambdabot>   [[1],[2],[3]]
12:10:17 <idnar> > let a <^ f = f <$> a; f ^> a = f <*> a; in [1,2,3] <^(:)^> [[]]
12:10:18 <lambdabot>   [[1],[2],[3]]
12:10:20 <idnar> damn, too slow
12:10:59 <litb> hehe
12:11:00 <Beelsebob> @let (<^) = flip fmap
12:11:01 <lambdabot>  <local>:8:12:
12:11:01 <lambdabot>      Ambiguous type variable `f' in the constraint:
12:11:01 <lambdabot>        `Fu...
12:11:14 <hackage> Uploaded to hackage: gitit 0.3.1
12:11:14 <hackage> Uploaded to hackage: hpylos 1.0
12:11:17 <idnar> what. the. heck?
12:11:19 <idnar> @type flip fmap
12:11:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
12:11:23 <Beelsebob> @let (<^) = flip fmap :: Functor f => f a -> (a -> b) -> f b
12:11:24 <lambdabot>  <local>:8:7:
12:11:24 <lambdabot>      Ambiguous type variable `f' in the constraint:
12:11:24 <lambdabot>        `Fun...
12:11:27 <ddarius> @hackage hpylos
12:11:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hpylos
12:11:28 <idnar> @type (<^)
12:11:30 <lambdabot> Not in scope: `<^'
12:11:33 <Beelsebob> wtf...
12:11:39 <idnar> @undef
12:11:43 <pumpkin> fail
12:11:49 <idnar> @let (<^) = flip fmap
12:11:50 <lambdabot>  <local>:1:12:
12:11:50 <lambdabot>      Ambiguous type variable `f' in the constraint:
12:11:50 <lambdabot>        `Fu...
12:11:59 <Peaker> <^(:)^>  is pretty terrible :)
12:12:08 <Beelsebob> @load Control.Infix.Applicative
12:12:08 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
12:12:12 <pumpkin> it's the bat-compound-operator
12:12:23 <Beelsebob> Peaker: it's much much better than liftA2 (:) though
12:12:30 <pumpkin> orly?
12:12:35 <Peaker> Beelsebob: I prefer liftA2
12:12:40 <Beelsebob> why?
12:12:43 <Beelsebob> liftA2 is both longer
12:12:47 <Beelsebob> and destroyes the infixity
12:12:55 <Peaker> Beelsebob: liftA2 is shorter, token-wise
12:13:02 <Beelsebob> so?
12:13:18 <mauke> -: liftA2 (:) :-
12:13:25 <idnar> (:) <$ foo <*> bar
12:13:32 <idnar> err, <$>
12:13:39 <Beelsebob> and that's longer
12:13:41 <Beelsebob> and not infix
12:13:57 <Beelsebob> foo <^ (:) ^> bar -- exactly the same thing, but infix
12:14:08 <Peaker> Beelsebob: I find an operator that big/long hard to remember and quite noisish..
12:14:11 <vixey> omg cabal is so broken :/
12:14:17 <Peaker> @type (^>)
12:14:18 <lambdabot> Not in scope: `^>'
12:14:29 <Beelsebob> Peaker: (^>) == (<*>)
12:14:30 <idnar> `liftA2 (:)` :P
12:14:34 <idnar> unfortunately that doesn't work
12:14:44 <idnar> uhm, so, I don't understand lambdabot's complaint there
12:14:50 <Beelsebob> nor do I
12:14:50 <idnar> Ambiguous type variable `f' in the constraint: `Functor f' arising from a use of `fmap'
12:14:54 <Peaker> @type (<$$>)
12:14:55 <lambdabot> Not in scope: `<$$>'
12:14:55 <idnar> what's ambiguous about it?
12:14:58 <Peaker> @type (<**>)
12:14:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
12:15:09 <mauke> is this the monomorphism restriction?
12:15:19 <vixey> yes
12:15:22 <Peaker> Beelsebob: how about <$$> being flip fmap (kind of like <**>), and then using <$$> and <*> instead of newly invented symbols for the same thing
12:15:28 <vixey> @set -XNoMonomorphismRestriction
12:15:28 <lambdabot>   Parse error
12:15:34 <Beelsebob> @let a <^ f = fmap f a
12:15:35 <lambdabot>  Defined.
12:15:37 <monochrom> To understand sequence, you must first understand recursion. To understand recursion...
12:15:49 <Beelsebob> @let f ^> a = f <*> a
12:15:49 <idnar> ah
12:15:50 <lambdabot>  Defined.
12:15:57 <mauke> ... you must first understand recursion or know someone who understands recursion
12:16:04 <Beelsebob> > [1,2,3] <^(:)^> [[]]
12:16:05 <lambdabot>   [[1],[2],[3]]
12:16:09 <Beelsebob> better :)
12:16:11 <idnar> heh
12:16:13 <monochrom> heh. but how does knowing someone help?
12:16:23 <pumpkin> lol
12:16:27 <mauke> you can just ask him to explain it to you
12:16:50 <Peaker> Beelsebob: Syntax is annoying :-(
12:17:04 <Beelsebob> I don't see what you're complaining about about syntax
12:17:05 <monochrom> this is something beyond explanation
12:17:06 <Peaker> beautiful concepts get their elegance corrupted by the textual representation
12:17:08 <Beelsebob> other than it's unfamiliar to you
12:17:09 <pumpkin> > [1,2,3] <^ (:) ^> [4, 5, 6]
12:17:10 <lambdabot>       No instance for (Num [t])
12:17:11 <lambdabot>        arising from the literal `4' at <inter...
12:17:17 <pumpkin> boo
12:17:22 <pumpkin> > [1,2,3] <^ (:) ^> [[4], [5], [6]]
12:17:23 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
12:17:26 <Beelsebob> > [1,2,3] <^ (+) ^> [4, 5, 6]
12:17:27 <lambdabot>   [5,6,7,6,7,8,7,8,9]
12:17:29 <vixey> monochrom, Is it really?
12:17:46 <vixey> monochrom, I just see it as putting induction to use
12:18:06 <arthax0r> grtz
12:18:17 <ddarius> Not all recursion is induction
12:18:30 <Peaker> Beelsebob: well, I thought <^(+)^> was meant to be taken as a single symbol, with the spaces it seems a little less bad, especially when using multiple ^> instead of multiple <*>.  I'd still prefer if we didn't have a multitude of names for the same operation, especially not infix operator names
12:18:47 <mauke> TMTOWTDI
12:19:01 <Beelsebob> Peaker: actually, I'm *really* in favor of different names for the same thing
12:19:02 <vixey> ddarius, How is that?
12:19:07 <Peaker> mauke: more like: TMTOWTSTST
12:19:13 <Peaker> mauke: to say the same thing
12:19:16 <ddarius> > ones = 1 : ones
12:19:17 <lambdabot>   <no location info>: parse error on input `='
12:19:19 <Beelsebob> e.g. (.), fmap, map, liftA, liftM.....
12:19:25 <Peaker> mauke: And I think that sucks (In Perl, too)
12:19:32 <mauke> Peaker: it's inevitable
12:19:38 <Peaker> Beelsebob: why is that a good thing?
12:19:39 <monochrom> Oh, that's co-recursion and co-induction.  *duck*
12:19:57 <mauke> cores can't curse
12:20:02 <Peaker> Beelsebob: it makes the learning curve more steep, it is more to remember, it is more confusing, ...
12:20:11 <Beelsebob> Peaker: because they're all great in different situations -- (fmap (fmap fmap fmap) fmap) looks a lot worse than (fmap . fmap . fmap) for example
12:20:21 <Beelsebob> no it doesn't make it steaper, it makes it shallower
12:20:29 <Beelsebob> noobs only have to understand map and (.)
12:20:34 <Beelsebob> not why fmap works everywhere
12:20:42 <Peaker> Beelsebob: a special case of something is not the same thing as the general case, though
12:20:58 <Beelsebob> no, but I don't see why different logic should apply
12:21:01 <Peaker> Beelsebob: whereas <*> and ^> seem to be the exact same thing
12:21:20 <Beelsebob> they are the exact same thing, but one of them makes a nice textual pattern that looks like lifting up an operator
12:21:22 <Beelsebob> and the other one doesn't
12:21:25 <Peaker> Beelsebob: so they just pollute a namespace, our memories, extra information you need to put in every tutorial about the subject, it adds up
12:21:28 <Beelsebob> <^(:)^>
12:21:35 <Peaker> Beelsebob: so why have <*> ?
12:21:45 <mauke> wait, I know this guy from chrono trigger
12:21:48 <Beelsebob> because <*> is very useful for non-infix things
12:21:55 <Peaker> Beelsebob: how is it more useful than ^> ?
12:21:55 <monochrom> Who understands + here?
12:22:27 <Beelsebob> Peaker: who knows, it's plausable that I'm even saying that we should only have <$>, <^ and ^>
12:23:09 <Peaker> Beelsebob: I agree with that.. And I also agree with your previous statements about keeping the special cases alive for learning curve. Though I believe in the long run, we should only have the general case, and a special "inliner" in the code editing UI should help newbies get over the abstractions
12:23:11 <Beelsebob> otoh, <*> looks somewhat like a circle with a star in it, from the applicative paper
12:23:41 <Peaker> Beelsebob: (Just inline the abstraction for the special case they're using it for [view-wise], to make it more concrete)
12:24:04 <Beelsebob> it's not just newbies that want the special cases though
12:24:16 <Peaker> Beelsebob: I think Haskell papers should use Haskell notation, so I don't have to reverse engineer which unicode symbols mean which Haskell things every time :)
12:24:19 <Beelsebob> I'm sure you wouldn't enjoy writing fmap (fmap (fmap fmap fmap) fmap) fmap
12:24:29 <Beelsebob> haha, so true
12:24:37 <Beelsebob> the point is that they're not haskell papers though
12:24:41 <Peaker> Beelsebob: you're right, the inliner is useful for non-newbies too
12:24:53 <Beelsebob> and they have to demonstrate to the reviewrs that they apply to all functional languages
12:24:54 <Beelsebob> not just haskell
12:25:54 <ddarius> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)) in map round $ g (repeat 1)
12:25:55 <lambdabot>   [1,3,4,4,3,3,2,0,-1,-1,-2,-2,-1,-1,-1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0...
12:26:53 * ski_ .oO( `(,[1,2,3] : ,[[]]) )
12:27:06 <ski_> (mauke : ?)
12:27:09 <vixey> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)) in map round $ g (repeat 10)
12:27:10 <lambdabot>   [10,27,36,38,34,26,15,4,-5,-12,-16,-17,-15,-11,-6,-2,3,5,7,7,6,5,3,1,-1,-2,...
12:27:26 <ski_> ddarius,vixey : what are you computing ?
12:28:02 <monochrom> Haskell is an emoticon language. It's even a multi-cultural emoticon language! Both the Western :*> and the Eastern ^_^ are allowed.
12:28:24 <monochrom> Oh darn ^_^ not allowed. But try ^*^
12:28:33 <ddarius> ^.^
12:28:54 <monochrom> >^.^<
12:28:59 <ski_> .:
12:29:27 <Beelsebob> monochrom: <^(++)^> became the pig operator, to go with the robot monkey
12:29:33 <ddarius> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)) in map round $ g (1:repeat 0)
12:29:35 <lambdabot>   [1,2,1,0,0,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
12:29:48 <monochrom> >@.@<   the Einstein tensor operator
12:30:04 <EmielRegis> lies
12:30:18 <olsner> is that the spinning eyes with brain flying out your ears smiley?
12:30:32 <monochrom> Oh, remind me, what is the robot monkey operator?  :[]  ?
12:30:41 <olsner> this one? (:[])
12:30:42 <Beelsebob> (:[])
12:30:49 <monochrom> OK thanks. :)
12:30:58 <idnar> (:[{ OM NOM NOM NOM }])
12:31:04 <Beelsebob> are you creating a catalogue of emoticon operators?
12:31:09 <roconnor> @src return []
12:31:09 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:31:12 <idnar> err
12:31:15 <idnar> I mean {- and -} obviously
12:31:16 <roconnor> @src [] return
12:31:16 <lambdabot> return x    = [x]
12:31:18 <vixey> return = (:[])
12:31:19 <roconnor> aww
12:31:31 <ddarius> @. pl src [] return
12:31:31 <lambdabot> (line 1, column 1):
12:31:32 <lambdabot> unexpected end of input
12:31:32 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:31:48 <olsner> this needs to be fixed! where is lambdabot's @src database?
12:32:40 <vixey> @@ (@src [] return)
12:32:52 <vixey> @. (@src [] return)
12:32:53 <lambdabot> Plugin `compose' failed with: Unknown command: "(@src"
12:32:58 <vixey> @@ @src [] return
12:33:23 <olsner> @pl return x = [x]
12:33:23 <lambdabot> return = return
12:33:26 <vixey> @@ (@yow)
12:33:26 <lambdabot>  I want to dress you up as TALLULAH BANKHEAD and cover you with VASELINE
12:33:27 <lambdabot> and WHEAT THINS ...
12:33:37 <vixey> @@ (@src ([] return))
12:35:05 <ddarius> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)) in map round $ g (cycle $ 1:replicate 7 0 ++ -1:replicate 7 0)
12:35:07 <lambdabot>   [1,2,1,0,0,-1,-1,-1,-2,-2,-1,0,1,1,2,2,2,3,1,0,-1,-1,-2,-2,-3,-3,-2,0,1,1,2...
12:35:23 <ddarius> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)) in drop 20 $ map round $ g (cycle $ 1:replicate 7 0 ++ -1:replicate 7 0)
12:35:24 <lambdabot>   [-1,-1,-2,-2,-3,-3,-2,0,1,1,2,2,3,3,2,0,-1,-1,-2,-2,-3,-3,-2,0,1,1,2,2,3,3,...
12:35:29 <ddarius> Excellent.
12:35:56 <mauke> ski_: http://www.chronocompendium.com/images/wiki/7/74/Scouter_Sprites.png
12:35:58 <lambdabot> http://tinyurl.com/5jyyv2
12:37:50 <alexsuraci> @help pl
12:37:50 <lambdabot> pointless <expr>. Play with pointfree code.
12:38:27 <alexsuraci> @pl (\(x, y) -> (x `elem` [1, 2]) && (y `elem` [1, 2]))
12:38:27 <lambdabot> uncurry ((. (`elem` [1, 2])) . (&&) . (`elem` [1, 2]))
12:39:21 <alexsuraci> could that be done with fst and snd?
12:39:22 <mauke> all (`elem` [1, 2]) [x, y]
12:39:44 <mauke> \xy -> ... fst xy ... snd xy
12:39:55 <ddarius> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)) in drop 20 $ map round $ g (cycle $ 1:replicate 15 0 ++ -1:replicate 15 0)
12:39:56 <lambdabot>   [0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,-1,-1,-1,-1,-1,0,0,0,0,0,0,-1,-1,-1,0,0,...
12:40:11 <alexsuraci> mauke: point-free I mean
12:40:24 <ddarius> > let h x2 x1 (x0:xs) ~(y2:y1:ys) = (x0 - x2 + 1.66*y1 - 0.81*y2):h x1 x0 xs (y1:ys); g xs = fix (h 0 0 xs . (0:) . (0:)) in drop 40 $ map round $ g (cycle $ 10:replicate 15 0 ++ -10:replicate 15 0)
12:40:25 <lambdabot>   [-8,-6,-3,-1,2,3,4,4,-7,-14,-8,-2,3,7,9,9,8,6,3,1,-2,-3,-4,-4,7,14,8,2,-3,-...
12:40:28 <mauke> run it through @pl
12:40:42 <alexsuraci> ah, right, duh
12:40:49 <vixey> @oies -8,-6,-3,-1,2,3,4,4,-7,-14,-8,-2,3,7,9,9,8,6,3,1,-2,-3,-4,-4,7,14,8,2,-3
12:40:49 <lambdabot>  Sequence not found.
12:41:11 <alexsuraci> @pl (\xs -> ((fst xs) `elem` [1, 2]) && ((snd xs) `elem` [1, 2]))
12:41:11 <lambdabot> ap ((&&) . (`elem` [1, 2]) . fst) ((`elem` [1, 2]) . snd)
12:41:28 <alexsuraci> closer to what I was expecting
12:42:15 <Peaker> Beelsebob: are feedback loops currently not implemented, or just buggy, in Reactive?
12:42:39 <mauke> :t liftA2 (&&) ((`elem` [1, 2]) . fst) ((`elem` [1, 2]) . snd)
12:42:40 <lambdabot> forall a b. (Num b, Num a) => (a, b) -> Bool
12:43:58 <Peaker> :t let x = ((`elem` [1,2]).) in liftA2 (&&) (x fst) (x snd)
12:43:59 <lambdabot> forall a b. (Num a, Num b) => (a, b) -> Bool
12:44:53 <Peaker> :t let x = ((`elem` [1,2]).) in liftA2 and $ map x [fst,snd]
12:44:54 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
12:44:54 <lambdabot>     Probable cause: `and' is applied to too many arguments
12:44:54 <lambdabot>     In the first argument of `liftA2', namely `and'
12:44:54 <ski_> (mauke : ok .. what about that creature ?)
12:45:14 <Peaker> :t let x = ((`elem` [1,2]).) in and <*> map x [fst,snd]
12:45:15 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
12:45:15 <lambdabot>     Probable cause: `and' is applied to too many arguments
12:45:15 <lambdabot>     In the first argument of `(<*>)', namely `and'
12:45:27 <mauke> ski_: <^(:)^> reminded me of it
12:46:06 <ski_> oh
12:48:17 <pumpkin> @pl (f (g x))
12:48:17 <lambdabot> f (g x)
12:48:24 <pumpkin> fancy!
12:48:34 <vixey> @pl \g -> f (g x)
12:48:35 <lambdabot> f . ($ x)
12:48:38 <vixey> @pl \f -> f (g x)
12:48:38 <lambdabot> ($ g x)
12:51:53 <Peaker> hmm, there's no mapM for Applicative?
12:52:01 <Peaker> (it doesn't really depend on monadic stuff)
12:52:03 <vixey> I thught mapA is not expessible
12:52:10 <vixey> :t mapM
12:52:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:52:32 <dibblego> Peaker, I think Traversable has mapM
12:52:35 <pumpkin> not expressible?
12:52:44 <lispy> blasphmy!
12:52:50 <lispy> it's all expressible!
12:52:51 <Peaker> vixey: sequenceA is expressible, so this should be, because a map between the first two args should make it a case of sequence
12:53:45 <Peaker> vixey: for something to be expressible as a Monad, and not as an Applicative, there has to be a dependence of the monadically-bound things on the previous monadic results
12:53:49 <lispy> The cleverness of people who are eager to express the "unexpresible" in haskell never ceases to surprise and entertain
12:53:56 <vixey> oh how do you write seequenceA?
12:54:04 <Peaker> @hoogle sequenceA
12:54:05 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
12:54:05 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
12:54:09 <Peaker> @src sequenceA
12:54:09 <lambdabot> Source not found. Where did you learn to type?
12:54:11 <Deewiant> ?ty (sequenceA .) . map
12:54:11 <vixey> ok needs traversable
12:54:12 <lambdabot> Not in scope: `sequenceA'
12:54:13 <pumpkin> I really look forward to understanding all the jargon that gets thrown around in here
12:54:24 <vixey> hm
12:54:38 <vixey> how about just Applicative f => [f a] -> f [a]?
12:54:49 <ski_> @type foldr (liftA2 (:)) (Control.Applicative.pure [])
12:54:50 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
12:54:59 <lispy> pumpkin: you need a catamorphism of concepts then
12:55:25 <vixey> cool!
12:55:27 <pumpkin> :)
12:55:33 <pumpkin> is that like a dogamorphism?
12:55:34 <vixey> where on earth did I get the idea it as impossible to write it?
12:56:47 <ski_> @let liftA0 a = Control.Applicative.pure a
12:56:48 <lambdabot>  Defined.
12:56:50 <twanvl> sequenceA works not only for lists, but for any traversable container
12:58:17 <Peaker> I want: liftAn :: Applicative f => ([a] -> b) -> [f a] -> f b
12:58:20 <Peaker> :t \f xs = f <$> sequenceA xs
12:58:21 <lambdabot> parse error on input `='
12:58:26 <Peaker> :t \f xs -> f <$> sequenceA xs
12:58:27 <lambdabot> Not in scope: `sequenceA'
12:58:40 <Peaker> :t \f xs -> f <$> Data.Traversable.sequenceA xs
12:58:41 <lambdabot> forall b (t :: * -> *) (f :: * -> *) a. (Applicative f, Data.Traversable.Traversable t) => (t a -> b) -> t (f a) -> f b
12:58:57 <Peaker> cool :)
12:59:12 <Peaker> I think liftAn may be useful?
13:00:27 <twanvl> > Data.Traversable.sequenceA (Just "abc")
13:00:28 <lambdabot>   [Just 'a',Just 'b',Just 'c']
13:00:36 <twanvl> > Data.Traversable.sequenceA [Just 'a',Just 'b',Just 'c']
13:00:37 <lambdabot>   Just "abc"
13:02:45 <Peaker> twanvl: what does Maybe do as a Traversable?
13:03:10 <Peaker> ah, I guess just a normal fold? (maybe)
13:04:37 <twanvl> traverse f Nothing = pure Nothing;  traverse f (Just x) = Just <$> f x
13:05:35 <Peaker> @type traverse
13:05:36 <lambdabot> Not in scope: `traverse'
13:05:45 <Peaker> @type Data.Traversable.traverse
13:05:46 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
13:07:40 <twanvl> traverse f = sequenceA . fmap f
13:08:05 <ddarius> :t \f -> liftM head . mapM f . (:[])
13:08:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> a -> m b
13:08:06 <twanvl> just like how   mapM f = sequence . map f
13:09:09 <ski_> sequence = mapM return
13:09:17 <Peaker> twanvl: oh, I had no idea traverse was related to mapM
13:09:24 <ski_> sequenceA = fmap liftA0
13:09:33 <nomeata> Hi. Im getting this error when linking a project (using HAppS and Template Haskell):
13:09:36 <nomeata> .text+0x1f409): undefined reference to `base_DataziTuple_Z63T_con_info'
13:09:46 <nomeata> How can I find out what library I have to recompile?
13:10:07 <Peaker> nomeata: try to recompile that project's .o and .hi files, before recompiling the libs?
13:10:10 <ski_> catamorphism  n  familiar term for properly "category morphism"; derived from the diminutive "cat"
13:10:29 <nomeata> Peaker: Already did that, thanks.
13:13:03 <nomeata> Peaker: any other hint?
13:13:23 <Peaker> nomeata: it seems to be a symbol from the base library
13:13:37 <Peaker> @hoogle con_info
13:13:37 <lambdabot> No results found
13:13:49 <Peaker> nomeata: I'm not an expert on ghc builds though, sorry :-(
13:14:14 <nomeata> ok, thx
13:20:53 <nomeata> Ah, it seems Im creating a tuple with more than 62 elements somewhere..
13:21:02 <Peaker> Why? :-)
13:21:11 <dons> nomeata: sounds like a bad idea
13:21:15 <dons> use data
13:21:21 <roconnor> haskell supports 62 tuples?
13:21:35 <Giraffe> oh god...
13:21:38 <olsner> @remember nomeata Ah, it seems Im creating a tuple with more than 62 elements somewhere..
13:21:38 <lambdabot> Nice!
13:21:45 <Peaker> (a,b,c) ought to be (a,(b,c)) or (a,(b,(c,())) ..
13:21:51 <roconnor> > (0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9)
13:21:52 <lambdabot>       No instance for (Show
13:21:52 <lambdabot>                         (t,
13:21:52 <lambdabot>                      ...
13:21:56 <Giraffe> a 62-tuple?
13:22:02 <roconnor> oh it does
13:22:04 <olsner> a 62-tuple is the largest tuple I've ever heard of yet actually
13:22:05 <Giraffe> :x
13:22:05 <idnar> hahaha
13:22:07 <mauke> olsner: :-(
13:22:18 <nomeata> dons: its created inside HAppS::State, it seems...
13:22:30 <Lemmih> nomeata: Huh?
13:22:45 * nomeata tries to dump the splices
13:22:46 <Phyx-> anyone got a link for me which shows how to use Typeable? i don't find the haddoc for it handy for a first timer
13:22:55 <nomeata> Lemmih: yes, it happens when I add a method to my state
13:23:00 <olsner> mauke: why the sad face?
13:23:17 <mauke> olsner: because you put some weird control characters in a quote
13:23:36 <olsner> mauke: only because they were there to begin with
13:23:39 <idnar> it's just an apostrophe
13:23:44 <mauke> olsner: no, they weren't
13:23:53 <mauke> U+2019 (e2 80 99): RIGHT SINGLE QUOTATION MARK []
13:24:01 <idnar> mauke: that was in nomeata's original message
13:24:04 <mauke> no
13:24:06 <idnar> wait
13:24:14 <idnar> maybe irssi is confusing me
13:24:18 <Giraffe> nah, it is in the original message
13:24:18 <olsner> I just copy-pasted from the original message
13:24:24 <mauke> fix your client
13:24:25 <twanvl> > (0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9)
13:24:27 <lambdabot>       No instance for (Show
13:24:27 <lambdabot>                         (t,
13:24:27 <lambdabot>                      ...
13:24:37 <twanvl> > (0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4)
13:24:37 <mauke>    
13:24:38 <lambdabot>       A 65-tuple is too large for GHC
13:24:38 <lambdabot>        (max size is 62)
13:24:38 <lambdabot>        Workarou...
13:24:38 <Giraffe> 16:20 < nomeata> Ah, it seems Im creating a tuple with more than 62 elements somewhere..
13:24:43 <idnar> ah, right I see
13:24:45 <mauke> Giraffe: that looks ok
13:24:55 <idnar> olsner added the quote in ISO-8859-1 or something
13:24:55 <Giraffe> mauke, i still see that quote mark
13:24:58 <idnar> whereas the original was UTF-8
13:25:04 <Giraffe> ahhh
13:25:21 <idnar> I think irssi is set up to fall back to iso-8859-1 if utf-8 doesn't work
13:25:22 <mauke> it's not a quote in olsner's message, at least not in ISO 8859-1
13:25:24 <ski_> (on this side, the original message had a normal single quotation mark, while the remembered one looks like it has a C-r or something)
13:25:24 <idnar> so it looks the same to me
13:25:30 <mauke> idnar: whoa
13:25:41 <ski_> (this side being irssi)
13:26:10 <idnar> hmm
13:26:11 <mauke> ski_: same here
13:26:16 <idnar> I'm not sure what charset that is, actually
13:26:44 <mauke> U+0092 (c2 92): <control> []
13:26:58 <mauke> that's what olsner sent; it's not a printable character in ISO 8859-1
13:26:58 <robertg> i'm having a bit of trouble with my program shown here http://phpfi.com/381835 - the trouble is that it only works when there is only one ace and it is the first in the list, can anyone help?
13:27:24 <Botje> use hpaste the next time, it has colors :)
13:27:27 <olsner> so I sent it as UTF-8 and received it as ISO-8859-1 in the original message?
13:27:33 <vixey> robertg, I think you should define Card differently
13:27:51 <vixey> robert, data Soething = Ace | Two | ... instead of String
13:27:53 <nomeata> Lemmih: hmm, the output with -ddump-splices look non-suspicious
13:27:55 <idnar> mauke: I didn't get a c2, only 92
13:28:02 <mauke> olsner: huh?
13:28:18 <mauke> idnar: yes, he only sent a 92 byte. what my client shows is the UTF-8 encoding of codepoint 92 :-)
13:28:23 <robertg> I would, that is the spec I was given
13:28:36 <idnar> mauke: ah
13:28:51 <idnar> so, in what charset *is* that a quotation mark?
13:29:33 <nomeata> Lemmih: ah, but it seems I crossed the 62-methods-mark for my state
13:29:33 <Botje> robertg: because you do sumlist (val x ++ handValue xs) you'll never get more than one element in your list
13:29:34 <idnar> oh! CP1252
13:29:43 <idnar> recode_fallback = CP1252
13:29:58 <olsner> I'm almost definitely not sending CP1252 anywhere
13:30:00 <robertg> ok, I do get two when the ace is first
13:30:02 <nomeata> Lemmih: Do you somewhere rely on making a tuple of all methods?
13:30:09 <mauke> Windows-1252, grr
13:30:31 <Botje> robertg: you could use store intermediate hand values
13:30:35 <idnar> olsner: you definitely sent a right quotation mark encoded in cp1252 :P
13:30:40 <Lemmih> nomeata: I can't recall.
13:30:55 <Botje> handValue v [] = [v]; handValue v (x:xs) = handValue (v + val x) xs
13:31:22 <idnar> olsner: the original message was in utf-8, though, so it seems like it got mangled in the copy/paste somehow
13:31:25 <Botje> and the ace case then becomes something like handValue (v + 1) xs ++ handValue (v + 11) xs
13:31:30 <olsner> idnar: probably that character has the same code in cp1252 as in latin1
13:31:30 <robertg> handValue has to be of the form handValue :: [Card] -> [Int]
13:31:34 <mauke> olsner: no.
13:31:41 <Botje> then use a helper function :)
13:31:44 <mauke> olsner: I repeat: this is a control character in latin1
13:31:45 <idnar> olsner: nope, it's an unprintable in latin1 :/
13:32:00 <idnar> olsner: is Windows involved anywhere in your IRCing process?
13:32:17 <olsner> idnar: not on my end at least :)
13:32:31 <mauke> can you configure your client to send utf-8 by default?
13:32:41 <idnar> well, maybe xchat just has a braindead default config
13:32:42 <Botje> okay
13:32:51 <Botje> alternative: use map
13:32:53 <Botje> a lot :)
13:32:58 <nomeata> Strange. I can load StateMethods into ghci, but using it in main gives StateMethods.o: In function `rKKJ_info': (.text+0x1f409): undefined reference to `base_DataziTuple_Z63T_con_info'
13:33:00 <robertg> hehe
13:33:52 <mauke> did you compile with --make?
13:34:00 <mauke> wait, that's in base. nvm
13:34:42 <robertg> Botje: i'm not sure what v is in your example
13:34:45 <nomeata> mauke: no, the problem is not the linking, the problem is the code that wants to know something about the 63-tuple-constructor
13:34:56 <nomeata> mauke: probably TH-generated
13:35:07 <vixey> fix the TH
13:35:17 <pumpkin_> @src mapAccumR
13:35:18 <lambdabot> Source not found. My mind is going. I can feel it.
13:35:19 <olsner> what does this  come out as then?
13:35:34 <mauke> U+2019 (e2 80 99): RIGHT SINGLE QUOTATION MARK []
13:35:37 <mauke> success
13:35:50 <nomeata> vixey: Id like to, but I cant find it... (its in some library, I think)
13:35:59 <olsner> and now? ?
13:36:33 <Lemmih> vixey: And -ddump-slices shows no tuples?
13:36:36 <yitz> @seen Peaker
13:36:36 <lambdabot> Peaker is in #haskell. I last heard Peaker speak 14m 50s ago.
13:36:37 <dcoutts_> vixey: you were having cabal problems?
13:36:45 <mauke> <olsner> and now? ?
13:36:56 <idnar> that was \x3f
13:37:00 <Peaker> yitz: ?
13:37:08 <mauke> yeah, a question mark
13:37:17 <yitz> Peaker: hi. can I msg u?
13:37:22 <Peaker> yitz: sure
13:37:26 <olsner> but I think the real problem is that nomeata somehow gets "right single quotation mark" instead of apostrophes in all his messages
13:38:01 <Lemmih> nomeata: And -ddump-slices shows no tuples?
13:38:02 <mauke> olsner: I don't think that's a problem 
13:38:25 <nomeata> Lemmih: no, but the method instance function has 63 elements...
13:38:25 <Lemmih> nomeata: grep say that HAppS-State isn't using any tuples.
13:38:33 <olsner> that was with latin-1, and this  is with latin-1/utf-8 hybrid (the setting I had from the start)
13:38:52 <nomeata> Lemmih: oh, nevermind, it must be the call to makeMethods :-)
13:39:11 <nomeata> Lemmih: mkMethods to be exact
13:39:18 <Botje> robertg: copious application of concatMap does the trick.
13:39:27 <Botje> handValue :: [Card] -> [Int]
13:39:27 <Botje> handValue [] = [0]
13:39:28 <Botje> handValue (x:xs) = concatMap (\v -> concatMap (\y -> [v + y]) (val x))          (handValue xs)
13:39:40 <Botje> of course it's a lot easier if you write it in do notation or using list comprehensions.
13:39:42 <olsner> weird of xchat to send that last one as a literal '?' while showing it as a '' on my screen
13:39:55 <nomeata> Lemmih: hmm, no, that gets a list as well...
13:40:05 <takinitez> just to see if my xchat is doing that, too: ' `  
13:40:40 <Lemmih> nomeata: Can you paste the spliced code?
13:40:45 <takinitez> does that look healthy?
13:40:56 <mauke> takinitez: no :-)
13:41:27 <robertg> thanks Botje
13:41:29 <takinitez> weird codepage-mangled crap?
13:41:45 <nomeata> Lemmih: yes, exactly 63 methods added. Guess Im the first one to use HAppS so far :-)
13:41:54 <mauke> takinitez: you're sending stuff in cp1252
13:41:55 <Botje> handValue (x:xs) = [ v+y | y <- val x, v <- handValue xs]
13:42:06 <takinitez> yuck!
13:42:20 <nomeata> Lemmih: http://nomeata.de/splices-dump.txt
13:42:25 <Lemmih> nomeata: You can use more than one component, you know.
13:42:29 <pumpkin_> is there any work on making "set comprehensions" rather than list comprehensions?
13:43:06 <nomeata> Lemmih: do i still get atomicity if I change stuff from more than one component at a time?
13:43:30 <Botje> pumpkin_: i thought sets were monads?
13:43:39 <pumpkin_> are they? hmm
13:43:46 <pumpkin_> I thought I read somewhere that they weren't
13:43:49 <Botje> ah
13:43:50 <Lemmih> nomeata: Nope, that's the trade-off.
13:43:51 <Botje> could be :)
13:43:51 <pumpkin_> (and that they should be)
13:44:07 <vixey> Botje, I think there some problem with the Ord constraint
13:45:08 <Lemmih> nomeata: Hm, I don't know how to fix it. Perhaps it has gone away in ghc-6.10.
13:45:09 <pumpkin_> aha, http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
13:45:17 <pumpkin_> looks scary
13:45:18 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
13:45:30 <takinitez> is it sane enough to change it without reconnect? --  
13:45:42 <mauke> takinitez: nope
13:46:05 <nomeata> Lemmih: :-( I had planned to use the app on a Debian stable server. but I guess I broke it, I can try to fix it.
13:48:25 <takinitez> stuff like this should not happen :(
13:51:08 <nomeata> Lemmih: I can see it used in the temporary assembler file  maybe some optimizing going wrong?
13:51:13 <ski_> (pumpkin_ : evil, rather, imo)
13:51:40 <pumpkin_> ski_: but on the whole, it seems like a reasonable thing to want... just that it's a big hack given the current implementation?
13:51:52 <pumpkin_> or is there something inherently un-monadic about a set?
13:52:01 <ski_> no
13:52:43 <nomeata> Lemmih: but I cant really read that yet :-)
13:55:52 <agl> Upgrading to 6.10.1 broke backspace (as well as up, down etc) in GHCi and cabal install now has a massive space leak, immediately eating all memory until the OOM killer zaps it. Are there any well known bug workarounds that I should know about?
13:56:50 <agl> if nothing else, I guess it'll teach me never to install the .1 release of any GHC ;)
13:57:35 <pumpkin_> oh, does ghc follow the odd minor = beta convention?
13:58:01 <mauke> agl: 6.10 dropped official support for libreadline
13:58:37 <agl> mauke: right, thanks. That probably explains backspace
13:58:44 <Draconx> agl, you may need to add bindings for your terminal in ~/.editrc
14:00:57 <mauke> agl: (I built mine with readline hacked it (I can't stand editline))
14:02:10 <agl> I probably need to rebuild GHC with libedit-dev. I'll try that.
14:02:34 <shapr> agl: hiya!
14:02:58 <agl> shapr: hi!
14:03:21 <dcoutts> agl: you need to upgrade cabal-install to the latest version for it to work with 6.10
14:03:43 <dcoutts> agl: if you've still got 6.8 installed then cabal install -w ghc-6.8.3 cabal-install
14:03:53 <agl> shapr: first free Sunday in a long time and I thought that I would try out Yi. Serves me right :)
14:04:37 <agl> dcoutts: I've Cabal 1.6.0.1 and cabal-install 0.6.0
14:04:53 <dcoutts> agl: well that version does not have the problem with 6.10
14:05:01 <agl> dcoutts: do I need newer than that? I'll try to debug the space leak once I get GHCi working
14:05:28 <dcoutts> agl: are you absolutely sure you're using the right version, and you've not got some older version on your $PATH ?
14:05:39 <shapr> agl: Yi sure is nifty.
14:07:42 <agl> dcoutts: I'll delete everything, rebuild GHC then install Cabal, HTTP, zlib and see if things sort themselves out
14:08:10 <agl> thanks all
14:08:14 <dcoutts> agl: it's not a random problem
14:08:37 <nomeata> Lemmih: ok, using -ddump-prep gives some functions that pattern-match on 63-tuples
14:08:45 <dcoutts> agl: it was a known bug with cabal-install-0.5.x when used with ghc-6.10. The bug is definitely fixed in 0.6.x.
14:08:54 <Lemmih> nomeata: Which functions?
14:09:12 <dcoutts> agl: so if cabal --version reports 0.6 then you should be fine.
14:09:27 <nomeata> Lemmih: they look like this: $dQueryEvent20_r73g, Im trying to find out where they come from
14:09:52 <agl> dcoutts: ah ok, good to know. I've just deleted everything and started the ghc build afresh. I should know in a couple of hours :)
14:13:31 <nomeata> Lemmih: it seems to be related to serialization
14:14:04 <nomeata> Lemmih: http://nomeata.de/core-dump.txt (1MB)
14:14:31 <nomeata> Lemmih: function ic_r6Zw seems to be the problem
14:16:45 <nomeata> Lemmih: it seems to construct an 63-tuple
14:17:32 <pumpkin_> oh my
14:17:59 <nomeata> Lemmih: its type is ic_r6Zw :: (HAppS.State.ComponentSystem.Methods State.State) => (HAppS.State.ComponentSystem.UpdateEvent StateMethods.SetLeasable (), HAppS.State.ComponentSystem.UpdateEvent StateMethods.GetLeasable (Data.Maybe.Maybe Types.Leasable), ...
14:18:07 <nomeata> Lemmih: does that maybe ring a bell?
14:20:17 <Peaker> it kinda sucks that the _darcs dir shows up in greps
14:20:40 <pumpkin_> :t randomR
14:20:41 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
14:21:05 <dcoutts> Lemmih: lhc project created on code.h.o
14:21:18 <Lemmih> dcoutts: Thank you.
14:24:27 <RedBolt> Hi there
14:25:22 <Lemmih> nomeata: I have no idea where that's from.
14:25:23 <RedBolt> can someone tell me if i can have a list by comprehension defined by recursion?
14:25:29 <yitz> Peaker: yeah. use prune.
14:26:18 <gwern> hm. does anyone know what '-lperl' is asking for in the pugs install?
14:26:29 <Peaker> yitz: what's that?
14:26:31 <gwern> I mean, I have 'perl' installed, but I dunno what perl library that could be
14:26:49 <yitz> Peaker: an option to 'find'
14:27:32 <yitz> or pipe the output of find through a grep -v
14:27:59 <yitz> RedBolt: paste it?
14:28:08 <yitz> @hpaste
14:28:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:28:58 <RedBolt> the list is basically [1,2,6,24,120,720] the recursion for it: f(n) = f(n-1)*n
14:29:38 <vixey> @let f n = f (n-1) * n
14:29:39 <lambdabot>  <local>:4:6:
14:29:40 <lambdabot>      Ambiguous occurrence `f'
14:29:40 <lambdabot>      It could refer to either `L....
14:29:45 <vixey> > let f n = f (n-1) * n in iterate f 1
14:29:47 <lambdabot>   [1,* Exception: stack overflow
14:29:57 <yitz> > extendSequence [1,2,6,24,120,720]
14:29:59 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
14:30:10 <vixey> > let f 1 = 1 ; f n = f (n-1) * n in iterate f 1
14:30:12 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:30:16 <opqdonut> vixey: why iterate?
14:30:21 <opqdonut> more like map f [1..
14:30:24 <opqdonut> ]
14:30:25 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
14:36:24 <yitz> > fix $ (1:) . zipWith (*) [2..]
14:36:26 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
14:45:53 <Lemmih_> nomeata: Ah, I think I know what the problem is.
14:46:16 <nomeata> Lemmih_: great! Is it fixable? :-)
14:46:55 <Lemmih_> nomeata: It is.
14:47:03 <sm> hledger 0.2 released
14:48:11 <Lemmih_> nomeata: Hm, maybe not.
14:50:38 <nomeata> Lemmih_: I have created a minimal example for this bug
14:51:20 <nomeata> Lemmih_: http://hpaste.org/12305
14:51:31 <nomeata> eh, truncated
14:51:32 <ddarius> > scanl (+) 0 $ repeat 1
14:51:34 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:51:40 <pumpkin_> oh my
14:51:47 <ddarius> @let integrator = scanl (+) 0
14:51:48 <lambdabot>  Defined.
14:51:52 <pumpkin_> I've been wondering what scanl did
14:51:59 <pumpkin_> @src scanl
14:51:59 <lambdabot> scanl f q ls = q : case ls of
14:51:59 <lambdabot>     []   -> []
14:51:59 <lambdabot>     x:xs -> scanl f (f q x) xs
14:52:05 <ddarius> @let comparator = map (\x -> if x > 0 then 1 else -1)
14:52:06 <lambdabot>  Defined.
14:52:54 <dons> http://www.reddit.com/r/programming/comments/7f7oz/hpylos_a_haskell_implementation_of_pylos_game/
14:52:56 <lambdabot> Title: HPylos: A Haskell implementation of Pylos game with AI and a GLUT interface : pr ..., http://tinyurl.com/6fkl8l
14:52:59 <dons> yay haskell gl games
14:53:51 <pumpkin_> is there a list of good haskell-themed blogs to read somewhere? :)
14:54:09 <dons> Lemmih_: have you thought about FFI calls between lhc and ghc code?
14:54:12 <dons> would be interesting
14:54:13 <nomeata> Lemmih_: I got to go. I posted my minimal example on the HAppS mailing list. Itd be really great if this restriction could be lifted somehow.
14:54:21 <nomeata> Lemmih_: thx in advance!
14:54:37 <ddarius> pumpkin_: planet.haskell.org
14:54:51 <Lemmih_> dons: I'm not quite sure how that would work.
14:56:56 <luite_> http://hpaste.org/12306 <- I'm trying to run some test with RandomGen/MonadSplit, but I can't figure out why this doesn't compile. any ideas?
14:57:30 <luite_> I may have some wrong understanding of how polymorphism works
14:58:07 <ddarius> @let schmitt True (x:xs) | x > 0.8 = -1:schmitt False xs | otherwise = 1:schmitt True xs; schmitt False (x:xs) | x < -0.8 = 1:schmitt True xs | otherwise = -1:schmitt False xs
14:58:08 <lambdabot>  Defined.
14:58:52 <ddarius> > schmitt True $ [1,0.9 .. 0.0] ++ [0.0, 0.1, 1.0]
14:58:54 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1* Exception: <local>:6:0-169: Non...
14:59:08 <ddarius> > schmitt True $ [1,0.9 .. 0.0] ++ [0.0, 0.1, 1.0] ++ repeat 0
14:59:10 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1...
14:59:21 <ddarius> > drop 10 $ schmitt True $ [1,0.9 .. 0.0] ++ [0.0, 0.1, 1.0] ++ repeat 0
14:59:22 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1...
14:59:58 <ddarius> @undef
15:01:24 <ddarius> @bot
15:01:24 <lambdabot> :)
15:01:44 <opqdonut> @cookie
15:01:44 <lambdabot> Unknown command, try @list
15:01:54 <vixey> why is it all -1 ?
15:02:06 <ddarius> Because I wrote it wrong
15:02:12 <ddarius> and gave it the wrong input
15:02:43 <opqdonut> good answer
15:03:23 <ddarius> > schmitt True $ [1,0.9 .. -1.0] ++ [-1.0, -0.9 .. 1.0] ++ repeat 0
15:03:24 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,...
15:03:36 <ddarius> > drop 10 $ schmitt True $ [1,0.9 .. -1.0] ++ [-1.0, -0.9 .. 1.0] ++ repeat 0
15:03:37 <lambdabot>   [1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1...
15:03:47 <ddarius> > drop 20 $ schmitt True $ [1,0.9 .. -1.0] ++ [-1.0, -0.9 .. 1.0] ++ repeat 0
15:03:48 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,...
15:04:24 <dons> Lemmih_: maybe just process level i guess
15:04:36 <dons> Lemmih_: though its nice to imagine calling an algorithm optimised with lhc
15:04:49 <nomeata> Lemmih_: its not TH-related, I could reproduce it by pasting the splices (test case sent to the list)
15:05:16 <Lemmih> nomeata: Right. It's a GHC bug. We can probably work around it.
15:05:30 <ddarius> > fix $ schmitt True . map negate . integrator . (0.1:)
15:05:31 <lambdabot>       No instance for (Fractional Integer)
15:05:32 <lambdabot>        arising from a use of `schm...
15:05:42 <ddarius> :t integrator
15:05:44 <lambdabot> forall a. (Num a) => [a] -> [a]
15:05:45 <nomeata> Lemmih: ok. will you keep me up-to-date via the HAppS list?
15:05:49 <ddarius> :t schmitt
15:05:50 <lambdabot> forall t a. (Fractional t, Ord t, Num a) => Bool -> [t] -> [a]
15:05:55 <pumpkin_> oh sweet, I can read RWH on my school's safari account
15:06:02 <pumpkin_> I still want a paper copy though
15:06:27 <Lemmih> nomeata: Sure thing.
15:06:39 <nomeata> Lemmih: thx. Gotta go now, cu around
15:06:49 <ddarius> > fix $ schmitt True . map negate . integrator . ((0.1 :: Double):)
15:06:50 <lambdabot>   Couldn't match expected type `Integer'
15:09:07 <ddarius> > map round $ fix $ schmitt True . map negate . integrator . (0.1:)
15:09:09 <lambdabot>   [1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-...
15:09:17 <pumpkin_> :po
15:11:14 <hackage> Uploaded to hackage: hledger 0.2
15:11:25 <ddarius> > fix $ integrator . (0.1:) . schmitt True . map negate
15:11:27 <lambdabot>   [0.0,0.1,1.1,2.1,1.1,0.10000000000000009,-0.8999999999999999,-1.9,-0.899999...
15:15:31 <ddarius> @let relaxation ys = comparator $ fix $ integrator . (0.1:) . schmitt True . zipWith subtract ys . map negate
15:15:32 <lambdabot>  Defined.
15:15:41 <ddarius> > relaxation (repeat 0)
15:15:43 <lambdabot>   [-1.0,1.0,1.0,1.0,1.0,1.0,-1.0,-1.0,-1.0,1.0,1.0,1.0,1.0,1.0,-1.0,-1.0,-1.0...
15:16:03 <ddarius> > drop 10 $ relaxation (repeat 0)
15:16:04 <lambdabot>   [1.0,1.0,1.0,1.0,-1.0,-1.0,-1.0,1.0,1.0,1.0,1.0,1.0,-1.0,-1.0,-1.0,1.0,1.0,...
15:17:38 <ddarius> > let xs = relaxation ys; ys = relaxation (map negate xs) in zip xs ys
15:17:40 <lambdabot>   [(-1.0,-1.0),(1.0,1.0),(1.0,-1.0),(1.0,1.0),(-1.0,1.0),(-1.0,1.0),(-1.0,1.0...
15:18:12 <ddarius> > drop 5 $ let xs = relaxation ys; ys = relaxation (map negate xs) in zip xs ys
15:18:13 <pumpkin_> ddarius: what is all this doing?
15:18:14 <lambdabot>   [(-1.0,1.0),(-1.0,1.0),(-1.0,1.0),(-1.0,-1.0),(1.0,-1.0),(1.0,-1.0),(1.0,-1...
15:18:21 <vixey> It's some black magic
15:18:34 <pumpkin_> very black magic
15:18:37 <vixey> > iterate (* (0 :+ 1)) 1
15:18:39 <lambdabot>   [1.0 :+ 0.0,0.0 :+ 1.0,(-1.0) :+ 0.0,(-0.0) :+ (-1.0),1.0 :+ (-0.0),0.0 :+ ...
15:20:07 <ddarius> > drop 5 $ let xs = relaxation ys; ys = relaxation (map negate xs) in zip (map round xs) (map round ys)
15:20:09 <lambdabot>   [(-1,1),(-1,1),(-1,1),(-1,-1),(1,-1),(1,-1),(1,-1),(1,-1),(1,1),(1,1),(1,1)...
15:22:19 <ddarius> Anyway, this is a simple model of quadrature cross-coupled relaxation oscillators.
15:22:45 <Giraffe> *** Exception: no buffering
15:22:55 <Giraffe> why do i get this error in ghci, but not ghc?
15:23:39 <ddarius> The earlier stuff was a bandpass filter selecting the first overtone of a signal.
15:23:46 <dons> ghci's command line interface sets different buffering on the handle by default, i imagine
15:24:09 <Giraffe> right
15:24:18 <Giraffe> well i'm using ByteString.getLine there, so...
15:36:35 <pumpkin_> why does "point-free" code have more points in it? :P
15:39:20 <dons> pumpkin_: you read the wiki page right?
15:39:36 <RayNbow> http://www.haskell.org/haskellwiki/Pointfree#But_pointfree_has_more_points.21
15:39:37 <dons> pumpkin_: http://www.haskell.org/haskellwiki/Pointfree#But_pointfree_has_more_points.21
15:39:38 <lambdabot> Title: Pointfree - HaskellWiki, http://tinyurl.com/2bkgub
15:39:39 <lambdabot> Title: Pointfree - HaskellWiki, http://tinyurl.com/2bkgub
15:39:42 <pumpkin_> oh my :)
15:39:44 <pumpkin_> sorry :)
15:39:57 <doublec> is there a version of hs_plugins anywhere that builds with latest ghc?
15:40:00 <pumpkin_> aha!
15:40:10 <dons> doublec: nope
15:40:18 <doublec> ok, thanks
15:40:27 <dons> use ghc-api if you're doing new thiiings
15:40:38 <doublec> so plugins is deprecated?
15:41:06 <luite_> http://hpaste.org/12306 <- why doesn't GHC know that the monad is an instance of MonadSplit?
15:45:51 <mapreduce> quicksilver: So what we were talking about wrt pickling gained an implementation.. http://github.com/rickyclarkson/binary4j/tree/master/README.markdown
15:45:53 <lambdabot> Title: README.markdown at master from rickyclarkson's binary4j  GitHub, http://tinyurl.com/5mbro2
15:46:19 <mapreduce> That title is pretty much the URL read out backwards..
15:52:14 <sm> a handy hackage release make target: http://hpaste.org/12307
15:53:20 <ddarius> > drop 5 $ let xs = relaxation ys; ys = relaxation xs in zip (map round xs) (map round ys)
15:53:21 <lambdabot>   [(-1,-1),(-1,-1),(1,1),(1,1),(1,1),(-1,-1),(-1,-1),(-1,-1),(1,1),(1,1),(1,1...
16:06:57 <RayNbow> @seen Cale
16:06:57 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 4h 9m 49s ago.
16:07:01 <Cale> hi
16:07:20 <RayNbow> hi :)
16:07:48 <gwern> speak of the devil
16:09:31 <RayNbow> Cale, do you know why getSplit from the MonadRandom package is more complicated to use than splitRandom from the hawiki?
16:09:46 <Cale> hm?
16:09:54 * RayNbow pokes luite_
16:10:00 <RayNbow> luite_, show the code :p
16:10:04 <luite_> Cale: hi, you wrote MonadRandom right? I have some problem with MonadSplit, probably using it wrong, but I really have no idea how to fix it, any idea? http://hpaste.org/12306
16:11:02 <Cale> ah, yeah, that's an issue. There should probably be a functional dependency.
16:11:15 <Cale> Another solution would be to give it a monomorphic type.
16:11:47 <luite_> ah, I was trying to keep it polymorphic
16:11:56 <luite_> but without any succes :)
16:12:00 <RayNbow> Cale: a fundep in the context?
16:12:15 <Cale> RayNbow: In the class declaration for MonadSplit
16:12:41 <RayNbow> ah
16:12:58 <Cale> oh, I suppose you could also use scoped type variables
16:13:18 * RayNbow tried fiddling with scoped type variables...
16:13:20 <Cale> Just add a  forall g m.  before the context on testR2
16:13:33 <Cale> and then  gen <- getSplit :: m g
16:14:01 <luite_> Cale: I tried that, but when I try to use testR2, it gives some other errors that I can't seem to get rid of
16:15:08 <RayNbow> the problem is that you can't "fill in" g then
16:15:21 <RayNbow> wait, lemme annotate the hpaste
16:15:51 <Cale> Oh right, that would be a problem
16:15:57 <Cale> Yeah, that's impossible to fix.
16:16:02 <luite_> oh :(
16:16:27 <luite_> guess I shouldn't have spent most of the day trying then ;)
16:16:55 <Cale> Perhaps I should add the functional dependency then.
16:17:00 <luite_> hehe
16:17:03 <nha_> Are there any low level IO bindings for haskell - i want to read into a (Ptr a)
16:17:51 <luite_> RayNbow: how's your annotation doing? :)
16:18:03 <RayNbow> http://hpaste.org/12306#a1
16:18:16 <RayNbow> ^ luite_, Cale
16:19:00 <Cale> RayNbow: I suppose that works.
16:19:08 <RayNbow> yeah, but it's ugly :p
16:21:18 <Cale> Okay, new package up.
16:21:33 <Cale> The initial code you had should now work.
16:23:19 <RayNbow> Cale: it needs a forall though
16:23:25 <luite_> Cale: thanks, great service :) yes it works
16:23:26 <Cale> It shouldn't.
16:23:30 <Cale> I just tried it.
16:23:32 <luite_> RayNbow: it doesn't need it here
16:23:35 <RayNbow> oh wait
16:23:41 <RayNbow> forgot to remove ":: g m" :p
16:23:44 <RayNbow> erm
16:23:47 <RayNbow> * :: m g
16:25:10 <RayNbow> luite_: you should annotate your paste that it works with the new package ;)
16:25:44 <RayNbow> preflex: karma Cale
16:25:44 <preflex>  karma for Cale: 26
16:25:49 <RayNbow> preflex: Cale++
16:25:51 <RayNbow> preflex: karma Cale
16:25:51 <preflex>  karma for Cale: 27
16:26:10 <luite_> RayNbow: yes, then my other hpaste (array shuffle) needs an annotation too, that also works perfectly with the new MonadRandom
16:26:15 <pumpkin_> preflex: pumpkin++
16:26:20 <pumpkin_> :(
16:26:25 <pumpkin_> preflex: pumpkin_++
16:26:28 <pumpkin_> :( :(
16:27:28 <RayNbow> pumpkin: updating karma doesn't automatically display it
16:27:34 <pumpkin> oh
16:27:42 <pumpkin> preflex: karma pumpkin
16:27:43 <preflex>  karma for pumpkin: 2
16:27:45 <pumpkin> yay
16:27:47 <pumpkin> lol
16:31:49 <pumpkin> how do people deal with large quantities of two-dimensional data in haskell? doing image processing on a large (several megapixels) image for example?
16:34:07 <gwern> arrays, I always figured
16:35:46 <pumpkin> hmm, would that be efficient?
16:36:13 <pumpkin> I wonder how many ^(.*)morphism$s I'd find if I searched
16:36:41 <pumpkin> mutumorphism? apomorphism? catamorphism? sounds like people are making stuff up :P
16:36:56 <RayNbow> hylomorphisms?
16:37:26 <pumpkin> what's a good data source to run a grep over to find an exhaustive list of *morphisms? :P
16:37:43 <RayNbow> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms <-- another example :p
16:37:45 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki, http://tinyurl.com/66ubol
16:38:03 <pumpkin> oh god
16:38:05 <Giraffe> ahahahaha
16:38:32 <Giraffe> Used when you really need both semi-mutual recursion and history and to repeatedly apply a natural transformation as you get deeper into the functor.
16:38:45 <RayNbow> pumpkin: http://comonad.com/reader/ had an overview, but he lost a few posts
16:38:54 <lambdabot> Title: The Comonad.Reader
16:39:24 <Giraffe> pumpkin, image processing can actually be done with just one array (really!)
16:39:53 <Giraffe> i'm not sure how the data of the image itself is stored, but it would ideally be in one large chunk in memory
16:39:59 <pumpkin> Giraffe: you mean with the (y * width) + x thing?
16:40:08 <Giraffe> pumpkin, yes
16:40:20 <luite_> pumpkin: or you can use some 2d type (like tuples) as an index
16:40:22 <pumpkin> yeah, it just didn't "feel functional" to do that
16:40:40 <pumpkin> hmm
16:41:06 <Giraffe> well i mean on a low level that's what's going to be happening anyway
16:41:13 <pumpkin> yeah
16:41:20 <Giraffe> sometimes the most functional a problem can feel is not very functional
16:41:52 <Giraffe> take database work for example--i'm working on an app to process ebook data in a sqlite database--HDBC does everything in the IO monad (and rightly so), which means almost everything is in do blocks
16:42:05 <pumpkin> ah :/
16:42:10 <pumpkin> damn IO
16:42:15 <pumpkin> :P
16:42:27 <Giraffe> well hey, it's not like it can't be functional
16:42:36 <pumpkin> yeah :)
16:42:44 <Cale> I think queries could be composed outside of IO rather effectively, and the results processed outside IO.
16:42:45 <Giraffe> it's just that as it stands for the current state of the project it doesn't go much deeper than grabbing data and outputting it in some form or another
16:42:53 <Giraffe> Cale, they are
16:57:25 <thoughtpolice> Lemmih: ping
16:58:59 <Lemmih> thoughtpolice: 'Ello.
16:59:21 <Lemmih> thoughtpolice: The project is up on http://code.haskell.org/lhc/.
16:59:22 <lambdabot> Title: Index of /lhc
17:00:41 <thoughtpolice> Lemmih: yay
17:01:00 <thoughtpolice> Lemmih: I have a pretty substantial patch that uh, changes just about every reference to 'jhc' in the compiler to 'lhc' (inside src, that is)
17:01:32 <thoughtpolice> Lemmih: also did you see my notes on the profiling results?
17:02:32 <Lemmih> Good work, komrad. We've always been at war with Oceania and we've always been lhc!
17:02:39 <thoughtpolice> :]
17:02:48 <thoughtpolice> Lemmih: do not thank me, thank find+sed :P
17:03:10 <thoughtpolice> Lemmih: I'll record and push it to c.h.o then?
17:03:26 <Lemmih> Yes, I saw. Reading the compiled libraries is quite expensive.
17:03:36 <Lemmih> thoughtpolice: Go for it.
17:04:28 <Lemmih> thoughtpolice: I suspect there's quite a lot of duplicate information in the .hl files.
17:05:33 <gwern> thoughtpolice: you know, it probably would've been better to do 'darcs replace jhc lhc `find .`'
17:06:06 <thoughtpolice> gwern: these magical powers were unknown to me :[
17:06:09 <gwern> I understand from the darcs guys that mass-replace-patches commute better when you use the replace command than a textual mass-rename
17:06:22 <gwern> thoughtpolice: yes, I only recently learned how to use replace meself
17:08:59 <Igloo> So how does lhc differ to jhc?
17:09:08 <gwern> cabalized
17:09:20 <Lemmih> Igloo: It is cabalized and it works with ghc-6.10.
17:09:34 <Igloo> Wouldn't John accept patches for that?
17:09:38 <Lemmih> (It is also slightly faster)
17:10:02 <gwern> Igloo: didn't you read john's emails to darcs-*?
17:10:07 <thoughtpolice> Lemmih: also I pushed the profiling lib patch, I tried with 'cabal install -p' but it didn't seem to make a profiling build :/
17:10:24 <Lemmih> thoughtpolice: The flag is --enable-executable-profiling.
17:10:39 <thoughtpolice> Lemmih: I tried building with 'cabal install -p' earlier and it didn't make a profiled build
17:11:04 <Lemmih> -p only works for libraries.
17:11:13 <Igloo> gwern: Recently?
17:11:14 <hackage> Uploaded to hackage: MonadRandom 0.1.3
17:11:22 <thoughtpolice> Lemmih: ah ok
17:11:46 <thoughtpolice> Lemmih: then I'll make a patch and take it out
17:11:48 <gwern> Igloo: back when I was advocating cabalization of darcs
17:11:54 <luite_> hackage bot is slow ;)
17:12:05 <Igloo> OK, I know he's against it generally
17:13:10 <thoughtpolice> Lemmih: done
17:13:13 <thoughtpolice> (and pushed)
17:16:36 <Lemmih> thoughtpolice: I hope it still works. The internals are fairly fragile. (:
17:19:37 <Lemmih> thoughtpolice: Where did lib/base/Jhc/*.hs go?
17:19:40 <thoughtpolice> Lemmih: oi, already seems something has broke  - the Jhc dir in lib/base has disappeared
17:19:56 <thoughtpolice> Lemmih: not sure, I built lhc-base earlier before I recorded my changes >:[
17:20:04 <thoughtpolice> Lemmih: I'll fix it right fast and push
17:22:57 <shapr> hiya CiScOh4x0r, learning Haskell?
17:23:05 <CiScOh4x0r> Yes
17:23:10 <shapr> Got any questions?
17:23:41 <shapr> @users
17:23:42 <lambdabot> Maximum users seen in #haskell: 558, currently: 508 (91.0%), active: 13 (2.6%)
17:24:05 <shapr> I guess not.
17:25:47 <insane> how do i convert Int to Integer
17:25:52 <insane> ?
17:25:57 <thoughtpolice> Lemmih: changes pushed, I just pulled everything, built lhc, built lhc-base and then ran a test and it worked fine
17:26:01 <Lemmih> insane: fromIntegral.
17:26:43 <insane> Lemmih: thanks
17:26:50 <thoughtpolice> Lemmih: wait
17:27:59 <Lemmih> thoughtpolice: Third time's the charm (:
17:28:45 <thoughtpolice> Lemmih: HOKAY, now it should be fine
17:29:55 <thoughtpolice> Lemmih: if you would darcs pull and try to build lhc & lhc-base it would be appreciated so I can be sure I've left the darcs repository in a proper fashion :]
17:30:53 <thoughtpolice> Lemmih: but AFAICS my huge patch changing all jhc -> lhc shouldn't have broke anything, since I replaced all occurrences simultaniously throughout the whole source (ditto for jhc, Jhc and JHC)
17:31:00 <thoughtpolice> Lemmih: but you never know
17:32:24 <Lemmih> thoughtpolice: It seems to work.
17:32:39 <thoughtpolice> Lemmih: yay
17:33:28 <thoughtpolice> Lemmih: also on the Notes I agree StringableAtom should be gone
17:33:38 <thoughtpolice> as well as most of the old build system stuff
17:34:25 <thoughtpolice> Lemmih: I'll look into replacing some of that cruft.
17:34:51 <thoughtpolice> Lemmih: oh, look at that :] http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stringtable-atom
17:34:57 <lambdabot> Title: HackageDB: stringtable-atom-0.0.6, http://tinyurl.com/6anvf6
17:50:31 <Giraffe> uh oh
17:50:52 <Giraffe> i think i'm turning into some kind of pointfree fanatic
17:53:48 <dons> Giraffe: its a phase
17:53:56 <Lemmih> thoughtpolice: In the end we should replace it with something safer. The threat of segfaults just isn't worth the speed-up.
17:54:00 <Giraffe> dons, well fanatic may be a strong word
17:54:06 <thoughtpolice> Lemmih: yeah
17:54:07 <Giraffe> but i'm liking it
17:54:19 <thoughtpolice> Lemmih: but right now I actually have replaced it with stringtable-atom from hackage
17:54:24 <Giraffe> also i'm finally at the stage in my project where i'm doing things purely functionally again
17:54:26 <thoughtpolice> Lemmih: would you like me to push the patch anyway?
17:54:27 <Giraffe> and it's a HUGE relief
17:54:48 <Lemmih> thoughtpolice: Oh yes, absolutely.
17:55:22 <Lemmih> thoughtpolice: Making it go away completely is fairly difficult and it can wait.
17:55:48 <gwern> Lemmih: lhc darcs doesnae compile for me
17:55:53 <gwern>  setup: can't find source for Doc.DocLike in src, dist/build/autogen
17:55:54 <thoughtpolice> Lemmih: push'd
17:56:04 <Lemmih> gwern: Right, you need to pull Doc.
17:56:08 <thoughtpolice> gwern: cd lhc/src; darcs get http://repetae.net/repos/Doc
17:56:09 <lambdabot> Title: Index of /repos/Doc
17:56:18 <thoughtpolice> gwern: I'm looking into replacing Doc with something off hackage
17:56:24 <thoughtpolice> gwern: to make it much easier to install
17:56:36 * gwern grumbles. either add that to instructions, or add the doc files to the lhc repo
17:56:51 <thoughtpolice> gwern: well its on the front page - http://lhc.seize.it/
17:56:53 <lambdabot> Title: Wiki - Front Page
17:57:01 <thoughtpolice> gwern: but hopefully Doc will be out of the picture soon
17:57:02 <gwern> thoughtpolice: I was going by #haskell!
17:57:10 <thoughtpolice> ;]
17:57:14 <gwern> Lemmih: also, I note setup.hs uses drift - you know I don't really maintain the cabalization of that right
17:57:58 <Lemmih> gwern: Hopefully we won't use it for long.
17:58:25 <thoughtpolice> Lemmih: okay so stringtable-atom is out of the picture now
17:58:36 <thoughtpolice> Lemmih: I'll look into removing a bunch of a cruft later tonight
17:58:38 * gwern grimaces at all the warnings
17:58:40 <thoughtpolice> Lemmih: hacking lhc = fun :]
17:58:54 <thoughtpolice> gwern: killing warnings is a future goal of mine
17:59:30 <gwern> are the warnings there because of deep reasons, or are they jsut from sloppy coding?
18:00:01 <Lemmih> There's no deep reason for them.
18:00:01 <gwern> hm. is lhc self-compiling?
18:00:18 <Lemmih> gwern: No. Far from it, I'm afraid.
18:00:34 <gwern> ah. so there's no problem in using GHC stuff like LANGUAGE?
18:00:59 <Lemmih> Nope.
18:01:07 <gwern> Lemmih: btw, when you have time it would be good to set a darcs-send default email address
18:01:26 <plogYy> i want to learn programming, i was recommended to start with haskell, is it a base knowledge for programming or it requires a prior reading?
18:02:06 <Lemmih> gwern: How do I do that?
18:02:12 <gwern> plogYy: I can promise you if you learn haskell you will have a deep understanding of many parts of programming. I started with haskell and I don't regret it
18:02:32 <gwern> @where real
18:02:32 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
18:02:34 <gwern> @where wiki
18:02:34 <lambdabot> I know nothing about wiki.
18:02:39 <gwern> hm.
18:03:01 <Lemmih> Haha, nice comment.
18:03:04 <gwern> hm.
18:03:16 <gwern> @where+ wikibook http://en.wikibooks.org/wiki/Haskell
18:03:17 <lambdabot> Nice!
18:03:35 <plogYy> gwern: will it teach me programming concepts and terms as well? like what is expressions, arguments, etc?
18:03:44 <gwern> plogYy: between the haskell wikibook and Real World haskell, and #haskell, is all the documentation on learning haskell you could want
18:03:47 <gwern> plogYy: yes
18:04:09 <plogYy> gwern: so i have nothing to study before it?
18:04:17 <gwern> Lemmih: how did you convince hackage to take lhc? cabal check claims the -fhpc option would cause it to be rejected
18:04:42 <gwern> plogYy: you can dive in pretty much, although certainly it would be good if you've at least learned middle-school level algebra
18:06:06 <Lemmih> gwern: The version on hackage predates the -fhpc flag.
18:06:36 <gwern> Lemmih: iirc, what you would do is ssh to community, cd to your lhc repo, and then do... I forget exactly
18:06:40 <plogYy> i don't want to spend much time in mathematics, is it a must? or I can find an online quick algebra needed by haskell?
18:06:40 * gwern goes to look it up
18:07:35 <gwern> http://darcs.net/manual/node5.html#SECTION00510000000000000000
18:07:36 <lambdabot> Title: Configuring darcs
18:07:37 <chessguy> is Henning Thielemann a #haskell native?
18:08:13 <gwern> plogYy: no, it's just you should understand what a function is, understand basic math (so you understand why an Int is not a Rational) and so on
18:08:41 <gwern> Lemmih: 'The _darcs/prefs/email file is used to provide the e-mail address for your repository that others will use when they darcs send a patch back to you. The contents of the file should simply be an e-mail address. '
18:09:09 <gwern> unfortunately, it seems you can't 'darcs setpref' it
18:09:33 <Lemmih> gwern: Done, thank you.
18:10:36 <plogYy> gwern: i see, can you give me a link that covers those basics generally without digging deep, because when I tried studying mathematics as a base for programming, it seems i lost my way and got really lost
18:11:11 <gwern> plogYy: iirc from when I was editing the wikibook, the haskell wikibook's introductory chapters summarize the basic math
18:11:29 <gwern> plogYy: but why not just start and see how it goes? maybe you understand the math as well as you need to
18:11:51 <plogYy> i hope so, you are encouraging
18:12:01 <plogYy> where can i download the wikibook from?
18:12:28 <gwern> plogYy: ^^ I linked it earlier
18:12:32 <gwern> @where wikibook
18:12:32 <lambdabot> http://en.wikibooks.org/wiki/Haskell
18:12:57 <plogYy> oh, sorry, it seems i missed it within the lines
18:12:58 <gwern> iirc, the wikibook project has a feature where you can get an entire wikibook as a downloadable PDF, but I don't know any more about that
18:14:18 <plogYy> do you suggest starting with the wikibook or the real world haskell?
18:14:51 <dons> i'd imagine the wikibook would completement some of the higher end theory that rwh leaves out
18:14:53 <gwern> I have no idea. I've only looked through a part of rwh; why not try reading through concurrently, or maybe alternating chapters?
18:15:02 <dons> the wikibook assumes more, imo.
18:15:29 <gwern> dons: does it? doesn't the wikibook start off with simple math functions like multuplcation and go from there?
18:18:31 <dons> well, it wanders down some category theoretic tracks
18:18:47 <dons> they have different emphasis, certainly.
18:19:41 <plogYy> gwern: i will start from there then
18:19:56 <gwern> dons: I always figured those weirdo chapters on denotational semantics and the zipper were just a haskeller who didn't have a blog handy
18:19:56 <plogYy> gwern: are studying haskell long time ago?
18:20:16 <gwern> plogYy: well, I don't so much study haskell these days as use it
18:21:12 <gwern> (and I never really sat down and learned haskell, per se, as much as I sat down and coded and stuff and banged my head a lot and chatted and read a lot in #haskell)
18:21:52 <gwern> ^^ that's why I still don't understand monads :)
18:21:59 <chessguy> so nobody knows if Henning Thielemann is on #haskell?
18:22:12 <dons> don't htink so
18:22:36 <gwern> can't remember ever seeing him, fwiw
18:23:26 <plogYy> gwern: why did you learn it? did you switch to another programming language after learning it?
18:24:35 <gwern> plogYy: I was seduced by dons' propaganda. I wanted to learn the highest-level language around, and haskell looked like it. also: I thought the syntax was beautiful and lazy evaluation sounded fascainting
18:25:18 <chessguy> what do you mean by "highest level"?
18:25:52 <gwern> chessguy: I wanted to be as far away from the machine as possible - haskell did not only gc, but I didn't even have to specify evaluation order
18:26:59 <gwern> chessguy: is that a satisfactory explanation of what I meant back then by highest level?
18:27:01 <plogYy> i was about to study C as an introduction to programming, but many people said that this is totally wrong, haskell is the best way to learn, even they teach it to their children, this sounded interesting
18:27:40 <chessguy> sure. i doubt haskell is the highest-level language by that definition, though
18:28:10 <gwern> chessguy: hm. you think a logic language would be even more high-level in that respect?
18:28:35 <roconnor> @type \f -> (liftM join) (liftM f)
18:28:36 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
18:28:48 <roconnor> @pl  \f -> (liftM join) (liftM f)
18:28:48 <lambdabot> fmap join . fmap
18:29:16 <roconnor> @type (liftM (liftM join)) liftM
18:29:17 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
18:29:30 <chessguy> probably some kind of constraint-based or 5GL
18:29:33 <roconnor> @type (join liftM join) liftM
18:29:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
18:29:34 <lambdabot>       Expected type: m (m a) -> m (m a)
18:29:34 <lambdabot>       Inferred type: m (m a) -> m a
18:29:48 <roconnor> ah oops
18:30:00 <roconnor> @type (liftM liftM liftM join) liftM
18:30:02 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
18:30:15 <plogYy> how much it takes to learn haskell? what step should be taken further?
18:30:42 <roconnor> @let (=<<) =  (liftM liftM liftM join) liftM
18:30:42 <lambdabot>  <local>:5:28:
18:30:43 <lambdabot>      Ambiguous type variable `m' in the constraint:
18:30:43 <lambdabot>        `Mo...
18:31:22 <roconnor> @type (join liftM liftM join) liftM
18:31:23 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = m a1
18:31:24 <lambdabot>       Expected type: (a1 -> r) -> a1 -> r
18:31:24 <lambdabot>       Inferred type: (a1 -> r) -> m a1 -> m r
18:31:42 <roconnor> polymorphism
18:32:22 <gwern> plogYy: what do you mean?
18:33:34 <plogYy> gwern: i mean what's the purpose for learning haskell? as an introduction to start learning any programming language after that? or it can be used itself for producing usefull applications?
18:34:05 <gwern> plogYy: oh, it's plenty useful in itself, *and* it's a great education in programming
18:34:10 <plogYy> for sure, it can't be used individually as a programming language to produce sophisticated progrms
18:34:27 <p_l> plogYy: Could you elaborate why?
18:34:35 <gwern> plogYy: indeed? we keep a number of sophisticated programs on http://hackage.haskell.org/packages/archive/pkg-list.html
18:34:36 <lambdabot> Title: HackageDB: packages by category
18:34:49 <plogYy> how much should be spend in it before jumping to staring learning another language, ex Java?
18:35:08 <p_l> gwern: argh, my troll bait failed ;-)
18:35:51 <plogYy> p_l: i guess because it would take much time to do so using functional programming
18:35:58 <gwern> plogYy: I'd say if you aren't productive in 6 months (assuming you are actually trying) then maybe you should try another language. programming paradigms are like that - some people just can't learn functional languages, just like some can't handle imperative and so on
18:36:08 <p_l> plogYy: In my case, I don't learn Java. On purpose. And I still rock my Java assignments (the only place that forces me to write Java is my uni)
18:36:45 <p_l> plogYy: Also, it's rare to find a program that cannot be expressed well in functional style. Most of the time I had seen opposite results to what you described
18:36:53 <plogYy> p_l: what do you use for programming then?
18:36:55 <p_l> Even if FP was not used all the time
18:37:02 <p_l> plogYy: Depends what I'm going to write
18:37:28 <plogYy> p_l: an application with GUI for example
18:37:28 <gwern> p_l: why not provide plogYy some examples you've done?
18:37:50 <p_l> gwern: Most of the stuff is abandoned and/or destroyed
18:37:53 <plogYy> gwern: how would you describe the word productive? how can I measure it?
18:38:11 * p_l never cared enough to build a portfolio
18:38:20 * dons doesn't know what this conversation is about.
18:38:31 <dons> plogYy: you're wondering if we write useful things in haskell?
18:38:32 <dons> ?users
18:38:33 <lambdabot> Maximum users seen in #haskell: 558, currently: 495 (88.7%), active: 14 (2.8%)
18:38:36 <plogYy> p_l: you did all of you work with haskell functional prog.?
18:38:44 <dons> or whether 500 people sit here twiddling thumbs?
18:39:08 <p_l> plogYy: Not yet - I however want to learn it, though I don't have much time right now (I'm broke)
18:39:19 <gwern> plogYy: examples of programming I've done recently: I wrote a haskell script to generate questions for flash card software, so I could have input like 'David Hume died in %1776%', and my script would generate a bunch of questions like 'Question: David Hume died in ___6\nAnswer: 1776'; this script generates all possible questions, which is a lot for longer numbers
18:39:54 <gwern> I have 2 other scripts which are variants of that
18:40:08 <plogYy> dons: i am wondering because whenever i read an article, it praises the OOP, and the shipped packages and classes with OO languages, claiming that big applications would have taken long time if programmed without OO and ready-made classes
18:40:09 <gwern> (they're very useful for me, and very short and reliable)
18:40:14 <p_l> plogYy: I'll quote a lisp hacker - for a good programmer, the time spent on thinking about the solution is usually constant. The time required to code the solution later depends often on the language
18:40:30 <dons> plogYy: there are other abstractions besides objects
18:40:39 <dons> and it is abstraction that lets you build big software
18:40:40 <p_l> plogYy: Also, most OOP languages are contradictory
18:41:01 <dons> anyway, to get a sense of what people are doing in haskell, check the packages list, http://hackage.haskell.org/packages/archive/pkg-list.html
18:41:06 <lambdabot> Title: HackageDB: packages by category
18:41:16 <p_l> what had grown around Java is a good example of OOP gone wrong
18:41:19 <gwern> plogYy: another script of mine searchs wikipedia for http:// links and uses webcite.org to back them up; this script is about 7 lines and very performant. I have no idea how anyone could hope to do something similar in C or Java
18:41:40 <dons> gwern: using the mediawiki bindings yet?
18:42:03 <gwern> dons: alas, no. my free time keeps getting sucked up by darcs and wikipedia related stuff
18:42:18 <plogYy> p_l: what happened around Java?
18:42:35 <gwern> plogYy: I do a lot more than just these scripts, it's just that I know you won't be impressed if I recount all the cabalization and bugs and questions and stuff I do :)
18:43:05 <gwern> plogYy: or take xmonad or darcs - both are powerful apps which are really good at what they do and which many non-haskellers seek out and use
18:43:08 <p_l> plogYy: Have you ever seen how much stuff you need to write to build a simple thing with all those "Enterprise" libs
18:43:10 <plogYy> gwern: sounds interesting, so you write web scripts in haskell as well? just wondering how they run on HTTP servers?
18:43:11 <p_l> ?
18:43:22 <p_l> plogYy: Like all apps :)
18:43:39 <gwern> plogYy: these are more clients - as in I run the script on my home computer to do stuff
18:43:55 <dons> plogYy: for server side, we use happs or fastcgi/hdbc/json etc
18:44:52 <plogYy> this is like PHP for example that run PHP scripts?
18:45:03 <plogYy> gwern, what are xmonad or darcs?
18:45:19 <p_l> plogYy: PHP is a *very* bad example when it comes to development
18:45:23 <dons> plogYy: popular open source desktop applications for linux.
18:45:42 <gwern> plogYy:  https://secure.wikimedia.org/wikipedia/en/wiki/Darcs  https://secure.wikimedia.org/wikipedia/en/wiki/Xmonad
18:45:55 <p_l> plogYy: darcs - distributed version control system; XMonad - a very *good* tiling window manager for X11
18:46:56 <p_l> though XMonad arguably could be called a library or "framework" for implementing your own WM :)
18:47:08 <plogYy> <p_l> plogYy: PHP is a *very* bad example when it comes to development >>> why, what do you prefer?
18:47:56 <plogYy> <p_l> plogYy: Have you ever seen how much stuff you need to write to build a simple thing with all those "Enterprise" libs >>> that's what i mean, see how libs saved time? isn't it a good thing?
18:48:22 <plogYy> gwern: those apps looks interesting!
18:49:02 <plogYy> gwern: do you think haskell gonna be more popular? why it's not beating the rest till now?
18:49:22 <p_l> plogYy: saved... time? I can't understand how making human to act as the toolset or requiring *big* IDEs is a sign of saving time
18:49:36 <dons> plogYy: beating the rest?
18:49:40 <dons> ?users
18:49:40 <lambdabot> Maximum users seen in #haskell: 558, currently: 494 (88.5%), active: 13 (2.6%)
18:49:56 <shapr> Hm, #haskell the channel seems pretty large to me.
18:50:02 <plogYy> dons: PHP or other languages
18:50:10 <dons> which ones?
18:50:17 <dons> some will always be huge. some will be small.
18:50:18 <p_l> plogYy: until EJB3 came, "Enterprise" meant writing tons of idiotic XML configs. It still requires lots of that stuff
18:50:23 <gwern> plogYy: well, one reason is infrastructure. the haskell community has in the last 2 or 3 years made an effort to develop tools - cabal for easy packaging and distribution, hackage for a centralized location to go and get libraries, a widespread effort to bring togehter all the scattered libraries, etc.
18:50:27 <dons> haskell has been growing for the last 5 years, and that doesn't seem to be slowing.
18:50:36 <dons> maybe its already popular compared to similar languages.
18:50:37 <roconnor> @type return . join
18:50:38 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m1, Monad m) => m1 (m1 a) -> m (m1 a)
18:50:50 <shapr> plogYy: How do you measure popular?
18:50:53 <dons> plogYy: i mean, you're here.
18:50:55 <dons> so it must be popular
18:50:58 <shapr> good point!
18:51:07 <dons> you weren't here before. so its growing!
18:51:10 <gwern> plogYy: another reason is that not only have we gotten new things like cabal, cabal-install, and hackage, but also the GHC compiler has gotten much better and much more competitive
18:51:11 <shapr> yay!
18:51:29 <shapr> I'd like to point out that ByteString solved a *lot* of complaints as well.
18:51:31 <p_l> plogYy: Also... don't try writing applications for financial institutions in Java. Especially the analytic stuff :)
18:51:42 <plogYy> dons :) right
18:51:48 <dons> plogYy: time to write some haskell programs now
18:51:51 <Raevel> #36! http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
18:51:54 <shapr> Yay Haskell!
18:51:59 <lambdabot> Title: TIOBE Software: The Coding Standards Company
18:52:08 <dons> Lemmih: exciting. lhc auto packaging is building.
18:52:18 <Lemmih> dons: auto packaging?
18:52:30 <gwern> plogYy: I mean, in the late 90s, say, every library and app basically had its own way of packaging, installing, and so on - when they weren't gratuitiously unportable, and even once you got everything compiled, the authors probably have never heard of each other and couldn't care less if their stuff worked together. if they did, ghc didn't produce all that great binaries
18:52:54 <dons> Lemmih: native packaging for lhc for arch
18:52:55 <shapr> Then there was that fateful meeting where SyntaxNinja came up with cabal.
18:53:00 <plogYy> dons: what made me here is what i heard about haskell as being a great programming learning language, and should be learned first instead of C, i was like ! instead of C?? i have to check this language
18:53:03 <dons> shapr: yeah, changed the game.
18:53:05 <gwern> shapr: quite.
18:53:08 <shapr> I was there, purely in the role of cheerleader.
18:53:17 <shapr> I look great with pom-poms.
18:53:20 <gwern> history in the making! I hope you took photos
18:53:20 <dons> that's true.
18:53:23 <dons> and cats.
18:53:29 <dons> and UNICYCLES!!
18:53:30 <shapr> Right, cats.
18:53:31 <p_l> plogYy: I'd rather say that you should learn both of them
18:53:33 <shapr> YES!
18:53:37 * dons boings
18:53:40 <shapr> dons: By the way, what hat?
18:53:52 <dons> hat?!
18:53:59 <dons> i need an interrobang key
18:54:00 <shapr> <dons> i like how shapr's hat fits
18:54:07 <luite_> by the way, is anyone going to fix the lambdabot package? ;)
18:54:16 <dons> oh. that was me wearing shapr's cheerleader hat, iirc
18:54:18 <gwern> luite_: the hackage one you mean?
18:54:19 <dons> :D
18:54:20 <shapr> oh right!
18:54:22 <shapr> of course!
18:54:28 <luite_> gwern: yes, the eval plugin doesn't compile
18:54:33 <dons> Lemmih++ awesome work with the lhc package
18:54:42 <dons> we'll be able to ship binary packages now
18:54:55 <shapr> plogYy: Lots of nifty and interesting things happening here on #haskell, join in, it's fun!
18:54:57 <p_l> plogYy: So that you learn from near-assembly side (C was designed to be portable assembler), and from High Level Language side (Haskell, Lisp, maybe Erlang?)
18:54:57 <gwern> luite_: hm, details - ghc, too
18:54:59 <shapr> Oh cool!
18:55:16 <p_l> plogYy: Anyway, a language that doesn't change the way you think is not worth learning
18:55:20 <shapr> truly
18:55:24 <dons> Lemmih: http://aur.archlinux.org/packages.php?ID=21749
18:55:25 <lambdabot> Title: AUR (en) - lhc
18:56:02 <Elly> people who use arch: how is it?
18:56:03 <luite_> gwern: on 6.10.1, seems something has changed in the haskell-src-exts package
18:56:06 <gwern> hm, why does cabal install on lambdabot dir want 'packedstring'? what the heck is packedstring?
18:56:11 <dons> Elly: it has 725 haskell packages
18:56:23 <dons> so *FREAKINGLY* *AWESOME*
18:56:26 <Elly> dons: hah :P
18:56:30 <gwern> luite_: oh, that. yeah, hs-src-exts made some changes I remember reading the ann shoiuldn't be too hard to fix? maybe I guess
18:56:39 <plogYy> p_l: i always fear dealing with abstract thinking whenever it comes to learning programming :) i have to overcome this i guess
18:56:43 <p_l> For me, haskell is important to learn from the point of pure FP. Lisp, from the side of being the most multi-paradigm as you can get, Erlang - massive distributed concurrency, as well as ROCK SOLID, etc. etc)
18:57:02 <gwern> ok, what the heck, packedstrings should not be a dep - it's way outdated
18:57:06 <gwern> as I thought
18:57:14 <luite_> gwern: probably not, it's just that I'm to lazy, I mean busy, to make a patch ;)
18:57:20 <heatsink> plogYy: What is there to programming besides abstract thinking?
18:57:46 <dons> p_l: written any rock solid erlang programs yet?
18:57:47 <p_l> plogYy: After you master enough from various languages and abstract side of programming, you'll be capable of writing anything in anything
18:57:50 <gwern> (typing it in)
18:58:04 <ddarius> Why learn "near-assembly"?
18:58:08 <plogYy> heatsink: nothing, i know
18:58:20 <p_l> dons: Not yet - but I like the assumption of "If it can fail, it fails. Prepare for that"
18:58:34 <dons> i think more people talk about writing rock solid erlang than actually do so, fwiw.
18:58:38 <plogYy> p_l: can haskell work with databases like MySQL or Oracle?
18:58:39 <p_l> ddarius: To understand how the machine works? That's important too
18:58:41 <dons> plogYy: yeah.
18:58:46 <gwern> 'template-haskell-2.3.0.0 depends on packedstring-0.1.0.1 which failed to
18:58:47 <p_l> plogYy: I had seen libs for that
18:58:48 <gwern> hm
18:58:53 <dons> plogYy: check hackage.haskell.org for an idea of the ~1k libraries to choose from
18:59:03 <ddarius> p_l: Let me clarify the emphasis, why learn "*near*-assembly"?
18:59:05 <dons> free signed copy of RWH for the 1000th package upload?
18:59:10 <gwern> interesting, I didn't know template-haskell was a package
18:59:13 <shapr> ooh
18:59:14 <Nafai> dons: oooo
18:59:17 <gwern> why is that I suppose
18:59:17 <dons> mmm....
18:59:22 <dons> i think i could arrange that, actually
18:59:30 <dons> time is right!
18:59:33 <Nafai> What number are we at?
18:59:33 <shapr> dons: Hey, I'd like to actually meet you at some point, think you'll be in the northeast at any point?
18:59:34 <p_l> ddarius: Well, I have nothing against actual assembly. Many people would have ;-)
18:59:37 <plogYy> dons: amazing! i can't imagine that haskell can do all the work, i thought i would just learn it to build a programming knowledge
18:59:41 <dons> shapr: i'll be in nyc next week
18:59:47 <fnord123> when will gtk2hs be a package?
18:59:47 <shapr> oh!
18:59:51 <shapr> hmm
18:59:55 <dons> probably for an nyfp meeting.
19:00:00 <gwern> fnord123: in another couple of cabal versions
19:00:02 * p_l has to finally get out of financial pinch and get back to writing
19:00:04 <dons> and in the DC area some time around then.
19:00:12 <dons> shapr: i'm on the east coast about once every 2 months currently
19:00:13 <fnord123> super duper
19:00:27 <shapr> Spiffy, ever in the Boston area? or purely nyc?
19:00:29 <dons> shapr: you're in boston right?
19:00:31 <shapr> Yup
19:00:37 <dons> i could make the trek on my next trip to DC.
19:00:44 <dons> come up and say hi
19:00:48 <shapr> That would be awesome!
19:00:53 <dons> yeah, sounds like a plan.
19:01:02 <shapr> NYC is closer than DC, btw.
19:01:02 <plogYy> haskell channel looks big as well :) it seems i was too wrong about the word popular
19:01:12 <gwern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/template-haskell <-- ok that's messed up, th is up to date it seems but it still wants 'packedstring'????
19:01:14 <lambdabot> Title: HackageDB: template-haskell-2.3.0.0, http://tinyurl.com/6aoczl
19:01:23 <dons> gwern: correct.
19:01:33 * gwern thinks that is off the hook
19:01:42 <dons> no no. there's a good reason.
19:01:46 <dons> see if you can work it out :)
19:01:54 <luite_> plogYy: the ration of irc users to language users is higher for haskell than for most 'popular' languages though :)
19:02:02 <gwern> I guess I'll have to as cabal-install can't install packedstring
19:02:06 <p_l> plogYy: Popular doesn't mean good. And if you really want to see something popular, go for COBOL.
19:02:11 <shapr> haha
19:02:21 <p_l> plogYy: But don't come back crying at what you saw
19:02:24 <dons> luite_: right. we're organised.
19:02:34 <dons> esp. compared to our FP cousins.
19:02:36 <ddarius> luite_: How do you know?
19:02:37 <luite_> yeah this channel is really great :)
19:02:39 <plogYy> lol
19:02:46 <dons> still yes, how do you know ? :)
19:03:06 <luite_> hehe, by 'popular' I meant Java
19:03:07 <Raevel> plogYy: the popularity of a language has very little to do with how good it is
19:03:33 <SyntaxNinja> shapr is the best cheerleader!
19:03:33 <ddarius> luite_: Well, I'll give you that without proof.
19:03:40 * shapr cheers
19:03:42 <plogYy> i like the way people interact here too, seems like all are motivated, and this is encouraging
19:03:51 * ddarius wants to see shapr do a handspring.
19:03:54 <p_l> dons: GHC surely helps in keeping it organised. At least when I compare Haskell to CL
19:04:02 <shapr> ddarius: I can actually.
19:04:11 <plogYy> Raevel: i totally agree
19:04:14 <p_l> (from the community pov, not language itself)
19:04:22 <ddarius> shapr: That's good, otherwise I'd have to wait much longer.
19:04:23 <dons> Lemmih: now all of Arch knows, http://archhaskell.wordpress.com/2008/11/24/lhc-lemmihs-haskell-compiler/
19:04:23 <Raevel> plogYy: heh, odds of an intelligent discussion in ##php are slim
19:04:25 <lambdabot> Title: LHC: Lemmihs Haskell Compiler  Arch Linux and Haskell, http://tinyurl.com/5m589a
19:04:26 <shapr> heh
19:04:31 <shapr> ooh
19:04:31 <dons> SyntaxNinja: yo.
19:04:57 <shapr> Lemmih: Boehm or regions?
19:05:07 <gwern> dons: I still dunno, why does TH use packedstring and not bytestring?
19:05:17 <dons> gwern: Word8 vs Char
19:05:21 <ddarius> TH uses packedstring?
19:05:32 <gwern> ddarius: yes, it's causing me problems >.<
19:05:35 <SyntaxNinja> hiya dons
19:05:45 <dolio> TH is old.
19:05:47 <ddarius> What does it use it for?
19:05:57 <Lemmih> shapr: Thanks, but I don't drink.
19:06:03 * SyntaxNinja realized something important about dons' cultural heritage yesterday 
19:06:07 <ddarius> dolio: I was here before TH was first implemented.
19:06:12 <dons> SyntaxNinja: oh dear.
19:06:25 <dons> SyntaxNinja: i got an email from AAM wondering who'd seen the incriminating evidence
19:06:29 <gwern> ddarius: if I am understanding dons right, he's saying bytestring doesn't support full UTF8 but packedstring does, and I guess you need UTF8 to support the full range of AST s possible
19:06:34 <shapr> Lemmih: Hah, I was asking what sort of GC LHC does. JHC was going to use regions, since GRIN pretty much requires them, but Boehm was going to be implemented prior to that.
19:06:35 <SyntaxNinja> watch out for dons!! he's Australian !
19:06:35 <Lemmih> shapr: Boehm, I think. At least for the C backend. There's also an unused ghc backend.
19:06:49 <SyntaxNinja> for background, see chopper
19:06:53 <dons> hehe
19:06:58 <kfish> bloody hell
19:07:00 <shapr> chopper?
19:07:04 <plogYy> is python a functional language?
19:07:07 <dons> kfish!
19:07:07 <dolio> ddarius: And the majority of work on TH was probably done before byte strings was implemented.
19:07:11 <kfish> dons!
19:07:20 <ddarius> dolio: Of course it was.
19:07:22 <dolio> Were, even. And no one has bothered to change it.
19:07:23 <shapr> plogYy: It has some functional bits.
19:07:27 <dons> kfish <-- convict brethren
19:07:28 <p_l> plogYy: AFAIK no, though it allows for some fp bits
19:07:33 <Raevel> plogYy: nope, though it has taken som inspiration from it
19:07:33 <luite_> plogYy: it does have a few basic functional constructs, but most people wouldn't call it functional
19:07:34 <shapr> plogYy: But I don't consider it particularly functional.
19:07:46 <gwern> dons: did I interpret your bytestring/TH comment aright?
19:07:54 <dons> gwern: yeah
19:07:57 <ddarius> dolio: I actually made a small hack to GHC for the first cut of TH.
19:08:03 <dons> gwern: there might even be a ticket for it.
19:08:10 <Raevel> 4 identical responses, hooray for us
19:08:23 <dons> ?quote stereo
19:08:24 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
19:08:24 <ddarius> The correct answer is: Ask Guido.
19:08:25 <plogYy> what about perl? how similar or different is it from haskell?
19:08:33 <dons> plogYy: oh boy.
19:08:36 <dons> can'o'worms
19:08:37 <ddarius> @where haskerl
19:08:37 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
19:08:40 <luite_> plogYy: quite different :)
19:08:40 <ddarius> Yay!
19:08:48 <dons> can'o'worms <-- not vegan
19:08:53 <shapr> heh
19:08:54 <dons> ddarius: well done.
19:08:58 <gwern> dons: so then presumably one could use a utf8-bytestring? did that ever get fixed? (or for that matter, what is stopping us from replacing packedstring with String?)
19:09:05 <p_l> plogYy: I don't know if you can compare Swiss Army Chainsaw to anything and not get stuck
19:09:23 <dons> gwern: right. you could use a utf8 friendly packed string of some kind
19:09:43 <Lemmih> dons: You've done a lot to publicise lhc. I was a bit surprised to find my name on reddit (:
19:09:47 <dons> hehe
19:09:49 <Raevel> one difference between perl and haskell is that you may end up with readable code when you play golf
19:09:50 <dons> go Lemmih !
19:09:53 <Raevel> in haskell
19:09:55 <plogYy> i worked for sometime on PHP because at that time Perl was tough for me to learn, i know people here wouldn't support learning PHP :)
19:10:10 <dons> plogYy: php is the anti-haskell :)
19:10:19 * gwern experiments with replacing packedstring with String
19:10:29 <shapr> PHP is a great example of a domain specific language.
19:10:31 <dons> gwern: should be good.
19:10:32 <gwern> I await ghc's verdict with bated breath!
19:10:38 <shapr> Haskell is really good at writing domain specific languages.
19:10:40 <gwern> it seemed to compile!
19:10:42 <dons> shapr: mmm. nice
19:10:52 <plogYy> dons: why it's anti haskell :) because it's functional ?
19:10:54 <ddarius> PHP as an EDSL in Haskell!
19:10:59 <shapr> yeah!
19:11:07 <p_l> plogYy: PHP is a bloody mess for anything other than it's very narrow domain. Which doesn't really include writing big web apps :P
19:11:13 <plogYy> shapr: domain specific language?
19:11:13 <dons> oh, my whinghing seems to have reduced the number of extensions used in haskeline
19:11:30 <luite_> shapr: what would exactly be the domain?
19:11:39 <shapr> luite_: html templating.
19:11:39 * ddarius marvels at the rapid uptake of letters into the word 'whining'
19:11:41 <gwern> luite_: forums. small oens.
19:11:48 <Raevel> a guest book?
19:11:57 <dons> whinging
19:12:06 <dons> i.e. having a sook
19:12:25 <p_l> plogYy: BTW, if you wanted a skill that's really highly priced and rare... learn COBOL. seriously, financial records management all around the world await you with that...
19:12:33 <shapr> PHP stands for PHP : Hypertext Preprocesser, and it's pretty good at that.
19:12:34 <gwern> isn't a sook a kind of marketplace?
19:12:45 <dons> nah.
19:12:52 <shapr> If you consider PHP something like the cpp preprocessor for HTML, it's okay.
19:12:54 <Raevel> PHP stands for Personal Home Page and it's not quite there yet
19:12:55 * ddarius has no idea what a sook is.
19:13:03 <dons> someone who whinges
19:13:05 <dibblego> a whinge
19:13:36 <luite_> shapr: it originally stood for Personal Home Page, that may be a better domain ;)
19:13:43 <gwern> dons: are you sure there's an open bug for packedstring in th? I can't seem to find anything in the ghc bug tracker nor a mention on the TH ml
19:13:43 <plogYy> p_l: really? i aim to build financial and accounting apps in the future actually, but never heard that COBOL is famous about that
19:13:50 <dons> gwern: ping dcoutts and Igloo
19:14:12 <gwern> @seen dcoutts_
19:14:12 <lambdabot> dcoutts_ is in #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts_ speak 5h 37m 35s ago.
19:14:15 <gwern> @seen dcoutts
19:14:15 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 3h 3m 38s ago.
19:14:19 <gwern> @seen Igloo
19:14:19 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 2h 2m 14s ago.
19:14:25 <gwern> dang
19:14:46 <gwern> libraries@haskell.org is listed as maintainer, guess I'll search their archives
19:14:54 <dons> gwern: or just ask in #ghc
19:15:03 <British0zzy> has anyone made a neural net in haskell?
19:15:06 <p_l> plogYy: It's because there's that what is called "dark mass of COBOL code" written for various record keeping stuff over the years, running on big mainframes..
19:15:20 <luite_> British0zzy: there is at least one on hackage (almost at the top of the list)
19:15:22 <dons> British0zzy: there's a library on hackage
19:15:29 <p_l> plogYy: Also known as the only place where Y2K bug really existed :)
19:15:40 <British0zzy> whats hackage?
19:15:52 <dons> hackage.haskell.org
19:15:56 <British0zzy> thanks
19:15:59 <dons> central repository for haskell libraries and tools
19:16:05 <dons> take your pick, its probably there.
19:16:13 <plogYy> p_l: that's rare to find, if i learn COBOL for just working on mainframes, it would be useless :)
19:16:39 <gwern> plogYy: no, it would be quite useful for getting a well-compensated job
19:17:25 <Raevel> the job probably comes with an unlimited supply of prozac?
19:17:45 <plogYy> :)
19:17:50 <dons> i note we've two (or more?) simple config file libs now
19:17:53 <dons> eeconfig and configfie.
19:18:21 <dons> eeconfig doesn't need missingh, too, so plus in that direction
19:18:53 <plogYy> gwern: COBOL? i am really wondering that it's highly compensated , i know that JAVA, c# PERL are those who are ranking high
19:18:57 <gwern> missingh needs a good whack with the merge-split
19:19:02 <dons> i wonder how we'd quantify how much 'cheaper' dependencies have become, now we have cabal-install
19:19:16 <dons> try to measure what increase in dependency use has occured since cabal-install ?
19:19:28 <p_l> plogYy: The thing is, that code is still used and crunches most important data.. and someone has to keep it running, as usually replacing it would much more costier and risky
19:19:28 <gwern> plogYy: from the surveys I remember, COBOL programmers have one of the highest average salaries from a combo of both seniority and scarcity and crucialness
19:19:57 <dons> gwern: ever met a cobol programmer?
19:20:05 <gwern> dons: yes
19:20:16 <dons> oh, i think lispy's done some commercial cobol
19:20:17 <Raevel> i'm happy i'm not a software engineer
19:20:22 * p_l bows to gwern for finding a rare species
19:20:31 <plogYy> i never met a COBOL programmer, that's why i am surprised that it's still alive :)
19:20:44 <p_l> plogYy: Oh, it's alive and well
19:20:53 <shapr> I used to work with a bunch of COBOL programmers, they make a lot of money. I got to see what they do, and I will never choose to do it.
19:21:14 <gwern> shapr: thank you! for backing me up
19:21:42 <shapr> We had one amusing instance where some COBOL source kept bouncing off the customer's email filter.
19:21:45 <gwern> I think the funniest research papers I've ever read were ones on adding a modern object system to COBOL, and another one on adding more powerful types to it
19:21:47 <p_l> the funny thing is when you happen to get a look at code that really uses all tricks COBOL has. I remember someone talk about his contracting job, where he wrote something like that
19:21:47 <plogYy> p_l: bas is the rumours when people just say things without any clue, people around think that COBOL is a dead old language like basics, never used, except in some school classes
19:21:50 <dons> shapr: hehe
19:22:06 <gwern> (COBOL is dying. Netcraft confirms it)
19:22:17 <shapr> They called me in to look at the problem, since I'm good at solving weird problems, and all the variables were named X, XX, XXX, XXXX, XXXXX
19:22:19 <plogYy> shapr: why, is their work hard?
19:22:32 <p_l> gwern: The stuff where 99% of COBOL works is not connected to network IIRC
19:22:42 <shapr> So I suggested that they rename their variables to get rid of all the XXX strings, and lo and behold, their email filter allowed it.
19:22:57 * gwern suspects p_l did not appreciate the joke
19:23:20 <p_l> gwern: I think I need to go to sleep, cause I missed it completely
19:23:21 <gwern> nope, the libraries@ archives don't seem to have any discussion
19:23:27 <shapr> plogYy: Have you ever done division with Roman Numerals?
19:23:31 <gwern> could I really be the first person to run into this problem?
19:23:48 <plogYy> shapr: what's that?
19:23:53 <dons> gwern: no. its well known. people just install packedstring
19:24:04 <gwern> :)
19:24:22 <shapr> plogYy: Have you seen the numbers that look like I, II, III, IV, V, VI, etc?
19:24:32 <gwern> I guess it took the rare combination of cabal-install, 6.10, and packedstring to make this a problem
19:24:35 <p_l> anyway, I remember someone talking about code-generation macros in COBOL. He mentioned that other workers looked at his code and were all "... COBOL can do that!?"
19:24:47 <plogYy> well, i think it's something subjective to the demanding market, actually, the word COBOL is missed in almost every company i see
19:25:04 <plogYy> shapr: sure
19:25:24 <plogYy> sure, i saw them but never worked with them
19:25:31 <shapr> plogYy: Have you ever tried to do division on a piece of paper with those numbers? It's hard! Representation affects ease of problem solving.
19:26:05 <shapr> In my opinion and experience, COBOL is no longer the best way to represent a problem for ease of solving.
19:26:06 <gwern> roman numerals, and math notation in general, are one of the best arguments for Why Progamming Language Research Matters
19:26:44 <shapr> plogYy: Check out wikipedia's COBOL examples: http://en.wikipedia.org/wiki/Cobol
19:26:45 <lambdabot> Title: COBOL - Wikipedia, the free encyclopedia
19:26:47 <plogYy> what's the next highly ranked and priced language to COBOL in our opinion?
19:26:57 <gwern> c++?
19:27:08 <p_l> C++ was designed for that...
19:27:40 <p_l> But I think that if you get into it, it's hard to define one
19:28:02 <QtPlatypus> What do you mean by "priced"?
19:28:15 <gwern> dons: how fast is utf8-string's Data.ByteString.UTF8 ? is it the promised utf8-bytestring?
19:28:27 <p_l> I remember that most jobs adverts mentioning Haskell, OCaml etc. came from big financial companies, ready to pay big
19:28:46 <plogYy> QtPlatypus: most demanded by companies
19:28:52 <shapr> or small research firms, ready to offer stock
19:29:05 <QtPlatypus> Typically thats java.
19:29:10 <shapr> There's at least one Boston based Haskell company, but I forgot their name.
19:29:15 <shapr> I keep meaning to meet them.
19:29:15 <plogYy> p_l: financial companies require haskell programmers? what for?
19:29:15 <gwern> well, most of those seekers are interested in someone who thinks functionally, since that's correlated with being smart and good
19:29:42 <p_l> plogYy: Financial analytics
19:29:49 <p_l> FP is big there
19:29:53 <p_l> or so I hear
19:30:02 <p_l> as well as AI
19:30:12 <plogYy> p_l: sounds logic, financial jobs needs to think the same way functional languages work
19:30:14 <gwern> plogYy: have you ever read an essay by Paul Graham in which he argues that good programmers gravitate towards languages like python, and so you can get good programmer just (relatively) by adveritising for python, even if python as a lagnauge doesn't really help you?
19:30:56 <mbz> python? why not lisp?
19:31:24 <plogYy> gwern: really? i think he means that a good programmer would go towards relatively hard languages?
19:31:40 <p_l> plogYy: No, towards one that give more power
19:31:42 <dino-> gwern: I see a lot of that, yes. Blub programmer wanted. Familiarity with Haskell, Erlang, OCaml or LISP a plus. :/
19:31:43 <plogYy> why he didn't mention haskell then?
19:31:54 <QtPlatypus> plogYy: Relatively hard compared to what?
19:31:58 <plogYy> p_l: python gives more power than haskell?
19:31:58 <shapr> hiya dino- !
19:32:03 <gwern> plogYy: that's not his arugment. by that argument, advertisements would be for assembly programmers or malbolge programmers
19:32:08 <dino-> shapr: Hi there. Hows that Boston?
19:32:13 <dino-> Cold, I'm guessing
19:32:23 <shapr> dino-: It's cold at the moment, but has lots of smart people. I'm having lots of adventures :-)
19:32:38 <p_l> plogYy: No, but it was better known than Lisp or Haskell at the moment of writing, without the baggage
19:32:41 <gwern> plogYy: paul graham is not familiar with haskell much, and even if he were, he'd still prefer lisp. I mention the essay as a general principle: the best programmers like non-popular languages
19:32:44 <dons> gwern: its fine.
19:32:44 <shapr> How's the southeast treating you?
19:32:55 <dino-> shapr: Excellent. I was kicking around the idea of moving there in 2005 but ended up not.
19:32:59 <shapr> dino-: Aww
19:33:04 <shapr> dino-: Coming to visit anytime soon?
19:33:08 <dino-> shapr: It's ok. Jobs are not great, but it's good that I have one.
19:33:13 <doublec> I'm trying to get a simple ghc-api example working: http://hpaste.org/12308
19:33:20 <p_l> afk - sleep time
19:33:21 <gwern> at the time it was written in 2000 or 2001, iirc, python was still relatively non-popular although obviously beomcing much more populatr
19:33:24 <British0zzy> if i want riced matrix multiplications, what package should i use?
19:33:27 * shapr waves to p_l 
19:33:34 * p_l waves sleepily back
19:33:35 <doublec> I get an error 'not in scope' whenever I use compileExpr
19:33:42 <shapr> riced?
19:33:44 <doublec> as per that paste
19:34:16 <dons> shapr: optimized.
19:34:21 <dons> British0zzy: hmatrix
19:34:27 <British0zzy> k, thx
19:34:32 <shapr> aha
19:35:06 <dons> blas perhaps, or even Vec
19:35:13 <plogYy> i am still wondering about the point, it's great to seek a powerful language, but what is the benefit of being powerful while companies need to finish their work in a day or two, they will just seek a VB developer, isn't that unfair to those who learn powerful languages like COBOL, Haskell perl and etc?
19:35:40 <dancor> does anyone know how recent glibc has to be to not get Floating point exception
19:35:50 <dancor>  in 6.10.1 ./utils/pwd/pwd
19:36:06 <dibblego> plogYy, the VB programmer who understands Haskell will be far more effective than the VB programmer who doesn't
19:36:07 <shapr> plogYy: I worked on a vba project for several months recently. Requirements changed, and the code had to be scrapped entirely.
19:36:21 <dancor> not much info on http://hackage.haskell.org/trac/ghc/ticket/2211
19:36:23 <lambdabot> Title: #2211 (Installing latest GHC-6.8.2 stable: pwd with floating point exception) -  ...
19:36:35 <gwern> plogYy: if I may put it in a way less than favorable to haskell, learning haskell proves your capability and intelligence and stuff in a way VB doesn't. it is an unforgeable signal - you can't fake knowing haskell
19:36:41 <plogYy> shapr: and what did you do after that?
19:37:03 <shapr> I got publically castigated, and then they gave me something else to do.
19:37:19 <shapr> er, publicly
19:37:36 <gwern> they didn't like your code that much?
19:38:06 <shapr> I think they were mostly unhappy that I was in fact right, this project was a bad answer to the wrong question.
19:38:26 <plogYy> what is delphi similar to?
19:38:56 <dino-> plogYy: Pascal
19:39:59 <plogYy> people now just seek to drag and drop GUI and build few objects and give the app they made to their managers, this is frustrating and really removed the beauty of working with functional languages
19:40:15 <shapr> gwern: Downside is that I'm on the third in a rowd of eath march projects that's going to fail. My reputation at the client is not high.
19:40:24 <plogYy> dino-: it's functional?
19:40:35 <gwern> ouch. you're a contractor/consultant right?
19:40:41 <dino-> plogYy: I believe not. But it is basically an OO Pascal, that Delphi.
19:40:58 <shapr> Yup, and the cients hate being told their project is going to fail from before the time the project starts.
19:41:43 <shapr> I am not considered a team player, meaning I won't just shut up and take the fall quietly :-)
19:41:55 <erikc> haha, that sounds familiar
19:43:13 <shapr> erikc: Hey, the many cell blades is slowly becoming reality :-)
19:43:23 <erikc> you found hosting?
19:43:37 <shapr> Yeah, for far less than the $1k/month everyone else offered.
19:44:05 <shapr> @seen jethr0
19:44:05 <lambdabot> Last time I saw jethr0 was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books,
19:44:05 <lambdabot> #haskell-hac07, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #
19:44:05 <lambdabot> haskell.se, #haskell_ru, #jhc, #jtiger, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 1m 8d 13h 17m 53s ago, and .
19:44:06 <plogYy> people are convinced that functional languages is wasting time to build big enterprise apps
19:44:20 <shapr> plogYy: Who?
19:44:29 <shapr> Which people?
19:44:37 <dibblego> plogYy, I have only ever met people who say that and don't have the first inkling about functional languages
19:45:09 <plogYy> my friends who work in developing apps for companies, they would laugh if i mentioned anything other than c# or java
19:45:28 <dibblego> plogYy, sucks to be them really
19:45:37 <dons> heh
19:45:50 <shapr> plogYy: Have they tried using anything other than C# or Java?
19:46:04 <dons> yes. while we're encouraged to read widely, and travel widely. apparently knowing lots of cool technologies is a liability in some places
19:46:11 <shapr> True that.
19:46:13 <chessguy> c# has some functional features
19:46:20 <dons> cheeseguy!!!
19:46:26 <shapr> chessguy: It even has type inference!
19:46:38 <dons> shapr: or 'latent typing' as i heard it described at sc08.
19:46:54 <chessguy> shapr and laziness
19:47:04 <shapr> It looks like going from blind to severely nearsight to me.
19:47:16 <erikc> i sat through an hour presentation last week about a guy's 'new framework', only to say at the end 'so...you implemented prolog'
19:47:23 <shapr> ouch
19:47:24 <erikc> he said 'i dont know what that is'
19:47:25 <plogYy> shapr: never, they say, am i going to spend days to build classes which are really pretty here in .net framework or in Java libs, do you want me to build such big app from scratch with functional programming, that;s insane! > they claim
19:47:42 <erikc> (its a buggy implementation of prolog :)
19:47:48 <dons> doing prior research isn't as widely taught skill in this industry
19:47:50 <dibblego> plogYy, they must give reasons for claims of such insanity
19:47:53 <dons> we reinvent lots of wheels
19:47:55 <shapr> plogYy: If their point is that libraries do not exist, check out hackage.
19:48:30 <dons> plogYy: yeah, not from scratch. use libraries plz.
19:48:44 <chessguy> ah, hackage, the solution to all haskell's problems
19:48:53 <shapr> erikc: I spoke to a guy at EuroPython 2005 who wrote a make clone, asked him if he'd used directed acyclic graphs. He said he didn't use anyting academic.
19:48:55 <dons> there are other ecosystems besides .net and java.
19:49:01 <dons> shapr: hah
19:49:19 <chessguy> heh
19:49:23 <dons> that's too depressing
19:49:27 <erikc> haha
19:49:36 <gwern> shapr: but at least he didn't make tabs significant?
19:49:50 <plogYy> they would be suspicious about how much reliable an open source lib is, sounds like they are microsoft fellows :)
19:49:51 <shapr> I don't remember :-)
19:49:51 <dons> http://lemonodor.com/images/dijkstra-quick-n-dirty-s.jpg
19:50:15 <shapr> plogYy: That's funny, my experience is that an open source lib is always as reliable as my ability to fix it.
19:50:21 <heatsink> dons: Is that a famous person?  I don't recognize the picture.
19:50:24 <shapr> plogYy: How quickly does Microsoft fix the bugs you find?
19:50:31 <heatsink> Oh-- dijkstra.
19:50:36 <necroforest> dons, i recognize him but i still don't get it
19:50:59 <dons> he's an haskell programmer deep down.
19:51:00 <plogYy> shapr: exactly, open source really proved its efficiency
19:51:21 * dons is happy at how gitit builds
19:51:57 <chessguy> well, part of the problem is, most companies want to sell their software, which means NOT using open-source libraries
19:52:09 <dons> chessguy: GPL you mean?
19:52:32 <chessguy> i never remember the different licenses
19:53:02 <plogYy> i got the GHC, i am going to start haskell after a taking a good rest
19:53:14 <heatsink> chessguy: BSD is the probably the most common OSS license that allows commercial use
19:53:15 <dons> yay
19:53:37 <chylli> what's the diff of `mod` and `remaider`?
19:53:40 <plogYy> enjoyed the discussion, see you all later on
19:53:43 <gwern> whew! finished that TH email
19:53:44 <chylli> `mod` and `rem`
19:53:53 <plogYy> thanks all for the info
19:53:55 <dibblego> @check \x y -> x `mod` y == x `rem` y
19:53:56 <lambdabot>   "* Exception: divide by zero
19:54:01 <gwern> I wish I could write emails faster
19:54:06 <dibblego> @check \x y -> y /= 0 ==> x `mod` y == x `rem` y
19:54:07 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
19:54:07 <lambdabot>           ...
19:54:18 <plogYy> thanks dibblego
19:54:22 * gwern blames #haskell for distracting me
19:54:45 <heatsink> chulli: They use different rounding for negative numbers.  I think 'mod' rounds to -inf and 'rem' rounds to zero.
19:54:48 <plogYy> bye all
19:54:51 <shapr> bye plogYy !
19:54:51 <heatsink> *chylli
19:54:56 <shapr> come back soon!
19:55:01 <heatsink> bye plogYy.
19:55:03 <erikc> y
19:55:03 <erikc> * dons is happy at how gitit builds
19:55:03 <erikc> <chessguy> well, part of the problem is, most companies want to sell their software, which means NOT using open-source libraries
19:55:03 <erikc> <dons> chessguy: GPL you mean?
19:55:03 <erikc> <chessguy> i never remember the different licenses
19:55:05 <erikc> <plogYy> i got the GHC, i am going to start haskell after a taking a good rest
19:55:07 <erikc> <heatsink> chessguy: BSD is the probably the most common OSS license that allows commercial use
19:55:08 <chylli> heatsink: still not understand
19:55:09 <erikc> <dons> yay
19:55:11 <erikc> <chylli> what's the diff of `mod` and `remaider`?
19:55:13 <erikc> <plogYy> enjoyed the discussion, see you all later on
19:55:15 <erikc> <gwern> whew! finished that TH email
19:55:15 <dibblego> > 3 `mod` (-2)
19:55:16 <lambdabot>   -1
19:55:17 <erikc> <chylli> `mod` and `rem`
19:55:19 <erikc> <plogYy> thanks all for the infoasdfas
19:55:20 <dibblego> > 3 `rem` (-2)
19:55:21 <chessguy> heatsink:  but you'd still have to distribute your own source, right? which means anyone can fork it
19:55:21 <erikc> ugh
19:55:22 <lambdabot>   1
19:55:23 <erikc> sorry
19:55:24 <dons> yay , gitit. just needs haskell-cgi haskell-crypto haskell-happs-data haskell-happs-ixset haskell-happs-server haskell-happs-state haskell-happs-util haskell-haxml haskell-highlighting-kate haskell-hspread haskell-pandoc haskell-pcre-light haskell-syb-with-class haskell-zip-archive
19:55:30 <dons> all of which build out of the box.
19:55:31 <dons> cabal++
19:56:12 <heatsink> > 5 `mod` (-2)
19:56:13 <lambdabot>   -1
19:56:17 <heatsink> > 5 `rem` (-2)
19:56:18 <lambdabot>   1
19:56:34 <chylli> thanks
19:56:35 <heatsink> chylli: They will always return the same result when both operands are positive.
19:56:39 <dons> gitit is the ultimate expression of hackage + cabal today
19:56:45 <dons> it's tiny once all the deps are resolved.
19:56:46 <dibblego> why doesn't @check work?
19:57:22 <gwern> my problem with gitit is that the link time is insane
19:57:29 <gwern> I still haven't succeeded in installing it
19:57:59 <doublec> ok, fixed my ghc-api example so it works
19:58:01 <doublec> http://hpaste.org/12308#a1
19:58:18 <doublec> I was missing the setContext it seems
19:58:33 <gwern> the ghc api is very tricky to work with. that's why I use Hint
19:58:33 <British0zzy> is there a gui version of ghci?
19:58:48 <doublec> Hint looks good, but doesn't work with the latest ghc afaik
19:58:51 <gwern> not really. what would it do but duplicate terminal functionality?
19:59:09 <gwern> doublec: true, but the author is prety respsonsive.
19:59:16 <British0zzy> perhaps it would have features not available in the CLI version
19:59:22 <dons> gwern: seems ok here.
19:59:23 <chessguy> gwern:  provide an actual modern IDE?
19:59:25 <dons> gwern: wnat a binary?
19:59:39 <gwern> dons: nah I'll keep trying it myself
19:59:45 <dons> British0zzy: there's no gui version in wide use, afaik.
19:59:52 <gwern> dons: I'll never be able to replace the git with darcs if I can't compile it myself
20:00:03 <erikc> just tried a cabal install gitit on windows...if this works out of the box it will blow my mind
20:00:14 <gwern> chessguy: wouldn't ghci itself being graphical merely interfere with an IDE's business?
20:00:18 <dons> erikc: it might just...
20:00:29 <dons> erikc: assuming 6.10 and latest cabal, cabal-install
20:00:32 <erikc> heh, im so used to windows build env knightmares
20:00:34 <erikc> yup
20:00:39 <chessguy> gwern:  well, presumably he's talking about a layer on top of ghc
20:00:40 <erikc> nightmares
20:00:58 <doublec> gitit is definitely a nice example of the package system working
20:01:06 <chessguy> which could itself be an IDE or provide hooks for an IDE
20:03:06 <dons> someone going to write a nice cairo/pango based ghci wrapper?
20:03:13 <dons> something really pretty and use hscolour for syntax?
20:04:00 <gwern> whew. that takes care of my darcs email
20:04:40 <dons> anyone played hpylos yet?
20:06:43 <Nafai> dons: That would be pretty cool.
20:06:54 <Nafai> dons: How hard would it be to wrap ghci?
20:07:30 <Nafai> doublec: What are you working on?
20:07:30 <fired> hi
20:07:44 * fired just came home with the new lego pirates. the black ones.
20:07:47 <dons> Nafai: i think not too hard at all
20:07:59 <doublec> Nafai, playing around with Haskell. Got the 'real world haskell' pdf and am exploring :)
20:08:13 <Nafai> Is there some ghc-api or something that you could use?
20:08:33 <doublec> I wanted to ghc-api to do dynamic loading in a web app
20:08:40 <Nafai> dons: That might be a fun hacking project
20:08:41 <doublec> which most of the web app frameworks seem to use hs-plugins for
20:22:36 <Cale> doublec: You might see about possibly using hint, which is a wrapper around the GHC API.
20:23:09 <doublec> Cale, yes I'll probably look at that once it's working with the latest ghc
20:27:22 <dons> nice soln to bowling balls problem, http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Bowling_balls/
20:27:32 <lambdabot> Title: Bowling balls
20:33:31 <heatsink> @quote
20:33:32 <lambdabot> Randroid says: I just wrote a monad that does my laundry. It threads it round and round until it's washed. Now I'm going to work on the Dryer monad.
20:34:12 <monochrom> haha
20:35:07 <dons> cool
20:35:35 <Cale> Fool! Everyone knows that Dryer is a comonad!
20:36:58 <kfish> can it dry an infinite stream of washing?
20:37:32 <kfish> http://www.vergenet.net/~conrad/text/underwear_fifo.html
20:37:33 <lambdabot> Title: The Underwear FIFO
20:38:10 <dons> you'll need to use an exhaustively searchable set if you want to finish if finite time
20:39:05 <pumpkin_> lol
20:39:36 * Cale arranges his clothing into a Cantor space.
20:41:14 <heatsink> Cale: does that mean your clothes' surface area has lebesgue measure 0?
20:42:32 <Cale> Uhh... it seems that the dryer shrunk it.
21:10:18 <erikc> hmm, well, not entirely without issues (had to build libpcre, and something in crypto was causing a ghc.exe panic which -fregs-graph fixed), but gitit built on windows
21:12:03 <doublec> yeah, I had those problems in Linux too
21:12:35 <thoughtpolice> @tell Lemmih what do you think about replacing DrIFT with Data.Derive? in my little compiler I was working on it was what I used (it was similar to jhc/lhc in structure)
21:12:35 <lambdabot> Consider it noted.
21:13:05 <cjs> Ok, so to deal with my "I want to apply all but the first parameter on one of these many value constructors" issue, I'm trying out just applying undefined as the first param, and then replacing it later in common code. (It's a time that needs to be pulled out from a Monad.) Is this evil?
21:13:13 <Lemmih> thoughtpolice: Data.Derive?
21:13:13 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
21:14:14 <pumpkin_> it'd be interesting to write some sort of computer algebra system in haskell, to do symbolic calculations and such
21:14:47 <shapr> pumpkin: http://homepages.inf.ed.ac.uk/wadler/realworld/docon2.html
21:14:48 <lambdabot> Title: DoCon
21:15:20 <thoughtpolice> Lemmih: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive <- it has similar functionality, but we can use template haskell to derive instances inside files (as a consequence you can derive instances for datatypes defined in other modules,) so we don't need to have a cabal preprocess hook either
21:15:21 <shapr> Sergey shows up here regularly.
21:16:27 <thoughtpolice> Lemmih: also I just updated lhc.seize.it and trac.haskell.org/lhc quite a bit - moved todo and notes pages onto trac, and showed how to build/install lhc/lhc-base on the main site
21:18:00 <pumpkin> looks interesting, thanks
21:18:15 <Lemmih> thoughtpolice: Wonderful. Data.Derive looks perfect.
21:18:24 <thoughtpolice> Lemmih: ok. i will replace things. :]
21:18:24 <erikc> ...and gitit works on windows, wow
21:20:29 <Refresher> hello, I'm having some trouble understanding type inference... anyone able to help me work it out pls?
21:20:40 <thoughtpolice> Lemmih: we might not be able to use it for everything, but we can at least derive bits like binary, etc.
21:20:43 <pumpkin> Refresher: what in particular?
21:20:57 * Cale had to move out of his domain because of a zero divisor infestation. ;)
21:22:03 <Refresher> well, for instance... what would be an example of a function that has type (a->a) -> a ->a ? What is the distinction between the parenthesized ones and the others?
21:22:15 <pumpkin> that would be another function
21:22:17 <Cale> Refresher: -> is right associative by default
21:22:25 <dibblego> (a->a) -> a ->a
21:22:29 <dibblego> (a->a) -> (a ->a)
21:22:36 <Cale> right :)
21:22:50 <Cale> Without the parens, it would be a -> (a -> (a -> a))
21:22:51 <jsn> this seems like it should work:
21:22:52 <jsn> http://github.com/jsnx/haskell-demos/tree/master/generic_zip%2FGenericZip.hs
21:22:54 <lambdabot> Title: generic_zip/GenericZip.hs at master from jsnx's haskell-demos  GitHub, http://tinyurl.com/6h8ysv
21:22:58 <jsn> but it doesn't
21:23:01 <Refresher> ah ok
21:23:21 <dibblego> a function with that signature is id
21:23:22 <Lemmih> thoughtpolice: You rule. Lhc wouldn't be what it is if it weren't for you.
21:23:35 <Cale> Refresher: You can look at such a function in two ways: One as a function which takes a function of type (a -> a), and produces another.
21:23:49 <Refresher> right
21:24:00 <jsn> i'm trying to make a type constructor  '([a] -> [b] ->)' that takes a 'c' and makes a type '[a] -> [b] -> c'
21:24:01 <Cale> Refresher: Secondly, you could look at it as a function which takes a function of type (a -> a) and a value of type a, and produces a value of type a.
21:24:08 <Lemmih> thoughtpolice: Btw, I'm upgrading lhc.seize.it to gitit 0.3.1. The password format has changed so you'll have to re-register.
21:25:42 <Lemmih> thoughtpolice++
21:25:42 <Refresher> ah, ok, so a function that accepts a function as the first argument and a value as it's second and results in a value... so almost like using map on a single element list? Although it would result in a single element list, instead of the element... but am I getting the jist of it?
21:25:43 <Cale> jsn: With TypeCompose, it would be  (->) [a] :. (->) [b]
21:26:08 <Cale> Refresher: yeah, kind of... Such a function could do quite a number of things though.
21:26:19 <jsn> Cale: with type compose?
21:26:35 <Cale> jsn: Yeah. That would involve some wrapping though.
21:27:03 <jsn> So what would my two examples look in the end?
21:27:07 <Refresher> Cale: thanks, let me process it for a bit and I might come up with another question if u don't mind :)
21:27:14 <Cale> Refresher: It can apply the function it's given to the second parameter zero or more times.
21:27:32 <Cale> :t let f g x = g (g x) in f
21:27:33 <lambdabot> forall t. (t -> t) -> t -> t
21:28:03 <Refresher> interesting
21:29:05 <Cale> Such functions are called Church numerals, and behave a bit like natural numbers (you can define addition, multiplication, etc.)
21:29:57 <Cale> (the one I wrote there would correspond to 2)
21:31:53 <jsn> Cale: just to be sure I understand -- the only way to do this is with type compose?
21:32:19 <Cale> jsn: Well, you could use newtype or something.
21:32:26 <jsn> Cale: oh?
21:32:29 <Saizan> jsn: i think you should try with the uncurried form first
21:32:45 <Cale> newtype Foo a b c = Foo ([a] -> [b] -> c)
21:32:59 <Cale> Then  Foo a b  is the type constructor you're after.
21:33:08 <jsn> Cale: ah i see
21:33:33 <jsn> so '([a] -> [b] ->)' is always a syntax error
21:33:42 <jsn> but can be expressed some other way
21:33:51 <jsn> Saizan: i'm not sure what you mean, to be honest
21:34:15 <Cale> Right, and even if it was allowed, it's unclear that it doesn't mean (([a] -> [b]) ->)
21:35:26 <jsn> ah, i see
21:35:34 <Saizan> like zip2 :: ([a],([b],())) -> [(a,(b,()))], which is a bit like Tuple from the -cafe thread, but you can use fundeps to get arity inferred by the result
21:36:23 <jsn> Saizan: that seems pretty easy, though
21:37:20 <Saizan> once you've that you can write a genericCurry and get your genericZip :)
21:38:08 <jsn> that's maybe not such a bad approach...
21:39:09 <pumpkin> if I wanted to represent an 8-dimensional vector as a bunch of nested pairs
21:39:43 <Saizan> jsn: http://hpaste.org/12309
21:40:05 <pumpkin> how can I extract the nth value from that? I thought initially of using iterate snd but that obviously wants to construct an infinite type
21:40:58 <cjs> I could use some design advice here. I have the following data structure: http://hpaste.org/12310
21:41:13 <ddarius> :t fst . snd . snd . snd . snd . snd . snd
21:41:14 <lambdabot> forall a b a1 a2 a3 a4 a5 a6. (a6, (a5, (a4, (a3, (a2, (a1, (a, b))))))) -> a
21:42:47 <Nafai> dons: So what would one use to embed ghci in something else?
21:43:34 <cjs> Most of my messages are generated by a module that reads from a market data feed (TCP connection) or a recorded one (a file with timestamps), and all is fine. But when playing back, my "current time" is really based on how far we are into the file, not on what the current system time is. But I often find myself wanting to delgate the setting of the time to some other, later thing through which the message passes. I can't easily p
21:43:34 <cjs> artially apply the value constructor when the time is the first argument.
21:44:16 <jsn> Saizan: i'll have a look at that, thanks
21:44:19 <dolio> Good old cadddddr
21:44:35 <dolio> Oops, missed a d.
21:44:43 <jsn> it's surprising to me how much much more difficult it is to extend (->) to the left than to the right
21:44:53 <cjs> So what should I be doing? Making it the last argument? (A bit awkward.) Make two separate data structures, one for the message, and one containing a timestamped message? (Awkward, but also gets rid of the possibility of someone coming up with a FeedMessage without a messageTime.)
21:45:35 <cjs> The latter seems to make the most sense from many points of view, but ends up adding more boilerplate.
21:46:24 <cjs> Especially when it comes to pattern-matching the message in the many places where I don't use the  time.
21:54:37 <bombshelter13_> Hmm, what operation can I use to put ["B"] into [["A"]] making [["A"],["B"]]?
21:55:29 <Lemmih> bombshelter13_: (++)
21:55:38 <roconnor> bombshelter13_: (++[["B"]])
21:56:00 <roconnor> bombshelter13_: be aware that adding to the end of a list is often a sign of an inefficent design.
21:56:10 <Riastradh> \ ["B"] [["A"]] -> [["A"], ["b"]]    -- Admit no inputs beyond what was specified!
21:56:17 <Riastradh> (Sorry, upcase the `b' there.)
21:56:42 <bombshelter13_> Riastradh: *grinss* technically true i suppose
21:57:11 <bombshelter13_> roconnor: Yeah... I'm just tinkering to learn at this point, and am just trying to get the code working before worrying about inefficiencies...
21:57:26 <bombshelter13_> roconnor: There are probably far greater efficiency sins elsewhere in the code, too. :)
21:58:32 <roconnor> bombshelter13_: good :)
22:06:34 <thoughtpolice> @tell Lemmih okay almost replaced Drift with Data.Derive, need to write a Data.Derive module for DrIFT's 'update' mechanism so we can port over easily, everything else we have covered
22:06:35 <lambdabot> Consider it noted.
22:07:43 <roconnor> can we have deriving Arbitrary?
22:07:58 <thoughtpolice> roconnor: with Data.Derive you can :]
22:08:46 <Lemmih> thoughtpolice: Can't we use 'set'?
22:08:46 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
22:09:39 <roconnor> that would make using quickcheck way easier.
22:10:21 <Lemmih> thoughtpolice: Oh, you're right. Set doesn't update.
