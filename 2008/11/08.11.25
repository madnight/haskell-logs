00:05:10 <vegai> hmm, I have a feeling that case statements are not needed in the language
00:05:24 <sbahra> vegai, needed?
00:05:29 <sbahra> vegai, not sure what you mean.
00:05:30 <vegai> seems to me that local functions with pattern matching are much nicer
00:05:41 <sbahra> vegai, that is one way to approach some problems.
00:05:53 <sbahra> vegai, however, pattern matching functions can be implemented with case statements, too
00:06:31 <vegai> I'll give an example
00:06:55 <vegai> I'm sure you got what I meant, but anyway :P
00:07:12 <vegai> http://haskell.org/ghc/docs/latest/html/libraries/editline/System-Console-Editline.html  has a piece of code under "Description"
00:07:14 <lambdabot> Title: System.Console.Editline, http://tinyurl.com/5pk9s4
00:08:41 <vegai> and mine http://hpaste.org/12345
00:08:47 <vegai> heh, fortunate sequence id for that paste
00:09:05 <povman> vegai: you could also, in the same way, say lambda expressions are redundant
00:09:21 <olsner> I dislike how pattern matching is a magic reserved for case statements and function definitions
00:09:39 <lament> first-class patterns!
00:09:49 <lament> (if you want them, sed's got them)
00:10:03 <pumpkin> I think we need first-class first-classness
00:10:36 <sbahra> pumpkin, huh?
00:10:37 <povman> i don't understand the concept of first-class patterns
00:10:45 <olsner> someone should write a haskell interpreter in sed
00:11:27 <olsner> sed could be the only program you ever need
00:11:48 <pumpkin> sbahra: just being stupid, sorry :P
00:12:32 <povman> olsner: where else would you like to use pattern matching?
00:14:29 <solrize> first class patterns couldn't be type-inferred
00:17:33 <Saizan> ?google first class labels Daan
00:17:35 <lambdabot> http://research.microsoft.com/users/daan/pubs.html
00:17:36 <lambdabot> Title: Publications
00:18:52 <Saizan> the First-class labels for extensible rows uses them to implement first class patterns, btw
01:01:56 <pumpkin> anyone tried http://repetae.net/computer/frisby/ ?
01:01:57 <lambdabot> Title: Text.Parsers.Frisby
01:02:57 <Raevel> looks interesting!
01:08:33 <pumpkin> I seem to have Text.ParserCombinators.Parsec but not Text.Parsec
01:08:36 <pumpkin> is that normal?
01:09:14 <Saizan> yes if you've parsec-2
01:10:06 <pumpkin> hmm
01:10:31 <pumpkin> I could've sworn I had 3 installed
01:12:45 <vegai> perhaps you have it only as user
01:13:02 <pumpkin> how can I check what I have instaled on cabal?
01:13:12 <Saizan> ghc-pkg list
01:14:05 <vegai> and, I just found out, cabalized Setup.hs program doesn't take user libraries in if you don't do runghc Setup.hs --user
01:14:23 <pumpkin> ah, I remember now, I tried to install parsec 3 on cabal but it said I already had it installed, but it looks like I have 2.1 installed systemwide
01:14:38 <Saizan> yeah, the default is inverted between Setup and cabal-install wrt --user/--global
01:14:42 <vegai> runghc Setup.hs configure --user   I mean
01:15:29 <thoughtpolice> @seen Lemmih
01:15:30 <lambdabot> I saw Lemmih leaving #haskell 37m 19s ago, and .
01:16:23 <pumpkin> frisby looks cool but I'm not sure I like how the grammar is specified: http://repetae.net/repos/frisby/frisby/examples/Additive.hs
01:19:14 <birdspider> hi all :), how do I write an empty tuple, i.e. a funktion returns (a,b) but in nil case an empty tupel i.e (,)
01:19:22 <dibblego> ()
01:19:36 <pumpkin> a Maybe?
01:19:39 <quicksilver> birdspider: you can't.
01:19:44 <dibblego> sorry, Maybe (x, y)
01:19:48 <quicksilver> birdspider: if it returns (a,b) then it returns (a,b)
01:20:04 <quicksilver> birdspider: if you want it to maybe return (a,b) and possibly not, then use "Maybe (a,b)"
01:20:12 <quicksilver> birdspider: (as the other people here just suggested ;)
01:20:23 <pumpkin> birdspider: tuples are a fixed size, so if you have a 2-tuple it will always be a 2-tuple
01:20:34 <pumpkin> just to repeat what everyone else is saying a bit more :P
01:20:37 <birdspider> quicksilver: hm, ok thanks,
01:20:40 <birdspider> thanks :)
01:23:51 <birdspider> ok, I admit, I don't know how to implement this funktion properly, maybe anyone has an idea: http://pastebin.com/d5caddb13
01:24:07 <birdspider> i want to flatten an heterogenous tree for sorting
01:24:17 <birdspider> but this heterogenousnes is killing me
01:24:33 <dibblego> HList perhaps?
01:24:39 * quicksilver slaps dibblego 
01:24:54 <quicksilver> birdspider: perhaps you want to flatten it to [Either a (a,b)]
01:25:10 <dibblego> oh I see, sorry :)
01:25:11 <quicksilver> birdspider: since that's what you store at the nodes - either just an "a" or an "a" and a "b"
01:25:15 <pumpkin> heterogeneous how?
01:25:31 <birdspider> quicksilver: yes this looks nice
01:25:40 <quicksilver> birdspider: by the way, surely you want htreeToList Nil = []
01:25:47 <birdspider> pumpkin: nodes have either a oder  a b value
01:26:10 <birdspider> quicksilver: yes but I think that rises an error
01:26:17 <pumpkin> it shouldn't?
01:26:21 <quicksilver> shouldn't do.
01:26:26 <quicksilver> [] is a valid memebr of type [(a,b)]
01:26:39 <quicksilver> birdspider: another alternative to [Either a (a,b)] is [(a,Maybe b)]
01:26:52 <quicksilver> (this is essentially the same thing, but is perhaps a little more convenient actually)
01:27:26 <pumpkin> it seems like it would be more convenient to represent the whole tree like that
01:27:28 <pumpkin> (a, Maybe b)
01:27:31 <birdspider> *** Type           : [a]*** Does not match : [Either a (a,b)]
01:27:31 <birdspider> *** Because        : unification would give infinite type
01:27:34 <pumpkin> then you can flatten it without special cases
01:27:53 <pumpkin> no?
01:28:03 <pumpkin> is that hugs?
01:28:05 <birdspider> yes but the tree structure is read only :)
01:28:08 <pumpkin> oh
01:28:10 <birdspider> hugs
01:28:12 <quicksilver> pumpkin: possibly, but maybe that's not what he's been asked to do.
01:28:54 <birdspider> its hug98
01:29:13 <pumpkin> birdspider: replace the (a, []) with (a, Nothing) and the (a, b) with (a, Just b)
01:29:29 <pumpkin> oh wait
01:29:39 <pumpkin> you're doing it the first way
01:30:22 <tredontho> question, i'm trying to build lambdabot on my local machine, and i'm using cabal, and it can't install because haskell-src-exts-0.4.3.1 requires base >= 4.. I assume this is dependant on what version of, for example, ghc i'm using?
01:30:36 <pumpkin> birdspider: then you'd probably want Left a or Right (a, b) I think
01:30:56 <Raevel> tredontho: heh, i did the exact same thing a few hours ago
01:31:19 <birdspider> pumpkin: huh ?
01:31:30 <Raevel> tredontho: install haskell-src-exts-0.3.9 instead
01:31:33 <quicksilver> birdspider: that's how you use the Either type
01:31:43 <pumpkin> birdspider: you defined your return type of htreeToList as an Either, so you need to make sure you're generating eithers
01:31:47 <quicksilver> Left constructs the left alternative and Right constructs the Right one
01:31:47 <Raevel> tredontho: appearantly lambdabot doesn't play nice with 0.4 either
01:32:00 <quicksilver> :t [Left 'a',Right "hi"]
01:32:01 <lambdabot> [Either Char [Char]]
01:32:04 <tredontho> Raevel: Okay.  This is my first time using cabal, is there a way to specify what version to instlal?
01:32:27 <Raevel> tredontho: yeah, type haskell-src-exts-0.3.9 instead of haskell-src-exts
01:32:35 <dcoutts> tredontho: cabal install foo-1.0, or cabal install 'foo >= 2'
01:32:46 <pumpkin> birdspider: but if you're still undecided, I think quicksilver's second suggestion was prettier :P if that makes any difference to you :)
01:32:53 * dcoutts should add those examples to the cabal install --help
01:32:56 <Raevel> tredontho: i actually had to do cabal install --with-happy=`which happy` haskell-src-exts-0.3.9 for it to work
01:33:14 <tredontho> Raevel: Cool, thanks, I'll give it a shot
01:33:15 <dcoutts> Raevel: hmm, that's pretty odd, it does look for happy on the path
01:33:24 <Raevel> dcoutts: but it couldn't find it
01:33:28 <dcoutts> Raevel: does calling happy --help work?
01:33:32 <dcoutts> or --version
01:33:37 <Raevel> yep
01:33:39 <dcoutts> hmmm
01:33:57 <birdspider> pumpkin: http://pastebin.com/d25b6043f this gives me *** Term           : [(a,Nothing)] *** Type           : [(a,Maybe c)] *** Does not match : [Either a (a,b)]
01:34:10 <dcoutts> Raevel: I'd be interested to see the output of cabal install -v haskell-src-exts-0.3.9
01:34:16 <pumpkin> yeah, I corrected myself after that, sorry :)
01:34:19 <Raevel> sure
01:34:23 <dcoutts> the bit where it reports where it found happy, or not
01:35:03 <pumpkin> I thought you were doing the (a, Maybe b) approach, but if you go with the Either approach, you need to do Left a instead of (a, Nothing), and Right (a, b) instead of (a, Just b) compared to what I said earlier
01:35:31 <Raevel> dcoutts: http://pastie.caboo.se/paste/323316
01:36:27 <birdspider> pumpkin: seems to work, let me think over this a bit
01:36:29 <Raevel> my happy version is 1.18.2
01:37:21 <dcoutts> Raevel: what does this report: $ ghc -e 'System.Directory.findExecutable "happy"'
01:37:43 <Raevel> Just "/home/adam/.cabal/bin/happy"
01:37:55 <dcoutts> how confusing
01:38:07 <Raevel> :-/
01:38:44 <dcoutts> Raevel: can you paste the same example again, but with -v3 instead of -v
01:38:59 <dcoutts> only the last few lines is necessary
01:39:02 <Raevel> okay
01:39:35 <Raevel> http://pastie.caboo.se/paste/323318
01:39:52 * dcoutts is very confused
01:40:25 <birdspider> pumpkin: i.e. the list returns [Left 4,Right (5,7),Left 4,Right (5,3)], how do I access the "a" elements .. left a and right (a,b)  ?
01:40:34 <dcoutts> Raevel: http://pastie.org/323319
01:40:35 <lambdabot> Title: #323319 - Pastie
01:40:53 <pumpkin> birdspider: well, you can pull them out with pattern matching, but you need to decide what you want to do with them
01:41:02 <pumpkin> you can't stick them in a list together
01:41:04 <birdspider> pumpkin: sort by a
01:41:16 <birdspider> pumpkin: i want to rearrange the list
01:41:26 <birdspider> pumpkin: or return the sorted list
01:41:38 <Raevel> well that's straightforward, i'm equally confused
01:41:55 <pumpkin> ah, okay, so you'd want a function to pass sortBy that pattern matches on the two Eithers you pass in
01:42:04 <birdspider> pumpkin: i used the [ y | x<-xs, ....] before
01:42:28 <birdspider> pumpkin: hm ..
01:42:48 <pumpkin> have you used sortBy before?
01:42:55 <pumpkin> you need to give it a comparator
01:43:04 <birdspider> yes I see,
01:43:31 <pumpkin> so your comparator can have 4 cases of pattern matching, for all patterns of the pair of Eithers it'll get
01:43:40 <pumpkin> by pair I mean 2, not a 2-tuple
01:44:49 <pumpkin> so compareEithers (Left x) (Right (y, _)) = compare x y
01:44:54 <pumpkin> and so on
01:47:29 <dcoutts> Raevel: if you discover anything more interesting tell me, and/or file a ticket, which you might want to do anyway
01:47:50 <dcoutts> Raevel: just in case someone else notices this and we can identify something common
01:47:59 <Raevel> sure, where do i do that?
01:49:08 <dcoutts> Raevel: http://hackage.haskell.org/trac/hackage/
01:49:19 <lambdabot> Title: Hackage - Trac
01:51:57 <Raevel> alright, i'll do that when i get home from school
01:52:01 <Raevel> gotta go!
01:54:37 <birdspider> pumpkin: http://pastebin.com/d15c30eab I'm stuck :),
01:56:14 <birdspider> pumpkin: oh didn't read your last line
01:56:24 <pumpkin> http://hpaste.org/12347 and so on :)
02:02:37 <pumpkin> birdspider: how goes it?
02:04:02 <birdspider> pumpkin: good, only time is running out XD
02:04:15 <birdspider> pumpkin: got it sorted, now .. building back the tree
02:04:23 <pumpkin> :o
02:06:59 <pumpkin> alright, time for bed
02:10:10 <jtraub> Hello!
02:10:20 <jtraub> I am looking for good haskell editor
02:10:37 <mbz> use vim or emacs
02:10:37 <jtraub> Can you give me some recommendations? Except vim and gedit :-)
02:10:57 <jtraub> mbz, Does emacs provide mode for haskell?
02:11:18 <qebab> jtraub: it does, but I don't know if it is installed by default
02:11:21 <mbz> yep, check haskell.org
02:11:25 <pumpkin> I use textmate
02:11:37 <pumpkin> (for mac)
02:11:51 <qebab> pumpkin: so does one of my flatmates. I never hear the end of how cool it is. :p
02:11:54 <pumpkin> yi is in haskell, for haskell, supposedly, but I haven't tried it
02:11:55 <povman> pumpkin: let's go yell at allan for not releasing tm2
02:12:19 <pumpkin> povman: sounds like a good plan! :)
02:12:25 <pumpkin> he's over in ##textmate sometimes
02:12:38 <mbz> http://www.haskell.org/haskell-mode/
02:12:39 <lambdabot> Title: Haskell Mode for Emacs
02:13:06 <pumpkin> povman: it'd be nice if he just gave us updates on development, even if he didn't give us an estimate for when it'd be done
02:13:09 <povman> oh so he's still alive
02:13:13 <pumpkin> it just feels like he forgot about the proejct
02:13:23 <povman> yeah i really don't care, tm1 does it for me
02:13:34 <birdspider> pumpkin: hm, can't figure out the matching, http://hpaste.org/12348
02:13:39 <pumpkin> same here, but there are occasional bugs in tm1 and I haven't had a new build in a bajillion years :P
02:13:58 <pumpkin> birdspider: you're matching the same pattern twice?
02:14:04 <povman> i wish there were more emacs-y syntax hilighting/indentation features
02:14:26 <birdspider> pumpkin: no no, just a stub,
02:14:28 <pumpkin> birdspider: if you want to build a tree, I'd imagine you'd want to fold over the list
02:14:43 <pumpkin> I guess not though
02:14:48 <pumpkin> since it's not in a good structural order
02:15:07 <birdspider> pumpkin: either way I have to distinguish between node1 and node2
02:15:22 <pumpkin> yeah, but you have two copies of the same pattern
02:15:45 <pumpkin> it'll need to be more complicated than this to build the tree again
02:16:21 <pumpkin> you'd probably want some sort of a stable topsort or something?
02:16:30 <birdspider> pumpkin: doesn't have to be a balanced tree or something, just tree form
02:17:15 <pumpkin> heh, not sure what you mean by that :/
02:17:15 <birdspider> pumpkin: the problem I have is how to match against the left and right, giben a list of eithers
02:17:46 <pumpkin> ah, then try
02:18:00 <pumpkin> f (Left a):rest = blah
02:18:08 <birdspider> aH
02:18:14 <pumpkin> f (Right (a, b)):rest = foo
02:18:18 <sjanssen> pumpkin: that won't parse
02:18:27 <pumpkin> oh
02:18:28 <sjanssen> f (Left a : rest) = blah
02:18:35 <pumpkin> oh makes sense
02:18:44 <pumpkin> sorry :) only just started myself too
02:18:49 <sjanssen> also, "rest" is the wrong name, it should be "as" :)
02:19:13 <pumpkin> how about for the Right situation?
02:19:20 <pumpkin> I've been looking for a good doc describing conventions
02:19:25 <sjanssen> I dunno
02:19:31 <pumpkin> but it seems you need to glean them by reading existing code :P
02:19:49 <sjanssen> maybe not "as", but it is general convention to call the head "something" and the tail "somethings"
02:19:57 <pumpkin> makes sense
02:20:53 <pumpkin> anyway, sleepy time
02:20:57 <pumpkin> good luck birdspider :P
02:21:44 <birdspider> thank you all :)
02:26:43 <jtraub> See this piece of code: toString (Mult a b) = (toString a) ++ "*" ++ (toString b)
02:27:04 <jtraub> i want to remove these parents, because
02:27:38 <jtraub> in other pieces i need to make a lot of appends
02:27:51 <Saizan> you can just drop them.
02:27:57 <sjanssen> toString a ++ "*" ++ toString b -- is fine
02:28:11 <Saizan> function application binds tighter than anything else
02:28:22 <sjanssen> or concat [toString a, "*", toString b] -- this style might be better if you have very many items to concatenate
02:28:32 <jtraub> sjanssen, thanks!
02:28:51 <jtraub> Saizan, nope. GHCi throws an error in case of simple dropping
02:29:35 <Saizan> with toString a ++ "*" ++ toString b ?
02:29:44 <jtraub> Saizan, sorry. You were right
02:30:24 <jtraub> huh. Haskell community is very friendly for newbies
02:30:26 <jtraub> thanks
02:31:23 <Saizan> @quote tropical
02:31:24 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
02:35:54 <nominolo|msr> @seen swiert
02:35:54 <lambdabot> I saw swiert leaving #haskell 18h 17m 37s ago, and .
02:39:08 * mlesniak laughs out loud about the "broccoli brains"!
02:40:25 <mlesniak> Anyone can recommend a haskell project with clean, understandable code? Or code, for which you'd say "you just have to see this once in your lifetime"?
02:41:27 <sjanssen> mlesniak: parts of xmonad are nice
02:41:33 <hugo__> hey ppl
02:41:43 <hugo__> ill need to do some serious debugging stuff with haskell
02:41:56 <hugo__> is there any way i can check the instructions step by step ?
02:42:12 <Saizan> ?google ghci debugger
02:42:15 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
02:42:15 <lambdabot> Title: 3.5.�The GHCi Debugger
02:42:22 <sjanssen> @googleit ghci debugger
02:42:24 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
02:42:24 <lambdabot> Title: 3.5.�The GHCi Debugger
02:42:28 <hugo__> allright :D
02:42:31 <mlesniak> sjanssen, implying that other parts are not? ;)
02:42:40 <sjanssen> aww, they haven't pulled the latest darcs yet :(
02:43:44 <sjanssen> mlesniak: overall the code is good, but there are parts here and there that are a bit hairy
02:44:27 <mlesniak> sjanssen, ah, ok, will take a look then (funny that you've mentioned xmonad, been using it for quite a while)
02:51:29 <thoughtpolice> @tell Lemmih please see here - http://projects.haskell.org/pipermail/lhc/2008-November/000001.html
02:51:29 <lambdabot> Consider it noted.
02:56:45 <Ogedei> does the debian GHC package handle 'included' libraries (Date.Time, Parsec) in an unconventional way? I'm getting linking errors on those when building wxHaskell with its own makefile
02:58:12 <vegai> oh, bugger
02:58:43 <vegai> using Readline.readline seems to block all concurrently running threads
02:58:46 <vegai> can that be?
02:58:49 <sjanssen> Ogedei: parsec is not an 'included' library any more
02:58:55 <sjanssen> it hasn't been for quite some time
02:59:10 <Saizan> vegai: do you compile with -threaded?
02:59:18 <vegai> Saizan: ah, I don't.
02:59:19 <sjanssen> Ogedei: try installing libghc6-parsec-dev
02:59:20 <gerryxiao> hello
02:59:22 <Ogedei> sjanssen: so you need to explicitly link it?
02:59:33 <Ogedei> sjanssen: i have that installed, i can compile the hs files, but linking fails
02:59:37 <vegai> right. I'll add that.
02:59:48 <mib_2apyui> What happens when I don't call hs_add_root in a C program calling a Haskell function? The documentation seems to assume one compiles with GHC, since __GLASGOW_HASKELL won't be defined when compiling with gcc. When I use gcc -D__GLASGOW_HASKELL__ to compile, I get/usr/bin/ld: /tmp/ccKI1EzP.o(.text+0x23): unresolvable R_386_32 relocation against symbol `__stginit_somesymbol.
03:00:49 <mib_2apyui> If I don't define GHC hs_add_root will not be called by the C program. Is that a problem? Or is that how it should work?
03:00:51 <sjanssen> Ogedei: ah, that is a bit different.  It is possible the wxHaskell makefile fails to set a -package flag when linking
03:00:55 <gerryxiao> how to get it work on ghc:  let test= do { a<-get; retrun a}
03:01:19 <sjanssen> gerryxiao: first, spell return correctly
03:01:41 <gerryxiao> s/retrun/return
03:01:59 <Ogedei> sjanssen: it does set -package... let me look up the command
03:02:35 <sjanssen> gerryxiao: we don't have nearly enough context to help
03:02:54 <Ogedei> sjanssen: ghc -package containers-0.1.0.1 -o dist/wxdirect/wxdirect dist/wxdirect/MultiSet.o -o [etc]
03:03:01 <gerryxiao> type this on your ghc prompt, you will got errors
03:03:19 <gerryxiao> Ambiguous type variables
03:03:33 <sjanssen> Ogedei: what about for the final link?
03:04:01 <gerryxiao> need i add type annotation?
03:04:06 <Ogedei> sjanssen: it stops on that one (after ten screens of link errors, for stuff like timezm1zi1zi2zi0_DataziTimeziLocalTimeziLocalTime_zdf1_closure)
03:04:40 <vegai> Saizan: Yes, that was it, of course. Thank you.
03:05:10 <sjanssen> gerryxiao: you're probably running into the monomorphism restriction
03:05:28 <vegai> this is not good, about 95% of my functions are in IO
03:06:14 <gerryxiao> sjanssen:  add type annotation, it works
03:06:22 <gerryxiao> :: State Int Int
03:07:24 <gerryxiao> which linux distros best for haskell?
03:07:46 <luite> Arch?
03:07:51 <gerryxiao> i mean installing any haskell softs are easy
03:08:00 <osfameron> seems to work fine on ubuntu, though you have to compile a later ghc yourself if you want it
03:08:25 <gerryxiao> why ubuntu not update to ghc 6.10
03:08:44 <luite> ubuntu still has 6.8.2
03:08:46 <Saizan> once you've a cabal-install your distro doesn't matter much
03:09:00 <luite> but it's not that difficult to get 6.10.1 and cabal-install running
03:09:03 <osfameron> gerryxiao: probably because nobody has volunteered to regularly build a quality ghc package for ubuntu
03:09:25 <luite> using distro packages is a bit easier, mainly because of the non-haskell dependencies
03:09:45 <osfameron> and I guess they don't want the cutting edge package either, for compatibility etc.
03:10:06 <gerryxiao> i found  haskell packages in ubuntu repos scattered,
03:10:47 <gerryxiao> last time,i wanted to install hoogle, i can't get much deps,have to install them by hand
03:11:22 <gerryxiao> and  hoogle cabal build not work
03:11:33 <luite> gerryxiao: guess you need cabal-install
03:12:10 <gerryxiao> luite:   i can do:  runhaskell Setup build
03:12:30 <gerryxiao> but stop at : runhaskell Setup install
03:12:45 <gerryxiao> what's cabal-install?
03:13:36 <gerryxiao> and darcs is too slow
03:13:43 <luite> gerryxiao: something that lets you do: cabal install hoogle
03:13:46 <luite> and then: magic!
03:14:10 <gerryxiao> luite: it work on ubuntu?
03:14:19 <luite> gerryxiao: yes
03:15:14 <gerryxiao> where can i get it?
03:15:32 <titusg> I have a problem with cabal upgrade, hxt requires base >= 4 but there's no suitable version of base...?
03:15:50 <luite> gerryxiao: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
03:15:55 <lambdabot> Title: HackageDB: cabal-install-0.6.0, http://tinyurl.com/2sj7lw
03:16:12 <luite> gerryxiao: on ubuntu, you probably want to manually install ghc 6.10.1, and then cabal-install
03:16:28 <luite> at least, that's what I did :)
03:16:31 <gerryxiao> thx, i'm downloadingnow
03:18:11 <vegai> interesting points in the 32bit vs 64bit thread (masqueraded as Linux vs Windows thread)
03:18:32 <vegai> at what point do you have so much memory that it is beneficial to go 64bit given the double waste?
03:19:18 <gerryxiao> hmm, ghc 6.10.1?
03:19:18 <vegai> gerryxiao: also Arch hasn't updated to ghc-6.10 yet
03:19:29 <vegai> because it has some regressions and not all packages build with it yet
03:19:31 <titusg> hmm, I unregistered hxt because I don't need it, now it cabal upgrade complains about other packages
03:19:34 <vegai> it would just break too much
03:19:54 <gerryxiao> hoogle not work still on ghc 6.10.1
03:21:31 <gerryxiao> Setup: array.hoo: copyFile : does not exist
03:21:34 <gerryxiao> what's this
03:21:54 <gerryxiao> when i do : sudo runhaskell Setup install
03:22:46 <gerryxiao> in hoogle building
03:23:06 <gerryxiao> but array.hoo is there
03:23:49 <gerryxiao> anyone here ever install hoogle on ubuntu?
03:24:30 <gerryxiao> i can get it work, by move *.hoo to /usr/local/share/hoogle-x.x.x
03:24:42 <jtraub> :t concat
03:24:43 <lambdabot> forall a. [[a]] -> [a]
03:24:49 <titusg> so base is not a package and cabal can't upgrade it -- I'm using ghc 6.8.2 which gives me base-3.0.1 -- does the fact that cabal upgrade fails looking for a newer base mean the packages depend on newer ghc?
03:25:23 <gerryxiao> moment, i need reboot
03:26:46 <jtraub> @src concat
03:26:46 <lambdabot> concat = foldr (++) []
03:28:02 <Saizan> titusg: essentially yes
03:28:23 <titusg> I don't think cabal upgrade should fail if I have the latest versions of packages that will work with my compiler. If there are newer versions that depend on a newer compiler I don't care.
03:28:41 <titusg> Now I can't use cabal upgrade until I upgrade ghc
03:30:59 <Saizan> uhm so cabal upgrade should pick the most recent set of "installable" packages
03:31:23 <titusg> yeas, as if the ghc version was like a distro release for apt
03:31:26 <Saizan> where installable is limited by the availability of packages on hackage, like base
03:32:08 <jtraub> Please see http://hpaste.org/12349. Right now this code passes all tests, but i am concerned about a lot of duplicates
03:32:20 <jtraub> How can i remove it?
03:32:58 <Saizan> titusg: right now there isn't a connection between packages and the version of any compiler, and it's probably saner like this
03:34:31 <Saizan> jtraub: all those cases in toString are for using less parenteses?
03:36:02 <titusg> Saizan: probably, but it ties everyone to upgrading ghc which can be a lot of hassle. What if cabal just upgraded what it could?
03:36:56 <Saizan> that sounds reasonable to me, since it can detect what it can't upgrade by just looking at the packages
03:37:06 <titusg> Saizan: and there might be newer versions (but not latest) of some packages for which my base is OK
03:37:23 <jtraub> Saizan, yes. I have several tests about parenteses which my module should pass
03:37:39 <Saizan> the same applies to "cabal install foo" that should install the latest foo that can build on the system, rather than the latest available of failing
03:39:40 <Saizan> jtraub: i'd define a toString' that adds parentheses if the value is not Const or Var, and use that from Mult/Plus/Minus, having a single case for each one
03:39:50 <gerryxiao> what's the type of " do { a<-get; lift modify(3+); b<-lift get; return(a,b)}
03:40:37 <Saizan> titusg: you can file a ticket here -> http://hackage.haskell.org/trac/hackage/
03:40:38 <lambdabot> Title: Hackage - Trac
03:40:43 <gerryxiao> i will assign it to a var
03:41:09 <gerryxiao> in ghc
03:41:10 <jtraub> Saizan, i don't understand how can i do that. Can you just showme few lines?
03:41:17 <titusg> Saizan: thx. I am guessing the fact that base is just another dependency might make it hard to do.
03:41:25 <Twey> Hullo, jtraub
03:41:36 <Twey> Do I know you?  If not, which school/university do you attend?
03:41:38 <jtraub> Twey, hi :-)
03:41:45 <Saizan> gerryxiao: State Int (Int,Int), but you need to use lift (modify (3+))
03:41:50 <Saizan> titusg: why?
03:41:57 <Twey> Because I think I know one of your classmates if that's the case :-P
03:42:20 <Saizan> titusg: it might make it hard if we upload base to hackage i guess
03:42:30 <jtraub> Twey, i am not sure, because i am from Russian
03:42:42 <jtraub> Twey, Irkutsk :-)
03:42:50 <Twey> Aha
03:43:00 <gerryxiao> Saizan: i mean StateT
03:43:55 <Twey> jtraub: It's this exercise, isn't it?  http://dynamicdrive.com/forums/showthread.php?p=172247
03:44:06 <gerryxiao> StateT Int (State Int) Int?
03:44:15 <titusg> Saizan: maybe it wouldn't be so hard, I just thought it would be a bit hackish -- treating one "package", which isn't really a package, as special.
03:45:13 <jtraub> Twey, they look similiar
03:45:54 <Saizan> titusg: why special? it will just fail to find the required version, also it's really a package, but it's not generally updateable since it's tied to the compiler
03:46:29 <Saizan> jtraub: oh, it's a bit more complex than what i thought because of the toString (Mult a (Const b)) = toString a ++ "*(" ++ show b ++ ")" case
03:47:01 <Twey> jtraub: Where is the exercise from?
03:47:49 <jtraub> Twey, actully our teacher gave it to us on the paper
03:47:55 <jtraub> *actually
03:49:25 <Saizan> jtraub: so Mult (Var "x") (Const 1) should get printed as "x*(1)"?
03:49:50 <jtraub> Saizan, oops. No, of course not
03:50:46 <Scott66> Are there any good tutorials on writing parsers/interpreters/compilers in Haskell?
03:50:48 <jtraub> Saizan, it wasn't covered in tests :-)))
03:51:28 <Twey> jtraub: Aha, interesting
03:51:39 <Twey> Scott66: There's A Scheme in 24
03:51:57 <jtraub> Twey, where are you from?
03:52:02 <Twey> I'm told it's not so good, but it is a general introduction to the concepts
03:52:16 <Twey> jtraub: England, as is the other person with this exercise
03:52:25 <mikv> jtraub: test
03:52:46 <Twey> Scott66: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/parser.html
03:53:27 <jtraub> mikv, ??
03:53:36 <Saizan> jtraub: http://hpaste.org/12349#a1
03:54:15 <jtraub> Saizan, wow.  I don't know about @ yet :-)
03:54:23 <jtraub> I guess its time to read about it
03:54:28 <jtraub> Saizan, thanks
03:54:43 <Twey> jtraub: @ allows you to both break something down, and also refer to the whole
03:54:45 <jtraub> Twey, interesting. Are you student?
03:55:03 <Twey> No, I'm not
03:55:03 <titusg> Twey: BYAS is really good IMO
03:55:12 <Saizan> > let a@(x,y) = (1,2) in (a,x,y)
03:55:13 <lambdabot>   ((1,2),1,2)
03:55:40 <Twey> titusg: Let me guess, 'Build Yourself A Scheme'?  :)
03:55:43 <Saizan> > let a@(x,y) = (1,2) in ((x,y),x,y)
03:55:44 <lambdabot>   ((1,2),1,2)
03:55:57 <gerryxiao> i still can't figure out the type of : let test1 =  do { a<-get; lift modify(*3); b<-lift get ; return b} ::StateT Int (State Int) Int
03:56:02 <gerryxiao> any help?
03:56:15 <Twey> Uh
03:56:28 <gerryxiao> StateT Int (State Int) Int not work
03:56:38 <jtraub> Aha.. Is toString c@(Const _) = toString' c equal to toString (Const x) = toString' (Const x) ?
03:56:42 <Saizan> gerryxiao: "lift modify (3+)" can't work
03:56:50 <Saizan> jtraub: yes
03:56:50 <Twey> jtraub: Yes :)
03:57:28 <Scott66> Thanks.
03:57:28 <Saizan> gerryxiao: lift modify (3+) == (lift modify) (3+), but you want lift (modify (3+))
03:57:45 <jtraub> Twey, sscarface and you are from England. Sounds like
03:57:49 <gerryxiao> Saizan: great, problem is there
03:57:52 <Twey> jtraub: Aye
03:57:53 <gerryxiao> it now works
03:59:14 <gerryxiao> Saizan, i wrote it as lift modify(*3),  but it can't work
04:00:16 <gerryxiao> i have to type lift (modify(*3)) , a bit annoy
04:00:29 <Twey> lift $ modify (*3)
04:00:45 <Saizan> gerryxiao: lift modify(*3) is the same as lift modify (*3) the space doesn't matter there
04:00:57 <gerryxiao> Twen,  i dislike $ in haskell
04:01:17 <jtraub> Saizan, thank you very much for your help
04:01:20 <araujo> gerryxiao, why?
04:01:24 <gerryxiao> why use money symbol?
04:01:33 <araujo> why not?
04:01:38 <gerryxiao> hmm
04:01:39 <araujo> it is just other symbol
04:01:48 <Saizan> jtraub: np
04:02:14 <gerryxiao> other symbols are all better than $
04:02:38 <Twey> gerryxiao: Redefine it then
04:02:45 <araujo> gerryxiao, such as?
04:02:50 <Twey> (#) = ($) or whatever you feel like
04:02:52 <gerryxiao> Twey: how?
04:03:08 <gerryxiao> ok
04:03:15 <Twey> > let (#) = ($) in (*3) # (+1) 3
04:03:16 <lambdabot>   <no location info>: parse error on input `)'
04:03:19 <Twey> Is that valid?
04:03:20 <Twey> No
04:03:21 <Twey> :(
04:03:29 <Twey> Maybe not (#) then.  Something that isn't reserved.
04:03:34 <quicksilver> I think it's valid in haskell98
04:03:38 <osfameron> you have to set the precedence too?
04:03:39 <quicksilver> but GHC reserves #
04:03:41 <Twey> What's (#) used for?
04:03:45 <Twey> Ah
04:03:49 <gerryxiao> # better
04:03:53 <quicksilver> GHC reserves it as a generalised marker of an internal symbol
04:03:54 <osfameron> # would have been prettier than $
04:04:21 <titusg> I think the bikeshed should be blue
04:04:29 <araujo> hah
04:04:29 <titusg> :-)
04:04:47 * Twey chuckles.
04:06:10 <gerryxiao> lol
04:07:30 <titusg> ghc does unicode though doesn't it? never tried.
04:07:50 <quicksilver> yes, it does
04:08:04 <titusg> cool
04:08:50 <gerryxiao> Ghci> putStrLn "你好"
04:08:50 <gerryxiao> `}
04:08:50 <gerryxiao> it :: ()
04:09:14 <gerryxiao> unicode support in ghc seems bad
04:09:27 <quicksilver> GHC supports unicode
04:09:28 <titusg> I meant in function definitions, operators etc.
04:09:31 <quicksilver> putStrLn does not.
04:09:53 <quicksilver> putStrLn doesn't know what encoding to use
04:09:58 <quicksilver> so it just strips down to 8 bits
04:10:10 <Saizan> in short, you want utf8-string
04:10:57 <gerryxiao> any equivainent putStrLn functions
04:11:18 <hackage> Uploaded to hackage: obj 0.1.2
04:12:14 <quicksilver> gerryxiao: get the utf8-string package
04:13:31 <gerryxiao> ok, but i have to install it by hand in ubuntu
04:14:12 <titusg> I have been using agda a bit and quite like defining functions called ∈, ∅? etc :-)
04:15:01 <gerryxiao> oops, ubuntu have libghc6-utf8-dev package
04:16:05 <gerryxiao> hmm, i have installed it ,why not work?
04:16:53 <titusg> gerryxiao: how is it not working?
04:17:14 <gerryxiao> i cant output unicode chars
04:18:09 <gerryxiao> Ghci> 学习
04:18:09 <gerryxiao> <interactive>:1:0: lexical error at character '\23398'
04:19:31 <gerryxiao> Ghci> "学习"
04:19:32 <gerryxiao> "\23398\20064"
04:19:32 <gerryxiao> it :: [Char]
04:19:42 <Saizan> you've to use it
04:19:43 <gerryxiao> that's it
04:20:04 <papermachine> I hope we're studying Haskell, gerryxiao
04:20:16 <quicksilver> show will always express highbit chars in that portable 7-bit way
04:20:21 <quicksilver> that's a feature of show
04:20:42 <gerryxiao> papermachine: you mean that not haskell?
04:20:57 <papermachine> I was making fun of the choice of example.
04:21:21 <Saizan> gerryxiao: System.IO.UTF8.putStrLn "学习"
04:21:32 <gerryxiao> Saizan: ok
04:22:38 <gerryxiao> Saizan: it works
04:23:32 <gerryxiao> i need change putStrLn to this one
04:24:13 <quicksilver> you can just import System.IO.UTF8 instead of System.IO
04:24:20 <quicksilver> and then you get the UTF8-enabled version.
04:24:26 <gerryxiao> thx
04:25:05 <gerryxiao> why GHC not support utf8 by default?
04:26:54 <quicksilver> it does.
04:26:58 <quicksilver> as we explained.
04:27:06 <quicksilver> GHC supports utf8 by default for a couple of versions.
04:27:15 <quicksilver> It's just putStrLn (and other functions in the standard library) which don't.
04:27:25 <gerryxiao> oic
04:27:48 <jtraub> Saizan, sorry for nudging, but is there way to improve last 3 equations of simplify function in http://hpaste.org/12349
04:28:37 <quicksilver> gerryxiao: the reason they don't, is it's not obvious which encoding to use
04:28:46 <quicksilver> gerryxiao: "always utf8" is not obviously sensible
04:28:53 <quicksilver> mind you, no single choice is obviously sensibel
04:28:55 <quicksilver> :(
04:30:00 <gerryxiao> quicksilver: many other languages starndard libs use utf8 by default
04:30:12 <RayNbow> quicksilver: the world would be a better place though if everyone used the same encoding :p
04:30:56 <Saizan> jtraub: i don't see much room for improvement without modifying the Expr definition
04:31:00 <quicksilver> gerryxiao: I don't think that's true, actually.
04:31:04 <RayNbow> gerryxiao: care to give a few examples?
04:31:16 <quicksilver> gerryxiao: it would be very broken under windows if they did
04:31:21 <jtraub> Saizan, thanks a lot
04:31:23 <quicksilver> (the windows system encoding is utf16, as I understand it)
04:31:45 <gerryxiao> .net   java
04:31:52 <quicksilver> most other languages have a way to explicitly choose the encoding.
04:31:59 <RayNbow> gerryxiao: Java doesn't use UTF8 by default
04:32:28 <jtraub> Saizan, but it lookeed to me that Haskell has a way for generalizaton in such cases.
04:33:58 <arw_> java does use unicode in its sourcecode by default, at least the spec says so.
04:34:28 <ToRA|MSR> for output (e.g. printwriter etc) java uses the system charset by default
04:34:39 <arw_> they don't define which encoding. and eclipse ignores any of those specs anyways, so sometimes you get iso8859-* java out of it.
04:34:47 <ToRA|MSR> but obviously there are ways of selecting your own charset
04:35:25 <ToRA|MSR> java natively is utf-16 (from java.nio.charset.Charset docs)
04:35:36 <gerryxiao> it should deps on  platform i'm using
04:36:28 <arw_> not really. it uses utf-16 internally, only input and output are platform-dependent. same in perl.
04:36:30 <Saizan> jtraub: even if a bit bruteforce it cuts down repetition: http://hpaste.org/12349#a2
04:36:46 <gerryxiao> if i use chinese, it  should support chinese
04:37:29 <gerryxiao> Saizan:  r u chinese or know chinese?
04:37:44 <Saizan> gerryxiao: no to both
04:37:54 <PeakerWork> does it make sense for Reactive to export a type for events that fire once?  Or is Future already exported?
04:38:11 <gerryxiao> your name like chinese name
04:38:42 <Saizan> jtraub: one usually defines a fold for the Expr datatype, or use generics
04:38:56 <PeakerWork> dolio: http://netsuperbrain.com/blog/posts/why-is-the-reactive-behavior-tutorial-taking-so-long-splitb/ is yours, right?
04:39:00 <lambdabot> Title: Less Sugar/More Meat » Blog Archive » Why is the Reactive Behavior tutorial ta ..., http://tinyurl.com/5ohlyn
04:39:35 <jtraub> Saizan, thanks. I am trying to understand your code :-)
04:39:54 <jtraub> :t cycle
04:39:55 <lambdabot> forall a. [a] -> [a]
04:40:04 <jtraub> >cycle [1,2,3]
04:40:23 <jtraub> > cycle [1,2,3]
04:40:25 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
04:40:33 <jtraub> ooops
04:41:09 <RayNbow> @seen camio
04:41:09 <lambdabot> I saw camio leaving #haskell 8h 13m 40s ago, and .
04:41:43 <jtraub> > drop 2 $ cycle ['a'..'z']
04:41:44 <lambdabot>   "cdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwx...
04:42:19 <jtraub> > zip ['a'..'z'] (drop 2 $ cycle ['a'..'z'])
04:42:21 <lambdabot>   [('a','c'),('b','d'),('c','e'),('d','f'),('e','g'),('f','h'),('g','i'),('h'...
04:43:21 <osfameron> @pl \a -> zip a (drop 2 $ cycle a)
04:43:21 <lambdabot> ap zip (drop 2 . cycle)
04:44:29 <osfameron> >  zip `ap` (drop 2 . cycle) $ ['a'..'z']
04:44:30 <lambdabot>   [('a','c'),('b','d'),('c','e'),('d','f'),('e','g'),('f','h'),('g','i'),('h'...
04:44:43 <osfameron> why doesn't that work for me?  (with +Control.Monad)
04:47:07 <osfameron> i.e. I get No instance for (Monad ((->) [Char])  arising from use of `ap' at <interactive>:1:0-24  in ghci
04:47:07 <Saizan> osfameron: you need Control.Monad.Instances or .Reader
04:47:14 <osfameron> ah
04:47:32 <osfameron> hurray
04:56:30 <PeakerWork> @type ap
04:56:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:18:15 <xenoblitz> guys is it possible to have something of this form: http://hpaste.org/12350 so as to have a function with different ... arity? I know the code is wrong... I just want to know if i can make a function have differing arity depending on need
05:19:02 <xenoblitz> quicksilver: if you are listening... the approach you suggested a few days ago works but sadly its not what I was looking for
05:19:41 <Saizan> @source Text.Printf
05:19:41 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
05:19:53 <ivanm> xenoblitz: was quicksilver's approach to use records?
05:20:23 <xenoblitz> ivanm: no he suggested something based on what I was trying to do back then but he said its not correct functional programming
05:20:46 <ivanm> xenoblitz: ahhhhh
05:20:50 <lilac> xenoblitz: http://hpaste.org/12246
05:20:58 <Saizan> xenoblitz: look at PrinfType there ^^^ to implement variadic functions
05:21:17 <ivanm> IIRC, ndm had a blog post a while back talking about variable number of parameters using records
05:21:19 <byorgey> xenoblitz: can I ask what your use case is?
05:21:51 <ivanm> basically, you have a record with a field for each possible argument, possibly set to something like Nothing by default
05:22:08 <xenoblitz> lilac: yes that's similar to what quicksilver had suggested but its a bit advanced for me :P
05:22:24 <lilac> xenoblitz: it's probably not the 'right' solution to your problem, either
05:22:27 <xenoblitz> saizan: i'll take a look
05:22:37 <xenoblitz> byorgey
05:23:03 <Saizan> xenoblitz: variadic functions will necessarily be "advanced", you've to hack the type system basically :)
05:23:04 <xenoblitz> byorgey: the context is simulating something with a circuit with 1-6 different input, depending on the circuit itself
05:25:06 <xenoblitz> i guess I have to write two type classes
05:25:10 <xenoblitz> and derive one from the other
05:25:20 <xenoblitz> a simulate for just a wire for example
05:25:32 <xenoblitz> and another simulate for circuits with parameters which are tuples of wire
05:25:46 <SamB> why ?
05:26:31 <xenoblitz> i can't figure out a way to make simulate have type a -> Bool and a -> (a->b) -> Bool
05:27:02 <Saizan> a -> (a -> b) -> Bool isn't what you want
05:27:37 <vegai> many socket programming examples convert the Socket to a Handle before doing stuff with it
05:27:52 <vegai> I was wondering... if I do that and just close the socket, is that enough?
05:28:04 <vegai> or do I need to explicitly close the Handle as well? Or just one of them?
05:28:07 <xenoblitz> Saizan: why not? I need example... Wire -> (Wire -> Wire) -> Bool or ﻿(Wire,Wire) -> ((Wire,Wire) -> Wire) -> Bool ﻿or ﻿(Wire,Wire, Wire) -> ((Wire,Wire, Wire) -> Wire) -> Bool ... up to tuples of 6 Wires
05:28:23 <xenoblitz> but also the basic case
05:28:26 <xenoblitz> Wire -> Bool
05:28:29 <xenoblitz> for simulate
05:28:51 <vegai> ah. *Now* I see in the docs that they recommend not using the socket after that for anything
05:30:29 <byorgey> xenoblitz: how could you have a function as an input to a circuit?
05:30:56 <xenoblitz> byorgey: no its the circuit that is the function
05:31:00 <byorgey> seems to me that every circuit would be of type  [Wire] -> Bool
05:31:20 <byorgey> xenoblitz: yes, but from the point of view of the next circuit it is just a wire.
05:31:42 <byorgey> I am trying to understand why you would want the type Wire -> (Wire -> Wire) -> Bool.
05:31:53 <xenoblitz> let me give you an example
05:31:59 <Saizan> xenoblitz: simulate for functions is just going to apply the function to the tuples, no?
05:32:13 <xenoblitz> Saizan: yes
05:32:32 <xenoblitz> its just a wrap around of just using simulate $ orgate true false
05:32:38 <byorgey> aha
05:33:02 <xenoblitz> byorgey making the type [Wire] -> Bool is kind of toooo open for mistakes
05:33:13 <byorgey> xenoblitz: well, sure.
05:33:25 <byorgey> that was just a simple example.
05:34:04 <byorgey> xenoblitz: so it sounds like simulate should have type  a -> (a -> Wire) -> Bool
05:34:04 <Saizan> so you want both "simulate orgate true false" and "simulate true" to work
05:34:10 <xenoblitz> yes
05:34:13 <xenoblitz> that's the idea
05:34:18 <byorgey> and you can make a type class instance for each different tuple of Wires that you want
05:34:20 <xenoblitz> wow i can't explain myself well :P
05:34:25 <xenoblitz> yes
05:34:31 <Saizan> so, why not use the old code i gave you?:)
05:34:39 <xenoblitz> the printf?
05:34:42 <byorgey> class Simulate a where  simulate :: a -> (a -> Wire) -> Bool
05:34:53 <byorgey> instance Simulate (Wire,Wire) where ...
05:34:55 <byorgey> and so on
05:35:15 <Saizan> no, the one of the other day
05:35:52 <Saizan> http://hpaste.org/12297#a2
05:36:24 <xenoblitz> ah yes I was refering to this when i said quicksilver... sorry lol but you two guys are always helping me and I mix you up!
05:37:10 <Saizan> ah ok :)
05:37:11 <xenoblitz> Saizan: so there is no simpler way than this... i just don't like to use extensions as much as possible :/
05:37:45 <Saizan> xenoblitz: unless you can tolerate simulate () true instead of simulate true
05:38:04 <xenoblitz> i was thinking about that
05:38:27 <Saizan> actually, text.printf is haskell98, so we could borrow from that
05:39:06 <byorgey> I think simulate () true is what you want.
05:39:41 <xenoblitz> byorgey: i think that's one possible solution yes
05:39:49 <SamB> personally I would go for simulate true ()
05:39:52 <xenoblitz> saizan: which part are you refering to in text.printf
05:39:58 <byorgey> seems the least painful option to me.
05:42:01 <shearn89> hey all - i've been getting an error about constructing an infinite type - if i pastebin could you guys take a look?
05:42:24 <Saizan> xenoblitz: looking better Text.Printf doesn't really apply, PrintfType doesn't take a function like your simulate does
05:42:35 <byorgey> shearn89: sure
05:42:45 <xenoblitz> saizan: too bad :/ but thats all the same
05:42:50 <xenoblitz> to all: thanks :)
05:42:55 <shearn89> byorgey: kk. relevant code is http://pastebin.com/m206f9891, error is http://pastebin.com/d14150b95
05:43:05 <xenoblitz> I will go for the simulate () true one
05:43:23 <engelmaus> Hello!
05:43:47 <engelmaus> Could anyone tell me, what the error Main.o:(.text+0x143): undefined reference to `__stginit_* means at linking time?
05:44:05 <engelmaus> where * stands for some module names?
05:44:07 <Saizan> engelmaus: pass --make to ghc
05:44:31 <engelmaus> Ah, seems to work.
05:44:40 <engelmaus> Why do i have to do so?
05:44:49 <BONUS> thats for linking
05:44:59 <Saizan> so that ghc links in the libraries you use
05:45:00 <BONUS> so it looks up the imports again and identifies them properly
05:45:02 <xenoblitz> it looks for the files you need
05:45:06 <Jedai> engelmaus: So that ghc search for the necessary package by himself
05:45:25 <engelmaus> Ok. Thank you.
05:45:31 <Jedai> engelmaus: You could specify them manually but --make is pretty nice
05:45:49 <engelmaus> What would it be manually?
05:45:58 <engelmaus> I tries to pass the .hs files on command line.
05:46:05 <Jedai> engelmaus: sometimes you want to link against a certain version (not the most recent) of a package and you can't use --make
05:46:35 <Jedai> engelmaus: ghc -package=ghc-6.8.1 MyProgram.hs
05:46:36 <Saizan> ghc -package foo -package bar ... Main.hs
05:46:48 <engelmaus> ah, ok.
05:47:31 <shearn89> can you guys help with this error? http://pastebin.com/d14150b95
05:47:44 <byorgey> shearn89: what's that type annotation on the end of line 12 for?
05:47:53 <byorgey> seems strange to me
05:47:57 <shearn89> byorgey: cut and paste error.
05:48:14 <shearn89> should be the line below...
05:48:24 <shearn89> ^^ http://pastebin.com/d45bc6a1
05:48:58 <byorgey> shearn89: aha, ok
05:49:09 <byorgey> shearn89: delta returns a [q]
05:49:19 <byorgey> but acceptsFrom expects a q as its second argument
05:49:35 <shearn89> byorgey: okay, so acceptsFrom should be modified to take [q]?
05:49:42 <mib_0mjki6> Hello, I'm trying to use Text.Regex.Posix.Wrap to do case-insensitive matching without success so far.  Could anybody point me to an example? Thanks ...
05:49:42 <byorgey> shearn89: probably not
05:49:59 <shearn89> hmm. Its all because its a non-deterministic fsm. grr.
05:50:15 <byorgey> shearn89: I'm guessing you want to map acceptsFrom over the q's returned by delta, and then take the 'or' or 'and' of the results
05:50:18 <byorgey> probably 'or'
05:50:40 <shearn89> ah - that would work, as some of the q's return [] on the next transition.
05:50:45 <byorgey> i.e. the FSM accepts from the given state if it accepts from *any* of the states it can transition to
05:50:53 <shearn89> yeah.
05:51:34 <shearn89> so code: map (\q -> delta m q x) listofq?
05:51:50 <byorgey> yup
05:51:57 <shearn89> cool. i'll check and get back to you...
05:52:08 <byorgey> shearn89: the 'or' function will be useful too
05:52:10 <byorgey> @type or
05:52:11 <lambdabot> [Bool] -> Bool
05:52:52 <shearn89> kk. give me a minute or two.
05:52:54 <Saizan> it's acceptsFrom that you've to map over the result of delta, no?
05:52:55 <byorgey> shearn89: you could also use 'any', which combines an 'or' and a 'map'
05:52:57 <byorgey> @type any
05:52:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:53:03 <byorgey> shearn89: sure, have fun =)
06:01:29 <shearn89> hmm. new code is http://pastebin.com/d3b97ef3d. Same error tho :-(
06:03:15 <byorgey> shearn89: oh, you changed acceptsFrom to take a [q] as its second argument?
06:03:36 <shearn89> is that wrong? given that i'm giving it a list?
06:04:07 <byorgey> no, it's not necessarily wrong, it's just not what I thought you were going to do =)
06:04:12 <byorgey> give me a minute to look at it again
06:06:11 <byorgey> shearn89: ok, you're almost there.  The problem now is that in line 13,  qlist :: [q], so (map (\q -> delta m q x) qlist) :: [[q]]
06:06:21 <byorgey> that is, it gives you a list of q's for each of the q's in qlist
06:06:28 <byorgey> so, you get a list of lists of q's
06:06:37 <byorgey> but you need to turn that list of list of q's into a list of q's
06:06:48 <shearn89> okay. a simple where the [x] = x, then?
06:07:12 <byorgey> shearn89: I don't understand what you mean.
06:07:52 <shearn89> as in define an aux function "> the qlist > where > the [x] = x"
06:08:16 <byorgey> oh, I see what you mean.  no, that won't work
06:08:29 <byorgey> if you have  'the [x] = x' that will only work on one-element lists.
06:08:46 <byorgey> shearn89: there is already a function in the standard libraries to turn a list of lists into a list, do you know it?
06:08:55 <shearn89> oh, know. that would be much easier.
06:08:58 <shearn89> *no
06:09:03 <byorgey> @type concat
06:09:04 <lambdabot> forall a. [[a]] -> [a]
06:09:14 <shearn89> ah yeah. awesome.
06:09:21 <BeelsebobWork> shearn89: for a start, have a cleaned up version in a pastebin which does Haskell syntax highlighting http://hpaste.org/12352
06:09:27 <BeelsebobWork> but what's the error you're getting?
06:09:39 <byorgey> BeelsebobWork: I think shearn89 has it figured out now
06:09:50 <BeelsebobWork> ah, k
06:10:02 <byorgey> BeelsebobWork: it was an infinite type error, using a [[q]] where it was expecting a [q]
06:10:05 <shearn89> BeelsebobWork: thanks for the hpaste link tho, very useful.
06:10:23 <shearn89> awesome! it works! thanks so much guys.
06:10:41 <byorgey> shearn89: great!
06:10:53 <BeelsebobWork> in fact, here's some more cleaning up... http://hpaste.org/12352#a1
06:10:56 <BeelsebobWork> also, yay, win!
06:11:10 <byorgey> BeelsebobWork: \q -> delta m q x  is not the same as delta m x.
06:11:25 <BeelsebobWork> byorgey: it is if you happen to swap some arguments around in delta ;)
06:11:41 <BeelsebobWork> oh, I forgot to swap the type sig around though
06:11:44 <byorgey> BeelsebobWork: sure, but... it looks like you didn't? =)
06:11:50 <shearn89> wicked. cheers guys.
06:11:53 <BeelsebobWork> I did -- but not the type sig
06:11:53 <byorgey> oh, hehe
06:11:56 <byorgey> right
06:12:11 <BeelsebobWork> http://hpaste.org/12352#a2 <-- that's better
06:13:08 <shearn89> right. back to work, and on with the project...
06:13:15 <byorgey> shearn89: have fun
06:13:18 <shearn89> will do...
06:19:04 <Twey> So, what's a good refactoring method when your code starts looking like: evaluate (ReOpEx "+" (ValueEx (PrimV (Number a))) (ValueEx (PrimV (Number b)))) = return $ PrimV (Number (a + b))
06:19:26 <saml> evaluate (parse expr)
06:19:46 <BeelsebobWork> it's a pattern match saml
06:20:00 * saml fails
06:20:10 <Twey> saml: It's been parsed, it's just that the AST ends up a little complicated and leads to deep pattern matches
06:20:15 <BeelsebobWork> Twey: I'd probably say "refactor your data type"
06:20:25 <Twey> Mm, yes
06:20:29 <Twey> That sounds like a good idea
06:20:33 <BeelsebobWork> so you have an App node
06:20:55 <BeelsebobWork> that can get evaluated as (evaluate a) (evaluate b)
06:21:04 <BeelsebobWork> i.e. evaluating a function actually returns a Haskell function
06:21:17 <Raevel> haha, oh my, dcoutts are you there?
06:22:36 <Twey> BeelsebobWork: This is what I've got at the moment: http://hpaste.org/12353
06:23:00 <Twey> The idea being that the parsing module takes a string and returns an Expression, then the evaluation module turns that Expression into a Value
06:23:04 <BeelsebobWork> Twey: is this an existing language, or one you have control over?
06:23:12 <Twey> No, it's mine
06:23:23 <sbahra> Anyone here with a box that has GHC-6.10 willing to provide me an account on their system?
06:23:41 <Raevel> @tell dcoutts so, it turns out that the problem with happy not being found in my path was because i ran cabal-install as root, and my ~/.cabal/bin was not in root's path. :-)
06:23:41 <lambdabot> Consider it noted.
06:23:55 <BeelsebobWork> Twey: well, I'd replace your application nodes with a single :$: node
06:24:02 <BeelsebobWork> with a function on the left
06:24:10 <BeelsebobWork> and a something on the right
06:24:25 * Twey fails to follow.
06:24:29 <Twey> Sorry, example?
06:25:39 <Twey> Oh!
06:25:40 <BeelsebobWork> start from lambda calculus is essentially what I'm saying -- data Expr = Var String | Lit Value | Abs String Expr | Expr :$: Expr
06:26:08 <BeelsebobWork> (note, lit isn't strictly necessary, but makes it as powerful as what you have atm)
06:26:17 <saml> what's PaOpEx and ReOpEx?
06:26:27 <ski_> (Twey : is there a reason you don't have something like `evaluate (ReOpEx "+" e0 e1) = return $ PrimV (Number (a + b)) where ...' with two recursive calls to evaluate `e0' and `e1' ?)
06:26:37 <tobsi> can i tell cabal that i want to install an old version of a package?
06:26:38 <Twey> Unary and binary operators (saml)
06:26:53 <Twey> BeelsebobWork: Hmm
06:26:55 <BeelsebobWork> Twey: all you need is unary
06:27:04 <mornfall> tobsi: cabal install 'package < current', eg.
06:27:06 <BeelsebobWork> then you even get partial application thrown in for good measure
06:27:13 <mornfall> tobsi: Or maybe '<= what-you-want'
06:27:17 <tobsi> aha
06:27:23 <tobsi> thanks
06:27:24 <Twey> BeelsebobWork: Then what goes on when parsing an infix operator?
06:27:55 <Twey> It parses to something like (Operator "+") :$: (TwoOperands a b)?
06:28:18 <ski_> Operator "+" :$: Operand a :$: Operand b  -- probably
06:28:28 <BeelsebobWork> nope (Var "+") :$: (parsedExpression) :$: (parsedExpression2)
06:28:33 <Twey> Oh, I see!
06:28:41 <BeelsebobWork> (with left associative :$:)
06:28:42 <byorgey> currying ftw!
06:28:44 <ski_> (depends on whether you want to get curried or not, i suppose)
06:28:47 <Twey> That's interesting
06:29:12 <BeelsebobWork> yeh, the alternative would be (Var "+") :$: (PairExr parseExpression parsedExpression2)
06:29:17 <BeelsebobWork> PairExp*
06:29:36 <Twey> Yes, but that's horrible :)  Yours is nicer
06:29:40 <BeelsebobWork> indeed ;)
06:29:43 <ski_> (.. or a multi-arg application)
06:30:23 <ski_> (`App (Var "+") [parsed0,parsed1]')
06:31:15 <saml> right with :$:, how would you check for arity?
06:31:34 <BeelsebobWork> the type checker would deal with it ;)
06:31:50 <BeelsebobWork> "couldn't match type a -> b against SomeType"
06:32:39 <Twey> Then how would that look when I went to evaluate it?
06:32:58 <BeelsebobWork> evaluate (f :$: a) = (evaluate f) (evaluate a)
06:33:01 <ski_> (`data TypedExpr :: * -> *; (:$:) :: TypedExpr (a -> b) -> (TypedExpr a -> TypedExpr b); ...' ..)
06:33:12 <Twey> But f could evaluate to a non-function, right?
06:33:27 <Twey> I guess that's where the type error kicks in?
06:33:28 <BeelsebobWork> well, Haskell's type system isn't gonna let you do that
06:33:28 <ski_> evaluate (f :$: a) = evaluate f `apply` evaluate a
06:33:38 <BeelsebobWork> or yes, you can write your own apply
06:33:42 <ski_> Closure ... `apply` x = ...
06:34:09 <Twey> Oh dear oh dear
06:34:11 <Twey> Right-ho :)
06:34:13 * Twey starts again.
06:34:19 <BeelsebobWork> hehe
06:34:29 <BeelsebobWork> getting language evaluation right is something that takes some time
06:35:28 <Twey> Uhm, I should probably know this, but what's an Abs?
06:35:45 <Twey> Aye
06:35:58 <BeelsebobWork> an abs is an abstraction
06:36:19 <BeelsebobWork> an example... (Abs "x" (Var "x"))
06:36:20 <Twey> What's the first parameter for?
06:36:21 <BeelsebobWork> that's \x -> x
06:36:31 <BeelsebobWork> it's the variable that gets bound by the abstraction
06:36:38 <ski_> <http://barzilay.org/images/CS212/cs212a.jpg> Eval and Apply
06:36:44 <BeelsebobWork> so (Abs "y" (Var "x")) is \y -> x
06:36:58 <Twey> Hmm
06:37:12 <Twey> I see
06:37:36 <BeelsebobWork> so apply will look something like (Abs "x" exp) `apply` arg = substitute "x" arg exp
06:37:36 <Twey> And because of currying, \x y -> z is (Abs "x" (Abs "y" (Var "z")))?
06:37:45 <BeelsebobWork> yep, exactly
06:38:07 <Twey> My language, however, isn't pure
06:38:27 <BeelsebobWork> well, make sure apply really does apply things in the right order then
06:38:32 <ski_>   Abs (PPair (PVar "x") (PVar "y")) (EVar "z")
06:38:38 <BeelsebobWork> and your environment will have rather more in it than normal
06:38:56 <BeelsebobWork> yeh, ski_'s is the uncurried version
06:39:07 <ski_>   \(x,y) -> z
06:39:08 <BeelsebobWork> or possibly just the concrete syntax version
06:39:24 <Twey> Mmm
06:39:41 <Twey> Expr is meant to be concrete syntax, y'see
06:39:50 <ski_> ?
06:39:50 <BeelsebobWork> ah, then add another pass
06:40:08 <BeelsebobWork> makeAbstractSyntax :: CST -> AST
06:40:08 <ski_> the concrete syntax is surely the strings ?
06:40:12 <Twey> As in, it also handles things like { someExprForKey() : someExprForVal() } which I don't want to be evaluated on parsing
06:40:47 <BeelsebobWork> ski_: well, yes and no, one could parse the string \x y -> z into Abs ["x", "y"] (Var "z")
06:40:56 <BeelsebobWork> i.e. exactly as it appears in the program
06:41:02 <BeelsebobWork> and then do another pass to sort out currying
06:41:16 <BeelsebobWork> (amongst other things)
06:41:41 <ski_> (i'd say that `Abs ["x", "y"] (Var "z")' is one abstract syntax, close to the concrete one ..)
06:42:03 <BeelsebobWork> okay, we have subtly different defs of abstract syntax
06:42:19 <BeelsebobWork> I regard concrete syntax as something from which the exact original program can be reserected
06:42:31 <ski_> ok
06:42:35 <BeelsebobWork> while abstract syntax is something from which only a program with the same meaning can be created
06:42:58 * Twey was working with BeelsebobWork's definition.
06:43:02 <ski_> ic
06:43:15 <BeelsebobWork> so yeh, Twey, if you're parsing to a CST, add another pass
06:43:20 <BeelsebobWork> to transform the CST into an AST
06:43:34 <saml> what's a good haskell opengl tutorial?
06:43:45 <Twey> But how do I handle things that are 'not to be evaluated yet'?  I can't really see how that fits into the datatype given above?
06:43:50 <grul> how do you check if all items of a list are of a certain type?
06:44:00 <BeelsebobWork> Twey: I'm not sure what you mean by that
06:44:00 <saml> grul, there's no other way
06:44:05 <saml> > [1,"a"]
06:44:07 <lambdabot>       No instance for (Num [Char])
06:44:07 <lambdabot>        arising from the literal `1' at <in...
06:44:18 <grul> oh
06:44:27 <BeelsebobWork> evaluation order is entirely down to what your evaluate function specifies Twey
06:44:38 <ski_> > [(2,3),'4']
06:44:39 <lambdabot>   Couldn't match expected type `(t, t1)' against inferred type `Char'
06:44:41 <BeelsebobWork> (you can add strictness anotations if you really do want things to be strict, which I suspect you do)
06:44:47 <Twey> BeelsebobWork: For example, an object literal: { a() : b() }
06:45:07 <ski_> Twey : what's `a' and `b' ?
06:45:21 <Twey> ski_: Functions of some sort (impure)
06:45:37 <Twey> In other words, { <impure expression> : <impure expression> }
06:45:44 <ski_> is this a kind of pair ?
06:45:45 <BeelsebobWork> Twey: yep, so that would be parsed into a Lit (Object [("a", rhsGoesHere),("b", rhsGoesHere)])
06:45:52 <Twey> Something like that
06:45:54 <Twey> Ohh
06:45:58 <Twey> Hm
06:46:00 <BeelsebobWork> and then you'd need to add that to an environment at the appropriate moment
06:46:14 <BeelsebobWork> (when it's in scope)
06:46:27 <Twey> BeelsebobWork: But if Object is a Value, then wouldn't it need to be evaluated fully there?
06:46:29 <ski_> (or maybe you meant to have "fields/methods" for `a',`b' with corresponding bodies/values, there ?)
06:46:39 <BeelsebobWork> Twey: no?
06:46:44 <Twey> ski_: No, just an expression
06:47:43 <Twey> BeelsebobWork: So I would have Exprs contained within some of my Value types?
06:48:17 <BeelsebobWork> I don't see why not
06:48:23 <ski_> would `rhsGoesHere' be an `Expr' ?
06:48:27 <Twey> I see
06:48:29 <BeelsebobWork> yep
06:48:40 <ski_> (so you have a kind of closure, then)
06:48:41 <BeelsebobWork> or a list of statements, as you appear to be going imperative
06:49:03 <Twey> Kind of
06:49:41 <Twey> Hmm, OK, that seems workable
06:49:42 <Twey> I'll give it a shot :)
06:49:42 <Twey> Thanks!
06:51:17 <saml> @hoogle initialDisplayMode
06:51:18 <lambdabot> No results found
06:54:31 <eipi> hi, what should we do when "cabal list" terminates with "cabal: Couldn't read cabal file ".\\Glob\\0.1\\Glob.cabal"?
07:05:45 <Twey> Oh dear
07:06:02 <Twey> BeelsebobWork: Thing is, then I end up with two different Object types — one evaluated and one unevaluated
07:06:13 <BeelsebobWork> Twey: I don't follow
07:06:31 <BeelsebobWork> the functions in an object are syntax, there's no evaluation to do on them
07:06:38 <BeelsebobWork> (until you come to applying them)
07:07:46 <Twey> BeelsebobWork: Nay.  OK, a bit more background: I have an object literal, of the form { a : b, c : d }, where a and c are expressions which, when evaluated, yield keys, and b and d are expressions which, when evaluated, yield values/members
07:08:05 <BeelsebobWork> I'm not sure I follow
07:08:17 <BeelsebobWork> a and c are the names of the variables bound in the object?
07:08:41 <Twey> No, a, b, c, and d are all expressions to be evaluated, which will yield their respective values
07:08:50 <Twey> (impure)
07:09:02 <BeelsebobWork> oh, is this a super-dynamic language where an object is just a dictionary?
07:09:07 <Twey> Aye
07:09:11 <Twey> Sorry, didn't make that clear :)
07:09:14 <BeelsebobWork> no probs
07:09:45 <BeelsebobWork> in that case, yes, you need to make it clear whether the object's contents have been evaluated or not
07:09:50 <BeelsebobWork> in a strict language, this is easy
07:10:02 <BeelsebobWork> when the object gets created, you evaluate them
07:10:16 <BeelsebobWork> in a lazy language, this is harder, if you don't want tags ending up all over the place
07:10:17 <Twey> Aye, that's what I intend to do
07:10:19 <Twey> But the issue is with the types
07:10:59 <BeelsebobWork> which, the strict or latter version?
07:11:02 <Twey> If I pack it into a Lit Object, then that Object needs to be a Map Expr Expr instead of a Map String Value
07:11:05 <Twey> Strict
07:11:14 <BeelsebobWork> oh no
07:11:21 <BeelsebobWork> if it's strict, then it's Map String Value
07:11:34 <BeelsebobWork> and you "evaluate" the Exprs you get, when you create the object
07:11:46 <Twey> But then I can't have that in my syntax tree
07:12:18 <Twey> Because until evaluated, they aren't Strings and Values, they're just Exprs, so I can't represent it with a Lit Object
07:12:29 <BeelsebobWork> nope -- another reason why you need multiple passes between concrete syntax and abstract syntax
07:12:58 <thomashartman1> how do I create a value of type Word8? I don't understand this dodumentation
07:13:01 <BeelsebobWork> going from Map Expr Expr to Map String Value would be part of going from CST to AST
07:13:02 <thomashartman1> Constructors
07:13:03 <thomashartman1> W8# Word#
07:13:12 <thomashartman1> (from GHC.Word)
07:13:13 <BeelsebobWork> > (5 :: Word8)
07:13:14 <lambdabot>   5
07:13:19 <thomashartman1> danke
07:13:22 <Twey> BeelsebobWork: But going from Map Expr Expr to Map String Value involves actual evaluation
07:13:30 <BeelsebobWork> yep
07:13:33 <Twey> For example, the object could be { "foo"
07:13:35 <Twey> Gah
07:13:39 <BeelsebobWork> so actually yes
07:13:43 <BeelsebobWork> that should come after the AST
07:14:00 <Twey> For example, the object could be { "foo" + "bar" : "baz" } and the end result is an Object { "foobar" : "baz" }
07:14:10 <BeelsebobWork> the first stage of your evaluator should be to evaluate objects, and stick them into the environment
07:14:26 <Twey> So I can't put it in a Lit?  It needs to have its own Expr constructor?
07:14:43 <BeelsebobWork> well, "foo" + "bar" *isn't* a lit
07:14:47 <BeelsebobWork> it's an application of +
07:14:52 <Twey> True
07:31:02 <thomashartman1> What does #haskell think of this module for securely storing passwords in webapps? http://hpaste.org/12359
07:31:13 <thomashartman1> seem ok?
07:34:10 <thomashartman1> enh, I'm getting impatient and will post to haskell cafe ;)
07:36:00 <sbahra> thomashartman1, terrible bug!
07:39:40 <thomashartman1> whhaat?
07:40:08 <thomashartman1> does my code suck?
07:41:03 <thomashartman1> I gotta go, if there's thoughts on this password stuff you can answer my moment-ago post on haskell cafe.
08:11:18 <hackage> Uploaded to hackage: checkers 0.1.2
08:13:05 <thomashartman1> Does anybody know what the pros and cons are of bsd3 versus
08:13:05 <thomashartman1> 		 gnu? eelco just asked me to switch my license to bsd3 when I
08:13:08 <thomashartman1> 		 included a file of his in a hackage
08:13:26 <thomashartman1> Of course I will do so, I'm just curious what the pros and cons are.
08:13:54 <Zao> thomashartman1: One doesn't force you to release everything that even remotely touches the code.
08:14:39 <thomashartman1> bsd3 is the more permissive?
08:15:26 <Zao> http://www.freebase.com/view/guid/9202a8c04000641f8000000005bcdcef
08:15:27 <lambdabot> http://tinyurl.com/6n9sm3
08:15:32 <Zao> BSD3 is the more sane one, yes.
08:15:36 <quicksilver> thomashartman1: BSD3 allows anyone to do whatver they like.
08:15:49 <Zao> quicksilver: Almost. :)
08:15:49 <quicksilver> thomashartman1: GNU requires people who make modified versions of your code to release the source.
08:15:57 <quicksilver> close enough, though.
08:16:07 <Zao> quicksilver: Or link against your GPL code.
08:16:15 <Zao> Unless you lads are talking about LGPL.
08:16:15 <quicksilver> the GNU license is perfectly sane, but may not reflect what you want.
08:16:58 <nominolo`> @seen swiert
08:16:58 <lambdabot> I saw swiert leaving #haskell 23h 58m 40s ago, and .
08:18:29 <earthy> quicksilver: no it doesn't
08:18:49 <earthy> GNU requires people who *distribute* modified versions of your code to release their sources
08:18:56 <quicksilver> indeed.
08:19:12 <quicksilver> I was giving a fairly brief summary and as such it was inadequate.
08:19:27 <earthy> they can use the modifications themselves for all they want without showing anyone those modifications
08:20:00 <yuuki> For those interested in linear logic and foundations of mathematics: http://www.csc.villanova.edu/~japaridz/CL/gsoll.html
08:20:01 <lambdabot> Title: Game Semantics or Linear Logic?
08:20:01 <earthy> (which puts webservices built on modified GPLv2 code in an interesting spot)
08:20:20 <daf> earthy: is it interesting?
08:21:54 <quicksilver> depends what you find interesting.
08:22:01 <quicksilver> it's certainly not on-topic ;)
08:22:04 <earthy> :)
08:22:31 <earthy> daf: legally right but morally questionable if they don't distribute their modifications
08:23:48 <daf> earthy: well, yes. the interesting question is whether the AGPL will change anything
08:23:51 <daf> but yes, this is OT
08:31:32 <conal> Peaker: ("does it make sense for Reactive to export a type for events that fire once?  Or is Future already exported?")  there's an interesting discussion in this question.  how about asking on reactive@haskell.org?
08:32:20 <mm_freak> i'm writing a monads tutorial, and i've completed the section about implicit state now…  sections about IO and monad transformers are missing and i'll write them, when i've got some more spare time
08:32:34 <mm_freak> if anyone is interested in beta-reading, here it is:  http://streitmacht.eu/.beta/monads.html
08:32:36 <lambdabot> Title: Monads in Haskell
08:33:25 <mm_freak> any constructive criticism, just complain loudly here =)
08:35:46 <leimy> i'm thinking that i'd like to do something like coroutines with Control.Monad.Cont, to deal with the "live streaming" scoring of a bowling game :-)
08:36:24 <leimy> but I've not seen that done much.  I know how to use callCC to set up early bailout points, but I guess I'll end up doing a State "put" of that continuation so I can return and resume it?
08:36:48 <leimy> this leads me to ask "Does anyone actually have an example of Haskell coroutines with Cont?
08:36:49 <leimy> "
08:38:11 <quicksilver> leimy: no. it would be quite cool though.
08:38:34 <leimy> quicksilver: well I'll keep at it. :-)
08:38:46 <leimy> and share what I come up with.  I'm by no means even a good Haskell coder yet.
08:38:57 <lilac> does anyone understand this splitB business? the semantics of the function make no sense to me
08:39:32 <quicksilver> I didn't entirely follow the email
08:39:41 <quicksilver> I *think* he wants to flip/flip between two behaviours
08:39:51 <Taejo> :T (^)
08:39:55 <Taejo> :t (^)
08:39:56 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
08:39:59 <Taejo> :t (**)
08:40:00 <lambdabot> forall a. (Floating a) => a -> a -> a
08:40:38 <lilac> it returns an Event (Behaviour a), where, if the Event and the contained Behaviour are observed at the same time, the Behaviour is always the second argument of the function
08:40:46 <lilac> at least, i think so
08:40:59 <lilac> if the Behaviour is sampled before the Event occurs, it returns the first argument
08:41:20 <quicksilver> you can't sample the contents of an event before it occurs
08:41:25 <quicksilver> (or you shouldn't be able to)
08:41:29 <lilac> this is why i'm confused
08:42:05 <quicksilver> you should instead have a behaviour which takes one behaviour before the event and the other after
08:42:12 <quicksilver> which is a trivial application of switcher
08:45:21 <saml> how can I make my own SettableStateVar  ?   I want to do  myVar $= blah  in opengl
08:45:35 <quicksilver> just instance the appropriate class
08:45:38 <quicksilver> you could just use an IORef
08:45:45 <quicksilver> (IORefs are instances of StateVar)
08:46:20 <b_jonas> hello
08:51:01 <sw17ch> How does one get Data.Time working in windows with GHC 6.8.3?
08:51:38 <quicksilver> I didn't know it didn't work
08:51:43 <quicksilver> What are the symptoms of 'not working'
08:51:51 <Thruspa> Are you getting problems with Cabal?
08:52:04 <sw17ch> when I cabal-install
08:52:08 <sw17ch> it requires the Win32 package
08:52:14 <sw17ch> which failes due to the lack of a configure script
08:52:38 * sw17ch does a cabal update just to be sure
08:52:49 <sw17ch> well, that fixed part of it
08:53:11 * dcoutts_ wonders why it's installing Win32 when Win32 is presumably already installed
08:53:12 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
08:53:15 <saml> isFullScreen <- newIORef False      ...  keyboard (Char 'f') Down _ _ = do { fs <- readIORef isFullScreen ; if fs then .. }      should I pass around isFullScreen ?
08:53:22 <saml> then i don't see point of IORef
08:54:10 <rwbarton> Yes, you should
08:54:12 <sw17ch> win32 2.2.0.0 apparently is not
08:54:12 <saml> i want a "settable variable"  that can be accessed across different monads
08:54:18 <rwbarton> Presumably you also use writeFullScreen, which is the point
08:54:29 <rwbarton> *writeIORef
08:54:32 <lilac> saml: which monads?
08:54:55 <Thruspa> The package you are trying to build may not be updated. I got that problem with hsql.
08:55:03 <sw17ch> dcoutts_, it seems that I have Win32-2.1.1.1 installed but the newer time package wants Win32-2.2.0.0
08:55:41 <dcoutts_> sw17ch: try installing the older time package then
08:56:00 <sw17ch> dcoutts_: here's the error i get
08:56:00 <sw17ch> http://hpaste.org/12362
08:56:28 <sw17ch> i have an older time package... it seems... so why isn't Data.Time exposed i wonder
08:56:34 * dcoutts_ notes there should be some way to say that core packages should not be upgraded
08:56:45 * thoughtpolice yawns
08:58:25 * sw17ch wonders why he only ever has build problems on windows
08:59:29 <saml> http://hpaste.org/12363   this is my question
08:59:54 <sw17ch> dcoutts_: i can't seem to build the older time package, and i've tried rebuilding Win32-2.1.1.1 (which is currently installed)
08:59:58 <sw17ch> but it won't let me do that either
09:00:11 <dcoutts_> sw17ch: could you paste the output of cabal install --dry-run -v time
09:00:28 <dcoutts_> sw17ch: this is with 6.8.3 right? on windows
09:00:59 <sw17ch> http://hpaste.org/12364
09:01:03 <sw17ch> yes, 6.8.3 on windows
09:02:44 <dcoutts_> sw17ch: so you've got Win32-2.1.0.0 installed already right?
09:02:55 <dcoutts_> that's the one that came with 6.8.3 right?
09:02:59 <sw17ch> it appears
09:03:07 <sw17ch> i did a ghc-pkg list in my previous paste
09:03:27 <rwbarton> saml: Just define your 'keyboard' callback in a let statement inside main's do block, after the IORef is created
09:04:05 <dcoutts_> sw17ch: ah hah!
09:04:47 <dcoutts_> sw17ch: your current Win32 install is broken, so cabal install ignores it, so it does not think it is constrained to use the current version, so it picks the latest version.
09:05:04 <dcoutts_> sw17ch: see how it's marked with {}'s in the output of ghc-pkg list
09:05:09 <sw17ch> yes, i do
09:05:14 <sw17ch> shouldn't i be able to reinstall it?
09:05:24 <quicksilver> http://www.getacoder.com/projects/bug_finder_92913.html
09:05:29 <lambdabot> Title: Bug Finder (Programming, Testing / Quality Assurance)
09:05:43 <dcoutts_> sw17ch: you should be able to install the older version, yes, not the latest version.
09:05:57 <saml> rwbarton, hrm i used where block in main to define keyboard.. still complains isFullScreen not in scope
09:06:02 <b_jonas> quicksilver: yeah, someone just linked it from another channel
09:06:16 <b_jonas> quicksilver: I like the name of the project creator
09:06:18 <dcoutts_> sw17ch: though apparently the version that comes with 6.8.3 is not on hackage, only 2.1.0.0, not 2.1.1.1
09:06:19 * quicksilver nods
09:07:28 <rwbarton> saml: yes, a where block is not a let command.
09:07:30 <b_jonas> and some repliers have nice names too
09:08:02 <sw17ch> dcoutts_ i was going to say taht the version sin't available
09:08:06 <sw17ch> :\
09:08:11 <sw17ch> any clue as to why the newer one fails to build?
09:08:21 <lilac> saml: basically, you need to make the 'isFullScreen' IORef visible to 'keyboard' somehow. you could just pass it in...
09:08:26 <dcoutts_> sw17ch: it needs base 4, but does not say so.
09:08:35 <sw17ch> ah, that's cool
09:08:37 <sw17ch> :\
09:08:57 <sw17ch> So, my options here appear to be to install 2.1.0.0?
09:08:58 <dcoutts_> sw17ch: do ghc-pkg check Win32
09:09:08 <dcoutts_> it should say why it's broken
09:09:14 <dcoutts_> which missing dependency
09:09:23 <sw17ch> ah, missing bytestring
09:09:30 <thoughtpolice> @tell Lemmih urg, I think I broke something arcane in LHC - if you would pull the latest darcs and try to build 'hello world' or something? I'm not sure exactly what I broke; all I did was remove cbits and move arch into src and then I also rolled that back once the compiler stopped working - I can't tell what introduced it now :[
09:09:30 <lambdabot> Consider it noted.
09:09:43 <dcoutts_> sw17ch: I guess you unregistered bytestring-0.9.0.1.1
09:09:52 <quicksilver> Woot. Upgrading to leopard has broken my GHC. I had a feeling that might happen.
09:09:53 <sw17ch> hah, which is also not avaialble
09:09:56 <dcoutts_> which other packages still depended on
09:09:56 <sw17ch> :\
09:10:16 * sw17ch can't wait until he can migrate all his machines to 6.10
09:10:21 <dcoutts_> sw17ch: the versions that came with 6.8.3 do not all seem to have been uploaded to hackage
09:10:23 <sw17ch> this is incredibly frustrating
09:10:41 <sw17ch> dcoutts_: there's probably a reason for that?
09:10:55 <sw17ch> but it leaves me with a very badly broken GHC
09:11:06 <dcoutts_> sw17ch: generally they're not needed, since they come with ghc, but you accidentally unregistered ome of them
09:11:18 <hackage> Uploaded to hackage: HAppSHelpers 0.4
09:11:18 <hackage> Uploaded to hackage: HAppSHelpers 0.3
09:11:25 <sw17ch> dcoutts_: yes, i was having issues where cabal install and runhaskell Setup were picking the wrong versions of things
09:11:34 <sw17ch> this stems back to the network issue you'd helped me with earlier
09:11:43 <sw17ch> (and being unable to build that package on windows)
09:12:07 <dcoutts_> sw17ch: to recover, you may be able to install similar versions of the broken packages, or re-install ghc
09:12:56 <sw17ch> well, i'll play with this...
09:14:18 <sw17ch> dcoutts_: what's the chance the missing versions are recoverable someplace on the internet or elsewhere?
09:14:34 <dcoutts_> sw17ch: they're in the ghc source tarball
09:14:51 <sw17ch> it is just the one package i unregistered that i need, and if i could avoid the hugely tedious process of tweaking windows GHC install to work again, it would be fantastic
09:15:00 <sw17ch> i'll take a look
09:18:05 <sw17ch> dcoutts_: would it be damaging to have these packages put into hackagE?
09:18:20 <dcoutts_> sw17ch: no, they should all be uploaded
09:18:41 <sw17ch> is this something that i would be allowed to do, or is this something dons should take care of
09:18:53 <sw17ch> i was able to fix my install with the bytestring from sources
09:19:18 <dcoutts_> sw17ch: dons, myself or Igloo should probably upload them.
09:19:29 <sw17ch> dcoutts_: alright. i figured :)
09:19:37 <sw17ch> either way, this definitely fixed my problem
09:19:48 <sw17ch> thanks for your help
09:20:18 <dcoutts_> sw17ch: great
09:23:07 * quicksilver reads g-h-u for clarity on which OSX install of GHC to use and finds all but clarity.
09:23:37 <xenoblitz> hi guys... is there a website you recommend which explains existential quantifiers for dummies?
09:25:48 <xenoblitz> guess no :P
09:25:57 <quicksilver> xenoblitz: the wiki page is ok
09:26:02 <quicksilver> @go haskellwiki existential
09:26:05 <lambdabot> http://www.haskell.org/haskellwiki/Existential_type
09:26:05 <lambdabot> Title: Existential type - HaskellWiki
09:26:37 <xenoblitz> i still dont understand how a forall is used to mean exists
09:26:48 <quicksilver> it's the type of the constructor
09:26:50 <xenoblitz> is it related to how in logic forall and exists are related?
09:26:53 <quicksilver> if the constructor has a forall
09:26:58 <quicksilver> then the type itself is exists.
09:26:59 <quicksilver> yes.
09:27:11 <quicksilver> if the constructor works "for all" types
09:27:11 <xenoblitz> ic
09:27:15 <quicksilver> then when you have a value
09:27:17 <quicksilver> it must be "some" type
09:27:28 <quicksilver> you don't know which, because the constructor works "for all"
09:28:00 <xenoblitz> as I was reading another wiki... if you use for all you are basically restricted to bottom... cause that's the only value in all types
09:28:34 <quicksilver> that's forall, not exists.
09:28:40 <quicksilver> there are lots of values in an exists
09:28:42 <xenoblitz> hmmm ok ok
09:28:51 <quicksilver> it's just you need to think hard about what you can do with them
09:28:57 <quicksilver> (because you don't know what their type is)
09:29:14 <quicksilver> what I don't like about the existential page I just linked you to is it makes a false link between type classes and existentials.
09:29:31 <quicksilver> existentials are entirely separate from type classes and can perfectly well be used without them.
09:30:11 <xenoblitz> i don't know if you remember when I was asking you about a problem i had and you (I hope its you) suggested I should use forall
09:30:39 <quicksilver> refresh my memory slightly :)
09:32:05 <pumpkin_> ooh, the wiki page is pretty good
09:33:19 <xenoblitz> quicksilver: ok so the problem was that I wanted to have a system, where a programmer could write his own module for a system as long as it exports two functions... however there was a problem because I was trying to use a generic type in the functions exported
09:34:03 <quicksilver> yes
09:34:09 <quicksilver> I was telling you not to use a forall
09:34:19 <quicksilver> I was tellin gyou just to use an abstract type which both modules declared
09:34:20 <xenoblitz> Oh
09:34:24 <xenoblitz> yes
09:34:27 <xenoblitz> i remember that
09:34:45 <quicksilver> Gah. Of course ghc 6.10 doesn't come with opengl. I hate everythign.
09:35:09 <xenoblitz> hehe i used the system you suggested... but the powers that be didn't like it :P
09:35:45 <sw17ch> quicksilver: you feeling like that today too? :)
09:36:05 <quicksilver> sw17ch: I hate it when people release new versions of software which work less well than previous ones.
09:36:14 <quicksilver> sw17ch: even if I may sympathise with their reasons.
09:36:53 <sw17ch> we need an "Upgrade Everything" button for Hackage/GHC
09:37:43 <xenoblitz> apart from this question... I was wondering when a new version of the language is coming up which incorporates some of the extensions...
09:37:58 <dcoutts_> sw17ch: cabal upgrade is supposed to upgrade to the latest versions of all the things you've got installed. However it's not always possible to do.
09:38:20 <dcoutts_> sw17ch: using the latest versions of everything might be inconsistent
09:38:23 <sw17ch> dcoutts_: base-4 does actually require ghc 6.10 right?
09:38:29 <Deewiant> sw17ch: yep
09:38:30 <dcoutts_> sw17ch: yep
09:38:45 <quicksilver> or it might be insane :)
09:38:48 <sw17ch> it would be nice if there was a way, in cabal files, to say that you need GHC version such and such to use this package
09:39:02 <sw17ch> so that when i do run upgrade it doesn't complain that i can' build base-4
09:39:11 <dcoutts_> sw17ch: we kind of do it the otherway around and say that for ghc, you cannot upgrade base
09:39:15 <pumpkin_> isn't the base an indication of that?
09:40:22 <dcoutts_> sw17ch: the reason that you get that error is probably because the solver is not sufficiently smart to find a solution that only uses base 3
09:40:32 <dcoutts_> and it may also not have quite enough information
09:40:33 <b_jonas> and... can you upgrade ghc (together with base) with cabal?
09:40:40 <thoughtpolice> no
09:40:45 <dcoutts_> b_jonas: no, cabal cannot install ghc
09:40:54 <dcoutts_> it's a good deal more complicated
09:41:18 <dcoutts_> it can install simpler Haskell compilers like lhc, apparently
09:41:26 <dcoutts_> though I've not tried it
09:41:46 <DukeDave> Um, http://www.haskell.org/hoogle/?hoogle=connectTo   doesn't seem to find Network.connectTo   :(
09:41:47 <lambdabot> Title: connectTo - Hoogle
09:41:53 <DukeDave> ?hoogle connectTo
09:41:53 <lambdabot> No results found
09:48:05 <b_jonas> I think I'll try to read this haskell arbitary rank types paper because I'm now curious how that extension works
09:48:44 <Botje> magic
09:48:45 <b_jonas> this paper that is: http://research.microsoft.com/%7Esimonpj/papers/boxy/
09:48:46 <lambdabot> Title: Simon Peyton Jones: papers
09:48:48 <b_jonas> yeah, magic
09:49:02 <b_jonas> I wonder if it has anything to do with Skolem functions
09:49:33 <b_jonas> I mean, that it's magic is clear from this statement of the ghc manual:
09:49:48 <b_jonas> "In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm ...
09:49:51 <b_jonas> "
09:50:03 <b_jonas> " to get a decidable algorithm by requiring some help from the programmer."
09:50:09 <b_jonas> clearly that's magic
09:50:22 <quicksilver> they don't use boxy types though, AIUI
09:50:49 <quicksilver> ISTR it turned out to be less simple than they anticipated, so they ended up with a different algorithm?
09:50:59 <b_jonas> quicksilver: I'd like to know about the type interference and theory
09:51:04 <b_jonas> not how the runtime is implemented
09:52:15 <b_jonas> by theory I mean I want to know exactly when a program is correctly typed, not just when these types can be inferred
09:52:18 <thoughtpolice> @tell Lemmih nvm fixed
09:52:19 <lambdabot> Consider it noted.
09:52:47 <b_jonas> "it is an
09:52:49 <b_jonas> extension of Damas-Milner; it relies only on System F types;"
09:53:10 <b_jonas> pity I can't understand even the first paragraph of the paper :-)
09:53:14 <PeakerWork> quicksilver: existential types without typeclasses are quite useless, aren't they? (only id and few other functions can work?)
09:54:08 <MyCatVerbs> PeakerWork: I've used existentials without typeclasses, just once.
09:54:20 <PeakerWork> MyCatVerbs: for what purpose?
09:54:23 <MyCatVerbs> PeakerWork: they're handy where you have some internal state parameter that you don't care about the type of.
09:54:38 <b_jonas> PeakerWork: how about ST?
09:54:50 <PeakerWork> MyCatVerbs: how can you use the state parameter?
09:54:56 <PeakerWork> MyCatVerbs: if you've lost all type information?
09:55:07 <PeakerWork> b_jonas: I thought ST was magic
09:55:24 <dolio> PeakerWork: exists s. (s, s -> s, etc.)
09:55:38 <PeakerWork> dolio: what can you do with that?
09:55:51 <dolio> You can apply the second parameter to the first, for instance.
09:55:57 <MyCatVerbs> PeakerWork: for example, I once defined something like, data Perhaps a = Done Double a | Going Double (forall s. (s,s -> State a))
09:55:59 <b_jonas> PeakerWork: ST requires rank n types and rank n types are magic, so yes
09:56:20 <PeakerWork> dolio: but you'll remain with something that you can't use?
09:56:34 <PeakerWork> dolio: unless its something like:  exists s. (IO s) and then you can use the surrounding IO?
09:56:37 <dolio> PeakerWork: Sure, but maybe there's something else like 's -> Int' or something.
09:56:46 <MyCatVerbs> PeakerWork: the numbers in there were estimations of how likely the result was to be useful. I have a tuple of current state and function from state to new state in there, with which I can get the next state.
09:56:49 <pumpkin_> how does the infixl/r function work? is it dynamically changing the parser at runtime somehow?
09:57:02 <PeakerWork> dolio: ah
09:57:33 <Riastradh> No, pumpkin_.  It changes the parser at parse-time.
09:57:35 <dolio> PeakerWork: When you do 'exists s. Foo s => s', one way to look at it is that you have a tuple of an s and a dictionary of functions that operate on an s.
09:57:45 <PeakerWork> MyCatVerbs, dolio: I see, basically you can use existentials without type-classes when you have a complex type that refers to the existential multiple times
09:57:48 <pumpkin_> Riastradh: sorry, that's what I meant, at the parser's run-time :P
09:57:54 <quicksilver> PeakerWork: not at all.
09:57:57 <dolio> PeakerWork: So instead of using a type class dictionary, you can tuple a bunch of functions themselves.
09:58:12 <quicksilver> ah, catching up, other people have explained.
09:58:15 <quicksilver> I'll continue though
09:58:20 <MyCatVerbs> quicksilver: yes, yes at all. I've done exactly that! But that's not the only use. :P
09:58:26 <quicksilver> a bunch of functions is a better and more general thing that a type class
09:58:33 <quicksilver> typeclasses are hugely overused.
09:58:35 <MyCatVerbs> PeakerWork: yep, it's useful then.
09:58:39 <quicksilver> they are a solution to a very specific problem
09:58:53 <quicksilver> (asking the type inference engine to choose a tuple of functions based on the result of a type inference calculation)
09:59:07 <PeakerWork> quicksilver: if I pass a tuple of functions, it can also work, no?
09:59:08 <quicksilver> the most obvious example of which is adhoc overloading in the sense of Num.
09:59:26 <quicksilver> a data structure containing higher order functions is a more general tool.
09:59:41 <quicksilver> there doesn't have to be some 'unifying' type linking them all together, in a general structure.
09:59:46 <quicksilver> (but there can be, if you want)
10:00:19 <PeakerWork> quicksilver: you could define:  (+) :: NumFuncs a -> a -> a -> a   and it would also infer, so you don't even "need" type-classes there, right?
10:00:26 <MyCatVerbs> quicksilver: less loftily than that, typeclasses and their instances and the newtype garbage takes a *lot* more boilerplate than higher-ranked types do.
10:00:45 <MyCatVerbs> quicksilver: especially if you're specifying only one or two types.
10:01:00 <quicksilver> MyCatVerbs: well yes, I tend towards loftiness and indeed hyperbole
10:01:01 <kig> any performance tips for animating pango text with gtk2hs? this approach is not working well: http://gist.github.com/28999
10:01:03 <lambdabot> Title: gist: 28999 — GitHub
10:01:23 <MyCatVerbs> e.g. I have somewhere or other, GeneticAlgorithmStep :: (Population a) => [a] -> [a].
10:01:28 <quicksilver> MyCatVerbs: the key point is that typeclasses shouldn't even have been considered in the first place :)
10:01:44 <quicksilver> people consider them as a first option, when they shouuld be the second option.
10:01:51 <quicksilver> the first option should be higher-order functions.
10:01:56 <MyCatVerbs> Population is a typeclass with functions like generate :: (RandomGen rg) => rg -> (a, rg).
10:02:16 <quicksilver> typeclasses come in when you say "hmm, we have some restrictions here, could I get GHC to pick the right functions automatically somehow?"
10:02:25 <MyCatVerbs> And wrapping Doubles in a newtype so that you can define a Population instance for them... gets annoying, fast.
10:02:30 <pumpkin_> lol: http://www.getacoder.com/projects/bug_finder_92913.html
10:02:32 <lambdabot> Title: Bug Finder (Programming, Testing / Quality Assurance)
10:02:35 <quicksilver> MyCatVerbs: indeed
10:02:44 <quicksilver> pumpkin_: pasted it a few minutes ago ;)
10:02:50 <pumpkin_> sorry :)
10:02:58 <quicksilver> it is certainly funny though
10:02:59 <pumpkin_> didn't see that :)
10:03:01 <b_jonas> it's so good it was worth the third paste
10:03:09 * pumpkin_ looks embarrassed
10:03:42 <PeakerWork> quicksilver: what disadvantages does using NumFuncs like that instead of a Num type-class have?
10:03:50 <b_jonas> the first one was on another channel though
10:04:44 <pumpkin_> I love the godel bid
10:04:45 <MyCatVerbs> quicksilver: specifying GeneticAlgorithmStep :: (forall p. (RandomGen g => g -> (p,g)) -> (p -> Double) -> (RandomGen g => (p,g) -> (p,g)) -> [p] -> [p] also gets annoying. :)
10:04:56 <b_jonas> PeakerWork: there's one: if you get two numbers from separate sources, and want to add them together, if you use typeclasses the compiler checks they're compatible, with a method table you have to check if the same method table comes with the two numbers
10:05:01 <MyCatVerbs> quicksilver: (those are population generation, mutation and fitness. I forgot crossover. :)
10:05:09 <quicksilver> yes.
10:05:28 <quicksilver> PeakerWork: well you have to pass the dictionary ;)
10:05:31 <quicksilver> so it's more work.
10:05:39 <PeakerWork> b_jonas: wouldn't the type-check of NumFuncs a   vs NumFuncs a    do the trick?
10:05:44 <PeakerWork> b_jonas: (have to be the same a)
10:05:48 <MyCatVerbs> quicksilver: so much nicer to have: data Genetic = forall p. { generate :: (RandomGen g => g -> (p,g) ... }
10:06:15 <PeakerWork> quicksilver: but if type-classes are merely a convenience above a func tuple, then why not use them in every oppurtunity?
10:06:16 <MyCatVerbs> quicksilver: in which case, I'm now doing exactly the dictionary-passing approach that people model typeclasses by, except that I'm doing it manually. =)
10:06:19 <leimy> looks like a State monad
10:06:29 <b_jonas> PeakerWork: maybe... but what guarantees there's only one value of type NumFuncs a for any one type a?
10:06:44 <b_jonas> PeakerWork: how do you know there's no two NumFuncs Int that is
10:07:02 <PeakerWork> b_jonas: oh
10:07:19 <MyCatVerbs> PeakerWork: two reasons. Firstly, as b_jonas said, there may be more than one possible instance for a given type. e.g. you can define Monoid [] with mappend = (++) or mappend = flip (++).
10:07:34 <b_jonas> PeakerWork: also there's another problem: what about functions like fromInteger or maxBound? where would they get the record from?
10:07:45 <PeakerWork> so instances are a useful way to associate exactly one NumFuncs with a type at compile-time, so you don't have to worry about that
10:07:54 <MyCatVerbs> PeakerWork: other reason is that, especially for small numbers of functions, wrapping up a newtype and writing up a typeclass get annoying fast.
10:07:55 <leimy> Is Monoid just a Monad with mplus and mzero?
10:08:12 <lament> -Monad
10:08:14 <Deewiant> No, that's MonadPlus :-)
10:08:17 <PeakerWork> b_jonas: fromInteger :: NumFuncs a -> Integer -> a ?
10:08:34 <MyCatVerbs> leimy: no. Monoid is just mappend and mzero, where mappend == mplus, and mempty == mzero.
10:08:35 * leimy has to look up Monoid again :-)
10:08:43 <PeakerWork> MyCatVerbs: I think maybe newtype can be replaced with something more convenient?
10:08:52 <MyCatVerbs> leimy: (MonoidPlus m) means that m is both a Monoid and a Monad.
10:09:03 <leimy> aren't all Monoids Monads though?
10:09:17 <PeakerWork> leimy: no
10:09:29 <Deewiant> integers are monoids in two ways but not monads
10:09:34 <leimy> hmmm
10:09:35 <MyCatVerbs> leimy: no. There's a monoid instance for integers, where mempty = 0 and mappend = +, for instance.
10:09:50 <MyCatVerbs> leimy: there's another one where mempty = 1 and mappend = (*), too. :)
10:09:50 <PeakerWork> leimy: types of kind * can be Monoids, but only types of kind *->* can be Monads, so strictly speaking, there's no overlap at all
10:10:04 <MyCatVerbs> PeakerWork: if you figure out a way to replace newtype with something more convenient, tell me.
10:10:26 <lilac> however, Monad m => Monoid (m ()), with mzero = return () and mappend = (>>)
10:10:32 <MyCatVerbs> PeakerWork: I suspect that the heavyweight way would involve bulldozing large chunks of the language to implement something like inheritance for typeclasses, yuch!
10:10:47 <MyCatVerbs> PeakerWork: the lighter-weight way is to use a damn existential, you hippy! =D
10:10:55 <b_jonas> btw
10:10:58 <leimy> PeakerWork:  So Lists aren't both monads and monoids because there's no overlap?  Or rather there is a list Monoid, and a list Monad?
10:11:16 <PeakerWork> lilac: every Monad can be "converted" into a Monoid then, but not vice versa
10:11:30 <PeakerWork> leimy: [] is a Monad, not a Monoid.  [a] is a Monoid, not a Monad
10:11:31 <lilac> PeakerWork: right. however,  m () is often not the monoid you want
10:11:50 <MyCatVerbs> leimy: there is a Monoid instance for lists, and there is also a Monad instance for lists.
10:11:50 <leimy> PeakerWork:  oh weird, but makes sense.
10:11:58 <MyCatVerbs> leimy: they aren't mutually exclusive in any way.
10:12:00 <b_jonas> if you say newtype MyInt = MyInt Int deriving Show; does the Show instance gets derived as usual for data, or as a newtype derived? that is, will it show the constructor name or just show myint like it shows an int?
10:12:17 <b_jonas> > show (4 :: CInt)
10:12:18 <lambdabot>   Not in scope: type constructor or class `CInt'
10:12:24 <MyCatVerbs> leimy: it's just that there's a bit of a screwup in the libraries, where we have (MonadPlus m) when we really ought to have been writing (Monad m, Monoid m).
10:12:28 <PeakerWork> MyCatVerbs: strictly speaking, they are exclusive because of the different kinds.. Less strictly, the [] and [a] instances can be considered the "same type"
10:12:31 <ToRA|MSR> it'll show the newtypes constructor too
10:12:41 <leimy> MyCatVerbs: That's where I get confused.
10:12:46 <ToRA|MSR> i guess since that's what h98 requires
10:12:56 <PeakerWork> MyCatVerbs: That's not true
10:13:05 <MyCatVerbs> Or, getting the kinds right, (Monoid (m a)).
10:13:15 <PeakerWork> MyCatVerbs: Even that's not quite the same, though
10:13:22 <leimy> PeakerWork:  I need to learn more about "kinds" vs "types".
10:13:36 <MyCatVerbs> PeakerWork: MonadPlus m says that forall a, Monoid (m a).
10:13:39 <lilac> PeakerWork: there's also Monad m => Monoid (m a), where mempty = fail "mempty" and mapppend = (>>), which coincides with the Monoid instance for []
10:13:50 <PeakerWork> MyCatVerbs: There's a meaningful difference between (MonadPlus m) and (Monad m, Monoid (m a)), because MonadPlus defines the mplus operation between infinite types, whereas mappend is defined on just one type
10:13:51 <b_jonas> but you can't say in haskell that m has to be a type such that m a is a Monoid for all a
10:13:59 <lilac> PeakerWork: but mentioning 'fail' around here gets you murdered, so pretend i didn't say that
10:14:17 <Twey> Apparently, fail is fail.
10:14:17 <PeakerWork> lilac: yeah, "fail" sucks :)
10:14:23 <MyCatVerbs> PeakerWork: no, forall a. Monoid (m a) also gives you mappend on an infinite number of types.
10:14:41 <b_jonas> how does mappend = (>>) coincide with the monadplus instance of [] ?
10:14:47 <b_jonas> I don't think it does
10:14:51 <lilac> b_jonas: nope, i'm fail
10:15:05 <b_jonas> > [4] (>>) [9]
10:15:06 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
10:15:08 <b_jonas> > [4] >> [9]
10:15:10 <lambdabot>   [9]
10:15:13 <b_jonas> > [4] mappend [9]
10:15:15 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
10:15:18 <b_jonas> > [4] mplus [9]
10:15:20 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
10:15:21 <MyCatVerbs> That's multiplicative, not additive.
10:15:23 <PeakerWork> MyCatVerbs: yeah, you have infinite instances, and each instance has mappend for that one instance/type.   a single instance of MonadPlus has to support mplus that is polymorphic
10:15:25 <ToRA|MSR> > (mzero `mplus` (return 3)) :: Maybe Int
10:15:25 <MyCatVerbs> b_jonas: you're forgetting the backticks.
10:15:27 <b_jonas> > [4] `mplus` [9]
10:15:27 <lambdabot>   Just 3
10:15:28 <lambdabot>   [4,9]
10:15:29 <ToRA|MSR> > (mempty `mappend` (return 3)) :: Maybe Int
10:15:30 <lambdabot>       No instance for (Monoid Int)
10:15:31 <lambdabot>        arising from a use of `mempty' at <...
10:15:35 <PeakerWork> MyCatVerbs: IOW, mappend does not have to be polymoprhic, and mplus does
10:15:36 <b_jonas> > [4] `mappend` [9]
10:15:37 <Twey> Ooo
10:15:37 <lambdabot>   [4,9]
10:15:50 <pumpkin_> what's a more general form of the venn diagram for showing relationships of more than three sets?
10:15:55 <ddarius> > [] `mplus` [1]
10:15:57 <lambdabot>   [1]
10:16:02 <ddarius> > [] `mappend` [1]
10:16:03 <lambdabot>   [1]
10:16:24 <MyCatVerbs> PeakerWork: push the forall up a little. By asking for forall a. Monoid (m a), you're constraining mappend to be forall a. (m a) -> (m a) -> (m a), which matches mplus.
10:16:36 <lilac> > [1,2,3] >> [4,5]
10:16:37 <lambdabot>   [4,5,4,5,4,5]
10:17:29 <MyCatVerbs> PeakerWork: in forall a. Monoid (m a), your definitions of mempty and mappend must also be polymorphic, because they have access to no type information about a.
10:17:39 <kig> quantize d f = d * floor (f / d)
10:18:03 <kig> wants a type definition
10:18:20 <PeakerWork> MyCatVerbs: a forall a. Monoid (m a) has to be polymorphic, but not all monoids are polymorphic, whereas all MonadPlus's are polymorphic
10:18:21 <ddarius> :t let quantize d f = d * floor (f / d) in quantize
10:18:22 <lambdabot> forall a. (Integral a, RealFrac a) => a -> a -> a
10:18:45 <b_jonas> so that's basically void
10:19:08 <b_jonas> because floor (in the prelude) returns an integer
10:19:15 <ddarius> :t floor
10:19:16 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
10:19:22 <b_jonas> perhaps you want (fromIntegral . floor) instead of floor
10:19:54 <PeakerWork> MyCatVerbs: maybe that is not a very meaningful distinction in practice, I am not sure
10:20:00 <MyCatVerbs> PeakerWork: what? What I said was that (MonadPlus m) is identical to (Monad m, forall a. Monoid (m a)).
10:20:14 <MyCatVerbs> PeakerWork: you appear to be telling me off for something that I did say, but immediately corrected. :P
10:20:35 <b_jonas> MyCatVerbs: is "forall a. Monoid (m a)" even meaningful?
10:20:39 <Deewiant> ?ty \d f -> d * div f d
10:20:40 <lambdabot> forall a. (Integral a) => a -> a -> a
10:21:16 <MyCatVerbs> b_jonas: within GHC's type system? I have no idea.
10:21:30 <PeakerWork> MyCatVerbs: Maybe that is truly equivalent, I was convinced the other month here by someone that MonadPlus and Monoid are both necessary, but you make a strong point as well :)
10:21:52 <PeakerWork> MyCatVerbs: will that work with -fghc-exts ?
10:22:09 <MyCatVerbs> PeakerWork: again, I don't know if GHC's type system will take that.
10:22:11 <orbitz> whats a monoid?
10:22:17 <orbitz> a singular monad?
10:22:19 <vegai> does cabal have any license resolving?
10:22:22 <PeakerWork> orbitz: has little to do with monads
10:22:23 <b_jonas> orbitz: a semigroup with unity
10:22:31 <vegai> i.e. if I link a GPL against my BSD software, do I get a warning...
10:22:35 <dolio> You can't quantify inside a context, so you can't do (Monad m, forall a. Monoid (m a)) => ...
10:22:39 <PeakerWork> orbitz: its an associative binary operation + neutral element
10:22:40 <rwbarton> orbitz: a group without inverses :)
10:22:54 <PeakerWork> MyCatVerbs: ah, so MonadPlus is required due to type system limitations, at least
10:22:56 * orbitz stares blankly :)
10:23:03 <MyCatVerbs> PeakerWork: I reiterate... :)
10:23:38 <b_jonas> PeakerWork: it's nice how the "+" in that sentence causes an ambiguity
10:23:44 <MyCatVerbs> PeakerWork: maybe. But I'll be impressed if you can show me a piece of code where having MonadPlus rather than just asking for the Monoid instance is actually useful.
10:23:51 * ToRA|MSR mumbles something about MonadPlus Maybe and Monoid Maybe being very different, distinct and useful beasts...
10:24:00 <dolio> Also, one could argue that implementing MonadPlus commits you to following some (ill-specified, disputable) laws as far as the interaction of MonadPlus and Monad methods are concerned that Monoid doesn't.
10:24:10 <leimy> can types of kind * be Monads?
10:24:14 <leimy> or just * -> *?
10:24:19 <MyCatVerbs> leimy: just * -> *.
10:24:20 <kig> b_jonas: thank you very much, that was it
10:24:21 <opqdonut> * -> *
10:24:21 <PeakerWork> MyCatVerbs: If you want "m" to be a monad, and all "m a"s to be Monoids? Or are you asking for a practical use case of that?
10:24:24 <mux> only * -> *
10:24:30 <orbitz> only * -> *
10:24:37 <PeakerWork> @type guard
10:24:37 <leimy> ah that totally makes more sense then
10:24:38 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
10:24:43 <PeakerWork> @src guard
10:24:43 <MyCatVerbs> PeakerWork: the latter. Call me a mild type system skeptic. :)
10:24:43 <lambdabot> guard True  =  return ()
10:24:44 <b_jonas> kig: only be aware that fromIntegral . floor can be really inefficent
10:24:44 <lambdabot> guard False =  mzero
10:24:56 <b_jonas> kig: because it always convert to an Integer (bigint) internally
10:25:05 <PeakerWork> MyCatVerbs: I have never encountered it, but I don't find it unimaginable
10:25:17 <ddarius> dolio: They're not ill-specified, there are just conflicting uses.  I agree with Cale that MonadPlus should probably be split into too classes (with similar methods but different laws)
10:25:25 <lilac> PeakerWork: [] ?
10:25:27 <b_jonas> kig: if you want a fromIntegral . floor that's efficent for floats with very large exponents, you have to foreign import the floor function from the c library
10:25:36 <leimy> types of kind * can be Monoids... can types of kind * -> * be Monoids?  Or is that where the "no overlap" claim comes from?
10:25:40 <MyCatVerbs> PeakerWork: I don't find it completely unimaginable, but then neither are lottery wins. ;P
10:25:43 <mux> that fake code project is awesome :-)
10:25:49 * mux forwards the URL to friends
10:25:53 <MyCatVerbs> leimy: types of kind * can be Monoids. Types of kind * -> * can't.
10:26:03 <leimy> MyCatVerbs: and thusly no overlap... cool
10:26:13 <PeakerWork> lilac: the question, I think, is who actually has legitimate use of MonadPlus, rather than just using Monoid, or e.g guard, only uses mzero, which might as well be some simpler type-class
10:26:32 <ToRA|MSR> PeakerWork: Maybe
10:26:51 <MyCatVerbs> leimy: but you can give polymorphic definitions of Monoid like, instance Monoid [a] where....
10:26:55 <PeakerWork> ToRA|MSR: example function that requires that context, not example type that is an instance of MonadPlus
10:26:56 <dolio> ddarius: Yeah, that's more or less what I meant.
10:27:24 <leimy> MyCatVerbs: but not for MonadPlus
10:27:29 <leimy> ?
10:27:43 <conal> @tell Peaker ("does it make sense for Reactive to export a type for events that fire once?  Or is Future already exported?")  there's an interesting discussion in this question.  how about asking on reactive@haskell.org?
10:27:43 <conal>  
10:27:43 <lambdabot> Consider it noted.
10:27:46 <PeakerWork> leimy: a type whose kind is *->* is a type constructor (like []), its not an actual type that has values.  a type whose kind is * (like [Int]) is a type that has values, a type constructor of kind *->*, when given a type argument (in compile-time), e.g:  [] Int    becomes an actual type  (in this case: [Int])
10:27:46 <b_jonas> I don't believe the constraint forall a. Monoid a can even make sense until I'm convinced otherwise
10:27:53 <PeakerWork> conal: I'm here :)
10:27:59 <conal> oh, hi PeakerWork
10:28:26 <dolio> ddarius: Although, if we have two classes, are there no more violations? I'd have to work out what the laws for both and which monads violate which, since I haven't thought about it in a while.
10:28:27 <MyCatVerbs> leimy: MonadPlus is defined on things of kind (* -> *).
10:28:28 <ToRA|MSR> PeakerWork: mplus for taking the first success out of a list of runs where you don't want to combine things.  mappend for when you want to e.g. combine two maps which may share keys
10:28:28 <PeakerWork> conal: The tutorial thing that switches between 2 behaviors seemed a bit ill-typed to me (I did not understand what it does with extra occurances of the event)
10:28:44 <leimy> MyCatVerbs: I think I've got it.
10:28:46 <conal> PeakerWork: i haven't read it.
10:29:01 <leimy> MyCatVerbs: thanks
10:29:02 <PeakerWork> conal: basically an:  Event () -> Behavior a -> Behavior a -> Behavior a         iirc
10:29:03 <leimy> PeakerWork: thanks!
10:29:15 <opqdonut> damn behaviourists!
10:29:15 <MyCatVerbs> leimy: (same as Monad). So you write instance MonadPlus [] where....
10:29:37 <PeakerWork> ToRA|MSR: but does it use the Monad-ness, or just MonadPlus-ness? :)
10:29:41 <kig> b_jonas: maybe floorf a = a - (snd $ properFraction a)  would work
10:30:11 <ToRA|MSR> the former will use the monadness certainly as you're doing some possibly failing operation
10:30:14 <PeakerWork> ToRA|MSR: also, MonadPlus as a mere alternative Monoid seems like a bad alternative to just using a newtype on Maybe with a differing Monoid instance?
10:30:27 <ToRA|MSR> the latter isn't using Maybe in a monad contex at all
10:30:34 <opqdonut> somebody should write a blog bost or something about MonadPlus and Monoid
10:30:39 <opqdonut> *post
10:30:49 <PeakerWork> ToRA|MSR: why does the MonadPlus make any sense then?
10:30:49 <leimy> It's amazing how much stuff you can make work in Haskell without really "getting" all of this stuff.
10:30:50 <vixey> kig, but not just snd . properFraction?
10:30:51 <opqdonut> so we wouldn't need to go all over this again every two months
10:30:54 <PeakerWork> ToRA|MSR: the class, that is
10:31:11 <leimy> I mean, you can seemingly fight with the type errors, and eventually make stuff work.
10:31:19 <leimy> but it's not clear that "stuff" is what you meant.
10:31:32 <MyCatVerbs> PeakerWork: newtypes for changing behavoir suck, they're verbose. Use existentials instead! =)
10:31:33 <Deewiant> Somebody should write a Haskell FAQ with answers to common questions from at least #haskell and -cafe
10:31:51 <MyCatVerbs> Deewiant: hah. Actually it'd mostly be a list of common holy wars. =)
10:31:53 <PeakerWork> MyCatVerbs: heh, how would I use existentials to get various Monoid behaviors from Maybe?
10:32:18 <PeakerWork> @src Alternative
10:32:18 <lambdabot> class Applicative f => Alternative f where
10:32:18 <lambdabot>     empty :: f a
10:32:18 <lambdabot>     (<|>) :: f a -> f a -> f a
10:32:31 <Deewiant> MyCatVerbs: that's fine as long as they're addressed, so we don't have to fight them once a week. :-P
10:32:31 <leimy> Deewiant: I'm not sure that would help
10:32:32 <PeakerWork> (its not enough that we have Monoid, MonadPlus,  lets also have Alternative! :-)
10:32:42 <MyCatVerbs> PeakerWork: er, you don't need them. Just plain old HOFs will suffice.
10:32:42 <kig> vixey: you lost me
10:32:57 <leimy> Deewiant: I've read about 3 books on haskell, many web articles, and some docs, plus example code, and sometimes still feel lost :-)
10:33:06 <PeakerWork> MyCatVerbs: I ought to play with HOFs to get a feel for their real problems
10:33:08 <Deewiant> leimy: I'm fairly sure it would help. It might not solve the problems completely, but it'd help.
10:33:11 <MyCatVerbs> PeakerWork: you just pass in a function of type forall a. (Maybe a) -> (Maybe a) -> (Maybe a).
10:33:22 <vixey> > let a = 3.2 in a - (snd $ properFraction a)
10:33:23 <lambdabot>   3.0
10:33:33 <vixey> > let a = 3.2 in (fst . properFraction) a
10:33:34 <lambdabot>   3
10:33:43 <kig> that's not 3.0
10:33:49 <MyCatVerbs> PeakerWork: the _problem_ with HOFs is simple. The more stuff you parameterize, the longer the argument lists grow (and hence the harder the declarations can be to read).
10:33:53 <leimy> Deewiant: I guess I'm just surprised that all the haskell books I know of just glance Monads, never talk about Monoids, or Arrow or any of the advanced stuff.  Or the relationships between them.  Perhaps that's a book unto itself?
10:33:54 <MyCatVerbs> PeakerWork: I think. :)
10:34:13 <vixey> MyCatVerbs, newtype Parameters = Foo Integer [String] ...
10:34:18 <PeakerWork> MyCatVerbs: gotta go, hope to continue the discussion some time :)
10:34:28 <MyCatVerbs> vixey: data, you mean. And I've written that, too. :)
10:35:00 <leimy> I can't decide if haskell is either good or bad for one's mental hygiene.  It's definitely thought-cycle consuming from time to time.
10:35:03 <Deewiant> leimy: Yeah, there's no book about "Advanced Haskell". Although I wouldn't lump Monoids into that. ;-)
10:35:18 <leimy> Deewiant:  OK I'm just an idiot then :-)
10:35:28 <kig> vixey: floorf = fromInteger . fst . properFraction would work but does it go through bignum?
10:35:28 <Deewiant> Well, Monoids as such aren't very complicated.
10:35:36 <leimy> or not getting hit with that thing my Philosophy professors used to call a BOOB
10:35:42 <leimy> Bolt Out Of the Blue
10:35:55 <Deewiant> Monads are a more complicated concept than monoids IMO.
10:36:05 <leimy> Monoids don't seem too difficult.  If you think of the fact that they're bound to a type
10:36:10 <vixey> :t properFraction
10:36:11 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
10:36:14 <leimy> Because you're just saying "this has this domain and range"
10:36:14 <lament> there're not very many concepts simpler than monoids
10:36:16 <MyCatVerbs> vixey: since all these different ways of writing programs are strictly equivalent, IMO it just comes down to which is most understandable and involves least boilerplate. Which are strictly subjective and objective, respectively. :)
10:36:17 <leimy> I think.
10:36:23 <plogYy> i am getting (Nan, Nan) when calling the function to get the roots of the polynomial equation, what's wrong?
10:36:34 <plogYy> here is the code:
10:36:45 <plogYy> roots a b c =
10:36:45 <plogYy>  let disc = sqrt(b*b - 4*a*c)
10:36:49 <lament> a monoid is one of the simplest mathematical objects you can have
10:36:55 <plogYy> twice_a = (2*a)
10:36:55 <plogYy>  in
10:37:07 <Deewiant> lament: I guess it depends on your point of view. For a programmer I'd say Functor (the class, not the category theory) is simpler, but mathematics is a different story.
10:37:08 <plogYy> ((-b + disc) / twice_a, (-b - disc) / twice_a)
10:37:24 <leimy> Yeah Functor I pretty much got right away
10:37:29 <MyCatVerbs> lament: class ThereExistsSome a where { iWantSome :: a } -- =)
10:37:30 <rwbarton> plogYy: probably b*b-4*a*c is negative
10:37:34 <lament> Deewiant: Programmers should be familiar with function composition. Therefore, they're familiar with monoids
10:37:52 <MyCatVerbs> lament: tada! One simpler mathematical object than a Monoid. :)
10:37:56 <leimy> lament: The problem is the things being composed don't always feel or look like functions :-)
10:38:02 <MyCatVerbs> lament: I can't think of any simpler than that, though. =)
10:38:08 <plogYy> rwbarton: what numbers would i pass as arguments to get a positive result?
10:38:14 <Deewiant> lament: I wonder how most programmers take to generalizing function composition ;-)
10:38:27 <leimy> Deewiant: That's the rub isn't it.
10:38:37 <leimy> it's saying "you can compose these things" and the Monad instances say "how"
10:38:41 <MyCatVerbs> leimy: prepend "aye," to that.
10:38:42 <lament> Deewiant: it's not about generalizing function composition. It's about generalizing composition. Function composition is one motivating example.
10:38:44 <rwbarton> plogYy: Uh, coefficients of a polynomial ax^2 + bx + c which has real roots, rather than complex roots
10:38:58 <leimy> but you can't compose different Monads, because their composition "steps" are different :-)
10:39:06 <lament> Deewiant: Addition of numbers is another. Concatenation of strings is another. Etc.
10:39:12 <leimy> You can contain them within each other, and lift stuff around, but it begins to feel clunky.
10:39:14 <lament> it doesnt take much brain to see similarities in those operations
10:39:16 <plogYy> rwbarton: more clear please?
10:39:35 <leimy> So the simplification given by Monads often feels like it's only one layer deep.
10:39:50 <Deewiant> lament: You might be right. I was familiar with groups before I was familiar with monoids so I didn't really have to think about them much. :-)
10:39:59 <leimy> but, Paul Hudak's book shows a really nice implementation of a home-brew state monad carrying a lot of stuff with it for the IRL language.
10:40:19 <leimy> so if you *really* get Monads, you don't have to confine yourself to Control.Monad.State and can roll your own for simplification.
10:40:46 <lament> monads IRL? :)
10:40:50 <Cale> http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx -- for people who want a fun example of using monoids :)
10:40:52 <rwbarton> plogYy: read this: http://en.wikipedia.org/wiki/Quadratic_equation
10:40:53 <lambdabot> Title: cgibbard comments on Monoids? In my programming language?, http://tinyurl.com/5e63ad
10:41:02 <sbahra> Hi.
10:41:03 <lambdabot> Title: Quadratic equation - Wikipedia, the free encyclopedia
10:41:04 <leimy> lament:  Imperative Robot Language  I think.
10:41:15 <sbahra> What was the URL to the page that contained the list of packages included with GHC releases?
10:41:16 <Deewiant> I guess I don't get monads then, rolling a State of my own would probably take a while and a fair deal of thought :-P
10:41:21 <sbahra> I couldn't find it.
10:41:28 <Deewiant> ?google haskell hierarchical
10:41:31 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/
10:41:31 <lambdabot> Title: Haskell Hierarchical Libraries
10:41:39 <leimy> Deewiant: I actually think I can roll my own State monad.
10:41:56 <sbahra> Deewiant, not this.
10:42:00 <leimy> Deewiant: I came close to doing it, then decided I could just use StateT :-)
10:42:09 <sbahra> Deewiant, there is one that shows the list of various packages includes with various releases of GHC.
10:42:16 <leimy> so I got lazy about it, and dealt with the lifting and other "fun"
10:42:25 <sbahra> Deewiant, nothing about interfaces really.
10:42:33 <Deewiant> sbahra: I don't think I know what you're talking about, sorry. Unless it's in the GHC docs?
10:42:39 <Deewiant> Maybe the changelog
10:42:42 <sbahra> It's on the WiKi.
10:42:55 <sbahra> It's very useful :-( I recently lost my bookmarks.
10:42:55 <Deewiant> I don't think I've seen it.
10:43:06 <sbahra> @seen dons
10:43:06 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 11h 48m 43s ago.
10:43:09 <Deewiant> Why do you need it?
10:43:17 <sbahra> @ask dons What was the URL to the page that contained the list of packages included with GHC releases?
10:43:17 <lambdabot> Consider it noted.
10:43:33 <sbahra> Deewiant, to properly implement dependencies.
10:43:35 <Cale> Deewiant: You can understand monads in general without understanding the State s monad, but I think for the purposes of understanding functional programming, understanding how State s is implemented is a very good exercise.
10:43:46 <Deewiant> ?src State
10:43:46 <lambdabot> Source not found. Are you on drugs?
10:44:19 <Cale> The reason that it's tricky is that it really does involve using functions as data in a way that's hard to ignore.
10:44:30 <leimy> Cale: The best book on nailing State down I've found was Hudak's
10:44:31 <Deewiant> The online docs don't have source, meh
10:44:33 <Deewiant> @source mtl
10:44:33 <lambdabot> mtl not available
10:44:52 <leimy> http://www.amazon.com/Haskell-School-Expression-Functional-Programming/dp/0521644089/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1227638684&sr=8-1
10:44:55 <lambdabot> http://tinyurl.com/5t8vvj
10:44:56 <Cale> The mtl's definition looks like this:
10:45:05 <Cale> newtype State s a = State { runState :: s -> (a,s) }
10:45:28 <Cale> s -> (s,a) would have been a better choice
10:45:32 <leimy> yes
10:45:35 <leimy> runState muddies it
10:45:41 <leimy> Hudak doesn't do that :-)
10:45:53 * rwbarton can't remember whether he agreed on Cale on this last time it came up :)
10:45:56 <Cale> Well, that's not what I was talking about, but yes.
10:46:13 <Cale> Usually when teaching, I change it to be:
10:46:18 <leimy> Cale:  oh the order of the tuple
10:46:21 <leimy> yes there's that too :-)
10:46:22 <Cale> newtype State s a = S (s -> (s,a))
10:46:23 <rwbarton> I think I did.
10:46:37 <Cale> runState (S f) s = f s
10:47:04 <Deewiant> Hmm.
10:47:09 <leimy> Cale: What I don't understand is how we go from
10:47:16 <leimy> State { runState :: s -> (a,s) }
10:47:20 <leimy> to what amounts to
10:47:25 <leimy> runState (S f) s = f s
10:47:35 <Cale> Well, okay
10:47:41 <Cale> runState is a field label
10:47:46 <Deewiant> (>>=) :: (s -> (s,a)) -> (a -> s -> (s,b)) -> s -> (s,b)
10:47:55 <Cale> which means that it's automatically defined as an extractor for that field
10:48:05 <Deewiant> ?djinn (s -> (s,a)) -> (a -> s -> (s,b)) -> s -> (s,b)
10:48:05 <lambdabot> f a b c =
10:48:06 <lambdabot>     case a c of
10:48:06 <lambdabot>     (d, e) -> b e d
10:48:14 <Cale> So as a function, it has type   runState :: State s a -> s -> (a,s)
10:48:16 <Deewiant> Clever.
10:48:48 <leimy> Yeah it seems like a "simplification" that's hard for newbies to really understand though.
10:48:55 <Cale> Yeah.
10:49:15 <leimy> Part of it is not understanding  the "Record" syntax in all of it's glory.
10:49:17 <leimy> er its
10:49:18 <leimy> :-0)
10:49:33 <Deewiant> My main gripe is that it's easy to miss if you're reading the documentation.
10:49:34 <Cale> yes, and the fact that you're extracting a function which is going to take another parameter
10:49:38 <FunctorSalad> leimy: agreed
10:49:48 <leimy> Cale: so there's currying going on + the syntax. :-)
10:49:54 <FunctorSalad> (the simplification line)
10:50:46 <Cale> I should write my own MTL :)
10:51:02 <leimy> Deewiant: anyway, I really liked the introduction to this stuff by Hudak
10:51:12 <FunctorSalad> also, "State" should be called "State transformer" and "StateT" "State transformer monad transformer" ;)
10:51:14 <Cale> I wonder how MonadPrompt-constructed monads perform relative to directly constructed ones.
10:51:31 <leimy> FunctorSalad: yeah...  State is really an FSM
10:51:41 <leimy> with state suspended between function calls.
10:51:51 <Deewiant> Cale: have you looked at monadlib (and the others, if there are any)?
10:51:55 <Cale> Well, I think we should really call it the State s monad.
10:51:57 <leimy> That's why I want to marry it with Coroutines.  I can fake it with forkIO and channel concurency, but EW.
10:52:00 <Cale> State itself is not a monad.
10:52:06 <Cale> But for any type s, State s is.
10:52:24 <leimy> yeah.  again, currying :-)
10:52:27 <Cale> Deewiant: yes, monadLib is better, but it's still not what I'd write.
10:53:01 <Deewiant> In what way(s) is monadLib better?
10:53:17 <leimy> I'm not sure I know of monadLib
10:53:44 <Cale> It has a non-broken monad transformer ChoiceT to take the place of ListT (which is not a monad transformer)
10:54:05 <Cale> and it doesn't have stupid things like RWS
10:54:33 <leimy> Hmmm http://www.galois.com/~diatchki/monadLib/doc/MonadLib.html  <-- that?
10:54:34 <lambdabot> Title: MonadLib
10:54:36 <lilac> @type flip ((.) . uncurry) :: (s -> (a,s)) -> (a -> s -> (b,s)) -> (s -> (b,s))
10:54:37 <lambdabot> forall s a b. (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)
10:54:40 <FunctorSalad> ListT m a = m [a]?
10:54:41 <Deewiant> leimy: it's on Hackage at least.
10:54:45 <FunctorSalad> @src ListT
10:54:45 <lambdabot> Source not found. Maybe you made a typo?
10:54:48 <olsner> seems the darcsweb cache directory has disappeared or something --> http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=array;a=shortlog
10:54:49 <Deewiant> ?unmtl ListT m a
10:54:49 <lambdabot> m [a]
10:55:14 <lilac> @type flip (fmap fmap uncurry) :: (s -> (a,s)) -> (a -> s -> (b,s)) -> (s -> (b,s))
10:55:15 <lambdabot> forall s a b. (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)
10:56:17 <Cale> I think it should really be LogicT.
10:56:26 <Deewiant> @type flip ((.) . uncurry)
10:56:28 <lambdabot> forall a a1 b c. (a -> (a1, b)) -> (a1 -> b -> c) -> a -> c
10:56:39 <Cale> Because LogicT comes with lots of nice operations.
10:57:08 <vixey> Cale, what should be logicT?
10:57:15 <vixey> oh... instead of ListT.. yeah I agree completely
10:57:49 <Cale> vixey: or instead of ChoiceT, though ChoiceT isn't really broken
10:58:01 <leimy> anyway this stuff certainly is at least fun.
10:58:03 <vixey> I've not seen ChoiceT
10:58:10 <Cale> It's in monadLib
10:59:54 <Deewiant> Assuming you don't (want to) use ListT or RWS is there anything special about monadLib?
11:03:42 <Cale> Well, it has more useful functions to use with continuation monads, a way to lift computations from the base monad in any monad transformer stack...
11:05:11 <romildo> Hi.
11:05:11 <Cale> Oh, and a nice bunch of functions to help transferring various operations across an isomorphism between two monads.
11:05:58 <Cale> (Usually with a newtype, though newtype-deriving does a decent job too.)
11:06:10 <Deewiant> Gah, the polymorphism! My eyes!
11:06:21 <Deewiant> Pages upon pages of instances
11:06:24 <Cale> Deewiant: in what, exactly?
11:06:42 <sw17ch> HList is like that :)
11:06:45 <Deewiant> in http://hackage.haskell.org/packages/archive/monadLib/3.4.4/doc/html/MonadLib.html
11:06:46 <lambdabot> Title: MonadLib, http://tinyurl.com/6r8rqt
11:06:52 <romildo> With ghc-6.10.1 I am getting the error:  Ambiguous type variable `e' in the constraint:  `GHC.Exception.Exception e' arising from a use of `catch' at Gui.hs:(253,4)-(254,31) Probable fix: add a type signature that fixes these type variable(s)
11:06:54 <Deewiant> HList is a lot worse
11:07:15 <romildo> With prior ghc this does not happen. How to correct the error?
11:07:16 <Deewiant> romildo: You need to specify, in the type, which exception you want to catch.
11:07:34 <vixey> Cale, ooh what's your take on the unary - ? :)
11:07:45 <Cale> vixey: I'd keep it as is.
11:07:50 <vixey> :(
11:07:51 <vixey> ok
11:07:55 <romildo> Deewiant, I do not even have a type signature to the function
11:08:07 <Cale> It's nice to be able to write -x, for example.
11:08:39 <vixey> well it's nice also to write  |x|  for absolute value
11:08:51 <Deewiant> romildo: The idea is that you shouldn't catch 'every possible exception' like you used to pre-6.10, since that's not usually what you actually want to do.
11:09:04 <Cale> vixey: Ah, you want surroundfix operators? :)
11:09:23 <vixey> actually I do but I more meant that some notations in math are horribly awkward to make formal
11:09:43 <vixey> i.e. how does |x||y| parse?
11:09:45 <Cale> But I think Haskell's done a good job of unary negation.
11:09:49 <vixey> bad example... :/
11:10:00 <Cale> |x|a|y|
11:10:18 <vixey> oh can you invert functions using a zipper?
11:10:19 <Cale> (if juxtaposition is multiplication)
11:10:26 <Cale> hm?
11:10:34 <vixey> or I guess equations in general
11:11:14 <vixey> if you have  3 + (2 * x) = y then a zipper into [x] can be the (inverse) of what you need to do to y to get x
11:11:23 <romildo> Deewiant, the exception may be raised by the function pixbufNewFromFileAtSize from gtk2hs.
11:11:32 <Cale> Ah, like compositions of invertible functions, you mean?
11:11:47 <vixey> yes
11:11:53 <vixey> I should probably try to program ita
11:12:18 <Deewiant> romildo: It's probably an IOException then. (This kind of thing should be documented (but I understand it often isn't)!)
11:14:24 <romildo> Deewiant, I see that the documentation on svn for gtk2hs has been update. It says to catch the exception with System.Glib.GError.catchGErrorJust. So I will try it instead of using catch.
11:19:49 <romildo> Using System.Glib.GError.catchGError instead of catch solved the problem.
11:22:22 <BMeph> mmorrow: ping
11:27:31 <BMeph> Ah, well, let me throw this out to the general population: Is there an "established" feature for transforming an ADT into a form "similar to" another already-established form?
11:28:11 <Cale> BMeph: what?
11:29:20 <Cale> BMeph: Are you perhaps thinking of a catamorphism?
11:29:53 <BMeph> For example: data Natural = Zero | Successor Natural is... I guess I want "isomorphic to" Maybe Natural. Or would that be Mu (Maybe Natural), I guess. :)
11:30:17 <BMeph> Cale: More like a regular way to show isomorphisms between types.
11:30:42 <BMeph> Such as the above one with Nat.
11:30:59 <Cale> hmm... let's say a decision procedure for telling if two types are isomorphic.
11:31:02 <BMeph> Or like how Either () a is isomorphic to Maybe a
11:31:21 <Cale> You can certainly do what djinn does, if the types are not recursive.
11:31:40 <rwbarton> That won't distinguish, say, () and Bool.
11:32:02 <Cale> Well, with a little extra checking.
11:32:06 <BMeph> rwbarton: Eh?
11:32:17 <Cale> (you just have to be careful about what you've used up)
11:33:09 <rwbarton> BMeph: All I mean is, djinn only knows whether there exist functions a -> b and b -> a, and not whether they can be chosen so that the compositions are the identites on a and b.
11:33:14 <rwbarton> @djinn () -> Bool
11:33:15 <lambdabot> f _ = False
11:33:19 <rwbarton> @djinn Bool -> ()
11:33:19 <lambdabot> f _ = ()
11:33:21 <Cale> Djinn will happily derive a function Bool -> (), but if you were to enforce injectivity, that would be enough.
11:33:27 <rwbarton> Whereas,
11:33:30 <rwbarton> @djinn Bool -> a
11:33:30 <lambdabot> -- f cannot be realized.
11:33:38 <rwbarton> So Bool and a are definitely not isomorphic :)
11:34:22 <rwbarton> Anyways, it sounds like what you're interested in is connected to "generic programming" in the sense of SYB, PolyP, etc.
11:34:51 <Cale> Like, it would write f True = (), and then falter when trying to decide what f False should be, since there are no values of () left.
11:35:51 <raxas> q
11:36:18 <sw17ch> do viewpatterns allow me to do something like... v = 1 ; f v = 2
11:36:27 <jsn> i guess the alternative to foldable requiring its first parameter to be of kind * -> * would be for it to require, for example,    Foldable [a] a
11:36:33 <jsn> as a declaration
11:36:34 <sw17ch> where, in this case, f 1  would evaluate to 2?
11:36:41 <jsn> which is inane
11:37:19 <rwbarton> sw17ch: Not really, I think... there is f ((== v) -> True) = 2 but you're probably better off with a guard...
11:37:52 <FunctorSalad> hmm... if (:⊗) is of kind * -> * -> * -> *, why doesn't "x :⊗ y z" work?
11:38:05 <vixey> FunctorSalad, "doesn't work"
11:38:17 <Igloo> It parses as x :⊗ (y z)
11:38:18 <rwbarton> Probably type application has higher precendence than all infix type operators :)
11:38:29 <FunctorSalad> ah that makes sense, thanks
11:38:34 <BMeph> rwbarton: Another point: Either () () is isomorphic to Bool, and so is Maybe (), but...no, way, those are easily er, "isomorphisized"? :)
11:39:05 <vixey> BMeph, sure it's easy, each has two inhabitants just call one true and one false
11:39:40 <dolio> Either () () actually has more values in Haskell, due to bottom.
11:39:43 <b_jonas> BMeph: you could make a typeclass that has both Either () and Maybe as a member, and add all constructors and deconstructors as methods to it, and generalize all utility maybe functions to it
11:39:56 <b_jonas> BMeph: and do the same to Maybe () and Bool
11:39:56 <BMeph> But yeah, I think you're right, rwbarton. I'm looking for something that'll look at, say Nat's definition, and equate 'Suc' with 'Just' without making you have to write it yourself. :)
11:40:11 <BMeph> dolio: More values than what? :)
11:40:27 <dolio> Maybe () and Bool (the former has more than the latter).
11:40:44 <vixey> :t [True,False,fix id]
11:40:45 <lambdabot> [Bool]
11:40:52 <BMeph> dolio: Because of Just _|_, you mean? :)
11:41:03 <dolio> Either () () has Left (), Right (), Left _|_, Right _|_ and _|_. Bool has True, False, _|_.
11:41:05 <dolio> Yeah.
11:41:07 <jsn> dolio: so they are not actually isomorphic?
11:41:14 <dolio> Not in Haskell, no.
11:41:25 <vixey> definition of isomorphic being what?
11:41:42 <rwbarton> BMeph: What these generic programming tools generally give you is a way to write functions which can take arguments of any "nice" type like Natural
11:41:46 <jsn> vixey: bijection
11:42:00 <dolio> There exist functions f :: a -> b and g :: b -> a such that g . f = id and f . g = id.
11:42:05 <olsner> oh, there's #haskell counting bottoms again
11:42:05 <rwbarton> BMeph: In effect the function will view the type Natural as Either () Natural
11:42:39 <BMeph> olsner; (Politicians count noses. In #haskell, we're more direct about it.) ;)
11:43:21 <BMeph> rwbarton: Why not as Maybe Natural? ;)
11:43:35 <lex8899> n00b question
11:43:36 <rwbarton> BMeph: It writes your type as a sum of products of other types
11:43:47 <olsner> BMeph: type Natural = Maybe Natural?
11:43:57 <BMeph> olsner: Exactly. :)
11:43:57 <jsn> consider a function that pattern matches on Maybe () or Either () () -- it will only actually run when there are no bottoms
11:44:03 <lex8899> how to print out the type of a value in ghci?
11:44:15 <jsn> lex8899:    :t 1
11:44:30 <lex8899> brilliant. thank you
11:45:17 <jsn> well, only when it does a full pattern match, i guess
11:45:19 <b_jonas> why, can't you match only the top level constructor of the either, not the unit constructors?
11:45:22 <BMeph> > [] == [undefined]
11:45:23 <lambdabot>   False
11:45:33 <b_jonas> then it would treat Right () and Right undefined the same
11:45:35 <BMeph> Oh, duh:
11:45:39 <jsn> if it matches   Just _ then it won't catch it
11:45:40 <BMeph> > length [undefined]
11:45:42 <lambdabot>   1
11:45:50 <vixey> why take _|_ into account?
11:45:53 <jsn> LOLz
11:46:01 <jsn> haskell is dumb
11:46:07 <jsn> we have all been tricked!
11:46:14 <jsn> safety, my ass
11:46:47 * jsn sneaks away...
11:46:50 <vixey> jsn, type safety sticks around every with _|_
11:47:01 <vixey> even*
11:47:37 <rwbarton> BMeph: For a quite length overview of the area, see http://www.cs.uu.nl/~johanj/publications/ComparingGP.pdf
11:47:40 <lambdabot> Title: Comparing Approaches to Generic Programming in Haskell
11:47:44 <rwbarton> *lengthq
11:47:47 <rwbarton> *lengthy
11:50:03 <BMeph> rwbarton: Right. I think what I want is something functionally equal to 'newtype', just without the single constructor restriction. :)
11:50:24 <b_jonas> BMeph: how would that work?
11:50:41 <BMeph> rwbarton: Of course, what I _Really_ want is to have Natural numbers defined without having to code it all in myself... ;p
11:51:10 <rwbarton> BMeph: You're trying to get around the too-many-bottoms problem?
11:51:12 <b_jonas> just copy from http://www.willamette.edu/~fruehr/haskell/evolution.html
11:51:13 <lambdabot> Title: The Evolution of a Haskell Programmer
11:51:23 <BMeph> b_jonas: Well...if I knew that, it'd be solved, wouldn't it? ;)
11:51:40 <vixey> BMeph, Natural already exists
11:51:43 <b_jonas> BMeph: not necessarily, you still had to hack it to ghc, which might not be easy
11:51:49 <vixey> :t 1 :: Natural
11:51:50 <lambdabot> Natural
11:53:15 <vixey> so Maybe Void ~=~ Either Void Void
11:53:35 <vixey> if you use Void instead of ()
11:53:44 <dibblego> @seen grahamhutton
11:53:44 <lambdabot> I saw grahamhutton leaving #haskell 1d 23h 46m 51s ago, and .
11:54:32 <vixey> hello
11:54:57 <vixey> I mean treat Void as () so you have {undefined} instead of {(),undefined}
11:54:58 <BMeph> So, who's gonna edit lambdabot, so that typing '@dons' does the '@users' command? ;)
11:55:55 <b_jonas> vixey: ah, now that's a nice suggestion
11:56:20 <BMeph> vixey: Yes, rather clever. :)
11:57:47 <vixey> it says "Furthermore, generic functions cannot be applied to generalized algebraic data types"
11:58:01 <vixey> meaning.. there is no approach at all which deals with it?
12:00:52 <jsn> @users
12:00:53 <lambdabot> Maximum users seen in #haskell: 558, currently: 539 (96.6%), active: 23 (4.3%)
12:01:06 <rwbarton> Typically you can only apply generic functions to a subset of the types you can define without GADTs anyways.
12:01:22 <orbitz> is there a common pattern for doing something like url decoding where i'd be itnerating over a string and mostly doing nothing but in some cases turning N characters into 1?
12:01:42 <rwbarton> It's more that the types you can apply generic functions to all happen not to be GADTs. :)
12:01:43 <jsn> orbitz: unfoldr is probably a good start
12:01:53 <orbitz> jsn: tahnks
12:02:02 <vixey> There's a few generic functions you can define for whole universe of strictly positive types
12:02:14 <vixey> (more than just the ones of the paper by that name even)
12:02:55 <Cale> orbitz: I suppose you could use a parser.
12:03:03 <dolio> Constructing Universes for Generic Programming builds a system that works for strictly positive families.
12:03:09 <BrokenClockwork> http://hpaste.org/12367 --> I want to create this list reversed, is it possible to add somewhere reverse?
12:03:09 <rwbarton> orbitz: It's usually very convenient just to define such functions by explicit recursion.
12:03:20 <dons> yay, haskell reddit has a logo, http://www.reddit.com/r/haskell/
12:03:21 <lambdabot> dons: You have 10 new messages. '/msg lambdabot @messages' to read them.
12:03:22 <lambdabot> Title: Haskell
12:03:33 <dons> 10. crikey
12:03:35 <Cale> orbitz: One which has a case which handles an arbitrary character by returning it, but only after trying to parse one of the special sequences.
12:03:49 <sbahra> Hey dons
12:03:57 <dolio> Of course, Haskell GADTs aren't required to be strictly positive.
12:04:04 <sbahra> dons, could you please provide the URL to the list of packages distributed with GHC?
12:04:12 <dons> oh, the list on haskell.org ?
12:04:12 <jsn> orbitz: i think Cale's idea is a good one, too
12:04:14 <sbahra> dons, no results with google/WiKi search.
12:04:18 <sbahra> dons, yes, it's on the WiKi.
12:04:18 <dons> mm
12:04:25 <sbahra> You provided it to me to begin with.
12:04:29 <sbahra> When working with some FreeBSD ports...
12:04:31 <vixey> BrokenClockwork, did you get your parenthesis thing doen?
12:04:42 <BrokenClockwork> yep, it's working now
12:04:52 <BrokenClockwork> here: http://hpaste.org/12368
12:05:16 <dons> http://haskell.org/haskellwiki/Libraries_released_with_GHC
12:05:17 <dons> sbahra: ^
12:05:20 <sbahra> Perfect.
12:05:22 <sbahra> Thanks a lot.
12:05:28 <lambdabot> Title: Libraries released with GHC - HaskellWiki
12:05:45 <Cale> BrokenClockwork: It has a different type, but consider:  tri = [(n*(n+1)) `div` 2 | n <- [0..]]
12:05:57 <Cale> > [(n*(n+1)) `div` 2 | n <- [0..]]
12:05:58 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
12:06:11 <BrokenClockwork> yeah, taht does it well
12:06:18 <lispy> ?oeis 0 1 3 6
12:06:19 <lambdabot>  Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
12:06:19 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
12:06:43 <Deewiant> > scanl1 (+) [0..]
12:06:44 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
12:06:48 <Cale> > scanl (+) 0 [1..]
12:06:49 <b_jonas> I still say buubot's is better because it gives a link to the other matching sequences
12:06:50 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
12:07:09 <BrokenClockwork> scanl ?
12:07:19 <Cale> > scanl f z [1,2,3]
12:07:20 <lambdabot>   [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3]
12:07:39 <BrokenClockwork> oh, ok ;)
12:07:42 <lispy> > scanl f 0 [1..3]
12:07:43 <lambdabot>   Add a type signature
12:07:44 <b_jonas> other 36577 matching sequences, or only other 327 if you restrict to consecutive elements
12:07:49 <lispy> > scanl f 0 [1..3] :: Expr
12:07:50 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
12:08:25 <Cale> > scanl (+) 0 [1,2,3] :: [Expr]
12:08:26 <lambdabot>   [0,0 + 1,0 + 1 + 2,0 + 1 + 2 + 3]
12:08:37 <lispy> yeah, that I just figured out in a different window :)
12:08:37 <pumpkin_> how does it work with just variables?
12:08:45 <pumpkin_> > map f [1, 2, 3]
12:08:46 <lambdabot>   Add a type signature
12:08:53 <pumpkin_> it worked for cale :(
12:09:02 <dejones> Any suggestion on how I might emulate a while-loop in Haskell?  (Without a recursive call to the function (unless it is a recursive call to a function defined with where))
12:09:02 <Cale> > map f [1,2,3] :: [Expr]
12:09:03 <lambdabot>   [f 1,f 2,f 3]
12:09:12 <pumpkin_> fancy!
12:09:22 <dejones> Hey Cale, it's been a while.  How are you?  :)
12:09:25 <pumpkin_> is that built-in, or is there some fancy hack going on behind the scenes?
12:09:26 <Cale> I'm well :)
12:09:34 <lispy> pumpkin_: it's a cool expression building type, it's with lambdabot not sure how else you'd get it
12:09:36 <Deewiant> @where simplereflect
12:09:36 <Cale> dejones: Usually I just use let/where
12:09:36 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
12:09:38 <vixey> BrokenClockwork, here's another solution http://hpaste.org/12368#a1
12:09:39 <Deewiant> pumpkin_: ^
12:09:57 <dejones> Cale: To emulate a while-loop?
12:10:12 <Cale> dejones: yes
12:10:24 <dejones> Cale: Ok, I'll give it a shot, heh.
12:10:32 <BrokenClockwork> vixey: oh, that looks alot smarter, also I don't understand many notations not yet
12:10:34 <vixey> BrokenClockwork, you get  check (Close round (Open round Nil)) :: ()  and  check (Close square (Open round Nil)) gives a type errer
12:10:53 <Cale> dejones: But you could write a combinator version. It's just there are so many slight variations on what you might want, that nothing too appropriate is in the libraries.
12:10:59 <vixey> BrokenClockwork, so it's basically the same as your program except it runs at compile time in the type system :)
12:11:24 <BMeph> dons: I think the next lambdabot should have a @dons command that works like @users... ;)
12:11:25 <dejones> Cale: I'll try the let/where first.  ;)
12:11:28 <BrokenClockwork> what was about the code strip from lulac?
12:11:49 <vixey> yeah lilacs one is the same as yours except one change
12:12:05 <vixey> instead of Nothing for failure it leaves close brackets on the stack (and they can never be popped off)
12:12:05 <lispy> BMeph: tells you how many dons we have?
12:12:21 <vixey> that just lets the program be slightly shorter (but a few order of magnitude more confusing for me)
12:12:29 <yaxu>  coo, there's some great stuff in the haskell subreddit
12:12:57 <vixey> I prefer the types and squiggol reddits
12:13:48 <pumpkin_> Deewiant, lispy: thanks, that looks awesome
12:15:31 <BMeph> lispy: Hmm, not bad - maybe it should tell you how many reddit threads he's started... ;p
12:17:10 <b_jonas> we already have @quote dons
12:17:14 <b_jonas> @quote dons
12:17:14 <lambdabot> dons says: I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
12:19:18 <rwbarton> BMeph: how many haskell packages have been added to arch linux in the past week
12:20:28 <eipi-1> hello
12:21:13 <vixey> hi
12:21:14 <eipi-1> cabal list exists with an error on glob (it says "can't read file")...I could not find how to fix that, any clue?
12:21:42 <b_jonas> @hoogle (Applicative m) => m (a -> b) -> a -> m b
12:21:43 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:21:43 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:21:43 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
12:21:54 <b_jonas> @hoogle (Monad m) => m (a -> b) -> a -> m b
12:21:55 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:21:55 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
12:21:55 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:22:18 <dcoutts> eipi-1: cabal update; cabal install cabal-install; cabal list
12:22:42 <dcoutts> eipi-1: actually, I think just cabal update might fix it.
12:22:54 <eipi-1> I already tried an update
12:23:03 <eipi-1> I'll try the full sequence
12:23:09 <eipi-1> big thanks :)
12:23:56 <b_jonas> @pf \x y -> x >>= \r -> return (r y)
12:23:57 <lambdabot> Maybe you meant: bf pl
12:23:59 <b_jonas> @pl \x y -> x >>= \r -> return (r y)
12:24:00 <lambdabot> flip (fmap . flip id)
12:24:28 <b_jonas> @fp \x y -> x <*> pure y
12:24:29 <lambdabot> \x y -> x <*> pure y not available
12:24:34 <b_jonas> @pl \x y -> x <*> pure y
12:24:34 <lambdabot> (. pure) . (<*>)
12:26:13 <b_jonas> does fp even know what pure and <*> means?
12:26:49 <b_jonas> wait... flip (fmap . flip id) it says
12:26:56 <b_jonas> how does that even work
12:27:19 <monochrom> @unpl
12:27:19 <lambdabot> ()
12:27:28 <monochrom> @unpl flip (fmap . flip id)
12:27:29 <lambdabot> (\ b c -> fmap (\ f -> f c) b)
12:27:41 <b_jonas> yeah, makes sense
12:27:50 <b_jonas> so this doesn't even need Applicative, only Functor
12:28:09 <b_jonas> @hoogle (Functor m) => m (x -> y) -> x -> m y
12:28:09 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:28:10 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:28:10 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
12:28:46 <b_jonas> the unpl is a good idea, it shows how the phrase works nicely
12:28:51 <b_jonas> monochrom++
12:28:58 <damkor> Hi, has anyone ever tried gtk applications written in haskell using debian (arm)?
12:29:20 <damkor> I'm getting a linking error when trying gtk2hs's examples
12:29:32 <Cale> damkor: Are you compiling with --make ?
12:29:36 <damkor> yeap
12:29:38 <b_jonas> damkor: you might need some c libraries
12:29:45 <b_jonas> damkor: which aren't installed with the haskell library
12:29:59 <b_jonas> that is, the haskell library might just be a wrapper over the gtk you already have installed
12:30:11 <pumpkin-> lambdabot doesn't listen to my :t in PM
12:30:14 <pumpkin-> :(
12:30:16 <damkor> hmm, I thought apt would take care of that :(
12:30:20 <b_jonas> perhaps read the README and other installation instructions in the haskell gtk package in case it says what it needs
12:30:29 <b_jonas> damkor: oh, you installed everything with apt?
12:30:36 <damkor> yeap
12:30:57 <b_jonas> damkor: from the repo of your os (as opposed to from random debs downloaded from haskell.org)?
12:31:05 <b_jonas> pumpkin-: try @type
12:31:26 <pumpkin-> aha, that does work, but it gives me the more complete type
12:31:36 <pumpkin-> ah well, works fine :)
12:31:50 <b_jonas> why does the topic still say "GHC 6.10 is out!" when 6.10.1 is out as well?
12:32:00 <damkor> yeap, from debian.org
12:32:09 <b_jonas> damkor: I don't know then
12:32:22 <b_jonas> damkor: apart from what Cale says
12:32:31 <mauke> b_jonas: same thing
12:32:34 <b_jonas> damkor: perhaps paste the exact error message
12:32:47 <sm> hmm, how do I tell parsec to fail the current parse, eg after checking something just parsed
12:32:48 <Deewiant> b_jonas: 6.10.1 was the first 6.10 release
12:32:53 <monochrom> I suppose "6.10" includes "6.10.1"
12:32:55 <mauke> sm: 'fail'
12:32:59 <b_jonas> Deewiant: was it?
12:33:03 <damkor> shall I paste it here or shall I use some online pasting service?
12:33:04 <b_jonas> I thought there was a 6.10.0 too
12:33:12 <Deewiant> b_jonas: 6.10.0 is the release candidates
12:33:14 <b_jonas> damkor: online one
12:33:18 <Deewiant> not 6.10 releases per se
12:33:24 <sm> thanks mauke. not working for me, I must have something else wrong
12:33:29 <b_jonas> I see
12:33:30 <b_jonas> ok
12:33:42 <b_jonas> I thought 6.10.0 was a stable one
12:33:47 <b_jonas> so that's why 6.10.1 came out so fast
12:34:12 <pumpkin-> scanl is pretty weird looking, what are its typical uses?
12:34:17 <b_jonas> I thought a release candidate would either have a name like 6.10.0-RC0 where 6.10.0 is the stable one, or the release candidate would just be called 6.9.something
12:34:41 <monochrom> [0, 0+a, 0+a+b, 0+a+b+c, ...] is a scanl
12:35:15 <b_jonas> damkor: I never used haskell gtk. I had some other linking errors with other libraries but I'm not so good in debugging them either. still, I think an exact error message may help.
12:35:41 <pumpkin-> > scanl (+) 0 [1,2...]
12:35:42 <lambdabot>   <no location info>: parse error on input `]'
12:35:51 <b_jonas> > scanl (+) 0 [1,2,...]
12:35:52 <lambdabot>   <no location info>: parse error on input `]'
12:35:56 <b_jonas> > scanl (+) 0 [1,2,..]
12:35:57 <lambdabot>   <no location info>: parse error on input `..'
12:35:59 <b_jonas> > scanl (+) 0 [1,2..]
12:36:01 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
12:36:08 <damkor> well, the lines are all quite similar
12:36:13 <b_jonas> > scanl (+) 0 [1::Expr,2..]
12:36:14 <lambdabot>   [0,0 + 1,0 + 1 + 2,0 + 1 + 2 + 3,0 + 1 + 2 + 3 + 4,0 + 1 + 2 + 3 + 4 + 5,0 ...
12:36:18 <damkor> Calc.o: In function `s3Ui_ret':
12:36:19 <damkor> ghc1731_0.hc:(.text+0x1330): undefined reference to `gtkzm0zi9zi13_GraphicsziUIziGtkziGeneralziGeneral_mainGUI_closure'
12:36:21 <pumpkin-> > scanl (+) 0 [1,3 ..]
12:36:23 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
12:36:24 <pumpkin-> whee
12:36:29 <pumpkin-> that's what I was trying for
12:36:42 <pumpkin-> thanks, makes sense now :)
12:36:49 <damkor> they all look like that, that's exactly what I get after "Linking calc" on the gtk2hs-docexamples directory
12:36:58 <b_jonas> it's basically the apl backslash (scan) operator
12:37:06 <b_jonas> it's in apl so it must be useful
12:37:38 <b_jonas> (I mean modern apl. historic ancient apl had some human errors.)
12:38:03 <BrokenClockwork> Hey, I have the following issue: I ahvea  fucntion with a [list] input and now I want to create a list of comprehension which creates exactly the input [list], sounds weird, but is this possible?
12:38:21 <monochrom> There are several self-referring uses of scanl for fibonacci, powers of 2, etc.
12:38:25 <BONUS_> hey anyone know how to do big O notation in LaTeX?
12:38:33 <vixey> > let list = [83,9,7,55,5,7,8,9] in [ x | x <- list ]
12:38:34 <lambdabot>   [83,9,7,55,5,7,8,9]
12:38:45 <sm> so I have y <- many digit; let year = read y; when (year <= 12) fail ""  -> complains about the type of the fail
12:38:45 <BrokenClockwork> ah sometimes so easy
12:38:46 <Taejo> BONUS_: $O(n)$ ?
12:38:50 <b_jonas> lst >>= return then?
12:39:10 <BONUS_> hmmm yeah
12:39:19 <BONUS_> but isn't a different glyph usually used for the big O?
12:39:26 <BONUS_> cause in big O notation its like bigger imho
12:39:45 <b_jonas> sm: did you try putting (fail "") in parens?
12:39:54 <b_jonas> BONUS_: I don't think so
12:40:04 <BONUS_> ah
12:40:06 <BONUS_> alrighty then
12:40:08 <sm> b_jonas: brilliant! didn't think of that
12:40:14 <pumpkin-> I just use a normal O
12:40:26 <sm> I haven't used when much
12:40:52 <monochrom> You can try \mathcal(O)
12:40:59 <sbahra> ye
12:41:03 <pumpkin-> I've never seen it typeset as mathcal though
12:41:04 <sbahra> It is a nice big-O
12:41:11 <sbahra> \mathcal{O}
12:41:45 <BONUS_> yeah that was the O i was looking for
12:41:46 <BONUS_> awesome
12:42:06 <opqdonut> mathcal usually imo
12:42:12 <Cale> sm: Don't use fail. Which parsing library are you using?
12:42:17 <sm> parsec 2
12:42:30 <kig> how do i get the time as [micro]seconds since the epoch?
12:42:33 <Cale> sm: Seeing as you're not providing a nontrivial string, use mzero
12:42:55 <Cale> sm: Or better yet,  guard (year > 12)
12:43:01 <sm> I don't understand.. I just want to abort this parse
12:43:14 <sm> so the enclosing try will try the next case
12:43:19 <pumpkin-> BONUS_: I'd stick to a normal O, just been looking around in papers (and my algo book) and they all use a regular big O :) for example, http://www.soe.ucsc.edu/classes/cmps102/Spring04/TantaloAsymp.pdf
12:43:22 <Cale> sm: fail is a misfeature of the Haskell prelude. You should never use it.
12:43:23 <lambdabot> Title: Asymptotic Growth of Functions
12:43:32 <pumpkin-> granted they use ugly smyolbs
12:43:40 <Cale> sm: The appropriate thing to use is mzero
12:43:44 <pumpkin-> but other papers use prettier typography and still use a regular O
12:44:00 <monochrom> mzero is precisely "just want to abort this parse"
12:44:04 <sm> ok.. I think that's pzero in parsec
12:44:08 <monochrom> guard calls mzero.
12:44:15 <Deewiant> ?src guard
12:44:16 <lambdabot> guard True  =  return ()
12:44:16 <lambdabot> guard False =  mzero
12:44:24 <Cale> sm: Parsec has a definition of mzero.
12:44:35 <Cale> mzero is polymorphic, it works in lots of monads.
12:44:50 <monochrom> parsec declares pzero = mzero or the other way round.
12:44:59 <Cale> and yeah, what you're trying to do is already covered by guard
12:45:38 <b_jonas> @src guard
12:45:39 <lambdabot> guard True  =  return ()
12:45:39 <lambdabot> guard False =  mzero
12:45:47 <sm> thanks for the help.. I see how to use pzero/mzero and will look at guard
12:45:48 <b_jonas> @src when
12:45:49 <lambdabot> when p s = if p then s else return ()
12:45:55 <b_jonas> same thing
12:51:31 <plogYy> I can't understand how to use Bool in haskell, can anyone give a link to a clear example?
12:51:50 <mauke> what's the problem?
12:52:00 <mauke> it works like in any other language (with booleans)
12:52:11 <plogYy> I am new to programming
12:52:21 <vixey> plogYy, why do you want to use Bool?
12:52:52 <plogYy> vixey: I don't want to use it, I just can't understand how I would use it
12:52:59 <mauke> depends on your definition of "use"
12:53:06 <b_jonas> a boolean can be true or false
12:53:09 <b_jonas> @src Bool
12:53:09 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:53:12 <mauke> > if 1 == 2 then "what" else "yay"
12:53:14 <lambdabot>   "yay"
12:53:14 <vixey> plogYy, just ignore it then, it shouldn't matter if you aren't using it
12:53:18 <mauke> there, using Bool
12:53:18 <aconbere> Bool it's self isn't a type constructor is it? it only as the Type constructors True and False
12:53:23 <b_jonas> also it's magical in that the builtin syntax if and guards knows about it
12:53:30 <mauke> aconbere: no, True/False are data constructors
12:53:31 <b_jonas> aconbere: yes
12:53:35 <Cale> aconbere: Bool is a type constructor. True and False are data constructors
12:53:36 <b_jonas> aconbere: no
12:53:39 <aconbere> ahh
12:53:41 <b_jonas> aconbere: what mauke says
12:55:00 <plogYy> ok
12:55:25 <plogYy> just wanted to know how i would need or use it in any example
12:55:44 <Cale> plogYy: Usually via 'if'
12:55:50 <b_jonas> plogYy: well, you would need it for numeric comparisions like <
12:55:50 <vixey> plogYy, my advice is not to worry about that until you are actually in that situation
12:55:56 <b_jonas> > 5 < 8
12:55:57 <lambdabot>   True
12:56:01 <b_jonas> that gives a boolean
12:56:29 <Cale> plogYy: The expression (if b then t else e) evaluates to t if b is True, and e if b evaluates to False.
12:56:33 <b_jonas> you can consume that boolean with an if or a guard in haskell, or can treat it like any other haskell value including passing it to a function or returning it from a function
12:56:42 <plogYy> i feel like i can substitue it with if some_condition then status = "ok" so why would i need a bool
12:57:06 <vixey> plogYy, 'bool'?
12:57:55 <mauke> plogYy: some_condition is a bool
12:58:09 <orbitz> Bool
12:59:08 <b_jonas> :t let { x = undefined; _ = if x then undefined else undefined; } in x
12:59:09 <lambdabot> forall a. a
12:59:14 <plogYy> Cale: what would change the value of b? it's a bool, right? why can't i just say if something_is_ok then t else e, can't get the point of the necessity for using a bool
12:59:16 <orbitz> hey sbahra
12:59:30 <sbahra> Hey orbitz!
12:59:42 <b_jonas> plogYy: there's no necessity to ever use a bool
12:59:49 <b_jonas> it's just there for convenient syntax
13:00:02 <Cale> plogYy: Huh?
13:00:02 <b_jonas> you could use any other type that has multiple constructors to store a flag
13:00:13 <b_jonas> but because you'd want to use < and other such builtin functions that return a bool
13:00:15 <plogYy> vixey: i guess so too :) seems i can't imagine it yet, hope there is no problem for not being able to create examples during studying the wikibook
13:00:18 <Cale> plogYy: For instance, parameters to a function being different?
13:00:26 <b_jonas> and because of the easier syntax (ifs and guards)
13:00:33 <b_jonas> you would usually use bools anyway
13:00:53 <aconbere> plogYy: it's important to note that you probably use bools all the time, just the result of expressions that return them.
13:00:55 <Cale> > map (\x -> if isUpper x then 0 else 1) "HeLlO ThErE"
13:00:56 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0]
13:01:02 <plogYy> what does negate mean?
13:01:04 <mauke> > partition even [0 .. 9]
13:01:05 <lambdabot>   ([0,2,4,6,8],[1,3,5,7,9])
13:01:12 <vixey> @w80 negate
13:01:14 <lambdabot> *** "negate" wn "WordNet (r) 2.0"
13:01:14 <lambdabot> negate
13:01:14 <lambdabot>      v 1: be in contradiction with [syn: {contradict}, {belie}]
13:01:14 <lambdabot>      2: deny the truth of [syn: {contradict}, {contravene}]
13:01:14 <lambdabot>      3: prove negative; show to be false [syn: {contradict}] [ant: {confirm}]
13:01:15 <lambdabot> [4 @more lines]
13:01:21 <mauke> > map negate [-4 .. 4]
13:01:22 <lambdabot>   [4,3,2,1,0,-1,-2,-3,-4]
13:01:32 <b_jonas> plogYy: unary negation of numbers
13:01:39 <b_jonas> negate 5 equals to -5
13:02:00 <Cale> > negate 12
13:02:01 <lambdabot>   mueval: Prelude.read: no parse
13:02:05 <Cale> ...
13:02:21 <mauke> haha, what
13:02:36 <mauke> > negate (-12)
13:02:38 <lambdabot>   12
13:02:40 <Cale> that... makes no sense
13:02:42 <mauke> > negate 12
13:02:43 <lambdabot>   -12
13:02:53 <b_jonas> @undo -(5)
13:02:53 <lambdabot> - (5)
13:02:56 <b_jonas> it can't undo that?
13:02:59 <b_jonas> @undo negate 5
13:03:00 <lambdabot> negate 5
13:03:00 <Cale> -.-;
13:03:06 <b_jonas> @do negate 5
13:03:06 <lambdabot> negate 5 not available
13:03:10 <b_jonas> what?
13:03:25 <Deewiant> @help do
13:03:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:03:27 <Cale> b_jonas: undo/redo change between do-notation and >>=
13:03:36 <boyscared> it's been awhile, and i've forgotten how to deinstall a package using cabal. can someone remind me?
13:03:38 <Deewiant> what does @do map to
13:03:38 <BMeph>  @do {negate} 5
13:03:41 <b_jonas> Cale: but they also change some other syntax sugar, not only >>=
13:03:47 <b_jonas> Cale: specifically I think it does list comprehensions
13:03:51 <Cale> yes
13:04:05 <b_jonas> and unary minus is clearly syntax sugar, isn't it?
13:04:07 <Cale> boyscared: You can't. You can unregister it using ghc-pkg though.
13:04:16 <boyscared> ah right. thanks.
13:04:22 <b_jonas> I mean with lambdas and lets and pattern guards and things like that it's not always clear what's basic and what's syntax sugar
13:04:32 <plogYy> Cale: yes
13:04:43 <b_jonas> @redo negate 5
13:04:43 <lambdabot> negate 5
13:05:08 <plogYy> b_jonas: it's like reversing something?
13:05:16 <b_jonas> no
13:05:19 <b_jonas> just negating numbers
13:05:22 <b_jonas> > negate 5
13:05:23 <lambdabot>   -5
13:05:28 <b_jonas> > negate (-5)
13:05:30 <lambdabot>   5
13:06:01 <b_jonas> it's the backend of the unary minus operator
13:06:41 <plogYy> i see
13:06:56 <Cale> It's a bit of an apology for the fact that (-) is subtraction, so if you want to pass a function which negates its parameter to another function, you'd have to use a lambda.
13:07:44 <Cale> There's also subtract, which exists because (-1) and the like are not sections of (-), but negative numbers :)
13:07:49 <olsner> as an apology we've introduced syntactic salt for negation?
13:08:38 <BrokenClockwork> Hey, I've got a heavy run time problem: http://hpaste.org/12371 (this function creates the triangular number n, and lists all dividers/factors) but this is hell slow... I wanted to find a triangular number with more then 500 dividers/factors, but not with this algorithm :(
13:08:44 <vixey> I really dislike that special case
13:08:50 * BMeph prefers syntactic vinegar, especially if it's a nice dark malt
13:08:50 <plogYy> seems like i still have much time to learn :) things seem confusing still
13:09:26 <dons> BrokenClockwork: so what's the question?
13:09:30 <dons> find a different algorithm?
13:09:39 <BrokenClockwork> or optimize this one
13:09:41 <BrokenClockwork> but I guess
13:09:50 <BrokenClockwork> find an alternative alrotihm is easier, isnt it?
13:09:52 <plogYy> thanks for the help
13:10:09 <plogYy> talk to you later :) bye for now
13:10:49 <olsner> BMeph: so is "syntactic salt-and-vinegar chips" a compliment or a complaint?
13:11:29 <BrokenClockwork> to my mind, most of the bugging issue is to find a divider for particular number n
13:11:40 <Cale> BrokenClockwork: uh, it doesn't necessarily find all the factors
13:11:42 <BrokenClockwork> not find a divider, but all...
13:11:42 <sjanssen> BrokenClockwork: the first thing you could do is to only try prime divisors
13:11:52 <acidjnk> I get "parse error on input '='" for "qsort (x:xs) = []". What is wrong?
13:11:59 <BrokenClockwork> why?
13:12:32 <Taejo> acidjnk: sounds like somethings wrong on the previous line
13:12:34 <Cale> BrokenClockwork: It finds triangular numbers corresponding to the divisors of n.
13:13:25 <acidjnk> I am in the prelude interpreter.
13:13:32 <Cale> acidjnk: Your problem is possibly that you're trying to enter declarations into ghci
13:13:38 <Cale> (or hugs)
13:13:41 <inimino> acidjnk: you can't do that
13:13:46 <Cale> acidjnk: Declarations must go in a file.
13:13:46 <acidjnk> Oh, forgot let
13:13:49 <inimino> acidjnk: you can use let though
13:13:55 <olsner> hmm, once you find one divider != 1 you can reduce the rest of the problem considerately... if the list of *all* divisors is interesting, you can take the list of factors and map the product on the power set
13:14:00 <BrokenClockwork> Cale: my fault I copied the wrong code
13:14:05 <acidjnk> Yes, and I did so for the qsort [], but here I forgot, thanks :-)
13:14:18 <acidjnk> Those are the things that really take my time :-)
13:14:22 <Cale> acidjnk: If you're going to use let, you have to squish the whole declaration onto one line.
13:14:30 <BrokenClockwork> http://hpaste.org/12373 <- this is the real code
13:14:33 <Cale> (using semicolons to separate the cases)
13:14:50 <mauke> :{
13:14:50 <BrokenClockwork> this one does: creates the triangular number n, and lists all dividers/factors
13:14:51 <mauke> :}
13:15:18 <Cale> BrokenClockwork: No it doesn't.
13:15:22 <BrokenClockwork> mh
13:15:39 <BrokenClockwork> not?
13:15:43 <Cale> BrokenClockwork: That finds the first n triangular numbers.
13:16:03 <sw17ch> is there a good way to do string interpolation in haskell yet?
13:16:07 <sw17ch> (no, not 6.10)
13:16:17 <BrokenClockwork> oh I am getting confused
13:16:19 <vixey> better than " ++ show (...) ++ "?
13:16:21 <Cale> sw17ch: concat ["hello", x, "world"]
13:16:25 <mauke> sw17ch: printf
13:16:28 <vixey> aha beaten
13:16:30 <vixey> :D
13:16:32 <sw17ch> Cale, vixey, that's whati 'm doing
13:16:33 <sw17ch> hehe
13:16:41 <sw17ch> well, i guess printf would be better here....
13:16:42 <vixey> and what would you rather do?
13:16:45 * sw17ch is scared of rpitnf
13:16:45 <vixey> ok
13:16:48 <sw17ch> wow
13:16:50 <quicksilver> HStringTemplate?
13:16:50 <sw17ch> printf
13:16:54 <quicksilver> or whatever it's called
13:17:01 <Cale> printf is silly.
13:17:04 <quicksilver> would be a more sophisticated approach for larger stuff.
13:17:06 <sw17ch> quicksilver: what package is that in?
13:17:15 <olsner> vixey: why waste time asking followups when you can be spewing answers instead? :)
13:17:16 <sw17ch> I'm autogenerating a bunch of C code for a project at work
13:17:16 <mauke> printf is awesome
13:17:19 <vixey> I like the type safe printf better
13:17:22 <olsner> printf++
13:17:25 <vixey> olsner hahaha
13:17:30 * sw17ch switches from concat to printf
13:17:31 <sbahra> > show printf "%3d 2
13:17:32 <lambdabot>   <no location info>:
13:17:32 <lambdabot>      lexical error in string/character literal at chara...
13:17:35 <quicksilver> @go hstringtemplate
13:17:37 <lambdabot> No Result Found.
13:17:38 <monochrom> printf or pretty-printer
13:17:40 <quicksilver> hmph
13:17:41 <sbahra> > show $ printf "%3d 2
13:17:42 <lambdabot>   <no location info>:
13:17:42 <lambdabot>      lexical error in string/character literal at chara...
13:17:43 <sbahra> fk
13:17:43 <quicksilver> maybe it wasn't called that
13:17:45 <sbahra> > show $ printf "%3d" 2
13:17:47 <lambdabot>   Add a type signature
13:17:52 <quicksilver> it was an sclv package.
13:17:56 <mauke> > ""++ printf "%3d" 2
13:17:57 <lambdabot>   "  2"
13:18:03 <sbahra> >  printf "%3d" 2
13:18:05 <lambdabot>   Add a type signature
13:18:06 <mauke> > ""++ printf "%.3d" 2
13:18:07 <lambdabot>   "2"
13:18:14 <sbahra> i fail
13:18:21 <hd_> should this work: boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]   (from learn you a haskell tutorial) ?
13:18:24 <mauke> ^ if you need that feature, get Text.Printf.Mauke
13:18:26 <sbahra> :t printf
13:18:27 <Cale> printf is not really type safe, and uses an arcane syntax for formats.
13:18:27 <lambdabot> forall r. (PrintfType r) => String -> r
13:18:28 <vixey> @let turnWhateverThisIsIntoAString = (""++)
13:18:29 <Saizan> Language.C ?
13:18:30 <lambdabot>  Defined.
13:18:37 <vixey> There is _a_ typesafe printf though
13:18:39 <sw17ch> Saizan: not that big
13:18:40 <BrokenClockwork> okay, another try, how do I find all dividers of a number
13:18:50 <Cale> hd_: yes
13:18:51 <BrokenClockwork> or what's good approach for a algorithm?
13:19:35 <hd_> oh ok, it does- my error
13:19:39 <inimino> Cale: doesn't it use the standard C syntax?
13:19:44 <Cale> inimino: It does.
13:19:50 <hd_> didn't seem to work in ghci though?
13:19:53 <mauke> inimino: not quite, it has a few bugs
13:20:04 <inimino> ah
13:20:05 <Cale> hd_: Your problem is that ghci wants expressions and that's a declaration.
13:20:11 <shepheb> BrokenClockwork: find the prime factors, take their power set, and map product on it?
13:20:15 <Cale> hd_: Put declarations in a file and load it into ghci
13:20:18 <mauke> (which is why I wrote a replacement)
13:20:23 <hd_> ah kk, thanks ;)
13:20:28 <olsner> > fix (printf "a%s") :: String
13:20:30 <lambdabot>   "a* Exception: stack overflow
13:20:31 <BrokenClockwork> prime factors of what?
13:20:33 <shepheb> but that's probably slower than just checking every number <= the sqrt
13:20:38 <olsner> still not fixed :)
13:20:41 <BrokenClockwork> or do you mean all prime factors?
13:20:41 <inimino> mauke: ok
13:20:49 <Dirk99> BrokenClockwork: Is that a Project Euler problem?
13:20:52 <shepheb> BrokenClockwork: you wanted all the divisors of a number, right?
13:21:17 <BrokenClockwork> well, of a triangular number to be exactly
13:21:32 <BrokenClockwork> Project Euler? Dirk99 =
13:21:38 <SubStack> project euler \m/
13:22:42 <b_jonas> olsner: lol
13:22:43 <SubStack> you don't actually need to check all the factors for that one
13:22:46 <Cale> BrokenClockwork: If you want a hint, the prime factors of n*(n+1)/2 are the prime factors of n union the prime factors of n+1, with a single 2 removed.
13:23:08 <Dirk99> BrokenClockwork: In case it's Problem #12, you don't need the exact factors, you just need their number.
13:23:21 <b_jonas> olsner: it's just emulating C printf which specifically states the dest string can't overlap with the string you print
13:23:27 <SubStack> it's also bounded further between factorials
13:23:43 <SubStack> like from that other problem
13:23:44 <BrokenClockwork> with a single 2 removed as in (-) 2 ? :)
13:23:49 <BrokenClockwork> ok thanks Cale
13:24:29 <Cale> If you know the prime factors of a number, you know how many divisors it has -- if n = p_1^n_1 * ... * p_k^n_k, then n has (n_1 + 1)*...*(n_k + 1) divisors.
13:24:45 <Cale> (where p_1,...,p_k are distinct primes)
13:25:55 <b_jonas> and n_i is positive for all i
13:25:56 <monochrom> What are all the divisors of 2^a 3^b ?  This program collects them all in a list:  do {x <- [0..a]; y <- [0..b]; return (2^x * 3^y)}.  There are optimizations and generalizations.
13:25:56 <b_jonas> yeah
13:26:20 <acidjnk> I vaguely remember a way in ghc to print the calculation steps very verbose. For example I have "let product [] = 1; product (x:xs) = x * product xs" and want to see the whole calculation for product [2,3,4]. How can I do that?
13:26:21 <b_jonas> monochrom: that's where that ZipThingy applicative comes in, right?
13:26:34 <monochrom> I don't know ZipThingy applicative.
13:26:51 <monochrom> I just use "sequence" for the general case.
13:27:14 <sw17ch> is there an upper limit on how many arguments printf can take?
13:27:34 <monochrom> Yes. The compiler is the limit.
13:27:44 <Cale> So if you want something to have, let's say exactly 500 divisors, 500 = 10 * 10 * 5 = 2 * 2 * 5 * 5 * 5, one way to get that number of divisors is to be of the form p_1 * p_2 * p_3^4 * p_4^4 * p_5^4.
13:27:45 <acidjnk> maybe 2^(31 - 1) or something :-)
13:27:46 <sw17ch> is it in the 10's or the hundreds
13:27:51 <sw17ch> monochrom: ^^
13:27:55 <mauke> sw17ch: more like 100k
13:27:58 <lispy> What is the big-O of Dama-Milner?
13:27:59 <sw17ch> mauke: thanks :)
13:28:00 <acidjnk> 2^31 - 1 I mean
13:28:02 <FunctorSalad> is there a flag that makes ghc dump more info related to the instance-finding process? (neither -ddump-tc nor -ddump-rn seems to do)
13:28:11 <mauke> lispy: O(n^2), I think
13:28:42 <monochrom> I don't write "real world" code, so I don't know compiler limits.
13:28:50 <FunctorSalad> :D
13:29:07 <lispy> mauke: next question, what is n?
13:29:23 <monochrom> n is the nth English letter.
13:29:27 <mauke> good question
13:29:37 <lispy> monochrom: *symbol crash*
13:29:38 <mauke> preflex: remember <monochrom> n is the nth English letter.
13:29:49 <mauke> cymbal clash!
13:29:53 <Cale> acidjnk: Probably the only real limit is how much memory is in your machine for the compiler to consume.
13:30:08 <monochrom> No symbol crash or clash.  I'll also gladly say, b is the bth English letter.
13:30:18 <FunctorSalad> (-ddump-absolutely-everything?)
13:30:19 <BrokenClockwork> thanks Cale, this is really helpful
13:30:39 <olsner> monochrom: let me guess, x is the xth?
13:30:51 <monochrom> It is the same thing as: 6 is the 6th positive integer.  Self-definition, why not use the thing itself for counting, etc.
13:30:55 <FunctorSalad> (I'd like to see the types assigned to all the expressions, to see why it thinks there isn't an instance)
13:31:12 <lispy> But seriously, what is it that you measure as in put to the type checker when you say that it runs in O(n^2)?
13:31:20 <lispy> s/in put/input/
13:31:41 <olsner> size of the program perhaps?
13:32:14 <Cale> The type checker is exponential time and space, at least. Even just plain HM.
13:32:17 <olsner> (not saying that is what I think n actually is, but that would be the useful quantity to go on)
13:32:17 <vixey> whe worst case of a type checker is hardly relevant
13:32:32 <mauke> ok, 2^n then :-)
13:32:52 <Cale> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
13:32:53 <kynky> isnt 6 the 7th positive integer, but the sixth natural number ?
13:32:54 <lambdabot> forall t. t -> ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((
13:32:54 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((
13:32:54 <lambdabot> t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((
13:32:54 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), (
13:32:56 <lambdabot> (t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t))
13:32:57 <monochrom> O(n^2) where (^) = flip Prelude.(^)
13:32:59 <lambdabot> , ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), (
13:33:02 <lambdabot> (t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
13:33:24 <Cale> That's interesting, it didn't stop after 5 lines.
13:33:31 <opqdonut> hehe
13:33:45 <vixey> kyknky, what's your definition of natural number?
13:34:10 <monochrom> and what's your "positive", too?
13:34:19 <kynky> the same as for mathematics, not include 0, the set[1,2,3,4,...n]
13:34:27 <monochrom> But in any case, "0 is the 0th number" will resolve all problems.
13:34:31 <Saizan> what's the difference between Damas-Milner and Hindley-Milner? is one an extension of the other?
13:34:42 <kynky> thats just 0 based indexing
13:35:04 <monochrom> If you open up a set theory book, you will see 0 as a natural number.
13:35:10 <Cale> Saizan: I have the impression that they're the same thing.
13:35:30 <vixey> kynky, I usually go with set that contains either 0 or 1 and closed under the operation sucessor
13:35:38 <BrokenClockwork> Cale: But will your approach tells me, how many divisors number n has and not a list of all diviors?
13:35:41 <Cale> monochrom: If you open pretty much any mathematics book which is not specifically about number theory, you'll find that 0 is a natural number :)
13:35:58 <vixey> Cale, like a book on analysis?
13:35:59 <monochrom> analysis books also rule out 0.
13:36:02 <vixey> hehe
13:36:10 <Cale> oh?
13:36:14 <Cale> Since when?
13:36:17 <vixey> Cale, the sequence (1/n)
13:36:18 <monochrom> Since Rodin.
13:36:26 <vixey> it's 1,1/2,1/3,...
13:36:32 <monochrom> Oops, since Royden
13:36:37 <Cale> Rudin?
13:36:50 <smtms> 0 being a natural number is unnatural, untl one studies set theory
13:37:14 <kynky> the graph y=x/x is crazy, not a straight line :)
13:37:26 <monochrom> 1 being a number is also unnatural, until one grows out of Greek culture.
13:38:00 <jsn> wow, my copy of RWH just shipped
13:38:03 <monochrom> You even see its relic in most European languages.  "I have a number of wives!"  That number is assumed not 0, not 1.
13:38:30 <vixey> I find R very unnatural.. I wish people would use C by default instead of R
13:38:33 <Cale> I'm not sure about that, most of my sequences were either explicitly quantified, or one would just take the domain of the sequence (1/n) to obviously exclude 0
13:38:40 <b_jonas> I think analysis books are indifferent on whether you count from 0 or 1
13:38:46 <monochrom> If you open up Euclid's Elements for his gcd explanation, you see "1" not being treated as a number.
13:38:58 <Cale> There are plenty of cases in analysis where you want 0 to be a natural as well.
13:39:13 <b_jonas> they might use 1 in notation, but basically you just have to replace 1 with the first natural number at a few places and similar, and the whole analysis book works without much changes
13:39:30 <BMeph> Saizan: Damas made a proff that Milner's algorithm does what it says it does. Hindley and Milner independently came up with algorithms to do it. :)
13:39:42 <b_jonas> 1/n is no problem, the first finite number of elements can be ignored for most properties anyway
13:39:51 <vixey> BMeph, whow does the proof go?
13:40:00 <Saizan> BMeph: ah, so it's a Damas-Hindler-Milner algorithm :)
13:40:48 <monochrom> Rudin seems to be smart. He just doesn't say "natural". He says "positive integers".
13:40:52 <olsner> @. type pl  let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
13:40:54 <lambdabot>     Occurs check: cannot construct the infinite type:
13:40:54 <lambdabot>       b = ((b, b), (b, b))
13:40:54 <lambdabot>     Probable cause: `join' is applied to too few arguments
13:40:59 * vixey writes N_+
13:41:01 <olsner> @pl bug!
13:41:01 <lambdabot> (line 1, column 5):
13:41:02 <lambdabot> unexpected end of input
13:41:02 <lambdabot> expecting white space or simple term
13:41:05 <b_jonas> but I too believe that zero is a natural number
13:41:25 <vixey> b_jonas, I thought it was a matter of definition :)
13:41:29 <BMeph> Saizan: That's usually how it's referenced. Although, for some reason, they hyphenate Hindley-Milner as if they collaborated to make one method.
13:41:32 <b_jonas> vixey: yep, it is
13:41:34 <monochrom> Anyway, my original point was that "as in mathematics, the set {1,2,3...}" is ignorant of mathematics.
13:41:37 <b_jonas> vixey: and for most things either way works
13:41:48 <smtms> 3 is the fist natural number in my theory :-P
13:41:59 <kynky> lol
13:42:04 <b_jonas> vixey: but I think that "in reality" natural numbers start from 0
13:42:05 <BMeph> vixey: read http://groups.csail.mit.edu/pag/6.883/readings/p207-damas.pdf if you're curious. :)
13:42:07 <lambdabot> Title: cache:http://groups.csail.mit.edu/pag/6.883/readings/p207-damas.pdf - Google Sea ...
13:42:12 <vixey> BMeph, thanks
13:42:27 <b_jonas> counting gets ugly if you think naturals start from 1
13:42:38 <vixey> everything is ugly if you use R instead of C
13:42:42 <b_jonas> I mean
13:42:53 <Cale> b_jonas: "in reality" they start wherever you define them to start ;)
13:43:02 <kynky> based on index
13:43:14 <b_jonas> Cale: no, that's in theory
13:43:17 <Cale> Mathematics is *entirely* determined by convention.
13:43:32 <b_jonas> in reality is the definitions the Book uses
13:43:34 <kynky> well this is a haskell channel :)
13:43:36 <Cale> It's a man-made construction.
13:43:48 <vixey> Cale, not sure about that.. lots of things come up naturally over and over again in different areas of math
13:43:48 <b_jonas> and that's well-defined for it uses the definition so that proofs are the most elegant
13:43:53 <BMeph> Since Damas and Milner actually worked together for the proof, Damas-Milner makes sense. Hindley-Milner should maybe be Hindley/Milner to accentuate their independent work on a common problem.
13:43:58 <Cale> vixey: Sure.
13:44:11 <Cale> vixey: In ways which are natural to us.
13:44:16 <monochrom> This debate comes up naturally, too.
13:44:20 <BMeph> vixey: Why N_+? Why not Z+? ;p
13:44:23 <vixey> hehe
13:44:25 <monochrom> Oh, and over and over again, too. :)
13:44:50 <monochrom> why not Z^+
13:44:51 <b_jonas> BMeph: because some people use R_+ to mean nonnegative reals
13:44:51 <BMeph> monochrom: Sounds like bulemia... ;p
13:45:14 <Cale> I think it's a bit foolish to consider that mathematics might exist without us. Who is going to create it?
13:45:23 <Jarvellis> Cats
13:45:25 <monochrom> Rats
13:45:31 <Jarvellis> Bats
13:45:33 <kynky> cant remember if this is exactly right, but e^(-i.pie) = -1 came up in lots of different maths modules, well derving proofs anyway
13:45:34 <yuuki> Cale, the universe still has rules even if we aren't around
13:45:39 <Cale> yuuki: Does it?
13:45:41 <BMeph> b_jonas: ...and? (There is more to the argument, right? Please? ;)
13:45:55 <Cale> yuuki: Rules are things which we create, aren't they?
13:46:01 <yuuki> Cale, sure.  So you think if the Earth blew up then the laws of physics would spontaneously became incomprehensible?
13:46:06 <b_jonas> BMeph: well, if it's like that, Z_+ could also mean nonnegative integers
13:46:08 <Cale> yuuki: That serve to predict our observations.
13:46:25 <Cale> yuuki: There would be nobody around to comprehend it.
13:46:32 <b_jonas> BMeph: but N_+ is unambiguous for it wouldn't make much sense to use N_+ for nonnegative natural numbers
13:46:42 <monochrom> Some people write R^{>0} just to be sure.
13:46:54 <Cale> The question of whether it was comprehensible would cease to have meaning.
13:46:58 <olsner> hmm, a mathematical model of a world would always include mathematics as the basis of the model, regardless of whether it models mathematicians
13:46:58 <yuuki> Cale, I don't see how the presence of humans has any bearing on the fundamental algorithm of the universe :)
13:47:03 <kynky> some mathematicians are sticklers
13:47:15 <olsner> yuuki: you're assuming the existence of a fundamental algorithm
13:47:18 <BMeph> yuuki: Is a thing nothing more than the "laws" which describe it? Are you nothing more than the description of you? ;)
13:47:21 <b_jonas> for some time I didn't understand why if Jesus was crucified on a Friday and rose from the dead the third day from that the rising from the dead is still on a Sunday
13:47:24 <Cale> yuuki: Without someone around to say what an algorithm is, it doesn't seem to matter much.
13:47:35 <b_jonas> and the answer is, that "third day" is one-based
13:47:45 <yuuki> Cale, sure it does.  It matters to every piece of matter.  A rock cares whether or not it falls :)
13:48:04 <b_jonas> that's the sort of thing why I think natural numbers start from zero
13:48:17 <b_jonas> ordinals (especially infinite ones) just don't work well if you start from one
13:48:24 <kynky> well its all relative, hehe
13:48:34 <b_jonas> for finite ones you can just get away with some extra subctractions of one and addittions of one
13:48:34 <Cale> yuuki: Scientific laws don't mean anything if you can't conduct an experiment because you don't exist.
13:48:44 <b_jonas> but for infinite it gets worse
13:48:46 <yuuki> Cale, rocks can conduct experiments
13:49:02 <yuuki> Cale, every piece of matter can "observe"
13:49:06 <geezusfreeek> interesting conversation, just walked in on it
13:49:25 <yuuki> Cale, now who's assuming things? :)
13:49:38 <monochrom> Everyone is assuming things.
13:49:40 <Cale> yuuki: On the other hand, I'd be willing to bet that rocks aren't going to come up with Newton's laws.
13:49:42 <geezusfreeek> yuuki, is that assumption useful at all? what scientific purpose does such an assumption serve?
13:49:43 <smtms> Cale, the discussion about science is on #netbsd tonight
13:49:57 <kynky> monochrom, thats the biggest assumption yet
13:50:00 <smtms> it started with Haskell vs. Lisp
13:50:00 <b_jonas> Cale: sure, they don't get hurt if an apple falls on their head
13:50:34 <yuuki> geezusfreeek, I'm just trying to call into question the idea that humans are so important that the information content of the entire universe depends on our existence
13:50:55 <kynky> b_jonas, depends on the mass of the apple and the mass of the planet your on and the gravitational constant G
13:50:57 <Cale> yuuki: I didn't say that.
13:51:10 <geezusfreeek> yuuki, it isn't about importance. it's about what "observation" is
13:51:17 <Cale> yuuki: I said that the *laws* which we've written down wouldn't exist without us.
13:51:24 <tibbe> hmm, anyone have time to help me debug a parse error caused when compiling a file with hsc2hs?
13:51:34 <yuuki> Cale, no disputing that one :)
13:51:38 <monochrom> You should put your * around "we".
13:51:52 <b_jonas> oh, philosophy
13:51:54 <Cale> yuuki: I don't believe in an objective reality.
13:52:02 <yuuki> Cale, I'm claiming that we right down laws that are similar to the laws that anyone would write down if they lived in the universe
13:52:27 <kynky> thats what theorems are for
13:52:30 * BMeph prefers to left down laws than to right them
13:52:32 <yuuki> Cale, why would our laws correspond to the laws that another intelligent entity would write down?
13:52:43 <geezusfreeek> yuuki, i think we write laws the way we do because that is how we think, not because they are objectively true
13:52:53 <b_jonas> so Haskell would exist on other planets in the universe too only it wouldn't be written in ascii and monads wouldn't have fail?
13:53:14 <monochrom> I don't understand how native speakers of English choose their emphases. In every novel I read, whenever there is an emphasized word, it is always 1 or 2 away from the word I think should logically receive the emphasis.
13:53:18 <kynky> b_jonas, sepends how many monkies and typewriters they have
13:53:31 <Cale> yuuki: I disagree. There's no particular reason to believe that aliens who might experience the universe very differently and have a different history from ours wouldn't come up with very different looking explanations.
13:53:37 <b_jonas> monochrom: that's why they emphasize
13:53:37 <geezusfreeek> monochrom, i suspect that is exactly why the emphasis is made explicit ;)
13:53:49 <b_jonas> monochrom: when it's obvious which word is important they don't need to emphasize it
13:53:51 <yuuki> ... , sure.  But do you not agree there is a reason why we say that "gravity" draws matter together instead of apart?
13:54:27 <kynky> well until we can have negative mass, then it will do the opposirte
13:54:44 <yuuki> kynky, don't jump to conclusions!!  It's all in your head!
13:54:53 <Cale> The reason lies in our particular definition for matter, together, and apart.
13:54:57 <Cale> and our observations
13:55:00 <yuuki> Cale, sure
13:55:04 <geezusfreeek> yuuki, as an example of cale's point, there is a tribe in south america (i think) who interpret our journey through time as walking backward rather than forward. think of the ramifications that might have on what physics is!
13:55:25 <yuuki> Cale, but if we take certain definitions then we our bound to certain conclusions
13:55:41 <Cale> I can imagine a scientific alien race which didn't have a definition of matter. You don't technically need one.
13:55:55 <Cale> In fact, I can imagine us discarding that definition without too much harm.
13:55:58 <yuuki> Cale, I don't dispute that we can have different definitions.  But the difference in definitions creates a differences on the specific words we use, not on the structure of the underlying truth
13:56:01 <kynky> or have no definition of time
13:56:10 <FunctorSalad> how would you determine whether they have a definition of <anything>, in general? ;)
13:56:11 <monochrom> I still don't understand.  Suppose there is a flame war.  「A: "you did it."  B: "no, you did it."」  Here is my ideal of emphasis.  「B: "no, *you* did it."」  But here is what novels do: 「B: "no, you *did* it."」  I don't understand why emphasize "did"; it's hardly the point, the point is "you, not me".
13:56:23 <Cale> yuuki: It's this 'underlying truth' that I don't believe in.
13:56:47 <Cale> yuuki: Simply because we can't know what it is, and even if we had it, we couldn't tell that we did.
13:56:57 <FunctorSalad> monochrom: the point could be whether B did it
13:57:02 <Cale> yuuki: So... Ockham's razor :)
13:57:14 <FunctorSalad> monochrom: with B denying *and* going on the counterattack in one step
13:57:17 <b_jonas> monochrom: maybe you're reading the bad kind of books
13:57:19 <jsn> monochrom: maybe you can give us a concrete example from a real book?
13:57:30 <yuuki> Cale, you don't have to know the underlying truth
13:57:31 <kynky> cat+box+poison ?
13:57:37 <Deewiant> monochrom: I run into that a lot too. Still, I do think it's the exception rather than the rule, you just remember it because it stands out :-)
13:57:45 <b_jonas> monochrom: try Arany János's poems, he uses italics the best way anyone does
13:57:52 <Cale> yuuki: Assuming that it exists seems unnecessary to me.
13:57:52 <yuuki> Cale, is your name Cale?
13:57:56 <Cale> yes :)
13:58:01 <geezusfreeek> yuuki, what is the use of an underlying truth?
13:58:05 <yuuki> Cale, what?  How did you know that?
13:58:15 <dejones> yuuki: No no, his name is grandmaster Cale.  :)
13:58:16 <kynky> are you a good lier ?
13:58:21 <monochrom> I can't give a quotable example from a book. But I can quote Cale again... he emphasized "laws" when I think the point is not "laws" but "we".
13:58:31 <FunctorSalad> seriously, I don't see how to do any communication whatsoever with an arbitrary alien
13:58:36 <FunctorSalad> (alien lifeform)
13:58:37 <dejones> yuuki: Or maybe lambdamaster Cale.  :D
13:58:44 <monochrom> So either Cale is an example of bad writers, or I still don't get it.
13:58:45 <geezusfreeek> monochrom, i think he meant "laws" as opposed to "truths"
13:58:52 <Deewiant> monochrom: I think that was fine.
13:59:05 <monochrom> OK I will never get it. I'm too logical.
13:59:14 <FunctorSalad> (much less compare their logic and physics to ours)
13:59:15 <dejones> Cale: Ever used Data.Binary package?
13:59:19 <yuuki> I think that the observer's perspective is a relevant perspective.  I don't think that requires ditching the universal perspective
13:59:26 <Cale> monochrom: I chose to emphasise that word, but I won't argue that there are others which are equally good to emphasise.
13:59:31 <geezusfreeek> yuuki, what *is* the universal perspective?
13:59:42 <kynky> yuuki, like i said earlier its all relative
13:59:48 <yuuki> A start state and a rule
13:59:52 <Cale> yuuki: Do you mean the collective agreement of humans?
13:59:55 <yuuki> That's what a universe is :)
13:59:55 <geezusfreeek> yuuki, can you identify it?
14:00:01 <monochrom> And also my attempt at derailing the philosophy has grossly failed. :)
14:00:07 <yuuki> I can identify large chunks of it
14:00:14 <Cale> dejones: I've looked at it.
14:00:27 <Cale> dejones: I haven't actually put it to use.
14:00:29 <FunctorSalad> monochrom: forget my explanation of the emphasis - I thought the "did" in A's part was emphasized
14:00:30 <geezusfreeek> yuuki, my point is that if you can't identify it then it isn't a useful assumption to reason about the universe
14:00:33 <dejones> Cale: You mind taking a look at my code?  It works, but maybe you have some design improvement suggestions?  :)
14:00:45 <monochrom> Ah ok, I feel better. :)
14:00:56 <Cale> dejones: Paste it somewhere and the whole channel can take a look :)
14:01:14 <dejones> Cale: Ok.  ;)
14:01:22 <yuuki> geezusfreeek, how does that follow?  I can't identify how the Intel Core 2 Duo processor works.  Does that mean it's a useless assumption to say that it exists and to try to understand it?
14:01:24 <geezusfreeek> yuuki, and if you *can* identify it, then it's still only an observation
14:01:45 <monochrom> Haskell beta-reductions are unobservable.
14:01:48 <geezusfreeek> yuuki, but you can observe that a core 2 duo exists
14:01:56 <yuuki> geezusfreeek, how?
14:02:06 <pumpkin_> the sticker on your laptop
14:02:08 <Beelsebob> yuuki: by looking inside your computer
14:02:16 <Botje> monochrom: not if you compile haskell for a 1hz cpu :)
14:02:21 <FunctorSalad> because they told you it is one? ;)
14:02:22 <yuuki> geezusfreeek, how is that any different from observing that a universe exists?
14:02:22 <DukeDave> Wow, clearly I've come in during some very very meta conversation :)
14:02:23 <sw17ch> how do i apply a list of functions to an argument returning a list of the result?
14:02:23 <geezusfreeek> yuuki, you just flipped your argument around on itself i think
14:02:27 <EmielRegis> core 2 processors are actually quite cool internally ;)
14:02:35 <wagle> single step the cpu
14:02:39 <Botje> sw17ch: map ($arg) [fun1,fun2,...]
14:02:40 <geezusfreeek> yuuki, it's not at all. they are both observations
14:02:43 <kynky> same way as australia existing, someone says so, just unable to dispute it :)
14:02:45 <monochrom> Oh, some reductions are unobservable because they're skipped by lazy evaluation!
14:02:50 <zimbatm> hi
14:03:00 <Cale> sw17ch: Botje's way, or  sequence [fun1,fun2,...] arg
14:03:00 <yuuki> geezusfreeek, ... observations are caused just like any other phenomena we observe
14:03:12 <Cale> sw17ch: (but make sure to import Control.Monad.Instances)
14:03:23 <yuuki> geezusfreeek, do you deny that there are causes in the universe which create our observations?
14:03:25 <geezusfreeek> yuuki, we observe observations?
14:03:26 <Botje> > sequence [a,b,c,d] x :: [Expr]
14:03:27 <Beelsebob> sw17ch: Cale or Botje's way, or [fun1, fun2, fun3] <*> [arg]
14:03:27 <lambdabot>   Couldn't match expected type `t -> Expr'
14:03:29 <wagle> woot!  my death is unobservable!
14:03:30 <sw17ch> ah, i wanted Cale's way
14:03:32 <sw17ch> :)
14:03:42 <geezusfreeek> yuuki, i can neither confirm nor deny that
14:03:43 <dejones> Cale and everyone: http://hpaste.org/12376#a1
14:03:48 <zimbatm> is there a way to choose how a certain type is displayed by the "print" function ?
14:03:50 <Cale> yuuki: There are different definitions of "universe" which are equally useful, or useful in different circumstances though.
14:03:53 <yuuki> geezusfreeek, so you think that our observations are uncaused?
14:03:53 <Beelsebob> > [f,g,h] <*> pure x :: [Expr]
14:03:54 <lambdabot>       Ambiguous occurrence `pure'
14:03:54 <lambdabot>      It could refer to either `Control.Appl...
14:03:55 <geezusfreeek> i haven't observed these causes
14:03:57 <Cale> yuuki: Don't you agree?
14:03:57 <vixey> dejonas, cannot read it at all
14:04:01 <vixey> dejonas, bad names
14:04:02 <Beelsebob> > [f,g,h] <*> [x] :: [Expr]
14:04:03 <lambdabot>   [f x,g x,h x]
14:04:04 <FunctorSalad> if you want to get really pedantic, making sense out of observations requires a-priori assumptions
14:04:05 <Botje> zimbatm: write the Show instance yourself
14:04:16 <monochrom> zimbatm: Yes, for your type, write your Show instance.
14:04:16 <yuuki> Cale, I don't agree that regarding the universe as causeless is productive
14:04:16 <vixey> dejonas, write everything in full is 'Pp' a word?
14:04:23 <geezusfreeek> yuuki, no, i don't think anything about the existence of causes for my observations. i *theorize* about them
14:04:29 <dejones> vixey: huh?
14:04:30 <wagle> gotta add some zen here
14:04:42 <Cale> yuuki: I'm not certain that there is a theory which explains the universe exactly. Why should I assume that there is one?
14:04:42 <vixey> dejones, I can't guess what that code does from looking at it
14:04:50 <yuuki> geezusfreeek, what is theorizing?
14:04:58 <geezusfreeek> yuuki, inventing "laws"
14:05:03 <DukeDave> Wow, thank you Cale, I've used map ($x) fs for so long and felt dirty about it.. sequence never crossed my mind :D
14:05:04 <yuuki> Cale, what are the laws about?
14:05:07 <kynky> guessing
14:05:09 <vixey> dejones, using acronyms or abbrevs. is the reason why
14:05:10 <yuuki> Oops, that was for geezusfreeek
14:05:17 <zimbatm> Botje, monochrom , thx, I'll look into that
14:05:19 <Cale> yuuki: What we'll see when we do experiments.
14:05:29 <geezusfreeek> yuuki, i did not say the universe is causeless
14:05:32 <Botje> DukeDave: the sequence way can really confuse newbies, though
14:05:37 <dejones> vixey: Sorry, the names would be really really long otherwise...heh.
14:05:40 <Cale> yuuki: Or what we expect to see, anyway.
14:05:41 <pumpkin_> > [f, g, h] <*> [x, y]
14:05:43 <lambdabot>   Add a type signature
14:05:45 <Botje> so if said newbies are your prof and/or TAs .. :)
14:05:47 <geezusfreeek> in fact, i explicitly said that i don't know and it doesn't matter
14:05:50 <pumpkin_> > [f, g, h] <*> [x, y] :: [Expr]
14:05:51 <lambdabot>   [f x,f y,g x,g y,h x,h y]
14:06:02 <pumpkin_> even better than map1
14:06:04 <dejones> Cale, vixey: So is it just a mess?  ;)
14:06:06 <yuuki> geezusfreeek, so, do your observations have causal relationships with eachother?
14:06:12 <vixey> dejones, they're already long, nothing to lose by making them meaningful as well
14:06:20 <Cale> dejones: just looking now
14:06:24 <geezusfreeek> yuuki, no, observations are independent. it is *i* who relates them in my mind
14:06:47 <yuuki> geezusfreeek what causes you to relate them?
14:06:53 <kynky> observations *should be* independent
14:06:54 <dejones> vixey: That's probably true...
14:07:05 <vixey> only probably ? :(
14:07:19 <geezusfreeek> yuuki, if i leave a sandwich on the table and then it's gone when i return, was it eaten or was it thrown away?
14:07:21 <FunctorSalad> yuuki: the human brain...
14:07:23 <dons> ?users
14:07:23 <lambdabot> Maximum users seen in #haskell: 558, currently: 537 (96.2%), active: 34 (6.3%)
14:07:39 <dejones> vixey: Well, I think some of them are clear from the data type declarations...
14:07:49 <dejones> vixey: But, maybe that isn't enough info?
14:07:50 <yuuki> FunctorSalad, yay!  enlighten our friend geezusfreeek about this piece of matter known as the human brain :)
14:07:55 <Cale> Not to mention that truth is a human invention as well.
14:08:08 <monochrom> Who am I? What am I? Am I consistent? Am I complete?
14:08:10 <Cale> Statements are only true or false because we regard them as such.
14:08:20 <yuuki> That's absurd
14:08:20 <Cale> (for whatever reasons we do)
14:08:20 <b_jonas> if I wanted to understand what Applicative is for, what's the clearest example for an instance of applicative that's not a monad?
14:08:27 <dejones> Hey dons, if you have a moment, maybe you could give me comments on this code from a design point of view... It's my first time using Data.Binary package:  http://hpaste.org/12376#a1
14:08:35 <FunctorSalad> yuuki: though we are going in circles in a way... we use knowledge of biology to talk about philosophy
14:08:37 <kynky> Cale, is right
14:08:40 <Cale> yuuki: What's absurd is saying that the universe has a particular opinion about a string of symbols.
14:08:41 <b_jonas> I know for monads <*> = ap; pure = return;
14:08:43 <DukeDave> Botje: Oh yeah, it's totally blowing my mind, but it looks fun :D
14:08:52 <yuuki> Cale, the universe IS a string of symbols!
14:09:01 <BrokenClockwork> Cale: I am still trieing to understand this prime factoring issue, to get all divisors of a number n. For instance we take 28. 28 = {1, 2, 4, 7, 14, 28 } now I lsited all prime factor's = {1, 2, 7} and tried to use your approach: 1^1 + 2^2 + 7^7 = ... which doesn't help me so far
14:09:04 <kynky> in your opinion
14:09:05 <yuuki> of course it cares about strings of symbols :)
14:09:19 <Cale> yuuki: Which string of symbols is it?
14:09:27 <b_jonas> BrokenClockwork: 1 is not a prime factor
14:09:34 <yuuki> Cale, I don't know
14:09:38 <monochrom> . o O ( it doesn't fit in this margin )
14:09:40 <b_jonas> BrokenClockwork: and 7^7 si really large
14:09:45 <dons> http://www.reddit.com/r/haskell/comments/7fo8e/janis_voigtlaenders_introduction_to_haskell_with/
14:09:46 <Cale> yuuki: How do you know that it is a string of symbols then?
14:09:47 <lambdabot> Title: Janis Voigtlaender's introduction to Haskell with emphasis on types and reasonin ..., http://tinyurl.com/69w822
14:09:48 <BrokenClockwork> that's the problem
14:09:49 <dons> Cale: looks interesting
14:09:59 <sw17ch> is there a scan variant for monadic actions?
14:09:59 <Cale> dons: What does?
14:10:02 <b_jonas> BrokenClockwork: try writing 28 in prime factors power form correctly first
14:10:06 <yuuki> Cale, I can observe the properties of our universe and determine what its structure must be
14:10:07 <geezusfreeek> yuuki, if the universe is a string of symbols, then what is a rock?
14:10:08 <Cale> dons: My philosophy conversation?
14:10:30 <b_jonas> what if we brought the philosophy discussion to -blah?
14:10:33 <geezusfreeek> yuuki, these are all just mental abstractions. i don't see how there can be absolute truth in them
14:10:39 <Jarvellis> A rock is a shorter string of symbols
14:10:40 <b_jonas> some people here want to learn haskell
14:10:41 <dons> janis' intro to haskell with emph. on types and reasoning :)
14:10:47 <yuuki> geezusfreeek who said anything about absolute truth?
14:10:49 <Cale> dons: oh
14:10:51 <Cale> dons: :)
14:10:56 <dons> not whatever you guys are talking about
14:10:59 <dons> ;)
14:11:07 <geezusfreeek> yuuki, if not you then i don't know what you're trying to say
14:11:08 <b_jonas> BrokenClockwork: it's 2^2 * 7^1
14:11:13 <Cale> dons: Is that the same one which was on the mailing list earlier today?
14:11:20 <BrokenClockwork> oh it's *
14:11:21 <BrokenClockwork> I tried +
14:11:25 <b_jonas> oh
14:11:29 <geezusfreeek> anyway, #haskell-blah is certainly where this should go (and probably die)
14:11:31 <b_jonas> no wonder it doesn't work
14:11:32 <pumpkin_> BrokenClockwork: factoring means you break it into mutiples
14:11:33 <nominolo> @seen swiert
14:11:33 <lambdabot> I saw swiert leaving #haskell 1d 5h 53m 15s ago, and .
14:11:33 <dons> Cale: yessir
14:11:34 <Cale> oh, yes, it is :)
14:11:39 <BrokenClockwork> yeah right
14:11:40 <pumpkin_> *multiplies
14:11:42 <yuuki> geezusfreeek, if I take truth as "knowledge" then it's not absolute.  If I take truth as the thing that knowledge intends to refer to, then it is absolute
14:11:55 <dejones> dons, Cale: Do you think my variable naming is poor (not meaningful)?
14:12:22 <BrokenClockwork> okay 28 = 7^1 * 2^2 ... which means, the number is produced by a factoring of primes with the power of another prime or is it numbered?
14:12:30 <BrokenClockwork> like ^1 * ^2 * ^3 ?
14:12:40 <yuuki> geezusfreeek, so when we do experiments, we have no hope of interacting with something that can be reasoned about?
14:12:40 <b_jonas> BrokenClockwork: ^ is the power operator
14:12:42 <pumpkin_> 1 is usually not considered a prime
14:12:46 <b_jonas> BrokenClockwork: x^2 is x squared
14:12:55 <Cale> dejones: I'm not sure how I'd modify that code, except that if you're parsing GHC structures, you probably should be using GHC-as-a-library.
14:12:58 <yuuki> geezusfreeek why would we perform experiments in that case?
14:12:59 <b_jonas> BrokenClockwork: so no, it's not numbered
14:13:00 * FunctorSalad suspects that practically, the word 'truth' comes from truth as in 'not deception'
14:13:03 <kynky> because otherwise you get an infinite answer
14:13:11 <b_jonas> BrokenClockwork: you could also write the factoring of 28 as 7 * 2 * 2
14:13:13 <geezusfreeek> yuuki, the reason we perform experiments is to perform observations
14:13:17 <pumpkin_> I thought the philosophy was moving to -blah :)
14:13:19 <BrokenClockwork> but x^1 , 1 is not a prime, why is it used ?
14:13:27 <pumpkin_> BrokenClockwork: it's not about the exponent
14:13:30 <geezusfreeek> yuuki, imagine what you would do if you had to black-box test an object of unknown complexity
14:13:31 <b_jonas> BrokenClockwork: but to get the number or list of divisors, you have to collapse identical prime factos
14:13:32 <vixey> 1 used to be a prime
14:13:32 <kynky> its not 1 ^ x
14:13:35 <pumpkin_> it's really saying 2 * 2 * 7 = 28
14:13:36 <geezusfreeek> yuuki, what would you do?
14:13:44 <pumpkin_> vixey: like pluto used to be a planet?
14:13:46 <BrokenClockwork> ah that helps, ok
14:13:47 <dejones> Cale: Not parsing GHC structures, they are C structures from the parallel profiling code I've implemented in GHC's run-time system.
14:13:49 <b_jonas> BrokenClockwork: which is why you write it as 7^1 * 2^2
14:13:50 <geezusfreeek> yuuki, and how would you know that it is not randomly replaced with other objects as you test it?
14:13:55 <monochrom> 7 is a prime. 7^1 is just fine.
14:13:56 <yuuki> geezusfreeek, well, I would give up because there is nothing there that I can hope to interact with
14:13:59 <BrokenClockwork> ok, I am sure I get it so far
14:14:04 <b_jonas> pumpkin_: no, I think it's not that sense
14:14:10 <dejones> Cale: The structures are mostly event types and events for parallel profiling data.
14:14:19 <pumpkin_> the "1 is not a prime" is pretty arbitrary
14:14:20 <Cale> dejones: okay
14:14:26 <pumpkin_> and doesn't really make much difference either way
14:14:29 <b_jonas> pumpkin_: rather it's 1 used to be a prime how dolphins used to be fish
14:14:32 <geezusfreeek> yuuki, right!
14:14:40 <FunctorSalad> pumpkin_: unique prime factorization.
14:14:40 <b_jonas> pumpkin_: I don't think it's arbitary
14:14:45 <yuuki> geezusfreeek, so you're advocating that everyone give up experimenting?
14:14:46 <geezusfreeek> yuuki, the goal is not absolute truth. the goal is useful models
14:14:48 <monochrom> pumpkin_: don't start that, recall what we got after "0 is/isnot natural" :)
14:14:59 <vixey> fundamental theorem of something likes 1 not being a prime
14:15:00 <pumpkin_> :P
14:15:03 <monochrom> Onoes it has started now...
14:15:03 <BrokenClockwork> so, I am able to prime factoring a number, how does it help find all divisors?
14:15:07 <vixey> arithmetic I guess
14:15:09 <yuuki> geezusfreeek, I'm not aiming for absolute truth.  I'm aiming for useful models
14:15:20 <geezusfreeek> yuuki, models of what?
14:15:22 <pumpkin_> I guess the philosophy didn't move to -blah
14:15:29 <yuuki> geezusfreeek, it doesn't matter
14:15:29 <geezusfreeek> pumpkin_, nope :\
14:15:31 <FunctorSalad> vixey: yep
14:15:33 <medfly> fundamental theorem of prime factorization
14:15:36 <pumpkin_> BrokenClockwork: because that's what factoring is :)
14:15:40 <yuuki> geezusfreeek as long as they are useful
14:15:41 <smtms> BrokenClockwork, are you serious?
14:15:50 <Cale> yuuki: What makes you think that assuming absolute truths exist is going to help produce useful models?
14:15:57 <monochrom> 2^a * 3^b * 7^c  has (a+1)(b+1)(c+1) divisors.
14:16:00 <luqui> > iterate (join (+)) 1
14:16:01 <yuuki> Cale, I don't assume that absolute truths exist
14:16:02 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
14:16:04 <vixey> BrokenClockwork, every divisor is a product of some of the prime factors
14:16:05 <Cale> yuuki: I can't personally see how I'd ever make good use of that fact.
14:16:07 <yuuki> Cale, how would I test them, anyways?
14:16:12 <Cale> yuuki: Right.
14:16:25 <Corun> I wonder how many times per day lambdabot prints a list of numbers with an obvious pattern
14:16:31 <Cale> yuuki: So why are you saying that truths are independent of us?
14:16:42 <vixey> BrokenClockwork, prime decomposition of 30 is 2*3*5, factors are {2,3,5,2*3,3*5,2*5,2*3*5}
14:16:48 <pumpkin_> Corun: I still like the scanl (+) 0 [1, 3..] myself
14:16:54 <yuuki> Cale, I'm saying that there is a reason why we come up with useful models
14:16:56 <mauke> @oeis 1,2,4,8,16
14:16:56 <lambdabot>  Powers of 2: a(n) = 2^n.
14:16:57 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
14:17:11 <Cale> yuuki: Why is that important?
14:17:16 <yuuki> Cale, that causality, either imposed by us or inherent in the universe, causes us to derive useful things
14:17:19 <luqui> > randoms (mkstdGen 100)
14:17:20 <monochrom> > scanl (+) 0 [1, 3..]
14:17:20 <lambdabot>   Not in scope: `mkstdGen'
14:17:21 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
14:17:27 <luqui> > randoms (mkStdGen 100)
14:17:28 <lambdabot>   [-3650871090684229393,-9143854998136150815,3895500410229592485,-12302447463...
14:17:35 <FunctorSalad> @oeis 1,1,1,1,433,1,1
14:17:36 <lambdabot>  Sequence not found.
14:17:37 <monochrom> > scanl (+) 0 [1, 3..] :: [Expr]
14:17:39 <lambdabot>   [0,0 + 1,0 + 1 + 3,0 + 1 + 3 + 5,0 + 1 + 3 + 5 + 7,0 + 1 + 3 + 5 + 7 + 9,0 ...
14:17:39 <pumpkin_> luqui: run it through oeis
14:17:40 <yuuki> Cale, because if I know about causality I can perform experiments with the expectation of creating useful models
14:17:43 <geezusfreeek> yuuki, "causality" is rather self-assuming, isn't it?
14:17:45 <Cale> yuuki: What would it look like if there wasn't a reason that we came up with useful models?
14:17:49 <kynky> yuuki, so that people can communicate with reference to a base?
14:17:50 <luqui> > fmap (`mod` 42) $ randoms (mkStdGen 100)
14:17:51 <lambdabot>   [5,9,27,29,36,8,36,39,10,29,23,3,35,6,18,10,31,40,3,38,22,30,39,39,1,4,36,1...
14:17:53 <monochrom> Oh! [1,3..] means [1,3,5,7,9,...]
14:17:57 <vixey> BrokenClockwork, makes sense?
14:18:07 <pumpkin_> monochrom: yup!
14:18:07 <BrokenClockwork> vixey: And how does "2*3*5, factors are {2,3,5,2*3,3*5,2*5,2*3*5}" take me to that the divisors of 30 are: 1,2,3,5,6,10.15,30 ?
14:18:09 <yuuki> Cale, it would be contradictory because the models wouldn't be useful
14:18:17 <geezusfreeek> yuuki, is causality an absolute truth?
14:18:20 <BrokenClockwork> yes
14:18:25 <vixey> BrokenClockwork: ???
14:18:27 <yuuki> geezusfreeek I observe that it is
14:18:29 <luqui> @oeis 5,9,27,29,36
14:18:29 <lambdabot>  Sequence not found.
14:18:30 <vixey> BrokenClockwork: You can't see the link there?
14:18:36 <BrokenClockwork> wait..
14:18:37 <Cale> yuuki: No. There just wouldn't be a particular reason that we were successful.
14:18:43 <vixey> > (2,3,5,2*3,3*5,2*5,2*3*5)
14:18:45 <lambdabot>   (2,3,5,6,15,10,30)
14:18:46 <vixey> BrokenClockwork: ^
14:18:48 <b_jonas> BrokenClockwork: that's where you need powers
14:18:50 <yuuki> geezusfreeek I observe that all of my observations have what I observe to be causes
14:19:00 <pumpkin_> luqui: I wonder how many tries it would take before you got it to find something...
14:19:06 <yuuki> geezusfreeek and that observation is useful
14:19:06 <b_jonas> BrokenClockwork: um, ignore my last line
14:19:12 <luqui> pumpkin_, probably not too many
14:19:14 <b_jonas> BrokenClockwork: what vixey says
14:19:15 <monochrom> Sigh, godawful.
14:19:15 <luqui> > fmap (`mod` 42) $ randoms (mkStdGen 101)
14:19:17 <lambdabot>   [13,16,21,28,26,33,28,12,28,24,15,10,34,38,12,7,24,38,28,20,23,13,35,12,2,3...
14:19:24 <BrokenClockwork> ah now I see it
14:19:25 <luqui> @oeis 13.16.21.28,26
14:19:26 <lambdabot>  Sequence not found.
14:19:30 <luqui> hmm
14:19:34 <pumpkin_> does lambdabot see its own output?
14:19:37 <luqui> @oeis [1,2,3,4,5]
14:19:37 <lambdabot>  Sequence not found.
14:19:39 <b_jonas> luqui: commas instead of dots
14:19:40 <pumpkin_> can you make it wroute the @oeis itself?
14:19:44 <luqui> oh whoops
14:19:46 <Cale> yuuki: What about at the start of the universe, in the big bang model?
14:19:52 <luqui> @oeis 13,16,21,28,26
14:19:52 <lambdabot>  Sequence not found.
14:19:54 <BrokenClockwork> sorry, I do see it ... it's getting late, hah, yeah that's pretty
14:20:06 <vixey> BrokenClockwork, proof this works comes straigt form fundamental theorem of arithmetic
14:20:07 <monochrom> > do { x<-[2^0, 2^1]; y<-[3^0, 3^1]; z<-[5^0, 5^1]; return (x*y*z) }  {- for BrokenClockwork -}
14:20:09 <Cale> yuuki: There are cases where it seems useful to allow causality to break down.
14:20:09 <lambdabot>   [1,5,3,15,2,10,6,30]
14:20:18 <vixey> BrokenClockwork, 'works' meaning gives _every_ divisor
14:20:21 <geezusfreeek> yuuki, so your observation of causality means it is true?
14:20:34 <kynky> thats an assumption, cale, who says thats not just the end and we going backwards in time, or any other n possibilities of big bang not being start of universe
14:20:35 <pumpkin_> BrokenClockwork: which bit don't you understand?
14:20:43 <yuuki> geezusfreeek, no, it means that's what I observe.  Why do you keep trying to talk about truth?
14:20:54 <geezusfreeek> yuuki, what if _everything_ was random, and it just so happens that so far in our history all events have appeared to follow a pattern?
14:20:57 <luqui> i don't think it's possible for @eval to output text that @oeis can understand, so I can't compose them :-(
14:21:02 <BrokenClockwork> I udnerstand now everything, it just has taken me long to see the link between both :)
14:21:03 <yuuki> Cale, no, I think that every state of the universe has one or more previous states
14:21:09 <medfly> Cale: this is why I don't want to become you
14:21:13 <vixey> BrokenClockwork, check out fundamental theorem of arithmetic
14:21:21 <pumpkin_> medfly: ?
14:21:23 <Cale> kynky: It doesn't matter. The point is that causality's usual definition doesn't apply in that particular model, at that particular point in time (because there are no times before it to compare with)
14:21:28 <BrokenClockwork> wiki I guess
14:21:34 <monochrom> No one other than Cale will become Cale. Don't you worry. :)
14:21:39 <geezusfreeek> yuuki, because you argued that all reasoning about the universe given intelligence and time would converge no matter where it starts
14:21:48 <pumpkin_> there was discussion about becoming Cale? :o
14:21:52 <medfly> monochrom: idon't see why anyone would want to
14:21:57 <yuuki> geezusfreeek, sure.  What does that have to do with absolute truth?
14:22:06 <pumpkin_> medfly: that's starting to sound ad-hom :P
14:22:24 <medfly> thats the right direction
14:22:32 <monochrom> I don't want to become anyone else.
14:22:35 <geezusfreeek> yuuki, does it not imply absolute truth if all lines of reasoning absolutely converge?
14:22:44 <pumpkin_> monochrom: oh so you think you're so cool already, eh
14:22:51 <Cale> monochrom: You just became yourself, 5 seconds older!
14:23:01 <monochrom> Yeah, it's an ad-hom on all of you!  *duck*
14:23:04 <DukeDave> Sorry to break the flow for a second: Is there a proposal in Haskell' for more expressive LINQ style list comprehensions?
14:23:05 <b_jonas> isn't that called fundamental theorem of number theory?
14:23:14 <luqui> monochrom :: Behavior Person
14:23:14 <yuuki> geezusfreeek, I don't know about absolute truth.  All I know is that other people around me report similar observations.  My guess, from my observation of the world, is that anyone I could ever meet would report similar observations.
14:23:18 <geezusfreeek> DukeDave, do not apologize for being on topic
14:23:20 <kynky> there is no such thing as absolute truth is  the defintion of absolute truth becomes ambiguous
14:23:26 <medfly> yuuki: of what, again?
14:23:28 <Cale> DukeDave: I'm not sure that I want them. GHC has an extension where they're supported though.
14:23:30 <smtms> yuuki, you are imagining those other people
14:23:42 <yuuki> haha, I know I am.
14:23:50 <yuuki> But I observe them nonetheless!
14:24:01 <pumpkin_> yuuki: are you japanese?
14:24:18 <yuuki> pumpkin_, no, but I lived in Japan
14:24:18 <geezusfreeek> i need to get back to work
14:24:21 <pumpkin_> ah ok :)
14:24:25 <geezusfreeek> getting off irc
14:24:45 <yuuki> geezusfreeek, how funny that the "real" world should beckon
14:25:13 <luqui> monochrom' = monochrom `untilB` future (parseTime "Jan 14, 2009") cale
14:25:19 <geezusfreeek> yuuki, i *observed* that i haven't not performed actual work for a while ;)
14:25:34 <yuuki> geezusfreeek, you should just observe that you've done some work :)
14:25:36 <b_jonas> so what's the rule for when two higher-rank polymorphic types count as the same type?
14:25:39 <monochrom> That is so painful
14:25:46 <DukeDave> geezusfreeek: Heh, I was waiting for someone to say "take it to the Haskell prime channel"   ;)
14:25:48 <pumpkin_> I'm having trouble understanding some haskell
14:25:51 <luqui> b_jonas, alpha equivalent?
14:25:55 <geezusfreeek> yuuki, hopefully causality holds while i try to get work done
14:26:06 <luqui> pumpkin_, really!?  how unexpected!
14:26:13 <pumpkin_> http://hpaste.org/12378
14:26:18 <pumpkin_> isn't very clear
14:26:24 <b_jonas> luqui: I think there are more, but I'm not completely sure
14:26:34 <pumpkin_> sorry :P
14:26:35 <monochrom> "isn't very clear" is an understatement :)
14:26:38 <DukeDave> Lmao
14:26:40 <luqui> LOL
14:26:51 <olsner> it could be clearer, yes
14:27:00 <b_jonas> luqui: like, is (foreach a. (C -> a)) the same as (C -> (foreach a. a)) ?
14:27:06 <luqui> but the question is: could it be less clear?
14:27:25 <b_jonas> it can always be less clear
14:27:26 <luqui> b_jonas, ahh right.
14:27:35 <luqui> can you give a constructive proof?
14:27:46 <b_jonas> luqui: dunno, I'm not even sure they're the same type
14:27:49 <medfly> Cale: read PM
14:27:52 <b_jonas> luqui: that's why I'd like to know the rule
14:28:04 <luqui> b_jonas, I meant of being possible to be less clear ;-)
14:28:05 <ekidd> Any good tutorials on nested data parallelism in GHC yet? I've read the papers, but the wiki is out of date, and I'd love a step-by-step "getting started" guide.
14:28:08 <b_jonas> luqui: I wondered if it had to do something with Skolem forms
14:28:13 <b_jonas> luqui: oh, that?
14:28:25 <b_jonas> no, I want to learn proper haskell first before writing haskell obfus
14:28:29 <dons> ekidd: mm. the recent papers, primarily.
14:28:35 <dons> there's been a couple of tutos/blogs
14:28:37 <luqui> b_jonas, the two types you gave are isomorphic.
14:29:01 <ekidd> dons: Ah, I'm still at the "fighting with compiler options to make it actually work" stage. :-)
14:29:01 <luqui> I believe in Haskell they can be used interchangably
14:29:12 <luqui> with explicit type application, they are essential isomorphic via "flip"
14:29:19 <FunctorSalad> yuuki: anyone would report similar observations? that's not even true for sane people ;)
14:29:19 <pumpkin_> ekidd!
14:29:26 <b_jonas> luqui: they're ceratinly isomorphic, but I'd like to know if they're the same according to ghc
14:29:27 <dons> ekidd: oh. ask on the list.
14:29:32 <dons> ekidd: shouldn't be that hard.
14:29:34 <medfly> FunctorSalad: what is he talking about, anyway
14:29:37 * ekidd waves at pumpkin_
14:29:38 <yuuki> FunctorSalad, I'm not claiming they are absolutely the same
14:29:43 <pumpkin_> ekidd: you at dartmouth?
14:29:50 <b_jonas> luqui: and also about what the exact rule is on when two types are the same
14:29:55 <ekidd> dons: Thanks! Maybe I need to write a blog post over Thanksgiving weekend...
14:29:55 <monochrom> If you turn on "forall hoisting", ghc makes them same IIRC.
14:29:58 <FunctorSalad> (try asking two people involved in some hostility what has happened)
14:30:05 <ekidd> pumpkin_: Yup!
14:30:08 <kynky> i like yet another haskel tutorial, the haskell wiki book, real world haskell, and the 26 1.5 hour lectures on haskell, done by a german lecturer in english
14:30:09 <pumpkin_> ekidd: me too!
14:30:11 <pumpkin_> anyway, gotta run
14:30:28 <FunctorSalad> yuuki: yes, I think I understood what you meant. just playing devils advocate again
14:30:35 <b_jonas> monochrom: what's forall hoisting?
14:30:47 <yuuki> I agree.  I'm just saying that the observations have causes which are based in the matter of the brain and its surroundings
14:30:49 <monochrom> It means moving "forall" outward.
14:30:59 <luqui> b_jonas, hmm.  you might get somewhere if you try to phrase your question in terms of unification rather than sameness
14:31:28 <FunctorSalad> medfly: the universe and stuff
14:31:39 <yuuki> FunctorSalad, when someone says "The world is X", I take that to mean "I observe X"
14:31:49 <b_jonas> luqui: maybe
14:31:57 <b_jonas> luqui: I am trying to read another paper about that
14:32:05 <yuuki> FunctorSalad, so all of my claims about absolute truth can be translated to "observation calculus"
14:32:06 <b_jonas> luqui: but I'm too tired to understand it now
14:32:29 <b_jonas> SP JONES, D VYTINIOTIS, S WEIRICH, M SHIELDS: Practical type inference for arbitrary-rank types
14:32:31 <yuuki> FunctorSalad, I just think that "observation calculus" is a waste of time
14:32:43 <FunctorSalad> yuuki: observation calculus?
14:33:02 <luqui> putting "calculus" after something makes it cool
14:33:15 <yuuki> FunctorSalad, yes, like Cale and geezusfreeek were describing.  Regarding everything as an observation and denying anything past that
14:33:44 <b_jonas> luqui: lol
14:33:59 <yuuki> But "observing X" is equivalent to "The world is X" from the perspective of the person observing
14:34:01 <monochrom> pointy-hair calculus
14:34:21 <yuuki> When I observe something, you don't think "I observed X".  That's called "observing the observation of X"
14:34:37 <FunctorSalad> yuuki: some people do question their observations
14:34:45 <yuuki> Sure, that's fine
14:34:57 <yuuki> But then you aren't observing anymore
14:35:08 <ddarius> Do they question their observation of them questioning their observation?
14:35:23 <yuuki> You can't both observe that the sky is blue and question that observation.  Questioning it would be equivalent to not really observing that the sky is blue!
14:35:31 <BrokenClockwork> I want to create a return in a string, how is this possible?
14:35:34 <FunctorSalad> ddarius: yes, but it decays quickly enough that the series converges ;)
14:35:37 <BrokenClockwork> sth. like "hello \n world"
14:35:37 <monochrom> join :: Obs (Obs x) -> Obs x
14:35:46 <Botje> BrokenClockwork: exactly like that :)
14:35:46 <mauke> BrokenClockwork: like that
14:35:53 <jsn> BrokenClockwork: that would be it
14:35:56 <monochrom> return "hello world"
14:36:05 <BrokenClockwork> no not that return
14:36:05 <monochrom> return (show True)
14:36:11 <BrokenClockwork> I mean a word wrap or sth
14:36:14 <BrokenClockwork> line break?
14:36:19 <monochrom> f x = "hello" ++ show x
14:36:23 <jsn> BrokenClockwork: that's what "\n" is
14:36:46 <jsn> BrokenClockwork: maybe we just don't understand what you mean?
14:37:03 <FunctorSalad> yuuki: seems like you are using 'observe' in the sense 'perceive, and accept as truth (in some sense)'
14:37:05 <monochrom> I think \n is it.
14:37:21 <b_jonas> luqui: in fact the better question might be when a type is a generalization (more polymorphic) than another becasue then unification is just an algorithm to find a type below two others, and equality is when a type is lessqual and greaterequal than another
14:37:23 <jsn> unless he means string should be a special monad
14:37:27 <yuuki> FunctorSalad, yes
14:37:28 <BrokenClockwork> parse error on input \n
14:37:37 <dons> woot. Amazon just changed RWH's status to "In Stock."
14:37:46 <mauke> BrokenClockwork: don't retype
14:37:46 <monochrom> "hello \n world"
14:37:51 <luqui> b_jonas, good insight
14:37:57 <BrokenClockwork> when I write "Hello \n world" into the compiler it says > "Hello \n world"
14:38:00 <BrokenClockwork> retype?
14:38:05 <dons> Looks like Real World Haskell is shipping.
14:38:05 <byorgey> dons: excellent!
14:38:11 <mauke> BrokenClockwork: you can't write into the compiler
14:38:13 <monochrom> putStr "hello \n world"
14:38:14 <dons> and you can add it to your Baby Registry or Wedding Registry
14:38:17 <lament> dons: it's about time!
14:38:20 <b_jonas> luqui: of course you can still have the problem that there's no one most general unification or that it can't be found
14:38:32 <b_jonas> luqui: but I want to understand well-typedness before type inference
14:38:42 <dons> THE TIME IS ABOUT NOW!
14:38:44 <jsn> dons: they shipped my order today, actually
14:38:46 <mauke> BrokenClockwork: I only get <interactive>:1:6: parse error on input `\'
14:38:51 <dons> jsn: awesome!
14:38:54 <mauke> BrokenClockwork: how did you get "parse error on input
14:38:54 <dons> I can't wait to see photos.
14:38:55 <mauke> \n"?
14:38:57 <FunctorSalad> dons: will we be on TV soon? :D
14:39:01 <jsn> dons: of RWH?
14:39:09 <mauke> aiIRRRR
14:39:10 <FunctorSalad> with monad toys coming with burgers
14:39:10 <BrokenClockwork> I wrote directly into the compiler
14:39:17 <mauke> BrokenClockwork: you can't write into the compiler
14:39:18 <monochrom> If you type "hello \n world" into Python, you will also get "hello \n world" back.
14:39:30 <dons> jsn: yeah, i want to see it on your hot little hands :)
14:39:38 <jsn> LOLz
14:39:43 <lament> sexay
14:39:58 <jsn> it arrives Dec. 4th
14:40:00 <lament> dons: is there any rationale behind the cover beetle?
14:40:05 <monochrom> I don't know how to convince newbies that this is the right thing to do.
14:40:09 <dons> it is an awesome beetle
14:40:13 <dons> with mighty strength
14:40:15 <lament> it is an awesome beetle
14:40:16 <jsn> monochrom: convince them of what?
14:40:40 <monochrom> that if you type in "\n" to the interpreter prompt, the correct response from the interpreter is "\n".
14:40:41 <mauke> jsn: String.show /= id
14:41:00 <FunctorSalad> lament: hmm, I think it looks a bit too evil :(
14:41:03 <jsn> ah
14:41:04 <b_jonas> I might be reading the wrong article though
14:41:05 <jsn> right
14:41:08 <monochrom> But fortunately since python does it too, perhaps there is nothing to be explained.
14:41:10 <lament> FunctorSalad: what do you mean "too" evil
14:41:15 <lament> it looks fricking evil
14:41:25 <FunctorSalad> remember, monads should have been called warm fluffy things
14:41:26 <b_jonas> so, um, doesn't anyone here want to explain higher-rank types to me?
14:41:28 <jsn> BrokenClockwork: if you actually want to see a newline printed, you need to use    putStr
14:41:30 <dons> i wonder if i'll get a copy of the book.
14:41:36 <BrokenClockwork> ah
14:41:42 <FunctorSalad> now people will be scared of monads, *and* of the beetle
14:41:57 <mauke> the monad beetle
14:42:00 <b_jonas> warm?
14:42:05 <jsn> people are already afraid of beetle
14:42:06 <b_jonas> fluffy thing is ok, but why warm?
14:42:10 <BrokenClockwork> jsn: thats what I wanted
14:42:12 <mauke> b_jonas: they're types with 'forall' in them :-)
14:42:12 <vixey> b_jonas, higher rank types
14:42:12 <lament> dons, FunctorSalad: http://merlin.pl/Mezzanine_Massive-Attack,images_big,9,8455992.jpg
14:42:16 <vixey> b_jonas, ? what about them?
14:42:20 <lambdabot> http://tinyurl.com/6pvdhv
14:42:26 <jsn> BrokenClockwork: no problem -- we were all pretty confused, i think
14:42:29 <b_jonas> vixey: when one is considered more general than another
14:42:32 <dons> lament: ah yes.
14:42:38 <dons> lament: well spotted
14:42:41 <b_jonas> vixey: or when one is considered the same as the other
14:42:46 <BrokenClockwork> that's for sure
14:42:48 <vixey> b_jonas, I think that criteria comes from unification
14:43:11 <b_jonas> vixey: eg. is (forall a. (C -> a)) and (C -> (forall a. a)) the same?
14:43:12 <vixey> b_jonas, A is more general than B if you can unify A with B only by instantiatiting variables in A
14:43:19 <vixey> (might have said that backwards.......)
14:43:31 <b_jonas> vixey: ok, but then I want to know how the unification works
14:43:37 <jsn> i think we should codename all the math stuff with animal names, so it's more approachable -- even more approachable than gang of four patterns
14:44:02 <b_jonas> jsn: sure, lambda expressions are crocodile families or birds
14:44:02 <lament> cat theory
14:44:10 <b_jonas> oh yeah, cat-amorphisms
14:44:12 <FunctorSalad> jsn: not much opportunity for mnemonics there, I think
14:44:19 <monochrom> mammalian lion = applicative functor ?
14:44:32 <FunctorSalad> the design pattern names at least have sth to do with the idea behind the pattern
14:44:34 <jsn> "monad" -> "tiger"    "monoid" -> "lion"    "monad plus" -> "liger"
14:44:37 <lament> manatee transformers
14:44:47 <b_jonas> um, no
14:45:15 <jsn> it should just be about memorable animals
14:45:20 * luqui never understood the reason for Monadplus
14:45:21 <b_jonas> monad -> tiger, applicative -> feline, functor -> mammal
14:45:27 <FunctorSalad> actually I think mathematical nomenclature isn't that bad, considering how abstract it is
14:45:27 <jsn> it doesn't have to be correct
14:45:54 <jsn> FunctorSalad: sure, but it scares software engineers, who think they are smart enough to know anything of value already
14:46:05 <b_jonas> FunctorSalad: mathematical nomenclature is quite good in that it uses few root words so it's easily translatable
14:46:35 <jsn> luqui: i only sorta half get it myself
14:46:48 <b_jonas> I'd be confused if I had to figure out what animal name translates to what and whether a leopard and a panther is the same thing
14:47:01 <monochrom> leapfrog theorem
14:47:03 <FunctorSalad> luqui: a monad with a "plus" operation, not a premium monad ;)
14:47:10 <lament> monad++
14:47:12 <b_jonas> pigeonhole theorem?
14:47:14 <luqui> i meant it as a criticism :-)
14:47:20 <b_jonas> FunctorSalad: lol
14:47:29 <b_jonas> premium monad
14:47:29 <luqui> i.e. why does MonadPlus exist when we have Monad and Monoid already
14:47:42 <b_jonas> luqui: we discussed that just a few hour ago
14:47:46 <lament> because programmers aren't as smart as mathematicians
14:47:47 <luqui> oh
14:47:50 <FunctorSalad> luqui: lack of quantifiying over variables in the context
14:48:07 <b_jonas> I think it's because Monoid has the wrong kind, someone said it's because Maybe has different definitions for the two
14:48:13 <FunctorSalad> we'd need "instance (forall a. Monoid m a) => MonadPlus m"
14:48:15 <luqui> FunctorSalad, ah, so for MonadPlus it is important that it works on m a for every a...
14:48:17 <b_jonas> you don't have to believe either
14:48:25 <FunctorSalad> luqui: yeah
14:48:32 <monochrom> . o O ( Actually, why do we have monad if we have monoid and functor already )
14:48:47 <FunctorSalad> monochrom: we don't have functor categories ;)
14:48:55 <jsn> monochrom: 'cuz it's what made Haskell famous?
14:49:17 <DukeDave> Can I discuss instance Functor Either with someone quickly? Just want to check I'm not mad :)
14:49:41 <luqui> AAAAAAAAAHahahahHAhhahahAHHHAaaa
14:49:49 <jsn> DukeDave: i'm sure we'll be happy to hear your question.
14:49:54 <FunctorSalad> DukeDave: you aren't mad... Either isn't a functor, but for any type A, "Either A" is a functor
14:51:17 <DukeDave> Heh, yes that's pretty much the source of my not-quite-understanding
14:51:43 <DukeDave> Would you call "Either Int" a partially applied type?
14:52:08 <monochrom> Yes.
14:52:46 <b_jonas> DukeDave: I'd call it a higher-kind type
14:52:50 <lilac> i might be pedantic and call it a partially applied type constructor
14:52:58 <b_jonas> but yeah, it's a partially applied type too
14:53:12 <luqui> :k Either Int
14:53:13 <lambdabot> * -> *
14:53:24 <luqui> :k Either
14:53:25 <lambdabot> * -> * -> *
14:53:38 <lilac> :k Mu
14:53:39 <lambdabot> (* -> *) -> *
14:53:52 <DukeDave> Okay, and then we have "fmap :: (Int -> b) -> Either Int c -> Either b c"
14:54:11 <luqui> DukeDave, no
14:54:21 <FunctorSalad> ?
14:54:21 <luqui> fmap :: (a -> b) -> Either Int a -> Either Int b
14:54:23 <monochrom> fmap :: (x -> y) -> Either Int x -> Either Int y
14:54:44 <FunctorSalad> what DukeDave said exists too I think, it just isn't called fmap
14:54:48 <DukeDave> Ah damn it
14:54:50 <DukeDave> Ofcourse
14:54:50 <luqui> FunctorSalad, true
14:54:54 <lilac> DukeDave: fmap always affects the last type to which the type constructor is applied
14:54:57 <ddarius> :t left
14:54:58 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
14:54:59 <FunctorSalad> looks like a natural transformation from Either Int to Either b
14:55:27 <DukeDave> Which is why f is applied only to Rights and not Lefts
14:55:31 <b_jonas> lilac: I think no
14:55:44 <luqui> DukeDave, yeah.  I almost consider it a hack.
14:55:45 <b_jonas> lilac: that's only in h89 where instances have that restriction
14:56:10 <b_jonas> lilac: um, wait
14:56:16 <b_jonas> lilac: maybe you're right
14:56:38 <b_jonas> lilac: except that it might be the last argument of a type synonym in extended haskell
14:57:31 <b_jonas> luqui: I don't consider it a hack. think of Left x as an exception, like in the error monad transformer
14:57:56 <lilac> b_jonas: you can define instances for synonyms now? is that really decidable?
14:58:00 <luqui> b_jonas, yeah I know.  The way I think it is a hack is because you can't define a functor that works on the first argument of Either
14:58:08 <DukeDave> Ah, I see, my problem stemmed in my notes where I too the class type "fmap :: (a->b) -> f a -> f b" and incorrectly derived "fmap :: (a->b) -> Either a c -> Either b c"
14:58:09 <luqui> lilac, not in any interesting way
14:58:13 <lilac> b_jonas: in any case, it's still the last type to which the tycon is applied :)
14:58:21 <luqui> lilac, only if it expands to something you could have defined an instance on anyway
14:58:28 <FunctorSalad> instances for synonyms, sounds like type families
14:58:28 <b_jonas> hmm
14:58:45 <b_jonas> I don't really understand all the typeclass rules then
14:58:46 <lilac> luqui: well, that makes sense :) so it's just a syntactic convenience
14:58:52 <b_jonas> probably you'd better ignore what I say
14:58:56 <b_jonas> good night now
14:58:59 <FunctorSalad> good night :)
14:59:23 <DukeDave> Okay, now on to this sequence [f1, f2] x == map ($x) [f1,f2] thing :)
14:59:49 <yuuki> http://en.wikipedia.org/wiki/Perspectivism
14:59:51 <lambdabot> Title: Perspectivism - Wikipedia, the free encyclopedia
14:59:51 <luqui> DukeDave, that's related, in the (->) a monad
14:59:55 <yuuki> oops, sorry
14:59:58 <lilac> DukeDave: do you know about the ((->) a) monad?
15:00:15 <luqui> well, let's launch off the functor first, ya?
15:00:39 <lilac> @src sequence
15:00:39 <lambdabot> sequence []     = return []
15:00:39 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:00:39 <lambdabot> --OR
15:00:39 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
15:00:51 <luqui> (fmap show (+1)) 41
15:00:56 <luqui> > (fmap show (+1)) 41
15:00:57 <lambdabot>   "42"
15:01:24 <luqui> that's because fmap :: (a -> b) -> (c -> a) -> (c -> b), for the (c ->) functor
15:01:30 <BMeph> lilac: " <lilac> luqui: well, that makes sense :) so it's just a syntactic convenience" - is that syntactic parsley? ;)
15:02:00 <monochrom> syntactic curry
15:02:37 <lilac> BMeph: well-seasoned syntax, either way :)
15:02:58 <stevan> hi, is there a fix for "include/HsEditline.h:7:22:  histedit.h: No such file or directory" when building editline? thanks.
15:03:24 <luqui> stevan, sounds like you need to install editline (or editline-dev)
15:03:47 <monochrom> the exact name varies. another possible name is libeditline-dev
15:05:13 <stevan> i have http://www.thrysoee.dk/editline/libedit-20080712-2.11.tar.gz installed and configure seems to have found it: "checking editline/readline.h usability... yes, checking editline/readline.h presence... yes..."?
15:06:20 <DukeDave> luqui: Yes, but thanks anyway, I actually ended up reading this: http://en.wikibooks.org/wiki/Haskell/Solutions/Applicative_Functors
15:06:21 <DukeDave> I don't know if that's related to the sequence expr I wrote?
15:06:23 <lambdabot> http://tinyurl.com/5gua4q
15:07:06 <lilac> anyone got ideas how i might solve this cabal error: "Setup: ghc-pkg version >=0 is required but it could not be found." ?
15:07:06 <luqui> DukeDave, yeah, sortof
15:11:29 <stevan> got it working, by addeding the include path to editline.buildinfo
15:13:42 <DukeDave> Erm, how does one pronounce ((->) t)  ?
15:13:55 <Saizan> lilac: is ghc-pkg in your $PATH?
15:14:19 <monochrom> I wouldn't pronounce it. It is not like I will talk Haskell over the phone.
15:14:43 <Botje> DukeDave: "the arrow monad" ? :)
15:14:46 <lilac> Saizan: that's fixed it, thanks :)
15:14:59 <Botje> depends on the context, really
15:15:04 <luqui> monochrom, I think you would, just there's nobody with whom you can
15:15:32 <Saizan> "naked reader monad" or just "reader monad"
15:15:35 <ddarius> I'm pretty sure many Haskellers have talked to each other over the phone.
15:15:57 <monochrom> Then just use a speech synthesizer.
15:17:41 <Botje> we entangle qubits and use those to transmit data.
15:18:33 <Lemmih> @tell thoughtpolice Yeah, the Suport.MapBinaryInstance file is a pita. It's one of the reasons we should get rid of StringTable.Atom.
15:18:33 <lambdabot> Consider it noted.
15:18:36 <Botje> you should have received your set in the mail, if not call 0.5|0> + 0.866|1>
15:18:56 <monochrom> The story in the wikibook in which the guy and his ex-gf could talk a complete Haskell lesson over the phone is pure fiction.
15:19:39 <lament> that's not really something i would want to do with my ex-gf
15:19:41 <Lemmih> @tell thoughtpolice It seems you've forgotten to add LHCVersion.hs
15:19:41 <lambdabot> Consider it noted.
15:20:19 <DukeDave> Wow. Just, wow: I get fmap f g = g . f
15:20:34 <DukeDave> I can see why it might confuse newbies :)
15:21:13 <ddarius> @djinn (a -> b) -> (r -> a) -> (r -> b)
15:21:13 <lambdabot> f a b c = a (b c)
15:21:21 <Vulpyne> That reminds me, I found something pretty interesting in that vein: http://www.haskell.org/pipermail/reactive/2008-November/000054.html
15:21:23 <ddarius> @. pl djinn (a -> b) -> (r -> a) -> (r -> b)
15:21:23 <lambdabot> Title: [reactive] To fmap fmap or not?, http://tinyurl.com/5a2zwo
15:21:23 <lambdabot> f = (.)
15:21:38 <Botje> heh
15:21:41 <Botje> i read that tomorrow.
15:21:46 <Botje> that tutorial is very clear
15:22:03 <lilac> @type foldr (liftA2 (:)) (Control.Applicative.pure [])
15:22:04 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
15:22:19 <lilac> is there a predefined 'sequence' for Applicatives?
15:22:31 <lilac> @hoogle Applicative f => [f a] -> f [a]
15:22:32 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
15:22:32 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:22:32 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:23:37 <lilac> "cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.0 however process-1.0.1.0 was excluded because ghc-6.10.1 requires process ==1.0.1.1"
15:23:39 <DukeDave> Heh, damn it guys, just when I'm feeling clever you pull that out on me :)
15:24:15 <Vulpyne> DukeDave: I haven't fully processed it myself, but it looks pretty interesting and like something that would be useful. :)
15:25:46 <kig> @hoogle &
15:25:47 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
15:25:47 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
15:25:47 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
15:25:58 <kig> @hoogle xor
15:25:58 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
15:26:12 <kig> @hoogle and
15:26:13 <lambdabot> Prelude and :: [Bool] -> Bool
15:26:13 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
15:26:13 <lambdabot> Data.List and :: [Bool] -> Bool
15:26:32 <ddarius> :t (.&.)
15:26:33 <lambdabot>     Ambiguous occurrence `.&.'
15:26:33 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
15:26:33 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
15:26:41 <ddarius> 'the fuck?
15:26:52 <ddarius> :t (Data.Bits..&.)
15:26:54 <lambdabot> forall a. (Bits a) => a -> a -> a
15:27:08 <luqui> :t (Test.QuickCheck..&.)
15:27:09 <lambdabot> forall prop1 prop2. (Testable prop2, Testable prop1) => prop1 -> prop2 -> Property
15:29:53 <luqui> > 123456789 Data.Bits.& 987654321
15:29:54 <lambdabot>   Not in scope: `Data.Bits.&'
15:30:00 <luqui> > 123456789 Data.Bits..&. 987654321
15:30:02 <lambdabot>   Add a type signature
15:30:05 <kig> > (6::Int) Data.Bits..&. 3
15:30:06 <lambdabot>   2
15:30:08 <luqui> > 123456789 Data.Bits..&. 987654321 :: Integer
15:30:09 <lambdabot>   39471121
15:30:18 <Saizan> lilac: this thread seems to talk about the same problem http://www.haskell.org/pipermail/cabal-devel/2008-November/004205.html
15:30:19 <lambdabot> Title: error with package ghc-6.10.1 and its dependency on process-1.0.1.[01], http://tinyurl.com/64gza5
15:34:37 <Axman6> anyone know how to tell cabal install where readline is installed?
15:35:18 <BrokenClockwork> I want to pattern match a list, so it gives out the last element I tried: givlast (x:xs) = givlast xs
15:35:26 <BrokenClockwork> but it don't work..
15:35:28 <sheyll> hi
15:35:35 <BrokenClockwork> I tried givlast[x] = x before
15:35:37 <BrokenClockwork> same result
15:35:41 <jsn> hello
15:35:43 <Botje> BrokenClockwork: really? works for me.
15:35:50 <Axman6> BrokenClockwork: you need gielast [x] = x
15:35:53 <roconnor> @type maybe
15:35:54 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:35:59 <Axman6> givlast*
15:36:00 <Botje> BrokenClockwork: you need to combine those two rules
15:36:03 <roconnor> @type either
15:36:04 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:36:11 <Axman6> @src last
15:36:11 <lambdabot> last [x]    = x
15:36:11 <lambdabot> last (_:xs) = last xs
15:36:11 <lambdabot> last []     = undefined
15:36:12 <Botje> giveLast [x] = x; giveLast (x:xs) = giveLast xs
15:36:28 <sbahra> > last [1 .. 100]
15:36:30 <lambdabot>   100
15:36:34 <roconnor> @type if'
15:36:36 <lambdabot> Not in scope: `if''
15:36:39 <sbahra> > last ['a' .. 'z']
15:36:40 <lambdabot>   'z'
15:36:50 * EmielRegis http://failblog.files.wordpress.com/2008/11/fail-owned-bookstore-sorting-sexuality-fail.jpg
15:36:51 <lambdabot> http://tinyurl.com/5fv35g
15:37:20 <Axman6> so, anyone know how to tell cabal-instal where readline is installed?
15:37:49 <lilac> Saizan: thanks. looks like i'm seeing different symptoms though. strangely ghc-pkg is picking up only the 6.8 packages not the 6.10 ones
15:39:13 <Saizan> lilac: ah, that means you've 6.8's ghc-pkg in your $PATH, rather than the 6.10 one
15:39:51 <EmielRegis> does anyone have experience in using STUArray?
15:40:06 <Saizan> lilac: look for ghc-pkg-6.10.1
15:40:35 <Alija_> does anyone knows if it's possible to have a trace in hugs?
15:40:51 <Alija_> while in execution
15:41:04 <lilac> Saizan: looks like my shell needed a 'rehash'
15:42:04 <Saizan> EmielRegis: better to just ask if you've a specific problem
15:42:18 <lilac> bizarre. it's found $HOME/.cabal/lib/ghc-6.10.1/./package.conf and $HOME/.ghc/x86_64-linux-6.10.1/package.conf, both of which have a Cabal-1.6.0.1
15:42:21 <EmielRegis> i have a problem to udnerstand how they work in general xD
15:42:22 <aconbere> is there a good way to find out what package provides a function?
15:42:34 <lilac> aconbere: @index or hoogle
15:42:48 <EmielRegis> but what is the difference between STUArray and IOUArray for instance?
15:43:09 <Saizan> EmielRegis: the monad they work in
15:43:10 <EmielRegis> i  know they are 'built' from different monads, but what does it mean in implementation?
15:43:21 <aconbere> lilac: I mean dynamically...say I have the mainLoop function in my global namespace, and I want to know what package is providing it
15:43:37 <Saizan> in implementation they are the same, i think
15:43:38 <lilac> EmielRegis: you can implement IOUArray in terms of STUArray using stToIO
15:43:55 * roconnor molds the other prelude to his liking
15:44:05 <DukeDave> Quick sanity check:   "Nothing" is a type constructor?   "Maybe" is a data constructor?
15:44:21 <lilac> DukeDave: other way around
15:44:22 <bd_> DukeDave: other way around
15:44:22 <vixey> DukeDave, sanity check failed
15:44:50 <Axman6> :(
15:44:59 <baaba> DukeDave, a type constructor constructs a type, and a data constructor constructs a piece of data
15:45:05 <EmielRegis> uhm, okay. Let me rephrase my question, as I am not too experienced with monads. Which of them two would be best to be used for array of pixels that would have to be merged with another array during the runtime (eg. the colours of second array blending with first one's)
15:45:22 <DukeDave> Ha, so wtf:   <interactive>:1:0: Not in scope: data constructor `Maybe'
15:45:37 <baaba> yes, there is no data constructor named 'Maybe' in scope
15:45:39 <DukeDave> Oh wait, lol, I parsed that incorrectly
15:45:41 <DukeDave> Hehe
15:45:41 <baaba> you are attempting to use one
15:45:46 <lilac> Saizan: turns out i had some packages from system ghc6.10 and some from my own install of ghc6.10 :-/
15:45:47 <Axman6> DukeDave: were you trying to do something like (Maybe 10)?
15:46:06 <EmielRegis> also, can you have an array which would hold more than one type? (for instance, a (Int,Int) tuple)
15:46:10 <DukeDave> I read it as "There is a data constructor called Maybe but it's not in scope"
15:46:12 <MarcWeber> DukeDave: (Just 10) or Nothing both has *type* Maybe Int
15:46:24 <DukeDave> Yeah, I was just goofing around in GHC
15:46:35 <lilac> EmielRegis: in general, I would prefer anything ST over anything IO, since ST is more flexible and no slower
15:46:35 <luqui> EmielRegis, uh.... no monad?
15:46:44 <luqui> EmielRegis, just operations on arrays.
15:47:00 <lilac> EmielRegis: in this case.. what luqui said :)
15:47:03 <DukeDave> Why does ghci assume they're data constructors?
15:47:29 <lilac> DukeDave: because it starts with a capital and you used it as part of an expression
15:47:35 <Peaker> DukeDave: you were writing a value expression, not a type expression, so an upper-case word is a data constructor or a module
15:47:35 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
15:47:36 <Cale> DukeDave: There *could be* a data constructor called Maybe
15:47:59 <EmielRegis> alrite. follow-up question - can you define a two dimensional array? I want to have an array of all rows of pixels and each of them would contain array of pixels inside
15:48:08 <lilac> data Just a = Maybe a
15:48:08 <Saizan> EmielRegis: ST is nicer because you can use runSTUArray to get a pure array back, but if you are already in IO i'd use IOUArray
15:48:12 <EmielRegis> like array[x][y] in C
15:48:19 <thomashartman1> how do I convert an Int to 4 Word8s, as required for implementing the pbkdf2 algo from rsa?
15:48:20 <luqui> EmielRegis, Array (Int,Int) Pixel
15:48:22 <Cale> EmielRegis: Arrays in Haskell can be indexed by any instance of the Ix class, and pairs are instances.
15:48:28 <EmielRegis> ah
15:48:29 <EmielRegis> thats nice
15:48:30 <Axman6> @instances Ix
15:48:31 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
15:48:36 <Axman6> bah
15:48:48 <lilac> @instances-importing Prelude Ix
15:48:49 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
15:49:12 <monochrom> thomashartman1: use the "binary" library. also note there are at least 24 ways to do that, and the "binary" library provides 2.
15:49:15 <thomashartman1> Feels like it should be easy but I'm stumped. Bytestrings always make me feel stupid for some reason.
15:49:23 <thomashartman1> thx
15:49:35 <Peaker> thomashartman1: an Int is not necessarily 4 Word8's
15:49:38 <EmielRegis> orite ill try implementing my array, thanks guys
15:50:02 <Axman6> thomashartman1: might want to make sure you're using Int32's then
15:50:27 <Peaker> Why is Word8 not Int8?
15:50:31 <Peaker> @hoogle Int32
15:50:32 <lambdabot> Data.Int data Int32
15:50:35 <Peaker> @hoogle Int8
15:50:35 <lambdabot> Data.Int data Int8
15:50:39 <lilac> Peaker: Word is unsigned IIRC
15:50:40 <Peaker> @hoogle Word8
15:50:40 <lambdabot> Data.Word data Word8
15:50:40 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
15:50:42 <thomashartman1> I thought of that too, but I think in this case it's right to use an int. I'll post code.
15:50:45 <Peaker> lilac: ah
15:50:55 <DukeDave> lilac: Peaker: Cale: Aha, that follows, I just wondered why I got a different error trying to evaluate "Maybe" or "Either" when compared with "(->)"
15:51:01 <Peaker> lilac: more informative to use UInt then, probably
15:52:21 <thomashartman1> http://hpaste.org/12386
15:52:37 * lilac wonders why hackage's package list has near-identical categories 'FRP' and 'Reactivity'
15:54:00 <Alija_> does anyone knows how can I have a trace of one simple execution in Hugs ?
15:54:07 <Alija_> if its possible
15:54:41 <sm> what's the most standard way to get a list of month names or day names ?
15:54:56 <thomashartman1> not sure what you mean by a trace of an exection. ghci has a debugger now fwiw
15:55:00 <vixey> sm, type it in
15:55:07 <lilac> sm: from where do you want to get the list?
15:55:14 <vixey> sm, days ["Mon...
15:55:17 <vixey> sm, days = ["Mon...
15:55:24 <sm> I thought it might be in the prelude or Data.Time.Calendar
15:55:40 <sm> i18n'd, ideally :)
15:55:47 <sm> thanks
15:56:25 <Alija_> thomashartman1, what I mean is like, a debugger for example, where I can follow whats going on step by step
15:57:17 <vixey> what's i18n'd,
15:57:40 <sm> internationalised, so I could let a french user type in janvier
15:59:27 <Peaker> thomashartman1: the ghci debugger is usable?
15:59:30 <thomashartman1> Alija: hugs has some debugging stuff but it's a bit dated.
15:59:31 <Peaker> I tried to use it, big fail
15:59:38 <thomashartman1> Peaker: depends what you're trying to do.
15:59:48 <thomashartman1> I don't use it that much but I played with it some and I could see the potential.
15:59:50 <Alija_> thomashartman1, can you tell me?
16:00:07 <thomashartman1> Alija: I think something called hood
16:00:28 <thomashartman1> honesly you're probably better off using the ghci debugger if you're wanting to learn
16:00:45 <thomashartman1> Peaker: I think the ghci debugger is a good tool for learning haskell and getting an intuition for how stuff works
16:00:54 <thomashartman1> less good for actually getting work done
16:01:06 <thomashartman1> alija: I don't use hugs much
16:01:13 <thomashartman1> (at all :) )
16:01:43 <Peaker> thomashartman1: I tried actually debugging with it, the breakpoints didn't seem to work consistently, and neither did the "step" command
16:01:45 <sm> it can be very useful, but it takes some learning and isn't as flexible as most debuggers
16:02:05 <sm> setting a breakpoint does seem to be hit and miss
16:02:26 <sm> note the difference between steplocal, stepmodule and step
16:02:45 <sm> hey there thomashartman1
16:02:48 <thomashartman1> I found the ghci debugger caused "heisenbugs" when I used it with a HAppS web application that used threads and was a bit more "dynamic" than typical examples in manuals.
16:02:58 <thomashartman1> sm. do we know each other? :)
16:03:10 <sm> you just mailed me about hledger
16:03:13 <thomashartman1> hi!
16:03:17 * sm waves
16:04:22 <thomashartman1> sm: I'm not sure when I'll next be in L.A. but it'll happen eventually, my whole family is there :)
16:04:55 <thomashartman1> By heisenbugs I mean, bugs that only happened when I was running the debugger. ick.
16:05:11 <cpfr> sm: are you going to lafp?
16:05:13 <sm> great, keep me posted
16:05:26 <sm> I hadn't heard about lafp, when is it ?
16:05:28 <thomashartman1> sm: will do.
16:05:33 <cpfr> december 9th
16:05:37 <cpfr> there will be cake
16:05:53 <sm> cake! thanks for the heads-up
16:06:10 <cpfr> http://groups.google.com/group/socalfp
16:06:12 <lambdabot> Title: Southern California Functional Programmers | Google Groups
16:06:17 <Alija_> thomashartman1, it doesnt word, I mean hood.
16:06:33 <aconbere> so I was poking around this problem yesterday
16:06:34 <monochrom> I want lambda cake
16:06:35 <Alija_> and it's not in the list of help
16:06:37 <aconbere> trying again :)
16:06:59 <thomashartman1> Alija: sorry then. like i said, ghci debugger is probably a good bet.
16:07:07 <Alija_> okay
16:07:21 <aconbere> I have some code that uses the IO monad, in the shell if I call it it returns me a list of Movies. If I use it out of the shell it returns IO [Movies] and I can't use list functions on it
16:07:23 <cpfr> outside of ByteString are there good functions for trimming and splitting strings?
16:07:29 <aconbere> I know this is part of how monads work
16:07:37 <thomashartman1> alija: http://cvs.haskell.org/Hugs/pages/users_guide/observe.html
16:07:38 <lambdabot> Title: Hugs debugging primitives
16:07:41 <aconbere> I'm just not sure how people usually deal with that kind of scenario
16:07:47 <Alija_> I dont know why are we using hugs in this case if ghc has a better debugger
16:07:52 <Alija_> in my class I mean..
16:07:58 <thomashartman1> cpfr: MissingH
16:08:09 <thomashartman1> Data.String.Util or something similar
16:08:32 <thomashartman1> aconbere: you can use list functions.
16:08:53 <Cale> aconbere: Do you understand that an IO [String] is not a list of strings, but a program which if executed will give a list of strings?
16:09:04 <thomashartman1> return . head =<< (return [1,2,3] :: IO [Int])
16:09:31 <aconbere> Cale: I do not!
16:09:43 <cpfr> thanks thomashartman1
16:09:55 <lilac> why is FieldTrip called FieldTrip?
16:10:00 <chessguy> you know what would be an interesting project?
16:10:00 <Cale> aconbere: To run such an IO action, you can use the notation   v <- x   in a do-block. The variable v will then be bound to its result, which in your case is a list of strings.
16:10:15 <Cale> aconbere: The do-block as a whole will be another IO action.
16:10:26 <thomashartman1> aconbere: what cale said is equivalent to what I wrote. do and the =<< / =>> are two ways of doing the same thing.
16:10:31 <chessguy> a library for turning haskell code into IL that can be passed to the .Net CLR
16:10:37 <aconbere> this is what I'm trying to do
16:10:38 <aconbere> http://paste.pocoo.org/show/92610/
16:10:38 <Cale> aconbere: In the end, the main of your compiled program will be an IO action.
16:10:53 <Cale> thomashartman1: s/=>>/>>=/
16:10:59 <Alija_> thanks thomashartman1:)
16:11:15 <aconbere> but I think you're both telling me what I thing I understood yesterday, which is that I'm stuck being in do land for all this sort of stuff :(
16:11:30 <lilac> aconbere: yes, but it's a feature :)
16:11:35 <chessguy> there's already a haskell-parser in haskell write?
16:11:38 <chessguy> err, right?
16:11:59 <Cale> aconbere: What's the error message?
16:12:01 <thomashartman1> aconbere: I think of the monad pipes (=<<, >>=) as ways to "escape" the IO monad and be able to use whatever pure functions you like
16:12:13 <Cale> aconbere: That doesn't actually look wrong.
16:12:29 <thomashartman1> of course, you haven't really escaped the monad, it's just a manner of speaking :)
16:12:33 <Cale> aconbere: getMovies "myFile" will be an IO action for getting the movies from that file.
16:12:51 <aconbere> Cale: I get
16:12:52 <aconbere>     Couldn't match expected type `[MovieTitle]'
16:12:53 <aconbere>            against inferred type `IO [MovieTitle]'
16:13:02 <aconbere> when trying to call "byYear"
16:13:08 <Cale> aconbere: aha
16:13:21 <lilac> aconbere: http://arcanux.org/lambdacats/io-monad.jpg
16:13:27 <Cale> aconbere: The problem is that getMovies fname is not a list, and you're trying to filter it.
16:13:37 <aconbere> Cale: exactly!
16:13:48 <aconbere> Cale: it's an IO [Thing]
16:13:53 <aconbere> hehe
16:14:02 <aconbere> I want to coerce that into being just list :P
16:14:15 <Cale> aconbere: byYear fname y = do ms <- getMovies fname; return (filter (\x -> year x == y) ms)
16:14:16 <aconbere> or at least understand why I wouldn't want to do that
16:14:43 <Cale> aconbere: If byYear really needs to do I/O, then it must give an IO action.
16:15:13 <Cale> aconbere: Now, you might not actually want to design your program like that. A better design would be to have byYear simply take a list of movies as a parameter.
16:15:18 <Cale> (might be)
16:15:49 <aconbere> Cale: so I'm game with that, but it means that when I want to play around with how this dataset works
16:15:59 <aconbere> that I'm constantly rewriting my main function
16:16:07 <aconbere> so I can be in that do block
16:16:14 <chessguy> @pl \ds -> r (p 8 ds)
16:16:14 <lambdabot> r . p 8
16:16:20 <lilac> aconbere: an IO [Thing] is a computation which produces a [Thing]. you want a computation which produces a filtered [Thing]. so you can take your IO [Thing] computation and glue on a filtering computation (with 'do' or >>=)
16:16:21 <Cale> aconbere: Note that giving an IO action to ghci will also cause that action to be run.
16:16:46 <aconbere> Cale: yeah, I notice this all "just works" in ghci
16:16:56 <Cale> aconbere: And you can write something like  ms <- getMovies "foo"  in ghci
16:17:11 <lilac> ghci has one big do block, to "in the darkness bind them"
16:17:15 <Cale> ghci behaves a bit like the inside of a do-block, except that it adds 'print' to things which need it.
16:17:21 <aconbere> hehe
16:17:57 <Cale> I really hate the 'escaping the monad' terminology and wish that it would die ;)
16:18:04 <aconbere> I guess I just haven't groked the direction that all goes, it's hurting my lispy brain
16:18:20 <aconbere> Cale: hehe, if I said that it's cause it's exactly what I want to do. "Get me out of this monad hell"
16:18:30 <Cale> Well, others here have
16:18:32 <Cale> More appropriate is to ask how you run actions in that monad.
16:18:39 <aconbere> yeah
16:18:41 <thomashartman1> Cale: I didn't even realize it was a teminology, I thought I made it up.
16:18:48 <luqui> lilac, =)
16:18:51 <olsner> Cale: escape reality for a warm and fuzzy monad?
16:18:51 <aconbere> I just feel like that makes this ugly heinous main function
16:19:13 <Cale> aconbere: Ideally, all you should do in the IO monad is your actual I/O.
16:19:40 <Cale> aconbere: That is, things like reading the files you need, and printing the results of computations.
16:19:52 <Cale> aconbere: Everything else that your program does should be outside the IO monad.
16:20:02 <Cale> (that is, it should not involve IO actions)
16:20:06 <aconbere> Cale: but doesn't everything end up IN the IO monad?
16:20:08 <lament> olsner: you can escape reality, but you cannot escape the warm and fuzzy monad!
16:20:12 <aconbere> or the do block that calls it
16:20:13 <thomashartman1> Cale: the reason I think of it this way is that I find the pure functions easier to remember, and of course there are more of them. Whereas the monad has all these "weird" functions like the lifts, kleislis... esoteric stuff.
16:20:14 <Cale> aconbere: Consider this program:
16:20:15 <aconbere> or whatever it's doing
16:20:22 <olsner> lament: nor would you want to!
16:20:30 <Cale> main = do x <- getLine; print (reverse x)
16:20:39 <thomashartman1> When you escape the monad, you can use "normal" functions to do what you wanna do
16:20:42 <lament> olsner: of course not. It's warm. And fuzzy.
16:20:47 <Cale> This is an extraordinarily simple program. It reads a line from the user, and prints it out in reverse.
16:20:54 <aconbere> Cale: sure
16:21:01 <Cale> The main work that the program is doing is reversing the line.
16:21:05 <aconbere> yes
16:21:13 <Cale> The type of reverse does not involve any IO actions.
16:21:30 <Cale> You could substitute reverse for something much more complicated.
16:21:42 <aconbere> but now it's all gunked up in that damn do block, which means if I want to write a bunch of things that act on user input, I either have to use do blocks in them, or write a higher order function that wraps that, or something
16:21:43 <olsner> prefer to build a thin shell of IO code wrapping the functionally pure actual transformation of data
16:21:46 <BrokenClockwork> I want to code elem-function myself with list of comprehension, any approahces?
16:21:49 <thomashartman1> main = print . reverse =<< getLine
16:21:56 <Cale> aconbere: reverse is acting on the user input
16:21:59 <thomashartman1> :t main = print . reverse =<< getLine
16:22:00 <lambdabot> parse error on input `='
16:22:09 <Cale> aconbere: And it doesn't deal with do-blocks or IO actions.
16:22:10 <lament> main = do x <- getLine; print (proveTheorem x)
16:22:24 <Cale> aconbere: It's only the very top level of your program which needs to be in IO.
16:22:26 <luqui> Cale, aconbere is perhaps talking about many inputs...
16:22:30 <olsner> (and that's a good idea for *any* language, not just purely functional ones)
16:23:13 <Cale> aconbere: If you want to loop, you can just have main call itself at the end of course...
16:23:14 <SamB_XP> too bad it's basically impossible in a lot of them ...
16:23:25 <Cale> SamB_XP: What is?
16:23:26 <aconbere> so I guess what I don't get
16:23:32 <luqui> SamB, disagree...
16:23:37 <aconbere> is ... let's say you have a BUNCH of actions you want to do to user input
16:23:49 <SamB_XP> I'm thinking, well, C ...
16:23:55 <DukeDave> Urm, how does one pronounce (<*>)?
16:23:56 <aconbere> and you want to be able to initiate them independantly (with a nice API)
16:24:03 <Cale> aconbere: sure.
16:24:16 <aconbere> it seems like I'm forced to do really odd things to accomplish that
16:24:20 <luqui> DukeDave, I say "star" or "ap"
16:24:23 <Cale> I don't see why...
16:24:37 <aconbere> so let's say we have a reverse and capitize program
16:24:54 <Cale> reverse :: [a] -> [a], capitalise :: String -> String
16:25:02 <luqui> aconbere, some of the things I'm doing now to separate IO and computation would have seemed "really odd" when I was first learning, I admit
16:25:05 <aconbere> I can write r = do x <- getLine; print (reverse x)
16:25:07 <aconbere> and
16:25:25 <aconbere> I can write c = do x <- getLine; print (capitalize x)
16:25:31 <Saya> x <- getInput; print $ reverse . capitalize x
16:25:49 <thomashartman1> I don't get Data.Binary. Can someone just tell me how to convert an Int to a ByteString if they know offhand?
16:25:58 <Cale> reverseAndCapitalise = reverse . capitalise
16:26:05 <DukeDave> luqui: Ah, I notice it has almost the same type as ap :: Monad m => m (a -> b) -> m a -> m b    except s/Monad/Functor
16:26:12 <DukeDave> I look forwards to understanding why :)
16:26:20 <aconbere> Cale: right, but Iv'e had to repeat that whole bit of catpuring input
16:26:21 <jsn> thomashartman1: encode?
16:26:24 <Cale> main = do x <- getLine; putStrLn (reverseAndCapitalise x)
16:26:28 <luqui> DukeDave, yeah, ap is the witness that all Applicatives are Monads
16:26:32 <Cale> aconbere: If you like you can abstract it.
16:26:43 <aconbere> Cale: right with a higher order function
16:26:44 <thomashartman1> jsn: what lib?
16:26:49 <jsn> Data.Binary
16:26:52 <aconbere> I guess that just seems like a big pain in the ass :P
16:26:54 <Cale> aconbere: There's also 'interact'
16:26:57 <Cale> :t interact
16:26:57 <andrewsw> can you do: c= do x <- getLine; print (reverse x); y <- getLine; print (capitalise y)
16:26:58 <lambdabot> (String -> String) -> IO ()
16:27:05 <luqui> DukeDave, er, reverse that :-)
16:27:09 <aconbere> Cale: well... usually I'm not so interested in returning to IO
16:27:12 <aconbere> but yeah I read about that
16:27:20 <luqui> (i stared at it for so long, knowing something was wrong)
16:27:24 <thomashartman1> oh ya
16:27:27 <olsner> SamB_XP: oh, C you say? well... you can take the horse to the water but not make it do calculus :P
16:27:34 <jsn> thomashartman1: that is adequate?
16:27:37 * aconbere really just wants his movie titles as first class objects, not crazy IO [MovieTitles] :)
16:27:40 <SamB_XP> olsner: lol
16:27:44 <jsn> it will of course put a lot of garbage in the front
16:27:47 <SamB_XP> what is that even supposed to mean ?
16:27:50 <Cale> aconbere: The idea is that if you can express your program as a function from its input string to its output string, then interact applied to that function gives you all the IO that you'll need.
16:27:53 <thomashartman1> jsn: I think so.
16:27:55 <aconbere> but maybe a higher order function is the right way
16:28:15 <EmielRegis> hmm im wondering what to put in constructor for STUArray
16:28:19 <EmielRegis> it looks like this now
16:28:23 <EmielRegis> array <- newArray ((0,0),(screenWidth-1,screenHeight-1)) black (STUArray s (Int,Int) ColourT)	
16:28:26 <olsner> SamB_XP: something about the hopelessness of coding C, I guess
16:28:34 <EmielRegis> but I need to put some state from ST monad for s
16:28:38 <EmielRegis> any help on that?
16:28:44 <Cale> aconbere: The right way is to write all the interesting part of your program without any regard to I/O, as a function from appropriate inputs to appropriate outputs, and then to use the IO monad to write a user interface for it.
16:28:59 <luqui> EmielRegis, in the ST monad, "s" is always anonymous
16:29:15 <thomashartman1> jsn: actually not quite. I need the first four bytes of the encoded int.
16:29:15 <luqui> EmielRegis, it is a "region variable", which keeps separate ST computations from interfering with each other
16:29:16 <jsn> aconbere: it is probably more common to use several functions
16:29:25 <aconbere> Cale: that's what I'm trying to do, but I get stuck when I actually want to get the data out
16:29:28 <EmielRegis> so what should I put there?
16:29:29 <aconbere> because my non-IO functions
16:29:36 <jsn> thomashartman1: look at Data.Storable
16:29:39 <aconbere> all break when they get the IO [MovieTitles]
16:29:46 <luqui> EmielRegis, well, that code doesn't even make sense to me
16:29:56 <aconbere> but I think the right answer is you have to pass those into the do block
16:29:58 <Cale> aconbere: Consider replacing getMovies with a function which instead of taking a filename takes a String.
16:30:01 <aconbere> maybe
16:30:02 <luqui> EmielRegis, the last part is a type...
16:30:03 <jsn> unfortunately, Data.Binary overlaps serialization with binarification
16:30:07 <Cale> aconbere: That is, it takes the *result* of the readFile
16:30:09 <luqui> EmielRegis, you don't have to write that part
16:30:25 <EmielRegis> luqui, no? I thought you have to explicitly state what kind of array you want to initialize
16:30:28 <thomashartman1> jsn: I think I need to convert lazy bytestring to a strict bytestring (which is list-based)
16:30:46 <jsn> thomashartman1: hmm? that has something to do with the rest?
16:30:54 * aconbere has to go
16:30:55 <luqui> EmielRegis, well, sometimes you do.  it depends on how much can be inferred
16:30:57 <aconbere> thinks Cale
16:31:09 <BrokenClockwork> is it possible to code my own init with pattenr matching or something?
16:31:20 <Cale> aconbere: Does that help?
16:31:46 <thomashartman1> jsn: encode puts you into lazy bytestring, and I don't know how to deconstruct those values. with strict bytestring I could just use take.
16:31:57 <jsn> oh i get it
16:31:57 <EmielRegis> luqui, well, i dont really care about which specific array this is, just i want it to be muttable
16:32:00 <luqui> EmielRegis, you might need "scoped type variables" to state the type if you need to
16:32:04 <Cale> aconbere: Typically, functions in well-designed Haskell programs might have a few extra parameters than they would in a language with side-effects everywhere.
16:32:07 <jsn> well, encode would give you a bunch of garbage in front
16:32:12 <luqui> EmielRegis, ah, well then don't worry about writing the type
16:32:15 <jsn> so you don't actually want the first four
16:32:19 <Cale> aconbere: This is because we like to be more explicit about what things really depend on.
16:32:27 <Cale> (and the language forces us to be)
16:32:47 <EmielRegis> luqui, ok thanks. now, how would I pass the array for it to be changed in aux function?
16:32:55 <Cale> aconbere: If you write everything in the IO monad, then you won't need those extra parameters, but you lose a lot of the benefits of referential transparency.
16:33:11 <Cale> aconbere: (but Haskell can be a beautiful imperative language)
16:33:18 <EmielRegis> LIES
16:33:21 <luqui> EmielRegis, you named it called "array".  so... type "array" :-)
16:33:24 <luqui> s/called//
16:33:54 <EmielRegis> so it can be passed like any normal variable? sry for stupid questions,  im not used to monads yet
16:34:16 <luqui> of course Haskell's possible beauty as an imperative language, which I agree exists, is nothing compared to its possible beauty as a functional language
16:34:28 <luqui> EmielRegis, it's fine.
16:34:37 <ivanm> Cale: I find that when using haskell as an imperative language, it often has way too much indentation :s
16:34:39 <EmielRegis> ye i just checked it works :p
16:34:45 <conal> and, in a sense, the imperative beauty is only skin deep.
16:34:51 <luqui> EmielRegis, yeah, when you say foo <- someMonadAction, foo is just a normal variable that you can use for the rest of that block
16:34:55 <EmielRegis> well are you kidding me? the only thing you can do imperative in haskell is do-notation...
16:34:58 <luqui> (and return it from that block, or...)
16:35:02 <conal> it makes imperative programs prettier, but doesn't address the semantic snarls.
16:35:03 <lament> @quote imperative
16:35:03 <lambdabot> Cale says: Ruby is kind of a nice language, for an imperative object oriented language that isn't smalltalk.
16:35:04 <EmielRegis> and it only works for monad
16:35:09 <lament> @quote imperative
16:35:10 <lambdabot> DavidAmos says: the real reason for using Haskell is that the code comes out shorter, and is quicker to write, than in imperative languages .. What that means is, I can get much more done when I use
16:35:10 <lambdabot> Haskell
16:35:20 <lament> boring
16:35:22 <lament> @quote imperative
16:35:22 <lambdabot> bos says: imperative languages only go up to ten
16:35:26 <lament> heh
16:35:30 <conal> lol
16:35:38 <Cale> conal: I think it's actually an excellent imperative language *because* it's functional.
16:35:59 <Cale> You can write your own control structures, for instance, and actions are first-class.
16:36:12 <conal> Cale: agreed.  excellent at manipulating semantically intractable computations.
16:36:16 <conal> Cale: because its functional.
16:36:18 <EmielRegis> luqui, last question, what do I need to declare in instance of MArray for my vector type to work with it?
16:36:27 <conal> Cale: but the result is still semantically intractable.
16:36:35 <conal> s/but/and/
16:36:47 <luqui> EmielRegis, hmm, you're declaring an instance of MArray?  that's a pretty uncommon thing to do
16:36:55 <luqui> or did I completely misparse that?
16:37:11 <Cale> Well, it's not as good as using the language properly, but I think the result is more tractable than a lot of languages in common use.
16:37:15 <EmielRegis> luqui, well, I cmpiler moans that there is no instance for my vector ( colour) type
16:37:20 <EmielRegis> which is Float Float Float
16:37:36 <luqui> EmielRegis, can you paste the relevant code
16:37:40 <lilac> how does one create a Sound.OpenAL.AL.Source?
16:37:54 <luqui> EmielRegis, most commonly, when ghc recommends you declare an instance, that's not what you should do :-/
16:38:03 <conal> Cale: the semantic domain is the same.  and yes, when i wield a dangerous weapon, i like to do it skillfully.
16:38:06 <thomashartman1> jsn: Data.ByteString.Lazy.unpack . encode $ 1000 ... I think this does what I want... closer anyway
16:38:36 <luqui> :t unpack
16:38:37 <lambdabot> Not in scope: `unpack'
16:39:00 <Cale> conal: While I agree with you that there are better ways to handle certain types of programs, I think that at least as long as you want to be writing programs for contemporary operating systems, anything which is reasonably universal will look at least somewhat imperative.
16:39:13 <Cale> (at the outermost level)
16:39:19 <EmielRegis> luqui, http://hpaste.org/12390
16:39:29 <roconnor> The IO monad is really the OS monad
16:39:48 <EmielRegis> "No instance for (MArray a ColourT IO)
16:39:48 <thomashartman1> luqui: it's in Data.ByteString
16:39:49 <luqui> EmielRegis, ah, you can't do actions at the top level like that
16:39:55 <luqui> EmielRegis, or are you not?
16:40:02 <thomashartman1> So this crypto spec I'm trying to implement says "         Here, INT (i) is a four-octet encoding of the integer i, most"
16:40:02 <thomashartman1>          significant octet first.
16:40:07 <EmielRegis> its in a do statement
16:40:12 <luqui> thomashartman1, I was just checking if I could do it in lambdabot.  which I probably can, but I don't care anymore :-)
16:40:30 <thomashartman1> L.unpack . encode $ 1000000
16:40:30 <thomashartman1> [0,0,15,66,64]
16:40:44 <luqui> @hoogle newArray
16:40:44 <lambdabot> Data.Array.Base newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
16:40:44 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
16:40:44 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
16:41:02 <thomashartman1> So do I want to read from the left or the right... what does most significant digit mean?
16:41:11 <conal> Cale: the challenge that interests me is how to move that OS cruft out of the programming model into the RTS.
16:41:11 <luqui> EmielRegis, what's the error?
16:41:37 <EmielRegis> "No instance for (MArray a ColourT IO) arrising from use of 'newArray'"
16:41:40 <conal> Cale: like functional languages have done already and more so
16:41:59 <lilac> greh. what terrible documentation
16:42:00 <jsn> conal: the thing i find hard to imagine is a resource model for that
16:42:02 <conal> e.g., updating thunk pointers, munging stack frames, etc.
16:42:11 <jsn> conal:  what do sockets look like?
16:42:26 <Saizan> EmielRegis: add a type annotation like :: IO (IOArray Int ColourT) or what'ever your index is
16:42:33 <luqui> conal, and better yet, move the OS cruft out of the OS...
16:42:40 <conal> jsn: yep.  good questions.  i could guess.
16:42:40 <Cale> conal: FFI is a particularly tricky one.
16:42:52 <conal> sounds like function calls & marshalling to me.
16:43:00 <conal> (implementations of ...)
16:43:15 <Cale> conal: How do we design an FFI for a functional reactive programming model?
16:43:27 <ddarius> luqui: Why stop there?  Push out of the OS, then push it out of the hardware, then push it out of physics.  Take that God!
16:43:34 <conal> Cale: yep!
16:43:43 <luqui> ddarius, well, it's not in physics.  at least not in our models of physics.
16:43:56 <luqui> physics is purely functional :-)
16:44:11 <conal> seems to me
16:44:14 <luqui> (mathematicians do not work imperatively)
16:44:14 <jsn> conal: the over-arching notion of making the whole system a "function of time" is hard to argue with
16:44:40 <ddarius> luqui: Our models of physics certainly have cruft.
16:45:03 <ddarius> luqui: Though, I will agree that physics itself seems reasonably well put together.
16:45:05 <luqui> ddarius, but not imperative OS cruft.
16:45:23 <luqui> it's a different kind of cruft.  "this doesn't make sense" cruft.
16:45:25 <Cale> Physics has lots of poorly defined things...
16:45:41 <lilac> how /obvious/. to even get basic functionality out of openal i need to use a typeclass from OpenGL.GL.BufferObjects which isn't even mentioned in the OpenAL docs :(
16:45:43 <Saizan> like?
16:45:50 <jsn> like the boundary between deterministic and probabilistic behaviour
16:45:58 <luqui> lilac, yep!  OpenGL has that problem too.
16:46:04 <Cale> Saizan: Feynman path integrals?
16:46:16 <lilac> luqui: is there a bug report on this already?
16:46:26 * luqui is not a libraries@ hacker
16:46:49 <EmielRegis> well, quantum physics is pretty borked thats true
16:46:57 <EmielRegis> but it works so no one complains :P
16:46:59 <luqui> EmielRegis, oh sorry, I missed that.
16:47:00 <Cale> EmielRegis: Quantum mechanics is fine.
16:47:06 <luqui> EmielRegis, I mean your type error.
16:47:10 <Cale> EmielRegis: It's the stuff after that which is messed up.
16:47:16 <EmielRegis> Cale, what stuff?
16:47:20 <ivanm> quantum physics is one of the most proven parts of science
16:47:34 <Cale> Quantum electrodynamics
16:47:57 <EmielRegis> http://hpaste.org/12390#a1 <-- this produces parse error on <- O-o
16:47:59 <ddarius> Cale: Quantum mechanics is an amalgamation of ad-hockery, but, yes, I will agree that the stuff after that is really bad.
16:48:14 <Cale> Physicists generally have a disregard for things which I think they should be paying a lot more attention to... things like whether operators are bounded or continuous, and what their domains are.
16:48:18 <EmielRegis> Cale, whats wrong with it?
16:48:27 <DukeDave> Bleh, sorry to go on topic again guys ;)
16:48:28 <DukeDave> Can someone add parens to this, all the infix is upsetting me :(           pure (.) <*> u <*> v <*> w
16:48:34 <ddarius> Cale: Pssh
16:48:37 <Saizan> EmielRegis: you can't use <- at the top level
16:48:45 <EmielRegis> Saizan, its in a do statement...
16:48:46 <ddarius> Cale: That's how you do physics.
16:48:49 <lilac> how do i find the BTS for a hackage package?
16:49:00 <ddarius> Cale: If you cared about such things, you'd be a mathematician.
16:49:00 <lex8899> fromInt ?
16:49:02 <luqui> EmielRegis, specialize to IOArray
16:49:06 <roconnor> (((pure (.)) <*> u) <*> v) <*> w
16:49:07 <DukeDave> Like this?     ((pure (.)) <*> u) <*> (v <*> w)
16:49:13 <DukeDave> Ha
16:49:18 <luqui> EmielRegis, (maybe, this error is perplexing me a bit)
16:49:19 <lex8899> no longer exists? (Int -> Double) ?
16:49:22 <DukeDave> Cheers roconnor
16:49:28 <conal> it's also important to me to eliminate the imperative stuff from our programs because functional code is way more composable.  that's why TV keeps the interface part with but separable from the pure part.
16:49:45 <DukeDave> I wish infix would die
16:49:52 <ddarius> lex8899: It should never have existed.
16:49:56 <ddarius> Use fromIntegral.
16:50:06 <ivanm> DukeDave: what's wrong with infix notation?
16:50:11 <luqui> conal, for udon i've been thinking about a composable command line interface
16:50:21 <ivanm> IMHO, "1 + 2" > "+ 1 2" or "1 2 +"
16:50:22 <Saizan> EmielRegis: then your paste should have reflected that, however maybe it's a problem of indentation?
16:50:22 <lex8899> great, thanks
16:50:23 <luqui> conal, i.e. command lines that can be composed with other command lines in a nice way
16:50:32 <Saya> isnt that what pipes are for?
16:50:36 <conal> luqui: with the composition happening on the pure part?
16:50:38 <DukeDave> It just adds an extra layer of confusion when learning
16:50:42 <DukeDave> (imho)
16:50:55 <ivanm> wtf?
16:50:55 <conal> Saya: yes, and pipes restrict the interface to text.  see my google talk
16:50:57 <luqui> conal, with composition happening at the shell level.
16:51:09 <EmielRegis> oh yea, it was missing ; in the end of the line
16:51:10 <EmielRegis> ;)
16:51:13 <conal> http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
16:51:19 <lambdabot> Title: Conal Elliott » Tangible Functional Programming: a modern marriage of usability ..., http://tinyurl.com/5vrmhu
16:51:20 <EmielRegis> i should stop using this silly C notation
16:51:22 <conal> luqui: on functional or imperative?
16:51:29 <luqui> conal, hmm?
16:51:31 <jsn> it's true that pipes basically force every stage in the pipeline to deal with parsing
16:51:51 <conal> jsn: and unparsing.
16:51:55 <jsn> right
16:51:57 <conal> and dynamic tpg
16:51:58 <conal> typing
16:52:02 <jsn> right
16:52:08 <Cale> ddarius: See, what concerns me is that in order to be a scientist, using the scientific method, you're meant to compose theories that make consistent predictions. For all the amazing things mathematics allows one to do with regard to this, it is an inherently dangerous tool for it, because if you make a mistake, you can end up with an inconsistency that allows you to show anything.
16:52:09 <luqui> basically I would like udon to conform to some interface that other command line programs could conform to, so that they can be composed nicely
16:52:10 <conal> and lack of graphics
16:52:14 <jsn> conal: well, no
16:52:22 <jsn> conal: because of course you can stream those
16:52:26 <Cale> ddarius: A model which allows you to predict anything is not falsifiable ;)
16:52:28 <jsn> conal: as bytes in some format
16:52:43 <Saya> conal: ill take a look :) indeed pipes are quite restrictive but in that case you could just use ghci (or python or whatver) as a command line with the appropriate lib loaded
16:52:46 <SamB_XP> Cale: physicists do not care about THAT
16:52:57 <ddarius> Cale: One doesn't need inconsistency to do that in physics.
16:52:57 <jsn> conal: the idea of typed channels is frustrating from a few different angles, though
16:53:06 <Cale> Of course, the real problem is that inconsistencies might be subtle enough to go unnoticed.
16:53:08 <EmielRegis> SamB_XP, depends who specifically ;)
16:53:12 <jsn> conal: first of all, it's not network transparent
16:53:15 <ddarius> Cale: Anyway, the metric is if you can build something using the knowledge.
16:53:24 <SamB_XP> Cale: I mean, well, a physicist is a bit smarter than a theorem prover ...
16:53:30 <luqui> jsn, how so?
16:53:55 <Cale> SamB_XP: I'm not asking them to be formal theorem provers, I'm asking them to try not to do things which are blatantly wrong or ill-defined.
16:54:02 <jsn> you need some kind of barrier where the parsing/unparsing happens when you are trying to "compose" with remote functions
16:54:14 <jsn> luqui: basically, the interface changes at that point
16:54:14 <Cale> SamB_XP: Because the result is something which is no longer science.
16:54:30 <conal> pipes are also linear
16:54:31 <luqui> jsn, can you elaborate?  why can there not be typed network channels?
16:54:33 <ddarius> Admittedly, if physicists paid more attention to such details we'd probably be farther along in physics and with a better understanding than we do now, except that we probably wouldn't have gotten so far in mathematics...
16:54:43 <jsn> luqui: well, that relates to the other thing
16:54:51 <conal> i list a lot of defects in the pipes model in that google tech talk.
16:54:53 <jsn> luqui: which is totalitarianism
16:55:17 <jsn> luqui: you can't have typed network channels if you are talking to some old DEC machine
16:55:30 <fnord321> conal, url?
16:55:32 <jsn> you need to parse/unparse that stuff
16:55:43 <roconnor> ddarius: I think the opposite.  If physicists didn't work with ill defined concepts, physics would have been held back.  No integration with respect to the dirac "function" for example.
16:55:44 <conal> fnord321: http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
16:55:45 <luqui> jsn, why can't it be of type RawStream?
16:55:46 <lambdabot> Title: Conal Elliott » Tangible Functional Programming: a modern marriage of usability ..., http://tinyurl.com/5vrmhu
16:55:53 <EmielRegis> alrite, I almost got it working - however upon switching to IOUArray (as i prefer unboxed version) it seems I cannot define it with my custom ColourT type. Should I add an instance for doing that or what?
16:56:08 <luqui> jsn, after all in Haskell we could pass everything around as Strings if we wanted to  (like in perl 4)
16:56:12 <jsn> luqui: that is effectively the same thing, isn't it?
16:56:14 <conal> fnord321: that post gives a brief description, and some links, including a youtube
16:56:28 <luqui> jsn, no added benefit for programs using the old model, but the new model benefits
16:56:30 <ddarius> roconnor: My comment has a circular causality relation.
16:56:47 <jsn> luqui: i think you miss the point
16:56:58 <ddarius> roconnor: Much of mathematics has been created making sense of what physicists said.
16:57:03 <jsn> luqui: if you receive values over the network, you have to verify them
16:57:03 <luqui> jsn, well I don't see a problem and you do, so it's very likely i miss the point :-)
16:57:12 <ddarius> And of course, physics strongly relies on mathematics.
16:57:18 <roconnor> :)
16:57:21 <jsn> luqui: it's not the same as receiving them from within a haskell program
16:57:35 <Cale> roconnor: Of course, there are ways to resolve that difficulty.
16:57:38 <luqui> jsn, however, that verification can be standardized and reused.
16:57:40 <EmielRegis> I guess physics is pretty much the only quite useful application of mathematics nowadays
16:57:45 <jsn> luqui: yes
16:57:52 <Cale> roconnor: The fact that they continue to be ignored by many is troubling.
16:57:55 <luqui> jsn, which is what typed network channels would have to be...
16:58:08 <ddarius> EmielRegis: You're a programmer, no?
16:58:11 <jsn> luqui: well, typed network channels would be the network doing it
16:58:15 <fnord321> Thanks Conal. I've delicioused it and I'm off to bed. :)
16:58:17 <luqui> jsn, it's just like casting from Dynamics to haskell types.  we have to do runtime validation to make sure we're allowed to.
16:58:18 <EmielRegis> ddarius, wannabe programmer ;)
16:58:30 <ddarius> EmielRegis: Then you are a wannabe applied logician.
16:58:38 <luqui> jsn, oh, I see.  hmm, that might be possible too, it would just be much harder and more pervasive.
16:58:41 <conal> fnord321: :)
16:58:53 <jsn> luqui: that's the totalitarianism i was talking about :)
16:59:11 <jsn> overall, i think the stream of bytes model need only be lifted a little bit
16:59:11 <EmielRegis> ddarius, I know that. I sure forgot computers. Still, besides those two big fields its not used much else (im counting things like engineering as physics cause it is)
16:59:16 <luqui> jsn, ahh okay
16:59:17 <jsn> to parseable streams of bytes
16:59:30 <jsn> and you gain a whole lot from just that change
16:59:53 <luqui> jsn, sure.  actually my latest project, udon, is attacking something related to that.
17:00:01 <mm_freak> why is main :: IO (), and not main :: IO Int?
17:00:07 <luqui> jsn, streams of bytes with "pointers" in them
17:00:28 <luqui> (not mutable pointers, of course, just the ability to pass pieces of data structures)
17:00:35 <jsn> mm_freak: within the haskell program, how would you use the int
17:00:36 <mm_freak> having to use exceptions to exit with a non-zero process status seems incorrect to me
17:00:42 <jsn> luqui: ah, so like disk blocks?
17:00:49 <Saya> emiel, how about finance for example?
17:00:52 <Stephen|Edibles> EmielRegis: Everything is an application of maths :p
17:00:54 <mm_freak> jsn: the Int could be the program's result value
17:00:54 <jsn> mm_freak: you don't have to use exceptions
17:01:04 <jsn> exitWith
17:01:10 <mm_freak> jsn: exitWith raises an exception
17:01:16 <luqui> jsn, no, hashes and (separately) where you can find the corresponding data
17:01:30 <ddarius> EmielRegis: Physics, Engineering of all sorts, Computer Science, Art, Finance, Economics, significantly but less so in many other fields.
17:01:34 <EmielRegis> Stephen|Edibles, biology is chemistry, chemistry is physics and physics is mathematics. Hence, everything is mathematics!
17:01:39 * luqui has to go.  toodleoo
17:01:45 <EmielRegis> ddarius, art...?
17:01:45 <Stephen|Edibles> EmielRegis: Quoting xkcd ftw?
17:01:56 <EmielRegis> no Stephen|Edibles quoting my physics teacher XD
17:02:01 <EmielRegis> wise guy btw
17:02:04 <Stephen|Edibles> Much art is actually mathematical
17:02:09 <mm_freak> is there any reason for main to be IO () instead of IO Int?
17:02:10 <Stephen|Edibles> Ever heard of the golden number?
17:02:28 <jsn> conal: i don't disagree with your vision -- i am starting to see how the reactive model can be used with file stores and such
17:02:55 <Saya> yeah exept im not sure artists do maths conciously when producing art :)
17:03:01 <EmielRegis> Stephen|Edibles, yes, the golden ratio. But I mean that mathematical methods are no way used by artists, cept in their very brains
17:03:14 <lilac> mm_freak: it'd be a pain to have to say 'return 0' in small programs. even C doesn't require that :)
17:04:27 <mm_freak> huh?  C does
17:04:30 <lilac> mm_freak: also i believe there's a GHC extension where if main :: IO a and a != (), it's equivalent to main' = main >>= print
17:04:30 <dancor> the weird thing is that main can be IO Anything
17:04:32 <conal> jsn: cool :)
17:04:41 <dancor> including IO (IO ())
17:04:43 <Stephen|Edibles> EmielRegis: Ah, but there you go - they use their brains, ergo it is maths (chemicals in their brains, aka chemistry, aka physics aka maths XD). Anyhow, I think we should stop dragging this ot _
17:04:47 <lilac> mm_freak: there's an implicit 'return 0' if control flow falls off the bottom of main
17:04:51 <dancor> which, incidentally, causes your program to just hang..
17:05:01 <lilac> mm_freak: (in C and C++)
17:05:05 <conal> jsn: i think of files as a to-be-hidden implementation technique for persistent behaviors.
17:05:18 <mm_freak> lilac: interesting…  i didn't know that, and i'd still write 'return 0' in main()
17:05:40 <EmielRegis> Stephen|Edibles, it is true, I agree with that. I actually tried to talk this in a colleague coder of mine, who also happens to study chemistry, but he wouldnt believe ;) Poor little fool :D
17:05:51 <mm_freak> however, i think, there is another reason than convenience for main to be of type IO ()
17:05:55 <jsn> conal: persistent behaviours -- you mean, they come back when you start up?
17:06:00 <lilac> mm_freak: the rules for 'main' in C are weird. it's undefined behaviour to call it, for instance :)
17:06:03 <conal> jsn: like the mutable thunk cells in the GHC RTS, supporting lazy pure values.
17:06:31 <mm_freak> lilac: indeed, but although possible, i wouldn't use main in haskell recursively =)
17:06:49 <conal> jsn: yeah.  they outlive a particular session.  they could also be for transient use.
17:07:17 <mm_freak> somehow that would interfere with my way of thinking…  it would feel like the program executing itself, though it doesn't
17:07:39 <lilac> mm_freak: i think that rule in C largely only eliminates IOCCC entries and bizarre argument parsing strategies
17:07:57 <mm_freak> indeed
17:09:02 <conal> is there a common name for fmap (uncurry ($)) ?
17:09:09 <lilac> step 1: make your program accept --help. step 2: make it invoke itself with --help. step 3: parse the output and do what it says you should do
17:09:20 <conal> or even for just uncurry ($)?
17:09:38 <twanvl> ?type uncurry ($)
17:09:39 <lambdabot> forall a b. (a -> b, a) -> b
17:10:02 <lilac> uncurry id :)
17:10:10 <conal> :p
17:10:16 <twanvl> ?type Control.Arrow.app
17:10:17 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
17:10:23 <lilac> nice
17:10:36 <lilac> > app ((+1), 17)
17:10:38 <lambdabot>   18
17:10:44 <conal> hey yeah.  thx twanvl.  that's what i was trying to remember.
17:11:08 <lilac> conal: i'm thinking about writing a reactive wrapper for openal
17:11:23 <adu> lilac: is there one for opengl already?
17:11:29 <lilac> adu: yes
17:11:34 <adu> lilac: where?
17:11:38 <conal> lilac: have you seen FieldTrip?
17:11:40 <necroforest> what does *->*->* mean?
17:11:42 <lilac> adu: reactive-glut and reactive-fieldtrip
17:12:07 <daf> necroforest: looks like a kind signature
17:12:20 <lilac> conal: yes.
17:12:21 <conal> there's a lot to be done with FieldTrip, if people are interested in helping.
17:12:37 <adu> conal: too much to do
17:12:38 <conal> lilac: okay, cool.
17:12:46 <lilac> i think i'd learn more from wrapping something new :)
17:13:00 <daf> necroforest: it describes a higher order type
17:13:02 <conal> lilac: i agree.  you would.
17:13:11 <necroforest> daf, ok
17:13:20 <lilac> is it completely unreasonable to use a "Behaviour Double" to represent an audio source?
17:13:31 <daf> necroforest: like functions take values as arguments, types can take other types as arguments
17:13:35 <conal> lilac: heck no.
17:13:44 <necroforest> daf, oh ok
17:13:46 <lilac> i mean more in terms of efficiency than semantics
17:13:51 <conal> lilac: i think we did that in TBAG and in DirectAnimation.
17:14:13 <conal> lilac: i designed Reactive for efficiency.
17:14:18 <necroforest> daf, wait, if a type takes another type as an argument wouldn't that look like (a -> b) ?
17:14:27 <lilac> can Reactive cope with many simultaneous 44KHz signals?
17:14:29 <daf> ?kind Maybe
17:14:30 <lambdabot> * -> *
17:14:35 <adu> how is h.o down then hackage.h.o is up?
17:14:47 <daf> necroforest: Maybe is a type constructor
17:14:56 <conal> lilac: i don't know.  the code is very pure and so very optimizable.
17:15:03 <necroforest> Right.
17:15:03 <daf> necroforest: it takes one argument, a type, and returns another type
17:15:08 <necroforest> Right.
17:15:17 * shapr boings
17:15:18 <shapr> @users
17:15:18 <lambdabot> Maximum users seen in #haskell: 558, currently: 512 (91.8%), active: 31 (6.1%)
17:15:21 <daf> :t Just
17:15:22 <lambdabot> forall a. a -> Maybe a
17:15:26 <adu> h.o does not exist?
17:16:04 <daf> hmm, not sure that "type constructor" is the right term
17:16:09 <adu> conal: but I'm interested in making demos of FieldTrip :)
17:16:12 <lilac> conal: do you think it would be hard to do automatic vectorization if it turns out to be too slow?
17:16:51 <conal> lilac: i don't know how hard, but i'm very interested in doing that sort of thing in reactive and in fieldtrip.
17:17:19 <necroforest> Oh ok. I think i get it... the type of one of maybe's type constructor is Just::a -> Maybe a, but the type of Maybe itself is * -> *
17:17:25 <Saya> whats fieldtrip all about?
17:17:29 <conal> lilac: and particularly in connecting the implementations to data-parallel haskell.
17:17:36 <daf> necroforest: right
17:17:37 <conal> Saya: purely functional 3D graphics
17:17:44 <conal> @wiki FieldTrip
17:17:44 <lambdabot> http://www.haskell.org/haskellwiki/FieldTrip
17:18:04 <adu> w.h.o is down too
17:18:06 <daf> necroforest: Maybe is a type constructor, Just is a data constructor for Maybe * types
17:18:10 <Saya> neat :)
17:18:14 <conal> Saya: and since FieldTrip is functional, it fits nicely with Reactive.
17:18:46 <conal> Saya: or with any other functional FRP framework.
17:20:06 <Saya> i really have to try that out someday
17:20:46 <conal> Saya: Reactive and FieldTrip are new & wobbly toys, but lots of fun and getting more solid.
17:21:14 <mmorrow> , 42
17:21:21 <lunabot>  42
17:21:24 <lispy> :t Maybe (*)
17:21:25 <lambdabot> Not in scope: data constructor `Maybe'
17:21:27 <mmorrow> hehe, someone discovered "!quit"
17:21:34 <lispy> :t Just (*)
17:21:35 <lambdabot> forall a. (Num a) => Maybe (a -> a -> a)
17:21:37 <mmorrow> guess i shoulda been more original
17:22:07 * lispy notes thta Just (*) is not a Maybe * type ;)
17:22:09 <Saya> conal: So you describe the scene and it does all the opengl rendering? could work with a ray tracing backend too i guess :)
17:22:40 <mmorrow> preflex: seen sbahra
17:22:40 <preflex>  sbahra was last seen on #haskell-blah 11 minutes and 44 seconds ago, saying: shapr, probably right after thanksgiving I'll ship it
17:22:41 <zloog> !quit
17:22:52 <conal> Saya: yeah.
17:23:15 <conal> Saya: and, the surfaces are intrinsically curved, not faceted.
17:23:22 <sbahra> Hey mmorrow
17:23:29 <conal> Saya: akin to FRP's continuous time and Pan's continuous space.
17:23:29 <necroforest> lispy, why does a have to be a Num ?
17:23:38 <lispy> conal: ah, so does it prevent invalid scenes statically?  Or at least, avoid states that are illogical from the point of view of a scene based rendering?
17:23:52 <mmorrow> hey. i had something unexpected come up that i had to deal with for a bit. anywho, that's all done now. i'm still interested in the mmx stuff for sure.
17:23:53 <ddarius> lispy: invalid scenes?
17:23:58 <lispy> necroforest: because the type of (*) requires Nums
17:24:10 <necroforest> oh (*) as in the function
17:24:11 <necroforest> right
17:24:31 <conal> lispy: it hides all of that traversal/state stuff.  so one can't do it wrong.
17:24:34 <lispy> ddarius: mostly I mean, avoiding undefined states
17:24:46 <ddarius> lispy: Such as?
17:25:08 <mmorrow> sbahra: i'll let you know once i've got some notes together.
17:25:16 <lispy> conal: cool.  I thnk we had discussed this a tiny bit once.  I wish I could work on something like that, but I've not had the time.  I'm happy to see you making progress.  I bet you'll do a better job than me :)
17:25:39 <conal> lispy: it helps that i've done it a few times before.
17:25:40 <lispy> ddarius: Well, in order transformations matters
17:25:59 <lispy> s/in//
17:27:27 <Saya> so did you actually build something with this? or its just a proof of concept thing for now
17:27:35 <conal> graphics programming has a weird heritage.  graphics research papers are full of lovely (and often continuous math), but graphics APIs are very stateful & discrete.
17:28:01 <daf> conal: why do you suppose that is?
17:28:25 <conal> Saya: it runs and is a work in progress.  there are wiki pages & mailing lists.
17:28:28 <Saya> because hardware is stateful and discrete :)
17:29:09 <conal> daf: because early programming languages were very low level, reflecting the old-fashioned sequential hardware.
17:29:11 <mmorrow> zloog: heh, now i've actually changed it ;)
17:29:26 <conal> daf: that hardware is gone, but the language paradigm  remains entrenched.
17:29:45 <conal> and sadly, modern cpus have to work hard to emulate those original sequential architectures.
17:29:48 <SamB> conal: afaict, I still have a framebuffer
17:30:05 <mmorrow> cat /dev/urandom | /dev/fb0
17:30:08 <mmorrow> yay!
17:30:14 <conal> SamB: and you can program at the level, but you don't have to.
17:30:35 <lispy> mmorrow: put that in GNUmakefile, make -j10 and you even hve it in parallel ;)
17:30:40 <SamB> conal: well, we don't exactly have a non-sequential way of commanding the CPUs ...
17:30:40 <conal> functional programming shows that we don't have to think at the machine/implementation level.
17:30:46 <mmorrow> lispy: hehe
17:30:53 <conal> SamB: i do.
17:31:04 <SamB> conal: what ?
17:31:07 <SamB> what CPU?
17:31:09 <daf> conal: I'm not sure what you mean when you say sequential architecture
17:31:10 <conal> functional programming
17:31:49 <conal> daf: i mean 1940s style computer architecture.  which no longer exist but is emulated by modern instruction sets.
17:31:59 <Saya> well the hardware executes instructions sequentially
17:32:01 <conal> because the language paradigm became entrenched.
17:32:01 <daf> or what you mean when you say that modern CPUs emulate it
17:32:04 <SamB> conal: I meant at the ISA level
17:32:11 <SamB> which is what the CPU must actually deal with
17:32:18 <conal> Saya: not any more
17:32:22 <lispy> daf: CPUs have been influenced by wide spread use of programming languages.  For this reason, modern CPUs tend to be have machine code that supports C really well.  Except that internally CPUs want to be really parallel now...so they have to bridge that parallelism to the C asm
17:32:56 <Saya> well it appears sequential anyways
17:33:00 <conal> we write naturally concurrent (i.e., purely functional) code, which gets compiled into sequential code, which gets mapped to a parallel architecture.
17:33:12 <Saya> hmmmmm i guess i see what you mean
17:33:24 <SamB> conal: what I am saying is that we do not seem to have any adequate non-sequential ISAs
17:33:26 <badsheepy> surely c supports cpu architectures really well not the other way round
17:33:39 <badsheepy> its pretty much asm with nice words after all :o
17:33:46 <SamB> badsheepy: not anymore!
17:34:01 <ddarius> badsheepy: C wasn't created in the 21st century.
17:34:09 <badsheepy> well, not now, but architectures hardly had to change to become more like themselves..
17:34:10 <SamB> well, I mean, the ASM doesn't fit the CPUs too well either
17:34:21 <adu> ddarius: but Vala was :)
17:34:31 <SamB> badsheepy: they've changed a great deal internally
17:34:36 <conal> the very existence of haskell and #haskell demonstrate that we don't have to think at the level of sequential instruction sets.  and backus' "liberated" paper explains why it's harmful to think at that level.
17:34:56 <Saya> well some instructions are executed in parallel or ahead of time but only if they match constraints or they get 'aborted' so its still sequential (looks like transactions!) how would you use the hardware 'functionnaly'?
17:34:58 <SamB> and there has been a widening impedence mismatch between the CPU core and the ISA the CPU has to implement
17:35:01 <conal> http://www.google.com/url?sa=t&source=web&ct=res&cd=1&url=http%3A%2F%2Fwww.stanford.edu%2Fclass%2Fcs242%2Freadings%2Fbackus.pdf&ei=uqcsSd2BL5_Htgea4_GQAw&usg=AFQjCNE_XKhoU2dAacmrCpv4AaJcw4C3OA&sig2=BhUwbi8EyYG8jFRNTuBzHQ
17:35:01 <conal> oops
17:35:05 <lambdabot> Title: cache:http://www.google.com/url?sa=t&source=web&ct=res&cd=1&url=http%3A%2F%2Fwww ..., http://tinyurl.com/5mf386
17:35:09 <conal> www.stanford.edu/class/cs242/readings/backus.pdf
17:35:37 <SamB> conal: well, CPUs don't exactly run Haskell so much remains to be done
17:35:42 <conal> Saya: yes.  that's why cpu's are much slower than they could be.
17:36:02 <conal> Saya: because they're busy emulating sequential machines from the 1940s.
17:36:07 <dancor> isn't cpu design hard enough already? ;)
17:36:10 <lilac> didn't i read about a haskell CPU on an FPGA?
17:36:22 <conal> Saya: and why GPUs are so much faster than cpus.  they don't have the heritage.
17:37:16 <conal> i'm confused.  is anyone here arguing that (a) computers are sequential, finite, and discrete, and so (b) programming models have to relfect those properties?
17:37:18 <sm> is there a way to regexp replace calling a function for each match, using the standard ghc libs ?
17:37:24 <mmorrow> if anyone has read http://people.cs.uu.nl/doaitse/Papers/2003/p224-swierstra.pdf , i was playing around with that and ReadP yesterday, and implemented (not the final part yet) of the Polish paper and stuck a ReadP interface on it
17:37:26 <lambdabot> Title: Polish Parsers, Step by Step
17:37:33 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=501
17:37:34 <lilac> http://www.cs.york.ac.uk/fp/reduceron/
17:37:36 <ddarius> conal: I will argue that they are finite.
17:37:47 <conal> ddarius: and so (b) ?
17:37:47 <lambdabot> Title: The Reduceron
17:37:57 <Saya> i wouldnt say so (b)
17:37:59 <mmorrow> most ReadP code works almost unmodified (only have to s/ReadP/P/)
17:38:11 <ddarius> conal: Actually, programming models don't reflect the finiteness of machines.
17:38:12 <mmorrow> many is broken i think though
17:38:20 <conal> ddarius: exactly!
17:38:34 <Saya> the machinery can be hardware or software it still gives the same result
17:38:46 <conal> after all, this is #haskell.  so i get surprised & perplexed when i think people are arguing that machine characteristics must show through in the programming model.
17:38:54 <lilac> (a).  (a) => (b) |-  (b) :)
17:38:55 <conal> especially *finiteness*
17:39:24 <conal> and discrete & sequential are no more necessarily inherited by languages than finiteness is.
17:39:31 <Saya> i was wondering how you would port the programming model to the machine
17:39:51 <ddarius> conal: It would actually be nice if some aspects of the finiteness of machines showed through (nicely) in some language, albeit not one I'd want to use for most things.
17:40:03 <conal> Saya: we're already doing it.  i routinely program with concurrent, infinite, continuous semantics.
17:40:33 <conal> Saya: e.g., in FRP
17:40:54 <conal> Saya: and in space as well as in time.
17:40:58 <Saya> i mean how would the hardware provide you directly with these abstractions .. yeah frp is alot like electronic design (vhdl...)
17:41:05 <mmorrow> , "hello"
17:41:08 <lunabot_>  "hello"
17:41:10 <mmorrow> wuh
17:41:14 <daf> conal: ah, I see
17:41:27 <daf> but what SamB says makes sense too:
17:41:29 <monochrom> I hope we won't get into "what is hardware"
17:41:31 <conal> Saya: i don't know why you care about the hardware directly providing those abstractions.
17:41:33 <lilac> conal: where concurrent means "sequential, but arbitrarily ordered", infinite means "finite but i'm not saying in advance which bits you get" and continuous means "discrete but on a very fine scale" :)
17:41:38 <daf> one would expect parallel-native ISAs
17:41:53 <daf> even if they were in parellel (so to speak) with compatibility sequential ones
17:42:04 <mmorrow> , "hello"
17:42:04 <conal> lilac: no, i'm talking about *semantics*
17:42:07 <lunabot>  "hello"
17:42:10 <monochrom> There is now much downloadable firmware in new CPUs, both Intel and AMD.
17:42:26 <daf> not just in CPUs
17:42:49 <thomashartman1> bye everyone. thanks for your help. I posted pbkdf2 to cafe if anyone wants to have a look.
17:42:50 <daf> lots of peripherals run most of their funcitonality in software these days
17:42:59 <conal> daf: i think SamB is just talking about something else.  and i don't know how it implies anything about programming model.
17:43:17 <mmorrow> , let nested nest p = p +++ nest (nested nest p); char = Text.ParserCombinators.ReadP.char; runP p = take 1 . readP_to_S p; in runP (nested (between (char '(') (char ')')) (char '.')) "((((((.))))))"
17:43:18 <daf> hmm, it seemed to be the same thing to me
17:43:19 <lunabot>  [('.',"")]
17:43:23 <lilac> conal: i agree you get concurrent and infinite semantics, but i'm not convinced about continuity
17:43:49 <Saya> conal: i dont really care, i was just wondering how it would/could work
17:43:52 <ddarius> daf: There are "parallel-native ISAs"
17:44:26 <daf> are they more inherently FP friendly?
17:44:43 <conal> daf: what does it matter?
17:44:58 <daf> conal: you're saying that our programming models should be decoupled from the ISA entirely?
17:44:59 <conal> daf: we already know we can implement pure semantics on crufty architectures.
17:45:01 <ddarius> Saya: Concurrency is trivial.  Infinite is impossible, but reasonably approximateable.  Continuous is the only not completely trivial one.
17:45:09 <conal> daf: no.  just that they can be.
17:45:17 <sm> to be specific, I'd like to replace all occurences of FUZZYDATEREGEXP in a string with EXACTDATE. To get the latter I have to parse and fill in defaults based on the current time. Text.Regex won't do this I think
17:45:22 <daf> hmm, ok
17:45:36 <conal> ddarius: infinite semantics is not only possible but commonplace in haskell.
17:45:50 <conal> *semantics*
17:45:52 <ddarius> conal: I'm talking about physically modelling the semantics.
17:46:00 <conal> ddarius: why?
17:46:08 <ddarius> conal: Because that's what Saya was asking about.
17:46:25 <conal> ddarius: oh, okay.
17:46:45 <conal> i don't understand why when i bring up semantic issues, people balk and talk about hardware.
17:46:51 <conal> as if the two were related.
17:47:06 <lilac> conal: a semantics where allocation cannot fail is unimplementable, though, isn't it?
17:47:25 <Saya> ! just wondering, dont hit
17:47:39 <conal> Saya: lol.  sry.
17:47:51 <conal> lilac: what you're saying applies to all of functional programming.
17:48:11 <conal> lilac: it's a typical simplification.
17:48:26 <lilac> conal: right. and more than that. things get much more 'interesting' if your turing machine has a finite tape
17:48:32 <ddarius> Many (most?) abstractions are unimplementable.
17:48:34 <conal> nothing to do with infinite, continuous, or (ideally) concurrent semantics.
17:49:42 <conal> and btw, when i say (ideally) concurrent semantics, i don't mean interleaving
17:50:03 <conal> i mean really simultaneous and deterministic.
17:50:05 <lilac> but you also don't mean not interleaving :)
17:50:06 <conal> as in FRP
17:50:15 <ddarius> lilac: Correct.
17:50:18 <lilac> since that's an implementation issue rather than a semantic one
17:50:25 <conal> lilac: exactly
17:50:42 <conal> it has nothing to do with the semantics one way or the other.
17:50:55 <lilac> that depends on how they're expressed, surely
17:51:13 <ddarius> lilac: If it changes the semantics, then it is not a valid model.
17:51:36 <conal> right.  though i'd say if it disagrees with the semantics then it's an incorrect implementation.
17:51:44 <lilac> ddarius: why not?
17:51:55 <ddarius> lilac: By definition.
17:52:08 <lilac> conal: every implementation is incorrect. if your computer is hit by a neutrino it can produce incorrect results :)
17:52:08 <noZone> Talk of Turing machines and tape reminds me: If your Turing machine was connected to the Internet could it get a tape worm?
17:52:35 <ddarius> lilac: There is clearly room for approximation.
17:52:45 <ddarius> lilac: Your CPU is yet another unimplementable abstraction.
17:52:53 <dancor> lolZone
17:52:58 <ddarius> lilac: It also produces incorrect results if you set it on fire.
17:53:16 <lilac> ddarius: i think you missed my point re interleaving. the semantics could require the appearance of interleaving
17:53:23 <lilac> but since we have no semantics, we can't say
17:53:45 <ddarius> lilac: Oh.  If the semantics requires it, then yes, that's both necessary and fine.
17:54:05 <lilac> ddarius: my CPU is a real entity. that it implements the x86_64 instruction set is (marginally) incorrect :)
17:54:23 <ddarius> lilac: But that does not depend on how you "express" the semantics, that's a different semantics altogether.
17:54:32 <dancor> i'm confused that the ghc-6.10.1 source tarball has no packages/ or ./darcs-all
17:55:10 <dancor> i'm concerned about 'checking whether ghc has editline package... no'
17:56:54 <Saizan> ?hoogle unsafePerformIO
17:56:54 <lambdabot> Foreign unsafePerformIO :: IO a -> a
17:56:55 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
17:57:13 <lilac> implementability matters too, obviously. for all i know there might be computible functions which it's not possible to compute within this universe...
17:57:35 <dancor> oh maybe i just have to cabal install editline after to make ghci repl work nice
17:58:02 <Saya> depends, does this universe have infitine space and time?
17:58:15 <dancor> hm no ghci still hates me
17:58:20 <lilac> Saya: i think answering that question would earn you a nobel prize at least :)
17:58:22 <SamB> Saya: well, I don't have infinite time
17:58:29 <Saya> hehe :p
17:58:38 <SamB> lilac: probably take about 40
17:59:12 <Saya> well i leave it as an exercise for the reader
17:59:31 <SamB> you have to actually give that kind a number
17:59:42 <SamB> and put a [50M] or whatever next to it
18:03:35 <mmorrow> dancor: you probably need to install libedit(-dev) with your distro pkg manager
18:04:04 <dancor> mmorrow: i had to install libedit by hand bc i'm on an crap distro at work
18:04:16 <dancor> s/an/an old/
18:04:16 <mmorrow> heh, sounds fabulous ;)
18:04:19 <dancor> it's superfun
18:04:54 <dancor> but yeah maybe ghc is having trouble finding my libedit install..
18:05:04 <conal> SamB: i wonder now if i completely missed what you were getting at.
18:05:05 <mmorrow> hmm, yeah i think that's probably it
18:05:18 <conal> SamB: e.g., with "afaict, I still have a framebuffer".
18:05:55 <SamB> that was unrelated to what I said after that
18:06:55 <conal> SamB: "well, we don't exactly have a non-sequential way of commanding the CPUs ...".  i probably missed what you were getting at there too.
18:07:41 <SamB> conal: what I was saying there is that I'm not aware of any non-sequential machine codes that are actually useful
18:08:18 <conal> SamB: and why did you want to say so?  was it in response to something?  does it imply something to you?
18:09:40 <SamB> it was basically in response to your statement that modern CPUs have to work hard to pretend to be sequential
18:09:43 <SamB> which is TRUE
18:09:50 <SamB> but what else could they reasonably do ?
18:09:57 <sm> re.split(r'\[[^\]]+\]', "a[b]c]d") -> ['a', 'c]d'] . Main> splitRegex (mkRegex "\\[[^\\]+]\\]") "a[b]c]d" -> ["a[b]c]d"] . Why the difference ?
18:10:19 <ddarius> SamB: The Itanium exposed more of the parallelism inherent in modern CPU architecture.
18:10:28 <ddarius> GPUs are parallel.
18:10:32 <conal> SamB: oh.  so you weren't arguing that programming models have to look sequential and discrete.
18:10:48 <ddarius> I suspect many microprocessors and DSPs have inherently parallel aspects.
18:10:52 <conal> SamB: they can do what GPUs do.
18:10:52 <SamB> conal: just that they DO look sequential, in that part
18:11:09 <SamB> well, okay, GPUs don't look very sequential no ;-)
18:11:18 <conal> SamB: yeah.  that "look" is the emulation i mentioned.
18:11:25 <conal> (sequential look)
18:11:57 <SamB> but the GPU model isn't exactly general purpose either
18:12:08 <conal> SamB: GPUs don't look sequential because they were able to break from the imperative mental legacy.
18:12:36 <adu> yum, i want to eat imperative mental legacy
18:12:39 <conal> GPUs are continuing to evolve into general purpose architectures.
18:13:21 <conal> GPUs aren't really graphics processors any more.  they're supercomputers.
18:13:42 <ddarius> Supercomputers being another example of less sequential architectures.
18:13:48 <SamB> conal: well, okay, but they are coming at this from the opposite direction
18:14:01 <SamB> and I don't think GPUs are supercomputers ...
18:14:23 <conal> SamB: okay.  i just meant very parallel and Teraflops.
18:14:24 <SamB> they might be good components for 'em though ;-)
18:14:26 <adu> I think OpenCL will be the new x86
18:14:35 <SamB> OpenCL ?
18:14:47 <Axman6> Apple's GPU programming language
18:14:48 <adu> OpenCL is a library for usingg GPU features
18:14:53 <conal> and even if GPUs didn't exist now for us to point to them, we could imagine them.  i.e., the current ISA just happens to be what it is.
18:14:53 <SamB> hmm, I want OpenWS
18:14:56 <Axman6> but, i think it's more than just GPUs
18:14:58 <SamB> X sux
18:15:31 <ddarius> I think a strong case could be made that the reason desktop ISAs are the way they are now is due to software and wetware legacy.  I don't think a compelling case can be made that that is inherently the better way to structure them.
18:15:33 <adu> SamB: http://developer.berlios.de/projects/openws/?
18:15:34 <lambdabot> Title: BerliOS Developer: Project Summary - OpenWS
18:15:43 <SamB> adu: what's that ?
18:15:49 <conal> ddarius: thx. that's what i was trying to say.
18:15:53 <adu> SamB: you said you want OpenWS?
18:16:09 <SamB> wrong WS
18:16:16 <SamB> I wanted a window system that sucks a bit less
18:16:20 <SamB> ;-P
18:16:37 <conal> i know of an awesome window system.
18:16:40 <adu> SamB: oh, like Jeff Han's? :) hehe
18:17:00 <conal> adu: yeah.
18:17:12 <Axman6> i find Glass pretty good
18:17:21 <Axman6> >_>
18:17:35 <adu> JeffHan++
18:17:43 <conal> i think Haskell could be the core of an incredibly cool network window system.
18:17:54 <conal> purely functional Haskell, i mean.
18:18:01 <conal> (no IO)
18:18:04 <adu> conal: we could start with a binding to VOS
18:18:05 <Axman6> why do window systems need to be networked? -_-
18:18:15 <conal> adu: what's VOS
18:18:27 <adu> http://interreality.org/
18:18:29 <kynky> xmonad, as X is already networkable ?
18:18:32 <lambdabot> Title: Interreality Project - Virtual Object System
18:18:54 <SamB> kynky: but X sux
18:18:59 <Axman6> indeed
18:19:02 <conal> Axman6: they don't.  but i mean to replace http & html etc along with X.
18:19:07 <adu> conal: despite the description, its essentially a tiny, well-designed version of CORBA
18:19:17 <SamB> conal: lol
18:19:19 <conal> adu: oh, thx.
18:19:25 <adu> conal: the 3D aspect is almost an afterthought, but it fits in really nice
18:19:26 <Axman6> conal: ha, i see. that sounds rather... ambitious
18:19:30 <conal> SamB: :)  i do mean it, though.
18:19:38 <SamB> conal: strange combination!
18:19:46 <kynky> thought X as its designed purpose was pretty good, just not great for what most want it to be
18:19:51 <SamB> what does X have to do with HTTP exactly ?
18:20:08 <Axman6> conal: i don't see why http and html need to be replaced
18:20:27 <conal> Axman6: you will when you see what i'm cooking up.
18:20:30 <SamB> kynky: X is pretty good considering ... but it's really really old and a lot has changed since it was created
18:20:33 <conal> SamB: wire protocol.
18:20:40 <kynky> X runs on tcp/ip layer, hence networkable, xlib is basically a clib that can interface with this layer
18:20:45 <SamB> and some of the ideas are a bit questionable
18:21:01 <conal> anyone remember NeWS?
18:21:05 <Axman6> conal: any work done so far
18:21:07 <Axman6> ?*
18:21:07 <lambdabot> Maybe you meant: . ? @ v
18:21:07 <SamB> I've heard of it
18:21:08 <adu> conal: my dream window system would be CrystalSpace + Berlin + ASF/SDF + VOS
18:21:41 <conal> Axman6: many of my projects are pieces.
18:21:48 <Axman6> i see
18:21:52 <SamB> adu: you have a strange dream of +
18:22:00 <Axman6> got any links? i'm curious
18:22:01 <adu> SamB: lol
18:22:25 <conal> Axman6: no links that show the big picture.
18:22:33 <adu> SamB: source code is transient, dreams are forever
18:22:49 <Axman6> well, this http/html replacing stuff sounds interesting
18:22:54 <conal> :)
18:23:47 <conal> NeWS had part of the puzzle, but used an imperative language.
18:24:24 <conal> HTML had another part but wasn't expressive enough.  and yuck.
18:24:32 <kynky> nxclient can be run in a webbrowser using just ajax, which i thought was pretty cool, nx like terminal services aka remote desktop
18:24:33 <conal> untyped, awkward syntax, ...
18:24:43 <conal> kynky: what's nxclient?
18:25:30 <kynky> nx = nomachine, like vnc but alot more efficient
18:25:38 <conal> neat
18:25:59 <gwern> https://secure.wikimedia.org/wikipedia/en/w/index.php?title=Haskell_(programming_language)&diff=prev&oldid=254023118  <-- man, this is so many kinds of fail I can't even begin to express
18:26:03 <lambdabot> http://tinyurl.com/5k45dc
18:27:08 <mmorrow> @remember adu source code is transient, dreams are forever
18:27:08 <lambdabot> Good to know.
18:30:11 <Axman6> gwern: just takes me to the 'Haskell may refer to:...' page on wikipedia
18:30:34 <gwern> Axman6: the undersocres probbably
18:30:46 <Axman6> or maybe terminal.app's url noticingness fails a little
18:31:25 <gwern> > let foo = (==) in foo 4 5
18:31:26 <lambdabot>   False
18:31:59 <Axman6> uh wow, who wrote that code?
18:32:20 <gwern> Axman6: I have no idea. the anon claims that it comes from his 'lecturer RL'
18:32:31 <Axman6> ha
18:32:32 <gwern> I assume he meant IRL
18:32:50 <adamvo> that would be very unfortunate if true
18:32:52 <kynky> so easy to become self certified these days
18:33:42 <Axman6> so, on a quick count, how many things are wrong with that code?
18:34:43 <gwern> it is syntacticaly invalid; the type is wrong; the name suggests that the functionality is wrong; and I suspect the guards are also syntactically broken as well
18:34:51 <gwern> although I'm still writing up the prior faults
18:35:25 <Axman6> > let fibs@(_:rest) = 0 : 1 : (zipWith (+) fibs rest) in fibs
18:35:26 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:35:37 <Axman6> hah, never knew you could do that
18:35:45 <Axman6> huh*
18:35:47 <sm> phew. Working with regexps in haskell, beyond just matching - eg replacing - is not yet easy.
18:36:02 <Saizan> Axman6: "that" being?
18:36:14 <Axman6> fibs@(_:rest)
18:36:14 <sm> most of the regex libs don't seem to even define a sub function
18:36:32 <sm> real world haskell doesn't mention it.. etc
18:36:57 <Saizan> regexes are not really common in haskell
18:37:20 <sm> it's not surprising! :)
18:37:56 <Saizan> well it's a vicious circle, but i guess it started with haskell having parsec and good list primitives
18:38:04 <Saizan> and regexes being ugly anyway
18:38:49 <BMeph> All I see (before a rehash of the article) is "- Um, Gwern is right. Take this to the talk page if necessary"
18:38:51 <mmorrow> also, Parsec needs to be replaced by Parsek/ReadP
18:38:56 * mmorrow ducks
18:39:03 <mmorrow> it's true though
18:39:07 <gwern> 'isBool x | x = True' <-- this will always evalaute to True right?
18:39:19 <Axman6> i believe so
18:39:25 <Saizan> yeah, i very much prefer ReadP
18:39:37 <Axman6> > let isBool x | x = True in isBool "Hello!"
18:39:38 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[Char]'
18:39:42 <BMeph> gwern: Well, it won't if x isn't True... ;p
18:39:44 <gwern> hm. what if x is False?
18:39:47 <Axman6> > let isBool x | x = True in isBool False
18:39:47 <gwern> ah.
18:39:48 <lambdabot>   * Exception: /tmp/516142391650950422:71:36-54: Non-exhaustive patterns in f...
18:39:51 <sm> if I'd understood this, I would have added a pointed comment to the relevant RWH section.. this will frustrate a lot of switchers
18:39:59 <mmorrow> i just the other day found a Parsek repo that reproduces the entire Parsec interface also, so the transition should be easy
18:40:03 * mmorrow find the link
18:40:04 <Axman6> > let isBool x | x = True | otherwise = False in isBool False
18:40:06 <lambdabot>   False
18:40:22 <mmorrow> the best thing about Parsek/ReadP is there's none of this "try" nonsense
18:40:23 <Axman6> but wow, that code is so fail
18:40:44 <BMeph> > let isBool x | x = True | otherwise = False in isBool True
18:40:46 <lambdabot>   True
18:40:48 <roconnor> > let isBool x | x = True | otherwise = False in isBool undefined
18:40:50 <lambdabot>   * Exception: Prelude.undefined
18:40:52 <pumpkin_> mmorrow: did someone say you had a (sparse) matrix lib for haskell, or am I remembering wrong?
18:41:00 <mmorrow> http://www.augustsson.net/Darcs/Parsek/
18:41:05 <BMeph> > let isBool x | x = True | otherwise = False in isBool 23
18:41:06 <lambdabot> Title: Index of /Darcs/Parsek
18:41:08 <lambdabot>       No instance for (Num Bool)
18:41:08 <lambdabot>        arising from the literal `23' at <int...
18:41:08 <Saizan> what's the point of isBool anyway?
18:41:12 <roconnor> Axman6: it fails on so many levels
18:41:30 <dons> my copy of RWH arrived!
18:41:32 <dons> http://www.realworldhaskell.org/blog/2008/11/25/real-world-haskell-is-shipping/
18:41:34 <lambdabot> Title: Real World Haskell » Blog Archive » Real World Haskell is shipping!, http://tinyurl.com/68v2sg
18:41:34 <Axman6> :D
18:41:35 <dons> it's real!
18:41:37 <mmorrow> pumpkin_: hmm, not me. if you find out who though, i'd love to hear about it :)
18:41:45 <dons> and it has a lot of pages about monads.
18:41:46 <Axman6> dons: is it more beautiful than you ever imagined?
18:41:48 <dons> it is.
18:41:50 <mmorrow> dons: congrats
18:41:58 <pumpkin_> mmorrow: damn! okay, I'll keep looking :)
18:42:21 <BMeph> Reminds me of those if (my_condition ==TRUE) {...} stuff from my C days... :P
18:43:03 <dons> anyone else got a copy yet?
18:43:18 <ivanm> dons: so when do us plebes get ours?
18:43:19 <mmorrow> , let char = Text.ParserCombinators.ReadP.charin (\p -> take 1 . readP_to_S p) (char '1' +++ char '0') "0000"
18:43:21 <lunabot>  luna: parse error on input `)'
18:43:30 * BMeph sneaks a peek at the christmas tree.
18:43:30 <mmorrow> , let char = Text.ParserCombinators.ReadP.char in (\p -> take 1 . readP_to_S p) (char '1' +++ char '0') "0000"
18:43:32 <lunabot>  [('0',"000")]
18:43:40 <BMeph> ...not yet. ;)
18:43:46 <gwern> Axman6: I'm starting to think maybe he's just a vandal. I'm not sure even the most nooby noob could think that confection right
18:44:28 <dons> the beetle is very crisp in printed form.
18:44:45 <SamB> dons: but is it crunchy ?
18:44:49 <conal> dons: yay RWH!
18:45:03 <gwern> SamB: but is it tasty in chocolate?
18:45:11 <dons> yaya!!
18:45:20 * gwern singes the vandal: https://secure.wikimedia.org/wikipedia/en/wiki/User_talk:Gwern#Haskell_function
18:45:24 <lambdabot> http://tinyurl.com/69as42
18:45:26 <sm> oh good, I guess that's why http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regexpr exists. Doesn't do programmatic replacements, but the basics seem familiar
18:45:33 <lambdabot> Title: HackageDB: regexpr-0.3.4, http://tinyurl.com/5cnclz
18:45:36 <dons> now we can officially take over the world.
18:45:37 <dons> GO!
18:46:00 * mmorrow channels atilla the hun with his ouija board
18:46:31 <gwern> mmorrow: did you really die of a nosebleed, or were you actually assassinated?
18:46:49 <mmorrow> nosebleeds can't be assassins too??
18:47:21 <sm> yay dons :)
18:47:29 <gwern> nosebleeds lack the murderous intent, and the savoir-faire to toss off a quip before the stabbitude
18:47:47 <mmorrow> ah, too true
18:48:10 <gwern> plus, they don't look sinisterly handsome clad all in black
18:48:11 <Axman6> nosebleeds can choke quite easily if asleep at the time
18:48:23 <SamB> dons: but doing it officially is such a drag
18:48:29 <pumpkin_> that sounds unpleasant
18:48:30 <SamB> it's much more fun to de-facto take over the world
18:48:49 <Axman6> pumpkin_: it is
18:49:02 <pumpkin_> Axman6: oh no, are you undead?
18:49:28 <Axman6> we prefer soulically challenged
18:49:34 --- mode: ChanServ set +o dons
18:49:35 <BMeph> Seriously, 'otherwise false' -- WTF?
18:49:38 --- topic: set to '["Real World Haskell: it is alive!", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
18:49:41 --- mode: ChanServ set -o dons
18:49:46 <dons> ?users
18:49:46 <lambdabot> Maximum users seen in #haskell: 558, currently: 493 (88.4%), active: 19 (3.9%)
18:49:55 <mmorrow> @src IO
18:49:56 <gwern> BMeph: I like how there are at least 3 things wrong with that
18:49:56 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
18:49:58 <dons> i'm hoping we hit 600 over the vacation period
18:50:00 <gwern> x = True is also good tho
18:50:33 <Axman6> @src RealWorld
18:50:34 <lambdabot> Source not found. Wrong!  You cheating scum!
18:50:52 <dancor> inconsistent post-punctuation spacing
18:50:57 <Axman6> i.. i didn't know it was cheating... i just wanted the meaning of life :'(
18:51:42 <dancor> isn't it obvious that the true meaning of life lies in spacing consistencies
18:51:54 <Axman6> is RWH intended to be read cover to cover?
18:52:07 <gwern> hm. did anything ever come of that whole sun-donating-a-server thing?
18:52:12 <Axman6> not just read that way, but written so it can be?
18:52:18 <conal> i wonder how GHC gets away with that definition of IO.  it doesn't seem to address concurrency.
18:52:29 <Axman6> gwern: a guy at my uni is working on it afaik :)
18:52:41 <conal> specifically, interleaving.
18:52:42 <gwern> Axman6: oh. what's he actually doing?
18:52:46 <Axman6> no idea
18:53:02 <Axman6> kinda hoping he'll be one of my lecturers next semester
18:54:15 <ivanm> Axman6: have you heard anything about when we can expect RWH from Fishpond?
18:54:26 <Axman6> nope :\
18:56:23 <ivanm> :(
18:56:23 <mmorrow> if fink the best pkg manager for unix stuff for osx, or is there another that's better?
18:56:40 <Axman6> mmorrow: macports is more better maintained
18:56:43 <ivanm> mmorrow: gentoo prefix?
18:57:00 <mmorrow> cool, i'll check those out, thx
18:57:08 <Axman6> for example, they're up to revision 7 of ghc-6.10.1, ironing out bugs they've had
18:57:25 <mmorrow> nice
18:57:48 <pumpkin_> however macports doesn't have precompiled binary packages
18:57:54 <Axman6> so, anyine know how to tel cabal-install where readline is installed?
18:57:56 <pumpkin_> so big projets take forever to install
18:58:03 <Axman6> adu: right here :)
18:58:07 <adu> hehe
18:59:06 <Axman6> pumpkin_: also means you can get the variants you want too
19:00:31 <Axman6> i'm getting "configure: error: readline not found, so this package cannot be built" when trying to install lambdabot
19:01:08 <ivanm> Axman6: is it actually installed?
19:01:16 <ivanm> I would have thought it'd be a gcc problem, not a ghc one
19:01:17 <mmorrow> oh crap, this is for my brother. so can a non-programmer with gcc installed use macports without trouble?
19:01:26 <Axman6> many times i'd say, a lot of stuff i use relies on it
19:01:45 <Axman6> mmorrow: probably
19:01:54 <ivanm> mmorrow: in that case, gentoo prefix probably isn't applicable ;-)
19:01:59 <mmorrow> cool
19:02:02 <mmorrow> ivanm: heh
19:02:18 <Axman6> if they can type things like 'port instal <port>','port search <term>','port info <port>' they should be fine
19:06:04 <mmorrow> conal: interestingly, dolio suggested seeing if a cps-style def of IO would be faster, and i did a small State monad benchmark and was very surprised by the results: http://moonpatio.com/repos/state-bench/
19:06:05 <lambdabot> Title: Index of /repos/state-bench
19:06:26 <mmorrow> StateCPS is over twice as fast as State with unboxed tuples
19:06:47 <mmorrow> (and mtl (Strict) State comes in third)
19:07:12 <thoughtpolice> @seen Lemmih
19:07:13 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
19:07:23 <Lemmih> thoughtpolice: 'Ello.
19:07:23 <lambdabot> Lemmih: You have 3 new messages. '/msg lambdabot @messages' to read them.
19:07:40 <mmorrow> since IO is essentially State + {# , #), i wonder if a CPS IO would be faster in the same way as that benchmark
19:07:40 <ddarius> mmorrow: This is reasonably well known.
19:07:52 <BMeph> gwern: The reply you made in the 'Atala T' section is brief, but comes off as a little cold. Funny, though: "I've seen the reply."
19:08:24 <mmorrow> ddarius: but completely unheeded?
19:08:26 <thoughtpolice> Lemmih: get my msg? http://projects.haskell.org/pipermail/lhc/2008-November/000001.html
19:08:27 <lambdabot> thoughtpolice: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:08:28 <lambdabot> Title: Current ideas, http://tinyurl.com/5uwlv4
19:08:44 <ddarius> Not widely appreciated or experimented with.
19:08:47 <ddarius> http://r6.ca/blog/20071028T162529Z.html
19:08:48 <mmorrow> ddarius: i'm using cps for all my monads now ;) http://moonpatio.com/repos/monad-cps/
19:08:48 <lambdabot> Title: Continuation Passing Style for Monads
19:08:48 <lambdabot> Title: Index of /repos/monad-cps
19:08:54 <conal> mmorrow: does the model address interleaving?  that's what i'm puzzled about with GHC's def.  i don't see the room for interleaving.
19:09:12 <ddarius> http://www.haskell.org/haskellwiki/Performance/Monads
19:09:13 <lambdabot> Title: Performance/Monads - HaskellWiki
19:09:27 <mmorrow> conal: i'm not really sure what the considerations are exactly wrt interleaving
19:09:41 <mmorrow> mostly because i haven't thought about it really
19:09:47 <mmorrow> that's interesting though
19:09:50 <Lemmih> thoughtpolice: Ah, I wasn't subscribed to the list.
19:09:54 <BMeph> CPS? Uh, it's like CPR, but a step above it! ;)
19:10:17 <conal> mmorrow: well, ghc's def looks very like a simple domain (as in denotational semantics) for non-concurrent imperative programs.
19:10:35 <mmorrow> conal: heh.
19:10:51 <conal> mmorrow: accounting for interleaving makes things much more complicated.
19:10:58 <conal> i.e., makes that domain more complicated
19:11:19 <hackage> Uploaded to hackage: hslogger4j 0.2
19:11:30 <conal> is it just coincidental that GHC's IO def looks like a model of imperative computation?
19:12:20 <mmorrow> i'm not sure. i guess all of this accounting for interleaving has been added to the rts over time, and the original def of IO in ghc retained?
19:12:20 <Axman6> i was talking to someone a while ago about the idea of seperating the input and output parts of IO into different things. i was wonderinf if any work had been done on that?
19:12:41 <conal> Axman6: i wonder also.
19:12:48 <Axman6> excellent :)
19:13:32 <Axman6> specifically, a lot of output need not be treated a non-functional, since it can't really effect the running of the program, unless there's input back into it
19:13:47 <ddarius> mmorrow: There's a paper somewhere if I can remember it's name or find it again.
19:14:10 <Axman6> s/treated a/treated as
19:14:11 <conal> Axman6: Axman6 that's my thinking as well.  i currently use IO for the output stuff in legacy (imperative) adapters for Reactive, but i'm going to change the type to be much more restrictive.
19:14:33 <mmorrow> ddarius: cool, i'll be on the lookout too
19:14:35 <Axman6> sounds excellent :D
19:14:38 <conal> Axman6: for just the reason you said.
19:15:01 <sjanssen> Axman6: can you really consider output pure?
19:15:10 <pumpkin_> seems odd to me
19:15:20 <pumpkin_> but I'm just a newbie
19:15:22 <Axman6> so, maybe there should be an In and an Out monad?
19:15:27 <thoughtpolice> Lemmih: also, I'm going to remove the -fjgc flag since it isn't needed (and doesn't work,) I just tried doing this earlier and I also removed via-ghc, but when I did it caused some very strange compiler problems
19:15:35 <sjanssen> Axman6: yeah, that might make sense
19:15:39 <Axman6> sjanssen: no, not totaally, but it can be treated as pure for a lot of things
19:15:43 <conal> maybe something simpler than a monad.
19:15:47 <Axman6> yeah
19:15:55 <conal> since monad has sequencing
19:16:03 <conal> with information flow
19:16:13 <Axman6> i think input should probably remain the same as it is now, but output might not even need a monad
19:16:13 <sjanssen> Axman6: but you never know where that output is going, it might go to another process that provides your process with input
19:16:47 <conal> sjanssen: the same is true for pure functions.
19:17:04 <Axman6> sjanssen: but who cares? you only worry about handling input. you can't really know anything about what the input you give to another process is going to get back to you
19:17:14 <sjanssen> conal: hmm, true
19:17:15 <Axman6> and that, my friends, is why i fail at talking
19:17:36 <thoughtpolice> Lemmih: I simply replaced a call to a predicate with 'False' instead (since it wouldn't make sense otherwise,) and the compiler through an error about a handle pointer becoming finalized which is extremely odd. I suspect there might be an unsafePerformIO culprit here, because the predicate is defined very unusually and isn't referentially transparent afaics. right now we'll just have to keep -fvia-ghc
19:17:37 <sjanssen> Axman6: I guess my largest concern is that it matters in what sequence bits of output happen
19:17:46 <pumpkin_> but if you really want to think of threading world state around, you are changing the world state with output too, even if it has no actual effect on your program?
19:17:59 <Axman6> sjanssen: i guess, but not all of it does
19:18:28 <conal> sjanssen: not all pairs of functions commute
19:18:41 <conal> i.e., composition isn't commutative
19:18:50 <conal> (function composition)
19:18:59 <sjanssen> conal: similarly with (>>)
19:19:12 <sjanssen> the point is that both (.) and (>>) allow you to specify the order
19:19:43 <conal> sjanssen: yes, both allow order-sensitivity, so order-sensitivity doesn't imply purity or impurity.
19:20:21 <zloog> Can anyone recommend a book on efficient haskell data structures/algorithms?
19:20:22 <conal> sjanssen: i don't know how this story ends.
19:20:22 <gwern> BMeph: you may've noticed I tend to the abusively sarcastic method of suffering fools :)
19:20:38 <pumpkin_> how about the very down-to-earth concern of buffered output having a full buffer? :P
19:20:40 <gwern> zloog: I hear Purely Functional Data Structure is good
19:20:52 <gwern> (indeed, I have it, although I've yet to more than crack it)
19:21:16 <gwern> *Structures
19:21:19 <Axman6> would i be right in saying that only input can change the results of your program?
19:21:38 <zloog> gwern: I was interested in that, but it is almost all ML which has strict evaluation (and I also dont know it)
19:21:58 <sjanssen> Axman6: yes, for a very large definition of input
19:22:10 <mm_freak> if anyone is interested, i've almost completed my monads tutorial by now, and i'd like some feedback
19:22:21 <gwern> zloog: the ML isn't important. all the structures and algorithms are implemented as working haskell code
19:22:22 <Axman6> mm_freak: sure, got a link?
19:22:25 <zloog> mm_freak: link?
19:22:27 <gwern> zloog: look up the edison library
19:22:30 <mm_freak> http://streitmacht.eu/.beta/monads.html
19:22:32 <lambdabot> Title: Monads in Haskell
19:22:41 <zloog> gwern: cool, i'll take a peek
19:23:21 <ddarius> mmorrow: http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf There we go.
19:23:27 <lambdabot> Title: Asymptotic Improvement of Computations over Free Monads
19:23:36 <Axman6> mm_freak: i'd mention something about monads not being all that difficult really, in the intro
19:23:54 <mm_freak> Axman6: the intro isn't even written yet
19:24:07 <mm_freak> Axman6: or you mean in the abstract?
19:24:10 <dons> zloog: purely functional data structures is good. RWH is the other one specifically about performance (and other real world problems)
19:24:13 <pumpkin_> Axman6: in c, printf can fail if there's no memory, is there any provision for that in haskell? it seems that in that case output can depend on world state, unless you consider output as a fire-and-forget process. I could envision writing a program that redirects stdout to a stream with a fixed buffer size, and whose behavior depends on printf failures given that buffer size, but it's awfully contrived (and may not be applicable to hask
19:24:20 <Axman6> sure they're difficult to comprehend initially, but easy once you get them
19:24:22 <gwern> 'monads are easy, as you'll see after working through the next 50 pages..'
19:24:22 <Axman6> mm_freak: yeah
19:24:30 <thoughtpolice> zloog: I just checked out that book from the library about three days ago and it's good; there's an appendix with full haskell code too.
19:24:41 <bd_> pumpkin_: in GHC, your program is terminated if it runs out of memory, I believe
19:24:42 <sjanssen> pumpkin_: in GHC, failure to allocate memory terminates the whole program
19:24:45 <zloog> RWH is already on amazon preorder :)
19:24:48 <pumpkin_> ah, I see
19:24:55 <dons> zloog: it started shipping from amazon today
19:24:56 <pumpkin_> well, then output can affect behavior? :P
19:25:00 <pumpkin_> if you assume being terminated "behavior"
19:25:04 <dons> my copy just arrived, actually, a few hours ago
19:25:12 <pumpkin_> but I guess it's not something that IO would help with
19:25:26 <mmorrow> ddarius: ooh, interesting
19:25:30 <Axman6> pumpkin_: yeah, it doesn;t change anything from what we already have i guess
19:25:34 <zloog> dons: Really? Amazon told me it would take till dec 8th to get it if i chose 1 day air
19:26:04 <dons> zloog: there's been buzz all over today that amazon is shipping
19:26:36 <mm_freak> Axman6: done
19:26:38 <shapr> What are they shipping?
19:26:42 <dons> zloog: this was straight from o'reilly, http://www.realworldhaskell.org/blog/2008/11/25/real-world-haskell-is-shipping/
19:26:42 <shapr> oh, RWH?
19:26:44 <lambdabot> Title: Real World Haskell » Blog Archive » Real World Haskell is shipping!, http://tinyurl.com/68v2sg
19:26:44 <Axman6> cheers :)
19:26:48 <shapr> yay!
19:26:55 <dons> shapr: yeah!! my copy was waiting on the doorstep when i got home
19:26:57 <shapr> w00!
19:27:18 <shapr> Ok, I'm cancelling my order at Barnes & Nobles and buying the combo pdf & hardcopy deal from ora.com
19:27:20 <Axman6> mm_freak: yep, that's perfect
19:27:24 <BMeph> gwern: Yeah. 's Cool. :)
19:27:33 <ivanm> dons: but is it a pre-release because you're an author?
19:27:33 <dons> shapr: probably fastest that way
19:27:38 <shapr> Yeah, definitely.
19:27:56 <dons> ivanm: direct from the publisher's warehouse
19:27:59 <dons> which also feeds amazon
19:27:59 <ivanm> shapr: why pdf as well?
19:28:02 <ivanm> dons: ahhh
19:28:12 <BMeph> ddarius: Ah - a Voigtlaender Special!
19:28:18 <shapr> dons: I've already got one person reading rwh.org and asking to borrow my hardcopy when it shows up, your writings ease proselytization!
19:28:22 <mm_freak> Axman6: i'll have some words about the length of the tutorial in the preamble, related to the fact that monads are not only useful for I/O, but for a lot of tasks
19:28:36 <ddarius> shapr: A nice hefty book to knock upside the head with.
19:28:39 <shapr> haha
19:28:44 <Axman6> mm_freak: yeah, it doesn't start with IO does it?
19:28:55 <mm_freak> nope, it starts with Maybe and lists
19:28:59 <Axman6> things like Maybe and [] are much easier to understand
19:29:01 <dons> shapr: yes. shapr-ising will be much easier now
19:29:01 <Axman6> hooray
19:29:05 <mm_freak> IO is the last monad it introduces
19:29:10 <shapr> ivanm: I want the PDF for personal reference on my N800, there are times when I want to write Haskell and don't have lambdabot/haskell.org/etc handy.
19:29:13 <shapr> dons: haha, yes!
19:29:22 <mm_freak> and it introduces do-notation even later than IO
19:29:28 <pumpkin_> mm_freak: minor stylistic comments allowed?
19:29:34 <ivanm> shapr: ahhh..... since the online version isn't in a convenient one-file-only format?
19:29:35 <mm_freak> pumpkin_: sure
19:29:41 <shapr> ivanm: yop
19:29:45 * ivanm considers bringing out wget...
19:29:50 * shapr shrugs
19:30:00 <pumpkin_> mm_freak: "So I'm trying to provide you with an interpretation, that is very generic and allows you to find familiar patterns in monad usage." extra comma ;)
19:30:01 <ivanm> N800 == Nokia internet tablet?
19:30:02 <pumpkin_> very minor ;)
19:30:19 <shapr> ivanm: Yup, $220 for a thoroughly spiffy linux box running a debian derivative.
19:30:36 <shapr> ivanm: http://en.wikipedia.org/wiki/N800
19:30:37 <lambdabot> Title: Nokia N800 - Wikipedia, the free encyclopedia
19:30:38 <ddarius> dons: So are pictures of the actual hardcopy posted to your blog yet?
19:30:44 <shapr> dons: ooh YES!
19:30:47 <zloog> thoughtpolice: Hey, can you tell me what edition has the haskell appendix? the pdf verison im reading doesnt seem to have it
19:30:55 <dons> ddarius: yes
19:30:57 <shapr> dons: Um hey, can I ask for your autograph in advance?
19:31:00 <dons> ddarius: check the blog
19:31:05 <dons> shapr: you can ask :)
19:31:08 <ddarius> Oh wow, it is in Planet Haskell.
19:31:15 <shapr> I want a fully autographed copy of RWH! All the authors, and lots of #haskell folks too!
19:31:23 <dons> we should get a #haskell-autographed copy
19:31:26 <shapr> YES!
19:31:26 <mm_freak> pumpkin_: i'm used to german, where that comma makes sense =)
19:31:31 <shapr> That would be SO COOL!
19:31:35 <pumpkin_> ooh!
19:31:44 <dons> i could try to collect #haskell's signatures on all my travels, perhaps
19:31:46 <ddarius> dons: None of those angles let you see the thickness.
19:31:52 <dons> ddarius: i'll take some more photos
19:31:56 <shapr> dons: Yay!
19:32:06 <Axman6> ivanm and I were trying to get dons to sign a few copies with the other authors to send to aus, but nothing happened with that :(
19:32:07 <dons> i literally walked in the door. unwrapped the book. took a photo. blogged it. opened a beer.
19:32:15 <shapr> w00!
19:32:25 <ddarius> Don is skilled at this blogging thing.
19:32:29 <shapr> truly
19:32:39 <shapr> He pre-read my mind before I even knew I wanted pix of the book!
19:33:06 <dons> now i have beer and a book. so next, take more photos and also put dinner on.
19:33:20 <ivanm> shapr: map signRWH $ replicate (length $ @users #haskell) [dons,bos,john]
19:33:22 <mm_freak> pumpkin_: and i'd rather add too many than too few commas, because i find they have about the same purpose as parenthesis in source code or math
19:33:24 <shapr> Yeah! I also want to see book thickness.
19:33:34 <dons> oh, i wonder if i have thompson's book here somewhere...
19:33:40 <dons> the one i learnt from
19:33:40 <shapr> ivanm: Yeah, that does sound like a lot of signing.
19:33:43 <ivanm> dons: what kind of beer? american beer that's like making love in a canoe? ;-)
19:33:50 <shapr> I loaned out my copy of Rabhi & Lapalme, and now it's gone forever :-(
19:33:58 <shapr> All my margin notes are gone
19:34:00 * shapr cries
19:34:01 <Nafai> Hi shapr, dons!
19:34:05 <pumpkin_> mm_freak: neat, I hadn't thought of Maybe and List as analogues, seems like Maybe is the ? operator in regular expressions and List is *, for a pretty loose analogy
19:34:06 <shapr> Hiya Nafai!
19:34:17 <shapr> In the future, I won't loan out my annotated copies.
19:34:27 <mm_freak> pumpkin_: i view the list monad as a generalization of the Maybe monad
19:34:29 <pumpkin_> mm_freak: makes sense, but feels a little awkward when reading it, up to you though
19:34:35 <ivanm> shapr: see, you need _two_ copies of each book
19:34:40 <shapr> Yup, I think so.
19:34:41 <ivanm> one for you, and one to lend out ;-)
19:34:48 <shapr> The downside is that I want others to make annotations too!
19:34:52 <ivanm> shapr: or else chain them to a desk...
19:34:59 <shapr> That's my loan out condition. You can borrow this book, as long as you write in it.
19:35:00 <ivanm> ahhh, stealing other people's annotations!
19:35:02 <ddarius> or put a GPS in them
19:35:04 * ivanm hates writing on books
19:35:06 <shapr> ivanm: Exactly
19:35:06 <ivanm> ddarius: lol
19:35:12 <mmorrow> dons: that would be a fitting side-by-side shot for sure
19:35:14 <BMeph> ivanm: s/john/CosmicRay/ :)
19:35:32 <pumpkin_> mm_freak: very neat :)
19:35:35 <ivanm> BMeph: thanks, couldn't remember his nick :s
19:35:57 <shapr> It's actually thoroughly selfish, other people have inspirational thoughts that I don't have, and when they write them down, I get the benefit!
19:36:15 <BMeph> dons: You should stash it in the lobby at Galois, and have folks make pilgrimages! ;)
19:36:24 <shapr> That's not a bad idea.
19:36:25 <ddarius> shapr: And then when you die, other people look at the books and think what great thoughts you thought.
19:36:31 <pumpkin_> > Just $ Just 4
19:36:32 <lambdabot>   Just (Just 4)
19:36:36 <pumpkin_> o.O
19:36:38 <shapr> ddarius: And what amazing variety I have in handwriting ;-)
19:36:43 <pumpkin_> Just $ Nothing
19:36:50 <mmorrow> > join $  Just (Just 4)
19:36:51 <pumpkin_> whoops, no $ needed
19:36:51 <lambdabot>   Just 4
19:36:57 <pumpkin_> > Just Nothign
19:36:58 <lambdabot>   Not in scope: data constructor `Nothign'
19:36:59 <shapr> ddarius: When I'm first exposed to an idea in a book, I write all the things that occur to me in relation.
19:37:00 <pumpkin_> > Just Nothing
19:37:01 <lambdabot>   Just Nothing
19:37:06 <mm_freak> yeah, given lists, Maybe is actually redundant, but for the sake of functions with at most one result and my tutorial, i'm glad to have Maybe =)
19:37:06 <pumpkin_> @src join
19:37:06 <lambdabot> join x =  x >>= id
19:37:09 <mmorrow> > join $ Just Nothing
19:37:10 <lambdabot>   Nothing
19:37:20 <shapr> Then I come back at look at all my writings later, and 95% of them look clueless, and 5% looks amazingly brilliant.
19:37:21 <mmorrow> > join [[]]
19:37:23 <lambdabot>   []
19:37:24 <Axman6> > join Nothing
19:37:25 <lambdabot>   Nothing
19:37:28 <mmorrow> > join []
19:37:28 <dons> ok. took more photos. uploading....
19:37:29 <lambdabot>   []
19:37:30 <shapr> But every few months, the brilliant 5% changes...
19:37:33 <pumpkin_> mm_freak: yeah, allows you to be more specific, which is safer I guess :)
19:37:49 <Axman6> mm_freak: does this make sense? "it employs a structure from category theory called monad." should be 'a monad'?
19:37:50 <BMeph> pumpkin: Are you familiar with Mu (type fixpoint)? :)
19:38:00 <shapr> The Chao says Mu!
19:38:01 <pumpkin_> nope :(
19:38:05 <ddarius> Axman6: Yes.
19:38:20 <Axman6> ddarius: to which question? :P
19:38:27 <ddarius> Axman6: The latter.
19:38:32 <mm_freak> pumpkin_: it allows me to give more examples =)
19:38:36 <Lemmih> dons: Photos? Where?
19:38:37 <Axman6> ok, thought so
19:38:41 <shapr> http://www.realworldhaskell.org/blog/ !
19:38:42 <lambdabot> Title: Real World Haskell
19:39:14 <ddarius> Your menus are eating your pictures!
19:39:22 <mm_freak> ddarius: it's not _the_ monad
19:39:23 * shapr repeatedly hits F5 waiting for the new pix
19:39:42 <pumpkin_> BMeph: anywhere I can find info on it? can't see anything obvious in wikipedia, except a vague link to the fixpoint page
19:39:50 <mm_freak> the structure is called 'monad'…  if you have an object that satisfies the axioms, that object is a monad, no?
19:40:15 <Axman6> mm_freak: a think 'a monad' is more correct here
19:40:22 * Nafai can't wait to read RWH on his new phone 
19:40:24 <Axman6> but i could very well be wrong
19:40:52 <shapr> pumpkin_: http://en.wikipedia.org/wiki/Fixed_point_combinator
19:40:53 <lambdabot> Title: Fixed point combinator - Wikipedia, the free encyclopedia
19:41:06 <doublec> Nafai, what's your phone?
19:41:42 <Nafai> doublec: I just ordered a Google G1
19:41:52 <doublec> nice!
19:42:02 <ddarius> mm_freak: s/category theory/algebra s/monad/field, the sentence still doesn't sound right.
19:42:04 * jeffwheeler is jealous. I only have an iPhone. :(
19:42:20 <mm_freak> ok, changed to 'a monad'
19:42:21 <pumpkin_> the iphone is awesome!
19:42:24 <shapr> I only have a Motorola Q9h, and it hates me :-/
19:42:31 <pumpkin_> especially when jailbroken :D
19:42:33 <Axman6> jeffwheeler: only? bah
19:42:35 <Nafai> jeffwheeler: Most of my iPhone owning friends laugh at me buying a G1
19:42:51 <jeffwheeler> Nafai: I waited in line for both iPhones, but I like all things new. :P
19:42:53 <shapr> Nafai: None of them are programmers, right?
19:43:14 <Nafai> shapr: They are, actually.  Just Apple fanbois
19:43:17 <jeffwheeler> Nafai: and I'd quite like to mess with the linux system, except any Java requirements there might be.
19:43:22 <shapr> Oh, weird.
19:43:31 <dons> http://www.facebook.com/album.php?aid=62755&l=f42b8&id=660195979
19:43:33 <dons> more photos
19:43:35 <mm_freak> however, i gotta go now…  if you've got more feedback, just highlight me =)
19:43:36 <pumpkin_> jeffwheeler: have you jailbroken your iphone then? :P
19:43:40 <pumpkin_> thanks mm_freak
19:43:47 <mm_freak> for what?
19:43:49 <jeffwheeler> pumpkin_: I did my original iPhone after a while; I haven't jailbroken my current one
19:43:51 <Nafai> jeffwheeler: Yes.  I've heard rumors that they are releasing a native-code SDK.
19:43:54 <shapr> The iPhone interface is really cool, too bad I'm not allowed to do much with it.
19:44:01 <pumpkin_> mm_freak: for the tutorial, it's interesting :P
19:44:03 <Nafai> jeffwheeler: Wonder if I could use GHC on there
19:44:11 <mm_freak> pumpkin_: thanks for the feedback =)
19:44:16 <jeffwheeler> Nafai: that'd be ideal. :)
19:44:31 <shapr> dons: Hah, comparing thickness to Mongoose IPA?
19:44:48 <dons> hehe
19:44:56 <Axman6> mm_freak: i'm liking it so far
19:45:00 <dons> well, some common object.
19:45:15 <shapr> So that's about three swigs worth of Haskell, eh?
19:45:26 <pumpkin_> jeffwheeler: you could probably get ghc onto the iphone with a little work and some dedication, if you jailbroke it :P
19:45:33 <pumpkin_> I've been meaning to look at it
19:45:44 <shapr> @users
19:45:45 <BMeph> dons: It looks skinny compared to Java 6 Reference... ;)
19:45:45 <lambdabot> Maximum users seen in #haskell: 558, currently: 495 (88.7%), active: 21 (4.2%)
19:45:55 <Nafai> Wonder what it would take to get ghc on Android
19:45:57 <dons> 50 pounds of hops in each batch
19:46:02 <jeffwheeler> pumpkin_: yeah, there are several other compilers available; I think there has been some discussion about it in haskell-cafe or etc.
19:46:05 <shapr> dons: I suspect RWH has an amplifying effect on attendance.
19:46:11 * dons hopes so
19:46:32 <shapr> Well, I'm using it to convert the infidels, er I mean .net programmers, so it's working for me :-)
19:46:44 <sbahra> I got the server shapr
19:46:47 <jeffwheeler> pumpkin_: if I remember correctly, nobody has done it yet, but it is probably possible
19:46:48 <shapr> sbahra: Yay!
19:46:50 <sbahra> I just need to find a way to weigh it.
19:46:55 <ivanm> shapr: you launching the holy Haskell crusade, are you?
19:47:00 <dons> yes. i've been encouraging o'reilly to use  the 'give a copy to a java programmer, and make the world a better place" slogna
19:47:04 <ivanm> sbahra: scales?
19:47:05 <shapr> ivanm: I started that several years back.
19:47:09 <shapr> ivanm: But it's a stealth crusade.
19:47:13 <ivanm> heh
19:47:19 <ivanm> when's the public one going to be started?
19:47:20 <pumpkin_> jeffwheeler: yeah, it isn't that hard to port stuff to iphone when you have full ssh access to it and can just run a configure script on it
19:47:21 <sbahra> shapr, Itanium is such a sexy architecture :)
19:47:25 * Nafai can't wait to get his hands on RWH
19:47:33 <sbahra> ivanm, great idea!
19:47:39 <pumpkin_> having said that, I've never tried compiling ghc from source so I don't know
19:47:44 <shapr> ivanm: All I have to do is do cool stuff in Haskell, and then show other people how cool that stuff is... tada, another converted Haskeller.
19:47:46 <jeffwheeler> pumpkin_: I'm not sure . . .
19:48:05 <jeffwheeler> pumpkin_: there's some funky stuff about GHC regarding bootstrapping, no?
19:48:07 <ddarius> sbahra: There are/were a lot of things to appreciate.
19:48:18 <sbahra> shapr, http://cgi.ebay.com/HP-ZX6000-Itanium-2-Dual-1-5GHz-8GB-2x-73GB-Rail_W0QQitemZ380067015962QQcmdZViewItemQQptZCOMP_EN_Workstations?hash=item380067015962&_trksid=p3286.c0.m14&_trkparms=72%3A1205|66%3A2|65%3A12|39%3A1|240%3A1318
19:48:19 <lambdabot> http://cgi.ebay.com/HP-ZX6000-Itanium-2-Dual-1-5GHz-8GB-2x-73GB-Rail_W0QQitemZ380067015962QQcmdZViewItemQQptZCOMP_EN_Workstations?hash=item380067015962&_trksid=p3286.c0.m14&_trkparms=72%3A1205|66%
19:48:19 <lambdabot> 3A2|65%3A12|39%3A1|240%3A1318
19:48:25 <shapr> ivanm: Also, I'm not necessarily a "Haskeller" specifically, I want the best tools that exist, and so far Haskell is the best tool. I don't think it's flawless by any means.
19:48:25 <ddarius> sbahra: However, I wouldn't want to write a compiler for it or write assembly for by hand...
19:48:31 <jeffwheeler> pumpkin_: GHC is written in Haskell, afaik, so it needs a previously-compiled version to compile itself; not quite sure how it all works
19:48:38 <Axman6> i need some nice haskell conversion code i can keep up my sleeve to show peope how awesome haskell really is...
19:48:51 <sbahra> ddarius, I want to atleast be able to write assembly by hand. Need to put some more time into that.
19:49:02 <ivanm> shapr: if it was flawless, then why are people working on haskell'? ;-)
19:49:10 <shapr> sbahra: I think that's an EMISCHAN :-)
19:49:22 <Axman6> jeffwheeler: you can download bootstrapping scaled compilers i think, which compile enough of GHC for it to compile itself. i could be wrong though...
19:49:25 <pumpkin_> jeffwheeler: well, ghc can generate c code for haskell can't it? so it seems like you could get the c code output for ghc from an existing ghc installation, then compile the actual c on the iphone with arm?
19:49:46 <pumpkin_> of course, the intel code generation wouldn't be meaningful there, and you'd need mach-o output
19:49:59 <Axman6> pumpkin_: problem would then be getting it onto the phone
19:50:06 <jeffwheeler> pumpkin_, Axman6: you would think so, but if I remember correctly, the people on the mailing list didn't get it working immediately
19:50:15 <pumpkin_> Axman6: how so?
19:50:28 <jeffwheeler> Axman6: he's talking about using SSH with a jailbroken iPhone
19:50:35 <Axman6> ah, fair enough
19:50:54 <Nafai> So GHC does not work as a cross-compiler right now, right?
19:51:01 <orbitz> can one do multiline string literals in haskell?
19:51:03 <lispy> Nafai: correct
19:51:16 <BMeph> Heh-heh, "Nobody expects the Haskell Inquisition!" ;p
19:51:22 <lispy> ?faq can one do multiline string literals in haskell?
19:51:22 <lambdabot> The answer is: Yes! Haskell can do that.
19:51:32 <dons> pumpkin_: that's how you do a port, yes.
19:51:32 <orbitz> haha
19:51:35 <lispy> orbitz: iirc you need a / at the start and end of the continued lines
19:51:43 <Nafai> Hrm
19:51:47 <pumpkin_> I might give it a go now, see if I find any obvious roadblocks
19:51:52 <Axman6> so, anyone have some nice code that they use to show off haskell?
19:51:53 <mmorrow> ) go = function(cont){while(cont=cont()){}}; f = function(x,y,z){var k=function(){if(x>z)return(undefined);x+=y;return(k)};go(k);return(x)}; f(0,7,1000000)
19:51:53 <lunabotjs>  1000006
19:51:55 <gwern> orbitz: yes, but it's more reliable if you don't since you avoid potential issues with cpp and stuff
19:52:06 <jeffwheeler> Axman6: quicksort ;)
19:52:12 <Axman6> ah, good call
19:52:12 <Nafai> I guess I need an emulator if I want to compile haskell programs to run on the g1
19:52:23 <Lemmih> thoughtpolice: Did my response get through?
19:52:35 <orbitz> oh
19:52:39 <ivanm> BMeph: what are our secret weapons? ;-)
19:52:59 <gwern> ivanm: a strong type system, and laziness... and dons
19:52:59 <orbitz> my specific case was i have string that i want to manipualt ein ghci that is multiple lines making let l = "....." be  a pain
19:53:19 <ivanm> gwern: and syntax
19:53:22 <gwern> I mean, dons, a strong type system, laziness, and GHC
19:53:38 <ivanm> and SPJ ;-)
19:54:11 <gwern> dons, spj, a strong type system, laziness, ghc. and our unicycles
19:54:20 <gwern> (er. perhaps we shoudl restart this joke)
19:55:09 <orbitz> wild how far a decent type system will get you
19:55:29 <ivanm> gwern: why unicycles?
19:55:44 <orbitz> do you consider a language like perl untyped or simply dynamically typed?
19:55:48 <ivanm> @go haskell unicycles
19:55:50 <BMeph> pumpkin_: data Mu t = In { out :: t (Mu t) }
19:55:50 <lambdabot> No Result Found.
19:55:52 <orbitz> or something else
19:56:04 <ivanm> orbitz: if you have numbers, strings, etc. then it can't be untyped ;-)
19:56:11 <gwern> (they see me riding... on my unicycle, and they think, he's so pure and nerdy, just too pure and nerdy)
19:56:28 <ddarius> One would first have to define "untyped" and/or "dynamically typed".
19:56:30 <ivanm> gwern: "white and nerdy" (i.e. weird al)?
19:56:43 <orbitz> ivanm: i guess it depend son your defintion of typing?  i know a few many peopel who consider smoething liek per/php untyped
19:56:54 <ivanm> orbitz: http://www.pphsg.org/cdsmith/types.html
19:56:55 <gwern> ivanm: they all want to catch me programming dirty
19:57:01 <ivanm> heh
19:57:05 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
19:57:32 <ivanm> orbitz: from what I understand, the only untyped languages are those like the pure lambda calculus
19:57:42 <ivanm> where everything is a function, etc.
19:57:48 <orbitz> ivanm: yeah i've seen that.  i'm not necessiarly saying one answer is righ tor worng, ust curious what jargon people use when talkign about these lagnuages
19:58:04 <ivanm> *shrug* I'd call it dynamically typed
19:58:25 <ivanm> (from my limited understanding of perl, which mainly comes from trying to debug my brother's garbage code)
19:58:29 <sbahra> "weakly typed"?
19:58:44 <ivanm> sbahra: see that link ;-)
19:58:56 <ivanm> no such thing as weakly typed, except "I don't like that typing system" :p
19:58:59 <sbahra> ivanm, oh, cool
19:59:04 <jml> orbitz: the terms I've heard are "dynamically typed" (e.g. Python) and "weakly typed" (e.g. PHP)
19:59:16 <lament> if you can have a type error (no matter whether run- or compile-time), the language is not "untyped"
19:59:31 <orbitz> can perl have a type error?
19:59:32 <jml> orbitz: where weakly typed languages tend to do lots of implicit casting.
19:59:33 <sbahra> ivanm, yeah, I saw some ambiguity when I read up "weak typing".
20:00:03 <lament> orbitz: my definition is nonsense, ignore it
20:00:44 <ddarius> "untyped" and "dynamically typed" are usually synonymous.  If you want to differentiate them, you'll have to define one (usually "untyped")
20:01:42 <orbitz> <horrid-joke>I'd say haskell is untyped, my functions tend to be quite short and expressive, less typing all around</horrid-joke>
20:01:52 <lament> i suppose the distinction between dynamically typed and untyped is pure talk
20:02:13 <lament> i feel like python is dynamically typed and forth is untyped, but damned if i know why
20:02:50 <Axman6> quick monad question, do all monads represent a failure state? or is that just some monads like Maybe and []?
20:03:03 <lament> :t fail
20:03:03 <ddarius> Axman6: No, former.
20:03:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
20:03:15 <ddarius> lament: You can make a reasonable definition and the one you gave earlier is reasonable.
20:03:20 <Axman6> ok, cheers.
20:03:55 <ivanm> Axman6: I'd say they _can_ represent a failure state
20:04:04 <lament> ddarius: it's not a definition, it just delegates the real work to defining a "type error"
20:04:15 <Axman6> that's where MonadFail comes into it? or no?
20:04:17 <lament> ddarius: e.g. is 1/0 a type error?
20:04:24 <Axman6> or maybe MonadPlus...
20:05:06 <ddarius> lament: I'm sure you can define "type error" in a reasonable (but informal) way.
20:05:15 <lament> yeah
20:05:28 <lexlex> n00b here
20:05:45 <lexlex> my program runs fine until I try to run it on a big file
20:05:50 <lexlex> then I get: Stack space overflow: current size 8388608 bytes.
20:06:09 <lexlex> all the recursion seems to be tail-recursive
20:06:33 <dons> how are you compiling your program?
20:06:42 <dons> ghc --make -O2 Foo.hs ?
20:06:43 <lexlex> ghc program.hs
20:06:54 <dons> turn on strictness analysis. use -O2
20:07:08 <dons> it turns lazy tail recursive calls into gotos.
20:07:11 <lexlex> ok. trying that
20:07:11 <dons> where posisble
20:07:22 <lexlex> same problem
20:07:25 <dons> otherwise, you'll need to use bang patterns on the stack slots
20:07:27 <ivanm> dons: but I thought GOTOs were considered harmful! :o
20:07:33 <dons> e.g. foo !x = foo (x+1)
20:07:33 <sjanssen> lexlex: tail recursion is a double edged sword in Haskell, the accumulating parameters can be lazy, causing a stack overflow when the result is finally evaluated
20:07:41 <sjanssen> @wiki Stack overflow
20:07:42 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
20:07:49 <ddarius> dons: Tail recursive calls should always be gotos in Haskell.
20:07:56 <dons> ddarius: you know what he means.
20:07:59 <lexlex> can i force evaluation?
20:08:04 <lament> ddarius: maybe the distinguishing feature of dynamically typed languages is the existence of the function that tells what type a value is (python has one, forth can't), subject to some properties, which are probably informal
20:08:06 <lexlex> that's what ! does ?
20:08:09 <sjanssen> lexlex: yes, with seq or bang patterns
20:08:10 <dons> lexlex: yes. with bang patterns, as above. or `seq` or $!
20:08:17 <ddarius> dons: By "he" you mean "I"?
20:08:18 <dons> is the code short?
20:08:30 <dons> ddarius: oh yes. by "he" i meant "me"
20:08:46 <dons> well, i didn't say the code was tail recursive. :)
20:09:06 <dons> ?hpaste
20:09:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:09:22 <dons> lexlex: ^ if you can't see where the lazy accumulator is, try pasting it
20:09:49 <BMeph> So, from all this, we get that PHP is dynamically hyped. :)
20:10:04 <dons> tail recursion is probably the easiest issue to fix, btw. it's blindingly obvious when something's not strict
20:11:20 <hackage> Uploaded to hackage: regexpr 0.4
20:11:52 <dons> lexlex: sorted it out?
20:12:03 <lexlex> still poking about
20:12:31 <dons> if you think its tail recursive, there should be some arguments you're recursing on. those need to not be lazily building up thunks on the stack.
20:12:41 <dons> btw, when you did ghc -O2 Foo.hs, did it actually recompile?
20:12:50 <dons> since if the src didn't change, it might not actually recompile...
20:13:02 <dons> confirm with: ghc -O2 -fforce-recomp Foo.hs
20:16:02 <lexlex> checking
20:17:27 <lexlex> it recompiled
20:17:49 <dons> ?paste <-- if you get stuck
20:17:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:17:51 <lexlex> turned every foldl into a foldl'
20:18:05 <dons> good. foldl is rarely correct
20:18:14 <dons> did you try profiling to get a stack trace?
20:18:22 <lexlex> great idea
20:18:24 <dons> ghc -O2 -prof -auto-all A.hs ; ./A +RTS -p -RTS
20:18:30 <dons> then look at A.prof to see what's allocating
20:19:37 <dons> there's a chapter in RWH about this , and how to think about laziness and tail recursion.
20:19:46 <Axman6> mm_freak: with your examples, you might want to give the types if 'f' when defining things like (>>=)
20:19:49 <lexlex> cat input | head -1000000 | ./a.out +RTS -p -RTS
20:19:50 <dons> and how to program in an explicitly strict idiom
20:20:00 <lexlex> Stack space overflow: current size 8388608 bytes.
20:20:00 <lexlex> Use `+RTS -Ksize' to increase it.
20:20:28 <System_X> can someone help me decipher an error message? "configure: error: cannot find ar in your PATH, no idea how to make a library" I got it while trying to install GHC on my mac.
20:20:51 <Axman6> System_X: what happens when you run `which ar` in terminal?
20:21:03 <Axman6> sounds like you don't have Xcode installed
20:21:19 <sm> do we have a date type you can you easy arithmetic on ?
20:21:29 <sm> d + 1 = tomorrow's date ?
20:21:37 <System_X> Axman6, no ar in /bin /sbin /usr/bin /usr/sbin
20:21:46 <Axman6> System_X: do you have Xcode instaled?
20:21:48 <Axman6> ll*
20:21:51 <lexlex> bad RTS option: -Ksize
20:22:04 <lexlex> ah got it
20:22:10 <Axman6> lexlex: you need to specify a size
20:22:13 <lexlex> needed the single quotes
20:22:15 <Axman6> -K100000000 or something
20:22:19 <Axman6> probably not that big...
20:22:27 <Axman6> maybeh
20:22:38 <lexlex> ok trying
20:22:55 <lexlex> VM at 2GB
20:23:09 <lexlex> 2.4GB
20:23:29 <dons> yeah, a stack overflow. kill it. and look at the stack trace :)
20:23:32 <sjanssen> lexlex: increasing the stack size is only a workaround, not a fix
20:23:38 <lexlex> i agree
20:23:44 <System_X> Axman6, does that come with OS 10.4?
20:23:48 <dons> but big ones like that are dead simple to fix
20:23:55 <dons> since they're just glaring
20:23:56 <lexlex> seems to be stable at 2.4GB
20:23:57 <Axman6> it will be on your OS X install disks
20:24:06 <lexlex> i guess that's the file size ha ha
20:24:08 <dons> you change one char, and it runs in constant space
20:24:13 <dons> lexlex: oh?
20:24:27 <dons> do you expect it to run in constant space? or something like it?
20:24:27 <Axman6> System_X: you might find it better to do to connect.apple.com and get the latest Xcode. not sure if you need leopard for it though
20:24:36 <lexlex> it should
20:24:50 <dons> ok. well, if you feel like pasting the code. let us know.
20:24:56 <lexlex> thanks
20:24:57 <adu> ya, every macosx user should have an apple dev account
20:25:03 <Axman6> indeed
20:25:20 <pumpkin_> someone needs to make hocoa
20:25:33 <pumpkin_> or something h-ish relating to cocoa
20:25:54 <Axman6> pumpkin_: there is one
20:26:00 <Axman6> it died a while ago though i believe
20:26:19 <pumpkin_> it seems that the wordy selectors would be rather ugly in anything but objc (and even there...)
20:26:37 <pumpkin_> objectAtIndex vs !! for example
20:26:43 <pumpkin_> :(
20:27:01 <lament> ugly selectors are ugly
20:27:21 <sutats> http://hpaste.org/12341 - Suggestions for condensing and simplifying it?
20:27:22 <lament> i don't think the fact that it's objc makes them any less ugly
20:27:25 <Axman6> what,  [window makeNewPanelWithHeight: y width: x color: c title:t]; isn't pretty?
20:27:28 <pumpkin_> http://mine.icanhascheezburger.com/view.aspx?ciid=2605097&vk=6sroRAqXS1q3GWKronEM2IMBOiHliOaSPGble9W7Dox7LFNlxXe8n2XPZh4Ez4FKuiz8GDvRN%2bofXfnbEmkyFg%3d%3d
20:27:43 <lament> Axman6: sure, but objectAtIndex ain't
20:27:54 <Axman6> yeah
20:27:57 <pumpkin_> objectForKey: annoys me
20:28:05 <pumpkin_> basic data structures need easy access
20:28:10 <Axman6> i need to start learning Cocoa again
20:28:23 <lament> basic data structures in objc are C structs and arrays :)
20:28:23 <Axman6> i think my main problem is i have nothing i want to make with it
20:28:25 <pumpkin_> dictionaryWithKeysAndValues: and stuff
20:29:02 <pumpkin_> lament: sure, but they discourage use of them, and people try to construe objc as a separate language from c, and not just as an overlay on top of it
20:29:09 <pumpkin_> it would be nice if it acted like more than a library :P
20:29:16 <pumpkin_> with a couple of extra @ tokens
20:29:16 <lament> it does act like a library
20:29:24 <pumpkin_> I know :P
20:29:29 <lament> oh, more than
20:29:31 <pumpkin_> I'm saying it would be nice if it did more than that
20:29:43 <lament> backwards compatibility with C is a terrible burden
20:29:46 <pumpkin_> some basic static dictionary constructor syntax, etc.
20:30:06 <lament> they might eventually add that sort of stuff
20:30:06 <Axman6> lament: but you can forget about pure C most of the time right?
20:30:32 <lament> Axman6: sure
20:30:38 <pumpkin_> the foundation "standard library" in cocoa feels so patchy
20:30:41 <lament> but it still affects objc design decisions
20:30:58 <pumpkin_> the whole picture just isn't elegant :P
20:31:11 <lament> it can't possibly be elegant because there's C in it
20:31:20 <pumpkin_> pure c has an elegance of its own
20:31:21 <lament> i think objc manages pretty well given the problem
20:31:31 <pumpkin_> objc just feels like frankenC
20:31:32 <lament> but the problem is intrinsically hairy
20:31:38 <Axman6> > div 14209 365
20:31:40 <lambdabot>   38
20:31:48 <lament> pumpkin_: if it does, it's because it is
20:31:57 <Axman6> yep, my macbook pro is 38 years old
20:31:59 <pumpkin_> yup :)
20:32:32 <lament> if you want smalltalk, it's still around :)
20:32:54 <pumpkin_> I just want a nicer option for programming cocoa :) MacRuby looks interesting, but isn't ready yet
20:32:54 <lament> for that matter i'm sure Ruby has nice cocoa bindings
20:33:11 <pumpkin_> rubycocoa's kinda lame, but macruby is making up for its shortcomings
20:33:12 <lament> python bindings are officially supported by apple
20:33:18 <pumpkin_> as are ruby ones
20:33:22 <lament> oh
20:33:35 <pumpkin_> macruby is actually being developed by apple
20:33:40 <lament> but that just means adding another language to the tower
20:33:49 <Axman6> apple are even working on macruby, which is a version of ruby 1.9 which is based on cocoa.. or something
20:33:52 <jeffwheeler> PyObjC is pretty exciting, in my opinion.
20:34:07 <lament> adding another story to an ugly tower doesn't turn it into a pretty palace
20:34:12 <jeffwheeler> I think they just provided interfaces via XML to Cocoa.
20:34:20 <lament> it turns it into a taller ugly tower
20:34:30 <jeffwheeler> But with a beautiful top floor. :)
20:34:35 <pumpkin_> Axman6: yeah, the nice thing is that native ruby basic types are implemented as their objc counterparts in the interpreter, so the ugly ruby-cocoa conversion step is gone
20:34:46 <Axman6> yeah
20:34:57 <pumpkin_> I should say vm, since it's 1.9
20:35:08 <lament> jeffwheeler: unfortunately the plumbing and such has to go through all the floors to reach the top :)
20:35:18 <jeffwheeler> lamindeed
20:35:21 <jeffwheeler> err
20:35:24 <jeffwheeler> lament: indeed
20:35:25 <gwern> @undo readDB = do file <- liftM readFile dbLocation; (liftM read file) :: IO ArticleDB
20:35:25 <lambdabot> readDB = liftM readFile dbLocation >>= \ file -> (liftM read file) :: IO ArticleDB
20:36:59 <pumpkin_> so what's the "coolest" thing people have seen done in haskell? something that you see and makes you say "wow, I love haskell"
20:37:17 <lucca> ghc.
20:37:22 <pumpkin_> :P
20:37:24 <jeffwheeler> yi
20:37:34 <lament> factorial
20:37:39 <gwern> :t writeFile
20:37:40 <lambdabot> FilePath -> String -> IO ()
20:37:40 <lucca> darcs is rather nice also.
20:37:41 <jeffwheeler> (consistently short names)
20:37:52 <pumpkin_> I mean on a smaller scale than entire projects
20:38:03 <Axman6> the simplicity of quicksort is pretty nice
20:38:14 <sjanssen> the mergesort in Data.List is awesome
20:38:14 <pumpkin_> yeah, that did look nice, especially the (inefficient) list comprehension method
20:38:24 <sjanssen> maybe the best application of laziness I've ever seen
20:38:36 <dons> sjanssen: i think we can thank Igloo for that
20:38:39 <shukhov> where do I find mkT and mkQ?
20:38:41 <sjanssen> dons: yep
20:38:43 <sjanssen> Igloo++
20:38:45 <dons> pumpkin_: xmonad :)
20:38:53 <gwern> shukhov: doing TH?
20:38:54 <Axman6> @src sort
20:38:54 <lambdabot> sort = sortBy compare
20:38:58 <pumpkin_> lol
20:38:58 <Axman6> @src sortBy
20:38:59 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:39:03 <gwern> @hoogle mkQ
20:39:03 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
20:39:04 <dons> i see a lot of cool stuff at work using types for safety.
20:39:07 <Axman6> @src insertBy
20:39:07 <lambdabot> insertBy _   x [] = [x]
20:39:07 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
20:39:07 <lambdabot>                                  GT -> y : insertBy cmp x ys'
20:39:07 <lambdabot>                                  _  -> x : ys
20:39:11 <gwern> ah, generics. fun
20:39:12 <dons> but its a bit hard to share , sadly
20:39:12 <sjanssen> Axman6: that isn't the real source, by the way
20:39:18 <pumpkin_> dons: noes!
20:39:23 <shukhov> gwern: do they come with base?
20:39:25 <Axman6> sjanssen: got a link to the real one?
20:39:32 <sjanssen> @source Data.List
20:39:32 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
20:39:39 <Axman6> cheers
20:39:43 <gwern> shukhov: dunno. probably
20:40:44 <shukhov> ah they do
20:40:48 <shukhov> thank you
20:42:01 <Axman6> sjanssen: going to take me a while to figure that one out
20:42:05 <gwern> @pl writeDB adb = join $ liftM (flip writeFile $ show adb) dbLocation
20:42:06 <lambdabot> writeDB = join . flip fmap dbLocation . flip writeFile . show
20:42:42 <sjanssen> Axman6: it helps to draw the structure of the thunks on a piece of paper
20:43:42 <mmorrow> ) a = (function(x){return("eval("+x+")("+x+")")})(function(x){return("eval("+x+")("+x+")")}); a == eval(a)
20:43:42 <lunabotjs>  true
20:43:45 <mmorrow> js quine
20:44:01 <mmorrow> using the method the lisp/scheme quine uses:
20:44:06 <mmorrow> ((lambda (x) (list x (list 'quote x))) '(lambda (x) (list x (list 'quote x))))
20:46:03 <gwern> incidentally, is there any much better way to move the head of a list to the end then this? 'setFirstLastArticle (b:bs) = bs ++ [b]'
20:46:21 <Axman6> sjanssen: any reason it uses wrap instead of return?
20:47:04 <sjanssen> Axman6: clarity
20:47:12 <Axman6> fair enough
20:47:38 <sjanssen> gwern: no
20:47:46 <sjanssen> also, you should try to avoid doing that frequently
20:47:59 <byorgey> gwern: I prefer   id . id . reverse . (b:) . reverse $ bs
20:48:33 <Axman6> i thought i'd heard that reverse $ (b : reverse bs) was supposed to be faster
20:48:42 <gwern> byorgey: I can never tell when you're kidding or serious
20:48:47 <byorgey> gwern: hehe
20:48:51 <mmorrow> hah
20:48:52 <byorgey> Axman6: it's actually slower.
20:48:53 <sjanssen> Axman6: it isn't
20:48:54 <gwern> sjanssen: hm? bad performance you mean?
20:49:07 <sjanssen> gwern: it is O(n), and does O(n) allocations
20:49:12 <lexlex> let x = foo y: how do I force the evaluation of y before the call to foo?
20:49:17 <dons> gwern: use a dlist?
20:49:23 <gwern> nah, performance isn't an issue. I don't expect this code to ever have to do with more than a few hundred entries
20:49:25 <sjanssen> lexlex: let x = foo $! y
20:49:25 <dons> if that's a bottleneck
20:49:34 <byorgey> Axman6: although if you want to add a bunch of individual elements to the end of a list, it's faster to cons them all on the front and then reverse, than doing a bunch of  ++ [x] 's
20:49:49 <Axman6> yeah
20:50:21 <Axman6> gwern: so you're not trying to cycle through a list of things?
20:50:49 <ddarius> > tails $ cycle "foo"
20:50:50 <lambdabot>   ["foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoof...
20:50:57 <mmorrow> , unDyn
20:50:58 <lunabot>  luna: Not in scope: `unDyn'
20:51:12 <jeffwheeler> > cycle "foo"
20:51:13 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
20:51:14 <gwern> Axman6: well, each article will take the reader several minutes/hours/days to read, so I am really not concerned with perofmrnace. my interest was stylistic
20:51:22 <jeffwheeler> Why doesn't it chop off the first f?
20:51:34 <Axman6> righto
20:51:42 <mmorrow> , let unDyn = maybe undefined id . fromDynamic; f <<$>> x = maybe undefined id (f `dynApply` x); q = (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x)) in foldr (.) id (replicate 100000 unDyn) $ q
20:51:46 <lunabot>  <<Dynamic>>
20:51:51 <Axman6> > tails "Hello"
20:51:53 <lambdabot>   ["Hello","ello","llo","lo","o",""]
20:51:56 <sjanssen> > tails "abc"
20:51:57 <jeffwheeler> Err, yeah.
20:51:57 <lambdabot>   ["abc","bc","c",""]
20:51:58 <mmorrow> that's such a great quine method
20:52:07 <jeffwheeler> Thanks. :)
20:52:09 <sjanssen> jeffwheeler: it returns the original input first
20:52:24 <ddarius> > transpose $ tails $ cycle "foo"
20:52:25 <lambdabot>   ["foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoof...
20:52:28 <jeffwheeler> sjanssen: yep, looks like it; I haven't used it before, so thought it acted differently.
20:52:47 <ddarius> hmm
20:52:50 <ddarius> > fix transpose
20:52:52 <lambdabot>   * Exception: stack overflow
20:52:59 <Axman6> that was quick
20:53:00 <lexlex> $! doesn't work on curried functions?
20:53:10 <lexlex> foo $! x y
20:53:14 <Axman6> no
20:53:18 <Axman6> @src ($!)
20:53:19 <lambdabot> f $! x = x `seq` f x
20:53:27 <Axman6> :t ($!)
20:53:28 <lambdabot> forall a b. (a -> b) -> a -> b
20:53:54 <byorgey> lexlex: since the precedence of $! is less than application, that parses as  foo $! (x y)
20:54:01 <Axman6> > (+) $! 1 $! 3
20:54:02 <lambdabot>       Overlapping instances for Show (b -> b)
20:54:02 <lambdabot>        arising from a use of `s...
20:54:05 <byorgey> so you'll have to do  (foo $! x) y
20:54:06 <sjanssen> lexlex: you can write "x `seq` foo x y", which will evaluate x before calling foo with x and y
20:54:09 <Axman6> ok, thought so
20:54:38 <dons> lexlex: i'd use bang patterns on foo
20:54:43 <lexlex> so I can do (foo $! x) $! y
20:54:44 <dons> foo !x !y  = ...
20:54:54 <byorgey> lexlex: yup, that works
20:55:01 <dons> to enable, compile with -XBangPatterns or add {-# LANGUAGE BangPatterns #-}
20:55:25 * dons is still curious to see lexlex's code
20:55:44 <dons> byorgey: do you know if bjp is going to use rwh for his parallelism/concurrency course next year?
20:55:57 <Lemmih> thoughtpolice: The lhc repo isn't buildable. You need to add LHCVersion.
20:56:16 <lexlex> it's much tighter now
20:56:30 <conal> dons: i just read your Beautiful Parallelism slides.  Beautiful!!
20:56:47 <byorgey> dons: I don't know.  he did say he was going to use it in his advanced programming course in his blurb/endorsement statement, though, right?
20:56:49 <dons> conal: yay! yes, i'm giving it again in new york next week.
20:56:55 <dons> byorgey: yes, that's the one.
20:57:19 <dons> lexlex: oh? fixed?
20:57:23 <Nafai> Hi byorgey!
20:57:34 <byorgey> dons: well, I haven't actually talked to him about it.  but I'm kinda hoping to TA that course =)
20:57:38 <dons> conal: i'm excited at how much easier `par` is getting.
20:57:40 <byorgey> hi Nafai!
20:57:47 <dons> byorgey: that's what i was guessing :)
20:57:58 <Axman6> dons: how's it getting easier?
20:58:00 <byorgey> I might have to fight dmwit for it though
20:58:10 <dons> Axman6: more predictable, better understood, faster.
20:58:11 <mmorrow> dons: where in ny?
20:58:17 <Axman6> excellent :)
20:58:30 <dons> mmorrow: midtown at a certain bank. hopefully back in jan for nyfp
20:58:59 <mmorrow> dons: ooh, cool. nyc is fun x2 :)
20:59:05 <dons> hope so!
20:59:12 <sutats> http://hpaste.org/12341 - Could someone condense this for me (particularly "inBounds" since "move" probably can't be)?
20:59:13 <dons> since portland is alread fun ^ 2
20:59:14 <pumpkin_> is there some way to extern "C" haskell symbols to make haskell dylibs?
20:59:27 <dons> pumpkin_: yeah. dylibs non trivial. external export easy
20:59:32 <mmorrow> dons: crap, i almost wrote that too..
20:59:51 <pumpkin_> dons: so you mean I can make static haskell objects to link against, but not dynamic ones?
20:59:53 <dons> pumpkin_: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
20:59:54 <lambdabot> Title: Calling Haskell from C - HaskellWiki
21:00:02 <dons> pumpkin_: dynamic ones depend on the arch
21:02:20 <System_X> Hey thanks Axman6! you were right, all I needed was xcode.
21:03:40 <Axman6> speaking of par, could someone tell me why this dies when using par, but works fine without it? http://hpaste.org/12393
21:04:07 <sjanssen> Axman6: dies?
21:04:28 <roconnor> sutats: http://hpaste.org/12341#a1
21:04:32 <Axman6> i get 'thread blocked indefinitely' and the program exits
21:04:36 <byorgey> sutats: one big improvement would be to pattern match on index, x, and y so you don't need 'fst' and 'snd' everywhere
21:04:40 <pumpkin_> dons: mach-o dynamic libs on intel for example? why are some archs harder than others?
21:04:45 <roconnor> sutats: hmm, i can do better
21:04:46 <sjanssen> Axman6: par only evaluates arguments, it doesn't execute IO
21:04:58 <Axman6> hmm
21:05:00 <roconnor> @hoogle range
21:05:01 <sjanssen> @type par
21:05:01 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
21:05:01 <lambdabot> Language.Haskell.TH data Range
21:05:01 <lambdabot> Language.Haskell.TH.Syntax data Range
21:05:02 <lambdabot> forall a b. a -> b -> b
21:05:07 <dons> so you create a race condition somewhere?
21:05:10 <sjanssen> Axman6: see the lack of IO?
21:05:10 <dons> STM would help :)
21:05:18 <byorgey> oh, I see roconnor already did that =)
21:05:22 <sjanssen> Axman6: basically left is never executed
21:05:29 <Axman6> dons: i'm using STM
21:05:29 <sutats> byorgey: Oh, I didn't even think about doing that. And yeah, he did that.
21:05:32 <Axman6> i see
21:05:36 <dons> Axman6: and MVars?
21:05:37 <Axman6> makes sense
21:05:37 <sjanssen> Axman6: forkIO left >> right -- will work
21:05:43 <Axman6> dons: yep
21:05:46 <dons> that's some wild code
21:05:51 <Axman6> heh, yes
21:05:56 <dons> you're using every parallelism abstraction in one place
21:06:02 <dons> only in haskell would this even be possible :)
21:06:13 <Axman6> not supposed to be practical,more a learning exercise
21:06:24 <dons> in C, someone would come and take your keyboard away
21:06:27 <dons> :)
21:06:37 <sjanssen> Axman6: the other uses of par look wrong too
21:06:51 <dons> yeah. too much par?
21:07:00 <Axman6> yeah, probably
21:07:00 <roconnor> sutats: http://hpaste.org/12341#a2
21:07:01 <dons> general rule: don't mix par and forkIO and MVars and STM
21:07:11 <Axman6> this is my play with version, i have another that works ok
21:07:19 <dons> choose one : par or forkIO. if the latter, choose one: MVar or STM
21:07:24 <sutats> roconnor: Where's inRange from?
21:07:32 <roconnor> @index inRange
21:07:47 <conal> sutats: you can also use the functions 'first' and 'second' to shorten up move.  for instance, move N = second succ
21:08:05 <conal> sutats: move W = first pred, etc
21:08:30 <sutats> conal: Ah, so that takes out the (i, j) part, right?
21:08:39 <conal> sutats: totally
21:08:47 <sjanssen> using both par and forkIO is okay, you just need to understand the difference between execution and evaluation
21:08:48 <sutats> roconnor: I had no idea that function already existed. Useful.
21:08:56 <conal> sutats: becomes "point-free", as we say.
21:09:19 <conal> well, nearly point-free.
21:09:22 <sutats> conal: Yeah, I've been trying to convert a lot of my code to point-free
21:09:44 <dons> sjanssen: have you ever see it done before though? it is surely safe, but subtle to get performance from
21:09:44 <conal> sutats: it's fun & addictive.  and sometimes yields powerful insights.
21:10:02 <sjanssen> dons: I don't think I have
21:10:06 <roconnor> @index inRange
21:10:10 <roconnor> @help index
21:10:11 <tessier> sutats: What is point-free?
21:10:18 <sutats> conal: And generally cleaner on top of that.
21:10:19 <roconnor> @botsnack
21:10:19 <sjanssen> dons: we might see it more when we have 64 cores in our machines instead of just 2 :)
21:10:28 <roconnor> > 2 + 2
21:10:48 <tessier> 64 cores isn't far off. I've already got machines with 16
21:10:49 <conal> sutats: yeah.  i'll publish a blog post tomorrow with some nifty examples.
21:10:50 <tessier> Soon 24
21:11:01 <roconnor> I killed her
21:11:13 <byorgey> tessier: 'point-free' means defining a function without reference to its arguments.
21:11:20 <hackage> Uploaded to hackage: TypeCompose 0.6.1
21:11:29 <conal> hey -- that's me!
21:11:39 <Axman6> :o
21:11:42 <tessier> byorgey: Interesting. How can a function do anything with the arguments in that case? And what is the advantage of doing this?
21:11:49 <sutats> tessier: I don't know if I can explain it well, but it's essentially the difference between "f x = <some function> x" and just "f = <some function>"
21:11:49 <byorgey> tessier: for example,  foo = reverse . (:'x')
21:11:51 <conal> i just made more of the TypeCompose point-free
21:12:11 <conal> (s//defs/)
21:12:13 <byorgey> tessier: that says that foo is the composition of the functions  'reverse' and (:'x')
21:12:15 <conal> :)
21:12:19 <sutats> conal: Oh, nice. Link to your blog?
21:12:30 <byorgey> in other words, foo first adds an 'x' to the front of a string, and then reverses it
21:12:32 <conal> sutats: http://conal.net/blog
21:12:32 <dons> sjanssen: interesting. yes. in many core we may see pure stuff by default `par`
21:12:38 <dons> and IO by default forkIO
21:12:45 <byorgey> tessier: you could also write it as   foo s = reverse ('x' : s)
21:12:54 <dons> i'd like to avoid forkIO + explicit shared mem if possible though
21:13:01 <dons> though STM helps a lot
21:13:11 <conal> sutats: it's on planet haskell also.
21:13:29 <mmorrow> tessier:
21:13:32 <byorgey> tessier: the reason it's possible to define functions usefully without mentioning their arguments is because of function composition and higher-order functions (i.e. functions that take other functions as arguments)
21:13:44 <mmorrow> main = print . length . lines =<< getContents
21:13:50 <byorgey> tessier: the advantage is that sometimes it's conceptually clearer.
21:13:59 <sutats> conal: Oh, good to know.
21:14:08 <byorgey> tessier: also, it proves that you have FP machismo ;)
21:14:13 <thetallguy> Hey guys, here's your target machine of the future: http://blog.wired.com/gadgets/2008/11/sgi-creates-con.html
21:14:13 <mmorrow> heh
21:14:25 <Raevel> morning!
21:14:38 <tessier> byorgey: Ah, a dick measuring competition. Now I get it. :)
21:14:50 <byorgey> tessier: oops, sorry, I just realized I should have said ('x':) everywhere I said (:'x')
21:15:02 <byorgey> tessier: at its worst, yes.
21:15:08 <Axman6> thetallguy: its ugly
21:15:11 <tessier> byorgey: To match and assign the first element in the list instead of the tail of the list, right
21:15:26 <thetallguy> Axman6: yeah, but 10K processors
21:15:31 <dons> thetallguy: heh, i was thinking this machine, http://www.cray.com/Products/XMT.aspx
21:15:32 <Axman6> indeed
21:15:36 <byorgey> but at its best it gets at the heart of what is really elegant about functional programming.
21:15:37 <conal> tessier: yeah, where smaller is better.
21:15:45 <byorgey> hehehe
21:15:54 <tessier> conal: Oh goody, a contest I can win!
21:15:59 <mmorrow> @pl \g f x -> g (f x)
21:16:01 <conal> heh
21:16:09 <mmorrow> @pl \g f x y -> g (f x y)
21:16:11 <byorgey> \bot seems to be taking a nap
21:16:11 <conal> poor departed lambdabot.
21:16:14 <mmorrow> @pl \g f x y z -> g (f x y z)
21:16:18 <mmorrow> ah
21:16:21 <mmorrow> @botnap
21:16:24 <dons> there's a bit of an arms race to build the most-cored machine
21:16:29 <dons> from all the old school players
21:16:35 <mmorrow> g . f
21:16:41 <mmorrow> (g .) . f
21:16:41 <dons> sgi, cray? it's like 1990 all over again
21:16:42 <Axman6> tessier: i am not a fan of point free style in many many cases where it is used
21:16:46 <mmorrow> ((g .) .) . f
21:16:46 <sutats> Is there an online equivalent to hoogle?
21:16:48 <mmorrow> ...
21:16:55 <byorgey> sutats: yes, it's called hoogle
21:16:55 <tessier> dons: But hardly anyone interested in writing code to take advantage of it.
21:16:59 <tessier> Axman6: Why is that?
21:17:07 <sutats> byorgey: Probably should have guessed.
21:17:15 <byorgey> sutats: haskell.org/hoogle  =)
21:17:16 <Axman6> tessier: it's often very confusing when you have more than one argument
21:17:25 <thetallguy> Yeah, it's like when Intel stopped upping the clock speed, the floodgates opened
21:17:33 <dons> tessier: there's lots of people interested
21:17:37 <dons> mostly they're using haskell :)
21:17:40 <sutats> byorgey: Haha, might have explained why hoogle.com didn't work.
21:17:43 <tessier> dons: Only the very small fp community afaik.
21:17:51 <byorgey> sutats: ah, indeed.
21:17:51 <Axman6> @pl \f g x y -> f (g x y) x y
21:17:57 <dons> tessier: you'd be surprised. 10k+ people at supercomputing08 last week
21:18:03 <tessier> And the fp  community is interested in it because it is finally something they are good at.
21:18:06 <dons> all talking about how to program manycores.
21:18:09 <Axman6> right, lambdabot's dead.. but that would be extremely ugly
21:18:15 <tessier> dons: But aren't they all wanting to do MPI etc?
21:18:25 <dons> nope. data parallelism was very hot.
21:18:30 <tessier> hmm
21:18:32 <dons> anything, anything that works.
21:18:37 <tessier> So was there a Haskell BOF or anything/
21:18:37 <tessier> ?
21:18:40 <Raevel> poor lambdabot
21:18:42 <dons> yep
21:18:45 <tessier> Cool.
21:18:50 <dons> talks from cray, intel, ibm and haskell land
21:18:52 <dons> :)
21:19:12 <tessier> dons: So is Haskell going to be the new FORTRAN?
21:19:26 <dons> there's a reason we have `par` and STM and [: :] arrays
21:19:35 <byorgey> dons: hmm, I think my architecture professor was there.  I wonder if he went to your talk =)
21:19:37 <dons> and the hardware is coming at us fast.
21:20:34 <tessier> Why is `par` even necessary? If the code is purely functional why can't the compiler know what can be done in parallel automatically?
21:20:43 <dons> because there's too much parallelism by default
21:20:48 <dons> you have to *restrict* the parallelism
21:20:53 <Axman6> tessier: people want that, but it's far more complicated than it sounds
21:20:54 <dons> `par` is one mechanism for that
21:21:03 <tessier> ah
21:21:15 <dons> spinning up a core is costly. so you better not do it too much
21:21:17 <inimino> tessier: the compiler can't know how much data you have
21:21:19 <conal> dons: which we don't yet know how to do automatically, right?
21:21:22 <dons> unless we have 1M cores.
21:21:25 <tessier> Ah. That was my guess.
21:21:27 <dons> conal: automatic inference of `par` ?
21:21:28 <Axman6> making all map f xs into a parMap rnf f xs might not be a great idea
21:21:32 <conal> dons: yes
21:21:43 <tessier> You are going to operate on a list of 2 things and it sends one of the evaluations to another core.
21:21:43 <dons> only via a) old school paralllel haskell, or b) runtime profiling of thunk costs
21:21:47 <dons> (see Satnam's papers)
21:21:55 <tessier> Runtime profiling...there ya go.
21:22:00 <conal> work in progress.
21:22:18 <Axman6> dons: GHC HotSpot™ runtime?
21:22:50 <ksf> > or undefined True
21:22:56 <ksf> > or True undefined
21:23:04 <byorgey> ksf: lambdabot is down
21:23:08 <dons> if we can make hardware threads cheaper to spin up, then mapping natural parallelism onto hardware directly becomes more attractive
21:23:10 <ksf> waaagh
21:23:16 <ksf> , or True undefined
21:23:17 <lunabot>  luna: Couldn't match expected type `[GHC.Bool.Bool]'
21:23:18 <byorgey> but those would give results of 'undefined' and 'True' respectively
21:23:22 <dons> until then we need some 'scheduler' that reduces the amount of parallel eval going on
21:23:24 <conal> ksf: are you reading my unamb post?
21:23:26 <ksf> ...
21:23:33 <dons> Thu Aug 14 05:40:27 PDT 2008  dias@eecs.harvard.edu * Merging in the new codegen branch
21:23:35 <ksf> http://www.cs.kent.ac.uk/people/staff/dat/miranda/ctfp.pdf
21:23:36 <dons> WOOT!!
21:23:38 <dons> happy day in haskell land
21:23:39 <ksf> just stumbled upon it.
21:23:47 <dons> we just got a new code gen in GHC
21:23:53 <dons> and a 700 page o'reilly book
21:23:54 <Axman6> dons: what's that mean?
21:24:00 <conal> yay haskell!
21:24:10 <dons> the new 'cutting edge' code gen just got committed.
21:24:12 <dons> about 30 seconds ago
21:24:15 <conal> wow
21:24:40 <Axman6> which means everything gets faster and also sexier?
21:24:49 <Raevel> dons: which book is that?
21:25:02 <bos> Raevel: the one dons and i wrote
21:25:08 <bos> @where rwh
21:25:09 <dons> http://www.realworldhaskell.org/blog/2008/11/25/real-world-haskell-is-shipping/http://www.realworldhaskell.org/blog/2008/11/25/real-world-haskell-is-shipping/ woot woot!
21:25:14 <ksf> duh.
21:25:35 <ksf> or is't Bool->Bool->Bool, it's [Bool]->Bool.
21:25:38 <inimino> nice :-)
21:25:45 <Raevel> haha that's awesome guys!
21:25:53 <dons> bos!
21:26:05 <bos> dons!
21:26:13 <dons> i added some more photos, btw.
21:26:13 <Axman6> Raevel: http://book.realworldhaskell.org/ if you want to read it
21:26:21 <ksf> , or [undefined,True]
21:26:24 <lunabot>  luna: Prelude.undefined
21:26:25 <dons> 'tis a weighty tome.
21:26:33 <ksf> , or [undefined]
21:26:35 <lunabot>  luna: Prelude.undefined
21:26:46 <tessier> Amazon charged my credit card for my pre-ordered RWH today
21:26:47 <ksf> the first one should be True, the other False.
21:26:59 * dons boggles. we really do have a book about STM, par, FFI, QuickCheck, and freaking monads!
21:27:04 <byorgey> dons++
21:27:05 <ksf> bottom should be catchable.
21:27:07 <byorgey> bos++
21:27:09 <dons> time to take over the world, lads.
21:27:11 <byorgey> CosmicRay++
21:27:11 <Axman6> > or [True,undefined]
21:27:13 <tessier> dons: Enjoy a nice beer with my royalty money! :)
21:27:21 <conal> ksf: some forms of bottom are catchable
21:27:24 <dons> :)
21:27:26 <conal> ksf: including 'undefined'
21:27:43 * tessier also has Haskell: The Craft of Functional Programming
21:27:53 <tessier> But I didn't make it very far through it before I got bored. I'll go back to it after RWH
21:27:56 <dons> tessier: that's the book i learnt from.
21:28:06 <dons> i should get sjt to sign it one day
21:28:09 <dons> next ICFP.
21:28:13 <Axman6> i have that one, but never read much of it. found it pretty boring
21:28:39 <Axman6> but, i'm dyslexic, so many books are boring to me
21:28:48 <byorgey> dons: so how's the new code gen better?
21:29:07 <dons> byorgey: it's got 98% less dumbs.
21:29:12 <byorgey> w00t!!
21:29:14 <dons> let me find the details
21:29:15 <Axman6> hooray!
21:29:35 <dons> officially, know as "GHC's glorious new code generator "
21:29:42 * ksf just noticed the amount of periphery abstract nonsense necessary to even consider rewriting or to accept undefined...
21:29:45 <dons> "glorious" is always a good sign.
21:29:57 <dons> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/NewCodeGen
21:30:12 <byorgey> @remember dons <byorgey> so how's the new code gen better? <dons> it's got 98% less dumbs.
21:30:12 <inimino> gloriousness is to be desired
21:30:21 <dons> more appropriately,
21:30:22 <dons> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/IntegratedCodeGen
21:30:29 <byorgey> I know lambdabot is down but my quote-culling script for HWN will find that later =)
21:30:37 <dons> "The big hammers are the dataflow optimization engine and a coalescing register allocator"
21:31:24 <ksf> the evil mangler is dead?
21:31:33 <dons> deprecated
21:31:36 <mcnster> hi.  is there a better way to express this:  foo = foldl f [] $ baz ls where f xs xi = xs ++ xi' where xi' = case bar of True -> [xi] False -> foldl f [xi] $ baz xi  ?
21:31:48 <Axman6> heh, just had the 'the which is dead' song pop into my head
21:31:50 <Raevel> haha oh, my connection is a little unstable so it looked like the book only had 8 chapters ("is that it!?")
21:31:58 <sjanssen> DING DONG, THE MANGLER IS DEAD!
21:32:00 <Axman6> witch even
21:32:15 <dons> most of us never use the mangler now
21:32:15 <sjanssen> Axman6: great minds think alike, apparently
21:32:18 <Raevel> okay i'll definitely buy that book
21:32:19 <dons> only if you ask for -fvia-C
21:32:25 <Axman6> sjanssen: indeed :)
21:32:44 <cpfr> hey if i have a lookup table that returns a lookup table, is there a nice way to thread them >>=?
21:33:16 <sjanssen> lookup key table >>= lookup key2
21:33:38 <sjanssen> assuming we're talking about Data.Map here
21:33:59 <dons> anyone have thoughts of how we get slashdot to take notice of us taking over the world?
21:34:40 <dons> at least one reddit submission, http://www.reddit.com/r/programming/comments/7fqjv/real_world_haskell_the_book_is_now_shipping/
21:34:50 * ksf suddenly sees bulat arguing against the new codegen on the reason that it makes haskell faster in the shootout
21:34:54 <dons> though probably worth while telling people tomorrow over their coffee
21:34:58 <dons> ksf: heh
21:35:01 <sutats> dons: I know that Slashdot has a lot of book reviews that make it to the front page, so if someone writes a review for RWH.
21:35:03 <dons> ksf: he's onto the GC now
21:35:09 <dons> sutats: ah. interesting.
21:35:56 <tessier> A review of RWH...that's a good idea...
21:36:17 <tessier> As a newbie if I get all the way through it and come out actually being able to do some basic things with Haskell I vow to write a review and submit it to /.
21:36:27 <dons> i thin kthe well-typed lads were thinking about doing a review.
21:36:28 <dons> dcoutts_: ?
21:36:51 <cpfr> sjanssen, i got: http://hpaste.org/12394
21:37:03 <Axman6> tessier: you should be able to do much more than basic things by the end of it
21:37:24 <tessier> Axman6: I prefer to under-promise and over-deliver. ;)
21:37:26 <Axman6> tessier: http://book.realworldhaskell.org/ if you want to read it online
21:37:29 <dons> yeah, i hope you can write all the things you normally write by the end of it
21:37:33 <tessier> Axman6: I am already reading it online
21:37:37 <sjanssen> cpfr: this makes no sense to me
21:37:37 <Axman6> :)
21:38:03 <cpfr> sjanssen, I have used Parsec to parsec a bibtex file
21:38:20 <cpfr> so i store all the entries in a lookup table
21:38:21 <Axman6> 'Barcode Recognition'? :o
21:38:28 <sjanssen> cpfr: what sort of table?
21:38:31 <lexlex> thanks for all the help with the strict evaluation
21:38:36 <lexlex> my program is running fine now
21:38:47 <cpfr> [(String, [(String,String)]]
21:38:51 <lexlex> 谢谢。再见
21:39:01 <dons> lexlex: so what was the change in the end?
21:39:19 <lexlex> i had a readline (w, y) function
21:39:34 <lexlex> a change to readline (!w, !y) did the trick
21:39:37 <dons> ah ok
21:39:44 <sjanssen> @type Data.List.lookup
21:39:46 <dons> so were you passing the pair in the tail call?
21:39:52 <lexlex> yes
21:40:02 <dons> ah ha!
21:40:14 <Axman6> "In this chapter, we'll make use of the image parsing library we developed in Chapter 10, Code case study: parsing a binary data format to build a barcode recognition application. Given a picture of the back of a book taken with a camera phone, we could use this to extract its ISBN number." ok, that's awesome
21:40:16 <lexlex> w and y were Data.Maps
21:40:16 <sjanssen> ah, bot is daed
21:40:19 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..100000]
21:40:22 <lunabot>  (5000050000,5000050000)
21:40:26 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..10000000]
21:40:26 <sjanssen> cpfr: Data.List.lookup returns a Maybe
21:40:26 <dons> yes. haskell is 'weak head normal form' strict when you use things like `seq`. so it only evaluats the outermost constructor
21:40:32 <lunabot>  Killed.
21:40:34 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..1000000]
21:40:35 <dons> so not the inner parts of (a,b), just the outer part
21:40:37 <sjanssen> cpfr: you can just Maybe's (>>=) to sequence two lookups
21:40:38 <lunabot>  (500000500000,500000500000)
21:40:39 <cpfr> lookup :: (Eq a) => a -> [(a, b)] -> Maybe b
21:40:53 <byorgey> cpfr: it looks like you have an IO action which returns either a parse error or a [(String, [(String,String)]], but you are using it as if it is a [(String, [(String,String)]]
21:41:04 <Axman6> :t (id $!)
21:41:08 <cpfr> byorgey, basically
21:41:20 <Axman6> , type (id $!)
21:41:21 <lunabot>  luna: parse error on input `type'
21:41:23 <Axman6> bah
21:41:46 <byorgey> cpfr: you will have do do something like   do { x <- foo; case x of Left err -> ...  Right table -> ... }
21:41:50 <mmorrow> , ?f (id $!)
21:41:52 <lunabot>  luna: Unbound implicit parameter (?f::(a1 -> a1) -> a)
21:41:55 <mmorrow> heh
21:42:01 <mmorrow> poor man's :type
21:43:23 <mmorrow> i really should add a `type_' function, the ghc-api makes it possible for sure
21:43:39 <mmorrow> , let type = 4 in type
21:43:41 <lunabot>  luna: parse error on input `type'
21:43:48 <mmorrow> (hence the '_')
21:44:20 <pumpkin_> if you could change one thing about haskell, what would it be?
21:44:30 <pumpkin_> (sorry for these random questions, just curious :P)
21:44:56 <orbitz> argh
21:45:03 <mmorrow> first-class modules
21:45:26 <mmorrow> (i'm sure i could think of something that matters to me more, but that's off the top of my head)
21:45:42 <pumpkin_> how would that work?
21:45:46 <ksf> optional touring-completeness
21:45:54 <pumpkin_> turing?
21:46:01 <ksf> yeah.
21:46:03 <pumpkin_> how do you mean optional?
21:46:06 <ksf> i constantly misspell him.
21:46:14 <ivanm> @bot
21:46:22 <mmorrow> pumpkin_: i'm not really sure how it'd work
21:46:22 <ksf> i.e. introduce unsafeHalt
21:46:23 <ivanm> methinks lambdabot is dead again :s
21:46:37 <Axman6> ksf: how do you pronounce turing?
21:47:00 <ksf> tooring. i'm german, so a u is really a u.
21:47:09 <Axman6> heh, or
21:47:23 <ksf> not tjuring or something.
21:47:27 <ksf> that sounds swedish.
21:47:28 <Axman6> i tend to pronounce it more like chew-ring
21:47:33 <mmorrow> pumpkin_: well, it'd mean something like being able to pass modules around like one passes records of functions/values around, but those records could also contain types/newtypes/data decls
21:47:38 <pumpkin_> me too
21:47:40 <Axman6> but, the ch is more like a t
21:48:05 <pumpkin_> mmorrow: interesting
21:48:05 <Raevel> tjuring -- somewhat amusing
21:48:08 <sutats> Given inBounds :: (Int, Int) -> (Int, Int) -> (Int, Int) -> Bool inBounds index (fst $ bounds maze) (snd $ bounds maze)
21:48:17 <ksf> ew and ju are quite insane in their similarity.
21:48:22 <sutats> Sorry, newline after the Bool.
21:48:43 <sutats> Any way to simplify "inBounds index (fst $ bounds maze) (snd $ bounds maze)"
21:48:48 <cpfr> byorgey, im having trouble juggling all these monads
21:49:12 <mmorrow> pumpkin_: and those "modules" would have import/export lists importing/exporting things selectively for other such "modules" to import and which other such "modules" export
21:49:21 <Axman6> sutats: isn;t that function already defined? in the Ix class?
21:49:33 <mmorrow> so kinda analogous to "public" and "private"
21:49:34 <Axman6> cpfr: what's the problem>
21:49:35 <Axman6> ?*
21:49:57 <sutats> Axman6: For only 1 dimension. I'm doing it for 2.
21:49:59 <ksf> mmorrow, seems to me like you are propagating the smalltalkification of haskell.
21:50:12 <sutats> Axman6: At least from what I can tell.
21:50:12 <cpfr> i am using parsec to parse up a lookup table that returns a lookup table
21:50:17 <mmorrow> ksf: heh, i'll have to read up on smalltalk.
21:50:28 <Axman6> sutats: you should be able to use ((int,int),(int,int)) i think
21:50:29 <mmorrow> for instance, Cayenne has exactly what i'm picturing
21:50:38 <cpfr> http://hpaste.org/12394
21:50:45 <mmorrow> but Cayenne also has dependent types..
21:51:05 <mmorrow> so i don't think haskell could do it like Cayenne does it
21:51:44 <Axman6> sutats: Data.Ix.inRange ((0,0),(10,10)) (5,5) ==> True
21:52:03 <cpfr> but parsec gave me its work in an IO action
21:52:36 <sutats> Axman6: Wow, that would have been good to know.
21:52:41 <Axman6> :)
21:53:20 <sutats> Axman6: Would you happen to know an easy way of finding the index of an element in a 2D array (if it helps, it should be in there once)?
21:54:01 <Axman6> Data.Ix.index ((0,0),(10,10)) (5,5) ==> 60
21:54:17 <Axman6> yes?
21:54:46 <sutats> Axman6: More like "index ((0,0),(10,10)) 60 ==> (5, 5)
21:55:14 <cpfr> byorgey, what if i want to make use of the natural monadic properties of Either so that it looked up what I wanted if it can, or just return the error if it can't
21:55:57 <Axman6> sutats: (Data.Ix.range ((0,0),(10,10))) !! 60 -> (5,5)
21:56:41 <sutats> Axman6: Wow, really pays to know these functions well. For range, what if the element is in there more than once?
21:56:55 <byorgey> cpfr: sure, just use 'liftM' to lift the function on the table into the Either monad
21:56:56 <Axman6> eh?
21:57:12 <byorgey> cpfr: but it's sort of hard to know how to help without seeing the actual code
21:57:20 <cpfr> sure thing
21:57:36 <sutats> Axman6: As in, what if 60 was at (2,2) and (5,5)
21:57:52 <Axman6> sutats: Data.Ix.range ((1,1),(3,3)) ==> [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)] -- if that helps you understand what's going on
21:58:57 <cpfr> http://hpaste.org/12394#a1
21:59:02 <cpfr> byorgey, http://hpaste.org/12394#a1
21:59:18 <sutats> Axman6: Ah, I think that clears things up. Thanks.
22:01:47 <dolio> , range ((1,1),(3,3))
22:01:49 <lunabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
22:02:33 <lucca> > permutations [1..5]
22:03:08 <Axman6> lambdabot is dead
22:03:16 <lucca> long live lambdabot.
22:03:17 <dancor> @bot
22:03:21 <Axman6> !bot
22:03:26 <lucca> , permutations [1..5]
22:03:28 <lunabot>  [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],...
22:03:42 <ksf> they accidentally shot her together with the evil mangler.
22:03:47 <dancor> @bye
22:03:51 <lucca> hm, that isn't in ghc 6.8.3...
22:04:01 <Axman6> , permutations [1..3]
22:04:04 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
22:04:15 <Axman6> hmm, where is permutations?
22:04:20 <lucca> Data.List
22:04:22 <lucca> apparently
22:04:28 <lucca> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Apermutations
22:04:45 <lucca> looks snazzy, but i'm out of date again
22:05:25 <lucca> whoa, 6.10.1 is stable now
22:05:29 <lucca> miracles of modern technology
22:06:17 <Axman6> eh?
22:10:09 <ksf> is there any deep philosophical reason why i can't just do "foo Bottom = Nothing, foo x = Just x"?
22:10:37 <ksf> after all, Bottom is a member of every type, so you should be able to match it, or not?
22:11:47 <rwbarton> _|_ represents nontermination
22:11:54 <ksf> not only.
22:11:57 <rwbarton> so foo is (among other things) solving the halting problem
22:12:34 <conal> @faq can haskell solve the halting problem?
22:12:57 <conal> oh -- @bye :(
22:12:59 <dolio> Hah! Your clever plan has failed! :)
22:13:07 <ksf> it's also what fib :: Integer -> Integer denotes for negative inputs.
22:13:12 <conal> sure did
22:13:15 <pumpkin_> who runs the lambdabot in here?
22:13:18 <rwbarton> Maybe lambdabot just hasn't answered us yet.
22:13:24 <pumpkin_> conal: how is conal pronounced?
22:13:45 <ksf> I've long since solved the halting problem, I just don't write programs that don't halt.
22:13:45 <Giraffe> 01:11 < rwbarton> so foo is (among other things) solving the halting problem <-- whaaaaa?
22:13:54 <conal> pumpkin_: start with "donald", then drop the final "d", then change the first "d" to a hard "c"
22:14:04 <byorgey> cpfr: you will want to extract the lookup table from the IO and Either before doing any lookups on it.
22:14:15 <byorgey> cpfr: let me paste some example code.
22:14:35 <cpfr> i hope my code wasn't too awful
22:14:41 <mmorrow> @bot
22:14:42 <lunabot>  :)
22:15:02 <dolio> , let f x = f x in f 5
22:15:08 <lunabot>  Killed.
22:15:17 <rwbarton> Giraffe: ksf's hypothetical foo such that foo _|_ = Nothing, foo x = Just x
22:15:18 <mmorrow> , fix error
22:15:24 <lunabot>  Killed.
22:15:44 <mbz> > let 2 + 2 = 5 in 2 + 2
22:15:48 <pumpkin_> can the halting problem really be called a problem when it's an inherent contradiction?
22:16:00 <Axman6> mbz: 5 -- yes, it works
22:16:13 <mmorrow> , let 2 + 2 = 5 in 2 + 2
22:16:16 <lunabot>  5
22:16:18 <conal> pumpkin_: did that explanation work?  i haven't tried it in a text chat before.
22:16:35 <ksf> It's more a question of syntactic sugar than of semantics, you can implement everything of foo that doesn't need to solve HALT with catches.
22:16:43 <pumpkin_> conal: yeah, thanks :) now we just need to assume we both pronounce donald the same way, but I think it's pretty unambiguous
22:17:15 <ksf> pumpkin_, it's a problem because your language lets you express stuff you don't want to be able to say.
22:17:30 <pumpkin_> ksf: hmm?
22:17:42 <pumpkin_> I mean just as an abstract question
22:17:45 <dons> pumpkin_: "Dhomhnuill"
22:18:03 <byorgey> cpfr: http://hpaste.org/12394#a2
22:18:14 <byorgey> cpfr: no, it's fine, just missing some things =)
22:19:12 <ksf> problem as in "real-world stuff we should try to solve", not as in "does (\x -> x x) (\x -> x x) reduce?"
22:19:15 <cpfr> well right now I am working on an interface for it
22:19:20 <conal> pumpkin_: at anygma (in belgium) this summer, Beelsebob_ was using a sort of rounded, heavily accented long O sound, and it caught on with the other guys.  it set my teeth on edge, and finally i set them straight.
22:19:50 <dons> hehe
22:19:50 <pumpkin_> ksf: I just mean "devise a decider that can decide if an algorithm halts"
22:19:51 <ksf> that is, IMNSHO, the answer to the halting problem is mu.
22:20:13 <mmorrow> , let unDyn = maybe undefined id . fromDynamic; f <<$>> x = maybe undefined id (f `dynApply` x) in (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x))
22:20:16 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
22:20:18 <cpfr> byorgey, and those "comments"
22:20:18 <ivanm> with Lemmih's fork of JHC... since its cabalised and thus easier to install and hack with, how usable  is it compared to ghc?
22:20:32 <dons> ivanm: about 2%
22:20:43 <ivanm> i.e. is it possible to use ghc merely to bootstrap lhc and the resulting platform, and thus use just lhc?
22:20:47 <ivanm> dons: *nod*
22:20:48 <sutats> Axman6: The range function gives a list of [Ix], right? How do I map that list over my array (ie. array ! (range (bounds array)) == 60)?
22:20:54 <ksf> maybe we should call it the "computation paradox" instead.
22:20:59 <ivanm> is that one of those wonderful statistics that were made up on the spot? :p
22:21:17 <conal> i wonder how john feels about lemmih naming the fork "lemmih's haskell compiler" :(
22:21:18 * byorgey heads to bed
22:21:19 <dolio> ksf: But, any language either lets you express things you don't want to say, or doesn't let you express things you want to say. Sounds like a problem to me. :)
22:21:21 <byorgey> night all
22:21:23 <pumpkin_> ksf: that's what I was wondering, it's basically russel's paradox expressed as an algorithm
22:21:26 <pumpkin_> ll
22:21:29 <ivanm> and does thhe fork have anything to do with colliding hadrons? :p
22:21:31 <conal> byorgey: good night.
22:21:40 <mmorrow> , let unDyn = maybe undefined id . fromDynamic; f <<$>> x = maybe undefined id (f `dynApply` x) in q = (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x)) in (q . q)
22:21:42 <lunabot>  luna: parse error on input `='
22:21:43 <Axman6> sutats: not sure what you're asking for
22:21:50 <mmorrow> , let unDyn = maybe undefined id . fromDynamic; f <<$>> x = maybe undefined id (f `dynApply` x); q = (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x)) in (q . q)
22:21:52 <lunabot>  luna: Couldn't match expected type `b -> c'
22:21:55 <mmorrow> gah!
22:22:23 <ksf> dolio, we just might end up noticing that we don't need to express the stuff we can't express in total languages, even if we wanted to do it throughout all of history.
22:22:46 <mmorrow> , let unDyn = maybe undefined id . fromDynamic; f <<$>> x = maybe undefined id (f `dynApply` x); q = (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x)) in foldr (.) id (replicate 10000 unDyn) $ q
22:22:49 <lunabot>  <<Dynamic>>
22:23:19 <mmorrow> , let unDyn = maybe undefined id . fromDynamic; f <<$>> x = maybe undefined id (f `dynApply` x); q = (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x)) in unDyn q :: Dynamic
22:23:20 <dolio> ksf: Well, I agree with that, but there are notable examples of things they can't express but you might want to, like interpreters for total languages.
22:23:21 <sutats> Axman6: Say I have a 2D array of random Ints. I want to get [Ix] where for all Ix "array ! Ix" is 10. Is that clearer?
22:23:21 <lunabot>  <<Dynamic>>
22:23:59 <dolio> Although I'm not sure you can't build a compiler, so maybe that's moot aside from impractical fooling around.
22:24:01 <ksf> i need to understand 3-lisp and reflective languages in general better do speculate further, but......... that might just be it.
22:24:06 <cpfr> nite byorgey
22:24:44 <Axman6> sutats: i think you may be missing what Ix is for here. could be wrong though. my head's really not in the right gear to help today though :\
22:25:13 <dolio> Obviously you can build certain compilers, like a compiler from the embedded language to the meta-language, pretty easily.
22:25:20 <ksf> anyways, you can emulate a turing machine with a sufficiently sophisticated total language, barring, of course, _really_ letting it run forever.
22:25:34 <ksf> ...which you don't want to do, so it doesn't matter.
22:25:38 <pumpkin_> more of a linear bounded automaton?
22:26:31 <erikc> hrm, is there a common fix for the xmonad-contrib compile errors for 'ambiguous type variable 'e' in the constraint: 'GHC.Exception.Exception e''
22:26:58 <ksf> pumpkin_, one step higher, even.
22:27:11 <sutats> Axman6: I think I understand what you were trying to say, but I'm not getting my question across clearly.
22:27:20 <ksf> not according to chomsky, though, he didn't specify that class.
22:27:24 <ksf> http://en.wikipedia.org/wiki/Machine_that_always_halts
22:27:41 <Axman6> sutats: so, you've got an array, and you want the index of all 60's?
22:27:52 <ksf> erikc, yes: use ghc 6.8.
22:28:01 <sutats> Axman6: Yeah.
22:28:18 <ksf> xmonad doesn't yet use the new exceptions that come with ghc 6.10
22:28:27 <noZone> What about the machine that never gets going in the first place....
22:28:34 <ksf> ...as of version 0.8, that is. darcs might already have it.
22:28:38 <Axman6> sutats: :t Data.Array.indices
22:28:38 <Axman6> Data.Array.indices :: (Ix i) => Array i e -> [i]
22:29:15 <Axman6> wait up, not what you wanted
22:29:17 <mmorrow> dolio: any language that can't interpret itself isn't one i
22:29:26 <mmorrow> 'd want to use as my primary lang
22:29:43 <mmorrow> err, i don't think i said correctly
22:30:33 <mmorrow> i suppose i meant, i can't see such a lang as being useful other than for a restricted subset of programming tasks
22:30:47 <mmorrow> hmm, that sounds obvious i guess..
22:32:03 <mmorrow> wait, what exactly is the relationship between a lang being total and being able to interpret itself?
22:32:22 <dolio> If it's total, it can't interpret itself.
22:32:34 <ksf> mmorrow, http://p-cos.net/documents/s32008.pdf
22:32:38 <dolio> Barring being based on some kind of self-proving theory, I guess (which do exist, apparently).
22:32:40 <mmorrow> heh, but what exactly is the sticking point?
22:32:55 <ksf> it's a consequence of the halting problem.
22:33:03 <mmorrow> ah. hmm
22:33:18 <ksf> got a bad memory for proofs.
22:33:26 <sutats> Axman6: Hm, maybe assocs with lookup?
22:33:35 <Axman6> probably
22:33:35 <ksf> in fact, you could say that it's the definition of the halting problem.
22:33:43 <mmorrow> so then, by extension, a total language cannot interpret /any/ language at all then?
22:34:05 <ksf> sure it can.
22:34:27 <ksf> there's a difference between being _formally_ unable to do it and _practically_.
22:34:29 <mmorrow> but what if the program in some other lang it's interpreting never halts?
22:34:47 <sutats> Axman6: I'll play around with that then. Thanks for the help.
22:34:53 <dolio> So every langauge is turing complete? :)
22:34:53 <ksf> because practical implementations don't need to run forever.
22:35:09 <mmorrow> hmm
22:35:13 <ksf> mmorrow, see turners paper and codata.
22:35:16 * mmorrow opens that pdf now
22:35:46 <ksf> the argument is that a language can use data that's infinite in potentia, just as long as it's not really infinite.
22:35:53 <Raevel> good stuff, i have an exam on this coming up
22:36:13 <ksf> ...so, like, the stream of incoming network packets until you pull the plug.
22:37:25 <ksf> the question of implementing eval without shooting holes into the type system is interesting, though.
22:39:08 <ksf> the 3-lisp reflective approach looks like a solution to me because it makes the language contain an infinite stack of eval's, saving you from wanting to write it yourself.
22:39:20 <ksf> ...and, of course, speeding up things.
22:39:37 <mmorrow> ooh, interesting
22:40:47 <mmorrow> in lunabot, i have an `eval' that uses a fixed env and imports the pkg `luna' that it's defined in, so it can see itself. i wonder how this is related to that
22:41:38 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic . fromJust . fromDynamic) eval "eval \"eval \\\"42\\\"\"" :: Integer
22:41:39 <ksf> it's the first step, the second is to enable messing with eval itself.
22:41:40 <lunabot>  luna: Couldn't match expected type `Data.Dynamic.Dynamic'
22:42:10 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic . fromJust . fromDynamic . fromJust . fromDynamic) eval "eval \"eval \\\"42\\\"\"" :: Integer
22:42:12 <lunabot>  luna: Couldn't match expected type `Data.Dynamic.Dynamic'
22:42:15 <mmorrow> heh
22:42:34 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) eval "eval \"42\"" :: Integer
22:42:36 <lunabot>  luna: Couldn't match expected type `Data.Dynamic.Dynamic'
22:42:53 <ksf> ...which gets also quite interesting (and, right now, confusing) if i'm thinking about graph reduction machines that reduce graphs that can specify their own reduction rules.
22:43:04 <ksf> like, to be honest, ghc enables you to do, kind of.
22:44:13 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic . fromJust . fromDynamic) $ eval "eval \"eval \\\"42\\\"\"" :: Integer
22:44:18 <lunabot>  42
22:44:19 <mmorrow> finally
22:44:40 <mmorrow> and the bot is using that same exact eval function for Strings coming in over the network
22:44:50 <Raevel> completely unrelated, but interesting: http://martinfowler.com/bliki/ServiceCustodian.html
22:45:03 <Raevel> when did i turn into an engineer? :*/
22:45:21 <ksf> Worber man nicht reden kann, darber muss man schweigen.
22:45:33 <mmorrow> ksf: yeah, i'm very interested in that kind of stuff.
22:45:48 <Raevel> ksf: i almost understood that!
22:46:02 <Raevel> except for "schweigen"
22:46:14 <ksf> (About that which one can't express, one must stay quiet)
22:46:24 <ksf> to not-talk.
22:46:53 <ksf> Schopenhauer iirc.
22:48:01 <mmorrow> hmm. just as long as staying quiet doesn't prevent one from gaining the insight to be able to express that thing.. ;)
22:49:11 <mmorrow> "<ksf> it's the first step, the second is to enable messing with eval itself."
22:49:14 <mmorrow> totally.
22:49:26 <ksf> "has to", not "must", it's more of a law.
22:49:55 <mmorrow> ah, i see. nuance is hard to translate i guess
22:50:07 <ksf> nah it's just counter-intuitive.
22:50:13 <mmorrow> heh
22:50:42 <mmorrow> i've gotta check out 3-lisp
22:50:43 <ksf> must, have to, can, may and stuff maps quite complex into german.
22:50:57 <mmorrow> interesting
22:51:05 <ksf> especially their negatives.
22:51:11 <jml> they are pretty complicated in English
22:51:40 <jml> non-intuitive mapping to foreign languages is not surprising.
22:52:02 <sm> dons: thanks for hmp3, it's very cool
22:52:30 <ksf> "muss nicht" means "doesn't need to", not "must not", to start off.
22:52:54 <sm> I have it working on mac/intel/leopard with mpg123 from ports (mpg321 doesn't play)
22:53:04 <sutats> How do you use filter if you have [(Int, Char)] and you want to filter based on the Char (or Int -- same idea)?
22:53:07 <dons> hey, cool.
22:53:14 <ksf> like "It's a holiday, so I must not study"
22:54:02 <ksf> much harder to get rid of than say sitting in a restaurant and saying "I'm becoming a steak"
22:55:45 <mmorrow> this is how babelfish translates that:
22:55:47 <mmorrow> About what one cannot talk, over it one must be silent.
22:56:44 <ksf> the reason for my advocation of "has to" is that "must" connotes a social norm.
22:57:05 <ksf> ...at least, in the context of shutting up about something.
22:57:52 <ksf> if he'd meant that, he'd written "hat man zu schweigen" or "darf man nicht reden"
22:58:07 <mmorrow> interesting, so the literal translation is a little /too/ literal then, in the sense that the word "must" carries some extra meaning in english in this situation
22:58:08 <mmorrow> ?
22:58:24 <mmorrow> (or something)
22:58:49 <ksf> it's carried mostly in the context, but german tends to make it explicit.
22:58:56 <mmorrow> ie   (englishToGerman . germanToEnglish) /= id       semantically
22:59:01 <ksf> ...at least german philosophers tend to do it.
22:59:08 <mmorrow> ah, i see
22:59:44 * mmorrow finds language tranlation fascinating
23:00:19 * ksf thinks it's the single most fuzzy thing you can occupy yourself with
23:01:34 <ksf> once read a story about a poem being translated from german to frensh to japanese, back to german, and it was a completely new one.
23:01:43 <ksf> ...still having the same essential meaning.
23:02:58 <mmorrow> heh
23:03:36 <ksf> bucky fuller would have said that "turing machines are not expressible in concrete-reality"
23:03:44 <pumpkin_> is there some way to embed ghc (the interpreter, at least) itself into a haskell program, so you can process (restricted) subprograms written in haskell?
23:03:45 <mmorrow> i wonder what how it was changed has to say about how those intermediate langs
23:03:56 <mmorrow> s/how//
23:04:04 <ksf> pumpkin_, ghc api, lambdabot, etc pp.
23:04:08 <mmorrow> *...about those interm...
23:04:15 <pumpkin_> ksf: oh yeah, I'm stupid
23:04:28 <pumpkin_> I'll check how they work :) thanks
23:04:29 <ksf> ...that japanese talk much about cherry blossoms.
23:04:38 <mmorrow> pumpkin_: if you have ghc6.10.1, i have a repo up with some code to help to do that
23:04:45 <pumpkin_> mmorrow: I do :)
23:04:46 <mmorrow> ksf: haha
23:04:58 <mmorrow> http://moonpatio.com/repos/luna/
23:05:25 <ksf> talking about cherry blossoms doesn't come that naturally to germans, we rather talk about the cherries.
23:05:33 <mmorrow> pumpkin_: oh yeah, so this is important (until i fix it). you need a NONcurrent haskell-src-exts for that
23:05:44 <mmorrow> this one works:
23:05:53 <mmorrow> http://moonpatio.com/repos/haskell-src-exts/
23:05:56 <jdrake> I would like to write a program to create a report, text output is good (like SQL would do), but pretty would be better. Something that I have now done in openoffice calc: http://www.techsociety.ca/~jeffd/CreditCalculator.html   It would be better done in a language for reports. Would haskell be decent for this? Would it have any special libraries that might apply?
23:06:08 <pumpkin_> thanks mmorrow, I'll take a look
23:06:21 <mmorrow> (the part of that that uses haskell-src-exts shouldn't actually be a part of that package anyways and is nonessential...)
23:07:08 <dons> jdrake: mm. I'd imagine Text.PrettyPrint will be useful
23:07:12 <dons> and parsec for reading stuff in.
23:07:28 <jdrake> dons, might have some basic parameters
23:07:29 <dons> formatted output is a strong point (parsec + ADT + pretty class)
23:07:37 <jdrake> ADT?
23:07:42 <mmorrow> pumpkin_: (so if you have any problems with haskell-src-exts related things, just comment out Luna.TH.* in the .cabal)
23:07:58 <dons> the data type that defines your report structure
23:08:02 <pumpkin_> mmorrow: okay, will do :)
23:08:06 <jdrake> Abstract Data Tree?
23:08:09 <dons> type
23:08:17 <dons> algebraic
23:08:18 <dons> data
23:08:29 <ksf> pumpkin_, also have a look specifically at mueval.
23:08:32 <ksf> as in
23:08:40 <ksf> , let x = x in x
23:08:42 <dons> jdrake: maybe look at the chapter on pretty printing in RWH
23:08:43 <lunabot>  luna: out of memory (requested 2097152 bytes)
23:08:47 <dons> mm
23:08:49 <jdrake> Rwh?
23:08:51 <ksf> huh? not killed...
23:08:53 <mmorrow> System.Posix.Resource ftw
23:09:04 <mmorrow> mem + cpu rlimits
23:09:08 <pumpkin_> thanks, ksf
23:09:18 <mmorrow> the evaluator is in a difference proc than the bot
23:09:42 <ksf> , let y f = f y in y id
23:09:43 <lunabot>  luna: Occurs check: cannot construct the infinite type:
23:09:49 <ksf> erm...
23:09:58 <ksf> i got better stuff to do right now.
23:10:28 <mmorrow> heh
23:10:30 <Axman6> , let y f = f y in fix y
23:10:32 <lunabot>  luna: Occurs check: cannot construct the infinite type:
23:10:56 <mmorrow> , let fix f = f (fix f) in f (0:)
23:10:57 <lunabot>  luna: Not in scope: `f'
23:11:01 <BMeph> ksf: Mmm, Kirschwasser! ;)
23:11:02 <mmorrow> , let fix f = f (fix f) in fix (0:)
23:11:04 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:11:20 <hackage> Uploaded to hackage: yjtools 0.9.5
23:11:20 <hackage> Uploaded to hackage: hake 0.9.9
23:11:23 <mmorrow> @pl \f -> f (fix f)
23:11:29 <mmorrow> oh yeah..
23:11:32 <ksf> , let fix f = f (fix f) in fix fix
23:11:34 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = t -> t
23:11:57 <jdrake> Is this lunabot the same bot we have had for a while?
23:12:20 <mmorrow> err, lunabot is different from lambdabot, but lunabot's been in here for a few weeks now
23:12:55 <mmorrow> so yes if you meant from lambdabot
23:13:06 <jdrake> How easy is it to setup a bot like it? There is another channel where a bot that does math among other things would be useful :p
23:13:24 <mmorrow> jdrake: a bot that evaluates haskell? or another lang?
23:13:30 <Axman6> , let fix f = f (fix f) in fix f :: Expr
23:13:31 <ksf> jdrake, cabal install lambdabot, cat README
23:13:32 <lunabot>  luna: Not in scope: type constructor or class `Expr'
23:13:33 <jdrake> haskell :p
23:13:34 <BMeph> mmorrow: I was wondering, have you looked at that SAPL  language those wacky Dutch created? :)
23:13:35 <Axman6> lame
23:14:32 <mmorrow> jdrake: if you want a lunabot clone and you have ghc-6.10.1, you can get my luna pkg, then use Luna.Eval.eval + System.Posix.Resource to get an evaluator a bot can talk to over a pipe in about 20 lines
23:14:44 <jdrake> I would only have 6.8
23:14:53 <mmorrow> BMeph: yes. it's very interesting.
23:14:55 <dons> jdrake: well, lambdabot can join other channels.
23:14:57 <conal> mmorrow: cool
23:14:59 <dons> then you don't have the burden
23:15:05 <Axman6> dons: is the text at http://book.realworldhaskell.org/read/ the same as that in the book? because i can see at least one error (a sentense that doesn't finish)
23:15:07 <ksf> we need a new bf dialect to teach lambdabot. "curry chicken powder" or something.
23:15:11 <jdrake> dons, that would be great :p How is it done?
23:15:21 <dons> what channel?
23:15:25 <mmorrow> jdrake, conal: i also have a super minimal javascript evaluator one could stick in such a bot:
23:15:28 <jdrake> ##electronicstech
23:15:31 <dons> ?join ##electronicstech
23:15:35 <mmorrow> http://moonpatio.com/repos/mm-js/
23:15:36 <dons> how's that?
23:15:43 <dons> > hello?
23:15:46 <mmorrow> it uses the spidermonkey api
23:15:50 <dons> ah, if someone brings lambdabot back.
23:15:51 <mmorrow> ) Date()
23:15:51 <dons> Cale!
23:15:51 <lunabotjs>  Wed Nov 26 2008 00:46:29 GMT-0600 (CST)
23:16:06 <mmorrow> ) (function(x){return(x*2))(21)
23:16:06 <lunabotjs>  some error.
23:16:09 <mmorrow> heh
23:16:12 <mmorrow> no error checking..
23:16:15 <dons> Axman6: no, the text online is not the same. we're waiting to get  the proof read xml back from the publisher
23:16:16 <Axman6> heh
23:16:22 <mmorrow> ) (function(x){return(x*2)})(21)
23:16:22 <lunabotjs>  42
23:16:29 <Axman6> dons: ok, excellent
23:16:36 <dons> it's the final alpha before we sent it to the publishers 2 months ago
23:16:52 <mmorrow> conal, jdrake: that pkg for hs eval is at http://moonpatio.com/repos/luna/
23:16:56 <dons> then made ~400 commits after us
23:17:07 <Axman6> dons: how did you write it btw? like, what format did you use?
23:17:18 <dons> docbook xml
23:17:29 <dons> made the processing phase super efficient, fwiw
23:17:31 <Axman6> is that difficult?
23:17:39 <dons> like the .pdf was online < 24 hours after finishing
23:17:45 <dons> well, its xml.
23:17:45 <Axman6> nice
23:17:49 <jdrake> dons, better than latex?
23:17:51 <mmorrow> BMeph: i've played around with some TH code that translates arbitrary haskell types to their SAPL equivalent (still in haskell). i'll dig that up..
23:17:56 <dons> i wouldn't say it was as fun as candy corn
23:18:06 <dons> jdrake: about the same :)
23:18:10 <jdrake> I would fear writing anything in xml
23:18:14 <Axman6> me too
23:18:18 <dons> yes
23:18:19 <jdrake> I have a conceptual dislike of it
23:18:21 <dons> fear.
23:18:21 <Axman6> LaTeX i can handle fine
23:18:27 <dons> but hey, it works. the tools like it.
23:18:30 <jdrake> LaTeX is the win
23:18:35 <cjs> I like ML; I'd imagine that eXtended ML would be even more fun.
23:18:41 <ksf> but then, xslt is pure.
23:18:42 <dons> heh
23:18:44 <Axman6> maybe there's a tex2docbook or something
23:19:47 <ksf> http://fxsl.sourceforge.net/articles/FuncProg/2.html
23:19:56 <ksf> it's nothing you'd want to code in, though.
23:20:01 <dons> forall x y. Format x, Format y => Exists . x2y converter
23:20:14 <mmorrow> jdrake, conal: ooh, i should mention this. if you do use that method for a lunabot clone and put it somewhere where untrusted people can eval expressions, you MUST change to export list in Luna.Eval to ONLY export "eval", since that module is imported into eval's scope... (see Luna.Config for the list of imported pkgs/modules)
23:20:31 <ksf> it's the same problem as ant's: the xml syntax hides all that cool stuff behind my aversion for angle brackets.
23:20:57 <mmorrow> well, you maybe could (and it'd be interesting to) export other stuff from that module, but you'd have to audit it for safety..
23:21:06 <jdrake> mmorrow, I am not sure I can easily construct something of this sort. I would rather have somebody made something already :-)
23:21:11 <jdrake> and I only have ghc 6.8
23:21:30 <jdrake> When debian upgrades, I will upgrade
23:21:38 <mmorrow> jdrake: ah, yeah the ghc-api is super volatile, so that luna pkg will /only/ build on exactly 6.10.1
23:22:02 <mmorrow> doesn't even work (without minor changes) on 6.10.0 or 6.11(HEAD)
23:22:18 <jdrake> Why does the api change so?
23:22:36 <mmorrow> it's still not clear the best interface
23:22:48 <mmorrow> so i guess you could call it a work in progress
23:23:00 <jdrake> Something such as the way python does it would be preferred
23:23:07 <mmorrow> how is that?
23:23:14 <mmorrow> (how does python do it?)
23:23:43 <jdrake> Pack Rat until you clean house with major version (3)
23:24:07 <mmorrow> heh
23:24:32 <jdrake> It is like solaris, I have heard, is big on binary compatibility.
23:24:48 <jdrake> Running a binary from 15 years ago - might actually work - try that on linux
23:25:06 <mmorrow> yeah, i guess progress and stability is the tradeoff
23:25:14 <mmorrow> s/and/or/
23:25:18 <dons> i ran my first university assignment (a haskell cgi program) successfully 9 years later recently
23:25:30 <ksf> ...work in case you still got an old libc lying around, or it's statically compiled.
23:25:31 <jdrake> You might have noticed my preference given that I run debian
23:25:39 <dons> originally written for gofer, then ran in hugs, then compiled with ghc almost a decade on.
23:25:42 <dons> H98 never dies.
23:25:45 <mmorrow> (not to say that it's black/white rather than shades of gray..)
23:26:07 <mmorrow> dons: nice
23:26:14 <dons> you can't kill it.
23:26:18 <jdrake> dons, although I missed gofer it seemed like it was superior in many ways.
23:26:23 <dons> to hugs?
23:26:23 <jdrake> gopher rather
23:26:33 <jdrake> oops
23:26:33 <jdrake> nvm
23:26:38 <BeelsebobWork> dons: this is exactly why I love H98, and am so keen to see H'
23:26:44 <BeelsebobWork> (a stable H' that is)
23:26:47 <dons> gofer the pre-hugs
23:26:52 <dons> BeelsebobWork: yeah
23:27:05 <dons> BeelsebobWork: choose your -X wisely
23:27:22 <jdrake> What I was mistaking when I was talking was that gopher seemed like a better system in many ways to http/html
23:27:26 <dons> hehe
23:27:28 <dons> yes.
23:27:29 <BeelsebobWork> hehe
23:27:40 <dons> did you use the haskell gopher client?
23:27:46 <BeelsebobWork> I mostly tend to chose no -X and no -f, so I should be winning :)
23:28:03 <jdrake> I never saw a real gopher client, only poor implementations in browsers
23:28:19 <Axman6> BanPatterns is the only one i've ever wanted to use
23:28:29 <Axman6> g*
23:28:34 <BeelsebobWork> BangPatterns is about the last one I'll ever touch :P
23:28:38 <dons> hah
23:28:55 <dons> BeelsebobWork doesn't write low level code.
23:29:03 <BeelsebobWork> yep
23:29:25 <dons> weren't bang patterns added to ghc so galois could finish our file system implementation?
23:29:25 <BeelsebobWork> having said that -- so far, 99% of my performance problems have been related to my program being too strict
23:29:28 <BeelsebobWork> not too lazy
23:29:40 <mmorrow> BMeph: here's that SAPL related code: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=103#a113   (the Luna.Devel.Utils import is only for those first two pp* functions and can be deleted (i think))
23:29:47 <mmorrow> and here's some sample output:
23:29:54 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=103#a112
23:30:52 * mmorrow loves seeing autogenerated code spit out in less than a second that would be deathly tedious to write by hand
23:32:36 <mmorrow> ooh, actually the fact that those functions take an info means you need to call them from inside the Q monad (not in ghci), or to have instances of Lift for Info,Exp,... (i have such instances in http://moonpatio.com/repos/luna/)
23:32:56 <mmorrow> so that ghci example wouldn't work without those instances
23:34:21 <sutats> Is there a lookup for b in [(a,b)] (ie. the lookup in Prelude looks up on the a's)?
23:35:23 <BMeph> mmorrow: Nice! So, is there a version of luna that doesn't need readline, and thus a *nix install? :)
23:36:14 <mmorrow> BMeph: hmm, you could s/System.Console.Readline/System.Console.Editline.Readline/ in luna/tools/luna.hs and s/readline// from the .cabal
23:36:21 <mmorrow> that'd do it
23:36:45 <mmorrow> (luna/tools/luna.hs is the only place i use readline..)
23:36:53 <ksf> ha!
23:37:03 <mmorrow> you could always install the readline package from hackage also..
23:37:11 <ksf> the ultimate solution to the halting problem is mtbf.
23:37:48 <mmorrow> mtbf?
23:37:56 <ksf> mean time between failures
23:38:01 <maxote> ksf, or destroy it with waiting for mtbf
23:38:01 <mmorrow> hmm
23:38:12 <maxote>  /with/without
23:38:23 <BMeph> mmorrow: Hmm, readline...or editline. That's a thrilling decision. ;p
23:38:25 <ksf> you just gotta include it in the theory and _every_ computation halts.
23:38:39 <ksf> ...sooner or later.
23:38:50 <mmorrow> BMeph: after using editline with ghci post-6.8 i've grown to hate editline
23:39:15 <mmorrow> it can't do unicode input
23:39:19 <mmorrow> delete doesn't work
23:39:34 <vegai> mmorrow: oh dear.
23:39:40 <mmorrow> it inexplicably exited ghci for the first month or two of 6.9
23:39:51 <pumpkin_> yeah, the unicode thing is annoying
23:39:53 <mmorrow> i think there are other open bugs too..
23:39:58 <mmorrow> pumpkin_: very
23:40:05 <vegai> couldn't that problem be solved with pure haskell?
23:40:17 <vegai> or is it too easy?
23:40:28 <mmorrow> vegai: there's actually an hs-readline pkg on hackage
23:41:04 <mmorrow> it works too, (but only has readline and addHistory as of now..)
23:41:10 <ksf> can anyone around here guesstimate whether or not a strong, reflective FPL could execute every halting program?
23:41:33 <vegai> mmorrow: hasn't moved in a year, though
23:42:17 <mmorrow> vegai: hmm, i think someone needs to use it as a start and run with it
23:43:00 <mmorrow> i'm not sure how much effort it'd take to implement the standard readline interface...
23:44:38 <BMeph> mmorrow: Yeah, maybe I'll just setup VMWare and use that. I suspect that my IT setup at work is breaking cabal-install, so I'm going to see if it works on a VM. :)
23:46:33 <mmorrow> BMeph: hmm? do you mean just for that luna pkg? if so i can really quickly make an editline version of that pkg (it'd take me less than a minute) :)
23:47:02 <mmorrow> the part of that pkg that uses editline/readline isn't essential either
23:52:18 <mmorrow> BMeph: http://moonpatio.com/repos/luna_editline/
23:52:24 <mmorrow> (if that helps)
23:56:10 <solrize> ksg, you mean a strongly normalizing fpl and EVERY halting program?  obviously not.
23:56:26 <lispy> ?tell Cale lambdabot is on the fritz so you won't get this message.
23:56:55 <lispy> not just normalizing
23:56:58 <mmorrow> preflex: tell lispy preflex: tell Cale
23:56:58 <preflex>  Consider it noted.
23:56:59 <lispy> STRONGLY normalizing
23:57:00 <preflex>  lispy: you have 1 new message. '/msg preflex messages' to read it.
23:57:01 <solrize> ksf i meant
23:57:05 <mmorrow> hehe
23:57:38 <mmorrow> also, preflex's "seen" is second to none
23:57:49 <lispy> ?none
23:57:51 <mmorrow> preflex: seen lambdabot
23:57:51 <preflex>  lambdabot was last seen on #haskell 2 hours, 52 minutes and 49 seconds ago, saying: forall a b. a -> b -> b
23:57:56 <lispy> preflex: none
23:58:04 <solrize> preflex: seen dolio
23:58:04 <preflex>  dolio was last seen on #haskell 1 hour, 23 minutes and 12 seconds ago, saying: So every langauge is turing complete? :)
23:58:10 <lispy> mmorrow: if none is better then why doesn't it do anything?
23:58:32 <lispy> preflex: seen lispy
23:58:32 <preflex>  lispy was last seen on #haskell 22 seconds ago, saying: mmorrow: if none is better then why doesn't it do anything?
23:58:38 <mmorrow> lispy: it's clearly confused. we should keep trying though ;)
23:58:50 <mmorrow> preflex: seen preflex
23:58:50 <preflex>  what
23:58:52 <lispy> preflex: wrong, I was last seen talking to you by the time you saw that!
23:58:52 <mmorrow> haha
23:59:28 <lispy> preflex: vixen do you has it?
23:59:56 <mmorrow> preflex: HAI CAN HAS STDIO? VISIBLE "HAI" KTHXBYE
