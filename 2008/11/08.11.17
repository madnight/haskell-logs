00:17:24 <Taejo> @hoogle Either a b -> b
00:17:24 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
00:17:24 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
00:17:24 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
00:18:10 <vincenz> Anyone care to explain why 'Cps (a,b) = (Cps a, Cps b)'  and what 'Cps (s -> t) = (Cps s, Cps t -> Z) ->Z ' means
00:19:18 <ski_> probably the type part of the CPS translation
00:19:25 <vincenz> ski_: I don't get it tho
00:20:21 <ski_> do you know what the abbreviation "CPS" stands for ?
00:20:25 <vincenz> Yes :)
00:20:44 <ski_> ok, what part don't you get ?
00:21:18 <vincenz> ski_: well I don't see why the CPs of a pair is a pair, since nwo you have two places to pass a continuation, and I don't quite get the second one, or what the Z stands for
00:21:38 <vincenz> shouldn't the CPS transfo encode L-to-R ?
00:21:50 <ski_> we define a translation from a language with functions and pairs, which maps expressions into expressions where every application is in tail-position
00:22:35 <ski_> there are several variants of CPS .. the call-by-value variant would typically encode L-to-R (or R-to-L) of applications
00:22:59 <vincenz> How come the CPS of a function results in a pair?
00:23:08 <ski_> no
00:23:18 <vincenz> Or rather, a function taking a pair to some arbitrary Z
00:23:26 <ski_> it results in a function from a pair type to the answer type
00:23:52 <ski_> the pair is the pair of the input argument to the function, and the output continuation to continue with
00:24:07 <vincenz> oic
00:24:14 <ski_> you may think of the continuation as a "return address" if you wish
00:24:17 <vincenz> Right
00:24:32 <vincenz> I know what continuations are, just this formulation is rather novel to me.
00:24:53 <vincenz> But thanks :)
00:24:54 <ski_> this is encoding continuations as functions to an answer type
00:25:16 <ski_> one could just as well have used `Cont' instead of `(-> Z)'
00:25:22 <vincenz> What is the CPS of a plain type?
00:25:41 <vincenz> Cps (int -> int) === (int, int -> Z) -> Z ?
00:25:49 <ski_> (only then one can't do crazy^H^H^H^H^Hfun stuff with composable/delimited continuations)
00:25:56 <ski_> yes
00:26:03 <vincenz> cool
00:26:31 <vincenz> Alright, thanks for clarifying that
00:27:42 <ski_> .. i presume you're reading some paper ?
00:27:56 <askentasken> Haskell claims the multicore world. OK but could nanotech perhaps bring single-core back or even if someone comes up with a way to increase nb of transistors per chip again or something else we will still have multiple cores(multiple cores have an advangate anyhow because of real parallellism right?)?
00:28:01 <BeelsebobWork> random related question -- what does the CPS monad gain me over just writing CPS code?
00:28:52 <ski_> BeelsebobWork : not having to painstakingly make sure that you write in CPS ?
00:28:58 <askentasken> mapM is map with sideeffectful functions right?
00:29:07 <BeelsebobWork> can you give me an example of that ski_?
00:29:12 <BeelsebobWork> also -- why would I have to do that?
00:29:23 <BeelsebobWork> i.e. why does it matter if I don't write a small section in CPS
00:29:23 <ski_> askentasken : yes (and with a specified execution order for the elements of the list)
00:29:36 <kalven> askentasken: no, in a few years everyone will have to code haskell.
00:29:51 <substack> hooray \o/
00:30:08 <substack> that'll show 'em
00:30:23 <ski_> BeelsebobWork : no, i didn't mean that you should write everything in CPS .. just that the things you want in CPS might not actually be in CPS
00:30:39 <vincenz> ski_: yeah the latest paper by schrijvers
00:30:41 <BeelsebobWork> okay, and why might I explicitly want something in CPS?
00:30:50 <BeelsebobWork> i.e. if it works not in CPS, what's the problem?
00:30:52 <ski_> vincenz : Olin Shivers ?
00:30:57 <vegai> kalven: and we will be paid for our skills.... in money!
00:31:00 <vincenz> ski_: no Schrijvers
00:31:02 <BeelsebobWork> askentasken: there's a reason why all the chip design companies are going multi-core -- it's got really really difficult to get more performance without it
00:31:08 <vincenz> ski_: Type Checking with Open Type Functions
00:31:15 <ski_> ty
00:32:45 <ski_> BeelsebobWork : "if it works not in CPS" ?
00:33:10 <BeelsebobWork> ski_: if I start writing a function in CPS, and end up writing something that isn't actually CPS, what's the problem?
00:33:23 <BeelsebobWork> i.e. why would I want to painstakingly check that I'm still in CPS?
00:33:31 <ski_> the code might not do what you intended ?
00:34:09 <ski_> compare with passing state around explicitnly instead of using `State' .. you have to keep track of the `s0',`s1',...
00:34:39 <BeelsebobWork> yeh -- but I've not found an instance where keeping track of actually calling the continuation in each rule is difficult
00:34:53 <BeelsebobWork> wheras keeping track of where s0 s1 s2, s96 go *is* really hard
00:34:59 <vincenz> Nice: :) "A related problem is that of type inference. For exmaple, if the type for insx above is not supplied by the programmer, can the type checker infer it? The answer is yes - but for reasons of space we completely ignore the inference probmein in this paper, ..."
00:35:06 <vincenz> Gotta love that statement
00:35:20 <ski_> (of course, sometimes you explicitly *want* a selected few applications inside CPS to not be in tail-position .. but then you could use specific operators there)
00:36:10 <BeelsebobWork> okay, so the CPS monad essentially gains me something in making sure I actually write my CPS as I originally intended
00:36:21 <BeelsebobWork> but I think I need to try writing something in it to understand what I gain
00:36:36 <olsner> hehe, if they hadn't ignored it maybe they would've found... I dunno... a language that already has type inference? :P
00:36:52 <ski_> say you want to use a few composable continuations here and there .. it can be a bit tricky to remember how and where to encode all the `reset' and `shift' operations
00:36:59 <vincenz> olsner: this is completely new stuff
00:37:10 <vincenz> olsner: it's like saying "Yes, we're so cool and have the ultimate system, but we'll only tell you part A here":
00:38:08 <askentasken> Beelsebob: yes but i asked IF someone could come up with a way to increase speed without multicores, would multicores still be wanted?
00:38:36 <ski_> BeelsebobWork : another reason for using 'ContT' is to improve performance in some cases
00:39:12 <ski_> (but in that case you're just more-or-less using `ContT o m' as a drop-in replacement for `m')
00:39:38 <BeelsebobWork> okay, interesting
00:39:54 <ski_> consider the `Either e' monad
00:40:13 <sjanssen> askentasken: yes, we'd want multiple increased speed cores :)
00:40:43 <ski_> assume you have `((..((Nothing >>= foo) >>= bar)..) >>= baz) >>= quux'
00:41:00 <ski_> er, s/Nothing/Left err/
00:41:25 <ski_> this will check the `Left err' at each `>>=', and just percolate the exception one step upwards
00:42:05 <ski_> using `ContT o (Either e)' instead, raising an exception will just "jump" upwards directly to the nearest exception handler
00:42:12 <BeelsebobWork> hmm, okay
00:42:15 <BeelsebobWork> interesting
00:43:26 <ski_> (compare with naive `reverse' which has "left-associative" `++' calls .. similar to the situation above .. here the solution is to introduce an auxilary parameter .. that corresponds in some sense to the continuation above)
00:50:13 <mmorrow> > let forever' f a = f a >>= forever' f in flip runCont id $ callCC (\done -> forever' (\a -> if a>1000 then done a else return (a+7)) 3)
00:50:14 <lambdabot>   1004
00:50:52 <mmorrow> , fix (\go a -> if a>1000 then a else k (a+1)) 3
00:50:53 <lunabot>  luna: Not in scope: `k'
00:50:59 <mmorrow> , fix (\go a -> if a>1000 then a else go (a+1)) 3
00:51:01 <lunabot>  1001
00:51:08 <mmorrow> , fix (\go a -> if a>1000 then a else go (a+7)) 3
00:51:10 <lunabot>  1004
00:54:11 <ski_> @type \f -> fix (. (=<< f))
00:54:13 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
00:54:13 <lambdabot>       Expected type: (a -> b) -> c
00:54:13 <lambdabot>       Inferred type: (a -> a -> b) -> c
00:55:00 <mmorrow> @type \f -> fix (. (f =<<))
00:55:01 <lambdabot> forall c a (m :: * -> *). (Monad m) => (a -> m a) -> m a -> c
00:56:30 <ski_> @type \f -> fix ((. f) . (=<<))
00:56:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m a) -> a -> m b
00:57:35 <ski_> @type callCC
00:57:39 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
00:58:06 <ski_> `((forall b. a -> m b) -> m a) -> m a' would be more useful
00:58:34 <ski_> (or you could use `Void' ..)
01:03:29 <Baughn> http://xkcd.com/505/ <-- Wow. Just wow.
01:03:30 <lambdabot> Title: xkcd - A Webcomic - A Bunch of Rocks
01:05:09 <substack> he should evaluate lazily
01:05:41 <Baughn> Maybe he is
01:11:59 <askentasken> multicore-fadacci!
01:17:15 <askentasken> multi-cooore. excellente!
01:20:23 <grom358> how can I filter and apply a function to the filter result and have both the filtered result and the result from calling the function in a list?
01:21:16 <Twey> multi-cooooore. banli!
01:21:16 <BeelsebobWork> grom358: map (id &&& f)?
01:21:19 <Deewiant> > map (id &&& (+1)) [1,2,3]
01:21:22 <lambdabot>   [(1,2),(2,3),(3,4)]
01:21:46 <Twey> map (second f) :(
01:22:14 <Twey> Wait, filter?
01:22:25 <Deewiant> map (id &&& f) . filter
01:22:28 <Deewiant> p
01:22:35 <Twey> > map (second (+2)) [1, 2, 3]
01:22:36 <lambdabot>       No instance for (Num (d, b))
01:22:36 <lambdabot>        arising from the literal `1' at <in...
01:22:39 <grom358> eg. let x = filter (\x -> 28 `mod` x == 0) [1..(floor(sqrt 28))]; let y = map (\x -> 28 `div` x) x; let z = x ++ y
01:22:56 <Baughn> > [(a,f a) | a <- [1..5], a < 3]
01:22:57 <lambdabot>   Add a type signature
01:22:58 <Twey> Oh, blast.
01:23:18 <BeelsebobWork> > map (second (+2) . (id &&& id)) [1,2,3]
01:23:19 <lambdabot>   [(1,3),(2,4),(3,5)]
01:23:24 <BeelsebobWork> also works -- but it's more complex
01:23:28 <Deewiant> > let x = filter ((==0).(mod 28)) [1..floor(sqrt 28)] in map (id &&& div 28) x
01:23:30 <lambdabot>   [(1,28),(2,14),(4,7)]
01:23:41 <Baughn> > [(a,a+1) | a <- [1..5], a < 3] -- Isn't this good enough?
01:23:42 <lambdabot>   [(1,2),(2,3)]
01:23:57 <BeelsebobWork> Baughn: hehe, good point
01:24:04 <grom358> can I have it so they not in tuples?
01:24:23 <BeelsebobWork> hmm? how else would they appear?
01:24:48 <grom358> [1,28,2,14,4,7]
01:25:28 <BeelsebobWork> > foldr (\x y -> x : (x+2) : y) [] [1,2,3,4]
01:25:30 <lambdabot>   [1,3,2,4,3,5,4,6]
01:26:10 <BeelsebobWork> > let withApp f = foldr (\x y -> x : f x : y) [] in withApp (+2) [1,2,3,4]
01:26:11 <lambdabot>   [1,3,2,4,3,5,4,6]
01:29:30 <BeelsebobWork> note though that that restricts you on what fs you can actually use
01:29:39 <BeelsebobWork> because it has to have type a -> a
01:33:52 <ski_> > [ (if b then (2 +) else id) x | x <- [1,2,3,4] , b <- [False .. True] ]
01:33:54 <lambdabot>   [1,3,2,4,3,5,4,6]
01:33:55 <grom358> okay.. so I got foldr (\x y -> x : 28 `div` x : y) [] $ filter (\x -> 28 `mod` x == 0) [1..floor(sqrt(28))]
01:34:42 <BeelsebobWork> well, personally I'd abstract the foldr into a function with appropriate name (withApp is fairly crap)
01:35:08 <ski_> > [ (if b then (28 `div`) else id) x | x <- [1 .. fllor (sqrt 28)] , 28 `mod` x == 0 , b <- [False .. True] ]
01:35:10 <lambdabot>   Not in scope: `fllor'
01:35:16 <ski_> > [ (if b then (28 `div`) else id) x | x <- [1 .. floor (sqrt 28)] , 28 `mod` x == 0 , b <- [False .. True] ]
01:35:18 <lambdabot>   [1,28,2,14,4,7]
01:36:11 <mikv> @src (elem)
01:36:11 <lambdabot> Source not found. Do you think like you type?
01:36:20 <mikv> @src elem
01:36:20 <lambdabot> elem x    =  any (== x)
01:36:27 <mikv> @src an
01:36:28 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:36:30 <mikv> @src any
01:36:31 <lambdabot> any p =  or . map p
01:36:32 <ski_> > do x <- [1 .. floor (sqrt 28)]; guard (28 `mod` x == 0); return x `mplus` return (28 `div` x)
01:36:34 <lambdabot>   [1,28,2,14,4,7]
01:36:51 <ski_> > do x <- [1 .. floor (sqrt 28)]; guard (28 `mod` x == 0); [x,28 `div` x]  -- if you prefer
01:36:53 <lambdabot>   [1,28,2,14,4,7]
01:36:59 <ski_> i suppose one could also
01:37:18 <BeelsebobWork> ugh
01:37:19 <ski_> > [ y | x <- [1 .. floor (sqrt 28)] , 28 `mod` x == 0 , y <- [x,28 `div` x] ]
01:37:20 <lambdabot>   [1,28,2,14,4,7]
01:37:35 <Deewiant> > let x = filter ((==0).(mod 28)) [1..floor(sqrt 28)] in concatMap (sequence [id, div 28]) x
01:37:37 <lambdabot>   [1,28,2,14,4,7]
01:37:57 <ski_>   concatMap = (=<<)
01:38:09 <Deewiant> yep
01:38:12 <grom358> what is this id thing?
01:38:16 <Deewiant> > filter ((==0).(mod 28)) [1..floor(sqrt 28)] >>= sequence [id, div 28]
01:38:16 <ski_> @src id
01:38:16 <lambdabot> id x = x
01:38:17 <lambdabot>   [1,28,2,14,4,7]
01:38:25 <ski_> > id "hello there !"
01:38:27 <lambdabot>   "hello there !"
01:38:50 <BeelsebobWork> grom358: it's the identity -- it's the function which always returns what you give it
01:39:03 <ski_> > (id id) (id id) 5
01:39:04 <lambdabot>   5
01:39:36 <BeelsebobWork> > let g h = h h 4 in g id
01:39:37 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
01:39:37 <lambdabot>    ...
01:39:38 <BeelsebobWork> :D
01:39:45 <BeelsebobWork> yay for breaking the type system
01:39:52 <opqdonut> :)
01:40:09 <opqdonut> BeelsebobWork: you probably wanted h (h 4)
01:40:12 <Deewiant> > let g :: (forall a. a -> a) -> Int; g h = h h 4 in g id
01:40:14 <lambdabot>   4
01:40:15 <ski_> > let g :: Num b => (forall a. a -> a) -> b ; g h = h h 4 in g id
01:40:16 <lambdabot>   4
01:40:22 <BeelsebobWork> opqdonut: no, I wanted to break the type system
01:40:29 <opqdonut> okay
01:40:31 <BeelsebobWork> it requires rank-2 polymorphism
01:40:37 <opqdonut> explicit typesigs work, yeah
01:40:53 <BeelsebobWork> well no, the explicit typing that ski_ gave it isn't valid in H98
01:41:08 <ski_> Rank-N to the masses !
01:41:15 <Deewiant> Well, H98 kinda sucks anyway :-P
01:41:21 <BeelsebobWork> heh
01:41:27 <ski_> the people demands it
01:42:52 <grom358> ski_: I like your [y | x <- [1..floor(sqrt 28)], 28 `mod` x == 0, y <- [x, 28 `div` x]] solution
01:44:23 <ski_> you may keep it :)
01:44:58 <ski_> (but consider possibly using `divMod')
01:45:27 <grom358> what would be the most idiomatic way todo it? or are all pretty standard looking haskell?
01:47:04 <BeelsebobWork> I would say either the foldr way or the list comprehension
01:47:12 <BeelsebobWork> I personally would use the foldr
01:48:04 <SubStack> list comprehensions can get pretty ugly pretty quick
01:48:13 <BeelsebobWork> yeh, but that one isn't too bad
01:48:19 <BeelsebobWork> it's right on the edge though
01:48:29 <BeelsebobWork> much more than that and I'd throw a hissy fit at it
01:48:53 <grom358> I trying to make it into a function and replacing 28 with n but getting type errors. No instance for (RealFrac Int) arising from a user of floot
01:49:00 <grom358> use* of floor
01:49:17 <BeelsebobWork> grom358: floor operates on RealFracs
01:49:22 <ski_> fromIntegral
01:49:24 <BeelsebobWork> so the 28 in that example is a RealFrac
01:49:30 <SubStack> I usually rewrite them when they start wrapping to the next line
01:49:43 <BeelsebobWork> so you need to convert your Int to a RealFrac a => a
01:49:46 <SubStack> at 80 characters
01:49:47 <Baughn> grom358: n is already an Int, which makes using floor on it both impossible and silly - it's already an integer
01:49:53 <ski_> SubStack : you could change them into `do's, too
01:50:05 <SubStack> true
01:50:08 <BeelsebobWork> ski_: yeh, but that would be horrible
01:50:08 <ski_> or
01:50:15 <ski_>   [ foo | bar
01:50:20 <ski_>         , baz
01:50:23 <SubStack> I don't like that so much though
01:50:23 <ski_>         , ...
01:50:25 <BeelsebobWork> completely non sequential computation, sequentialised for no reason
01:50:26 <ski_>         ]
01:50:27 <grom358> Baughu: huh? I doing floor(sqrt n)
01:50:41 <BeelsebobWork> :t sqrt
01:50:42 <lambdabot> forall a. (Floating a) => a -> a
01:50:49 <BeelsebobWork> @instances Floating
01:50:50 <lambdabot> Double, Float
01:50:59 <ski_> BeelsebobWork : depends .. sometimes it can be lovely
01:51:00 <sjanssen> BeelsebobWork: sequence does matter somewhat in the list monad
01:51:16 <BeelsebobWork> sjanssen: yeh -- but it doesn't matter in something that is really a list comprehension
01:51:35 <BeelsebobWork> i.e. if it's a list comprehension, it can be thought of non-sequentially, and there's no reason to sequentialise it with do
01:51:52 <sjanssen> BeelsebobWork: a list comprehension is also sequential
01:52:05 <grom358> so how do I round down the result from sqrt to Int?
01:52:05 <BeelsebobWork> sjanssen: yes -- but it doesn't expose the sequentiality to the outside world
01:52:12 <sjanssen> sure it does
01:52:23 <BeelsebobWork> sjanssen: where?
01:53:10 <sjanssen> > [(x, y) | x <- [1, 2], y <- "ab"]]
01:53:12 <lambdabot>   <no location info>: parse error on input `]'
01:53:12 <SubStack> grom358: like with floor?
01:53:22 <sjanssen> > [(x, y) | x <- [1, 2], y <- "ab"]
01:53:24 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
01:53:26 <BeelsebobWork> sjanssen: I don't see any sequentiality there
01:53:28 <SubStack> and then fromIntegral on that
01:53:44 <sjanssen> > [(x, y) | y <- "ab", x <- [1, 2]] -- vs. this
01:53:46 <lambdabot>   [(1,'a'),(2,'a'),(1,'b'),(2,'b')]
01:54:08 <BeelsebobWork> sjanssen: yes, but that's essentially just like swapping arguments to a function round
01:54:08 <sjanssen> BeelsebobWork: you also need to consider cases where a prior list is infinitely long
01:54:20 <BeelsebobWork> surprise surprise, that produces different results
01:54:26 <ski_> the sequentiality of the list monad translates into different nesting levels of the "loops"
01:54:28 <BeelsebobWork> it's not explicitly writing a sequential program though
01:54:39 <ski_> it is
01:54:41 <sjanssen> how is it any different?
01:54:50 <BeelsebobWork> it's different in terms of program style only
01:54:55 <BeelsebobWork> one program is sequential
01:54:57 <BeelsebobWork> the other is not
01:55:11 <sjanssen> >  [(1,'a'),(1,'b'),(2,'a'),(2,'b')] ==  [(1,'a'),(2,'a'),(1,'b'),(2,'b')]
01:55:13 <lambdabot>   False
01:55:15 <ski_> both are similar in style, but the results differ subtly
01:55:25 <BeelsebobWork> > const 5 6 == const 6 5
01:55:26 <lambdabot>   False
01:55:55 <BeelsebobWork> it behaves exactly the same way as a function does
01:55:58 <sjanssen> putChar 'h' >> putChar 'i' == putChar 'i' >> putChar 'h'
01:56:08 <Mr_Awesome> (+) 3 4 == (+) 4 3
01:56:14 <Mr_Awesome> > (+) 3 4 == (+) 4 3
01:56:16 <lambdabot>   True
01:56:17 <Deewiant> > const 5 6 == cÎ¿nst 6 5
01:56:18 <Mr_Awesome> oh wait...
01:56:18 <ski_> > [(1,'a'),(1,'b'),(2,'a'),(2,'b')] == [(1,'a'),(2,'a'),(1,'b'),(2,'b')]   where xs == ys = all (`elem` xs) ys && all (`elem` ys) xs
01:56:19 <lambdabot>   True
01:56:20 <lambdabot>   True
01:56:29 <sjanssen> BeelsebobWork: (>>) is a function too
01:56:40 <BeelsebobWork> sjanssen: yes -- but one that stylistically introduces a sequence
01:56:54 <BeelsebobWork> I'm not complaining about *anything* here, other than programming style
01:57:03 <grom358> so fromIntegral(floor(sqrt n)) ?
01:57:21 <SubStack> function composition looks nicer, but yeah
01:57:30 <sjanssen> > [(x, y) | x <- [1 ..], y <- "ab"] -- enumerates all pairs
01:57:32 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b'),(4,'a'),(4,'b'),(5,'a'),(5...
01:57:39 <Mr_Awesome> Deewiant: wha?
01:57:41 <ski_> grom358 : rather with the `fromIntegral' converting the integral `n' to a real-fractional one to pass to `sqrt' ..
01:57:43 <Deewiant> > const 5 6 == cÎ¿nst 6 5
01:57:44 <lambdabot>   True
01:57:56 <sjanssen> > [(x, y) | y <- "ab", x <- [1 ..]] -- doesn't
01:57:58 <lambdabot>   [(1,'a'),(2,'a'),(3,'a'),(4,'a'),(5,'a'),(6,'a'),(7,'a'),(8,'a'),(9,'a'),(1...
01:57:59 <Deewiant> > [const 5 6,cÎ¿nst 6 5]
01:58:00 <lambdabot>   [5,5]
01:58:00 <grom358> cause I still getting No instance for (RealFac Int) arising from a use of floor
01:58:01 <Mr_Awesome> > const 5 6 == const 6 5
01:58:02 <lambdabot>   False
01:58:06 <sjanssen> BeelsebobWork: order matters
01:58:25 <ski_> the list monad is not "commutative"
01:58:34 <Mr_Awesome> Deewiant: stop that
01:58:41 <BeelsebobWork> sjanssen: yes, I know it does -- that doesn't stop that being stylistically better than 'do, make x the value you get by binding this list, make y the value you get by binding this list, return the pair of x and y'
01:58:53 <BeelsebobWork> sjanssen: again -- I'm *only* talking about programming style
01:58:53 <Deewiant> Mr_Awesome: I'm not doing anything :-P
01:59:00 <sjanssen> BeelsebobWork: you're reading "do" too strictly
01:59:03 <BeelsebobWork> the do style is horrible for something that is really a list comprehension
01:59:18 <Deewiant> > 'o' == 'Î¿'
01:59:19 <lambdabot>   False
01:59:29 <ski_> imo, `do' for list monad, and list comprehension is almost exactly the same thing
01:59:30 <SubStack> @pl [n | n <- [1..10], even n]
01:59:30 <lambdabot> [n | n <- [1..10], even n]
01:59:42 <BeelsebobWork> ski_: it is the same thing -- except for in style
01:59:58 <ski_> what do you mean by "style" ?
01:59:58 <SubStack> that's odd, n seems like a point
02:00:00 <Mr_Awesome> i'm so confused
02:00:03 <ski_> how you think about it ?
02:00:06 <BeelsebobWork> ski_: programming style
02:00:10 <BeelsebobWork> how the program looks
02:00:12 <BeelsebobWork> how the program reads
02:00:17 <ski_> or the concrete syntactic apperance and order ?
02:00:36 <Deewiant> > map fromEnum "oÎ¿" -- Mr_Awesome
02:00:38 <lambdabot>   [111,959]
02:00:51 <BeelsebobWork> both the concrete syntactic appearance, and the fact that one explicitly says "there's an stepping behavior here -- we first bind x, then bind y, then return a value"
02:01:01 <BeelsebobWork> when in fact, that stepping behavior *isn't* there
02:01:10 <BeelsebobWork> because lazy evaluation can do it any way it likes
02:01:17 <ski_> it's only there in your mind
02:01:21 <BeelsebobWork> yes
02:01:23 <sjanssen> BeelsebobWork: where does it say there is a stepping behavior?
02:01:25 <BeelsebobWork> which is why do is bad
02:01:25 * quicksilver is with ski_ on that one.
02:01:32 <quicksilver> there is no stepping behaviour in the do
02:01:32 <ski_> <sjanssen> BeelsebobWork: you're reading "do" too strictly
02:01:36 <BeelsebobWork> do makes it look like there *is* a stepping behavior
02:01:37 <quicksilver> it's just in BeelsebobWork's mind.
02:01:39 <quicksilver> only to you.
02:01:43 <Mr_Awesome> Deewiant: you tricky bastard ;)
02:01:49 <Deewiant> :-P
02:02:04 <quicksilver> do is just a syntax for building up function application
02:02:09 <BeelsebobWork> quicksilver: I think pretty much any non-haskell-expert will ready do x y z as having a sequential behavior
02:02:10 <quicksilver> convenient for some purposes, and not for others.
02:02:21 <BeelsebobWork> they will read do x, then y, then z
02:02:22 <quicksilver> only if they've been mis-taught.
02:02:38 <BeelsebobWork> as I said -- non-haksell-expert -- no mis-teaching involved -- only no teaching
02:02:40 <quicksilver> if they happen to talk to me, I'll tell them it sequences the effects, not the evaluation.
02:02:56 <BeelsebobWork> yes -- and they shouldn't need to have that explained
02:02:59 <BeelsebobWork> thus do is a horrible style
02:03:07 <BeelsebobWork> you shouldn't *need* to explain a program
02:03:14 <BeelsebobWork> it should just read as what it's doing
02:03:17 <BeelsebobWork> (or being)
02:03:17 <quicksilver> such a person might also think that "f x y z" calculates x first, then y, then z, and then passes it them all to f.
02:03:18 <ski_> not even to beginners ?
02:03:26 <sjanssen> bah
02:03:32 <sjanssen> why cater to Haskell illiterates when writing Haskell code?
02:03:57 <BeelsebobWork> quicksilver: the letter "f" has no connotations (except perhaps to mathematitions), the word "do" implies sequentiality
02:04:17 <BeelsebobWork> sjanssen: because code readability is one of the main reasons I love Haskell
02:04:27 <BeelsebobWork> you can make really amazingly readable beautiful code
02:04:33 <Taejo> sjanssen: it depends on the context. I'd rather write Haskell that was comprehensible to others than Java
02:04:35 <quicksilver> I have never heard anyone suggest that "do" implies sequentiality.
02:04:38 <quicksilver> (until now)
02:04:45 <quicksilver> "do" implies action.
02:04:49 <quicksilver> that's all.
02:05:03 <sjanssen> BeelsebobWork: how do you feel about do with the Maybe Monad?
02:05:06 <grom358> can you have where in list comprehension?
02:05:08 <BeelsebobWork> "work on (something) to bring it to completion or to a required state"
02:05:14 <BeelsebobWork> note the bring it to a completion state
02:05:27 <BeelsebobWork> this isn't the behavior that do has in Haskell
02:05:29 <sjanssen> grom358: where only works on declarations, not expressions
02:05:34 <ski_> grom358 : `[ ... | x <- [...] , let y = blah x , ... ]'
02:05:57 <BeelsebobWork> that quote btw is out the OED
02:06:42 <grom358> okay.. just trying to figure out how I can have something like [y | x <- [1..floor(sqrt 28)], b == 0, y <- [x, a] where (a, b) = 28 `divMod` x]
02:06:54 <quicksilver> news at 11, language keywords don't correspond precisely to their dictionary definitions?
02:07:00 <quicksilver> I think your point has become a bit derailed.
02:07:07 <BeelsebobWork> quicksilver: actually, all the other ones do
02:07:09 <quicksilver> Yes, haskell certainly violates the expectations of people who haven't used haskell before.
02:07:25 <quicksilver> we shouldn't waste time pandering to that.
02:07:28 <ski_> (btw, i'd say that `do' (possibly) implies sequentiality, but not necessarily sequentiality at a low operational level .. rather at the "flow" level of values computed by the actions)
02:07:32 <BeelsebobWork> the other reason I hate that word is that Haskell doesn't *do* anything
02:07:39 <BeelsebobWork> a Haskell program *is*
02:07:47 <quicksilver> we should rather invest that time teaching peopel what it does mean
02:07:50 <sjanssen> @quote shemantics
02:07:50 <lambdabot> No quotes match. My brain just exploded
02:07:51 <quicksilver> and writing monad tutorials
02:07:56 <quicksilver> (can never have enough of them)
02:07:59 <BeelsebobWork> ski_: yep, and in a lot of monads that flow-level sequentiality isn't even there
02:08:02 <sjanssen> ski_: yes, I agree
02:08:30 <sjanssen> BeelsebobWork: we've demonstrated that the flow-level sequentiality does exist for list
02:08:30 <BeelsebobWork> quicksilver: I'd rather invest my time in writing code that's non-sequential (even in the implications of how my code is read)
02:08:46 <sjanssen> similarly for Either and to a less extent Maybe
02:08:56 <BeelsebobWork> yep, but not in all monads
02:09:05 <ski_> (BeelsebobWork : .. doing and being are just different point-of-views)
02:09:11 <BeelsebobWork> yes, yes they are
02:09:14 <grom358> ah.. [y | x <- [1 .. floor(sqrt 28)], let (a,b) = 28 `divMod` x, b == 0, y <- [x, a]]
02:09:21 <BeelsebobWork> and I chose Haskell *because* of it's *being* point of view
02:09:38 <SubStack> wow, I think pointless haskell has helped me avoid using odd-sounding pronouns like "one"
02:09:39 <sjanssen> I can't think of many monads where sequence doesn't matter.  Reader is the only one that comes to mind immediately
02:10:01 <SubStack> that always bugs me when people overuse that, sounds like the queen talking
02:10:11 <BeelsebobWork> sjanssen: I can't say I can think of more off the top of my head -- but it's certainly possible to write them
02:10:29 <quicksilver> BeelsebobWork: all I'm saying is wasting time worry about those implications is just that, wasting time.
02:10:34 <ski_> BeelsebobWork : no, it *is* there .. the sequentiality i mean is that in `do x <- a; y <- f x; ...' the `y' *depends* on `x' and therefore on performing the effects in `a' needed to produce `x'
02:10:35 <quicksilver> because those implications aren't really there.
02:10:49 <BeelsebobWork> quicksilver: in my mind, it certainly isn't wasting time
02:10:58 <C-Keen> hm if I want to round a value to an Int, can't I use floor ?
02:11:00 <BeelsebobWork> because the implications *are* there in anyone but the most expert haskell users
02:11:05 <quicksilver> ski_: that's true but that kind of data demand dependency exists in all styles of code
02:11:08 <BeelsebobWork> and there are perfectly good other ways of writing the code
02:11:12 <Taejo> @ty toIntegral
02:11:13 <lambdabot> Not in scope: `toIntegral'
02:11:55 <ski_> quicksilver : hence "effects" .. i suppose i should've added : the effects to produce `y' depends on the effects to produce `x'
02:12:14 <ski_> grom358 : yes, like that
02:12:16 <Taejo> C-Keen: you should be able to (as long as the type you're rounding is a RealFrac)
02:12:17 <C-Keen> Taejo: there is toInteger but it gives me an Integer not an Int
02:12:21 <BeelsebobWork> Taejo: floor/round/ceil/properFraction
02:12:25 <grom358> ski_: thanks
02:12:37 <quicksilver> ski_: yes, the sequencing in do is the sequencing of effects
02:12:46 <quicksilver> ski_: and of course that varies considerably between monads.
02:12:47 <ski_> as you've said
02:12:52 <araujo> hello
02:12:53 <ski_> *nod*
02:12:56 <C-Keen> Taejo: in my code I am using floor $ length $ list/2
02:13:01 <quicksilver> the sequencing is still there in "f <$> x <*> y <*> z"
02:13:06 <quicksilver> ...but it's less obvious.
02:13:18 <Taejo> C-Keen: it's list/2 that's the problem
02:13:22 <ski_> @type (<*>)
02:13:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:13:24 <C-Keen> arr
02:13:31 <Taejo> [a] is not an instance of Fractional
02:13:46 <C-Keen> floor $ (length s)/2
02:13:50 <ski_> quicksilver : well, i'd claim that the absense of `join' makes this a partly different situation
02:13:59 <Taejo> C-Keen: why don't you just use div?
02:14:06 <C-Keen> :t div
02:14:07 <lambdabot> forall a. (Integral a) => a -> a -> a
02:14:18 <Taejo> > 5 `div` 2
02:14:19 <lambdabot>   2
02:14:33 <ski_> > 15 `divMod` 7
02:14:33 <C-Keen> Taejo: bedause I didn't know about it
02:14:34 <lambdabot>   (2,1)
02:14:40 <C-Keen> thanks!
02:14:49 <Taejo> no problem
02:15:18 <BeelsebobWork> quicksilver: yes -- it's the less obvious part that I care about!
02:15:26 <ski_> (BeelsebobWork : also, different POVs are useful for different things)
02:15:32 <BeelsebobWork> I want it less obvious, because it's not part of the behavior of my program that I care about
02:15:38 <BeelsebobWork> and nor should anyone reading it care about it
02:16:02 <BeelsebobWork> ski_: sure -- and there *are* uses for do where I *want* the reader to see the sequentiality
02:16:18 <BeelsebobWork> I don't tend to use them often
02:16:21 <BeelsebobWork> but they exist
02:18:13 <ski_> in the `Applicative' case above, i'd say that there's no inherent sequencing in the sense of sequencing in `do' .. since later actions cannot depend on results of previous actions .. so, i suppose you could call that a "more pure" formulation, if you like
02:18:22 <ski_> (i think conal would agree with that)
02:18:37 <BeelsebobWork> I'd agree with that too
02:20:23 <askentasken> points-free has points, why?
02:20:31 <ski_> not using `(>>=)' (or `join'), (or not over-sequentializing things with arrows) implementations have more room to perform computations in whatever low operational order fits better, so there is a possible efficiency-gain, too
02:21:01 <Taejo> askentasken: "points" refers to the "points" (values) in the "space" of values
02:21:06 <Taejo> it's from topology
02:21:09 <grom358> okay.. I got head . filter (> 5) $ map (length . factors . triangleNum) [1..] . But I want to find out the result of triangleNum when the length of the factors is > 5
02:21:10 <ski_> askentasken : "." is not a point, it is the composition operator .. the points are the values of the datatypes being transformed
02:21:22 <askentasken> does Gödels imcompleteness theorem mean all mathematics would always have to be based on something that cant be proved or that was the case anyway? ie is the search for foundational math an oxymoron?
02:21:44 <askentasken> ski_ aha!
02:21:59 <sjanssen> ski_: results can depend on the implicit results hidden in the applicative functor, however
02:22:06 <Taejo> askentasken: that is the case in any logic
02:22:15 <grom358> ah.. nvm I think I know
02:22:33 <ski_> (of course, in `Applicative' there can still be a sequencing in the sense of some things occuring "to the left" of other things .. and also there's of course the usual dataflow dependencies of the values computed by the actions)
02:23:02 <Taejo> what the incompleteness theorem says is that *no* set of axioms can prove all of arithmetic
02:23:08 <ski_> sjanssen : if you use effectful operations, yea
02:23:50 <ski_> (you could invent a new combinator `sklronk' that behaves just like `join', e.g.)
02:24:38 <grom358> head . filter (\x -> ((> 5) . length . factors) x) $ map triangleNum [1..]
02:24:56 * ski_ hands grom358 a `> '
02:25:37 <BeelsebobWork> ski_: would that go along with rrrrtnk and squilookl?
02:25:50 <ski_> it might
02:25:57 <grom358> gah.. its too slow when I trying to find the first triangle number with over 500 factors
02:26:26 <grom358> I have triangleNum n = foldr (+) 0 [1..n]
02:26:50 <BeelsebobWork> grom358: why foldr? why not sum?
02:27:02 <BeelsebobWork> (or the strict version with foldl1')
02:27:02 <ski_> grom358 : possibly `(== 5) . length . take 5' would be better than `(> 5) . length' in your case ..
02:27:23 <dermiste> clear
02:27:45 <grom358> ski_: I need to find the first triangle number with over five hunderd factors
02:28:28 <BeelsebobWork> > foldl1' (+) [1..500]
02:28:30 <lambdabot>   125250
02:28:42 <Deewiant> > foldr1 (+) [1..500]
02:28:43 <lambdabot>   125250
02:28:56 <Deewiant> > foldr1 (+) [1..500000]
02:28:57 <lambdabot>   * Exception: stack overflow
02:29:00 <Deewiant> > foldl1' (+) [1..500000]
02:29:01 <lambdabot>   125000250000
02:29:02 <BeelsebobWork> > foldl1' (+) [1..500000]
02:29:03 <lambdabot>   125000250000
02:29:37 * skorpan is going to give XMonad.Prompt a shot...
02:29:48 <grom358> I just changed to using sum.. still too slow
02:30:21 <Deewiant> are you compiling it or using GHCi
02:30:46 <grom358> i using runghc .. my python version takes 10 seconds
02:30:54 <Deewiant> runghc doesn't compile it
02:31:05 <Deewiant> use ghc --make -O2 and run the binary
02:31:10 <ski_> > scanl (+) 0 [1..]  -- grom358 ?
02:31:12 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
02:31:14 <BeelsebobWork> grom358: what's the n you're trying to use?
02:31:43 <quicksilver> grom358: if your python version is faster than GHC you've done something very wrong.
02:31:47 <Deewiant> and yeah, scanl would be a lot faster
02:31:54 <quicksilver> (i.e. they're not carrying out the same calculation)
02:31:55 <Deewiant> quicksilver: well, it could be faster than runghc
02:32:31 <Deewiant> I wouldn't be particularly surprised to see python beat GHCi at the same calculation
02:33:14 <grom358> okay.. I just change triangleNumbers = scanl (+) 0 [1..]
02:33:34 <BeelsebobWork> triangleNumbers = scanl (+) 0 [1..] !! n
02:33:51 <grom358> what's the !! n ?
02:33:54 <ski_> error : `n' not in scope
02:33:57 <BeelsebobWork> index the list by n
02:34:00 <ski_> @type (!!)
02:34:01 <lambdabot> forall a. [a] -> Int -> a
02:34:06 <BeelsebobWork> > [1,2,3] !! 0
02:34:08 <lambdabot>   1
02:34:09 <BeelsebobWork> > [1,2,3] !! 1
02:34:10 <ski_> > [0,3..] !! 5
02:34:11 <lambdabot>   2
02:34:12 <lambdabot>   15
02:34:12 <BeelsebobWork> > [1,2,3] !! 93
02:34:13 <lambdabot>   * Exception: Prelude.(!!): index too large
02:34:18 <grom358> but I don't know what n is
02:34:29 <BeelsebobWork> n is the triangleNumber you're trying to compute
02:34:46 <BeelsebobWork> > let triangleNumber n = scanl (+) 0 [1..] !! n in triangleNumber 12
02:34:47 <lambdabot>   78
02:35:22 <grom358> okay I got, head . filter (\x -> ((> 500) . length . factors) x) $ scanl (+) 0 [1..]
02:35:26 <ski_> BeelsebobWork : but that would probably not cache the list, as was intended, yes ?
02:35:35 <BeelsebobWork> oh, fair point, yes
02:36:02 <grom358> and its still taking longer then python when using runghc
02:36:16 <Deewiant> use ghc --make -O2 and run the binary
02:36:20 <BeelsebobWork> grom358: looks sensible enough to me, except that you probably just want filter ((>500) . length . factors)
02:36:20 <ski_> grom358> @src factors
02:36:22 <Deewiant> runghc is not meant to be fast
02:36:24 <BeelsebobWork> (no lambda at all
02:37:07 <grom358> okay: the compiled version takes 2.5 seconds
02:37:12 <BeelsebobWork> > head . filter ((>50) . length . factors) . scanl (+) 0 $ [1..]
02:37:13 <lambdabot>   Not in scope: `factors'
02:37:16 <BeelsebobWork> oh, bah
02:38:15 <ski_> btw, an (imho) cute use of list monad
02:38:16 <ski_>     show (Sudoku rows) = do
02:38:17 <ski_>       row <- rows
02:38:17 <ski_>       (do cell <- row
02:38:17 <ski_>           maybe "." ((:[]) . intToDigit) cell
02:38:19 <ski_>        `mplus`
02:38:22 <ski_>        do "\n")
02:39:09 <BeelsebobWork> show (Sudoku rows) = (fmap . fmap . maybe ".") ((:[]) . intToDigit) rows
02:39:10 <BeelsebobWork> ?
02:39:22 <Deewiant> `mplus` do "\n" instead of just ++ "\n"?
02:39:23 <BeelsebobWork> oh, no
02:39:28 <BeelsebobWork> that doesn't concat it all
02:39:46 <ski_> Deewiant : yes
02:39:57 <Deewiant> why? :-P
02:40:14 <earthy> ski: that would indeed be uglier in list comprehension
02:40:37 <ski_> i was in the mood of using `MonadPlus' (i had other operations which i used both in `Maybe' and in `[]')
02:40:38 * quicksilver thinks 'do "\n"' is a funny way of writing "\n"
02:41:12 <BeelsebobWork> show = unlines . (map . concatMap) (maybe "." ((:[]) . intToDigit)) . unSudoku
02:41:15 <BeelsebobWork> how's that?
02:42:07 <grom358> mmm.. i am still a bit surprised running it with runghc is so slow though when its so quick compiled
02:42:34 <BeelsebobWork> grom358: bear in mind that using -O2 over -O1 is usually two orders of magnitude faster for anything involving lists
02:42:47 <BeelsebobWork> and -O1 is a lot faster than ghci in the first place
02:43:06 <Deewiant> grom358: GHCi/runghc just do blind interpretation, they don't even try to optimize anything
02:43:06 <quicksilver> BeelsebobWork: !1?
02:43:13 <quicksilver> BeelsebobWork: two orders of magnitude? I think not.
02:43:23 <BeelsebobWork> quicksilver: that's my (admittedly anecdotal) experience
02:43:25 <opqdonut> simple strictness analysis spees stuff up quite much
02:43:35 <grom358> Deewiant: ah.. where the python interpreter converts it to bytecode
02:43:39 <quicksilver> -O2 does a bunch of slightly random stuff, some of which is occasionally pessimisation
02:43:41 <opqdonut> and that's what ghc has and ghci hasn't got :)
02:43:47 <quicksilver> -O1 has the key optimisations thouhg
02:43:56 <quicksilver> (fusion, in particular, and strictness analysis)
02:44:08 <Deewiant> grom358: well yeah, python is different, because it's meant as an interpreted language so all the optimizations are in the interpreter
02:44:29 <BeelsebobWork> quicksilver: oh? are they in -O1? I thought they were in -O2
02:44:42 <grom358> well it took me 1minute 48seconds with runghc
02:46:19 <quicksilver> BeelsebobWork: yeah, RULES and strictness are in -O1
02:46:27 <quicksilver> I'm not sure exactly what's held over to -O2
02:46:35 <BeelsebobWork> hmm, okay
02:46:47 <BeelsebobWork> maybe it's -O1 that's really giving me the gain *checks again*
02:46:49 <grom358> omg... problem 13 .. man this is getting hard
02:46:54 * quicksilver has a look to see if the fine manual has an answer
02:47:25 <grom358> oh.. i working on project euler btw
02:47:35 * quicksilver doesn't look like it.
02:47:37 <quicksilver> "At the moment, -O2 is unlikely to produce better code than -O"
02:47:41 <grom358> solving them in python and then haskell
02:47:51 <Deewiant> quicksilver: Wouldn't be the first outdated thing in the manual
02:48:18 <BeelsebobWork> wtf!
02:48:21 <BeelsebobWork> AnygmaMacPro:obj tatd2$ runhaskell Setup configure
02:48:21 <BeelsebobWork> Setup:1:0: lexical error (UTF-8 decoding error)
02:48:33 <BeelsebobWork> that file hasn't changed since I last configured!
02:49:44 <int-e> BeelsebobWork: you're trying to run an executable with runhaskell?
02:49:51 * int-e wonders
02:49:51 <BeelsebobWork> oh >.<
02:50:02 * BeelsebobWork wonders why the executable is there
03:04:40 <askentasken> grom: lol me the same, but im getting better at Haskell. Just hard to picture how to do things in Haskell from the start. feels like in python you can solve problems iteratively but in Haskell you are forced to come up with something good right away
03:05:24 <askentasken> -O1 means it evals strictly everythin? without using the ! in the code
03:05:50 <askentasken> skorpan: you study at chalmers? what discipline? civilingenjör datateknik?
03:07:30 <grom358> what is the function to take the last x elements from a list?
03:08:36 <opqdonut> there are many ways to do it
03:08:45 <grom358> askentasken: yeah.. its definitely a mind bender when you always done it imperative way
03:08:49 <Deewiant> reverse . take x . reverse
03:08:53 <opqdonut> that's the simplest
03:08:58 <Deewiant> or take x . reverse if you don't care about order
03:09:18 <opqdonut> also: drop (length l - x) l
03:09:43 <grom358> yeah.. I don't know the length
03:09:53 <int-e> > length [1..10]
03:09:54 <lambdabot>   10
03:10:04 <Deewiant> good luck knowing which element is the last if you don't know the length ;-)
03:10:07 <opqdonut> you can calculate it :)
03:10:20 <grom358> okay.. this works > reverse . take 10 . reverse . show . sum . map (\x -> x ^ x) $ [1..1000]
03:10:32 <grom358> > reverse . take 10 . reverse . show . sum . map (\x -> x ^ x) $ [1..1000]
03:10:33 <lambdabot>   "9110846700"
03:10:35 <opqdonut> ah, the last digits
03:10:44 <opqdonut> smells like projecteuler :)
03:10:57 <hackage> Uploaded to hackage: pugs-compat 0.0.6
03:10:57 <hackage> Uploaded to hackage: stringtable-atom 0.0.6
03:11:02 <grom358> yeah it is
03:11:45 <int-e> > show . (`mod` 10^10) . sum . map (\x -> x ^x) $ [1..1000]
03:11:46 <lambdabot>   "9110846700"
03:11:51 <gio123> does somebody has a book: JE Hopcroft, R Motwani, JD Ullman, Introduction to automata theory, languages, and computation
03:11:58 <opqdonut> yeh
03:12:07 <opqdonut> not right here though
03:12:41 <grom358> int-e: how you come up with the 10^10 though
03:13:05 <twb> I find it slightly amusing that "cabal configure" fails with "you don't have cabal -any && >= 1.6" after upgrading GHC.
03:13:11 <te> haskell looks way more fun to me than lisp
03:13:18 <twb> And that I can then "cabal install cabal"
03:13:21 <int-e> grom358: because that's what the last 10 digits in base 10 are - the value modulo 10^10. (The last digit is the number modulo 10, the last 2 digits modulo 100, etc.)
03:13:47 <grom358> ah.. right.. ah
03:13:50 <int-e> grom358: you may have to adjust for negative numbers.
03:14:01 <te> ive heard a lot about haskell, even went so far as to install the development tools but never played with it
03:14:03 <int-e> (but your sum is positive)
03:14:11 <te> i started toying with lisp, but god i hate emacs
03:15:05 <gio123> does somebody has a book: JE Hopcroft, R Motwani, JD Ullman, Introduction to automata theory, languages, and computation
03:15:26 <grom358> that is nicer then converting to string
03:15:26 <te> gio123: i do at home
03:16:16 <mapreduce> lisp is good for an untyped language.  emacs is excellent.
03:16:32 <te> mapreduce: i just can't get good at it
03:16:41 <te> there is something about it that seems so wrong to me
03:16:55 <te> i suppose its just my own biases, im sure its very good
03:19:10 <te> anyone wanna sell me on Haskell?
03:19:43 <te> i can read articles all day long, but i'd rather have the pitch come conversationally
03:19:47 <te> ya kno?
03:21:15 <opqdonut> it's just beautiful
03:21:31 <opqdonut> you'll never think about computing the same way after learning it
03:21:51 <opqdonut> plus you'll learn to hate all existing type systems ;)
03:21:59 <quicksilver> te: purity makes you think about modularising your program into sensible functional chunks, which increases code reuse and makes refactoring much easier
03:22:16 <te> sounds kind of like ruby philosophy...
03:22:18 <grom358> thanks everyone for the help.. off to watch the idiot box
03:22:29 <mapreduce> te: More like Scheme's.
03:23:17 <te> anyone play with distributed haskell?
03:32:06 <soa2ii> Hi there. I want to write a new version of the show function for regular expressions.
03:32:08 <soa2ii> http://rafb.net/p/Deimk831.html
03:32:13 <lambdabot> Title: Nopaste - No description
03:32:13 <soa2ii> This is what I've done
03:32:39 <soa2ii> ghci says:
03:32:40 <soa2ii> aufgabe2.1.hs:33:3: parse error on input `='
03:32:40 <soa2ii> Failed, modules loaded: none.
03:32:47 <soa2ii> What is my error?
03:36:15 <profmakx> soa2ii one "=" too much?
03:36:41 <soa2ii> profmakx: Hm... let's see... Haskell is realy weird if you start to learn... :/
03:37:08 <profmakx> well at a first glance these are simple syntax errors
03:37:13 <soa2ii> profmakx: Where?
03:37:21 <Boney> I agree with profmakx
03:37:22 <soa2ii> I can't find my = too muc
03:37:25 <profmakx> remove the = in line 33 36
03:37:34 <profmakx> 39 and 42
03:37:38 <Boney> soa2ii: look at the line above the error.
03:37:54 <soa2ii> Ah there
03:38:00 <soa2ii> one moment.
03:39:25 <soa2ii> Now I got: http://hpaste.org/12124
03:43:31 <Boney> soa2ii: why are you defining show as a function that takes two arguments?
03:43:51 <soa2ii> Boney: My exercises say that.
03:44:23 <soa2ii> I shall call show' with the surrounding function as a parameter so I could say where I have to place brackets.
03:44:29 <Boney> Well, your type signature says that it takes two,  but your definition of show takes only one.
03:45:19 <Boney> nope, wait I'm reading it wrong.
03:45:24 <soa2ii> OK...
03:46:50 <Boney> ah IC what is happening.
03:47:18 <Boney> Normally the type RegExp takes arguments of other types, in this case you're not giving it any.
03:48:15 <soa2ii> Boney: If I'm honest I do not understand exactly what I'm doing. I saw the principle of the solution at an other student and I try to solve it now ...
03:48:22 <Boney> more correctly, a type can be paramatised with other types.  RegExp (the type) can take a parameter (another type).
03:49:28 <PeakerWork> @src RegExp
03:49:28 <lambdabot> Source not found. stty: unknown mode: doofus
03:49:33 <Boney> soa2ii: so what are you asking us for?
03:50:20 <soa2ii> Boney: Well I have to finish my solution in one hour... and I alway get this errors... I do not understand what's wrong :/
03:51:12 <EvilTerran> hehehe
03:51:36 <soa2ii> That's not funny...
03:51:40 <soa2ii> :P
03:52:03 <EvilTerran> one of the lecturers, in introducing his simplified functional language Fun (interpreter written in haskell), has a text-grab from a terminal of someone loading a demo file into the interpreter
03:52:07 <EvilTerran> $ fun fun.fun
03:52:32 <soa2ii> Boney: Can you maybe tell me how I could fix the error? I don't know smth about parameter types...
03:56:51 <askentasken> to update  with cabal i do: cabal update right?
03:57:46 <Boney> soa2ii: I can but I wont.
03:58:26 <Boney> I will tell you that the error is in the RegExp part of the type signature of show'
03:59:00 <Boney> and that the type "RegExp" is too abstract, it requires another argument.
03:59:44 <Boney> Reading about parametric types should help you.  I belive that "A Gentle Introduction to Haskell" has this information.
04:04:45 <twb> They're also in RWH.
04:08:11 <twb> soa2ii: if the code isn't compiling, try writing simpler code until you *can* get it working, then build your way back up.
04:08:37 <soa2ii> twb: I would like if my prof thinks the same way :P
04:09:03 <twb> soa2ii: for example, try just defining show' at the top level
04:09:34 <twb> soa2ii: the try show' against some test values to make sure it does what you expected.
04:11:00 <twb> BTW, what is "Eps" short for?
04:12:09 <profmakx> isnt that one constructor for RegExp?
04:12:23 <twb> Oh, RegExp is a standard type?
04:12:30 <profmakx> no
04:12:35 <profmakx> he defined it
04:12:48 <twb> OK, so soa2ii should know what it is short for :-)
04:12:58 <profmakx> (well, yes there is a haskell RegExp Type but this here is not the one)
04:22:55 <te> la la la, building ghc
04:24:10 <twb> soa2ii: do you still want help?
04:24:54 <soa2ii> twb: Sorry... I just try to get my code a little nicer...
04:25:32 <twb> soa2ii: it's not a problem; we're here to help
04:25:51 <twb> soa2ii: but if you're done I can direct my super-powers elsewhere
04:26:21 <soa2ii> twb: You can (: Thanks.
04:30:43 <jpcooper> is there currently any way in Haskell to write functions of multiple parameters of different types which give the same answer no matter in which order the arguments are given?
04:30:50 <jpcooper> I don't know the correct term for this
04:32:10 <ivanm> jpcooper: if I understand what you're saying, probably not
04:32:16 <ivanm> closest you can get is by using a record
04:32:29 <jpcooper> for instance I might want to define an equivalence function
04:32:38 <jpcooper> which could take arguments in any order
04:32:57 <ivanm> oh, wait, and they're both the same type?
04:33:03 <ivanm> just write your function that way! ;-)
04:33:07 <jpcooper> no, they're not
04:33:20 <wjt> class Equivalentable a where ...
04:33:27 <wjt> instance Equivalentable Foo ...
04:33:30 <wjt> ...
04:33:49 <jpcooper> wjt, I'd like to define equivalence between types
04:33:52 <wjt> equiv :: (Equivalentable a, Equivalentable b) => a -> b -> Bool
04:35:06 <jpcooper> wjt, but I'd have to define the same function in both instances, wouldn't I?
04:36:20 <PeakerWork> @src Equivalentable
04:36:20 <lambdabot> Source not found. Take a stress pill and think things over.
04:36:56 <PeakerWork> what meaningful implementation can that equiv have?  It sounds like it should be: class Equivalentable a b where ...
04:37:49 <jpcooper> PeakerWork, so say I have types a and b, I'd like to define eqv a b without having to define eqv b a as well
04:38:18 <jpcooper> and say I have another relation f x y z, I would not like to have to define f y x z and f z x y and all of the rest
04:38:26 <wjt> PeakerWork: I assumed that jpcooper had a bunch of types that could be converted to some representation which would allow values of different types to be compared
04:38:39 <wjt> but it sounds like jpcooper is after type-level equality?
04:38:53 <PeakerWork> jpcooper: why not force a single order and use just that?
04:39:03 <Boney> jpcooper: what you probably want is a type class that can take two parameters.
04:39:18 <jpcooper> sure that can be done, but I'm wondering if it's possible to define for all orders
04:39:21 <jpcooper> maybe with a certain extension
04:39:25 <Boney> Equivalentable a b => a -> b -> Bool
04:39:28 <jpcooper> if -> whether
04:40:04 <Boney> it doesn't quite solve your problem, but it delegates it to somwhere where it's possibly easier to deal with.
04:40:07 <ivanm> jpcooper: have: data Equiv = ..., class Equivalent a where equivForm :: a -> Equiv, equiv a b = (equivForm a) == (equivForm b)
04:40:46 <jpcooper> okay
04:41:03 <jpcooper> this was just an example. I just wanted to ask whether there was a certain extension that would allow me to do this
04:41:07 <jpcooper> say with more than two arguments
04:41:27 <jpcooper> and maybe what the terminology of this is
04:41:49 <Boney> win 1
04:41:52 <Boney> argh.
04:43:41 <mapreduce> M-! pkill irssi RET M-x erc RET
04:45:57 <jpcooper> does anyone know why multi-parameter type-classes aren't in the specification?
04:46:32 <Botje> they wanted to publish a paper about them :)
04:47:04 <jpcooper> oh I was wondering whether there was some kind of theoretical dispute about them
04:47:19 <SamB> actually, it's because fundeps aren't ;-P
04:55:58 <BeelsebobWork> jpcooper: in which specification?
04:56:47 <quicksilver> haskell98, presumably
04:57:30 <BeelsebobWork> oh, in which case, there was (and still is to a certain extent) a theoretic dispute
04:57:39 <BeelsebobWork> back then it was because fun-deps didn't work entirely properly
04:57:51 <BeelsebobWork> these days it's because no one can make up their mind between fun-deps and asc-types
05:02:13 <EmielRegis> is there a way of assigning specified values to enums, like in C?
05:02:32 <EmielRegis> for example, I have enum with 3 values - INOBJ, MISS, HIT
05:02:40 <EmielRegis> and i want them to have values of -1, 0 and 1
05:02:42 <EmielRegis> is that possible?
05:03:05 <Botje> write from/toEnum
05:03:10 <Botje> ... yourself
05:03:19 <EmielRegis> yes, but I need to assign the values before not?
05:03:57 <EmielRegis> ah
05:03:59 <EmielRegis> i get you now :P
05:04:46 <quicksilver> don't use from/toEnum
05:04:48 <BeelsebobWork> EmielRegis: note though, that actually using said functions is usually not a good plan...
05:04:56 <EmielRegis> i know
05:04:57 <BeelsebobWork> because you can usually come up with much better names for them
05:04:59 <EmielRegis> ill remname them
05:05:00 <quicksilver> instead, just write your own value assignment function
05:05:05 <quicksilver> valueOf INOBJ = -1
05:05:09 <quicksilver> valueOF MISS = 0
05:05:26 <BeelsebobWork> like collisionMultiplier INOBJ = -1 -- or something like this
05:05:33 * quicksilver nods
05:05:44 <BONUS> curious: why not use Enum for that?
05:05:57 <BeelsebobWork> because you get shit function names
05:06:03 <BONUS> ah
05:06:09 <BeelsebobWork> it's another of these things like show, that's designed to not actually be used
05:06:13 <BeelsebobWork> but be there for debugging
05:07:23 <SamB> and here I thought it was here for making bugs
05:08:16 <BeelsebobWork> also BONUS -- it does make bugs -- when you're calling fromEnum (or an equivalent function), you're usually pretty certain what type you're working on
05:08:33 <BeelsebobWork> if you write a type specific version, you'll get type errors, and in a nice place
05:08:42 <BONUS> thats true i guess yeah
05:08:45 <BeelsebobWork> if you use fromEnum, you'll get a type error in an odd place, or worse, no type error
05:09:05 <BONUS> with fromEnum you'll get (Enum a) => ... when you actually mean for your function to work only on one concrete type
05:09:07 <BeelsebobWork> I guess no type error most of the time
05:09:14 <BeelsebobWork> yep
05:10:23 <quicksilver> well, enum is so you can do things like [minBound .. maxBound]
05:10:25 <quicksilver> which is pretty cool.
05:10:47 <jpcooper> BeelsebobWork, what are asc-types?
05:10:50 <jpcooper> associative types?
05:10:52 <quicksilver> but IMO it's an abstraction error to assume particular values in the fromEnum/toEnum part of the instance.
05:11:19 <BeelsebobWork> jpcooper: yep
05:11:27 <BeelsebobWork> quicksilver: indeed, that too
05:11:31 <BeelsebobWork> it's also inflexible
05:11:39 <BeelsebobWork> in that, you may want one set of values in one situation
05:11:42 <BeelsebobWork> and another set in a different one
05:34:19 <dancor> how would you decide that certain types like a -> b and (a -> b) -> a are really not realistic
05:35:31 <opqdonut> by curry-howard
05:36:41 <quicksilver> and, then, by logical semantics.
05:37:47 <dancor> does that mean typeIsReasonable is non-computable?
05:39:12 <opqdonut> dancor: no
05:39:33 <opqdonut> propositional logic is decideable
05:39:47 <EmielRegis> > exp 2
05:39:48 <opqdonut> or rather, tautology in - -
05:39:48 <lambdabot>   7.38905609893065
05:39:50 <EmielRegis> > e^2
05:39:51 <lambdabot>   e * e
05:39:56 <EmielRegis> > e * e
05:39:56 <dancor> :t (const 'x') :: (Char -> Int) -> Char
05:39:58 <lambdabot>   e * e
05:39:58 <lambdabot> (Char -> Int) -> Char
05:40:40 <opqdonut> EmielRegis: e isn't what you think
05:40:54 <EmielRegis> ah
05:41:08 <RayNbow> :t e
05:41:09 <lambdabot> Expr
05:41:12 <dancor> > a - a
05:41:14 <lambdabot>   a - a
05:41:34 <Twey> @check Just n > Nothing
05:41:35 <lambdabot>   "OK, passed 500 tests."
05:41:49 <Twey> @check (Just n :: Maybe Integer) > Nothing
05:41:50 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Expr'
05:41:56 <BeelsebobWork> @check x `mappend` y == mempty
05:41:57 <lambdabot>       No instance for (Monoid Expr)
05:41:57 <lambdabot>        arising from a use of `mappend' at...
05:42:04 <BeelsebobWork> @check \x y -> x `mappend` y == mempty
05:42:05 <lambdabot>   "OK, passed 500 tests."
05:42:07 <Twey> Bah
05:42:10 <quicksilver> @check \n -> (Just n :: Maybe Integer) > Nothing
05:42:11 <lambdabot>   "OK, passed 500 tests."
05:42:12 <Twey> How do I get it to do that?
05:42:16 <quicksilver> ^^ like that.
05:42:16 <Twey> Ah :)
05:42:20 <Twey> Thanks.
05:42:32 <quicksilver> @check \n -> (Just n :: Maybe Integer) < Nothing
05:42:34 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
05:42:50 <gio123> can somebody download for me:
05:42:51 <quicksilver> I'm sure the output of @check didn't used to be wrapped in ""
05:43:06 <gio123> http://portal.acm.org/citation.cfm?id=578597
05:43:09 <lambdabot> Title: Machines, Languages and Computation
05:43:18 <gio123> can somebody download for me: http://portal.acm.org/citation.cfm?id=578597
05:43:22 <lambdabot> Title: Machines, Languages and Computation
05:46:46 <opqdonut> dancor: of course if you have an element of a (thus "a is true") then of course you have an element of (a->b)->a, as the statement is true when a is
05:46:56 <opqdonut> (sorry for the delayed response)
05:47:44 <byorgey> gio123: ask again in a few hours when I'm at school
05:48:46 <opqdonut> gio123: it isn't available as pdf
05:48:58 <opqdonut> from acm, at least
05:50:16 <gio123> opqdonut: how can I found this book? I need pdf :(
05:54:27 <dancor> ok a type is "reasonable" if the corresponding logic statement is a tautolog.
05:54:28 <dancor> y
05:55:03 <PeakerWork> does acm share its profits with the paper writers?
05:55:05 <dancor> and simple types (a, b) get in for free
05:55:53 <askentasken> i find most datastructures in Haskell a real PITA to work with?
05:56:31 <RayNbow> askentasken: why's that?
05:58:50 <dancor> opqdonut: what does [a] curry-howard correspond to?
06:01:13 <twb> dancor: it's a paper
06:01:28 <twb> @wikipedia Curry-Howard isomorphism
06:01:30 <lambdabot> No Result Found.
06:01:37 <twb> Bah.
06:01:42 <opqdonut> dancor: functors like [] correspond to modal logic
06:01:43 <opqdonut> in some way
06:01:45 <opqdonut> google it up
06:02:38 <dancor> @wikipedia curry-howard correspondence
06:02:40 <lambdabot> No Result Found.
06:02:51 <dancor> lambdawat
06:03:02 <ddarius> The Curry-Howard correspondence is, particularly, a relation between the theorems and proofs of Intuitionistic Propositional Logic and the types and terms of the Simply Typed Lambda Calculus.
06:03:14 <ddarius> Last I checked, there is no wikipedia command.
06:03:45 <ddarius> More generally, the Curry-Howard correspondence is the "propositions as types" and similar slogans.
06:04:31 <quicksilver> recursive types like [a] are not entirely straightforward, I think.
06:05:18 <dancor> maybe typeIsReasonable can just consider them different types
06:05:23 <dancor> no, a -> [a] is reasonable
06:05:41 <RayNbow> @djinn a -> [a]
06:05:42 <lambdabot> Error: Undefined type []
06:05:45 <dancor> so maybe [a] can be considered the same as a
06:05:51 <dancor> for reasonability-assessment
06:06:10 <quicksilver> not really, no.
06:06:15 <quicksilver> because [a] -> a is not reasonable.
06:06:16 * dancor likes to assume one thing, realize it's wrong, assume the opposite, and not check
06:06:20 <ddarius> It does so happen that [] does correspond to a modality in a particular modal logic, but that's certainly not something the original (or even most) CH correspondence covers.
06:06:21 <dancor> :t head
06:06:22 <lambdabot> forall a. [a] -> a
06:06:37 <RayNbow> head is only defined for non-null lists
06:06:42 <quicksilver> "The second-order lambda-calculus can be extended by Church-style recursive types in various ways. We discuss and compare several such definitions from the point of view of the Curry-Howard correspondence."
06:06:49 <quicksilver> ". This is possible because recursive types in system F can be seen as propositional level counterparts (via dependency erasing maps) of predicates defined as fixpoints in higher-order logic. "
06:07:02 <quicksilver> that seems to be "not entirely straightforward", as I suggested ;)
06:07:17 <dancor> true.. but i would like to include [a] -> a in my reasonable-types set
06:07:28 <dancor> despite head not being total
06:07:28 <quicksilver> you'd be wrong in doing so.
06:07:39 <dancor> i have practical motivations :)
06:07:40 <quicksilver> you'd be completely throwing away everything at that point.
06:07:45 <Toxaris> how is [a] -> a more reasonable then b -> a?
06:07:46 <quicksilver> you'd have nothing left.
06:07:52 <quicksilver> once you permit bottom, you permit everything.
06:07:58 <ddarius> head [] ::  FlyingMonkeys
06:08:07 <quicksilver> then everythign is reasonable and nothing is limited.
06:08:44 <dancor> you may be right, but i'm not yet convinced there is no interesting middle-ground where [a] -> a is good and a -> b is bad
06:08:55 <RayNbow> ddarius: cool... what are the value constructors of the FlyingMonkeys type? :)
06:09:57 <byorgey> RayNbow: there aren't any, that's the point =)
06:10:23 <dancor> :t head []
06:10:24 <lambdabot> forall a. a
06:11:27 <dancor> well [a] -> Maybe a is def reasonable, and things are getting tough
06:11:39 <dancor> tough as in undecideable-seeming
06:11:48 <quicksilver> yes, [a] -> Maybe a is fine.
06:13:24 <Toxaris> @type (\f b -> f []) :: (forall a . [a] -> a) -> (a -> b) -- bad follows from good, so good is bad, too
06:13:26 <lambdabot> forall a b. (forall a1. [a1] -> a1) -> a -> b
06:14:11 <quicksilver> Toxaris: nice.
06:14:50 <quicksilver> that's a very good proof that that is a bad idea ;)
06:15:46 <dancor> :t let f = g h; f :: a -> a -> b; g = id in h
06:15:47 <lambdabot>     Could not deduce (SimpleReflect.FromExpr b, Show a)
06:15:47 <lambdabot>       from the context ()
06:15:47 <lambdabot>       arising from a use of `h' at <interactive>:1:10
06:15:58 <dancor> why doesn't that work, with h :: a -> a -> b
06:16:04 <Toxaris> Towards Distributed Proof Checking in Live-Long Learning -- The Lambda-Bot Proof Assistant
06:16:22 <earthy> toxaris wins the buzzword award for the day
06:17:42 <Toxaris> dancor: h is not defined in the binding group, so the semi-magic h from the Simple Reflection library is taken
06:17:43 <Toxaris> :t h
06:17:44 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
06:17:58 <dancor> :t let f = g h; f :: a -> a -> b; g = id; h = undefined in h
06:17:59 <lambdabot> forall a. a
06:18:52 <dancor> magic--
06:19:06 <dancor> :t let f = g h; f :: a -> a -> b; g = id; h = h in h
06:19:07 <lambdabot> forall t. t
06:19:58 <Toxaris> :t undefined
06:19:59 <lambdabot> forall a. a
06:20:00 <EmielRegis> if I compile my program with GHC do I need to put a main routine to make it work?
06:20:22 <Toxaris> :t let blubb = bla; bla = unrelated; unrelated = blubb in undefined
06:20:23 <lambdabot> forall a. a
06:20:30 <Toxaris> :t let blubb = bla; bla = unrelated; unrelated = blubb; h = undefined in undefined
06:20:31 <lambdabot> forall a. a
06:20:33 <Toxaris> :t let blubb = bla; bla = unrelated; unrelated = blubb; h = undefined in h
06:20:34 <lambdabot> forall a. a
06:20:38 <Toxaris> dancor: you see?
06:23:46 <mapreduce> @seen cdsmith
06:23:46 <lambdabot> I haven't seen cdsmith.
06:24:20 <BeelsebobWork> which version to people here regard as better style? http://hpaste.org/12125#a1
06:24:30 <BeelsebobWork> (the annotated, or non annotated version)
06:29:05 <quicksilver> BeelsebobWork: well, I don't much like aux1/2/3/
06:29:21 <BeelsebobWork> quicksilver: yeh, aux1/2/3 are another random style pasted by a friend
06:29:29 <BeelsebobWork> I meant between the non-anotation and the annotation
06:29:29 <gio123> can somebody download for me: http://portal.acm.org/citation.cfm?id=578597
06:29:32 <lambdabot> Title: Machines, Languages and Computation
06:29:50 <dancor> well, if you want your code to be readable to noobs, i am one and i think the second/annotated one is easier to read
06:30:10 <dancor> but i understand that is at odds with benefits of conciseness
06:31:38 <BeelsebobWork> yeh, I actually like the second annotation (other than the names)
06:32:23 <quicksilver> let g1 = ... g; let g2 = ... g1; let g3 = .... g2; is crying out for an appropriate fold or state monad.
06:32:43 <EmielRegis> when I run some function with forkIO, how do I get the return type of function?
06:32:53 <BeelsebobWork> yeh, I know quicksilver -- but I can't quite come up with how to make it nice
06:32:57 <ddarius> Beelsebob: Looks like you want a state monad.
06:33:13 <quicksilver> EmielRegis: you have to get the forked thread to stuff it in an MVar.
06:33:43 <EmielRegis> hmm
06:34:10 <ddarius> Beelsebob: All versions of that code are just asking for trouble.
06:34:10 <quicksilver> mv <- newEmptyMVar; (forkIO $ do res <- action; putMVar mv res)
06:34:21 <EmielRegis> ah
06:34:23 <EmielRegis> thank you
06:35:37 <quicksilver> of course if you try to 'take' from that MVar it will block until the forked thread completes
06:35:43 <quicksilver> so don't do that until you want to
06:36:27 <gio123> does somebody has ebook:  Machines, Languages and Computation
06:36:58 <BeelsebobWork> so this is what I've got to now... http://hpaste.org/12125#a3
06:37:01 <BeelsebobWork> any suggestions?
06:37:09 <quicksilver> gio123: it's a real physical book
06:37:17 <quicksilver> gio123: nobody here is going to pirate it for you.
06:38:02 <quicksilver> gio123: either go buy a copy, or have a look at the author's available papers and see if any of the freely downloadable ones contains the information you are interested in.
06:38:08 <bbs> yo guess what
06:38:20 <bbs> linux users all over the world lets celebrate
06:38:26 <bbs> adobe flashplayer 10
06:38:28 <bbs> ;D
06:38:50 <bbs> 64 bits
06:38:52 <EmielRegis> quicksilver, so If i have 2 threads, both can use same var
06:39:02 <EmielRegis> and the value will add?
06:39:57 <quicksilver> no.
06:40:01 <quicksilver> how would it do that?
06:40:12 <quicksilver> if you want the values to combine in a certain way, you do that yourself.
06:46:51 <EmielRegis> quicksilver, could you tell me whats wrong with this code? http://hpaste.org/12131
06:46:55 <EmielRegis> I'd be grateful
06:47:20 <BeelsebobWork> EmielRegis: the error you get would be useful
06:47:24 <ToRA|MSR> you write to mv1 in both lines...
06:47:32 <EmielRegis> ah ye
06:47:36 <EmielRegis> but im getting error on mv1 init
06:47:48 <BeelsebobWork> also, add two spaces on the first line so that things line up and you can see that more obviously
06:47:55 <EmielRegis> couldnt match expected type [t] against inferred type IO MVar a
06:48:06 <EmielRegis> in do expression mv1 < newEmptyMVar
06:48:14 <ToRA|MSR> @type newEmptyMVar
06:48:14 <lambdabot> Not in scope: `newEmptyMVar'
06:48:27 <ToRA|MSR> i assume it's IO (MVar a)
06:48:28 <BeelsebobWork> also, do res <- (renderY 0   299 renderBoundY origin); putMVare mv1 res) is nicer as renderY 0   299 renderBoundY origin >>= putMVar mv1
06:48:40 <ToRA|MSR> and your function has type [[ColourT]]
06:48:52 <ToRA|MSR> [[ColourT]] != IO
06:49:43 <EmielRegis> but it should return (r1++r2), which should be colours
06:50:33 <quicksilver> EmielRegis: yes, but it's all in IO
06:50:40 <quicksilver> so its type is IO [ColourT]
06:50:48 <BeelsebobWork> some code clean up... http://hpaste.org/12131#a1
06:50:50 <quicksilver> it may "return" (r1++r2)
06:50:52 <BeelsebobWork> although probably still errors
06:50:53 <quicksilver> but it returns it, in IO
06:51:09 <BeelsebobWork> oops, missed deleting the last two chars
06:52:18 <EmielRegis> mhm
06:52:25 <EmielRegis> so any ideas I could fix it up?:P
06:52:56 <BeelsebobWork> what does renderY return?
06:53:02 <EmielRegis> s
06:53:07 <EmielRegis> [[ColourT]]
06:53:08 <BeelsebobWork> [[ColourT]]?
06:53:43 <BeelsebobWork> that should do it then... http://hpaste.org/12131#a2
06:54:29 <BeelsebobWork> but... why are you using forkIO if this is a pure computation?
06:54:44 <EmielRegis> uhm, what else should I use?
06:54:47 <geezusfreeek> EmielRegis, another thing you should be aware of: forking those threads won't actually speed anything up. they will just point the references to thunks
06:55:03 <geezusfreeek> EmielRegis, you should look at the `par` function, perhaps
06:55:07 <EmielRegis> i wanted the raytraces to run in parallel...
06:55:51 <BeelsebobWork> EmielRegis: http://hpaste.org/12131#a3
06:55:53 <BeelsebobWork> no IO
06:55:54 <quicksilver> geezusfreeek: well his render functions are apparently in IO
06:55:55 <BeelsebobWork> no forkIO
06:56:02 <geezusfreeek> quicksilver, oh!
06:56:08 <quicksilver> well maybe they're not ;)
06:56:11 <quicksilver> I thought they were.
06:56:16 <BeelsebobWork> quicksilver: he said their type was [[ColourT]]
06:56:23 <EmielRegis> my render function doesnt return IO... it only writes the resulting pixles into ppm, but thats once calculations are done
06:56:25 <quicksilver> geezusfreeek: `par` has no magic benefit over forkIO anyhow.
06:56:38 <BeelsebobWork> quicksilver: other than it doesn't force you into the IO monad
06:56:41 <geezusfreeek> quicksilver, it's pure
06:56:45 <geezusfreeek> right
06:56:47 <quicksilver> geezusfreeek: `par` on two list thunks will only check they're both non-empty
06:56:55 <quicksilver> geezusfreeek: it won't solve the problem you correctly pointed out
06:56:59 <BeelsebobWork> EmielRegis: if renderY happens to be an application of map, then just change map to parMap rnf
06:57:07 <geezusfreeek> quicksilver, yes, i you are right. that was an oops on my part
06:57:12 * quicksilver nods
06:57:22 <EmielRegis> beelsebob, no its recursive
06:57:26 <EmielRegis> anyway thanks ill try that
06:57:42 <BeelsebobWork> EmielRegis: not map renderRow [top..bottom]?
06:57:50 <EmielRegis> no
06:57:58 <EmielRegis> it runs a recursive function that renders all X
06:58:01 <EmielRegis> then goes to next row
06:58:04 <EmielRegis> and does same
06:58:13 <geezusfreeek> strategies or dph would be the way to go i guess
06:58:31 <EmielRegis> and what is rnf?
06:58:32 <BeelsebobWork> EmielRegis: I'd expect this to work... http://hpaste.org/12131#a4
06:58:40 <BeelsebobWork> where renderRow is a function that renders a single row
06:58:49 <EmielRegis> ah
06:58:53 <BeelsebobWork> EmielRegis: ReduceToNormalForm (it's in Control.Parallel)
06:58:56 <geezusfreeek> strategies is really what i meant by `par`. they are probably over a beginner's head though :(
06:59:04 <EmielRegis> so it would run all the lines in  parallel?
06:59:12 <geezusfreeek> in implementation at least
06:59:19 <BeelsebobWork> EmielRegis: parMap will parallelise it, over as many CPUs as you have
06:59:22 <BeelsebobWork> dynamically
06:59:25 <EmielRegis> ah
06:59:26 <EmielRegis> thats nice
06:59:27 <BeelsebobWork> depending on CPU load
07:00:24 <BeelsebobWork> so, yeh, then you need to write the renderRow function -- which should actually be simpler than the renderY function
07:00:30 <BeelsebobWork> because it doesn't have to recurse over your rows
07:00:54 <BeelsebobWork> it's probably a case of map renderPix [0..imageWidth]
07:01:01 <BeelsebobWork> and then renderPix casts a ray
07:03:01 <BeelsebobWork> (if you want to go really insane, then parMap rnf renderPix [0..imageWidth], but that's probably too small a work unit to be efficient
07:03:08 <EmielRegis> hmm
07:03:15 <EmielRegis> im getting error on rnf and parMap
07:03:23 <EmielRegis> even though I imported Control.Parallel
07:03:28 <BeelsebobWork> you need to import Control.Parallel.Strategies iirc
07:03:40 <BeelsebobWork> @hoogle parMap
07:03:41 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
07:03:43 <BeelsebobWork> yep
07:10:06 <sw17ch> I can't use empty data decls with htags :(
07:18:02 <PeakerWork> @src Strategy
07:18:02 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:18:06 <PeakerWork> @hoogle Strategy
07:18:06 <lambdabot> Control.Parallel.Strategies type Strategy a = a -> Done
07:18:06 <lambdabot> package StrategyLib
07:18:15 <PeakerWork> @type Done
07:18:16 <lambdabot> Not in scope: data constructor `Done'
07:18:18 <PeakerWork> @src Done
07:18:18 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:18:21 <EmielRegis> @hoogle makeNFData
07:18:21 <lambdabot> No results found
07:18:29 <EmielRegis> anyone knows how would I use this?
07:18:42 <PeakerWork> I've not used the parallel stuff
07:23:49 <EmielRegis> beelsebob, maybe you could help here? :)
07:27:33 <BeelsebobWork> EmielRegis: what's that?
07:27:43 <BeelsebobWork> oh, no NFData instance?
07:27:46 <EmielRegis> yes
07:27:50 <EmielRegis> for my vector type
07:28:06 <BeelsebobWork> you need to make an instance of NFData, which contains one function -- rnf
07:28:21 <EmielRegis> and what should it do?
07:28:22 <BeelsebobWork> rnf should evaluate an experession to normal form
07:28:52 <BeelsebobWork> if it's a vector type, it's likely to be rnf (Vec x y z) = x `seq` y `seq` z `seq` Vec x y z
07:29:21 <BeelsebobWork> (i.e. return exactly the same thing, but make sure the components get evaluated)
07:29:28 <EmielRegis> ah ok
07:29:30 <EmielRegis> thanks
07:29:32 <BeelsebobWork> np
07:29:36 <quicksilver> or you can cheat and reuse built in rnf instances
07:29:44 <BeelsebobWork> you can do that too, yep
07:29:54 <quicksilver> rnf (Vec x y z) = (x,y,z) `rnf` (Vec x y z)
07:30:00 <quicksilver> or something.
07:30:14 <twanvl> iirc rnf always returns ()
07:30:19 <BeelsebobWork> oh, so it does
07:30:31 <BeelsebobWork> so it's rnf (Vec x y z) = rnf (x,y,z)
07:30:34 <BeelsebobWork> in it's simplest form
07:31:41 <quicksilver> although that probably pays the cost of constructing a pointless 3-tuple
07:31:46 <quicksilver> so it may not be the best way really.
07:31:52 <BeelsebobWork> yeh
07:32:10 <BeelsebobWork> rnf (Vec x y z) x `seq` y `seq` z `seq` () -- may be better
07:32:18 <EmielRegis> do I need to compile with anything special for it to run on 2 processors?
07:32:30 <BeelsebobWork> yes
07:32:33 <BeelsebobWork> -threaded
07:32:44 <BeelsebobWork> and you need to run with +RTS -N<number of system threads to use>
07:32:52 <EmielRegis> and for the program to run normally I need a main function, right?
07:33:23 <BeelsebobWork> you can also use ghci +RTS -N<number of system threads to use> IIRC
07:33:29 <BeelsebobWork> if you want to use ghci still
07:33:36 <BeelsebobWork> but yes, to compile it, you'll need a main function
07:33:40 <EmielRegis> k
07:35:16 <EmielRegis> still runs on one cpu :(
07:35:43 <BeelsebobWork> hmm, that's odd
07:37:10 <EmielRegis> ah
07:37:12 <EmielRegis> works now
07:37:13 <EmielRegis> my fault :P
07:37:17 <EmielRegis> thanks for help
07:37:17 <BeelsebobWork> cool :)
07:37:19 <BeelsebobWork> no probs
07:37:24 <BeelsebobWork> you getting good CPU use now?
07:37:27 <EmielRegis> nah
07:37:31 <EmielRegis> 52% ;/
07:37:36 <EmielRegis> i had 100% in the beginning tho
07:37:46 <BeelsebobWork> that may be the effect of the garbage collector
07:38:01 <BeelsebobWork> try adding -H200M to the +RTS options
07:38:17 <BeelsebobWork> (rather over the top amount, but it'll tell you if that's what's going on)
07:38:25 <EmielRegis> k
07:38:52 <EmielRegis> same
07:38:57 <EmielRegis> but runs 100% longer
07:38:58 <EmielRegis> :p
07:39:28 <BeelsebobWork> okay, compile with -prof -auto-all, and then use -Pa in the runtime options to find out how much time is spent where
07:39:34 <BeelsebobWork> (and see if the GC is holding it up)
07:39:54 <EmielRegis> k
07:39:57 <EmielRegis> my other problem is
07:40:00 <EmielRegis> that the code terminates
07:40:05 <EmielRegis> after 1/4 of pixels is drawn
07:40:07 <EmielRegis> O_o
07:40:23 <BeelsebobWork> that's certainly an odd effect
07:40:31 <BeelsebobWork> does it terminate cleanly?
07:40:34 <EmielRegis> yes
07:40:38 <EmielRegis> it returns render time
07:40:54 <BeelsebobWork> well, time for you to do a little debugging by the sounds of it
07:41:09 <EmielRegis> i probably screwed the render fucntion in some way :p
07:41:13 <EmielRegis> gonan double cehck it
07:42:01 <BeelsebobWork> it should look pretty much like render = parMap rnf renderRow [0..rows]; renderRow y = map (castRay y) [0..cols]; castRay y x = -- your raytracing code goes here
07:47:01 <EmielRegis> where is the profiling info saved?
07:47:32 <BeelsebobWork> in a file called YourProgram.prof
07:55:23 <Raevel_> lt
07:55:30 <Raevel_> oops
07:57:53 <EmielRegis> argh another stupid errors
07:58:46 <EmielRegis> http://hpaste.org/12132
08:00:36 <ToRA|MSR> on a guess: rnf (VecT x y z) = x `seq` y `seq` z `seq` (VecT x y z)
08:00:56 <EmielRegis> that doesnt work either :(
08:00:57 <quicksilver> not `seq` () at the end?
08:00:58 <EmielRegis> same error
08:01:09 <ToRA|MSR> hmm, actually taht's wrong looking at the error
08:01:11 <ToRA|MSR> ignore me
08:01:22 <EmielRegis> same w/o ()
08:02:21 <ToRA|MSR> is that rnf declaration supposed to be part of the instance declaration or standalone?
08:02:29 <EmielRegis> instance declaration
08:02:38 <quicksilver> it shouldn't be Main.rnf
08:02:43 <quicksilver> it should just be rnf
08:02:48 <quicksilver> and it should be indented by at least one space
08:02:50 <EmielRegis> if i use rnf it returns ambigous type
08:03:02 <quicksilver> then fix the ambiguity
08:03:06 <quicksilver> don't change it into rubbish.
08:03:21 <EmielRegis> oh
08:03:24 <EmielRegis> it works with indent
08:03:24 <EmielRegis> lol
08:03:26 <EmielRegis> thanks
08:03:46 <EmielRegis> hm
08:03:47 <EmielRegis> crash
08:03:48 <EmielRegis> ;/
08:23:20 <geezusfreeek> crash?
08:26:28 * Baughn is amused to note that the cryptosystem he implemented as a teen at summer camp, that he was certain probably didn't really work, was in fact blum-goldwasser
08:27:13 <EmielRegis> o rly
08:27:48 <aeolist> does ghc need any flags to parse an .hs that has \begin{code} and such?
08:28:01 <Baughn> aeolist: No, but it needs to be a .lhs
08:28:13 <aeolist> ah, enlightment, thank you
08:29:13 <titto> has anyone tried to use the bloomfilter package with ghc 6.10.1? It seems to compile and install fine but when I try to use it returns an error:   unknown symbol `_jenkins_little2_frag
08:30:22 <dancor> @src cycle
08:30:22 <lambdabot> cycle [] = undefined
08:30:22 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:30:25 <dancor> why not cycle xs = xs ++ cycle xs
08:30:52 <Baughn> dancor: That would create an infinite list
08:31:00 <dancor> they both do..
08:31:08 <Baughn> No, the former creates a circular list
08:31:22 <Saizan_> well denotationally they are the same thing
08:31:46 <Baughn> Denotational semantics aren't very useful on their own, though. :P
08:31:53 <Axman6> titto: oh no, not little jenkins, we've lost hime! :'(
08:31:55 <Axman6> -e
08:32:28 <dancor> but there is no way to distinguish the two results
08:32:33 <Baughn> Sure there
08:32:34 <Baughn> is
08:32:53 <dancor> how
08:32:54 <Baughn> "main = let x = cycle [2] in print x >> print x"
08:33:07 <Baughn> That will eventually crash if it's an infinite list
08:33:07 <sw17ch> Hayoo needs to be updated :(
08:33:14 <sw17ch> All its links point to the wrong place
08:34:21 <dancor> so it is a stack space optimization kind of thing
08:34:34 <Baughn> Heap space optimization
08:34:56 <Baughn> An infinite list will grow to infinite size if you don't discard old elements when reading new ones
08:35:02 <Baughn> A circular list won't
08:35:14 <dancor> that's crazy
08:35:30 <Baughn> Look. It's /circular/.
08:35:36 <Baughn> The last element in the list just points back to its head.
08:36:03 <Baughn> As opposed to pointing to a function that ends up growing the list
08:37:03 <mikezackles> Is there any way to control ghc's memory usage?
08:37:09 <Baughn> mikezackles: Several
08:37:24 <Baughn> mikezackles: Run your programs with +RTS --help to see them all, or..
08:37:36 <Baughn> +RTS -M64m will just limit them to 64 megabytes
08:37:48 <Baughn> Or you can stick the options in the GHCRTS envvar
08:38:03 <mikezackles> Baughn:  Ah, great that should give me a place to start looking.  Thanks.
08:38:14 <Baughn> mikezackles: And if you do mean the compiler itself, ghc is itself a ghc-compiled program. ;)
08:38:51 <mikezackles> Baughn:  Ohh.  I do mean the compiler, but I see what you're saying.
08:39:07 <EmielRegis> seriously
08:39:09 <EmielRegis> thanks guys
08:39:17 <EmielRegis> i reduced my raytrace time from over 600 seconds to 16...
08:39:20 <Axman6> can you use +RTS with ghc itself?
08:39:23 <EmielRegis> using two cores and 'par'....
08:39:25 <EmielRegis> omfg...
08:39:39 <Baughn> Axman6: "mikezackles: And if you do mean the compiler itself, ghc is itself a ghc-compiled program. ;)"
08:39:54 <Axman6> righto :)
08:40:02 <quicksilver> EmielRegis: hmm. If you got a more than 100% speedup then something else happened other than the par ;)
08:40:03 <Axman6> missed that bit
08:40:13 <quicksilver> EmielRegis: probaby the 'rnf' improved cache behaviour, or something.
08:40:27 <Axman6> EmielRegis: yeah, that's not normal
08:40:48 <EmielRegis> ye lol
08:41:00 <EmielRegis> probably parMap is a lot faster than doing a x : xs
08:41:03 <EmielRegis> on my colours
08:41:13 <Baughn> @src seq
08:41:14 <lambdabot> Source not found. Wrong!  You cheating scum!
08:41:15 <Baughn> @src pseq
08:41:16 <lambdabot> Source not found. I feel much better now.
08:43:09 <Beelsebob> EmielRegis: well done
08:43:13 <Beelsebob> glad that you got it working
08:43:17 <Beelsebob> and that it's bloody fast
08:43:30 <EmielRegis> ^^
08:43:42 <EmielRegis> 27 secs on one core, 16 on two
08:43:44 <EmielRegis> not bad
08:43:53 <Beelsebob> how big's the image? 800x600?
08:43:59 <Beelsebob> and how complex is the scene?
08:44:03 <EmielRegis> yes
08:44:13 <EmielRegis> lemme upload
08:44:20 <Baughn> import Codec.Encryption.RSA.NumberTHeory
08:44:48 <Baughn> ..and to add insult to injury, I didn't even get the module name right
08:45:17 <EmielRegis> http://img45.imageshack.us/my.php?image=raytracevh5.jpg
08:45:30 <EmielRegis> note there is some issue with reflections atm
08:45:35 <Beelsebob> not bad though
08:45:41 <Beelsebob> and you need to do a bit of AA
08:45:59 <Stephen|Edibles> Hrm, my hilbert curve doesnt look right
08:46:00 <EmielRegis> i do
08:46:03 <EmielRegis> and soft shadows
08:46:06 <Stephen|Edibles> Whoops, wrong channel guys, sorry
08:46:08 <EmielRegis> and many othe things
08:46:11 <Beelsebob> yep
08:46:12 <EmielRegis> like global illumination
08:46:13 <Beelsebob> but shiny :)
08:46:15 <EmielRegis> :P
08:47:10 <Beelsebob> I wonder why you're getting that mottled pattern though
08:47:21 <Beelsebob> it's a little odd?
08:47:42 <EmielRegis> ye
08:47:48 <EmielRegis> something wrong with reflections
08:47:52 <EmielRegis> looking into that now
08:47:53 <Beelsebob> oh, okay
08:58:21 <EmielRegis> hmm
08:58:35 <EmielRegis> if I have a && statement like this -> a1 && a2 && a3
08:58:48 <EmielRegis> will compiler stop evaluatiing a2 if a1 is false already?
08:58:55 <EmielRegis> or will it go through all and then do and on it?
08:59:41 <Saizan_> the former
08:59:54 <ToRA|MSR> > False && error "hi"
08:59:55 <Saizan_> because of lazy eval and the definition of (&&)
08:59:56 <lambdabot>   False
09:00:20 <endusr> EmielRegis: && means that all evaluations must be equal.
09:00:27 <quicksilver> to amplify: && was deliberately designed to be left-to-right lazy
09:00:27 <Beelsebob> hmm, that's a point
09:00:37 <endusr> It has no reason to evaluate a condition after its previous condition was false.
09:00:41 <Beelsebob> the unamb definition of && doesn't deal with any exception
09:00:46 <EmielRegis> ok
09:00:47 <quicksilver> it of course fails to be right to left lazy
09:00:57 <EmielRegis> thats good
09:01:14 <Beelsebob> > let (-&&-) x y = x && y `unamb` y && x in (error "hi") -&&- False
09:01:15 <lambdabot>   Not in scope: `unamb'
09:01:18 <Beelsebob> oh, fail
09:05:43 <mapreduce> I have a type with a function I'm tempted to call 'map' but that takes an a -> b and a b -> a, so my type doesn't appear to be a monad.  Is there anything else it could be?
09:06:06 <mapreduce> :t map
09:06:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:06:12 <mapreduce> :t fmap
09:06:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:06:58 <mapreduce> (Format f) => (a -> b) -> (b -> a) -> f a -> f b
09:07:06 <mapreduce> or something.
09:08:12 <idnar> mapreduce: what is the (b -> a) function for?
09:09:17 <ToRA|MSR> hpaste.org/12136 - does anyone have an opinion on which of the three design choices they think is good/bad?
09:10:13 <mikezackles> Baughn: Is there a good way to get cabal install to pass the +RTS option to ghc?  I tried -f="+RTS -M128m", but that didn't seem to work.
09:14:00 <Saizan_> mikezackles: -ghc-options=
09:14:52 <mikezackles> Saizan_: Ah, thanks.
09:16:33 <Saizan_> mapreduce: that might be an invariant functor, (meaning both contra- and co- variant)
09:19:49 <dibblego> mapreduce, ExpFunctor
09:19:54 <dibblego> invariant functor
09:20:05 <dibblego> typically called 'xmap'
09:21:28 <mapreduce> idnar: A Format t converts 't's to binary and binary to 't's.  You can make a Format u from it using said function, but that Format u needs to know how to get from binary to 'u's.
09:21:38 <mapreduce> That's what the b -> a (or u -> t) is for.
09:22:21 <quicksilver> a pickling type.
09:22:27 <quicksilver> have you read the paper on pickling, mapreduce ?
09:22:35 <quicksilver> (hmm maybe we had this conversation already)
09:23:04 <mapreduce> I have, but I didn't understand a lot of it, which is a shame, as I'm quite capable of writing code to do this stuff. :)
09:23:34 <quicksilver> ;)
09:23:47 <mapreduce> It's hard to tell what it says that I don't already know, if that makes any sense.
09:24:23 <PeakerWork> can the pickler in the paper describe a format such as Excel CSV?
09:25:09 <mapreduce> I don't think it's limited in any way.
09:25:15 <mapreduce> (neither is mine)
09:25:43 <PeakerWork> mapreduce: where is your pickler?
09:25:56 <mapreduce> dibblego: Is there something I should read other than the Haskell source, for ExpFunctor?
09:26:08 <mapreduce> PeakerWork: Are you able to read Java? ;)
09:26:13 <dibblego> mapreduce, I expect it to be in the category-extras package
09:26:29 <PeakerWork> mapreduce: oh, I was wondering about a Haskell one.  I wrote ones in Python, that's easier because you can "cheat" :)
09:26:33 <dibblego> mapreduce, Functional Java also has a couple of ExpFunctors iirc (grep for xmap)
09:27:02 <mapreduce> dibblego: I meant is there anywhere ExpFunctor is documented?
09:27:25 <dibblego> @google exponential functor
09:27:26 <mapreduce> Anything about it not immediately obvious, etc.
09:27:26 <lambdabot> No Result Found.
09:27:49 <dibblego> it is simply (a -> b) -> (b -> a) -> f a -> f b with identity and compositio
09:28:16 <mapreduce> PeakerWork: The first few examples are.. not ridiculous.  http://github.com/rickyclarkson/binary4j/tree/master/bin4j/Main.java
09:28:18 <lambdabot> Title: bin4j/Main.java at master from rickyclarkson's binary4j â GitHub, http://tinyurl.com/55oqsj
09:28:43 <lilac> newtype Iso a = Iso (a -> a); instance ExpFunctor Iso where xmap f g (Iso h) = Iso (g.h.f)
09:30:30 <Baughn> I'd like to have a christmas tree operator - Unicode U+FFFF - but isn't that actually a control character of some sort?
09:31:33 <lilac> U+FFFE definitely is
09:31:49 <lilac> (it's a byte-order marker)
09:32:00 <Baughn> Mm. That's not a christmas tree, though. ;)
09:32:43 <Baughn> Eh. "U+FFFF is guaranteed not to be a Unicode character at all, ever."
09:32:45 <Baughn> Pity.
09:32:46 <lilac> http://www.fileformat.info/info/unicode/char/ffff/index.htm "not a unicode character"
09:32:52 <lambdabot> Title: U+FFFF
09:33:11 <lilac> anyway, don't you want U+10FFFF?
09:33:12 <quicksilver> you know there is a website at <snowman>.com
09:33:25 <quicksilver> where snowman is the actual unicode snowman.
09:33:28 <quicksilver> I can't paste it here.
09:33:34 <Baughn> I can't load it
09:33:53 <lilac> u+2603?
09:33:59 <Baughn> (My DNS server does not implement unicode addresses, and in fact specifically blocks them)
09:34:25 <lilac> Baughn: http://xn--n3h.com/
09:34:31 <lambdabot> Title: â.com
09:34:36 * quicksilver nods
09:34:53 <quicksilver> hmm.
09:34:55 <quicksilver> it's changed now though.
09:34:59 <quicksilver> used tobe just a big snowman
09:36:39 <wchogg> conal:  I'm having an odd issue at the moment.  The events I get from keyPressed are Reactive.Internal.Reactive.EventG ITime which appears to be different than the EventG ITime that Event is a synonym for, i.e. I can't feed them to accumB or other functions.
09:37:18 <conal> wchogg: hm.  same type, I think.
09:37:37 <wchogg> conal:  But I'm getting a type error when I try.
09:37:56 <conal> wchogg: would you paste the error message?
09:38:13 <Asztal> quicksilver: there's another at http://www.unicodesnowmanforyou.com/, though, in case of emergency. :)
09:38:14 <lambdabot> Title: Unicode Snowman for You
09:38:23 <quicksilver> Asztal: ;)
09:38:28 <Guest21418> whois purple
09:39:51 <Saizan_> ..the question is, why there's a snowman in unicode?
09:40:50 <conal> Saizan_: maybe for Xmas conversation efficiency
09:40:56 <Deewiant> for weather charts
09:40:59 <Deewiant> IIRC
09:41:03 <dancor> NamesList annotations:
09:41:04 <dancor> = snowy weather
09:41:35 <dancor> the glyph is pretty absurd tho
09:41:40 <wchogg> conal:  http://hpaste.org/12137  Maybe I'm misunderstanding something, but that's what it looks like.
09:42:19 <conal> wchogg: looks like version skew
09:42:40 <conal> wchogg: note some types are version/package-annotated
09:43:31 <conal> wchogg: try a clean compile & install of reactive & packages depending on it
09:43:59 <wchogg> conal:  yeah, I had previously tried a cabal update/upgrade before I asked about it...but you're right, I should just try cleaning everything up.
09:48:51 <wchogg> conal:  Reinstalling the packages fixed it.  Sorry for the trouble.  Not sure how things got out of whack.
09:49:13 <conal> wchogg: np.  it's happened to me a few times, so it was easy to recognize.
09:49:37 <conal> wchogg: i don't think there are smarts anywhere in our tools to fix this kind of thing.
09:50:08 <mikezackles> So running cabal install gitit --ghc-options="+RTS -M128m" is giving me the following errors: http://hpaste.org/12138.  It seems like the options are being applied out of order?
09:50:28 <conal> wchogg: and i think there *could be* such smarts, by using FRP to run compilation, packaging, etc.
09:51:14 <ikkebr> is it better to sort first and nub later or to nub first and sort later?
09:51:19 <geezusfreeek> mikezackles, try "+RTS -M128m -RTS"
09:52:14 <mikezackles> geezusfreeek: perfect, seems to be doing the trick.  Thanks!
09:52:20 <Deewiant> ikkebr: nub is slow either way: if you want to sort and nub, do "map head . group . sort"
09:52:21 <geezusfreeek> np
09:53:37 <Baughn> ikkebr: Which may or may not be faster than Data.Set.toList . Data.Set.fromList
09:53:49 <wchogg> conal:  Your program at any time is a Behavior & changes to libraries or modules are events triggering recompilation?  That kind of what you mean?
09:53:51 <Deewiant> s/toList/toAscList/
09:54:00 <Baughn> Oh, right
09:54:01 <ikkebr> Deewiant, Baughn thanks
09:55:13 <conal> wchogg: i mean *all* libraries, source modules, object modules, executables, compilers, input & output data are behaviors.
09:55:21 <dancor> > Set.toList $ Set.fromList "hello"
09:55:22 <lambdabot>   "ehlo"
09:55:49 <Deewiant> toList = toAscList for [Int]Set/Map but I wouldn't rely on it
09:56:11 <conal> wchogg: so yeah, changes trigger compilation, linking, packaging, execution, etc.  but that'd be hidden inside of the implementation of behaviors or reactive values.
09:58:08 <jaj> dancor: that would be a very obscure way to initiate an smtp connection in haskell ;)
10:02:38 <conal> wchogg: to program this sort of thing, i imagine one would just use <$> and <*>.  For instance, 'ghc <*> src', since ghc and src are both dynamic.
10:03:29 <wchogg> conal:  I think I see the idea & it sounds interesting.  Have you started on anything like that, or is it still in the brainstorming phase?
10:05:52 <conal> wchogg: i played just a bit.  there's an immediate problem, which is that the Haskell module language is extremely imperative.  module imports are essentially global mutable variables.
10:06:12 <conal> wchogg: in contrast with ML's more functional style.
10:06:40 <vegai> what's the benefit?
10:09:51 <dancor> jaj: i didn't understand your smtp joke :/
10:10:17 <wchogg> conal:  Is it the kind of thing you can build a functional interface around, or is it a total showstopper?
10:11:35 <conal> wchogg: i think the module language could be redesigned in a functional style.  maybe as a pre-processor.
10:11:50 <geezusfreeek> conal, is your current approach to graphics output basically to have an event of actions or something like that? or is there a more declarative way to do it yet?
10:12:16 <conal> wchogg: i also have a hunch that an elegant solution to recursive modules will fall out.
10:12:32 <conal> geezusfreeek: no actions visible.
10:12:40 <conal> geezusfreeek: it's purely functional.
10:12:40 <jaj> dancor: EHLO is the command to greet a mail server and ask it what features it supports
10:13:01 <geezusfreeek> what module should i look at to see what's going on there?
10:13:46 <conal> graphics is no more imperative than numbers.  both have a purely functional algebra and an imperative means of displaying the result.
10:13:50 <dancor> jaj: oh HELO i see it now in http://james.apache.org/server/rfclist/smtp/rfc0821.txt
10:14:02 <geezusfreeek> conal, i'm not talking about the goal, i just mean right now
10:14:06 <conal> geezusfreeek: you could start with Geometry3.
10:14:16 <geezusfreeek> k, thanks
10:14:17 <conal> geezusfreeek: yeah.  it's purely functional now.
10:14:23 <conal> :)
10:14:52 <jaj> dancor: HELO is the old version
10:15:01 <conal> geezusfreeek: the purely functional "it" in my last comment refers to the programming model.
10:15:16 <dancor> jaj: ah, interesting
10:15:23 <geezusfreeek> oh you are referring to field trip
10:15:24 <dancor> helol
10:15:36 <conal> geezusfreeek: yeah.  were you also?
10:15:41 <geezusfreeek> i thought it was decoupled from reactive?
10:15:50 <conal> geezusfreeek: it is
10:16:00 <geezusfreeek> k, i'll just have to look at how you laid out the interface
10:16:05 <conal> k
10:16:49 <geezusfreeek> conal, my question has to do with the rendering function
10:17:07 <geezusfreeek> is that typically going to be done in an Event Action?
10:17:45 <conal> geezusfreeek: oh.  it'll be a Behavior Action.  the adapter interface takes care of it.  see Adapter.hs in reactive-glut.
10:18:03 * geezusfreeek peeks
10:19:10 <conal> geezusfreeek: i'm calling it "Action" (IO ()), but it's supposed should be restricted to idempotent actions.  I'll make a newtype to emphasize the distinction.
10:20:36 <conal> geezusfreeek: for instance printing isn't idempotent, but repainting a graphics window with a given image is idempotent.
10:21:08 <wchogg> conal:  Speaking of printing & idempotency, did you ever get to look at that rewritten simple chat server example?
10:21:18 <geezusfreeek> ah, that's how you get away with using Behavior
10:21:22 <conal> wchogg: sry.  haven't yet.
10:21:29 <conal> geezusfreeek: exactly!
10:21:47 <geezusfreeek> that is nice
10:21:52 <conal> geezusfreeek: and why the data-driven optimization doesn't cause an abstraction leak.
10:22:10 <geezusfreeek> it's how i was thinking of doing it myself, but i hadn't thought it through all the way
10:22:12 <conal> i'm wondering about a simple & clear name for idempotent actions.  considering "Replacer".  suggestions welcome.
10:23:07 <ddarius> IdempotentAction
10:23:39 <conal> geezusfreeek: the magic is the mkUpdater function in FRP.Reactive.Internal.Timing
10:24:49 <conal> ddarius: that'd make it clear.  am hoping for something shorter.
10:27:12 <wchogg> conal:  'Repeatable'?
10:27:33 <geezusfreeek> conal, perhaps using the word "put" (in homage to HTTP's idempotent PUT method)
10:27:36 <geezusfreeek> ?
10:28:56 <ddarius> geezusfreeek: That's not clear at all.  Also, does the RFC actually require PUT to be implemented idempotently?
10:29:16 <ddarius> In fact, it is almost certainly not idempotent.
10:30:39 <geezusfreeek> ddarius, http://www.ietf.org/internet-drafts/draft-ietf-httpbis-p2-semantics-04.txt (text search that for "idempotent")
10:30:51 <lambdabot> http://tinyurl.com/5wtbyt
10:31:53 <geezusfreeek> ddarius, but you are right that it is perhaps not clear. makes perfect sense to me due to my web background, but not necessarily to others
10:33:19 <geezusfreeek> hmm, that's not actually spec. google failed me
10:33:28 <mr_H> where can i learn about monad reader and monad state ?
10:33:42 <conal> i'm not even sure idempotence gets to the heart of the matter.  in a graphics or UI setting, what seems to be important is that each of these actions completely erases the previous result.
10:34:08 <geezusfreeek> ah, but the relevant text from the link i gave is in the real spec verbatim
10:34:09 <ddarius> geezusfreeek: 8.1.2 seems self-contradictory, but perhaps I'm not understanding the precise definition of sequence.
10:34:29 <conal> so in opengl, one starts by clearing the buffer.
10:34:43 <ddarius> Can you have multiple requests that are not in a sequence?
10:35:30 <geezusfreeek> ddarius, for example, PUT foo, DELETE foo, PUT foo
10:35:36 <conal> so there's more restrictive than idempotence going on.
10:36:19 <geezusfreeek> they mean PUT foo, PUT foo, PUT foo is the same as just PUT foo, but not if you put something else in the middle of it
10:36:40 <geezusfreeek> i think
10:36:42 <geezusfreeek> :)
10:37:32 <mr_H> anyone can point me to a good documentation on monad reader and monad state ?
10:38:45 <wchogg> mr_H:  Have you checked out the old tutorial All About Monads?
10:39:14 <wchogg> http://www.haskell.org/all_about_monads/html/index.html
10:39:15 <lambdabot> Title: All About Monads
10:40:29 <geezusfreeek> conal, you mean that they do not accumulate anything? or is there more to the property you are trying to name than that?
10:40:55 <geezusfreeek> NonaccumulatingAction! rolls right off the tongue
10:41:37 <ddarius> :t toInteger
10:41:38 <lambdabot> forall a. (Integral a) => a -> Integer
10:41:45 <mr_H> thanks wchogg
10:42:02 <idnar> @src toInteger
10:42:02 <lambdabot> Source not found. It can only be attributed to human error.
10:42:17 <conal> geezusfreeek: that's one way to put it.  well -- they can internally accumulate all they want.
10:42:45 <geezusfreeek> conal, i still think idempotence describes it well. if they are the same action then you still get the same end result
10:43:06 <conal> geezusfreeek: yeah.  idempotence is necessary, but i don't think sufficient.
10:43:42 <conal> geezusfreeek: if i sequence two different such actions, the result is equivalent to just doing the latter
10:44:20 <geezusfreeek> @hoogle a -> b -> b
10:44:20 <lambdabot> Control.Parallel par :: a -> b -> b
10:44:20 <lambdabot> Control.Parallel pseq :: a -> b -> b
10:44:20 <lambdabot> Prelude const :: a -> b -> a
10:44:57 <geezusfreeek> no useful works there :(
10:44:59 <geezusfreeek> *words
10:45:57 <geezusfreeek> hmm... i think the important property you are looking for is that some actions can be omitted
10:46:37 <conal> geezusfreeek: yeah.
10:47:36 <geezusfreeek> ForgetableAction? :)
10:48:58 <geezusfreeek> actually, i don't think you want this property in all cases
10:49:08 <conal> oh?
10:49:59 <geezusfreeek> what if i wanted to have an accumulating buffer? a gradual motion blur or something (by using a non opaque color to clear the buffer or something and then drawing on top of it with translucent polygons or something)
10:50:35 <geezusfreeek> or even just not clearing the buffer at all
10:51:32 <wchogg> geezusfreeek:  Wouldn't it be better to keep track of that in your simulation data somehow, rather than rely on the implementation of buffering?
10:51:47 <conal> geezusfreeek: yeah.  i'd like to have a firm semantic basis beneath using such mechanisms.  in other words, to understand what questions these mechanisms are naswering.
10:52:27 <geezusfreeek> well, i certainly wouldn't want to make my simulations rerender past frames to do something i could much more efficiently do this way, no?
10:52:41 <wchogg> geezusfreeek:  Fair enough.
10:52:47 <conal> i do have some vague ideas, in terms of defining how a time-space discrete sampling approximates an ideal time-space continuous function.
10:53:08 <geezusfreeek> it's almost like i want a function (Buffer -> Buffer) instead of just a final value Buffer
10:53:24 <wchogg> Well, so this would be some kind of "integration" over your 'Behavior Buffer', yah?
10:53:38 <geezusfreeek> wchogg, yeah
10:53:39 <conal> yes, integration!
10:54:54 <conal> it'd be great to allow differential/incremental techniques for implementing behavior rendering, with a clear semantic justification.
10:55:04 <geezusfreeek> yes it would
10:55:18 <conal> a paint program is another example.
10:55:37 <conal> continuous smearing of paint
10:55:42 <conal> & erasing ...
10:55:43 <geezusfreeek> exactly
10:56:36 <wchogg> Aww man, now I'm getting tempted to go back to my old analysis books.
10:56:45 <conal> :)
10:57:19 <wchogg> conal:  The problem is that I don't remember just how bare bones we could get in terms of the definition of integration & still have the propeties we'd want for Behavior integration.
10:57:41 <geezusfreeek> conal, i think for accumulating buffers you can't use a Behavior
10:57:46 <p_l> is there any library for working with TUN/TAP interfaces? Or do I have to work it out from scratch?
10:57:58 <geezusfreeek> because you can't skip anything
10:58:06 <geezusfreeek> oh wait, sure you could
10:58:09 * p_l couldn't find anything on hackage
10:58:10 <geezusfreeek> you would just have to dig into it a bit
10:58:27 <conal> geezusfreeek: i think *most* things get skipped when using an accumulation buffer
10:58:36 <conal> geezusfreeek: because only finitely many frames get accumulated
10:59:01 <geezusfreeek> well, consider the paint program again. we don't want to skip drawing steps as a user paints
10:59:09 <mdmkolbe> I've got a build failure on one of my hackage packages.  I think it is due to a missing C library on the build server (libpapi).  Is there someway to ask that library be installed on the build server?  Is there someway my package should specify what C libraries it needs? (I already have "extra-libraries: papi" in the cabal file.)
10:59:12 <geezusfreeek> even if it slows it down
11:00:10 <conal> geezusfreeek: i'm not following.  the user paints continuously, so almost none of the resulting images can be shown.
11:00:22 <conal> (assuming finite frame rate)
11:00:48 <geezusfreeek> yes, but every frame that is skipped is a delta and must be integrated into the next frame that is rendered
11:01:16 <Saizan_> mdmkolbe: i think the mid-term plan is to switch to user-submitted build reports, so the server doesn't need to have everything installed and there's more coverage
11:01:16 <conal> geezusfreeek: oh.  i guess you're liking the integration rate with the display rate.
11:01:29 <conal> geezusfreeek: while i'd keep them independent.
11:01:42 <geezusfreeek> i'm thinking about what you would do in the presence of variable frame rate
11:02:10 <conal> geezusfreeek: whether fixed or variable, i'd separate out integration from display
11:02:29 <conal> moreover, the user input is continuous as well.
11:02:51 <geezusfreeek> consider a behavior that has action1, action2, and action3... action2 depends on action1 to render properly, and action3 relies on both of the others
11:02:57 <conal> so we can only capture an approximation of it.  still -- not about output rate.
11:03:24 <conal> geezusfreeek: if you phrase the problem that way, the solution space will be small.
11:04:06 <PeakerWork> conal: Instead of a (Behavior Image), you could have the  sink  take an (Event DrawingDiffs)
11:04:22 <geezusfreeek> yeah, PeakerWork's way is what i'm seeing
11:04:57 <conal> i wouldn't say "instead of"
11:05:08 <conal> that event *does* define a behavior.
11:05:30 <conal> the trick is to exploit cumulative behavior definition while rendering.
11:05:33 <wchogg> w00t.  The my reactive tetris is essentially done.
11:05:35 <PeakerWork> conal: It lets the sink get a (Behavior Image) via accumB if it wants
11:05:42 <PeakerWork> conal: but it also has the DrawingDiffs directly
11:05:46 <conal> however, the drawing diffs would be continuous as well, i.e., integration.
11:05:58 <mdmkolbe> Saizan_: ok, thx for the intel
11:06:11 <PeakerWork> conal: if the sink forces you to create an (Event Diff) then you're forced to generate efficient differential draws
11:06:15 <conal> PeakerWork: i think there's good idea in there.  but it's not yet composable.
11:06:39 <PeakerWork> conal: I smell a multi-param typeclass that connects delta types to their types
11:07:04 <wchogg> PeakerWork:  Type families would be better, no?
11:07:10 <conal> PeakerWork: try out the idea.  see if you can get it to be cvty composable.
11:07:13 <PeakerWork> Maybe, I don't know enough about associated types/type families
11:07:18 <conal> *conveniently
11:07:25 <conal> (emacs abbrev-o)
11:07:39 <conal> wchogg: awesome!
11:08:04 <PeakerWork> conal: fmap of pure functions becomes pretty useless, but if you have a whole family of diff-based functions, you can fmap those composably, possibly
11:08:51 <Baughn> "last (take iterations (iterate reverseIt lastState) `using` seqList rnf)" <-- Is there a better way to write this?
11:09:25 <conal> PeakerWork: yeah.  i'm interested in incremental/differential approaches.  i haven't been able to see it through in general, while keeping the semantics and interface super simple.
11:09:45 <conal> PeakerWork: in other words to have the incremental/differential trickery hidden in the FRP implementation.
11:10:25 <PeakerWork> conal: I am pretty confident that the right way to abstract it will develop from the patterns in the "ugly" non-abstract code, and not from pure thought about it
11:10:29 <conal> i don't know how to define fmap, let alone (<*>) on differential representations.
11:10:50 <PeakerWork> conal: you can use fmap someDiffManipulator on the diff sources
11:10:54 <conal> PeakerWork: i do both.
11:10:57 <hackage> Uploaded to hackage: delicious 0.3.2
11:11:03 <wchogg> conal:  fmap => chain rule?
11:11:06 <psnively> Freetings.
11:11:16 <conal> PeakerWork: would it be a functor morphism?
11:11:30 <conal> PeakerWork: i.e., would the semantics of fmap be fmap?
11:11:49 <conal> wchogg: hm.  maybe.
11:11:51 <PeakerWork> conal: Sure,  (ImageDiff -> ImageDiff) -> Event ImageDiff -> Event ImageDiff,  for example
11:12:15 <conal> PeakerWork: no.  i mean a differential representation of behaviors.
11:12:36 <conal> not a differential representation of differences ;)
11:12:48 <PeakerWork> conal: I am not sure being differential on continuous behaviors is that useful, I think its probably useful to be differential on discretely changing values
11:13:01 <PeakerWork> unless I'm misunderstanding you
11:13:39 <conal> PeakerWork: continuous/discrete is not the issue i'm trying to get at.  let's take lists as a simple, familiar example.
11:14:05 <conal> imagine a data type whose *semantics* is a sequence of values, but whose representation is a sequence of differences.
11:14:38 <conal> then ask: how can you implement fmap on this type, so that the meaning of fmap is fmap on the meaning.
11:14:52 <conal> if that property fails, the abstraction leaks.
11:14:57 <solrize> @seen sjansson
11:14:57 <lambdabot> I haven't seen sjansson.
11:15:03 <solrize> @seen sjanssen
11:15:03 <lambdabot> sjanssen is in #haskell-blah, #xmonad and #haskell. I last heard sjanssen speak 8h 53m 2s ago.
11:15:12 <PeakerWork> conal: I see. Why not use accumR on the sequence of differences before using it as a sequence of values?
11:15:38 <PeakerWork> conal: IOW, why not expose differing primitives to work with differential stuff
11:16:10 <conal> PeakerWork: because i want to keep the conceptual model simple for the programmer.
11:18:01 <conal> these issues are only efficiency issues.
11:18:11 <conal> so i don't want them complicating the programming model.
11:18:27 <PeakerWork> I think they also have some UI consequences (animate the difference, don't quirk it, for example)
11:19:05 <PeakerWork> But I agree, its less important
11:19:17 <conal> PeakerWork: "quirk"?
11:19:30 <PeakerWork> conal: disorienting redraw with completely different data
11:19:42 <PeakerWork> conal: without a "smooth" change from one to the next, making it clear what changed and how
11:19:55 <PeakerWork> conal: Something I think is very important in UI's, and only Apple and few others have realized
11:20:07 <geezusfreeek> it's just a matter of how you envision "animation." is it a sequence of changes or is it a snapshot of something continuous? i think which one is simpler depends on the particular application
11:20:13 <conal> PeakerWork: i'd hope that issue could be addressed consistently with semantics.
11:21:03 <PeakerWork> conal: I think if you have a rich set of (diff->diff) functions, then its pretty simple/straightforward to work with diffs, as if they were values. Consider your list example, I'd have a Differential (!!) called dGetItem that I'd fmap on the diff event source
11:21:05 <conal> geezusfreeek: don't you think one has a simpler semantic model, independent of application?
11:21:27 <PeakerWork> conal: the question is what combinators to create so you can build (diff->diff') functions easily
11:21:32 <ikkebr> what's the biggest integer I can get with haskell withouth overflowing?
11:21:38 <geezusfreeek> conal, only if one can be intuitively described in terms of the other
11:21:45 <mauke> ikkebr: how much RAM do you have?
11:21:46 <conal> PeakerWork: try it.  specifically.  try fmap on a differential representation of lists.
11:21:51 <PeakerWork> ikkebr: Integer has no upper bound.  Int has.  Any type that has a bound you can get with "maxBound"
11:22:18 <PeakerWork> conal: is it ok to only allow "fmap" with differential functions (such as dGetItem rather than (!!))?
11:22:49 <conal> PeakerWork: what's a "differential function"?
11:23:06 <PeakerWork> One that is not a->b, but aDiff -> bDiff
11:23:20 <conal> PeakerWork: the type of fmap is a given.
11:23:24 <conal> @type fmap
11:23:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:24:08 <PeakerWork> conal: Yeah, but if you're stuck in a diff category, all fmap's will remain in that category, so your "a" will always be a diff type, and all functions on diff types result in diff types (except maybe one function diff -> a -> a)
11:24:15 <conal> PeakerWork: and then after fmap comes (<*>)
11:24:23 <PeakerWork> conal: no way I can get <*> to work ;)
11:24:40 <PeakerWork> I think
11:24:44 <conal> PeakerWork: the differential lists would be parameterized over *arbitrary* types.
11:25:31 <PeakerWork> conal: well, my diff would probably be agnostic to the elements, and would just use insertion/deletion/etc
11:26:01 <geezusfreeek> how does fmap over (DiffList a) differ from fmap over ([Diff a]). i think that seems to be one of the points of dispute, from my point of view
11:26:02 <PeakerWork> my diff stuff might be an Arrow-without-arr, but I don't think it is Applicative
11:26:08 <conal> PeakerWork: please give it a try. i think you'll see right away what i'm getting at.
11:26:36 <conal> geezusfreeek: the *semantics* of the representation is what i'm getting at.
11:26:49 <geezusfreeek> conal, right. [Diff a] has clear semantics though
11:26:54 <geezusfreeek> DiffList a does not
11:27:10 <PeakerWork> conal: I am wondering if you agree with me that it is a reasonable Functor instance even if you are stuck in the Diff category, so all fmaps convert diffs to diffs, and you can never use functions that are not upon diffs
11:27:10 <conal> geezusfreeek: which semantics do you have in mind for [Diff a]?
11:27:34 <conal> PeakerWork: the functions being fmap'd are *not* on diffs.
11:27:36 <geezusfreeek> conal, my point is that the unwrapped version is clear, but a wrapped version is not
11:28:01 <conal> geezusfreeek: honestly, i don't know which interpretation you mean.
11:28:08 <geezusfreeek> you can fmap over a [Diff a] just fine because you can only use a function (Diff a -> Diff b) anyway
11:28:23 <conal> geezusfreeek: oh -- a literal interpretation then.
11:28:27 <geezusfreeek> but over a DiffList a, you have to be able to accept functions of type (a -> b)
11:28:47 <conal> geezusfreeek: i was talking about a differential *representation* of lists
11:29:03 <geezusfreeek> conal, right, and i think PeakerWork is not
11:29:05 <conal> geezusfreeek: where the semantic function would do the accumulation.
11:29:19 <conal> geezusfreeek: maybe so.
11:31:58 <conal> geezusfreeek: thx for helping sort out the confusion.
11:32:38 <geezusfreeek> that is also why i mentioned Event Action as a possible way to do accumulating actions. i meant using it with no wrapper or special semantics
11:33:17 <conal> geezusfreeek: yeah.  and as with difference lists, one could use fmap, but what would it *mean*?
11:33:42 <conal> in other words, would it mean anything useful?  ditto for (<*>).
11:34:05 <conal> ditto for mappend/(++)
11:34:28 <geezusfreeek> > foldl (+) 0 [1,2,3,4,5]
11:34:29 <lambdabot>   15
11:34:39 <geezusfreeek> > foldl (+) 0 $ map (*0.5) [1,2,3,4,5]
11:34:40 <conal> i'd love to figure it out!
11:34:40 <lambdabot>   7.5
11:34:59 <geezusfreeek> actually i think i really wanted to accum that :P
11:35:08 <conal> probably
11:35:22 <conal> scanl or scanr
11:35:34 <wchogg> Okay, I'm trying to get caught up on the conversation:  so we're talking about whether taking the 'derivative' of Behavior should be a functor?
11:37:09 <conal> wchogg: i don't think so.  for me, it's whether we can use a differential *representation* ("deltas" in some sense) of behaviors, and still have behavior be a functor & applicative.
11:37:29 <conal> without losing the benefit of the differential representation.
11:38:06 <conal> in other words, without making all of the differences be const functions.
11:39:36 <conal> hm.  i suspect i use "in other words" more often than i would if it weren't bound to an emacs abbrev.
11:40:05 * conal wonders if emacs abbrevs stunt his verbal diversity.
11:42:28 <newsham> conal: your blog continues to blow my mind.  tyvm.
11:42:54 <conal> newsham: yay!!  :)
11:53:57 <Lemmih> dcoutts: I really wish we could use something else than plain-text passwords. It makes mirroring more or less impossible.
11:55:56 <solrize> lemmih, wrong window ?
11:56:46 <Lemmih> solrize: Right window. The conversation is a couple of days old, though.
12:00:33 <FunctorSalad> anyone else suspects that @pl would be clearer with tuples and &&& rather than nested (.) and flip? ;)
12:01:05 <FunctorSalad> at least when granted decurried functions
12:01:24 <vixey> FunctorSalad, I don't think anybody is going to implement that
12:01:25 <lambdabot> vixey: You have 1 new message. '/msg lambdabot @messages' to read it.
12:01:30 <vixey> @messages
12:01:30 <lambdabot> mmorrow said 16h 1m 58s ago: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=492
12:01:45 <FunctorSalad> vixey: are you daring me? ;))
12:01:48 <vixey> yep :p
12:06:53 <Baughn> ..this is the worst kind of bug. The kind that goes away when you inspect the code and decide that, actually, it should have worked all along.
12:07:21 <ikkebr> in a list comprehension, any way to append 2 elements to the list, instead of only one?
12:07:40 <Baughn> No. Use functions like concatMap instead
12:07:46 <mauke> ikkebr: yes
12:07:51 <mauke> use more <-
12:08:01 <vixey> hehe
12:08:09 <vixey> @heisenbug
12:08:09 <lambdabot> Unknown command, try @list
12:08:40 <mauke> > [ x | x <- [1 .. 4] ]
12:08:41 <lambdabot>   [1,2,3,4]
12:08:51 <mauke> > [ x' | x <- [1 .. 4], x' <- replicate x x ]
12:08:52 <lambdabot>   [1,2,2,3,3,3,4,4,4,4]
12:09:20 * Baughn groans. Of course, there /would/ be a way to do it with LOOP.
12:09:20 <Deewiant> Baughn: no, the worse kind is when you notice that the code never could have possibly worked, at which point it instantaneously stops working for everyone, everywhere.
12:09:25 <trofi> , [(x,y) | x <- [1,2,3] | y<- [4,5,6] ]
12:09:26 * FunctorSalad has avoided list comp's til now for some reason
12:09:31 <lunabot>  [(1,4),(2,5),(3,6)]
12:09:34 <trofi> :p
12:10:01 <Baughn> Deewiant: I think the code is in league with the teacher, actually. It started working only once I actually understood the chinese remainder theorem, as opposed to just /using/ it
12:10:07 <ikkebr> i'm currently doing: [a | ((a,b),c)<-k ]++[b| ((a,b),c)<-k]
12:10:24 <Deewiant> Baughn: heh.
12:10:53 <mauke> :t unzip
12:10:53 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
12:10:57 <hackage> Uploaded to hackage: CheatSheet 1.5
12:11:02 <dons> shapr: sti.co.gatech.edu
12:11:13 <mauke> :t uncurry (++) . unzip . map fst
12:11:14 <lambdabot> forall b b1. [((b, b), b1)] -> [b]
12:11:53 <FunctorSalad> @type merge
12:11:54 <lambdabot> Not in scope: `merge'
12:12:06 <mauke> > uncurry (++) . unzip . map fst $ [((a,b),c), ((a,b),c), ((a,b),c)]
12:12:07 <lambdabot>   [a,a,a,b,b,b]
12:12:16 <dons> shapr, 28x cell processor, fill in a form to get access.
12:14:17 <FunctorSalad> so lambdabot is written in brainfuck? (cabal install lambdabot downloads that) ;)
12:14:30 <trofi> @bf ++,
12:14:30 <lambdabot>   fd:5: hClose: resource vanished (Broken pipe)
12:14:38 <gwern> FunctorSalad: yes. we're pondering a rewrite of lambdabot in haskell
12:14:43 <FunctorSalad> hehe
12:14:50 <gwern> FunctorSalad: but we're unsure haskell can do I/O like we'd need it to
12:14:59 <gwern> brainfuck of course has no such problems
12:15:02 <mauke> and arrays!
12:15:08 <mauke> a 30000 cell array
12:15:23 <gwern> oh of course. really, compared to brainfuck haskell is something of an obscure toy language
12:15:48 <trofi> :]
12:16:09 * trofi 've seen bf 2 .net "compiler"
12:16:41 <mauke> I have a brainfuck->x86 asm compiler
12:16:42 <trofi> so there's yet clear benefits
12:17:38 <monadwr> mauke: Interesting.
12:17:47 <vixey> is it online ?
12:17:49 <monadwr> You're so full of code.
12:17:57 <vixey> I want to read it .
12:17:57 <tibbe> slightly OT: anyone got the simple indent mode working for emacs?
12:18:14 <mauke> http://mauke.ath.cx/stuff/perl/bfc.pl
12:18:29 <monadwr> tibbe: You may want to ask #Emacs.
12:18:36 <monadwr> mauke: You wrote this compiler?
12:18:40 <mauke> monadwr: yes
12:18:44 <tibbe> monadwr: I was referring to the Haskell mode
12:19:09 <monadwr> mauke: My statement "You're so full of code", stands.
12:19:14 <FunctorSalad> lambdabot fails to build on 6.10? or is it just me
12:19:25 <FunctorSalad> (actually, mueval fails because hint fails)
12:20:01 <trofi> same for me :]
12:20:13 <monadwr> mauke: I'll take a look, even though I don't code in perl; It may be something I want to begin looking into, eventually.
12:29:40 <Badger> @src uncurry
12:29:40 <lambdabot> uncurry f p = f (fst p) (snd p)
12:29:58 <pumpkin> what's the point of that?
12:30:08 <Badger> ?
12:30:23 <pumpkin> > uncurry (^2) (5, 4)
12:30:23 <lambdabot>       No instance for (Num (b -> c))
12:30:23 <lambdabot>        arising from a use of `^' at <int...
12:30:25 <newsham> uncurry (+) (3,5)
12:30:27 <pumpkin> > uncurry (^) (5, 4)
12:30:28 <lambdabot>   625
12:30:31 <pumpkin> yeah
12:30:36 <mauke> automated tuple unwrapping
12:30:40 <pumpkin> was just wondering when that would be needed
12:30:50 <mauke> so you don't have to pattern match manually
12:31:00 <geezusfreeek> pumpkin, consider for example what you have after you zip a couple lists
12:31:09 <geezusfreeek> > zip [1..] ['a'..]
12:31:11 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'),(9,'i'),(1...
12:31:18 <geezusfreeek> what do you do if you want to then fmap over it?
12:31:25 <newsham> sometimes you want all your args at once
12:31:26 <pumpkin> yeah, I was thinking that, but can't you just do zipWith?
12:31:28 <geezusfreeek> you either have to pattern match or use uncurry
12:31:30 <newsham> sometimes you want them one at a time
12:31:31 <mauke> use zipWith in the first place :-)
12:31:41 <Badger> @src unzip
12:31:41 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
12:31:46 <mauke> @src zipWith
12:31:46 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:31:46 <lambdabot> zipWith _ _      _      = []
12:31:47 <geezusfreeek> @src zipWith
12:31:47 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:31:47 <lambdabot> zipWith _ _      _      = []
12:31:50 <mauke> tee hee
12:31:52 <geezusfreeek> @src zip
12:31:52 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
12:31:52 <lambdabot> zip _      _      = []
12:31:56 <geezusfreeek> bleh
12:32:13 <geezusfreeek> anyway, what if you don't want to do that right then?
12:32:17 <geezusfreeek> plenty of cases
12:32:20 <mauke> zip = zipWith (,); zipWith f = map (uncurry f) . zip
12:32:22 <newsham> another example would be when you're doing a bunch of arrow stuff
12:32:28 <PeakerWork> > let zipWith f = map (uncurry f) . zip in zipWith (+) [1,2,3] [4,5,6]
12:32:28 <newsham> you end up with a bunch of tupled up data
12:32:29 <lambdabot>   Couldn't match expected type `[(a, b)]'
12:32:40 <PeakerWork> @type uncurry
12:32:41 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:33:01 <PeakerWork> > let zipWith f = (map (uncurry f).) . zip in zipWith (+) [1,2,3] [4,5,6]
12:33:02 <lambdabot>   [5,7,9]
12:33:10 <mauke> my emperor!
12:33:17 <newsham> > uncurry (+) . ((*2) &&& (+10)) $ 5
12:33:18 <lambdabot>   25
12:33:37 <PeakerWork> > [1,2,3] &&& [4,5,6]
12:33:38 <lambdabot>   Couldn't match expected type `a b c' against inferred type `[a1]'
12:33:44 <mauke> uncurry is really just a tuple catamorphism
12:33:56 <PeakerWork> mauke: if' is really just a boolean catamorphism
12:34:10 <Badger> :t &&&
12:34:11 <lambdabot> parse error on input `&&&'
12:34:16 <Badger> heh
12:34:16 <trofi> ()
12:34:27 <Badger> :t (&&&)
12:34:28 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:34:48 <Badger> erp.
12:34:52 <PeakerWork> the Lambda calculus "data structures" are mostly the catamorphisms
12:34:57 <PeakerWork> (afaik)
12:35:21 <mauke> the nonrecursive variant
12:35:26 <vixey> I wonder if we can make that statement precice
12:35:32 <vixey> precise
12:35:57 <PeakerWork> mauke: why?  Isn't the definition of naturals really just the recursive catamorphism of the natural fold?
12:36:04 <PeakerWork> the recursive natural fold, that is?
12:36:07 <mauke> oops, right
12:36:18 <vixey> data Bool = True | False & bool true false True = true ; bool true false False = false  ~~> true = \t f -> t, false = \t f -> f
12:37:05 <vixey> so each constructor is turned into the cata applied with that construtor (in the case where types don't hold anything)
12:37:37 <vixey> for data N = Z | S N, and data H = Lam (H -> H), ...
12:37:43 <vixey> what do you do?
12:39:22 <vixey> does this encoding work for any type what-so-ever or just a subset
12:39:22 <vixey> ?
12:39:49 <newsham> there's a paper on implementing haskell data types as lambda expressions with mapping rules
12:39:59 <BMeph> vixey: How come you define Nat as Z | S Nat, but insist on defining Bool as True | False (instead of False | True)? ;)
12:40:01 <PeakerWork> vixey: the N = Z | S N   you do the normal LC naturals, what do you mean?
12:40:43 <newsham> http://www.cs.nott.ac.uk/~nhn/TFP2006/Papers/03-JansenKoopmanPlasmeijer-EfficientInterpretation.pdf
12:40:47 <lambdabot> Title: Efficient Interpretation by Transforming Data Types and Patterns to Functions, http://tinyurl.com/2drus8
12:40:53 <newsham> (using the untyped lambda calc)
12:41:08 <vixey> BMeph, I'm not sure actually, It seems to bug everybody that I put True first though :)
12:41:16 <vixey> I don't hink there's a specific reason
12:41:26 <mauke> vixey: breaks deriving Enum
12:41:40 <aeolist> guys, does haskell have multiple matching in pattern matches like ocaml does?
12:41:44 <mauke> data Boolean = True | False | FileNotFound deriving (Read, Show, Eq, Ord, Enum, Bounded)
12:41:48 <mauke> aeolist: no
12:41:52 <vixey> my argument is that deriving enum for Bool is already broken
12:41:56 <aeolist> mauke: why not?
12:41:59 <aeolist> it was handy!
12:42:01 <joelr1> good day
12:42:12 <vixey> aeolist, what multiple matching? the | patterns?
12:42:16 <aeolist> yeah
12:42:22 <vixey> @let dup = join (,)
12:42:24 <lambdabot>  Defined.
12:42:25 <aeolist> http://haskell.org/tutorial/patterns.html#sect4.2 here you would only right the second []
12:42:26 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
12:42:34 <aeolist> in the take function...
12:42:36 <newsham> aeo:  like   f ((Foo x y):z:[]) (Bar a b)  = ...   ?
12:42:42 <vixey> > let f (dup -> (Just x, y)) = (x,y) in f (Just True)
12:42:43 <lambdabot>   <no location info>: parse error on input `->'
12:42:49 <dolio> newsham: That paper encodes constructors as the non-recursive catamorphism of the constructor, though.
12:42:54 <vixey> , let dup = join (,) ; f (dup -> (Just x, y)) = (x,y) in f (Just True)
12:42:56 <lunabot>  (True,Just True)
12:43:04 <vixey> , let dup = join (,) ; (||) = (,) ; f (dup -> (Just x || y)) = (x,y) in f (Just True)
12:43:06 <lunabot>  luna: Parse error in pattern
12:43:09 <vixey> oh well
12:43:11 <vixey> you could define
12:43:20 <vixey> data DisjunctivePattern a = a :| a
12:43:22 <mauke> newsham: use several patterns for the same branch of code (requires the patterns to bind the same variables)
12:43:23 <newsham> dolio: by that you mean that the mapping for lists doesnt encode the notion of recursion?
12:43:30 <aeolist> newsham: when 2 patterns same the same function body, you only have to write that function body once
12:43:42 <vixey> aeolist, (I just showed you how to implement it in haskell)
12:43:43 <vixey> :)
12:43:47 <newsham> dolio: isnt that necessary to implement the non-terminating possibilities in haskell?
12:43:56 <aeolist> ocaml has "match expression with | a | b | c | -> action | d -> other action etc
12:44:03 <newsham> ahh
12:44:05 <aeolist> ah
12:44:08 <aeolist> ty vixey
12:44:14 <aeolist> mmm purty
12:44:32 <vixey> aeolist, you could  make a typeclass that splits more than once for case like a | b | c
12:44:51 <vixey> I gues you could also write it as a quasiquote
12:45:36 <aeolist> you are scaring me... quasiquote?
12:45:40 <aeolist> not that far into the language yet
12:45:59 <vixey> aeolist, it's like a macro or something
12:46:15 <vixey> you write [$foo| .... |] and the function 'foo' parses the " ... " and returns some haskell code
12:46:24 <vixey> I prefer the view pattern though
12:46:37 <dcoutts> Lemmih: if we could support http digest authentication that'd be good
12:46:40 <mauke> you can't do it with view patterns
12:47:02 <dolio> newsham: I'm not sure exactly what your second question means. But it's like encoding lists by partially applying 'uncons :: (a -> [a] -> c) -> c -> [a] -> c' I believe.
12:47:26 <dolio> At least, that's how it seemed to me.
12:47:43 <vixey> mauke, I just approximated it above
12:48:01 <mauke> no, you didn't
12:48:08 <mauke> he wanted |, you wrote &
12:48:22 <vixey> no I wrote ,
12:48:32 <vixey> but you can use :|  too
12:48:40 <vixey> Ohhhhh.....
12:48:41 <newsham> dolio: if all data structures were encoded using their recursive variants, then you would lose the ability for arbitrary recursion, no?
12:48:43 <vixey> you're right
12:48:46 <newsham> (thats what my 2nd quesiton meant)
12:48:52 <vixey> thanks
12:48:53 <newsham> you'd be limited to structural recursion
12:49:04 <newsham> (and you'd have proof of termination for all finite data)
12:49:13 <vixey> hummmmmmmmm :/
12:49:22 <vixey> I am not sure how to do it then
12:49:47 <dolio> newsham: It's not an encoding that works in Haskell unless you put in a strategic newtype wrapper to break the recursive types that result in a lot of cases.
12:49:59 <mauke> > let f y@(Just x) = (x, y) in f (Just True)
12:50:00 <lambdabot>   (True,Just True)
12:51:51 <mauke> dcoutts: I can't get gtk2hs to build. can you help me?
12:51:52 <vixey> yeah I can't see any way to do it
12:51:57 <dolio> @type let nil f z = z ; cons x xs f z = x `f` xs f z in (nil, cons)
12:51:58 <lambdabot> forall t t1 t2 t3 t4 t5. (t -> t1 -> t1, t2 -> ((t2 -> t3 -> t4) -> t5 -> t3) -> (t2 -> t3 -> t4) -> t5 -> t4)
12:51:58 <vixey> that's annoying
12:56:06 <wchogg> conal:  I passed along my reactive tetris to the list.  It was a pretty positive experience.  Now once that recursive bug is resolved I should be able to pump out a number of 'almost finished' examples.
12:56:15 <dcoutts> mauke: not today, sorry
12:56:27 <mauke> ok
12:57:50 <monadwr> http://www.overcomingbias.com/2008/11/all-are-unaware.html interesting.
12:58:00 <lambdabot> Title: Overcoming Bias: All Are Skill Unaware
12:59:35 <dolio> newsham: I can still write unfoldr for a Church-encoded list as long as there's general recursion in the language.
13:01:38 <vixey> which one is church encoding?
13:02:10 <vixey> zero = \zero succ -> zero,  succ = \n zero succ -> succ (n zero succ) ?
13:02:12 <newsham> isnt unfoldr built into the recursive encoding you are talking about?
13:02:18 <newsham> err.. sorry, thats foldr
13:02:33 <dolio> There is an encoding that has unfoldr built in.
13:02:54 <dolio> It's the difference between inductive (finite) lists and coinductive (possibly infinite) lists.
13:03:19 <dolio> I'm not sure if both are considered Church encodings (the former is the standard one, I think).
13:05:23 <vixey> what is the unfoldr encoding?
13:05:38 <vixey> on N?
13:09:36 <dolio> exists s. (s, s -> Maybe s)
13:10:57 <hackage> Uploaded to hackage: EEConfig 1.0
13:11:19 <vixey> oh right
13:12:28 <ashren> hi, are there haskell module for simulating keystrokes?
13:14:01 <conal> wchogg: just saw your reactive-tetris email.  congrats on getting it this far!
13:14:43 <conal> wchogg: you can host code etc in your home dir on code.haskell.org, without having to request a "project"
13:14:49 <vixey> is there a working tetris using reactive?
13:15:06 <wchogg> vixey:  for certain definitions of 'working', yes.
13:15:14 <vixey> can I read it?
13:15:45 <newsham> http://www.haskell.org/pipermail/reactive/2008-November/000022.html
13:15:48 <lambdabot> Title: [reactive] First draft of reactive-tetris, http://tinyurl.com/55ya5h
13:16:02 <vixey> thanks :)
13:16:55 <wchogg> conal:  didn't realize that.  I'm pretty sure I have an account on code.haskell.org.
13:17:13 <conal> wchogg: i learned the trick from dons
13:17:44 <conal> wchogg: i just had to "mkdir ~/public_html", and i was good to go
13:18:03 <wchogg> conal:  Cool.
13:18:21 <conal> wchogg: oh, and then point people to http://code.haskell.org/~conal
13:18:24 <lambdabot> Title: Index of /~conal
13:19:01 <conal> hurray for code.haskell.org !
13:19:24 <wchogg> conal:  This might be a dumb question, but can I share the ssh key for logging in between machines?
13:20:28 <monadwr> Nice nick.
13:20:48 <vixey> awww...
13:20:49 <newsham> wchogg: you can put your public key on as many machines as you want
13:20:58 <vixey> this is not good: OpenGL-2.2.1.1 failed during the configure step. The exception was: exit: ExitFailure 1
13:21:17 <pumpkin> wchogg: I normally keep one private key per machine I have an account on, and put its public half onto all the machines I want to log into
13:21:25 <pumpkin> I wouldn't spread the private keys :P
13:21:45 <pumpkin> makes it easier to blacklist individual keys if one is compromised
13:22:11 <conal> wchogg: i get confused about ssh stuff, so better listen to others' advice rather than mine.
13:23:05 <newsham> pumpkin: how many machines do you sit at the console of?
13:23:20 <pumpkin> maybe 5ish
13:23:24 <newsham> eek.
13:23:37 <pumpkin> well, two laptops, a desktop, and two remote machines I use for hosting stuff
13:23:43 <pumpkin> that I do occasionally ssh from
13:23:57 <newsham> you dont need the keys on the remote machines
13:24:06 <newsham> you can do agent forwarding (-A) when ssh'ing into them
13:24:13 <pumpkin> ah, didn't know that
13:24:15 <pumpkin> cool
13:25:20 <wchogg> I'm glad I can save the money on hosting.
13:25:51 <vixey> conal, may want to add a note or something saying to install libghc6-opengl-dev for field trip?
13:26:08 <vixey> (and glut)
13:26:55 <conal> vixey: how about just "cabal install"?
13:27:05 <vixey> that didn't work for me at least
13:27:20 <conal> vixey: what happened?
13:27:37 <vixey> it says: OpenGL-2.2.1.1 failed during the configure step. The exception was: exit: ExitFailure 1
13:27:51 <vixey> and that is encrypted message saying that it doesn't have headers for opengl
13:27:51 <conal> eep.  not much to go on.
13:28:09 <vixey> installing libghc6-opengl-dev & glut seems to fix it
13:28:22 <conal> oh, i seee.  sounds like something missing on the C end.
13:28:27 <vixey> yes
13:28:35 <conal> i haven't heard of libghc6-opengl-dev .
13:28:39 <conal> how did you learn about it?
13:28:45 <profmakx> is there a way to compose Data.Map(s)
13:28:51 <profmakx> ?
13:28:57 <pumpkin> compose?
13:28:59 <vixey> conal: I searched for haskell opengl in synaptic
13:29:11 <profmakx> as in function composition
13:29:12 <pumpkin> profmakx: you'd need a way of sorting them, if you want to use a Map as a key
13:29:27 <profmakx> hm
13:29:37 <profmakx> isnt the keytype Ord a =>?
13:29:47 <vixey> :/
13:29:55 <vixey> even after cabal install claims to work
13:29:59 <vixey> it says  Could not find module `FRP.Reactive.FieldTrip.Adapter':
13:30:07 <vixey> don't like cabal
13:30:14 <conal> vixey: oh.  cool.  hey -- would you mind adding an "Installation Challenges" (or some such) section to the FieldTrip wiki page?
13:30:27 <wchogg> vixey:  did you install reactive-fieldtrip?
13:30:30 <profmakx> whm
13:30:35 <profmakx> monoid seems a better fit
13:30:42 <vixey> I cabal install fieldtrip and cabal install reactive
13:30:59 <wchogg> vixey:  cabal install reactive-fieldtrip  <- different package
13:31:02 <vixey> hehe.. it's a third one :)
13:31:03 <vixey> ok
13:31:06 <vixey> thanks trying it now
13:31:16 <conal> cool.  i appreciate the feedback.
13:31:30 <vixey> great!
13:31:40 <vixey> I played reactive tetris :))
13:32:28 <wchogg> I'm going to be in Portland most of this week, but when I'm back I want to make it fully complete & put it up on hackage
13:33:32 <Baughn> I found one page claiming that the multiplicative groups of integers (1..p) for some prime p is /not/ safe for el-gamal encryption, but no references. Anyone happen to know about this?
13:34:03 <Baughn> As the handbook of applied encryption disagrees, I'm inclined to ignore this
13:34:25 <vixey> conal, adding this note?:  * Or install with <tt>cabal install reactive-fieldtrip</tt> (you may also need to install libghc6-opengl-dev and libghc6-glut-dev using synaptic or apt-get).
13:34:46 <conal> vixey: thanks much.
13:35:00 <conal> vixey: i may tweak it from there, but at least i won't forget.
13:35:32 <wchogg> those particular packages are so distro specific though
13:36:38 <vixey> I don't know if this is wchogg or conals or my opengl install.. but the window tetris is in does not have a title bar?
13:36:46 <vixey> is that just me?
13:37:20 <conal> vixey: i see a title bar with "Reactive + FieldTrip"
13:37:33 <vixey> ok must be a problem with something in my OS
13:37:40 <conal> wchogg: cool.  the first Reactive-based game!
13:37:54 <vixey> yes very nice
13:38:00 <newsham> i want a curses version ;-)
13:38:12 <vixey> curses yuck
13:38:17 <vixey> I hate curses
13:38:40 <wchogg> conal:  But seriously, whenever this integral issue is fixed I have a breakout clone, a few physics simulations, etc. that can all be finished.
13:40:48 <conal> wchogg: awesome!  couldn't respond before -- was playing tetris.
13:41:59 <wchogg> conal:  Cool!  Glad it works.
13:44:59 <wchogg> conal:  and I appreciate all the help on learning reactive.
13:45:06 <conal> :)
13:45:39 <profmakx> after all the reactive concept seems really cool
13:46:21 <profmakx> i always dreamed of such a thing when i developed games and stuff like that
13:46:24 <geezusfreeek> my uDevGames entry will be done in reactive style, actually, but not using Reactive
13:46:42 <profmakx> and now i dont have the time to do it anymore :/
13:46:58 <geezusfreeek> i've got the bits and pieces of a nice implementation
13:47:15 <geezusfreeek> following the Reactive semantics, mostly
13:47:41 <geezusfreeek> but for my entry i'm just going to reimplement things only as needed
13:48:15 <geezusfreeek> should be nice though. speedy and simple
13:48:55 <profmakx> when will it be published, geezusfreeek?
13:49:20 <geezusfreeek> uDevGames starts Dec. 2 and lasts for 3 months, then i will extract a library
13:49:27 <geezusfreeek> the game itself will be open source though
13:49:38 <geezusfreeek> so can be inspected before extraction
13:49:53 <Saya> hey is there a standard library for reactive programming in haskell?
13:50:02 <profmakx> hm. I assumed it would be an online magazine of sorts ;)
13:50:06 <profmakx> wrong assumtion i suppose
13:50:22 <geezusfreeek> online magazine?
13:50:28 <profmakx> uDevGames
13:50:32 <geezusfreeek> ah
13:50:37 <geezusfreeek> no, it's a mac gam dev contest
13:50:42 <profmakx> see ;)
13:50:48 <geezusfreeek> supposed to be annual, but it's been dormant for a few years
13:50:49 <profmakx> wrong assumption
13:50:53 <geezusfreeek> back this year though :)
13:51:04 <Baughn> Saya: reactive, I suppose
13:51:32 <geezusfreeek> Yampa is probably one of the oldest that i still see tossed around, but i don't have a clue about whether it is nice to use or efficient
13:51:40 <geezusfreeek> Reactive is certainly the new hotness lately
13:51:57 <sinelaw> conal, i'm new to haskell and want to convince my univ. to allow me to do an FRP-related project as my final year EE project. how ambitious is it to do computer vision with FRP (for a newbie)?
13:52:00 <wchogg> geezusfreeek:  Yampa is a bit in flux at the moment.  I was looking at it a few weeks ago.
13:52:05 <Saya> ok :p  i guess it makes sense but it doesnt seem available in the ubuntu repositories :(
13:52:06 <profmakx> i started an attempt on such things while reading SoE
13:52:18 <sinelaw> it has to be a real-time system of course
13:52:28 <geezusfreeek> Saya, you will want to install cabal-install from hackage and use it to manage your haskell libs
13:52:32 <wchogg> Saya:  Ubuntu is going to be too far behind.  go to hackage instead.
13:53:02 <Baughn> sinelaw: As I understand FRP, it's handy when you have complex systems of triggers and actions. I don't know anything about computer vision, really, but does that really fit?
13:53:13 <vixey> Saya, You can install it using cabal but you should get ghc-opengl-dev and glut-dev from ubuntu
13:53:16 <Saya> well cabal install should be in the repositories and its not, outrageous!
13:53:18 <conal> sinelaw: i wouldn't stake something as important as your senior project on a still-getting-the-kinks out project like Reactive.
13:53:27 <vixey> Saya, but cabal takes a bit of work to install
13:53:37 <Saya> yeah i already got those tried some haskell opengl earlier this week
13:54:12 <Saya> i just hope i dont need cabal to install cabal
13:54:35 <sinelaw> conal it's next year :) maybe by then....
13:54:48 <geezusfreeek> Saya, you don't actually have to have cabal-install to manage your haskell packages, but it's really nice once you have it
13:54:58 <conal> sinelaw: oh, good.  i sure hope it's solid in time then.
13:55:06 <conal> sinelaw: and there is related FRP vision work.
13:55:19 <sinelaw> conal, yes i've seen some presentation a while ago
13:55:24 <sinelaw> didn't get much of it back then
13:55:40 <sinelaw> couldn't even read haskell syntax :)
13:55:46 <conal> sinelaw: www.haskell.org/yale/papers/padl01-vision/index.html
13:56:11 <conal> sinelaw: just to get you oriented on related work.
13:56:47 <sinelaw> conal, thanks, that's great. my only problem is that none of the EE faculty here have anything to do with functional programming at all.
13:57:33 <sinelaw> i mean, i can handle it all myself, but bureaucratically i need someone to review it
13:57:45 <Baughn> sinelaw: Electrical engineering? I may be mistranslating cultures.. do they normally do anything CS-like?
13:58:12 <wchogg> Baughn:  It often depends on the Uni.  I've seen CS & EE combined in some places.
13:58:13 <sinelaw> Baughn, not CS, but they do a lot of computer vision
13:58:13 <Fallen_Demon> Hi guys
13:58:17 <profmakx> for certain things EEs at my old university were the better computer scientists
13:58:24 <sinelaw> Baughn, and parallel computing
13:58:39 <profmakx> for "certain things" == "practical programming" for example
13:59:02 <Fallen_Demon> I'm wondering if I can get some help on a little parsing issue I'm having.....
13:59:03 <Baughn> Hmm. That's certainly very different from my experience
13:59:21 <Baughn> Then again, EEs here do no programming more high-level than embedded chips, and more likely FPGAs
13:59:42 <geezusfreeek> engineering is often conflated with computer science at universities
13:59:46 <Baughn> Fallen_Demon: I wonder too. So, what do you think?
13:59:47 <gwern> http://www.pps.jussieu.fr/~canou/obrowser/tutorial/ <-- those ocaml bastards! they're stealing YHC's thunder
13:59:48 <geezusfreeek> the one i graduated from, for example
13:59:49 <lambdabot> Title: O'Browser - Introduction and Tutorial
13:59:49 <sinelaw> Baughn, and matlab surely? that's all you need for image processing work (as long as it stays in the lab)
14:00:07 <Fallen_Demon> evaluateExpr (NUM c:NUM d:cs)		= evaluateExpr (NUM (d+c*10):cs)
14:00:09 <Baughn> sinelaw: They don't do image processing. They make microchips and analog circuits.
14:00:16 <newsham> no courses on assembly programming?  C?  operating systems? algorithms?
14:00:23 <Baughn> sinelaw: Actually, we don't do anything relating to AI in all of our university
14:00:33 <Fallen_Demon> I have that as a list of tokens trying to parse a mathematical expression
14:00:35 <Baughn> newsham: That's for the CS people
14:00:50 <sinelaw> Baughn, ah ok, here they do a lot of computer architecture, robotics, audio and video processing, and also lower-level stuff
14:01:07 <newsham> baughn: useful for an engineer who's using a microprocessor
14:01:09 <Baughn> sinelaw: Oh, they do all of that. THey just don't try to make them at all intelligent
14:01:13 <Fallen_Demon> The operations all work, but when I go to get multidigit numbers it gives me much more than I should have
14:01:15 <Baughn> Not our department, so to speak. ;)
14:01:49 <sinelaw> If you mean AI,  i don't think they do that here either
14:01:55 <Baughn> newsham: EE grads do have some CS courses required.. I'm pretty sure the OS course is one of them
14:02:06 <Baughn> sinelaw: Computer vision is a branch of AI...
14:02:21 <Beelsebob> camio: it came up because of a discussion in here -- we were talking about x -&&- y == x && y `unamb` y && x
14:02:34 <Beelsebob> and someone then mentioned error
14:02:37 <Beelsebob> and I twigged
14:02:53 <sinelaw> Baughn, oh ok. Then maybe they do! We also participated in DARPA's Urban Challenge
14:03:04 <Baughn> sinelaw: Definitely AI.
14:03:25 <dancor> herpesBot: help
14:03:27 <camio> Beelsebob: so (delayInfinity) `unamb` 5 would return 5 in implementation, but semantically it ought to return _|_.
14:03:34 <Fallen_Demon> ^ that is my bot I'm having trouble with
14:03:37 <Beelsebob> camio: no?
14:03:40 <Fallen_Demon> Watch
14:03:44 <Fallen_Demon> !math 20+20
14:04:37 <herpesBot> 400
14:04:37 <Beelsebob> becaues delayInfinity == _|_
14:04:37 <Beelsebob> so it can chose the other
14:04:37 <Beelsebob> > 20 + 20
14:04:37 <sinelaw> we were to supply the CV part for some car. i wrote the framework (in C++) and at the last moment, the car team failed to integrate our CV system into the car
14:04:37 <lambdabot>   40
14:04:37 <Fallen_Demon> mmm....
14:04:37 <Baughn> Fallen_Demon: ..how did /that/ happen?
14:04:37 <camio> Beelsebob: Yes, semanticly it is _|_.
14:04:37 <Fallen_Demon> I have no idea
14:04:37 <Beelsebob> camio: so it's free to return 5
14:04:37 <Fallen_Demon> I've tracked some sample input through and it doesn't make sense
14:04:37 <sinelaw> they ended up driving up a pavement...the pavement detection code was the simplest part of our system, it could have gotten them into the finals :(
14:04:43 <Beelsebob> camio: the problem comes with error, because it's a "fast" bottom -- i.e. it returns bottom, possibly faster than the computation of 5
14:05:06 <Beelsebob> so it's possible for unamb to return bottom, even when the other argument has a valid result
14:05:20 <conal> Beelsebob: i don't think so.
14:05:41 <camio> Beelsebob: Right
14:05:41 <Beelsebob> conal: oh?
14:05:50 <Fallen_Demon> Baughn, evaluateExpr (NUM c:NUM d:cs)		= evaluateExpr (NUM (d+c*10):cs) that's the code that should be rectifying any list of the form 6:6:xs to 66:xs
14:06:01 <conal> Beelsebob: try: error "yipes!" `unamb` hang
14:06:07 <sinelaw> does haskell have OpenCV wrappers?
14:06:08 <vixey> Fallen_Demon, what are you programming here?
14:06:11 <conal> Beelsebob: it hangs.
14:06:13 <vixey> Fallen_Demon, this looks fun .. :)
14:06:15 <sinelaw> oops i'll ask google...
14:06:21 <Fallen_Demon> vixey herpesBot
14:06:46 <Beelsebob> conal: oh?
14:06:48 <Beelsebob> that's wierd
14:06:50 <Fallen_Demon> And it is fun :)
14:06:56 * Beelsebob goes and looks at the implementation again
14:07:14 <conal> Beelsebob: i think the thread with the error never gets to write to the mvar, so it cannot win.
14:07:21 <Fallen_Demon> Hey, cool aid!
14:07:23 <herpesBot> OH YEAH!
14:07:26 <sinelaw> ok, google doesn't seem to know. _does_ haskell have OpenCV bindings/wrappers/whatever?
14:07:35 <Beelsebob> conal: hmm, interesting
14:07:38 <conal> for others, we're talking about Unamb (purely functional unambiguous choice)
14:07:44 <sinelaw> if python does, how hard will it be to make some for haskell?
14:07:45 <conal> @wiki Unamb
14:07:45 <lambdabot> http://www.haskell.org/haskellwiki/Unamb
14:08:42 <Beelsebob> conal: hmm, so that would imply that the implemntation and the semantics agree -- but we could possibly produce a "better" bottom in the case of error "hi" `unamb` error "lo"
14:08:52 <Beelsebob> i.e. it would be nice for unamb to terminate in that case
14:08:53 <conal> Beelsebob: yeah.  for a thread to win, it has to reduce a value to whnf without dying.
14:09:22 <camio> Beelsebob: For the sake of error messages?
14:09:23 <Beelsebob> conal: do you agree it would be nice to return a better bottom? or do you not see that as an issue?
14:09:25 <Beelsebob> yep
14:10:10 <Beelsebob> camio: I guess I would intuitively expect that if I give unamb to terminating functions (even though bottoms), it would terminate too
14:10:29 <Beelsebob> even if it's with something like error "Unamb called with two bottoms"
14:10:37 <conal> Beelsebob: yeah.  might be nice to know.
14:10:58 <conal> Beelsebob: i'd expect to get exactly that behavior from ghc, btw.
14:10:58 <hackage> Uploaded to hackage: RSA 1.0.0
14:10:58 <hackage> Uploaded to hackage: SHA 1.0.0
14:11:06 <Beelsebob> conal: oh?
14:11:18 <Beelsebob> because both threads terminated?
14:11:28 <Beelsebob> and it read nothing out of the mVar
14:11:34 <conal> Beelsebob: no.  because ghc is smart about threads blocked on an inaccessible mvar.
14:11:43 <Beelsebob> oh, okay
14:11:59 <Beelsebob> so the error would be something like "thread blocked permanently on mvar read"?
14:12:15 <conal> Beelsebob: yeah.
14:12:20 <Beelsebob> which is better, but I guess not ideal
14:12:21 <Saya> do i need the last version of ghc for 'reactive' ?  (cabal: Package vector-space-0.5 can't be built on this system.)
14:12:23 <Fallen_Demon> !math 20+20
14:12:24 <herpesBot> 400
14:12:27 <Fallen_Demon> >_<
14:12:29 <Beelsebob> cool, I'm glad you convinced me conal
14:12:33 <conal> Beelsebob: yeah.  maybe we could do better somehow.
14:12:33 <Beelsebob> I thought there was a hole here
14:12:42 <Beelsebob> conal: I can think of a hack implementation
14:12:46 <mauke> !math .
14:12:47 <herpesBot> 0
14:12:50 <Saya> !math 1/0
14:12:51 <herpesBot> Dividing by zero is a no-no, asshole
14:12:52 <roconnor> !math 2^200
14:12:53 <herpesBot> 22000
14:12:53 <mauke> !math /
14:12:54 <herpesBot> Nice try
14:12:58 <Saya> hehe
14:12:59 <Beelsebob> make each thread contain a catch, and then return an Either String a
14:12:59 <conal> Beelsebob: btw, i just tried: error "foo" `unamb` error "bar"
14:13:03 <lament> !math 1 + 1
14:13:04 <herpesBot> 2
14:13:06 <roconnor> !math 2**200
14:13:07 <lament> ha
14:13:08 <herpesBot> 40000
14:13:08 <camio> Saya: Yes, I believe you do.
14:13:10 <lament> !math 1 + 10
14:13:11 <herpesBot> 2
14:13:11 <herpesBot> 101
14:13:12 <Beelsebob> and then if both return Left "something", throw a new error in the main thread
14:13:18 <lament> oh, i se
14:13:19 <lament> see
14:13:21 <Beelsebob> conal: what did it do?
14:13:23 <Saya> damn :(
14:13:39 <roconnor> > 2^200
14:13:40 <conal> Beelsebob: it hangs.  no "thread permanently blocked..." message.
14:13:41 <lambdabot>   1606938044258990275541962092341162602522202993782792835301376
14:13:45 <Beelsebob> conal: oh, lame
14:13:48 <Fallen_Demon> I should add names to it :/
14:13:55 <Beelsebob> let my try a hack at my fix
14:13:57 <conal> Beelsebob: yeah -- i like your idea of catching the exceptions.
14:14:05 <geezusfreeek> conal, could you remind me again what it means that the two arguments to unamb must "agree unless bottom"? i'm still having trouble convincing myself that it's RT, and it's become accepted enough now that my intuitions _must_ be wrong
14:14:20 <conal> Beelsebob: oh, hey!  maybe your idea could also work for a cheaper (?) implementation of hang.
14:14:24 <roconnor> @type forever retry
14:14:25 <lambdabot> Not in scope: `retry'
14:14:26 <mauke> !math 2+-2
14:14:28 <herpesBot> 4
14:14:29 <Beelsebob> conal: oh?
14:14:31 <conal> Beelsebob: by having hang throw an exception.
14:14:32 <mauke> haha, what
14:14:37 <roconnor> @hoogle retry
14:14:37 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
14:14:37 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry_ :: Num a => String -> IO a -> IO ()
14:14:37 <lambdabot> Foreign.C.Error throwErrnoIfMinus1RetryMayBlock :: Num a => String -> IO a -> IO b -> IO a
14:14:39 <dolio> What kind of math is this?
14:14:42 <lament> new math
14:14:44 <mauke> !math 2+ -2
14:14:44 <Beelsebob> conal: but surely that would defeat the point of Hang?
14:14:45 <herpesBot> 4
14:14:49 <lament> !math 99999 + 1
14:14:50 <herpesBot> 1010089900
14:14:52 <lament> hehe
14:14:55 <mauke> !math 2+ -******2
14:14:56 <herpesBot> 4
14:15:00 <Beelsebob> i.e. it will no longer hang in the hang `unamb` hang case
14:15:02 <mauke> ok, makes sense
14:15:07 <Fallen_Demon> dolio, I haven't got the tokenizer right yet :(
14:15:09 <mauke> !math 2+ (2
14:15:10 <herpesBot> 4
14:15:14 <dolio> Ah. Heh.
14:15:14 <mauke> !math 2+ ))2
14:15:16 <herpesBot> 4
14:15:17 <geezusfreeek> Beelsebob, right, but it would still be bottom
14:15:25 <conal> geezusfreeek: yeah.  i don't get as much skepticism about unamb as i used to.
14:15:25 <Beelsebob> geezusfreeek: true
14:15:30 <mauke> !math 2)) +2
14:15:31 <herpesBot> 4
14:15:35 <lament> first to hack the box on which herpesBot is running gets the prize
14:15:36 <Fallen_Demon> It just ignores any symbols it doesn't know
14:15:55 <mauke> !math 2 -(-2)
14:15:57 <herpesBot> 0
14:16:02 <vixey> !math 999999999999999999999999999999999999999
14:16:03 <herpesBot> -1084587701
14:16:06 <vixey> !
14:16:06 <lament> !math 1.1 * 9
14:16:08 <herpesBot> 99
14:16:17 <skorpan> !math hello
14:16:18 <herpesBot> I don't what you think maths is, but it aint that
14:16:19 <conal> geezusfreeek: for 'a `unamb` b', the meanings of a and b must either be equal, or one must be bottom.
14:16:26 <vixey> lol
14:16:33 <vixey> @remember <herpesBot> I don't what you think maths is, but it aint that
14:16:34 <lambdabot> Nice!
14:16:40 <mauke> preflex: calc 2)) + 2
14:16:40 <preflex>  4
14:16:42 <roconnor> $ telnet 115.129.0.115
14:16:42 <roconnor> Trying 115.129.0.115...
14:16:42 <roconnor> telnet: Unable to connect to remote host: Connection refused
14:16:42 <mauke> superior
14:16:47 <roconnor> I'm out of ideas
14:16:49 <geezusfreeek> conal, oh!
14:16:57 <conal> geezusfreeek: simple, huh?
14:17:08 <mauke> preflex: calc 1.1 * 9
14:17:09 <preflex>  9.9
14:17:14 <lament> !math 0.0.0.0.0.0.0.1
14:17:18 <geezusfreeek> so they are "morally equivalent" so to speak
14:17:22 <herpesBot> 1
14:17:26 <dolio> !math 20 20
14:17:27 <herpesBot> 20200
14:17:40 <conal> geezusfreeek: sure.  they "agree if you wait long enough"
14:17:44 <geezusfreeek> well, that convinces me then
14:17:50 <mauke> !math 1 1
14:17:51 <herpesBot> 11
14:17:52 <lament> !math 1 = 2
14:17:53 <herpesBot> 12
14:17:54 <geezusfreeek> that was the key part i guess i wasn't getting
14:17:56 <mauke> !math 1  1
14:17:57 <herpesBot> 11
14:18:02 <Beelsebob> conal: my solution doesn't quite work
14:18:04 <Beelsebob> because the mvar can only be written once
14:18:09 <lament> !math 1 = 2 = 3
14:18:09 <mauke> !math 10  1
14:18:09 <herpesBot> 123
14:18:10 <herpesBot> 1001
14:18:16 <mauke> !math 10    1
14:18:18 <conal> geezusfreeek: hm.  there's a related zen koan in paul reps's book
14:18:18 <herpesBot> 1001
14:18:23 <mauke> creative
14:18:25 <Beelsebob> so if the first to terminate throws an exception, it can write the mVar with Left "jam", and stop the other one returning a sane value
14:18:31 <lament> !math 10 10 10
14:18:32 <herpesBot> 1010100
14:18:45 * geezusfreeek likes koans
14:18:46 <vixey> so broken
14:18:58 <mauke> preflex: calc 10 10 10
14:18:58 <preflex>  Too many operands
14:19:03 <mauke> this is how you do it :-)
14:19:06 <Fallen_Demon> vixey, it's my first go at parsing :(
14:19:06 <conal> :)
14:19:18 <lament> !math 1 2 3 4 5 6 7 8 9 10
14:19:19 <Saya> !math 1/(0.00000000000000000000000000000000000000000000000000000000000001)
14:19:20 <herpesBot> -539222888
14:19:21 <herpesBot> Dividing by zero is a no-no, asshole
14:19:25 <Beelsebob> hmm, this is hard to come up with a solution
14:19:37 <vixey> what happened to ##compilers?
14:19:40 <geezusfreeek> herpesBot is polite
14:19:42 <mauke> !math 0.00000000000000000000000000000000000000000000000000000000000001
14:19:42 <Baughn> Fallen_Demon: Are you doing math inside the parser?
14:19:48 <profmakx> > 1 / 0
14:19:48 <herpesBot> -954437177
14:19:49 <lambdabot>   Infinity
14:19:54 <mauke> haha
14:19:55 <vixey> Riastradh do you know?
14:20:00 <geezusfreeek> !math a
14:20:01 <Fallen_Demon> Baughn, nope, it tokenizes it first
14:20:04 <herpesBot> I don't what you think maths is, but it aint that
14:20:09 <vixey> omg sorry
14:20:12 <vixey> one #
14:20:15 <vixey> got confused...
14:20:19 <Baughn> Fallen_Demon: Tokenizes? Not builds an AST first?
14:20:45 <Fallen_Demon> Baughn, when I start putting in brackets I'll get a tree going
14:20:54 <Baughn> Fallen_Demon: It'd probably be simpler to first parse it to a tree somewhat like lisp's, then interpret that
14:20:58 <geezusfreeek> !math 100-+-+-+-+99
14:21:00 <herpesBot> 9001
14:21:04 <Fallen_Demon> But for now I just want the maths to work :(
14:21:12 <Baughn> Fallen_Demon: For "evaluate" values of "interpret"
14:21:25 <mikezackles> I've been having a lot of trouble trying to get the highlighting-kate package to install on a machine with 256MB memory.  Using +RTS eventually gives me "heap exhausted" errors for any value under 256.  Is there anything I can do besides letting ghc swap for a day or so?
14:21:45 <vixey> Fallen_Demon, data Exp = Number Integer | Add  Exp Exp | ..., foldExp number add ... (Number x) = number x, foldExp number add ... (Add m n) = add (foldExp number add m) (foldExp number add n) -- will come in useful
14:21:48 <mauke> Fallen_Demon: my advice would be to make the evaluator as simple as possible, which in turn requires an expression tree, which dictates what your parser should do :-)
14:21:57 <vixey> Fallen_Demon, you can write eval = foldExp id (+) ... for example
14:21:57 <conal> Beelsebob: thanks for the fun discussion topic!
14:21:59 <Baughn> mikezackles: Install more memory?
14:22:04 <mauke> you don't even need a generic expression folder
14:22:24 <mikezackles> Baughn: Heh, I wish.  It's a slice on slicehost.
14:22:37 <conal> Beelsebob: i didn't think about the error case when in unamb's semantics or implementation.  i guess i'm just lucky that they agree.
14:22:41 <Fallen_Demon> Hmm, I'll try and get a tree going then....
14:22:46 <Baughn> mikezackles: Hm. You can't ask for more memory temporarily?
14:23:14 <Beelsebob> conal: this is where I'm at... http://hpaste.org/12145
14:23:22 <mikezackles> Baughn: Not a bad idea.  I guess it can't hurt to ask.
14:23:37 <Beelsebob> is there a way to reset the mVar to being writable?
14:24:01 <Baughn> mikezackles: Alternately, switching off optimization should make ghc use less memory
14:24:11 <conal> Beelsebob: a takeMVar resets it
14:24:28 <geezusfreeek> Beelsebob, or tryTakeMVar if you want to be nonblocking
14:24:32 <Lemmih> mikezackles: -c -G1 ?
14:24:44 <Beelsebob> conal: oh? so if I takeMVar, check it, and then take it again, it'll be fine?
14:25:02 <Baughn> Lemmih: ghc-rts automatically starts compacting when you close on the maximum heap size
14:25:09 <geezusfreeek> Beelsebob, takeMVar foo >> takeMVar foo will block
14:25:24 <conal> Beelsebob: maybe.  dunno.  imperative concurrent programming makes me dizzy.
14:25:24 <Beelsebob> geezusfreeek: even if both threads write to the mVar?
14:25:25 <geezusfreeek> well, disregarding other threads
14:25:35 <geezusfreeek> tryTakeMVar will never block
14:25:37 <Baughn> Lemmih: Also, are you a fictional german medical company?
14:26:13 <Beelsebob> geezusfreeek: suppose thread A writes (Left "a") to the mVar, and I takeMVar, then thread B tries to write (Right 5) to the mVar, will I be able to read the Right 5 with takeMVar?
14:26:16 <Lemmih> Baughn: No, I'm a Nigerian prince.
14:26:34 <Baughn> Pity. I was hoping for a time machine.
14:26:36 <geezusfreeek> Beelsebob, yes
14:26:42 <Beelsebob> awesome :)
14:26:55 <geezusfreeek> Beelsebob, the M stands for mutex
14:27:09 <geezusfreeek> (i hope, now that i've said it)
14:27:09 <Baughn> Beelsebob: Though of course the order isn't guaranteed, unless you use mvars to make it so
14:27:17 <conal> i wonder if a more lenient version of unamb can be implemented.  one that works for all pairs of values that have a common upper information-bound.
14:28:13 <roconnor> conal: you mean unamb should return the meet of the two values?
14:28:22 <conal> roconnor: yes
14:28:28 <roconnor> that'd be cool
14:28:30 <conal> roconnor: it does already
14:28:33 <roconnor> does unamb not do this?
14:28:39 <roconnor> ah
14:28:49 <conal> roconnor: yeah, it does, but i'm wondering about a less stringent precondition.
14:29:05 <roconnor> I don't understand your proposal
14:29:22 <conal> somewhat like my blog posts on partial values
14:29:24 <conal>  http://conal.net/blog/posts/a-type-for-partial-values/
14:29:27 <lambdabot> Title: Conal Elliott Â» A type for partial values
14:29:33 <conal> http://conal.net/blog/posts/implementing-a-type-for-partial-values/
14:29:34 <lambdabot> Title: Conal Elliott Â» Implementing a type for partial values, http://tinyurl.com/5rsch9
14:30:29 <conal> roconnor: for instance: (undefined,3) `unamb` (2,undefined)
14:30:45 <conal> they have an upper bound but they violate unamb's current precondition
14:31:29 <roconnor> hmm
14:32:06 <roconnor> isn't (undefined,3) `unamb` (2,undefined) == (undefined `unamb` 2, 3 `unab` undefined) ?
14:32:09 <conal> my blog posts give a solution, via a special representation of partial values.
14:32:25 <Beelsebob> bugger -- I forgot catch doesn't work inside unsafePerformIO
14:32:30 <conal> roconnor: it isn't anything at all.
14:32:59 <conal> roconnor: because it violates the precondition.
14:33:06 <conal> roconnor: but i'd like it to be what you said.
14:33:12 <therp> is anyone using ubuntu as soil for haskell related development?
14:33:22 <conal> therp: i am!
14:33:25 <roconnor> what is the precondition?
14:33:35 <therp> conal: how do you feel with ubuntu+haskell support?
14:33:39 * roconnor uses kubuntu
14:33:42 <conal> roconnor: that the values are equal if both non-bottom.
14:33:59 <therp> conal: I _have_ to get of Gentoo, or otherwise something terrible might happen
14:34:02 <conal> therp: i came from windows, so i feel ecstatic.
14:34:09 <therp> conal: so I'm looking for alternatives..
14:34:15 <geezusfreeek> therp, there isn't really much haskell support in the ubuntu repos
14:34:23 <therp> conal: ah ok :) so you are happy about everything that doesn't crash.
14:34:25 <conal> therp: that just means i had an abusive haskell childhood.
14:34:32 <geezusfreeek> therp, arch has very good haskell support thanks to dons :)
14:34:43 <roconnor> so uamb isn't the meet of the CPO?
14:34:49 <therp> geezusfreeek: I heard about that and I installed arch two weeks ago on my laptop
14:35:02 <conal> roconnor: it is the meet where defined.
14:35:02 <geezusfreeek> aw, don't like arch?
14:35:05 <therp> geezusfreeek: still, arch doesn't feel like it's more comfortable than Gentoo
14:35:28 <geezusfreeek> i love it. the package manager just makes sense to me, and i like how easy it is to make new packages
14:35:31 <mdmkolbe> therp: I use ubuntu.  The haskell package works just fine, but *do*not* install the haskell libraries from the package manager (the version numbers are messed up, you'll get a broken install).  Instead just install the minimal from the package manager and after that use cabal to install other libraries
14:36:02 <wchogg> I agree with mdmkolbe.  I've been very happy using Ubuntu for haskell dev with that caveat
14:36:02 <conal> therp: i never install haskell stuff from apt.
14:36:03 <ibid> mdmkolbe: is that bug reported?
14:36:07 <therp> geezusfreeek: are you on i386 or amd64?
14:36:08 <mdmkolbe> therp: IIRC it was one specific database/sql package that messed up the version
14:36:11 <kosmikus> therp: certainly not a smooth experience yet, but you could really help us with NixOS ...
14:36:12 <roconnor> conal: ok, I see what you mean.
14:36:20 <mdmkolbe> ibid: probably not, didn't have time/motivation
14:36:24 <geezusfreeek> therp, i have used arch for both, but am on amd64 right now
14:37:03 <gwern> I agree. the way to go with ubuntu is to install ghc and ghc only, and then get cabal-install working and work from there
14:37:03 <roconnor> conal: so (2:3:undefined) `unamb` (2:3:4:[]) doesn't return 2:3:4:[].
14:37:32 <conal> roconnor: you're asking about the implementation, not the semantics, right?
14:37:42 <roconnor> semantics
14:37:50 <geezusfreeek> therp, i do agree with everybody else about how to use ubuntu for haskell dev. works great for just ghc from package manager
14:37:54 <mdmkolbe> conal: is there a link for this unamb so I can follow the conversation?
14:37:56 <conal> roconnor: the question is broken
14:38:02 <conal> mdmkolbe: yeah
14:38:05 <conal> @wiki unamb
14:38:05 <lambdabot> http://www.haskell.org/haskellwiki/unamb
14:38:06 <roconnor> conal: because (2:3:undefined) (2:3:4:[]) are non bottom and not equal
14:38:10 <therp> kosmikus: hmm.. I thought about it. but honestly speaking, I'm trying to fix "Haskell" already for me personally. I can't jump into fixing "the linux distro" problem too
14:38:10 <conal> @hackage unamb
14:38:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unamb
14:38:16 <conal> roconnor: right
14:38:27 <therp> kosmikus: but you have my both thumbs up for NixOS! (that doesn't fix bug of course)
14:38:34 <conal> i love lambdabot
14:38:44 <geezusfreeek> i love the concept of nixos, but i haven't figured it out yet
14:38:46 <roconnor> conal:  I see now, that in the source you use evaluate, which cares only about head normal form.
14:38:55 <conal> roconnor: yeah
14:39:02 <therp> geezusfreeek & conal & mdmkolbe: thanks
14:39:07 <conal> :)
14:39:11 <kosmikus> therp: sure, I can understand if you want something that just works for you. but then again, you seem like someone who might be happy with the way NixOS works.
14:39:11 <geezusfreeek> np
14:39:27 <roconnor> conal: I bet you cold make a real cool unamb operator using GHC internals.
14:39:29 <roconnor> :)
14:39:34 <roconnor> you could
14:39:45 <hcube> hi!
14:39:45 <geezusfreeek> lambdabot should give karma whenever your nick and the word "thanks" are in the same message
14:39:48 <geezusfreeek> :)
14:39:51 <mdmkolbe> conal: is this similar to frons (Friedman & Wise)
14:40:11 <conal> roconnor: yeah.  for one thing, if either value is already in whnf, don't start any threads.
14:40:17 <hcube> i've got error during compiling grapefruit
14:40:34 <conal> mdmkolbe: never heard of frons.  googling.
14:40:49 <hcube> it's build system is incompatible with the new cabal API
14:40:50 <therp> kosmikus: how would I try NixOS? I hear that it's "distribution agnostic"
14:41:07 <conal> mdmkolbe: thx much for the reference.
14:41:32 <conal> mdmkolbe: the important thing to me about unamb is that it's referentially transparent.
14:41:51 <kosmikus> therp: NixOS isn't, but the Nix package manager is.
14:41:51 <conal> mdmkolbe: it's semantically deterministic, hence "unambiguous choice"
14:42:03 <roconnor> therp: let me know if you get a good haskell dev environment under NixOS.
14:42:08 <kosmikus> therp: you can just install the Nix package manager on top of another distro.
14:42:17 <roconnor> oh
14:42:27 <roconnor> so we could put Nix on Unbuntu?
14:42:31 <kosmikus> yes
14:42:32 <conal> mdmkolbe: from a quick googling, i guess frons is nondeterministic, and so doesn't preserve simple semantics.
14:42:53 <roconnor> kosmikus: so some packages would be managed by apt, and some packages managed by Nix?
14:42:55 <mdmkolbe> conal: does that mean "1 `unamb` 2" throws an error value (e.g. undefined)?
14:42:56 <kosmikus> unfortunately, and I'm really ashamed to say this, I find the Haskell packaging less than optimal on NixOS right now
14:42:59 <therp> kosmikus: I want the whole thing
14:43:01 <kosmikus> the potential is certainly great
14:43:13 <kosmikus> but I've not had the time to get it all done
14:43:20 <kosmikus> we lack manpower :)
14:43:49 <roconnor> mdmkolbe: it will return either 1 or 2 nondeterministically, making that piece of code non-referentially transparent and broken.
14:44:05 <geezusfreeek> kosmikus, i believe dons keeps arch up to date using a script that is automatically run
14:44:06 <kosmikus> roconnor: yes, NixOS packages don't have any dependencies on the outside system. so installing Nix on top of another distro is costing you a bit of disk space, but doesn't interfere with anything
14:44:16 <mdmkolbe> conal: your impression is probably correct.  the car of a frons returns the first one to come back, but any following cars also return the same value (cdr gets which ever one didn't come back first)
14:44:18 <roconnor> kosmikus: cool
14:44:22 <kosmikus> geezusfreeek: I know, I want to automate as well. still costs time.
14:44:31 <geezusfreeek> yeah :\
14:44:31 <conal> mdmkolbe: what roconnor said.  the precondition is not checked statically (would require something like dependent types), nor dynamically (would defeat the purpose).
14:44:49 <kosmikus> therp: I see. If you want the whole OS, I'm afraid you have to install it in a VM if you want to try it.
14:45:02 <mdmkolbe> conal: but it is a requirement the user must satisfy, right?
14:45:06 <geezusfreeek> time to go home
14:45:17 <conal> mdmkolbe: exactly
14:45:46 <roconnor> kosmikus: ah you are from UU.  Do you work on Nix?
14:45:52 <conal> mdmkolbe: e.g., (a && b) `unamb` (b && a)
14:45:53 <mdmkolbe> conal: ok, that make sense.  yeah, frons is different
14:46:11 <conal> mdmkolbe: where a or b could be bottom
14:46:13 <kosmikus> roconnor: I'm not the main dev, but yes, I work on it.
14:46:37 <therp> kosmikus: no prob, I just fixed my vmware installation error that kept me from spending a happy evening with my girlfriend
14:46:55 <roconnor> conal: you mean (a || b) `unamb` (b || a), the infamous parallel or?
14:47:15 <roconnor> conal: I guess what you wrote is equivalent.
14:47:29 <kosmikus> roconnor: niksnut is the author of Nix. he's around on freenode, just not usually on #haskell.
14:47:32 <conal> roconnor: yes, that's another example.
14:47:57 <conal> roconnor: i don't know why parallel-or is more famous than parallel-and.  do you?
14:47:58 <kosmikus> roconnor, therp: we also have #nixos, but it's certainly more quiet than #haskell ;)
14:48:37 <ddarius> conal: Why is nand more famous than nor?
14:49:02 <roconnor> conal: I've never heard of parallel and, but it seems equivalent now that I think about it.
14:49:06 <conal> ddarius: simple hw, i think.
14:49:19 <conal> roconnor: yeah.  to me too.  strange.
14:49:32 <conal> given de morgan
14:49:44 <roconnor> unamb should totally be part of haskell' ...
14:49:53 <roconnor> well, maybe I shouldn't go that far
14:50:11 <ddarius> We can add por without adding the nastiness of unamb.
14:50:18 <roconnor> it is a huge requirement.
14:50:28 <conal> ddarius: which nastiness?
14:50:59 <ddarius> conal: The fact that it's preconditions are not statically or dynamically checked is pretty nasty.
14:51:19 <conal> ddarius: yep: unfortunate.
14:51:31 <conal> like fromAscList in Data.Map
14:51:32 <roconnor> ddarius: we could mandate a version of unamb that returns the meet of the two values in their DCPO.
14:51:42 <roconnor> that would have no preconditions
14:51:52 <vixey> @tell mmorrow I don't get it :(
14:51:53 <lambdabot> Consider it noted.
14:52:06 * roconnor ponders the unamb of functions and how it interacts with seq.
14:52:14 <ddarius> roconnor: You also couldn't write por with that.
14:52:47 <roconnor> ddarius: por = (a || b) `dcpoMeet` (b || a)
14:52:51 <roconnor> er
14:52:54 <roconnor> you know what I mean
14:53:13 <ddarius> roconnor: If either a or b is bottom, then the meet is bottom.
14:53:33 <mdmkolbe> wouldn't unamb be a nasty potential space/time leak? (e.g. "(let f x = f (x+1) in f 0) `unamb` [0..]")
14:54:17 <roconnor> ddarius: oh crap. I want the join ... which does require preconditions.
14:54:33 <conal> mdmkolbe: i think the current Data.Unamb would do fine in that case
14:54:41 <roconnor> ddarius: thanks for catching that
14:54:56 <dolio> It'd see (0:[1..]) and immediatley yield that, no?
14:55:04 <conal> right.
14:55:16 <conal> unless the ghc scheduler got stuck.
14:55:31 <conal> which it might
14:56:10 <dolio> f 0 `unamb` f 0 might be more of an issue.
14:56:26 <conal> dolio: yeah.  that'd be expensive
14:56:36 <conal> semantically correct but expensive
14:58:15 <conal> here's a dilemma: haskell could provide an ad hoc set of functions like parallel-or and parallel-and, which would not be adequate for things like Reactive.  or it could provide something more general like unamb that doesn't have checkable conditions.  maybe something in between that i don't see yet.
14:58:39 <roconnor> dolio: that is just as expensive as g (f 0) (f 0) in the general case?
14:59:12 <dolio> As long as g evaluates either one of them.
14:59:25 <roconnor> or both of them.
14:59:30 <dolio> Sure.
14:59:45 <roconnor> so it isn't really a problem with unamb
14:59:48 <dolio> I mean, it'd build an ever-increasing nested thunk of (+1)s.
15:00:07 <wchogg> You know you're dealing with some nasty problems when you keep a permanent 1 s vmstat going to spot when the memory leak hits you.
15:00:17 <ddarius> conal: I believe there are proofs that adding por is all you need to get such benefits while preserving referential transparency.
15:00:18 <conal> roconnor: i agree.  it's not an unamb problem.
15:00:31 <conal> i don't think unamb can make anything much more expensive.
15:00:50 <dejones> Hello, I am confused why I get a compilation error on this simple case, http://hpaste.org/12147
15:01:04 <conal> i mean aside from some constant-time overhead, which hopefully could be kept small.
15:01:12 <dejones> The error is: Test.hs:8:22: Not in scope: data constructor `Word32'
15:01:33 <Baughn> wchogg: Try with +RTS -M512m or so
15:01:38 <mauke> dejones: Word32 is a type, not a value
15:01:42 <roconnor>  <conal> i don't think unamb can make anything much more expensive.
15:01:46 <roconnor> what do you mean by this?
15:02:06 <roconnor> oh
15:02:08 <roconnor> nevermind
15:02:17 <roconnor> I read expensive as "expressive"
15:02:27 <roconnor> I turned on the lights now.
15:02:28 <dolio> roconnor: I mean, it's just as expensive as f itself.
15:02:29 <roconnor> :)
15:03:04 <purple_> newbi question - in ocaml i can write something like ... map (\x -> print x  ) [1,2,3,4]   where the unit type of return will be ignored, is there an equivalent in haskell that also takes into account that print is monadic ?
15:03:17 <ddarius> mapM_
15:03:18 <mauke> purple_: yes, mapM_
15:03:28 <dejones> mauke: sizeOf expects a value then?
15:03:35 <mauke> purple_: also, that's just map print [1,2,3,4]
15:03:41 <ddarius> dejones: sizeOf is just a function (well method)
15:03:42 <mauke> dejones: all functions do
15:03:49 <mdmkolbe> dejones: you want this http://hpaste.org/12147#a1
15:03:52 <dejones> mauke, ddarius: yea, makes sense, thanks.  :)
15:03:58 <conal> ddarius: i've heard that also.  i haven't seen them.
15:04:14 <purple_> beautiful - thanks
15:04:19 <dejones> mdmkolbe: Ahh, thanks!  :)
15:04:27 <conal> ddarius: and i wonder if unamb could be implemented in terms of por.
15:04:34 <wchogg> Baughn:  That imposes a cap?
15:04:36 <mdmkolbe> dejones: sizeOf expects a value but it ignores the value (so we can use "undefined") and only cares about the type of the value (thus we need the ":: Word32")
15:04:45 <dejones> conal: Nice post on the beautiful folding, btw.  :)
15:04:49 <conal> ddarius: if so, then por would be the way to go.
15:04:54 <ddarius> conal: If unamb violates referential transparency then it clear cannot be.
15:05:04 <dejones> mdmkolbe: Yeah, I didn't know that "undefined" existed.  ;)
15:05:15 <dejones> mdmkolbe: You accomplished exactly what I wanted.  Thank you.
15:05:28 <conal> ddarius: assuming unamb is RT, which i believe is the case (over its domain).
15:05:35 <conal> dejones: thanks!  i got a bit obsessed last week!
15:05:50 <ddarius> conal: unsafePerformIO is referentially transparent "over its domain"
15:05:56 <mdmkolbe> @src undefined
15:05:57 <lambdabot> undefined =  error "Prelude.undefined"
15:06:07 <conal> ddarius: hm?
15:06:50 <conal> ddarius: can por implement unamb over unamb's domain?
15:07:08 <conal> ddarius: unamb can implement por and more.
15:07:12 <mdmkolbe> random question what do you call the distinctive pattern on a waffle? (other than "waffle pattern")
15:07:21 <conal> ddarius: while staying in unamb's domain.
15:07:21 <ddarius> unamb is strictly more powerful than por
15:07:44 <conal> ddarius: without losing RT
15:07:52 <dejones> conal:  lol, I see, but good work.
15:08:00 <conal> :) :)
15:08:05 <dejones> Thanks everyone; I'm going back to work.  :)
15:08:15 <conal> dejones: take care.
15:08:37 * dejones resists the urge to develop his application for reading a binary file in C.  ;)
15:08:40 <ddarius> unamb a b = if (por (a `seq` True) (b `seq` False) then a else b
15:09:49 <conal> ddarius: cool
15:09:55 <ddarius> hmm, there has to be something wrong with that definition... (ignoring the extra open bracket)
15:10:57 <conal> ddarius: hm.  hasn't tripped my alarms yet.  what makes you suspicious?
15:10:58 <hackage> Uploaded to hackage: hmpfr 0.1.3
15:11:50 <ddarius> Because it seems like it defines unamb in full generality, but the || is wrong.  If b terminates we have to wait for a.
15:11:53 <roconnor> ddarius: I don't think that definition is right.
15:12:09 <roconnor> ddarius: if b returns first, por gets a false
15:12:23 <roconnor> ddarius: but then por must wait for a to proceed.
15:12:29 <ddarius> That's what I just said.
15:12:47 <conal> oh yeah
15:12:52 <conal> fooled me
15:13:00 <roconnor> hmmm
15:13:05 <roconnor> is waiting for a wrong?
15:13:05 <ddarius> But I think it can be fixed by using the assumption that a and b are identical modulo termination.
15:13:13 <conal> right.
15:13:40 <conal> yeah.  that's the point of unamb.  as soon as one terminates, we know the other one, modulo termination.
15:13:59 <conal> that's why it's RT
15:14:25 <roconnor> oh, of course waiting for 'a' is wrong
15:14:27 <roconnor> duh
15:14:31 <roconnor> we want to return b right away.
15:15:23 <conal> hm.  as ddarius said, it defines unamb in full generality.
15:15:43 <conal> including 'unamb 2 3'
15:15:50 <necroforest> if i have a type  "MyType a", how can I code "MyType a is an instance of 'Show' iff a is an instance of Show"?
15:16:10 <conal> so does por + seq break RT?
15:16:20 <ddarius> No, because my definition is wrong.
15:17:02 <mdmkolbe> necroforest: you can add "deriving (Show)" to the end of your data declaration if you want Haskell to do that automatically or ...
15:17:11 <roconnor> ddarius's definition of unamb fails to return b in the case of _|_ `unamb` b
15:17:26 <mdmkolbe> necroforest: declare your instance as "instance (Show a) => Show (MyType a) where " etc.
15:18:32 <conal> oh ...
15:18:47 <mdmkolbe> necroforest: for example "Maybe" does the same thing.  You'll see that it is an instance of show iff the thing it wraps is a show (try ":info Maybe" at ghci command line to see this)
15:19:02 <necroforest> ok thanks
15:19:20 <necroforest> I was doing instance Show (Show a => MyType a)
15:19:27 * roconnor believes ddarius's theorem that non-RT functions cannot be built form RT pieces.
15:19:41 <roconnor> all that remains to prove is that unamb is necessarily non-RT.
15:19:54 <roconnor> (over the entire domian of it's type)
15:19:58 <roconnor> its
15:20:20 <Peaker> I am trying to compile the Tetris thing: Couldn't match expected type `reactive-0.9.0:FRP.Reactive.Internal.Reactive.EventG reactive-0.9.0:FRP.Reactive.Reactive.ITime Piece' against inferred type `Event Piece
15:20:31 <conal> Peaker: version skew
15:20:41 <conal> Peaker: clean & rebuild your libs
15:20:41 <mdmkolbe> necroforest: FYI if you have both "a" and "b" (e.g. Either), then you'll need "instance (Show a, Show b) => Show (Either a b) where"
15:20:50 <necroforest> right
15:20:59 <Peaker> conal: Okay, how is it importing from 2 versions simultaniously?
15:21:00 <conal> roconnor: using what definition of unamb off of its domain (preconditions)?
15:21:31 <conal> Peaker: maybe reactive-glut has one version and reactive-fieldtrip has another.
15:21:36 <ddarius> roconnor: Yeah, I guess you need to reify the restriction on unamb's domain someway to even consider a por based definition, otherwise there is no way to enforce the fact for a putative por based definition either.
15:21:36 <conal> Peaker: just a guess
15:22:05 <Peaker> conal: I think I mixed cabal install with darcs versions. I'll try to install from the darcs repos, not sure how to "clean" the existing installs
15:22:28 <roconnor> conal: using any definition of unamb off it's domain.  My claim is very non-obvious and may not even be true.
15:22:47 <conal> Peaker: hm.  how about a 'cabal update' followed by a 'cabal install'?
15:23:21 <Peaker> conal: that's what I did, but I have darcs versions installed too
15:23:22 <necroforest> mdmkolbe: I got it for Show, but when i try it for num, i.e instance Num a => Num (MyType a) where,  the compiler gives me an error: Cannot construct infinite type a = MyType a
15:23:51 <conal> Peaker: oh, okay.  hm.  i thought the hackage versions are up to date, w.r.t version.  maybe not.
15:24:14 <Peaker> darcs/reactive-fieldtrip seems to be missing a dependency on containers in its cabal file
15:24:20 <conal> i sometimes bump up a version number right after uploading to hackage, so i won't forget next time.  maybe a bad practice.
15:24:34 <Peaker> oops, no that was my change
15:25:22 <mdmkolbe> necroforest: I'm going to guess you have an implementation error in your implementation of Num.  Most likely you forgot to add a MyType contructor around one of your return values or you forgot to unwrap the MyType constructor from one of your inputs.  I don't think the problem would be with the "instance" line inself (though it's body might have a problem)
15:25:23 <byorgey> http://math.andrej.com/2008/11/17/not-all-computational-effects-are-monads/
15:25:29 <Peaker> conal: you might have bumped the versions correctly, I am not completely sure (I have all this installed at my work computer too, so I may confuse what I've done where)
15:25:30 <lambdabot> Title: Mathematics and Computation Â» Not all computational effects are monads, http://tinyurl.com/5tl44c
15:25:39 <necroforest> mdmkolbe, i think you're right
15:26:11 <wchogg> Peaker:  I was having that version skew problem this morning when I was writing it.  I just did cabal install --reinstall on all the libs & then it was all fine, oddly enough.
15:29:40 <Peaker> wchogg: cute!
15:30:39 <ddarius> byorgey: Andrej is misunderstanding monads and/or computational effects (or how it is used in relation to monads).
15:31:01 <Peaker> wchogg: I have some suggestions for refactorings (that may or may not be good ideas...)
15:31:05 <byorgey> ddarius: how so?
15:31:08 <ddarius> "it" = the term "computational effects"
15:31:09 <byorgey> ddarius: (I'm not disagreeing)
15:31:40 <wchogg> Peaker:  They probably are.  I rewrote chunks of it a number of times so it's pretty messy.
15:32:09 <roconnor> byorgey: I think luqui is right.  Those all look like effects that can be modeled by monads.
15:32:16 <ddarius> byorgey: Monads -model- -languages supporting- a specified computational effect.  Both of those examples can be modelled.
15:32:24 <Peaker> wchogg: the first thing that comes to mind is the explicit passing of the Board in a few functions, if you have the Board be the last argument, you can be inside the (Board->) reader, and not pass it around explicitly
15:32:34 <byorgey> ok, makes sense. I agree.
15:32:41 <Peaker> wchogg: I've only now started reading the code..
15:32:58 <ddarius> With the first example he wants to -add- an effect to Haskell.  Monads don't add effects to Haskell.
15:33:13 <mdmkolbe> Does FRP play nice with video output?  I mean wouldn't the real-time requirements of video (avoiding jitter and keeping sync with audio) be a potential source of problems?  Also I would think you wouldn't want to keep blasting full video pixels through your FRP pipe for overhead reasons.
15:33:33 * roconnor wonders if catch is RT.
15:33:38 <Peaker> wchogg: if guardTransform took Board last, then: movePiece (SpecialKey KeyRight) b = guardTransform b moveRight   can become:  movePiece (SpecialKey KeyRight) = guardTransform moveRight   -- and then you can maybe map (SpecialKey) to moveRight and not repeat the guardTransform
15:33:52 <roconnor> I supsect catch is not RT, but I should find an example.
15:33:53 <ddarius> roconnor: It, or something like it is, but it is not implementable without effects.
15:34:04 <roconnor> ddarius: oh wow.
15:34:05 <ddarius> @google "sequentially realizable functionals"
15:34:07 <Peaker> mdmkolbe: reactive-fieldtrip shows that you can have nice snappy 3d animations with FRP
15:34:13 <lambdabot> http://citeseer.ist.psu.edu/611067.html
15:34:13 <lambdabot> Title: Games on graphs and sequentially realizable functionals - CiteSeerX
15:34:33 <Peaker> mdmkolbe: and we were discussing earlier a possible optimization of passing differentials instead of actual results (although it is not clear how to do that)
15:35:12 <roconnor> ddarius: do haskell programs sastify some other property that catch does not?
15:35:37 <Peaker> wchogg: maybe if Position was a newtype, you could use a Bounded instance instead of vertbounds,horizbounds
15:36:44 <mdmkolbe> Peaker: by video I mean like recorded video, not animations, so I think there is a much higher bandwidth happening here.
15:37:29 <Peaker> wchogg: I think you can generate all of the tetris shapes by generating all of the possible shapes with 4 positions in them that are all adjacent to at least one other position
15:37:48 <vixey> Peaker, why would you do that ...
15:38:07 <ddarius> @google "When is a functional program not a functional program"
15:38:11 <lambdabot> http://portal.acm.org/citation.cfm?id=317775
15:38:11 <lambdabot> Title: When is a functional program not a functional program?
15:38:25 <Peaker> vixey: to replace 8 lines of error-prone definitions with a couple that capture the spirit of tetris shapes? :)
15:38:53 <vixey> they are correct already and I bet you can't do this in < 8 lines
15:39:21 <ddarius> roconnor: That paper, which is available for free elsewhere, describes some examples and the theory.
15:40:16 <shapr> dons: Neither  sti.co.gatech.edu nor sti.gatech.edu work
15:40:25 <shapr> dons: Also, when I saw  their site previously they only had 4 QS20 blades.
15:40:32 <ddarius> roconnor: I don't think there is a good non-tautological answer to your question.
15:41:09 <wchogg> Peaker:  That's a lot of good suggestions.  I'm not sure of a really clean way to do that last one though.
15:41:21 <SamB> catch didn't sound RT to me ...
15:41:30 <shapr> dons: Ah, it's sti.cc.gatech.edu
15:45:27 <conal> i have an ubuntu-newbie question: is there a way in a shell to activate a file using whatever associatin the file browser uses?  e.g., view a pdf?
15:45:29 <ddarius> SamB: Here's a different example:  (Ignoring seq so that \_ -> undefined === undefined) There are three partial functions (() -> ()) -> ()) namely t _ = (), m f = f (), and b f = b f, a function g such that g t = False, g m = True, and g b = undefined is possible, but not possible in, say, the STLC.
15:46:14 <ddarius> g just returns True if the function it's passed uses it's argument.
15:46:27 <mdmkolbe> conal: #ubuntu should be able to answer that one
15:46:39 <conal> i'm too new to linux to know whether my question is even ubuntu specific.
15:46:45 <conal> mdmkolbe: thx
15:47:07 <roconnor> ddarius: ah, I suppose that Haskell semantics under some sort of permuation of nested case statements, and catch would break that property.
15:47:07 <Nafai> conal: gnome-open
15:47:16 <conal> Nafai: thanks!
15:47:27 <roconnor> ddarius: sound like a good property?
15:47:41 <roconnor> other than being vague
15:47:48 <ddarius> roconnor: I can't parse that sentence.
15:47:55 <mdmkolbe> conal: #ubuntu is fairly newbie friendly.  so general questions on ubuntu are fair game even if they aren't specific to ubuntu
15:48:08 <ddarius> roconnor: I think you are missing a word (?)
15:48:12 <conal> mdmkolbe: glad to know.  thanks for the tip.
15:48:19 <Peaker> any nicer way to implement: http://hpaste.org/12148
15:48:25 <roconnor> ddarius: ah, I suppose that Haskell semantics under invarient under some sort of permuation of nested case statements, and catch would break that property.
15:48:40 <roconnor> ddarius: sorry, editing error
15:48:58 <roconnor> ah
15:49:05 <roconnor> still didn't edit it correctly
15:49:10 <roconnor> but at least I added a word
15:49:22 <byorgey> s/under/are/?
15:49:22 <roconnor> semantics are invarient under
15:50:12 <Samy> INVARIANT
15:50:22 <shapr> hah
15:50:24 <shapr> pedant
15:51:09 <byorgey> Peaker: that's nice and elegant, although it may not be optimal efficiency-wise due to left-nested ++'s
15:51:59 <byorgey> hm, on second thought, you have to do the map anyway
15:52:00 <roconnor> @spell invarient
15:52:20 <byorgey> reasoning about this sort of thing is tricky =P
15:52:32 <Peaker> byorgey: I could pass the end-list case as an arg so I don't need ++
15:52:36 <Peaker> byorgey: but that's ugly
15:52:46 <byorgey> Peaker: agreed.
15:52:56 <byorgey> Peaker: well, your code is certainly what I would write.
15:53:14 <byorgey> I'd say, use it unless you really need to optimize it further.
15:53:45 <conal> Peaker: i think dons's simple dlist lib automates that optimization.
15:53:53 <Samy> Yes.
15:54:19 <conal> Peaker: coincidentally, considering our earlier discussion, dlist is a sort of "differential representation" of lists.
15:54:36 <conal> Peaker: not not differential in the same sense.
15:54:42 <Peaker> conal: oh, cool, where can I read about that?
15:54:48 <conal> @hackage dlist
15:54:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
15:54:56 <Peaker> conal: so it IS differential in the same sense? :-)
15:54:59 <conal> lambdabot is my goddess
15:55:09 <conal> Peaker: ??
15:55:15 <Peaker> conal: double negative :)
15:55:21 <conal> Peaker: oh!
15:55:22 <conal> lol
15:55:29 <ikkebr> is there any easy way for me to remove elements from one list that belong to another list?
15:55:39 <ddarius> :t difference
15:55:40 <lambdabot> Not in scope: `difference'
15:55:50 <conal> :t (//)
15:55:51 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
15:55:55 <conal> hm.
15:55:56 <ddarius> :t (\\)
15:55:56 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:55:57 <conal> :t (\\)
15:55:58 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:56:07 <conal> ddarius: we used unamb!
15:56:25 <ikkebr> thanks ddarius
15:57:27 <ddarius> :t 1 + 0.4
15:57:28 <lambdabot> forall t. (Fractional t) => t
16:05:37 <Peaker> I wanted to prove vixey wrong and write a short generator for all the tetris shapes, but now I gotta eliminate repeating rotations, its not gonna fit in 8 lines :)
16:08:35 <ddarius> Couldn't you make a table in less than 8 lines?
16:08:58 <roconnor> @type nubBy
16:08:59 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
16:09:27 <FunctorSalad> encode a block as a triple of movements, like (r,d,r)
16:09:30 <roconnor> Peaker: nubBy equivalentByRotation ?
16:09:37 <FunctorSalad> should be one line :)
16:10:06 <Peaker> FunctorSalad: interesting ;)
16:10:10 <FunctorSalad> roconnor: I thought that too but won't the naive thing check all 2^16 possible shapes on the 4x4 grid?
16:10:14 <Peaker> FunctorSalad: still need roconnor's nubBy
16:10:47 <FunctorSalad> is there a faster algorithm for factoring a set by a group action and obtaining a set of representatives?
16:11:03 <roconnor> Peaker or is the hard bit defining equivalentByRotation in one line?
16:11:13 <Peaker> roconnor: I think that's harder
16:11:28 <FunctorSalad> Peaker: I just meant listing the seven triples ;)
16:11:32 <ddarius> What is the representation?
16:11:35 <Peaker> though I think if you take FunctorSalad's idea, eliminate the first of the 3 (as it doesn't matter which way you start), then you only get 1 shape you need to eliminate (square)
16:12:07 <Peaker> FunctorSalad: Yeah I think I'll do that
16:12:18 <roconnor> equivalentByRotation x y = x `elem` sequence [id, left, right, left . left] y
16:12:46 <roconnor> in fact, screw right.  right = left . left . left
16:12:58 <FunctorSalad> > 7 * (length "(r,d,r),") -- should fit in one line
16:13:00 <lambdabot>   56
16:13:10 <roconnor> take 4 (iterate (left .) id)
16:14:43 <FunctorSalad> Peaker: true, the first direction doesn't matter
16:15:09 <Peaker> FunctorSalad: Yeah as soon as I get it to compile again I'll do that
16:16:24 <FunctorSalad> ddarius: for the factoring problem? good question
16:17:17 <FunctorSalad> in gap groups are represented either as a subgroup of S_n or by generators and relations, ISTR
16:36:35 <Peaker> wchogg: hey, you there?
16:37:32 <Peaker> conal: wchogg is using "dropPiece :: Behavior Piece -> Anim (Piece,Board) ; dropPiece randomPiece ui = accumB (straight startPos red, emptyBoard) $ ..."   I am wondering how I might change this to start with a random piece
16:39:13 <roconnor> @type randoms
16:39:14 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
16:40:07 <Peaker> randomPiece is a behavior containing random pieces already..
16:40:09 <roconnor> Peaker: can you pass in a sequence of random pieces generated by randoms?
16:40:29 <roconnor> oh
16:42:27 <Peaker> I guess I could the accumB here shouldn't need an initial piece
16:43:31 <roconnor> pass in undefined :)
16:44:43 <Peaker> but I also need some before-time-existed event then
16:44:49 <Peaker> to set a random piece
16:44:54 <Peaker> (to snapshot the given behavior)
16:49:40 <conal> Peaker: i just tuned in again.
16:49:58 <conal> Peaker: maybe irrelevant, but there *is* a before-time-existed event.  it's "pure"
16:50:24 <Peaker> conal: ah, cool, maybe I can use that. I am trying to get it to start with a random piece
16:51:13 <sinelaw> Peaker, ?
16:51:22 <Peaker> sinelaw: working on the FRP tetris
16:51:28 <sinelaw> I was trying out something from conal's blog
16:51:33 <Peaker> sinelaw: of wchogg's
16:51:34 <sinelaw> could this be a ghc bug?
16:51:47 <sinelaw> Prelude Control.Monad.Instances Control.Arrow> fmap (+1) undefined
16:51:48 <sinelaw> *** Exception: Prelude.undefined
16:51:48 <sinelaw> Prelude Control.Monad.Instances Control.Arrow> second (+1) undefined
16:51:48 <sinelaw> (*** Exception: Prelude.undefined
16:51:54 <sinelaw> why the extra ( ?
16:52:01 <EvilTerran> ahh
16:52:18 <EvilTerran> that's because of laziness
16:52:23 <EvilTerran> ?src (->) second
16:52:24 <lambdabot> second f = id *** f
16:52:30 <EvilTerran> ?src (->) (***)
16:52:30 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
16:52:36 <conal> sinelaw: fmap is stricter than snd.
16:52:40 <conal> *second
16:52:44 <conal> i didn't know until recently.
16:52:51 <sinelaw> conal, i'm reading your blog
16:53:01 <conal> sinelaw: which post(s)?
16:53:03 <sinelaw> i'm just wondering what causes the extra ( in that case
16:53:10 <EvilTerran> sinelaw, (***) does a delayed match on its tuple input, so "second" does too
16:53:13 <conal> sinelaw: strictness difference.
16:53:23 <sinelaw> actually i'm not sure who wrote this blog :) http://netsuperbrain.com/blog/posts/analysis-of-lazy-stream-programs/#more-74
16:53:27 <conal> i thought that second == fmap, but not so.
16:53:29 <lambdabot> Title: Less Sugar/More Meat Â» Blog Archive Â» Analysis of lazy-stream programs., http://tinyurl.com/5j5y3a
16:53:34 <conal> yeah -- camio's blog
16:53:42 <sinelaw> ah ok
16:53:48 <EvilTerran> sinelaw, which means evaluation gets as far as knowing that there's a pair in the value, and hence printing a ( in the process of showing this pair
16:53:57 <EvilTerran> before hitting the "undefined" and erroring out
16:54:13 <EvilTerran> > (undefined, undefined) -- it's like this
16:54:14 <sinelaw> EvilTerran, that's weird
16:54:14 <conal> because second is less strict than fmap
16:54:14 <lambdabot>   (* Exception: Prelude.undefined
16:54:23 <EvilTerran> > (True, undefined) -- or even like this
16:54:24 <daf> hmm, why the ~?
16:54:24 <lambdabot>   (True,* Exception: Prelude.undefined
16:54:36 <EvilTerran> daf, because they can?
16:54:40 <sinelaw> ah, it's returning (undefined, undefined)?
16:54:45 <conal> yeah
16:54:45 <daf> EvilTerran: does it help?
16:54:45 <EvilTerran> sinelaw, exactly
16:54:51 <sinelaw> ok
16:54:55 <daf> EvilTerran: or rather, what does it change?
16:54:58 <EvilTerran> daf, well, yes; as we can see above, it results in a more defined value being returned
16:55:04 <conal> and luqui pointed out that a functor law prevents fmap from being non-strict on pairs
16:55:06 <EvilTerran> (_|_, _|_) instead of _|_
16:55:16 <conal> fmap id == id
16:55:23 <EvilTerran> conal, ah, of course
16:55:55 <conal> and ryan ingram pointed out a related issue on my recent "proofs ..." blog post.
16:55:59 <daf> EvilTerran: hmm, how does that follow?
16:56:19 <conal> which i can fix with laziness, but i'd probably break that fmap id law.
16:56:33 <EvilTerran> > let f (x,y) = () in f undefined -- here, the pattern-match in f fails before it even gets as far as evaluating the body
16:56:34 <lambdabot>   * Exception: Prelude.undefined
16:56:57 <EvilTerran> > let f ~(x,y) = (x,y) in f undefined -- here, the pattern-match is deferred until the names in the pattern are forced
16:56:58 <lambdabot>   (* Exception: Prelude.undefined
16:57:07 <daf> > let f (x,y) = () in f (undefined, undefined)
16:57:08 <lambdabot>   ()
16:57:17 <daf> > let f (x,y) = (x, y) in f (undefined, undefined)
16:57:18 <lambdabot>   (* Exception: Prelude.undefined
16:57:30 <Peaker> could be nice if I got some sort of traceback about who is using my undefined
16:57:39 <daf> it still returns a typle with an error thunk there, and the pattern isn't irrefutable
16:57:50 <EvilTerran> daf, that's because the pattern isn't forcing a _|_
16:58:10 <sinelaw> Peaker, yeah in general i find this stuff hard to debug
16:58:17 <EvilTerran> it only forces as far as it needs to to work out if the pattern matches or not
16:58:24 <EvilTerran> and then the variables in the pattern point to thunks
16:58:31 <Peaker> I have no idea which Behavior or such is trying to read my undefined
16:58:37 <sinelaw> Peaker, the lack of "repr" is annoying
16:58:49 <daf> sinelaw: isn't show repr?
16:58:59 <Peaker> sinelaw: deriving Show gives you a __repr__ for free (you don't have to define it like in Python)
16:59:00 <sinelaw> daf, no, show fails
16:59:13 <Peaker> It would be nice to have DebugShow on functions, though
16:59:20 <sinelaw> yes, that's what i mean
16:59:31 <sinelaw> and for undefined
16:59:33 <Peaker> sinelaw: the error you get is like a show ;)
16:59:47 <sinelaw> no, it would have been: (undefined, undefined)
16:59:59 <sinelaw> instead of the (*** Exception: ...
17:00:01 <daf> undefined is not a value
17:00:16 <sinelaw> daf, i know, i meant a debug shower
17:00:18 <EvilTerran> that would mean big problems for the semantics, i think
17:00:23 <EvilTerran> although it would be interesting to try
17:00:33 <sinelaw> it's for debugging
17:00:37 <Peaker> sinelaw: consider: def f(): assert False ;  print (f(), f())
17:00:38 <daf> a show that catches the exception, and looks at the text? :)
17:00:40 <EvilTerran> you could write a transformer on TH's parse trees
17:00:57 <EvilTerran> although a really arcane one would be necessary
17:00:58 <Peaker> sinelaw: Python can't show that either
17:01:12 <sinelaw> Peaker, but it has tracebacks
17:01:17 <sinelaw> that's the other problem :)
17:01:27 <Peaker> Yes, I agree a traceback is useful, but not showing undefineds via DebugShow :)
17:01:30 <EvilTerran> i'm not sure how (or how well) one could recover from hitting an undefined/error/etc
17:01:43 <sinelaw> ok, so i guess the missing thing is a good traceback
17:01:45 <Peaker> EvilTerran: it would be nice to have some debug information about *who* was reading the undefined
17:01:57 <daf> EvilTerran: oh, I think I see now
17:02:28 <daf> EvilTerran: cheers
17:02:29 <EvilTerran> Peaker, yeah - maybe a code transformer or something that wove a stack trace through the program as an additional parameter?
17:02:59 <EvilTerran> seeing as that becomes quite hard to determine after compilation
17:03:31 <daf> sinelaw: I think in practice, you can sidestep the problem by using error instead of undefined
17:04:19 <daf> and the ghci debugger is useful
17:04:28 <daf> though a bit tricky to get the hang of, I think
17:07:18 <chylli> I want to get a string consisted of "!$%", so I set arbitrary = elements "!$%"
17:07:22 <chylli> but I got :
17:07:33 <chylli> Falsifiable, after 0 tests:
17:07:52 <chylli> is that express ok ?
17:08:39 <chessguy_> 'evening
17:08:51 <Lemmih> Phew. Jhc is now on hackage. Never have I cabalised such a large package.
17:09:27 <Peaker> EvilTerran: how do you add that in a code transformer?
17:09:28 <EvilTerran> in the version of TH with ghc 6.10, you could write a function undef = do Loc{ loc_filename = file, loc_start = (line,_) } <- location; stringE $ "undef at '" ++ file ++ "' line " ++ show line
17:09:35 <EvilTerran> Peaker, er, with difficulty =/
17:09:47 <EvilTerran> , let undef = do Loc{ loc_filename = file, loc_start = (line,_) } <- location; stringE $ "undef at '" ++ file ++ "' line " ++ show line in $undef
17:09:48 <lunabot>  luna: GHC stage restriction: `undef'
17:09:52 <EvilTerran> ah, of course...
17:10:05 <Peaker> EvilTerran: I want each *use* of undefined to get recorded too, doesn't that only record the "maker" of the undefined?
17:10:26 <gwern> Lemmih: you cabalized jhc?
17:10:27 <gwern> impressive
17:10:36 <gwern> Lemmih: how on earth did you convince meachem to allow it?
17:10:49 <EvilTerran> Peaker, yes, that's a lot harder
17:10:58 <hackage> Uploaded to hackage: jhc 0.5.20081118
17:11:04 <Lemmih> gwern: Oops. I asked for forgiveness, not permission.
17:11:12 <daf> :D
17:11:21 <chessguy> Lemmih: gwern has experience with that
17:11:23 <Peaker> EvilTerran: unless you're inside ghc
17:11:33 <gwern> Lemmih: a man after my own heart
17:11:48 <sinelaw> Peaker, you want to find out in runtime?
17:11:49 <Lemmih> gwern: Meacham doesn't like cabal?
17:11:55 <Peaker> sinelaw: what?
17:12:03 <gwern> but what do you intend to do with all the patches? I'd normally react with horror at the thought of a fork, but it's not like jhc is really being developed...
17:12:06 <gwern> Lemmih: with a passion
17:12:07 <Peaker> conal: can you help me fix Tetris to get its initial state to be random too?
17:12:07 <chessguy> gwern has stolen some of my stuff to put on hackage without asking forgiveness _or_ permission
17:12:14 <gwern> he hates it even more than droundy
17:12:17 <EvilTerran> Peaker, i think it'd be possible as a sufficiently sophisticated preprocessor, anyway, just fiddly
17:12:33 <gwern> chessguy: er... your chosen license was prior permission?
17:12:38 <Peaker> EvilTerran: how can you catch errors on pure value usage in order to record that? unsafePerformIO?
17:12:45 <EvilTerran> Peaker, or as a back-end to yhc that wraps an (or any) existing backend with something that weaves stack traces
17:12:59 <gwern> huh. the last patch to jhc was back in april. and... it was mine?
17:13:01 <chessguy> gwern:  i hadn't even gotten as far as licensing it. it wasn't near production ready
17:13:16 <EvilTerran> Peaker, linear implicit parameters? :P
17:13:44 <Lemmih> gwern: I'll fork it if he doesn't like it. There are a couple of other things he and I disagree on.
17:14:08 <chessguy> Lemmih:  this is NOT a good path to go down
17:14:10 <EvilTerran> or conventional parameters, seeing as this'd only be an intermediate step, so it doesn't need the implicit parameter syntactic sugar
17:14:16 <gwern> Lemmih: such as?
17:14:33 <Lemmih> chessguy: He isn't actively developing it.
17:14:36 <chessguy> one step above software piracy, as far as i'm concerned
17:14:43 <chessguy> Lemmih:  that's his prerogative
17:15:02 <gwern> other people worked on it too; do they not count?
17:15:13 <gwern> (heck, I've patches in JHC)
17:16:12 <Lemmih> chessguy: Should I let this excellent open source project die because the author is disagreeable?
17:16:18 <conal> Peaker: i'm focusing on something else right now.  maybe wchogg would enjoy collaborating.
17:16:20 <chessguy> if he's the person that comes to mind when you think of the author of JHC (which is obviously the case since you were surprised he let it be cabalized), he has a majority share
17:16:27 <Peaker> conal: ok, thanks
17:17:23 <EvilTerran> the concept of what "share" someone has of an open-source project is tenuous and relative at best
17:17:24 <chessguy> if haskell is so desperate for good libraries that they're willing to publish them against their authors' permission, they are in sad, sad shape indeed
17:17:24 <bbs> sbahra: you ditched freebsd-haskell all together?
17:17:26 <gwern> chessguy: I only meant that very few people have commit bits for jhc
17:17:34 <gwern> I am unsure he is the author or chief dev
17:17:43 <gwern> samb was doing a lot of jhc work a while ago
17:18:10 <Lemmih> gwern: StringTable.Atom comes to mind.
17:18:30 <chessguy> backpedal all you want
17:18:35 <gwern> Lemmih: pardon?
17:19:05 <Lemmih> gwern: You asked what Meacham and I disgreed on.
17:19:33 <gwern> Lemmih: oh. what is StringTable.Atom?
17:19:34 <roconnor> I thought the whole point of dvcs like darcs is to allow things to fork!
17:19:42 <EvilTerran> http://xkcd.com/438/
17:19:42 <lambdabot> Title: xkcd - A Webcomic - Internet Argument
17:19:49 <roconnor> forking is very good in principle
17:20:06 <Lemmih> chessguy: I've made significant contributions to jhc and will continue to do so. I've even marked myself as the maintainer.
17:20:10 <gwern> roconnor: dvcs makes forking easier in one particular technical aspect; it does little about all the others
17:20:33 <roconnor> gwern: what others?
17:20:40 <gwern> roconnor: although I've heard that github is supposed to make the other aspects almost as easy, although I dunno
17:21:12 <Lemmih> chessguy: I see no problem in picking up and continuing a "dead" project.
17:21:14 <gwern> roconnor: control of URLs, 3rd party dev support (such as mindshare of packagers), your own developer community, confusion among consumers...
17:21:40 <gwern> (bugger, DrIFT changed darcs urls. how annoyinig)
17:22:27 <chessguy> Lemmih: i just think we're going down a bad path
17:22:58 <Lemmih> chessguy: The only other option is to let it die.
17:23:34 <lispy> There seems to be a strong correlation in the community between cabal acceptance and project life
17:23:52 <chessguy> i'd rather that than get closer to software piracy as a community
17:23:59 <lispy> At this point in time to reject cabal is to start working on the coffin for your project
17:24:35 <gwern> (I've already cablized DrIFT, but that's just a local branch)
17:24:38 <lispy> chessguy: so, is making a debian package for a project stealing too?
17:25:43 <lispy> chessguy: if not, how and where do you draw the distinction?
17:25:45 <Lemmih> chessguy: Are you thinking legally or morally?
17:25:55 <dejones> http://hpaste.org/12150 -- I am having a parse error (possibly indentation) that I don't understand, any help would be greatly appreciated.  :)
17:26:04 <chessguy> Lemmih:  morally
17:26:12 <chessguy> lispy:  if you have the author's permission? no
17:26:45 <daf> I never asked the author's permission before uploading things to Debian
17:26:56 <daf> and I'm sure that's true in nearly all cases
17:27:02 <chessguy> or if the license allows it
17:27:05 <lispy> chessguy: why is it important to get the authors permission before distributing open source software?
17:27:28 <daf> well, surely the license is exactly that: permission
17:27:36 <chessguy> sure
17:27:37 <gwern> dejones: 'else foo <- bar'?
17:27:45 <lispy> chessguy: I'm not saying either point of view here (your's or gwern's) is right or wrong.  But I certainly don't undertand what the debate is about.
17:28:02 <chessguy> are you saying that in this case the license allowed it, but that he wouldn't have gien permission?
17:28:18 <chessguy> lispy:  it's about uploading things on hackage without the author's permission
17:28:31 <Saizan_> dejones: you need another do after the else
17:28:41 <daf> chessguy: what's the difference between hackage and debian?
17:28:43 <lispy> chessguy: Yes, I read the scroll back.  But, I still don't understand what the cruxt of this debate is.
17:28:44 <dejones> gwern: Hmm, didn't work.
17:28:52 <dejones> Saizan_: Oh?  Why..?
17:29:06 <dejones> Saizan_: Nvmd.  :)
17:29:07 <gwern> dejones: no I mean inside an if-then-else is normal haskell syntax, there is no do syntax
17:29:38 <chessguy> daf:  i'm assuming the license in this particular library matched the author's wishes
17:29:45 <Saizan_> dejones: because you've to start a new do-block
17:29:54 <lispy> chessguy: what is your fundamental objection?  Is it that gwern made available your code without politely running it by you first?  or do you have a more general complaint?  From listening I have this feeling that your objection is more personal.  That someone did something with your project that you didn't object to but that you wanted to be made aware of.
17:30:07 <Saizan_> dejones: the outer one doesn't automatically extend inside if/then/else
17:30:28 <gwern> chessguy: although it hurts my general position, I must say it is true that many people don't understand what they're granting permission to do with many licenses
17:30:33 <daf> chessguy: well, software licenses are crude things
17:30:43 <dejones> Saizan_: Do I need a do-block inside the if and inside the else?
17:30:49 <daf> they can hardly exactly encompass the author's wishes
17:30:51 <lispy> chessguy: take droundy for example.  he didn't want darcs to use cabal, but he was fine with gwern uploading a cabalized darcs to hackage.
17:30:58 <chessguy> lispy:  my fundamental objection, as stated multiple times, is that we're too quick to put things on hackage without the author's permission, either explicitly, or according to the library's license
17:31:04 <gwern> he was? I didn't remember it that way
17:31:04 <daf> but you choose the tradeoff at the point when you choose the license
17:31:06 <dejones> Saizan_: Just inside the else, correct?
17:31:30 <lispy> gwern: well, when I brought it up last he seemed to encourage it
17:31:42 <daf> chessguy: Hackage only accepts packages under licenses which would allow them to be uploaded to Hackage
17:31:47 <lispy> gwern: he said that was the proper way for cabal support to work...that you use it as a package system like debian packages
17:31:53 <Saizan_> dejones: inside the first else, also you should indent both elses more than the corresponding if
17:32:11 <dons> http://www.reddit.com/r/haskell/comments/7e0bx/jhc_the_whole_program_optimizing_haskell_compiler/ sweet
17:32:11 <daf> chessguy: so I think the legal aspect is moot
17:32:13 <lambdabot> Title: JHC: the whole program optimizing Haskell compiler based on the lambda cube: now ..., http://tinyurl.com/5d4yaa
17:32:16 <dons> Lemmih: mega sweet
17:32:19 <gwern> I rememebr his view about my darcs-cabalized as being grudging at best - since he knew there was not really anything he could do to stop me short of some sort of new hackage policy
17:32:39 <chessguy> daf:  i could care less about the legal aspect. or rather, if my concerns are met, then the legal aspect would be moot
17:33:05 <dejones> dons: lambda cube?
17:33:08 <daf> a license that would require your permission would not be free software
17:33:25 <gwern> daf: I remember Tuomov of Ion doing a license like that :)
17:33:29 <Lemmih> dons: I'm taking it down. It'll be back up with a new name soonish.
17:33:30 <dejones> dons: JHC is based on the lambda cube...?  is that a joke or is there a such thing as the lambda cube?  heh.
17:33:38 <lispy> chessguy: I still do not see the difference between someone packaging for debian versus hackage, with or without permission.  Do you agree that these are similar?
17:33:40 <dons> dejones: the dependently typed intermediate language.
17:33:41 <gwern> dejones: no, it's real. wiki it
17:33:43 <daf> gwern: indeed :)
17:33:51 <gwern> Lemmih: incidentally, I can't cabal-install jhc
17:33:53 <dejones> dons, gwern: thanks.  :)
17:33:56 <dons> get a copy of barendreght. totally worth while.
17:33:57 <daf> gwern: and everybody stopped using it
17:33:58 <chessguy> daf:  i'm only suggesting explicit permission for software that doesn't have a license
17:34:04 <gwern> Lemmih: is it meant for 6.10?
17:34:21 <Lemmih> gwern: Yes, ghc-6.10. Send me the build log?
17:34:25 <gwern> daf: well, the last I looked at the debian popcon there was a a small group still getting by on the old package
17:34:26 <daf> chessguy: if it doesn't have a license, I don't think it should be on hackage at all
17:34:36 <chessguy> daf:  tell gwern that
17:34:39 <daf> gwern: well, I was generalising
17:35:07 <gwern> (I wish I had 6.10)
17:35:10 <daf> but everybody I know who used ion now uses xmonad or awesome
17:35:12 <gwern> Lemmih: http://hpaste.org/12151
17:35:29 <wchogg> @seen Peaker
17:35:29 <lambdabot> Peaker is in #haskell. I last heard Peaker speak 19m 2s ago.
17:36:16 <Lemmih> gwern: Yay, it works. That package isn't meant to be build.
17:36:29 <gwern> ...
17:36:56 <dejones> Saizan_: Thanks, the indentation on the else's fixed it.  :)
17:36:57 <Lemmih> gwern: Try jhc-0.5.20081118
17:37:42 <gwern> bah, fails on syb dep
17:37:49 <gwern> (needs base 4)
17:37:57 <thoughtpolice> Lemmih: how did you get jhc to build with cabal if it uses DrIFT?
17:38:16 <Lemmih> thoughtpolice: I hooked in a custom preprocessor.
17:38:49 <Lemmih> gwern: I'll make a backwards compatible version available soon.
17:38:51 <thoughtpolice> Lemmih: ah nice. the reason I have used data.derive over drift is because it can use TH, it's nice and convenient really
17:39:04 <gwern> Lemmih: 'k
17:39:27 <gwern> Lemmih: so have you sent the patches to meachem yet?
17:39:41 <Lemmih> gwern: Nope.
17:39:47 <gwern> Lemmih: actually more improtantly did you edit configure.ac? I was going to update an url in it but I don't want to conflict
17:39:56 <roconnor> JHC is GPLed.  That means Lemmih has permission, right?
17:40:05 <thoughtpolice> yes
17:40:47 <gwern> yeah, COPYING is GPL 2
17:40:54 <gwern> (and later)
17:41:08 <Lemmih> gwern: I don't use the configure files at all.
17:41:19 <lispy> I think RMS would argue that this, potentially subservive, act of uploading to hackage is exactly the sort of user freedom he had in mind when drafting the GPL.
17:41:30 <thoughtpolice> dons: this book? http://www.amazon.com/Lambda-Calculus-Studies-Foundations-Mathematics/dp/0444875085
17:41:34 <lambdabot> http://tinyurl.com/5rxfyr
17:41:36 <gwern> great
17:41:46 <chessguy> gwern, so then why would you be so sruprised that it got cabalized?
17:41:57 <Lemmih> gwern: It seems that cabal can replace everything except the endian detection.
17:41:58 <roconnor> lispy: indeed
17:42:25 <gwern> ah, a 20k hello world. refreshing
17:42:54 <lispy> chessguy: I hope you don't think I'm being a dick and blaming the victim...but while gwern may not have been playing nicely, I hope you learned that in the future you should be very careful when you HAVEN'T yet assigned a license. :)
17:43:31 <daf> lispy: remember that GCC got forked largely because of the GCC steering committe, which included RMS, made it difficult to make some improvements
17:43:32 <gwern> chessguy: because I assumed most people were like me after a few bad experiences and wouldn't do a lengthy stretch of cabalizing - which can be very frustrating - unless they had a good chance of upstream accepting it; which combined with my impression of meachem being vocal about being anti-cabal (on -cafe, on darcs-devel/users etc.)...
17:43:33 <chessguy> lispy: agreed. i just didn't think haskell was "that kind of community"
17:44:00 <lispy> chessguy: yeah, we should ensure we play fair.  I like the Haskell community.
17:44:03 <daf> lispy: hmm, surely it's the other way around
17:44:19 <daf> lispy: it's the user, not the author that should be careful
17:44:24 <chessguy> lispy:  it's not that i necessarily think we're doing anything horrible right now, it's the direction we're moving
17:44:32 <lispy> daf: not specifiying the terms of your license is a sure fire way to have people do things you don't approve of with your source, sadly.
17:44:48 <daf> I don't believe that
17:44:52 <wchogg> Does anyone have any kind of electronic copy of Algebra of Programming by Bird & Moor?   It appears to be extremely out of print, but I still want to read it.
17:45:26 <lispy> daf: well, there is a reason why we all don't just "Public Domain" our software
17:46:26 <gwern> lispy: besides the question of whether that's even possible?
17:46:27 <Saizan_> lispy: yeah, but isn't the default "all rights reserved" with no license?
17:46:31 <lispy> daf: IMO, it mostly comes down to what expectations you have from others wrt handling your code
17:46:42 <daf> Saizan_: exactly
17:46:52 <daf> I think most people want to do the right thing
17:47:01 <chessguy> i just think everyone's so excited about getting packages up on hackage, to pump up the numbers, that they go too far
17:47:03 <daf> which means not doing things you haven't got permission to do
17:47:09 <lispy> sure, but we all disagree on the nuances of "the right thing" :)
17:47:29 <daf> I think it's fair to say that free software only works at all because people follow the licenses
17:47:47 <daf> so people respect them
17:48:02 <daf> code that doesn't have a license tends not to go anywhere
17:48:59 <chessguy> daf:  as it should be
17:49:29 <lispy> So the take home points for me: 1) We should seek aproval before posting someone else's code as a way of collaborating positively. 2) open source licenses like BSD and GLP mean that you can do it anyway.
17:49:47 <lispy> 3) Let's be a community of collaborators, please
17:50:30 <chessguy> lispy:  and err on the side of the author
17:51:32 <Lemmih> chessguy: If an author wants to wait for a stable release before publishing, fair enough. But if the author doesn't wanna play ball at all because of ideological reasons, I see no problem in going ahead.
17:52:02 <chessguy> i completely disagree
17:52:09 <chessguy> the author is still the author
17:52:43 <lispy> So should Lemmih have posted LHC instead?
17:52:58 <lispy> and I don't mean the large hadron collider either
17:53:16 <daf> I'm with Lemmih on this one
17:53:20 <Axman6> i was confused where that came in...
17:53:27 <roconnor> wait, I thought everyone agreed that what Lemmih is doing is fine?
17:53:48 <Axman6> Lemmih: what are you doing?
17:53:52 <daf> everyone except chessguy, I think
17:54:04 <roconnor> Axman6: cabalizing and hackaging jhc
17:54:05 <Lemmih> And perhaps Meacham.
17:54:17 <chessguy> roconnor:  i don't. the author doesn't want the package on hackage, and Lemmih uploaded it anyway
17:54:25 <lispy> Axman6: he cabalized jhc but he doesn't sought approvale from Meacham yet, and we have good reason to believe he would disapprove.  But, jhc is GPL'd
17:54:29 <Axman6> what licence is it under?
17:54:34 <daf> BSD
17:54:43 <roconnor> chessguy: but JHC is GPLed, so the author is okay with it.
17:54:48 <lispy> daf: are you sure, I thought somoen said GPL'd
17:54:54 <daf> Hackage says BSD
17:54:59 <daf> maybe the Hackage entry is wrong
17:55:03 <Lemmih> daf: Sorry 'bout that.
17:55:06 <Axman6> well there you go, it's under a licence that doesn't give the author any rights to stop him
17:55:10 <lispy> okay, but either way both of those licenses are fine with it
17:55:18 <daf> right
17:55:23 <Lemmih> daf: I replaced the hackage entry with an empty package.
17:55:26 <chessguy> roconnor:  yeah, that's what i don't understand. everyone's saying that he doesn't want it there, but he licensed it differently?
17:55:42 <lispy> Axman6: chessguy's point isn't about just the legality of it.  But where it means the community is heading.
17:55:47 <roconnor> if the Cabal licence is wrong, it should be fixed.
17:55:50 <Axman6> that reminds me, i need to put something on hackage once exams are over, and i'm back from the coast
17:55:53 <daf> chessguy: as I said, licenses are coarse
17:56:04 <daf> they can never exactly match your wishes
17:56:12 <Axman6> need to get that ARM emulator up
17:56:14 <roconnor> I understood that chessguy was only unhappy with people putting unlicenced code on hackage.
17:56:15 <chessguy> daf:  then we should follow the more strict of the license and the wishes of the author
17:56:38 <daf> chessguy: in that case, things like EGCS would never have happened
17:56:39 <chessguy> roconnor:  i'm unhappy with all violation of the author's desires on hackage
17:56:45 <daf> and we'd all be much the poorer
17:56:49 <chessguy> what's EGCS?
17:56:52 <Axman6> Lemmih: could always make a fork i guess :P
17:56:58 <daf> chessguy: it was a GCC fork
17:57:03 <Lemmih> Axman6: I'm planning to.
17:57:03 <daf> chessguy: it was so good that everybody used it
17:57:12 <daf> chessguy: and eventually it just got renamed to GCC
17:57:32 <roconnor> chessguy: so you'd be unhappy if putting JHC on Hackage against the authors (current) wishes even if the author had a GPL license?
17:57:48 <chessguy> roconnor:  yes
17:57:54 <daf> as people have pointed out, there is more than one author
17:58:00 <roconnor> chessguy: ah.  Now I understand the disagreement.
17:58:17 <daf> I think what Lemmih did is in the best interests of the community
17:58:46 <chessguy> daf:  but it seems clear (though i'm not familiar with the project) that there is one primary author
17:58:50 * roconnor thinks what Lemmih did was fine.
17:58:59 <lispy> Since what Lemmih is valid under the GPL, then to me the question becomes, has Lemmih implicitly created a fork?
17:59:08 <chessguy> i agree that the line does blur if there are multiple authors
18:00:01 <roconnor> lispy: perhaps techinically, but not morally
18:00:30 <roconnor> lispy: are debian packages really forks, even when they make minor code changes?
18:00:44 <ddarius> roconnor: Unlicensed code shouldn't be on Hackage at all.
18:00:47 <daf> I think I might feel differently if the original repository was still seeing active development
18:00:53 <roconnor> ddarius: yes
18:00:55 <daf> roconnor: sometimes major code changes :)
18:01:18 <lispy> We had similar issues in the darcs project.  In the end, David has now assigned project lead status to Eric Kow for now.  Eric is now using more community consensus and allowing cabal adoption for example.  No one wanted a fork and and it was painful to get to this point.
18:01:39 <chessguy> ddarius:  nobody's disputing that, though it's been violated in the past, and the violators still seem to think they didn't do anything wrong
18:02:43 <Axman6> can't unlicenced code just be accepted as being in the public domain?
18:02:45 <daf> you're talking about one incident
18:02:59 <daf> Axman6: absolutely not
18:03:02 <gwern> chessguy: if it will make you happy, I will shave my head, bathe in ashes, and bedizen myself with sackcloth and post pictures of my mortification to /b/ to express my remorse -_-
18:03:03 <roconnor> Axman6: not according to most country laws
18:03:20 <Axman6> that's lame
18:03:28 <ddarius> Axman6: No it's not.
18:03:34 <chessguy> gwern:  a simple acknowledgement that it was the wrong thing to do would more than suffice
18:03:42 <roconnor> Axman6: I understand that in most countries things become copyright the moment they are created.
18:03:57 <Axman6> sure it is, what if i invent something, and say hey, take this, do what you want with it, i don't care, really?
18:04:04 <chessguy> daf:  i may be talking about one incident, but i'd bet my pants that it's not an isolated incident
18:04:24 <daf> chessguy: well, I hope you're wrong
18:04:28 <daf> chessguy: but you can keep your pants
18:04:33 <Axman6> but i guess those laws are there to protect people who do want the protection, not those who wish not to take advantage of it
18:04:38 <ddarius> Axman6: Then you are licensing it.  What if you show someone some code you are working on and haven't yet assigned a license, do you want all of that to suddenly be public domain.
18:04:38 <chessguy> daf:  thanks :)
18:04:48 <ddarius> Axman6: You can't un-Public Domain something.
18:04:55 <roconnor> Axman6: watch http://support.creativecommons.org/videos/#gc
18:04:56 <FunctorSalad> what's the problem now? I thought it was GPLed?
18:04:56 <lambdabot> Title: Videos | Creative Commons
18:05:21 <Axman6> no i get it now, hadn't really thought about it before
18:05:26 <FunctorSalad> GPL clearly allows the user to redistribute it
18:05:51 <chessguy> FunctorSalad:  it was GPLd but the author has clearly stated that he doesn't want it on hackage
18:05:53 <daf> whether all rights reserved by default is a good thing is a large debate in its own right
18:06:12 <daf> but e.g. the GPL only works because of how copyright law does
18:06:12 <chessguy> FunctorSalad:  i'm not concerned about the legalities, but the morality
18:06:19 <Axman6> chessguy: then he should have added porvisions to the licence i guess, the GPL allows that doesn't it?
18:06:25 <FunctorSalad> chessguy: hmm...
18:06:26 <lispy> FunctorSalad: a distinction that chessguy was making was about the letter of the license and the author's wishes.  He would use to respect more than just the letter.  That is, he wants this to be a functioning collaborating community where people enjoy working together and respect each other.
18:06:31 <daf> Axman6: it doesn't, no
18:06:32 <ddarius> daf: I don't see how.  It's somewhat annoying when you can't get the original author, but the alternative is clearly far worse.
18:06:48 <daf> Axman6: you're not allowed to add restrictions to GPL software
18:06:57 <Axman6> hmm
18:06:59 <chessguy> Axioplase_:  i'm not saying the author shouldn't have done something differently, i'm talking about when you know what the author wants and violate it anyway
18:07:04 <daf> Axman6: otherwise I could take your GPL software, modify it, and add nasty restrictions
18:07:21 <daf> (you can, on the other hand, give extra permission)
18:07:31 <Axman6> daf: doesn't the GPL say that if its redistributed, it must incluse the exact same licence?
18:07:33 <FunctorSalad> lispy: I see
18:07:43 <daf> ddarius: sorry, I don't follow
18:07:55 <adu> hi
18:08:00 <Axman6> bah, fuck the GPL, bloody linux whingers -_-
18:08:11 <FunctorSalad> the author changed his mind about GPLing inbetween?
18:08:27 <daf> Axman6: more or less, yes
18:08:40 <daf> Axman6: you can only give extra permissions for the bit you have copyright over
18:08:52 <Saizan_> FunctorSalad: he just expressed his dislike of cabal in the past
18:08:59 <chessguy> i'm just saying, doing stuff like this changes the nature of the community, very sadly
18:09:00 <daf> I'm not sure he said anything about hackage
18:09:34 <Axman6> chessguy: what if it makes the community better by making great work more accessible?
18:09:42 <FunctorSalad> Saizan_: if I don't like cabal, I'm surely still happy if people for whom cabal works can get my work via cabal?
18:10:00 <daf> chessguy: what makes you so sure that something has changed?
18:10:03 <lispy> chessguy: it's a good and non-obvious point.  If you care about it, I would recommend you talk about it more and bring it to the attention of more people in the community.  You could for example blog about it and how we should strive to be better citizens.
18:10:07 <chessguy> FunctorSalad: at the cost of sacrificing the relationships within the community?
18:10:21 <ddarius> daf: The most restrictive license, namely All Rights Reserved, should clearly be the default since you can't add restrictions after the fact.  I've never heard any debate about this.
18:10:26 <chessguy> FunctorSalad:  i would say that it hasn't made the community better
18:10:33 <FunctorSalad> chessguy: I'm saying that I don't understand the author's motives
18:10:48 <chessguy> FunctorSalad: you don't have to
18:10:52 <daf> ddarius: well, in practice, authors don't have complete control over their works
18:10:57 <chessguy> they're pretty irrelevant
18:10:58 <hackage> Uploaded to hackage: jhc 0.5.20081118.3
18:10:58 <hackage> Uploaded to hackage: jhc 0.5.20081118.2
18:10:58 <hackage> Uploaded to hackage: jhc 0.5.20081118.1
18:10:58 <hackage> Uploaded to hackage: RSA 1.0.1
18:10:58 <hackage> Uploaded to hackage: SHA 1.0.1
18:10:59 <daf> ddarius: even if all rights are reserved
18:11:06 <daf> ddarius: the law has exceptions
18:11:10 <Saizan_> FunctorSalad: no-one that's arguing here has actually talked with the author about this, afaiu
18:11:23 <chessguy> lispy:  it seems nobody much cares about my little old opinion.
18:11:37 <chessguy> and maybe rightly so :)
18:11:41 <ddarius> daf: Relaxing the default assignment of rights won't give them any more rights.
18:11:46 <ddarius> s/rights/control
18:11:51 <daf> sure
18:11:58 <Lemmih> FunctorSalad: The author might be thankful for all we know (:
18:12:20 <grom358> the combination formula for n choose k is n! / k! (n -k)! .. But why is k = n for the solution at http://www.joaoff.com/2008/01/20/a-square-grid-path-problem/
18:12:20 <daf> ddarius: the question is whether you think that giving copyright holders fewer rights would be a good thing
18:12:27 <lispy> Lemmih: did you kill the upload?  Now it says thet package is empty?
18:12:31 <lambdabot> Title: A square grid path problem : Joao Ferreira
18:12:34 <chessguy> Lemmih:  but the fact that you don't know is what bothers me
18:12:38 <Lemmih> lispy: I did.
18:13:10 <lispy> chessguy: Sometimes you have to invest time in persuading people.  You've convinced me it's a valid point.
18:13:21 <adu> anyone here know much about yaml?
18:13:39 <daf> chessguy: I think I would agree with you if the particulars were different
18:13:43 <lispy> adu: nope, BTW how's it going?  I didn't see you announcing your work on darcs-users yet...what gives?? :)
18:13:47 <daf> but the context is everything
18:13:49 <chessguy> lispy:  i thought we had settled the issue of uploading someone else's work
18:13:51 <chessguy> on hackage
18:13:58 <adu> lispy: oh, am I supposed to?
18:14:02 <chessguy> i thought there were rules against it now
18:14:05 <roconnor> lispy: what convinced you?
18:14:18 <FunctorSalad> chessguy: I think second-guessing the author's motives would matter here, if we couldn't contact him
18:14:20 * adu subskrybs to darcs-users...
18:14:41 <lispy> chessguy: what you convinced me was that to be a heathly community we should consider more than just the letter of the license.
18:14:53 <FunctorSalad> the question is whether "I dislike cabal" implies "I don't want my program in a cabal repo"
18:15:08 <chessguy> FunctorSalad: well when we started the conversation, it was clear that the general opinion was that the author would be doing a back flip if he knew. it's since devolved into "we don't really konw"
18:15:31 <lispy> adu: Well, now is a good time to start making the darcs community aware of your progress and your intentions...this way we can begin the sometimes painful dance of getting your work accepted into darcs :)
18:15:46 <Lemmih> chessguy: Since I'm the maintainer, why is it his work?
18:16:06 <adu> lispy: well, I got the diff algorithm working for lines and chars, but I have not combined them yet
18:16:06 <ddarius> daf:  That's not directly relevant to what the default license should be.  However, it is indirectly relevant because you can change what "the most restrictive license" should be, and the default should be whatever that is.
18:16:06 <ddarius> Personally, as a capitalist, I think it should be All Rights Reserved.
18:16:35 <lispy> adu: yeah, but I think telling people what you've got and showing them will drum up enthusiasm and maybe even some people to help you :)
18:16:44 <adu> lispy: ok :)
18:17:00 <chessguy> Lemmih: again, i'm not familiar with the project, but the fact that he was the first person someone thought of when you uploaded it says something
18:17:03 <roconnor> Personally, as a captialist, I think all copyright matieral should be clearly labeled so.
18:17:17 <Axman6> finders keepers!
18:17:19 <Axman6> >_>
18:17:32 <chessguy> Lemmih:  i'm really talking more abstractly than this particular situation
18:17:35 * roconnor isn't really a capitalist.
18:17:48 <Lemmih> As an anarcho-capitalist, I think all claims on intellectual property are invalid.
18:17:48 <lispy> roconnor: you just play one on irc...
18:18:20 <noZone> Personally, as a complete nutter, I think the rules should apply, but only when it's most inconvenient/confusing for them to do so.
18:18:25 <lispy> Lemmih: have you thought about asking John if you can upload it?  Maybe he's okay with you doing that?
18:18:50 <Lemmih> lispy: Still waiting to hear back from him. It usually takes a while (days).
18:18:55 <chessguy> lispy:  what a novel idea
18:18:57 <lispy> oh I see
18:19:51 <chessguy> days??? the horror!!!
18:20:21 <lispy> chessguy: do you live near portland?
18:20:31 <chessguy> nope
18:20:33 <roconnor> even if John said no, I still think Lemmih should upload it.
18:20:40 <lispy> chessguy: oh, maybe I'm thinking of glguy
18:20:52 <ddarius> Getting lonely, lispy?
18:20:58 <chessguy> haha
18:21:08 <lispy> ddarius: well, since you stop coming over yeah...
18:21:23 <ddarius> lispy: I told you it was only a temporary thing.
18:21:26 <lispy> I'm just left with Korollary to mock me
18:21:42 <lispy> "Lindsay" as he calls me
18:22:15 * lispy shrugs
18:22:16 <lispy> It would be nice to meet more haskell hackers
18:22:24 <lispy> The darcs sprint was fun.
18:22:35 <lispy> I don't know when the next portland haskell hackathon is
18:22:56 <FunctorSalad> sounds scarily social, even if it's other haskellers
18:22:56 * ddarius wonders when the next Texas hackathon is... oh wait
18:23:12 <Lemmih> What does JHC stand for, btw?
18:23:26 <FunctorSalad> java haskell compiler I thought ;)
18:23:30 <dolio> John's Haskell Compiler?
18:23:38 <lispy> Just (Haskell Compiler) ?
18:23:51 <lispy> jhc :: Maybe Compiler
18:25:28 <dolio> The original announcement doesn't look like it says (based on my skimming).
18:25:49 <Axman6> jhc :: Haskell -> Maybe (HaskellExecutable)
18:26:03 <EvilTerran> i heard it was John's Haskell Compiler
18:26:10 <Axman6> compiler's gotta take input right?
18:26:15 <ddarius> I think the presumption is that it stands for John's Haskell Compiler, but I don't know if that is officially stated anywhere.
18:26:16 <dolio> Yeah, I'd always just assumed he named it after himself.
18:26:17 <EvilTerran> but that may've been speculation
18:26:35 <ddarius> Personally, I think Lennart stole the best name.
18:26:38 <EvilTerran> it might just be "j haskell compiler"
18:26:47 <ddarius> It might just be jhc.
18:26:58 <EvilTerran> like "KGS" is now the "K go server" after Keseido stopped spondoring them
18:27:11 <EvilTerran> (or whatever the K used to stand for)
18:27:43 <lispy> ddarius: what name was that?
18:27:50 <ddarius> lispy: hbc
18:28:37 <lispy> ddarius: okay a quick google search doesn't tell me what that stands for
18:28:50 <dolio> Yeah, the page doesn't say.
18:29:20 <ddarius> lispy: The Haskell B. Compiler
18:29:47 <Pseudonym> The B is for Brooks?
18:29:57 <dolio> Oh, it has the same initials as Haskell Curry.
18:30:04 <lispy> ah, cute
18:30:12 <ddarius> Pseudonym: I don't think it actually stands for anything for hbc, but that's the idea.
18:30:13 <Pseudonym> You hadn't spotted that?
18:30:15 <Pseudonym> Right.
18:30:54 <lispy> I guess you could make an incomplete compiler and call it tumeric?
18:32:02 <FunctorSalad> a continuous intermediate between a -> b -> c and (a,b) -> c ?
18:32:09 <Axman6> anyone know of any documentation on actually using memotries? i've read the theory, but i'd like some actual examples
18:32:19 <EvilTerran> ?hackage trie
18:32:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/trie
18:32:35 <ddarius> Axman6: I believe fieldtrip uses them.
18:32:47 <dolio> Axman6: If you go through all my programs under Haskell_Quiz on the wiki, I'm sure some use the technique.
18:32:53 <EvilTerran> ?hackage MemoTrie
18:32:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MemoTrie
18:32:53 <Axman6> i was thinking more a blog post on how to use them
18:33:02 <EvilTerran> there's a module that uses them
18:33:30 <dolio> Although I think some of my code for the tries themselves is broken.
18:33:30 <EvilTerran> Axman6, and, a few links from that page, http://conal.net/blog/tag/tries/
18:33:35 <lambdabot> Title: Conal Elliott Â» tries
18:35:22 <EvilTerran> those posts and module really hit home for me how clever associated datas are
18:35:36 <EvilTerran> i'd been just using associated type synonyms
18:36:00 <ManateeLazyCat> Hi, everyone! Today i update to GHC 6.10.1, but when i use "ghc --make Setup" compile HTTP for cabal, i got error "/usr/bin/ld: cannot find -lgmp". Any help?
18:36:43 <Saizan_> ManateeLazyCat: install libgmp
18:37:21 <r0oter> Hi, everyone, Im trying to delete the second element from a list, does anybody know how could I perform this?
18:37:35 <ManateeLazyCat> Saizan_: Thanks, i try....
18:37:52 <chessguy> deletesecond xs = head xs : drop 2 xs
18:37:53 <roconnor> @hoogle delete
18:37:54 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
18:37:54 <lambdabot> Data.IntMap delete :: Key -> IntMap a -> IntMap a
18:37:54 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
18:38:10 <roconnor> @hoogle [a] -> Int -> [a]
18:38:11 <lambdabot> Prelude drop :: Int -> [a] -> [a]
18:38:11 <lambdabot> Prelude take :: Int -> [a] -> [a]
18:38:11 <lambdabot> Data.List drop :: Int -> [a] -> [a]
18:38:20 <EvilTerran> f (x:_:xs) = x:xs; f xs = xs
18:38:47 * EvilTerran likes the weird smiley aspect of "x:_:xs"
18:39:11 <chessguy> EvilTerran: that's a nice version
18:39:18 <conal> btw, i tried converting MemoTrie from associated data types to associated type synonyms, but wasn't able
18:39:20 <Saizan_> the second element is sad since you're discarding it?
18:39:37 <roconnor> let (a,b) = splitAt 2 l in a++drop 1 b  -- (or a ++ tail b) depending on if you want it to fail on a list of length 1 and 0 or not.
18:39:50 <r0oter> Saizan_: what u mean?
18:40:25 <ddarius> > splitAt 2 "abc"
18:40:26 <lambdabot>   ("ab","c")
18:40:26 <Saizan_> r0oter: just kidding
18:40:30 <conal> i guess i'd need type lambda and higher-order type unification.
18:41:10 <r0oter> ok, I think im little bit confuse since Im kinda new, Do I need to create a function in order to perform this?
18:41:33 <lispy> conal: I swear those features came up yesterday too :)
18:41:43 <conal> lispy: oh!
18:41:44 <Saizan_> r0oter: yes, the one from EvilTerran "f (x:_:xs) = x:xs; f xs = xs" looks nice
18:41:45 <ddarius> lispy: They did.
18:42:20 <conal> lispy: the type system sort of flirts with being a higher-order logic programming language (like Lambda-Prolog), but doesn't actually go there.
18:42:29 <lispy> conal: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.7505
18:42:29 <lambdabot> Title: Type classes with more higher-order polymorphism - CiteSeerX
18:42:42 * conal looks
18:42:43 <ddarius> conal: In which way does it flirt with being higher-order?
18:42:55 <lispy> ddarius: rankn types?
18:43:18 <conal> ddarius: function-valued variables.
18:43:23 <EvilTerran> r0oter, alternatively, you can use a "case/of", as in "case yourList of x:_:xs -> x:xs; xs -> xs"
18:44:23 <EvilTerran> r0oter, but don't use either of these unless you know how they work
18:44:26 <EvilTerran> ;)
18:45:00 <r0oter> EvilTerran: Yes I kinda understand it, thx :)
18:45:12 <ddarius> EvilTerran: So what do you suggest to programmers who don't want to know how the code works?
18:45:25 <EvilTerran> ddarius, that they go for a career change?
18:46:09 <EvilTerran> "know how they work" was the wrong phrase - "know their semantics" would be better
18:46:16 <EvilTerran> nothing wrong with abstractions
18:47:35 <Axman6> r0oter: only kinda understand it?
18:48:26 <ManateeLazyCat> Saizan_: Thank you very much! Now i compile success. :)
18:48:27 <roconnor> @type catch
18:48:28 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
18:48:36 <roconnor> @hoogle catc
18:48:36 <lambdabot> package catch
18:48:36 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
18:48:36 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
18:48:39 <roconnor> @hoogle catch
18:48:39 <lambdabot> package catch
18:48:39 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
18:48:39 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
18:48:58 <roconnor> @type Control.Monad.Exception.catch
18:48:59 <lambdabot> Couldn't find qualified module.
18:49:00 * EvilTerran $ sleep . (morning -) =<< now
18:49:32 <roconnor> @type catchError
18:49:34 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
18:50:09 <conal> wchogg: ping
18:51:36 <Axman6> ah, conal, i wanted to ask you something
18:52:21 <Web083> im wet
18:52:29 <ManateeLazyCat> Why GHC 6.10.1 not include HTTP, zlib, cabal-install? So just install ghc and not need comile these package manually.
18:52:36 <r0oter> Axman6: haha yeah I do understand them but sometimes I get some hard time implmenting them...
18:52:43 <conal> Axman6: yeah?
18:53:45 <Axman6> conal: would it maybe be possible for you to maybe do a blog post on your memotrie stuff, showing how to use them in common applications? like, maybe an example of a fibs function, and soemthing else, to demonstrate how to actually use them
18:54:07 <Saizan_> ManateeLazyCat: there's a plan to ship an "Haskell Platform" which would include that and other libraries
18:55:22 <ManateeLazyCat> Saizan_: Thanks. Then install ghc is more handy.
18:55:23 <conal> Axman6: probably not a blog post.  there's not much to it.  i could add a couple of examples as code comments.
18:55:42 <conal> Axman6: recursive use is a little less obvious than non-recursive ones.
18:57:30 <Axman6> ok, well either way would be good :)
18:58:06 <Axman6> i've read a few of your posts on them, and i see what's going on, i just don't see how to fit it into programs i might be writing
18:58:29 <Lemmih> If I have to fork jhc, what would be a good name?
18:58:36 <ddarius> lhc
18:58:53 <Axman6> heh, i agree
18:58:55 <conal> Axman6: i'll paste an example.
18:59:01 <Axman6> cheers :)
18:59:36 <conal> Axman6: http://hpaste.org/12154
18:59:39 <Lemmih> I fear it might be seen as slightly vain.
18:59:57 <ddarius> It'll be lispy's haskell compiler in honor of him being the first to state the obvious.
19:00:05 <conal> fib0 is the naive recursive version, and fib is the memoized version.
19:00:11 <ddarius> Or we can use the first initial of lispy's first name and call it jhc.
19:00:19 <lispy> heh
19:00:36 <lispy> Lemmih: I think you should call it the Large Hadron Compiler
19:01:38 <conal> Axman6: beware that fib is a CAF.
19:01:58 <Axman6> CAF? (i did know what that meant...)
19:02:11 <pizza__> lispy: lol
19:02:19 <lispy> Axman6: it basically means top level value/function
19:03:16 <Saizan_> with no formal parameters
19:03:30 <Saizan_> so it's shared
19:04:35 <lispy> Axman6: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html#prof-rules
19:04:38 <lambdabot> Title: Chapterï¿½6.ï¿½Profiling, http://tinyurl.com/kwh6c
19:04:44 <lispy> Axman6: thta page explains the term
19:04:47 <Axman6> hmm, so MemoTrie is quite limited in its datatypes?
19:07:53 <conal> http://hpaste.org/12154#a1
19:08:01 <conal> i added a non-CAF version.
19:08:11 <Axman6> i still think there's a place for putting like memoisation annotations into the compiler, so you can add a single character, and have it memoised. it would have to be used only where appropriate, and that would be left up to the programmer.
19:08:33 <Axman6> and i never understood why i got so much negative feedback for saying that :\
19:09:02 <conal> the naive version is slow (exponential).  the two memo versions are both fast.  the CAF one eats up a lot of memory and doesn't release it.  the non-CAF one releases memory.
19:09:44 <Axman6> don't those types have to be Int -> Int?
19:09:47 <conal> if the CAF version is invoked twice from the ghci repl with the same argument, it yields an answer right away.
19:10:06 <Axman6> i tried changing to Integer -> Integer, but there's no HasTrie instance for Integer
19:10:18 <conal> oh, btw, i just added a MemoTrie instance for Integer.  will release.
19:10:28 <Axman6> ah. excellent :)
19:11:21 <conal> just an oversight.  Int is too small to be useful in this case.
19:11:59 <wchogg> conal:  much delayed pong
19:12:24 <lispy> Axman6: if you want to autogenerate memoized things by way of your above proposal it sounds like a good place to use metaprogramming.  So you might use Data.Derive or template Haskell or drift or ...
19:13:00 <r0oter> Im trying to sort the list as f :: (Ord a) => [a] -> a; f (x:xs) = x but Im getting "Could not deduce (Num a) from the context (Ord a)"
19:13:20 <lispy> Axman6: what you're suggesting has so much value to it that in the common lisp community they have macros for it as part of the folklore of lisp.
19:13:55 <r0oter> is that because they belong to just type Char?
19:14:08 <conal> new MemoTrie released.
19:14:13 <conal> @hackage MemoTrie
19:14:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MemoTrie
19:14:13 <bd_> r0oter: the problem is not in the  code you gave :)
19:14:19 <conal> (now with HasTrie Integer)
19:14:21 <Axman6> lispy: well, every time i've mentioned it, people have pretty flatly said no to the idea, that it should be left to the programmer to reinvent the wheel every time they want to memoise something
19:14:28 <bd_> r0oter: but the code you just gave doesn't sort... and doesn't need the Ord annotation, as it just take's the list's head
19:14:48 <gwern> Lemmih: the current jhc cabal-install error is fascinating - 'jhc-0.5.20081118.3 failed during the building phase. The exception was: exit: ExitFailure 1' :)
19:14:52 <conal> so that paste code will run
19:14:58 <lispy> Axman6: it may be in the way you've presented the ideas.  Definitely a completely automated approach is wrong.
19:15:12 <Axman6> does anyone think an 'Nthable' class would be useful? something like class Nthable (N a) where nth :: N a -> Integer -> a?
19:15:13 <conal> wchogg: i was just looking at your reactive@haskell.org note.  and not sure i understood what you were asking.
19:15:23 <adu> lispy: about representation...
19:15:45 <conal> wchogg: and confused about "event stream that has a constant difference of 1".
19:15:47 <lispy> adu: sorry?
19:16:00 * Axman6 implements Nthable
19:16:03 <bd_> Axman6: I'm not sure what that class does - personally I think a class Eq a => Hashable a where hash :: a -> Int would be the logical building block for a memoize :: Hashable a => (a -> b) -> (a -> b)
19:16:05 <chylli> hi. I write a test case, declare instance Arbitrary Char, but I got an error:
19:16:05 <chylli>     Duplicate instance declarations:
19:16:10 <r0oter> bd_: what u mean doesnt need Ord?
19:16:18 <adu> lispy: do you think the patch type should be represented as ModLine Int Int [String] [String] or ModLine Int [(Int, [String], [String])]?
19:16:22 <lispy> Axman6: I wouldn't lose hope yet.  I say, if you can make a nice, easy to toggle, memoizer that applies just where you want it, that it will catch on.
19:16:22 <Axman6> bd_: sounds good to me
19:16:24 <bd_> r0oter:  f :: (Ord a) => [a] -> a; f (x:xs) = x <-- nowhere in this definition do you use anything in Ord
19:16:24 <chylli> what should I do ?
19:16:27 <wchogg> conal:  Sorry, I can be a bit terse.  I meant it would be equivalent to doing integral over an event stream whose events always occur 1 s apart.
19:16:28 <adu> for the character-based patch
19:16:39 <conal> wchogg: oh!
19:16:41 <conal> thx
19:17:04 <bd_> r0oter: so yeah, go to hpaste.org and paste in the actual code, and the full error message :)
19:17:13 <conal> wchogg: though 0.1 sec in this case, right?
19:17:25 <adu> lispy: basically, do you think it would be common for people to change stuff in multiple places per line, or do line modifications only happen in a single character insertion point?
19:17:27 <lispy> adu: oh boy, that's a hard question to answer.  My advice is to ask Igloo or droundy (on darcs-users that's Ian and David respectively)
19:17:52 <Axman6> lispy: well, the way i'd like to do it would be in the compiler, so its implimentation wasn't something the user would have to worry about. just add some anotation saying that the compiler should memoise this function (with a few restrictions on the types, number of arguments etc) and it would make the whole thing a lot easier
19:18:20 <bd_> Axman6: Someone (Oleg?) proposed an implementation using an unsafe address-comparison primitive
19:18:22 <Axman6> and, i've only been using haskell for about 8 months, so hacking GHC is far beyond my capabilities
19:18:25 <lispy> Axman6: but, couldn't that be abstracted out of the compiler and still be an annotation?  I mean, drift works this way
19:18:29 <conal> wchogg: so i'll reply (on-list) that yes, i'd want this example to run, and i'd expect it to be the constant 0 behavior.
19:18:30 <bd_> which doesn't need any further compiler hacks
19:18:38 <r0oter> bd_: I thought I could use it like for instance (Num a) => [a] -> a
19:18:41 <Saizan_> Axman6: there are a lot of variables to tune though, for example "how long should the table kept in memory?"
19:18:42 <wchogg> conal:  Well, the 'myIntegral' function doesn't actually do the snapshotWith (*^), so it's numerically 'equivalent' to feeding the real integral an Event () where the events are 1 s apart
19:18:42 <Axman6> lispy: possibly, i don't know tbh
19:19:06 <conal> wchogg: oh, but more quickly
19:19:10 <bd_> r0oter: You can... but in this particular case the one line of implementation for your function you posted doesn't use anything like < or > that Ord provides
19:19:21 <conal> wchogg: same values, just 10 times as fast.
19:19:25 <lispy> Axman6: Okay.  So the first step is to figure out how the automated translation should work.  Once you've figured that out, we can decide where it's implement, in GHC, as a preprocessor, etc.
19:19:55 <conal> wchogg: though in this case, it's a constant 0 function, so "faster" is the same.
19:19:57 <bd_> Axman6: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.1948
19:19:58 <lispy> Axman6: and, you should be able to prototype your translation in template haskell
19:19:59 <lambdabot> Title: Stretching the storage manager: weak pointers and stable names in Haskell - Cite ...
19:20:08 <Axman6> if it used laziness, with the array style that is pretty popular, the the only restrictions would be on the inpits being of type Ix
19:20:16 <jsn> i'm having some real trouble finding docs on how to check for a function with template haskell
19:20:22 <wchogg> conal:  With the whole point being that by cutting out the diffE & the snapshotWith (*^) that it'll be a little easier for me to see paper & pencil why the implementation is going funny.
19:20:23 <jsn> it seems like reify is the way to go
19:20:28 <Axman6> lispy: yes.. once i learn what template haskell is...
19:20:35 <jsn> but of course i can not use reify from within GHCi
19:20:37 <bd_> I don't think anything like TH is needed
19:20:50 <conal> wchogg: agreed.  same core issue, but simpler.  good idea.
19:20:51 <bd_> unsafePerformIO however will be needed
19:20:54 <wchogg> conal:  At the moment, I get to about page 4 of the calculation & it starts getting hard to simplify in any illustrative way.
19:21:05 <conal> wchogg: ouch!
19:21:07 <Axman6> bd_: thanks for the link, looks good
19:21:14 <jsn> what should i expect reify to do if a name is not defined?
19:21:17 <Saizan_> jsn: tried something like $(reify 'foo >>= stringL . show) ?
19:21:27 <lispy> Axman6: template haskell is sort of like an elaborate macro system. You can modify the code during a specific stage of compilation to generate other code
19:21:28 <wchogg> conal:  That's why I was so disappointed I couldn't reproduce it via stepping in ghci
19:21:47 <newsham> do FieldTrip dependencies run on win32? (ie. opengl and friends) ?
19:22:02 <conal> wchogg: oh, i see.
19:22:03 <Axman6> bd_: that's why i think it should be in the compiler, so that you don't have to worry about the IO of it. it will always be a function of f :: a -> ... -> x, no matter if its memoised or not
19:22:04 <conal> newsham: yes
19:22:07 <Axman6> just, one will be faster
19:22:37 <Lemmih> gwern: Can I interest you in an lhc tarball: http://darcs.haskell.org/~lemmih/lhc-20081118.tar.gz ?
19:22:41 <conal> newsham: i was running reactive & FieldTrip on Win32 a couple of weeks ago.  i think camio still does.
19:22:52 <Lemmih> gwern: It should work with ghc-6.8.
19:22:56 <bd_> Axman6: That doesn't need to be in the compiler - just in a library :)
19:22:59 <newsham> cool, gonna upgrade my ghc and install that stuff
19:23:07 <Axman6> what i'm proposing would let anyone add a single character to the code, and get memoisation. no worrying about IO or anything like that
19:23:31 <jsn> Saizan_: Couldn't match expected type `Q Exp' against inferred type `Lit'
19:23:51 <bd_> Axman6: a single character might be pushing it for a library - but memoization isn't actually something you want all that often - trading memory for CPU isn't always a good solution :)
19:24:05 <r0oter> bd_: so u think I can use something like sort, i guess im a bit confused
19:24:09 <bd_> memo :: Hashable a => (a -> b) -> (a -> b)  would seem reasonable
19:24:11 <Axman6> bd_: i know, but it would be a useful feature
19:24:11 <Saizan_> jsn: so it's $(reify 'foo >>= return . LitE . stringL . show), i don't recall the types so well
19:24:22 <Saizan_> , $(reify 'id >>= return . LitE . stringL . show)
19:24:25 <lunabot>  "VarI GHC.Base.id (ForallT [a_1627417734] [] (AppT (AppT ArrowT (VarT a_1...
19:24:27 <bd_> r0oter: Sorry, it's hard for me to speak usefully about the code when you aren't showing me the important part of it :)
19:24:38 <Saizan_> works :)
19:24:39 <Axman6> bd_: yeah, something like that owuld be good
19:24:41 <Axman6> would*
19:24:43 <thoughtpolice> conal: http://hpaste.org/12155
19:24:57 <Saizan_> , $(reify 'id >>= lift . show)
19:24:59 <bd_> r0oter: in the two lines you gave, you said f works on a list of orderable objects, right? But in the actual definition of f (x:xs) = x, you don't make use of the ordering property
19:24:59 <lunabot>  "VarI GHC.Base.id (ForallT [a_1627417712] [] (AppT (AppT ArrowT (VarT a_1...
19:25:05 * conal looks
19:25:10 <bd_> r0oter: but anyway your error is in some code you never showed me :)
19:25:24 <jsn> Saizan_: so, that seems to just fail when the symbol is not defined
19:25:33 <Saizan_> , $(reify (mkName "notdefined") >>= lift . show)
19:25:35 <lunabot>  luna: `notdefined' is not in scope at a reify
19:26:09 <r0oter> bd_: well im trying to take a list of #'s and sort it on ascendant order
19:26:13 <Saizan_> yeah
19:26:20 <jsn> so it's not clear to me who i'm supposed to take that and determine whether or use the old or the new version of something
19:26:24 <r0oter> bd_: thats why I thought I could use it
19:27:16 <jsn> Saizan_: template haskell changed in a breaking way and so i need to change my template haskell to check for either 'currentModule' or 'location' and use one or the other
19:27:16 <r0oter> bd_: code: f :: (Ord a) => [a] -> a f (x:xs) = x f [] = 0
19:27:22 <conal> thoughtpolice: yeah.   i also tried 300 and 3000.
19:27:30 <bd_> oh
19:27:40 <bd_> r0oter: okay, now we see the error :)
19:27:44 <Axman6> hmm, how would i define a class that worked on containers? like, class Blah (n a) where foo :: (n a) -> Integer -> a?
19:28:15 <conal> thoughtpolice: i wonder how that 0.001 min got in there for fib0
19:28:20 <bd_> r0oter: Ord includes things that aren't numbers. Thus your return type might not be something that has a zero. (for example, strings, or tuples of orderable objects)
19:28:32 <Axman6> containers being lists, tuples etc
19:28:51 <r0oter> bd_: I kinda thought that, cause just char right?
19:28:54 <bd_> r0oter: So, one thing you can do is instead annotate it (Ord a, Num a) => [...], which will let your code as written work... but it isn't very haskelly to use 0 as a flag
19:29:09 <jsn> Axman6: the parens are unnecessary
19:29:16 <bd_> what I'd do is just: f :: [a] -> Maybe a        f (x:_) = Just x         f [] = Nothing
19:29:32 <jsn> Axman6: define the class and then a great many instances
19:29:33 <bd_> jsn: They're needed if you specify multiple typeclasses though
19:29:37 <bd_> oh wait
19:29:43 <bd_> jsn: sorry, nevermind, got mixed up
19:29:47 <Saizan_> , $(recover (reify (mkName "notdefined") >>= lift . show) (lift "catched"))
19:29:49 <lunabot>  "catched"
19:29:53 <Saizan_> jsn: ^^^
19:30:00 <jsn> Saizan_: thank you
19:30:45 <jsn> : let exists = recover (reify (mkName "notdefined") >>= lift . show) (lift False)
19:31:03 <jsn> , let exists = recover (reify (mkName "notdefined") >>= lift . show) (lift False)
19:31:05 <lunabot>  luna: parse error on input `)'
19:31:28 <jsn> hmm
19:31:48 <jsn> oh, well
19:31:56 <jsn> i don't need all that print stuff in there
19:33:02 <gwern> Lemmih: your link gives me forbidden
19:33:02 <r0oter> bd_: so something like this? f :: (Ord a, Num a) => a -> a
19:33:11 <gwern> Connecting to darcs.haskell.org|69.30.63.197|:80... connected.
19:33:13 <gwern> HTTP request sent, awaiting response... 403 Forbidden
19:33:16 <Saizan_> jsn: you want an "in" anyhow :)
19:33:25 <bd_> r0oter: well, yeah, but look at the Maybe thing. I'm really not sure what your function is meant to do though
19:33:28 <jsn> Saizan_: oh, right, this is not GHCi
19:34:23 <Axman6> is # used for anything in haskell?
19:34:37 <bd_> Axman6: in GHC, it's used to mark internal primitives
19:34:46 <bd_> it's also illegal in syntax without a GHC extension
19:34:46 <Axman6> ah yes
19:34:53 <gwern> good ol' MagicHash
19:35:03 <gwern> now there's something which confused me the first time I ran into it
19:35:05 <r0oter> bd_: f just need to sort and return it on ascendant order
19:35:20 <Lemmih> gwern: Try again.
19:35:29 <Axman6> i need a new infix operator, something along the lines of ! and !!
19:35:38 <bd_> r0oter: well, you don't need Num in that then - the only reason you need Num is because your incomplete implementation is incorrect
19:35:55 <bd_> r0oter: f [] = 0 <-- this says f returns a number. Of course, a real sort would not return a number
19:36:17 <bd_> moreover, your function returns only a single element; if it's to be a sort, it needs to be f :: Ord a => [a] -> [a]
19:36:34 <Axman6> so i couldn't use !#?
19:36:44 <gwern> 'lhc' eh. logical and amusing
19:36:56 <gwern> (since khc doesn't sound nice)
19:37:01 <bd_> Axman6: you could in a preprocessor, but it probably wouldn't be merged into GHC proper
19:37:10 <bd_> I still think a 'memo' function would be cleaner
19:37:17 <Axman6> i'm not working on the memoisation thing atm
19:37:20 <bd_> oh
19:37:24 <Axman6> i'll give that ago once exams are over
19:37:29 <Axman6> working on Nthable
19:37:54 <Axman6> something to overcome the common "how can i get the nth element of an m-tuple?"
19:38:00 <Saizan_> > let a !# b = a + b in a !# b
19:38:01 <lambdabot>   a + b
19:38:08 <Saizan_> > let a !# b = a + b in 1 !# 2
19:38:09 <lambdabot>   3
19:38:10 <bd_> Saizan_: LB has magichash enabled?
19:38:12 <Axman6> i'll give it a go then :0
19:38:37 <Saizan_> bd_: MagicHash means that you can use # as a non-symbol
19:38:47 <gwern> bd_: mueval enables extensions by default
19:38:48 <Saizan_> bd_: by default you can use # only in operators
19:38:49 <gwern> so yes
19:38:52 <bd_> aaah
19:39:09 <Axman6> @info (!!)
19:39:10 <lambdabot> (!!)
19:39:14 <Axman6> thanks lambdabot
19:39:34 <Saizan_> @info do { x <- foo; bar x }
19:39:34 <lambdabot> foo >>= \ x -> bar x
19:39:46 <Saizan_> there's not info command :)
19:40:50 <jsn> Saizan_: thank you
19:42:02 <Saizan_> jsn: np
19:42:16 <Axman6> how do you define the fixity of an infix function?
19:42:44 <r0oter> bd_: ok I think I got it thanks :)
19:44:34 <r0oter> bd_: i end up using filter
19:45:25 <gwern> > 1/3
19:45:27 <lambdabot>   0.3333333333333333
19:45:32 <gwern> :t 1/3
19:45:34 <lambdabot> forall t. (Fractional t) => t
19:45:50 <roconnor> > (1/3) :: CReal
19:45:51 <lambdabot>   0.3333333333333333333333333333333333333333
19:45:54 <Saizan_> Axman6: see infix/infixl/infixr
19:46:12 <Axman6> Saizan_: not sure where to look...
19:46:52 <newsham> hmm.. do you need cygwin to install the GLUT packages on win32?
19:47:09 <Saizan_> Axman6: some examples: http://www.haskell.org/onlinereport/standard-prelude.html
19:47:10 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
19:47:21 <lispy> newsham: you shouldn't need it to install, but you might need it as a way to build it
19:47:27 <Axman6> hoogle showed me, s'all good
19:47:33 <newsham> lispy: "cabal install"
19:47:45 <lispy> newsham: you could also use microsofts "free as in beer" version of visual studio, the one with the express moniker
19:47:54 <newsham> i dont understand the distinction between "build" and "install"
19:47:57 <Axman6> how do you export only specific functions from a module?
19:48:22 <roconnor> @type runError
19:48:23 <lambdabot> Not in scope: `runError'
19:48:38 <lispy> newsham: well, some people install things that are binaries...but if you want to use cabal install.  Hmm...I don't know.  I didn't realize we had a GLUT package on hackage.  I guess you could see what happens?
19:48:51 <Saizan_> Axman6: module Foo (only,some,function,here,DataType(..),DataType2(Some,Constructors)) where
19:49:08 <Axman6> cheers
19:49:17 <newsham> well, i'm running it from cygwin and i noticed that it ran "configure" and detected "cygwin" and this has me worried
19:49:27 <newsham> that it might be linking against cygwin stuff instead of making "normal" win32 bins
19:50:03 <lispy> newsham: sadly I'm out of my depth.  Maybe someone else will comment
19:50:03 <newsham> Linking Tetris.exe ...
19:50:04 <newsham> C:\ghc\ghc-6.10.1\gcc-lib\ld.exe: cannot find -lSM
19:50:06 <newsham> guh
19:50:11 <newsham> I think its all cygwined out now
19:50:15 <Axman6> hmm, how can i in an instance declaration say that i want tuples of type (a,a)?
19:50:50 <Axman6> hmm, this is getting more complicated than i thought it would...
19:51:10 <lispy> Axman6: if you want, instance Foo (a,a) where ..., you'll need some extensions
19:51:17 <lispy> Axman6: you'll need -XFlexibleInstances
19:51:40 <newsham> conal: still around?  any hints on how to install the GLUT stuff on win32?
19:51:54 <Axman6> lispy: {-# LANGUAGE FlexibleInstances #-} up the top?
19:52:09 <lispy> Axman6: that looks close...maybe it's right?
19:52:12 <conal> newsham: first you have to get opengl32.dll and glut32.dll on your system.
19:52:23 <gwern> Lemmih: that tarball compiled
19:52:26 <conal> newsham: or freeglut.dll ("32"?)
19:52:30 <gwern> Lemmih: haddocks are broken but that's not surprising
19:53:09 <gwern> Lemmih: and it seems to compile one or two of my scripts
19:53:36 <conal> newsham: maybe helpful: http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
19:53:38 <lambdabot> Title: Less Sugar/More Meat Â» Blog Archive Â» freeglut + Windows + HOpenGL + HGLUT, http://tinyurl.com/5ualsl
19:53:39 <newsham> conal: are there any FAQs or docs on this install process?  I'm not very GL saavy
19:53:42 <newsham> danke
19:53:46 <Axman6> lispy: doesn't seem to like it
19:53:59 <lispy> Axman6: what is the error?
19:54:07 <newsham> hrmm.. gotta install a mingwin sys to do builds.. *sigh*
19:54:09 <Axman6> Kind mis-match Expected kind `* -> *', but `(a, a)' has kind `*' In the instance declaration for `Nthable (a, a)'
19:54:30 <lispy> Axman6: okay, I need to see more of your code
19:54:41 <conal> newsham: see also www.xmission.com/~nate/glut.html for a non-free glut
19:54:41 <lispy> Axman6: seeing the class def for Nthable would help
19:55:06 <conal> newsham: though i recommend the freeglut route if you can do it
19:55:15 <Axman6> lispy: http://hpaste.org/12156
19:55:23 <lispy> looking
19:55:37 <Axman6> and this is turning out to be less useful than i had hoped.
19:56:00 <Axman6> need something more abstract... like ... -> *
19:56:11 <lispy> Axman6: okay, "n a" in the signature of (!#) makes n have kind * -> *, meaning n takes a type and produces a type
19:57:18 <lispy> Axman6: you probably want an approach that is similar to that of printf
19:57:36 <lispy> Axman6: where the class instances work inductively to reduce to the Nth value
19:57:37 <conal> newsham: would you do me a favor and make and/or gather Windows walk-through notes as you go?  we can add them to the wiki.
19:57:52 <lispy> :t printf
19:57:53 <Lemmih> gwern: Excellent. I'll work on putting lhc-base on hackage.
19:57:53 <lambdabot> forall r. (PrintfType r) => String -> r
19:57:54 <Axman6> lispy: hmm, i'll have to have a look
19:58:00 <newsham> i'm following the less sugar/more meat notes now and will note any deviations
19:58:30 <Axman6> is there some way to say, 'take a type that contains these types, an integer, and return one of those types'?
19:58:33 <lispy> Axman6: see that printf returns a PrintfType r, and you can use that to build multi parameter calls to printf
19:59:22 <Axman6> uh huh...
19:59:49 <jsn> Saizan_: so actually, i am still stuck
20:00:04 <conal> does anyone here no about how to catch an 'error' call (or pattern matching fail or undefined).  i know i'd have to catch in IO, for semantic reasons.
20:00:08 <jsn> oh wait, no
20:00:14 <jsn> there is a way
20:00:22 <jsn> well, no, there isn't
20:00:23 <lispy> Axman6: but yeah, I got nothing.  You could read the HList paper if you need inspiration.  They have a similar problem when accessing indexed elements of HLists
20:00:24 <Saizan_> jsn: are you building this with Cabal?
20:00:29 <jsn> Saizan_: yeah
20:00:53 <Axman6> lispy: yeah, i hadn't though about how this might be possible...
20:01:11 <jsn> Saizan_: how does that help?
20:01:27 <lispy> Axman6: it's unlikely you will find a solution that is simple to explain
20:01:28 <Saizan_> jsn: you could use CPP and #ifdef on the template-haskell version
20:01:44 <Axman6> indeed
20:02:00 <jsn> Saizan_: is there a way to 'unreify' ?
20:02:44 <Twey> conal: You can do it with Control.Exception.catch (non-98)
20:02:53 <jsn> Saizan_: i can use Cabal to define values that are available to CPP ?
20:03:19 <conal> Twey: oh.  which differs from Prelude.catch ?
20:03:27 <roconnor> Gcc rewrites a 32-bit unsigned x/255 into (x*0x80808081)>>39
20:03:28 <roconnor> neat
20:03:40 <Twey> conal: Yes, Prelude.catch is '98-compliant, which means it can't catch Prelude.error errors.
20:03:53 <Saizan_> jsn: yes, cpp-options: -DFOO
20:04:35 <conal> Twey: thanks much
20:05:10 <Twey> Welcome
20:05:12 <Saizan_> jsn: i'm not sure what you mean by unreify, the Info carries a Name
20:05:47 <adu> lispy: done
20:06:05 <adu> the email that is
20:07:31 <jsn> Saizan_: well, like this:   do {  f  <-  recover (reify "theFirstFToTry" >> return (unreify "theFirstFToTry")) (return $ unreify "theOtherF") }
20:07:54 <jsn> Saizan_: (don't really need the do wrapping that)
20:07:58 <newsham> conal: the blog post was spot-on.  no problems installing w/ these instructions
20:08:10 <conal> newsham: awesome!  :) :)
20:08:24 <newsham> (other than accidentally trying to bulid the test program at the end in the GLUT src dir..)
20:08:32 <jsn> basically, i need to see if "name" resolves to something, if it does, give me what it resolves to; if not, resolve this other thing and give me that
20:09:06 <Saizan_> , [| foo x |]
20:09:08 <lunabot>  luna: Not in scope: `foo'
20:09:14 <Saizan_> , [| id |]
20:09:17 <lunabot>  VarE id
20:09:40 <Saizan_> jsn: so (return . VarE)
20:10:01 <pumpkin_> I want to make an infinite list of pi's decimal digits
20:10:03 <Saizan_> or just VarE..
20:10:21 <pumpkin_> I wonder if that CReal class can do that for me
20:10:58 <hackage> Uploaded to hackage: MemoTrie 0.4.1
20:11:24 <newsham> $ ./Tetris.exe
20:11:24 <newsham> Tetris.exe: user error (unknown GLUT call glutSetOption, check for freeglut)
20:11:32 <newsham> hrm
20:12:22 <Saizan_> , $(return . VarE . mkName $ "id") 1
20:12:24 <lunabot>  1
20:14:01 <chylli> I want to construct a Test.QuickCheck.Gen to produce a string begin with 1 or more spaces following characters in "!$%&", how to write this gen ?
20:14:39 <thoughtpolice> chylli: do something like 'newtype SpecialStr = SS String' and write an instance for Arbitrary
20:14:55 <thoughtpolice> chylli: then make your tests use SpecialStr instead of String and check them
20:15:16 <Saizan_> or use forAll
20:15:23 <chylli> thoughtpolice: ok, thanks.
20:15:32 <pumpkin_> omg the thoughtpolice are here :(
20:15:33 <chylli> Saizan_: can you show me how to write with forAll ?
20:15:37 * pumpkin_ thinks goodthink
20:15:45 <Saizan_> ?type forAll
20:15:46 <lambdabot> forall a prop. (Testable prop, Show a) => Gen a -> (a -> prop) -> Property
20:16:12 <chylli> Saizan_: I writen by this :
20:16:13 <Saizan_> forAll yourgenerator prop
20:16:28 <chylli> myChar = elements "!$%&|*+-/:<=?>@^_~#"
20:16:35 <chylli> prop_SpaceBegin x = forAll myChar $ \c -> (head  $ readExpr $ (replicate x ' ') ++ c:[]) == 'F'  where types = x::Int
20:16:48 <chylli> but the x maybe 0 or negative number
20:17:15 <chylli> Saizan_: so I dont know how to write 'yourgenerator'
20:17:43 <Saizan_> chylli: you can use (abs x) + 1 instead of x
20:17:46 <Saizan_> ?type abs
20:17:47 <lambdabot> forall a. (Num a) => a -> a
20:18:03 <Saizan_> > abs (-5) + 1
20:18:04 <lambdabot>   6
20:18:44 <chylli> good idea, but is it possible to combine two gen as one ?
20:19:14 <chylli> Saizan_: such as : connect myChar mySpace
20:19:19 <chylli> Saizan_: :p
20:20:10 <chylli> Saizan_: so that I can just write one gen to generate special char and another spaces
20:20:25 <Saizan_> do x <- arbitrary; let n = abs x + 1; c <- myChar; return (replicate n ' ' ++ [c])
20:20:47 <Saizan_> or do spaces <- mySpace; c <- myChar; return (spaces ++ [c])
20:21:03 <chylli> Saizan_: thanks
20:21:24 <chylli> Saizan_: I learned a lot.
20:24:28 <newsham> cant figure out this glut error.  the small glut test program runs but tetris fails.
20:24:47 <Zao> newsham: Freeglut feature missing?
20:25:02 <newsham> "unknown GLUT call glutSetOption, check for freeglut"
20:25:11 <newsham> i just built and installed freeglut
20:25:22 <Zao> And built the haskell glut against it?
20:25:26 <newsham> yup.
20:25:36 <newsham> at least as far as I know it built against it
20:25:39 <conal> wchogg: ping
20:25:52 <newsham> I still have package srcs here so I could rebuild
20:26:10 <Axman6> newsham: yeah, only freeglut has that. conal had a fix for it... which i'm guessing hasn't been comitted?
20:26:27 <newsham> ahh, i'm buliding from hackage srcs, not darcs.
20:26:34 <conal> wchogg: I just stumbled across the ghc code that shows "<<loop>>".   It's in Control.Exception .
20:26:37 <newsham> should I be more progressive?  which package?
20:28:08 <glguy> lispy, yeah, that was me
20:30:02 <wchogg> conal:  I don't know if you saw it, but I asked about what conditions caused it on the ghc list & it's when you reenter a thunk during its evaluation.
20:30:38 <conal> wchogg: yeah, i did see it.  i think that's what they call a "black hole".
20:31:55 <conal> wchogg: i'm messing with Unamb again, after today's stimulating conversations about it.  stumbled across the NonTermination type in the process.
20:33:09 <lispy> glguy: ah, well, I've met dons and some of the peeps at galois.  So, I guess you're next on the list :)
20:33:21 <lispy> glguy: unless we met already and I didn't realize it...
20:33:33 <geezusfreeek> conal, NonTermination type?
20:33:53 <conal> geezusfreeek: yeah.  it's a data type with an Exception instance.
20:34:14 <conal> i don't quite understand Control.Exception yet
20:35:08 <wchogg> conal:  what was the conversation about Unamb?  I don't think I saw it.
20:35:16 <newsham> http://hpaste.org/12157
20:35:38 <newsham> (example from wiki page)
20:36:04 <newsham> possibly because I'm now trying ot run w/ darcs srcs?
20:37:34 <newsham> oh well, out of time..  will have to revist later
20:37:50 <conal> wchogg: oh, too bad.  there was a lot to it.  see http://tunes.org/~nef/logs/haskell/08.11.17 starting around 14:02
20:38:04 <conal> wchogg: or just search there for "unamb"
20:38:12 <wchogg> conal:  k, will do
20:38:59 <conal> wchogg: the discussion started with Beelsebob asking about how exceptions played with unamb.  i think the answer is that the implementation is correct w.r.t the semantics.
20:40:17 <conal> wchogg: then two other questions arose that got me thinking.  (a) is unamb more strictly expressive than parallel-or? and (b) can we loosen unamb's precondition considerably, e.g., to arbitrary non-contradictory values.
20:40:29 <conal> where non-contradictory means they have a common upper information bound.
20:40:42 <conal> e.g., (2,undefined) `unamb` (undefined,3) == (2,3)
20:40:56 <conal> i'm playing with an implementation of (b) now.
20:41:59 <wchogg> conal:  what's the upshot to a "unifying" implementation of unamb?  I don't think I understand.
20:42:39 <conal> wchogg: yeah -- it is similar to unification.  to "linear" unification (no repeated variables), with undefined as a variable.
20:42:48 <jmob> geez, fn is crowded these days, who told ppl we were here? did all the cool ppl leave?
20:43:07 <conal> wchogg: are you asking what practical application?
20:43:16 * conal isn't sure what "upshot" means
20:43:25 <gio123> can somebody point me book where can i see how is constructed cartesian product of 2 DFA?
20:44:07 <wchogg> conal:  Sorry, I meant in practice or theory do you get as a benefit.  I don't think I've thought enough about unamb to see it.
20:44:19 <lispy> jmob: fn?
20:44:30 <conal> wchogg: i don't have an application in mind -- yet.
20:44:38 <jmob> freenode
20:45:06 <conal> wchogg: but i've been uncomfortable about unamb being interested only in weak head normal form.
20:45:26 <lispy> ?users
20:45:26 <lambdabot> Maximum users seen in #haskell: 550, currently: 488 (88.7%), active: 20 (4.1%)
20:45:44 <jmob> conal: practical applications are for engineers, who needs em (other than to fund research)
20:45:51 <conal> wchogg: i suspect it'd have broader uses if it were more widely applicable.
20:46:16 <wchogg> jmob:  Bah!  The most beautiful theory comes from the vagueries of practice.
20:46:24 <conal> jmob: and i often find practical applications only after following my nose after an aesthetically pleasing idea.
20:47:03 <jmob> lispy: yeah, takes a while to list all those users on a slow connection
20:47:27 <jmob> probably just need to turn that off in irssi
20:47:40 <lispy> jmob: yeah, I was 'bout to say :)
20:49:14 <jmob> biggest problem i had with linear algebra (initially) was that none of my teachers could tell me any of the practical applications of all the different characterizations of a "bunch of numbers"
20:50:25 <ddarius> Linear algebra is rife with practical applications.
20:50:32 <lispy> jmob: that's sad considering that linear algebra is one of the most applicable areas in math
20:53:00 <geezusfreeek> haskell's biggest blessing and biggest curse is its ability to abstract things that are hard to pin down as "useful for x, y, and z"
20:55:00 <jmob> lispy: i leanred many of them when i took image analysis and computational geometry classes
21:16:10 <ManateeLazyCat> Hi. I use cabal install Xmonad and got error "configure: error: X11 libraries not found, so X11 package cannot be built", but i have install X11 libraries(I use Debian, have install libx11-dev), so any help?
21:16:49 <dmwit> It's probably referring to the Haskell bindings to the X11 libraries.
21:17:00 <dmwit> Why don't you join us in #xmonad so we don't clutter up #haskell?
21:18:12 <ManateeLazyCat> dmwit: Because I compile gtk2hs have same problem. Today i update GHC 6.10.1
21:18:24 <dmwit> mmm
21:18:33 <dmwit> Make sure to get the latest stuff from Hackage.
21:18:59 <dmwit> I do recall some issues with one of the xmonad libraries, so you might even want to go straight to the darcs version of some of the stuff that isn't working.
21:35:04 <conal> does anyone here have Reactive installed, with accessible source code?  I'm getting a QuickCheck test non-termination, and I don't know if it's related to my un-checked-in code.
21:38:17 <conal> nm. i'm just installing elswhere from the repo
21:53:31 <orbitz> is Timber basicaly a haskell-like language for embeded devices?
22:14:55 <orbitz> hai
22:30:59 <solrize> wow this place hasn't been so quiet in quite a long time
22:31:11 <solrize> hi orbitz i have no idea what timber is ;)
22:31:47 <ski_> (ssh .. it may wake up ..)
22:32:54 <ski_> (orbitz : from what i remember, Timber expressed interaction in a reactive, non-blocking fashion .. mayhaps that has some connection with embedded devices, i don't know)
22:39:56 <grom358> I have a infinite list of primes but when I do > takeWhile (< (2^50)) primes I get the empty list
22:40:06 <grom358> but take 30 primes works fine
22:40:24 <grom358> any ideas?
22:40:32 <idnar> > 2 ^ 50
22:40:33 <lambdabot>   1125899906842624
22:40:41 <Cale> > 2^50 :: Int
22:40:42 <lambdabot>   1125899906842624
22:40:51 <Cale> > 2^50 :: Int32
22:40:53 <lambdabot>   0
22:41:03 <ski_> @type takeWhile
22:41:03 <Cale> Int is evil :)
22:41:04 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:41:51 <grom358> oh.. so how do the takeWhile
22:42:06 <grom358> do you do* the takeWhile to 2^50
22:42:46 <Cale> grom358: Is it a list of Ints?
22:42:50 <Axman6> > takeWhile (< (2^50)) [1..]
22:42:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:42:59 <Axman6> > takeWhile (> (2^50)) [1..]
22:43:00 <lambdabot>   []
22:43:07 <Cale> grom358: If you're on a 32-bit architecture, the results will be incorrect before then anyway
22:43:08 <idnar> > takeWhile (< (2^50)) [1..] :: [Int]
22:43:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:43:10 <idnar> > takeWhile (< (2^50)) [1..] :: [Int32]
22:43:11 <lambdabot>   []
22:43:16 <grom358> yes.. :type primes gives primes :: [Int]
22:44:04 <Cale> Possibly try forcing the type to be [Integer], by adding an explicit type annotation, and then see what type error you get.
22:45:23 <grom358> ah.. i didn't realise Int and Integer where different.. I now have :type primes give primes :: [Integer]
22:46:45 <Axman6> > maxBound :: Int
22:46:47 <lambdabot>   9223372036854775807
22:46:51 <Axman6> > maxBound :: Integer
22:46:52 <lambdabot>       No instance for (Bounded Integer)
22:46:52 <lambdabot>        arising from a use of `maxBoun...
22:47:10 <roconnor> > fix bitsize
22:47:11 <lambdabot>   Not in scope: `bitsize'
22:47:14 <roconnor> > fix bitSize
22:47:16 <lambdabot>   64
22:47:24 <Cale> Int means machine integers, which are really integers modulo 2^n for some n.
22:47:29 <Axman6> :t bitSize
22:47:30 <lambdabot> forall a. (Bits a) => a -> Int
22:47:45 <ski_> > maxBound :: Int32
22:47:46 <lambdabot>   2147483647
22:49:11 <Axman6> > maxBound :: Int8
22:49:12 <lambdabot>   127
22:49:31 <dmwit_> > maxBound :: Word8
22:49:32 <lambdabot>   255
22:49:43 * dmwit_ joins the maxBound party
22:49:53 <ski_> > maxBound Word0
22:49:54 <lambdabot>   Not in scope: data constructor `Word0'
22:50:01 <ski_> bah
22:50:09 <dmwit_> > maxBound :: Word9
22:50:10 <lambdabot>   Not in scope: type constructor or class `Word9'
22:50:14 <dmwit_> aw shucks
22:50:30 <roconnor> > maxBound ()
22:50:31 <lambdabot>       No instance for (Bounded (() -> a))
22:50:31 <lambdabot>        arising from a use of `maxBo...
22:50:32 <Axman6> i was seriously considering writing Int24 for something a while ago
22:50:42 <roconnor> > maxBound :: ()
22:50:43 <ski_> > maxBound :: ()
22:50:44 <lambdabot>   ()
22:50:45 <lambdabot>   ()
22:50:54 <Axman6> @instances Bounded
22:50:55 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
22:50:56 <dmwit_> ?check minBound == maxBound
22:50:57 <lambdabot>   "OK, passed 500 tests."
22:51:10 <dmwit_> Thank you, defaulting!
22:51:17 <roconnor> ?check (==)
22:51:18 <lambdabot>   "OK, passed 500 tests."
22:51:21 <pumpkin> lol
22:51:32 <pumpkin> ?check
22:51:33 <lambdabot>   <no location info>: parse error on input `;'
22:51:33 <Axman6> ?check (/=)
22:51:34 <lambdabot>   "Falsifiable, after 0 tests:\n()\n()\n"
22:51:39 <Axman6> naww :(
22:51:49 <Twey> > maxBound :: Integer
22:51:50 <lambdabot>       No instance for (Bounded Integer)
22:51:50 <lambdabot>        arising from a use of `maxBoun...
22:51:52 <pumpkin> what does check do?
22:51:57 <Twey> Oh ah.
22:52:00 <dmwit_> pumpkin: Check out QuickCheck, it's really cool!
22:52:11 <ski_> @check @check True
22:52:11 <lambdabot>   Parse error at "@chec..." (column 1)
22:52:13 <ski_> @check True
22:52:14 <dmwit_> pumpkin: It generates random inputs to functions to see if they return True.
22:52:14 <Twey> pumpkin: Checks stuff.
22:52:15 <lambdabot>   "OK, passed 500 tests."
22:52:17 <Twey> :-P
22:52:17 <pumpkin> oh
22:52:19 <pumpkin> fun
22:52:21 <roconnor> ?check \x y z -> ((x == y) == z) == (x == (y == z))
22:52:22 <lambdabot>   "OK, passed 500 tests."
22:52:25 <Twey> 500 tests?
22:52:28 <Axman6> > maxBound :: Char
22:52:29 <lambdabot>   '\1114111'
22:52:37 <Twey> What 500 tests can one perform on True?
22:52:46 <dmwit_> Twey: Many copies of the 8 possibilities.
22:52:46 <pumpkin> so wait, why does == pass?
22:52:47 <Twey> I really see only on.
22:52:47 <Beelsebob> pumpkin: unless you specify type though, it's unreliable...
22:52:49 <Twey> one**
22:52:51 <pumpkin> oh
22:52:51 <Beelsebob> @check
22:52:52 <lambdabot>   <no location info>: parse error on input `;'
22:52:52 <roconnor> ?scheck True
22:52:53 <dmwit_> pumpkin: ()'s
22:52:54 <lambdabot>   "OK, passed 500 tests."
22:52:59 <ski_> generate 500 parameter lists, each containing zero arguments
22:53:01 <Twey> dmwit_: What are the eight?
22:53:03 <Beelsebob> @check \x y -> x `mappend` y == mempty
22:53:04 <lambdabot>   "OK, passed 500 tests."
22:53:08 <Beelsebob> see
22:53:13 <roconnor> ?scheck True
22:53:15 <lambdabot>   "OK, passed 500 tests."
22:53:16 <Beelsebob> it assumed I wanted () as my type there
22:53:18 <dmwit_> Twey: (True, True, True), (True, True, False), ...
22:53:20 <roconnor> wtf?
22:53:23 <Beelsebob> which was possbly the worst idea ever
22:53:24 <dmwit_> Twey: There's three inputs, so ...
22:53:26 <roconnor> where is small check?
22:53:34 <roconnor> or am I getting spell corrected?
22:53:41 <dmwit_> ?help scheck
22:53:42 <ski_> @help scheck
22:53:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:53:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:53:46 <Twey> dmwit_: Huh?
22:53:47 <Axman6> > maxBound :: (,)
22:53:49 <lambdabot>       `(,)' is not applied to enough type arguments
22:53:49 <lambdabot>      Expected kind `?', b...
22:53:49 <Twey> dmwit_: Three inputs?
22:53:57 <dmwit_> Twey: Are we talking about the same command here?
22:54:00 <ski_> dmwit_ : touché
22:54:00 <Axman6> > maxBound :: (,) Int Int64
22:54:01 <lambdabot>   (9223372036854775807,9223372036854775807)
22:54:01 <Twey> dmwit_: For `@check True`?
22:54:02 <dmwit_> Twey: I was talking about:
22:54:10 <dmwit_> Twey: Nope, we're not. =)
22:54:16 <Twey> Seems so.  :)
22:54:26 <dmwit_> Twey: I was talking about
22:54:27 <dmwit_> ?check \x y z -> ((x == y) == z) == (x == (y == z))
22:54:28 <lambdabot>   "OK, passed 500 tests."
22:54:31 <dmwit_> =)
22:54:34 <dmwit_> Same idea, though.
22:54:41 <Twey> Right-ho :)
22:54:43 <roconnor> (==) is associative
22:54:50 <roconnor> I learned that last year
22:54:55 <dmwit_> Sorry, but (==) is non-associative. =)
22:54:58 <Twey> Heh
22:55:07 <dmwit_> > True == True == True
22:55:07 <lambdabot>       precedence parsing error
22:55:07 <lambdabot>          cannot mix `(==)' [infix 4] and `(==)...
22:55:11 <dmwit_> ;-)
22:55:17 <roconnor> that's dumb
22:55:22 <roconnor> :)
22:55:25 <ski_> (roconnor : but iso-morphism type is not associative ..)
22:55:56 <ski_> @check \x y z -> ((x /= y) /= z) == (x /= (y /= z))
22:55:57 <lambdabot>   "OK, passed 500 tests."
22:56:49 <roconnor> inequality is also associtive
22:57:30 <roconnor> oh right
22:57:30 <ski_> exclusive or
22:57:33 <roconnor> xor is associative
22:59:22 * ski_ idly wonders how to type-theoretify `xor'
23:00:27 <roconnor> not A <-> B?
23:01:19 <roconnor> or did you want <-> to mean isomorphic?
23:01:36 <roconnor> not A <-> not not B?
23:03:40 <chylli> I want to set $? as a non-zero when some tests failed in quickCheck, how to know there are tests failed ?
23:05:37 <ski_> roconnor : i'm not sure .. probably i want that whenever one part is false, the other should be true
23:05:40 * roconnor wonders how darcs does this.
23:05:47 <ski_> does what ?
23:05:59 <roconnor> check if tests fail in quickCheck
23:06:28 <roconnor> ... actually darcs may not even know about quickcheck
23:06:48 <dmwit_> evaluate :: (Testable a) => a -> Gen Result
23:07:17 <cjs> If I'm constantly evaluating a function that returns something like 'foo { bar = bar foo }', i.e., reconstructing a new version of foo that's exactly the same as the old one, is that likely to have any major impact on the performance of my app? Or is the garbage collector so good that it will make little difference?
23:07:17 <dmwit_> Use replicateM to run several such tests.
23:07:21 <ski_> (roconnor : `<->' should mean iso, but i'm not sure whether `xor' should be directly tied in to this)
23:07:44 <dmwit_> cjs: That should be pretty okay.  Are you having problems with it?
23:07:53 <orbitz> is there any desire to add uniqueness typing to haskell?
23:07:57 <roconnor> @type test
23:07:58 <lambdabot> Not in scope: `test'
23:08:05 <dmwit_> cjs: (All the other elements of the structure will be (pointer) copies of the original, so it shouldn't take long.)
23:08:15 <roconnor> @type Test.QuickCheck.test
23:08:16 <lambdabot> Not in scope: `Test.QuickCheck.test'
23:08:22 <roconnor> @hoogle test
23:08:22 <lambdabot> Test.HUnit.Base test :: Testable t => t -> Test
23:08:22 <lambdabot> Test.HUnit.Base data Test
23:08:22 <lambdabot> Test.QuickCheck class Testable a
23:08:33 <cjs> Not so far as I know, but if I rip out some otherwise silly Maybes I'm using all over the place to avoid that, I can simplify my code a bit.
23:08:35 <dmwit_> test :: (Testable a) => a -> IO ()
23:08:37 <opqdonut> http://courses.cs.ut.ee/2006/algebraofprog/Main/HomePage
23:08:40 <opqdonut> nice course :D
23:08:41 <lambdabot> Title: Algebra of Programming | Main / HomePage browse
23:08:56 <roconnor> what happens when test fails?
23:08:57 <cjs> But I'll be doing it quite a lot, in multiple levels of data structure nesting.
23:09:07 <dmwit_> cjs: The garbage collector is likely to be faster than your homebrew garbage preventor. ;-)
23:09:23 <cjs> So probably I should just rip it out, and later profile.
23:09:27 <dmwit_> roconnor: I believe it prints a failure message.
23:09:35 <roconnor> chylli: I'm not sure but I think 'test' fails when a test fails.
23:09:47 <dmwit_> roconnor: no
23:09:50 <jdrake_> A friend is doing C# development, and his latest assignment is doing a threaded traffic simulation (very basic). I was curious if this could be done with haskell, I have heard of 'parallel haskell'. The description has each car being run by a separate thread and using shared data. How might it work in haskell while trying to keep close to the spirit, but doing things in a haskell way? Description can be read here:
23:09:51 <jdrake_>  http://cs.senecac.on.ca/~robert.robson/dps910/DPS910_as3.html
23:09:51 <lambdabot> Title: DPS910 - AS2
23:09:53 <cjs> I was also kinda hoping it might help prevent space leaks, but I've learned that doing things that you hope will prevent them is not usually the solution. :-)
23:09:58 <chylli> roconnor: seems not
23:10:03 <dmwit_> roconnor, chylli: But evaluate does exactly what you want.
23:10:05 <roconnor> oh
23:10:10 <roconnor> oh
23:10:29 <roconnor> how does darcs know that my Tests failed?
23:10:54 <dmwit_> Those tests are totally unrelated to QuickCheck, aren't they?
23:10:57 <chylli> roconnor: co-ask, using git
23:10:58 <dmwit_> Are you talking about pre-record tests?
23:11:09 <chylli> dmwit_: yes
23:11:13 <roconnor> ya darcs setpref test "runhaskell Tests.hs"
23:11:21 <dmwit_> jdrake_: Look for the Beautiful Concurrency paper.
23:11:29 <roconnor> obviously darcs knows nothing about QuickCheck
23:11:30 <chylli> dmwit_: git do like this
23:11:36 <roconnor> I only call test
23:11:40 <dmwit_> jdrake_: Haskell has several nice concurrency abstractions: STM, MVars, Chans, etc.
23:11:44 <roconnor> so I figured test must fail
23:11:49 <dmwit_> jdrake_: Shared memory is an option on *nixes, too, I believe.
23:12:12 <jdrake_> dmwit_, sounds interesting...
23:12:17 <roconnor> anyhow
23:12:20 <cjs> jdrake_, dmwit_: Doing it the "Haskell way" (probably STM) sort of entirely changes the point of the exercise, which appears to be to learn to use C# synchronization constructs. :-)
23:12:32 * dmwit_ nods
23:13:01 <chylli> roconnor, dmwit_ : must I parse the result string like 'ok' or 'fail' ?
23:13:28 <roconnor> meh I'm sure whatever the C# synchronization constructs, the are persumably impossible to use.
23:13:34 <ski_> orbitz : i'd think such would be interesting
23:13:37 <dmwit_> chylli: No!
23:13:38 <jdrake_> cjs, I want to at least have some kind of parallel controlled cars going, that is what I interpret as the basis of the project
23:13:40 <roconnor> chylli: how about the suggestion to use evaluate?
23:13:43 <cjs> So you could just use the Haskell equivalants of the C# synchronization constructs, in which case just look at the library docs for both, or you could try to do the exercise you'd get in the Haskell class, and use STM.
23:13:57 <roconnor> <dmwit_> roconnor, chylli: But evaluate does exactly what you want.
23:13:57 <chylli> roconnor: sorry, I don't know what's the mean :(
23:14:06 <roconnor> @hoogle evaluate
23:14:06 <lambdabot> Control.Exception evaluate :: a -> IO a
23:14:06 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
23:14:25 <chylli> roconnor: let me try
23:14:27 <chylli> thanks
23:14:32 <dmwit_> And, as I said the first time I suggested this, you can use replicateM to run the test many times.
23:15:09 <jdrake_> I am not sure there is any value in using haskell equivalents, because such a translation sounds like lunacy to me.
23:15:19 <jsn> is there a way, within cabal, to check the version of template haskell that is available and conditionally set a CPP flag?
23:15:21 <cjs> jdrake_: Well, either way, just read up on the stuff available in Control.Concurrent and chose what looks good to you. For extra credit, do it several different ways.
23:15:28 <jsn> i'm not having trouble setting the flag
23:15:35 * sjanssen is sad about the de-generalization of Data.Map.lookup
23:15:37 <jsn> but testing the version of a package is eluding me
23:15:42 <chylli> roconnor: I don't find this action in ("space_special",  prop_SpaceBegin),
23:15:42 <chylli>  
23:15:48 <chylli> roconnor: sorry
23:15:53 <jdrake_> dmwit_, is this the right one? Beautiful Concurrency by  Simon Peyton Jones, Microsoft Research, Cambridge
23:15:54 <chylli> roconnor: http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.1/doc/html/Test-QuickCheck.html#1
23:15:56 <lambdabot> Title: Test.QuickCheck, http://tinyurl.com/6al8uw
23:16:03 <dmwit_> jdrake_: The very same!
23:16:20 <dmwit_> jdrake_: SPJ is my favorite paper writer, though Wadler comes close...
23:16:37 <ski_> @type Data.map.lookup
23:16:38 <lambdabot> Couldn't find qualified module.
23:16:41 <jdrake_> dmwit_, I will be sure to read it tomorrow :p
23:16:42 <ski_> @type Data.Map.lookup
23:16:43 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
23:16:43 <roconnor> chylli: presumablly you need to evaluate prop_SpaceBegin
23:17:02 <ski_> sjanssen : ?
23:17:19 <sjanssen> @type Data.Map.lookup
23:17:20 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
23:17:26 <chylli> roconnor: I mean, I didn't find it in the QuickCheck doc
23:17:39 <sjanssen> ski_: in GHC 6.10, that function returns a "Maybe a"
23:17:59 <roconnor> chylli: indeed.  Prehaps it is now called quickCheckResult ?
23:18:11 <ski_> sjanssen : you want `m a' for `MonadZero m' ?
23:18:11 <roconnor> well
23:18:20 <roconnor> at least quickCheckResult seems to do what you want
23:18:26 <sjanssen> ski_: right, [] in my particular case
23:18:50 <ski_> *nod*
23:18:50 <sjanssen> ski_: r <- maybeToList (M.lookup f (W.floating ws)) -- is a bit annoying
23:19:22 <sjanssen> Just r <- [M.lookup f (W.floating ws)] -- is another option, not sure whether it is better or worse
23:19:24 <ski_>   Just r <- M.lookup ...
23:19:37 <ski_> um, right
23:19:40 <sjanssen> ski_: you have to inject the value into your monad
23:19:41 <Twey> ... huh?
23:19:46 <Twey> That's not the same
23:19:49 <ski_> i forgot
23:19:55 <Twey> (and will fail)
23:20:58 <xpik1> @pl (\x -> map (++fst x) (snd x))
23:20:58 <lambdabot> uncurry (map . flip (++))
23:23:44 <ski_> it might be nice if one could make pattern-matching failures in bindings "spill over" to a `MonadZero'
23:24:10 <ski_> but i'm not sure how one could make that nicely
23:24:16 <ski_>   do ...
23:24:26 <chylli> roconnor: dmwit_ thanks
23:24:27 <ski_>      let Just r = M.lookup ...
23:24:31 <chylli> I got it
23:24:32 <ski_>      ..r..
23:25:10 <dmwit_> chylli: Great!
23:25:14 <xpik1> @pl do {a<-f n;return (g a))
23:25:14 <lambdabot> (line 1, column 4):
23:25:14 <lambdabot> unexpected "{"
23:25:14 <lambdabot> expecting variable, "(", operator or end of input
23:25:21 <xpik1> @pl do {a<-f n;return (g a))}
23:25:21 <lambdabot> (line 1, column 4):
23:25:21 <lambdabot> unexpected "{"
23:25:21 <lambdabot> expecting variable, "(", operator or end of input
23:25:43 <ski_> xpik1 : g `liftM` f n
23:27:20 <jsn> i am correct that it is not possible, from within cabal, to test the version of a package?
23:27:25 <twb> I want to learn about Cabal so I can teach darcs.cabal to build documentation.
23:27:39 <twb> Where is the *current* documentation for Cabal?
23:28:02 <twb> (Last time I guessed, I apparently managed to find instructions for installing cabal-install that were obsolete.)
23:28:12 <jsn> twb: i think this must be it
23:28:13 <jsn> http://www.haskell.org/cabal/release/latest/doc/users-guide/
23:28:13 <lambdabot> Title: Common Architecture for Building Applications and Libraries
23:29:53 <twb> Bleh, cabal has a default target for haddock, but not for user documentation?
23:30:12 <sjanssen> twb: Cabal is very Haskell-centric
23:31:22 <twb> Since Cabal is going to be replacing autoconf/make, I guess that means I'll need to make it part of ./setup build.
23:31:47 <twb> I guess that's not so bad, since currently the documentation can't be built without compiling all the .o files.
23:36:24 <twb> I probably need to add support for ./setup configure --with-pdflatex=/opt/silly/pdflatex and --without-documentation, though.
23:38:13 <jsn> ?localtime Saizan_
23:38:14 <lambdabot> Local time for Saizan_ is Tue Nov 18 08:37:43 2008
23:40:26 <jsn> Saizan_: i'm trying to figure out how to set a CPP flag with that depends on the template-haskell version, as you suggested
23:40:36 <jsn> Saizan_: i'm kind of stuck on testing the version, though
23:41:21 <twb> Is there an Emacs major mode for editing .cabal files?
23:42:26 <twb> Aha, it just wasn't autoloaded.
23:45:17 <chylli> roconnor: the datatype Result is not a monad, so how to get failure or success from [Result] ?  should I declare it as an instance of monad ?
23:47:06 <roconnor> pattern match
23:47:29 <roconnor> or you could write your own adaptor function
23:48:46 <chylli> roconnor: thanks. I had think there are something like this in quick check
