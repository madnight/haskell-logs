00:01:42 <Twey> Hmm, how *does* XSLT work with hAppS?
00:02:04 <lispy> ?brain
00:02:04 <lambdabot> I think so, Brain! How much deeper would the ocean be if there weren't sponges down there?
00:02:09 <lispy> heh
00:02:14 <Twey> Hahaha
00:03:09 <Twey> I thought about this before — using XSLT as a template language — but it seemed to end up involving transforming all data to XML first, and thus having an XML class for each possible datatype, which doesn't seem very elegant at all
00:03:25 <Twey> The FAQ is, of course, blank.
00:03:31 <lispy> XSLT is not a very pragmatic functional language
00:03:42 <lispy> It's actually quite easy to do incorrect transformations with it
00:04:22 <Twey> Yes, quite
00:04:33 <lispy> Twey: you could use Data.Derive or DrIFT to automate the translation of data to XML
00:05:38 <lispy> what i mean by that is, as far as metaprogramming is concerned that's more or less a solved problem
00:05:49 <lispy> so don't let that stop you :)
00:06:23 <Twey> lispy: It still seems somewhat awkward... since the developer does/never see the XML representation, and XSLT cares about the order of elements...
00:06:55 <lispy> Twey: I think XSLT mainly exists because in languages like C/C++ that need to process XML it can be easier to use XSLT to express it and you don't lose much safety.  But, compared to Haskell I would say that XSLT is a degrade in safety and expressiveness
00:07:14 <Twey> Also, XSLT can't transform directly to HTML, as far as I know
00:07:31 <lispy> XSLT in principle can output text of any kind
00:07:37 <Twey> lispy: Aye... but writing templates directly in Haskell is kind of fugly
00:07:47 <lispy> but there is also nothing to make output HTML easy...XHTML perhaps
00:07:55 <Twey> Aye, but it needs to be... yeah
00:08:12 <Twey> XHTML isn't really feasible for proper websites
00:08:19 <lispy> why is that?
00:08:27 <lispy> still not enough browser support?
00:08:37 <Twey> IE doesn't support it
00:08:57 <lispy> I'm always surprised to learn that people still use IE
00:09:02 <lispy> but I've heard it's still quite popular
00:09:03 <Twey> Having the biggest browser on the market refuse to render your page is a big set-back, and not one most clients will accept...
00:09:09 <Twey> Yeah, alas
00:11:09 <lispy> Twey: a schema safe language to compete with XSLT would be nice
00:11:25 <lispy> instead of type safe, I think schema safe is what you need/want
00:12:37 <lispy> I think you could even encode your transformations in GADTs fairly naturally and make sure that your implementation of the transformations is correct via the type system!
00:12:56 <lispy> (there's a paper in there....)
00:25:03 <lispy> Note: the public hackage server would reject this package.
00:25:09 <lispy> I wish it said why :(
00:28:04 <lispy> dcoutts_: I'm having some cabal issues and I could use your expertise if you're available
00:58:49 <ketil> tu
00:58:54 * ketil growls
00:59:05 * BeelsebobWork sets lambdabot on ketil 
00:59:14 <ketil> @botsnack
00:59:14 <lambdabot> :)
00:59:15 <ketil> @botsnack
00:59:15 <lambdabot> :)
00:59:16 <ketil> @botsnack
00:59:16 <lambdabot> :)
00:59:19 <BeelsebobWork> watch out, she'll make you pointless!
00:59:20 * ketil feels safer now.
00:59:24 <ketil> :-)
01:07:45 <lispy> sjanssen: darcs-2.1.2.1 is on hackage
01:11:05 <hackage> Uploaded to hackage: darcs 2.1.2.1
01:20:21 <sjanssen> lispy: any idea where "Distribution.ShellHarness" might come from?
01:20:58 <lispy> sjanssen: yes, try again, I just fixed it in 2.1.2.2
01:21:09 <lispy> sorry!
01:21:39 <sjanssen> no problem
01:21:58 <lispy> that was quite literally my first hackage upload, so I was bound to get it wrong :)
01:23:05 <sjanssen> lispy: forget an extra-source-files listing?  I've done that before :)
01:23:36 <lispy> sjanssen: Yeah, we've been removing all the perl from our test suite
01:23:52 <lispy> sjanssen: and yeah I forgot to list the new test harness
01:24:21 <sjanssen> lispy: after doing that once, I've made the habit of always compiling the tarballs that Setup dist creates
01:24:27 <sjanssen> it really is to easy to get it wrong
01:24:40 <lispy> heh, yeah, that's what I did :)
01:25:03 <lispy> I asked hackage to check the package and it didn't find the problem
01:25:21 <lispy> which is unfortunate
02:11:05 <hackage> Uploaded to hackage: darcs 2.1.2.2
02:12:40 <dcoutts> oooh
02:12:40 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
02:27:23 <lispy> dcoutts: I think I figured out my cabal woes
02:27:36 <lispy> dcoutts: save one
02:27:42 <dcoutts> lispy: yes?
02:28:12 <jsn> quasi-quotes and IsString are kind of the same idea?
02:28:12 <lambdabot> jsn: You have 1 new message. '/msg lambdabot @messages' to read it.
02:28:13 <lispy> dcoutts: as Meacham commented in -cafe, what is the proper way to upload different copies of a 1 release as you fix bugs with a hackage package?
02:28:30 <lispy> dcoutts: what I did in thec ase of darcs is I added an extra .n to the package
02:28:47 <dcoutts> lispy: yes, that's fine
02:28:48 <lispy> dcoutts: but, this has the side effect that the version of darcs it builds for you is slightly different than the official stable release
02:29:37 <lispy> dcoutts: and I think eric has some concern that may confuse people who see the ANN for darcs 2.1.2
02:30:33 <dcoutts> lispy: you get to manage the version numbers how you like, but you cannot change a release after it's out
02:31:05 <dcoutts> lispy: a fourth digit for patch level is quite common
02:31:16 <BeelsebobWork> @type (<$)
02:31:17 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
02:31:18 <lispy> dcoutts: okay, but what I'm getting at, is that I would like for what's on hackage as 2.1.2.x to install as 2.1.2
02:31:51 <lispy> dcoutts: are you saying this is just something I need to fix in Setup.lhs for darcs?
02:31:57 <dcoutts> lispy: what darcs reports for --version is up to you
02:32:29 <lispy> dcoutts: next question, in the future, could I make the version string on hackage be 2.1.2-1 a la debian?
02:32:32 <jsn> to be honest, i kind of prefer IsString to QuasiQuoting, since IsString let's the type context sort things out.
02:32:33 <dcoutts> lispy: if you choose to only report the first three digits in darcs --version then nobody can stop you, but the package version is the one that it is released with
02:33:04 <jsn>  s/let's/lets/
02:33:24 <dcoutts> lispy: the significance of the digits is only be convention, there's no syntax for 2.1.2-1 or 2.1.2-r1 as some systems use.
02:33:30 <dcoutts> be/by
02:34:02 <lispy> dcoutts: no syntax means hackage would reject them as malformed?
02:34:42 <dcoutts> lispy: yes, package version strings are a sequence of digits separated by '.', that's how we parse it and represent it internally.
02:35:08 <dcoutts> lispy: I thought that the 2.1.2 release was using autoconf, so I was surprised to see it on hackage
02:35:17 <lispy> :)
02:35:22 <lispy> it uses either
02:35:58 <lispy> cabal install and let me know if it gives you grief.  It's the first time I've uploaded to hackage so I may have made mistakes.
02:36:07 <lispy> I was able to cabal install it
02:36:51 <lispy> and I noticed that our use of -O2 makes hackage angry :)
02:37:06 <dcoutts> lispy: it's a warning, not an error
02:37:18 <lispy> yeah
02:37:20 <dcoutts> lispy: and since you're sure you know better then that's fine.
02:37:30 <dcoutts> lispy: have you tested the performance difference?
02:37:33 <lispy> I'm looking forward to seeing our haddocks appear
02:37:35 <dcoutts> is it measurable?
02:38:05 <dcoutts> lispy: there are no haddocks for exes, only libs, exes do not expose modules
02:38:07 <lispy> personally?  no.  Perhaps someone has back in antiquity.  We have the performance benchmarks now.  But, I'm a bit busy with other things to do it myself.  It would be valuable though.
02:38:30 <lispy> dcoutts: ah.  We do, at least the GNUmakefile can build haddocks
02:38:45 <lispy> haddock still makes a lot of sense for executables IMO
02:38:51 <lispy> devs still need to grok the source
02:39:02 <dcoutts> lispy: yes, cabal can do it, but hackage doesn't because that's for users
02:39:15 <lispy> ah
02:39:23 <lispy> well, we have them at darcs.net so I won't frett :)
02:39:30 <dcoutts> lispy: cabal haddock --executables
02:39:44 * lispy makes a mental note
02:40:00 <lispy> Does that have a way to pass options to haddock?
02:40:13 <lispy> we need to pass some things typcally, like telling haddock to ignore the export list
03:00:00 <lispy> tim sheard really has a wealth of good papers on his website
03:00:07 <lispy> http://web.cecs.pdx.edu/~sheard/
03:01:45 <dolio> He did create Omega.
03:01:51 <dolio> The language everyone's been waiting for.
03:01:59 <lispy> yeah, and designed TH it would seem
03:22:26 <dcoutts> lispy: $ darcs --version
03:22:26 <dcoutts> 2.1.2.2 (unknown)
03:24:38 <lispy> dcoutts: sweet
03:24:55 <procyon112> does cabal-install honor the HOME env variable in Windows to find it's config file?  alternatively, is there anything I can set to get it to look for a speciic config file?
03:26:10 <dcoutts> procyon112: no, it uses the per-user application and settings dir
03:26:33 <procyon112> hmmm.  bummer.
03:26:44 <dcoutts> procyon112: returned by getAppUserDataDirectory
03:27:14 <dcoutts> getAppUserDataDirectory "cabal" returns $HOME/.cabal on unix systems and the appropriate windows thing on windows
03:27:47 <dcoutts> on windows it's a windows app and so follows the windows conventions
03:28:06 <lispy> procyon112: I wouldn't be surprised if windows allows you to set something in the registery or some place like that to make it point where you want
03:28:19 * procyon112 is trying to get a user agnostic build environment set up.
03:28:26 <dcoutts> procyon112: there's a command line flag to give an alternative config file
03:29:11 <procyon112> ok then.  I can just wrap cabal.exe then and pass an env variable for that flag.  cool.
03:29:38 <dcoutts> procyon112: cabal --config-file=blah command
03:30:24 <dcoutts> ie it's a global flag that comes before any particular sub-command
03:31:10 <procyon112> that will work.  I'll write a small wrapper exe with HSH.
03:31:14 <procyon112> thx!
03:31:57 <procyon112> And make sure cabal.exe isn't in my path so it doesn't get accidentally used.
03:34:12 <procyon112> I'm making a standardised build environment that is all in darcs, which ensures that the build environment has all the same dependencies.  I don't want user specific settings messing it up.
03:35:27 <dcoutts> procyon112: perhaps you could file a ticket for that, eg some flag to suppress getting configuration options from any config file
03:36:56 <lispy> procyon112: 'a standardized build environment that is all in darcs' sounds interesting
03:37:10 <procyon112> sounds like a plan.  Some ENV variable would be nice, like CABAL_INSTALL_CFG=c:\mycabal
03:38:16 <aeolist> is anybody in the mood for chatting? i recently read the haskell history pdf and i fail to see why Type Classes are such a huge new concept...
03:38:52 <procyon112> lispy: It's basically so at any machine I can darcs get and have my entire build system right there.  No custom configurations on a per-machine basis... no installs, etc.
03:41:27 <procyon112> lispy: I've got emacs and my .emacs file, GOA, ghc, my ghc packages all in it, and a batch file to set up the local environment.  All I need is a USB key with darcs.exe, and it's like remoting without the remoting ;)
03:41:43 <lispy> procyon112: cool
03:42:20 <lispy> procyon112: I put the latest release of darcs on hackage today so you could even get that off hackage now if your cabal and cabal-install are sufficiently recent :)
03:42:46 <lispy> 'cabal install darcs >= 2.1.2'
03:42:51 <dcoutts> procyon112: are you going to file a ticket then?
03:42:51 <sjanssen> aeolist: what specifically do you contest?
03:43:06 <twb> @hoogle rawSystemProgramStdoutConf
03:43:06 <lambdabot> Distribution.Simple.Program rawSystemProgramStdoutConf :: Verbosity -> Program -> ProgramConfiguration -> [ProgArg] -> IO String
03:43:30 <aeolist> sjanssen: i dont know, maybe i just dont grasp the concept really well
03:43:30 <procyon112> they are :)  I'm just trying to get cabal-install working constrained to the build environment so it dumps to the right places :)
03:43:46 <aeolist> sjanssen: i am not contesting, i am trying to understand why it's considered unique etc etc
03:44:11 <aeolist> let me re-read that part
03:46:05 <lispy> aeolist: well, they add overloading (aka ad-hoc polymorphism) to a language that has parametric polymorphism and H-M type checking.  I'm pretty sure it was the first way found to do that?
03:47:28 <sjanssen> constructor classes (classes with kind other than *) are also pretty unique
03:48:05 <lispy> sjanssen: classes with kind other than *?
03:48:08 <aeolist> ad hoc polymorphism says: if it's a string, do this, if it's an integer do that etc?
03:48:14 <sjanssen> lispy: Functor, Monad
03:48:16 <lispy> aeolist: yeah
03:48:34 <lispy> sjanssen: oh, I se
03:48:36 <sjanssen> it might be a bit of a stretch to call type classes "ad hoc"
03:48:36 <lispy> +e
03:49:01 <lispy> sjanssen: ad-hoc modifies polymorphism in that case
03:49:16 <lispy> sjanssen: ad-hoc polymorphism meaning overloading.
03:49:27 <sjanssen> IIRC, a famous paper on type classes is titled something like "Making ad hoc polymorphism les ad hoc"
03:49:27 <lispy> sjanssen: it's a contrast to parametric polymorphism
03:50:20 <lispy> that sounds like an SPJ title to me :)
03:50:27 <sjanssen> lispy: Wadler, I think
03:50:28 <aeolist> polymorphism is giving me the headaches
03:50:35 <lispy> sjanssen: oh, wadler makes sense too
03:50:37 <sjanssen> @google making ad hoc polymorphism less ad hoc
03:50:43 <lambdabot> http://citeseer.ist.psu.edu/wadler88how.html
03:50:50 <lispy> wadler it is
03:51:14 <lispy> monomorphism is the one I find odd
03:51:25 <lispy> you still get to parameterize it, but you fix the parameterization
03:51:27 <blarf> what is Haskellers main complaint about Lisp? its dynamicy?
03:51:53 <procyon112> It's lack of compile time type checking.
03:51:56 <Gabbie> it smells slightly of turpentine
03:52:03 <lispy> blarf: for me yes.  Haskell's static guarantees are one of the reasons I stopped using it and started using Haskell
03:52:15 <aeolist> lispy: what is HM type checking
03:52:25 <lispy> aeolist: hindly-milner
03:52:50 <aeolist> you are scaring me again, arent you... oh well, back to studying
03:52:59 <lispy> aeolist: GHC actually uses a variation of damas-milner, but Haskell98 can be checked with H-M (I'm not an expert here, just quoting a paper I looked at recently by SPJ)
03:53:01 <sjanssen> aeolist: do you understand type classes?  It might be hard to see why they're unique if not :)
03:53:56 * lispy notes it hard to explain why type classes are special because they are so different
03:54:13 <lispy> They're like....X but totally different.
03:54:35 <lispy> They're like interfaces...oh wait nope not quite
03:54:42 <mapreduce> Imagine CLOS but dispatched on type rather than tag.
03:54:49 <mapreduce> (where tag = runtime type)
03:54:59 <aeolist> i'll read about all these concepts a bit more and come back for questions... i really hate the way polymorphism is explained in most articles, i want more practical explanations, like how does the compiler handle the different kinds of polymorphism
03:55:10 <lispy> type classes are like GADTs but they are open instead of closed :)
03:55:34 <procyon112> aeolist: what language are you used to?
03:56:08 <lispy> aeolist: in GHC type classes are implement by passing a dictionary that maps types to implementations of the functions in the type class
03:56:33 <lispy> aeolist: and that dictionary is pass to any function which uses the type class
03:56:38 <aeolist> procyon112: the usual imperative stuff (c, java) and ocaml
03:56:39 <lispy> aeolist: does that help?
03:56:45 <aeolist> lispy: yes
03:57:23 <aeolist> lispy: that's ad hoc polymorphism right?
03:57:27 <lispy> aeolist: so in GHC type classes can add run-time overhead
03:57:40 <lispy> aeolist: yes it is
03:58:17 <lispy> aeolist: there exists at least one haskell compiler that tries to resolve all the types that can actually be passed to the fuction at compile time so thta no dictionary needs to be passed
03:58:40 <lispy> aeolist: but, I don't know if this implementation is actually theoreticaly sound
03:58:49 <lispy> (i'm skeptical)
03:59:07 <aeolist> ok so what about parametric polymorphism? it only applies to more general concepts, like a list... which is implemented as data + a pointer, so in order to join 2 lists you dont have to know what type the elements are, just fix the pointers
03:59:53 <lispy> aeolist: yeah, in parametric polymorphism you can't do anything that makes use of the parameterised type
04:00:05 <procyon112> aeolist: If you know Java or C# generics, or C++ templates, then you are already familiar with the basics of parametric polymorphism.. you just aren't used to the name :)
04:00:08 <lispy> aeolist: i mean, depends on specific knowlegde of the parameter's type
04:00:18 <sjanssen> aeolist: yes, that's right.  All parametrically polymorphic containers have the same representation no matter what type is contained
04:00:25 <sjanssen> (in GHC, at least)
04:00:45 <lispy> aeolist: yeah, java generics are analogous to haskell's parameteric polymorphism
04:00:46 <mapreduce> How is "parametrically polymorphic" different to "generic"?
04:01:02 <procyon112> generic is a more generic term :)
04:01:30 <aeolist> sjanssen: i guess at the lowest level, you'll still need to find out how big the data is
04:01:30 <Saizan> in haskell "generics" is used for other things
04:01:36 <sjanssen> mapreduce: generic is a much more general word.  "parametrically polymorphic" means what it says, polymorphic because it is parameterized on a type
04:01:38 <aeolist> mmm, no not true
04:01:39 <lispy> mapreduce: to me they are the same concept, the difference just lies in the choices made by the designers to make it fit their needs like backwards compatibility with the language
04:01:45 <aeolist> forget what i just said
04:01:51 <sjanssen> aeolist: GHC uses a pointer to data
04:02:03 <mapreduce> lispy: Yes, raw types are a silly idea.
04:06:50 <hugo__> :t mapM
04:06:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:06:53 <aeolist> well thank you all
04:07:04 <hugo__> @src mapM
04:07:05 <lambdabot> mapM f as = sequence (map f as)
04:07:31 <hugo__> just checking :P
04:08:04 <sjanssen> lispy: "darcs failed:  Codec.Compression.Zlib: incorrect data check" from the new darcs.  Any advice?
04:08:27 <lispy> sjanssen: that sounds not good
04:08:43 <lispy> sjanssen: what version of ghc and bytestring do you use?
04:08:59 <sjanssen> 6.8.2
04:09:12 <sjanssen> and 0.9.0.1
04:09:55 <lispy> sjanssen: does this sound like your bug? http://bugs.darcs.net/issue844
04:10:01 <lambdabot> Title: Issue 844: b0rked CRCs in _darcs/patches/*-*-*.gz - Darcs bug tracker
04:10:40 <dcoutts> sjanssen: ie the corruption happened previously and the new darcs detects it
04:11:12 <sjanssen> dcoutts: possible, but doesn't seem likely
04:11:33 <dcoutts> sjanssen: given the history of that bug I think it's pretty likely
04:11:48 <sjanssen> I recorded a patch, but now check, obliterate, push, unrecord all fail with that error
04:12:05 <dcoutts> sjanssen: on the patch you recorded or on an older one?
04:12:32 <lispy> sjanssen: hmm...you should have the patch that fixes in 2.1.2, I'll double check
04:12:37 <sjanssen> dcoutts: how can I tell which patch has the problem?
04:12:44 <dcoutts> sjanssen: ah of course the exception does not tell you that
04:12:58 <dcoutts> sjanssen: there's a check script in that bug ticket
04:13:07 <dcoutts> basically calls gzip to check all the patches
04:13:16 <lispy> sjanssen: yeah, so the bug fix for issue844 is in your darcs...weird.
04:13:48 <lispy> sjanssen: does darcs repair help?
04:13:52 * lispy doesn't expect it to
04:14:14 <dcoutts> lispy: the fix to not introduce new corruption is in, but what about corruption in existing repos?
04:14:30 <sjanssen> dcoutts: yes, the bad CRCs all seem to be in old patches
04:14:43 <dcoutts> lispy: the old darcs used gzwrite(hnd, 0), and that's sjanssen's problem
04:14:45 <lispy> dcoutts: I understand.  That is a possibilyt.
04:14:54 <dcoutts> the new darcs correctly identifies the bad crcs
04:15:04 <lispy> hmm.
04:15:08 <dcoutts> lispy: that's the bit of this bug I do not get,
04:15:27 <sjanssen> so what can I do?
04:15:31 <dcoutts> lispy: the bug was from calling gzwrite(hnd, 0) but why did gzread not detect it?
04:15:51 <lispy> sjanssen: I'm not sure.  I'm trying to read the bug description to see what the reporter did.  IIRC theydid something.
04:15:59 <dcoutts> lispy: why is it only the haskell zlib package and standalone gzip that seems to detect it?
04:16:02 <lispy> dcoutts: and why did we gzwrite empty strings?
04:16:15 <lispy> dcoutts: like why do we even have that case?
04:16:34 <dcoutts> lispy: well that's another issue, but I think the most important question is how was reading in borked patches able to work?
04:16:51 <sjanssen> great, XMonadContrib has tons of bad CRCs.
04:17:11 <dcoutts> lispy: eg was it just that darcs ignored errors on closing the gz handle?
04:17:22 <lispy> sjanssen: http://bugs.darcs.net/msg6640
04:17:22 <lambdabot> Title: Message 6640 - Darcs bug tracker
04:17:40 <lispy> dcoutts: that's a good possibility
04:17:48 <dcoutts> lispy: lemme check...
04:18:35 <lispy> sjanssen: in that msg David gives a way to fix your repo I think
04:21:11 <jsn> Saizan: yeah, that trick was finally clarified to me in email
04:21:16 <sjanssen> lispy: yes, that script seems to work
04:21:42 <lispy> sjanssen: good, it seems we need support for this in darcs repair, ASAP
04:21:57 <sjanssen> lispy: I predict this will be a big problem in the future
04:22:02 <sjanssen> lispy: right
04:22:06 <lispy> sjanssen: and I agree it will
04:22:39 <sjanssen> xmonad, XMonadContrib and xmobar each have this problem
05:09:58 <rskjr> looking at http://en.wikibooks.org/wiki/Haskell/Advanced_monads
05:10:00 <rskjr> what is the $ ?
05:10:11 <rskjr> find3rdConfig :: Board -> [Board]
05:10:14 <rskjr> find3rdConfig bd = tick $ tick $ tick [bd]
05:11:25 <Saizan> @src $
05:11:25 <lambdabot> f $ x = f x
05:12:05 <Twey> ($) = id
05:12:35 <rskjr> hmmm i think i'm more confused. where can i find this language feature described? it's hard to google
05:12:47 <idnar> it's just an operator, not a language feature
05:13:20 <Saizan> tick $ tick $ tick [bd] == tick (tick (tick [bd]))
05:13:32 <rskjr> ah.
05:13:33 <rskjr> thanks
05:14:01 <Twey> foo . bar . baz $ quux quuux == (foo . bar . baz) (quux quuux)
05:17:29 <twb> In Cabal, rawSystemProgramConf seems to run a program but not care about the exit status, nor print stderr to the tty.
05:17:29 <kirkt> hey all. ive read that haskell has an implementation of software transactional memory (?). is there any tutorial or such that could teach me just the very least of haskell so i can get my hands wet and see real life STM ?
05:17:58 <twb> Is there a similar procedure that does?
05:18:11 <Zao> kirkt: http://research.microsoft.com/~simonpj/papers/stm/
05:18:11 <Zao> See "Beautify Concurrency"
05:18:12 <lambdabot> Title: Papers on transactional memory
05:18:35 <dcoutts> twb: it throws an exception if the process returns non-0 and it does print stdout and stderr
05:18:42 <kirkt> Zao microsoft uses haskell to research STM
05:18:43 <kirkt> ?
05:18:57 <twb> dcoutts: hmm, it didn't seem to.
05:19:22 <Zao> kirkt: The Cambridge labs employ the two Simons, I believe.
05:19:26 <twb> dcoutts: I'll try again.  It only seemed to print stdout
05:19:32 <dcoutts> twb: it calls rawSystem which does not do any redirection of in/out/err
05:20:51 <dcoutts> twb: the Stdout variant returns the stdout as a string of course
05:20:57 <dcoutts> and ignores stderr
05:20:59 <twb> Yep.
05:21:21 <twb> dcoutts: I'm basically trying to trick Darcs' Setup.hs into rendering the user manual
05:22:35 <twb> dcoutts: hmm, I do "cabal build", but the exit status (with a failing command) is still 0.
05:22:56 <twb> Ooooooh
05:23:00 <dcoutts> ?
05:23:01 <twb> I'm getting fucked by Python, I think
05:23:06 <dcoutts> heh
05:23:23 <twb> I've seen something similar before, it is "clever" and does different things if it detects a tty
05:24:22 <twb> Oh no, the problem is that rst2html --strict apparently stops it returning nonzero on failure.  Argh!
05:24:53 <twb> Let's try cabal build again without --strict
05:25:47 <twb> dcoutts: btw, you know how Darcs now has Distribution/ShellHarness.hs?  I added Distribution/RestructuredText.hs, but I found that "cabal build" wasn't recompiling Setup if I edited RestructuredText.hs
05:26:24 <dcoutts> twb: aye, it only looks at Setup.hs, we do not call ghc --make to ask it to check
05:26:35 <dcoutts> since it does too much work in the common case of there being no changes
05:26:37 <twb> OK, so longs as you know.
05:27:08 <twb> When setup.hs calls rst2html without --strict, it propagates the exit status.
05:27:37 <twb> And I was getting stderr all along, I was just confused because in the other window I'd done ^C and gotten a backtrace, and I was expecting to get a backtrace because I'd forgotten about the ^C
05:30:53 <Daniel_H> @src duplicate
05:30:53 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:30:54 <twb> So now I'm on to the next hurdle: getting Setup.lhs to generate Foo.txt from Darcs.Commands.Foo.foo_help
05:31:18 <Daniel_H> Which order does duplicate take arguments?
05:31:26 <lispy> ?hooge duplicate
05:31:26 <lambdabot> No results found
05:31:36 <lispy> I've never heard of duplicate
05:31:46 <Saizan> Comonad's duplicate?
05:31:47 <lispy> are you thinking of replicate?
05:31:52 <Daniel_H> ah, yes
05:31:53 <Daniel_H> must be
05:32:00 <lispy> ?hoogle replicate
05:32:00 <lambdabot> Prelude replicate :: Int -> a -> [a]
05:32:00 <lambdabot> Data.ByteString replicate :: Int -> Word8 -> ByteString
05:32:00 <lambdabot> Data.List replicate :: Int -> a -> [a]
05:32:05 <Daniel_H> ty
05:32:10 <twb> I immediately thought of Forth dup ^_^;;
05:32:32 <twb> @hoogle a -> (a,a)
05:32:32 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
05:32:32 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
05:32:32 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
05:32:38 <lispy> #haskell is an error correcting channel :)
05:32:55 <lispy> ?pl \a -> (a,a)
05:32:55 <lambdabot> join (,)
05:32:58 <Daniel_H> @hoohle [a] -> a
05:32:59 <lambdabot> Prelude head :: [a] -> a
05:32:59 <lambdabot> Prelude last :: [a] -> a
05:32:59 <lambdabot> Data.List head :: [a] -> a
05:33:08 <lispy> I knew lambdabot would use reader for that
05:33:18 <Daniel_H> @hoogle [[a]] -> [a]
05:33:18 <lambdabot> Prelude concat :: [[a]] -> [a]
05:33:18 <lambdabot> Data.List concat :: [[a]] -> [a]
05:33:18 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
05:33:22 <lispy> it should also be possible to do a -> (a,a) using arrows
05:33:22 <Daniel_H> :)
05:33:42 <Saizan> ?type id &&& id
05:33:43 <lambdabot> forall a. a -> (a, a)
05:33:51 <lispy> Saizan: thanks :)
05:33:59 <lispy> :t (***)
05:34:00 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
05:34:03 <twb> dcoutts: so what I want to do for the user manual is have Haskell code the imports all the Darcs.Commands.* modules, and prints the help for each command to a file.  But obviously if I just import them in Setup.hs, Setup.hs will end up compiling most of Darcs before it starts!  Is there a way to get out of this dilemma?
05:34:14 <Saizan> ?type join (&&&) id -- reader _and_ arrows!
05:34:14 <lambdabot> forall c. c -> (c, c)
05:34:45 <twb> dcoutts: I thought of building a secondary, temporary executable like src/preproc.hs was for the TeX version, but I'm not sure if that's elegant OR workable.
05:34:53 <lispy> Saizan: cute
05:35:15 <lispy> twb: you could do that easily with cabal but you'll have to repeat stuff in darcs.cabal
05:35:39 <lispy> twb: actually, maybe i'm wrong about repeating
05:35:53 <twb> lispy: you mean a separate Executable stanza?
05:36:10 <twb> lispy: I worry if I do that, that 1) it won't be built by default; or 2) it'll be built and installed by default.
05:44:24 <dcoutts> twb: I'd recommend against importing darcs code in Setup.hs, especially since you cannot specify things like -isrc
05:44:35 <twb> dcoutts: right.
05:44:39 <dcoutts> twb: and it cannot use any conditional compilation
05:44:51 <twb> dcoutts: so what's the "right" way to go about this?
05:45:21 <dcoutts> twb: build a second exe and call it
05:45:40 <twb> dcoutts: should I have a second Executable stanza in darcs.cabal?
05:46:07 <dcoutts> twb: unfortunately that'll mean it ends up getting installed
05:46:18 <twb> Right, that's what I worried about
05:46:24 <dcoutts> twb: there isn't an easy obvious way to do it at the moment
05:46:27 <lispy> http://serv1.ist.psu.edu:8080/viewdoc/summary?doi=10.1.1.105.4873
05:46:29 <lambdabot> Title: ABSTRACT Compositional Explanation of Types and Algorithmic Debugging of Type Er ...
05:46:32 <twb> dcoutts: OK.
05:46:45 <dcoutts> twb: darcs pushes the boundary of what people want to do in Setup.hs
05:46:49 <twb> dcoutts: fortunately, we have several months before Darcs adopts Cabal as its one true build system!
05:47:07 <twb> That's plenty of time for you to get this deployed everywhere, right? ;-)
05:47:15 <twb> *implemented and deployed
05:47:25 <dcoutts> twb: the obvious thing for the future is to declare an extra executable that's a build tool
05:47:41 <dcoutts> and have a way to build that from the Setup.hs
05:47:57 <matthew-_> help. I need to be able to get ghc to load a library (data.time) without data.time being in the ghc pkg list
05:48:02 <twb> dcoutts: I'd also like to be able to have separate "pdf" and "html" targets, like is common for make.
05:48:16 <twb> Or something like "cabal build pdf" or "cabal documentation pdf".
05:48:28 <lispy> I don't see how we can step using the makefile
05:48:31 <lispy> er stop
05:48:42 <lispy> We can use cabal for darcs but not the other targets
05:49:02 <dcoutts> twb: please file feature requests describing how more general support for docs should work, what the interface should be for users and developers
05:49:03 <twb> lispy: you don't see this as something to fix in Cabal, but something
05:49:04 <matthew-_> data.time is built and installed, but for silly numbers of complicated reasons, it's not going in the ghc pkg list. I can't work out which magic cantation of flags are needed to get ghc to find and load it from the command line
05:49:24 <twb> dcoutts: I admit I haven't thought much about it
05:50:25 <Saizan> matthew-_: if you've the directory of .hi .o files you can just -idir
05:50:41 <lispy> twb: even if duncan released a version of cabal tomorrow that did everything we need, how could we justify requiring it?  What would all the people that can build juts fine with autotools and make do?
05:50:48 <twb> dcoutts: I suppose it would be complicated by the need to know when the docs are up to date
05:51:02 <matthew-_> Saizan: I'm trying that and it's not working
05:51:13 <lispy> twb: unlike droundy I don't see the evil of maintaining more than build description.  It's relatively little work.
05:51:23 <lispy> more than one*
05:51:24 <matthew-_> Saizan: with -v it says it's still looking for the .hs files
05:51:48 <twb> lispy: it's not a "build description", it's not declarative.  There's like 500 lines of code, and some of it is extremely hairy.
05:52:04 <twb> lispy: and what happens is some bastard adds a file in src/ and that code needs to be updated to handle it correctly.
05:52:27 <twb> lispy: and the guy who added the file probably won't write good make/cabal code -- so the make/cabal code gets hairier and harier
05:52:27 <matthew-_> Saizan: it seems like it will use the .hi and .o if they're there and match the .hs, but if the .hs isn't there, no dice
05:52:45 <lispy> twb: I'm talking about maintaining both make+autotools along side a .cabal file.  I don't know what you're talking about :)
05:52:46 <Saizan> matthew-_: yeah, my bad
05:52:47 <matthew-_> and because Data.Time uses lots of cbits, sticking the .hs in doesn't help
05:52:52 <twb> lispy: and of course Right Now the .depend code is a total mess
05:53:27 <twb> lispy: as Darcs ships now, you can't build .depend without QuickCheck 2.1 installed, even though it's only used to build .depend for the testing dependencies.
05:53:48 <lispy> twb: oh yeah, that bit me recently so I deleted the unit tests :)
05:54:24 <twb> lispy: and don't forget problems like "sorry, you can't use find(1) because it breaks the builds on Windows."
05:54:56 <twb> "Oops, you can't use POSIX 2003 flags because they aren't in OpenBSD and Solaris yet."
05:55:17 <matthew-_> grr, can't even make it link against libHSTime
05:55:23 <matthew-_> is there really no way round this?
05:56:23 <lispy> twb: these are not show stoppers.  We have build bots.  It's just a minor annoyance that is easy to fix once the real work has been done.  This is in contrast to telling people "you *have* to have the darcs HEAD of cabal."
05:56:29 <Saizan> matthew-_: maybe registering in-place instead of a normal install could work?
05:56:47 <twb> lispy: we aren't telling them that yet, and won't tell them that for months
05:57:19 <twb> lispy: but IMO it's no different from a Python package using setuptools or waf, or a Ruby package using rake, or a Perl package using Make.pl
05:57:50 <twb> lispy: it's one extra dependency that makes ongoing maintenance, particularly stupid and hairy portability gotchas, largely go away.
05:58:01 <matthew-_> Saizan: how do you do that?
05:58:44 <lispy> twb: until debian stable ships with a version of cabal that does what we need, I wouldn't want to drop autotools/make.  It just seems like we're being too hard on users.
05:58:49 <Saizan> matthew-_: cabal register --inplace
05:59:02 <lispy> twb: granted...if you could generate a correct makefile from the .cabal...maybe that's what works
05:59:16 <matthew-_> err, this is ghc 6.8.2
05:59:20 <twb> Generating makefiles just makes things worse.
05:59:27 <twb> That's what cmake does, it's a bloody nightmare.
05:59:51 <Saizan> matthew-_: runghc Setup.hs register --inplace is the same
06:00:28 <twb> What waf does is pretty clever -- it includes what amounts to a share script that unpacks a dirful of library into ./.dist-waf-$version and then uses that to do the work -- so end users don't have to install waf separately.
06:00:28 <matthew-_> Saizan: do you do that before or after install?
06:00:50 <matthew-_> ahh, without install
06:00:51 <matthew-_> I see
06:00:52 <Saizan> matthew-_: instead of install
06:01:04 <twb> Essentially it's a single 200kB or so file that lives in ./ of your repo that you mostly don't worry about.
06:02:39 <matthew-_> Saizan: it still writes into my user config
06:03:36 <Fallen_Demon> Hi guys
06:04:01 <Fallen_Demon> I feel another stupid question from me comng up
06:04:18 <Botje> let it out :)
06:04:31 <matthew-_> and I can't get ghc-pkg -f to look at any of the likely files inside dist
06:05:25 <stianhj> Hi guys, I'm considering doing my bachelor thesis (computer science) on/in haskell after a suggestion from a professor. So I was wondering what the opensource community was like here.. Are there any opensource projects I could contribute or does anyone have any ideas on where to start, anyone I could talk to etc..
06:05:44 <Botje> stianhj: hackage.haskell.org is full of projects to hack on :)
06:06:38 <stianhj> ok, i'll def have a look there..
06:06:55 <matthew-_> hmm. I'm utterly unconvinced --inplace is working
06:07:01 <stianhj> any other suggestions or comments?
06:08:02 <Botje> check haskell.reddit.com for interesting announcements, maybe
06:08:12 <Botje> there was a web framework there yesterday
06:08:31 <Botje> or just hang in here and wait for people to complain about / announce projects :)
06:08:47 <stianhj> i'm sick of web frameworks.. but maybe that's javas fault.. :P
06:09:00 <Saizan> you could look at the SoC trac
06:09:12 <stianhj> yeah, it's not until next year anyways.
06:09:42 <Saizan> http://hackage.haskell.org/trac/summer-of-code/report/1
06:09:43 <stianhj> but considering there won't be any haskell projects to choose from, i'll have to make my own..
06:09:51 <lambdabot> Title: {1} Active Tickets - Haskell.org Google Summer of Code - Trac
06:10:15 <Saizan> plenty of haskell projects there ^^^^
06:10:36 <stianhj> absolutely, thanks..
06:11:05 <hackage> Uploaded to hackage: TTTAS 0.2
06:11:05 <hackage> Uploaded to hackage: TTTAS 0.1
06:11:07 <stianhj> any book recommendations? i'm new to haskell, but not new to functiontal programming
06:11:22 <quicksilver> stianhj: real world haskell
06:11:34 <twb> I second that
06:11:41 <quicksilver> it's not quite published in dead tree form yet, I don't think
06:11:41 <twb> It's the PCL of Haskell
06:11:44 <quicksilver> but it's available online
06:11:46 <stianhj> that's the free online one?
06:11:51 <quicksilver> (and I have a pre-order with amazon)
06:11:53 <matthew-_> WOOT!
06:12:04 <twb> free-of-charge.
06:12:33 <twb> It has a CC-By-NC license.
06:12:35 <luite_> stianhj: yes, but I don't think the content is the same as the final edited book. it will be updated though
06:12:46 <twb> luite_: that's correct.
06:13:10 <stianhj> luite_; ok
06:13:46 <jsn> it won't be shipped until late december, it seems
06:14:12 <stianhj> anyways, thanks for the suggestions guys, you'll probably be seeing more of me in the future..
06:14:39 <byorgey> stianhj: excellent, drop by anytime =)
06:33:25 <luqui> are there any options for "hooking" the GHC garbage collector?
06:33:50 <luqui> for example, could I write an FFI data structure which had a custom GC mark function or something...
06:34:30 <quicksilver> luqui: custom finalizers but that's it, afaik.
06:34:46 <quicksilver> luqui: JaffaCake would be the man to talk to if you have something more sophisticated in mind.
06:35:10 <luqui> quicksilver, thanks.  I'm not sure I do, I'm just looking for options right now.
06:35:35 <quicksilver> I would like GHC to expose a bit more of its RTS to determined hackers
06:35:45 <quicksilver> a little bit of GC configuration could go a long way.
06:36:13 <luqui> aye :-)
06:36:37 <BeelsebobWork> it would get us up the shootout for a start ;)
06:36:41 <quicksilver> grin
06:36:51 <quicksilver> tweaking GC parameters is against the rules of the shootout.
06:36:57 <quicksilver> Oh, unless you're ATS. Then it's allowed.
06:37:02 <luqui> lol
06:37:32 <BeelsebobWork> quicksilver: wait, what?
06:37:41 <BeelsebobWork> ATS is allowed to do it?
06:37:42 <BeelsebobWork> why?
06:37:47 * quicksilver shrugs
06:37:58 <quicksilver> rules applied inconsistently, or they didn't notice, or the rules changed.
06:38:00 <quicksilver> I'm not sure.
06:38:03 <BeelsebobWork> heh
06:39:49 <quicksilver> the shootout is only a game after all ;)
06:39:59 <BeelsebobWork> true
06:40:06 <BeelsebobWork> but it would be nice for the game to be fair
06:40:19 <BeelsebobWork> it makes it less fun if the game is "stop haskell winning at all costs"
06:40:37 <quicksilver> some would argue that makes it more fun.
06:40:43 <quicksilver> adversity drives innovation
06:40:49 <quicksilver> parasites drive evolution, etc.
06:41:02 <BeelsebobWork> true
06:46:33 <jsn> haskell is doing fairly well for a scripting language :P
06:46:43 <BeelsebobWork> huh?
06:46:48 <jsn> is anyone in here familiar with the cabal sources?
06:47:00 <BeelsebobWork> it's doing pretty well for a compiled language
06:47:16 <jsn> i'm trying to find the part where things like 'flag()' and such are parsed
06:47:26 <luqui> it and clean are both doing well and poorly for lazy languages...
06:48:26 <dcoutts> jsn: Distribution/PackageDescription/Parse.hs
06:48:44 <jsn> yeah, i am looking at ti
06:48:49 <jsn> s/ti/it/
06:48:55 <jsn> i see the fields and all that
06:49:15 <jsn> parseFields, &c.
06:51:48 <madara> I'm learning haskell; I have experience with other languages, but I'm going through this with a couple of people that don't; does the LYAH book cover algorithm design/data structures? Or is it merely syntactical development in regard to haskell?
06:52:14 <Twey> madara: LYAH is new and fairly incomplete
06:52:14 <luqui> LYAH?
06:52:24 <Twey> It's a nice introduction, but shouldn't be considered a complete course
06:52:28 <Twey> luqui: Learn You A Haskell
06:52:51 <jsn> it sounds like something why would put together
06:52:57 <luqui> madara, have you looked at real world haskell?
06:52:57 <apsod> I prefer Real World Haskell over LYAH (though LYAH is pretty cute)
06:53:05 <madara> Twey: So, we'd be better off reading something else
06:53:22 <luqui> that has become the sortof flagship book on haskell...
06:53:25 <Twey> RWH is probably for you, aye
06:53:25 <Botje> there's also YAHT
06:53:34 <luqui> ew yaht.
06:53:36 <madara> luqui: not really, no. i do have 'haskell-the.craft.of.functional.programming' though.
06:54:01 <madara> are there pdf versions or .txt versions or rwh
06:54:09 <apsod> yes
06:54:23 <luqui> although I might just hate yaht because I associate it with my head hurting when I was learning...
06:54:31 <luqui> but it is unavoidable :-)
06:55:00 <apsod> Err, actually, I'm not sure there's a PDF version of RWH. All I see on their site is the HTML version.
06:55:32 <lispy> How do you say this? Cayenne
06:55:40 <lispy> kay-knee ?
06:55:51 <lispy> kay-en e?
06:55:59 <apsod> kai-yin ?
06:56:17 <jsn> dcoutts: processIfs ?
06:56:30 <jsn> ah, yeah, there it is
06:56:36 <luqui> kai anne
06:56:44 <lispy> it keeps coming up when I search for stuff as an example of a dependently typed language,b ut I haven't figured out how to say it :)
06:56:46 <jsn> nobody knows
06:56:52 <lispy> luqui: like the spice?
06:56:57 <luqui> yeah presumably
06:57:05 <lispy> as a pun on curry?
06:57:17 <Twey> luqui: Kay-en
06:57:23 <Twey> Er, lispy
06:57:27 <luqui> what kind of a is that, Twey?
06:57:38 <Twey> 'Kay' to rhyme with 'say'
06:57:42 <luqui> ok
06:57:53 <luqui> so like "KN" :-)
06:57:55 <Twey> /keɪ.ˈen/
06:57:58 <jpcooper> I always pronounced the a in Cayenna as the y in by
06:57:59 <Twey> Right
06:58:27 <jpcooper> Cayenne*
06:59:27 <JohnMeacham> I was bored for a few hours so wrote an interactive proof assistant in 300 lines of haskell. http://repetae.net/Hilbert.hs
06:59:57 <JohnMeacham> compile with ghc --make, set 'hasUnicode = False' if your terminal doesn't support unicode. good times.
06:59:58 <BeelsebobWork> like the spice is not a good way to describe it
06:59:59 <luqui> JohnMeacham, sweet!  what logic?
07:00:07 <dan_> hey channel
07:00:13 <JohnMeacham> basic hilbert style deduction system.
07:00:15 <BeelsebobWork> because I've heard it said so many different ways
07:00:25 <JohnMeacham> so, first order logic, with just modus pones as the rule of inference.
07:01:22 <dmead> i have a logic question
07:01:32 <luqui> JohnMeacham, don't you need axiom schema for completeness of that system?
07:01:32 <dmead> are there any primers on how we prove things in logic using group theory?
07:01:54 <dmead> i've been working on a resolution prover for a while and i'm wondering if there are better ways
07:02:31 <luqui> JohnMeacham, ah, seems you have a schema :-)
07:04:17 <luqui> hmm.  I remember there being more and more complex axioms when I studied this.  Though I never got a good intuition for why the axioms were chosen the way they were...
07:05:32 <JohnMeacham> yeah. just a few. feel free to add more. I just used the ones from wikipedia.
07:05:47 <JohnMeacham> http://en.wikipedia.org/wiki/Hilbert_type_axiomatic_system
07:06:31 <JohnMeacham> I actually needed to manipulate some first order logic terms for another project and decided a nice little interface would be fun to play with.
07:09:18 <JohnMeacham> I was playing with ideas for a 'goedel machine' I figure I could use jhc to jumpstart it so I can actually use haskell as the implmentation language.
07:09:36 <JohnMeacham> http://www.idsia.ch/~juergen/goedelmachine.html
07:09:38 <luqui> what do you mean goedel machine
07:09:39 <luqui> oh
07:09:39 <lambdabot> Title: GOEDEL MACHINE HOME PAGE
07:11:05 <hackage> Uploaded to hackage: hxt-filter 8.2.0
07:11:05 <hackage> Uploaded to hackage: hxt 8.2.0
07:11:31 <luqui> JohnMeacham, wow.  this is neat :-)
07:12:34 <luqui> sonofabitch!  Where is GHC.ST?
07:14:35 <Badger> is fungen dead?
07:14:45 <apsod> Grr, why isn't there a FreeBSD port for Cabal yet...
07:14:54 <Badger> apsod: er what
07:14:56 <jpcooper> apsod, because you didn't make one
07:15:07 <Badger> oh
07:15:11 <C-Keen> apsod: because there isn't a ghc port for freebsd (7) yet?
07:15:18 <apsod> C-Keen: Yes there is.
07:15:20 <Badger> er what
07:15:22 <Badger> C-Keen: thwere s
07:15:23 <Badger> is
07:15:25 <Badger> even.
07:15:25 <apsod> lang/ghc
07:15:27 <C-Keen> apsod: not in current stable
07:15:42 <C-Keen> apsod: that is marked as broken
07:16:04 <apsod> huh, strange
07:16:16 <apsod> How old is your ports tree?
07:16:22 <C-Keen> apsod: it is fixed in cvs, maybe in 7.1 it will be available
07:16:33 <apsod> C-Keen: I mean, I have it installed and working right now.
07:17:03 <Badger> as do I.
07:17:07 <C-Keen> apsod: are you supposed to update the ports tree within releases?
07:17:17 * C-Keen is a FreeBSD newbie
07:17:26 <apsod> Of course, how else do you keep your applications up-to-date?
07:18:01 <apsod> The base system is completely separate from the user-installed applications (/usr/local), so there's no reason you're locked in to a specific version of ports :)
07:18:03 <C-Keen> well with other port systems there is a stable and a current tree
07:18:07 <Badger> it's like syncing your package manager
07:18:11 <Badger> :P
07:18:44 <Badger> but yeah; fungen certainly looks dead, but is it just hiding out of sight?
07:18:50 <apsod> I've always been under the impression that the different ports trees are maintained because there's a couple kernel modules in ports, but I'm not quite sure.
07:18:54 <C-Keen> so I assumed wrongly that you should not mix those
07:19:09 <apsod> Yeah, stick on the stable ports tree if you're running stable.
07:19:18 <apsod> (but still keep it up-to-date!)
07:19:38 <C-Keen> apsod: so in the stable freebsd7 ports tree there is a working ghc port?
07:19:42 <apsod> Yep.
07:19:54 <C-Keen> thanks!
07:20:05 <apsod> no problem :3
07:20:33 <apsod> I guess I should write a cabal port or something tonight; I can't believe it hasn't been ported yet.
07:27:12 <mortenlysgaard> Hi, I'm in the starting phase of learning haskell and are meeting something i don't understan: How do i make a good self updating random number generator?
07:28:29 <lispy> mortenlysgaard: people use a state monad for that.  There is a library for doing it called MonadRandom
07:28:52 <lispy> mortenlysgaard: so, you probably want to learn about the State monad
07:29:11 <mortenlysgaard> Yeah, i think so.. What is it?
07:29:28 <mortenlysgaard> Or more general, what is a monad?
07:29:53 <quicksilver> it's just g -> (a,g)
07:29:55 <C-Keen> mortenlysgaard: a way to handle side effects in haskell
07:30:06 <quicksilver> I.e. generator gives value + new generator
07:30:13 <quicksilver> the 'monad' is just a way of hiding the gs.
07:30:45 <quicksilver> BeelsebobWork: no conal today?
07:30:52 <mortenlysgaard> Ah! Thats what i've been looking for. I really love haskell, but this problem was irrirtating me
07:31:08 <BeelsebobWork> quicksilver: not yet, it is only 8:30 am for him though
07:31:12 <BeelsebobWork> 7:30 even
07:31:19 <quicksilver> oh he's back in the us?
07:31:21 <quicksilver> that explains it :)
07:32:03 <mortenlysgaard> But how do i make use of the state monad. Is there any examples out there?
07:32:55 <luite_> the documentation for the state monad does have a small and a big sample, but I din't find them very helpful
07:33:10 <apsod> http://www.haskell.org/all_about_monads/html/statemonad.html
07:33:11 <lambdabot> Title: The State monad
07:33:30 <apsod> ^ The last example shows exactly what you're trying to do -- defining a function which returns a random value and updates the generator state
07:33:39 <quicksilver> I was just about to paste that very link.
07:33:55 <quicksilver> apsod++ # faster than me
07:34:04 <luite_> ah that's better than the samples on the haddock page
07:34:27 <mortenlysgaard> Wow, thanks! =) I'll look into it
07:34:35 <apsod> :3
07:35:00 <mortenlysgaard> Haskell's really opened o new dimension of elegant programming for me :D
07:35:44 <luite_> mortenlysgaard: you may want to read some introduction about monads and the do syntax in general. a do block isn't just a magic 'imperative' thing in haskell, but actually a way to chain to chain function calls together through the monad
07:36:46 <mortenlysgaard> Yeah, i've not understood what the do block does yet either
07:36:54 <C-Keen> you'll be writing monad tutorials in no time!
07:37:38 <luite_> mortenlysgaard: rwh gives some good examples of real-world situations where you run into something 'monadic' and first solves it with their own notation, then switches to the standard do block. I found that helpful
07:38:28 <mortenlysgaard> luite_;  who/what is rwh?
07:38:34 <quicksilver> mortenlysgaard: in this specific example, "do a;b;c" gives "a" the random number generator (behind the scenes), takes the modified result, gives it to "b", and so on.
07:38:38 <luite_> hm, what is the command to get the link? :)
07:38:44 <quicksilver> @go real world haskell
07:38:47 <lambdabot> http://www.realworldhaskell.org/
07:38:47 <lambdabot> Title: Real World Haskell
07:38:53 <luite_> ah thanks quicksilver
07:40:03 <mortenlysgaard> thanks
07:49:53 <mortenlysgaard> When i try the examples i get not in scope: State.. etc. That mean i have to import something to make it work right?
07:50:13 <jsn> mortenlysgaard: yes
07:50:49 <jsn> mortenlysgaard: Control.Monad.State
07:52:26 <mortenlysgaard> jsn; Thanks! =)
07:52:39 <luite_> mortenlysgaard: you can use hoogle to find where a function or type comes from: http://www.haskell.org/hoogle/  (you can also build your own local hoogle index)
07:52:40 <lambdabot> Title: Hoogle
07:54:04 <luite_> mortenlysgaard: it's also really useful if you forget what a function was called, but still know the types :)
07:54:07 <mortenlysgaard> Nice!
07:56:07 <dino-> Hello my Haskell friends.
07:57:47 <dino-> @paste
07:57:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:00:41 <dino-> bah, hpaste doesn't announce here any longer?
08:00:55 <dino-> http://hpaste.org/12217
08:00:58 <Saizan> the bot is dead
08:01:02 <dino-> ok
08:01:17 <dino-> So, what I think is happening here is I'm trying to design like an OO monkey
08:01:41 <Saizan> yeah
08:01:44 <dino-> I hope this small example actually illustrates it well enough
08:01:51 <Saizan> you're thinking in terms of subtyping
08:01:53 <Twey> Heh
08:01:54 <dino-> ya
08:02:22 <dino-> So, how to achieve this? I'm having a difficult time even describing what "this" is.
08:02:25 <dino-> :/
08:02:32 <dino-> I mean, I don't want to necessarily subtype.
08:02:57 <Saizan> you can use existential types if you just care that the returned type is an instance of some class
08:03:00 <dino-> I want to be able to have the code change which "handler" will be used at runtime based on other data (that boolean)
08:03:08 <sw17ch> getFooInst (Foo a) => Boolean -> b -> a
08:03:11 <dino-> I don't necessarily have to design it that way
08:03:15 <sw17ch> :t True
08:03:16 <lambdabot> Bool
08:03:21 <sw17ch> whoops
08:03:23 <sw17ch> getFooInst (Foo a) => Bool -> b -> a
08:03:25 <dino-> I don't really want to simulate OO at all
08:03:30 <sw17ch> getFooInst :: (Foo a) => Bool -> b -> a
08:03:43 <Saizan> dino-: do you need different types for different handlers?
08:04:11 <dino-> Saizan: Only because I latched on to the typeclass system as a way to have different function implementations, so they could do different things.
08:04:25 <dino-> So, not necessarily.
08:04:33 <Saizan> dino-: your Handler datatype could be a record of functions
08:04:43 <dino-> With a nervous feeling that I was hitting this with the Object hammer.
08:06:21 <Saizan> like data Foo = Foo { foo :: Int } in this case
08:06:49 <Saizan> or data Handler = H { handle :: Something -> IO ()}
08:07:17 <dino-> hm, data holds the handler function
08:08:03 <Saizan> so instead of instance declarations you just have Handler values, or functions that return them
08:09:11 <dino-> And somewhere else have these constructed. [(H handleBar), (H handleBaz)]
08:09:12 <dino-> Or whatever
08:09:22 <dino-> with a way to disambiguate them
08:09:23 <Saizan> right
08:09:25 <dino-> tuples, whatever
08:10:41 <dino-> Ok, I'll see about applying this to the real code. Which is much bigger with more going on in these instanced things.
08:11:03 <dino-> Saizan, everyone: Thank you, this helps
08:11:04 <Saizan> of you already have the classes etc..
08:11:16 <Saizan> you could use existential types, which are quite similar
08:11:27 <dino-> Well, class is only for this, I cooked it up just now.
08:11:39 <dino-> ok
08:11:55 <Saizan> data AnyFoo = forall a. Foo a => AnyFoo a
08:12:02 <Saizan> ah ok
08:12:26 <dino-> But I get where you're going. Existential is how you pretty much really really simulate OO's interface behavior.
08:12:34 <Saizan> yeah
08:12:53 <dino-> Work with a collection of things that only share their typeclass instancing and little else.
08:13:18 <Saizan> nothing else :)
08:14:10 <Saizan> (altough you can also downcast with Typeable)
08:14:31 <dino-> Maybe it's me, but it seems cheap in some way to fall back on hacking OO into this. Like a "you're doing it wrong". Maybe it's perfectly valid, though.
08:15:52 <dino-> I have an unreasonable, bad attitude about objects lately.
08:15:57 <Saizan> i guess it depends on the actual class and how you create these existentials/records
08:16:24 <dino-> And don't want to miss the point of using FP by making it do ugly things.
08:16:34 <jsn> there are some situations where, really, you do just want a bunch of things to all look the same
08:16:44 <dino-> ya
08:16:59 <jsn> but most of the time, i really don't :)
08:17:26 <jsn> i don't want to find myself feeding a string to a function that takes a hash with three keys
08:17:32 <dino-> Unsure where that line is between being practical and using techniques from other languages, or just plain designing badly in Haskell.
08:18:20 <dino-> Right, there does seem to be some danger of cicumventing the type system, I guess.
08:18:57 <quicksilver> have you considered just lists of functions?
08:19:02 <quicksilver> or lists of IO actions?
08:21:04 <dino-> quicksilver: The real problem may be more complex than that. Like the different things have more than one function.
08:21:11 <dino-> s/may be/is/
08:21:55 <dino-> But could be lists of tuples of functions, or list of Saizan's data type above with record fields for each one.
08:22:24 <dino-> Something like that seems to be the concensus here re: avoiding existentials for this.
08:23:11 <dino-> Saizan: I did see that "downcast with Typeable" :o
08:23:20 <dino-> Not familiar with Typeable yet
08:23:37 <dino-> sounds all meta meta
08:23:43 <quicksilver> dino-: only from the point of view of Occam
08:23:50 <quicksilver> avoid existentials, unless they are the right solution
08:23:52 <quicksilver> IYSWIM.
08:23:57 <quicksilver> keep it as simple as you can, always.
08:24:09 <quicksilver> higher order functiosn and actions as first class values is already a powerful feature.
08:24:38 <quicksilver> And, if in doubt, do not use a typeclass.
08:24:43 <agcorona> why to avoid existentials?
08:24:53 <dino-> quicksilver: yes, definitely why I came around to ask. It seemed perhaps overcomplicated already.
08:24:57 <Saizan> with data Foo = forall a. Typeable a => Foo a, you can downcast :: Typeable b => Foo -> Maybe b; downcast (Foo a) = cast a; but i find it ugly :)
08:25:06 <dino-> agcorona: Maybe the advice is more like: try to be careful with them
08:25:13 <dino-> Not throw them all over like mad.
08:25:37 <mux_> Saizan: I find the new Control.Exception module to be a nice example of good usage of this
08:25:43 <dino-> Saizan: huh
08:26:01 <quicksilver> agcorona: as I say, just in the interesting of solving the problem in the simplest way you can.
08:26:04 <Saizan> mux_: yeah, that's well placed
08:26:21 <agcorona> quicksilver: yes that is the rule for me
08:26:24 <quicksilver> And according to some subjective criterion I believe existentials to be less 'simple' than first order functions.
08:26:30 <dino-> Also that word reminds me of working in C++ a million years ago. We had a macro that would cast to void* and then to another class. Called TYPESAFE_DOWNCAST
08:26:35 <dino-> An evil beast.
08:26:35 <quicksilver> first class functions, I mean.
08:27:28 <Saizan> there's a stronger argument for using an existential if you already have a typeclass for other reasons
08:28:42 <dino-> Saizan: I can see that.
08:33:40 <agcorona> type A= forall a. classtype a => A a    instance classtype A a where method (A a)= method a           is a good way to handle arbitrary data with a comon interface
08:35:00 <agcorona> class instead of type, sorry
08:37:37 <Angie^> can someone explain type classes to me?
08:37:37 <Angie^> and decls?
08:37:43 <Angie^> kinda confused
08:37:52 <Angie^> i fired up ghci and cant make my own function declarations
08:38:03 <Angie^> i dunno if its worth doing so because hs infers already
08:38:08 <Angie^> but i want to learn
08:38:08 <Angie^> lol
08:38:11 <luqui> Angie^, you need to say "let" in ghci
08:38:16 <luqui> i.e. let foo x = x + 1
08:38:24 <Botje> you're best off putting declarations in a file and loading that
08:38:37 <Angie^> so is it like: let test :: (Num a) => a -> a; test(x) = x * x ?
08:38:49 <luqui> yep :-)
08:39:05 <ttomm> http://learnyouahaskell.com/types-and-typeclasses
08:39:12 <lambdabot> Title: Learn You a Haskell for Great Good! - Types and Typeclasses
08:39:32 <luqui> which gets annoying as things get longer.  my typical workflow, as Botje says, is to put stuff in a file and then loading it up and typing :r every time I change it
08:39:46 <luqui> that is also kind of annoying though, because I lose my local definitions from the ghci session
08:39:54 <PeakerWork> ghci could be much nicer if it accepted anything that a file does
08:40:14 <PeakerWork> deferring compilation until the symbols are all there, if necessary
08:40:48 <luqui> heheh:
08:40:50 <Angie^> is this right: let test2 :: (Char a) => a -> a; test2(x) = x * x
08:40:53 <luqui> foo :: Int -> Int
08:40:57 <luqui> foo 42
08:40:59 <Angie^> like if i want test2(A)
08:41:02 <luqui> <hang>
08:41:05 <Angie^> AA pops up
08:41:11 <Angie^> or sum.
08:41:11 <Angie^> lol
08:41:20 <luqui> (later, foo x = x+1), and then it unhangs with the response 43
08:41:33 <luqui> I guess you would need two prompts in the same session for that :-)
08:41:54 <luqui> Angie^, Char is not a typeclass, it's just a type
08:42:04 <luqui> so (Char a) => ...   doesn't make sense
08:42:08 <Angie^> o
08:42:20 <Angie^> and num is a typeclass and so is int, float, double too?
08:42:34 <Saizan> Num is a typeclass
08:42:35 <luqui> Angie^, nope, just Num.  Int, Float, and Double are members of Num
08:42:37 <Angie^> so how would i do this with characters???
08:42:56 <Saizan> you can't multiply characters directly
08:43:08 <luqui> Angie^, you are trying to... oh.  I see. concatenate the characters into a string?
08:43:11 <Saizan> since Char is not an instance of Num
08:43:16 <Angie^> oo
08:43:29 <Angie^> i just wanted like "ABC"
08:43:36 <Angie^> then "ABCABC"
08:43:41 <Angie^> luqui: ya
08:43:58 <luqui> okay. well that function works on strings, not characters, so it would have type String -> String
08:44:35 <luqui> the string concatenation operator is called ++
08:44:53 <Angie^> so like: let test2 :: String c => String a -> String b ?
08:45:07 <Angie^> uhh
08:45:22 <Angie^> so like: let test2 :: String c => String a -> String b; test2(String x) = x ++ x ?
08:45:31 <luqui> why so complicated!? :-)
08:45:35 <luqui> test2 :: String -> String
08:45:36 <luqui> :-)
08:45:46 <luqui> it's a function which takes a string and returns a string.
08:45:46 <Angie^> lol im dumb sorry
08:45:46 <quicksilver> grrr.
08:46:04 <quicksilver> Saizan: before my machine crashed, I wanted to say, not all existentials need be type classes.
08:46:06 <Twey> test2 a b = a ++ b
08:46:09 <Twey> test2 = (++)
08:46:17 <quicksilver> and IMO this confusion leads to misuse of typeclasses :)
08:46:56 <Philonous> > (join (++)) "abc"
08:46:58 <lambdabot>   "abcabc"
08:47:19 <Twey> Oh, the same string.  Sorry, yes.
08:47:29 <Twey> test2 a = a ++ a
08:47:31 <luqui> you guys are such pointfree lunatics.
08:47:32 <Twey> test2 = join (++)
08:47:40 <Giraffe> luqui, i like pointfree D:
08:47:56 <luqui> Giraffe, that's fine.  I like lunatics.
08:48:00 <Giraffe> bahahaha
08:48:00 <Twey> Everyone likes pointfree
08:48:02 <Giraffe> excellent
08:48:16 <Twey> :-D
08:48:17 <Angie^> well different strings: let test2 :: String -> String -> String; test2 a b = a (++) b ?
08:48:21 <Saizan> quicksilver: i've thought of that case, but you usually can just preapply the functions at that point
08:48:32 <Angie^> umm
08:48:38 <Angie^> hm
08:48:53 <Philonous> Angie^: Almost, when used as infix operator, you need to leave out the brackets
08:48:55 <luqui> Angie^, parentheses around an operator turns an infix operator into a normal function.  i.e. if you aren't using it infix, don't include the parentheses
08:49:03 <Philonous> So test2 a b = a ++ b
08:49:07 <luqui> er, if you *are* using it infix, don't include the parentheses
08:49:20 <dino-> quicksilver: Oh really! My only real knowledge of existentials is from alpheccar http://www.alpheccar.org/en/posts/show/67
08:49:23 <lambdabot> Title: Haskell Study Plan
08:49:29 <dino-> Where his example uses a typeclass
08:49:47 <Angie^> let test2 :: String => String -> String; test2 a b = a ++ b ?
08:50:01 <luqui> existentials are only useless when you only mention the existential variable once (and it's not a typeclass)
08:50:01 <Philonous> Or test2 a b = ((++) a b) -- lisp style with lots of superflous paranthesis
08:50:13 <Angie^> > let test2 :: String => String -> String; test2 a b = a ++ b ?
08:50:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:50:22 <luqui> Angie^, what do you intend that "String =>" part to mean?
08:50:26 <Angie^> > let test2 :: String => String -> String; test2 a b = a ++ b
08:50:27 <lambdabot>   <no location info>: parse error on input `;'
08:50:38 <quicksilver> dino-: it is unfortunate that he chose to write his description of existentials that way.
08:50:45 <Angie^> luqui: the returning string
08:50:57 <Angie^> like x = a ++ b
08:50:59 <luqui> Angie^, ah, that's the "-> String" part
08:51:04 <Angie^> i thought you needed to return back to calling computer
08:51:08 <quicksilver> dino-: consider data H = forall a . H a (a -> String) (a -> a -> Int)
08:51:09 <Angie^> o
08:51:16 <Angie^> k
08:51:16 <Angie^> hmm
08:51:17 <quicksilver> dino-: no type-class there, but it's still useful.
08:51:24 <luqui> i.e. "String -> String" is already the type of functions that take strings and return strings
08:51:29 <Angie^> done it!!!!!!
08:52:02 <Angie^> Prelude> test2 "Thanks " "Luqui"
08:52:09 <Angie^> "Thanks Luqui"
08:52:21 <Angie^> i just dont get it all lol
08:52:26 <Angie^> so what's String => for?
08:52:42 <luqui> uh I have no idea.  it means "give me a parse error, dear compiler"
08:53:03 <Angie^> huh
08:53:03 <Angie^> lol
08:53:03 <Angie^> k
08:53:04 <luqui> but the => notation in general is typeclass notation.
08:53:14 <luqui> roughly, if you say,  Num a => a -> a,  you are saying
08:53:24 <luqui> "this function has type a -> a, as long as a is a Numeric type"
08:53:27 <Angie^> kk
08:53:48 <Angie^> mm
08:54:08 <Angie^> well im still a bit cionfused. but ill keep reading
08:54:11 <luqui> you see that also with, say, sort :: (Ord a) => [a] -> [a].
08:54:14 <Angie^> just kinda lost lol
08:54:21 <luqui> which can sort lists of anything, as long as it can compare the things
08:54:49 <Angie^> im so confused lol
08:55:00 <Angie^> brb in a sec
08:55:00 <Angie^> thanks tho
08:55:00 <Angie^> brb
08:55:00 <apsod> luqui: How do you specify multiple typeclasses? fun :: (Type1 a), (Type2 b) => a -> b, or :: (Type1 a) => (Type2 b) => a -> b ?
08:55:19 <dino-> quicksilver: So, that def of H above isn't doing the same thing as the typeclass one, but is illustrating being flexible with the type a for all of its functions? mm, I may not be making sense
08:55:27 <mux_> (Type1 a, Type2 b) => a -> b
08:55:33 <apsod> hurr, thanks :3
08:55:42 <quicksilver> dino-: it's a bit like having a type class for a, containing functions a -> String and a -> Int
08:55:47 <quicksilver> dino-: but it's simpler and more flexible.
08:56:00 <quicksilver> simpler because it doesn't require to you define a one-off typeclass you will never use
08:56:19 <quicksilver> more flexible because you can have different functions, not necessarily limited to one per type.
08:56:40 <dino-> Interesting, and it's the forall that really does this for us now.
08:56:58 <dino-> the 'not free' type variable
08:57:46 <quicksilver> well, yes, that's what existentials are ;)
08:57:59 <quicksilver> typeclasses are for ad-hoc overloading
08:58:13 <quicksilver> more generally, they're for the case you want to select a particular function by looking at the types of its arguments.
08:58:16 <quicksilver> that's all.
08:58:21 <quicksilver> they're not interfaces, and they're not OO classes.
08:58:51 <quicksilver> they're a hook that lets you ask the compiler's type inference engine to choose code for you.
08:59:37 <dino-> It's been difficult to keep mental OO baggage from typeclasses.
08:59:45 <quicksilver> yes.
08:59:53 <quicksilver> they should have called them ugly poisonous spiky things.
09:00:21 <quicksilver> Two problems with haskell : people are too scared of monads, because we gave them a scary name. They are not scared enough of typeclasses, because we gave them too friendly a name.
09:00:25 <Saizan> well, they carry a notion of interface, otherwise superclasses don't make a lot of sense
09:00:44 <quicksilver> Saizan: they are a notion of interface selected by a type.
09:00:54 <quicksilver> that's a peculiar way to select an interface, in general.
09:01:06 <quicksilver> (it works well in some cases, of course)
09:01:34 <quicksilver> the simplest haskell notion of interface is just a tuple of functions.
09:01:46 <quicksilver> a typeclass is just a way to bind a tuple of functions to a type.
09:01:58 <quicksilver> (and ask the type inference part of your compiler to select the right tuple, based on that)
09:02:50 <Saizan> nah, typeclasses are just a way to do logic programming in the type system ;)
09:03:30 <quicksilver> it's a pretty limited kind of logic programming in haskell98.
09:03:50 <quicksilver> but yes, that's what I mean by 'ask the type inference part of your compiler to choose code for you
09:04:25 <Saizan> yeah, i'm agreeing
09:05:51 <tristes_tigres> Hi
09:06:23 <tristes_tigres> Is it possible to define a datatype of non-empty list of [someting] ?
09:06:42 <tristes_tigres> so as empty lists are caught at compile time
09:06:49 <camior> newtype NonEmptyList a = (a,[a])
09:07:00 <camior> newtype NonEmptyList a = NEL (a,[a])
09:07:04 <tristes_tigres> camior: ok thanks, that was obvious
09:07:14 * tristes_tigres feels ashamed
09:07:15 <igel> hi
09:07:23 <luqui> hi igel
09:07:24 <PeakerWork> quicksilver: heh, I think monads/applicatives/etc are generalizations that are far more general than what most coders generalize usually, so it may scare them, not just because of the name
09:07:29 <luite_> I have some list of type Ord, and want to construct a set that is ordered in reverse order (such that Set.toAscList gives me the highest element first), how can I do this?
09:07:33 <igel> can someone give me a hint how to access defines from a c-header in a haskell file?
09:07:40 <PeakerWork> quicksilver: and type-classes are quite similar to the OO stuff people have been doing already
09:07:44 <igel> i'm writing bindings and some constants are defined as #define
09:07:57 <quicksilver> PeakerWork: yes. I was being slightly flippant. The name is a minor problem, although it is a problem.
09:08:04 <quicksilver> we should have called them 'Patterns'
09:08:05 <quicksilver> ;)
09:08:12 <luqui> igel, I believe you can using the c2hs tool
09:08:20 <quicksilver> PeakerWork: the point is, the type classes are NOT similar to the OO stuff they've been doing already.
09:08:24 <quicksilver> they just have a similar name
09:08:29 <luqui> igel, using that tool is typically how people write bindings
09:08:30 <quicksilver> (and 'methods' also have a similar name)
09:08:34 <Saizan> luite_: use a newtype Inverse a = Inv a, instance Ord a => Ord (Inv a) where compare (Inv x) (Inv y) = compare y x
09:08:56 <PeakerWork> quicksilver: why is it so different?
09:09:04 <igel> ok looks like i'll have to read a lot then... :D
09:09:05 <igel> thanks
09:09:10 <quicksilver> PeakerWork: I have just explained at some length, I think.
09:09:20 <quicksilver> typeclasses are more like C++ overloading than they are like C++ classes.
09:09:36 <PeakerWork> quicksilver: except when used on existentials?
09:09:37 <luite_> Saizan: ah, good idea, thanks
09:10:17 <PeakerWork> What do you think of the names: Functor -> Mappable,  Applicative -> Sequential,  Monad -> DynamicSequential ?
09:10:27 <quicksilver> PeakerWork: disaster.
09:10:33 <PeakerWork> heh, why?
09:10:37 <Deewiant> DynamicSequential sounds wrong
09:10:41 <quicksilver> the misconception that Monads are Sequential is even worse than the misconception that they are scary.
09:11:01 <PeakerWork> quicksilver: why? Monads force you to sequence the stuff, but they allow you to be dynamic in what you sequence
09:11:05 <PeakerWork> Deewiant: why?
09:11:20 <quicksilver> they only sequence the effects, not the actual operational semantics of the program
09:11:31 <quicksilver> and the confusion between the two is bad enough I'm scared of the name.
09:11:46 <quicksilver> people assume that sequencing effects implies sequencing evaluations.
09:12:08 <PeakerWork> quicksilver: What names would you choose?
09:12:09 <quicksilver> and this is an abstract sense of the word 'sequence', too.
09:12:16 <Deewiant> WarmFuzzyThing
09:12:43 <quicksilver> i.e. whilst every applicative does have a sense of sequence, the sense varies from applicative to applicative
09:12:49 <quicksilver> it is an abstraction of the notion of sequence
09:12:52 <camior> I like the names as they are. Their use of non-typical names implies to me that their actual meaning, to be fully grasped, takes more than a word. For example, a Monad is a short name for the operations and laws associated with it.
09:13:09 <PeakerWork> I think sequencing effects is what a computer program really wants to get done (computation is just a mediating goal in order to choose the effects to sequence)
09:13:20 <PeakerWork> At least an IO () program
09:13:29 <quicksilver> ah, well, now you've shown your true colours.
09:13:34 <quicksilver> IO is a poor example of a monad
09:13:38 * mux_ giggles
09:13:40 <quicksilver> because it is particularly unusual.
09:13:55 <quicksilver> we don't want to be guided by IO when choosing a name for the class as a whole.
09:14:02 <quicksilver> (it's a particularly interesting example, of course)
09:14:12 <quicksilver> but it is very different.
09:14:28 <PeakerWork> quicksilver: I see.  "Sequencing effects on lists" does not convey a lot of meaning
09:14:38 <quicksilver> its semantics are not specified "in" haskell, but come externally from the language (or RTS, if you want to be concrete)
09:14:44 <quicksilver> PeakerWork: exactly.
09:14:52 <quicksilver> > sequence [[1,2],[5,6]]
09:14:53 <lambdabot>   [[1,5],[1,6],[2,5],[2,6]]
09:15:00 <quicksilver> ^^ there is a sense in which that is a sequence, sure
09:15:04 <quicksilver> but it's a fairly strange sense.
09:15:09 <quicksilver> very different from IO :)
09:15:39 <PeakerWork> yeah. I think maybe the names of Functor,Applicative,Monad could carry more information about the relationships between them
09:16:10 <Deewiant> Functor could have a better name
09:16:10 <quicksilver> yes, that would be nice.
09:16:28 <mux_> yeah, the confusion with ML Functors is annoying
09:16:55 <quicksilver> if I was searching for a new name for Monad, I might cast around words related to 'effect' and perhaps 'data flow'
09:17:05 <quicksilver> but I don't have a good suggestion to offer.
09:18:58 <PeakerWork> Mappable, Applicable, Bindable ? :)
09:19:04 <PeakerWork> or Joinable
09:19:06 <JohnMeacham> but the agreement with category theory is refreshing.
09:19:39 <quicksilver> Bindable's not bad
09:19:43 <Saizan> -able feels so Java
09:19:56 <quicksilver> MapFactor ApplicationPattern and BindableBean ?
09:20:00 <quicksilver> MapFactory ApplicationPattern and BindableBean ?
09:20:02 <PeakerWork> Saizan: Not *everything* Java is horrible :)
09:20:06 <PeakerWork> horrable maybe :)
09:20:20 <mux_> Monad => SpecialEffect
09:20:27 <Deewiant> SpecialFX
09:20:31 <Saizan> FireWorks
09:20:35 <Deewiant> CGI
09:20:40 <mux_> heh
09:21:00 <Saizan> heh CGI for web programmers
09:21:26 <Deewiant> I was thinking of Computer-Generated Imagery :-P
09:21:27 <apsod> :(
09:22:00 <mlesniak> Hi, I'm currently searching for a phd topic in the area of parallel programming and functional languages, but my impression is that a *lot* of work has already been done for this in haskell. Can anyone comment on this?
09:22:31 <cjb> that's certainly correct :)
09:22:39 <mux_> well yeah there's been a lot of work in this area with NDP or DPH
09:22:45 <mux_> I'm sure there's room for more though
09:22:48 <cjb> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
09:22:49 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
09:22:59 <mlesniak> mux_, It's quite difficult to find a niche ;)
09:23:26 <cjb> mlesniak: I think there's a lot of work still to be done in automatic/guided parallelization
09:23:40 <cjb> and functional languages seem like a particularly good environment for that, since you know where the data dependencies are.
09:24:13 <mlesniak> cjb, yes, this is why I've chosen fp, but I'm not quite sure that diving deeper into haskell is the right choice ;)
09:24:36 <cjb> ah :)
09:24:44 <cjb> you might like this paper
09:24:48 <cjb> http://research.microsoft.com/~tharris/papers/2007-fdip.pdf
09:24:50 <lambdabot> Title: Feedback Directed Implicit Parallelism
09:25:10 <quicksilver> mlesniak: lots has been written about automatic parallelism
09:25:15 <quicksilver> but precious little has been *done*
09:25:24 <quicksilver> there's plenty of room for people to do actual work :)
09:25:35 <dons> mlesniak: its a huge area. haskell's hot at the moment, and its purity saves you a lot of busy work, so you can get into the fun stuff quickly.
09:26:11 <mlesniak> dons, hmm, the problem with being hot (from my point of view) is that a lot of people are possibly faster than you ;-)
09:26:23 <mlesniak> quicksilver, that sounds good
09:26:30 <dons> mlesniak: or you get to work with good people
09:27:00 <mlesniak> dons, I already have the job but the thesis topic is missing, which means the people are fixed ;)
09:27:30 <dons> well, find out what the hard problems are, and then which toolset would be best to solve it in.
09:27:42 <dons> haskell's good because purity means you avoid a lot of busy work establishing purity
09:28:06 <mlesniak> yes, this is why I started to take a look at haskell (and well, it looks so damn elegant!)
09:28:19 <dons> plus you'll get a lot of users, and can ask simon peyton jones for advice
09:28:44 <mlesniak> *g* a definite pro
09:29:07 <blueonyx> hi
09:29:13 <cjb> I'm not much of a Haskell programmer, but having seen DPH I'm far more likely to write multicore code in Haskell than C
09:30:50 <dino-> Thanks again you guys, Saizan, quicksilver. I will get back to hacking this after lunch. Much appreciated help.
09:30:53 <mlesniak> Thanks for all the nice answers. I'll take a look at the links you've provided.
09:31:39 <blueonyx> how can i specify an include path when importing a module?
09:31:49 <Deewiant> -ipath
09:32:03 <Deewiant> -I would be for #includes
09:32:27 <PeakerWork> what's putMsgS?
09:32:38 <blueonyx> Deewiant: for ghci too?
09:32:41 <PeakerWork> from GHCPlugins, possibly
09:32:43 <dino-> blueonyx: And in .cabal files, hs-source-dirs
09:32:50 <Deewiant> blueonyx: yeah, I'm quite sure.
09:32:54 <dino-> blueonyx: yes, that -i works for ghci
09:36:01 <cjs> How do I partially apply a function to all but the first argument?
09:36:20 <cjs> (For any f taking however many args?)
09:36:27 <Deewiant> ?pl \f x y z -> f y z
09:36:27 <lambdabot> const
09:36:55 <blueonyx> mh i get http://pastie.org/private/w46oalb0acnlcuggcyv1ha where testRemDup.hs is just 'import HUnit' :/
09:37:00 <lambdabot> Title: Private Paste - Pastie
09:37:27 <Deewiant> ?pl \f y z -> (\x -> f x y z)
09:37:27 <lambdabot> (flip .) . flip
09:37:35 <Deewiant> ?pl \f y z a b c -> (\x -> f x y z a b c)
09:37:36 <lambdabot> (((((((flip .) . flip) .) . flip) .) . flip) .) . flip
09:37:48 <Deewiant> cjs: no general way.
09:38:12 <cjs> Deewiant: That was not the answer I was looking for. :-/
09:38:13 <Deewiant> blueonyx: -ipath, not -i path
09:38:30 <blueonyx> oh
09:38:43 <blueonyx> wow thanks :)
09:39:40 <blueonyx> and are there standard path which are searched?
09:40:06 <Deewiant> I think they're package-specific, ghc-pkg knows
09:40:29 <blueonyx> thank you
09:42:21 <newsham> rot3 f x y z = f y z x
09:42:32 <quicksilver> blueonyx: if you're trying to get standard places searched then you should probalby learn about ghc packages
09:42:43 <quicksilver> blueonyx: there is a nice standard way of adding stuff to standard search paths.
09:42:50 <quicksilver> conal: hi!
09:43:28 <quicksilver> conal: are you unhappy with your joinE implementation?
09:45:34 <explicitjelly> http://www.frodoid.org/closedstuff/superfac.html
09:45:35 <lambdabot> Title: superfac.py
09:46:08 <newsham> nice.
09:46:54 <explicitjelly> newsham, but stupid... and I really wished python was lazy %)
09:47:18 <newsham> http://www.thenewsh.com/~newsham/x/machine/lazy.py
09:48:02 <MyCatVerbs> explicitjelly: that's what generators are for.
09:48:17 <explicitjelly> MyCatVerbs, yes but I didn't have one
09:48:26 <newsham> what do today what you can thunk till tomorow
09:48:36 <newsham> s/what/why/
09:48:56 <explicitjelly> MyCatVerbs, and it was okay. I assigned smaller terms and when everything worked I put the whole expression back together.
09:49:24 <newsham> explicitjelly: you might like this:  http://www.thenewsh.com/~newsham/x/obf.py
09:49:37 <conal> quicksilver: hi.  yes, i am.  it's more complicated than i like.
09:49:37 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
09:49:52 <explicitjelly> newsham, it looks interesting, but what is it doing?
09:50:00 <newsham> run it (its safe, i promise)
09:50:06 <quicksilver> conal: I thought I read a bug report about it misbehaving.
09:50:14 <quicksilver> conal: anyhow, mine seems to be substrantially different to yours.
09:50:26 <quicksilver> conal: I'm not even entirely sure mine is correct but I thought you might be interested to compare.
09:50:42 <newsham> explicitejelly: its based on http://www.thenewsh.com/~newsham/lambda/ but pared down to be small and obtuse
09:50:43 <lambdabot> Title: Directory /~newsham/lambda/
09:50:51 <newsham> (ie. see primes2.lam)
09:50:54 <conal> quicksilver: yes, i'm very interested.
09:51:07 <explicitjelly> newsham, oooh, nice
09:51:10 <quicksilver> conal: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=494#a494
09:51:26 <quicksilver> conal: line 275
09:51:26 <explicitjelly> newsham, I also have a lambda calculator in haskell in development
09:51:30 <explicitjelly> newsham, it gave me the idea.
09:51:40 <newsham> its a slippery slope
09:51:48 <explicitjelly> why? 8)
09:52:00 <newsham> and very fun once you start sliding
09:52:08 <explicitjelly> it is!
09:52:43 <conal> quicksilver: hm.  i'm not getting through to that page: "The connection to the server was reset while the page was loading."
09:53:03 <explicitjelly> it was also interesting for me to find something like a Y combinator for call-by-value evaluation (I only have something similar to the Y-combinator, but it's enough)
09:53:07 <quicksilver> that's odd. works for me.
09:53:15 <quicksilver> can someone else try to load my moonpatio link?
09:53:22 <Cale> I loaded it
09:53:29 <Deewiant> works here, too
09:53:35 <conal> quicksilver: trying a third time. ...
09:53:37 <newsham> quick: http://www.thenewsh.com/~newsham/x/machine/fix.py
09:53:44 <geezusfreeek> works for me as well
09:53:45 <Deewiant> maybe a firewall somewhere doesn't like port 8080?
09:53:53 <Cale> joinE :: Event (Event a) -> Event a
09:53:54 <Cale> joinE (Event ft) =
09:53:54 <Cale>   Event . joinF $
09:53:54 <Cale>   fmap (\(e `Stepper` ee) ->
09:53:54 <Cale>          let (Event ftft) = (e `mappend` joinE ee) in ftft)
09:53:57 <Cale>   ft
09:54:07 <geezusfreeek> heh, yeah that was much easier Cale
09:54:15 <conal> thx, guys.
09:54:26 <quicksilver> conal: emailed it to you anyway.
09:54:41 <quicksilver> you're probably rgiht about conal's firewall and port 8080
09:54:48 <explicitjelly> # 7 is about the highest number computing in a few seconds on a core 2 CPU
09:54:48 <explicitjelly> print natural(fac(church(7)))
09:54:50 <explicitjelly> sad isn't it.
09:55:20 <Cale> explicitjelly: not really...
09:55:27 <conal> quicksilver: it looks very simple.  have you thought about whether it lazily merges infinitely many infinite streams (in time order)?
09:56:06 <pumpkin_> what is church(x)?
09:56:47 <explicitjelly> Cale, well, 7 is not a particularly big number
09:56:52 <explicitjelly> I blame church numerals
09:56:57 <MyCatVerbs> pumpkin_: http://en.wikipedia.org/wiki/Church_encoding
09:56:58 <lambdabot> Title: Church encoding - Wikipedia, the free encyclopedia
09:56:59 <newsham> pumpkin: encode number a church numeral
09:57:00 <explicitjelly> and my Y-combinatory thingy
09:57:05 <Cale> explicitjelly: 5040 is reasonably large
09:57:13 <MyCatVerbs> pumpkin_: it's how you encode a number as a combinator.
09:57:13 <explicitjelly> pumpkin_, it converts a python number to a church numeral
09:57:14 <newsham> http://www.thenewsh.com/~newsham/x/numbers.py
09:57:20 <pumpkin_> oh :)
09:57:36 <Cale> (and 40320 is larger ;)
09:57:43 <MyCatVerbs> pumpkin_: so that you can do arithmetic in pure lambda calculus.
09:57:45 <explicitjelly> 8 is "still okay".
09:57:53 <explicitjelly> I didn't wait for 9, but I didn't wait particularly long.
09:57:56 <Cale> When you're working with numbers in unary representation, you can expect things to be slow.
09:58:10 <explicitjelly> yes.
09:58:28 <explicitjelly> I should use composite numbers.
09:58:36 <newsham> (numbers.py also has lists and tuples)
09:58:50 <explicitjelly> "We had to resort to using python's if-statement a few times to
09:58:51 <explicitjelly> implement a lazy conditional since any functionwe define is going
09:58:51 <explicitjelly> to be strict and can cause problems with recursion.
09:58:51 <explicitjelly> "
09:59:00 <explicitjelly> you do not *need* to
09:59:02 <explicitjelly> it's way easier
09:59:10 <newsham> you're right
09:59:25 <explicitjelly> q_ = lambda z: lambda f: lambda g: lambda n: (iszero_(n)(lambda m: f)(lambda m: g(z(z)(f)(g))(m))(n))
09:59:28 <explicitjelly> qq_ = q_(q_)
09:59:29 <explicitjelly> that's what I used
09:59:38 <apsod> lol.
09:59:45 <MyCatVerbs> Python's "and" and "or" are lazy anyway. So you *can* define everything purely in expressions... :)
10:00:06 <decafbad> explicitjelly: what does that code?
10:00:07 <explicitjelly> newsham "lambda x: f(x)" is THE trick for strict languages %)
10:00:32 <newsham> explicit: see lazy.py above
10:00:58 <explicitjelly> decafbad, it's just a stupid combinator for some primitive recursion
10:01:12 <explicitjelly> newsham, ah
10:01:53 <explicitjelly> MyCatVerbs, I did not want to use anything except single-argument lambdas and single-argument function calls
10:02:02 <explicitjelly> so, not and/or...
10:02:50 <explicitjelly> decafbad, it's similar to the Y-combinator for strict languages, but with more stupid in it.
10:04:24 <decafbad> explicitjelly: I'm just a unix admin, who sometimes writes really long shell scripts and a few pages C.
10:04:42 <explicitjelly> decafbad, I'm a unix admin, too!
10:05:31 <dons> ?users
10:05:31 <lambdabot> Maximum users seen in #haskell: 550, currently: 530 (96.4%), active: 20 (3.8%)
10:05:38 <explicitjelly> but I made the big mistake of starting to study computer science some semesters ago. now look what I have become. I write useless functions with strange constructs.
10:06:52 <Cale> conal, quicksilver: It seems to me that the most sensible way to join Events would be to switch from one Event to the next... that is, the last thing to have occurred at time t in join x should be the last thing to have occurred at time t in the Event which is the last thing to have occurred at time t in x.
10:07:21 <explicitjelly> now I could do the same with just using the S and K combinators.
10:07:21 <Cale> (I'm not completely certain if that's what this code does or not)
10:07:21 <explicitjelly> OR
10:07:35 <explicitjelly> I could leave the house.
10:07:57 <dons> lennart's getting interviewed today. inneresting
10:08:19 <dons> Igloo: know who this is ? http://twitter.com/magthe/statuses/1014692572
10:08:19 <lambdabot> Title: Twitter / magthe: The Debian Haskell package ...
10:08:45 <conal> Cale: what do you like about that semantics?
10:09:26 <Igloo> dons: No
10:09:56 <Cale> conal: It reflects the idea that an Event is a piecewise constant function of time.
10:10:50 <Cale> (basically, just stealing the instance of Monad for ((->) t)
10:10:52 <Cale> )
10:10:53 <conal> Cale: that's reactive values, not events.
10:11:06 <hackage> Uploaded to hackage: taglib 0.1.0
10:11:16 <conal> Cale: i mean, that join semantics agrees with reactive values, which are step functions.
10:11:39 <conal> Cale: while events have a different semantics and different join instance.
10:11:46 <conal> (i mean monad instance)
10:12:43 <Cale> Oh, Events only happen once?
10:12:45 <dons> Cale: hehe http://twitter.com/jkale/statuses/1015012334
10:12:46 <lambdabot> Title: Twitter / Rich Mehta: I've finally cracked the H ...
10:12:54 <conal> Cale: no.  repeatedly
10:13:23 <Cale> Okay, so I'm not that confused :)
10:14:03 <Cale> The only difference between an Event and a Reactive is that the Reactive has a value available right away?
10:14:05 <quicksilver> conal: (sorry I had to hop on a train) yes, well I think it does, by recursive calls to mappend and itself.
10:14:14 <Cale> dons: hehe
10:14:27 <quicksilver> Cale: that's the difference in information content, yes.
10:14:56 <quicksilver> Cale: the difference in meaning is that reactives have a value available at all times, whilst Events only have values at finitely many discrete times.
10:15:19 <Cale> Finitely many?
10:15:48 <quicksilver> within the constraints of ordinary computations, yes.
10:15:59 <quicksilver> countably many perhaps from a theoretical perspective.
10:16:03 <Cale> okay
10:16:52 <Cale> But every Event a has an associated Reactive (Maybe a)
10:17:00 <quicksilver> yes.
10:17:10 <quicksilver> Nothing `stepper` Just <$> e
10:17:29 <Cale> Which gives Nothing until the first event, and then Just x at time t when x is the last value which the Event gave.
10:17:30 <conal> with information loss
10:17:43 <Cale> What information is lost there?
10:18:00 <conal> successive occurrences with the same value
10:18:14 <Cale> ah, right, okay.
10:18:44 <camior> Also, occurances that happen at the same time.
10:18:47 <quicksilver> conal: of course my joinE relies on a joinF.
10:18:56 <conal> camior: yeah, that too.
10:19:13 <quicksilver> but that's easier to write.
10:19:19 <conal> quicksilver: yeah.  nice.  and joinF has simple semantics.
10:20:12 <Cale> quicksilver: So what does your joinE actually do?
10:20:29 <quicksilver> Cale: given an event-valued-event
10:20:32 <conal> (nothing -- it's functional ;) )
10:20:44 <quicksilver> produce an event which is the union of all those occurrences
10:20:47 <quicksilver> in the right order.
10:21:45 <Cale> quicksilver: Ah, okay, so once an Event a happens in the outer Event (Event a), all of its occurrences of type a for the whole future happen in the join?
10:21:59 <quicksilver> yes.
10:22:08 <Cale> okay
10:22:11 <conal> yeah
10:22:20 <quicksilver> suppose the outer event is new participants joining a chat room
10:22:27 <quicksilver> a participant is Event String - all the things they will say
10:22:45 <quicksilver> so Event (Event String) is all the participants joining and saying stuff
10:22:53 <quicksilver> joining it reduces that to all the stuff that gets said
10:23:45 <ToRA|MSR> qq: is infix data constructors, ala data Tuple = Int `Bar` Int  in h98 or an extension?
10:24:12 <camior> quicksilver: What happens to the statement someone said before they joined?
10:24:32 <quicksilver> that's one of the key questions, of course.
10:24:52 <Cale> I would guess that those should be discarded.
10:25:04 <quicksilver> my implementation doesn't solve that.
10:25:10 <quicksilver> ToRA|MSR: it's h98.
10:25:37 <ToRA|MSR> quicksilver: k thanks, i'll reread the report a bit more carefully then
10:25:39 <quicksilver> ToRA|MSR: theree aren't any arity two alphanumeric constructors in the prelude though
10:25:46 <conal> i think the semantics of future join does answer that question.
10:25:54 <Cale> quicksilver: The other option is to stop listening to one Event a once the next one occurs.
10:26:00 <camior> Well, if go on a rant, before I connect, I could see where it would be useful to post my rant immediately upon connecting.
10:26:14 <quicksilver> oh, yes.
10:26:20 <PeakerWork> quicksilver: so the difference between joinE and joinF is whether you unify or discard the non-last event source?
10:26:29 <quicksilver> I push the times forward. in joinF.
10:26:45 <quicksilver> so in my model everything you said before, you say the instant you join.
10:26:52 <quicksilver> (with time adjusted to your joining time)
10:26:59 <quicksilver> since my joineE uses my joinF.
10:27:06 <paggas> regarding my understanding of functional purity (:P): why is par pure? (http://haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel.html) isn't spawning a thread for parallel computations considered a side-effect?
10:27:07 <lambdabot> Title: Control.Parallel, http://tinyurl.com/685nu3
10:27:08 <conal> that's the semantics of Future join in the Reactive paper
10:27:09 <geezusfreeek> i think i am going to avoid making my Event a monad until i have a use case that _makes_ it a monad
10:27:26 <Cale> paggas: It doesn't change the meaning of the program though.
10:27:31 <Asgaroth> Is there a package which implementents the erf-function or the normal cumulative distribution function?
10:27:40 <geezusfreeek> but i am not making a library for the sake of a library right now, so i can get away with that
10:27:46 <camior> Unfortunately, that version of join doesn't form a monad.
10:27:52 <quicksilver> conal: yes, that's where I copied it from ;)
10:28:05 <quicksilver> camior: I don't know if I think that's unfortunate.
10:28:10 <Cale> paggas: Adding par annotations doesn't affect termination behaviour or the result of the computation, only the resources it uses to compute.
10:28:13 <quicksilver> I don't know if I think Event is a (useful) monad.
10:28:35 <quicksilver> geezusfreeek: agreed.
10:28:36 <camior> Well, we loose the type class morphism.
10:28:46 * lispy grumbles
10:28:55 <geezusfreeek> i am happy with applicative for now
10:28:56 <camior> And are back at the stage where we can choose anything we want for join.
10:28:57 <conal> quicksilver: i think time & experience will tell.  Reative was the first FRP lib to make event a monad.
10:28:58 <lispy> This page should be easier to find!  It is very, very valuable :) http://www.haskell.org/haskellwiki/Research_papers/Type_systems
10:29:00 <lambdabot> Title: Research papers/Type systems - HaskellWiki
10:29:08 <paggas> Cale: aha, i think i'm getting it :)
10:29:14 <geezusfreeek> even that is a little weird at times
10:29:16 <quicksilver> conal: I agree.
10:29:26 <Cale> I think we can decide how we want Behaviour to be a monad though...
10:29:36 <camior> Cale: how?
10:29:41 <conal> Cale: yes
10:29:51 <quicksilver> camior: behaviour is definitely a monad, morally.
10:29:55 <quicksilver> it's hard to implement though.
10:30:04 <quicksilver> that was supposed to be directed at Cale, but whatever :)
10:30:14 <quicksilver> geezusfreeek: I don't like the Event applicative either.
10:30:14 <vixey> lispy, types.reddit.com
10:30:17 <Cale> What makes it hard to implement?
10:30:22 <quicksilver> geezusfreeek: (I don't have that instance)
10:30:26 <Cale> It's certainly easy to implement on the semantics...
10:30:54 <vixey> though, it is less haskell oriented
10:31:16 <geezusfreeek> quicksilver, i have only bothered to implement it in past experiments. it didn't seem so ugly to me, and it actually met the applicative laws at least
10:31:36 <geezusfreeek> i remember that i used it a couple times in test simulations, but i can't remember what for anymore
10:31:41 <paggas> something else now; how does functional purity interact with the fact that when dealing with floats, one will most probably have some error in the end? or is it irrelevant, in the sense that the error will always be the same?
10:31:52 <geezusfreeek> > 1/0
10:31:54 <lambdabot>   Infinity
10:31:57 <lispy> vixey: thanks, I'll look it over
10:32:01 <geezusfreeek> woops
10:32:04 <geezusfreeek> duh
10:32:11 <quicksilver> geezusfreeek: I find it to be rather ugly around simultaneous events.
10:32:22 <Cale> paggas: Well, if your parallelisation method results in a nondeterministic association of some operation, that may cause problems.
10:32:30 <geezusfreeek> paggas, oh, do you mean precision?
10:32:42 <geezusfreeek> the errors are well-defined, afaik
10:33:13 <conal> Cale: ("What makes it hard to implement?")  The Behavior representation is Reactive :. Fun Time.  For a join, I don't know how to define a Fun Time :. Reactive -> Reactive :. Fun Time
10:33:17 <Cale> paggas: For example, to take the sum of an array of Floats by breaking it up into chunks to evaluate in parallel, that may give very different results based on how it's broken up.
10:33:35 <conal> (where (:.) is type composition)
10:33:37 <paggas> hmmmm
10:34:08 <conal> ??? :: Fun Time (Reactive a) -> Reactive (Fun Time a)
10:34:32 <paggas> so purity has only to do with the final result
10:34:39 <Cale> paggas: yes
10:34:45 <quicksilver> geezusfreeek: f <*> x in Event has occurrences whenever either f or x has an occurence.
10:35:31 <quicksilver> geezusfreeek: that's strange, but fine I suppose. Until you consider f having (only) two simultaneous occurences, and x also haveing two (at the same time as f)
10:35:31 <pumpkin_> is there some simple compose f x function? that does (f . f . . .) x times?
10:35:34 <conal> quicksilver: me too, about simultaneous events.  something isn't right there.
10:35:45 <quicksilver> geezusfreeek: does that have two occurrences? 4? 1? why?
10:36:00 <capitrane> somebody who has experience of image processing in haskell?
10:36:09 <quicksilver> and also I haven't found a use for <*> on Events yet anyway.
10:36:20 <quicksilver> much better to use <*> on Reactives, which have a value at all times.
10:37:00 <Cale> conal: hmm, yes, I can see the difficulty there.
10:38:18 <quicksilver> pumpkin_: (iterate f x) !! n
10:38:28 <Cale> conal: You end up wanting to turn something continuous into something discrete.
10:38:36 <conal> Cale: that's where i got stuck and am still stuck.  i don't know how to simultaneously get data-driven reactivity, continuous time, and a behavior monad.
10:38:41 <luqui> foldr (.) id . replicate n
10:38:50 <paggas> since haskell programs aren't executed in some specific order, how does one use par correctly? how do i say that a value will be needed *later*?
10:39:13 <Cale> paggas: In practice, they are evaluated in lazy evaluation order.
10:39:24 <pumpkin_> > iterate (^2)
10:39:25 <lambdabot>       Overlapping instances for Show (a -> [a])
10:39:25 <lambdabot>        arising from a use of ...
10:39:28 <Cale> paggas: That is, outermost functions first.
10:39:35 <pumpkin_> can I pl that?
10:39:40 <pumpkin_> @pl iterate (^2)
10:39:41 <lambdabot> iterate (^ 2)
10:39:45 <pumpkin_> nice :P
10:39:54 <quicksilver> pumpkin_: it doesn't have any points to lose.
10:39:55 <paggas> Cale: isn't that too much implementation dependent?
10:39:59 <pumpkin_> yeah, makes sense
10:40:07 <Cale> paggas: Lazy evaluation is well-defined :)
10:40:34 <Cale> paggas: Let's have a quick look at evaluation orders.
10:40:35 <Sizur> hi lambdabot
10:40:44 <pumpkin_> > ((iterate (^2)) !! 3) 3
10:40:45 <lambdabot>   Couldn't match expected type `[a]'
10:40:47 <pumpkin_> hmm
10:40:53 <paggas> and i guess, par won't be considered unless it's a strict dependency for some other function?
10:40:54 <Cale> paggas: I'll use my standard example, suppose we have the function double x = x + x
10:40:59 <Deewiant> > ((!! 3) . iterate (^2)) 3
10:41:00 <lambdabot>   6561
10:41:09 <Cale> and we want to evaluate  double (double 5)
10:41:17 <paggas> ok
10:41:29 <Cale> Under strict (innermost-first) evaluation, this goes:
10:41:32 <Cale> double (double 5)
10:41:36 <Cale> -> double (5 + 5)
10:41:39 <Cale> -> double 10
10:41:41 <Cale> -> 10 + 10
10:41:43 <Cale> -> 20
10:41:43 <pumpkin_> Deewiant: how are those two different?
10:41:58 <Deewiant> yours tries to index the function instead of its result
10:42:04 <luqui> paggas does have a point though.  par is strictly a practical thing, and has no semantic bearing whatsoever.  if you were a pure mathematican, you would say "why would I ever ever use par?"
10:42:04 <pumpkin_> ah
10:42:09 <Cale> Under normal-order (outermost-first) evaluation, it goes like this:
10:42:12 <Cale> double (double 5)
10:42:19 <Cale> -> (double 5) + (double 5)
10:42:26 <Cale> -> (5 + 5) + (double 5)
10:42:28 <luqui> semantcally meaningful parallel combinators is something I'm after as a general goal :-)
10:42:30 <Cale> -> 10 + (double 5)
10:42:34 <Cale> -> 10 + (5 + 5)
10:42:36 <Cale> -> 10 + 10
10:42:38 <Cale> -> 20
10:42:45 <paggas> right
10:42:51 <Cale> Of course, that took more steps: we ended up computing double 5 twice
10:43:24 <Cale> So lazy evaluation makes a modification to this: if a parameter to a function occurs more than once in the body, then the results of evaluating it are shared between the copies.
10:43:37 <Cale> I'll use  let ... in ...  to represent the sharing.
10:43:41 <Cale> double (double 5)
10:43:46 <Cale> -> let x = double 5 in x + x
10:43:51 <Cale> -> let x = 5 + 5 in x + x
10:43:54 <Cale> -> let x = 10 in x + x
10:43:58 <Cale> -> 20
10:44:23 <paggas> right
10:44:45 <Cale> So that's all there is to lazy evaluation :)
10:44:56 <Cale> Now, par...
10:45:25 <Cale> The idea is that evaluating (par x y) will cause x to be put on a queue of values to evaluate if there's time available, before resulting in y.
10:45:29 <conal> quicksilver: i _really_ like your idea of using Future join in defining Event join!  obvious in retrospect, but i sure didn't think of it.  i'm going to mull it over for a while.
10:45:58 <Cale> So consider something like:
10:46:00 <conal> quicksilver: to see if it handles infinite events
10:46:16 <paggas> but shouldn't par be in the IO monad or something? because then, why have a separate IO monad, and not use the _well-defined_ lazy eval. order to do IO?
10:46:50 <Cale> Well, we could, but controlling the lazy evaluation order is tricky.
10:47:06 <Cale> and with IO, the order of execution *matters*
10:47:15 <luqui> perhaps not iO
10:47:27 <paggas> sounds like an abuse of lazy eval. order
10:47:32 <luqui> perhaps a purer monad that gives a bit more control
10:48:11 <Cale> Well, once you see the idiom of using par, it's not so bad.
10:48:13 <paggas> luqui: yep :)
10:48:14 <geezusfreeek> hmm. this conversation about par makes me wonder... what would a language be like that treats parallel evaluation the same way it treats lazy and strict evaluation?
10:48:16 <luqui> but it's a difficult thing to reconcile
10:48:20 <Cale> In fact, lazy evaluation order is exactly what you want.
10:48:24 <luqui> since on one hand par = const
10:48:30 <luqui> so you're not doing anything semantically evil
10:48:50 <geezusfreeek> using terms like "parallel data type" in addition to "strict data type" and "lazy data type"
10:48:50 <luqui> you're just cluttering up your code with strange extra stuff
10:49:23 <geezusfreeek> we are partly there with dph i guess
10:49:31 <geezusfreeek> but we only have parallel arrays
10:49:32 <Cale> Consider something like:  let x = difficultCalculuation in par x (somethingWith x)
10:49:38 <luqui> my problem with par is not that it introduces effects... because it doesn't.
10:49:54 <luqui> it's that you can't reason about it in the domain.
10:49:57 <paggas> i still have the feeling that this is an abuse of the lazy evaluation order :|
10:50:06 <Cale> paggas: I suppose it is.
10:50:31 <Cale> paggas: If you start evaluating that expression by evaluating somethingWith x, and only later get to the par, then it won't be parallel.
10:50:52 <Cale> (because you'll already have computed x, supposing that you needed it at all)
10:50:58 <luqui> but we're forbidden from evaluating in that order
10:51:03 <luqui> because somethingWith x might be _|_
10:51:06 <Cale> Right.
10:51:09 <Cale> Well...
10:51:18 <Cale> There are things in between lazy and strict.
10:51:29 <luqui> I guess you did say "start evaluating"
10:52:01 <luqui> I consider par more like metadata
10:52:16 <luqui> i.e. it's not part of your program, it's like little sticky notes you're putting on your program to help the compiler
10:52:41 <luqui> just like strictness annotations on an already-strict function
10:52:49 <Sizur> need some help please ... http://hpaste.org/12221
10:52:53 <Cale> Yes, that's probably the best way to look at it. No matter which evaluation order the compiler is going to use, it probably should take care of the par before its parameters.
10:53:15 <paggas> it's that _later_ i guess that causes problems :) pure functional programming hasn't something to do with the order of evaluation, the usual lazy evaluation order is more of an implementation convenience, i'd say... one shouldn't take it for granted
10:53:16 <geezusfreeek> okay, thoughts on a language extension anybody? we have strictness annotations like data Foo = Foo !Int !Int. what if we had parallel annotations, something (arbitrarily) like data Foo = Foo &Int &Int? could the semantics make sense?
10:53:55 <_pizza_> just make everything parallel by default ;-D
10:53:56 <geezusfreeek> they would have to be strict of course
10:54:06 <geezusfreeek> but also evaluated in parallel?
10:54:12 <Cale> Sizur: well, that looks like the package is missing a dependency that it needs.
10:54:25 <Cale> Sizur: But also, you have an old Cabal and cabal-install
10:54:32 <luqui> paggas, though there is a nice domain theory for "timed thunks" which could apply.  unfortunately it does not match what haskell does
10:54:45 <Sizur> Cale: process-1.0.1.1 is installed
10:54:46 <paggas> some sort of parallel monad? :D
10:55:00 <Cale> Sizur: yeah, but the .cabal file for hsc2hs might not mention it.
10:55:16 <Sizur> Cale: i need the hsc2hs to install zlib to install cabal-install
10:55:18 <geezusfreeek> hmm... i think that syntax may not make much sense though
10:55:33 <luqui> paggas, what would be the semantics of your parallel monad?
10:55:34 <Cale> Sizur: hmm...
10:55:40 <luqui> paggas, i.e. how would that improve things?
10:56:01 <Cale> Sizur: that's strange, because I didn't...
10:56:03 <pumpkin_> is there a good optimization toolkit for haskell? bindings to TAO or something?
10:56:23 <Sizur> Cale: sec, let me paste cabal install cabal-install
10:56:25 <paggas> luqui: good question :)
10:56:31 <LeCamarade> Of monoids and groups, which is the subset of the other?
10:56:56 <Cale> All groups are monoids.
10:57:00 <geezusfreeek> ah, yes it would. pattern match on Foo, then the annotated parameters are evaluated in parallel
10:57:06 <Cale> Not all monoids are groups.
10:57:17 <Cale> Groups are monoids which have inverses for every element.
10:57:35 <Sizur> Cale: http://hpaste.org/12221#a1
10:59:49 <LeCamarade> Cale, thanks you. :o)
11:00:23 <conal> geezusfreeek: cool idea :)
11:00:46 <geezusfreeek> conal, yay somebody noticed it! i was worried i would get no feedback at all :)
11:01:24 <luqui> geezusfreeek, your comments got lost in the flurry
11:01:33 <geezusfreeek> heh, yeah it was busy
11:01:36 <luqui> geezusfreeek, I think they would necessarily be nonstrict
11:01:49 <Cale> Sizur: Well, we can fix the .cabal file
11:02:20 <luqui> geezusfreeek, so is it construction or destruction that starts the evaluation?
11:02:25 <Cale> Sizur: cd ~/.cabal/packages/hackage.haskell.org/hsc2hs/0.67.20061107/
11:02:38 <Cale> Sizur: and then unpack the tar.gz you find there.
11:02:59 <geezusfreeek> luqui, i would say destruction i guess, but the idea is only a few minutes old and needs more though ;)
11:03:03 <geezusfreeek> *thought
11:03:12 <Cale> Sizur: In hsc2hs.cabal (which you'll find in the subdirectory which is created by unpacking) you'll see a line:
11:03:17 <Cale> Build-Depends: base
11:03:23 <Cale> Edit it to read:
11:03:26 <conal> maybe it's whnf'ing that spins threads for the parallel components.
11:03:27 <Cale> Build-Depends: base, process, directory
11:03:39 <geezusfreeek> conal, right, that is what i was thinking
11:03:48 <paggas> okay, i agree that par is useful and works in practice, but to me it seems there are problems from a theoretical standpoint
11:04:02 <luqui> conal, ah, so basically it just changes each constructor Foo x y to x `par` y `par` Foo x y
11:04:10 <Cale> paggas: Well, from some theoretical standpoints, it's a no-op.
11:04:38 <Cale> paggas: If you're unwilling to specify an evaluation order, then it's hard to talk about parallelising computation.
11:04:45 <conal> luqui: oh.  that's a nice simple way to think about it.
11:05:00 <Sizur> Cale: and build-type: Simple too?
11:05:13 <Cale> Sizur: perhaps... I didn't have to do that to get it to build.
11:05:24 <conal> luqui: though decided per field
11:05:27 <geezusfreeek> luqui, i was thinking more like (\(Foo x y) -> whatever) means (\(Foo x y) -> x `par` y `par` whatever)
11:05:28 <Cale> Then you can just run cabal install from that directory.
11:05:29 <luqui> indeed
11:05:41 <paggas> Cale: it worked for the IO monad though! it works without having to think about evaluation order
11:05:57 <conal> how are ! fields defined?
11:06:13 <geezusfreeek> conal, i thought it was like the latter, but maybe i was wrong?
11:06:14 <Cale> paggas: right, by explicitly representing the order of execution.
11:06:23 <Cale> conal: Same way, but with seq
11:06:27 <luqui> conal, it makes the constructor strict in that argument
11:06:46 <luqui> using the formal definition:  Foo _|_ = _|_
11:07:11 <conal> if there's a precise definition of how ! fields are interpreted, maybe we can do something like s/seq/par
11:07:13 <geezusfreeek> luqui, so strict Foo x y means x `seq` y `seq` Foo x y?
11:07:25 <geezusfreeek> if that is the case then i agree with your version for par
11:07:47 <luqui> it's still all ad hoc and meaningless though
11:07:56 <Saizan> geezusfreeek: i think pseq is more appropriate thre
11:08:02 <geezusfreeek> :t pseq
11:08:03 <lambdabot> forall a b. a -> b -> b
11:08:04 <luqui> we might be looking for a semantics in which there is an analogous notion to _|_ for parallelism
11:08:41 <conal> pseq??
11:08:48 <conal> oh.
11:08:53 <luqui> so  f = (\x -> x `par` foo x) means f ~-~ = ~-~    (except that would probably not be ordinary application)
11:08:59 <Saizan> pseq is strict in the first argument while par isn't
11:09:26 <Saizan> i'm not sure what strict means here with parallelization though..
11:09:40 <luqui> so pseq waits until both arguments are evaluated to return?
11:09:58 <luqui> but it still does them in parallel?
11:10:30 <tomh> anyone here remembers a site called got a haskell or something like that?
11:10:34 <geezusfreeek> hmm... i like that too
11:10:38 <Badger> tomh:
11:10:42 <Badger> @where lyah
11:10:42 <lambdabot> www.learnyouahaskell.com
11:10:46 <Badger> that one?
11:10:49 <tomh> ah that one yes
11:10:52 <tomh> thanks
11:10:55 <Saizan> ..or maybe i'm misundertanding pseq completely
11:10:55 <pumpkin_> anyone done any "scientific computing" in haskell? :P
11:11:00 <luqui> pseq strikes me as a simpler notion than par, even if it is less expressive  (is it?)
11:11:01 <sheyll> hi
11:11:06 <hackage> Uploaded to hackage: feed 0.3.6
11:11:24 <orbitz> tomh: real world haskell is good too if you are looking at tutorials
11:11:30 <camior> pumpkin_: would computational geometry qualify?
11:11:37 <tomh> actually im looking on a crash course on monads
11:11:43 <dcoutts> Saizan: pseq is like seq, but...
11:11:47 <sheyll> how do I "sleep" in the current version of hugs, w/o any extra  libs installed?
11:11:48 <Badger> tomh: oh.
11:11:49 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel.html#v%3Apseq <-- i can't understand if pseq adds parallelism
11:11:51 <lambdabot> Title: Control.Parallel, http://tinyurl.com/685nu3
11:11:59 <pumpkin_> camior: that's one thing I'm curious about, but I was thinking more along the likes of big/sparse matrices, nonlinear optimization, and so on
11:11:59 <Badger> LYAH doesn't have a Monads section yet
11:12:00 <dcoutts> Saizan: it does not
11:12:05 <tomh> to bad that learn me a haskell site doesn't have that section yet
11:12:06 <tomh> ye
11:12:23 <tomh> i need to learn it in like one day, any tips? :P
11:12:27 <Badger> tomh: you'll want book.realworlhaskell.org then (I think that's the right one)
11:12:33 <tomh> ok thank
11:12:34 <tomh> s
11:12:34 <Badger> oops
11:12:40 <Saizan> dcoutts: ah, so it's just a more precise seq?
11:12:42 <dcoutts> Saizan: as I understand it, the strictness analyser thinks pseq is lazy in it's first arg, so the strictness is not statically propagated, but at runtime it really does cause evaluation
11:12:44 <Badger> don't paste that link, I misspelled :P
11:13:03 <pumpkin_> camior: but if there's anything even remotely approaching CGAL available in haskell that would make me very happy too :)
11:13:07 <tomh> i put a d in it :P
11:13:09 <orbitz> Badger: oh no, you've inadvertinely given the URL that sets all the worlds nukes off when it gets a hit!
11:13:29 <dcoutts> Saizan: so it gives more precise runtime control of when evaluation will happen, seq means it can happen earlier due to strictness analysis, and that might defeat parallelism
11:13:45 <Badger> orbitz: D:
11:13:58 <camior> pumpkin_: I've done some closed source stuff like that. I remember there being things like voronoi diagram computation libraries.
11:14:10 <pumpkin_> ah :/
11:14:15 <paggas> someone come up with a cool idea for parallelization, like what the IO monad did for io!
11:14:37 <geezusfreeek> paggas, trying :)
11:14:55 <luqui> gah!
11:15:00 <geezusfreeek> paggas, was have par and data parallelization already though :)
11:15:03 <geezusfreeek> *we have
11:15:06 <luqui> pseq :: a -> b -> b  is not strict in its second argument!
11:15:17 <luqui> (at least that's what the compiler sees)
11:15:20 <Saizan> dcoutts: i see, thanks
11:15:26 <luqui> which is total nonsense.  it can only be strict in its second argument!
11:15:31 <tomh> i've only seen monads very shortly so im noob, but are monads not like an attempt to kinda get the sequential part of imperative programming back into functional programming?
11:15:35 <paggas> geezusfreeek: you have a bachelor in mathematics? :D
11:15:39 <Giraffe> tomh, sorta
11:15:44 <pumpkin_> camior: voronoi diagrams are cute, but I was hoping for other geometrical algorithms (CAG/CSG, etc.) and primitives CGAL style :)
11:15:58 <Giraffe> it's that and a way to sort of relay data along in your program
11:16:02 <geezusfreeek> paggas, why do you ask that?
11:16:03 <Giraffe> chain it together, as it were
11:16:04 <Saizan> dcoutts: btw, did you take a look at my revised unpack patch?
11:16:06 <geezusfreeek> paggas, i do have a minor
11:16:10 <tomh> ok
11:16:17 <camior> pumpkin_: Why the interest?
11:16:21 <dcoutts> Saizan: it's on my TODO, I was away the last few days
11:16:53 <dcoutts> luqui: that seems backwards to me, I think pseq is only strict in it's second arg (statically)
11:17:09 <luqui> well that's not what the docs say...
11:17:14 <pumpkin_> camior: well, I love computational geometry as a side interest, but I actually do need nonlinear optimization and would like to use haskell next time I need to solve something
11:17:14 <paggas> geezusfreeek: at least the concept of monads would require some good mathematics to be come up with :P
11:17:17 <luqui> but they might be wrong
11:17:19 <dcoutts> I think they must be wrong
11:17:22 <dcoutts> since it returns it's second arg then it is necessarily strict
11:17:43 <Saizan> This is why we have pseq. In contrast to seq, pseq is only strict in its first argument (as far as the compiler is concerned), which restricts the transformations that the compiler can do, and ensures that the user can retain control of the evaluation order.
11:17:46 <geezusfreeek> paggas, it was already discovered. somebody merely applied it to programming ;)
11:17:50 <camior> pumpkin_: I was considering doing a binding to a CSG library a while ago. Doesn't look too tough.
11:17:52 <luqui> but the examples re: optimization in the docs make sense from the docs perspective
11:18:10 <geezusfreeek> ah, yes, i just checked the report. strict parameters are evaluated at construction
11:18:11 <luqui> i.e. it says that a `seq` b may be rewritten to b `seq` a `seq` b, and that's what pseq prevents
11:18:20 <paggas> geezusfreeek: even so :)
11:18:37 <pumpkin_> camior: I guess you're right... it would be nice to have a computational geometry lib like CGAL in haskell, where almost everything is parametrized on the underlying types
11:18:47 <geezusfreeek> paggas, programming and math are more intimately related than most programmers and mathemeticians are willing to admit anywa, i think
11:18:50 <pumpkin_> implementing it would be fun but having it just work would be even more fun :P
11:18:58 <luqui> paggas, I am not so sure.  they require a knack for generality, but not necessarily formal maths.
11:19:03 <luqui> it's just the name that requires maths!
11:19:13 <geezusfreeek> monads = warm fuzzy things
11:19:29 <pumpkin_> mmm
11:19:43 <lament> everything is math
11:19:44 <geezusfreeek> now that i think about it, it wouldn't make much sense any other way
11:19:47 <lament> therefore, programming is also math
11:20:08 <geezusfreeek> although now i wonder if we could have lazy parallel parameters _and_ strict parallel parameters
11:20:17 <luqui> they are really quite obvious.  >>= is a sequencing combinator.  Do the thing on the left, then, given that result, do the thing on the right
11:20:27 <luqui> (in retrospect, as usual)
11:21:03 <luqui> and it _must_ be sequencing, because you can't provide the argument to the function on the right if you didn't do the thing on the left first
11:21:04 <dons> dcoutts: does gtk2hs support presentation of .pdf data?
11:21:43 <dcoutts> dons: no, you'd need bindings to the poppler lib to do that. I think it lets you render pdfs to a cairo surface.
11:21:45 <Cale> tomh: Specific monads let you do imperative programming.
11:21:46 <orbitz> are there any std functions to do integer/string conversions with a base?
11:21:48 <orbitz> otehr than decimal
11:21:53 <Cale> tomh: I wouldn't say all monads are like that.
11:22:03 <benjamin_Fr> 559 haskell programmer Oo
11:22:30 <mauke> orbitz: yes, look at Numeric and Data.Char
11:22:31 <luqui> lament, you give math a bad name
11:22:40 <dcoutts> dons: we do something similar for svg data, via a binding to librsvg that can render to a cairo surface. It integrates nicely with the cairo binding.
11:22:44 <luqui> lament, if everything is math, then math is nothing
11:22:44 <geezusfreeek> i'll make a note to myself to think abotu this more later. i need to do some real work
11:22:53 <geezusfreeek> which doesn't involved haskell :(
11:22:54 <orbitz> mauke: thanks
11:22:59 <geezusfreeek> *involve
11:23:08 <Sizur> Cale: thanks a lot :) zlib could not get installed using old cabal-install, but did manually just fine.  Then i could install cabal-install
11:23:09 <dcoutts> dons: I'm happy to provide advice if you need to write the poppler binding.
11:23:18 <dons> dcoutts: oh interesting.
11:23:26 <dons> i'm thinking of writing a lightweight slide presentation tool
11:23:28 <dons> notionally vai pdf
11:23:32 <paggas> heh
11:23:34 <dons> but maybe i can get .svg output
11:23:47 <luqui> lament,  f :: Math -> a.  Math must be empty :-)
11:23:49 <dons> dcoutts: since i'm frustrated with buggy, heavy weight tools for .pdf
11:23:52 <dcoutts> dons: that'd be a quicker route in terms of development time
11:23:57 <dons> yup
11:24:03 <dons> so find a pdf2svg tool
11:24:15 <dcoutts> dons: the gnome pdf viewer evince uses the poppler lib
11:24:23 <dons> oh ok.
11:24:33 <dcoutts> dons: so it's relatively good, I dunno how complex the api is
11:25:09 <dons> ok. that's useful to know. thanks
11:26:20 <dcoutts> dons: I've used the s5 system before, simple html. It's not bad. Stealing an input format like that might work. Or use markdown / pandoc as input.
11:27:18 <dons> mm
11:31:15 <Sizur> > take 10 $ unfoldr (\(a,b)->Just(a,(b,a+b))) (1,1)
11:31:16 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
11:32:36 <geezusfreeek> unfoldr is so underused
11:32:44 <dcoutts> indeed
11:32:52 <vixey> use it more!
11:32:56 <dcoutts> I do !
11:33:00 <geezusfreeek> i do too!
11:33:10 <conal> I vow to!
11:33:26 * dcoutts realises his statement doesn't make sense
11:33:32 <dcoutts> but conal's does :-)
11:33:35 <conal> lol
11:33:38 <geezusfreeek> heh
11:33:51 <geezusfreeek> i use it more too!
11:34:05 <conal> geezusfreeek & i each use it more than each other!
11:34:17 * dcoutts unfolds that argument...
11:34:17 <lucca> what's the difference between a duck?
11:34:26 <dcoutts> lucca: quack?
11:34:32 <lucca> heh
11:34:39 <geezusfreeek> lucca, haha
11:37:08 <conal> lucca: good one!
11:43:09 <tristes_tigres> http://www.haskell.org/pipermail/haskell/2004-November/014939.html
11:43:11 <lambdabot> Title: [Haskell] Typeful symbolic differentiation of compiled functions, http://tinyurl.com/2gxa53
11:43:13 <tristes_tigres> interesting paper
11:45:08 <tristes_tigres>  class Term t a | t -> a where ...
11:45:18 <tristes_tigres> what the | stands for ?
11:45:38 <Philippa> it's a guard
11:45:57 <Philippa> I'm not sure there's a standard verbal pronunciation for it
11:46:12 <tristes_tigres> Philippa: is it haskell 98 or extension ?
11:46:15 <Philippa> extension
11:46:31 <tristes_tigres> philippa: what it's called ?
11:46:46 <mauke> functional dependency
11:46:47 <dmwit_> It's a functional dependency.
11:47:05 <tristes_tigres> mauke, dmwit, philippa: thanks
11:47:13 <Philippa> the idea is that if you know t, then you also know what a is
11:47:47 <conal> a "depends on" ("is a function of") t
11:48:35 <tristes_tigres> Section 8.6.2 of haskell manual
11:49:07 <Philippa> of the /GHC/ manual
11:49:12 <Philippa> there is no "haskell manual"
11:49:46 <tristes_tigres> philippa: right. Is anyone using non-GHC haskell anymore ?
11:50:23 <Giraffe> my impression of GHC was that it's like the GCC of, well, haskell
11:51:02 <tristes_tigres> my impression is that it's getting closer to perl of perl ^-)
11:51:09 <tristes_tigres> perl of Perl
11:51:26 <camior> Ghc Haskell ~ Haskell 98 where C++ ~ C?
11:51:56 <camior> That is, C++ before it got standardized.
11:52:19 <mauke> .oO( ANSI standard GHC )
11:52:35 <Philippa> tristes_tigres: GHC's mostly the de facto standard for getting stuff done at the moment, but if anything it's not desirable for things to entirely remain that way. There're things other implementations can potentially do better
11:52:52 <geezusfreeek> i would love to see JHC get somewhere near polished
11:53:14 <geezusfreeek> takes too long to compile for general development, but perhaps to make a final binary
11:53:21 <orbitz> what is JHC?
11:53:28 <apsod> JHC: http://repetae.net/computer/jhc/
11:53:33 <lambdabot> Title: jhc
11:53:45 <geezusfreeek> orbitz, a haskell compiler designed to generate executables that are as absolutely performant as possible
11:53:48 <orbitz> cool
11:54:06 <geezusfreeek> orbitz, most of my tests in jhc have outperformed C
11:54:11 <geezusfreeek> the ones that work, anyway
11:54:29 <conal> wow
11:54:47 <geezusfreeek> that's what i said
11:54:49 <orbitz> does haskell have some concept of shared libraries? i'm under the impression that in a language like haskell they would be a performance problem, is that accurate at all?
11:55:23 <geezusfreeek> orbitz, i think ghc used to support shared dlls on windows, but not anymore. there is nothing inherent about haskell which prevents it
11:55:50 <tristes_tigres> geezusfreeek: they are improving building DLLs in Haskell, I believe
11:55:52 <geezusfreeek> ghc only compiled statically, and jhc relies on static compilation for much of its performance
11:56:12 <geezusfreeek> *ghc only compiles statically
11:56:20 <tristes_tigres> geezusfreeek: how about matrix computations in jhc ?
11:56:22 <orbitz> geezusfreeek: i would have thought it would A) be a problem for type checkign B) make it difficult to optimize code, i believ ein Ocaml the optimizer has to take advantage of inling a lot of fucntions
11:56:35 <geezusfreeek> tristes_tigres, haven't tried it
11:56:54 <mauke> why for type checking? we already have separate compilation
11:57:11 <geezusfreeek> orbitz, shouldn't be any more of a problem for type checking than static libraries, but there is a bit of a problem with optimization and shared libraries in haskell
11:57:11 <tristes_tigres> geezusfreeek: it's the most interesting test of performance
11:57:19 <orbitz> if you dynamically load teh so, would you have to keep type informatin in there for teh dynamic linker to validate?
11:57:27 <geezusfreeek> tristes_tigres, one of the more interesting ones anyway
11:57:32 <geezusfreeek> i jsut haven't gotten around to it yet
11:57:55 <geezusfreeek> orbitz, if they are compiled already they are already type checked...
11:58:20 <orbitz> but how do you know the so you are loading conforms to the types the loading binary expets?
11:58:20 <geezusfreeek> same for your executable
11:58:29 <Mulgrom> Hi, just wondering: What exactly does the "do" construct do? Coming from imperative languages i have problem grasping it's purpose.
11:58:34 <tristes_tigres> geezusfreeek: Linpack in haskell ! Yay !
11:58:44 <tristes_tigres> would be mighty cool
11:59:00 <geezusfreeek> orbitz, you have the same problems in any other language afaik
11:59:15 <orbitz> geezusfreeek: any other language sucks at type checking though
11:59:15 <mauke> Mulgrom: it's syntactic sugar for calls to >>=
11:59:27 <geezusfreeek> orbitz, doesn't mean they have _no_ type checking
11:59:34 <mauke> Mulgrom: it's just a different notation
11:59:50 <orbitz> is there any interest in targetign haskell for a JIT (JVM/.net?)
12:00:07 <Mulgrom> mauke; Hm, I see. But i don't really know what >>= means either =/
12:00:20 <geezusfreeek> orbitz, from what i've heard, most vms are poor targets for first class functions
12:00:29 <mauke> Mulgrom: >>= is overloaded. its meaning depends on what type it's used with :-)
12:00:32 <dcoutts> Mulgrom: the choice of the word 'do' is because it is like a sequence of imperative actions, but where the ';' action composition operator is defined by the programmer rather than built into the language
12:01:46 <orbitz> geezusfreeek: i wonder wiaht F#'s performanc ei slike
12:02:33 <geezusfreeek> orbitz, not terrible i don't think. maybe i am getting mixed up with call-by-need evaluation
12:02:44 <Mulgrom> Aha, so it's a bit like a way to do imprative programming in haskell, when it's the only option?
12:02:46 <geezusfreeek> something about haskell makes it a poor fit for most vms
12:02:56 <dcoutts> orbitz: for imperative programming I expect it's ok. I don't think it does any clever FP optimisations though (probably does tail calls)
12:03:14 <geezusfreeek> Mulgrom, imperative programming is _one_ of the things you can do with do notation
12:03:44 <dcoutts> geezusfreeek: generalise that statement: something about pure functional languages makes them a poor fit for most vms that are designed for imperative languages
12:04:29 <geezusfreeek> dcoutts, i just said haskell specifically because i don't know if it's due to purity or something else
12:04:51 <geezusfreeek> but yes, it would be something that other languages could have problems with too, not _just_ haskell
12:05:12 <dcoutts> geezusfreeek: it's an interesting and I think an open question as to whether you can design a useful VM that supports both FP and imperative & OOP languages well
12:05:32 <geezusfreeek> dcoutts, well, current hardware seems to do it fine
12:05:53 <geezusfreeek> x86 even has a JIT
12:05:56 <dcoutts> of course one can make an assembler like language, but that doesn't provide any of the inter-language inter-operability
12:06:02 <Peaker> a Haskell VM that does good for Haskell could probably be good for imperative languages too, if it does good for IO actions in Haskell
12:06:17 <dcoutts> that things like jvm/.net provide for different (but similar) oop languages
12:06:49 <Peaker> polymorphism by message passing is deeply ingrained in some VM's..
12:07:30 <tristes_tigres> geezusfreeek: Haskell CPU would be nice :-)
12:07:45 <luqui> reduceron!
12:07:57 <tristes_tigres> wasn't there Lisp Machine long time ago ?
12:08:06 <Corun> luqui, avada kedavra!!!
12:08:15 <Peaker> car/cdr = address register/data register! :P
12:08:30 <mauke> contents of address/data part of register
12:08:36 <conal> luqui: yeah!  leapfrog multi-core to FPGA
12:08:46 <mauke> er
12:08:49 <geezusfreeek> tristes_tigres, from what i've heard, it turns out that the basic design of current hardware tends to be just about as fast for functional programming as special hardware would be
12:08:50 <mauke> data?
12:09:11 <dcoutts> geezusfreeek: most VMs are really only slightly generalised language runtimes, not generic virtual machines, and a major advantage they provide is that they're not generic, they know about the language object model to provide security etc
12:09:11 <geezusfreeek> fpga would be awesome though
12:09:14 <luqui> oh sweet they picked it back up again1
12:09:15 <mauke> ITYM decrement
12:09:29 <luqui> "From 1 October 2008 we will work for 15 months on the Reduceron."
12:09:46 <geezusfreeek> dcoutts, right. and most vms are designed for object languages
12:09:49 <tristes_tigres> Haskell FPGA ?
12:10:19 <dcoutts> tristes_tigres: the reduceron runs a Haskell bytecode and it's implemented in a small FPGA
12:10:45 <tristes_tigres> dcoutts: cool, when we can buy some ? ^)
12:10:49 <dcoutts> luqui: they've got some bigger FPGAs to work with this time
12:11:04 <dcoutts> tristes_tigres: heh, talk to the people doing it
12:11:06 <Peaker> is that FPGA faster at running Haskell than a modern x86_64?
12:11:26 <dcoutts> Peaker: read the paper, but I don't think so
12:11:38 <BMeph> Has there been any work on that SAPL project - well, from the Haskell side, vice the Clean folks? :)
12:11:53 <dcoutts> tristes_tigres: I think getting large FPGAs is rather hard, there are export restrictions and all sorts of nonsense
12:11:53 <tristes_tigres> dcoutts: then what's the point if it is not faster ?
12:11:55 <luqui> Peaker, IIRC the results were comparable to about 1ghz when the fpga was running at 200mhz.  But that's not really a fair comparison.
12:12:22 <dcoutts> tristes_tigres: first version on an FPGA not faster doesn't tell you a huge amount about it not being possible ever
12:12:24 <luqui> tristes_tigres, the question is *will* it be faster?
12:12:51 <luqui> modern x86_64 has 30 years of research behind it
12:12:57 <luqui> reduceron has 3 months
12:13:56 <Peaker> luqui: I doubt the "research" from the early 90's is very relevant to today's x86, let alone the 80's..
12:14:13 <tristes_tigres> Peaker: that depends
12:14:24 <luqui> Peaker, still the same ol' instruction set :-)
12:14:26 <Giraffe> anybody here have any experience with HDBC?
12:14:35 <tristes_tigres> peaker: floating int research is not obsolete, i would think
12:14:39 <tristes_tigres> point
12:14:45 <pierre-> reduceron is very interesing, does anybody know whether new version will run on spartan-3e?
12:15:03 <pumpkin_> modern x86 processors have a huge chunk of the processor dedicated to decoding the ridiculously complex instruction format
12:15:07 <_pizza_> the instruction set is just an interface, a lot happens under the covers on x86
12:15:22 <Peaker> pumpkin_: and support of the complex segment stuff nobody uses
12:15:27 <pumpkin_> yup
12:15:50 <Peaker> call gates, task gates, tss's, nested tasks, v86 mode, so much complexity!
12:15:57 <pumpkin_> yup
12:15:58 <Peaker> (that nobody uses)
12:16:07 <pumpkin_> it's wonderful
12:16:10 <geezusfreeek> and the whole thing is just translated to a RISC instruction set internally
12:20:02 <Twey> @hoogle on
12:20:03 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:20:03 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
12:20:03 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
12:20:06 <Giraffe> bah
12:20:10 <Giraffe> why is HDBC so hard to work with
12:20:32 <dcoutts> luqui: I was wrong about pseq, it is (statically) lazy in it's second arg and statically strict in the first.
12:21:25 <luqui> dcoutts, right, utter nonsense :-)
12:21:48 <dcoutts> luqui: what is utter nonsense?
12:22:12 <luqui> well it is impossible for that function to be anything but strict in its second argument
12:22:34 <dcoutts> yes, there's a distinction between the runtime semantics here and what the compiler knows about those semantics
12:22:39 <luqui> and it ought to be impossible to be strict in an unused argument (the whole Seq typeclass thing)
12:22:41 <geezusfreeek> unsafeSeq, please
12:23:20 <dcoutts> luqui: indeed and the converse, to be lazy in an arg that is directly returned
12:23:47 <dcoutts> from the type a -> b -> b we should assume it's lazy in first and strict in the right
12:23:51 <dcoutts> but it's the opposite
12:24:42 <luqui> the necessity of this function is indication to me that par and seq are not *the way* to go
12:24:49 <luqui> I have no better ideas though =P
12:25:08 <geezusfreeek> parallel annotations!
12:25:23 <luqui> just lift them to a purely "this isn't part of the program" level
12:25:27 <luqui> ?
12:25:39 <lucca> the baroque x86 isa fits better into icache than nice risc isa's
12:26:28 <lucca> a more generalized solution would be to go risc isa and support gzipped instruction streams, heh
12:27:23 <yrlnry> After  type From x a = x -> a ;   I want to   instance Monad (From x), but ghci says "Type synonym `From' should have 2 arguments, but has been given 1".  Why can't I curry "From"?
12:27:56 <Deewiant> type synonyms can't be partially applied
12:28:10 <yrlnry> Thank you, Mr. Tautology.
12:28:24 <pao> yrlnry: use a newtype
12:28:31 <Twey> yrlnry: 'Because'
12:28:34 <Deewiant> I was pointing out that it's a general restriction, not something specific to that type.
12:29:00 <Deewiant> In any case, you want a newtype, because there's already an instance Monad ((->) x).
12:29:20 <vixey> yrlnry, I think you can workaround it though
12:29:26 <vixey> yrlnry, type From = (->)
12:29:36 <vixey> yrlnry, but it is really silly, I think GHC should learn to eta reduce
12:30:10 <yrlnry> I could of course  data From x a = In (x -> a), but if i do that the extra "In"s are both annoying and confusing.
12:30:23 <vixey> I'm not suggesting you do that
12:30:25 <yrlnry> Deewiant: thanks.
12:30:33 <yrlnry> No, nobody suggested that i do that.
12:30:40 <yrlnry> I'm just discussing.
12:30:59 <EvilTerran> vixey, i vaguely recall hearing it claimed that type lambdas could be added to the type system without it breaking
12:31:11 <EvilTerran> i guess they could be used for that purpose
12:31:12 <Deewiant> EvilTerran: I WANT NAO
12:31:13 <luqui> "The prototype compiler to Reduceron code performs no optimisation, only the
12:31:13 <luqui> essential transformations to make code generation possible. Even so, the
12:31:13 <luqui> Reduceron on a slow FPGA (clock-speed 91.5MHz) consis- tently outperforms the
12:31:13 <luqui> fastest byte-code imple- mentations on a PC (clock-speed 2.8GHz, or 30 times
12:31:13 <luqui> that of the FPGA).
12:31:14 <luqui> "
12:31:14 <yrlnry> newtype From x a = x -> a; instance Monad (From x)   says "Not a constructor: `x'"
12:31:21 <EvilTerran> "type From = /\a b. a -> b" kinda thing
12:31:29 <vixey> EvilTerran, I know *I'm* not going to be implementing that
12:31:30 <mauke> yrlnry: you need the extra Ins
12:31:33 <Deewiant> yrlnry: like datas, newtypes need a constructor.
12:31:38 <mauke> newtype is syntactically data
12:31:40 <yrlnry> Oh, right.
12:31:47 <yrlnry> Bleh.
12:32:03 <pao> vixey: EvilTerran: do you think some "lamdba calculus study" could be of any benefit also for a "pragmatic" programmer?
12:32:04 <EvilTerran> luqui, we liek FPGAs :D
12:32:12 <dmead> yo channel
12:32:15 <Mulgrom> @pastebin
12:32:15 <lambdabot> Unknown command, try @list
12:32:19 <Mulgrom> @ pastebin
12:32:19 <EvilTerran> @hpaste
12:32:19 <dmead> what do you do to get a list difference?
12:32:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:32:23 <vixey> pao, no it is completely useless
12:32:25 <Deewiant> dmead: (\\)
12:32:33 <dmead> thanks
12:32:34 <vixey> yrlnry, I didn't realize you wanted to do a monad instance, disregard what I said in that case
12:32:35 <geezusfreeek> luqui, wow!
12:32:52 <EvilTerran> vixey, "it" = lambda calculus study, or a pragmatic programmer? :P
12:33:18 <pao> EvilTerran: :-)
12:33:31 * pao doesn't feel to be useless :-)
12:33:39 <vixey> In the book The Pragmatic Programmer there is many a mention of perl scripts that turn some data into a program but never do they mention lambda calculus
12:33:57 * EvilTerran disagrees with the idea of pragmatism vs purism as an absolute
12:34:18 <yrlnry> Yesterday I was trying to explain the Curry-Howard isomorphism to someone who only knew Perl.
12:34:43 <yrlnry> I had to use  sub { my $a = shift; return sub { my $b = shift; return; } } as an example.  It sucked.
12:35:02 <EvilTerran> i figure knowledge of programming language theory, working up from, say, a simply-typed lambda calculus, would make most people who could grasp it better programmers
12:35:18 <_pizza_> the first time someone described linked lists to me it blew my mind.
12:35:40 <tristes_tigres> It sucks that Haskell 98 standard is so out-of-date wrt GHC
12:35:46 <EvilTerran> if everyone did that, we could finally put PHP out of its misery, as no-one would want to touch it with a barge-pole any more
12:36:12 <tristes_tigres> where would i look up functional dependencies if not for #haskell ?
12:36:21 <geezusfreeek> EvilTerran, ever since i got a real grasp on function programming i have thought the same
12:36:26 <Zao> EvilTerran: The underlying language is largely irrelevant with PHP. What matters is the web-biased standard library.
12:36:27 <geezusfreeek> *functional
12:36:35 <vixey> If Haskell had a decent manual, what would happen to #haskell?
12:37:00 <pumpkin_> lol
12:37:01 <EvilTerran> Zao, PHP's "design" is flawed in so many ways
12:37:06 <tristes_tigres> "Oh, joy, another paper to read"
12:37:10 <EvilTerran> to the point where i'd say there wasn't one
12:37:45 <pao> tristes_tigres: as I understand many extensions ghc are still controversial (see functional dependency) or overlapping (functional dependency vs associated types)...
12:37:55 <EvilTerran> Zao, see: the lack of a namespacing system; the lack of sane scoping rules; etcetc
12:38:03 <EvilTerran> "superglobals", anyone?
12:38:11 <EvilTerran> as if normal globals weren't bad enough
12:38:30 <tristes_tigres> functional dependency is controvercial ?
12:38:57 <EvilTerran> tristes_tigres, well, there's a movement to phase them out and use type families instead
12:39:19 <Deewiant> if you like hugs compatibility you'll use fundeps
12:40:01 <Zao> EvilTerran: The important thing is that it "works" quickly, and fuzzily enough, and good enough.
12:40:13 <pao> tristes_tigres: I found ghc manual to be a good index of "non standard features" and haskell wiki a great tool to dissect the functionalities
12:40:13 <yrlnry> When people say something like "(-> x) is a monad", aren't they leaving out something important?  it seems like (-> x) could be made into a monad in many ways, and what they really mean is "there exists a way to make (-> x) into a monad" or some such.
12:40:32 <vixey> @instances Monad
12:40:33 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:40:35 <vixey> ^ this is what they mean
12:40:46 <mauke> don't you mean (x ->)?
12:41:02 <EvilTerran> Zao, "fuzzily enough"? what a bizarre concept
12:41:22 <yrlnry> Actually I meant ((->) x
12:41:26 <yrlnry> )
12:41:27 <EvilTerran> yrlnry, there's only one way it could be made into a monad, though
12:41:34 <EvilTerran> ?type return
12:41:35 <yrlnry> Really?
12:41:36 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:41:45 <apsod> ugh, I wish GHC 6.8.3 had an easy way to get the stdout of a subprocess :(
12:41:45 <EvilTerran> ?djinn a -> ((->) e) a
12:41:45 <tristes_tigres> pao: but when I run into notation class Term t a | t -> a where ... I was stuck, because I didn't knew wtf it's called
12:41:46 <lambdabot> Cannot parse command
12:41:51 <EvilTerran> ?djinn a -> (e -> a)
12:41:52 <lambdabot> f a _ = a
12:41:57 <Deewiant> ?pl f a _ = a
12:41:58 <EvilTerran> ?type (>>=)
12:41:58 <lambdabot> f = const
12:41:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:42:13 <EvilTerran> ?djinn (e -> a) -> (a -> e -> b) -> (e -> b)
12:42:14 <lambdabot> f a b c = b (a c) c
12:42:22 <pao> tristes_tigres: you have two options (I'm a newbie as you)....
12:42:27 <Deewiant> ?pl f a b c = b (a c) c
12:42:27 <lambdabot> f = flip flip id . (ap .) . flip (.)
12:42:31 <Deewiant> O_o
12:42:42 <EvilTerran> yrlnry, there's the only valid (total) definitions of return and >>= for (e ->)
12:42:49 <pao> tristes_tigres: 1. study all ghc manual to be able to recognize at least syntax patterns
12:42:51 <yrlnry> Sometimes those pointless definitions are worth doing, other times they're just pointless.
12:42:54 <EvilTerran> yrlnry, because of the types
12:42:58 <pao> 2. ask #haskell :-)
12:43:00 <geezusfreeek> @pl f c = b (a c) c
12:43:00 <lambdabot> f = b =<< a
12:43:14 <pao> tristes_tigres: or anything in between :-)
12:43:29 <tristes_tigres> pao: What about the third option - bash head against the wall until it doesn't hurt ?
12:43:41 <tristes_tigres> you forgot that one
12:43:50 <pao> tristes_tigres: :-)
12:44:22 <pao> tristes_tigres: learning haskell is really challenging and fascinating :-)
12:44:43 <pao> tristes_tigres: It's simple and elegant, but it's not ;-)
12:45:04 <geezusfreeek> pao, the more you learn the more beauty you will see
12:45:20 <tristes_tigres> pao: until it becomes somewhat less fascinating, few programmers are going to adopt it, I am afraid
12:45:36 <tristes_tigres> not everyone has a strong masochistic streak
12:46:08 <geezusfreeek> masochistic?! no, haskell is liberation!
12:46:14 <Philippa> tristes_tigres: does Real World Haskell cover fundeps yet?
12:46:54 <tristes_tigres> Philippa: don't know, but they just said fundeps may be are getting obsoleted
12:46:56 <pao> tristes_tigres: :-) I'm a newbie as you... I undestand you... haskell reminds of windsurfing... It's difficult, with a steep learning curve.... you've always lots to learn ... and it's so much fun... :-)
12:47:07 <pao> Philippa: I don't think so
12:47:12 <apsod> windsurfing, heh.
12:47:31 <Philippa> tristes_tigres: yep. Haskell has an interesting relationship with type system research, but once in a while it leads to things like that
12:48:09 <tristes_tigres> pao: what i am saying is that the state of documentation is not adequate
12:48:26 <tristes_tigres> there's no The Haskell Book
12:48:37 <apsod> Real World Haskell.
12:48:44 <apsod> (eventually ;_;)
12:48:50 <tristes_tigres> apsod: it is not The Haskell Book
12:48:56 <apsod> I can dream.
12:49:03 <tristes_tigres> Report would be it, if it weren't obsolete
12:49:25 <pao> tristes_tigres: you have haskell report + ghc manual
12:49:35 <vixey> tristes_tigres, it's still implemented you program in it if you want
12:49:42 <vixey> tristes_tigres, or add in some extensions
12:49:57 <pao> tristes_tigres: I think those two document provide you with a pointer to almost anything you would be interested into
12:50:09 <tristes_tigres> vixey: Haskell 98 is not fully implemented yet ?
12:50:18 <yrlnry> EvilTerran: are you sure that's right?   Each theorem can have many proofs.  Some proofs may not be equivalent.
12:51:10 <tristes_tigres> pao: I would agree if there were updated syntax reference, where one can look up stuff like class Term t a | t -> a where
12:52:36 <vixey> yrlnry, every proof is equal
12:52:48 <vixey> yrlnry, (...or every proof is not equal)
12:52:52 <Philippa> tristes_tigres: I have to wonder if your expectations are coming from a little much from a perl/python/PHP background - there's a lot of languages where there isn't The $language Book and can't be
12:53:09 <vixey> yrlnry, was talking to Cale about it recently....
12:53:42 <ruben> hi
12:53:44 <vixey> You can confuse every proof of the same sentence or identify them by alpha-beta-equality or some relation
12:54:12 <yrlnry> Ok, I am persuaded that there is only one total function with type forall a x . a -> (x -> a)
12:54:12 <tristes_tigres> philippa: I am not so sure in Perl 5 there's The Language book. The major point of perl 6 is to have language defined by standard, not by the interpreter
12:54:42 <tristes_tigres> my point is that Haskell sometimes seems too much like perl in that respect
12:54:45 <vixey> if you are talking about observational equivalence between functions in haskell then..... proofs aren't really important and what I said is irrelevant
12:54:46 <Philippa> tristes_tigres: yeah. So really what you're after is the Haskell' standard when it materialises?
12:54:54 <yrlnry> tristes_tigres: I am not by any means a Perl 6 expert, but I find your claim very unlikely.
12:55:17 <vixey> they didn't mention Perl 6 ...
12:55:29 <vixey> oh I'm just unable to read .
12:55:51 <vixey> anyway Perl 6 is defined by the test suite not an implementation
12:56:35 <tristes_tigres> yrlnr: what do you mean "unlikely" ? that's what the project page says
12:56:50 <yrlnry> Really?  Where?
12:58:05 <tristes_tigres> http://www.perl.com/pub/a/2006/01/12/what_is_perl_6.html "This points to one of the most subtle flaws of Perl 5: its single implementation is its specification. "
12:58:09 <lambdabot> Title: perl.com: What Is Perl 6
12:58:56 <tristes_tigres> philippa: I would be satisfied by some document that is like Standard, but tracks the present state of GHC
12:59:18 <vixey> tristes_tigres, sadly the GHC source code is completely unreadable and does not suffice for that
12:59:20 <yrlnry> tristes_tigres: And the very next sentence is ""Perl 6 will likely also use its test suite as its primary specification
12:59:38 <vixey> yrlnry, that's what I said...
12:59:48 <tristes_tigres> yrlnry: Test suite, not interpeter
12:59:55 <Philippa> tristes_tigres: mmm. You're probably not going to get that too quickly sadly, you'd basically need a technical writer volunteering some significant time to reverse engineer various things as they're implemented. That, and the type system gets hard to spec
13:00:05 <yrlnry> " The major point of perl 6 is to have language defined by standard,..."
13:00:27 <tristes_tigres> yrlnry: yes, that's it
13:00:37 <yrlnry> You think the test suite is a standard.
13:00:46 <tristes_tigres> yrlnry: no
13:01:54 <yrlnry> Then what is the source for your claim that "The major point of perl 6 is to have language defined by standard"?
13:02:05 <tristes_tigres> philippa: In a better world, implementation of an extension should BEGIN by updating the dialect description
13:02:14 <yrlnry> Okay, never mind.  This is totally off-topic.
13:02:19 <tristes_tigres> not maybe perhaps end by it
13:02:24 <foo_> Hi! My teacher gave us a puzzle: "How to stable-split list in two parts without using list arithmetic?". Have You got any ideas?
13:02:31 <Philippa> tristes_tigres: that only works when the extensions aren't a research topic
13:02:55 <tristes_tigres> philippa: don't see why
13:02:59 <Philippa> fundeps and GADTs are two good examples where GHC's been a subtly moving target since their introduction
13:03:13 <Philippa> tristes_tigres: because you only see what's working when you implement it
13:03:16 <foo_> this is actualy an ocaml puzzle, but I think we shouldn't use imperative features
13:03:20 <orbitz> what is list arrithmetic?
13:03:28 <mauke> what is stable split?
13:03:28 <foo_> list length
13:03:45 <vixey> what's list arithmetic
13:03:46 <foo_> take list length /2 and drop so
13:03:49 <pao> vixey: really? ghc src are difficult to approach?
13:03:50 <tristes_tigres> philippa: before you implement something, you have an idea what you are implementing
13:03:58 <vixey> pao, very
13:04:02 <pao> vixey: I'm not even able to judge :-)
13:04:03 <SamB> I think he means not to use the library functions ...
13:04:09 <foo_> stable means they should be in the same order if merged
13:04:25 <Philippa> tristes_tigres: an idea is not a specification
13:04:29 <orbitz> erm
13:04:32 <orbitz> what are you splitting it on?
13:04:45 <foo_> two parts
13:04:50 <foo_> like in mergesort
13:04:57 <orbitz> i don't think that's what i asked
13:05:05 <tristes_tigres> vixey, pao: in GHC 6.10.1 library docs there are lins to source. Excellent new feature I think
13:05:14 <Philippa> the reality for things like this is that the specification and the implementation develop in parallel because a good spec is in fact a program unto itself - especially in the case of type systems where the formal spec can be directly read as a (constraint) logic program
13:05:22 <Mulgrom> Hmm, trying to make me a random Int and Char function, but don't really get the hang of it: This is what i've got: http://hpaste.org/12225  I would like makeRandomChar and Int to return a random Char and Int respectively. Any hints?
13:05:38 <Philippa> additionally, having to fully specify things when it's not known how to specify them in an orthogonal manner is a pain in the butt for multiple reasons
13:05:59 <Philippa> you don't /want/ to try reading the specification for GADTs or impredicative types, even if you are a type theorist
13:06:08 <Philippa> reading the spec for both combined? No thanks
13:06:20 <orbitz> Mulgrom: in what way is it not working?
13:06:47 <SamB> Philippa: except that it's very rare that there aren't either ambiguous notations or library functions that are specified in english ;-P
13:07:41 <vixey> basically programming is broken
13:07:56 <Philippa> SamB: well quite. Doing the same with type system extensions just gets you what's in the GHC manual though
13:08:16 <Philippa> it's not a spec the way the Report is, and it's not intended to be
13:08:39 <SamB> Philippa: uh, I meant in specs
13:08:54 <tristes_tigres> Philippa: At least up-to-date syntax spec is realistic thing to expect
13:09:09 <tristes_tigres> shouldn't be too hard i would think
13:09:27 <SamB> famous last words ;-P
13:09:31 <Mulgrom> orbitz; when i call makeRandomChar need to supply a stdGen, would like it to handle that itself. also the result is strange: try: "do g <- getStdGen; print $ fst $ makeRandomChar g" this gives the same char each time. I would like something like "let char = makeRandomChar"
13:10:15 <orbitz> Mulgrom: you an't hav elet char = makeRandomChar, since it has to be a Monad right? you' dhave ot do cahr <- makRandomChar
13:10:21 <Mulgrom> orbitz; I think I'm missing something fundametal, I'm all new to Func Programming
13:10:25 <Philippa> tristes_tigres: there're rare occasions when that's in flux a little too much, partly because the spec for haskell's syntax is subtle in places as it is
13:10:35 <Philippa> (interactions with the layout rule are often "fun", for example)
13:11:01 <Philippa> and with type system extensions, if those're in flux then the exact syntax can vary as well because the underlying abstract syntax is doing so.
13:11:02 <SamB> Philippa: oh yes, fun is the word I would choose ;-P
13:11:19 <Philippa> SamB: or at least something matching fu*?
13:11:33 <vixey> I think if there was simpler and more expressive libraries and so on then specifying by implementation could work better
13:11:43 <Mulgrom> orbitz; This is what i get: "do g <- getStdGen; c <- makeRandomChar g
13:11:43 <Mulgrom> <interactive>:1:19: The last statement in a 'do' construct must be an expression"
13:11:56 <SamB> that could work well for syntax I guess
13:12:13 <Vulpyne> Mulgrom: thing <- action just binds the thing to the action.
13:12:23 <Vulpyne> Mulgrom: But the do block has to actually return a value.
13:12:33 <Mulgrom> Ah!
13:12:45 <Mulgrom> So i'm not computing anything?!
13:13:01 <Mulgrom> If i make a return in the end?
13:13:34 <Vulpyne> Well, say you wanted to return a random character (BTW, doing it this way wouldn't work because you're using the same generator each time, but just an example...)
13:13:55 <Vulpyne> somefunc = do { g <- getStdGen; c <- makeRandomChar g; return c }
13:14:05 <conal> does cabal-install leave source files behind, or delete them?
13:14:11 <Vulpyne> That is the same as: somefunc = do { g <- getStdGen; makeRandomChar g }
13:15:02 <waern> conal: it stores a tarball of the source somewhere in .cabal/
13:15:08 <waern> IIRC
13:15:14 <Vulpyne> What that actually turns into without the "do" notation is: getStdGen >>= (\g -> makeRandomChar >>= \c -> return c)
13:15:16 <conal> waern: thx.  i see it.
13:15:19 <geezusfreeek> ~/.cabal/packages or something
13:16:07 <Peaker> @hoogle getStdGen
13:16:07 <lambdabot> System.Random getStdGen :: IO StdGen
13:16:11 <Mulgrom> Vulpyne; Hmm. But how do i change the generator after each time
13:16:12 <Vulpyne> Er: getStdGen >>= (\g -> makeRandomChar g >>= (\c -> return c))
13:16:15 <orbitz> Mulgrom: you can't get out of a do, you can just return a value
13:17:08 <Peaker> @pl getStdGen >>= (\g -> makeRandomChar g >>= (\c -> return c))
13:17:09 <lambdabot> makeRandomChar =<< getStdGen
13:17:27 * tristes_tigres can't get any work done when #haskell window is open
13:17:35 <Badger> heh
13:17:47 * Badger can't get any work done when any window is open
13:17:56 <tristes_tigres> may be it's the purpose of the channel ?
13:18:02 <Mulgrom> orbitz; So if i return a walue, the "do" "terminates"?
13:18:08 <Vulpyne> Mulgrom: Well, I haven't used the random functions, but I think ones that get a random value of some sort also return a new generator.
13:18:12 <dcoutts> conal: it upacks the tarball into a temp dir, it builds and installs then removes the temp dir
13:18:16 <orbitz> Mulgrom: once you are in a monad, you'r ein for life
13:18:27 <Vulpyne> Mulgrom: And you'll basically have to sequence that, so each time you use it, you call the random function on the generator returned by the previous.
13:18:27 <conal> dcoutts: thanks.
13:18:38 <tristes_tigres> orbitz: only if it's IO monad, I think ?
13:18:43 <dcoutts> conal: Saizan has added a cabal unpack command which should be handy for this
13:18:58 <Peaker> Mulgrom: "return" does not do what you'd expect from other, imperative languages.
13:19:00 <orbitz> tristes_tigres: err yaeh i'm kind fo talking about of my butt here
13:19:09 <Peaker> Mulgrom: it won't "jump" to the end
13:19:15 <orbitz> tristes_tigres: i think you are correct, you can ge tout of a maybe monad right
13:19:22 <Peaker> Mulgrom: it will merely place the pure value given to it as a computational result of the monad
13:19:32 <Vulpyne> They should have called it put_thing_in_monad!
13:19:39 <tristes_tigres> orbitz: and out of the Either and List too
13:20:00 <Vulpyne> Mulgrom: It looks like you may find getStdRandom useful.
13:20:37 <orbitz> tristes_tigres: i'm still trying to come to grips with monads myself, i probably shouldn't be tryign to help
13:20:43 <Vulpyne> In the IO monad, there seems to be a global random generator, which getStdRandom accesses. Its type is (StdGen -> (a, StdGen)) -> IO a
13:21:00 <Badger> @let put_thing_in_monad x = "No thanks."
13:21:01 <lambdabot>  Defined.
13:21:02 <Mulgrom> Vulpyne; Whats tat?
13:21:20 <tristes_tigres> orbitz: also you can get out of IO monad but it is unsafe
13:21:23 <mauke> :t randomIO
13:21:24 <lambdabot> forall a. (Random a) => IO a
13:21:26 <Vulpyne> So if you pass it one of the random functions, like "next", it'll feed the global generator into that, run next, get the value of it, then update the global random generator to the returned generator, and finally return the calculated random value.
13:21:39 <Vulpyne> http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
13:21:40 <lambdabot> Title: System.Random, http://tinyurl.com/3yau3k
13:22:23 <Peaker> global random generators aren't very nice.  The pseudo-ness of random should always be exposed with an explicit argument
13:22:30 <Peaker> (or an explicit reader you're in)
13:22:42 <Vulpyne> He sounds like a newbie though, probably best not to complicated with stuff like state monads. :)
13:23:05 <Peaker> well, just get a pseudo random generator and use that
13:23:24 <Vulpyne> Mulgrom: randnum <- GetStdRandom next
13:23:35 <Vulpyne> Mulgrom: Binds "randnum" to a random number between 0 and the maximum.
13:23:41 <Peaker> @type next
13:23:42 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
13:24:03 <mauke> just use randomIO
13:24:10 <Peaker> @type randomIO
13:24:11 <lambdabot> forall a. (Random a) => IO a
13:24:26 <Mulgrom> Vulpyne; Nice!
13:24:31 <Vulpyne> Oh yeah, didn't see that. Heh, in all the time I've been using Haskell, I don't think I've ever generated a random number.
13:24:34 <tristes_tigres> @t trace
13:24:34 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:24:43 <tristes_tigres> @type trace
13:24:44 <lambdabot> Not in scope: `trace'
13:24:44 <Peaker> Vulpyne: how much time?
13:24:53 <tristes_tigres> @type Debug.trace
13:24:54 <lambdabot> Couldn't find qualified module.
13:25:03 <Vulpyne> Peaker: Serious work programming for about a year, flirting with Haskell for 5 or so years.
13:25:07 <geezusfreeek> i think newbies should be encouraged to stay out of the IO monad when possible since it is already a common source of problems for them, and that is what experienced haskell programmers do anyway
13:25:15 <Badger> :l Debug
13:25:21 <Badger> @:l Debug
13:25:21 <lambdabot> Debug
13:25:24 <Badger> oops.
13:25:26 <Vulpyne> Well, newbies want to write programs that actuall do something, so they're forced into the IO monad right at the beginning.
13:25:27 <tristes_tigres> @type Debug.Trace.trace
13:25:27 <Badger> @l Debug
13:25:27 <lambdabot> Maybe you meant: learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban . ? @ pl v
13:25:27 <lambdabot> forall a. String -> a -> a
13:25:35 <Peaker> Vulpyne: cool. I've been learning Haskell for about 6-7 months now. Pretty intensively in the last few months
13:25:46 <Badger> apparently I am utterly wrong. ohwell.
13:26:00 <Vulpyne> Peaker: I'm really happy my work lets me use pretty much whatever language I can.
13:26:07 <geezusfreeek> my preferred way to do many random values is with a state monad
13:26:15 <tristes_tigres>  geezusfreeek:  Staying out of IO monad is impossible
13:26:25 <vixey> Staying out of IO is not good practice
13:26:25 <Peaker> Vulpyne: I am not confident yet that Haskell is usable for my workplace, I'm going to try to implement it in Haskell as a hobby project :)
13:26:30 <geezusfreeek> tristes_tigres, i said "when possible," not "always"
13:26:39 <luqui> geezusfreeek, not with the randoms function?
13:26:41 <Vulpyne> The first serious project I ever did in Haskell was a packet sniffer that parsed SIP packets and logged them to a DB, and I had to incorporate in the TCP parsing parts of House (a haskell OS). So it was definately jumping into the deep end of the pool. :)
13:26:42 <Peaker> vixey: ?
13:26:47 <geezusfreeek> :t randoms
13:26:49 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
13:26:54 <geezusfreeek> that is not in IO, and needn't be
13:27:12 <Peaker> Vulpyne: cool. Though I'm more interesting in non-imperative Haskell stuff
13:27:35 <luqui> that is the more interesting part
13:27:40 <Vulpyne> Peaker: Work stuff usually is heavily IO/db/network based, at least where I work. :(
13:27:44 <Badger> good grief
13:27:50 <Badger> there actually is a haskell OS
13:28:03 <luqui> Vulpyne, you would be surprised how much "heavily IO/db/network" can be done without touching the IO monad :-)
13:28:11 <Peaker> Vulpyne: legacy :(
13:28:16 <geezusfreeek> vixey, why is staying out of IO not good practice? yes, to do anything useful you have to use IO, but minimizing that to bare necessity is usually good, no?
13:28:22 <Vulpyne> luqui: Well, part of it still has to touch it, even if most of the processing routines stay pure.
13:28:32 <vixey> no
13:28:42 <luqui> Vulpyne, yes, but the amount that has to touch it is much smaller than most people (even haskell hackers) realize
13:28:54 <vixey> just do what is convenient and correct
13:29:41 <luqui> to the point where my haskell apps nowadays are developed as a pure library and then a small wrapper script.
13:29:45 <apsod> oh man, Control.Concurrent looks really fun.
13:29:54 * tristes_tigres thinks the claim that Haskell is pure is somewhat sloppy
13:29:59 <geezusfreeek> seems a bit dismissive to me. pure functions are far easier to reason about
13:30:01 <luqui> apsod, wait until you see Control.Concurrent.STM! :-)
13:30:20 <geezusfreeek> i mean it as a rule of thumb, not a law
13:30:32 <apsod> luqui: I don't even know what that stands for which means it *must* be awesome :D
13:30:35 * sw17ch <3 STM
13:30:41 <vixey> I think "pure functions are far easier to reason about" has become a slogan
13:30:58 <sw17ch> Software Transactional awesoMeness
13:31:18 <vixey> This does not mean avoiding impure htings makes a program easier to reason about
13:31:34 <geezusfreeek> not _necessarily_
13:31:50 <luqui> especially if your semantics are "nonlocal" in some sense, an IORef (or STRef) can really clean things up
13:33:05 <vixey> More restrictions to worry about "am I overusing IO?" make it more difficult to think about the problem at hand - so I don't think it's wise to suggest people spend a year writing factorial and fibonacci calculators before writing the real program they lean haskell for
13:33:12 <geezusfreeek> i don't think there is any disagreement over the fact that sometimes doing things in IO is the most natural way to do something
13:33:25 <vixey> infact haskell makes it possible to write that program immediately without wasting any time "learning"
13:33:38 <EvilTerran> it's the world's finest imperative language!
13:33:44 <geezusfreeek> EvilTerran, quite true
13:33:55 <vixey> (Assuming some previous programming experience of course)
13:34:02 <Philippa> vixey: being less dogmatic about style is good, yeah. OTOH, it really is true that as a matter of style, keeping IO thin is a good thing
13:34:35 <Philippa> other monads are... different, and the most important rule of thumb is to attempt to /manage/ side-effects
13:34:43 <Japsu> differentmonad is different
13:34:49 <vixey> that is it exactly
13:35:14 <geezusfreeek> Philippa, vixey: then there is no real disagreement here :)
13:35:29 <orbitz> is there a fake one?
13:35:44 <geezusfreeek> orbitz, if you read above, you will see it!
13:35:57 <orbitz> is there still a fake one?
13:36:25 <Vulpyne> Can you use quickcheck for impure functions?
13:37:02 <camior> Vulpyne: With unsafePerformIO you can.
13:37:10 <geezusfreeek> Vulpyne, also check out IOSpec (i think it's called)
13:37:44 <Vulpyne> Hmm.
13:37:59 <Vulpyne> Interesting. Well, I would expect IO to make unit testing harder/less exact at least though.
13:38:31 <conal> geezusfreeek: IO (or STM, ...) is the only to *do* anything in Haskell (though not really *in* Haskell).  another question is whether *doing* is ever most elegant & powerful approach.
13:39:02 <geezusfreeek> conal, quite true, which leads quite predictably to your area of research ;)
13:39:09 <conal> :)
13:39:36 <leimy> conal: what's your area of research?
13:39:42 <geezusfreeek> our mutual area of research, to a point
13:39:49 <dons> ?users
13:39:49 <lambdabot> Maximum users seen in #haskell: 566, currently: 554 (97.9%), active: 28 (5.1%)
13:39:53 <dons> ohh new high score
13:40:00 <geezusfreeek> nice!
13:40:00 <Philippa> a lot of people will reply that right now, it is the most powerful approach for the simple reason that it's the only way to accomplish their goals without significant infrastructure development, of course
13:40:02 * dons waves to everyone
13:40:04 <leimy> geezusfreeek: which is?
13:40:09 <leimy> geezusfreeek: FRP?
13:40:13 <geezusfreeek> leimy, functional reactive programming, yes
13:40:18 <leimy> sweet
13:40:33 <conal> leimy: yeah.  FRP and other semantically simple alternatives to imperative programming.
13:40:35 <dons> shapr, i wonder if we're seeing a RWH surge in #haskell?
13:40:35 <leimy> Can FRP help one to avoid the problem of too much IO?
13:40:52 <leimy> i really need to learn more about FRP
13:40:54 <dons> heh, #haskell is bigger than #c today, for the first time.
13:41:08 <EvilTerran> woo!
13:41:15 <conal> leimy: if you'd like an intro to the flavor of FRP, see http://conal.net/fran/tutorial.htm
13:41:23 <lambdabot> Title: Composing Reactive Animations
13:41:25 <Philippa> leimy: in that the "do" bit can become "run this FRP system hooked up to this IO here", yeah
13:41:34 <dino-> Oh hey, I had no idea that RWH was going to be sold in PDF and epub form. So, even though we pre-purchased from Amazon months ago, I bought the ebook from O'R as well. yay
13:41:43 <dons> woo!
13:41:53 <dons> yeah, there's 3 different digital versions that come in a bundle
13:41:57 <dons> epub, et al
13:42:04 <dino-> Looks sharp on the Sony eink reader
13:42:11 <leimy> conal: thank you
13:42:12 <dons> i'd love to see a photo!
13:42:12 <monadwr> What does `compare` return, when evaluating expressions?
13:42:18 <vixey> :t compare
13:42:19 <geezusfreeek> leimy, frp is all about declaring a program's behavior as opposed to a program telling the computer what to do, although i suppose that description will make little sense until you learn a bit more of the specifics
13:42:20 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:42:23 <conal> leimy: :)
13:42:23 <mauke> @src Ordering
13:42:24 <lambdabot> data Ordering = LT | EQ | GT
13:42:24 <vixey> an Ordering
13:42:24 <Philippa> FWIW, I do actually quite like FRP in a "wish it were more ready for practical use in the stuff I do" kind of way. And many of the things I'd find missing doing it in Haskell right now aren't FRP's fault at all (extensible records and variants!)
13:42:34 <leimy> geezusfreeek: so like chaining event handlers?
13:42:40 <geezusfreeek> leimy, it's kind of the difference between imperative programs and pure functional programs in general
13:42:54 <dino-> dons: photo? I can do that later
13:43:07 <dons> yeah. would be nice to see it in the wild :)
13:43:19 <geezusfreeek> in haskell we don't worry about setting the state of memory, etc. in frp, we don't worry about setting the state of RealWorld, etc.
13:43:36 <dons> that's a nice way of putting it, geezusfreeek
13:43:46 <leimy> geezusfreeek: Hmmm
13:43:53 <leimy> geezusfreeek: sounds a bit like "interact"
13:43:57 <orbitz> what is FRP?
13:44:00 <geezusfreeek> leimy, exactly!
13:44:07 <Philippa> leimy: it's a lot like a really generalised version of interact, yeah
13:44:10 <leimy> geezusfreeek: wow, I understood something.
13:44:23 <leimy> I'm going back to bed before I fuck up the rest of the day
13:44:23 <geezusfreeek> frp is supposed to be like interact, but more composable and general
13:44:30 <Philippa> only interact doesn't really have a sensible notion of 'time', whereas FRP does
13:44:38 <Philippa> so things like waiting behaviours are much easier
13:44:59 <leimy> I found myself maybe wanting a "Sleep" in Haskell the other day
13:45:06 <leimy> without digging around in thread-like stuff
13:45:19 <geezusfreeek> Philippa, i don't really think an explicit notion of time in frp is necessary
13:45:26 <dino-> Saizan, quicksilver, etc.: If you're around, this is what I finally boiled this problem down to. Fantastically clean, IMO. http://hpaste.org/12217#a1
13:45:28 <vixey> you can have unsafeCatnap
13:45:44 <leimy> vixey: FFI out to C and call sleep :-)
13:45:45 <pumpkin_> i can haz unsafeCatnap?
13:45:52 <geezusfreeek> although such a notion can certainly be useful in describing semantics
13:46:38 <Philippa> geezusfreeek: AIUI (though I might be wrong), there's going to be at least /some/ notion of it - but it's not necessarily going to bear much resemblance to wall clock time. For some tasks you want it to, of course
13:47:28 <vixey> @let let unsafeCatnap = unsafePerformIO . threadDelay
13:47:29 <lambdabot>   Parse error
13:47:32 <vixey> @let unsafeCatnap = unsafePerformIO . threadDelay
13:47:32 <lambdabot>  <local>:22:15: Not in scope: `unsafePerformIO'
13:47:32 <lambdabot>  
13:47:32 <lambdabot>  <local>:22:33: Not in scop...
13:47:39 <geezusfreeek> okay, i'll grant that a notion of relative time is probably more useful than of absolute time
13:47:39 <vixey> no luck here then
13:48:08 <leimy> another bright note is I did get my bowling score thing going
13:48:11 <vixey> I don't think a notion of absolute time exists does it?
13:48:14 <leimy> via ContT
13:48:22 <leimy> and some divide and conquer
13:48:29 <pumpkin_> vixey: since God created the universe 6000 years ago
13:48:42 <pumpkin_> clearly there is absolute time ;)
13:48:43 <orbitz> 6012 as of Oct 23rd
13:48:45 <leimy> but it's not really "computing" the score live.... however it does handle the question of how many balls are thrown in any game of bowling.
13:48:45 <vixey> pumpkin_, relative to when God did what?
13:48:53 <Philippa> pumpkin_: actually that was me when I was asleep last night
13:49:04 <travisbrady> anybody have any pointers as to how to fix this error: http://hpaste.org/12227
13:49:06 <geezusfreeek> vixey, i meant relative as in one event relative to another rather than relative to calendar time
13:49:16 <dino-> dons: So, yes, cool idea. I will photograph later
13:49:22 <vixey> leimy, How the hell do they explain bowling scoring to _people_?
13:49:33 <leimy> I don't know
13:49:40 <leimy> It took me a really long time to get it.
13:49:44 <vixey> geezusfreeek, ok I see
13:49:49 <leimy> basically the minimum balls thrown is 12
13:49:54 <leimy> Oh no it isn't
13:49:55 <leimy> it's 11 :-)
13:50:09 <leimy> that's 9 frames of strikes and then not striking or sparing on the 10th frame
13:50:21 <vixey> I'm already lost
13:50:32 <Cale> travisbrady: fromIntegral
13:50:45 <leimy> the first 9 frames can each have up to 2 balls :-)
13:50:48 <Cale> travisbrady: To turn the Int into something like Double.
13:50:57 <leimy> but if the first is a strike, the frame ends early
13:51:05 <leimy> Continuations seemed a good choice here.
13:51:06 <Philippa> leimy: compositionality is your friend. Group the frames up /first/
13:51:15 <leimy> I did :-)
13:51:17 <travisbrady> Cale: ok, i'll toss that in somewhere, btw, full code is here: http://hpaste.org/12227#a1
13:51:21 <leimy> I have a frameGetter
13:51:23 <yrlnry> Okay, I just realized that when you make (->) a  into a monad, the unit and compose functions are the K and S combinators.  That can't be a coincidence.
13:51:38 <Cale> travisbrady: Yeah, I'll have to look at more of the code to really tell :)
13:51:57 <Cale> travisbrady: But basically, it's saying that you're using operations on an Int which aren't available for Ints
13:51:58 <vixey> :t (>>= return)
13:51:59 <leimy> http://hpaste.org/12228
13:51:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
13:52:11 <Cale> (things like sqrt, for instance)
13:52:19 <Peaker> @hoogle interact
13:52:20 <lambdabot> Prelude interact :: (String -> String) -> IO ()
13:52:20 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
13:52:20 <lambdabot> System.IO interact :: (String -> String) -> IO ()
13:53:03 <Peaker> seems useless :)
13:53:14 <leimy> it's awesome :-)
13:53:24 <leimy> I've used it on a few programs here and there.
13:53:31 <EvilTerran> yrlnry, there's probably some deep category-theoretic reason for it
13:53:32 <Peaker> what can you do with a (String -> String)?
13:53:35 <vixey> Peaker, the unix in haskell stuff is good example of it
13:53:48 <leimy> vixey: indeed
13:53:52 <mauke> yrlnry: isn't compose = flip S? I've always used 'ap' as S
13:54:00 <Peaker> how does Unix use it? How can you accumulate state or anything?
13:54:07 <vixey> Peaker, look it up
13:54:07 <EvilTerran> Peaker: grep, awk, sed, etcetc
13:54:12 <monadwr> mauke: I'm just wondering, because for "ASDF" `compare` "A" returns LF, and "A" `compare` "ASDF" returns LF.
13:54:18 <vixey> it's really cool
13:54:24 <mauke> what's LF?
13:54:45 <mauke> > (compare "ASDF" "A", compare "A" "ASDF")
13:54:46 <lambdabot>   (GT,LT)
13:54:51 <EvilTerran> Peaker, they're all effectively String -> String, modulo parsing the command line (which i guess you do outside the interact call)
13:54:55 <monadwr> mauke: LT*
13:55:01 <leimy> (String -> String) and judicious use of a state monad + execState == neat :)
13:55:04 <yrlnry> mauke: the order of the arguments isn't really important.
13:55:10 <Deewiant> > (compare (0/0) 1, compare 1 (0/0))
13:55:12 <lambdabot>   (GT,GT)
13:55:20 <monadwr> Yeah, I expected GT/LT. But I'm not getting that here.
13:55:33 <monadwr> My computer must be defective.
13:55:52 <EvilTerran> yrlnry, i think ap is usually cites as being S instead of >>= as S because ap is actually more basic than >>= in some respects
13:55:56 <monadwr> Prelude> "ASDF" `compare` "A"
13:55:59 <EvilTerran> *usually cited
13:56:04 <monadwr> LT
13:56:04 <monadwr> Prelude> "A" `compare` "ASDF"
13:56:04 <monadwr> LT
13:56:24 <yrlnry> @pl \x y z -> x z (y z)
13:56:24 <lambdabot> ap
13:56:34 <yrlnry> That's S, dude.
13:56:41 <Deewiant> monadwr: what does ':i compare' say
13:56:45 <EvilTerran> yrlnry, in that you can have structures that have ap (actually Control.Applicative.<*>) but no valid >>=
13:56:53 <orbitz> monadwr: i get LT and GT on mine
13:57:29 <monadwr> orbitz: I get LT/GT on opensolaris in virtualbox as well; but not here.
13:57:41 <orbitz> monadwr: redefine compare somewhere by accident?
13:58:09 <monadwr> orbitz: Hm, no -- class (Eq a) => Ord a where compare :: a -> a -> Ordering
13:58:20 <monadwr> Looks _right_
13:58:34 <monadwr> How peculiar.
13:58:38 <orbitz> the type does but that doesn't mean you didn't rebind it somewhere does it?
13:58:56 <orbitz> i mean, completely clean ghci instance?
13:59:24 <monadwr> orbitz: Well, it's fairly clean; I've only used it to test functions out.
14:00:17 <monadwr> orbitz: I'll rm -rf .ghc/ and re-test. Hold.
14:01:07 <monadwr> Bizarre: Prelude> "ASDF" `compare` "A"
14:01:14 <monadwr> GT
14:01:14 <monadwr> Prelude> "A" `compare` "ASDF"
14:01:14 <monadwr> LT
14:01:25 <monadwr> I wonder what caused this.
14:01:32 <monadwr> Ah, well.
14:01:57 <idnar> @type ap
14:01:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:02:00 <idnar> @type (<*>)
14:02:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:02:12 <monadwr> I wonder why modifying my package.conf in .ghc/ would fix it up though.
14:02:23 <idnar> @type (*>)
14:02:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
14:02:39 <idnar> @pl flip ap
14:02:39 <lambdabot> flip ap
14:02:44 <idnar> mmph
14:03:02 <surgeon> hi all, I am reading floating point number from a file and now I stored them in [[line]] where one sublist is a list of floating point numbers in one line of the file; now I have a random number of columns in this file, so one time it can be 3 columns, one just 2 oder 7 columns
14:03:44 <surgeon> but mostly there'll be a time, when I want a list of pairs, where two of these columns are combined, how do I most efficiently achieve that?
14:04:02 <monadwr> orbitz: Does the package.conf store anything but paths and cabal information?
14:04:13 <dibblego> surgeon, zip?
14:04:25 <monadwr> Would `compare` have bindings pointing towards it? I should've kept that to find out what it was.
14:04:36 <surgeon> so e.g. one line of the file is: "2.3 45.2 1.1" which yields [[2.3,45.2,1.1],...], but now I want for example [(45.2,2.3),....]
14:04:52 <surgeon> dibblego: isn't that just for a limited number of values?
14:05:10 <dibblego> zip x (tail x) ?
14:06:02 <monadwr> Unless the operands were wrong; but they weren't.
14:08:15 <surgeon> dibblego: problem is, I have to take two elements out of a line and I just have sublists for each line, how can I selected a special member of a list?
14:08:47 <surgeon> dibblego: hmm I guess I am not describing the problem very well
14:09:04 <monadwr> orbitz: Has anything like this happened to you?
14:09:55 <monadwr> Eh.
14:10:03 * monadwr wanders back into his book.
14:15:10 <orbitz> monadwr: it has not, i'm quite new though
14:15:43 <monadwr> Ah.
14:16:24 <sbahra> yow orbitz
14:16:46 <sbahra> orbitz, joined the dark side? :-P
14:16:46 <EvilTerran> @yow?
14:16:47 <lambdabot> This ASEXUAL PIG really BOILS my BLOOD ... He's so ... so ... URGENT!!
14:16:58 <orbitz> sbahra: i've been here for years :)
14:17:20 <leimy> So the Fran tutorial page looks pretty cool.
14:17:30 <leimy> but some of it seems like magic hand waving still :-
14:17:42 <vixey> leimy, I think Fran is real
14:17:51 <leimy> I know it is, or was :-
14:17:55 <leimy> _
14:18:00 <leimy> dang, can't type
14:18:19 <leimy> In fact I believe one of my haskell tutorials has a chapter on it
14:20:19 <British0zzy> sorry, i'm new to haskell, is there anyway to have pattern matching only happen at compile time?
14:20:33 <mauke> o_O
14:20:54 <Cale> British0zzy: It's not clear to me what that would mean.
14:21:00 <vixey> BritishOzzy, I think not, but why do you want to (maybe there is some alternative)
14:21:52 <geezusfreeek> what do you mean? as an optimization?
14:22:06 <British0zzy> i was wondering if i could use pattern matching for optimizations, but having it do the pattern matching at run-time would be a waste
14:22:20 <vixey> what optimization?
14:22:35 <geezusfreeek> could you give a specific example of what you are trying to optimize?
14:22:36 <sjanssen> British0zzy: you could use Template Haskell
14:23:00 <vixey> is using template haskell to unroll a loop going to make the program faster?
14:23:22 * Nafai takes a look at Scion
14:23:31 <ddarius> I'm pretty confident known cases are optimized (seeing as that would be trivial to do)
14:23:48 <sjanssen> ddarius: yes, they are
14:24:00 <sjanssen> you just need to arrange that the case is known
14:24:28 <Nafai> Darn, it requires 6.10.1
14:24:34 <British0zzy> template haskell might be what i need
14:24:43 <British0zzy> i'll try it out. thanks
14:25:07 <sjanssen> British0zzy: TH is pretty drastic, I'd recommend other approaches first
14:25:29 * geezusfreeek still doesn't understand what these optimizations are supposed to do
14:27:13 <EvilTerran> British0zzy, careful to avoid premature optimisation there; your code might be fast enough anyway
14:29:33 <sbahra> orbitz, oh
14:29:41 <British0zzy> i want to optimize certain matrix multiplications
14:30:14 <sbahra> British0zzy, talk to mmorrow about MMX/SSE2-optimized computational library for haskell :-P
14:30:18 <pumpkin_> sparse matrices anyone?
14:30:25 <British0zzy> some can happen at compile time, but i don't want it to try and pattern match these optimizations at run-time
14:30:48 <Lemmih> British0zzy: Pattern matching is very cheap.
14:31:20 <British0zzy> i should probably read up more on pattern matching
14:31:31 <vixey> BritishOzzy, {-# RULES #-} may do it?
14:32:10 <Lemmih> British0zzy: In all likelihood, you won't be able to measure the time it takes to do a pattern match.
14:32:34 <EvilTerran> British0zzy, http://c2.com/cgi/wiki?PrematureOptimization
14:32:40 <lambdabot> Title: Premature Optimization
14:32:51 <vixey> what about a million pattern matches though?
14:33:35 <EvilTerran> vixey, you'd still better profile before you optimise
14:33:50 <vixey> I'm not the one doing optimizations
14:34:25 <EvilTerran> s/you/one/, then :P
14:34:25 <pumpkin_> is there a profiler for haskell that's does something simialr to the hpc html output?
14:34:35 <pumpkin_> colors certain things brighter if they get called more?
14:34:49 <Lemmih> vixey: It's almost free if the structure will eventually be used.
14:35:04 <EvilTerran> pumpkin_, it'd certainly be possible to build such a thing around an existing profiler
14:35:13 <pumpkin_> mmm
14:35:17 <pumpkin_> I love the HPC output
14:35:22 <pumpkin_> I want purty heatmaps on code
14:35:29 <pumpkin_> :P
14:35:51 <Lemmih> vixey: jhc's typechecker does about 900,000,000 pattern matches per second.
14:36:49 <pumpkin_> on any computer?
14:36:51 <Lemmih> vixey: There are many situations where GHC isn't great but pattern matches aren't one of them.
14:37:48 <Lemmih> I've found that strict cases usually generates better code than you would write by hand.
14:38:39 <newsham> you know, i bet an air traffic control game would work well as FRP
14:40:33 <EvilTerran> newsham, s/game/simulator/, and you've got yourself a paper :P
14:41:00 <newsham> i'm not a paper generator
14:43:01 <capitrane> is there any libraries for image handling and image processing?
14:43:34 <capitrane> found nothing intresting on google
14:43:58 <geezusfreeek> capitrane, the best response to most questions asking about libraries is a snarky answer with a link to hackage.haskell.org ;)
14:44:34 <geezusfreeek> there are some. check gd, for example
14:45:37 <geezusfreeek> actually, probably not such a great suggestion for general image processing
14:45:41 <geezusfreeek> sorry about that
14:47:08 <surgeon> I need help with a parsec parser: I am executing a parserTest function in a do block in my main routine and the parser works great. but when I now pipe its output in a variable like "data <- parseTest ..." it gets an () at the end, why that?
14:47:10 <geezusfreeek> huh, i actually can't seem to find one that looks great for for processing
14:47:57 <Cale> :t parseTest
14:47:59 <lambdabot> Not in scope: `parseTest'
14:48:06 <Cale> :t Text.Parsec.parseTest
14:48:07 <lambdabot> Couldn't find qualified module.
14:48:10 <Cale> hm
14:48:19 <byorgey> :t Text.ParserCombinators.Parsec.parseTest
14:48:20 <lambdabot> forall tok a. (Show a) => Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> [tok] -> IO ()
14:48:30 <Cale> ah, it is in IO.
14:48:37 <byorgey> that's why, its return type is IO ()   =)
14:48:50 <byorgey> parseTest is just designed to print the result of the parse to the screen
14:49:06 <byorgey> if you actually want to get the result of the parse, use the 'parse' function instead of 'parseTest'
14:49:14 <byorgey> :t Text.ParserCombinators.Parsec.parse
14:49:15 <lambdabot> forall tok a. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
14:49:59 <surgeon> byorgey: thanks!
14:50:00 <byorgey> something like    case parse myParser "source name" "thing to be parsed" of  Left err -> ...   Right parsedThing -> ...
14:50:14 <capitrane> geezusfreeek: no, haskell is proberbly not the first hand choice. but i thought i would be fun.. but surpriseingly i couldnt find anything about it
14:50:44 <geezusfreeek> capitrane, haskell would be pretty good for it, really
14:50:56 <geezusfreeek> i'm very surprised at the small selection there
14:51:02 <capitrane> me to
14:51:28 <geezusfreeek> there are plenty of low-level libraries
14:51:29 <capitrane> virtually every thing else is there, but no image processing
14:51:37 <geezusfreeek> not really any high level ones
14:51:38 <geezusfreeek> yeah
14:51:50 <geezusfreeek> well, middle-level or so
14:53:15 <capitrane> maybe i should write a small library instead of process images (small school project)
14:53:37 <geezusfreeek> sounds fun!
14:54:18 <geezusfreeek> conal, you have done a lot with graphics in haskell, do you know of anything that might be of use to capitrane?
14:56:43 <conal> geezusfreeek: i don't know of anything offhand
14:57:20 <capitrane> thanks anyway conal
14:58:37 <conal> capitrane: good luck
14:58:39 <EvilTerran> capitrane, have you looked through http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Graphics ?
14:58:45 <lambdabot> Title: HackageDB: packages by category, http://tinyurl.com/yqov7f
14:59:11 <geezusfreeek> EvilTerran, there seems to be nothing that offers much as far is image processing though :(
14:59:41 <EvilTerran> yeah, last i checked, you couldn't really do much with the imagemagick and GD bindings
14:59:45 <geezusfreeek> we have libraries to compose graphics and to open files and save them, a few basic conversions, but no real processing
15:00:19 <EvilTerran> tempted to look into making more complete bindings for something sometime
15:00:37 <EvilTerran> i looked at allegro, 'cos i learnt that to make learning c more interesting
15:01:01 <mlesniak> beginner question: I'm playing with xosd's haskell bindings and using ghci the example works, but how do I compile it into an executable? using just ghc example.hs -o example returns errors about undefined refernces in snw_info (which is strange because it works in ghci)
15:01:14 <EvilTerran> but i ran into limitations of the current c-header-to-haskell binding tools
15:01:48 <EvilTerran> the killer being allegro's use of en un-named enum for a particular batch of constants
15:02:39 <EvilTerran> and there being no way of getting a list of all the elements of an unnamed enum with c2hs or hsc2hs
15:02:44 <Cale> http://www.smbc-comics.com/index.php?db=comics&id=575#comic
15:02:50 <lambdabot> Title: Saturday Morning Breakfast Cereal
15:04:36 <lunabot>  luna: lexical error in string/character literal at end of input
15:10:24 <hml> what's the function to take a list  of commands and run them
15:10:26 <FunctorSalad> hmm I asked this the other day but we weren't sure... is there a valid syntax for this concept? "class (forall x. c x) => Foo c where ..."
15:10:35 <Cale> hml: sequence ?
15:10:48 <Cale> hml: sequence :: [IO a] -> IO [a]
15:11:06 <hackage> Uploaded to hackage: peano-inf 0.6
15:11:14 <hml> Cale: after sequence_; but yeah, sequence; thanks :-)
15:11:59 <Cale> FunctorSalad: I'm not sure I understand which concept you're after...
15:12:15 <twanvl> FunctorSalad: what does (c x) => .. even mean? Is c a type constructor or a class?
15:12:16 <Saizan> FunctorSalad: you forgot a class
15:12:27 <FunctorSalad> c is of kind * -> *
15:12:55 <FunctorSalad> c can only be a Foo if for all x, Bar (c x) (thanks Saizan)
15:12:55 <Saizan> you probably want class forall x. Bar (c x) => Foo x
15:12:59 <geezusfreeek> what is the difference between that and class Foo c where...?
15:13:16 <Saizan> (the last being a c..)
15:13:19 <geezusfreeek> ah i see
15:13:20 <FunctorSalad> yes, without the Foo it was slightly confusing ;)
15:14:51 <FunctorSalad> practical example, "class (forall a b. Iso (cat a b)) => Groupoid cat"
15:14:55 <twanvl> So you want QuantifiedContexts, http://haskell.org/haskellwiki/Quantified_contexts
15:14:57 <lambdabot> Title: Quantified contexts - HaskellWiki
15:15:17 <surgeon> :t runParser
15:15:18 <lambdabot> Not in scope: `runParser'
15:15:32 <surgeon> :t Text.ParserCombinators.Parsec.runParser
15:15:33 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> st -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError
15:15:33 <lambdabot> a
15:16:28 <FunctorSalad> twanvl: exactly
15:17:26 <shapr> @users
15:17:26 <lambdabot> Maximum users seen in #haskell: 566, currently: 536 (94.7%), active: 19 (3.5%)
15:17:29 <shapr> wow
15:17:32 <shapr> dons: Entirely possible
15:18:06 <twanvl> FunctorSalad: I want them too :)
15:19:47 <FunctorSalad> any workarounds? I guess not
15:21:15 <FunctorSalad> my Iso class is a bit dubious anyway. it would mean that *all* morphisms from a to b are isos
15:21:28 <vixey> FunctorSalad, put a code repo online :p
15:23:58 <Saizan> FunctorSalad: class Iso2 (arr :: * -> * -> *) ?
15:25:11 <FunctorSalad> Saizan: yes, but that's just the groupoid clas
15:25:13 <FunctorSalad> class
15:26:52 <FunctorSalad> vixey: I should work on it some more first
15:30:03 <vixey> FunctorSalad, no you shouldn't
15:42:32 <erikc> sigh, well that just ticks me off, gcc doesnt perform an inlining pass after devirtualizing calls through pointers
15:57:21 <hml> is there a function for concatenating two lists?
15:57:29 <vixey> yes
15:57:33 <ddarius> :t (++)
15:57:34 <lambdabot> forall a. [a] -> [a] -> [a]
15:57:42 <hml> > [1, 2, 3] ++ [3, 4, 5]
15:57:43 <lambdabot>   [1,2,3,3,4,5]
16:01:58 <dons> ?hoogle [a] -> [a] -> [a]
16:01:58 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
16:01:58 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
16:01:58 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:04:36 <Vulpyne> With haddock, is there a way to document each pattern match of a function?
16:05:57 <Saizan> if you mean different cases no
16:06:04 <Saizan> if you mean each argument yes
16:06:13 <Vulpyne> I meant cases. I RTFMed and it didn't seem possible. :(
16:06:25 <Vulpyne> I guess wanting to do that could indicate that refactoring is in order.
16:06:40 <Saizan> haddock is for API doc, not implementation
16:06:54 <Vulpyne> Guess that makes sense.
16:10:03 <milton13> well howdy, how do i pattern match a list of tuples [(3,3),(3,4)], is it like this: [(x,y):(xs,ys)]??
16:10:57 <alexeld> Is there something deviant I should know about "a + b"? It *seems* simple, but I'm getting (a, b). Does anyone know how I can force it to add, not build a tuple?
16:11:06 <hackage> Uploaded to hackage: hsc3-dot 0.6
16:11:06 <hackage> Uploaded to hackage: lhc 20081121
16:11:06 <hackage> Uploaded to hackage: hsc3-unsafe 0.6
16:11:06 <hackage> Uploaded to hackage: hsc3 0.6
16:11:06 <hackage> Uploaded to hackage: hosc 0.6
16:12:03 <Saizan> > 3 + 4
16:12:04 <lambdabot>   7
16:12:25 <Saizan> alexeld: one of your 'a' or 'b' is a tuple for other reasons, probably
16:12:41 <alexeld> Possibly because I'm doing (a:x).
16:13:00 <alexeld> I'll have hacking at it. Thanks Saizan.
16:13:01 <dons> dcoutts_: know any easy fix to http://hackage.haskell.org/packages/archive/Takusen/0.8.3/logs/failure/ghc-6.10 ?
16:13:07 <lambdabot> http://tinyurl.com/6endvk
16:13:12 <alexeld> %s/have/keep/g
16:14:15 <Lemmih> dons: The LHC Haskell Compiler is out. World domination is one step closer.
16:14:18 <dons> Lemmih: i see what you did.
16:14:23 <dons> i was about to say!
16:14:26 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lhc-20081121
16:14:28 <lambdabot> Title: HackageDB: lhc-20081121, http://tinyurl.com/5n22ml
16:14:37 <dons> Lemmih's Haskell Compiler!
16:15:18 <profmakx> does it make black holes?
16:15:43 <dons> Lemmih++ LHC is the best name
16:16:42 <Vulpyne> Is it related to Jhc?
16:17:12 <Lemmih> profmakx: Yes. It sucks in memory and radiates occasional bursts of code.
16:17:44 <dons> hehe
16:17:58 * profmakx will have a look
16:17:58 <dons> Lemmih: so you had to fork?
16:18:00 <Lemmih> Vulpyne: It's a fork of Jhc.
16:18:01 <profmakx> i cannot sleep
16:18:06 <Vulpyne> Ah, I see.
16:18:07 <Lemmih> dons: I did )-:
16:18:14 <dons> over cabalisation?
16:18:43 <Lemmih> The guy really loath Cabal.
16:18:47 <dons> sigh. oh well, less than a handful of projects like that.
16:19:39 <Lemmih> Now to fix cabal-install.
16:19:53 <profmakx> how on earth would anyone not love cabal?
16:21:26 <Lemmih> Some people seem to have a masochistic fondness of makefiles.
16:21:44 <dons> heh
16:21:47 <dons> older projects
16:21:56 <Vulpyne> Hmm, it doesn't seem to compile when I do "./Setup build".
16:22:17 <Lemmih> Vulpyne: Anything I can fix?
16:22:38 <Vulpyne> No actual error, it just says "Preprocessing executables for lhc-20081121..." and then "Processing: src/C/FFI.hs"
16:22:42 <Saizan> does it check if i have DrIFT or simply dies?
16:22:45 <Vulpyne> And then it exits with no further output.
16:23:04 <Saizan> i guess the latter..
16:23:07 <Lemmih> Saizan: The DrIFT support is an ugly hack.
16:23:24 <Saizan> i'm having the same problem as Vulpyne
16:24:08 <Saizan> ok, after cabal install drift the build proceeds
16:24:19 <Vulpyne> Yeah, I just figured that out too after I did build -v
16:24:34 <Vulpyne> DrIFT sure prints a lot of warnings!
16:26:06 <Lemmih> Keep in mind that lhc doesn't ship with any libraries. Not even 'base'. You won't be able to compile anything at all.
16:26:53 <Vulpyne> Oh well, I'm just killing time before I leave work. :)
16:27:18 <Lemmih> dcoutts: Do you think anything will break if I upload 'base-1.0' to hackage?
16:29:03 <hml> how do I make: map + [1, 2, 3, 4] work?
16:29:20 <Vulpyne> map (+) [1,2,3,4]
16:29:21 <Lemmih> > map (+10) [1,2,3,4]
16:29:23 <lambdabot>   [11,12,13,14]
16:29:26 <Vulpyne> Er, yeah.
16:29:52 <hml> > map (+) [1, 2, 3, 4]
16:29:53 <lambdabot>       Overlapping instances for Show (a -> a)
16:29:53 <lambdabot>        arising from a use of `s...
16:29:57 <hml> ... doesn't work
16:30:09 <dons> Lemmih: sounds scary
16:30:12 <dons> i wouldn't do that.
16:30:13 <Vulpyne> Yeah, because + requires two arguments and map applies it to each.
16:30:22 <dons> Lemmih: a different package probably makes sense
16:30:30 <hml> err, so some type of reduction?
16:30:33 <hml> fold?
16:30:37 <hml> > fold (+) [1, 2, 3, 4]
16:30:38 <lambdabot>   Not in scope: `fold'
16:30:42 <hml> > foldl (+) [1, 2, 3, 4]
16:30:43 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
16:30:43 <lambdabot>        arising from a use...
16:30:48 <Vulpyne> Yeah, you'd want a fold if you want it to act like 1+(2+(3+(4)))
16:30:57 <hml> > foldr (+) [1, 2, 3, 4]
16:30:57 <Saizan> > foldl1 (+) [1,2,3,4]
16:30:58 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
16:30:58 <lambdabot>        arising from a use...
16:30:58 <lambdabot>   10
16:31:03 <hml> > fold1 (+) [1, 2, 3, 4]
16:31:04 <lambdabot>   Not in scope: `fold1'
16:31:04 <Lemmih> dons: Then I can't use, say, 'directory'. All packages depend on 'base'.
16:31:12 <hml> >foldl1 (+) [1, 2, 3, 4]
16:31:21 <hml> > foldl1 (+) [1, 2, 3, 4]
16:31:22 <lambdabot>   10
16:31:23 <Lemmih> dons: Cabal-install filters out all 'base' packages.
16:31:24 <dons> why do you need base 1?
16:31:38 <dons> oh, for building things /with/ jhc?
16:31:44 <dons> via cabal-install?
16:31:46 <Lemmih> dons: Yeps.
16:31:53 <dons> right. interesting.
16:31:57 <dons> coordinate with dcoutts
16:33:26 <mcnster> hi.  q: i have a fn that { h <- FileOpen "foo"; s <- hGetContents; and lets p = happyParse s } ... and i want to hClose the file after parsing.  how can i do this?
16:34:26 <Saizan> mcnster: you've to consume all the parse result first
16:35:45 <mcnster> Saizan, i was hopeing i could put the parser in the IO monad somehow...?
16:36:52 <mcnster> Saizan, maybe i'm dreaming...
16:38:36 <Saizan> mcnster: that wouldn't help, if the file is not too long an easy solution is to read the content strictly
16:39:38 <Saizan> mcnster: like do { h <- openFile "foo"; s <- hGetContents h; length s `seq` return (); hClose h; ... }
16:40:28 <mcnster> Saizan, the parse result is a Map that i need to work with in its entirety, so strict is fine
16:41:57 <mcnster> Saizan, the "length s `seq` return s" does the trick perfectly, thank you! :)
16:42:59 <mcnster> return () rather
16:43:25 <davidL> @seen grahamhutton
16:43:25 <lambdabot> I saw grahamhutton leaving #haskell 2d 31m 11s ago, and .
16:44:57 <roconnor> > let isFinite = foldr const mempty in isFinite [0..4]
16:44:58 <lambdabot>   Add a type signature
16:45:17 <roconnor> > let {isFinite :: [a] -> (); isFinite = foldr const mempty} in isFinite [0..4]
16:45:18 <lambdabot>   Couldn't match expected type `()' against inferred type `a'
16:45:31 <roconnor> > let {isFinite :: [a] -> (); isFinite = foldr (flip const) mempty} in isFinite [0..4]
16:45:32 <lambdabot>   ()
16:45:41 <roconnor> > let isFinite = foldr (flip const) mempty in isFinite [0..4]
16:45:43 <lambdabot>   ()
16:45:49 <roconnor> > let isFinite = foldr (flip const) mempty in isFinite [0..]
16:46:14 <lambdabot>   thread killed
16:47:05 <roconnor> return (foldr (flip const) () s) === length s `seq` return () ?
16:47:56 <necroforest> Dear #haskellers: I'm trying to decide whether to take Neural networks or Cryptology next semester. Any opinions?
16:48:13 <Botje> neurocryptology!
16:48:40 <dolio> They're both cool.
16:48:43 <necroforest> thanks. that was very helpful
16:48:51 <Saizan> roconnor: no, returning a value doesn't force it
16:49:33 <roconnor> return $! (foldr (flip const) () s) === length s `seq` return () ?
16:49:35 <Botje> i think cryptology is more interesting
16:49:55 <dolio> I'd probably go with cryptology, too.
16:50:21 <Saizan> roconnor: yes
16:50:27 <roconnor> :)
16:55:21 <Lemmih> Igloo: ping.
16:55:51 <Igloo> yo
16:56:58 <Lemmih> Igloo: old-time and directory seems to be borked on hackage.
16:58:01 <Igloo> In what way?
16:58:13 <procyon112> Does ~/.cabal/config expand environment variables when parsed? (not the built in ones, of course, various others, like $HOME)
16:59:01 <Lemmih> Igloo: They don't compile with ghc-6.10 (or lhc). Looks like a cabalisation issue.
16:59:30 <dolio> @poll-add course
16:59:30 <lambdabot> Added new poll: "course"
16:59:42 <dolio> @choice-add course neural-networks
16:59:42 <lambdabot> New candidate "neural-networks", added to poll "course".
16:59:53 <dolio> @choice-add course cryptology
16:59:53 <lambdabot> New candidate "cryptology", added to poll "course".
16:59:57 <roconnor> neural networks have projects that are more fun
17:00:16 <roconnor> crypto projects are like: design a crypto system
17:00:28 <roconnor> and then: break your neighbours crypto system
17:01:07 <roconnor> @vote  course neural-networks
17:01:09 <lambdabot> voted on "neural-networks"
17:01:26 <dolio> @vote course cryptology
17:01:28 <lambdabot> voted on "cryptology"
17:01:41 <dolio> @poll-show course
17:01:41 <lambdabot> ["cryptology","neural-networks"]
17:01:54 <dolio> @poll-result course
17:01:54 <lambdabot> Poll results for course (Open): cryptology=1, neural-networks=1
17:02:09 <Raevel_> @vote cryptology
17:02:09 <lambdabot> usage: @vote <poll> <choice>
17:02:13 <Raevel_> noo!!
17:02:23 <pumpkin_> @vote course cryptology
17:02:25 <lambdabot> voted on "cryptology"
17:02:30 <Raevel_> @vote course cryptology
17:02:30 <lambdabot> voted on "cryptology"
17:02:33 <roconnor> @poll caleskell
17:02:33 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
17:02:38 <roconnor> @poll-show caleskell
17:02:38 <lambdabot> No such poll: "caleskell" Use @poll-list to see the available polls.
17:02:48 <dolio> course is the only poll in there.
17:02:50 <procyon112> @vote  course neural-networks
17:02:51 <lambdabot> voted on "neural-networks"
17:02:53 <dolio> @poll-list
17:02:54 <lambdabot> ["course"]
17:04:06 <BMeph> Does anyone know of a good (or fair) ttutorial or something like it, for explaining CPS (continuation-passing style)?
17:05:16 <roconnor> have you read the wiki pages?
17:05:50 <BMeph> roconnor: On haskell.org, or wikipedia? :)
17:06:11 <roconnor> haskell.org I was think
17:06:13 <roconnor> thinking
17:06:48 <roconnor> It was pretty good as I recall
17:07:00 <Apocalisp> What's a homomorphism in Haskell terms?
17:07:01 <roconnor> but I more or less understand CPS now, so it is hard for me to judge
17:07:12 <mikv> Hi!
17:07:34 <mikv> I am going to develop simple library in GHC
17:07:42 <mikv> Will it work with Hugs?
17:08:17 <roconnor> Apocalisp: usually it is a function of the form f :: (TypeClass a, TypeClass b) => a -> b, that "perserves" the operations of the TypeClass
17:08:36 <Cale_> mikv: It depends on what language extensions you use.
17:08:37 <BMeph> necroforest: 1) Do you plan on taking both eventually, or is this a "two roads in the forest"-type of decision? :)
17:08:42 <mikv> where can i read about difference between Hugs and GHC?
17:09:03 <roconnor> eg for the Monoid type class, it would be a function where f mempty == mempty and f (a `mappend` b) == f a `mappend` f b
17:09:14 <mikv> Cale, ? I am Haskell newbie :-)
17:09:14 <necroforest> BMeph, actually i probably will take both eventually...
17:09:39 <Apocalisp> roconnor, thanks a lot
17:09:52 <BMeph> roconnor: Have you ever heard of SAPL, and if so, does it seem like anything that other-than-Clean-programmers would want to study? :)
17:09:53 <pumpkin_> mikv: write me an interface to TAO and PETSc please :)
17:09:56 <pumpkin_> and maybe a GSL
17:10:11 <roconnor> BMeph: nope, and I don't really know Clean.
17:10:24 <Cale> mikv: I'm not sure of a perfect resource for that... but the GHC User's Guide lists the extensions that GHC supports, and I suspect the Hugs User's Guide would do the same.
17:11:07 <BMeph> necroforest: Hm, then why not do NN first, and use the Power of the Automata (pat. pend.) to help you tackle crypto? :)
17:11:23 <necroforest> lol
17:11:53 <Cale> mikv: But essentially, if you create a cabal package, and don't use language extensions, it should be installable for both GHC and Hugs.
17:12:08 <necroforest> well, i'm pretty sure i'm going to take NN.  I wasn't initially considering crypto, but its on the same day as the other class i'm signed up for so i have less driving :) (part time grad student)
17:12:25 <mikv> Cale, thanks
17:12:46 <mikv> Huh. I can not install Hugs in Ubuntu 8.10 from repos :-(
17:13:16 <Cale> mikv: And you certainly can't get the latest GHC that way either.
17:13:42 <mikv> Cale, actually i am disappointed with broken dependencies in Ubuntu
17:14:03 <mikv> Cale, but Debian lenny (my second desktop) installed it without problems..
17:14:06 <Cale> mikv: It's unfortunate, but the GHC and Ubuntu dev cycles are almost optimally out of sync. Ubuntu does a release and the new GHC comes out right after.
17:14:17 <necroforest> mikv, that's because debian > ubuntu ;)
17:14:30 <profmakx> arch wins
17:14:35 <Cale> mikv: Normally, I just install the generic linux binary which works fine.
17:14:43 <mikv> necroforest, afaik ubuntu is shot of debian testing
17:14:58 <mikv> Cale, where can i found precompiled binaries?
17:15:06 <mikv> Cale, i mean binaries for Hugs
17:16:15 <Cale> Oh, for hugs, you could probably compile it yourself with little trouble, supposing that you have a C compiler.
17:16:30 <mikv> huh.. Wine rocks :-)
17:16:52 <Apocalisp> roconnor, I had the vague notion that a homomorphism was an arrow, (Hom a b, Functor f) => (f a -> a) -> f b -> b
17:16:53 <Cale> Heh, you're running WinHugs in wine?
17:16:58 <mikv> yep
17:17:22 <Cale> mikv: What is the problem with installing hugs on ubuntu anyway?
17:18:14 <mikv> Cale, broken dependencies for libhugs-openal-bundled package
17:18:16 <roconnor> Apocalisp: could be.  The term may mean different things in different contexts.
17:18:42 <Cale> mikv: hmm... I didn't run into that, I'll try reinstalling.
17:19:28 <dolio> BMeph: It might help you in figuring out CPS to break it into direct style --> monadic style, and then monadic style -> CPS (since continuatino passing is a monad).
17:19:33 <dolio> Then again, it may not.
17:19:47 <Cale> mikv: Oh, I can't install libhugs-openal-bundled... but I don't need to in order to install hugs
17:20:19 <Apocalisp> OK, thanks. Gives me something to chew on.
17:22:11 <hml> should the following two lines always have the same semantic meaning?
17:22:16 <hml>       sequence_ $ foldl1 (++) [ [g x, h x] | x <- [0, 1, 2, 3]]
17:22:19 <hml>       sequence_ $ foldl1 (++) [ [g 0, h 0], [g 1, h 1], [g 2, h 2], [g 3, h 3]]
17:22:47 <dolio> Yes.
17:22:56 <hml> this is freaky, in xmonad it's not
17:23:05 <hml> so is this likely to be a compiler error?
17:23:16 <travisbrady> anyone know of an easy way to shuffle a list in Haskell ala python's random.shuffle?
17:23:37 <dolio> > [ [g x, h x] | x <- [0..3] ] :: [[Expr]]
17:23:40 <lambdabot>   [[g 0,h 0],[g 1,h 1],[g 2,h 2],[g 3,h 3]]
17:23:58 <Cale> hml: Are you certain? What is the problem you're running into?
17:24:38 <hml> Cale: it's with setting up workspaces, the line with I explicitly put out the 0, 1, 2, 3, results in a static setup;;; with the x <- [0, 1, 2, 3] method, i get an alternating response
17:24:42 <hml> (in xmonad)
17:24:50 <Cale> travisbrady: There's nothing in the libraries, but it's been written a number of times, I could perhaps dig one up for you.
17:24:55 <hml> for a while, I thoguht it was an xmonad problem, but the more I look into it, it seems like a weird haskell/xmonad interaction issue
17:25:19 <Cale> hmm
17:25:22 <travisbrady> Cale: googling yielded a few articles, something by Oleg
17:25:27 <askentask> any plans on adding shorthands for other datsastructures than lists?
17:25:36 <hml> Cale: give me 2 mins, brb
17:25:47 <askentask> any plans on adding shorthands for other datsastructures than lists?
17:26:12 <askentask> {"key": value} is pretty awesome
17:26:13 <Cale> askentask: Well, list comprehensions used to work with any monad.
17:27:06 <Cale> (and lots of us would like that to come back)
17:27:13 <hml> Cale: http://hpaste.org/12235#a0 <-- better explatination of error / weirdness
17:27:42 <roconnor> > (cos (2*pi/3),  cos (2*pi/3)::CReal)
17:27:44 <lambdabot>   (-0.4999999999999998,0.5)
17:28:21 <roconnor> Cale: I think the fix for cos :: CReal -> CReal isn't difficult
17:28:29 <Cale> hml: btw, foldl1 (++) is concat
17:28:40 <Cale> roconnor: I don't think it's likely to be hard either.
17:31:33 <Cale> travisbrady: A small problem is that the type is different from what you might expect. Either you need a random generator state to be passed in, or you need the thing to be in an appropriate monad (Rand or IO)
17:32:24 <Cale> travisbrady: Other than that, writing, say, a Knuth shuffle is not so hard.
17:32:46 <idnar> > concat []
17:32:47 <lambdabot>   []
17:33:00 <Cale> idnar: I'm aware ;)
17:33:12 <idnar> I was just checking for myself
17:33:20 <Cale> That use of the word 'is' was rather loose :)
17:33:40 <Cale> concat is actually foldr (++) []
17:33:41 <travisbrady> Cale: thank you, I'm reading this http://brett-hall.blogspot.com/2008/01/haskell-shuffling.html but I feel like i'd be caught in a Monad
17:33:42 <lambdabot> Title: placeholder: Haskell Shuffling
17:33:52 <idnar> indeed
17:34:01 <Cale> travisbrady: Well, a monad can make things simpler.
17:34:16 <Cale> travisbrady: Because you don't have to thread the state of the random generator along explicitly.
17:34:42 <Cale> Wow, those are some pretty elaborate implementations...
17:35:19 <Cale> Ah, it's an unusual algorithm?
17:35:36 <Cale> er...
17:36:23 <mikv> I am confused
17:36:26 <Cale> Oh, Fischer-Yates is just the usual one.
17:36:42 <Cale> s/Fischer/Fisher/
17:36:48 <mikv> consider i have SuperFile.hs
17:37:05 <mikv> with declared module in it. I want to load it into Prelude (ghci)
17:37:10 <mikv> How can i do that?
17:37:39 <Cale> mikv: hm?
17:37:44 <Cale> ghci SuperFile.hs
17:38:02 <travisbrady> Cale: this one is nice and short http://en.literateprograms.org/Special:Downloadcode/Fisher-Yates_shuffle_(Haskell)
17:38:03 <Cale> mikv: I'm not sure what you mean by "load it into Prelude"
17:38:08 <lambdabot> Title: Download code - LiteratePrograms, http://tinyurl.com/5o7aja
17:38:27 <mikv> Cale, i have ghci session
17:38:52 <Cale> mikv: :l SuperFile.hs
17:38:57 <mikv> mikv, thats "ghci SuperFile.hs" method doesn't fit
17:40:46 * sjanssen adds a letmegooglethatforyou.com plugin to lambdabot
17:50:28 <askentask> {"key": value} is pretty awesome
17:50:28 <askentask> {"key": value} is pretty awesome
17:50:28 <askentask> {"key": value} is pretty awesome
17:50:28 <askentask> {"key": value} is pretty awesome
17:50:28 <askentask> {"key": value} is pretty awesome
17:50:29 <askentask> {"key": value} is pretty awesome
17:50:31 <askentask> {"key": value} is pretty awesome
17:50:33 <askentask> wtf
17:50:35 <askentask> soorry
17:54:50 <yuuki> Hey guys!  I'm trying to show the equivalent of I = SKS in a hilbert-style proof.  I've shown that I = SKK.  Any insights into how something like this might be done?
17:57:31 <yuuki> In other words I am trying to show that p -> p in a way that is isomorphic to SKS rather than SKK
17:57:42 <EvilTerran> ?type ap const ap
17:57:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
17:58:38 <askentask> data Proof = Left | RIght, Right SKK .> SKS <<->> not in Left of xase Right -> ergo corgo sum
17:58:59 <Cale> wha?
17:58:59 <EvilTerran> what?
17:59:20 <monochrom> Sorry, "Left" and "Right" will have a name clash with the Prelude.
18:00:05 <yuuki> askentask, is that a Haskell program?
18:00:17 <EvilTerran> monochrom, did you bail on the first error there or something? :P
18:00:22 <monochrom> corgo is probably a dog breed.
18:00:40 <Cale> yuuki: Not a valid one.
18:01:52 <askentask> data Given = Axiom | Conjecture | Theorem deriving(Eq, Ord, Show); prove given with-function = case with-function of Axiom not in left of case Conjecture <<>> deriving Theorem, hence I = SKS
18:02:37 <yuuki> I can't tell if you're being sarcastic or not :)
18:02:38 <Saizan_> how does hilbert-style proofs look like?
18:03:31 <yuuki> Well, the type for K is p -> q -> p and the type for S is (p -> q -> r) -> (p -> q) -> p -> r
18:03:40 <monochrom> I think he is typing in a wrong window.
18:03:41 <yuuki> The only rule is modus ponens
18:04:16 <yuuki> From the types of K and S and modus ponens, it should be possible to derive p -> p (the I combinator)
18:04:44 <yuuki> I can do it using a method isomorphic to SKK, but not for one isomorphic to SKS
18:05:31 <dolio> SKS doesn't have type p -> p, though, no?
18:05:49 <dolio> That's not what EvilTerran's test showed, at least.
18:05:57 <dolio> It was (r -> a -> b) -> (r -> a -> b)
18:06:07 <yuuki> Yes, that's what I got by hand
18:06:25 <dolio> Which is I, but with a less general type.
18:06:30 <mikv> http://hpaste.org/12236
18:07:01 <yuuki> Hmm... right.  That's interesting.  So, I lost generality in the type by using SKS?
18:07:09 <mikv> How can i match with different constructors, so i can use switch statement?
18:08:39 <mikv> @src ($)
18:08:39 <yuuki> dolio, where did EvilTerran's test say that?  I couldn't understand what he was saying :)
18:08:39 <lambdabot> f $ x = f x
18:08:45 <ziman> that was what EvilTerran showed, given that m == ((->) r)
18:08:51 <dolio> @type ap const ap -- here
18:08:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
18:09:03 <dolio> ap = S, const = K
18:09:23 <Saizan_> ?ty let s :: (p -> q -> r) -> (p -> q) -> p -> r; s = undefined; k :: p -> q -> p; k = undefined in s k s
18:09:23 <lambdabot> forall p q r. (p -> q -> r) -> p -> q -> r
18:09:24 <FunctorSalad> how can I escape ot the toplevel in GHCI if the compilation failed early (say in the CPP-phase)
18:09:24 <yuuki> Ohhh... apparently there is a lot I need to know :)
18:09:31 <FunctorSalad> +?
18:09:33 <FunctorSalad> :)
18:10:18 <procyon112> > maybe "test" id $ lookup "test" [("a", "b")]
18:10:20 <lambdabot>   "test"
18:10:28 <yuuki> Thanks guys.  That's what I got from hand, but I thought I was wrong.  I need to take advantage of Haskell's type system in the future :)
18:10:43 <dolio> :) It's handy.
18:10:48 <Saizan_> there's also djinn
18:11:00 <yuuki> I'm making a proof checker, but it seems that Haskell's type system is equivalent to a proof checking
18:11:04 <Saizan_> ?djinn (p -> q -> r) -> (p -> q) -> p -> r
18:11:04 <lambdabot> f a b c = a c (b c)
18:11:27 <yuuki> Saizan_, what did you just do!?
18:11:33 <Saizan_> yeah, it's equivalent to a propositional intuitionistic logic
18:11:40 <FunctorSalad> is it turing-complete with -XUndecidableInstances?
18:11:51 <Saizan_> and djinn is a theorem prover for that
18:12:04 <yuuki> holy moley.  This is awesome.  Actually I don't want turing completeness because I want strong normalization
18:12:10 <dolio> You need another extension or two to make it Turing complete.
18:12:22 <Saizan_> ?djinn Not (Not (Either a (Not a)))
18:12:22 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
18:12:24 <FunctorSalad> yuuki: that's why that flag has that scary name ;)
18:12:36 <dolio> Although you can write non-terminating computations with UndecidableInstances of course.
18:12:55 <Saizan_> yuuki: djinn is restricted to the strong normalizing subset
18:13:33 <procyon112> if I want Nothing to default to a value, then "maybe default id maybeValue" works, but requiring the id in there makes me think I'm using the wrong function...
18:13:48 <Saizan_> ?type fromMaybe
18:13:49 <lambdabot> forall a. a -> Maybe a -> a
18:14:45 <yuuki> Saizan_ sweetness.  I was surprised that the halting problem doesn't exist for finite machines.  It makes sense now, but why were people trying to use non-finite memories to begin with?
18:15:49 <FunctorSalad> is it possible that rewrite rules don't see type equality context constraints? :(
18:16:29 <procyon112> > fromMaybe $ lookup "test" [("a", "b")]
18:16:30 <lambdabot>       Overlapping instances for Show
18:16:30 <lambdabot>                                  (Maybe ...
18:16:58 <procyon112> > fromMaybe "test" $ lookup "test" [("a", "b")]
18:16:59 <dolio> There are some things you can't write in a strongly normalizing language.
18:17:00 <lambdabot>   "test"
18:17:00 <Saizan_> there isn't a formal system that discards only the bad programs, so you've to accept them if you want to investigate all of which is computable, afaiu
18:17:09 <dolio> Like an interpreter for said strongly normalizing language. :)
18:17:15 <yuuki> yep!
18:17:20 <FunctorSalad> yuuki: it's unnatural to impose upper bounds on everything during reasoning, even if in reality there will always be an upper bound
18:17:27 <dolio> (Excepting, perhaps, a certain specific class of 'languages'.)
18:18:10 <FunctorSalad> (maybe use monads to hide the upper bounds away? ;))
18:19:17 <yuuki> There doesn't have to be an upper bound for the reasoning to be finite, right?
18:19:40 <FunctorSalad> no, see most of mathematics :)
18:20:04 <rwbarton> More like there has to not be an upper bound for the reasoning to be correct, I think...
18:20:39 <FunctorSalad> rwbarton: the correct reasoning with memory bounds would have to branch all the time to deal with overflows, I guess
18:21:06 <yuuki> Hmm, one of the reasons I want to make a proof checker is that I want to see how much of math is derivable without resorting to infinities
18:21:48 <rwbarton> ... all of it?  What does a proof checker do that's different from what a mathematician does when checking a proof?
18:22:02 <yuuki> The proof checker doesn't make mistakes
18:22:02 <rwbarton> (Sorry if I'm confused about this conversation because I came in in the middle of it)
18:22:04 <yuuki> And I do :)
18:22:09 <FunctorSalad> I think yuuki means without even having infinity in the objects of study, rwbarton
18:22:42 <yuuki> Basically, an axiomatic theory with only S, K, and modus ponens
18:22:51 <yuuki> It seems like a better foundation for math than set theory
18:23:02 <FunctorSalad> with arbitrary terms you have infinity already
18:23:13 <yuuki> Hmm?  How so?
18:23:19 <yuuki> Any term will be finite
18:23:27 <rwbarton> I see.  In that case I think the answer is "essentially none of it" :)
18:23:31 <yuuki> I'm not postulating a "set of all terms"
18:23:33 <FunctorSalad> yes. countable infinity, just like natural numbers
18:24:20 <FunctorSalad> granted, you would be less "infinitary" than math that deals with uncountable sets
18:24:50 <mikv> http://hpaste.org/12236#a1
18:25:01 <yuuki> I would only get "infinity" if I tried to get the cardinality of the "set of natural numbers", but I don't think that set exists
18:25:06 <mikv> Why simplify (Minus (Plus (Var "x") (Const 0)) (Var "y") ) causes problem in
18:25:14 <yuuki> And I have to show it exists with my axioms before I can talk about it
18:25:19 <mikv> function defined as http://hpaste.org/12236#a1
18:26:03 <FunctorSalad> yuuki: arithmetic doesn't have infinity internally either
18:26:19 <FunctorSalad> it's just from the outside that you know that the universe must be infinite
18:26:35 <mikv> Argh!!. I see the problem :-)
18:26:37 <FunctorSalad> (just like your term structure)
18:26:42 <rwbarton> If your proofs are built from S, K, and application, can you even talk about arithmetic?
18:27:03 <yuuki> Yes, I think so.  You can make cons cells and everything
18:27:27 <rwbarton> But cons cells are values = proofs
18:27:45 <rwbarton> I think I must not be interpreting what you're saying properly
18:28:07 <yuuki> You can prove that 2 + 2 is 4, I think
18:28:12 <yuuki> (for example)
18:28:41 <roconnor> > 2 + 2
18:28:42 <lambdabot>   4
18:28:44 <yuuki> rwbarton, I'm using the types of S and K through the curry-howard correspondence
18:29:10 <rwbarton> yuuki: OK, what type corresponds to 2 then?  This is where I'm confused
18:29:17 <Saizan_> if you allow forall (like in System F2) you can
18:29:37 <yuuki> rwbarton, I'm learning still myself
18:29:49 <roconnor> S and K are only enough to do propositional logic. AFAIK
18:30:07 <rwbarton> I think there are two different things you can do
18:30:09 <FunctorSalad> I thought turing completeness <=> encodability of arithmetic in some ill-defined sense :)
18:30:11 <yuuki> Yes, I think I need to use F2
18:30:17 <Saizan_> yeah, you want dependent types for FOPL, right?
18:30:26 <rwbarton> one is use S and K to encode (the multiplicative fragment of) intuitionistic logic
18:30:32 <yuuki> But F2 is still strongly normalizing, and so still turing incomplete
18:30:57 <rwbarton> and the other is to use the strong normalization property of the simply typed lambda calculus to do computations like 2 + 2 = 4
18:31:23 <roconnor> although you can probably "prove" 2 + 2 = 4 using propositional logic
18:31:47 <yuuki> Doesn't calculating 2 + 2 prove that it's 4?
18:31:49 <rwbarton> roconnor: Like with a binary adder circuit or something?
18:32:08 <FunctorSalad> maybe we should make the syntax and semantics explicit
18:32:37 <roconnor> I was thinking of trying to show Either Bool Bool is isomorphic to Maybe (Maybe (Maybe (Maybe Void)))
18:32:45 <FunctorSalad> encoding the theory of arithmetic is not the same as having natural numbers as semantic directly, no?
18:32:51 <roconnor> but actually I'm not sure how to say isomorphic
18:33:12 <roconnor> FunctorSalad: indeed
18:36:19 <yuuki> so you're saying that typed lambda calculus is insufficient for proving the Peano postulates?
18:36:44 <roconnor> It is insufficent to state peano's postulates
18:36:53 <yuuki> Wow
18:36:56 <yuuki> That's a bummer
18:37:03 <roconnor> It is insufficent to state first order logic
18:37:23 <roconnor> at least that is my reconing
18:37:28 <solrize> yuuki you are trying to reinvent [[reverse mathematics]] ?
18:37:54 <solrize> the standard textbook is "subsystems of second-order arithmetic" by simpson
18:38:21 <roconnor> I'd wager it is decidable for a given type, whether or not there is a term of that type in the STLC.
18:38:24 <yuuki> This is the first I've heard of reverse mathematics
18:38:40 <solrize> http://en.wikipedia.org/wiki/Reverse_mathematics
18:38:41 <lambdabot> Title: Reverse mathematics - Wikipedia, the free encyclopedia
18:38:44 <yuuki> Oh,  I wasn't talking about STLC
18:38:46 <roconnor> just ask djinn
18:39:00 <roconnor> <yuuki> so you're saying that typed lambda calculus is insufficient for proving the Peano postulates?
18:39:04 <roconnor> oh
18:39:10 <roconnor> indeed you didn't say simply
18:39:18 <yuuki> I was talking about the calculus of constructions
18:39:27 <roconnor> yuuki: oh okay
18:39:39 <roconnor> then you can do all math used in practice
18:39:59 <yuuki> that's what I thought :)  I just won't get any infinities unless I add that as an axiom
18:40:24 <solrize> yuuki there's a claim in a paper by reynolds that polymorphic lambda calculus with higher order functions can implement any function that is provably total in second order arithmetic
18:40:31 <roconnor> yuuki: there are pleanty of types with infinite and uncountable members.
18:40:31 <solrize> that's in his paper on total functional programming
18:40:54 <roconnor> Nat -> Nat for example.
18:41:02 <mikv> So, how can i use pattern matching to catach several data constructor in one equeation?
18:41:08 <mikv> *catch
18:41:20 <yuuki> roconnor, but Nat is a predicate, it's not asking membership in a set
18:41:25 <Saizan_> mikv: you nest them just like in your paste
18:41:44 <yuuki> As long as I can tell whether or not what you give me is a natural, I can make a Nat -> Nat function
18:41:44 <solrize> http%3a//math.stanford.edu/~feferman/papers/newaxioms.pdf yuuki you might like this paper too
18:41:45 <mikv> Saizan_, hm... Sorry. I didn't understand you
18:41:49 <roconnor> yuuki: Nat isn't a predicate.  It is your run of the mill inductive type.
18:41:56 <solrize> oops http:/math.stanford.edu/~feferman/papers/newaxioms.pdf
18:42:20 <yuuki> roconner, all I need to be able to do is decide whether or not a value is a Nat or not
18:42:24 <mikv> Saizan_, Did you mean myfunc (Const1|Constr 2) ?
18:42:33 <yuuki> I don't need to have "the set of Nats" and then test for membership
18:43:05 <roconnor> yuuki: indeed.  Sets, as understood in set theory, don't exist in Type theory.
18:43:07 <solrize> http://math.stanford.edu/~feferman/papers/ASL2000R.pdf
18:43:07 <Saizan_> mikv: ah, no, you've to use multiple lines for that
18:43:09 <lambdabot> Title: % *;1<18=-=598=9=41:-816A%91<7-=417-=5/<811081?-@597<#B $+)! 711=583,;.-8-')(>81 ...
18:43:23 <conal> is there an html entity for latex's \sqcup (lub)?
18:43:28 <yuuki> roconnor, the meaning of the inductive type is to decide whether or not a number is a Nat in a finite number of steps
18:43:33 <yuuki> There's nothing infinite about it
18:43:34 <roconnor> yuuki: there are several different replacements for sets in type theory, each capturing a different aspect of sets from set theory.
18:44:00 <yuuki> roconner, I was thinking that cons cells were the most logical starting step.  Are there others?
18:44:12 <roconnor> yuuki: for any type A, the relationship a : A is always decidable.
18:44:47 <solrize> conal i think there is a unicode point for that character
18:44:48 <roconnor> because a always contains enough information to reconstruct the type it belongs to.
18:44:51 <mikv> Saizan_, :-( I wanted to fold several lines like simplify (Plus a b)  = simplify (Plus (simplify a) (simplify b)) and simplify (Minus a b) = simplify (Minus (simplify a) (simplify b)) into single
18:44:54 <yuuki> solarize thank you very much for the papers!
18:45:19 <FunctorSalad> oh no, ghc panic for me :(
18:45:25 <roconnor> yuuki: each natural number is a finite object, but there are an infinite number of them.
18:45:45 <roconnor> yuuki: but it is less clear that each f : Nat -> Nat is a finite object.
18:46:19 <yuuki> solarize, what is the paper on total functional programming by reynolds?
18:46:24 <conal> solrize: oh -- i hadn't thought of unicode.  thanks!
18:46:51 <solrize> yuuki, sorry, it's by dave turner, lemme find the url
18:47:11 <solrize> http%3a//www.cs.mdx.ac.uk/staffpages/dat/sblp1.pdf
18:47:13 <dolio> ⊔
18:47:14 * roconnor advertises #constructive-math
18:47:19 <solrize> http:/www.cs.mdx.ac.uk/staffpages/dat/sblp1.pdf
18:48:03 <Lemmih> Igloo: Do you know if/when newer packages will hit hackage?
18:48:05 <yuuki> roconnor, thanks!  I'm very interested in contsructive math
18:48:44 <yuuki> solrize, thank you
18:48:58 <Saizan_> roconnor: because a always contains enough information to reconstruct the type it belongs to <-- is this like saying that type inference is always decidable?
18:49:11 <roconnor> yes
18:49:22 <yuuki> Yes, type inference is decidable depending on the system
18:49:27 <FunctorSalad> how should I report a ghc panic? I have no idea what the issue is. just send in the whole .hs?
18:49:48 <Saizan_> yeah, my next question is, of which type system we're talking about here?:)
18:49:59 <pumpkin> FunctorSalad: I think it's generally nice to reduce the bug to a minimal testcase
18:50:04 <pumpkin> but I don't know about ghc-specific rules
18:51:55 <FunctorSalad> with this type I was kinda asking for it ;) http://hpaste.org/12237
18:52:39 <pumpkin> so that alone crashes it?
18:53:05 <FunctorSalad> well, it depends on the other definitions, but there it broke
18:53:31 <roconnor> Saizan_: we are talking about CoC apparently
18:54:37 <Saizan_> ah, since type inference for System F is undecidable i always assumed it would be worse for more interesting type systems
18:55:02 <yuuki> Wait, I don't think the type inference in F is undecidable
18:55:07 <FunctorSalad> presumably it's a bug in the associated types system
18:55:38 <roconnor> I'm sure you can make System F decidable by adding enough type annotations to your terms.
18:55:54 <roconnor> CoC is full of type annotations
18:55:59 <Saizan_> ah, ok
18:56:16 <roconnor> you can hardly read the terms through all the types.
18:56:19 <solrize> Joe Wells (1994) settled an "embarrassing open problem" by proving that type checking is undecidable for a Curry-style variant of System F, that is, one that lacks explicit typing annotations.
18:56:29 <solrize> http://en.wikipedia.org/wiki/System_F#Use_in_programming_languages
18:56:31 <lambdabot> Title: System F - Wikipedia, the free encyclopedia, http://tinyurl.com/2d5f9v
18:56:52 <roconnor> And that is why we all use Church Style :P
18:56:58 <solrize> i seem to remember that rank 2 polymorphism in system F is decidable but rank 3 is not
18:57:05 <yuuki> I see
18:57:07 <Saizan_> it's not really "inference" then :)
18:57:10 <yuuki> I stand corrected :)
19:03:04 <yuuki> The difference between church and curry style seemed small when I was looking it up
19:03:40 <dolio> Church annotates the arguments to lambda expressions, no?
19:04:05 <dolio> Or am I thinking of something else?
19:04:17 <yuuki> I think they both do
19:04:26 <yuuki> hmm... I'm fuzzy on it.
19:05:06 <Saizan_> yeah, Church looks like /\a:*.\x:a -> x
19:05:13 <dolio> If you try writing a type checker for, say, CoC, one where the parameters to lambdas are annotated, and one where they aren't, you'll see the difference. :)
19:05:37 <rwbarton> I was under the impression that this undecidability was related to the fact that runST $ do ... is tricky for the compiler; is that right?
19:06:33 <roconnor> church looks like \x:a -> x, curry looks like \x -> x
19:06:44 <dolio> Yeah, that's what I though.
19:07:27 <roconnor> same goes for /\, cause it is a lambda too.
19:07:27 <Saizan_> yuuki: you may like this post http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html (from the same author of djinn)
19:07:28 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
19:07:43 <Philippa> rwbarton: yes
19:08:28 <yuuki> saizan_, is that your blog?
19:09:21 <Saizan_> yuuki: heh, no
19:10:39 <dolio> check (\x:a -> e, env) is easy, because it's check(a, env), t = check(e, (x:a, env)), return a -> t.
19:11:07 <hackage> Uploaded to hackage: system-uuid 1.0.1
19:11:07 <hackage> Uploaded to hackage: system-uuid 1.0.0
19:11:42 <dolio> check (\x -> e, env) is u = fresh-type, t = check(e, (x:u, env)), return u -> t, where there's unification thrown in there.
19:14:51 <dolio> Or something of the sort. Anyhow, it only works when the types you're doing unification for are simple enough (like Hindley-Milner).
19:15:33 <dolio> Or rank-2 but not rank-3.
19:17:23 <mm_freak> besides some additional functions, Rand is just State, isn't it?
19:18:12 <roconnor> mm_freak: it is presumably more restircted than State in some ways
19:18:15 <roconnor> (I hope)
19:21:03 <thoughtpolice> @seen Lemmih
19:21:03 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 33m ago.
19:21:17 <Lemmih> Oi!
19:21:27 <thoughtpolice> Lemmih: trying to build lhc ;]
19:22:25 <thoughtpolice> http://hpaste.org/12238
19:23:04 <Lemmih> thoughtpolice: From darcs?
19:23:07 <thoughtpolice> i can't tell what's wrong, because afaics it preprocesses all the files successfully in Setup.hs (Ho.Build is the last one) - is it a generated file?
19:23:09 <thoughtpolice> Lemmih: yeah
19:23:39 <Lemmih> thoughtpolice: darcs get http://repetae.net/repos/Doc
19:23:45 <lambdabot> Title: Index of /repos/Doc
19:23:55 <Lemmih> thoughtpolice: Pull that repo from the lhc directory.
19:24:02 <thoughtpolice> Lemmih: k
19:29:28 <thoughtpolice> Lemmih: I had to pull the Doc repo from src/ and also move DataConstructors.hs-boot into src but it worked - I also needed to specify '--extra-include-dirs=/usr/lib/ghc-6.8.2/include' because it couldn't find HsFFI.h for some reason?
19:30:16 <thoughtpolice> Lemmih: does the simplifier change in the darcs repo make a big impact for compile time (O(n) from O(n^2))?
19:30:38 <Lemmih> thoughtpolice: I've only tried it with ghc-6.8.3 and ghc-6.10. Never seen an error about HsFFI.h before.
19:31:41 <Lemmih> thoughtpolice: Somewhat. It reduced the compile time of 'base' from 2:18 to 1:54 on my machine.
19:32:26 <Lemmih> thoughtpolice: But you can't compile old-locale without the change (:
19:33:22 <Lemmih> thoughtpolice: The performance bug is triggered by deriving show on large records.
19:33:57 <Saizan_> thoughtpolice: that HsFFI.h is an error from hsc2hs?
19:33:59 <thoughtpolice> thoughtpolice: i see that in the notes
19:34:02 <thoughtpolice> Saizan_: yes
19:34:10 <thoughtpolice> er, Lemmih
19:35:04 <mm_freak> thanks
19:35:23 <Saizan_> it occurred to at least 3 different people lately
19:35:30 <Saizan_> no idea which is the cause though
19:35:34 <Saizan_> ?seen Sizur
19:35:34 <lambdabot> Sizur is in #haskell. I last heard Sizur speak 8h 4m 20s ago.
19:35:50 <Lemmih> lhc shouldn't use hsc2hs at all.
19:36:11 <Lemmih> That's one of the items on my TODO list.
19:36:32 <thoughtpolice> Lemmih: how can I build lhc-base?
19:36:48 <Lemmih> thoughtpolice: You have to call lhc manually.
19:37:02 <Lemmih> thoughtpolice: I've finished the lhc support for cabal and cabal-install but haven't pushed it yet.
19:37:11 <thoughtpolice> Lemmih: ah ok
19:41:24 <Giraffe> how (in)efficient is pack?
19:41:43 <Lemmih> Giraffe: O(n), I'd think.
19:41:58 <Giraffe> Lemmih, yeah
19:44:31 <Lemmih> Giraffe: Why do you ask?
19:48:45 <Lemmih> thoughtpolice: I've pushed the Cabal support.
19:53:49 <Giraffe> Lemmih, i'm making a database application for keeping track of books
19:54:06 <Giraffe> and since titles can get pretty long, i figured it might be best to implement them as ByteStrings
19:55:24 <yuuki> It's interesting that typing to does some reasoning about code but we need contracts or something else to reason about the code itself
19:57:56 <Cale> yuuki: Hm? Types are contracts.
19:58:06 <Cale> (Or rather contracts are types)
19:58:18 <yuuki> Right, but there is more information in a program that could be subject to verification
19:58:23 <Cale> Types are basically any properties of the code which can be statically checked.
19:58:24 <geezusfreeek> yuuki: with an even more expressive type system we could type check any contract
19:59:04 <geezusfreeek> well, computable ones anyway ;)
19:59:22 <Cale> In fact, we can now, but it'll be ugly, since our type system was mostly designed to make inference easy, and not to be as expressive as possible.
19:59:29 <yuuki> How does a type system become more expressive?
19:59:50 <geezusfreeek> yuuki: consider dependent types as an example
20:00:19 <geezusfreeek> you can put value-level expressions _in_ the type level
20:01:06 <geezusfreeek> so, for example, you can statically prove that sorting a list actually correctly sorts the list
20:01:23 <yuuki> Whoa, that's neat.
20:01:30 <geezusfreeek> by putting expressions in the types that verify that elements are in the right order, that they are all there, etc.
20:01:59 <Cale> (Of course, you lose principal types, and type inference.)
20:02:33 <geezusfreeek> there is currently still a fair bit of typing (on the keyboard), mental overhead, and syntactic overhead when you use type systems like this
20:02:37 <yuuki> You still have type inference in the CoC though
20:03:22 <geezusfreeek> to prove the most interesting properties you pretty much have to use explicit types signatures
20:03:47 <geezusfreeek> you wouldn't want to leave them to chance anyway though. they are your specifications
20:05:27 <Cale> Right. A lot of recent work seems to be about how we can allow for fancy types when we want them, while conserving type inference for terms which would normally typecheck in less fancy systems.
20:14:05 <gwern> 'Depending on how you measure success, it may be to early to call Real World Haskell successful. From a financial perspective, it won't be a success until they have recouped their expenses and sold enough copies to pay for all the time they spent writing the book.'
20:14:09 <gwern> bwa ha ha
20:14:20 <gwern> like dons, at least, was writing it for the money?
20:14:47 <dolio> Who is this? jdh?
20:15:13 <gwern> http://www.reddit.com/r/programming/comments/7ensy/ask_proggit_is_it_a_good_idea_to_write_a_book/ setuid_w00t, apparenbtly
20:15:15 <lambdabot> Title: Ask Proggit: Is it a good idea to write a book called "Functional Programming in ..., http://tinyurl.com/5bms63
20:16:12 <chessguy> @bot
20:16:12 <lambdabot> :)
20:17:14 <Giraffe> man, is it just me or is it very difficult to make a database application without a lot of do blocks?
20:17:18 <tessier> I'm reading RWH and I don't understand these type descriptions: (a -> b -> c) -> [a] -> [b] -> [c]
20:17:27 <tessier> What does it mean to be in parens?
20:17:34 <Giraffe> tessier, it means a function that takes an a and a b
20:17:38 <Giraffe> and returns a c
20:17:55 <chessguy> tessier:  there are 3 arguments, and the first is a function of type a -> b -> c
20:17:55 <Giraffe> geezusfreeek, you seem like some kind of haskell demigod
20:18:02 <Giraffe> or chessguy, or whoever
20:18:04 <Lemmih> gwern: lhc is out with support for both ghc-6.8 and ghc-6.10.
20:18:13 <Giraffe> is it possible to do much event-driven stuff without many do blocks?
20:18:29 <chessguy> that's an awfully vague question
20:18:56 <Giraffe> er, sorry
20:19:17 <gwern> Lemmih: 'k
20:19:25 <Giraffe> not event driven, i'm trying to make a database application and it seems to involve a staggering amount of IO, facilitating the need for do blocks i guess
20:19:29 <gwern> Lemmih: no luck on the meachem front I take it from the 'lhc'
20:19:46 <chessguy> the question is, is everything you're doing inside of monads really impure, or can it be refactored into pure functions
20:20:05 <chessguy> err, "impure" i should say
20:20:34 <tessier> chessguy: So sort of like some kind of compound type definition?
20:20:46 <chessguy> huh?
20:20:58 <chessguy> oh
20:21:11 <chessguy> sorry, my mind didn't context-switch quickly enough
20:21:15 <tessier> heh, sorry
20:21:32 <tessier> So this thing describes a function which takes a function and an a and a b?
20:21:37 <chessguy> tessier: it's a higher-order function. do you know what that means?
20:21:48 <tessier> er...a function then an [a] and a [b] and returns a [c]
20:21:51 <tessier> Yes, I know what that means.
20:21:57 <chessguy> right, you've got it
20:22:03 <tessier> Ok, thanks. :)
20:22:07 <tessier> Mind-bending.
20:22:09 <chessguy> in fact, you can already guess what it does just from that
20:22:26 <Giraffe> well alright, chessguy, here's an example
20:22:40 <Giraffe> http://hpaste.org/12239
20:23:05 <Giraffe> how can i further separate IO from the rest of the code like that?
20:23:14 <tessier> chessguy: You would guess that the function does something with [a] and [b] to produce [c]?
20:24:07 <chessguy> tessier:  i would guess that it applies the function to the first element of the first list and the first element of the second list to get the first element of the third list, then does the same for the second elements, and so on
20:24:11 <tessier> Giraffe: I haven't gotten to doing IO in RWH yet but I have heard people say that newbies tend to do much more inside their do blocks than they really should be doing just because they don't know how to turn it into pure functions.
20:24:30 <Giraffe> tessier, it's not really in RWH, but yeah
20:24:46 <Giraffe> i recognize that it's not how i should be doing it, but...how should i be doing it then?
20:25:01 <chessguy> tessier:  that is, f func (x:xs) (y:ys) = func x y : f func xs ys
20:25:09 <sjanssen> Giraffe: that code doesn't look too bad
20:25:15 <Giraffe> sjanssen, really?
20:25:21 <Giraffe> i mean addRecord is pure
20:25:27 <tessier> "Honey, you don't look too fat..."
20:25:28 <Giraffe> as is continue
20:25:30 <sjanssen> Giraffe: oh, it is?
20:25:34 <sjanssen> okay, then we can do better
20:25:35 <chessguy> Giraffe, sjanssen: yeah, except that that one function is doing a couple different things
20:25:50 <sjanssen> yeah
20:26:14 <chessguy> depending on how it fits into the rest of the app, you might be able to do better
20:26:20 <sjanssen> Giraffe: it looks like you're using addRecord as if it isn't pure
20:26:39 <Giraffe> uh huh
20:27:12 <chessguy> tessier:  does that make sense?
20:27:21 <tessier> chessguy: Yeah, I've got it now. Thanks! :)
20:27:25 <chessguy> cool
20:27:26 <Giraffe> well addRecord is a addRecord :: Connection -> String -> String -> IO Integer
20:27:33 <chessguy> @type zipWith
20:27:34 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
20:27:41 <sjanssen> Giraffe: so it isn't pure
20:27:46 <tessier> chessguy: Yes, that's it exactly. :)
20:27:47 <Giraffe> er, yeah D:
20:27:53 <Giraffe> i forgot about that
20:28:00 <chessguy> heh
20:28:07 <tessier> Interesting how one can guess just by the type.
20:28:10 <Giraffe> it just seems very difficult to do something like DB management while maintaining a significant amount of purity
20:28:16 <sjanssen> Giraffe: is it important that you input records iteratively, or would it be okay to add all the records at the end?
20:28:17 <tessier> Can that be done with any other language?
20:28:21 <chessguy> tessier:  for some functions, not all
20:28:35 <Giraffe> sjanssen, it would be okay to add all the records at the end for sure
20:28:48 <rwbarton> tessier: the ability to guess the behavior from the type has a lot to do with parametric polymorphism
20:28:56 <chessguy> tessier:  well, if you consider class definitions without their implementations, for example, you can sort of do it in OO
20:29:20 <Giraffe> sjanssen, are you saying i do something like ask the user for all the records, store them as a list, and then write them to the DB at the end?
20:29:35 * chessguy puts on a flame-retardant suit
20:29:37 <sjanssen> Giraffe: alright, so we can make manageDB conn = getManyRecords >>= mapM_ addRecord
20:29:53 <sjanssen> Giraffe: where getManyRecords :: IO [(String, String)]
20:30:30 <sjanssen> Giraffe: you can ask the users for the records iteratively, but it helps refactoring if we separate data input with data processing
20:30:35 <Giraffe> right
20:30:40 <rwbarton> that assumes you don't want to add the records as you receive them
20:30:41 <chessguy> @type g? >>= mapM_ a?
20:30:42 <lambdabot> parse error on input `>>='
20:30:58 <rwbarton> @type ?g >>= mapM_ ?a
20:30:59 <lambdabot> forall a (m :: * -> *) b. (Monad m, ?a::a -> m b, ?g::m [a]) => m ()
20:31:03 <chessguy> ugh
20:31:17 <rwbarton> @type ??
20:31:18 <lambdabot> parse error on input `??'
20:31:39 <Giraffe> rwbarton, it depends
20:31:49 <Giraffe> i may need to add them iteratively in some cases, but not in others...
20:34:35 <orbitz> @src Either
20:34:35 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:34:56 <chessguy> @source Either
20:34:56 <lambdabot> Either not available
20:35:02 <chessguy> @docs Either
20:35:02 <lambdabot> Either not available
20:35:05 <chessguy> bah
20:35:13 <chessguy> @docs
20:35:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:35:43 <rwbarton> , src ''Either
20:35:56 <lunabot>  data Either a b = Left a | Right b
20:36:17 <chessguy> , help
20:36:19 <lunabot>  luna: Not in scope: `help'
20:39:02 <sjanssen> Giraffe: http://hpaste.org/12239#a1 is how I would do it
20:39:53 <Giraffe> sjanssen, interesting
20:40:11 <sjanssen> Giraffe: it is a bit longer, but you've got several re-usable components
20:41:19 <chessguy> ahem.....of course you would add type annotations, right? :)
20:41:44 <sjanssen> chessguy: the core functions have type signatures
20:41:57 <Giraffe> sjanssen, yeah, i like the generalization you did
20:42:08 <sjanssen> in fact, I'd probably move getTitleAuthor to a where-bound function and not give it a type sig
20:42:59 <chessguy> that inputLoop looks like it should collapse into something smaller
20:44:10 <sjanssen> one could use maybe, but that would just obfuscate
20:44:35 <Giraffe> could you take out that mx <- a?
20:44:49 <Giraffe> ah, wait, no
20:45:03 <sjanssen> you could use >>= and maybe
20:45:05 <Giraffe> right
20:45:45 <chessguy> @type maybe
20:45:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:48:54 <Giraffe> sjanssen, judging by the type signature mapM_ runs the action passed in across the entire list, right?
20:49:02 <sjanssen> Giraffe: exactly
20:49:09 <Giraffe> hmm, i think i'm starting to get this
20:49:13 <Giraffe> the gears, they are turning
20:49:43 <chessguy> @type i a = a >>= maybe (return []) (\x -> (x:) (i a))
20:49:44 <lambdabot> parse error on input `='
20:50:08 <sjanssen> chessguy: forgetting fmap, also @type takes expressions only
20:50:15 <chessguy> @type let i a = a >>= maybe (return []) (\x -> (x:) (i a)) in i
20:50:15 <lambdabot> forall a. [Maybe [a]] -> [[a]]
20:50:47 <Giraffe> i think i may want to just make a book data structure though
20:50:56 <chessguy> bah, too late at night for me
20:51:03 <sjanssen> Giraffe: sounds like a good idea
20:51:16 <yuuki> Is MacPorts the most common way to get Haskell on OS X?
20:51:21 <sjanssen> ype let i a = a >>= maybe (return []) (\x -> fmap (x:) (i a)) in i
20:51:25 <chessguy> yuuki:  that's how i did it
20:51:28 <sjanssen> @type let i a = a >>= maybe (return []) (\x -> fmap (x:) (i a)) in i
20:51:29 <lambdabot> forall (m :: * -> *) a. (Functor m, Monad m) => m (Maybe a) -> m [a]
20:51:43 <pumpkin> does macports have cabal?
20:51:57 <chessguy> ah, i was close
20:51:59 <pumpkin> guess not
20:52:23 <chessguy> @pl \x -> fmap (x:) y
20:52:23 <lambdabot> flip fmap y . (:)
20:52:30 <sjanssen> pumpkin: Cabal comes with GHC
20:52:34 * chessguy giggles
20:52:37 <pumpkin> oh
20:53:54 <pumpkin> I wonder how many forms of cancer we could've cured by now with all the cycles wasted on having all macports and gentoo users recompile everything from scratch every time
20:55:03 <lament> 69105 forms
20:55:56 <pumpkin> ah, thanks
20:56:05 <pumpkin> I'll cite that number when I need to rant about recompiling
20:56:05 <sjanssen> _
20:56:25 <Giraffe> har har
20:57:46 <orbitz> what does No instance for (Fractional Int) mean when i am usign putStrLn?
20:58:11 <vegai> orbitz: putStrLn takes Strings
20:58:27 <orbitz> i'm under the imrpession i am giving it one though
20:58:28 <orbitz> hrm
20:58:38 <orbitz> putStrLn (convertTemp temperature scale) where
20:58:47 <orbitz> convertTemp t Celsius = "Fahrenheit : " ++ show (9/5 * t + 32)
20:59:32 <vegai> yeah, seems so
20:59:32 <mentalmonkey> anyone use haskell for simple numerical applications, root finding, Newton's method etc. and if so is there any major disadvantage using this over C(++)/Fortran for instance?
20:59:41 <orbitz> clearly i am wrong, but i'm unsure why I'm wrong
20:59:55 <lament> (9/5 * t + 32) seems to be the problem
21:00:00 <rwbarton> orbitz: probably temperature :: Int there
21:00:04 <tessier> mentalmonkey: Tons of code to do those things already exist in Fortran/C++ and probably even optimized. In Haskell you'll be reinventing the wheel.
21:00:09 <rwbarton> orbitz: you can't multiply an Int by 9/5
21:00:21 <ivanm> mentalmonkey: if it's simple things, it'd be faster in general to do it in Haskell
21:00:22 <orbitz> rwbarton: indee dit does
21:00:32 <orbitz> let temperature = (read temp) :: Int
21:00:41 <orbitz> i'm still gettin ga whold of haskells numerical stuff
21:00:53 <ivanm> since you have less boilerplate, and don't have to spend as long looking for segfault ;-)
21:00:57 <ivanm> *segfaults
21:01:01 <mentalmonkey> tessier: yes, I know some of the arguments raised, for instance http://www.mail-archive.com/haskell-cafe@haskell.org/msg12900.html, but the fact that it's in haskell means I can read it, which I like
21:01:03 <lambdabot> Title: Re: [Haskell-cafe] Numerical methods in Haskell, http://tinyurl.com/6gt7a7
21:01:43 <mentalmonkey> tessier: not that I couldn't read it if it were in C(++)/Fortran but I would prefer not to :)
21:02:07 <Giraffe> sjanssen, what exactly does fmap DO?
21:02:21 <sjanssen> @type fmap
21:02:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:02:46 <ivanm> Giraffe: depends on the type
21:02:53 <orbitz> rwbarton: thanks
21:03:02 <ivanm> typically, it cleverly applies the function on the data contained within that data structure
21:03:10 <ivanm> @src [] fmap
21:03:10 <lambdabot> fmap = map
21:03:15 <ivanm> @src Maybe fmap
21:03:15 <lambdabot> fmap _ Nothing       = Nothing
21:03:15 <lambdabot> fmap f (Just a)      = Just (f a)
21:03:16 <sjanssen> Giraffe: given a function and an action, returns the function applied to the result of the action
21:03:36 <sjanssen> Giraffe: for any Monad, fmap f mx = do x <- mx; return (f x)
21:05:13 <Twey> ∴  fmap f mx = mx >>= return . f ∴  fmap f mx = liftM f mx ∴  fmap = liftM?
21:06:14 <pumpkin> sounds like voodoo to me
21:06:28 <Twey> @src liftM
21:06:28 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:06:46 <Twey> Looks right to me :)
21:07:01 <pumpkin> voodoo
21:07:08 <pumpkin> :)
21:07:12 <pumpkin> to the uninitiated like me
21:07:22 * Twey chants and beats drums.
21:07:23 <sjanssen> liftM is the devil!
21:07:52 <Twey> Whaaat?
21:07:54 <chessguy> @quote voodoo
21:07:54 <lambdabot> No quotes match. Wrong!  You cheating scum!
21:07:58 <Twey> liftM is awesome and useful
21:08:01 <pumpkin> @src [] liftM
21:08:02 <chessguy> @quote sacrifice
21:08:02 <lambdabot> No quotes match. My brain just exploded
21:08:02 <lambdabot> Source not found.
21:08:07 <Cale> Twey: yes, liftM and fmap are the same thing
21:08:09 <pumpkin> hm
21:08:12 <Cale> Twey: (apart from the type)
21:08:17 * Twey nods.
21:08:18 <pumpkin> why could he do that with fmap?
21:08:19 <Twey> Aye
21:08:21 <pumpkin> but not with liftM
21:08:21 <sjanssen> Twey: liftM has the wrong type
21:08:30 <pumpkin> :t liftM
21:08:31 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:08:32 <Twey> :t liftM
21:08:33 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:08:44 <Twey> What should it be?
21:08:45 <sjanssen> it only exists due to a problem in the Haskell '98 report
21:08:55 <sjanssen> Twey: it should work on Functor
21:08:59 <Twey> Oh really?  What problem is that?
21:09:01 <Twey> Ah
21:09:10 <Twey> So basically, liftM should just be fmap?
21:09:19 <Twey> But... Monads aren't Functors?
21:09:26 <chessguy> sjanssen:  that's ok, they'll fix it in haskell'.......
21:09:34 <chessguy> in 20 years or so
21:09:46 <Twey> Oh, that is going to be fixed?
21:09:47 <Twey> Haha
21:09:47 <Twey> Hey chessguy.  :)
21:09:49 <Cale> monads are functors, but Monads need not be Functors (unfortunately)
21:09:56 <sjanssen> chessguy: I don't think that is official
21:10:04 <chessguy> hiya Twey
21:10:39 <Twey> Haven't seen you around of late
21:10:41 <chessguy> wgat isn't?
21:10:59 <sjanssen> chessguy: Functor => Monad isn't a sure thing for Haskell' yet
21:11:12 <Twey> Why on Earth not?
21:11:17 <chessguy> Twey: yeah, been a little scarce around here
21:11:37 <sjanssen> (I'm not sure what *is* a sure thing for Haskell')
21:12:11 <Cale> Let's start a Haskell 2 committee. :)
21:12:11 <dino-> @seen dons
21:12:12 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 4h 40m 15s ago.
21:12:15 <chessguy> i'm not sure i'm even convinced haskell' will ever happen
21:12:42 <orbitz> what is haskell'?
21:12:55 <Cale> orbitz: The provisional name of the new standard.
21:13:12 <Cale> (Would be Haskell 1.6)
21:13:22 <Cale> (Or something based on the date.)
21:13:24 <orbitz> does haskell currently have a 'standard' in the ISO sense or is it more of a defacto standard (GHC)?
21:13:38 <sjanssen> Haskell' isn't really a new standard any more -- it is now an errate process as I understand it
21:13:43 <Cale> orbitz: Not an ISO standard, but there's the Haskell 98 Report.
21:14:29 <chessguy> that's just pathetic
21:14:42 <chessguy> 10 years old
21:15:17 <sjanssen> chessguy: what is the problem?
21:15:19 <Cale> sjanssen: Hmm... doesn't that kind of defeat the purpose, which was to write down precisely the behaviour of various common extensions made by GHC and Hugs?
21:15:40 <chessguy> sjanssen:  oh, just that haskell' has stalled
21:16:04 <sjanssen> Cale: did you hear about the consensus that came out of the Haskell workshop?
21:16:10 <Cale> sjanssen: no.
21:16:58 <sjanssen> Cale: rather than producing a single standards document, Haskell' will now just standardize extensions
21:17:12 <Cale> Oh, that's sensible.
21:17:42 <Cale> But we also have things like the Prelude...
21:17:48 <Saizan_> it doesn't work well for libraries
21:17:51 <Saizan_> right..
21:18:01 <sjanssen> yeah, it basically doesn't work at all for libraries
21:19:13 <Cale> Hmm... I wonder if we really need a standards document for a library spec, given that the library is likely open source under a very permissive license anyway.
21:19:41 <sjanssen> it would be nice to have a standard for Prelude, at least
21:19:51 <Cale> If we just get all the implementations to use the same source (or something close enough to the same), that would do the same job, wouldn't it?
21:19:56 <Saizan_> yeah, but a diverging base library might be worse than diverging extentions
21:21:24 <sjanssen> Cale: a standard makes the Prelude less likely to change, which is a good thing
21:21:37 <sjanssen> Prelude should only change for very good reasons
21:21:37 <Cale> Is it really?
21:21:37 <BMeph> Cale: Call it Haskell: TNG, and watch the geeks roll in... ;)
21:21:51 <Cale> The Prelude needs changes though.
21:21:56 <Twey> @src on
21:21:56 <lambdabot> (*) `on` f = \x y -> f x * f y
21:22:04 <sjanssen> I don't think there are too many problems with it
21:22:11 <Twey> I don't get this definition.
21:22:22 <sjanssen> Functor => Monad, and the Num superclasses are my only grievances
21:22:22 <Twey> Only (*) is defined with on?
21:22:27 <sjanssen> oh, and fail
21:22:28 <Cale> Twey: (*) is a variable there
21:22:38 <Twey> Oh
21:22:47 <Twey> That's... weird
21:23:15 <Cale> Twey: on is what's being defined.
21:23:24 <Twey> *nod*
21:23:47 <Cale> It's the same thing if you write   g `on` f = \x y -> f x `g` f y
21:23:49 <sjanssen> Cale: what other changes would you make to Prelude?
21:23:57 <Twey> Yep
21:23:59 <Saizan_> if Functor => Monad then it seems natural to put Applicative in the middle
21:24:04 <Cale> sjanssen: Well, I would de-Int-ise a bunch of stuff
21:24:09 <Twey> It's just slightly confusing :-P
21:24:18 <Cale> sjanssen: If class aliases were available, the class hierarchies would get finer.
21:24:23 <sjanssen> Saizan_: yeah, it would be logical to do those changes all at once
21:25:14 <Cale> The whole exception thing is fairly messed up.
21:25:14 <sjanssen> Cale: I suppose you're referring to Num and friends?  I don't think we can talk about splitting them until we at least see a nice proto-type
21:25:51 <sjanssen> yes, Prelude.catch should be dropped
21:26:00 * Twey nods.
21:26:35 <Saizan_> we also need saner strictness defaults here and there
21:27:00 <Cale> I wouldn't recommend swapping foldl and foldl', but I would recommend including foldl'
21:27:22 <Cale> Or are you talking about I/O?
21:27:34 <Saizan_> things like sum
21:27:58 <Cale> Oh, yeah, the sum in terms of foldl' is generally more useful.
21:28:31 <Cale> The Real class is terribly named.
21:28:38 <yuuki> Is there talk of Haskell losing its laziness?
21:28:43 <sjanssen> yuuki: no
21:28:47 <Twey> Heck no
21:28:51 <Riastradh> That applies to numerical classes beyond Real, Cale.
21:28:57 <Twey> How's sum defined right now?
21:28:59 <Twey> @src sum
21:29:00 <lambdabot> sum = foldl (+) 0
21:29:05 <Twey> Oh
21:29:11 <Cale> Riastradh: which ones?
21:29:34 <Twey> I do wonder, why foldl (+) 0 and not foldl1 (+)?
21:29:40 <Riastradh> Num, for example!
21:29:50 <Cale> Twey: Because you don't want it to fail on an empty list?
21:29:51 <sjanssen> > sum []
21:29:52 <lambdabot>   0
21:29:56 <Twey> Ah, true.
21:30:10 <Cale> Riastradh: What should it be called? Certainly not Ring, as we want Float to be an instance.
21:30:34 <sjanssen> I think the current Num hierarchy is very pragmatic
21:30:53 <Cale> It's better than it looks at first, but it has some problems.
21:30:55 <rwbarton> Cale: What's wrong with Float being a ring?
21:31:05 <Cale> rwbarton: Addition is not associative.
21:31:07 <Riastradh> Floating-point numbers fail to be associative.
21:31:14 <Riastradh> ...floating-point addition fails, I mean.
21:31:21 <rwbarton> That's a problem with Float, not with making it a ring.
21:31:30 <rwbarton> I mean, technically of course you are correct.
21:31:34 <Cale> signum and abs don't deserve to be in Num though.
21:31:35 <Riastradh> Of course, nothing prohibits an instance of Ring that fails the desired law.
21:32:23 <Cale> That's true. It's sort of an 'approximate' ring, whatever that means.
21:32:42 <Saizan_> and remove the Show,Eq superclasses
21:32:47 <Cale> right.
21:32:56 <rwbarton> The thing that people are modeling with Float is a ring.
21:32:56 <Cale> They're there because of n-patterns.
21:33:17 <Twey> Wait, remove Show and Eq?
21:33:23 <Cale> But I don't think it's that bad to require people who use n-patterns to write the extra contexts.
21:33:30 <Cale> Twey: as superclasses of Num
21:33:37 <Twey> Ah
21:33:44 <Twey> Well, Eq makes sense, doesn't it?
21:33:53 <Cale> There are lots of useful instances of Num which aren't useful instances of Eq or Show
21:34:05 <Cale> Various function types for instance.
21:34:08 <Twey> Such as?
21:34:11 <Saizan_> Cale: that's how we'll do refutable patterns in do-notation anyway :)
21:34:19 * Twey blinks.
21:34:45 <rwbarton> Hmm, I understand why Eq is a superclass of Num, but why Show?
21:35:10 <Cale> Hmm, good point, why Show indeed...
21:37:33 <Cale> Another thing is that there's a lot of stuff in the Prelude which needs to be hidden to allow more general stuff, specifically Data.Foldable, for instance. I'm not 100% convinced that Data.Foldable is the right thing though.
21:38:32 <Cale> It would be nice if the Prelude was chopped up into submodules like the Report showed (e.g. PreludeList) and one could easily prevent one of those from being imported all at once.
21:38:47 <sjanssen> import Prelude ()
21:38:59 <Cale> Well, you can import nothing, sure.
21:39:13 <Cale> But that can be even less convenient.
21:39:50 <sjanssen> can you hide a re-exported module?
21:40:01 <Cale> I don't think you can at present.
21:40:24 <Cale> But it would be awfully nice to be able to say  import Prelude hiding (PreludeList)
21:42:20 <Saizan_> we should ask for a richer module language, or maybe just extensible records..
21:42:29 <Cale> There seems to be an awkward tension between making enough stuff available in the Prelude for writing small programs and leaving enough out that it's easy to change later.
21:42:35 <Saizan_> to Haskell'
21:42:43 <Cale> Haskell 2!
21:43:02 <Twey> ... The Reckoning
21:43:22 <Cale> There is some need, I think, to write down what's currently in place, and I'm okay with it if Haskell' wants to be that. :)
21:43:36 <jml> Haskell 2: This time, it's functional.
21:43:39 <jml> I mean, wait.
21:43:40 <jml> what.
21:43:45 <Cale> But it would be nice to have a formal way to recommend things.
21:43:45 <Twey> Haha
21:43:54 <Twey> Aye
21:44:03 <Twey> How's the discussion going on record improvements?
21:44:39 <Cale> Personally, my mind is made up about the semantics I want for records, and pretty much on the syntax as well, though I'm a little more flexible there.
21:45:04 <Cale> Basically, I think we should steal the semantics for extensible records and variants from Daan Leijen's proposal.
21:45:21 <Twey> Got it written down?
21:45:21 <Cale> The syntax in that paper is incredibly ugly though, so I think lenses are a much better plan.
21:45:35 <Twey> Aye
21:46:02 <Cale> record.fieldName is *so* not Haskell syntax.
21:46:19 <Twey> Right.  And it overloads . *even more*.
21:46:35 <Cale> If I had my way, | would be our module path separator
21:46:49 <Twey> I was thinking :
21:46:51 <Twey> But OK :-P
21:46:58 <Cale> : is taken ;)
21:47:13 <Saizan_> Cale: do they allow types like forall l r a. l -> a -> r -> { l := a, r }? i.e. label polymorphism
21:47:26 <dino-> http://ui3.info/d/rwh/
21:47:55 <dino-> pics of RWH on my book reader
21:47:58 <Cale> Saizan_: yes.
21:48:09 <Twey> Ooh, | is reserved anyway.  Yes, that could work.
21:49:31 <Cale> I mean, you do end up with a few funny things like that...
21:50:04 <Cale> Control|Arrow||||
21:50:19 <dino-> I don't know why they didn't size the cover bigger. I may have to fix that in my cp.
21:50:33 <Twey> They're going to make all qualified operators prefix!! :(
21:50:42 <Cale> But infix operators are always going to be impossible to make nice.
21:50:54 <Cale> We already have Prelude.. with the current system.
21:51:02 <twb> I want some help with Cabal flags.
21:51:03 <Twey> Aye, but... prefix! :(
21:51:11 <Cale> Twey: hm?
21:51:15 <Cale> ah
21:51:20 <Cale> In Haskell'?
21:51:23 <twb> I can see some code doing: customFields = map fst . customFieldsBI . buildInfo $ darcsExe
21:51:41 <Nafai> twb: How's your shell going?
21:51:41 <twb> And then it checks: "x-have-libwww" `elem` customFields
21:51:52 <Twey> Cale: Haskell' proposes to force a M.// b to (M.//) a b
21:51:58 <twb> Nafai: I haven't been working on it for a while
21:52:02 <Twey> It's horrible :(
21:52:10 <Cale> Twey: I'm not sure that's a terrible idea.
21:52:23 <Cale> Twey: Qualified infix operators are really ugly anyway.
21:52:24 <Twey> I guess I would end up steering clear of qualified imports a lot more.
21:52:37 <Twey> Yes, but at least they're still infix
21:52:38 <Cale> I try to minimise qualified imports as it is.
21:52:49 <twb> Anyway, I added another cabal flag, with-manual, which defaults to True.  But copying the above approach doesn't work, because customFields here is just ["x-use-color"]
21:52:55 <Cale> and will usually separately import all the infix operators I'll need unqualified
21:52:59 <Twey> Mmm.
21:53:06 * Twey nods.
21:53:20 <Twey> OK, fair point.  That's always an option.
21:54:26 <Saizan_> Map.! is nice though
21:56:09 <Cale> The nice thing about using lenses for record operations is that you don't need lots of separate syntaxes for different operations.
21:56:20 <Cale> (this is back in that other thread of conversation ;)
21:57:22 <Saizan_> yeah, just get/set/remove functions
21:57:38 <Cale> Also, I think all labels should start with '
21:57:55 <Cale> (and not consist of a single character followed by another '
21:57:56 <Cale> )
21:58:13 <Cale> This gets around a lot of syntactic issues.
21:59:09 <Cale> And well, more than syntactic issues...
21:59:30 <Cale> It's hard to tell what's a label if you want to go with lenses.
21:59:53 <Saizan_> they started implementing this in JHC iirc?
21:59:58 <Cale> Oh?
22:00:45 <Cale> I remember John being interested in doing it, but I'm not sure how far he got.
22:01:06 <Saizan_> ah, yeah, that's probably what i recall too
22:02:17 <Cale> Oh, the funny thing with Daan's proposal is that 'set' isn't a primitive.
22:02:29 <Cale> You have extension, selection, and restriction
22:02:56 <Cale> You can extend a record with the same label multiple times, and they all get added, and behave a bit like a stack.
22:03:17 <Cale> It avoids the need for lacks predicates.
22:04:01 <Cale> Restriction would be better referred to as deletion, perhaps.
22:04:26 <Cale> So by combining that with extension, you get the usual set operation.
22:05:22 <monochrom> eww, you can also unset.
22:05:36 <Cale> Well, that's essentially what restriction is.
22:05:48 <monochrom> the empty record is the mother of all records
22:06:17 <Cale> Is there a reason to be upset by that?
22:06:24 <monochrom> no
22:08:28 <monochrom> haha. if you delete, it's "unset". if you delete then extend, it's "set". if you don't delete but extend, possibly stacking up, it's "upset". :)
22:08:47 <Cale> :)
22:11:02 <Cale> Mathematica has an UpSet (but it's unrelated to this). UpSet[lhs, rhs] defines rhs to be the value of lhs, but associates the assignment with symbols that occur one level deep in lhs (rather than at the top level)
22:11:30 <Cale> So you can do  UpSet[Cos[a], 2], and that becomes part of the definition of a
22:11:46 <Cale> (You can also use the infix operator ^= )
22:12:42 <Cale> Mathematica has a really screwy evaluation model ;)
22:12:55 <monochrom> a theorem prover needs it.
22:13:11 <monochrom> hilbert's choice operator
22:13:56 <monochrom> Mathematica likely doesn't just evaluate, it also does unification, and it can grok "Cos[a]=2" as an axiom.
22:14:40 <Cale> It does pattern matching and substitution repeatedly.
22:16:18 <Cale> It's basically a tree rewriting system which can handle rules that are defined for things one level deep (but not more).
22:16:48 <monochrom> now that's interesting
22:17:08 <xpik1> does anyone know the telnet code for clear screen?
22:17:44 <Cale> Probably for efficiency reasons. You wouldn't want to have to go looking through a whole expression deeply and repeatedly for upvalue definitions after every reduction.
22:17:49 <monochrom> ctrl-L ?
22:18:09 <Cale> Though, there might be smarter ways to go about it.
22:19:21 <xpik1> > "\12"
22:19:22 <lambdabot>   "\f"
22:19:36 <xpik1> monochrom: thanks
22:32:56 <pumpkin> do I have to build cabal-install myself or is there any easy way to grab it?
22:34:27 <Lemmih> pumpkin: I think there is a bootstrap script somewhere.
22:45:01 <quicksilver>  /win 27
22:46:19 <Lemmih> quicksilver: 27 open tags?
22:50:30 <quicksilver> Lemmih: 30-something
22:53:03 <pumpkin> if I do cabal upgrade, it says it can't configure syb-0.1.0.0, because it needs base > 4.0 and no such thing exists
22:53:09 <pumpkin> is that normal?
22:57:14 <enolan> base 4 is in ghc 6.10
22:57:33 <pumpkin> hmm
22:57:45 <pumpkin> bah, the macports version is old
22:58:35 <pumpkin> I assume there's no easy way to upgrade?
23:00:05 <Cale> http://haskell.org/ghc/download_ghc_6_10_1.html#macosxintel
23:00:06 <lambdabot> Title: GHC: Download version 6.10.1
23:00:27 <pumpkin> ooh
23:00:43 <pumpkin> will I need to recompile my cabal packages for the new one?
23:00:55 <quicksilver> btw don't do cabal upgrad.
23:00:58 <pumpkin> :o
23:01:02 <quicksilver> cabal upgrade considered harmful.
23:01:05 <pumpkin> oh
23:01:07 <pumpkin> ok
23:01:11 <quicksilver> upgrade new packages if/when you need them.
23:01:21 <quicksilver> upgrading them all at once is a one-way ticket to dependency hell.
23:01:27 <pumpkin> ok :)
23:01:43 <pumpkin> so I should get rid of the macports ghc now, install the new one from the .pkg, and then what should I do with my cabal installation?
23:01:46 <pumpkin> reinstall it?
23:02:13 <quicksilver> new GHCs are totally separate.
23:02:39 <quicksilver> so when you install the new one, you will only get the libs which come with it
23:02:51 <quicksilver> and you'll need to freshly install anything you want not in the base set.
23:02:54 <pumpkin> yeah, but I have my cabal sitting in ~/.cabal/bin and it was compiled using the macports ghc, so I was wondering if that had some sort of compatibilty issue
23:03:12 <quicksilver> yup, it won't be compatible AFAIK.
23:05:21 <pumpkin> here goes :)
23:25:13 <twb> I'm having trouble with haddock; it looks like it's trying to parse the code between \end{code} and \begin{code}.
23:25:32 <twb> I get dist/build/tmp/src/Darcs/Repository/Prefs.hs:127:0: error: unterminated comment
23:25:32 <twb> where line 127 is
23:25:32 <twb> --    simple ``darcs add newdir newdir/*``
23:50:04 <dons> "with great sadness that I agree with several recent Rubyist’s blog posts and say that Ruby is in a very bad place right now. It’s no longer cutting edge, it’s technically stagnant, is in implementation limbo, and just isn’t… well… fun, anymore."
23:51:16 <dmwit> Yikes.
23:51:22 <dolio> Did ruby used to be cutting edge?
23:51:25 <pstickne> oh noes!
23:51:32 <dmwit> That's some sad disillusionment.
23:51:55 <dons> heh
23:52:00 <dmwit> Disillusionment might not be the word I want.
23:52:03 <dons> we can only benefit, imo.
23:52:13 <dmwit> ?wn denouement
23:52:24 <lambdabot> *** "denouement" wn "WordNet (r) 2.0"
23:52:24 <lambdabot> denouement
23:52:24 <lambdabot>      n 1: the outcome of a complex sequence of events
23:52:24 <lambdabot>      2: the final resolution of the main complication of a literary
23:52:24 <lambdabot>         or dramatic work
23:52:35 <dmwit> not that either
23:52:55 <pumpkin> dons: who wrote that?
23:53:38 <dons> http://kirindave.tumblr.com/post/60776407/the-opposite-of-momentum
23:53:39 <lambdabot> Title: kd.to_tumblr - The Opposite of Momentum, http://tinyurl.com/62s5hh
23:53:43 <vegai> I chose my current job because they were using ruby
23:53:59 <vegai> now I have a chance of using Haskell here, what I couldn't ever have done in my previous place
23:54:12 <dons> ruby has helped people think outside the java box
23:54:12 <vegai> hype can have unforeseen consequences
23:54:27 <dons> it was important in opening up the language market for erlang and others
23:54:38 <dons> since it forced people to find solutions, without going to java :)
23:56:42 <twb> ?wn ennui
23:56:42 <lambdabot> *** "ennui" wn "WordNet (r) 2.0"
23:56:42 <lambdabot> ennui
23:56:42 <lambdabot>      n : the feeling of being bored by something tedious [syn: {boredom},
23:56:42 <lambdabot>           {tedium}]
23:56:59 <SubStack> yay wordnet
23:57:02 <dons> bored, frustration, reality dawns, etc.
23:57:13 <dons> its rare in worse is better land
23:57:17 <twb> epiphany? ;-)
23:57:24 <dons> heh
23:58:01 <SubStack> ruby has some nice ideas going for it
23:58:09 <SubStack> and it has cycle and take_while and other functional goodies
23:58:31 <dmwit> It also has dynamic typing and monkey patching. =/
23:58:42 <dons> you mean, in the language? or someone wrote a library to add a few list functions?
23:59:08 <SubStack> in Enumerable in the core as of the latest version
23:59:13 <SubStack> at least with cycle
23:59:17 <SubStack> they added a few others like that too
