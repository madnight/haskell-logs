00:06:40 <dolio> top
00:10:33 <august> i like it on the top too
00:28:12 <august> oh duh, i can't rsync because only port 80 is currently allowed
00:29:10 <Enzo_H> Does anyone know how to obtain a username and password to haskell.org? .. I want to upload a package to hackage
00:30:59 <mauke> Enzo_H: http://hackage.haskell.org/packages/accounts.html
00:31:04 <lambdabot> Title: HackageDB: User accounts
00:32:32 <august>  /= instead of !=, that's annoying
00:33:17 <mauke> heh, you'll get used to it
00:33:47 <mauke> != doesn't make much sense in a language without an ! operator
00:34:56 <august> ah
00:34:59 <august> well
00:35:10 <august> that makes sense
00:35:31 <august> why || and && but not instead of !
00:35:49 <mauke> because haskell has no unary (symbolic) operators
00:36:02 <august> negative numbers?
00:36:03 <mauke> x ! y is valid, though
00:36:15 <mauke> yeah, unary minus is a hack in the language grammar :(
00:36:26 <august> eww
00:37:02 <dons> impact on humanity: zero
00:39:59 <august> 0.00% Â± 0.00000001%
00:40:17 <SubStack> negative numbers are actually a lie spread by the mathematical establishment
00:40:38 <sjanssen> @keal
00:40:39 <lambdabot> there is no way to prove the failsafe exists
00:41:06 <august> 0 is a lie
00:41:16 <sjanssen> dons: I dunno, I've been bitten by (-) a few times.  Am I part of humanity? :)
00:41:20 <august> only natural numbers exist
00:41:38 <sjanssen> august: that is a slippery slope -- first you axe 0, is 1 next?
00:41:53 <SubStack> 1 is the new 0
00:42:08 <dons> sjanssen is a species all of his own.
00:42:11 <august> actually let's see, this is cs, so 0, 1, âˆž are the only numbers
00:42:30 <dons> sjanssen: i agree though. i used to get bit by subtract vs (-)
00:42:35 <markovChain> what about the tri-state?
00:42:48 <august> the tri-state area?
00:42:51 <dons> SubStack: hehe very kealish
00:42:53 <sjanssen> I thought 2 was the only number in CS?
00:43:14 <markovChain> no, there's 0, 1, and not-connected.
00:43:29 <august> TRUE, FALSE, and FILE_NOT_FOUND
00:43:35 <markovChain> right.
00:43:44 <SubStack> and EOF
00:44:17 <sjanssen> http://20bits.com/articles/interview-questions-two-bowling-balls/ is a fun little problem to solve in Haskell
00:44:22 <lambdabot> Title: Interview Questions: Two Bowling Balls | 20bits
00:44:56 <SubStack> hah, I was just reading that
00:45:21 * markovChain is a newb
00:46:02 <markovChain> in ghci, if i want to use a library, how do i load it?  :load Data.HMM fails.
00:46:49 <SubStack> :module +Foo.Bar is the shorthand
00:46:50 <SubStack> er
00:46:51 <SubStack> :m
00:47:33 <markovChain> why the + ?
00:47:50 <SubStack> in case you want to load more than one module
00:49:27 <pumpkin> how do I convert between Strings and ByteStrings? I thought it was (un)pack, but it wants a [Word8] and not a [Char]
00:49:57 <vegai> if I have an action that just runs a String stream through an external program (stdin->stdout), is it safe to use unsafePerformIO to make that action look pure?
00:50:26 <sjanssen> vegai: is the program referentially transparent?
00:50:26 <markovChain> huh.  that fails too, i can "import Data.HMM" in a foo.hs.  that works.  but ghci cannot find "Data.HMM"
00:50:41 <pumpkin> why would an HMM be in Data?
00:50:43 <august> i can't define functions on the prompt in ghci?
00:50:53 <pumpkin> august: you can, sort of
00:50:56 <sjanssen> vegai: that is borderline, but probably acceptable
00:51:11 <markovChain> pumpkin, it's on hackage.
00:51:13 <pumpkin> vegai: what if someone replaced the external program with something evil
00:51:15 <pumpkin> :P
00:51:23 <sjanssen> pumpkin has a good point
00:51:30 <pumpkin> markovChain: yeah, was just wondering why an HMM belonged in Data :P
00:51:38 <sjanssen> or what if the program was deleted in between calls to your function?
00:51:40 <SubStack> I'd like to see what an evil module looked like.
00:51:51 <vegai> hmm, ok.
00:51:53 * august can't believe ghci> doubleMe x = x + x doesn't work
00:52:03 <pumpkin> august: type let
00:52:05 <pumpkin> before that
00:52:11 <vegai> and perhaps it even wasn't referentially transparent
00:52:17 <august> ah
00:52:17 <vegai> I was thinking of openssl(1)
00:52:23 <pumpkin> I've been told that ghci is a bit like a big do statement
00:52:32 <pumpkin> that shows every result
00:52:34 <sjanssen> vegai: if the program isn't referentially transparent, then you certainly shouldn't use unsafePerformIO
00:52:39 <vegai> aye
00:53:34 <pumpkin> is the GHC grammar for haskell written in parsec?
00:53:38 <pumpkin> or is it hand-coded?
00:53:49 <pumpkin> the parser, that is
00:53:52 <sjanssen> pumpkin: it uses Happy, a Haskell parser generator
00:54:02 <pumpkin> oh yeah, I came across that for language-c
00:58:24 <pumpkin> http://hpaste.org/12275 I asked this earlier but lost my scrollback... how can I have two accessors of the same name? I commented out my second flags function because it conflicted with the first... do I need to define it manually and pattern match against my types?
01:00:51 <Enzo_H> import [...] hiding flags
01:01:24 <Japsu> import qualified Personnel hiding (illegalImmigrants)
01:01:48 <pumpkin> Enzo_H: but they're both in this module
01:06:56 <Taejo> pumpkin: you can create a HasFlag class
01:07:28 <pumpkin> hmm, maybe that's a good idea
01:07:44 <pumpkin> but I can't do it with just vanilla notation like that?
01:08:55 <Enzo_H> the simplest thing to do is either import the function in a separate module or rename the function
01:10:25 <pumpkin> I might just do that
01:10:40 <pumpkin> maybe I can get away with not even providing flags
01:14:08 <pumpkin> is there a more appropriate analog to enums in haskell than data Animal = Moo | Baa | Oink | Woof
01:14:10 <pumpkin> ?
01:16:56 <idnar> "data Animal = Moo | Baa | Oink | Woof deriving Enum", perhaps? ;)
01:17:25 <pumpkin> ooh sounds fancy :P
01:18:01 <idnar> it just automatically defines an instance of the Enum class
01:18:29 <Taejo> pumpkin: is there a feature of Enums you want that "data Animal = Moo | Baa | Oink | Woof" doesn't provide?
01:18:51 <pumpkin> Taejo: not at all, I'm just learning and was wondering if that was the most appropriate way to describe such a situation
01:19:07 <Taejo> generally, that's exactly what you want
01:19:46 <pumpkin> I have another less trivial question (seems to me, at least): for Data.Binary.Get, it has a set of getWord(16/32/64)(le/be) functions, and I'd like to avoid repeating myself and make it so I can just call getWord(16/32/64) and set the endianness once at the beginning... can anyone think of a good way of doing that?
01:20:05 <pumpkin> it would be nice to add to the state that the Get is passing around
01:20:28 <pumpkin> (the endianness is not fixed, so I need to set it based on something I notice near the beginning of my ByteString)
01:22:04 <Taejo> pumpkin: I'm not familiar with Data.Binary, but it looks like a job for implicit parameters
01:24:04 <pumpkin> hmm? what I was thinking of was something like readVariableEndianStruct reader16 reader32 reader64 and giving it the set of three functions that are suitable for each int size
01:24:16 <pumpkin> but it seems more flexible than it needs to be
01:24:34 <pumpkin> as I'll never be reading 16 bit big endian at the same time as a 32 bit little endian number
01:24:45 <Taejo> pumpkin: that works, but using implicit parameters means you don't have to bother about passing them all explicitly
01:25:27 <Taejo> OTOH, implicit parameters aren't particularly popular; I think some people don't like them (I myself have only used them once)
01:25:44 * pheaver uses implicit parameters a lot :)
01:25:48 <pumpkin> how do they work? all I can think of that I'd call something like that is a curried function definition
01:26:05 <Taejo> http://cvs.haskell.org/Hugs/pages/users_guide/implicit-parameters.html
01:26:07 <lambdabot> Title: Implicit parameters, http://tinyurl.com/35uxrh
01:26:11 * pumpkin eats his curried function definition
01:26:43 <pumpkin> hmm
01:26:49 <SubStack> spicy
01:27:39 <pumpkin> this stuff looks scary :P
01:35:31 <Lanjiao> Hi, do someone know if GHC support macros like #define M(x) #x, #define M(x) Pre##x
01:37:51 <opqdonut> you could do something like that with template haskell
01:38:43 <Japsu> Or you can use the C preprocessor with Haskell. ^____^
01:38:52 <Lanjiao> I saw GHC have a -cpp argument
01:39:23 <Lanjiao> I tried, but seems it only worked with the simple macros like #define M 1234.
01:39:41 <Lanjiao> but didn't work with #x or x##y
01:42:28 <pumpkin> :t liftM8
01:42:29 <lambdabot> Not in scope: `liftM8'
01:42:35 <pumpkin> hmm
01:42:40 <pumpkin> is that overdoing it?
01:42:48 <Taejo> pumpkin: Yes. Use Control.Applicative
01:42:49 <dolio> Really? You need 8?
01:42:53 <pumpkin> :P
01:44:27 <Taejo> pumpkin: liftMn f a1 ... an = f <$> a1 <*> ... <*> an
01:44:43 <pumpkin> aha, thanks
01:44:45 <Taejo> the right hand side is usually better especially if there are many args
01:44:56 <Taejo> pumpkin: you'll need to import Control.Applicative
01:45:05 <pumpkin> and I can ignore one side by using <* and *>, right?
01:45:33 <pumpkin> Taejo: what do you mean by the right hand side?
01:45:58 <Taejo> I mean "f <$> a1 <*> ... <*> an" is better than "liftMn f a1 ... an"
01:46:21 <dmwit> better?
01:46:30 <Taejo> dmwit: for n=8
01:46:35 <pumpkin> :P
01:46:36 <dmwit> ah
01:46:38 <dmwit> Yes,
01:46:43 <dmwit> because liftM8 doesn't exist. =)
01:46:50 <dmwit> ?hoogle liftM8
01:46:50 <lambdabot> No results found
01:46:52 <dmwit> unless it does
01:46:53 <dmwit> oh good
01:46:59 <pumpkin> :P
01:47:02 <pumpkin> I just looked for it
01:47:56 <dolio> You could do 'liftM7 f a1 ... a7 <*> a8'. :)
01:48:35 <pumpkin> would that help at all, other than getting rid of a few <*>s?
01:48:44 <dolio> No.
01:48:48 <pumpkin> being a clueless newbie, I'm open to style suggestions though
01:49:10 <Taejo> personally, I prefer the applicative style
01:49:11 <dmwit> I wouldn't be surprised if liftMn and return f `ap` ... style ended up producing the Exact Same Code.
01:49:38 <dmwit> But yeah, for style, you should either be decomposing things better or using Applicative. =)
01:49:43 <Taejo> @src <*
01:49:43 <lambdabot> (<*) = liftA2 const
01:51:33 <pumpkin> dmwit: I'm loading in someone else's binary structure from a file, and I'd like to get a direct analog of what's in the spec before converting it to a form that's more usable (so I have lots of fields for now)
01:51:39 <pumpkin> are unqualified imports considered bad?
01:51:59 <dmwit> They're mostly fine if they're common libraries.
01:52:49 <pumpkin> things like Data.Binary or Data.Int/Word?
01:53:13 <dmwit> should be totally fine
01:53:23 <dmwit> I think we'll all be able to recognize where Word8 came from. ;-)
01:53:30 <pumpkin> :)
01:53:38 <pumpkin> I'm really enjoying haskell so far
01:54:06 <pumpkin> and this has got to be the friendliest IRC programming langauge channel I've encountered so far (have yet to see a flame!)
01:55:44 <dmwit_> pumpkin, YOUR MOTHER  CAN GO EAT FLAMING DEATH FOR ALL I CARE< AND YOU CAN GO BACK TO PYTHON HAHAHA
01:56:13 <pumpkin> lol
01:56:13 <C-Keen> lol
01:56:19 <SubStack> flaming death sounds pretty delicioius
01:56:31 <SubStack> some sort of mixed drink?
01:56:32 <dmwit> Now with half the calories!
02:01:50 <Lanjiao> some one konw why undefined reference to `__stginit_ZCMain'?
02:01:57 <Lanjiao> which pkg should be include?
02:02:00 <dolio> Use --make
02:02:34 <Lanjiao> --make does't give me the executable if there is no Main moudle:(
02:02:51 <int-e> Lanjiao: the main module should be called Main. alternatively you can play with --main-is
02:03:03 <Lanjiao> oh, great
02:03:39 <Lanjiao> ghc: unrecognised flags: --main-is :(
02:03:46 <dmwit> single-tick
02:03:47 <dmwit> -main-is
02:03:49 <int-e> sorry, -main-is. http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#id2617208
02:03:51 <lambdabot> Title: 5.10.ï¿½Options related to a particular phase, http://tinyurl.com/smq5n
02:05:03 <Lanjiao> thanks
02:06:54 <Lanjiao> using ghc --make packer.hs -I. -main-is Packer
02:07:00 <Lanjiao> still failed whit
02:07:14 <Lanjiao> Linking packer ...
02:07:16 <Lanjiao> /opt//lib/ghc-6.10.1/libHSrts.a(Main.o): In function `real_main':
02:07:17 <Lanjiao> Main.c:(.text+0x12): undefined reference to `__stginit_ZCMain'
02:07:18 <Lanjiao> Main.c:(.text+0x2c): undefined reference to `ZCMain_main_closure'
02:07:20 <Lanjiao> collect2: ld returned 1 exit status
02:07:35 <Peaker> Lanjiao: I had the same problem, and it disappeared when I stopped using -main-is, iirc
02:07:54 <Peaker> Lanjiao: you can comment out "module Packer where ..." :P
02:08:14 <Lanjiao> trying
02:08:38 <Peaker> Taejo: the applicative style of a <$> b <*> c <*> d ... is less composable in this sense:  (liftA2.liftA2.liftA2)
02:09:57 <pumpkin> so I should go for liftA2 over <*> ?
02:10:18 <pumpkin> it looks kinda purty right now with all those <*>s
02:10:24 <dmwit> no
02:10:45 <dmwit> Go with purty.
02:10:51 <Lanjiao> Peaker: it works, but why?
02:11:01 <Peaker> Lanjiao: I don't know
02:11:16 <int-e> Peaker: because Main is the default module name
02:11:18 <Peaker> pumpkin: <*> is fine, but I was just mentioning my perceived advantage of the lift shortcuts
02:11:24 <pumpkin> ah :)
02:11:33 <pumpkin> alright, time for bed for me
02:11:40 <pumpkin> more haskell for me tomorrow, can't wait
02:11:41 <pumpkin> :P
02:11:41 <Lanjiao> int-e: but I have used -main-is to specify.
02:11:46 <Peaker> int-e: why does using a non-default module name cause ZCMain linkage errors?
02:11:52 <Peaker> int-e: (via -main-is)
02:12:18 <sjanssen> http://www.reddit.com/r/programming/comments/7evy4/programmer_interview_questions_two_bowling_balls/c06hdpq :)
02:12:20 <lambdabot> Title: sjanssen comments on Programmer Interview Questions: Two Bowling Balls, http://tinyurl.com/6lwm46
02:12:52 <dmwit> augh
02:13:13 <dolio> What on earth is that?
02:13:26 <sjanssen> http://20bits.com/articles/interview-questions-two-bowling-balls/ solution to this problem
02:13:27 <lambdabot> Title: Interview Questions: Two Bowling Balls | 20bits
02:13:39 <dmwit> It's not even a reply to some stupid request?
02:13:44 <sjanssen> no
02:13:50 <dmwit> hen WHY
02:13:53 <dmwit> +t
02:14:08 <dolio> Did you at least write a program to generate that program?
02:14:14 <sjanssen> dolio: of course!
02:14:21 * sjanssen is not crazy
02:14:25 <dolio> That's comforting. :)
02:14:53 <sjanssen> dmwit: I find it funny
02:14:59 <sjanssen> maybe I have a strange sense of humor
02:15:07 <dmwit> =)
02:15:16 <dmwit> All senses of humour are strange.
02:15:26 <Lanjiao> Peaker: thanks
02:19:38 <int-e> Lanjiao: I don't know why -main-is doesn't work for you.
02:20:44 <int-e> Peaker: the RTS contains a call for initialising the Main module; the function that does this happens to be called __stginit_ZCMain
02:20:58 <opqdonut> i want to say "haskell is pretty goddam fast" in my paper, who should i cite?
02:21:41 <Peaker> int-e: -main-is works for me on an x86-64 machine, and fails on my x86-32 machine
02:21:49 <Lanjiao> int-e: try ghc --make packer.hs -I. -main-is Packer again, it worked, maybe a typo before
02:21:52 <leadnose> opqdonut, :D
02:22:22 <int-e> Peaker: works for me on x86-32.
02:22:23 <ivan> shootout.alioth?
02:22:31 <Lanjiao> Peaker: i woking on x86-32
02:22:37 <Lanjiao> int-e: yes
02:22:54 <Peaker> Lanjiao: maybe you can try deleting the .o and .hi files
02:24:06 <Lanjiao> Peaker: yes. it still works.
02:24:36 <Lanjiao> Peaker: and do you know how to force it to compile if i don't delete .o and .hi files?
02:26:23 <Peaker> Lanjiao: I mean does it maybe work with -main-is after you delete the .o/.hi files?   You could touch the .hs files you want to recompile
02:26:28 <int-e> Lanjiao: use -fforce-recomp
02:26:28 <Peaker> Lanjiao: or not use --make, maybe
02:26:55 <int-e> Peaker: yes that's the problem. if you compile the module without -main-is and then try to link with -main-is, linking will fail
02:27:11 <Lanjiao> thanks
02:27:47 <Peaker> int-e: ah
02:28:17 <Lanjiao> Peaker: Yes, it does.
02:30:21 <Lanjiao> Peaker: I think the reason I failed before with -main-is is that as int-e said: if you compile the module without -main-is and then try to link with -main-is, linking will fail
02:30:29 <int-e> Peaker: so what GHC actually does is add an artificial :Main (with a leading colon) module interface to a module when compiling, if the module name matches the -main-is option.
02:32:13 <besiria> error when Building unix-2.3.1.0
02:34:09 <besiria> http://hpaste.org/12277
02:34:41 <besiria> i'm on ghc6.8.2
02:35:06 <int-e> Peaker: and armed with that knowledge it's also possible to trigger the opposite error - B.o: In function `ZCMain_main_srt': (.data+0x68): multiple definition of `ZCMain_main_closure' and so on :)
02:35:35 <Peaker> int-e: Yeah, I see, thanks
02:36:02 <Peaker> int-e: so now only one build mystery remains, why on my x86-64 machine, glut compiles smoothly, but on the x86-32 machine, its configure script does not add -lglut to the ld-options in its package metadata
02:38:16 <SubStack> @pl ($ 3) . ($ 4)
02:38:17 <lambdabot> flip ($ 4) 3
02:38:25 <sm> good morning all.. the time has come, to cross the streams of IO and Parser..
02:38:29 <SubStack> @pl ($ 3) . ($ 4) . ($ 5)
02:38:29 <lambdabot> flip ($ 4) 3 . ($ 5)
02:38:34 <Lanjiao> thanks Peaker and int-e, it's a great place!
02:38:36 <SubStack> that's not really much better
02:38:49 <SubStack> meh
02:38:51 <sm> I'd like to make a date parser which knows the current time. How do I write that ?
02:39:16 <dmwit> parseTime "%h%m"
02:39:31 <sm> I mean, how do I plumb the two monads together ? liftM didn't quite do it
02:39:36 <dmwit> ah
02:39:41 <dmwit> ParsecT IO, then?
02:39:46 <dmwit> :t lift
02:39:47 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
02:39:49 <dmwit> :t liftIO
02:39:50 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
02:40:05 <dmwit> Use liftIO if it works, and lift otherwise.
02:40:19 <besiria> any idea about http://hpaste.org/12277
02:40:33 <sm> great, thank you. Sounds useful, I'll stare at it for a bit
02:40:44 <dmwit> sm: What is the actual monad you're using?
02:40:56 <sm> "Parser"
02:41:05 <dmwit> uh
02:41:31 <dmwit> You're going to either need a monad transformer in there somewhere, or you're going to need to do the IO first and pass in the result as an argument. =)
02:42:17 <sm> this is what I need to learn
02:42:30 <dmwit> ?where allaboutmonads
02:42:30 <lambdabot> I know nothing about allaboutmonads.
02:42:32 <dmwit> ?go all about monads
02:42:40 <lambdabot> http://www.haskell.org/all_about_monads/
02:42:40 <lambdabot> Title: All About Monads
02:42:44 <dmwit> There's a nice section there about monad transformers.
02:43:03 <dmwit> They're not as scary as they sound. =)
02:43:17 <sm> maybe you could tell me, what will be the type signature of dateparserwithcurrenttimeasdefault ?
02:43:45 <dmwit> Well, without knowing a bit more about Parser, it's really impossible to say.
02:43:56 <sm> I have Parser (IO UTCTime) right now, but that's just a guess
02:44:15 <dmwit> You can make that work.
02:44:18 <dmwit> But you shouldn't.
02:44:19 <sm> I think Parser is Parsec's synonym
02:44:31 <dmwit> You should make a ParserT that can wrap any monad.
02:44:41 <dmwit> Then it would be ParserT IO UTCTime.
02:44:46 <dmwit> (notice no parens)
02:44:55 <sm> as my first attempt ? I want the baby step first
02:45:22 <laziest> dmwit: can you wrap around IO monad?
02:45:22 <dmwit> Well... it's probably going to be just as difficult to thread first-class IO actions as it is to just deal with the threading up front.
02:45:28 <dmwit> laziest: Of course.
02:45:31 <dmwit> laziest: IO is a monad.
02:45:49 <sm> ok.. so read up on monad transformers it is
02:46:15 <laziest> dmwit: so can you combine state and IO for instance?
02:46:19 <dmwit> laziest: You should note that, for example, "getLine" does not, by itself, get a line; it's merely a description of an action that gets a line.
02:46:21 <dmwit> laziest: Yes.
02:46:51 <dmwit> laziest: In particular, this means you can pass IO actions around, return them from other IO actions, repeat IO actions, ...
02:46:55 <sm> aren't there some examples of these common transformers somewhere ?
02:47:07 <dmwit> sm: Check out All About Monads.
02:47:21 <dmwit> (Part III)
02:47:46 <sm> ok, thanks
02:48:21 <dmwit> :t return getLine :: IO (IO String)
02:48:22 <lambdabot> IO (IO String)
02:48:31 <dmwit> laziest: ^^
02:48:33 <dmwit> =)
02:48:49 <laziest> ya...
02:49:59 <dmwit> ?unmtl StateT IO s a
02:50:00 <lambdabot> IO -> s (a, IO)
02:50:08 <dmwit> uh
02:50:10 <dmwit> what?
02:50:28 <dmwit> ?unmtl StateT s IO a
02:50:28 <lambdabot> s -> IO (a, s)
02:50:31 <dmwit> ah =)
02:51:03 <dmwit> Anyway, staring at that type should demystify the idea that "IO can be wrapped".
02:51:17 <laziest> Now I have a motivation to enter 'all about monads'
02:51:36 <laziest> I mean the transformer section
02:51:45 <laziest> earlier I had just browsed it...
02:53:42 <laziest> what is ?unmtl ?
02:57:09 <Beelsebob_> can someone with permissions get \bot in #macosxdev please?
02:59:58 <sjanssen> @join #macosxdev
03:00:10 <Beelsebob_> thank you :)
03:00:11 <sjanssen> Beelsebob_: you'll need to ask Cale if you want to make that permanent
03:00:21 <Beelsebob_> okies, will do
03:01:06 <Beelsebob_> "lambdabot: Maximum users seen in #macosxdev: 0, currently: 22 (Infinity%), active: 1 (4.5%)"
03:01:14 <Beelsebob_> Infinity%1
03:01:15 <Beelsebob_> !
03:03:03 <sjanssen> interesting
03:03:08 <sjanssen> @users #macosxdev
03:03:08 <lambdabot> Maximum users seen in #macosxdev: 0, currently: 22 (Infinity%), active: 1 (4.5%)
03:03:17 <sjanssen> lambdabot: @part #macosxdev
03:03:20 <sjanssen> @users #macosxdev
03:03:20 <lambdabot> Maximum users seen in #macosxdev: 22, currently: 0 (0.0%), active: 0 (NaN%)
03:03:27 <Beelsebob_> heh
03:03:33 <sjanssen> lambdabot: @join #macosxdev
03:06:07 <sm> it seems to me that the standard Parsec monad isn't transformer-friendly.. eg no T type
03:06:11 <sm> http://haskell.org/ghc/docs/6.8.2/html/libraries/parsec/Text-ParserCombinators-Parsec-Prim.html
03:06:13 <lambdabot> Title: Text.ParserCombinators.Parsec.Prim, http://tinyurl.com/58jrq6
03:06:53 <sjanssen> sm: yes, the transformer version is in Parsec 2
03:06:59 <dolio> 3.
03:07:08 <sjanssen> oh
03:07:37 <sm> so I shouldn't bother trying to use a transformer in parsec 2 ?
03:07:56 <sm> I should use nested monads instead ?
03:08:41 <sjanssen> sm: does your other monad have a transformed version?
03:09:10 <sm> it's IO, so I guess so
03:10:04 <sjanssen> sm: if it is IO, the answer is "no"
03:11:12 <sm> er to which question ? no to a transformer for IO and parsec 2, right
03:11:55 <sjanssen> sm: there is no transformer version of IO
03:12:13 <sm> ok
03:12:29 <sm> has anyone here written a parser that also uses IO ?
03:23:14 <sm> night all
03:40:42 <idnar> http://neopythonic.blogspot.com/2008/11/scala.html
03:41:49 <SubStack> @pl ((\a b -> [1,2]) 2 3) ++ ((\a b -> [3,4]) 2 3)
03:41:49 <lambdabot> [1, 2, 3, 4]
03:42:32 <SubStack> @pl (\x y -> ((\a b -> [1,2]) x y) ++ ((\a b -> [3,4]) x y))
03:42:33 <lambdabot> ap (ap . ((++) .) . const (const [1, 2])) (const (const [3, 4]))
03:42:44 <Beelsebob_> heh
03:43:55 <ski_> \x y -> [1,2,3,4]
03:46:33 <idnar> or maybe that should be http://www.reddit.com/r/haskell/comments/7f01i/
03:48:43 <SubStack> @pl (\x y -> (foo x y) ++ (bar x y))
03:48:43 <lambdabot> ap (ap . ((++) .) . foo) bar
03:48:57 <SubStack> @pl (\x y -> (foo x y z) ++ (bar x y z))
03:48:57 <lambdabot> ap (ap . ((++) .) . flip flip z . foo) (flip flip z . bar)
03:49:03 <SubStack> blah
03:49:17 <SubStack> @pl (\x y z -> (foo x y z) ++ (bar x y z))
03:49:17 <lambdabot> ap (ap . (liftM2 (++) .) . foo) bar
03:49:19 <SubStack> aha!
04:00:51 <ski_> > (liftM2 . liftM2) (++) ((const . const) [1,2]) ((const . const) [3,4]) x y
04:00:52 <lambdabot>   [1,2,3,4]
04:11:10 <hackage> Uploaded to hackage: tabular 0.1.0.2
04:11:10 <hackage> Uploaded to hackage: infinite-search 0.10
04:15:25 <niklaus> if i have a long (1 million) sequence of numbers and i want to find the maximum consecutive sum + length of the interval = f(a,b) = csum(a) - csum(b) + a-b , csum is cummulative sum. ans(a,b) = max(f(i,j) ) for all a>= i>=j>=b, which is the best structure to use for this problem
04:19:08 <Taejo> I thought some haskellers might be interested in my (mathematical) webcomic, indiscreet-mathematics.blogspot.com
04:21:56 <RayNbow> for the love of lazy people, prefix that URL with http:// so it's clickable ;)
04:22:15 <Taejo> RayNbow: sorry. http://indiscreet-mathematics.blogspot.com
04:22:22 <lambdabot> Title: Indiscreet Mathematics
04:24:41 <vixey> funny
04:24:58 <Zao> slightly amusing.
04:25:22 <Taejo> Zao: I am bowled over by your enthusiasm :)
04:25:40 <vixey> I like that last one "If this wasn't a lattice we may never have met"
04:26:00 <Taejo> vixey: thank you
04:26:13 <Taejo> my own favourite is Juggling
04:27:25 <RayNbow> http://indiscreet-mathematics.blogspot.com/2008/11/zeta.html <-- I recognise this situation for a different letter :p
04:27:26 <lambdabot> Title: Indiscreet Mathematics: Zeta
04:27:45 <Taejo> RayNbow: which letter?
04:28:02 <RayNbow> Î¾
04:28:42 <vixey> Xi
04:28:56 <Taejo> that's what every numerical-algorithms student wants to know :) -- at least, it came up when I did NA
04:28:56 * RayNbow nods
04:29:45 <RayNbow> students should know the Greek alphabet by heart :p
04:30:19 <Taejo> I don't mind reading them as long as they aren't both used. Writing them, on the other hand, I do s/Î¶/w/g
05:03:44 <Peaker> FieldTrip has  type Image o = (R, R) -> o        for 2D images. With this kind of type, how can you make use of OpenGL optimizations and such?
05:06:04 <Peaker> Functions are opaque, I don't think interfaces should commit to creating functions.. They should create applicatives, or arrows, or such, that can be represented as functions today, and translated into interesting data structures that utilize OpenGL optimizations later
05:06:46 <EvilTerran> images as arrows (x,y) ~> pixel is an interesting thought
05:07:06 <Beelsebob_> EvilTerran: the generalisation from Pixel to a is very useful
05:07:23 <Beelsebob_> it's very nice to be able to <*> an image of transformations over an image of pixels for example
05:07:36 <Beelsebob_> which results in moving all the pixels about in different directions
05:07:40 <Beelsebob_> (yay, we have photoshop filters)
05:09:56 <Beelsebob_> Peaker: also, function is a pretty useful type if you happen to have a compileToPixelShader function
05:10:23 <Peaker> Beelsebob_: that takes a function? Using compiler-magic?
05:10:40 <arjanb> Peaker: i think modern vidoecards could do pretty well in running creating functions
05:10:44 <Beelsebob_> I've not seen the exact interface for ivan's shader compiler
05:10:46 <Beelsebob_> we'll see
05:11:50 <Peaker> Beelsebob_, arjanb: Wouldn't it be better to compute computations in some points-free manner, to form a data structure that a normal library can compile, than to form Haskell functions and then use deep magic to compile that?
05:12:01 <Peaker> s/compute computations/combine computations
05:14:25 <Philippa> Peaker: Applicatives etc have functions in them too, they're still too opaque
05:15:08 <Peaker> Yeah, someone ought to popularize the Arrow-without-arr formally, instead of hackish arrow-without-de-facto-arr extensions ...
05:15:44 <Philippa> Someone wrote the lib, it just got a really bad name
05:16:17 <idnar> what's up with arr?
05:16:30 <Peaker> Philippa: what's that?
05:16:55 <Peaker> idnar: arr lets you convert a turing-complete opaque function into an arrow.. That means you can't have completely non-opaque arrows
05:17:05 <Philippa> DeepArrow
05:17:09 <idnar> @type arr
05:17:10 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
05:17:29 <Peaker> Philippa: DeepArrow doesn't really get rid of arr.. everything starts by _extending_ arrows, when we need to replace them, no other way to get rid of arr
05:17:39 <idnar> I still haven't quite wrapped my head around arrows, but that's probably just because I haven't seen a practical use-case
05:17:45 <Philippa> Peaker: yes it does, it's just that it's also a tad hackish - the arr in it's bogus
05:17:47 <idnar> (only potential use cases)
05:18:12 <Philippa> it implements Arrow but not the Arrow contract, the actual intention was exactly what you're asking for but with the sugar support
05:18:24 <Philippa> (and now you can see why it's badly named)
05:19:05 <Peaker> idnar: I think an ArrowLoop/ArrowChoice without arr can let you formulate computations that are entirely visible to a library, which is useful for optimizations or compiling to run where a Haskell evaluator is not available
05:20:17 <Peaker> we're stuck in a local peak of having all this infrastructure around a wrong formulation of arrows, and we can't escape, evolutionarily
05:20:19 <Philippa> Peaker: next thing you know, you're replacing Num
05:20:28 <Peaker> Philippa: That too, should be fixed :P
05:20:31 <Philippa> it's not a wrong formulation. It's a formulation that isn't the thing you wanted
05:20:39 <Peaker> but probably with class aliases
05:21:14 <Peaker> Philippa: its probably safe to say the arrow extensions that are "without arr in spirit" are wrongly formulated (since Haskell allows specifying that type-safely)
05:21:54 <Philippa> yes, they are
05:22:30 <Philippa> but really, can you be a bit more careful about yelling "this is wrong!" from a 2008 knows-everything point of view?
05:22:32 <Peaker> Beelsebob_: say, why does field trip only let me assign materials (for colors, etc) to Geometry3's, and not Geometry2's?
05:22:46 <Beelsebob_> hmm, good question that
05:23:08 * Philippa suspects "because nobody thought to implement it"
05:23:14 <Peaker> Beelsebob_: how does one draw colorful 2d graphics without coercing it to Geometry3?
05:23:27 <Peaker> Beelsebob_: or if its supposed to be coerced, why have Geometry2 at all?
05:23:52 <Beelsebob_> Peaker: you'd have to ask conal
05:24:00 <Peaker> Philippa: I didn't mean that the guys who did any of that were fools.. I think pretty much every part of Haskell is _brilliantly_ designed :)
05:24:33 <Peaker> Obviously less attention was spent on some things (*ahem* records *ahem*), but still :-)
05:24:48 <Philippa> Peaker: records are a case where it was fully intentional, though
05:25:06 <Philippa> the situation you're talking about now isn't actually wrong in any meaningful sense, DeepArrow&relatives aside
05:25:12 <Philippa> it's not ideal, sure
05:25:40 <Peaker> Classes have too broad a granularity for clear practical concerns.. It seems as though class aliases are required to have the right kind of granularity and still having usability
05:25:59 <shapr> I disagree.
05:26:05 <shapr> I think compositional classes would be better.
05:26:22 <Peaker> shapr: I wasn't aware of alternatives to class aliases.. What are compositional classes?
05:26:30 <shapr> They're something I made up.
05:27:17 <shapr> If you could refer to several classes by a single name, or if you could decompose a large complicated class into smaller chunks, classes would be more flexible.
05:27:17 <Philippa> Peaker: you realise you're wandering into genuine research territory, right? The entire concept of type classes was created during the process of designing Haskell, there was no predecessor
05:28:11 <Philippa> shapr: prod me into implementing PrenexF=> and you'll have a chance to try that out :-)
05:28:14 <shapr> In my experience, classes have just the right granularity, sometimes... then sometimes it's too much or too little. I think it depends on what level of abstraction you want to look at right now.
05:28:34 <Philippa> I think Peaker meant classes as a metaabstraction, not individual classes as abstractions
05:28:37 <shapr> Philippa: hey, implement PrenexF
05:28:42 <Philippa> already done that
05:29:03 <Philippa> admittedly there's no interpreter and no parser or pretty-printer beyond deriving Show/Read, but it's implemented
05:29:10 <Philippa> PrenexF=> != PrenexF though
05:29:30 <Peaker> shapr: " If you could refer to several classes by a single name, or if you could decompose a large complicated class into smaller chunks, classes would be more flexible." --> Isn't that what class aliases do?
05:29:56 <shapr> Peaker: You have to do it yourself though, right?
05:30:28 <Peaker> shapr: You specify the grouping, and iirc, default implementations in such groups
05:31:19 <Peaker> shapr: In what cases do you find the classes are too little (too much granularity)? My short experience is that its too coarse-grained
05:33:35 <shapr> Peaker: It depends on what level of abstraction you want at that moment. Sometimes you want a Num, sometimes you want a Semigroup.
05:37:46 <Peaker> shapr: I'm looking for a counter-example.. if I understand that correctly, its another example
05:38:35 <shapr> Too much granularity: Is there a semigroup class in the standard hierarchy right now?
05:39:07 <Peaker> semigroup would be something smaller than Num, wouldn't it?
05:39:15 <shapr> Yup
05:39:25 <Peaker> well, its lack means there's too little granularity then?
05:39:38 <shapr> er right
05:39:48 <shapr> I was thinking large grains.
05:40:54 <Peaker> I think an example of too little granularity would probably mean repeatedly using (Num a, Monoid a, Bleh a)
05:41:31 <shapr> I use (Read a, Show a, Eq a, Enum a) pretty often.
05:41:43 <pao> hi all
05:41:56 <shapr> hi pao
05:41:59 <shapr> How's code?
05:42:09 <Peaker> And creating a class (Read a, Show a, Eq a, Enum a) => Blah a where {}   would be a real bad idea, because you'd have to instantiate everyone who happens to have these
05:42:15 <pao> does there exists an event-driven framework for haskell?
05:42:21 <Peaker> so that's a good example of too much granularity, yeah
05:43:13 <Peaker> pao: Yeah, but for some reason, Haskell threads are preferred (at least for parallelism), and FRP is where the future/hype is at :)
05:43:39 <pao> Peaker: FRP?
05:43:45 <Peaker> pao: Functional Reactive Programming
05:43:52 <pao> Peaker: yep
05:44:02 <Peaker> pao: See the Reactive library, I can point you to dolio's tutorial, too
05:44:17 <pao> Peaker: let me google for it...
05:45:28 <Peaker> pao: if you haven't found it: http://netsuperbrain.com/blog/posts/introducing-reactive-events/
05:45:34 <lambdabot> Title: Less Sugar/More Meat Â» Blog Archive Â» Introducing Reactive: Events
05:45:49 <pao> Peaker: thank you! :-)
05:50:50 <pao> Peaker: wow :-)
05:51:02 <hawksen> hey
05:51:17 <Peaker> pao: impressed with FRP? :)
05:51:28 <pao> Peaker: definitely
05:53:06 <Peaker> its definitely a cool alternative to IO
05:56:14 <pao> Peaker: the problem with IO and Threads is locking... how do you syncronize accesses to a shared resource
05:56:46 <Peaker> pao: with FRP you don't "do" anything, you only describe relationships, so there's no problem
05:57:02 <Peaker> pao: also, in IO there are alternatives to locking (transactions) but those have problems too
05:57:05 <vixey> That is a description of declarative programming in general
05:57:27 <vixey> is FRP simply declarative IO? or is there more important detail?
05:57:38 <Beelsebob_> FRP doesn't have to be about IO at all
05:57:48 <Beelsebob_> FRP is about describing any computation that happens over time
05:57:52 <Peaker> vixey: I'd describe it as declarative reactive programming, pretty much.. I don't think anything else managed to do that..
05:58:08 <Beelsebob_> one such useful thing to describe is IO
05:59:19 <Peaker> JavaFx, btw, is a "step" towards FRP (the same step I made in my GUI toolkit attempts too).. FRP takes a few steps further and eliminates imperativeness altogether (JavaFx still has imperative callbacks on events)
06:00:40 <hawksen> i find out that i can read the keyboard input in hasekll with input <- getLine, but how can i find out which key the user pressed? if it was a char, its easy, i only have to compare it with for example 'd', but how do i get to know that the pressed key was for example the left arrow key on the keyboard? thx
06:01:10 <vixey> hawksen, you can't do that with getLine
06:01:23 <hawksen> oh, okay, thanks
06:01:32 <Peaker> hawksen: getLine does not really read keyboard input, but some translation of that. If you want direct access to keyboard input you're going to have to use some lower-level access to user input.. A terminal library, or a graphics/UI library
06:01:48 <vixey> don't go lower level than getLine :(
06:02:00 <Badger> heh
06:02:03 <Peaker> side-ways, not lower :)
06:02:05 <Peaker> Surely ncurses and the likes have Haskell wrappers
06:02:11 <Peaker> @where ncurses
06:02:11 <lambdabot> I know nothing about ncurses.
06:02:18 <Peaker> @package ncurses
06:02:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ncurses
06:02:26 <vixey> don't recommend people use ncurses!
06:02:35 <vixey> They may end up actually doing that
06:02:38 * Badger curses vixey 
06:02:55 <Peaker> hawksen: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nanocurses -- will let you do that in the terminal
06:02:59 <hawksen> okay, thanks, i will take a look at this
06:03:00 <lambdabot> Title: HackageDB: nanocurses-1.5.2, http://tinyurl.com/6m4zht
06:03:19 <Peaker> hawksen: but if you want more "advanced" UI interaction, maybe you should consider SDL or such
06:04:07 <Pellwurst> what is the reason for a "Pattern match(es) are overlapped"-Warning?
06:04:21 <vixey> Pellwurst, because they didn't implement view patterns properly
06:04:49 <vixey> or maybe you have get two equations with the same/similar patterns
06:05:45 <vixey> How do you turn an emacs buffer into HTML?
06:05:47 <vixey> oops
06:05:54 <vixey> I didn't mean to ask that here.......
06:22:28 <samphippen> if I want to write a function that prints out all the multiplications my factorial function does, what do I do?
06:23:08 <Peaker> samphippen: you could use Expr :-)
06:23:23 <samphippen> Peaker, my haskell isn't brilliant, could you link me?
06:23:27 <Peaker> > foldr (*) 1 [1..5] :: Expr
06:23:29 <lambdabot>   1 * (2 * (3 * (4 * (5 * 1))))
06:23:52 <Beelsebob_> > foldr (\x y -> seq (unsafePerformIO (putStrLn (concat [show x, " * ", show y, " = ", show (x * y)]))) x * y) 1 [1..5]
06:23:53 <lambdabot>   Not in scope: `unsafePerformIO'
06:23:56 <skorpan> i have a list of functions fs and a single argument x. i want to get a list [f1 x, f2 x, f3 x, ...]. is there any builtin function for this?
06:23:57 <Beelsebob_> aww :(
06:24:10 <EvilTerran> skorpan, map ($x) fs?
06:24:17 <skorpan> hm, maybe
06:24:24 <EvilTerran> > map ($x) [f,g,h] :: [Expr]
06:24:25 <lambdabot>   [f x,g x,h x]
06:24:30 <skorpan> cool thanks
06:24:31 <Peaker> samphippen: Expr is something that has instances of Num and other stuff, and builds up a big expression that describes what happened
06:24:40 <EvilTerran> > ($ x) f :: Expr
06:24:40 <idnar> > sequence [f,g,h] x :: [Expr]
06:24:41 <lambdabot>   f x
06:24:42 <samphippen> right
06:24:42 <lambdabot>   [f x,g x,h x]
06:24:55 <idnar> (don't use my version, it's obscure :P)
06:25:00 <EvilTerran> sequence works too, yeah, but is rather more arcane
06:25:25 <EvilTerran> and would require Control.Monad.Instances
06:25:43 <samphippen> i'm confused
06:25:59 <samphippen> I have factorial n as a function
06:26:11 <samphippen> how do I evaluate it?
06:27:04 <Raevel> factorial someN
06:27:17 <samphippen> yes
06:27:32 <samphippen> what I mean is evaluate what multiplications are done
06:28:04 <EvilTerran> samphippen, what output do you want for, say, "factorial 5"?
06:28:15 <Raevel> you mean, you want to see that  fac 3 turns into 3*2*1*1 ?
06:28:28 <samphippen> 5*factorial(4); 5*4*factorial(3); ...
06:28:48 <EvilTerran> ah, that's what hat does, if you can get it working
06:28:50 <EvilTerran> @where hat
06:28:50 <lambdabot> http://www.haskell.org/hat/
06:29:09 <Raevel> wow, that's cool
06:29:28 <EvilTerran> it does it after-the-fact based on an evaluation log, iirc
06:30:05 <Peaker> except conal, does anyone know anything about FieldTrip here?
06:30:38 <Peaker> How to create a wide 2d line from an ordered list of 2d points, for example?
06:37:22 <vixey> samphippen, in haskell_
06:37:23 <vixey> ?
06:37:46 <zimbatm> hello
06:37:49 <vixey> hi
06:38:10 <zimbatm> I'm seeking for some help with string handling in haskell
06:38:19 <samphippen> vixey, hello
06:38:21 <vixey> ok
06:38:23 <samphippen> vixey, what do I do
06:38:23 <vixey> hi
06:38:33 <vixey> I don't know
06:38:46 <vixey> Do you want to know which order haskell evaluates the factorial?
06:38:59 <samphippen> no, I just want to see which calculations it does
06:39:07 <samphippen> i then want to extend it to other functions
06:39:11 <vixey> I don't know what it is you mean
06:39:32 <Peaker> Did anyone write a paper/article about _incrementally_ improving OO languages until they become Haskell? :)
06:39:34 <vixey> hmm
06:40:22 <zimbatm> how do you decompose a string, for example taking the first five chars ? Treating is as a list, with the (x:xs) construct doesn't work.
06:40:42 <vixey> zimbatam, take 5
06:40:50 <vixey> example:
06:41:02 <vixey> > take 5 "fivesixeseven"
06:41:03 <lambdabot>   "fives"
06:41:11 <vixey> @src take
06:41:11 <lambdabot> take n _      | n <= 0 =  []
06:41:11 <lambdabot> take _ []              =  []
06:41:11 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
06:41:20 <vixey> it uses recursion on the number 'n'
06:41:22 <Philippa> zimbatm: treating it as a list should work fine
06:41:31 <zimbatm> yay
06:41:32 <Philippa> not least because it is one
06:41:34 <vixey> or does it ....
06:41:41 <Feuerbach> > splitAt 5 "fivesixeseven"
06:41:42 <lambdabot>   ("fives","ixeseven")
06:41:45 <zimbatm> ... must have done something wrong then
06:43:37 <zimbatm> thx, brb
06:45:37 <idnar> @type (>=>)
06:45:38 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:46:06 <idnar> @type (<=<)
06:46:07 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
06:48:28 <RayNbow> hmm, two new Monad movies posted on Channel9
06:53:02 <czShadoW> @src reverse
06:53:02 <lambdabot> reverse = foldl (flip (:)) []
06:53:33 <Peaker> @type foldl
06:53:34 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:53:35 <Peaker> @type foldr
06:53:36 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:54:09 <Peaker> I'd say foldl :: (b -> a -> b) -> b -> [a] -> b
06:54:24 <Peaker> (for easier comparison)
07:02:45 <dcoutts> Lemmih: I'm going to use a different fix for your LHC hack in cabal-install
07:03:09 <dcoutts> Lemmih: and the LHC support will be in Cabal HEAD, 1.7.x dev series but not stable 1.6.x series. Hope that's ok.
07:05:51 <zimbatm> what is the simplest way to parse an integer in a string with haskell ?
07:06:12 <dcoutts> > read "3" :: Int
07:06:13 <lambdabot>   3
07:06:38 <samphippen> > factorial 4
07:06:39 <lambdabot>   Not in scope: `factorial'
07:06:44 <samphippen> > factorial 1 = 1
07:06:45 <lambdabot>   <no location info>: parse error on input `='
07:07:06 <vixey> :t parseInteger
07:07:08 <lambdabot> Not in scope: `parseInteger'
07:07:11 <vixey> @hoogle integer
07:07:12 <lambdabot> Text.Parsec.Token integer :: GenTokenParser s u m -> ParsecT s u m Integer
07:07:12 <lambdabot> Text.PrettyPrint.HughesPJ integer :: Integer -> Doc
07:07:12 <lambdabot> Language.Haskell.TH.PprLib integer :: Integer -> Doc
07:07:21 <vixey> :t parse integer
07:07:22 <lambdabot> Not in scope: `parse'
07:07:31 <zimbatm> thanks dcoutts
07:07:32 <vixey> :t Text.Parsec.parse Text.Parsec.Token.integer
07:07:33 <lambdabot> Couldn't find qualified module.
07:07:36 <vixey> :
07:08:19 <zimbatm> vixey, I have seen the parsec module but it's a bit too complicated for me for the moment
07:08:50 <vixey> zimbatm, it is not too complicated for you :)
07:10:07 <zimbatm> I said "for the moment" :-p
07:11:36 <vixey> zimbatm, if you import the right things you can use:  parse (integer haskell) "" "12314"
07:11:48 <vixey> which gives you Left and an error message or Right and an Integer
07:12:06 <vixey> if you already knew for sure the string will parse correctly then using read is fine of course
07:13:22 <zimbatm> actually it's one of the project-euler problems
07:13:32 <Peaker> Does anyone know how to take a Curve2 s (type Curve2 s = One s -> Two s, type One a = a, type Two a = (a,a))  and make a Geometry2 out of it?
07:13:38 <Peaker> (Fieldtrip)
07:14:50 <zimbatm> so I know the input is right
07:15:22 <zimbatm> list comprehension is my all time favourite
07:16:20 <gio123> is here somebody who is native speaker of english?
07:16:24 <zimbatm> only I wish it would be possible to early-exit on infinite lists
07:16:49 <dcoutts> gio123: just ask your question, don't keep asking if you can ask your question.
07:17:15 <dcoutts> zimbatm: but it is, the list comprehension is generated lazily.
07:18:16 <dcoutts> zimbatm: so you can select a finite prefix of your infinite list comprehension
07:18:40 <zimbatm> dcoutts, let's say you have that lazy-generated list of primes in a list
07:19:04 <zimbatm> and want to build another list, where primes are smaller than 10'000
07:19:25 <zimbatm> like : [ dosomethingwith x | x <- primes, x < 10000 ]
07:19:37 <ziman> > takeWhile (<10000) [1,1000..]
07:19:38 <lambdabot>   [1,1000,1999,2998,3997,4996,5995,6994,7993,8992,9991]
07:19:46 <dcoutts> zimbatm: right, you've got to take advantage of special knowledge there, that the sequence is increasing
07:20:03 <dcoutts> and you can't do that with a generic filter
07:21:06 <zimbatm> okay, takeWhile looks fine
07:21:25 <dcoutts> yes, it's exactly what you want
07:21:52 <zimbatm> those higher-order functions are so great to avoid recursion
07:22:29 <aeolist> i say embrace that recursion
07:23:35 <zimbatm> but then I tend to go shopping for those functions, hoping to find one that already solves my problem :-p
07:26:15 <zimbatm> what do you think of that code ? : http://hpaste.org/12282
07:26:25 <zimbatm> it's solution for projecteuler problem n° 8
07:27:07 <Peaker> This doesn't add up in FieldTrip's code, how does it typecheck?
07:27:07 <Peaker> http://hpaste.org/12283
07:27:49 <Peaker> move3X wants a Geometry3 as 2nd arg but is given an (s,s)->(s,s,s) instead, but it compiles..?
07:31:18 <zimbatm> haskell is my new drug
07:31:29 <samphippen> > 3^4
07:31:30 <lambdabot>   81
07:31:47 <Peaker> oh! torus is defined in Geometry3 as well
07:33:15 <Peaker> conal: hey
07:33:36 <Peaker> conal: Toying with your FieldTrip work.. Seems so awesome, yet has a pretty steeeeep learning curve..
07:35:06 <Peaker> I'm trying to figure out how to take the Surf representation of a 2d circle and create a Geometry2 or Geometry3 out of it
07:36:26 <conal> Peaker: hi.  i don't anything tutorial about FieldTrip yet.  there's just the examples for torus etc.
07:36:51 <Peaker> conal: Yeah, it seems to lack functions to work with Geometry2's (for example, assigning materials/colors to them)
07:37:13 <Peaker> conal: And I have to reverse engineer your mathematical abstraction tower :)
07:37:57 <conal> Peaker: oh, yeah. sry about that. in a pretty early stage.  would you please file fieldtrip tickets as you go?  http://trac.haskell.org/FieldTrip/report/1?sort=ticket&asc=1
07:38:08 <lambdabot> Title: {1} Active Tickets - FieldTrip - Trac
07:38:43 <conal> Peaker: doesn't have to be "bugs" in the classical sense.  anwhere you'd like more functionality or more explanation.
07:38:48 <conal> *anywhere
07:39:23 <Peaker> conal: sure.. Can you help me write the 1-liner of converting the "circle :: Surf2 s" to a Geometry2 or Geometry3?
07:40:29 <conal> Peaker: happy to.  how about in 20 minutes?
07:41:19 <dcoutts> Lemmih: would you mind sending a patch to clean up the warnings in the LHC module? It will not build in ghc's build system since it makes warnings fatal for core libs like Cabal.
07:41:31 <dcoutts> Lemmih: btw, where can I get LHC from?
07:41:31 <Peaker> conal: great, thanks!
07:45:05 <Feuerbach> dcoutts: any progress with System.Glib.UTFString issue? (http://hackage.haskell.org/trac/gtk2hs/ticket/1099) (just stumbled over it)
07:45:07 <lambdabot> Title: #1099 (build errors on Glib.UTFString) - Gtk2Hs - Trac
07:46:22 <Peaker> heh, I got the type right with "FT.surfG (FT.revolve FT.circle)" but its super slow and not exactly what I'd expected :)
07:47:29 <dcoutts> Feuerbach: no, we've not figured it out. You'll notice in your gtk2hs-config.h file that _GLIB_MICRO_VERSION is #define'ed as (), rather than a number like (2)
07:47:46 <dcoutts> Feuerbach: and we have not figured out why that is happening. It does not happen for everyone.
07:48:01 <dcoutts> Feuerbach: if you'd like to investigate I'm sure that'd be useful.
07:48:21 <Peaker> okay, the tesselation is probably taking ages...
07:48:51 <thoughtpolice> dcoutts: http://lhc.seize.it/
07:48:58 <lambdabot> Title: Wiki - Front Page
07:49:36 <Feuerbach> dcoutts: actually, it's defined as (0)
07:49:58 <dcoutts> Feuerbach: ok, then check the other similar ones, there should be one of them defined as ()
07:51:10 <Feuerbach> dcoutts: there isn't..
07:52:34 <dcoutts> Feuerbach: and you still get the cpp error about '(' ')' ?
07:52:54 <Peaker> is there a float-modulu?
07:53:38 <Peaker> a more general modulu than of integrals? Perhaps on all Num, or Floating?
07:53:40 <dcoutts> Feuerbach: perhaps you could hpaste the error and your gtk2hs-config.h
07:54:51 <Feuerbach> dcoutts: heh, it seems like different error indeed. "Module `Control.Exception' does not export `throwDyn'". I'll paste it
07:55:28 <dcoutts> Feuerbach: ah, are you building the released tarball with ghc-6.10?
07:55:41 <dcoutts> Feuerbach: if you're using 6.10 then I think you have to use the darcs version
07:56:24 <Feuerbach> dcoutts: yes, it's 6.10. Thanks for the tip
07:56:46 <Peaker> Another cute ghci fieldtrip example: Prelude Graphics.FieldTrip Control.Applicative FRP.Reactive FRP.Reactive.FieldTrip.Adapter> anim3 $ const $ (\t -> rotate3 t (Vector3 t 0 1) *% ((materialG (flat red) . flatG) $ box2 (1/t) (1/t))) <$> sin <$> time
08:01:04 <vixey> oo
08:01:12 <vixey> "side effects - the 'goto' of data'
08:01:42 <Peaker> There are a few parallels that can be found :)
08:09:27 <Pellwurst> how can I cast an Integer to a String?
08:09:33 <thoughtpolice> Lemmih: ping?
08:09:58 <Peaker> Pellwurst: define "cast"
08:10:22 <Peaker> Pellwurst: You probably mean show?
08:10:51 <Peaker> Does this kind of join exist: Reactive (Behavior a) -> Behavior a ?   Hoogle sucks on the Reactive libraries :-(
08:11:04 <Pellwurst> Peaker: thats it...thx
08:11:11 <hackage> Uploaded to hackage: lub 0.0.4
08:11:11 <hackage> Uploaded to hackage: unamb 0.1.3
08:12:30 <conal> i woke up this morning remembering that i'd forgotten to release the latest unamb and lub to go my my latest blog posts (http://conal.net/blog).
08:12:36 <conal> Peaker: back.
08:13:20 <Peaker> conal: given that "switcher :: Behavior a -> Event (Behavior a) -> Behavior a" exists, surely Reactive (Behavior a) -> Behavior a  could also exist?
08:13:25 <chessguy> conal, what would be some realistic uses of partial values?
08:13:47 * chessguy gets in line
08:14:11 <conal> chessguy: trying different approaches to solving a problem and allowing each to contribute what it can when it can.
08:14:43 <chessguy> hrm. such as?
08:14:53 <conal> Peaker: interesting .. hm...
08:15:10 <conal> Peaker: agreed.
08:15:18 <conal> Peaker: you're getting to something, right?
08:15:26 <Peaker> conal: Initial thoughts about a modal game
08:15:42 <conal> oh..  i thought it was about the missing behavior monad.
08:16:31 <Peaker> conal: I'm trying to rewrite a Python game I wrote, which was a ripoff of an early 90's game called Pyun.  the game needs to draw a lot of little shapes right next to each other (the number of shapes only grows), and later do collision detection between them.. So I wanted to draw little circles, but it seems there's no Geometry2 circle maker
08:16:51 <ka> What does ' mean in Haskell?  e.g. functionname' = ...
08:16:51 <Peaker> It was called Pune, mine was in Python so was called Pyun, heh
08:17:02 <Peaker> ka: its just a valid symbol in names, like a letter
08:17:04 <conal> Peaker: yeah.  that function could be in Reactive, though Reactive (perhaps ironically) doesn't export the type Reactive
08:17:27 <chessguy> ka, foo' is generally a stricter version of foo, but only by convention
08:17:31 <Riastradh> ka, it has no special meaning to Haskell; it indicates a variation on the theme of the name.  Pronounce it `prime', as in mathematics.
08:17:31 <ka> Peaker: hmm, is there a convention.. ah.
08:17:33 <Peaker> conal: Oh, I didn't know that :-) makes sense though
08:17:45 <ski_> thoughtpolice : what does `lhc' stand for, and how is it related to `jhc' (if at all) ?
08:17:46 <Peaker> conal: I conflated implementation with interface as I read about both :)
08:17:57 <chessguy> ka, or sometimes a similar but different thing to foo
08:18:31 <conal> Peaker: for the Reactive announcement & release, i reworked the modules to make the difference much clearer.
08:19:11 <Peaker> conal: so, what's an easy way to draw small circles?  I tried using spheres, but tessalation there seems to take ages (it takes _seconds_ to initialize)
08:19:12 <conal> Peaker: it'd be easy to whip up a function to do 2D shapes like circle.
08:19:27 <dcoutts> ka: like: let x' = x + 1 in ...
08:19:35 <conal> Peaker: do you want a *disk* (filled) or a circle (empty)?
08:19:43 <Peaker> conal: a disk
08:19:50 <dcoutts> ka: indicating a relationship between an old and new instance of something, like you say, just a convention
08:19:55 <conal> okay, good.  we can do that.
08:20:09 <Peaker> conal: well, I don't really completely understand TypeCompose, vector-space, etc, and it seems that they're a pre-requisite to understand the parameter surfaces and their use
08:20:09 <conal> Peaker: if you don't mind it being Geometry3, you can do it now.
08:20:21 <Peaker> conal: sure, I'm already in Geometry3 because Geometry2 seems to lack basic functions
08:20:29 <conal> Peaker: i don't think you'll have to understand any of that stuff.
08:20:58 <dcoutts> thoughtpolice: so do you know about lhc then?
08:21:03 <conal> Peaker: first job: define a disk as a Surf, i.e., Two a -> Three a
08:21:10 <conal> (a,a) -> (a,a,a)
08:21:24 <Peaker> conal: That part I understood, just didn't understand how these related to the Geometries
08:22:08 <Feuerbach> dcoutts: another error I get with gtk2hs: http://hpaste.org/12284
08:22:30 <conal> Peaker: you can imitate the definition of usphere
08:22:49 <ka> Is 'in' a keyword of haskell?
08:23:01 <Peaker> conal: udisk might be what I was looking for (didn't know I was looking for a disk)
08:23:05 <conal> Peaker: which you'll understand mor fully if learn about derivative towers.
08:23:09 <vixey> > let x = in in x
08:23:09 <lambdabot>   <no location info>: parse error on input `in'
08:23:13 <dcoutts> Feuerbach: check ghc-pkg list -f gtk2hs/package.conf.inplace, that's shorter than the entire content
08:23:23 <conal> Peaker: oh.  i forgot i made udisk.
08:23:36 <Peaker> conal: I intend to learn all about your Haskell libs.. Insane generalizations :-)
08:23:48 <conal> :) (:
08:24:49 <Feuerbach> dcoutts: no glib there
08:24:54 <conal> Peaker: okay, so udisk is your friend.  still, i'd expect a Surf-based version to be simple and efficient.  i'd like to know what you tried that was slow or difficult.
08:25:01 <Feuerbach> only     {gnomevfs-0.9.13}, {gstreamer-0.9.13}
08:25:41 <dcoutts> Feuerbach: try deleting the file and making again. I expect something went wrong earlier.
08:26:01 <Peaker> conal: I tried sphere and (revolve circle), but it takes 1-3 seconds to start up when I use those
08:26:19 <conal> Peaker: hm.  how's torus?
08:27:11 <conal> Peaker: and are you using a compiled FieldTrip lib?  (probably, if you're playing via reactive-fieldtrip)
08:27:20 <Peaker> conal: torus also takes a few seconds
08:27:36 <Peaker> conal: Yeah, I've compiled everything, afaik
08:28:00 <conal> Peaker: yeah, you'd have to go out of your way *not* to be using FieldTrip compiled
08:28:08 <conal> and it's -O2
08:28:57 <Peaker> conal: how do you do the tessalation? Is a few seconds at startup worth a bug report?
08:30:15 <Peaker> conal: btw: I think "Animation" implies (Behavior Geometry3), but not UI ->..  Maybe RAnim vs Anim ? (Reactive Animation)
08:30:17 <conal> Peaker: i'd say yes it is.  it's much faster on my computer, which is two years old.
08:30:49 <conal> Peaker: yeah.  thx.
08:31:36 <conal> Peaker: i agree.  i'll change it.
08:31:50 <chessguy> conal, by the way, the second link in your blog post is broken
08:32:13 * conal looks ...
08:32:22 <conal> chessguy: which post?
08:32:36 <chessguy> http://conal.net/blog/posts/merging-partial-values/
08:32:37 <conal> chessguy: nm
08:32:37 <lambdabot> Title: Conal Elliott Â» Merging partial values
08:32:40 <conal> tx
08:34:06 <papermachine> FieldTrip requires GHC 6.10?
08:34:28 <Peaker> conal: I can't attach files to tickets, "trac internal error"
08:35:11 <conal> Peaker: oh.  i guess you're the first to try.  any more info with that message?
08:36:06 <conal> chessguy: link fixed now.  thanks a bunch.
08:36:18 <conal> papermachine: yes, because vector-space does.
08:36:24 <Peaker> conal: OSError: [Errno 13] Permission denied: '/srv/trac/FieldTrip/attachments/ticket'
08:36:25 <papermachine> ah, okay
08:36:27 <chessguy> sure thing
08:36:45 <conal> Peaker: did you register?
08:36:50 <conal> Peaker: on the trac?
08:36:53 <Peaker> conal: yeah
08:37:08 <conal> i'll look at the permission lists.  maybe something is missing.
08:37:20 <Peaker> conal: are trac users unix users?
08:37:33 <conal> Peaker: i don't think so.
08:37:34 <Peaker> conal: I think they aren't, so an OS permission denied like that cannot be a trac-user issue
08:37:48 <conal> oh -- good point.  thx.
08:38:01 <Peaker> conal: the python traceback is showing it tried to mkdir in there
08:38:16 <gwern> 'It's so cold that I have to compile ghc to heat the room.' 'The heat is what they call a side-effect.' http://www.reddit.com/r/programming/comments/7f07k/its_so_cold_that_i_have_to_compile_ghc_to_heat/
08:38:18 <lambdabot> Title: It's so cold that I have to compile ghc to heat the room. : programming, http://tinyurl.com/5vj2gz
08:38:27 <conal> Peaker: would you paste or email me the traceback?
08:39:00 <chessguy> conal, it seems like a next step to partial values would be patterns
08:39:14 <conal> chessguy: hm.  interesting.
08:39:25 <Peaker> conal: emailed
08:39:32 <conal> Peaker: thanks again!
08:39:56 <chessguy> so in your (Integer, Bool) example, you could also have something like 'even' in the first slot
08:40:14 <conal> chessguy: i like that idea a lot
08:40:24 <chessguy> it may make the ordering more difficult
08:40:25 <ski_> are you inventing constraint programming ?
08:40:36 <Peaker> Does FieldTrip support importing 2d images as textures or otherwise?
08:41:18 <conal> Peaker: i'm unsure.  i think andy gill added such a thing, and i've seen it on youtube, but i haven't seen the code.
08:41:57 <conal> Peaker: keep those tickets coming
08:42:23 <conal> Peaker: i forget things
08:46:28 <chessguy> conal, another idea would be some representation of relationship between components of values
08:47:14 <chessguy> e.g., you don't know what fst x is, but you know snd x == 2 * (fst x)
08:49:56 <vixey> chessguy, you want to express relations between values in types ?
08:50:36 <chessguy> vixey, sort of
08:50:52 <chessguy> i don't know how practical it is
08:52:04 <xenoblitz> hi guys... help needed here pls http://hpaste.org/12286
08:52:42 <conal> chessguy: a question would be: how to merge/lub such partial information.
08:53:19 <chessguy> i'm not really up to date on lub
08:53:20 <conal> (conjoin constraints)
08:53:37 <conal> lub just means combine partial information from two sources into one
08:53:46 <conal> like conjunction.
08:54:06 <conal> it means "least upper bound", in terms of descriptiveness/information
08:54:48 <EvilTerran> (x `lub` y) being the least defined z such that x [= z and y [= z
08:55:40 <xenoblitz> is it possible to derive an instance of the form shown in the above hpaste?
08:55:40 <chessguy> conal, i would still just replace the old value with the second value in that case
08:56:06 <ski_> (conal : hmm .. (reading about) your `Partial' implementation reminds me of a way of faking logic variables using `fix')
08:56:11 <EvilTerran> xenoblitz, it looks to me like it won't typecheck even with extensions
08:56:40 <EvilTerran> "simulate :: ((a -> b) -> a) -> Bool
08:56:40 <EvilTerran> " for that instance, it only takes one parameter
08:57:18 <xenoblitz> EvilTerran: is it possible to get a simulate of this form somehow simulate :: (a -> b) -> a -> Bool
08:57:45 <EvilTerran> you could write an instance for (a -> b, a)
08:58:05 <EvilTerran> so simulate :: (a -> b, a) -> Bool for that instance
08:58:19 <xenoblitz> ah thanks alot... I'll give it a try
08:58:58 <EvilTerran> but i think you'll still need -XFlexibleInstances
08:59:09 <conal> ski_: i don't know that trick.  do you have a reference?
08:59:15 <EvilTerran> it's one of the most commonly-used extensions, i wouldn't worry about using it
08:59:44 <ski_> conal : hm, i'm not sure where i put the test file
09:00:30 * ski_ tries to recall what he did
09:00:41 <xenoblitz> EvilTerran: i tried as you suggested... I'm getting the same error :/
09:01:00 <conal> chessguy: ("i would still just replace the old value with the second value in that case").  i didn't understand this bit.
09:01:16 <EvilTerran> xenoblitz, as i just said, you'll still need -XFlexibleInstances; the problem i pointed out was orthogonal to the error you were getting
09:01:27 <EvilTerran> because compilation was bailing on that error before it noticed the problem i pointed out
09:01:40 <xenoblitz> ah, ic
09:02:02 <xenoblitz> is it really that common to use -XFlexibleInstances... I see it as tarnishing the nice code
09:04:49 <EvilTerran> xenoblitz, haskell98's instance requirements are needlessly restrictive, they stop you doing all sorts of interesting things that you'd expect to work
09:05:07 <xenoblitz> i understand
09:05:44 <xenoblitz> how is it possible to add the pragma to the code itself instead of passing it to the gchi
09:05:50 <xenoblitz> ?
09:05:55 <EvilTerran> {-# LANGUAGE FlexibleInstances #-}
09:05:56 <xenoblitz> or at least a list of them somewhere?
09:06:05 <EvilTerran> in the file with the instance decleration
09:06:06 <xenoblitz> thanks loads EvilTerran :)
09:06:17 <ski_> (yay .. found it)
09:06:28 <EvilTerran> if you're using more than one language extension, separate them with commas, as in
09:06:37 <EvilTerran> {-# LANGUAGE FlexibleInstances, GADTs #-}
09:07:04 * gwern install GHC 6.10, and greatly appreciates cabal-install
09:07:47 <gwern> all that's left to cabalize is gtk2hs and ghc, basically, and the glorious day of cabal-installing everything will arrive
09:10:22 * gwern watches simulatenous cabal installs of xmonad-contrib, darcs, lhc, yi, and gitit progress. excellent...
09:11:27 <chessguy> conal, i.e., i would treat it as if that component were fully-defined
09:12:27 <chessguy> so (snd * 2, _|_) U (snd * 3, _|_)  = (snd * 3, _|_)
09:13:15 <chessguy> but i don't know if i'm understanding right
09:15:22 <MrTree> hi. i just saw a function definition i don't quite understand.
09:15:27 <MrTree> nextMoves already@(x:xs) = ...
09:15:35 <MrTree> what does the @ do?
09:16:01 <chessguy> MrTree, binds the whole list to 'already'
09:16:11 <chessguy> in addition to binding the head to x and the tail to xs
09:16:31 <MrTree> cool, thanks
09:17:53 <vixey> hm
09:18:13 <vixey> nextMoves already@(x:xs) = ... { = } nextMoves (x:xs) = let already = x:xs in ...
09:18:36 * shapr hugs vixey
09:18:42 <chessguy> @get-slapr
09:18:43 <lambdabot> shapr!!
09:19:01 <vixey> shapr!!!!!
09:19:12 <olsner> @help get-shapr
09:19:12 <lambdabot> get-shapr. Summon shapr instantly
09:19:27 <vixey> did you watch the talk by Steele and Gabriel ?
09:19:45 <shapr> hiya!
09:19:49 <shapr> Nah, I missed it.
09:19:53 <Gabbie> I thought I was awesome.
09:20:01 <Gabbie> Steele was a bit naff though.
09:20:04 <vixey> I like it
09:20:14 <vixey> lots of programming languages :p
09:20:34 <shapr> @users
09:20:34 <lambdabot> Maximum users seen in #haskell: 558, currently: 527 (94.4%), active: 12 (2.3%)
09:21:44 <chessguy> naff?
09:21:49 <shapr> @wn naff
09:21:58 <vixey> @w80 nyaf
09:22:00 <lambdabot> No match for "naff".
09:22:05 <lambdabot> No match for "nyaf".
09:22:06 <vixey> @w80 nyaff
09:22:07 <lambdabot> No match for "nyaff".
09:22:13 <chessguy> @all-dict naff
09:22:14 <lambdabot> No match for "naff".
09:22:15 <vixey> hummm
09:22:32 <shapr> http://www.urbandictionary.com/define.php?term=naff
09:22:48 <lambdabot> Title: Urban Dictionary: naff
09:22:55 <ski_> conal : ok, i think i now remember what i was thinking
09:23:17 <Gabbie> shapr, that's the chap.
09:23:50 <chessguy> hm, never lea/j #haskell-blah
09:23:56 <chessguy> oops
09:24:19 <chessguy> heh. goes to show how long my attention span is
09:28:47 <chylli> hi, I write a scheme parser, part of code  at http://hpaste.org/12287
09:29:30 <chylli> but when it parse (1 . 2), I got error: Parse error at "lisp" (line 1, column 4):
09:29:36 <chessguy> chylli, have you seen the Write a scheme in 48 hours tutorial?
09:29:41 <chylli> unexpected "."
09:29:42 <ski_> conal : the idea was to try to encode some simple prolog handling partially instantiated structures in haskell
09:29:54 <chylli> chessguy: yes, I use that code
09:29:59 <chessguy> ah, cool
09:30:03 <ski_> (conal : it would help here if you know any Prolog ..)
09:30:46 <chylli> chessguy: and I found it cannot parse list like (+ 1 (+ 1 2) ), something like the two ')' with a space in them.
09:30:54 <ski_> conal : the point was that i wanted to encode prolog lists as haskell lists, et.c. no explicit representation of `uninstantiated' variables
09:31:15 <EvilTerran> chylli, it seems to me that a direct right-recursive grammar that amalgamated the list and dotted-list cases might be easier to reason about
09:31:25 <chylli> chessguy: I want to know, I has use 'try' in parseExpr, but why it report error instead of try parsedottedlist
09:31:48 <ski_> conal : SYN
09:31:50 <EvilTerran> chylli, but i suspect the "endBy parseExpr spaces" is at fault here
09:31:58 <EvilTerran> ?type endby
09:31:59 <lambdabot> Not in scope: `endby'
09:32:03 <conal> chessguy: (i was afk.)  thx for the explanation.
09:32:05 <EvilTerran> ?type endBy
09:32:06 <lambdabot> Not in scope: `endBy'
09:32:11 <EvilTerran> , src 'endBy
09:32:20 <vixey> ski_, I think it's safe to assume conal knows a bit of Prolog :p
09:32:26 <lunabot>  endBy :: forall a sep . (ReadP a) -> (ReadP sep) -> ReadP ([a])
09:32:30 <EvilTerran> aha
09:32:39 <conal> SimonRC: yeah, i used to program in prolog.  and i worked on Lambda-Prolog.
09:32:48 <chylli> EvilTerran: why 'try' dont work ?
09:33:00 <ski_> s/SimonRC/ski_/
09:33:22 <chylli> EvilTerran: I think when parseList fail, it will run parser parseDottedList
09:33:23 <EvilTerran> , src ''Parser
09:33:25 <lunabot>  luna: Not in scope: type constructor or class `Parser'
09:33:47 <chylli> EvilTerran: but seems it not, It just eject error
09:33:52 <ski_> conal : ok, so to encode length/2 to begin with .. the "forward" mode `(+,-)' could be encoded as
09:33:55 <conal> ski_: "SYN"?
09:34:02 <EvilTerran> , src ''Parsec
09:34:05 <lunabot>  luna: Not in scope: type constructor or class `Parsec'
09:34:14 <EvilTerran> , src ''GenParser
09:34:16 <lunabot>  luna: Not in scope: type constructor or class `GenParser'
09:34:18 <EvilTerran> hm
09:34:45 * EvilTerran looks at that first one again - ohhhh, it's ReadP, not Parsec *doh*
09:35:41 <ddarius> conal: TCP/IP terminology SYN, ACK etc.
09:35:46 <EvilTerran> chylli, i mean i suspect it's falling through to the parseDottedList, and then the "endBy parseExpr spaces" in that may be malfunctioning
09:35:51 <ski_> (conal : sorry .. used that instead of "ping")
09:35:51 <vixey> :(
09:35:52 <vixey> cabal: There is no package named frisby
09:36:40 <chylli> But I has tested by : remove (try ParseList <|>), only use ParseDottedList, and it ok
09:36:44 <ski_>   lengthA :: [a] -> Nat
09:36:50 <ski_>   lengthA [    ] = Zero
09:36:52 <conal> (ski_: what's it stand for?)
09:36:59 <ski_>   lengthA (_:xs) = Succ n
09:37:03 <ski_>     where
09:37:04 <ski_>     n = lengthA xs
09:37:17 <vixey> ACKnowledga
09:37:34 <ski_> (conal : it was supposed to stand for a "ping" as in "ping - pong" .. but possibly i confuse it with "ENQ" ..)
09:37:35 <EvilTerran> chylli, consider that endBy p sep = many (do{ x <- p; sep; return x })
09:37:41 <chessguy> conal, my thinking is that, component-wise, a predicate would replace undefined or a predicate, a relationship with another component would replace undefined or a predicate, or another relationship, and of course a fully defined value would replace anything
09:38:05 <solussd> i am passing an index to an array in the form (i-1)   -- how can i check that the index is within bounds ?
09:38:13 <solussd> inline, preferably
09:38:23 <vixey> SYN Synchronize
09:38:23 <EvilTerran> the source of "many" is unintelligable, i note
09:38:41 <ski_> (<http://en.wikipedia.org/wiki/C0_and_C1_control_codes>)
09:38:45 <conal> vixey: oh.  i get it.
09:38:48 <conal> thx
09:38:55 <chylli> EvilTerran: I rewrite it as x <- try (parseDottedList) <|> parseList
09:38:56 <conal> ddarius: thx
09:38:56 <ski_> conal : anyway, that mode is no surprise
09:39:05 <chylli> EvilTerran: it is ok.
09:39:20 <ski_> conal : the other mode of length/2, then "backward" `(-,+)' is more interesting
09:39:22 <EvilTerran> SYN "are you there?"; ACK SYN "I'm here; are you still paying attention?"; ACK "yes, let's talk"
09:39:27 <chylli> EvilTerran: my question is , why do not 'try' wrok
09:39:49 <EvilTerran> chylli, ah, it works if you swap those over? that's interesting
09:39:57 <EvilTerran> me 's Parsec is a bit rusty
09:40:00 * EvilTerran 's Parsec is a bit rusty
09:40:02 <EvilTerran> even
09:40:19 <ski_>   lengthB :: Nat -> [a] -> [a]
09:40:23 <chylli> EvilTerran: ok, thanks
09:40:24 <ski_>   lengthB  Zero    ~[     ] = [   ]
09:40:30 <ski_>   lengthB (Succ n) ~(x:xs0) = x:xs1
09:40:31 <chylli> I will ask it in newsgroup
09:40:34 <ski_>     where
09:40:35 <ski_>     xs1 = lengthB n xs0
09:40:41 * EvilTerran is still thinking about it, mind
09:40:55 <chessguy> EvilTerran, i think a standard like IM_HERE_ARE_YOU_STILL_PAYING_ATTENTION would rock :)
09:41:44 <vixey> why does it take a [a] parameter?
09:41:53 <ski_> conal : this mode of length/2 is supposed to generan a partially instantiated list of the given length .. but in haskell we need to give the elements as well, since we can't plug them in later
09:42:40 <ski_> conal : so, we use the idea of "blue-printing", i.e. we expect to get the list we're about to construct, as a parameter .. but we don't look (i.e. pattern-match (strictly)) at ir
09:42:44 <ski_> s/ir/it/
09:43:09 <ski_> s/generan/generate/
09:43:50 <vixey> thats crazy
09:43:59 <ski_> (:
09:44:03 <vixey> trying to build frisby makes impossible happen
09:44:21 <ski_> now, both thest two modes are deterministic
09:44:25 <conal> ski_: you represent partial information about 'a' as 'a -> a' ?
09:44:40 <vixey> ski_, it seems strange there is no notion of failure
09:44:54 <ski_> conal : more or less, yes .. (hence my reaction to your `Partial a' implementation in the blog article from last year)
09:45:12 <ski_> vixey : i'm just about to mix in nondeterminism :)
09:45:34 <ski_> so, now i want to encode
09:45:41 <ski_>   map0(_,[    ]).
09:45:50 <ski_>   map0(P,[X|Xs]) :-
09:45:55 <ski_>     call(P,X),
09:46:02 <ski_>     map0(P,Xs).
09:46:07 <ski_> in a similar way
09:46:25 <ski_> `P' should be allowed to be nondeterministic
09:46:37 <ski_> so i get
09:46:46 <ski_>   map0A :: [] a -> [a] -> [] [a]
09:46:54 <ski_>   map0A p [       ] = do return []
09:47:08 <ski_>   map0A p (~x0:xs0) = do x1 <- p
09:47:09 * chessguy waits for conal  to get it and explane it to us mere mortals
09:47:20 <ski_>                          xs1 <- map0A p xs0
09:47:26 <ski_>                          return (x1:xs1)
09:48:19 <ski_> this is for the case that `P' (`p' in the haskell version) will generate each element fully .. no input to `p'
09:48:27 <ski_> we can also make a
09:48:33 <ski_>   map0B :: (a -> [] a) -> [a] -> [] [a]
09:48:38 <ski_> that is more general
09:49:05 <ski_> the `[]' here is for noting the nondeterminism effects (as opposed to `[a]' which just represent data lists)
09:49:26 <ski_> now, the finale
09:49:35 <ski_> i want to express
09:49:38 <ski_>   test(Xs) :-
09:49:45 <ski_>     length(Xs,succ(succ(succ(zero)))),
09:49:51 <ski_>     map0A(smallPrime,Xs).
09:50:04 <ski_> (where smallPrime/1 just enumerates a few primes)
09:50:40 <ski_> so i did that as
09:50:41 <ski_>   testA :: [] [Int]
09:50:47 <ski_>   testA = mfix $ \xs0 ->
09:50:53 <ski_>           do let xs1 = lengthB (Succ (Succ (Succ Zero))) xs0
09:50:58 <ski_>              xs2 <- map0A smallPrimeA xs1
09:51:04 <ski_>              return xs2
09:51:52 <ski_> the `mfix' (`fix' could be used if we didn't have nondeterminism effects to keep track of ..) is used here to "feed back" the final output as the initial input
09:52:16 <vixey> cool technique!
09:53:09 <conal> ski_: neat!  is this technique written up somewhere?
09:53:14 <ski_> (my timestamps tell me i hacked this together slightly more than a year ago .. so it's not that fresh in my mind, atm)
09:53:22 <ski_> sorry, no
09:53:36 <conal> ski_: would make a cool blog post or Monad.Reader article
09:54:36 <conal> is there a code.haskell.org admin here?  i'd like to get some odd permissions fixed in /srv/trac.
09:54:40 <ski_> atm, you could see the test file, if you like .. (though, it's not very cleaned-up)
09:54:46 <dons> conal: dcoutts or igloo
09:55:01 <conal> dons: thx.
09:56:26 <conal> Peaker: i think the trac problem (error when attaching files) is due to group ownership on the trac directories.  i'll try to get it fixed.
09:57:14 <solussd> can you have multiple where clauses at the end of a haskell function definition ?
09:57:57 <solussd> i have several array indices i need to use in the function definition, i'd like to give them simpler names than index+dim-1, index-dim-1, etc...
09:57:58 <ski_> solussd : you would you need to ?
09:57:58 <EvilTerran> no, but you can have one with multiple lines
09:58:22 <conal> dcoutts, Igloo: could either of you give me a hand on code.haskell.org?  the groups associated with subdirectories of /srv/trac are inconsistent.  some are owned by www-data and some by the project's group.  i think the latter set (e.g., including FieldTrip but not reactive) are causing some failures.
09:58:32 <EvilTerran> > let foo x = z where { z = 2*y; y = x+1 } in foo x
09:58:34 <lambdabot>   2 * (x + 1)
09:58:47 <solussd> if i want iL to be equal to index-1 and iR to be equal to index+1, how do i do that using where?
09:59:15 <EvilTerran> actually, in the right circumstances, you can have multiple where-clauses at the end of a function, each indented less than the one before
09:59:37 <conal> dcoutts, Igloo: an "ls -lt /srv/trac" will show that all older trac db's have www-data and all newer ones don't.
09:59:41 * ski_ tries to recall if there was any advantage to using `fix' instead of passing `undefined'
10:00:06 <conal> dcoutts, Igloo: make that "almost all".  haskeline is an exception.
10:00:14 <ski_> (.. maybe one could "use" a value before instantiating it, if careful .. hm)
10:01:11 <aeolist> i have a data Color = Red | Black (following a RedBlack trees implementation) and i have to do a colorflip which involves a function like negation R = B negation B = R, maybe i could define a type Class and overload "not" to do this for me?
10:01:35 <vixey> aeolist, This is not what you would usually do
10:01:48 <vixey> aeolist, but just  class Negatory a where not :: a -> a
10:01:57 <roconnor> > let âŠ¥ = undefined in âŠ¥
10:01:58 <lambdabot>   <no location info>: parse error on input `âŠ¥'
10:02:02 <vixey> aeolist, instance Negatory Color where not Red = Black ; not Black = Red
10:02:22 <vixey> aeolist, the question is, is this better than using  flipColor :: Color -> Color?
10:02:35 <EvilTerran> there's a traditional "class Dual a where dual :: a -> a; -- dual.dual = id"
10:02:36 <aeolist> ok... i was just about to ask that
10:02:44 <Botje> not Red is less clear than flip Red, imo
10:02:46 <aeolist> vixey: is it better than having a function for it?
10:02:56 <vixey> aeolist, it is worse
10:03:39 <aeolist> may i ask why?
10:03:41 <vixey> If you really want to use the name 'not' that is fine
10:04:02 <vixey> but making a class to do this is more complicated than not
10:04:37 <vixey> (import Prelude hiding (not), lets you reclaim that name for normal use)
10:04:49 <aeolist> ok
10:05:08 <aeolist> vixey: i'm just going to define that class anyway, just to see how defining type classes works
10:06:19 <vixey> ski, say wanted to write unify :: ([()],[()]) -> ([()],[()])
10:06:22 <aeolist> it's an assignment and the implementation already works, so i might just go ahead and experiment a little
10:06:33 <conal> Peaker: i just emailed the c.h.o support folks and cc'd you.
10:06:35 <aeolist> thank you vixey
10:06:56 <vixey> ski, it seems there is no way to make that work with holes in the structure
10:07:10 <vixey> (unless you chose a mode liike + - or - +)
10:08:17 <ski_> vixey : yes, hence "fake" logic variables .. i can't represent any kind of instantiation pattern .. but it surprised me i could represent some partially defined terms at all
10:08:59 <vixey> ski, but then maybe grouting all data structures with Computation a = Now a | Later (Computation a), you could implement that same thing)
10:09:14 <ski_> vixey : however, i can't just instantiate an uninstantiated variable .. i have to take on faith that it really is meant to be uninstantiated at thie point, and just discard it and replace it with the instantiated value
10:09:49 <vixey> (i.e. data List a = Nil | Cons (Computation a) (Computation (List a)))
10:09:58 <ski_> (vixey : and the crazy thing, using `fix', is that if one does that, then the discarded value is the same as the one one replaced it with .. but if you look at it, you're screwed :)
10:10:50 <ski_> hm .. using a resumption monad for the nondeterminism ?
10:10:57 <vixey> perhaps
10:11:11 <hackage> Uploaded to hackage: peano-inf 0.6.2
10:11:13 <ski_> ".. you could implement that same thing" what thing ?
10:11:14 <vixey> I'm not sure what such a monad would b elike
10:11:26 <vixey> unification of lists
10:12:19 <Botje> im in ur list, unificating.
10:12:23 <ski_> (`return = Now; join (Now ma) = ma; join (Later mma) = Later (join mma)')
10:13:03 <vixey> actually no it wouldn't work, I was thinking with that you could race for a least fixed point, but actually without adding a Bottom constructor to the Computation type it could not -- there is no way to tell if values are different
10:13:06 <ski_> er .. s/nondeterminism/nontermination/ might clear that up
10:13:14 <vixey> which comes right back to the usual implementation of logic variables :/
10:13:29 <vixey> sorry, useless diversion
10:14:19 <ski_> np
10:14:25 <ski_> (useless typo)
10:15:34 <Chief> :t map
10:15:34 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:15:50 * ski_ probably should continue reading about `Partial' now
10:16:04 <vixey> so I suppose any logic program that is not expressible as a _knot_ would be out of reach with that technique
10:16:06 <ski_> (i just wanted to mention this, before i forgot about it again)
10:16:07 <vixey> and unification is one
10:16:46 <ski_> yes, i think that's in some sense it
10:17:37 <ski_> (btw, note that i here didn't invent the blue-printing technique .. just this application/interpretation of it, in terms of logic programming)
10:17:56 <gwern> Botje: better might be 'im in ur type system, unifyng ur terms'
10:18:18 <vixey> s/terms/types/
10:18:35 <ski_> .oO(maybe a dependent type system)
10:18:55 <vixey> ski_, what do you read about partiality?
10:18:58 <conal> ski_: do you have a ref for blue-printing?
10:19:16 <gwern> vixey: I didn't want to repeat 'type', so I picked somer andom related jargon :)
10:19:30 <ski_> conal : iirc, apfelmus and a few others were discussing it here maybe a year or two ago
10:19:36 * vixey (recommend Computation by Prophecy)
10:19:43 <ski_> vixey : conal's blog ;)
10:19:45 <Giraffe> man, i love this channel
10:19:54 <conal> ski_: okay, thx
10:19:55 <shapr> me too!
10:19:55 <ski_> (: Giraffe
10:20:00 <vixey> oh
10:20:11 <vixey> I was thinking about something else (the monad)
10:20:13 <Giraffe> it's way more interesting than other programming channels, since everyone discusses it on a more mathematical level
10:20:18 <Giraffe> which is far, far more fascinating
10:20:53 <Asztal> should it be possible to crash ghci (stack overflow) with something like 3^478293748^4332874923 ? I expected a long wait or an exception...
10:21:23 <ski_> (conal : i think i had some references to blue-printing lying around in some files on my computer .. unfortunately, it's currently kinda dead)
10:21:56 <conal> ski_: too bad about the computer :(
10:22:56 <Giraffe> Asztal, i did the ackermann function and it worked just fine
10:24:12 <Asztal> oh, I forgot this is a really old version of GHC
10:24:50 <Giraffe> ahh
10:24:57 <vixey> What packrat parser does everyone use?
10:25:12 <Giraffe> well yeah, you expected ghci to not work with really big numbers? :P
10:25:44 <Asztal> I wanted to waste some memory
10:26:01 <aeolist> vixey: with the example code you provided, are ambiguities with Prelude supposed to show up?
10:26:30 <vixey> aeolist, did you hide not like I said?
10:27:03 <aeolist> no
10:27:09 <vixey> then yes :)
10:27:11 <aeolist> lol
10:27:32 <aeolist> i thought not would be overloaded, what is it that i dont understand?
10:27:49 <Giraffe> aeolist, how do you mean?
10:28:32 <vixey> :t not
10:28:33 <lambdabot> Bool -> Bool
10:28:35 <vixey> it is only Bool -> Bool
10:28:43 <Giraffe> yeah
10:28:50 <vixey> it's not Dual bool => bool -> bool or anything but I showed you how to do that
10:29:05 <vixey> (did it work?)
10:29:51 <aeolist> with importing prelude without not? it should...
10:30:17 <aeolist> what about... negate? it's for numbers
10:30:19 <aeolist> :t negate
10:30:20 <lambdabot> forall a. (Num a) => a -> a
10:30:32 <aeolist> i'm stretching this, i know
10:30:42 <vixey> you could define a Num instance for
10:30:56 <vixey> data CantThinkOfAGoodName = NegativeOne | One
10:31:02 <ddarius> @src Fractional
10:31:02 <lambdabot> class  (Num a) => Fractional a  where
10:31:02 <lambdabot>     (/)             :: a -> a -> a
10:31:02 <lambdabot>     recip           :: a -> a
10:31:02 <lambdabot>     fromRational    :: Rational -> a
10:31:15 * ski_ multiplies `Black' with `Red'
10:31:18 <vixey> iirc that's a field (?)
10:31:26 <aeolist> ski_: it's striped
10:31:28 <Riastradh> What's the additive identity, vixey?
10:31:39 <vixey> ok yeah it's not a flield
10:32:14 <Riastradh> Well, it can be made into a field; there are several fields of cardinality 2.  But it might not behave like you would expect with names such as `-1' and `1'.
10:32:22 <ddarius> Z/2 is a field
10:33:15 <ski_> Z/(2*Z)
10:34:00 <aeolist> so not is not overloadable since it doesnt belong to a type class, but (+) is since it belong to Num a, and every type class that instantiates Num a must/should define a (+) function
10:34:33 <vixey> aeolist, by the way if you defined an instance Negatory for Bool any code that uses 'not' on Bool would still work*
10:34:52 <vixey> (* well it might break if you have a monomorphism restriction and maybe other cases I'm not aware of)
10:34:55 <EvilTerran> aeolist, and, indeed, any instance should, intuitively, "act like" numbers
10:35:23 <aeolist> yeah, like instance Negatory Bool where not x == Prelude.not x ?
10:35:28 <ddarius> Acting like numbers is for the weak.
10:35:34 <EvilTerran> ie, (+) and (*) should be commutative and associative
10:35:58 <Riastradh> (mostly)
10:36:01 <EvilTerran> (fromInteger 0) should be the identity element of (+), and likewise 1 and (*)
10:36:01 <EvilTerran> etc
10:36:24 <EvilTerran> well, yes, mostly
10:36:37 <EvilTerran> but then floating-point spoils everyone's fun
10:36:45 <ddarius> I have instances that don't satisfy those laws at all
10:37:43 <roconnor> > let {fI 0 = False ; fI 1 = True; (+) = (/=)} in fI 0 + fI 0 == fI 0
10:37:44 <lambdabot>   True
10:37:48 <roconnor> > let {fI 0 = False ; fI 1 = True; (+) = (/=)} in fI 0 + fI 1 == fI 1
10:37:50 <lambdabot>   True
10:38:50 <vixey> of what data ddarius?
10:39:26 <ddarius> Usually symbolic expressions of some sort.  Other times just massively abusive use.
10:39:28 * EvilTerran is frequently tempted to include instances of Num for Bool and () just for the hell of it
10:44:13 <vixey> yuck
10:44:31 <vixey> Frisbys implementation inlines unsafeCoerce and casuse impossible to happen
10:45:37 <dons> inlining unsafeCoerce# is often ok , particularly in specialist code generators
10:45:50 <dons> "the impossible happened" is usually worth a bug report
10:45:56 <vixey> @seen FordCortina
10:45:56 <lambdabot> Last time I saw FordCortina was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-
10:45:56 <lambdabot> hac07, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr and #haskell.it 2m 26d 20h 3m 13s ago, and .
10:46:05 <vixey> 2 months :/
10:46:15 <EvilTerran> preflex: seen FordCortina
10:46:16 <preflex>  FordCortina was last seen on #haskell 75 days, 8 hours, 12 minutes and 20 seconds ago, saying: s/to types/two types/
10:47:16 <vixey> hehe
10:47:25 <vixey> do you think they too that nick from an SPJ paper
10:49:18 <vixey> I don't understand frisby why does it use unsafeCoerce
10:49:22 <vixey> ?
10:50:22 <ski_> istr Happy uses it too
10:50:36 <gwern> hm. a good result about mueval and lambdabot being separate is that mueval can't be compiled with 6.10 but you can still upgrade for lambdabot
10:50:40 <vixey> boo!
10:50:48 <vixey> I don't like unsafeCorce
10:50:53 <vixey> since this thing doesn't compile
10:53:30 <Giraffe> hey, uh, is this appropriately functional? http://hpaste.org/12288
10:56:08 <dons> vixey: did you paste your error somewhere?
10:56:14 <vixey> Giraffe, it's a bit scary seeing SQL in a _String_
10:56:28 <Giraffe> vixey, what are you referring to?
10:56:30 <dons> looks fairly clean, Giraffe
10:56:36 <vixey>      else run conn ("CREATE TABLE books " ++
10:56:40 <vixey> stuff like that
10:56:46 <dons> vixey: are you proposing the use of a different library?
10:56:46 <vixey> I don't think you are doing anything wrong I just find it scary
10:56:53 <Giraffe> oh, i understand
10:56:59 <Giraffe> but...
10:57:07 <Giraffe> :t Database.HDBC.run
10:57:08 <lambdabot> Couldn't find qualified module.
10:57:09 <dons> there's some typed SQL embeddings, of course, not widely used though.
10:57:11 <Giraffe> ahh
10:57:15 <dons> Giraffe: is hdbc installed?
10:57:19 <vixey> note that I didn't implement Database.HDBC :p
10:57:19 <Giraffe> it is for me
10:57:23 <Giraffe> maybe not for lambdabot :P
10:57:55 <dons> you might need to add hdbc to lambdabot's .cabaal file
10:58:06 <Giraffe> but anyway afaik run is Connection -> String -> IO ()
10:58:10 <Giraffe> i know it takes a string though
10:58:18 <Giraffe> but the rest is bytestrings, so...
10:58:21 <vixey> Giraffe, you can maybe make inputLoop simpler with <$> and <*> or liftM or whatever
10:58:51 <Giraffe> hmmm
10:59:36 <vixey> so there is no termination proof for PEGs?
10:59:46 <Giraffe> PEG?
10:59:48 <vixey> that sucks
10:59:59 <vixey> some kind of parser that looks interesting
11:00:17 <vixey> but I think it's undecideable whether or not a given one will terminate on all inputs
11:02:34 <vixey> I'm confused.....
11:02:43 <EvilTerran> Giraffe, do you know of "string gaps"?
11:03:03 <gwern> dcoutts_: btw, did you remove me from moderation on the cabal-devel ml?
11:03:41 <EvilTerran> Giraffe, see http://hpaste.org/12288#a1
11:03:55 <EvilTerran> > "foo\    \bar"
11:03:56 <lambdabot>   "foobar"
11:04:12 <EvilTerran> > "foo\ {- i forget if you can have comments, or just whitespace -} \bar"
11:04:12 <lambdabot>   <no location info>:
11:04:13 <vixey> does http://en.wikipedia.org/wiki/Parsing_expression_grammar ("Each parsing function conceptually takes an input string as its argument, and yields one of the following results: sucess, failure") contradict the theorem in http://pdos.csail.mit.edu/~baford/packrat/popl04/ (It's undecideable whether or not a grammar is  complete)
11:04:13 <lambdabot>      lexical error in string/character literal at chara...
11:04:14 <lambdabot> Title: Parsing expression grammar - Wikipedia, the free encyclopedia
11:04:19 <EvilTerran> ok, just whitespace
11:04:24 * gwern blinks. that was not what I expected of "foo\    \bar"
11:04:35 <EvilTerran> gwern, what did you expect?
11:05:01 <gwern> I expected it to evaluate to "foo    bar" or whatever, as neither a space not 'b' are special characters which need guarding
11:05:20 <EvilTerran> however, \<whitespace> introduces a string gap
11:05:25 <EvilTerran> which is terminated by the next \
11:05:31 <mauke> > "\b"
11:05:32 <lambdabot>   "\b"
11:05:39 <gwern> I've never heard of this string-gap concept before
11:05:46 <vixey> > "\                        \"
11:05:47 <lambdabot>   ""
11:05:52 <vixey> > "\          \ \ \ \       \ \ \              \"
11:05:53 <lambdabot>   <no location info>:
11:05:54 <lambdabot>      lexical error in string/character literal at chara...
11:05:55 <vixey> > "\          \ \ \ \       \ \ \         \     \"
11:05:56 <lambdabot>   "            "
11:06:08 <mauke> > "\8"
11:06:09 <lambdabot>   "\b"
11:06:15 <sclv> you've seen it gwern, i'm sure.
11:06:24 <gwern> well, now I have
11:06:27 <gwern> what's the point of it?
11:06:33 <EvilTerran> "A string may include a "gap"---two backslants enclosing white characters---which is ignored. This allows one to write long strings on more than one line by writing a backslant at the end of one line and at the start of the next."
11:06:51 <ski_> gwern : saw that paste annotation above ?
11:06:51 <gwern> oh, those things. I didn't realize they didn't need a newline in them
11:06:52 <EvilTerran> http://haskell.org/onlinereport/lexemes.html#sect2.6
11:06:55 <lambdabot> Title: Haskell 98 Lexical Structure
11:06:59 <gwern> (how I hate them!)
11:07:31 <EvilTerran> gwern, well, i figure they're at least nicer than having multiple lines in the "..."++ format
11:07:52 <dons> there's lots of preprocessors too, fwiw
11:07:58 <gwern> EvilTerran: at least that's guaranteed to work, as opposed to the \\ method which may or may not work in ghci or cabal or whatever
11:08:00 <dons> i often use unlines [ "foo", "bar"]
11:08:14 <ski_> (or `concat')
11:08:21 <gwern> if the moon is right, the wolves not howling, and the proper implementation of CPP in PATH...
11:08:45 <gwern> *maybe* your \\ method will compile and work in ghci
11:08:58 <mauke> why wouldn't it work in ghci?
11:08:59 <dino-> I do that too, [ "foo"...
11:09:11 <dino-> but on multiple lines
11:09:31 <EvilTerran> with -XOverloadedStrings, you could have "instance IsString a => IsString (String -> a) where fromString = flip (++)" or something
11:09:35 <dino-> And the ,'s lined up with the [ and ]
11:09:38 <EvilTerran> (not sure if i got that quite right)
11:09:46 <EvilTerran> and then "foo" "bar" = "foobar"
11:10:06 <mauke> haha, EvilTerran++
11:11:01 <EvilTerran> :)
11:11:11 <hackage> Uploaded to hackage: ParserFunction 0.0.1
11:12:06 <solussd> if i am using guards for a function, can my 'otherwise' condition be several lines long?
11:12:08 <ddarius> So, with associate type synonyms and co., it should now be possible to use a little TH to embed the vast majority of ML's module system into Haskell.
11:12:28 <ddarius> solussd: Sure.
11:12:41 <solussd> d
11:12:44 <solussd> oops
11:13:08 <solussd> myfunc = | condition = something
11:13:18 <solussd>        | otherwise = line1
11:13:20 <solussd> line2
11:13:22 <solussd> etc?
11:13:31 <EvilTerran> ... what are these lines?
11:13:38 <EvilTerran> what happens to the value of line1?
11:13:56 <ddarius> line2 has to be indented more than the beginning of myfunc, but otherwise that's fine (except for the extra =)
11:14:18 <solussd> well they are if.then.else statements inside of ()s and added together so line1, line2, etc, end in '+'
11:14:30 <EvilTerran> ahh, i see; yes, that's fine
11:14:50 <EvilTerran> as ddarius says, you just need to indent the lines more than the start of the definition
11:15:52 <solussd> the function definition? .. this isnt working:
11:16:00 <solussd> countNeighbors grid_array dim index = | index>last $indices grid_array = Error: "out of bounds"
11:16:00 <solussd>                                       | otherwise = (if iL<0 then 0 else isAlive $ grid_array!(iL)) +
11:16:01 <solussd>                                           (if iR > last_index then 0 else isAlive $ grid_array!(iR)) +
11:16:01 <solussd>                                         ....etc
11:16:17 <ski_> remove the `=' before the `|'
11:16:27 <mauke> $indices looks wrong
11:16:38 <mauke> Error: looks wrong
11:16:41 <ddarius> mauke: It's only wrong if TH is enabled.
11:16:50 <solussd> what is TH?
11:16:52 <mauke> ddarius: why?
11:17:01 <EvilTerran> ddarius, no, it's still wrong, (index>last) is not a function
11:17:04 <mauke> (iL) better written as iL
11:17:09 <ddarius> mauke: Well, by itself, in the context it's wrong.
11:17:10 <mauke> same for iR
11:17:12 <solussd> the indices line is like this: last $ indices grid_array
11:17:25 <mauke> solussd: no, it's like index>last $ indices grid_array
11:17:43 <solussd> right.
11:18:07 <ski_> i.e. `(index > last) $ (indices grid_array)'
11:18:29 <ski_> possibly you wanted `index > last (indices grid_array)' ?
11:18:46 <solussd> no, i want: index > (last $ indices grid_array)
11:18:55 <EvilTerran> that's _the_same_thing_
11:18:57 <ski_> (that's the same)
11:19:08 <solussd> that part works .
11:19:09 <EvilTerran> ?src ($)
11:19:10 <lambdabot> f $ x = f x
11:19:41 <EvilTerran> last $ (indices grid_array) = last (indices grid_array); the source of $ says so
11:21:03 <solussd> where is a pastebin ?
11:21:08 <ski_> @hpaste
11:21:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:21:13 <the_unmaker> pastebin.ca
11:21:17 <dino-> Do we also use a different one these days?
11:21:25 <dino-> I'm vaguely remembering something with syntax highlight.
11:21:43 <EvilTerran> ?where hpaste2
11:21:43 <lambdabot> I know nothing about hpaste2.
11:22:34 <EvilTerran> google suggests http://www.unsafecoerce.com:8080
11:23:01 <solussd> here is the code and the error messages hugs gives me: http://hpaste.org/12289
11:23:08 <dino-> ah http://haskell.pastebin.com/
11:23:22 <Botje> solussd: drop the =
11:23:27 <Botje> before the first |
11:23:36 <solussd> ok
11:23:49 <ski_> dino- : are you thinking of <http://paste.lisp.org/new/haskell.hr> ?
11:23:55 <solussd> damn- -that was it.. thanks.
11:23:59 <Botje> also, that code isn't very sexy :'(
11:24:11 <EvilTerran> solussd, i'd be tempted to extract out this "if p then 0 else x" behaviour you're using repeatedly
11:24:19 <dino-> ski_: ooh, that looks good too
11:24:19 <solussd> yeah yeah... im very new at haskell. suggestions to sex it up?
11:24:41 <dino-> with channel announce
11:25:16 <EvilTerran> solussd, or, how about this; a function that, given co-ordinates, returns the value in the array if the co-ordinates are in the bounds, and a default value otherwise?
11:27:37 <EvilTerran> ?type inRange
11:27:39 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
11:27:49 <EvilTerran> solussd, that function may make things easier
11:27:55 <ski_> (dino- : in this case #haskell.hr)
11:28:15 <olsner> and you should probably use bounds rather than last . indices
11:28:20 <chessguy> foo i p g = if (p i) then 0 else isAlive $ grid_array!i
11:28:40 <EvilTerran> > filter (inRange ((0,0), (5,5))) [(0,0), (0,5), (0,6), (3,3), (5,5), (5,6)]
11:28:42 <lambdabot>   [(0,0),(0,5),(3,3),(5,5)]
11:29:00 <BMeph> chessguy: Gonna use that 'g'? ;)
11:29:05 <solussd> im still here, fyi-- just absorbing info
11:29:08 <solussd> :)
11:29:09 <chessguy> oops, that's g!i
11:29:17 <BMeph> :)
11:29:38 <chessguy> my attention span isn't long enough :)
11:29:42 <solussd> chessguy: that's good-- ill use it.
11:29:51 <olsner> @karma fyi
11:29:51 <lambdabot> fyi has a karma of -1
11:29:56 <olsner> @karma good
11:29:56 <lambdabot> good has a karma of -1
11:29:59 <olsner> :)
11:30:00 <BMeph> chessguy: Too much time watching SSAST, eh? ;)
11:30:00 <ddarius> Another jfredett
11:30:14 <chessguy> @vera SSAST
11:30:15 <lambdabot> No match for "SSAST".
11:30:37 <BMeph> *SAST (Short Attention-Span Theatre)
11:31:15 <chessguy> sorry, what? were you talking? :)
11:31:47 <BMeph> Ooh, Shiy! ;)
11:32:59 <olsner> sum . map (isAlive . (grid_array !)) . filter inBounds $ [iL,iR,...] where inBounds = inRange . bounds $ grid_array
11:33:40 <sbahra> > map (+ 0) [1 ..]
11:33:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:34:48 <pumpkin> mmm +0 is my favorite function
11:35:10 <solussd> chessguy/evilTerran: like this?: neighbor i last_index grid_array = if (0,last_index) `inRange` i then isAlive $	grid_array!(iL)	else 0
11:35:47 <mauke> eww, tabs
11:35:49 <solussd> (my spaces are getting clobbered for some reason)
11:35:57 <mauke> T A B S
11:36:01 <solussd> i do not use tabs
11:36:09 <solussd> i swear to it
11:36:22 <solussd> my emacs replaces tabs w/ spaces. :)
11:36:32 <chessguy> solussd, i assume you mean !last_index instead of !iL
11:36:58 <solussd> actually i mean 'i' not 'iL'
11:37:14 <chessguy> anyway, seems ok to me
11:37:24 <solussd> cool. thanks. much cleaner looking now.
11:38:24 <EvilTerran> solussd, yeah, looks good, altho, as a style point, it's normal to write "inRange" prefix instead of infix
11:38:29 <EvilTerran> makes more grammatical sense
11:38:45 <solussd> ok
11:38:47 <the_unmaker> how do i have box 1 do lookups accross box 2..n   as far as distributed hashes?
11:38:56 <EvilTerran> "inRange (lo,hi)" being the predicate "my parameter is in the range (lo,hi)"
11:42:06 * roconnor kinda wishes (_|_,_|_) was the same as _|_
11:42:28 <olsner> (for my function above: indices = [(index-),(index+)] <*> [1,dim,dim-1,dim+1])
11:42:57 <olsner> hmm, this is a game-of-life, isn't it?
11:43:31 <solussd> yes it is. :)
11:43:52 <solussd> olsener: i just started thinking along those lines before you posted that. :)
11:45:06 <ski_> roconnor : what for ?
11:45:30 <vixey> > let test (_,_) = True ; probe (u,v) = u `seq` v `seq` (u,v) in test undefined
11:45:32 <lambdabot>   * Exception: Prelude.undefined
11:45:34 <ski_> (and how about `(_|_,_) = _|_' ?)
11:45:39 <vixey> > let test (_,_) = True ; probe (u,v) = u `seq` v `seq` (u,v) in test (probe (undefined,undefined))
11:45:40 <lambdabot>   * Exception: Prelude.undefined
11:45:53 <roconnor> ski_ what is _ ?
11:46:00 <ski_> anything
11:46:07 <vixey> if only _|_ was a first class value! :p
11:46:17 <roconnor> nah, that is different
11:46:24 <ski_> yes, of course
11:46:35 <ski_> (which is why i asked)
11:47:09 <Baughn> vixey: We'd be able to solve the halting problem! ^_^
11:47:26 <roconnor> The CPO of ((),()) would have a pleasing diamond shape
11:47:27 <vixey> halts = const True -- :D
11:48:23 <ski_> halts = const _|_
11:49:08 <ski_> roconnor : hm .. would that be implementable ?
11:49:44 <roconnor> ski_ I don't know
11:50:33 <ski_> i suppose a forcing of a pair could spawn two threads with forcing of the two parts .. and as soon as one of those terminated, we stop/pause the other, so that the whole then is not `_|_'
11:51:34 <ski_> (`funnyPair a b = unsafePerformIO $ ...')
11:51:35 <vixey> I'm not sure that works
11:51:37 <vixey> ski
11:51:41 <solussd> ok... i want a list of numbers like this: [index-1,index+1,index-dim-1,index-dim+1,index+dim-1,index+dim+1]    is there a more elegant way to write that?
11:51:47 <vixey> let y = (x,y)
11:51:51 <vixey> is y in WHNF ?
11:51:57 <Saizan> (_|_,_|_) == _|_ in Miranda, iirc
11:52:00 <vixey> oh more like,,
11:52:03 <vixey> let y = (y,y)
11:52:03 <dons> solussd: what's the formula?
11:52:20 <vixey> actually passes both cases
11:52:23 <the_unmaker> haskell web browser coming soon?
11:52:25 <ski_> vixey : good example
11:52:38 <dons> the_unmaker: you working on one?
11:53:32 <ski_> Saizan : how about `(_|_,_)', then ?
11:54:53 <Saizan> ski_: it's like having only irrefutable patterns for (,)
11:55:23 <mauke> http://cgi.4chan.org/r/src/1227382169472.jpg
11:55:32 <ski_> hm
11:58:55 <EvilTerran> ski_, vixey; sounds like that "unambiguous choice" thing someone mentioned in here earlier
11:58:56 <ski_> (Saizan : actually, that sounds like a great idea :)
11:59:06 <EvilTerran> http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice
11:59:08 <lambdabot> Title: Conal Elliott Â» Functional concurrency with unambiguous choice, http://tinyurl.com/5wecn5
11:59:51 <ski_> EvilTerran : yes, we did sortof a tangent of that, before :)
12:00:01 <EvilTerran> \p@(x,y) -> (x `seq` p) `unamb` (y `seq` p)
12:00:47 <EvilTerran> identifies (_|_,_|_) with _|_, but keeps (x,_|_) and (_|_,y) separat
12:02:20 <ddarius> mauke: That was very well done.
12:02:34 <ski_> roconnor : hm, so, then for the `()' type, we should really have `() = _|_' right ?
12:03:03 <ski_> (roconnor : so your "diamond" would actually be for `(Sierpinski,Sierpinksi)')
12:09:05 <chessguy> solussd,  i suspect you want a list comprehension
12:10:28 <chessguy> e.g., [x+y | x <- [index, index - dim, index + dim], y <- [1, negate 1]]
12:10:55 <skorpan> > :t negate
12:10:56 <lambdabot>   <no location info>: parse error on input `:'
12:11:00 <skorpan> :t negate
12:11:01 <lambdabot> forall a. (Num a) => a -> a
12:11:14 <chessguy> negate n = 0 - n
12:11:16 <skorpan> > negate 1 == (-1)
12:11:17 <lambdabot>   True
12:11:49 <chessguy> i'd rather use negate here, pesonally. (-1) looks too much like a section :)
12:12:01 <solussd> thanks
12:12:01 <chessguy> to each his own
12:12:13 <vixey> - is such a horrible awful mistake :/
12:12:25 <vixey> did anyone say "Oh I have a great idea, lets make - a special case"
12:12:40 <skorpan> i'm not sure it's a mistake
12:12:52 <vixey> > 1 + -3
12:12:53 <Giraffe> it's a mistake not in action, but in principle
12:12:54 <lambdabot>       precedence parsing error
12:12:54 <lambdabot>          cannot mix `(+)' [infixl 6] and prefi...
12:12:56 <vixey> It's a mistake
12:13:03 <Giraffe> > 1 + (-3)
12:13:05 <lambdabot>   -2
12:13:07 <Giraffe> ugh
12:13:12 <skorpan> in principle a mistake+
12:13:13 <skorpan> ?
12:13:15 <vixey> @let n x = 0 - x
12:13:17 <lambdabot>  Defined.
12:13:21 <vixey> > 1 + n 3
12:13:22 <lambdabot>       Ambiguous occurrence `n'
12:13:22 <lambdabot>      It could refer to either `L.n', defined a...
12:13:25 <skorpan> you guys, i get the point
12:13:27 <vixey> aaaaaa :/
12:13:28 <Giraffe> hahahaha
12:13:36 <chessguy> > [1 + x | x <- [-1, 2]]
12:13:37 <lambdabot>   [0,3]
12:13:45 <chessguy> oh, it can work it out there
12:13:45 <vixey> :t negative
12:13:46 <lambdabot> Not in scope: `negative'
12:13:47 <Giraffe> vixey, how would you represent negative numbers?
12:13:55 <vixey> @let negative n = 0 - n
12:13:56 <lambdabot>  Defined.
12:13:59 <vixey> > 1 + negative 3
12:14:00 <vixey> like that
12:14:00 <lambdabot>   -2
12:14:03 <Giraffe> eh
12:14:11 <chessguy> solussd, use -1 there, not negate 1
12:14:16 <solussd> ok
12:14:21 <Giraffe> @let neg n = 0 - n
12:14:22 <lambdabot>  Defined.
12:14:24 <ddarius> > 1 + negate 3
12:14:25 <lambdabot>   -2
12:14:34 <Giraffe> oh, does negate already exist?
12:14:39 <chessguy> Giraffe, yes
12:14:43 <Giraffe> gotcha
12:14:44 <chessguy> @hoogle negate
12:14:44 <lambdabot> Prelude negate :: Num a => a -> a
12:14:52 <Giraffe> > negate 4
12:14:53 <lambdabot>   -4
12:15:26 * Giraffe > p == np
12:16:03 <pumpkin> lol
12:17:46 <ski_> obviously, integers should have canonical literals of the forms `m - 0',`0 - n', where `m',`n' are naturals
12:18:07 <mauke> excuse me wtf r u doin
12:18:16 <Saizan> @bot
12:18:17 <lambdabot> :)
12:25:53 <pumpkin> any way to skip negatively in Data.Binary.Get?
12:26:10 <pumpkin> or is it acting like a stream?
12:28:00 <dons> it's a stream.
12:35:39 <gio123> is here any german speaker? can somebody translate:Grundlagen eines Unterrichtes ueber endloses product
12:35:44 <pumpkin> can anyone recommend me a hackage package that parses a relatively complex binary format in pure haskell? I'd like to get a feel for what good patterns are. I've read ch10 of rwh but I get the feeling the resulting parser could be neater given things learned in later chapters
12:36:01 <roconnor> @bab de en Grundlagen eines Unterrichtes ueber endloses product
12:36:01 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
12:36:22 <vixey> @go power of Pi
12:36:38 <lambdabot> Plugin `search' failed with: thread killed
12:37:13 <trofi> @let pi_pow = ((4*atan(1))^)
12:37:14 <lambdabot>  Defined.
12:41:59 <byorgey> gio123: what is the context?
12:42:42 <byorgey> I know enough German to have a general idea of what it means, but it might have some technical sense that I'm not aware of
12:43:15 <byorgey> literally it means something like "bases/foundations of a class/lesson about infinite products" ?
12:47:26 <foo_> Given a tree how to number it doing bfs?
12:47:39 <foo_> I am intrested in purely functional algorithm.
12:47:46 <dons> heh
12:47:57 <dons> by 'number' what do you mean?
12:48:01 <vixey> foo_: You want someone to just give away the solution? :)
12:48:06 <dons> count  the nodes? assign numbers to the nodes?
12:48:12 <dons> foo_: its two lines of code :)
12:48:14 <foo_> assign
12:48:22 * EvilTerran detects homework
12:48:25 <dons> do you have a tree data type defined?
12:48:38 <vixey> foo_: I think it would be more fun to solve teh problem than be told an answer
12:48:39 <foo_> type 'a btree = Leaf of 'a | Node of 'a btree * 'a * 'a btree;;
12:48:45 <dons> hey, that's not haskell
12:48:52 <earthy> so?
12:48:55 <dons> you'll need to rewrite it in haskell for it to work. :)
12:49:11 <foo_> i'll rewrite after all :)
12:49:27 <orbitz> why not just ask in #ocaml?
12:49:36 <dons> data Tree a = Leaf a | Node a (Tree a) (Tree a)
12:49:42 <foo_> they give me imperative solution
12:49:51 <dons> i forget how ugly ocaml can be
12:50:19 <dons> foo_: so what transformation do you want to make?
12:50:29 <dons> change each node's contents to be a pair of the element and a number?
12:50:36 <sjanssen> hmm, breadth-first is tricky
12:51:01 <foo_> replace tree's content with bfs' number
12:51:52 <dons> and what do you have so far?
12:52:01 <dons> and which course is this homework for?
12:52:09 <foo_> imperative solution with lots of refs
12:52:11 <BMeph> sjanssen: Okasaki would disagree. ;)
12:52:15 <foo_> functional programming
12:52:33 <vixey> foo_: Well I'd suggested competely ignoring that solution
12:52:34 <sjanssen> BMeph: I know there must be a clever solution, I don't see it yet
12:52:35 <foo_> we have to program in ocaml in it
12:52:46 <vixey> foo_: by the way you are in #haskell not #ocaml
12:52:51 <vixey> foo_: dunno if that matters to you or not
12:53:31 <sjanssen> BMeph: BFS is certainly less straightforward that DFS or in-order numbering
12:54:20 <EvilTerran> it doesn't construct easily as an attribute
12:54:20 <BMeph> sjanssen: Certainly. :)
12:54:22 <foo_> yes, we have to think. it hurts.
12:54:36 <EvilTerran> inherited or synthesised
12:54:52 <BMeph> I think Okasaki's paper uses ML... ;p
12:55:08 <trofi> > [1,1..2]
12:55:09 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:55:37 <foo_> I had some troubles using Okasaki's purely functional queue to BFS tree
12:55:42 <EvilTerran> > [1,1..0]
12:55:44 <lambdabot>   []
12:55:51 <dons> BMeph: ML and Haskell
12:55:54 <foo_> there's no one instance of it, that's why
12:56:04 <pumpkin> foo_: you could try using fgl?
12:56:12 <BMeph> dons: Right, thanks. :)
12:56:35 * BMeph goes poking around in his PDF collection...
12:56:52 <dons> didn't okasaki write a pearl on this topic?
12:57:49 <dons> ah yes, "Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design"
12:58:13 <foo_> so I didn't do my homework, I see.
12:59:19 <BMeph> dons: Ah, SML, with views. :)
12:59:23 <dons> heh
12:59:37 <dons> i know. its bizarre he doesn't use a proper pseudocode language
13:02:17 <foo_> thanks! It solved my problem
13:02:49 <BMeph> foo_: It IS your problem... ;p
13:03:59 <dons> hehe. that's the published solution, so you should mention "I looked at what Okasaki did, tried to understand it, and used <insert idea here>"
13:04:31 <foo_> BMeph: hey, I am not Okasaki, I needn't be so smart
13:04:50 <orbitz> you should strive for it though
13:06:29 <luite> I'm trying to make a list shuffle function (MonadRandom m) => [a] -> m [a], using a swap algorithm, from a runSTArray. how can I use the random generator from the MonadRandom from the swap function?
13:07:13 <Saizan> which are MonadRandom's methods?
13:07:29 <luite> I need the getRandomR method
13:07:33 <BMeph> luite: Have you looked at the paper... ;)
13:07:39 <luite> which paper?
13:07:48 <luite> so that's a no ;)
13:08:11 <BMeph> Heh-heh. Just seems like the theme of the problems today. :)
13:08:34 <BMeph> luite: Hm, didn't Oleg do something on this? :)
13:08:51 <Saizan> ?google oleg perfect random shuffle
13:08:53 <luite> BMeph: Oleg did a pure functional random
13:09:04 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
13:09:28 <luite> but I still want to make my STArray shuffle :P
13:10:02 <Saizan> luite: you can work in the RandT g (ST s) monad
13:10:51 <luite> Saizan: yes I had a feeling I'd need RandT, can I use that in combination with a runSTArray?
13:11:09 <Saizan> ?type runSTArray
13:11:10 <lambdabot> Not in scope: `runSTArray'
13:11:16 <Saizan> ?hoogle runSTArray
13:11:16 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
13:11:24 <Saizan> yeah
13:11:36 <byorgey> luite: sure, you can do "runRand" first to get an ST computation, then run that with runSTArray
13:11:46 <EvilTerran> runRandT
13:11:50 <byorgey> or runRandT, or whatever it's called
13:11:53 <byorgey> right
13:12:11 <luite> ah, thanks, that sounds ok :)
13:15:00 <luite> hmm, I wonder how many monad transformer tutorials I'm going to need to be able to write this ;)
13:15:05 <gigo> is haskell good for solving mathematical problems like those of projecteuler.com ?
13:15:07 <dons> http://www.reddit.com/r/programming/comments/7f2jz/haskell_weekly_news_november_22_2008_monadreader/
13:15:10 <lambdabot> Title: Haskell Weekly News: November 22, 2008 | Monad.Reader, Udon dvcs, Turbinado web  ..., http://tinyurl.com/5e5j5b
13:15:19 <dons> gigo: a lot of people have done well with haskell on the euler projects, yes.
13:15:40 <dons> i believe haskell has been top ranked at various times, int-e?
13:16:25 <gigo> what is int-e?
13:16:44 <BMeph> gigo: Ask int-e. ;)
13:16:52 <olsner> a person, supposedly
13:16:53 <gigo> oh :-)
13:17:06 <gigo> which compiler or interpreter is the most popular that I should download?
13:17:18 <gigo> i am a beginner and i want to learn a new language to solve project euler.
13:17:29 <BMeph> http://www.haskell.org/GHC/
13:18:10 <dons> gigo: ghc, no question.
13:18:10 <BMeph> ...hmm, that didn't work. Sorry.
13:18:15 <BMeph> http://www.haskell.org/ghc/
13:18:16 <lambdabot> Title: The Glasgow Haskell Compiler
13:18:20 <dons> > product [1..1000]
13:18:21 <BMeph> That's better. :)
13:18:21 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
13:18:27 <dons> gigo: and you're underway
13:19:23 <gigo> dons: underway meaning? sorry, I'm not native english speaker
13:19:48 <sbahra> :-P
13:20:10 <olsner> you're on your way, you have started, etc
13:20:17 <gigo> oh thanks.
13:20:26 <dons> its easy to get started, i mean :)
13:21:15 <dmw> hello i need help
13:22:00 <BMeph> "State the nature of the computational emergency." ;)
13:22:23 <dmw> haskell I need prog c assistance will you help me please
13:22:46 <BMeph> Segmentation fault (core dumped).
13:22:55 <EvilTerran> if you need help programming C, wouldn't ##c be the place to ask/
13:22:55 <EvilTerran> ?
13:23:13 <olsner> yeah, maybe a C programming channel would be better suited... unless you're willing to switch to Haskell that is :)
13:23:14 <dmw> I have a take home test in prog c to complete by tuesday i need assistance
13:23:33 <EvilTerran> dmw, shouldn't take-home tests be completed without assistance?
13:24:06 <dmw> yes but i'm allowed to use any help books notes or assistance from anyone
13:24:16 <EvilTerran> really
13:24:27 <dmw> yes really can you help please
13:24:31 <sjanssen> dmw: #haskell is not going to do your C homework for you
13:24:42 <sjanssen> #haskell is for discussion about the programming language Haskell
13:24:57 <EvilTerran> it's not much of a test if you're allowed to ask anyone for the answer...
13:24:58 <dons> probably you should use monads
13:25:06 <rskjr> word
13:25:13 <dmw> all right then thank you anyway
13:25:16 <xcthulhu> dmw:  It's very hard to my polymorphic types in C...
13:25:18 <xcthulhu> :(
13:25:20 <vixey> dmw, You're no allowed to use any assistance from anyone? :p
13:25:29 <vixey> dmw, ... but you want assistance from us?
13:25:40 <dons> heh
13:25:44 <dons> fail.
13:25:48 <EvilTerran> vixey, he claimed to be allowed to use any help from anyone
13:25:53 <dons> that time of the year, eh
13:26:02 <EvilTerran> must be getting near the end of term somewhere
13:26:04 <vixey> oh I negated that sentance in my head when I read it somehow
13:26:11 <dons> since it made no sense
13:26:27 <vixey> I wrote a bfs numbering thing then I looked at the okasaki paper
13:26:28 <dons> social networks make take home tests an interesting thing
13:26:32 <EvilTerran> vixey, easy mistake to make; i made it the first time i read it too
13:26:34 <dons> vixey: oh, how'd you go?
13:26:49 <olsner> @pl int main() { printf("Hello world\n"); }
13:26:49 <lambdabot> (line 1, column 11):
13:26:50 <lambdabot> unexpected " "
13:26:50 <lambdabot> expecting variable, "(", operator or end of input
13:27:08 <vixey> The one by Gibbonsor whatever is the shortest of the 3 .. but I think mine has the simplist derivation
13:27:18 <vixey> Okasakis one is  just confusing :?
13:27:36 <dons> ah, jeremy gibbons did one too?
13:28:00 <dons> conal: hehe
13:28:07 <dons> yes, /that/ GvR
13:29:12 <dons> did everyone else see what guido said about haskell?
13:29:14 <dons> "Haskell is a pure functional language with a fast implementation that seems to have solved the I/O problem of functional languages well"
13:29:22 <dons> time to get the word out
13:29:44 <conal> :)
13:29:46 <dons> i wonder if GvR has a copy of RWH yet
13:29:55 <BMeph> dons: Too bad HWR just came out; that'd make a great "quote of the Week" :)
13:30:21 <idnar> I'm surprised he thinks Haskell is simpler than Scala, though; maybe it's just all the Java...
13:30:30 <vixey> Scala is horrendously complicated
13:30:41 <vixey> even taking GADTs and all that into account
13:30:43 <dons> corner cases and odd ball cases seem to be a constant refrain
13:30:43 <idnar> I guess I tend to see it through Java glasses
13:31:51 <idnar> this is probably the part where I mention that Haskell is the language that redeemed static typing for me
13:31:57 <roconnor> It should really be ``finite search over compact search spaces expressed as a monad'', but I understand using infinite is more provocative than compact.
13:32:13 <dons> :)
13:32:19 <dons> idnar: i'm glad.
13:32:44 <dons> ?users
13:32:44 <lambdabot> Maximum users seen in #haskell: 558, currently: 529 (94.8%), active: 21 (4.0%)
13:32:45 <idnar> all of a sudden, instead of the static typing just being some useless hurdles you have to jump through by telling the compiler stuff it already knows, and repeating yourself over and over, it's actually something *useful*!
13:32:57 <dons> oh. yeah, you want inference.
13:33:03 <conal> roconnor: yeah.  a provocative title catches readers
13:33:16 <idnar> of course, my previous experience was only with C-like languages (C, C++, Java, C#)
13:35:30 <idnar> inference helps get the type system out of your way; but of course, the type system does so much for you in Haskell
13:35:55 <xcthulhu> idnar: Haskell can't infer everything
13:35:57 <idnar> as opposed to, say, Java, where you're still getting NullPointerExceptions every time you sneeze (so what the heck was the point of all those type names you laboriously typed out five times each?)
13:36:15 <roconnor> conal: "compact" is almost the opposite of provocative.  Programmers probably would find it off putting
13:36:27 <roconnor> now we know why CS students need to study topology.
13:36:44 <gigo> lambdabot product [1..1000]
13:36:46 <idnar> xcthulhu: sure, but it doesn't need to
13:36:57 <dons> > product [1..1000]
13:36:58 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
13:37:01 <gigo> i am unable to talk to lambdabot in private.
13:37:05 <gigo> i want to send commands to it in private
13:37:17 <conal> roconnor: exactly.  "infinite" is provocative.
13:37:22 <gigo>  doesn't work : /msg lambdabot > product [1..1000]
13:37:23 <dons> idnar: right. we use it as a design tool for structuring applications whose safety we wish to certify at my work.
13:37:27 <dons> that's how flexible and powerful it
13:37:27 <dons> is
13:37:38 <conal> roconnor: i was agreeing with you.
13:37:39 <gigo> oh it works now. i think it took some delay for all its replies to arrive
13:37:40 <idnar> xcthulhu: on the one hand, it can infer what you want in the vast majority of cases; on the other hand, types in Haskell are much more expressive, so you can use them to communicate information to the reader that you would otherwise have to put in a docstring or comment or somesuch
13:37:51 <roconnor> conal: yep, I know.
13:38:22 <conal> oh
13:38:52 <idnar> for example, in Python code, I assign to local variables all over the show, to break up my code and make it easier to see how the various components fit together
13:39:40 <idnar> in the C-likes, you have to type out a type declaration every time you do that (well, C# has var now, yay!), which means you're tempted to just lump it all into one inscrutable expression to save on typing
13:40:48 <idnar> in Haskell, you just throw in a `let' or `where' and let the compiler infer the type just like it was already doing; same effort (more or less) as the Python version
13:42:31 <idnar> anyhow, the experience of discovering Haskell was something like drinking coffee all your life, complaining how awful it tastes; then drinking a *real* cup of coffee, and discovering you were actually drinking brown crayon dripped in warm water before
13:42:48 <dons> heh
13:54:43 <Giraffe> idnar, that sounds about right
13:58:11 <Honen> hello. i'm a haskell beginner and try to understand IO. i want to write a function which asks for an userinsert and returns a string to work with in other functions. but this fails because getLn gives an IO String. so, is a IOfunction returning a normal string possible?
13:58:33 <EvilTerran> @go io monad don't care
13:58:36 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2008-September/047069.html
13:58:36 <lambdabot> Title: The IO sin bin [was: Re: [Haskell-cafe] Re: [Haskell] Top Level <-]
13:58:41 <vixey> Honen, what is the name of the function that takes the String as input?
13:58:42 <EvilTerran> grr
13:59:29 <EvilTerran> Honen, have a look at http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
13:59:31 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care, http://tinyurl.com/yplmwx
13:59:48 <Giraffe> EvilTerran, that seems like a cruel article name
14:00:12 <EvilTerran> Giraffe, i like that one for when people are just starting out, so they can do IO without having to worry about monads
14:00:53 <EvilTerran> when they've used that to become familiar with the rest of the language, then i start suggesting other monad tutorials :)
14:01:07 <vixey> > do 3
14:01:08 <lambdabot>       No instance for (Num (t t1))
14:01:08 <lambdabot>        arising from the literal `3' at <in...
14:01:10 <vixey> > do [3]
14:01:12 <lambdabot>   [3]
14:01:18 <EvilTerran> > do Nothing
14:01:18 <vixey> > do do do do do do [do [3]]
14:01:20 <lambdabot>   Nothing
14:01:20 <lambdabot>   [[3]]
14:01:27 <vixey> > do do do do Just (do do [do [3]])
14:01:29 <lambdabot>   Just [[3]]
14:02:00 <Giraffe> hahahaha
14:02:08 <idnar> do do do do do do do, do do do do do do, do do do do do, do do do do, do
14:02:10 <Giraffe> are monads really that difficult to comprehend?
14:02:18 <Giraffe> it just seemed to click for me
14:02:37 <trofi> @src Monad
14:02:38 <lambdabot> class  Monad m  where
14:02:38 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:02:38 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:02:38 <lambdabot>     return      :: a -> m a
14:02:38 <lambdabot>     fail        :: String -> m a
14:02:55 <EvilTerran> > don't do [1,2,3]
14:02:56 <lambdabot>   <no location info>: parse error on input `do'
14:03:01 <EvilTerran> > don't (do [1,2,3])
14:03:02 <lambdabot>   []
14:03:12 <Giraffe> trofi, if he doesn't understand classes he won't understand how a monad works, that's for sure
14:04:03 <trofi> i understand, i don't quite get them myself :]
14:04:14 <trofi> but it looks simple!
14:04:17 <Giraffe> oh :P
14:04:31 <Giraffe> here's a problem that isn't clicking for me, btw
14:04:34 <Giraffe> how do i get information from a PDF?
14:04:42 <vixey> read it :D
14:04:47 <SamB> Giraffe: most people use eyes for that
14:04:58 <EvilTerran> *predictable joke*
14:05:08 <SamB> actually ... it isn't a joke
14:05:57 <Giraffe> SamB, that's not quiiiiite what i mean :P
14:06:17 <EvilTerran> there isn't really a good way of getting content out of PDFs, iirc
14:06:23 <SamB> Giraffe: elaborate then
14:06:26 <trofi> pdf2txt
14:06:34 <EvilTerran> trofi, well, yes, when it works
14:06:37 <SamB> what information were you hoping to extract from what sort of PDF ?
14:06:43 <Giraffe> for a project of mine, i want to automatically go through until i find the ISBN of a publication
14:06:52 <trofi> sorry, pdftotxt
14:07:14 <Giraffe> EvilTerran, not all PDFs have a text layer
14:07:19 <SamB> Giraffe: well, that would work if the PDF had the back outside cover I guess ;-P
14:07:33 <Honen> question ... i wrote a function test = do word <- getLine return word. (works, what a surprise). and a second function, for example  test2 = words test . doesn't work caus' it's a IO String which test2 gets
14:07:35 <SamB> Giraffe: oh, so you want to OCR it ?
14:07:39 <SamB> or read the barcode ?
14:07:52 <Giraffe> hahaha, reading the barcode eh?
14:07:55 <Giraffe> that would be interesting
14:08:16 <Giraffe> i was thinking more along the lines of finding the ISBN in the first few pages
14:08:26 <trofi> some pdf's are composed from distinct letters(not words) (scribus generator?), pdftotext gives awful results there too
14:08:53 <Giraffe> Honen, haskell isn't quite like C/C++/Python/(the language you love that i completely forgot and that i am a jerk for forgetting)
14:09:05 <adityam> What is the canonical way of getting difference of successive elements of a list?
14:09:21 <Giraffe> adityam, like a map/fold?
14:09:24 <vixey> > scanl (flip (-)) [1..]
14:09:26 <lambdabot>       Overlapping instances for Show ([[t]] -> [[t]])
14:09:26 <lambdabot>        arising from a u...
14:09:31 <adityam> list = [a,b,c,d] and I want [ b-a, c-b, d-c, d]
14:09:35 <EvilTerran> > zipWith (-) <*> tail $ [a,b,c,d,e,f]
14:09:35 <andun> Honen: that wasn't a question, but i guess what you're looking for is something like: test2 = do s <- test; return (words test)
14:09:36 <vixey> not like that centainly
14:09:36 <lambdabot>   [a - b,b - c,c - d,d - e,e - f]
14:10:13 <EvilTerran> > zipWith subtract <*> tail $ [a,b,c,d,e,f]
14:10:13 <trofi> Honen: functions are pure, you can't read string from user without change outer users' world, co you can't (almost)
14:10:14 <lambdabot>   [b - a,c - b,d - c,e - d,f - e]
14:10:18 <adityam> EvilTerran: almost that. I want the last element to be f
14:10:22 <EvilTerran> ah
14:10:39 <Giraffe> adityam, if i had to guess...
14:10:45 <Giraffe> is this for some ranking system?
14:10:50 <EvilTerran> > zipWith subtract <*> (tail.(++[0])) $ [a,b,c,d,e,f]
14:10:51 <lambdabot>   [b - a,c - b,d - c,e - d,f - e,0 - f]
14:11:01 <EvilTerran> hm
14:11:07 <trofi> > permutations [1,2,3]
14:11:08 <adityam> No, Freudenthal Triangulation, Giraffe :)
14:11:08 <lambdabot>   Not in scope: `permutations'
14:11:29 <Giraffe> adityam, gesundheit
14:11:55 <adityam> Giraffe: what does gesundheit mean?
14:12:13 <Giraffe> like "bless you" when someone sneezes
14:12:20 <EvilTerran> @leo gesundheit
14:12:21 <lambdabot>   Parse error
14:12:36 <Giraffe> oh forget it, that's not even important
14:12:43 <adityam> EvailTerran: The reason I am not just doing ++ [0] is that I have heard that list concat can be constly
14:12:52 <adityam> Giraffe: ah, thanks
14:12:53 <Giraffe> SamB, any ideas on how i could manually poke around till i find something like "ISBN ..."
14:12:54 <EvilTerran> adityam, yeah, i'm just playing with it
14:13:05 <EvilTerran> adityam, it might be easiest to do it by direct recursion, to be honest
14:13:15 <SamB> Giraffe: where are you getting PDFs from ?
14:13:23 <Giraffe> SamB, i don't know
14:13:28 <Giraffe> it's not an application for me
14:13:39 <Giraffe> well, it can be, but even then i don't necessarily know where they'll be coming from
14:13:41 <SamB> well, do they actually have ISBNs in them ?
14:13:57 <adityam> EvilTerran: OK, I'll do direct recursion, which is pretty straightforward.
14:13:59 <Giraffe> they should
14:14:08 <SamB> and if it isn't in text, you'll presumably need to use OCR
14:14:20 <SamB> and/or barcode recognition
14:14:24 <Honen> so i can't transform a IO String to a "normal" string, right?
14:14:33 <Giraffe> Honen, no, but you can do it monadically!
14:14:38 <EvilTerran> Honen, you can, but only temporarily
14:14:39 <Giraffe> can you paste what you're trying to do again?
14:14:45 <Giraffe> EvilTerran is right
14:15:17 <EvilTerran> Honen, if you've got an IO String, m, you can get an appropriate String x with "x <- m" as a line in a do-block
14:15:20 <earthy> an IO String is a string dressed up in pretty tattoos
14:15:23 <Giraffe> i kind of like thinking of monadic programming as directing the course of a lot of different streams in a river
14:15:28 <EvilTerran> but then the do-block has to return an IO value
14:15:35 <earthy> you can hide the tattoos, but they'll always stay on
14:15:37 <EvilTerran> the IO "tag" in the type indicates the presence of side-effects
14:15:57 <earthy> and removal is hard, painful and not necessarily possible
14:15:59 <Giraffe> a monad is like a divergent stream--it might have the same stuff in it, but it's distinctly separate from the rest of the program
14:16:41 <trofi> @hoogle IO a -> a
14:16:41 <lambdabot> Foreign unsafePerformIO :: IO a -> a
14:16:41 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
14:16:41 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
14:16:49 * earthy kicks trofi
14:16:53 <Giraffe> oh god
14:16:54 <Giraffe> stop that
14:16:55 <Giraffe> right now
14:17:04 <earthy> this is *not* something you want to teach
14:17:14 <Giraffe> Honen, don't use those functions
14:17:25 <vixey> Honen, what is the name of the function that takes the String as input?
14:17:29 <FunctorSalad> look away! :)
14:17:58 <Honen> just called it "input"
14:18:04 <Giraffe> alright then!
14:18:08 <Giraffe> getLine >>= input
14:18:10 <vixey> Honen, so what is the type of input?
14:18:12 <Giraffe> done
14:18:25 <vixey> :t getLine >>= reverse
14:18:26 <lambdabot>     Couldn't match expected type `IO b' against inferred type `[Char]'
14:18:26 <lambdabot>       Expected type: String -> IO b
14:18:26 <lambdabot>       Inferred type: [Char] -> [Char]
14:18:31 <vixey> Giraffe: (not quite yet)
14:18:55 <trofi> how about (input.print) ?
14:19:03 <baaba> getLine >>= liftM input
14:19:21 <Giraffe> :t getLine
14:19:23 <lambdabot> IO String
14:19:23 <vixey> Honen: (Do you know how to get the type of it?)
14:19:34 <Giraffe> let's not make him answer if he's bashful
14:19:41 <Honen> IO String
14:19:56 <Giraffe> Honen, just do :type input (where input is the function that takes a String) in ghci
14:20:04 <vixey> Honen, oh sorry, I meant what is the typef the function you want to _use_ with the input string
14:20:17 <vixey> Honen, it must be String -> <something> but I don't know what that something is
14:20:35 <Honen> String -> [String]
14:20:42 <Giraffe> oh right, you're using unlines
14:20:50 <vixey> Honen, ok and then you want to print out all the [String] list?
14:21:07 <Giraffe> hmm...
14:21:12 <Giraffe> :t getLine >>= print.unlines
14:21:14 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
14:21:14 <lambdabot>       Expected type: String -> b
14:21:14 <lambdabot>       Inferred type: [String] -> String
14:21:20 <trofi> :t interact
14:21:21 <lambdabot> (String -> String) -> IO ()
14:21:42 <Honen> yes
14:21:59 <vixey> Honen, so you probably did try something like  let input = getLine in unlines input ?
14:22:00 <FunctorSalad> :t getLine <$> input
14:22:01 <lambdabot> Not in scope: `input'
14:22:12 <vixey> Honen, and of course didn't work with the IO stuff in the way
14:22:26 <FunctorSalad> let input x = x ++ ", in the type system"
14:22:31 <FunctorSalad> @let input x = x ++ ", in the type system"
14:22:32 <lambdabot>  Defined.
14:22:35 <FunctorSalad> :t getLine <$> input
14:22:36 <lambdabot>     Couldn't match expected type `a -> b'
14:22:36 <lambdabot>            against inferred type `IO String'
14:22:36 <lambdabot>     In the first argument of `(<$>)', namely `getLine'
14:22:50 <Honen> yes, as i realised :(
14:22:52 <FunctorSalad> :t input <$> getLine
14:22:53 <lambdabot> IO [Char]
14:22:56 <FunctorSalad> finally :)
14:23:03 <Giraffe> you know, i don't even know what <$> does
14:23:14 <Giraffe> i know what $ does, but is <$> different somehow?
14:23:28 <EvilTerran> yes
14:23:29 <trofi> :t (<$>)
14:23:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:23:31 <EvilTerran> <$> is `fmap`
14:23:32 <vixey> Honen, so the fix is,  you can write  print . lines =<< getLine
14:23:32 <MyCatVerbs> Giraffe: <$> is a synonym for fmap.
14:23:33 <FunctorSalad> Giraffe: it's synonymous to `liftM` for monads
14:23:34 <Giraffe> ah,i aws gonna say
14:23:39 <Giraffe> i was gonna say*
14:23:50 <vixey> Honen, (Incase you haven't seen it before, do you know what (.) is?)
14:23:54 <Giraffe> then what are * and <*>?
14:23:59 <EvilTerran> * is multiplication
14:24:03 <MyCatVerbs> Giraffe: because Haskell geeks like things that do analogous things to one another to have similar symbols. :)
14:24:05 <EvilTerran> <*> is synonymous to `ap` for monads
14:24:06 <skorpan> <*> is division by zero
14:24:20 <Giraffe> MyCatVerbs, that's fine, i like it too :P
14:24:20 * MyCatVerbs baps skorpan.
14:24:26 <vixey> Giraffe, f <$> x <*> y <*> z = liftM3 f x y z
14:24:37 <Giraffe> vixey, uh huh
14:24:46 <Honen> yes, ruffly
14:24:47 <Giraffe> fascinating
14:24:48 <FunctorSalad> what is *that*, vixey :o ?
14:24:48 <EvilTerran> Giraffe, when the side-effects of "f <*> x" are run, first the side-effects of f are run, then the side-effects of x
14:24:54 <FunctorSalad> the (->) Applicative?
14:25:02 <Giraffe> :t (<*>)
14:25:04 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:25:07 <vixey> Giraffe, Hopefully that helps with (<Giraffe> you know, i don't even know what <$> does)........
14:25:14 <Giraffe> vixey, it does!
14:25:17 <EvilTerran> Giraffe, and the result of running f is applied as a function to the result of running x
14:25:39 <vixey> Honen, so (f . g) x is just shorthand for f (g x)
14:25:53 <Giraffe> EvilTerran, fascinating
14:26:04 <Giraffe> this language is so much fun to play with
14:26:10 <EvilTerran> note that "side-effect" is a very flexible term in haskell
14:26:15 <Giraffe> right
14:26:22 <vixey> Honen, anyway if that syntax with =<< is too awkward you can also write   do input <- getLine ; print (lines input)
14:26:32 <EvilTerran> for instance, if f = Maybe
14:26:34 <EvilTerran> ?src Maybe
14:26:34 <lambdabot> data Maybe a = Nothing | Just a
14:26:45 <EvilTerran> then "normal operation" is to work in "Just"s
14:26:49 <vixey> Honen, This is the exact same function but written in different notation.. Something important to notice is that 'input' in there has type String, not IO String :)
14:26:50 <Giraffe> hey, i know what Maybe is :P
14:26:56 <vixey> Honen, does it make sense?
14:26:57 <Giraffe> right
14:27:01 <EvilTerran> > Just (^2) <$> Just 4
14:27:02 <lambdabot>   Couldn't match expected type `a -> b'
14:27:06 <EvilTerran> er
14:27:08 <EvilTerran> > Just (^2) <*> Just 4
14:27:10 <lambdabot>   Just 16
14:27:16 <Giraffe> oh wow
14:27:18 <Giraffe> awesome!
14:27:24 <EvilTerran> and the only possible side-effect is "give up and become Nothing"
14:27:25 <vixey> > (+1) <$> Nothing
14:27:26 <lambdabot>   Nothing
14:27:33 <Giraffe> yeah
14:27:39 <EvilTerran> > (Nothing <*> Just 4, Just (^2) <*> Nothing, Nothing <*> Nothing)
14:27:40 <lambdabot>   (Nothing,Nothing,Nothing)
14:27:42 <roconnor> Maybe is a great way of learning monads
14:27:45 <Giraffe> i wonder...why isn't haskell very widely used?
14:28:04 <roconnor> Especially if you have a big chain of case  statements with Nothing -> Nothing in your code
14:28:06 <Giraffe> roconnor, i agree
14:28:12 <Giraffe> i think RWH actually teaches them pretty well
14:28:15 <idnar> Giraffe: Haskell has only really started to pick up recently, I think
14:28:16 <roconnor> that's how I learned
14:28:20 <vixey> humf
14:28:22 <EvilTerran> Giraffe, because it's harder to muddle through in haskell
14:28:26 <idnar> in terms of community, libraries, and so on
14:28:30 <FunctorSalad> 2009 is the year of Haskell on the desktop
14:28:35 <FunctorSalad> ;)
14:28:38 <Giraffe> EvilTerran, you mean it forces you to code...well?
14:28:42 <EvilTerran> basically, yeah
14:28:43 <Giraffe> that's not profitable though!
14:28:44 <idnar> couple that with the fact that a) writing bad Haskell code is a lot harder, and b) functional programming is still "weird" to most people
14:28:46 <EvilTerran> it'll never catch on
14:28:49 <roconnor> IO is a bad way of learning monads, cause IO is kinda weird.
14:28:59 <EvilTerran> because the majority of people who work as programmers really aren't very good at it
14:29:01 <idnar> and you have all the makings for slow adoption ;)
14:29:03 <xcthulhu> roconnor: List is another nice monad
14:29:17 <roconnor> yep list is a great second monad example.
14:29:20 <idnar> Giraffe: well, it's more specific than that; most broken Haskell programs won't compile ;)
14:29:40 <roconnor> because Maybe and List are relatively similar
14:29:41 <idnar> if you're writing high-quality software, this is great
14:29:43 <EvilTerran> i'm perennially horrified by how little so many of my programmer friends know about formal reasoning
14:29:44 <Giraffe> idnar, yeah
14:29:50 <idnar> if you just want some junk that maybe sometimes works on a tuesday, then it's not good at all
14:29:56 <Giraffe> EvilTerran, i don't know if i know it by that name
14:30:01 <Honen> guess i'll have some more of these "really easy" tutorials about monads and input
14:30:02 <roconnor> > return 5 : [] Int
14:30:03 <lambdabot>   Not in scope: data constructor `Int'
14:30:06 <roconnor> > return 5 :: [] Int
14:30:07 <vixey> EvilTerran, and of those that do, How many apply it in practice?
14:30:07 <lambdabot>   [5]
14:30:10 <Giraffe> Honen, hmm
14:30:10 <EvilTerran> given that programming is, by its very nature, formal; computers do *exactly* what you tell them to do, even if it's not what you meant
14:30:11 <Giraffe> PM?
14:30:18 <Giraffe> exactly!
14:30:29 <vixey> Honen, Did anything I said not make sense?
14:30:34 <Giraffe> years ago i remember watching a friend try to make a game where the main player jumped
14:30:36 <xcthulhu> idnar: Hmmm... Godel was a functional programmer
14:30:42 <Giraffe> and all he did was do jump()
14:30:45 <vixey> xcthulhu, lisp hacker
14:30:50 <xcthulhu> totally
14:30:50 <Giraffe> didn't define it, then he didn't know why it didn't work...
14:30:51 <Giraffe> D:
14:30:52 <vixey> xcthulhu, according to Chaitin
14:31:09 <xcthulhu> vixey: Just read on formally undecidable propositions.
14:31:14 <vixey> aha :))
14:31:24 <EvilTerran> vixey, i feel that, if you have the knowledge to reason formally about code, then, even if you're not conciously applying it in practice, you'll still be writing better-structured code
14:31:29 <EvilTerran> in my experience, anyway
14:31:34 <Giraffe> i agree
14:31:46 <idnar> Giraffe: import IDSoftware; main = Quake3
14:31:51 <idnar> Giraffe: look, I wrote a first-person shooter ;)
14:31:52 <Giraffe> oh god
14:31:54 <EvilTerran> it's the "ever since i learnt haskell, i've been trying to write haskell in $other_language" effect
14:31:56 <Giraffe> WHY
14:32:04 <vixey> EvilTerran, I agree with that but only up to certain barrier
14:32:18 <xcthulhu> EvilTerran: Hehe, like my mathematics courses
14:32:54 <EvilTerran> vixey, indeed, there's a limit, but i start to get worried when none of the masters students who didn't do their undergrad here claim to have never heard of predicate logic
14:33:05 <Giraffe> what i like about haskell is that while it is a high level language, it's low-level in terms of mathematical logic
14:33:10 <Giraffe> which i think is both fascinating and wonderufl
14:33:12 <Giraffe> wonderful*
14:33:31 <BMeph> EvilTerran: Wha?!? I did pred logic in junior high!
14:33:36 <yuuki> So I've spent some time uncovering a well-typed, one-combinator basis for CoC
14:33:46 * Giraffe hasn't heard of predicate logic...
14:33:48 <idnar> BMeph: man
14:33:49 <Giraffe> :x
14:33:52 <vixey> yuuki, I can't tell if you are joking ? :P
14:33:54 <idnar> BMeph: the only reason why I've heard of predicate logic is GEB
14:33:56 <EvilTerran> Giraffe, the way i see it, imperative languages are fundamentally designed around the way a computer works; haskell, like the mind of a mathematician works :)
14:34:08 <FunctorSalad> EvilTerran: graduates in mathematics?
14:34:10 <EvilTerran> BMeph, er, sorry, propositional logic
14:34:15 <EvilTerran> FunctorSalad, computer scientists
14:34:16 <yuuki> And then I realized that parenthesis are required.  So the basis is actually { (, ), X }, where X is the "one-combinator" basis
14:34:17 <Giraffe> oh wait, i see...
14:34:21 <Giraffe> THAT'S what predicate logic is
14:34:28 <Giraffe> then i guess i knew what it was, just not by that name
14:34:29 <EvilTerran> predicate; propositional... i forget
14:34:33 <Giraffe> (thanks hofstadter <3)
14:34:34 <BMeph> EvilTerran: Okay, that makes more sense. :)
14:34:43 <yuuki> I think that can be reduced to a single parenthetical combinator and the X combinator
14:34:49 <FunctorSalad> EvilTerran: okay. for math students I wouldn't be horrified if they didn't specialize on logic
14:34:54 <idnar> I also meant propositional logic, probably
14:35:15 <vixey> yuuki, what's the definitino of X?
14:35:24 <yuuki> Xx = xKSK
14:35:29 <yuuki> It's Rosser's X
14:35:50 <EvilTerran> actually, it'd be odd if they'd met predicate logic without meeting propositional logic, seeing as propositional is a sublanguage of predicate
14:36:12 <yuuki> It's enough to express any lambda expression -- if you use parentheses
14:36:24 <Giraffe> oh, speaking of lambdas
14:36:31 <FunctorSalad> @botsnack
14:36:31 <lambdabot> :)
14:36:38 <vixey> but well typed? that seems like a really lucky coincidence
14:36:44 <Giraffe> i think what honestly got me into functional programming as more than just a fun hobby was implementing exponentiation with church nummerals
14:36:52 <EvilTerran> vixey, i think it's for the untyped \calc
14:37:01 <Giraffe> it just seems so much more...beautiful and elegant than other languages try to be
14:37:06 <vixey> no CoC
14:37:07 <yuuki> vixey, yes.  There is another simpler combinator created by Fokker which is not well-typed
14:37:18 <EvilTerran> ?type \x -> x const ap const
14:37:19 <lambdabot> forall a b (m :: * -> *) a1 b1 a2 b2 t. (Monad m) => ((a -> b -> a) -> (m (a1 -> b1) -> m a1 -> m b1) -> (a2 -> b2 -> a2) -> t) -> t
14:37:33 <yuuki> K = XXX
14:37:37 <EvilTerran> huh. well, isn't that something
14:37:50 <roconnor> @quote dijkstra
14:37:50 <lambdabot> No quotes match. stty: unknown mode: doofus
14:37:57 <roconnor> @quote Dijkstra
14:37:58 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
14:37:58 <lambdabot> regeneration."
14:38:03 <vixey> ?djinn ((a -> b -> a) -> (m (a1 -> b1) -> m a1 -> m b1) -> (a2 -> b2 -> a2) -> t) -> t
14:38:03 <lambdabot> -- f cannot be realized.
14:38:09 <Giraffe> roconnor, :(
14:38:12 <yuuki> ?type let rosser = \x -> x const ap const in rosser rosser rosser
14:38:13 <lambdabot>     Ambiguous type variable `m1' in the constraint:
14:38:13 <EvilTerran> djinn doesn't do monads
14:38:14 <lambdabot>       `Monad m1' arising from a use of `rosser' at <interactive>:1:39-58
14:38:14 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
14:38:17 <xcthulhu> lol
14:38:19 <vixey> ?djinn ((a -> b -> a) -> ((e -> (a1 -> b1)) -> (e -> a1) -> (e -> b1)) -> (a2 -> b2 -> a2) -> t) -> t
14:38:19 <lambdabot> f a = a (\ b _ -> b) (\ c d e -> c e (d e)) (\ f _ -> f)
14:38:25 <roconnor> @quote Dijkstra
14:38:25 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
14:38:26 <lambdabot> regeneration."
14:38:30 <roconnor> :(
14:38:40 <Giraffe> it is a shame, really
14:38:44 <EvilTerran> ?pl f a = a (\ b _ -> b) (\ c d e -> c e (d e)) (\ f _ -> f)
14:38:44 <lambdabot> f = flip (flip ($ const) ap) (const id)
14:39:12 <Giraffe> that we teach people to use languages that are pretty mediocre because they're what's big at the time
14:39:14 <FunctorSalad> I think Dijkstra is exaggerating there
14:39:22 <Giraffe> he is, i started programming in C
14:39:27 <EvilTerran> ?let rosser ::((a -> b -> a) -> ((e -> (a1 -> b1)) -> (e -> a1) -> (e -> b1)) -> (a2 -> b2 -> a2) -> t) -> t; rosser a = a (\ b _ -> b) (\ c d e -> c e (d e)) (\ f _ -> f)
14:39:28 <lambdabot>  Defined.
14:39:36 <EvilTerran> ?type rosser rosser rosser
14:39:38 <lambdabot> forall a2 b2. a2 -> b2 -> a2
14:39:42 <vixey> Girafffe, how can anyone know their own potential?
14:39:49 <yuuki> ?type rosser ( rosser ) ( rosser )
14:39:50 <lambdabot> forall a2 b2. a2 -> b2 -> a2
14:39:52 <Giraffe> vixey, how do you know?
14:39:56 <BMeph> I started programming with BASIC, but then I learned Forth... >;)
14:39:56 <Giraffe> er...
14:39:59 <yuuki> ?type rosser ( rosser rosser )
14:39:59 <Giraffe> what do you mean?*
14:40:00 <lambdabot> forall e a1 b1. (e -> a1 -> b1) -> (e -> a1) -> e -> b1
14:40:04 <yuuki> That's S
14:40:22 <xcthulhu> Giraffe: Are you implying there's something wrong about learning C first?
14:40:27 <vixey> yuuki, this is so cool :)
14:40:29 <EvilTerran> and SK are all you need!
14:40:32 <Giraffe> xcthulhu, no, i like C :P
14:40:40 <xcthulhu> Me too...
14:40:57 <idnar> I learned BASIC first, I think, but I didn't have any trouble transitioning to other languages
14:41:28 <Giraffe> i'm saying that while it seems like he's exaggerating, i get the point--trying to teach a functional language to people who are used to only programming (poorly) in more hackish languages is very difficult
14:41:30 <yuuki> :t \f -> f const ( \x y z -> x )
14:41:31 <lambdabot> forall a b t t1 t2 t3. ((a -> b -> a) -> (t -> t1 -> t2 -> t) -> t3) -> t3
14:41:39 <yuuki> That is fokker's X
14:41:59 <yuuki> :let fokker = \f -> f const ( \x y z -> x )
14:42:19 <yuuki> ?let fokker = \f -> f const ( \x y z -> x )
14:42:20 <lambdabot>  Defined.
14:42:37 <badsheepy> people who only program poorly in any language are hard to teach
14:42:38 <yuuki> Here, K = fokker fokker.  But it isn't well-typed
14:43:05 <yuuki> :t fokker fokker
14:43:07 <lambdabot> forall b t t1 t2. b -> t -> t1 -> t2 -> t
14:43:11 * BMeph mutters "fokker"
14:43:25 <yuuki> oops.  I thought it wasn't well typed :)
14:43:33 <EvilTerran> it's not k...
14:43:44 <yuuki> Hmm.. what went wrong here :)
14:44:04 <yuuki> sorry, the definition was supposed to have ap not const
14:44:24 <idnar> :t let fokker = \f -> ap const ( \x y z -> x ) in fokker fokker
14:44:25 <lambdabot> forall a. a -> a
14:44:28 <idnar> er
14:44:31 <idnar> :t let fokker = \f -> ap ( \x y z -> x ) in fokker fokker
14:44:32 <yuuki> ?let fokker = \f -> f (\x y z -> x z (y z )) ( \x y z -> x )
14:44:33 <lambdabot> forall t a t1. (t -> a) -> t -> t1 -> t
14:44:34 <lambdabot>  <local>:10:0:
14:44:34 <lambdabot>      Multiple declarations of `L.fokker'
14:44:34 <lambdabot>      Declared at: <lo...
14:44:41 <Giraffe> i worry about the use of do by people who may not understand haskell too quickly
14:44:56 <Giraffe> and thus who might think it's just some language where you can't make assignment
14:45:04 <yuuki> Did universes just collide?
14:45:23 <yuuki> ?let fokker = \f -> f (\x y z -> x z (y z )) ( \x y z -> x )
14:45:24 <lambdabot>  <local>:10:0:
14:45:24 <lambdabot>      Multiple declarations of `L.fokker'
14:45:24 <lambdabot>      Declared at: <lo...
14:45:31 <EvilTerran> yuuki, you need to ?undef; it clears the ?lets
14:45:37 <vixey> :t rosser rosser rosser
14:45:38 <lambdabot> forall a2 b2. a2 -> b2 -> a2
14:45:39 <yuuki> ?undef fokker
14:45:40 <vixey> :t rosser rosser
14:45:41 <lambdabot> Not in scope: `rosser'
14:45:41 <lambdabot> Not in scope: `rosser'
14:45:43 <vixey> grrrrr
14:45:45 <yuuki> ?let fokker = \f -> f (\x y z -> x z (y z )) ( \x y z -> x )
14:45:46 <lambdabot>  Defined.
14:45:47 <trofi> IO is bad example of monads, parsers like parsec are far better to understand concept, imho
14:45:50 <EvilTerran> yuuki, ?undef takes everything, unfortunately
14:45:57 <yuuki> yikes, that's no good
14:46:04 <Giraffe> trofi, i agree
14:46:08 <vixey> ?let fokker = \f -> f (\x y z -> x z (y z )) ( \x y z -> x )
14:46:09 <lambdabot>  <local>:2:0:
14:46:09 <lambdabot>      Multiple declarations of `L.fokker'
14:46:09 <lambdabot>      Declared at: <loc...
14:46:13 <yuuki> ?let rosser ::((a -> b -> a) -> ((e -> (a1 -> b1)) -> (e -> a1) -> (e -> b1)) -> (a2 -> b2 -> a2) -> t) -> t; rosser a = a (\ b _ -> b) (\ c d e -> c e (d e)) (\ f _ -> f)
14:46:14 <lambdabot>  Defined.
14:46:18 <Giraffe> i just don't see what's so difficult about them...
14:46:20 <vixey> :t rosser rosser
14:46:20 <xcthulhu> trofi: Or, Category theory for the Working Mathematician
14:46:21 <lambdabot> forall b2 a2 b21. b2 -> a2 -> b21 -> a2
14:46:21 <yuuki> :t fokker fokker
14:46:23 <lambdabot>     Occurs check: cannot construct the infinite type:
14:46:23 <lambdabot>       t1 = t5 -> t -> t1 -> t2
14:46:23 <lambdabot>     Probable cause: `fokker' is applied to too many arguments
14:46:29 <EvilTerran> there we go
14:46:32 <yuuki> Yes, it creates an infinite type
14:46:53 <EvilTerran> you can probably define it with Mu Endo
14:46:56 <yuuki> So rosser seems to be the simplest one-combinator basis for typed lambda calculus
14:47:06 <yuuki> What is Mu Endo?
14:47:09 <EvilTerran> ?src Endo
14:47:10 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:47:19 <EvilTerran> newtype Endo a = Endo (a -> a)
14:47:24 <idnar> @type Mu Endo
14:47:25 <lambdabot> Not in scope: data constructor `Mu'
14:47:29 <EvilTerran> ?src Mu
14:47:29 <idnar> er
14:47:29 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
14:47:30 <idnar> @kind Mu Endo
14:47:31 <lambdabot> *
14:47:38 <EvilTerran> Mu is type-level fixed-point
14:47:43 <vixey> I need some metaprogram that does HM type inference in Coq :/
14:47:56 * vixey was trying to put these definitions in but they don't get types inferred
14:48:04 <yuuki> vixey, hehe.  It's fun to see the type inference as it goes
14:48:13 <EvilTerran> so Mu Endo  ~~  Mu Endo -> Mu Endo  ~~  (Mu Endo -> Mu Endo) -> (Mu Endo -> Mu Endo)  ~~  ...
14:48:15 <idnar> @type In Endo
14:48:16 <lambdabot>     Couldn't match expected type `Mu ((->) (a -> a))'
14:48:16 <lambdabot>            against inferred type `Endo a'
14:48:16 <lambdabot>       Expected type: (a -> a) -> Mu ((->) (a -> a))
14:48:19 <vixey> it's really cool :)
14:48:26 <EvilTerran> ?type In . Endo
14:48:27 <lambdabot> (Mu Endo -> Mu Endo) -> Mu Endo
14:48:37 <vixey> I wonder if you can put down some proofs in it
14:48:38 <EvilTerran> ?type unEndo . out
14:48:39 <lambdabot> Not in scope: `unEndo'
14:48:42 <EvilTerran> ?type runEndo . out
14:48:43 <lambdabot> Not in scope: `runEndo'
14:48:46 <EvilTerran> ?type getEndo . out
14:48:47 <lambdabot> Not in scope: `getEndo'
14:48:50 <EvilTerran> ...grr
14:48:51 <idnar> heh
14:48:58 <idnar> @hoogle Endo
14:48:58 <lambdabot> Data.Monoid newtype Endo a
14:48:58 <lambdabot> Data.Monoid Endo :: a -> a -> Endo a
14:48:58 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
14:48:59 <EvilTerran> ?type appEndo . out
14:49:00 <lambdabot> Mu Endo -> Mu Endo -> Mu Endo
14:49:03 <yuuki> This paper has Rosser, Fokker, and some other one-combinator bases
14:49:04 <yuuki> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.5163
14:49:05 <lambdabot> Title: The systematic construction of a one-combinator basis for Lambdaterms,â€ Formal ...
14:49:23 <EvilTerran> so In . Endo :: (Mu Endo -> Mu Endo) -> Mu Endo, and appEndo . out :: Mu Endo -> Mu Endo -> Mu Endo
14:49:47 <idnar> yet again, my head is exploding
14:50:16 <yuuki> vixey, yes, I wrote a proof isomorphic to rosser rosser rosser proving K's type
14:50:32 <yuuki> All the action happens in the type unification
14:50:50 <EvilTerran> idnar, the point is that you can express any untyped lambda-calc term within the type Mu Endo
14:50:52 <yuuki> Needless to say, doing it in your head is impossible
14:51:03 <ddarius> data U = U (U -> U)
14:51:10 <ddarius> D ~ D -> D
14:51:14 <idnar> EvilTerran: I don't know lambda-calc, so that doesn't really help me
14:51:16 <EvilTerran> idnar, because you can keep expanding a Mu Endo to a Mu Endo -> Mu Endo, or vice-versa
14:51:27 <yuuki> EvilTerran, you can represent *terms* within the *type* of mu endo?
14:51:43 <EvilTerran> mu endo is a type, it doesn't have a type
14:51:50 <EvilTerran> i mean as values of the type mu endo
14:52:06 <yuuki> Right
14:52:13 <yuuki> You can represent terms using a type!?
14:52:33 <EvilTerran> no... i just said no to that
14:52:37 <roconnor> bah.  I can't find that Dijkstra quote about programmers wanting "easier" langauges because they get tired of the compiler pointing out their mistakes all the time.
14:52:50 <EvilTerran> 1,2,3 etc are values of the type Int, or the type Float, or whatever
14:52:53 <dons> heh
14:53:02 <yuuki> Oh, I see what you mean
14:53:03 <EvilTerran> S, K, I can be expressed as values of the type Mu Endo
14:53:31 <yuuki> What is the type of Mu Endo?
14:53:37 <yuuki> I didn't really understand the output of lambdabot
14:53:41 <EvilTerran> Mu Endo is a type
14:53:49 <EvilTerran> like Maybe Int is a type
14:53:54 <yuuki> I mean, what is the type Mu Endo?
14:53:54 <trofi> @src Mu
14:53:54 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
14:54:03 <vixey> Mu is the fixed point of a data
14:54:09 <vixey> :t Nothing :: Mu Maybe
14:54:10 <lambdabot>     Couldn't match expected type `Mu Maybe'
14:54:11 <lambdabot>            against inferred type `Maybe a'
14:54:13 <vixey> :/
14:54:14 <EvilTerran> it's the fixed-point of \T. (T -> T)
14:54:19 <vixey> :t Nothing :: Maybe (Mu Maybe)
14:54:20 <idnar> :t In Nothing
14:54:20 <lambdabot> Maybe (Mu Maybe)
14:54:21 <lambdabot> Mu Maybe
14:54:24 <vixey> :t In Nothing :: Mu Maybe
14:54:25 <lambdabot> Mu Maybe
14:54:28 <yuuki> Hmm
14:54:29 <vixey> :t In Just (In Nothing) :: Mu Maybe
14:54:30 <lambdabot>     Couldn't match expected type `Mu ((->) a)'
14:54:31 <lambdabot>            against inferred type `Maybe a'
14:54:31 <lambdabot>       Expected type: a -> Mu ((->) a)
14:54:37 <vixey> :t In (Just (In Nothing)) :: Mu Maybe
14:54:38 <lambdabot> Mu Maybe
14:54:40 <vixey> grr I suck at this..
14:54:43 <idnar> heh
14:54:48 <ddarius> yuuki: It's isomorphic to the type U I mentioned above or the domain equation D.
14:54:55 <vixey> so Maybe x = 1 + x, Mu Maybe = 1 + (1 + ...) = N
14:54:56 <yuuki> I guess I only know about types that look like T = a | b | c | ... | T -> T
14:55:19 <EvilTerran> it's isomorphic to "data T = T (T -> T)"
14:55:47 <trofi> sounds terribly unusable :]
14:55:50 <EvilTerran> to be honest, this is a pretty boring type, because you can't tell the values apart
14:55:52 <EvilTerran> but
14:56:08 <yuuki> T ( T -> T ) isn't a type, though, right?
14:56:12 <EvilTerran> "data T a = T (T a -> T a) | V a" is more interesting
14:56:15 <EvilTerran> say
14:56:16 <ddarius> trofi: It's as useful as the pure untyped lambda calculus.
14:56:33 <EvilTerran> yuuki, no, the first T is the constructor's name, and the (T -> T) is the type of its parameter
14:57:14 <yuuki> Hmm
14:57:22 <yuuki> Not a type in the CoC?
14:57:31 <EvilTerran> the what?
14:57:42 <vixey> yuuki, you won't get that in CoC or CIC, leads to paradoxen
14:58:05 <vixey> consider i.e. data Untypd = Lam (Untypd -> Untypd) | App Untypd Untypd
14:58:48 <yuuki> But anyways, my whole point in bringing up rosser is that one still needs parethesis
14:59:10 <yuuki> without parentheses, one can only derive K = XXX, and not S = X(XX)
14:59:15 <vixey> it seems like you have two options to apply (XX)X and X(XX)
14:59:25 <vixey> yes
14:59:54 <yuuki> So it's actually a 3-combinator(?) basis, { X, (, ) }
15:00:10 <vixey> I don't know why you consider the ()'s in the basis though
15:00:15 <EvilTerran> you can indicate grouping with only one symbol; a post-fix application symbol
15:00:20 <yuuki> Yes
15:00:21 <EvilTerran> then it's RPN
15:00:28 <yuuki> so, it would be { X, * }
15:00:36 <vixey> I mean you could say it's a 4 combinator basis,  { >, <, (, ) } > and < make an X :p
15:00:43 <yuuki> haha
15:00:56 <EvilTerran> it's a two-symbol language
15:01:07 <EvilTerran> although any language can be reduced to a one-symbol one via goedel numbers
15:01:08 <yuuki> right
15:01:10 <vixey> concrete syntax needs parameters
15:01:26 <vixey> abstract syntax is data X = X | App X X
15:01:36 <vixey> oops
15:01:40 <vixey> concrete syntax needs parenthesis*
15:02:00 <EvilTerran> ?
15:03:00 <yuuki> XX*X* = K
15:03:21 <yuuki> oops, that's S
15:03:25 <yuuki> XXX** = K
15:03:59 <explicitjelly> what's a good way to publish haskell code on the web?
15:04:03 <explicitjelly> something like code to html, maybe
15:04:18 <vixey> explicitjelly, htmlize-buffer in emacs doesn't work :(
15:04:30 <shepheb> explicitjelly: you can host code repos on code.haskell.org
15:04:35 <yuuki> vixey, it seems that if we are rigorous in our definitions, that both X and * are combinators
15:04:40 * ddarius is pretty confident the html generation stuff in vim works.
15:04:46 <trofi> maybe, he wants suynthax highlight
15:04:52 <vixey> ddarius, cool! thanks
15:05:08 <vixey> I feel stupid not having thought to try that earliel.. :)
15:05:22 <explicitjelly> vixey, ddarius, I like emacs htmlize but even if it would work, seems a bit tedious for a big bunch of code
15:05:39 <vixey> explicitjelly, since you can program it in elisp I don't think it is tedious
15:05:53 <ddarius> yuuki: Combinators form an applicative structure.  Combinatory logic is the study of these applicative structures.  So not counting application doesn't seem unreasonable.
15:05:57 <explicitjelly> vixey, yes, but I would have to write some elisp start just to get a directory htmlized, no?
15:06:07 <explicitjelly> -start+stuff
15:06:20 <vixey> explicitjelly, don't be scared to write a little lisp :p
15:06:38 <vixey> explicitjelly, in any case it doesn't really matter because the whole thing is screwed anyway
15:06:38 <ddarius> Install yi and then write the necessary Haskell.
15:07:13 <trofi> hscolour
15:07:51 <explicitjelly> trofi, hscolour?
15:08:03 <trofi> could gen colourized html haskell code
15:08:31 <explicitjelly> shepheb, maybe that's the best idea so far. but suppose I wouldn't want it published on code.haskell.org? (I think it's okay in that particular case)
15:09:54 <yuuki> I wonder if any t = X | (t t) is well-typed
15:10:19 <yuuki> I guess not, since the Y combinator can be constructed from X
15:10:40 <explicitjelly> what is the X combinator?
15:11:11 <yuuki> It's Xx = xKSK
15:11:21 <yuuki> So that K = XXX and S = X(XX)
15:11:56 <explicitjelly> ah, nice
15:12:07 <the_unmaker> do you gents use that haskell gui dev tool?
15:12:11 <yuuki> It's Rosser's X combinator
15:12:11 <the_unmaker> or use emacs?
15:12:15 <the_unmaker> or just use vi?
15:12:18 <ddarius> I think they made the syntax2html script a little less braindead over the last seven years.
15:12:35 <yuuki> There are many X combinators, but Rosser's is the simplest that defines a well-typed complete basis
15:13:32 <idnar> what is type erasure?
15:13:33 <explicitjelly> so, any more ideas for publishing code? some CGI would be nice
15:14:06 <ddarius> explicitjelly: hscolour is what you want
15:14:14 <explicitjelly> ddarius, hscolour. will look into it, thanks
15:15:12 <vixey> hey just thinking about that numbering problem again
15:15:21 <vixey> instead of breadth first what if you wanted to do it depth first?
15:15:40 <vixey> data Tree a = Leaf a | Tree a (Tree a) (Tree a)
15:15:41 <yuuki> vixey, which numbering problem is this, if I might ask?
15:15:52 <vixey> yuuki, before it was depth first numbering of a tree
15:16:03 <vixey> but now I'm wondering about (hopefully simpler problem) depth first
15:16:22 <yuuki> before it was breadth first, you mean?
15:16:29 <vixey> oh yes
15:17:55 <yuuki> Unless the tree is extremely unbalanced, depth first should take less memory
15:18:11 <yuuki> You just need a stack which is the path from the root to the current node
15:18:38 <yuuki> For a breadth first you need a queue which holds at most every node on the next level of the tree
15:19:31 <yuuki> I don't know if that's the problem you're trying to solve or not :)
15:21:28 <mlesniak> Can someone please explain why using newtype on p. 240 of RWH (Implicit State/Chapter 10) is necessary or good style?
15:24:43 <ikkebr> haskell makes me afraid
15:24:43 <ikkebr> fa a ((b,t):x) c = fa a ( [head ((sort(([( minimum [k, addCosts (lookUp (t,m) a) b] , m) |(k,m)<- c]))))]++x++[(b,t)]) (tail( sort( [ (minimum( [k, addCosts (lookUp(t,m)a) b] ),m) | (k,m) <- c ])))
15:25:26 <vixey> ikkebr, it shouldn't look like that
15:26:26 <aconbere> I'm looking for a way to "apply" a list of values to a function as function arguments
15:26:41 <trofi> > map f [a,b,c]
15:26:42 <lambdabot>   Add a type signature
15:26:45 <olsner> aconbere: you're looking for 'map'
15:26:46 <aconbere> I'm sure this exists, I'm just not sure what it would be called (or maybe there's some trickness I'm not grocking)
15:26:57 <trofi> > x
15:26:58 <lambdabot>   x
15:27:01 <trofi> :t x
15:27:02 <lambdabot> Expr
15:27:03 <vixey> aconbere, like apply (+) [1,4] ==> 5?
15:27:05 <olsner> > map f [x,y,z]
15:27:06 <lambdabot>   Add a type signature
15:27:07 <trofi> > map f [a,b,c] :: Expr
15:27:08 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[b]'
15:27:12 <trofi> > map f [a,b,c] :: [Expr]
15:27:14 <lambdabot>   [f a,f b,f c]
15:27:19 <aconbere> vixey: yes like that
15:27:29 <vixey> aconbere, I don't think that's possible in haskell
15:27:32 <olsner> oh, like *that*
15:27:44 <aconbere> olsner: yes... apply the list to the function, not the function to the list :)
15:27:53 <aconbere> you could probably foldr
15:27:57 <aconbere> since currying works
15:28:20 <olsner> if you know the length of the list and the number of arguments you can make a function f' [x,y,z] = f x y z
15:29:09 <trofi> what should it do when arg count mismatches?
15:29:28 <trofi> app f [a,b,c,x] -> f a b c : [x] ?
15:29:55 <aconbere> trofi: hmmm
15:30:08 <trofi> or f [a,b] -> f a b : ?
15:30:11 <aconbere> I would expect failure exactly like if you tried f a b c x
15:30:23 <aconbere> and expect it to curry up to the point in the list given
15:30:31 <trofi> > (+) 1 2 3 4
15:30:32 <lambdabot>       No instance for (Num (t -> t1 -> a))
15:30:33 <lambdabot>        arising from the literal `1...
15:30:33 <aconbere> so app f [a, b] => f a b
15:30:47 <vixey> aconbere, you can write apply1 :: (a -> z) -> (a) -> z, apply2 :: (a -> b -> z) -> (a,b) -> z, apply3 :: ... but you can't write _apply_
15:31:01 <the_unmaker> so is haskell a form of lisp?
15:31:08 <vixey> aconbere the type system stops you from doing that
15:31:22 <aconbere> vixey: ah yeah, I nearly forgot about the problems that types cause :P
15:31:24 <vixey> the_unmaker, no
15:31:26 * aconbere smacks head
15:31:29 <ddarius> mlesniak: It's necessary to add a Functor instance to Parse and it is also good style/necessary for other things.
15:31:34 <vixey> aconbere, on the contrary,,, this is not a problem :)
15:31:48 <olsner> aconbere: you mean, the problems that types *prevent*? :P
15:31:50 <vixey> aconbere.. remember apply1
15:31:53 <aconbere> vixey: haha, I suppose I mean, the problems that types cause for solving this problem in the way that I described it :)
15:32:01 <roconnor> the_unmaker: Haskell is more related to ML than it is to lisp.
15:32:05 <vixey> aconbere, one specialization is:   apply1 :: ([a] -> z) -> [a] -> z
15:32:16 <mlesniak> ddarius, ok thanks, hopefully the other things become more obvious later :)
15:32:19 <the_unmaker> hm
15:32:20 <vixey> aconbere, so example...
15:32:25 <vixey> @let apply1 f x = f x
15:32:26 <lambdabot>  Defined.
15:32:34 <vixey> > apply1 sum [3,5,8,4,6]
15:32:35 <lambdabot>   26
15:32:48 <the_unmaker> so like what makes haskell more fun than I dunno perl? or python?
15:33:06 <vixey> @let twoArg f [x,y] = Just (f x y) ; twoArg _ _ = None
15:33:06 <lambdabot>  <local>:4:45: Not in scope: data constructor `None'
15:33:09 <vixey> @let twoArg f [x,y] = Just (f x y) ; twoArg _ _ = Nothing
15:33:10 <lambdabot>  Defined.
15:33:15 <kynky> its more functional
15:33:17 <vixey> > apply1 (twoArg (+)) [1,4]
15:33:19 <lambdabot>   Just 5
15:33:29 <vixey> > apply1 (twoArg (+)) [1,4,5,2]
15:33:31 <lambdabot>   Nothing
15:33:36 <olsner> ... the same things that make cake more fun than death :P
15:35:55 <trofi> looks like QT's marshalling for signals/slots
15:36:04 <the_unmaker> taste sugar?
15:36:08 <the_unmaker> calories
15:36:08 <the_unmaker> ?
15:36:23 <roconnor> the_unmaker: circular data depencencies
15:37:57 <roconnor> the_unmaker: and monads!
15:38:55 <Twey> Infinite lists!
15:39:02 <yuuki> Hmm, I think that a basis is linear iff any application of combinators from the basis is well typed
15:39:35 <roconnor> the_unmaker: the ability to search a predicate over an infinite space in finite time
15:39:56 <vixey> how does that work?
15:40:12 <vixey> yuuki, what does linear mean?
15:40:15 <Twey> vixey: Not in worst-case :-P
15:40:49 <yuuki> linear means that nothing is duplicated nor destroyed.  I think Kxy -> x is non-linear because it destroys one of its terms
15:40:52 <roconnor> vixey: were you asking me?
15:40:58 <vixey> yes
15:41:04 <Twey> Oho
15:41:08 <vixey> yuuki, aha
15:41:30 <roconnor> vixey: if the search space is topologically compact and your predicate is continuous, then there is no problem.
15:41:37 <yuuki> Sxyz -> xz(yz) is also non-linear.  I'm not sure if this is the precise definition.  Another definition of linear is that no object is referenced multiple times
15:41:57 <vixey> yuuki, no connection between linear and that typing jumps out for me though
15:42:09 <vixey> roconnor, I do not know what those words mean :)
15:42:15 <polveroj> @vixey: it's "linear" as in "linear logic"
15:42:15 <lambdabot> i hate it when i get stuck with chatting with a bot!
15:42:24 <vixey> roconnor, continuous I never understand..
15:42:24 <yuuki> Well, for instance SKK and SKS have different types because in SKY, Y is destroyed
15:43:07 <roconnor> the_unmaker: http://www.reddit.com/comments/24p2c/xkcd_does_anyone_else_feel_compelled_to_solve_this/c24pc5
15:43:09 <yuuki> Similarly, the Y combinator is not well-typed because it duplicates
15:43:09 <lambdabot> Title: roconnor comments on xkcd - Does anyone else feel compelled to solve this?, http://tinyurl.com/6naqtt
15:43:48 <roconnor> vixey: http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
15:43:55 <lambdabot> Title: Mathematics and Computation Â» A Haskell monad for infinite search in finite tim ..., http://tinyurl.com/5zjtz2
15:44:39 <Giraffe> you know
15:44:42 <Giraffe> i'm not really a fan of xkcd
15:44:44 <roconnor> vixey: a continuous predicate over a compact space will only consume a finite amount of input.
15:45:23 <roconnor> vixey: so you only need to check a finite number of cases (upto the amount that the predicate consumes).
15:45:44 <vixey> oh right I see
15:47:27 <FunctorSalad_> continuous predicate?
15:47:34 <roconnor> yes
15:47:36 <FunctorSalad_> what's the codomain
15:47:42 <FunctorSalad_> {0,1}?
15:47:42 <roconnor> Bool
15:47:58 <FunctorSalad_> uhm, isn't it locally constant then ;)
15:48:08 <roconnor> yes
15:48:38 <FunctorSalad_> so you only need to search the connected components I suppose
15:48:59 <roconnor> well, the space might be totally disconnected
15:49:07 <roconnor> like the cantor example
15:49:35 <FunctorSalad_> hmm
15:51:18 <FunctorSalad_> I'm slightly confused. it is compact, yet it has uncountably many conn. components?
15:52:00 <roconnor> FunctorSalad_: it just goes to show that uncountable is a bad way of measuring big
15:52:04 <gwern> woo. that was painful. note to self: next time I order ubuntu desks, make sure they're x86_64
15:52:09 <roconnor> ... and that set theory is stupid
15:52:12 <roconnor> and evil
15:52:16 <FunctorSalad_> :)
15:52:28 <ddarius> roconnor: All we need to do is get rid of the Axiom of Infinity.
15:52:34 <vixey> nooo
15:52:44 <FunctorSalad_> noooo they be taking mah AoI
15:52:52 <gwern> roconnor: anything which is as recursive as set theory can't be all bad!
15:53:05 <gwern> ('I know there's good in him; I can feel it')
15:53:13 <lament> Evil stupid, theory is four corner category.
15:53:59 <Twey> FunctorSalad_: é’ã„?
15:54:03 <dons> ?yow
15:54:03 <lambdabot> Like I always say -- nothing can beat the BRATWURST here in DUSSELDORF!!
15:54:17 <FunctorSalad_> Twey: my font doesn't have the first char :(
15:55:07 <dons> ?users
15:55:07 <lambdabot> Maximum users seen in #haskell: 558, currently: 527 (94.4%), active: 22 (4.2%)
15:56:02 <FunctorSalad_> roconnor: my topology has become a bit rusty :( a compact space can only have finitely many connected components, right? otherwise cover the space by the connected components
15:56:29 <roconnor> the cantor space is compact.
15:56:36 <FunctorSalad_> yes
15:56:37 <roconnor> um
15:56:41 <FunctorSalad_> by tychonoff
15:56:41 <roconnor> I forget if it is connected
15:56:56 <FunctorSalad_> it isn't
15:57:03 <roconnor> ok
15:57:13 <FunctorSalad_> (the topology is the subset topology inherited from R, right?)
15:57:14 <roconnor> so doesn't it have an uncountable number of components?
15:57:30 <roconnor> FunctorSalad_: re:topology, yes
15:57:55 <dcoutts> @seen Lemmih
15:57:56 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
15:58:02 <Lemmih> dcoutts: Hi.
15:58:14 <dcoutts> Lemmih: hia, tell me more about LHC
15:58:19 <Giraffe> @seen Giraffe
15:58:20 <lambdabot> You are in #haskell. I last heard you speak just now.
15:58:23 <FunctorSalad_> roconnor: it seems that any two points must be in different components, because between any two points there's a "removed" intervall
15:58:28 <dcoutts> Lemmih: and do you mind if I fix the warnings in the LHC module in Cabal or do you want to do it?
15:58:47 <Lemmih> dcoutts: There are warnings?
15:58:54 <dcoutts> Lemmih: lots :-)
15:59:14 <dcoutts> mostly unused imports
15:59:16 <roconnor> > (otherwise cover the space by the connected components) I don't think the connected components are open, especially in the cantor case
15:59:17 <lambdabot>   <no location info>: parse error on input `,'
15:59:36 <Lemmih> dcoutts: What do you want to know about LHC?
15:59:41 <dcoutts> Lemmih: I've got a patch already to fix them, but I just want to check if that'd mess things up for you if you've got more patches coming
15:59:57 <dcoutts> Lemmih: where does it live? does it work? is it based on jhc or ghc?
15:59:59 <Lemmih> dcoutts: Push it. I've got nothing new.
16:00:04 <dcoutts> 'k
16:00:19 <yuuki> vixey, this is the logical equivalent to the idea of a linear language http://en.wikipedia.org/wiki/Linear_logic
16:00:20 <lambdabot> Title: Linear logic - Wikipedia, the free encyclopedia
16:00:34 <dcoutts> Lemmih: I noticed the LHC module imports the GHC module and re-uses code to get the list of installed modules by calling ghc-pkg.
16:01:14 <Lemmih> dcoutts: It's a fork of jhc. The source is on d.h.o and its homepage is lhc.seize.it
16:01:38 <Lemmih> dcoutts: It doesn't work very well yet but at least it works better than jhc.
16:01:42 <dcoutts> Lemmih: what are the aims, compared to jhc?
16:01:59 <dcoutts> Lemmih: great, I've not been able to get jhc to build much
16:02:09 <FunctorSalad_> roconnor: right... there only has to be *some* connected component that is clopen
16:02:17 <FunctorSalad_> roconnor: (confused that with "all")
16:02:39 <Lemmih> dcoutts: Faster and prettier code (judged by my eyes). Better support for Cabal and hackage.
16:02:47 <dcoutts> Lemmih: excellent
16:03:05 <dcoutts> Lemmih: I tried to support jhc in Cabal, but I couldn't get jhc to build cabal at all
16:05:13 <Lemmih> dcoutts: Compiling Cabal won't happen anytime soon. I recently managed to compile old-locale which was a big accomplishment (:
16:05:22 <dcoutts> :-) ok
16:05:25 <dons> dcoutts: would it be possible to write a simple parallel gzip -d using our zlib bindings?
16:05:34 <dons> or is the underlyign C lib esssentially sequential?
16:05:45 <dcoutts> dons: what does parallel gzip -d do?
16:05:55 <dons> oh, i guess we could chunk it up more. mm
16:06:05 <dons> dcoutts: it doesn't exist.
16:06:13 <Lemmih> dcoutts: It's a bit problematic that the core packages on hackage are either broken or GHC specific.
16:06:19 <dons> but i'd like to decompress things faster sometimes (and write other unix tools that are multicore friendly)
16:06:29 <BMeph> Does anyone know what Sigbjorn Finne's handle is? :)
16:06:35 <dons> BMeph: he doesn't  use irc.
16:06:42 <gwern> yeah, siggie isn't here
16:06:43 <dons> BMeph: he's usually 'sof' though
16:06:56 <Lemmih> dcoutts: Particularly, array depends on ghc and old-time is just plain broken.
16:06:57 <dcoutts> dons: zlib is essentially linear, there's a linear data dependence on the dictionary
16:07:05 <gwern> dcoutts: btw, did you ever remove me from moderation on cabal-devel ml?
16:07:11 <dons> dcoutts: so gz.tar would be ok though :)
16:07:13 <dons> just not tar.gz
16:07:19 <dcoutts> dons: yes
16:07:27 <dons> k.
16:07:31 <BMeph> dons: Ah, pity. I guess I'll just email. then.
16:07:39 <dons> BMeph: that's the best way.
16:07:44 <dons> BMeph: what's this in reference to?
16:07:49 <dons> (i work with sof)
16:07:57 <dcoutts> dons: multiple streams are fine. Similarly if you compress in chunks then you can decompress in chunks on the same boundaries. But you loose compression opportunities.
16:08:11 <dons> mm
16:08:26 <dcoutts> gwern: I added some address of yours to a white list I think
16:08:44 <dcoutts> Lemmih: how does array depend on ghc?
16:08:44 <gwern> arggh. this is such a frustrating cabal-install problem. I have containers 0.2.0.0 installed, I instaleld it several times my usual way, and yet everything I try to cabal-install seems to think they need to compile containers-0.2.0.0 first!
16:09:00 <gwern> dcoutts: oh, ok. I sent in a little tab cleaning patch earlier which is why I ask
16:09:09 <dcoutts> gwern: see the -v output, it'll say why it wants to rebuild it
16:09:19 <dcoutts> gwern: I applied it
16:09:29 <dcoutts> though I've not pushed it yet
16:09:30 <gwern> and of course containers fails unmodified because of ghc 6.10
16:09:36 <dons> mm
16:09:37 <dons> ?
16:09:52 <dons> gwern: containers should be fine. what are you doing?
16:10:09 <gwern> dons: I'm just trying to cabal-install with my usual options
16:10:11 <dons> containers not building would be a serious bug report, fwiw.
16:10:21 <dcoutts> ghc-6.10.1 comes with containers-0.2.0.0, so it has to work to some degree :-)
16:10:32 <Lemmih> dcoutts: It depends on 'syb' which depends on base-4.
16:10:32 <dons> dcoutts: any thoughts on when the hackage upgrade should happen?
16:10:36 <gwern> what might 'In order, the following would be installed:
16:10:37 <gwern> containers-0.2.0.0 (reinstall) changes: base-4.0.0.0 -> 3.0.3.0
16:10:40 <gwern> mean?
16:10:53 <dcoutts> Lemmih: ah, I already sent a patch to drop the array dep on syb iirc
16:11:09 <Lemmih> dcoutts: Ah, excellent.
16:11:10 <dcoutts> dons: when the new server is feature-complete
16:11:21 <dcoutts> dons: in particular we need clients that can build docs
16:11:31 <dons> mm
16:11:39 <dcoutts> Lemmih: speaking of which, have you pushed your code for serving docs in the new hackage-server?
16:11:50 <gwern> there's *something* odd here, since runhaskell Setup configure works just fine.
16:12:16 <dcoutts> gwern: as you know, cabal install is not doing the same thing as cabal configure
16:12:25 <gwern> I guess I'll try reinstalling cabal and cabal-install
16:12:25 <Lemmih> dcoutts: I don't think so. The user handling made me depressed so I moved on. (:
16:12:42 <gwern> dcoutts: well, that tells me that containers is correctly installed, at least
16:12:47 <dcoutts> Lemmih: do you want to send me the changes you've got so far
16:12:57 <dcoutts> Lemmih: what was wrong with the user handling? I can do that bit.
16:12:59 <Lemmih> dcoutts: Sure. Pushing now.
16:13:05 <dcoutts> Lemmih: oh, ta
16:13:33 <Lemmih> dcoutts: We use plain text passwords. It makes everything so much more difficult (and horribly unsafe).
16:13:57 <dcoutts> Lemmih: oh yes, sure. It'd be great to use something better than http basic auth, like digest.
16:14:10 <dcoutts> Lemmih: did you have any suggestions?
16:14:19 <Lemmih> dcoutts: That won't help with mirrors.
16:14:27 <dcoutts> Lemmih: why?
16:14:42 <Lemmih> dcoutts: I'd like to mirror users as well as packages.
16:15:01 <dcoutts> hmm
16:15:16 <funktio> I have a problem building 6.10 with the extra libs in Ubuntu 8.10: http://hpaste.org/12290
16:15:46 <dcoutts> Lemmih: well in principle that's possible isn't it? The mirrors would need to share the hashed passwd db
16:15:49 <Lemmih> dcoutts: I can only have a single active hackage server if we use passwords for authentication.
16:16:19 <dons> dcoutts: know what funktio's bug is?
16:16:26 <dons> missing haddock? old cabal?
16:16:49 <dcoutts> Lemmih: isn't it usual for the mirrors to be read only?
16:17:09 <dcoutts> Lemmih: or we can use happs clustering if we want tighter integration
16:17:33 <funktio> building without extra libs worked fine a while ago
16:17:49 <Lemmih> dcoutts: I'd like cheap, anonymous mirrors.
16:18:18 <dcoutts> Lemmih: they cannot be anon if they're sharing the user auth data, they'd have to be trusted wouldn't they?
16:18:39 <dcoutts> dons: can't be old haddock or cabal, that's building ghc itself which comes with both.
16:18:55 <Lemmih> dcoutts: With the current setup, yes. But not if we use public keys for authentication.
16:19:12 <dcoutts> Lemmih: you mean https ssl/tls
16:19:44 <Lemmih> dcoutts: No, users would just sign when they upload them.
16:19:52 <Lemmih> dcoutts: The original cabal-install did that.
16:19:56 <dcoutts> Lemmih: ahh, I see.
16:20:10 <Lemmih> dcoutts: Worked wonders but was a pita on Windows.
16:20:12 <dcoutts> Lemmih: though it requires everyone to have gpg and sign their packages.
16:20:16 <dcoutts> Lemmih: exactly
16:20:33 <gwern> cheap anonymous peers = p2p?
16:20:45 <gwern> dcoutts: well, people signing their packages is not at all a bad thing
16:20:52 <dcoutts> we should certainly support signed packages, but I don't think we can realistically make it compulsory
16:20:54 <Lemmih> dcoutts: Perhaps if we had some pure implementation and maintained our own keyring.
16:20:59 <dcoutts> gwern: of course
16:21:08 <dcoutts> Lemmih: maybe
16:21:12 <gwern> (but then, I say that as someone with gpg set up and all, and I know full right well that getting set up can be awfully painful)
16:21:16 <dcoutts> sounds like a lot of work though
16:21:33 <dcoutts> Lemmih: and there are some authenticated actions on hackage that are not uploading packages
16:22:14 <dcoutts> gwern: we should certainly move to a situation where many core packages are signed and checked
16:22:16 <Lemmih> dcoutts: I'm just dreaming. Hackage has certainly showed that something technically inferior is better than nothing at all.
16:22:25 <dcoutts> Lemmih: right
16:22:40 <Lemmih> (no offence to the hackage devs)
16:22:43 <dcoutts> Lemmih: I'm all for making stuff better :-)
16:23:39 <dcoutts> but as you say, having something a bit better is better than waiting for too long for something perfect
16:23:59 <dcoutts> eg Cabal has many many technical imperfections, but is still useful
16:24:25 <dcoutts> and we're slowly rewriting the internals to be less embarrassing
16:25:27 <dons> yeah, kinda useful.
16:25:47 <dons> in the useful way that actually making products in the real world to solve problems is useful.
16:26:10 <dons> Lemmih: "worse is better"
16:26:24 <dons> and anything at all is better than nothing.
16:26:26 <gwern> oh the irony - haskellers invoking worse is better
16:26:37 <dons> yup
16:26:46 <dons> we had 15 years building ivory towers
16:26:53 <dons> time to throw rocks from the top!
16:27:23 <gwern> @remember dons we had 15 years building ivory towers - time to throw rocks from the top!
16:27:24 <lambdabot> Done.
16:27:27 <dcoutts> if I'd written Cabal from scratch, I would be embarrassed
16:27:48 <dcoutts> but it does serve a need
16:27:52 <dcoutts> and is fixable
16:28:32 <dons> galois is almost entirely using cabal now, even for our biggest, oldest projects. it didn't take long to surplant make
16:28:39 <dcoutts> so yeah, I don't like invoking "worse is better" but it seems appropriate in this case, in hind sight
16:29:02 <dcoutts> it's still embarrassing though
16:29:18 <dons> not to any other community
16:29:25 <dons> we just look ridiculously well organised.
16:29:51 <dcoutts> we've got bugs in our tracer that cannot sensibly be fixed without replacing the guts of Cabal
16:29:51 <dons> i like how shapr's hat fits
16:29:59 <Lemmih> dons: I'm on an unencrypted wireless network and hackage use plain text passwords. Once a week I broadcast my password to everyone in shouting range. Hopefully things will improve. /-:
16:30:09 <dons> Lemmih: yeah, not so good
16:30:22 <dcoutts> Lemmih: how hard would it be to implement digest auth?
16:30:35 <dons> Lemmih: but just think: event that helps others contribute to haskell :)
16:30:50 <dons> dcoutts: seems trivial...
16:30:54 <dons> we do it all the time
16:30:58 <dcoutts> Lemmih: that seems like the next best thing in terms of security vs ease of implementation
16:31:07 <dcoutts> dons: http digest auth?
16:31:12 <dons> yeah
16:31:13 <Lemmih> dcoutts: I have no idea. I usually ask you about these things. (:
16:31:23 <Giraffe> think of it this way
16:31:24 <dcoutts> Lemmih: heh heh, well perhaps we can ask dons :-)
16:31:42 <dons> oh, i guess new hackage doesn't use apache?
16:31:48 <dcoutts> dons: right
16:31:52 <dons> so whatever support happs has for this stuff
16:31:58 <Giraffe> looking at the errors in the system and going "let's fix them" is FAR better than doing what happened with autotools
16:32:20 <dcoutts> dons: happs currently has only http basic, the question is how hard is it to implement digest auth for happs
16:32:24 <dons> mm
16:32:42 <Lemmih> dons: We can put HAppS behind apache if it helps.
16:32:46 <dcoutts> dons: which is really the same question as how hard is it to implement http digest auth in general, happs doesn't really come into it much.
16:33:08 <dcoutts> dons: you know of course that the current hackage, using apache, is only using basic auth
16:33:30 <Philonous> Is there a fix somewhere for array-0.1.0.0 on ghc 6.10? Or a related discussion?
16:34:02 <Lemmih> Philonous: The fix is to update the package that requires array-0.1.0.0, I think.
16:34:17 <dcoutts> Philippa: ghc-6.10 comes with array-0.2.0.0, you do not need or want array-0.1.0.0
16:34:26 <Philonous> Lemmih: I'd love to, but there is no new version of haskore
16:34:27 * SimonRC just learnt not to type /names on this channel
16:34:54 <Philonous> dcouts: Now you pinged philipp* for new good reason ;)
16:35:00 <Philonous> no*
16:35:08 <dcoutts> doh!, sorry Philippa, I keep doing that.
16:35:54 <dcoutts> Lemmih, dons: switching to digest auth will require all uploaders to re-submit their info. We do not keep plain-text passwds, only hashed and the mechanism for digest auth uses a different hash I think.
16:36:05 <Philonous> dcoutts: I sure don't care about array 0.1.0.0, but unfortunately haskore does
16:37:13 <dcoutts> Philonous: try downloading it and relaxing the deps, and see if it will build with ghc-6.10
16:37:24 <dcoutts> Philonous: it's clearly not been updated for 6.10
16:37:44 <Philonous> Right, sounds fair enough. Thanks for the hint.
16:38:12 <dcoutts> dons: I was under the impression from what you'd said that you've implemented digest auth for some application, rather than just configured apache to use it.
16:38:44 <dcoutts> dons: I guess we were talking at cross-purposes
16:38:45 <dons> dcoutts: right.
16:38:46 <dons> both.
16:38:47 <luite> is there a STT, a ST transformer?
16:38:56 <dons> dcoutts: in all sorts of scenarios
16:39:12 <dcoutts> dons: ah, so you have implemented it, and you think it's not too hard to implement in Haskell, eg so we could do it in happs
16:39:18 <dons> right.
16:39:28 <dcoutts> dons: ok, well that's good to know
16:39:35 <dons> i'll talk to glguy, he's the auth expert. shouldn't be too hard to whip something up
16:39:46 <dcoutts> Lemmih: seem like a plan?
16:39:52 <dcoutts> dons: I think that sounds great
16:39:54 <dons> if someone has a repo to point to.
16:40:01 <Lemmih> dcoutts: Sounds good.
16:40:17 <dcoutts> dons: code.h.o/hackage-server it already contains an impl of basic auth
16:40:24 <dons> ijones has been interested in this for ages.
16:40:34 <dons> so seems like something galois can contribute.
16:40:39 <dons> ok. cheers
16:40:45 <dcoutts> dons: in Distribution/Server/Auth/Basic.hs
16:40:53 <dons> ok
16:40:58 <roconnor> luite: I don't think so.  I think ST, like IO, always has to be at the bottom of a monad transformer stack
16:41:19 <roconnor> luite: but I'm not certain
16:41:36 <sclv> it does
16:41:48 <sjanssen> it seems hard to make an STT that wouldn't break referential transparency
16:42:06 <Lemmih> dcoutts: Patches pushed to hackage-server repo.
16:42:12 <dcoutts> Lemmih: great, thanks
16:42:31 <dcoutts> dons: the next thing after that for security is having hackage include a signed list of package tarball checksums. So at least you know that the package has not been modified since being uploaded. Prevents dodgy mirrors.
16:42:48 <dons> yep. i think we can help here.
16:43:04 <dcoutts> so it's not end-to-end, but it's cheap and useful
16:43:20 <dcoutts> and doesn't require windows users to have gpg to check every downloaded tarball
16:43:55 <dons> phew, 20 packages Arch-ified, only 64 to go
16:44:00 <dons> hackage is growing to fast. slow down kids!
16:44:07 <luite> roconnor: hm, I was afraid of that. is there some way to flip the order of monads in a transformer stack then?
16:44:07 <dcoutts> heh
16:44:23 <sjanssen> dcoutts: nice to see another advocate for proper encodings for IO.  Do you know if there is any progress on this?
16:44:46 <roconnor> luite: the order of monad transformers is very important
16:45:00 <dcoutts> sjanssen: Simon Marlow started working on adding encoding to Handle, using iconv on unix and something Win32 on windows.
16:45:27 <dcoutts> sjanssen: he didn't manage to finish in time before 6.10. If you're keen, it'd be a really valuable thing to pick up.
16:46:13 <dcoutts> sjanssen: there's an old thread somewhere where we basically decided what the right behaviour for the H98 text IO was
16:46:14 <explicitjelly> dons, it's nice to see that he haskell user base is steadily growing
16:46:23 <explicitjelly> this means a lot for future programming in general
16:46:44 <dcoutts> sjanssen: I can't remember if we decided to always use the locale by default, or to do something slightly more complex.
16:47:33 <dons> explicitjelly: i hope so.
16:47:39 <dcoutts> sjanssen: perhaps we can ask Simon to post a status update on it if he's not got time to finish it.
16:47:56 <dcoutts> someone else might feel motivated to do it
16:48:24 <dons> explicitjelly: i'm not even sure it is 'steadily' growing. uploads to hackage http://galois.com/~dons/images/hackage-daily-graph.png
16:48:38 <dons> something nice has happened in the last 150 days
16:48:44 <dons> since cabal 1.4 + cabal-install?
16:48:53 <dons> what happened 6 months ago?
16:49:01 <dons> chalmers hackathon?
16:49:18 <dons> even more so in the last 50 days
16:49:22 <dons> so that's the cabal 1.6 ramp up
16:49:50 * dons -> home. ciao
16:49:52 <dcoutts> perhaps that shows the importance of communicating to package authors around the time of ghc releases
16:49:57 <jfoutz> i'd like to report a bug against the GLUT library, but i'm not sure where to do that... does anybody have a link?
16:49:57 <roconnor> when was "how to write a haskell program" writen?
16:50:06 <roconnor> 150 days ago?
16:50:22 <dcoutts> jfoutz: the lib should list a maintainer email address
16:50:28 <koninkje> /sc/sc
16:50:29 <jfoutz> thanks
16:50:38 <explicitjelly> well, it's winter now. people have more programming-time.
16:53:46 <explicitjelly> I wonder why I always simply forget about list comprehensions
16:56:23 <kynky> you should add it to a comprehensive reminder list
16:57:01 <explicitjelly> or I could have one of those office assistant thingies.
16:57:13 <explicitjelly> "did you mean to write [ f x | ... ]?
16:58:11 <Twey> explicitjelly: Because map is usually more appropriate?  :-P
16:58:42 <Twey> Also more curryable.
16:59:08 <olsner> personally, I don't much care for list comprehensions
16:59:29 <Twey> They have their place
16:59:45 <Twey> They're just not as useful as one would initially think them to be
16:59:55 <Twey> There's usually a higher-order function that'll do what you want
17:01:34 <Philippa> and it's always expressible in terms of them: list comprehensions're strictly sugar
17:02:11 * Twey nods.
17:02:14 <Twey> Well, no
17:02:19 <Twey> Well, yes.
17:02:30 <Twey> But some of them are list monad operations.
17:02:31 <the_unmaker> so wow clone in haskell doen yet?
17:02:49 <Twey> Clone?  What clone?
17:04:42 <Cale> concatMap ;)
17:05:38 <Cale> > concatMap (\x -> concatMap (\y -> (x,y)) [3,4,5]) [1,2]
17:05:39 <lambdabot>   Couldn't match expected type `[b]' against inferred type `(a, a1)'
17:05:57 <Cale> > concatMap (\x -> concatMap (\y -> [(x,y)]) [3,4,5]) [1,2]
17:05:58 <lambdabot>   [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
17:06:13 <Twey> @src concatMap
17:06:13 <lambdabot> concatMap f = foldr ((++) . f) []
17:06:16 <Cale> > [(x,y) | x <- [1,2], y <- [3,4,5]]
17:06:17 <lambdabot>   [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
17:06:22 <Twey> Hmm, OK :)
17:06:31 <Cale> It's the same as >>= of course
17:06:32 * BMeph looks for the flash of light and cloud of dust...
17:06:37 <Twey> That's an instance where the comprehension looks nicer, though :-P
17:07:02 <Cale> > liftM2 (,) [1,2] [3,4,5]
17:07:03 <lambdabot>   [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
17:07:42 <pumpkin> > do x <- [1,2]; y <- [3,4,5]; return (x, y)
17:07:44 <lambdabot>   [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
17:07:50 <pumpkin> mmm
17:09:13 <Cale> > let f 0 = [[]]; f 1 = [[1]]; f n = map (1:) (f (n-1)) ++ map (2:) (f (n-2)) in map (length . f) [0..]
17:09:15 <pumpkin> how does liftAx work?
17:09:29 <lambdabot>   thread killed
17:09:36 <heatsink> @src liftAx
17:09:36 <lambdabot> Source not found. Wrong!  You cheating scum!
17:09:40 <Cale> > let f 0 = [[]]; f 1 = [[1]]; f n = map (1:) (f (n-1)) ++ map (2:) (f (n-2)) in take 10 . map (length . f) $ [0..]
17:09:42 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
17:11:12 <hackage> Uploaded to hackage: HStringTemplate 0.4.3
17:11:40 <pumpkin> @src liftA
17:11:41 <lambdabot> liftA f a = pure f <*> a
17:11:44 <pumpkin> @src liftA3
17:11:44 <lambdabot> Source not found. Maybe you made a typo?
17:11:54 <pumpkin> @src liftA2
17:11:54 <lambdabot> liftA2 f a b = f <$> a <*> b
17:15:58 <luite> I still can't figure out how to mix the runST with the MonadRandom, maybe I'm thinking in the wrong direction, this is the code I have so far: http://hpaste.org/12291  any ideas?
17:17:34 <ka> factorial (n + 1) = (n + 1) * factorial n
17:17:38 <ka> Why is it that this works?
17:18:11 <ka> for factorial 3, wouldn't you just get: '4 * factorial 3' over and over?
17:18:45 <pumpkin> huh?
17:18:51 <luite> ka: n would be 2
17:19:04 <ddarius> ka: That's equivalent to factorial n = n * factorial (n - 1)
17:19:10 <ddarius> It's "pattern matching off" a 1.
17:19:30 <heatsink> shuffle, It looks like you're trying to drop out of ST into m, then come back in to ST.  You can't do that, because in general m isn't guaranteed to run sequentially like ST requires.
17:20:13 <idnar> ka: factorial 3 is factorial (2 + 1), so you get factorial 2 in the last call, and so on
17:20:15 <pumpkin> > liftA2 (,) [1,2] [3,4,5]
17:20:16 <lambdabot>   [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
17:20:27 <pumpkin> how does liftA2 differ from liftM2?
17:20:28 <heatsink> shuffle, I would recommend writing a newtype of ST that is an instance of MonadRandom.
17:20:32 <idnar> n + k patterns are a bit silly, though, because of confusion
17:21:06 <heatsink> Oh, I'm talking to the wrong person >_<
17:21:15 <idnar> pumpkin: liftA2 works on Applicatives, liftM2 works on Monads; some monads might not have an applicative instance, even if they should, and some applicatives aren't monads, so you can't use liftM2
17:21:30 <luite> heatsink: hm, ok, if it's not possible, at least it's not me being stupid ;) (except for wanting the impossible)
17:21:39 <idnar> pumpkin: in the cases where it is possible to use either of them, any difference is most likely a bug
17:21:47 <pumpkin> ah
17:22:03 <pumpkin> is there a concise example of places in which one works but the other doesn't?
17:22:46 <BMeph> pumpkin: ZipList is an Applicative, but not a Monad.
17:26:07 <the_unmaker> can forth be as abstract as haskell?
17:26:24 <tessier> the_unmaker: Have you coded in forth?
17:26:40 <the_unmaker> slightly
17:26:44 <lament> define "can" and "abstract"
17:26:45 <tessier> forth is very stack based.
17:26:50 <the_unmaker> I didnt build many abstractions
17:26:51 <tessier> The hardware is very stack based.
17:26:53 <lament> tessier: haskell is very function based.
17:27:01 <tessier> I would say it is not very abstract at all.
17:27:08 <lament> i would say haskell is not abstract at all.
17:27:15 <the_unmaker> hm
17:27:21 <lament> (actually i wouldn't, that's nuts)
17:27:26 <heatsink> :)
17:27:30 <Twey> Heh
17:27:32 * Twey nods.
17:27:45 <lament> the_unmaker: in theory, you have more freedom in forth than you do in haskell
17:27:59 <lament> hell, in theory you can implement haskell in forth s.t. haskell source code runs as a forth program
17:28:07 <tessier> lament: And you have more freedom in assembly than you do in forth if you want to define freedom that way
17:28:10 <lament> in practice, forth is extremely low-level and not abstract at all
17:28:14 <tessier> I like freedom from bugs and manual memory management. :)
17:28:28 <lament> tessier: no, you have more freedom in forth than in assembly
17:28:41 <lament> tessier: assembly is fixed, but you can modify forth into a different language, on the fly.
17:28:47 <Twey> lament: Uhm, but you can also implement Forth in Haskell :-P
17:28:52 <tessier> lament: forth is implemented in assembly so...
17:29:01 <lament> Twey: such that forth source code runs as a haskell program? No.
17:29:18 <luite> heatsink: could you tell me what the newtype would look like?
17:29:22 <Saizan> what's the relationship betweeen forth and factor?
17:29:24 <lament> tessier: who cares what forth is implemented in?
17:29:29 * inimino declines to make obvious remark about Turing completeness
17:29:35 <the_unmaker> forth and haskell seem cool
17:29:35 <tessier> inimino: Ditto.
17:29:37 <lament> tessier: it's a programming language. It's not implemented in anything. It is specified.
17:29:41 <Twey> lament: Depends how you define 'the same program'
17:29:46 <pumpkin> is it possible to parse binary formats with parsec? is there some way to merge Data.Binary.Get and Parsec?
17:29:46 <lament> Twey: the same source code.
17:29:57 * Twey raises an eyebrow.
17:30:02 <Twey> Now admittedly I don't know Forth
17:30:09 <lament> Twey: you could modify forth to be haskell, if you really felt insane.
17:30:11 <the_unmaker> learning to program has eluded me, I starting reading the book and invariably the author starts using works he ahs not defined...
17:30:13 <Twey> But you're saying that Forth is a superset of Haskell?
17:30:19 <the_unmaker> words
17:30:19 <Twey> Ah, right
17:30:24 <the_unmaker> undefined words
17:30:24 <Twey> It's a 'programmable programming language'?
17:30:34 <lament> Twey: think Lisp but without any syntactic restrictions
17:31:10 <Twey> Ah, OK
17:31:43 <heatsink> luite, It's a state transformer that also carries along a random number generator seed.  So you could do newtype RandST s a = RandST {runRandST :: STRef s StdGen -> ST s a}
17:33:20 <Cale> > let f 0 = [[]]; f 1 = [[1]]; f n = [k : ks | k <- [1,2], ks <- f (n-k)] in take 20 $ map (length . f) [0..]
17:33:23 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
17:33:29 <luite> heatsink: ah ok, I wanted to try to prevent having to specify the generator explicitly, but that may just be impossible for this problem?
17:33:51 <Cale> > let f 0 = [[]]; f 1 = [[1]]; f n = [k : ks | k <- [1,2], ks <- f (n-k)] in take 20 $ map (map sum . f) [0..]
17:33:53 <lambdabot>   [[0],[1],[2,2],[3,3,3],[4,4,4,4,4],[5,5,5,5,5,5,5,5],[6,6,6,6,6,6,6,6,6,6,6...
17:34:03 <BMeph> lament: I prefer to think of it a Lisp without the dedication to composing a third of your program with Shift-9 and Shift-0. ;p
17:34:41 <Cale> > let f 0 = [[]]; f 1 = [[1]]; f n = [k : ks | k <- [1,2,3], ks <- f (n-k)] in take 20 $ map (length . f) [0..]
17:34:45 <lambdabot>   [1,1,* Exception: stack overflow
17:35:10 <heatsink> luite: Yeah, there's no way to call MonadRandom functions on m from within ST, so you have to extract a generator.
17:35:16 <Cale> > let f 0 = [[]]; f 1 = [[1]]; f 2 = [[1,1],[2]]; f n = [k : ks | k <- [1,2,3], ks <- f (n-k)] in take 20 $ map (length . f) [0..]
17:35:19 <lambdabot>   [1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,660...
17:35:28 <travisbrady> anyone ever bumped into this while installing ghc? http://hpaste.org/12292
17:35:35 <Cale> @oeis 1,1,2,4,7,13,24,44,81,149,274,504,927
17:35:40 <lambdabot>  Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3).
17:35:40 <lambdabot>  [0,0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,...
17:35:55 <luite> heatsink: ok, thanks :)
17:36:01 <Saizan> luite: you can use newtype RandST g s a = RandST {runRandST :: STRef s StdGen -> ST s a}
17:36:05 <Saizan> ops
17:36:06 <lament> BMeph: lisp is designed for computers (as opposed to humans) to read. Forth is not designed to read at all :)
17:36:10 <Lemmih> travisbrady: Yes, it looks like you downloaded the binaries for the wrong platform.
17:36:11 <Saizan> newtype RandST g s a = RandST {runRandST :: STRef s g -> ST s a}
17:36:32 <Saizan> what was the problem with RandT g (ST s), btw?
17:36:36 <Cale> travisbrady: yeah, I *think* it means you have the wrong version (32/64 bit)
17:36:58 <Twey> Oooh
17:37:01 <Cale> But I'm not sure.
17:37:03 <Twey> Tribonacci?  Niiice
17:37:03 <mapreduce> Can you provide an instance declaration for a type defined in a separate file?
17:37:07 <heatsink> travisbrady, Yeah, I've had that problem installing 32bit on 64bit also.
17:37:17 <Twey> Never heard that one before.
17:37:22 <BMeph> lament: Forth is a lot easier to read than assembler (well, IMHO it is, YMMV).
17:37:30 <Lemmih> mapreduce: Yes.
17:37:31 <heatsink> mapreduce, yes, you need to turn on an extension for that.
17:37:55 <travisbrady> Lemmih, Cale, heatsink: thanks, kind of a cryptic error message
17:38:13 <mapreduce> Thanks.
17:38:30 <BMeph> mapreduce: You'd have to do that for a new type, wouldn't you? :)
17:38:41 <heatsink> But I'd like to know why the platform problem happens.  I can run some 32-bit x86 programs with a 64-bit x86 os, so what's different about ghc?
17:38:49 <pumpkin> ooh it looks like parsec + data.binary is a normal combination?
17:38:53 <mapreduce> BMeph: Yes, but you could do it then in the same file.
17:38:55 <pumpkin> http://hackage.haskell.org/packages/archive/HCodecs/0.0.3/doc/html/src/Codec-Midi.html#parseMidi
17:38:57 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5en773
17:39:03 <Twey> > let tribs = 0 : 1 : 1 : zipWith ((+) . (+)) tribs (tail tribs) (tail $ tail tribs) in tribs
17:39:04 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
17:39:04 <lambdabot>        Exp...
17:39:10 <Twey> Boo :(
17:39:40 <Twey> @pl \x y z -> x + y + z
17:39:41 <lambdabot> ((+) .) . (+)
17:39:54 <Twey> > let tribs = 0 : 1 : 1 : zipWith (((+) .) . (+)) tribs (tail tribs) (tail $ tail tribs) in tribs
17:39:55 <heatsink> > let tribs = 0 : 1 : 1 : zipWith3 (((+) .) . (+)) tribs (tail tribs) (tail $ tail tribs) in tribs
17:39:56 <lambdabot>   Couldn't match expected type `[a] -> [t]'
17:39:57 <lambdabot>   [0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,6...
17:40:07 <travisbrady> anybody have any thoughts on using haskell for webapps?  i'm thinking of trying something simple and using fastcgi, Happs looking difficult and heavy to me
17:40:10 <Twey> Oops!
17:40:12 <Twey> Crud.  Haha
17:40:38 * papermachine finally updates to 6.10.1!
17:40:47 <papermachine> That was disgustingly painless
17:41:05 <luite> Saizan: hm, is that possible with ST?
17:43:14 <heatsink> luite, You can do that, but you still have to extract a generator from the other monad and then use it to run the RandT g (ST s) monad.
17:43:30 <BMeph> mapreduce: Ah - not type class, but type. Interesting...but still yes. :)
17:43:48 <heatsink> Saizan, I didn't know RandT existed.
17:43:51 <Saizan> well yeah, you need to generate your generator somewhere
17:44:10 <mapreduce> BMeph: Did I mix up type and type class?
17:44:12 * Saizan jumped in the middle of the conversation
17:44:32 <heatsink> Is MonadRandom in GHC's standard libs?
17:44:40 <luite> heatsink: it's on hackage
17:44:46 <heatsink> ok
17:44:47 <Saizan> ?hackage MonadRandom
17:44:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom
17:44:55 <the_unmaker> travisbrady: hey I want to know about haskell for webapps too
17:45:03 <the_unmaker> happs and hws are 2
17:45:29 <travisbrady> the_unmaker: this looks ok http://mult.ifario.us/p/wiring-haskell-into-a-fastcgi-web-server
17:45:39 <lambdabot> Title: wiring-haskell-into-a-fastcgi-web-server
17:46:03 <luite> I guess I can get a new generator by using getSplit
17:46:23 <luite> but somehow, I'd hoped to be able to use the original generator, without splitting
17:54:15 <gwern> http://hpaste.org/12293#a2 <-- what the heck cabal-install. what the heck
17:54:51 <gwern> @seen dcoutts
17:54:51 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 46m 35s ago.
17:57:51 <the_unmaker> I wish there was a way to program say 12 computers so they could serve web fast without relational database
17:57:58 <the_unmaker> and if I needed more power I add 13th box
17:58:00 <the_unmaker> etc
17:58:29 <the_unmaker> i have sneaking suspicion LAMP can eb improved
17:58:32 <the_unmaker> upon
17:59:14 <Lemmih> the_unmaker: HAppS can almost do that.
17:59:43 <the_unmaker> is happs runing for anyone?
17:59:48 <the_unmaker> I couldnt get the bugger installed
18:00:06 <Lemmih> the_unmaker: lhc.seize.it is running HAppS+gitit.
18:00:10 <the_unmaker> I was liek holy crap cool software noooo its not doc or installable!! aaggaagag
18:00:32 <Lemmih> the_unmaker: cabal install gitit -- This should work.
18:01:07 <the_unmaker> lhc?
18:01:07 <gwern> I can't figure this out. it configures and builds and hinstalls fine, but cabal install infallibly fails to configure it, and worse, refuses to accept its existence!
18:01:12 <the_unmaker> is that new haskell compiler?
18:01:19 <gwern> new fork of an old one
18:01:32 <the_unmaker> gitit will grab happs as a dependency?
18:01:49 <gwern> think so
18:01:59 <travisbrady> i can't make sense of this error when using cabal install: http://hpaste.org/12294
18:02:30 <Lemmih> gwern: Doesn't containers list base as a dependency?
18:02:31 <gwern> travisbrady: you don't have fcgi installed
18:02:33 <the_unmaker> Lemmih: will cabal install gitit   install happs as well?
18:02:36 <gwern> Lemmih: it does!
18:02:38 <Lemmih> the_unmaker: Yes.
18:03:01 <gwern> travisbrady: the key line is the one which says it can't find  fcgi.h
18:03:23 <gwern> travisbrady: this means it is trying to bind to a non-haskell library, but you don't have it findable-by-cabal, which usually means you don't have it at all
18:03:33 <travisbrady> gwern: ahh
18:03:37 <Lemmih> gwern: Care to paste 'cabal install -v'?
18:03:39 <travisbrady> gwern: thank you
18:03:47 <gwern> you'd see a similiar error if you tried to cmopile zlib without zelib-dev instaleld say
18:04:06 <gwern> Lemmih: sure
18:04:08 <Saizan> gwern: put base >= 4
18:04:20 <Lemmih> gwern: Impressive number of typos (:
18:04:29 <gwern> is in a hurry
18:04:55 <gwern> Lemmih: http://hpaste.org/12293#a3
18:05:30 <gwern> Saizan: ok, that works. but why does 'runhaskell Setup configure' work fine without a >= 4?
18:05:51 <Saizan> gwern: because Setup prefers the latest version available
18:06:02 <Saizan> gwern: while cabal-install prefers base-3 over base-4
18:06:36 <gwern> wait, further weirndess - I cabal install containers, and then I go to cabal-install's darcs directory and run 'cabal install' - and it tries to install containers again (but since it's using an unmoidifed containers tarball it fails again)
18:06:48 <Saizan> this is a bug in containers' .cabal, i think, anyhow
18:07:43 <Lemmih> gwern: Perhaps cabal-install wants base-3.
18:08:00 <gwern> http://hpaste.org/12293#a4
18:08:03 <Saizan> gwern: try installing the modified containters as 2.0.0.1
18:08:50 <gwern> Saizan: you mean 0.2.0.1?
18:08:58 <Saizan> ah, yeah
18:09:08 <Saizan> in short, bump the micro version
18:09:23 <gwern> is there any danger of conflicts by bumping the last?
18:09:45 <Saizan> which kind of conflicts?
18:10:09 <gwern> well is there any change ghc hq will release an actual 0.2.0.1?
18:10:10 <Saizan> i guess you'd get troubles if a 0.2.0.1 is uploaded to hackage
18:10:12 <gwern> *chance
18:10:25 <the_unmaker> web server built from lindaspace be awesome done in haskell i think
18:10:51 <gwern> (hm. now cabal install in cabal-install dir leads to latest hackage cabal being downloaded and instaleld - even though I've got darcs cabal installed)
18:11:00 <gwern> ^ this is getting a little confusing to write :)
18:14:12 <Saizan> running "cabal install" from HEAD cabal-install repo is working fine for me, but i'm on 6.10.1
18:14:29 <mikv> Hi!
18:15:20 <gwern> I too am now on 6.10.1 but my installation is potentially weird
18:15:38 <gwern> as I installed a i386 ghc on top of a x86_64 snapshot
18:16:41 <mikv> http://hpaste.org/12295
18:17:12 <mikv> I want to have different results when b parameter is an Const and Var
18:17:23 <mikv> What is the best way to make such function?
18:17:29 <mikv> I mean Haskell way :-)
18:18:03 <gwern> myFunct (Mult a b) = Const (a*b), presumably?
18:18:35 <roconnor> myFunct (Mult a (Const b)) = ...
18:18:39 <Raevel> i'm guessing he  means myFunct (Mult a (Var x)) = ...
18:18:45 <roconnor> myFunct (Mult a (Var b)) = ...
18:18:50 <gwern> hm. how can 'b' be both a Const and a Var?
18:18:56 <BMeph> mikv: One way that comes to mind is by using a case statement on b. :)
18:19:12 <roconnor> mikv: use nested patterns
18:19:18 <Cale> *case-expression
18:19:30 <BMeph> mikv: Nested patterns will work, as well. :)
18:19:31 <Raevel> gwern: theyre both exprs, Var and Const are just the constructors
18:19:32 <roconnor> nested patterns
18:19:40 <mikv> Hm.. How can i find out which constructor was used for second paramter?
18:19:56 <mikv> I know how to it only with pattern matching :-(
18:19:57 <BMeph> Cale: I think you called it. :)
18:19:58 <Cale> mikv: Like roconnor just showed
18:20:12 <Cale> mikv: Or using case
18:20:22 <mikv> Cale, i've asked about case
18:20:30 <Cale> case b of
18:20:37 <Cale>   Const x -> ...
18:20:44 <Cale>   Var x -> ...
18:20:49 <Cale>   ...
18:20:51 <mikv> Cale, ok.. thanks.
18:20:55 <mikv> Cale, i will try
18:20:57 <roconnor> nooooo
18:20:59 <roconnor> :)
18:21:00 <Cale> mikv: But nested patterns are nicer
18:21:10 <mikv> What is nested patterns?
18:21:12 <Cale> mikv: look at roconnor's code
18:21:21 <roconnor> http://hpaste.org/12295#a1
18:21:23 <Cale> (rather than ignoring him ;)
18:21:33 <mikv> Oh. I see
18:21:38 <mikv> I already have another function
18:21:45 <mikv> which was defined in that way
18:21:57 <mikv> and my teacher told me that it was bad style
18:22:05 <roconnor> intresting
18:22:12 * roconnor thinks case is bad style
18:22:22 <roconnor> or at least less good style
18:22:22 <Cale> How is it bad style?
18:22:33 <Cale> (I mean, nested patterns.)
18:22:50 <Cale> In fact, I don't think anything here can be considered bad style. Bad style would be using ==
18:23:06 <Cale> (or trying to)
18:23:07 <mikv> http://hpaste.org/12295#a2
18:23:16 <mikv> this code was considered bad
18:24:32 <Cale> Probably not because of the nested patterns so much...
18:24:33 <roconnor> looks more or less fine to me
18:25:03 <jamie> is there a function for set complement in Haskell?
18:25:05 <chessguy> it's a little inconsistent and redundant
18:25:40 <ziman> jamie, there's set difference.
18:25:44 <Cale> :t Data.Set.difference
18:25:45 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
18:25:48 <roconnor> chessguy: in what way?
18:26:00 <jamie> cool, thanks
18:26:12 <chessguy> inconsistent in that he uses _ in some places, and bound names that don't get used in others
18:26:21 <luite> hm, I wonder why my code fails to compile when I add the type signature that I got from :t
18:26:41 <roconnor> chessguy: I don't see any unused bound names
18:27:01 <chessguy> err
18:27:10 <chessguy> huh. i swear thy were there a second ago
18:27:25 <chessguy> i must be more tired than i thought. i think i'll just shut up now
18:27:37 <roconnor> There is the problem that (Plus a (Minus 0 0)) isn't simplified to a.
18:28:00 <roconnor> so the functionality might be broken.
18:28:05 <roconnor> I don't know what the spec is.
18:28:20 <mikv> roconnor, hm... give me few seconds..
18:28:31 <gwern> @quote week
18:28:31 <lambdabot> JonathanShapiro says: The ML module system is fully understood only by David MacQueen, and only on alternating weeks.
18:28:46 <FunctorSalad_> roconnor: jumping in without context, but sometimes I like "case". like, if your intuition about the functionality of the code is "case distinction"
18:29:18 <roconnor> ya, I was a bit hard on case.  It isn't really bad per se.
18:29:28 <roconnor> But I almost never use it
18:29:47 <roconnor> Maybe if I want to avoid using pattern guards for some reason, I might maybe use it.
18:30:05 <roconnor> even then, I'd rather use an auxilary function in a where clause
18:30:18 <mikv> roconnor, probably i din't understood you
18:30:36 <mikv> roconnor, but let probl = (Plus (Var "a") (Minus (Const 0) (Const 0)))
18:30:50 <heatsink> luite, If it's not on a top-level function you probably need -XScopedTypeVariables
18:30:58 <heatsink> luite, and forall.
18:30:59 <mikv> roconnor, simplify probl call gives me Var "a" result
18:31:16 <roconnor> mikv: ah right.
18:31:31 <roconnor> sorry, I misread your code
18:31:59 <roconnor> mikv: in that case it is prehaps less efficent than it could be.
18:32:26 <mikv> roconnor, which way?
18:32:41 <roconnor> simplify (Plus a b)  = simplify (Plus (simplify a) (simplify b))
18:33:07 <roconnor> having both inner and outer calls makes me fear being exponention
18:33:18 <jml> I'm trying to figure out how to do random number generation in Haskell. Following the doc links led me to http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98/Random.html but it looks blank
18:33:19 <roconnor> exponential
18:33:19 <lambdabot> Title: Random, http://tinyurl.com/5j4k29
18:33:29 <luite> heatsink: this is the new code:  http://hpaste.org/12291#a1
18:33:30 <heatsink> jml: System.Random
18:34:10 <jml> heatsink: thanks.
18:34:11 <roconnor> mikv: but whatever.  being right is more important than being fast.
18:34:34 <jml> for future reference, what does a blank page in the GHC library docs normally imply?
18:34:44 <jml> "don't use this" or "we haven't got around to documenting this yet"?
18:35:01 <heatsink> It's usually a module that only exports functions defined in other modules.
18:35:38 <mikv> roconnor, can you give another way to simplify? because i added this call for such cases like (Plus (Plus (Var "x") (Const "0")) (Mult (Const "0") (Var "y")))
18:35:54 <heatsink> Haddock doesn't search other modules for documentation, or something like that.
18:36:52 <roconnor> mikv: I suspect that when you simplify (Plus a b), you should simplify a and b first, before checking to see if they are (Const 0) or not.
18:36:53 <mikv> roconnor, left part is reduced to Var "x" and right part is reduced to Const "0". Without that outer call simplify will return (Plus (Var "x") (Const 0))
18:36:54 <jml> heatsink: ok.
18:37:23 <jml> heatsink: is there any significance in whether I import Random or System.Random?
18:37:26 <luite> are there some things that :t 'forgets', so that adding a type annotation with exactly the inferred type makes it fail te compile?
18:37:34 <heatsink> jml: I don't think so
18:37:50 <heatsink> luite, Not for toplevel functions.
18:38:17 <mikv> roconnor, i tried to make some checks, but concluded that outer call will be more readable
18:38:19 <luite> heatsink: hm, strange, I copy/pasted exactly the :t contents to the annotation
18:38:29 <Twey> Not for any functions
18:38:31 <heatsink> luite, what error do you get?
18:38:35 <mikv> roconnor, probably i am wrong, because i am not exprienced with Haskell yet
18:38:41 <Twey> luite: Did you perhaps forget to import a module with the type?
18:38:48 <roconnor> mikv: yes, it probably more readable.
18:39:21 <roconnor> mikv: arguably you shouldn't make the efficency change until your profiling identifies it as a problem.
18:39:53 <jml> heatsink: thanks.
18:39:56 <FunctorSalad_> 'Random' is from before the dotted names got introduced, I guess
18:40:17 <luite> heatsink: one moment, I restarted ghci and now a bit more seems wrong
18:41:23 <jml> FunctorSalad_: oh, that's interesting.
18:42:07 <gwern> jml: yes, if you import modules like 'Random' or 'List' instead of system.random or data.list, you've added a dep to your project
18:42:14 <gwern> build-depends: haskell98 now
18:42:49 <gwern> generally, I update such imports as they're relatively unusual and unfamilair to haskellers
18:42:58 <ka> What is the difference between:   functionA . functionB   and functionA(functionB()) ?
18:43:03 <jml> gwern: so System.Random is the preferred form?
18:43:22 <gwern> I'd say so, although it's certainl not major
18:43:28 * jml nods
18:43:42 <luite> heatsink / Twey : this error: http://hpaste.org/12291#a2
18:44:20 <Cale> ka: (f . g) x = f (g x)
18:44:28 <FunctorSalad_> ka: in the second case, you pass () as an argument to functionB
18:44:36 <Cale> ka: That is, f . g is the function which when applied to x, gives f (g x)
18:44:48 <gwern> luite: add the context to the type sig?
18:44:51 <jml> do modules need to be Capitalized?
18:44:56 <Cale> jml: yep
18:45:07 <FunctorSalad_> (haskell doesn't have function call brackets like C-like languages)
18:45:12 <jml> am I allowed to mildly resent this? :P
18:45:23 <Cale> jml: No. CamelCase is the one true way.
18:45:28 <FunctorSalad_> :)
18:45:35 <ka> FunctorSalad_: ah, I see - with the () parameter that is effectively an empty tuple, is it not?
18:45:35 <luite> gwern: what do I need to add? you can see the type sig in the post above the error, it fails to compile when I add the sig
18:45:43 <Cale> ka: yes
18:45:58 <Cale> ka: You're passing an empty tuple to functionB there.
18:46:04 <FunctorSalad_> ka: yes, () is the only value of the type that's also called ()
18:46:13 <FunctorSalad_> (the only value except for undefined)
18:46:38 <heatsink> luite, try adding a type signature for getSplit
18:46:41 <jml> also, do people tend to use Makefiles for ghc projects, or is there some other more haskell-y solution?
18:47:04 <Cale> jml: Cabal.
18:47:06 <gwern> jml: what is a ghc project?
18:47:16 <FunctorSalad_> you can put "ghc --make -main-is MyModule MyModlue" into the Makefile ;)
18:47:27 <jml> gwern: well, I meant a haskell project that's being built with ghc
18:47:28 <Cale> jml: You write a .cabal file, and use cabal install to build the project.
18:47:56 <gwern> jml: then in that case, what Cale said. cabal is the standard
18:47:58 <Cale> (If it's something of a significant size -- otherwise  ghc --make  does well.)
18:48:06 <jml> thanks
18:48:34 <Cale> Writing a .cabal file also gives you a way to create a standard distribution tarball to upload to hackage.
18:48:46 <Cale> cabal sdist, iirc.
18:49:03 <FunctorSalad_> is that easy to learn? /me hasn't tried yet
18:49:15 <luite> heatsink: doesn't seem to help, I changed the line to:   gen <- getSplit::(MonadSplit s m) => m s
18:49:16 <jml> I presume it also gives a fairly sane debian packaging path.
18:49:16 <Cale> It's not too hard :)
18:49:44 <Cale> I haven't ever tried making a debian package, so I don't know.
18:50:11 <gwern> did we ever get a cabal->deb generator?
18:50:11 <FunctorSalad_> it sure looks scary, with all these helper programs I stumble over while browsing aptitude ;)
18:50:28 <FunctorSalad_> (re .deb)
18:50:49 <heatsink> luite, try http://hpaste.org/12291#a3
18:50:52 <pumpkin> hmm, it looks like they rewrote Data.Binary as a set of Parsec parsers: http://hackage.haskell.org/packages/archive/HCodecs/0.0.3/doc/html/src/Data-ByteString-Parser.html#getInt16be
18:50:54 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/65pfx8
18:51:09 <mikv> How can i check that some parameter was constructed with certain data constructor?
18:51:29 <Cale> mikv: Pattern matching.
18:51:33 <mikv> I mean without pattern matching on the left side of function definition
18:51:39 <Cale> case
18:51:40 <FunctorSalad_> 'case', then
18:52:10 <FunctorSalad_> case x of (Just y) -> ... ; Nothing -> ....
18:52:32 <luite> heatsink: thanks, that did the trick :)
18:52:34 <mikv> hm.. i guess i need to make own predicate function
18:52:46 <mikv> then i will be able to use it in guards
18:53:20 <luite> at last, a working (but impure) array shuffle :)
18:53:31 <luite> I mean list
18:53:52 <luite> only took me a day
18:54:09 <Saizan> anyone got morrow to build?
18:54:28 <roconnor> mikv: what is simplify (Plus (Var "a") (Const (1))) ?
18:54:55 <mikv> roconnor, it should return the same Expr
18:55:02 <roconnor> what do you get?
18:55:22 <mikv> infinite recursion?
18:55:26 <roconnor> :)
18:55:48 <roconnor> maybe that was the problem with the code :)
18:55:48 <mikv> roconnor, how can i avoid it?
18:56:32 <roconnor> do it the way i suggested,  simplify a and b and then check if they are (const 0) etc.
18:56:52 <pumpkin> I can see how simplify could be one huge pattern match
18:56:59 <pumpkin> (or so it seems)
18:57:01 <roconnor> then you don't need the extra (broken) call to simpify in simplify (Plus a b)  = simplify (Plus (simplify a) (simplify b))
18:58:13 * jml hugs emacs
18:58:32 <pumpkin> oh decisions decisions
18:58:34 <mikv> roconnor, thanks
18:58:54 <pumpkin> I want to use Parsec but I want to use Data.Binary.Get
19:02:53 <Cale> pumpkin: Use Data.Binary.Get to get a stream of tokens to be parsed using Parsec?
19:03:07 <pumpkin> you mean in two separate passes?
19:03:14 <Cale> yeah
19:03:17 <pumpkin> hmm :/
19:24:46 <jml> Cale: Data.Binary? I don't see that in http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
19:24:47 <lambdabot> Title: Haskell Hierarchical Libraries
19:26:13 <Lemmih> jml: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
19:26:14 <lambdabot> Title: HackageDB: binary-0.4.4
19:27:08 <ka> rev2 :: [Int] -> [Int]                  rev2 xs = (last xs):(rev2 init xs)
19:27:12 <ka> Why does this give me a typing error?
19:27:37 <Lemmih> ka: rev2 (init xs)
19:27:54 <jml> Lemmih: exactly what I was looking for. thanks.
19:28:30 <pumpkin> which is the preferred style? rev2 $ init xs or (init xs)?
19:28:32 <jml> I guess I need to learn how to install stuff with Hackage now.
19:28:43 <ka> Lemmih: why does that fix it? (And thanks!)
19:28:47 <jml> or whatever the right preposition is
19:29:15 <Lemmih> ka: You were giving 'rev2' two arguments.
19:29:26 <ka> Oh, of course!  Thank you.
19:30:15 <pumpkin> why doesn't HashTable need an Eq on the key?
19:31:28 <Lemmih> pumpkin: Because 'new' takes a function that tests for equality.
19:35:34 <thoughtpolice> Lemmih: yay! lhc-base installing on my mbp :]
19:35:49 <thoughtpolice> Lemmih: was having problems earlier, got latest cabal/cabal-install
19:36:57 <Saizan> jml: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
19:36:59 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/39kra4
19:37:11 <jml> Saizan: thanks, I'd found that.
19:40:59 <thoughtpolice> Lemmih: hm, cabal install does not seem to register the base package with lhc :[
19:41:38 <Lemmih> thoughtpolice: Hold on. I have a patch for that.
19:41:57 <Lemmih> thoughtpolice: Pull and rebuild lhc.
19:42:01 <thoughtpolice> Lemmih: yay :] i would like to contribute to lhc so i'm trying to get it to at least compile programs reliably
19:44:43 <adu> I have that problem too
19:45:00 <Lemmih> thoughtpolice: Being reliable is a far future goal (:
19:45:12 <adu> like the idea of a project, then when I try and contribute, I find out that I can't even compile it...
19:46:07 <thoughtpolice> Lemmih: :] i would like to at least help clean up some stuff and make it more usable in general
19:46:27 <Lemmih> thoughtpolice: That would be greatly appreciated.
19:47:14 <thoughtpolice> Lemmih: some stuff might be replaceable with e.g. packages from hackage
19:47:43 <Lemmih> thoughtpolice: Don't hesitate to poke me if you have any questions/suggestions.
19:48:00 <Lemmih> thoughtpolice: That's a near future goal.
19:48:20 <thoughtpolice> Lemmih: k. (to tell you the truth I was thinking of writing my own compiler with many jhc-like qualities, but if lhc can at least have somewhat-active work, then I'll work on it instead)
19:48:42 <thoughtpolice> Lemmih: the Doc stuff might be replaceable with this -- http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ansi-wl-pprint
19:48:44 <lambdabot> Title: HackageDB: ansi-wl-pprint-0.4.0, http://tinyurl.com/5a6x8u
19:49:35 <Lemmih> thoughtpolice: Relacing Doc would be great.
19:51:29 <thoughtpolice> Lemmih: cool, then I might send you some patches - darcs send lemmih@gmail.com ?
19:52:53 <Lemmih> thoughtpolice: Yeps.
19:53:06 <Lemmih> I should probably start a mailing list.
19:53:24 <thoughtpolice> Lemmih: if it's on code.haskell.org, start a mailing list and put up a trac instance
19:58:01 <erikc> hrm, does anyone know why if i do getLine on windows, i cant ctrl-c out? similarly, ctrl-d doesnt work as EOF?
19:58:39 <Twey> Because that's not what they are on Windows
19:58:47 <Twey> EOF is... ctrl-Z, I think
19:58:55 <Twey> Kill is ctrl-break
19:59:23 <lispy> Twey: ah! that explains a lot
20:00:02 <Twey> Actually I think ctrl-C used to work for kill as well, hm
20:00:36 <lispy> I find that ubuntu live CDs help a lot ;)
20:01:54 <erikc> ah k, ctrl-z works as EOF, ctrl-break has the same behavior as ctrl-c for me
20:02:11 <erikc> if the progarm is sitting in getLine and i ctrl-c, the process hangs and i gotta kill it in task manager
20:02:22 <Twey> Odd
20:02:30 <lispy> erikc: what version of ghc?
20:02:35 <erikc> 6.10
20:03:17 <lispy> hmm
20:03:18 <erikc> main = getLine
20:03:21 <erikc> is sufficient
20:03:43 <lispy> So getLine has some bug with reading until EOF?
20:04:26 <lispy> on osx, ghc-6.10.1 -e 'getLine' does wht I would expect when I hit ^C
20:04:27 <erikc> twey was right, ctrl-z works fine as EOF, EOF is fine
20:04:43 <erikc> but ctrl-c will hang the process instead of killing it
20:04:56 <Twey> It does sound like a bug.
20:05:05 <Twey> File a report?
20:05:10 <erikc> k
20:05:10 <lispy> Sorry, so what does ^C send on iwndows?
20:05:39 <erikc> ctrl-c works fine under msys in windows, just not command prompt
20:06:03 <lispy> Well, msys tries to emulate posix
20:06:11 <lispy> so C-c would be send sigINt
20:07:53 <pumpkin> hrm
20:08:02 <Twey> lispy: Windows doesn't really have signals.
20:08:18 <Twey> It just sends a special character sequence, I think
20:08:41 <Twey> Which is interpreted by the console IO libraries (wild guess)
20:08:47 <lispy> Twey: I'm pretty sure cygwin and msys do have signals though
20:09:22 <Twey> They do, aye
20:09:51 <lispy> But, then I guess I don't understand how you can run something under either cmd.exe or msys and have it work...hrm.
20:09:59 <lispy> Something under the hood there that Idon't know anything about :)
20:10:15 <Twey> Sounds like different versions?
20:11:06 <idnar> you execute any process from either cmd.exe or msys, but if it's a console app, it'll probably only behave correctly in one of them
20:11:12 <hackage> Uploaded to hackage: gitit 0.3
20:11:15 <idnar> which is exactly what seems to be happening here
20:11:29 <idnar> *you can
20:12:25 <thoughtpolice> Lemmih: hm, I think I can replace Support.MD5 with PureMD5, also the UTF8 stuff is perhaps replaceable by utf8-string?
20:12:59 <lispy> UTF8?  that sounds like a crufty module that darcs would use
20:13:11 <lispy> thoughtpolice: is this jhc?
20:13:21 <thoughtpolice> lispy: Lemmih's fork
20:13:25 <gwern> darcs has UTF8.lhs specifically, iirc
20:14:53 <lispy> Lemmih: oh, you ended up forking?
20:14:55 <Lemmih> thoughtpolice: Excellent.
20:15:23 <gwern> lispy: yup
20:16:17 <olsner> is that 'lhc'?
20:16:26 <gwern> I know there must be some humor to be derived from the unimaginative names for haskell compilers/interpreters, but I can't think what
20:16:48 <gwern> so we have: ehc, ghc, jhc, lhc, nhc, yhc, and... who else...
20:16:54 <blackdog> hm. no hc?
20:17:01 <olsner> ... and hugs :)
20:17:13 <Lemmih> lispy: Yeah, unfortunately. It's quite a shame. John is probably the only one who understands the code in its entirety.
20:17:22 <gwern> and gofer, but they don't match the ?hc pattern
20:17:53 <gwern> and there's some incredibly ancient odd compiler which some ancient haskeller releases every couple years which I can't remember
20:18:06 <Lemmih> thoughtpolice: Do you have an account on code.haskell.org?
20:18:14 <lispy> Lemmih: Wow.  It sounds like darcs/droundy and jhc/John have a lot in common in terms of personality, project management style, anti-cabal sentiment and etc.  Kinda scary.
20:18:29 <lispy> gwern: hugs?
20:18:32 <gwern> lispy: well, except darcs is still alive, I'd say
20:18:52 <gwern> lispy: no, the ancient one isn't hugs. iirc, it doesn't accept haskell, technically
20:18:52 <lispy> gwern: thanks to Eric's defibulation yes
20:19:05 <Saizan> gwern: hbc
20:19:12 <gwern> Saizan: ah, that was it, yes
20:19:20 <blackdog> lispy: ... he took its leg?
20:19:41 * gwern adds that to the list, close enough: ehc, ghc, hbc, jhc, lhc, nhc, and yhc.
20:20:06 <lispy> blackdog: perhaps I used the wrong word.  I meant to make it sound like Eric was the shock to get the heartbeat going again
20:20:24 <gwern> I was really surprised when I found out whoever was still maintaining hbc - usually haskell software from the early '90s is deader than a doornail :)
20:20:25 <olsner> HBC's home page says "Status (August 1996):" :)
20:20:36 <Saizan> also, the only haskell haskell interpreter, hhi
20:20:40 <gwern> olsner: there was a release 3 years ago, iirc
20:20:53 <gwern> Saizan: the what? hhi is a new one on me
20:20:58 <Lemmih> gwern: Seven down, nineteen to go. (:
20:21:15 <lispy> Lemmih: Will lhc be collaborating with jhc?
20:21:38 <gwern> lispy: jhc;s development since april has been 0; there's not exactly anything to collaborate *on*
20:21:50 <lispy> Lemmih: is this intended as a permanent fork, is what I'm after.  or do you plan to fix what's wrong with jhc and then merge back in ala gcc/egcs?
20:22:06 <Saizan> gwern: mostly an experiment, it was on a recent issue of The Monad.Reader
20:22:19 <gwern> Lemmih: myself, I want to see an 'ihc', a 'khc', and a 'mhc' so we could have an entire section of the alphabet staked out :)
20:22:25 <Lemmih> lispy: John haven't worked on jhc since April. I'm not sure when he'll pick it up again.
20:22:34 <gwern> Saizan: ok, so not a real project then
20:22:41 <thoughtpolice> Lemmih: ok I think I've got it replaced.. trying to build
20:23:07 <lispy> Lemmih: I wish you the best of luck, but at the same time, I'm sad it had to be forked.  Viva la lhc!
20:23:09 <thoughtpolice> Lemmih: after that I might tackle the UTF8 and Doc stuff, and that should help a bunch alone by removing some cruft (if we move to pureMD5 we can also remove part of the ugly cbits and whatnot)
20:23:27 <thoughtpolice> Lemmih: yes I do
20:23:34 <thoughtpolice> Lemmih: the account is 'thoughtpolice'
20:23:55 <Lemmih> lispy: Hopefully he'll change his mind once lhc improves.
20:23:59 * Saizan realizes he needs a newer pc to compile lhc
20:24:01 <lispy> thoughtpolice: why does a compiler need an md5 implementation?
20:24:15 <Lemmih> lispy: Recomplication checking.
20:24:29 <lispy> Lemmih: yes, I was going to do this same thing with darcs, but Eric removed the need by becoming the maintainer
20:25:29 <gio123> how "hat folgeten pracktiken durchgenommen" could be in englisj
20:26:00 <lispy> what language is that, swedish?
20:26:08 <gio123> deutsch
20:26:16 <gio123> german
20:26:34 <lispy> http://translate.google.com/translate_t#de|en|hat%20folgeten%20pracktiken%20durchgenommen
20:26:35 <lambdabot> Title: Google Translate, http://translate.google.com/translate_t#de|en|hat%20folgeten%20pracktiken%20durchgenommen
20:26:37 <lispy> google doesn't know
20:26:39 <olsner> dutch more likely
20:26:42 <lispy> so I'm stumped :)
20:26:44 <Lemmih> @babel de en hat folgeten pracktiken durchgenommen"
20:26:45 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
20:27:21 <lispy> gio123: maybe, practice makes perfect?
20:28:16 <gio123> lispy: I had teaching practice while I was studing at uni
20:28:22 <gio123> iy was graded as well
20:28:33 <gio123> and I dont know how to write in english
20:29:04 <reillyeon> Are there any libraries out there which help with memoization?
20:29:34 <lispy> gio123: I wish I knew german.  I'm just guessing at the meaning based off of google translate and breaking up some of the words to see if I can help it along :(
20:30:02 <lispy> reillyeon: none that I'm aware of, but someone was here recently trying to amke one
20:30:11 <Saizan> there's MemoTrie
20:30:12 <lispy> reillyeon: I think usually in haskell if you want memoization you have to do it manually
20:30:15 <Saizan> and maybe others
20:30:28 <dolio> And data-memocombinators or something like that.
20:30:39 <Saizan> yeah
20:30:41 <reillyeon> lispy: That's what I thought.
20:30:49 <Saizan> ?hackage data-memocombinators
20:30:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-memocombinators
20:30:58 <lispy> sometimes it's really easy though, like this memoized fibs
20:31:06 <gio123> so, noone is here german speaker :)
20:31:15 <lispy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
20:31:16 <lambdabot>   573147844013817084101
20:31:44 <lispy> gio123: we have many german speakers come by here, but I guess none at the moment.
20:31:47 <jml> it looks misspelled anyway
20:31:49 <Lemmih> gio123: It's 5:30 in Germany.
20:32:04 <jml> Praktiken, not pracktiken
20:32:05 <gio123> passed following practice
20:32:12 <gio123> is it correct in english?
20:32:43 <jml> it's also not a complete sentence, as "hat" has no subject.
20:32:51 <lispy> gio123: I'm not sure what you mean to say, so it's hard to judge if it's correct english
20:33:04 <gio123> passed following practice: Professional, teaching
20:33:13 <lispy> hrm
20:33:16 <gio123> passed following practice: Professional, teaching.
20:33:23 <lispy> gio123: you mean to say, that you are experience in those areas?
20:33:33 <lispy> experienced*
20:33:33 <gio123> yes
20:33:50 <gio123> amd I were graded from uni in each
20:35:33 <lispy> I think, "passod following practice" is fine except that a native speaker would probably say it differently
20:35:36 <lispy> passed*
20:35:57 <gio123> how?
20:35:59 <lispy> But, I'm having trouble formulating it
20:36:07 <gio123> ok
20:36:08 <gio123> :)
20:36:37 <lispy> What is "Professional" ?
20:36:52 <lispy> Usually professional is an adjective
20:36:56 <Twey> Uhm
20:37:25 <lispy> with the exception of something like, "I am a professional."
20:37:34 <gio123> lispy: research ability
20:37:40 <pumpkin> hmm
20:38:18 <gio123> lispy: depensed master thesis on :"title"
20:38:22 <gio123> how it looks?
20:38:59 <shapr> dons: shapr's hat?
20:38:59 <lispy> gio123: depensed?  did you mean defended?
20:39:02 <shapr> @users
20:39:02 <lambdabot> Maximum users seen in #haskell: 558, currently: 485 (86.9%), active: 18 (3.7%)
20:39:04 <gio123> yes
20:39:06 <gio123> sorry
20:39:07 <lispy> shapr: yay shapr!
20:39:15 <blackdog> shapr: heya man
20:39:24 <lispy> gio123: that one looks fine
20:39:30 <pumpkin> who are good big haskellers to follow on twitter?
20:39:39 <lispy> pumpkin: dons
20:39:43 <pumpkin> got him
20:39:44 <pumpkin> :)
20:39:45 * BMeph tosses lambda confetti to celebrate shapr's arrival
20:39:54 <lispy> pumpkin: then whoever dons follows is a good start :)
20:40:06 <pumpkin> good idea, hadn't thought of that :P
20:40:06 <lispy> pumpkin: I find twitter to be overly silly myself, so I don't use it :)
20:40:16 <gio123> lispy:defended  master thesis on : "title"
20:40:20 <gio123> so is it OK?
20:40:22 <pumpkin> lispy: I feel like a twit for using it
20:40:25 <pumpkin> but I enjoy it anyway :P
20:40:30 <BMeph> lispy: But...you're no one if you're not on Twitter! ;p
20:40:44 <jml> this might be a silly question, but does haskell have an equivalent of C's typedef? If so, how do I do it?
20:40:48 <lispy> pumpkin: my idea was to register shitter.com and then you send in a "shit" whenever you have something interesting to say from the john :)
20:40:54 <pumpkin> lol
20:40:58 <pumpkin> that's a good idea
20:41:03 <pumpkin> I bet shitter.com is taken though
20:41:16 <BMeph> jml: We call it "newtype". And  it's pretty direct.
20:41:16 <lispy> pumpkin: it's parked by a search engine thingy
20:41:25 <jml> shittr.com perhaps
20:41:28 <lispy> gio123: yes,  I think that one is reasonable
20:41:37 <BMeph> jml: It has a few restrictions on it that typedef doesn't.
20:41:38 <thoughtpolice> Lemmih: ok, I think the patch is working - rebuilding base and trying some tests, and now lhc shouldn't depend on Support.MD5 or the MD5 C impl. either! :]
20:42:13 <thoughtpolice> Lemmih: also I was going to change a bunch of version info to output 'lhc' instead of 'jhc' ;]
20:42:28 <Lemmih> thoughtpolice: Ah, good.
20:43:12 * jml looks it up
20:43:16 <jml> BMeph: thanks.
20:44:43 <Lemmih> thoughtpolice: I've requested the project on c.h.o. You'll have write access once it comes through.
20:44:45 <BMeph> jml: No problem.  :)
20:44:59 <thoughtpolice> Lemmih: k. then we can start up trac and a mailing list.
20:45:29 <thoughtpolice> Lemmih: also, since we're using cabal do we need all the Makefile.am and autoconf stuff at the top of the tree still? or is it needed for running the test suites etc.?
20:46:37 <jml> it's been way too long since I've tried to write code in not-Python.
20:48:22 <gio123> lispy:so, the row where is credits we call credits row and were is grades we call in english what?
20:48:44 <gio123> evaluation?
20:49:18 <shapr> blackdog: g'day
20:49:23 <shapr> lispy: What did I do?
20:49:33 * shapr boings confusedly
20:49:40 <lispy> shapr: hopefully a lot
20:49:42 <jml> is there anything I could hook up to flymake for haskell?
20:49:44 <shapr> um, ok :-)
20:50:06 <blackdog> jml: what do you mean? flymake has a haskell mode..
20:50:14 <lispy> gio123: not sure I follow the question.  In english we say credits and grades though.
20:50:18 <blackdog> modulo occasional problems with lhs files
20:50:25 <gio123> ok
20:50:26 <gio123> thanks
20:51:24 <jml> blackdog: so it does :)
20:52:02 <jml> although, I can't seem to make an error that it highlights.
20:52:15 <blackdog> jml: are you using hs or lhs?
20:52:35 <jml> blackdog: the file extension is .hs -- is that what you mean?
20:52:38 <blackdog> yeah
20:54:40 <Lemmih> What was the last thing I said?
20:55:27 <shapr> "<Lemmih> What was the last thing I said?"
20:55:34 * shapr takes pedantry to new lows.
20:55:45 <shapr> But seriously - <Lemmih> thoughtpolice: I've requested the project on c.h.o. You'll have write access once it comes through.
20:55:58 <blackdog> jml: hm. works ok for me... have you got flymake working for other languages?
20:55:59 <Lemmih> shapr: Smart guy, eh? (:
20:56:00 <shapr> blackdog: Hey, I bought a bladeserver.
20:56:08 <shapr> Lemmih: Parts of me are smart, that's for sure.
20:56:14 <Lemmih> thoughtpolice: No, we don't need it. I just haven't had time to clean it all up.
20:56:18 <jml> blackdog: for Python, but that's hooked up via pyflakes with some special glue.
20:56:20 <Lemmih> thoughtpolice: The testsuite is in shambles. We need to rewrite most of it, I think.
20:56:28 <blackdog> shapr: seriously? that's kind of cool
20:56:47 <shapr> blackdog: Yeah seriously, but I have more than 14 slots worth of blades to put in it.
20:56:58 <blackdog> what sort of specs? i've been idly thinking about getting a big quad-core box or something to have a go at multicore..
20:57:04 * shapr points to #haskell-blah
20:57:10 <blackdog> oh wow. you hardcore bastard, you :)
20:58:00 <jml> blackdog: http://hpaste.org/12296 if you're interested
21:00:16 <blackdog> jml: annotated it with what i've got
21:00:55 <blackdog> jml: think there's a haskell wiki page on it somewhere, too
21:01:05 <jml> ahh ok
21:01:31 <jml> blackdog: so, I guess my original question could be rephrased as, "what's in flycheck_haskell.pl?"
21:02:10 * jml suddenly remembers what .lhs stands for & implies -- who says university was a waste of time?
21:03:15 <blackdog> http://www.emacswiki.org/emacs/FlymakeHaskell
21:03:18 <lambdabot> Title: EmacsWiki: Flymake Haskell
21:04:02 <blackdog> jml: i made some trivial change that let it work, but it should all be on that apage
21:04:10 <jml> thanks.
21:10:16 <roconnor> strange.  It seems I cannot import a single function from a module without an export list.
21:10:51 <BMeph> roconnor: O RLY? ;)
21:11:07 <roconnor> It's probably something else
21:11:12 <hackage> Uploaded to hackage: flickr 0.3.1
21:11:55 <roconnor> no I still get the error
21:12:04 <roconnor> Data/Colour/SRGB/Linear.hs:30:29:
21:12:04 <roconnor>     Module `Data.Colour.Internal' does not export `RGB'
21:12:15 <pumpkin> how can I define a get for instance Binary <myType> where, without a put?
21:12:18 <roconnor> oh wait
21:12:20 <pumpkin> I only need to read the file, not write it
21:12:25 <roconnor> I cannot import a constructor like that
21:13:16 <roconnor> there it goes
21:13:17 <roconnor> working now
21:14:19 <blackdog> pumpkin: couldn't you just define a null put?
21:14:26 <blackdog> put x = undefined or something?
21:14:29 <pumpkin> I guess
21:14:47 <blackdog> then it'll be your fault when you try to put something after you promised not to :)
21:15:00 <Saizan> you're not forced to make a Binary instance to use the .Get monad
21:15:01 <thoughtpolice> Lemmih: ping?
21:15:15 <gio123> Formal Theories or Formal theory?
21:15:24 <pumpkin> blackdog: soudns good :)
21:16:09 <reillyeon> gio123: Formal theory
21:16:21 <Lemmih> thoughtpolice: Yes?
21:22:34 <jeffwheeler> I'm having trouble using `darcs send`, after it was working this morning. I'm not exactly sure what changed, but now it seems to fail silently (it says it was sent successfully).
21:23:04 <yuuki> Does anyone have resources for linear logic as a type system for haskell or other languages?
21:23:04 <jeffwheeler> I've tried sending it both to my personal email address and to the devel mailing list for the project, but neither seem to receive it.
21:24:20 <reillyeon> jeffwheeler: Wireshark or strace to see if it's connecting to the mail server?
21:24:38 <jeffwheeler> reillyeon: I could try that, but wouldn't it be using sendmail on my machine?
21:25:11 <reillyeon> jeffwheeler: If it's using sendmail then you could check the logs.
21:25:38 <jeffwheeler> reillyeon: alright; I have no idea what I'm doing with sendmail (never configured it before), but I'll try to do that.
21:27:24 <lispy> jeffwheeler: an unfortunate thing about using sendmail is that darcs can't tell when sendmail fails to send because that part happens after darcs send exits
21:27:52 <jeffwheeler> lispy: hmm, then that seems to suggest again that the logs should contain something; I'll keep looking for them
21:28:04 <lispy> jeffwheeler: I use postfix as my sendmail and have it connect to my google account.  What os are you on?
21:28:20 <jeffwheeler> lispy: OS X; I think sendmail came on it, but I don't remember for sure
21:28:44 <lispy> jeffwheeler: yes, I use osx too.  Okay, I should be able to find the guide I used
21:29:34 <jeffwheeler> lispy: this? http://www.installationexperiences.com/?p=87
21:30:15 <lispy> jeffwheeler: ah yeah, just found that.  not the exact one I used, but it looks to be equivalent
21:30:33 <jeffwheeler> lispy: thanks; I'll try that
21:30:37 <Lemmih> thoughtpolice: You rang?
21:38:36 <thoughtpolice> Lemmih: sorry
21:38:43 <thoughtpolice> Lemmih: okay so I got pureMD5 switched in
21:39:11 <thoughtpolice> Lemmih: I also am about to have a patch for the UTF8 stuff; it will require a utf8-string dependency but it should eliminate the 9-million copies of 'toUTF' and 'fromUTF' hanging throughout the source
21:42:24 <jeffwheeler> lispy: after some playing, I got it working; thanks a ton!
21:42:47 <jeffwheeler> (And damn, the cleaner Gmail is beautiful; I hadn't used the web client in ages.)
21:48:55 <lispy> jeffwheeler: yay!  (they have themes in Gmail now too, I like "tree" because it updates the bg to fit the local weather :)
21:49:44 <thoughtpolice> Lemmih: patch bundle sent; includes the utf8 and md5 changes and some other stuff (plus a conflict fix between two of our patches in lhc.cabal)
21:49:45 <jeffwheeler> lispy: yep; it's neat
21:53:15 <Lemmih> thoughtpolice: Wonderful. I've pushed them to d.h.o.
21:54:08 <thoughtpolice> Lemmih: I'll look into replacing Doc with ansi-wl-pprint, and updating a bunch of the version info
21:54:47 <thoughtpolice> Lemmih: doc will by far be the most significant refactor
22:09:11 <lispy> darcs-graph keeps saying, darcs-graph: no patches found in: foo/
22:09:15 <lispy> but, I have patches there
22:09:21 <lispy> is it incompatible with darcs2 format?
22:11:12 <hackage> Uploaded to hackage: mediawiki 0.2.3
22:11:12 <hackage> Uploaded to hackage: ffeed 0.3.2
22:11:12 <hackage> Uploaded to hackage: ffeed 0.3.1
22:11:12 <hackage> Uploaded to hackage: flickr 0.3.2
22:14:57 <Lemmih> thoughtpolice: I really appreciate your efforts. LHC will be a lot easier to install without Doc.
22:15:12 <lispy> what is Doc?
22:15:20 <lispy> some sort of esoteric documentation package?
22:15:29 <BMeph> lispy: The Seventh Dwarf? ;p
22:15:39 <lispy> BMeph: heh, nice
22:15:41 <Lemmih> lispy: A pretty-printer with support for terminal codes (for colours).
22:24:30 <jml> how can I get a string representation of an integer? (e.g. 4 -> "4")
22:24:43 <blackdog> show i
22:24:47 <dibblego> > show 4
22:24:48 <lambdabot>   "4"
22:24:54 <jml> thanks
22:26:04 <jml> is there an inverse operation that will bork if the string isn't a number?
22:26:11 <dibblego> read
22:26:48 <jml> dibblego: won't 'read' read anything?
22:27:00 <dibblego> > read "4" :: Integer
22:27:01 <lambdabot>   4
22:27:06 <dibblego> > read "xx" :: Integer
22:27:07 <lambdabot>   * Exception: Prelude.read: no parse
22:27:17 <jml> thanks.
22:27:17 <pumpkin> what's a good way to make dependent enums? I need a type and subtype enum, and I'd like to have certain subtypes only work for certain types
22:29:10 <Saizan> pumpkin: an example?
22:30:27 <pumpkin> well, again with my mach-o parser, they define a few CPU types, such as x86, powerpc, arm, and so on. these cpu types have subtypes, such as pentium 4, pentium pro, and such, but it doesn't make sense to pair up pentium pro subtype with an arm cpu type
22:31:34 <pumpkin> it'd be nice to have pattern matching on types or something, like cpuSubtypes (X86 _) = Pentium | Pentium4 | Core2Duo
22:31:35 <pumpkin> :P
22:31:46 <pumpkin> actually no underscore there
22:32:43 <Saizan> data CPU = X86 X86 | Arm Arm | PPC PPC ..., data X86 = Pentiom | Pentium4 | Core2Duo, data Arm = ...
22:32:46 <Saizan> ?
22:33:30 <pumpkin> ah, was hoping to avoid making a separate type for each of those enums, but it makes sense
22:34:55 <Saizan> uhm, you could put them all in one GADT
22:35:10 <pumpkin> how would that work?
22:35:32 <pumpkin> reading up on them now :)
22:37:07 <Saizan> data X86; data Arm; ... data CPU a where Pentium :: CPU X86; Pentium4 :: CPU X86; SomeArmCPU :: CPU Arm ...
22:37:33 * ddarius finds the first solution much more sensible.
22:37:38 <pumpkin> :P
22:38:12 <Saizan> yeah
22:53:35 <erikc> is there a regexp that works over bytestrings i should use instead of unpacking and using Text.Regex.Posix?
22:54:04 <erikc> n/m
22:54:33 <Twey> erikc: Find one?  Or just decide that three lines of lifting code weren't worth the effort of looking?  :-P
22:55:34 <erikc> i found Text.Regex.Posix.ByteString :P
22:57:27 <Lemmih> Gitit is actually quite awesome.
22:58:55 <Lemmih> I initially installed it out of solidarity to Haskell but now I find it very useful.
23:01:09 <Twey> erikc: Ah :-P
23:19:49 <lispy> Lemmih: what do you like?
23:20:02 <lispy> Lemmih: why is so cool, I mean
23:20:19 <Twey> Gitit?
23:21:24 <Lemmih> lispy: It was incredibly easy to install. Orders of magnitude easier than media-wiki.
23:21:28 <dons> erikc: Text.Regex.* have modules to work on bytestrings
23:21:38 <dons> if you care about performance use the PCRE backend, not the Posix one
23:23:30 <blackdog> anyone know what "Tip" means in -hd profiling on ghc?
23:24:17 <lispy> Lemmih: okay, does it have a web front end?  Do you have a demo I can look at?  I have a broken mediawiki install that I'm too lazy to fix, plus I'm sick of php :)
23:24:19 <Lemmih> lispy: And highlighting-kate+pandoc works wonders.
23:24:34 <Lemmih> lispy: lhc.seize.it
23:24:51 <lispy> Lemmih: heh, so what does l the end stand for now?
23:25:00 <Lemmih> lispy: LHC.
23:27:07 <the_unmaker> ok ok
23:27:07 <lispy> Lemmih: wow, I fail at typing.  I meant, what is the acronym LHC mean?
23:27:13 <the_unmaker> what is this lhc thing?
23:27:17 <Saizan> blackdog: it's probably a constructor of some tree
23:27:24 <the_unmaker> in fact
23:27:26 <lispy> the_unmaker: it's a haskell compiler
23:27:38 <the_unmaker> someone tell me why everyone is taking a crap over haskell
23:27:44 <the_unmaker> is ti really that fun and cool?
23:27:44 <lispy> Lemmih: did you go with Lemmih, or Large Hadron Compiler?
23:27:46 <Lemmih> lispy: LHC Haskell Compiler. Its recursive.
23:27:52 <lispy> Lemmih: got it, cool
23:28:15 <Lemmih> the_unmaker: It really is. (:
23:28:52 <lispy> the_unmaker: I really like it.  I like having a language where I can make the compiler enforce some invariants and the semantics of the language mean I can program both efficiently and abstractly.  I love the community.  It's full of hyper intelligent people that really care about making quality software.
23:29:55 <pumpkin> hmm
23:30:02 <lispy> Lemmih: you may have convinced me to use gitit in the future as my wiki engine.
23:30:04 <pumpkin> I think I'm confusing myself
23:30:48 <lispy> Lemmih: we need to add a way to export to PDF since it can do latex
23:31:01 <lispy> Lemmih: do you know if it's possible to do latex style math mode too?
23:31:07 <Lemmih> lispy: Yeah, I was just thinking that.
23:31:09 <lispy> Lemmih: mediawiki had that extension andit was nice
23:31:29 <lispy> actually, can you author in whatever markup pandoc supports?
23:32:19 <lispy> and having a darcs backend would be cool IMO but I think that because I'm a darcs hacker :)
23:32:45 <the_unmaker> crap
23:32:50 <the_unmaker> got bumped off
23:32:57 <the_unmaker> did anyone respond to me?
23:33:05 <lispy> the_unmaker: I really like it.  I like having a language where I can make the compiler enforce some invariants and the semantics of the language mean I can program both efficiently and abstractly.  I love the community.  It's full of hyper intelligent people that really care about making quality software.
23:33:11 <lispy> (that's what I said)
23:33:24 <Lemmih> lispy: I looked at the git code but it went way over my head.
23:34:01 <Lemmih> the_unmaker: Haskell is the most enjoyable language I've seen.
23:34:03 <lispy> Lemmih: well, as long as the wiki engine is nice and works well I don't care if it interacts with cvs in the back :)
23:34:13 <lispy> Lemmih: so, maybe i'm bikeshedding
23:34:27 <the_unmaker> how about vs squeak smalltalk   common lisp   or FORTH
23:34:56 <pumpkin> they're all very different
23:34:58 <lispy> the_unmaker: I came here from common lisp.  The advantage that Haskell provide are performance and static gaurantees about the code
23:35:13 <lispy> the_unmaker: Also, the community for Haskell is friendlier
23:35:17 <Twey> Haskell's the best language evah!  :-P
23:35:26 <Twey> There's more stuff going on in Haskell
23:35:48 <lispy> ?users
23:35:48 <lambdabot> Maximum users seen in #haskell: 558, currently: 475 (85.1%), active: 8 (1.7%)
23:35:54 <lispy> just look at all the users
23:36:00 <lispy> we're what, the 13th biggest channel on freenode?
23:36:07 <Twey> Functional programming is quite a new field as far as things go (I know, it's ancient, but there hasn't been much work on it), and it's mostly the Haskell folks who are taking it places
23:36:36 <lispy> Twey: yeah, I think the inefficiencies of older FP languages really hurt the adoption.
23:36:52 <lispy> but, Haskell is pretty damn fasted
23:36:55 <lispy> fast*
23:37:08 <Twey> Only in Haskell can you wander around the wiki and find articles on, ahem, 'zygohistomorphic prepromorphisms'
23:37:11 <Twey> :)
23:37:43 <lispy> I think the next hurdle for Haskell adoption is getting it into the circulum
23:37:44 <pumpkin> I have what's probably a dumb question
23:37:52 <pumpkin> made dumber by the fact that it's hard to explain
23:37:53 <lispy> it tends to only be taught at the high end
23:37:54 <Twey> pumpkin: Aye-aye?
23:38:02 <Twey> lispy: Better, getting it into *good* curriculum
23:38:04 <lispy> pumpkin: i have a dumb answer then
23:38:08 <pumpkin> :)
23:38:13 <Twey> I've seen a few examples now of Haskell Taught Badly
23:38:33 <lispy> pumpkin: BTW, no such thing as stupid questions...just some people are stupid ;)
23:38:34 <Twey> Anyone remember that guy with a homework question on how to implement laziness in Haskell?
23:38:45 <pumpkin> lispy: then maybe it's that :P
23:38:47 <Twey> (\() x -> x) ()
23:38:50 <pumpkin> lol
23:38:51 <lispy> pumpkin: but anyway, ask us?
23:38:56 * Twey shakes vis head.
23:38:56 <pumpkin> yup, trying to phrase it :)
23:40:13 <Twey> pumpkin: Can you phrase it better with code?  :)
23:40:37 <lispy> pumpkin: maybe it's easire to ask in lolcode?
23:40:52 <Twey> Or Lojban!
23:41:00 <lispy> http://lolcode.com/examples/examples
23:41:01 <pumpkin> sooooo I'm writing (or attempting to write) a loader for mach-o binaries. these support a variety of architectures, which means that for a given arch, the file is full of types that vary with the architecture. The first field in the binary specifies specifically if the rest of the binary is big-endian, little-endian, 32 bit or 64 bit (all combinations of these)
23:41:05 <lambdabot> Title: examples:examples Â· LOLCODE
23:41:09 <Twey> mi'a prami la .lojban. .iu
23:41:34 <pumpkin> I was hoping to get around the obvious 4-fold repetition by messing with the types
23:41:52 <Twey> Heh, 'specifies specifically' is redundantly pleonastic!
23:42:02 <pumpkin> lol, you're right
23:42:16 <pumpkin> a left-over from in-irc-client editing
23:42:20 <Twey> Hmm
23:42:23 <Twey> Yep, you could do that
23:42:30 <pumpkin> but it occurred to me that this is all at runtime
23:42:31 <lispy> pumpkin: at least on the surface, I would say it's good to have 1 internal representation and a parser that understands how to map from the 4 types of input to the 1 internal rep and possible a pretty printer that is analogous to the parser
23:42:32 <Twey> With typeclasses perhaps?
23:42:55 <Twey> Ah, hmn, yes
23:43:09 <pumpkin> well, so I was thinking of having an extension of the (Word/Int)(n) types with (be/le) appended
23:43:34 <pumpkin> so based on the type it knows what endianness to read
23:43:49 <pumpkin> but again, it feels fundamentally flawed due to the fact that the specific type comes at runtime
23:43:54 <pumpkin> unless I've just confused myself :P
23:45:17 <pumpkin> so I have a type called Endian which is either BigEndian or LittleEndian, a CpuType which is parameterized on the size of its address (Word64 or 32)
23:45:38 <pumpkin> and I'd like to pull out the right one at the right time, and have the rest magically read correctly
23:46:05 <pumpkin> am I doing it
23:46:06 <pumpkin> maybe http://is.gd/Gf7 ?
23:46:28 <lispy> pumpkin: you have a parser right?
23:46:44 <pumpkin> not quite :P well, not in haskell anyway
23:46:58 <pumpkin> I'm trying to think of the most effective way to write one in haskell
23:46:59 <lispy> how do you read the binary?
23:47:13 <pumpkin> well, so far I've been using Data.Binary.Get for my tests
23:47:21 <the_unmaker> hmmmmmmm
23:47:37 <the_unmaker> what about arc?
23:47:37 <pumpkin> but I'm only reading the first field (that specifies the endianness and address size) and then trying to think how to implement the rest most efficiently
23:47:39 <the_unmaker> ;)
23:47:49 <pumpkin> without writing 4 copies of the parser for each combination
23:47:59 <pumpkin> *one for each combination
23:48:25 <lispy> pumpkin: I don't know how Data.Binary works, but it seems to me that you'd make a way to read bytes and the parser would know if those bytes are part of a big or little endian number.  Then you'd convert it to it's value based on that info.  So internally the big/little endian distinction would go away.
23:49:07 <pumpkin> yeah
23:49:26 <pumpkin> easiest way would be for me to just pass a "reader" to the parser function
23:49:33 <pumpkin> one for each word size
23:49:40 <pumpkin> but I wanted to see if I could do better than that using types
23:49:59 <lispy> Well...
23:50:03 <lispy> If you wanted to use types for this
23:50:16 <lispy> I think you'd want to have data BigEndian; data LittleEndian
23:50:38 <lispy> Then you have a phantom type, data MyWord a = W Word
23:50:40 <pumpkin> yeah, I have that
23:50:54 <pumpkin> oh I don't actually have exactly that
23:51:08 <pumpkin> W?
23:51:10 <lispy> so you can pass around MyWord BigEndian, and the type checker considers that as differen from MyData LittleEndian
23:51:22 <pumpkin> ah yes, that's what I was thinking
23:51:28 <lispy> W is just me being lazy about naming the data contsructor
23:51:30 <pumpkin> :)
23:52:21 <lispy> If you want the type checker to help you more, you have to "lift" your values into the type system
23:52:28 <pumpkin> I guess my question is mostly how this stuff propagates
23:52:32 <lispy> that's why I made data BigEndian and data LittleEndian
23:52:49 <pumpkin> so say I start parsing and detect it's a big-endian 64-bit arch
23:52:55 <lispy> Then to handle the polymorphism and programming based on types you use type classes, GADTs, and existentials
23:53:14 <pumpkin> I create an instance of ArchInfo with the correct endianness and address type
23:53:20 <lispy> okay
23:53:33 <lispy> (sounds like you'll need GADTs to type that)
23:53:35 <pumpkin> pass it as the first parameter to my MachO type constructor (currying)
23:53:48 <pumpkin> and then hope that it magically sets all the rest of the types for the type
23:53:54 <pumpkin> for the MachO
23:54:33 <pumpkin> okay, I'll give it a go and see how epicly it fails :P
23:54:34 <Saizan_> you could make the endianess a parameter of a monad transformer over Get
23:54:46 <lispy> data ArchInfo endianness addrtype where Option1 :: ArchInfo LittleEndian SixtyFourBit; Option2 :: ArchInfo BigEndian SixtyFourBit; ...
23:55:18 <pumpkin> Saizan_: I was originally thinking of something like that too, but was wondering if it made sense to go further and specify that it makes no sense for BE and LE values to coexist in the same instace of the binary
23:55:27 <Saizan_> and have things like getWord :: Endianess e => WithEndianess e Get Word
23:55:41 <lispy> pumpkin: a GADT is similar to a type class, except that it's closed and you can recover information about the "instance" (data constructor in this case)
23:55:47 <pumpkin> ah
23:56:12 <pumpkin> maybe I should've started with a less ambitious project
23:56:56 <pumpkin> hmm
23:56:56 <Saizan_> or write it the straightforward way and add fancyness later
23:57:26 <pumpkin> Saizan_: but that's no fun! :P I want to think hard :) it's pretty trivial to translate from the file spec to a reader
23:57:36 <pumpkin> I'm not used to thinking about types like this
23:58:10 <Saizan_> heh, ok :)
