00:00:10 <dmwit_> mgdtgd: Specify the type of piWallis as Integer -> Rational and you'll be good to go.
00:00:23 <adu> ok, so that should force the type of fromInteger to Integer -> Double as well...
00:00:53 <mgdtgd> dmwit_: why is that so
00:00:58 <adu> mgdtgd: did you specify that type? or are you relying on the thing?
00:01:08 <mgdtgd> I specified it
00:01:28 <dmwit_> mgdtgd: Rational is arbitrary-precision; Double is machine-precision.
00:01:38 <adu> mgdtgd: interpreters/compilers make many assumptions, like 3 is an Int unless it needs to be a Word64 or something....
00:02:32 <mgdtgd> http://hpaste.org/12058
00:03:22 <dmwit_> Actually, now that I read back, I'm not totally sure: what is your question?
00:03:56 <mmorrow> @type 42
00:03:57 <lambdabot> forall t. (Num t) => t
00:04:23 <mgdtgd> my question is: what is the difference between my division in piWallis and the division that has to be somewhere in fromRational
00:04:30 <sjanssen> mgdtgd: the fromRational method defers rounding until the last possible moment, and that is why it is more precise
00:04:33 <mmorrow> @type (42::Integer,42::Double,42::Word64)
00:04:33 <adu> mgdtgd: to answer one of your questions, fromRational has different implementations for different types
00:04:34 <lambdabot> (Integer, Double, Word64)
00:05:02 <dmwit_> mgdtgd: fromRational has no division itself; fromRational is not even a function all by itself.
00:05:03 <adu> mgdtgd: you could look in the GHC sources for something like "instance Fractional Double where"
00:05:06 <mgdtgd> where do I find fromRational :: Rational -> Double
00:05:18 <dmwit_> mgdtgd: fromRational is a class function.
00:05:26 <dmwit_> ?src Double fromRational
00:05:27 <lambdabot> Source not found. My mind is going. I can feel it.
00:05:30 <sjanssen> @source GHC.Float
00:05:30 <lambdabot> GHC.Float not available
00:05:34 <dmwit_> Anyway, it's a primitive.
00:05:41 <sjanssen> it isn't actually
00:06:30 <sbahra> mmorrow, hi
00:06:30 <lambdabot> sbahra: You have 1 new message. '/msg lambdabot @messages' to read it.
00:06:42 <sjanssen> mgdtgd: http://hpaste.org/12058#a1
00:07:09 <adu> fromRational x =  fromRat x, does that answer your question? lol
00:07:10 <sjanssen> mgdtgd: but I think you'll find that most of the magic is in Rational, not fromRational
00:07:43 <adu> mgdtgd: i found that in ghc-6.8.3/libraries/base/GHC/Float.lhs
00:07:58 <mgdtgd> thank you
00:07:59 * sjanssen has pasted fromRat's defn. in the above paste
00:08:26 <mmorrow> mgdtgd: here's the fromRational src http://hpaste.org/12058#a2
00:08:35 <mgdtgd> fromRat does indeed do some serious magic
00:08:37 <mmorrow> heh, me too
00:09:05 <mmorrow> sjanssen: jinx
00:12:12 <adu> wow, its almost pi-time
00:12:17 <adu> I should go to bed
00:12:31 <adu> 3.14 am
00:23:33 <solrize> is there  a way to get finer grained heap profiling than ghc -prof  -auto-all -caf-all -fforce-recomp
00:23:43 <solrize> i know which one of my functions is overflowing the stack
00:23:53 <solrize> but i am having trouble figuring out why
00:30:17 <sjanssen> solrize: you can add cost center pragmas, see the GHC manual
00:30:28 <solrize> thanks i'll look at that
00:38:26 <Snark> hmmm... what does "strict version" mean ?
00:38:32 <Snark> like in foldl vs foldl'
00:38:55 <dmwit_> Strictness is one of the opposites of laziness.
00:39:07 <dmwit_> It means you evaluate to weak-head normal form before continuing.
00:39:34 <dmwit_> Practically speaking, this means foldl' produces many fewer thunks than foldl does, which means you can sometimes prevent a stack overflow by using it.
00:39:51 <Snark> ok
00:39:55 <Snark> thanks
00:40:21 <dmwit_> There is much to know about this, so feel free to ask more questions. =)
00:44:34 <dons> Snark: welcome to haskell.
00:46:05 <dons> dcoutts, one of the top search phrases for  the arch haskell blog... "which linux for haskell" ...
00:46:21 <C-Keen> hehe
00:46:45 <dons> come on debian. where you at?
00:50:19 <Snark> dons, eh, it's been some time already, but I'm not 100% up to speed yet
00:53:02 <dons> ok. how can we help?
00:58:52 <Savant> dons: Sup?
01:08:55 <Snark> dons, examples are what help the most
01:09:02 <Snark> but I already managed to do what I wanted
01:12:30 <dons> you could try a tutorial
01:12:34 <dons> ?go learnyouahaskell
01:12:37 <lambdabot> http://learnyouahaskell.com/
01:12:37 <lambdabot> Title: Learn You a Haskell for Great Good!
01:12:40 <dons> ?go realworldhaskell
01:12:47 <dons> hey...
01:12:53 <lambdabot> http://www.realworldhaskell.org/
01:12:53 <lambdabot> Title: Real World Haskell
01:12:56 <dons> there we go.
01:25:30 <Snark> dons, I did try
01:25:42 <Snark> dons, Write Yourself a Scheme in 48 Hours was helpful
01:25:55 <Snark> simpler examples are better
01:26:13 <Snark> like the tick example at the end of the Control.Monad.State.Lazy documentation
01:26:13 <solrize> As to cardinality not being absolute, personally I no more expect an axiomatic model to capture everything about my intuitions than I expect a Barbie doll should actually feel love for Ken, frankly I'm amazed they do so well.
01:26:15 <Savant> I never found Teach yourself * in * books very good.
01:26:31 <dons> heh
01:26:41 <dons> probably different in grassroots tutorials online
01:27:05 <solrize> teach yourself haskell in 15 years and 3 postgrad degrees
01:27:15 <Savant> solrize: That's upsetting.
01:27:18 <dons> heh
01:27:25 <dons> you'll never learn C++ by that comparison
01:27:46 <dons> haskell's easy, its just explained to a rather deeper level than most languages.
01:28:04 <dons> so what goes unexplained and unexamined in other languages, we try to explain
01:28:09 <C-Keen> IMHO that deeper level is necessary to get programs running though
01:28:16 <dons> i wonder.
01:28:25 <dons> it's still a language for new programmers though
01:28:34 <Savant> It is?
01:28:34 <dons> programmers not yet tainted by imperative thinking
01:28:42 <C-Keen> the compiler error messages are a babble of infinite nothing if you don't understand how the language works
01:28:43 <dons> sure. it was my first programming language at university
01:28:43 <Savant> Hrm.
01:28:52 <Savant> dons: How long ago was this?
01:28:56 <dons> oxford, chalmers, lots of places teach it as a first language
01:29:01 <dons> Savant: 10 years ago.
01:29:07 <Savant> AH
01:29:09 <Savant> Ah*
01:30:01 <C-Keen> dons: I am spoiled in this regard but I do find that it is actually easier to program in haskell, as it really forces you to think about data structures first
01:30:03 <dons> i'm not really sure what imperative programmers expect when they hit haskell. seems like people are making progress. perhaps having lots of libraries and code and tutorials now is helping.
01:30:11 <dons> C-Keen: yeah, data structures are key.
01:30:18 <dons> its all about choosing types to represent your thoughts :)
01:30:26 <dons> and then everything else is easy.
01:30:30 <Savant> Haskell programmers tend to write better imperative code, I suppose.
01:30:36 <Savant> Well, first-language coders.
01:30:39 <C-Keen> dons: From my experience if I get the data right the code just 'wraps' around it although this sounds awfully cheesy
01:31:18 <dons> didn't djikstra say something about 'show me a data structure, and i'll show you an algorithm'?
01:31:34 <dons> that data structures are the main organising principle of code
01:31:40 <C-Keen> dons: I think the hard part for imperative programmers is to break the old thinking patterns about how to do certain things, trained idioms are hard to change
01:31:50 <dons> and imo, they're not first class in a language until you get ADTs and pattern matching.
01:31:56 * dmwit_ finds this unconvincing
01:32:09 <dons> at which point data structures become so primary they really begin to capture signficant parts of the design
01:32:52 <dons> C-Keen: yeah. there's just basic habits to relearn. loops, mutation, globals
01:33:15 <dmwit_> There's an awful lot of back-patting going on, but I've seen about the same ratio of good to bad code in the Haskell community as I have in any other language community.
01:33:20 <dmwit_> In other words: not that much bad code.
01:33:26 <C-Keen> dons: which makes it a hard demotivating struggle sometimes
01:33:33 <dmwit_> There's smart coders who make choices that do not end in Haskell. =)
01:33:39 <vegai> dmwit_: the java community too?
01:33:44 <dons> dmwit_: yeah, peole produce code anywhere it seems
01:33:48 <dmwit_> I haven't been in the Java community.
01:34:00 <dmwit_> But I find it hard to believe that people suddenly lose skill just because they're using Java.
01:34:01 <dons> even if we were all programming in asm, code would still be produced.
01:34:04 <dons> humans are ingenious.
01:34:08 <vegai> depends on how you define a community member, though
01:34:10 <C-Keen> dmwit_: I think we agree that you can write bad code in any language
01:34:21 <C-Keen> dmwit_: and it is easy as well
01:34:26 <vegai> some members of the C community for instance, might like to be rather selective
01:36:00 <vegai> dmwit_: no, not lose skill, but if you have a language that 99% of new programmers learn, I would guess it's bound to have a larger relative quantity of bad coders
01:36:08 <vegai> I have no data to back that up, though
01:36:10 <solrize> i didn't have much trouble with the idea of applicative programming, but i'd done lisp before.  i had a fair amount of trouble with the type system but i think i mostly get it now.   i still struggle with evaluation strategy and space leaks and feel somewhat despairing about them.  there is even an item in the GHC bug tracker about a space leak that the simons haven't figured out how to fix, so what chance does someone like me have?
01:36:34 <dmwit_> vegai: That's not the language's fault, either.
01:36:40 <vegai> certainly not
01:36:52 <dmwit_> So I still find the "Haskell coders are inherently better" meme a bit unconvincing.
01:36:59 <vegai> just a symptom of failing to avoid success :)
01:37:08 <dons> dmwit_: i don't think anyone's saying that.
01:37:22 <dons> i doubt anyone's would claim such a thing.
01:37:23 <C-Keen> dmwit_: I agree
01:37:36 <dmwit_> <Savant> Haskell programmers tend to write better imperative code, I suppose.
01:37:55 <Snark> I had to solve a problem where I had a [String] and wanted to make it a [[String]], by cutting everytime I met "Backtrace:" -- I solved it but I find my solution inelegant
01:37:56 <dons> that's an interesting idea. its along the lines of spj's 'finest imperative language'
01:38:11 <dons> dmwit_: perhaps they write better imperative code, as they write /less/ imperative code :)
01:38:12 <Raynes> dons: Damn near everyone claims that actually.
01:38:22 <dons> Raynes: what?
01:38:51 <Raynes> You said you didn't think anyone would make such a claim.
01:38:56 <Raynes> Alot of people do.
01:39:01 <dons> that haskell /coders/ are better than other coders?
01:39:03 <Snark> http://pastebin.com/d4cbeb774 <- if someone can tell me how to make more elegant
01:39:35 <Raynes> No, that learning haskell makes you write better imperative code.
01:39:45 <dons> oh, sure.
01:39:53 <dons> it teaches you a hell of a lot about imperative thinking
01:39:59 <dons> when and why to use mutation, for example
01:40:04 <dons> what the hell "imperative" is.
01:40:05 <solrize> it takes much more mental effort to reach a level of basic competence with haskell than with other languages, so i'd say haskell programmers have worked harder at acquiring programming skill than (say) java programmers on average.  so you've got a group of programmers that's 1) self-selected for taking on challenges; 2) have put more effort into skill development; 3) are nerds, as required per haskell's mathematical nature
01:40:10 <dmwit_> Snark: Check it:
01:40:17 <dmwit_> :t break (=="Backtrace:")
01:40:18 <lambdabot> [[Char]] -> ([[Char]], [[Char]])
01:40:23 <dons> solrize: do you think that's true if they're new programmres?
01:40:30 <dons> who've not yet become imperative programmers?
01:40:49 <dons> there's a reason functional languages are taught to non-programmers: they match basic math training better.
01:41:19 <vegai> I have a distaste in many mathematical things, Haskell still appeals to me
01:41:24 <solrize> yes i think so.  lots of very young kids learn to program in basic, logo, etc.  i think that would be near impossible with haskell
01:41:27 <vegai> might be that I haven't looked at the right math yet, though
01:41:45 <dons> solrize: but we do see again and again the teaching of haskell to non-programmers..
01:41:49 <vegai> was it dibblego who teached his kids haskell?
01:42:03 <dmwit_> > let chunky s [] = []; chunky s ss = let (b, e) = break (==s) ss in b : chunky s e in chunky "Backtrace:" ["hey", "Backtrace:", "Backtrace:", "foo", "bar"]
01:42:05 <lambdabot>   [["hey"],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
01:42:11 <dmwit_> whoops =P
01:42:24 <dmwit_> > let chunky s [] = []; chunky s ss = let (b, e) = break (==s) ss in b : chunky s (drop 1 e) in chunky "Backtrace:" ["hey", "Backtrace:", "Backtrace:", "foo", "bar"]
01:42:25 <lambdabot>   [["hey"],[],["foo","bar"]]
01:42:28 <dons> so that's the school of 'imperative thinking is a constraint placed on us by bad languages'
01:42:29 <solrize> non-programmers with no math training?
01:42:40 <dons> solrize: yes, just school kids starting university.
01:42:44 <Snark> dmwit_, the first version doesn't work ;-)
01:42:53 <dmwit_> Snark: The second version works fine, though. =)
01:42:58 <dons> haskell was primarily a teaching language in the 90s.
01:43:08 <dons> the generation that grew up on hugs and miranda
01:43:18 <solrize> hmm
01:43:28 <therp> I propose a controlled experiment with two kindergartens full of innocent children, one being taught a functional language for 4 years, and one being taught an imperative one.
01:43:41 <dons> i can entirely accept that /if/ you've become an imperative programmer, there's a greater leap to FP than to another imperative language (say, python or ruby)
01:43:45 <dons> that just seems like a no-brainer.
01:43:53 <dmwit_> therp: Starting young, eh? =)
01:44:22 <dons> yeah, give 'em x = x + 1 and watch them cry :)
01:44:23 <therp> dmwit: we can also take two elementary school :)
01:44:29 <Snark> dmwit_, I'm trying to understand it first
01:44:32 <solrize> i look at something like hughes' "why functional programming matters" and could imagine an intro haskell course going mostly along those lines
01:44:48 <solrize> which means treating haskell as almost untyped
01:45:00 <dmwit> Snark: The key is to understand break:
01:45:04 <dons> you could check out wadler's justification for typed intro. languages
01:45:14 <Snark> dmwit, I get break, but you're looping on it
01:45:16 <dmwit> > break (=="Backtrace:") ["hey", "Backtrace:", "there"]
01:45:17 <lambdabot>   (["hey"],["Backtrace:","there"])
01:45:22 <dmwit> Snark: Exactly!
01:45:26 <dons> an argument against scheme, fwiw, and for miranda (or was it orwell, Pseudonym?)
01:45:36 <dmwit> Snark: See, you've already understood it! =)
01:45:47 <dons> now days though people donn't seem to be talking much about what language to teach beginners.
01:45:48 <dmwit> Snark: (What's giving you trouble, then?)
01:45:54 <solrize> is that a particular article by wadler?  i'm not familiar with it
01:46:01 <dons> let me see..
01:46:02 <Snark> dmwit, how you get rid of the pair
01:46:08 <dons> is a very early wadler work
01:46:14 <solrize> i'm not saying using typed languages is inadvisable, i'm just saying haskell's type system is difficult to understand
01:46:14 <dons> when he was teaching in the 80s
01:46:22 <dmwit> Snark: Ah, the key there is the let-binding; I use pattern matching to deal with the pair:
01:46:24 <dons> oh sure. haskell's an industrial language
01:46:28 <dons> like teaching C++ to kids
01:46:31 <solrize> right
01:46:35 <dmwit> > let (b, e) = break (=="Backtrace:") ["hey", "Backtrace:", "there"] in b
01:46:36 <lambdabot>   ["hey"]
01:46:40 <dons> the typed 'haskell' taught to new programmers doesn't have type classes.
01:46:43 <therp> dons: I really like the SICP video series, and also C.Queinnec seems to do well teaching Scheme to almost all technical student in their first year at some Paris university
01:46:50 <dons> its just a simple polymorphically typed language.
01:47:01 <dmwit> Snark: Do you see how that binds "b" and "e" to the first and second parts of break's return value?
01:47:02 <dons> therp: right, but what if they had some types as well.
01:47:03 <therp> dons: so, for the moment, scheme is better than most of what we have. I was "taught" Java for instance
01:47:07 <dons> what more structure would they then have.
01:47:18 <dmwit> Snark: (If it helps, I'm using "b" as a mnemonic for "beginning" and "e" as a mnemonic for "end".)
01:47:25 <dons> what more mental tools would they have for thinking about programming
01:47:26 <therp> dons: would be worth a try
01:47:35 <dmwit> s/"\./."/ # stupid English
01:47:50 <solrize> yeah, that makes sense, though monadic i/o has to be dealt with
01:47:55 <dons> solrize: "A critique of Abelson and Sussman or why calculating is better than scheming"
01:48:04 <dons> '87.
01:48:12 <dons> on why typed FP is better than untyped FP for the kids
01:48:18 <dons> its a good read.
01:48:21 <dons> pre-haskell, of course.
01:48:28 <dmwit> Monadic IO need not be dealt with at all.
01:48:40 <dons> IO's not really taught in first courses.
01:48:50 <solrize> http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf
01:48:54 <dons> the semantics are too awkward :)
01:48:54 <lambdabot> Title: A is 3QD
01:48:58 <solrize> how do you print stuff without monadic i/o?
01:49:02 <dmwit> ghci
01:49:02 <dons> 'show'
01:49:03 <solrize> and what about fixing space leaks?
01:49:06 <dons> what?
01:49:09 <dons> in a first course?
01:49:18 <dons> do you do much teaching, solrize ? :)
01:49:34 <dons> do you debug double-free errors in a first course?
01:49:39 <solrize> well, if you're going to actually calculate stuff... ?
01:50:03 <dons> i don't think it comes up...
01:50:04 <solrize> i spent a couple hours trying to code euler 14 in haskell tonight and couldn't get it to stop overflowing the stack
01:50:14 <solrize> any high school kid could do it in basic in 15 minutes
01:50:19 <dons> solrize: 1?
01:50:21 <dons> !!?
01:50:33 <dons> you couldn't write the haskell version, but you could a basic version?
01:50:42 <solrize> wait not 14
01:50:44 <dons> seems like time for a tutorial then. something fundamental missing.
01:51:04 <solrize> dons, yes, the problem is to find f(1 million) for a certain f
01:51:07 <dons> for example: write the basic version and explain why the haskell version isn't equivalent.
01:51:10 <solrize> it is trivial to write f in haskell or basic
01:51:17 <solrize> the haskell version finds f(10000) just fine
01:51:19 <solrize> but has a space leak
01:51:23 <solrize> so it cant find f(1 million)
01:51:50 <dons> so a) not enough information, b) why did it leak -- i.e. what did you do wrong, and c) did you compile it.
01:52:08 <dons> d) why not translate the basic version into haskell?
01:52:08 <solrize> http://projecteuler.net/index.php?section=problems&id=14
01:52:09 <lambdabot> Title: Problem 14 - Project Euler
01:52:25 <dons> oh, is that collatz?
01:52:26 <solrize> you mean write it imperatively with the state monad?  i guess i could try that
01:52:35 <dons> that's trivial to solve with recursion, iirc.
01:52:45 <dons> we do it every week in #haskell :)
01:52:56 <solrize> i wrote it in the obvious way with haskell and then spent a long while dorking with strictness annotations, recursion etc
01:53:02 <papermachine> There shouldn't be a space leak
01:53:02 <dons> yeah, don't dork around.
01:53:04 <solrize> worst of all i've done that problem at least once before
01:53:17 <papermachine> I did that problem in Haskell a couple months ago and I don't understand strictness annotations
01:53:20 <Snark> dmwit, the "let (b,e) = " escaped me -- now I see how it works : thanks !
01:53:37 <Taejo> > let {f n | even n = n `div` 2; f n = 3*n+1} in f 1000000
01:53:38 <lambdabot>   500000
01:53:50 <dons> seriously.
01:53:52 <Taejo> @let {f n | even n = n `div` 2; f n = 3*n+1}
01:53:52 <lambdabot>  <local>:11:0: parse error on input `{'
01:54:02 <dmwit> no ;
01:54:15 <dmwit> ?let f n | even n = n `div` 2 | otherwise = 3 * n + 1
01:54:16 <lambdabot>  Defined.
01:54:16 <dons> http://hpaste.org/2107
01:54:32 <dons> i'm trying to find the stream fusion version...
01:55:04 <dons> ah,
01:55:20 <dons> http://hpaste.org/7461#a1
01:55:37 <Snark> dmwit, http://pastebin.com/d4cbeb774 <= old new => http://pastebin.com/d517e8476
01:55:47 <dons> solrize: so i guess there's some gap in your understanding of evaluation order, that means you programmed in an unexpected memory behaviour.
01:55:54 <solrize> dons, yes
01:55:55 <dons> we could walk through why that happened if you like
01:55:59 <solrize> ok
01:56:06 <dons> if you had the code somewhere.
01:56:12 <solrize> sec
01:56:19 <solrize> should i paste in that same hpaste?  or start a new one?
01:56:22 <dons> so looks like i wrote collatz as an unfoldr
01:56:26 <dons> a new one
01:56:40 <dmwit> Snark: Looks like you have a bug.
01:56:55 <solrize> i think if i tried enough different approaches something would work, but i wrote it in a natural way and wanted to preserve the naturalness
01:57:00 <dmwit> Snark: Unless you always know your first line will be "Backtrace:"...?
01:57:35 <Snark> dmwit, it's supposed to
01:57:43 <dmwit> okey-dokey!
01:57:53 <solrize> http://hpaste.org/12061
01:58:00 <solrize> i think my first attempt was like that
01:58:01 <dmwit> Snark: Now you just have to decide which you like better. =)
01:58:06 <Snark> though I should probably protect myself with something like stream@("Backtrace:" : _)
01:58:14 <solrize> but i may have broken it by cleaning up some other stuff i tried
01:58:17 <Snark> then a catch-all
01:58:32 <dons> looking, solrize
01:58:36 <dmwit> Snark: It's simpler just to drop 1 in the recursive call, I think.
01:59:14 <dons> oh, some missing functions there.
01:59:16 <dons> it doesn't compile
01:59:22 <solrize> oh sorry, import data.list
01:59:33 <solrize> lemme try to get it to compile
01:59:39 <dons> always included imports in pastes. every paste should be type correct :)
01:59:59 <solrize> yeah, i had a bunch of extra junk in the file that i didn't paste, let me try again
02:00:12 <Snark> dmwit, dropping the "drop 1" leads to an infinite list of []....
02:00:35 <dmwit> Snark: Right, you need the drop 1, but I think it should be moved to the recursive call.
02:00:47 <dmwit> Snark: i.e. bt : chunky s (drop 1 rest)
02:01:10 <dmwit> Snark: Since you *know* (by virtue of having called break) that the first element of rest is s.
02:01:56 <solrize> http://hpaste.org/12061#a1
02:01:58 <solrize> this one works
02:02:06 <Snark> dmead, hmm...
02:02:16 <zeno> whats a good linux distro for haskell dev (preferr rolling release, up-to-date haskell packages), in vbox so dont care about other stuff
02:02:36 <solrize> zeno around here i think the answer is usually arch
02:02:51 <zeno> ok, thx
02:02:56 <dons> zeno: rolling release + up to date, probably means only Arch I think?
02:03:00 <dons> is gentoo a rolling release?
02:03:05 <Snark> s/dmead/dmwit/
02:03:07 <dons> (its up-to-date also)
02:03:08 <zeno> i think gentoo is
02:03:20 <irm> It should be.
02:03:21 <dons> ?go what's a good linux for haskell
02:03:25 <lambdabot> http://www.haskell.org/haskellwiki/Implementations
02:03:25 <lambdabot> Title: Implementations - HaskellWiki
02:03:28 <Snark> dmwit, it gives me a [] at the beginning of the result in that case
02:03:29 <dons> ?go what's a good linux for haskell arch?
02:03:31 <lambdabot> http://archhaskell.wordpress.com/
02:03:31 <lambdabot> Title: Arch Linux and Haskell
02:03:33 <dons> yes.
02:03:34 <dons> hehe
02:03:39 <zeno> im just sick of ubuntu, haskell stuff so out-of-date
02:03:46 <dons> oh for sure. blame debian.
02:03:48 <irm> zeno: It is?
02:03:58 <dmwit> Snark: Mmm, yeah, it will tend to drop []'s in there for "empty" backtraces.
02:04:04 <dmwit> Snark: You can filter them out if you like.
02:04:15 <dmwit> :t filter (not . null)
02:04:17 <lambdabot> forall a. [[a]] -> [[a]]
02:04:19 <jeffz> dons, why blame debian?
02:04:21 <mgee_> hi
02:04:27 <dmwit> mgee_: Hiya!
02:04:31 <dons> they supply out of date haskell packages to ubuntu.
02:04:34 <zeno> irm: well not exteremely, but 6.8.2 (i think 3 is recent) on 8.10
02:04:47 <dmwit> zeno: 6.10 is recent
02:04:47 <jeffz> dons, is that because there is no maintainer?
02:04:58 <Snark> dmwit, ok
02:05:07 <irm> zeno: You can change that in your sources.list, I expect
02:05:08 <dons> solrize: doesn't have a space leak.
02:05:14 <dons> $ time ./A 1000000
02:05:14 <dons> (837799,524)
02:05:14 <dons> ./A 1000000  12.59s user 0.05s system 99% cpu 12.673 total
02:05:18 <dons> seems to run in constant space.
02:05:22 <zeno> dmwit: ah big version change wonder whats new (googles :)
02:05:24 <Snark> dmwit, perfect !
02:05:41 <solrize> Stack space overflow: current size 8388608 bytes.
02:05:41 <solrize> Use `+RTS -Ksize' to increase it.
02:05:52 <dons> solrize: are you running in ghci?
02:05:54 <mgee_> I need the Shellac-editline package, but building it fails. I installed the editline development packages (I am using ubuntu), but I get a compile error: http://hpaste.org/12062
02:05:55 <dons> or did you compile it?
02:05:56 <Snark> dmwit, though I'm not 100% sure it's that much more elegant than what I did :-/
02:06:08 <mgee_> can anyone help me
02:06:08 <dmwit> Snark: As I said... the only decision left, etc, etc. =)
02:06:11 <solrize> i get that with runhaskell and with unoptimized ghc
02:06:14 <dons> right.
02:06:19 <dons> so you're relying on some strictness analysis
02:06:34 <dons> try, $ ghc -O2 --make A.hs
02:06:45 <dons> $ time ./A 1000000
02:06:45 <dons> (837799,524)
02:06:45 <dons> ./A 1000000  12.51s user 0.03s system 99% cpu 12.573 total
02:07:11 <solrize> yeah, that works, but i shouldn't have to rely on that, i want to be able to write code that pins down the execution semantics enough to not have leaks without leaving it up to the compiler
02:07:31 <dons> right. you now know though that you have a true space leak, caught by strictness analysis
02:07:41 <dons> so it should be simple to explicitly state where you relied on strict evaluation
02:07:41 <solrize> right
02:08:05 <dons> so the compiler showed up where you've not stated precisely which evaluation order you desire.
02:08:09 <dons> can you find that point?
02:08:20 <solrize> that's not so easy to find, the heap profile was not that useful and the core listing was too messy to read
02:08:55 <dons> runhaskell runs it in ghci though.
02:09:03 <dons> so you compiled without optimisations?
02:09:09 <solrize> but, collatz0 does a lot of allocation so i did a bunch of stuff to try to strictify it
02:09:17 <solrize> yes, compiled without optimizations and used heap profiling
02:09:28 <mgee_> so nobody knows how to fix it? :(
02:09:37 <dons> collatz0 just allocates integers.
02:10:04 <dmwit> mgee_: What does the code near that error look like?
02:10:20 <dmwit> mgee_: Maybe just paste the whole file to hpaste.org.
02:10:28 <mgee_>   , readHistory                      = \_ -> EL.readHistory
02:10:28 <dons> ghc generates pretty good code, considering all those Integers
02:10:28 <solrize> iterate collatz0 makes a big chain of thunks
02:10:30 <solrize> i guess
02:10:45 <dons> solrize: so anyway, your original complaint was kinda false, right? all you needed to do was ghc -O2
02:10:47 <dmwit> mgee_: We're gonna need a whole lot more context than that.
02:10:49 <solrize> anyway i got rid of that and used explicit recursion
02:10:57 <dons> we have smarter compilers to make this higher level programming easier.
02:11:20 <dons> so just as your basic program worked in 15 mins, so your haskell one does too. since our compiler is smarter than you are at strictness analysis
02:11:20 <solrize> dons no the complaint is valid, the program has ill-defined behavior that some compiler settings happen to get right
02:11:22 <askentasken> is there no scripting language hat has static typing<?
02:11:38 <dons> solrize: well, not 'happen to', it actually does infer the strictness better than you're able to.
02:11:41 <dons> meaning your program works.
02:11:49 <askentasken> man i really wish Python had sometimes. im doing image processing and the larger the project grows the more static i wish it was
02:12:03 <dons> solrize: of course, the space behaviour is something you might also want to control
02:12:09 <solrize> askentasken, yeah, untyped languages just start to feel juvenile after using haskell for a while
02:12:10 <dmwit> askentasken: Time to make a Haskell binding for GEGL. ;-)
02:12:13 <dons> but the compiler lets you defer thinking about that if you don't need to
02:12:16 <askentasken> GEGL?
02:12:22 <dmwit> ?go gegl image processing
02:12:25 <dons> which in this case, you wouldn't actually have to, since your goal was to solve euler problems quickly
02:12:30 <dons> so turn up -O2
02:12:32 <lambdabot> http://gegl.org/
02:13:18 <C-Keen> hm if I have a function f:: a->b->c, and I want to do f $ g $ a b how do I return b and c for f in g? As I understand I should return a function b->c right?
02:13:24 <solrize> i don't think my goal was to solve euler problems quickly, it was to write fluent haskell code that did the right thing, which includes having the right space behavior
02:13:54 <dons> well, if you care about stating space behaviour too, then that's some extra burden you're adding to your effort.
02:14:01 <dmwit> C-Keen: f doesn't return b and c; it returns a function from b to c.
02:14:20 <solrize> a program with undefined space behavior is an incorrect program
02:14:21 <dmwit> C-Keen: If it returned two values of types b and c, its type would end in ... -> (b, c)
02:14:25 <dons> you want to state your strictness or laziness explicitly.
02:14:30 <C-Keen> dmwit: ok
02:14:44 <mgee_> dmwit, ah no matter. i figured out that I only need Shellac-compatline. thanks anyway for your help :)
02:15:25 <solrize> well if i can get the necessary strictness by putting in a few annotations here and there, that's one thing
02:15:40 <dons> well, you should also add type annotations if you're in this mood
02:15:56 <solrize> yes i had some type annotations, didn't include them in the paste
02:16:01 <dons> state everything, or let the compiler do the work
02:16:22 <dons> you're letting it infer types and strictness, which, if you've time, you can go back and put in explicitly.
02:16:34 <dons> knowing how to do mental strictness anlayis takes time to learn though
02:16:51 <solrize> well in principle i know how type inference works, there's an explicit algorithm for it
02:16:59 <solrize> so i'd say that isn't the same
02:17:18 <dons> you don't have the strictness analyzer in your head too, in principle?
02:17:29 <C-Keen> dmwit: how do I return a function that does b->c then?
02:17:49 <solrize> no, there is nothing in the language specification that says what the strictness analyzer is supposed to do
02:17:51 <dmwit> C-Keen: Well, you have two options.
02:18:10 <dons> yeah. frustrating.
02:18:14 <dmwit> C-Keen: The simplest is to just add an argument to the definition of f that binds the input of type b.
02:18:32 <dmwit> :t let f a b = 3 in f
02:18:33 <lambdabot> forall t t1 t2. (Num t2) => t -> t1 -> t2
02:19:05 <dmwit> C-Keen: The other option is of course to just build a function in any of your favorite ways: partial application, lambda abstraction, etc.
02:19:17 <dmwit> > let f a = const 3 in f
02:19:18 <lambdabot>       Overlapping instances for Show (t1 -> b -> t)
02:19:18 <lambdabot>        arising from a use...
02:19:24 <dmwit> :t let f a = const 3 in f
02:19:25 <lambdabot> forall t b t1. (Num t1) => t -> b -> t1
02:19:38 <dmwit> :t let f a = \b -> 3 in f
02:19:40 <lambdabot> forall t t1 t2. (Num t2) => t -> t1 -> t2
02:19:48 <solrize> i read SPJ's book about graph reduction a long time ago without which i'd have no idea what was going on
02:20:07 <C-Keen> dmwit: oh, I guess I just head a knot in my brains
02:20:50 <dons> yeah, if you want to state evaluation order behaviour, you should have to understand evaluation order
02:21:14 <solrize> right, this is what makes me say haskell is difficult
02:22:20 <dons> use -O2 and move on. :)
02:22:27 <solrize> :)
02:22:35 <dons> i've been arguing for a few months that -fstrictness should be the default in ghci
02:22:48 <solrize> i've hit some other things like that which -O2 doesn't fix
02:22:50 <dons> so kids stop complaining about dumb stack overflows the analyzer can catch with its eyes closed.
02:23:04 <dons> sure. sometimes you really need to understand your code
02:23:59 <solrize> really though, if the language semantics permit these stack overflows then it's an unsafe language.  i had the idea a while back of connecting up quickcheck to the heap profiler to allow writing properties about space complexity but i don't see any more solid approach than that
02:24:19 <dons> stating laziness properties is a start
02:24:28 <dons> duncan and i have a half-done paper idea for that
02:24:37 <solrize> hmm, not sure what you mean
02:24:47 <Taejo> dons: how slow is the strictness analyzer? is there a high-level profile of compilation phases somewhere?
02:24:59 <dons> Taejo: its not too bad.
02:25:09 <dons> the simplifier/rewrite engine is way slower
02:25:46 <solrize> do you know anything about clean?  is the situation with that language similar?  it's specified in terms of graph rewriting instead of lambda calculus
02:26:04 <dons> i don't know if people write enough software in Clean to know :)
02:26:07 <solrize> :)
02:27:34 <solrize> i've been reading about spark ada, which is really obsessed with the idea that programs are never allowed to crash.  it doesn't even have anything like malloc, all memory allocation has to be completely static.  the compiler (written in itself) comes in multiple versions, for different maximum input program sizes.
02:28:07 <Taejo> solrize: gross
02:28:41 <solrize> taejo, yeah, i think it's ok if a compiler has a theoretical possibility of crashing, unlike a realtime control program
02:28:56 <solrize> i.e. haskell would be a good language to compile spark ada with
02:29:37 <dons> total functional programming ftw.
02:30:09 <solrize> hehe
02:30:56 <solrize> but, even that does nothing to control space complexity
02:33:30 <solrize> i think i'm more angsty about these correctness issues than most programmers and that's making haskell harder for me.
02:35:58 <solrize> iterate' f !x = x:(iterate' f x)
02:36:01 <solrize> didn't help
02:43:54 <sjanssen> solrize: I hope you mean iterate' f !x = x : iterate' f (f x)?
02:45:04 <czakey> @bot
02:45:04 <lambdabot> :)
02:45:07 <mmorrow> printf with TH http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=484
02:45:18 <mmorrow> notypeclasshackery++
02:47:20 <solrize> sjanssen heh, right, thanks :)
02:48:26 <solrize> but, still overflows the stack, i thought that collatz0 was making thunks and that the !x should get rid of them
02:49:40 <solrize> i remember someone explaining that x `seq` x never does what it looks like
02:50:55 <ziman> > let x = foldr (:) [] [1..2] in x `seq` x
02:50:56 <lambdabot>   [1,2]
02:51:11 <sjanssen> solrize: x `seq` x is the same as x
02:51:24 <solrize> > undefined `seq` undefined
02:51:25 <lambdabot>   * Exception: Prelude.undefined
02:51:32 <solrize> > undefined `seq` 3
02:51:33 <lambdabot>   * Exception: Prelude.undefined
02:52:21 <solrize> sjanssen, yeah, x `seq` x doesn't actually evaluate x
02:52:31 <solrize> > [1,2,3,undefined]
02:52:32 <lambdabot>   [1,2,3,* Exception: Prelude.undefined
02:53:13 <solrize> let a = [1,2,3,undefined] in a `seq` (length a)
02:53:18 <solrize> > let a = [1,2,3,undefined] in a `seq` (length a)
02:53:19 <lambdabot>   4
02:53:43 <Beelsebob> note that seq there only evaluates the first cons cell of the list
02:54:15 <mmorrow> > error "sdaqf" `seq` undefined
02:54:16 <lambdabot>   * Exception: sdaqf
02:54:17 <solrize> beelsebob, right, that just seems crufty, seq isn't really strict
02:54:23 <sjanssen> seq never evaluates something on its own
02:54:25 <Beelsebob> solrize: yes it is
02:54:45 <Beelsebob> seq is strict in its first argument -- whether it's first argument is strict in its arguments is a different matter
02:55:13 <mmorrow> it guarantees the lhs will be evaluated before the rhs
02:55:20 <sjanssen> and whether the expression containing the seq is ever evaluated is yet another thing
02:55:26 <mmorrow> yeah
02:55:27 <solrize> well i thought that strict meant that f(bottom)=bottom
02:55:34 <Beelsebob> yes
02:55:42 <Beelsebob> and seq _|_ x = _|_
02:55:43 <mmorrow> > snd (undefined `seq` undefined, 42)
02:55:44 <lambdabot>   42
02:56:21 <solrize> that length [1,2,3,undefined] is not bottom reflects haskell's non-strictness
02:56:28 <Beelsebob> solrize: note that (_|_ : _|_) /= _|_
02:56:48 <Beelsebob> nor does (1 : 2 : 3 : _|_)
02:57:47 <Deewiant> > let x = undefined:undefined in seq x 1
02:57:49 <lambdabot>   1
02:58:32 <solrize> hmm
02:58:33 <luite> > length [undefined,undefined,undefined]
02:58:35 <lambdabot>   3
03:00:09 <mmorrow> seq only can reach down one level
03:00:20 <mmorrow> just like bang patterns
03:00:30 <solrize> mmorrow yes
03:00:43 <mmorrow> Control.Parallel.Strategies.rnf otoh..
03:00:52 <solrize> yeah i tried that too
03:01:13 * Beelsebob wonders why there's always so much talk about making things strict in here
03:01:29 <Beelsebob> 99% of times I've had an efficiency issue, it's been because I've not been being lazy enough
03:01:34 <solrize> probably due to an interest in having one's programs not crash
03:01:35 <sjanssen> solrize: are you sure the expression containing the seqs or rnfs is itself evaluated?
03:02:10 <solrize> sjanssen, not sure, i never managed to put in enough seqs to make the space leak go away
03:02:22 <mmorrow> , snd (rnf undefined, 42) `seq` ()
03:02:27 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
03:02:29 <solrize> there was another time i coded the same problem quite a bit differently and that had no leaks
03:02:41 <mmorrow> , snd (rnf (undefined::Tree (Either (Maybe String) Int, 42) `seq` ()
03:02:43 <lunabot>  luna: parse error (possibly incorrect indentation)
03:02:49 <mmorrow> , snd (rnf (undefined::Tree (Either (Maybe String) Int), 42) `seq` ()
03:02:50 <lunabot>  luna: parse error (possibly incorrect indentation)
03:02:53 <mmorrow> grrgr
03:03:02 <mmorrow> , snd (rnf (undefined::Tree (Either (Maybe String) Int)), 42) `seq` ()
03:03:05 <lunabot>  ()
03:03:10 <mmorrow> , fst (rnf (undefined::Tree (Either (Maybe String) Int)), 42) `seq` ()
03:03:13 <lunabot>  luna: Prelude.undefined
03:04:18 <sjanssen> solrize: if you're not sure of that, you probably need to step back and think about the program a bit more
03:04:21 <sjanssen> is the program large?
03:04:28 <solrize> no
03:04:42 <solrize> it's the collatz example from earlier
03:05:09 <solrize> http://hpaste.org/12061#a1
03:06:00 <sjanssen> the title is "this one works", is that correct?
03:06:10 <Beelsebob> solrize: so, what's the bug exactly -- it memory leaks?
03:06:11 <solrize> it "works" in the sense of computing the right value for small n
03:06:16 <solrize> but it leaks memory
03:06:40 <sjanssen> @src maximumBy
03:06:41 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:06:51 <solrize> that's in data.list
03:06:55 <sjanssen> solrize: maximumBy is probably your leaker
03:06:56 <solrize> or data.ord
03:07:03 <solrize> hmmm
03:07:12 <C-Keen> @hoogle maximumBy
03:07:12 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
03:07:12 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
03:07:18 <Beelsebob> @src maximumBy
03:07:18 <lambdabot> Source not found. Just try something else.
03:07:22 <Beelsebob> bah
03:07:33 <solrize> :t maxBy
03:07:34 <lambdabot> Not in scope: `maxBy'
03:07:40 <solrize> @hoogle maxby
03:07:40 <lambdabot> No results found
03:07:42 <sjanssen> yep
03:07:42 <Beelsebob> I bet that's written in terms of foldl, not foldl'
03:07:44 <sjanssen> maximumBy cmp xs        =  foldl1 max xs
03:07:48 <C-Keen> @src Data.List.maximumBy
03:07:48 <lambdabot> Source not found. :(
03:08:00 <C-Keen> @src Data.Foldable.maximumBy
03:08:00 <lambdabot> Source not found. My brain just exploded
03:08:15 <C-Keen> oh well
03:08:20 <solrize> hmm lemme see if i can rewrite it with foldr
03:08:31 <sjanssen> solrize: foldr will stack overflow also
03:08:33 <sjanssen> use foldl'
03:08:42 <Beelsebob> indeed
03:08:52 <solrize> foldl' will construct a million element list in memory
03:08:59 <sjanssen> no, it won't
03:08:59 <Beelsebob> no it won't
03:09:08 <sjanssen> Beelsebob: high five!
03:09:12 <Beelsebob> foldl' will get the first two elements, and strictly compare them
03:09:20 <Beelsebob> then it'll get another element, and strictly compare it
03:09:21 <Beelsebob> etc
03:09:31 * Beelsebob smacks sjanssen's hand
03:09:44 <solrize> neat!   i didn't know that, i thought it made the whole list
03:09:58 <Beelsebob> nope -- that's kinda the point of foldl'
03:10:08 <solrize> :t max
03:10:09 <lambdabot> forall a. (Ord a) => a -> a -> a
03:10:12 <Beelsebob> foldl makes the entire 'list' as a big closure
03:10:15 <sjanssen> solrize: the strictness in foldl' is in the accumulator, it isn't hyper-strict in the list
03:10:21 <Beelsebob> foldl' does the folding as it goes along
03:11:01 <sjanssen> solrize: the max in my paste is a where bound function in maximumBy
03:11:15 <sjanssen> just returns the larger element according to the supplied comparison function
03:11:18 <solrize> which paste?
03:11:56 <sjanssen> solrize: the body of maximumBy I pasted in channel, I thought you were looking at that
03:12:06 <solrize> oh yes i saw that
03:12:20 <sjanssen> just wanted to point out that it isn't Prelude.max
03:13:01 <solrize> data.foldable.max exists and is different?  gack
03:13:14 <Beelsebob> no
03:13:19 <Beelsebob> max is defined in a where clause
03:14:18 <solrize> @src data.foldable.maximumBy
03:14:18 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:14:29 <solrize> @src Data.List.maximumBy
03:14:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:14:59 <solrize> oh i see, you pasted from someplace external
03:17:08 <Taejo> @hoogle Int -> String
03:17:09 <lambdabot> Language.Haskell.TH tupleDataName :: Int -> Name
03:17:09 <lambdabot> Language.Haskell.TH tupleTypeName :: Int -> Name
03:17:09 <lambdabot> Language.Haskell.TH.Syntax tupleDataName :: Int -> Name
03:17:18 <Taejo> @hoogle a -> String
03:17:18 <lambdabot> Distribution.Text display :: Text a => a -> String
03:17:18 <lambdabot> Prelude show :: Show a => a -> String
03:17:18 <lambdabot> Text.Show show :: Show a => a -> String
03:17:29 <solrize> main = do
03:17:29 <solrize>   n <- liftM (read . head) getArgs  -- read n from command line
03:17:29 <solrize>   print (foldl1' (maxBy snd) (cs n))
03:17:29 <solrize>       where
03:17:29 <solrize>         maxBy f a b = if (f a) > (f b) then a else b
03:17:33 <solrize> still leak
03:18:27 <solrize> max `on` snd
03:18:51 <Beelsebob> get heap profining then
03:19:03 <Beelsebob> what does it say is taking up all the space if you use +RTS -hC?
03:19:32 <solrize> iirc, collatz0 was allocaitng the most
03:20:17 <Beelsebob> hmm, it may be length that is the leak then
03:20:23 <solrize> looking at profile
03:21:05 <Beelsebob> not discarding collatz's results until the whole list is computed
03:21:28 <Beelsebob> in fact -- that makes sense -- if you made itterate strict, it will do that
03:21:42 <solrize> that would be on the heap, and the lists are never that terribly long
03:21:56 <sjanssen> Beelsebob: length won't leak, because collatz uses takeWhile
03:22:51 <thomashartman1> can someone help me with (I think) a cabal install issue? http://groups.google.com/group/fa.haskell/browse_thread/thread/c39dca259a9489ef#
03:22:53 <lambdabot> Title: cabal install HaXml installs wrong version unless I specify the version number - ..., http://tinyurl.com/5cxfmt
03:25:04 <thomashartman1> Is there a way to specify package version in the build-depends field in a cabal file?
03:25:22 <sjanssen> thomashartman1: yes, the usual range operators are allowed
03:25:59 <sjanssen> thomashartman1: if xml-parsec requires a certain version of haxml, it ought to say so in the .cabal file
03:26:16 <sjanssen> solrize: can you paste the full code of your current working version?
03:26:23 <solrize> sec
03:28:56 <solrize> http://hpaste.org/12061#a4
03:29:01 <solrize> this one seems to not leak
03:30:40 <solrize> hmm, it might be looping?
03:31:16 <solrize> just took a while
03:31:28 <sjanssen> solrize: the strict iterate is not necessary
03:31:46 <sjanssen> it looks like your only problem was maximumBy
03:31:59 <solrize> thanks, i was looking way in the wrong place
03:33:05 <solrize> it's 4.5x faster with -O2
03:33:45 <solrize> the strict iterate speeds it up slightly
03:34:08 <Beelsebob> yes, -O2 does a lot of shinies
03:34:53 <sjanssen> solrize: if you want real speed, you'll need to get rid of the collatz list
03:35:15 <Beelsebob> yeh, there's a lot of unnecessary allocation there
03:35:27 <Beelsebob> just keep a counter as you step along
03:35:53 <solrize> well i wanted to write naturally
03:36:10 <Beelsebob> yep, but you could write a countWhile function
03:36:14 <solrize> i like the current version except i wish that maximumBy' was part of the library
03:36:18 <Beelsebob> which repeatedly applies and increments a counter
03:36:49 <solrize> yeah maybe
03:37:28 <solrize> well, i gotta get some sleep, thanks everyone
03:37:50 <sjanssen> http://hpaste.org/12061#a5 will be a bit faster, but still does excess allocation
03:38:30 <Scriper> Hello ALL any guy here which unterstand german?
03:38:32 <sjanssen> you might also try stream fusion, which can fuse iterate, takeWhile, and length
03:38:50 <sjanssen> Scriper: you might want to try #haskell.de
03:38:58 <Scriper> there ist just the bot^
03:39:17 <Scriper> i got a problem with a haskell programm
03:39:52 <solrize> scriper go ahead and ask
03:40:04 <Scriper> well ok my task is
03:40:16 <Scriper> to rotate a bitmap for 90°
03:40:18 <solrize> sjanssen you mean with uvec or something like that?  (for stream fusion)
03:40:33 <sjanssen> solrize: there is a stream fusion list package too
03:40:37 <thomashartman1> Scriper: ich spreche deutsch.
03:40:39 <solrize> oh neat
03:40:50 <Scriper> bist du gut in haskell?^^
03:40:59 <Scriper> bruache drigend hilfe
03:41:08 <thomashartman1> haengt davon ab :)
03:41:10 <sjanssen> thomashartman1, Scriper I hate to be a stickler, but #haskell should use English
03:41:16 <thomashartman1> he's right.
03:41:18 <Scriper> sery
03:41:20 <jpcooper> STICKLER
03:41:21 <Scriper> sry
03:41:24 <Beelsebob> Scriper: flip . transpose?
03:41:32 <sjanssen> but we do have #haskell.de for you all to use! :)
03:41:35 <Beelsebob> (not haskell flip though)
03:41:43 <solrize> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stream-fusion
03:41:45 <lambdabot> Title: HackageDB: stream-fusion-0.1.2.1, http://tinyurl.com/38larw
03:41:48 <thomashartman1> scriper: I'll join #haskell.de if ya want to keep everyone else happy
03:42:03 <thomashartman1> I've never been on haskell.de but if it's a low volume channel I understand why scriper might want to come here.
03:42:08 <solrize> looks like i have to download that from hackage and i'm too sleepy
03:42:29 <thomashartman1> solrize: cabal install is easy right?
03:42:34 <solrize> i think i'm satisfied with this for now.  i'd like to have a better idea of how to locate problems like that though
03:42:39 <solrize> i never got cabal install working
03:42:51 <thomashartman1> solrize: ghc --version ?
03:42:53 <solrize> i could try again but not now
03:43:01 <solrize> 6.8.2
03:43:20 <thomashartman1> solrize: I think that's a bum version
03:43:21 <solrize> one problem is that i don't have root on the box i was using it on
03:43:34 <solrize> yeah i should get 6.10 since i want to try the parallel stuff
03:43:34 <mmorrow> looks cool http://metalua.luaforge.net/
03:43:35 <lambdabot> Title: Metalua
03:43:42 <mmorrow> http://metalua.luaforge.net/quicktour.html
03:43:43 <lambdabot> Title: Quick tour
03:43:44 <thomashartman1> the odd numbers are supposed to be stable iirc
03:44:08 <thomashartman1> sjannsen: thanks for your help, I answered my post on haskell cafe.
03:44:22 <thomashartman1> I still think there's a bug in cabal install, but I was able to install the package I wanted.
03:44:31 <solrize> lua seems ugly, too much type coercion
03:44:53 <thomashartman1> solrize: not sure what to do about the root issue, but there's a trick with cabal install, download the latest tar from hackage and then run bash bootstrap.sh
03:45:07 <thomashartman1> otherwise you're right, it's a pain. but bootstrap works great.
03:45:10 <solrize> i'll mess wtih it some other time, it's 0347 here i really should sleep
03:45:32 <thomashartman1> ON ghc 6.10.1, I was able to install cabal install as non-root but I suspect eventually I'll need root after all.
03:45:37 <thomashartman1> solrize: get some sleep man.
03:46:00 <sjanssen> thomashartman1: GHC/Cabal should work smoothly without root
03:46:02 <solrize> nytol
03:46:09 <jpcooper> solrize, are you 2 minutes in the future or something?
03:46:26 <sjanssen> @localtime solrize
03:46:26 <lambdabot> Local time for solrize is Sat Nov 15 03:49:31
03:46:32 <solrize> maybe system clock is off a little ok
03:46:44 <solrize> nite.... zzz :)
03:51:43 <mmorrow> this is friggin awesome. something like template-haskell + QuasiQuotes for lua http://metalua.luaforge.net/metalua-manual.html
03:51:44 <lambdabot> Title: Metalua Manual
03:52:58 <mmorrow> mostly it's awesome, because that's the manual that template-haskell + QuasiQuotes doesn't have, and by pretending their talking about haskell code it almost could be
03:53:07 <mmorrow> *they're
03:54:41 <flux> :)
03:54:46 <mmorrow> (modulo haskell's type system, etc.../but/ that manual mentions an extension which implems (a) nontrivial typesystem(s)
03:54:48 <mmorrow> )
03:54:49 <lunabotjs>  jseval: <stdin>: hGetLine: end of file
03:54:52 <mmorrow> heh
03:57:21 <mmorrow> ) (function(f,xs){var ys=new Array(xs.length); for(var i=0;i<ys.length;i++) ys[i]=f(xs[i]); return(ys)})(function(x){return(x*2)},[0,1,2,3,4,5,6,7,8,9])
03:57:22 <lunabotjs>  syntax error.
03:58:19 <mmorrow> ) (function(f,xs){var ys=new Array(xs.length); for(var i=0;i<ys.length;i++) {ys[i]=f(xs[i])}; return(ys)})(function(x){return(x*2)},[0,1,2,3,4,5,6,7,8,9])
03:58:19 <lunabotjs>  syntax error.
03:58:23 <mmorrow> liar!
04:04:24 <mmorrow> ) map = function(f,xs){var ys=new Array(xs.length); for(var i=0;i<ys.length;i++) {ys[i]=f(xs[i])} return(ys)}; x = map(function(x){return(x*2)},[0,1,2,3,4,5,6,7,8,9])
04:04:25 <lunabotjs>  0,2,4,6,8,10,12,14,16,18
04:06:12 <gwern> mmorrow: why is there a javascript bot here?
04:06:51 <RayNbow> @seen twanvl
04:06:52 <lambdabot> I saw twanvl leaving #haskell, #haskell-blah, #haskell.dut and #ghc 10h 51m 14s ago, and .
04:06:58 <mmorrow> gwern: lunabotjs is running on my laptop until i can figure out how to not have the spidermonkey jsapi evaluator not segfault on lunabot's machine
04:07:24 <mmorrow> *not have the .... (not) not segfault
04:07:40 <gwern> that explains why you're running it, but that's not what I asked
04:07:46 <mmorrow> lunabot's running on a hosted server
04:08:34 <mmorrow> oh, because i managed to hack this out and figured i'd botify it: http://moonpatio.com/repos/mm-js/
04:08:35 <lambdabot> Title: Index of /repos/mm-js
04:08:52 <mmorrow> that darcs repo'll set you up with the identical evaluator that's in lunabotjs
04:09:18 <mmorrow> it's not much mind you
04:09:27 * gwern wonders what mm_js.c does that haskell couldn't
04:10:05 <mmorrow> gwern: hooks into the spidermonkey entirely-in-c js runtime/interp/parser :)
04:10:30 <gwern> what ingratitude! does not haskell have a lovely ffi for people like you?
04:10:31 <mmorrow> so the answer is nothing ;)
04:10:55 <gwern> despair! despair! this world of ungrateful haskellers has cast me into despair!
04:10:59 * gwern goes and hangs self
04:11:23 <mmorrow> gwern: heh, i thought about it and i figure it'd be just as well to write a pure haskell interp as it would be to ffi to spidermonkeyt
04:11:32 <mmorrow> there's already hjs
04:11:47 <mmorrow> so it's even been done before
04:12:26 <mmorrow> then you wouldn't have to worry about random segfaults and having to enable thread safety with a flag to ./configure
04:13:02 <mmorrow> gwern, are you dead?
04:13:26 * gwern twitches a little. dead men can't speak
04:13:42 * mmorrow pokes gwern with a stick
04:15:11 <jpcooper> does anyone here code on a really small screen?
04:15:21 <mmorrow> 1024x768 baby
04:15:28 <jpcooper> yeah, I've got that at 14.1 inches
04:15:43 <mmorrow> i've got an x60
04:15:47 <jpcooper> T60 here
04:15:49 <mmorrow> i think it's prob about that
04:15:52 <jpcooper> it's just unbearable
04:15:52 <mmorrow> ah
04:16:12 <mmorrow> heh, sometimes i realize how small it really is
04:16:38 <jpcooper> when I worked this summer, I had a lovely 21-inch wide screen
04:16:43 <mmorrow> other times i don't notice. the key is to never use a larger display
04:16:50 <mmorrow> BIG mistake
04:17:22 <jpcooper> yes, it's funny to notice that effort is required to move one's eyes with a larger screen
04:17:55 * RayNbow reminisces the past when he was really happy with 800x600 on his laptop :p
04:18:02 <mmorrow> code that exceeds 80 cols in width is just unreadable. extremely verbosely spaced C/blah code is excruciating
04:18:27 <jpcooper> having a wide screen was nice for viewing two parts of code at once
04:18:36 <mmorrow> yeah, that too
04:18:47 <jpcooper> my manager had a wide screen that could be flipped to portrait
04:18:48 <mmorrow> man, i need a new laptop
04:18:59 <mmorrow> ooh
04:19:00 <jpcooper> naah, you just need a screen to which to connect it :)
04:19:09 <mmorrow> hmm
04:19:26 <mmorrow> do the new thinkpads of the same size have higher res displays?
04:19:51 <jpcooper> I don't know
04:19:56 <mmorrow> i think i'm hooked on the thinkpads for a while now
04:20:01 <mmorrow> (this is my first)
04:20:38 <mmorrow> hmm, the x300 has Screen: 13.3-inch WXGA+ (1440 x 900, 300 nit) LED backlit display
04:20:46 <jpcooper> I tried an iMac over the summer. I'd love to get one but can't justify it while I already have a thinkpad
04:20:59 <luite> the t61 is available with high res displays (I have the 1920x1200 15.4")
04:21:03 <jpcooper> wow
04:21:27 <Beelsebob> yeh, that's my one problem with apple's laptops -- no option for decent high res screens on them
04:21:39 <Beelsebob> their 15" one is only 1440x900
04:21:49 <jpcooper> only?
04:22:08 <Beelsebob> well, most 15" screens on laptops are 1680x1050, and the high res ones are 1920x1200
04:22:12 <jpcooper> anything to get out o f1024x768
04:22:14 <Beelsebob> so 1440 is fairly lame
04:24:58 <mmorrow> but the x-series fit in your pocket and crush computation simultaneously
04:25:37 <jpcooper> they also crush the bank
04:25:40 <mmorrow> the x300 and x301 appear to have a solid-state hd too
04:25:49 <luite> yeah the x series are quite a bit more 'sexy' than the t, but too expensive for me
04:26:06 <dancor> the man was haskell brooks curry.  when is someone going to call something brooksing
04:26:11 <mmorrow> well, if i was a carpenter i'd have a friggin sweet hammer
04:26:20 <jpcooper> dancor, is that some Markov chain?
04:26:40 <dancor> my yoda-esque utterance?
04:27:07 <dancor> i'll try to use more nested constructs..
04:27:32 <jpcooper> right
04:27:38 * dancor resents being approximatable with tri-grams
04:29:04 <jpcooper> mmorrow, have the keys worn at all on your keyboard?
04:29:44 <mmorrow> you heavily used ones are worn smooth
04:30:12 <mmorrow> it's funny, i can see exactly my keybd use pattern from the degree of wear on diff keys
04:30:26 * mmorrow almost never uses the left shift key
04:30:50 * mmorrow also never uses right ctrl or alt
04:31:13 <luite> I only seem to use the right side of my space bar :)
04:31:49 <mmorrow> i appear to be fairly ambidexterous with space
04:32:52 <mmorrow> s/you heavily/the heavily/
04:32:54 <jpcooper> do I smell a right-hander?
04:32:55 <luite> hm, my left/right ctrl keys are worn about equally, which surprises me as I could swear I only use the left ctrl in emacs
04:33:18 <jpcooper> luite, tried using caps lock as ctrl?
04:34:06 <luite> jpcooper: not yet, but thanks for the suggestion, that may be a bit more comfortable to type
04:34:16 <mmorrow> ooh, brilliant. i never use capslock anyway
04:34:21 * RayNbow doesn't have a right ctrl key :p
04:34:26 <jpcooper> it's much more comfortable
04:35:18 <RayNbow> http://www.scientia.demon.nl/Keyboard.png <-- my keyboard layout :)
04:38:47 <jpcooper> RayNbow, is that a Thinkpad keyboard
04:38:51 <RayNbow> nope
04:38:53 <RayNbow> Toshiba
04:39:10 <RayNbow> a bit dated though
04:39:18 <RayNbow> current Toshiba keyboards are a bit different
04:39:33 <cpfr> hey is there a nice html templating system for haskell
04:39:34 <RayNbow> they have moved the Win key to the lowerleft iirc
04:41:51 <jpcooper> cpfr, I think that there's a combinator based XML library
04:42:11 <cpfr> jpcooper, any idea what its called
04:42:28 <luite> jpcooper: configured caps-lock as ctrl now, I'm still getting used to it, but it looks like a keeper, thanks :)
04:42:37 <jpcooper> good
04:42:55 <jpcooper> what's annoying is when you have to use someone else's keyboard or vice versa
04:43:14 <jpcooper> cpfr, it might be this: http://www.fh-wedel.de/~si/HXmlToolbox/
04:43:20 <lambdabot> Title: Haskell XML Toolbox 8.1.1
04:43:29 <cpfr> thanks jpcooper ill look into it
04:52:10 <jpcooper> does anyone here use the Reader monad frequently?
04:52:27 <cpfr> im not sure when i should be using it
04:53:07 <jpcooper> yes, same here. I've found that it complicates things for me
04:55:14 <RayNbow> > let sq = join (*) in sq 3
04:55:15 <lambdabot>   9
04:55:39 <RayNbow> > (sequence [(+4), (*5)]) 4
04:55:40 <lambdabot>   [8,20]
04:56:23 <scook0> don't know that I've ever used Reader on its own
04:56:29 <scook0> I've used ReaderT a few times though
05:07:25 <dancor> broken link to the paper on http://hackage.haskell.org/packages/archive/mtl/1.1.0.1/doc/html/Control-Monad-Reader.html
05:07:27 <lambdabot> Title: Control.Monad.Reader, http://tinyurl.com/5v9upa
05:07:36 <dancor> otherwise i would recommend looking there for usecases..
05:10:51 <hackage> Uploaded to hackage: xml-parsec 1.0.3
05:21:16 <jpcooper> in GHC 6.8.3 does Data.Map.lookup now only use the Maybe monad?
05:24:50 <Beelsebob> nope
05:24:54 <Beelsebob> any monad
05:25:23 <papermachine> How would one use it with a different Monad?
05:25:35 <papermachine> One that isn't MonadPlus, I mean.
05:25:41 <papermachine> Does it use fail?
05:25:48 <Lemmih> papermachine: It does.
05:25:55 <papermachine> ... fail.
05:29:06 <dancor> @src forever
05:29:06 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:30:21 <dolio> It uses Maybe in 6.10.1
05:31:54 <Beelsebob> that's irritating
05:42:32 <ttt--_> hi, is there a way to make ghci handle #ifdefs ?
05:42:52 <Deewiant> ghci -XCPP?
05:43:21 <ttt--_> yes, thanks!
06:09:03 <beso> does somebody has electronic version of the book: Salomaa: theory of automata
06:10:51 <hackage> Uploaded to hackage: hmatrix 0.5.0.1
06:13:13 <EmielRegis> how to convert floats to chars?
06:13:46 <profmakx> show?
06:14:08 <byorgey> > show 24.2353 -- EmielRegis, like this?
06:14:10 <lambdabot>   "24.2353"
06:14:15 <EmielRegis> ye]
06:14:16 <EmielRegis> danke
06:14:35 <Deewiant> > toEnum . round $ 24.2353 :: Char
06:14:38 <lambdabot>   '\CAN'
06:19:14 <Saya> does a data declaration add much overhead compared to a type if i want to do a Vector3f class for example (like to use in 3D a game) ?
06:21:21 <Saizan_> data Vector3 = V !Double !Double !Double is better than (Double,Double,Double), for example
06:21:58 <dolio> And V {-# UNPACK #-} !Double {-# UNPACK #-} !Double {-# UNPACK #-} !Double is even better.
06:22:18 <Saizan_> or -funbox-strict-fields
06:24:26 <Saya> thanks, so even values like Double are boxed by default
06:26:00 <luite> is there a {- -} directive for funbox-strict-fields?
06:26:15 <Deewiant> {-# GHC_OPTIONS -funbox-strict-fields #-}
06:26:20 <Deewiant> or was it OPTIONS_GHC
06:26:22 <Deewiant> I always forget
06:26:28 <dolio> OPTIONS_GHC
06:26:40 <luite> ah tnx
06:28:11 <EmielRegis> hmm
06:28:20 <EmielRegis> anyone could help me with converting pixels to ppm format?
06:28:39 <EmielRegis> i got a C code which reads printf("%c", red)
06:28:45 <EmielRegis> how to do same in haskell?
06:29:05 <lilac> EmielRegis: can you paste what you've got so far, if anything?
06:30:30 <EmielRegis> http://hpaste.org/12064
06:30:36 <EmielRegis> but this is obviously foul
06:30:41 <EmielRegis> I tried putting simple %d there
06:30:42 <askentasken> is hmatrix fast?
06:30:45 <EmielRegis> but P6 format doesnt read it
06:33:11 <beso> does somebody has electronic version of the book: Salomaa: theory of automata
06:34:10 <chris2> is there always a way to express a foldr with a foldl?
06:34:38 <Saizan_> > printf "%d" 1
06:34:40 <lambdabot>   Add a type signature
06:34:42 <Saizan_> > printf "%d" 1 :: String
06:34:43 <nominolo> chris2: yes, though ineffintly
06:34:44 <profmakx>  would guss so, chris2
06:34:46 <lambdabot>   "1"
06:34:51 <chris2> by creating a building lambda?
06:34:54 <profmakx> the other way round is not possible though
06:35:01 <profmakx> (in general)
06:35:13 <Saizan_> profmakx: sure it is
06:35:21 <profmakx> well.
06:35:24 <nominolo> > :t foldl
06:35:24 <EmielRegis> lwemme rephrase
06:35:25 <lambdabot>   <no location info>: parse error on input `:'
06:35:31 <dolio> Both can be expressed by both, but the strictness of going from foldl to foldr is different.
06:35:32 <EmielRegis> anybody knows how to convert floats into bytecode?
06:35:33 <nominolo> :t foldl
06:35:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:36:12 <profmakx> Saizan_  how to you express a foldr on an infinite list? at least it would not terminate huh?
06:36:16 <Saizan_> EmielRegis: you want the IEEE representation of the Float?
06:36:19 <dolio> So you can't write a foldr that's identical on all inputs to the normal one using foldl in Haskell.
06:36:24 <andun> > (foldr1 const [1..], foldl1 (flip const) [1..])
06:36:42 <lambdabot>   thread killed
06:37:06 <Saizan_> profmakx: the original question was "how to express foldr with foldl" so i understood "other way" to mean "foldl with foldr"
06:37:12 <chris2> thx
06:37:46 <profmakx> i'm being stupid today
06:42:21 <EmielRegis> Saizan_,
06:42:25 <EmielRegis> <EmielRegis> i got a C code which reads printf("%c", red)
06:42:30 <EmielRegis> iw ant something like this...
06:43:02 <dolio> let foldl f z l = foldr (\e g -> g . flip f e) id l z in foldl (flip (:)) [] [1..10]
06:43:09 <dolio> > let foldl f z l = foldr (\e g -> g . flip f e) id l z in foldl (flip (:)) [] [1..10]
06:43:13 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
06:44:01 <beso> does somebody has electronic version of the book: Salomaa: theory of automata
06:44:41 <Saizan_> ?type \f -> show (round f :: Word8)
06:44:43 <lambdabot> forall a. (RealFrac a) => a -> String
06:44:55 <Saizan_> > \f -> show (round f :: Word8) $ 123.22
06:44:56 <lambdabot>   Couldn't match expected type `a -> b'
06:45:01 <dolio> > let foldr f z l = foldl (\g e -> g . f e) id l z in foldr (:) [] [1..10]
06:45:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
06:45:18 <Saizan_> > (\f -> show (round f :: Word8)) 123.22
06:45:18 <lambdabot>   "123"
06:45:36 <dolio> > let foldr f z l = foldl (\g e -> g . f e) id l z in foldr (:) [] [1..] -- bottom
06:45:46 <lambdabot>   mueval: Prelude.read: no parse
06:45:48 <dolio> > foldr (:) [] [1..] -- not bottom
06:45:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:46:21 <Saizan_> EmielRegis: i'd use that ^^^
06:46:22 <profmakx> @src foldr
06:46:23 <lambdabot> foldr f z []     = z
06:46:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:47:01 <telexicon> why do we need map then if we have monads
06:47:03 <Saya> hmm ive defined a vector3 type and made it instance of Num and Fractional but i still cant do v/d for example but v/2.0 works!! what am i doing wrong?
06:47:15 <telexicon> tradition?
06:47:30 <EmielRegis> Saizan_, I dont get it
06:47:33 <EmielRegis> I need bytecode
06:47:35 <EmielRegis> not rounding :P
06:47:46 <EmielRegis> oh unless Word8 is bytecode?
06:48:10 <jeffz> what do you mean by bytecode?
06:48:25 <byorgey> telexicon: I'm not sure what you mean.  How do monads get rid of the need for map?
06:48:39 <telexicon> byorgey, (+1) <$> [1..10]
06:48:51 <byorgey> telexicon: oh, (<$>) = fmap
06:48:54 <dolio> <$> doesn't have anything to do with monads.
06:49:00 <byorgey> that has nothing to do with... right
06:49:00 <telexicon> its for applicatives
06:49:09 <dolio> It's for functors.
06:49:13 <byorgey> although you could ask, 'why do we need map if we have functors'?
06:49:23 <telexicon> ok functors
06:49:30 <byorgey> tradition =)
06:49:40 <telexicon> ok
06:49:41 <dolio> Yeah, well, in that case, we should get rid of map.
06:49:45 <dolio> And rename fmap map.
06:49:49 <byorgey> indeed.
06:49:52 <telexicon> excellent
06:49:55 <telexicon> lets do it
06:50:18 <EmielRegis> nvm, I got around it using older file format
06:50:28 <byorgey> the argument against, as with many such proposals, is that error messages would become more confusing for people learning haskell.
06:50:32 <dolio> Except you can't do that without breaking H98 library compatibility, which is apparently important to some people.
06:50:38 <telexicon> byorgey, lol
06:50:52 <telexicon> since when is anybody concerned with error messages?
06:51:02 <byorgey> If I am learning Haskell and I only know about lists, and I apply 'map' wrong, I don't want to see an error message telling me something about 'foo is not an instance of Functor'
06:51:07 <telexicon> they are completely incomprehensible for someone learning haskell
06:51:15 <telexicon> they arent even close to being understandable
06:51:16 <dolio> People were during the H98 drafting. and they won a lot.
06:51:33 <vegai> I never read those error messages from ghc. I read the line number and go there to see what could be wrong
06:51:46 <telexicon> vegai, yeah, pretty much
06:51:46 <dolio> That's why there are a lot of monomorphic functions in the prelude and such.
06:51:50 <vegai> only if it's not obvious in 10 minutes or so, I start looking at the error
06:51:53 <dolio> Instead of more general versions.
06:51:56 <byorgey> hehe, point taken.  they're still a lot better than they used to be.
06:52:35 <Saizan_> bah, tutorials should teach you type inference
06:53:00 <dolio> GHC has gotten better. Now it tells you about half the time when the monomorphism restriction is biting you, for instance. :)
06:53:18 <dolio> And what extensions to turn on to make your code compile, if available. :)
06:54:00 <vegai> perhaps there could be a dummies version of ghc that just prints the line number when an error occurs :)
06:54:48 <vegai> seriously though, this is not an easy problem to solve, is it?
06:55:57 <vegai> does partial application prevent compile errors in the form of "expected n parameters, got m"?
06:56:22 <vegai> or "expected Int, got String"
06:56:53 <vegai> oh, and type classes make it a bit harder too?
06:56:57 <vegai> > 1.0 `div` 2.0
06:56:58 <lambdabot>   Add a type signature
06:57:10 <vegai> heh, ok.
06:57:40 <dolio> Go ahead. Give it a type that's both Integral and Fractional.
06:59:19 <Saizan_> if GHC's type system had principal typings (which i doubt) we could make the type inference work with much more local information, making it more understandable
06:59:38 <dolio> > 1.0 `div` 2.0 :: Expr
06:59:39 <lambdabot>   1.0 `div` 2.0
07:00:37 <vegai> yes ok. I'll withdraw that. The error messages in those cases are quite clear
07:05:30 <vegai> > (+) 1
07:05:31 <lambdabot>       Overlapping instances for Show (t -> t)
07:05:31 <lambdabot>        arising from a use of `s...
07:05:33 <vegai> > (+) 1 2 3
07:05:34 <lambdabot>       No instance for (Num (t -> a))
07:05:34 <lambdabot>        arising from the literal `1' at <...
07:10:51 <hackage> Uploaded to hackage: iCalendar 0.0
07:11:08 * shapr boings furiously
07:13:30 <vininim> lol, so what goes in hackage? anything written in haskell? =P
07:15:05 <vegai> anything someone who has an account submits there, I think
07:15:26 <Deewiant> anything with a .cabal file :-P
07:22:10 <EmielRegis> which library does clamp belong to?
07:22:17 <DustyDingo> ok, really i have no idea how haskell works, jope that is not stupid question i still have to get used to some concepts
07:22:49 <DustyDingo> i want to print a list of strings (text) line by line
07:23:32 <DustyDingo> so i got a printText :: [[Char]] -> IO function
07:24:31 <DustyDingo> printText (l:ls) = putStrLn l .....
07:25:30 <DustyDingo> how can i recursivley call printText and put print the current line each time?
07:25:37 <ziman> @hoogle clamp
07:25:37 <lambdabot> No results found
07:25:54 <EmielRegis> ok i wrote it myself :P
07:27:06 <Saizan_> DustyDingo: if you don't want a newline you can use putStr
07:27:07 <ziman> DustyDingo, it's usually printText [] = return () {- no action on empty lists -}; printText (l:ls) = putStrLn l >> printText ls
07:27:28 <jeffz> DustyDingo: alternatively forM_  ["foo","bar"] putStrLn
07:27:48 <ziman> when you get familiar with the concept, you can use printText = mapM_ putStrLn
07:28:08 <ziman> or what jeffz said.
07:28:31 <Deewiant> putStr . unlines
07:28:59 <DustyDingo> ok, i will have a look on this >> operator
07:29:12 <DustyDingo> of course i could map that too
07:29:36 <ziman> DustyDingo, it can be written using do
07:29:42 <nominolo> DustyDingo: >> performs to actions in sequence
07:29:48 <ziman> @redo putStrLn l >> printText ls
07:29:48 <lambdabot> do { putStrLn l; printText ls}
07:29:53 <nominolo> (ignoring the result of the first one)
07:30:00 <nominolo> *two
07:31:16 <DustyDingo> ok, so the result of this do statement is the result of the last operation in it?
07:32:02 <Deewiant> DustyDingo: yes
07:43:06 <Saya> how would i make an immutable array of Vector3's ... its asking for an instance declaration of IArray UArray but i have no idea how its supposed to work
07:43:49 <Saya> or im doing it wrong
07:44:16 <Lemmih> Saya: Don't use an UArray.
07:44:18 <vixey> so the docs says class HasBounds a => IArray a e
07:44:45 <vixey> maybe you need to write  instance HasBounds Vector3 where bounds = <something> :: Ix i => a i e -> (i, i)
07:45:46 <Lemmih> Saya: Are you using Vector3's as the index?
07:49:36 <vixey> what is the meaning of newtype Foo t = Foo t ?
07:50:41 <nominolo> vixey: it's like a label
07:51:03 <Botje> it allows you to define instances for Foo t while working on raw t values
07:51:05 <DustyDingo> hm, why doesn't this work for a generic type? http://pastebin.com/d59372bca
07:51:10 <Botje> see Sum a and Product a, for example :)
07:51:40 <skorpan> DustyDingo: how did that one line of code get highlighted?
07:51:45 <Beelsebob> DustyDingo: you compare x and y
07:51:48 <nominolo> DustyDingo: because a has to support Equality
07:51:52 <Beelsebob> so you need Eq a => [a] -> Bool
07:52:23 <Beelsebob> DustyDingo: using ghci instead of hugs would give you a significantly better error message there
07:52:31 <nominolo> DustyDingo: read the type as for any list of as which can be tested for equality ...
07:52:32 <DustyDingo> skorpan: @@ in front
07:52:41 <skorpan> cool
07:53:38 <DustyDingo> nominolo: line 35 is the highlighted one tho
07:54:22 <nominolo> DustyDingo: they're all different cases for the same function,
07:54:57 <nominolo> DustyDingo: which case gets selected is a runtime decision so you cannot have the constraint for one case and not for the other
07:55:20 <vixey> ooh
07:55:24 <vixey> I figured out something fun
07:55:29 <nominolo> :t foldr1 (==)
07:55:30 <lambdabot> [Bool] -> Bool
07:55:40 <Beelsebob> uh
07:55:41 <vixey> How do you write a variadic function without using typeclasses
07:55:44 <Beelsebob> oh, yes
07:55:49 <Beelsebob> :t foldr (==)
07:55:50 <lambdabot> Bool -> [Bool] -> Bool
07:56:07 <nominolo> :t comparing
07:56:08 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
07:56:26 <Deewiant> ?ty all (uncurry (==)) . (zip `ap` tail)
07:56:27 <lambdabot> forall b. (Eq b) => [b] -> Bool
07:56:30 <Botje> vixey: {-# LANGUAGE OlegToTheRescue #-} ?
07:57:22 <nominolo> yikes
08:01:00 <DustyDingo> Beelsebob: hm, so i have to limit this generic type and specify this in in the function head?
08:01:29 <Botje> yes
08:01:34 <Beelsebob> DustyDingo: you have to limit to types which can actually have the equality operator applied, yes
08:01:35 <Saya> lemmih: sorry was gone, no im using ints as the index and vector3 as value, its to represent a terrain in a basic form i want to try and a do a small 3d game in haskell
08:01:37 <Botje> not all types have an == operation, so you have to mention the constraint
08:02:06 <DustyDingo> so like concepts in C++, but here they are explicitly specified
08:02:23 <Lemmih> Saya: Use an 'Array' instead of 'UArray'.
08:02:42 <DustyDingo> isEqual :: a => [a] -> Bool doesn't work tho
08:02:44 <Saya> wouldnt a strict representation be more efficient?
08:02:49 <DustyDingo> ah *grml*
08:02:50 <DustyDingo> forget it
08:02:52 <DustyDingo> :)
08:02:54 <vixey> what do you store Saya?
08:03:07 <Saya> a matrix of vector3 basically
08:03:12 <Saya> points in space
08:03:27 <Lemmih> Saya: UArray only works for a limited number of types.
08:03:48 <vixey> Saya, is it something like opengl which wants it in a UArray?
08:03:58 <Lemmih> Saya: Unboxed isn't the same thing as strict.
08:03:59 <Saya> nope :p just me
08:04:02 <vixey> ok
08:04:09 <vixey> what is wrong with [Vector3]?
08:04:25 <Saya> hmm is index access good?
08:04:33 <vixey> no it's O(n) indexing
08:04:39 <vixey> Array has got O(1) indexing
08:04:52 <Saya> yeah well thats why i want arrays :p
08:05:05 <vixey> :t Array.fromList
08:05:06 <lambdabot> Not in scope: `Array.fromList'
08:05:10 <vixey> :t Array.array
08:05:12 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
08:05:18 <vixey> yeah this shoud be it ..
08:05:54 <drigz> :t arrayList
08:05:55 <lambdabot> Not in scope: `arrayList'
08:05:58 <drigz> :t listArray
08:05:59 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
08:06:42 <C-Keen> hm how do you use yi in emacs mode together with xmonad grabbing the alt modifier?
08:08:05 <Saizan_> C-Keen: change the meta-key for xmonad
08:08:36 <Saizan_> C-Keen: or use custom keybindings in yi, there's an example configuration for that iirc
08:09:40 <Saya> ok i got my 2D array :)
08:10:14 <Saya> now how to generate a heightmap with an immutable array... i guess the heightmap could be a 2D function of some sort
08:10:28 <vixey> I have to build a complex monad transformer stack
08:10:38 <Saya> scary :)
08:10:52 <hackage> Uploaded to hackage: tiger 1.0
08:10:52 <hackage> Uploaded to hackage: ghc-syb 0.1
08:11:11 <vixey> I don't know how to :L
08:17:30 <snk_kid> Lemmih?
08:17:41 <Saizan_> vixey: hard to properly mix the effects?
08:17:45 <Lemmih> snk_kid?
08:18:28 <snk_kid> Lemmih: did you get my email about HSDL ghc 6.10.1 on windows/mingw?
08:18:37 <vixey> yes
08:20:21 <Lemmih> snk_kid: I did. Do you want to be the windows maintainer?
08:23:47 <snk_kid> Lemmih: not really, i'm not well versed in cabal besides
08:24:50 <Lemmih> snk_kid: I can't test on Windows so I'm reluctant to do anything else than apply patches.
08:26:28 <snk_kid> Lemmih: well it works fine on windows, it's just something weird with build config adding the set of libraries & paths twice
08:26:53 <snk_kid> Lemmih: like it's get it from the both the make file and buildinfo file
08:29:00 <idnar> what is "mdo"?
08:30:10 <EvilTerran> idnar, i think it's the MonadFix syntactic sugar
08:32:34 <EvilTerran> idnar, see http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#mdo-notation
08:32:35 <lambdabot> Title: 8.3.ï¿½Syntactic extensions, http://tinyurl.com/y6v6by
08:32:43 <EvilTerran> ?where+ mdo http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#mdo-notation
08:32:44 <lambdabot> It is forever etched in my memory.
08:34:44 <idnar> oh, huh
08:34:48 * idnar 's brain explodes again
08:35:13 <EvilTerran> ?instances-importing Control.Monad.Fix MonadFix
08:35:14 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:35:29 <EvilTerran> yeah, IO's in there. that makes my brain explode too.
08:38:13 <idnar> uhmm
08:38:32 <Saya> > array ((0,9),(0,9)) [((i,j),i*j) | i <- [0..9], j <- [0..9] ]
08:38:33 <lambdabot>   array * Exception: Error in array index
08:38:42 <Saya> whats wrong with my array index?
08:38:51 <EvilTerran> try ((0,0),(9,9))
08:38:57 <EvilTerran> it's (lower bound, upper bound)
08:39:13 <EvilTerran> ?src Ix
08:39:14 <lambdabot> class (Ord a) => Ix a where
08:39:14 <lambdabot>     range           :: (a,a) -> [a]
08:39:14 <lambdabot>     index           :: (a,a) -> a -> Int
08:39:14 <lambdabot>     inRange         :: (a,a) -> a -> Bool
08:39:14 <lambdabot>     rangeSize       :: (a,a) -> Int
08:39:20 <Saya> > array ((0,0),(9,9)) [((i,j),i*j) | i <- [0..9], j <- [0..9] ]
08:39:22 <lambdabot>   array ((0,0),(9,9)) [((0,0),0),((0,1),0),((0,2),0),((0,3),0),((0,4),0),((0,...
08:39:23 <EvilTerran> > range ((0,9),(0,9))
08:39:24 <lambdabot>   [(0,9)]
08:39:25 <idnar> @type array
08:39:26 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
08:39:26 <Saya> indeed thx
08:39:28 <EvilTerran> > range ((0,0),(9,9))
08:39:29 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1...
08:40:07 <idnar> generalised list comprehensions are weird
08:43:26 <DustyDingo> hm, i have two list of strings, they are the same size and i must do logic intersection for each char
08:43:34 <ikkebr> > range ((0,0),(9,9)) !! 27
08:43:35 <lambdabot>   (2,7)
08:43:41 <dolio> , [ (x, y) | x <- [1..10], y <- [10,9..1], sort ]
08:43:42 <ikkebr> > range ((0,0),(9,9)) !! 50
08:43:43 <lambdabot>   (5,0)
08:43:46 <ikkebr> :p
08:43:47 <lunabot>  luna: Couldn't match expected type `GHC.Bool.Bool'
08:43:48 <vixey> bitwise XOR?
08:43:54 <DustyDingo> i define these operations in a seperate function
08:43:55 <dolio> , [ (x, y) | x <- [1..10], y <- [10,9..1], sort by id]
08:43:57 <lunabot>  luna: Not in scope: `by'
08:44:07 <idnar> , [ (x, y) | x <- [1..10], y <- [10,9..1], then sort by id]
08:44:09 <lunabot>  luna: Illegal transform or grouping list comprehension: use -XTransformLi...
08:44:24 <DustyDingo> is there a good way to map this (char->char->char) function on these two [String] lists?
08:44:34 <vixey> DustyDingo, yeah, zipWith
08:44:43 <DustyDingo> to get a [String] in the end
08:44:51 <DustyDingo> vixey: ok, i will have a look
08:44:51 <vixey> wait [String] not String
08:44:58 <dolio> , [ (x, y) | x <- [1..10], y <- [10,9..1], then sort by y]
08:44:59 <vixey> If it's actually [String] I don't know
08:45:00 <lunabot>  luna: Illegal transform or grouping list comprehension: use -XTransformLi...
08:45:38 <EvilTerran> > zipWith (,) "abcde" "fghij"
08:45:39 <lambdabot>   [('a','f'),('b','g'),('c','h'),('d','i'),('e','j')]
08:45:43 <idnar> @type zipWith (map ?f) ?x::[String] ?y::[String]
08:45:44 <lambdabot> parse error on input `?y'
08:45:50 <EvilTerran> > liftA2 (,) "abcde" "fghij"
08:45:52 <lambdabot>   [('a','f'),('a','g'),('a','h'),('a','i'),('a','j'),('b','f'),('b','g'),('b'...
08:45:52 <idnar> @type zipWith (map ?f) (?x)::[String] (?y)::[String]
08:45:53 <lambdabot> parse error on input `)'
08:46:13 <Beelsebob> > "abcde" <^(,)^> "fghij"
08:46:14 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
08:46:14 <Lemmih> @type zipWith . zipWith
08:46:15 <Beelsebob> :(
08:46:15 <lambdabot> forall a b c. (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
08:47:12 <EvilTerran> @type zipWith (map ?f) (?x::[String]) (?y::[String])
08:47:13 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[b1]'
08:47:13 <lambdabot>     Probable cause: `map' is applied to too many arguments
08:47:13 <lambdabot>     In the first argument of `zipWith', namely `(map ?f)'
08:47:23 <idnar> @type zipWith (zipWith ?f) ((?x)::[String]) ((?y)::[String])
08:47:24 <lambdabot> forall c. (?f::Char -> Char -> c, ?x::[String], ?y::[String]) => [[c]]
08:47:50 <DustyDingo> vixey: yeah, i would have to do it line by line and then zip for that again
08:47:53 <Lemmih> DustyDingo: The answer is 'zipWith . zipWith' if you missed it.
08:47:54 <DustyDingo> or is there a better way?
08:48:11 <DustyDingo> Lemmih: ok
08:48:12 <idnar> @pl \f x y -> zipWith (zipWith f) x y
08:48:12 <lambdabot> zipWith . zipWith
08:48:15 <idnar> doh
08:48:44 <vixey> I guess I need only need ErrorT and GensymT
08:49:07 <vixey> It doesn't have to be more complex than that
08:49:29 * vixey will probably discover that is not true after writing it out
08:50:42 <Saizan_> vixey: it's usually easy to add another layer in the stack later, if you wrap it properly
08:51:12 <vixey> I think I want ReaderT too
08:53:46 <conal> btw zipWith . zipWith is a special case of the pattern liftAn^m
08:53:46 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
08:54:30 <conal> which also subsumes stuff like (.).(.).(.)
08:54:55 <idnar> in what applicative is zipWith liftA?
08:55:04 <dolio> ZipList
08:55:32 <idnar> ah
08:55:45 <Saizan_> liftA2
08:55:59 <dolio> @type \f l r -> getZipList (liftA2 f (ZipList l) (ZipList r))
08:56:00 <lambdabot> forall a b a1. (a -> b -> a1) -> [a] -> [b] -> [a1]
08:57:15 <mikey> Anyone use c# programming here?
08:58:41 * Botje has used vb.net for a while
09:02:01 <askentasken> is 5+3 and [1,2]
09:02:21 <askentasken> is "he" ++ "llo" and [1,2]++[3,4,5] parametric polymorphism?
09:02:36 <Saizan_> es
09:02:41 <Saizan_> "yes"
09:03:35 <askentasken> and i can define my own? i could define "add" that does [1,2] `add` [3,4] "he" `add` "llo", 1 `add`5 etc
09:04:25 <Raevel_> askentasken: in that case you need a type class
09:04:27 <lilac> askentasken: yes, but that's something a bit more powerful.
09:04:39 <gwern> yes, I was about to say, to add numbers and strings...
09:04:56 <Raevel_> askentasken: to get the first to working, you only need add = (++)
09:05:00 <Raevel_> s/to/two
09:08:33 <Raevel_> http://en.wikipedia.org/wiki/Haskell_class_attack_transport
09:08:35 <lambdabot> Title: Haskell class attack transport - Wikipedia, the free encyclopedia
09:12:25 <askentasken> why cant i have a Map of {1: "hello", 2: 5} ?
09:12:33 <askentasken> why is that a sin?
09:12:56 <jeffz> what would the type be?
09:13:14 <Beelsebob> askentasken: if you did a lookup on the map, what type would you get out?
09:13:22 <askentasken> Map Int : a
09:13:24 <Beelsebob> and what functions could you apply to it?
09:13:49 <askentasken> well if could do dynamic stuff :)
09:13:58 <askentasken> so can i only have that ina dynamic language?
09:14:03 <Lemmih> askentasken: You could say: data T = S String | I Int.
09:14:04 <Beelsebob> you can
09:14:09 <askentasken> where i can check types at runtime?
09:14:15 <Beelsebob> in a static language you would have to define a data type to tell it what types are there
09:14:21 <Beelsebob> by doing as Lemmih said
09:14:29 <Beelsebob> or by making it a Map Int (Either String Int)
09:14:50 <Botje> askentasken: there's also Data.Dynamic
09:14:59 <Botje> where you make the dynamic type conversion explicit.
09:20:31 <vixey> so say you have  Lambda (\x -> ... (Var <annotation> x))  and you want to subst in some value (Foo <annotation'>)
09:20:34 <vixey> should the result be,
09:20:48 <vixey> Lambda (\x -> ... (Foo <annotation>)) or Lambda (\x -> ... (Foo <annotation'>)) ?
09:21:43 <vixey> annotation and annotation' are probably alpha-beta-(and a couple other things) equal, so I'm not sure what to choose
09:23:38 <EvilTerran> ... what information are these annotations carrying?
09:25:35 <nolraiWest> I want to write a monad that is poylmorphic between a version that keeps logs and a version that doesn't.  I want the version that dosen't to not even bother calculating them, or will lazyness do the job for me?
09:26:26 <nolraiWest> hmm, not my clearest writing.
09:28:12 <EvilTerran> nolraiWest, you could have a typeclass for your monad
09:28:24 <EvilTerran> like MonadState for State
09:28:46 <EvilTerran> and then have two different datatypes as instances of that typeclass, one which logged and another which didn't
09:33:10 <nolraiWest> Thanks
09:39:06 <C-Keen> hm installing of array-0.1.0.0 fails with ghc-6.10.1  Duplicate instance declarations: instance Typeable2 IOArray
09:39:22 <C-Keen> that's part of base as well
09:39:40 <C-Keen> do I need a --base 3 or something?
09:40:50 <Saizan_> C-Keen: why do you need array-0.1?
09:41:01 <C-Keen> Saizan_: yi wants it
09:42:51 <rherrmann> btw, any news about Gtk2Hs on 6.10 ?
09:43:29 <DustyDingo> theres, head it's oposit last is there a counter part for tail too?
09:43:54 <Deewiant> DustyDingo: init
09:44:02 <DustyDingo> Deewiant: thx
09:44:12 <Saizan_> C-Keen: ah right, since it depends on Cabal-1.4.* which depends on array-0.1
09:44:21 <DustyDingo> ok maybe i didn't found it, because the name isn't that intuitive :=
09:44:23 <DustyDingo> :)
09:45:13 <Saizan_> C-Keen: i solved that problem by installing a custom Cabal-1.4 package, http://code.haskell.org/~Saizan/Cabal-1.4.0.3.tar.gz
09:47:41 <C-Keen> Saizan_: that does not build with cabal configure
09:48:13 <Saizan_> no?
09:49:42 <Saizan_> oh, right, you need --constraint="base < 4"
09:50:33 <C-Keen> alright
09:51:13 <Saizan_> no, actually you need to compile the Setup.lhs explicitly
09:51:26 <Saizan_> passing -package base-3.0.3.0 and building with that
09:51:57 <C-Keen> indeed
09:53:23 <C-Keen> Saizan_: hm, and how do I proceed then? Setup configure fails with packages requiring base 4
09:55:35 <Saizan> C-Keen:  don't use --contraint="base < 4", it will print a warning but it's harmless
09:56:26 <nolraiWest> is there a way to hack the cunning newtype deriving to work on type classes of arity >1?
09:57:11 <Saizan> nolraiWest: classes like MonadState/MonadReader etc work with newtype deriving
09:57:23 <sclv> what about Functor?
09:57:43 <C-Keen> Saizan: thanks!
09:57:55 <sclv> with Newtype and Standalone together?
09:58:02 <sclv> Could never get that working.
09:59:20 <nolraiWest> hmm its not likeing StateM.
09:59:28 <askentasken> how do i do map = (map . filter) ?
09:59:36 <DustyDingo> hm, should that work? http://pastebin.com/d842861f
09:59:41 <DustyDingo> hugs segfaults here
09:59:55 <Saizan> i've seen Functor derived in many places, but not standalone
10:00:16 <idnar> what is standalone?
10:00:18 <askentasken> how do i do: let mapf = (map . filter) ?
10:00:25 <sclv> maybe its a bug that it can't?
10:00:36 <sclv> I should file it, I suppose.
10:00:39 <Saizan> nolraiWest: maybe you need to make the parameter you want to derive on the last one
10:00:41 <idnar> @type map . filter
10:00:41 <lambdabot> forall a. (a -> Bool) -> [[a]] -> [[a]]
10:01:00 <nolraiWest> Saizan: ??
10:01:02 <Saizan> askentasken: that definition should work, which error are you getting
10:01:07 <dons> yay, rwh electronic version now shipping!
10:01:08 <dons> http://www.realworldhaskell.org/blog/2008/11/15/real-world-haskell-electronic-edition-now-on-sale/
10:01:10 <lambdabot> Title: Real World Haskell Â» Blog Archive Â» Real World Haskell Electronic Edition Now  ..., http://tinyurl.com/5qbgrm
10:01:11 <dons> woot woot
10:01:29 <idnar> dons: awesome
10:01:33 <sclv> standalone deriving = "deriving instance Show for MyTypeWithoutShowInstance"
10:01:46 <sclv> congrats!
10:01:47 <C-Keen> Saizan: you don't happen to know what to do with regex-tdfa-0.94?
10:02:10 <dons> apparently , because we used docbook, they can just push a button to enable the electronicv ersion. good good
10:02:11 <askentasken> Saizan: mapf (\x -> x*x) (< 10) [[1..20]]
10:02:11 <askentasken> <interactive>:1:17:
10:02:11 <askentasken>     The section `(< 10)' takes one argument
10:03:06 <askentasken> it compiels but i dont want that type, i want just one list, not list of lists
10:03:38 <idnar> askentasken: what do you want mapf to do?
10:03:47 <askentasken> filter and map in one step
10:03:55 <askentasken> with no-points-style
10:04:02 <idnar> @pl \f1 f2 x -> map f1 . filter f2
10:04:02 <lambdabot> (const .) . (. filter) . (.) . map
10:04:05 <luite> dons: ah cool, I always wanted to ask whether an electronic version would be available, but now you already gave the answer
10:04:28 <luite> can we also get the docbook source? :)
10:04:41 <Saizan> C-Keen: ah, yes
10:05:14 <idnar> @pl \f1 f2 x -> filter f1 . map f2
10:05:14 <lambdabot> (const .) . (. map) . (.) . filter
10:05:17 <idnar> @pl \f1 f2 x -> filter f2 . map f1
10:05:17 <lambdabot> (const .) . flip ((.) . filter) . map
10:05:54 <dons> luite: we have asked for those too.
10:05:54 <BMeph> idnar: What do you want done with that 'x' you keep throwing in the arguments? :)
10:06:02 <idnar> BMeph: oh, oops
10:06:08 <idnar> @pl \f1 f2 -> filter f1 . map f2
10:06:08 <lambdabot> (. map) . (.) . filter
10:06:13 <idnar> @pl \f1 f2 -> filter f2 . map f1
10:06:13 <lambdabot> flip ((.) . filter) . map
10:06:28 <idnar> @pl \f1 f2 -> map f1 . filter f2
10:06:28 <lambdabot> (. filter) . (.) . map
10:06:34 <idnar> @pl \f1 f2 -> map f2 . filter f1
10:06:34 <lambdabot> flip ((.) . map) . filter
10:06:50 <idnar> I guess one of those is askentasken's answer, although none of them are particularly attractive
10:07:27 <Saizan> C-Keen: http://code.haskell.org/~Saizan/regex-tdfa-0.94.1.tar.gz
10:07:27 <idnar> BMeph: thanks, I was wondering why the heck there was a const :P
10:07:45 <C-Keen> Saizan: what's the fix here btw
10:08:02 <BMeph> idnar: No problem - making simple, dumb mistakes is my specialty. ;)
10:08:23 <solrize> hmm, dons, i clicked "book + electronic" on the oreilly page but it added them to the cart as separate items instead of the discount combo
10:08:40 <solrize> print + electronic rather
10:08:47 <Saizan> C-Keen: in the new containters package the type of Map.lookup has changed
10:09:04 <dons> solrize: hmm interesting.
10:09:06 <C-Keen> Saizan: I see
10:09:13 <dons> maybe because the book isn't shipping yet?
10:09:30 <solrize> i dunno
10:09:39 <dons> solrize: "NOTE: Book/PDF bundles are shown as two separate items in your cart. Discount and bundle pricing will be shown on the order summary page."
10:09:43 <dons> ?
10:09:59 <askentasken> idnar: i think i ahve seen an easier way to do it with oints-free
10:10:01 <solrize> oh that would take care of it
10:10:04 <solrize> i didnt see that
10:10:07 <askentasken> mapf f cond [] = []
10:10:07 <askentasken> mapf f cond (x:xs) | cond x     = f x : mapf f cond xs
10:10:07 <askentasken>                    | otherwise  = mapf f cond xs
10:10:13 <dons> anyone tried viewing the .pdf on a mobile device yet?
10:10:17 <askentasken> there is my own recursive solution'
10:10:28 <dons> i'd be keen for feedback on whether it is android or iphone friendly
10:10:41 <luite> I plan to read it on an eink book reader
10:10:46 <adityam> dons: Is a preview of RWH available somewhere. I want to see how the pdf version looks.
10:10:47 <askentasken> dons: if what is?
10:10:51 <askentasken> ah
10:10:52 <hackage> Uploaded to hackage: LslPlus 0.1.2
10:11:09 <dons> adityam: good idea. i'm not aware of a preview of the .pdf yet. let me see...
10:11:31 <dons> adityam: i'll ask the publishers.
10:11:51 <luite> is there a much of a difference between the current online html version and the final published o'reilly version?
10:11:53 <adityam> dons: Usually, they have table of contents and 10-15 pages from a chapter.
10:11:57 <BMeph> askentasken: Just curious, but - what do you think "points-free" means? :)
10:12:32 <solrize> it wants me to enroll some kind of membership before i can check out, sigh
10:12:32 <dons> adityam: since it just went live, maybe some of the extras aren't available yet
10:12:39 <dons> adityam: but i've asked the publishers that question
10:12:52 <dons> luite: yeah, all the proof editing and so on.
10:12:59 <dons> luite: we'll be getting back the docbook though soon
10:13:02 <adityam> dons: Thanks
10:13:03 <askentasken> solrize: uh well maybe i meant something else. f . another_f obv uses points
10:13:08 <dons> so that the site can have the same content in html form
10:13:10 <vegai> I wish it was there. I just have other books I need to order and RWH would come nicely in that stream...
10:13:19 <askentasken> didnt think about that, thought i had heard it refereed to as pointe-freee
10:13:36 <vegai> the paper version, I mean.
10:13:50 <dons> oh, it went to the printers just under 24 hours ago
10:14:09 <dons> more details will follow when we hear back from the printing press people
10:14:26 <vegai> oh, ok. I'll try to postpone my order a bit then
10:15:54 <adityam> How does one install the profiling version of a haskell package on Arch Linux?
10:16:15 <dons> we don't actually provide those via default. good question!
10:16:32 <dons> cabal install foo -p
10:16:38 <askentasken> hy can i do map . filter and not filter . map?
10:16:51 <dons> you can do both... :)
10:16:59 <adityam> But I am using yaourt for installing packages. I don't want to mix that with cabal
10:17:03 <nolraiWest> :t filter . map
10:17:04 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[b]'
10:17:04 <lambdabot>       Expected type: (a -> b) -> [a] -> Bool
10:17:04 <lambdabot>       Inferred type: (a -> b) -> [a] -> [b]
10:17:10 <DustyDingo> hm, is there a way to map a function a -> b -> c on a list and specify one argument with a contant value and one with the list input list?
10:17:12 <nolraiWest> :t filter (==2) . map
10:17:13 <lambdabot>     Couldn't match expected type `[a]'
10:17:13 <lambdabot>            against inferred type `[a1] -> [b]'
10:17:13 <lambdabot>     Probable cause: `map' is applied to too few arguments
10:17:19 <dons> adityam: the arch packages don't enable profiling
10:17:52 <Saizan> > map (+1) [1..3] -- DustyDingo ?
10:17:52 <luite> DustyDingo: map (+1) [1,2,3]
10:17:53 <lambdabot>   [2,3,4]
10:17:55 <luite> lol
10:18:04 <luite> you stoled my example :(
10:18:10 <adityam> dons: So should I just give up AUR and install everything using cabal-install. I don't want to maintain two different trees
10:18:16 <BMeph> askentasken: "points" refers to free variables; a "points-free" equation is one that describes what you'd do to a function's argument, without referencing the argument by name. If you've ever seen Forth (or Joy or Factor), that's the style they use. :)
10:18:30 <askentasken> mapif :: (t -> a) -> (t -> Bool) -> [t] -> [a]
10:18:35 <askentasken> thats the type i want
10:18:47 <BMeph> @type (.map) . foLip filter
10:18:48 <lambdabot> forall a a1. (a1 -> Bool) -> (a -> a1) -> [a] -> [a1]
10:19:03 <dons> adityam: if you're doing development, and need profiling, using cabal-install is required for now.
10:19:03 <badkins> I'm trying to run a simple benchmark using a towers of hanoi program here: http://www.kernelthread.com/hanoi/html/hs.html
10:19:11 <Saizan> then "mapif f pred = map f . filter pred" is the saner definition
10:19:17 <BMeph> @type (.filter) . foLip map
10:19:18 <dons> adityam: i would imagine you don't need profiling versions of everything.
10:19:18 <lambdabot> forall a b. (a -> b) -> (a -> Bool) -> [a] -> [b]
10:19:21 <profmakx> its pointsfree because it contains a lot of points!
10:19:25 <dons> adityam: but note, cabal install won't clobber your aur packages
10:19:32 <dons> since it installs as user by default
10:19:40 <DustyDingo> luite: ?
10:19:41 <dons> so you can just get things that you need for profiling via cabal-install
10:19:48 <badkins> I'm a total newbie - how do I actually run this? ghc is complaining when I simply add: 'hanoi 10' at the end.
10:19:58 <DustyDingo> luite: i want to map the function foo to a list, but foo takes two arguments
10:20:03 <dons> badkins: at the end?
10:20:07 <badkins> yes
10:20:07 <luite> DustyDingo: + also takes two arguments
10:20:10 <adityam> dons: Ok. I will install the profiling  versions using cabal install
10:20:13 <luite> > (+) 1 2
10:20:15 <lambdabot>   3
10:20:15 <dons> ?paste <- paste the code you're trying to compile
10:20:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:20:28 <luite> DustyDingo: you can also write map ((+) 1) [1..3]
10:20:33 <badkins> ok
10:20:35 <BMeph> askentasken: I have a utility function that I call "foLip" for some obscure historical reason. It's defined as: foLip f = (.) . f
10:20:56 <Saizan> badkins: add "main = print (hanoi 10)" at the end and compile with ghc --make
10:21:01 <DustyDingo> luite: so map (foo 3) [1,2,3,4] ok, that makes sence
10:21:11 <badkins> dons: http://hpaste.org/12067
10:21:24 <DustyDingo> but there is no way, to specify the which argument is the list?
10:21:26 <nolraiWest> :t let f = (.) . f in f
10:21:27 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
10:21:27 <lambdabot>     Probable cause: `.' is applied to too few arguments
10:21:27 <lambdabot>     In the expression: (.) . f
10:21:28 <Saizan> -O2 also
10:21:37 <luite> DustyDingo: true. you can only supply the first argument this way. if you want to specify another you can use flip
10:21:42 <badkins> I'm sure it's a "main" type of thing. I'm used to "loose" languages such as Ruby/Python :)
10:21:52 <luite> DustyDingo: or use map (`func` arg) ...
10:22:06 <Saizan> DustyDingo: map (\x -> foo x constant) list
10:22:08 <badkins> Saizan: thx, I'll try it
10:22:42 <nolraiWest> :t let ff f = (.) . f in ff
10:22:43 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
10:23:15 <dons> badkins: http://hpaste.org/12067#a1
10:23:22 <chrisdone> Computer--so called--science has a lot in common with magic. Computers. Magic.
10:23:38 <C-Keen> Saizan: yi wants regex-tdfa-0.94
10:23:38 <nolraiWest> > let ff f = (.) . f in ff f x g y
10:23:39 <lambdabot>       Ambiguous occurrence `f'
10:23:39 <lambdabot>      It could refer to either `L.f', defined a...
10:23:51 <dons> badkins: the need to write 'main' will be made up for by code that is typically 100x faster than ruby :)
10:23:54 <nolraiWest> > let ff f = (.) . f in ff z x g y
10:23:54 <lambdabot>   Couldn't match expected type `a -> b -> c'
10:23:55 <badkins> Saizan dons: thx. Since this is a benchmark, I'd prefer to avoid actually printing though.
10:24:08 <dons> oh sure.
10:24:14 <badkins> dons: it wasn't a complain, just an excuse for my ignorance :)
10:24:15 <nolraiWest> > let ff f = (.) . f in ff z x g y :: Expresion
10:24:16 <lambdabot>       Not in scope: type constructor or class `Expresion'
10:24:20 <badkins> speed is what I'm after :)
10:24:22 <BMeph> I'm really looking forward to the Functional Revolution. Then, students introduced to C/C++/Java can ask Q's like "I just gave a tuple to that function, why can't I use it in this equation?" :)
10:24:53 * vixey awaits a different revolution
10:25:07 <chrisdone> time warp revolution?
10:25:07 <badkins> what can I use instead of "print (hanoi 10)" to simply ignore the output of (hanoi 10) ?
10:25:12 <dons> here...
10:25:19 <vixey> badkinds, "ignore output" ?
10:25:19 <DustyDingo> Saizan: nice
10:25:26 * solrize missed the revolution.  nobody told me it wouldn't be televised.
10:25:34 <dons> badkins: http://hpaste.org/12067#a2
10:25:36 <badkins> vixey: yes
10:25:41 <vixey> badkinds, meaning what
10:25:42 <dons> badkins: make sure you /compile/ with -O2
10:25:45 <Saizan> C-Keen: well, you can relax that dep in the cabal file
10:25:47 <badkins> ok
10:25:48 <dons> as in the example i just linked to.
10:26:07 <Saizan> C-Keen: i bumped the version in the package i gave to you to avoid confusion with the one on hackage
10:27:05 <badkins> dons: excellent! thx
10:27:33 <Saizan> C-Keen: or you could bug the yi developers for a version that compiles fine on 6.10 :)
10:27:35 <badkins> Ruby has been good to me, but *man* is it slow :) Haskell will take some effort, but I expect it to be rewarding.
10:28:05 <Saizan> C-Keen: that would be probably best, but i got it working with this method too
10:28:08 <badkins> for the simple hanoi.hs: Ruby(20)=14.6s, Haskel(20)=0.004s  !
10:28:36 <luite> the haskell version only seems to calculate the structure of the list though, don't know if that matters?
10:28:45 <solrize> badkins how long does it take if you print the length of x in main
10:28:47 <badkins> dons: hmm... I wonder if it simply optimized it all away?
10:28:54 <vixey> hahahaha
10:28:58 <dons> oh, yes. its a list result :)
10:29:07 <vixey> Haskel can do nothing faster than ruby can do something
10:29:11 <solrize> :)
10:29:12 <badkins> ha :)
10:29:16 <dons> replace that eval line with,
10:29:23 <dons> main = do let x = hanoi 20 length x `seq` return ()
10:29:25 <dons> grr.
10:29:27 <badkins> that's actually not ridiculous though :)
10:29:30 <dons> length x `seq` return ()
10:29:34 <chrisdone> too bad ruby is slow as f-wait, what?
10:29:38 <dons> so it actually calculates the list :)
10:29:48 <badkins> ok
10:29:53 <dons> since haskell will just say, 'eh? you don't even want the whole thing, i won't evaluated it then. done!'
10:30:18 <badkins> dons: right. I never have to worry about that in Ruby ;)
10:30:23 <solrize> i remember the alioth shootout site maintainer mentioning having to keep rewriting the benchmark specs because ghc kept recognizing stuff it could completely ignore instead of computing
10:30:40 <vixey> lol
10:30:45 <Eelis> that just shows that his benchmarking philosophy is crap.
10:31:00 <badkins> dons: "The last statement in a 'do' construct must be an expression"
10:31:13 <badkins> first line is now: "main = do let x = hanoi 20 length x `seq` return ()"
10:31:16 <badkins> w/o ""
10:31:20 <dons> main = do let x = hanoi 20
10:31:29 <badkins> ok
10:31:30 <dons> then the next line
10:31:41 <vixey> badkins, benchmarking this probably wont tell you anything interesting
10:31:43 <solrize> i think like this  http://hpaste.org/12067#a3
10:31:49 <badkins> whitespace sensitive ?
10:32:01 <dons> badkins: http://hpaste.org/12067#a4
10:32:12 <dons> badkins: yes. (unless you use { ; ; } syntax , which is ugly)
10:32:14 <badkins> vixey: I know, I just wanted a quick comparison. I do have some performance background, so I may put a better test together later.
10:32:41 <solrize> control.parallel.strategies?
10:32:47 <vixey> what do you mean by that badkins?
10:32:54 <vixey> performance backgroud(?)
10:32:57 <dons> badkins: someone's already done some tests for you, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ruby
10:32:59 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : IntelÂ® PentiumÂ® 4 Computer Language Benchmar ..., http://tinyurl.com/veo3w
10:33:26 <badkins> vixey: proper measuring of performance capabilities
10:33:38 <badkins> stats, experiments, etc.
10:33:43 <luite> dons: but as length will only look at the conses and not the elements themselves, the actual (from,to) move tuples will still not be calculated, right?
10:33:50 <vixey> I see
10:33:58 <badkins> dons: I've been to shootout
10:34:06 <badkins> consider this my "hello, world"
10:34:17 <Didro> Hello, Could somebody please point me out how to define the datatype - Integer subset: e.g.: 1,4..10 ?
10:34:22 <dons> luite: to calculate the length though, the algorithm must force it all anyway
10:34:36 <vixey> Didro, you can't do that
10:34:37 <dons> badkins: got it working now?
10:35:01 <badkins> yes 0.332s
10:35:03 <vixey> Didro, easy approximation is to define  data Those = One | Two ... and nthem make it a Num instance
10:35:05 <badkins> thx a bunch!
10:35:12 <solrize> didro you could do it as an enumeration but then you couldn't do arithmetic on it
10:35:31 <badkins> ~43x faster than Ruby
10:35:39 <Didro> vixey, solrize: Ok, thank you
10:35:57 <chrisdone> @quote chrisdone
10:35:58 <lambdabot> chrisdone says: benchmarks only exist to make fun of ruby
10:36:01 <dons> hehe
10:36:04 <EmielRegis> :D
10:36:23 <solrize> the hanoi program actually makes the (from,to) tuple?
10:36:39 <badkins> good question, no clue
10:36:50 <vixey> who knows, both programs do something and haskell does it faster though
10:37:10 <dons> solrize: well, they're only evaluated once, and we take the length
10:37:13 <badkins> solrize: it would have to to perform the function wouldn't it?
10:37:15 <dons> so all the cons cells have to be created.
10:38:08 <dons> let's see...
10:38:14 <luite> but using [undefined] instead of [(from,to)] will work just as good
10:39:33 <solrize> http://hpaste.org/12067#a5  i'd be interested in runtime of this version
10:39:47 <badkins> solrize: I'll run it
10:39:50 <solrize> and its ruby counterpart
10:39:57 <vixey> you know what would be useful
10:40:02 <badkins> what's with the parallel stuff ?
10:40:04 <vixey> in ghci,   :time <expression>
10:40:11 <luite> solrize: will not make any difference, probabl, it will not even evaluate the from+to
10:40:15 <dons> badkins: oh, not used. i was going to play with some ideas
10:40:19 <vixey> and it times how long it takes to turn that expression into a normal form
10:40:28 <roconnor> what's that free software mathematica/maple program?
10:40:32 <vixey> Maxima
10:40:33 <solrize> luiti i changed "length x" to "sum x"
10:40:39 <nolraiWest> :t litft
10:40:40 <lambdabot> Not in scope: `litft'
10:40:48 <solrize> luite
10:40:54 <solrize> :t lift
10:40:55 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
10:41:04 <luite> solrize: oh sorry
10:41:19 <badkins> solrize: 0.361 instead of 0.332 for the first
10:41:34 <badkins> a handful of runs
10:41:56 <badkins> ~ 10% slower
10:42:05 <solrize> might be interesting with http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stream-fusion
10:42:06 <lambdabot> Title: HackageDB: stream-fusion-0.1.2.1, http://tinyurl.com/38larw
10:42:12 <luite> badkins: is it faster if you change the type to Int?
10:42:25 <lispy> does anyone have a tool that checks if exported functions are ever imported?
10:42:54 <badkins> luite: type?  I'm a dynamic language guy :)
10:42:59 <DustyDingo> ok, tell me a good way to creat a list of the length n with all elements of value x?
10:43:20 <solrize> dustydingo, replicate n x
10:43:22 <solrize> > replicate 3 5
10:43:23 <lambdabot>   [5,5,5]
10:43:26 <chrisdone> dynamic languages have types...
10:43:29 <badkins> luite: what type do you think is inferred ?
10:43:37 <roconnor> dynamic languages have tags
10:43:43 <badkins> chrisdone: yes, but I don't have to specify them :)
10:43:51 <luite> badkins: you can add a type signature dohanoi::Int -> Int -> Int -> Int -> [Int]
10:43:56 <badkins> luite: ok
10:44:09 <luite> badkins: I think it would default to Integer
10:44:24 <chrisdone> roconnor: what's a tag?
10:44:29 <DustyDingo> thx
10:44:33 <badkins> luite: uh, where do I put that line :)
10:44:34 <RayNbow> you can always load your code in the interpreter and then query the inferred type
10:44:44 <badkins> man I have some reading to do...
10:44:47 <luite> badkins: above the dohanoi definition
10:44:51 <badkins> ok
10:45:15 <roconnor> chrisdone: it's a bit of data (at run time) that names the type of the associated value.
10:45:32 <badkins> luite: about 0.300s now, so an improvement
10:45:37 <C-Keen> Saizan: ah the darcs yi repo does use 95 but it needs parsec-3 (?!)
10:45:53 <badkins> ~ 18% drop in exec time
10:46:11 <luite> badkins: but Int may overflow, while Integer can represent arbitrary numbers
10:46:12 <chrisdone> roconnor: so there are types
10:46:27 <dons> luite: right, but here you're just shuffling symbols around
10:46:32 <badkins> right, but good to know if I can stay w/in the limit
10:46:34 <chrisdone> roconnor: you're just talking about the implementation
10:46:49 <luite> dons: true, but it still feels a bit like cheating ;)
10:47:26 <dons> n-1 is the only thing that has arithmetic involved
10:47:32 <roconnor> chrisdone: it is more than an implemenation issue.  You can switch based on the value of these tags
10:47:33 <solussd> i have a list of items of two types. for simplicity lets say they are 0 and 1, so [0,1,0,0,0,1,1,0,1]. For each item in the list I want to know whether it has 0, 1 or 2 1s as neighbors. I was thinking some kind of discrete convolution mask. i want to expand this to 2 dimensions. so, maybe i would have a list of lists and a neighbor for any item is left/right, up/down and both diagonals. any suggestions on how to best accomplish this? i
10:47:40 <dons> and you can't calculate hanoir in > maxBound 'n' anyway
10:48:14 <dons> ?users
10:48:14 <lambdabot> Maximum users seen in #haskell: 550, currently: 531 (96.5%), active: 29 (5.5%)
10:48:16 <vixey> solussd, what are the neighbours of the very first element?
10:48:35 <solussd> anything 'outside' the list would be a 0
10:48:45 <vixey> solussd, btw I would not use a list of lists, it's very awkward
10:48:48 <dolio> Please compute the solution for 2^64 discs. :)
10:48:49 <solrize> solussd i guess you'd process 3 scan lines at a time
10:49:08 <vixey> @let bits = [0,1,0,0,0,1,1,0,1]
10:49:09 <lambdabot>  Defined.
10:49:16 <luite> solrize: is the number of neighbours fixed, or can different convolution functions have different size kernels?
10:49:38 <solrize> yeah, for variable sized kernels it gets more complicated
10:49:46 <vixey> > let left = ([0]++) . init ; right = (++[0]) . tail in left bits `zip` bits `zip` right bits
10:49:48 <lambdabot>   [((0,0),1),((0,1),0),((1,0),0),((0,0),0),((0,0),1),((0,1),1),((1,1),0),((1,...
10:49:58 <luite> oh sorry solrize, I meant solussd
10:50:12 <solrize> probably should use arrays rather than lists anyway, to avoid so many conses
10:50:30 <vixey> > let left = ([0]++) . init ; right = (++[0]) . tail in map (\((l,_),r) ->l+r) (left bits `zip` bits `zip` right bits)
10:50:30 <dons> badkins: something else to ponder, http://hpaste.org/12068 slightly different pair representation
10:50:31 <lambdabot>   [1,0,1,0,1,1,1,2,0]
10:50:47 <badkins> dons: thx
10:51:16 <dons> solrize: were you asking about previews of the pdf?
10:51:18 <solussd> ohh. the convolution mask for the 1D example would be [1,0,1] . so applying it to a list [0,1,1,0] would result in [1,]1,1,1
10:51:26 <solrize> that wasnt me
10:51:31 <dons> askentasken: ?
10:51:32 <dolio> > let right = (++[0]) in (bits `zip` right bits) == (bits `zip` bits)
10:51:33 <lambdabot>   True
10:51:34 <dons> anyway, "A dynamic TOC should be available on the catalog page in a couple of days."
10:51:38 <badkins> I have to admit, that Haskell has surprisingly nice aesthetics considering how little of it I understand.
10:51:41 <solrize> adityam was asking about that
10:51:45 <dons> adityam: ah
10:51:45 <solussd> im very new to haskell-- there is a difference b/n arrays and lists?
10:51:52 <dons> yeah.
10:51:54 <dons> ?src []
10:51:54 <lambdabot> data [] a = [] | a : [a]
10:51:55 <solrize> solussd, lists are linked lists
10:51:58 <luite> solrize: quite a difference
10:52:02 <vixey> solussd: lists are consed up one by one, arrays are blobs wih O(1) indexing
10:52:04 <luite> aah :(
10:52:10 <luite> solrize: sorry again
10:52:11 <solussd> i c
10:52:25 <vixey> solussd, thing is, using lists of lists or 2D is so awkward
10:52:31 <vixey> for*
10:52:38 <solussd> that's what i was starting to notice
10:52:47 <dons> > [ (x,y) | x <- [1..10], y <- [1..10] ]
10:52:47 <irm> Hm.
10:52:48 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
10:52:49 <solussd> how do you define an array then?
10:52:58 <dons> using an array library, like Data.Array
10:53:10 <askentasken> so mapf = (. filter) . (.) . map workd
10:53:20 <askentasken> how can i simplify that?
10:53:58 <luite> askentasken: use what you got before you ran it through @pl? :P
10:54:30 <askentasken> @ pl?
10:54:35 <dolio> mapf f p = map f . filter p
10:54:35 <solrize> A manhunt is under way in western Germany for a convicted drug dealer who escaped by mailing himself out of jail.
10:55:06 <askentasken> ah nice
10:55:16 <askentasken> lol
10:56:54 <pstickne> solrize:  I think I'd have to let him go for pulling that off ^^
10:57:01 <solrize> hee
11:01:33 <EmielRegis> <solrize> A manhunt is under way in western Germany for a convicted drug dealer who escaped by mailing himself out of jail.
11:01:35 <EmielRegis> lmao
11:01:43 <idnar> hahaha, crazy
11:01:48 <EmielRegis> who posted himt hen?:p
11:05:57 <askentasken> board = [[0,0,0],[0,0,0],[0,0,0]]
11:06:13 <askentasken> if i want to change value at !! 1 !! 2 how can i do that?
11:06:38 <Lemmih> askentasken: Make a new board with the new value.
11:07:24 <glguy> let (a,_:b) = splitAt n xs in a ++ v : b -- something like that
11:08:01 <nolraiWest> @unmtl WriterT log (ErrorT error (StateT s (Reader env))) r
11:08:01 <lambdabot> s -> env -> (Either error (r, log), s)
11:08:15 <askentasken> yes but do i ahve to copy rach value then?
11:08:25 <askentasken> its like array[x][y] in python...
11:08:41 <askentasken> i know i could do it but im wondering if there is a simple way
11:08:44 <shapr> hiya yaxu, I enjoyed your flashlet.
11:09:02 <yaxu> hey shapr!
11:09:08 <Lemmih> askentasken: You might consider actually using an array.
11:09:17 <nolraiWest> @hoogle Writer a
11:09:17 <lambdabot> Did you mean: :: Writer a a /count=20
11:09:17 <lambdabot> Control.Monad.Writer.Lazy mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
11:09:17 <lambdabot> Control.Monad.Writer.Strict mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
11:09:42 <askentasken> what is diff between Array and Data.Array?
11:09:47 <nolraiWest> @hoogle Writer a a
11:09:47 <lambdabot> Did you mean: :: Writer a a /count=20
11:09:47 <lambdabot> Control.Monad.Writer.Lazy mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
11:09:47 <lambdabot> Control.Monad.Writer.Strict mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b
11:09:57 <yaxu> yep it's good to have audio rendering in a browser but shame it has to be flash
11:10:03 <shapr> Yeah, I agree.
11:10:32 <EvilTerran> askentasken, Array is haskell98; Data.Array is (as it's a heirarchical name) not h98, and hence can also have more stuff in it
11:10:37 * yaxu is still trying to get dynamic code loading working with current ghc
11:10:59 <shapr> yaxu: lambdabot's dynloading stuff doesn't work with 6.10?
11:11:29 <yaxu> hm i don't know, good pointer -- i'll have a look
11:12:14 <yaxu> it seems ghc-api isn't documented for mortals and don's plugins library isn't working with ghc-6.10
11:12:23 <nolraiWest> Whats a good type to use with Writer?
11:12:31 <vixey> Integer!
11:13:01 <EvilTerran> ... [a]?
11:14:19 <askentasken> seriously do i ahve tow rite a dunction to update an array?
11:14:32 <dino-> But if concerned about (++) efficiency for [a], maybe.. I don't know, Data.Set?
11:14:48 <Lemmih> askentasken: Note the difference between lists and arrays.
11:15:39 <dino-> Or maybe Data.Sequence
11:16:40 <Lemmih> askentasken: Use something else than a list and you'll be fine.
11:17:52 <askentasken> i cant even create an array
11:17:57 <askentasken> data.array i imported
11:18:06 <askentasken> cant do A.Array
11:18:15 <luite> askentasken: array or listArray
11:19:29 <askentasken> No instance for (Num [(i, e)])
11:19:39 <askentasken>  A.array 3 4
11:20:05 <luite> askentasken: it's a bit more complicated than that, you have to specify the bounds for the array, and a list with the values
11:20:51 <luite> askentasken: and keep in mind they're immutable, if you want to change just 1 element in a huge array, you have to construct a whole new array
11:21:02 <RayNbow> @src listArray
11:21:02 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:21:05 <RayNbow> @hoogle listArray
11:21:05 <lambdabot> Data.Array.Base listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
11:21:05 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
11:21:05 <lambdabot> Data.Array.Base listArrayST :: Ix i => (i, i) -> [e] -> ST s (STArray s i e)
11:22:06 <luite> askentasken: it may be easier/better to use a Data.Map instead
11:22:55 <luite> askentasken: at least you can update those efficiencly, without having to use complicated things like STArray
11:24:39 <ichor> Diff arrays is a nice compromise.
11:24:40 <Plouj> hi, why do I get this error: http://hpaste.org/12069
11:25:28 <luite> ichor: I thought that those were not really a useful alternative because of lack of a good implementation, and that Data.Map is preferred. has the situation changed now?
11:26:44 <monochrom> Not yet. But there is a call for re-implementing diffarray now.
11:26:58 <monochrom> We think it could be made fast.
11:27:03 <SamB> how ?
11:27:06 <int-e> Plouj: cabal: The program happy is required but it could not be found  is probably the real error
11:27:11 <adityam> dons: yes, I was asking about the previews.
11:27:21 <b_jonas> we always have Sequences
11:27:41 <Plouj> int-e: what can I possibly do about it. I didn't explicitly install 'happy'.
11:27:44 <ichor> luite, oh, I didn't know they were badly implemented. I just liked the idea :)
11:27:52 <Plouj> do about it?*
11:27:57 <b_jonas> which are based on a balanced tree but such a tricky one that pushing or popping on either end it fast (I dunno how they do that)
11:28:03 <adityam> dons: My main reason was to see how the book looks like before deciding if I want the paper version or the screen version
11:29:31 <int-e> Plouj: Well, install happy. I'd hope that  'cabal install happy'  works.
11:31:01 <Plouj> ok, that makes sense now and it seems to fix the problem
11:33:04 <Plouj> but, I still have another error
11:33:17 <roderyk> I'm struggling with my raytracer in terms of pixel colors; it's a little OT but maybe someone can help. I've been trying to read up on Phong shading, etc. but I'm missing some elemental issue of handling RGB. Is the basic algorithm something like: color = black + surfaceColor(ambient + diffused + specular) ?
11:33:39 <Plouj> http://hpaste.org/12071
11:34:53 <roderyk> eg. for diffused, we have (colorSurface * colorLightDiffused * kd * dot(N, L)) and this additive to all the other light sources?
11:35:15 <Plouj> roderyk: yea, the addition of various shadings is correct
11:35:56 <Plouj> roderyk: have you looked at http://nobugs.org/developer/htrace/ yet?
11:35:59 <lambdabot> Title: Haskell raytracer at nobugs.org
11:40:34 <luite> how can I do something like this, but returning the list itself, instead of the length:  (max `on` length) [1,2] [2,3,4,5]
11:40:51 <vixey> :t maximumBy
11:40:53 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
11:41:01 <vixey> :t maximumBy (comparing length)
11:41:02 <lambdabot> forall a. [[a]] -> [a]
11:41:12 <vixey> > maximumBy (comparing length) [ [1,2], [2,3,4,5] ]
11:41:13 <lambdabot>   [2,3,4,5]
11:41:16 <roderyk> Plouj: thanks, I will look at that now. Parts of it look almost identical to my code, except more eloquent. Talk about re-engineering an uglier wheel :)
11:41:16 <luite> ah, I should have seen that :)
11:41:18 <luite> thanks
11:41:20 <vixey> @let longest = maximumBy (comparing length)
11:41:22 <lambdabot>  Defined.
11:42:19 <idnar> isn't that somewhat inefficient?
11:42:27 <monochrom> yes
11:42:45 <idnar> is there a nice way to do it the efficient way?
11:42:55 <Deewiant> use an IntMap
11:43:37 <idnar> how exactly would that work?
11:44:10 <vixey> longest = maximumBy (comparing naturalLength)
11:44:10 <Deewiant> snd . IntMap.findMin . IntMap.fromList . map (length &&& id)
11:44:27 <Deewiant> well there's that too
11:44:33 <Deewiant> I was thinking of computing the length only once
11:44:37 <solrize> @hoogle naturalLength
11:44:37 <lambdabot> No results found
11:44:41 <idnar> @type naturalLength
11:44:42 <lambdabot> Not in scope: `naturalLength'
11:44:50 <vixey> naturalLength :: [a] -> Natural
11:44:55 <Deewiant> @let naturalLength = genericLength :: [a] -> Natural
11:44:56 <lambdabot>  Defined.
11:45:01 <idnar> Deewiant: mmph, okay, I was thinking of just doing that with a list
11:45:09 <idnar> it's still rather awkward, though, isn't there some way to generalise it?
11:45:12 <vixey> > naturalLength "fooo" < infinity
11:45:13 <lambdabot>   True
11:45:14 <solrize> :t (3 :: Natural)
11:45:14 <lambdabot> Natural
11:45:17 <vixey> > naturalLength "fooo" > infinity
11:45:18 <lambdabot>   False
11:45:24 <idnar> > (3 :: Natural)
11:45:25 <lambdabot>   3
11:45:28 <idnar> heh.
11:45:41 <dmwit> Are we talking about the Schwartzian transform today?
11:45:44 <solrize> > naturalLength ""
11:45:45 <lambdabot>   0
11:45:57 <idnar> > naturalLength (cycle "5") > 500
11:45:58 <lambdabot>   True
11:45:58 <Deewiant> yep
11:46:00 <dmwit> > naturalLength [0..] > naturalLength [3]
11:46:01 <lambdabot>   True
11:46:14 <vixey> > naturalLength [0..] == infinity
11:46:14 <dmwit> Nice, a lazy length.
11:46:28 <lambdabot>   mueval: Prelude.read: no parse
11:51:05 <Philonous> Is there a useable version of leksah?
11:51:13 <Philonous> The cabal version doesn't compile
12:06:52 <solrize> > naturalLength ([0..] ++ [1..5])
12:06:59 <lambdabot>   * Exception: stack overflow
12:07:17 <solrize> heh
12:07:22 <pumpkin_> o.O
12:07:51 <lilac> > naturalLength ([0..] ++ [1..5]) > naturalLength [0..]
12:07:59 <nolraiWest> @Hoogle Natrual
12:08:03 <lambdabot> Maybe you meant: google hoogle
12:08:03 <lambdabot>   mueval: Prelude.read: no parse
12:08:03 <nolraiWest> @Hoogle Natural
12:08:03 <lambdabot> Maybe you meant: google hoogle
12:08:09 <nolraiWest> @hoogle Natural
12:08:09 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
12:08:09 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
12:08:09 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
12:08:27 <lilac> nolraiWest: i think it's 'data Natural = Succ Natural | Zero'
12:08:50 <dmwit> ...with a few clever instances for Show, Num, etc.
12:09:01 <nolraiWest> vixey: whare is Natural defined?
12:09:02 <solrize> > Succ Zero
12:09:05 <lambdabot>   Not in scope: data constructor `Succ'Not in scope: data constructor `Zero'
12:09:13 <lilac> hi BONUS, how's Learn You a Haskell?
12:09:21 <solrize> :t infinity
12:09:23 <lambdabot> Natural
12:09:29 <lilac> @src Natural
12:09:29 <lambdabot> Source not found. There are some things that I just don't know.
12:09:32 <lilac> @index Natural
12:09:33 <lambdabot> bzzt
12:09:34 <dmwit> ?hackage nat
12:09:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nat
12:09:45 <solrize> > naturalLength [2,4..]
12:09:51 <lambdabot>   * Exception: stack overflow
12:10:24 <dmwit> > Pos (O IHi)
12:10:25 <lambdabot>   Not in scope: data constructor `Pos'Not in scope: data constructor `O'Not i...
12:10:45 <dmwit> Well, I guess it's not the nat package, then.
12:10:52 <hackage> Uploaded to hackage: rmonad 0.3
12:11:04 <byorgey> ooh, rmonad!
12:11:11 <Deewiant> ?hackage rmonad
12:11:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
12:11:29 <dmwit> Oh, hey, Set as a monad!
12:11:37 <dmwit> rmonad++
12:11:56 <luite> hm, I wonder how the notation is
12:12:01 <luite> for 'do'
12:12:02 <Saizan> ?hackage numbers
12:12:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
12:12:11 <dmwit> luite: It's identical, I guess.
12:12:25 <byorgey> wait, what is Heffalump doing hacking on rmonad with a one-week-old?  =O
12:12:25 <luite> dmwit: you sure? I thought that was impossible with restricted monads
12:12:27 <dmwit> luite: (He says you have to use NoImplicitPrelude, so presumably it overrides the old Monad class.)
12:12:32 <luite> ah
12:12:33 <byorgey> I guess you have to do something to stay sane =)
12:12:37 <luite> that explains
12:13:14 <byorgey> yes, rmonad is pretty nifty
12:13:26 <Saizan> one-week-old child?
12:13:31 <byorgey> it's not just Set, but anything which needs some sort of class constraint
12:14:06 <byorgey> Saizan: indeed!  http://urchin.earth.li/aegean/baby/
12:14:08 <lambdabot> Title: Alexander Suresh Kerr Sittampalam
12:14:54 <dmwit> Well, what other monads do people wish for that require class constraints?
12:15:01 <yaxu> shapr: lambdabot needs mueval which needs hint which currently needs ghc 6.8
12:15:08 <dmwit> I mean, Ord is a reasonable class constraint to require, thanks to the axiom of choice...
12:15:12 <yaxu> i think i'll play with hint under 6.8
12:15:14 <byorgey> dmwit: um, well...
12:15:22 <byorgey> dmwit: but you COULD
12:15:26 <dmwit> ;-)
12:15:26 <byorgey> ;)
12:16:58 * ddarius didn't even know Heffalump was married (or maybe I did...)
12:17:06 <lilac> yaxu: lambdabot uses mueval as a binary; i have a 6.10 lambdabot which uses a 6.8 mueval
12:17:56 <yaxu> lilac: so the dynamic loading part works under 6.10?
12:18:11 <lilac> how can i test?
12:18:36 <yaxu> i don't know but as this is haskell I guess if it compiles it will work
12:19:03 <lilac> in that case, it works!
12:19:08 <yaxu> :)
12:19:22 <vegai> lambdabot is a rather special case ...
12:22:30 <Saizan> if by dynamic loading you mean load plugins at runtime then i'd be very surprised
12:23:21 <yaxu> yep that's what i meant
12:23:33 <yaxu> i want to play with dynamic loading/reloading of haskell code
12:23:56 <yaxu> thought lambdabot might offer some example code
12:24:09 <yaxu> seems the easiest is to go back to 6.8 for this though
12:27:22 <Saya> So i havent done much 'non functional' stuff in haskell, and im trying to do a small game. Id like to have entities each with their own state and a world state containing the entities etc... how would i do that without having to keep around 5 layers of state monads in all my functions (any advice?)?
12:28:27 <monochrom> Use a thread for one entity.
12:30:58 <vixey> nolraiWest: I don't know look on hoogle or somethig
12:31:19 <vixey> Saya, actually conal showed me this
12:31:53 <dons> Saya: use a single State monad, containing a record.
12:32:07 <dons> if you really want layers, use layers (and MonadTrans to lift automatically between them)
12:32:09 <vixey> Saya, http://conal.net/fran/ -- looks like a good way to do it to me
12:32:13 <lambdabot> Title: Functional Reactive Animation (Fran)
12:32:18 <dons> there's lots of example games on hackage
12:32:23 <dons> so you could look there for inspiration
12:32:25 <vixey> Saya, oops meant http://conal.net/fran/tutorial.htm
12:32:26 <lambdabot> Title: Composing Reactive Animations
12:36:57 <dmwit> Is it just me, or is (not . null) way more useful than null?
12:37:06 <Beelsebob> yes, yes it is
12:37:32 <vixey> :t (>0) . naturalLength
12:37:33 <lambdabot> forall a. [a] -> Bool
12:37:39 <vixey> :t not . null
12:37:40 <lambdabot> forall a. [a] -> Bool
12:37:56 <dmwit> I want a pithy name for not . null.
12:38:08 <dmwit> So that I can stop doing not . null $ ps and start doing pithy ps.
12:38:20 <vixey> CONSP
12:38:23 <vixey> PAIR?
12:38:25 <C-Keen> not. null is easy to read
12:38:33 <dmwit> not . null is not easy to type.
12:38:44 <dmwit> (not . null) is even worse.
12:38:49 <Deewiant> not (null ps)
12:38:51 <jpcooper> dmwit, have you never heard of key macros?
12:39:00 <vixey> I usually cons for something like liftA (:) or whatever, but 'cons' is an adequate name for not . null
12:39:01 <jpcooper> :p
12:39:22 <dmwit> Deewiant: Useless when I want to use it in, say, a map or filter.
12:39:28 <Deewiant> not.null
12:39:34 <idnar> dmwit: notNull? :P
12:39:35 <C-Keen> not $ null ps
12:39:40 <Deewiant> not that much worse than nonNull or whatever
12:39:41 <dmwit> Compare: filter pithy foo; filter (not . null) foo
12:39:54 <Deewiant> just call it 'x' and be done with it
12:39:54 <dmwit> I could drop the parens and the separate tokens.
12:39:55 <Deewiant> filter x foo
12:40:10 <dmwit> "populated" is too long
12:40:23 <dmwit> hmm
12:40:39 <vixey> positive
12:40:43 <dmwit> "hay"
12:40:52 <vixey> :t positive
12:40:53 <lambdabot> Not in scope: `positive'
12:40:53 <dmwit> For the Spanish-speaking Haskellers. =)
12:41:20 * dmwit adds to Dmwit.hs
12:44:22 <byorgey> just set  iDontCareAboutEmptyLists = filter (not . null), then use that
12:44:31 <trofi>   what will use lambdabot as eval engine for ghc-6.10?
12:45:56 <vixey> >_<
12:46:29 <monochrom> iMac = filter (not . cheap)
12:46:54 <dmwit> mac = 0014:4432:dead:babe
12:47:08 <monochrom> dead babe is not hot
12:47:14 <C-Keen> :t array
12:47:15 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
12:47:45 <C-Keen> :t Array
12:47:46 <lambdabot> Not in scope: data constructor `Array'
12:47:49 <C-Keen> hm
12:51:15 <Saya> vixey: thanks! well your tutorial is not really about state but interesting nonetheless :)
12:51:27 <vixey> Saya, oh I didn't write t
12:51:55 <Saya> by your i meant the one you showed :p
12:53:11 <C-Keen> :t (:)
12:53:11 <lambdabot> forall a. a -> [a] -> [a]
12:53:22 <C-Keen> :t (++)
12:53:23 <lambdabot> forall a. [a] -> [a] -> [a]
12:54:01 <vixey> :t flip intercalate
12:54:02 <lambdabot> forall a. [[a]] -> [a] -> [a]
12:54:14 <Saya> hmm that article is pretty hold seems like the reactive paradigm didnt really take off although it looks awesome for stuff like guis
12:54:39 <Saya> *old
12:55:55 <dmwit> ?pl \old new -> intersection (union old new) new
12:55:56 <lambdabot> join . (intersection .) . union
12:56:03 <dmwit> What, no ap?
12:56:14 <dmwit> :t ap
12:56:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:57:00 <dmwit> ?undo \old -> do { x <- union old; intersection x }
12:57:01 <lambdabot> \ old -> union old >>= \ x -> intersection x
12:57:20 <dmwit> union old >>= intersection -- beautifully obfuscated
12:58:22 <Saizan> ..i hate type synonyms.. most of the time they just mean that to find out what a type really means i've to browse two 3-levels of haddock pages twice, since at the end of the first run i've forgotten some of them.
12:58:50 <monochrom> Heh heh heh
12:59:00 <askentasken> hwo do i jst create an array?
12:59:05 <dmwit> :t listArray
12:59:07 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
12:59:07 <monochrom> The same can be said about function definitions.
12:59:13 <askentasken> imm using dta,arry dn ci nt even figur tt out
12:59:26 <dmwit> > listArray (0, 5) [30..]
12:59:28 <lambdabot>   array (0,5) [(0,30),(1,31),(2,32),(3,33),(4,34),(5,35)]
12:59:54 <dmwit> There's also "array" if your build process is more complicated.
12:59:55 <dmwit> :t array
12:59:56 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
13:00:29 <sutats> Does Haskell have something like ARGV?
13:00:36 <dmwit> getArgs
13:00:39 <monochrom> It is more about the lack of high-level specification than allowing synonyms, macros, definitions.
13:00:43 <dmwit> ?hoogle getArgs
13:00:44 <lambdabot> System.Environment getArgs :: IO [String]
13:00:47 <dmwit> ?hoogle getName
13:00:47 <lambdabot> No results found
13:00:55 <sutats> dmwit: Thanks.
13:00:57 <dmwit> ?hoogle IO String
13:00:58 <lambdabot> Did you mean: :: IO String /count=20
13:00:58 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
13:00:58 <lambdabot> System.IO.Error ioeSetErrorString :: IOError -> String -> IOError
13:01:07 * dmwit blinks
13:01:14 <dmwit> Yes, as a matter of fact, I *did* mean IO String.
13:01:21 <dmwit> ...that's why I typed it.
13:01:36 <dmwit> oh
13:01:40 <dmwit> ?hoogle :: IO String
13:01:41 <lambdabot> Prelude getContents :: IO String
13:01:41 <lambdabot> Prelude getLine :: IO String
13:01:41 <lambdabot> System.IO getContents :: IO String
13:02:01 <dmwit> ?hoogle+
13:02:01 <lambdabot> System.IO getLine :: IO String
13:02:01 <lambdabot> System.Environment getProgName :: IO String
13:02:01 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
13:02:08 <dmwit> getProgName, not getName.
13:02:09 <dmwit> ah well
13:02:25 <Saizan> monochrom: you mean that those apis are bad and that type synonyms are just a product of that?
13:03:00 <monochrom> If I write like "define x = long RHS", and export x for you to see, it should be because I can describe x to you in a shorter and more high-level way than making you read the RHS.
13:03:24 <monochrom> And so it comes down to documentation and specification.
13:03:31 <BfrOv3rfl0w> has anyone amongst you written a haskell webservice?
13:03:49 <Taejo> Saizan: was it you who asked about the necessity of the post-fold function in my "Beautiful Folds" post?
13:04:10 <dmwit> BfrOv3rfl0w: Yes, some of us have.  You should just ask the question you're interested in.
13:04:43 <Saizan> right, instead most of the time i see synonyms that are there just to make shorter types.
13:04:44 <BfrOv3rfl0w> I need some tuts or resources to get to know how to write a webservice in haskell
13:04:55 <Saizan> Taejo: i don't think so
13:05:07 <BfrOv3rfl0w> dmwit: or at least to understand the service if i have the source
13:05:09 <dmwit> ?go happs tutorial
13:05:13 <lambdabot> http://www.haskell.org/haskellwiki/HAppS_tutorial
13:05:13 <lambdabot> Title: HAppS tutorial - HaskellWiki
13:05:16 <monochrom> Due to most or all Haskell compiler nature, "type X = long RHS" the long RHS is exported with X. But this is just for the compiler. The author should not require the audience to read it.
13:05:27 <vixey> I write type synonyms like type DeBruijn = Integer
13:05:40 <vixey> is this just confusing for everyone except me?
13:05:47 <dmwit> No.
13:05:58 <luite> I do that too
13:06:08 <BfrOv3rfl0w> lambdabot, dmwit: thx
13:06:10 <vixey> (I do this to make the big   data  ... = ...  things actually descriptive)
13:06:16 <RLa> vixey, only for those who does not know what DeBruijn is
13:06:34 <dmwit> It always makes me chuckle when people thank lambdabot.
13:06:36 <dmwit> ?botsnack
13:06:36 <lambdabot> :)
13:06:38 <vixey> RLa, that's ok, nobody that doesn't know what DeBruijn is will care about my code :)
13:06:58 <vixey> (neither will those that do I suppose.. )
13:07:32 * FunctorSalad is undecided whether 'type' declarations for 'soft' safety are a good thing
13:07:47 <FunctorSalad> 'soft' as in 'does not get checked, but gives a hint to the user'
13:08:09 <vixey> FunctorSalad, you don't mean that every use of type should be replaced with newtype?
13:08:21 <nolraiWest> hmm.
13:08:32 <FunctorSalad> vixey: no, I mean that I'm not experienced enough to really tell :)
13:08:33 <RLa> is that really "soft" in haskell like it is in pascal?
13:08:38 <Taejo> Saizan: sorry, it was sjanssen. I get confused with the S names for some reason
13:09:00 <vixey> FunctorSalad, in this same code I have mixes like  newtype Gensym = Gensym Integer vs type DeBruijn = Integer
13:09:14 <RLa> in pascal you could app oranges and apples if both were integer eq types
13:09:19 <FunctorSalad> RLa: yes, type synonyms just get replaced
13:09:19 <RLa> add*
13:09:24 <RLa> oh
13:09:30 <FunctorSalad> RLa: for actual safety you use newtype
13:09:45 <FunctorSalad> (but then you need to wrap/unwrap)
13:09:55 <RLa> oh dear, never knew that
13:09:58 <vixey> I use newtype to say this has some semantic difference to <whatever>
13:10:07 <vixey> and type to give something a more specific name
13:10:32 <vixey> It seems to me that it would make things terribly awkward and less clear if you replace every use of type with newtype
13:10:33 <FunctorSalad> vixey: some types have a semantic difference thoug, like type FilePath = String
13:10:49 <vixey> FunctorSalad, I'd use a newtype there
13:10:51 <FunctorSalad> "semantic" as in "real-world meaning" here
13:10:52 <hackage> Uploaded to hackage: arff 0.0.1
13:11:03 <vixey> or would I .. I am not sure
13:11:46 <FunctorSalad> vixey: maybe if we used fmap rather than explicit construction / pattern matching?
13:12:04 <monochrom> The case of ãtype FilePath = Stringã is there is a semantic difference but we prefer not to be pedantic about it.
13:12:34 <monochrom> I guess it generalizes. type synonym is when you introduce a new semantic idea but don't wan't to be anal.
13:13:07 <monochrom> newtype is when you want to be so anal that you want compiler to check things.
13:13:13 <FunctorSalad> is it a good idea to derive Monad for newtypes?
13:13:20 <FunctorSalad> ("derive")
13:13:29 <monochrom> Yes. But doesn't always works.
13:13:41 <monochrom> Oh I mean auto-derive doesn't always works.
13:14:02 <monochrom> If you can prove that you have a monad, sure.
13:14:03 <FunctorSalad> not even for newtype? isn't it just the identity monad but with renaming?
13:14:52 <FunctorSalad> OTOH I rarely put functions into newtypes so Functor might be enough
13:14:55 <monochrom> You can always give it a try. I hit some non-working example but it's complicated.
13:15:19 <Taejo> monochrom: surely the newtype is isomorphic by definition?
13:15:25 <FunctorSalad> I don't remember, can newtypes have typeclass contexts? then it wouldn't be a monad in general
13:16:58 <nolraiWest> Im deriving from IdT's monad instance right now so i think that works. But I dont have a context on the newtype itself.
13:21:39 <nolraiWest> :t log
13:21:40 <lambdabot> forall a. (Floating a) => a -> a
13:21:40 <vixey> @undo do m <- e m ; n <- e n; f m n
13:21:41 <lambdabot> e m >>= \ m -> e n >>= \ n -> f m n
13:21:48 <vixey> @pl e m >>= \ m -> e n >>= \ n -> f m n
13:21:48 <lambdabot> (e n >>=) . f =<< e m
13:21:58 <vixey> @src on
13:21:59 <lambdabot> (*) `on` f = \x y -> f x * f y
13:22:33 <vixey> (*) `om` f = \x y -> do x' <- x; y' <- y; f x' * f y'
13:22:41 <vixey> :?
13:25:02 <dmwit> I don't think so.
13:25:21 <dmwit> Unless you really want "om" to be significantly different from "on". =)
13:25:52 <dmwit> :t \op f x y -> do x' <- x; y' <- y; f x' `op` f y'
13:25:53 <lambdabot> forall (t :: * -> *) t1 t2 t3. (Monad t) => (t2 -> t2 -> t t3) -> (t1 -> t2) -> t t1 -> t t1 -> t t3
13:26:02 <roconnor> > iterate (^2) 1
13:26:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:26:06 <roconnor> > iterate (^2) 2
13:26:08 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
13:26:43 <roconnor> > 2^1024
13:26:45 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
13:26:46 <dmwit> > iterate (^2) 2 !! 6
13:26:48 <lambdabot>   18446744073709551616
13:26:52 <dmwit> > iterate (^2) 2 !! 8
13:26:54 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
13:26:57 <dmwit> > iterate (^2) 2 !! 12
13:26:57 <FunctorSalad> monochrom: nevermind what I just said about newtypes... I confused the "newtype" operator itself (on the metalevel) with actual type constructors like "data Foo a = Foo (Bar a)" which needn't be monads
13:26:58 <lambdabot>   104438888141315250669175271071662438257996424904738378038423348328395390797...
13:26:59 <olsner> hmm, the ghc build process is disturbingly serial
13:27:01 <dmwit> wow
13:27:06 <roconnor> thoses are big numbers
13:27:07 <dmwit> > iterate (^2) 2 !! 16
13:27:09 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
13:27:12 * dmwit stops
13:27:36 <roconnor> I'm not to sure GHC would handle polynomials of that degree
13:30:24 <sutats> dmwit: You helped me clean up some of my code yesterday (http://hpaste.org/12017), but I just changed some things around and was hoping you could suggest some more improvements.
13:31:12 <nolraiWest> can you have "newtype Bob = Bob [Alpha]"?
13:31:32 <Taejo> the moment has come where I wished for dynamicity: I want to change the definition of whiteSpace in Parsec.Token
13:32:01 <dmwit> nolraiWest: Certainly.
13:32:05 <olsner> @ty listArray . (,) (1,1)
13:32:06 <lambdabot> forall e t t1. (Num t1, Num t, Ix t1, Ix t) => (t, t1) -> [e] -> Array (t, t1) e
13:32:12 <dmwit> sutats: Looks good, though I would s/(contents)/contents/
13:32:16 <vegai> Taejo: cannot you just define your own with a different name and use that?
13:32:24 <dmwit> olsner: Needs more (.):
13:32:33 <dmwit> :t (listArray .) . (,) (1,1)
13:32:34 <lambdabot>     Couldn't match expected type `a -> (i, i)'
13:32:34 <lambdabot>            against inferred type `((t, t1), a1)'
13:32:34 <lambdabot>     Probable cause: `(,)' is applied to too many arguments
13:32:37 <dmwit> err
13:32:48 <dmwit> No, you were right.
13:32:50 <dmwit> dmwit--
13:32:51 <olsner> dmwit: ehm... no it doesn't :)
13:32:53 <nolraiWest> > map (head . show) itterate (2^) 2
13:32:53 <vegai> (.) -- the cowbell of Haskell
13:32:54 <lambdabot>   Not in scope: `itterate'
13:33:17 <Taejo> vegai: well, yes, that is what I *will* do, but I'll have to copypasta everything that *uses* it as well (so it uses my definition)
13:33:17 <nolraiWest> > map (head . show) iterate (2^) 2
13:33:18 <lambdabot>   Couldn't match expected type `[a]'
13:33:34 <vegai> I got a fever! And the only prescription... is more function composition!
13:33:37 <nolraiWest> > map (head . show) $ iterate (2^) 2
13:33:49 <sutats> dmwit: Thanks. Also, the whole case part takes up a lot of lines. Is there any way to condense that?
13:33:52 <lambdabot>   thread killed
13:33:58 <dons> "
13:34:01 <olsner> vegai: more functional kool-aid! :)
13:34:04 <dmwit> sutats: The other thing you could maybe do is: do { [maze] <- getArgs; ... } or maybe do { (maze:_) <- getArgs }
13:34:13 <dmwit> sutats: But that's really a nitpick; overall your code looks very nice.
13:34:22 <dons> "excellence at a complex task requires a critical, minimum level of practice - surfaces again and again in studies of expertise. In fact, researchers have settled on what they believe is a magic number for true expertise: 10,000 hours"
13:34:24 <dmwit> sutats: You could do:
13:34:36 <dons> there you go. haskell takes 10k hours.
13:34:44 <dons> shapr: ^ http://www.guardian.co.uk/books/2008/nov/15/malcolm-gladwell-outliers-extract
13:34:47 <dmwit> sutats: fromMaybe Invalid . lookup [(' ', Open), ('X', Wall), ...]
13:34:50 <dmwit> :t lookup
13:34:56 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:34:56 <lambdabot> Title: Malcolm Gladwell asks is there such a thing as pure genius? | Books | The Guardi ..., http://tinyurl.com/6jsvo7
13:35:00 <olsner> dons: we should have some #haskell stats to see how far we've come and who's leading :)
13:35:04 <dmwit> Okay, flip lookup, then. =)
13:35:25 <dons> heh
13:35:26 <sutats> dmwit: Hm, interesting. Thanks for those suggestions.
13:35:34 <dons> practice every day.
13:35:49 <dons> never go a day without writing more haskell, or reading more haskell. then you'll be done soon enough.
13:36:05 <dmwit> > 10000 / 365
13:36:06 <lambdabot>   27.397260273972602
13:36:17 <dons> days.
13:36:19 <dmwit> 8 hours a day for 3 years... sounds low
13:36:25 <dons> yep
13:36:28 <olsner> 27h/day for a year and you're done!
13:36:49 <dons> #haskell's been running for 60480 hours.
13:36:50 <dmwit> Although, if you figure in how many working days you actually get in a year, let's see...
13:37:05 <roconnor> @go 10000 days in years
13:37:08 <lambdabot> http://en.wikipedia.org/wiki/10,000_Days
13:37:08 <lambdabot> Title: 10,000 Days - Wikipedia, the free encyclopedia
13:37:40 <dons> "To become a chess grandmaster also seems to take about 10 years. (Only the legendary Bobby Fischer got to that elite level in less than that time: it took him nine years.) And what's 10 years? Well, it's roughly how long it takes to put in 10,000 hours of hard practice."
13:38:09 <dmwit_> > 10000 / 240
13:38:10 <lambdabot>   41.666666666666664
13:38:10 <LLing2008> Hello
13:38:23 <dmwit_> Yep, ten years at 4 good hours per day.
13:38:31 <dmwit_> (Which seems like a reasonable assumption.)
13:38:49 <beso> does somebody has a book: Salomaa, Theory of Automata
13:38:52 <beso> ?
13:38:54 <dons> i've almost completed 9 years of haskell, of which 6 are full time. so 4 years to go.
13:38:55 <dmwit> LLing2008: Hiya!
13:39:33 <sutats> ?index fromMaybe
13:39:33 <lambdabot> Data.Maybe
13:39:34 <dons> while, say, JaffaCake's had about 15 years full time.
13:40:25 <dons> lennart's had about ~20 years full time, i suppose
13:40:52 <vegai> sounds like you're talking about prison sentences
13:41:02 <dons> grand master status :)
13:41:16 <dons> or hard time.
13:41:18 <dons> either way.
13:41:28 <profmakx> :/ that would be an additional 9 years for me
13:41:48 <dons> well, if you do more each day, it takes less time.
13:41:49 <LLing2008> I'm new to haskell, and i'm getting this compiler error i just don't know how to fix, can anyone help me? http://hpaste.org/12074#a0
13:41:53 <vegai> there's a huge difference between seeing something as interesting, and studying it a bit
13:42:02 <luite> long way to go, with my 5 months non-fulltime :(
13:42:05 <profmakx> theres my maths phd that wants to be done
13:42:08 <vegai> and basing part of one's employment on something
13:42:13 <dons> one thing that helps keep up regular practice is try to answer user questions every day
13:42:30 <dons> LLing2008: main :: IO ()
13:42:44 <dons> it does some IO and returns () (notionally)
13:42:47 <LLing2008> right, thanks
13:43:05 <dons> vegai: yeah, so if you can get it as part of your employment, then that makes it easier.
13:43:17 <dons> employment is good for racking up 8 hr haskell days
13:43:43 <vegai> I actually had a few of those this week
13:43:44 <profmakx> hm. i should just go for something more CIRCA and do computational algebra in haskell
13:43:47 <vegai> first time in my life
13:43:53 <Taejo> dons: once I have a PhD, I may attempt to find a haskell job
13:43:59 <vegai> it'll be interesting to see what happens when rest of the company realizes this :P
13:44:06 <idnar> hmm
13:44:16 <idnar> I have no clue how much time I've spent on any particular language
13:44:17 <dons> vegai: well, mitigate risk as much as you can
13:44:21 <dons> and try not to scare people
13:44:28 <dons> vegai: demonstrating clear advantages is probably good
13:44:51 <luite> impress people with your l33t points-free style ;)
13:45:02 <dons> well. ... not sure
13:45:17 <olsner> luite: we're after *not* scaring people away :)
13:45:26 <nolraiWest> @source toList
13:45:26 <lambdabot> toList not available
13:45:40 <vegai> one of our strongest coders actually told me that he thinks Haskell is way too difficult
13:46:02 <olsner> "way too difficult"?
13:46:07 <vegai> I think it was Hudak's book that scared him off
13:46:11 <profmakx> steep learning curve
13:46:23 <vegai> unfortunately, the only haskell book I own
13:46:44 <sutats> dmwit: http://hpaste.org/12017#a7
13:46:59 <vegai> a good book in many ways, but apparently not the best idea to give it to newcomers
13:47:25 <C-Keen> I liked thompson's book
13:48:12 <dons> vegai: maybe point him at rwh.
13:48:16 <vegai> a much better idea was to show a Parsec parser I had made
13:48:21 <vegai> dons: yes, that too
13:48:27 <dons> something modern and less academically focused.
13:48:33 <dons> vegai: yeah, parsec ftw.
13:48:36 <profmakx> btw. real world haskell rocks
13:48:43 <dons> yay!
13:48:58 <Soliah> is rwh a book?
13:49:03 <profmakx> i read some of the chapters online i will definitely be buying that book
13:49:06 <kynky> yeah its a well good read
13:49:10 <dons> ?go realworldhaskell
13:49:12 <profmakx> real world haskell
13:49:12 <lambdabot> http://www.realworldhaskell.org/
13:49:12 <lambdabot> Title: Real World Haskell
13:49:21 <dons> digital editions started shipping today.
13:49:26 <Soliah> oh nice
13:49:30 <dons> hard copies in the next couple of weeks.
13:49:32 <Soliah> i like oreily publications
13:49:41 <Soliah> should be on safaribooks then
13:49:41 <profmakx> its good in many ways ;) because it shows you how to solve real problems
13:49:48 <kynky> i like those english video lectures from german univeritty too
13:49:53 <C-Keen> I had just a friend ask me about a palindrome exercise, is there a better way than x ++ (drop 1 $ reverse x)?
13:50:00 <profmakx> that helps silencing people who say that haskell is only a research language
13:50:21 <dons> yeah, you have to fight the smears like that.
13:50:26 <dolio> @quote JonHarrop
13:50:26 <lambdabot> JonHarrop says: As Haskell has shown, laziness cannot be implemented efficient at all.
13:50:32 <dons> just look at today's hackage releases. all things like flickr, numerics, web apps
13:50:46 <dons> an ical parser, a wiki
13:51:00 <Soliah> damnit
13:51:01 <dons> http://archhaskell.wordpress.com/2008/11/15/arch-haskell-news-nov-15-2008/ <- very practically-oriented code production
13:51:02 <kynky> scm
13:51:03 <lambdabot> Title: Arch Haskell News: Nov 15 2008 Â« Arch Linux and Haskell, http://tinyurl.com/669rn4
13:51:03 <Soliah> it's not on oreily
13:51:08 <dons> Soliah: sure.
13:51:15 <Soliah> yea i just searched :<
13:51:18 <dons> nope.
13:51:27 <dons> Soliah: http://oreilly.com/catalog/9780596514983/
13:51:31 <lambdabot> Title: Real World Haskell | O'Reilly Media
13:51:49 <Soliah> I mean safaribooks online :<
13:52:06 <dons> ah let me see...
13:52:22 <dolio> , src 'ViewL
13:52:24 <lunabot>  luna: Not in scope: data constructor `ViewL'
13:52:28 <dolio> , src ''ViewL
13:52:29 <lunabot>  luna: Not in scope: type constructor or class `ViewL'
13:52:34 <dolio> Bah.
13:52:36 <vixey> , src 'viewL
13:52:38 <lunabot>  luna: Not in scope: `viewL'
13:52:44 <dolio> @seen mmorrow
13:52:44 <lambdabot> I saw mmorrow leaving #darcs, #ghc and #haskell 9h 5m 44s ago, and .
13:52:45 <dons> oh, its been tested on iphone.
13:52:59 <dolio> , viewl
13:53:01 <lunabot>  luna: Not in scope: `viewl'
13:53:10 <Soliah> oh well
13:53:14 <Soliah> i'll just buy the book
13:53:18 <dolio> @tell mmorrow No Data.Sequence in lunabot?
13:53:18 <lambdabot> Consider it noted.
13:54:40 <ksf> C-Keen, x == reverse x
13:54:48 <ksf> modulo map toLower
13:55:19 <vixey> @let modulo = on
13:55:21 <lambdabot>  Defined.
13:55:30 <C-Keen> ksf: that's not a palindrome
13:55:34 <ksf> ah, you ain't matching, you're generating.
13:55:38 <vixey> > ((==)`modulo`map toLower) "foo" "OOf"
13:55:39 <lambdabot>   False
13:56:02 <ksf> it's a predicate that tells you whether x's a palindrome.
13:56:32 <olsner> @ty modulo
13:56:33 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:56:37 <C-Keen> ksf: ah ok
13:56:43 <C-Keen> ksf: then I agree :)
13:57:07 <olsner> aha, vixey had just defined modulo to 'on' ... sneaky
13:57:08 <ksf> what's all this stuff about taking modulo literally?
13:58:11 <idnar> @type on
13:58:12 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:58:18 <idnar> oh, of course
13:58:27 <beso> does somebody has a book: Salomaa, Theory of Automata?
14:01:49 <dmwit> beso: Amazon has it.
14:02:42 <dmwit> sutats: Did you figure out your problem?
14:03:29 <dmwit> sutats: Just drop the 'c' argument, as you don't use it anyway.
14:03:56 <dmwit> sutats: (i.e. as it is defined there, charToMazeNode :: a -> Char -> MazeNode)
14:05:38 <adimit> hello. I have been trying, on and off, for the last two weeks to get recent versions of gtk2hs to compile. Without success on four different systems (all of which were linux.) Are there currently any known problems of that sort?
14:06:05 <adimit> if you want to ask for error-messages, well, they are surprisingly different each time.
14:06:18 <dmwit> gtk2hs has a binary distribution, doesn't it?
14:06:31 <dmwit> (It's a pretty darn big library if you want to compile it yourself.)
14:06:36 <dons> adimit: should build fine.
14:06:39 <dons> esp. on linux.
14:06:46 <adimit> ok, so the error is with me, thanks.
14:06:51 <dons> it'll depend on what C libraries you have.
14:07:03 <dons> talk to dcoutts_ about it, if you can't get it to build
14:07:14 <adimit> dmwit: well, Debian had an old version, arch doesn't have the binary as a package.
14:07:20 <dmwit> Anyway, yeah, I use it just fine here with a pretty recent version -- 0.9.12 -- so definitely post more details if you can't figure it out.
14:07:35 <dmwit> adimit: gtk2hs' website has their own packages, I think.
14:07:39 <dmwit> http://sourceforge.net/project/showfiles.php?group_id=49207&package_id=42440
14:07:46 <adimit> yes, I'll try them, too, if all else fails.
14:08:00 <ksf> > (((. reverse) . (==)) `modulo` map toLower) "Foo" "OOf"
14:08:01 <lambdabot>   True
14:08:12 <ksf> > (((. reverse) . (==)) `modulo` map toLower) "Foo" "raB"
14:08:13 <lambdabot>   False
14:08:20 <Twey> :t on
14:08:21 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:08:34 <dmwit> > ((==) `on` map toLower) "Foo" "fOO"
14:08:35 <lambdabot>   True
14:08:40 <sutats> dmwit: Ah, thanks, forgot about that c.
14:08:44 <trofi> @src on
14:08:45 <lambdabot> (*) `on` f = \x y -> f x * f y
14:08:53 <sutats> dmwit: Makes it look cleaner too without that.
14:10:44 <Deewiant> > (((>>>) >>> (>>>) (>>>)) (==) reverse `modulo` map toLower) "Foo" "OOf"
14:10:46 <lambdabot>   True
14:10:52 <hackage> Uploaded to hackage: reactive 0.9.1
14:10:52 <hackage> Uploaded to hackage: TypeCompose 0.6.0
14:11:23 <shapr> dons: Hah, cool
14:11:29 <badkins> dons: "i've almost completed 9 years of haskell, of which 6 are full time. so 4 years to go." academia, or professional? Just curious about real world Haskell hacking.
14:11:48 <adimit> dons: currently, it seems, I'm getting an error in the haskell code. http://pastebin.com/m2c07286e
14:12:33 <Saizan_> adimit: ah, you're using ghc 6.10
14:13:03 <Saizan_> adimit: there's a patch for building gtk2hs under that on the mailing list iirc
14:13:04 <adimit> Saizan_: remarkable. How did you find out :-)
14:13:22 <LLing2008> I'm writing a quicksort, and i need to reject duplicates with 'error' or abort, how would I do this, http://hpaste.org/12075
14:13:25 <adimit> Saizan_: aha. OK. Needless to say, I tried using 6.8, too, and it didn't work.
14:13:28 <Saizan_> Module `Control.Exception' does not export `throwDyn'
14:13:57 <adimit> OK, I'll need to patch it then. Thanks very much for the hint.
14:14:14 <jeffwheeler> LLing2008: homework?
14:14:18 <LLing2008> yes
14:14:25 <LLing2008> i'm stuck
14:15:14 <ksf> "reject with error or abort" is kinda strange.
14:15:19 <ksf> error does exactly that.
14:15:41 <lilac> LLing2008: you could sort the list, then scan through it looking for adjacent pairs with the same key.
14:15:47 <LLing2008> yeah, my prof doesn't really make sense
14:16:07 <Saizan_> adimit: i've built it fine a couple times under 6.8, maybe you also ha've problems with the C libs
14:16:16 <adimit> probably, yes.
14:16:21 <LLing2008> lilac: I assumed I could do it during the sort
14:16:39 <lilac> LLing2008: or you could do it while you sort. your quicksort pivots on every element, so you have three cases: y < x, y == x and y > x
14:17:02 <dons> badkins: 5 years phd, 1 year commercial
14:17:04 <lilac> LLing2008: you already handle y<x and y>x in your recursive calls to quicksort
14:17:22 <lilac> LLing2008: you could handle y==x similarly.
14:17:26 <badkins> dons: math or cs ?
14:17:43 <dons> CS. programming languages.
14:17:48 <dons> adimit: ah!
14:17:52 <dons> you're on ghc 6.10
14:17:56 <badkins> gotcha, well, Haskell seems to fit the bill then :)
14:18:00 <LLing2008> lilac: right, and i just need error?
14:18:01 <dons> i'm not sure there's been a release of gtk2hs for 6.10 yet.
14:18:32 <ksf> > error "yes"
14:18:33 <lambdabot>   * Exception: yes
14:18:36 <profmakx> i should try some parallel stuff on our 16 core machine
14:18:39 <dmwit> LLing2008: You should use Maybe or Either instead. =)
14:18:41 <dons> shapr: so daily study. i'm interested in ways to help people get into daily programming
14:18:46 <dons> profmakx: for sure. you could help the DPH effort
14:18:51 <lilac> LLing2008: it depends how you do it. the troulbe with error checks in haskell is that sometimes they don't happen due to laziness.
14:18:55 <adimit> dons: Yes, Saizan_ told me so. My current solution is to back off to 6.8. Just giving it another run, let's see if it goes through.
14:19:03 <dons> yep.
14:19:09 <dons> 6.8.x is a more stable compiler to use anyway
14:19:12 <profmakx> we have a few computational algebra things lying around that i wanted to try out in haskell
14:19:18 <profmakx> so i could try that in parallel
14:19:24 <dons> seems like a killer app to me.
14:19:51 <lilac> LLing2008: but something simple like, "qsort ... = if error condition then error "Same keys" else normal condition" can work
14:19:57 <adimit> parallel garbage collection sounded like an interesting thing to toy with. But I haven't the time currently, anyway.
14:20:19 <monochrom> If an error check doesn't happen due to laziness, that means it does not matter.
14:20:31 <dons> adimit: parallel GC with gtk2hs ? :)
14:20:38 <dons> sounds like an interesting collision
14:20:41 <monochrom> ãif True then 0 else error "not true"ã there is no problem.
14:20:57 <dons> kids these days with their idiom brackets
14:21:02 <lilac> monochrom: not necessarily. consider: f n = let check = if n < 0 then error "negative" else () in isqrt n
14:21:05 <ksf> the problem is that you can't force the exceptions by pulling values, as you just can't get hold of them.
14:21:12 <lilac> in a strict language, that'd guard the result of f
14:21:24 <dons> its easy enough to write a catch/handle that's rnf strict.
14:21:26 <adimit> dons: well, no, my interest in the two is independent. But it does sound kinky.
14:21:29 <dons> i wonder why no one's done that.
14:21:42 <dons> Control.Exception.Strict
14:21:52 <monochrom> Well alright, but that is a strange way to code a check, even in strict languages.
14:22:25 <dons> i guess the main thing is errors embedded in unevaluated structures
14:22:27 <monochrom> Everyone in C writes like if (n<0) then error("blah") else { normal computation }
14:22:35 <ksf> but then, if you're trying to check data, you should definitely pull your errors. yet another argument against error and bottom in general.
14:22:38 <dons> catch (1, 2, undefined)
14:23:00 <ksf> f n | n < 0 = error "too small"
14:23:42 <dmwit> There's no "then" in C. ;-)
14:23:59 * ksf tries to decide whether -2 is larger or smaller than -1
14:24:23 <dons> are you standing on your head?
14:24:29 <monochrom> there are two "larger"s
14:24:32 <vegai> #define then /* so there */
14:24:38 <ryant50001> has anyone put ghci on Windows Mobile?
14:29:17 <Taejo> @let f91 = if x > 100 then x - 10 else f91 $ f91 $ x + 11
14:29:18 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Expr'
14:29:29 <Taejo> @let f91 x = if x > 100 then x - 10 else f91 $ f91 $ x + 11
14:29:30 <lambdabot>  Defined.
14:29:34 <Taejo> f91 1
14:29:40 <Taejo> > f91 1
14:29:40 <vixey> > map f91 [1..]
14:29:42 <lambdabot>   91
14:29:42 <lambdabot>   [91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91...
14:29:45 <vixey> > map f91 [90..]
14:29:47 <lambdabot>   [91,91,91,91,91,91,91,91,91,91,91,91,92,93,94,95,96,97,98,99,100,101,102,10...
14:30:36 <dons> nice to see someone parsing with binary+bytestring+bytestring-lexing, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/arff
14:30:37 <lambdabot> Title: HackageDB: arff-0.0.1
14:31:56 <adimit> ok, this is the error I can reliably produce with ghc 6.8 on both arch linux and debian sid installs: http://pastebin.com/m268c3ec (I'm sorry if I bother you, but I'm pretty helpless here.)
14:32:12 <adimit> I do have all dependencies which are listed (says the ./configure script).
14:32:59 <Saizan> uhm, are you building a release tarball?
14:33:22 <adimit> yes.
14:33:27 <LLing2008> lilac: Thanks a bunch! Ended up with http://hpaste.org/12077 which works fine.
14:33:29 <adimit> .13
14:34:34 <dons> adimit: are you using the arch gtk2hs package?
14:34:44 <dons> $ yaourt --aur -S haskell-gtk2hs
14:34:54 <dons> 'gtk2hs' sorry,
14:34:56 <dons> not haskell-gtk2hs
14:35:07 <dons> ah!
14:35:09 <adimit> dons: yes and no. fails manually and with yaourt.
14:35:16 <dons> a cairo function has changed.
14:35:31 <dons> do you see the diff on the AUR page?
14:35:32 <adimit> so a current cairo is not compatible anymore with gtk2hs
14:35:40 <adimit> I'll have a look at it.
14:35:50 <dons> there's a diff here, http://aur.archlinux.org/packages.php?ID=14890
14:35:51 <lambdabot> Title: AUR (en) - gtk2hs
14:36:13 <dons> can you report that to the gtk2hs team?
14:36:19 <dons> along with a link to the patch
14:36:26 <dons> then you should be fine.
14:36:46 <adimit> ok, I'll do so. thanks.
14:37:42 <adimit> right. argh. I haven't been on arch for a while and lost the habit of reading aur comment threads.
14:41:21 <shapr> dons: Probably puzzle based
14:41:31 <shapr> dons: That way you don't have to load a bunch of state..
14:41:38 <shapr> or better abstractions like DSLs specific to a task
14:42:24 <shapr> dons: Or some sort of quality access from ubiquitous devices like cellphones or PDAs.
14:45:26 <dons> mmm.
14:45:53 <shapr> dons: Lower the cost of entry
14:46:05 <shapr> dons: Research paper RSS feed
14:46:23 * ddarius doesn't know what shapr and dons are talking about.
14:46:30 <dons> mm. research paper rss feed.
14:46:47 <shapr> With included introductory material that shows where to put a research paper in a mental map.
14:46:58 <dons> but lower costs of entry
14:47:02 <dons> that's the main thing
14:47:06 <shapr> Right
14:47:09 <dons> like a rubiks cube. easy to pick up and toy around
14:47:13 <shapr> exactly
14:47:18 <dmwit> LtU is kind of like a research paper RSS feed.
14:47:23 <shapr> That's part of why lambdabot was so successful.
14:47:25 <dons> yeah
14:47:28 <shapr> dmwit: Yeah, sort of...
14:47:40 <shapr> It doesn't furnish context though.
14:47:47 <shapr> So it's often hard to jump in and read a paper.
14:47:58 <dmwit> true enough
14:48:09 <shapr> dons: Another part of lambdabot's success comes from the social reinforcement aspect.
14:48:10 <bbs> hey guys
14:48:12 <bbs> how is everyone :)
14:48:24 <dmwit> Hiya, bbs!
14:48:28 <dmwit> Everyone is grand. =)
14:48:44 <dons> shapr: yeah, we all learned how to use Reader (->) because of lambdabot
14:48:47 <dons> daily reenforcement
14:48:50 <shapr> Exactly
14:49:17 <shapr> #haskell golf is exactly that sort of thing, small daily bits of study.
14:50:10 <bbs> dmwit: :)
14:50:14 <bbs> i has no questions todays
14:50:25 <bbs> you should be proud
14:50:36 <bbs> ghci and i bonded
14:50:38 <bbs> a bit more
14:50:45 * vixey forgot what the hell she was going to do
14:51:27 <bbs> my olpc is being pissy though
14:51:31 <vixey> hi gwern
14:51:36 <bbs> and i'm too lazy to work on compcache right now
14:52:11 <orbitz> hi vixey
14:52:42 <lispy> dons: what is this minimal imports flag?
14:52:57 <lispy> dons: I suspect it is subsumed by -Wall
14:53:33 <Saizan> -ddump-minimal-imports?
14:59:40 <gwern> vixey: hi
15:03:14 <lispy> :t ap
15:03:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:04:24 <Axman6> hmmmm, using par and STM does not seem to work very well
15:04:29 <Axman6> or, not at all in my case
15:04:41 <Axman6> keep getting 'thread blocked indefinitely'
15:04:52 <EvilTerran> par and STM are completely different models
15:05:03 <Axman6> i know
15:05:25 <Axman6> dons said i should use it instrad of forkIO
15:06:36 <vegai> what are you using from STM, Axman6?
15:07:46 <Axman6> i'm using a shared variable to check whether a number has been seen before when creating a tree
15:07:46 <dmwit> On that note, is there some way of mixing ST and parallelism?
15:08:05 <dmwit> I was just curious about it and hadn't really looked into it, so if it's really easy, I'm sorry for asking...
15:08:09 <gwern> > let uncat3 [] = [] ; uncat3 xs = (let (ys, zs) = splitAt 3 xs in ys : uncat3 zs) ; getFrom x y = map (x !!) $ map (fromIntegral . ((\x -> fromIntegral $ foldl (.|.) (0::Word8) (zipWith (\c n -> if c then bit n else (0::Word8)) x [0..2])) :: [Bool] -> Int)) $ reverse . uncat3 . reverse . concat . map (((\x -> map (testBit x) [7,6..0]) :: Word8 -> [Bool]) . fromIntegral . ord) $ y in getFrom " HWdelor" "e\184-\235"
15:08:10 <lambdabot>   "Hello World"
15:08:28 <vixey> very concise!
15:08:51 <gwern> ...I'm going to add that to my mueval tests since I'm impressed at how many functions it uses
15:10:52 <hackage> Uploaded to hackage: hprotoc 1.0.0
15:10:52 <hackage> Uploaded to hackage: protocol-buffers-descriptor 1.0.0
15:10:52 <hackage> Uploaded to hackage: protocol-buffers 1.0.0
15:11:18 <profmakx> who posted the modular arithmetic stuff? or does anyone know where its flying around?
15:12:42 <xcthulhu> > [0,1] >>= (\x -> [0,1] >>= (\y -> [(x,y)]))
15:12:43 <lambdabot>   [(0,0),(0,1),(1,0),(1,1)]
15:13:16 <EvilTerran> > (,) <$> [0,1] <*> [2,3]
15:13:17 <lambdabot>   [(0,2),(0,3),(1,2),(1,3)]
15:13:55 <LLing2008> hello, does anyone know how to write  a binary search function: binsearch :: String -> Integer -> Integer -> String   (  from the sorted list of strings, a )
15:15:00 <xcthulhu> sounds like a homework problem.
15:15:12 <LLing2008> yes, it is.
15:15:37 <EvilTerran> yeah... that doesn't really make sense to do in haskell
15:15:48 <EvilTerran> seeing as it takes O(n) to get the n'th element of a list anyway
15:16:21 <vixey> LLing2008: I don't really get it
15:16:34 <vixey> LLing2008: so you have like  ["a","b","c","d"] and then what?
15:17:04 <dons> lispy: no, it is different to -Wall
15:18:02 <vixey> Why not make a binary tree out of the strings and then binary searching shourd be really aesy
15:18:47 <LLing2008> actually i have [("a", 1), ("b", 2), ("c", 3), ("d", 4), ("e", 5)]. i'm looking for "e" i want to get back 5
15:19:11 <ddarius> dmwit: I don't believe so.  You could use unsafeIOToST and see what happens.
15:19:44 <vixey> LLing2008: so it's  [(String,Integer)] -> String -> Integer /
15:19:45 <vixey> ?
15:19:57 <LLing2008> yeah
15:19:57 <dmwit> ddarius: *nod*
15:20:06 <dmwit> :t lookup
15:20:07 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:21:29 <ddarius> :t (<*)
15:21:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
15:21:51 <EvilTerran> ?src (<*)
15:21:51 <lambdabot> (<*) = liftA2 const
15:22:00 <EvilTerran> (/= flip (*>))
15:22:25 <ddarius> :t fmap ($)
15:22:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f (a -> b)
15:23:05 <EvilTerran> "fmap id = id"
15:23:10 <ddarius> indeed
15:25:27 <ryant50001> where can i read about the new extensible exceptions?
15:26:28 <olsner> @ty foldl (flip id) `asTypeOf` foldr id
15:26:29 <lambdabot> forall b. b -> [b -> b] -> b
15:28:40 <orbitz> the stdlib documetnation on haskell.org doesn't have anything under Char, is that a mistake?
15:28:52 <dons> Data.Char
15:29:24 <orbitz> would i want to import Data.Char rather than Char?
15:29:50 <ryant50001> iirc, Char is deprecated; everything was moved to Data.Char a couple years ago
15:30:03 <vixey> @hoogle every
15:30:03 <lambdabot> Data.Generics.Schemes everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
15:30:03 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
15:30:03 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
15:30:06 <vixey> @hoogle everyM
15:30:06 <lambdabot> No results found
15:30:48 <orbitz> ryant50001: ok thanks
15:33:31 <dons> orbitz: you would , yes.
15:33:40 <dons> 'Char' is a H98 construct
15:33:48 <dons> only available via the haskell98 package
15:34:04 <dons> (which is guaranteed to always stay around, fwiw)
15:34:58 <Botje> yaaaaaaaaaaaay
15:35:02 <Botje> my transformation finally works
15:35:35 <dons> yya
15:35:53 <vixey> what transformation?
15:35:57 <Botje> and it only took me 5 hours
15:36:16 <Botje> vixey: a bastardised CPS, basically
15:36:20 <vixey> oo
15:36:23 <vixey> code !
15:36:24 <vixey> :)
15:36:46 <Botje> hmm, sec
15:37:24 <monochrom> Oh bother. Why do I keep typing Handel for Handle?
15:37:32 <Botje> http://wilma.vub.ac.be/~dharnie/code
15:37:34 <lambdabot> Title: Index of /~dharnie/code
15:37:43 <Botje> monochrom: type Handel a = Handle a
15:37:51 <vixey> arh!!!
15:37:57 <vixey> Botje I typeng that :p
15:38:02 <Botje> vixey: transformation itself is in TM/Tm9k.hs
15:38:06 <dmwit> For opening musical files. ;-)
15:38:42 <Botje> basically, the idea is to write an interpreter in a nice recursive elegant shiny fashion
15:39:13 <Botje> and convert it into an ugly hideous clutter of thunks that can be used in a real-life (tm) virtual machien
15:39:17 <Botje> s/en$/ne/
15:39:48 <ddarius> Botje: See Olivier Danvy's work.
15:40:02 <vixey> Botje, by formal transformation ? or by just hacking?
15:40:54 <Botje> vixey: mostly hacking, it's basically "ensure eval is always in tail position"
15:41:03 <ddarius> Botje: http://lambda-the-ultimate.org/node/2423#comment-38384
15:41:04 <lambdabot> Title: A functional correspondence between evaluators and abstract machines | Lambda th ...
15:42:03 <bbs> sbahra: ping
15:42:31 <vixey> humm I can hardly read it
15:42:36 <Botje> ddarius: hmm, i'll give it a read, thanks :)
15:42:51 <Botje> vixey: yeah, it's far from pretty or readable at the moment
15:42:59 <Botje> as things get less hacked up, stuff should improve
15:43:55 <vixey> Botje, I know how to make your 'eval' simpler
15:44:37 <Botje> the one in Eval.hs?
15:44:40 <vixey> yes
15:44:46 <Botje> do tell :)
15:45:41 <vixey> Botje, the method is eval & unquote in http://rascal-haskell.googlecode.com/svn/trunk/HOAS.hs pretty much
15:46:19 <vixey> (You'd have to put eval in a monad to get strictness of course)
15:47:14 <sbahra> bbs, pong
15:47:24 <bbs> sbahra: freebsd question
15:47:31 <bbs> and i didn't want to messa round in ##fbsd
15:47:31 <sbahra> bbs, sure
15:47:37 <bbs> may i pm since its OT
15:47:46 <sbahra> Sure.
15:48:44 <vixey> Botje, I think this Tm9k is hard to read because there is a lot of dealing with fresh vars free vars bound vars
15:49:27 <vixey> Botje, maybe if you did it with DeBruijn indices (basically what 'next' is doing cut down to the bare minimum) it would help, or even HOAS but I don't know that would work out to the end
15:49:39 <vixey> (still trying to understand it)
15:50:15 <Botje> i'm staring at HOAS too
15:50:42 <vixey> I mean it works really well in lambda-Prolog but that doesn't mean you can do it in haskell too
15:50:55 <ddarius> @google CINNI
15:50:56 <lambdabot> No Result Found.
15:51:09 <ddarius> http://formal.cs.uiuc.edu/stehr/cinni_eng.html
15:51:10 <lambdabot> Title: CINNI - A Calculus of Indexed Names and Named Indices
15:51:37 <vixey> I never understad why people are interested in explicit substitutions
15:51:47 <vixey> Don't you want them be totally hidden?
15:52:04 <Botje> i don't know any better :]
15:52:14 <vixey> I mean that CINNI stuff and so on
15:52:22 <vixey> "calculus of explicit substitutions"
15:52:46 <Botje> oh
15:52:50 <Botje> i read the abstract
15:55:12 <vixey> I like this 'local' bit you have
15:55:17 <vixey> I need something like that
15:56:09 <Saizan_> A distinctive advantage of CINNI is that it completely eliminates the problematic translation between the notation that is visible by the user of a system and the internal representation. <- i guess this is the main point
16:06:21 <mib_emq8xcku> hi there... anybody have time for a quick naive question?
16:08:54 <roconnor> how do I evaluate the derivative of f at 0 in maxima?
16:10:06 * roconnor screws it, and uses limit to evaluate a polynomial
16:10:52 <hackage> Uploaded to hackage: haskell-src-exts 0.4.2
16:17:45 <luite> Plugin/Eval.hs:70:14: Not in scope: data constructor `HsModule'  <- what can cause this error? I'm trying to compile lambdabot with ghc 6.10.1, haskell-src 1.1.0.3 is installed
16:25:12 <sutats> Say I have "data Direction = N | S | W | E", what's a concise way of defining an opposite function (opposite W = E) without defining each individually?
16:25:17 <Lemmih> luite: It has probably been renamed.
16:26:10 <thoughtpolice> a 4 case definition is about as concise as it will get, i think
16:26:15 <dmwit> sutats: There is not likely to be a more concise way for such a short enumeration.
16:26:46 <sutats> Okay, thought so.
16:27:24 <sutats> Even if I somehow define them in pairs?
16:28:31 <sutats> Actually, that sounds like it would be more trouble than just defining them.
16:28:36 <sjanssen> sutats: can you define the directions as "N | E | S | W"?
16:29:04 <ddarius> sjanssen: And then use +2 mod 4
16:29:11 <sjanssen> ddarius: exactly
16:29:15 <sjanssen> with deriving Enum
16:30:17 <sutats> sjanssen: Sure, that's possible. Does that allow me to make it more concise?
16:30:30 <sjanssen> sutats: yes, using addition and mod
16:30:55 <sutats> sjanssen: Could you explain that?
16:31:19 <sutats> Oh, I see the logic now.
16:32:25 <sutats> How do you apply a +2 to something that's not an integer though?
16:32:46 <sjanssen> fromEnum can turn any Enum into an Int
16:36:42 <profmakx> @hoogle (a,b) -> (b,a)
16:36:42 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
16:36:42 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
16:36:42 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
16:36:53 <sjanssen> @djinn (a, b) -> (b, a)
16:36:54 <lambdabot> f (a, b) = (b, a)
16:37:00 <sjanssen> @. pl djinn (a, b) -> (b, a)
16:37:00 <lambdabot> f = uncurry (flip (,))
16:37:05 <profmakx> well
16:37:10 <sutats> What did I do wrong here: opposite d = (+ (fromEnum d) 2) `mod` 4
16:37:11 <profmakx> i will go with lambda
16:37:44 <sjanssen> sutats: Haskell is not lisp :)
16:37:49 <sjanssen> sutats: the + should be infix
16:38:07 <sutats> Oh, I thought you could prefix + for some reason
16:38:21 <sjanssen> sutats: also, that doesn't have the type you want
16:38:42 <Twey> sutats: You can, by surrounding it with brackets
16:38:52 <Twey> (+) x y === x + y
16:38:57 <sutats> Twey: Ah, that's what I was trying to do.
16:39:00 <BMeph> sutats: if you write it separately in parens, you can. But as sjanssen mentioned, Haskell is not Lisp. :)
16:39:09 <Twey> But yes, it's bad style.  :)
16:39:49 <sutats> Yeah, infix works better here.
16:39:52 * mwotton_ can't work out if it's moronic or inspired to run a virtual machine to get 64 bit ints...
16:40:05 <sutats> sjanssen: Do I need a toEnum or something like that now?
16:40:15 <BMeph> Unless you're the inventor of Haskell, in which case, it's merely odd. As in the-relative-that-lives-in-the-attic "odd". :)
16:40:26 <Twey> 'Eccentric'
16:40:27 <BMeph> Er, s/Haskell/Liskell/
16:40:32 <Twey> :-D
16:40:36 <sutats> Haha
16:40:48 <sjanssen> sutats: yep
16:41:25 <sutats> opposite d = toEnum $ ((fromEnum d) + 2) `mod` 4
16:41:31 <sutats> That's about as simple as it can get?
16:41:37 <sjanssen> looks good
16:41:39 <ddarius> drop the parens around the fromEnum d
16:41:50 <sutats> Oh, right.
16:41:58 <Twey> sutats: Excessive brackets are usually considered bad in Haskell :-P
16:42:13 <Twey> 'As few as possible' is the watchword, generally speaking.
16:42:25 <sutats> Twey: It definitely looks better and it's easier to read that way too./
16:42:53 <ddarius> @pl opposite d = toEnum $ (fromEnum d + 2) `mod` 4
16:42:53 <lambdabot> opposite = toEnum . (`mod` 4) . (2 +) . fromEnum
16:43:20 <Twey> What, like (toEnum (mod ((+) (fromEnum d) 2) 4))?
16:43:51 <sutats> Twey: No, I meant fewer brackets and parentheses
16:43:59 <Twey> Ohh.
16:44:01 <Twey> Yes, indeed.
16:44:05 <sutats> ddarius: Is that form better because it drops the reliance on d?
16:44:17 <BMeph> Or write it (what's a good name for this?) - way: opposite d = toEnum . (`mod` 4) . (+2) . fromEnum $ d
16:44:25 <Twey> sutats: I would say so.
16:44:39 <nolraiWest> Is that realy better than "opposite N = S /n opposite E = W /n opposite S = N /n opposite W = E"
16:44:44 <idnar> BMeph: isn't it a bit pointless (tee hee) to explicitly put the point(s) back in like that?
16:44:49 <ddarius> nolraiWest: Personally, I'd say no.
16:45:04 <Twey> I would agree with ddarius and nolraiWest.
16:45:36 <ddarius> sutats: Whether you want it that way or not is taste, but in this case it is a relatively nice composition of functions and it clearly illustrates the passage to/from Int.
16:45:52 <BMeph> idnar: :)
16:45:57 <Twey> sutats: Point-free can express some concepts much more clearly and elegantly.
16:46:14 * BMeph snorts at idnar and the obligatory 'point-less' joke.
16:46:15 <Twey> If you try it on others, it'll make a mangled mess out of them.  :)
16:46:18 <sutats> ddarius: Yeah, reading it over, I can follow the logic much more clearly with the pointless.
16:46:40 <sutats> Point-free, rather.
16:46:46 <Twey> Heh
16:46:54 <Twey> BMeph: I would call it 'point-free plus added redundancy' :-P
16:47:32 <BMeph> Yeah, point-free loses its charm when you have more than one argument. Unless you come from a Forth or Forth-like background. :)
16:47:48 <idnar> pointfreeless
16:47:52 <Twey> Now that's not true
16:47:59 <BMeph> Twey: "Compositional-style"? :)
16:48:08 <Twey> I'd like to call it 'chained'
16:48:47 <BMeph> Twey: "Point-less Workers of the World, Unite! You have nothing to Lose but your Chains!" :)
16:48:55 * Twey laughs.
16:48:56 <sutats> It's probably faster to execute the opposite N = S, opposite W = E, etc version too.
16:49:09 <Twey> The explicit version is clearer, though, aye.
16:49:10 <Saizan_> btw, opposite = toEnum . (`mod` 4) . (2 +) . fromEnum by itslef won't compile because of the DMR
16:49:30 <Twey> DMR?
16:49:40 <Twey> What's the D?  :-P
16:50:22 <Saizan_> dreaded
16:50:54 <Twey> Ah :)
16:51:01 <sutats> I guess I want to know the MR bit, then.
16:51:05 <Twey> I guess it's the chained version we want, then.
16:51:12 <Twey> sutats: 'Monomorphism Restriction'
16:51:17 <BMeph> Functional Programming is OO-style, taken to a more abstract form. We use dynamic dispatch, but at the value-level, not the type-level. :)
16:51:33 <Twey> Heh :)
16:51:42 <sutats> Ah.
16:52:12 <BMeph> I think everyone knows Object-Oriented style is a mistake. Why else do they say "O-O" when they describe it? ;)
16:52:35 <Twey> I don't know, I quite like OO
16:52:38 <Saizan_> sutats: the Monomorphism restriction says that a definition without arguments (like opposite there) can't have a typeclass context unless you give it an explicit type signature
16:52:45 <Twey> Done properly, anyway.
16:53:50 <sutats> Saizan_: So if I include opposite :: Direction -> Direction (where data Direction = N | S | ...) it's okay?
16:54:02 <Saizan_> sutats: yup
16:54:09 <sutats> Saizan_: Okay, good, I included that already.
16:54:38 <geezusfreeek> i _used_ to like OO
16:55:30 <BMeph> Twey: I like using it for simulations, but beyond that, it feels like trying to sculpt with a hammer - like using the wrong tool for the job.  But what do I know, I still like Forth programming. :)
16:55:45 <geezusfreeek> oops, i mean... I.removeFromLikes(ProgrammingParadigm.OO)
16:55:45 <Twey> I use it mostly for organisation
16:56:10 <Twey> geezusfreeek: That's OO Done Wrong.  ;-)
16:56:24 <Twey> OO Done Right is CLOS.
16:56:43 <geezusfreeek> Twey, yes, CLOS is a good implementation of OO
16:57:00 <geezusfreeek> i also like Io and kind of like JavaScript
16:57:05 <Twey> Yeah
16:57:14 <geezusfreeek> but i still don't like OO itself
16:57:34 <Twey> I'm working on developing a Javascript-similar language with generics and without some of the limitations of Javascript's OO
16:57:34 <pstickne> Any good CLOS intro/comparison with other OO systems?
16:57:50 <Twey> pstickne: PCL does the former and a little of the latter
16:57:52 <pstickne> limitations with JS OO? :-)
16:57:58 <pstickne> Twey:  thanks
16:58:10 <Twey> pstickne: Most of them stem from 'new'
16:58:20 <pstickne> Ahh ^^
16:58:31 <Twey> It's basically prototypical, but you can't do a proper clone, because there are hidden properties that can only be set by the appropriate constructor
16:58:43 <Twey> (with 'new')
17:00:41 <FunctorSalad> what again was the argument that java interfaces are a bad analogy to explain typeclasses?
17:00:59 <mwotton_> can you cast from Word64 to Int? I don't want to use fromIntegral, i can't afford to pass a dictionary round
17:01:08 <mwotton_> and i only care about the bit patterns being distinct
17:01:12 <Twey> FunctorSalad: Typeclasses can specify default behaviour?
17:02:02 <Saizan_> FunctorSalad: typeclasses aren't types, interfaces incorporate dynamic dispatch
17:03:13 <Saizan_> also typeclasses were kind of invented to solve OO's problem with binary methods
17:03:24 <sjanssen> mwotton_: is your Int 64 bits?  If so, GHC will optimize the fromIntegral away
17:03:24 <FunctorSalad> fair enough, though the analogy still doesn't seem *that* bad to me :)
17:03:25 <pstickne> Saizan_:  "problem with binary methods?"
17:03:41 <Twey> pstickne: foo.add(bar) vs. bar.add(foo)
17:03:55 <pstickne> Twey:  how is that a problem?
17:03:58 <Saizan_> which is worse with .equal
17:03:59 <FunctorSalad> I think he means methods that dynamically dispatch depending on *two* args
17:04:09 <mwotton_> sjanssen: yeah, it is. i'll give it a go - the dictionary was killing me on the old version, but that was running on the Mac, and i can't get 64 bit running natively there
17:04:10 <geezusfreeek> pstickne, where does it really belong?
17:04:23 <Twey> pstickne: It doesn't actually belong to either class
17:04:23 <monochrom> It seems not so much typeclass as hindley-milner polymorphism that solves the binary method problem. The problem is due to subclass polymorphism.
17:04:28 <sjanssen> mwotton_: just be sure to optimize with -O2 and you should be okay
17:04:33 <Saizan_> pstickne: that foo and bar could be of two different subclasses, and so you don't really know which implementation you get
17:04:54 <monochrom> For example SML also solves the binary method problem.
17:05:33 <FunctorSalad> monochrom: isn't the problem solved in haskell in the first place by not having anything like dynamic dispatch? ;)
17:05:44 <FunctorSalad> I might be wrong
17:05:55 <monochrom> Yeah, basically just kill OOP and you don't have a problem! :)
17:06:04 <Twey> Haskell does have dynamic dispatch...
17:06:05 <Saizan_> exactly :)
17:06:11 <monochrom> OO = object obsession
17:06:17 <Twey> Additionally, that's again not a problem with OO, but a problem with dispatching on the first argument
17:06:25 <Twey> CLOS can do binary methods with no problem
17:06:27 <geezusfreeek> my main problem with OO is the whole idea that objects do stuff to themselves. it blurs several fundamental concepts about abstraction and code vs. data in my mind
17:06:32 <FunctorSalad> Twey: yeah
17:06:35 <monochrom> Heh I speak too strongly.
17:07:00 <Saizan_> Twey: does clos have subtyping?
17:07:28 <monochrom> Just kill all mainstream languages.
17:07:35 <Twey> geezusfreeek: Blurring that doesn't occur with functional languages, where functions are data?  :-P  Haskell does the same thing with records containing functions.
17:07:41 <Twey> Saizan_: Yes
17:07:57 <FunctorSalad> Twey: ah, I was just going to ask whether you meant these
17:07:58 <mwotton_> sjanssen: hm. hang on, i should clarify: if i have a Word64, and 64 bit Ints, can i assume every value of Word64 has a unique mapping onto an Int?
17:08:15 <pstickne> Twey:  how can m-dispatch solve that problem? Wouldn't add(a,b) still be dependent upon the exact types of a and b?
17:08:22 <mwotton_> i don't really care about what value it actually has, i'm just worried about overflow
17:08:26 <geezusfreeek> at least my haskell functions don't operate on themselves
17:08:36 <Saizan_> Twey: if foo :: C -> C -> Bool, and  A,B < C, how is foo (x ::A) (y :: B) resolved?
17:09:13 <geezusfreeek> i see message passing as a compelling argument for OO, but i think erlang does is far better than any OO language i've seen
17:09:45 <geezusfreeek> or any other architecture with absolute separation between processes like that
17:09:49 <Twey> Saizan_: As foo (x :: C) (y :: C), unless there's a more specific instance of the method
17:10:12 <Twey> Saizan_: In CLOS, methods aren't functions and don't have types by themselves
17:10:31 <geezusfreeek> *erlang or any other architecture [etc]
17:10:47 <Saizan_> Twey: i guess they are macros
17:10:50 <Twey> You have one method, which serves as a sort of placeholder and specifies the number of arguments, then you have a series of specialisations, actual functions to which method calls are dispatched based on the types of the arguments
17:10:52 <hackage> Uploaded to hackage: ztail 1.0
17:10:55 <monochrom> Yeah geezusfreeek. Someone asked how to do a game program in haskell, with multiple entities each with internal state. I thought for a while and said, one thread per entity. Erlang encourages that too.
17:11:02 <sjanssen> mwotton_: with GHC on a 64-bit system, yes
17:11:26 <Twey> monochrom: Aye, that's COP all right
17:11:31 <geezusfreeek> time to go
17:11:38 * Twey likes COP.
17:11:59 <Saizan_> COP?
17:12:07 * pstickne is glad Saizan_ asked ;)
17:12:12 <FunctorSalad> :)
17:12:19 <Twey> Heh
17:12:20 <monochrom> corpulating orc programming
17:12:23 <Twey> Concurrency-Oriented Programming
17:12:37 <Twey> The style Erlang encourages
17:12:45 <Saizan_> oh, i didn't know we had a name for that :)
17:12:59 <Twey> Where the program is organised into actors
17:13:58 <monochrom> Mainstream people fear concurrency because their communication primitives are archaic. Like shared memory and locks.
17:14:07 <Twey> Aye
17:14:23 <Twey> Concurrency really isn't a difficult problem.  It's just that the mainstream solutions suck.
17:14:51 <Twey> If you organise your program according to COP, you get it pretty much for free.
17:15:22 <ddarius> Twey: Not everything splits nicely into Erlang-style message passing.
17:15:27 <dons> awesome: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/matlab-0.1
17:15:27 <Twey> Also, COP structure â having lots of little worker threads all buzzing around independently of one another â is awesome.
17:15:31 <lambdabot> Title: HackageDB: matlab-0.1, http://tinyurl.com/5oza3f
17:15:32 <Saizan_> FRP might be nicer in the end
17:15:36 <Twey> ddarius: True.  Many things do, though.
17:15:43 <ddarius> Twey: Agreed.
17:15:52 <monochrom> Everything that splits nicely in OOP splits nicely in COP too.
17:16:03 <monochrom> Proof: implement OOP by message passing.
17:16:07 <Twey> And quite a lot of things that don't.
17:16:15 <Twey> monochrom: *cough*Self*cough*
17:16:29 <Twey> Not concurrent, but hey
17:16:42 <monochrom> "splitting nicely in OOP" is well studied and every programmer knows how to do it because it's so bloody mainstream.
17:17:05 <Twey> As are the hacks to get around things that don't.
17:17:13 <dons> "A collection of professional quality Python software tools which enhance Python's usability" <-- why does that sound warning bells
17:17:27 <Twey> dons: Because it's marketing-speak?
17:17:31 <monochrom> It's a tautology.
17:17:41 <Twey> So was that.
17:17:41 <dons> heh
17:17:42 <Twey> :)
17:17:58 <dons> professional at what?
17:18:10 <Twey> dons: Does it matter?  It's PROFESSIONAL
17:18:15 <Twey> It's like 'enterprise'
17:18:24 <Twey> Who cares what it actually does, it must be good!
17:18:32 <dons> ah. so used inside an enterprise? like ghc? and xmonad. and darcs.
17:18:32 <monochrom> what is "python software tool"?  development tool for python?  other tool written in python?
17:18:41 <dons> python software tool. hmm
17:18:53 <Twey> dons: No, no, those aren't Enterprise.
17:18:58 <Twey> They may be used in enterprises, but they aren't Enterprise.
17:19:01 <dons> oh, Enterprise.
17:19:10 <dons> like on board the star ship enterprise
17:19:16 <Twey> A tool isn't Enterprise until the PHBs flock towards it.
17:19:25 <dons> ah i see.
17:19:41 <dons> yes, we're a bit of a way from that still.
17:19:46 <dino-> I keep thinking I'm going to have to learn Python sooner or later as a least-crappy backup plan for jobs. Not thrilled about it.
17:19:51 <monochrom> "professional" probably means "like Visual Studio"
17:19:54 <Twey> If it can be made completely redundant, it's even more Enterprise.
17:19:55 <dons> our PHB/PHD ratio is rather poor.
17:20:03 <pumpkin> what makes visual studio visual btw?
17:20:03 <Saizan_> you need to serialize everything in XML before you can start calling it Enterprise
17:20:04 <Twey> An Enterprise solution uses Java and XML.
17:20:15 <pumpkin> and UML
17:20:17 <Twey> Right.
17:20:34 <Twey> And it should preferably have been developed using Agile.
17:20:36 <monochrom> phd = polished head drones?
17:20:44 <olsner> it's all about leveraging synergy
17:20:48 <pumpkin> monochrom: I hope not, or I'll feel bad for myself
17:20:50 <dons> piled deeper and higher.
17:21:15 <monochrom> packaged haskell dons
17:21:21 <pumpkin> lol
17:21:30 <Twey> Leveraging synergy to bring the maximum potential usability benefits to large-business clients.
17:21:35 <pumpkin> this channel feels way more academic than any other channel I've been in
17:21:52 <Twey> pumpkin: And yet I'm a high-school drop-out.  Go figure.
17:21:57 <dons> we have candy!
17:21:59 * Twey preens.
17:22:00 <dons> oh wait, no.
17:22:03 <FunctorSalad> does an 'enterprise' have a legal minimum size? ;)
17:22:03 <pumpkin> :)
17:22:08 <dons> sorry pumpkin. we have no candy today
17:22:08 <Twey> We have happy!
17:22:10 <pumpkin> FunctorSalad: I'm a one-man enterprise
17:22:12 <Saizan_> sugar lambdas anyone?
17:22:12 <dons> we are!
17:22:18 <olsner> FunctorSalad: at least Galaxy class
17:22:21 <FunctorSalad> pumpkin: that was the idea
17:22:53 <monochrom> Enterprise is an Institution class starship software tool
17:23:47 <dino-> dons: While you're here, we were having problems building hscurses on Debian for some time until I hacked a bit of hmp3 over (the colour pairs thing). I'm wondering if it's something that should be submitted as a patch against hscurses.
17:24:03 <TomMD> dons: Are you privy to Lees new contract?  I'm just curious what the spec is he'll be basing the monitor on.
17:24:19 <dons> TomMD: hmm. only what's on the blog. I could dig up more info if you're interested.
17:24:32 <TomMD> Nah, I can e-mail him.
17:24:34 <dons> TomMD: you've met Lee, right? Drop him a line.
17:24:40 <TomMD> Yes, I have.
17:24:43 <dons> great.
17:25:12 <dons> i might be working with him on a bit of that next year, actually
17:25:51 <TomMD> Its an interesting task - but the need for a high quality spec to base the monitor on would worry me (unless it already exists).
17:25:56 <dons> dino-: i think there's been a new hscurses release.
17:26:03 <TomMD> s/high quality/formal/
17:26:10 <Twey> First since 2006?
17:26:10 <dons> TomMD: yeah.
17:26:30 <dons> Twey: right.Upload dateWed Oct 15 10:51:01 UTC 2008
17:26:42 <dino-> I couldn't build 1.3.0.1 because of the linker problems. From 2008-Oct-15
17:26:45 <Twey> Nice
17:26:54 <Twey> Is there a changelog?
17:26:56 <dons> dino-: mm. seems to be building on c.h.o
17:27:02 <dons> dino-: msg int-e
17:27:04 <dino-> But not on our Debian and Ubuntu systems here
17:27:09 <Twey> It should be *huge* :-P
17:27:21 <dino-> dons: will do
17:27:31 <dons> Twey: in darcs.
17:27:32 <Saizan_> dino-: same problem here
17:27:49 <thoughtpolice> dons: gah! if I knew you were going to have a talk on monday in tx. I would have arranged to go :]
17:28:02 <Saizan_> i sent a patch but got no answer
17:28:33 <dino-> Saizan_: Ah, to wehr@informatik.uni-freiburg.de ?
17:28:40 <Saizan_> right
17:28:45 <dino-> ok
17:28:48 <TomMD> tp: there is still time.  Skip class.
17:31:07 <dons> the matlab lib looks promising, "a comprehensive interface to the MathWorks MATLAB(R) libraries and native data structures, including complete matrix access"
17:31:18 <dons> its great to see new significant contributions like this.
17:32:02 <int-e> Saizan_: when did you send it? For the last patches I sent I got a response within 3 days.
17:32:05 <dino-> ah, int-e is Bertram, uploader of hscurses to Hackage
17:32:28 <Saizan_> int-e: Nov 11
17:32:39 <dino-> int-e: Hey, there you are
17:34:56 <Saizan_> * Add ncurses as an extra-library so that it gets linked in
17:34:56 <Saizan_>   * Avoid using hsc2hs's #def feature since it's badly supported
17:35:08 <Saizan_> that's my solution btw
17:35:41 <dino-> Saizan_: The add ncurses part on the cm example, is what we did, ya.
17:35:58 <dino-> And the other, yes, some borrowed code from hmp3
17:36:01 <thoughtpolice> hscurses seems to be broken on ghc 6.10 for other reasons
17:36:06 <thoughtpolice> i was thinking of patching it so it  would work
17:36:31 <dino-> thoughtpolice: What distro? It's reporting ok for 6.10, 6.8 on Hackage.
17:36:52 <dino-> But I'm seeing borkenness in Debian and Ubuntu
17:37:00 <dino-> And Saizan too
17:37:32 <Saizan_> dino-: i added it to the .cabal file, so ghc --make adds -lncurses for you
17:37:50 <dino-> Saizan_: Awesome, I was unsure of how to go about that
17:38:44 <dino-> Making it work everywhere, not just each individual consumer of the API
17:38:46 <thoughtpolice> dino-: http://hpaste.org/12080
17:40:01 <dino-> thoughtpolice: Looks like we may all be on the same page here, judging by the _hs_curses_color_pair
17:41:04 <Saizan_> dino-: you can pull from http://code.haskell.org/~Saizan/hscurses/ , it'd be nice to test it on other platforms, just in case
17:41:04 <lambdabot> Title: Index of /~Saizan/hscurses
17:42:13 <thoughtpolice> Saizan_: your patch fixes my breakage
17:43:39 <Saizan_> nice
17:44:28 <Twey> I read that as 'your fix breaks my webpage'
17:44:49 <thoughtpolice> Saizan_: i would say if it works for who's having problems to go ahead and upload it as 1.3.0.2 or something on hackage
17:45:49 <dino-> Saizan_: Works here too in Debian.
17:45:51 <dino-> Thank you
17:45:56 <Saizan_> np
17:46:49 <Saizan_> since int-e said the maintainer is responsive i'd wait a few more days before uploading a package myself
17:48:11 <Saizan_> btw, do you have a tutorial/guide on using it? especially the Widgets
17:49:14 <dino-> Saizan_: I do not. I was trying to get up to that stage, of learning how to use.
17:49:30 <int-e> Saizan_: the only reason that I did the previous upload is that I offered to do it and Stefan agreed
17:49:42 <dino-> Never used curses in C either, so should be interesting.
17:51:48 <sutats> What's the function to return an index for an item in a (2-D) array?
17:51:56 <Saizan_> dino-: same here :) i guess the hmp3 source should help
17:52:31 <dino-> Saizan_: Yep, and possibly that (kind of broken) cm and hetris. Any other cursy apps on Hackage that I'm not aware of?
17:52:53 <Saizan_> sutats: i think you've to implement binary search yourself
17:53:40 <sutats> Saizan_: Afraid that was the case. Thanks.
17:53:57 <Saizan_> dino-: LambdaHack
17:54:52 <BMeph> sutats: In other news, though, it shouldn't matter what your array's rank is - i.e., if it works for a one-dimensional array, it'll work for them all. :)
17:55:28 <sutats> BMeph: Hm, that's a nice benefit.
17:55:32 <dons> dino-: hmp3?
17:55:42 <dons> twitter.
17:55:47 <Saizan_> it's kind of weird that there aren't algorithms like that in the standard library
17:56:12 <dino-> dons: ya, hmp3
17:56:24 <dino-> LambdaHack, neat. That could be fun
17:56:56 <sutats> How about getting the item of an array in a certain index? What's the syntax for that?
17:57:08 <Saizan_> arr ! index
17:57:21 <sutats> Saizan_: How does that extend to 2D?
17:57:30 <sutats> arr ! (i, j)?
17:57:30 <Saizan_> sutats: the index is a tuple
17:57:35 <Saizan_> right
17:57:37 <sutats> Okay, good.
17:57:56 <Saizan_> or anything that instances the Ix class
17:57:59 <Twey> Hmm
17:58:11 <Twey> How does that work for n-dimensional arrays?
17:58:31 <Saizan_> (i1,i2,..,in)
17:58:42 <Twey> But what about the types?
17:59:07 <luite> are tuples of aritrary length of class Ix?
17:59:14 <Twey> There's an Ix instance for every possible tuple?
17:59:49 <Saizan_> http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Arr.html#t%3AIx <-- up to 5
17:59:50 <lambdabot> Title: GHC.Arr, http://tinyurl.com/5ezb9z
18:00:02 <Twey> So, no n-dimensional arrays
18:00:32 <ddarius> :t (!)
18:00:33 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
18:00:34 <luite> you can implement your own Ix of course
18:00:59 <Twey> @instances Ix
18:01:00 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
18:01:08 <Twey> Bah
18:01:08 * Saizan_ would use an Array as index then
18:01:14 <Twey> How does @instances-importing work?
18:01:25 <Twey> Not a list?
18:01:30 <ddarius> @instances-importing Array Ix
18:01:30 <dolio>  @instances-importing module class
18:01:34 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
18:01:37 <dolio> Not sure.
18:01:55 <Twey> Aha
18:02:02 <Twey> Only up to four, no?
18:02:14 <Twey> What's the use of Ix ()?  *chuckles*
18:02:22 <dolio> You can implement more.
18:02:23 <ddarius> Twey: You may want it.
18:02:23 <Saizan_> haddock reports 5
18:02:28 <Twey> ddarius: For?
18:02:33 <Twey> @info Ix
18:02:34 <lambdabot> Ix
18:02:35 <dolio> Or use (a, b, c, (d, e, f, g)). :)
18:02:45 <ddarius> Also, you can encode n-fold as (a, (b, (c, .. (n, ()) ... )))
18:02:46 <Twey> Point
18:02:52 <Twey> Heh
18:03:11 <ddarius> () is useful for turning a single value into an array.
18:03:31 <ddarius> The Ordering instance is a bit unusual.
18:03:38 <Twey> Ooh, I see.
18:03:40 * Saizan_ wonder if using strict tuples would improve performance
18:03:51 <gumpwea> I'm trying to nest functions but hugs keeps griping at me claiming "Type error in application"... I've looked at several Haskell tutorials and none of them seem to provide coherent guidance regarding nesting function calls where functions with multiple arguments are concerned (ie the type I'm not matching is "a -> b -> c") Any help appreciated.
18:03:52 <ddarius> I guess you could use APL/J like stuff with Ordering.
18:04:02 <Twey> Yes, I can imagine that might be useful if something accepted an Array a b
18:04:44 <ddarius> listArray (LT,GT) [lessThan, equal, greaterThan] ! compare foo bar
18:04:49 <Saizan_> gumpwea: it's like (bar (foo a b) c d)
18:05:15 <Saizan_> gumpwea: that the function bar applied to the three arguments (foo a b), c, d
18:06:00 <Saizan_> gumpwea: so totally different from C-like syntax
18:06:12 <Saizan_> hoping that was your question..
18:06:14 <twb> I'm looking at some code that's confusing me: there's a "let" without any "in".
18:06:19 <gumpwea> thanks - I'll see if i can stare it into submission
18:06:45 <Saizan_> twb: that's allowed in a do-block
18:06:53 <twb> Saizan_: oh.
18:07:09 <twb> @undo do { let x = y; x; }
18:07:09 <lambdabot>  Parse error at ";" (column 18)
18:07:16 <twb> Bah.
18:07:32 <twb> @undo do { let x = y; x }
18:07:33 <lambdabot>  Parse error at "}" (column 19)
18:07:33 <Saizan_> @undo do let {x = y}; x
18:07:34 <lambdabot> let { x = y} in x
18:08:21 <twb> Saizan_: so that in-less sugar is unrelated to do's normal usage of sugaring monadic combinators?
18:08:23 <gumpwea> Saizan_:  so what does the following declaration mean?  foo :: SomeType -> SomeType -> SomeType
18:08:40 <sutats> Does "f a ++ f b ++ f c ++ f d" have a more concise representation?
18:08:46 <lispy> twb: it just happens that do and non-do have let, but they are syntatically different lets
18:09:02 <Saizan_> twb: yeah, it's just a shorthand for let .. in
18:09:18 <lispy> ?undo do {let x = 1; y = 2; return (x,y) }
18:09:18 <lambdabot>  Parse error at "}" (column 36)
18:09:21 <twb> sutats: there's map/foldl, but probably there's a dedicate function for that.
18:09:25 <Saizan_> gumpwea: that foo takes two parameters of type SomeType and returns something of type SomeType
18:09:26 <Eelis> sutats: concatMap f [a, b, c, d]
18:09:34 <gumpwea> ok, many thanks.
18:09:35 <twb> lispy: oh, ok.  Confusing!
18:09:42 <dolio> > concatMap f [a, b, c, d]
18:09:43 <lambdabot>       Ambiguous occurrence `f'
18:09:44 <lambdabot>      It could refer to either `L.f', defined a...
18:09:57 <sutats> Eelis: I think that's what I'm looking for. Thanks.
18:09:59 <lispy> twb: the difference is that let inside of do doesn't need 'in'
18:09:59 <dolio> @type f
18:10:00 <lambdabot>     Ambiguous occurrence `f'
18:10:00 <lambdabot>     It could refer to either `L.f', defined at <local>:11:0
18:10:00 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:72:0-32
18:10:04 <dolio> @type L.f
18:10:05 <lambdabot> forall a. (Integral a) => a -> a
18:10:08 <lispy> twb: otherwise they are indistinguishable
18:10:12 <dolio> > L.f 5
18:10:13 <lambdabot>   16
18:10:23 <Saizan_> > L.f 10
18:10:25 <lambdabot>   5
18:10:33 <dolio> > map L.f [1..20]
18:10:33 <lambdabot>   [4,1,10,2,16,3,22,4,28,5,34,6,40,7,46,8,52,9,58,10]
18:10:41 <twb> dons: typo in RWH's "Acknowledgements" -- s/wierd/weird/.
18:10:43 <Asztal> guess the function!
18:10:53 <hackage> Uploaded to hackage: ZipFold 0.1
18:10:53 <hackage> Uploaded to hackage: matlab 0.1
18:11:11 <Saizan_> gumpwea: which tutorials are you following?
18:11:22 <Saizan_> @where LYAH
18:11:23 <lambdabot> www.learnyouahaskell.com
18:11:28 <dolio> f (2*n) = n ...
18:12:23 <dolio> f (2*n+1) = 4 + n*6?
18:12:55 <lispy> > let f (2*n+1) = 4 + n*6 in map f [1..20]
18:12:56 <lambdabot>   <no location info>: Parse error in pattern
18:13:08 <lispy> that's not a valid n+k pattern!
18:13:13 <dolio> > concatMap (\n -> [4 + n*6, n+1]) [0..]
18:13:14 <lambdabot>   [4,1,10,2,16,3,22,4,28,5,34,6,40,7,46,8,52,9,58,10,64,11,70,12,76,13,82,14,...
18:13:18 <dolio> I know.
18:13:38 <dolio> But it's a reasonable mathematical definition.
18:13:54 <dolio> > L.f 0
18:13:55 <lambdabot>   0
18:14:02 * lispy checks the channel name....nope still #haskell ;)
18:14:03 <dolio> > L.f (-1)
18:14:04 <lambdabot>   -2
18:14:29 <dolio> > map L.f [-10 .. 0]
18:14:30 <lambdabot>   [-5,-26,-4,-20,-3,-14,-2,-8,-1,-2,0]
18:15:02 <Saizan_> can we write a quasiquoter for that?
18:15:12 <dolio> > concatMap SimpleReflect.f [a,b,c,d]
18:15:13 <lambdabot>       No instance for (SimpleReflect.FromExpr [b])
18:15:13 <lambdabot>        arising from a use ...
18:17:29 <alexsuraci> http://gist.github.com/23030 -- Is the Explanation accurate here?
18:17:31 <lambdabot> Title: gist: 23030 â GitHub
18:17:42 * Botje is trying to build ghc 6.10 using the 6.8 debian directory
18:17:46 <Botje> seems to work, so far
18:18:03 <sutats> I have a pure function that returns [(Int, Int)]. How do I call putStrLn from my main with that?
18:18:30 <dolio> You just want to print the list?
18:18:37 <sutats> dolio: Yeah.
18:18:42 <dolio> Just use print.
18:19:01 <Botje> alexsuraci: looks fine
18:19:15 <sutats> dolio: Oh, that worked. What's the difference between print and putStrLn?
18:19:25 <alexsuraci> Botje: Nice, thanks. :)
18:19:28 <Botje> @source print
18:19:28 <lambdabot> print not available
18:19:31 <dolio> print = putStrLn . show
18:19:31 <Botje> doh
18:19:40 <dolio> Where show turns various values into strings.
18:19:51 <sutats> Oh, that's probably the step I needed.
18:20:41 <lispy> ?src show
18:20:41 <lambdabot> show x = shows x ""
18:21:00 <lispy> > fix (flip shows "")
18:21:01 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:21:38 <lispy> ?let break = fix
18:21:38 <lambdabot>  Defined.
18:21:43 <lispy> > break show
18:21:44 <lambdabot>       Ambiguous occurrence `break'
18:21:44 <lambdabot>      It could refer to either `Data.List.b...
18:21:46 <Botje> lol
18:21:50 <lispy> > L.break show
18:21:51 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:22:05 <monochrom> it doesn't break show
18:22:14 <Botje> it just bends it!
18:22:34 <dolio> It breaks mueval, though.
18:22:52 <dolio> For people who want to use Data.List.break, at least.
18:23:24 <lispy> :t Prelude.break
18:23:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:23:37 <monochrom> > break (== 'n') "good night"
18:23:39 <lambdabot>       Ambiguous occurrence `break'
18:23:39 <lambdabot>      It could refer to either `Data.List.b...
18:23:41 <lispy> > Prelude.break (const True) [1..10]
18:23:42 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
18:23:55 <pumpkin> @src const
18:23:55 <lambdabot> const x _ = x
18:23:55 <Twey> :t Prelude.break
18:23:56 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:23:58 <lispy> ?undef break
18:24:07 <monochrom> > break (== 'n') "good night"
18:24:08 <lambdabot>   ("good ","night")
18:24:32 <dons> twb: in the final version?
18:24:34 <dolio> > f a
18:24:35 <lambdabot>   Add a type signature
18:24:42 <dolio> > f a :: Expr
18:24:43 <lambdabot>   f a
18:24:47 <dons> the online one is out of date now, it'll be resynced once we get the docbook back from the publishers
18:24:49 <twb> dons: in the web version I fetched yesterday
18:25:00 <twb> dons: OK.
18:25:02 <dons> ok. not today's published version.
18:25:11 * monochrom watches more The Tudors. "Henry rules the world and gets the girl!"
18:25:14 <lispy> :t f
18:25:15 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
18:25:36 <dolio> Decent show.
18:25:39 <Twey> Or six.
18:29:15 * dolio wishes Rome hadn't been cancelled.
18:31:40 <fynn> Hey. How do I define an anonymous function on-the-fly in Haskell?
18:32:04 <fynn> like, suppose I have a function foo that takes an argument bar that is a function.
18:32:36 <byorgey> fynn: \x -> something in terms of x
18:32:38 <int-e> > map (\x -> x*4 + 2) [1..2]
18:32:39 <lambdabot>   [6,10]
18:32:59 <fynn> byorgey, int-e: ah, nice.
18:33:03 <fynn> thanks.
18:33:41 <int-e> > zipWith (\x y -> x - 2*y + x*y) [1,2] [5,6] -- if you need more than one argument
18:33:42 <lambdabot>   [-4,2]
18:33:55 <fynn> yeah, was just about to ask that :P
18:33:57 <fynn> thanks.
18:34:11 <int-e> > zipWith (\x -> \y -> x - 2*y + x*y) [1,2] [5,6] -- works, too.
18:34:12 <lambdabot>   [-4,2]
18:34:49 <Twey> fynn: Or just an expression with an argument not filled in.
18:35:06 <Twey> > map (*2) [1, 2, 3, 4]
18:35:07 <lambdabot>   [2,4,6,8]
18:35:14 <Twey> > map (\x -> x * 2) [1, 2, 3, 4]
18:35:16 <lambdabot>   [2,4,6,8]
18:35:48 <fynn> Twey: oh this is very cute.
18:36:16 <Twey> map (map (*2)) [[1, 2], [3, 4]]
18:36:21 <fynn> though I'm not sure I understand where I can use it instead of the other forms
18:36:27 <Twey> The joys of currying.  :)
18:37:13 <Twey> fynn: (+2) is exactly equivalent to \x -> x + 2
18:37:27 <Twey> And (+) is exactly equivalent to \x y -> x + y
18:37:39 <fynn> ah, starting to make sense.
18:37:49 <Twey> You can also do (2+)
18:37:50 <fynn> Haskell is so awesome.
18:38:13 <fynn> also, look what I just discovered:
18:38:15 <fynn> valid3 bf = and [ bf p q r | p <- [True,False],
18:38:15 <fynn>                              q <- [True,False],
18:38:15 <fynn>                              r <- [True,False]]
18:38:24 <Twey> And since a function without all its arguments is just another function in Haskell, you can do that with trailing function arguments, too (although if you want to do it with ones in the middle it gets a little tricky â we have things like flip for that)
18:38:32 <fynn> a propositional statement checker!!
18:38:50 <Twey> Haha, yeah :)
18:39:19 <ddarius> > (+2) undefined `seq` ()
18:39:20 <lambdabot>   * Exception: Prelude.undefined
18:40:20 <ddarius> > let f True = \x -> x in (`f` False) `seq` ()
18:40:20 <lambdabot>   ()
18:40:35 <Twey> \x -> x === id
18:40:52 <ddarius> I wrote it that way for emphasis.
18:41:02 <Twey> I know, I was just pointing it out :-P
18:41:31 <fynn> Twey: this is sort of like list comprehensions in Python, except the syntax is enhanced with pure Win(tm).
18:41:48 <ddarius> fynn: List comprehensions in Python were inspired by Haskell's.
18:41:51 <Twey> TBH, the syntax scared the crap out of me when I first saw it.  :-P
18:42:09 <Twey> They weren't just inspired, they were taken pretty much verbatim from Haskell
18:42:41 <fynn> in Python it would be:
18:42:42 <fynn> all(bf(p, q, r) for p in [True, False] for q in [True, False] for r in [True, False])
18:42:43 <Twey> Except | = for, <- = in/if
18:43:15 <fynn> except in Python I'd be likely to name [True, False] as l, and it would thus be:
18:43:17 <Saizan_> the need to repeat for always made them look ugly in python
18:43:19 <Twey> Aye
18:43:33 <fynn> all(bf(p, q, r) for p in l for q in l for r in l)
18:43:37 <Saizan_> +to me
18:44:31 <fynn> hm, 'all(bf(p, q, r) p, q, r  in l * 3)' :)
18:44:58 <fynn> all(bf(p, q, r) p, q, r  in zip(*(l * 3)))
18:45:05 <idnar> I always try to read nested list comprehensions in Python backwards, for some reason
18:45:29 <fynn> idnar: they're the same order of a nested loop
18:45:46 <Saizan_> except the lexical scope is backwards?
18:46:19 <Saizan_> for usually introduces a scope on its right, not on its left
18:47:31 <idnar> fynn: yeah, I know
18:47:39 <idnar> it's probably because of what Saizan_ said
18:47:47 <idnar> it's like nested for loops, except the body is on the far left
18:47:57 <fynn> yeah
18:50:07 <fynn> OK, here's a tested, working, and seemingly the most concise version of that proposition checker in Python:
18:50:10 <fynn> lambda bf: all(bf(p, q, r) for p, q, r in zip(*([True, False],) * 3)))
18:50:24 <idnar> concise, but illegible :P
18:50:37 <idnar> use a list rater than a 1-tuple
18:50:44 <idnar> although that's probably the least of the problems there ;P
18:50:47 <Twey> Why bother with the zip?
18:50:49 <Twey> Yeah
18:50:51 <Twey> [(True, False)] * 3
18:51:03 <Twey> Oh wait, then you can't extract it.
18:51:08 <fynn> right :)
18:51:12 <Twey> ((True, False) * 3) then
18:51:13 <idnar> the "zip" is actually a transpose
18:51:28 <fynn> sorry, I mislead you all :(
18:51:33 <idnar> def transpose(x): return zip(*x)
18:51:41 <fynn> or rather, there's a problem in that implementation
18:51:45 <fynn> can you detect it?!
18:51:47 <Twey> I know it :)
18:52:07 <fynn> prove it.
18:52:15 <idnar> it only tests True, True, True and False, False, False
18:52:20 <fynn> yeah :/
18:52:29 <Saizan_> what does the first * do?
18:52:35 <fynn> unpacks
18:52:37 <Twey> zip([True, False], [True, False], [True, False]) -> [[True, True, True], [False, False, False]]
18:52:50 <idnar> Saizan_: foo(*[x, y, z]) is the same as foo(x, y, z)
18:52:53 <fynn> Twey, idnar: guess there's no avoiding the nested  fors
18:52:58 <Twey> Saizan_: Applies the function to an iterable full of arguments
18:53:04 <idnar> fynn: write a permute() function :P
18:53:10 <Saizan_> ah, right, now i recall
18:53:18 <Twey> ** is the same for dictionaries
18:53:18 <fynn> idnar: ah, there's a itertools.product() in 2.6
18:53:34 <fynn> anyways, enough making this into #python-2, this is #haskell goddamit
18:53:49 * idnar turns this into #sleep instead
18:54:00 <Twey> Heh
18:54:03 <fynn> you sleep in the channel?
18:54:18 <Twey> idnar does
18:54:26 <Twey> Very dilligent
18:54:32 <fynn> I heard you Haskell dudes were crazy.
18:54:34 <Twey> diligent**
18:54:46 <fynn> anyways, I'll probably have lots of questions later.
18:54:54 <fynn> so keep thinking Haskell in the meantime!!
18:54:57 <Twey> fynn: I'm not crazy.  That's my alter-ego, Fred.
18:54:59 <Saizan_> > let fibs = 1 : 1 : (zipWith (+) `ap` tail) fibs in fibs
18:55:00 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:55:48 <dolio> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6],[7,8,9]]
18:55:49 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
18:57:04 * Twey freely admits to not really understanding that'n.
18:57:26 <Twey> Oh wait
18:57:30 <Twey> Now I get it.
18:57:35 * fynn wonders about a propositional function checker for functions of N propositions.
18:57:54 <Twey> > foldr zip (repeat []) [[a, b, c], [d, e, f], [g, h, i]]
18:57:55 <lambdabot>       Occurs check: cannot construct the infinite type: b = (a, b)
18:57:55 <lambdabot>        Exp...
18:57:59 <oklopol> what's `ap` again?
18:58:01 <Twey> :<
18:58:05 <Twey> :t ap
18:58:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:58:23 <dancor> :t (<$>)
18:58:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:58:32 <Twey> Like bind, but works with a function in the monad.
18:58:38 <Saizan_> oklopol: ap f g = \x -> f x (g x) for the ((->) r) monad, which is the instance i was using
18:58:40 <dancor> :t (<*>)
18:58:41 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:58:48 <twb> @hoogle (a, b, c) -> a
18:58:49 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
18:58:49 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
18:59:09 <dancor> ap is <*>
18:59:13 <Saizan_> fynn: see Test.QuickCheck
18:59:15 <telexicon> is there a function which does what you get when you generically deriving Show a datatype?
18:59:28 <Saizan_> @check \x y -> x && y
18:59:29 <lambdabot>   "Falsifiable, after 1 tests:\nFalse\nTrue\n"
18:59:34 <Twey> And bind is <$>
18:59:36 <Saizan_> @check \x y z -> x && y && z
18:59:37 <lambdabot>   "Falsifiable, after 0 tests:\nTrue\nFalse\nTrue\n"
18:59:44 <ddarius> telexicon: gshow kind of does that
18:59:45 <twb> Can I extract the first element in a tuple without pattern matching?
19:00:01 <Raevel_> twb: fst
19:00:01 <Saizan_> ?type fst
19:00:02 <lambdabot> forall a b. (a, b) -> a
19:00:03 <Twey> twb: You can use `fst` if it's a pair.
19:00:13 <twb> Sorry, I meant a 3-tuple
19:00:21 <Twey> Not by default
19:00:23 <dancor> you could write fst3
19:00:30 <Twey> fst3 (a, _, _) = a
19:00:35 <Saizan_> Twey: it's >>= that's usually called bind
19:00:46 <dancor> or switch to use like fst . fst on ((x, y), z)
19:00:49 <Twey> Saizan_: Which is the monadic equivalent to <$>
19:00:55 <dancor> or switch to named records
19:00:56 <Saizan_> ..no
19:00:57 <ddarius> Twey: No.
19:00:59 <Twey> ... although backwards
19:01:01 <Twey> No?
19:01:04 <Saizan_> <$> is fmap
19:01:04 <Twey> Hmn.
19:01:05 <ddarius> @src (<$>)
19:01:06 <lambdabot> f <$> a = fmap f a
19:01:14 <Saizan_> ?type (<$>)
19:01:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:01:15 <FunctorSalad> type Firstable a b where fst :: a -> b; instance Firstable (x,y) x
19:01:17 <Twey> Oh, right.  Aye.
19:01:18 <FunctorSalad> ?
19:01:19 <Saizan_> ?type (>>=)
19:01:19 <FunctorSalad> ;)
19:01:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:01:49 <FunctorSalad> I mean class, not type :(
19:01:57 <Twey> Heh
19:02:30 <dancor> Firstable, that's amazing
19:02:38 <dancor> that's a first for me
19:02:44 <FunctorSalad> :)
19:02:54 * Twey groooooans.
19:03:02 <Twey> Food!
19:03:04 * Twey vanishes.
19:03:04 <fynn> Saizan_: thanks.
19:03:35 <fynn> all that code caused Twey to degenerate to the primitive state of an animal, seeking food and refuge.
19:03:46 <fynn> hope you're proud of yourselves.
19:04:03 <ddarius> Just another day in #haskell
19:04:32 <lament> he didn't say anything about refuge.
19:04:33 <Saizan_> ..causing head explosions since 1998
19:04:59 * FunctorSalad 'splodes
19:05:00 <Saizan_> (or before/after i don't really know)
19:06:12 <Saizan_> (chanserv says 2001)
19:07:06 <ddarius> There were two #haskells.  This one started around 2001.
19:08:20 <conal> wchogg: thanks for the blog comment on http://conal.net/blog/posts/enhancing-a-zip/
19:08:25 <lambdabot> Title: Conal Elliott Â» Enhancing a Zip
19:10:34 <wchogg> conal:  Is my thinking kind of heading in the same direction as yours & your use of natural transformations in reactive semantics?
19:10:52 <lispy> a tale of two #haskells
19:12:31 <twb> Woo, I convinced the tye checker to accept my code
19:12:38 <twb> That means it has no bugs!1!1
19:12:50 <dancor> why isn't  class .. where ..; instance .. where ..  valid? (parse error on instance)
19:12:58 <dancor> why does it have to be newline for the ;
19:13:43 <lispy> > class .. where ..; instance .. where ..
19:13:43 <lambdabot>   <no location info>: parse error on input `class'
19:13:50 <Saizan_> dancor: try class .. where { .. }; maybe?
19:14:15 <twb> dons: btw, I made a little script that renders the HTML version of RWH into a PDF -- and it uses vector icons for the admonitions! :-)
19:14:16 <dancor> that works
19:14:44 <Saizan_> so the instance "line" was interpreted as a part of the block introduced by where
19:16:29 * lispy wonders if he's the only one that would find a bot in #sparta that autokicks people who join...especially if it first said, "This is #sparta!"
19:16:39 <conal> wchogg: i think so.
19:17:12 <ddarius> lispy: You are missing part of that sentence.  Check under your seat.
19:17:22 <lispy> funn!
19:17:25 <lispy> er, funny
19:17:32 <lispy> I meant, would anyone else find it funny..
19:18:21 <conal> wchogg: i stumbled onto this type class morphism stuff while writing down denotational semantics of Reactive.  i was fiddling with definitions aesthetically, and didn't realize it meant something.
19:20:02 <dons> twb: you should send it to the book email, and we can link to it on the blog
19:21:57 * kfish returns from #sparta
19:22:16 <twb> dons: I can't see an email address on the http://realworldhaskell.org/ page.
19:22:19 <lambdabot> Title: Real World Haskell
19:27:59 <pizza_> sweet
19:31:04 <conal> dons: thanks for filling the haskell reddit.
19:33:26 <SubStack> @pl (\n -> n ^ n)
19:33:26 <lambdabot> join (^)
19:33:29 <SubStack> orite
19:37:55 <lispy> > join (*) 4
19:37:56 <lambdabot>   16
19:38:25 <lispy> > map (join (^)) [1..10]
19:38:25 <lambdabot>   [1,4,27,256,3125,46656,823543,16777216,387420489,10000000000]
19:49:50 <sutats> dmwit: If you don't mind reading more of my code, could you suggest more improvements / condensing to http://hpaste.org/12017#a8 ?
19:55:48 <mwotton> slightly off-topic - has anyone here tried using Amazon Web Services, for haskell or otherwise? am thinking about farming some of my compute work out - it's either that or buy a decently sized desktop...
19:56:50 <Lemmih> mwotton: I've used S3 and EC2 some.
19:59:14 <mwotton> Lemmih: recommend it? they charge per hour of actual time, not CPU time, right?
20:00:05 <Lemmih> mwotton: Right. It's not bad but it's not great either.
20:00:58 <Lemmih> mwotton: It's quite expensive so if you don't have a dire need for scaling then an alternative might be better.
20:02:11 <mwotton> Lemmih: I occasionally need a really hefty machine, but usually only for a little while... just trying to work out whether it'd be cheaper to build my own and leave it unused a lot of the time
20:03:36 <kynky> just rent time on a server ?
20:03:57 <mwotton> kynky: are there places you can buy time in small chunks?
20:04:06 <kynky> yeah
20:12:00 <p_l> Sun Grid?
20:13:15 <p_l> I think you can also buy supercomputer time too
20:14:03 * mwotton is getting shivery just thinking about it :)
20:14:36 <p_l> Though with supercomputers you might have problems with Haskell compiler :)
20:14:55 <p_l> BG/L should still work, though
20:15:08 <p_l> as well as as Cray's MPP
20:15:35 <p_l> (but only the newer, Opteron based. Forget T3 running Haskell)
20:16:05 <mwotton> p_l: hm. might be easier to just be cleverer about parallelising my program, i guess.
20:16:26 <p_l> MPP line requires a *very* parallel program :)
20:16:34 <p_l> the same goes for BG/L
20:16:37 <kynky> just run it inside a vm inside a supercomputer, or make it so your app can be parallized well :)
20:16:44 <p_l> VM won't help
20:16:47 <kynky> one big , or lots small
20:17:06 <p_l> Most really powerful supercomputers require *very* parallel programs
20:17:39 <p_l> starting with Cray's old T3 supercomputers started having thousands of processing nodes
20:17:48 <Corun> Well, just parallelize the program's then, easy ;-)
20:17:51 <p_l> before that, Connection machine
20:17:53 <Corun> *programs
20:20:21 <p_l> mwotton: What binds your program? calculation speed, memory, IO, etc?
20:21:41 <mwotton> p_l: at the moment, memory, but that's because i have a leak - it doesn't really need that much information hanging around. it should be CPU in the end
20:25:13 <p_l> then you can probably easily go with grid.. unless you've got really awful amounts of data to transfer ^^;
20:30:02 <mwotton> p_l: should be ok for the moment. eventually i'll have a one-time 26 gig transfer, but that's just a setup cost.
20:32:04 <p_l> well, 26G transfer can be done in one night, so it's not a problem
20:38:18 <fynn> I have the following lambda: \p -> not p
20:38:31 <fynn> can I call it in the same line I defined it, without enclosing it in parens?
20:45:44 <dancor> fynn: i think lambda's have to be in parens
20:45:56 <dancor> @pl \ p -> not p
20:45:56 <lambdabot> not
20:46:32 <dancor> just saying not $ .. instead of (\ p -> not p) $ ..   should be clearer tho
20:48:10 <fynn> hm
20:48:20 <fynn> dancor: thanks.
20:49:11 <fynn> it's too bad Haskell list syntax doesn't support the redundant comma convention.
20:49:20 <dancor> i feel the same way
20:51:14 <dancor> i see a few options: pre-processor, editor macros to handle comma-ery for you when adding to or deleting from end of lists, crazy spaced-out style where you do "[\nx\n,\ny\n,\nz\n]"
20:52:37 <dancor> only #2 is really good if you value fitting-in
20:53:55 <fynn> or patching GHC :)
20:54:15 <dancor> that's what happened with the arrow-notation pre-processor :)
20:54:50 <dancor> {-# LANGUAGE IJustCareAboutCommasALot #-}
20:56:32 <Twey> Why don't we just have layout for lists?
20:56:33 <askentasken> exceptions are always Maybes in Haskell?
20:56:49 <Twey> askentasken: No, there are a variety of different exception/error-handling methods
20:56:53 <askentasken> how do you handle something like factorial that is passed a negative number?
20:57:12 <askentasken> error "Factorial not defined for negative numbers" is that idiomatic?
20:57:30 <Twey> Yeah, since it's a case that should never occur
20:57:33 <dancor> i liked this one: http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
20:57:39 <Twey> If you expect it to happen in normal running, don't use `error`, because it's hard to catch
20:57:42 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
20:57:47 <Twey> (impossible in '98)
20:58:32 <Twey> fynn: No, you can't, since lambdas extend as far as possible
20:59:16 <Twey> You always have to enclose them in brackets unless they're at the end of the expression
20:59:31 <Twey> (or you're in a do block and can use layout to make it clear)
20:59:37 <fynn> Twey: OK, it would still be nice to have redundant commas in lists :)
20:59:43 <Twey> It would
21:00:05 <fynn> hah, got you there didn't I
21:00:08 <Twey> But layout for lists would solve the issues for which we kind-of-need them
21:01:19 <Twey> (and would be more consistent with the rest of Haskell)
21:02:39 <dancor> adopting anything from python could also compromise dons' irc war against python
21:03:52 <Twey> dons has an IRC war against Python?
21:04:06 <dancor> @users
21:04:06 <lambdabot> Maximum users seen in #haskell: 550, currently: 477 (86.7%), active: 8 (1.7%)
21:06:13 <Twey> The activity/attendance ratio for this channel is so low
21:08:48 <jeffz> I wouldn't say it's low, more small.
21:09:48 <jeffz> comparing to ##c has a similar total number of people of which only a small amount participate
21:12:50 <Twey> That was the sense in which I was using 'low', yes :-P
21:12:59 <Twey> Mm.
21:13:36 <Twey> They do participate sometimes.  I think maybe people just feel a little intimidated by all the Ph.D.s around here.
21:13:49 <Twey> And other assorted clever folks.
21:14:56 <ksf> you mean those that got their own lambdabot installed and secretly @pl everything they post on their own machine?
21:15:37 <dons> it depends on the time of day.
21:15:39 <Twey> Hahaha
21:15:58 <dons> 1.7% is low, but the time of day isn't good
21:16:28 <ksf> sunday 6:20, I wouldn't know why nobody would be awake........
21:16:51 * ksf intended to learn conditionals for like 8 years now.
21:17:15 <Twey> Hahaha, conditionals?
21:18:27 <dons> we usually have about 5% active.
21:18:28 <dons> up to 10%
21:18:49 <dons> ?users
21:18:49 <lambdabot> Maximum users seen in #haskell: 550, currently: 472 (85.8%), active: 10 (2.1%)
21:18:51 <askentasken> i like Maybe for fail. does Myabe always work, like openFile reutnr sMyabe?
21:19:05 <dons> askentasken: no, actually. but you can tell by the type.
21:19:19 <dons> and you can lift other errors into Maybe
21:19:27 <dons> or Maybe into other errors
21:19:46 <ksf> http://www.englishlanguageguide.com/english/grammar/conditionals.asp
21:19:49 <ksf> those buggers.
21:19:53 <lambdabot> Title: English Grammar: Conditionals, http://tinyurl.com/6yznxr
21:20:13 <Twey> Oh, *English* conditionals
21:20:20 <askentasken> How do i create a data.Array.array?
21:20:21 <Twey> Subjunctive mood getting to you?  :-P
21:20:39 <askentasken> let arr = A.array 3 4 doesnt work
21:21:32 <dancor> > array (3, 4) [(3, "Three"), (4, "Four")]
21:21:34 <lambdabot>   array (3,4) [(3,"Three"),(4,"Four")]
21:21:44 <askentasken> let a = Data.Array.array (4,3)
21:21:49 <askentasken> but i cant show it
21:22:05 <ksf> English got a subjunctive?
21:22:14 <dancor> askentasken: array takes a pair of bounds and a list of index,value pairs
21:22:27 <Twey> > show $ array (4, 3) [(3, "Three"), (4, "Four")]
21:22:28 <dancor> askentasken: so your a there is not an Array
21:22:28 <lambdabot>   "array * Exception: Error in array index
21:22:30 <ksf> Damn my English teachers, all of them.
21:22:38 <Twey> > show $ array (3, 4) [(3, "Three"), (4, "Four")]
21:22:39 <lambdabot>   "array (3,4) [(3,\"Three\"),(4,\"Four\")]"
21:22:39 <dancor> :t Data.Array.array (4,3)
21:22:41 <lambdabot> forall t e. (Ix t, Num t) => [(t, e)] -> Array t e
21:22:45 <Twey> A pair of bounds in order, apparently :(
21:22:57 <Twey> ksf: Haha
21:23:09 <dancor> :t Data.Array.array (4,3) [(3, "Three"), (4, "Four")]
21:23:10 <lambdabot> forall t. (Ix t, Num t) => Array t [Char]
21:23:13 <Twey> ksf: 'Were I covered in fur, I would suspect myself of being a mongoose.'
21:23:23 <dancor> askentasken: if you want an "empty" Array
21:23:59 <dancor> > listArray ((0,0), (3,4)) $ repeat ""
21:24:01 <lambdabot>   array ((0,0),(3,4)) [((0,0),""),((0,1),""),((0,2),""),((0,3),""),((0,4),"")...
21:24:12 <ksf> Knowing that, I might now even be able to see some sense in the conditionals' grammar.
21:24:34 <dancor> that's a 2d array which is four wide and five tall and everything has value empty-string
21:24:36 <askentasken> i dont get it
21:24:49 <askentasken> i want [[0,0,0],[0,0,0],[0,0,0]]
21:25:07 <askentasken> and i want to easily update at a given row-col-index
21:25:08 <dancor> > listArray ((1,1), (3,3)) $ repeat 0
21:25:09 <lambdabot>   array ((1,1),(3,3)) [((1,1),0),((1,2),0),((1,3),0),((2,1),0),((2,2),0),((2,...
21:25:41 <dancor> > let a = listArray ((1,1), (3,3)) $ repeat 0 in a // [((1,2), 888)]
21:25:43 <lambdabot>   array ((1,1),(3,3)) [((1,1),0),((1,2),888),((1,3),0),((2,1),0),((2,2),0),((...
21:26:13 <dancor> you could also do it 0-indexed depending on your preferrence/application
21:26:18 <Twey> I need to learn to use Arrays at some point, hmn.
21:26:27 <dancor> > let a = listArray ((0,0), (2,2)) $ repeat 0 in a // [((0,1), 888)]
21:26:28 <lambdabot>   array ((0,0),(2,2)) [((0,0),0),((0,1),888),((0,2),0),((1,0),0),((1,1),0),((...
21:26:35 <askentasken> and how do i get-at-index?
21:26:41 <dancor> :t (!)
21:26:42 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
21:26:47 <dancor> :t (//)
21:26:48 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
21:27:17 <dancor> http://hackage.haskell.org/packages/archive/array/0.1.0.0/doc/html/Data-Array-IArray.html
21:28:38 <askentasken> wtf cant i do something like: update_at 1 2 "X" board , menaing update the Array board at index row=1, col=2 to "X"
21:29:29 <dancor> let updateAt x y v a = a // [(x, y), v]
21:29:34 <dancor> let updateAt x y v a = a // [((x, y), v)]
21:29:35 <dancor> rather
21:30:13 <ddarius> Twey: You only need to learn them if you need them.
21:30:28 <Twey> ddarius: Yes, but I'm going to need them :)
21:30:43 <ddarius> Twey: Are you sure?
21:30:57 <ddarius> Immutable arrays are mostly useless.  Mutable arrays are more useful.
21:31:14 <Twey> I meant the mutable ones, of course.
21:31:20 <Twey> The interface is mostly the same, no?
21:31:30 <ddarius> Not really, no.
21:31:38 * dancor doesn't seem how immutable Array's are not useful..
21:31:43 <Twey> Oh.  I guess I'd better learn the mutable version, then.
21:32:02 <Twey> What're the main use cases for the immutable arrays?
21:32:55 <dancor> i use them whenever i have a board structure in games or displaying and working with tabular stuff..
21:33:30 <dancor> i would never use mutable arrays unless i thought i had to for some perf thing
21:33:44 <Twey> Wouldn't a mutable one be better for that latter?  Assuming a large range.
21:34:03 <dancor> i never worry about it bc of laziness
21:34:09 <dancor> i guess i'm still waiting to run into a problem
21:35:37 <roconnor> > Numeric.showHex (-16711681::Int) ""
21:35:38 <lambdabot>   "* Exception: Numeric.showIntAtBase: applied to negative number -16711681
21:36:07 <roconnor> > Numeric.showHex (16711681::Int) ""
21:36:08 <lambdabot>   "ff0001"
21:36:24 * dancor had assumed immutable was clearly the purer option and so preferable unless you have reason
21:36:44 <dons> well, Arrays. mm.
21:37:14 <Twey> Can't we have mutable arrays with a pure-looking interface?
21:37:15 <ddarius> dancor: I rarely use arrays mutable or otherwise.
21:37:17 <dons> IntMap (i.e. a trie), makes more sense for immutable arrays
21:37:33 <Twey> A bit of unsafePerformIO in there just for performance?
21:37:38 <dons> Twey: sure. via diffs, or fusion, or ...
21:37:47 <dons> but somehow you have to keep around all the old versions
21:37:57 <Twey> Oh, yeah.
21:37:58 <Twey> Hmph.
21:38:43 <ddarius> Twey: If you can operate whole arrays at a time, then you can get fine performance.  This is how, e.g. uvector and the parallel array stuff works.
21:40:15 <askentasken> can i sum over a row or col in an array?
21:41:02 <dons> depends on which array library you use.
21:41:22 <dons> but if you're thinking in terms of rows and columns, i'd recommend one of the matrix libs
21:41:31 <askentasken> the problem with Haskell datastructures are that there are 100 operaions to leanr on each instead of a few easily understood ones that can then be combined together
21:41:42 <ddarius> The standard array library has a paucity of operators and a poor interface.
21:41:51 <dons> askentasken: ?
21:42:04 <dons> usually there's just a few primitives. which fall out of the very structure of the data type.
21:42:09 <askentasken> im doing TicTcToe and want to check if there is 3 ina row somewhere, using Data.Array
21:42:17 <dons> oh, just use a list.
21:42:40 <askentasken> but i was told to use an array
21:42:46 <dons> the Data.Array interface is very simple.
21:42:51 <dons> it has what, 4 operations on it.
21:42:51 <askentasken> for a list, how would i update at?
21:42:57 <dons> split and combine.
21:43:29 <dons> i'd probably use an IntMap or a mutable array, actually. immutable arrays don't make much sense if you need updates
21:43:33 <dancor> you certainlly _can_ do it with array but you will have to write your own column-sum, ironically bc Array has so few primitives :)
21:43:37 <dons> lists are ok for small things.
21:43:46 <dons> dancor: right, or use uvector or something else like hmatrix
21:44:02 <askentasken> hmatrix fails to install on my system
21:44:21 <dons> anyway, its just tictactoe, use lists :)
21:45:58 <dancor> is IntMap 1d so you'd have to do your own y*w+x stuff?
21:46:15 <dancor> that's kind of lame if you have a 2d thing in reality
21:46:25 <dons> well, 2d arrays are also ok
21:46:35 <dons> so maybe a 2d mutable array
21:46:38 <dons> or a 2d list
21:47:24 <dons> have a look at the sample sudoku solvers
21:47:28 <dons> most of them use lists, iirc
21:47:36 <askentasken> split and combine how do they work?
21:48:12 <dons> well, your goal would be to learn enough of Data.List to write an update function on lists.
21:48:32 <dons> hey, is haskell.org down?
21:48:54 <Corun> http://downforeveryoneorjustme.com/haskell.org
21:48:59 <lambdabot> Title: It's just you.
21:49:03 <Corun> Heh
21:49:14 <Corun> That was unexpectedly efficient
21:49:35 <dancor> esp for their ad revenue
21:49:44 <askentasken> but wtf how thee not be a function for that?
21:49:51 <askentasken> so silly this language is
21:50:01 <askentasken> its not that i dont know how
21:50:03 <dancor> askentasken: there are different data structures for different things ya
21:50:09 <askentasken> i just dont want to redo everything
21:50:33 <dancor> askentasken: doing it "right" would be like hmatrix
21:51:01 <dancor> if you just want to get it done you could write a row-sum in Array
21:53:39 <Twey> Isn't an immutable array basically just a Map?  What's the difference?
21:54:33 <dancor> > let updateL i v xs = take i xs ++ v ++ drop (i + 1) xs in updateL 2 "C" "abcdefg"
21:54:35 <lambdabot>   "abCdefg"
21:57:09 <dancor> Twey: presumably the Array implementation could benefit from knowing that the index range is contiguous?
21:57:26 <dancor> so Map is kind of like a possibly-spares Array..
21:57:30 <dancor> sparse
21:57:58 <dancor> maybe i will start using Map's where I use Array's..
21:58:28 <dancor> the paradox of choice
21:58:50 <Twey> Perhaps, yes
21:59:03 <dancor> List and Map are obvi more generally useful than Array
21:59:04 <Twey> I imagine there could be some minor performance benefit there
22:03:58 <dons> i'm at a conference next week, where there's a talk on yottabyte data management.
22:04:06 <dons> do you think linked lists will work? :)
22:05:09 <Twey> Depends what you want to use them for :-P
22:05:40 <dons> wikipedia informs me the Earth ways 5k Yg.
22:05:45 <dons> weights.
22:05:57 <dancor> also that "ccording to one study, all the world's computers stored approximately 160 exabytes in 2006, with nearly 1 zettabyte projected by 2010."
22:06:14 <dons> interesting.
22:06:20 <dons> so a somewhat forward looking talk.
22:10:19 <dancor> the Earth is 5 Xg under http://jimvb.home.mindspring.com/unitsystem.htm
22:10:21 <lambdabot> Title: Extended System of Units
22:11:04 <ddarius> And a Map is just slightly more than a function.
22:11:40 <dancor> -funroll-functions
22:14:48 <askentasken> how can iw rite: while (not hasWinner board) do
22:16:17 <dancor> let playGame = if hasWinner board then return () else do {..; playGame}
22:16:26 <dancor> probably something like that..
22:18:02 <Valarnin> Hello! I'm working on Project Euler, problem 13, in C++. I seem to be having an issue though, and I can't find it. Could anyone take a look for me? http://rafb.net/p/qnaNdo54.html
22:18:03 <lambdabot> Title: Nopaste - No description
22:21:27 <askentasken> i have [[1,0,0],[0,0,0],[0,0,0]] and want to sum over th sol of the first row
22:21:32 <askentasken> sumCols xs index = foldl (\x y -> x !! index + y !! index) 0 xs
22:21:39 <askentasken> Occurs check: cannot construct the infinite type: a = [a]
22:21:39 <askentasken>       Expected type: [a]
22:27:20 <ddarius> :t transpose
22:27:21 <lambdabot> forall a. [[a]] -> [[a]]
22:29:57 <askentasken> nice
22:30:00 <askentasken> i did sumCols xs index = foldl (\x y -> x + y !! index) 0 xs
22:30:35 <dancor> :t sum
22:30:36 <lambdabot> forall a. (Num a) => [a] -> a
22:30:57 <askentasken> i know thanks
22:30:57 <askentasken> sumCols2 xs index = sum $ L.transpose xs !! index
22:32:28 <askentasken> summing the diagonal, do i ahve tow rite my own recursive func then?
22:32:44 <askentasken> or is there some clever trick for lining up the diagonal so i can sum it?
22:33:02 <dancor> could use list comprehension
22:33:19 <dancor> or a cool recursion
22:34:27 <dancor> > let b = [[1,0,0],[0,1,0],[0,0,0]] in [b !! i !! i for i in [0..2]]
22:34:28 <lambdabot>   <no location info>: parse error on input `in'
22:34:41 <dancor> > let b = [[1,0,0],[0,1,0],[0,0,0]] in [b !! i !! i | i <- [0..2]]
22:34:42 <lambdabot>   [1,1,0]
22:34:43 <dancor> lol
22:38:24 <askentasken> is it possible to have a fold with an accumulator
22:38:28 <askentasken> 2 chanign variables
22:39:19 <dons> yes.
22:39:22 <ddarius> > let diag [] = []; diag xs = head (head xs) : diag (map tail (tail xs)) in diag [[1,0,0],[0,2,0],[0,3,0]]
22:39:23 <lambdabot>   [1,2,0]
22:39:23 <dons> just use a pair as the state
22:40:03 <jeffz> records work too
22:44:20 <askentasken> [x !! index | x <- board | index [0..]]
22:44:27 <askentasken> Illegal parallel list comprehension: use -XParallelListComp
22:44:39 <askentasken> something int he spirit of that should work right?
22:50:09 <ddarius> > zipWith (flip (!!)) [0..] [[1,0,0],[0,2,0],[0,0,3]]
22:50:10 <lambdabot>   [1,2,3]
22:51:34 <askentasken> sum $ [ x !! y | (x,y) <- zip board [0,1,2]]
23:00:44 <askentasken> hasWinner board_ | sum $ board !! 0 == 3 || sum $ board !! 0 == 27  = True
23:01:31 <askentasken> Couldn't match expected type `Bool'
23:01:31 <askentasken>            against inferred type `[a] -> a'
23:01:58 <roconnor> askentasken: more brackets?
23:02:33 <askentasken> aj
23:02:36 <askentasken> ah
23:03:06 <roconnor> hasWinner board = sum $ board !! 0 == 3 || sum $ board !! 0 == 27
23:03:30 <roconnor> no need for if foo then True else False.
23:24:27 <twb> @hoogle Char -> Bool
23:24:27 <lambdabot> Data.Char isAlpha :: Char -> Bool
23:24:27 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
23:24:27 <lambdabot> Data.Char isAscii :: Char -> Bool
23:24:41 <twb> Bah, hayoo gives useless results for that search.
23:33:53 <askentasken> blarf!
23:33:58 <askentasken> randMove = do
23:33:59 <askentasken>   seed1 <- R.newStdGen
23:33:59 <askentasken>   seed2 <- R.newStdGen
23:33:59 <askentasken>   return $ (rand seed1, rand seed2)
23:34:05 <askentasken> No instance for (Show (IO (Integer, Integer)))
23:34:05 <askentasken>       arising from a use of `print'
23:34:05 <askentasken>                    at c:/ghc-6.8.3/Prog
23:34:53 <twb> When I run "cabal build", it prints the input and output file in parentheses.
23:35:05 <twb> Can I suppress the part in between the parens?
23:35:22 <twb> I'd rather it just printed "[ 40 of 133] Compiling Darcs.External" by default.
23:37:35 <lispy> conal: I think the problem with the lazy pattern is that pattern matches, like 'case' have to bind the existentials at that spot in the program.  But, this seems to be at odds with delaying the pattern match
23:37:55 <solrize> @hoogle fix
23:37:55 <lambdabot> Data.Function fix :: (a -> a) -> a
23:37:55 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
23:37:55 <lambdabot> module Control.Monad.Fix
23:40:48 <sciolizer> `sudo cabal install haskell-src-exts` says that it cannot find happy version >=1.17. The output of ghc-pkg list agrees. But I already ran `sudo cabal install happy`; no errors were reported, and there's a happy file sitting in ~/.cabal/bin. Any ideas? (Ubuntu, kernel 2.6.24, ghc 6.8.2)
23:40:50 <dancor> what is cooler:  reverse . sortBy c  or  sortBy ((not .) . c)
23:41:16 <askentasken> how do i convert from int to integer and interger to int? and whya re there 2 types nyway?
23:41:30 <dancor> err not doesn't work.. but you know what i mean
23:42:07 <sciolizer> askentasken: fromIntegral will convert from Int and Integer into any type that you need.
23:42:18 <sciolizer> askentasken: er, any numeric type that you need
23:42:32 <dancor> :t fromIntegral
23:42:34 <lambdabot> forall a b. (Num b, Integral a) => a -> b
23:43:13 <sciolizer> askentasken: Int fits in a CPU register, Integer is arbitrary precision.
23:43:14 <askentasken> scio: i am in int and want integr
23:44:04 <sciolizer> askentasken: (fromIntegral myNum :: Integer)
23:44:56 <sciolizer> askentasken: The ":: Integer" is unnecessary if it can be inferred from context.
23:53:37 <lispy> sciolizer: is happy in your path?
23:53:53 <lispy> sciolizer: iirc, the default path for cabal installed things is something like ~/.cabal/bin
23:53:57 <askentasken> cant i do let blah in hah if x then y else z in a something = do ?
23:56:58 <kfish> who needs beat poetry when you can have beat haskell
23:58:32 <askentasken> http://hpaste.org/12083
