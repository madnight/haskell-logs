00:00:47 <extasic> I now tried
00:00:48 <extasic> assignments (x:xs) = concat ([ [(x,True)] ++ (assignments xs) ] ++ [ [(x,False)] ++ (assignments xs) ])
00:01:58 <extasic> but that is wrong as well
00:02:10 <rwbarton> You are still adding (x,True) to the front of the return of assignments xs, whereas you want to add it to the front of each of its elements
00:04:42 <extasic> *sigh*
00:06:52 <extasic> :r
00:06:54 <extasic> ups
00:09:37 <rwbarton> extasic: do you know how strings are lists of characters?
00:11:06 <extasic> yes
00:11:18 <rwbarton> imagine you have a variable y = ["ello", "askell"]
00:11:26 <rwbarton> and you want to produce ["hello", "haskell"]
00:11:33 <rwbarton> how would you write that expression?
00:11:56 <Baughn> s/variable/binding/g
00:12:12 <extasic> aah, ok, now I know what you mean
00:12:16 <BeelsebobWork> extasic: essentially what you're going for is assignments (x:xs) = (prepend (x,True) to each of as ++ prepend (x,False) to each of as) where as = assignments xs
00:12:35 <BeelsebobWork> the only real question is how do you do "prepend (x,y) to each of as"
00:12:52 <SubStack> > map ('h':) ["ello", "askell"]
00:12:53 <lambdabot>   ["hello","haskell"]
00:13:23 <extasic> great, thank you!
00:13:24 <BeelsebobWork> SubStack: noting that he's not allowed to use map ;)
00:13:58 <extasic> I have to go now, thank you so much!!!
00:14:10 <BeelsebobWork> extasic: incidentally -- what uni are you at?
00:14:21 * SubStack hadn't read that far up yet
00:16:09 <SubStack> that's neat that some schools are teaching haskell
00:16:27 <BeelsebobWork> there's tons of schools teaching it
00:16:37 <BeelsebobWork> at least in the UK
00:16:48 <SubStack> although I can't stand it in any language when students aren't allowed to use the best tool for the job
00:16:58 <BeelsebobWork> heh
00:17:01 <Baughn> Here we're stuck on java, but I can at least take pleasure in making all the other students look foolish
00:17:14 <yitz> Didn't the ACM just make it a part of the core CS curriculum in the US?
00:17:18 <BeelsebobWork> that was how York tought stuff -- they never tought us a language -- they just taught whatever course we were doing in the best language for doing it
00:17:35 <BeelsebobWork> so e.g. we all learned Ada by absorbtion, because it was used in the real time systems course
00:18:14 <yitz> we learned PL/I by force feeding
00:18:23 <BeelsebobWork> heh
00:18:43 <SubStack> it's all c++ here, although I've used anything else whenever I can get away with it
00:18:48 <SubStack> lately mostly haskell
00:18:48 <olsner> pretty cool that they have the cajones to give a course using a language you haven't already had a course in
00:19:09 <BeelsebobWork> SubStack: that sounds like it fails
00:19:11 <BeelsebobWork> what uni?
00:19:14 <Baughn> olsner: Having a whole course just to teach a language would be a bit silly, though
00:19:23 <Baughn> olsner: We did have one to teach about half a dozen languages
00:19:26 <yitz> we didn't notice the problems with PL/I though. we were too worried about dropping the deck of punched cards.
00:19:35 <SubStack> BeelsebobWork: university of alaska fairbanks
00:19:40 <Baughn> (Sadly, it sucked)
00:20:50 <SubStack> but I get to use haskell at work :D
00:21:02 <olsner> Baughn: we have one course for each of a bunch of paradigms (i.e. functional, imperative, object-oriented, and obscure), then make sure that they include some mention of every language used in labs for any other course
00:21:10 <yitz> and feeding the horse that took us to the computer center
00:22:05 <Baughn> olsner: "Obscure" isn't a paradigm. -_-
00:22:08 <yitz> olsner: obscure == logic programming?
00:22:12 <Baughn> Unless you mean design by obfuscation
00:22:31 <olsner> because courses can't require knowledge that isn't provided by another course, and a course like "systems programming" couldn't include a significant chunk of something unrelated like learning a new language
00:22:59 <olsner> Baughn: something like "trying out a few other things we couln't fit in anywhere"
00:23:12 <Plareplane> what's this? http://www.haskell.org/ghc/dist/stable/dist/ghc-6.10.1-src.tar.bz2
00:23:14 <lambdabot> http://tinyurl.com/6rmf3k
00:23:19 <Peaker> also I'd say OO and Procedural are both imperative. OO just happens to organize the imperative code in a more sane manner
00:23:22 <yitz> olsner: sounds like they had the same problems that the designers of cabal have
00:23:31 <Baughn> Plareplane: Whee!
00:23:34 <olsner> I think haskell, ML and prolog would go under that umbrella since we have lisp for the functional part
00:23:35 <BeelsebobWork> Peaker: I don't think that last part is true
00:23:40 <BeelsebobWork> it certainly organises code
00:23:48 <BeelsebobWork> but whether it's more sane or not depends entirely on the project
00:24:20 <yitz> BeelsebobWork: it depends on who was the architecht
00:24:22 <Peaker> BeelsebobWork: well, procedural code often divided code based on semantics or chronologically or other silly ideas.  OO always divides code based on the concept it relates to, so that's a step forawrd
00:25:00 <BeelsebobWork> Peaker: true -- but (for example) trying to write a compiler in a truely OO way results in an inefficient mess
00:25:06 <Peaker> BeelsebobWork: for example, you will see lots of "procedural code" with all of the "constants" (relating to anything at all) together, whereas an OO project will at least have the constants related to some concept together with that concept's data declarations and code
00:25:29 <Peaker> BeelsebobWork: I too have discovered the folly of OO recently ;) Its still a step forward over the disorganized mess called "procedural" :)
00:25:55 <BeelsebobWork> Peaker: again, I think that entirely depends on the project, and the guy architecting the procedural code
00:26:09 <BeelsebobWork> in a lot of cases though, yes OO code causes brain dead monkeys to write something half decent
00:26:26 <BeelsebobWork> rather than something resembling an italian resteraunt's kitchen
00:26:36 <SubStack> it's still blub
00:27:07 <Peaker> BeelsebobWork: I think well-organized procedural code (where its modularity is done sanely) is really just OO code in a non-OO language...
00:27:30 <olsner> maybe that's just the OO hivemind getting to them
00:31:05 <olsner> I'd say procedural and functional have in common (in contrast to OO) that they focus on data and what happens to it (i.e. algorithms), rather than building a huge model of something and then send messages into it or ask stuff to do something (almost like anthropomorphising data)
00:32:38 <quicksilver> olsner: I'm not sure that's a fair characterisation in general.
00:32:48 <quicksilver> olsner: It's an accurate characterisation of what happens sometimes.
00:32:52 <yitz> olsner: the linux kernel code has a lot of OO-think in it, emulated in C.
00:33:41 <Peaker> olsner: "messages" is just a way to say that polymorphism is based on 1 argument, but with ugly workarounds ("Visitor") you can really have multimethods, so I think the term "message" in OO is just misleading
00:33:48 <quicksilver> good OO-think is sensible encapsulation.
00:33:52 <yitz> it's so much part of the prevailing culture that people instinctively think that way
00:34:12 <quicksilver> bad OO-think is when you apply techniques which don't apply because it's the only hammer you have.
00:34:32 <olsner> well, obviously my theory is a generalization of the subset of the world that matches the theory :)
00:35:37 <Peaker> olsner: if you encapsualte your state and use data hiding in your procedural program - then you're really just doing OO
00:35:56 <yitz> quicksilver: besides encapsulation, it also means modeling complex systems using the "is-a" relationship. that sometimes works, but often results in spaghetti.
00:36:34 <olsner> Peaker: well, yes, you can write OO in almost any language
00:37:02 <Peaker> olsner: and if you're not doing any data hiding, then you're just not using any abstraction at all, and that sucks (that's what I see as "procedural")
00:37:11 <quicksilver> yitz: that's certainly a common problem.
00:37:27 <quicksilver> yitz: conversely, successful OO systems don't use 'is-a' very much. I.e. inheritance is not used that commonly.
00:37:55 <quicksilver> the only place that is-a really does seem to work is GUI toolkits.
00:38:51 <yitz> quicksilver: inheritance is appropriate in OO when you need polymorphism. the trick is to design a simple enough structure that still provides all the polymorphism you need.
00:39:47 <Peaker> quicksilver: I think "is-a" is pretty much a wrapping data type that happens to delegate most of its instances to the particular data member it wraps.  Its a weird way of doing the delegation and also forms a big polluted "self" namespace..
00:39:55 <olsner> Peaker: plenty of OO doesn't involve data hiding, like languages with all-public member variables
00:40:30 <Peaker> olsner: data-hiding by convention (underscore-first means private) is also a form of data-hiding..
00:40:33 <quicksilver> olsner: that's still (often) viewed as advisory hiding.
00:41:30 <olsner> hmm, yes... I guess in the end it just comes down to what code you write
00:41:48 <quicksilver> of course.
00:42:20 <Peaker> olsner: also note: #define private public ; #include <blah>  :-)
00:42:31 <Peaker> olsner: C++ data hiding is also conventional, in that sense :)
00:43:55 <olsner> compilers could make that impossible to exploit if they wanted, I'm pretty sure you waive all guarantees of working separate compilation by doing that :P
00:44:34 <yitz> olsner: ok, use  m4 instead. you'll always be able to get around the compiler.
00:44:35 <olsner> (which, sadly, isn't to say that there is any compiler out there where it won't work)
00:44:48 <Heooo> Can someone explains this sentence: "Beta reduction expresses the idea of function application. The beta reduction of  ((? V. E) E?)  is simply  E[V := E?] ." ?
00:44:56 <Heooo> *s
00:45:29 <Peaker> Inheritence is used for so many purposes, and each of these purposes is better served by other mechanisms...  I realized I hated inheritence way before I discovered Haskell/FP
00:45:45 <Peaker> I was using Python, and virtually never using inheritence..
00:47:25 <thoughtpolice> Heooo: If you have the expression 'E[v := x]' then it means 'the expression E where all free occurences of v are bound to x'
00:48:53 <SubStack> prototyping can be fun in languages like that
00:49:36 <thoughtpolice> Heooo: think of a lambda expression (\v. E) - then, if we apply it i.e. '(\v. E) x' we can reduce the overall expression to a simpler form. that is, '(\v. E) x' is the same as simply saying 'E' where all 'v's are replaced by x, or simply 'E[v := x]'
00:50:38 <thoughtpolice> this is known simply as beta reduction - the reduction of a lambda applied to arguments.
00:51:50 <Heooo> thoughtpolice: So is this equivalent: ((/ V. E) E') = E[V := E'] ? I thought E[V := E'] means that you replace every V by E' in E? Wrong?
00:52:00 <thoughtpolice> Heooo: for example, given (\v -> func2 v * func3 v), the beta reduction when applied to 'x' results in 'func2 x * func3 x'
00:52:53 <thoughtpolice> Heooo: yes
00:53:19 <thoughtpolice> Heooo: that's correct - there are other forms of reduction as well
00:54:32 <Heooo> thoughtpolice: Is this equivalent:  where all free occurences of v
00:54:38 <Heooo>                         are bound to x'
00:54:42 <Heooo> to
00:54:57 <thoughtpolice> Heooo: well think of for example '(\v. (\v. v*3) + v)'
00:55:33 <Heooo> + ?
00:55:38 <thoughtpolice> in reducing the outermost lambda abstraction, we replace only the /free/ occurences of v in '(\v. v*3) + v'
00:56:04 <Heooo> arithmetics?
00:56:09 <thoughtpolice> if we replaced the v that appears inside the inner lambda abstraction,
00:56:12 <thoughtpolice> the result would be wrong
00:56:59 <Heooo> + stands for free variable?
00:57:16 <unenough> does it really make sense for Double/Float to be in Enum?
00:57:25 <Heooo> thoughtpolice: + stands for free variable?
00:57:29 <Deewiant> unenough: no, not really
00:57:29 <thoughtpolice> e.g. (\v. (\v. v*3) + v) x y => ((\v. v*3) + x) y ==> (y*3) + x
00:57:32 <thoughtpolice> Heooo: no
00:57:34 <unenough> pi's successor is pi+1 ?
00:57:35 <unenough> heh
00:57:36 <thoughtpolice> it's just an example
00:57:56 <Heooo> thoughtpolice: + is just some operation?
00:57:57 <unenough> Deewiant, so why are they??
00:58:03 <thoughtpolice> Heooo: yes, just an example
00:58:06 <Deewiant> unenough: on the one hand it doesn't make sense for Integer to be since (maxBound :: Int)'s successor is (minBound :: Int)
00:58:17 <thoughtpolice> Heooo: but that's why you only replace the /free/ occurences of the bound variable
00:58:25 <Deewiant> (when fromEnum'd from Integer, that is)
00:58:33 <Deewiant> unenough: and beats me, probably convenience
00:58:39 <Deewiant> > [0.1,0.2..1]
00:58:40 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999999...
00:58:45 <Deewiant> so that you can do that
00:58:56 <unenough> > succ ( maxBound :: Int)
00:58:57 <lambdabot>   * Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
00:58:59 <unenough> aha
00:59:02 <Heooo> thoughtpolice: I think it is because the structure of the tree must be the same after reduction?
00:59:10 <Deewiant> > succ (toInteger $ (maxBound :: Int))
00:59:11 <lambdabot>   9223372036854775808
00:59:14 <Deewiant> > fromEnum $ succ (toInteger $ (maxBound :: Int))
00:59:16 <lambdabot>   -9223372036854775808
00:59:25 <unenough> wha
00:59:34 <Deewiant> that's what I meant :-)
00:59:58 <unenough> > succ (toInteger (maxBound :: Int))
01:00:00 <lambdabot>   9223372036854775808
01:00:19 <unenough> Prelude> succ (toInteger (maxBound :: Int))
01:00:19 <unenough> 2147483648
01:00:29 <unenough> that's what happens in my ghci
01:00:35 <Deewiant> lambdabot's on a 64-bit machine
01:00:39 <thoughtpolice> Heooo: given "(\v. (\v. v*3) + v) x y", we reduce to come to "((\v. v*3) + x) y" -- note we don't replace the inner v because it is actually bound by an inner lambda abstraction already, i.e. that occurrence is bound, not free, so we leave it alone; otherwise we would get "((\v. x*3) + x) y" which would overall just reduce to "(x*3)+x"
01:00:43 <unenough> oh
01:00:55 <Deewiant> so maxBound::Int is 2^63-1 and not 2^31-1
01:00:56 <thoughtpolice> Heooo: which is wrong
01:01:05 <unenough> yes ok. so why does fromEnum do that?
01:01:22 <Deewiant> well it converts to an Int
01:01:33 <Deewiant> it /could/ throw an error I suppose
01:01:40 <unenough> should, probably
01:01:41 <Deewiant> > fromEnum 0.1
01:01:42 <lambdabot>   0
01:01:43 <Deewiant> > fromEnum 0.2
01:01:44 <lambdabot>   0
01:01:45 <Deewiant> ...
01:01:58 <unenough> ok, but that doesn't explain the float/double thing which makes no sense, but ok.
01:02:10 <Deewiant> I just thing that fromEnum/toEnum shouldn't lose information
01:02:13 <thoughtpolice> Heooo: for clarification, a variable in some expression 'E' is /bound/ if it is created by a lambda abstraction, and /free/ if it is not bound by a lambda, i.e. in the expression '\x. y + (x/4)', 'x' is bound, but 'y' is free as it is not bound by any lambda
01:02:23 <Deewiant> the notable cases where they do lose information are Integer, Double, Float.
01:02:44 <unenough> well, anything with more values than Int
01:02:56 <Deewiant> yep
01:03:02 <Deewiant> I'm not sure that such things shoulds be Enum
01:03:07 <Deewiant> s/ds/d/
01:03:22 <Heooo> thoughtpolice: So v after + is bound: v. (\v. v*3) + v)
01:04:13 <Heooo> thoughtpolice: actually all "v"s ie v*3 as well
01:04:29 <quicksilver> well on the one hand, the enum instances for float and double are utterly bogus
01:04:34 <quicksilver> and only there to make the range syntax worse
01:04:50 <quicksilver> on the other hand, from/toEnum really *should* target Integer
01:04:58 <quicksilver> they don't for efficiency I imagine
01:05:43 <Heooo> thoughtpolice: v. (\v. v*3) + v) [v := a] => a. (\a. a*3) + a          Correct?
01:06:23 <mmorrow> , let sub bnd env e@(VarE n) | n `elem` bnd = e | otherwise = maybe e id (lookup n env) ; sub bnd env (LamE [VarP n] e) = LamE [VarP n] (sub (n:bnd) env e) ; sub bnd env (AppE e e') = AppE (sub bnd env e) (sub bnd env e') ; sub _ _ _ = error "invalid expression" in ppDoc $ sub [] [(mkName "y",LitE (IntegerL 42))] ((either undefined id . parseExp) "(\\x -> (\\y-> y) y)")
01:06:26 <mmorrow> hehe
01:06:26 <lunabot>  \x -> (\y -> y) 42
01:06:35 <unenough> what's this:
01:06:39 <unenough> > maxBound :: Char
01:06:40 <lambdabot>   '\1114111'
01:06:44 <unenough> unicode?
01:06:44 <Deewiant> > 0x10ffff
01:06:46 <lambdabot>   1114111
01:06:49 <Deewiant> yep
01:06:50 <mmorrow> unenough: yes
01:06:52 <thoughtpolice> Heooo: no we don't replace the inner v
01:06:56 <unenough> k
01:07:01 <thoughtpolice> Heooo: it is already bound by an abstraction
01:07:08 <thoughtpolice> hence it is not free, and does not need to be replaced
01:07:17 <mmorrow> sub bnd env (LamE [VarP n] e) = LamE [VarP n] (sub (n:bnd) env e)
01:07:30 <Heooo> thoughtpolice: but I changed also the other v. So the structure stays actually the same
01:07:31 <mmorrow> notice how the name 'n' is added to the bnd list
01:07:37 <mmorrow> then
01:07:43 <mmorrow> sub bnd env e@(VarE n) | n `elem` bnd = e | otherwise = maybe e id (lookup n env
01:08:10 <mmorrow> before looking up a name, it's checked if it's bound (ie whether it really is free or not)
01:08:18 <unenough> why isn't Float Bounded?
01:08:24 <Deewiant> > Infinity :: Float
01:08:26 <lambdabot>   Not in scope: data constructor `Infinity'
01:08:29 <Deewiant> d'oh
01:08:31 <Deewiant> > (1/0) :: Float
01:08:33 <lambdabot>   Infinity
01:08:37 <unenough> oh, thats why
01:08:46 <unenough> but there IS a maximum value
01:08:52 <Deewiant> true
01:09:10 <unenough> > Infinity + 1
01:09:11 <lambdabot>   Not in scope: data constructor `Infinity'
01:09:18 <unenough> > (1/0)::Float + 1
01:09:19 <lambdabot>       No instance for (Show (+ Float Unit))
01:09:19 <lambdabot>        arising from a use of `sho...
01:09:34 <Deewiant> unenough: that was :: (Float + 1)
01:09:39 <thoughtpolice> Heooo: remember beta reduction is E[v := x] in '(\v. E) x', so for (\v. (\v. v*3) + v), E == "(\v. v*3) + v" and replacing all /free/ occurences of v in this expression with 'x' results in "(\v. v*3) + x" -- the 'v*3' expression is using an instance of v that is already bound, and that inner lambda is reduced in its own separate reduction step
01:09:43 <unenough> > ((1/0)::Float) + 1
01:09:44 <lambdabot>   Infinity
01:10:00 <Deewiant> infinity + anything except -infinity is infinity :-)
01:10:06 <Deewiant> and except nan
01:10:20 <unenough> yeah i guess it don't fit the bounded definition
01:10:22 <Heooo> thoughtpolice: So this is right: ( (\x.x) yx) [x := d]   =>  ( (\x.x) yd) but what about this: ( (\x.x) yx) [x := y]   =>  ( (\x.x) ay) ?
01:10:29 <BeelsebobWork> > ((1 / 0) :: Float) < (NaN)
01:10:31 <lambdabot>   Not in scope: data constructor `NaN'
01:10:32 <unenough> but also, Float does have a maximum representable value that isn't infinity
01:10:33 <ManateeLazyCat> Hi, everyone! Now I start to write a multi-thread download manager for study Haskell deeply. So I have two question. First, have anyone write multi-thread download manager use Haskell? Second, I have read "Real World Haskell", it's great, so have any others book or website that intro about network programming with Haskell ? Thanks :)
01:10:42 <BeelsebobWork> > (1 / 0) :: Int
01:10:43 <lambdabot>       No instance for (Fractional Int)
01:10:43 <lambdabot>        arising from a use of `/' at <i...
01:10:46 <Deewiant> unenough: yes, but you can still go up from there and get infinity
01:10:51 <BeelsebobWork> > (1 `div` 0) :: Int
01:10:52 <lambdabot>   * Exception: divide by zero
01:10:56 <thoughtpolice> Heooo: yes, and using another form of reduction you can change the names of bound variables
01:10:57 <BeelsebobWork> how does one get a NaN?
01:10:59 <thoughtpolice> to help avoid conflict
01:11:04 <Deewiant> unenough: I mean, I see your point, but I can also see the point of not making it bounded
01:11:07 <Deewiant> BeelsebobWork: 0/0
01:11:16 <mmorrow> ManateeLazyCat: can't think of any pre-existing prog. good luck!
01:11:17 <BeelsebobWork> > ((1 / 0) :: Float) < (0/0)
01:11:19 <lambdabot>   False
01:11:22 <unenough> yes, not making it bounded makes more sense, it doesn't quite fit the definition
01:11:22 <BeelsebobWork> awww :(
01:11:27 <mmorrow> , (0/0)
01:11:29 <lunabot>  NaN
01:11:31 <Deewiant> BeelsebobWork: nan compared to anything in any way is false
01:11:36 <BeelsebobWork> oh, okay
01:11:39 <Deewiant> > (0/0) == (0/0)
01:11:39 <mmorrow> , (0/0) + (1/0)
01:11:40 <lambdabot>   False
01:11:41 <lunabot>  NaN
01:11:43 <BeelsebobWork> so the definition of compare breaks the rules?
01:11:46 <Deewiant> yes
01:11:53 <Deewiant> > compare (0/0) (0/0)
01:11:55 <lambdabot>   GT
01:11:59 <Deewiant> > compare (0/0) (1/0)
01:12:00 <BeelsebobWork> o.O
01:12:00 <lambdabot>   GT
01:12:01 <Deewiant> > compare (0/0) (-1/0)
01:12:01 <unenough> heh
01:12:03 <lambdabot>   GT
01:12:06 <mmorrow> ha
01:12:10 <Deewiant> > compare (1/0) (0/0)
01:12:12 <lambdabot>   GT
01:12:19 <ManateeLazyCat> mmorrow: Thanks. I just want to write this program for study Haskell.
01:12:20 <Deewiant> compare _ NaN = GT
01:12:21 <unenough> that should cause an exception
01:12:23 <Deewiant> compare NaN _ = GT
01:12:26 <BeelsebobWork> > let x = 0 / 0; y = 0 / 0 in (compare x y, compare y x)
01:12:28 <Deewiant> I guess
01:12:28 <lambdabot>   (GT,GT)
01:12:33 <BeelsebobWork> :D
01:12:33 <unenough> @src compare :: Float
01:12:34 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:12:37 <Deewiant> but also more sneakiness
01:12:42 <Deewiant> > compare (0/0) (0/0)
01:12:44 <lambdabot>   GT
01:12:45 <mmorrow> ManateeLazyCat: totally. the only way to learn is to do :)
01:12:46 <dmwit> ManateeLazyCat: The "Roll your own IRC Bot" blog post probably has some information on network programming.
01:12:47 <Deewiant> > (0/0) > (0/0)
01:12:49 <lambdabot>   False
01:12:53 <BeelsebobWork> haha, awesome
01:13:00 <thoughtpolice> Heooo: but remember in the case of "((\x. x) y x)[x := y]" we actually get "(\x. x) y y"
01:13:00 <BeelsebobWork> > let x = 0 / 0; y = 0 / 0 in (compare x y, compare y x, x > y, y > x)
01:13:02 <lambdabot>   (GT,GT,False,False)
01:13:02 <unenough> wow
01:13:03 <Deewiant> it's well-specified
01:13:07 <Deewiant> just a bit weird
01:13:16 <BeelsebobWork> that is... uh, wierd
01:13:18 <unenough> it's GT but not > ?
01:13:23 <Deewiant> it's nothing
01:13:24 <unenough> that's not well specified
01:13:29 <Deewiant> compare has no "unordered" value
01:13:34 <unenough> obviously
01:13:35 <thoughtpolice> Heooo: I suggest you read this - http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/index.htm
01:13:36 <Deewiant> unenough: well, not in haskell terms maybe
01:13:36 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/yempzk
01:13:40 <thoughtpolice> it's free in its entirety
01:13:47 <thoughtpolice> and the 2nd chapter is a great into to the lambda calculus
01:13:50 <dmwit> compare :: Ord a => a -> a -> Maybe Ordering
01:13:54 <ManateeLazyCat> Thanks, guys! I love Haskell...
01:14:10 <unenough> that's good, don't hold back your feelings
01:14:12 <Deewiant> dmwit: not that bad an idea actually
01:14:16 <unenough> as long as they're positive...
01:14:26 <Deewiant> although the problem is really that such things shouldn't be Ord
01:14:33 <dmwit> Deewiant: It's bad from a mathematical perspective.
01:14:38 <dmwit> Deewiant: exactly
01:14:43 <Heooo> thoughtpolice: Ok, I come back to the problem as I have read it. Thanks!
01:14:49 <Deewiant> Stupid practicalities, always interfering :-)
01:14:49 <Heooo> *will
01:14:55 <unenough> the IEEE float maybe just should exist in haskell?
01:15:04 <unenough> SHOULDN'T
01:15:09 <dmwit> Deewiant: But then, floats don't satisfy the associativity of (+), either.
01:15:16 <dmwit> So what the hell.
01:15:33 <Deewiant> maybe floats should just be their own magic type class with all their own operations
01:15:46 <Deewiant> but it'd be so inconvenient and off-putting :-/
01:15:54 <dmwit> yeah
01:16:02 <Deewiant> I guess there's always CReal though
01:16:06 <Deewiant> > (0/0) :: CReal
01:16:07 <dmwit> We should maybe have TotalOrder and PartialOrder, though.
01:16:22 <lambdabot>   thread killed
01:16:24 <Deewiant> > (1/0) :: CReal
01:16:29 <Deewiant> hmm
01:16:35 <Deewiant> that's a bit of a sad way to divide by zero :-P
01:16:39 <lambdabot>   thread killed
01:16:48 <dmwit> > (1/1) :: CReal
01:16:49 <lambdabot>   1.0
01:16:55 <dmwit> huh, yeah
01:16:56 <unenough> @index CReal
01:16:57 <lambdabot> bzzt
01:17:04 <unenough> @hoogle CReal
01:17:05 <lambdabot> No results found
01:17:05 <Deewiant> unenough: on hackage
01:17:07 <dmwit> ?wiki CReal
01:17:07 <lambdabot> http://www.haskell.org/haskellwiki/CReal
01:17:14 <Deewiant> can't remember what it's called
01:17:29 <dmwit> http://www.haskell.org/haskellwiki/Applications_and_libraries/Mathematics
01:17:31 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/37jtrh
01:17:45 <dmwit> ?hackage era
01:17:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/era
01:17:46 <unenough> that wiki page contains "(There is currently no text in this page) "
01:17:59 <Cheery> hi
01:18:02 <dmwit> unenough: I know, I thought ?wiki searched, but it just does title replacement.
01:18:12 <Cheery> I've once hit upon an interesting feature in haskell
01:18:17 <unenough> so does hackage
01:18:18 <unenough> 404 Not Found
01:18:18 <unenough> The requested resource was not found: no such package 'era'
01:18:18 <dmwit> ?hackage is totally dumb, too
01:18:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/is totally dumb, too
01:18:28 <unenough> heh
01:18:31 <Cheery> seen you can assign operators in fly
01:18:33 <Deewiant> ?hackage numbers
01:18:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
01:18:35 <Deewiant> that's it
01:18:59 <Cheery> I'd like to know, what sort of hackery does haskell employ to solve the precedence in mathematical operators?
01:19:01 <dmwit> Deewiant: nice
01:19:22 <dmwit> Cheery: There are fixity declarations that declare associativity and precedence.
01:19:37 <dmwit> Cheery: Try ":i +" in ghci.
01:19:37 <Cheery> yes yes, what does they work on?
01:19:39 <mmorrow> Cheery: the lexer and parser are threaded through each other
01:19:51 <dmwit> Cheery: They can be applied to any function.
01:20:27 <Cheery> you mean you do not just take everything operator-looking into a list and solve that out?
01:20:41 <dmwit> There is a proposal to do that.
01:20:43 <mmorrow> Cheery: err, but actually the precedence is worked out after parsing without regard for precedence actually i believe
01:20:49 <dmwit> I'm hoping it gets into Haskell'.
01:21:10 <Cheery> dmwit: I'd like to get that into my experimental parser
01:21:19 <dmwit> Sounds good to me.
01:21:32 <Cheery> in the end it wont have such machinery to the user, because it can burn ppl badly
01:21:35 <dmwit> You should allow arbitrary real-valued precedences, too. ;-)
01:21:47 <Cheery> but for development its useful if I could define operators in fly :)
01:22:12 <unenough> CReal is unlimited precision?
01:22:19 <dmwit> unenough: Sort of.
01:22:28 <dmwit> unenough: Unlimited up to machine memory.
01:22:34 <Cheery> dmwit: just wondering about how to solve precedence in that manner?
01:22:40 <unenough> of course, and world supply of tissue paper too
01:22:54 <dmwit> right =)
01:23:18 <mmorrow> so "1 + 1 * 1" gets parsed initially as ((1 + 1) * 1), then after all the fixity declarations have been seen (after the AST has been constructed), it does another pass to fix the tree up given those precedences
01:23:18 <Cheery> I could write a small LR-parser for that only, but I wonder whether there's smarter way
01:23:34 <mmorrow> haskell is way hard to parse
01:23:43 <mmorrow> since it not context-dependent
01:23:48 <mmorrow> heh
01:23:57 <mmorrow> *since it's not context-independent
01:24:01 <Cheery> I'm thinking about prsing 1 + 1 * 1 as: [1, +, 1, *, 1]
01:24:06 <Cheery> or some other such
01:24:08 <unenough> that makes sense
01:24:22 <dmwit> Yeah, or ([1, 1, 1], [+, *]), maybe.
01:24:29 <Cheery> dmwit: that
01:24:32 <Cheery> 's better
01:24:39 <mmorrow> , either undefined id $ parseExp "1 + 1 * 1"
01:24:41 <lunabot>  InfixE (Just (InfixE (Just (LitE (IntegerL 1))) (VarE +) (Just (LitE (Int...
01:24:46 <mmorrow> ugh
01:25:27 <Cheery> it makes it a bit harder that I'd also like to get combination into comparison operators
01:25:28 <unenough> why is that better? how do you know where the + was
01:25:43 <Cheery> ie. 1 < n < 5 turns to: 1 < n & n < 5
01:26:01 <Cheery> unenough: easily
01:26:26 <dmwit> unenough: huh?
01:26:42 <dmwit> Cheery: Python has that, but I don't think I've ever seen it used.
01:26:54 <dmwit> Cheery: So if I were you, I'd suggest leaving it off to begin with.
01:27:07 <dmwit> Cheery: It's really hard to generalize in a meaningful way.
01:27:43 <mmorrow> , lex "1 + 1 * 1"
01:27:45 <lunabot>  [("1"," + 1 * 1")]
01:27:52 <dmwit> :t lex
01:27:53 <lambdabot> String -> [(String, String)]
01:28:00 <dmwit> :t unfoldr (listToMaybe . lex)
01:28:01 <lambdabot> String -> [String]
01:28:01 <Cheery> dmwit: I don't see that being hard really.
01:28:10 <Cheery> just fucking hard to parse :(
01:28:17 <dmwit> > unfoldr (listToMaybe . lex) "1 + 1 * 1"
01:28:18 <lambdabot>   ["1","+","1","*","1","","","","","","","","","","","","","","","","","","",...
01:28:20 <dmwit> hum
01:28:35 <dmwit> Does lex ever return an empty list?
01:28:39 <BeelsebobWork> dcoutts: you about?
01:28:42 <Deewiant> > lex ""
01:28:43 <lambdabot>   [("","")]
01:28:46 <mmorrow> , let go s = let (a,rest) = lex s in if null rest then [a] else a : go rest in go "\\x -> (x, [x,x])"
01:28:48 <lunabot>  luna: Couldn't match expected type `(t, t1)'
01:28:52 <dcoutts> BeelsebobWork: yarr!
01:28:52 <kaizoku> YARRRR
01:28:53 <dmwit> > lex "\255"
01:28:54 <lambdabot>   [("\255","")]
01:29:01 <dcoutts> kaizoku: you're weird
01:29:16 <Deewiant> @yarr
01:29:16 <kaizoku> YARRRR
01:29:16 <lambdabot> I heard andersca is a pirate
01:29:57 <dmwit> > unfoldr (listToMaybe . filter (not . null . snd) . lex) "1 + 1 * 1"
01:29:58 <lambdabot>   ["1","+","1","*"]
01:30:01 <dmwit> err
01:30:02 <BeelsebobWork> dcoutts: excellent -- can I pick your cabal brains -- I have ghc-6.9.somethingrandom, I'm trying to get to ghc-6.11.head, which needs me to compile happy.  Happy's Setup.lhs crashes in configure though, with Distribution/Compat/Exception.hs:21:14: Not in scope: `Exception.onException'
01:30:07 <dmwit> > unfoldr (listToMaybe . filter (not . null . fst) . lex) "1 + 1 * 1"
01:30:09 <lambdabot>   ["1","+","1","*","1"]
01:30:14 <mmorrow> , let go s = case lex s of [] -> [] ; [(a,[])] -> [a] ; [(a,rest)] -> a : go rest in go "\\x -> (x, [x,x])"
01:30:16 <lunabot>  ["\\","x","->","(","x",",","[","x",",","x","]",")"]
01:30:16 <BeelsebobWork> am I being a moron?
01:30:23 <dmwit> mmorrow: Beatcha to it. ;-)
01:30:26 <mmorrow> heh
01:30:34 <dcoutts> BeelsebobWork: no, it uses a later exception api from 6.10
01:30:54 <BeelsebobWork> dcoutts: ah, bugger -- so how do I go about upgrading?
01:31:07 <BeelsebobWork> roll back happy to an earlier version with darcs?
01:31:25 <dcoutts> BeelsebobWork: if it's using cpp on ghc >= 6.9 then try hacking the cpp to check for >= 6.10 and build Setup using base 3
01:31:40 <unenough> another newbie question, how do i check if an instance belongs to some type class?
01:31:56 <dmwit> unenough: instances always belong to some type class.
01:31:57 <BeelsebobWork> dcoutts: I don't follow
01:32:00 <Deewiant> :info Class?
01:32:07 <unenough> to a specific one, of course
01:32:11 <dmwit> unenough: What do you mean?
01:32:14 <Deewiant> in GHCi, :info Class
01:32:25 <unenough> ok
01:32:27 <dcoutts> BeelsebobWork: ie try to persuade it to build as if you were using 6.8 rather than 6.9, since your 6.9 is clearly too early
01:32:40 <BeelsebobWork> hmm, okay
01:33:16 <dcoutts> BeelsebobWork: or build an older happy, or change the Control.Exception import to .OldException
01:33:38 <BeelsebobWork> hmm, okay
01:34:10 <BeelsebobWork> so hang on, this should work if I use 6.8 to build it instead?
01:34:20 <BeelsebobWork> i.e. it'll then detect that my ghc is old, and do the right thing?
01:34:29 <dcoutts> BeelsebobWork: that's my guess
01:34:38 <BeelsebobWork> cool binary package of 6.8 time me thinks
01:34:40 <dcoutts> BeelsebobWork: and certainly if you use an older happy tarball
01:36:15 <BeelsebobWork> thanks a lot dcoutts :)
01:36:22 <dcoutts> np
01:36:24 <unenough> fromIntegral (3 :: Int)
01:36:30 <glguy> dcoutts, testyarritout
01:36:30 <kaizoku> YARRRR
01:36:39 <dcoutts> glith: heh, quite
01:36:39 <kaizoku> dcoutts: Oh, hehe. That's a script
01:36:43 <unenough> oops, wrong window.
01:36:44 <dcoutts> oops, glguy
01:36:56 <glguy> kaizoku, can you turn that off please?
01:37:21 <mmorrow> @yow
01:37:22 <lambdabot> Is this an out-take from the "BRADY BUNCH"?
01:37:23 <kaizoku> glguy: Uhh, it's only triggered by a pretty specific sequence of characters that doesn't often get used
01:37:28 <mmorrow> @nixon
01:37:28 <lambdabot> Voters quickly forget what a man says.
01:37:31 <mmorrow> @nixon
01:37:31 <lambdabot> Scrubbing floors and emptying bedpans has as much dignity as the Presidency.
01:37:34 <dcoutts> kaizoku: I use it all the time ;-)
01:37:35 <Deewiant> @ghc
01:37:36 <lambdabot> ghc says: Use -fglasgow-exts to allow multi-parameter classes
01:37:37 <mmorrow> @nixon
01:37:38 <lambdabot> Government enterprise is the most inefficient and costly way of producing jobs.
01:37:45 <glguy> kaizoku, so you are saying no?
01:38:04 <mmorrow> yarr
01:38:05 <kaizoku> YARRRR
01:38:05 <kaizoku> I'm saying I don't think it's a problem.
01:38:09 <dcoutts> kaizoku: I'd recommend only turning it on for international talk like a pirate day
01:38:15 <quicksilver> @yar
01:38:16 <lambdabot> Har de har har!
01:38:16 <dmwit> yarr sayin' it be no problem!
01:38:16 <kaizoku> YARRRR
01:38:21 <kaizoku> If it's really bothersome I'll leave this channel when I'm not on IRC
01:38:26 <mmorrow> arrrrgyle socks
01:38:27 <dcoutts> otherwise we've got both you and lambdabot responding to the @yarr command
01:38:27 <kaizoku> YARRRR
01:38:39 <dcoutts> @yarr!
01:38:40 <kaizoku> YARRRR
01:38:40 <lambdabot> Swab the deck!
01:38:43 <dmwit> hahaha
01:38:46 <dcoutts> see, it's silly
01:38:46 <dmwit> Man, this is great.
01:38:47 <unenough> yarr really stubborn, yarrent' you?
01:38:47 <kaizoku> YARRRR
01:38:51 --- mode: ChanServ set +o glguy
01:38:51 --- mode: glguy set -o glguy
01:38:52 <kaizoku> Yup
01:38:57 <kaizoku> Alright
01:39:12 <Deewiant> @ghc -- much more on-topic
01:39:12 <lambdabot> No quotes match. I feel much better now.
01:39:20 <Deewiant> :-/
01:39:26 <unenough> not quite
01:39:40 <Deewiant> lambdabot should strip comments from all commands
01:40:59 <dcoutts> @tell kaizoku we didn't mean that you had to leave, just asking to turn off the YARRR
01:40:59 <lambdabot> Consider it noted.
01:41:00 <dmwit> Deewiant-- I don't agree!
01:41:08 <dmwit> ;-)
01:41:23 <Deewiant> especially in that case, I certainly do ;-)
01:41:28 <dmwit> heh
01:41:44 <Deewiant> @ghc
01:41:44 <lambdabot> ghc says: GHC stack-space overflow
01:41:46 <glguy> dcoutts, turning it off wasn't one of the choices he was considering
01:42:40 <Kvasir>  /\byarr\b/
01:43:08 <dmwit> yeah
01:43:15 --- mode: ChanServ set +o glguy
01:43:21 --- mode: glguy set -b *!*@gateway/tor/x-0339c5109bbc534a
01:43:42 <dmwit> Oof, there was a ban on a tor gate?
01:43:45 <dmwit> Did that even work?
01:43:59 <glguy> it works for a little while , until they reconnect
01:45:08 --- mode: glguy set -o glguy
01:47:45 --- mode: christel set +L
01:48:10 <Deewiant> +L?
01:48:25 <glguy> moar bans
01:48:29 <glguy> exceptions
01:48:33 <glguy> invex
01:55:15 <vesz> Do I have to import anything for ':' to work? for example foo (x:xs) = (x, xs) gives the error Undefined data constructor ":"
01:56:43 <sjanssen> vesz: (:) comes from the Prelude, it should be in scope unless you've hidden it
01:57:36 <vesz> import Prelude (Num(..), Bool(..), Eq(..), Show(..)) that might hide it I guess then. I was told to use that :)
01:57:41 <vesz> sjanssen: thanks
01:57:55 <sjanssen> vesz: yep, it will hide (:)
01:58:31 <sjanssen> that is also a silly import, all of those things are available by default and it will hide lots of useful things
01:59:06 <BeelsebobWork> sjanssen: I suspect it's done to strip the prelude down to things not provided elsewhere
01:59:10 <BeelsebobWork> e.g. by Data.List
01:59:17 <BeelsebobWork> but yeh, it's silly
02:00:43 <vesz> sjanssen, I'm doing some exercises and I guess they didn't want us using readily available things, then I forgot to remove it as I moved on
02:00:50 <sjanssen> vesz: ah
02:07:03 <yitz> These exercises that prohibit using things like map seem very silly to me.
02:07:39 <BeelsebobWork> yes and no
02:07:46 <BeelsebobWork> depends if you're trying to teach them recursion for example
02:07:49 <Deewiant> if you're writing map, it's helpful.
02:07:54 <yitz> he
02:08:25 <yitz> If you're teaching recursion, say "use recursion".
02:08:33 <BeelsebobWork> indeed
02:08:38 <BeelsebobWork> "use recursion -- not map"
02:08:40 <Deewiant> And wonder why they don't learn. ;-)
02:09:02 <BeelsebobWork> nothing wrong with starting people off with primitive recursion
02:09:07 <yitz> When they teach recursion in C or Pascal, they don't prohibit while.
02:09:13 <ivanm> yitz: where in the dictionary, the definition of recursion is "see recursion"? ;-)
02:09:21 <yitz> he
02:09:28 <BeelsebobWork> yitz: sure they do -- they say "use recursion for this" and mark you down if you use while to do it, not recursion
02:10:43 <yitz> well, you can also use while if you want, but the main iteration needs to be recursion.
02:10:59 <BeelsebobWork> I would certainly mark you down if you did that
02:11:19 <BeelsebobWork> if the assessment says "use recursion" it means it
02:11:31 <yitz> BeelsebobWork: I don't think starting off with primitive recursion is necessarily the right approach, but I guess it depends on the basic goal of the course.
02:11:43 <BeelsebobWork> yitz: yeh, I agree
02:11:50 <BeelsebobWork> but I can imagine many courses that do start off with it
02:12:01 <BeelsebobWork> the UKC on certainly starts with higher order functions
02:12:10 <BeelsebobWork> and then says "oh hay, you can write these if you like"
02:14:42 <yitz> I would start with simple things written the way we really write them, building a vocabulary of basic tools. Then motivate recursion with things that can't easily be written using existing tools without recursion.
02:15:12 <yitz> You might then mention that recursion is actually more primitive and that the basic tools are written that way.
02:16:14 <yitz> For advanced programmers who are learning Haskell, you might start with recursion, but also in that case you wouldn't need those silly exercises.
02:16:27 <BeelsebobWork> I think you would need them
02:16:37 <BeelsebobWork> most advanced programmers are used to going "pft, recursion, that's inefficient"
02:16:41 <yitz> They know what recursion is.
02:16:42 <BeelsebobWork> and have very little experience with it
02:16:55 <BeelsebobWork> yeh, but they have next-to-no experience with thinking in a recursive way
02:17:09 <Deewiant> The 'head recursion' style in particular is quite unique to haskell IMO
02:17:22 <Lemmih> Dependencies between finalizers  in GHC is a no-go, right?
02:17:23 <Deewiant> Or to lazy languages in general, I guess
02:18:18 <yitz> Deewiant: true. but it would be more natural to introduce it later on, for problems that really need it. not to start out by misleading them about what Haskell code is supposed to look like.
02:19:13 <BeelsebobWork> yitz: I think that the problem is that 1st year students have seen very little maths, and are not good at thinking compositionaly
02:19:13 <Deewiant> Well, 'problems that really need it' == almost anything that returns a list, for instance. :-)
02:19:28 <BeelsebobWork> so trying to imediately immerse them in compositional style is not entirely useful
02:19:40 <BeelsebobWork> they just end up going "what the shit, I can't write anything in this language"
02:19:45 <SubStack> delicious lists :)
02:19:49 <yitz> Deewiant: not really, I use lists all the time and usually don't need raw recursion.
02:20:09 <Deewiant> yitz: well yeah, but the HOFs you use need it.
02:20:26 <BeelsebobWork> Deewiant: yeh, but he was asserting that the course should teach the HOFs
02:20:35 <yitz> Deewiant: they also need branches in the assembler code they generate, so what?
02:20:35 <BeelsebobWork> and then later say "oh, btw, if the HOFs aren't enough, do this instead"
02:20:45 <Deewiant> yitz: so tell them about that, too.
02:21:04 <yitz> Deewiant: ok -- some day.
02:21:21 <BeelsebobWork> this is an age old computing problem though
02:21:25 <BONUS> hmm
02:21:27 <yitz> start with the basics though. In idiomatic Haskell, recursion isn't basic.
02:21:28 <BeelsebobWork> should you approach things bottom up
02:21:30 <BeelsebobWork> or top down
02:21:41 <BONUS> Kleisli arrows using the identity monads are just normal function arrows. am i correct in thinking this?
02:22:01 <BONUS> s/monads/monad
02:22:07 <Deewiant> yitz: Depends on what you're doing. If you're implementing a data structure, for instance, it is.
02:22:20 <Deewiant> IMHO at least.
02:22:48 <BeelsebobWork> Deewiant: yes and no -- the first thing you do is write fmap, and then use HOFs again
02:22:58 <BeelsebobWork> having said that -- you need to be able to write fmap
02:23:13 <Deewiant> BeelsebobWork: good luck implementing set union with fmap, for instance ;-)
02:23:22 <BeelsebobWork> true, so you implement fold too
02:23:27 <yitz> Deewiant: yeah sometimes it is natural there - so introduce it when you get to that, if you haven't needed it yet.
02:23:42 <Deewiant> the fold might not have the wanted performance characteristics
02:24:27 <sjanssen> will you really be able to use fold if you don't know recursion?
02:24:40 <BeelsebobWork> it might not Deewiant -- but that's not the *first* think I'm thinking about when learning Haskel
02:24:51 <BeelsebobWork> sjanssen: I think so, yes
02:24:57 <BeelsebobWork> fold is an easy function to think about
02:24:58 <Deewiant> BeelsebobWork: true, it's arguable that doing that in the first place isn't very idiomatic. :-)
02:25:19 <yitz> Recursion is fundamental in the theory of computing, so if that's what you're teaching, it's certainly right at the beginning. But before someone takes a course in that, they should know some programming languages already.
02:25:35 <yitz> Including functional languages.
02:25:57 <sjanssen> yitz: recusion is fundamental in the practice of programming, not just the theory
02:26:26 <BeelsebobWork> sjanssen: sure it is -- but we don't start people programming by introducing them to ASM
02:26:34 <BeelsebobWork> we start them by doing something higher level
02:26:39 <BeelsebobWork> and then filling in details later
02:26:41 <yitz> sjanssen: I claim that in Haskell, raw recursion is not the most basic technique.
02:26:53 <BeelsebobWork> hmm
02:26:54 <sjanssen> yitz: it is the most fundamental
02:26:56 <Deewiant> I claim that it is the most basic.
02:26:56 <yitz> sjanssen: not to say that it isn't important
02:27:04 <BeelsebobWork> I would claim that it is the most basic too
02:27:04 <sjanssen> "basic" is an overloaded term, I'm not sure what you mean by it
02:27:50 <yitz> sjanssen: ok. I'm thinking about a course that is teaching Haskell to first year CS students - as a language.
02:28:05 <sjanssen> yitz: "basic" means "easy"?
02:28:46 <yitz> sjanssen: in idiomatic Haskell, you usually use other techniques to iterate, not raw recursion. it's only in certain situations, or when the problem is difficult in some way, or if you need to optimize, that you use recursion.
02:28:55 <quicksilver> yitz: no you always use recursion
02:28:58 <quicksilver> yitz: every single time.
02:29:05 <quicksilver> haskell has no other looping construct.
02:29:10 <yitz> sjanssen: basic means simplest idiomatic usage.
02:29:39 <yitz> quicksilver: map, zip, iterate, folds.
02:29:42 <sjanssen> yitz: you basically need to use recursion every time your structure isn't a list
02:30:15 <BONUS> everything comes down to recursion, but that doesn't mean that you have to do explicit recursion
02:30:47 <BONUS> even if you have trees, you can make them a functor and do fmap, which is implicit recursion
02:30:49 <BONUS> imho
02:31:34 <sjanssen> yitz: I also think "idiomatic" is not the most useful thing in CS 101, the goal is not to produce working Haskell programmers, the goal is to teach concepts
02:31:58 <KoenigGunther> hi
02:32:04 <sjanssen> BONUS: but you can't write fmap for your tree without using recusion
02:32:15 <BeelsebobWork> sjanssen: yeh, that depends -- I personally wouldn't teach Haskel as a CS101
02:32:20 <BeelsebobWork> I'd do the SICP thing
02:32:28 <BeelsebobWork> and then teach Haskell in a later functional programming course
02:32:39 <BONUS> sjanssen: yeah, exactly
02:32:47 <BONUS> you can't write map without recursion either
02:32:47 <BeelsebobWork> which would be all about doing the powerful things like HOFs and producing monads etc
02:32:48 <magthe> is there already a function in the base modules like this:  foo a = a >> return ()
02:32:59 <yitz> sjanssen: the basic structures are pre-defined. You start out with those. The simplest user-defined data structures don't need recursion. You start out with those. Eventually, you'll get to recursion, yeah. It won't take that long. But by that time you certainly won't need to give exercises that say "write this function using the following crippled mutilated variation on Haskell..."
02:33:02 <Deewiant> magthe: nope
02:33:06 <sjanssen> you know, I'd probably cover recursion before lists
02:33:10 <quicksilver> yitz: all of those things are defined using recursion.
02:33:21 <magthe> Deewiant: oki, then I'll stop looking, thanks
02:33:35 <yitz> quicksilver: for a beginner, that's totally under the hood.
02:33:37 <sjanssen> magthe: yes, (>>return()) :)
02:33:42 <quicksilver> it shouldn't be.
02:33:47 <quicksilver> that's what "basic" means
02:33:50 <quicksilver> everything depends on recursion.
02:33:52 <BeelsebobWork> sjanssen: interesting -- I think I'd do lists first -- because the whole stepping down a list thing and getting to the [] slightly easier to grasp than just decrementing a number
02:34:00 <magthe> sjanssen: ;) I was aware of that one yes
02:34:09 <BeelsebobWork> quicksilver: even
02:34:42 <yitz> quicksilver: everything depends on storing bits in memory locations and branching with gotos, so let's start out beginners with that.
02:35:06 <sjanssen> yitz: that is a different kind of basic
02:35:09 <KoenigGunther> i've got a question regarding my homework in haskell... whe have to define a function composeMaybe with the following signature: composeMaybe :: (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c).
02:35:09 <KoenigGunther> when i have
02:35:09 <KoenigGunther> composeMaybe f g x,
02:35:09 <KoenigGunther> I tried to apply f to x to get a result of type Maybe b. To feed g with this result i have to write a function with mapps 'Maybe b' to 'b', right?
02:37:15 <sjanssen> KoenigGunther: you also need to think about what you should do if (f x) returns Nothing
02:37:27 <KoenigGunther> Right, thats my problem :D
02:37:36 <yitz> @type maybe
02:37:37 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:37:49 <yitz> KoenigGunther: does that help?
02:38:01 <PeakerWork> KoenigGunther: you can use pattern matching on (Just x) or Nothing. Or you can use "maybe" which is an alternative to pattern matching
02:38:16 <quicksilver> yitz: because recursion is the ONLY looping technique in haskell
02:38:20 <quicksilver> if you don't teach it to beginners
02:38:34 <quicksilver> they are immediately lost when they try to do something which doesn't obviously fit into a map or a fold.
02:38:42 <KoenigGunther> I tried to do it with 'maybe', but 'maybe' requires a fallback value, which I cannot specify
02:38:49 <quicksilver> actually recursion is an easier programming technique, because it is universal
02:39:01 <quicksilver> learning to express you algorithms using common, named, recursion patterns
02:39:07 <quicksilver> like zipWith and fold
02:39:10 <quicksilver> is a higher-order skill.
02:39:13 <sjanssen> KoenigGunther: think about the type you're ultimately returning
02:39:20 <quicksilver> the first skill is to understand how looping is possible at all.
02:39:27 <yitz> quicksilver: that's just my point. It isn't the only looping technique, and it's not the most commonly used. I don't care that the compiler happens to replace my looping constructs with recursion during the compilation process, that's not a topic for beginners.
02:39:52 <yitz> quicksilver: ok. start with iterate then.
02:39:59 <KoenigGunther> Ummmm, pretty hard for me at the moment :) I think I'll have to revise the definition of Maybe
02:40:08 <Deewiant> ?src Maybe
02:40:08 <lambdabot> data Maybe a = Nothing | Just a
02:40:21 <sjanssen> KoenigGunther: no, the existing definition will work :)
02:40:21 <quicksilver> It is the only looping technique.
02:40:27 <quicksilver> and since it is the only one, it is the most commonly used
02:40:31 <quicksilver> it is the *only* one used.
02:40:38 <yitz> quicksilver: you never use iterate?
02:40:45 <quicksilver> haskell is not a language for people who are afraid to look at the source of iterate and map
02:40:54 <quicksilver> the soruce of iterate and map are beautifully simple
02:40:57 <quicksilver> even beginners
02:41:01 <quicksilver> no *especially* beginners
02:41:04 <quicksilver> should look at that.
02:41:09 <sjanssen> KoenigGunther: a Maybe is either Just a value, or Nothing (no result).  In which cases would you want to use either of those options?
02:41:17 <yitz> quicksilver: true, but that's not the right way to start out beginners. it gives a distorted picture of how you program in Haskell.
02:41:21 <quicksilver> thinks like map and fold should not be thought of as magic black boxes, never to be looked inside
02:41:39 <quicksilver> they should be viewed as common idioms which are all the more beautiful because you could easily have written them yourselves.
02:41:44 <yitz> And these weird distorted exercises that people are always bringing here proves it.
02:42:32 <yitz> quicksilver: when you start learning something totally new, everything looks like a magic black box. it doesn't take long before most of them open up though.
02:42:58 <yitz> quicksilver: i'm not saying not to teach recursion. i'm just giving the following criterion:
02:42:59 <KoenigGunther> I am interested in the Just-value, since I can extract he value of type 'b'.
02:43:26 <KoenigGunther> The Nothing-value is confusing me right now, because I cannot immagine how to convert it into a 'b'-value
02:43:35 <sjanssen> KoenigGunther: so when the value is Just, what will you return?
02:43:37 <yitz> recursion should not be taught until you can give realistic exercises that don't force you to write stupid-looking unidiomatic Haskell.
02:43:44 <Deewiant> Nothing is a 'Maybe a' value, a 'Maybe b' value, and a 'Maybe c' value
02:44:24 <sjanssen> yitz: you keep talking about idiomatic Haskell, but that is not what the first stages of learning a language are about
02:44:24 <KoenigGunther> If the value would be (Just x) x would be my returned value
02:44:26 <opqdonut> yitz: you have a point there
02:44:37 <opqdonut> writing folds explicitly is good style, expanding them out is not
02:44:48 <Deewiant> KoenigGunther: no it wouldn't, you're returning a 'Maybe c' not a 'c', remember?
02:45:12 <sjanssen> KoenigGunther: but x has the type 'c', not 'Maybe c'
02:45:22 <yitz> sjanssen: i don't think you're right. every other language i learned started out with things that were simple but idiomatic in that particular language. why does only Haskell have to start out by distorting things?
02:46:38 <KoenigGunther> We're talking about the function help :: (a -> Maybe b) -> b, right?
02:46:38 <KoenigGunther> So my approach would be to define a pattern        help (Just x) = x     for the Just-case
02:47:00 <sjanssen> KoenigGunther: we're talking about the composeMaybe function as a whole
02:47:06 <KoenigGunther> ah, okay :)
02:47:26 <sjanssen> KoenigGunther: help :: (a -> Maybe b) -> b is a dead end
02:47:30 <jimstutt> dons: hi, failing to build ghc-6.10.1 on archlinux x8. Has anyone succeeded yet?
02:47:40 <KoenigGunther> cool, this saves a lot time :D
02:47:54 <jimstutt> dons: s/x/x86/
02:48:57 <KoenigGunther> ummm, I think I try to think about it for a while again... I have no clue what to do at the moment :) But thank you anyways for the moment!
02:49:12 <KoenigGunther> If I dont come to a solution: I'll be back :D
02:49:34 <RayNbow> yitz: but what would be a realistic recursion exercise?
02:50:55 <quicksilver> yitz: I think it's fine to start by playing with some idiomatic things like "map (+1) [2,3,4,5]"
02:51:03 <quicksilver> yitz: but it's hard to learn from those because they don't mean anything
02:51:09 <quicksilver> they're just fun patterns
02:51:37 <quicksilver> once you actually want to move on from playing "look this language is cool, it's really expressive" to "how would I actually solve my own problems in it?"
02:51:43 <quicksilver> then you have to address recursion.
02:51:49 <BeelsebobWork> quicksilver: you do?
02:51:52 <RayNbow> (gtg, be back in 1 hr)
02:51:55 <yitz> quicksilver: why, you can certainly solve problems with map.
02:52:00 <BeelsebobWork> I've written plenty of real world programs that don't use recursion
02:52:08 <mapreduce> BeelsebobWork: No you haven't.
02:52:14 <mapreduce> Iteration == Recursion.
02:52:15 <yitz> here we go again
02:52:21 <quicksilver> BeelsebobWork: I can't be bothered to rehash the last 20 minutes of the argument, sorry.
02:52:27 <quicksilver> you can read up / read the logs if you're interested.
02:52:28 <BeelsebobWork> okay, i've written plenty of real world programs that don't use plain primitive recursion
02:52:41 <mapreduce> Ah, this is #haskell, I thought I was in ##csharp for a moment.
02:52:43 * mapreduce backs off.
02:52:45 <quicksilver> yitz: solving problems with map as your only tool is hugely frustating
02:52:53 <BeelsebobWork> main = interact $ unlines . foldr processCommand initState . lines
02:52:54 <quicksilver> (as a student)
02:52:58 <BeelsebobWork> done
02:52:59 <quicksilver> BeelsebobWork: FAIL
02:53:03 <sjanssen> yitz: map solves exactly one problem, on exactly one structure
02:53:08 <quicksilver> BeelsebobWork: unlines, foldr, and lines are all recursive
02:53:19 <BeelsebobWork> quicksilver: yes -- but they're not explicit, primitive recursion
02:53:23 <quicksilver> indeed.
02:53:24 <BeelsebobWork> which is what yitz is arguing about
02:53:28 <quicksilver> no it's not.
02:53:32 <quicksilver> please read back, please understand
02:53:36 <quicksilver> I'm not going to explain it again.
02:53:37 <BeelsebobWork> he's saying "don't teach them explicit primitive recursion, teach them HOFs instead"
02:53:40 <yitz> sjanssen: you mean it's not enough to make the language Turing complete. Yeah. :)
02:53:43 <quicksilver> yes
02:53:53 <quicksilver> and Im' saying that teaching HOFs as black boxes is dire
02:54:02 <quicksilver> it's really poor teaching techniques
02:54:04 <BeelsebobWork> I don't think it is
02:54:06 <quicksilver> because you can't generalise from it
02:54:10 <quicksilver> HOFs are not black boxes
02:54:17 <quicksilver> in fact they almost all have one or two-line definitions
02:54:18 <BeelsebobWork> they are so -- if you treat them as such
02:54:25 <quicksilver> you should teach them *with* their definitions
02:54:31 <BeelsebobWork> in the same way as a while loop is not a black box -- it's a load of OSM
02:54:33 <BeelsebobWork> ASM8
02:54:36 <BeelsebobWork> ASM**
02:54:37 <quicksilver> and then people can generalise them.
02:54:44 <yitz> quicksilver: you can defer that by a week or two.
02:54:49 <quicksilver> ah yes but the different is while loops are complete
02:54:52 <BeelsebobWork> sure -- but I think what he's arguing is that you go back and teach that 3 weeks later
02:54:53 <quicksilver> you can do anything with while loops
02:54:56 <BeelsebobWork> once they're already programming
02:55:03 <quicksilver> map lines and unlines are not compelte
02:55:09 <quicksilver> and you can't generalise form them to anything which is.
02:55:13 <BeelsebobWork> no, they're not -- but they're enough to get started
02:55:15 <quicksilver> yitz: two weeks, sure ;)
02:55:16 <quicksilver> that's fine.
02:55:20 <quicksilver> but not long
02:55:26 <quicksilver> you can't *really* teach haskell without teaching recursion
02:55:36 <BeelsebobWork> yeh, I don't think anyone's arguing that you can just not ever teach primitive recursion
02:55:38 <quicksilver> once you move out of the playground, you have to see how the slide was put toegether.
02:55:44 <BeelsebobWork> only that you can get people started in a playground
02:55:51 <yitz> quicksilver: that's all I'm saying. that's enough to be able to avoid distorting people's view of Haskell.
02:56:19 <yitz> first impressions have a lasting effect.
02:56:34 <sjanssen> CS 101 is supposed to do PR work for Haskell?
02:56:46 <BeelsebobWork> yeh, that's the bit I don't disagree with sjanssen
02:56:57 <BeelsebobWork> I don't think HOFs are useful in CS101
02:57:02 <BeelsebobWork> maybe in CS301 though
02:57:08 <yitz> can you image what happens to all the students who *don't* come to this channel to get straightened out when they are doing those crazy exercises?
02:57:22 <BeelsebobWork> "by the way, functional languages are really powerful because you can throw functions around everywhere" kind of stuff
02:57:37 <sjanssen> every CS course is full of moments where the professor goes "oh, but this is generalized in X Y and Z, and melts down to one line of code"
02:57:46 <BeelsebobWork> yitz: but the point of the crazy exercises is not to teach them Haskell
02:57:46 <yitz> sjanssen: I meant that they start out by getting into bad habits about how to think about a problem.
02:57:50 <BeelsebobWork> it's to teach them about recursion
02:58:02 <BeelsebobWork> the fact that they're using haskell is irrelevant
02:58:08 <BeelsebobWork> as is what idiomatic haskell looks like
02:59:00 <yitz> BeelsebobWork: so that's also part of the confusion. in cs 101 don't start out with computing theory during the first lecture. start out with a concrete language.
02:59:13 <BeelsebobWork> yitz: really?
02:59:39 <sjanssen> actually, you usually start with the syllabus :P
02:59:40 <BeelsebobWork> my first POP (principals of programming, essentially CS101) involved "hey, so what do we need to build a language that lets us do stuff"
02:59:44 <BeelsebobWork> (see SICP)
03:00:03 <yitz> of course, just like in math you don't start group theory until you are well familiar with basic arithmetic in the Integers.
03:00:26 <IsoPallo_> Hmm... I did :)
03:00:51 <BeelsebobWork> the point though is that what they were teaching is the basics of "programming languages need ways to express an atomic thing, and atomic computation, and ways of producing lots of things, and lots of computations"
03:00:57 <BeelsebobWork> they weren't teaching us scheme
03:01:07 <BeelsebobWork> they were teaching us what a programming language was
03:01:12 <IsoPallo_> It is suprising how you don't need to know the basics if you have good abstractions :)
03:03:34 <yitz> IsoPallo_: in the 1960's there was this thing called "New Math". (Ever hear the Tom Lehrer song about it?)
03:03:55 <yitz> If they did it nowadays, they might start out first graders with category theory.
03:04:02 <yitz> it's quite general.
03:05:41 <yitz> @go new math tom lehrer
03:05:43 <lambdabot> http://www.youtube.com/watch?v=a81YvrV7Vv8
03:05:43 <lambdabot> Title: YouTube - New Math (Tom Lehrer) Animation
03:07:38 <vincenz> Is this droscript real or a farce?
03:07:43 <vincenz> dons: ping
03:07:58 <vincenz> @seen dons
03:07:58 <lambdabot> dons is in #darcs, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 5h 27m 33s ago.
03:09:22 <vincenz> @tell dons I agree that 'get' is very cheap, computationally, but you did not address my main concern.  The reason why I want a branch to be even cheaper is if you want a LOT of branches, but not perse on different servers, with 'get' you'll have a lot of disk-space overhead.  The reason to have that many branches, is that then you could have a code-review system.  People mail their patch to the main repository, this creates a branch with a uni
03:09:22 <lambdabot> Consider it noted.
03:10:10 <unenough> looking through lambdabot's code, i see something like: String -> LB [String]
03:10:12 <unenough> what's LB?
03:10:19 <vincenz> unenough: lambdabot's monad
03:10:25 <unenough> ah
03:10:36 <vincenz> I think it's an IO monad, potentially with some state to track the connection
03:11:17 <sjanssen> vincenz: get does not have disk space overhead if the repositories are on the same partition
03:11:25 <vincenz> sjanssen: it hardlikns?
03:11:30 <sjanssen> vincenz: yep
03:11:33 <vincenz> Neat :)
03:11:50 <sjanssen> vincenz: also, truncated after "creates a branch with uni"
03:11:56 <sjanssen> with a uni
03:12:03 <vincenz> People mail their patch to the main repository, this creates a branch with a unique number, and then you can review that code with regards  to the active version of the repository
03:12:39 <sjanssen> is there a version control system that actually works that way?
03:12:44 <vincenz> Yes
03:13:01 <vincenz> basically you want to separate the concept of patch and patch
03:13:09 <vincenz> You want something you submit, let's call it 'Patch' (capitalized)
03:13:21 <vincenz> And as code is reviewd, you submit 'patch'es to this 'Patch' until the reviewer's happy
03:13:33 <jimstutt> @tell dons hi, any chance of an status update on ghc-6.10.1 archlinux x86?
03:13:34 <lambdabot> Consider it noted.
03:13:37 <vincenz> With darcs this would work better than normal system,s since normal systems do not allow multiple 'Patch'es for one file
03:13:48 <vincenz> Notice the case.
03:13:55 <vincenz> sjanssen: perforce does that
03:14:00 <vincenz> it's called a 'changelist'
03:14:42 <sjanssen> so, we both know that darcs can send several patches in a single bundle, what will this functionality gain?
03:15:27 <vincenz> sjanssen: imagine that I send you a patch ,you're the main maintainer
03:15:32 <vincenz> made of several darcs-patches
03:15:38 <vincenz> And you say 'good, but I'd like you to change x, ,y,z"
03:15:57 <vincenz> so I can keep sending you darcs-patches and they fall into the same bundle, until you're happy, and then you submit that bundle to the main repo
03:16:17 <vincenz> sjanssen: http://www.niallkennedy.com/blog/2006/11/google-mondrian.html
03:16:22 <lambdabot> Title: Google Mondrian: web-based code review and storage
03:17:03 <vincenz> with something like darcs that would work better, since this system blocks you from working on the same file agian, while this file is part of one changelist
03:17:41 * vincenz is tempted to write a efw tools around darcs to try to get something like this working.
03:17:53 <sjanssen> what is wrong with working on the same file again?
03:18:09 <vincenz> sjanssen: if you read that webpage, basically, the review system looks at the nfs-directory of the developer
03:18:21 <vincenz> instead of submitting patches to some repo, and then having it pushed to the main repo past review
03:18:33 <vincenz> since perfoce is not a distributed scs
03:21:48 <vincenz> sjanssen: makes sense?
03:21:58 <jsn> i am having a great deal of trouble with parsec
03:22:17 <jsn> i can get a program to compile in GHCi but not with cabal
03:22:29 <sjanssen> vincenz: I'm not sure you'd want to use branches to do this
03:22:41 <vincenz> sjanssen: why not?
03:22:44 <sjanssen> vincenz: the patches have to be applied to the head eventually, right?
03:22:48 <vincenz> sjanssen: make mini branches for each mega patch
03:22:50 <vincenz> \then apply to head
03:23:00 <sjanssen> vincenz: you need to review conflict resolutions too
03:23:01 <vincenz> sjanssen: correct.
03:23:06 <vincenz> sjanssen: that needs to be done anyways.
03:23:09 <jsn> it gets stuck on    runParser _ _ () _    it tells me the    ()    should be    GHC.Prim.Any
03:23:20 <jsn> has anyone seen that before?
03:24:29 <vincenz> sjanssen: hum, but you are right, branches might not work, since you'd have to keep pulling in HEAd.
03:26:03 <sjanssen> jsn: can you hpaste the code?
03:26:39 <sjanssen> jsn: also "runParser _ _ () _" seems like a very strange bit of code...
03:26:57 <jsn> sjanssen: i omitted the obvious stuff
03:27:32 <BeelsebobWork> do I need to do anything special to get hackage to see my source is haddock documented?
03:27:45 <sjanssen> BeelsebobWork: no
03:28:07 <ivanm> hackage does the magic for you
03:28:12 <sjanssen> BeelsebobWork: you do have to wait a while for docs to be generated (it is scheduled by cron, I think)
03:28:14 <ivanm> assuming haddock doesn't fail on your source
03:28:39 <BeelsebobWork> sjanssen: ah, okay -- so when I check the package it won't show me any links
03:28:46 <sjanssen> BeelsebobWork: also, the package has to pass "Setup configure" on hackage.haskell.org
03:30:13 <BeelsebobWork> sjanssen: okay, so if the check worked, and it builds with 6.8.3, I should upload, and it'll generate docs in a while
03:30:14 <BeelsebobWork> ?
03:30:57 <sjanssen> BeelsebobWork: yep
03:38:16 <jsn> sjanssen: well, it turns out i needed to annotate something
03:50:16 <mmorrow> one of my favorite functions that can't (?) be written with the canned higher order functions is a product that can handle infinite lists containing at least one 0
03:51:38 <opqdonut> > 0*undefined
03:51:39 <lambdabot>   * Exception: Prelude.undefined
03:52:00 <opqdonut> you just have to define a custom (*) with different strictness and then zip with it
03:52:10 <mmorrow> , fix (\k !a bs -> case bs of [] -> a ; b:bs -> if b==0 then 0 else k (a*b) bs) 1 ([1..10]++[0]++[1..])
03:52:22 <lunabot>  0
03:53:30 <opqdonut> > let f 0 x = 0; f x y = x*y in foldr1 f ([1..10]+[0..])
03:53:32 <lambdabot>       No instance for (Num [a])
03:53:32 <lambdabot>        arising from a use of `+' at <interact...
03:53:37 <opqdonut> gah
03:53:39 <opqdonut> > let f 0 x = 0; f x y = x*y in foldr1 f ([1..10]++[0..])
03:53:41 <lambdabot>   0
03:53:49 <opqdonut> why can't + be mappend ;)
03:54:02 <Deewiant> > mappend 1 2
03:54:03 <lambdabot>   Add a type signature
03:54:05 <Deewiant> that's why :-P
03:54:06 <mmorrow> that will stack overflow
03:54:12 <mmorrow> you need to use foldl'
03:54:12 <opqdonut> mmorrow: no it won't
03:54:18 <Cale> > foldr (\x y -> if x == 0 then 0 else x*y) 1 $ [1..10] ++ [0..]
03:54:19 <lambdabot>   0
03:54:24 <mmorrow> damnit
03:54:29 <mmorrow> ok, bad example then ;)
03:54:32 <opqdonut> ;)
03:54:39 <Cale> foldl is bad for laziness
03:54:42 <Deewiant> foldls won't work
03:54:42 <opqdonut> if it looks like a fold, it can be written as a fold
03:54:42 * mmorrow thinks of a bettar one
03:54:56 <opqdonut> well
03:55:01 <mmorrow> , foldr (+) 1 [1..100000000]
03:55:05 <lunabot>  Stack space overflow: current size 8388608 bytes.
03:55:05 <lunabot>  Use `+RTS -Ksize' to increase it.
03:55:16 <mmorrow> , foldl' (+) 1 [1..100000000]
03:55:21 <opqdonut> often one wants to look at more than one element of the list at a time
03:55:23 <lunabot>  Killed.
03:55:27 <mmorrow> , foldl' (+) 1 [1..100000]
03:55:29 <lunabot>  5000050001
03:55:42 <opqdonut> and fold f start (tails l) is a bit cumbersome
03:55:55 <Cale> foldl/foldl' always run all the way to the end of the list before giving a result though, so they will never ever work on infinite lists.
03:56:30 <mmorrow> but just as often i'd argue one wants to do an expensive computation where at various points therein a condition can occur where any more work is useless
03:56:49 <mmorrow> and to continue would be to do more expensive computation for nothing
03:57:12 <Cale> Right, if you need to shortcut, it must be foldr
03:57:19 <mmorrow> exactly
03:57:31 <mmorrow> so in the case of (*) that isn't a solution
03:57:36 <Cale> hm?
03:57:36 <Saizan> the problem with foldr using (\x y -> if x == 0 then 0 else x*y), is that if you've a large list without 0 it will stack overflow
03:57:37 <mmorrow> since it'll stack overflow
03:58:10 <Saizan> you can use the Cont or Either e monad if you want a left fold that can shortcut
03:58:24 <Cale> Well, okay. Yes, foldr and foldl both fail in that case then.
03:58:47 <mmorrow> Cale: but what about the cases where foldl'
03:59:00 <Cale> There's also a combinator in category-extras iirc, which handles that.
03:59:03 <mmorrow> won't foldr will overflow
03:59:06 <mmorrow> and foldl'
03:59:13 <mmorrow> gah i keep hitting enter by accident
03:59:22 <Cale> yes, like this:
03:59:26 <Cale> > foldr (\x y -> if x == 0 then 0 else x*y) 1 $ [1..10] ++ [1..]
03:59:28 <lambdabot>   * Exception: stack overflow
03:59:28 <Cale> er
03:59:31 <Cale> > foldr (\x y -> if x == 0 then 0 else x*y) 1 $ [1..10] ++ [1..1000000]
03:59:33 <lambdabot>   * Exception: stack overflow
03:59:39 <Cale> > foldl' (\x y -> if x == 0 then 0 else x*y) 1 $ [1..10] ++ [1..1000000]
03:59:50 <mr_H> hey
03:59:52 <mr_H> is there any jabber module for haskell ?
03:59:54 <lambdabot>   thread killed
03:59:57 <mmorrow> yes
04:00:15 <Cale> mr_H: hmm...
04:00:22 <IsoPallo_> mr_H: I think there is.
04:00:28 <IsoPallo_> Check HAckage
04:00:50 <mr_H> jabber is the new trend in web 2.0, everybody is doing bots with jabber, and fireeagle apps
04:00:54 <mmorrow> > foldl' (\x y -> if x == 0 then 0 else x*y) 1 $ [1..10] ++ [0] ++ [1..10000000000000000000]
04:01:09 <lambdabot>   thread killed
04:01:20 <mr_H> i can't find it, no jabber or xmpp :/
04:01:24 <Cale> mr_H: I've only met one other person who was actually interested in using Jabber to communicate :P
04:01:25 <mmorrow> this is the case i mean when i say "it isn't a solution"
04:01:57 <Saizan> foldl will always traverse all the list, yeah
04:02:07 <Cale> mr_H: But I'm pretty sure I have seen something along those lines around...
04:02:14 <mr_H> hmm yes
04:02:15 <IsoPallo_> mr_H: Hmm... Maybe there isn't :(
04:02:21 <IsoPallo_> Fancy doing one? :)
04:02:28 <mr_H> maybe there is some google chat module (which uses xmpp)
04:02:30 <Cale> http://www.dtek.chalmers.se/~henoch/text/hsxmpp.html
04:02:32 <mr_H> i would
04:02:37 <lambdabot> Title: XMPP
04:02:46 <Cale> http://www.mail-archive.com/haskell-cafe@haskell.org/msg22437.html
04:02:51 <lambdabot> Title: Re: [Haskell-cafe] ANN: XMPP 0.0.1, http://tinyurl.com/6g2v7c
04:03:00 <vegai> intriguing version number
04:03:06 <Cale> So there are at least 3 XMPP modules, and none of them on Hackage.
04:03:25 <mr_H> nice
04:03:28 <Saizan> how could gwern overlook them?
04:03:50 <mmorrow> heh
04:04:41 <KoenigGunther> Hi again! I still cant find a solution to my task to write a function 'composeMaybe :: (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)' to compose two functions :( My problem still is to figure out how I have to pass the result of the first to the second function. The result of the first is of type 'Maybe b' and the input-type for the second function is 'b'
04:05:05 <Cale> KoenigGunther: right, so you have to pattern match the result of the first
04:05:15 <Cale> KoenigGunther: If it's Nothing, then you're going to want to return Nothing
04:05:31 <Cale> KoenigGunther: If it's Just x, then you want to pass it along to the second function.
04:05:44 <Cale> You can use a case expression to do that.
04:06:25 <KoenigGunther> But Nothing is of type 'Maybe b' and the x in (Just x) is of type 'b'
04:06:40 <Cale> right.
04:06:43 <Cale> composeMaybe f g x =
04:06:46 <KoenigGunther> This would result in a unification error, wouldnt it?
04:06:47 <Cale>   case f x of
04:06:53 <Cale>     Nothing -> ...
04:07:00 <Cale>     Just x -> ... x ...
04:07:31 <Cale> You're going to do something with that x
04:07:47 <Cale> In particular, you're going to turn it into a value of type Maybe c
04:07:56 <KoenigGunther> yes, right
04:08:00 <Cale> whose type will unify nicely with Nothing
04:08:27 <KoenigGunther> okay, I'll try it out
04:09:17 <mmorrow> @src maybe
04:09:17 <lambdabot> maybe n _ Nothing  = n
04:09:17 <lambdabot> maybe _ f (Just x) = f x
04:10:00 <KoenigGunther> omg
04:10:01 <KoenigGunther> it works
04:10:07 <mmorrow> yay
04:10:33 <Cale> Out of interest, this operation is >=> for the Maybe monad.
04:10:36 <Deewiant> ?djinn (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c
04:10:36 <lambdabot> f a b c =
04:10:36 <lambdabot>     case a c of
04:10:36 <lambdabot>     Nothing -> Nothing
04:10:36 <lambdabot>     Just d -> b d
04:10:39 <Cale> :t (>=>)
04:10:40 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
04:10:42 <KoenigGunther> god, that's embarrassing :D
04:10:57 <Deewiant> and yes, combineMaybe = (>=>) as well
04:11:11 <RayNbow> @index (>=>)
04:11:11 <lambdabot> bzzt
04:11:16 <RayNbow> @hoogle (>=>)
04:11:16 <Deewiant> Control.Monad
04:11:16 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:11:17 <Cale> RayNbow: Control.Monad
04:11:31 <mmorrow> composeMaybe f g x = maybe Nothing (maybe Nothing g (f x))
04:11:33 <mr_H> i have never written any monad
04:11:46 <mr_H> but i have used loads of monads :P
04:11:59 <mr_H> i guess
04:12:03 <Cale> mr_H: That's a standard position to be in :)
04:12:05 <jsn> :t f a >>= g
04:12:06 <mmorrow> composeMaybe f g x = g =<< f x
04:12:07 <lambdabot> forall (m :: * -> *) a b. (Monad m, SimpleReflect.FromExpr (m b), Show a, SimpleReflect.FromExpr (m a)) => m b
04:12:16 <Cale> mr_H: It's much harder to invent new monads than it is to use them.
04:12:20 <mmorrow> @type (<=<)
04:12:21 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
04:12:31 <Deewiant> ?ty flip . ((>>=) .)
04:12:33 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => (a1 -> m a) -> (a -> m b) -> a1 -> m b
04:12:34 <mmorrow> composeMaybe f g = g <=< f
04:12:42 <mmorrow> composeMaybe = (>=>)
04:13:12 <mmorrow> wow, i've never used (>=>) before
04:13:20 <KoenigGunther> Thank you :)
04:13:26 <mmorrow> but it'll be extremely handy
04:14:26 <mmorrow> (>=>) is new in 6.8?
04:14:27 <mr_H> Cale: yes :) i imagine that
04:15:25 <RayNbow> hmm, if you compile with -threaded but don't use the +RTS -Nx flag... will the program then only use a single thread?
04:15:44 <quicksilver> only a single OS thread, yes.
04:16:51 <Saizan> unless it has to do something that would block all the threads, right?
04:17:13 <Cale> It would be interesting to have a classification theorem for Haskell-definable monads.
04:18:41 <Cale> But it seems like there are just enough of them that that could be rather hard :)
04:19:52 <jsn> Cale: a classification theorem tells you which monads are in, and which are out of the Haskell definable monads?
04:20:16 <Cale> jsn: Well, provide some characterisation which in some sense lists them all.
04:21:06 <Cale> For instance, I would be happy with "Every monad is isomorphic to one of these primitive monads, or one of these monad transformers applied to another monad."
04:21:18 <Cale> (haskell-definable monad of course)
04:21:33 <mmorrow> Cale: such a thing would be very interesting indeed
04:21:43 <Cale> It's not clear at all that the monad transformers we have are anything like exhaustive.
04:21:52 <Cale> We might be missing something big even :)
04:22:18 <quicksilver> Cale: they're certainly not, they miss out various trivial monads for a start.
04:22:38 <Cale> Well, also, there are restrictions of those monads.
04:22:54 * quicksilver nods
04:23:31 <mmorrow> hmm
04:23:42 <Cale> (in the sense of, say, refining the State Integer monad into a unique supply monad)
04:24:53 <Cale> But there might be whole classes of effects which are missing from our view, and I'm not certain how to discover if that's the case.
04:26:08 <jsn> a supply monad?
04:26:34 <Cale> jsn: Yeah, hide get and put, and only provide something like  supply = do x <- get; put (x+1); return x
04:27:50 <jsn> when you say, a unique supply monad, you mean, one that can supply anything?
04:28:07 <Cale> Well, in this specific example, I mean one which can supply integers.
04:29:28 <Cale> But supplying elements of a stream of something is fine too :)
04:30:46 <mmorrow> Cale: one thing i've thought about doing is having a function which takes some appropriate "specification" for a needed monad (e.g. i want get, tell, callCC, and local, but i also want get to do ..) and which then constructs the flattened and fully optimized data/newtype decls, instances of Functor and Monad, the requested helper functions, and a run<name-of-monad> function with template-haskell (it just happens that TH is (probably)
04:30:46 <mmorrow> the most convenient way to construct this, but it's not essential to the problem in any way)
04:30:48 <pozic> Is there a way to write this without explicit recursion? http://paste.debian.net/20574/
04:31:10 <mmorrow> Cale: so any example of a flattened composite monad would be RWS
04:31:18 <EvilTerran> oops
04:31:39 <Cale> mmorrow: This is a little different, but have you seen MonadPrompt?
04:32:11 <mmorrow> heh, i was just looking at that yesterday alongside you moonpatio paste about PromtState
04:32:23 <Cale> aha, yeah :)
04:32:25 <mmorrow> interesting indeed
04:32:43 <Cale> pozic: I'll have a look :)
04:33:00 <mmorrow> i think i'm starting to get a picture of use-cases for GADTs
04:33:34 <Cale> pozic: hmm... what's the overall idea here?
04:34:09 <mmorrow> ooh, this is very interesting (it related GADTs to typeclasses in a particular situation) http://moonpatio.com/repos/oleg/InFin.hs
04:34:27 <mmorrow> (that's also on oleg's site, but i don't know the link off hand)
04:34:30 <pozic> Cale: the overall idea is to grab a monotone decreasing list of numbers starting from the head of the list and returning the rest.
04:35:12 <Cale> hmm
04:35:16 <pozic> Cale: also, it should work for infinite lists.
04:35:42 <EvilTerran> pozic, so you're trying to remove, what, a prefix?
04:35:58 <pozic> EvilTerran: not really remove, but split of, yes.
04:36:05 <EvilTerran> separate out
04:36:12 <pozic> off*
04:36:15 <pozic> EvilTerran: yes
04:36:42 <Cale> > let f xs = map fst (span (\(x,y) -> y < x) (zip xs (tail xs))) in f [7,4,2,1,1] ++ [0..]
04:36:43 <lambdabot>   Couldn't match expected type `[(a, b)]'
04:36:47 <Cale> > let f xs = map fst (span (\(x,y) -> y < x) (zip xs (tail xs))) in f ([7,4,2,1,1] ++ [0..])
04:36:48 <lambdabot>   Couldn't match expected type `[(a, b)]'
04:36:51 <Cale> er.
04:37:05 <Cale> > let f xs = (map fst *** map fst) (span (\(x,y) -> y < x) (zip xs (tail xs))) in f ([7,4,2,1,1] ++ [0..])
04:37:06 <pozic> Cale: that was my first try :)
04:37:07 <lambdabot>   ([7,4,2],[1,1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23...
04:37:17 <Deewiant> join (***) (map fst)
04:37:41 <Cale> okay...
04:37:59 <pozic> Cale: also f [3,2,1] should return [3,2,1]
04:38:07 <Cale> > let f xs = (map fst *** map fst) (break (\(x,y) -> y > x) (zip xs (tail xs))) in f ([7,4,2,1,1] ++ [0..])
04:38:09 <lambdabot>   ([7,4,2,1,1],[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23...
04:38:28 <Cale> ah, right, okay, you need takeUntil/dropUntil which are gone :/
04:38:48 <Cale> Well, might be able to rig something up :)
04:39:05 <Cale> er...
04:39:11 <Cale> > let f xs = (map fst *** map fst) (break (\(x,y) -> y >= x) (zip xs (tail xs))) in f ([7,4,2,1,1] ++ [0..])
04:39:13 <lambdabot>   ([7,4,2],[1,1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23...
04:39:19 <Cale> yeah...
04:40:45 <pozic> Cale: is that it according to you?
04:40:48 <Cale> > let f xs = zipWith (>) xs (tail xs) in f ([7,4,2,1,1] ++ [0..])
04:40:51 <lambdabot>   [True,True,True,False,True,False,False,False,False,False,False,False,False,...
04:40:59 <Cale> Let's see...
04:41:05 <pozic> Cale: it's incorrect for [3,2,1].
04:41:14 <Cale> > let f xs = True : zipWith (>) xs (tail xs) in f ([7,4,2,1,1] ++ [0..])
04:41:15 <lambdabot>   [True,True,True,True,False,True,False,False,False,False,False,False,False,F...
04:41:19 <pozic> Cale: that's why I abandoned the zip trick.
04:41:24 <Cale> oh?
04:41:31 <Cale> > let f xs = True : zipWith (>) xs (tail xs) in f [3,2,1]
04:41:33 <lambdabot>   [True,True,True]
04:42:22 <pozic> > let f xs = True : zipWith (>) xs (tail xs) in f [3,2,5]
04:42:24 <lambdabot>   [True,True,False]
04:42:46 <Cale> > let f xs = True : zipWith (>) xs (tail xs); g xs = break snd (zip xs (f xs)) in g [3,2,1]
04:42:48 <lambdabot>   ([],[(3,True),(2,True),(1,True)])
04:42:54 <Cale> er
04:43:01 <Cale> > let f xs = True : zipWith (>) xs (tail xs); g xs = span snd (zip xs (f xs)) in g [3,2,1]
04:43:02 <lambdabot>   ([(3,True),(2,True),(1,True)],[])
04:43:08 <Cale> > let f xs = True : zipWith (>) xs (tail xs); g xs = span snd (zip xs (f xs)) in g [3,2,1,1,5]
04:43:09 <lambdabot>   ([(3,True),(2,True),(1,True)],[(1,False),(5,False)])
04:43:43 <Cale> > let f xs = True : zipWith (>) xs (tail xs); g xs = span snd (zip xs (f xs)) in g ([7,4,3,2,1] ++ [1..])
04:43:45 <lambdabot>   ([(7,True),(4,True),(3,True),(2,True),(1,True)],[(1,False),(2,False),(3,Fal...
04:44:08 <Cale> That appears to work, despite the awkwardness.
04:44:15 <Cale> Might be able to clean it up a bit :)
04:44:44 <ben_h> hi all
04:44:50 <Cale> hello :)
04:44:58 <ben_h> just having a read of Learn You a Haskell
04:45:06 <Cale> cool :)
04:45:10 <ben_h> (love the title)
04:45:23 <Cale> BONUS is the guy who wrote it, btw :)
04:45:34 <ben_h> yeah so i see
04:45:42 <ben_h> BONUS_: pro artwork on the website
04:45:54 <ben_h> as for the text - i'm reading that now :)
04:47:12 <pozic> > :t span snd
04:47:14 <lambdabot>   <no location info>: parse error on input `:'
04:47:19 <EvilTerran> :t span snd
04:47:20 <lambdabot> forall a. [(a, Bool)] -> ([(a, Bool)], [(a, Bool)])
04:47:55 <EvilTerran> span p xs = (takeWhile p xs, dropWhile p xs)
04:48:14 <EvilTerran> (useful identity, although an inefficient implementation
04:48:19 <Deewiant> ?src span
04:48:20 <lambdabot> Source not found. My brain just exploded
04:48:24 <Deewiant> meh
04:48:38 <EvilTerran> ?src break
04:48:39 <lambdabot> break p =  span (not . p)
04:48:43 <Deewiant> :-)
04:48:43 <EvilTerran> meh!
04:49:01 <Deewiant> I recalled that ?src span would be the takeWhile-dropWhile pair but evidently not, it was something else
04:50:48 <Saizan> ?src splitAt
04:50:49 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
04:51:42 <Deewiant> yeah, that was it
04:53:12 * EvilTerran notes that neither span nor splitAt lend themselves to particularly natural foldrs
04:53:13 <Cale> join (***) (map fst) . span snd . (zip <*> (True :) . (zipWith (>) <*> tail))
04:53:22 <Cale> Maybe a little hard to read like that :)
04:53:31 <Deewiant> hooray for ap
04:53:41 <EvilTerran> Cale, shouldn't that tail be (drop 1)?
04:53:57 <Cale> seems to work regardless :)
04:54:00 <Deewiant> > (join (***) (map fst) . span snd . (zip <*> (True :) . (zipWith (>) <*> tail))) []
04:54:02 <lambdabot>   ([],[])
04:54:08 <EvilTerran> huh
04:54:11 <Deewiant> zipWith is lazy
04:54:16 <EvilTerran> oh, yeah
04:54:17 <Deewiant> zipWith [] xs = []
04:54:20 <EvilTerran> zipWith [] _|_ = []
04:54:22 <Deewiant> minus the f
04:54:27 <EvilTerran> indeed
04:54:31 <EvilTerran> > zip [] undefined
04:54:32 <lambdabot>   []
04:54:35 <EvilTerran> > zip undefined []
04:54:36 <lambdabot>   * Exception: Prelude.undefined
04:54:40 <Deewiant> :-P
04:54:54 <EvilTerran> that seems kinda cheeky to rely on, but okay
04:55:22 <Cale> zip xs (tail xs)  is an idiom as far as I'm concerned :)
04:55:40 <Deewiant> yeah, and zip (tail xs) xs isn't, so. :-P
04:55:59 <Saizan> @quote aztec
04:55:59 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
04:56:13 <Deewiant> zip`flip ap`tail
04:56:16 <mmorrow> , let foldC _ !a [] = a ; foldC f !a (b:bs) = f a b bs (\a bs -> foldC f a bs) in foldC (\a b bs k -> if b==0 then 0 else k (a*b) bs) 1 $ [1..20]++[0]++[21..100000000000]
04:56:22 <Deewiant> doesn't have the same ring to it :-)
04:56:25 <lunabot>  0
04:57:02 <pozic> Cale: thanks
04:57:20 <Cale> pozic: Might want something closer to the original version really :)
04:57:32 <Cale> pozic: But it's shorter anyway ;P
04:57:43 <Cale> (I mean, my original version)
04:57:54 <pozic> @hoogle (Arrow a) => a b c -> a (b, b) (c, c
04:57:55 <lambdabot> Parse error:
04:57:55 <lambdabot>   --count=20 "(Arrow a) => a b c -> a (b, b) (c, c"
04:57:55 <lambdabot>                                                  ^
04:58:07 <pozic> @hoogle (Arrow a) => a b c -> a (b, b) (c, c)
04:58:07 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
04:58:07 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
04:58:07 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
04:58:22 <pozic> hoogle fail
04:58:33 <RayNbow> hmm, x `using` s  x <-- why the subset symbol? Because of _|_?
04:58:59 <Deewiant> ?ty join (***)
04:59:00 <Cale> g xs = let (ys,zs) = span snd (zip xs (True : (zipWith (>) xs (tail xs))))
04:59:00 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
04:59:01 <Cale>        in (map fst ys, map fst zs)
04:59:13 <Cale> That's a little more pointful, and maybe easier to read.
04:59:33 <Deewiant> pozic: hoogle doesn't combine functions and no such predefined function exists
04:59:51 <pozic> Deewiant: then it should just say "no results found".
05:00:03 <Deewiant> no, it tries a close match
05:00:14 <Cale> (also doesn't require any imports like that :P)
05:00:17 <Deewiant> and it gives you the most useful function :-)
05:00:37 <And1> Hey there... when I try to upload an image to the (xmonad-)wiki I always get the error message "The connection was reset"... why?
05:01:12 <araujo> hello
05:01:19 <EvilTerran> Deewiant, `flip ap`? do you mean =<< ? :P
05:01:28 <EvilTerran> > zip =<< [0..]
05:01:29 <lambdabot>   Couldn't match expected type `[b] -> [a]'
05:01:33 <Deewiant> EvilTerran: no, flip ap. :-P
05:01:33 <EvilTerran> er
05:01:59 <EvilTerran> er
05:02:17 <EvilTerran> i dunno, i thought that worked for (e ->) :(
05:03:27 <EvilTerran> (<*>) :: (e ->) (a -> b) -> (e ->) a -> (e ->) b
05:03:27 <EvilTerran> (=<<) :: (a -> (e ->) b) -> (e ->) a -> (e ->) b
05:03:28 <ejt> is there a channel that combines haskell and unicycles, or did I dream it ?
05:03:38 <EvilTerran> ?seen lambdabot
05:03:38 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #
05:03:38 <lambdabot> haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #
05:03:38 <lambdabot> darcs, #arch-haskell, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
05:03:40 <Deewiant> ?ty flip . ap
05:03:41 <lambdabot> forall b a b1. (b -> a -> b1) -> b -> (b -> a) -> b1
05:03:47 <EvilTerran> ejt, that'll be #unicycling
05:03:51 <Deewiant> ?ty flip . (>>=)
05:03:52 <lambdabot> forall b a b1. (b -> a) -> b -> (a -> b -> b1) -> b1
05:04:01 <ejt> thx
05:04:01 <Deewiant> similar, yeah
05:04:31 <EvilTerran> Deewiant, yeah, i was thinking f =<< x = flip f <*> x for the (e->) monad
05:04:51 <Deewiant> ?ty ap . flip
05:04:53 <lambdabot> forall a b c. (a -> b -> c) -> (b -> a) -> b -> c
05:05:11 <Deewiant> ?ty flip . flip . (=<<)
05:05:13 <lambdabot> forall b a b1. (a -> b -> b1) -> (b -> a) -> b -> b1
05:05:19 <Deewiant> appears to be
05:05:27 <Deewiant> cute find :-)
05:05:36 <EvilTerran> > (zip =<< tail) [1..]
05:05:37 <lambdabot>   [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9),(11,10),(12,11),(13...
05:05:50 <EvilTerran> > (zip <*> tail) [1..]
05:05:51 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
05:06:29 <mmorrow> :R
05:06:30 <EvilTerran> i think the closest to `flip ap` is <**>, actually
05:06:37 <EvilTerran> > (tail <**> zip) [1..]
05:06:38 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
05:06:39 <Deewiant> ?ty <**>
05:06:40 <lambdabot> parse error on input `<**>'
05:06:44 <Deewiant> ?ty (<**>)
05:06:45 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
05:06:48 <EvilTerran> ?src (<**>)
05:06:48 <lambdabot> (<**>) = liftA2 (flip ($))
05:06:53 <Deewiant> O_o
05:07:06 <idnar> heh
05:07:16 <EvilTerran> f <**> x = flip ($) <$> x <*> f
05:07:24 <EvilTerran> er, x <**> f = ...
05:07:52 <EvilTerran> runs the side-effects of x before those of f, which is why it's not exactly flip (<*>)
05:08:07 <EvilTerran> > [f,g] <*> [x,y] :: [Expr]
05:08:08 <lambdabot>   [f x,f y,g x,g y]
05:08:14 <EvilTerran> > [x,y] <**> [f,g] :: [Expr]
05:08:15 <lambdabot>   [f x,g x,f y,g y]
05:10:44 <EvilTerran> Deewiant, note (<*>) = liftA2 ($), if that makes the ?src of (<**>) any clearer
05:10:48 <EvilTerran> ?src ap
05:10:48 <lambdabot> ap = liftM2 id
05:11:10 <EvilTerran> (<*>) = ap = liftM2 id = liftA2 ($) = ...
05:12:57 <quicksilver> note the subtle difference between liftA2 (flip ($)) and flip (liftA2 ($))
05:13:08 <quicksilver> so <**> is not just flip (<*>)
05:13:11 <ben_h> holy crap
05:13:22 <ben_h> list comprehensions just raised my consciousness
05:13:27 <PeakerWork> @src (<**>)
05:13:27 <lambdabot> (<**>) = liftA2 (flip ($))
05:13:40 <EvilTerran> ben_h, just wait 'til you get to do-notation in general :D
05:13:47 <ben_h> nice
05:14:03 <EvilTerran> > do x <- [1,2,3]; y <- [4,5,6]; guard (even (x+y)); return (x,y)
05:14:04 <lambdabot>   [(1,5),(2,4),(2,6),(3,5)]
05:14:08 <ben_h> the thing i like most about this so far is how directly it maps to pure mathematics
05:14:13 <ben_h> having studied it a bit at uni
05:14:18 <EvilTerran> > [(x,y) | x <- [1,2,3], y <- [4,5,6], even (x+y)]
05:14:19 <lambdabot>   [(1,5),(2,4),(2,6),(3,5)]
05:14:39 <EvilTerran> ben_h, indeed, haskell is *very* maths-y compared to most programming languages
05:14:46 <ben_h> C functions shouldn't really be called functions imo, they should be called methods as is convention in ruby
05:14:52 <EvilTerran> i'd be tempted to say it's more like maths than it is like conventional programming
05:14:57 <ben_h> hmm
05:15:07 <ben_h> sounds reasonable from the bits i've seen so far
05:15:22 <EvilTerran> ben_h, ah, C functions are still functions, they just implicitly take the universe as a parameter and return a new one :P
05:15:27 <ben_h> lol
05:15:53 <EvilTerran> (this is actually remarkably similar to how GHC models IO and whatnot under-the-hood)
05:16:03 <Deewiant> ?src IO
05:16:04 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
05:16:12 <ben_h> i dunno, i like to think of a function as a mapping between this and that, or like a graph - not a list of 'do this, then do this, then do this'
05:16:48 <EvilTerran> ben_h, as i say, "do this" can be read as "look at the universe parameter, and make a new one based on that but with these changes"
05:16:56 <ben_h> haha
05:17:22 <ben_h> so there's not really much scope-related stuff in haskell?
05:17:34 <Deewiant> what do you mean?
05:17:40 <EvilTerran> i actually find this a useful idea to keep in mind when thinking about side-effects
05:17:58 <EvilTerran> when you get to looking at the State monad, you'll see that's pretty much exactly how it gives the impression of mutable state
05:18:01 <ben_h> is it true that the only data a function has access to is its params?
05:18:03 <ben_h> a pure function that is
05:18:25 <EvilTerran> well, its params, and anything in a lexically enclosing scope of its definition
05:18:35 <ben_h> i.e. other functions?
05:18:53 <Saizan> other functions or constants
05:18:54 <EvilTerran> > let x = 1; y = (x,x) in y -- x is in the lexically enclosing scope of the body of y
05:18:55 <lambdabot>   (1,1)
05:19:02 <Beelsebob> > let f x = let g = x in g in f 5
05:19:03 <lambdabot>   5
05:19:06 <EvilTerran> *a lexically enclosing scope
05:20:00 <ben_h> just parsing those, one sec
05:20:06 <mmorrow> @src foldr
05:20:07 <lambdabot> foldr f z []     = z
05:20:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:20:08 <ben_h> i'm a little slower than lambdabot ;)
05:20:12 <EvilTerran> ben_h, it sounds really complicated, but i find it basically boils down to "if (and only if) it looks in the source code like it should be in scope, it probably is"
05:20:19 <mmorrow> @src foldl
05:20:19 <lambdabot> foldl f z []     = z
05:20:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:20:20 <yitz> > let f x = foo where {foo = x *x} in f 12
05:20:21 <lambdabot>   144
05:20:29 <ben_h> EvilTerran: hmm
05:20:34 <mmorrow> lambdabot @src is sooo handy
05:20:48 <Saizan> > let abort x = Cont $ const x in flip runCont id $ foldM (\a b -> if b == 0 then abort 0 else return $! a * b) 1 $ [1..20] ++ [0] ++ [21..]
05:20:50 <lambdabot>   0
05:20:53 <EvilTerran> > let f x = (let g = x in g) in f 5 -- ben_h, this is Beelsebob's one made (hopefully) clearer
05:20:54 <lambdabot>   5
05:21:08 <ben_h> EvilTerran: awesome, i successfully implied those brackets
05:21:09 <ben_h> :)
05:21:15 <EvilTerran> hurrah!
05:21:20 <yitz> mmorrow: yeah, it's worth being verbally abused by a bot every once in a while
05:21:44 <EvilTerran> > let { f x = let { g = x } in g } in f 5  -- or, with explicit blocks, it looks like this
05:21:45 <lambdabot>   5
05:21:47 * ben_h wonders what triggers the abuse
05:21:59 <ben_h> hmm i like the brace notation EvilTerran
05:22:06 <yitz> @src something_unknown
05:22:06 <lambdabot> Source not found. I've seen penguins that can type better than that.
05:22:08 <ben_h> coming from a ruby state of mind
05:22:10 <Beelsebob> @vixen abuse me please
05:22:11 <lambdabot> don't beg
05:22:13 <EvilTerran> ?src yhjulwwiefzojcbxybbruweejw
05:22:13 <lambdabot> Source not found. Where did you learn to type?
05:22:15 <Beelsebob> :(
05:22:21 <Beelsebob> she wouldn't abuse me :(
05:22:21 <ben_h> lol
05:22:21 <Deewiant> @ghc
05:22:22 <lambdabot> ghc says: Empty record update
05:22:23 <EvilTerran> ?yhjulwwiefzojcbxybbruweejw
05:22:24 <lambdabot> Just 'J'
05:22:35 <Beelsebob> EvilTerran: o.O
05:22:52 <EvilTerran> Beelsebob, ah, don't you know that story?
05:22:57 <Deewiant> ?yhjulwwiefzojcbxybbruweejw
05:22:58 <lambdabot> "\"#$%&'()*+,\""
05:23:05 <Deewiant> ?help yhjulwwiefzojcbxybbruweejw
05:23:06 <lambdabot> V RETURNS!
05:23:10 <EvilTerran> ?v
05:23:11 <lambdabot> Just 'J'
05:23:12 <Beelsebob> EvilTerran: ? no
05:23:12 <EvilTerran> ?help v
05:23:12 <lambdabot> let v = show v in v
05:23:21 * ben_h is knee deep in in-jokes
05:23:37 <Deewiant> that's a bit... loose on the spelling correction there, if that's what it is
05:23:57 <EvilTerran> Beelsebob / Deewiant, well, for a while, \bot would splice "> ..."s into "let v = (...) in v" for some reason
05:24:07 <EvilTerran> someone noticed this somehow, and started writing expressions in terms of this v
05:24:16 <Deewiant> heh
05:24:17 <Beelsebob> haha
05:24:27 <EvilTerran> sorry, "let v = show (...) in v"
05:24:39 <ben_h> EvilTerran: are there any advantages to explicit blocks apart from the syntactic sygar?
05:24:41 <ben_h> sugar*
05:24:54 <ben_h> i.e. are there situations where the syntax would otherwise be ambiguous?
05:24:59 <quicksilver> no.
05:25:06 <Beelsebob> ben_h: the syntactic sugar is a disadvantage, not advantage ;
05:25:06 <quicksilver> but they do allow you to put code on one line
05:25:07 <Beelsebob> ;
05:25:09 <Beelsebob> ;)
05:25:12 <quicksilver> which is handy for lambdabot
05:25:13 <EvilTerran> ben_h, no, not really, unless you're cramming everything on one line
05:25:23 <ben_h> ahh yep
05:25:28 <ben_h> multiline it's clear enough anyway
05:25:42 <EvilTerran> Deewiant / Beelsebob: anyway, this was temporarily fixed for a while, until someone noticed the variable had just been renamed to yhjulwwiefzojcbxybbruweejw
05:25:49 <Deewiant> LOL
05:25:51 <Deewiant> what a fix
05:26:02 <EvilTerran> now it uses a random three-letter name, iirc
05:26:10 <Deewiant> aha
05:26:26 <Deewiant> so if I keep writing everything as 'let aaa = ... in aaa' I'll get an error one day?
05:26:49 <EvilTerran> but ?v and ?yhjulwwiefzojcbxybbruweejw produce outputs that were caused by this quirk
05:26:57 <ben_h> lol that's awesome
05:27:11 <EvilTerran> consider that "> v", for instance, would've had the same effect that
05:27:21 <Deewiant> > fix show
05:27:21 <EvilTerran> > let v = show v in v -- does now
05:27:23 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
05:27:23 <Saizan> now it's up to whatever the ghc-api/hint do
05:27:23 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
05:27:53 <ben_h> @src show
05:27:54 <lambdabot> show x = shows x ""
05:28:01 <ben_h> @src shows
05:28:01 <lambdabot> Source not found.
05:28:41 <EvilTerran> > let v = show (Just (head v)) in v -- "> Just (head v)"
05:28:42 <lambdabot>   "Just 'J'"
05:29:00 <EvilTerran> ?yhjulwwiefzojcbxybbruweejw
05:29:00 <lambdabot> "\""
05:30:03 <byorgey> @seen roconnor
05:30:03 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 6h 20m 39s ago.
05:31:59 <mmorrow> i think foldC should be Prelude http://hpaste.org/11700 :)
05:33:08 <ben_h> hpaste looks nice
05:33:24 <quicksilver> mmorrow: it's just runCont . foldM . Cont isn't it? FSOV "."
05:36:27 <yitz> ben_h: it is. hpaste used to announce here, but now that stopped working :(
05:36:31 <mmorrow> quicksilver: interesting
05:36:39 <mmorrow> @type runCont . foldM . Cont
05:36:40 <lambdabot>     Couldn't match expected type `a -> b -> m a'
05:36:40 <lambdabot>            against inferred type `Cont r a1'
05:36:40 <lambdabot>     Probable cause: `Cont' is applied to too many arguments
05:36:45 <mmorrow> hmm
05:36:49 <yitz> ben_h: also, there's a new version of hpaste around somewhere.
05:37:17 <quicksilver> mmorrow: well the arguments are all wrong
05:37:19 <mmorrow> http://moonpatio.com:8080/
05:37:22 <quicksilver> hence my 'FSOV .'
05:37:31 <mmorrow> quicksilver: heh, i just realized what you meant by that
05:37:31 <quicksilver> but if you can sort it out the basic idea should be there
05:37:41 * mmorrow is trying to sort now
05:38:20 <yitz> mmorrow: so is that better? should @hpaste (or even the hpaste.org domain) point to that now?
05:38:59 * yitz didn't mean to interrupt mmorrow's sorting, sorry.
05:39:25 <mmorrow> heh
05:39:37 <thoughtpolice> mmorrow: it's just the v2.0 hpaste - why it hasn't taken over hpaste.org yet I do not know :]
05:39:44 <mmorrow> yitz: i like the improved syntax highlighting and search
05:39:58 <mmorrow> also you can selectively highlight/unhighlight lines
05:40:03 <thoughtpolice> er, that was going to yitz :P
05:40:08 <ben_h> mmorrow: ahh nice, the new one doesn't copy line numbers
05:40:12 <yitz> got it :)
05:40:30 <mmorrow> ben_h: there's always the "raw" link too
05:40:34 <yitz> I want the announcements back.
05:40:38 <ben_h> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=331#a333 lol
05:40:41 <aeolist_> \names
05:41:02 <mmorrow> yitz: i really need to make lunabot annouce pastes there (since lunabot's already on the same machine..)
05:41:28 <mmorrow> hpaste2 comes with a pastebot as well, but i'm not sure how to get it to work
05:42:04 <mmorrow> (i'm sure it's not that hard, but i gave it a quick go at one point and failed)
05:42:53 <mmorrow> quicksilver: i'm not sure about runCont . foldM . Cont FSOV, since i'm not sure if you could get foldr from that (??)
05:43:01 <mmorrow> since
05:43:04 <mmorrow> @type fold<
05:43:05 <lambdabot> parse error (possibly incorrect indentation)
05:43:05 <mmorrow> @type foldM
05:43:06 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
05:43:16 <mmorrow> err, maybe
05:44:55 <mmorrow> @type \f z xs -> runCont $ foldM (\a b -> return (f a b)) z xs
05:44:56 <lambdabot> forall r a b. (a -> b -> a) -> a -> [b] -> (a -> r) -> r
05:45:06 <mmorrow> > list
05:45:07 <lambdabot>   Not in scope: `list'
05:45:29 <mmorrow> @let list n _ [] = n ; list _ c (x:xs) = c x xs
05:45:30 <lambdabot>  Defined.
05:45:50 <mmorrow> > (\!x -> x) ()
05:45:51 <lambdabot>   <no location info>: parse error on input `->'
05:46:53 <mmorrow> @type let foldC f z = list z (\x xs -> f z x xs (\z xs -> foldC f z xs)) in foldC
05:46:54 <lambdabot> forall t t1. (t -> t1 -> [t1] -> (t -> [t1] -> t) -> t) -> t -> [t1] -> t
05:47:05 <mmorrow> @type let foldC f z = list z (\x xs -> f z x xs (\z xs -> foldC f z xs)) in foldC :: (a -> b -> [b] -> (a -> [b] -> a) -> a) -> a -> [b] -> a
05:47:06 <lambdabot> forall a b. (a -> b -> [b] -> (a -> [b] -> a) -> a) -> a -> [b] -> a
05:47:40 <mmorrow> @let foldC = (\f z -> list z (\x xs -> f z x xs (\z xs -> foldC f z xs))) :: (a -> b -> [b] -> (a -> [b] -> a) -> a) -> a -> [b] -> a
05:47:41 <lambdabot>  <local>:5:8:
05:47:41 <lambdabot>      Inferred type is less polymorphic than expected
05:47:41 <lambdabot>        Qua...
05:47:42 <pozic> I am about to reify some conditions. Is there a good alternative to that? It's in a function that decides how a given value should be transformed, but it also computes in some cases what should happen for a lot of values after that value.
05:47:57 <mmorrow> @let foldC f z = list z (\x xs -> f z x xs (\z xs -> foldC f z xs)))
05:47:58 <lambdabot>   Parse error
05:48:01 <mmorrow> @let foldC f z = list z (\x xs -> f z x xs (\z xs -> foldC f z xs))
05:48:02 <lambdabot>  Defined.
05:48:04 <mmorrow> epic
05:48:59 <magthe> I'd like to read a user's keypresses, similar to how darcs works, I thought I saw an email on haskell-cafe recently on this subject (I might be mistaken though), any hints (besides the obvious: reading darcs' code)?
05:49:03 <mmorrow> > foldC (\a b bs k -> if b==0 then 0 else k (a*b) bs) 1 $ [1..10] ++ [0] ++ [1..]
05:49:04 <lambdabot>   0
05:49:36 <mmorrow> > let foldr f = foldC (\z x xs k -> f x (k z xs)) in foldr (:) [] [0..]
05:49:37 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:49:38 <yitz> magthe: it doesn't just use getChar?
05:50:10 <mmorrow> > let foldl f = foldC (\z x xs k -> k (f z x) xs) in foldl (+) 0 [0..1000]
05:50:11 <lambdabot>   500500
05:50:12 <magthe> yitz: not sure, I'll take a look at that together with NoBuffering
05:59:04 <mmorrow> quicksilver: i can't think of a way to do it with foldM and Cont
06:01:23 <Saizan> mmorrow: to do what? the shortcutting foldl?
06:01:48 <mmorrow> try to define foldC with foldM and Cont http://hpaste.org/11700
06:02:41 <Saizan> ?type foldM
06:02:42 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
06:02:47 <mmorrow> i don't think you can, since both foldr and foldl can be defined in terms of foldC, but foldM's type seems to exclude the possibility do use it and Cont for foldr
06:03:01 <mmorrow> s/do use it/to use it/
06:03:19 <mmorrow> > let foldr f = foldC (\z x xs k -> f x (k z xs)) in foldr (:) [] [0..]
06:03:21 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
06:03:22 <mmorrow> > let foldl f = foldC (\z x xs k -> k (f z x) xs) in foldl (+) 0 [0..1000]
06:03:23 <lambdabot>   500500
06:03:43 <lilac> @let foldlC f x xs = foldM ((return .) . f) x xs `runCont` id
06:03:44 <lambdabot>  Defined.
06:04:07 <mmorrow> @type foldlC
06:04:09 <lambdabot> forall b a. (b -> a -> b) -> b -> [a] -> b
06:04:13 <mmorrow> @type foldC
06:04:14 <lambdabot> forall t t1. (t -> t1 -> [t1] -> (t -> [t1] -> t) -> t) -> t -> [t1] -> t
06:04:51 <mmorrow> foldC is most interesting in the cases that can't be done with foldl or foldr
06:05:16 <mmorrow> > let product = foldC (\a b bs k -> if b==0 then 0 else k (a*b) bs) 1 in product $ [1..10] ++ [0] ++ [1..]
06:05:29 <lambdabot>   0
06:08:37 <Saizan> > let foldr' f = foldM (\z x -> Cont $ \k -> f x (k z)) in flip runCont id $ foldr' (:) [] [1..10]
06:08:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
06:09:26 <mmorrow> err, but try to defined foldC with foldM and Cont
06:10:02 <Saizan> you can't since foldM doesn't give you access to the tail of the list, but you also never use it directly
06:10:02 <mmorrow> if it's possible, it's not clear to me how
06:10:26 <mmorrow> yeah, exactly. i was thinking something with callCC or shift, but that didn't seem to work either
06:12:24 <Saizan> ?type let foldrM f x xs = flip runContT return $ foldM (\z x -> ContT $ \k -> f x (k z)) x xs in foldrM
06:12:26 <lambdabot> forall b (m :: * -> *) r. (Monad m) => (b -> m r -> m r) -> r -> [b] -> m r
06:12:36 <Saizan> nice :)
06:13:15 <Saizan> ?type \f -> foldr f . return
06:13:16 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> m a1 -> m a1) -> a1 -> [a] -> m a1
06:14:01 <Saizan> mmorrow: yours is more a paramorphism than a fold/cata, btw
06:15:06 <mmorrow> @let chunk n = foldC (\_ b bs k -> let (xs,ys) = splitAt (n-1) bs in (b:xs) : k [] ys) []
06:15:08 <lambdabot>  Defined.
06:15:15 <mmorrow> > chunk 4 [0..49]
06:15:17 <lambdabot>   [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23],...
06:15:35 <mmorrow> Saizan: interesting
06:16:01 * mmorrow refreshes his memory of the exact defs of para/cata/ana/hylo/etc..
06:16:32 <mmorrow> > chunk 4 [0..9]
06:16:34 <lambdabot>   [[0,1,2,3],[4,5,6,7],[8,9]]
06:19:58 <mmorrow> @let let chunkmod m = foldC (\_ n ns k -> let (xs,ys) = splitAt (n`mod`m) ns in (n:xs) : k [] ys) []
06:19:58 <lambdabot>   Parse error
06:20:02 <mmorrow> @let chunkmod m = foldC (\_ n ns k -> let (xs,ys) = splitAt (n`mod`m) ns in (n:xs) : k [] ys) []
06:20:04 <lambdabot>  Defined.
06:20:07 <mmorrow> heh "chunkmod"
06:20:15 <mmorrow> made me lol
06:20:34 <mmorrow> > chunkmod 3 [0..]
06:20:36 <lambdabot>   [[0],[1,2],[3],[4,5],[6],[7,8],[9],[10,11],[12],[13,14],[15],[16,17],[18],[...
06:20:43 <mmorrow> > chunkmod 4 [0..]
06:20:45 <lambdabot>   [[0],[1,2],[3,4,5,6],[7,8,9,10],[11,12,13,14],[15,16,17,18],[19,20,21,22],[...
06:24:20 <BeelsebobWork> > chunkmod 41 [0..]
06:24:22 <lambdabot>   [[0],[1,2],[3,4,5,6],[7,8,9,10,11,12,13,14],[15,16,17,18,19,20,21,22,23,24,...
06:24:33 <BeelsebobWork> hmm, that was too high
06:24:37 <BeelsebobWork> > chunkmod 7 [0..]
06:24:38 <mmorrow> > (fmap . fmap) (const ()) (chunky 5 (randoms (mkStdGen 73827)) :: [[Int]])
06:24:40 <lambdabot>   Not in scope: `chunky'
06:24:40 <lambdabot>   [[0],[1,2],[3,4,5,6],[7],[8,9],[10,11,12,13],[14],[15,16],[17,18,19,20],[21...
06:24:46 <mmorrow> > (fmap . fmap) (const ()) (chunkmod 5 (randoms (mkStdGen 73827)) :: [[Int]])
06:24:48 <lambdabot>   [[(),(),(),()],[(),(),(),()],[(),(),(),(),()],[()],[(),(),()],[(),(),(),(),...
06:25:05 <BeelsebobWork> hmm, is that generating all powers of two less than the number you give it
06:25:20 <BeelsebobWork> > map length . chunkmod 41 $ [0..]
06:25:22 <lambdabot>   [1,2,4,8,16,32,23,5,10,20,40,39,37,33,25,9,18,36,31,21,1,2,4,8,16,32,23,5,1...
06:25:31 <BeelsebobWork> heh
06:25:32 <BeelsebobWork> neat
06:25:36 <mmorrow> whoa
06:25:48 <BeelsebobWork> > map length . chunkmod 7927 $ [0..]
06:25:51 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,265,530,1060,2120,4240,553,110...
06:25:55 <BeelsebobWork> :D
06:25:59 <mmorrow> chunkmod is neat
06:26:06 <BeelsebobWork> it makes sense though
06:26:29 <BeelsebobWork> skip's one number, and gets to the number itself -- rinse repeat jumps along by powers of two
06:26:40 <mmorrow> interesting
06:29:52 <lilac> mmorrow: i think the foldr-in-terms-of-foldM can be done with the reverse state monad.
06:30:45 <mmorrow> lilac: ooh, cool. i've been meaning to look at the def of reverse state..
06:33:41 <Saizan> lilac: did you see the one with Cont?
06:35:58 <mmorrow> lilac: yeah, Saizan showed a foldr. foldC on the other hand i don't think is possible using only foldM and some monad on account of foldM's type
06:45:47 <camio> Is there a lib in ghc that can tell me if a file is a directory?
06:46:24 <dcoutts> @hoogle doesDirectoryExist
06:46:24 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
06:46:33 <camio> thanks
06:51:44 <mmorrow> @let bfs = foldC (\_ (Node a xs) ys k -> a : k [] (ys++xs)) undefined
06:51:46 <lambdabot>  Defined.
06:52:40 <mmorrow> > flatten [Node 0 [Node 1 [], Node 2 []], Node 3 [Node 4 [], Node 5 []]]
06:52:41 <lambdabot>   Couldn't match expected type `Tree a' against inferred type `[a1]'
06:52:48 <mmorrow> > fmap flatten [Node 0 [Node 1 [], Node 2 []], Node 3 [Node 4 [], Node 5 []]]
06:52:50 <lambdabot>   [[0,1,2],[3,4,5]]
06:53:19 <mmorrow> > levels (Node (-1) [Node 0 [Node 1 [], Node 2 []], Node 3 [Node 4 [], Node 5 []]])
06:53:21 <lambdabot>   [[-1],[0,3],[1,2,4,5]]
06:53:30 <mmorrow> > bfs [Node 0 [Node 1 [], Node 2 []], Node 3 [Node 4 [], Node 5 []]]
06:53:46 <mmorrow> um'
06:53:49 <lambdabot>   [0,3,1,2,4,5]
06:53:50 <mmorrow> > 3
06:53:52 <lambdabot>   3
06:53:54 <mmorrow> > bfs [Node 0 [Node 1 [], Node 2 []], Node 3 [Node 4 [], Node 5 []]]
06:53:56 <lambdabot>   [0,3,1,2,4,5]
06:57:29 <mmorrow> > bfs [Node (-1) [Node 0 [Node 1 [], Node 2 []], Node 3 [Node 4 [], Node 5 []]]]
06:57:30 <lambdabot>   [-1,0,3,1,2,4,5]
07:01:44 <jff> Hi, can someone please help me out with http://hpaste.org/11701 ?
07:03:12 <arjanb> jff: it's caused by the defaulting rules
07:04:34 <jff> But then, f and (+) are not the same function, are they?
07:04:51 <arjanb> right
07:04:54 <zax> No, f is an instance of (+)
07:05:06 <zax> so to speak
07:05:51 <jff> But if I write f = g, shouldn't I be getting the same function? :-)
07:07:39 <Saizan> jff: yes, but parameterless bindings can't be typeclass polymorphic due to the monomorphism restriction
07:08:11 <Saizan> jff: so ghci has to remove the Num a => context, picking a specific type for 'a' via defaulting
07:08:41 <Saizan> jff: you can :set -XNoMonomorphismRestriction to lift it
07:26:47 <mmorrow> @src mapAccumR
07:26:49 <lambdabot> Source not found. Maybe you made a typo?
07:28:03 <And1> Who's in charge of the haskell/xmonad-wiki?
07:28:07 <jff> Saizan, ok, thanks!
07:32:17 <RayNbow> And1: what do you mean with "in charge of"?
07:32:20 <mmorrow> @let let foldAccumC done _ s [] = done s ; chunk n = foldC (\_ b bs k -> let (xs,ys) = splitAt (n-1) bs in (b:xs) : k [] ys) []
07:32:36 <mmorrow> oh crap
07:32:48 <And1> RayNbow: Who's responsible for it/who's the administrator/...
07:33:04 <RayNbow> And1: a wiki entry can be edited by anyone
07:33:14 <mmorrow> @let foldAccumC done _ s  []    = done s ; foldAccumC done f s (x:xs) = f s x xs (\s xs -> foldAccumC done f s xs)
07:33:26 <And1> RayNbow: I can't upload images, "The connection was reset" every time I try.
07:33:27 <mmorrow> @bot
07:33:36 <RayNbow> mmorrow: you killed lambdabot!
07:33:40 <mmorrow> oh noes!
07:33:58 <mmorrow> lunabot needs @let bad
07:34:18 <mmorrow> @tell lambdabot i'm sorry :)
07:35:00 <RayNbow> mmorrow: oh, that's why the bot didn't respond... netsplit :p
07:35:53 <mmorrow> RayNbow: phew
07:35:58 <mmorrow> @bot
07:36:06 <mmorrow> > 42
07:36:29 <And1> RayNbow: Any ideas, why?
07:36:30 <roconnor> 42
07:37:10 <mmorrow> roconnorbot
07:37:15 <RayNbow> And1: no, I don't... you could try contacting the admin of the haskell.org site... but I have no idea who that is
07:37:18 <mmorrow> @botsnack
07:37:21 <roconnor> :)
07:37:25 <mmorrow> hah
07:37:30 <And1> RayNbow: K, thanks though. =)
07:38:09 <RayNbow> Cale: do you know who's maintaining haskell.org?
07:39:19 <pozic> RayNbow: http://www.haskell.org/haskellwiki/Haskell.org
07:39:28 <pozic> RayNbow: UTFS :)
07:40:59 <RayNbow> pozic: bah! :p
07:41:26 * RayNbow should spend some skill points in UTFS
07:42:03 <lambdabot> :)
07:42:08 <lambdabot>   42
07:42:08 <lambdabot> :)
07:42:20 <BeelsebobWork> @botsnack
07:42:35 <lambdabot> Title: Haskell.org - HaskellWiki
07:43:13 <lambdabot> :)
07:43:30 <BeelsebobWork> man lambdabot is lagging
07:44:53 <RayNbow> > ping
07:44:54 <lambdabot>   pong
07:45:36 <ziman> > id ping
07:45:38 <lambdabot>   pong
07:45:53 <ziman> :t ping
07:45:55 <lambdabot> forall a. Sym a
07:47:05 <RayNbow> > iterate ping
07:47:06 <lambdabot>   Couldn't match expected type `a -> a'
07:47:12 <RayNbow> eh wait
07:47:16 <RayNbow> > repeat ping
07:47:17 <lambdabot>   [pong,pong,pong,pong,pong,pong,pong,pong,pong,pong,pong,pong,pong,pong,pong...
07:48:02 <ToRA|MSR> > [ping, pong]
07:48:04 <lambdabot>   [pong,ping]
07:52:15 <kalven> > cycle [ping,pong]
07:52:17 <lambdabot>   [pong,ping,pong,ping,pong,ping,pong,ping,pong,ping,pong,ping,pong,ping,pong...
08:06:08 <sandbox> what would be an 'intelligent' way of making a function that returns false for a list with 2+ False and True otherwise?  Currently I just walk the list with a second arg that tells me if I've seen false.
08:06:56 <ziman> > (>= 2) . length . filter not $ [True, True, True, False, False, True]
08:06:58 <lambdabot>   True
08:07:19 <ziman> > (>= 2) . length . filter not $ [True, True, True, False, True]
08:07:20 <lambdabot>   False
08:07:36 <andun> > (>= 2) . length . filter not $ [True, False, False] ++ repeat False
08:07:49 <ziman> good point.
08:07:51 <lambdabot>   thread killed
08:09:36 <ziman> > not . null . drop 1 . filter not $ [True, True, True, False, True] ++ repeat False
08:09:38 <lambdabot>   True
08:10:02 <camio> Anyone know of something like Language.Haskell.Parser that works with "beyond" haskell98?
08:11:02 <sandbox> thanks, ziman
08:11:17 <sandbox> for both examples
08:19:59 <dmwit> ziman: Better solution: create a lazy Natural and make it an instance of Num. ;-)
08:20:19 <dmwit> data Nat = Zero | Succ Nat
08:20:50 <dmwit> instance Num Nat where fromInteger 0 = Zero; fromInteger n = Succ (fromInteger (n - 1))
08:21:19 <dmwit> (>= 2 :: Nat) . genericLength . filter not
08:21:32 * dmwit feels like he's lost his need for speed somewhere along the line
08:21:50 <ziman> i guess the speed won't suffer
08:22:04 <dmwit> You might also need to define (+).
08:22:18 <dmwit> ?src genericLength
08:22:19 <lambdabot> genericLength []    = 0
08:22:19 <lambdabot> genericLength (_:l) = 1 + genericLength l
08:22:26 <ziman> you'll traverse the list as you'll descend into the natural while comparing it with 2.
08:23:27 <int-e> @src genericLength
08:23:27 <lambdabot> genericLength []    = 0
08:23:27 <lambdabot> genericLength (_:l) = 1 + genericLength l
08:24:44 <andun> @src length
08:24:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:28:29 <Saizan> camio: haskell-src-exts
08:47:11 <mmorrow> @let mutual f g a = f a (\b -> g b (\a -> mutual f g a))
08:47:13 <lambdabot>  Defined.
08:48:42 <lispy> ?seen dcoutts
08:48:43 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 4m 58s ago.
08:48:59 <dcoutts> hia lispy
08:49:05 <lispy> dcoutts_: I'm trying to get Cabal 1.6.x going on windows and I have some feedback :)
08:49:14 <dcoutts> ok... :-)
08:49:17 <mmorrow> @type mutual :: (a -> (b -> s) -> r) -> (b -> (a -> r) -> s) -> a -> r
08:49:19 <lambdabot> forall a b s r. (a -> (b -> s) -> r) -> (b -> (a -> r) -> s) -> a -> r
08:49:30 <lispy> dcoutts_: first order of business, I needed 7-zip because the website just has a .tar.gz (a .zip would be polite to users)
08:49:46 <dcoutts> lispy: winzip does .tar.gz too
08:50:22 * mmorrow loves when zip files vomit their contents all over the pwd rather than making a new dir
08:50:26 <lispy> dcoutts: ah, but winzip sucks, 7-zip is open source.  But, my real point was that on windows xp and vista you get an un .zip tool with windows
08:50:47 <dcoutts> lispy: and all the other packages also use .tar.gz so I'm not sure it's a great advantage if just one has .zip too
08:50:50 <lispy> dcoutts: anyway, that problem is more superficial than anything
08:51:18 <lispy> dcoutts: the next order of business is what happens when you 'runghc Setup.hs configure'
08:51:40 <dcoutts> lispy: against the recommendation of the README I might note ;-)
08:51:42 <lispy> dcoutts: and in that case you get a problem with undefined symbol
08:51:52 <lispy> oh, am I doing it wrong?
08:52:08 <lispy> dcoutts: ah excellent
08:52:16 <lispy> dcoutts: so the readme already says to use --make
08:52:23 <dcoutts> lispy: it's ticket http://hackage.haskell.org/trac/hackage/ticket/325
08:52:25 <lispy> dcoutts: my appologies
08:52:25 <lambdabot> Title: #325 (SHGetFolderPath requiered to configure cabal on windows) - Hackage - Trac
08:52:40 <dcoutts> lispy: ideally runghc would work, but you can see in the ticket the reasons it does not
08:53:19 <dcoutts> the solution is for SHGetFolderPath to be bound by the win32 package
08:53:47 <sam___> What is the name of program that automatically simplifies haskell expression?
08:53:56 <lispy> sam___: ?pl ?
08:53:57 <mapreduce> Cale
08:54:03 <lispy> ?pl \x y -> x : y
08:54:03 <lambdabot> (:)
08:54:15 <Cale> yes?
08:54:30 <mmorrow> shoulda done this (same type, but cleaner)
08:54:31 <mapreduce> Cale: That's the name of the program that automatically simplifies haskell expressions. :)
08:54:31 <lispy> dcoutts: well, I'm glad that's in the read me :)  Next I will try cabal-install
08:54:32 <mmorrow> mutual f g a = f a (\b -> mutual g f b)
08:54:38 <sam___> eg by giving this expression (x y. x (x y)) (a b. a (a b)) (c d e. d)  it simplifies it to here b d e. d
08:54:57 <Cale> mapreduce: ah
08:55:36 <Cale> sam___: You mean a lambda calculus evaluator, not a Haskell evaluator, right?
08:55:48 <sam___> Cale: Yes :)
08:56:00 <Saizan> there's one on hackage, iirc
08:56:03 <lispy> dcoutts: windows makes it hard to write a bootstrap.bat doesn't it?
08:56:28 <Saizan> lispy: no wget/curl
08:56:36 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/LambdaShell
08:56:38 <lambdabot> Title: HackageDB: LambdaShell-0.9.1, http://tinyurl.com/655a9w
08:56:40 <lispy> Saizan: right yeah
08:56:40 <Cale> sounds about right
08:57:12 <sam___> Cale: Thanks a lot! :)
08:57:16 <lispy> Saizan: I guess we could do some IE automation via com and probably make that behave as wget...but ick
08:58:00 <Cale> lispy: Or include the source for an HTTP client ;)
08:59:31 <lispy> dcoutts: going back to the .zip issue for a moment.  Would it be hard to have hackage create a .zip and place it in the Downloads section?
08:59:47 <lispy> dcoutts: I mean, so that packages have .tar.gz and .zip options?
09:00:32 <dcoutts> lispy: not desperately hard, but I don't think it's any great advantage
09:00:47 <dcoutts> lispy: once you've got cabal-install then you don't need the .zip s
09:01:24 <dcoutts> lispy: there's a pre-built cabal.exe here if you want to try it: http://haskell.org/~duncan/cabal/cabal.exe
09:01:31 <sam___> Is there any lambda calculus evaluator for mac?
09:01:32 <lispy> dcoutts: IMO, we either need to have a Haskell Platform for windows that gives you, 7-zip, wget, etc OR we use data formats that are windows-ish.  In this case, since windows xp and vista ship with .zip support I consider them "windows-ish"
09:02:00 <dcoutts> lispy: the Haskell Platform will use an installer and will come with cabal-install
09:02:36 * lispy notes that since 7-zip is free software all windows users should have it anyway...
09:02:50 <idnar> I assume on other platforms you'll be able to do something like "aptitude install haskell-platform"
09:03:12 <lispy> dcoutts: okay.  Maybe I'm harping on a weird point.  I just feel bad for these windows users that have to jump through unix-ish hoops that may feel alien to them
09:03:37 * lispy now has cabal -install 0.6
09:03:42 <idnar> well, the alien part is probably the "run cabal install from a cmdline" part
09:03:52 <idnar> you need a nice GUI browser thingy
09:04:16 <lispy> yes, a gtk2hs GUI package manager for cabal-install sounds good
09:04:24 <idnar> alternatively, you could do something like AptURL
09:04:33 <idnar> that way the hackage website would be the GUI browser thingy
09:04:39 <idnar> although I guess that doesn't handle uninstallation etc.
09:04:54 <dcoutts> sure, a gui would be nice
09:04:59 <idnar> I suppose you could tie into the Windows installer system if you wanted to have "native" uninstallation
09:05:06 <dcoutts> eg adapt araujo's himerge to use cabal
09:05:22 <idnar> (I have no clue how cabal works, so I'm just freewheeling here, no idea how hard / feasible any of this would be to implement)
09:05:35 <lispy> dcoutts: anyway, i hope I don't sound too negative.  I was just trying to think of ways to improve windows experience :)
09:05:54 <lispy> lost cause? :)
09:06:02 * lispy looks down on those windows users....bad users
09:06:39 <dcoutts> lispy: no, not at all a lost cause, installing cabal-install on windows at the moment is not easy. The solution is a pre-built cabal.exe and having that included in the platform installer
09:06:58 * lispy wonders how to most easily fetch the sprint branch of darcs on windows without an existing darcs...hrm...
09:07:38 <lispy> dcoutts: okay.  If you have a clear plan I will stop whinning :)
09:08:02 <dcoutts> lispy: you may also like to comment on http://hackage.haskell.org/trac/hackage/ticket/390
09:08:04 <lambdabot> Title: #390 (add cabal unpack command) - Hackage - Trac
09:08:30 <dcoutts> lispy: if you're interested in actually unpacking and inspecting packages off of hackage, rather than just installing them
09:08:40 <lispy> yes, this command is much needed
09:08:49 <dcoutts> lispy: add your vote then
09:08:53 <lispy> and it would be more or less trivial given the framework, right?
09:08:56 <dcoutts> I also want to make hackage serve the entire content of the package tarballs
09:09:00 <dcoutts> lispy: yep
09:09:09 <dcoutts> lispy: nice task for a new dev
09:09:22 <lispy> dcoutts: add my vote?  just leave a comment saying +1 and my name?
09:09:44 <dcoutts> lispy: yep, and/or add your username/email to the cc list
09:09:48 <mopped> How can I turn a Num into an Int/integer, likewise with a char/string?
09:10:20 <Cale> mopped: What kind of Num?
09:10:32 <Cale> mopped: fromIntegral is often what you want.
09:10:32 <mopped> Hmm, Double
09:10:42 <mopped> > fromIntegral 2,5
09:10:43 <Cale> ah, by rounding, floor or ceiling?
09:10:44 <lambdabot>   <no location info>: parse error on input `,'
09:10:49 <Cale> > round 2.5
09:10:50 <lambdabot>   2
09:10:54 <Cale> > floor 2.5
09:10:56 <lambdabot>   2
09:10:59 <Cale> > ceiling 2.5
09:11:00 <lambdabot>   3
09:11:09 <Cale> There's also truncate
09:11:14 <Cale> > truncate (-2.5)
09:11:16 <lambdabot>   -2
09:11:21 <Cale> > truncate 2.5
09:11:23 <lambdabot>   2
09:11:35 <Cale> round means round to even
09:11:38 <mopped> what from fromIntegral do then? Int -> Integer?
09:11:52 <lispy> dcoutts: thanks, updated
09:11:59 <Cale> fromIntegral converts from any integer-like type to any numeric type
09:12:09 <Apocalisp> > round 0.5
09:12:11 <Cale> So yeah, Int -> Integer, for example
09:12:11 <lambdabot>   0
09:12:25 <Cale> Or Integer -> Double
09:12:29 <alp2> I've put together a pair of functions exposing the interaction between IO an laziness (here, http://hpaste.org/11704). Is there a way to make the code space efficient, i.e. to process the intermediate list lazily?
09:12:32 <Apocalisp> > toInteger 0.5
09:12:34 <lambdabot>   Add a type signature
09:12:57 <mopped> > toInteger 5 :: Double
09:13:00 <lambdabot>   Couldn't match expected type `Double'
09:13:06 <mopped> > fromIntegral 5 :: Double
09:13:07 <mopped> even
09:13:08 <lambdabot>   5.0
09:13:15 <mopped> aha, thanks
09:13:25 * lispy uses wget -m to download the darcs-sprint repo...I hope tihs works
09:13:26 <Cale> There's also realToFrac
09:13:37 <Cale> which is typically what you'll use to convert between fractional types
09:13:55 <Cale> > realToFrac (1.7 :: Double) :: Float
09:13:56 <lambdabot>   1.7
09:14:05 <Apocalisp> ?src round
09:14:06 <lambdabot> Source not found. I feel much better now.
09:14:11 <Apocalisp> ?src floor
09:14:13 <lambdabot> Source not found.
09:14:18 <Cale> alp2: hmm...
09:14:25 <mopped> > fromIntegral "2" :: Integer
09:14:27 <lambdabot>       No instance for (Integral [Char])
09:14:27 <lambdabot>        arising from a use of `fromInt...
09:15:09 <alp2> Cale: function c is just a filter
09:15:26 <alp2> if I use it outside of the IO monad, it works lazily
09:15:47 <Cale> alp2: Why is a in the IO monad?
09:15:55 <Cale> There's nothing to do with IO in there.
09:16:02 <alp2> Cale: yup, it's just an example
09:16:28 <alp2> Cale: I guess we can assume it is reading Ints from a file...
09:17:52 <Cale> okay...
09:24:14 <Cale> alp2: Well, you can cheat...
09:24:38 <Cale> alp2: and use unsafeInterleaveIO to make the recursive call which a does lazy.
09:25:13 <alp2> Cale: ok, great
09:25:16 <alp2> but what about c?
09:25:19 <alp2> I mean
09:25:33 <alp2> assume there is another "consumer" after c
09:25:54 <alp2> is it possible to use unsafeInterleaveIO inside c as it is wrapped into a ReaderT ?
09:26:11 <Cale> Well, it can be lifted.
09:26:36 <alp2> Cale: ok
09:26:41 <alp2> thx
09:26:44 <Cale> oh, but you can't apply it to ReaderT computations.
09:26:52 <Cale> Only to IO computations.
09:26:59 <alp2> yes, that was my point
09:27:02 <idnar> unsafeInterleaveReaderT
09:27:07 <Cale> ReaderT is somewhat trivial though, so you could run runReaderT inside.
09:27:53 <Cale> But I'm not really sure what this is meant to represent, or whether unsafeInterleaveIO is really the right answer.
09:28:00 <int-e> @type \f -> ask >>= return . runReaderT f
09:28:01 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *) a1. (MonadReader a m) => ReaderT a m1 a1 -> m (m1 a1)
09:28:23 <Cale> At least in this case, a better answer would be to move more of this computation out of IO entirely.
09:28:49 <alp2> yes
09:29:02 <Cale> Even if we're assuming that there's actual I/O to be done here, deferring it until later might be better.
09:29:36 <alp2> but I'm actually trying to write a more general problem in which I have a number of "filters" (each one performin I/O) that are piped together
09:29:48 <alp2> I was looking for a general solution to the problem of composing them
09:29:55 <Cale> hmm...
09:29:56 <alp2> in a lazy fashion, I mean
09:30:05 <Cale> Concurrency might not be a bad idea.
09:30:27 <alp2> yes, that sounds interesting...
09:30:37 <Cale> You could have the first thing writing into a Chan, and the next reading from it and writing to another.
09:30:49 <Cale> It shouldn't be hard to rig up a decent abstraction around that idea.
09:30:56 <lispy> dcoutts: okay, so I'm trying to get darcs sprint to build on windows
09:31:13 <lispy> dcoutts: first problem is that it wants curl.  so I want to make HTTP the default on windows I guess
09:31:24 <alp2> Cale: sure, thx!
09:31:35 <Cale> (maybe together with something like a quantity semaphore to prevent any one channel from getting too large)
09:32:51 <lispy> dcoutts: so I can put flag curl\n if os(windows)\n default: True\nelse default: False ?
09:32:57 <lispy> I guess I'll try it
09:33:27 <dcoutts> lispy: no, they're just literal True or False
09:33:33 <lispy> ah
09:35:14 <dcoutts> lispy: you can do if os(windows)\n the stuff for libcurl \n else\n what you had previously
09:35:27 <lispy> okay...
09:35:40 <dcoutts> lispy: if you want to force windows to use libcurl always and not have any of the other options
09:35:51 <dcoutts> lispy: does it not configure automatically?
09:36:16 <lispy> dcoutts: what about if I want HTTP to be the default for only windows?  Currently configure fails because I don't have any curl
09:36:32 <lispy> I would like to try curl and if that fails resort to HTTP
09:36:51 <lispy> C:\Users\jdagit\Desktop\haskell\sprint>runghc Setup.hs build
09:36:52 <lispy> Preprocessing executables for darcs-2.1.0...
09:36:52 <lispy> C:\ghc\ghc-6.8.3\gcc-lib\ld.exe: cannot find -lcurl
09:36:52 <lispy> collect2: ld returned 1 exit status
09:36:57 <lispy> That's what I'm getting now
09:37:22 <dcoutts> lispy: it'd fail at configure time if it checked for libs, or if you were using pkgconfig-depends
09:37:45 <lispy> this is windows so I don't have pkgconfig
09:37:49 <dcoutts> lispy: so that's the thing that the auto-resolving of configurations doesn't do yet, it only resolves based on build-depends
09:38:09 <dcoutts> lispy: gtk2hs uses pkg-config on windows, but yes it's not commonly available
09:38:12 <lispy> dcoutts: so the then, I have to configure -fhttp ?
09:38:17 <dcoutts> lispy: yep
09:38:22 <lispy> k
09:38:40 <lispy> hrm, but that dosen't disable curl
09:38:40 <dcoutts> lispy: and when I've improved the resolving to consider all deps then it'll do that automatically
09:38:59 <dcoutts> lispy: should do, you need to clean first
09:39:16 <dcoutts> it doesn't rebuild when the cpp flags have changed
09:39:44 <lispy> clean is not enough, I have to say -f-curl -f-libwww
09:40:11 <lispy> heh, my HTTP is too new
09:40:42 <dcoutts> lispy: hmm, yes ok
09:42:09 <lispy> dcoutts: hmm...so build-depends: HTTP >= 3000.0 && < 3001.1, does not mach 3001.1.4.  Should I change it to 3001.* ?
09:42:25 <dcoutts> lispy: or < 3001.2
09:42:32 <lispy> okay, thanks
09:42:44 <dcoutts> ie build-depends: HTTP >= 3000.0 && < 3001.2
09:42:58 <lispy> right
09:43:18 * dcoutts notes that QuickCheck shrinking rocks
09:43:31 <lispy> shrinking?
09:43:42 <dcoutts> yes, it can shrink failing test cases
09:43:49 <dcoutts> which is very cool
09:43:51 <lispy> hhmmwhat does thta mean?
09:44:09 <byorgey> i.e. to try to find a minimal test case that still makes the property fail.
09:44:13 <Cale> It means that it tries to find a simpler counterexample to your property
09:44:27 <dcoutts> lispy: well, here's an example, I've been working on that Cabal autoconfigure stuff we've just been talking about,
09:44:56 <dcoutts> lispy: and I've got an expression type for those tests like "os(windows) || flag (foo)"
09:45:22 <dcoutts> so when I write QC properties for these expressions and one fails, it's nice to have as small an example as possible
09:45:31 <lispy> aaaaaah
09:45:36 <lispy> yes, that is nice
09:45:44 <thoughtpolice> QC 2 == win all around
09:45:45 <dcoutts> so you can write a custom shrinking function
09:45:55 <quicksilver> in fact I have often written shringking functions by hand
09:45:57 <dcoutts> eg:
09:45:59 <quicksilver> (pre QC2)
09:46:10 <dcoutts> quickCheck prop_fmap_id
09:46:10 <dcoutts> *** Failed! Falsifiable (after 4 tests and 2 shrinks):
09:46:10 <dcoutts> PredExprOr (PredExprBase False) (PredExprLit True)
09:46:29 <dcoutts> that's with a deliberate mistake in the fmap function that swaps the params to Or
09:46:35 <lispy> ugh, Ctrl+C does not work with windows darcrs
09:46:56 <bbs> Cale: i have more questions!
09:46:58 <bbs> :p
09:46:58 <dcoutts> point is, without shrinking it'd have found a much larger test case
09:47:03 <bbs> and! i got it to parse perfectly
09:47:04 <Cale> bbs: shoot!
09:47:09 <bbs> kk
09:47:12 <bbs> let me paste again
09:48:12 <lispy> dcoutts: hmm...this darcs I built may be buggy
09:48:21 <bbs> http://zlin.dk/p/?ZDgwNTYy
09:48:25 <bbs> Cale: ^
09:48:25 <lambdabot> Title: K-nopaste
09:48:28 <lispy> oh no just horribly slow
09:48:39 <dcoutts> lispy: due to the HTTP package?
09:48:40 <Cale> Yeah, I think shrinking is actually the key to making quickcheck really useful not just for determining if there is a bug, but actually finding what the bug is.
09:49:01 <lispy> dcoutts: I haven't tried to use HTTP  yet.  I just reverted Setup.hs and it took about 30 seconds
09:49:13 <Cale> Being handed a large and complex failing case is generally not terribly useful, but being handed one which is minimal can be quite useful.
09:49:29 <dcoutts> Cale: does QC2 use the cunning trickery to display the functions used in failing test cases?
09:49:54 <dcoutts> that was what used to annoy me with QC1, finding the function value for the failing tests
09:50:06 <dcoutts> eg, discovering that one needs a non-associative function to trigger a bug
09:50:10 <Cale> I think it has some way to display functions, but I'm not sure.
09:50:34 <dcoutts> eg groupBy nonAssoc
09:50:38 <dcoutts> fun fun :-)
09:50:56 <bbs> Cale: so i can parse somethings
09:51:06 <bbs> meh loudness
09:51:18 <bbs> Cale: but it cannot be parsed together
09:51:55 <bbs> http://zlin.dk/p/?NzZjYTk0
09:51:56 <lambdabot> Title: K-nopaste
09:52:00 <bbs> ^^^ startnig interpreter
09:52:25 <bbs> so see where i added the p1 and p2 at the end of the program?
09:53:21 <lispy> huh, I don't know what the problem is but this darcs.exe is not happy about the global cache
09:53:48 <dcoutts> lispy: check if we're passing different cpp flags, the cabal build vs franchise
09:53:57 <dcoutts> or vs configure
09:54:11 <Cale> bbs: yeah?
09:55:04 <bbs> Cale: if i run my interpreter -- according to the parser i can do something like
09:55:09 <bbs> parsepart decs p1
09:55:23 <bbs> Cale: [Assign "x" (IntLit 1),Assign "y" (IntLit 2)]
09:55:30 <bbs> and thats what should / does come up
09:55:34 <lispy> dcoutts: I think it really is a problem with my global cache settings
09:55:45 <bbs> Cale: what about when i do program 2
09:55:51 <lispy> dcoutts: I was able to fetch a different repo and it works fine..just having problems fetching the darcs sprint repo
09:55:56 <bbs> Cale: i need to use exec right?
09:56:23 <bbs> what about state and all that jazz
09:56:26 <bbs> i just don't get that stuff
09:57:27 <Cale> bbs: Isn't the problem with p2 that it doesn't parse?
09:57:57 <bbs> no, shouldn't be
09:58:17 <Cale> bbs: The only difference between p2 and p1 is that p2 doesn't end in a semicolon.
09:58:56 <bbs> oh crap
09:58:58 <bbs> whoops
09:59:00 <bbs> wrong one
09:59:02 <bbs> :/ sorry
09:59:07 <bbs> i wrote another little one
09:59:10 <bbs> i sent and antiquated one
09:59:29 <bbs> Cale: its in overflow
10:01:12 <Cale> okay
10:01:39 <bbs> Cale: so thats not a parsepart
10:02:03 <bbs> since parsepart from the parser says "hey -- ok you wanna parse?  what kind do you want" -- then i specify decs or what have you
10:02:20 <bbs> but if i want to parse something with the whole thing
10:02:25 <bbs> i need to modify exec
10:02:28 <bbs> and i have no idea how to do that
10:02:46 <bbs> or how to create operational semantics like -- (e1,state) -> v1
10:02:54 <bbs> (e2, state) -> v2
10:03:09 <bbs> (e1+e2,state) -> v1+v2
10:03:10 <bbs> :/
10:05:12 <Cale> Well, presumably you're going to use the parser which parses the whole program.
10:05:25 <bbs> ok
10:05:41 <Cale> and as for state, probably the simplest thing to do is to carry around a dictionary of variable bindings
10:07:25 <bbs> Cale: like "store"
10:07:31 <bbs> which i implemented in evaluate
10:07:37 <bbs> and then lookup
10:07:48 <bbs> Cale: but state can also be done by a function
10:09:20 <bbs> Cale: see overflow again
10:10:17 <dons> ?users
10:10:18 <lambdabot> Maximum users seen in #haskell: 536, currently: 501 (93.5%), active: 18 (3.6%)
10:19:49 <nomeata> Hi. Is there something wrong with the function "stateAsReader :: MonadState s m' =>  (forall m. MonadReader s m => m a) -> m' a" that allows you to use a MonadReader function inside a MonadState computation?
10:23:26 <quicksilver> nomeata: looks plausible to me.
10:23:46 <quicksilver> (forall m. MonadReader s m => m a) is isomorphic to (s -> a), I believe.
10:24:06 <ddarius> Quite definitely not.
10:25:00 <nomeata> quicksilver: you mean "s -> m a"?
10:25:00 <ddarius> nomeata: That type is uninhabited (except for bottom)
10:25:33 <ddarius> (and mild variations on bottom, freakin' seq)
10:26:19 <ToRA|MSR> :t ask
10:26:23 <lilac> stateAsReader :: (MonadReader s m, MonadState s m') => m a -> m' a
10:26:27 <ToRA|MSR> @type ask
10:26:29 <lilac> ^^ probably what you meant
10:26:43 <pozic> > let ~(a,b) = fromJust Nothing in 5
10:26:45 <ddarius> Well, I guess const (fail "foo") would work, but that's likely bottom too
10:27:07 <nomeata> hmm, might be
10:27:28 <lilac> in questions of what's uninhabited, it's probably best to ignore fail and seq :)
10:27:42 <lilac> and unsafePerformIO and catch and so on
10:28:28 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
10:28:31 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
10:28:39 <lambdabot>   5
10:28:44 <quicksilver> nomeata: no, I don't.
10:29:11 <quicksilver> :t ask
10:29:16 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
10:29:26 <rwbarton> let stateAsReader :: MonadState s m' => (forall m. MonadReader s m => m a) -> m' a;  stateAsReader c = do x <- get; return (runReader c x)  -- works fine
10:29:43 <hugo_> my boss payed me with a cheque, and when i got to deposit it, there was no money in it...
10:29:43 <hugo_> ...bahh
10:29:49 <hugo_> i guess ill start looking for another job...
10:30:21 <rwbarton> , src ''MonadReader
10:30:38 <lunabot>  class (Monad m) => MonadReader r m | m -> r where
10:30:38 <lunabot>          ask :: m r
10:30:38 <lunabot>          local :: forall a . (r -> r) -> m a -> m a
10:31:06 <nomeata> rwbarton: yes, thats what I had in mind
10:32:08 <quicksilver> nomeata: I mean that if an action doesn't use any aspect of the monad except the readerishness
10:32:17 <quicksilver> nomeata: (as evidenced by the forall m)
10:32:30 <quicksilver> nomeata: then it is really just a function from the environment.
10:32:35 <quicksilver> I.e. s -> a
10:32:53 <quicksilver> in otherwords, if it works in *all* reader monads, it must work in the initial reader monad
10:32:54 <nomeata> Im writing an HAppS.State based app, so I have many functions with the MonadReader or MonadState context (depending whether its going to be an Update or an Query event)
10:32:56 <lilac> rwbarton: depends what you mean by 'works fine'
10:33:10 <nomeata> and it would be nice to use the MonadReader functions from both kind of events
10:33:16 <rwbarton> lilac: It typechecks.  And I'm pretty sure it's not bottom.
10:33:17 <lilac> rwbarton: it works when given a (forall m. MonadReader s m => m a), but not when given an ((->) s)
10:33:36 <lilac> s -> a, rather
10:33:55 <quicksilver> because s -> a isn't (obviously to the compiler) the same thing.
10:33:55 <rwbarton> right, you have to wrap the ((->) s) in ask essentially
10:34:03 <quicksilver> howevere ther is a mapping ;)
10:34:05 <lilac> in fact, the most general type for it is (MonadState r t) => Reader r a -> t a
10:34:18 <lilac> and if that's what you mean, i'd suggest giving it that type
10:34:27 <quicksilver> not so much 'the most general' as 'a different most general'
10:34:32 <quicksilver> in particular, that's a first-order version
10:34:38 <nomeata> isnt  "MonadState s m' => (forall m. MonadReader s m => m a) -> m' a" more general?
10:34:42 <quicksilver> but I agree it is probably more useful in practice.
10:34:50 <lilac> nomeata: no, it's less general
10:35:01 <lilac> nomeata: that requires the first argument to be *all* MonadReader types
10:35:12 <lilac> nomeata: whereas my one only requires the first argument to be Reader
10:35:23 <nomeata> lilac: ah, right, the function is less general, but the places where it can be used are more general, right?
10:35:55 <lilac> no, the places where it can be used are less general. the Reader one can be used with a Reader, the MonadReader one cannot.
10:36:15 <lilac> (because Reader is not all MonadReader types, since it's not ((->) s) for instance)
10:36:49 <nomeata> ok
10:37:35 <dons> mm. i got 3 emails about the Arch Haskell updates. People who hadn't seen it before. Maybe fortnightly updates are best.
10:37:36 <lambdabot> dons: You have 8 new messages. '/msg lambdabot @messages' to read them.
10:37:44 <dons> too many messages.
10:37:54 <dons> is lambdabot up more than twitter?
10:38:21 <rwbarton> There is a different type (MonadState s m', MonadReader s m) => m a -> m' a which certainly has no sensible values.
10:39:30 <pozic> dons: what's your opinion on the family syntax?
10:39:38 <dons> type family syntax?
10:39:45 <pozic> dons: yes
10:39:51 <dons> 'sok. i quite like the associated types syntax in particular.
10:39:52 <nomeata> :t let readerAsState c = get >>= runReader c in readerAsState
10:39:53 <lambdabot> forall a (m :: * -> *) b. (MonadState a m) => Reader a (m b) -> m b
10:40:02 <dons> which is all i've used in the wild.
10:40:18 <nomeata> :t let readerAsState c = runReader c `liftM` get in readerAsState
10:40:19 <lambdabot> forall a1 a (m :: * -> *). (MonadState a1 m) => Reader a1 a -> m a
10:40:21 <pozic> dons: ok, then you are the first :)
10:40:33 <dons> i've not heard any complaints actually
10:40:49 <nomeata> now, is this function too simple, or too bad practice to be included in the libs somewhere?
10:40:58 <dons> mm
10:41:05 <dons> in the mtl lib?
10:41:30 <nomeata> dons: yes, thatd be the place where Id expect it
10:44:33 <trhj1> @pl \a b c d -> a $ b $ c $ d
10:44:33 <lambdabot> (. (.)) . (.) . (.)
10:44:46 <quicksilver> nomeata: there are a variety of hoisting and transforming functions.
10:44:58 <quicksilver> nomeata: I think the problem is it's not entirely clear which ones are best.
10:45:25 <nomeata> quicksilver: understandable
10:45:27 <quicksilver> I quite like MonadReader s m => (s -> x) -> m x
10:45:38 <quicksilver> and MonadState s m => (s -> (x,s)) => m x
10:45:52 <quicksilver> i.e. embedding the 'simple case' in an arbitrary monad
10:47:06 <nomeata> :t \a -> a `liftM` ask :: MonadReader s m => (s -> x) -> m x
10:47:07 <lambdabot>     Inferred type is less polymorphic than expected
10:47:08 <lambdabot>       Quantified type variable `x' is mentioned in the environment:
10:47:08 <lambdabot>         a :: (s -> x) -> m x (bound at <interactive>:1:1)
10:47:39 <nomeata> :t asks :: MonadReader s m => (s -> x) -> m x
10:47:40 <lambdabot> forall s x (m :: * -> *). (MonadReader s m) => (s -> x) -> m x
10:48:18 <nomeata> quicksilver: at lease the former one of yours is already present
10:49:23 <Dover> hello guys
10:49:30 <Dover> can somebody hlep me with this stupid problem?
10:49:31 <Dover> http://hpaste.org/11707
10:50:14 <chr1s> Dover: I think hpaste has some problems with unicode
10:50:22 <Dover> ?? same that 
10:50:23 <lambdabot>  same that 
10:50:27 <Dover> spanish character
10:50:55 <tromp__> you cant use / on Integers
10:51:12 <Dover> mmm same problem with out /
10:51:17 <tromp__> try div?
10:51:26 <Dover> problem is in *
10:51:50 <Dover> and maybe in / also
10:52:27 <vixey> Dover, you should not write  f(x)  but instead  f x
10:52:37 <vixey> so not,  f(1 + y)  but  f (1 + y)
10:53:10 <Dover> ok need more ()
10:53:17 <Dover> i understand that
10:53:22 <vixey> no that's not what I was saying
10:53:23 <Botje> perhaps ghc should correct source code.
10:53:24 <Dover> my english lvl is very little
10:53:30 <Botje> "silly user, that's not how you do that"
10:54:18 <Dover> mmm how i should do that Botje
10:54:31 <Botje> i was joking, nevermind
10:54:53 <Dover> ok ^^
10:54:59 <vixey> Dover, using GHCi ?
10:55:09 <Dover> no
10:55:10 <Dover> Winhugs
10:55:11 <Dover> :D
10:55:29 <Botje> ohgod, winhugs still exists?
10:55:37 <Dover> yep
10:55:54 <Dover> Couldnt install graphic interpreter in ubuntu :(
10:55:59 <Dover> only hugs as command line
10:56:05 <vixey> .. what
10:56:07 <vixey> ? lol
10:56:18 <vixey> It does work in ubuntu
10:56:20 <Botje> Dover: commandline is good enough, really
10:56:23 <vixey> GHCi ***
10:56:41 <Dover> ok another day i will try install GHCI
10:56:49 <Dover> now need make this exercises for tomorrow
10:56:49 <Dover> :D
10:56:54 <vixey> today install ghci
10:57:37 <Dover> tried use command line hugs and had problems with windows characters
10:57:53 <Dover> problems with format of characters
10:58:01 <Dover> no have time to rewrite all exercise
10:58:32 <Dover> for this exercise i still use winhugs need finish for tomorrow
10:59:33 <Botje> ghci and winhugs accept the samne language (haskell)
10:59:51 <Dover> win characters and linux characters are different
10:59:53 <Dover> i have 
10:59:56 <Dover> in my document
11:00:02 <Botje> ghc(i) is just infinitely better at features, speed, error messages, and warm fuzzy things
11:00:12 <Botje> i find that hard to believe.
11:00:17 <Dover> and linux dont read
11:00:18 <Botje> but okay.
11:00:24 <Dover> when finish i will donwload
11:00:32 <Dover> ghci
11:00:38 <rwbarton> just  sudo apt-get install ghc6
11:00:47 <Dover> ok
11:03:50 <jimstutt> ping dons
11:03:53 <dons> yo
11:04:07 <jimstutt> dons:hi
11:04:19 <dons> hey
11:05:45 <Dover> cant repair the problem
11:05:47 <Dover> will restart
11:05:55 <Dover> and do this functions in linux
11:05:59 <Dover> brb
11:07:32 <dons> jimstutt: did you have a question?
11:08:01 <jimstutt> dons: failing to build ghc-6.10.1 on archlinux x86. Has anyone built it yet? Will put in some time to get reactive going.
11:08:13 <dons> oh, its in testing.
11:08:22 <dons> jimstutt: i'm just using vegai's binary from [testing]
11:08:29 <dons> and i've built it several times too, fwiw.
11:08:37 <jimstutt> dons: I could only find x86_64?
11:08:41 <dons> oh. hmm
11:08:49 <dons> jimstutt: check with vegai in #archhaskell
11:08:55 <dons> #arch-haskell
11:09:28 <jimstutt> dons: great, I'll go there.
11:10:04 <dons> jimstutt: btw, the RC is just an RC, it still has things to iron out.
11:14:20 <jimstutt> dons: yea, it's a good opportunity for me to learn ghc build system.
11:14:33 <vixey> ghc build system is so bad :/
11:14:40 <vixey> it uses makefiles and stuff
11:14:43 <Botje> can we cabalize ghc yet?
11:14:59 <vixey> is cabal stable enough to rely on though?
11:15:06 <saml> doesn't cabal depend on ghc?
11:15:16 <wchogg> @seen conal
11:15:16 <lambdabot> I saw conal leaving #haskell and #ghc 8m 43s ago, and .
11:15:17 <Botje> saml: you need ghc to install ghc anyway
11:15:44 <Igloo> GHC itself is currently built with Cabal, but the build system needs to beuild more than just the compiler
11:15:47 <LarstiQ> saml: lucky bootstrapping is not something you have to do a lot
11:15:49 <saml> it's like i need a computer to buy a computer thesdays
11:15:56 <jimstutt> botje: no, as dons says stuff (I think editline, HSarray, HScontainers etc) to sort out.
11:16:04 <Botje> boo
11:16:46 <Peaker> Botje: you need cabal-install to install cabal-install, and cabal to install cabal, etc, but they're cabalized?
11:16:55 <jimstutt> I want to build reactive but haven't seen ghc-6.9 being popular
11:17:06 <int-e> Peaker: you don't need cabal to install cabal
11:17:27 <Peaker> int-e: oh, ok, but cabal-install can install cabal-install, so why not ghc?
11:17:46 <dcoutts> Peaker: and you don't need cabal-install to install cabal-install
11:17:53 <Peaker> jimstutt: quicksilver wrote his own minimalist clone of Reactive, possibly usable until Reactive itself is released (He didn't release it or anything, but he gave me a copy..)
11:17:59 <dcoutts> otherwise bootstrapping would be impossible :-)
11:18:06 <Peaker> dcoutts: I totally misworded my statement ;-)
11:18:10 <dcoutts> (well, at least very tricky)
11:18:20 <int-e> Peaker: because it's a headache to replace the right things in the right order and rebuild all installed packages afterwards.
11:18:45 <dons> vixey: yeah, its stable enough to rely on :)
11:18:57 <Peaker> int-e: ok
11:18:58 <dcoutts> Peaker: ghc is pretty complex, but for example I think it'd be possible to install nhc98 via cabal
11:19:13 <dcoutts> cabal install nhc98 && cabal install --nhc98 base
11:19:44 <jimstutt> ping vegai
11:20:08 <lilac> dons: is the ghc 6.10.1 tarball on the download site a real release, or still an rc?
11:20:23 <int-e> it's still an rc
11:20:57 <lilac> 't'd be nice if 'rc' was in the filename really :)
11:21:45 <dcoutts> lilac: they were using 6.10.0.$date for the rc's
11:21:58 <Dover> hello again
11:22:12 <int-e> Igloo optimistically committed a patch, changing the version to 6.10.1 - but the release still hasn't happened :/
11:22:20 <dcoutts> lilac: the reason we have a 6.10.1 tarball there is because they switched into release mode, but then all the build bots fell over and the people who could fix them were on holiday
11:22:21 <Dover> i am downloading ghc6
11:22:28 <Dover> but have to go
11:22:28 <dons> lilac: RC!
11:22:36 <Dover> see you later
11:22:43 <dcoutts> so that was only supposed to be a temporary name, but it's been several days now.
11:22:56 <dcoutts> fortunately the buildbots are fixed and we're expecting a release any day now
11:24:19 <jimstutt> I spent a bit of time looking for ghc-6.10.1 src ;) - a beginner blocker.
11:25:18 <lilac> well, fair enough -- it's not linked from anywhere obvious at least :)
11:25:44 <Dover> nice compiler this hgc
11:25:52 <Dover> i am reading the help
11:26:14 <bos> is that tarball final?
11:26:20 <mauke> reading the help? that's so oldschool
11:27:24 <Dover> atenea hablas espaol? ^^
11:27:34 <atenea> hola
11:27:43 <Dover> no estudiaras en la ETSE jaja
11:28:03 <lispy> > estudiaras
11:28:04 <lambdabot>   Not in scope: `estudiaras'
11:28:24 <Dover> sorry we talking in spanish i saw that he or she has same internet provider than me
11:28:48 <dcoutts> bos: no
11:29:00 <bos> oh, unfortunate.
11:29:04 <atenea> no Dover
11:29:22 <Dover> bueno me voy
11:29:25 <Dover> see you soon
11:30:10 <yebyen> hi everybody
11:30:17 <lilac> > let compatibilidad (dA, mA, aA) (dB, mB, aB) = (abs (dA - dB) + abs ((dA - dB) * 30)) `div` 365 + abs (aA - aB)   in compatibilidad (1,2,3) (4,5,6)
11:30:18 <lambdabot>   3
11:30:45 <unenough> @babel
11:30:45 <lambdabot>   bzzt.
11:31:25 <lilac> Dover: ^^ the problem was that you were using 'round' and '/' on Integers, which Haskell doesn't like
11:31:47 <dons> bos, looks like the release is maybe tomorrow
11:31:56 <bos> coolio
11:32:01 <jpcooper> I feel ashamed: how does one do one-line comments in Haskell?
11:32:09 <dons> > 1 + 2 -- like this
11:32:10 <Saya> --
11:32:11 <lambdabot>   3
11:32:11 <lilac> release :: Maybe (IO DateTime)
11:32:16 <jpcooper> thanks
11:32:28 <dons> lilac: its in the NonDet monad :)
11:32:50 <mofmog1> so
11:33:02 <mofmog1> how do i get ghci interaction in emacs
11:33:06 <mofmog1> i've downloaded the file
11:33:11 <mofmog1> i've screwed around with the .emacs file
11:33:27 <mofmog1> haskell mode is installed and working, it shows me the type signature of functions and everything
11:33:52 <Peaker> how can I tell where "Data.Data" is imported from?  There's isn't necessarily a correlation between the import name and the package name :-(
11:33:57 <rwbarton> mofmog1: I added this line to my .emacs: (load-file "/home/rwbarton/emacs/haskell-mode-2.4/inf-haskell.el")
11:34:03 <rwbarton> mofmog1: then I was able to use C-c C-l
11:34:07 <Peaker> (I need to fix a cabal file to depend on the package exporting Data.Data)
11:34:09 <mofmog1> inf-haskell?
11:34:25 <dcoutts> Peaker: base 4 exports Data.Data
11:34:27 <mofmog1> well, i installed haskell-mode from the debian repositories because i'm a total noob
11:34:40 <mofmog1> then sitting in my home directory is "haskell-ghci.el"
11:34:47 <rwbarton> mofmog1: Yeah, so change the path to wherever the debian package unpacks to
11:34:48 <Peaker> dcoutts: is there any automatic way to know who exports what?
11:35:13 <mofmog1> which would be ~anywhere~
11:35:13 <lilac> Dover: do you understand why your version is not accepted?
11:35:21 <dcoutts> Peaker: ghc-pkg find-module Data.Data
11:35:26 <Peaker> dcoutts: thanks!
11:37:13 * Peaker changes haskell-src-exts's cabal file to depend on base >= 4 instead of base >= 3 and now lambdabot seems to at least agree to compile (and maybe it will install) on ghc 6.10
11:37:19 <Peaker> changed*
11:38:10 <olsner> but it doesn't jive right with me that packages suddenly start arbitrarily requiring 6.10
11:38:36 <Peaker> Hmm, lambdabot fails to compile with: Module `GHC.IOBase' does not export `Exception(NoMethodError)'
11:38:47 <dons> Peaker: base < 4
11:38:48 <dons> :)
11:38:52 <dons> seriously.
11:39:11 <Peaker> dons: is that exception in base 3 or 4?
11:39:37 <lilac> getting /b + deps to compile with GHC6.10 was a little fiddly
11:39:43 * lilac gave up on mueval
11:39:55 <lilac> or rather, on hint
11:40:27 <lilac> Peaker: it'll be base 3. base 4 uses extensible exceptions
11:42:10 <lilac> import Control.Exception           (Exception(NoMethodError))
11:42:18 <lilac> ^^ replace the GHC.IOBase import with that
11:42:37 <lilac> (in Plugin/Base.hs and Plugin/Compose.hs)
11:44:14 * lilac generates diffs
11:44:27 <marcot> When I do ghc-pkg list with a user I'm not getting some packages that I get with other.
11:44:33 <marcot> Where can this configuration be?
11:44:40 <dons> ibid: can you resend me the details for admining planet haskell?
11:44:43 <marcot> The other user is a clean user (in which I get more packages).
11:44:49 <dons> ibid: i'd like to help ensure the queue doesn't get too long
11:45:40 <marcot> And the package not showing in my user is xmonad from debian.
11:46:33 <lilac> Peaker: http://metafoo.co.uk/downloads/lambdabot-ghc-6.10.1.diff
11:46:44 <Peaker> lilac: thanks
11:46:45 <ibid> dons: well, first i'll need to add you to the alias so you'll see the requests as they come in
11:47:02 <lilac> Peaker: if you get hint + mueval compiling, let me know :)
11:47:03 <dons> yeah, that'd be great.
11:47:21 <unenough> hey Peaker :)
11:47:23 <Peaker> lilac: I don't know what they are ;)
11:47:40 <ibid> dons: note that the current lag is mostly due to the finnish municipal elections held a week ago, and i'm stariting to recover - expect to see a queue processing in the next couple of days
11:47:46 <lilac> cabal install does :)
11:47:58 <dons> ibid: that's fine, but help can't hurt :)
11:48:07 <dons> less chance for bus error
11:48:23 <ibid> yeah
11:48:50 <lilac> dons: something's changed in newtype deriving in GHC 6.10 that's broken the compilation of lambdabot. bug or feature?
11:49:08 <dons> depends on what 'something' is
11:49:12 <lilac> (the diff i posted above shows the something)
11:50:01 <ibid> dons: remind me, what's your community account?
11:50:17 <dons> 'dons'
11:50:21 <ibid> dons: note that the alias receives the cron mail, which can be numerous on occasion
11:50:27 <dons> sure
11:51:09 <ibid> sent a test mail. did you receive?
11:51:12 <jpcooper> @hoogle Int -> Int
11:51:13 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
11:51:13 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
11:51:13 <lambdabot> Test.QuickCheck configSize :: Config -> Int -> Int
11:51:22 <jpcooper> is there no incrementer function?
11:51:34 <ibid> (+1)
11:51:37 <dons> ibid: not yet... waiting...
11:52:53 <Deewiant> succ
11:54:11 <ibid> dons: you should already have access to the config, it's in /srv/data/planet/config.ini - i'd like you to continue the policy of including the permission documentation in comments (it's missing for some of the early entries)
11:54:37 <ibid> dons: otherwise, the syntax is [rss uri]\nname = tag used in planet
11:55:05 <ibid> dons: of course, there's the problem of mutual exclusion here
11:55:09 <ibid> dons: do you use vi?
11:55:11 <dons> yes.
11:55:21 <ibid> ok, then its locking ought to suffice
11:55:25 <dons> could you send me an email with a summary of what i need to do to clear an item from the queue?
11:55:28 <ibid> try to open the file for editing now?
11:55:30 <dons> so we don't lose it.
11:55:39 <dons> it says "swap file" :)
11:55:46 <dons> Found a swap file by the name "/srv/data/planet/.config.ini.swp"
11:55:53 <ibid> and now?
11:55:57 <dons> all godo.
11:56:05 <ibid> ok, so the locking works
11:56:09 <dons> nice.
11:56:15 <ibid> swap file indicates someone else has it open
11:56:17 <dons> yes.
11:56:29 <ibid> did you receive the test yet?
11:56:30 <dons> ok. so i just add entries using the existing ones as a guide?
11:56:37 <dons> no.
11:56:45 <dons> you might need to make it my real email address?
11:56:59 <ibid> or perhaps it's just waiting for greylisting
11:57:20 <ibid> it hasn't bounced yet
12:03:26 <mofmog1> hmm, emacs modes seems to have this annoying thing where if i type
12:03:36 <mofmog1> (Empty) and then i press tab, itll move over (Empty) along with it
12:04:04 <mofmog1> ok this smart indent isn't so smart after all
12:04:05 <byorgey> that's a feature.  Hitting 'tab' anywhere on a line indents that line.
12:04:10 <olsner> yeah, 'tab' usually means 'indent this line to its proper indent' in emacs, I think
12:04:14 <byorgey> why do you want to insert a tab in the middle of a line?
12:04:33 <Baughn> Then you press C-q tab
12:04:38 <Baughn> You almost never want to do that, though
12:04:43 <byorgey> if you want to align subsidiary parts of lines, you can use align-regexp
12:04:55 <Baughn> (And makefile-mode does treat tab literally)
12:05:00 <byorgey> M-x align-regexp =  , for example, aligns everything after = signs
12:05:13 <byorgey> there's also a keybinding in haskell-mode to do such alignment for you
12:05:26 <Baughn> There is? I thought that was undecidable
12:06:18 <mofmog1> so
12:06:24 <mofmog1> if i wanna align things
12:06:35 <mofmog1> i just type it out and let it align itself?
12:06:38 <byorgey> C-c C-.		haskell-indent-align-guards-and-rhs
12:06:58 <ibid> dons: hm, do you have a forward from your account?
12:07:05 <dons> ah ...
12:07:14 <dons> heh
12:07:20 <byorgey> you type it out, then select the region you want to align and align it using C-c C-.,  or M-x align-regexp
12:07:24 <dons> got it :)
12:07:43 <dons> ibid: ok. all good.
12:11:43 <mopped> Say I have a function for example, f x c = x + c, and I want the result of that function to be fed back into f with keeping c constant, how can I manipulate iterate to do this? ;P
12:12:07 <Philonous> :t flip
12:12:08 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:12:13 <mauke> (\x -> f x c)
12:12:20 <Philonous> > flip f a b
12:12:21 <lambdabot>   Add a type signature
12:12:31 <Philonous> > flip f a b :: Expression
12:12:32 <lambdabot>       Not in scope: type constructor or class `Expression'
12:12:41 <Baughn> iterate (flip f c) x
12:12:44 <byorgey> try Expr
12:12:48 <Philonous> > flip f a b :: Expr
12:12:50 <lambdabot>   f b a
12:12:55 <Philonous> thx byorgey
12:13:57 <mopped> take 5 $ iterate (flip (\x c -> x + c) 5) 2
12:13:59 <mopped> > take 5 $ iterate (flip (\x c -> x + c) 5) 2
12:14:01 <lambdabot>   [2,7,12,17,22]
12:14:04 <mopped> thanks
12:14:23 <mauke> (+) may not be the best function to test flip
12:14:47 <osfameron> heh
12:15:15 <byorgey> > take 5 $ iterate (+5) 2
12:15:18 <lambdabot>   [2,7,12,17,22]
12:16:02 <ibid> dons: procedure email sent
12:16:31 <Peaker> lispy: btw: /usr/bin/ld: cannot find -lHSrts_thr  -- that's not because of the patch not applied fully, right? (It had a problem applying, that I didn't look into)
12:17:18 <mopped> Say I have [x | x <- [1..100], x < 20], will x still iterate from 20 to 100 or is the code 'smart' and know not to evalute (or is there a way I can make it 'break' the comprehension upon failing a guard)
12:17:43 <rwbarton> use takeWhile
12:22:32 <Botje> mopped: ghc is not smart enough (yet) to see that.
12:23:02 <Deewiant> Botje: you sure? for that simple a case, I think it might
12:23:16 <Deewiant> GCC would, I think
12:24:08 <Dover> i donwloaded ghc
12:24:18 <Dover> and try execute my programa with runhugs but
12:24:21 <Dover> runhugs: can't find "Main" module
12:24:21 <Peaker> how come I have /usr/local/lib/ghc-6.10.0.20081007/HSrts.o  but not the _thr one?
12:24:29 <lispy> Peaker: what is the context of -lHSrts_thr ?
12:24:37 <Peaker> lispy: Linking dist/build/lambdabot/lambdabot ...
12:24:40 <roconnor> > takeWhile (< 20) [1..100]
12:24:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
12:24:51 <lispy> Peaker: I don't know anything about lambdabot builds, sorry
12:24:53 <Peaker> lispy: Seems like my ghc install came with the Haskell Runtime System lib, but not the threaded one
12:25:08 <Peaker> I think I installed from a ghc 6.10 snapshot
12:25:24 <Peaker> ghc-6.10.0.20081007
12:25:42 <lispy> Peaker: I suspect you mean to be chatting with someone else here besides me :)
12:26:15 <Peaker> good thing its not a query window, then ;-)
12:28:20 <Botje> Deewiant: hmm
12:28:24 <Botje> i'm looking at the core output
12:28:46 <Deewiant> isn't the code optimized still at the asm level?
12:28:46 <Botje> if i understand it correctly, it doesn't
12:28:49 <Botje> even with -O2
12:28:51 <Peaker> lambdabot code is using unqualified imports everywhere, ahhh! :(
12:30:01 <Cale> Peaker: is that a problem?
12:30:07 <vixey> :t snerp
12:30:08 <lambdabot> forall a. Int -> [a] -> [a]
12:30:15 <Peaker> Cale: I can't find where any symbol is coming from
12:30:23 <Cale> Which symbol?
12:30:24 <Botje> heh
12:30:27 <Cale> ghci can tell you
12:30:31 <Botje> there's a symbol called "errorBelch"
12:30:33 <Cale> :info <symbol>
12:30:34 <Peaker> Cale: Example code:   ios  = list . io   -- I can't find "io"
12:30:39 <Peaker> Cale: I don't know what to import
12:30:41 <Cale> ah, io = liftIO
12:30:51 <Peaker> Cale: how can I know that?
12:31:02 <vixey> Cale tells you it
12:31:19 <Peaker> Cale: With qualified imports or explicit name imports, its right there...
12:31:47 <mathijs> Hi all, I'm following a tutorial (http://www.lisperati.com/haskell/), for clarity's sake they put a let-construct in main, but mention it's cleaner to define outside of main. see page 2 (http://www.lisperati.com/haskell/ht2.html). I would like to know how to do that, but this 'people' function seems to have some kind of 'closure' because it needs to access people_text.
12:32:05 * Cale looks
12:32:26 <Peaker> Is lambdabot's Plugin.hs auto-generated?  why does it have  import Codec.Binary.UTF8.String   and   import Language.Haskell.TH    repeated 3 times?
12:32:31 <vixey> mathijs, that tutorial is bad
12:32:42 <Cale> oh, it's reasonable for people to be defined in the do-block
12:32:51 <mathijs> vixey: I shouldn't use it?
12:33:00 <vixey> I would recommend that you don't
12:33:15 <Cale> If it was something more complicated, you could separate it out into a function, but that function already has a name: read
12:33:54 <mathijs> vixey: I worked through 'Programming Haskell by Graham Hutton' and 'yaht', they are very good, but I would like some more real-life examples
12:34:12 <Botje> Deewiant: the generated C code is .. unclear :)
12:35:04 <Deewiant> Botje: run it through gcc -O3 and take a look at the asm :-P
12:35:21 <Botje> i tried that
12:35:21 <mathijs> vixey: most tutorials/info are very academical and theoretical, I'm looking for tutorials that are more lightweight and fun. Do you know any?
12:35:27 <Botje> had to turn it off quickly :p
12:35:28 <Cale> mathijs: Did you know that Real World Haskell is available online?
12:35:37 <mathijs> Cale: nope?
12:35:39 <Botje> mathijs: there's BONUS_' tutorial
12:35:49 <Botje> "learn you a haskell"
12:35:49 <Cale> http://book.realworldhaskell.org/read/
12:35:54 <lambdabot> Title: Real World Haskell
12:36:07 <Cale> That seems like it would satisfy your craving for practical stuff :)
12:36:29 <mathijs> Cale: cool, thanks very much
12:36:41 <Cale> BONUS' tutorial is indeed very lighthearted and fun :)
12:36:50 <Cale> @where LYAH
12:36:50 <lambdabot> www.learnyouahaskell.com
12:36:55 <Cale> it's there :)
12:38:35 <mathijs> Botje, Cale, thanks, this will get me started. All this stuff about parsers and mathematical problems makes me fear I'll never grasp haskell :)
12:38:47 <Botje> mathijs: you say that _now_
12:38:53 <mofmog1> no one understands haskell
12:38:54 <mofmog1> it is
12:39:08 <Botje> in a week you'll be lifting monads like the best of them :)
12:39:31 <Cale> A week, hehe...
12:39:43 <mofmog1> A week * 104
12:39:44 <mathijs> hehe hope so :)
12:39:58 <Cale> I think it took me two months before I started to feel like I could actually use Haskell.
12:39:59 <mathijs> week.repeat
12:40:06 <Cale> and about a year before I was really comfortable
12:40:30 <mathijs> Cale: and what language was your 'main' one before?
12:40:56 <mofmog1> so i've been working with learning about how to optimize haskell code from the actual haskell code perspective
12:41:08 <Cale> mathijs: Well, I knew a whole bunch of imperative languages mostly, and a bit of scheme.
12:41:19 <mofmog1> and so i started with quicksort but it's too fast
12:41:19 <mopped> mandelSet size t = [[z, z, z] | i <- [1..t], j <- [1..t], z <- (256 - (orbit (((i*size)/t), ((j*size)/t)) 256))], can anyone tell me why this compiles, but doesn't work when putting values for size/t in? :S
12:41:33 <Botje> Deewiant: anyway, i have to make some more slides. if you find proof that ghc somehow stops prematurely, would you tell me? :)
12:41:45 <Botje> define "doesn't work"
12:41:53 <Botje> also check the type.
12:41:59 <Cale> :t let mandelSet size t = [[z, z, z] | i <- [1..t], j <- [1..t], z <- (256 - (orbit (((i*size)/t), ((j*size)/t)) 256))] in mandelSet
12:42:00 <lambdabot> Not in scope: `orbit'
12:42:05 <Cale> oh, right...
12:42:13 <Botje> chances are it's something like (Integral a, Rational a) => ...
12:42:22 <mopped> orbit returns an integer
12:42:32 <mopped> mandel z c = ((fst z)^2 - (snd z)^2 + (fst c), 2*(fst z)*(snd z) + (snd c))
12:42:32 <mopped> orbit c l  = orbit' c (0.0, 0.0) l 0
12:42:32 <mopped>     where    orbit' c z l n | (fst z)^2 + (snd z)^2 > 4 = n
12:42:32 <mopped>                             | l == n    = l
12:42:33 <mathijs> I've been using Ruby professionally for 3 years, it's very different to haskell but has some functional constructs which got me interrested in 'real' functional languages.
12:42:33 <mopped>                             | otherwise = orbit' c (mandel z c) l (n + 1)
12:42:36 <mopped> wow, sorry for the spam
12:42:39 <mopped> (and the bad code)
12:42:45 <Botje> mopped: put it on hpaste already :)
12:42:50 <mopped> yeah, i am
12:42:53 <mopped> accidental paste
12:43:23 <mopped> http://hpaste.org/11709
12:43:29 <Cale> mopped: btw, there's an actual Complex datatype.
12:43:44 <Cale> (so you wouldn't have to use pairs)
12:44:51 <mopped> wouldnt I still access them the same way?
12:45:23 <vixey> I'd do like
12:45:35 <vixey> :t \c -> iterate (\z -> z*z + c)
12:45:36 <lambdabot> forall a. (Num a) => a -> a -> [a]
12:45:48 <vixey> or nTimes instead of iterate
12:46:11 <Cale> mopped: Well, you wouldn't have to hand-expand the definition of complex multiplication everywhere :)
12:46:17 <mopped> well, I wanted to stop when x^2 + y^2 > 4, and not carry on iterating
12:46:30 <vixey> mopped, you probably know that may never happen
12:46:44 <vixey> mopped, oh and FWIW mandelbrot set isn't computable :p
12:46:51 <mopped> sure, itll also stop at the limit!
12:47:00 <mopped> eh? I thought it made a pretty picture...
12:47:45 <vixey> the approximations are nice, but in comparison to the real thing..?
12:47:47 <Cale> :t \c -> takeWhile ((< 4) . magnitude) $ iterate (\z -> z*z + c) 0
12:47:48 <lambdabot> forall a. (RealFloat a) => Complex a -> [Complex a]
12:48:04 <mopped> It was more of me to test image creation, so two birds and one stone
12:48:10 <Cale> hehe
12:48:21 <Cale> vixey: Don't be a troll :P
12:49:12 <Philonous> The real thing? You can't even display the natrual numbers, let alone a real plane or the mandelbrot set :P
12:49:19 <mopped> is the list comprehension correct? it looks quite bad, but i think thats the only way to loop through the coordinates of an image
12:49:39 <unenough> is there anything like python's random.choice for haskell?
12:49:46 <unenough> i want to randomly select an element from a list
12:49:53 <Peaker> @hoogle Random
12:49:54 <lambdabot> module System.Random
12:49:54 <lambdabot> System.Random class Random a
12:49:54 <lambdabot> package random
12:50:08 <Cale> unenough: It's been written a lot of times, but it's not in the libraries.
12:50:14 <Peaker> @hoogle Random a => a -> [b] -> b
12:50:14 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
12:50:14 <lambdabot> Control.Parallel par :: a -> b -> b
12:50:14 <lambdabot> Control.Parallel pseq :: a -> b -> b
12:50:41 <Cale> unenough: You can use one of the functions to get a random number along with !!
12:50:47 <Baughn> @src pseq
12:50:48 <lambdabot> Source not found.
12:50:58 <Cale> If you need a lot of random selections though, I'd recommend making the list into an array first though.
12:51:19 <Cale> er, minus superfluous 'though'
12:51:20 <Cale> hehe
12:52:13 <Baughn> Cale: That's both of 'em
12:52:27 <Cale> Baughn: could be :)
12:52:59 <Baughn> Does the existence of a 10.1 package mean that ghc 10.1 is in fact out?
12:53:18 <tromp__> @oeis 1,2,14,134
12:53:23 <lambdabot>  a(n) = number of lattice paths (Schroeder paths) from (0,0) to (3n,n) with u...
12:53:23 <lambdabot>  [1,2,14,134,1482,17818,226214,2984206,40503890,561957362,7934063678,11362269...
12:53:46 <mopped> > [z | x <- [1..5], y <- [1..5], z <- x * y]
12:53:48 <lambdabot>       No instance for (Enum [t])
12:53:48 <lambdabot>        arising from the arithmetic sequence ...
12:54:04 <olsner> "silent releases: another success story on avoiding success"?
12:54:05 <mopped> > [x*y | x <- [1..5], y <- [1..5]]
12:54:06 <lambdabot>   [1,2,3,4,5,2,4,6,8,10,3,6,9,12,15,4,8,12,16,20,5,10,15,20,25]
12:54:08 <mopped> woops
12:54:17 <Baughn> Oh, and are there any cases where you'd want to use seq instead of pseq?
12:54:49 <Baughn> olsner: Well, it's gotten uploaded, but not to the right directory, so.. *shrug*
12:54:54 <Baughn> They're obviously getting ready, at least
12:55:34 <mopped> > [replicate 3 (x*y) | x <- [1..5], y <- [1..5]]
12:55:36 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3],[4,4,4],[5,5,5],[2,2,2],[4,4,4],[6,6,6],[8,8,8],[1...
12:59:50 <Peaker> where does "insult" come from (Lambdabot's code)
13:00:38 <Baughn> Peaker: Various places
13:00:44 <Baughn> Most of the actual text is in State/
13:00:49 <vixey> @insult
13:00:49 <lambdabot> Unknown command, try @list
13:00:56 <Baughn> @src rutabaga
13:00:57 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:01:08 <Baughn> @src rutabaga
13:01:08 <lambdabot> Source not found.
13:01:09 <Baughn> @src rutabaga
13:01:09 <lambdabot> Source not found. My pet ferret can type better than you!
13:01:14 <Baughn> ..etc
13:01:26 <Baughn> Peaker: Of course, a grep would have told you that
13:01:57 <Peaker> Baughn: I grepped lambdabot's code, its not there (it seems)
13:02:18 <Peaker> Baughn: I hate unqualified imports, they should be banned :-(
13:03:02 <Peaker> IMO: Saving the code reader time is far more important than saving the code writer time.. Unqualified imports do exactly the opposite
13:03:05 <Baughn> ./lambdabot-utils/Lambdabot/Util.hs:    "Have you considered trying to match wits with a rutabaga?",
13:03:14 <Baughn> Peaker: Grep better. :P
13:03:52 <Peaker> aha, its in utils. That requires a grep within .tar.gz's
13:03:53 <Baughn> Peaker: And I disagree. Oh, it's certainly warning-worthy, but my usual style is to use unqualified imports while developing a module, and then qualify them once I'm relatively sure it's done for now
13:04:07 <Peaker> Baughn: why? its so much easier to qualify them in the first place than retroactively
13:04:20 <Baughn> Peaker: Oh, wait, *qualification*..
13:04:36 <Baughn> Peaker: Eh. I may be biased, but as the code writer, I enjoy not having to qualify everything.
13:04:51 <Peaker> Baughn: we are all readers much more of the time than we are writers
13:05:00 <Baughn> Peaker: Emacs tells me where a symbol comes from on mouse-over anyway
13:05:10 <Peaker> Baughn: even for symbols from hackage packages?
13:05:28 <Baughn> Peaker: Working on that one
13:05:59 <Baughn> Peaker: It should be able to get it from the list of imports, however. And perhaps interrogating the packages via ghci :browse
13:06:20 <Baughn> I'd much rather have a smart editor than B&D programming
13:06:29 <Peaker> Baughn: I guess the use of dot for namespace getting makes people shy away from fully qualified names, which is a shame
13:06:33 <Peaker> Haskell needs a syntax face-lift
13:06:57 <tromp__> @oeis 1,2,14,130
13:06:57 * cjb votes for real lambdas
13:06:57 <lambdabot>  Sequence not found.
13:07:24 <cjb> hm, a better way of doing infix would be good too
13:07:27 <Baughn> Peaker: Not for me. Emacs gives me a small circle instead of a dot when it's actually the composition function
13:07:51 <Baughn> ..well, at least it does with sufficient spaces around it. We *need* better syntax support in the editor, it's true
13:08:12 <Baughn> cjb: You can have real lambdas now, though. :P
13:08:18 <Baughn> At least they'll /look/ like real lambdas
13:08:19 <cjb> Baughn: in emacs?  yeah, I do
13:08:27 <cjb> still, everyone should get them :)
13:08:33 <vixey> how do you make emacs write the compose symbol?
13:08:38 <vixey> I want that
13:08:41 <Baughn> vixey: .
13:08:49 <cjb> vixey: (setq haskell-font-lock-symbols 'unicode)
13:08:55 <Baughn> vixey: It doesn't actually change the underlying text any, just how they look
13:08:57 <vixey> oh I probably have to install a haskell-mode
13:09:01 <cjb> right
13:09:04 <Baughn> ..yeah, that'd be good
13:09:17 <vixey> there's at least 3 isn't there?
13:09:19 <vixey> which one do you use
13:09:32 <Baughn> cjb: Incidentally, setting it to t works fine
13:09:33 <cjb> Stefan Monnier's, the main haskell-mode.el
13:09:36 <cjb> ah
13:09:50 <Baughn> vixey: There's only really one, but you want the newest cvs version
13:10:01 <Peaker> Baughn: well, if we're going into what we *really* need, we really need to dispose of the textual encoding and edit abstract syntax directly
13:10:05 <cjb> could we have some kind of "flip ($)" operator?
13:10:15 <Botje> like >>>?
13:10:15 <vixey> Peaker: what we need is less talk more code :)
13:10:29 <Peaker> vixey: :)
13:10:30 <Botje> hmm, wait
13:10:31 <Baughn> Peaker: The textual encoding is fine. We just need to have the editor parse it and then edit an AST instead of the text
13:10:32 <Botje> that's flip (.)
13:10:48 <vixey> . and ($) are basically the same thing
13:10:54 <Baughn> Peaker: Then we can have backwards-compatibility /and/ nice editors. ;)
13:10:55 <vixey> > (+1) . (*2) $ 7
13:10:56 <Peaker> Baughn: that's a very difficult problem, almost impossible to get right.. and when it is close to right, its usually very slow/sluggish
13:10:56 <lambdabot>   15
13:11:01 <vixey> > ((+1) . (*2) . const 7) ()
13:11:02 <lambdabot>   15
13:11:15 <Peaker> Baughn: look at how much elisp is required to implement trivial features
13:11:55 <Baughn> Peaker: Disallow saving illegal haskell syntax, add a couple leaves to the syntax to signify missing code..
13:12:02 <vixey> Peaker: emacs sucks...
13:12:04 <Peaker> Baughn: why do you need textual-syntax backwards compatibility, when you have abstract-syntax compatibility instead?
13:12:15 <Peaker> vixey: what text editor doesn't suck?
13:12:31 <LarstiQ> ed!
13:12:33 <Baughn> Peaker: So we can import existing code, and work with other people who don't use our single splendid little editor
13:12:34 <vixey> Peaker: I think you have a great idea, I would like to try it out but afaict you are not actively implementing your idea
13:12:49 <yitz> Peaker: teco
13:13:04 <Baughn> Peaker: If we don't plan for an upgrade path, people won't upgrade
13:13:24 <Baughn> Peaker: Oh, you could have a more robust legacy-free form *too*, but the textual parser is a must
13:13:32 <Peaker> vixey: I have very little time to work on it, and I'm relatively new and as of yet unproductive in Haskell.. I want to use FRP for my editor, but I find it pretty difficult, with so little examples of working FRP code (Reactive style) out there
13:13:59 <vixey> Peaker: Produce the example of FRP
13:14:31 <vixey> Peaker: I'm serious, there is no signification obstical if you want to do this you can definitely do it
13:14:41 <vixey> significant*
13:14:48 <mopped> Cale: sorry, but in your example - where did you express that a number was complex
13:14:56 <mopped> how did it know it was!
13:15:02 <Cale> mopped: magnitude
13:15:07 <vixey> mopped, use :t to check the types of functions
13:15:34 <mopped> How can I declare a pair as complex, just (0.1, 0.2) :: Complex?
13:15:41 <mopped> (and what module is that..)
13:15:43 <vixey> @src Complex
13:15:43 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
13:15:50 <mauke> > 0.1 :+ 0.2
13:15:50 <vixey> :t 0.1 :+ 0.2
13:15:52 <lambdabot>   0.1 :+ 0.2
13:15:52 <lambdabot> forall t. (RealFloat t) => Complex t
13:15:58 <mauke> @index Complex
13:15:58 <lambdabot> Data.Complex
13:16:02 <vixey> see you can find all this out automatically
13:16:36 * Baughn ponders proposing a haskell editor for an MSc.. hmmph, add that to the list
13:16:50 <vixey> why stop at haskell?
13:17:13 <Baughn> Point
13:17:14 <vixey> why does haskell.org use cvs
13:17:15 <therp> actually I'm offended by religious content on planet.haskell.org.
13:18:08 <shepheb> therp: such things have been said many times. Planet Haskell aggregates not Haskell blog posts but blog posts by Haskell people.
13:18:11 <therp> I'm ok with off-topic other stuff, but I don't want to read about "God"
13:18:12 <Baughn> Peaker: http://dream.inf.ed.ac.uk/projects/anastasia/ <-- Have you looked at this?
13:18:13 <lambdabot> Title: Anastasia - A Structural Editor for Functional Programming Languages
13:18:38 <vixey> therp, that's kind of weird yeah, dunno why that is on planet.haskell..
13:18:38 <Baughn> Mythology is interesting, but how does that end up on a technology list?
13:18:40 <Baughn> *blog
13:19:16 <therp> shepheb: yeah. probably this policy should be changed.
13:19:28 <vixey> therp, send a email to whoever runs it?
13:19:34 <idnar> or just start a new planet
13:19:42 <Peaker> Baughn: Haven't looked yet, bookmarked
13:19:44 <sjanssen> therp: it is not hard to skip to the next post in the list
13:19:49 <byorgey> Or just skip posts you don't want to read.
13:19:59 <shepheb> I basically ignore Joel Reymont these days
13:20:10 <sjanssen> shepheb: I think he is off planet.h.o now
13:20:20 <byorgey> I explicitly enjoy reading non-Haskell posts by Haskell people.
13:20:24 <vixey> I installed a gui interface for CVS :/
13:20:32 <vixey> this is harder to use than command line CVS
13:20:40 <mauke> heh, is mjd a Haskell person now?
13:20:52 <byorgey> mauke: indeed. =)
13:20:59 <therp> sjanssen: doesn't help when I'm deeply offended by religious stuff.
13:21:03 <shepheb> he posts things about Haskell. we'd all be subscribed to his blog if he wasn't on PH anyway
13:21:15 <vixey> therp, so................. send a email to whoever runs it?
13:21:24 <vixey> being offended doesn't make things change
13:21:35 <byorgey> therp: what is offensive about it?
13:21:37 <mauke> therp: use a greasmonkey script to autohide posts containing "god"
13:21:42 <therp> vixey: that would practically mean to kick someone from p.h.o.
13:22:03 <vixey> therp, I'm saying send an email to whoever runs planet haskell, not kick someone from pho......
13:22:10 <vixey> I guess I'm not getting through
13:22:47 <idnar> The subscriber you have dialled is not available at present; please try again later.
13:22:55 <therp> vixey: what else should he do? should he filter posts? probably he could only subscribe to a haskell-specific category of CosmicRay's blog
13:23:24 <vixey> therp, I don't have a clue, ...  Just trying to be helpful, if you don't let people in change know they don't know
13:23:56 <vixey> in charge*
13:24:20 <therp> byorgey: I find religious thinking offensive, not to say plain unacceptable. http://fora.tv/2005/12/09/View_From_End_Of_World
13:25:01 <shepheb> therp: that falls pretty firmly into the category of "your problem"
13:25:08 <therp> this is btw a really great talk on fora.tv
13:25:14 <jsn> it might be fair and reasonable to ask the offender to get two blogs
13:25:17 <therp> shepheb: oh really?
13:25:44 <jsn> because hey, what if someone on planet haskell likes to post jailbait?
13:25:47 <byorgey> therp: you are welcome to that opinion, but it doesn't mean people should be banned from expressing such views in public fora.
13:26:04 <shepheb> or rather "the problem of a small subgroup of p.h.o readers whose intersection with currently active #haskellers is the set containing you."
13:27:13 <therp> shepheb: do you have any data to call this p.h.o subscribe's subgroup small?
13:27:51 <jsn> everyone raise their hands who has a problem with this
13:27:58 * therp *
13:28:04 * vixey wishes they wouldn't talk about it here :P
13:28:07 <shepheb> that everyone who has commented one way or the other in #haskell right now has said they don't mind.
13:28:13 <jsn> the channel has spoken
13:28:26 * vixey thinks the best way to deal with it is not sitting arond being offended but emailing the people that run the thing
13:28:46 <shepheb> there are several solutions that will stop you from seeing it without changing things for the apparently happy majority.
13:28:48 <therp> vixey: I would rather like an estimate whether this is just my opinion.
13:28:57 <vixey> therp, it's pretty much just you
13:29:45 <Apocalisp> therp: Consider yourself lucky. The Java blogs, for example, contain pretty much nothing other than religion.
13:29:45 <byorgey> I could see the utility--especially now that the community has grown much larger than when p.h.o started--in splitting p.h.o into two feeds, one with purely technical content and one more general
13:29:49 <therp> shepheb: please, unless you have some kind of opinion poll run directly on p.h.o, don't use phrases like "happy majority" or "problem of small subgroup".
13:30:17 <byorgey> but that would require everyone putting tags on their posts or something, because you can't just split certain people's blogs into one and certain ones into the other
13:30:26 <therp> everyone raise their hand who likes to see religious stuff on p.h.o.
13:30:38 * byorgey *
13:30:42 <jsn> heh
13:30:56 <vixey> therp, have you noticed this is going nowhere though?
13:30:58 <Apocalisp> therp: OK, what do you want me to do about it? What is the very next action required, and who is going to do it?
13:31:15 <shepheb> I enjoyed that post. I have no problem reading a thinking man's views on religion.
13:31:34 * sebaseba_ thinks this conversation should move elsewhere
13:31:52 <vixey> sebaseba, like email between therp and those that run planet haskell?
13:32:04 <jsn> like #haskell-blah
13:32:06 <therp> Apocalisp: create a separate category for Haskell related stuff and only aggregate that?
13:32:07 <vixey> that's the only constructive place I can imagine ...
13:32:15 <byorgey> no, like #haskell-blah or a thread on haskell-cafe
13:32:25 <mauke> so ... vim > php, right?
13:32:35 <jsn> i am going to go talk about it there, now
13:32:44 <sebaseba_> vixey: #haskell-blah is indeed what I had in mind
13:32:45 <jsn> mauke: yeah, vim is way better than PHP
13:32:52 <mauke> excellent
13:33:01 <Apocalisp> therp: You do it. Stop being a little girl about it and quit your whining.
13:33:09 <jsn> mauke: have you seen it's text processing capacities?
13:33:13 <therp> oh wow.
13:33:15 <jsn> mauke: it's like the new sed
13:33:21 <sjanssen> mauke: Couldn't match expected type `ProgrammingLangague' against inferred type `TextEditor'
13:33:22 <byorgey> Apocalisp: that's really not necessary.
13:33:32 <vixey> Apocalisp; (not really a good insult)
13:33:38 <mauke> sjanssen: since when is php a TextEditor?
13:33:50 <lament> > "vim" > "php"
13:33:51 <lambdabot>   True
13:33:57 <lament> QED
13:34:01 <vixey> > "php" > "haskell"
13:34:02 <lambdabot>   True
13:34:03 <jsn> Apocalisp: we do not know that therp is a little girl
13:34:22 <jsn> Apocalisp: everyone said that already so i'll lay off
13:34:23 <sjanssen> mauke: did I turn the order of the types around?  I just quickly wrote what I saw in ghci :)
13:34:31 <therp> this is actually the first time #haskell feels somewhat stupid. we don't have any on-topic discussion going on and everyone seems to be eager to get this discussion to die. men, we have seen tuomav lately here rambling for about an hour, and this channel can even get together on a constructive discussion how to handle off-topic content on the main aggregation site for our community? is it really that bad? please. I don't think so.
13:34:48 <jsn> therp: i am in #haskell-blah talking about it now
13:34:48 <mauke> sjanssen: well, php surely is no programming language!
13:34:55 <sjanssen> mauke: hmm, yes GHC reads from left to right
13:35:11 <sjanssen> mauke: ha, I get your joke now
13:35:13 * sjanssen is slow
13:35:13 <Apocalisp> therp: No, it's just that only you can help you here. Sorry about that.
13:35:14 <jsn> therp: please go there
13:35:14 <therp> jsn: thanks for the offer, but I rather let it die.
13:35:17 <vixey> therp, I thought it was pointless to discuss it here instead of with the people that run planet haskell
13:35:25 <sjanssen> therp: tuomov was banned
13:35:27 <jsn> therp: well i already said stuff in that channel
13:35:36 <shepheb> therp: you have had a half-dozen possible avenues for dealing with this, and not one of them is continuing to complain here.
13:35:37 <vixey> therp, (apparently that's not true though)
13:35:43 <lament> PHP = Preprocesseur Hypertexte PHP
13:35:44 <jsn> therp: you are ignoring your brother in the lord!
13:35:45 <shepheb> +suggested
13:35:54 <mauke> omg tail recursion
13:36:13 <vixey> jsn, that seems kind of rue
13:36:14 <vixey> jsn, that seems kind of rude
13:36:25 <jsn> vixey: eh?
13:36:54 <jsn> GHC should really be GGHC
13:38:48 <lament> GGHCC?
13:38:54 <dons> ibid: thanks for those details. and we'll see the original emails arrive on that mailing list?
13:39:15 <jsn> well, any more, it's the Glorious Cambridge Haskell Compiler
13:39:16 <Baughn> lament: GNU Glasgow Haskell Compiler Collection?
13:39:34 <jsn> Glorious Glasgow...
13:39:50 <IsoPallo_> GGGHCC
13:40:12 <Baughn> Glorious GNU Glasgow Haskell Compiler Collection, then
13:40:18 <lament> GGGHCC Glorious Glasgow Haskell Compiler Collection
13:40:28 <lament> gotta make it recursive
13:40:31 <StoneToad> is there a way to get some kind of id for a function in haskell? something like a function pointer address...
13:40:41 <lament> StoneToad: its name
13:40:52 <dons> :t id
13:40:54 <lambdabot> forall a. a -> a
13:40:57 <Baughn> StoneToad: Not reasonably, and you're an evil, horrible person for asking. Why do you want to? ;)
13:41:01 <dons> StoneToad: but what do you want to do?
13:41:24 <dons> this is a high level language, we don't take the address of objects most than once every 4 years.
13:41:32 <StoneToad> cause currently I have an instance that declares all functions functions to be equal to eachother
13:41:38 <lament> dons: unless they look suspicious?
13:41:49 <dons> StoneToad: what are you doing!?
13:41:54 <dons> Eq (a -> a) ?
13:41:59 <StoneToad> yea
13:42:02 <dons> heh
13:42:07 <dons> good luck. :)
13:42:07 <lament> StoneToad: why?
13:42:14 <StoneToad> primitives in an interpereter
13:42:14 <lament> StoneToad: what are you actually trying to do?
13:42:29 <bd_> StoneToad: It should be noted that objects change address in haskell /all the time/
13:42:31 <dons> ah, writing an interpreter.
13:42:36 <lament> primitives in an probably shouldn't be haskell functions
13:42:39 <dons> and you want a notion of equality on functions?
13:42:40 <bd_> quite possibly in the middle of executing (==)
13:42:40 <lament> *in an interpreter
13:42:51 <lament> perhaps you want Eq Primitive?
13:43:00 <StoneToad> lament: why not? it makes it really easy to add new ones as I go along...
13:43:09 <bd_> as such, even if you get the addresses of two values and compare it, the result is completely useless
13:43:15 <lament> StoneToad: because one day, it will all go horribly wrong :)
13:43:23 <Baughn> "type Primitive = (Int, a -> a)" or some such might do well enough. Add something you /can/ compare..
13:43:30 <bd_> Baughn: Data.Unique perhaps
13:43:35 <bd_> Or String
13:43:37 <StoneToad> ah that's a good idea
13:43:49 <Baughn> Oh yeah. Data.Unique is good
13:44:10 <lament> there's a lot of reasons for not mixing the types in your language with the types in haskell
13:44:36 <StoneToad> lament: I have a type in my language of "native haskell code"
13:44:42 <StoneToad> there's no mixing involved :)
13:45:01 <Baughn> StoneToad: Or you might encode the textual (or AST) representation of the function instead of the Int/Unique, thus letting you print it out again at need too. Or its source location, assuming you never load two different functions from the same location (eg. over time). Or something.
13:45:10 <StoneToad> it's much cleaner then the previous version (in perl) where said type was a string of perl code that got eval'ed
13:45:27 <mauke> haha, oh wow
13:45:34 <StoneToad> Baughn: those are both a bit more advanced then anythign I know how to do in haskell
13:45:35 <mauke> perl has function pointers, you know
13:45:50 <StoneToad> mauke: I know, I wrapped the string in sub {} before eval and cached it
13:46:10 <StoneToad> generating unique ids is dead easy in single threaded imperitive programing
13:46:12 <lament> StoneToad: what do these primitives operate upon?
13:46:14 <Baughn> StoneToad: Well, basically the thing you'd compare for equality can be something (anything) that lets you reconstruct the function somehow. By reading it, evaluating that thing, or whatever..
13:46:28 <Baughn> StoneToad: The fully qualified name of the function, say
13:46:43 <Baughn> StoneToad: It could also just be an unique identifier, but the other way is probably more useful. ;)
13:47:05 <lament> you want the primitives to have user-friendly names anyway
13:47:07 <StoneToad> Baughn: there's a way to call a function based on a name that's visible to the code calling the function?
13:47:08 <lament> for debugging and error messages
13:47:23 <vixey> so I found a fun book
13:47:27 <Baughn> StoneToad: Of course there is. You're writing it - your interpreter.
13:47:38 <vixey> Higher Order Operational Techniques in Semantics
13:47:42 <Baughn> StoneToad: Well, there's also the GHC API, but I don't think you want to go there. ;)
13:47:51 <dons> StoneToad: do you have example interpreters in haskell to look at?
13:47:56 <vixey> It's all operational semantics stuff, which everyone seems to be vehemently against
13:47:57 <StoneToad> Baughn: hehe, yea I don't think I want to either
13:48:05 <vixey> but it's actually really elegant
13:48:09 <lament> StoneToad: seriously, don't mix types :)
13:48:12 <dons> StoneToad: http://haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters#Small_languages
13:48:15 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2dt77g
13:48:16 <dons> some nice examples
13:48:21 <vixey> they have monadic semantics for ML using a comp type
13:48:53 <lament> StoneToad: think about debugging, error messages, potential type extensions with no haskell equivalent - all good reasons to use your own types
13:48:55 <vixey> concurrent ML*
13:49:03 <StoneToad> lament: I guess I don't understand what you're saying about "not mixing types"... I dont think I am...
13:49:12 <lament> StoneToad: what is the type of these primitives?
13:49:38 <lament> these functions you're trying to compare?
13:49:56 <StoneToad> data Core = <snip> | Code (Core -> CoreMonad Core)
13:50:12 <vixey> newtype Comp a = Comp a
13:50:28 <StoneToad> the <snip> is the various other things like lists, variable declaration and referencing etc
13:51:05 <StoneToad> it's very similar to the scheme in 48 hours setup
13:51:58 <StoneToad> vixey: sounds interesting, that's in one of the small language interpereters?
13:52:07 <vixey> StoneToad: which?
13:52:15 <StoneToad> <vixey> they have monadic semantics for ML using a comp type
13:52:23 <vixey> StoneToad: Oh I'm just rambling about a book I read
13:52:48 <lament> StoneToad: these primitives (Core -> CoreMonad Core) must have names in your interpreted language, and somewhere you have a function that dispatches from names to functions
13:52:54 <vixey> StoneToad: I have some code but I don't know if I should put it on that page or what
13:53:11 <lament> StoneToad: but really the name and the function form one object
13:53:14 <vixey> actually I wish someone would put a bit of code I have up on hackage
13:53:47 <lament> StoneToad: when adding a new primitive you already must specify both the name and the function, in different places in your code -- correct?
13:54:16 <vixey> dons, I wrote this unifier (parametrised over data type using a typeclass), wrote some tests.. I think it works fine..
13:54:30 <vixey> afaict there is still no unifier on hackage though
13:55:04 <StoneToad> lament: yes and no, names are fully optional since the language is being written for an ALife simulator
13:55:19 <StoneToad> I think that Data.Unique will do what I want very well though
13:56:50 <litb> hi there
13:56:50 <vixey> dons, what do you think? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62
13:57:13 <vixey> (there is examples too)
13:59:24 <unenough> EnoughSaid, @quit
13:59:38 <vixey> @yow
13:59:38 <lambdabot> Yow!  Did something bad happen or am I in a drive-in movie??
13:59:38 <EnoughSaid2> Couldn't find fortune file
13:59:38 <EnoughSaid2> why do you ask
14:00:00 <mauke> @bot
14:00:01 <EnoughSaid2> :)
14:00:01 <lambdabot> :)
14:00:06 <mauke> :(
14:00:12 <vixey> :)
14:00:17 <unenough> i'm just running a test
14:00:20 <unenough> my first haskell code!
14:00:32 <unenough> a ripped-off plugin
14:00:49 <mauke> two guns
14:00:52 <unenough> when it annoys i'll kill it
14:00:59 <mauke> directed by john woo
14:01:17 <vixey> why?
14:01:17 <EnoughSaid2> I'm not sure
14:01:20 <vixey> ?
14:01:20 <EnoughSaid2> why do you ask
14:01:22 <vixey> ?
14:01:22 <EnoughSaid2> heh, don't ask me
14:01:27 <mauke> wtf?
14:01:27 <EnoughSaid2> dunno, ask lambdabot
14:01:45 <unenough> ok, i'm poised on the quit button :)
14:01:55 <ibid> dons: the original emails?
14:01:55 <EnoughSaid2> I'm not sure
14:01:57 <mauke> so it reacts anytime you say 
14:02:14 <lament>  ?
14:02:14 <EnoughSaid2> yes
14:02:19 <unenough> except when it's swapped out i guess
14:02:21 <lament> mauke: i can't see the character  
14:02:26 <unenough> nope
14:02:27 <lament> nor does it react to that character
14:02:35 <mauke> U+FF1F (ef bc 9f): FULLWIDTH QUESTION MARK []
14:02:42 <dons> ibid: right. so i think we're good to go now.
14:02:53 <lament> yeah, cool
14:02:55 <vixey> dons, it is that bad..? :)
14:02:56 <EnoughSaid2> that's not a valid question
14:02:58 <vixey> oh well.....
14:03:10 <unenough> EnoughSaid2: @quit
14:03:16 <unenough> ok, sorry everybody :)
14:03:25 <ibid> dons: um, what original emails?
14:03:55 <dons> ibid: the user requests to add their blog
14:04:00 <jdrake> If I have a datatype such as: data TeXElement = Command String                 | Text String    what is the best way to implement Show TeXElement?
14:04:12 <vixey> deriving Show
14:04:15 <vixey> jdrake,
14:04:49 <ibid> dons: ah, yes, they'll go there assuming they follow instructions
14:04:51 <jdrake> vixey, I know very little about this. Do I just have deriving Show after it and that is it, or is there something of substance I have to add?
14:05:07 <vixey> that is it
14:05:12 <vixey> data Foo = ...
14:05:14 <ibid> dons: some people still email me directly - i'll try to remember to bounce them to the alias (that shouldn't take time at all)
14:05:15 <vixey>   deriving Show
14:05:42 <dons> ok.
14:06:05 <jdrake> lovely
14:06:36 <vixey> ping dons
14:10:47 <vixey> ....
14:11:59 <dons> just talk!
14:12:01 <dons> i'm always here
14:12:16 <idnar> ping -f dons
14:12:19 <vixey> dons, you said someone shoud write a unifier for hackage, so I have done that
14:12:26 <vixey> what is your thoughts about it?
14:12:59 <eu-prleu-peupeu> hi
14:13:04 <eu-prleu-peupeu> im looking for a job coding in haskell
14:13:14 <eu-prleu-peupeu> im a total noob, btw :P
14:13:24 <dons> ok. so that's a problem.
14:13:43 <dons> and you've a long history of asking silly questions too, so i wouldn't hold my breath ;)
14:13:49 <eu-prleu-peupeu> heheh
14:13:52 <IsoPallo_> I'm total noob too and I found a job coding haskell in less than a month...
14:13:52 <eu-prleu-peupeu> oh that
14:13:59 <eu-prleu-peupeu> thats my CV :)
14:14:38 <eu-prleu-peupeu> what do i need to do, in order to show off my haskell skills ?
14:14:39 <dons> eu-prleu-peupeu: do you have a question, eu-prleu-peupeu ?
14:14:46 <eu-prleu-peupeu> yes
14:14:50 <vixey> nothing
14:14:53 <IsoPallo_> Then again I'm not even doing my job too fast or well so just keep your eyes open for an open position soon :)
14:14:54 <dons> eu-prleu-peupeu: the irc channel isn't a resume site.
14:15:20 <dons> i would suggest you should have developed a major project in the language. do that.
14:15:27 <eu-prleu-peupeu> hmm
14:15:37 <eu-prleu-peupeu> major project, like what ?
14:15:39 <unenough> without bugs
14:15:41 <dons> something about demonstrating competence and professionalism.
14:15:49 <dons> eu-prleu-peupeu: if you have to ask, you don't get the job.
14:15:49 <ketil> I want to FFI to a c-lib as part of my library.  Any good protocol for doing so?  In particular, is cabal up to distributing the c-lib as part of the sdist?
14:15:55 <dons> ketil: yes.
14:15:57 <eu-prleu-peupeu> i see... hmmm
14:16:01 <Samy> IsoPallo_, where?
14:16:08 <dons> ketil: see, e.g. mersenne-random-pure64 (and others) that distribute cbits
14:16:10 <eu-prleu-peupeu> im too busy with my master thesis :/
14:16:18 <ketil> dons: any lib I can ....ah, right, cool.
14:16:20 <eu-prleu-peupeu> which i hope to port to haskell in january...
14:16:21 <vixey> You're doing a masters thesis!??
14:16:22 <vixey> LOL
14:16:27 <eu-prleu-peupeu> yes
14:16:35 <unenough> @girl19
14:16:35 <lambdabot> I have stolen about 50 msn and yahoo accounts
14:16:40 <dons> heh
14:17:36 <ketil> eu-prleu-peupeu, to get a job coding in Haskell, first get a job where you can do whatever you want.
14:17:40 <IsoPallo_> Samy: For a guy that I met in ItaloHaskell.
14:17:44 <ketil> Then want to code in haskell. :-)
14:17:52 <eu-prleu-peupeu> yes, i see
14:18:01 <eu-prleu-peupeu> ill start looking for those
14:18:07 <ketil> (works for me :-)
14:19:50 <bbs> http://rafb.net/p/Bbqg8c81.html
14:19:51 <lambdabot> Title: Nopaste - No description
14:19:55 <profmakx> i got a phd and can code haskell as much as i want!
14:19:59 <bbs> ^^^^^^^i need to define an IR datatype for that
14:20:22 <eu-prleu-peupeu> dons: i believe that deep inside you are a good person
14:20:22 <vixey> bbs, wow lol
14:20:28 <eu-prleu-peupeu> you too vixey
14:20:29 <bbs> vixey: ?
14:20:29 <vixey> bbs, it's like lisp but in the wrong language
14:20:38 <bbs> yea
14:20:41 <bbs> unfortunatley
14:20:46 <bbs> vixey: stupid assignemnt
14:20:48 <vixey> bbs, headof tailof and assoc look realy really dodgy
14:21:00 <bbs> vixey: thats because they are
14:21:02 <ketil> dons: Forgot one thing, is it generally a good idea to do so (distribute clib + haskell lib)?
14:21:05 <monochrom> <3
14:21:07 <vixey> hi monochrom, hi ddarius :))))))))
14:21:11 <unenough> my only conclusion so far from running my annoying ? detector bot in #not-math, is that mathematicians use only statements, not questions.
14:21:17 <bbs>         (While b x) -> if (evaluate b state) then (exec (Prog d (x++[s]++ss)) (state)) else (exec (Prog d ss) (state) )
14:21:22 <bbs> vixey: you mean like that?
14:21:25 <bbs> its ugly as hell
14:21:26 <ddarius> uh, hi vixey
14:22:04 <vixey> bbs, I mean the definitions .. it looks like someone who is writing lisp in haskell syntax
14:22:30 <bbs> i know -- :/
14:22:32 <bbs> crappy
14:22:37 <vixey> also I would replace
14:22:40 <bbs> vixey: i just want a IR datatype to handle stuff
14:22:48 <vixey> evaluate (RelOp "=" aexp1 aexp2) state = if ((execute aexp1 state) == (execute aexp2 state)) then True else False
14:22:49 <vixey> with
14:23:04 <monochrom> Oh, that's dreadful.
14:23:06 <bbs> vixey: ah thats neat
14:23:09 <bbs> execute (IntLit x) state = (I x)
14:23:11 <vixey> evaluate (RelOp (*~*) aexp1 aexp2) state = (execute aexp1 state) *~* (execute aexp2 state)
14:23:29 <vixey> and that kills off all that repititious nonsense
14:23:45 <vixey> using strings here is .. ridiculous
14:23:52 <monochrom> Anyone who writes like "if b then True else False" does not understand boolean logic.
14:24:08 <bbs> *nod*
14:24:09 <unenough> wow
14:24:10 <bbs> my teacher
14:24:17 <unenough> that's like, b
14:24:19 <vixey> maybe they think 'b' is a boolean designator (lol)
14:24:32 <vixey> or whatever is the correct lisp term
14:24:48 <vixey> bbs, I would be a really terrible student in that class
14:24:48 <conal> i'm getting started with linux (ubuntu 8.10).  what's are some simple ways to get a new ghc (6.11) installed?
14:25:01 <bbs> vixey: i still want to know how to wrap integers and reals into a data type
14:25:06 <bbs> :/
14:25:10 <vixey> 'wrap'?
14:25:13 <monochrom> 6.10 is not out yet. 6.11 already? :)
14:25:14 <vixey> I don't know what you mean
14:25:19 <vixey> I am using 6.11
14:25:33 <monochrom> gosh you people are impatient!
14:25:36 <vixey> conal, I just installed 6.8.3, then build 6.11 from source code
14:25:52 <bbs> http://rafb.net/p/yPDZOS59.html
14:25:53 <lambdabot> Title: Nopaste - No description
14:26:04 <bbs> vixey: ^^^ those are the data types
14:26:13 <vixey> conal: 6.11.20081031 is the one I got working
14:26:34 <vixey> bbs, so what's the point of this?
14:26:36 <conal> vixey: where do you start? download from http://www.haskell.org/ghc/dist/current/dist/?C=M;O=D ?
14:26:38 <lambdabot> Title: Index of /ghc/dist/current/dist
14:26:42 <bbs> to write a crappy interpreter
14:26:53 <vixey> is it actually "crappy" in the course title?
14:26:56 <vixey> I would not be surprised :D
14:26:59 <bbs> :/
14:27:10 <vixey> conal, yes exactly
14:27:16 <unenough> lambdabot should learn to ignore those urls
14:27:17 <bbs> ... should be
14:27:22 <vixey> oh wait
14:27:25 <eu-prleu-peupeu> i'm not leet in haskell, but i can play bossa nova
14:27:31 <eu-prleu-peupeu> will i be able to get a job coding haskell ?
14:27:35 <conal> vixey: compiling via 6.8.2 from apt?
14:27:39 <vixey> conal, yeah that one .. I got confused because when I looked at it it was the other way around
14:28:01 <bbs> vixey: so how would i go about it
14:28:16 <vixey> conal, Yeah. I think I tried to use a binary from that site before bbut iirc it didn't work so I used apt then build 6.11 from source
14:28:23 <vixey> bbs, sorry go about what?
14:28:30 <conal> vixey: are there compile/install instructions somewhere?
14:28:32 <vixey> bbs, I am looking at your AST
14:28:45 <bbs> ok
14:28:46 <vixey> conal, oh it's just ./configure, then make then if that worked install
14:29:00 <bbs> conal: you need to make after configure
14:29:03 <bbs> ;P
14:29:46 <conal> sounds easy.   and where does one conventionally place things like the downloaded ghc source tree?
14:30:01 <bbs> conal: wherever the hell you like :)
14:30:05 <bbs> probably ~
14:30:13 * unenough supresses the urge to mention the toilet
14:30:17 <bbs> hehehe
14:30:19 <vixey> oh I put it in ~/code
14:30:25 <vixey> oh I put it in ~/code/implementations *
14:30:26 <bbs> conal: you can also ./configure --prefix
14:30:36 <vixey> I keep lots of compiler source codes around for no good reason :L
14:30:39 <bbs> if you know exactly where you want to install it
14:30:42 <monochrom> I throw away the source tree afterwards.
14:30:51 <bbs> monochrom: me too heh
14:30:59 <bbs> unless i *plan* to make uninstall
14:31:19 <conal> okay, great.  thanks for all the help.  i'll give it a try and probably ask some more questions.
14:34:41 <bbs> conal: thats cool :)
14:34:46 <bbs> vixey: what do you think?
14:34:48 <bbs> i get stucked
14:35:03 <bbs> execute (IntLit x) state = (I x)
14:35:05 <bbs> line 59
14:35:06 <conal> oh, i see now that much of this info is in the source tree's README.
14:35:09 <bbs> or the first paste
14:35:18 <bbs> conal: *nod*
14:35:27 <bbs> most stuff in *nix works like that
14:35:42 <bbs> conal: your distro might even have it
14:35:45 <bbs> in a testing or something
14:36:30 <unenough> why no parse?
14:36:30 <unenough> > let factorial n = n*(factorial (n-1)) ; factorial 0=1 in factorial 5
14:36:31 <lambdabot>   mueval: Prelude.read: no parse
14:36:31 <lambdabot>  mueval: UnknownError "GHC reported errors a...
14:36:46 <conal> fun.  what a relief to be back in *nix land (after many years in windows)!
14:37:36 <bbs> conal: WB
14:37:50 <conal> bbs: thx!
14:38:44 <eu-prleu-peupeu> :)
14:39:58 <vixey> bbs, You can use a GADT
14:40:28 <vixey> @let factorial = product . enumFromTo 1
14:40:29 <lambdabot>  Defined.
14:40:32 <vixey> > factorial 4
14:40:33 <lambdabot>   24
14:40:48 <bbs> vixey: oO
14:40:52 <bbs> you are talking way over my head
14:40:56 <bbs> you saw that POS code
14:41:07 <bbs> how would i implement that in AS
14:41:12 <unenough> vixey, why didn't my version parse?
14:41:20 <vixey> bbs, "way over your head" means there is one work you didn't understand? :)
14:41:34 <vixey> one word*
14:42:55 <unenough> @let factorial 0=1; factorial n = n*(factorial (n-1))
14:42:56 <lambdabot>  <local>:14:0:
14:42:56 <lambdabot>      Multiple declarations of `L.factorial'
14:42:56 <lambdabot>      Declared at: ...
14:43:04 <unenough> @let factorial2 0=1; factorial2 n = n*(factorial2 (n-1))
14:43:05 <lambdabot>  Defined.
14:43:10 <unenough> > factorial2 5
14:43:12 <lambdabot>   120
14:43:15 <unenough> ok :)
14:45:43 <bbs> vixey: ok i still don't understand :/
14:46:32 <bbs> vixey: i fail to see how factorial helps me here
14:46:42 <bbs> all i want it to wrap an integer and an real together so they can use either
14:46:56 <unenough> bbs, i think vixey was referring to my babbling
14:47:58 <bbs> vixey: ok GADT
14:48:10 <bbs> i don't get that though -- how do I apply it
14:48:15 <bbs> why can't i just derive stuff for it
14:48:42 <mopped> say I have a number < 361, and I want to partition it into a tuple/list such that 360 would be [120, 120, 120], 340 [120, 120, 100], how would I do this? :P
14:49:25 <lament> mopped: what would 1 be?
14:49:48 <mopped> [1, 0, 0]
14:50:07 <unenough> you want it in base 120
14:50:11 <unenough> reversed
14:51:36 <mopped> eh?
14:52:20 <yitz> > let p = map (min 120) . takeWhile (> 0) . iterate (max 0 . subtract 120) in p 360
14:52:21 <lambdabot>   [120,120,120]
14:52:28 <yitz> > let p = map (min 120) . takeWhile (> 0) . iterate (max 0 . subtract 120) in p 340
14:52:30 <lambdabot>   [120,120,100]
14:52:39 <yitz> > let p = map (min 120) . takeWhile (> 0) . iterate (max 0 . subtract 120) in p 1
14:52:40 <lambdabot>   [1]
14:52:56 <ddarius> unenough: In base 120, 360 would be 30.
14:52:58 <unenough> does haskell have a builtin function to convert bases?
14:53:11 <dons> yeah.
14:53:16 <dons> "builtin" :)
14:53:19 <unenough> ddarius, yes, but you can then use it?
14:53:21 <yitz> > let p = take 3 . (++ repeat 0) . map (min 120) . takeWhile (> 0) . iterate (max 0 . subtract 120) in p 1
14:53:22 <lambdabot>   [1,0,0]
14:53:26 <dons> its a primitive in the runtime ;)
14:53:27 <unenough> dons, excuse my newbieness
14:53:29 <yitz> > let p = take 3 . (++ repeat 0) . map (min 120) . takeWhile (> 0) . iterate (max 0 . subtract 120) in p 360
14:53:30 <lambdabot>   [120,120,120]
14:53:37 <yitz> > let p = take 3 . (++ repeat 0) . map (min 120) . takeWhile (> 0) . iterate (max 0 . subtract 120) in p 340
14:53:38 <lambdabot>   [120,120,100]
14:53:43 <yitz> ok?
14:54:29 <dons> > showIntAtBase 16 intToDigit 256
14:54:30 <lambdabot>       Overlapping instances for Show (String -> String)
14:54:30 <lambdabot>        arising from a...
14:54:31 <mopped> thats cool, thanks
14:54:39 <dons> > showIntAtBase 16 intToDigit 256 []
14:54:40 <lambdabot>   /tmp/8438924598316593499:69:52: Not in scope: `showIntAtBase'
14:54:54 <ddarius> wtf?
14:54:54 <dons> > Numeric.showIntAtBase 16 intToDigit 256 []
14:54:56 <lambdabot>   /tmp/996651468875074648:69:52:
14:54:56 <lambdabot>      Not in scope: `Numeric.showIntAtBase'
14:54:59 <dons> gwern
14:55:12 <dons> i hates the mueval error msgs. i hates them
14:55:22 <jkr> Ahoy
14:55:25 <unenough> ok, dons. got it
14:57:35 <bbs> vixey: http://rafb.net/p/wWsQs942.html
14:57:36 <lambdabot> Title: Nopaste - No description
14:57:46 <bbs> vixey: that fails :/
14:59:02 <bbs> i has the haskell dumb
14:59:22 <vixey> bbs, you shouldn't have x -> thought
14:59:24 <jkr> I have another newbie question. How is input usually validated in Haskell?
14:59:27 <vixey> it should be Int -> or Double ->
14:59:35 <bbs> vixey: so how do i fix it
14:59:40 <bbs> can i have a diff -ruN
14:59:41 <bbs> hehe
14:59:46 <dons> jkr: it is often parsed.
14:59:46 <monochrom> jkr: usually write a simple parser.
14:59:53 <jkr> For example, I take one argument from command line and I want to make sure it's an integer, and print a nice error message if not.
15:00:01 <dons> oh, use readMaybe
15:00:05 <dons> or other 'read' functions
15:00:11 <dons> > read '0x42' :: Integer
15:00:12 <lambdabot>   <no location info>:
15:00:13 <lambdabot>      lexical error in string/character literal at chara...
15:00:17 <vixey> bbs, make the change I suggested
15:00:19 <dons> > read "0x42" :: Integer
15:00:20 <lambdabot>   66
15:00:26 <dons> > read "0xxx" :: Integer
15:00:28 <lambdabot>   * Exception: Prelude.read: no parse
15:00:35 <bbs> vixey: and make them both point to IR?
15:00:39 <bbs> oh!
15:00:43 <monochrom> > readMaybe "0xxx" :: Maybe Integer
15:00:44 <jkr> dons: That's what I'm doing currently, but what can I do against the "Prelude.read: no parse" error?
15:00:44 <lambdabot>   Not in scope: `readMaybe'
15:00:46 <bbs> make one point to I and one point to R?
15:00:49 <dons> if you google for 'readMaybe' you'll see a version that returns Nothing
15:00:49 <bbs> vixey: ^
15:00:52 <dons> instead of an exception
15:00:53 <unenough> off topic: for those who work at home / get paid by the hour, the gnome hamster-applet is cool.
15:01:49 <bbs> vixey: i'm getting an exepcted symbol "where"
15:02:03 <dons> jkr: http://hpaste.org/11714
15:02:04 <monochrom> It would be on-topic if someone get paid by the hour helping in #haskell or haskell-cafe. :)
15:02:10 <unenough> is there something that does: maybeNotException :: (a->b) -> Maybe b ?
15:02:30 <vixey> unenough: a -> Maybe b is better
15:02:40 <unenough> yes
15:02:41 <vixey> just don't have an a -> b that use exception
15:02:43 <unenough> is there?
15:02:51 <dons> something like
15:02:52 <dons> unsafePerformIO $
15:02:53 <dons>     handle (const Nothing) $ do
15:02:53 <dons>         v <- e
15:02:53 <dons>         rnf v
15:02:55 <dons>         return $ Just v
15:02:58 <dons> at a first appox.
15:03:15 <yitz> @let readMaybe x = do (h, t) <- listToMaybe $ reads x; guard $ null t; return h
15:03:16 <lambdabot>  Defined.
15:03:39 <yitz> > readMaybe "0x123" :: Int
15:03:40 <lambdabot>   Couldn't match expected type `Int' against inferred type `Maybe a'
15:03:46 <yitz> > readMaybe "0x123" :: Maybe Int
15:03:47 <dons> hehe
15:03:47 <monochrom> Maybe Int !
15:03:48 <lambdabot>   Just 291
15:03:58 <yitz> > readMaybe "0xxxx" :: Maybe Int
15:03:59 <lambdabot>   Nothing
15:04:05 <yitz> whew
15:05:27 <yitz> readMaybe brought to you by dons (on haskell cafe), but really it's old Haskell folklore.
15:06:28 <dons> so what should we do with it?
15:06:34 <dons> stick it on hackage in the 'safe' library?
15:06:35 <jkr> dons: Thanks, that looks pretty helpful
15:07:08 <dons> yitz: yes, i discovered at galois that /every/ project i worked on had defined it some time over the last decade
15:07:50 <Igloo> Did it ever get proposed for base?
15:07:51 <yitz> dons: hmm. it really belongs in the Prelude. :)
15:08:05 <dons> it did. and i think we might even have reached consensus
15:08:18 <dons> particularly now the 'monad fail' faction has ceded ground.
15:08:29 <monochrom> haha
15:08:52 <dons> they're a weakened rump now. so onward with safety!
15:09:25 <Saizan> the "safe" variants of fromJust/head would also be appreciated, if you're going to crash your program at least give an hint of where it happened
15:09:40 <ddarius> safeFromJust = id
15:10:39 <Saizan> safeFromJust str x = case x of Nothing -> error str; Just x -> x
15:10:57 <sebaseba_> > abs (-2^31:: Int)
15:10:58 <lambdabot>   2147483648
15:11:00 <ddarius> fromMaybe (error str)
15:11:07 <sebaseba_> abs (-2^63:: Int)
15:11:09 <yitz> safeFromJust (Just x) = x; safeFromJust = error @timezone
15:11:20 <Saizan> yeah, i guess what i want is to discourage the use of fromJust
15:12:06 <unenough> where can i learn about exceptions in haskell? is there a standard for them? is that's what's happening when read fails?
15:12:06 <sebaseba_> > abs (-2^63:: Int)
15:12:08 <lambdabot>   -9223372036854775808
15:12:59 <monochrom> Int should be confined to IO.  *duck*
15:13:38 <sebaseba_> I wonder if this is acceptable behavior for abs
15:13:52 <yitz> monochrom: we're already talking about confining IEEE floats to IO, so hey, why not Int.
15:14:02 <ddarius> sebaseba_: What behavior do you want?
15:14:15 <sebaseba_> ddarius: an error, perhaps?
15:14:25 <Saizan> unenough: when read fails it calls error, which raises an exception from pure code, you can catch it with Control.Exception.catch, but you've to make sure to force the thunk that contains it inside the scope of catch
15:14:37 <yitz> ummm shouldn't abs always return something positive?
15:14:38 <monochrom> -9223372036854775808 is an error alright.
15:14:58 <eu-prleu-peupeu> im training to become an haskell evangelist, so everyday i read a tiny little bit of the haskell report as if it was the bible
15:15:04 <Saizan> ?docs Control.Exception
15:15:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
15:15:43 <monochrom> "the monomorphism restriction saves you"? :)
15:15:54 <unenough> Saizan, is that like a standard haskell thing now?
15:16:30 <yitz> > length . takeWhie (>0) . iterate (`div` 2) . (maxBound :: Int)
15:16:31 <lambdabot>   Not in scope: `takeWhie'
15:16:37 <yitz> > length . takeWhile (>0) . iterate (`div` 2) . (maxBound :: Int)
15:16:38 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Int'
15:16:44 <Saizan> unenough: it's not haskell98, in h98 there's no way to catch the use of error
15:16:47 <yitz> > length . takeWhile (>0) . iterate (`div` 2) $ (maxBound :: Int)
15:16:49 <lambdabot>   63
15:17:27 <yitz> I see, \bot's on a 64-bit machine now.
15:17:46 <ddarius> > maxBound :: Int
15:17:47 <lambdabot>   9223372036854775807
15:19:12 <eu-prleu-peupeu> what do i have to code in order to be known as "the haskell king" ?
15:19:29 <yitz> > head . dropWhile ((< maxBound) . (2 ^)) $ [0::Int..]
15:19:30 <lambdabot>   <no location info>: parse error on input `Int..'
15:19:39 <unenough> a spam filter for #haskell
15:19:40 <yitz> > head . dropWhile ((< maxBound) . (2 ^)) $ [(0::Int)..]
15:19:41 <lambdabot>   Add a type signature
15:20:10 <yitz> > head . dropWhile ((< (maxBound::Int)) . (2 ^)) $ [0..]
15:20:23 <monochrom> eu-prleu-peupeu: you need to code a least fixed point.
15:20:25 <lambdabot>   thread killed
15:20:32 <eu-prleu-peupeu> :)
15:20:43 <eu-prleu-peupeu> i was planing for an OS kernel, something like prlix
15:20:56 <yitz> > head . dropWhile ((< toInteger (maxBound::Int)) . (2 ^)) $ [0..]
15:20:58 <lambdabot>   63
15:20:59 <nomeata> eu-prleu-peupeu: get house running on SYS/161
15:21:00 <monochrom> An OS kernel is a big piece of least fixed point.
15:21:19 <eu-prleu-peupeu> what is house ?
15:21:24 <eu-prleu-peupeu> what is "least fixed point" ?
15:21:39 <monochrom> I'm pulling your leg. :)
15:21:43 <eu-prleu-peupeu> :D
15:21:43 <yitz> @go lambda calculu
15:21:45 <yitz> @go lambda calculus
15:21:46 <lambdabot> http://en.wikipedia.org/wiki/Lambda_calculus
15:21:46 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
15:21:48 <lambdabot> http://en.wikipedia.org/wiki/Lambda_calculus
15:21:48 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
15:22:17 <eu-prleu-peupeu> nice
15:23:01 <ddarius> An OS is more like a greatest fixpoint.
15:23:14 <eu-prleu-peupeu> hmm
15:23:19 <eu-prleu-peupeu> what about a virtual machine in haskell ?
15:23:28 <jkr> How do I prototype a function that returns either an Int or Nothing?
15:23:32 <jkr> -> Maybe Int?
15:23:41 <dons> yeah.
15:23:42 <dibblego> jkr, yes
15:23:43 <dons> that's the type
15:23:46 <dons> not prototype :)
15:23:51 <jkr> Ah, right :)
15:23:55 <dons> its the truly, ruly real type
15:24:05 <jkr> :)
15:25:22 <monochrom> Oh oops, greatest fixed point. :)
15:26:34 <yitz> most OSes are neither great nor fixed.
15:26:47 <Saizan> btw, (sort of) is there a -morphism which corresponds to foldl?
15:27:01 <ddarius> Saizan: No.
15:27:29 <BMeph> An OS is a continuation comonad! :)
15:27:46 <Saizan> 'k
15:27:59 <monochrom> cocontinuation coconut
15:29:49 <noZone> coconut milk is endosperm that doesn't solidify like it does in most other seeds.
15:29:50 <monochrom> most OSes are not points either. more like big fat greek wedding.
15:30:11 <jkr> How do I use the result of a Maybe Int function? Maybe Int doesn't seem to match Int
15:30:24 <dibblego> jkr, you must break it out into Just and Nothing
15:30:26 <jkr> Do I need to take a "Maybe Int" argument in my functions then?
15:30:35 <monochrom> You could.
15:30:36 <kpreid> jkr: case maybeIntThing of Just i -> ...; Nothing -> ...
15:30:36 <int-e> a least broken point, hmm.
15:30:38 <dibblego> @src Maybe
15:30:38 <lambdabot> data Maybe a = Nothing | Just a
15:30:39 <Philonous> jkr: That's where monads come into play
15:30:55 <jkr> Ah, I forgot the "Just" in my case :)
15:31:01 <kpreid> jkr: or use any other pattern matching option, or use the functions fromMaybe or maybe if you're feeling functional
15:31:16 <kpreid> (er, 'maybe' there is Prelude.maybe)
15:31:26 <yitz> @type maybe
15:31:28 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:31:31 <noZone> What if you are feeling disfunctional?
15:31:44 <kpreid> then use fromJust
15:32:22 <yitz> > maybe -100 (+ 7) . readMaybe "42" :: Int
15:32:24 <lambdabot>   Couldn't match expected type `a -> b'
15:32:33 <yitz> > maybe -100 (+ 7) $ readMaybe "42" :: Int
15:32:34 <lambdabot>   Couldn't match expected type `Int'
15:32:37 <monochrom> I use a do-block. I am dysfunctional.
15:33:13 <yitz> > (maybe -100 (+ 7) $ readMaybe "42") :: Int
15:33:14 <lambdabot>   Couldn't match expected type `Int'
15:33:39 <Philonous> > (Just 2) >>= (liftM2 (+) ) 5
15:33:40 <lambdabot>       No instance for (Num (Maybe a1))
15:33:40 <lambdabot>        arising from the literal `2' at...
15:33:52 <yitz> @type maybe -100 (+ 7) $ readMaybe "42"
15:34:01 <lambdabot>     Ambiguous type variable `a' in the constraint:
15:34:01 <lambdabot>       `Num a' arising from the literal `7' at <interactive>:1:14
15:34:01 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
15:34:10 <Philonous> > (Just 2) >>= (liftM2 (+) ) (Just 5)
15:34:11 <noZone> Since a do block is syntactic sugar, and a little sugar helps the medicine go down, then maybe after awhile you wont be dysfunctional anymore.
15:34:12 <lambdabot>       No instance for (Num (Maybe a1))
15:34:12 <lambdabot>        arising from the literal `2' at...
15:34:52 <yitz> noZone: sometimes a spoonful of sugar helps the *machine* go down.
15:34:59 <jdrake> Does anyone know a good demonstration of implementing a parsec parser in a fairly simple syntax situation but can explain what it is doing to a beginner fairly easily?
15:35:22 <dibblego> jdrake, Graham Hutton's book has exactly that
15:35:59 <yitz> > maybe (-100) (+ 7) $ readMaybe "42" :: Int
15:36:01 <lambdabot>   49
15:36:05 <jdrake> ah you mean the book I already have? :p
15:36:08 * jdrake looks
15:36:09 <yitz> > maybe (-100) (+ 7) $ readMaybe "xxx" :: Int
15:36:11 <lambdabot>   -100
15:36:35 <jdrake> Chapter 8 functional parsers I assume would help with that
15:36:43 <yitz> jkr: ^ use of the maybe function
15:38:36 <monochrom> Some drugs cause more dysfunctions. :)
15:39:32 <monochrom> Graham Hutton also has early papers on parsing monadically, if you don't have the book.
15:41:53 <noZone> Is Hutton's book worth getting if you already understand monads, and the basics of Haskell?
15:43:02 <jkr> Where does the readMaybe come from? Is it in the standard libs?
15:43:05 <monochrom> That is hard to say. If you want to save money, hey it's recession magnus now, probably not.
15:43:35 <jkr> Or do I have to copy dons version?
15:43:44 <Saizan> jkr: copy
15:43:55 <jkr> Ok
15:44:40 <monochrom> But you could also think, though you already know haskell, you want to own and read the book so you learn exposition methods from it or know how to recommend it to other people.
15:44:56 <noZone> I found "Real World Haskell" both enlightening and encouraging, since I like practical uses over just theory.
15:45:27 <noZone> Ture monochrom
15:45:30 <noZone> True
15:45:51 <jkr> Yeah, that's a great tutorial.
15:46:15 <jkr> I like Learn You A Haskell even more, but I'm still waiting for the IO part :)
15:46:56 <noZone> I, along with many others I expect, will dig into difficult stuff if there's a practical payoff.
15:48:20 <noZone> "Programmers cannot live on theory alone!"... I can't remember who said that.
15:49:13 * Cale lives on theory alone :)
15:49:30 <ddarius> Theory and olives.
15:49:40 <Cale> Okay, and olives.
15:49:41 <dons> mmm
15:49:42 <Pseudonym> Dijkstra was a theoretical physicist who became a theoretical programmer.
15:49:42 <noZone> :)
15:49:49 <Cale> Maybe the occasional pickle.
15:49:50 <Pseudonym> But I'm with you on the olives.
15:49:54 <Pseudonym> Antipasto.
15:52:03 <noZone> I suppose without those who thrive on theory we wouldn't be blessed with Haskell at all.
15:52:37 <conal> i'm installing zlib (for cabal-install), and i'm missing zlib.h. (ubuntu linux.)  where might i pick it up, and how could i have figured out the answer for myself?
15:53:11 <dons> conal: so the zlib package is a C package. you'd need to find the name of the C package for zlib using some search mechanism in your distro.
15:53:32 <dons> pacman -S zlib  (on arch linux), for example, searches for packages that mention zlib
15:55:15 <jkr> http://github.com/jkramer/haskell/tree/master/tree.hs <-- christmas tree printer with argument validation \o/
15:55:17 <lambdabot> Title: tree.hs at master from jkramer's haskell  GitHub
15:55:39 <conal> dons: thx.
16:17:19 <adityam> How good is gsl-random as a random number generator. I am finding huge variations in my answers depending on seed
16:17:31 <dons> in the quality of your answers?
16:17:38 <dons> or in the random data? being random and all ... :)
16:17:44 <dons> which random generator are you using?
16:18:00 <adityam> I am running a monte carlo simulation. The answers vary a lot depending on the seed
16:18:41 <ivanm> adityam: how many points are you using?
16:19:29 <adityam> See http://hpaste.org/11715
16:19:47 <adityam> I am using 100000000000 points
16:19:59 <ivanm> heh, I'd think that would be accurate then ;-)
16:20:21 <ivanm> dons: do you have PKBUILDs for _every_ hackage package or something?
16:20:48 <adityam> Yes but my result is varying from 20,000 to 70,000 depending on the seed!
16:20:58 <ivanm> what's mt19937?
16:21:26 <dons> ivanm: yeah
16:21:40 <ivanm> I'm guessing draw produces 5 random points from [0,10) or something?
16:21:42 <adu> adityam: isn't that a good thing?
16:21:46 <adityam> I was trying monte carlo simulations using MC monad http://quantile95.com/2008/08/26/a-monte-carlo-monad-for-haskell/ mt19937 is some function from gsl-random
16:21:47 <dons> adityam: are you using the mersenne-random generator?
16:21:51 <lambdabot> Title:  Blog Archive  A Monte Carlo Monad for Haskell
16:22:02 <adu> adityam: you don't want it to be remotely related to the seed, otherwise it wouldn't be random
16:22:05 <dons> ah mt19937 is the high perf mersenne random function
16:22:09 <ivanm> dons: even the ones that aren't for *nix (e.g. the cocao bindings)? ;-)
16:22:16 <dons> no.
16:22:22 <ivanm> heh
16:22:28 <ivanm> so not _quite_ all
16:22:44 <ivanm> adityam: you're only using 5 points
16:23:03 <ivanm> monte carlo is accurate to ~ 1/(sqrt n)
16:23:07 <adityam> But my results depend quite a lot on the seed. I do not understand why this should happen.
16:23:14 <ivanm> hence why you're results aren't accurate
16:23:26 <ivanm> adityam: for draw, replace '5' with '10000000'
16:23:59 <ivanm> or else have: draw n = replcateM n (uniformInt 10), then in main have:  ... evalMC (draw n >>= ...
16:24:02 <ddarius> I don't see n being used...
16:24:08 <ivanm> ddarius: exactly
16:24:13 <adu> "draw = replicateM 5"
16:24:16 <adu> thats the 5
16:24:17 <ivanm> he's only using 5 points (if I understand what draw does)
16:24:39 <adityam> ivanm..Thanks...I realize I am not using n at all <hangs head in shame>
16:25:04 * ivanm should probably start studying MC for his exam on Friday :s
16:26:03 <adu> adityam: maybe parameterize draw to "draw n = replicate n ...."
16:26:17 <adityam> Actually, I want to repeat the experiment of drawing 5 random numbers n times
16:26:35 <ivanm> adityam: ahhhh
16:26:43 <ivanm> that's entirely different then
16:26:58 <ivanm> probably want to use replicateM on draw then, off the top of my head
16:29:33 <noZone> Do hpaste pages remain permanently, or do little Haskell elves sweep up the place after awhile?
16:29:56 <dons> they are permanent
16:30:01 <dons> they're keyed by an unbounded Integer
16:30:16 <noZone> nice
16:30:38 <ivanm> permanent == until the computer they're stored on crashes and loses all its data
16:30:40 <ivanm> ;-)
16:30:49 <adityam> Ah, I realize that MC Monad does not provide an abstraction for what I want.
16:30:51 <dons> we've used up the first 13 bits
16:30:53 <ivanm> hmmmm..... we need a way of indexing nice/useful hpastes...
16:31:00 <ivanm> dons: heh
16:31:16 <monochrom> nice indexing = google
16:31:24 <dons> 14 bits coming up soon.
16:31:50 <adityam> Is there a Haskell monte carlo module where I can just specify the experiment, and I get average value of the experiment (without having to write all the pluming code)
16:31:58 <ivanm> monochrom: yes, but it doesn't provide a way of nowing which hpastes are interesting or useful
16:32:02 <ivanm> and will index all of them
16:32:08 <dons> adityam: check on hackage.haskell.org, but i'm not aware of one.
16:32:13 <ivanm> adityam: doubt it
16:32:19 <dons> there are libraries for good random data (e.g. mersenne-random)
16:32:19 <ivanm> that's the only MC module around
16:32:21 <dons> and the MNC monad.
16:32:28 <Pseudonym> adityam: SOunds like you might run foul of the No Free Lunch Theorem there.
16:32:31 <dons> yeah
16:32:37 <ivanm> (and was released a couple of days after I submitted my MC assignment :s )
16:33:00 <monochrom> I made one or two useful pastes on hpaste, and I bookmarked them.
16:33:19 <adityam> Thanks. I'll check hackage
16:33:37 <ivanm> monochrom: well, you know which useful pastes _you_ made... but others don't, nor do they know of useful pastes made by someone else
16:34:03 <ivanm> adityam: what are you actually trying to do?
16:34:57 <adityam> ivanm: Find the average value of the number generated by picking 5 digits at random
16:35:15 <noZone> Maybe lamdabot can be trained to belch out a random, but useful hpaste page if asked.
16:35:15 <adityam> ivanm: But actually trying to learn how to do numerical algorithms in haskell
16:35:23 <ivanm> I don't know what evalMC does, but surely you could just do something like: evalMC (replicateM n (draw >>= value')) $ mt19937 seed
16:35:52 <ivanm> adityam: ummm.... do you really want MC for that then?
16:36:02 <ivanm> generate n five digit numbers, and average them
16:36:17 <ivanm> for averaging, grab the code off dons' blog
16:36:45 <cads> Hey, I have a naive sort algorithm in ugly pseudo-c. I was wondering if you guys know whether it has a name, as I can't find one, though in implementation it seems to be a cross between bubble sort and gnome sort:  http://pastie.org/306854 .
16:36:46 <lambdabot> Title: #306854 - Pastie
16:37:08 * ivanm has never heard of "gnome sort" before...
16:37:24 <cads> I'd like to implement that in haskell too but I'm having a hard time conceptualizing how to encode that swapping behaviour
16:37:29 <adityam> ivanm: I thought that is what Monte Carlo was. Maybe I am confused with terminology
16:37:31 <ivanm> looks like a partial sorting bubble sort to me
16:37:49 <ivanm> adityam: MC is used to approximate n-dimensional integrals
16:38:27 <ivanm> (usually, anyway)
16:38:28 <ivanm> http://en.wikipedia.org/wiki/Monte_Carlo_method
16:38:29 <lambdabot> Title: Monte Carlo method - Wikipedia, the free encyclopedia
16:38:52 <ivanm> cads: using lists or arrays?
16:39:04 <adityam> ivanm: That is just a sophisticated averaging, isn't it?
16:39:20 <ivanm> hmmmm..... I suppose you could see it that way
16:41:24 <cads> ivanm, hmm, I guess that algorithm would be a little silly with lists
16:41:48 <ivanm> cads: that algorithm is a little silly for arrays as well ;-)
16:42:03 <cads> arrays are beyond me right now, but maybe this is a decent excuse to see how they're done
16:42:06 <ivanm> all you're doing (AFAICT) is partially sorting an initial segment, adding an element then resorting
16:42:10 <ivanm> which wastes comparisons
16:42:39 <ivanm> adityam: have a look here: http://www-stat.stanford.edu/~patperry/code/monte-carlo/examples/Pi.hs
16:42:41 <lambdabot> http://tinyurl.com/5r84ym
16:43:12 <ivanm> basically, you want draw to return n five-number lists
16:43:57 <ivanm> so something like: draw n = replicateM n $ replicateM 5 (uniformInt 10)
16:45:21 <ivanm> so when using it, have: evalMC (liftM (map value') $ value n) ...
16:45:51 <ivanm> though, tbh I would apply value' when generating the lists
16:46:21 <adityam> ivanm : let me try that to see if it works.
16:46:46 <ivanm> alternatively, leave draw how you have it and have: evalMC (replicateM n $ draw >>= return . value')
16:46:51 <ivanm> @pl draw >>= return . value'
16:46:55 <lambdabot> value' `fmap` draw
16:47:19 <ivanm> what's `fmap`? <+> or something?
16:47:49 <cads> ivanm, I see what you mean; there are a lot of comparisons made which have a relatively small chance of  effecting a swap
16:47:59 <adityam> ivanm: then I will need to do the averaging by hand
16:48:07 <Saizan> ivanm: <$>
16:48:15 <ivanm> adityam: no, if I understand what evalMC does it will average it for you
16:48:19 <ivanm> have a look at that pi example
16:48:25 <ivanm> Saizan: yeah, that's what I was after
16:48:39 <yitz>  > let mcpi :: Int -> Double; mcpi n = 4 * (fromIntegral . length . filter ((< 1) . (\[x,y]->sqrt(x*x+y*y))) . evalState (replicateM n . mapM State . replicate 2 $
16:48:40 <ivanm> draw >>= return . value' == value' <$> draw
16:49:16 <yitz>  > let mcpi :: Int -> Double; mcpi n = 4 * (fromIntegral . length . filter ((< 1) . (\[x,y]->sqrt(x*x+y*y))) . evalState (replicateM n . mapM State . replicate 2 $
16:49:26 <conal> i'm getting an installation failure for OpenGL, saying "no OpenGL headers found".  the configure phase reports finding GL/gl.h but not OpenGL/gl.h, and no version of glu.h.  does anyone know if OpenGL/gl.h or glu.h is needed?
16:49:51 <cads> anyways, this is just some algorithm someone asked about and I thought it would be interesting to implement using haskell, since it uses iteration instead of recursion like quicksort and other sort algorithms I've done
16:49:54 <yitz> > let mcpi :: Int -> Double; mcpi n = 4 * (fromIntegral . length . filter ((< 1) . (\[x,y]->sqrt(x*x+y*y))) . evalState (replicateM n . mapM State . replicate 2 $ randomR (-1,1)) $ mkStdGen 42) / (fromIntegral n) in mcpi 100
16:49:55 <conal> (the haskell OpenGL package)
16:49:57 <lambdabot>   3.28
16:50:04 <yitz> > let mcpi :: Int -> Double; mcpi n = 4 * (fromIntegral . length . filter ((< 1) . (\[x,y]->sqrt(x*x+y*y))) . evalState (replicateM n . mapM State . replicate 2 $ randomR (-1,1)) $ mkStdGen 42) / (fromIntegral n) in mcpi 1000
16:50:09 <lambdabot>   3.172
16:50:20 <yitz> > let mcpi :: Int -> Double; mcpi n = 4 * (fromIntegral . length . filter ((< 1) . (\[x,y]->sqrt(x*x+y*y))) . evalState (replicateM n . mapM State . replicate 2 $ randomR (-1,1)) $ mkStdGen 42) / (fromIntegral n) in mcpi 100000
16:50:22 <lambdabot>   3.13904
16:50:34 <ivanm> yitz: show off ;-)
16:50:53 <yitz> ivanm: good thing \bot responds to private msgs
16:51:47 <ivanm> yitz: for testing purposes? ;-)
16:52:02 <ivanm> but really, that is one ugly piece of code...
16:52:09 * ivanm hopes yitz doesn't code like that IRL
16:52:35 * yitz only does that when constrained to one-liners
16:53:28 <ivanm> *phew*
17:11:05 <adityam> I modified the monte-carlo function by defining an average function, and now it does not depend too much on the seed
17:11:33 <adityam> I defined a average function along the lines of the code by dons in his blog
17:12:14 <adityam> Is it possible to write an efficient average function for (Num a)?
17:14:03 <adityam> The data P = P !Double !Int does not work for arbitrary instance of Num
17:18:45 <conal> how can one remove or clean-reinstall a package installed with 'cabal install' ?
17:19:19 <conal> i want to get the configure step to be repeated
17:19:28 <FunctorSalad> conal: cabal install --reinstall, I think
17:19:48 <conal> FunctorSalad: thx.  i'll give it a try.
17:20:11 <FunctorSalad> not sure if it will reconfigure, though
17:20:45 <FunctorSalad> to force that you could delete your .cabal/packages/... directory, I guess
17:21:36 <ivanm> adityam: no, because Num doesn't have division
17:21:37 <FunctorSalad> or maybe not, that directory just contains the downloaded packages, not the temp files I think
17:21:44 <conal> FunctorSalad: thx.  the --reinstall did seem to trigger a re-config.  i'm glad to know the delete trick also.
17:21:45 <ivanm> but you can write a generic average function
17:22:12 <adityam> ivanm: how about average :: (Num a) -> [a] -> Double
17:22:16 <FunctorSalad> conal: nvm the deletion, I think that will just force redownload :) maybe the temp files are in /tmp ?
17:23:03 <ivanm> adityam: I don't think there's a generic a -> Double function either
17:23:25 <conal> hrmf.  i'm getting this error when running a haskell glut program: Loading package GLUT-2.1.1.2 ... linking ... <interactive>: /home/conal/.cabal/lib/GLUT-2.1.1.2/ghc-6.11.20081103/HSGLUT-2.1.1.2.o: unknown symbol `glutGet'
17:23:26 <jsn> is there a generic way to take a Parsec parser    GenParser tok st a    to a parser     GenParser tok st ()    that is not as verbose as    >> return ()    ?
17:23:30 <ivanm> adityam: http://hpaste.org/11716
17:23:37 <conal> anybody know about that problem?
17:23:41 <adityam> I can always first convert [a] -> [Double] but I wonder if there is a better way?
17:23:43 <ivanm> I've used that to create a function to take means of hmatrix vectors, etc.
17:23:55 <ivanm> adityam: probably not
17:25:04 <adityam> ivanm: Aren't these mean functions inefficient?
17:25:21 <ivanm> adityam: ummm.... it uses the one developed by dons
17:25:30 <ivanm> which _is_ efficient
17:26:18 <ivanm> it's just a generalisation, that takes in an addition function, a division function and a zero value
17:26:25 <adityam> ivanm: Oh, I thought that dons recommended to used data P = P !Double !Int
17:26:41 <ivanm> adityam: I don't think so...
17:26:49 <ivanm> this is his efficient mean function
17:27:15 <ivanm> *list mean
17:27:26 <adityam> I got confused by the two blog posts. I was only reading the second one
17:28:04 <jsn> skipMany is almost right
17:28:22 <ivanm> adityam: IIRC, the later one wasn't dealing with lists
17:28:56 <adityam> ivanm: I figured out out to use it on lists :-D
17:29:14 <ivanm> heh, fair enough
17:29:18 <adityam> I think I can define a generic average function on Fractional a
17:29:27 <ivanm> yeah, you're pretty much limited to that
17:29:37 <ivanm> unless you specify a generic 'division' function
17:29:53 <adityam> Then I can define reapeatMC :: Fractional a => Int -> MC a -> RNG -> Double
17:30:08 <ivanm> note that in hindsight, my generic meanBy function should specify the division function to be Num c => (b -> c -> b), and not restrict it to Double
17:30:22 <ivanm> adityam: ummm..... I thought the MC monad did multiple calcs...
17:30:31 <ivanm> in that case, you shouldn't use evalMC but runMC
17:31:13 <ivanm> oh, wait, I'm wrong
17:31:18 <ivanm> it does it one at a time
17:31:31 <ivanm> which to me sounds pretty silly... how does using evalMC differ from doing it manually?
17:32:02 <ivanm> blah, forget that
17:32:07 <ivanm> it does do multiple runs in the one simulation
17:32:25 <ivanm> adityam: http://www-stat.stanford.edu/~patperry/code/monte-carlo/examples/Pi.hs <-- see the main' function at the bottom
17:32:42 * ivanm -> lunch
17:33:39 <adityam> ivan: Yes, but you have to write the complete simulation function
17:33:39 <adityam> Similar to calculatePi function in the example
17:33:39 <adityam> I was thinking that I can just write something like insideCircle :: (Double, Double) -> Int and then average
17:33:41 <lambdabot> http://tinyurl.com/5r84ym
17:34:35 <lispy> :t unzip
17:34:37 <kclancy> does anyone here know anything about parallel algorithms?
17:34:45 <lispy> ?bot
17:34:51 * lispy pokes at lambdabot 
17:35:12 <adityam> ivanm: I want to write a function so that I do not have to write calculatePi for all my experiments
17:35:17 <adityam> only inUnitCircle should be enough, rest is just boilerplate code
17:35:35 <lambdabot> :)
17:35:36 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
17:35:58 <ddarius> @check \x y -> x*x + y*y < 1.0
17:35:59 <lambdabot>   "Falsifiable, after 1 tests:\n-2.0\n-2.5\n"
17:36:13 <lispy> that's some great output
17:36:34 * lispy isn't familiar with the number \n-2.0
17:37:07 <lispy> > \n-2.0
17:37:26 * lispy thinks someone must be pounding on lambdabot in private
17:37:33 <lispy> go lambdabot g!
17:37:38 <lambdabot>   <no location info>: parse error on input `-'
17:38:36 <lispy> > \n
17:38:37 <lambdabot>   <no location info>: parse error on input `;'
17:38:50 <lispy> > \
17:38:51 <lambdabot>   <no location info>: parse error on input `;'
17:40:31 <yitz> > Numeric.showHex 12345 ""
17:40:32 <lambdabot>   /tmp/4426083721482518467:69:52: Not in scope: `Numeric.showHex'
17:40:40 <yitz> > showHex 12345 ""
17:40:41 <lambdabot>   /tmp/8929270418213674857:69:52: Not in scope: `showHex'
17:40:47 <yitz> @seen Cale
17:40:47 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 1h 50m 56s ago.
17:41:28 <Cale> hey
17:41:29 <adityam> How can I convert Floating a -> Double?
17:41:44 <yitz> Hi Cale. What's with Numeric in \bot?
17:41:49 <Cale> adityam: realToFrac might work
17:41:52 <jsn> :t fromRational
17:41:53 <lambdabot> forall a. (Fractional a) => Rational -> a
17:42:15 <Cale> yitz: apparently it's not imported?
17:42:24 <yitz> apparently not
17:43:28 <yitz> Cale: perhaps there's a reason - some name clash?
17:43:54 <gwern> 'lo all
17:44:06 <adityam> jsn: It does not work.
17:44:19 <yitz> hi gwern
17:44:19 <adityam> > let a = [10.2, 15.3] in map (fromRational) a
17:44:22 <lambdabot>   [10.2,15.3]
17:44:27 <Pseudonym> Perhaps rather than a black candidate, Obama is seen as "not a member of the club".
17:45:01 <adityam> jsn: hmmm... it does not work when I try on ghci when a is already defined
17:45:03 <jsn> > let a = [10.2, 15.3] in map (fromRational) a :: Double
17:45:04 <lambdabot>   Couldn't match expected type `Double' against inferred type `[a]'
17:45:04 <Cale> yitz: No, it's just not imported.
17:45:19 <jsn> > let a = [10.2, 15.3] in map (fromRational) a :: [Double]
17:45:20 <lambdabot>   [10.2,15.3]
17:45:35 <Cale> > showHex 12345 ""
17:45:36 <lambdabot>   "3039"
17:45:40 <Cale> there you go
17:45:53 <yitz> yay! tnx Cale
17:45:56 <adityam> jsn: On ghci I get  Couldn't match expected type `Rational'
17:45:56 <adityam>            against inferred type `Double'
17:45:56 <adityam>       Expected type: [Rational]
17:45:56 <adityam>       Inferred type: [Double]
17:45:56 <adityam>     In the second argument of `map', namely `a'
17:45:57 <adityam>     In the expression: map (fromRational) a :: [Double]
17:46:12 <adityam> @let  a = [10.0, 13.24] :: Float
17:46:12 <lambdabot>  Couldn't match expected type `Float' against inferred type `[a]'
17:46:17 <adityam> @let  a = [10.0, 13.24] :: [Float]
17:46:18 <lambdabot>  Defined.
17:46:32 <adityam> > map (fromRational) a :: [Double]
17:46:33 <lambdabot>       Ambiguous occurrence `a'
17:46:33 <lambdabot>      It could refer to either `L.a', defined a...
17:46:41 <Cale> > map realToFrac a :: [Double]
17:46:42 <lambdabot>       Ambiguous occurrence `a'
17:46:42 <jsn> hmm
17:46:42 <lambdabot>      It could refer to either `L.a', defined a...
17:46:46 <Cale> > map realToFrac L.a :: [Double]
17:46:47 <lambdabot>   [10.0,13.239999771118164]
17:46:53 <Cale> @undefine
17:47:55 <adityam> Ok, another try
17:48:26 <adityam> @let abc = [10, 14] :: [Int]
17:48:26 <lambdabot>  Defined.
17:48:37 <adityam> map (fromRational) abc :: [Double]
17:48:45 <adityam> >map (fromRational) abc :: [Double]
17:49:03 <adityam> ?bot
17:49:04 <lambdabot> :)
17:49:08 <adityam> > map (fromRational) abc :: [Double]
17:49:09 <lambdabot>   Couldn't match expected type `Rational' against inferred type `Int'
17:49:37 <adityam> @undefine
17:50:01 <adityam> Ah, Int is not a member of floating
17:53:59 <jsn> it is kind of tough to make a Parsec parser that recovers from errors
17:54:39 <jsn> i imagine i could rewrite fail to move to the end of the current line and then -- do what?
17:54:43 <jsn> i'm not sure
17:54:45 <jsn> oh
17:56:05 <jsn> i guess i need to organize things with some "root" parser, and then have a    goto    function that i call in the event of an error
17:56:39 <jsn> the idea is, i am processing a list of things and i want to walk over ones that are defective
17:57:01 <jsn> there is maybe not a "general" pattern for parser recovery
17:59:50 <SamB_XP_> jsn: if recovery is what you want, Parsec may not be the tool for you ...
18:00:04 <jsn> well, actually
18:00:10 <jsn> we'll see in a minute
18:00:31 <jsn> i'm looking for sed like "silent failure"
18:00:53 <jsn> or maybe it puts all the failures in one list, and all the successes in another
18:00:59 <jsn> that's really what i want, yeah
18:04:41 <jsn> i notice that in core you can specify the package in a module name
18:05:01 <jsn> it might not be bad to have this feature in real haskell
18:05:23 <SamB_XP_> jsn: can ?
18:05:29 <SamB_XP_> I thought it was required!
18:05:55 <jsn> SamB_XP_: i haven't really tried it out :)
18:06:13 <SamB_XP_> then again, does core even parse right now ?
18:11:09 <jsn> there is no way to collect the errors, is there?
18:11:15 <ivanm> adityam: just use a different name...
18:12:07 <ivanm> adityam: computePi is equivalent to your draw >>= return . value'
18:12:28 <ivanm> adityam: what you don't seem to realise is that with MC, you don't do one experiment at a time... you do a whole _heap_ at a time
18:17:26 <adityam> ivanm: draw >>= return. value' is one experiment
18:17:55 <adityam> Just as inUnitCircle is one experiment
18:18:09 <adityam> One repeats the experiment multiple times to get a simulation
18:18:15 <ivanm> adityam: yes.... but you're meant to do multiple experiments in the same turn
18:18:17 <ivanm> not just one
18:18:17 <adityam> At least, this is how I am thinking about it
18:18:36 <adityam> That is why I want a function that will repeat experiments
18:18:59 <adityam> This is what I defined repeatMC n f r = average (evalMC (replicateM n f) r)
18:19:30 <adityam> Here f is my experiment, n is the number of times I want to repeat it and r is the random number generator
18:19:43 <ivanm> that's not right
18:19:49 <ivanm> evalMC works on _multiple_ experiments
18:19:58 <ivanm> and it performs the averages (so you were right before about that)
18:20:45 <adityam> Suppose I have an experiment say experiment:: a -> MC b
18:21:07 <ivanm> no
18:21:22 <ivanm> Int -> MC b should define _all_ of your experiments
18:21:32 <adityam> Ok, so we are using different terminology
18:21:39 <ivanm> could be
18:21:56 <ivanm> MC works on a whole number of "runs" at a time
18:22:11 <ivanm> changing my terminology
18:22:25 <ivanm> an experiment is the MC evaluation of n random samples
18:22:47 <adityam> Ok. In many cases, all samples are taken independently
18:23:10 <ivanm> the distribution of MC results is a gaussian, with the error in each experiment proportional to ~/(sqrt n), where n is the number of runs in an experiment
18:23:15 <ivanm> adityam: they shouldn't be
18:23:31 <ivanm> because then your error is proportional to your value
18:23:39 <ivanm> or the sqrt of your value... something like that
18:23:59 <adityam> No... I want to repeat my sampling n times, but do not want to write code each time to do that
18:24:02 <ivanm> MC becomes accurate since the error is proportional to 1/(sqrt n) ...  so for large values of n, your error is small
18:24:20 <ivanm> adityam: you want to get n different 5-digit numbers?
18:24:26 <ivanm> then do what, average them?
18:24:29 <adityam> Yes.
18:24:30 <ivanm> MC will do that for you
18:24:41 <adityam> This is how I am currently writing it.
18:24:47 <adityam> repeatMC n f r = average (evalMC (replicateM n f) r)
18:24:49 <adityam> and then
18:24:52 * ivanm hates to point this out to adityam, but it's wrong
18:25:07 <adityam>  mean   = repeatMC n (value' <$> draw)                         (mt19937 seed)
18:25:32 <ivanm> ummm..... what does your average function do?
18:25:46 <adityam> average :: [Double] -> Double
18:26:00 <ivanm> hmmm..... I thought evalMC returned a single value...
18:26:03 <pumpkin_> arithmeticMean :o
18:26:23 <ivanm> adityam: hmmm....
18:26:30 <ivanm> I still don't think you're doing it right...
18:26:40 <ivanm> but I'm not really that familiar with the MC monad
18:27:11 <adityam> No you have to write the function to average !!! Thats my point
18:27:14 <ivanm> or si the MC monad just a wrapper around applying a new random value to each function?
18:27:20 <ivanm> adityam: ahhh, OK, my mistake
18:27:26 <ivanm> the MC monad doesn't do what I thought it did
18:28:10 <adityam> That is why I am saying that it should have a function that does averaging :-)
18:29:07 <ivanm> adityam: yeah, looks like the MC monad is just a wrapper around RNG -> a
18:29:27 <ivanm> adityam: the reason it doesn't by default is probably because you can do different things with the results
18:30:06 <SamB_XP_> ivan: not quite ...
18:30:37 <SamB_XP_> I'm pretty sure it threads the RNG through the whole computation ;-)
18:30:44 <adityam> ivanm: Thats how I understand it.
18:31:26 <ivanm> SamB_XP_: something like that though
18:31:47 <BMeph> Rooted trees are Creepy! o.O
18:31:52 <ddarius> @google probability monad
18:31:55 <lambdabot> http://www.randomhacks.net/articles/2007/10/02/probability-monads-at-hac-07-ii
18:31:55 <lambdabot> Title: Probability monads at Hac 07 II
18:32:18 <ddarius> BMeph: Most of the trees you see in CS are rooted.
18:35:25 <BMeph> ddarius: I'm skimming this paper showwing a bijection between T and N, involving P, the set of primes. It's like voodoo! =8*O
18:35:39 <lispy> I had a CS prof that claimed that either CS people see the world upside down or we're studying roots not trees.
18:36:18 <BMeph> (T being the set of rooted trees)
18:36:27 <lispy> (I don't think he had much of a career as a comedian...)
18:36:53 <lispy> BMeph: oh, there is a theorem in math about primes and trees...
18:36:58 <lispy> some sort of correspondence
18:37:23 <BMeph> Here's the paper, if anyone's interested: http://www.cs.ucsb.edu/~cappello/papers/bijections/p.pdf
18:37:24 <lambdabot> Title: A New Bijection between Natural Numbers and Rooted Trees
18:38:47 <lispy> BMeph: ugh...yeah I can't let my self get distracted by that :)  I glanced and now I'm putting it away :)
18:39:58 <BMeph> lispy: Heh-heh. :)
18:42:55 <BMeph> The only disappointing thing I see about it is that the sequence of trees corresponding to the sequence of numbers doesn't separate the vertices out monotonically (did I say that right).
18:44:57 <lispy> combinatorics are weird
18:45:33 <lispy> BMeph: this is a paper I did as an undergrad but didn't try to publish: http://files.codersbase.com/numberoftrees.pdf
18:45:35 <lambdabot> Title: Almost Tree-Like Plane Curves
18:46:00 <lispy> BMeph: it's more weirdness with curves that correspond to trees and then trying to count those
18:47:12 <adu> lispy: nice graphics
18:48:10 <lispy> adu: thanks, they were a pain :)
18:48:24 <lispy> Huyen and I had lots of bickering about them :)
18:48:26 <adu> looks like it :)
18:48:42 * lispy misses his hold math buddies from undergrad
18:49:01 <adu> I wish I had math buddies from undergrad
18:49:10 <adu> I just have math buddies from a coffee shop :)
18:53:53 * byorgey <3 combinatorics =)
18:54:04 <adu> byorgey!
18:54:08 <byorgey> adu!
18:54:12 <byorgey> how goes it?
18:54:17 <adu> good
18:54:42 <BMeph> lispy: Interesting! :)
18:54:58 <byorgey> lispy: neat
18:55:01 <adu> I've been slowing down as it gets colder, but it just means I think more thoroughly about the hard questions :)
18:55:14 <byorgey> sounds like a good tradeoff =)
18:56:06 <lispy> byorgey: hey, how's school?
18:56:20 <byorgey> hey lispy, school's great!
18:57:19 <byorgey> I get to spend all day learning about cool stuff
18:57:29 <lispy> oh, such as?
18:57:34 <lispy> you're studying PL theory right?
18:57:41 <byorgey> which is pretty much the same as last year, except now I don't have to feel guilty about not getting real work done ;)
18:57:48 <lispy> haha
18:57:50 <lispy> right on
18:58:00 <lispy> should we move to #haskell-blah?
18:58:04 <byorgey> ok, sure
18:58:58 <jsn> so, i've come up with a version of    manyTill    that recovers from errors
18:59:00 <jsn> http://hpaste.org/11718
18:59:16 <jsn> to make it actually record the errors would take some doing
18:59:39 <jsn> i think i'd actually need to change    fail
19:07:53 <pumpkin_> is there a stringToInteger function that takes "123" and returns 123?
19:08:07 <dons> read
19:08:13 <dons> ?hoogle String -> a
19:08:14 <lambdabot> Prelude error :: String -> a
19:08:14 <lambdabot> Debug.Trace trace :: String -> a -> a
19:08:14 <lambdabot> Distribution.ReadE readEOrFail :: ReadE a -> String -> a
19:08:22 <dons> ?hoogle+
19:08:22 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
19:08:22 <lambdabot> Prelude read :: Read a => String -> a
19:08:22 <lambdabot> Text.Read read :: Read a => String -> a
19:08:29 <dons>  Prelude read :: Read a => String -> a
19:08:48 <dons> see how you described the type in terms of a transformation on sample values?
19:08:48 <dmwit> ?hoogle String -> Int
19:08:48 <lambdabot> Prelude read :: Read a => String -> a
19:08:48 <lambdabot> Text.Read read :: Read a => String -> a
19:08:48 <lambdabot> Prelude error :: String -> a
19:08:58 <dons> if you could write down the type, hoogle can find it for you
19:09:03 <dons> good thinking, dmwit
19:09:12 <dons> so its a matter of encoding 'what this should do' as a type.
19:11:37 <pumpkin_> thanks
19:19:04 * byorgey distributes chocolate lambdas
19:20:38 <dolio> @quote qwe1234
19:20:39 <lambdabot> qwe1234 says: check out 'complexity theory', it's all there.
19:23:34 <mmorrow> @nixon
19:23:35 <lambdabot> If you think the United States has stood still, who built the largest shopping center in the world?
19:23:54 <mmorrow> @nixon
19:23:54 <lambdabot> I brought myself down. I impeached myself by resigning.
19:26:55 <BMeph> Off to shop, see you guys when I get home.
19:29:03 <dons> ?users
19:29:03 <lambdabot> Maximum users seen in #haskell: 536, currently: 469 (87.5%), active: 16 (3.4%)
19:29:56 <mmorrow> @let mutual f g a = f a (\b -> g b (\a -> mutual f g a))
19:29:56 <lambdabot>  Defined.
19:30:20 <mmorrow> @type let unfoldr f = mutual (\a k -> (k . f) a) (\m k -> maybe [] (\(b,a) -> b : k a) m) in unfoldr
19:30:20 <L3v1> hi all.
19:30:21 <lambdabot> forall t2 a. (t2 -> Maybe (a, t2)) -> t2 -> [a]
19:30:49 <mmorrow> @type list
19:30:53 <lambdabot> Not in scope: `list'
19:30:53 <mmorrow> hi
19:31:13 <mmorrow> @let list nil _    [] = nil ; list _ cons (x:xs) = cons x xs
19:31:14 <lambdabot>  Defined.
19:31:44 <L3v1> is there any doc about using c-like buffer in haskell ? e.g. to call hGetBuf :: Handle -> Ptr a -> Int -> IO Int
19:32:45 <mmorrow> the source code may be the best ref
19:35:48 <dons> is that valid?
19:36:05 <dons> > let plus = (+) in (2 `plus`) 7
19:36:07 <lambdabot>   9
19:36:23 <dons> find under 6.10. so something record-ish
19:37:29 <dons> ah ha yes.
19:37:55 <dons> no.
19:38:15 <ivanm> dons: I must say, I like the reviews for RWH on o'reilly's site
19:38:28 <dons> oh?
19:38:37 <ivanm> http://oreilly.com/catalog/9780596514983/index.html
19:38:42 <lambdabot> Title: Real World Haskell | O'Reilly Media
19:39:12 * Samy will have his library order it :-P
19:39:15 <ivanm> you might want them to update your author page though ;-)
19:41:18 <Samy> $50 :/
19:42:27 <pizza> gotta lose money to make money
19:44:58 <dolio> $50 isn't that bad. You get over 700 pages of book for that!
19:47:19 <lament> "this book will expand your mind"
19:47:57 <lament> i will use mine for rolling joints!
19:48:08 <TOLUanckA> hooray!
19:50:43 <noecksit> does anyone have any good tips for writing an abstract for haskell presentation?
19:51:03 <noecksit> introductory basic one
19:53:20 <mmorrow> L3v1: here's an example and a mini test prog using hGetBuf: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=425
19:56:24 <mmorrow> L3v1: there's also this hackage pkg that wraps the C read,write,open,close http://hackage.haskell.org/cgi-bin/hackage-scripts/package/c-io
19:56:25 <lambdabot> Title: HackageDB: c-io-0.1.0
20:25:32 <jinjing> @bot
20:25:32 <lambdabot> :)
20:25:38 <shapr> @yow
20:25:39 <lambdabot> Yow!  I want my nose in lights!
20:32:03 <mmorrow> @yarrr
20:32:03 <lambdabot> I heard andersca is a pirate
20:32:09 <shapr> yay!
20:32:21 <mmorrow> @yow?
20:32:21 <lambdabot> What PROGRAM are they watching?
20:38:24 <L3v1> ah, i dont remember how to specify values for each name for enum type. is there any syntax sugar ?
20:40:13 <dmwit> deriving Enum?
20:40:19 <L3v1> yes.
20:40:31 <dmwit> I don't understand your question.
20:40:57 <roconnor> I suspect you answered his question.
20:40:59 <roconnor> :D
20:41:25 <dmwit> \o/
20:41:55 <L3v1> likely c code : typedef enum { foo=0x0A, bar=0x20 } blah_t;
20:42:14 <roconnor> oh
20:42:18 <dmwit> data Foo = Foo | Bar
20:42:24 <L3v1> then, fromEnum foo = 0x0A..
20:42:37 <dmwit> instance Enum Foo where toEnum 0x0a = Foo; toEnum 0x20 = Bar
20:42:38 <dmwit> yeah
20:42:45 <dmwit> ?src Enum
20:42:45 <lambdabot> class  Enum a   where
20:42:45 <lambdabot>     succ                     :: a -> a
20:42:45 <lambdabot>     pred                     :: a -> a
20:42:45 <lambdabot>     toEnum                   :: Int -> a
20:42:45 <lambdabot>     fromEnum                 :: a -> Int
20:42:47 <lambdabot> [3 @more lines]
20:42:59 <dmwit> ?more
20:42:59 <lambdabot>     enumFrom                 :: a -> [a]
20:42:59 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
20:42:59 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
20:43:09 <dmwit> Those are the functions you have to implement if you want a custom Enum instance.
20:43:15 <b7j0c> vague and general question - will ffi see any improvement in ghc 6.10?
20:43:15 <pumpkin_> @src Char
20:43:16 <lambdabot> data Char = C# Char#
20:43:35 <dmwit> b7j0c: I'm not aware of any changes to the FFI specs; what were you hoping for?
20:43:44 <b7j0c> because i get semi-random crashes with the curl stuff and its annoying
20:43:54 <roconnor> BTW, this won't be the same as the c code, because unsafe casts of Foo and Bar won't return 0x0a nor 0x20
20:43:59 <pumpkin_> how smart is the GHC optimizer? if I make two identical calls in a given expression will it only make the call once in the generated code?
20:44:04 <roconnor> ... why you want to do unsafe casts, I don't know. :)
20:44:18 <b7j0c> i have a small fastcgi program i use to generate my "home page"...there is a 50/50 chance it will coredump
20:44:22 <dmwit> pumpkin_: Look at the Core to find out for sure.
20:44:35 <dmwit> pumpkin_: You can also specify sharing with "let" clauses.
20:44:39 <dmwit> (That's what they're for.)
20:44:43 <pumpkin_> yeah, I know
20:44:49 <roconnor> pumpkin_: I'm told that GHC doesn't usually optimize these things :(
20:44:52 <pumpkin_> just wanted to know if it was smart even if I didn't tell it they were shared
20:44:57 <L3v1> o, yes, thanks alot.. it seems that i have to implement the name-value-map by hand..
20:45:07 <pumpkin_> it would need some sort of "maximum common subexpression" evaluation
20:45:14 <b7j0c> its sad when you go back to c coding for STABILITY!!
20:45:16 <roconnor> pumpkin_: people (rightly) fear these optimisations will cause space leaks.
20:45:17 <pumpkin_> but it's something that could definitely be done in functional
20:45:25 <pumpkin_> space leaks?
20:45:34 <roconnor> pumpkin_: to be sure, you need to use a let clause.
20:45:50 <dmwit> b7j0c: I'm obviously not an expert, but it sounds like something is very wrong.
20:45:57 <pumpkin_> yeah, it was just me being curious rather than looking for ways to program
20:46:01 <roconnor> pumpkin_: your two clause might reduce to a very large expression.
20:46:03 <b7j0c> i agree dmwit
20:46:11 <pumpkin_> thinking of how functional code is more easily optimizable than imperative
20:46:23 <dmwit> b7j0c: I have never had e.g. Gtk2Hs crash on me, and it makes extensive use of the FFI.
20:46:25 <roconnor> pumpkin_: by using two calls each instance of the can be cleaned up
20:46:37 <roconnor> pumpkin_: and your memory footprint will stay small
20:46:39 <dmwit> b7j0c: This suggests a bug either in your fastcgi library, your curl library, your code, or somewhere else.
20:46:41 <dmwit> b7j0c: Does that help?
20:46:43 <dmwit> =)
20:46:43 <roconnor> pumpkin_: but if the optimizer shares this
20:46:45 <b7j0c> but frankly a coredump (instantly upon program invocation) is something that seems out of my control
20:46:51 <dmwit> b7j0c: (I'm just saying I doubt it is the FFI's fault.)
20:46:57 <roconnor> pumpkin_: then it may have to hold on to the result for a long time
20:47:04 <pumpkin_> yeah, true
20:47:07 <roconnor> pumpkin_: making a huge memory footprint.
20:47:21 <roconnor> pumpkin_: GHC can't tell if this is the case, and is conservative.
20:47:22 <b7j0c> well actually dmwit, i got some traction suggesting to other people that this was a problem...the ghc people accepted a bug based on it
20:47:38 <roconnor> pumpkin_: not to say GHC won't ever do sharing, but it is rare.
20:47:47 <b7j0c> my fastcgi library is also a haskell lib
20:47:51 <roconnor> pumpkin_: I'm not sure what circumstances it will do the sharing.
20:47:59 <dmwit> b7j0c: I guess checking out that bug on Trac would be the surest way to find out if it is fixed in 6.10, then.
20:48:17 <jsn> b7j0c: what is the bug?
20:48:26 * roconnor wonders if it will share expressions of type Double or Int or Word
20:48:30 <b7j0c> i would have to look it up jsn, its bee a few months
20:48:32 <roconnor> which are guarenteed to be small
20:48:50 <b7j0c> but look for a bug with "b7j0c" if you are searching, it is the only one i have ever reported
20:49:01 <dmwit> roconnor: They are guaranteed to be no such thing, unfortunately.
20:49:08 <dmwit> roconnor: I discovered this the hard way recently.
20:49:35 <dmwit> laziness--
20:49:36 <b7j0c> i could just go back to using Network.HTTP...but its api seems poorly designed
20:51:10 <roconnor> dmwit: they aren't guarenteed to be small?
20:51:21 <rwbarton> dmwit: I was about to say that too, but I'm not sure that matters here.
20:51:33 <roconnor> I was thinking if that is true or not
20:51:42 <roconnor> if you could partially evaluate a thunk
20:51:45 <dmwit> Thunks upon thunks upon thunks...
20:51:47 <roconnor> it could become very big
20:51:51 <roconnor> ah yes
20:51:55 <roconnor> if you are summing a list
20:52:01 <roconnor> and someone else forces that list
20:52:06 <roconnor> it can become big
20:52:09 <roconnor> and stay big
20:52:28 <roconnor> because it normalizes the list without completing the sum.
20:52:42 <dmwit> Or if you are using an STRef to count something that happens a lot, but only printing the count at the end of a long computation.
20:52:44 <dmwit> =/
20:52:58 * roconnor nods
20:53:15 <dmwit> I had strictness annotations all over my program... and I still got bitten.
20:53:29 <rwbarton> dmwit: But if I have two expressions of the form 1+(1+(1+...)) and I share them, it can't increase my memory usage, right?
20:53:31 <roconnor> well
20:53:36 <roconnor> dmwit: that isn't really a sharing issue.
20:53:43 <dmwit> right
20:54:19 <ddarius> dmwit: The trick isn't putting strictness annotation willy-nilly, it's putting them in the right places.
20:54:26 <dmwit> rwbarton: The problem with sharing isn't usually extra memory usage.
20:54:32 <roconnor> functional programming always disappoints me
20:54:41 <roconnor> rwbarton: oh?
20:54:43 <roconnor> er
20:54:46 <roconnor> dmwit: oh?
20:54:59 <dmwit> I mean.
20:55:21 <dmwit> The problem is holding a reference longer, not that you're using more memory by having one copy instead of two.
20:55:40 <rwbarton> Well, that may affect the peak memory usage of the program
20:55:58 <dmwit> Yeah, what I said was worded incorrectly.
20:56:30 * dmwit goes to bed before he's even more catastrophically wrong
20:56:35 <roconnor> :D
20:57:08 <rwbarton> roconnor: were you giving an example where sharing an Int can increase peak memory usage?
20:59:04 <rwbarton> Anyways, CSE doesn't seem like a big deal to me.  It's usually easy enough to give a name to the common subexpression.
20:59:16 <rwbarton> I'd rather have the compiler behave predictably regarding sharing.
20:59:29 <roconnor> rwbarton: I have an idea
20:59:55 <roconnor> f (sum l) l (sum l)
21:00:37 <roconnor> rwbarton: I often find sharing subexpression obscures the code.
21:00:49 <roconnor> so I don't bother with it.
21:00:57 <roconnor> because usually it isn't signifigant.
21:01:01 <dmwit> That's probably wise.
21:01:19 <roconnor> I rather the complier did the sharing
21:01:26 <dmwit> Wait for it to be slow, then do profiling.
21:01:28 <roconnor> but I have bigger problems to worry about :)
21:01:29 <dmwit> That's the smart way.
21:01:39 <roconnor> like >>=
21:01:42 <roconnor> :D
21:01:49 <dmwit> heh
21:02:02 <roconnor> for that ICFP contest the year before this one
21:02:09 <roconnor> profiler said >>= was slowest
21:02:16 <roconnor> I thought it was too simple to be slow
21:02:22 <roconnor> ... turns out it was slow.
21:02:43 <roconnor> I thought the profiler was lying because optimisations was on.
21:02:44 <dmwit> ?remember roconnor I thought it was too simple to be slow ... turns out it was slow.
21:02:44 <lambdabot> I will remember.
21:02:48 <roconnor> that'll teach me.
21:09:29 <roconnor> It's okay about the slow >>=
21:10:01 <roconnor> I wouldn't have never thought to use the CPS transform if I hadn't overheard ddarius et al. talking about it.
21:15:04 <jsn> roconnor: does a slow    >>=    mean do notation is generally slow?
21:15:15 <roconnor> jsn: my paritcular instance
21:15:26 <roconnor> I think it was mostly the statemonad's fault
21:15:28 <jsn> oh, you wrote your own    ..+
21:15:32 <jsn> eh
21:15:38 <jsn> >>=
21:15:40 <roconnor> but I forget which part of the monad transformer stack was to blame
21:17:16 <roconnor> http://www.haskell.org/haskellwiki/Performance/Monads#Use__Continuation_Passing_Style
21:17:18 <lambdabot> Title: Performance/Monads - HaskellWiki, http://tinyurl.com/62khz4
21:20:46 <lispy> oh oleg
21:20:55 <lispy> he just had to link dependent types with TH in my brain
21:21:00 <lispy> now I'm stuck thinking about that
21:23:32 <L3v1> if i have a data type (may any), already an instance of class A, how to instance it to class B?
21:23:53 <lispy> instance A a => B a where
21:24:00 <L3v1> instance A a => B a where ?
21:24:35 <L3v1> o, i encounted an error.
21:24:47 <lispy> wwhere to begin explaining
21:24:49 <L3v1> (All instance types must be of the form (T a1 ... an)
21:24:50 <L3v1>  where a1 ... an are type *variables*,
21:24:50 <L3v1>  and each type variable appears at most once in the instance head.
21:24:50 <L3v1>  Use -XFlexibleInstances if you want to disable this.)
21:25:02 <lispy> I would need to see your code, hpaste.org
21:25:19 <rwbarton> do you want *every* instance of A to be an instance of B?
21:26:23 <L3v1> http://hpaste.org/11719
21:26:27 <L3v1> yes.
21:27:41 <lispy> L3v1: I don't really see a problem except that I wouldn't expect (:[]) . code
21:27:47 <lispy> I wouldn't expect that to type check
21:27:51 <rwbarton> so... without overlapping instances, you can't have any other instances of B, in which case you may as well merge B into A
21:27:56 <lispy> :t \code -> (:[]) . code
21:27:58 <lambdabot> forall b a. (a -> b) -> a -> [b]
21:28:21 <L3v1> o, i mistake, (:[]) . chr . code
21:28:40 <L3v1> the same error.
21:29:09 <rwbarton> Just turn on the option it suggests, that one is harmless.
21:29:25 <lispy> L3v1: well, I can't see how that error is in your code
21:29:30 <rwbarton> (It's just not valid in Haskell 98.)
21:29:57 <rwbarton> (I mean, your code isn't valid in Haskell 98, for the reason it gave you.)
21:31:23 <lispy> L3v1: I kinda wonder about these type classes too.  do you really have different types of Instruct?
21:32:14 <lispy> (maybe you're writing a cross compiler and the op codes change per instruction set or something...I dunno.)
21:36:19 <L3v1> eh, im going to try the opt.
21:36:35 <L3v1> lispy: i do have some Instruct data types.
21:45:22 <ryant5000> What's the most efficient way of determining which nodes in a graph are no longer connected after the removal of one (directed) link?
21:45:54 <ryant5000> in other words, if you had to run the garbage collector after each modification to a reference, what's the most efficient way to do that?
21:45:58 <lispy> ryant5000: could you start from mininum spanning tree?  iirc that's pretty efficient to find
21:46:38 <L3v1> ok, it is passed, though i donno why not and how works.. thanks..
21:46:47 * lispy is not a Graph Theory Algorithm Export (GTAE)
21:47:17 <ryant5000> lispy: i'm not totally sure how that would work, but it is an interesting way to start
21:47:35 <L3v1> i just turn on any options compiler askd.
21:47:51 <ryant5000> lispy: i suppose if the link in question is not a member of the minimum spanning tree, then it can't result in garbage
21:48:12 <lispy> ryant5000: well, it seems like a connected graph would have at least one minimum spanning tree, but a disconnected one would have to have 2 or more, right?
21:48:26 <ryant5000> lispy: yeah
21:48:37 <ryant5000> lispy: but i don't want to have to regenerate the spanning tree from scratch every time
21:48:55 <lispy> But, what bugs me is that you updated one reference.  There must be a way that is O(1) given that constraint
21:49:01 <lispy> exactly
21:49:22 <ryant5000> lispy: i don't know whether there's an O(1) algorithm, because if there were i suspect it'd be used for "deterministic garbage collection" all the time
21:49:30 <ryant5000> lispy: but there might be something *relatively* cheap
21:49:40 <ryant5000> (i.e.: cheap enough for my application here)
21:49:56 <lispy> ryant5000: Well, I was thinking, if you started with the graph and one edge was removed you should be able to do something super cheap.
21:50:05 <lispy> I thought cheap might even be O(1) in that constrained setting
21:50:05 <ryant5000> yeah, i think so
21:50:35 <jsn> > foldr const "no" $ guard True >> ["yes"]
21:50:37 <lambdabot>   "yes"
21:50:46 <jsn> > foldr const "no" $ guard False >> ["yes"]
21:50:48 <lambdabot>   "no"
21:51:01 * lispy wonders if jsn is working on a proof that no means yes...
21:51:58 <ryant5000> lispy: perhaps
21:54:27 <lispy> ryant5000: if you had all the minimum spanning trees and removing that edge makes all the MSTs disconnected then you have your answer right?
21:55:01 <lispy> ryant5000: so, assuming you can handle the space trade off (storing all those MSTs) you could probably amoratize the cost of this check and the maintenance of the MSTs
21:55:10 <ryant5000> well, first of all, there's no concept of "minimum" - our edges are undirected
21:55:15 <ryant5000> but that doesn't really affect your point
21:55:24 <ryant5000> sorry, unweighted, not undirected
21:55:31 <ryant5000> but *then*, they *are* directed
21:55:37 <ryant5000> which makes spanning tree more of an issue
21:56:00 <lispy> yeah, I see what I'm saying wrong.  Good point
21:56:25 <lispy> My brain was thinking that minimum applied to graph, and that a spanning tree is a "minimal" graph ...anyway
21:57:01 <lispy> oh, but maybe the thing I suggested doesn't make that much sense
21:57:04 <ryant5000> ok so we have a root node
21:57:24 <lispy> (if you remove one edge from any of the spanning trees it would disconnect things)
21:57:32 <ryant5000> (right)
21:58:21 <lispy> oh so you have a directed rooted graph?
21:58:28 <ryant5000> yeah
21:58:28 <lispy> unweighted
21:58:31 <ryant5000> yes
21:58:56 <lispy> stupid cycles :)
21:59:04 <ryant5000> yeah exactly :P
21:59:17 <ryant5000> what if we stored, in each node, a pointer to each of the nodes that are "closer" to the root node
21:59:32 <lispy> (cycle detection is fast, BTW)
22:00:09 <pumpkin_> speaking of cycle detection
22:00:12 <ryant5000> yeah
22:00:16 <lispy> (just trace the cycle at one step and 2 step in parallel and look for same node)
22:00:29 <pumpkin_> is there a good graph datastructure that provides fast cycle prevention (when updating the graph)
22:00:51 <lispy> pumpkin_: we have FGL on hackage...that's a nice graph lib, but I have no idea if it does what you want
22:00:57 <ryant5000> pumpkin_: if you've got a root, you can just store the distance from the root in each node
22:01:11 <ryant5000> oh you mean a pre-existing datastructure; i have no idea
22:01:22 <pumpkin_> ryant5000: I'm talking about a generic datastructure, without necessarily a root
22:01:28 <pumpkin_> just something I can add edges and vertices to
22:01:31 <lispy> pumpkin_: http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
22:01:33 <ryant5000> yeah, i'm not sur ethen
22:01:34 <lambdabot> Title: Functional Graph Library/Haskell
22:01:48 <pumpkin_> but that I could check quickly whether my incremental update created a cycle
22:01:49 <pumpkin_> thanks lispy
22:01:57 <pumpkin_> I'm mostly interested just theoretically
22:02:17 <pumpkin_> whether such a datastructure exists and if so how it works
22:02:31 <pumpkin_> it's pretty hard to do a google search for stuff like that
22:02:38 <ryant5000> yeah
22:03:38 <rwbarton> pumpkin_: what does "prevention" mean?
22:03:47 <rwbarton> pumpkin_: you might want the union-find algorithm of Tarjan
22:03:48 <pumpkin_> well, efficient detection
22:03:56 <pumpkin_> for incremental addition of edges
22:04:28 <rwbarton> Yeah, that algorithm will tell you whether an edge you're adding joins two vertices that are already in the same connected component.
22:04:31 <ryant5000> ok so here's what i've come up with so far
22:04:40 <pumpkin_> rwbarton: interesting, I'll check it out then, thanks
22:04:42 <ryant5000> i basically need to keep an updated topological sort of the graph
22:04:49 <ryant5000> except that the graph is allowed to have cycles
22:04:56 <ryant5000> which means a topological sort may be impossible
22:05:10 <pumpkin_> topological sort of cycles is fine
22:05:14 <pumpkin_> but the edges might go "backwards"
22:05:28 <ryant5000> pumpkin_: then how is it topologically sorted? :P
22:05:48 <pumpkin_> well, it's how you can detect cycles if you need to :P
22:05:56 <ryant5000> right
22:05:58 <ryant5000> but what i want to do instead
22:06:06 <ryant5000> is do a topological sort of an implicit overlay of the graph
22:06:16 <pumpkin_> hmm
22:06:18 <ryant5000> in which each cycle of the underlying graph is replaced by a single node
22:06:19 <pumpkin_> bbiab
22:06:26 <ryant5000> now we have a DAG, and we know what to do
22:06:27 <pumpkin_> ah, interesting
22:06:44 <ryant5000> so now all i need to do is make the identification of cycles fast
22:11:58 <ryant5000> ok i've boiled this down to a simpler question now:
22:12:15 <ryant5000> is there an efficient way to store a partial ordering on a set and do comparisons using it?
22:16:52 <rwbarton> ryant5000: you probably want to look at papers like this one: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.9853
22:16:53 <lambdabot> Title: Online algorithms for topological order and strongly connected components - Cite ...
22:18:42 <mmorrow> http://moonpatio.com/images/aplkeyb.gif
22:18:45 <mmorrow> heh
22:20:08 <mmorrow> rwbarton: nice find
22:25:15 <dibblego> what data type has both Integral and Fractional?
22:25:38 <dibblego> @type let interest principal rate term freq = principal * 1 + (rate / 100 / freq) ^ (term * freq) in interest
22:25:39 <lambdabot> forall a. (Fractional a, Integral a) => a -> a -> a -> a -> a
22:26:11 <lispy> ?instances Integral
22:26:12 <lambdabot> Int, Integer
22:26:17 <lispy> ?instances Fractional
22:26:18 <lambdabot> Double, Float
22:26:31 <lispy> dibblego: it's disjoint if you only go by prelude types
22:26:53 <dibblego> then how do you perform the computation I'd like?
22:27:10 <lispy> :t (^)
22:27:11 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
22:27:16 <lispy> :t (**)
22:27:17 <lambdabot> forall a. (Floating a) => a -> a -> a
22:27:30 <dibblego> oh
22:27:33 <dibblego> > 2 ** 3
22:27:35 <lambdabot>   8.0
22:27:39 <dibblego> aah thanks
22:27:44 <lispy> :)
22:28:10 <lispy> :t let i p r t f = p * 1 + (r / 100 / f) ** (t * f) in i
22:28:11 <lambdabot> forall a. (Floating a) => a -> a -> a -> a -> a
22:29:38 <dibblego> (1 + (r / 100 / f)) -- by the way I missed these parens
22:37:34 <ryant5000> rwbarton: thanks for that link, it is *precisely* one of the things i was wondering about
22:42:29 <pumpkin_> is there a built-in modular exponentiation algorithm?
22:42:51 <roconnor> nope
22:43:24 <rwbarton> Well, kind of--(^) is if you define a modular arithmetic Num instance
22:44:15 <pumpkin_> is that something standard? I asked about it a while ago and people said that there wasn't anything obvious that would give me a finite field
22:44:39 <roconnor> I suppose hackage may have something
22:44:51 <rwbarton> If you know the prime at compile time, then of course it's easy.
22:45:14 <pumpkin_> yeah
22:45:31 <pumpkin_> I wanted something a little more general, and that did modular exponentiation intelligently
22:46:58 <rwbarton> Otherwise you can use the type-level package and roll your own (I have).  I haven't seen a pre-packaged modular arithmetic type class on hackage
22:47:59 <rwbarton> The type magic is a little tricky, but the result is nice; you get fast operations, compile-time checking that you don't mix numbers modulo two different primes, and you can use numeric literals as residue classes
22:48:11 <pumpkin_> would you mind sharing the basics of your approach? I'm just not sure how to get started on it
22:48:14 <pumpkin_> yeah, that does sound nice
22:48:42 <roconnor> pumpkin_: it's not for the faint of heart. :)
22:48:54 * pumpkin_ pounds his chest
22:49:04 <pumpkin_> can I see it now? :P
22:49:32 <rwbarton> let me throw something together that uses the type-level package (I made mine from scratch, and it has some dependencies)
22:49:40 <roconnor> @go haskell binary type arithmetic
22:49:43 <lambdabot> http://okmij.org/ftp/Haskell/number-parameterized-types.html
22:49:43 <lambdabot> Title: Haskell Programming: Types that depend on numbers
22:50:13 <gopik> Hi, I have a question on visual haskell. I see that it only works with Visual Studio 2003/2005. Is there anything preventing it to run on Visual Studio 2008
22:50:39 <pumpkin_> that looks interesting roconnor, it also addresses another question I had a while back :P thanks
22:50:44 <pumpkin_> rwbarton: thanks, that would be great, no rush though
22:50:50 <pumpkin_> I hang out in here a lot
23:04:01 <rwbarton> pumpkin_: OK, here is the basic idea: http://hpaste.org/11720
23:04:40 <pumpkin_> thanks, I'll try to absorb it!
23:06:43 <pumpkin_> only bit I don't get is the reifyIntegral
23:07:19 <rwbarton> Yes, that is where all the magic happens :)
23:07:25 <pumpkin_> yup
23:08:12 <rwbarton> (hmm, I didn't need FlexibleInstances.)
23:10:49 <rwbarton> I did a similar test comparing the speed (of some similar code) to a hand-written modular exponentiation algorithm and they were equally fast
23:11:00 <rwbarton> s/similar test/informal test/
23:11:08 <pumpkin_> as in by repeated squaring or something like that?
23:11:21 <rwbarton> right, same algorithm
23:12:30 <rwbarton> I just took the source for (^) and inserted `mod` p everywhere
23:12:32 <pumpkin_> so can you explain what reifyIntegral does? or just what reify means? from latin I'd guess thingify but that doesn't tell me much
23:12:53 <rwbarton> I don't know what reify means either.  It seems like an overused term to me.
23:13:46 <rwbarton> Here, reifyIntegral effectively takes a number m and produces a class dictionary for an instance of Nat that we'll call 'b' such that toNum (undefined :: b) = m
23:14:47 <pumpkin_> hmm
23:14:54 <lispy> So what's up with QuickCheck
23:14:57 <lispy> Home pagehttp://www.haskell.org/QuickCheck/
23:15:02 <lispy> that's on hackage, but it's a 404 for me
23:15:12 <lispy> sorry, sloppy paste: http://www.haskell.org/QuickCheck/
23:15:23 <lispy> but I also see this: http://darcs.haskell.org/QuickCheck
23:15:24 <lambdabot> Title: Index of /QuickCheck
23:15:30 <lispy> The version on hackage is 2.1
23:15:35 <lispy> But the one in the darcs repo is 2.0
23:15:39 <lispy> So what's up?
23:15:46 <pumpkin_> rwbarton: so it's basically finding the "mod n" version of the integer?
23:15:48 <rwbarton> the latest version on hackage points to http://www.cs.chalmers.se/~koen
23:15:52 <lambdabot> Title: Koen Claessen
23:16:19 <rwbarton> Well, the "mod" part is being handled by the Num instance I wrote.
23:16:26 <pumpkin_> yeah
23:16:29 <rwbarton> Basically, it's implemented something like this
23:16:43 <pumpkin_> I've seen the source for reifyIntegral, it's um
23:16:43 <rwbarton> It's easy if we know that the number n should be at compile time
23:16:51 <lispy> rwbarton: really?  I just looked there
23:17:10 <rwbarton> lispy: it changed in 2.1 -> 2.1.0.1
23:17:10 <lispy> rwbarton: yes, thanks
23:17:13 <lispy> rwbarton: my bad :)
23:17:32 <harblcat> HI all. I'm having a problem with using randomRs.
23:17:53 <rwbarton> pumpkin_: What we'd like to have is a type (ModN n) that depends on a value.  Or more precisely, the Num instance should depend on a value.
23:17:58 <lispy> rwbarton: hmm...but not QC repo at that address it seems
23:18:05 <pumpkin_> rwbarton: yup
23:18:17 <rwbarton> Well, haskell lets us have instances that depend on other types, but not values (at least directly)
23:18:28 <pumpkin_> yeah
23:18:58 <pumpkin_> (was that an explicit choice btw? templates in c++ for example allow you to pass in an integer too)
23:19:00 <harblcat> I'm trying to make a list of numbers in the range 1 to 6, and for some reason randomRs is giving me an error
23:19:09 <rwbarton> so you can imagine something like this: class Nat a where toInteger :: a -> Integer; data N31337; instance Nat N31337 where toInteger _ = 31337
23:19:37 <rwbarton> pumpkin_: there are languages that allow types to depend on values.  It's called dependent typing, and it tends to make your type system turing complete.
23:19:46 <pumpkin_> ah
23:20:02 <pumpkin_> I thought someone proved haskell's typing system was turing equivalent
23:20:21 <pumpkin_> anyway, sorry, that was a distraction
23:20:55 <rwbarton> But anyways, if I had a type for every integer, I could make a general "ModN n" type, but I'd still have to choose the value of n at compile time wherever I used it.
23:20:57 * mmorrow settles for template-haskell until he can has dependent types
23:21:17 <rwbarton> Also, having a type for every integer is kind of unwieldy.
23:21:32 <pumpkin_> yeah
23:21:40 <rwbarton> So, instead we represent integers by their digits or whatever, using type constructors.
23:22:19 <rwbarton> data D0 a; data D1 a; ...; data D9 a; instance Nat x => Nat (D4 x) where toInteger _ = read ("4" ++ toInteger (undefined :: x))
23:22:38 <rwbarton> and I probably want data Z; instance Nat Z where toInteger _ = 0
23:23:05 <abbe> hi all
23:23:07 <rwbarton> OK, so now I can write x :: Nat (D3 (D1 (D3 (D3 (D7 Z))))) instead
23:23:12 <L3v1> @help
23:23:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:23:25 <pumpkin_> rwbarton: sneaky :P
23:23:26 <L3v1> @list
23:23:26 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:23:33 <abbe> :t map (putStrLn . show) [10,20,30,40]
23:23:35 <lambdabot> [IO ()]
23:23:39 <rwbarton> That gets around having to have infinitely many types.
23:23:43 <pumpkin_> rwbarton: feels like a hack though :P
23:23:48 <pumpkin_> but still neat
23:23:50 <abbe> ^^^^ how do I execute above statement in 'main' function
23:24:03 <L3v1> :t mapM_ print [10..]
23:24:03 <pumpkin_> abbe: stick it in a do?
23:24:04 <lambdabot> IO ()
23:24:06 <mmorrow> hehe, if 31337 is actually a prime i don't know what i'll do
23:24:16 <rwbarton> pumpkin_: Finally, we can use polymorphic recursion to effectively build up the type D3 (D1 (D3 (D3 (D7 Z)))) at runtime from the integer 31337
23:24:20 <rwbarton> mmorrow: it is!
23:24:27 <pumpkin_> :P
23:24:39 <mmorrow> rwbarton: leet!!
23:24:43 <rwbarton> pumpkin_: This is what the source of reifyIntegral does, and I think it should seem more straightforward now
23:25:29 <rwbarton> (The representation used by that package isn't exactly the one in my example, though)
23:25:32 <abbe> pumpkin_: tried that already, but still getting that issue about [IO()] != IO()
23:25:44 <abbe> s/()$/ a/
23:25:45 <pumpkin_> abbe: sequence_ I think?
23:26:04 <rwbarton> pumpkin_: And yes, in a sense this is all a hack to get around a lack of dependent typing
23:26:06 <pumpkin_> rwbarton: okay, why does reifyIntegral take a function though? I can understand taking the integral to "reify"
23:26:22 <abbe> pumpkin_: thanks, that worked :)
23:26:29 <rwbarton> pumpkin_: Well, morally reifyIntegral takes an integer and returns a type
23:26:42 <rwbarton> pumpkin_: but Haskell doesn't have first-class types
23:26:44 <pumpkin_> but you can't return types explicitly?
23:26:45 <pumpkin_> yeah
23:26:51 <pumpkin_> ok makes more sense now
23:27:14 <rwbarton> pumpkin_: but it does have ad-hoc polymorphism, which allows a function to return different values when "passed" (type-level lambda) different types
23:27:24 <pumpkin_> so that whole thing is basically "coercing" the number to the ModN type through that function
23:27:56 <pumpkin_> @src (^)
23:27:57 <lambdabot> x ^ 0            =  1
23:27:57 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:27:57 <lambdabot>   where f _ 0 y = y
23:27:57 <lambdabot>         f x n y = g x n
23:27:57 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
23:27:59 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:28:01 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:28:21 <rwbarton> pumpkin_: right, it's taking a value of type Num a => a, and evaluating it at the instance a = ModN b
23:28:27 <pumpkin_> mmm
23:28:32 <pumpkin_> the lightbulb is coming on
23:29:07 <pumpkin_> could similar reification be done with n-tuples of digits?
23:29:17 <mmorrow> pumpkin_: in langs with dependent types, you can just map numbers directly to types instead of having to ride a unicycle along a tightrope while battling an unruly gang of monkey with knives
23:29:20 <pumpkin_> *digit types
23:29:20 <pumpkin_> that is
23:29:43 <rwbarton> @quote OlegFacts
23:29:44 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
23:29:46 <rwbarton> @quote OlegFacts
23:29:46 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
23:29:57 <pumpkin_> lol
23:30:09 <pumpkin_> who's Oleg?
23:30:14 <rwbarton> this method is an invention of the famous Oleg
23:30:25 <mauke> preflex: remember mmorrow in langs with dependent types, you can just map numbers directly to types instead of having to ride a unicycle along a tightrope while battling an unruly gang of monkey with knives
23:30:31 <mauke> @where oleg
23:30:31 <lambdabot> http://okmij.org/ftp/
23:30:34 <pumpkin_> by this method you mean the recursive type reification thing?
23:30:49 <rwbarton> right
23:31:20 <rwbarton> He's done a lot more related stuff, like the ability to "add" numbers represented by types and so on
23:31:35 <pumpkin_> that's the paper pasted earlier I think
23:31:41 <rwbarton> Yes, probably
23:31:45 <mmorrow> pumpkin_: oleg's site is a great resource
23:31:50 <pumpkin_> sounds like fun
23:32:18 <pumpkin_> is there a draft future haskell standard that includes dependent types?
23:32:30 <pumpkin_> or do people just accept it as not happening
23:32:47 <dons> there are new languages that included dependent types.
23:32:50 <pumpkin_> it's definitely an awesome mental exercise to do all this crazy stuff to get around the limitations
23:32:51 <dons> they're not versions of haskell though
23:33:07 <dons> Agda is one good one to look at
23:33:09 <mmorrow> i don't think that's on the horizon, but haskell seems to be the dependent-type-language-implementor's language of choice :)
23:33:31 <mmorrow> (for implementing said languages that it)
23:33:37 <mmorrow> s/it/is/
23:34:12 <mmorrow> pumpkin_: very true
23:34:37 <rwbarton> pumpkin_: BTW, I was under the impression that type-checking is only turing complete if you turn on AllowUndecidableInstances.  But I don't have a lot of confidence in that impression
23:34:38 <pumpkin_> :)
23:34:58 <pumpkin_> I think I may have confused it with the c++ template system which I was also looking at at the time
23:35:34 <pumpkin_> the mere fact that it can detect "infinite types" is probably a good indicator, although I haven't thought it through very hard
23:36:28 <mmorrow> rwbarton: i'm under that impression too, although the lengths/hackery one would have to go to to program at the type level a prog that at the value level would be just barely above trivial seems to me to be huge
23:37:00 <rwbarton> I think there's a lot of research that's gone into coming up with a type system that's as flexible as possible but *isn't* turing complete.
23:37:12 <pumpkin_> yeah, that would make sense
23:37:27 <rwbarton> So it wouldn't surprise me at all if C++ templates were turing complete (in fact, I know it is the case, but I don't know enough about them to know why)
23:38:28 <pumpkin_> http://homepage.mac.com/sigfpe/Computing/peano.html
23:39:55 <mmorrow> i think there's a place for both decideable /and/ undecideable type systems
23:40:36 <mmorrow> i mean, i would hope that if i'm using a proof assistant, if it passed the type checker it's guaranteed to be "correct"
23:41:07 <pumpkin_> http://en.wikipedia.org/wiki/List_of_undecidable_problems
23:41:17 <mmorrow> but on the other hand, programming things that actually do stuff using a non-turing complete lang would suck bigtime^2
23:41:42 <mmorrow> so why not allow this nonsuckery at the type level?
23:42:06 <mmorrow> (when it's desireable)
23:43:07 <rwbarton> This whole shenanigan could be avoided if it were possible to just construct dictionaries at run-time willy nilly.
23:43:28 <mmorrow> weehoo!
23:44:10 <mmorrow> the coolest part about the of the dependent type langs i've been reading about lately is that their able to completely erase types during compilation
23:44:59 <rwbarton> Gah, I can't even manage to write the Plus type class without undecidable instances.
23:45:21 <rwbarton> I wonder whether Oleg has worked out the computational power of ghc's type system - undecidable instances
23:45:58 <olsner> work out? he probably only has to look at it
23:47:10 <mmorrow> err, i think i used "undecideable" incorrectly above
23:47:18 <mmorrow> oh, n
23:47:23 <mmorrow>  /m
23:47:43 <mmorrow> too tired to compute
23:47:49 <mmorrow> night
23:58:42 <pumpkin_> rwbarton: anyway, thanks for all the help
