00:00:04 <pumpkin_> is there a "scientific computing" channel anywhere?
00:00:19 <fons> a set of processes*
00:00:52 <mmorrow> @pl \e l r -> either l r e
00:00:52 <lambdabot> flip (flip . either)
00:01:32 <fons> I have a list of process names and a function which executes a process cyclically, waiting for it to end
00:02:08 <Twey> fons: Just call forkIO on the monad that represents running the process
00:02:15 <fons> however, mapM_ doesn't do what I want because it runs sequentially and my program gets stuck executing the first process
00:03:12 <Twey> mapM_ forkIO
00:03:35 <fons> Twey: Uhm OK, thanks, for some reason I thought forkIO cound't be mixed with heavy processes
00:04:12 <Twey> It can be
00:04:37 <Twey> Plus, if you're talking external processes, the Haskell thread isn't really heavy — it's just interacting with the heavy process
00:06:10 <x6d65> If I want to read some data from a file to build a table, and that's the only I/O in the program, does it seem reasonable to use unsafePerformIO?
00:06:34 <Twey> x6d65: No
00:06:35 <Cale> Twey: s/monad/action/ ;)
00:06:46 <Twey> Right :)  Thanks
00:07:53 <x6d65> Twey: Why not?
00:07:56 <Cale> x6d65: main = do data <- readFile "myData"; let table = process data; print table
00:08:18 <Twey> x6d65: Because that's precisely what unsafePerformIO isn't for.
00:08:21 <Cale> x6d65: You'll have a main which looks something like that. Note that here 'data' is a string.
00:08:54 <Cale> x6d65: unsafePerformIO should be treated with the same gravity as modifying the compiler.
00:09:14 <Korollary> In this occasion it's not saving you anything anyway.
00:09:17 <x6d65> Twey: Simon Peyton Jones says one of the primary uses is "performing once-per-run input/output, as for configFileContents."
00:09:23 <Cale> x6d65: If you wouldn't otherwise have to modify the compiler to do what you're trying to do, then unsafePerformIO is not the right plan.
00:10:05 <pumpkin_> sounds pretty extreme
00:10:09 <pumpkin_> what does one use it for?
00:10:19 <Twey> Mostly, writing bindings.
00:10:25 <x6d65> pumpkin_:  Getting rid of the IO action.
00:10:26 <Cale> pumpkin_: Extend the evaluation model with new primitives, mostly.
00:10:43 <Cale> It creates values whose evaluation causes IO to execute.
00:11:22 <Twey> It should be used for things that are actually basically pure, but outside Haskell.
00:11:29 <luqui> Is it possible/safe to serialize a TypeRep?
00:11:34 <Cale> Which is something inherently unsafe due to, for instance, compiler optimisations that operate under the assumption that functions are pure.
00:11:59 <Twey> Config files do not fit that.  I've no idea what SPJ is on about in that one — it sounds like that quote may have been taken out of context.
00:12:03 <fons> Twey: Sorry to be a pain in the ass but could you have a look at this paste? http://hpaste.org/1193
00:12:12 <luqui> serialize = marshall = freeze, depending on where you're from
00:12:19 <pumpkin_> omg it's the fons!
00:12:27 <fons> no z
00:12:35 <pumpkin_> fons pietatis, of course!
00:12:35 <fons> :P
00:12:38 <dolio> 'Eeeeey.
00:12:38 <pumpkin_> ;)
00:12:54 <Cale> To be fair, you can actually use unsafePerformIO to do some pretty neat things if you know what you're doing, but if you're just doing normal IO, that's what the IO monad is for.
00:13:08 <x6d65> Twey: "Nevertheless, when the proof obligations are satisﬁed, unsafePerformIO can be extremely useful. In practice, I have encountered three very common patterns of usage:"
00:13:19 <x6d65> Performing once-per-run input/output, as for configFileContents.
00:13:25 <x6d65> Allocating a global mutable variable.
00:13:28 <ski_> (luqui : also "pickle")
00:13:29 <Cale> x6d65: I suspect that he wouldn't actually advocate that use.
00:13:32 <x6d65> Emitting trace messages for debugging purposes
00:13:33 <pumpkin_> :P
00:13:40 <Twey> Aye.
00:13:51 <Twey> 'Common' doesn't mean 'appropriate'.
00:13:52 <luqui> ski_, ah yes, forgot that one
00:14:26 <fons> Twey: wrong number, sorry
00:14:40 <fons> Twey: Sorry to be a pain in the ass but could you have a look at this paste? http://hpaste.org/11933
00:14:43 <Twey> fons: I was a little baffled.  :-P
00:15:06 <fons> that's the right onoe
00:15:18 <luqui> So my guess is that it is not safe to marshall a TypeRep.  What, then, would be a safe way to write typesafe marshalling?  Something from Data.Generics?
00:15:31 <Cale> x6d65: One appropriate use of unsafePerformIO is to write memoising functions. Most others have to do with FFI -- making calls to a C library to compute something which you know is going to be pure, but requires some otherwise-ignorable I/O.
00:15:57 <luqui> i.e. I want to write the Binary form of a value along with its type, so I can make sure it's the type I'm expecting before reading it back in
00:16:08 <luqui> If this has already been done, I'd love to see it
00:16:20 <pumpkin_> Cale: are there other less scary-sounding ways to memoize?
00:16:30 <pumpkin_> I guess memoization isn't naturally very functional
00:16:43 <dolio> Yes, there are.
00:16:46 <luqui> pumpkin_, data-memocombinators  (shameless plug)
00:16:50 <Cale> pumpkin_: Well, someone really should write a library. It's quite possible to write a function  memo :: (Ord a) => (a -> b) -> (a -> b)
00:16:54 <Cale> aha
00:17:08 <pumpkin_> ah
00:17:14 <pumpkin_> that uses a map internally to remember it?
00:17:17 <Cale> yes
00:17:28 <pumpkin_> I see
00:17:29 <ski_> (Cale : splay trees, difference structures (like `DiffArray') might fit into the latter, as well ..)
00:17:53 <pumpkin_> mmm splay trees
00:18:21 <ski_> (yes i know there's persistent variants of splay trees .. here i was not talking about those)
00:18:27 <x6d65> Well, thanks for the input.
00:18:32 <dreixel> luqui: why would marshalling a TypeRep be unsafe?
00:18:38 <Twey> fons: The structure of your app is wrong
00:18:49 <Twey> fons: Note that it loops *within* the cyclicCmd
00:18:52 <luqui> dreixel, because it might not actually represent the type, just some identifier associated with it for some particular run
00:19:06 <dons> ?bug
00:19:07 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
00:19:07 <luqui> and I realize I used the word "marshal" wrong,  I meant pickle or serialize or any of those
00:19:18 <Twey> Oh wait, no, I'm reading it wrong
00:19:26 <Twey> Hmm
00:19:32 <luqui> dreixel, i.e. it might tell you two types are equal when they're not.
00:20:14 <ski_> (generally .. any quotient type where you might want to change underlying representation dynamically .. one can even think of (lazy) thunks/suspensions in that way .. except they're of course inherent in haskell)
00:20:21 <Cale> x6d65: I/O is not really that hard to do from the IO monad. If you need help with it, just shout :)
00:20:49 <fons> Twey: I replaced the run+Wait sequence by a putSTrLn of the command name and it doesn't work either :S
00:21:08 <Baughn> Cale: http://www.overcomingbias.com/2007/11/artificial-addi.html <-- Remind you of \bot?
00:21:09 <dreixel> luqui: but aren't the TypeReps given by the instance of Typeable, and isn't that constant over different runs?
00:21:12 <ski_> (s/representation/representant value/)
00:21:44 <x6d65> Cale: I'm fine with the IO monad. I just came across unsafePerformIO in SPJ's paper, and was curious what others thought about it.
00:22:08 <Cale> x6d65: Ah, okay.
00:22:27 <luqui> dreixel, I doubt it.   consider the case where I change my source code, for example...
00:22:41 <Cale> x6d65: The general consensus is largely that it's quite dangerous, and to be generally avoided unless your first name happens to be Simon ;)
00:22:53 <x6d65> Cale: Hehe.
00:23:00 <luqui> but I am not sure...
00:23:17 <foo-nix> twanvl: Hallo twanvl.
00:23:34 <dreixel> luqui: so, you mean, if you would change the definition of your datatype (which you want to serialize), which derives Typeable?
00:23:46 <x6d65> Cale: I imagine that's because it allows you to, as the paper says, "break the Haskell type," and because it puts the burden of proof on the programmer, which is almost always a bad idea.
00:23:58 <luqui> dreixel, yes, I would want that not to be equal to the original
00:23:59 <Cale> x6d65: yes
00:24:10 <Cale> x6d65: You can actually break the type system with it, along with IORefs.
00:24:36 <luqui> burden of proof on the programmer is just fine, as long as a computer is checking the proof ;-)
00:24:37 <ski_> > unsafePerformIO getProgName == "Simon"
00:24:38 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `getProgName'
00:25:04 <pumpkin_> does anyone have any examples of the infamous programs whose types make the compiler take forever?
00:25:07 <dreixel> data TypeRep = TypeRep !Key TyCon [TypeRep]
00:25:11 <x6d65> One question about the IO monad, though, how does it play with ghci?
00:25:28 <luqui> dreixel, TyCon = ?
00:25:35 <dreixel> luqui: so I guess if the structure of your type changes you'll get different TypeReps
00:25:36 <Cale> x6d65: When ghci encounters an expression of type (IO t), it executes it.
00:25:44 <dreixel> but if it doesn't, then you might not. I wonder about that Key.
00:25:56 <Cale> x6d65: Recent versions of ghci also print the result, if there's an instance of Show available.
00:26:02 <luqui> dreixel, the key is not constant between runs.  the docs say so themselves.
00:26:02 <dreixel> the instance of equality compare only the Key, actually
00:26:23 <luqui> ah, so this is no good
00:26:27 <Cale> (and the result isn't ())
00:26:35 <luqui> I'm going to do something with Data.Generics, I think
00:26:35 <x6d65> Cale: Great, so it's as if every value of type (IO t) behaves mostly like main?
00:26:43 <luqui> since I'm only doing this with ADTs anyway
00:26:46 <Cale> x6d65: yeah.
00:26:50 <luqui> check for structural equality
00:26:56 <Twey> fons: Hmn, no, I can't work it out :-\
00:27:12 <Twey> Cale?
00:27:14 <Cale> x6d65: You can treat the GHCi prompt like the inside of a do-block
00:27:36 <Cale> Twey: hm?
00:27:44 <dreixel> luqui: yes, Data.dataTypeOf and Data.toConstr might give you more useful information
00:27:52 <Twey> Cale: http://hpaste.org/annotate/11933 — seems to only run the first process and not fork nicely
00:28:23 <Twey> Oh, fons, you do need a wait in there, though, or it'll just exit immediately
00:29:40 <Cale> Twey: hmm...
00:29:40 <Twey> Or... maybe not *frown*
00:29:50 <luqui> dreixel, thanks for the pointer
00:29:57 <Twey> I'm vastly confused by the whole thing
00:30:25 <Cale> um, it works for me?
00:30:45 <Cale> Seems to be printing the numbers 1 through 10 at random, spliced into one another.
00:30:59 <Twey> ... how odd
00:30:59 <fons> Cale: it does?
00:31:03 <Cale> yep
00:31:06 <Twey> It doesn't print anything at all for me...
00:31:09 <fons> Cale: it's not working for me
00:31:12 <Cale> of course, which sequence of numbers you get is going to depend on a lot of things
00:31:27 <fons> Cale: thats the efect I want to acheive
00:31:30 <dreixel> luqui: you're welcome. I mean Data.Data instead of only Data, btw :p
00:31:50 <dbbddbdb> Lemmih: hi, are you still maintaining Hssdl?
00:31:52 <Cale> I'm using GHC 6.10.1 on Ubuntu.
00:31:53 <luqui> I eventually found that :-)
00:32:11 <fons> Twey: it doesn't print enything for me either
00:32:13 <Twey> If I change it to main = (forkIO $ cyclicCmd "yes x") >> forkIO (cyclicCmd "yes y"), I get only 'y's
00:32:29 <Twey> Hmn, Cale, I suspect we're all using 6.8
00:32:41 <Twey> 6.8.2 here
00:33:21 <Cale> It could be a fairness issue...
00:33:40 <Cale> What happens if you stick in a 'yield' just before/after waitForProcess?
00:34:14 <Twey> Still no 'x's
00:34:18 <Cale> I can imagine that the GC is not getting many chances to run.
00:34:58 * jeffz` notices another bug in the GLFW bindings
00:35:05 <fons> Cale: any ideas of how to fix it?
00:35:39 <fons> Cale: maybe using unix threads ...
00:35:55 <Cale> okay, on 6.10.1 here, I'm getting an arbitrary string of x's and y's from Twey's program
00:36:12 <Twey> Is 'upgrate to 6.10' an option, fons?
00:36:18 <Twey> upgrade** damn you, voicing
00:36:39 <Cale> t"
00:36:46 <fons> Twey: not really, I'm at aork and my machine use a damn old version of libc
00:37:47 <fons> I'm getting the Floating point exception issue when trying to isntall GHC 6.10
00:37:59 <Cale> hmm
00:38:38 <Cale> fons: oh, one thing to try
00:38:42 <Cale> compile with -threaded
00:39:10 <Cale> waitForProcess apparently blocks all the threads in the system unless you're compiling with -threaded
00:40:21 <Cale> Twey: are you compiling with -threaded?
00:40:31 <zloog> Hrm, I'm having some kind of casting problem between floats and ints it seems. Can someone look at this three line function for me please?
00:40:32 <zloog> http://hpaste.org/11934
00:40:51 <fons> I am compiling with -threaded
00:41:01 <zloog> bricksize :: Float
00:41:05 <Cale> zloog: you need to apply fromIntegral to an Int to get a Float
00:41:10 <Twey> Cale: Ooooooh.
00:41:14 <Twey> That fixes it, fons
00:41:19 <Twey> -threaded
00:41:20 <fons> actually it seems that if I compile with -O it prints something but not cyclically (it dies)
00:41:25 <zloog> Cale: Thanks, I'll google that
00:41:38 <Cale> zloog: I just mean stick  fromIntegral before px
00:41:44 <fons> I'm using 6.8.1 I hope that's not the problem
00:41:50 <Cale> vx = 1-(bricksize/2.0)+(fromIntegral px-09.0) * bricksize
00:41:55 <Twey> fons: Do it with -threaded
00:42:07 <Cale> <fons> I am compiling with -threaded
00:42:27 <zloog> Cale:  can you explain why? Is subtraction between Int and Float some kind of an issue?
00:42:36 <telexicon> lol
00:42:41 <telexicon> s/bricksize/dicksize
00:42:43 <Cale> zloog: arithmetic operators only operate on numbers of the same type
00:42:59 <zloog> zloog: Oh, I keep forgetting this isnt C
00:43:18 <Cale> telexicon: It's generally not a good plan to IRC while drunk.
00:43:20 <zloog> :t fromIntegral
00:43:21 <lambdabot> forall a b. (Num b, Integral a) => a -> b
00:43:31 <Twey> Cale: Oh :(
00:43:41 <telexicon> Cale, oh.. good thing im not drunk
00:43:44 <Twey> fons: Hmm...
00:44:13 <zloog> I think I'm hitting the Ballmer's peak right about now
00:44:25 <fons> Twey: threaded doesn't fix it either
00:44:28 <fons> :S
00:45:24 <Cale> telexicon: Well, try to keep things in good taste and on topic here :)
00:45:44 <zloog> Thanks again cale, its working now
00:45:54 <Cale> zloog: no problem :)
00:46:09 <Cale> zloog: fromIntegral is what you use to convert from any integer-like type to any numeric type at all
00:46:15 <Twey> What's the function to get the last element of a list?
00:46:22 <Twey> The complement to init?
00:46:29 <Cale> zloog: realToFrac goes between various floating point and fractional types (wherever possible)
00:46:36 <Cale> Twey: last
00:46:42 <Twey> Ah, thanks
00:46:58 <Twey> fons: Are you also using the yield?
00:47:12 <Cale> zloog: and round/ceiling/floor/truncate go from fractional to integral in various ways.
00:47:29 <Twey> Actually, works for me even without the yield
00:47:31 <zloog> Cale: Yea, I need to flip back to that section in my book for a reread
00:47:41 <Twey> fons: You do have to wait for it to finish before exiting main, though
00:49:04 <fons> Twey: can you ellaborate on that?
00:49:16 <fons> Twey: waiting for what?
00:49:37 <fons> (BTW, changing forkIO with forkProcess fixed it)
00:49:47 <Cale> forkProcess?
00:50:04 <Cale> :t forkProcess
00:50:05 <lambdabot> Not in scope: `forkProcess'
00:50:18 <Cale> forkOS?
00:50:40 <fons> Cale: System.Prosix.Process
00:50:44 <fons> Posix*
00:50:47 <Cale> ah
00:51:04 <Cale> How about forkOS?
00:51:08 <Cale> Does that work for you?
00:51:19 <Twey> fons: If you just forkIO them all, main will exit and the program will finish
00:51:41 <Twey> You have to leave one attached to the main thread, or else delay the main thread in some other way
00:52:14 <fons> Twey: I see, that's probably the problem
00:52:19 <fons> Twey: how did you do that?
00:52:22 <Cale> g'night all
00:52:30 <fons> Cale: good night
00:52:42 <Twey> 'night Cale :)
00:52:47 <Peaker> @type succ
00:52:48 <lambdabot> forall a. (Enum a) => a -> a
00:52:54 <Peaker> What's an easy way to write a cyclic succ?
00:53:10 <Peaker> @hoogle Enum
00:53:10 <lambdabot> Prelude class Enum a
00:53:10 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
00:53:10 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
00:53:18 <sjanssen> @let csucc x = if x == maxBound then minBound else succ x
00:53:19 <lambdabot>  Defined.
00:53:24 <Twey> fons: fons do mapM_ (forkIO . cyclicCmd) $ init cmds; cyclicCmd $ last cmds
00:53:28 <Twey> Er
00:53:32 <Peaker> @type csucc
00:53:33 <lambdabot> forall a. (Bounded a, Eq a, Enum a) => a -> a
00:53:35 <sjanssen> > map csucc [False, True]
00:53:37 <Twey> Minus one fons :)
00:53:37 <lambdabot>   [True,False]
00:53:48 <Peaker> Are Enums automatically bounded?
00:53:54 <Twey> There should be something clever in Control.Arrow we can use here
00:53:57 <sjanssen> Peaker: no
00:53:57 <Peaker> (do they subclass Bounded)
00:54:03 <sjanssen> no
00:54:09 <Peaker> sjanssen: ok, makes sense, thanks!
00:54:12 <sjanssen> @src Bounded
00:54:12 <lambdabot> class  Bounded a  where
00:54:12 <lambdabot>     minBound, maxBound :: a
00:54:15 <sjanssen> @src Enum
00:54:15 <lambdabot> class  Enum a   where
00:54:16 <lambdabot>     succ                     :: a -> a
00:54:16 <lambdabot>     pred                     :: a -> a
00:54:16 <lambdabot>     toEnum                   :: Int -> a
00:54:16 <lambdabot>     fromEnum                 :: a -> Int
00:54:18 <lambdabot> [3 @more lines]
00:54:31 <dolio> Integers are not bounded.
00:54:38 <Twey> :t splitAt
00:54:39 <sjanssen> but Int is
00:54:39 <lambdabot> forall a. Int -> [a] -> ([a], [a])
00:54:49 <dolio> Yes.
00:54:49 <Peaker> Why isn't Enum subclassing Ord?
00:54:52 <sjanssen> the Enum class is rather mis-designed
00:55:00 <Peaker> it has succ/pred, so its an ordinal...
00:55:02 <Twey> @hoogle Int -> [a] -> ([a], [a])
00:55:02 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
00:55:03 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
00:55:03 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
00:55:12 <fons> thanks Twey
00:55:14 <fons> :)
00:55:20 <Twey> @hoogle [a] -> ([a], a)
00:55:21 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
00:55:22 <Twey> fons: Works now?
00:56:21 <Cale> fons: btw, another idea: use a quantity semaphore to count the threads which have run their process, and don't let any thread run a second time until that counts all the way up
00:56:39 <Cale> Of course, that's fundamentally different, but would be more fair.
00:58:34 <sjanssen> my standard solution: vs <- mapM_ (\p -> do v <- newEmptyMVar; forkIO (p >> putMVar ())) ps; mapM_ takeMVar vs
00:58:51 <sjanssen> erm, the first should be a mapM
00:59:07 <fons> Twey: it does
00:59:11 <fons> that was the problem
00:59:36 <Twey> fons: The -threaded is also an issue :)
00:59:38 <fons> I didn't know that when main ended all the IO actions spawned by forkIO died
01:00:54 <Twey> fons: That's UNIX :)  If a parent process dies, so do all its child processes
01:01:09 <Twey> There's some way to detach them, though
01:01:18 <mmorrow> > let inf = ceiling (1/0::Double) :: Integer in (length . show) (inf ^ 10000)
01:01:27 <quicksilver> Twey: it's not related, except by analogy.
01:01:27 <lambdabot>   3082548
01:01:40 <quicksilver> forkIO threads are not processes.
01:01:44 <Peaker> is Reactive's stateE just accumE on (fmap (const stateTransition) eventSource) ?
01:01:45 <sjanssen> Twey: this is not Unix
01:02:16 <Twey> quicksilver: No, but the forkIO could die and leave the spawned processes intact.
01:02:30 <quicksilver> Twey: it could. I'm just saying, the comparison with unix is not releveant.
01:02:34 <quicksilver> except as an analogy.
01:02:45 <quicksilver> because forkIO does not use processes.
01:02:59 <Twey> quicksilver: We're not really talking about forkIO
01:03:11 <Twey> quicksilver: There are a set of forkIO threads, sure, but they each spawn a process
01:03:19 <Twey> An actual OS process
01:03:43 <quicksilver> ah.
01:03:48 * quicksilver nods
01:03:52 <Twey> I was talking about those processes dying instead of staying alive when the main Haskell program exited.
01:04:13 <sjanssen> ah, the comment about -threaded makes more sense now :)
01:04:29 <Twey> Heh :)
01:06:19 <fons> Actually I meant forkIO processes, that's why I was suprised about main implicitly killing them when it ended
01:06:57 <fons> anyway, it works and I'm thankful
01:06:59 <fons> thanks!
01:07:09 <sjanssen> s/forkIO processes/forkIO threads/
01:08:00 <sjanssen> fons: the runtime exits when the last bound thread exits.  main is executed in the first bound thread, forkOS creates more bound threads
01:08:02 <Peaker> http://netsuperbrain.com/blog/posts/introducing-reactive-events/ is a pretty cool intro to FRP Events
01:08:09 <lambdabot> Title: Less Sugar/More Meat » Blog Archive » Introducing Reactive: Events
01:08:43 <Twey> Are they processes or threads, what forkIO spawns?
01:08:53 <alexeyr> Hi!
01:08:56 <sjanssen> Twey: threads
01:09:11 <Twey> Ah, because data can be shared with them
01:09:12 <sjanssen> of the light-weight variety, not OS threads
01:09:31 * Twey nods.
01:09:37 <b_jonas> it works!
01:09:38 <Twey> But -threaded allows them to become OS threads?
01:10:26 <sjanssen> Twey: -threaded allows the runtime to run several light-weight threads at a time by using multiple OS threads (generally a number equal to the CPUs you have)
01:10:39 <Twey> Aha
01:10:48 <b_jonas> ghc believed me that this expression makes sense: return (liftM (o :) (liftM2 (++) x y));
01:10:48 * Twey frowns.
01:12:35 <alexeyr> cabal-install shows there is a new version for template-haskell, but "cabal upgrade template-haskell" says "No packages to be installed. All the requested packages are already installed."
01:12:41 <Twey> sjanssen: So using -threaded in this case was a bit of a hack?  I have only two CPU cores, how come it scatters all ten numbers about?
01:15:24 <sjanssen> Twey: I haven't read the scrollback
01:15:28 <quicksilver> Twey: -threaded has at least two different observable effects
01:15:38 <quicksilver> Twey: one is the ability to make FFI calls asynchronous
01:15:44 <quicksilver> (not holding up haskell threads)
01:15:50 <quicksilver> and the other is to parallelise haskell threads.
01:16:17 <sjanssen> Twey: GHC will only use your cores if you ask it to (with +RTS -N2, for example)
01:17:00 <sjanssen> Twey: and threads are still pre-empted even without -threaded
01:18:07 <Twey> quicksilver: Oh right.
01:18:32 <Twey> So I was observing the former effect rather than the latter.
01:18:40 <quicksilver> but without -threaded, threads don't get pre-empted in FFI
01:18:44 <Kvasir> hello
01:18:53 <quicksilver> so without -threaded, FFI blocks except for the special case of Handle IO
01:19:00 <quicksilver> which is explicitly multiplexed by the RTS
01:19:10 <quicksilver> (...the rather important special case ;) ...)
01:20:15 <b_jonas> but if an FFI you write wanted to specifically not block at some point, could you acheive that somehow without knowing too much of ghc internals?
01:20:35 <b_jonas> like calling back a thread-non-blocking select-like haskell function?
01:21:48 <sjanssen> b_jonas: you'd just ask your users to use -threaded
01:22:11 <b_jonas> oh yeah, that's the easy way...
01:22:24 <b_jonas> now I somehow have to swap these two monads...
01:24:24 <Taejo> has somebody packaged GHC 6.10 as a DEB?
01:25:46 <sjanssen> b_jonas: sounds like bad movie dialog
01:26:19 * b_jonas hopes adding sequence would just solve everything, but it's not that easy...
01:26:32 <sjanssen> "I just need to re-route this applicative functor through the monad transformer, then we should be able to hack the bad guy's parser combinators"
01:26:50 <b_jonas> sjanssen++ lol
01:26:57 <pumpkin_> lol
01:27:44 <b_jonas> this would be hard this way... I'll have to revert the design
01:28:40 <hugo_> :)
01:28:45 <quicksilver> sjanssen: "Oh no, he's set an Arrow instance as a trap. If I can just derive a Typeable instance fast enough I should be able to bypass his type system with Generics"
01:30:18 <sjanssen> quicksilver: "I've tripped the dreaded monomorphism restriction, deploy a language pragma immediately!"
01:30:42 * quicksilver thinks sjanssen and quicksilver should write the next series of 24. It would be ace.
01:32:16 <b_jonas> but what if they have a quantum vector collector inspector detector deflector reflector projector? ("http://www.galactanet.com/comic/view.php?strip=209")
01:38:47 <Taejo> @hoogle Char -> Int
01:38:48 <lambdabot> Data.Char digitToInt :: Char -> Int
01:38:48 <lambdabot> Data.Char ord :: Char -> Int
01:38:48 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
01:41:55 <b_jonas> Taejo: fromEnum
01:42:59 <Taejo> b_jonas: thanks
01:52:27 <Taejo> @where sort
01:52:27 <lambdabot> I know nothing about sort.
01:52:33 <Taejo> @i sort
01:52:33 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
01:52:40 <Taejo> @index sort
01:52:40 <lambdabot> Data.List
01:52:47 <b_jonas> @hoogle sort
01:52:48 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
01:52:48 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
01:52:48 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
01:54:33 <Taejo> :t (map (map (fromIntegral . (-64 +) . fromEnum))) . sort
01:54:33 <lambdabot> forall b a. (Ord a, Enum a, Num b) => [[a]] -> [[b]]
01:55:19 <lispy> hmmm...someone highlighted me, but I my scroll back doesn't seem to have it
01:55:29 * lispy goes to the logs
01:56:44 <Peaker> Hoogle only searches the stdlib, right?
01:56:45 <lispy> oh, heh just zombie muevals
01:57:09 <b_jonas> I think you can set up with it should search when it's installed
01:57:45 <b_jonas> Peaker: http://www.haskell.org/haskellwiki/Hoogle
01:57:47 <lambdabot> Title: Hoogle - HaskellWiki
02:03:06 <Peaker> Can I use hoogle to index all my installed libs, instead of just the stdlib?
02:05:37 <mmorrow> if you have a new enough haddock, you can just passit the --hoogle option while building the docs
02:06:28 <mmorrow> this gets me a hoogle index and hscoloured src linked from the haddock html docs:
02:06:33 <mmorrow> ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
02:06:55 <mmorrow> (where i'd previously done ghc --make Setup.lhs && ./Setup configure)
02:06:59 <foo-nix> \whois twanvl
02:07:11 <Peaker> mmorrow: if I use cabal install?
02:07:21 <mmorrow> Peaker: dunno how with that
02:07:49 <Peaker> cabal has a "haddock" option to "Generate Haddock HTML documentation."
02:07:50 <mmorrow> Peaker: all you have to do though is either darcs get some src, or wget it from hackage, then just
02:08:26 <mmorrow> ghc --make Setup.*hs && ./Setup configure && ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html && firefox dist/doc/html/<name-of-pkg>/index.html
02:08:33 <mmorrow> or copy it wherever
02:09:00 <Peaker> mmorrow: thanks
02:09:07 <mmorrow> if you want the docs to ghc + libs, you'll have to build ghc and add the opt to build the docs before build
02:09:37 <mmorrow> (although maybe docs get built by default now, but i don't think they do)
02:10:41 <hackage> Uploaded to hackage: HStringTemplate 0.4.2
02:10:44 <mmorrow> i'm not yet sure how to get that snazzy overlay hoogle does over the haddock html docs yet, but someone had it on some docs on their site and it was sweeet
02:11:03 <mmorrow> the docs for hledger
02:11:11 * mmorrow googles
02:11:18 <mmorrow> @go hledger haskell ledger
02:11:20 <lambdabot> No Result Found.
02:11:23 <mmorrow> crap
02:11:30 <Peaker> it would be sweet if "cabal install X" had installed the hoogle database too, and the "hoogle" command searched everything
02:13:08 <mmorrow> found them. check /this/ out :o  http://joyful.com/repos/hledger/api-doc/
02:13:09 <lambdabot> Title: hledger api docs
02:15:03 <mmorrow> here's his Makefile that i think has what's needed to build docs like those http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=headblob;f=/Makefile
02:15:05 <lambdabot> Title: joyful.com darcsweb - hledger, http://tinyurl.com/5v3qe4
02:15:44 * mmorrow takes notes
02:17:54 <Peaker> haddock generated a text file for hoogle with: arrowChoice :: (ArrowChoice ~>, ....
02:17:58 <Peaker> (bad syntax)
02:18:06 <Peaker> I had to wrap the ~> with () for hoogle --convert to eat it
02:18:25 <halberd> does a version of Bresenham's line-drawing algorithm exist when the line is being drawn in n-dimensional space, which is asymptotically efficient in the number of dimensions? (ideally, O(n + m) where n is the number of dimensions and m is the number of points to be plotted)
02:18:49 <halberd> to achieve this one could use plotting operations that are incremental, like "move cursor +1 pixel in dimension 8, and plot"
02:18:59 <halberd> instead of having to name all the coordinates of every point you plot
02:19:51 <mmorrow> Peaker: heh
02:20:30 <Peaker> gonna report a ticket...
02:23:53 <Peaker> http://trac.haskell.org/haddock/ticket/64
02:23:54 <lambdabot> Title: #64 (Invalid syntax generated for arrow functions) - haddock - Trac
02:24:21 <halberd> but the hard part is picking which direction to move the cursor in
02:24:21 <halberd> when you can't scan each dimension in turn on each step to evaluate the best one
02:24:28 <halberd> okay what this is really motivated by... suppose you have n points on the discrete number line, each of which has a given velocity, and you want to simulate their motion by moving one point at a time, one step at a time, the question being only which point to move
02:26:26 <Peaker> weird, hoogle takes "--data" or "--d", not "-d"
02:26:32 <Taejo> @hoogle Set -> k -> Bool
02:26:32 <lambdabot> Did you mean: Set k -> k -> Bool /count=20
02:26:32 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
02:26:32 <lambdabot> Control.Parallel par :: a -> b -> b
02:26:35 <Peaker> why the non-gnu-options?
02:26:35 <halberd> and at all times you want to be as close as possible to the perfect continuous position of all the points
02:26:39 <EvilTerran> Peaker, i imagine the problem applies to any use of infix type variables
02:26:45 <Taejo> @hoogle Set k -> k -> Bool
02:26:45 <lambdabot> Data.Set member :: Ord a => a -> Set a -> Bool
02:26:45 <lambdabot> Data.Set notMember :: Ord a => a -> Set a -> Bool
02:26:45 <lambdabot> Data.Set isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
02:26:49 <Peaker> EvilTerran: Probably, yeah
02:27:00 <EvilTerran> which're an extension anyway, aren't they?
02:27:03 <Peaker> EvilTerran: But I'm reporting a symptom.. speculation is for the bug fixers :)
02:27:15 <Peaker> EvilTerran: The problem is, you can't use hoogle --convert on that output
02:27:19 <Peaker> EvilTerran: without the parens()
02:29:15 <EvilTerran> i see
02:30:09 <dolio> Even GHCi :type output can be weird for infix type variables.
02:30:51 <Peaker> then the bug is probably deeper inside
02:31:29 <dolio> Yeah. I assume it's the same bug, since the new haddock just hooks into GHC's api somehow.
02:31:58 <dolio> If you type in ":t (>>>) :: Arrow (~>) => (a ~> b) -> (b ~> c) -> (a ~> c)" in ghci, you should see the same sort of weird behavior.
02:32:06 <dolio> All the ~> are treated as prefix in the output.
02:32:46 <Peaker> arrg,  hoogle takes --convert=BLAH, but not hoogle --convert BLAH, and the shell doesn't expand wildcards when its prefixed with --convert=
02:33:03 <Peaker> --convert=$(echo ...wildcards...) works though
02:35:36 <dolio> :t ((>>>) :: Arrow (~>) => (a ~> b) -> (b ~> c) -> (a ~> c))
02:35:37 <lambdabot> forall (~> :: * -> * -> *) a b c. (Arrow ~>) => ~> a b -> ~> b c -> ~> a c
02:36:10 <dolio> That's actually worse than your haddock bug, I guess. :)
02:36:19 <Peaker> in ghc 6.10 it seems to work
02:36:26 <dolio> (From an incorrectness, standpoint.)
02:36:30 <ziman> can i do https in haskell? i can't google anything useful.
02:36:35 <Peaker> oops, no
02:36:53 <Peaker> also get: (Arrow ~>) => ~> b c -> ~> (b, d) (c, d)
02:37:21 <dolio> Good, because I thought I just checked with 6.10. :)
02:37:34 <dolio> I may not be losing my mind.
02:37:58 <Taejo> > take 3 []
02:37:59 <lambdabot>   []
02:38:16 <jeffz> ziman: probably using the curl library on hackage
02:38:35 <Twey> Taejo: take is safe for use on empty lists, but head isn't.
02:39:06 <ziman> jeffz, thanks
02:41:45 <mmorrow> that reminds me, i still need to report this bug:
02:41:49 <mmorrow> 6.8.*
02:41:50 <mmorrow> > (fromIntegral :: forall a b. Integral a => a -> Num b => (Num b => (Num b => (Num b => b)))) 0
02:41:51 <lambdabot>       Could not deduce (Num ((Num b, Num b, Num b, Num b) => b))
02:41:51 <lambdabot>        from ...
02:41:59 <mmorrow> 6.10.*:
02:42:01 <mmorrow> , (fromIntegral :: forall a b. Integral a => a -> Num b => (Num b => (Num b => (Num b => b)))) 0
02:42:04 <lunabot>  luna: luna: panic! (the 'impossible' happened)
02:42:13 <mmorrow> hehe
02:43:49 <mmorrow> > (fromIntegral :: forall a b. Integral a => a -> Num b => (Num b => b))) 0
02:43:50 <lambdabot>   <no location info>: parse error on input `)'
02:43:53 <mmorrow> > (fromIntegral :: forall a b. Integral a => a -> Num b => (Num b => b)) 0
02:43:54 <lambdabot>       Could not deduce (Num ((Num b, Num b) => b))
02:43:54 <lambdabot>        from the context (I...
02:44:03 <mmorrow> > (fromIntegral :: forall a b. Integral a => a -> Num b => b) 0
02:44:04 <lambdabot>       Could not deduce (Num ((Num b) => b)) from the context (Integral a)
02:44:04 <lambdabot>    ...
02:44:10 <mmorrow> , (fromIntegral :: forall a b. Integral a => a -> Num b => b) 0
02:44:12 <lunabot>  luna: luna: panic! (the 'impossible' happened)
02:44:23 <mmorrow> @type (fromIntegral :: forall a b. Integral a => a -> Num b => b) 0
02:44:24 <lambdabot>     Could not deduce (Num ((Num b) => b)) from the context (Integral a)
02:44:24 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:1-12
02:44:24 <lambdabot>     Possible fix:
02:44:44 <mmorrow> @type undefined :: forall a b. a -> Num b => b
02:44:45 <lambdabot> forall a b. (Num b) => a -> b
02:44:58 <mmorrow> @type undefined :: forall a b. a -> Num b => (Num b => b)
02:44:58 <lambdabot> forall a b. (Num b) => a -> b
02:45:12 <mmorrow> @type undefined :: forall a b. Num b => a -> Num b => (Num b => b)
02:45:13 <lambdabot> forall a b. (Num b) => a -> b
02:46:30 <mmorrow> > (fromIntegral :: forall a b. (Num (Num b => b), Integral a) => a -> Num b => b) 0
02:46:31 <lambdabot>       No instance for (Num ((Num b) => b))
02:46:31 <Peaker> is there a parsec Haskell parser I can modify to read Haskell code with infix as prefix, to then dump it with () around the infix stuff?
02:46:31 <lambdabot>        arising from instantiating ...
02:46:43 <Peaker> (to automate a workaround)
02:47:03 <idnar> (Num ((Num b) => b)), that's a nice instance
02:47:38 <Peaker> mmorrow: I built the documentation with haddock, but how do "install" the docs? When I try "cabal haddock" on a dependent package it says it cannot find the installed docs of its dependencies
02:48:29 <Taejo> don't the show instances for string and [a] overlap?
02:48:40 <Peaker> its not very important, cause I can use the docs from the web, and just use the "hoo" files I'm happily generating
02:49:01 <Axman6> @src String show
02:49:02 <lambdabot> Source not found. You speak an infinite deal of nothing
02:49:06 <Axman6> @src [] show
02:49:07 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:49:08 <Peaker> @src String shows
02:49:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:49:11 <Peaker> @src String showsPrec
02:49:12 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:49:15 <Peaker> @src Show
02:49:15 <lambdabot> class  Show a  where
02:49:15 <lambdabot>     showsPrec :: Int -> a -> ShowS
02:49:15 <lambdabot>     show      :: a   -> String
02:49:15 <lambdabot>     showList  :: [a] -> ShowS
02:49:21 <Peaker> @src String showList
02:49:22 <lambdabot> Source not found. Just try something else.
02:49:26 <Peaker> @src Char showList
02:49:27 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:49:37 <Peaker> @src [Char] showsPrec
02:49:38 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:53:13 <mmorrow> Peaker: i actually have no clue how to actually get the docs to install. i just have a place i put them all, but they're not interlinked
02:53:29 <Peaker> mmorrow: its so close to being so easy with the "cabal" command
02:54:02 <mmorrow> heh
03:01:16 <Taejo> is there an elegant way to get every third element of a list (like xs[::3] in python)
03:04:00 <BONUS> you can cycle a list like [0,0,1]
03:04:04 <BONUS> and then zip it with your list
03:04:10 <BONUS> and then filter to only those that have a 1
03:04:24 <quicksilver> Taejo: takeWhile (not.null) . map (take 1) . iterate (drop 3) $ l
03:04:25 <BONUS> > zip "hello hey" (cycle [0,0,1])
03:04:26 <lambdabot>   [('h',0),('e',0),('l',1),('l',0),('o',0),(' ',1),('h',0),('e',0),('y',1)]
03:04:49 <quicksilver> > takeWhile (not.null) . map (take 1) . iterate (drop 3) $ "hello hey"
03:04:51 <lambdabot>   ["h","l","h"]
03:05:18 <BONUS> > filter ((==1) . snd) $ zip "hello hey" (cycle [0,0,1])
03:05:19 <lambdabot>   [('l',1),(' ',1),('y',1)]
03:05:28 <BONUS> ahg yeah quicksilver's is better
03:05:41 <BONUS> cause you gotta extract the letters from this later on
03:07:06 <BONUS> > map fst . filter ((==1) . snd) $ zip "hello hey" (cycle [1,0,0])
03:07:07 <lambdabot>   "hlh"
03:07:20 <BONUS> although in quicksilver's example you get a type of [[a]]
03:07:37 <dolio> > let f (_:_:x:xs) = Just (x, xs) ; f _ = Nothing in unfoldr f "hello hey"
03:07:37 <BONUS> so you'd have to concat
03:07:38 <lambdabot>   "l y"
03:08:29 <Peaker> does hoogle search all the indexes in "~/.cabal/share/hoogle-<version>" ?
03:08:38 <dolio> > let f (x:_:_:xs) = Just (x, xs) ; f _ = Nothing in unfoldr f "hello hey"
03:08:40 <lambdabot>   "hlh"
03:09:19 <BONUS> man i almost never use unfoldr even though it comes in handy in many cases
03:10:41 <hackage> Uploaded to hackage: system-uuid 0.0.0
03:10:41 <hackage> Uploaded to hackage: HSHHelpers 0.15
03:10:41 <hackage> Uploaded to hackage: DebugTraceHelpers 0.10
03:12:23 <Taejo> @hoogle [a] -> [a] -> Bool
03:12:24 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
03:12:24 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
03:12:24 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
03:12:53 <Taejo> > isInfixOf "foo" "bar foo quux"
03:12:54 <lambdabot>   True
03:15:58 * Peaker has set up a bunch of scripts - I can now hoogle through my darcs repo's
03:16:22 <Peaker> @src unfoldr
03:16:23 <lambdabot> unfoldr f b  = case f b of
03:16:23 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
03:16:23 <lambdabot>    Nothing        -> []
03:17:26 <Peaker> If Nothing corresponds to [] and Just corresponds to (:), then how does one write unfolds for types that have more data constructors?
03:17:31 <Peaker> (Maybe Maybe Tree)?
03:17:49 <Peaker> (Maybe Maybe a) that is
03:18:18 <ToRA|MSR> a -> Maybe [a] ? if you have a rose tree
03:18:40 <ToRA|MSR> mm, no that's wrong
03:18:44 <mmorrow> @type id :: ((Double ~ Int) => Double) -> Double
03:18:45 <lambdabot>     Couldn't match expected type `Double ~ Int'
03:18:45 <lambdabot>            against inferred type `Double ~ Int'
03:18:45 <lambdabot>     When matching `(Double ~ Int) => Double'
03:18:49 <mmorrow> @type let ?f = (42::Double) in (\_ -> ?f) :: (?f::b) => (a ~ Int => a) -> (b ~ a => b)
03:18:50 <lambdabot> ((a ~ Int) => Double) -> Double
03:20:09 <Peaker> Hmm, reactive-fieldtrip has a Module Test where main = ...   I am not sure why it is not called module Main - but can "ghc --make" be told to compile it as main anyhow?
03:20:28 <mmorrow> , let ?f = (42::Double) in (\_ -> ?f) :: (?f::b) => (a ~ Int => a) -> (b ~ a => b)
03:20:30 <lunabot>  luna: Illegal equational constraint a ~ GHC.Types.Int
03:20:35 <quicksilver> Peaker: --main-is
03:20:43 <mmorrow> hmm, in 6.10.1:
03:21:03 <mmorrow> :: ((Double ~ Int) => Double) -> Double
03:21:14 <Peaker> quicksilver: its unrecognized in 6.10?
03:21:58 <Twey> What does that mean?
03:22:08 <Peaker> quicksilver: ah, -main-is,  thanks
03:22:36 <quicksilver> ghc-- # inconsintent option naming scheme
03:26:11 <Peaker> how do I hoogle for instance declarations?
03:26:35 <BONUS> if its in the standard library you can do :info in GHCI
03:26:51 <BONUS> e.g :info Monad
03:26:56 <quicksilver> not just the standard library
03:26:58 <BONUS> or :info Maybe
03:27:01 <quicksilver> any libraries you have loaded.
03:27:04 <BONUS> yeah
03:27:30 <Peaker> thanks
03:28:07 <Peaker> I love being able to hoogle in my CLI, and have results from my darcs repos, I think it might be a good idea to have cabal-install always install the docs too, including binary hoogle databases
03:28:47 <Peaker> having something like that deeply built-into Haskell distributions would make Haskell more than just competative at the interactive help/search realm
03:30:39 <Peaker> how do I get ghci to run some commands at startup?
03:30:48 <Peaker> (I want to :def stuff)
03:31:00 <byorgey> Peaker: put them in your ~/.ghci
03:31:12 <Peaker> is that a file?
03:31:16 <byorgey> yes
03:31:24 <Peaker> might be short sighted ;)
03:31:30 <byorgey> perhaps =)
03:31:36 <Peaker> I guess there's ~/.ghc for the future
03:32:02 <byorgey> ~/.ghc is already in use.
03:32:18 <byorgey> that's where ghc stores your local package info.
03:32:26 <Peaker> yay, now I can hoogle from my ghci
03:32:40 <Peaker> byorgey: ~/.ghc/ghci/ would probably not conflict though
03:34:19 <Peaker> ok, I'm managing to crash reactive-fieldtrip by scaling against the current time ;p
03:34:29 <byorgey> haha =)
04:04:31 <Peaker> awesome! I just modified conal's example to rotate based on mouse position rather than time
04:04:39 <Peaker> conal's stuff is great :-)
04:05:34 <Stalin> hi everyone
04:05:53 <Peaker> heh, a polish stalin
04:06:05 <Stalin> yeah, I know
04:06:43 <Stalin> could anyone help me with a little bit of a newbish issue?
04:07:11 <Peaker> Why does rotate3 take a scale, when there's uscale3?
04:07:24 <ToRA|MSR> Stalin: don't ask to ask, just ask ;)
04:07:59 <Stalin> ToRA, ok, so, I'm trying to compile a program that I just used to run in the interactive environment
04:08:28 <Stalin> the problem is, I don't really know how to define the main function so that I could use all the other functions in the program
04:09:47 <ToRA|MSR> main = print other_function
04:09:51 <ToRA|MSR> would be a really simple starting point
04:10:00 <Stalin> is it possible to have my program wait for the user input, so that it acts similar to what it would do in interactive mode?
04:10:18 <Thomas2> you know you can use your program from interactive mode?
04:10:31 <Stalin> yes, but I want it compiled
04:10:57 <ToRA|MSR> you can also compile your program and then load it in ghci
04:11:08 <Thomas2> sure. putting a lot of work into replicating interactive mode doesn't make a lot of sense though
04:11:33 <Thomas2> so can anyone tell me what the cool kids are using to make slides these days?
04:11:41 <Stalin> but what if, say, I want to use it on a different computer and don't want to download the whole interpreter?
04:12:01 <Peaker> Beelsebob_: you there?
04:12:12 <Thomas2> then I guess replicating interactive mode might make more sense
04:12:24 <rog> quick question: is there a simple class constraint on f that would allow me to write a fn with type: Monad m => f (m a) -> m (f a) ?
04:12:26 <Axman6> Thomas2: LaTeX Beamer class, or Keynote >_>
04:12:33 <Stalin> in C++ "interactive" mode would just be an infinite loop with checking the input, is something like that possible in a comparable amount of effort in Haskell?
04:13:00 <Axman6> Stalin: you could have a readLine loop...
04:14:21 <dolio> @type Data.Traversable.sequence
04:14:22 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
04:14:45 <dolio> rog ^^
04:14:52 <rog> dolio: brilliant, thanks. just the sort of thing i was looking for.
04:15:41 * rog asks himself why he didn't just hoogle it...
04:15:46 <Thomas2> Stalin: try something like this
04:15:47 <Thomas2> main = do
04:15:53 <Thomas2>   line <- getLine
04:16:15 <Axman6> @hoogle Expr
04:16:15 <lambdabot> module Text.Parsec.Expr
04:16:15 <lambdabot> module Text.ParserCombinators.Parsec.Expr
04:16:15 <lambdabot> Distribution.Simple.Program alexProgram :: Program
04:16:18 <Thomas2>   print (do_computation_on_line)
04:16:22 <Thomas2>   main
04:16:24 <ddaedalus> Thomas: why not use interact?
04:16:34 <Stalin> will try that
04:16:59 <Thomas2> ddaedalus: because I don't have standard lib memorised?
04:17:07 <ddaedalus> :D
04:18:11 <Thomas2> hmm, not sure that really does what you want
04:18:20 <Thomas2> that is, you have to break it into lines and such yourself
04:18:43 <Thomas2> i guess you could just use lines and unlines
04:18:51 <Stalin> will try
04:19:45 <Axman6> hmm, it'd be kinda nice if you could do something like f = do {expr <- readLine :: IO Expr; expr; f}
04:22:10 <ddaedalus> Stalin: nice example of using interact: interact (map toUpper)
04:23:22 <Peaker> ok, reactive-fieldtrip is either very slow or buggy...
04:24:44 <Stalin> it kind of works
04:24:56 <Stalin> but seems extremely tedious
04:25:10 <Stalin> I mean the interaction I'm trying to implement
04:25:28 <ziman> > fromMaybe 5 Nothing
04:25:29 <lambdabot>   5
04:26:52 <Peaker> @src fromMaybe
04:26:52 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
04:27:25 <Peaker> > let fromMaybe n = maybe n id in fromMaybe 5 Nothing
04:27:26 <lambdabot>   5
04:27:41 * Peaker prefers catamorphisms over simple pattern-matches
04:28:32 <Peaker> not sure why fromMaybe is needed, instead of (maybe n id)
04:28:49 <Peaker> @seen conal
04:28:50 <lambdabot> I saw conal leaving #haskell and #ghc 4h 22m 43s ago, and .
04:32:00 <Stalin> I'm still having problems with getting my program to work and quite honestly don't understand the negative attitude towards side effects
04:32:40 <Axman6> it's a lot harder to guarantee a lot of stuff there's sideeffects
04:32:58 <Stalin> I mean, they seriously made interactive programs easier to write and almost every piece of software is interactive
04:33:09 <Beelsebob_> Stalin: the negative attitude towards side effects is caused by them disallowing things like parallelism
04:33:26 <Beelsebob_> rubbish -- the interact function is all you need for interaction
04:33:29 <Axman6> Beelsebob_: been playing with STM lately, it
04:33:33 <Axman6> it's really cool :)
04:33:33 <ddaedalus> Stalin: You dont need sidefeects to have interactivity. Just look at FRP.
04:33:36 <Beelsebob_> at a guess, you're still trying to write in a stateful way
04:33:45 <Stalin> maybe
04:33:50 <Beelsebob_> and hence banging your head at a brick wall
04:33:56 <Stalin> I'm just trying to write a program that will compile
04:34:15 <Axman6> Stalin: wel, try pasting some code, and people might be able to help. use hpaste.org
04:34:19 <Stalin> unluckily, most books on haskell I could find don't really make learning easier than banging my head against the mentioned wall
04:34:19 <Axman6> l*
04:35:02 <Beelsebob_> Stalin: the problem there is that it's probably not learning haskell you're struggling with
04:35:09 <Beelsebob_> but instead unlearning what you already "know"
04:35:14 <Axman6> Stalin: i think you're probably trying to use haskell in a way it's not best at being used. if you do things the haskell way, you'll find things are quite nice most of the time
04:35:35 <Stalin> I don't want to unlearn C++, I want to know them both
04:35:40 <Stalin> anyway
04:35:51 <Stalin> I will paste the source code on hpaste
04:35:53 <Stalin> just a moment
04:35:55 <Axman6> that's fine, but you have to treat them both differently
04:36:13 <Beelsebob_> sure, but until you stop trying to think of Haskell like C++ you'll never manage to grasp Haskell
04:36:14 <ddaedalus> Stalin: its not about unlearning a language. Ist about looking problems from a different POV.
04:36:53 <Stalin> ok
04:37:06 <Stalin> http://hpaste.org/11939
04:37:44 <ddaedalus> Stalin: main = interact trimSpaces
04:38:17 <Beelsebob_> actually that won't do anything
04:38:23 <Beelsebob_> becasue interact requires a lazy function
04:38:36 <Beelsebob_> what might do something is main = unlines . trimSpaces . lines
04:38:59 <Beelsebob_> http://hpaste.org/11939#a1 <-- but there's a neater definition of trimSpaces
04:39:11 <ddaedalus> well, IMO, trimSpaces is lazy, isnt it?
04:39:17 <Beelsebob_> no
04:39:21 <Beelsebob_> it needs the list to be reversed
04:39:26 <Beelsebob_> so it's strict in the spine of the list
04:40:02 <ddaedalus> ... you are right.
04:40:54 <Beelsebob_> Stalin: what's the desired effect -- I've got that you want to remove spaces, but do you want to do this to every line?
04:40:56 <Beelsebob_> every word?
04:41:04 <Beelsebob_> the entire input?
04:41:15 <Stalin> I want to remove spaces at the beginning and at the end only
04:41:20 <Beelsebob_> okay
04:41:25 <Beelsebob_> and the beginning and end of what?
04:41:26 <Beelsebob_> each line?
04:41:29 <Stalin> yes
04:41:54 <Beelsebob_> http://hpaste.org/11939#a1
04:41:56 <Stalin> it's just a test, I'm trying to learn how to make those compiled programs interactive
04:41:56 <Beelsebob_> oops
04:41:57 <Beelsebob_> 2
04:42:14 <Beelsebob_> so lines splits it up into the constituant lines
04:42:20 <Beelsebob_> each line gets the spaces trimmed from it
04:42:27 <Beelsebob_> and then unlines glues them back together with newlines
04:42:49 <mdmkolbe> I have a C function (PAPI_get_opt(int,PAPI_option_t*)) that I am trying to build a Haskell binding for.  The trouble is that the int argument is a flag indicating which element of the union that is PAPI_option_t should be read.  On top of that sometimes fields of PAPI_option_t are for input and sometimes they are just for output.  I know how to do the low level FFI, but I'm uncertain how to design the high level Haskell interface (e.g. what type 
04:42:51 <mdmkolbe>   I see two possibilities.  I could make separate functions for each flag (e.g. getOptPreload, getOptMaxCpus, etc.) each with their own type appropriate to the flag.  Or I could maybe have one function with a GADT argument (e.g. getOpt :: GetOptArg a -> IO (GetOptResult a)).  I'm sort of on the fence here so does anyone have opinions, suggestions or experiences that might help me figure this out?
04:43:12 <Twey> main = getStrLn >>= putStrLn . trimSpaces >> main
04:43:18 <Twey> Surely?
04:43:22 <Beelsebob_> Twey: ewwww
04:43:34 <Twey> What?  :(
04:43:38 <Beelsebob_> interact (unlines . trimSpaces . lines) is much more functional
04:43:39 <Axman6> Peaker: you've been playing with FieldTrip, got any ideas about "Could not find module `Graphics.FieldTrip.Glut'"?
04:43:41 <Beelsebob_> and much more easily read
04:43:42 <Peaker> Beelsebob_: hey, do you do some fieldtrip work?
04:43:52 <Beelsebob_> Peaker: occasionally, yes
04:43:53 <Peaker> Axman6: how did you install fieldtrip?
04:43:58 <Axman6> cabal
04:44:04 <Beelsebob_> are you trying to get the Fieldtrip example program working Peaker ?
04:44:07 <Peaker> Beelsebob_: Any idea why some simple programs are extremely slow?
04:44:13 <Peaker> Beelsebob_: Its working, I even made it nicer! :-)
04:44:14 <Beelsebob_> no?
04:44:23 <Beelsebob_> they all run nicely on my machine
04:44:30 <Peaker> Beelsebob_: even lplace?
04:44:37 <Beelsebob_> lplace?
04:44:39 <Beelsebob_> never tried it
04:44:46 <Peaker> Beelsebob_: can you try it?
04:44:56 <Peaker> Beelsebob_: I just sent a mail to the reactive mailing list about it
04:45:04 <Twey> Beelsebob_: You mean map trimSpaces?
04:45:09 <Beelsebob_> no idea which program you're talking about :/
04:45:25 <Peaker> Beelsebob_: Test.hs has a bunch of commented-out examples
04:45:25 <Stalin> Beelsebob, http://hpaste.org/11939#a3
04:45:32 <Twey> Doesn't work anyway... *** Exception: <stdin>: hGetContents: illegal operation (handle is closed)
04:45:33 <Stalin> the result of compiling this
04:45:39 <Peaker> Beelsebob_: in the reactive-fieldtrip package
04:45:45 <Beelsebob_> Stalin: oh, woops, map trimSpaces
04:45:50 <Beelsebob_> you need to do it for each line
04:45:52 <Beelsebob_> not just one
04:46:06 <Axman6> @hoogle Glut
04:46:06 <Beelsebob_> http://hpaste.org/11939#a4 <-- that
04:46:07 <lambdabot> package GLUT
04:46:18 <Beelsebob_> Peaker: oh, I don't have that
04:46:24 <Beelsebob_> not played with it at all
04:46:35 <Peaker> Beelsebob_: where are the examples you're referring to?
04:46:38 <Twey> Oh, now it works.
04:46:42 <Peaker> Beelsebob_: (I'm referring to the reactive one)
04:46:43 <Stalin> great, it works now
04:47:01 <Beelsebob_> Peaker: the ones in fieldtrip, that don't work because fieldtrip-glut has gone byebye
04:47:06 <Twey> GHCi and its crazy IO handling *shakes head*
04:47:10 <Peaker> Beelsebob_: oh
04:47:11 <Stalin> Beelsebob, what if I had another function that I would want to make interactive in the same program?
04:47:28 <Peaker> Beelsebob_: can you try the Test.hs lplace example and see if its slow there too?
04:47:32 <Twey> Stalin: You'd chain it with that one, generally
04:47:34 <Beelsebob_> Stalin: well, how would the two interact?
04:47:45 <Stalin> let's say they wouldn't
04:47:47 <Beelsebob_> i.e. if you get input, which function do you want to give the data to
04:48:01 <Beelsebob_> one after the other?
04:48:01 <Beelsebob_> or some switching mechanism?
04:48:06 <Stalin> switching
04:48:14 <Stalin> like, selecting which one of them I want to run
04:48:20 <Stalin> and giving the parameters
04:48:21 <Beelsebob_> okay, and how would you like to select?
04:48:29 <Stalin> just type its name
04:48:33 <Stalin> that would suffice
04:48:35 <Beelsebob_> so you want to give a command name, and some parameters?
04:48:36 <Beelsebob_> yeh?
04:48:39 <Stalin> yes
04:48:45 <Stalin> that would be great
04:49:46 <Twey> interact and hGetContents have always seemed a little dodgy to me...
04:50:17 <Twey> All that invisible IO
04:50:25 <Beelsebob_> Stalin: something like this... http://hpaste.org/11939#a5
04:50:56 <Beelsebob_> Twey: that's exactly the point of them
04:50:58 <Axman6> @hoogle Anim
04:50:58 <Beelsebob_> to hide the IO
04:50:58 <lambdabot> No results found
04:51:01 <Axman6> gahh
04:51:07 <Beelsebob_> and allow you to just describe a functional program
04:51:18 <Axman6> i can;t get the Test.hs to work at all for FieldTrip
04:51:36 <Stalin> ok, will try that
04:52:00 <quicksilver> they'd be great if they weren't broken.
04:52:05 <quicksilver> interleaved IO--
04:52:12 <Twey> Yes, but it's kind of like unsafePerformIO
04:52:17 * Twey nods.
04:52:33 <Twey> quicksilver: How do you suggest they be fixed?
04:52:48 <quicksilver> switching, behind the scenes, to a left fold model
04:53:08 <quicksilver> 'interact' couldn't keep its type though
04:53:22 <Beelsebob_> quicksilver: how are they broken?
04:53:24 <Axman6> anyone know where Anim and timeR come from?
04:53:24 <quicksilver> but, for example, an efficient explicitly line-based one would be possible.
04:54:18 <quicksilver> @go perils of getContents
04:54:20 <lambdabot> No Result Found.
04:54:23 <Axman6> why is Text.hs importing 'import Graphics.FieldTrip.Glut'? there's no such thing...
04:54:29 * quicksilver slaps lambdabot 
04:54:37 <Beelsebob_> Axman6: because it's based on fieldtrip-glut
04:54:39 <quicksilver> Beelsebob_: http://www.haskell.org/pipermail/haskell-cafe/2007-March/023073.html
04:54:40 <Beelsebob_> which no longer exists
04:54:41 <lambdabot> Title: [Haskell-cafe] Takusen and strictness, and perils of getContents, http://tinyurl.com/yp35rl
04:54:44 <Beelsebob_> slap david to fix it
04:54:54 <Axman6> urgh
04:55:03 <quicksilver> Twey: more generally, you'd choose your chunking policy
04:55:08 <quicksilver> Twey: (of which lines are just one example)
04:55:29 <ezrakilty> @pl \f x y -> f x x
04:55:30 <lambdabot> (const .) . join
04:55:46 <Beelsebob_> quicksilver: oh, I don't really see that as a bug at all
04:55:48 <Beelsebob_> I see that as a feature
04:56:01 <Beelsebob_> although I do agree that you don't want it sometimes
04:56:10 <Beelsebob_> in which case you drop to the uglier monadic IO approach
04:56:11 <Axman6> Beelsebob_: any ideas about ""?
04:56:11 <Axman6> Beelsebob_: any ideas about "Perf.hs:55:13: Not in scope: `colorG'"?
04:56:27 <Axman6> um, ok, not sure why that was there twice
04:56:27 <quicksilver> Beelsebob_: you don't need to drop to an uglier IO approach, fortunately
04:56:36 <Beelsebob_> quicksilver: woot :D
04:56:38 <quicksilver> there are perfectly appropriate pure types
04:56:43 <quicksilver> it's just interact isn't it.
04:56:49 <Beelsebob_> yeh
04:56:58 <Beelsebob_> some form of runReactive is >.<
04:57:00 <quicksilver> don't pretend you can get "all the file at once" and still process it lazily.
04:57:01 <Beelsebob_> >.>
04:57:15 <Beelsebob_> oh, I don't think it ever does pretend that
04:57:18 <quicksilver> the essence of lazy process is recognition that you might generate an IO error later.
04:57:27 <quicksilver> so String is the wrong type
04:57:33 <quicksilver> a line based example might be
04:57:34 <Stalin> Beelsebob, could I just do main = interact (unlines . runCommand . lines) in your example?
04:57:48 <quicksilver> [Either  Error String]
04:58:07 <Beelsebob_> Stalin: you could -- but runCommand would need to switch to something like runCommand x | "monkies" `isPrefixOf` x = ...
04:58:09 <quicksilver> ^^ your interact will get a bunch of Right Strings possibly terminated by a Left Error
04:58:12 <quicksilver> and possibly not.
04:58:16 <Beelsebob_> because it would no longer get the individual words
04:58:42 <Stalin> I see
04:58:46 <Beelsebob_> Stalin: you would then probably also want to use your trimSpaces function -- in case the user mashed space a bit, in my example words caught that
04:59:25 <Stalin> and with that other solution you gave
04:59:49 <Beelsebob_> hmm? with the one in the pastebin, words will strip off the spaces for you, so it's unneccessary
04:59:50 <Stalin> would I delete "monkies" from x and then pass that to the command?
05:00:00 <Beelsebob_> yep
05:00:09 <Beelsebob_> and you would then need to split up the params manually
05:00:18 <Beelsebob_> on the plus side -- you would be able to accept arguments with spaces in
05:00:48 <Stalin> could I maybe include the words splitting into runCommand, so that I don't need the interpret function?
05:01:06 <Beelsebob_> you could
05:01:22 <Beelsebob_> or you could make main = unlines . map (runCommand . words) . lines
05:01:27 <ziman> i've just written a `multilayer' program consisting of stacked monads that are basically StateT over the underlying monad -- HTTP monad -> Session monad -> Chat monad -- each providing high-level abstractions to the superior monads (and the user will finally use the top-level monad). Is it a common/recommended design pattern in Haskell?
05:01:29 <Stalin> I see
05:02:04 <Stalin> and then would I do runCommand("monkies": params) = etc. etc., like in your example?
05:02:23 <Beelsebob_> indeed
05:02:33 <Stalin> great, thanks for help
05:02:44 <Beelsebob_> no probs
05:02:54 <Beelsebob_> see what I mean about IO without side effects being rather nice?
05:03:03 <Stalin> yes
05:03:18 <Stalin> it was only hard to figure out with most online books on haskell
05:03:24 <Stalin> or maybe I was reading them wrong
05:03:26 <Beelsebob_> sure
05:03:40 <Beelsebob_> well, I think a lot of them approach it from a "this is a lost cause" angle
05:03:48 <Beelsebob_> and just introduce you to the IO monad
05:03:55 <Beelsebob_> which lets you do side effects in a controlled way
05:04:19 <Beelsebob_> it's more powerful, but it's also not necessary as often as people make out
05:04:51 <Stalin> I haven't struggled with monads yet, so far I've only been learning a few days, using mostly GHCi to test out whatever I learned
05:05:44 <ksf> for me, the list monad and concatMap did the trick.
05:06:12 <ksf> the good thing in studying that one is that it's not really utterly sequential.
05:06:49 <Axman6> argh, the FieldTrip wiki page is anoying useless, and the fact that the examples don't work is even more annoying
05:06:58 <Axman6> anoyingly*
05:07:01 <Axman6> nn*
05:07:06 <ksf> seems to be easier to grasp a new, much too general control structure if the example isn't too familiar, semantically.
05:07:18 <Twey> I don't think it's exactly production-ready yet :-P
05:07:22 <Stalin> ok, so I have another problem, Beelsebob
05:07:36 <Axman6> Twey: well it'd be nice if the examples compiled at least
05:07:49 <Stalin> I've tried using your method in another program and it won't compile
05:07:52 <Axman6> i have no idea where to start trying to fix the,
05:08:15 <Axman6> m*
05:08:32 <Beelsebob_> Stalin: hmm?
05:08:42 <Stalin> Couldn't match expected type `Char' against inferred type `String'
05:09:00 <ksf> It seems to me that both Perl and Haskell can run brain dumps, but Haskell lacks a confusion parser.
05:09:01 <Stalin> In the first argument of `function', namely `parameters'
05:09:13 <Beelsebob_> Stalin: wanna pastebin the source?
05:09:24 <Stalin> just a moment
05:09:56 <Stalin> http://hpaste.org/11940
05:10:09 <Stalin> I'll be afk for a while, brb
05:10:41 <hackage> Uploaded to hackage: utf8-prelude 0.1.6
05:11:08 <Beelsebob_> Stalin: what that's saying is "hey, simpleCyp expected to get two strings -- the key and the plaintext, what it got instead is a last of parameters"
05:11:11 <vixey> zipWith (+) (map ord codetable) (map ord plaintext)
05:11:32 <mdmkolbe> Resending due to lack of responce ...
05:11:35 <mdmkolbe> I have a C function (PAPI_get_opt(int,PAPI_option_t*)) that I am trying to build a Haskell binding for.  The trouble is that the int argument is a flag indicating which element of the union that is PAPI_option_t should be read.  On top of that sometimes fields of PAPI_option_t are for input and sometimes they are just for output.  I know how to do the low level FFI, but I'm uncertain how to design the high level Haskell interface (e.g. what type 
05:11:37 <vixey> = zipWith ((+)`on`ord) codetable plaintext
05:11:39 <mdmkolbe>   I see two possibilities.  I could make separate functions for each flag (e.g. getOptPreload, getOptMaxCpus, etc.) each with their own type appropriate to the flag.  Or I could maybe have one function with a GADT argument (e.g. getOpt :: GetOptArg a -> IO (GetOptResult a)).  I'm sort of on the fence here so does anyone have opinions, suggestions or experiences that might help me figure this out?
05:11:39 <Beelsebob_> you want something along the lines of runCommand ("simpleCyp":key:plaintext:[]) = simpleCype parameters
05:11:43 <vixey> (although that might give a type error)
05:12:01 <vixey> :t ord
05:12:02 <lambdabot> Char -> Int
05:12:44 <vixey> oh it will be fine
05:13:43 <Beelsebob_> and yeh, you need zipWith (chr . ((+) `on` ord)) (cycle key) plaintext
05:13:47 <vixey> Beelsebob: that confuses the hell out of me, compared to  ["simpleCyp",key,plaintext]
05:13:49 <Beelsebob_> but that's for later
05:13:57 <Beelsebob_> vixey: true
05:13:58 <Stalin> now it just says Couldn't match expected type `Char' against inferred type `Int'
05:14:13 <Beelsebob_> Stalin: yep, that's becasue simpleCyp isn't outputting a list of chars
05:14:17 <Beelsebob_> it's outputting a list of ints
05:14:17 <ksf> mdmkolbe, you could do two Data.Sets, one called Settable and one Gettable, and make two functions, one that sets the set and one that gets it.
05:14:30 <Axman6> does anyone know how to fix "Not in scope: type constructor or class `Anim'"?
05:14:32 <Beelsebob_> so you need to convert the integers you got from adding them up, back to chars wth chr
05:14:44 <vixey> hmmm
05:14:51 <vixey> > 'x' + 'y'
05:14:52 <lambdabot>       No instance for (Num Char)
05:14:52 <lambdabot>        arising from a use of `+' at <interac...
05:14:57 <mdmkolbe> ksf: I don't follow
05:15:05 <vixey> > chr (ord 'x' + ord 'y')
05:15:06 <lambdabot>   '\241'
05:15:09 <ksf> ...and other set primitives, like union and difference to set or unset a single flag.
05:15:23 <Beelsebob_> Stalin: also, if you're doing cryptography, I'm guessing you want xor, not +
05:15:40 <vixey> > chr (ord 'x' .^. ord 'y')
05:15:41 <lambdabot>   Not in scope: `.^.'
05:15:44 <vixey> @hoogle xor
05:15:45 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
05:15:49 <vixey> > chr (ord 'x' `xor` ord 'y')
05:15:50 <lambdabot>   '\SOH'
05:15:55 <vixey> > chr (ord 'x' `xor` ord 'x')
05:15:55 <mdmkolbe> ksf: I meant a C style union.  There are no Set theory Sets around here.
05:15:56 <lambdabot>   '\NUL'
05:16:09 <halberd> is there a better way to compare two fractions a / b, c / d than multiplying and comparing ad and bc
05:16:12 <vixey> > (chr . xor`on`ord) 'p' 'q'
05:16:13 <lambdabot>   Couldn't match expected type `Int' against inferred type `b -> b'
05:16:17 <Axman6> @hoogle runWithGlut
05:16:17 <lambdabot> No results found
05:16:21 <vixey> > (chr . flip xor`on`ord) 'p' 'q'
05:16:22 <lambdabot>   Couldn't match expected type `Int' against inferred type `a -> a'
05:16:24 <vixey> :/
05:16:42 <vixey> > ((chr .) . xor`on`ord) 'p' 'q'
05:16:43 <lambdabot>   '\SOH'
05:16:58 <ksf> mdmkolbe, ah. You could do the GADT thing and use some TH to generate convinience functions.
05:17:49 <mdmkolbe> ksf: in otherwords provide both sorts of functions?
05:20:47 <Stalin> Beelsebob, like runCommand("simpleCyp": key:plaintext) = map chr (simpleCyp key plaintext) ?
05:21:05 <Beelsebob_> Stalin: something like this... http://hpaste.org/11940#a1
05:21:16 <ksf> I'm mainly suggesting this because a union perfectly maps onto a GADT and using a GADT for it doesn't seem very haskellish, I wouldn't want to use it from the Haskell side. Then, just typing down the GADT and some TH seems to be the most efficient way of implementing the high-level interface.
05:22:19 <Beelsebob_> @type xor
05:22:20 <lambdabot> forall a. (Bits a) => a -> a -> a
05:22:25 <Beelsebob_> @instances Bits
05:22:25 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
05:22:32 <Beelsebob_> @instances Data.Bits.Bits
05:22:33 <lambdabot> Int, Integer
05:22:36 <Beelsebob_> hmm, okay
05:22:38 <Stalin> Beelsebob, could I not change the simpleCyp functions?
05:22:39 <Axman6> > xor 1 3 :: Int
05:22:40 <Beelsebob_> no Char, that's a shame
05:22:40 <lambdabot>   2
05:22:41 <ksf> Can anyone point me to the best general paper about swarm intelligence?
05:22:47 <Axman6> > xor 4 3 :: Int
05:22:48 <lambdabot>   7
05:23:08 <ksf> and now don't you answer #haskell
05:23:08 <Axman6> > xor 7 3 :: Int
05:23:09 <lambdabot>   4
05:23:11 <Beelsebob_> Stalin: well, you at least need to change simpleCyp -- so that it does the map chr, like your simpleDec
05:23:11 <vixey> mdmkolbe, GADT sounds fine
05:23:27 <vixey> would not touch TH though
05:24:46 <Stalin> Beelsebob, like that: http://hpaste.org/11940#a2 ?
05:24:56 <Beelsebob_> Stalin: that would work, yes
05:25:02 <Stalin> well it doesn't
05:25:07 <Beelsebob_> what's the error?
05:25:10 <Stalin> Couldn't match expected type `Int' against inferred type `Char'
05:25:15 <ksf> well you'll end up with (Width width) <- getProperty all over the place.
05:25:20 <Stalin> In the second argument of `simpleDec', namely `encryptedtext'
05:25:21 <Beelsebob_> okay, where?
05:25:25 <vixey> Stalin: zipWith (+) (map ord codetable) (map ord plaintext)
05:25:26 <Beelsebob_> oh, okay
05:25:32 <vixey> Stalin: = zipWith ((+)`on`ord) codetable plaintext
05:25:37 <Beelsebob_> Stalin: you're not mapping ord over the encrypted text
05:25:45 <mdmkolbe> vixey: so would you recomend GADT over just splitting the function into separate functions?
05:25:45 <Beelsebob_> you need to
05:26:20 <cjs> How do I get some sort of RealFrac out of a DiffTime?
05:26:20 <lambdabot> cjs: You have 1 new message. '/msg lambdabot @messages' to read it.
05:26:27 <Stalin> finally
05:26:31 <Stalin> it compiled
05:26:46 <ksf> mdmkolbe, i never said you should split them, I thought of implementing the functions in terms of the GADT functions
05:26:50 <vixey> Stalin, rather than ("simpleCyp": key: plaintext: [])
05:26:59 <vixey> Stalin, how about ["simpleCyp",key,plaintext]
05:27:05 <vixey> Stalin, the first one is bloody confusing
05:27:10 <Beelsebob_> vixey: not really
05:27:18 <Beelsebob_> tbh, I hate the list syntactic sugar
05:27:21 <vixey> It is, I am sure that I got confused about it
05:27:27 <Beelsebob_> it saves no characters
05:27:30 <vixey> I thought it meant
05:27:34 <Stalin> ok, it compiles and all that
05:27:46 <vixey> I mean I thought it was metasyntax for 's':'i':'m':..
05:27:46 <Stalin> but I can't encrypt anything else than a single word
05:27:46 <Axman6> Beelsebob_: it's clearer to many that it's a list though
05:28:04 <Stalin> in GHCi I would just go simpleCyp "key" "words to encrypt"
05:28:10 <Stalin> in this I can't
05:28:26 <Beelsebob_> Stalin: yep, as I warned you -- the words function splits things on spaces
05:28:42 <Beelsebob_> so if you want to do something cleverer, like that, you'll need to parse it manually
05:28:48 <Axman6> Peaker: you around?
05:28:54 <ksf> does anyone else think that http://en.wikipedia.org/wiki/Bees_algorithm is awesomely similar to A*?
05:28:55 <lambdabot> Title: Bees algorithm - Wikipedia, the free encyclopedia
05:29:08 <Stalin> that seems more tedious than doing it the imperative way
05:29:10 <mdmkolbe> ksf: ah, that's what I thought you were saying with TH. (i.e. write a single GADT based getOpt, and use TH to make writting the getOptMaxCPUs, etc easier).  But it sounds like I've got two votes against the getOptMaxCPUs style (you and vixey)
05:29:12 <vixey> > words "simpleCrypt key words  to   encrypt"
05:29:13 <lambdabot>   ["simpleCrypt","key","words","to","encrypt"]
05:29:45 <ksf> <ksf> well you'll end up with (Width width) <- getProperty all over the place.
05:29:58 <Stalin> it just feels like I'm placing a hack on a hack on a hack instead of using the language like it's supposed to be used
05:30:11 <Beelsebob_> Stalin: well -- what would you do the imperative way
05:30:12 <ksf> I wouldn't count that as a vote in favour of GADT style
05:30:15 <Beelsebob_> you'd loop until you got a space
05:30:22 <Beelsebob_> then you'd consume all the spaces
05:30:26 <Beelsebob_> then you'd check you got a quote
05:30:28 <Axman6> that's pretty hacky
05:30:33 <Beelsebob_> then you'd consume everything until the next quote
05:30:33 <Beelsebob_> etc
05:30:40 <Beelsebob_> which as Axman6 says, is nasty and hacky
05:30:55 <Beelsebob_> so with something like parsec, you can parse this really quickly and elegantly in Haskell
05:31:19 <ksf> Always use parsec if you can.
05:31:42 <vixey> @pl \x y -> f x . g y
05:31:43 <lambdabot> (. g) . (.) . f
05:31:59 <Beelsebob_> or, you could hack it, by using let (cmd, (key, plaintext)) = second (break isSpace) (break isSpace xs)
05:32:06 <Beelsebob_> but parsec would be a lot neater
05:32:08 <Axman6> usong something like 'f ("encrypt":key:message) = enc key $ concat message is pretty clear to me
05:32:17 <vixey> mdmkolbe: I am recommending against using TH
05:32:40 <Axman6> 'f ("encrypt":key:message) = enc key $ concatMap (' ':) message' maybe
05:32:41 <ksf> It's the One True Parser(tm). It's a perfect blend of a parser generator and rolling your own parser, you inherit the advantages of both.
05:32:44 <Beelsebob_> Axman6: yeh, but it changes the message
05:33:01 <Axman6> Beelsebob_: see excellent fix above >_>
05:33:10 <Beelsebob_> Axman6: still corrupts the message
05:33:11 <vixey> Axman6:
05:33:12 <ksf> vixey, you're just scared.
05:33:12 <vixey> > words "simpleCrypt key words  to   encrypt"
05:33:13 <lambdabot>   ["simpleCrypt","key","words","to","encrypt"]
05:33:18 <Stalin> I guess I'm just tired with haskell for today
05:33:28 <Axman6> vixey: yeah i know
05:33:31 <dolio> ksf: Seems like a standard variation on evolutionary algorithms.
05:33:31 <Beelsebob_> > let f ("encrypt":key:message) = concat message in f (words "encrypt jam the             monkey rode the\n bike")
05:33:32 <lambdabot>   "themonkeyrodethebike"
05:33:40 <vixey> Axman6: do you ?
05:33:44 <Beelsebob_> > let f ("encrypt":key:message) = concatMap (' ':) message in f (words "encrypt jam the             monkey rode the\n bike")
05:33:45 <lambdabot>   " the monkey rode the bike"
05:33:54 <Beelsebob_> see, the message got corrupted
05:33:57 <dolio> (I'm pretty sure I've seen the algorithm before, but not by the name there.)
05:34:21 <Axman6> yes, which is why i called it an excellent fix sarcastically
05:34:36 <Axman6> sartcasticly even? bah
05:34:45 <Beelsebob_> oh, I see
05:34:56 <EvilTerran> ?wn sarcastically
05:34:57 <lambdabot> *** "sarcastically" wn "WordNet (r) 2.0"
05:34:57 <lambdabot> sarcastically
05:34:57 <lambdabot>      adv : in a sarcastic manner; "`Ah, now we're getting at the
05:34:57 <lambdabot>            truth,' he interposed sarcastically" [syn: {sardonically}]
05:35:01 <Beelsebob_> it's even worse decrypting -- because the spaces/newlines will decrypt into something completely different
05:35:05 <EvilTerran> you were right the first time :P
05:35:14 <Beelsebob_> and the key will end up missaligned with the cyphertext
05:35:18 <DukeDave> Um, in ghci do I remember there's a command to open the definition of a function in your editor?
05:36:51 <Beelsebob_> Stalin: essentially what I'm saying is that what you're wanting to do would be about a hundred lines in something like C -- so it's no real surprise when it comes out as 5 rather than 1 in Haskell
05:37:17 <dolio> ksf: I guess bees came up with evolutionary algorithms before computer scientists did. :)
05:37:37 <Stalin> yeah, I just thought parsing user input would be easier without learning about parsec and all
05:37:53 <vixey> Stalin, don't learn Parsec then
05:38:05 <Beelsebob_> Stalin: well, you can always use the split/break/take/takeWhile/drop/dropWhile functions
05:38:11 <Beelsebob_> it'll just be a lot less neat than using parsec
05:38:17 <vixey> Stalin, This thing can be written really easily using continuation passing style
05:38:26 <mdmkolbe> ok, well I've got to go.  I'll still be thinking about this problem though.
05:38:58 <ksf> dolio, I'm actually seeing it in an AI context, splitting up an actor in many parts that figure the best behaviour out for him.
05:40:06 <ksf> ...hopefully without developing multiple personae, that is.
05:40:08 <Stalin> could anyone recommend me a book that would make learning all of this a little easier?
05:40:18 <ksf> @real
05:40:19 <lambdabot> Maybe you meant: keal read
05:40:24 <ksf> @where real
05:40:24 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
05:40:27 <Beelsebob_> Stalin: simon thompson's book is good
05:40:35 <Beelsebob_> or graham hutton's
05:40:39 <Beelsebob_> or real world haskell
05:40:39 <vixey> Stalin, learning what ?
05:41:01 <Axman6> ooo, i own simon thompsons book
05:41:16 <Axman6> haven't read much of it though, #haskell is for more informative
05:41:20 <Axman6> far*
05:41:38 <ksf> there's also...
05:41:48 * Beelsebob_ runs off to eat lunch
05:41:48 <ksf> @where+ joc http://katmat.math.uni-bremen.de/acc/
05:41:49 <lambdabot> Done.
05:42:09 <dcoutts> Peaker: installing the docs happens automatically at install time if they were built
05:42:11 <vixey> @where JOC
05:42:11 <lambdabot> http://katmat.math.uni-bremen.de/acc/
05:42:48 <DukeDave> Ahaaa, it's :find in Hugs... Does no equivalent exist in ghci? :|
05:43:19 <ksf> DukeDave, <tab>?
05:44:05 <DukeDave> ksf: Eh ?
05:44:14 <DukeDave> In Hugs    :find <name>        edit module containing definition of name
05:44:30 <DukeDave> Imho :find is a bit of a misleading name
05:44:39 <ksf> the funny key with |<-- and -->| on top of each other
05:44:59 <ksf> well that explains my answer ;)
05:45:02 <DukeDave> Hehe
05:45:11 <DukeDave> Too description of the tab key though :)
05:45:35 <DukeDave> Is there not even a way to find out which file a function is defined in?
05:45:54 <vixey> grep
05:45:56 <ksf> I usually use the haddock index
05:46:12 <Stalin> thanks for all the help and bye for now
05:46:33 <DukeDave> Hee
05:46:41 <DukeDave> Yeah I settled for grep
05:47:19 <Axman6> Beelsebob_: you do understand you've been helping Stalin back from the dead to take over the world right?
05:47:38 <DukeDave> Shame though, I loved that function in hugs
05:48:19 <ksf> stalin is going to supersede ghc? has siskind started to code again?
05:50:05 <ksf> oh, I see http://sourceforge.net/projects/stalin
05:50:46 <Axman6> ksf: with those haskell skills, i doubt it :)
05:58:15 <Saizan> DukeDave: :info tells you the module
05:58:17 <kowey> did anybody find a solution to http://hpaste.org/4472 ?
05:58:34 <DukeDave> Saizan: Aha
05:58:36 <kowey> i'm trying to install QuickCheck 2.1 on GHC 6.6.1 and I get the same kind of error message :-(
05:58:40 <DukeDave> Damn I could have guessed that
05:59:18 <DukeDave> Hmm, Saizan you think there's a way to call info from within ghci?
06:00:38 <Saizan> DukeDave: i was referring to the ghci command :info, e.g. ":info sort"
06:02:08 <Saizan> kowey: it looks like a problem with your installation of the Cabal lib, maybe compiling Setup first can help
06:02:18 <ksf> http://en.wikipedia.org/wiki/Ant_colony_optimization has been predated by sim city.
06:02:19 <lambdabot> Title: Ant colony optimization - Wikipedia, the free encyclopedia
06:02:37 <DukeDave> Saizan: Yeah, it's just so tantalisingly close to :find in Hugs..
06:02:50 <dcoutts> kowey: it means your ghc does not like the version of gcc you are using.
06:03:21 <dcoutts> kowey: it may or may not work via ghc --make either
06:03:40 <DukeDave> All you have to do is invoke the defined editor with the file.. It even outputs the line number :'(
06:03:57 <dcoutts> kowey: if the problem persists, rebuild the affected library with -fasm rather than -fvia-C (which is implied by -O in ghc 6.6)
06:06:19 <kowey> dcoutts: the affected library being Cabal, right?
06:06:35 <kowey> dcoutts: that's quite plausible as I'm on a very recent Ubuntu (Intrepid)
06:08:14 * kowey tries
06:08:31 <dcoutts> kowey: right
06:10:35 <kowey> frabjous day! adding -fasm to Cabal.cabal allowed me to build QuickCheck 2.1 - thanks, Saizan and dcoutts!
06:16:27 <dcoutts> kowey: you can add --ghc-option=-fasm to the cabal configure/install command line so you don't have to modify the package itself
06:16:51 <quicksilver> I thought -fasm was the default now?
06:17:02 <quicksilver> oh, ghc 6.6
06:17:06 <quicksilver> didn't read back ;)
06:18:02 <kowey> oh, that's much nicer (and I can just stick it in the wiki)
06:18:07 <ksf> Humans are in no way different from ants.
06:18:12 <ksf> I guess I should log out now.
06:18:25 <Axman6> ksf: less acidic bites
06:18:55 <kowey> oh wait, no I can't stick that in the wiki because I don't want to assume the user has cabal-install; ok, I'll just leave it at 'modify the Cabal file'
06:18:59 <ksf> depends on enragement state of females.
06:19:17 <Axman6> ha
06:19:27 <Axman6> squishier bodies?
06:19:38 <ksf> human females?
06:20:17 <dcoutts> kowey: --ghc-options=-fasm works on runghc Setup.hs configure too
06:20:35 <dcoutts> kowey: no need to modify .cabal files
06:20:40 <kowey> ok!
06:21:10 <dcoutts> kowey: the best solution for people in that situation is to build everything with -fasm since -fvia-C is not going to work well at all.
06:22:01 <dcoutts> kowey: you might even try modifying the /usr/bin/ghc shell script to add -fasm
06:22:07 <Rapiere> Great, I've eventually be able to compile ghc-core ! now I could learn to decrypt ghc-core listings :P
06:22:09 <kowey> i hope this only affects those of us who are keeping old GHC around on recent machines in order to test for backward compatibility
06:22:47 * Axman6 has no problem with telling users to upgrade
06:22:50 <ksf> Just imagine an ant saying "Hey, geek, you gotta care about the costumers and dress up properly!"
06:22:57 <dcoutts> kowey: it should only affect people using very new gcc and old ghc, or the other way around
06:23:32 <Saizan> anyone used hscurses here? i get link errors
06:23:50 <ksf> Rapiere, ghc -ddump-simpl
06:24:51 <kowey> so after darcs configure decided it couldn't find -lz (because of the _DISCARD_ thing, I gave up and modified the /usr/local/bin/ghc script)
06:25:00 <kowey> hmm... still having issues
06:25:19 <kowey> Axman6: yeah, darcs is way more conservative than the usual Haskell crowd
06:25:38 <Rapiere> ksf: sure, but ghc-core gives a convenient way to read it
06:26:27 <mxc> hi
06:26:39 <mxc> has anyone been able to build ghc 6.10.x iwth macports?
06:27:44 <Axman6> i have, but ghci is broken
06:27:59 <Axman6> for some reason building it myself worked fine
06:28:10 <Axman6> i think that was before libedit had been installed though
06:30:10 <sbahra> pl
06:31:14 <kowey> dcoutts: sorry to keep dragging this out, but http://hpaste.org/11941
06:31:18 <mxc> oh, apparently, they recommend using hte binary install on osx
06:34:47 <ski_> @type \f -> (. (f .))
06:34:49 <lambdabot> forall c b c1 a. (b -> c1) -> ((a -> c1) -> c) -> (a -> b) -> c
06:34:49 <ski_> @type \f -> ((. f) .)
06:34:50 <lambdabot> forall b c a a1. (a -> b) -> (a1 -> b -> c) -> a1 -> a -> c
06:34:50 <ski_> @type \f -> (. f .)
06:34:52 <lambdabot> parse error on input `)'
06:35:51 <dcoutts> kowey: I wonder if the -fasm has to come after the -O2
06:36:17 <ski_> hm .. it could be natural for `(* foo /)' parses, given that `x * foo / y' parses, for operators `*',`/'
06:36:28 <dcoutts> kowey: hmm, in this case I wonder if it's actually your perl that's too new
06:36:53 <dcoutts> kowey: you might be able to fix that by patching the lib/ghc-6.6.1/ghc-asm script
06:37:04 <kowey> that's what I get for being too eager :-)
06:37:22 <kowey> ok! I edited /usr/local/bin/ghc and put the -fasm at the end
06:37:26 <kowey> and now configure completes
06:53:16 <Axman6> hmm, core is quite hard to read and understand
06:54:34 <Saizan> i think it could be much nicer with human-readable variable names
06:58:25 <Axman6> indeed
07:05:43 <Saizan> dcoutts: if i have Foo.hsc source that produces Foo.hs Foo_hsc.h Foo_hsc.c, Cabal takes care of building and linking the _hsc files by itself? or should i add something in the .cabal file?
07:06:13 <dcoutts> Saizan: you mean you're using the #c feature of hsc2hs
07:06:30 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/245
07:07:00 <Saizan> #def actually
07:09:36 <quicksilver> Axman6: have you seen the ghc-core package on hackage?
07:09:45 <Axman6> quicksilver: i'm using it
07:09:51 <Axman6> doesn;t help all that much
07:10:13 <Peaker> Axman6: now I am
07:10:30 <Peaker> dcoutts: Where can I find the installed docs?
07:10:51 <Axman6> Peaker: you don't happen to know where Anim is defined do you?
07:11:06 <Peaker> Axman6: I do, I spent 2 hours fixing hoogle to work on the darcs repos I have today ;)
07:11:17 <dcoutts> Peaker: $docdir/$pkgid/
07:11:23 <Peaker> dcoutts: it would be totally awesome if every package installed also generated the ".hoo" file for hoogle and installed it such that the hoogle command line used it too
07:11:51 <Peaker> dcoutts: being able to use hoogle on everything installed could be awesome
07:11:57 <Peaker> Axman6: FRP.Reactive.FieldTrip.Adapter
07:12:05 <Peaker> Axman6: type Anim a = UI -> Behavior a
07:12:14 <Peaker> Anim is a UI reader of Behaviors
07:12:54 <Axman6>     Could not find module `FRP.Reactive.FieldTrip.Adapter':
07:12:56 <Axman6> urgh!
07:12:58 <dcoutts> Peaker: indeed, I thought we had a ticket open for that feature request but it seems not, so feel free to file one
07:13:32 <Axman6> Peaker: you don't have a copy of Test.hs that, ya know, actually works do you?
07:13:51 <Peaker> dcoutts: Do you have the trac url?
07:14:05 <Peaker> Axman6: I do - I changed it to do cooler stuff ;)
07:14:11 <dcoutts> Peaker: http://hackage.haskell.org/trac/hackage/
07:14:20 <Axman6> mind pasting it somewhere?
07:15:33 <Peaker> Axman6: its just the one in the darcs
07:15:43 <Peaker> Axman6: it worked, I just added some stuff
07:15:54 <Axman6> well, it gives many mane errors for me
07:16:52 <Axman6> many*
07:17:24 <Axman6> for one, there's no such thing as Graphics.FieldTrip.Glut
07:19:16 <Peaker> Axman6: are you using darcs?
07:19:20 <Peaker> Axman6: maybe only the darcs one works
07:19:37 <Axman6> afaik, i am using the darcs one
07:19:48 <Peaker> Axman6: I don't have Glut either but nothing needs it
07:19:56 <Peaker> (Graphics.FieldTrip.Glut that is)
07:19:58 <Axman6> import Graphics.FieldTrip.Glut
07:20:05 <Axman6> like 21 of Test,hs
07:20:32 <Axman6> Axman$ darcs pull
07:20:32 <Axman6> Pulling from "http://code.haskell.org/FieldTrip"...
07:20:33 <Axman6> No remote changes to pull in!
07:20:46 <Peaker> I registered myself as a member of the reactive mailing list, but under a "+blah" on my gmail - and now it says my mail awaits "moderation" - does moderation actually happen?
07:20:58 <Peaker> Axman6: who's importing that inexistent module?
07:21:03 <Peaker> Axman6: darcs pull that one
07:21:31 <RayNbow> has anyone ever used parallel strategies on an 8-core machine?
07:21:32 <Axman6> FieldTrip/examples/src/Test.hs is importing it
07:27:09 <Peaker> btw, why doesn't Hoogle on the web try to index _every_ library in existence?
07:27:28 <Peaker> Axman6: I'm using reactive-fieldtrip/src/Examples/Test.hs
07:27:33 <Peaker> Axman6: not FieldTrip/examples
07:27:45 <Axman6> hmm, ok. where would i get that?
07:27:53 <camio> You also need reactive-glut.
07:27:53 <Peaker> Axman6: the Test.hs in FieldTrip itself is broken for me too
07:28:11 <Peaker> camio: I think that Graphics.FieldTrip.Glut is just gone
07:28:31 <_pizza_> > length [0..]
07:28:38 <Axman6> yeah, BeelsebobWork was saying something like that earlier
07:28:39 <Peaker> Axman6: you can try "cabal install reactive-fieldtrip", or if that's no good: "darcs get http://code.haskell.org/reactive-fieldtrip"
07:28:45 <vixey> infinity
07:28:57 <Peaker> _pizza_: are you intentionally DoS'ing lambdabot ? :)
07:28:58 <camio> Yeah, test in fieldtrip is deprecated.
07:29:07 <camio> You'll want to run the tests in reactive-fieldtrip.
07:29:26 <Saizan> @bot
07:29:30 <Peaker> camio: are you also one of the Reactive folk?
07:29:35 <camio> Yup
07:29:40 <camio> I'm the tutorial guy.
07:29:49 <Peaker> this one? http://netsuperbrain.com/blog/posts/introducing-reactive-events/
07:29:49 <lambdabot>   thread killed
07:29:49 <lambdabot> :)
07:29:57 <camio> yup
07:30:02 <Peaker> camio: cool! Its a great tutorial
07:30:06 <camio> thanks :)
07:30:19 <Peaker> camio: I am trying to play with reactive-fieldtrip myself
07:30:36 <Peaker> camio: The lplace example seems insanely slow/broken
07:30:44 <camio> Hrm, lemme look...
07:30:45 <_pizza_> Peaker: no, i'm trying to figure out why haskell as the concept of an infinite list but not Infinity (other than (1/0)::Float)
07:31:19 <Peaker> _pizza_: well, length is just a list func, its not smart enough to know that it is infinity
07:31:19 <vixey> > infinity > 4
07:31:22 <vixey> > infinity < 4
07:31:23 <lambdabot>   True
07:31:23 <lambdabot>   False
07:31:29 <Peaker> > infinity::Int
07:31:31 <lambdabot>   Couldn't match expected type `Int' against inferred type `Natural'
07:31:36 <camio> Peaker: What os are you on? Do you have accelerated graphics? It works well for me.
07:31:43 <Peaker> camio: I'll try to revert my changes
07:31:52 <Peaker> how do I ask darcs to set aside my changes
07:32:00 <Peaker> and use the pulled revision?
07:32:11 <Peaker> camio: Yeah, other examples work well
07:32:25 <Peaker> camio: also, if I try to scale something as a function of time, it becomes insanely slow too
07:32:54 <_pizza_> vixey: where is that infinity defined?
07:33:02 <camio> brb
07:33:49 <drigz> is there an easy way of doing \[a,b] -> (a,b)?
07:34:02 <drigz> normally i'd rely on @pl for this but i don't think it knows list unpacking
07:34:10 <Botje> don't think so
07:34:17 <Riastradh> You just wrote the easy way.
07:34:35 <quicksilver> drigz: what could possibly be more concise than "\[a,b]->(a,b)" ?
07:34:51 <quicksilver> that's about the briefest definition I could imaginge
07:34:52 <drigz> i really like pointsfree :(
07:35:05 <Peaker> @pl \[a,b] -> (a,b)
07:35:11 <drigz> i was thinking something like apply (,)
07:35:16 <Peaker> why is reactive's list moderated?
07:35:17 <quicksilver> if you really like pointsfree, without having a reason, then you are making a mistake.
07:35:39 <quicksilver> pointsfree is nice because you express code in reusable higher order forms
07:35:42 <quicksilver> it's an abstraction
07:35:50 <quicksilver> it doesn't mean you should have no points anywhere
07:35:58 <camio> Peaker: This particular example is fast on my machine.
07:36:05 <Peaker> quicksilver: if you can derive points-free code from point-ful code, how is it more abstract?
07:36:14 <drigz> quicksilver: it's subconscious. there are some functions which just feel like they shouldn't have points
07:36:15 <camio> Peaker: What do you mean by scalling with time?
07:36:32 <Axman6> RAWR! *** Exception: user error (unknown GLUT call glutSetOption, check for freeglut)
07:36:41 * Axman6 goes to sleep very annoyed
07:36:52 <camio> Hey Axman6, are you trying to install freeglut?
07:36:55 <quicksilver> Peaker: I didn't say it was more abstract.
07:37:00 <quicksilver> Peaker: I said it was an abstraction.
07:37:03 <quicksilver> not the same.
07:37:09 <Axman6> camio: no
07:37:13 <quicksilver> it enables refactoring and stuff
07:37:16 <Peaker> camio: I changed spinning to use "t" in the "z" axis
07:37:50 <Peaker> quicksilver: it makes refactorings more obvious, yeah
07:38:01 <quicksilver> Peaker: yes, exactly.
07:38:21 <quicksilver> it also lets you move from functions to other choices of primitve
07:38:28 <quicksilver> (foo) <|> (bar)
07:38:29 <drigz> also, is there an easier way of replacing items in a list than map (\x -> if x == source then dest else x)?
07:38:45 <quicksilver> could be a sensible expression when foo are functions, in one model of a parser
07:38:55 <quicksilver> but you might switch to a more sophisticated model of parser
07:38:59 <quicksilver> where they aren't functions any more
07:39:04 <vixey> drigs:  replace source dest = \x -> if x == source then dest else x
07:39:14 <vixey> drigs: replaceAll source dest = map (replace source dest)
07:39:16 <lambdabot> (line 1, column 2):
07:39:16 <lambdabot> unexpected "["
07:39:16 <lambdabot> expecting pattern
07:39:18 <quicksilver> so the combinator form (with no points) in more general in that slightly strange sense of more general
07:39:28 <drigz> @hoogle replace
07:39:29 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
07:39:30 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
07:39:32 <lambdabot> Data.Array.Diff replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
07:39:38 <camio> Peaker: Hrm, it's still fast for me.
07:39:58 <Peaker> camio: then I don't know what's wrong, cause I think accelerations generally work
07:40:22 <camio> Peaker: What OS?
07:40:31 <Peaker> camio: Ubuntu Intrepid
07:40:41 <camio> I'm on windows.
07:41:08 <Peaker> camio: Maybe some examples work OK even without acceleration though, I am looking for something to run to check whether I have accel
07:41:10 <camio> Do you have all your repositories updated to the latest and greatest?
07:41:38 <camio> Do you have all your repositories updated to the latest and greatest?
07:41:48 <camio> (sry for the double-post)
07:42:22 <Peaker> camio: Yep
07:42:25 <Peaker> camio: (from darcs)
07:42:44 <Peaker> camio: I'm checking acceleration, it might be that, even if rotations seem to be OK
07:43:25 <mdmkolbe> @hoogle (Monad m) => m ()
07:43:26 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
07:43:26 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
07:43:26 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
07:45:04 <mdmkolbe> Is there a library name for "return ()"?
07:45:17 <vixey> I don't think so
07:45:21 <vixey> :t mzero
07:45:23 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
07:45:26 <vixey> not that
07:45:27 <dolio> Why would that need a name?
07:45:33 <dolio> To make it 1 character shorter?
07:45:39 <ToRA|MSR> mzero would do it
07:45:40 <vixey> @let unit = return ()
07:45:41 <lambdabot>  <local>:6:7:
07:45:41 <lambdabot>      Ambiguous type variable `m' in the constraint:
07:45:41 <lambdabot>        `Mon...
07:45:43 <vixey> there we go
07:45:50 <RayNbow> vixey: almost
07:45:53 <vixey> @set -XNoMoronmorphismRestriction
07:45:56 <RayNbow> and I also wanted to type that :p
07:45:57 <lambdabot>   Parse error
07:46:24 <mdmkolbe> dolio: basically yeah (and make it more idiomatic)
07:46:32 <unenough> Cale, got the book. it was ordered by someone from education studies
07:46:38 <unenough> i wonder why...
07:49:14 <_pizza_> > 1/0
07:49:16 <lambdabot>   Infinity
07:49:24 <_pizza_> > 1/0*0
07:49:26 <lambdabot>   NaN
07:49:59 <vixey> > 1/infinity
07:50:00 <lambdabot>       No instance for (Fractional Natural)
07:50:00 <lambdabot>        arising from a use of `/' a...
07:50:06 <vixey> > infinity - infinity
07:50:21 <lambdabot>   thread killed
07:50:25 <unenough> Why would someone from the education faculty order a book on category theory??
07:51:12 <dolio> Because category theory is awesome?
07:51:27 <_pizza_> > 1/(1/0)
07:51:29 <lambdabot>   0.0
07:51:53 <unenough> _pizza_, wow
07:53:29 <quicksilver> mdmkolbe: I call it "skip" sometimes.
07:54:46 <drigz> @type infinity
07:54:48 <lambdabot> Natural
07:55:14 <dolio> > infinity
07:55:15 <lambdabot>   * Exception: stack overflow
07:55:25 <_pizza_> where is infinity defined?
07:55:25 <drigz> :t zero
07:55:26 <lambdabot> Not in scope: `zero'
07:55:26 <dolio> Hmm...
07:55:34 <_pizza_> <interactive>:1:0: Not in scope: `infinity'
07:55:35 <drigz> @where infinity
07:55:36 <lambdabot> I know nothing about infinity.
07:55:40 <unenough> heh
07:55:40 <vixey> > infinity
07:55:41 <lambdabot>   * Exception: stack overflow
07:55:42 <unenough> :)
07:55:42 <vixey> > infinity+1
07:55:44 <lambdabot>   * Exception: stack overflow
07:55:47 <drigz> it's probably in the locals
07:55:52 <profmakx> @src infinity
07:55:52 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:55:56 <vixey> > fix (1+) > 234324::Natural
07:55:57 <lambdabot>   Couldn't match expected type `Natural' against inferred type `Bool'
07:55:59 <drigz> > 1 < infinity
07:56:00 <dolio> > Z
07:56:00 <vixey> > fix (1+) > (234324::Natural)
07:56:01 <lambdabot>   True
07:56:01 <lambdabot>   Not in scope: data constructor `Z'
07:56:02 <lambdabot>   True
07:56:09 <dolio> > 0 :: Natural
07:56:11 <lambdabot>   0
07:56:19 <dolio> Oh.
07:56:23 <dolio> > 1 :: Natural
07:56:24 <lambdabot>   1
07:56:29 <dolio> > 537 :: Natural
07:56:30 <lambdabot>   537
07:56:36 <vixey> > 99^99 :: Integer
07:56:37 <lambdabot>   369729637649726772657187905628805440595668764281741102430259972423552570455...
07:56:39 <vixey> > 99^99 :: Natucal
07:56:39 <lambdabot>       Not in scope: type constructor or class `Natucal'
07:56:41 <vixey> > 99^99 :: Natural
07:56:45 <lambdabot>   * Exception: stack overflow
07:57:00 <unenough> according to this site, Haskel is the "Yiddish for Ezekiel"
07:57:51 <Peaker> @src Natural
07:57:51 <lambdabot> Source not found. Just try something else.
07:58:07 <dolio> > Zero
07:58:08 <lambdabot>   Not in scope: data constructor `Zero'
07:58:22 <drigz> > [2^x | x <- [1..]] :: [Natural]
07:58:25 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
07:58:28 <vixey> I suspect the constructors aren't exported
07:58:43 <vixey> > map (^2) [1..]
07:58:44 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
07:58:58 <vixey> > map (^5) [1..]
07:58:59 <lambdabot>   [1,32,243,1024,3125,7776,16807,32768,59049,100000,161051,248832,371293,5378...
07:59:02 <mfwitten> It's extremely annoying that there is no GHC for Mac OS X PPC
07:59:02 <vixey> > map (5^) [1..]
07:59:04 <lambdabot>   [5,25,125,625,3125,15625,78125,390625,1953125,9765625,48828125,244140625,12...
07:59:38 <jpcooper> mfwitten, are you sure?
07:59:55 <dolio> Yep. No constructors.
07:59:56 <dolio> Lame.
07:59:56 <jpcooper> I specifically remember coding in Haskell at work on my PPC when I should have been doing Lisp, over the summer
07:59:57 <mfwitten> Well, the download page lists "Mac OS X (Intel)"
08:00:11 <conal> @seen Beelsebob_
08:00:11 <lambdabot> Beelsebob_ is in #haskell-blah and #haskell. I last heard Beelsebob_ speak 2h 18m 23s ago.
08:01:09 <jpcooper> mfwitten, though are you talking about the latest version? I don't know about the latest one
08:01:20 <Peaker> why is the Reactive list moderated? How long does it take for mails to go through?
08:01:23 <conal> @seen BeelsebobWork
08:01:24 <lambdabot> BeelsebobWork is in #haskell and #ghc. I don't know when BeelsebobWork last spoke.
08:01:30 <mfwitten> I am talking about the latest version. I suppose I should go find a previous PPC version and build the latest
08:01:50 <unenough> @seen infinity
08:01:51 <lambdabot> I haven't seen infinity.
08:01:57 <mfwitten> I'm just surprised no one bothered to build a PPC version, considering it's extremely easy to build both PPC and Intel version (provided no x86 hacks)
08:02:17 <jpcooper> mfwitten, maybe you could provide one
08:02:45 <mfwitten> jpcooper: That's really not a good idea; I know nothing about the conventions of this project, and it would really be easier for the Intel guy to make a PPC version
08:02:53 <conal> @seen Peaker
08:02:53 <mfwitten> It would take him as long as it takes to compile.
08:02:54 <lambdabot> Peaker is in #haskell. I last heard Peaker speak 1m 34s ago.
08:03:01 <quicksilver> mfwitten: it would not.
08:03:10 <conal> Peaker: oh, there you are.
08:03:18 <mfwitten> quicksilver: What would not?
08:03:21 <quicksilver> mfwitten: cross compiling GHC is not that simple.
08:03:25 <Peaker> conal: yeah - are you the moderater of the reactive list?
08:03:40 <mfwitten> quicksilver: This isn't quite cross-compiling though
08:03:50 <quicksilver> mfwitten: it is as far as GHC is concerned.
08:03:52 <mfwitten> quicksilver: Apple has made creating binaries for Intel and PPC easy
08:03:59 <quicksilver> mfwitten: that's not relevant
08:04:04 <quicksilver> mfwitten: creating the binary is not the hard part.
08:04:05 <conal> i've unmoderated the list.  meant to earlier, but i guess i didn't understand the mailman interface.  had it moderated because of some early spam concern.
08:04:16 <mfwitten> quicksilver: So where is the trouble?
08:04:17 <quicksilver> mfwitten: GHC is itself a compiler, so it is quite architecture dependent.
08:04:29 <quicksilver> mfwitten: it needs to know the details of its host system intimiately to work
08:04:37 <quicksilver> you can't "just use" apple's PPC target toolchain for it.
08:04:46 <quicksilver> GHC is compiled by GHC, not by Xcode
08:04:50 <unenough> does GHC produce code in a cross-platform low-level intermediate stage?
08:04:56 <mfwitten> quicksilver: Perhaps GHC should be redesigned to hook into LLVM or the like
08:05:04 <conal> Peaker: i was scanning the channel log, and i see that some people ran into trouble with reactive-fieldtrip, not being able to find reactive-glut.  e.g., "<Peaker> camio: I think that Graphics.FieldTrip.Glut is just gone".
08:05:04 <quicksilver> mfwitten: perhaps it should. Actually, it shouldn't.
08:05:24 <Peaker> conal: my mail was bounced with "waiting for moderation" just a little while ago
08:05:26 <quicksilver> unenough: there are cross-platform stages, certainly.
08:05:43 <mfwitten> Ah Man! I've suffered my entire life as a Mac user, and it still hasn't gotten any better. ;-(
08:05:57 <unenough> quicksilver, but it could output some code that's compiled by an external intermediate language compiler
08:06:04 <conal> Peaker: it's gone through now
08:06:08 <quicksilver> unenough: you're missing the point.
08:06:19 <quicksilver> unenough: the point is that GHC code is dependent on its target platform.
08:06:20 <camio> conal: I think that happens when people look at the fieldtrip demos within the fieldtrip repository.
08:06:26 <Peaker> conal: ah, cool
08:06:26 <mfwitten> quicksilver: So basically, you're suggesting that PowerPC isn't supported? However, the GHC website suggests it is
08:06:32 <quicksilver> mfwitten: no I'm not suggesting that.
08:06:35 <camio> conal: Instead of the reactive-fieldtrip repository.
08:06:39 <conal> Peaker: i just got up and saw the moderation email and again cleared the moderation bit for everyone as well as changing the default.  don't know what i missed the first time.
08:06:45 <quicksilver> mfwitten: all I'm saying is it is not "that simple" for the "intel guy" to "just compile it for PPC"
08:06:52 <conal> Peaker: do you know why you had trouble finding the reactive-glut stuff?
08:07:05 <quicksilver> mfwitten: somebody with a PPC has to compile it. At least htat's by far the easiest route.
08:07:15 <conal> Peaker: you're not the only one, and i don't know why.
08:07:17 <Peaker> conal: Nope, I was telling that to Axman6.. I used reactive-fieldtrip's examples which did work
08:07:21 <jpcooper> can't GHC compile into multiple architectures from a single one?
08:07:22 <jpcooper> sorry
08:07:23 <jpcooper> GCC
08:07:34 <jpcooper> though maybe this isn't relevant
08:07:57 <mfwitten> quicksilver: Actually, I don't understand the problem. What does code generation have to do with the actual platform on which the compiler runs?
08:07:58 <quicksilver> it's not relevant, no.
08:08:57 <quicksilver> mfwitten: GHC is set up to generate code for the platform its running on.
08:09:11 <quicksilver> in GCC terminology, GHC is written to assume that host platform = target platform.
08:09:24 <quicksilver> it's not unreasonable to want a GHC which can cross-compile
08:09:26 <quicksilver> but, it can't.
08:09:48 <quicksilver> they do porting using a special via-C path
08:09:56 <quicksilver> but it's not part of the standard path.
08:09:58 <Peaker> conal: does that module exist?
08:10:28 <mfwitten> quicksilver: So why not make cross-compilation easier?
08:10:28 <conal> Peaker: no.  is there a dangling reference to Graphics.FieldTrip.Glut somewhere?
08:10:36 <Peaker> conal: Yeah, in FieldTrip examples
08:10:42 <hackage> Uploaded to hackage: DebugTraceHelpers 0.11
08:10:42 <hackage> Uploaded to hackage: HStringTemplateHelpers 0.0.2
08:10:42 <hackage> Uploaded to hackage: Workflow 0.1
08:10:50 <mfwitten> quicksilver: It seems to me that if the compiler can find platform-specific libraries against which it can link, then it shouldn't give a damn what the target is.
08:11:09 <Peaker> conal: darcs/FieldTrip/examples/src/Test.hs
08:11:10 <b_jonas> mfwitten: the hard part of cross-compilation isn't the compiler (cc1) but rather the linking with right libraries and all that kind of small bits
08:11:20 <conal> Peaker: thanks!  that's the problem.  i forgot to delete the examples directory
08:11:22 <b_jonas> and I assume this is true for haskell as well
08:11:47 <mxc> mfwitten - its really not that hard to build from source
08:11:55 <Peaker> conal: I am trying to use the "anim3 lplace" example, but its taking many seconds or perhaps waiting for enough events, I am not sure, before there's response for left-clicks
08:11:58 <quicksilver> mfwitten: you don't appear to understand what a compiler is.
08:12:06 <quicksilver> mfwitten: compilers need to uderstand about their target platform!
08:12:15 <mxc> generally, i feel your pain as a fellow macuser, but i have to say, haskell definitely treats os x as a first class platform
08:12:29 <quicksilver> mfwitten: they need to know register sizes, struct alignment, executable format, and so on.
08:12:30 <b_jonas> quicksilver: via C? can't they also port a simpler part of ghc via darcs or something? or will they have to maintain the via C compilation indefinitely?
08:12:42 <conal> Peaker: weird.  works perfectly for me.  i wonder if the results appear off-screen when you first click.
08:12:46 <mfwitten> mxc: My problem with building from source is that an existing GHC environment is required; perhaps older ones exist for PPC
08:12:50 <quicksilver> mfwitten: it is possible to imagine a compiler which can select multiple targets.
08:12:57 <quicksilver> mfwitten: for example, GCC is such a thing.
08:12:59 <quicksilver> however, GHC is not.
08:13:02 <mfwitten> mxc: It treats Intel as a first class platform
08:13:06 <mxc> mfwitten: they do indeed.  i think you just answered your question
08:13:10 <b_jonas> mfwitten: you can usually get an older version of ghc as binary
08:13:10 <mxc> mfwitten: so does apple
08:13:20 <quicksilver> mfwitten: now you're just being stupid. intel is not a platform, and you know this.
08:13:44 <mfwitten> Oh Christ, quicksilver, you're just being pedantic. I meant Mac OS X (Intel)
08:14:15 <mfwitten> quicksilver: And there's no reason that a program can't know about a target platform if it's not running on that platform
08:14:34 <quicksilver> mfwitten: there's no reason why GHC couldn't support multiple targets, except it doesn't
08:14:35 <mxc> mfwitten: thats basically the same as complaining that os x doesn't run on my 68040..  its not a different platform, its an older, rapidly obsolescing technology
08:14:40 <quicksilver> code doesn't get written for free.
08:14:44 <quicksilver> people haven't written that code.
08:14:46 <mxc> only a difference in degree not in kind
08:14:47 <Peaker> conal: I made some changes to toy with the examples
08:14:59 <quicksilver> mfwitten: I do agree it would be nice if GHC could be a cross compiler.
08:15:00 <mfwitten> mxc: I'm afraid that's not the right conclusion
08:15:03 <quicksilver> I mean, it would be awesome.
08:15:04 <Peaker> conal: I don't know enough darcs to revert my changes but keep them around somehow
08:15:08 <quicksilver> It would be useful for so many things.
08:15:13 <quicksilver> but GHC can't be a cross compiler
08:15:20 <mfwitten> quicksilver: I'm glad we agree; there's no reason to suggest I don't understand what a compiler is.
08:15:21 <quicksilver> and wanting it to be one won't make it happen.
08:15:36 <Peaker> ok I just used "diff" and "revert"
08:15:39 <quicksilver> well you seemed to think there was some magic button the GHC develoeprs could have pressed
08:15:40 <mfwitten> quicksilver: We agree that the problem is that GHC isn't designed to be that flexible.
08:15:45 <quicksilver> which they didn't press just to spite you.
08:16:04 <Peaker> conal: why do you use "module Test where .." and not "module Main where" for the example?
08:16:05 * mxc advocates spite driven development
08:16:06 <b_jonas> oh, on ghc and free code, do you happen to know how much ghc has improved in using shared libraries?
08:16:25 <quicksilver> b_jonas: in practical, "you can use this today" terms, not at all.
08:16:33 <quicksilver> behind the scenes it has certainly been worked on
08:16:42 <quicksilver> but no release of that functionality as far as I am aware.
08:16:47 <b_jonas> ok, thanks
08:16:48 <conal> Peaker: hm.  i guess i wanted it to be clear that the examples are examples, not *the* app.
08:16:49 <Peaker> conal: ok, I reverted, there's approximately 3-4 second delay between the left click and the appearance
08:16:54 <Peaker> conal: its not off-screen
08:17:08 <dolio> Shared libraries are on the list for "coming up next".
08:17:19 <dolio> So, 6.12, perhaps?
08:17:21 <camio> Peaker: What happens if you click very rapidly, do they show up faster?
08:17:27 <conal> Peaker: oh -- i have an idea.  what about delay after the second click?
08:17:46 <Peaker> conal: btw it just hangs after a while I have to kill it maliciously
08:17:52 <b_jonas> dolio: yeah, I was asking because of the minor version jump
08:17:57 <conal> Peaker: do you have glut or freeglut?
08:18:12 <b_jonas> from 6.8 to 6.10
08:18:22 <Peaker> conal: apparently both
08:18:22 <Peaker> libglut3 and freeglut3 are installed
08:18:31 <Peaker> conal: one of them is bad?
08:18:44 <Peaker> conal: MS research left you running on Windows? :-)
08:18:47 <conal> Peaker: freeglut allows graceful shutdown
08:18:59 <camio> Peaker: Sometimes freeglut3 is also installed as glut3. Are they the same file?
08:19:17 <Peaker> conal: graceful shutdown works, but not if I let it run for a while, it seems to be leaking something and after enough leakage it stops responding altogether
08:19:19 <conal> Peaker: i just switched from Windows to Ubuntu Linux two weeks ago.  and i love it!
08:19:27 <conal> Peaker: oh, okay.  hm.
08:19:46 <Peaker> libglut3 is an empty package, actually so I just have freeglut
08:19:59 <Peaker> conal: cool! ;)
08:20:04 <b_jonas> what's strange is how ghci pretends to be able to load native compiled versions of haskell modules
08:20:13 <quicksilver> b_jonas: "pretends" ?
08:20:25 <b_jonas> well, I don't know what it actually does
08:20:32 <Saizan> it does load them
08:20:33 <conal> Peaker: i wonder if the delay is really about tessellation rather than reactivity.
08:20:34 <quicksilver> it actually does load the native compiled versions.
08:20:46 <Peaker> conal: what is tessellation?
08:20:54 <b_jonas> but if that's possible then I indeed hope shared libraries for other haskell executables are close
08:21:15 <conal> Peaker: fieldtrip surfaces are really continuous & curved, not made of polygons.
08:21:35 <b_jonas> I mean, I could write a wrapper now that loads all modules of a program to ghci and starts main
08:21:35 <Peaker> conal: it converts them to polygons for OpenGL's sake?
08:21:44 <conal> Peaker: yeah.  rendering tessellates them, i.e., approximates by a bunch of polygons.
08:21:54 <conal> Peaker: and caches the result.  so the first time may be slow.
08:21:56 <wchogg> conal:  As a note, I've been having issues with my tests locking up after an extended period as well the same as Peaker.
08:22:13 <Saizan> b_jonas: not closer than 6.4.2 since i recall ghci doing that at the time :)
08:22:22 <Peaker> conal: I think the delay just grows, its as if the whole thing grows slower with time
08:22:40 <b_jonas> would this wrapper thing not work?
08:22:41 <conal> i'd love to get help tracking down these problems.
08:23:08 <conal> how about opening one or more trac tickets and updating them with any more info you get?
08:23:26 <Peaker> conal: Does ghc have a debugger that is usable with these things?
08:23:52 <wchogg> Peaker:  The GHCi debugger is a bit hard to use for diagnosing things with reactive, I've found, due to the multiple threads.
08:24:03 <mfwitten> quicksilver: So, I don't know much about LLVM, but it seems like it would be a good system on which to build a compiler. Why is it not good for GHC? Thanks.
08:24:07 <Peaker> wchogg: I failed to use the ghci debugger for anything at all :(
08:24:34 <Peaker> I think debugging lazy/pure functional things should be easier, not harder than debugging imperative things.. but the tools disagree :(
08:24:57 <wchogg> Peaker:  Well, the whole graph reduction thing *does* make the situation more complicated.
08:25:17 <vixey> wchog, simpler!
08:25:31 <Peaker> wchogg: I don't know what that is
08:25:35 <wchogg> vixey:  For tracing execution in a debugger?
08:25:40 <vixey> oh
08:25:43 <vixey> nobody wants to do that
08:25:45 <b_jonas> I think debugging lazy functional things should be harder
08:25:56 <Peaker> wchogg: when debugging denotational things, I don't care about the execution order...
08:25:59 <vixey> if your program doesn't work go prove it's correctness
08:26:40 <b_jonas> especially because of how the strong type system and bounds checking catches most of the easy bugs, so the ones you actually debug are harder problems
08:26:48 <Peaker> wchogg: it could be nice if I could see the result value of any computation and dig down into any sub-evaluation I want, rather than have the debugger dictate where to go according to arbitrary evaluation order
08:26:49 <quicksilver> mfwitten: http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011794.html
08:26:55 <quicksilver> mfwitten: http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011795.html
08:27:03 * mfwitten reads
08:27:22 <Peaker> b_jonas: sometimes I debug "easy" bugs and I just have to add "prints" everywhere because I can't "dig into" an expression to see where its reading its values from
08:27:25 <conal> Peaker: i don't see you on the fieldtrip list.
08:27:29 <wchogg> Peaker:  Yeah, I haven't gotten a good grasp of how to evaluate things in the order I want.  I've found that carefully forcing certain computations can get me right to the meat faster than breakpoints.
08:27:32 <Peaker> conal: I'm just on the reactive one
08:27:52 <b_jonas> sure, printing helps in 90% of the cases when you have a bug, you only need the debugger in the rest of the cases
08:28:04 <Saizan> Peaker: you can do that to some extent with the ghci-debugger, since when you get to a breakpoint you can inspect the values in scope
08:28:04 <b_jonas> but that's true for any language
08:28:06 <wchogg> conal:  Oh, but yeah I should start putting information on the trac's you have set up.  Sorry for not doing that sooner.
08:28:08 <conal> Peaker: the questions in your note are mostly about fieldtrip, so i'm cc'ing fieldtrip@haskell.org in my reply.
08:28:12 <b_jonas> that's why I rarely use a debugger
08:28:19 <b_jonas> I usually just add prints and stuff like that
08:28:25 <Peaker> b_jonas: printing is never better than debugging, instead of a print I should be able to just ask the debugger to go there, and then I can "dig into" the value, if its wrong, I can see the sub-expressions that built it
08:28:32 <Peaker> conal: ok, sure
08:28:40 <conal> wchogg: thanks.  whenever you get around to it.
08:28:40 <b_jonas> not exactly
08:28:55 <b_jonas> because I usually print repeatedly, not just one thing
08:29:02 <b_jonas> and it's harder to automate the debugger
08:29:42 <quicksilver> conal: nice. I missed the reactive mailing list announcement. Been busy :)
08:29:47 <Peaker> conal: Added myself to the list
08:30:11 <conal> quicksilver: well, hop on.  it's starting to pick up.  :)
08:31:24 <quicksilver> conal: I might start a counter-revolution! Use quicksilver's reactive implementation, and undermine the establishment!
08:31:36 <telexicon> in parsec how would i make a parser which only works if a string ends a certain way, say for dns, it must start with a letter, in the middle it can be letter, digit or hyphen, but the last character can only be letter or digit (not hyphen)
08:31:52 <conal> quicksilver: if you get the semantics correct, more power to you!
08:32:04 <quicksilver> conal: it was a learning strategy, to be honest.
08:32:17 <Peaker> conal: I enhanced the spin example to spin based on mouse movements, that works well. When I use the time in the "z" axis of translate, it leaks/dies very quickly
08:32:17 <conal> quicksilver: i know.  and a great one.
08:32:25 <quicksilver> conal: I will probably abandon it unless it ends up having a convincing advantage, which seems unlikely.
08:32:37 <vixey> telexicon, ... I tried to think of a way to explain how to do it "Well you just.. write a parser"
08:32:38 <wchogg> conal:  Also, quicky question on the tetris clone I'm working on:  I have an event stream I want to use as "ticks" for dropping blocks based upon the current level, but I also have UI events that can move pieces.  What would be the best way to merge these two effects together into the Behavior Piece I want to animate?
08:32:39 <conal> quicksilver: oh, too bad.
08:32:44 <quicksilver> conal: I have an interesting question for you.
08:32:58 <vixey> telexicon, If you set it out just like you said it.. I think it should parse that correctly
08:33:03 <quicksilver> conal: can you arrange it so that the GC can collect Events which aren't being listened to, even though there is an active Sink ?
08:33:19 <quicksilver> conal: otherwise as the external source keeps pouring into the Sink, you get a memory leak
08:33:29 <telexicon> vixey, ok, but if i do { many (alphaNum <|> char '-'); alphaNum; } then it fails, because the last character gets picked up by the first parser and theres no more input for the second
08:33:51 <camio> wchogg: mappend and then stepper?
08:34:00 <wchogg> quicksilver:  yeah, I've noticed that with experiments in ghci.  I end the main thread, but in the background a leak is still eating up resources.  I've had ghci completely die on me before.
08:34:07 <Cale> telexicon: do x <- letter; xs <- many (letter <|> digit <|> char '-'); z <- letter <|> digit; return (x : xs ++ z)
08:34:07 <nominolo|msr> JaffaCake: http://img147.imageshack.us/my.php?image=notesot7.png
08:34:21 <quicksilver> wchogg: there are circumstances in which the GC can collect background threads.
08:34:38 <quicksilver> wchogg: so the question is, can we arrange that circumstance to apply, to unlistened Events.
08:34:56 <conal> maybe something like henry baker's "incremental garbage collection of processes"
08:35:01 * quicksilver nods
08:35:10 <quicksilver> well I was actually wondering if you could subvert the GHC GC to do it.
08:35:13 <quicksilver> ;)
08:35:54 <quicksilver> real example: I have 'mousePos' (in window coordinates) and 'mouseWP' (in world coordinates), both reactives defined by an even linked to a Sink
08:36:09 <quicksilver> the passive motion callback pumps both Sinks (doing the coordinate transform as needed)
08:36:14 <Peaker> conal: I can't get wx to compile btw, so I can't use phooey :-(
08:36:22 <quicksilver> but unless you actively "listen" to both events, you get a leak.
08:36:24 <wchogg> camio:  Oh *%#(, that would be what the monoid instance of Event is for isn't it?
08:36:36 <camio> wchogg: ;)
08:36:37 <Peaker> conal: do you think it'd be hard for the Phooey UI type to have no coupling at all with wx?
08:36:43 <b_jonas> ghc has weak references already, which may help
08:36:54 <b_jonas> (it has to have those of course to be able to collect unused threads)
08:37:02 <conal> Peaker: probably not.  i'm overhauling phooey to work with reactive.
08:37:08 <conal> (with the new reactive)
08:37:47 <telexicon> Cale, parseTest name "dns"; parse error at (line 1, column 4): unexpected end of input
08:38:09 <conal> wchogg: yeah, that's what Monoid Event is for.
08:39:02 <wchogg> conal:  I knew I was missing something obvious.  Bah!
08:39:19 <conal> wchogg: more tutorials would help.
08:39:25 <conal> s/would/will
08:39:27 <ski_> can you both listen conjunctively respectively disjunctively on events ?
08:39:39 <camio> wchogg: Did you see the Introducing Reactive tutorial?
08:39:55 <conal> ski_: e.g.,?
08:40:00 <quicksilver> ski_: yes.
08:40:04 <wchogg> camio:  Was that the one on Planet Haskell a few days ago with the eggTimer & all that?
08:40:11 <camio> wchogg: yup
08:40:15 <quicksilver> ski_: although I'm not sure what conjunctively would mean
08:40:26 <quicksilver> would it only count if they arrived precisely simultaneously?
08:40:47 <wchogg> camio:  Yeah, I liked that one.  It was very clear.
08:40:51 <quicksilver> (Left <$> a) `mappend` (Right <$> b) is what I would call listening disjunctively
08:41:03 <quicksilver> that's an event which has an occurence when a or b has an occurnece.
08:41:08 <wchogg> camio:  I was just suffering from brain damage earlier.
08:41:15 <quicksilver> (if it happens that "a" and "b" share the same type, you could skip the Left and Right of course)
08:41:24 <ski_> conal : "conjunctively" - listen until all the events in question delivers a value / becomes satisfied (/ whatever) ; "disjunctively" - listen until at least one of the events in question ditto
08:41:31 <Peaker> what's the "defaultGC :: GContext"?
08:41:36 <Peaker> (what's a GContext?)
08:41:52 <vixey> @w80 conjunctiveitis
08:42:07 <quicksilver> ski_: your sense of conjunct isn't quite clear to me. What happens if a arrives, and you're waiting for b, and you get a second occurence of 'a' ?
08:42:07 <lambdabot> Error: thread killed
08:42:37 <conal> ski_: events have multiple occurrences.  so "all the events" would take some defining.
08:42:54 <conal> ski_: i suspect what you mean is related to the Future and Event monads.
08:43:09 <Saizan> isn't conjunctively like <*> and disjunctively like mappend ?
08:43:14 <conal> ski_: or more likely, the Applicative.
08:43:26 <ski_> quicksilver : right .. i think that possibly we should wait until each of them has arrived (doesn't need to be at the exact same time)  .. (but maybe sometimes one'd like some time-frame for each event (from it "arriving"), outside of which the whole event couldn't succeed/match .. ?)
08:43:29 <conal> Saizan: yeah, i think that's it.
08:43:30 <quicksilver> I think maybe ski wants futures?
08:43:37 <quicksilver> futures are guaranteed to arrive only once
08:43:38 <Peaker> does FieldTrip support lighting stuff?
08:43:42 <Peaker> transparency/etc?
08:43:46 <quicksilver> then (,) <$> a <*> b
08:43:53 <quicksilver> sounds like ski_'s kind of conjunction.
08:44:08 <conal> quicksilver: agreed
08:44:18 <quicksilver> whereas Left <$> a `mappend` Right <$> b is disjunction
08:44:24 <quicksilver> (for Futures as well as monads)
08:44:34 <conal> is there a standard name for Left <$> a `mappend` Right <$> b
08:44:34 <quicksilver> but in the future case you're completely discarding the guy who comes second.
08:45:03 * telexicon sighs
08:45:05 <quicksilver> conal: is it something like the "free Alternative" ?
08:45:06 <ski_> quicksilver,conal : quite possibly .. i can't say i know very much about the semantic details of these things
08:45:10 <telexicon> i qualified my question
08:45:20 <telexicon> but then the qualification got ignored
08:45:38 <quicksilver> hmm, no it's not quite right.
08:45:44 <Peaker> conal: I read that you were thinking of using (Reactive SourceCode) and fmapping a compiler on that / etc.  I was wondering if you also thought about modelling revision control into that somehow, that's something I'm struggling with
08:46:25 <quicksilver> conal: if one of the objectives of making a public mailing list was to encourage people to discuss and engage with this interesting work, I think it has succeeded :)
08:46:32 <quicksilver> conal: (if this channel is any guide)
08:46:48 <conal> quicksilver: i guess so!  wow.  :)
08:47:04 <conal> Peaker: yes about "ghc <$> src" (or better, "ghc <*> src").   i haven't thought about revision control.
08:47:29 <Peaker> conal: why ghc <*> src ?
08:47:42 <conal> Peaker: instead of <$> ?
08:47:45 <Peaker> conal: yeah
08:47:46 <Beelsebob_> quicksilver: not (,) <$> a <*> b -- a <^(,)^> b
08:47:50 <Peaker> conal: isn't ghc pure?
08:48:03 <conal> Peaker: ghc varies with time
08:48:05 <Peaker> Beelsebob_: that's a child sticking out his tongue and holding his hands on his ears
08:48:18 <Peaker> conal: ah, cool :-)
08:48:19 <quicksilver> Beelsebob_: :)
08:48:23 <conal> Peaker: yeah!
08:48:41 <quicksilver> Peaker: his tongue is a bit malformed though, poor thing.
08:48:43 <Peaker> conal: what doesn't vary with time, though? :)
08:48:49 <quicksilver> death
08:48:51 <quicksilver> and taxes
08:49:01 <Beelsebob_> Peaker: :D
08:49:04 <conal> Peaker: exactly.
08:49:11 <wchogg> Now wait, the actual tax *rate* does change with time.
08:49:16 <conal> Peaker: that's why frp is so widely applicable.
08:49:22 <ski_> telexicon : this is related to Parsec's (imho) strange treatment of `<|>' (which sits inside `many')
08:50:25 <conal> quicksilver: i want to make sure i understand the event/gc issue. is it that memory leaks when an externally fed event is made but not used?
08:51:27 <telexicon> ski_, ok.. so where do i look
08:52:31 <conal> quicksilver: there may be a solution based on weak references, as i used in DataDriven.  data-driven frp was the original motivation for weak references in ghc.
08:52:38 <wchogg> Yes, using mappend was exactly what I needed.  This is a lot easier than when I first wrote this tetris clone using SDL & StateT
08:53:11 <ski_> telexicon : you might be able to use `many' (or maybe `maybeTill') of Hughes "ReadP" library ..  or you could maybe use `try' of Parsec .. or unfold the loop in `many' in Parsec, and modify it as you want
08:53:15 <conal> wchogg: awesome!  function programming composes well.  imperative badly.  that's the mail point of backus's "liberated" paper.
08:53:45 <conal> imperative programming in haskell is no exception.
08:54:10 <conal> because it uses the same semantic model.
08:54:49 <quicksilver> conal: yes, that's the issue.
08:54:58 <conal> quicksilver: thx.
08:55:16 <velco> what does it mean to "compose well" or to "compose badly" ?
08:55:26 <quicksilver> conal: I essentially reimplemented Concurrent.Chan to build my Sink/Event pairs
08:55:32 <quicksilver> conal: is that the approach you took?
08:55:34 <Beelsebob_> velco: an example might be a drawing package, with a setColour function
08:55:39 <vixey> velco, you can just make a few smaller bits and put them together in lots of different interesting/useful ways
08:55:48 <Beelsebob_> that makes the colour of all operations after that a certain colour
08:55:48 <conal> velco: quicksilver yes.
08:55:59 <vixey> velco, vs. writing everything out for(int i = 0; i < n; i++) and over, again
08:56:00 <quicksilver> ;)
08:56:07 <conal> velco: with semantically predictable, useful, and tractable results
08:56:12 <Beelsebob_> if you write a method that sets the colour and draws a red square, it composes badly with for example a circle drawing function
08:56:22 <ski_> (telexicon : roughly, the problem is that `<|>' in Parsec isn't commutative .. not even upto ordering of possible parses .. however `+++' of ReadP is)
08:56:23 <Beelsebob_> because it your circle will come out red
08:56:27 <Beelsebob_> rather than the original colour
08:56:49 <Beelsebob_> as opposed to the functional way would be to describe the first one as being a square, that's painted red
08:57:09 <Beelsebob_> which composes well with a circle drawing operation -- because the colour change doesn't affect the circle
08:57:25 <Peaker> good example: lock-based thread code  does not compose well
08:57:32 <Beelsebob_> result -- you can predict what the circle drawing operation will do
08:57:34 <conal> velco: www.stanford.edu/class/cs242/readings/backus.pdf
08:57:37 <Beelsebob_> and it'll always do the same thing
08:57:38 <Cale> telexicon: oh, sorry about that... hmm
08:57:48 <telexicon> i have an idea
08:57:59 <telexicon> i ran into this before, i solved it with regex once
08:58:00 <vixey> put try inside the many ?
08:58:01 <Cale> telexicon: Parsec is a bit difficult about backtracking as far as most parser combinator libraries go
08:58:11 <Cale> telexicon: here's a way that works...
08:58:20 <telexicon> theres a way to do it without hackery
08:58:20 <Cale> do x <- letter; xs <- many (letter <|> digit <|> char '-'); guard (last xs /= '-'); return (x : xs)
08:58:35 <quicksilver> conal: I think it will be interesting to see what kind of debugging/profiling questions extensive use of reactive provokes
08:59:01 <Cale> mm... that's dangerous, actually ;)
08:59:11 <conal> quicksilver: me too.
08:59:12 <quicksilver> conal: I have (personally) no doubt at all about the expressiveness of the system, but I do wonder what it will be like to cope with memory and time.
08:59:24 <Cale> null xs || last xs /= '-'
08:59:36 <Beelsebob_> > guard True
08:59:37 <lambdabot>       No instance for (Show (m ()))
08:59:37 <lambdabot>        arising from a use of `show' at <i...
08:59:38 <quicksilver> conal: although on the expressiveness front, I think there are many idioms we have yet to discover.
08:59:43 <quicksilver> conal: but discovering idioms is fun :)
09:00:20 <Beelsebob_> letter <^(:)^> (many (letter <|> digit <|> char '-')) -- I wonder how to nicely get the guard into it
09:00:25 <Beelsebob_> you can easily do it nastily
09:00:28 <conal> quicksilver: i agree about both points: operational behavior can be tricky, and we're just starting to learn how to program reactive systems functionally.
09:00:54 <vixey> @let cons = liftM2 (:)
09:00:55 <lambdabot>  <local>:6:7:
09:00:55 <lambdabot>      Ambiguous type variable `m' in the constraint:
09:00:55 <lambdabot>        `Mon...
09:00:57 <vixey> @let cons = liftA2 (:)
09:00:57 <lambdabot>  <local>:6:7:
09:00:57 <lambdabot>      Ambiguous type variable `f' in the constraint:
09:00:57 <lambdabot>        `App...
09:01:07 <vixey> @set -XNoMoronmorphismRestriction ....
09:01:07 <lambdabot>   Parse error
09:01:18 <vixey> this lambdabot thing keeps getting worse
09:01:22 <Peaker> hehe
09:01:34 <quicksilver> conal: I find my code already looks ugly with all the 'rToB' everywhere. (that is, rToB :: Reactive a -> Behaviour a)
09:01:53 <vixey> quicksilver, would subtyping help ?
09:01:53 <Peaker> I thought the monomorphism restriction applied to (Class a) => a  types, not function types?
09:02:08 <conal> quicksilver: can't you hide Reactive altogether?
09:02:12 <quicksilver> conal: yes.
09:02:15 <conal> quicksilver: the way Reactive does.
09:02:15 <vixey> Peaker, all I know is that it is a huge cause of problems
09:02:15 <conal> ok
09:02:20 <quicksilver> conal: I didn't know it did.
09:02:30 <quicksilver> conal: you don't export `Stepper` ?
09:02:38 <quicksilver> or you export a Behaviour version of it?
09:02:56 <conal> quicksilver: FRP.Reactive doesn't export Reactive.  there's a stepper for Behavior.
09:03:20 <geezusfreeek> Peaker: it applies to functions because the spec (needlessly) requires it :P
09:03:22 <quicksilver> conal: I think that's probably the answer I want. I have some fuzzy idea it's nice to use Reactives because they're more efficient.
09:03:23 <conal> quicksilver: the representations are altogether hidden, to get people to stop breaking the abstractions.
09:03:36 <Peaker> geezusfreeek: ouch
09:03:38 <quicksilver> conal: but I'm just being daft.
09:03:44 <Saizan> Peaker: if it's a function type or not doesn't matter, what matters is if it has formal parameters or not
09:03:47 <quicksilver> (mind you my 'FunTime' doesn't have the K-optimisation yet)
09:03:59 <Peaker> Saizan: formal types?
09:04:00 <geezusfreeek> Peaker: there is -XNoMonomorphismRestriction though :)
09:04:12 <conal> quicksilver: oh, that K optimization is really important!
09:04:27 <Saizan> Peaker: formal parameters, i.e. it applies to let f = \x -> y, but not on let f x = y
09:04:30 <conal> quicksilver: i have mixed feelings as well about exposing Reactive.  i like that the type is more precise in some cases.
09:04:33 <Peaker> geezusfreeek: yeah, but it may make code that looks like its sharing actually not share (which makes sense in the (Class a => a) case
09:04:38 <quicksilver> conal: right.
09:04:40 <conal> quicksilver: more precise in all cases, and applicable in some.
09:04:47 <telexicon> can you have -- double dash in a domain name?
09:04:52 <quicksilver> conal: did you sort out a Monad instance for Behaviour?
09:05:13 <Peaker> Saizan: oh. I forget why there's an interesting difference between them
09:05:28 <conal> quicksilver: it's no problem semantically.  but i don't know how to do reactive-normal-form with join.
09:05:28 <geezusfreeek> Peaker: yeah, that does suck
09:05:32 <quicksilver> Peaker: it's just about expectations.
09:05:39 <conal> quicksilver: doesn't seem doable.
09:05:48 <quicksilver> Peaker: people expect let bindings with no visible parameters to share.
09:06:02 <quicksilver> conal: I certainly can't see how to do it.
09:06:19 <quicksilver> conal: except by special-casing FunTime further
09:06:30 <quicksilver> conal: making functions of particular structure structural
09:06:40 <quicksilver> and only permitting the monad instance when there is enough structure
09:06:43 <quicksilver> (which would be pretty annoying)
09:06:48 <conal> yeah
09:06:53 <ski_> (quicksilver : .. oh, i thought you meant `idioms' a la Conor McBride)
09:07:03 <quicksilver> ski_: no :)
09:07:06 <quicksilver> small "i"
09:07:10 <Peaker> quicksilver: why do you need to rToB? what can you do with a B that you can't with an R?
09:07:57 <Peaker> quicksilver: or is it just for coercion with a required signature?
09:07:59 <wchogg> ski_:  As a tangent, I was sad that they dropped that name.
09:09:46 <geezusfreeek> conal: the description field of your FieldTrip.cabal file links to http://haskell.org/haskellwiki/Reactive instead of http://haskell.org/haskellwiki/FieldTrip
09:09:48 <ski_> reenact idioms !
09:09:51 <Cale> telexicon: ah, here's another way...
09:09:57 <Cale> do x <- letter; xs <- many (letter <|> digit <|> (do char '-'; lookAhead anyToken; return '-')); return (x : xs)
09:10:08 <conal> geezusfreeek: oops!!  thx.
09:10:16 <geezusfreeek> np
09:10:24 <Cale> There's probably a good combinator to use there...
09:10:42 <hackage> Uploaded to hackage: franchise 0.0.6
09:10:42 <hackage> Uploaded to hackage: DebugTraceHelpers 0.12
09:11:00 <geezusfreeek> conal: is fieldtrip complete enough to, say, make a game with yet?
09:11:08 <geezusfreeek> i'm only just now looking at it
09:11:51 <conal> geezusfreeek: i doubt it.  i think fieldtrip and reactive are both going to need some more play & work before ready to do real stuff.
09:12:14 <wchogg> geezusfreeek:  Well, what kind of game?
09:12:34 <quicksilver> Peaker: probably I should jsut use 'B's as conal says.
09:12:41 <quicksilver> Peaker: but 'R' is a more precise type
09:12:45 <quicksilver> you can "join" Rs
09:12:51 <telexicon> Cale, it continues consuming input
09:12:59 <geezusfreeek> wchogg: probably a quite simple one. i will be entering in a 3-month game dev contest soon, and intend to make a haskell entry
09:13:23 <Cale> telexicon: hm?
09:13:30 <Peaker> quicksilver: surely you can't use just B's everywhere, some places need to be R
09:13:38 <conal> wchogg: good point.  depends on what kind of game.  how about the game of playing with reactive & fieldtrip and improving it ;)
09:13:40 <geezusfreeek> not much you can do with just 3 months, so it would be very simple, but i would also feel better if i know that i won't spend a majority of my time fussing with buggy libraries
09:13:56 <Peaker> conal: how can I help debugging the performance issues?  is there an execution tracer that works well?
09:14:05 <wchogg> conal:  I'm totally going to compete in that game. :-P
09:14:15 <conal> wchogg: go, go!
09:14:26 <telexicon> Cale, the lookAhead doesn't make terminate many
09:14:48 <telexicon> that made less sense than is possible
09:14:49 <geezusfreeek> i'm thinking an IO monad version instead of a FRP version is looking more and more likely
09:14:54 <conal> Peaker: i think there are some perf wizards out there to learn from.  e.g., dons and andygill.
09:14:55 <geezusfreeek> the contest starts on dec 1
09:15:12 <conal> geezusfreeek: maybe a functional version next year.
09:15:19 <Cale> telexicon: oh, I see, yes.
09:15:19 <geezusfreeek> conal: that would be nice
09:15:20 <wchogg> geezusfreeek:  Yeah, but that takes a lot of effort from my experience.  You might save a ton of dev time by just doing a reactive version anyway & filing bug reports.
09:15:39 <Peaker> conal: are you working on FRP full-time, in an academic setting, or commercial one?
09:15:39 <conal> hard to know where the tipping point is.
09:16:00 <conal> Peaker: is that three options?
09:16:02 <geezusfreeek> wchogg: i've done stateful games in haskell before, so i know what i'm getting into ;)
09:16:02 <Cale> telexicon: that should probably be lookAhead (letter <|> digit) then
09:16:07 <conal> Peaker: (parsing the question)
09:16:12 <ski_> telexicon : `map fst . filter (null . snd) . (`readP_to_S` "foo-bar") $ do xs <- many (satisfy isAlphaNum +++ char '-'); x <- satisfy isAlphaNum; return (xs ++ [x])' seems to work fine in ReadP, here
09:16:18 <geezusfreeek> just very simple ones
09:16:23 <Peaker> conal: heh, yes/no question + either-question ;)
09:16:24 <wchogg> geezusfreeek:  BTW, what contest is this?
09:16:24 <telexicon> wow
09:16:30 <telexicon> cant i just use a regex?
09:16:33 <geezusfreeek> http://udevgames.com/
09:16:37 <Cale> ski_: Yeah, this is only hard because Parsec is bad at backtracking.
09:16:51 <geezusfreeek> used to be very regular and big, then there was a period of no activity, but it is back this year
09:16:57 <geezusfreeek> probably not as big as it once was though
09:17:05 <wchogg> Aww crap, I totally don't use a Mac though.
09:17:08 <Cale> telexicon: If you want a regex library, there are lots of them.
09:17:24 <telexicon> [a-zA-Z](-[a-zA-Z0-9]|[a-zA-Z0-9])*
09:17:29 <conal> Peaker: i'm doing research & publishing, working some for Anygma, and pretty focused on getting FRP and functional 3D working well.
09:17:30 <geezusfreeek> wchogg: as long as you make is cross platform and have enough access to a mac to build it it can still work :)
09:17:50 <ski_> telexicon : so the parser there is simply your `do { many (alphaNum <|> char '-'); alphaNum; }' (plus i returned the result) .. the other stuff was just calling the parser
09:17:55 <Cale> telexicon: not quite :)
09:18:00 <Peaker> conal: oh the Anygma work is not FRP?
09:18:03 <telexicon> Cale, yeah it doesnt let you do --
09:18:08 <bbs> Cale: i get to pretend haskell is an eager language
09:18:10 <conal> Peaker: it is FRP.
09:18:10 <Cale> telexicon: you missed a * too.
09:18:11 <bbs> and then make it lazy
09:18:24 <telexicon> Cale, its on the end
09:18:25 <Cale> er
09:18:28 <Cale> oh, right.
09:18:29 <Peaker> conal: ah, I envy that ;-)
09:19:19 <Cale> It should probably be [a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]*)*
09:19:24 <conal> Anygma is doing much/most of its work with open source libs, including Reactive & FieldTrip, so in a sense they're sponsoring the effort.
09:19:39 <telexicon> Cale, so it can end in hyphen?
09:19:43 <Peaker> cool
09:19:48 <Cale> It should probably be [a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*
09:19:54 <Cale> sorry ;)
09:20:08 <Cale> Now, let's translate that regex into parsec, for fun :)
09:20:33 <telexicon> parsec can parse any regular grammar ya?
09:20:49 <Cale> yes
09:20:52 <telexicon> it better, or im gonna stab someone
09:20:56 <vixey> I think Parsec is turing complete
09:21:20 <quicksilver> parsec can parse a lot more than any regular grammar
09:21:36 <quicksilver> it can parse any computable language at all.
09:21:36 <telexicon> quicksilver, whats the weather like in sydney?
09:21:42 <quicksilver> I don't know.
09:21:49 <quicksilver> would you like me to ask weather.com for you?
09:22:14 <luite> how would I make an immutable array with default values from an association list? for example [(i,a)] -> Bounds ->  Data.Array i (Maybe a)
09:23:12 <EvilTerran> where'd the default come from?
09:23:13 <Cale> do x <- letter; xs <- many alphaNum; zs <- many (do char '-'; ys <- many1 alphaNum; return ('-':ys)); return (x : xs ++ concat zs))
09:23:54 <luite> EvilTerran: it could be another parameter, in this case I could just map the a -> Just a, and then specify Nothing as the default
09:24:06 <EvilTerran> oh, i see, hence the "Maybe"
09:24:17 <EvilTerran> ?type array
09:24:19 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
09:24:45 <luite> the problem is that the array function fills the array with 'undefined' if there is no association
09:25:30 <telexicon> Cale, this is an annoying problem huh.. -- is allowed
09:26:02 <EvilTerran> maybesArray bounds assocs = array bounds $ [(k,Just v) | (k,v) <- assocs] ++ [(k,Nothing) | k <- range bounds]
09:26:20 <vixey> > map (flip (,) Nothing) [0..]
09:26:21 <lambdabot>   [(0,Nothing),(1,Nothing),(2,Nothing),(3,Nothing),(4,Nothing),(5,Nothing),(6...
09:26:33 <vixey> > [(2,Just "foo")] ++ map (flip (,) Nothing) [0..]
09:26:34 <lambdabot>   [(2,Just "foo"),(0,Nothing),(1,Nothing),(2,Nothing),(3,Nothing),(4,Nothing)...
09:26:56 <vixey> > lookup 2 ([(2,Just "foo")] ++ map (flip (,) Nothing) [0..])
09:26:57 <lambdabot>   Just (Just "foo")
09:27:52 <ksf> Maybe (Maybe a) cries for a special case
09:28:08 <vixey> > join (lookup 2 ([(2,Just "foo")] ++ map (flip (,) Nothing) [0..]))
09:28:09 <lambdabot>   Just "foo"
09:28:31 <mfwitten> Thanks. later.
09:28:55 <luite> vixey: I could of course use accumArray with a list of default values for each index, and a suitable combination function, but that doesn't look very elegant
09:29:14 <vixey> luite, do it the inelegant way
09:29:19 <luite> :(
09:29:30 <ksf> @faq
09:29:31 <lambdabot> The answer is: Yes! Haskell can do that.
09:29:36 <telexicon> oh
09:29:39 <telexicon> duh
09:30:18 <DukeDave> Heh
09:30:32 <Saizan> luite: EvilTerran gave you the solution if you didn't notice
09:30:51 <luite> oh sorry, I didn't
09:31:04 <Saizan> modulo s/array/listArray/
09:32:44 <Saizan> (no, array was fine, sorry)
09:37:58 <telexicon> wow
09:37:59 <telexicon> i did it
09:38:41 <b_jonas> isn't that what join is for?
09:39:16 <luite> EvilTerran: thanks, the 'default values' list should come first though, because the array function only uses the last association for each index
09:40:12 <quix> I just installed hoogle and I'm looking at the Wiki page for it.  Can hoogle show the documentation for functions?  I just get type signatures.
09:42:24 <telexicon> i hope this is accurate
09:42:42 <nominolo|msr> quix: perhaps you hoogle requires haddocks to be available
09:43:50 <b_jonas> @pl \f x -> liftM concat (mapM f x)
09:43:51 <telexicon> Cale, what do you think, do { c <- letter; cs <- do { ns <- many (do hs <- many (char '-'); xs <- many1 alphaNum; return (hs++xs);); return (concat ns); } return (c:cs); } <|> do c <- letter; return [c]
09:43:51 <lambdabot> (fmap join .) . mapM
09:44:14 <b_jonas> yeah, join instead of concat, not much better
09:44:25 <b_jonas> @pl liftM . concat
09:44:26 <lambdabot> fmap . join
09:44:32 <b_jonas> @t liftM . concat
09:44:33 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:44:35 <b_jonas> @type liftM . concat
09:44:37 <lambdabot>     Couldn't match expected type `a1 -> r' against inferred type `[a]'
09:44:37 <lambdabot>     Probable cause: `concat' is applied to too many arguments
09:44:37 <lambdabot>     In the second argument of `(.)', namely `concat'
09:44:38 <telexicon> Cale, its pretty unreadable, but i think it works
09:44:56 <b_jonas> oh, sorry
09:45:01 <b_jonas> @t liftM concat
09:45:02 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:45:04 <b_jonas> @ttype liftM concat
09:45:06 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
09:45:32 <b_jonas> @hoogle (Monad m) => m [[a]] -> m [a]
09:45:33 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
09:45:33 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
09:45:33 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
09:46:05 <b_jonas> um, no, I think sequence won't work here
09:46:11 <b_jonas> how does that even match this hoogle search?
09:46:49 <nominolo|msr> m = t []
09:47:31 <bos> pom tiddly pom pom
09:47:56 <bos> i've been invited to give a haskell talk at next spring's erlang conference here in san francisco
09:48:24 <b_jonas> which one is erlang?
09:48:27 <bos> will i have to wear a kevlar vest?
09:48:51 <nominolo|msr> bos: no, Erlang users feel superiour to Haskell in their domain
09:49:09 <bos> nominolo|msr: i know how erlang users feel, don't worry :-)
09:49:13 <nominolo|msr> bos: or you will see lots of "?" rotating above their head
09:49:45 <bos> frankly, they're right to feel superior about stuff like OTP and some capabilities of the RTS
09:50:13 <nominolo|msr> bos: yup, Erlang is _really_ good at what it's meant for
09:50:37 <bos> haskell could do as well, given a few years of spit and polish, but it's never really been a focus
09:50:49 <Edmilson> can someone help me to install a haskell web server?
09:51:01 <nominolo|msr> well, there aren't that many people working on the runtime
09:51:19 <bos> there aren't many people working on the erlang runtime any longer either
09:51:43 <nominolo|msr> true, but they had corporate backing for quite a while
09:52:15 <nominolo|msr> bos: btw, what's the state of your llvm bindings?
09:52:19 <quix> I install haddock then re-installed hoogle, but hoogle does not give English documentation, only type signatures.  Is it supposed to?
09:52:37 <b_jonas> I think I understand now why return does not have a shorter name
09:52:47 <bos> nominolo|msr: a bit rusty this month. augustss did a bunch of work on them and they are now slightly borked.
09:53:17 <b_jonas> if you use all the more complicated functions like liftM and sequence etc, you don't get to see the primitives that often
09:53:31 <b_jonas> so return occurrs more often while you're learning haskell than later
09:53:31 <bos> but i really want to write a C compiler that uses Language.C and the LLVM bindings, so i'll fix them up
09:53:55 <b_jonas> my code is full of liftM
09:54:03 <quix> Is there a haskell equivalent to ruby's "ri"?  Command-line API documentation query?
09:54:04 <nominolo|msr> bos: i wanted to do some experiments translating core (or a mini-core) to llvm
09:54:13 <nominolo|msr> bos: mostly test out where the issues are
09:54:29 <vegai> quix: not really
09:54:29 <bos> it should be quite similar to generating Cmm
09:54:29 <lambdabot> vegai: You have 1 new message. '/msg lambdabot @messages' to read it.
09:54:38 <b_jonas> nominolo|msr: ah, that would be funny
09:54:39 <nominolo|msr> quix: did you run cabal haddock --hoogle?
09:54:46 <b_jonas> nominolo|msr: llvm is the new c--
09:55:14 <nominolo|msr> b_jonas: yes, it's a bit too early to commit to it, but it'd be interesting to see what you can do with it
09:55:15 <quix> nominolo|msr: I installed haddock then re-installed hoogle.  I thought that would do it.  I didn't know about haddock --hoogle.
09:55:28 <nominolo|msr> quix: see http://www.haskell.org/haskellwiki/Hoogle#Database_Creation
09:55:29 <bos> llvm is quite mature at this point
09:55:39 <lambdabot> Title: Hoogle - HaskellWiki
09:55:53 <vegai> @tell gwern mueval seems to import Data.Number.BigFloat, that's why it depends on numbers
09:55:58 <b_jonas> you can upload it separately or put to a branch without committing it to the main devel version
09:56:00 <nominolo|msr> bos: yes, but we don't know how well it fits with Haskell's requirements for an RTS
09:56:02 <lambdabot> Consider it noted.
09:56:55 <bos> nominolo|msr: true. it's pretty agnostic in general, so it shouldn't be tough. it doesn't prescribe anything about important issues like data layout, threads, or GC.
09:57:07 <b_jonas> nominolo|msr: well, you can even talk to the llvm guys to change something in llvm to make it better if there's some small thing that could improve it as a haskell runtime
09:57:14 <nominolo|msr> bos: i was thinking about having some kind of typed DSL for code generation that uses LLVM as the back end
09:57:23 <b_jonas> nominolo|msr: it's already extensible with foreign functions I think
09:57:30 <bos> nominolo|msr: that's what the LLVM bindings are
09:57:36 <quix> nominolo|msr: thanks.  I'm using macports, so I figured it would have handed whatever the config flags.
09:58:00 <quix> I guess I shouldn't used macports
09:58:05 <b_jonas> I heared gcc-llvm was quite stable these days
09:58:16 <nominolo|msr> bos: i was aiming for more expressive typing, like GC invariants; but that's pie-in-the-sky
09:58:42 <bos> nominolo|msr: we use type-level integers to encode e.g. register widths, so it's a lot more strongly typed than bindings in other languages
09:59:09 <nominolo|msr> quix: i haven't used it myself, yet, but i'm planning to use it as a library in my IDE lib, soon
09:59:13 <b_jonas> nominolo|msr: do you mean for supporting a strict (not conservative) gc?
09:59:23 <bos> nominolo|msr: what are you doing at MSR at the moment>
09:59:40 <conal> Peaker: ping
09:59:46 <b_jonas> nominolo|msr: I think llvm would make strict gc more easy normally because of how the root set for gc is more explicit than in native code
09:59:49 <Peaker> conal: here
09:59:55 <nominolo|msr> bos: working on this http://code.google.com/p/scion-lib/ and fixing GHC bugs/adding features where needed
09:59:58 <b_jonas> but I could be wrong here, I'm not good in this kind of thing
10:00:15 <bos> nominolo|msr: IDE-like functionality?
10:00:22 <bos> nominolo|msr: so stuff like autocompletion?
10:00:36 <conal> Peaker: looking at your comment about env passing ("The example even used an undefined error value in place of the env in some cases ...").  now i found it.  nm.
10:00:48 <Peaker> conal: oh you were wondering about what error?
10:00:51 <nominolo|msr> bos: i can load a cabal project and highlight warnings, insert pragmas and language flags
10:00:57 <conal> Peaker: yeah.
10:00:59 <nominolo|msr> bos: but i want a lot more
10:01:02 <Peaker> conal: I added use of mouse events there, so I stumbled upon the error
10:01:11 <Peaker> conal: Kind of an argument against explicit env passing
10:01:24 <conal> Peaker: oops.  i didn't realize i'd left it in there.  and i totally agree with you.  i'm working on an alternative.
10:01:29 <bos> nominolo|msr: yes, stuff like visual studio's context-sensitive completion would be *gorgeous*
10:01:32 <nominolo|msr> bos: but yes, autocompletion is one of the things to come soon
10:01:51 <nominolo|msr> bos: yes, that's a little trickier in haskell, since functions are global
10:02:15 <conal> currently interaction isn't done in a nicely modular/composable way.  i'm going to fix that.
10:02:19 <nominolo|msr> bos: and local type inference doesn't work so well with the current GHC api; but we have some ideas how it might be doable
10:02:28 <bos> nominolo|msr: cool
10:02:48 <b_jonas> I think I'll need ST here
10:02:49 <bos> nominolo|msr: even having the ability to accurately jump to a place in the code (a la ghctags) would be a big step
10:03:05 <nominolo|msr> bos: well, ghctags works again
10:03:23 <conal> Peaker: could you give an example of using the reader Applicative that's different from what i'm doing now?
10:03:26 <nominolo|msr> so that should be straightforward to implement
10:03:55 <Peaker> conal: ok, sec
10:03:56 <nominolo|msr> bos: do you use emacs or vim?
10:04:00 <conal> Peaker: oh, e.g., in lplace.
10:04:02 <bos> nominolo|msr: emacs
10:04:11 <bos> nominolo|msr: but ghctags works only in HEAD, right?
10:04:19 <nominolo|msr> bos: yes
10:04:31 <b_jonas> can't you just search for the function name starting at the first column?
10:04:33 <nominolo|msr> but i can make it available as a separate package
10:04:34 <conal> Peaker: the commented version of lplace, using liftA2?  lplace = place <$> liftA2 snapshot_ leftButtonPressed mouseMotion
10:04:42 <b_jonas> well, that's not perfect, it doesn't work for methods and operators
10:04:45 <b_jonas> hmm
10:04:56 <Peaker> conal: yeah
10:04:59 <Peaker> conal: I didnt notice that ;)
10:05:02 <b_jonas> but jumping to the defn of a method is hard anyway for you need to know the type
10:05:15 <nominolo|msr> @hackage ghctags
10:05:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghctags
10:05:27 <Peaker> conal: I guess maybe Applicative needs syntax sugar like "do"
10:05:33 <Peaker> conal: to be more comprehensible :)
10:05:45 <conal> Peaker: except functional-looking (unlike "do")
10:06:27 <conal> Peaker: i've been doing the applicative trick, but uneasily. it only works to a point.  with reactivity, the input fed to later stages has to be shifted or pruned.
10:06:34 <nominolo|msr> bos: http://img147.imageshack.us/my.php?image=notesot7.png
10:06:42 <conal> Peaker: in time, that is.  similarly for space.
10:06:44 <quix> Can I define a type consisting of 12 Ints without typing Int 12 times?
10:06:58 <b_jonas> quix: an array?
10:07:03 <Peaker> conal: But in this case, the applicative is simply the reader applicative and it is completely equivalent?
10:07:10 <bos> nominolo|msr: nice!
10:07:14 <Peaker> conal: I'm not sure I understand why it fails to work at a point
10:07:15 <quix> b_jonas: yes, but can it be an array of exactly 12 Ints?
10:07:24 <conal> quix: you could do something like "Three (Four Int)" if you don't mind extra structure.
10:07:54 <b_jonas> well, in theory you could define a newtype on array and only export a creator function that creates an array of 12 ints
10:07:57 <Peaker> conal: you could also enforce the env-passing with a newtype around (UI ->) that hides the data constructor
10:08:00 <b_jonas> or what conal says
10:08:01 <conal> Peaker: it's a subtle issue i've been thinking about for years.  i'll blog about it.
10:08:03 <nominolo|msr> bos: next features on the list are: - type-check when i stop typing;  - navigatie to errors
10:08:18 <b_jonas> and of course you could type I = Int if you just want to type less
10:08:42 <conal> quix: is there some structure to the 12 ints?  do they mean something?
10:08:44 <b_jonas> but then your code would look like Iverson's C code, not what haskellers are used to
10:09:08 <quix> conal: Actually it's 13 playing cards.  A hand of spades.
10:09:28 <quix> I liked about the Int for simplicity
10:09:31 <quix> *lied
10:09:48 <Peaker> conal: sorry to press it, but do you have an example I can look at to see when it fails?
10:10:31 <whampyre> is debuging haskell ez?
10:10:42 <hackage> Uploaded to hackage: regex-tdfa 0.95.2
10:10:42 <hackage> Uploaded to hackage: FieldTrip 0.2.2
10:10:50 <whampyre> squeak and smalltalk users say with running objects you save and can see change so debugging is ez as pie
10:10:51 <bos> nominolo|msr: that's great
10:11:22 <vegai> whampyre: not extremely easy, but people think debugging is more rarely needed
10:11:40 <Saizan> easy! data Vec n a where VNil :: Vec Zero; VCons :: a -> Vec n a -> Vec (Succ n) a; type Ints = Vec (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)..) Int
10:12:14 <b_jonas> is MArray really a multi-argument class without fundep? is that because there is (or was) some compiler that supports multi-argument templates but not fundeps?
10:12:39 <conal> Peaker: sure.  i ran into it even with lplace.  i want each animation to be interactive.  but each one must interact with a different user, in the sense of shifted in time.
10:12:50 <b_jonas> I mean, the monad parameter could depend on the array parameter
10:12:55 <nominolo|msr> b_jonas: yes
10:13:09 <conal> Peaker: in other words the human sees multiple animations.  but the single interactive animation instead sees multiple humans.
10:13:11 <Peaker> conal: oh, so you put UI inside a Reactive/Behavior and use that?
10:13:22 <conal> Peaker: ??
10:13:38 <Peaker> conal: How can you pass a different UI to different functions you call?
10:13:50 <Peaker> conal: that's what I gathered from "each one must interact with a different user"
10:14:48 <Peaker> conal: maybe I misunderstand what you mean by the "user" the animation sees? is it not the "env" (UI)?
10:15:18 <conal> Peaker: yes.  different users/envs (shifted in time & space).
10:15:55 <Peaker> conal: ah, how does explicit env passing let you achieve that effect?
10:15:59 <mib_z8naal> Does the community have a FreeBSD machine with GHC on it open to the "public"?
10:16:08 <Peaker> conal: I was speculating that maybe it is by putting the env inside a Behavior or such, maybe that's completely off-track :)
10:16:11 <conal> Peaker: it doesn't.  at least not conveniently.
10:16:12 <dons> how good is your japanese, http://d.hatena.ne.jp/inajob/20081005#1223252776
10:16:20 <dons> anyone work out the license on this gui/twitter client?
10:17:30 <conal> Peaker: an env in a behavior is fine, as long as it's polymorphic.  that's the idea of signal transformers, if you look in the original arrow-frp paper "genuinely functional user interfaces".
10:18:07 <conal> then input can get inversely transformed in time & space.
10:18:49 <conal> which is what the reader functor/applicative/monad doesn't do
10:19:07 <conal> on its own
10:20:01 <Peaker> I don't fully understand that, hopefully the blog will clear things up
10:20:30 <Peaker> I am not sure why an arrow allows any kind of inversions for example (given that an "arr func" arrow is non-invertible)
10:20:35 <_pizza_> how can i calculate the size of an Enum?
10:20:47 <Peaker> _pizza_: I think only Bounded enums have size
10:21:00 <Peaker> @type fromEnum
10:21:01 <lambdabot> forall a. (Enum a) => a -> Int
10:21:12 <b_jonas> even Integer and Float are Enums
10:21:28 <conal> Peaker: one can use a type of invertible functions, as in Data.Bijection from TypeCompose
10:21:30 <Peaker> Then you can probably use:  (fromEnum maxBound - fromEnum minBound)
10:21:40 <Peaker> > succ 5.5
10:21:41 <lambdabot>   6.5
10:21:50 <conal> Peaker: for the transforms.
10:21:56 <conal> in time & space
10:22:03 <mib_z8naal> cool
10:22:05 <mib_z8naal> View patterns are really nice
10:22:06 <Peaker> conal: but how do you prevent use of pure non-invertible functions in your arrow?
10:22:57 <Peaker> conal: (i.e: the use of "arr")
10:23:00 <conal> Peaker: it's not the signal transformers that have to be inverted.  just the transforms applied to them.
10:23:43 <Peaker> conal: Oh. I see, thought its hard for me to imagine why you only want to invert part of the arrow's computation?
10:23:47 <Peaker> s/thought/though
10:25:55 <conal> Peaker: it'll be much clearer when you see the details.
10:26:27 <vixey> @let range = fromEnum maxBound - fromEnum minBound
10:26:28 <lambdabot>  Add a type signature
10:26:30 <ertai> What about a Data.List.prolongate http://hpaste.org/11942#a0 ?
10:26:35 <vixey> lambdabot--
10:27:04 <vixey> ertai, you want that in the standard library ??
10:27:54 <ertai> not necessary, I'm wondering if it's a usefull function in general
10:28:04 <vixey> ertai, Have you ever used it?
10:28:39 <ertai> just now, that's why I've wrote it
10:28:48 <vixey> what for?
10:29:58 <Deewiant> that's xs ++ repeat (last xs)?
10:31:07 <ertai> Deewiant: morrally yes, that the spec, however it's better for lazy lists
10:31:47 <Deewiant> yes, that implementaton's single-pass, just checking to see whether I got it correct :-P
10:32:21 <ertai> vixey: I wanted a variant of zip`ap`tail such that the last one got paired with itself
10:32:43 <ertai> and so I use zip`ap`(tail . prolongate)
10:33:02 <vixey> ertai, so that function goess "fox" ~~> [(f,o)(o,x)(x,x)] ?
10:33:54 <noZone> What is the reason why the types Float and Double are not part of the Bounded class? Aren't they hardware dependent?
10:33:54 <Deewiant> might be better to write a version of zip`ap`tail that does that :-)
10:33:54 <ertai> vixey: yes
10:34:12 <Deewiant> noZone: they're not bounded in the sense that they contain the value infinity
10:34:14 <vixey> ertai, so I'm really curios.. hwat do you use _that_ for?
10:34:18 <Cale> telexicon: aha, (just got back), I think it ought to be "[a-zA-Z]([a-zA-Z0-9]*-)*[a-zA-Z0-9]+", that doesn't end in a - and allows for multiple hyphens in a row.
10:34:38 <noZone> Deewiant: tx
10:34:45 <b_jonas> oh, I see
10:35:12 <quix> Is there a particular convention about when to explicitly specify a type signature verses leaving it up to inference?  My initial thought is that one should not explicitly specify unless it's needed, so that things are maximally general.
10:35:30 <Deewiant> quix: keep -Wall quiet and you're good ;-)
10:36:02 <ertai> vixey: that function check that a list is sorted http://hpaste.org/11944#a0
10:36:06 <Peaker> quix: -Wall thinks you should specify all top-level things. If you use a general type signature, you're just as general
10:36:17 <Peaker> quix: You can use the types inferred by copying them from -Wall warnings
10:36:55 <vixey> ertai, ahhh
10:36:57 <Deewiant> -Wall can be somewhat annoying to code against though
10:37:06 <vixey> ertai, I suggest that you write this in a different way
10:37:15 <vixey> ertai,
10:37:18 <ertai> I suggest you the same :)
10:37:19 <vixey> sorted [] = True
10:37:21 <vixey> sorted [_] = True
10:37:29 <vixey> sorted (x:y:zs) = something else
10:37:39 <Cale> telexicon: Which is Parsec-able, but you need a 'try'
10:37:39 <vixey> all this zip ap stuff is completely ludicrous
10:37:44 <Cale> parseTest (do x <- letter; ys <- many (try (do us <- many alphaNum; char '-'; return (us ++ "-"))); zs <- many1 alphaNum; return (x : concat ys ++ zs)) "ab--c"
10:37:50 <ertai> vixey: note that this function returns the given list on demand
10:37:51 <Deewiant> sorted = ap (==) sort
10:38:34 <ertai> Deewiant: my is perhaps to big to sorted there
10:38:53 <ertai> +list
10:39:03 <Deewiant> ertai: have you tried it? :-P
10:39:27 <Deewiant> I mean sure, it is slower, but don't optimize until you need to or know you will need to
10:40:29 <ertai> Deewiant: to be fair I finally sort them instead of checking, but that's not viable these files will be pretty big in future
10:41:12 <Cale> ertai: What's this (b -> b -> String)?
10:41:41 <Cale> Oh, something for generating an error when you find it's not sorted?
10:41:46 <ertai> that's a bit specific this function is not supposed to be a library one
10:41:52 <ertai> Cale: right
10:42:07 <Cale> er... why does this thing return a list?
10:42:45 <Cale> Maybe I'm misunderstanding what it's supposed to do based on the name ;)
10:43:27 <ertai> Cale: if the list is sorted then that's the identity otherwise it's an error
10:43:38 <Cale> Why not make it a Bool at least?
10:43:44 <vixey> ertai, yeah sorry this code confused the hell out of me
10:43:45 <Cale> Or a Maybe (a,a)?
10:43:59 <vixey> ertai, why not a boolean?
10:44:10 <Peaker> is there a standard type-class for Monoid + neg :: a -> a that can be used to generate items that cancel out mappends (only if applied immediately and in reverse order)?
10:44:12 <ertai> I want this to be computed lazily
10:44:44 <Peaker> a `mappend` b `mappend` c `mappend` (neg c) `mappend` (neg b) == a
10:45:07 <Peaker> or mconcat [a,b,c,neg c,neg b,neg a] == mempty
10:45:17 <Cale> ertai: Hmm, so you want the failure to happen as late as possible?
10:45:50 <askentasken> doesnt haskell-mode come with ghc-10?
10:45:54 <Peaker> can formulate as: \x -> mconcat (x ++ (map neg . reverse) x) == mempty
10:46:13 <Cale> askentasken: Haskell-mode?
10:46:17 <b_jonas> Peaker: so you want a group
10:46:22 <Cale> (also, ITYM 6.10)
10:46:38 <Peaker> b_jonas: is there a type-class?
10:46:39 <ddarius> Peaker: No.  That's not a particularly nice structure.  The nicer structure of a Group isn't even in the standard libraries.  (Actually, even Monoid isn't in the actual standard libraries.)
10:46:46 <b_jonas> Peaker: I don't think so
10:47:00 <Cale> ddarius: "actual"?
10:47:13 <ddarius> @where report
10:47:14 <lambdabot> http://www.haskell.org/onlinereport/
10:47:14 <Peaker> b_jonas: doesn't a group allow them to be in a different order than LIFO?
10:47:29 <b_jonas> Peaker: wait, there might be one in that numeric tower library
10:47:30 <Cale> ddarius: Oh, all the "actual" standard libraries are deprecated then ;)
10:47:36 <Peaker> I am not sure what I described is actually a Group, because of the LIFO requirement..
10:47:43 <b_jonas> Peaker: on cabal
10:48:33 <ddarius> Peaker: Some groups would count and your particular instance might be a group (do you actually have associativity of mappend though?)
10:48:55 <ertai> Cale: yes I want consume this list only once
10:49:00 <ddarius> Anyway, what do you want to happen when a `mappend` neg b is written?
10:49:03 <Peaker> ddarius: Its actually for patches
10:49:27 <Peaker> ddarius: mappend is for joining dependent patches
10:50:51 <telexicon> Cale, the one i sent you worked
10:51:10 <b_jonas> Peaker: you could look at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric-prelude but I think even that doesn't have such a class
10:51:12 <Cale> telexicon: okay :)
10:51:28 <telexicon> Cale, thanks for your help and suggestions :)
10:51:51 <b_jonas> or jsut write your own
10:52:43 <lilac> class Monoid g => Group g where minverse :: g -> g
10:52:50 <Peaker> b_jonas: I guess its missing, yeah
10:53:09 <b_jonas> Peaker: maybe write one
10:53:16 <Peaker> b_jonas: yeah
10:53:18 <lilac> or write a Num instance *ducks*
10:53:23 <Peaker> lilac: what is mconcat [a,b,minverse a, minverse b] ?
10:53:35 <lilac> Peaker: depends on the instance, obviously
10:53:40 <ddarius> Peaker: That's the question I asked you.
10:53:43 <Peaker> lilac: why not mempty?
10:53:49 <Peaker> ddarius: in my case, its a bottom
10:53:50 <vixey> ertai, did I miss anyting?
10:53:54 <lilac> Peaker: because it's not necessarily an abelian group
10:53:57 <b_jonas> Peaker: because it's not a commutative group, just a group
10:54:02 <Cale> ertai: should the first element of the first pair which are in the wrong order be generated?
10:54:13 <b_jonas> there is a class in that library I linked to for commutative groups
10:54:23 <Peaker> lilac, ddarius: So its allowed to be bottom in a non-cummutative group?
10:54:45 <ddarius> Peaker: No.  But you can have bottom be in your group (maybe)
10:54:54 <b_jonas> Peaker: not if you understand group like mathematicians do because there minverse and mappend are clsoed
10:54:56 <ddarius> Peaker: Non-commutative means ab /= ba
10:55:08 <vixey> people with IRC nicks like 'a' and 'name' should not be allowed -_-
10:55:19 <ddarius> I suspect Peaker doesn't even have a monoid.
10:55:35 <Peaker> ddarius: well, what if you try to "append" a patch to one of the wrong result?
10:55:37 <vixey> or I should figure out how to make less things clickable
10:55:44 <lilac> Peaker: no, it can't be bottom in a non-trivial Group, because mconcat [a,b,minverse a, minverse b] `mappend` mconcat [b,a,minverse b,minverse a] must be mempty
10:55:50 <Cale> Bottom can't be considered an element of the group.
10:55:53 <b_jonas> vixey: as for 'a' in particular, you can get it dropped and register it
10:56:05 <vixey> b_jonas, I'd feel mean :/
10:56:06 <Peaker> I see, so indeed I don't have a Monoid
10:56:10 <vixey> b_jonas, someone is using it..
10:56:12 <ddarius> Peaker: As b_jonas said, the notion of monoid and group are closed. mappend and minverse should be applicable to any element.
10:56:12 <lilac> Peaker: it can be bottom in a group where the only element is bottom, though
10:56:16 <Cale> Well, unless the group is trivial...
10:56:52 <ddarius> Peaker: Ironically, what you probably want is a groupoid.
10:57:01 <lilac> hi, i'm your redundant Cale backup. i'll be here all week :)
10:57:13 <Cale> lilac: hehe :)
10:57:24 <Peaker> ddarius: what is that?
10:57:30 <RLa> can i use lamda without any parameters?
10:57:39 <Cale> RLa: No, you'd never need to.
10:57:48 <Cale> RLa: If you don't have any parameters, you have a constant.
10:57:55 <b_jonas> , \ -> 5
10:57:56 <vixey> RLa, why?
10:58:03 <lunabot>  luna: parse error on input `->'
10:58:03 <Peaker> RLa: a function always has exactly 1 parameter.  If it takes 0 args, it is simply the result, without being a function at all
10:58:06 <ddarius> Peaker: It's like a "typed" group.  It's a category where all arrows are isomorphisms.  The monoid "equivalent" would just be a category.
10:58:09 <b_jonas> looks like you can't
10:58:13 <RLa> yes, but \ -> 5 gives syntax error
10:58:18 <vixey> , (\() -> 5) ()
10:58:19 <Cale> RLa: rightly so ;)
10:58:21 <lunabot>  5
10:58:27 <Peaker> ddarius: I don't have CT background..
10:58:27 <vixey> RLa, but why do you want to?
10:58:29 <Cale> RLa: Why do you want it to be a lambda?
10:58:37 <Cale> RLa: What's the type of the function you want?
10:59:01 <ddarius> Peaker: You don't need to.  Do you think you understand what I mean by "'typed' group"?
10:59:02 <ertai> Cale: I didn't get your last sentence
10:59:16 <Peaker> ddarius: I'm not sure I did
10:59:21 <Cale> ertai: Well, it's about when the error actually occurs...
10:59:32 <RLa> i'm actually translating haskell-like language and thought it might be good idea to write all declarations as lambdas
10:59:34 <Peaker> ddarius: I could take it to mean that only mappends between rightly typed elements are allowed?
10:59:41 <vixey> RLa, I think not
10:59:43 <ddarius> Peaker: Correct.
10:59:58 <RLa> so c = 2 would have become c = \ -> 2
10:59:59 <vixey> RLa, is your haskell like language lazy? and what do you implement it in?
11:00:04 <Peaker> RLa: why?
11:00:06 <Cale> RLa: why would it become that?
11:00:07 <ertai> Cale: I know when I've consumed the list, that the error occured if needed
11:00:19 <ddarius> Peaker: Each element would have an input type and an output type and the output type of one would have to match the input type of another.
11:00:22 <RLa> yes, it is lazy
11:00:25 <ddarius> s/another/the other
11:00:33 <vixey> RLa, oh cool
11:00:39 <RLa> it will run on some obscure virtual machine
11:01:04 <vixey> RLa, so you're writing a compiler for it ? (in what?)
11:01:05 <Cale> RLa: You could of course make it a constant function...
11:01:07 <Peaker> ddarius: So darcs' phantom type params in the Patch type make Patch a typed group?
11:01:19 <Cale> RLa: like a function which ignores its parameter and always gives the same thing
11:01:27 <Cale> RLa: But it's unclear why you'd want to do so...
11:01:58 <Cale> Are you trying to avoid memoisation of constants?
11:02:02 <RLa> just thought it might simplify translating since i already know what to emit on lambdas
11:02:08 <ddarius> Peaker: Maybe.  I haven't looked at darcs code.  There are still axioms that would need to be satisfied.
11:02:13 <roconnor> ddarius: Okay I see the difference between covectors and bivectors.  reflecting the normal of the xy-plane through the xy-plane as covector flips the covector, but as a bivector, the normal remains fixed.
11:02:26 <vixey> RLa, I don't get it.. haskell doesn't have  \ -> 2  but that doesn't mean your language can't have it
11:02:54 <RLa> vixey, yes, i must make that clear with my instructor
11:03:10 <b_jonas> I'm confused
11:03:17 <Peaker> ddarius: http://www.physics.oregonstate.edu/~roundyd/talks/cs_colloquiem.pdf  is a nice slideshow you can skim through to see darcs Patch definitions
11:03:18 <RLa> one way is to write nullary lambdas into constants not vice verse
11:03:21 <b_jonas> I want to nest two monads
11:03:33 <Cale> b_jonas: which ones?
11:03:43 <ddarius> Peaker: I have no interest in darcs' code.
11:03:45 <b_jonas> a state-like monad and ST
11:03:53 <vixey> RLa, What method do you compile your code into the VM?
11:03:54 <Peaker> ddarius: Ok. Its not code, just a bit of background/theory
11:04:04 <Peaker> ddarius: if you're interested, of course
11:04:09 <Cale> b_jonas: so, you're going to use ST to compute a State computation, or vice versa?
11:04:17 <b_jonas> the ST to compute a State
11:04:29 <unenough> every subset of likely-typed objects would form a group, no?
11:04:39 <b_jonas> so the type is ST s (State StdGen a)
11:04:46 <b_jonas> wait, I'll paste some code
11:04:50 <Cale> unenough: Under what operation?
11:04:57 <RLa> vixey, i think it is descibed in here: http://www.springer.com/computer/programming/book/978-3-540-49596-3
11:05:02 <ddarius> roconnor: What is the definition of "reflecting hrough a covector/bivector"?
11:05:08 <quix> Is there an official name for this function?  I haven't found it in the base libs:  allValues :: (Bounded a, Enum a) => [a] ; allValues = [minBound..maxBound]
11:05:20 <RLa> but i can't read it since i do not know german
11:05:22 <Cale> unenough: Also, in Haskell, you have to be careful, since not all functions on a Haskell type are Haskell-definable.
11:05:24 <unenough> Cale, i'm referring to Peaker's idea.
11:05:55 <arjanb> @hoogle Enum a => [a]
11:05:55 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
11:05:55 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
11:05:55 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
11:06:09 <Peaker> ddarius: anyhow, thanks for the explanations
11:06:10 <roconnor> ddarius: the linear trasformation represented by [[1,0,0],[0,1,0],[0,0,-1]]
11:06:14 <FunctorSalad> vector maps can act on covectors by the transpose/pullback...
11:06:25 <FunctorSalad> if covector = linear functional here
11:06:31 <b_jonas> here: http://erxz.com/pb/13420
11:06:46 <RLa> vixey, this is virtual machine that will run the code: http://wwwseidl.in.tum.de/projekte/vam/
11:06:46 <Peaker> what's enumFromThen?
11:06:50 <unenough> Cale, so all patches with type a->b (borrowing function notation) would form a group under mappend and 'minverse'
11:06:50 <b_jonas> I made a random state monad (turns out there's already one on cabal that uses saner names)
11:06:52 <Peaker> > enumFromThen 5 8
11:06:58 <b_jonas> and I want to write a shuffle for that
11:07:04 <lambdabot>   [5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,8...
11:07:08 <b_jonas> but for the shuffle I'd like to use a temporary STArray
11:07:23 <unenough> i meant a specific a->b
11:07:23 <Cale> b_jonas: ... whoa
11:07:47 <roconnor> ddarius: that transformation, f, acts on the covector [0,0,1], c, by f(c) = - c, but acts on the bivector (y/\z) by f(y/\z) = y/\z.
11:07:49 <Cale> b_jonas: Let me start by reformatting that so I can read it :P
11:08:37 <b_jonas> should I rename the random monad functions at the top to match those in the MonadRandom cabal library?
11:08:57 <roconnor> ddarius: so you get fundamentally disinguishable results if you chose to represent normals by covectors or bivectors.
11:10:42 <hackage> Uploaded to hackage: plugins 1.3.1
11:10:42 <hackage> Uploaded to hackage: stringtable-atom 0.0.5
11:10:42 <hackage> Uploaded to hackage: reactive-fieldtrip 0.0.3
11:10:42 <hackage> Uploaded to hackage: feed 0.3.5
11:10:50 <Peaker> it seems Haskell's type-classes were designed for convenience, sometimes at the expense of correctness (according to http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric-prelude). And class aliases would allow both convenience and correctness
11:11:04 <roconnor> ddarius: er, but acts on the bivector (x/\y) by f(x/\y) = x/\y.
11:11:16 <roconnor> sorry.
11:11:23 <ddarius> roconnor: That's the same statement.
11:11:36 <ddarius> Oh, nevermind.
11:11:36 <b_jonas> everyone says the h89 numeric classes aren't really good, but we disagree on what the good one would look like
11:11:42 <ddarius> I knew what you meant.
11:13:33 <mdmkolbe> @hoogle (b -> m c) -> (a -> m b) -> a -> m c
11:13:34 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
11:13:34 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
11:13:34 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
11:14:48 <b_jonas> @src StateT (>>=)
11:14:49 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:16:42 <Cale> b_jonas: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=471#a471
11:16:59 <Cale> b_jonas: okay, so that's nicely formatted now, we can look at what it's doing :P
11:18:55 <Cale> b_jonas: It seems to always cycle the elements of the list.
11:19:01 <Cale> (by exactly one position)
11:19:05 <b_jonas> yes
11:19:08 <b_jonas> see the comment
11:19:09 <Cale> [1,2,3,4,5] -> [5,1,2,3,4]
11:19:19 <Cale> ah, okay
11:19:46 <b_jonas> newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
11:19:56 <Cale> Well, you're not in the RandomState monad there.
11:20:08 <Cale> You're working in ST.
11:20:14 <b_jonas> yes, I should be in both
11:20:33 <Cale> Well...
11:20:35 <b_jonas> I think this might not work because I need a RandomStateT
11:20:53 <Cale> Have you seen MonadRandom, by the way?
11:20:54 <b_jonas> I can't just work with RandomState becuase it's not a transformer
11:20:59 <b_jonas> yeah, that's what I said
11:21:03 <b_jonas> but only after I wrote this
11:21:07 <Cale> Perhaps I missed that...
11:21:07 <b_jonas> I should use that
11:21:30 <b_jonas> am I right in that I can't just do this without converting RandomState to a monad transformer instead of just a monad?
11:21:40 <Cale> Well, of course you can do it without...
11:22:00 <b_jonas> I mean
11:22:04 <b_jonas> I don't need its monad instance
11:22:06 <Cale> I think what you'd probably do is use the RandomState monad to build an appropriate ST computation.
11:22:37 <b_jonas> but I can't just make the inner function f :: ST s (RandomState a)
11:23:12 <jdrake> :t (<-)
11:23:13 <lambdabot> parse error on input `<-'
11:23:54 <b_jonas> it has to be f :: StdGen -> ST (a, StdGen)
11:23:57 <b_jonas> hmm
11:24:00 <Cale> But this is all a very complicated way to solve this problem, I think.
11:24:08 <b_jonas> sure, I could just use IO
11:24:18 <Cale> Yeah, try just using plain ST and StdGens.
11:24:19 <b_jonas> which has both a random generator and IOArrays
11:24:55 <b_jonas> I think I'll download the MonadRandom package
11:25:00 <Cale> Also, how long are the lists which you're shuffling?
11:25:03 <b_jonas> and import it
11:25:34 <_pizza_> > 1^2^3^4
11:25:36 <lambdabot>   1
11:25:44 <_pizza_> > 1^2^3^4^5
11:25:47 <b_jonas> Cale: at most a few thousand elements
11:25:51 <b_jonas> in this app
11:25:58 <lambdabot>   mueval: Prelude.read: no parse
11:25:58 <lambdabot>  mueval: out of memory (requested 68157440 b...
11:27:33 <Deewiant> > 3^4^5
11:27:34 <lambdabot>   373391848741020043532959754184866588225409776783734007750636931722079040617...
11:28:58 <Baughn> > 1^2^3^4
11:29:00 <lambdabot>   1
11:29:07 <Baughn> ..doh
11:31:58 <Philonous> @src (^)
11:31:58 <lambdabot> x ^ 0            =  1
11:31:58 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
11:31:58 <lambdabot>   where f _ 0 y = y
11:31:58 <lambdabot>         f x n y = g x n
11:31:58 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
11:32:00 <lambdabot>                       | otherwise = f x (n-1) (x*y)
11:32:02 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
11:32:08 <vixey> that is crazy
11:33:18 <Peaker> why is (^) not implemented in a more generic fashion?  Its probably not that rare to want to have to do y to x as ^ is to *
11:34:36 <DrSyzygy> vixey: It's not all that crazy.
11:35:09 <DrSyzygy> Or wait ... are you talking about the square-and-multiply or about locking it down to the semantics of ^ wrt *?
11:35:10 <b_jonas> Peaker: define it as (f ^: n) x = iterate f x !! n;
11:35:53 <Peaker> b_jonas: yeah but why not have a reusable nice logarithmic algorithm, instead of one that's coupled with ^ and *?
11:35:54 <b_jonas> Peaker: or as something with execState sequence_ replicate modify
11:36:12 <b_jonas> oh, that one
11:36:21 <Peaker> b_jonas: ^ expresses a useful algorithm, which is not useful only for ^ and *
11:36:25 <b_jonas> that only works for associative functions, I see
11:36:46 <DrSyzygy> Peaker: It _does_ use more semantics than just "binary function" though.
11:36:59 <b_jonas> yeah, associative binary functions
11:37:01 <DrSyzygy> And it's most useful for *, and there's no way of guaranteeing it for anything else.
11:37:05 <b_jonas> not just plain unary repeat
11:37:06 <b_jonas> I see
11:37:14 <DrSyzygy> We cannot typeclass associativity.
11:37:15 <b_jonas> well, it might make sense to have it, yes
11:37:36 <b_jonas> isn't it something related to monoids then?
11:37:44 <Peaker> DrSyzygy: Monoid expresses assocativity, not via the type-system but via the laws
11:38:08 <b_jonas> Endo monoids
11:38:11 <Peaker> DrSyzygy: you can have a type-class to express that via its docs/laws
11:38:57 <eu-prleu-peupeu> yoo Hppl
11:38:59 <eu-prleu-peupeu> chek it: http://www.todaysbigthing.com/2008/11/10
11:39:05 <Cale> b_jonas: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=472#a472
11:39:18 * sw17ch suggests the ban hammer
11:39:38 <vixey> sw17ch, what did I do wrong ??
11:39:59 <vixey> looks like knuth shuffle
11:40:09 <b_jonas> Cale: looks nice
11:40:29 * sw17ch wonders if todaysbigthing.com has to do with haskell
11:40:29 <b_jonas> I'm reading the docs of Control.Monad.Random to implement it myself
11:40:44 <Cale> Heh, it's funny that it's actually named after Knuth.
11:41:22 <Cale> I suppose he has enough non-obvious algorithms named after him to have a few obvious ones as well.
11:41:39 <DrSyzygy> Peaker: My point is that this particular implementation is to make sure we have efficient and obvious syntax for basic numeric stuff. There's nothing to prevent us from making a Monoid a => a -> Integer -> a function that'll iterate the monoid action, but it's silly to erect all that machinery behind making ^ work well.
11:41:52 <vixey> the argument that it is a perfect shuffle is nice
11:42:36 <Peaker> DrSyzygy: I'm not suggesting generalizing it to Monoid, just mentioning that type-classes can indeed specify associativity, by convention.  Also, I think we just need ^ = pow, and a powBy that takes a function with some properties to use
11:42:57 <Peaker> DrSyzygy: and a neutral element
11:43:13 <Peaker> DrSyzygy: and you could of course use: powBy mempty mappend, or 1 and (*)
11:43:24 <vixey> ahahaa
11:43:53 <b_jonas> Cale: wait
11:43:57 <b_jonas> Cale: that has the wrong type
11:43:59 <DrSyzygy> Or for that matter 0 and + getting a double-and-add multiplier
11:44:06 <Cale> b_jonas: oh?
11:44:16 <b_jonas> the shuffle function should return something without ST
11:44:26 <vixey> b_jonas, runST
11:44:29 <b_jonas> that's the whole point of ST: you can use it inside and eliminate it, right?
11:44:29 <Cale> b_jonas: you can runST it.
11:44:44 <Cale> After running the RandT.
11:45:05 <b_jonas> um
11:45:44 <b_jonas> how do I run it so I Get an ([a] -> Rand StdGen [a]) or perhaps an ([a] -> RandT StdGen (Identity [a])) ?
11:46:02 <b_jonas> as I'd like to sequence this with other random computations
11:46:11 <vixey> :t runST
11:46:13 <lambdabot> forall a. (forall s. ST s a) -> a
11:46:37 <b_jonas> liftM runST or something then I guess
11:46:46 <Cale> b_jonas: You'll have to write a Rand wrapper around the run for it.
11:46:50 <vixey> :t liftM runST
11:46:51 <lambdabot> forall a (m :: * -> *). (Monad m) => m (forall s. ST s a) -> m a
11:47:13 <RayNbow> http://blog.plover.com/lang/numeral-words.html <-- :D
11:47:17 <Cale> You absolutely must run the RandT before the ST computation.
11:47:27 <b_jonas> Cale: why?
11:47:42 <Cale> Because the RandT is computing what ST computation needs to be done.
11:48:33 <b_jonas> probably different sense of "before" then
11:49:24 <vixey> you can say  inside  too
11:49:54 <vixey> actually that might be more confusing
11:50:25 <Cale> You can use getRandom together with mkStdGen to get a generator to use to run the RandT.
11:50:28 <skorpan> hi. i have a question regarding fixed-point combinators... i read on wikipedia that they're relevant because they don't rely on recursion being implemented in the underlying programming language. why don't they? i can't quite see how they don't.
11:50:32 <Cale> and then run the ST
11:51:09 <Cale> skorpan: Uh, usually they're how you introduce recursion to a programming language, by providing a fixpoint combinator as primitive.
11:51:09 <vixey> skorpan, actually we can't do this in haskell because tho types get in the way
11:51:34 <b_jonas> vixey: I think you still can, only it needs a wrapper data so it's more complicated
11:51:46 <skorpan> "This operation is relevant in programming language theory because it allows the implementation of recursion in the form of a rewrite rule, without explicit support from the language's runtime engine."
11:52:02 <Cale> skorpan: But in the untyped lambda calculus, the existence of fixpoint combinators definable as lambda terms shows that there's no need to introduce further explicit recursion.
11:52:14 <vixey> skorpan, that makes no sense :p should probably erase that line
11:52:26 <skorpan> vixey: i agree, but then again, i'm quite the newbie
11:52:52 <vixey> skorpan, have you seen U? Ux = x x
11:53:07 <vixey> skorpan, UU ~~> UU ~~> UU, it reduces to itsself
11:53:10 <skorpan> no, but i know I, S and K (and *almost* Y)
11:53:32 <vixey> Y is actually very similar to U
11:53:43 <vixey> Y is basically like a packagade up all read to use version of U
11:53:50 <b_jonas> vixey: look at here as an example "http://www.math.bme.hu/~ambrus/pu/olvashato/t2n.sml": it's not exactly the fixpoint combinator only a weaker recursion combinator, but I define it without letrec, and I think you can define the fixpoint combinator
11:53:56 <vixey> (that is how to derive it by the way, if you want to o it from scratch)
11:54:33 <roconnor> @djinn (e->a,e->b) -> e -> (a,b)
11:54:34 <lambdabot> f (a, b) c = (a c, b c)
11:54:34 <skorpan> do you guys have any tips on papers regarding fixed-point combinators? preferrably not including lambda calculus basics.
11:54:39 <Cale> b_jonas: It's impossible to define a fixpoint combinator in the simply typed lambda calculus, or HM without recursive types.
11:54:45 <vixey> b_jonas, nice example,,
11:54:46 <b_jonas> only it's unreadable
11:54:52 <vixey> I can read it
11:54:55 <roconnor> @djinn (e -> (a,b)) -> (e->a,e->b)
11:54:55 <lambdabot> f a =
11:54:55 <lambdabot>     (\ b ->
11:54:55 <lambdabot>      case a b of
11:54:55 <lambdabot>      (c, _) -> c,
11:54:55 <lambdabot>      \ d ->
11:54:57 <lambdabot>      case a d of
11:54:59 <lambdabot>      (_, e) -> e)
11:55:06 <vixey> skorpan, what do you want to know about it/
11:55:14 <b_jonas> Cale: yeah, not _the_ fixpoint combinator, but you can define something that's isomorphic to it if you ignore boxing and unboxing functions to a data
11:55:17 <vixey> skorpan, To Mock a Mockingbird
11:55:21 <ddarius> Y = λf.(λx.f(x x))(λx.f(x x)), Yf = (λx.f(x x))(λx.f(x x)) = f((λx.f(x x))(λx.f(x x))) = f(Yf)
11:55:22 <skorpan> vixey: basically what they're good for and all of those SKIUY combinators
11:55:24 <b_jonas> Cale: oh, without recursive types
11:55:31 <b_jonas> Cale: yeah, you need recursive types
11:55:34 <vixey> skorpan, they aren't really useful ...
11:55:52 <vixey> skorpan, thy introduced types for lambda so that you cannot have these fixed points causing hell
11:55:57 <skorpan> i'm sure they must have some use? or at least it should in some way be useful to understand them.
11:56:15 <Cale> skorpan: Here's the best way to understand fix:  fix f = f (fix f)
11:56:19 <b_jonas> ddarius: yeah, and it's good to know that the first definition doesn't work in a strict language
11:56:24 <Cale> Or:  fix f = x where x = f x
11:56:33 <b_jonas> (though a variant of it does)
11:56:34 <Cale> (those are both valid Haskell definitions)
11:56:36 <skorpan> Cale: i've seen that example actually, but out of context, it doesn't help me very much
11:56:38 <vixey> b_jonas, oh you just put another lambda around it :)
11:56:53 <Cale> skorpan: Well, let's see how you might use it to implement a recursive function, like the factorial.
11:56:55 <skorpan> i think the haskell source is: fix f = let x = f x in x
11:56:57 <b_jonas> vixey: the hard part is around _what_
11:57:02 <roconnor> @src fix
11:57:02 <lambdabot> fix f = let x = f x in x
11:57:06 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 56
11:57:08 <lambdabot>   710998587804863451854045647463724949736497978881168458687447040000000000000
11:57:14 <roconnor> > fix bitSize
11:57:16 <lambdabot>   64
11:57:32 <Cale> skorpan: See how that works?
11:57:35 <vixey> b_jonas, f
11:57:40 <skorpan> Cale: let me think about that one for a while... thanks for your help, you too vixey!
11:58:12 <b_jonas> vixey: probably. I computed it at one point but I can't remember
11:58:27 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
11:58:33 <ddarius> skorpan: Can you program in Haskell at all?
11:58:48 <Cale> -> let x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x in x
11:58:56 <skorpan> ddarius: uh, yeah...?
11:59:15 <ddarius> skorpan: Then why do you want to avoid "lambda calculus basics"?
11:59:20 <Cale> -> let x = (\ n -> if n == 0 then 1 else n * x (n-1)) in x
11:59:26 <skorpan> ddarius: because i already know them
11:59:34 <Cale> skorpan: Does that bit of evaluation help?
11:59:44 <Cale> See how it turned into the definition of the factorial?
11:59:50 <Peaker> @type fix
11:59:51 <lambdabot> forall a. (a -> a) -> a
12:00:01 <skorpan> Cale: yes, thank you
12:00:17 <Peaker> is (a -> a) -> a  considered a recursive type?
12:00:26 <ddarius> Peaker: No.
12:00:35 <Peaker> then why is it impossible to define in the "simply-typed LC"?
12:00:45 <Beelsebob_> it's not
12:00:45 <Cale> Peaker: it's quite possible to define
12:00:46 <vixey> Peaker, because |
12:00:51 <vixey> it is not :/
12:00:55 <vixey> (a -> a) -> a
12:01:02 <Cale> Peaker: It's just not possible to define nontrivial terms of that type
12:01:06 <vixey> read it as (P -> P) -> P
12:01:28 <vixey> this type is uninhabited
12:01:34 <Peaker> Cale: what are "terms of a type"?
12:01:40 <Cale> Peaker: its elements
12:01:44 <b_jonas> Peaker: because you can't use recursive types like [], nor higher-rank polymorphism
12:01:46 <Cale> If you prefer
12:01:55 <vixey> ((x -> x) -> (x -> x)) -> (x -> x)  is
12:02:07 <Peaker> vixey: why is it uninhabited?
12:02:08 <vixey> so maybe should say,  forall a, (a -> a) ->a
12:02:24 <Peaker> that's what lambdabot said
12:02:53 <Peaker> Cale: what's triviality in this context?
12:02:54 <vixey> Peaker, it just isn't,.. if you beleve me for a sec that STLC is strongly normalizing, and it's clear that a term t :: (a -> a) -> a would break that
12:03:14 <Peaker> vixey: strongly-normalizing -> everything terminates?
12:03:14 <Cale> Peaker: Actually, vixey is right, it's completely uninhabited, since we don't have to worry about bottom.
12:03:16 <b_jonas> Peaker: in the example I linked to, I use a recursive type (data L a b = L (L a b, a) -> b) to define it
12:03:17 <vixey> Peaker, then that is by contradiction.. except the strong normalization proof is like.. not something I can just type out
12:03:49 <b_jonas> if I read the sml right
12:03:50 <Peaker> vixey: I didn't know STLC was strongly normalizing. Is that the same as saying its functions are all total? Or that STLC itself is total?
12:03:54 <Cale> Peaker: But you can get a sense for why it's uninhabited by trying to write a well-typed lambda term which is a value of that type.
12:03:54 <b_jonas> I've completely forgotten sml
12:04:00 <Cale> Peaker: Without using fix, of course.
12:04:09 <Cale> (or recursive types)
12:04:21 <vixey> Peaker, so there is that clever lexicographic induction on redex complexity by turing, induction on typing derivation, embedding in stronger logics, cut elimination of FOL by CH
12:04:23 <b_jonas> or higher-rank types
12:04:29 <ddarius> vixey: Every application reduces the number of arrows and there are only finitely many arrows.
12:04:32 <Cale> Peaker: Okay, so I hand you a function of type P -> P
12:04:35 <Peaker> is STLC Turing complete?
12:04:40 <Cale> Peaker: Please give me a value of type P.
12:04:44 <ddarius> Peaker: No.
12:04:50 <vixey> Peaker, if it is strongly normalizing it cannot be TC
12:05:02 <vixey> I think the class is 'polynomial functions' not sure what that is though
12:05:04 <b_jonas> Cale: I think it can be done that way
12:05:06 <Peaker> Cale: Can't I use the same trick as in fix?
12:05:18 <Cale> Peaker: It seems that in order to do that, you'll have to apply the function I gave you, right?
12:05:21 <b_jonas> Peaker: which definition of fix?
12:05:35 <Cale> Peaker: But in order to do that, remember this is the STLC, you need a value of type P.
12:05:41 <Cale> Which you don't have.
12:05:56 <Peaker> Cale: I don't know what STLC means exactly, its the first time I heard the term, I'm reverse engineering it ;-)
12:06:05 <Cale> ah, simply typed lambda calculus
12:06:16 <vixey> here are the rules of STLC
12:06:18 <vixey> :t ?m ?n
12:06:19 <lambdabot> forall t t1. (?n::t, ?m::t -> t1) => t1
12:06:19 <Peaker> Cale: yeah, the acronym I saw above
12:06:19 <Cale> lambda calculus with (->) types, and some basic types
12:06:22 <vixey> :t \x -> ?m
12:06:23 <lambdabot> forall t t1. (?m::t1) => t -> t1
12:06:35 <Peaker> b_jonas: for example: fix f = f (fix f)
12:06:44 <Cale> Peaker: and maybe algebraic types without recursion.
12:07:05 <ddarius> Cale: You could have inductive types.
12:07:06 <Peaker> oh, I see, if I want to recursively call fix, I need something like: rec f = f f
12:07:12 <Cale> Peaker: The usual definition of Y in untyped lambda calculus won't typecheck.
12:07:14 <b_jonas> Peaker: yes, but that's not written in lambda calculus
12:07:14 <Peaker> and for that I need recursive types
12:07:17 <b_jonas> Peaker: that definition that is
12:07:30 <b_jonas> Peaker: because it uses fix on the rhs in the equation where you define fix
12:07:35 <ddarius> Peaker: You only have lambda abstraction and application.
12:07:41 <Peaker> ddarius: I understand, yeah
12:07:41 <vixey> you have to be careful with inductive types if you want to .. do anything with them
12:07:49 <Peaker> and the Y combinator results in a recursive data-type?
12:07:50 <vixey> just having thees funny constants is ok though
12:08:03 <ddarius> Peaker: No.
12:08:09 <vixey> (do anything, like folds or pattern matching)
12:08:47 <Peaker> what do you call the function:  f g = g g ?
12:08:55 <Cale> Peaker: Being able to define recursive datatypes gives you a Y combinator.
12:09:09 <vixey> Peaker, I just deifned that above..
12:09:10 <Cale> Peaker: not a function, directly.
12:09:12 <vixey> Peaker, U
12:09:20 <ddarius> Peaker: It's not a data type.  It's just a function and one that isn't able to be defined in the STLC or even Haskell.
12:09:24 <Cale> (it won't typecheck in this system)
12:09:26 <Peaker> vixey: sorry, there were lots of messages in between
12:09:33 <vixey> :t \u -> u u
12:09:35 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
12:09:35 <lambdabot>     Probable cause: `u' is applied to too many arguments
12:09:35 <lambdabot>     In the expression: u u
12:09:35 <ddarius> s/defined/type checked
12:09:43 <Cale> ddarius: fix can be defined in Haskell ;)
12:09:52 <Peaker> so its not a recursive type, but worse
12:10:19 <ddarius> Peaker: It's not a type, it is a value.
12:10:19 <Cale> Oh, perhaps you were referring to f
12:10:23 <Cale> sorry :)
12:10:25 <Peaker> ddarius: I'm referring to t = t -> t1
12:10:41 <vixey> t = t -> t1 is recursive
12:10:41 <Cale> Peaker: That's an infinite type
12:10:42 <hackage> Uploaded to hackage: peano-inf 0.1
12:10:42 <hackage> Uploaded to hackage: MetaObject 0.0.5
12:10:58 <Cale> You can approximate it with a recursive one.
12:10:59 <Peaker> Cale: yeah, and untyped LC has no problem having it, so it can recurse freely
12:11:00 <ddarius> Specifically, t = t -> t1 is an equirecursive type.
12:11:02 <Cale> :t Rec
12:11:03 <lambdabot> Not in scope: data constructor `Rec'
12:11:05 <Cale> hmm
12:11:11 <ddarius> Peaker: Untyped lambda calculus has no types.
12:11:12 <vixey> :t Mu
12:11:12 <Cale> I wonder where my definitions went :)
12:11:13 <lambdabot> Not in scope: data constructor `Mu'
12:11:14 <vixey> :k Mu
12:11:15 <Cale> :t InR
12:11:16 <lambdabot> (* -> *) -> *
12:11:16 <lambdabot> forall a. (Rec a -> a) -> Rec a
12:11:18 <Cale> aha
12:11:21 <Cale> there it is :)
12:11:23 <Deewiant> ?index Identity
12:11:24 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
12:11:24 <Peaker> ddarius: yeah, my terminology is broken, sorry
12:11:33 <Peaker> ddarius: I meant untyped LC has no problem with implementing U
12:11:48 <ddarius> Peaker: Correct.
12:11:49 <Peaker> ddarius: so you can implement fix. But without U, and with simple types, you can't
12:11:56 <Cale> :t outR
12:11:57 <lambdabot> forall a. Rec a -> Rec a -> a
12:12:05 <Cale> :t let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y
12:12:06 <lambdabot> forall a. (a -> a) -> a
12:12:10 <Cale> hooray! :)
12:12:18 <vixey> Systems that you can't define fix are the interesting ones because the yhave logical interpretations
12:12:29 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 56
12:12:30 <lambdabot>   710998587804863451854045647463724949736497978881168458687447040000000000000
12:12:54 <Cale> So, there's the usual Y combinator, annotated a bit with recursive type wrappers and unwrappers
12:13:15 <Peaker> vixey: but without turing completeness, don't you need many extra facilities to make interesting programs writable?
12:13:27 <Cale> vixey: Well, I'd argue that even the ones with fix have logical interpretations, they're just inconsistent logics.
12:13:53 <b_jonas> oh, you mean _that_ logical interpretation
12:13:55 <b_jonas> not the other one
12:14:01 <Peaker> vixey: For example, Dependent-type languages that are not turing complete, but have powerful type systems that allow proving the totality of programs without losing some of the expressiveness a STLC would lose?
12:14:13 <Cale> b_jonas: other one?
12:14:38 <ddarius> Peaker: Dependently typed languages can be Turing complete.
12:14:51 <vixey> Cale, I'm not sure... I don't have any formal definition of logical interpretation
12:15:20 <Peaker> ddarius: yeah, but some aren't. And lack of turing completeness sounds catastrophic at least at first, unless there are very powerful facilities to prove totality?
12:15:23 <vixey> Cale, I'm not saying  Has a model  because I don't know enough model theory to be sure that is actually what I mean
12:16:01 <vixey> Peaker, Think about it from the other side... What programs do you want to write that you can't prove terminate or not?
12:16:01 <ksf> % cabal install hback
12:16:01 <ksf> Resolving dependencies...
12:16:01 <ksf> cabal: cannot configure hback-0.0.3. It requires cairo -any, glade -any, gtk
12:16:01 <ksf> -any and svgcairo -any
12:16:10 <ksf> where can i get those? and why ain't they on hackage?
12:16:18 <Deewiant> gtk2hs
12:16:22 <ddarius> vixey: User interactions, operating systems, web servers, ...
12:16:28 <Peaker> vixey: I'd love to prove that they all terminate, surely. The question is whether requiring that proof is not too limiting
12:16:36 <Deewiant> ksf: AFAIUI its build system is too complicated for cabal
12:16:39 <dcoutts> ksf: you need gtk2hs which doesn't build with cabal yet, still it's fairly easy to install ./configure && make etc
12:16:46 <vixey> ddarius, well.. If you have coinductive types writing an OS is easy :))
12:17:04 <ddarius> vixey: It doesn't terminate though, but I was just being an ass anyway.
12:17:13 <b_jonas> Cale: the other logical interpretation is where you show that Turing-complete computation is as strong as the class of first-order logic expressions over natural number arithmetic with multiplication restricted so that each foreach or exists bound variable has to be upper-bounded
12:17:19 <Deewiant> dcoutts, ksf: unless you're on Windows in which case it'll take about 12 hours to compile and you need to go through the hassle of installing GTK etc.
12:17:54 <dcoutts> Deewiant: na, on windows it's even easier since there are installers
12:17:56 <dcoutts> :-)
12:18:04 <jeffersonheard> Okay...  trawling the Graphics.UI.Gtk documentation and coming up empty.  How do I check the status of mouse buttons?
12:18:15 <ksf> emerge gtk2hs ftw.
12:18:17 <jeffersonheard> within the onMouseMotionNotify handler
12:18:26 <ksf> the only other thing it's pulling system-wide is haddock.
12:18:37 <b_jonas> Cale: so you can't for example write exists n (P(n)) but you can write exists n (n <= k and P(n)) where k is an expression without free variables
12:18:38 <Deewiant> dcoutts: installer didn't work for me and now I'm on 6.10 so I had to build from source anyway :-)
12:18:47 <b_jonas> Cale: but that one is totally irrelevant here
12:18:51 <Cale> vixey: Well, the usual axioms of intuitionist implicational logic are:  pure :: a -> (e -> a), and  ap :: (e -> (a -> b)) -> ((e -> a) -> (e -> b))
12:18:56 <dcoutts> Deewiant: well I'm glad it actually builds ok from source on windows :-)
12:19:03 <Cale> vixey: and of course, another name for those are K and S
12:19:05 <vixey> Peaker, I don't know what you mean, I feel limited by the inexpressiveness of simple types though
12:19:19 <Deewiant> dcoutts: modulo autoconf ;-)
12:19:27 <vixey> Cale, ok yeah
12:19:29 * dcoutts stabs autoconf
12:19:32 <Cale> vixey: There are a number of ways to extend those axioms with additional primitives.
12:19:53 <Peaker> vixey: if you don't have turing completeness with simple types, is there any way to demonstrate the scope of usefulness of the language? Things that can be done with it despite its limitations?
12:19:56 <Cale> callcc :: ((a -> b) -> a) -> a  gives you classical logic
12:20:10 <ksf> I'd like something like http://omake.metaprl.org/index.html , just slightly less impure.
12:20:15 <jeffersonheard> is there a gtk2hs channel?
12:20:21 <lambdabot> Title: The OMake build system
12:20:22 <Cale> (Peirce's law)
12:20:30 <|alexey_r|> Hm. I've got a program which works fine in GHCi, but when compiling with GHC I get error messages:
12:20:36 <|alexey_r|> C:\Users\Alexey\AppData\Local\Temp\/ghc4480_0/ghc4480_0.s: Assembler messages:
12:20:36 <|alexey_r|> C:\Users\Alexey\AppData\Local\Temp\/ghc4480_0/ghc4480_0.s:6622: Error: symbol `_
12:20:36 <|alexey_r|> FreshLibzm0zi2zi1_NominalBase_zdgfromName_closure' is already defined
12:20:37 <dcoutts> jeffersonheard: no, people typically use this one
12:20:40 <b_jonas> Cale: really?
12:20:41 <vixey> yes
12:20:46 <Cale> b_jonas: yep
12:20:58 <ddarius> Peaker: As a side note, the types keep you from writing a lambda term for fix.  You can always add fix in as a primitive (or rather you'd have to add fix_T for each type T).
12:21:02 <|alexey_r|> How can I find the reason?
12:21:11 <vixey> :t ap pure
12:21:12 <lambdabot> forall a a1. (a -> a1) -> a -> a
12:21:14 <Cale> |alexey_r|: Are you compiling with --make ?
12:21:16 <vixey> :t ap pure pure
12:21:17 <lambdabot>     Ambiguous type variable `f' in the constraint:
12:21:17 <lambdabot>       `Applicative f'
12:21:17 <lambdabot>         arising from a use of `pure' at <interactive>:1:8-11
12:21:18 <jeffersonheard> dcoutts: figured.  Do *you* know how to poll the mouse button states?  I just want to handle drag events in pseudo-realtime
12:21:19 <vixey> :t ap pure ap
12:21:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
12:21:25 <vixey> :t ap (ap pure)
12:21:26 <lambdabot> forall a a1. ((a -> a1) -> a) -> (a -> a1) -> a
12:21:30 <vixey> :t pure (ap pure)
12:21:31 <Peaker> ddarius: Or just allow referencing left-hand names on the rhs
12:21:31 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f ((a -> a1) -> a -> a)
12:21:37 <vixey> how do you get id from ap and pure?
12:21:43 <vixey> :t ap (pure pure)
12:21:44 <lambdabot> forall a (f :: * -> *) (m :: * -> *). (Monad m, Applicative m, Applicative f) => m a -> m (f a)
12:21:53 <vixey> :t pure (ap ap)
12:21:54 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Applicative f, Monad m) => f ((m (a -> b) -> m a) -> m (a -> b) -> m b)
12:22:01 <ksf> took me about 4 hours of learning omake and debugging impurities to generate a dependency tree from a top-level .c file to avoid having to give it a list of targets.
12:22:08 <b_jonas> Cale: but how does classical logic even map to this stuff if higher-rank polymorphic types aren't even allowed?
12:23:25 <Cale> :t ap (pure :: a -> (e -> a)) (pure :: a -> e -> a)
12:23:26 <lambdabot> forall a. a -> a
12:23:37 <|alexey_r|> Yes, both --make and "runghc Setup build" give the same mistakes
12:23:54 <Cale> b_jonas: I'm talking about propositional logic, not first order logic.
12:24:05 <b_jonas> oh, it makes more sense that way
12:24:11 <ddarius> Peaker: That's equivalent to adding fix.
12:24:23 <dcoutts> jeffersonheard: I think you need to react to the mouse button click and track the state until a release, in the mean time respond to the mouse move events
12:24:25 <vixey> :t fix (ap pure)
12:24:33 <vixey> oh
12:24:38 <Cale> adding fix gives you a way to prove any theorem, but it makes the proofs you can construct far more interesting ;)
12:24:41 <lambdabot> forall a. a -> a
12:24:43 <jeffersonheard> gotcha
12:24:44 <jeffersonheard> alright
12:24:45 <Peaker> ddarius: yeah
12:24:46 <ddarius> Peaker: Anyway, there aren't definitions in the STLC.
12:24:56 <dcoutts> jeffersonheard: polling if the user is holding down a mouse button doesn't sound like a reliable approach
12:24:57 <vixey> I don't think it makes the proofs more interesting
12:25:24 <Cale> vixey: Well, it gives you Turing completeness.
12:25:27 <vixey> I mean they are the only interesting thing left
12:25:30 <Cale> vixey: So in that sense.
12:25:43 <dcoutts> jeffersonheard: note the thing about drawWindowGetPointer so that you do not get flooded with mouse move events
12:25:58 <vixey> Cale, but it seems wrong to call it a proof to me :)
12:26:02 <ksf> there are other quirks with omake, like their authors not having realised yet that dynamic scoping is evil.
12:26:03 <Cale> vixey: There are way more arrows between any two types once you add fix into the picture.
12:26:06 <jeffersonheard> dcoutts: already have. Just polishing a few things before Thursday's demo
12:26:14 <Cale> vixey: Well... "more" :)
12:26:17 <dcoutts> jeffersonheard: cool, what are you demoing?
12:26:47 <Cale> vixey: It seems natural to identify proofs and programs to me.
12:27:10 <vixey> Cale, I think it is natural and very useful but only when you consider total programs
12:27:21 <Cale> Nah, even in the non-total case, it's fine.
12:27:45 <Cale> You can still apply most of your ability to prove theorems to writing programs.
12:27:57 <dons> ?users
12:27:58 <lambdabot> Maximum users seen in #haskell: 559, currently: 552 (98.7%), active: 21 (3.8%)
12:28:12 <Cale> You just have some extra primitives to learn to use, depending on what sort of recursion has been added.
12:28:17 <b_jonas> I think you can't even get a Rand g a from a RandT g (Identity a) because Rand doesn't have a method to modify the random state
12:28:22 <vixey> the only techniques I know for theorem proving end up with finite proofs :p
12:28:24 <b_jonas> shit
12:28:28 <jeffersonheard> dcoutts: Oh hell.  Hard to describe.  Same thing I've been working on for awhile.  It's a bit like real-time wide area teleconferencing, but for maps.  A map forms the basis for N virtual scratchpads that participants can add text/hypermedia annotations to
12:28:30 <Cale> b_jonas: You can make a new StdGen
12:28:48 <Cale> b_jonas: fmap mkStdGen getRandom
12:28:50 <dcoutts> jeffersonheard: interesting
12:29:13 <Cale> vixey: These are finite proofs too!
12:29:25 <jeffersonheard> dcoutts: The idea is to coordinate disaster managers on the ground with disaster management centers, and the centers with each other.  Everyone can annotate the map at once and see each others' annotations in near-realtime
12:29:26 <Cale> vixey: I've never written an infinitely long program ;)
12:29:31 <vixey> I'm calling things like
12:29:38 <vixey> f (1+x) = f x
12:29:41 <vixey> infinite
12:29:46 <ksf> Cale, you should loose your quine virginity.
12:29:47 <Cale> vixey: But that's not an infinite proof.
12:29:55 <Cale> ksf: A quine is not infinitely long.
12:30:05 <Cale> (not necessarily anyway)
12:30:07 <vixey> but you can always open up an 'f' on the right hand side
12:30:11 <b_jonas> Cale: no, that might give really wrong results depending on how the StdGen is implemented
12:30:13 <ksf> it is if you've got too much lisp in your head.
12:30:20 <Cale> b_jonas: how so?
12:30:21 <dcoutts> jeffersonheard: wow, sounds very "real world". Will we see screenshots? I think people would be interested.
12:30:21 <ddarius> Usually one restricts programs to be finite by definition...
12:30:22 <jeffersonheard> dcoutts: the whole thing is hypermedia enabled, so any kind of link or embedded image/video/app you can add to a webpage can be added instead into the image, and images can link between each other as well
12:30:32 <Cale> b_jonas: It gives you a new random StdGen
12:30:34 <jeffersonheard> There will be open source after SC08
12:30:37 <wchogg> I swear I should be banned from ever using tick marks in variable names.  I have created more bugs from leaving off a ' than anything else.
12:30:57 <dons> foo'n'bar :) perfectly cromulent.
12:30:58 <skorpan> @src unionWithKey
12:30:59 <lambdabot> Source not found. :(
12:31:00 <Cale> ksf: Lisp doesn't even allow infinitely long programs
12:31:05 <ddarius> dons: I hate that style.
12:31:05 <vixey> if your proof goes  fix (either a or ~a, so for the first case, ...)
12:31:28 <b_jonas> Cale: but the random numbers that new gen returns could depend a lot (or even be the same) as the numbers I get from the original generator after that
12:31:43 <jeffersonheard> dcoutts: I've got lots of interest on the real-world side, now.  They're itching for a deployment.  Got sidetracked for this demo, because they want a high-end version of the app that uses OpenGL and will run on our multitouch table
12:32:01 <jeffersonheard> gesture recognition, etc.  Very Tom Cruise
12:32:03 <ksf> Cale, oh yes it does. think of generating a list that generates a list that generates a list that generates a list that....
12:32:08 <dcoutts> jeffersonheard: cool
12:32:41 <Cale> ksf: The compiler won't accept an infinitely long source file.
12:32:45 <ksf> then add a thing that lazily prints it.
12:32:48 <b_jonas> Cale: in particular, if Int was as wide as StdGen, then StdGen could be implemented as storing the last generated number, and random would return that number and advance the state,
12:33:01 <ksf> that's why eval is less than 10 lines.
12:33:09 <b_jonas> Cale: then you'd get actually the same number sequence from randomming the inside and the outside generator
12:33:20 <dcoutts> jeffersonheard: you know the dev on the gtk2hs-devel list would be interested to hear your thoughts on what is good and bad in gtk2hs atm
12:33:33 <dcoutts> jeffersonheard: since you've been building something serious
12:33:36 <b_jonas> Cale: it's not likely that it happens this seriously because Int is just 32 bits and a sane random generator has more state than that
12:33:46 <b_jonas> Cale: but still something similar could happen
12:34:05 <Cale> b_jonas: I wonder where the operation I'd added for splitting the generator went.
12:34:09 <jeffersonheard> I get some kind of gtk2hs list, but I can't recall which one
12:34:14 <Cale> b_jonas: It seems someone removed it from the library.
12:34:14 <b_jonas> Cale: you don't even need split
12:34:19 <Cale> b_jonas: But I could add one.
12:34:20 <jeffersonheard> I'll post a note to it next week on what I've found so far
12:34:33 <b_jonas> Cale: for this you just need a modify
12:34:37 <dcoutts> jeffersonheard: either the user or devel list would be fine, doesn't matter
12:34:42 <b_jonas> Cale: which reads the random generator and writes it
12:34:48 <vixey> I don't know
12:34:54 <Cale> b_jonas: you want something which does a split under the covers, and gives you the new generator, while threading the other along.
12:34:57 <vixey> I don't feel right calling it a proof if it is just a program
12:35:06 <jeffersonheard> dcoutts: main thing that I could complain about offhand is not being able to get a Ptr Word8 from a Gdk.Pixbuf so I can load directly to texture without passing through Haskell
12:35:13 <Cale> vixey: It's a proof in a peculiar logic.
12:35:23 <b_jonas> Cale: though maybe it's on purpose that they don't want to allow that, for maybe Rand would want to have the semantics that the actions can't mess up the random numbers to be less random
12:35:24 <Cale> vixey: It's also an arrow in an appropriate category.
12:35:29 <vixey> that logic is inconsistent matters to me
12:35:32 <vixey> I don't know why :/
12:35:39 <b_jonas> Cale: and a modify would allow that
12:35:39 <Cale> vixey: It doesn't matter so much to me.
12:35:44 <jeffersonheard> rather, going through the Haskell heap
12:35:45 <vixey> It doesn't fit with my notion of proof
12:35:46 <b_jonas> Cale: so maybe this is on purpose
12:35:48 <Cale> vixey: After all, these proofs are useful.
12:36:24 <Cale> b_jonas: I'll fix the library in a moment ;)
12:36:35 <Cale> vixey: I think I know what you're caught on :)
12:36:41 <b_jonas> Cale: just make sure you've read what I said for maybe it's on purpose
12:37:04 <Cale> b_jonas: My operation would be safe :)
12:37:12 <b_jonas> splitting would be, yes
12:37:16 <Cale> yeah
12:37:23 <Cale> Which is all you really want.
12:37:36 <mbeddoe> anyone else had compilation issues with 6.10 specifically with Maybe monad?
12:37:53 <mbeddoe> i have some old code that's borked now
12:38:07 <Cale> vixey: Do you know the sense in which statements in a logic form a category?
12:38:24 <b_jonas> well, it has the disadvantage that there are few established good implementations of Random with split, whereas there are established good ones of Random with random but without split
12:38:25 <Saizan> mbeddoe: maybe it's because of changes in Data.Map ?
12:38:26 <vixey> Cale, Yeah I think so... the arrows are equiv. classes of proofs?
12:38:27 <Cale> vixey: Where we have an arrow A -> B if A |- B in the logic?
12:38:30 <Cale> yeah
12:38:40 <skorpan> why is there no source code on hoogle anymore?
12:38:43 <mbeddoe> Saizan: yup! it's in Data.Map
12:38:49 <mbeddoe> is there docs online to fix?
12:38:53 <Cale> We're used to working in this category where there's at most one arrow between any two statements in mathematics.
12:39:07 <Cale> and we don't worry about what that arrow *is*
12:39:19 <vixey> Proof irrelevance :)
12:39:24 <Cale> right
12:39:27 <skorpan> proof by irrelevance!
12:39:38 <mbeddoe> oh
12:39:39 <mbeddoe> nm
12:39:46 <mbeddoe> i didn't realize they changed it completely
12:40:05 <Cale> But you can also define a category where there's an arrow A -> B for every proof of A |- B
12:41:01 <Cale> and composition is just defined by composing proofs in an appropriate way (though you have to be careful about associativity)
12:41:20 <vixey> careful in what respect?
12:41:44 <Cale> Well, you want (f . g) . h = f . (g . h), so you need to be careful about exactly how you identify those
12:41:59 <Cale> Or do something to ensure that they're the same proof.
12:42:12 <vixey> I don't see why
12:42:18 <ksf> does hback's glade dependency reference glade itself or libglade?
12:42:20 <Cale> If you want this to be a category.
12:42:28 <ksf> i'm a bit confused as i bet that glade can't generate haskell.
12:42:59 <ksf> ...and gentoo offers no haskell-specific glade package, neither does hackage.
12:43:07 <vixey> (.) is just modus ponens though
12:43:18 <Cale> ksf: You can use glade to generate user interfaces which you then load with stuff in Gtk2Hs.
12:43:27 <vixey> it's total (as long as the types match up) isn't it?
12:45:12 <vixey> hm I think what I said is not true
12:45:54 <Cale> Well, you could say that (in the "proof as list of statements" view) that f . g is something which looks somewhat like f ++ g ++ [apply modus ponens]
12:45:56 <Peaker> what's the difference between "assocs" and "toList" in a Data.Map?
12:46:08 <Peaker> @type Data.Map.assocs
12:46:10 <lambdabot> forall k a. M.Map k a -> [(k, a)]
12:46:14 <Peaker> @type Data.Map.toList
12:46:15 <lambdabot> forall k a. M.Map k a -> [(k, a)]
12:46:56 <Cale> vixey: But that's going to end up failing associativity for a stupid reason.
12:47:19 <Cale> vixey: (the application of modus ponens moves around)
12:48:05 <Cale> So you have to be careful to identify your proofs just enough with an equivalence that this doesn't matter, or else define them in a structural way which gets around the problem.
12:49:36 <Cale> b_jonas: Aha, I think I see why they removed that operation, but I think it's worth adding back anyway
12:49:48 <Cale> b_jonas: It makes the MonadRandom typeclass a little more complicated.
12:51:09 <b_jonas> yeah, you can't implement it because neither the MonadRandom typeclass nor Rand exports anything that would allow you to split the random seed
12:51:58 <Cale> b_jonas: But moreover, in order to define it, you need to parametrise the MonadRandom class with the generator type
12:52:10 <Peaker> conal: I wrote a tiny/ugly IO text-mode menu that lets you select the demo interactively instead of recompiling every time, is that interesting?
12:52:18 <Cale> b_jonas: So I think rather than doing that and breaking any existing code which uses MonadRandom, I'll add a new class.
12:52:22 <Peaker> conal: (to contribute to Test.hs, that is)
12:52:25 <Cale> MonadSplit
12:53:23 <b_jonas> Cale: oh, I see
13:01:14 <conal> Peaker: please send it to me, and i'll take a look.  do you not use ghci?
13:03:13 <roconnor> > (1+1/4)/(1-(1/4))::Rational
13:03:15 <lambdabot>   5%3
13:04:04 <Cale> b_jonas: okay, new version is up
13:04:08 <Cale> shuffle xs = do g <- getSplit
13:04:08 <Cale>                 return (runST (evalRandT (shuffle' xs) g))
13:04:23 <conal> fmap!
13:04:24 <Cale> b_jonas: and that code is what you want, in terms of the old shuffle'
13:04:29 <b_jonas> Cale: great
13:04:38 <Cale> yeah, fmap would be good there :)
13:06:06 <b_jonas> btw, why does runState and runStateT return a pair with the state second? wouldn't it make more sense to have the state first?
13:06:48 <Cale> Yes, it would.
13:07:03 <b_jonas> so it's for historical reasons then
13:07:06 <Cale> It does that because the mtl was not very well thought out.
13:07:17 <Cale> We really should have a new monad library.
13:07:25 <b_jonas> heh
13:07:32 <ddarius> Why does it make any difference what compenent the state is in?
13:07:40 <Cale> ddarius: (,) s is a functor
13:07:46 <b_jonas> ddarius: the Functor instance of (,), yeah
13:08:04 <ddarius> (,) a is a functor too
13:08:31 <conal> and Applicative when a is in Monoid
13:08:52 <Cale> Yes, it just doesn't line up with the parameter of the functor you're defining.
13:09:20 <ddarius> I believe the choice to have it be (a,s) is to emphasize the actual return value.
13:10:13 <Cale> But that *de-emphasises* the actual return value, by making the state be the thing which the functor instance is going to affect.
13:10:40 <Peaker> conal: I don't use ghci much, but maybe for no good reason
13:10:42 <hackage> Uploaded to hackage: MonadRandom 0.1.2
13:10:42 <hackage> Uploaded to hackage: uri-template 0.2
13:10:50 <b_jonas> though I don't really understand some of these extra classes yet (Functor, Applicative, Foldable, Traversable, Arrow)
13:11:01 <Cale> Functor is easy of course.
13:11:23 <Cale> Applicative is basically what you get when you remove (>>=) from Monad, but leave ap
13:11:24 <b_jonas> I understand the interface of a functor but I don't really understand why it's useful
13:11:43 <b_jonas> that is, what functors share
13:11:57 <Cale> b_jonas: It's useful because it characterises the data structures to which you can apply a function to all the elements.
13:12:16 <Cale> (or to the result value, in the case that you prefer the computation view)
13:12:29 <b_jonas> well, I don't really want to digest all these now so don't tell
13:12:33 <b_jonas> perhaps later
13:12:34 <Cale> okay
13:12:38 <b_jonas> there are so many of them
13:13:13 <Cale> Well, you know about combinator libraries (not in the technical sense of combinator, but the somewhat less technical one)
13:13:36 <ddarius> "somewhat less technical" = completely untechnical
13:13:43 <Cale> hehe
13:13:50 <b_jonas> lol
13:14:04 <Cale> Basically, they're libraries where you have some primitive computations, and some ways to combine those together into larger ones.
13:14:13 <b_jonas> yes
13:14:19 <b_jonas> a nice example is parsec
13:14:58 <Cale> Those classes (Functor, Monad, Applicative, Arrow, Comonad, and some others) characterise different kinds of combinator libraries -- ones where you have some particular means of combination that behaves in a standard way.
13:15:24 <Cale> Perhaps I should even include Monoid in that.
13:15:51 <Peaker> I explained Haskell basics to 3 of my friends, and I cover Functor, Applicative, Monad.   I think they form a nice hierarchy of their own together..
13:16:05 <Cale> and because you have such a means of combination, you get a bunch of library functions for free
13:16:12 <vixey> @instances Applicative
13:16:13 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
13:16:14 <Peaker> and because I want to explain FRP, and those are essential for it
13:16:17 <sbahra> Cale, Any good lecture slides on Haskell?
13:16:29 <Cale> sbahra: Like, general intro stuff?
13:16:39 <sbahra> Cale, yes
13:16:46 <sbahra> Cale, for CS undergraduates.
13:16:50 <Cale> sbahra: You might have a look at SPJ's slides.
13:16:55 <ksf> grrrr.... now I have to recompile gtk2hs as the glade use flag wasn't activated.
13:16:56 <Cale> For his intro.
13:17:52 <Cale> sbahra: If you want, I can find it...
13:18:14 <Cale> http://conferences.oreillynet.com/presentations/os2007/os_peytonjones.pdf
13:18:16 <Cale> http://www.haskell.org/haskellwiki/Video_presentations
13:18:29 <b_jonas> what's FRP?
13:18:38 <Cale> Functional reactive programming
13:18:39 <thoughtpolice> functional reactive programming
13:18:41 <lambdabot> Title: Video presentations - HaskellWiki
13:19:13 <Cale> b_jonas: Basically, a way of declaratively specifying the way that values are affected by inputs.
13:19:14 <sbahra> Cale, thanks, downloading
13:20:05 <Cale> b_jonas: Well, not just one way, but a whole bunch of libraries and research into how to do this.
13:23:41 <maltem> @users
13:23:42 <lambdabot> Maximum users seen in #haskell: 559, currently: 555 (99.3%), active: 19 (3.4%)
13:23:46 <sbahra> Cale, thanks
13:24:23 <maltem> At uni we're currently doing static Java programming (that is, Java code with static methods only). I'm really missing my state monad
13:24:41 <Cale> b_jonas: A common theme is that you have Behaviours, which are essentially functions of time, that is, you have a value associated to every time, and Events, which are effectively streams of (time,value) pairs, values which "happen" at a particular time.
13:25:34 <vixey> maltem: Is there any theory behind it? what's the point of doing everything static
13:25:35 <Peaker> conal: sent. the lplace is not trying to be accurate about the (x,y) right? Its not doing the perspective adjustment based on the current depth
13:25:56 <Cale> b_jonas: you might have a look at http://conal.net/papers/simply-reactive/
13:26:12 <maltem> vixey: not having introduced classes in the lectures yet :(
13:26:51 <roconnor> TeXmacs gives a distrubing number of what I believe are runtime type errors.
13:26:57 <xinming_> hmm, Ever heard ghc will going to switch to git, And I found http://darcs.haskell.org/ghc.git is refered to sample repository in an post, So, Is there an official git repository for ghc?
13:27:00 <roconnor> <unnamed port>: In procedure scm-error in expression (scm-error (quote misc-error) #f ...):
13:27:01 <roconnor> <unnamed port>: no code for module (math)
13:27:33 <vixey> maltem, so there is absolutely no theory, they are just telling you to program in this subset because they didn't teach the rest yet?
13:28:04 <conal> Peaker: right.  there's currently nothing at all sensible going on in relating window position to 3D space.
13:28:24 <maltem> vixey, that's right
13:28:45 <vixey> maltem, it's so embarrassing what universities are doing wrt. teaching computing :/ ... they should be ashamed
13:29:20 <pozic> vixey: what makes you conclude there is no theory after the programming course is done?
13:29:38 <maltem> vixey: actually it's understandable... they're teaching procedural programming first. it's just a little painful
13:29:40 <pozic> vixey: probably some kind of memory model for Java was explained too.
13:29:47 <Peaker> conal: it seems like the scaling slowness you mentioned explains all the weird slowness and it seems to have spontaniously disappeared (perhaps after a reboot, maybe OS issue), except one last weirdness -- a significant delay in lplace remains
13:29:58 <vixey> maltem, there is no reason it should be painful at all
13:30:02 <roconnor> Cale: I thought we did have a new monad library?
13:30:14 <Peaker> conal: (the problematic Z-translation was used in LPlaces as well as the motion example)
13:30:19 <Cale> roconnor: Well, there are some other contenders...
13:30:27 <Peaker> s/motion/spin
13:30:29 <ddarius> vixey: If there is no pain then objects can't come to the rescue!
13:30:53 <vixey> ddarius, oooh.. so it's a brain washing thing
13:31:38 <Apocalisp> but... objects are cool!
13:31:47 <Apocalisp> They're all... oriented. And stuff.
13:32:00 <ksf> objects are just structs on steroids.
13:32:10 <maltem> vixey, actually it makes me program the little exercises in quite a functional style. The only thing that disturbs me are the long parameter lists, I'm guessing this isn't how I should do it in Java...
13:32:26 <ksf> the only sensible thing added in OOP is inheritance, and that's overused.
13:32:31 <maltem> ("should" in the moral sense)
13:32:35 <ksf> cross-object recursion is much cleaner.
13:32:48 <Apocalisp> @go functionaljava
13:33:04 <lambdabot> Plugin `search' failed with: thread killed
13:33:05 <ksf> like a nil object, a couple of node objects and a list object to wrap it all up.
13:33:11 <vixey> maltem, I am very disappointed at what I have seen people doing in teaching computing
13:33:11 <Apocalisp> @bot ?
13:33:11 <lambdabot> :)
13:33:30 <vixey> maltem, so I am now just looking for the worst in it all
13:34:01 <maltem> vixey, yeah I can understand that
13:34:24 <Apocalisp> maltem, http://functionaljava.org has a library that enables a more functional style in the Java language, if you're stuck with it.
13:34:53 <whampyre> screw java
13:34:54 <vixey> http://functionaljava.org is another thing I hate
13:34:56 <vixey> :)
13:35:10 <vixey> It is so dumb, write a compiler for goodness sake
13:35:24 <ksf> I once investigated the possibility of adding closures to java _without_ using objects (for memory efficiency reasons on mobiles), and i was not amused.
13:35:28 <Apocalisp> vixey, that project is at http://scala-lang.org
13:35:51 <maltem> Apocalisp: hmm interesting. Even though not the point of my exercises ;)
13:35:52 <ksf> can't even build a decent trampoline in assembly because of the verifier.
13:37:16 <ksf> arguably, there are no java compilers but only source-to-source translators.
13:37:46 <vixey> ksf, There is a difference between a compiler and a source-to-source traslator?
13:38:05 <linkinpork> hello guys
13:38:44 <ksf> not from java to java bytecode, no.
13:39:02 <ksf> Declaration for TreeSelectionClass:
13:39:03 <ksf>   Bad interface file: ./glib/System/Glib/Types.hi
13:39:03 <ksf>       magic number mismatch: old/corrupt interface file
13:39:06 <ksf> oh the joy.
13:39:15 * vixey confused
13:39:15 <vixey> hi
13:39:47 <ksf> it's like compiling lisp to lisp instead of lisp to malbolge.
13:40:57 <linkinpork> just a small question
13:41:08 <ksf> @faq
13:41:09 <lambdabot> The answer is: Yes! Haskell can do that.
13:41:23 <linkinpork> how do you deal with errors in haskell
13:41:41 <vixey> linkinpork, errors? :)
13:41:49 <linkinpork> I'm quite a defensive guy
13:41:51 <ksf> :t Maybe
13:41:53 <lambdabot> Not in scope: data constructor `Maybe'
13:41:53 <ksf> :t Error
13:41:55 <Lemmih> linkinpork: We have several support groups.
13:41:55 <lambdabot> Not in scope: data constructor `Error'
13:41:57 <ksf> graaaaaagh
13:42:01 <vixey> linkinpork, I've not heard of these in a looong time :)
13:42:09 <ksf> :t Data.Maybe.Maybe
13:42:10 <lambdabot>     Not in scope: data constructor `Data.Maybe.Maybe'
13:42:13 <Beelsebob_> linkinpork: you use the Either String a type
13:42:13 <ksf> :t Data.Maybe
13:42:14 <lambdabot> Couldn't find qualified module.
13:42:20 <Beelsebob_> (Either an error message, or a result)
13:42:21 * ksf gives up
13:42:25 <vixey> linkinpork, so like throw/catching expections, malformed data, what sotr of stuf do you mean?
13:42:30 <ddarius> ksf: Maybe is a type constructor.  It doesn't have a type.
13:42:33 <ddarius> :k Maybe
13:42:34 <linkinpork> yeah, kinda like that
13:42:34 <lambdabot> * -> *
13:42:37 <linkinpork> I have a class that teaches haskell's functions
13:42:42 <ksf> :t Just "not an error"
13:42:44 <lambdabot> Maybe [Char]
13:42:45 <dblazakis> :t Just True
13:42:45 <lambdabot> Maybe Bool
13:43:07 <vixey> linkinpork, there are haskell approaches to all this stuff.. I wonder what is a good tutorial that covers it.
13:43:09 <linkinpork> so, the teacher asked for a function to make something, receiving [String], Int and Char
13:43:18 <linkinpork> my beef is
13:43:28 <ksf> @src MonadError
13:43:29 <lambdabot> class (Monad m) => MonadError e m | m -> e where
13:43:29 <lambdabot>     throwError :: e -> m a
13:43:29 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
13:43:43 <linkinpork> what is Int is Negative and Char if different than n,m,o,something?
13:43:56 <linkinpork> I'm not that advanced
13:43:58 <linkinpork> lol
13:44:04 <vixey> linkinpork, well you can do,
13:44:07 <linkinpork> don't know what a monad is
13:44:31 <vixey> foo i c | i < 0 || not (c `member` "nmo")  = error "invalid input"
13:44:38 <vixey> foo i c = __ the actual code __
13:44:47 <vixey> but, this is like.. my least favorite way
13:44:50 <ddarius> notElem
13:44:52 <vixey> a nicer one is
13:45:06 <vixey> actually no that works doesn't it
13:45:06 <ksf> :t (\x::[String], y::Int, z::Char -> id)
13:45:08 <lambdabot> parse error on input `,'
13:45:10 <roconnor> > 'a' `notElem` "nmo"
13:45:11 <lambdabot>   True
13:45:15 <roconnor> > 'm' `notElem` "nmo"
13:45:17 <lambdabot>   False
13:45:18 <ksf> :t (\x::[String] y::Int z::Char -> id)
13:45:19 <lambdabot> parse error on input `y'
13:45:29 <djsiegel1> Is there any way I can get a stacktrace or line number on a "Prelude.tail: empty list" error?
13:45:34 <ksf> :t (\(x::[String]) (y::Int) (z::Char) -> id)
13:45:35 <lambdabot> forall a. [String] -> Int -> Char -> a -> a
13:45:51 <ksf> linkinpork, there you got it.
13:46:01 <linkinpork> thanks ksf,vixey
13:46:10 <linkinpork> will try do something like that
13:46:15 <linkinpork> the room makes me dizzy
13:46:28 <vixey> :D
13:46:41 <vixey> @remember <linkenpork> the room makes me dizzy
13:46:41 <lambdabot> Okay.
13:46:53 <ksf> @remember ksf Confusion is the first step to enlightenment
13:46:54 <lambdabot> Nice!
13:47:02 <ksf> @botsnack
13:47:02 <lambdabot> :)
13:47:14 <ksf> It's developing intelligence!
13:48:02 <b_jonas> eek
13:48:15 <b_jonas> I keep changing the code and I'm getting crazier and crazier type error messages
13:48:57 <_pizza_> work backwards
13:49:33 <ddarius> b_jonas: Give the type you expect to each top-level declaration and maybe more locally if need be.
13:49:38 <b_jonas> I think my problem is that I don't really understand rank-n-types and they're requiers for ST
13:49:59 <b_jonas> ddarius: yeah, that's what I'm trying but where ST is involved I'm not sure where to put the foreaches
13:50:53 <Cale> b_jonas: Well, the important thing to notice with regard to runST is that its type looks like:
13:51:07 <Cale> runST :: forall a. (forall s. ST s a) -> a
13:51:27 <Cale> Note that 's' is not in scope where a is bound.
13:51:39 <Cale> So a cannot depend on s.
13:52:12 <Cale> There are also some strange interactions with runST and (.) and ($). Basically, you shouldn't have (.) or ($) next to runST in your code ;)
13:52:25 <dons> Cale: did you have a think about Chad's problem unsafeFreezing each IOUArray in an IntMap?
13:52:26 <b_jonas> now that might be the problem
13:52:36 <vixey> Cale, did you see the FPH stuff that can remedy that?
13:52:38 <Cale> dons: nope... I didn't see that one
13:52:39 <b_jonas> I did try to use (runST .)
13:52:43 <Cale> vixey: yeah
13:52:59 <vixey> I want it in GHC
13:53:08 <dons> Cale: chad's using haskell for some research and needs to get from IntMap IOUArray to IntMap UArray.
13:53:15 <b_jonas> that's becasue of the type derivation doesn't work well with high-rank types, right?
13:53:19 <b_jonas> but what cna I replace it instead?
13:53:20 <dons> he's having trouble working out how to unsafeFreeze each element of the map.
13:53:27 <Cale> b_jonas: runST (...)
13:54:51 <Cale> dons: Sounds like a job for Data.Traversable, but IntMap isn't an instance...
13:55:18 <b_jonas> oh
13:55:25 <b_jonas> a page long error message now
13:55:28 <b_jonas> longer than ever
13:55:28 <Cale> dons: Data.Map is though
13:57:05 <ddarius> b_jonas: It's because Haskell's type system is predicative.
13:57:51 <dons> Cale: not just fmap?
13:58:39 <Cale> dons: hmm
13:59:07 <ddarius> :t unsafeFreeze
13:59:08 <lambdabot> Not in scope: `unsafeFreeze'
13:59:14 <roconnor> Cale: is R -> R[X] a _natural_ monomorphism?
13:59:18 <dons> :t Data.Array.MArray.unsafeFreeze
13:59:19 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *) (b :: * -> * -> *). (Data.Array.Base.IArray b e, Data.Array.Base.MArray a e m, Ix i) => a i e -> m (b i e)
13:59:22 <Cale> I don't really know IOUArrays very well, but isn't freezing in the IO monad?
13:59:23 <dons> mm. kindy.
13:59:45 <Cale> roconnor: I would say yes.
13:59:54 <dons> Cale: hmm,yes. so sequence for IntMaps
13:59:59 <roconnor> good, it's goin into my thesis.
14:00:19 <b_jonas> better now
14:00:27 <b_jonas> it compiles but gets in an infinite loop
14:00:32 <Cale> roconnor: You can check this... the functors in question are the identity functor, and the one which sends a ring to the polynomial ring.
14:02:53 <Cale> So the naturality square has two rings R and S, and their polynomial rings R[X] and S[X]
14:03:47 <Cale> an arbitrary morphism R -> S, and the lifted morphism R[X] -> S[X] which just applies the hom to each of the coefficients
14:04:17 <roconnor> ah right
14:04:19 <Cale> and then down the sides, you have your natural map
14:04:29 <Cale> and it's easy to see that things will end up in the right place :)
14:06:08 <b_jonas> I'm way overcomplicating this
14:06:17 <ddarius> b_jonas: Probably.
14:07:03 <b_jonas> I currently have this: http://erxz.com/pb/13426
14:10:05 <vixey> that IS complicated..
14:10:19 <b_jonas> yeah
14:10:38 <vixey> what is goin on here
14:10:40 <vixey> a?
14:11:05 <b_jonas> vixey: evalRandomStateIO (shuffleFromState "") should shuffle the empty list
14:11:10 <b_jonas> but it goes to an infinite loop
14:11:15 <b_jonas> same for longer lists
14:11:59 <b_jonas> it should do the same as Cale's shuffle  http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=472#a473
14:15:06 <b_jonas> hmm, you know what's strange?
14:15:07 <b_jonas> this works:
14:15:12 <b_jonas> runST (runRandomStateT (shuffleFromState1 "abc") (mkStdGen 0))
14:15:43 <b_jonas> so the problem might be nor in shuffleFromState1 but in shuffleFromState
14:16:46 <b_jonas> but shuffleFromState does almost the same as this
14:16:56 <b_jonas> then the problem must be in withRandomStaet
14:17:15 <b_jonas> oh yeah, it is
14:17:22 <lambdapants> hello. having a little problem with hscurses, has it become broken recently?  I get undefined reference to `hs_curses_color_pair' with ghc 6.8.2.  it worked before, but that was with a 32 bit system, and now I'm on 64.  anyone had this problem?
14:17:29 <b_jonas> withRandomState c = withRandomState c
14:17:32 <b_jonas> that's the infinite loop
14:18:53 <b_jonas> if I change that line to
14:19:00 <b_jonas> withRandomState c = withRandomStateT (Identity . c);
14:19:03 <b_jonas> then it works
14:20:25 <b_jonas> and if you try this in ghci:
14:20:26 <b_jonas> evalRandomStateIO (sequence (replicate 10 (shuffleFromState "abc")))
14:20:36 <b_jonas> it shows that it's correct
14:21:36 <b_jonas> liftM (map length . group . sort) (evalRandomStateIO (sequence (replicate 1000 (shuffleFromState "abc")))) -- shows how it seems a fair shuffle
14:32:50 <jeffersonheard> is mallocBytes thread-safe?
14:32:57 <jeffersonheard> can I use it in a forkIO?
14:34:00 <roconnor> I need some mathematical notation for clamp x a b where clamp x l u = min (max x l) u.
14:36:09 <Peaker> who came up with the LC way to define PRED? Its pretty ingenius, IMO :)
14:37:06 * roconnor has [x]^{\wedge a}_{\vee b} at the moment
14:37:33 <vixey> I'd probalby wrcite it like
14:37:37 <vixey> a
14:37:38 <vixey> -
14:37:39 <vixey> x
14:37:40 <vixey> -
14:37:41 <vixey> b
14:37:47 <vixey> with the a and b small
14:37:50 <vixey> but I just made that up
14:38:10 <vixey> never sseen a notation for that
14:38:36 <vixey> oops swap the a and b
14:38:43 <conal> any emacs+linux users here?  i'm having a weird emacs/ghci interaction since switching to linux (ubuntu)
14:38:54 <roconnor> vixey: hmm
14:38:57 <bos> conal: what's the problem?
14:38:57 <roconnor> not bad
14:39:23 <Saizan> conal: switched to an editline ghci?
14:39:30 <conal> ghci echoes all of my input, when run via haskell-mode or via "M-x shell".
14:39:44 <conal> what's an "editline ghci"?
14:39:56 <conal> (asking hopefullly)
14:40:06 <Saizan> since 6.10 ghci is built with editline instead of readline
14:40:53 <conal> Saizan: hey, that might be it.  what can i do?
14:41:01 <bos> conal: which version of ghc?
14:41:04 <Saizan> and in haskell-mode i get the escape sequences echoed out e.g. ^J, so things like C-u C-c C-t don't work
14:41:09 <conal> bos: 6.10.1
14:41:23 <bos> conal: i've had weird problems with 6.10.1 too
14:41:25 <conal> Saizan: same here!
14:41:29 <bos> conal: did you build it yourself?
14:41:33 <conal> bos: yes
14:41:50 <conal> and i don't mind tweaking & recompililng.
14:41:55 <bos> conal: you may have an insufficiently new version of the editline library installed
14:41:56 <conal> (i love haskell-on-linux!)
14:42:12 <Pseudonym> I just clicked a .exe and everything Just Worked.
14:42:21 <bos> conal: if you go into ghc/libraries/editline and run "runghc Setup configure", see if it finds a compatible version of editline
14:42:25 <Peaker> conal: I don't know how you managed to use Windows for all these years and still enjoy using a computer ;)
14:43:07 <Peaker> I'm on the verge of ritually burning my Ubuntu machine sometimes, and Windows is far worse
14:43:15 <Pseudonym> BTW, if you think Windows is bad, try bioinformatics.
14:43:35 <Pseudonym> The Intelligent Designer is the software analyst's worst nightmare.
14:43:55 <Pseudonym> He's a fan of undocumented calls, self-modifying code and every hack you were ever taught not to use.
14:43:58 <Saizan> bos: so you've a ghci that works correctly in haskell-mode?
14:44:02 <Peaker> Pseudonym: heh :-)
14:44:09 <conal> Peaker: neither do i, now!
14:44:11 <im_maciek> what is the best book to learn haskell?
14:44:11 <bos> Saizan: after some careful fiddling, yes
14:44:24 <bos> @where rwh
14:44:24 <lambdabot> is http://www.realworldhaskell.org/blog/
14:44:31 <bos> im_maciek: ^^^
14:44:37 <Peaker> Pseudonym: I'd assume some hacks would be less evolutionary advantageous than "good code".  For example, genetic DRY principle would allow for more adaptiveness
14:44:46 <Pseudonym> Peaker: No.
14:44:55 <Pseudonym> THey're not advantageous, they're opportunistic.
14:45:09 <Pseudonym> We just happened to have this bit pattern lying around, so let's reuse it for something else.
14:45:19 <conal> bos: i get "checking editline/readline.h usability... no", etc.
14:45:27 <bos> Pseudonym: what kind of bioinformatics are you doing?
14:45:31 <sbahra> Peaker, should try FreeBSD :-P
14:45:35 <im_maciek> what? that's a serious question :P
14:45:35 <Pseudonym> bos: I'll tell you on Monday week.
14:45:42 <bos> conal: that's your problem
14:45:45 <Pseudonym> At the moment, my directive is to "cram".
14:46:07 <conal> bos: awesome!  is the solution to install libedit-dev?
14:46:22 <bos> conal: if ubuntu's version is new enough, which i imagine it isnt't
14:46:27 <Peaker> Pseudonym: so why do stuff related to the same mechanisms often appear in the same chromosome?
14:46:43 <Peaker> Pseudonym: that's a good coding principle, isn't it?
14:46:49 <Saizan> bos: which version should we use?
14:46:55 <Pseudonym> Peaker: Because that way they get inherited together.
14:46:57 <conal> bos: oh!  it's 2.11~20080614
14:46:59 <vixey> good coding principles don't exist
14:47:03 <Pseudonym> But while they're on the same chromosome, a chromosome is huge.
14:47:11 <vixey> as soon as you follow some methodology without thinking, you've made a mistake
14:47:11 <Pseudonym> Genes are often quite fragmented.
14:47:45 <bos> conal: that *might* be new enough?
14:47:56 <Peaker> Pseudonym: genes are fragmented? what do you mean?
14:47:57 <Pseudonym> Hemoglobin is in about six pieces.
14:48:08 <Peaker> Pseudonym: you mean a multi-gene mechanism has its genes all over the place
14:48:15 <conal> bos: i'll try.  after installing, so I want to rebuild ghc?
14:48:25 <Pseudonym> I mean that the way to turn genes into proteines is horribly complicated.
14:48:32 <bos> conal: im not sure which parts need rebuilding.
14:48:50 <conal> bos: okay.  i'll try a few things.  thanks very much for the help.
14:48:58 <Pseudonym> You get pieces from different bits of a chromosome, some of them are catalysts, some of them are pieces...
14:49:02 <Pseudonym> Sometimes, coding regions overlap.
14:49:06 <bos> conal: i endure the pain so you don't have to :-)
14:49:17 <Pseudonym> The same piece belongs to multiple coding regions.
14:50:10 <conal> bos: and i sure do appreciate it!
14:50:39 <BMeph> I'm annoyed at how slow my company IT is to act, so I'm running GHCi on a Virtual machine. Am I just too impatient for my own good? :\
14:53:08 <Saizan> Pseudonym: good material for another icfp contest :)
14:53:41 <Pseudonym> Perhaps.
14:54:31 <Pseudonym> HEre, here's 22 hard drives.  You have no idea what's on them, but I can tell you: They're highly fragmented, and the bit on them that has code is full of the most ungodly hacks you've ever seen.
14:54:35 <Pseudonym> Now work out what it all does.
14:54:46 <Pseudonym> That's pretty much the Human Genome Project right there.
14:55:09 <ddarius> Pseudonym: And you only partially know how the machine works.
14:55:12 <jsn> BMeph: wow
14:55:14 <Pseudonym> Right.
14:55:28 <Pseudonym> And there's also stuff that isn't files.  It might be important, it might not.
14:56:29 <Pseudonym> And then, of course, there's DNA in the mitrochondria.
14:57:13 <jsn> records and views seem to be related
14:57:35 <Pseudonym> ?go "concrete view"
14:57:38 <lambdabot> http://www.flickr.com/photos/toniphotos/2220302271/
14:57:38 <lambdabot> Title: concrete view on Flickr - Photo Sharing!
14:57:47 <Pseudonym> ?go "concrete view" haskell
14:57:50 <lambdabot> http://www.haskell.org/haskellwiki/Concrete_data_type
14:57:50 <lambdabot> Title: Concrete data type - HaskellWiki
14:57:52 <vixey> hehe
14:57:54 <Pseudonym> Hm.
14:58:08 <Pseudonym> REminds me of Knuth's book, "Concrete Mathematics".
14:58:19 <Pseudonym> Apparently, a bunch of civil engineers turned up to the first lecture.
14:58:28 <vixey> lol
14:58:36 <jsn> hehe
14:59:04 <RLa> Pseudonym, we use that book in combinatorics lectures :)
14:59:10 <Pseudonym> Yeah.
14:59:13 <Pseudonym> It's a great book, isn't it.
14:59:40 <Pseudonym> It's almost as good as a "popular science" book as it is as a maths textbook.
14:59:42 <RLa> it has great 7 ways how to find closed forms to integer series :)
15:00:03 <jsn> so, if you allow RecordFieldDisambiguation, you basically have a way to say, here is this ad hoc class and the things that are in it
15:00:19 <vixey> huh
15:00:42 <jsn> and RecordPuns and RecordWildCards just make that even easier
15:01:02 <jsn> it is like duck typing
15:01:25 * RLa just got 10 factorial calculated :)
15:01:43 <pumpkin_> quack
15:01:55 <thoughtpolice> Pseudonym: i have that book open right now :]
15:03:11 <Pseudonym> @let fac n = let { f n 0 = 1; f n 1 = n; f n 2 = n*(n+1); f n c = let c2 = c `div` 2 in fac n c2 * fac (n+c2) (c-c2) } in f 1 n
15:03:12 <lambdabot>  <local>:6:117:
15:03:12 <lambdabot>      Occurs check: cannot construct the infinite type: a = a ...
15:03:29 <Pseudonym> @let fac n = let { f n 0 = 1; f n 1 = n; f n 2 = n*(n+1); f n c = let c2 = c `div` 2 in fac n c2 * fac (n+c2) (c-c2) } in f 1 n :: Integer
15:03:30 <lambdabot>  Couldn't match expected type `Integer -> Integer'
15:03:34 <jsn> i guess, you could not actually use records like typeclasses in practie
15:03:39 <jsn> s/practice/
15:03:45 <Pseudonym> @let fac n = let { f n 0 = 1; f n 1 = n; f n 2 = n*(n+1); f n c = let c2 = c `div` 2 in f n c2 * f (n+c2) (c-c2) } in f 1 n :: Integer
15:03:47 <lambdabot>  Defined.
15:03:57 <Pseudonym> > product [1..10000] `seq` ()
15:03:58 <lambdabot>   ()
15:04:06 <Pseudonym> > product [1..1000000] `seq` ()
15:04:09 <lambdabot>   * Exception: stack overflow
15:04:15 <Pseudonym> > fac 1000000 `seq` ()
15:04:22 <lambdabot>   ()
15:04:24 <Pseudonym> Want to know what 1 million factorial is?
15:04:28 <RLa> fac = fn n -> if n then 1 else n * fac (n - 1); <- in the language i just got more-less implemented :)
15:04:33 <vixey> I know it's bigger that a million
15:04:55 <RLa> huh, i do not want to know how much time it will take to calc
15:04:55 <Pseudonym> Trouble is, it takes a very long time to print it out.
15:05:00 <vixey> RLa, what' sthe byte code for it?
15:05:00 <jsn> oh, i know
15:05:06 <Pseudonym> RLa: Less than 5 seconds.  Look, I just did it.
15:05:10 <RLa> vixey, a sec
15:05:24 <jsn> maybe there's a way to put a data definition into a view based on its field definitions or something like that
15:05:27 <Pseudonym> Trouble is, it takes a few minutes to show the number.
15:05:28 <RLa> 10 factorial took about 6-7 minutes
15:06:12 <ddarius> RLa: You are doing something very very wrong.
15:06:31 <Pseudonym> ddarius: It's RLa's own compiler.
15:06:48 <Pseudonym> Writing your own language and compiler is never wrong.
15:06:49 <RLa> no, it's the machine that's slow!
15:06:51 <ddarius> Pseudonym: Yes, and he must be doing something very, very wrong for it to take that long.
15:07:12 <ddarius> Maybe if he is using unary naturals it might take that long?
15:07:15 <RLa> ddarius, the machine visualizes stack and heap contents
15:07:40 <RLa> and redrawing ofcourse takes time
15:07:57 <jsn> dcoutts: you have a cabal binary somewhere?
15:08:05 <ddarius> There's only 10 iterations.  How detailed are these visualizations?
15:08:16 <RLa> ddarius, everything
15:08:22 <dcoutts> jsn: http://haskell.org/~duncan/cabal/cabal.exe
15:08:29 <RLa> vixey, "byte" code: http://pastebin.com/m28af0b28
15:08:35 <jsn> dcoutts: thank you
15:08:45 <dcoutts> jsn: lemme know if it works ok for you, I might announce it more widely
15:08:50 <ddarius> RLa: What is "everything"?
15:09:11 <RLa> all instructions get visualized
15:09:31 <vixey> RLa, aha cool
15:09:34 <RLa> wwith nice animations
15:10:05 <mmorrow> RLa: sounds very cool
15:10:14 <Peaker> hmm, what's the difference between: leftButtonPressed ui `snapshot_` mouseMotion ui    and liftA2 snapshot_ leftButtonPressed mouseMotion ?
15:10:31 <Peaker> oh, the application with ui
15:10:54 <RLa> the compiled code runs on this: http://wwwseidl.in.tum.de/projekte/vam/
15:11:48 <ddarius> Each step takes about 6 seconds to animate?
15:13:08 <ddarius> Well I guess it's about a second.
15:13:32 <RLa> yeah, you can change the speed also
15:25:03 <vixey> so
15:25:06 <vixey> just wondering
15:25:15 <vixey> does cabal work ?
15:25:39 <vixey> it seems like a great idea.. this thing that can install software automatically
15:26:40 <Peaker> vixey: you're not using cabal-install?
15:26:45 <Peaker> vixey: its great
15:26:56 <vixey> I had endless problems with it in mac
15:27:23 <Saizan> vixey: if you have some specific problem we can help
15:27:59 <dons> vixey: endless problems?
15:28:07 <vixey> just wondering if people use it sucessfully
15:28:08 <dons> did you report any of them to the cabal authors?
15:28:19 <dons> vixey: yes. galois is using it as the primary build tool on a number of projects
15:28:27 <dons> with multiple engineers. it is indispensible.
15:28:41 <vixey> dons, Every problem I had was fixed in a later version of cabal which I could not install because cabal was broken
15:29:08 <Saizan> vixey: Cabal doesn't need an older version of itself to install
15:29:10 <dons> vixey: i think its just you ;). just make sure you have cabal 1.6.x and cabal-install 0.6.x. seems to work for everyone else.
15:29:13 <dcoutts> vixey: you can bootstrap Cabal from fresh, it can build itself without using any older version
15:29:21 <vixey> ok I'll try this out
15:29:36 <dcoutts> vixey: there's Cabal the lib, and cabal-install which provides the command line tool
15:29:44 <dcoutts> the latter depends on a couple other packages, HTTP and zlib
15:29:47 <vixey> http://www.haskell.org/cabal/download.html
15:29:48 <lambdabot> Title: The Haskell Cabal
15:29:50 <vixey> cabal-install isn't there
15:29:51 <dons> i strongly encourage people to get a working cabal-install toolchain if they wish to do serious haskell.
15:29:57 <vixey> so it is a good idea to get the darcs one?
15:29:58 <dons> it removes major bottlenecks to getting stuff done.
15:30:05 <Peaker> conal: ping
15:30:05 <dons> vixey: use the one on hackage.
15:30:06 <Philonous> I needed mtl and network as well
15:30:08 <Saizan> ?hackage cabal-install
15:30:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
15:30:22 <vixey> omg the dependencies ..
15:30:32 <luite> vixey: it has a script that will bootstrap the dependencies for you
15:30:34 <Saizan> only _4_ dependencies
15:30:42 <dcoutts> vixey: oh, oops I didn't update that download page, as dons says they're all on hackage
15:30:43 <Saizan> and there's a bootstrap.sh script
15:31:11 <conal> Peaker: here
15:31:42 <Peaker> conal: spinning :: Behavior (Transform3 Double) -- is a Transform3 invertible, or do I have to manually create the inverse Transform3?
15:31:50 <conal> (getting dual-head-single-rotate help in #nvidia)
15:32:22 <luite> where should I report issues with cabal or cabal-install? I found that some directories don't seem to be set correctly by default, in the windows version (C:\Program Files\ or a user install, which is not user writable)
15:32:23 <conal> Peaker: i forget, offhand.  probably invertible.  check the haddock docs via the hackage page.
15:32:47 <mmorrow> Peaker: re: http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=headblob;f=/Makefile
15:32:53 <lambdabot> Title: joyful.com darcsweb - hledger, http://tinyurl.com/5v3qe4
15:32:59 <Peaker> conal: Ok. I'm trying to get the left-clicks to happen at the right place
15:33:02 <snk_kid> vixey: http://monadickid.blogspot.com/2008/11/haskell-eye-for-windows-guy.html
15:33:05 <lambdabot> Title: ∃planet ∈U Life∃(planet): A Haskell eye for the windows guy, http://tinyurl.com/64tquk
15:33:05 <vixey> Setup: At least the following dependencies are missing: zlib >=0.4 && <0.6 Sorry, something went wrong. # bootstrap.sh says that ... but will everything screw up or work if I just install zlib?
15:33:20 <mmorrow> now that i look more closely, it isn't hoogle doing that overlay on haddock, but he's got a custom thing going on there
15:33:30 <vixey> snk_kid, thanks but I'm not using windows
15:33:47 <snk_kid> vixey: should be the same procedure but without the mingw bit
15:33:50 <pastorn> hi
15:34:05 <Saizan> vixey: you can just install zlib
15:34:11 <vixey> I'm going to install zlib and everything will break
15:34:18 <pastorn> i'm making a datastructure for a grid and i would like some critique
15:34:41 <pastorn> anyone have a spare minute?
15:34:47 <conal> Peaker: awesome.
15:35:02 <pastorn> (it's <10 lines of code)
15:35:18 <vixey> it says
15:35:22 <vixey> Preprocessing library zlib-0.5.0.0...  Stream.hsc:79:18: error: zlib.h: No such file or directory
15:35:24 <luite> pastorn: just put it on hpaste
15:35:24 <Peaker> conal: any idea what might delay the left clicks by ~1 second, btw?
15:35:31 <Saizan> luite: http://hackage.haskell.org/trac/hackage/
15:35:39 <conal> pastorn: if you hpaste your code and announce it, someone might bite.
15:35:57 <conal> Peaker: i haven't seen that delay.  under what conditions?
15:36:01 <vixey> I'll try installing the real zlib..
15:36:07 <Saizan> vixey: you've to install the C zlib
15:36:07 <lambdabot> Title: Hackage - Trac
15:36:12 <Peaker> conal: it seems to always be, its the last weirdness that did not mysteriously disappear
15:36:21 <dcoutts> luite: that issue of where to install to by default on windows is tricky.
15:36:39 <conal> Peaker: urg.  including the rotating text examples?
15:36:42 <dcoutts> luite: we used to default to per-user dirs, but people complained and we switched back to global ones.
15:36:44 <Saizan> vixey: the -dev version if your distro have separate packages
15:36:59 <Peaker> conal: oh, those conditions, I think only in placeL
15:37:06 <dcoutts> luite: part of the issue is that there is no nice sensible per-user dir to install into that is on the %PATH%
15:37:24 <Peaker> conal: revText is fine/immediate
15:37:24 <conal> Peaker: hm. let me look a bit...
15:37:34 <vixey> so why bootstrap doesn't install zlib?
15:37:45 <conal> Peaker: good.  and strange.
15:37:56 <luite> dcoutts: hm, but none of Program Files dirs is on the path either
15:38:00 <dcoutts> vixey: the C zlib C library is a system package, we cannot install it
15:38:35 <dcoutts> luite: true, though the ghc installer puts Program Files/Haskell on the %PATH% (or was it Haskell/bin, I forget)
15:38:46 <Peaker> conal: it seems also that you don't redraw when I alt-tab and back
15:38:49 <conal> Peaker: i'm very puzzled!  i get maybe 1/10 sec delay.
15:38:57 <conal> Peaker: oh yeah.  known bug.  sry.
15:39:35 <conal> Peaker: i'll add a trac item so i'll remember.  will take some work on both reactive & reactive-fieldtrip
15:39:35 <dcoutts> luite: could you file a new ticket for this issue, I'd like to get different people's opinions on what the best thing to do is.
15:39:59 <dcoutts> luite: it's clear that having it not work by default is bad, and for lots of systems you're not admin so cannot install into Program Files
15:40:00 <luite> dcoutts: ah, but in this case the dir that gave me problems was not for executable files, most packages installed correctly, but this one had some extra files (changelog and readme or something) that defaulted to c:
15:40:02 <Peaker> conal: you don't get a redraw event, that you can just subscribe a repaint action to?
15:40:04 <luite> program files
15:40:07 <conal> Peaker: and please to contribute to the trac db.
15:40:38 <dcoutts> luite: oh, ok, please file all the details in a new ticket here: http://hackage.haskell.org/trac/hackage/
15:40:39 <lambdabot> Title: Hackage - Trac
15:40:43 <conal> Peaker: i probably do.  and it's a bit more involved than that on the reactive end.
15:40:54 <Peaker> conal: http://trac.haskell.org/FieldTrip is an Error 500 Server Error
15:40:57 <Peaker> conal: where's the trac?
15:41:00 <vixey> oh you have to install Cabal before cabal-install
15:41:07 <yitz> @hpaste
15:41:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:41:15 <yitz> pastorn: ^^
15:41:16 <conal> http://trac.haskell.org/reactive and http://trac.haskell.org/fieldtrip
15:41:17 <lambdabot> Title: reactive - Trac
15:41:43 <pastorn> yitz: yeah, i just came to think of that i might need an example of a simple use
15:41:53 * pastorn writes it manually
15:42:23 <vixey> @hackage HTTP
15:42:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
15:42:35 <Peaker> why does each trac require its own registration?
15:42:42 <Lemmih> Igloo: I'm seeing this behavior with ghc-6.10: http://hackage.haskell.org/trac/ghc/ticket/1712
15:42:43 <lambdabot> Title: #1712 (unknown symbol “glutGet”) - GHC - Trac
15:43:09 <luite> dcoutts: ok, will do that when I use my windows computer again (tomorrow probably)
15:43:21 <dcoutts> luite: thanks
15:43:29 <conal> Peaker: some fieldtrip vs FieldTrip confusion for now.  sigh.
15:44:33 <mmorrow> speaking of trac, does anyone know off hand howtf to setup logins on a new trac install?
15:44:58 <mmorrow> (i was having an epic the other day..)
15:45:27 <pastorn> http://hpaste.org/11946
15:45:51 <pastorn> ^ that's my grid implementation, please flame me ^
15:46:31 <conal> Peaker: would you mind adding the redraw-window task to the fieldtrip trac?
15:46:36 <pastorn> luite, conal, yitz: ^^
15:46:47 <vixey> @hackage Happy
15:46:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Happy
15:47:02 <mmorrow> @hackage Sad
15:47:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Sad
15:47:17 <yitz> pastorn: looks like you're thinking of a zipper
15:47:45 <vixey> oh my god
15:47:49 <vixey> does anyone else get this for Happy?
15:47:52 <vixey> or know why
15:47:59 <pastorn> yitz: i might be... but isn't zipper just for going backwards? i want to be able to move more freely
15:48:11 <vixey> % runhaskell Setup.lhs configure
15:48:12 <vixey> Setup.lhs:30:43: Not in scope: `buildVerbose'
15:48:13 <mmorrow> pastorn: that's exactly what a zipper's for :)
15:48:23 <pastorn> iirc, zipper is a class, so that wouldn't be too hard to make an instance of it
15:48:27 <mmorrow> (moving freely)
15:48:48 <conal> pastorn: perhaps a pair of zippers here
15:48:53 <conal> pastorn: i mean nested zippers
15:49:09 <pastorn> is zipper in the standard libraries
15:49:11 <mmorrow> vixey: yeah, you've gotta update that part of Setup.(l)hs
15:49:18 <pastorn> (installed with ubuntu 8.10);
15:49:22 <vixey> that is so ridiculous
15:49:27 <conal> pastorn: someone added a list zipper package recently
15:49:53 <conal> pastorn: http://hackage.haskell.org/packages/archive/pkg-list.html
15:49:54 <lambdabot> Title: HackageDB: packages by category
15:49:58 <vixey> I don't like Happy :(
15:50:02 <yitz> pastorn: it's a good idea.
15:50:02 <yitz> pastorn: If the board shape is fixed, here's another idea:
15:50:03 * pastorn fires up synaptic
15:50:16 <pastorn> yitz: annotate :)
15:50:55 <yitz> pastorn: you create a circular link structure of the board, so that up/down/left/right just follow the links.
15:51:09 <robertg> can anyone help me to understand why [ [b] | (a, [b]) <- [('r', [True])], a == 'r' ] outputs [[True]]     but [ [b] | (a, [b]) <- [('r', [True, True])], a == 'r' ] outputs []
15:51:13 <yitz> pastorn: it takes a little work, so I can't annotate so fast :)
15:51:26 <Saizan> vixey: which version of Cabal do you have?
15:51:37 <mmorrow> she's using ghc 6.11
15:51:56 <ddarius> robertg: [b] does not match [True, True]
15:51:57 <vixey> % cabal version unrecognised command: version (try --help)
15:51:58 <vixey> :)
15:52:06 <Saizan> vixey: ghc-pkg list Cabal
15:52:16 <vixey> 1.6.0.1 and cabal-install 0.6.0
15:52:43 <Saizan> ok, me too
15:52:44 <vixey> I don't understand ghc-pkcg
15:52:54 <vixey> it lists like 3 different versions
15:53:08 <Saizan> and happy's Setup script builds with just a warning
15:53:15 <robertg> ddarius: why not? it looks like it should to me?
15:53:15 <Saizan> vixey: because you've 3 versions installed
15:53:24 <vixey> I only wanted one :/
15:53:35 <Saizan> you can unregister the others
15:53:47 <vixey> should I? or juts leaving it is also ok
15:53:47 <vixey> ?
15:54:05 <Saizan> however "runghc -package Cabal-1.6.0.1 Setup configure" should work
15:54:08 <Philonous> Is there a gtk2hs version that supposedly works with ghc 6.10 ?
15:54:12 <Saizan> just leaving it's also ok
15:54:28 <dcoutts> Philippa: current darcs version is reported to work
15:54:29 <ziman> robertg, [b] matches only one-element lists, b being the only element of the list
15:54:46 <dcoutts> oops, tab completion, sorry Philippa
15:54:52 <dcoutts> Philonous: ^^
15:55:05 <vixey> it said not in scoe main
15:55:11 <vixey> not in scope main
15:55:16 <robertg> ziman - oh yes I see that now- how might I change that to show all the elements?
15:55:36 <ziman> robertg, you might want to use [ b | (a, b) <- [('r', [True, True])], a == 'r' ]
15:55:55 <ziman> robertg, b (as a simple variable) matches anything
15:55:59 <Philonous> dcoutts: Humm, it gives me build errors
15:56:02 <robertg> ziman: I had that but I need a list of lists
15:56:07 <lilac> robertg: you might want to use lookup
15:56:11 <lilac> @type lookup
15:56:13 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:56:27 <ziman> robertg, b can match lists:
15:56:36 <Saizan> vixey: ok, runghc doesn't work as i expected but you can compile the Setup script with ghc --make Cabal-1.6.0.1 Setup, that definitely works
15:56:38 <ziman> > (\b -> [b, b, b, b]) [True]
15:56:39 <lambdabot>   [[True],[True],[True],[True]]
15:56:57 <ziman> robertg, in the above example, b is bound to [True]
15:57:07 <vixey> for me it says Setup.lhs:30:43: Not in scope: `buildVerbose'
15:57:10 <robertg> ah yes sorry I thought you had  [ b | (a, [b]) <- [('r', [True, True])], a == 'r' ]
15:57:17 <vixey> but I think I'll fix this stuff tommorow
15:57:32 <ziman> there's no need to explicitly state `b is a list'
15:57:34 <Saizan> ah, i forgot -package
15:57:40 <Saizan> it's late for me too :)
15:57:50 <lilac> > lookup 'r' [('r', [True, True])]
15:57:52 <lambdabot>   Just [True,True]
15:58:15 <lilac> > maybeToList $ lookup 'r' [('r', [True, True])]
15:58:17 <lambdabot>   [[True,True]]
15:58:22 <Saizan> vixey: if you constantly use the devel version of ghc you should learn about ghc-pkg and friends
15:58:38 <vixey> Saizan these tools are way way too complex for me
15:58:41 <dons> how could we make the use of the standard haskell toolchain easier ?
15:58:48 <dons> the use of cabal, cabal-install and ghc-pkg?
15:58:58 <dons> is it just lack of a coherent, integrated overview of the work flow?
15:59:12 <lilac> is it possible to install newer versions of ghc with cabal?
15:59:22 <robertg> thanks guys that seems to do the trick
15:59:23 <dons> nope. ghc isn't cabalised.
15:59:32 <lilac> that might help a bit
16:00:00 <lilac> other than that, i've generally found using cabal pretty simple
16:00:42 <wchogg> conal:  Conceptual question for you on Reactive, if you don't mind.  Whenever a tetris piece "lands", I want to randomly generate the next piece to drop.  I'm not sure the best way of threading something that stateful into my program without contaminating everything with IO or having a (StdGen g) => Behavior g that I also keep track of.
16:01:05 <luite> the name of the package cabal-install could be more intuitive :)
16:02:08 <luite> and maybe some better error reporting and non-haskell dependency checking (missing zlib.h seems to be one of the most common problems for beginners)
16:02:42 <dons> luite: there's an open ticket for C lib error
16:02:47 <Philonous> manpages would be nice
16:03:03 <dons> distro specific.
16:03:07 <dons> please consult your distro
16:03:32 <yitz> why are man pages distro specific?
16:03:57 <pastorn> yitz: you got something?
16:04:42 <dons> distros have different conventions for them, while haskell apps tend to provide haddock docs.
16:04:44 <conal> wchogg: yeah.  injecting IO/state would contaminate things quite a lot.
16:05:29 <conal> wchogg: it's part of the point (for me) of frp to make that sort of thing impossible, since I want frp to have simple semantics, and IO doesn't have any tractable semantics.
16:05:52 <yitz> pastorn: remebering when I did that - it was for the edge and corner pieces of a rubik cube, that never change.
16:06:04 <conal> wchogg: so i'd look for a deterministic, non-IO solution.  maybe use the time.
16:06:10 <mm_freak> is there any difference between Data.ByteString and Data.ByteString.Char8, besides that the Char8 version makes it easier to pack/unpack Strings?
16:06:19 <Saizan> re cabal: if you use the devel version of tools you should expect some problems and potentially contribute solving them
16:06:42 <pastorn> yitz: my idea was that focus movement would be fast; moving right/left is O(1) and up/down is O(n) where n is the width
16:06:42 <yitz> pastorn: I connected them together using a Map that gave the "next piece to the right" on a given face
16:06:47 <dons> mm_freak: no.
16:06:58 <luite> Saizan: would that include anything marked 'experimental' on hackage? :)
16:07:09 <pastorn> yitz: but you said you did something cyclic?
16:07:17 <yitz> pastorn: using a Data.Map, moving any direction is log n.
16:07:48 <pastorn> i talked to a friend, he said that i should do somithing like this
16:07:55 <juhp> anyone have an array package that builds with ghc6.10?
16:08:14 <Saizan> luite: i was referring to HEAD ghc and HEAD Cabal, hackage releases usually work :) (even if today i had problems with hscurses which is Stable)
16:08:15 <yitz> pastorn: yes. a corner piece has 3 stickers. "next" cycles around them, thus also moving from face to face.
16:08:17 <ivanm> juhp: the one that actually comes with 6.10?
16:08:21 <dons> the array package that ships with ghc 6.10?
16:08:41 <yitz> pastorn: but it only worked because those corner pieces are immutable.
16:09:00 <juhp> ah thanks... then I guess I need to update the packages that are asking for 0.1.0
16:09:16 <ivanm> juhp: yup
16:09:32 <pastorn> data Grid a = Data.Map (Int,Int) a
16:09:38 <pastorn> *type*
16:10:50 <mm_freak> Data.Map.Map
16:11:49 <tomh> anyone knows what the $ operator is called in haskell? kinda hard to google -.-
16:11:54 <jsn> wchogg: what is difficult, from your point of view, about keeping tracking of a StdGen in this case?
16:12:03 <jsn> is it apply?
16:12:27 <tomh> mm possibly
16:12:31 <yitz> or dollar
16:12:33 <jsn> s/keeping tracking/keeping track/
16:13:05 <tomh> what does it do?
16:13:09 <juhp> wonder how it would be if hackage had separate dists for ghc6.X etc
16:13:27 <jsn> tomh: it affects precedence
16:13:28 <wchogg> jsn:  Nothing _difficult_, just seems 'unpleasing' for some reason.  I'm starting to think, though, that conal is right and maybe I'll use the time behavior as a time dependent seed for random generation.
16:13:52 <mm_freak> dons: is UVector mature enough so that UArr Word8 can replace ByteString?
16:14:12 <jsn> <what ever on the leat> $ <what ever on the right>    means "apply whatsoever is on the left to whatsoever is on the right
16:14:13 <yitz> tomh: it allows you to avoid parens in certain cases
16:14:14 <jsn> "
16:14:31 <jsn> tomh: right, that's the use case
16:14:51 <tomh> ok
16:15:00 <dons> mm_freak: not yet, but getting there.
16:15:06 <dons> mm_freak: that's one of my next goals.
16:15:17 <conal> Peaker: the ftrac instance is now http://trac.haskell.org/FieldTrip/
16:15:17 <lambdabot> Title: fieldtrip - Trac
16:15:19 <jsn> for example,    return (Just theResult)     can be written as    return $ Just theResult
16:15:30 <yitz> > sum $ [1..6] ++ [3,6..15]
16:15:30 <lambdabot>   66
16:15:30 <conal> Peaker: s/ftrac/FieldTrip trac/
16:15:32 <tomh> ah i see
16:15:37 <tomh> saves like one char :)
16:15:40 <jsn> wchogg: i guess people could cheat that way
16:15:43 <yitz> > sum ([1..6] ++ [3,6..15])
16:15:43 <dons> ?users
16:15:43 <lambdabot> Maximum users seen in #haskell: 559, currently: 521 (93.2%), active: 23 (4.4%)
16:15:44 <lambdabot>   66
16:15:50 <jsn> tomh: it saves no chars, actually
16:15:56 <yitz> tomh: also easier to read
16:15:57 <tomh> if you use a space ye
16:15:58 <jsn> '$ ' or '()'
16:16:13 <tomh> or is the space mandatory?
16:16:18 <wchogg> jsn:  How's it cheating?
16:16:29 <juhp> oh wow what happened!  cabal install on yi.darcs built! ;o)
16:16:38 <jsn> wchogg: i mean, couldn't devious players access the StdGen and know the future?
16:16:39 <juhp> (-:
16:16:58 <jsn> tomh: i don't think it's mandatory, but it's good style
16:17:04 <tomh> ye true
16:17:07 <mm_freak> what does a String in NF look like in memory?  is it really a linked list of Chars, or is it a more efficient structure?
16:17:15 <pastorn> yitz: but could you please paste the code for what you did (that rubiks cube), i'd love to look at it and maybe learn something
16:17:33 <yitz> tomh: $ is also useful for apply a list of functions
16:18:03 <yitz> > map ($ [3,5..9]) [sum, product, maximum]
16:18:04 <lambdabot>   [24,945,9]
16:18:05 <tomh> ye so you dont get a (((()))) mess
16:18:27 <mm_freak> (in GHC i mean)
16:18:33 <tomh> mm cool example
16:18:42 <Lemmih> mm_freak: They really are lists of chars.
16:18:45 <jsn> tomh: are you familiar with operator sections?
16:18:54 <tomh> maybe, not sure
16:18:57 <mm_freak> =/
16:19:04 <tomh> not with the name -.-
16:19:18 <jsn> tomh: well, all functions in haskell can be "partially applied"
16:19:28 <jsn> an operator can be partially applied, too
16:19:38 <tomh> like you can remove the first argument if its the last part of a function ?
16:19:46 <jsn> on the left     (1 +)    or on the right    (+ 1)
16:20:00 <tomh> i mean last argument
16:20:01 <jsn> well, it means, you can make a new function from an old function
16:20:01 <tomh> ye
16:20:14 <jsn> so i just made some functions that "add 1"
16:20:33 <mm_freak> > zipWith ($) [sum, product, maximum] [[1,2,3], [4,5,6], [7,8,9]]
16:20:35 <lambdabot>   [6,120,9]
16:21:04 <tomh> isnt that currying? making a new function of an old one?
16:21:06 <jsn> operators can be partially applied from the front or back, unlike normal funcitons
16:21:32 <mm_freak> tomh: currying is a notation
16:21:40 <jsn> :t curry snd
16:21:42 <lambdabot> forall a b. a -> b -> b
16:21:45 <mm_freak> curried:  hPutStrLn handle "blah"
16:21:47 <jsn> :t curry
16:21:48 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:21:51 <mm_freak> uncurried:  hPutStrLn (handle, "blah")
16:21:59 <tomh> ok
16:22:10 <hesselink> you can partially apply a function to its second argument by writing it infix
16:22:20 <hesselink> `f` args
16:22:22 <mm_freak> currying allows you things like partial application without any syntactic extensions
16:22:27 <tomh> damn have to catch up a lot of stuff before i get toasted on my next course :P
16:22:37 <jsn> curry takes a function that takes a tuple of arguments, and turns it into a function that takes and argument and returns a function that takes the next argument and returns a function that...
16:22:42 <ksf> hback is definitely evil.
16:22:46 <Philonous> Partial application and currying are often used synonymously, though
16:23:00 <tomh> ok
16:23:01 <jsn> Philonous: oh?
16:23:14 <mm_freak> Philonous: huh?  never seen that being done
16:23:23 <tomh> hesselink: i see you are from the UU too, nice :)
16:23:59 <Philonous> I saw a conference video of spj just today where he mixed them up
16:24:00 <hesselink> tomh: yes, lots of UU people here (though not at this time, usually)
16:24:03 <ksf> I'm just not used to purge my working memory of previous knowledge, but rather to build up an image over half an hour.
16:24:30 <ddarius> mm_freak: Currying is an operation.
16:24:34 <tomh> i guess i should be familiar with most of them very soon
16:24:36 <yitz> pastorn: won't fit in an hpaste. :(
16:24:52 <tomh> most people probably do ST then
16:25:03 <hesselink> most that hang out here, yes
16:25:10 <FunctorSalad_> if f : (a,b) -> c, you could do "f_partially_applied = f . (id &&& const my_b)"
16:25:11 <jsn> UU ?
16:25:14 <ddarius> mm_freak: It's not a notation.
16:25:15 <jsn> ST ?
16:25:17 <hesselink> or they are lecturers :)
16:25:22 <mm_freak> ddarius: what is the notation called then?
16:25:27 <tomh> university of utrecht, master software technology
16:25:33 <mm_freak> or rather, the notational style
16:25:39 <jsn> ah
16:25:42 <ddarius> mm_freak: There is no "notation".  It's just application.  Nothing magical is happening.
16:25:43 <tomh> lecturers hang out here too?
16:25:50 <hesselink> sure
16:25:51 <tomh> which ones -.-
16:25:53 <FunctorSalad_> (that is to say, I'm not sure the easier partial application in order of the arguments justifies the higher complicatedness induced by currying)
16:25:55 <luite> ah more uu'ers :P
16:26:03 <hesselink> andres loeh at least
16:26:07 <pastorn> yitz: alexander.goransson at gma...
16:26:17 <mm_freak> ddarius: yeah, but there is a difference between haskell's "f x y" and other languages' "f (x,y)"…  what is the former style called?
16:26:17 <tomh> ok
16:26:24 <luite> I am from UU, but not master ST
16:26:28 <conal> Saizan: did you try rebuilding ghc 6.10.1 with libedit-dev?  i did, and i got no change. still echoing my input, including "^J"  :(
16:26:40 <tomh> i just started ST
16:26:47 <mdmkolbe> What is the Haskell FFI equivalent of "void*"?  I get that "Ptr CChar" is "char*" and "Ptr CInt" is "int*", but I can't find anything for "void*"
16:26:50 <tomh> tomorrow compiler construction with haskell
16:27:08 <Lemmih> mdmkolbe: Ptr ().
16:27:09 <mm_freak> mdmkolbe: probably Ptr ()?
16:28:19 <Saizan> conal: same here
16:28:20 <mdmkolbe> That would only work if () isn't a Storable instance (I don't see one but it might be hiding)
16:28:42 <conal> Saizan: drat.  i'll ask on #ghc.
16:28:55 <mdmkolbe> how do I search the entire haskell library for instances of ()?
16:28:59 <Lemmih> mdmkolbe: Why do you think that?
16:29:18 <tomh> well thanks for the info all, time to sleep :/
16:29:40 <mdmkolbe> Lemmih: in C void* very specifically means a pointer that you can't (directly dereference).
16:29:58 <mdmkolbe> s/(directly dereference)/(directly) dereference/
16:30:07 <mm_freak> hmm…  maybe something like:  forall a. Ptr a
16:30:17 <Lemmih> mdmkolbe: Peeking and pushing a void is obviously undefined and 'Ptr a' is an instance of Storable.
16:30:55 <mofmog> This may not be specific to haskell, but how do i go around sending say, a sine wave to my soundcard or something
16:31:24 <mofmog> or get it to output a squarewave (probably easier), or something
16:31:27 <mdmkolbe> Lemmih: you can store a Ptr in something else. the question is whether you're allowed to store ()
16:31:38 <mm_freak> mofmog: there are a few sound libraries for Haskell, see <http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Sound>
16:31:39 <lambdabot> Title: HackageDB: packages by category, http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Sound>
16:32:05 <mm_freak> mdmkolbe: you're allowed to store (), but you can use something like (forall a. Ptr a)
16:32:17 <mm_freak> at least i guess so
16:32:22 <Lemmih> mdmkolbe: I don't see the problem.
16:33:11 <yitz> pastorn: http://paste.lisp.org/display/70172
16:33:38 <mdmkolbe> Lemmih: poke (foo :: Ptr a) is legal only if "a" is storable.  We don't want that to be legal.
16:34:09 <mdmkolbe> mm_freak: would that be a universal "a" or an existential "a" (it's been a while and I can't remember)
16:34:11 <noddy> is there a way to declare a class for types a, such that for every type a there would a particular type b involved in function signatures?
16:34:37 <mdmkolbe> mm_freak: (I think I want an existential "a" b/c that would force a cast before any deref (but I'm not sure))
16:34:38 <Lemmih> mdmkolbe: That's what 'castPtr' is for.
16:34:49 <mm_freak> mdmkolbe: that would be an 'a' too polymorphic for the values of it to make any sense
16:35:05 <noddy> ie, class Foo a where { foo1 :: a -> b; foo2 b -> a; }, where there is a single b per a?
16:35:38 <mdmkolbe> @type peek
16:35:39 <lambdabot> Not in scope: `peek'
16:35:51 <mdmkolbe> @type Foreign.Storable.peek
16:35:52 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
16:36:12 <mdmkolbe> @type Foreign.Storable.peek (undefined :: forall a. Ptr a)
16:36:13 <lambdabot> Not in scope: type constructor or class `Ptr'
16:36:16 <ddarius> mm_freak: You can call it curried style, but it is still not currying.  At best it's the result of currying, though even that is not an accurate characterization of the situation.
16:36:16 <FunctorSalad_> noddy: class Foo a b | a -> b where ...
16:36:24 <mm_freak> noddy: functional dependencies  class Foo a b | a -> b where …
16:36:32 <Lemmih> mdmkolbe: What specifically are you trying to do?
16:36:35 <mdmkolbe> @type Foreign.Storable.peek (undefined :: forall a. Foreign.Ptr.Ptr a)
16:36:36 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO a
16:36:43 <conal> rats, missed bos.
16:37:07 <noddy> will look into it, thx
16:37:08 <mm_freak> ddarius: makes sense
16:37:52 <FunctorSalad_> what then? "would be the result of currying if it hadn't been born curried?"?
16:37:54 <mdmkolbe> mm_freak: yeah, that universal doesn't work (peeks are legal), but I'm sure the existential version would work.  thanks for the help
16:38:29 <mm_freak> mdmkolbe: that's the same trick ST uses to allow safe threading of the state
16:39:15 * mdmkolbe just realize existeantials won't work either (they require an extra constructor around the Ptr)
16:39:27 <mm_freak> huh?
16:39:52 <pastorn> yitz: thanks... i don't get that much, but thanks
16:39:53 <mm_freak> note that existential quantification is a type system extension
16:40:05 <Lemmih> mdmkolbe: Are you sure there's not a really simple solution to your problem?
16:40:29 <FunctorSalad_> mm_freak / mdmkolbe : I'm not familiar with the ffi but what's the difficulty with void* ?
16:40:34 <FunctorSalad_> just curious
16:40:48 <mm_freak> FunctorSalad_: he want's peek/poke not to work on void pointers
16:40:49 <mdmkolbe> mm_freak: the only way to write an existential is "data Foo = Foo (forall a. Ptr a)" <- note the "Foo" constructor around everything
16:41:03 <mdmkolbe> FunctorSalad_: what mm_freak said
16:41:06 <FunctorSalad_> :)
16:41:42 <Lemmih> mm_freak: Why is that a problem?
16:41:46 <mdmkolbe> FunctorSalad_: this is because "*(void*)x" is a type error in C.  You always have to cast away from (void*) before dereferencing
16:41:57 <mm_freak> mdmkolbe: getSomePointer :: IO (forall a. Ptr a)
16:42:12 <Lemmih> mdmkolbe: You have to do the same thing in Haskell.
16:42:14 <mdmkolbe> FunctorSalad_: thus I would like the same constraint imposed on the Haskell type
16:42:14 <FunctorSalad_> does the haskell translation have to be a Ptr something?
16:42:50 <mm_freak> Lemmih: i don't know, but probably it's a pointer to some opaque structure
16:43:02 <mdmkolbe> FunctorSalad_: not nessisarily, but keeping it close to Ptr would be nice (i.e. just a newtype around it might be ok)
16:44:30 <mfwitten> Well, there was an interesting 6.8.3 binary distribution for Mac OS X PPC that allowed me to configure the destination for installation. With this, I have been able to start building GHC 6.10.
16:44:42 <mfwitten> 6.10.1, that is.
16:44:54 <FunctorSalad_> Ptr AnyCastable, AnyCastable an existential castable?
16:45:07 <Lemmih> mdmkolbe: "peek (ptr :: Ptr ())" is a type error in Haskell. You always have to cast away from 'Ptr ()' before dereferencing.
16:45:46 <mm_freak> Lemmih: unless there is some hidden Storable instance for ()
16:45:59 <mm_freak> that's his concern
16:46:15 <Lemmih> mm_freak: There is no. There cannot be a sensible instance for ().
16:46:39 <mofmog> I thought () was everything and nothing
16:46:42 <mm_freak> why not?  it's just that it would always poke and peek the same value
16:47:23 <Lemmih> mm_freak: Exactly. They wouldn't touch the ptr at all. No dereferencing takes place.
16:47:51 <dolio> 'data Foo = Foo (forall a. Ptr a)' is not an existential.
16:48:22 <mdmkolbe> Lemmih: () has one object in it's type.  void has no objects in it's type.  I should probably do "data Void -- no constructors" and use "Ptr Void" isntead of "Ptr ()"
16:48:24 <mm_freak> Lemmih: but it wouldn't be wrong, if
16:48:36 <sjanssen> mofmog: () is (), it isn't anything else
16:49:30 <mofmog> (), is it a value?
16:49:30 <ddarius> @src ()
16:49:31 <lambdabot> data () = ()
16:49:34 <mdmkolbe> dolio: ah, yes.  I think it is really "data Foo = forall a. Foo (Ptr a)" but the same problem remains: the result isn't a Ptr anymore
16:49:35 <Lemmih> mdmkolbe: That will also work.
16:49:37 <dolio> Man, Agda takes an absurd amount of memory.
16:49:39 <mm_freak> mofmog: yes, () is a value of type ()
16:49:55 <mm_freak> in fact, the only value besides bottom
16:50:14 <mofmog> There is only () and _|_?
16:50:20 <mm_freak> yes
16:50:25 * mofmog has become enlightened
16:50:52 <lilac> well, technically there are multiple _|_
16:50:53 <mm_freak> it's called the 'unit type' for some reason
16:50:59 <mdmkolbe> mofmog: () is called the "unit type" because it has exactly one value in it (just like the binary type has two values in it)
16:51:01 <mm_freak> lilac: how that?
16:51:16 <lilac> mm_freak: in the sense that 'error "hello"' != 'error "world"'
16:51:25 <mdmkolbe> (well binary or boolean more commonly)
16:51:37 <mm_freak> lilac: computationally they are equivalent in that the function does not return a result
16:52:17 <lilac> mm_freak: if we had a full semantics for haskell they'd be different, due to 'catch'-type stuff
16:52:40 <lilac> but i do take your point
16:52:41 <mm_freak> the result of the function is bottom, no matter how the bottom is 'reached'…  the value 'bottom' is always the same
16:53:09 <mdmkolbe> lilac: in semantics actually 'undefined' is observationally equivalent to 'undefined' so there is only one bottom in semantics (I'm excluding hooks haskell mihgt have in "error")
16:53:23 <mofmog> There is only nothing and error, and when meditated upon, the error is nothing- thus there is nothing.
16:54:26 <mm_freak> mdmkolbe: back to your problem, you're not looking for existential types, but for quantification…  this is something you'd use in type signatures
16:54:27 * mdmkolbe gives mofmog a Zen cookie
16:54:43 <lilac> mdmkolbe: you assume that all bottom values are 'undefined' in the semantics, but they can't be in any semantics which includes IO
16:54:53 <mm_freak> allocateOpaqueStructure :: IO (forall a. Ptr a)
16:55:00 <mdmkolbe> lilac: true
16:55:13 <mofmog> So type () is an instance of what classes?
16:55:35 <yitz> @info ()
16:55:35 <lambdabot> ()
16:55:49 <yitz> @instances ()
16:55:50 <lambdabot> Couldn't find class `()'. Try @instances-importing
16:55:53 <mdmkolbe> @type (undefined :: IO (forall a. Ptr a) >>= \x -> peek x)
16:55:54 <lambdabot> parse error on input `\'
16:56:05 <mdmkolbe> @type (undefined :: IO (forall a. Ptr a)) >>= \x -> peek x
16:56:06 <lilac> Monoid, for one
16:56:06 <lambdabot> Not in scope: type constructor or class `Ptr'
16:56:06 <lambdabot> Not in scope: `peek'
16:56:10 <yitz> @instances-importing ()
16:56:11 <lambdabot> Couldn't find class `()'. Try @instances-importing
16:56:24 <mdmkolbe> @type (undefined :: IO (forall a. Foreign.Ptr.Ptr a)) >>= \x -> Foreign.Storable.peek x
16:56:25 <lambdabot> forall b. (Foreign.Storable.Storable b) => IO b
16:56:28 <yitz> @hoogle ()
16:56:29 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
16:56:29 <lambdabot> Control.Parallel.Strategies r0 :: Strategy a
16:56:29 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
16:56:47 <mdmkolbe> mm_freak: I think that shows a counter example to IO (forall a. Ptr a)
16:57:22 <pjdelport> mofmog: Eq, Ord, Enum, Bounded, Show, Read at least
16:57:45 <mm_freak> @type Foreign.Storable.peek (undefined :: forall a. Ptr a)
16:57:47 <lambdabot> Not in scope: type constructor or class `Ptr'
16:57:54 <mm_freak> @type Foreign.Storable.peek (undefined :: forall a. Foreign.Ptr.Ptr a)
16:57:55 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO a
16:58:13 <mm_freak> @type Foreign.Storable.peek (undefined :: Foreign.Ptr.Ptr (forall a. a))
16:58:14 <lambdabot>     No instance for (Foreign.Storable.Storable (forall a. a))
16:58:14 <lambdabot>       arising from a use of `Foreign.Storable.peek'
16:58:14 <lambdabot>                    at <interactive>:1:0-65
16:58:43 <Philonous> () is even a monad and a comonad
16:58:47 <lilac> mofmog: also, Data, Typeable, Monoid
16:58:57 <lilac> Philonous: kind error!
16:59:00 <mm_freak> Philonous: () can't be a monad
16:59:19 <Philonous> mm_freak: Why not?
16:59:25 <lilac> Philonous: kind error!
16:59:28 <mm_freak> because a monad is of kind * -> *
16:59:28 <mdmkolbe> mm_freak: it is if you put a type-lambda in front of it
16:59:56 <mdmkolbe> e.g. type Unit a = ()
16:59:56 <mm_freak> mdmkolbe: what kind of monad would it be, then?
17:00:13 <mm_freak> that's still not a monad, because it must break monad laws
17:00:14 <mdmkolbe> mm_freak: the monad that does nothing (at all)
17:00:22 <lilac> mm_freak: it obeys monad laws :)
17:00:27 <lilac> trivially
17:00:53 <mdmkolbe> all "Unit a" are equal thus it satisfies the monad laws
17:01:07 <mdmkolbe> it's the domocratic monad ;-)
17:01:18 <lilac> but it's not a comonad
17:01:37 <lilac> since there's no counit other than \_ -> undefined
17:01:41 <mm_freak> what would be the type of 'f' in (return 3 >>= f)?
17:02:00 <mdmkolbe> f :: a -> ()
17:02:04 <lilac> mm_freak: a -> Unit b
17:02:19 <mm_freak> what value would it receive?
17:02:28 <lilac> mm_freak: it would never be called
17:02:34 <mm_freak> ah, indeed
17:02:51 <lilac> () >>= _ = ()
17:03:37 <Philonous> Hmm, right, can't be a comonad.
17:03:40 <mm_freak> interesting, though useless =)
17:03:55 <lilac> there's actually a more useful >>=
17:04:06 <lilac> () >>= f = f `seq` ()
17:04:08 <ddarius> It's not technically a "notion of computation" a la Moggi though
17:04:27 <lilac> still pretty useless though :)
17:04:31 <mm_freak> lilac: what does demanding a function do?
17:04:40 <mdmkolbe> ddarius: it's the "wood block" notion of computation
17:05:03 <dolio> Unit is just a special case of 'newtype Const a b = Const a', too.
17:05:07 <mdmkolbe> mm_freak: lilac is saying there are both strict and lazy versions of this function
17:05:17 <mdmkolbe> @index Const
17:05:18 <lambdabot> bzzt
17:05:23 <mm_freak> interestingly it would be some kind of a black hole for monad transformers
17:05:28 <dolio> Where you get a monad for monoidal a.
17:05:35 <dolio> Er.
17:05:59 <BONUS> UnitT
17:06:00 <BONUS> ahaha
17:06:08 <mm_freak> BONUS: nope, Unit
17:06:09 <vininim> okay, I flashed latest fso and got some magic bitmask error scrolling ad infinitum
17:06:16 <vininim> err wrong channel
17:06:20 <mm_freak> StateT s () ()
17:06:25 <BONUS> yeah
17:06:30 <BONUS> it would be funny to have a UnitT
17:06:32 <BONUS> is what im sayin
17:06:38 <dolio> Yeah, I suppose that may work, although (>>=) still kind of sucks.
17:06:49 <lilac> > let f :: () -> (); f = undefined in f `seq` 42
17:06:50 <dolio> It's a better Applicative, I think.
17:06:51 <lambdabot>   * Exception: Prelude.undefined
17:06:57 <mm_freak> BONUS: it would be just as pointless
17:07:07 <lilac> mm_freak: some functions are _|_
17:07:08 <BONUS> yeah
17:07:16 <mdmkolbe> what would the type of "StateT Int Unit a" be?
17:07:35 <mm_freak> mdmkolbe: StateT Int Unit a
17:07:37 <BONUS> s -> ()
17:07:42 <lilac> mdmkolbe: you mean, runStateT $ ...  ?
17:07:44 <BONUS> would be the inner functions i guess
17:07:51 <mdmkolbe> lilac: yeah
17:08:00 <BONUS> so basically const ()
17:08:27 <mdmkolbe> I'm worries that some combination would give you back the result state without doing the computation (but maybe that only happens if you have a UnitT around)
17:09:33 <mm_freak> maybe an easier example is useful
17:09:44 <mm_freak> IdentityT Unit a
17:09:50 <lilac> as i understand it, the monad laws are generally interpreted to make no guarantees about behaviour in presence of bottoms
17:10:38 <lilac> so the only guarantees about the computation actually being done have to come from the monad itself
17:10:43 <hackage> Uploaded to hackage: haskell-src-exts 0.3.10
17:10:45 <mdmkolbe> ok, yeah.  WriterT w Unit a = () so we are ok, but I don't think you could write a UnitT
17:11:16 <lilac> what's the problem with UnitT?
17:11:16 <mm_freak> you could, but it wouldn't be much different from Unit
17:11:31 <mm_freak> lift _ = ()
17:11:32 <lilac> type UnitT m a = ()
17:11:33 <ddarius> lilac: One can choose differing notions of "=" for doing the monad laws, but there is nothing about bottom that makes the monad laws meaningless.
17:11:42 <dolio> Scratch that, Const a isn't a monad.
17:11:45 <BONUS> UnitT has just one more phantom type
17:11:46 <dolio> Just an applicative.
17:12:08 <ddarius> lilac: The natural choice for "=" is observational equality in which case the monad laws need to hold even with bottom.
17:12:09 <mdmkolbe> lilac: wouldn't the natural UnitT m = m ()?
17:12:24 <lilac> ddarius: sure, but as far as i remember, many common monads aren't, if you consider = to count for bottoms too
17:12:27 <dolio> It's only a monad when all elements are equal to the unit of the monoid (which is () and anything isomorphic to it).
17:12:58 <mdmkolbe> lilac: but then UnitT (Writer w) a = ((), w) which is obviously wrong (you shouldn't be able to get the w out), thus the obvious UnitT is wrong
17:13:57 <BONUS> hmm dunno
17:14:14 <BONUS> UnitT Maybe a ---> Just () or Nothing
17:14:49 <BONUS> looks ok and i think the laws would hold, although someone would have to check
17:15:37 <mdmkolbe> BONUS: that would be very bad.  because how would you evaluate "return 1 >>= \x -> if x == 1 then return 2 else Nothing"
17:16:04 <mm_freak> regarding the definedness partial order, both Just undefined ≥ Nothing and Just undefined ≤ Nothing do _not_ hold, right?
17:16:19 <mdmkolbe> BONUS: note that "x" can not be assigned a value
17:16:26 <ddarius> mm_freak: Correct.
17:16:34 <mm_freak> thanks
17:16:48 <BONUS> hmm i see
17:17:34 <Saizan> return x >>= f = f x can't hold if the result of f can be anything interesting
17:17:39 <mdmkolbe> BONUS: the only escapes I see are either "return == undefined" or "UnitT m a = ()", but I'm not sure if those are legit
17:18:25 <mm_freak> i can picture Just undefined and Nothing on separate 'leaves' of the order 'tree', just above undefined, right?
17:18:25 <ddarius> mdmkolbe: The latter is the "sensible" definition.
17:18:36 <dolio> return = undefined doesn't work.
17:18:49 <dolio> Becuase m >>= return = undefined, then.
17:18:52 <lilac> how about: data BottomMonad a; instance Monad BottomMonad where;
17:19:01 <geezusfreeek> here we go: (>>=) = _|_; return = _|_
17:19:03 <ddarius> mm_freak: Nothing is a leaf, Just undefined would be a node, but yes, they are on different branches from undefined.
17:19:04 <BONUS> hmmm interesting indeed
17:19:04 <dolio> Presumably.
17:19:07 <mdmkolbe> ddarius: aren't there some kind of transformer laws that would prevent such a cop out?
17:19:23 <mm_freak> ddarius: that's what i meant
17:19:24 <lilac> dolio: m >>= return = undefined, but what values can m take?
17:20:02 <dolio> Are we discussing BottomMonad now, or UnitT, still?
17:20:20 <lilac> BottomMonad right now
17:20:22 <ddarius> mdmkolbe: There are laws for transformers, but I don't believe they disallow that.
17:20:25 <dolio> (>>=) = return = undefined is fine for BottomMonad, but not for UnitT.
17:21:15 * mdmkolbe would really like someone to write a bot that tracks and graphs topics on this IRC channel, it would be cool to watch the timelines
17:21:34 <bbs> hey all
17:21:38 <mdmkolbe> hi bbs
17:23:01 <bbs> hows it going :)
17:23:04 <bbs> i'm haskelling
17:23:10 <bbs> i'll prolly have a few q's in a bit
17:24:04 <Saizan> is there a standard command line interface for linkers on the various *nixes? and if so, is calling ld with just an -lfoo flag without any object files allowed in it?
17:25:36 <lilac> i think: data UnitT m a = UnitT m (Unit a) /might/ work. _ >>= _ = return (); return m = UnitT $ return ()
17:25:45 <mdmkolbe> Saizan: ##workingset would be a good place to ask
17:26:54 <lilac> nah, forget that. can't be done?
17:27:07 <dolio> UnitT Nothing >>= return = return () = UnitT (Just ())
17:27:10 <mdmkolbe> lilac: it looks like it b/c all objects would be the same. namely, UnitT (return ())
17:27:58 <mdmkolbe> (at least as far as the monad laws go, I'm not sure about the transformer laws)
17:28:26 <pejo> Is there an example/real cabal package that shows how to run Happy before starting to compile stuff?
17:28:50 <lilac> "(UnitT m) >>= f = UnitT $ m >> return ()" fixes Maybe at least.
17:29:06 <mdmkolbe> pejo: if you just name your source files with .y I think cabal will figure it out (IIRC the happy extention is .y)
17:30:18 <pumpkin_> how do I "maybe pull something out of a maybe" ? :P
17:30:27 <pumpkin_> without using pattern matching
17:30:29 <mdmkolbe> @type maybe
17:30:29 <lilac> @type maybe
17:30:30 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:30:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:30:42 <daf> @type fromMaybe
17:30:43 <lambdabot> forall a. a -> Maybe a -> a
17:30:43 <lilac> @type maybeToList
17:30:44 <lambdabot> forall a. Maybe a -> [a]
17:30:54 <pumpkin_> hmm
17:30:55 <mdmkolbe> > maybe 1 (+2) (Just 3)
17:30:57 <lambdabot>   5
17:31:01 <mdmkolbe> > maybe 1 (+2) Nothing
17:31:02 <dons> dcoutts: just did a simple map toUpper test on bytestrings versus UArr Word8, and UArr Word8 ran 10x faster (0.5s vs 5s...)
17:31:03 <lambdabot>   1
17:31:05 <pumpkin_> what module are those in?
17:31:14 <daf> Data.Maybe
17:31:15 <lilac> Data.Maybe
17:31:20 <dolio> return 5 >>= const (UnitT Nothing) = UnitT (return 5 >> return ()) = UnitT (Just ()) /= UnitT Nothing
17:31:23 <dons> ah, fusion!
17:31:38 <mm_freak> pumpkin_: do { x <- Just 3; return (x+1) }
17:31:42 <pumpkin_> ah
17:31:51 <lilac> @quote glorious
17:31:52 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
17:31:52 <dons> uvector generates good code.
17:32:05 <daf> lilac: :)
17:32:13 <pumpkin_> thanks :)
17:32:16 <mm_freak> (although that uses pattern matching, but just to bind a name to a value)
17:32:55 <mm_freak> > do { x <- Just 3; y <- Just 4; return (x+y) }
17:32:57 <lambdabot>   Just 7
17:33:01 <mm_freak> > do { x <- Just 3; y <- Nothing; return (x+y) }
17:33:03 <lambdabot>   Nothing
17:34:18 <lilac> dolio: ok, i think i can now prove to myself it's not possible :)
17:34:34 <FunctorSalad_> pumpkin_: or fromJust if you're really sure ;)
17:34:40 <dolio> :)
17:34:48 <FunctorSalad_> (it will throw an error if applied to Nothing)
17:34:58 <lilac> return a >>= f must call f, and can't.
17:35:31 <lilac> (because return must throw away the 'a')
17:36:01 <bbs> *Shitzu> foldr (+) [1..10] []
17:36:06 <bbs> > foldr (+) [1..10] []
17:36:07 <lambdabot>       No instance for (Num [t])
17:36:07 <lambdabot>        arising from a use of `+' at <interact...
17:36:16 <bbs> > foldr + [1..10] []
17:36:17 <lambdabot>   Couldn't match expected type `t -> (a -> b -> b) -> b -> [a] -> b'
17:36:20 <lilac> > foldr (+) [1..10] 0
17:36:20 <pumpkin_> FunctorSalad_: thanks :)
17:36:21 <lambdabot>       No instance for (Num [t])
17:36:21 <lambdabot>        arising from a use of `+' at <interact...
17:36:29 <mm_freak> > foldr (+) 0 [1..10]
17:36:30 <lambdabot>   55
17:36:42 <bbs> mm_freak: ah base case comes first
17:36:44 <bbs> derr
17:36:46 <bbs> sry
17:36:52 <lilac> bbs: also, base case is not []
17:36:53 <dolio> Yeah. So you have to ensure that 'return a >>= f' the same thing as 'f a' without using f, which can only work in general if there is only one value of type UnitT m a.
17:36:58 <mm_freak> bbs: yes, but your base case was wrong anyway =)
17:37:05 <bbs> yep
17:37:10 <bbs> thats ok though
17:37:12 <bbs> :)
17:37:14 <bbs> i know why now
17:37:25 <dolio> So UnitT m a = ().
17:37:43 <FunctorSalad_> UnitT? =)
17:38:45 <dolio> Although that's probably still kind of a problem, strictly speaking.
17:39:09 <mm_freak> (i find it amazing how haskell has an gigantic theoretic background)
17:39:39 <dolio> Since if you do '_ >>= _ = ()' then 'return 5 >>= const undefined = () /= undefined'.
17:39:56 <dolio> And even 'm >>= f = m `seq` f `seq` ()' doesn't help.
17:40:27 <dolio> But that's a problem with Unit, too.
17:41:59 <Philonous> > Nothing >>= const undefined
17:42:00 <lambdabot>   Nothing
17:42:59 <dons> mm_freak: programming has a gigantic theoretical background :)
17:43:04 <dons> mostly it is submerged though
17:43:21 <dons> the haskell guys had a look under water and saw how big the rest of the iceberg was
17:43:35 <mm_freak> true
17:45:25 <mm_freak> haskell has already reached a point where a program can calculate something without being ever run…  i wonder how far further theory and practice can be merged
17:46:05 <mdmkolbe> mm_freak: well to be fair, C++ can to that too.  twice even
17:46:24 <mm_freak> mdmkolbe: how?
17:46:40 <mdmkolbe> mm_freak: both the preprocessor and templates are turing complete
17:46:57 <mm_freak> true
17:47:17 <dolio> The preprocessor is? Hmm.
17:47:35 <mdmkolbe> dolio: you have to use #include in order to do your recursion, but yes
17:47:38 <mm_freak> dolio: recursive #incudes
17:47:46 <dolio> Ah, heh.
17:48:37 <mm_freak> the template approach is surely more interesting =)
17:48:57 <mmorrow> a quine with Dynamic:
17:48:59 <mmorrow> (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x))
17:49:05 <mdmkolbe> mm_freak: well, you get boost that way
17:49:15 <mmorrow> where
17:49:29 <mmorrow> f <<$>> x = maybe undefined id (f `dynApply` x)
17:49:48 <mmorrow> , let f <<$>> x = maybe undefined id (f `dynApply` x) ; unDyn = maybe undefined id . fromDynamic ; quine = (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x)) in foldr (.) id (replicate 100000 unDyn) $ quine
17:49:50 <lunabot>  <<Dynamic>>
17:50:01 <mmorrow> 100000 evals of itself :)
17:50:34 <Twey_> I love Haskell documentation
17:50:41 <Twey_> « Haskell provides indexable arrays, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers. »
17:50:49 <mm_freak> well, i wonder what the next giant step is
17:50:59 <mm_freak> probably giving IO a constructor
17:51:34 <dons> Twey: hehe. duh. arrays!
17:52:06 <mm_freak> Twey: think of generalizing "Integer" to "Ix i => i" =)
17:52:20 <dons> :t Data.Array.unsafeFreeze
17:52:21 <lambdabot> Not in scope: `Data.Array.unsafeFreeze'
17:52:22 <Twey> Heh, aye
17:52:24 <dons> :t Data.Array.MArray.unsafeFreeze
17:52:26 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *) (b :: * -> * -> *). (Data.Array.Base.IArray b e, Data.Array.Base.MArray a e m, Ix i) => a i e -> m (b i e)
17:52:41 <dons> a i e -> m (b i e)
17:52:45 <dons> beautiful :)
17:53:20 <Twey> A.K.A. a -> m b?  :-P
17:53:32 <Twey> Oh wait
17:53:36 <Twey> No, not quite
17:53:44 <Twey> Heh
17:53:47 <Twey> Why do both Array and IArray exist?
17:53:58 <mdmkolbe> that looks like what the compile shouts if you doo that: aiiiiiieeeeee  --> 'm bye
17:54:00 <mm_freak> IArray is a class
17:54:04 <Twey> Isn't IArray's functionality a superset of Array's?
17:54:11 <Twey> Haha, mdmkolbe
17:54:37 <Twey> It says: « Note: The Data.Array.IArray module provides a more general interface to immutable arrays: it defines operations with the same names as those defined below, but with more general types, and also defines Array instances of the relevant classes. To use that more general interface, import Data.Array.IArray but not Data.Array. »
17:55:02 <Twey> It seems kind of like a splitAt/generalSplitAt situation
17:55:14 <ddarius> Twey: Data.Array is where H98 Array moved.
17:55:19 <Twey> @hoogle a -> [b] -> ([b], [b])
17:55:20 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
17:55:20 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
17:55:20 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
17:55:30 <Twey> genericSplitAt, even.
17:55:37 <Twey> ddarius: So it's just for compatibility?
17:55:59 <ddarius> I imagine.
17:56:01 <christos_> Is it possible to type in GHCi non-latin characters?
17:56:13 <Twey> I see, thanks :)
17:56:28 <Twey> christos_: Certainly
17:56:56 <mm_freak> > let π = pi in π^2
17:56:58 <lambdabot>   9.869604401089358
17:57:12 <pejo> (Late reply for my cabal question) It only seems to run happy if there's an exposed-modules for that file. Is that necessary? I only want a final binary that uses the Parser.
17:57:17 * Twey can't wait for Haskell' to make UTF-8 the default encoding.
17:57:57 <mm_freak> > let (×) = (*); π = pi; π² = π×π in π²
17:57:59 <lambdabot>   <no location info>: parse error on input `='
17:58:07 <mm_freak> > let × = (*); π = pi; π² = π `×` π in π²
17:58:08 <lambdabot>   <no location info>: parse error on input `×'
17:58:32 <mm_freak> > let π = pi; π² = π*π in π²
17:58:33 <lambdabot>   <no location info>: parse error on input `='
17:59:26 <pumpkin_> I have a utf-8 terminal and my ghci is failing
17:59:29 <pumpkin_> with japanese
17:59:34 <mm_freak> Twey: i'd rather stick with ASCII and let editors display operators as symbols, if the user wants that
18:00:00 <Twey> mm_freak: I'm talking about IO, not language
18:00:07 <mm_freak> oh, ok
18:00:14 <dolio> Is it the latest ghc?
18:00:19 <Twey> (although Unicode operators are cool too)
18:00:37 <dolio> The GHC 6.10 packages use editline for ghci, which doesn't do unicode.
18:01:01 <dolio> The generic linux ones on the ghc page, that is.
18:01:14 <Twey> Hmn.  6.8.2 doesn't mind UTF-8 input.
18:01:25 <dolio> Yeah, 6.8 was still readline.
18:01:40 <Twey> Why did they switch?
18:01:46 <dolio> Licensing.
18:01:55 <Twey> Ah...
18:02:03 <mdmkolbe> Twey: readline is GPL, editline is BSD(?)
18:02:13 <Twey> I guess so.
18:02:30 <Twey> editline seems quite inferior, though.
18:02:38 <Twey> I'm surprised they didn't make their own implementation.
18:02:45 <mm_freak> > let (×) = (*) in 2×2
18:02:47 <lambdabot>   4
18:03:36 <mdmkolbe> (but the social dynamics are such that (1) editline may catch on b/c it's BSD and (2) readline will switch to LGPL if editline starts catching on)
18:03:44 <adu> what kind of license is GHC under?
18:04:16 <dolio> It's mostly BSD/MIT/something-like-that.
18:05:22 <Twey> Is there a fork of GHC 6.10 with a readline GHCi?
18:05:48 <mofmog> dont they all have readline
18:05:50 <dolio> Someone said they compiled it by hand, and it pulled in readline since they didn't have editline.
18:05:58 <Twey> Lack of Unicode is pretty severe for me, although I guess I can just mess about with ghc proper.
18:06:08 <dolio> So it may be just the officially distributed builds that prefer editline.
18:06:17 <Twey> Mm.
18:09:55 <mmorrow> , [| [ 42, $(lift (21 * 2)) ] |]
18:09:58 <lunabot>  ListE [LitE (IntegerL 42),LitE (IntegerL 42)]
18:11:25 <mmorrow> , [ 42, $(lift (21 * 2)) ]
18:11:26 <lunabot>  luna: Ambiguous type variable `t' in the constraints:
18:11:33 <mmorrow> , [ 42, $(lift (21 * (2::Int))) ]
18:11:35 <lunabot>  [42,42]
18:15:26 <BMeph> Twey: I think another reason why editline, is that there's a (supported) port of editline for Windoze^W Microsoft OSes. :)
18:15:37 <dancor> does this exist: mbToEith err mb = case mb of {Just x -> Right x; Nothing -> Left err}
18:16:33 <int-e> :t maybe (Left ?err) Right
18:16:34 <lambdabot> forall a b. (?err::a) => Maybe b -> Either a b
18:16:38 <mmorrow> i'm trying to map TH to scheme (quasi)quotes. there's a small difference i think in when exactly things get eval'ed
18:16:40 <BMeph> dancor: I suspect folks'd just use 'maybe' and 'either' together in some form... :)
18:16:42 <mmorrow> , [| [ 42, $(lift (21 * 2)) ] |]
18:16:45 <lunabot>  ListE [LitE (IntegerL 42),LitE (IntegerL 42)]
18:16:46 <mmorrow> guile> '`(list 42 ,(* 21 2))
18:16:46 <mmorrow> (quasiquote (list 42 (unquote (* 21 2))))
18:17:03 <mmorrow> guile> (quasiquote (list 42 (unquote (* 21 2))))
18:17:03 <mmorrow> (list 42 42)
18:17:17 <mmorrow> , $(return (ListE [LitE (IntegerL 42),LitE (IntegerL 42)]))
18:17:20 <lunabot>  [42,42]
18:17:50 <mofmog> So apparently you a list of fractions is turing complete
18:18:30 <dancor> int-e: sweet
18:18:36 <int-e> :t fromMaybe (Right ?err) . fmap Left
18:18:37 <lambdabot> forall a b. (?err::b) => Maybe a -> Either a b
18:18:49 <dancor> BMeph: well a lot of times i want to promote a Nothing failure to something with context
18:19:17 <bbs> fibs = 0:1:zipWith (+) fibs (tail fibs)
18:19:22 <dancor> BMeph: oh i think i misunderstood you
18:19:27 <bbs> does that make sense for a fibonacci?
18:19:30 <ddarius> :t mplus . fail
18:19:31 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => String -> m a -> m a
18:19:40 <bbs> Cale: oh herro!
18:19:42 <ddarius> :t mplus . Left
18:19:43 <BMeph> So, if your terminal doesn't do UTF-8, can you call if a WTF-8 one? ;p
18:19:43 <lambdabot> forall a a1. (Error a1) => a1 -> Either a1 a -> Either a1 a
18:20:04 <bbs> BMeph: lol
18:20:17 <mmorrow> wtf8Encode
18:20:18 <bbs> BMeph: WTF-1
18:20:36 <BMeph> bbs: WTF-p
18:20:41 <mmorrow> wtf8Encode _ = "WTF!!@"
18:20:49 <mmorrow> ++ "8"
18:20:55 <Twey> Heh
18:21:51 <BMeph> dancor: There are a slew of functions that seem to be "too easy" for the Prelude Masters, and we're all just supposed to fend for ourselves. :\
18:22:24 * BMeph is still bitter about 'swap' being left out of the GHC libraries
18:22:45 <dancor> @pl \ (x, y) -> (y, x)
18:22:45 <lambdabot> uncurry (flip (,))
18:22:47 <mmorrow> @pl \(a,b) -> (b,a)
18:22:47 <lambdabot> uncurry (flip (,))
18:22:49 <mmorrow> heh
18:22:51 <dancor> lol
18:23:03 <dancor> we could even agree on , spacing
18:23:24 <ivanm> BMeph: if you're so bitter, fork ghc with the only change being the inclusion of the swap function!
18:23:28 <ivanm> call it bhc! ;-)
18:23:47 <dancor> have bhci support unicode and ^S as a gnu screen change character
18:23:51 <mmorrow> then tell people you forked it because you wanted to "swap one or two functions in"
18:24:01 <BMeph> ivanm: That's okay, I'm much happier telling GHC to go fork itself... ;p
18:24:03 <ivanm> dancor: I thought ghc-6.12 was going to support unicode...
18:24:20 <mmorrow> and when they ask which functions those are, just stare blankly
18:24:24 <ivanm> lol
18:26:11 <dancor> swap isn't even in missingh
18:26:19 <BMeph> Eh, time to make the trek home - see y'all in an hour. :)
18:27:04 <bbs> can someone talk to me about fibonacci and list comp?
18:27:06 <bbs> fibsl = 0:[n+n | n <- [1..]]
18:27:10 <bbs> i mean thats not right
18:27:23 <ivanm> well, that's just even numbers...
18:27:41 <bbs> ivanm: yea
18:27:42 <bbs> :)
18:27:44 <bbs> i am wrongzo
18:28:02 <bbs> ivanm: its going to be kinda like self-embedding right?
18:28:10 <bbs> ivanm: more like how you would derive primes
18:28:15 <ivanm> ummmmmm..... not really...
18:28:17 <mm_freak> > map fst $ iterate (\(a,b) -> (b, a+b)) (0,1)
18:28:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:28:23 <ivanm> oh, wait, yeah, I see what you mean
18:28:41 <ivanm> mm_freak: hmmmm..... that's almost as nice as the zipWith method...
18:28:50 <mm_freak> the zipWith method?
18:29:18 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
18:29:19 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:29:28 <bbs> ivanm: i already wrote that one :)
18:29:36 * ivanm belongs to the "fibonacci starts with 1" camp
18:29:37 <ivanm> ;-)
18:29:43 <mm_freak> ah, although i find the iterate method more comprehensible
18:29:50 <bbs> i just didn't know how to do it with list comprehension
18:29:59 <bbs> ivanm: fibs = 0:1:zipWith (+) fibs (tail fibs)
18:30:01 <bbs> ;)
18:30:05 <mm_freak> bbs: you don't want to use list comprehension for that
18:30:18 <ivanm> > let fib 1 = 1; fib 2 = 1; fib n = (fib (n-1)) + (fib (n-2)) in fib 20
18:30:19 <lambdabot>   6765
18:30:36 <pumpkin_> eww, no
18:30:44 <bbs> mm_freak: i HAVE to use it for that
18:30:54 <ivanm> bbs: take mm_freak's method
18:31:04 <ivanm> no, I take it back
18:31:06 <bbs> ivanm: thats how i started it
18:31:10 <bbs> i have to do it w/ list comp
18:31:14 <bbs> i already did it the other way
18:31:18 <bbs> thats what i'm saying lol
18:31:24 <bbs> so it doesn't matter since i'm doing a fib and fibl
18:31:26 <bbs> saavy?
18:31:47 <bbs> like say
18:31:49 <bbs> for primes
18:32:11 <ivanm> > let fibs = (1,1) : [(f,f+fn) | (fn,f) <- fibs ] in map fst fibs
18:32:12 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:32:19 <ivanm> bbs: ^^
18:32:24 <mmorrow> , let nfib n = (let fib m n = m : fib n (m+n) in fib 0 1) !! n in nfib 10000
18:32:25 <lunabot>  3364476487643178326662161200510754331030214846068006390656476997468008144...
18:32:41 <mmorrow> , let fib m n = m : fib n (m+n) in fib 0 1
18:32:43 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:33:09 <mmorrow> , fix ((0:) . scanl (+) 1)
18:33:11 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:33:29 <byorgey> oh good, I was wondering why no one had done the fix version yet =)
18:33:36 <ksf> > let fibs = 0:1:[n+m | n <- fibs, m <- tail fibs]
18:33:38 <lambdabot>   <no location info>: parse error on input `;'
18:33:42 <ksf> > let fibs = 0:1:[n+m | n <- fibs, m <- tail fibs] in fibs
18:33:43 <lambdabot>   [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:33:44 <mmorrow> , fix (\next m n -> m : next n (m+n)) 0 1
18:33:44 <ivanm> byorgey: because no-one could remember it? ;-)
18:33:46 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:33:47 <ksf> darn.
18:33:59 <ivanm> ksf: that fails because it does every element in fibs with every element in tail fibs
18:34:00 <bbs> http://hpaste.org/11947
18:34:02 <byorgey> ivanm: oh, come on, it is self-evident ;)
18:34:22 <ivanm> byorgey: maybe for people who regularly use fix...
18:34:30 * ivanm still marvels at how fix can find a value
18:34:45 <mmorrow> , fix (\k x -> x) 42
18:34:48 <lunabot>  42
18:34:51 <bbs> lol
18:34:55 <ivanm> bbs: interesting module name...
18:34:57 <mmorrow> , fix (\k x -> x : k x) 42
18:34:59 <lunabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
18:35:08 <bbs> ivanm: :D
18:35:12 <bbs> what can i say
18:35:16 <bbs> just saw some family guy
18:35:17 <mmorrow> , fix (\k x -> x : take 4 (k x)) 42
18:35:19 <lunabot>  [42,42,42,42,42]
18:35:39 <byorgey> , let you = \f n -> if n == 0 then 1 else n * f (n-1); good = 5  in  fix you good
18:35:40 <ivanm> bbs: I take it Seq is your own custom list structure?
18:35:41 <lunabot>  120
18:35:53 <bbs> ivanm: *nod*
18:35:53 <mmorrow> , fix (\xs -> [0, 42, xs!!1, xs!!0])
18:35:55 <lunabot>  [0,42,42,0]
18:35:55 <gwern> 'I am one step further in solving my failing tests using the haskell
18:35:57 <gwern> shell harness script, and one step closer to madness.'
18:36:04 <bbs> ivanm: this teacher can be a small painzo but we learn a shitload
18:37:02 <bbs> ivanm: its about lazy-evaluation
18:37:03 <bbs> :)
18:37:13 <byorgey> , fix (\xs -> [1, xs!!0 + 2, xs!!3, xs!!0 + xs!!4, length xs])
18:37:15 <lunabot>  [1,3,6,6,5]
18:37:17 <ivanm> bbs: ummm.... doesn't Haskell do that already?
18:37:29 <ksf> one thing is for sure: list comprehensions aren't made for it.
18:37:50 <ivanm> ksf: for what?
18:38:02 <adu> bbs: DEATH?
18:38:06 <ksf> in the end, everything.
18:38:32 <ksf> but fibs in peculiar. zips, i mean.
18:38:37 <bbs> ivanm: yes it does
18:38:43 <mm_freak> > fix (\k x y -> x : k y (x+y)) 0 1
18:38:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:38:45 <ivanm> adu: he explained that already
18:38:59 <bbs> ivanm: thats why this teacher is annoying as crap sometimes
18:39:09 <mm_freak> the most obvious solution, considering that haskell is a lambda language =P
18:39:11 <bbs> i *hate* programming stuff thats already done
18:39:15 <ivanm> ksf: well, IIRC list comprehensions get de-sugared to do-notation
18:39:16 <bbs> mm_freak: it *is*
18:39:18 <bbs> isn't it?
18:39:21 <ivanm> or is it the other way round? *shrug*
18:39:26 <mmorrow> , (\xs -> fix (\endresult -> (xs, (fst endresult) !! 2))) "asdf"
18:39:28 <lunabot>  ("asdf",'d')
18:39:43 <ksf> well thinking in concatMap isn't really straightforward...
18:39:55 <pjdelport> > [(x,y) | x <- [1..5] | y <- "hello"]
18:39:56 <lambdabot>   [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
18:40:02 <pjdelport> yay for parallel comprehensions
18:40:17 <mm_freak> ksf: concatMap can be pictured as mapping a non-deterministic function
18:40:22 <ivanm> pjdelport: oh, I was wondering what parallel comprehensions were for...
18:40:31 <pjdelport> zipping :)
18:40:34 <ivanm> I take it that's equivalent to having a list comp of a list comp?
18:40:38 <ivanm> pjdelport: heh
18:40:49 <pjdelport> that's the equivalent of zipWith*
18:40:58 <mm_freak> > let nsqrt x = [sqrt x, -sqrt x] in concatMap nsqrt [1,2,3,4]
18:40:58 <adu> ivanm: what was the explaination?
18:41:00 <lambdabot>   [1.0,-1.0,1.4142135623730951,-1.4142135623730951,1.7320508075688772,-1.7320...
18:41:03 <mmorrow> , [ (x,y,z) | x <- [1..5] | y <- "hello" | z <- [1000..] ]
18:41:05 <lunabot>  [(1,'h',1000),(2,'e',1001),(3,'l',1002),(4,'l',1003),(5,'o',1004)]
18:41:07 <ivanm> adu: he was watching Family Guy
18:41:19 <ivanm> since I don't watch that show, I don't know what that's meant to mean *shrug*
18:41:21 <adu> ivanm: so what's the explaination?
18:41:34 <ivanm> adu: I just said what it was! ;-)
18:41:48 <ksf> > let fibs = 0:1:[fibs!!n + fibs !!m |  n <- [1..] in fibs
18:41:48 <adu> ivanm: how does that explain "DEATH"?
18:41:49 <lambdabot>   <no location info>: parse error on input `in'
18:41:53 <ksf> > let fibs = 0:1:[fibs!!n + fibs !!m |  n <- [1..]] in fibs
18:41:55 <lambdabot>   Couldn't match expected type `Int' against inferred type `Expr'
18:42:00 <ivanm> adu: <ivanm> since I don't watch that show, I don't know what that's meant to mean *shrug*
18:42:00 <ksf> wut?
18:42:13 <adu> bbs: why DEATH?
18:42:27 <ivanm> adu: because he saved it in DEATH.hs? ;-)
18:42:27 <ksf> > let fibs = 0:1:[fibs!!n + fibs !!(n+1) |  n <- [1..]] in fibs
18:42:29 <byorgey> hm, the discussion seems particularly confused tonight =)
18:42:42 <lambdabot>   thread killed
18:42:49 <ivanm> byorgey: as opposed to when? ;P
18:42:51 <ksf> > let fibs = 0:1:[fibs!!n + fibs !!(n+1) |  n <- [1..]] in take 10 fibs
18:42:58 * byorgey releases LAMBDA-WEASELS to help calm everyone down
18:43:06 <adu> byorgey: did you see my hello world yesterday?
18:43:07 <lambdabot>   thread killed
18:43:07 <mm_freak> @pl \k x y -> x : k y (x+y)
18:43:08 <lambdabot> liftM2 (.) (:) . (. (+)) . ap
18:43:13 <ksf> > let fibs = 0:1:[fibs!!n + fibs !!(n+1) |  n <- [1..]] in take 3 fibs
18:43:18 <byorgey> adu: no
18:43:23 <ivanm> byorgey: I'm sorry, but weasels are illegal here...
18:43:26 <mmorrow> > let fibs = 0:1:[fibs!!n + fibs !!(n+1) |  n <- [0..]] in fibs
18:43:26 <mm_freak> fix (liftM2 (.) (:) . (. (+)) . ap) 0 1
18:43:30 * ivanm claps byorgey in the Jail monad
18:43:32 <mm_freak> > fix (liftM2 (.) (:) . (. (+)) . ap) 0 1
18:43:35 <lambdabot>   thread killed
18:43:39 <byorgey> ivanm: I know, which is why I used LAMBDA-weasels.
18:43:47 <mm_freak> > fix (liftM2 (.) (:) . (. (+)) . ap) 0 1
18:43:47 <bbs> adu: buecause i watned it to be
18:43:48 <bbs> thats all
18:43:50 <ivanm> oh, and that makes a difference, does it?
18:43:58 <byorgey> help! i iz trapd in Jail monad!
18:44:06 <ivanm> how do LAMBDA-weasels differ from standard weasels?
18:44:18 <ivanm> byorgey: freedom :: Jail a -> IO ()
18:44:19 <byorgey> well, for one, they are more lambda-ish
18:44:24 <ivanm> lol
18:44:50 * byorgey unsafePerformIO . freedom's his way out
18:44:57 <mmorrow> lambdabot might just have been incapacitated
18:45:38 <lambdabot>   thread killed
18:45:42 <mmorrow> ah there
18:46:07 <adu> > "Hello"
18:46:24 <mmorrow> > HAI CAN HAS STDIO?
18:46:51 <mm_freak> , fix (liftM2 (.) (:) . (. (+)) . ap) 0 1
18:46:53 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:46:58 <byorgey> ooooooh
18:47:15 <byorgey> shiny
18:47:26 <mmorrow> purdy
18:47:39 <mmorrow> , let fibs = 0:1:[fibs!!n + fibs !!(n+1) |  n <- [0..]] in fibs
18:47:41 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:47:41 <bbs> ivanm: ping
18:47:44 <bbs> fibsl2 = sieve [1..] where sieve(fib:rest) = fibs : sieve [r | r <- rest]
18:47:50 <bbs> can i do something like this
18:47:57 <bbs> for fib list comprehension?
18:48:00 <mmorrow> , fibsl2 = sieve [1..] where sieve(fib:rest) = fibs : sieve [r | r <- rest]
18:48:02 <lunabot>  luna: parse error on input `='
18:48:09 <mmorrow> , let fibsl2 = sieve [1..] where sieve(fib:rest) = fibs : sieve [r | r <- rest] in fibs12
18:48:11 <lunabot>  luna: Not in scope: `fibs'
18:48:12 <mm_freak> bbs: [ r | r <- rest ] = rest
18:48:20 <bbs> mm_freak: yea
18:48:21 <bbs> thats bad
18:48:32 <byorgey> bbs: that looks like it's just equal to [1..]
18:48:35 <bbs> i need to fiugre out how to make that a fscking fibonacchier
18:48:41 <bbs> byorgey: it might be :)
18:48:57 <ksf> what's the difference in > and ,?
18:49:12 <mm_freak> ksf: '>' is for lambdabot, ',' is for lunabot
18:49:39 <lambdabot>   thread killed
18:49:39 <lambdabot>   thread killed
18:49:39 <lambdabot>   thread killed
18:49:44 <mm_freak> > "guten morgen"
18:49:44 <ksf> ...what i actually wanted to know is why lambdabot killed the list comprehension and lunabot didn't.
18:49:45 <mmorrow> speak of the devil
18:50:07 <adu> ,type "Helllo"
18:50:09 <lunabot>  luna: parse error on input `type'
18:50:11 <mmorrow> ksf: i changed the starting index to 0 from 1
18:50:21 <adu> ,help
18:50:23 <lunabot>  luna: Not in scope: `help'
18:50:24 <mmorrow> , typeOf "Helllo"
18:50:26 <lunabot>  [Char]
18:50:36 <mmorrow> , src ''Monad
18:50:38 <adu> , import Data.Bits
18:50:45 <lunabot>  class Monad m where
18:50:45 <lunabot>          (>>=) :: forall b a . m a -> (a -> m b) -> m b
18:50:45 <lunabot>          (>>) :: forall b a . m a -> m b -> m b
18:50:46 <lunabot>  luna: parse error on input `import'
18:50:50 <ksf> yeah but that didn't help with lamdabot.
18:50:58 <ksf> > let fibs = 0:1:[fibs!!n + fibs !!(n+1) |  n <- [0..]] in fibs
18:51:05 <ksf> , let fibs = 0:1:[fibs!!n + fibs !!(n+1) |  n <- [0..]] in fibs
18:51:08 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:51:12 <mmorrow> ksf: i think lambdabot's puking her guts out right now
18:51:14 <adu> , typeOf Data.Bits..|.
18:51:17 <lunabot>  luna: Not in scope: `Data.Bits..|.'
18:51:24 <mmorrow> (too much moonshine or something)
18:51:28 <sbahra> She's so abused.
18:51:47 <mmorrow> pauvre lambdabot
18:52:24 * ksf decides that not knowing where !! starts its indices can be seen as a sign of leetness.
18:53:14 <mmorrow> ksf: by starting with 1 instead of zero, the first go-round you were trying to access a value in the list that didn't yet exist
18:53:27 <lambdabot>   thread killed
18:53:31 <mmorrow> so that computation depended on its result
18:53:33 <ksf> I thought they started at 1...
18:53:38 <mmorrow> and looped forever
18:53:46 <mmorrow> , [0..] !! 0
18:53:48 <lunabot>  0
18:54:15 <ksf> has been ages since i last used it.
18:54:19 <mmorrow> heh
18:55:11 <bbs> , fibs = unfoldr (\(a,b) -> Just (a,(b,a+b))) (0,1)
18:55:13 <lunabot>  luna: parse error on input `='
18:55:24 <bbs> whoa that would have been bad.
18:55:48 <mmorrow> , unfoldr (\(a,b) -> Just (a,(b,a+b))) (0,1)
18:55:49 <bbs> lazy.hs:55:9: Not in scope: `unfoldr'
18:55:50 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:55:52 <bbs> how can that be?
18:56:06 <mmorrow> import Data.List?
18:56:13 <bbs> nopskies
18:56:15 <bbs> thx
18:56:54 <mmorrow> preflex: seen lispy
18:56:54 <preflex>  lispy was last seen on #haskell 17 hours and 9 seconds ago, saying: oh, heh just zombie muevals
18:57:25 <adu> lispy: are you here?
18:57:51 <ksf> , let fibs = 0:1:[(\(a:b:_ -> a + b ) fibs!!n |  n <- [0..]] in fibs
18:57:53 <lunabot>  luna: Parse error in pattern
18:58:03 <ksf> , let fibs = 0:1:[(\(a:b:_) -> a + b ) fibs!!n |  n <- [0..]] in fibs
18:58:03 <sutats> Design question: if I have a maze that I would normally store in a 2-dimensional array, what should I use to store it in Haskell?
18:58:05 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = [a]
18:58:21 <mmorrow> interesting idea
18:58:28 <ksf> , let fibs = 0:1:[(\(a:b:_) -> a + b ) drop n fibs |  n <- [0..]] in fibs
18:58:28 <adu> stalker_: [[cell]]
18:58:29 <lunabot>  luna: Couldn't match expected type `[t1 -> t2 -> t]'
18:58:30 <pjdelport> sutats: a 2-dimensional array?
18:58:36 <ksf> waaagh
18:58:41 <ksf> that's why i don't do such stuff.
18:58:45 <FunctorSalad_> sutats: Map (Int,Int) MazeSquare -- that would be one way
18:58:54 <pjdelport> sutats: or whatever is more convenient
18:59:03 <sutats> pjdelport: Basically, width by height.
18:59:10 <adu> , 6 .|. 3
18:59:12 <lunabot>  luna: Not in scope: `.|.'
18:59:18 <pjdelport> sutats: no, i mean in Haskell
18:59:23 <adu> , 6 Data.Bits..|. 3
18:59:25 <lunabot>  luna: Not in scope: `Data.Bits..|.'
18:59:25 <mmorrow> adu: one sec
18:59:30 <ksf> , let fibs = 0:1:[(\(a:b:_) -> a + b ) (drop n fibs) |  n <- [0..]] in fibs
18:59:33 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:59:41 <sutats> pjdelport: Oh, I thought arrays in Haskell were a tad more complicated to work with.
18:59:47 <ksf> that's at least half-way efficient.
18:59:48 <sutats> pjdelport: So I was looking for alternatives.
18:59:57 <FunctorSalad_> sutats: that was my thinking too =)
19:00:39 <FunctorSalad_> the Map will be a bit inefficient if the maze is dense, on the other hand you'd save some stuff for sparse mazes
19:00:40 <pjdelport> well, Haskell arrays are pretty powerful
19:00:50 <pjdelport> not unnecessarily complicated, i think
19:01:03 <FunctorSalad_> pjdelport: not saying they are, I just haven't used them yet
19:01:17 <mmorrow> , 6 .|. (3::Int)
19:01:18 <lunabot>  7
19:01:22 <FunctorSalad_> pjdelport: for non-innerloop stuff Map Int x always seemed fine
19:01:31 <ivanm> bbs: I don't think fibonacci works that way ;-)
19:01:31 <sutats> Yeah, I haven't really used them either.
19:01:34 <mmorrow> adu: Data.Bits added
19:01:39 <ivanm> it's not a sieve-based series
19:01:41 <lambdabot>   thread killed
19:01:41 <lambdabot>   mueval: Prelude.read: no parse
19:01:44 <adu> , 6 .|. 3
19:01:47 <lunabot>  luna: Ambiguous type variable `t' in the constraint:
19:01:53 <sutats> FunctorSalad_: These mazes will tend to be small (probably around 20x20 max).
19:01:55 <mmorrow> , 6 .|. (3::Int)
19:01:56 <lunabot>  7
19:01:57 <pjdelport> FunctorSalad_: yeah; i meant to sutats :)
19:01:58 <adu> , 6 .|. 3 :: Int
19:02:00 <lunabot>  7
19:02:04 <adu> yey!
19:02:14 <mmorrow> yippee!!
19:02:26 <adu> , let uncat3 [] = [] ; uncat3 xs = (let (ys, zs) = splitAt 3 xs in ys : uncat3 zs) ; getFrom x y = map (x !!) $ map (fromIntegral . ((\x -> fromIntegral $ foldl (.|.) (0::Word8) (zipWith (\c n -> if c then bit n else (0::Word8)) x [0..2])) :: [Bool] -> Int)) $ reverse . uncat3 . reverse . concat . map (((\x -> map (testBit x) [7,6..0]) :: Word8 -> [Bool]) . fromIntegral . ord) $ y in getFrom " HWdelor" "e\184-\235"
19:02:28 <lunabot>  "Hello World"
19:02:32 <adu> :)
19:02:33 <mmorrow> hahah
19:02:39 <FunctorSalad_> sutats: then the Map solution may be easiest, dunno
19:02:55 <pjdelport> arrays give you stuff like bounds, and so on
19:03:02 <pjdelport> which might make things more convenient
19:03:07 <pjdelport> depending on what you want to do
19:03:22 <FunctorSalad_> otoh for some games you actually want an potentially-infinite board :)
19:03:39 <mmorrow> , let reach f a = let preT (Node x xs) = x : preF xs ; preF = (preT=<<) ;  grow f a = Node a (fmap (grow f) (f a)) ; dfs f = chop . fmap (grow f);chop = (let go _ [] k = k [] ; go xs (Node y ys:zs) k = if y`elem`xs then go xs zs k else go (y:xs) ys (\r ->Node y r:go (y:xs) zs k) in flip (go []) id) in nub (preF (dfs f [a])) in nub (reach (maybe [] id . flip lookup [(0,[1,2]),(1,[4,0])]) =<< [0,1])
19:03:41 <lunabot>  [4,1,2,0]
19:03:43 <mmorrow> :)
19:03:56 <FunctorSalad_> pjdelport: for finite boards you could have Map MyFiniteIndexType MazeSquare
19:03:57 <sutats> pjdelport: Hm...I think I'm dealing with finite (particularly small) mazes. And I'll want to be able to write algorithms to solve the maze in whichever form.
19:04:13 <pjdelport> FunctorSalad_: yes, but you might also need to keep track of the bounds separately
19:04:23 <pjdelport> FunctorSalad_: if you say want to write functions generic over board sizes
19:04:39 <FunctorSalad_> *nod*
19:04:52 <pjdelport> maze solving sounds like exactly such a case :)
19:05:02 <bbs> adu: LULZ!
19:05:07 <bbs> thats like xmas.c
19:05:07 <bbs> :)
19:05:08 <sutats> pjdelport: Yeah, the algorithms will have to be generic.
19:05:13 <bbs> by anon
19:05:35 <FunctorSalad_> pjdelport: you could do the board size in the type system ;)
19:05:43 <sutats> pjdelport: Would you need to keep track of bounds though?
19:05:53 <sutats> pjdelport: Assuming you're given a start coordinate and a closed maze?
19:06:08 <pjdelport> sutats: if you just have a Map with no other info
19:06:17 <pjdelport> sutats: how do you know what indexes to start using? :)
19:06:20 <FunctorSalad_> so the type "Board (S (S (S (S ... ()))))" would have n inhabitants
19:06:28 <sutats> pjdelport: Hah, good point.
19:06:37 <pjdelport> sutats: arrays give you that
19:06:54 <pjdelport> sutats: they also mean you don't have to worry about "holes" left in the map
19:06:59 <pjdelport> (due to a bug, say)
19:07:13 <FunctorSalad_> array elements are always initialized?
19:07:44 <sutats> That's true.
19:07:51 <sutats> Maps look less ideal now.
19:08:08 <mm_freak> > evalState (fix (\k -> get >>= \(x,y) -> put (y, x+y) >> k >>= \xs -> return (x:xs))) (0,1)
19:08:11 <FunctorSalad_> sutats: unless you use an appropriate index type rather than (Int,Int)
19:08:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:08:23 <pjdelport> FunctorSalad_: not necessarily initialized
19:08:28 <pjdelport> but the indexes are always defined
19:08:38 <sutats> FunctorSalad_: Such as?
19:08:45 <ksf> we're still missing a fibs version that mentions neither 0, 1 nor (+)
19:09:08 <FunctorSalad_> sutats: in your case, a type with 400 inhabitants
19:09:18 <pjdelport> ksf: Monoid!
19:09:46 <pjdelport> sutats: so arrays are probably the easy fit
19:10:01 <FunctorSalad_> sutats: it involves a bit of typesystem trickery to do it for arbitrary n
19:10:20 <sutats> FunctorSalad_: Yeah, I think pjdelport is right. Arrays might be the best fit.
19:10:23 <FunctorSalad_> yes, arrays would be easier
19:10:25 <pjdelport> sutats: they're not too much different to use than Map, overall
19:10:40 <pjdelport> sutats: if you wanted to investigate an alternative, it might be something in Graph :)
19:10:41 <sutats> pjdelport: Would you happen to know a site that explains them well?
19:10:43 <hackage> Uploaded to hackage: gitit 0.2.2
19:11:02 <sutats> pjdelport: Haha, I think arrays fits my particular use case better than graphs.
19:11:09 <pjdelport> sutats: hmm, i don't, especially
19:11:21 <pjdelport> :t array
19:11:23 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
19:11:44 <pjdelport> that's the basic constructor
19:11:48 <pjdelport> bounds, and initial values
19:13:44 <sutats> array (width, height) [(0,0)]?
19:13:48 <pjdelport> > array ((0,0),(5,5)) [((x,y),x*y) | x <- [0..5], y <- [0..5]]
19:13:49 <lambdabot>   array ((0,0),(5,5)) [((0,0),0),((0,1),0),((0,2),0),((0,3),0),((0,4),0),((0,...
19:14:13 <pjdelport> sutats: nah, arrays use a generic type for the index
19:14:25 <pjdelport> in this case, a 2-tuple
19:14:26 <FunctorSalad_> ksf: I like the one on the webpage where you take the iteration matrix [(0,1),(1,1)] and notice that the algebra generated by that matrix is just two-dimensional
19:14:50 <pjdelport> sutats: so you give the lowest corner and the highest corner
19:15:34 <pjdelport> sutats: so array (0,5) would make a 1D array of length five
19:15:49 <mm_freak> > map length $ evalState (fix (\k -> get >>= \(x,y) -> put (y, x ++ y) >> k >>= \xs -> return (x:xs))) ([], [()])
19:15:59 <pjdelport> err, length 6, actually
19:16:19 <ksf> , fix ((0 :) . (1 :) . return . (<- [0..]) . (| n) . ap ((`ap` tail) . (. head) . (const .) . (+) . head) tail . drop n)
19:16:21 <lunabot>  luna: parse error on input `<-'
19:16:24 <mmorrow> , array ((0,0),(5,5)) [((x,y),x*y) | x <- [0..5], y <- [0..5]]
19:16:26 <lunabot>  luna: Couldn't match expected type `Control.Comonad.Pointer.Pointer i a'
19:16:27 <ksf> hey!
19:16:28 <mm_freak> > "ping"
19:16:32 <lambdabot>   "ping"
19:16:41 <mm_freak> , map length $ evalState (fix (\k -> get >>= \(x,y) -> put (y, x ++ y) >> k >>= \xs -> return (x:xs))) ([], [()])
19:16:44 <lunabot>  luna: out of memory (requested 1048576 bytes)
19:16:55 <mm_freak> lol
19:16:58 <mm_freak> , take 10 $ map length $ evalState (fix (\k -> get >>= \(x,y) -> put (y, x ++ y) >> k >>= \xs -> return (x:xs))) ([], [()])
19:17:01 <lunabot>  [0,1,1,2,3,5,8,13,21,34]
19:17:09 <mmorrow> , let f xs = listArray (0,length xs-1) xs in f [((x,y),x*y) | x <- [0..5], y <- [0..5]]
19:17:10 <lunabot>  luna: Not in scope: `listArray'
19:17:49 <EvilTerran> ?type listArray
19:17:51 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
19:18:37 <pjdelport> sutats: following?
19:19:37 <pjdelport> sutats: so for the 2D case, you give the actual 2D tuple as the lower bound, and another as the upper bound
19:19:42 <pjdelport> and end up with a square
19:20:00 <pjdelport> sutats: same for a 3D array, or whatever else you care to index
19:20:14 <mmorrow> , let f xs = listArray (0,length xs-1) xs in f [((x,y),x*y) | x <- [0..5], y <- [0..5]]
19:20:16 <lunabot>  luna: No instance for (Data.Array.Base.IArray a ((t, t), t))
19:20:25 <mmorrow> sigh
19:20:39 <pjdelport> sutats: you can even do stuff like: array (('A',1),('H',8))
19:20:56 <mmorrow> , src ''Pointer
19:21:00 <pjdelport> to give you an 8x8 chessboard, indexed from A1 to H8
19:21:01 <lunabot>  data Pointer i a = Pointer {index :: i, array :: (Array i a)}
19:21:21 <mmorrow> Control.Comonad.Pointer is getting the chop
19:23:00 <adu> i got another one :)
19:23:04 <mmorrow> , array ((0,0),(5,5)) [((x,y),x*y) | x <- [0..5], y <- [0..5]]
19:23:06 <lunabot>  luna: No instance for (GHC.Show.Show (a (t, t) t))
19:23:11 <mmorrow> gah
19:23:21 <adu> , let z=(0::Word8); u [] = []; u xs = (let (ys,zs) = splitAt 4 xs in ys : u zs); getFrom x y = map(x !!) $ map(fromIntegral.((\x -> fromIntegral $ foldl(.|.) z (zipWith(\c n -> if c then bit n else z) x [0..3])) :: [Bool] -> Int)) $ reverse.u.reverse.concat.map(((\x-> map (testBit x) [7,6..0]) :: Word8 -> [Bool]).fromIntegral.ord) $ y in getFrom " .abeglnorstuy" "&`\216\201\ETX*@\DC1\DLE)@4hu\v\128\202\SOH\DC1"
19:23:23 <mmorrow> , array ((0,0),(5,5)) [((x,y),x*y) | x <- [0..5], y <- [0..5::Int]]
19:23:23 <lunabot>  "all your base ... are belong to us ..."
19:23:25 <lunabot>  luna: No instance for (Data.Array.Base.IArray a GHC.Types.Int)
19:23:28 <mmorrow> haha
19:23:29 <sutats> pjdelport: Hm, thanks, that's pretty interesting.
19:23:42 <mmorrow> , array ((0,0),(5,5::Int)) [((x,y),x*y) | x <- [0..5], y <- [0..5::Int]]
19:23:44 <lunabot>  luna: No instance for (Data.Array.Base.IArray a GHC.Types.Int)
19:24:14 <pjdelport> sutats: that example just now gives a multiplication table, by the way
19:24:30 <mmorrow> @type array ((0,0),(5,5)) [((x,y),x*y) | x <- [0..5], y <- [0..5]]
19:24:31 <lambdabot> forall t. (Ix t, Enum t, Num t) => Array (t, t) t
19:24:44 <mmorrow> , array ((0,0),(5,5)) [((x,y),x*y) | x <- [0..5], y <- [0..5]] :: Array (Int,Int) Int
19:24:46 <sutats> pjdelport: Yeah, I managed to understand that.
19:24:47 <lunabot>  array ((0,0),(5,5)) [((0,0),0),((0,1),0),((0,2),0),((0,3),0),((0,4),0),((...
19:24:50 <mmorrow> victory!
19:25:04 <pjdelport> sutats: cool
19:25:11 <mmorrow> adu: lol
19:25:27 <mmorrow> , let ppGraph xs = let (<+>) = (Text.PrettyPrint.HughesPJ.<+>) ; ppEdge (x,xs) = let dQText = doubleQuotes . text in (dQText . show) x <+> text "->" <+> (braces . hcat . punctuate comma . fmap (dQText . show) $ xs) in (text "digraph g" <+> text "{") $+$ nest 2 (vcat . fmap ppEdge $ xs) $+$ text "}" in ppGraph [(0,[1,2]),(1,[4,0])]
19:25:29 <lunabot>  digraph g {
19:25:29 <lunabot>    "0" -> {"1","2"}
19:25:29 <lunabot>    "1" -> {"4","0"}
19:25:33 <sutats> pjdelport: I don't know why I thought arrays were so difficult. Your example makes sense.
19:25:38 <mmorrow> err, one line got chopped off
19:25:44 <mmorrow> (lunabot shows 3 max)
19:26:00 <pjdelport> sutats: maybe the type signature scares people off :)
19:26:21 <sutats> pjdelport: I think that's what it was for me.
19:26:44 <pjdelport> sutats: i just read the function descriptions
19:27:19 <pjdelport> the type makes sense once you realize what's actually what
19:27:27 <pjdelport> but even then, you can mostly just overlook it
19:27:34 <pjdelport> and just think in terms of indexes and bounds
19:27:44 <sutats> pjdelport: Yeah, it took some examples for me to see what meant what.
19:29:05 <pjdelport> sutats: the Ix index class is a pretty nice thing about arrays
19:29:17 <pjdelport> that's the other thing you get over maps
19:29:30 <pjdelport> @src Ix
19:29:30 <lambdabot> class (Ord a) => Ix a where
19:29:31 <lambdabot>     range           :: (a,a) -> [a]
19:29:31 <lambdabot>     index           :: (a,a) -> a -> Int
19:29:31 <lambdabot>     inRange         :: (a,a) -> a -> Bool
19:29:31 <lambdabot>     rangeSize       :: (a,a) -> Int
19:29:33 <sutats> pjdelport: Ix = index?
19:29:37 <pjdelport> right
19:29:47 <pjdelport> yay obscure shortenings :)
19:30:25 <sutats> pjdelport: That also made it a bit difficult to understand at first.
19:30:25 <pjdelport> @instances Ix
19:30:26 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
19:30:49 <dolio> Ix is nicer than Ord?
19:32:06 <pjdelport> dolio: more general
19:32:14 <mmorrow> , src ''Ix
19:32:20 <lunabot>  class (Ord a) => Ix a where
19:32:20 <lunabot>          range :: (a, a) -> [a]
19:32:20 <lunabot>          index :: (a, a) -> a -> Int
19:32:29 <shapr> @seen taral
19:32:29 <lambdabot> I saw taral leaving #haskell 27d 23h 50m 50s ago, and .
19:32:32 <shapr> bah
19:32:34 <mmorrow> i should allow more than 3 lines
19:32:37 <dolio> mmorrow: How do you get luna to do types?
19:32:40 <mmorrow> lambdabot does it
19:33:13 <mmorrow> dolio: src uses TH reify, then cleans the returned Info up then prettyprints it
19:33:28 <dolio> I was looking more for an example.
19:33:34 <mmorrow> src should really be called :info
19:33:51 <mmorrow> dolio: cool. one sec
19:33:57 <dolio> like , type [| foo |] or something.
19:34:15 <dolio> Since your bot has stuff you can't ask lambdabot for @type.
19:34:33 <mmorrow> oh, hmm. i wanna do something like that, but i'm not sure exactly how to do it yet
19:34:43 <dolio> Ah. :)
19:34:55 <mmorrow> i could use the ghc-api and get it for free i guess
19:35:12 <mmorrow> (since luna(bot) already has functions to do that)
19:35:25 <mmorrow> dolio: what ghc version are you using?
19:35:37 <dolio> I've got 6.10.1 now.
19:36:10 <dolio> , src ''Natural
19:36:14 <lunabot>  type Natural f g = (:~>) f g
19:36:27 <adu> , let z=(0::Word8); u [] = []; u xs = (let (ys,zs) = splitAt 4 xs in ys : u zs); getFrom x y = map(x !!) $ map(fromIntegral.((\x -> fromIntegral $ foldl(.|.) z (zipWith(\c n -> if c then bit n else z) x [0..3])) :: [Bool] -> Int)) $ reverse.u.reverse.concat.map(((\x-> map (testBit x) [7,6..0]) :: Word8 -> [Bool]).fromIntegral.ord) $ y in getFrom " ?Waeghilmnoruwy" "&\240<@\251\208\131\213g\165\t\155\204\190\DLE"
19:36:29 <lunabot>  "Why are you laughing mmorrow? "
19:36:41 <dolio> Wow.
19:36:47 <mmorrow> hehe
19:37:33 <mmorrow> adu: you've totally gotta write a program that takes a desired output string as input, then generates the program like that to compute that output string :)
19:38:08 <adu> mmorrow: ok, shall i call it mucipher?
19:38:24 <sbahra> haha
19:38:50 <mmorrow> adu: lol. yes call it that for sure
19:40:05 <sw17ch> Is there a good way to figure out where the Segfault in my program is coming from? My usual method doesn't work when things are lazy...
19:40:55 <zloog> sw17ch: I'm pretty sure that if it is actually a segfault its coming from your haskell implementation
19:41:11 <sw17ch> zloog, no, it's coming from me doing bad things with pointers
19:41:19 <zloog> sw17ch: Oh
19:41:25 <sw17ch> zloog, but i can't figure out which pointer is being bad :)
19:41:29 <ksf> from any unsafe* function if you're lucky, from ghc if you're even more lucky and get the chance to embarrass spj.
19:41:30 <zloog> sw17ch: interfacing to C then?
19:41:46 <sw17ch> zloog, yes... in windows... so it's even worse :P
19:42:00 <zloog> sw17ch: lol
19:43:03 <sjanssen> sw17ch: laziness and pointers do not mix
19:43:04 <sw17ch> zloog, the worst part is that it's not deterministic
19:43:18 <sw17ch> run once, works, run again, fails, run again, fails, run again works... etc...
19:43:20 <sjanssen> sw17ch: are you using unsafePerformIO?
19:43:25 <sw17ch> sjanssen, no
19:43:40 <zloog> sw17ch: I'm sure you are going way over my head. I just came here to ask about how to add two tuples together piecewise
19:43:41 <sw17ch> sjanssen, this is related to the issue from last night, i think
19:44:00 <sw17ch> zloog, :)
19:44:09 <sjanssen> sw17ch: so it probably has something to do with how you're managing memory
19:44:37 <sw17ch> sjanssen, yes, i'm assuming that. i'm wondering if the finalizer on the ForeignPtr is being called too early...
19:45:41 <sw17ch> sjanssen, the problem is that i can't quite tell where it's happening
19:45:55 <sw17ch> i think it's in one of my Storable instances (peek), but i'm not entirely sure
19:49:55 * clanehin wonders if there should be something along the lines of a class Endomorphism a t | a -> t where appEndo :: a -> t -> t, but doesn't have time/inclination to play with it so just throws it out there
19:50:13 <dmwit__> category-extras has such a thing.
19:50:25 <dmwit__> I think it may even be in some of the more standard libraries.
19:50:31 <dmwit__> ?instances Monoid
19:50:32 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
19:50:41 <dmwit__> clanehin: There you go, right in the middle: Endo a.
19:50:55 <clanehin> dmwit_ as that's a data decl, not a typeclass
19:51:14 <dmwit> clanehin: What would a class give you?
19:51:47 <clanehin> dmwit: well I just realized I wrote a specialized version of above as a convenience typeclass
19:52:07 <dmwit> Okay, so what does your specialized version give you? =)
19:52:27 <clanehin> dmwit: saves me a lot of redundant typing, mainly
19:53:15 <dmwit> I would be interested in seeing an example where an Endo typeclass saves typing, but the Endo data declaration doesn't.
19:53:29 <dmwit> I'm not saying it would be hard to cook up such an example, just that a motivating example helps a lot.
19:54:01 <clanehin> dmwit: well I'm working on roguestar and I'm trying to represent all of the differently-typed pieces of information that contribute to a creature
20:21:13 <roconnor> I wonder if I should rename Data.Colour.HDTV.rgb709 and Data.Colour.HDTV.toRGB709 and drop the 709.
20:22:10 <roconnor> or put in the word "linear" instead
20:22:23 <roconnor> naming stuff is so stressful.
20:22:50 <int-e> what does the 709 refer to?
20:23:17 <adu> int-e: I think it stands for ITU standard 709
20:24:06 <roconnor> adu is correct
20:24:16 <int-e> thanks
20:24:22 <roconnor> it specifies which rgb gamut we are talking about
20:24:32 <roconnor> as opposed to rgb601
20:24:49 <roconnor> actually, that is a pretty good reason to keep the 709
20:25:00 <roconnor> maybe not good enough reason
20:25:06 <roconnor> but a pretty good reason.
20:26:02 <Saizan> anyone has a good reference for the Fidge/Mattern timestamp algorithm? (google suggests searching for Fridge Pattern ...)
20:26:36 <dmwit> roconnor: Is there a friendlier name?
20:26:46 <dmwit> (for the standard?)
20:28:01 <roconnor> not really, other than maybe HDTV, which is in the module name.
20:28:25 <dmwit> Does 601 apply to HDTV?
20:28:30 <roconnor> no
20:28:45 <roconnor> 601 applies to SDTV
20:28:51 <dmwit> I'm inclined to suggest dropping it.
20:29:01 <dmwit> (There's also an SDTV module, right?)
20:29:08 <roconnor> there was, and will be
20:29:17 <roconnor> SDTV is bit more tricky
20:29:28 <roconnor> there are several different gammuts specified.
20:29:33 <roconnor> europe
20:29:39 <roconnor> north america
20:29:43 <roconnor> north america again
20:29:54 <roconnor> north america again again I think.
20:30:10 <ddarius> People see color differently in Canada
20:30:12 <dmwit> heh
20:30:16 <dmwit> again again
20:30:44 * edwardk waves hello.
20:31:14 <dmwit> Hiya!
20:31:23 <dmwit> How's life treating edwardk?
20:31:30 <edwardk> not shabby actually
20:32:44 <edwardk> how is the life of dmwit?
20:33:03 <dmwit> Absolutely marvelous!
20:33:19 <dmwit> I couldn't ask for much more than what I've got.
20:33:32 <dmwit> Maybe if days had a few extra hours... ;-)
20:35:41 <ddarius> I like the interposition of "much"
20:36:12 <edwardk> hah
20:36:20 <mmorrow> it was truly key
20:37:32 <edwardk> so what truly electrifying news is there in the wonderful realm of haskell?
20:38:23 <gwern> well, darcs development has really picked up
20:38:26 <dmwit> Ah, well, you can always *ask* for more. =)
20:38:38 <gwern> roundy is no longer beneveolent dictator for life
20:38:46 <dmwit> darcs is up, FRP is up, haskell.org is down
20:38:54 <dmwit> Just kidding, haskell.org is just fine.
20:38:58 <mmorrow> gwern: what does that mean?
20:39:05 <dmwit> mmorrow: new maintainer!
20:39:10 <edwardk> i've been following along on the darcs thing. the fact that kowey was able to call for the break from franchise astounded and amazed me
20:39:10 <gwern> eric kowey assures us that the coup was bloodless, but I dunno. there have been emails from roundy, but I'm not sure the signatures check out...
20:39:19 <mmorrow> oh snapptrap
20:39:45 <edwardk> i still think that kowey has turned bond villain and has roundy trapped in a basement somewhere with sharks, and frickin laser beams.
20:39:45 <gwern> edwardk: well, franchise would only ever fly in the minds of roundy and meachem
20:40:27 <edwardk> didn't they learn from searchpath? http://searchpath.org/
20:40:34 <lambdabot> Title: SearchPath — Automatic import chasing across the Internet for Haskell modules
20:40:35 <gwern> 'Do you really expect me to commute 4 patches while I explain the build system?' 'No, Mr. Roundy. I expect you to die!'
20:41:12 <edwardk> gwern: exactly =) i figure its good for a sequel at least, because lispy will have to rush in to his rescue if he wants to graduate.
20:43:43 <roconnor> dmwit: how do you feel about Data.Colour.SDTV.rgbEBU, SDTV.rgbNTSC, SDTV.rgbSMPTEC, or should the by Data.Colour.SDTV.EBU.rgb, etc.?
20:44:18 <ddarius> Looks like it should be a (type?) parameter...
20:44:50 <roconnor> ddarius: was that for me?
20:45:13 <ddarius> Yes.
20:45:46 <dmwit> roconnor: Those sound very usable.
20:45:55 <dmwit> oh
20:45:59 <dmwit> It was a choice. =P
20:46:13 <dmwit> roconnor: aaah, that's a tricky decision.
20:46:21 <roconnor> ddarius: ya, there will be a gamutEBU, etc values and a generic rgb :: Gamut -> a -> a -> a -> Colour a
20:46:49 <roconnor> ddarius: but I feel I ought to provide these functions for the common gamuts
20:47:02 <dmwit> Maybe a class?
20:47:12 <dmwit> I guess you don't want these things to have different types.
20:47:29 <roconnor> dmwit: ya, I don't think bringing in type classes is a good idea.
20:47:30 <dmwit> But, I'd go with the module version: Data.Colour.SDTV.EBU.rgb
20:47:39 <dmwit> dunno what your gut reaction is
20:47:43 <roconnor> dmwit: that seems fair.
20:48:26 <roconnor> the nice thing is that people can change (fix?) their gamut by simply changing what module they import.
20:51:44 <mmorrow> i hope there's a function called runGamut
20:51:56 <roconnor> mmorrow: there will be.
20:52:01 <mmorrow> zomg
20:52:05 <roconnor> rgbGamut
20:52:11 <roconnor> gamutRGB
20:52:16 <roconnor> gamutToRGB
20:52:24 <roconnor> I don't know what I'll name it yet
20:52:38 <roconnor> but users will be able to specify their own gamuts
20:52:39 <mmorrow> runTheGamutFromRGBToNTSC ???
20:53:00 <roconnor> :)
20:53:06 <mmorrow> hehe
20:57:40 <bd_> @hoogle [a] -> Int -> a -> [a]
20:57:41 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
20:57:41 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
20:57:41 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
21:03:26 <geezusfreeek> wow, chipmunk physics has a lot of mutation. i had sat down to try a direct, native port using DPH, but it seems i might have to make some rather drastic design changes instead
21:03:30 <grom358> I got a one liner piece of code that works in ghci. But I want to put it in a .hs file and run it with runghc . How can I do that? (the code is sum [x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0])
21:03:48 <Cale> grom358:  main = print (...)
21:04:19 <dmwit> geezusfreeek: Yeah, it does. =/
21:04:28 <dmwit> geezusfreeek: It also makes some odd decisions re: memory management.
21:04:33 <geezusfreeek> yeah
21:04:51 <geezusfreeek> i'm not too worried about that part though since i'm trying to port natively :)
21:05:08 <grom358> Cale: thanks.. btw is that the same as main = print $ ...
21:05:20 <dmwit> yes
21:05:24 <geezusfreeek> but it does mean i have to find alternatives to the pointers in chipmunk
21:05:35 <dmwit> geezusfreeek: Oh?
21:05:41 <dmwit> oh.
21:05:44 <geezusfreeek> well, i'm just trying to be pure
21:05:48 <Cale> grom358: yeah, it is
21:06:04 <dmwit> geezusfreeek: I thought you were talking about the Haskell binding to chipmunk, but you're actually just talking about chipmunk proper.
21:06:10 <geezusfreeek> right
21:06:15 <dmwit> got it
21:06:30 <dmwit> So, yeah, it uses mutation pretty critically for its speed.
21:07:09 <geezusfreeek> i may have to resort to some unsafe functions at the core, but my goal is for at least a pure interface
21:07:34 <dmwit> I'm not sure that's really going to be feasible.
21:07:38 <geezusfreeek> i'm preferring to avoid unsafe functions too though :P
21:07:46 <geezusfreeek> it won't be as fast as the original
21:07:50 <geezusfreeek> i'm not too worried about that
21:08:05 <dons> you just need to work out if there's a referentially transparent way to do what you're doing.
21:08:11 <dons> if so, it can be impure under the hood
21:08:16 <geezusfreeek> right
21:08:19 <dons> (like bytestrings, uvector, the haskell heap...)
21:08:51 <dons> i think i wrote a whole bunch about this in RWH somewhere.
21:09:05 <dons> the ffi chapter, iirc. on when its safe to make an ffi binding pure.
21:17:10 <sutats> Say I read a file in with readFile knowing that the first line has two ints separated by a comma. How would I write the function to extract those two ints and put them into a 2-tuple?
21:18:17 <dmwit> Sounds a lot like a homework problem!
21:18:23 <dmwit> But take a look at lines, words, and read.
21:18:32 <dmwit> See also break and span.
21:19:16 <sutats> dmwit: Actually, a small project to help me learn Haskell better. But thanks, I'll look into those.
21:19:37 <gwern> @hoogle readInt
21:19:38 <lambdabot> Numeric readInt :: Num a => a -> Char -> Bool -> Char -> Int -> ReadS a
21:19:38 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
21:19:38 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
21:20:02 <dmwit> Yep, there's readInt, but it's overkill unless your number is not decimal.
21:20:28 <dmwit> And even then, if it's written in the "standard way" -- i.e. prefixed by 0x for hex numbers or 0 for octal numbers -- read will still get you where you want to go.
21:20:42 <dmwit> > 0o32
21:20:43 <sutats> Okay, I'll stick to read then.
21:20:44 <lambdabot>   26
21:21:06 <dmwit> Oops, I was wrong, octals have to be prefixed by 0o, which is slightly uncommon.
21:22:02 <sutats> dmwit: I think I figured out how to extract the line I want. Which functions do I want to examine for the comma separation part?
21:22:09 <dmwit> span/break
21:22:32 <dmwit> If your format gets much more complicated than this, you might just want to learn about Parsec straight away.
21:22:46 <dmwit> (i.e. write a full parser -- it's easier than you might think!)
21:23:11 <sutats> dmwit: I would, but I know for a fact that the file format I want to parse is consistently in this format.
21:23:54 <dmwit> I meant "gets more complicated later in the file," not "gets more complicated in the future."
21:25:10 <sutats> dmwit: Oh, hm...
21:25:14 <sutats> dmwit: It actually does.
21:25:30 <adu> this is freaking me out
21:25:39 <sutats> dmwit: That's not a bad suggestion, but I think that if I'm still struggling with the Prelude, I should get that down first.
21:25:51 <dmwit> sure
21:25:56 <dmwit> Totally reasonable. =)
21:26:13 <dmwit> And the Prelude functions will make a totally unreadable mess, but it will be loads of fun in the meantime. =)
21:26:24 <sutats> dmwit: Does there happen to be an isComma type function?
21:26:31 <dmwit> :t isPunctuation
21:26:33 <lambdabot> Char -> Bool
21:26:35 <dmwit> :t (==',')
21:26:36 <lambdabot> Char -> Bool
21:26:46 <sutats> Ah, handy.
21:27:04 <dmwit> The former is likely in Data.Char; the latter just uses Char's Eq instance, of course.
21:27:56 <sutats> dmwit: Right.
21:29:24 <sutats> dmwit: So far I have "(break (==',') . head . lines)" but the comma is in the second list. I'm thinking about using drop 1 with snd to eliminate that, but the syntax is eluding me.
21:29:41 <dmwit> You've got it exactly right so far.
21:29:54 <dmwit> How much do you know about pattern matching?
21:30:02 <sutats> dmwit: Not much, unfortunately.
21:30:26 <dmwit> Time to learn, then! =)
21:30:33 <sutats> Haha, yeah.
21:30:35 <adu> can you guys explain this??? I'm very confused
21:30:42 <adu> , take 15 $ map snd $ drop 1 $ iterate ((`divMod`8) . fst) (4022889313, 0)
21:30:44 <lunabot>  [1,4,5,5,6,0,2,6,7,5,3,0,0,0,0]
21:30:50 <adu> , map (" HWdelor" !!) [1,4,5,5,6,0,2,6,7,5,3,0,0,0,0]
21:30:52 <lunabot>  "Hello World    "
21:31:10 <adu> , map (" HWdelor" !!) $ take 15 $ map snd $ drop 1 $ iterate ((`divMod`8) . fst) (4022889313, 0)
21:31:11 <dmwit> adu: What's got you confused?
21:31:13 <lunabot>  "Hello Worlrrrrr"
21:31:17 <dmwit> oh
21:31:37 <adu> composition doesn't seem to be working
21:32:01 <dmwit> > map (" HWdelor" !!) $ take 15 $ map snd $ drop 1 $ iterate ((`divMod`8) . fst) (4022889313, 0)
21:32:03 <lambdabot>   "Hello World    "
21:32:19 <dmwit> Perhaps lunabot is broken somehow.
21:32:31 <adu> dmwit: my ghc does the same thing as lunabot
21:32:39 <dmwit> > 4022889313
21:32:40 <lambdabot>   4022889313
21:32:42 <dmwit> , 4022889313
21:32:44 <lunabot>  4022889313
21:32:53 <adu> so what I'm confused about is why the 'rrrrrr'?
21:33:04 <dmwit> right
21:33:05 <geezusfreeek> woo internet is back!
21:33:22 <dmwit> adu: Perhaps you should check about what types are being used in the two cases.
21:33:37 <dmwit> > map (" HWdelor" !!) $ take 15 $ map snd $ drop 1 $ iterate ((`divMod`8) . fst) (4022889313 :: Integer, 0)
21:33:39 <lambdabot>   Couldn't match expected type `Int' against inferred type `Integer'
21:33:43 <dmwit> > map (" HWdelor" !!) $ take 15 $ map snd $ drop 1 $ iterate ((`divMod`8) . fst) (4022889313 :: Int, 0)
21:33:44 <lambdabot>   "Hello World    "
21:33:47 <dmwit> , map (" HWdelor" !!) $ take 15 $ map snd $ drop 1 $ iterate ((`divMod`8) . fst) (4022889313 :: Int, 0)
21:33:49 <lunabot>  "Hello Worlrrrrr"
21:33:56 <dmwit> weird
21:34:02 <Saizan> ?type (!!)
21:34:03 <lambdabot> forall a. [a] -> Int -> a
21:34:07 <Saizan> heh
21:34:15 <dmwit> oh
21:34:19 <dmwit> , 4022889313 :: Int
21:34:22 <lunabot>  -272077983
21:34:25 <dmwit> > 4022889313 :: Int
21:34:27 <Saizan> > map (" HWdelor" !!) . map fromIntegral $ take 15 $ map snd $ drop 1 $ iterate ((`divMod`8) . fst) (4022889313 :: Int, 0)
21:34:27 <lambdabot>   4022889313
21:34:28 <lambdabot>   "Hello World    "
21:34:28 <adu> , map ((" HWdelor" !!).fromIntegral) $ take 15 $ map snd $ drop 1 $ iterate ((`divMod`8) . fst) (4022889313, 0::Integer)
21:34:31 <lunabot>  "Hello World    "
21:34:31 <adu> yey
21:34:34 <dmwit> adu: There you have your answer.
21:34:43 <adu> that explains it
21:34:46 <dmwit> adu: I had it earlier, but forgot that Integer is the default. =)
21:34:48 <doublef> Since when did GHC stop accepting programs with tab characters in string literals?!
21:35:02 <doublef> Like
21:35:02 <doublef> module Main where
21:35:02 <doublef> main = putStrLn "It<tab here>works!"
21:35:51 <dmwit> doublef: try "It\tworks!"
21:36:21 <doublef> dmwit: yeah thanks, that broke all of my scripts.
21:36:47 <doublef> dmwit: even C accepts that!
21:37:38 <dmwit> doublef: http://www.haskell.org/onlinereport/lexemes.html literal tab is not valid in a String literal
21:37:39 <lambdabot> Title: Haskell 98 Lexical Structure
21:37:39 * dmwit shrugs
21:37:42 <dmwit> Haskell is not C.
21:38:43 <sutats> dmwit: I know this isn't the direction I want to take, but why is this ambiguous: "read . drop 1 . snd . break (==',') . head . lines"?
21:38:45 <doublef> Is there any reasoning behind that? And, BTW, it worked for ~2 years with GHC...
21:39:06 <dmwit> sutats: read is polymorphic on its return type
21:39:20 <sutats> dmwit: And how would I resolve that?
21:39:26 <dmwit> > (read "()" :: (), read "32" :: Int, read "\"Hey\"" :: String)
21:39:28 <lambdabot>   ((),32,"Hey")
21:39:44 <dmwit> sutats: Either use the value you parsed in a way that restricts its type, or give an explicit type annotation.
21:40:30 <sutats> dmwit: Okay, makes sense, thanks.
21:40:47 <dmwit> doublef: If it used to work, there is likely a command-line option to let it still work.
21:41:24 <sutats> dmwit: Where would I add the ":: Int" for the line I gave you?
21:41:26 <Twey> > read "\"\t\"" :: String
21:41:28 <lambdabot>   "\t"
21:41:36 <Twey> Well, that works.
21:42:23 <dmwit> sutats: I guess you could stick ":: String -> Int" or whatever at the end of your line.
21:42:40 <dmwit> sutats: But type annotations can go basically anywhere in the language.
21:42:53 <dmwit> sutats: So if you're naming the result, I'd give an annotation for the name:
21:43:02 <dmwit> firstIntInTheFile :: Int
21:43:07 <dmwit> firstIntInTheFile = ...
21:43:16 <ddarius> What happens if you use quasiquotation to read in tab characters?
21:43:16 <dmwit> String -> Int, whatever
21:43:20 <adu> I think i made it scalable now
21:43:42 <adu> > map((" ,Iacdehimnoprstuwy"!!).fromIntegral.snd)(takeWhile(/=(0,0))$drop 1$iterate((`divMod`19).fst)(85973985357612504089563763423405580952256980889603714659247119848980415879037499410684111255191100434,0))
21:43:43 <dmwit> Twey: interesting
21:43:44 <lambdabot>   "I can assure you, sir, that my teacher intended to pay what he owed on his...
21:44:17 <sutats> dmwit: Hm, okay.
21:55:33 <mmorrow> adu: awesome. i can't wait to play with mucipher ;)
21:56:05 <mmorrow> (i read "mucipher" like lucifer btw)
21:57:22 <int-e> > reverse $ showIntAtBase 19 (" ,Iacdehimnoprstuwy"!!) 85973985357612504089563763423405580952256980889603714659247119848980415879037499410684111255191100434 ""
21:57:25 <lambdabot>   "I can assure you, sir, that my teacher intended to pay what he owed on his...
21:57:31 <Twey> dmwit: Indeed.  Perhaps read is implemented a little oddly?
21:57:45 <adu> int-e: oh, that helps alot
22:08:40 <roconnor> @hoogle Word10
22:08:41 <lambdabot> No results found
22:09:03 <dmwit> heh
22:09:06 <dmwit> Word10?
22:09:11 <roconnor> 10 bit
22:09:17 <dmwit> Right, I know.
22:09:23 <dmwit> But what machines have a 10-bit word?
22:09:28 <dmwit> 9-bit I've heard of, but 10?
22:09:49 <roconnor> SMPTE 259M
22:10:23 <dmwit> Well, I'll be damned.
22:10:52 <dmwit> I guess you'll have to write something nasty or waste 6 bits.
22:10:59 <dmwit> > 6 / 16
22:11:00 <lambdabot>   0.375
22:11:06 <dmwit> nearly 40% lossage
22:11:23 <roconnor> dmwit: 3 10 bit channels takes 30 bits
22:11:41 <dmwit> That's pretty nice.
22:12:00 <dmwit> I guess the next step up is 17x3 10-bit channels. ;-)
22:13:34 <solrize_> i think there are some 10 bit pics?
22:14:05 <solrize_> i guess not.  they just have 10 bit a/d converters
22:27:10 <adu> mmorrow: yu there?
22:27:33 <adu> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mucipher
22:27:37 <adu> > showIntAtBase 2 ("ey"!!) 5 ""
22:27:43 <lambdabot>   "yey"
22:27:44 <lambdabot> Title: HackageDB: mucipher-0.5.0, http://tinyurl.com/6qokta
22:28:37 <mmorrow> adu: haha, sweet.
22:28:41 * mmorrow wgets
22:29:18 <sjanssen> adu: clever
22:29:29 * sjanssen cabal install mucipher
22:29:39 <adu> sjanssen: that was int-e's idea of using showIntAtBase
22:30:31 <dons> in your favorite haskell-friendly distro, http://aur.archlinux.org/packages.php?ID=21413
22:30:42 <lambdabot> Title: AUR (en) - haskell-mucipher
22:31:50 <adu> dons: how did that happen?
22:32:25 <dons> mmm . http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Workflow-0.1
22:32:27 <lambdabot> Title: HackageDB: Workflow-0.1, http://tinyurl.com/5fjnnu
22:32:33 <dons> transparent checkpointing for each step in permanent storage (using TCache)
22:32:46 <adu> > showIntAtBase 11 (" abceimostu"!!) 320820238752982730 ""
22:32:48 <lambdabot>   "must be automatic"
22:33:03 <dons> " library for transparent execution of computations across shutdowns and restarts"
22:33:09 <dons> that's pretty interesting.
22:33:17 <dons> adu: yeah
22:33:23 <dons> by the power of cabal!
22:33:39 <adu> indeed, hail cabal
22:33:41 <adu> cabal++
22:33:56 <adu> is karma case-sensitive?
22:33:59 <adu> Cabal++
22:34:01 <dons> all hail cabal.
22:34:47 <mwc> hey dons, is th x86_64 arch haskell overlay still disused?
22:34:48 <dons> all glory to cabal.
22:34:58 <mwc> or is the wiki out of date when it says the overlay is out of date ;)
22:35:01 <dons> mwc, it is, until we start using some clever cabals to trigger recompilatoin.
22:35:17 <dons> we need to keep the entire binary suite in sync
22:35:28 <mwc> Yes, I was thinking about htat a while ago
22:36:33 <sjanssen> adu: how about a getExpression function, which produces the expression that will produce a string?
22:36:34 <dons> it seems like this transparent execution business would be useful for happs or lambdabot..
22:37:53 <mmorrow> showCipher "zmog asdfffffffffff;;lkj;lkjlkjlk"
22:37:55 <mmorrow> , showCipher "zmog asdfffffffffff;;lkj;lkjlkjlk"
22:37:56 <lunabot>  "showIntAtBase 13 (\" ;adfgjklmosz\"!!) 564710172035238831253464852009538...
22:38:03 <mmorrow> , (fromDynamic . eval) (showCipher "zmog asdfffffffffff;;lkj;lkjlkjlk") :: Maybe String
22:38:13 <lunabot>  Just "zmog asdfffffffffff;;lkj;lkjlkjlk"
22:38:16 <sjanssen> adu: oh, that's what showCipher does
22:38:26 <sjanssen> adu: I'm just a bit slow :)
22:47:11 <adu> sjanssen: like with TH?
22:47:26 <sjanssen> adu: nah, I was just confused on what showCipher does
22:52:23 <mmorrow> adu: you could also add a function returning a TH ExpQ easy enough:
22:52:26 <mmorrow> (\b str ns -> [|showIntAtBase b (str!!) ns []|]
22:52:42 <mmorrow> (you'd just have to provide the b str ns)
22:52:49 <mmorrow> , showCipher "zmogg"
22:52:52 <lunabot>  "showIntAtBase 4 (\"gmoz\"!!) 864 \"\""
22:53:07 <mmorrow> , (\b str ns -> [|showIntAtBase b (str!!) ns []|] 4 "gmoz" 864
22:53:09 <lunabot>  luna: parse error (possibly incorrect indentation)
22:53:14 <mmorrow> , (\b str ns -> [|showIntAtBase b (str!!) ns []|]) 4 "gmoz" 864
22:53:16 <lunabot>  AppE (AppE (AppE (AppE (VarE showIntAtBase) (LitE (IntegerL 4))) (InfixE ...
22:53:25 <mmorrow> , ppDoc `fmap` ((\b str ns -> [|showIntAtBase b (str!!) ns []|]) 4 "gmoz" 864)
22:53:27 <lunabot>  showIntAtBase 4 (['g', 'm', 'o', 'z'] !!) 864 []
22:54:03 <mmorrow> (\b str ns -> [|showIntAtBase b (str!!) ns []|]) :: Int -> String -> Integer -> ExpQ
22:54:22 <mmorrow> import Language,Haskell.TH.Lib (ExpQ)
22:54:27 <mmorrow> s/,/./
22:54:58 * Saizan hates to read "details left for the full paper" and not being able to find the full paper.
22:55:01 <mmorrow> (and {-# LANGUAGE TemplateHaskell #-})
22:55:26 <mmorrow> Saizan: grrr
22:56:39 <mmorrow> , (fromDynamic . eval) "showIntAtBase 4 (['g', 'm', 'o', 'z'] !!) 864 []" :: String
22:56:40 <lunabot>  luna: Couldn't match expected type `GHC.Base.String'
22:56:41 <Saizan> anyone has an implementation of "Two Simplified Algorithms for Maintaining Order in a List" handy? :)
22:56:50 <mmorrow> , (fromDynamic . eval) "showIntAtBase 4 (['g', 'm', 'o', 'z'] !!) 864 []" :: Maybe String
22:56:54 <lunabot>  Just "zmogg"
22:58:41 <mmorrow> adu: i like this idea of storing data as code which when evaluated yields the data (apart from in the trivial sense that a String from show will evaluate to itself)
23:00:23 <adu> mmorrow: its like Shannon's information theory
23:00:26 <mmorrow> (i meant to say in the parens =>   (eval . show) === id)
23:00:38 <mmorrow> adu: interesting
23:01:23 <adu> anything sufficiently repetitive is not information... or something
23:04:04 <dancor> how do i not write out inner Either: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=474#a474
23:08:35 <dmwit> Maybe you want EitherT IO?
23:08:45 <dmwit> ?unmtl EitherT e IO a
23:08:46 <lambdabot> EitherT e IO a
23:09:10 <dmwit> No, you don't want that.
23:09:39 <dmwit> The Either monad should be enough for you.
23:09:42 <dmwit> Let's see...
23:09:52 <dancor> i don't want that?
23:09:58 <dmwit> Give me a second.
23:10:43 <hackage> Uploaded to hackage: Pugs 6.2.13.12
23:10:43 <hackage> Uploaded to hackage: mucipher 0.5.0
23:12:45 <adu> i think my next thing will be custom tables
23:12:58 <dmwit> dancor: Check your paste again.
23:13:04 <adu> , showIntAtBase 10 ("thys image"!!) 624789453401943769 ""
23:13:06 <lunabot>  "my age is the same"
23:13:15 <dmwit> dancor: That's untested refactor part one.
23:13:39 <dancor> dmwit: i want to keep the IO stuff
23:13:48 <dancor> this is just a simple example for something else i was doing
23:13:53 <dmwit> dancor: It does keep the IO stuff.
23:14:20 <dmwit> At the end, I guess you could do: case f l of Left err -> print err; Right answer -> print answer
23:14:33 <dancor> it doesn't print the steps as you go
23:14:47 <dancor> i think i want like ErrorT IO or something
23:14:53 <dancor> but i have to figure that stuff out
23:14:55 <dmwit> Oops, yup, I meant to put that in, but forgot.
23:15:05 <dmwit> bad refactor =)
23:15:09 <dmwit> Okay, let me try again.
23:15:09 <dancor> heh
23:15:28 <dons> uploads per day to hackage, http://galois.com/~dons/images/hackage-daily-graph.png since launch
23:15:38 <dons> (via the gnuplot bindings for haskell, btw)
23:15:56 <dmwit> dancor: Anyway, yeah, you want something like EitherT IO or EitherT Writer.
23:16:08 <dmwit> (I think EitherT Writer would be very nice here.)
23:16:10 <dancor> is EitherT cooler than ErrorT
23:16:16 <dancor> for my first use of transformers
23:16:23 <dmwit> uh
23:16:26 <dmwit> ?index EitherT
23:16:26 <lambdabot> bzzt
23:16:32 <dmwit> Nope, since it doesn't exist. =)
23:16:38 <dancor> http://hackage.haskell.org/packages/archive/mtl/1.1.0.1/doc/html/Control-Monad-Error.html#v:ErrorT
23:16:40 <lambdabot> Title: Control.Monad.Error, http://tinyurl.com/6gdtkv
23:26:24 <dancor> is it true that if you have several monads stacked with transformers, that you just have to keep track of the number of lift's to do
23:26:44 <dancor> instead of being able to like "lift until you get to a monad of this type"
23:28:53 <quicksilver> dancor: no.
23:29:01 <quicksilver> dancor: it's true that you should never use lift.
23:29:10 <quicksilver> dancor: that's what the "MonadFoo" classes are for.
23:29:10 <dancor> hah ok
23:29:19 <quicksilver> :t get
23:29:21 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
23:29:33 <quicksilver> get is a method of MonadState precisely so that the lifting is automatic
23:29:57 <dancor> so StateT is always wrong?
23:30:12 <quicksilver> no, StateT is fine.
23:30:20 <quicksilver> conveniently, StateT comes with MonadState instances
23:30:23 <quicksilver> so you can just use 'get'
23:30:30 <quicksilver> and it will work out how many lifts it needs.
23:30:44 <vegai> What's the benefit of STM.TChan compared to Chan?
23:30:44 <lambdabot> vegai: You have 1 new message. '/msg lambdabot @messages' to read it.
23:31:03 <quicksilver> So, the author of a monad transformer has to write the instances using lift. But once that has been done once, hopefully the user of the monad never needs to explicitly lift.
23:31:29 <quicksilver> vegai: well atomicity and retries
23:31:47 <quicksilver> vegai: e.g. one transaction can read twice from the channel and guarantee no one else does in between
23:31:57 <adu> , showIntAtBase 26 (" !\"()0356789ABIadehlnorstw"!!) 165598739806743594898145996663668231350651355985630129354479438 ""
23:32:00 <lunabot>  "showIntAtBase 8 (\" dehlorw\"!!) 3566500769 \"\""
23:32:11 <vegai> ah, right.
23:32:25 <vegai> So if I have the simple case where one process writes and one other reads, that won't buy me anything
23:32:26 <mrd> atomically $ foldr orElse retry listOfChans -- :)
23:32:53 <vegai> but if the amount of readers/writers rise...
23:32:57 <quicksilver> vegai: yeah. atomicity doesn't buy you anything when your algorithm was already atmoic
23:33:00 <quicksilver> vegai: IYSWIM.
23:33:43 <vegai> I hope I do
23:34:06 <Twey> IYSWIM?
23:34:16 <Twey> I've heard ISWIM, but that's new on me :-P
23:34:34 <quicksilver> If You See What I Mean
23:35:53 <dancor> ok thanks, this looks good: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=474#a476
23:35:59 <dancor> i think
23:36:15 <dancor> i don't really get lift vs liftIO
23:36:43 <quicksilver> liftIO knows how far down to go to getIO
23:36:56 <quicksilver> liftIO is "lift . lift . lift . lift" for some number of lifts
23:37:01 <quicksilver> depending how deep the IO is.
23:37:36 <dancor> ok
23:37:41 <dancor> so lift--, lift
23:37:42 <dancor> IO++
23:37:47 <dancor> hitting enter--
23:37:56 <quicksilver> yeah, although once you've used monad transformers for a while with IO
23:38:04 <quicksilver> you'll wish that all IO was auto-lifted
23:38:10 <dancor> ya
23:38:18 <quicksilver> e.g. putStrLn :: MonadIO m => String -> m ()
23:38:36 <quicksilver> (which could be defined by putStrLn = lift . Prelude.putStrLn)
23:38:46 <dancor> ooh that's hot, anyone up for Prelude.Fork
23:38:56 <quicksilver> dons tends to use "io = liftIO"
23:39:06 <quicksilver> just to make it a bit easier on the eyes
23:39:58 <dancor> if it's good enough for dons, it's good enough for me
23:40:27 <dmwit> dancor: You could sorely use a "errAndPrint s err v = nothErr err v <* liftIO (print (s ++ show v))"
23:40:34 <dmwit> err
23:41:06 <dmwit> errAndPrint s err v = do { x <- nothErr err v; liftIO . print $ s ++ show x; return x }
23:41:27 <dancor> ya this example is repetitive
23:41:53 <dancor> but it has served its purpose
23:42:31 <dons> kolmodin: got native packages for today's hugs yet!? :)  http://archhaskell.wordpress.com/2008/11/12/pugs-621312-now-available-for-arch-linux-with-ghc-610-support/
23:42:33 <lambdabot> Title: pugs 6.2.13.12 now available for Arch Linux, with ghc 6.10 support « Arch Linux ..., http://tinyurl.com/6er7uv
23:42:37 <dons> today's /pugs/
23:43:14 <ivanm> dons: we don't manage pugs
23:43:15 <ivanm> perl does
23:43:20 <ivanm> and we're having issues with them :@
23:43:31 <dons> probably a mistake, since its a haskell system.
23:43:42 <dons> much easier for us to manage it, since it fits with all the other cabalised stuff
23:43:47 <dons> i write about that above.
23:43:57 <ivanm> they haven't updated the ebuilds for them in donkeys ages, so they're the only ones left using the old deprecated haskell-bin ebuilds (which we want to dump)
23:44:10 <ivanm> dons: well, they've already got it, and they're not responding to our bug about it :@
23:44:15 <dons> you should just do a proper haskell package.
23:44:26 <ivanm> dons: yeah, I've considered that
23:44:26 <dons> pugs is trivial now it is hackage-ified
23:44:32 <ivanm> http://bugs.gentoo.org/show_bug.cgi?id=239222
23:44:34 <lambdabot> Title: Gentoo Bug 239222 - Remove dependencies in pugs on dev-lang/ghc-bin
23:44:44 <dons> that's what i did for arch -- just conquested the perl-maintained packages
23:44:45 <mmorrow> monadLib has IO autolifted iirc
23:45:00 <mmorrow> well, you have to use lift
23:45:05 <dons> so they actually didn't suck.
23:45:25 <ivanm> heh
23:45:28 <ivanm> "conquested"?
23:45:58 <dmwit> "conquered"
23:46:05 <dancor> conquestedored
23:46:05 <dmwit> "annexed" might be a better replacement, though
23:46:22 <dons> yes perhaps.
23:46:30 <dons> aggressively overthrew and replaced with my own regime.
23:46:36 <dons> how's that/
23:47:18 <mmorrow> dmwit'd probably call that a "gentle suggestion"
23:47:27 <dmwit> heh
23:47:31 <mmorrow> :)
23:49:02 <dons> i wonder if anyone else will submit articles to http://www.reddit.com/r/haskell/
23:49:04 <lambdabot> Title: Haskell
23:49:19 <dons> hmm. i note there are now 1222 subscribes. that's gone up fast.
23:50:58 <mmorrow> quicksilver: i remember the topic of entwining (for lack of a better word) stm and database transactions at one point. so you have any random thoughts on this?
23:51:14 * mmorrow could use something like this
23:51:34 <dmwit> dons: It's okay just acting as your blog for now, I think.
23:51:34 <mmorrow> i don't necessarily care if i use stm or not
23:51:37 <dmwit> (I read it.)
23:52:06 <mmorrow> sclv: same to you of you're present
23:52:12 <mmorrow> s/of/if/
23:53:33 <dons> dmwit: kinda my twitter feed..
23:53:56 <dons> i wonder if who gets there haskell news from the haskell reddit
23:54:38 <dmwit> I don't read HWN until it hits the Haskell reddit. =P
23:56:37 <mmorrow> quicksilver: err, s/so you .../do you .../
