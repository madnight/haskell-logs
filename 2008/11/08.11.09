00:00:23 * Beelsebob ponders hacking something like reactivotal
00:00:29 <Beelsebob> the two would be a really excellent match
00:00:58 <sclv> the spreadsheet thing is already frp -- just without a graphical backend.
00:01:15 <Beelsebob> the spreadsheet thing?
00:01:29 <sclv> spreadsheets, in general, or spreadsheet-like things.
00:01:36 <Beelsebob> oh, I see
00:01:37 <Beelsebob> yes
00:02:54 <Beelsebob> I guess what you get with reactivotal is acually called Eros
00:03:03 <Beelsebob> (although with significant polishing)
00:05:25 <rwbarton> jekor: what you're trying to do doesn't fit in the type system well.
00:05:37 <rwbarton> jekor: consider--what if somewhere else someone made String into an instance of Num?
00:06:56 <mmorrow> here's that spreadsheet code i was toying with. it'll read in a "sheet" of (as of now) basic syntax and eval it. it also will prettyprint the dep graph to .dot, call graphviz on that, and run display to show the image: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=462#a462
00:07:43 <rwbarton> jekor: probably the most practical thing to do is to write the definitions for Num instances as ordinary functions (with a Num a class constraint) and then write boilerplate instances for each Num instance you want as an instance of your class
00:09:37 <crutcher> mmorrow: neat.
00:10:14 <jekor> rwbarton: Ah. Didn't think of that. Thanks.
00:10:34 <jekor> I saw mention of creating a type alias of some sort and using that. But I don't know how to do that.
00:11:28 <mmorrow> crutcher: feel free to hack on it if you so desire :)
00:12:06 <crutcher> I might. I'm currently taking another pass through Parsec, now that I'm more comfortable with Monads
00:12:50 <mmorrow> cool. ReadP is really nice because it does a bfs instead of a dfs like Parsec
00:12:56 <mmorrow> so you can write online parsers
00:13:43 <crutcher> oh, btw, have you seen the Graph libs? They have support for generating Graphviz output
00:14:18 <mmorrow> crutcher: yeah, they look nice for sure. i haven't used them much yet though.
00:14:33 <crutcher> just saw that you were doing some dot output.
00:16:38 <mmorrow> yeah, i usually just use Text.PrettyPrint to dump a [(a,[a])] ot .dot, but if i start doing more complicated .dot generation those'll make it more bearable i'm sure
00:17:03 <crutcher> I really wish haddock and ghci were integrated, so I could examine docs interactively ala Python
00:17:44 <Nafai> crutcher: That would be very useful indeed
00:18:30 <crutcher> well, I've got a lot more learnin' to do, so I can help make some of this actually happen, rather than bitch about it.
00:18:35 <mmorrow> crutcher: i have a quicky cgi prog that lets you interactively make graphviz graphs that i find handy: http://moonpatio.com/cgi-bin/graphedit.cgi
00:18:55 <mmorrow> (the radio buttons are for rendering with the various graphviz progs)
00:19:07 <mmorrow> dot,neato,circo,dph,twopi
00:19:24 <mmorrow> err, i think the order is:
00:19:45 <mmorrow> dot,neato,dph,circo,twopi
00:19:58 <Negroid> "Personally, I do not hate niggers at all, I just correctly understand that they are not human and treat them accordingly. They are nothing more than wild niggers running around loose and one must act accordingly around them. A hundred and fifty years or so ago, people in this country treated niggers accordingly and kept them contained and controlled. We made them useful by managing their numbers, containing them, and forcing them to wor
00:19:59 <Negroid> k and be somewhat productive. But the natural empathy of the White man caused him to unrestrain a species of animal (niggers) largely due to the fact they they mimick humans in their behavior and dress. Now that the genie is out of the bottle, he can't be put back in and we're stuck with living around 30 million wild niggers.
00:20:15 <crutcher> heh. graphviz - the most useful, and most unusable program you'll ever write code to think about for you
00:20:36 <dmwit> ?ops
00:20:36 <lambdabot> Maybe you meant: docs oeis pl
00:20:42 <dmwit> ?where ops
00:20:42 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
00:20:50 <Negroid> I am never surprised when I hear stories of TNB; stories of niggers raping, torturing, murdering and beating White people. Stories from Africa of them raping babies, toddlers, and goats; drinking lizard pee and smoking their own shit to get high. The rampant disease and famine there and watching their nigglets die off by the millions while their mammies get gang-banged in the bush to pump out another litter. Nothing about niggers surpris
00:20:50 <Negroid> es me at all because I do not compare their behavior with that of humans.
00:21:00 <glguy> ?
00:21:04 --- mode: ChanServ set +o glguy
00:21:06 <Negroid> The only way to hate niggers and to justify the old, tired whigger accusation that racists are full of hate and spread hate and all that nonsense is only if you consider niggers human. It WOULD fill me up with hate and want to get revenge if a group of humans acted the same way niggers do and created so much misery, pain, and suffering in the world. But if you consider them as the animals that they are - a separate species from human - t
00:21:07 <Negroid> heir actions do not surprise nor cause hate at all.
00:21:09 --- mode: glguy set +b *!*@ip72-207-20-159.sd.sd.cox.net
00:21:37 <crutcher> wow. that was unexpected
00:21:44 <dmwit> glguy: thanks
00:21:49 <glguy> dmwit, good call on the lambdabot command
00:21:56 <glguy> I noticed because of it
00:21:59 --- mode: glguy set -o glguy
00:22:09 * allbery_b noticed also but glguy got there first
00:22:59 <mmorrow> heh, of course i meant s/dph/fpd/
00:23:10 <mmorrow> *fdp
00:23:27 * lispy noticed but got here last
00:24:14 <dmwit> Thanks to all for responding. =)
00:32:38 <pumpkin_> some people are amazing
00:33:11 <pumpkin_> maybe I'll get used to it someday but every time one of those appears on IRC it leaves me feeling kinda depressed for the next half hour
00:34:52 <SubStack> not just this channel either
00:35:00 <pumpkin_> yeah I know
00:35:16 <pumpkin_> it seems to be happening more often with the rise of obama recently
00:35:53 <pumpkin_> I can deal with people who are obviously just trying to piss people off (like the GNAA or something) but when it looks like people actually believe that shit is what gets me down
00:35:55 <pumpkin_> ah well
00:36:06 <jsn> crutcher: regarding your earlier comment on the educational system -- i think that forcing everyone in to college has dramatically raised the prices of seats
00:36:35 <crutcher> yes, it has.
00:37:11 <jsn> so whereas approval was a force of bias in, say, the fifties, we now have price as a major biasing factor
00:37:34 <jsn> the net effect, i think, is to maintain the status quo
00:37:55 <jsn> while improving the overall level of education a bit
00:38:06 <crutcher> jsn: um, no? Many, many more people are recieving education.
00:40:14 <jsn> i don't see how that's actually incompatible with my remark
00:40:21 <crutcher> let me put it this way: if you are concerned that you aren't getting a good enough education, you aren't the best ROI for the education system to focus on. The best outcome is not going to be had teaching more to 'self-starters'. The would learn just as much with a crap system. You want to teach as many people as you can who otherwise _wouldn't_ have learned anything
00:40:37 <crutcher> jsn: what aspect of the status quo has been maintained?
00:40:52 <jsn> the wealthy retain access to the best education
00:41:05 <jsn> and the opportunities associated with it
00:41:11 <pumpkin_> the "best education" has need-based aid doesn't it?
00:42:01 <pumpkin> but I haven't been following the discussion so maybe I'm way off
00:42:55 <crutcher> jsn: no, they don't.
00:43:03 <jsn> crutcher: oh?
00:43:07 <jsn> okay, well
00:43:13 <mmorrow> crutcher: "They would learn just as much with a crap system."
00:43:15 <jsn> there is nothing to say to that
00:43:16 <mmorrow> i beg to differ
00:43:22 <crutcher> the guy who did Freakonomics gave a talk at work a while back
00:43:49 <pumpkin> jsn: I guess I was surprised to find that here they brag about 40% of students getting some form of financial aid, which obviously means that 60% is able to pay the 40k a year
00:43:56 <crutcher> it turns out, the best predictor of 'success', defined as "how much do you make after 10 years", is the best college you applied to.
00:44:01 <crutcher> Not the best college you went to
00:44:28 <crutcher> Harvard is a good school because ambitious people go there
00:44:50 <crutcher> ambitious people also _fail_ to go there, and generally do as well
00:45:12 <crutcher> the question is, how well would harvard educate a mediocre student?
00:45:23 <crutcher> (and clearly, I can't spell very well)
00:46:38 <jsn> pumpkin: here is where?
00:47:08 <pumpkin> a reasonably well known "good school"
00:47:43 <crutcher> Like I said earlier, selection bias totally screws up thinking about education
00:49:31 <jsn> pumpkin: okay, well
00:49:35 <mmorrow> i think this is precisely the problem: " The best outcome is not going to be had teaching more to 'self-starters'. The would learn just as much with a crap system. You want to teach as many people as you can who otherwise _wouldn't_ have learned anything"
00:49:52 <jsn> pumpkin: that is not exactly saying much but i'm sure i can find similar figures on the internet
00:50:25 <dmwit> mmorrow: And a big ol' @#$% you to the people most interested in learning from you.
00:50:26 <mmorrow> that strategy is imo terribly flawed
00:50:42 <crutcher> mmorrow: think of it like this: what's the most I can do with this dollar? Do I incrementally improve the education of someone who's already doing okay, or do I teach someone else to tie their shoes
00:50:42 <pumpkin> jsn: just an empirical observation supporting the "rich people tend to be the majority at 'good schools'"
00:51:25 <crutcher> mmorrow: why is it flawed? I've got some money, I want the best impact on my culture and economy
00:51:35 <jsn> from a whole society perspective, you teach people to tie their shoes
00:51:52 <crutcher> yes, you do. and the clever people grumble about it.
00:52:21 <jsn> you do not, however, need to give people four year degrees in things like english, anthropology, MIS
00:52:40 <jsn> they would be better served by internships and technical schools
00:52:42 <mmorrow> crutcher: i would argue that ensuring that the "self-starters" excel should be more important that making sure everyone can tie their shoes
00:53:26 <jsn> mmorrow: that attitude, taken to its extreme will lead to a lot of dirty bums :)
00:53:38 <crutcher> jsn: I think the important part there is the "four year degree" and not the "in X". Learning to finish something makes them good little salary workers, makes them strategic planners
00:53:45 <mmorrow> jsn: with untied shoes no less
00:54:10 <crutcher> we used to need a lot o fmanual labor
00:54:16 <crutcher> now we need more than that
00:54:34 <crutcher> and the manual labor jobs are being automated away
00:54:46 <jsn> mmorrow: bringing up the mean is valuable to everyone, really -- think about how great it is that we have signs all over the place, because everyone is literate so its worth it to do that!
00:54:54 <jsn> crutcher: not plumbing
00:54:59 <jsn> crutcher: not construction
00:55:07 <rwbarton> jsn: on the other hand, think how great it is that we have computers.
00:55:09 <SubStack> fostering the development of well-rounded, cultured individuals is a pretty healthy thing for a society to be doing
00:55:20 <rwbarton> jsn: 6 billion people being able to read won't produce computers for you.
00:55:20 <crutcher> http://www.technovelgy.com/ct/Science-Fiction-News.asp?NewsNum=57
00:55:22 <crutcher> just wait
00:55:29 <lambdabot> Title: Contour Crafting: 3D House Printer: Science Fiction in the News
00:56:06 <jsn> however -- also from a whole society perspective -- a few bright scientists are a lot better than hundreds of dumb ones
00:56:09 <SubStack> especially since technological progress is getting more interdisciplinary
00:56:29 <jsn> if your going to have specialists, make sure they are special, for goodness' sake
00:56:42 <jsn> s/your/you're/
00:56:43 <crutcher> jsn: I'm not sure I'd agree with that. hundreds of dumb ones can explore a larger problem space
00:56:52 <SubStack> indeed, depends on the problem
00:57:07 <crutcher> I'd say, if its important, better hope its redundant
00:57:15 <pumpkin> not all problems are well suited to parallel computation :P
00:57:31 <dsturnbull> crutcher: that seems to be the essence of modern science anyway
00:58:09 <crutcher> pumpkin: wizardry is not motivated by money, but effort is. Don't pin your hopes on geniuses, they may just want to juggle.
00:58:24 <dsturnbull> maybe in the good old days one insanely intelligent person could invent something... like a light bulb.. wait... ma.. no i can't think of any important concept that wasn't built on the shoulders of others
00:58:42 <pumpkin> of other geniuses?
00:58:43 <pumpkin> :P
00:58:45 <crutcher> dsturnbull: dynamite
00:58:57 <jsn> ah, hmmm
01:00:06 <jsn> this argument has become very generic
01:00:16 <jsn> no matter what we say, it is foolish
01:00:39 <jsn> to side with crutcher, we are saying a million monkeys can write ulysses
01:00:39 <crutcher> jsn: I thought we'd reached the point of violent agreement
01:01:02 <pumpkin> maybe not a million, but infinite monkeys might
01:01:03 <jsn> to disagree with him is to pin our fate on erratic masters
01:01:39 <jsn> s/him/them/
01:01:57 <crutcher> jsn: Hmm, I'd say more: plan for drudger, hope for cleverness, exploit any random genius that shows up.
01:02:05 <crutcher> drudgery
01:03:04 <jsn> the olympics seems to find enough people every four years
01:03:12 <jsn> i think we can plan for that
01:04:02 <crutcher> oh man. That crap. Yeah, its amazing what 20 years of physical and mental abuse can do to 1/100th of the people who go through it.
01:04:17 <crutcher> its so inspiring
01:04:55 <Adamant> yeah, MIT degrees really are impressive
01:05:05 <crutcher> like throwing an entire planeload of people out the window, and calling the 2 freak landings which don't kill the passenger 'talent'
01:05:22 <jsn> crutcher: that is not my point at all
01:05:51 <crutcher> the olympics finds those people by treating many times more very badly for a very long time
01:06:08 <crutcher> and that is my point. The olympics is the end result of drudgery
01:06:41 <crutcher> it suffers from a narrative bias, in that we see the people who weren't selected out, and think in terms of their stories
01:06:52 <Adamant> so is our educational system. your point being?
01:06:54 <jsn> oh my goodness, we are not in #haskell-blah !
01:07:11 <crutcher> jsn: yeah, okay. I'll stop :/
01:07:17 <jsn> well, let's move it over
01:11:10 <paczesiowa> haskell.org down?
01:11:51 <mmorrow> it responds to my pings, but looks like the httpd is down
01:12:46 <ksf> http://downforeveryoneorjustme.com/haskell.org
01:12:56 <lambdabot> Title: Huh?
01:13:18 <ksf> dns problems, too.
01:13:20 <mmorrow> Huh? doesn't look like a site on the interwho.
01:13:24 <mmorrow> ""
01:20:24 <ksf> # Duncan Coutts <dcoutts@gentoo.org> (06 Feb 2008)
01:20:24 <ksf> # Haddock-2.0 is not ready for prime time yet, too many things break.
01:20:24 <ksf> >=dev-haskell/haddock-2.0
01:20:36 <ksf> that's out of package.mask for the gentoo overlay...
01:20:49 <ksf> still up to date?
01:21:05 <paczesiowa> 2.4* is unmasked
01:21:31 <ksf> huh?
01:22:01 <paczesiowa> only 2.2 is masked
01:22:15 <paczesiowa> and 2.0.0.0
01:22:26 <ksf> nah that line says everything above and equal to 2.0 is masked.
01:22:56 <paczesiowa> when was the last time you have synced?
01:23:03 <ksf> my portage tree is only a few days old, and I didn't see anything above 2.2.2
01:23:11 <ksf> in about 30 seconds.
01:23:47 <paczesiowa> # Ivan Miljenovic <Ivan.Miljenovic@gmail.com> (06 Nov 2008)
01:23:49 <paczesiowa> # Haddock-2.4 works with most packages, only mask 2.0 and
01:23:50 <paczesiowa> # 2.2 versions until we delete them.
01:23:52 <paczesiowa> =dev-haskell/haddock-2.0.0.0
01:23:53 <paczesiowa> =dev-haskell/haddock-2.2*
01:24:29 <ksf> are we using the same overlay?
01:24:51 <paczesiowa> are there more than one?
01:25:49 <paczesiowa> darcs+http://code.haskell.org/gentoo/gentoo-haskell/
01:25:49 <lambdabot> Title: Index of /gentoo/gentoo-haskell
01:26:11 <ksf> that's what I got, too.
01:26:16 <ksf> and eix tells me
01:26:22 <ksf>      Available versions:  0.7[1] 0.8 0.8[1] (~)0.9 (~)0.9[1] [M](~)2.0.0.0[1] [M](~)2.2.1[1] {M}(~)2.2.2[1]
01:26:32 <paczesiowa> http://code.haskell.org/gentoo/gentoo-haskell/profiles/package.mask
01:26:33 <lambdabot> http://tinyurl.com/6fu88w
01:26:42 <paczesiowa> maybe update-eix
01:29:39 <ksf> I guess my problem is that eix-sync stopped to run layman.
01:30:40 <paczesiowa> I use paludis with hooks to update eix cache after syncing
01:35:36 <mmorrow> @nixon
01:35:36 <lambdabot> I don't want to see this country to go that way.  You know what happened to the Greeks.  Homosexuality destroyed them. Sure, Aristotle was a homo, we all know that, so was Socrates.
01:35:43 <mmorrow> @nixon
01:35:43 <lambdabot> People react to fear, not love; they don't teach that in Sunday School, but it's true.
01:36:00 <mmorrow> @nixon
01:36:01 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
01:36:16 <mmorrow> @nixon
01:36:16 <lambdabot> Americans admire a people who can scratch a desert and produce a garden. The Israelis have shown qualities that Americans identify with: guts, patriotism, idealism, a passion for freedom. I have
01:36:16 <lambdabot> seen it. I know. I believe that.
01:36:50 <mmorrow> wheretf did these quotes come from?
01:37:47 <mmorrow> well, a google search just answered that
01:37:56 <mmorrow> @go nixon quotes
01:37:59 <lambdabot> http://www.brainyquote.com/quotes/authors/r/richard_m_nixon.html
01:37:59 <lambdabot> Title: Richard M. Nixon Quotes
01:38:36 <mmorrow> If you take no risks, you will suffer no defeats. But if you take no risks, you win no victories.
01:39:39 <mmorrow> heh
01:39:40 <mmorrow> Never say no when a client asks for something, even if it is the moon. You can always try, and anyhow there is plenty of time afterwards to explain that it was not possible.
01:40:01 <mmorrow> People have got to know whether or not their president is a crook. Well, I'm not a crook.
01:41:12 <paczesiowa> what is a LANGUAGE pragma for mr?
01:41:45 <mmorrow> {-# LANGUAGE NoMonomorphismRestriction #-}
01:41:48 <mmorrow> ?
01:41:58 <mmorrow> (is that what you meant?)
01:42:24 <ksf> -flet-my-program-run
01:42:35 <mmorrow> -flet-my-people-go
01:42:49 <paczesiowa> doesn't work
01:42:59 <mmorrow> what doesn't work?
01:43:06 <paczesiowa> cannot parse LANGUAGE pragma
01:43:09 <vegai> wow, Nixon seems like a reasonable fellow
01:43:14 <mmorrow> what ghc are you on?
01:43:46 <paczesiowa> oh wait, I have to use one pragma for every LANGUAGE
01:43:51 <ksf> I'd be surprised if he was undecidable.
01:44:03 <paczesiowa> mmorrow: thanks
01:44:16 <mmorrow> paczesiowa: np
01:46:13 <jsn> paczesiowa: you can use commas
01:46:21 <swiert> what is the precedence of >>= ?
01:46:24 <mmorrow> yeah, commas are key
01:46:27 <paczesiowa> anyway, even LANGUAGE pragma doesn't turn off mr inside ghci with loaded module
01:46:34 <mmorrow> , src '(>>=)
01:46:37 <paczesiowa> :i (>>=)
01:46:44 <lunabot>  luna: `(>>=)' is not in scope at a reify
01:46:47 <mmorrow> dang
01:46:49 <paczesiowa> infixl 1 >>=
01:47:49 <swiert> Ok thanks.
01:51:08 <swiert> Any reason why its infixl? I suppose it shouldn't matter.
01:53:08 <paczesiowa> how do I get from Parsec remaining  input?
01:54:01 <ksf> manyTill EOF?
01:54:19 <ksf> something like that.
01:54:41 <paczesiowa> no, I want to run parser and get parse result and remainging output
01:55:07 <jsn> paczesiowa: hmm
01:55:23 <paczesiowa> *input
01:55:37 <swiert> getInput?
01:55:59 <jsn> that's in the Parsec State
01:57:35 <mmorrow> , src '(>>=)
01:57:40 <lunabot>  Class op from Monad: (>>=) :: forall m . Monad m => forall a b . (m a) ->
01:57:40 <lunabot>                                                                   (a -> m ...
01:57:40 <lunabot>                       infixl 1 (>>=)
01:57:44 <mmorrow> woohoo
01:57:54 <mmorrow> needs to be cleaned up though
02:01:28 <paczesiowa> swiert: thanks
02:01:41 <swiert> paczesiowa: np.
02:04:37 <mmorrow> , (\(ClassOpI _ _ _ f)->ppDoc f) $(lift =<< reify '(>>=))
02:04:42 <lunabot>  infixl 1
02:07:25 <mmorrow> , src 'VarI
02:07:32 <lunabot>  Killed.
02:07:38 <mmorrow> , src 'VarI
02:07:45 <lunabot>  Killed.
02:07:47 <mmorrow> grr
02:08:05 <mmorrow> , src 'VarI
02:08:11 <lunabot>  data Info = ... | VarI Name Type (Maybe Dec) Fixity | ...
02:08:11 <lunabot>  infixl 9
02:08:25 <mmorrow> , (\(VarI _ _ _ f)->ppDoc f) $(lift =<< reify '(.))
02:08:30 <lunabot>  infixr 9
02:09:30 <mmorrow> , (\(VarI _ _ _ f)->ppDoc f) $(lift =<< reify '(=<<))
02:09:35 <lunabot>  infixr 1
02:10:21 * mmorrow just realized how to have a :t to go along with `src' (== :i)
02:11:38 <mmorrow> , src 'ClassOpI
02:11:43 <lunabot>  data Info = ... | ClassOpI Name Type Name Fixity | ...
02:11:43 <lunabot>  infixl 9
02:35:34 <C-Keen> any idea why this build fails? http://hpaste.org/11871
02:36:17 <paczesiowa> not enough memory?
02:37:40 <dmwit> 1MB doesn't seem like a controversial amount of memory to request.
02:38:11 <paczesiowa> 1MB too much is enough
02:38:30 <dmwit> *nod*
02:48:22 <Deeem2031> hi, im trying to negate a function p (a->Bool) so i can use it in filter to get the elements that would return false if passed to p. i tried many ways (e.g. filter (-p) xs) but nothing worked - any ideas?
02:48:26 <Peaker> is there a 2d graphics API around OpenGL that hides all the nastiness? (Doesn't need setting up matrices, makes image loading and blitting easy, etc)
02:48:51 <paczesiowa> Deeem2031: not
02:48:55 <kaol> > not True
02:48:56 <lambdabot>   False
02:49:03 <paczesiowa> > filter even [1..10
02:49:04 <lambdabot>   <no location info>: parse error on input `;'
02:49:05 <paczesiowa> > filter even [1..10]
02:49:06 <lambdabot>   [2,4,6,8,10]
02:49:09 <trofi> :t (not.(?p))
02:49:10 <lambdabot> forall a. (?p::a -> Bool) => a -> Bool
02:49:11 <paczesiowa> > filter (not even) [1..10]
02:49:12 <lambdabot>   Couldn't match expected type `Bool'
02:49:17 <Peaker> you can't "not" on an (a -> Bool) function, though,  but you can  (not . func) on that func
02:49:20 <paczesiowa> > filter (not . even) [1..10]
02:49:21 <lambdabot>   [1,3,5,7,9]
02:49:32 <mmorrow> @src break
02:49:33 <lambdabot> break p =  span (not . p)
02:50:15 <Deeem2031> ah, not . p works - thx :)
02:50:22 <mmorrow> :)
02:50:30 <Deeem2031> and whats the point good for?
02:50:42 <mmorrow> heh, you mean (.)?
02:50:47 <Deeem2031> yea
02:50:49 <mmorrow> function composition
02:50:52 <paczesiowa> . is the most important char in haskell
02:50:53 <mmorrow> @src (.)
02:50:54 <lambdabot> (f . g) x = f (g x)
02:50:54 <Peaker> Deeem2031: (a . b) x = a (b x)
02:50:59 <trofi> > 1 + . 2
02:50:59 <lambdabot>   <no location info>: parse error on input `.'
02:51:10 <Deeem2031> ah k - thx for the help
02:51:11 <mmorrow> main = print . length . lines =<< getContents
02:51:33 <mmorrow> it's kinda like | in sh, but flipped around
02:51:42 <paczesiowa> although it's weird that it isn't flipped
02:51:54 <paczesiowa> making us reading from right to left
02:52:10 <mmorrow> well, you apply functions that way
02:52:10 <paczesiowa> can't fight the tradition:/
02:52:25 <trofi> :t (.)
02:52:25 <mmorrow> otherwise we'd be writing
02:52:26 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:52:30 <mmorrow> 42 print
02:52:44 <trofi> :t flip
02:53:06 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:53:51 <paczesiowa> mmorrow: keep it quiet, or slava will come and preach about those stacks
02:54:00 <mmorrow> hehe
02:54:04 <trofi> @pl r `revdot` l = l . r
02:54:05 <lambdabot> (line 1, column 14):
02:54:05 <lambdabot> unexpected "="
02:54:05 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
02:54:27 <mmorrow> @pl \f g -> g . f
02:54:27 <lambdabot> flip (.)
02:54:42 <paczesiowa> flip (.) = (>>>)
02:54:47 <trofi> @pl revdot r l = l . r
02:54:47 <lambdabot> revdot = flip (.)
02:54:55 <mmorrow> (>>>) = flip (.)
02:54:57 <mmorrow> :)
02:55:22 <mmorrow> (.) = (flip . flip) (.)
02:55:42 <mmorrow> (>>>) = (flip . flip . flip) (.)
03:00:28 <jmg> hi
03:00:46 <paczesiowa> bye
03:01:00 <paczesiowa> hi:>
03:01:16 <jmg> re
03:01:50 <jmg> can anybody tell me where to find some documentation about yi?
03:02:30 <paczesiowa> there is yi blog
03:03:18 <paczesiowa> and great howto to some scripting but it is heavily outdated
03:04:10 <paczesiowa> http://www.nobugs.org/developer/yi/
03:04:21 <lambdabot> Title: Getting started with Yi, the haskell editor
03:04:24 <jmg> i would like to learn how to customize it and how to write a major mode
03:04:51 <paczesiowa> so do I:>
03:05:04 <jmg> ah, yes i have found that, but  it is outdated, isn't it?
03:05:27 <paczesiowa> jmg: I tried yi-0.4 and none of it worked with that version
03:05:36 <paczesiowa> now it is probably even worse
03:06:06 <jmg> so, it seems there is no docs beside the source
03:06:43 <paczesiowa> and I didn't like the source too much
03:07:10 <paczesiowa> looked like ugly hack factory
03:07:23 <jmg> :-) something like that
03:07:38 <jmg> perhaps i am just missing the right entry point
03:07:57 <paczesiowa> so I wouldn't write anything atm, it will break anyway with next release
03:09:33 <jmg> too sad
03:10:10 <paczesiowa> yeah, gotta stick with emacs for now
03:10:16 <jmg> currently i am looking for a long term replacement of my emacs+customizations, and i hope yi could be it
03:10:28 <C-Keen> paczesiowa, dmwit: indeed my ulimits have been to conservative
03:14:26 <mmorrow> jmg: me too. i think reading the source is the one and only real entry point. :)
03:14:48 <mmorrow> (for better or for worse)
03:15:38 <jmg> so, it will take much longer to find the entry
03:15:49 <jmg> but i guess i have to do it the hard way
03:16:29 <mmorrow> you'll eventually have to know the code to make it do what you want. i figure now's the best time, since it'll only grow in complexity :)
03:16:50 <mmorrow> (of course that's half me just trying to rationalize it)
03:16:55 <mmorrow> ;)
03:18:30 <jmg> no, i think you are right. now is the time to find an entry and perhaps to influence it
03:19:09 <paczesiowa> ksf: if you remember my yesterday problem, could you take a look at http://hpaste.org/11873 ? I get empty output if I don't force it with print
03:22:21 <ksf> you gotta force the computation somewhere, that's for sure.
03:22:27 <ksf> that's the whole point of laziness.
03:22:50 <paczesiowa> well, forcing it at the end should work
03:23:25 <ksf> actually, I'm not sure about that hClose.
03:23:33 <paczesiowa> maybe I close it too early?
03:23:47 <paczesiowa> and should force final result before hClose? makes sense?
03:25:41 <ksf> just try it.
03:25:49 <Lemmih> paczesiowa: hGetContents will close the handle once it reaches the end.
03:26:11 <paczesiowa> ksf: yeah, that was it
03:26:25 <paczesiowa> ksf: thanks
03:26:52 <paczesiowa> Lemmih: problem is it's not that easy to reach the end
03:27:25 <ksf> well you can call hClose at any time if you think it's wise.
03:27:30 <ksf> like if you're flooded.
03:27:48 <ksf> or the peer doesn't know your syntax.
03:27:51 <paczesiowa> but I have to force result before hClose
03:28:29 <ksf> yeah, and you can hClose or not, depending on result.
03:28:47 <ksf> hClose is going to end the stream hGetContents returns, then.
03:29:18 <ksf> ...which is only a potentially, not necessarily infinite list.
03:31:03 <ksf> "before" is a nasty concept in this context.
03:31:38 <paczesiowa> well if I print result inside runTelnetM beore hClose it works
03:31:40 <ksf> think of data dependencies instead.
03:32:40 <paczesiowa> it's not that easy in presence of lazy IO
03:33:10 <ksf> that's why I'm trying hard not even to imagine calling hClose before you've got some data ;)
03:34:44 <paczesiowa> if I print that data, then I can hClose, it's forced and mine till gc do us apart
03:34:55 <ksf> the main culprit is that responseStream isn't completely defined when you call runStateT, but depends on actions further on.
03:35:32 <ksf> ...which is just slightly less confusing that goto's mixed with continuations.
03:36:22 <paczesiowa> right, but printing result after runStateT must force it
03:36:24 <mmorrow> jmg: totally.
03:36:34 <paczesiowa> or else I get some magic answer (which is not that bad)
03:37:56 <ksf> so you must do some forcing inside the io monad before calling hClose, which works fine iff you eg. hClose if the user gives a quit command.
03:38:21 <ksf> ...as you gotta force the parsing of quit to figure out that you want to hClose.
03:41:08 <paczesiowa> what was the name of that thing to force smth totally ? like megaSeq, because I don't really want to print anything
03:41:27 <vixey> rnf
03:41:36 <paczesiowa> :t rnf
03:41:37 <lambdabot> forall a. (NFData a) => a -> Done
03:41:43 <paczesiowa> :i rnf
03:41:52 <paczesiowa> @where rnf
03:41:53 <lambdabot> I know nothing about rnf.
03:42:23 <vixey> @index rnf
03:42:23 <lambdabot> Control.Parallel.Strategies
03:42:44 <paczesiowa> vixey: thx
03:42:53 <mmorrow> jmg: also, this is a good paper related to Yi, although it looks like recent versions of Yi have moved away from the dynamic eval/compilation/loading of code, but i want to add this stuff back in in one way or another: http://www.cse.unsw.edu.au/~dons/papers/yi.pdf
03:42:56 <lambdabot> Title: Dynamic Applications From the Ground Up
03:42:56 <vixey> An error occurred while extracting files: (null)
03:42:58 <vixey> great...
03:43:15 <mmorrow> , rnf ()
03:43:21 <lunabot>  ()
03:43:56 <mmorrow> in case anyone was wondering, i think lunabot's in vmware/equivalent, hence the sluggishness...
03:44:18 <paczesiowa> what package do I need for those Strategies?
03:44:25 <mmorrow> (so this is not indicative of the performance of the ghc-api under 6.10)
03:44:50 <mmorrow> Control.Parallel.Strategies
03:45:09 <paczesiowa> Could not find module `Control.Parallel.Strategies':
03:45:41 <mmorrow> $ ghc-pkg list parallel
03:45:42 <mmorrow> ?
03:45:57 <paczesiowa> thanks
03:46:36 <mmorrow> i'd be surprised if you don't have it. it's one of the core libs
03:46:58 <paczesiowa> I don't
03:47:15 <mmorrow> http://darcs.haskell.org/libraries/parallel/
03:47:16 <lambdabot> Title: Index of /libraries/parallel
03:47:23 <mmorrow> where'd you get your ghc from?
03:47:28 <paczesiowa> gentoo
03:47:32 <mmorrow> (maybe it's in extralibs then i guess)
03:47:33 <Kerris4> mmorrow: a REPL of sorts in Yi would be awesome :)
03:47:40 <paczesiowa> I'm already emerging that library
03:47:42 <vixey> ooo
03:47:43 <mmorrow> Kerris4: totally!
03:48:58 <jmg> mmorrow:  i'v read that paper this week
03:49:28 <mmorrow> nice, an interesting paper for sure
03:49:43 <jmg> and i agree with you that it would be gread if the generic  dynamic reloading stuff should be  used
03:50:08 <jmg> but i am still not sure whether that is still part of yi or not
03:50:55 <paczesiowa> I think it is
03:50:59 <paczesiowa> why wouldn't it
03:51:09 <mmorrow> yeah, they seem to have ditched it. i think though this is partly because the ghc-api has been so unstable recently.
03:51:25 <jmg> if it is still used by lambdabot and yi, why is it not released as a library?
03:51:38 <paczesiowa> so if I change key bindings I have to restart yi?
03:52:04 <vixey> @pl (\left' right' -> branch (left left') (right right'))
03:52:04 <lambdabot> (. right) . branch . left
03:52:06 <mmorrow> paczesiowa: i'm not 100% sure how it currently works, but am slowly grokking the code.
03:52:08 <vixey> ://///
03:52:10 <vixey> this sucks
03:52:45 <mmorrow> vixey: ?
03:52:55 <vixey>  (. right) . branch . left
03:53:01 <mmorrow> ah
03:53:34 <mmorrow> @pl (\right' left' -> branch (left left') (right right'))
03:53:34 <lambdabot> flip (branch . left) . right
03:53:38 <mmorrow> hmm
03:56:07 <vixey> hasakell-mode does not display . as a ring
03:56:43 <jmg> do you mean emacs haskell-mode?
03:56:48 <vixey> yeah
03:56:56 <dolio> It does if you enable a certain option.
03:57:18 <jmg> (setq haskell-font-lock-symbols 'unicode)
03:57:40 <jmg> at least it works in aquamacs emacs on os x
03:58:23 <vixey> :(
03:58:32 <vixey> that just makes the phi symbol turn into a box
03:59:06 <xd> you prolly dont have a unicode font active
03:59:13 <jmg> perhaps you are missing a font?
03:59:20 <xd> one with that symbol anyway
04:00:47 <jimstutt> vegai: I'm getting the supposedly fixed ghc-pkg bug 2201 having installed everything as root.
04:01:58 <jimstutt> vegai: on ghc 6.10.1
04:09:43 <vixey> what font is the best
04:09:56 <vixey> anything fixed width that supports lots of unicode?
04:10:03 <Zao> vixey: DejaVu Sans Mono is sane
04:10:20 <vixey> thanks ill try it out
04:12:21 <cnwdup> Can anyone give me the name of a lambdabot's plugin which uses information saved by a different plugin?
04:12:21 <paczesiowa> how do I use that rnf inside IO?
04:31:34 <vixey> @pl (f (g (x:)))
04:31:34 <lambdabot> f (g (x :))
04:31:39 <vixey> @pl \f g x -> (f (g (x:)))
04:31:39 <lambdabot> (. (. (:))) . (.)
04:32:06 <Deewiant> f . g . (:)
04:35:23 <MarcWeber> dcoutts_: ping
04:41:10 <Badger> o_O
04:41:11 <Badger> Configuring haskell-src-exts-0.3.9...
04:41:11 <Badger> cabal: happy version >=1.17 is required but it could not be found.
04:41:20 <Badger> that's not a listed dependency
04:44:27 <jimstutt> dcoutts: I'm getting ticket 2201 msgs on ghc-6.10.1 archlinux. Has a patch unfixed it?
04:47:10 <jmg> I'm getting it, too on os x with ghc-6.10.1
04:50:22 <u_quark> @kind  forall a. a -> a
04:50:23 <lambdabot> *
04:50:37 <u_quark> is that so ?
04:50:49 <EvilTerran> yep; it's a type proper, not a type constructor
04:50:59 <u_quark> ahaa
04:51:07 <vixey> u_quark: if there is a value with type  t  then  t :: *
04:51:08 <u_quark> @kind  Maybe
04:51:09 <lambdabot> * -> *
04:51:12 <u_quark> ic
04:51:59 <rog> @hello
04:52:00 <lambdabot> Maybe you meant: help tell
04:52:07 <EvilTerran> @vixen hello
04:52:08 <lambdabot> hello there
04:53:59 <Badger> @vixen good grief
04:53:59 <lambdabot> good good
04:54:53 <EvilTerran> @. vixen nixon
04:54:53 <lambdabot> well find out then
04:56:10 <Deewiant> @. vixen ghc
04:56:11 <lambdabot> why do you keep repeating yourself?
04:57:11 <Badger> @vixen liver
04:57:11 <lambdabot> you know what? if we'd known it was going to be like this we'd have picked our own goddamn cotton!
04:57:28 <Deewiant> @ghc
04:57:28 <lambdabot> ghc says: Illegal polymorphic type
04:57:55 * Badger hates inconsistent build environments.
04:57:58 <EvilTerran> @@ @@ @read @run let s = (@show @nixon) in show s ++ " @show @vixen " ++ s
04:58:00 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
04:58:01 <EvilTerran> buu
04:58:24 <Deewiant> @@ @read @run let s = (@show @nixon) in show s ++ " @show @vixen " ++ s
04:58:26 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
04:58:51 <EvilTerran> it works in pm, but not here for some reason. i guess because the lines get truncated
04:58:59 <Deewiant> @@ @read @run let s = (@show @nixon) in show s
04:59:01 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
04:59:07 <Deewiant> hmph
04:59:26 <Deewiant> @@ @read @run let s = (@show @nixon) in show (take 50 s)
04:59:27 <lambdabot>  "Finishing second in the Olympics gets you silver. "
04:59:29 <EvilTerran> @run let s = (@show @nixon) in s
04:59:30 <lambdabot>   <no location info>: parse error on input `@'
04:59:35 <EvilTerran> @@ @run let s = (@show @nixon) in s
04:59:36 <lambdabot>   "You won't have Nixon to kick around anymore, because, gentlemen, this is m...
04:59:45 <Deewiant> @@ @@ @read @run let s = take 20 (@show @nixon) in show s ++ " @show @vixen " ++ s
04:59:47 <lambdabot>  "A man who has never " "Bollox!"
04:59:52 <hoknamahn> guys, is it okay than binary tree has at least one node which is leaf and empty tree has one leaf with empty value? just want to be sure that I'm doing it in proper way
04:59:52 <EvilTerran> there's the problem, i think; @read can't deal with that truncation
05:00:04 <Deewiant> yeah, because there's no final quotation mark
05:00:29 <EvilTerran> i wouldn't've expected it to truncate until it'd finished running commands, but oh well
05:00:59 <b_jonas> Deewiant: you may want the @? command instead of @@
05:01:15 <Deewiant> may I? :-)
05:01:15 <EvilTerran> b_jonas, aren't they identical?
05:01:25 <EvilTerran> @? @run 1+2
05:01:27 <lambdabot>   3
05:01:31 <Deewiant> @@ ?run 1+2
05:01:33 <lambdabot>   3
05:01:34 <EvilTerran> ?? ?@ @? @@ @run 1+2
05:01:36 <lambdabot>   3
05:01:41 <Deewiant> heh
05:01:57 <b_jonas> EvilTerran: hmm, help says they are
05:01:58 <b_jonas> sorry
05:02:08 <b_jonas> I thought they had slightly different syntax
05:02:08 <aeolist> never knew addition could be so much fun!
05:02:10 <b_jonas> sorry
05:03:43 <EvilTerran> @. vixen vixen how are you today?
05:03:43 <lambdabot> i'm glad, i'm good too
05:04:13 <luite> what is a simple function for [(1,2),(3,4)] -> [1,2,3,4] ?
05:04:16 <Saizan> Badger: dependecies on tools like happy are not tracked yet
05:04:42 <EvilTerran> luite, concatMap (\(x,y) -> [x,y])
05:05:07 <Deewiant> > concatMap (uncurry ((:) >>> (.(:[])))) [(1,2),(3,4)]
05:05:09 <lambdabot>   [1,2,3,4]
05:05:12 <EvilTerran> ?type (.return).(:)
05:05:13 <lambdabot> forall a. a -> a -> [a]
05:05:17 <luite> lol Deewiant :)
05:05:32 <EvilTerran> > concatMap (uncurry $ (.return).(:)) [(1,2),(3,4)]
05:05:33 <lambdabot>   [1,2,3,4]
05:05:34 <luite> EvilTerran: ah that looks clearer than my fold
05:07:42 <b_jonas> @pl \(x,y) -> [x,y]
05:07:43 <lambdabot> uncurry ((. return) . (:))
05:08:16 <EvilTerran> , src 'listify
05:08:40 <lunabot>  listify :: forall r . Typeable r => (r -> Bool) -> GenericQ ([r])
05:08:52 <EvilTerran> , listify (const True) (1,2)
05:08:55 <lunabot>  []
05:08:57 <EvilTerran> hm
05:09:04 <EvilTerran> , listify (const True) (1,2) :: [Int]
05:09:07 <lunabot>  []
05:09:14 <EvilTerran> , listify (const True) (1::Int,2::Int) :: [Int]
05:09:17 <lunabot>  [1,2]
05:09:36 <EvilTerran> , listify (const True) [(1,2)::(Int,Int),(3,4)] :: [Int]
05:09:39 <lunabot>  [1,2,3,4]
05:09:40 <EvilTerran> :D
05:10:07 <mmorrow> hehe
05:10:25 <mmorrow> :)
05:10:36 <EvilTerran> (approximately translates to "pull out everything from this structure that's of type Int")
05:11:12 <mmorrow> i think i have something like that predefined in one of lunabot's files. looking for the name now...
05:11:23 <mmorrow> , listof
05:11:24 <lunabot>  luna: Not in scope: `listof'
05:11:24 <mmorrow> , listOf
05:11:26 <lunabot>  luna: No instance for (GHC.Show.Show (a -> b -> [a]))
05:11:35 <EvilTerran> , listify (\(_::Int) -> True) [(1,2),(3,4)]
05:11:37 <lunabot>  luna: Illegal signature in pattern: Int
05:11:47 <mmorrow> , listOf (undefined::Int) [(1,2)::(Int,Int),(3,4)] :: [Int]
05:11:53 <lunabot>  [1,2,3,4]
05:12:10 <EvilTerran> , src 'listOf
05:12:16 <lunabot>  listOf :: forall a b . (Typeable a, Data b) => a -> b -> [a]
05:12:20 * mmorrow finds the def now
05:12:31 <mmorrow> it's essentially what you just wrote
05:14:05 <mmorrow> listOf :: (Typeable a, Data b) => a -> b -> [a]
05:14:05 <mmorrow> listOf a = listify ((== typeOf a) . typeOf)
05:14:59 <EvilTerran> seems to me that listify (const True) would do the same thing with that type sig
05:15:10 <mmorrow> i this listify (rarely), everywhere, and mkT (well, and typeOf) are the only functions from Data.Generics i ever really use
05:15:32 <mmorrow> EvilTerran: yeah, i didn't think of that
05:16:11 <mmorrow> even better though, you don't need to give an 'a' as the first arg either
05:16:51 <EvilTerran> yeah, it's just doing the job that a type constraint on the return value could do
05:17:01 <mmorrow> totally
05:17:39 <EvilTerran> although, with that first arg and the type sig you used, you can put the constraint on the first arg instead of the return value if you prefer :P
05:18:07 <mmorrow> yeah, hmm
05:18:12 <EvilTerran> listOf a = listify (const True) `asTypeOf` [a] -- who needs explicit types anyway? :P
05:18:21 <mmorrow> that may be more desireable in some situations
05:18:25 <mmorrow> heh
05:18:39 <EvilTerran> er, missed off a parameter there, but you get the idea
05:19:26 <luite> where can I find this listOf?
05:19:59 <mmorrow> luite: listify is in Data.Generics. listOf is a function i defined in luna(bot)'s source
05:20:25 <mmorrow> which is just:
05:20:33 <mmorrow> listOf :: (Typeable a, Data b) => a -> b -> [a]
05:20:33 <mmorrow> listOf a = listify ((== typeOf a) . typeOf)
05:20:53 <luite> ah
05:20:55 <EvilTerran> although it can be written in various ways
05:21:09 <mmorrow> but Evilterran's version lets you put the type constraint on the return type instead
05:21:16 <mmorrow> (of on the first arg)
05:22:19 <EvilTerran> yours would support that too, because the type sig you gave restricts the first arg's type and the return type together
05:22:29 <mmorrow> ah yeah, true
05:22:37 <EvilTerran> , listOf undefined [(1::Int,2::Int),(3,4)] :: [Int]
05:22:41 <lunabot>  [1,2,3,4]
05:23:12 <mmorrow> , listOf' = listOf undefined in listOf' [(1::Int,2::Int),(3,4)] :: [Int]
05:23:13 <lunabot>  luna: parse error on input `='
05:23:17 <mmorrow> , let listOf' = listOf undefined in listOf' [(1::Int,2::Int),(3,4)] :: [Int]
05:23:22 <lunabot>  [1,2,3,4]
05:24:17 <mmorrow> , let listOf' = listOf undefined in listOf' [(1::Int,2::Int),(3,4)] :: (Integer,Integer)
05:24:19 <lunabot>  luna: Couldn't match expected type `(GHC.Integer.Internals.Integer,
05:24:21 <mmorrow> , let listOf' = listOf undefined in listOf' [(1::Int,2::Int),(3,4)] :: [(Integer,Integer)]
05:24:25 <lunabot>  []
05:24:32 <mmorrow> oh heh
05:24:37 <mmorrow> , let listOf' = listOf undefined in listOf' [(1::Int,2::Int),(3,4)] :: [(Int,Int)]
05:24:41 <lunabot>  [(1,2),(3,4)]
05:25:12 <EvilTerran> , let listOf' = listOf undefined in listOf' [(1::Int,2::Int),(3,4)] :: [[(Int,Int)]]
05:25:16 <lunabot>  [[(1,2),(3,4)],[(3,4)],[]]
05:25:22 <EvilTerran> :D
05:25:27 <mmorrow> hehe
05:25:29 <mmorrow> oh, i just remembered my question
05:25:52 <mmorrow> what's the difference between x86_64 and ia64?
05:26:13 <Deeem2031> x64 is from amd and ia64 from intel
05:26:31 <Deeem2031> but x86 is the standard these days
05:26:32 <luite> it's quite different, ia64 is itanium
05:26:34 <Deewiant> x86-64 has since been renamed to AMD64
05:26:37 <Deeem2031> x64 i mean
05:26:52 <Deewiant> x86-64/x64 are more usually terms that refer to both AMD64 and IA64
05:27:03 <Deewiant> or wait
05:27:10 <luite> x86-64 doesn't refer to ia64
05:27:13 <Deewiant> what's the core architecture
05:27:14 <Deewiant> yeah
05:27:20 <luite> ia64 is only used for high end servers :)
05:27:22 <Deewiant> IA64 refers specifically to the itanium, which isn't x86
05:27:35 <mmorrow> just invoked the googlemachine
05:27:38 <Deewiant> ah, EM64T
05:27:39 <mmorrow> yeah, itanium
05:27:42 <Deewiant> that's what I was thinking of
05:27:43 <dermiste> hi folks
05:27:51 <pozic> x64 is a marketing term from MS.
05:27:57 <Deewiant> evidently it's been renamed to Intel 64
05:28:14 <byorgey> hi dermiste
05:28:17 <Deewiant> so we have AMD64 and Intel 64, which are both commonly referred to as x86-64, and x64 is an MS term for x86-64. :-)
05:28:25 <pozic> Deewiant: right
05:28:37 <pozic> Deewiant: I am not sure about the Intel 64.
05:28:56 <Deewiant> http://en.wikipedia.org/wiki/x86-64#Intel_64
05:29:30 <pozic> Deewiant: yes, I also checked.
05:29:44 <Deewiant> I think there are some differences between AMD64 and Intel 64 and the original x86-64 spec.
05:30:23 * mmorrow is trying to make sense of http://darcs.haskell.org/ghc/rts/Linker.c and feels the burn
05:31:15 <Deewiant> is the evil mangler still in use? it's probably even worse
05:31:51 <mmorrow> heh, suprisingly it's definitely worse
05:32:02 <mmorrow> yeah, still used for -fvia-C
05:32:42 <mmorrow> http://darcs.haskell.org/ghc/driver/mangler/ghc-asm.lprl
05:33:09 <Deewiant> gah
05:33:14 <ksf> iirc x86_64 was coined by people who wanted to be politically correct in their #defines as intel started to offer amd64-compatible cpus.
05:33:33 <ksf> it's a bugger to write, so don't do it ;)
05:33:54 <Deewiant> x86-64 was the original spec for 64-bit x86 machines
05:33:59 <mmorrow>  $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s.*|\.globl\s+\S+|\.text|\.data|\.section\s+.*|\.type\s+.*|\.size\s+\S+\s*,\s*\d+|\.ident.*|\.local.*)\n)';
05:34:03 <mmorrow> woohoo!!
05:34:06 <b_jonas> Deewiant: I think no-one calls it just "Intel 64" for that would be confusable with ia64
05:34:15 <Zao> EM64T or whatnot.
05:34:28 <Deewiant> b_jonas: maybe, but that seems to be the official name for it :-)
05:34:32 <ksf> http://www.x86-64.org/
05:34:33 <Deewiant> EM64T being the older name.
05:34:36 <b_jonas> really? I dunno
05:34:37 <lambdabot> Title: AMD64 Homepage
05:34:58 <pozic> Most spell IA64 as IAD (D for disaster).
05:35:00 <Deewiant> $T_PRE_APP	    = 'DONT THINK THIS APPLIES'; # regexp that says what comes before APP/NO_APP
05:35:15 <Japsu> it's funny that linux ran on AMD64 before there even were physical AMD64 chips to test on ;)
05:35:17 <ksf> it's used interchangeably there, and it's the official site for all i know.
05:35:20 <Deewiant> $T_PRE_APP    = 'DOES NOT SEEM TO APPLY';
05:35:27 <Deewiant> I love the uncertainty
05:35:33 <Japsu> I mean, in the wild (AMD released a simulator)
05:35:39 <Saizan> "The _info label is just an address in code
05:35:47 <Saizan> ops
05:36:11 <mmorrow> oh dear
05:36:13 <mmorrow> s/^\tmovl\s+\$${T_US}(.*),\s*(\%e(ax|cx|si|di))\n\tjmp\s+\*\%r\3/\tjmp\t$T_US$1/gm;
05:36:26 <luite> o_O
05:36:42 <Deewiant> (operating on asm with regex)++
05:36:48 <Saizan> mmorrow: the evil mangler as a comment with "..descriptive blob we talked about yesterday.."
05:37:20 <Saizan> @karma regex)
05:37:20 <lambdabot> regex) has a karma of 1
05:37:24 <mmorrow> heh. there should be a "classic mangler quotes" page on the wiki for sure.
05:37:36 <Deewiant> regex)--
05:37:39 <mmorrow> "The HP is a major nuisance."
05:38:25 <EvilTerran> something like @ghc for worrying comments in the source?
05:38:52 <Deewiant> @ghc-src could be funny :-)
05:38:53 <lambdabot> Unknown command, try @list
05:39:05 <ksf> I guess there's an unwritten law here that says don't ever mention c++
05:39:20 <ksf> @karma c
05:39:20 <lambdabot> c has a karma of 0
05:39:24 <ksf> bugger.
05:39:24 <Deewiant> @ghc is all too often boring
05:39:25 <lambdabot> No quotes match. My pet ferret can type better than you!
05:39:27 <askentasken> c++ > haskell¨
05:39:31 <Deewiant> preflex: karma c
05:39:31 <preflex>  karma for c: 41630
05:39:34 <askentasken> @karma c++
05:39:34 <lambdabot> c++ has a karma of 0
05:39:40 <Kerris4> @karma java
05:39:40 <lambdabot> java has a karma of 0
05:39:43 <Kerris4> haha
05:39:45 <askentasken> lol and i do c++ ++?
05:39:50 <askentasken> c++ ++
05:39:56 <Deewiant> c++++
05:39:59 <Deewiant> @karma c++
05:40:00 <lambdabot> c++ has a karma of 1
05:40:05 <askentasken> ah
05:40:06 <askentasken> lol
05:40:06 <EvilTerran> c++-- i disagree
05:40:07 <mmorrow> "toss all epilogue stuff; again, paranoidly"
05:40:08 <askentasken> c++--
05:40:16 <Kerris4> @karma c++
05:40:17 <lambdabot> c++ has a karma of -1
05:40:22 <ksf> there's also c--
05:40:22 <mmorrow> oh classic:
05:40:25 <mmorrow> "I have no idea why, and I don't think it is necessary, so let's toss it."
05:40:27 <askentasken> @karma ghc
05:40:27 <lambdabot> ghc has a karma of 0
05:40:32 <askentasken> @karma haskell
05:40:32 <lambdabot> haskell has a karma of 46
05:40:42 <askentasken> ghc++
05:40:59 <Deewiant> @ghc
05:41:00 <lambdabot> ghc says: Info table already?
05:41:17 <mmorrow> "Let's live dangerously and discard these initalisations."
05:43:16 <mmorrow> evil-danger-is-my-middle-name-mangler++
05:44:36 <pozic> mmorrow: that linker code looks more evil to me.
05:45:56 <mmorrow> pozic: yeah, they're both pretty friggin evil
05:46:43 <luite> is there some groupBy like function, that can fill 'gaps', like this? [0,2,2,4] -> [[0],[],[2,2],[],[4]]
05:46:46 <ksf> c-- < ++c
05:47:04 <ksf> there's no way around it.
05:47:24 <ksf> but then, c-- = c++
05:47:44 * ksf likes to make his c semantics cry out in despair
05:48:14 <Deewiant> whether c-- == c++ or not is implementation-defined (or even undefined?)
05:48:35 <EvilTerran> luite, don't think so, but you could defint it in terms of group(By)
05:48:46 <Deewiant> > intersperse [] $ group [0,2,2,4]
05:48:48 <lambdabot>   [[0],[],[2,2],[],[4]]
05:49:03 <ksf> It's those things you don't want to know about c because you don't want to write in these ways.
05:49:27 <ksf> but I bet rvalues are specified to be evaluated before lvalues.
05:49:44 <Deewiant> nope
05:49:47 <pozic> ksf: AFAIK, it's undefined.
05:49:50 <luite> Deewiant: oh, my example may not have been clear enough: [1,2,4] -> [[1],[2],[], [4]], it should return sublists grouped by value, and an empty list if that value is missing
05:51:07 <ksf> Somehow, I can't get the concept of "onordered monadic >>" out of my head.
05:51:16 <ksf> *unordered
05:51:58 * EvilTerran 's brain melts trying to think about implementation of an equational-reasoning-based proof assistant
05:52:10 <ksf> like saying "kissGirl a <<?>> kissGirl b", where you don't really care about the ordering of execution.
05:52:52 <EvilTerran> i think the girls would be ordering your execution fairly promptly :P
05:53:16 <ksf> you're having evil operational thoughts there ;)
05:54:12 <luite> EvilTerran: do you think it can still be done in terms of group, given my second example?
05:55:17 <EvilTerran> luite, i think so, but it'd be more complicated, as group doesn't think about ordering
05:55:36 <luite> EvilTerran: that's no problem, the lists are sorted
05:58:25 <EvilTerran> luite, i think it'd probably be easiest with explicit recursion, although span would help
06:02:08 <EvilTerran> > let groupWithSpaces [] = []; groupWithSpaces (x:xs) = go x (x:xs); go i [] = []; go i xs = is : go (succ i) xs' where (is,xs') = span (==i) xs in groupWithSpaces [1,1,2,4,5,8]
06:02:19 <lambdabot>   [[1,1],[2],[],[4],[5],[],[],[8]]
06:02:55 <luite> ah thanks
06:02:59 <EvilTerran> note the ordering is a precondition; it'll probably explode if it's unordered
06:04:01 <Deewiant> > let foo [] = []; foo xs = go (pred $ head xs) (group xs) where go _ [] = []; go prev (y:ys) = if succ prev == head y then y : go (head y) ys else map (const []) [succ prev..pred $ head y] ++ go (pred $ head y) (y:ys) in foo [1,2,2,4,8]
06:04:05 <Deewiant> :-/
06:04:08 <lambdabot>   [[1],[2,2],[],[4],[],[],[],[8]]
06:04:09 <Deewiant> twice as long and twice as ugly
06:04:14 <Deewiant> Deewiant--
06:04:39 <luite> yes, that's why I sort the lists first. It's actually for collecting arcs from a list, and make it suitable for zipping with a list of nodes
06:04:44 <ziman> @karma Deewiant
06:04:45 <lambdabot> Deewiant has a karma of -1
06:04:53 <Deewiant> preflex: karma Deewiant
06:04:54 <preflex>  karma for Deewiant: 1
06:05:02 <luite> so I don't have lists of Int, but of a tuple, but that's just a minor difference :)
06:05:16 <EvilTerran> well, that'll mean succ won't work
06:05:20 <EvilTerran> nor will (+1)
06:05:29 <Deewiant> ?instances Enum
06:05:30 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
06:06:07 <EvilTerran> so how are you deciding how many []s should between any two particular elements?
06:07:57 <mmorrow> i think this file has both Linker.c and the mangler beat (maybe) http://moonpatio.com/repos/glibc-2.7/elf/tls-macros.h
06:08:46 <mmorrow> i vomitted a little in my mouth when i opened that file :)
06:09:05 <mmorrow> thought i'd share it with the channel
06:09:34 <EvilTerran> gee thanks -.-
06:09:38 <luite> EvilTerran: depends on the direction :)   each arc is (parent,child), when adding the outgoing arcs, the list is sorted on fst, for example [(0,4),(3,5),(3,6),(4,7)], this should result in [[4],[],[],[5,6],[7]]
06:10:14 <luite> the gap size is the gap between the 'fst' of adjacent elements in the list
06:10:17 <mmorrow> anywho, i just glibc sources here. i find them highly amusing to browse : put http://moonpatio.com/repos/glibc-2.7/
06:10:18 <lambdabot> Title: Index of /repos/glibc-2.7
06:10:21 <EvilTerran> ahhhhhhhhhh
06:10:41 <EvilTerran> and then you're throwing away the fsts?
06:10:56 <luite> yes
06:11:09 <EvilTerran> do you want to always start from 0, then?
06:11:37 <EvilTerran> (ie, if the incoming list is [(2,...), ...], the output would start [[],[],...])
06:11:55 <luite> hm, yes, seems my example was wrong
06:12:26 <Deewiant> > let groupWithSpaces = go 0; go i [] = []; go i xs = is : go (succ i) xs' where (is,xs') = span (==i) xs in groupWithSpaces [2,2,4,7]
06:12:27 <lambdabot>   [[],[],[2,2],[],[4],[],[],[7]]
06:12:36 <Deewiant> easy enough to fix :-P
06:14:01 <luite> I think go i [] = [] should be = repeat []
06:14:21 <Deewiant> so from 0 to infinity?
06:14:24 <luite> at least for my application :)
06:14:36 <Deewiant> why not negative infinity to infinity? ;-)
06:14:37 <luite> yes, there may be no arcs to or from the last nodes
06:15:03 <luite> and then I can zip with a list of nodes, and always have enough elements in my incoming-arcs-for-each-node-list :)
06:15:03 <Deewiant> repeat [] ++ ... ++ repeat [] :-)
06:20:18 <luite> > let groupWithSpaces = go 0; go i [] = []; go i xs = (map snd is) : go (succ i) xs' where  (is,xs') = span ((==i).fst) xs in groupWithSpaces [(0,4),(3,5),(3,6),(4,7)]
06:20:19 <lambdabot>   [[4],[],[],[5,6],[7]]
06:22:55 <JuanDaugherty> 6.10 is not the "best", in the sense of most stable and most likely to work with existing packages, is it?
06:23:16 <mmorrow> JuanDaugherty: what do you mean by "stable"?
06:23:19 <luite> I think 6.8.3 is more likely to work with existing packages
06:23:30 <JuanDaugherty> luite, thanks!
06:23:47 <Deewiant> there are some packages that only work with any one of 6.4, 6.6, 6.8, 6.10 out there...
06:23:50 <luite> but those should probably be fixed :)
06:24:01 <mmorrow> then again, all packages will be being made to work with 6.10 in the near future
06:24:18 <Deewiant> for small values of 'all' ;-)
06:24:25 <luite> I'd use 6.10 unless you need some specific package that is not yet updated
06:24:27 <JuanDaugherty> <- lives in the past and present.
06:24:34 <mmorrow> i think only the stragglers are not 6.10-ready :)
06:24:35 <RayNbow> luite, do you still need that function to do that vertices stuff?
06:24:38 * mmorrow ducks
06:25:11 <luite> RayNbow: if you have a better one than the one I just showed (thanks to EvilTerran and Deewiant), then yes :)
06:25:27 <JuanDaugherty> luite, why is that?
06:25:29 <EvilTerran> would it be wise to uninstall 6.8.2 before installing 6.10?
06:25:44 <mmorrow> JuanDaugherty: well, because 6.10 is a better compiler.
06:25:52 <mmorrow> which produces better code :)
06:25:58 <JuanDaugherty> in what sense?
06:26:02 * EvilTerran is slightly wary about throwing one install over the top of another one and praying it works
06:26:57 <JuanDaugherty> i'd prolly use 6.10 for dev, 6.8.3 for prod, if that's a distinction that can penetrate in this space.
06:27:04 <EvilTerran> > [0::Micro ..]
06:27:06 <lambdabot>   [0.000000,0.000001,0.000002,0.000003,0.000004,0.000005,0.000006,0.000007,0....
06:27:11 <Deewiant> ?index Micro
06:27:11 <lambdabot> bzzt
06:27:12 <mmorrow> in terms of the asm generated, and the parallel gc, and the fixes to the language features broken in 6.8
06:27:14 <Deewiant> ?hoogle Micro
06:27:15 <lambdabot> Data.Fixed type Micro = Fixed E6
06:27:15 <lambdabot> package microbench
06:27:15 <lambdabot> package sat-micro-hs
06:27:27 <mmorrow> plus, it has new language extensions implemented as well
06:27:28 <RayNbow> luite, http://hpaste.org/11879
06:27:32 <EvilTerran> > [0::Pico ..]
06:27:34 <lambdabot>   [0.000000000000,0.000000000001,0.000000000002,0.000000000003,0.000000000004...
06:27:37 <Deewiant> hmm
06:28:23 <Deewiant> it seems that only those two exist
06:28:41 <Deewiant> Why's that? Can't it generalize easily to any precision?
06:29:18 <EvilTerran> well, you'd need type-level natural numbers, but in theory, yes
06:29:25 <Deewiant> Or is it just that it's too inconvenient to use since we can't give numbers at the type level
06:29:28 <EvilTerran> some wouldn't consider that "easy"
06:29:36 <Deewiant> Yeah
06:30:02 <EvilTerran> for most purposes where Fixed would be useful, Ratio works too
06:33:16 <RayNbow> @karma twanvl
06:33:17 <lambdabot> twanvl has a karma of 0
06:33:19 <RayNbow> twanvl++
06:34:10 <Deewiant> preflex: karma twanvl
06:34:10 <preflex>  karma for twanvl: 1
06:35:51 <RayNbow> <3 twanvl's mergeByR <3
06:37:36 <besiria> can't cabal-install hmatrix
06:38:30 <besiria> http://hpaste.org/11881 output
06:41:47 <pozic> besiria: you don't have the c libs.
06:42:06 <pozic> besiria: there is nothing wrong with the package.
06:43:20 <besiria> pozic: what libs exactly am i missing
06:43:21 <Deewiant> except that maybe it could tell you that you need the C libs :-P
06:43:24 <Taejo> @undo [1..100]
06:43:24 <lambdabot> [1 .. 100]
06:43:35 <Taejo> > enumFromTo 1 10
06:43:36 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
06:43:40 <hoknamahn> guys, could you say where mistake is in this code?
06:43:43 <hoknamahn> kdtreeFlatten :: KDTree Point -> [Point]
06:43:43 <hoknamahn> kdtreeFlatten (L x) = [x]
06:43:53 <hoknamahn> kdtreeFlatten (B1 a l) = a : (kdtreeFlatten l)
06:43:53 <hoknamahn> kdtreeFlatten (B2 a l r) = a : (kdtreeFlatten l) : (kdtreeFlatten r)
06:43:57 <hoknamahn> ?
06:44:17 <hoknamahn> ectually mistake is in last line but I'm not sure how to fix it
06:44:35 <Deewiant> the type of kdtreeFlatten l and kdtreeFlatten r are both [Point], no?
06:44:41 <Deewiant> so you can't join them together with :
06:44:46 <Deewiant> you want ++
06:44:58 <hoknamahn> arrrh thanks Deewiant!
06:45:08 <Deewiant> heh, no problem
06:46:12 <PeakerWork> @pl [1..100]
06:46:13 <lambdabot> [1..100]
06:46:38 <Deewiant> @pl (\x y -> [x..y]) 1 100
06:46:39 <lambdabot> [1..100]
06:46:48 <PeakerWork> hoknamahn: you might want a catamorphism on the tree ...
06:47:11 <Taejo> @pl (\x y -> [x..y])
06:47:11 <lambdabot> enumFromTo
06:47:51 <jpcooper> @hoogle m a -> (b -> m a -> m b) -> (b -> m b)
06:47:51 <lambdabot> No results found
06:48:13 <jpcooper> @hoogle m a -> (m a -> b -> m b) -> (b -> m b)
06:48:13 <lambdabot> No results found
06:49:05 <Valodim> oohh ghc6.10. sweet :D
06:49:07 * Valodim read
06:49:07 <jpcooper> @hoogle m a -> (b -> a -> m b) -> (b -> m b)
06:49:07 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
06:49:07 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
06:49:07 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
06:49:26 <jpcooper> Valodim, where have you been?
06:49:26 <hoknamahn> PeakerWork, I know it's shame but I don't know what catamorphism is :)
06:50:09 <Valodim> I just recently compiled ghc when I set up my notebook.. huh. Must have been on November 2nd or so :P
06:50:09 <Philonous> hoknamahn: folds are also called catamorphisms
06:50:16 <Valodim> so basically, under a rock
06:50:39 <Deewiant> ?ty (.) . (>>=) -- jpcooper
06:50:40 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => m a1 -> (a -> a1 -> m b) -> a -> m b
06:50:55 <jpcooper> Deewiant, I've been using that. I'm just wondering whether there is a nicer way
06:50:57 <lilac> @type \ma f b -> ma >>= f b
06:50:58 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => m a -> (t -> a -> m b) -> t -> m b
06:51:39 <Deewiant> ?pl \ma f b -> fmap (f b) ma
06:51:40 <lambdabot> flip (flip . (fmap .))
06:51:45 <Deewiant> not much nicer :-P
06:51:51 <PeakerWork> hoknamahn: if a list is 1:2:3:4:[], the catamorphism of that list would be replacing each "data constructor" with something else, for example each (:) with (+) and each [] with 0
06:51:56 <PeakerWork> @src sum
06:51:56 <Deewiant> and not the same either
06:51:56 <lambdabot> sum = foldl (+) 0
06:52:01 <PeakerWork> hoknamahn: that's what the foldl here does
06:52:08 <hoknamahn> yeah guys
06:52:12 <hoknamahn> I know this
06:52:25 <hoknamahn> didn't know it's also called catamorphism :)
06:52:31 <hoknamahn> thanks for explanation
06:52:32 <lilac> @type \ma -> ((ma >>=) .)
06:52:33 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => m a -> (a1 -> a -> m b) -> a1 -> m b
06:57:53 <luite> is data MyType = MyType { a::Int, b::Int, c::Int } less efficient than a tuple (Int, Int, Int) ?
06:58:25 <BONUS> i think it should be about the same
06:58:30 <RayNbow> data (,,) = (,,) Int Int Int  -- equivalent
06:58:58 <BONUS> worrying about stuff like that is pretty much the definition of premature optimization
06:59:02 <luite> RayNbow: yes I know, but the compiler may know some special tricks to optimize tuples
06:59:05 <EvilTerran> luite, they'll be pretty much the same
06:59:15 <RayNbow> luite: tuples are lazy
06:59:20 <EvilTerran> note you can also write data MyType = MyType { a,b,c :: Int }
06:59:45 <shapr> When do we get Secure Cabal where we can sign packages?
07:00:00 * shapr guesses as soon as someone writes it...
07:00:07 <galdor> hi; I've a small problem with the Vty library
07:00:13 <galdor> I wrote a simple program: http://hpaste.org/11883
07:00:29 <galdor> but when I run it with runhaskell, I get: can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)
07:00:39 <galdor> if I compile with ghc --make, it works fine
07:00:55 <dcoutts> shapr: you're right! just as soon as you write it :-)
07:01:04 <galdor> what could I do to run it without compiling (make development so quicker)
07:01:18 <dcoutts> shapr: we know how to do it, it's a matter of developer time
07:01:20 <RLa> haskell as a language (without dynamic operators) is context-free?
07:01:37 <pozic> RLa: no, next question.
07:02:33 <RLa> pozic, maximal subset of haskell that is context-free?
07:02:57 <RLa> pozic, how is parser "f 2 + 4" does it require knowledge what f is?
07:03:06 <RLa> parsing*
07:03:14 <Taejo> @pl bothWith c f g = c <$> f <*> g
07:03:14 <lambdabot> bothWith = (. (<*>)) . (.) . (<$>)
07:03:22 <Taejo> ick
07:03:51 <RLa> as i uderstand f 2 + 4 should parse as (f 2) + 4?
07:03:55 <pozic> RLa: there is the off-side rule.
07:04:06 <matthew-_> hmm. is it just me or do other people find it irritating when you're working in GHCi and you try to run an expression and you get no output, and it eventually transpires that some part of the output is of a type with no Show instance?
07:04:12 <RLa> huh, off-side rule?
07:04:22 <vixey> off-side is irrelevant
07:04:46 <pozic> vixey: whatever.
07:05:07 <ttt--> hi, is it possible to enter type declarations in ghci?
07:05:08 <pozic> RLa: there is this thing called a search engine.
07:05:18 <vixey> pozic: you are being quite rude
07:05:27 <vixey> as usual
07:05:39 <Saizan> galdor: are you on archlinux? i symlinked libncurses.so to libncurses.so.5.6 and it started to work
07:05:48 <galdor> Saizan: yep I am
07:06:05 <shapr> dcoutts: Yeah, it's amazing how wanting something usually means writing it :-)
07:06:09 <galdor> it's a dirty hack, but gonna try
07:06:10 <Saizan> ttt--: no
07:06:16 <pozic> vixey: and you claim it's irrelevant, without any evidence.
07:06:17 <RLa> ok, what i need is how haskell implementations handle such expressions
07:06:25 <shapr> Though at the moment my obsession is Haskel programming on the Cell cpu.
07:06:41 <pozic> RLa: what do you want?
07:06:44 <RLa> off-side rule seems to be about identation
07:07:06 <pozic> RLa: yes, and that's what makes Haskell 98 not a context-free language.
07:07:09 <RLa> i want (have) to implement functional language
07:07:15 <ttt--> Saizan,  is there a reason for this? it is too hard to do?
07:07:27 <pozic> RLa: so, it's homework?
07:07:33 <RLa> yes, it is
07:07:35 <dcoutts> shapr: :-)
07:07:45 <pozic> RLa: then ask your teacher?
07:08:20 <galdor> Saizan: it works, thank you!
07:08:37 <galdor> I'm a bit concerned by its dirtyness, but at least it works
07:08:41 <galdor> s/by/about
07:09:00 <RLa> pozic, i already did, he put up better language description and made such rule (function apps bind tighter than bin ops) explicit
07:09:33 <jpcooper> are if statements allowed within do statements?
07:09:39 <RLa> but all i have is grammar that does not contain itself such information
07:09:41 <matthew-_> jpcooper: yup
07:09:46 <jpcooper> great
07:09:51 <Saizan> ttt--: i think it's just that noone has worked on it
07:10:14 <matthew-_> ooh, also, is unit (()) special cased in ghci? entering () on its own does indeed print (), but doing "return ()" prints nothing
07:10:25 <pozic> RLa: then what makes you think your assignment has anything to do with Haskell?
07:10:48 <opqdonut> matthew-_: ywah it's special cased because of IO () -actions
07:10:50 <opqdonut> afaik
07:11:06 <RLa> pozic, because without that rule i had working parser but when i evaluated expressions by hand i got different answers than hugs
07:11:19 <RLa> pozic, it's very haskell-like language
07:11:49 <RLa> but the teacher told me that hugs answer is correct
07:12:00 <RLa> so all my work this far was useless
07:12:13 <Saizan> that could be a bug in the evalutation rather than the parser
07:12:44 <matthew-_> opqdonut: it's really odd though, because if you use a constructor on its own within ghci and no show instance you get an error, but if you do the same thing and put return in front, it just disappears
07:12:49 <pozic> RLa: if you want to see whether you parse correctly, make an unparser.
07:12:55 <Saizan> howerver there are haskell parsers on hackage, like haskell-src, but i'm not convinced that looking at those would help much
07:13:08 <RLa> my parser is useless, i have damn ambiguous base grammar and i have no idea how to handle function apps
07:13:14 <matthew-_> whereas if there is a show instance then it'll use it.
07:13:20 <matthew-_> this seems both confusing and inconsistent
07:13:21 <RLa> pozic, i did that
07:13:24 <ksf> jpcooper, matthew-_ , there is no such beast as an "if statement"
07:13:44 <jpcooper> ksf, what would you term it as?
07:13:44 <pozic> RLa: stop making us guess, show the code with the assignment.
07:13:45 <matthew-_> expression
07:13:50 <ksf> exactly.
07:13:56 <jpcooper> okay
07:14:11 <RLa> f 2 + 4 parses as f (2+4) which is wrong
07:14:15 <RLa> pozic, a sec
07:14:18 <ksf> it's not an action but a thingie that evaluates to one or the other thing.
07:14:24 <matthew-_> otoh, you could argue that do notation and monads give expressions statement semantics
07:14:28 <matthew-_> (at least, sorta ;)
07:17:10 <RLa> pozic, base grammar: http://www.cs.ut.ee/~varmo/TM2008/project/puf-syntax.txt, LL(k) grammar spec. i wrote for antlr parser generator: http://pastebin.com/m73a5f3c0
07:18:33 <RLa> pozic, we use ; at the end of declaration, so no whitespace rules are necessary
07:21:40 <trofi> dons: is there any reason bytestring-0.9.1.4 isn't uploaded to hackage?
07:23:23 <pozic> RLa: you just need to make sure that function application binds the strongest.
07:24:09 <RLa> pozic, my problem is probably how do i know that f in f 2 + 4 is a function?
07:27:17 <Saizan> RLa: because f is <ident> or even <expr> instead of <bop>
07:27:18 <pozic> RLa: the only way to parse the left argument of + is as an expression.
07:28:09 <pozic> RLa: and the only way to parse that expression is as an <expr> <expr>
07:28:20 <pozic> RLa: and so on.
07:29:12 <RLa> pozic, yes, i will try to draw some derivation trees and order rules so it will finally get ok
07:29:40 <paczesiowa> is this the best way to force smth inside IO () <- return $ rnf result `seq` () ?
07:30:15 <Saizan> don't you usually change the grammar to enforce such precedencies?
07:30:39 <mmorrow> () <- return $! rnf result
07:30:42 <mmorrow> @src ($!)
07:30:44 <lambdabot> f $! x = x `seq` f x
07:31:07 <pozic> Saizan: yes
07:31:11 <Saizan> evaluate (rnf result)
07:31:15 <RLa> hm, it's my first time to use parser generator, so i will have mess around with it some time
07:31:20 <mmorrow> ooh, that too
07:31:20 <paczesiowa> mmorrow: thx
07:31:39 <pozic> RLa: the proper way is to first write down the correct grammar and then sit behind a computer.
07:32:11 <Axman6> could someone briefly explain to me what Chan's are for?
07:32:13 <paczesiowa> @info evaluate
07:32:13 <lambdabot> evaluate
07:32:23 <paczesiowa> @where evaluate
07:32:23 <lambdabot> I know nothing about evaluate.
07:32:29 <paczesiowa> @source evaluate
07:32:29 <lambdabot> evaluate not available
07:32:38 <EvilTerran> ?hoogle evaluate
07:32:38 <Dan_> Wow, lots of people here.
07:32:39 <lambdabot> Control.Exception evaluate :: a -> IO a
07:32:39 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
07:32:48 <paczesiowa> thx
07:32:57 <Dan_> Umm, is anyone around willing to help with a really stupid question about main?
07:33:05 <paczesiowa> sure
07:33:21 <Axman6> Dan_: what's the problem?
07:33:45 <Dan_> Okay: I've got a list of commands I want the program to execute in main, and I'm assuming they all execute but only the final one shows... like it's overwriting the others. Any way to just show the results of each one in a list?
07:34:02 <Saizan> Axman6: they are for communication between threads, using an unbounded buffer of messages
07:34:06 <RayNbow> :t sequence
07:34:06 <ksf> mapM.
07:34:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:34:39 <Axman6> Saizan: ah, i see, quite handy. so FIFO?
07:35:00 <Saizan> yeah
07:35:12 <Axman6> @src [] sequence
07:35:13 <lambdabot> Source not found. I feel much better now.
07:35:45 <Axman6> bleh, that doesn't make any sense to ask for the source for that -_-
07:35:47 <Dan_> ksf, RayNbow and lambdabot: was that aimed at me? if so thanks, but i have three possible solutions, not sure what to do with each.
07:35:59 <Saizan> @src sequence
07:35:59 <lambdabot> sequence []     = return []
07:36:00 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:36:00 <lambdabot> --OR
07:36:00 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:36:06 <ksf> sequence [[1],[2]]
07:36:09 <trofi> @ask dons is there any reason bytestring-0.9.1.4 isn't uploaded to hackage?
07:36:09 <ksf> > sequence [[1],[2]]
07:36:09 <lambdabot> Consider it noted.
07:36:11 <lambdabot>   [[1,2]]
07:36:22 <Saizan> Dan_: you could show us your main, so that we understand better the situation
07:36:30 <Dan_> sure, 1 sec
07:36:38 <Axman6> Dan_: use hpaste
07:36:43 <Axman6> lambdabot: hpaste?
07:36:46 <Dan_> main = do	cCode 'a' (convHHToH (hCons engFreq))
07:36:48 <Dan_> 			cCode 'b' (convHHToH (hCons engFreq))
07:36:50 <Axman6> @hpaste
07:36:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:36:50 <Dan_> 			cCode 'c' (convHHToH (hCons engFreq))
07:36:52 <Dan_> never done a main before
07:36:57 <Axman6> damn
07:37:11 <Axman6> oh, it did work
07:37:34 <Dan_> should i still use hpaste or is that ok?
07:37:34 <Saizan> Dan_: oh, a main block doesn't exactly work like a ghci prompt
07:37:40 <Dan_> oh i see
07:38:02 <Saizan> Dan_: if you want to get things printed you've to use putStr or print
07:38:02 <Dan_> so, should i put all of them in a list and then map it, perhaps?
07:38:32 <Dan_> ah ok. anything i need to import for that? IO?
07:38:38 <Saizan> System.IO
07:38:52 <ksf> most likely, you want to have a look at all of Control.Monad
07:39:10 <Axman6> isn't putStr(Ln) and print in Prelude?
07:39:30 <ksf> there's a thousand of useful functions defined there that only spj and dons understand completely.
07:39:34 <Axman6> @hoogle putStrLn
07:39:35 <lambdabot> Prelude putStrLn :: String -> IO ()
07:39:35 <lambdabot> Data.ByteString putStrLn :: ByteString -> IO ()
07:39:35 <lambdabot> System.IO putStrLn :: String -> IO ()
07:39:51 <askentasken> what is a good example to do in Coq? like can i prove that quicksort works?
07:40:08 <Saizan> i'd write it like: main = do let foo c = cCode x (convHHToH (hCons engFreq)); xs <- mapM foo ['a','b','c']; mapM_ print xs
07:41:15 <Saizan> ksf: "only spj and dons" would make the haskell community look pretty poor :)
07:41:49 <paczesiowa> because we also have Oleg!
07:42:22 <Saizan> hah, well Control.Monad is not even visible on the oleg-scale
07:42:47 <ksf> Well, for mortals, understanding of monads is a non-terminating process.
07:43:09 <paczesiowa> Oleg probably uses type level monads
07:43:27 <paczesiowa> so choosing instances is more composable
07:43:44 <opqdonut> ksf: monads aren't hard
07:43:50 <Dan_> the return type of cCode is Maybe String
07:43:55 <Dan_> is that a problem for print?
07:43:55 <opqdonut> there's just a lot of hype on how hard they are
07:44:00 <trofi> :t mdo
07:44:01 <lambdabot> Empty 'do' construct
07:44:07 <ksf> yes, they're soft and squishy ;)
07:44:10 <Saizan> Dan_: ah, i assumed it was in IO
07:44:29 <Saizan> Dan_: it's not a problem for print, but then my code doesn't typecheck
07:44:42 <ksf> Dan_, no, print uses show and Maybe has a Show instance.
07:44:43 <Axman6> > show (Just 3)
07:44:45 <lambdabot>   "Just 3"
07:44:55 <Dan_> hmmm
07:44:59 <Axman6> @instances Show
07:45:01 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
07:45:02 <Saizan> Dan_: so you can just use map and print that list
07:45:27 <askentasken> what is the extension for coq-files? i mean suffix
07:45:37 <Saizan> Dan_: main = print (map (\x -> cCode x (convHHToH (hCons engFreq))) ['a','b','c'])
07:45:47 <ksf> or, preferrably, unlines $ map foo bar
07:46:27 <Dan_> oh okay, that makes sense :) thanks 1 sec
07:46:32 <ksf> show isn't meant to be human-readable.
07:46:40 <askentasken> what is the extension for coq-files? i mean suffix
07:47:04 <swiert> askentasken: .v
07:47:18 <swiert> askentasken: but you may want to join #coq
07:47:34 <Axman6> askentasken: it's usually more polite to wait longer than that before repeating a question
07:47:58 <Dan_> thanks everyone, it works :D
07:48:05 <Dan_> specifically saizan's
07:48:12 <Dan_> you just saved me a lot of time :P
07:48:14 <Saizan> Dan_: you may like this tutorial on using monads/do-notation http://www.haskell.org/haskellwiki/Monads_as_computation
07:48:26 <lambdabot> Title: Monads as computation - HaskellWiki
07:49:23 <Dan_> i'll bookmark it, thanks saizan. Bit difficult to get round to any extra-curricular reading at the moment but i'd definitely like to. Cheers :)
07:49:43 <hoknamahn> guys, is it possible to use catamorphism on trees like this one data Tree = Leaf a | B1 a l | B2 a l r ?
07:50:16 <Saizan> hoknamahn: are you missing some type parameters?
07:51:42 <hoknamahn> data Tree a
07:52:13 <ksf> > sequence [[1],[2,3],[4,5,6]]
07:52:15 <lambdabot>   [[1,2,4],[1,2,5],[1,2,6],[1,3,4],[1,3,5],[1,3,6]]
07:52:26 <Saizan> and instead of l and r you've (Tree a)? so it's easy but you've to define the function yourself
07:52:44 <hoknamahn> arrh sorry data Tree a = L a | B1 a (Tree a) | B2 a (Tree a) (Tree a)
07:53:12 <ksf> the list monad is one of the best way to prove to yourself that you don't grok monads.
07:53:13 <hoknamahn> so B1 - constructor for branch which has 1 child and B2 has two children
07:55:11 <Saizan> hoknamahn: foldTree :: (a -> b) -> (a -> b -> b) -> (a -> b -> b -> b) -> Tree a -> b; foldTree f g h (Leaf a) = f a; foldTree f g h (B1 a t) = g a (foldTree f g h t) .. etc.
07:55:21 <jpcooper> do if expressions in a do statement have to have an else part?
07:55:34 <paczesiowa> jpcooper: yes
07:55:49 <paczesiowa> jpcooper: but you may be interested in guard
07:55:51 <paczesiowa> :t guard
07:55:51 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:55:59 <jpcooper> thanks
07:56:19 <jpcooper> :doc guard
07:56:31 <jpcooper> how can I get the link to its documentation?
07:57:01 <Saizan> @docs Control.Monad
07:57:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
07:57:04 <jpcooper> thanks
07:57:41 <paczesiowa> > do x <- read `fmap` getLine; guard $ even x; print x
07:57:42 <lambdabot>   * Exception: "<IO ()>"
07:59:29 <hoknamahn> thanks, Saizan!
08:00:44 <Axman6> is read `fmap` getLine == readLine?
08:00:53 <Axman6> @src readLine
08:00:54 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:01:03 <paczesiowa> :t readLine
08:01:04 <lambdabot> Not in scope: `readLine'
08:01:20 <paczesiowa> @src readLn
08:01:21 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
08:01:30 <Axman6> readLn*
08:01:33 <Axman6> @src readLn
08:01:34 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
08:01:40 <Axman6> bleh, too late
08:02:24 <PeakerWork> can both foldr and foldl be considered catamorphisms of a list, or is there only one canonical form that is considered that?
08:02:35 <paczesiowa> but come on, read `fmap` looks so much cooler
08:02:57 * Axman6 prefers clarity to coolness
08:02:59 <Saizan> PeakerWork: only foldr is the catamorphism
08:03:21 <paczesiowa> I mean everyone but us uses Int.Parse(getLine()) and we can use Functors and Monads to do that
08:03:28 <PeakerWork> Saizan: so there's just one function that is truly the catamorphism of any data structure?
08:03:41 <PeakerWork> (at least denotational-semantics)
08:03:44 <PeakerWork> -wise
08:03:56 <Saizan> PeakerWork: yes, there's a precise CT definition
08:04:20 <PeakerWork> thanks
08:09:18 <gwern> 'Wilkes is reputed to have said, "I can remember the exact instant when I realized that a large part of my life from then on was going to be spent in finding mistakes in my own programs."' :(
08:13:30 <opqdonut> :(
08:15:13 <vegai> :(
08:17:31 <EvilTerran> gwern, and this is why we <3 formal methods :)
08:18:11 <gwern> EvilTerran: talk about being between the devil and the deep blue sea
08:18:40 <chris2> ... because formal methods take even more time than finding mistakes in your own programs!
08:19:13 <EvilTerran> it takes more *time*, yes, but less *sanity*
08:19:20 <EvilTerran> and i consider that more important
08:19:59 <EvilTerran> (taking sanity to be a resource which can be "spent" working on various soul-destroyingly boring tasks)
08:20:24 <jpcooper> programming, being one of them
08:20:38 <newsham> hmm.. 6.10.1 is out, eh?  does this one come with cabal install?
08:20:49 <newsham> time to do the upgrade dance
08:20:50 <chris2> who said "i never felt as stupid as in my first week of coq"?
08:21:00 <jpcooper> are any people here working in finance/
08:21:00 <dcoutts> newsham: the platform release will include cabal-install
08:21:04 <gwern> my trouble is that formal methods seem to take even more work than writing in a half-formal language like haskell and then ironing out the occasional bug
08:21:05 <jpcooper> or plan to be
08:21:15 <EvilTerran> jpcooper, well, not necessarily, but some approaches to/fields of programming, yeah
08:21:29 <Saizan> so the call of cthulhu rpg is really about debugging?
08:21:31 <newsham> chris2: its an enlightening feeling
08:21:38 <newsham> the "what I dont know could fill a library" feeling
08:21:47 <chris2> i know it :P
08:22:33 * EvilTerran checks his version control for commits made by the user "azathoth"
08:22:44 <gwern> cthulhu's tentacles could fill  a library as well
08:22:47 <newsham> gwern: but how do you know if there are "occasional" bugs left?
08:24:00 <gwern> newsham: well, first I need to make sure that there is in fact an external world
08:24:25 <gwern> newsham: I can prove the existence of an external world by considering my concept of _|_
08:24:26 <ushdf> i leave for ten minutes and the whole place goes to shit
08:25:07 <EvilTerran> it does?
08:25:11 <gwern> clearly an infinite concept like _|_ could only come from an infinite being like SPJ; SPJ would not allow me to be so deceived as to an external world's existence
08:25:46 <ushdf> too many faulty jumps of logic
08:26:06 <gwern> by a similar argument, I am certain that my program is bug-free, and SPJ, being omnibenevolent, would not allow me to be deceived as to my program's bugginess. therefore, I can rest confident of its validity. any 'bugs' are really features
08:26:23 <gwern> QED
08:26:31 <chrisdone> everyone I install a package with network, cabal install *always* rebuilds and installs network. anyone else get this or are my packages screwed?
08:26:34 <newsham> gwern: http://hpaste.org/11884
08:26:48 <waern> chrisdone: it's a known problem
08:27:16 <waern> (that's all I know)
08:27:31 <newsham> granted the benefits came at a high cost, but good anecdotal evidence of the value
08:27:38 <dcoutts> chrisdone: it was an issue in the RCs, it should be fixed in 6.10.1
08:27:55 <gwern> newsham: I can barely read that
08:27:57 <dcoutts> chrisdone: and with an up-to-date hackage list
08:28:03 <newsham> gwern: check the pdf hten
08:28:03 <newsham> then
08:28:20 * gwern snorts: '
08:28:21 * gwern snorts: '[section 6.4, http://ertos.nicta.com.au/publications/papers/Cock_KS_08.pdf]
08:29:16 <mathijs> Hi all, I tried to reason about a bit of code in 'real world haskell'. I tried to write down my reasoning steps and 'analysis', can someone please have a look and tell me if this is right?
08:29:21 <mathijs> http://hpaste.org/11885
08:30:38 <EvilTerran> mathijs, it looks right, although i'd mention the definition of step on the line it comes into scope in your reasoning
08:31:40 <mathijs> EvilTerran: yeah I know what you mean, I should comment on every reasoning step and mention what i'm applying
08:31:41 <EvilTerran> mathijs, ie, i'd make that line "foldr step id [1,2,3] 8 where where step x g a = g (a - x)" or something
08:31:52 <EvilTerran> er, only one "where" there :P
08:31:54 <mathijs> EvilTerran: ah like that, get it
08:31:58 <newsham> if you used two different names for your two different step functions it would be clearer
08:32:28 <mathijs> newsham: they aren't different, just written as lambda to clear it up
08:32:42 <newsham> oh heh
08:32:43 <EvilTerran> newsham, it's the same function, just two different presentations of it
08:32:45 <newsham> i dont read comments so well
08:33:07 <EvilTerran> yeah, it took me a good bit of looking at the code before that clicked
08:33:38 <mathijs> well, it took me even longer to figure out what was happening :)
08:35:03 <chrisdone> dcoutts: ah, brilliant. thanks =)
08:47:00 <lilac> @type flip . flip foldr id . (flip (.) .) . flip
08:47:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:48:34 <dabd> I have an upcoming project in which I will have to make a fairly efficient suffix tree implementation (not the one .  Is Haskell a good choice for this application
08:49:22 <dabd> I am aware of this implementation http://www.serpentine.com/blog/software/suffixtree/
08:49:23 <lambdabot> Title: teideal glic deisbhÃ©alach Â» Data.SuffixTree - lazy, efficient suffix trees in  ...
08:53:13 <Badger> lunabot: talk to Cale :P
08:54:06 <Cale> , 2^100
08:54:13 <lunabot>  1267650600228229401496703205376
08:56:00 <lilac> , 2^(2^100)
08:56:07 <lunabot>  Killed.
09:14:10 <Lemmih> dons: ping.
09:14:39 <ksf> Lemmih, that's called SYN
09:14:57 <Lemmih> dons: SYN.
09:15:32 <paczesiowa> <dons> Lemmih: RST
09:16:16 <paczesiowa> did you crash?
09:18:25 <EvilTerran> ?type replicate
09:18:26 <lambdabot> forall a. Int -> a -> [a]
09:18:34 <EvilTerran> , replicate (-3) 1
09:18:37 <lunabot>  []
09:18:58 <b_jonas> this low-level stuff (TCP, routing) always seems magic to me and I'm glad the OS does it for me
09:19:15 <pierre-> ?users
09:19:15 <lambdabot> Maximum users seen in #haskell: 559, currently: 530 (94.8%), active: 20 (3.8%)
09:32:29 <albdogo> hi
09:40:53 <vixey> hello
09:41:35 <Taggnostr> when I have simple functions like "abs n | n < 0 = -n; abs n = n", is better to use guards or if/else in the function?
09:41:39 <vixey> no
09:41:59 <vixey> abs = sqrt . square
09:42:40 <Taggnostr> it was an example
09:42:53 <roconnor> use guards
09:42:54 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:43:01 <EvilTerran> vixey, no need to be facetious
09:43:04 <roconnor> and for the last case do          | otherwise = n
09:43:26 <Taggnostr> ok
09:43:46 <Taggnostr> is there a function to check if a list contains an element?
09:43:53 <PeakerWork> would it be accurate to say that lambda calculus represents data structures in general via their catamorphisms?
09:44:01 <vixey> Peaker: No
09:44:06 <vixey> Peaker: You _can_ do that
09:44:14 <roconnor> @type elem
09:44:15 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:44:16 <EvilTerran> lambda calculus doesn't care about data structure
09:44:17 <EvilTerran> s
09:44:24 <Taggnostr> thanks
09:44:25 <vixey> btwy you probably could say eliminator rather that cata
09:44:42 <PeakerWork> vixey: what is an "eliminator"?
09:44:43 <ksf> > null []
09:44:44 <lambdabot>   True
09:44:47 <ksf> > null [1]
09:44:48 <lambdabot>   False
09:45:04 <ksf> @type null
09:45:05 <lambdabot> forall a. [a] -> Bool
09:45:08 <vixey> :t foldr (== ?e) (||)
09:45:08 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `Bool'
09:45:08 <lambdabot>     In the first argument of `foldr', namely `(== ?e)'
09:45:32 <ksf> for another definition of "contains an element", that is.
09:45:32 <Saizan> PeakerWork: the word they use in dependently typed languages for roughly he same concept
09:45:52 <Saizan> PeakerWork: which corresponds to the principle of structural induction on that type
09:46:08 <solrize_> i thought elimination meant getting rid of a value of some data type, by pattern matching to pull out its component values
09:46:28 <solrize_> yeah, that would be structural induction
09:46:35 <PeakerWork> solrize_: that does sound very close to catamorphism, which could also be said to be an alternative to pattern-matching
09:47:02 <vixey> Is compiling pattern matching into catamorphism _possible_?
09:47:04 <vixey> I think it's not
09:47:11 <solrize_> i don't know what catamorphism is, though i think i looked it up once
09:47:33 <PeakerWork> vixey: why not?
09:47:37 <Saizan> solrize_: generalization of foldr
09:47:50 <solrize_> hmm
09:48:00 <vixey> solrize: if you have a data type with constructors F :: A, B :: A -> A -> A, then (| f, b |) takes a data sturcture like that and replaces every F with f and every B with b
09:48:13 <EvilTerran> vixey, it would be, but it'd be a very inefficient implementation
09:48:19 <vixey> PeakerWork: For one, I've never seen anyone do it
09:48:42 <vixey> can you write a program that takes equations like
09:48:44 <vixey> @src zip
09:48:44 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
09:48:44 <lambdabot> zip _      _      = []
09:48:53 <vixey> and turns them _automatically_ into foldr's
09:49:14 <PeakerWork> vixey: hmm, its probably easy for equations that only match just 1 pattern at a time
09:49:30 <ksf> zip's much more like a map than a fold.
09:49:31 <PeakerWork> for these I have to think more...
09:49:35 <solrize_> vixey, ic, that sounds like elimination
09:49:41 <PeakerWork> ksf: a map can also be expressed with a fold
09:49:41 <vixey> I think it's probably undecideable in general
09:49:54 <vixey> compiling into case expressions or case eliminators is fine though
09:50:03 <EvilTerran> it'd involve the foldr returning a tuple; the body of the function doing pattern-matching, with the variables instantiated correctly for this step of the cata, but also the unmodified values it got in, in case this isn't the topmost pattern
09:50:06 <Saizan> vixey: is that much different than representing lists by church encoding?
09:50:15 <vixey> Saizan: what is?
09:50:29 <Saizan> vixey: transforming equations to folds
09:50:43 <vixey> it seems different to me
09:50:46 <Saizan> s/than/from/
09:50:58 <vixey> maybe I ma just missing something obvious? but I couldn't program it
09:52:29 <Saizan> the church encoding for a list is exactly the type of foldr, no? List a = forall b. b -> (a -> b -> b) -> b
09:52:59 <vixey> I thought a big thing about church encoding was type esasure, e.g. you can't represent untyped lambda terms without type erasure
09:53:00 <Saizan> i guess nested patterns are problematic
09:55:59 <kazimir> hey guys
09:56:49 <kazimir> what means (a -> a) in nIt :: (a -> a) -> a -> Int -> [a] ??
09:57:06 <roconnor> a function from a to a
09:57:16 <roconnor> @type map
09:57:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:57:28 <kazimir> ah...
09:57:35 <roconnor> > map succ [1..3]
09:57:37 <lambdabot>   [2,3,4]
09:57:40 <roconnor> @type succ
09:57:42 <lambdabot> forall a. (Enum a) => a -> a
09:57:48 <EvilTerran> > foldr (\x (hd,tl,all) -> (x,all,x:all)) (undefined,undefined,[]) $ [1..10] -- one level of pattern-matching, via foldr
09:57:50 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
09:58:06 <kazimir> alright..
09:58:07 <kazimir> thanks
09:58:42 <PeakerWork> is zip expressable with foldr?
09:58:53 <vixey> Peaker: yes but not in any algorithmic way afaict
09:59:05 <EvilTerran> PeakerWork, using that function i just gave, yes
09:59:33 <EvilTerran> might also need a boolean for null-ness being returned
09:59:35 <mm_freak> does 'printf' need RTTI?
09:59:37 <PeakerWork> EvilTerran: ah, ok
10:00:17 <Taggnostr> how can I extract the nth element from a list?
10:00:21 <vixey> !!
10:00:28 <PeakerWork> EvilTerran: you're throwing away hd and tl?
10:00:29 <vixey> Taggnostr: check Data.List documentations
10:00:39 <PeakerWork> Taggnostr: vixey isn't mad, (!!) is the operator :)
10:00:55 <solrize_> > [2,4,6,8,10] !! 3
10:00:57 <lambdabot>   8
10:01:22 <unenough> hey PeakerWork
10:01:26 <PeakerWork> hey unenough
10:01:31 <roconnor> Taggnostr: whatcha writing?
10:01:32 <b_jonas> PeakerWork: yes, he is
10:01:40 <PeakerWork> EvilTerran: how can you use that to write zip? I don't understand
10:01:48 <Taggnostr> even and odd :D
10:02:01 <roconnor> Taggnostr: often using (!!) is an indication of a poorly designed haskell program.
10:02:12 <unenough> > foldr ((.) . (:)) id [1,2,3] [4,5,6]
10:02:13 <lambdabot>   [1,2,3,4,5,6]
10:02:15 <unenough> :)
10:02:26 <vixey> that's not zip :p
10:02:27 <unenough> don't you love haskell?
10:02:43 <vixey> > flip (foldr (:)) "abc" "xyz"
10:02:44 <b_jonas> whoa
10:02:44 <lambdabot>   "abcxyz"
10:02:47 <b_jonas> how does that work?
10:02:53 <unenough> Argg
10:02:59 <b_jonas> oh, I see
10:03:05 <vixey> > foldr (flip (:)) "abc" (reverse "xyz")
10:03:06 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
10:03:06 <lambdabot>        Expect...
10:03:07 <b_jonas> but indeed that's not zip
10:03:08 <unenough> vixey, i know, just an example (++) from YAHT
10:03:17 <vixey> > foldl (flip (:)) "abc" (reverse "xyz")
10:03:18 <lambdabot>   "xyzabc"
10:03:52 <EvilTerran> PeakerWork, foldl-via-foldr on one list, and, at each step, use the above function on the other list to get the matching element ouit
10:04:47 <PeakerWork> EvilTerran: Is it possible to be O(N) like zip?
10:04:47 <b_jonas> how about implementing zip from unfold?
10:04:59 <EvilTerran> probably not
10:05:18 <vixey> b_jonas, can you do it?
10:05:27 <vixey> @go Oleg
10:05:30 <vixey> @go Oleg zip with fold
10:05:33 <lambdabot> http://www.olegproducts.com/
10:05:33 <lambdabot> Title: Custom Saxophone,Flutes,Olegatures Woodwind Ligatures & Accessories - Oleg Produ ...
10:05:35 <lambdabot> http://okmij.org/ftp/Algorithms.html
10:05:35 <lambdabot> Title: Algorithms and Data Structures
10:05:49 <unenough> Saxophone?
10:05:51 <b_jonas> let me try
10:05:55 <therp> is there any haskell environment that can provide me with backtraces of some constant depth?
10:05:56 <solrize_> lol
10:06:14 <PeakerWork> EvilTerran: Its easy to build map with foldr, and I can use map with a growing number accumulating next to my element, and use (!!) which is also implementable with a foldr, I guess
10:06:21 <vixey> therp, you checked the ghci docs?
10:06:42 <therp> vixey: no. what should I find in there?
10:07:02 <unenough> Is there a theorem about what can be implemented with foldr? :)
10:07:05 <therp> vixey: to my best knowledge GHC doesn't have anything included that resembles backtraces
10:07:23 <PeakerWork> unenough: it seems like everything, but not at the best O()...
10:07:28 <vixey> therp, it may be worth a look
10:07:28 <unenough> yeah
10:07:52 <EvilTerran> O() is dependent on such implementation details as evaluation order, anyway :P
10:08:19 <ski> writing `zip' using only `foldr' for recursion over the two list was quite fun
10:08:28 <PeakerWork> EvilTerran: then we can define the O() using the "best" evaluation order strategy.. Under no strategy does the (!!) based zip get O(N) ...
10:08:38 <therp> vixey: can you be more precise, what should I find in there?
10:08:45 <ksf> fold, cons, car, cdr and cond are touring-complete on a quick glance.
10:08:49 <EvilTerran> PeakerWork, yeah, that works
10:09:37 <ksf> as you can implement cons, car and cdr directy in lambdas you're left with fold and cond, which should suffice.
10:09:49 <vixey> @go universality of fold
10:09:55 <lambdabot> http://www.cs.nott.ac.uk/~gmh/fold.pdf
10:09:55 <lambdabot> Title: A tutorial on the universality and expressiveness of fold
10:10:12 <b_jonas> > let { zi a b = snd (mapAccumL (\(ah : at) bh -> (at, (ah, bh))) a b); } in zi "abcd" "pqrs" -- ->vixey
10:10:13 <ski> (or allowing less cheating, use `type List a = forall r. (a -> r -> r) -> r -> r' and write `zipList :: List a -> List b -> List (a,b)')
10:10:14 <lambdabot>   [('a','p'),('b','q'),('c','r'),('d','s')]
10:10:45 <b_jonas> doesn't work if the first list is shorter though
10:10:54 <roconnor> @type group
10:10:56 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
10:10:56 <vixey> that's cool b_jonas
10:11:23 <b_jonas> the problem is, this can't be fixed to work both if the first list is shorter and if the second list is shorter
10:11:28 * ski wonders whether that disallows all cheating
10:11:53 <PeakerWork> @src mapAccumL
10:11:54 <lambdabot> mapAccumL _ s []        =  (s, [])
10:11:54 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
10:11:54 <lambdabot>    where (s', y ) = f s x
10:11:54 <lambdabot>          (s'',ys) = mapAccumL f s' xs
10:12:06 <ksf> I'm wondering whether you can implement fold without null and cond.
10:13:07 <ski> @src foldr
10:13:07 <lambdabot> foldr f z []     = z
10:13:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:13:17 <ski> no `null' nor `cond'
10:13:26 <vixey> hhe
10:13:36 <ksf> [] is spelled null? in lisp.
10:13:51 <b_jonas> > let { zi a b = unfoldr (let { f (ah : at, bh: bt) = Just ((ah, bh), (at, bt)); f _ = Nothing; } in f) (a, b); } in zi "abcd" "pqrs"
10:13:53 <lambdabot>   [('a','p'),('b','q'),('c','r'),('d','s')]
10:13:56 <b_jonas> this one works in both cases
10:14:02 <ski> no, "[]" is spelled "'()" in lisps
10:14:23 <vixey> b_jonas, ah but you used pattern matchincg :))
10:14:23 <vixey> '() is scheme, nil in lisp
10:14:44 <ksf> well then pattern-matching for [] is spelled (cond ((null? x) ...))
10:14:53 <b_jonas> actually '() works in both lisp and scheme, and so does (list), whereas nil works only in lisp
10:15:03 <ski> (ok, was wondering some had "nil" without having "'()")
10:15:08 <vixey> yeah but nobody writes '() in lisp
10:15:16 <ski> (s/some/whether some/)
10:15:18 <b_jonas> vixey: in scheme they do
10:15:25 <b_jonas> I dunno if they do that in lisp
10:15:26 <vixey> yeah scheme ....
10:15:39 <b_jonas> null is the same function in lisp as in haskell
10:16:48 <b_jonas> ksf: yeah, it is spelt like that in scheme; in lisp nil (the empty list) is considered false so there you don't need null actually
10:17:36 <kazimir> it is possible to map a funtion like f=3*x+(5*x) with "map f x" ?
10:17:46 <vixey> azimir, yes
10:18:00 <ksf> I was thinking of replacing any predicate and cond by lambdas, to be precise.
10:18:10 <b_jonas> so you want something without pattern matching? why?
10:18:11 <kazimir> how to define x ind the function?
10:18:21 <vixey> let f x =3*x+(5*x) in map f xs
10:18:44 <kazimir> thanks...i will try this !
10:18:45 <EvilTerran> map (\x -> 3*x + 5*x) xs
10:18:49 <EvilTerran> also works
10:18:54 <vixey> b_jonas, I was conjecturing that it's impossible to compile pattern matching into catamorphisms
10:19:00 <kazimir> thank you
10:19:05 <EvilTerran> or [3*x + 5*x | x <- xs]
10:19:06 <ksf> like testing for peano-0 by defining at as a function that calls the correct continuation.
10:19:22 <vixey> ksf, what about it?
10:19:23 <b_jonas> vixey: hmm
10:19:38 <ksf> In my invaluable attempt to safe the world by proving that data doesn't exist ;)
10:19:57 <ksf> s/at/it
10:20:19 <vixey> ksf, untyped lambda calculus is TC ... qed
10:20:19 <vixey> ?
10:20:29 <b_jonas> ksf: I have a short scheme-like interpter that does not have lists, only lambdas
10:20:52 <b_jonas> ksf: it does have if though which treats numeric zero as false and the < predicate returns a number
10:21:32 <ksf> does it know of naturals, then?
10:23:36 <ksf> http://pastebin.com/m25519cd9
10:24:13 <vixey> ksf, if you do a metacircular evaluator using HOAS it's like 3 lines of code
10:24:42 <ksf> hoas?
10:24:52 <ski> Higher-Order Abstract Syntax
10:25:04 <b_jonas> ksf: see http://www.madore.org/~david/programs/unlambda/
10:25:05 <lambdabot> Title: The Unlambda Programming Language
10:25:28 <b_jonas> what I was wondering is, what would a pure functional unlambda look like? has someone ever made one?
10:26:26 <b_jonas> in particular, would it need an IO >>= combinator or could you spare that by making all io primitives look like (putchar "a" >>=) instead of just (putchar "a"), or some trick like this?
10:27:28 <b_jonas> vixey: I think your foldr solution works to provide pattern matching
10:27:40 <vixey> I didn't give any solution
10:27:48 <b_jonas> yeah, not a complete one
10:27:51 <b_jonas> let me try
10:27:57 <ksf> you can just define stdin as a special list and stdout as a special list end that you can be prepended with cons cells.
10:28:17 <b_jonas> ksf: that wouldn't be pure functional
10:28:51 <ksf> why's that? there are no side effects at all.
10:29:17 <ski> b_jonas : mayhaps Lazy-K does something like that, don't remember
10:30:24 <b_jonas> ski: this one? --> http://homepages.cwi.nl/~tromp/cl/lazy-k.html
10:30:36 <ksf> so you do (cons H (cons e (cons l ... (cons ! stdout))))))))))
10:30:37 <lambdabot> Title: The Lazy K Programming Language
10:30:37 <ski> yes
10:30:51 <ski> @where lazy-k
10:30:51 <lambdabot> I know nothing about lazy-k.
10:31:06 <b_jonas> oh, so that has no relation to the infamous K
10:31:07 <ski> @where+ lazy-k http://homepages.cwi.nl/~tromp/cl/lazy-k.html
10:31:07 <lambdabot> Nice!
10:31:11 <b_jonas> thanks for the link
10:31:15 <Taggnostr> how can I rewrite "let foo n = (cycle ["even", "odd"]) !! (abs n) in foo (-2)" using a "foo . bar . baz $ args" structure? (the function doesn't make any sense, I know)
10:31:34 <ksf> But then I bet you'd stumble across the halting problem trying to write and interpreter for it.
10:32:03 <vixey> :t (cycle ["even", "odd"]) !! (abs n)
10:32:04 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
10:32:04 <lambdabot>     In the second argument of `(!!)', namely `(abs n)'
10:32:14 <vixey> :t (cycle ["even", "odd"]) !! (abs ?n)
10:32:15 <lambdabot> (?n::Int) => [Char]
10:32:17 <vixey> :t (!!) (cycle ["even", "odd"]) (abs ?n)
10:32:18 <lambdabot> (?n::Int) => [Char]
10:32:21 <vixey> :t (!!) (cycle ["even", "odd"]) . abs
10:32:22 <lambdabot> Int -> [Char]
10:32:39 <vixey> :t (!!) (fix ("even": "odd" :)) . abs
10:32:40 <lambdabot>     The operator `:' [infixr 5] of a section
10:32:40 <lambdabot>         must have lower precedence than the operand `(:)' [infixr 5]
10:32:40 <lambdabot>         in the section: `("even" : "odd" :)'
10:32:49 <ski> (cycle ["even", "odd"] !!) . abs
10:32:57 <vixey> :t (!!) (fix (("even":) . ("odd":))) . abs
10:32:58 <lambdabot> Int -> [Char]
10:33:18 <vixey> can't think how to get any more (.) in there
10:33:38 <ski> bool "even" "odd" . even
10:34:02 <dons> Lemmih: does flag(base4) actually work?
10:34:02 <lambdabot> dons: You have 9 new messages. '/msg lambdabot @messages' to read them.
10:34:07 <dons> src/System/Log/Logger.hs:461:39:
10:34:07 <dons>     Ambiguous type variable `e' in the constraint:
10:34:07 <dons>       `Control.Exception.Exception e'
10:34:07 <dons>         arising from a use of `handler'
10:34:19 <Taggnostr> is what I wrote the more readable way of express that?
10:34:19 <dons> Lemmih: i think you actually need to say you require base < 4
10:34:36 <vixey> Taggnostr, skis one is the most readable
10:34:59 <Taggnostr> yes, but it uses even :P
10:35:30 <vixey> so write even
10:35:37 <ddarius> :t even
10:35:39 <ski> @type even
10:35:39 <lambdabot> forall a. (Integral a) => a -> Bool
10:35:44 <b_jonas> vixey: so on the pattern matching, consider this: hd s = foldr (\e _ -> Just e) Nothing s;
10:35:46 <lambdabot> forall a. (Integral a) => a -> Bool
10:35:47 <vixey> even = (==0) . last . toBinary
10:35:53 <vixey> toBinary = unfoldr  ....
10:35:56 <ski> @index even
10:35:56 <lambdabot> Prelude
10:36:17 <b_jonas> vixey: now if you replaced the Maybe in it with their function encoding, you'd get pattern matching I think
10:36:46 <b_jonas> vixey: this doesn't extract the tail, only the head, but you've already shown that you can extract the tail from a non-null list, right?
10:37:04 <vixey> b_jonas, yeah head & tail are expressible
10:37:34 <b_jonas> is it expensive?
10:37:36 <ddarius> vixey: The safer and faster thing is to use mod
10:37:39 <b_jonas> oh yeah, tail is
10:37:43 <dons> Lemmih: hmm. runhaskell works. but my arch package doesn't. weird..
10:37:45 <b_jonas> but just head isn't I think
10:37:58 <dons> ah! hslogger .
10:38:22 <vixey> ddarius, mod n = last . toBaseN n ?
10:39:51 <ddarius> And for Pete's sake, any "toBase" function should produce digits lsd first.
10:39:55 <dons> Lemmih: false alarm. it is hslogger that's not base 4 ready
10:40:17 <b_jonas> vixey: apparently this lazy K indeed claims to be a pure functional unlambda, I'll have to read this on how it works
10:40:34 <ski> ddarius : how about for rationals or floating-point numbers ?
10:40:44 <b_jonas> ddarius: why? I think msd first makes more sense
10:40:53 <vixey> ddarius is right actually
10:41:07 <vixey> arabic (writing and number system) is right to left
10:41:13 <vixey> which is biza..rre
10:41:37 <b_jonas> > foldl' (\x y -> 10*x+y) 0 [2, 5, 3]
10:41:39 <lambdabot>   253
10:42:00 <vixey> > foldr (\x y -> y*10+x) 0 [2, 5, 3]
10:42:01 <lambdabot>   352
10:42:10 <ski> (hm, i suppose for those, it should return a zipper, positioned at (or just below) the zero exponent digit)
10:42:35 <ddarius> ski: I'm basing this on the type of even.
10:42:42 <b_jonas> vixey: but isn't it that the foldl' variant uses constant memory or something?
10:42:43 <ski> vixey : why is it bizarre ?
10:42:54 <ski> (ddarius : ok)
10:42:54 <vixey> ski, I am used to writing left to right
10:43:02 <ski> (:
10:43:18 <b_jonas> I guess I've started the endianness flamewar
10:43:28 <ddarius> Little endian is the One True Way.
10:44:18 <Twey> LE is bizarre.
10:45:02 <Twey> Right-to-left writing systems baffle me a little.  They seem fairly impractical, given that 90% of people are right-handed.
10:45:29 <vixey> top down seems the best to me
10:45:31 <pumpkin> depends what the traditional way of writing was
10:45:39 <vixey> not that I actually do it
10:46:14 <jpcooper> Twey, it would suit me to a tee
10:46:30 <jpcooper> our alphabet is discriminatory!
10:46:39 <Twey> Hehe
10:46:49 <ski> little vs. big endian is a different issue to left-to-right vs. right-to-left (or indeed : left-to-right, then; taeper ,tfel-ot-thgir)
10:47:13 <Twey> Yes, top to bottom then left to right seems the most logical
10:47:51 <ski> we should write in spirals, spiraling outward from a centre !
10:47:54 <pumpkin> why is left to right better for right handers?
10:48:11 <vixey> pumpkin smudge
10:48:15 <pumpkin> aha
10:48:18 <vixey> ski, yesssss !
10:48:18 <pumpkin> that was my point :P
10:48:27 <pumpkin> (being a left hander I know that all too well)
10:48:28 <jpcooper> pumpkin, I believe that it is the letters are written
10:48:29 <b_jonas> but this lazy K isn't what it claims to be
10:48:33 <pumpkin> but if people traditionally wrote with brushes
10:48:45 <pumpkin> then there's a lot less of a reason to be LTR vs. RTL
10:48:48 <jpcooper> actually, as a left-hander, my hand position is close to that of right-handers, so I don't have smudging problems
10:48:58 <pumpkin> jpcooper: you write upside down?
10:49:01 <b_jonas> it seems that it does what ksf suggested
10:49:10 <jpcooper> pumpkin, I just keep my hand out of the way of the text
10:49:11 <b_jonas> which does not allow interactively mixing input and output
10:49:19 <jpcooper> instead of the hook
10:49:35 <pumpkin> jpcooper: I can deal with paper fine, but writing on a board is a pain
10:49:38 <b_jonas> so no, this is not what I want
10:49:56 <jpcooper> I've never seen a left-handed lecturer, actually
10:52:32 <ski> (anyone care for seeing `zipWith' without pattern-matching on lists, except for in `foldr' .. not simulating `head',et.c. ?)
10:52:53 <Taggnostr> @hoogle map
10:52:53 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
10:52:53 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
10:52:53 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
10:53:34 <dmwit_> ski: sure!
10:54:06 <b_jonas> so my question remains, how would a pure functional unlambda work?
10:54:24 <b_jonas> ski: yes
10:54:46 <dons> Lemmih: good work. happs for 6.10 now in arch
10:55:21 <ski> (ok .. wrote this a while ago, before seeing Oleg's <http://www.mdstud.chalmers.se/~md9slj/code/FoldrZip.hs>)
10:55:51 <Lemmih> dons: Will a new binary version be released soon?
10:56:32 <ski> (one could use `build' instead of explicitly calling `[]' and `(:)' .. also, one could change it to use `type List a = forall r. (a -> r -> r) -> r -> r' instead)
10:56:54 <dmwit_> ski: re: your formatting: You have interesting ideas, and I would like to subscribe to your newsletter.
10:57:21 <ski> b_jonas : i think one can do an `IO' representation with constructors for `(putStr c >>=)', yes
10:58:12 <ski> dmwit_ : I've got BAD news for YOU. There isn't ONE !
10:58:14 <ski> @yow
10:58:14 <lambdabot> My Aunt MAUREEN was a military advisor to IKE & TINA TURNER!!
10:58:33 <dmwit_> Yow!
10:58:44 <ksf> b_jonas, if you have seperate terminals for input and output, things might work well.
10:58:49 <dons> Lemmih: a new binary version of the happs libraries?
10:58:56 <dmwit_> That IS bad news!  Now I need a DONUT dunked in GRAPE JAM!
10:59:02 <ksf> depends on how lazy lazy k is.
10:59:08 <vixey> very lazy
10:59:21 <Lemmih> dons: binary is several times slower with ghc-6.10 than with ghc-6.8.
10:59:25 <dmwit_> > 10.8 * 365
10:59:26 <lambdabot>   3942.0000000000005
10:59:36 <Lemmih> dons: Er, Data.Binary, I mean.
10:59:54 <dons> Lemmih: oh, yes. i have it right here.
10:59:56 <dons> all fixed.
11:00:03 <dons>  do you have a test you can try to make sure it works?
11:00:17 <dons> i was waiting on feedback from somewhere else but if you can test, that will do.
11:00:30 <dons> Lemmih: http://galois.com/~dons/tmp/binary-0.4.4.tar.gz
11:00:53 <dons> Lemmih: yes, inlining was failing in the Get monad, leading to about a 100x slowdown.
11:00:53 <ski>   data IOResult r = Return r
11:00:59 <ski>                   | PutStr Char (IOResult r)
11:01:00 <ski>                   | GetChar (Char -> IOResult r)
11:01:01 <ksf> imho not allowing symbol definitions is unnecessarily esoteric.
11:01:03 <ski> (iirc)
11:01:09 <dons> Lemmih: please test. if all goes well with happs, i'll upload.
11:01:11 <ksf> malbolge could have them and still be impossible to use.
11:01:21 <Lemmih> dons: Thank you.
11:03:25 <b_jonas> ski: so the program would have to store a temporary representation of any IO it builds so it can decostruct it, and convert it to real IO at the end, right?
11:03:29 <roconnor> @wiki IO_Semantics
11:03:30 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
11:03:38 <b_jonas> ski: because otherwise it can't implement >>=
11:04:01 <vixey> :t (>>=)
11:04:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:04:12 <vixey> Bind :: IO a -> (a -> IO b) -> IO b
11:04:22 <ski> b_jonas : what is "real IO" ?
11:04:41 <b_jonas> ski: what the interpreter believes is io and can execute
11:05:09 <b_jonas> roconnor: ah, thanks for the link
11:05:54 <dons> Lemmih: i think you should announce the new release, mention things like gitit, and compact-map, and link to tutorials
11:06:01 <dons> and other things to piont to the vibrancy of happs
11:06:04 <b_jonas> roconnor: so it's indeed possible to do this
11:06:05 <b_jonas> strange
11:06:18 <jkr_> Is there some kind of web framework for haskell?
11:06:25 <dons> happs!
11:06:28 <dons> and a bunch of others.
11:06:31 <jkr_> Or is Haskell usable for web development at all?
11:06:36 <dons> yes, of course.
11:06:55 <dons> what is web dev? database bindings, json, cgi/fastcgi/web server, html/xhtml templating, ... ?
11:07:14 <jkr_> Exactly :)
11:07:14 <dons> jkr_: there's a lot of stuff for this kind of thing. check out hackage.haskell.org
11:07:27 <quicksilver> anyone know about cairo's SVG renderer speed?
11:07:44 <dons> from complete all-in-one frameworks like happs, to build-your-own ones starting with fastcgi and sqlite.
11:07:50 <jkr_> For starters, a templating system similar to Template Toolkit and a database abstrayction layer like DBIx::Class would be good
11:07:50 <roconnor> quicksilver: I can render tiny charts instantly
11:08:13 <quicksilver> roconnor: I'm wondering if it's fast enough to do animation though
11:08:16 <dons> jkr_: hdbc is a good db abstraction. takusen's a bit higher. there are half a dozen templating engines.
11:08:22 <quicksilver> roconnor: can I have a 30fps animated SVG object?
11:08:22 <dons> see hstringtemplate or others.
11:08:34 <roconnor> quicksilver: oh, can SVG be animated?
11:08:41 <dons> jkr_: you can look also at 'panda' and 'kibro' for example running systems of how to glue it all together.
11:08:42 <b_jonas> what I'm missing from that article is the sample implementation of IO >>= and IO return
11:08:56 <jkr_> dons: Ok, I'll have a look, thank you
11:09:09 <dons> jkr_: hpaste.org and gitit run on happs, fwiw. http://johnmacfarlane.net:5001/Front Page
11:09:12 <dons> for example.
11:09:15 <b_jonas> ah, those are there
11:09:17 <b_jonas> on the top
11:09:19 <b_jonas> I'm stupid
11:09:21 <dons> that's the all-in-one rali competitor
11:09:24 <dons> rails.
11:09:34 <quicksilver> roconnor: I don't know. I only just posed the question myself.
11:09:51 <quicksilver> roconnor: I'd like to have anti-aliased resolution independent 2D 'sprites'
11:10:03 <quicksilver> roconnor: one or both of cairo + SVG struck me as a possible way.
11:10:17 <quicksilver> with the opengl painter I'm assuming although I'm not sure.
11:10:59 <roconnor> quicksilver: I guess I can't help you
11:13:39 <ivan> cairo may not be fast enough if you have tons of translucent objects or antialiased edges
11:13:46 <ivan> it is not known to be particularly fast so you should benchmark it
11:14:03 <roconnor> b_jonas: what was your question that started this?
11:14:52 <ski> (b_jonas,dmwit_ : any comments on the zipping before i go ?)
11:18:07 <dmwit_> ski: Not much other than, "neat!"
11:18:29 <ski> b_jonas : `return' and `(>>=)' is defined near the top, under the data type definition
11:19:36 <quicksilver> ivan: not fussed about translucency but I am certainly fussed about antialiasing.
11:19:57 <ski> (one can ponder whether this encoding using a few mutually recursive "state" types would be automatically constructable from a pattern-matching function)
11:21:27 <ksf> is there an inverse to continuations?
11:21:39 <vixey> ksf, that doesn't make sense to me
11:21:47 <vixey> ksf, what does inverse mean ?
11:21:55 <ksf> like COME FROM vs. GOTO
11:22:17 <vixey> I don't see continuations in any way similar to either of those
11:22:21 <ksf> a thing that represents the program up to the current computation.
11:22:34 <ski> `state-in-context' might be considered "inverse" to continuations, FSVO "inverse" ..
11:23:02 <ski> @unmtl a -> Cont r b
11:23:02 <lambdabot> a -> Cont r b
11:23:09 <ski> bah
11:23:18 <ski> a -> ((b -> r) -> r)
11:23:24 <b_jonas> rocconor: my question was how a pure functional unlambda-like language looked like
11:23:26 <ski> (b -> r) -> (a -> r)
11:23:29 <dmwit_> ?unmtl Cont r b
11:23:30 <lambdabot> (b -> r) -> r
11:23:38 <ski> now compare this with
11:23:46 <ski> (s -> a) -> (s -> b)
11:23:53 <ski> (s,s -> a) -> b
11:23:54 <vixey> oh oh!
11:24:01 * vixey sticks her hand up
11:24:02 <ski> Cxt s a -> b
11:24:15 <b_jonas> there's an unmtl? wow!
11:24:21 <ski> where `Cxt s' is the "state-in-context" comonad on the type `s'
11:24:23 <vixey> it's yoneda lemma ski ?
11:24:25 <b_jonas> can it do values as well as types?
11:24:37 <vixey> b_jonas, only typed
11:24:40 <vixey> b_jonas, only types*
11:25:19 <ski> vixey : it's possibly yoneda is sneaking around somewhere here .. i don't know him well enough to tell reliably
11:26:35 <ski> the state-in-context comonad <http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.Context.html>
11:26:35 <lambdabot> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.Context.html>
11:27:29 <ksf> vixey, continuations are kinda similar to first-class gotos.
11:27:36 <ksf> modulo scoping and such.
11:27:39 <askentasken> vixey is a girl!?
11:27:59 <ski> (hmm, actually .. iirc since yoneda had to do with cps, it may in fact be coyoneda that's appearing here .. or is it yoneda anyway ?)
11:28:20 <vixey> ksf, I don't tend to look at it at that (operational) level, and I don't really like the goto metaphor but I guess I see what you mean
11:28:56 <vixey> ski, ok. I have not heard of coyoneda and I don't know which way the arrows are _supposed_ to go :)
11:29:04 <dons> Lemmih: so give me an ok to release, and i will do so.
11:29:21 <ski> (i've not heard of coyoneda either .. which is why i'm unsure)
11:29:42 <vixey> ski, fwiw, djinn may help
11:29:51 <vixey> oh
11:29:52 <ski> with what ?
11:29:58 <vixey> no sorry djinn isn't useful
11:30:03 <vixey> I need rank 2 types
11:30:12 <ksf> ski, that comes awfully close to what I'm looking for, if it's not exactly that.
11:30:19 <ski> vixey : to prove what ?
11:30:19 <vixey> I was going to ask it something
11:30:38 <vixey> (a -> b) <-or-> (forall k. (b -> k) -> (a -> k))
11:30:55 <vixey> I think yo ucan't go both ways without AC or something..
11:31:12 <ski> ksf : i may have experimented a bit with something, if generously viewed, possibly in a similar spirit to "COME FROM"
11:31:32 <Stalin> hi all
11:31:57 <vixey> hello Stalin
11:32:33 <Lemmih> dons: It works great. Thanks.
11:32:33 <Stalin> I keep getting a "infinite type" error and I can't figure out the cause
11:32:53 <Lemmih> dons: I would still love to get the buffer size issue resolved.
11:33:12 <ski> @type let foo :: (a -> b) -> (forall r. (b -> r) -> (a -> r)); foo ab br a = br (ab a) in foo
11:33:12 <lambdabot> forall a b r. (a -> b) -> (b -> r) -> a -> r
11:33:15 <ski> @type let bar :: (forall r. (b -> r) -> (a -> r)) -> (a -> b); bar br_ar = br_ar id in bar
11:33:16 <lambdabot> forall b a. (forall r. (b -> r) -> a -> r) -> a -> b
11:33:16 <dons> Lemmih: what was that? the ability to tune the chunk size of lazy bytestrings?
11:33:27 <dons> ah since we might use chunk after chunk when putting
11:33:31 <ski> @hpaste
11:33:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:33:51 <dons> Lemmih: so you confirmed the performance was back to normal?
11:33:52 <ski> Stalin : possibly it would be nice if you showed the code in question, e.g. at that pastebin
11:34:03 <ski> (Stalin : including the error message)
11:34:11 <Stalin> http://hpaste.org/11892
11:34:15 <albdogo> hi
11:34:40 <Lemmih> dons: Yes, performance is back to normal.
11:35:20 <ski> Stalin : are you sure you don't mean `duplitimes :: Num a => a -> [b] -> [b]' ?
11:35:20 <vixey> Stalin, remove this line:   duplitimes :: (Num a) -> [b] -> [b]
11:35:25 <dons> if you want to write down the buffer size issue, and describe how to fix it, we could htink about it. otherwise, send a patch.
11:35:32 <dons> Lemmih: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
11:35:43 <lambdabot> Title: HackageDB: binary-0.4.4
11:35:44 <Stalin> vixey, ok, but can you tell me why this goes wrong?
11:35:49 <ski> Stalin : remember, `Num' is not a type, it is a type-class
11:36:07 <vixey> Stalin: this line  duplitimes :: (Num a) -> [b] -> [b]  is a lie
11:36:24 <ski> Stalin : what you wrote said that the first argument was of type `Num a' .. have you defined a type (constructor) `Num' ?
11:36:30 <vixey> Stalin: if you remove it, you can load this into ghci and do  :t duplitimes  and ghci will tell you what it should have been
11:36:59 * roconnor reads about unlambda
11:37:00 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
11:38:02 <Stalin> great, now it works
11:38:15 <Stalin> turns out it had to be [[b]] not [b]
11:38:26 <Stalin> thanks
11:38:30 <ski> Stalin : also, note that the `=>' and the `->' mean different things .. `->' is used to separate argument types from result type, while `=>' is used to separate type class constraints (like which types should be ordered, numeric, et.c.), from the actual type
11:38:42 <Stalin> I know that
11:38:49 <vixey> Stalin, you can also just leave out the annotation completely if you like
11:39:12 <Stalin> I read that one should annote his/her functions
11:39:24 <Stalin> although that might have been just a style guideline
11:39:31 <dons> ?users
11:39:32 <lambdabot> Maximum users seen in #haskell: 559, currently: 539 (96.4%), active: 24 (4.5%)
11:39:38 <vixey> Stalin, Well I say that one should not annotate :)
11:39:44 <roconnor> I wish unlambda used bckw instead of ski
11:39:52 <vixey> Stalin, so there is for and against ..
11:39:59 <Stalin> and I still can't fathom how [b] would be an infinite type
11:40:00 * byorgey votes 'for'
11:40:00 <ski> roconnor : instead of what ?
11:40:07 <Stalin> could someone enlighten me?
11:40:11 <byorgey> especially for beginners
11:40:23 * quicksilver votes 'against' for beginners
11:40:31 <quicksilver> (but 'for' for advanced programmers)
11:40:32 <vixey> Stalin, if b = [b], then b = [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...
11:40:51 <byorgey> [b] itself is not an infinite type
11:41:04 <Stalin> yeah, but I wrote it as [b] -> [b]
11:41:09 <ski> Stalin : haskell wanted the result type `[[b]]' but you had written `[b]', so those must be equal : `[b] = [[b]]', see vixey above
11:41:15 <vixey> Stalin, but did you try not having any annotation?
11:41:22 <quicksilver> for beginners it's more enlightening to write the function and see what type is inferred.
11:41:24 <Stalin> no, I haven't
11:41:26 <vixey> Stalin, see how ghci figures out what the type is from the _code_
11:41:29 <ddarius> vixey: (a -> b) ~ (forall x. (a -> x) -> (b -> x)) is a simple corollary of the yoneda lemma.
11:41:38 <albdogo> [[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]
11:41:41 <vixey> Stalin, then it tries to match it up with your annotation, and _that_ is what caused b = [b]
11:41:52 <Stalin> I see
11:41:56 <Stalin> thanks
11:42:01 <eu-prleu-peupeu> hi haskellians
11:42:06 <Stalin> hello
11:42:11 <vixey> ddarius, ah so it's not hte real theorem,, ok thanks
11:42:19 <dmwit_> eu-prleu-peupeu: Hiya!
11:42:25 <ski> (ddarius : s/(a -> b)/(b -> a)/)
11:42:41 <ddarius> ski: Yes, or switch the location of the x.
11:43:09 <ski> ddarius : how about `(a -> b) ~ (forall x. (x -> a) -> (x -> b))', yoneda too ?
11:43:15 <ddarius> Yes.
11:44:00 <ski> what about `a ~ (forall x. (a -> x) -> x)' respectively `a ~ (exists x. (x,x -> a))' ?
11:44:39 <ddarius> The former is the Yoneda lemma for F = Id
11:45:23 <ski> (yes, istr the first was .. but not sure about the second)
11:46:45 <telexicon> is there a prepackaged getLine or equivalent that will break at CRLF?
11:47:34 <ski> telexicon : try open the file in text mode, using `hGetLine' ?
11:47:43 <telexicon> ski, its not a file
11:48:15 <ddarius> ski: Both may be instances of the Yoneda isomorphisms which relate the Yoneda embedding to indexed (co)limits.
11:48:56 <ddarius> Or also instances of how the Yoneda embedding interacts with Kan extensions.
11:49:30 <jkr_> Can someone point me to an article or something that explains the dot syntax in Haskell?
11:49:38 <dmwit_> ?src (.)
11:49:38 <lambdabot> (f . g) x = f (g x)
11:49:43 <vixey> jkr, this f . g . h stuff?
11:49:47 <jkr_> Yup
11:49:50 <dmwit_> jkr_: It's just a function, as defined there.
11:49:55 <dmwit_> jkr_: It's function composition from maths.
11:50:01 <vixey> jkr, well   (f . g) . h = f . (g . h)
11:50:13 <vixey> jkr,  (f . g)^-1 = g^-1 . f^-1
11:50:26 <roconnor> (f . id) = f = (id . f)
11:50:37 <roconnor> @free (.)
11:50:37 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
11:50:51 <vixey> @free compose :: (b -> c) -> (a -> b) -> (a -> c)
11:50:52 <lambdabot> g . k = p . f => f . q = f1 . h => g . compose k q = compose p f1 . h
11:50:54 <dmwit_> ?free (b -> c) -> (a -> b) -> (a -> c)
11:50:54 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
11:51:07 <dmwit_> Ah, you beat me to it. =)
11:51:09 <ski> ddarius : ok
11:51:09 <vixey> jkr, I prefer the type written as  (c <- b) -> (b <- a) -> (c <- a)
11:51:18 <vixey> <- read as from
11:51:40 <roconnor> vixey: oh, what a good idea
11:51:45 <ddarius> :t flip (.)
11:51:46 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
11:52:01 <albdogo> @src StateMonad
11:52:01 <lambdabot> Source not found. That's something I cannot allow to happen.
11:52:08 <jkr_> I still don't get it :) I'll better search realworldhaskell for dots :)
11:52:15 <dmwit_> ?source State
11:52:16 <lambdabot> State not available
11:52:21 <vixey> jkr, what don't you get?
11:52:24 <dmwit_> ?source Control.Monad.State
11:52:24 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
11:52:27 <dmwit_> albdogo: ^^
11:52:31 <jkr_> Well, what it is good for
11:52:37 <jkr_> And what it does
11:52:53 <ski> (vixey : did you get that from the catsters as well ?)
11:52:56 <dmwit_> ?source Control.Monad.State.Lazy
11:52:56 <lambdabot> Control.Monad.State.Lazy not available
11:52:57 <b_jonas> hmm
11:53:07 <vixey> jkr, it's the primitive thing that you can put together lots of different functions
11:53:11 <roconnor> > map (fromEnum) ['a'..'z']
11:53:13 <ski> (.. or maybe Bird and Meertens ?)
11:53:13 <lambdabot>   [97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,1...
11:53:20 <vixey> ski, yeah,  :) Algebra of Programming
11:53:42 <dmwit_> jkr_: It's useful when you have a "pipeline" of functions that you want to apply in sequence.
11:53:52 <roconnor> > map (toRational) map (fromEnum) ['a'..'z']
11:53:53 <lambdabot>   Couldn't match expected type `[a]'
11:53:56 <ski> (vixey : i decided a while a go i wanted to use that syntax in types in my language :)
11:54:01 <roconnor> > map (toRational) $ map (fromEnum) ['a'..'z']
11:54:02 <lambdabot>   [97%1,98%1,99%1,100%1,101%1,102%1,103%1,104%1,105%1,106%1,107%1,108%1,109%1...
11:54:13 <roconnor> > map (toRational . fromEnum) ['a'..'z']
11:54:15 <lambdabot>   [97%1,98%1,99%1,100%1,101%1,102%1,103%1,104%1,105%1,106%1,107%1,108%1,109%1...
11:54:19 <vixey> ski, it is pleasing that you can just define it as an infix op in Coq
11:54:23 <dmwit_> jkr_: f (g (h (j x))) -> f . g . h . j $ x
11:54:29 <roconnor> jkr_: usefull for that
11:54:34 <ski> vixey : how about dependent ?
11:54:43 <jkr_> Ahh
11:54:53 <ski> vixey : `F a <- (a : A)' or somesuch possible ?
11:54:57 <jkr_> dmwit_: Thanks, that explains it :)
11:54:58 <vixey> ski, that would freak me out .. backwards binding
11:54:59 <jkr_> Thanks a lot
11:55:06 <ski> hehe
11:55:12 <vixey> ski, but possible, yes I think so
11:55:14 <ski> > x where x = ()
11:55:15 <lambdabot>   ()
11:55:17 <vixey> eep
11:55:44 <roconnor> what?
11:55:49 <roconnor> > x where x = ()
11:55:50 <lambdabot>   ()
11:55:54 <vixey> > let in ()
11:55:55 <ddarius> ski: Yes, but those are at syntactically different levels.
11:55:55 <lambdabot>   ()
11:55:57 <roconnor> > x where x = 5
11:55:59 <lambdabot>   5
11:55:59 <b_jonas> I think in ghc you can define "type :<- a b = b -> a;"
11:56:12 <jkr_> dmwit_: Couldn't you use $ instead in that example?
11:56:13 <vixey> b_jonas, *nod* I just don't like that :<-
11:56:21 <roconnor> > (x+1) where x = 5
11:56:22 <lambdabot>   6
11:56:23 <dmwit_> b_jonas: What's that semicolon doing in my Haskell!
11:56:27 <vixey> type a :<- b though
11:56:28 <ski> ddarius : sure .. just showing that it isn't so foreign a concept as it might seem
11:56:33 <roconnor> since when can we do that?
11:56:35 <jkr_> a $ b $ c $ d $ param == a (b (c (d param)))
11:56:36 <dmwit_> jkr_: Yes, but I consider that bad form for a couple of reasons.
11:56:50 <ddarius> ski: Foreigness isn't the problem.  It would be unreadable.
11:56:53 <dmwit_> jkr_: First: it makes it more difficult to refactor by naming a part of the pipeline.
11:56:55 <ski> > map f [0,1,2,3]   where  f x = x * x
11:56:56 <lambdabot>   [0,1,4,9]
11:57:12 <b_jonas> maybe you could put the whole program in a scope where <- is a bound type variable, and make it so that it unifies with :<-
11:57:12 <vixey> jkr_, $ only works one way, though  i.e.  (f $ g) $ h /= f $ (g $ h)
11:57:14 <dmwit_> jkr_: (You can't just grab (foo = b $ c $ d) and use (a $ foo $ param).)
11:57:14 <ski> ddarius : why ?
11:57:16 <slamsamlare> anyone goot with proofgeneral?
11:57:19 <slamsamlare> dear vixey
11:57:30 <roconnor> I'm pretty sure :<- is the cuthulu type constructor
11:57:32 <slamsamlare> can you help me oh sweet sweet woman?
11:57:32 <b_jonas> yeah, type a :<- b
11:57:32 <dmwit_> jkr_: (Whereas grabbing (foo = b . c . d) and using (a . foo $ param) works just fine.)
11:57:35 <vixey> jkr_, so a big chain of $'s is very hard to reason with, chop up etc
11:57:45 <dmwit_> jkr_: Another reason is that I believe ($) should be right-associative.
11:57:47 <vixey> slamsamlare: don't even start
11:57:59 <dmwit_> jkr_: And if that change ever gets made, your chain of ($)'s would die horribly in a fire.
11:58:05 <slamsamlare> vixey: with what?
11:58:08 <dmwit_> errr...
11:58:10 <dmwit_> left-associative
11:58:19 <jkr_> Ok, got it :)
11:58:21 <vixey> slamsamlare: conversation over
11:58:31 <slamsamlare> oh my, sensitive
11:58:37 <slamsamlare> i was just kidding with you
11:58:47 <slamsamlare> i just need some help
11:59:04 <RLa> is not function or binary operator?
11:59:08 <RLa> unary*
11:59:14 <vixey> jkr_: (not one of those properties about (.) we mentioned earlier hold for ($))
11:59:19 <dmwit_> :t not -- RLa
11:59:20 <lambdabot> Bool -> Bool
11:59:37 <dmwit_> RLa: How would "not" be a binary operator, anyway?
11:59:38 <RLa> dmwit_,  are there unary operators at all?
11:59:45 <ddarius> ski: Because reading left to right, when you see a variable it wouldn't be clear where to jump to to see it's definition because the term could have complex structure and nothing distinguishes the binders from each other.  With 'where', you just jump to the where clause.  You are much harder pressed to having complexly nested/scoped where clauses.
11:59:48 <dmwit_> RLa: Ah, I see what you're asking.
12:00:12 <dmwit_> > let (!) 0 = 1; (!) n = n * ((!) (n-1)) in (5!)
12:00:13 <lambdabot>   120
12:00:20 <dmwit_> RLa: But it's an extension, and it's kind of ugly.
12:00:31 <dmwit_> RLa: Usually, if you want a unary function, you just name it.
12:00:34 <vixey> > let (0!) = 1; (!) n = n * ((!) (n-1)) in (5!)
12:00:35 <lambdabot>   <no location info>: Parse error in pattern
12:00:38 <vixey> > let 0! = 1; (!) n = n * ((!) (n-1)) in (5!)
12:00:39 <lambdabot>   <no location info>: parse error on input `='
12:00:45 <vixey> rubbish extension
12:00:47 <dmwit_> RLa: Note that there is a special case for unary -.
12:00:50 <ski> > let x = 5 in - x
12:00:51 <lambdabot>   -5
12:00:56 <dmwit_> there we go
12:00:56 <RLa> uh
12:01:03 <RLa> - is unary
12:01:13 <dmwit_> RLa: right, special case
12:01:23 <dmwit_> RLa: ...special cased *in the parser*, no less. =/
12:01:30 <b_jonas> yeah
12:01:47 <RLa> i'm asking because i have to parse fun. language
12:01:48 <b_jonas> and you can define negate in Num to overload it
12:02:18 <RLa> how would f unary_op 2 + 3 parse?
12:02:41 <ddarius> ski: If where clauses were free expressions forms like 'let', then there wouldn't be much difference.
12:02:50 <dmwit_> RLa: That would parse as a binary operator.
12:03:05 <RLa> f g 2 +3 would be ((f g) 2) + 4 when g is function, is that correct
12:03:07 <ski> ddarius : difference to what ?
12:03:17 <dmwit_> RLa: correct
12:03:31 <dmwit_> RLa: f - 2 + 3 would parse as (f - 2) + 3
12:03:40 <RLa> oh
12:03:45 <ddarius> ski: Difference to a dependent type binder that followed it's bindees.
12:03:51 <RLa> because - is binary op as well?
12:03:53 <ddarius> ski: They'd both be unreadable.
12:04:02 <dmwit_> RLa: i.e. "f g 2 + 3" and "f `g` 2 + 3" parse differently (no surprise).
12:04:03 <ski> ddarius : you're claiming complexly nested/scoped where clauses would be as bad as (you claim) `F a <- (a : A)' would be ?
12:04:26 <ski> ok
12:04:31 <RLa> ok, i cannot use `'s so no problem that way
12:04:40 <ddarius> ski: I'm claiming that if where clauses were where expressions, then yes it could and probably would be.
12:04:49 <ski> (not arguing, just interested in opinion and reasons)
12:05:04 <RLa> do we need unary operators at all?
12:05:32 <ddarius> RLa: Of course not.
12:05:33 <ski> (ddarius : in the worst case .. i.e. assuming people would frequently (ab)use them like that, if possible)
12:06:17 <ddarius> ski: Actually in practice it probably wouldn't be as bad as dependent binding expressions seem to get more structurally complex than typical value bindings.
12:06:37 <ski> (if we wanted to write `n ! !' we'd need (postfix) unary operato)
12:06:47 <ski> ddarius : ok
12:08:44 <dmwit_> > let (!) 0 = 1; (!) n = n * ((n-1)!) in ((5!)!)
12:08:45 <lambdabot>   668950291344912705758811805409037258675274633313802981029567135230163355724...
12:09:37 <ski> (that needs paren between the "!" ..)
12:09:41 <ddarius> > product [2..120]
12:09:42 <lambdabot>   668950291344912705758811805409037258675274633313802981029567135230163355724...
12:11:09 <jeffwheeler> >let (!) n = product [1 .. n] in (!) 120
12:11:49 * ski feeds lambdabot an extra space
12:11:57 <jeffwheeler> > let (!) n = product [1 .. n] in (!) 120
12:11:58 <lambdabot>   668950291344912705758811805409037258675274633313802981029567135230163355724...
12:12:05 <jeffwheeler> Doh.
12:12:52 <b_jonas> > let { (!) = product . EnumFromTo 1; } in (!) 5
12:12:54 <lambdabot>   Not in scope: data constructor `EnumFromTo'
12:12:56 <b_jonas> > let { (!) = product . enumFromTo 1; } in (!) 5
12:12:58 <lambdabot>   120
12:13:19 <b_jonas> > let { (!) = product . enumFromTo 1; } in (5!)
12:13:21 <lambdabot>   120
12:13:24 <b_jonas> > let { (!) = product . enumFromTo 1; } in (5 :: Int !)
12:13:25 <lambdabot>   <no location info>: parse error on input `)'
12:13:29 <b_jonas> > let { (!) = product . enumFromTo 1; } in ((5 :: Int) !)
12:13:31 <lambdabot>   120
12:13:32 <vixey> @let (!) = product . enumFromTo 1
12:13:34 <lambdabot>  Defined.
12:13:39 <jeffwheeler> > let (!) n = product [1 .. n] in (120!)
12:13:39 <vixey> > (       4!       )
12:13:41 <lambdabot>   668950291344912705758811805409037258675274633313802981029567135230163355724...
12:13:41 <lambdabot>       Ambiguous occurrence `!'
12:13:41 <lambdabot>      It could refer to either `Data.Array.!', ...
12:13:53 <b_jonas> > ((5 :: Int) !)
12:13:54 <lambdabot>       Ambiguous occurrence `!'
12:13:54 <lambdabot>      It could refer to either `Data.Array.!', ...
12:14:12 <jeffwheeler> > let (!) n = product [1 .. n] in 120!
12:14:14 <lambdabot>   <no location info>: parse error on input `;'
12:14:20 <jeffwheeler> :(
12:14:24 <b_jonas> also, that definition needs a type I think
12:14:33 <b_jonas> the pl one that is
12:14:40 <b_jonas> for monomorphism restriction
12:14:54 <ski> (i suppose a reason for wanting `f : A <- B' would be that application is written with argument to the right `f x : A', given `x : B' .. so `(<- B)' is the right adjoint to `(* B)', which seems proper, somehow)
12:15:37 <ski> (.. so `apply : (A <- B) * B  >->  A')
12:17:44 <ski> (.. another variant would be `A ^ B' :)
12:20:42 <C-Keen> hm has anyone else problems with building cabal-install with ghc-6.10.2?
12:21:02 <C-Keen> It seems that memory requirements increased a lot since 6.8
12:21:06 <C-Keen> Is this possible?
12:21:19 <vixey> C-Keen, loads of problems with cabal.. none that I managed to fix :)
12:21:35 <FunctorSalad> C-Keen: tried the 0.6 dev version? fixed the memory issues for me
12:21:51 <C-Keen> FunctorSalad: ah no, I will do so. Thanks for the hint
12:21:54 <Saizan> C-Keen: in 0.5.2 there's a bug triggered by ghc 6.10
12:22:00 <Saizan> so you want 0.6
12:22:02 <b_jonas> heh
12:22:05 <C-Keen> alright
12:22:50 <Saizan> dcoutts_: maybe there should be an annouce somewhere about using cabal-install 0.6 on ghc 6.10?
12:27:11 <ac> what do you all think of BitC?
12:27:51 <vixey> ac, I am not curious enough about it to use it .......
12:28:06 <vixey> ac, does it generate really fast code?
12:28:19 <ac> vixey: that's definitely a design goal
12:28:31 <vixey> can you do untyped programming in it?
12:28:33 <wolverian> hm, no-one happens to have ghc 6.10 in a ubuntu ppa?
12:28:50 <ac> vixey: it's strongly and statically typed. I haven't used it either, but I was just reading about it today
12:29:06 <vixey> I was thinking, if it's very efficient and untyped it could be a useful IL
12:30:25 <Kerris4> wolverian: it looks like Arch is the Haskell Way Forward :v
12:38:09 <unenough> what's the tuple function?
12:38:30 <unenough> \a b ->(a,b)
12:38:48 <RayNbow> @pl \a b -> (a,b)
12:38:49 <lambdabot> (,)
12:38:58 <unenough> > (,) 1 2
12:38:59 <lambdabot>   (1,2)
12:39:03 <unenough> ok
12:39:29 <RayNbow> (,) is the 2-tuple constructor :)
12:39:36 <RayNbow> > (,,) 1 2 3
12:39:38 <lambdabot>   (1,2,3)
12:39:56 <unenough> got it
12:40:22 <vixey> > (,,,) 1 2 3 4
12:40:23 <lambdabot>   (1,2,3,4)
12:41:41 <unenough> > flip (,,,) 1 2 3 4
12:41:42 <lambdabot>   (2,1,3,4)
12:41:55 <unenough> > flip flip flip (,,,) 1 2 3 4
12:41:56 <lambdabot>   Couldn't match expected type `t1 -> t'
12:42:05 <unenough> never mind, just messing around.
12:42:09 <vixey> > (flip . flip . flip) (,,,) 1 2 3 4
12:42:10 <lambdabot>   (2,1,3,4)
12:42:22 <vixey> > flip ((flip . flip . flip) (,,,) 1) 2 3 4
12:42:23 <lambdabot>   (3,1,2,4)
12:42:37 <vixey> > ((flip .) . (flip . flip . flip)) (,,,) 1 2 3 4
12:42:38 <lambdabot>   (3,1,2,4)
12:42:49 <vixey> > (((flip .) .) . (flip . flip . flip)) (,,,) 1 2 3 4
12:42:50 <lambdabot>   (2,1,4,3)
12:42:57 <unenough> will vixey terminate?
12:43:07 <vixey> Learng FORTH with Haskell
12:43:16 <unenough> forth?
12:48:56 <Peaker> unenough: forth is an interesting language.. very weird..
12:49:19 <BMeph> Peaker: I <3 Forth. :)
12:49:49 <sbahra> Peaker, why?
12:50:49 <thoughtpolice> forth is a very peculiar language - 'low floor, high ceiling'
12:51:20 <sbahra> I see.
12:52:02 <sbahra> FreeBSD has a forth interpreter for bootstrapping stage.
12:52:04 <sbahra> Kind of nice.
12:52:38 <eu-prleu-peupeu> how about this for recursion: http://www.myextralife.com/?p=10049
12:52:39 <BMeph> Forth is what Lisp might have been if done by a programmer instead of a scientist. :)
12:52:40 <lambdabot> Title: EXTRALIFE - By Scott Johnson Â» Blog Archive Â» Awesomeâ¦
12:53:22 <vixey> Forth is the only language (family) I cannot program a bloody thing in
12:53:33 <osfameron> cobol?
12:53:47 <BMeph> Best comment quote: "hufrickenlarious"
12:54:04 <ddarius> vixey: Why not?
12:54:28 <vixey> I probably try to write the wrong programs in it
12:56:36 <ddarius> I like some aspects of Forth, but I think factor does a decent job improving some of the aspects I don't like, but it loses a bit.
12:56:49 <unenough> Wohoo! I did it
12:56:52 <unenough> > foldr (\x f_rest ->  (\(y:ys)->(x,y):(f_rest ys)) )  (\_ -> []) [1,2]   ["a","b"]
12:56:53 <lambdabot>   [(1,"a"),(2,"b")]
12:57:02 <roconnor> eu-prleu-peupeu: that doesn't make any sense.  The metro is a dutch paper, but the article is in english!
12:57:28 <eu-prleu-peupeu> roconnor: metro is a global newspaper... we have it here in portugal also
12:57:40 <eu-prleu-peupeu> and probably in england
12:57:48 <roconnor> eu-prleu-peupeu: wholy crap!  I didn't know that
12:57:52 <eu-prleu-peupeu> ;)
12:58:10 <vixey> I tried to just pick up Joy and start programming but that didn't work.. so I read a couple books on forth but still ..  totally unable to write anything in it
12:58:13 <Peaker> unenough: \_ -> [] is (const [])
12:58:29 <unenough> Peaker, yes. i didn't point-less it yet
12:58:34 <vixey> I thought that some of the code was nice like the sokoban game I read was short but then .. it's shorter in Prolog ..
12:58:34 <roconnor> @pl (\_ -> [])
12:58:35 <lambdabot> const []
12:59:05 <Peaker> unenough: you did use pattern matching in there, though. Can you do it without any list pattern matching? :)
12:59:14 <unenough> Also it doesn't deal with the case of the first list being longer than the second yet.
12:59:16 <Peaker> unenough: also, that will have a big problem if the second list is shorter...
12:59:25 <Peaker> (oh, vice versa, yeah)
12:59:30 <unenough> vice versa works
12:59:37 <BMeph> vixey: Just to warn you, but Joy (and Factor) are like Forth in some ways, but are distinctly UNlike it in important ways. :)
12:59:46 <RLa> vixey, i remember that sokoban game, did you also add gui later to it?
13:00:03 <vixey> RLa, no
13:00:13 <ddarius> I much prefer the way joy and factor handle control as opposed to how forth does.
13:00:37 <vixey> RLa, I would like to but I don't have much motivation for it
13:02:20 <RayNbow> <roconnor> eu-prleu-peupeu: that doesn't make any sense.  The metro is a dutch paper, but the article is in english! <-- you've been too long in the Netherlands, roconnor... it's starting to affect you :p
13:02:31 <BMeph> ddarius: That's because Joy introduced code quotation, isn't it? :)
13:04:10 <mdmkolbe> What is the best way to convert from a CChar to a Char and vice versa?
13:04:44 <Peaker> @hoogle CChar -> Char
13:04:45 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
13:04:45 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:04:45 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
13:05:04 <b_jonas> @type toEnum
13:05:05 <lambdabot> forall a. (Enum a) => Int -> a
13:05:10 <ddarius> BMeph: That it uses quotation for control is why, though the "quoting" aspect of quotation isn't particularly important.  Basically it uses HOFs for control much like Smalltalk which is perfectly reasonably if you choose a lightweight "lambda" notation.
13:06:02 <mdmkolbe> thx Peaker, I guess I should have looked in Foreign.C.String instead of Foreign.C.Types
13:06:40 <Peaker> mdmkolbe: I have no idea if that's a reasonable thing to do, but hoogle is great ;)
13:07:04 <Peaker> I think Hoogle and PL are the sexiest Haskell things :)
13:07:10 <EvilTerran> i suspect betweEnum would work too
13:07:19 <mdmkolbe> @type betweenEnum
13:07:20 <Peaker> (@pl that is)
13:07:21 <lambdabot> Not in scope: `betweenEnum'
13:07:29 <EvilTerran> sorry, "toEnum.fromEnum"
13:07:37 <mdmkolbe> Peaker don't forget djinn
13:08:40 <b_jonas> @djinn CChar -> Char
13:08:41 <lambdabot> Error: Undefined type CChar
13:08:50 <vixey> :t toEnum . fromEnum
13:08:50 <lambdabot> forall a a1. (Enum a1, Enum a) => a1 -> a
13:08:55 <vixey> @let castEnum = toEnum . fromEnum
13:08:56 <lambdabot>  <local>:2:11:
13:08:56 <lambdabot>      Ambiguous type variable `a' in the constraint:
13:08:56 <lambdabot>        `En...
13:09:08 <vixey> @set -XNoMonomorphismRestriction
13:09:09 <lambdabot>   Parse error
13:09:12 <mdmkolbe> @type fromEnum
13:09:13 <lambdabot> forall a. (Enum a) => a -> Int
13:09:45 <Peaker> mdmkolbe: @djinn would be sexy if it actually solved any interesting problem ;)
13:09:53 <Peaker> mdmkolbe: it seems to fail on anything that's not super-trivial
13:10:18 <ddarius> Peaker: Djinn can create all of the definitions related to CPS and such.
13:10:56 <vixey> the source code of djinn is actually so complex
13:11:02 <vixey> I wonder why it is so complicated
13:11:09 <vixey> @go leanTAP
13:11:16 <lambdabot> http://www.uni-koblenz.de/~beckert/leantap/
13:11:16 <lambdabot> Title: The leanTAP Home Page
13:11:17 <vixey> It needn't be much longer that leanTAP right ?
13:11:19 <vixey> ileanTAP*
13:11:45 <b_jonas> @let castEnum :: (Enum a, Enum b) => a -> b; castEnum = toEnum . fromEnum;
13:11:46 <lambdabot>  Defined.
13:11:57 <vixey> then again, I have no idea why the original prolog code djinn is based on is so long either
13:12:04 <b_jonas> > castEnum LT :: Float
13:12:05 <lambdabot>   0.0
13:12:09 <vixey> hh
13:12:09 <b_jonas> > castEnum GT :: Float
13:12:11 <lambdabot>   2.0
13:12:14 <ddarius> vixey: Rewrite djinn.
13:12:35 <vixey> I did do a tiny fragment of a djinn thing :)
13:12:45 <vixey> just testing out some idea though
13:12:53 <ddarius> It's basically a LP implementation that keeps track of the steps it takes.
13:14:00 <b_jonas> @djinn Either () a -> Maybe a
13:14:01 <lambdabot> f a =
13:14:01 <lambdabot>     case a of
13:14:01 <lambdabot>     Left _ -> Nothing
13:14:01 <lambdabot>     Right b -> Just b
13:14:09 <b_jonas> @djinn Either Bool a -> Maybe a
13:14:10 <lambdabot> f a =
13:14:10 <lambdabot>     case a of
13:14:10 <lambdabot>     Left _ -> Nothing
13:14:10 <lambdabot>     Right b -> Just b
13:14:22 <EvilTerran> @djinn (Bool,a) -> Maybe a
13:14:22 <b_jonas> @djinn Maybe a -> Either () a
13:14:23 <lambdabot> f (a, b) =
13:14:23 <lambdabot>     case a of
13:14:23 <lambdabot>     False -> Nothing
13:14:23 <lambdabot>     True -> Just b
13:14:23 <lambdabot> f a =
13:14:25 <lambdabot>     case a of
13:14:27 <lambdabot>     Nothing -> Left ()
13:14:29 <lambdabot>     Just b -> Right b
13:14:59 <b_jonas> @djinn () -> Maybe a
13:15:00 <lambdabot> f _ = Nothing
13:15:19 <Peaker> hmm, these are not super-trivial. Cool ;)
13:15:36 <wolverian> um, how do I tell ghci to interpret a file instead of compiling it, so that I can debug it?
13:15:50 <Peaker> can Djinn be used on complex types (typeclasses/etc)
13:15:51 <vixey> wolverian:  :load file
13:15:58 <wolverian> vixey, that compiles.
13:16:02 <vixey> Peaker: djinn can't properly do typeclasses
13:16:03 <dmwit_> Peaker: /msg lambdabot ?djinn-env
13:16:25 <Peaker> wolverian: You might need to delete the compiled file from before. It will compile with debug information when you :load iirc
13:16:25 <vixey> Peaker: I suspect it would be undecideable but I'm not sure yet
13:16:31 <wolverian> Peaker, ah. thanks.
13:16:41 <Peaker> vixey: I thought djinn is in general undecidable and that it just solves specific-cases
13:16:48 <vixey> no
13:16:52 <dhpe> wolverian: :l *file
13:17:03 <wolverian> dhpe, I'm on 6.8 :(
13:17:06 <Peaker> vixey: s/specific/non-general
13:17:10 <wolverian> anyway, removing the compiled files worked. thanks.
13:19:07 <Peaker> vixey: so why does djinn not solve all of the correctly formulated problems?
13:19:30 <vixey> it always terminates with the right answer
13:20:01 <Peaker> @djinn a -> b -> ((a,b) -> c) -> c
13:20:01 <lambdabot> f a b c = c (a, b)
13:20:08 <vixey> I think you would lose that property if you added typeclasses, but I'm not certain
13:20:20 <Peaker> hmm, I seem to remember djinn failing to solve most things I threw at it
13:20:37 <EvilTerran> i think it could deal with typeclasses fairly easily, as long as you left out undecidable instances etc
13:20:42 <vixey> ?djinn a -> b
13:20:42 <lambdabot> -- f cannot be realized.
13:20:55 <mdmkolbe> Peaker: djinn fails at monads and lists
13:21:05 <thoughtpolice> djinn can only generate code from a complete parametrically polymorphic type I thought?
13:21:12 <mdmkolbe> @djinn [a] -> (a -> b) -> [b]
13:21:12 <lambdabot> Error: Undefined type []
13:21:25 <vixey> thoughtpolice: you're not thinking of @free ?
13:21:42 <vixey> @djinn #(@*!@^1
13:21:42 <lambdabot> Cannot parse command
13:21:58 <EvilTerran> it seems to me that it could deal with list parameters via foldr
13:23:23 <yitz> vixey: djinn also fails for Perl.
13:23:38 <vixey> yitz, much to my disappointment :p
13:23:49 <Peaker> vixey: you're a Perl fan?
13:24:43 <b_jonas> EvilTerran: interesting idea
13:25:37 <unenough> Ok, next refinement:
13:25:37 <unenough> > foldr (\x f_rest ->  (liftM2 (:) (((,) x) . head) (f_rest.tail) ))  (const []) [1,2]   ["a","b"]
13:25:38 <lambdabot>   [(1,"a"),(2,"b")]
13:25:55 <dmwit_> unenough: Yikes!
13:26:09 <Peaker> unenough: you're using head and tail, still cheating ;)
13:26:13 <b_jonas> yeah
13:26:21 <unenough> give me time!
13:26:24 <ddarius> EvilTerran: Constructor classes require higher rank types.
13:26:30 <Peaker> unenough: you're going to have to go O(N^2) on this one
13:26:33 <EvilTerran> ... are you still trying to write zip in terms of foldr?
13:26:36 <vixey> f.g confuses me compared to f . g
13:26:37 <ddarius> EvilTerran: It can deal with type (kind *) classes and already has a few put in.
13:26:49 <unenough> EvilTerran, yip
13:26:51 <vixey> when I see f.g it seems like g is a field of the object f
13:26:52 <ddarius> @djinn (Eq a) => a -> a -> Bool
13:26:52 <lambdabot> f = (==)
13:27:26 <EvilTerran> ddarius, i see
13:27:31 <b_jonas> ddarius: could it deal with lists by defining it as a class with foldr and unfoldr methods?
13:28:24 <ddarius> b_jonas: No.
13:28:37 <ddarius> b_jonas: It could be extended to deal with inductive types.
13:28:54 <ddarius> (and coinductive ones)
13:28:54 <vixey> would become undecideable if you did though ?
13:29:16 <vixey> I mean the number of choices to take, becomes infininte in some cases .. during the search
13:29:18 <ddarius> vixey: It shouldn't, or at least, there should be a not useless subset that it shouldn't.
13:29:40 <ddarius> I guess it could become semidecidable.
13:29:50 <ddarius> But I think that too may be avoidable.
13:30:01 <ddarius> It certainly will lead to an explosion of possible proofs.
13:30:07 <vixey> gotta reread this book about tableaux methods I found :)
13:30:23 <srush_> can someone answer a FRP.Reactive question?
13:30:45 <dons> conal can!
13:30:50 <dons> and he's someone.
13:30:54 <srush_> nice
13:31:02 <srush_> conal, what happened to runE?
13:31:04 <conal> srush_: hi
13:31:04 <b_jonas> > ((a -> b -> b) -> b -> b) -> b
13:31:05 <lambdabot>   <no location info>: parse error on input `->'
13:31:06 <yitz> vixey: until I found LispMe, forth was the only interpreter I could run on my Palm.
13:31:09 <b_jonas> @sjinn ((a -> b -> b) -> b -> b) -> b
13:31:10 <lambdabot> -- f cannot be realized.
13:31:16 <b_jonas> @sjinn ((a -> b -> b) -> b -> b) -> Maybe b
13:31:16 <lambdabot> f _ = Nothing
13:31:20 <yitz> vixey: never really became comfortable with it tho
13:31:27 <b_jonas> yeah, that works but it's not what I want
13:31:31 <Peaker> @djinn (a -> a) -> a
13:31:32 <lambdabot> -- f cannot be realized.
13:31:32 <b_jonas> I want head from foldr
13:31:37 <Peaker> @type fix
13:31:38 <lambdabot> forall a. (a -> a) -> a
13:31:48 <vixey> :t foldr (flip const) undefined
13:31:49 <ddarius> > foldr const undefined [1,2,3]
13:31:49 <lambdabot> forall b a. [a] -> b
13:31:50 <lambdabot>   1
13:31:51 <conal> srush_: i rearranged things to clearly separate the functional interface from the "legacy adapter" stuff (connecting to imperative libs).
13:31:55 <Peaker> vixey: you said djinn always completes
13:31:55 <yitz> vixey: I once did a big project for the print industry that involved programming in forth's most famous offspring
13:32:02 <dmwit_> Peaker: If you allow general recursion, all things are provable.
13:32:05 <vixey> Peaker, yeah
13:32:05 <dmwit_> Peaker: It did complete.
13:32:07 <srush_> conal: so I see how to get stuff into event
13:32:11 <dmwit_> Peaker: And it gave the correct answer, too.
13:32:12 <srush_> but how do I get it out?
13:32:20 <vixey> Peaker, the definition of fix, fix f = f (fix f)
13:32:22 <jsn> yitz: PS ?
13:32:29 <yitz> jsn: you got it
13:32:30 <vixey> Peaker, fix being on the RHS is disallowed
13:32:33 <conal> srush_: see FRP.Reactive.LegacyAdapters.
13:32:34 <Peaker> vixey: I know, why doesn't djinn allow recursion?
13:32:43 <vixey> Peaker, the message "f cannot be realized" comes with some conditions
13:32:44 <conal> srush_: and as an example, see the reactive-glut package.
13:33:08 <mauke>  f = f
13:33:09 <vixey> Peaker: it's adapted from a theorem prover for a language that recursion doesn't have any meaning
13:33:16 <vixey> in
13:33:37 <Peaker> vixey: I see. Is it decidable if you include recursions?
13:33:44 * conal just released new versions of reactive etc -- http://hackage.haskell.org/packages/archive/recent.html
13:33:45 <lambdabot> Title: HackageDB: recent additions
13:33:49 <vixey> I should think not
13:33:52 <b_jonas> so if you have recursion then `let { f = f } in f' would solve anything, right?
13:34:00 <dmwit_> Peaker: It doesn't include recursion because it doesn't include recursion.  If you don't like that explanation, maybe you should exclude recursion. ;-)
13:34:08 <dmwit_> b_jonas: exactly
13:34:15 <b_jonas> dmwit_++ lol
13:34:15 <dmwit_> b_jonas: Everything becomes uninteresting.
13:34:28 <nomeata> @seen alpheccar
13:34:28 <lambdabot> I haven't seen alpheccar.
13:34:34 <Peaker> conal: what's the status of the darcs repo?
13:35:02 <askentasken> can you implement prolog in haskell?
13:35:04 <vixey> b_jonas, I would disallow any proof like that
13:35:05 <askentasken> well foc you can
13:35:10 <askentasken> but is it easy
13:35:13 <mauke> preflex: seen alpheccar
13:35:14 <preflex>  Sorry, I haven't seen alpheccar
13:35:23 * vixey saw alpheccar
13:35:29 <conal> Peaker: my repos are up to date.  i just pushed and hackage-released.
13:35:29 <dmwit_> askentasken: Unification can be fun and easy!
13:35:30 <vixey> ages ago... can't remember when..
13:35:36 <yitz> > cycle "it doesn't include recursion because "
13:35:37 <lambdabot>   "it doesn't include recursion because it doesn't include recursion because ...
13:35:49 <ddarius> askentasken: Easy enough.
13:36:01 <Peaker> conal: cool, is there any documentation about how to hook it to imperative libs (how to generate events/etc)?
13:36:10 <b_jonas> vixey: for lists, wouldn't using foldr and unfoldr solve that?
13:36:27 <conal> Peaker: just the reactive-glut example so far.
13:36:31 <vixey> b_jonas, well this comes back to what we were wondering before :))
13:36:36 <b_jonas> yep
13:36:45 <vixey> b_jonas, I don't think we figured out if folds are equiv. to pattern matching
13:36:47 <Peaker> conal: all I see in examples/ is fromBeelsebob.hs
13:36:53 <b_jonas> that's why I plusplussed EvilTerran above
13:37:02 <vixey> b_jonas, well, we certainly can't write an interpreter for a TC language with a fold
13:37:07 <srush_> Peaker: http://abstractabsurd.blogspot.com/2008/09/some-first-steps-with-datareactive.html shows that
13:37:09 <lambdabot> Title: Abstract Absurdities: Some first steps with Data.Reactive, http://tinyurl.com/6pmwp5
13:37:19 <vixey> b_jonas, would be nice to come up with a better example though
13:37:21 <b_jonas> vixey: haven't we? I thought we have found list foldr is equivalent to list pattern matching
13:37:22 <srush_> it's a bit out of date, but I think it works
13:37:41 <conal> i'm about to email out announcements for Reactive and FieldTrip (functional 3D).  i don't know whether to mail to haskell or haskell-cafe.  any advice?
13:37:53 <conal> (mentioning new mailing lists, trac, etc)
13:38:49 <yitz> conal: in my opinion important enough for cafe *and* haskell, as much as I try to avoid xposting.
13:39:11 <Peaker> conal: where can I find the GLUT example?
13:39:17 <srush_> http://hackage.haskell.org/packages/archive/reactive-glut/0.0.3/doc/html/src/FRP-Reactive-GLUT-Adapter.html#adapt
13:39:19 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6ehqyj
13:39:30 <conal> srush_: thx
13:40:02 <askentasken> hey hey hey implementing prolog in haskell should be easy right?
13:40:04 <conal> @wiki reactive-glut
13:40:04 <lambdabot> http://www.haskell.org/haskellwiki/reactive-glut
13:40:07 <Peaker> srush_: thanks
13:40:27 <conal> and an interface to functional graphics:
13:40:30 <conal> @wiki reactive-fieldtrip
13:40:30 <lambdabot> http://www.haskell.org/haskellwiki/reactive-fieldtrip
13:40:31 <b_jonas> @faq can you implement prolog in haskell easily?
13:40:32 <lambdabot> The answer is: Yes! Haskell can do that.
13:41:01 <thoughtpolice> conal: i only follow -cafe normally, at the very least cc the ann. to the other one :]
13:41:15 <askentasken> @faq can haskell bite b_jona sin the balls?
13:41:16 <lambdabot> The answer is: Yes! Haskell can do that.
13:41:31 <b_jonas> ouch!
13:41:41 <vixey> b_jonas, it's not easy :p
13:41:46 <srush_> the (tick     , tickSink     ) <- mkE pattern is pretty crazy
13:42:17 <vixey> without cut is easy
13:42:17 <Kerris4> askentasken: since 1999 apparently http://lambda-the-ultimate.org/node/112
13:42:29 <lambdabot> Title: Embedding Prolog in Haskell | Lambda the Ultimate
13:42:31 <vixey> afacit it's impossible to shoehorn cut into a monad (transformer)
13:43:28 <conal> srush_: criticism & suggestions are most welcome on the Reactive mailing list.
13:44:11 <ddarius> Actually, conal has a paper about implementing languages more complex than Prolog in functional languages (admittedly using an ML).
13:44:13 <vixey> sorry this is oobvious
13:44:20 <b_jonas> sure it isn't
13:44:24 <vixey> you can't have cut in a monad since that destroys associativity
13:44:31 <jsn> conal: to connect the cursor position wih an object on the screen -- is that in reactive fieldtrip?
13:44:39 <srush_> conal: it's not bad, it just feels different
13:44:44 <Cale> vixey: You can if you're willing to add additional operations...
13:44:57 <b_jonas> you need unification, backtracking, cut as you say, and stuff like that
13:44:59 <vixey> Cale, I think you must not use a monad for it though
13:45:01 <dons> conal: all the new reactive stuff builds fine, and is in Arch Linux, http://aur.archlinux.org/packages.php?O=0&L=0&C=0&K=haskell-reactive&SeB=nd&SB=n&SO=a&PP=25&do_Search=Go
13:45:02 <b_jonas> you need to implement assert
13:45:03 <lambdabot> Title: AUR (en) - Search: haskell-reactive, http://tinyurl.com/5dokwl
13:45:11 <vixey> A similar,different structure, would be fine
13:45:18 <dons> good work on a pain free upgrade
13:45:40 <conal> dons: wonderful. :)  thanks!
13:45:42 <vixey> b_jonas; ( http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62 )
13:46:30 <vixey> iirc Seres uses once and ifte (or similar) because they have better algebraic property
13:46:34 <dons> conal: people want tutorials now.
13:46:34 <conal> srush_: in any case, comments please on the legacy-adapter stuff (particularly new) or any aspect of Reactive.
13:46:47 <conal> dons: yeah.
13:46:51 <srush_> yeah, I think we just need more examples
13:47:03 <srush_> I'll try to write up what I can put together
13:47:10 <dons> conal: did you see the intro someone posted yesterday?
13:47:21 <dons> http://netsuperbrain.com/blog/posts/introducing-reactive-events/
13:47:25 <lambdabot> Title: Less Sugar/More Meat Â» Blog Archive Â» Introducing Reactive: Events
13:47:28 <conal> dons: i'm hoping folks will be inspired to write a variety of blog posts with tutorial material.
13:47:44 <dons> yes. are you aggregating material on the wiki?
13:47:47 <conal> dons: yeah.  david sankel.  i helped him with the post
13:47:51 <srush_> that one was really good
13:47:51 <dons> great.
13:48:02 <dons> and links to users (like the reactive irc bot, and other things)
13:48:11 <jsn> the API docs say the "project page" is "project-foo"
13:48:12 <jsn> http://code.haskell.org/reactive-fieldtrip/doc/html/
13:48:13 <lambdabot> Title: reactive-fieldtrip-0.0.1: Connect Reactive and FieldTrip
13:48:15 <conal> dons: yeah -- that kind of input would be great.
13:48:24 <conal> jsn: oops!
13:48:51 <Cale> vixey: You can almost certainly have something which is a monad, and supports a cut operation simultaneously. However, the cut itself will probably not be an action in the monad.
13:48:59 <conal> jsn: i have a "project-foo" template.  forgot to change that field.
13:49:15 <jsn> it looks like selection/picking is something we do ourselves
13:49:24 <vixey> Cale, not sure I see it -- what does the monad do in that case?
13:49:35 <b_jonas> vixey: hmm, I don't really understand that
13:49:43 <vixey> b_jonas, oh :( why
13:50:02 <b_jonas> because I haven't thought on what interface the unifier should have
13:50:10 <vixey> b_jonas, it's a kind of mix of typed logical variables and sheards stuff
13:50:26 <unenough> heh, @pl gave me: foldr ((. (. tail)) . liftM2 (:) . (. head) . (,)) (const [])
13:50:29 <unenough> for my zip
13:50:30 <vixey> b_jonas, the examples don't make sense ?
13:51:00 <b_jonas> I'm reading them
13:52:03 <b_jonas> so Unify is the monad that stores the state of unification, and as it's a type synonym it needs no Monad instance spelt out
13:52:23 <conal> okay.  reactive-fieldtrip-0.0.2 released.  no more project-foo.  thanks, jsn.
13:52:24 <b_jonas> then Unifiable is the class of types of expressions you can unify, that's strange
13:52:33 <b_jonas> I should you'd have only one unifiable type
13:52:46 <jsn> conal: disaster averted :)
13:52:59 <conal> :)  i'm glad for the extra eyes!
13:53:03 <vixey> b_jonas, it's not like Prolog, with this you separate out different types (like haskell vs lisp) at compile time
13:53:22 <vixey> b_jonas, you can use data Prolog a = Functor Name [Prolog a] | Variable ...
13:53:27 <vixey> to get the Prolog universe back though
13:55:18 <b_jonas> I see
13:58:03 <Cale> vixey: Well, something like take 1 for the list monad, for instance.
13:58:06 <vixey> it's kind of irritating though, (at least as far as I could tell) that you can't do unification on HOAS
13:58:47 <mopped> Can somebody explain what @pl does?
13:58:54 <vixey> Cale, yeah I suppose you could send out cut as a success thing into the list of solutions and the (nested) runProlog thing would stop at those points -- I don't think you get the right memory usage as cut with that though... but it's tricky to determine with lazyness in the mik
13:58:58 <unenough> @djinn a->b
13:58:58 <lambdabot> -- f cannot be realized.
13:59:15 <Cale> vixey: I just mean wrapping some initial part of the computation in take 1
13:59:27 <vixey> Cale, once ?
13:59:29 <Peaker> mopped: it composes functions together instead of using the point-form (\x y -> x + y  is point-form for (+))
13:59:34 <Cale> vixey: yeah
13:59:40 <vixey> Cale, that's not cut
13:59:55 <unenough> mopped, i don't know how it works, but converts a 'function in terms of its args' to an equivalent composition of functions
14:00:02 <vixey> I just think that there is a deeper reason that cut isn't in LogicT and so on than because it's ugly
14:00:44 <Cale> vixey: Doesn't once effectively prevent backtracking in the same way as cut?
14:01:03 <ddarius> cut is ugly
14:01:09 <vixey> Cale, I think it is not equivalent in expressiveness
14:01:12 <Cale> vixey: I have a feeling you can transform any computation which uses cut into one which uses once instead.
14:01:19 <vixey> I can't see how to implement not/1 with once/1
14:01:30 <Cale> once/1?
14:01:39 <Cale> I'm referring to the once in LogicT.
14:01:45 <vixey> sorry thinking in prolog terms..
14:02:15 <vixey> I think dolio came up with a non-local transform for it
14:02:21 <Cale> Yes.
14:02:24 <BONUS> hmm
14:02:31 <BONUS> how come you can't view the source in the docs
14:02:35 <BONUS> for the latest ghc
14:03:08 <Cale> BONUS: I was going to ask the same thing the other day...
14:03:25 <Cale> BONUS: It's possible they have the wrong version of haddock
14:03:32 <BONUS> could be
14:03:43 <b_jonas> vixey: I think I see how it works
14:03:45 <b_jonas> it's strange
14:03:51 <BONUS> i hope they put it up soon, having the source nearby is really handy
14:04:16 <vixey> b_jonas, if you use it and see any possiblity for improvement do tell me :)
14:04:30 <b_jonas> vixey: what seems strange is that match is not a complete function
14:04:38 <vixey> what do you mean not complete?
14:04:49 <b_jonas> you define it for non-variables only, right?
14:05:06 <vixey> yes that's correct
14:05:18 <vixey> It's not expressed in the type,... but a variable is never passed into that
14:05:25 <b_jonas> that's what seems strange to me, yes
14:05:34 <b_jonas> I wonder if you could bring this constraint to type-level
14:05:36 <ziman> :t fix
14:05:37 <lambdabot> forall a. (a -> a) -> a
14:05:37 <conal> okay, whew.  Reactive & FieldTrip announced.  that's been a long time coming.
14:05:44 <vixey> b_jonas: I don't think it's possible to say that without dependent types
14:05:54 <conal> thx for the advice about where to announce.
14:06:11 <vixey> actually it might be..
14:06:13 <Beelsebob> conal: congrats :D
14:06:16 <b_jonas> vixey: how about with some mu-like higher-order type
14:06:26 <Cale> vixey: Wouldn't it just be something like  not x = ifte (once x) (const mzero) (return ())
14:06:35 <vixey> b_jonas, going to try it out eventually
14:06:48 <ksf> Mu is not higher-order, it's lower order, for there is a reason that you asked.
14:06:54 <conal> Beelsebob: thx! :)
14:07:13 <b_jonas> I'm not sure how it would work though
14:07:54 <vixey> Cale, I'm not sure, I don't remember what ifte does
14:08:16 <koanbot> SCNR
14:08:19 <vixey> checking,
14:08:42 <Cale> In  ifte x t e  if x succeeds at all the results are passed to the function t, otherwise the result is e
14:09:23 <mdmkolbe> conal: I take it that Field trip represents objects as a tree structure.  Does this mean that when running with Reactive, each time a value on a channel/wire changes, the entire tree is sent or is there some smarter way to do this (e.g. nested channels/wires)?
14:09:29 <vixey> Cale, it says        The third equivalence is more interesting: as soon as the test command succeeds once, the th branch is immediately executed and the el branch can never be tried.
14:09:49 <Cale> vixey: right
14:10:13 <Cale> vixey: The once just makes it more efficient.
14:10:20 <conal> mdmkolbe: Reactive is pretty smart about only recomputing parts that change, while leaving other parts unchanged.
14:10:29 <Cale> vixey: (because you only fail once, not multiple times)
14:11:08 <conal> mdmkolbe: (using applicative functor magic)
14:11:59 <b_jonas> vixey: unrelated to the type issue, I think the Just case of deref should store the dereffed value back to the stref for efficency
14:12:31 <mdmkolbe> conal: I understand not recomputing, but if I insert a network in between two parts, I'd also want to avoid resending large structures if only a small part of the structure changed (like is common with GUIs)
14:13:28 <ksf> write git bindings?
14:13:49 <conal> mdmkolbe: "sent"?
14:14:09 <conal> mdmkolbe: as in sending to the graphics card?
14:15:31 <mdmkolbe> conal: I'm thinking from an arrows perspective.  If I have "a >>> b", and a :: Arr b BigTreeType, then I should be able to do "a >>> network_b" and "network_a >>> b" where the two computations are on different machines communicating over a network
14:15:54 <mdmkolbe> sorry a :: Arr x BigTreeType
14:16:20 <b_jonas> as for the types, do you suppose you could make a (* -> *) -> * -> * -> * type (or something like that) Foo so that Foo [] would be equivalent to your List and have a single Unifiable instance for Foo?
14:16:35 <b_jonas> I feel like something like that should be possible, but maybe it isn't
14:16:36 <vixey> b_jonas, is it correct to do that?
14:16:43 <mdmkolbe> conal: think "X11/TerminalServices for free"
14:16:51 <b_jonas> I don't know
14:17:02 <b_jonas> it's complicated and I don't really understand it
14:17:04 <vixey> b_jonas, I'm sure I implemented exactly what you said in a different language and it was incorrect
14:17:20 <b_jonas> hmm
14:17:27 <conal> mdmkolbe: oh -- in a distributed setting.
14:17:57 <b_jonas> you might not be able to generate match
14:18:12 <b_jonas> I don't know
14:19:17 <mdmkolbe> conal: yeah.  basically, resending the entire BigTreeType whenever the old value is almost but not exactly equal, is a bit wastefull.  (This thought could be extened to computations in "b" based on sub parts of BigTreeType, but a little memoization should take care of that (reactive may already))
14:19:49 <b_jonas> so how about if you had to instance a class with a complete version of match for the * -> * type but then var and varCtl and the partial match would be autogenerated from that?
14:20:15 <b_jonas> no, that would have problems too
14:20:19 <b_jonas> for recursive types
14:20:29 <b_jonas> I dunno then
14:20:57 <vixey> b_jonas, I think I might be able to make it type safe if I did something tricky with a GADT
14:21:07 <vixey> I'll probably try it out at some point
14:22:03 <ksf> 'Michel Mauny was giving a guest lecture to new computer science students. After the students were seated, Michel pronounced "Today's lecture will be about Lazy Evaluation", he paused for a moment then concluded with, "Are there any questions?" '
14:22:07 <ksf> http://web.archive.org/web/20041012103936/http%3a//www.bagley.org/~doug/ocaml/Notes/okoans.shtml
14:22:13 <ksf> reminds me of the little schemer.
14:22:14 <b_jonas> ok
14:22:16 <b_jonas> good night now
14:22:36 <vixey> s/type safe/total/
14:26:11 <conal> mdmkolbe: maybe Reactive would be a suitable basis for that kind of networking optimization.  i did something related with TBAG (http://conal.net/tbag), where the implementation distributed constraint assertions & retractions for replicated solution.  very low bandwidth for multi-user interactive 3D.
14:28:50 <mdmkolbe> conal: I'll have to take a look at that.  Anyway, congrats on getting Reactive released.  I've been looking forward to it since you mentioned it at ICFP.
14:29:19 <askentasken> im trying to implement prolog. i have a data Clause = Rule | Fact
14:29:37 <askentasken> now i want Rule = Head and Body and Fact = Head and True
14:29:46 <askentasken> a record doesnt seem like the right match for this
14:29:57 <dons> shapr: gitit appears to be building fine today.
14:29:59 <conal> mdmkolbe: thx. :)
14:30:16 <conal> go gitit!
14:31:03 <dons> it sure depends on some things, but they all seem working.
14:31:30 <roconnor> conal: has GuiTV been deprecated?
14:31:33 <dons> what's amazing is that gitit is 4 modules.
14:31:40 <dons> happs does *so* much, hackage provides so much now.
14:32:00 <dons> shapr, http://galois.com/~dons/tmp/gitit.txt
14:32:04 <dons> build log for you to check against
14:32:09 <roconnor> dons: I fear hackage will collapse under it's own weight.  But you know me, I'm a pessimist.
14:32:16 <mauke> whee, xmonad running under 6.10.1
14:32:39 <dons> mauke: of course :)
14:32:43 <Lemmih> roconnor: We'll just use some of the code on Hackage to make Hackage stronger.
14:32:44 <conal> roconnor: no.  it's just that i haven't updated phooey, on which GuiTV is built.
14:33:04 <mauke> dons: hey, getting this to work was nontrivial (grr, libedit)
14:33:08 <dons> giti is what. 400 lines of code1?
14:33:15 <roconnor> conal: so GuiTV is still the way to go for making GUIs?
14:33:25 <dons> roconnor: well, already we have a constraint solver to work out what to install...
14:33:32 <dons> don't collapse, just get smarter.
14:33:39 <mauke> and I still need to hack libedit to support sane history commands
14:33:46 <conal> roconnor: if your GUI is simple enough -- essentially a visualization of a pure value (e.g., function), then i'd recommend it.
14:33:52 <roconnor> Lemmih: what is Hackage written with at the moment?
14:33:54 <dons> Lemmih: gitit is tiny! this is very good news for happs.
14:34:19 <dons> oh, found one more module. so its about 1k loc. for a complete wiki. awesomness.
14:34:21 <roconnor> conal: good to know.  I wasn't sure if your new recative stuff was going to replace it, or if it was different.
14:34:23 <conal> roconnor: phooey is more flexible and not as simple.
14:34:42 <ksf> cabal install lambdabot
14:34:42 <ksf> Resolving dependencies...
14:34:42 <ksf> Downloading brainfuck-0.1...
14:34:44 <ksf> wtf?
14:35:17 <Deewiant> @bf ++.
14:35:18 <lambdabot>   fd:5: hClose: resource vanished (Broken pipe)
14:35:19 <Kerris4> ksf: surprised that lambdabot understands brainfuck? :\
14:35:28 <Lemmih> roconnor: A jumple of shell scripts and haskell scripts. Duncan and I wrote a small hackage version some time ago.
14:35:43 <roconnor> dons: currently the catorgorization method seems poor and likely to get worse without something.
14:36:10 <chr1s> I had some problems with building gitit, but those disappeared after updating to the newest cabal and cabal-install.
14:36:24 * gwern notes that hackage categories are more akin to tags than categories
14:36:47 <roconnor> dons: but I'm more concerned about specifying versions of packages in dependencies becoming the nightmare that ever other system seems to be.
14:36:49 <Lemmih> dcoutts: Is the happs hackage still running somewhere?
14:37:00 <roconnor> dons: But I have no solutions to offer.
14:37:30 <roconnor> dons: I do like the idea of using module signatures to specify package interfaces.  I don't really know how feasable that is.
14:38:23 <dons> hence our constraint solver and versioning policy.
14:38:35 <sheyll> hi
14:38:39 <dons> chr1s: good
14:39:53 <roconnor> dons: oh is there a versioning policy?
14:40:10 <roconnor> I made up one in my head
14:40:13 <yitz> hi sheyll
14:40:16 <sheyll> hi
14:40:23 <dons> yeah, its kinda required if we're going to use version ranges as proxies for interface checking.
14:40:35 <roconnor> where is the policy?
14:40:42 <sheyll> could someone give me a hint how to get this compiled: http://hpaste.org/11895 ?
14:41:04 <dons> Lemmih: http://archhaskell.wordpress.com/2008/11/09/gitit-now-supported-in-arch-linux/
14:41:06 <lambdabot> Title: gitit now supported in Arch Linux Â« Arch Linux and Haskell, http://tinyurl.com/63ldrd
14:41:08 <roconnor> do you think we can actually do interface checking?
14:41:18 <dons> Lemmih: should be easy to bundle other happs-based things needing 0.9.{2,3}
14:41:31 <mauke> sheyll: well, you'll need a main function
14:41:56 <sheyll> hmm
14:42:04 <srush_> conal: I'm still n00bing it up on this mkUpdater stuff
14:42:32 <srush_> how do you do Event IO a -> IO a
14:42:32 <mauke> sheyll: also, the types don't seem to match
14:42:36 <askentasken> it seems the prolog-runtime carries the facts right?
14:43:09 <sheyll> ghc does not complain about a missing main function but rather that shiftL has type a -> Int -> a
14:43:31 <ksf> Configuring haskell-src-exts-0.3.9...
14:43:32 <ksf> cabal: happy version >=1.17 is required but it could not be found.
14:43:34 <conal> srush_: oh -- that's why you asked about runE?
14:43:37 <ksf> shouldn't cabal resolve that one?
14:43:37 <sheyll> int Int8 is not an Int. How do I fix this and why is this so complicated?
14:43:48 <srush_> yeah
14:43:55 <EvilTerran> ?type fromEnum
14:43:56 <lambdabot> forall a. (Enum a) => a -> Int
14:44:00 <yitz> sheyll: you start out with an Int8 and never convert to anything else
14:44:15 <srush_> I think I get the GLUT code, but it seems like too much boiler plate for events
14:44:24 <yitz> sheyll: put in a fromIntegral somewhere
14:44:30 <vixey> srush_: Implement it once then
14:44:31 <askentasken> hmm i thought haskell would be great for DSLs or so it claims but it seems a bit hard to write PROLOG in it compared to doing it in lisp or python
14:44:32 <dons> ksf, it won't resolve executables required for building.
14:44:34 <yitz> @type fromIntegral
14:44:35 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:44:35 <sheyll> well if I do a Int8 `shiftL` Int8  it will not compile!
14:44:40 <dons> ksf, so just cabal install happy
14:44:43 <roconnor> > fromIntegral (8::Int8)
14:44:45 <lambdabot>   8
14:44:45 <mauke> sheyll: insert fromIntegral between `shiftL` e and between = x
14:44:49 <EvilTerran> sheyll, because it needs an Int, not an Int8
14:44:51 <yitz> sheyll: also true
14:45:00 <conal> srush_: runE is now in FRP.Reactive.Internal.Reactive.
14:45:04 <sheyll> that make the code look ugly
14:45:10 <EvilTerran> > fromEnum (8::Int8) :: Int
14:45:12 <lambdabot>   8
14:45:19 <sheyll> this is not elegant
14:45:29 <EvilTerran> sheyll, oh well, such is the occasional price we pay for the semantics not being viciously ugly
14:45:30 <sheyll> why is Int8 not an instance of Int?
14:45:36 <vixey> sheyll, yeah lack of subtyping really sucks
14:45:37 <thoughtpolice> because Int is a concrete type
14:45:37 <roconnor> x `myShiftL` s = x `shiftL` (fromIntegral s)
14:45:38 <EvilTerran> sheyll, because Int is a type, not a typeclass
14:45:47 <yitz> sheyll: yes it is. it is not elegant for types to get confused. it leads to bugs.
14:45:58 <EvilTerran> roconnor, genericShiftL?
14:45:59 <mauke> sheyll: then remove the type signature
14:46:00 <sheyll> then why is shiftL not defined over Integral
14:46:06 <roconnor> EvilTerran: right
14:46:07 <vixey> yitz, but subtyping would lead to bugs or not?
14:46:19 <mauke> it'll get the type Int -> Int, but it'll be elegant
14:46:39 <EvilTerran> vixey, subtyping leads to undecidable typechecking, iirc
14:46:43 <srush_> conal: yeah, I saw that, but I figured I was doing it wrong
14:46:50 <vixey> EvilTerran, I don't think so ...
14:47:02 <EvilTerran> type inference, even
14:47:04 <yitz> vixey: in general, yes. here I'm not sure. if you can think of a nice rule, you can implement it that way and not need the type sigs anymore.
14:47:05 <sheyll> yitz: you are right, in this way it is elegant, because it is explicit...
14:47:21 <mdmkolbe> EvilTerran: yes, System F extended with subtyping is undescidable, but then again so is System F
14:47:30 <conal> srush_: the legacy-adapter stuff is new.  it'll take some shaking out for different styles of use of reactive.  what are you doing?
14:48:09 <srush_> for starters I wanted to have http://netsuperbrain.com/blog/posts/introducing-reactive-events/ print out Beeps
14:48:12 <lambdabot> Title: Less Sugar/More Meat Â» Blog Archive Â» Introducing Reactive: Events
14:48:28 <conal> srush_: oh, sure.  then you're on the right track with runE.
14:48:32 <sheyll> ok thanx for that little enlightment over that topic, it always helps asking you here :)
14:49:06 <EvilTerran> ... hang on a minute
14:49:15 <shapr> dons: Yeah, it was user error, I had an older version of HAppS-Server installed
14:49:29 <askentasken> hmm i thought haskell would be great for DSLs or so it claims but it seems a bit hard to write PROLOG in it compared to doing it in lisp or python
14:49:37 <sheyll> one other question: does remove the type sigs from the code I pasted have an impact on performance? (not that is would matter...)
14:49:41 <EvilTerran> the problem isn't the second parameter to shiftL, it's the return type being different from the type of the first parameter
14:50:00 <conal> srush_: reactive is currently missing a simple adapter for 'Event Action'.  should be easy for me to cook up.
14:50:02 <shapr> askentasken: What do you find to be difficult?
14:50:14 <srush_> ok cool.
14:50:16 <askentasken> I read Norvigs Lisp.version, could follow it fairly easily. im now wirting it in both Haskell and Python and it is easy in Python but Haskell is ebing a *****
14:50:25 <srush_> maybe I'll give it a try
14:50:27 <askentasken> shapr: No state
14:50:28 <thoughtpolice> then ask for help?
14:50:38 <EvilTerran> askentasken, haskell has state, it's just explicit state
14:50:41 <shapr> Right
14:50:43 <thoughtpolice> askentasken: see - state monad
14:50:53 <srush_> it should be like mkUpdater right, but for events
14:50:58 <shapr> askentasken: You could have state by explicitly passing it in to each function call, right?
14:51:00 <srush_> instead of behaviors?
14:51:26 <thoughtpolice> sheyll: type inference will take care of determining the proper types for everything
14:51:50 <dons> askentasken: heh. oh? people write prolog in haskell all the time for fun...
14:51:53 <thoughtpolice> sheyll: in some instances you must provide a type signature (to remove ambiguity) for some expressions, but for the most part you can leave them out if you wish
14:52:02 <dons> its one of the oldest benchmarks for ghc
14:52:24 <vininim_> oh my
14:52:24 <EvilTerran> thoughtpolice, it does help to give explicit type sigs for top-level declerations, though, to keep type errors local
14:52:42 <thoughtpolice> EvilTerran: yeah I pretty much always have sigs for exported functions and whatnot
14:52:44 <vininim_> anyone knows what is the beamer template jason dagit uses in his Type Correct Changes slides?
14:52:45 <sheyll> how do I write binary integer literals?
14:53:03 <shapr> lispy: Hey, what beamer template do you use?
14:53:03 <vixey> [$binary|0101011101|]
14:53:04 <EvilTerran> and i find writing the type of a function first often helps me reason about its implementation
14:53:16 <sheyll> vixey: thank you :)
14:53:27 <shapr> Caelum: Walmart people use Haskell?
14:53:41 <vixey> sheyll, You must have ghc 6.9 or earlier though
14:53:44 <EvilTerran> sheyll, unfortunately, vixey is referring to a particular use of the 'quasiquoting' extension
14:53:49 <lispy> shapr: remind me, what is beamer?
14:53:49 * shapr hugs vixey 
14:53:59 <shapr> I assume it means overhead projector.
14:54:01 * vixey hugs shapr . .
14:54:08 * shapr boings frumiously
14:54:16 <SamB> lispy: a latex package!
14:54:27 <vixey> shapr..... no time to many ideas I am going (more) mad
14:54:27 <lispy> vininim_: I used Keynote
14:54:33 <EvilTerran> SamB, o.Ã³
14:54:36 <sheyll> Ah... I see. I have not upgrade to ghc 6.9 yet
14:54:37 <mdmkolbe> lispy: beamer is the latex package for making beamer slides (called in the USA projector slides)
14:54:50 <SamB> EvilTerran: what's with the accent
14:54:58 <EvilTerran> raised eyebrow
14:55:01 <Lemmih> shapr: Of course. Where did you think Haskell's cheap threads came from?
14:55:02 <shapr> ay donno have an accent!
14:55:03 <EvilTerran> but then i read up further and it made sense
14:55:10 <shapr> Lemmih: haha
14:55:12 <sheyll> so that was template haskell's quasiquote syntax?
14:55:12 <SamB> mdmkolbe: funny, I thought it was used for making PDFs to display using an LCD projector
14:55:20 <vixey> sheyll, not TH
14:55:33 <vininim_> it's awesome, I should learn proper tex just to port it to beamer.
14:55:54 <mdmkolbe> SamB: that's the same thing isn't it?
14:55:54 <EvilTerran> vixey, er, isn't it TH?
14:55:55 <conal> srush_: simpler than mkUpdater.  really just a call to runE.  i'm also working on it.
14:56:12 <vixey> oh you're right, it is
14:56:19 <SamB> mdmkolbe: oh, I thought you were talking hardcopy for a bit there
14:56:24 <lispy> vininim_: if you have a mac you can get a 'demo' of keynote for $0, and then pick it apart
14:57:06 <vininim_> lispy: nice, will try it in my brother's one.
14:57:31 <lispy> vininim_: it's a standard theme, I'll go look up the name
14:58:06 <lispy> vininim_: they call it blackboard, of all crazy things :)
14:58:12 <vininim_> heh
14:58:49 <yitz> > 0b0101101
14:58:50 <lambdabot>   Not in scope: `b0101101'
14:59:35 <yitz> > 0x0123abc
14:59:36 <lambdabot>   1194684
15:00:08 <yitz> > 011
15:00:09 <lambdabot>   11
15:00:54 <yitz> > 0o11
15:00:55 <lambdabot>   9
15:01:35 <roconnor> @hoogle digit
15:01:35 <lambdabot> Text.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
15:01:35 <lambdabot> Text.ParserCombinators.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
15:01:35 <lambdabot> Data.Char digitToInt :: Char -> Int
15:02:17 <roconnor> > readInt 2 (`elem`"01") digitToInt "0101101"
15:02:19 <lambdabot>   [(45,"")]
15:03:24 <ziman> :t readInt
15:03:25 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
15:03:53 <ziman> hm, nifty.
15:04:50 <Philonous> :t elem
15:04:51 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
15:04:56 <Lemmih> Can anyone install reactive-fieldtrip on Ubuntu?
15:07:31 <vixey> hey I have a tricky situation in this typechecker thing I wanted ot write
15:07:57 <vixey> has anyone had something like, you want to inspect one language -- but parts of its computation are defined in a different (untyped) language
15:08:20 <vixey> how od you make sure that when you reduce bits of it in terms of the other language that parts of that never seep through?
15:08:57 <jsn> i think wadler did something with this
15:09:06 <jsn> i can not remember the name of the paper
15:09:07 <yitz> so, here is the thread about binary constants on the cafe: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/30694/focus=30721
15:09:19 <lambdabot> Title: Gmane Loom, http://tinyurl.com/63v8nc
15:09:58 <jsn> vixey: well-typed programs can't be blamed
15:11:16 <conal> srush_: i just pushed reactive-0.9.0 with a new function 'adaptE'.  would you give it a try and let me know?  see http://code.haskell.org/reactive/doc/html/FRP-Reactive-LegacyAdapters.html
15:11:17 <lambdabot> Title: FRP.Reactive.LegacyAdapters, http://tinyurl.com/6k4jek
15:11:26 <srush_> hot, thanks conal
15:11:31 <srush_> fast service
15:11:36 <rherrmann> kudos for dons, for the quick fix to stream-fusion for 6.10 ;-)
15:12:06 <jsn> vixey: http://homepages.inf.ed.ac.uk/wadler/papers/blame/blame.pdf
15:12:07 <conal> :)
15:12:20 <lambdabot> Title: Well-typed programs canât be blamed
15:12:22 <conal> srush_: it's something i meant to add before but forgot.  thx for the reminder.
15:12:29 <jsn> vixey: is that actually relevant?
15:12:40 <vixey> jsn, I'll have to read it first
15:13:05 <jsn> sorry, i meant, i let me know if that is actually relevant
15:13:13 <jsn> s/i let/let/
15:13:14 <vixey> what
15:13:29 <jsn> >_> <_<
15:13:41 <jsn> \o/
15:14:04 <ksf> main = runCommand "perl"
15:14:05 <rherrmann> btw, I remeber reading somewhere that stream-fusion would become the standard for GHC
15:14:12 <ksf> Well-typed programs can be blamed.
15:14:15 <rherrmann> does anyone have any info on that ?
15:14:17 <ksf> Q.E.D.
15:15:05 <dons> rherrmann: we're just providing it as a library now, for lists and arrays.
15:15:10 <dons> its available from hackage.haskell.org
15:15:16 <yitz> ksf: it's in the IO monad, so you have been warned.
15:15:30 <yitz> ksf: main = launchMissiles
15:16:16 <rherrmann> dons: yes, I was just curious about when importing the libs would become unnecessary
15:16:30 <rherrmann> dons: please do not forget blogging about it ;-)
15:17:20 <dcoutts> Lemmih: I should get it running again
15:17:42 <Lemmih> dcoutts: Let me know if I can help out.
15:18:04 <dcoutts> Lemmih: getting it running is not a problem, but there's plenty to do on the server itself
15:18:24 <Lemmih> I've got time to hack.
15:18:38 <dcoutts> Lemmih: in particular serving the haddock docs. I want a server part for serving the content of a tarball
15:19:27 <dcoutts> Lemmih: so we can go to http://hackage.haskell.org/foo-1.0.tar.gz/foo-1.0/README
15:19:48 <mm_freak> if i say 'type A = B', is there any difference between A and B besides the name?
15:19:57 <dcoutts> Lemmih: and so we can use the same mechanism for serving the docs, ie upload a tarball of docs and serve the content directly
15:20:03 <vixey> mm_freak; no
15:20:09 <mm_freak> great, thanks
15:20:18 <ddarius> mm_freak: Technically you can't write instance Foo A in Haskell 98, but otherwise no.
15:20:24 <vixey> mm_freak; oh maybe there is aslight difference
15:20:33 <vixey> you can not I think, curry A but you could B
15:20:37 <vixey> inthe case they took parameters
15:20:42 <vixey> sorry..... partially apply!
15:20:44 <dcoutts> Lemmih: so we'd gunzip the tarball and read the content to build a name -> offset index and use that to serve the content later.
15:20:46 <vixey> I didn't mean to say curry :)
15:20:59 <ddarius> vixey: For type A = B that's moot.
15:21:06 <dcoutts> Lemmih: sound like a reasonable strategy?
15:21:09 <ddarius> If you wrote type A a = B a then that would apply
15:21:12 <vixey> yes
15:21:21 <ddarius> but that's equivalent to type A = B so always eta reduce.
15:21:25 <mm_freak> it's just that i want to import Data.Map qualified, and say 'type Map = Map.Map' for convenience
15:21:35 <mm_freak> so currying must work
15:21:59 <conal> does anyone here use wxhaskell on linux?  'cabal install wx' gives me "Unable to find wxWidgets configuration (wx-config)."  and sure enough, though libwxgtk2.8-0 and libwxbase2.8-0 came with Ubuntu, i don't seem to have wx-config.
15:22:07 <Saizan> mm_freak: you usually just add a line "import Data.Map (Map)"
15:22:21 <dcoutts> conal: install the 'dev' variants of those packages
15:22:29 <vixey> mm_freak, why not import it non-qualified
15:22:33 <mm_freak> indeed
15:22:39 <mm_freak> vixey: because there are name-clashes with Prelude
15:22:43 <srush__> conal: cool, works
15:22:53 <vixey> no
15:23:04 <ddarius> mm_freak: As Saizan pointed out, you can import just the type unqualified.
15:23:14 <Lemmih> dcoutts: Sounds excellent. Shouldn't be a problem to write.
15:23:30 <conal> dcoutts: oh, thanks1
15:23:45 <rherrmann> http://packages.ubuntu.com/search?searchon=contents&keywords=wx-config&mode=exactfilename&suite=intrepid&arch=any
15:23:46 <Lemmih> dcoutts: Where's the repo?
15:23:51 <lambdabot> Title: Ubuntu -- Package Contents Search Results -- wx-config, http://tinyurl.com/6rrsqy
15:24:00 <dcoutts> Lemmih: code.h.o/hackage-server/
15:24:05 <Davbo> Could anyone point me in the right direction for writing Huffman codes in Haskell? I've started but think I'm going about it totally wrong http://hpaste.org/11898
15:24:10 <rherrmann> conal: It seems wx-config is not present in Intrepid ?!?
15:24:15 <conal> rherrmann: wow -- that's a handy trick.  thanks much.
15:24:18 <dcoutts> Lemmih: and checking it still builds with the new happs release would be useful too
15:24:30 <vixey> Davbo, data HTree = Leaf Char | Branch HTree HTree
15:24:33 <conal> rherrmann: not that my bash can find ("which wx-config")
15:24:46 <vixey> Davbo, would be more useful as  data HTree a = Leaf a | Branch (HTree a) (HTree a)
15:24:50 <dons> conal: http://haskell.org/haskellwiki/FieldTrip should have graphics on it. is there somewhere i can find examples to link to?
15:24:52 <lambdabot> Title: FieldTrip - HaskellWiki
15:25:01 <mm_freak> ddarius: ah, indeedâ¦  there's even an example in the library doc
15:25:11 <dons> on the conal.net gallery?
15:25:16 <vixey> Davbo, the really sneaky trick is writing a function  HTree Char -> HTree (HCode,Char)
15:25:27 <vixey> Davbo, (or it could have type  HTree a -> HTree (HCode,a) )
15:25:31 <dons> no, those look like pan.
15:25:57 <Davbo> ah, thanks vixey
15:26:06 <vixey> Davbo, (the definition of cCode just drops out from it quite simply after)
15:26:10 <conal> dons: good ideas about the graphic.  i don't have many FieldTrip examples yet.
15:26:26 <vixey> Davbo, There's one more tool that comes in extremely handy for programs over HTree a
15:26:39 <dons> i think before i can show it to the wider world, there needs to be say, one image, and its corresponding code.
15:26:43 <vixey> Davbo, You have met the functions like  maybe  either  and  foldr  ?
15:26:44 <vixey> :t maybe
15:26:45 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:26:46 <dons> to really convey how short/declarative and effective it is.
15:27:06 <dons> conal: there are youtube videos, no?
15:27:10 <dons> http://uk.youtube.com/watch?v=YevWgMvGsDA ?
15:27:11 <lambdabot> Title: YouTube - Spining sphere with image map
15:27:27 <Davbo> yeah i've used maybe in the past vixey
15:27:52 <Davbo> not either or foldr though
15:28:02 <vixey> Davbo, cool, so you know how   maybe no j Nothing = no,  maybe no j (Just x) = j x,  it just replaces the constructors with functions of your choice
15:28:15 <conal> dons: agreed.  i'd forgotten about those videos that andy made.
15:28:18 <vixey> Davbo, The analogue of that for HTree a is very useful,
15:28:34 <Davbo> hmm
15:28:48 <vixey> foldHTree leaf branch (Leaf a) = leaf a ; foldHTree leaf branch (Branch l r) = branch (foldHTree leaf branch l) (foldHTree leaf branch r)
15:29:13 <conal> dons: probably too early in the project to advertise to the wider world.
15:29:14 <vixey> Davbo, stuff like  contains e = foldHTree (== e) (||), dfs = foldHTree return (++), etc..
15:29:41 <vixey> Davbo, pretty much everything is expressible with it :))
15:29:56 <Davbo> ah cool, i *think* i see what you mean
15:30:19 <vixey> Davbo, so I wont spoil it for you but, writing  the function with type HTree a -> HTree (HCode, a) in terms of foldHTree is lots of fun
15:31:03 <Davbo> hmm, right :-)
15:35:47 <Lemmih> dcoutts: If you're got the time, I could use a todo list.
15:37:45 <Davbo> thank you vixey, do you know if there is a similar bit of code to this I could take a look at?
15:38:55 <Davbo> sources for information / tutorials on haskell seem to vary quite significantly in quality :(
15:39:42 <dons> unlike, say, ... ?
15:39:51 <snk_kid> hi
15:40:08 <dons> Davbo: try realworldhaskell.org and learnyouahaskell.com
15:40:16 <luite> dons: php tutorials are almost uniformly bad ;)
15:40:23 <dons> Davbo: quality things are linked from haskell.org, which you should become familiar with
15:40:26 <snk_kid> are the packages on hackage sorted yet?
15:40:35 <vixey> Davbo, You don't wanna see a similar bit of code :p
15:40:47 <vixey> Davbo, It would take the fun of your programming problem away
15:40:55 <Davbo> true dons, i'm just not yet familiar with where to look for haskell
15:41:04 <Davbo> alright vixey :)
15:41:11 <vixey> Davbo, you know a little bit about the type system?
15:41:23 <vixey> Davbo, there's a nice property about the folds that can guide you in programing
15:41:31 <dons> snk_kid: sorted? yes...
15:41:44 <dons> snk_kid: they're sorted by tag.
15:41:55 <dons> ?users
15:41:55 <lambdabot> Maximum users seen in #haskell: 559, currently: 527 (94.3%), active: 23 (4.4%)
15:41:57 <snk_kid> dons: i dont mean that kind of sorted
15:41:59 <snk_kid> lol
15:42:14 <dons> you'll need to provide more information, lolz.
15:42:21 <vixey> lol
15:42:31 <dons> :)
15:42:32 <snk_kid> dons: i mean some of the package packages fail to build on ghc 6.10.1
15:42:44 <Davbo> vixey, i'd go as far as saying "a little", yeah
15:42:48 <dons> ah. yes, about 3% as of two weeks ago. i imagine that is less now.
15:42:57 <dons> snk_kid: what's your question?
15:43:00 <mm_freak> how is MonadIO useful?  i mean, what's the reason for having MonadIO besides MonadTrans?
15:43:29 <Pseudonym> IO is always on the bottom of a stack of transformers.
15:43:33 <Peaker> mm_freak: easier to liftIO than repeating (lift.)
15:43:34 <vixey> Davbo, so for example if your target was to write  HTree a -> [a]   (get all the leaves of a tree)
15:43:35 <Pseudonym> So there's exaclty one way to get to IO.
15:43:47 <Pseudonym> And yes, it avoids the long way. :-)
15:44:00 <mm_freak> ah, so liftIO always lifts to the bottom
15:44:08 <vixey> Davbo, you'd have leaves = foldHTree ?leaf ?branch :: HTree a -> [a]
15:44:09 <snk_kid> dons: well like i said some packages fail to build on the latest version of ghc so i asking if the issue is resolved yet
15:44:24 <vixey> Davbo, now we don't know what leaf or branch are yet..... but the types can be inferred,
15:44:26 <snk_kid> dons: packages on hackage
15:44:37 <vixey> Davbo, so leaf :: a -> [a], branch :: [a] -> [a] -> [a]
15:44:49 <mm_freak> but then it's only useful, if you have a transformer chain longer than two monads, right?
15:44:57 <vixey> Davbo, so you can fill the gaps of that fold now? (and test it out :))
15:45:03 <dons> snk_kid: well, the vast majority build. around 820 packages.
15:45:05 <snk_kid> dons: if not is there an quick workaround
15:45:06 <Pseudonym> mm_freak, it's also usefuyl if you're writing generic code.
15:45:06 <dons> snk_kid: so proceed.
15:45:19 <snk_kid> dons: not the one i'm trying to build
15:45:20 <vixey> Davbo, (if you get that to work the next bit should I'll say will make sense)
15:45:22 <dons> snk_kid: i don't think there's a problem. was there something you wanted that didn't build?
15:45:31 <Davbo> heh, think so. Thanks vixey
15:45:42 <dons> snk_kid: ah. so there's a concrete package that isn't working. which is it?
15:45:48 <dons> snk_kid: and how are you building it (cabal-install ?)
15:45:56 <mm_freak> Pseudonym: i'd count that to the above
15:46:00 <ksf> Knowing that you're going into the wrong direction is going into the right direction.
15:46:04 <dons> cabal-install is the most robust way to build things, since it uses a constraint solver to pick correct package versions
15:46:08 <snk_kid> dons: array-0.1.0.0, it's documentated as fails on 6-10
15:46:14 <dons> hmm? array comes with ghc.
15:46:24 <dons> $ ghc-pkg list array
15:46:24 <dons> /usr/lib/ghc-6.10.0.20081007/./package.conf: array-0.2.0.0
15:46:27 <dons> you won't need to build it.
15:46:34 <snk_kid> dons: ok cool
15:46:48 <dons> use ghc-pkg list to determine what libraries you've already got installed.
15:46:59 <dons> to install new things, i recommend using 'cabal-install', since it will pick the right versions.
15:47:39 <snk_kid> it really sucks on windows without package installers to deal with dependacies for you
15:47:56 <dons> yes. cabal-install should help a lot.
15:48:06 <dons> it gives you a package manager for windows, just for haskell stuff.
15:48:22 <snk_kid> nice
15:48:44 <dons> snk_kid: for example, if you'd have been using it to build array, the following:
15:48:47 * ksf is even using it on gentoo without being able to tell why.
15:48:48 <dons> $ cabal install array
15:48:49 <dons> would have saved you some time.
15:48:52 <dons> Resolving dependencies...
15:48:54 <dons> No packages to be installed. All the requested packages are already installed
15:49:13 <mm_freak> if i have a read-only environment, is there any advantage of using Reader?  i'd just use State
15:49:49 <snk_kid> dons: are there dependencies for cabal-install?
15:49:54 <mm_freak> Reader appears to be the same, just without the ability to change the state
15:49:56 <guinea> OT, but is cabal also a make replacement? I mean for in the development cycle
15:50:07 <roconnor> mm_freak: reader stops you from modifying the state
15:50:09 <jeffz> snk_kid: you'll need to build zlib and HTTP by hand first
15:50:13 <dons> snk_kid: there are, yes. HTTP and zlib.
15:50:21 <dons> after which everything else can be resolved automatically.
15:50:27 <dons> guinea: yeah.
15:50:27 <roconnor> mm_freak: this is important if you code's correctness is predicated on this assumption
15:50:27 <shapr> yay
15:50:33 <dons> guinea: for haskell (+ C code)
15:50:35 <Pseudonym> mm_freak: It's theoretically a bit more efficient.  It doesn't introduce false data dependencies.
15:50:35 <shapr> I should finish bootstrapping my ps3 at some point.
15:50:42 <dcoutts> guinea: yes, though it's not completely brilliant for that yet (eg no parallel make).
15:50:42 <jeffz> everything except for packages that expect sh.
15:50:45 <vixey> bootstrapping ??
15:51:14 <juhp> does darcs-2.1.0 build with ghc-6.10.1?
15:51:15 <guinea> dons: cool, i'm having to deal with a bunch of haskell, C and R code
15:51:18 <dons> dcoutts: any idea what percent of people are building with a) runhaskell Setup.hs, b) cabal c) make ?
15:51:24 <mm_freak> roconnor: that's almost voidâ¦  "changing state"?  it may change it for itself, and Reader doesn't stop it from doing so
15:51:28 <dons> juhp: no, i think you need the RC appearing tomorrow
15:51:29 <juhp> I get "Failing due to -Werror."
15:51:35 <juhp> dons: ah ok
15:51:38 <juhp> thanks
15:51:40 <dons> guinea: any haskell code should be packaged with cabal.
15:51:49 <dons> juhp: ask in #darcs.
15:51:53 <mm_freak> Pseudonym: yeah, that's true
15:51:55 <juhp> ah yes
15:51:56 <roconnor> mm_freak: reader doesn't let you change the enviroment
15:51:59 <dons> we're getting close to the 1000 package mark on hackage...
15:52:05 <dcoutts> woo!
15:52:09 <juhp> wow
15:52:13 <dons> about a month away, by my reckoning.
15:52:15 <guinea> dons: i'm not at the packaging stage yet, still at the alpha versions
15:52:18 <dons> i expect we'll hit it before xmas.
15:52:25 <juhp> dons: 1000 tarballs?
15:52:31 <askentasken> Im having design-issues. When implementing Prolog in Haskell what would you make the base-parts? Should I make a data Runtime that collectls all facs and rules?
15:52:33 <roconnor> mm_freak: I can with confidence perform a <- foo; b <- bar, knowing that the enviroment is the same for foo and bar.
15:52:36 <dons> no, 1000 unique libaries.
15:52:41 <juhp> wowow
15:52:49 <sheyll> how do I convert (reinterpret_cast) int Int8 to a Word8?
15:52:50 <dons> there's currently 2424 .tar.gz (versions of things)
15:52:55 <dons> sheyll: fromIntegral
15:52:57 <juhp> awesome
15:53:03 <dons> the 1000 package mark will be a celebration day.
15:53:07 <roconnor> mm_freak: I can swap commands because I know that the reader monad is commutative.
15:53:09 <dons> since we're in the big league at that piont.
15:53:13 <vixey> @quote fromIntegral
15:53:13 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
15:53:25 <dons> lambdabot speaks the truth.
15:53:25 <roconnor> mm_freak: things like that
15:53:29 <dibblego> what does Reader give you that (->) doesn't?
15:53:32 <mm_freak> roconnor: someReaderFunction s = return (runState someStateFunction s)
15:53:44 <ksf> askentasken, make monadic combinators to combine your facts and rules?
15:53:56 <sheyll> dons thanks so much :)
15:54:18 <vixey> I thought Reader = IS (->)
15:54:19 <snk_kid> does Simon know about intel Ct? because i'm interested to hear about his opinion about it and the differences with haskell's implementation of nested parralel arrays
15:54:19 <roconnor> mm_freak: your someReaderFunction  still doesn't change the reader environment
15:54:21 <Peaker> is it not possible express the type of (iterate (lift.) id) in the type system?
15:54:32 <vixey> :t lift
15:54:32 <roconnor> @src Reader
15:54:33 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
15:54:33 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:54:48 <mm_freak> roconnor: but it changes its stateâ¦  State doesn't allow you to modify the environment eitherâ¦  it's just a matter of interpretation
15:55:03 <mm_freak> it appears that Reader is just a restricted version of State
15:55:06 <vixey> @unmtl Reader a
15:55:06 <lambdabot> err: `Reader a' is not applied to enough arguments, giving `/\A. a -> A'
15:55:08 <vixey> @unmtl Reader a b
15:55:08 <lambdabot> a -> b
15:55:15 <askentasken> ksf: ok that is good because then i have to take monads by the horns and not avoid them anymore :9
15:55:25 <roconnor> mm_freak: maybe I'm not understanding you.  State does allow you to modify the state.  put!
15:55:45 <roconnor> mm_freak: yes, reader is a restricted version of State.  that's what types are for, restricting people
15:56:25 <roconnor> mm_freak: because the more restricted you are, the less errors you will make from breaking hidden assumptions.
15:56:28 <mm_freak> roconnor: yeah, and Reader allows you to thread it, which is about the same thingâ¦  i mean, by looking at a function from the outside, you can't reason about Reader any more than about State, right?
15:56:32 <snk_kid> whats the state of NDP at the moment?
15:56:54 <ksf> askentasken, it also saves you from writing a parser before you can comfortably work with the interpreter.
15:56:57 <roconnor> mm_freak: I can reason more about reader
15:57:29 <mm_freak> what?
15:57:38 <roconnor> mm_freak: do {a <-- foo; b <- bar; ...} === do {b <-- bar; a <- foo; ...} holds for the reader monad
15:57:44 <roconnor> but not for the state monad
15:57:53 <mm_freak> ok
15:57:59 <roconnor> That's one example of the reasoning I can do in the Reader Monad.
15:58:18 <roconnor> One might even imagine a compiler taking advantage of that sort of rule.
15:58:28 <ksf> there it is, unordered binds all over the place.
15:58:35 <Peaker> since (lift .) lifts into a potentially unique monad transformer type, it seems impossible to use    iterate (lift.) id   which means I cannot generalize  lift.lift.lift.lift to someFunc lift 4.  The same can be said of fmap...
15:58:43 <roconnor> mm_freak: do {a <-- foo; a <- for; ...} === do {a <- foo; ...} holds for the reader monad
15:58:56 <roconnor> that is even a law a compiler might really use.
15:59:00 <Peaker> I can't have    someFunc fmap 4    I have to use: fmap.fmap.fmap.fmap
15:59:04 <shapr> roconnor: SPJ was talking about that in his hair shirt retrospective...
15:59:06 <roconnor> and may come up in practice (through combining various functions)
15:59:14 <shapr> roconnor: He wants less tightly sequenced monads.
15:59:24 <vixey> Peaker, I call it (^) not someFunc
15:59:37 <vixey> Peaker, I also don't implement it in haskell .. :)
15:59:53 <vixey> would like to knowhow
15:59:55 <mm_freak> roconnor: indeed, thanks
15:59:59 <roconnor> :)
16:00:32 <Peaker> vixey: it seems like its type is not even implementable in Haskell :-(
16:00:50 <Peaker> I wonder if it warrents even more type system extensions to Haskell?
16:00:58 <roconnor> mm_freak: But I think the most important point is to tell users that the environment won't change.  So that users can refactor their code in ways such as above.
16:01:01 <Peaker> oops, probably warrants
16:03:04 <roconnor> Peaker: I bet you can use MVTC to get someFunc fmap Four to work
16:03:21 <Peaker> @where MVTC
16:03:22 <lambdabot> I know nothing about mvtc.
16:03:26 <roconnor> er
16:03:26 <Peaker> what's that?
16:03:28 <roconnor> MPTC
16:03:33 <Peaker> @where MPTC
16:03:34 <lambdabot> I know nothing about mptc.
16:03:38 <roconnor> maybe GADTs would also work
16:03:54 <Peaker> roconnor: I thought GADTs only let you add constraints on the data constructors
16:03:56 <roconnor> multi-paramter type classes
16:04:15 <roconnor> ya, you probably need some class tricks too.
16:04:17 <Peaker> roconnor: well, using "Four" kinda sucks too, IMO :-)
16:04:26 <roconnor> Agreed
16:05:05 <roconnor> Peaker:  do you want somFunc fmap n  to work for a variable n?
16:05:24 <Peaker> roconnor: yeah
16:05:50 <roconnor> okay, then I think you more or less need to use dependent types.
16:06:05 <Peaker> @type (fmap.fmap.fmap.fmap)
16:06:06 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
16:07:41 <Peaker> I guess you can't express this type for any N in a general way that doesn't lose significant type safety
16:07:52 <Peaker> or becomes dependent on values..
16:08:01 <mm_freak> roconnor: my point is that i have a function in Reader that isn't bound anywhere
16:08:15 <mm_freak> so it wouldn't make a difference to use State
16:08:33 <mm_freak> i wondered, then why should i prefer Reader over State
16:08:49 <roconnor> mm_freak: I don't understand what you mean.
16:09:21 <juhp> http://hackage.haskell.org/packages/archive/regex-tdfa/0.95.1/logs/failure/ghc-6.10
16:09:23 <lambdabot> http://tinyurl.com/5cz646
16:09:59 <mm_freak> roconnor: i have a function in the Reader monad, which is never boundâ¦  its result is never the first argument to (>>=)
16:10:16 <juhp> lambdabot: thanks but really no need for that
16:10:29 <Peaker> mm_freak: what's done with it then?
16:10:35 <mm_freak> Peaker: runReader
16:10:38 <roconnor> mm_freak: in that case you can optimise it away by discarding it
16:10:47 <hackage> Uploaded to hackage: randomgen 0.1
16:10:47 <hackage> Uploaded to hackage: reactive 0.9.0
16:10:47 <hackage> Uploaded to hackage: HSHHelpers 0.13
16:10:48 <hackage> Uploaded to hackage: reactive-fieldtrip 0.0.2
16:10:50 <hackage> Uploaded to hackage: gitit 0.2.1
16:11:22 <roconnor> x :: Reader e () === return ()
16:11:31 <roconnor> another theorem
16:11:42 <Peaker> mm_freak: I think its probably best to prefer Reader over State by default, and there's no reason to use State in that case?
16:11:45 <conal> hackage: hi & welcome!
16:11:49 <Davbo> I get the idea of this folding for lists vixey, but i'm getting confused how to implement it on the tree
16:11:52 <mm_freak> roconnor: the function uses the state and the advantages of Reader over explicit passingâ¦  it just isn't meant to be bound, but only to be run
16:12:00 <crutcher> I think I've reached the point where I need to understand something about monad transformers
16:12:19 <crutcher> I'm trying to implement brainfuck. I've got a parser, and I'm working on the interpreter
16:12:26 <roconnor> mm_freak: I'm totally lost.  Maybe a paste is needed at this point.
16:12:44 <crutcher> I'm gonna build it in the runSTUArray environment
16:12:49 <roconnor> mm_freak: functions in the Reader monad that don't return anything don't do anything.
16:13:09 <crutcher> but I need an additional piece of state, the current pointer position
16:13:22 <crutcher> and I've no idea how to extend a monad env
16:13:23 <conal> does anyone know how to reverse a list in gnu make?
16:13:39 <crutcher> conal: a list of what?
16:13:54 <crutcher> conal: what kind of list, rather? Is it a make list, or a shell list?
16:14:13 <snk_kid> oh what cabal-install failed :(
16:14:22 <conal> crutcher: a make list i guess. it's the value of a makefile variable.
16:14:36 <dons> snk_kid: how?
16:14:38 <crutcher> okay. let me look ...
16:14:45 <mm_freak> roconnor: imagine a function that does some modular arithmetic:  modexp :: Integer -> Integer -> Reader Modulus Integer
16:15:18 <mm_freak> if i don't intend to bind modexp, but only to use it with runReader, then i could just as well use State instead of Reader
16:15:23 <juhp> can cabal-install explode source tarballs?
16:15:27 <roconnor> @hoogle withReader
16:15:28 <lambdabot> Control.Monad.Reader withReader :: (r' -> r) -> Reader r a -> Reader r' a
16:15:28 <lambdabot> Control.Monad.Reader withReaderT :: (r' -> r) -> ReaderT r m a -> ReaderT r' m a
16:15:36 <snk_kid> dons: i have it installed but trying to build GLUT failed with "Invalid configuration i686-pc-mingw32': machine `' not recognized..."
16:15:39 <roconnor> crutcher: ^^
16:15:52 <dons> snk_kid: ah, so GLUT failed to build.
16:15:59 <dons> snk_kid: is that right? cabal install GLUT ?
16:16:21 <roconnor> mm_freak: okay.  runReader counts and binding for pratical purposes.
16:16:25 <snk_kid> dons; yep
16:16:39 <roconnor> mm_freak: use Reader.
16:17:00 <roconnor> counts as binding
16:17:19 <mm_freak> conal: maybe in GNU make, the $(foreach) function is useful
16:17:38 <crutcher> conal: interesting. I can't see an easy way to do that. Even with foreach
16:17:39 <mm_freak> roconnor: ok, thank you
16:18:00 <roconnor> mm_freak: of course, if you aren't using any monad features at all, then don't use Reader and just write a function.
16:18:10 <conal> crutcher: thx for looking.
16:18:30 <snk_kid> dons: latest version of msys is very tempremental :/
16:18:59 <roconnor> crutcher: oops, you want to extend the state of a state monad.
16:19:31 <crutcher> roconnor: I think so. But I don't really know what I'm doing here.
16:19:31 <mm_freak> crutcher: maybe you can implement some ugly form of zipping and then counting backwards with $(foreach)
16:19:46 <roconnor> crutcher: you will have to change the type of your state
16:19:53 <roconnor> crutcher: and modify your code as required
16:20:09 <crutcher> mm_freak: well, you could always shell out, but you'll loose your list hygene when you re-parse the results
16:20:16 <roconnor> crutcher: this will be easier if you used record fields and speicalized function to access your state.
16:20:28 <roconnor> crutcher: if not, now would be a good time to start using them :)
16:20:48 <mm_freak> monad transformers are very easyâ¦  it's just that their name is scary a bit =)
16:20:58 <conal> any emacs users here?  i'm having some emacs+ghci oddness since switching to linux (ubuntu).  when i run ghci in bash (via "M-x shell"), i get all of my input echoed.  it's even a little worse in emacs-mode.  and it happens even with "emacs -Q" (don't load any start-up elisp code).  my emacs is 22.2.1.
16:21:07 <Peaker> monad transformers have some clunky syntax
16:21:09 <roconnor> <crutcher> but I need an additional piece of state, the current pointer position
16:21:23 <opqdonut> ?quote
16:21:24 <lambdabot> Adamant says: captchas are a way for some humans to find out their image recognition is worse than an tweaked OCR package
16:21:29 <opqdonut> ?quote
16:21:29 <crutcher> roconnor: I've got some exp with using the runSTUArray func, where you've only got the array as state. Whatever I build needs to run inside that
16:21:29 <lambdabot> mwc says: I'm thinking we should file a bug report and require ghc to produce executables that sound like famous classical pieces
16:21:30 <roconnor> crutcher: mm_freak is right. This sounds like you want to use a "Zipper" data structure
16:21:51 <roconnor> crutcher: oh, if you are using arrays then a zipper isn't appropriate.
16:21:59 <crutcher> roconnor: mm_freak is talking about Make rules
16:22:13 <roconnor> oh ok
16:22:23 <roconnor> he was still right. :P
16:23:06 <roconnor> Maybe someone has some examples of how to use the state monad.
16:23:16 <roconnor> there must be lots laying around on the interweb.
16:23:26 <mm_freak> > evalStateT (lift [1,2,3] >>= \x -> (get >>= \y -> return (x+y))) 5
16:23:28 <lambdabot>   [6,7,8]
16:24:23 <roconnor> > evalReaderT (lift [1,2,3] >>= \x -> (ask >>= \y -> return (x+y))) 5
16:24:25 <lambdabot>   Not in scope: `evalReaderT'
16:24:38 <roconnor> > runReaderT (lift [1,2,3] >>= \x -> (ask >>= \y -> return (x+y))) 5
16:24:39 <lambdabot>   [6,7,8]
16:26:19 <askentasken> monadic combinators, is there a librayr for that?
16:26:32 <roconnor> Control.Monad?
16:26:43 <roconnor> comes standard
16:27:06 <roconnor> @src Monad
16:27:06 <lambdabot> class  Monad m  where
16:27:06 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:27:06 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
16:27:06 <lambdabot>     return      :: a -> m a
16:27:06 <lambdabot>     fail        :: String -> m a
16:28:54 <snk_kid> relationship between arrows and stream processing?
16:29:54 <dmwit_> snk_kid: Stream processors are an arrow.
16:30:28 <mm_freak> hmmâ¦  i wonder where ListT is usefulâ¦  it seems like i'd have to reimplement all the list functions
16:30:35 <dmwit_> snk_kid: (>>>) performs the processors in sequence -- the output stream of the first becomes the input stream of the second
16:30:48 <mofmog> so can most recursive procedures be done via folds, unfolds and maps?
16:30:59 <dmwit_> mm_freak: You have to be careful with ListT.  It doesn't always make a monad.
16:31:00 <opqdonut> yes
16:31:08 <opqdonut> mofmog: yes, for some value of most :)
16:31:16 <dibblego> mofmog, map is from fold, so you can remove that from your statement
16:31:19 <mm_freak> mofmog: folds and unfolds (maps are folds)
16:31:32 <opqdonut> catamorphisms and endomorphisms
16:31:40 <mm_freak> dmwit_: huh?
16:31:42 <mofmog> catamorphism is a fold right?
16:31:50 <Cale> unfolds aren't endomorphisms...
16:31:52 <mofmog> are anamorphisms and endomorphisms the same?
16:31:57 <mofmog> oh
16:32:25 <Cale> endomorphisms are just arrows from an object to itself
16:32:37 <mofmog> so an endomorphism would just be id?
16:32:40 <dmwit_> mm_freak: If the monad you wrap with ListT doesn't have some property (commutativity, maybe?), the resulting data type is not a true monad.
16:32:46 <dmwit_> mm_freak: i.e. it fails some of the monad laws
16:32:51 <Cale> mofmog: id is an example of an endomorphism
16:33:04 <opqdonut> Cale: ah, got my morphisms mixed up
16:33:06 <Cale> mofmog: So every type/object has at least one. :)
16:33:06 <mofmog> unfold is an anamorphism right?
16:33:08 <dmwit_> mm_freak: Cale would know the details, or a few seconds on Google.
16:33:20 <mofmog> it goes from a single value to multiple, thus "ana"
16:33:26 <Cale> mofmog: iirc, that's right.
16:33:40 <mm_freak> ok, i'm reading
16:33:49 <Peaker> Cale: what endomorphism is there except id for some type?
16:34:18 <Cale> Peaker: For, say, Integer, there are lots of them.
16:34:20 <opqdonut> Peaker: well (+1) :: Integer->Integer
16:34:20 <mofmog> So for example, the equivalent of the factorial function that evertone writes when starting out in fn programming would just be "fac x = foldr (*) 1 [1..x]"
16:34:22 <Cale> :t (*2)
16:34:23 <lambdabot> forall a. (Num a) => a -> a
16:34:24 <askentasken> is there a Monadic Combinator library?
16:34:28 <askentasken> what is ti called?
16:34:35 <askentasken> google doesnt give any good info about it
16:34:37 <Cale> askentasken: Control.Monad?
16:34:43 <dmwit_> askentasken: The answer is the same as last time you asked.  Control.Monad
16:34:48 <Peaker> Cale, opqdonut: The type is an arrow to itself, but the value isn't?
16:34:55 <Cale> askentasken: Or... I'm not sure what you're looking for from that, exactly...
16:35:05 <opqdonut> Peaker: yeah
16:35:20 <Cale> Peaker: (*2) is an arrow from Integer to Integer, for instance.
16:35:34 <Cale> So it's an endomorphism on Integer.
16:35:52 <Cale> The endomorphisms on a type form a monoid under composition.
16:36:10 <Cale> If you just take the invertible ones, you get a group.
16:36:11 <Peaker> I guess I don't know what "an arrow" means in that context -- it speaks of what sets/categories its mapping between?
16:36:12 <mofmog> iirc, recursive procedures on functors can be done with folds and unfolds specific to those functors
16:36:23 <mofmog> an arrow is a function right?
16:36:24 <Cale> Peaker: I mean it in the category theoretic sense.
16:36:33 <dmwit> mofmog: Not quite.
16:36:36 <Cale> Peaker: So in the category of Haskell types, it's just a function.
16:36:42 <Peaker> Cale: I don't know CT, so I'm reverse engineering it from your words :)
16:36:44 <Cale> (a Haskell-definable function)
16:36:53 <Cale> Ah, okay
16:36:59 <snk_kid> dons: its working now, just this new version of msys is weird and quite buggy
16:36:59 <mofmog> wait, so what's a hylomorphism in all of this
16:37:04 <dmwit> mofmog: An arrow is a mapping between objects in a category, but I don't think "function" is quite the right word.
16:37:05 <askentasken> what is a class in Haskell? there is type, data and class. i dont really get the use for type either, i can do type Number = Integer but what is the point of that?
16:37:17 <mofmog> dmwit: but is the intuition the same?
16:37:20 <Cale> It might be good to mention that cata/ana/hylo are not (a priori) category theoretic terms.
16:37:20 <Peaker> Cale: I can guess you meant its a monoid because "id" will always be mempty and composition between (a->a) will always be OK with the Monoid laws regarding identity and associativity?
16:37:28 <mm_freak> askentasken: monads are integral to haskellâ¦  you use them everywhere
16:37:36 <dmwit> askentasken: "type" declares type synonyms. "data" declares new structures. "class" declares sets of types.
16:37:46 <Cale> askentasken: type just gives another name to an existing type
16:37:59 <mm_freak> the point of type:  type IntTriple = (Int, Int, Int)
16:38:00 <Cale> askentasken: In case you have some complicated type you don't want to write over and over.
16:38:07 <mofmog> ironically, i think slava pestov's google tech talk explains the haskell type system better than most tutorials
16:38:13 <Peaker> askentasken: type serves the same purpose as typedef in C
16:38:21 <Cale> askentasken: Do you know about parametric polymorphism already? Type variables?
16:38:25 <dmwit> askentasken: As such, "class" is closer to the mathematical meaning of class; it allows you to declare that several types have the same operations.
16:38:49 <Cale> askentasken: length :: [a] -> Int, for example, meaning that it takes a list of elements of any type a
16:38:53 <mofmog> Classes are more like operator overloading, type variables are like generics
16:39:19 <mofmog> For example, you can define + for many different types and so the + would come under the Num type
16:39:20 <Cale> mofmog: hmm... I disagree to some extent...
16:39:31 <mofmog> well i'm guessing he knows java or C moreso than anything else
16:39:39 <Cale> mofmog: I think of typeclasses as a refinement of what Java calls generics.
16:39:54 <mofmog> of course, i never said it was an exact comparison
16:40:03 <Cale> That is, typeclasses allow us to restrict what types a type variable ranges over.
16:40:09 <Peaker> type-classes could possibly be seen as a rich way to specify restrictions on the generics, which lacks in Java/etc
16:40:22 <Cale> Typeclasses don't mean a whole lot if you don't already have type variables.
16:40:23 <Peaker> C# has a language to specify such restrictions but it is more limited
16:40:25 <snk_kid> if you coming from a C++ stl/boost background one way to get type classes is to see that Concepts are quite similliar to type-class
16:40:44 <mofmog> Could you say type classes are like java interfaces?
16:40:50 <Cale> But I think this discussion is possibly confusing :)
16:40:50 <snk_kid> also C# generic type constraints using interface is simillar
16:40:53 <Cale> mofmog: a little
16:41:09 <snk_kid> C
16:41:11 <mofmog> the point of a java interface is that each class that implements as certain methods that you can use on it
16:41:11 <dmwit> Haskell's class is somewhat similar to interfaces, but with the ability to create anonymous interfaces that are a mix of named interfaces.
16:41:16 <glguy> did someone cause lambdabot to leave #concatenative?
16:41:16 <askentasken> any need to qualif Control.Monad?
16:41:19 <Cale> askentasken: Do you already know about type variables?
16:41:23 <Cale> askentasken: nope
16:41:32 <dmwit> askentasken: That is qualified already. ;-)
16:41:36 <dmwit> oh
16:41:45 <Saizan> mofmog: the main difference is that interfaces are types
16:41:47 <Cale> askentasken: Consider the type of something like the function 'sort' whose job it is to sort a list.
16:41:47 <dmwit> No, there's no clashes with Prelude (or just about any other module).
16:41:50 <Peaker> Haskell interfaces also support overloading based on return-type, as well as "multi-methods"
16:41:50 <snk_kid> they are similliar to interfaces but they arent used in the same fashion
16:41:52 <glguy> if it wasn't intentional could someone send lamdaot back to concatentative
16:41:54 <mm_freak> askentasken: in many cases, there isn't even a reason to import itâ¦  the most important stuff from Control.Monad is already in the prelude
16:41:57 <dibblego> the additional restriction on type-classes that the type variable is used in every function, is crucial in distinguishing type-classes from Java interfaces
16:42:09 <Cale> askentasken: It should take a list, and produce another list, so we might think it would have a type like [a] -> [a] at first.
16:42:13 <dmwit> mm_freak: Uh, what?
16:42:21 <snk_kid> askentasken: do you understand C# generic type constraints?
16:42:26 <Cale> askentasken: But then we run into the problem that not all types have a reasonable notion of ordering.
16:42:35 <Axman6> speaking of qualifying imports... how do i say import Data.Map as M? is it just 'import Data.Map as M'?
16:42:38 <mm_freak> dmwit: for some value of "most important"
16:42:51 <Saizan> mofmog: also the dispatch is done differently, in fact we have it also on the return type of functions
16:42:56 <dmwit> mm_freak: fix, forM, replicateM, instances of Monad...
16:42:57 <Cale> askentasken: So what we really want to say is that the type variable 'a' only ranges over types where we have ordering operations like (<)
16:43:01 <Saizan> s/return/result/
16:43:14 <Cale> askentasken: and to do that, we use a typeclass, specifically Ord
16:43:19 <Cale> sort :: Ord a => [a] -> [a]
16:43:23 <EmielRegis> i think typeclasses and c++ abstract classes/interfaces is same to large extent but with using different scheme
16:43:23 <mm_freak> dmwit: "in many cases", not "in most cases"
16:43:25 <Cale> class Ord a where
16:43:28 <mauke> Axman6: import qualified Data.Map as M
16:43:32 <Cale>   compare :: a -> a -> Ordering
16:43:33 <mm_freak> i often get along without importing Control.Monad
16:43:38 <Cale>   (<) :: a -> a -> Bool
16:43:42 <Cale>   ... etc. ...
16:43:44 <dmwit> mm_freak: I don't think I've written a real program yet that didn't need at least Control.Monad.
16:43:48 <Axman6> mauke: what does qualified actually mean btw?
16:43:52 <Cale> askentasken: Does that description help?
16:43:52 <Peaker> EmielRegis: you cannot specify the type Class a => a -> a   in C++ with abstract classes
16:43:57 <mm_freak> dmwit: indeed
16:44:01 <dmwit> mm_freak: Often Control.Arrow and Control.Applicative, too.
16:44:08 <snk_kid> Peaker: Concepts are like Typeclasses for C++
16:44:10 <askentasken> Cale: type variable, i dont know what it is but perhaps i still know the concept
16:44:16 <mauke> Axman6: that it won't shove everything in the unqualified namespace
16:44:17 <mm_freak> i've never used arrows
16:44:20 <Cale> askentasken: Okay, so let's step back a bit then :)
16:44:21 <Peaker> snk_kid: yeah, I know. but not abstract classes
16:44:23 <snk_kid> C++0x Concept ~= type classes
16:44:25 <EmielRegis> peaker: i dont really follow
16:44:30 <Axman6> righto...
16:44:34 <mrd> Axman6: it means that the symbols must be prefixed by "M." in that case
16:44:43 <EmielRegis> you mean an operator that takes one type a?
16:44:45 <Axman6> ah, ok
16:44:50 <mauke> Axman6: "as" provides an additional name
16:44:56 <mrd> Axman6: this is a good idea with Data.Map because it uses many of the same names that the Prelude does
16:44:56 <Peaker> EmielRegis: abstract classes and classes used as interfaces are not as powerful as Haskell type-classes, because they don't restrict a type-variable but instead used as the type itself
16:44:56 <Cale> askentasken: Type variables normally let us say that *any* type is okay.
16:44:57 <snk_kid> C# Generic Type Constraints using interfaces ~= Typeclasses
16:45:05 <srush__> conal: I think there is a bug in withPrevE
16:45:16 <Cale> askentasken: For example, you might have something like   length :: [a] -> Integer
16:45:21 <EmielRegis> ah ye
16:45:25 <askentasken> i know C, Python, a little JAVA(dont like it), a little lisp, a little ruby
16:45:33 <Cale> askentasken: That is, it takes a list of elements of any type a, and produces an Integer.
16:45:34 <EmielRegis> thats what i meant by being similar but with differnt 'architecture'
16:45:37 <mm_freak> EmielRegis: C++'s type system is not comparable to haskell'sâ¦  a class in C++ is like a type in haskell
16:45:45 <Cale> askentasken: length doesn't care what type of elements the list has
16:45:46 <Axman6> mrd: yeah, i'm using Data.[Map|Set|List] in the same module, so it was getting annoying to use Data.Blah.fromList
16:45:48 <EmielRegis> indeed
16:45:56 <Cale> askentasken: another example is  reverse :: [a] -> [a]
16:46:17 <Cale> askentasken: It takes a list of elements of type a and produces another list of elements of the same type
16:46:19 <snk_kid> mm_freak: C++0x Concepts are very similliar to typeclasses (but serve a different problem)
16:46:23 <Cale> (by reversing the list)
16:46:31 <Cale> again, it need not know what type of elements there are.
16:46:35 <mm_freak> snk_kid: are they turing-complete? =)
16:46:56 <Cale> askentasken: A more complicated example is provided by the higher-order function 'map':
16:47:02 <Cale> map :: (a -> b) -> [a] -> [b]
16:47:03 <snk_kid> mm_freak: well you can test it out with GCC Concept frontend!
16:47:20 <mm_freak> i mean, can you do type arithmetic in C++0x?
16:47:23 <Cale> It takes a function which takes a value of type 'a' and produces a value of type 'b'
16:47:27 <Cale> and a list of values of type 'a'
16:47:33 <Cale> and produces a list of values of type 'b'
16:48:05 <snk_kid> mm_freak: i don't know because the C++0x standard has only just be drafted and it's not offically released until next year
16:48:07 <Cale> It needn't care what the types 'a' and 'b' are, because it's just going to apply the function to the elements of the list it receives.
16:48:22 <Cale> askentasken: Does that make sense?
16:48:43 <Peaker> why haven't people given up on C++?  C#/Java show that legacy is overrated, we don't need the old C++ code
16:48:49 <Axman6> is C++0x possibly the most ugly name for a language ever?
16:48:57 <snk_kid> it's not a name
16:49:01 <mofmog> C++0x#
16:49:08 <Axman6> mrd: touchÃ©
16:49:10 <mofmog> C++0xTREME
16:49:11 <Axman6> uh, mofmog
16:49:25 <Axman6> C++0xBOL
16:49:26 <mauke> Axman6: it's pronounced "sepplesox"
16:49:30 <mofmog> hahahahaha
16:49:35 <mm_freak> Axman6: they plan to replace the 'x' by a digit, as soon as the year of release is known
16:49:41 <mm_freak> the '0x' stands for '200x'
16:49:42 <Axman6> heh, ok
16:49:54 <Axman6> still, ugly!
16:49:56 <mm_freak> i wonder when they rename C++0x to C++1x =)
16:50:02 <mofmog> C++0NEVER
16:50:09 <snk_kid> mm_freak: thats C1x
16:50:11 <mm_freak> C++0â¥
16:50:14 <EmielRegis> peaker: how its not needed? its probably the most widely used language now (kudos to being probably the greatest one for big projects)
16:50:16 <snk_kid> mm_freaks: i'm serious
16:50:18 <Axman6> C++0Void
16:50:19 <mauke> mm_freak: C++0A
16:50:23 <Cale> I should get around to designing MutVar#
16:50:34 <EmielRegis> c# AND JAVA are extremely inefficient in many cases
16:50:44 <snk_kid> mm_freaks: next ISO C revision, targetted for 2010
16:50:52 <snk_kid> mm_freaks: so C1x
16:51:04 <ben_h> as a haskell nub i was astounded at how fast it was compared to C
16:51:04 <mm_freak> hmm
16:51:05 <Axman6> Cale: what would it do? just a mutable variable?
16:51:10 <Cale> Axman6: heh
16:51:15 <ben_h> and hence against Java and friends
16:51:16 <Peaker> EmielRegis: C++ is the most widely used language today?
16:51:25 <Peaker> EmielRegis: There's no hope for software, ever, then
16:51:26 * Axman6 wasn't joking :(
16:51:32 <Cale> Axman6: It's my joke name for a language for .NET
16:51:36 <EmielRegis> it is
16:51:46 <Axman6> heh, ok
16:51:46 <Peaker> EmielRegis: C# / Java suck, but C++ sucks even more
16:51:47 <EmielRegis> most software is written in C/C++
16:51:49 <ben_h> i was seeing slowdowns of ~ 6x between similar (not identical) C and Haskell routines
16:51:50 <mm_freak> ben_h: sureâ¦  GHC has been improved greatly over the last few years
16:52:07 <mauke> EmielRegis: no software is written in C/C++
16:52:11 <ben_h> also it was interesting how a couple of small optimisations made about 8x difference
16:52:14 <EmielRegis> right.
16:52:25 <ben_h> mauke: lol?
16:52:37 <EmielRegis> as a game developer, I CAN assure you every single game that was out in last 10 years was written in C/C++
16:52:40 <mauke> I'm still the only person with a C/C++ implementation
16:52:43 <dmwit> EmielRegis: Of my four summer internships in software development, one of them has dealt with C++.  Are you sure you've got your facts on straight?
16:52:48 <mauke> EmielRegis: you fail
16:52:49 <Peaker> EmielRegis: I wrote a game in Python!
16:53:00 <mauke> ben_h: what/
16:53:02 <mm_freak> ben_h: although it really depends on the paradigm you use in C
16:53:04 <EmielRegis> i mean professional, commercial games
16:53:06 <conal> srush__: do tell
16:53:12 <mm_freak> if you write your C code like me, then you're screwed =)
16:53:13 <snk_kid> you guys make me laugh, i'm in the games industry too, i have to work nearly all the time C++
16:53:18 <mm_freak> http://rafb.net/p/pzZXt718.html
16:53:18 <EmielRegis> dmwit, which facts?
16:53:19 <Peaker> EmielRegis: what will you say if you are proven wrong?
16:53:19 <lambdabot> Title: Nopaste - Next generation crazy factorial function. =)
16:53:24 <srush__> it seems to be ignoring the first two events
16:53:26 <srush__> as opposed to one
16:53:28 <ben_h> mm_freak: true, these programs were just small ones with simple functions.
16:53:28 <EmielRegis> snk_kid, thats what im saying
16:53:31 <srush__> trying to track it down
16:53:39 <EmielRegis> peaker: i will bow before the master :p
16:53:42 <profmakx> the games industry is as all software engineering just 25 years behind time
16:53:44 <dmwit> EmielRegis: The facts that "most software is written in C/C++"
16:53:49 <Peaker> EmielRegis: surely people can find a commercial non-C++ game
16:54:01 <snk_kid> of-course there are
16:54:03 <ben_h> profmakx: yep i'd agree with that
16:54:06 <EmielRegis> ok
16:54:14 <dmwit> EmielRegis: By count of the programs I've worked on so far, about 10-20% of all projects are written in C/C++. ;-)
16:54:14 <EmielRegis> let me reprhase that - successful commercial games
16:54:16 <profmakx> even worse
16:54:25 <mm_freak> ben_h: algebraic lists in Câ¦  see the URL =P
16:54:26 <profmakx> they still believe that C++ is the best thing since sliced bread
16:54:27 <Kerris4> Bejeweled :V
16:54:29 <mauke> NO PROGRAMS ARE WRITTEN IN C/C++ :(
16:54:51 <Kerris4> successful commercial game not written in C/C++, that wasn't so hard :V
16:54:56 <dmwit> mauke: Just read "written in C/C++" as "written in C or written in C++" and you'll be happy. =)
16:54:56 <jeffz> mauke: is there a C/C++ implementation?
16:55:01 <Cale> Most people don't drive fuel efficient cars. Therefore, driving fuel efficient cars must be inherently impossible.
16:55:05 <mauke> jeffz: I have one
16:55:06 <EmielRegis> Kerris4, never heard of it
16:55:09 <EmielRegis> and im game freak
16:55:15 <EmielRegis> so its not successful :D
16:55:15 <jeffz> mauke: heh
16:55:23 <ivan> never heard of bejeweled?
16:55:25 <mauke> jeffz: it's written in Haskell :-)
16:55:32 <ben_h> mm_freak: lol are you sure that's C? :)
16:55:32 <jeffz> mauke: you should put it on hackage to confuse people ;)
16:55:34 <Cale> Don't forget all the games written in ActionScript :)
16:55:39 <Axman6> EmielRegis: it's quite a successful game indeed
16:55:40 <ivan> you've probably *seen* bejeweled, you just didn't notice
16:55:42 <dmwit> EmielRegis: You've never heard of bejeweled?  I'm not even into gaming, and I've heard of it.
16:55:45 <EmielRegis> no
16:55:46 <mauke> jeffz: yeah, but I'd need to clean it up first
16:55:50 <EmielRegis> well i see it now
16:55:52 <mm_freak> ben_h: C with a GCC extension to support scoped functions =)
16:55:57 <mauke> jeffz: also, the language definition is buggy/incomplete :-)
16:56:01 <Kerris4> EmielRegis: welp, since you're the final arbiter on successful games, I give up
16:56:03 <EmielRegis> maybe because i stopped playing puzzle games when i was 4
16:56:07 <dmwit> EmielRegis: Basically, I no longer trust any claim you make. ;-)
16:56:09 <ben_h> mm_freak: yeah i was about to say, those look like closures
16:56:12 <EmielRegis> lol
16:56:17 <Axman6> btw, peggle from Pop Cap games is excellent, and _really_ fun and addictive
16:56:21 <mm_freak> those _are_ closures =)
16:56:45 <mm_freak> of course, you need to use CPS to make them work ;)
16:56:48 <EmielRegis> but writing a puzzle game that has 1mb of source code is nothing compared to writing an FPS like crysis
16:56:50 <ben_h> CPS?
16:56:56 <mm_freak> continuation passing style
16:56:56 <ben_h> oh is that the extension?
16:56:57 <Japsu> okay, I'll start listing the games in my shelf, and someone holler when you notice one _not_ written in C/C++
16:56:59 <EmielRegis> which has tens, or even hundreds of megabytes of code
16:57:05 <Japsu> morrowind, bioshock, fallout 3, oblivion
16:57:06 <mm_freak> nope, CPS can be done in standard C =)
16:57:24 <Japsu> worms world party, age of empires 1 & 2, baldur's gate 1 & 2, in the groove
16:57:24 <mauke> dmwit, Japsu: http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html
16:57:29 <mm_freak> normal factorial function:  int factorial(int);
16:57:34 <lambdabot> Title: C/C++ Request For Enlightenment 0 - Design Philosophy
16:57:34 <MJSmall> Hi there. I'm new to Haskell and am having a small problem. In an HOpenGL tutorial, the "$=" assignment is used in a do block. As in, "displayCallback $= display". Could anyone please tell me what's that all about? :)
16:57:34 <Cale> Those look better than closures. Those look like first class procedures.
16:57:42 <mm_freak> CPS factorial function:  void factorial(int, void (*)(int));
16:57:45 <Japsu> unreal tournaments 2004 and 3, mass effect, assassin's creed
16:57:48 <ben_h> Cale: yeah
16:57:48 <Japsu> ...still nothing?
16:57:54 <Kerris4> Japsu: all of the first four games use a scripting language, why?
16:57:56 <EmielRegis> dont think so Japsu
16:57:59 <mauke> MJSmall: $= is just an operator (i.e. a library function with a funny name)
16:58:00 <Kerris4> same with all of the last four
16:58:01 <Cale> (Closures are pairs!)
16:58:14 <snk_kid> get a little realistic here, people in the games industry are usually domain experts who spend a long time learning about there problem domain. You can't expect everyone to be able to focus on being a domain expert and spend the time learning different programming paradigms and be able to utilize them effectively. Further it's not like they C++ is only used in a games project these days anyways
16:58:20 <EmielRegis> Kerris4, so? the script language interpreter is written in C++
16:58:20 <EmielRegis> :p
16:58:22 <EmielRegis> or C
16:58:37 <luqui> MJSmall, $= is just a user-defined infix operator
16:58:38 <mm_freak> Cale: real closures are impossible in C without support functions, because C is not garbage-collected
16:58:38 <Kerris4> EmielRegis: but C++ is so powerful, surely there is no need for a puny scripting language
16:58:41 <Cale> MJSmall: Sure...
16:58:45 <EmielRegis> Kerris4, its other issue
16:58:50 <vininim_> We have to respect beta, delta and gammas. But I'm glad I'm a lambda.
16:58:52 <EmielRegis> scripts are used by non-programmers mostly
16:58:52 <Japsu> EmielRegis: imnsho the scripting language interpreter is not the point, the game engine is
16:58:53 <Cale> MJSmall: $= is an operator defined by the OpenGL library.
16:58:54 <mm_freak> my code simulates garbage collection through the stack by using CPS
16:59:00 <snk_kid> big games are composed of multiple-languages
16:59:05 <EmielRegis> or people who have little insight into advanced C++ and wanna write AI functions, for example
16:59:06 <mm_freak> and it's ugly in GCC, because it needs executable stack
16:59:06 <MJSmall> @mauke & luqui & Cale: Ah, that's good news then. I thought I was going mad. Thanks!
16:59:06 <lambdabot> Unknown command, try @list
16:59:11 <Cale> MJSmall: It's actually a little bit unfortunate that it's part of the OpenGL library and not factored out.
16:59:24 <EmielRegis> Japsu, yes it is, I was merely supporting your claim :p
16:59:35 <snk_kid> but i have seen some really bad C++ code
16:59:46 <EmielRegis> if haskell/java/rppolog/lisp whatever you list is so cool
16:59:47 <snk_kid> in production
16:59:48 <EmielRegis> then why
16:59:49 <Peaker> EmielRegis: if you're going to claim things are in C++ because their language is implemented in C++, then everything is written in assembly, or machine code!
16:59:50 <Cale> vininim_: Nice reference :)
16:59:54 <Japsu> what I'm trying to say is that these scripts in the games, they're _content_ ;)
16:59:56 <EmielRegis> are nearly all OS written in C/C++?
16:59:59 <Kerris4> Peaker: nice
17:00:03 <crutcher> conal: reverse = $(if $(subst 0,,$(words $(1))), $(call reverse, $(wordlist 2, $(words $(1)), $(1))) $(word 1, $(1)))
17:00:11 <EmielRegis> peaker: ...
17:00:12 <ksf> lua is written in c, and that's the scripting language of choice.
17:00:14 <crutcher> that was somewhat non-obvious
17:00:18 <EmielRegis> the game engine is C++ itself
17:00:22 <luqui> Peaker, I don't know about that.  isn't C++ written in C, and C written in C?
17:00:22 <ksf> and os's are written in c, too.
17:00:23 <EmielRegis> only parts of game logic are scripted
17:00:26 <snk_kid> lets not forgot about shaders
17:00:33 <jeffz> snk_kid: who expects them to?  if current game design experts are restricted to C++ because they don't have time to learn anything else then that means there is plenty of room for people who want to write games in Haskell.
17:00:35 <snk_kid> tools
17:00:37 <Cale> Nearly all OSes are written in C or C++, therefore, writing an OS in another language must be a bad idea. ;)
17:00:45 <ksf> let's say only parts of the engine are not scripted.
17:00:50 <Peaker> luqui: If C is written in C, can you find the value of '\n' in the C compiler source code?
17:00:59 <Kerris4> haha C was written in C
17:01:01 <snk_kid> jeffz: game designers don't touch C++ usually
17:01:07 <conal> crutcher: wow.  thx.
17:01:10 <jeffz> snk_kid: programmers, whatever.
17:01:13 <EmielRegis> snk_kid, what?
17:01:15 <ksf> designers can't code, anyway...
17:01:20 <EmielRegis> thats bollocks
17:01:22 <mm_freak> GHC is written in haskell =)
17:01:24 <luqui> _nowadays_ C is written in C :-)
17:01:25 <mauke> Peaker: I distrust your distrust
17:01:27 <crutcher> http://hpaste.org/11899
17:01:33 <Kerris4> luqui: much better :P
17:01:33 <Philonous> :t pseq
17:01:34 <lambdabot> forall a b. a -> b -> b
17:01:37 <jeffz> snk_kid: misdirect.
17:01:40 <crutcher> you need to call it with $(call reverse, VAL)
17:01:42 <Philonous> @src pseq
17:01:42 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:01:43 <snk_kid> ?
17:01:58 <Cale> Philonous: pseq is a primitive.
17:02:16 <Axman6> t is?
17:02:18 <Axman6> it*
17:02:26 <Philonous> What's the difference to seq?
17:02:31 <EmielRegis> I agree that the biggest pressure on getting people make games, or OSes in C/C++ comes from historial reasons (as it became most widely used language for that)
17:02:34 <Peaker> luqui: the C compiler converts a '\\' followed by an 'n' to a '\n', so you cannot really figure out the value of '\n' from looking at the C compiler :-)  So you're still inheriting artifacts from the original non-C implementation of C, and obviously the first C compiler was not written in  C
17:02:39 <EmielRegis> but something must've triggered that in frist place
17:02:40 <Philonous> (I take it they are related? )
17:02:59 <Cale> Philonous: seq is defined by semantics which allow for the case that (seq x y) causes y to evaluate, then x, then results in y.
17:03:02 <snk_kid> EmielRegis: do you come across nasty C++ code at work?
17:03:06 <mauke> Peaker: not if it's a cross compiler
17:03:07 <Kerris4> EmielRegis: the lack of working compilers, perhaps
17:03:15 <snk_kid> EmielRegis: i mean some really no, no code
17:03:21 <Peaker> mauke: what's different in that case?
17:03:24 <Kerris4> 20 years ago a decent compiler was hard to come by for nearly anything
17:03:27 <EmielRegis> snk_kid, im not pro developer, im amatuer actually :D But yes, I do
17:03:30 <mauke> Peaker: the value of \n
17:03:36 <EmielRegis> probably some of my code can be qualified as nasty too,...
17:03:36 <Cale> Philonous: pseq specifically disallows that, (pseq x y) means to evaluate x first, then y, resulting in y.
17:03:37 <luqui> Peaker, I disagree.  The C compiler converts \n to whatever byte it represents on its target.
17:03:53 <EmielRegis> Kerris4, nah, hardly a reason in times where most games were written in assembler
17:03:54 <luqui> compiler written in C /= translator from C to C
17:04:06 <EmielRegis> it just seemed to most viable choice, didnt it?
17:04:15 <Kerris4> EmielRegis: and the target platform for those assembler games was?
17:04:19 <Peaker> mauke: do C compilers mostly support non-ascii?
17:04:23 <EmielRegis> PC?
17:04:25 <Philonous> Ah, and how would that make any difference?
17:04:28 <EmielRegis> i386?
17:04:28 <ksf> EmielRegis, it's C because real programmers don't code pascal.
17:04:29 <Cale> Philonous: Specifically, all that (seq x y) means is that x must be evaluated at some point before the result of evaluating y is made available.
17:04:31 <mauke> Peaker: depends on the compiler
17:04:43 <snk_kid> Tim Sweeney has the idea the problem is you're not going to convince anyone!
17:04:50 <mauke> Peaker: but note that ascii has no "newline" character
17:04:59 <Cale> Philonous: Personally, I view it as a bit of an oversight...
17:05:04 <EmielRegis> snk_kid, I am working with Source SDk now, its written in C++ and is really nice. But ive been working with Jedi Academy SDK before, which was written in C and was a big pile of shitty mess :P
17:05:07 <ksf> C is just the best high-level assembler you can get.
17:05:10 <Cale> Philonous: pseq does what you really want seq to do in most cases.
17:05:24 <Cale> Philonous: But in most cases, there's no difference between the two.
17:05:28 <erikc> snk_kid: convince anyone of? (sorry im coming in a bit late)
17:05:30 <mm_freak> C is boring =/
17:05:31 <crutcher> ksf: C is a terrible assembler.
17:05:35 <Axman6> anyone had a look at BitC?
17:05:48 <crutcher> it doesn't have explicitly sized types
17:05:54 <mm_freak> sometimes i find myself using setjmp()/longjmp() or continuations just to make it more interesting
17:05:56 <Peaker> Axman6: I did, I was disappointed to learn he used Lisp syntax, but has no syntactic macros
17:06:07 <Peaker> Axman6: but it seemed interesting
17:06:11 <mm_freak> crutcher: inttypes.h
17:06:16 <mm_freak> uint32_t
17:06:17 <Axman6> Peaker: yeah, the lispness was a little offputting
17:06:26 <Philonous> Cale: But wouldn't that only make a difference when x and y are not referentially transparent?
17:06:28 <erikc> one problem with the game industry is that the platform holders on the console side bless a C/C++ compiler as 'the compiler' and you gotta compile with that, and they also dont allow jitting of code (exec pages are read only)
17:06:28 <Peaker> Axman6: then I realized the bottom-up approach of reforming the software world is wrong, and we need a top-down approach :)
17:06:31 <snk_kid> EmielRegis: well be prepared for not some really nasty C++ code because quite a few game developers originally come from C
17:06:34 <crutcher> mm_freak: oh, every compiler works arround that prob. But there are others
17:06:44 <Axman6> Peaker: enter Haskell, yet again?
17:06:48 <Cale> Philonous: Well, it can make a difference to performance.
17:06:52 <Peaker> Axman6: yeah
17:07:01 <walski> Hi
17:07:02 <Japsu> I find it interesting that Microsoft is now pushing C# into the gaming industry
17:07:04 <crutcher> I actually don't think we should still use C compilers written in C, since C is a terrible language for dealing with trees
17:07:07 <Kerris4> EmielRegis: my point exact, it was hard enough to find compilers for everything else :P
17:07:12 <crutcher> but no one cares what I think :)
17:07:12 <mm_freak> crutcher: inttypes.h is a standard header
17:07:19 <Cale> Philonous: Performance isn't something which is preserved by the transformations that referential transparency allows ;)
17:07:21 <snk_kid> Japsu: they don't need to do that it already is
17:07:23 <EmielRegis> Japsu, me too. However I dont think VisualSDK will be very worthy performance wise
17:07:25 <Cale> walski: hi
17:07:35 <dmwit_> crutcher: I care what yo... ah, I can't even make myself say it. ;-)
17:07:36 <Cale> Wow, this channel is busy tonight :)
17:07:36 <snk_kid> C# is used for tools dev
17:07:38 <mm_freak> crutcher: you can implement algebraic trees in C =P
17:07:43 <crutcher> mm_freak: hmm, seems to come in with C99
17:07:44 <Japsu> I've no idea how widely C# and CLI are used there at the moment
17:07:44 <mm_freak> see my method above =)
17:07:45 <EmielRegis> yea
17:07:52 <snk_kid> often
17:07:54 <snk_kid> not always
17:07:54 <Cale> Especially with lots of talk about old imperative languages. ;)
17:07:55 <walski> I hope I can find somebody in here who could help out a Haskell newbie who is getting mad over the easiest exercises.
17:08:02 <crutcher> mm_freak: can != should
17:08:02 <Japsu> it'd be nice to hear about commercially successful games that are non-trivial performance-wise and use C#
17:08:14 <Cale> walski: Sure, there are lots... if we can get this C discussion to quiet down :)
17:08:19 <ksf> M$ pushes any product they intend to sell anywhere they can.
17:08:20 <walski> ;)
17:08:21 <EmielRegis> Japsu, doubt thats possible
17:08:26 * crutcher shuts up
17:08:27 <walski> I'm fine with C ;)
17:08:29 <mm_freak> why not?  i don't care whether the average C programmer understands my codeâ¦  i'm for C what Cale is for haskell =P
17:08:30 <EmielRegis> although I heard C# is really faster lately
17:08:30 <Axman6> walski: what's the problem? (and if you have code, paste it on hpaste)
17:08:33 <Axman6> @hpaste
17:08:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:08:37 <Philonous> Cale: Ok, right, maybe I was thinking a little bit too algebraic ^^
17:08:37 <snk_kid> Japsu: well there are a couple of C# houses who use it for main game code
17:08:40 <EmielRegis> walski, feel free to pm me.. though im haskell noob myself ;D
17:08:43 <walski> Ok I'll just explain what's to do:
17:08:49 <snk_kid> Japsu: there is a youtube video floating around
17:08:55 <Cale> walski: Or come to #haskell-overflow
17:08:59 <Japsu> titles?
17:09:04 <Cale> which is pretty quiet atm :)
17:09:06 <EmielRegis> snk_kid, link please?
17:09:10 <EmielRegis> i would be happy to see that
17:09:11 <snk_kid> Japsu: i can't remember the name, some combat driving game
17:09:20 <erikc> Japsu: http://en.wikipedia.org/wiki/Schizoid_(game) is an xbla game written in c#
17:09:34 <walski> I have to define a datatype "Shape" which describes either a circle (point and radius) or a rectangle (4 points) or a triangle (3 points). To achieve that I have to implement a Point datatype first, which is just a Double tuple.
17:09:39 <walski> I'll paste what I got
17:09:44 <walski> and then ask my questions ;)
17:09:46 <erikc> microsoft is making a push toward c#/f# for xbla stuff
17:09:51 <Cale> walski: sure
17:09:53 <Japsu> erikc: cool... but that's still asteroids, not mass effect :(
17:09:57 <Philonous> Cale: could it be that you actually meant psec when you said "Specifically, all that (seq x y) means is that x must be evaluated at some point before the result of evaluating y is made available." ?
17:10:06 <snk_kid> i wish i could use at least F# at work
17:10:08 <Japsu> erikc: it's an asteroids clone that uses shader assembly for the heavy lifting
17:10:31 <walski> Here is it: http://hpaste.org/11900
17:10:32 <snk_kid> assembly? i doubt it
17:10:37 <Cale> Philonous: nope... I'm pretty sure I got it right...
17:10:44 <walski> I can load this in GHCi which is cool ;)
17:10:47 <Cale> Philonous: see http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel.html
17:10:50 <mauke> walski: that's wrong :-)
17:10:52 <Axman6> walski: want to join #haskell-overflow, so we can avoid all the noise?
17:10:53 <Japsu> meh, not shader assembly but the shader language thingy
17:10:57 <Japsu> what's it called,
17:10:59 <EmielRegis> HLSL
17:10:59 <lambdabot> Title: Control.Parallel, http://tinyurl.com/2ktqoz
17:10:59 <snk_kid> lol
17:11:00 <walski> surre
17:11:03 <Japsu> yeah.
17:11:05 <Japsu> hlsl.
17:11:15 <snk_kid> but there are multiple shader languages!
17:11:19 <Japsu> sure
17:11:27 <snk_kid> but yeah most likely HLSL
17:11:30 <EmielRegis> HLSL is for DirectX
17:11:35 <EmielRegis> there is this other one for OpenGl
17:11:37 <EmielRegis> i forgot the name
17:11:41 <Japsu> GLSL ;)
17:11:44 <snk_kid> GLSL
17:11:45 <EmielRegis> al
17:11:46 <snk_kid> and Cg
17:11:47 <EmielRegis> lol ye
17:11:56 <SamB> is there one for Glide ?
17:12:05 <snk_kid> neah
17:12:06 <EmielRegis> glide is long time dead
17:12:07 <Japsu> does someone still use glide?
17:12:12 <EmielRegis> and it was not programmable back then
17:12:13 <EmielRegis> so no :p
17:12:26 <SamB> what? Voodoo 5 didn't have shaders?
17:12:30 <snk_kid> there is some glide nutters still around
17:12:36 <EmielRegis> i dont think it did
17:12:44 <SamB> well, actually, I'm using the Glide64 plugin in mupen64plus since it works best for me
17:12:45 <snk_kid> pushing there voodoo cards to the limits
17:12:52 <EmielRegis> first programmable GFX was geforce256 I think
17:13:01 <SamB> but it uses a wrapper
17:13:01 <Philonous> Cale: Oh, I missunderstood. My bad.
17:13:15 <Japsu> snk_kid: yes, as there's still some C64 nutters still around, pushing C64 to the limits ;)
17:13:28 <snk_kid> i wouldn't be surprised
17:13:33 <Japsu> they do cool stuff in demoscene. cool, completely unpractical stuff
17:13:42 <SamB> yes, tring to run that lunix and serve up HTTP
17:13:47 <snk_kid> isn't that what life is about lol
17:14:24 <Kerris4> pushing the envelope!
17:14:24 <Japsu> for example, ftp://micksam7.com/demos/booze_design-edge_of_disgrace.mp4 <-- a c64 demo released in 2008
17:16:03 <EmielRegis> hmm
17:16:08 <ksf> Is that ftp served by a c64?
17:16:08 <Davbo> noobie question: What does "." do in Haskell?
17:16:09 <EmielRegis> i didnt look at cg before
17:16:13 <Japsu> ksf: no.
17:16:21 <Japsu> @src (.)
17:16:22 <lambdabot> (f . g) x = f (g x)
17:16:24 <EmielRegis> it seems it can output both HLSL and GLSL code
17:16:30 <Davbo> thought so Japsu
17:16:32 <EmielRegis> Davbo, function composition
17:16:34 <Japsu> Davbo: function composition, that is
17:16:40 <Davbo> thanks guys
17:16:43 <Japsu> @quote stereo!
17:16:43 <lambdabot> greeting says: Welcome to #haskell where your questions are answered in glorious stereo!
17:17:15 <snk_kid> EmielRegis: if you're a GL nut then you'd probably prefer using Cg over glsl ;)
17:17:29 <snk_kid> oh dear i just ran frag
17:17:35 <snk_kid> it needs some serious update
17:17:43 <Japsu> hmm, is cg nvidia-only?
17:18:12 <EmielRegis> snk_kid, sadly I dont have much knowledge on graphic programming ;/
17:18:20 <EvilTerran> @vixen how are you today?
17:18:21 <lambdabot> i'm good, you?
17:18:25 <EmielRegis> but I wanna get into shaders to get some cool effects for my game ;)
17:18:31 <EmielRegis> no Japsu
17:18:40 <EmielRegis> it can output both directx and opengl code
17:18:59 <Japsu> there's this little toy project of mine I've, to code a mandelbrot rotozoomer in a pixel shader ;)
17:19:28 <Japsu> trying to learn hlsl in the process.
17:21:07 <snk_kid> EmielRegis: so you're modding then?
17:21:11 <EmielRegis> yes
17:21:32 <snk_kid> EmielRegis: what are you doing?
17:21:41 <EmielRegis> www.invision-games.com :P
17:21:47 <EmielRegis> star wars total conversion on source engine
17:22:09 <u_quark> @seen marcot
17:22:10 <lambdabot> I saw marcot leaving #haskell 6d 4h 56m 8s ago, and .
17:22:53 <snk_kid> EmielRegis: looks cool
17:23:11 <snk_kid> EmielRegis: fps?
17:23:28 <EmielRegis> snk_kid, yea, but needs loads of work still. we have pretty ambitious plans, including single player at some time
17:23:34 <EmielRegis> yes, its an fps
17:24:12 <snk_kid> EmielRegis: well good luck with it, don't get to ambitious :)
17:24:23 <EmielRegis> thanks ;)
17:24:29 <Japsu> oh, that looks 'ool
17:24:31 <Japsu> *cool
17:24:45 <snk_kid> EmielRegis: you know SMOD?
17:25:00 <EmielRegis> snk_kid, I know few things with that name.. which one exactly do you mean?
17:25:16 <Japsu> those tantive IV screenshots look really neat
17:25:29 <Japsu> I'm looking forward to play this ;)
17:25:32 <snk_kid> EmielRegis: the original SMOD for HL2 (which all the others are derived from)
17:25:34 <EmielRegis> ^^
17:25:52 <EmielRegis> snk_kid, ah, no I havent played it.
17:26:02 <snk_kid> EmielRegis: its not really a game, more of a meta-mod
17:26:25 <Japsu> makes me want to watch the movies again ;)
17:26:36 <snk_kid> EmielRegis: it adds lots of features to the source sdk, including lua support
17:27:06 <snk_kid> EmielRegis: so metamod, other mods build off of it
17:27:14 <EmielRegis> snk_kid, ah, I thought so. there is actually a lot of effort put into things like plugin interfece
17:27:30 <EmielRegis> although there is a quite powerful interface in the SDK itself
17:27:41 <snk_kid> you need to watch the video!
17:27:44 <EmielRegis> I am at least glad to see how much community effort is put into the game
17:27:56 <EmielRegis> as well as constant support from valve, which is sweet
17:28:03 <EmielRegis> what video?
17:28:33 <snk_kid> of SMOD features
17:29:05 <snk_kid> awesome blood effects
17:29:37 <EmielRegis> looking at it now
17:31:57 <gwern> @quote ungrateful
17:31:57 <lambdabot> kzm says: My program contains a bug.  How ungrateful, after all I've done for it.
17:32:26 <EmielRegis> lol
17:32:27 <SubStack> truth
17:39:39 <snk_kid> why is there no videos of frag?
17:42:01 <dons> snk_kid: hmm. good question.
17:42:04 <dons> would you like me to make one?
17:42:06 <dons> right now!?
17:42:14 <dons> $ cabal install frag
17:42:17 <snk_kid> dons: well i've got it built and running
17:42:27 <dons> make a video!!
17:43:04 <snk_kid> dons: i should make a blog of "haskell: it just works (IJW) technology"
17:43:15 <snk_kid> :P
17:43:35 <dons> :)
17:43:38 <snk_kid> i need to up fraps
17:43:44 <snk_kid> fraps to video frag
17:43:47 <snk_kid> lol
17:47:52 <erikc> snk_kid: are you windows-based where you work for build pipe / tools / dev env?
17:49:01 <snk_kid> erikc: at the moment yep
17:49:50 <dons> you could write up your haskell dev environment on windows
17:49:52 <dons> to help others.
17:49:56 <dons> that would be quite valuable.
17:50:59 <snk_kid> i dont have such envirnment at work, i highly doubt i would be allowed to ;)
17:51:33 <dons> highly doubt you'd be able to write about your dev environment?
17:51:33 <erikc> i write my tools at work in haskell, then convert them to c or c# when they are correct
17:51:39 <dons> heh.
17:52:02 <mauke> ghc can do that, right?
17:52:07 <snk_kid> dons: i don't mean that lol
17:52:23 * SubStack does a similar thing for ruby code
17:52:33 <Nafai> It seems difficult to translate Haskell into C or C#
17:52:35 <SubStack> for some of the more non-trivial algorithms
17:52:52 <Nafai> (into human-readable C, not the compiler generated versions)
17:53:12 <erikc> nafai: i just mean i use haskell so im forced to concentrate on the core data and algorithm meat and potatoes
17:53:35 <SubStack> c wasn't designed to be human readable
17:53:39 <erikc> and dont get distracted with performance or oo masturbation
17:53:54 <Nafai> I guess I haven't done enough algorthmically at work to have that be super beneficial
17:54:14 <Nafai> erikc: What kinds of theings are you working on?
17:55:07 <erikc> most recently, a coroutine scheduler for spu jobs and a datalog for game data
17:55:25 <Nafai> Sounds fun
17:55:29 <Nafai> You work on video games?
17:55:55 <SubStack> neat
17:56:24 <erikc> yep
17:56:53 <snk_kid> you know what is weird, one of our senior graphics programmer he's a C guy but some how he knows something about haskell
17:56:59 <Nafai> I got out of that industry 3 years ago :)
17:57:18 <erikc> nafai: smart move (seriously, im nearing my end :)
17:57:28 <Nafai> Yeah, just wasn't for me
17:57:57 <dmwit_> snk_kid: Why is that weird?
18:00:08 <snk_kid> dmwit_: well unless you're a scripter or in tools dev almost every programmer i've spoken to don't know much beyond the C/C++ box and don't want to know
18:00:41 <snk_kid> it's not really that weird i guess
18:01:58 <mm_freak> how is (forall s. ST s a) -> a different from forall s. ST s a -> a?
18:02:00 <dmwit_> The best programmers I know are all about looking at new languages and ideas.
18:02:12 <Nafai> dmwit_: Indeed
18:02:36 <snk_kid> i think that is a little unfair to say
18:02:52 <SubStack> some people are more breadth-first and some are more depth-first
18:03:38 <snk_kid> you got to consider the problem domains they deal with are large subject areas in themselves
18:03:56 <snk_kid> take many years to learn & master
18:04:23 <erikc> yea, particularly for graphics
18:04:56 <dmwit_> mm_freak: The latter runs would run an ST action with a particular type of state.
18:05:15 <dmwit_> mm_freak: The former runs an ST action that knows how to handle *any* kind of state.
18:05:46 <Cale> snk_kid: But it might be attractive if the languages they used were capable of giving them tools which operated closer to the problem domain.
18:05:46 <dmwit_> mm_freak: The upshot of this is that the "run" function gets to decide what 's' is, not the person providing the ST action.
18:06:52 <dmwit_> mm_freak: But that's about the extent of my knowledge in that area, so I hope that much is helpful. =P
18:08:40 <snk_kid> Cale: yeah but you're gonna have a tough time convincing them (for now)
18:09:06 <mm_freak> it was helpful, thanks
18:09:54 <mm_freak> is ST part of haskell 98?
18:10:15 <dolio> > runST (newSTRef (3 :: Int)) -- mainly it keeps you from doing this and other such terrible things
18:10:18 <lambdabot>       Inferred type is less polymorphic than expected
18:10:18 <lambdabot>        Quantified type ...
18:11:13 <snk_kid> Cale: my point was it's hard to focus on mastering your problem domain let alone the learning curves of learning other programming paradigms. It takes time and what should you focus on first
18:11:50 <dmwit_> mm_freak: no
18:11:56 <dmwit_> mm_freak: It uses Rank2Types.
18:12:08 <snk_kid> and at that point when you get there it's like you don't want to do anything else from exhaustion!
18:12:18 <mm_freak> k
18:12:45 <gwern> 'Ultimately, the problem with Haskell and ML for our purposes is that the brightest and most aggressive programmers in those languages, using the most aggressive optimization techniques known to the research community, remain unable to write systems codes that compete reasonably with C or C++. The most successful attempt to date is probably the FoxNet TCP/IP protocol stack, which incurred a 10x increase in system load and a 40x penalty ...
18:12:52 <gwern> ... in accessing external memory relative to a conventional (and less aggressively optimized) C implemenation. '
18:13:09 <gwern> 'It is instructive that no performance evaluation of the hOp and House [10] systems was attempted five years later. The operative research question in both systems was whether systems programming is feasible in Haskell, not whether the result is practically useful. In the eyes of the systems community, it is inconceivable that these two questions might be separated, and in the absence of a performance evaluation the work has limited ...
18:13:16 <gwern> ... credibility. From a programming language perspective, we view the hOp and House results as positive first indicators that must be viewed skeptically. Given the ratio of C to Haskell code in the House implementation, it does not seem to us that the case for Haskell as a systems programming language has been sustained (yet).'
18:13:20 <gwern> http://www.bitc-lang.org/docs/bitc/bitc-origins.html
18:13:32 <lambdabot> Title: The Origins of the BitC Programming Language
18:13:38 <newsham> itC bitC
18:14:20 <ksf> imho, hOp and House aren't real OSs, ghc is.
18:14:41 <Cale_> iirc, House is based on GHC.
18:15:05 <newsham> does that change the argument?
18:15:16 <ksf> my point exacly.
18:15:18 <newsham> the ratio of C to haskell in ghc is still large (in fact, larger, no?)
18:15:21 <askentasken> OSs?
18:15:25 <snk_kid> you know when people talk about others, it's always in a vacuum environment, like we are robots and never take into accout other external factors
18:15:49 <Cale_> hm?
18:15:57 <gwern> 'Several people advocated that we adopt the Haskell monads alternative. We rejected this option early, largely because we didn't think we could explain it to general systems programmers, and it imposes constraints that we found idiomatically restrictive. Later we would come to feel that monads do not scale to large programs well.'
18:16:09 <newsham> when they takl about the C code in House they really mean the C code in ghc runtime
18:16:31 <gwern> 'We decided very early that the ML surface syntax should not survive. It is hopelessly ambiguous, which is more or less inexcusable, but after all it's just a yucky pragmatics issue. The beauty of the ML family really does go more than skin deep, but given the skin, it needs to. ' <-- *snirk*
18:16:36 <ksf> it's ghc that's able to run on bare metal, unmodified and only annotated with some code to do mmap and a few other things.
18:17:00 <Cale> gwern: Are you almost done pasting the entire contents of that page into the IRC channel ;)
18:17:17 <gwern> Cale: the paper is many times longer than what I have pasted
18:17:24 <gwern> I paste merely the amusing and snarky bits
18:17:50 <Cale> Heh, people who don't understand monads tend to make really strange comments.
18:18:23 <gwern> 'One reason that that ML inference system works well subjectively is that the language does not include multiple integral or floating point types. There is a kludge in ML to disambiguate int vs. float by fiat. ' <-- huh. I didn't know that. I had assumed ML did something similar to type classes but using its fancy module stuff
18:18:43 <Cale> no.
18:18:52 <ksf> newsham, is there even any c left in ghc?
18:18:55 <Cale> That would be way way too heavyweight for numbers.
18:19:00 <newsham> bind program restOfProgram
18:19:35 <Axman6> anyone know how to fix this in cabal-install? cabal: ghc-pkg describe * failed. If you are using ghc-6.9 and have an empty
18:19:50 <gwern> 'Strong typing means that BitC occasionally requires type annotations'
18:20:06 <Axman6> i upgraded to 6.10.1, and now i can't use cabal-install
18:21:20 <dcoutts> Axioplase_: upgrade cabal-install
18:21:21 <newsham> $ find ghc-6.8.2 -name '*.c' |xargs wc|grep total 204388  746641 5754401 total
18:21:34 <dcoutts> Axioplase_: oops, sorry, I meant Axman6
18:21:43 <Axman6> dcoutts: how do i do that?
18:22:31 <dcoutts> Axman6: by building its dependencies and then it in the traditional way
18:22:38 <luqui> "later we would come to feel that monads do not scale to large programs well
18:22:47 <Axman6> lame -_-
18:22:51 <luqui> I am of the opinion that no single abstraction scales to large programs well
18:22:59 <Axman6> but, i'll get on that soon
18:23:12 <luqui> monads are useful in *little* bits, not as a way to sequence your entire program together...
18:23:23 <dcoutts> Axman6: if you'd done it the other way around it'd work, ie upgraded cabal-install and then ghc
18:23:43 <Axman6> ah, i see
18:23:47 <dcoutts> Axman6: but there were several updates required to make cabal-install work with ghc-6.10
18:24:11 <Cale> To make the ridiculousness of that statement more apparent to the uninitiated, I propose systematically replacing the word "monads" with the word "libraries"
18:24:19 <gwern> 'The C approach was certainly out. Textual inclusion is about as elegant as Perl syntax (and can be implemented therewith). The ML module system [18] is fully understood only by David MacQueen, and only on alternating weeks. The Scheme module system [8] required the combined brilliance of Matt Flatt and Matthias Felleisen (and six revisions of the language standard) to achieve.' <-- zings galore
18:24:20 <luqui> :-)
18:24:36 <Cale> "later we would come to feel that libraries do not scale to large programs well"
18:24:59 <ksf> "occasionally requires type annotations"... doing a bit of c++ template work, I found myself cursing the compiler for not interfering even the simplest things.
18:25:02 <gwern> @remember JoanathanShapiro The ML module system is fully understood only by David MacQueen, and only on alternating weeks.
18:25:03 <lambdabot> I will remember.
18:25:10 <gwern> @quote alternating
18:25:10 <lambdabot> JoanathanShapiro says: The ML module system is fully understood only by David MacQueen, and only on alternating weeks.
18:25:44 <Cale> Is that really how his name is spelled?
18:25:53 <gwern> no
18:26:00 <gwern> @forget JoanathanShapiro
18:26:00 <lambdabot> Incorrect arguments to quote
18:26:04 <ksf> my favourite is the monad quote.
18:26:10 <gwern> @help forget
18:26:10 <lambdabot> forget nick quote.  Delete a quote
18:26:16 <Cale> @forget JoanathanShapiro The ML module system is fully understood only by David MacQueen, and only on alternating weeks.
18:26:16 <lambdabot> Done.
18:26:24 <gwern> @remember JonathanShapiro The ML module system is fully understood only by David MacQueen, and only on alternating weeks.
18:26:25 <lambdabot> I will never forget.
18:26:30 <gwern> the looks better
18:26:42 <erikc> ksf: indeed, there are really simple template idioms i'd like to use that are socially unacceptable because of the verbosity that occurs without inferencing (c++0x's auto will help that somewhat)
18:26:46 <mauke> @flush
18:26:55 <gwern> @remember JonathanShapiro Later we would come to feel that monads do not scale to large programs well.
18:26:56 <lambdabot> Done.
18:27:00 <gwern> @quote scale
18:27:00 <lambdabot> JonathanShapiro says: Later we would come to feel that monads do not scale to large programs well.
18:27:33 <gwern> @flush
18:27:52 <gwern> ' The problems with module systems in stateful languages are all about global variable initialization order. Java ducks this by eliminating both non-trivial and mutable global variables. Which works, but it is one of the reasons that Java isn't terribly well suited to systems programming. One thing does seem clear: using things before you define them is problematic in a safe programming language.
18:28:11 <gwern> (Yes, I suppose using undefined things can be problematic)
18:28:46 <ksf> java isn't suited for systems programming because it's  without a j2se runtime
18:29:01 <ksf> insert a "a pain to use" there.
18:29:13 <ksf> i know, i did games in j2me.
18:29:29 * Axman6 proposes hardware j2se runtime chips
18:29:48 * luqui proposes software j2se compile-time chips
18:29:55 <ksf> you've got the speed of an interpreted language and the inflexibility of a compiled one.
18:30:32 <luqui> ksf, how dare you say such blasphemy to a compiled channel!
18:31:13 <ksf> ghc-api ftw.
18:31:23 <luqui> @faq Can Haskell be as flexible as an interpreted language?
18:31:23 <lambdabot> The answer is: Yes! Haskell can do that.
18:31:30 <gwern> 'From the programming language community, we are often informed that we didn't fully understand the I/O monad, or we are asked whether state is truly necessary. To some degree this question is a matter of theology, but state is unquestionably awkward from a verification standpoint. '
18:31:47 <ksf> TH ftw.
18:32:56 <luqui> gwern, this is from the recent LtU paper?
18:32:58 <gwern> 'The real reason we stuck with the LISP-ish syntax is that we didn't want to be fiddling with the parser while designing the language, and (to a lesser degree) because we didn't want to encourage programmers until we thought the language was ready. We are now preparing a more sensible surface syntax, whereupon we will receive rotten egg and tomato complaints from the LISP community. You can't please everyone.'
18:33:09 <gwern> luqui: I don't think so, the page is marked a draft/unfinished
18:33:10 <Cale> gwern: heh, "So in summary, why did we create BitC? It seems that we did so because of a failure to understand functional programming idioms."
18:33:23 <Cale> (not a real quote)
18:33:24 <erikc> heh
18:33:47 <dolio> Yes, it's the LtU paper.
18:33:49 <gwern> @remember JonathanShapiro We are now preparing a more sensible surface syntax, whereupon we will receive rotten egg and tomato complaints from the LISP community.
18:33:49 <lambdabot> I will never forget.
18:33:55 <gwern> @quote rotten
18:33:56 <lambdabot> JonathanShapiro says: We are now preparing a more sensible surface syntax, whereupon we will receive rotten egg and tomato complaints from the LISP community.
18:34:36 <ksf> starting out with lisp syntax is actually a very sensible idea.
18:34:49 <Cale> ksf: Indeed it is.
18:34:51 <luqui> Cale, that does seem a pretty common reason (with various substitutions for "functional programming") to create a language
18:34:52 <gwern> 'It is noteworthy that none of this effort was deemed fundable by the National Science Foundation (which is to say: by the academic programming languages community). The work is clearly innovative, and it is somewhat unusual to find a project of this sort that is accompanied by a validating experiment. ' <-- sour much?
18:35:07 <rherrmann> ksf: lisp no-syntax
18:35:14 <dibblego> gwern, got a link?
18:35:22 <dons> ?seen mbeddoe
18:35:22 <lambdabot> Last time I saw mbeddoe was when I left #debian-es, #dreamlinux-es, #friendly-coders, #gentoo-uy, #haskell, #haskell-hac07, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.
18:35:22 <lambdabot> hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru and #thunks 2m 17d 21h 10m 27s ago.
18:35:23 <gwern> luqui: looks like it might be post-LtU: 'We have received comments, encouragement, and assistance from the many members of the bitc-lang mailing list and the Lambda the Ultimate blog. '
18:35:35 <gwern> dibblego: I posted it earlier: http://www.bitc-lang.org/docs/bitc/bitc-origins.html
18:35:36 <lambdabot> Title: The Origins of the BitC Programming Language
18:35:58 <gwern> 'This sort of ``let's do a conservative, evaluable experiment'' approach makes project funding nearly impossible to obtain in academic circles, which may help to explain why computer scientists tend to step on each other's toes rather than standing on each other's shoulders. '
18:35:58 <luqui> LISP has syntax.  After all, lisp programs are not infinite...
18:36:31 <gwern> @remember JonathanShapiro This sort of "let's do a conservative, evaluable experiment" approach makes project funding nearly impossible to obtain in academic circles, which may help to explain why computer scientists tend to step on each other's toes rather than standing on each other's shoulders.
18:36:32 <lambdabot> Okay.
18:36:37 <gwern> @quote shoulders
18:36:38 <lambdabot> JonathanShapiro says: This sort of "let's do a conservative, evaluable experiment" approach makes project funding nearly impossible to obtain in academic circles, which may help to explain why
18:36:38 <lambdabot> computer scientists tend to step on each other's toes rather than standing on each other's shoulders.
18:37:18 * gwern notes quietly that there's a tense disagreement there - 'tend to step' doesn't parallel 'standing'
18:38:10 <luqui> minor type error
18:38:35 <ksf> classical confusion of cause and effect there.
18:38:37 <fynn> isn't it really awesome that creating your own operators in Haskell is much more elegant and completely non-brittle?
18:38:52 <gwern> well, it's not perfect
18:38:55 <fynn> I mean, most language I know that let you do this result in very brittle code.
18:39:11 <gwern> I still find '-4' to be strange, and I wonder why precedences are ints
18:39:29 <fynn> what else should they be?
18:39:35 <daf> gwern: isn't the alternative a partial ordering?
18:39:37 <dons> dcoutts: little experiment, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/statistics-fusion-0.1 (reimplementing hstats using uvector fusion)
18:39:38 <lambdabot> Title: HackageDB: statistics-fusion-0.1, http://tinyurl.com/667zvf
18:39:45 <ksf> fynn, dependencies.
18:39:50 <gwern> fynn: well, reals. or an approximation
18:39:56 <mauke> gwern: strings
18:40:02 <ksf> like * > +
18:40:08 <dons> hey, awesome, haddock generates uvector's docs now.
18:40:15 <fynn> possibly the reason for them being integers and discrete is to avoid confusing people too much.
18:40:22 <gwern> fynn: if '+' is 8, and '*' is 9, one should be able to insert something between '+' and '*' if that's semantically appropriate
18:40:25 <fynn> it's hard to remember precedence rules as it is.
18:40:45 <gwern> 8.5 would work. and suppose you want to add another betwene the new one and *? make it 8.75 and so on
18:40:58 <dolio> Stuff like * > + means you have to worry about cycles and such.
18:41:05 <ksf> * > # > + still holds.
18:41:11 <fynn> gwern: still, isn't Haskell the language with the best (maybe "only usable") implementation of "define your own operators"?
18:41:16 <gwern> mauke: how would strings work?
18:41:17 <ksf> well cycles are obviously errors.
18:41:32 <dons> ?users
18:41:32 <lambdabot> Maximum users seen in #haskell: 559, currently: 492 (88.0%), active: 23 (4.7%)
18:41:34 <gwern> fynn: I suspect the lispers would disagree. haskell is certainly better than your average bear I do admit
18:41:54 <mauke> gwern: I don't know, but the idea was mentioned in the perl6 design :-)
18:42:04 <fynn> gwern: you think lispers would argue that non-hygienic macros are not brittle?
18:42:09 <gwern> mauke: of course, I suppose
18:42:18 <dcoutts> dons: I'm interested what you think is gained from hitting mean etc with the INLINE hammer :-)
18:42:22 <gwern> fynn: I dunno. go ask some common lispers and see what they say
18:42:25 <dons> dcoutts: it is required.
18:42:27 <luqui> mauke, only briefly.
18:42:32 <dons> dcoutts: otherwise no fusion happens in the user's module.
18:42:37 <dcoutts> hmm
18:42:41 <dons> ghc 6.10
18:42:47 <luqui> mauke, every day
18:42:53 <dons> dcoutts: note i had to /remove/ inline from Data.Binary.Get to get it to inline...
18:42:54 <dcoutts> because the bodies look too big
18:43:00 <dons> maybe, yeah.
18:43:15 <fynn> gwern: I worked with Lisp a bit, and although the non-hygienic macros are powerful, I'm pretty sure they're more brittle than defining operators in Haskell.
18:43:33 <fynn> the breakage cases are much more subtle, and problematic once they occur.
18:43:38 <dcoutts> dons: hmm, do you know what was going on with get? phasing things? inlining too early?
18:43:46 <luqui> fynn, of course, because they are not extensional
18:43:46 <gwern> fynn: iirc, wouldn't a lisper hack the symbol table to define an operator?
18:44:03 <gwern> (man, am I hungry)
18:44:10 <luqui> lol
18:44:32 <ksf> (fullp fridge)
18:44:41 <luqui> any mechanism which can distinguish between two identical functions is going to be brittle
18:44:43 <fynn> hehe
18:45:13 <lispy> gwern: I thought it was 'hack the gibson' not symboltable
18:45:41 <mauke> .oO( what's the equivalent of %::=() in lisp? )
18:46:06 <dons> dcoutts: it wasn't respecting our inline stuff. not sure why.
18:46:43 <luqui> mauke, I have been out of perl for a while, but... that isn't legal, is it?
18:46:45 <fynn> gwern: (really not sure changing the symbol table in any way is going to give you all the stuff you can do with Haskell's custom operators)
18:46:56 <mauke> luqui: depends on your definition of "legal"
18:47:16 <luqui> mauke, okay, probably it will parse, but no matter what the context, it will always result in a runtime error
18:47:22 <mauke> nope
18:47:32 <mauke> % perl -wle '%::=(); print 42'
18:47:32 <mauke> 42
18:47:43 <ksf> .oO( does stripping a lisp program of identifiers produce interesting set-theoretic theorems? )
18:47:43 <luqui> oh geez.
18:47:50 <fynn> the Enterprise operator.
18:48:03 <mauke> luqui: but do it in a BEGIN block to trigger a segfault
18:48:03 <fynn> Perl 6 code is going to look like a Star Trek episode.
18:48:25 <luqui> oh that's a real =.  I was parsing "%::=" as the name of a hash
18:48:48 <luqui> i see, empty the top-level symbol table
18:48:55 <lispy> We call it operator NCC-1701?
18:50:01 <byorgey> omg my code typechecks!
18:50:08 * byorgey does the typechecking dance
18:50:09 <SubStack> congrats
18:50:09 <lispy> byorgey: yeah?
18:50:13 <mauke> ship it!
18:50:20 <lispy> byorgey: now, exlpain the significance
18:50:24 * byorgey hits the 'ship' button
18:50:27 <harblcat> Is the type 'IO a' really 'World -> (a, World)'?
18:50:32 <lispy> byorgey: what is your code?
18:50:35 <mauke> harblcat: no
18:50:41 <byorgey> well, I've just finished some major refactoring
18:50:50 <byorgey> I basically spent the past two hours fixing type errors
18:50:51 <lispy> harblcat: more like (a, World)
18:51:04 <byorgey> so I had to share my victory =)
18:51:14 <byorgey> this is my lambda-cube interpreter
18:51:30 <lispy> byorgey: tell me about it...I had some sessions on the darcs source were I'd spend a couple days making stuff type check with our GADTs :)
18:51:35 <luqui> harblcat, that depends on what you mean by "really"
18:51:41 <byorgey> hehe, sounds fun =)
18:51:46 <harblcat> mauke: I've been trying to get the 'a' out..
18:51:51 <lispy> where a day is defined as 12+ hoours of hacking :
18:51:52 <lispy> :)
18:51:54 <mauke> harblcat: why?
18:52:13 <luqui> harblcat, you can't, by design.  though you can use the a inside another IO action
18:52:14 * lispy is determined but perhaps slow
18:52:15 <Cale> harblcat: It's not *really* World -> (a,World)
18:52:31 <harblcat> mauke: So that I don't have a whole bunch of IO * functions...
18:52:38 <mauke> huh?
18:52:44 <harblcat> Working with random numbers is hard.
18:52:55 <mauke> if you use global state, yes
18:52:56 <luqui> harblcat, make them functions of an infinite list of random numbers
18:52:57 <mauke> or rather, no
18:53:03 <mauke> just use IO everywhere
18:53:04 <lispy> harblcat: well, you see, you have an inverted view of the world as most haskell beginners do
18:53:17 <Cale> harblcat: Inside of a do-block defining an IO action, you can write  v <- x  where x :: IO t, and then v :: t
18:53:23 <harblcat> lispy: I am a beginner, yes.
18:53:37 <Cale> harblcat: That v can then be passed on to a pure function.
18:53:40 <gwern> lispy: everyone knows that if you try to hack a gibson, you'll just wind up burning the chrome
18:53:41 * fynn just defined the shurikan operator: <+>
18:53:50 <harblcat> Cale: But then when I return v, it's IO v, anyway
18:53:51 <fynn> apropos "hacking the Gibson" that is.
18:53:51 <Cale> harblcat: and the result perhaps used for output later
18:53:55 <Cale> harblcat: right.
18:54:00 <luqui> > randoms (mkStdGen 42)
18:54:01 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
18:54:05 <lispy> harblcat: basically, you pull the value out while your in a do-block and use all your non IO functions on that value.  When you're done looking at the value, you use 'return' to put it back into IO :)
18:54:07 <luqui> > randoms (mkStdGen 42) :: [Double]
18:54:08 <lambdabot>   [0.11040701265689151,0.8453984927258916,0.30778213446209723,0.7813880826070...
18:54:16 <Cale> harblcat: Do something pure with the thing you got from the IO action, and then do some output
18:54:22 <byorgey> "Type mismatch: expected type A -> A, got type A -> A instead"  -- hmm... =P
18:54:28 <Cale> harblcat: At least, that's the general pattern.
18:54:31 * gwern goes and watches an Alan Kay presentation at TED
18:54:38 <Cale> harblcat: In the end, your 'main' is an IO action anyway.
18:54:52 <lispy> byorgey: oh, better do a recall on that ship :)
18:55:00 <byorgey> too late! ;)
18:55:19 <harblcat> Ah, so the value is pure while in the do block, but once it leaves, it's an IO value again?
18:55:19 <lispy> byorgey: at least your program doesn't allow buggy programs :)
18:55:31 <lispy> harblcat: yeah, in that regard IO is a wrapper
18:55:32 <Cale> harblcat: the do-block as a whole is an IO action.
18:55:46 <byorgey> lispy: I wouldn't be willing to put money on that...
18:55:46 <harblcat> I see. So I've got to think differently.
18:56:00 <luqui> harblcat, well.. it can only leave through the use of "return", which has type a -> IO a, which puts it back into the IO monad
18:56:02 <mauke> Think different!â¢
18:56:07 <Cale> 'leave'
18:56:10 <lispy> byorgey: obama won, we can do anything now.  Don't be so shy ;)
18:56:16 <byorgey> hehe
18:56:17 <Cale> I'm not clear on what 'leave' means here ;)
18:56:31 <lispy> ?faq Can Haskell elect an african american president to the US?
18:56:31 <lambdabot> The answer is: Yes! Haskell can do that.
18:56:41 <luqui> Cale, me neither.  I'm just trying to jump on his thought train....
18:56:44 <Cale> But you might pass v to a pure function.
18:56:55 <Cale> something like...
18:57:02 <Cale> let w = f v
18:57:21 <Cale> and then do some more actual I/O with the result of that...
18:57:24 <Cale> print w
18:57:49 <harblcat> Ah.
18:58:18 <harblcat> Well, someone said before, generating a list of randoms is not hard. I was just getting confused as to how I would use them.
18:58:24 <luqui> harblcat, but if the only IO you are doing most of the time is getting random numbers, you might like MonadRandom on hackage
18:58:47 <lispy> harblcat: now that we've said all that, there is one way to take a value out of IO but it's reserved for use by experts that understand it will eat kittens if used incorrectly
18:59:03 * luqui eats a kitten
18:59:16 <Cale> I think it's misleading to say "take a value out of IO"
18:59:19 <ksf> Assuming I completely abandon operational reasoning, can I still reason about big-O?
18:59:27 <Cale> A better way to say that is "run an IO action"
18:59:33 <harblcat> I was making a list of numbers, basically rands n, which would return IO [Int]... And sum doesn't work on IO [Int]
18:59:35 <luqui> ksf, VERY good question.
18:59:45 <Cale> harblcat: fmap sum does though.
18:59:53 <lispy> :t fmap sum
18:59:54 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f [a] -> f a
19:00:00 <luqui> ksf, I have been trying to answer it for myself for quite a while
19:00:03 <lispy> :t fmap sum :: IO Int
19:00:04 <lambdabot>     Couldn't match expected type `IO Int'
19:00:04 <lambdabot>            against inferred type `f [a] -> f a'
19:00:09 <Cale> harblcat: It gives you an IO Int
19:00:23 <Cale> :t fmap sum (replicateM 6 randomIO)
19:00:24 <lambdabot> forall a. (Random a, Num a) => IO a
19:00:29 <lispy> :t fmap sum :: IO [Int] -> IO Int
19:00:30 <lambdabot> IO [Int] -> IO Int
19:00:50 <gwern> (boy, Kay seems very tired in his talk. when I think about it, he must be in his 60s by now or something)
19:00:51 <Cale> harblcat: Of course, you could also write:
19:01:00 <idnar> :t fmap sum
19:01:01 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f [a] -> f a
19:01:07 <Cale> do xs <- myIOaction; return (sum xs)
19:01:29 <Cale> :t do xs <- replicateM 6 randomIO; return (sum xs)
19:01:31 <lambdabot> forall a. (Num a, Random a) => IO a
19:01:38 <ksf> How to be sure that map is really O(n) and not NP-hard?
19:01:48 <Cale> ksf: what?
19:02:01 <ksf> <ksf> Assuming I completely abandon operational reasoning, can I still reason about big-O?
19:02:10 <Cale> no, you can't.
19:02:24 <luqui> that's quite a conclusion to jump to
19:02:29 <Cale> If you're working in the land of denotational semantics, functions don't take any time at all.
19:02:33 <Cale> They're defined or they're not.
19:02:51 <gwern> yeah. evaluation strategies alone would mess things up
19:02:55 <luqui> but saying "no, you can't" I think is a shaky thing to extract from this
19:03:05 <ksf> yes, but they still have complexity.
19:03:14 <lispy> What complexity?
19:03:19 <lispy> we already know the answer
19:03:19 <luqui> why would there not be a different semantics which captures computational complexity as well
19:03:22 <Cale> You can add time to the picture, but it's not there in the denotational view.
19:03:31 <luqui> you cannot use scott semantics, but does that mean it can't be done?
19:03:43 <Cale> luqui: Oh, of course it can be done.
19:04:02 <Cale> Usually it's done via a particular operational semantics, but you could invent something else.
19:04:12 <lispy> Asking about the complexity of something given as denotational semantics, isn't that really just the complexity to verify the answer?
19:04:15 <luqui> yay, I like being able to invent things!
19:04:47 <Cale> lispy: I suppose you could look at it that way too, "jumping outside the system"
19:04:49 <harblcat> So I'm guessing that when someone is a haskell beginner, there are a lot of moments like these where one has to think differently, maybe learn something new?
19:04:54 <lispy> And so if we're only considering the time to verify the answer, that's the whole non-deterministic space right?
19:04:55 <Cale> harblcat: yes.
19:05:04 <Cale> harblcat: Treat it like learning to program again :)
19:05:44 <Cale> harblcat: This IO that you're doing, it's for managing random numbers?
19:06:00 <Cale> harblcat: You might instead find it more convenient to work with StdGens.
19:06:04 <ksf> Let's break this down: Is there a way to tell that map _cannot_ run in less than O(n)? It certainly _can_ be NP-hard if you e.g. use a compiler that targets malbolge.
19:06:48 <Cale> ksf: I don't see a way to make that question meaningful without introducing at least some notion of what it means to compute the result.
19:07:22 <Cale> I mean map might be O(1), and in fact, in Haskell, counting the time to reach WHNF, it is.
19:07:42 <lispy> there are people that study minimum algorithmic complexity, but those people still do so interms of operational semantics, right?
19:08:10 <ksf> yes, mmx makes addition O(1/4)
19:08:21 <Cale> O(1/4) = O(1)
19:08:27 <harblcat> Cale: StdGens?
19:08:32 <Cale> harblcat: Yes.
19:08:48 <Cale> harblcat: A StdGen value is essentially the state of a random number generator.
19:08:51 <ksf> not if you compare O(1/4 * n) and O(1 * n)
19:09:04 <dolio> O(n/4) = O(n)
19:09:10 <Cale> ksf: No, those are the same class as well.
19:09:46 <Cale> harblcat: You can get a random one (based on the clock) using newStdGen from IO
19:10:02 <harblcat> Cale: Well, I'm currently using gen <- getStdGen, and before returning a value I use newStdGen...
19:10:04 <ksf> well, actually I'm more interested in knowing the run-time cost than figuring out the concrete class.
19:10:11 <Cale> harblcat: You then pass that StdGen you get to whatever otherwise-pure function needs to generate (pseudo) random values
19:10:22 <harblcat> Cale: newStdGen returns a StdGen?
19:10:38 <hackage> Uploaded to hackage: statistics-fusion 0.1
19:10:38 <Cale> harblcat: yeah. getStdGen is totally superfluous, and I'd recommend avoiding it.
19:10:51 <Cale> harblcat: newStdGen is almost always what you really want.
19:10:59 <harblcat> Cale: Never thought of that, thanks! One less line of code.
19:11:41 <Cale> harblcat: Then you use functions like randomR to get a pseudorandom value from that StdGen, along with another StdGen, which should be used to get the next value.
19:12:11 <harblcat> Cale: I'm using randomRs, to get many at once.
19:12:19 <Cale> Right, that works too. :)
19:12:45 <Cale> You can also use split, to split a StdGen into two new ones (useful if you need to recurse down two branches of a tree, for instance)
19:12:47 <ksf> specifically, I'm more interested in what effects it has to my reasoning than in doing pen+paper calculations using it.
19:13:10 <ksf> s/no-grammar/grammar/
19:13:24 <Cale> heh
19:14:26 <Cale> Understanding the real-world cost of running a Haskell program is probably best done using profiling and a toy model of the operational semantics.
19:14:28 <harblcat> Cale: I'm guessing that splitting a StdGen is more efficient than making two new ones?
19:14:28 <ksf> or, put differently, I want you guys to beat the assembly out of my head.
19:14:38 <Cale> harblcat: Well, it's pure :)
19:14:56 <Cale> harblcat: Not just more efficient (actually I'm not sure if it is more efficient)
19:15:03 <Cale> :t split
19:15:05 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
19:15:41 <dolio> newStdGen calls split, I thought.
19:15:47 <Cale> ksf: Okay, I think what you really want is a way to evaluate Haskell code which gives you a real sense of how long it'll take to run.
19:15:48 <lispy> :t newStdGen
19:15:49 <lambdabot> IO StdGen
19:15:50 <dolio> It only get seeded with the time at the start of the program.
19:15:56 <dolio> And then splits from there.
19:16:19 <Cale> dolio: Oh, okay. None of that stuff works how I think it ought to, really.
19:16:43 <ksf> Nah, actually I want to apply my haskell experience to imperative languages more thoroughly.
19:16:51 <Cale> In my mind, getStdGen shouldn't exist at all, and newStdGen should read from the system entropy pool.
19:17:09 <Cale> ksf: Okay...
19:17:19 <keseldude> How long do you think this will take? let divisors n = [x | x<- [2..(n-1)], n `mod` x == 0]; isPrime n = if n < 2 then False else if (length (divisors n)) == 0 then True else False; t = [n | n <- [1..500000000], isPrime (2*n^2 - 1)] in length t
19:17:40 <lispy> keseldude: a metric minut
19:17:43 <lispy> +e
19:17:49 <dolio> do g <- getStdGen ; g' <- newStdGen ; return (split g, g') ==> ((1920670146 40692,1700912949 2147483398),1700912949 2147483398)
19:18:08 <juhp> is X11-extras obsolete?
19:18:30 <dolio> @src newStdGen
19:18:30 <lambdabot> Source not found.
19:19:35 <Cale> ksf: hmm...
19:20:06 <Cale> ksf: Well, at the very least, you know how to remove unnecessary state variables from things :)
19:20:08 <mauke> juhp: yes
19:20:53 <dolio> do g <- getStdGen ; g' <- newStdGen ; g'' <- getStdGen ; return (show (split g) == show (g'', g')) ==> True
19:21:11 <lispy> I find that getting better at haskell tends to make me a worse programmer in other languages.
19:21:23 <ksf> yes... there were days where i defined FP as putting as much side-effect free functions into a statement as possible.
19:21:25 <juhp> mauke: thanks - it would be nice if packages can be labelled old or something in hackage, like "Obsoleted by: X11 >= ..."
19:21:31 <Cale> keseldude: If I'm reading that correctly, I would expect the sun to burn out first.
19:21:39 <keseldude> :D
19:22:14 <Cale> at least it's not 2^n - 1
19:22:23 <mauke> learning haskell didn't affect my perl skills, but it ruined my ocaml
19:22:30 <keseldude> that would be ridiculous
19:22:41 <Axman6> "if (length (divisors n)) == 0 then True else  False" == "(length (divisors n)) == 0"
19:23:08 <keseldude> yeah, I wrote it really quickly a few minutes ago
19:23:29 <keseldude> I wasn't really thinking
19:23:45 <Cale> keseldude: Speeding that computation up so that it's more reasonable seems like it would involve quite a bit of number theory.
19:24:06 <keseldude> it's the most recent problem on Project Euler
19:24:30 <Axman6> keseldude: well, you'll need much more efficient algorithms than that
19:24:51 <Axman6> for one, isPrime only needs to check for divisors up to sqrt n
19:24:56 <keseldude> yeah, I was about to ask
19:25:10 <keseldude> I tried to do that, but I could never quite get it to go up to only floor(sqrt(n))
19:25:32 <Axman6> :t floor
19:25:33 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
19:25:42 <Axman6> :t sqrt
19:25:43 <lambdabot> forall a. (Floating a) => a -> a
19:25:46 <snk_kid> okay i'm youtuberfing the video of frag
19:25:54 <Axman6> i hate that >_<
19:25:56 <Cale> snk_kid: oh?
19:25:59 <keseldude> > [x | x <- [1..(floor(sqrt(12))], 12 `mod` x == 0]
19:25:59 <lispy> snk_kid: nice
19:26:00 <lambdabot>   <no location info>: parse error on input `]'
19:26:07 <snk_kid> Cale: earlier discussion
19:26:19 <snk_kid> Cale: no video of frag but while?
19:26:28 <snk_kid> i mean but why
19:27:04 <Cale> I would guess because it's easier to download and play frag for yourself than to make a screencast :P
19:27:38 <lispy> having a youtube video is nice advertising though
19:27:43 <snk_kid> Cale: not exactly on widows and not until more recently
19:27:44 <lispy> and documents what frag was like in 2008
19:28:04 <Cale> Is frag actually under any active development?
19:28:06 <snk_kid> sorry about spelling, 03:27 a.m.
19:28:39 <dons> Cale: no.
19:28:53 <Cale> It's a nice proof of concept, but it's somewhat hastily designed, and it's not really much of a game that you'd sit down and play for very long.
19:29:00 <dons> its a research prototype on building 3d games with reactive programming.
19:29:12 <Cale> It looks like some of Conal's recent work is headed in that direction.
19:29:25 <Cale> s/some/almost all of/
19:29:33 <snk_kid> Cale: is there something better to show?
19:29:41 <Cale> snk_kid: Not as a video.
19:29:55 <dons> monadius?
19:30:00 <dons> some of the other games on hackage?
19:30:06 <Cale> snk_kid: But Conal has the core of a nice FRP 3D library in place.
19:30:29 <lispy> IMO, frag should be on youtube
19:30:38 <lispy> There are soooo many video game videos on there.  Why not?
19:31:04 <snk_kid> dons: monadius is already up there
19:31:11 <Cale> snk_kid: Of course, some of the Japanese guys have been knocking out retro games with Haskell, which are pretty cool, but they're not 3D.
19:31:29 <snk_kid> Cale: i know, i was the one who linked to super nario ;)
19:31:35 <Cale> :)
19:32:12 <snk_kid> anyways it's to late you can't stop me now!
19:32:14 <Axman6> hooray, upgrading cabal was a lot easier than expected
19:32:16 <Cale> hehe
19:32:28 <Cale> I'm not arguing against putting a video up :)
19:32:46 <Cale> You asked why there wasn't already one there, and I tried to provide an explanation as to why that might be :)
19:33:31 <luite> is there a function does this?   f [id,(+1),(*2)] 2 = [2,3,4]   ?
19:33:42 <Cale> > sequence [id,(+1),(*2)] 2
19:33:43 <lambdabot>   [2,3,4]
19:34:00 <Axman6> :t sequence
19:34:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:34:02 <Cale> luite: That requires Control.Monad.Instances
19:34:11 <Cale> Here, m = e ->
19:34:13 <luite> ah, thanks, I thought it would be ap, but that didn't work
19:34:20 <idnar> @type ap
19:34:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:34:34 <Cale> well...
19:34:36 <mauke> > ap [id,(+1),(*2)] [2]
19:34:37 <lambdabot>   [2,3,4]
19:34:39 <Cale> yes
19:34:55 <luite> yes I already found that out :)
19:34:58 <Cale> So (ap .) . return
19:35:04 <Cale> er...
19:35:28 <Cale> points-free fail
19:35:31 <idnar> I guess the sequence example uses the (->r) monad, while the ap example uses the list monad
19:35:45 <Cale> yeah
19:35:49 <Cale> ((->) r)
19:35:54 <Cale> Or (r ->)
19:35:58 <idnar> er, yeah, that one
19:36:11 <lispy> monadius actually looks pretty cool
19:36:14 <Cale> I kinda wish we could actually write (r ->)
19:37:49 <lispy> hey, monadius devs, not everyone uses qwerty!
19:37:51 <Axman6> is it possible to write a pointfree id function?
19:38:03 <lispy> myid = id
19:38:08 <lispy> ;)
19:38:20 <mauke> I = SKK
19:38:26 <Axman6> with id only on the left side ;)
19:38:33 <mauke> :t ap const const
19:38:34 <lambdabot> forall a. a -> a
19:38:50 <mauke> :t fmap fix return
19:38:51 <lambdabot> forall a. a -> a
19:39:18 <mauke> :t head . (: [])
19:39:19 <lambdabot> forall a. a -> a
19:39:55 <Axman6> > (fmap fix return) 2
19:39:56 <lambdabot>   2
19:41:56 <lispy> Haskell for C Programmers: http://www.youtube.com/watch?v=PoPyMcD9lSE
19:42:01 <lambdabot> Title: YouTube - Haskell for C Programmers Video Supplement (Part I)
19:42:09 <lispy> Except the narrator calls it Haskall
19:42:38 <snk_kid> i pronouce it like pascal but with with a h
19:44:00 <dolio> It doesn't sound like Pascal.
19:44:07 <snk_kid> not pascal
19:44:17 <snk_kid> Pascal with a H :P
19:44:29 <dolio> That's still wrong. :)
19:44:53 <dolio> It's like Haskle.
19:45:12 <mauke> silly speakers of english
19:45:15 <dolio> If you take SPJ as a reference, at least.
19:45:35 <gwern> we can has skull?
19:45:36 <snk_kid> yeah i think i'm saying it the same way anyways
19:45:38 <geezusfreeek> rhymes with rascal
19:45:46 <Axman6> geezusfreeek: can has skull?
19:46:41 <Axman6> uh, gwern
19:46:42 <mwc> I've heard that SML's module system is more 'powerful' than Haskell98's modules + type classes. Do type families close the gap?
19:46:45 <Axman6> sorry geezusfreeek
19:47:30 <snk_kid> what the hell youtube >.<
19:47:49 <Cale> Hehe, the guy playing Super Nario Bros tries to get the hidden 1up, but clearly it's not there :)
19:49:08 <dolio> mwc: http://www.haskell.org/pipermail/haskell/2004-August/014463.html
19:49:14 <lispy> Cale: yeah, I thought that was cute too
19:49:27 <lambdabot> Title: [Haskell] Applicative translucent functors in Haskell
19:49:46 <mwc> dolio: thanks, been away from haskell for a few months
19:51:06 <lispy> heheh, this video about 'lambda list', the narrator says 'skim' instead of 'scheme'...I didn't realize these languges had such vague pronouncation rules :)
19:52:38 <snk_kid> http://uk.youtube.com/watch?v=0jYdu2u8gAU
19:52:39 <lambdabot> Title: YouTube - Frag - 3D FPS game written in Haskell
19:55:11 <Cale> snk_kid: hey, is that the standard map?
19:55:20 <rherrmann> snk_kid: too bad the video framerate doesn't keep up with the game
19:55:46 <snk_kid> sorry i couldn't find a decent capture software, if you got any recommendations
19:55:58 <rherrmann> snk_kid: well, at worst it will make people download it
19:56:17 <rherrmann> snk_kid: in order to see it at 60fps ;-)
19:56:46 <ksf> Maybe what I want is to stop reasoning about every part of a problem in a touring-complete way. That is, capture the minimal complexity of the system that is needed to evaluate each part.
19:56:55 <lispy> snk_kid: what did you use?
19:57:16 <snk_kid> Cale: yeah, i noticed it's from OpenArena so i'll download it tomorrow maybe and rip out some maps
19:57:25 <snk_kid> lispy: Camtasia
19:57:45 <jeffz> you could probably just modify the game to dump the frames to an avi
19:57:49 <ksf> What I _definitely_ should do is continuing reading A New kind of Science.
19:58:04 <ksf> s/reading/rereading/
19:58:16 <lispy> I think jeffz is write
19:58:18 <lispy> right*
19:58:18 <snk_kid> jeffz: not at 04:00 a.m. i'm not :)
19:58:23 <lispy> heh
19:59:31 <rherrmann> jeffz: afterall, is there a FragMonad or what ? lol
19:59:42 <dolio> It's an Arrow.
20:00:18 <ksf> There are question-mark fnords all over " That is, capture the minimal complexity of the system that is needed to evaluate each part."
20:00:35 <snk_kid> look at the first comment lol
20:00:45 <snk_kid> wow that video is terrible
20:02:20 <rherrmann> snk_kid: much better than nothing
20:07:24 <nofeardjb> grr i can't remember how to take in an arguement string
20:07:48 <mauke> take it like a man
20:07:54 <ksf> :t getArgs
20:07:55 <lambdabot> Not in scope: `getArgs'
20:08:00 <ksf> ah.
20:08:04 <dibblego> @type System.getArgs
20:08:04 <ksf> no System.IO
20:08:05 <lambdabot> IO [String]
20:08:08 <rherrmann> System.getArgs
20:08:23 <mauke> :t System.Environment.getArgs
20:08:24 <lambdabot> IO [String]
20:15:06 <nofeardjb> hehe thanks for all the replies
20:16:48 <dons> snk_kid: good work on the video.
20:17:26 <dons> snk_kid: but also, not worth engaging with comments on youtube :)
20:19:27 <snk_kid> :)
20:20:00 <snk_kid> time to sleep, good night/morning/afternoon
20:20:27 <nofeardjb> is this valid? "main = do x <- getArgs" and then nextline: "putStrLn x"
20:20:37 <mauke> nofeardjb: no
20:20:51 <mauke> x :: [String], putStrLn :: String -> IO ()
20:20:58 <nofeardjb> mauke: i can't remember how i was doing this yesterday lol
20:21:14 <nofeardjb> aaaaaaah
20:21:48 <mauke> :/aa2/aa3/aa;/aa9/aa1/aa5/h
20:22:22 <nofeardjb> :O
20:22:24 <ksf> I'm imagining a dialect of haskell that is mostly not touring-complete, but requires usage of a special monad to do such evil and hard-to-reason-about things.
20:22:27 <nofeardjb> mauke: nice
20:22:33 <ksf> For now, it seems to work quite well.
20:22:36 <mauke> nofeardjb: what are you trying to do?
20:23:26 <ksf> I figured that you mostly don't need it, so you shouldn't care about it.
20:23:28 <nofeardjb> mauke: one second
20:25:14 <nofeardjb> mauke: heh, well from my assignment i can't tell if this is supposed to be a stand alone executable of haskell or if he's going to test via hugs interpreter O_o so maybe i don't need to worry about I/O
20:27:08 <ksf> well it's always nice to have something like (infile:outfile:[]) <- getArgs and then do all the stuff instead of relaying on interact or such.
20:28:14 <nofeardjb> ksf: ya, i'm having a hard time learning the IO syntax for Haskell
20:28:44 <nofeardjb> i think i'll finish the nuts and bolts of the program and then see if i can write some sort of IO at the end, since i don't think its required for this assignment
20:28:44 <mauke> nofeardjb: there is no IO syntax :-)
20:28:48 <mauke> all you need is (>>=) and return
20:29:01 <nofeardjb> mauke: i'm not so good with words xD
20:30:14 <ksf> I hereby hypothesise that Big-O can be defined for denotational semantics that describe non-touring complete systems.
20:30:51 <mauke> Turing
20:30:59 <ksf> my bad.
20:31:14 <ksf> it's associated with "tour" and "round-trip" in my head.
20:31:33 <mauke> o_O
20:33:20 <ksf> Shortcutting the proof by abstract nonsense, I'd say that analysis becomes possible non-operationally 'cos I just defined away the halting problem.
20:34:28 <gwern> ksf: wait, what's bad about 'interact'?
20:34:34 <gwern> when it's usable, I love interact
20:34:45 <ksf> the shell redirection.
20:34:49 <ksf> I just don't like it.
20:35:10 <ksf> shouldn't be the only way to use a program.
20:35:16 <mauke> yes, it should
20:36:08 <ksf> ghc --make < Main.hs?
20:36:28 <mauke> that's different; you can actually pass multiple files to ghc
20:38:12 <ksf> well, taste cast aside, there are times when you don't have a shell to do all the handle bending for you.
20:39:46 <nofeardjb> wow the ackermann equation is fun recursion :)
20:39:51 <pumpkin_> yeah
20:39:52 <nofeardjb> er, algorithm
20:39:53 <pumpkin_> it's crazy
20:41:08 <ksf> Conjecture: If you can't tell how many beers you've had without looking at the near-empty six pack, you're also going to drink the rest of it.
20:41:21 <nofeardjb> ....lol
20:43:29 <nofeardjb> random ackermann reference: http://xkcd.com/207/
20:43:30 <lambdabot> Title: xkcd - A Webcomic - What xkcd Means
20:44:14 <askentasken> anyone met Jon Harrop?
20:44:52 <askentasken> Why is this guy such an ubertroll? I mean hardly an attitude that works in a community of people with strong logic skills. is he a real doctor btw?
20:45:10 <dibblego> askentasken, he is a fraud, ignore him
20:45:44 <gwern> askentasken: why? money
20:46:01 <dolio> Where are you that he's trolling?
20:46:27 <dons> let's not go down that rabbit hole.
20:46:47 <nofeardjb> sweet: ack 4 1 "ERROR - Control stack overflow"
20:47:09 <dons> is that hugs?
20:47:13 <nofeardjb> ya
20:47:17 <dons> nofeardjb: dude, gotta get yourself a real haskell :)
20:47:26 <dons> *==>* haskell.org/ghc
20:47:26 <nofeardjb> dons: oh i know
20:47:41 <nofeardjb> dons: we're required to use hugs for our work in this class, don't ask me why
20:47:46 <sw17ch> Is a malloc needed for each new bytestring created?
20:47:47 <dons> life must suck using hugs. not a strictness analsysis to be had.
20:47:56 <dons> nofeardjb: you could do it all in ghci / ghc , then port it back i guess.
20:48:05 <ksf> sw17ch, Mu.
20:48:06 <dons> but you should talk to the lecturer about using a modern haskell system.
20:48:16 <dons> sw17ch: nope.
20:48:22 <dons> sw17ch: it allocates on the haskell heap
20:48:24 <nofeardjb> dons: the whole class has suggested it lol
20:48:36 <sw17ch> dons: great! i was worried about that
20:48:42 <dons> i'd just use ghc anyway. unless he's trying ot make the language seem like a toy.. :/
20:48:53 <dons> its like using an interpreter for C in a C class ...
20:49:23 <nofeardjb> lol
20:49:24 <sw17ch> Has there been work on porting more of the windows API to Haskell?
20:49:35 <sw17ch> or are the parts not ported stupidly hard to implement?
20:49:55 <dons> doubt it. just not enough windows devs.
20:50:04 <ksf> bugs are generally not haskell-compatible.
20:50:07 <sw17ch> dons: i'm having issues porting Scurry to windows
20:50:15 <sw17ch> and i'm being forced to be non-elegant
20:50:26 <ksf> ksf :: a -> SCNR a
20:50:36 <andrewsw> hi.
20:50:41 <dons> hey andrewsw
20:50:47 <sw17ch> and if just a tad bit more of the Windows API was present... it would be easier... oh well
20:50:47 <andrewsw> hey dons.
20:51:17 <andrewsw> if map applies a function to a list, how do I apply a list of functions to a value returning the list of results?
20:51:30 <mauke> sequence
20:51:43 <andrewsw> >:t sequence
20:51:49 <sw17ch> :t sequence
20:51:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:52:02 <sw17ch> sequence [(+1),(+2)] 5
20:52:06 <sw17ch> > sequence [(+1),(+2)] 5
20:52:07 <lambdabot>   [6,7]
20:52:13 <andrewsw> ah, perfect!
20:52:16 <sw17ch> =)
20:52:47 <sjanssen> > map ($ 5) [(+1), (+2)] -- Prelude only
20:52:49 <lambdabot>   [6,7]
20:53:04 <andrewsw> hmmm... okay.
20:53:16 <andrewsw> I was thinking I'd need a lambda
20:53:21 <sjanssen> sw17ch's example requires an instance that is found in Control.Monad.Instances
20:53:29 <sjanssen> andrewsw: sure, you could use a lambda
20:53:43 <lispy> > map (id 5) [(+1), (+2)]
20:53:44 <lambdabot>       No instance for (Num ((a -> a) -> b))
20:53:44 <lambdabot>        arising from the literal `...
20:53:52 <sjanssen> > map (\f -> f 5) [(+1), (+2)]
20:53:53 <lambdabot>   [6,7]
20:53:57 <sw17ch> dons: Are the new ByteStrings allocated on the haskell heap capable of reusing old strings of the same size?
20:54:02 <sw17ch> without intervention?
20:54:08 <sjanssen> @pl \f -> f 5
20:54:09 <lambdabot> ($ 5)
20:54:09 <andrewsw> sjanssen: that's more up my alley
20:54:14 <dons> sw17ch: reusing?
20:54:32 <dons> as in, if you create a new string "foo" it'll be transparently not allocated, and instead point to a previous one?
20:54:45 <sw17ch> dons: I have a TChan of ByteStrings (packets) that are going to be approximately 1500 bytes each.
20:54:50 <sw17ch> Object reuse is all i'm going for
20:54:54 <sw17ch> not that it matters if it's raw
20:54:56 <sw17ch> and just bytes
20:54:58 <dons> you want to reuse the buffer?
20:55:38 <dons> you can reuse and copy buffers if you like. but i don't quite understand what you want to be reused.
20:55:41 <sw17ch> dons: well, i can't reuse the buffer, but is GHC capable of seeing something of the same size on it's heap that's marked for GC and is the same size/shape as what it's currently trying to allocate?
20:55:52 <sjanssen> sw17ch: umm, doesn't the garbage collector do this?
20:55:57 <dons> oh. just leave it to the GC
20:55:58 <sw17ch> sjanssen, that's wahti was getting at
20:56:01 <dons> its smart and efficient.
20:56:06 <sjanssen> sw17ch: why is it imperative to use the exact same buffers?
20:56:09 <sw17ch> Excellent, i didn't quite know how to ask that question
20:56:21 <dons> sjanssen: well, it won't even come up if he's using the GC anyway.
20:56:32 <sw17ch> sjanssen, it's not, but i'm going ot have millions of little allocations which are immediately freed
20:56:53 <sw17ch> and if the GC is smart about it, it'll be much faster, and i don't have to worry about optimizing it myself
20:57:05 <sjanssen> sw17ch: GHC's garbage collector is good at that
20:57:06 <sw17ch> (since no more than a few of these will exist together at the same time)
20:57:10 <sw17ch> marvelous
20:58:03 <dons> it'll be interesting to see how you go.
20:58:21 <sw17ch> dons: as soon as the windows port is working, i want to do a release on hackage
20:58:30 <dons> there are cheaper options than bytestrings (e.g. uvector-like strings), but for most scenarios i can think of ,bytestrings are perfect.
20:58:48 <dons> but wait for a problem before worrying about them.
20:58:58 <sw17ch> well, i just had to move my read/write functions to C, so all i'm really doing is passing CString's around
20:59:09 <dons> you had to move your read/write to C?
20:59:10 <sw17ch> the bytestrings with a few unsafe usages will be great for my purpose
20:59:25 <dons> yup. if you're using C, that's the only option really.
20:59:33 <sw17ch> dons: yeah... the TUN/TAP driver in windows can't be used as a file descriptor
20:59:39 <sw17ch> as far as i can tell
20:59:53 <sw17ch> so, i need to use the CreateFile and their awful Read/Write functions
20:59:57 <dons> ah i see.
21:00:07 <sw17ch> or find some goofy way to abstract out the HANDLE/Handle/Fd/FD differences...
21:00:25 <sw17ch> I have about 2 lines in linux which exploded to about 30 in windows
21:00:30 <dons> mm. Handle is the abstraction :)
21:00:34 <dons> but yeah, if you're monkeying around
21:00:42 <sw17ch> but i need descriptors :)
21:00:47 <dons> yup
21:00:49 <sw17ch> actually, that's not true
21:00:53 <sw17ch> what i'm given is a descriptor (by linux)
21:00:58 <sw17ch> and i'm given a handle by windows
21:01:00 <sw17ch> but it's a windows handle
21:01:12 <sw17ch> and i'm not aware of a way to turn a HANDLE (win) to a Handle (Haskell)
21:01:29 <dons> well, ghc does it somehow.
21:01:34 <dons> if you dig around the bottom of the base library
21:01:38 <sw17ch> dons: i've been trying to figure out how... :(
21:01:50 <sw17ch> I discovered GHC.Handle.fdToHandle (which isn't documented)
21:02:01 <sw17ch> which was *almost* what i wanted
21:03:45 * sw17ch wonders if any one knows for sure whether or not windows devices can be used as files
21:03:55 <sw17ch> with _read/_write?
21:04:34 <jeffz> sw17ch: possibly, there are some device names you can enumerate and access, can't remember much about it though
21:05:18 <sw17ch> I've been rooting around in the code for qemu/openvpn/tinc to figure out how they implement the windows read/write functionality for the TAP device... they all do it slightly differently and it's convoluted
21:05:56 <jeffz> ah, I thought you might have only meant filesystems
21:06:11 <sw17ch> jeffz: no :( i'm doing weird things
21:25:25 <roconnor> @seen conal
21:25:25 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
21:27:04 <roconnor> \msg conal I humbly suggest replacing Graphics.FieldTrip.Color with my lib to get gamma-correct compositing: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/colour
21:27:09 <lambdabot> Title: HackageDB: colour-1.0.0
21:27:14 <roconnor> @msg conal I humbly suggest replacing Graphics.FieldTrip.Color with my lib to get gamma-correct compositing: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/colour
21:27:15 <lambdabot> Not enough privileges
21:27:26 <roconnor> oh?
21:28:26 <dons> @tell ?
21:28:26 <lambdabot> Consider it noted.
21:28:45 <roconnor> oh right
21:28:49 <roconnor> @tell conal I humbly suggest replacing Graphics.FieldTrip.Color with my lib to get gamma-correct compositing: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/colour
21:28:50 <lambdabot> Consider it noted.
21:28:55 <roconnor> dons++
21:29:00 <sw17ch> What is the appropriate definition of a "Finalizer" and is it documented any where?
21:29:53 <sw17ch> well, i'm giving up for the night. good night all.
21:30:07 <jeffz> sw17ch: System.Mem.Weak describes them a little
21:30:26 <sw17ch> thanks jeffz
21:38:47 <roconnor> oh, I didn't know hackage builds on ghc 6.8 and 6.10
21:38:49 <solrize_> is there any operator (i guess it would be a type operator) with signature *->(*->*)  ?  that is, you give it a type and a function comes out
21:38:50 <roconnor> cool.
21:39:14 <roconnor> @type ReaderT
21:39:16 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
21:39:28 <roconnor> @kind ReaderT
21:39:29 <lambdabot> * -> (* -> *) -> * -> *
21:39:43 <solrize_> hmm
21:39:53 <roconnor> wait, * -> (* -> *)  is the same as * -> * -> *
21:40:06 <roconnor> solrize_: you are trying to trick us :)
21:40:07 <Cale> Either ;)
21:40:17 <andrewsw> yeah, its just parameterized, right?
21:40:19 <solrize_> doesn't seem right
21:40:20 <roconnor> @kind Eitehr
21:40:21 <lambdabot> Not in scope: type constructor or class `Eitehr'
21:40:23 <roconnor> @kind Either
21:40:24 <lambdabot> * -> * -> *
21:40:30 <Cale> Or (->)
21:40:33 <Cale> Or (,)
21:40:34 <solrize_> i'm thinking more in terms of a generic function
21:40:35 <dibblego> @kind (,)
21:40:37 <lambdabot> * -> * -> *
21:40:45 <dolio> Except (->) has a much more insidious kind.
21:41:03 <dolio> (In GHC)
21:41:11 <solrize_> :kind (->)
21:41:19 <Cale> Not that insidious, it's just that if you account for unboxed stuff, it gets slightly more complicated.
21:41:31 <dolio> :k (->)
21:41:32 <lambdabot> ?? -> ? -> *
21:41:44 <solrize_> :k (+)
21:41:45 <lambdabot> Not in scope: type variable `+'
21:41:53 <solrize_> :k State
21:41:54 <lambdabot> * -> * -> *
21:42:01 <Cale> (+) doesn't have a kind, but its type has kind *
21:42:06 <solrize_> right
21:43:00 <solrize_> i want something like a generic function constructor, e.g. "showfunc Integer" gives back the show function for integers
21:43:14 <solrize_> "showfunc (Maybe Int)" similarly
21:43:39 <Cale> You mean, specialisation?
21:43:51 <Cale> :t show :: Integer -> String
21:43:52 <lambdabot> Integer -> String
21:43:53 <solrize_> or more precisely i'm trying to figure out if this is a reasonable way to describe the difference between genericity and polymorphism
21:44:31 <Cale> :t show `asTypeOf` (undefined :: Integer -> String)
21:44:32 <solrize_> i think not just specializing, but the ability to do something like "deriving Show", which reflects on the structure of the type being defined
21:44:32 <lambdabot> Integer -> String
21:45:20 <Cale> Oh, so your showFunc would actually construct the function from the structure of the type?
21:45:25 <solrize_> yeah
21:45:45 <solrize_> and that's always done with external packages like drift, syb, etc
21:45:59 <solrize_> so that capability is not directly in the language
21:46:03 <Cale> Well, you could write it directly in Generic Haskell.
21:46:22 <Cale> syb is a library written in Haskell with a few extensions...
21:46:26 <solrize_> but my first question was whether there was anything at all with that signature, and the answer is yes, it's the same as *->*->* which is a vanilla type constructor
21:46:40 <dolio> syb isn't a preprocessor or anything.
21:47:16 <solrize_> syb uses a compiler hack that allows reflection on types, right?
21:47:32 <dolio> It uses automatic deriving for the Data and Typeable typeclasses.
21:47:32 <Cale> Uh, not really.
21:47:37 <solrize_> hmm
21:47:44 <dolio> That's the only compiler addition.
21:48:20 <solrize_> ic
21:48:28 <Cale> In order to be sound, those typeclasses really should *only* be derivable... at least Typeable.
21:48:43 <Cale> :t gshow
21:48:44 <lambdabot> forall a. (Data a) => a -> String
21:48:53 <solrize_> the wikipedia article about generics is really a mess and i don't see a way to capture the concept
21:49:00 <Cale> There's the generalised version of show which you wanted ;)
21:49:14 <solrize_> hmm
21:49:15 <Cale> gshow [1..10]
21:49:16 <Cale> > gshow [1..10]
21:49:17 <lambdabot>   /tmp/3097833299487768762:70:44: Not in scope: `gshow'
21:49:23 <Cale> oh, not in scope
21:49:51 <sjanssen> @type gfoldl
21:49:52 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall a1 b. (Data a1) => c (a1 -> b) -> a1 -> c b) -> (forall g. g -> c g) -> a -> c a
21:49:52 <Cale> "((:) (1) ((:) (2) ((:) (3) ((:) (4) ((:) (5) ((:) (6) ((:) (7) ((:) (8) ((:) (9) ((:) (10) ([])))))))))))"
21:49:54 <solrize_> there's something hacking about syb that i haven't wrapped my head around
21:50:07 <sjanssen> dolio: it also uses higher ranked types
21:50:08 <Cale> is the result... a little suboptimal, but what are you going to do? :)
21:50:17 <dolio> Ah, yeah, true.
21:50:48 <solrize_> hacking->hackish
21:51:10 <dolio> Well, it definitely has its problems.
21:51:13 <_roconnor> solrize_: syb is a big hack
21:51:14 <Cale> I tend to think of the approach taken by Generic Haskell as being a lot prettier.
21:51:51 <Cale> But I'm not really an expert on this stuff, and it's not clear to me what the differences with regard to expressiveness are.
21:52:13 <solrize_> the whole point of the paradise benchmark seems to be to escape the type system and turn haskell into lisp
21:52:26 <solrize_> so if generic haskell can do the same thing, it has the same disease
21:52:29 <solrize_> unless i'm missing something
21:53:00 <dolio> Paradise benchmark?
21:53:02 <Cale> Well, no, it's giving an appropriate type to functions which act on all algebraic types.
21:53:53 <solrize_> dolio, the paradise benchmark is the one that recursively crawls a datatype for the org chart of a corporation, finds all the people in it, and gives them all a raise
21:54:08 <dolio> Ah.
21:54:12 <solrize_> described in the syb paper
21:54:25 <Cale> http://www.cs.uu.nl/research/projects/generic-haskell/jandewit.pdf
21:54:28 <dolio> Heh, I guess it's been a while since I read that. :)
21:54:35 <lambdabot> Title: A technical overview of Generic H A SKELL, http://tinyurl.com/5rwlm8
21:55:44 <Cale> solrize_: If you want, typeclasses are "more hackish" in this regard, as definitions for various types can in principle be completely unrelated.
21:55:46 <roconnor> why not use traversable?
21:55:57 <roconnor> or map even
21:56:47 <dolio> roconnor: Presumably, the org chart is an opaque algebraic datatype, not some parameterized type that would work with traversable, etc.
21:56:52 <roconnor> Cale: not completely.  They have the sameish typesignature.
21:56:56 <Cale> roconnor: The idea is that you have some complicated bunch of nested datatypes, which we don't want to assume too much about, and you want to find all the Person-typed values in those, and map a function over them
21:57:31 <roconnor> Cale: that's a dumb idea :)
21:57:48 <roconnor> I still say use map
21:57:49 <Cale> roconnor: Well, it's a common sort of problem.
21:58:01 <Cale> roconnor: The type might not even be a functor.
21:58:29 <roconnor> ok
21:58:31 <Cale> It might be an unparametrised datatype.
21:58:51 <Cale> and the idea is that we want to recurse over the structure of the type
21:59:11 <roconnor> <Cale> It might be an unparametrised datatype.
21:59:13 <roconnor> there's your problem
21:59:24 <roconnor> I should stop commenting
21:59:39 <roconnor> and reread data types a la carte
21:59:49 <Cale> roconnor: Well, another example is provided by Read and Show
22:00:02 <Cale> We have machinery in the compiler for deriving instances of those.
22:00:18 <roconnor> it's true.  We need more generic deriving stuff
22:00:20 <Cale> Mainly because we cannot write the appropriate generic functions once and for all.
22:01:13 <roconnor> is that really the case, or is it because we use '|' and ' ' in our ADTs instead of "Either" and "(,)"?
22:01:21 <Cale> another good one to read (which I think provides a cleaner view of generic programming) is the paper I linked to
22:01:59 <dolio> solrize_: Generally, I'd say a generic function works for many types by inspecting the particular type it's used on, and tailoring what it does to that type somehow, whereas a (parametric) polymorphic function works on many types by not needing any information whatsoever about those types.
22:02:09 <dolio> At least, in an ad-hoc, hand-wavey kind of way.
22:02:10 <paczesiowa> there was nice paper this year that compared different generic libs
22:02:30 <solrize_> dolio, yeah, that's what i would say too
22:02:47 <ThisIsSarahPalin> i'm sarah palin!!!!!!!!!!!!!
22:03:03 <roconnor> @ops
22:03:04 <lambdabot> Maybe you meant: docs oeis pl
22:03:12 --- mode: ChanServ set +o Cale
22:03:17 --- mode: Cale set +b *!*@syru217-183.syr.edu
22:03:22 --- kick: ThisIsSarahPalin was kicked by Cale (Cale)
22:05:17 <nofeardjb> I'm parah salin?
22:05:39 <Taejo> why does adding instance declarations to my program slow it down even if I don't use the instances? (GHC 6.8.2)
22:07:41 <solrize_> yeah i may have seen that paper
22:09:42 <Adamant> nofeardjb: I'm Ron Burgundy
22:10:38 <hackage> Uploaded to hackage: utf8-prelude 0.1.5
22:10:38 <hackage> Uploaded to hackage: ehaskell 0.5
22:13:28 <nofeardjb> Adamant: you forgot the question mark
22:13:40 <Adamant> nofeardjb: so I did
22:13:40 <nofeardjb> Adamant: I'm Ron Burgundy?
22:13:50 <nofeardjb> Adamant: :)
22:14:00 <Adamant> hi Ron!
22:14:10 <Adamant> :)~
23:08:17 <jinjing> @bot
23:08:17 <lambdabot> :)
23:10:39 <hackage> Uploaded to hackage: hake 0.9.5
23:10:59 <ddarius> @hackage hake
23:10:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hake
23:17:24 <noZone> > sum [4 / fromInteger n * if (n + 1) `mod` 4 == 0 then -1 else 1 | n <- [1,3..99999]]
23:17:26 <lambdabot>   3.1415726535897814
23:18:23 <Axman6> o.O
23:18:33 <ivanm> anyone know when we can expect a version of hxt that works with 6.10?
23:18:49 <lispy> ivanm: what is broken?
23:18:57 <lispy> ivanm: if it's just exceptions, you can use base3
23:19:07 <lispy> ivanm: if it's GADTs, its more work but there are rules
23:19:21 <ivanm> the Arrow syntax
23:19:30 <ivanm> and I forgot about base 3...
23:19:43 <ivanm> how do you specifically require base-3 support again?
23:20:50 <vegai> > 355/113
23:20:52 <lambdabot>   3.1415929203539825
23:21:24 <binrapt> > pi
23:21:25 <lambdabot>   3.141592653589793
23:21:27 <binrapt> Betterer
23:21:39 <Axman6> > showCReal 200 pi
23:21:40 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
23:21:45 <Axman6> bestest
23:23:50 <ivanm> Axman6: no it isn't
23:23:54 <ivanm> > showCReal 201 pi
23:23:56 <lambdabot>       Ambiguous occurrence `pi'
23:23:56 <lambdabot>      It could refer to either `Prelude.pi', i...
23:24:10 <Axman6> > showCReal 202 pi -- bestestest
23:24:11 <lambdabot>       Ambiguous occurrence `pi'
23:24:11 <lambdabot>      It could refer to either `Prelude.pi', i...
23:24:11 <ivanm> :o how come lambdabot didn't complain to you? :o
23:24:18 <ivanm> > showCReal 200 pi
23:24:19 <lambdabot>       Ambiguous occurrence `pi'
23:24:19 <lambdabot>      It could refer to either `Prelude.pi', i...
23:24:27 <ivanm> hmmm..... what just happened there?
23:24:33 <Axman6> eh?
23:24:34 <ivanm> @hoogle pi
23:24:35 <lambdabot> Prelude pi :: Floating a => a
23:24:35 <lambdabot> Data.Fixed type Pico = Fixed E12
23:24:35 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
23:24:48 <dolio> @undefine
23:24:49 <Axman6> > showCReal 202 CReal.pi -- bestestest
23:24:50 <lambdabot>       Failed to load interface for `CReal':
23:24:50 <lambdabot>        Use -v to see a list of th...
23:24:55 <ivanm> Axman6: I tried repeating what you did above, and lambdabot doesn't seem to work anymore :s
23:25:00 <Axman6> > showCReal 202 Data.Numeric.CReal.pi -- bestestest
23:25:01 <lambdabot>       Failed to load interface for `Data.Numeric.CReal':
23:25:01 <lambdabot>        Use -v to see...
23:25:07 <ivanm> heh
23:25:07 <dolio> > showCReal 202 pi
23:25:08 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
23:25:24 <Axman6> > showCReal 202 (pi :: CReal) -- bestestest
23:25:25 <ivanm> dolio: what, someone did @let pi = ?
23:25:25 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
23:25:31 <dolio> I guess.
23:25:36 <Axman6> ha
23:25:42 <ivanm> Axman6: you can always use more digits...
23:25:53 <Axman6> interesting, so @lets are cross channel?
23:26:10 <Axman6> @let (+) = (-)
23:26:10 <lambdabot>  Defined.
23:26:12 <ivanm> static bot ;-)
23:26:14 <ivanm> @slap Axman6
23:26:15 * lambdabot places her fist firmly on Axman6's jaw
23:26:16 <Axman6> > 1 + 3
23:26:17 <lambdabot>       Ambiguous occurrence `+'
23:26:17 <lambdabot>      It could refer to either `Prelude.+', imp...
23:26:17 <vegai> Sorry, guys :)
23:26:20 <Axman6> dang
23:26:22 <ivanm> heh
23:26:24 <ivanm> @undefine
23:26:26 <vegai> I had to
23:26:27 <ivanm> > 1 + 3
23:26:29 <lambdabot>   4
23:26:42 <ivanm> vegai: did you _really_ have to? or did you just _want_ to?
23:27:00 <Axman6> > pi :: CReal
23:27:01 <lambdabot>   3.1415926535897932384626433832795028841972
23:29:12 <MarcWeber> nominolo: ping
23:29:21 <ivanm> http://www.physics.uq.edu.au/people/gilmore/humour/the-pi-song/
23:29:23 <lambdabot> Title: Joel Gilmoreâs Home Â» The Pi Song
23:29:28 <vegai> ivanm: it seems my free will is limited
23:29:38 <ivanm> heh
23:32:58 <lispy> CReal?
23:36:53 <Taejo> is it expected behaviour for GHC (or a known bug) that instance declarations cause slowdowns even if the instances aren't used?
23:37:49 <sjanssen> @hackage numbers
23:37:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
23:38:15 <sjanssen> lispy: an arbitrary precision number
23:38:39 <sjanssen> Taejo: slow downs in the produced code?  Seems strange
23:38:55 <Taejo> sjanssen: indeed it does
23:39:43 <sjanssen> Taejo: are you sure the instances aren't used?  Perhaps you're working with overlapping instances?
23:40:48 <lispy> did it warn orphan?
23:40:59 <Taejo> lispy: no warnings
23:41:48 <Taejo> sjanssen: I didn't allow overlapping instances
23:42:20 <sjanssen> Taejo: are you absolutely certain this is what is happening?
23:42:21 <Taejo> http://hpaste.org/11909
23:42:55 <Taejo> sjanssen: that code runs in 1.660 seconds
23:43:29 <Taejo> if I comment out the instances it takes 1.212s
23:44:21 <Taejo> and if I comment out the Applicative but leave the Functor instance, it runs in 1.292s
23:44:28 <sjanssen> Taejo: which flags are you using to compile?
23:44:39 <Taejo> -funbox-strict-fields -O2
23:45:06 <sjanssen> -funbox-strict-fields won't do anything on this code, but that's no problem
23:46:24 <sjanssen> Taejo: I can't reproduce that here
23:46:37 <Taejo> sjanssen: are you using GHC 6.10?
23:46:47 <sjanssen> 6.8
23:46:54 <Taejo> ok, I'm using 6.8.2
23:47:05 <sjanssen> same here
23:47:21 <sjanssen> I bet you forgot to uncomment "(/) <$> sumF <*> (fromIntegral <$> lengthF)" in the instances version
23:48:09 <Taejo> sjanssen: it's commented out in both -- that's the point
23:48:33 <Taejo> if the instance was *used* I could understand (though it shouldn't use a dictionary anyway)
23:48:35 <sjanssen> hmm, strange
23:48:41 <sjanssen> I'm actually seeing it now
23:48:48 <ivanm> sjanssen: havent' you wanted to upgrade yet?
23:48:56 <sjanssen> ivanm: I don't really care
23:49:08 <ivanm> heh
23:49:53 <Taejo> the instances version allocates 1,402,757,012 bytes; without the instances, only 880,892,088 bytes
23:50:04 <sjanssen> Taejo: I think the optimizer gets a certain amount of "time" per module, your instances (and other code) must be complicated enough to hit that limit
23:50:23 <Taejo> hmm, interesting
23:50:52 <sjanssen> yeah, try sticking in undefined stubs for each class function
23:52:04 <Taejo> sjanssen: that brings it down to the same time and allocation as the no-instances version
23:52:05 <sjanssen> oh, actually I bet it is inlining
23:52:48 <sjanssen> yep
23:53:12 <Taejo> sjanssen: is there an option to allow the optimizer more time/passes?
23:53:13 <sjanssen> Taejo: stick INLINE pragmas on both and after
23:53:26 <sjanssen> Taejo: I was wrong about the passes thing
23:54:05 <Taejo> sjanssen: is it just {-# INLINE #-} ?
23:54:12 <sjanssen> {-# INLINE both #-}
23:55:20 <noZone> > head [x | a <-[1..9], b <-[0..9], c <-[0..9], d <-[0..9], let x = (1000*a + 100*b + 10*c + d), x*4 == (1000*d + 100*c + 10*b + a)]
23:55:21 <lambdabot>   2178
23:56:11 <Taejo> sjanssen: that seems to fix it
23:56:55 <sjanssen> Taejo: note that <*> uses 'both', as does 'bothWith', which is indirectly used by main
23:57:31 <Taejo> yeah
23:57:48 <sjanssen> when there is only one use of both, GHC inlines it.  When there are two uses of both, GHC doesn't
23:58:02 <Taejo> sjanssen: aah
