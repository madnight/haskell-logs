00:00:09 <mmorrow> someone needs to write a LOLCODE interp..
00:01:54 <ksf> solrize, in other words, I'm trying to figure out how reflection differs from a turing equivalent system computing itself
00:02:31 <mmorrow> ksf: i'd love to know the answer to that as well
00:02:45 <olsner> turing complete optical simulations?
00:03:07 <mmorrow> hall of mirrors, etc.
00:03:25 <solrize> hmm  i dunno the definitions of what you're asking then.  does reflection just mean the ability to introspect on the structure of a type?
00:03:28 <ksf> ...xeroxing your mirror and ending up with a second xerox, yes.
00:03:45 <ksf> http://p-cos.net/documents/s32008.pdf
00:03:50 <lambdabot> Title: Reflection for the Masses
00:03:54 <ksf> nah, also the ability to mess with apply.
00:04:00 <lispy> ksf: well, I'd like to know why general recursion is a logical absurdity, I mean (a -> a) -> a?  C'mon!
00:04:01 <olsner> ksf: you mean it won't print a mirror!? *chock*
00:04:14 <ksf> like a graph that's specifying how it is reduced.
00:04:16 <mmorrow> solrize: i believe he means in the sense of a metacircular interpreter
00:04:45 <mmorrow> an interpreter that's interpreting itself
00:05:21 <ksf> mmorrow, exactly.
00:05:25 <mmorrow> then you pull the rug out and it just floats there like the cheshire cat
00:05:56 <solrize> yah, iirc that is a theorem, a non-turing complete language cannot implement its own interpreter
00:06:08 <pumpkin_> hmm
00:06:41 <olsner> solrize: meaning if it *can* implement its own interpreter it's necessarily turing-complete?
00:06:43 <ksf> that's why it'd be cool if it would just ship infinitely many of them as primitive.
00:06:54 <solrize> olsner, right
00:07:15 <mmorrow> i'd love to get a haskell metacirc interp working
00:07:18 <pumpkin_> so I can't recognize regular expressions with a regular expression?
00:07:23 <pumpkin_> or is that not what you mean?
00:07:28 <olsner> that's a much cooler way to prove something turing complete than having to build an interpreter for *another* language
00:07:28 <lispy> That could certainly motivate the reason bother with a UTM
00:07:43 <solrize> pumpkin_ hmm
00:07:53 <pumpkin_> I mean pure regular expressions
00:08:06 <pumpkin_> some simple representation of them as a string
00:08:25 <olsner> hmm, that'd rather be that there's no regular expression matching a regexp+input that matches
00:08:42 <solrize> i think there are some requirements on the language and regexes are not powerful enough.
00:08:47 <pumpkin_> olsner: ah, makes sense
00:08:56 <solrize> ti'm remembering turner's paper on total funcitonal programming
00:09:25 <solrize> http://www.jucs.org/jucs_10_7/total_functional_programming
00:09:31 <lambdabot> Title: (D. A. Turner) Total Functional Programming
00:09:42 <ksf> I'm reading http://www.cs.kent.ac.uk/people/staff/dat/miranda/ctfp.pdf right now.
00:09:55 <lambdabot> Title: Church’s Thesis and Functional Programming
00:10:46 <mmorrow> pumpkin_: it'd be like a regex that can parse and interpret another regex it gets as input and then match patterns that input regex encodes in a string it also takes as input
00:10:47 <olsner> solrize: you have any references for that theorem btw?
00:11:18 <pumpkin_> mmorrow: yeah
00:12:21 <ksf> I'm also bothered by the excluded middle, and that it isn't obvious in lambda calculus.
00:12:22 <mmorrow> i've heard that pcre regexes are turing complete, but i'm not sure what feature they have makes them so
00:12:28 <solrize> olsner, i remember if from the turner paper whose url i just pasted
00:12:42 <ksf> I kind of think it should be clear nonsense and not hidden below layers of abstraction.
00:12:43 <olsner> oh, that's simple to prove impossible... whatever interpreter regexp you have, compiled in into a DFA of some number of states, you can always give it an input regexp that requires more DFA states
00:13:03 <mmorrow> so i guess that means you could write a metacircular pcre regex interpreter
00:13:13 <pumpkin_> mmorrow: there are languages they can't recognize, but the backreferences are what make them more powerful than pure regexes
00:13:39 <mmorrow> but the horrors that would entail would be anyone's guess..
00:13:51 <solrize> certainly you can't write a regexp that recognizes an arbitrary other regexp on arbitrary input.  i thought the question was whether you could code regexes in a way that they could be recognized by a regex
00:13:55 <ksf> does that make them turing-incomplete in essence or just by bad luck?
00:14:12 <mmorrow> pumpkin_: interesting. i thought someone in here said pcre regexes are /turing complete/?
00:14:15 <solrize> i dunno if regexes with backreferences are turing complete
00:14:17 <pumpkin_> mmorrow: I was trying to find papers on them, but there doesn't seem to be much formal research on where exactly the extended regex falls
00:14:26 <BMeph> mmorrow: Hm? Oh, thanks, I'll check it out. Meanwhile bed Calls... :)
00:14:29 <solrize> theyre just not regexes in the traditoinal sense, they can't be recognized by dfa's
00:14:34 <mmorrow> hmm
00:14:37 <ksf> <olsner> solrize: meaning if it *can* implement its own interpreter it's necessarily turing-complete?
00:14:39 <mmorrow> BMeph: cool. night
00:14:50 <pumpkin_> mmorrow: let me see if I can find the paper that worked on it... they came up with a modified pumping lemma for "extended regular" languages to show that certain languages aren't in them
00:15:08 <mmorrow> interesting
00:16:07 <mmorrow> but if pcre regexes are turing complete, one could program arbitrary things in them..
00:16:38 <mmorrow> like a chess engine or a webbrowser or a metacircular regex interp..
00:16:49 <pumpkin_> here's an extended abstract on it
00:16:49 <pumpkin_> http://hal.archives-ouvertes.fr/docs/00/17/60/43/PDF/notes_on_extended_regexp.pdf
00:16:54 <lambdabot> Title: On extended regular expressions, http://tinyurl.com/6kjyol
00:17:06 <mmorrow> cool
00:17:10 <pumpkin_> they don't really form a formal language
00:17:15 <olsner> it would be bad if pcre's didn't have guaranteed termination
00:17:17 <pumpkin_> they show that the language isn't closed under intersection
00:17:54 * ksf tries not to think of malbolge and whether or not writing a compiler that can compile every turing-program to malbolge might involve solving the halting problem
00:18:07 <pumpkin_> ksf: solving it? :o
00:18:45 <pumpkin_> I thought we agreed it should be called halting paradox earlier? :P
00:19:09 <solrize> that paper says pcre recognition is np-complete, i.e. in NP and therefore decidable
00:19:34 <ksf> http://en.wikipedia.org/wiki/Malbolge
00:19:36 <lambdabot> Title: Malbolge - Wikipedia, the free encyclopedia
00:19:40 <ksf> have a look and you'll see what i mean.
00:19:40 <JackpotManie_> hello guys  thats a gamelink pls visit the page    http://www.pennergame.de/change_please/4476982/     thx
00:19:43 <lambdabot> Title: Pennergame
00:19:44 <olsner> pumpkin_: nah, the halting problem is just not solved yet... ghc 6.12 will be able to solve it, they say
00:19:49 <pumpkin_> yeah, I've come across malbolge :)
00:20:13 <pumpkin_> ksf: just cause it's crypto disguised as a programming language doesn't mean it can resolve a paradox though :P
00:20:17 <pumpkin_> olsner: oh, I can't wait :)
00:20:55 <JackpotManie_> more user  http://www.pennergame.de/change_please/4476982/     thx
00:20:57 <lambdabot> Title: Pennergame
00:21:04 <JackpotManie_> can you?
00:21:11 <pumpkin_> JackpotManie_: ugh
00:21:29 <JackpotManie_> what is ugh?
00:21:38 <olsner> pumpkin_: yeah, kind of embarassing no haskell compiler's implemented it yet though... the FAQ does say haskell can do it
00:21:43 <pumpkin_> JackpotManie_: you ever hear the term "pyramid scheme"? :P
00:22:00 <pumpkin_> I don't read german but it looks like one
00:22:07 <JackpotManie_> understand sorry im stupid guy you know
00:22:19 <JackpotManie_> i speek german
00:23:11 --- mode: ChanServ set +o sjanssen
00:23:17 <sjanssen> JackpotManie_: are you here to learn Haskell?
00:23:25 * pumpkin_ cowers
00:23:30 <JackpotManie_> yes and blowjob
00:23:33 <pumpkin> o.O
00:23:39 --- mode: sjanssen set +b *!*=JackpotM@*.187-66-87.adsl-dyn.isp.belgacom.be
00:23:39 --- kick: JackpotManie_ was kicked by sjanssen (sjanssen)
00:23:50 --- mode: ChanServ set -o sjanssen
00:24:02 <pumpkin> that's gotta be the first time I've seen someone be kicked from here
00:24:11 <sjanssen> pumpkin: it happens very rarely
00:24:19 <ksf> pumpkin_, my point is that even if you've got a turing machine available, you might not be able to run every program on it as using the machine at all as you'd have to solve the halting problem to get the tape to advance to a spot you want it to advance to.
00:24:21 <sjanssen> we get the occasional troll or spammer
00:24:22 <mlesniak> Is this a sign that haskell becomes popular? ;)
00:24:31 <sjanssen> @users
00:24:31 <lambdabot> Maximum users seen in #haskell: 518, currently: 488 (94.2%), active: 13 (2.7%)
00:24:59 <mlesniak> Does lambdabot keep any statistics about kicking and/or banning?
00:25:04 <sjanssen> no
00:25:07 <pumpkin> sjanssen: I've been amazed at how different the atmosphere is in here, compared to every other public IRC channel I've ever been in, glad to see we're not in a parallel universe after all
00:26:15 <pumpkin> ksf: if your language doesn't cover all of the potential of a turing machine (and is closed) I'd assume the language isn't turing equivalent? and thus you'd be saying that for some sub-construct of a turing machine you can solve the halting problem? or did I misread you?
00:26:56 <pumpkin> my vocabulary has really gone down the drain
00:27:14 <mmorrow> here's a scheme metacircular interp that interprets itself forever (i can't remeber where i got this code from and couldn't find it on a quick google search)  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=508#a508
00:28:25 * sjanssen is amazed JackpotManie_ hasn't been removed from the server yet
00:28:36 <pumpkin> is he spamming other channels too?
00:28:50 <sjanssen> judging from his /whois, probably
00:29:05 <mlesniak> Anyone knows about a paper which gives a good overview of the implementation of functional programming languages? I've heard about a K(?)-Machine, but the only paper I've found was in french. SPJ's book is a little to detailed for an overview.
00:29:05 <pumpkin> if he's spamming #freenode, he'll probably be gone soon :)
00:29:10 <ksf> he's spamming for hits that get him points in that strategy game he linked.
00:29:20 <mlesniak> ...which is quite famous in Germany
00:29:31 <pumpkin> I hate those things
00:30:42 <ksf> pumpkin, nope: malbolge is turing-complete (well, at least it's assumed to be), but it might not be able to execute all programs as finding a coding might blast all computational bounds.
00:31:02 <mmorrow> mlesniak: i found this one to be very informative http://serv1.ist.psu.edu:8080/viewdoc/download;jsessionid=558F2C844DFFE3C4404B2E4C23051AEE?doi=10.1.1.81.7841&rep=rep1&type=pdf
00:31:03 <pumpkin> all computational bounds?
00:31:04 <lambdabot> Title: cache:http://serv1.ist.psu.edu:8080/viewdoc/download;jsessionid=558F2C844DFFE3C4 ..., http://tinyurl.com/5r6y9b
00:31:21 <mmorrow> although it may not be what you're looking for..
00:31:24 <pumpkin> ksf: a turing machine is unbounded though
00:32:26 <mlesniak> mmorrow, thanks, it seems interesting (but unfortunately you are right)
00:32:40 <pumpkin> being intractable on any physical computer doesn't change that... or are you saying that you might find that malbolge partitions the programs such that all tractable ones halt and all intractable ones don't?
00:33:36 <mmorrow> mlesniak: what part of the implem are you most interested in?
00:33:55 <pumpkin> I'm just curious, as I'm sure is obvious I really don't know much about theory :P only took one undergrad course in it, so my knowledge is rather limited in the field
00:33:55 <ksf> ...so, assuming that malbolge is turing-complete and finding a coding for an arbitrary program to run on malbolge involves solving the halting problem, malbolge is either a) not turing complete, which is paradoxial, or b) implies that a turing machine can solve the halting problem
00:34:14 <ksf> I hope you understand now why i tried not to think about it.
00:34:33 <pumpkin> ksf: why would you make that assumption though?
00:34:44 <ksf> to construct an argument.
00:34:48 <pumpkin> oh :)
00:35:05 <mlesniak> mmorrow, Hmm, let's say it this way: we have some functional language with no specific oder of execution and somehow magically we are able to compile code for a von Neuman machine. In common languages like C, python, ruby, Java the transformation from language -> machine code is (at least in theory) much more obvious.
00:35:53 <pumpkin> ksf: but the b has already been proven to be false, and the a is paradoxical, so it seems that the only thing left is that finding a coding for any malbolge program does NOT involve solving the halting problem? :P
00:36:04 <mmorrow> mlesniak: ah. that lvm paper may be interesting after all then, since it is very similar to the STG machine that ghc uses as its execution model
00:37:10 <mlesniak> mmorrow, Hey, that sounds good. Additonally I'll search for paper about the STGmachine. Thanks for your kind help!
00:37:11 <pumpkin> maybe I'm just being thick though, sorry :)
00:37:18 <ksf> are halting problems generatable in finite time?
00:37:34 <mmorrow> i wrote a partial lvm interpreter in haskell that may give a better idea of that paper/spec's content: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=486
00:38:07 <mmorrow> the 2nd and 3rd pastes in that thread show the compiled code for a simple program, and the full execution trace  including stack and heap at each step
00:38:49 <mlesniak> I see, thanks for this, too
00:38:51 <pumpkin> ksf: not sure what you mean...
00:41:01 <mmorrow> mlesniak: this page also has many applicable papers http://research.microsoft.com/~simonpj/Papers/papers.html
00:41:02 <lambdabot> Title: Simon Peyton Jones: papers
00:41:20 <mmorrow> this one's good http://research.microsoft.com/~simonpj/Papers/eval-apply/index.htm
00:41:21 <lambdabot> Title: How to make a fast curry, http://tinyurl.com/5z825l
00:42:29 <pumpkin> oh, he doesn't have a PhD?
00:43:31 <vegai> of course he does
00:43:40 <pumpkin> his bio doesn't mention it
00:43:43 <pumpkin> I always assumed he did
00:44:37 <vegai> hmm, I suppose it's possible
00:45:14 <pumpkin> that's cool, I didn't think MSR hired non-PhDs, but I guess he's got quite the credentials :P
00:45:35 <vegai> well, he's a professor anyway
00:45:51 <vegai> even if only 'honorary' :P
00:46:13 <ibid> i believe he doesn't
00:46:34 <ibid> a doctorate isn't required for an academic career, but it helps  a lot
00:46:39 <pumpkin> yeah
00:48:28 <BeelsebobWork> hmm, this makes no sense
00:49:41 <pumpkin> BeelsebobWork?
00:50:20 <BeelsebobWork> I've played with conal's def of minI, in the hope of stopping it spawning 10 threads
00:50:26 <BeelsebobWork> because in theory it should only spawn 6
00:50:32 <BeelsebobWork> but it seems to now have a very slow case
00:50:37 <BeelsebobWork> I wonder if anyone can see it... http://hpaste.org/12395
00:52:41 <BeelsebobWork> ah... discovery is that my change makes it leak
00:52:51 <BeelsebobWork> I wonder what I added that did that
00:53:15 <pumpkin> what does minI do?
00:53:46 <ksf> pumpkin, if you halting problems are generatable then you can construct a turing-complete operational semantic that'd have to solve the halting problem (that another instance just generated) to run itself.
00:53:48 <BeelsebobWork> it compares two improving values
00:54:01 <ksf> i'm trying to solve the problem ad absurdum, it seems.
00:54:45 <ksf> ...proving that it actually doesn't exist as it's just a figment of our demented illusion.
00:55:19 <pumpkin> ksf: so if you had a generator of all problems that halted and avoided the rest?
00:56:13 <pao> hi all
00:56:31 <pao> suppose I've got to implement a simple telnet app
00:56:37 <ksf> well the essence of turing machines is that they can run programs that don't halt.
00:57:17 <pao> in a traditional imperative language I'd use event based programming based on select family sistem calls or two threads sharing the socket and the terminal resources....
00:57:26 <pumpkin> ksf: yes
00:57:33 <pao> what's the best practice with haskell?
00:57:44 <pumpkin> ksf: so you're saying write a program that can generate all programs that do halt?
00:58:05 <ksf> I'm trying to prove my intuition that believing in the halting problem is like believing in hell because you believe that you will spend your afterlife in hell if you don't believe in it.
00:58:31 <ksf> nah, that generates a problem you have to solve before it lets you do what you want.
00:58:40 <pumpkin> hmm
00:59:57 <pumpkin> ksf: it seems that regardless of the construct you use, you can always reduce it to the same old argument
01:00:13 <pumpkin> that if you did have some effective way to separate the halting ones from the non-halting ones
01:00:19 <ksf> don't listen to your parents?
01:00:20 <pumpkin> you could construct a program that fit in neither
01:00:34 <pumpkin> hmm?
01:00:39 <ksf> never mind.
01:00:54 <pumpkin> :(
01:00:57 <dancor> lambdabot depends on readline, ghc 6.10.1 depends on libedit, and readline + libedit tends to do bad things with include files overlapping
01:01:03 <dancor> that is a bad situation
01:01:52 <mlesniak> Out of curiosity: is compling ghc from the repository a possible task?
01:02:13 <dejones> Lemmih: Hi.  :)
01:02:26 <dejones> Lemmih: I just got your reply about LHC fork of JHC.
01:02:35 <pumpkin> ksf: I'm not trying to be thick, it just seems (with my limited understanding of theory, as I said) like you're trying to come up with a roundabout way to get around a paradox... making it more complicated doesn't resolve the fundamental issue
01:03:00 <ksf> I'm trying to get _into_ it.
01:03:02 <dancor> mlesniak: i compiled from 6.10.1-src earlier today
01:03:14 <dancor> mlesniak: and i've done it from the repo head in the past
01:03:25 <Lemmih> dejones: I'll put a more detailed reason up on lhc.seize.it once I get around to it.
01:03:34 <mlesniak> dancor, any things I have to pay attention to?
01:03:51 <mlesniak> (besides the "normal" stuff)
01:03:57 <ksf> pumpkin, how can there be a program that neither halts nor doesn't halt?
01:03:58 <dancor> mlesniak: you want to have libedit if you want ghci to be nice
01:04:00 <solrize> halting programs are generatable in the sense that you can enumerate all the tm's and run them in parallel and every time one runs, output it.  but the non-halting ones are not enumerable.
01:04:02 <dancor> after the intsall
01:04:11 <dancor> otherwise no up/down history
01:04:13 <dejones> Lemmih: Sure.  Your email was fine.  I definitely appreciate the reply.
01:04:28 <mlesniak> dancor, ok, thanks
01:04:29 <pumpkin> ksf: it asks halts?(self) and if it returns true, enters an infinite loop, otherwise exits
01:04:45 <dancor> also it takes a while like an hour on a fast machine maybe?  not sure
01:04:49 <dejones> Lemmih: I think a roadmap on the site would be helpful though.
01:05:00 <mlesniak> dancor, that should be no problem :)
01:05:16 <dejones> Lemmih: Did John not apply your patches to JHC bc it is inactive?  or technical differences?
01:05:26 <pumpkin> ksf: basically a computational reformulation of russell's paradox
01:05:33 <ksf> doesn't commute.
01:05:35 <ksf> mu.
01:05:46 <pumpkin> ?
01:06:01 <dancor> comμte
01:06:12 <Lemmih> dejones: We had some ideological disagreements.
01:06:17 <pumpkin> ksf: what's broken about it?
01:06:46 <ksf> it's bottom.
01:07:00 <dejones> Lemmih: Ahh.  It happens.  :)
01:07:02 <pumpkin> my program?
01:07:24 <ksf> yes. it's like saying a = !a
01:07:26 <dancor> this sounds almost like _|_rolling ;)
01:07:36 <pumpkin> ksf: that's what I'm saying
01:08:08 * ksf considers paradoxes to be harmful
01:08:16 <Lemmih> dejones: There's a lhc mailing if you want to stay up-to-date.
01:08:24 <pumpkin> ksf: but that's what the halting problem is :P
01:08:30 <dejones> Lemmih: Oh, thanks.  I will subscribe.  :)
01:08:35 <ksf> so let's define it away.
01:08:47 <ksf> that's how you deal with em buggers.
01:08:48 <pumpkin> ksf: there are no other logical fallacies in that program, so the only thing left is the definition of halts itself
01:09:07 <pumpkin> ksf: the set of all sets that don't contain themselves
01:09:16 <pumpkin> I can state it
01:09:19 <pumpkin> doesn't mean it's meaningful
01:09:35 <ksf> the pseudocategory of pseudocategories.
01:09:37 <mmorrow> why do we care if a program halts again?
01:09:38 <ksf> it's all around.
01:10:08 <ksf> because turing machines can execute themselves, and that's leet.
01:10:24 <pumpkin> mmorrow: I'm just trying to understand how you can get around that basic paradox :)
01:10:27 <mmorrow> heh, leet++
01:11:25 <mmorrow> pumpkin: i need to scroll back and get some perspective
01:11:47 <pumpkin> maybe I'm just sophomoric :)
01:12:05 <ksf> so, what if the universe actually isn't turing-complete but only total, and all we are doing is using partial turing emulators and imagining abstract thingies we label turing-complete?
01:12:41 <ksf> does, in fact, the universe need to run itself?
01:13:10 <mmorrow> heh, a wonderful question.
01:13:29 <pumpkin> ksf: I'm not sure what your point is here :)
01:13:56 <pumpkin> ksf: are you saying that the halting problem is solvable by some clever construct, or that the definition we use of halting is unproductive
01:14:13 <pumpkin> ?
01:14:14 <ksf> the latter. that the whole thing is pure imagination.
01:14:29 <pumpkin> well, we've got a pretty formal definition of halting
01:14:31 <mmorrow> ok i see, so the issue/question is "a turing machine can execute/interpret any turing machine (including itself) if and only if it can solve the halting problem" ??
01:14:33 <ksf> "solving" it means abandoning it.
01:14:45 <pumpkin> ksf: so for the given formal definition of halting, it's a paradox
01:14:47 <ksf> formalisms _are_ imagination.
01:14:59 <pumpkin> I agree that if you relax it a little you might very well be able to solve it in many cases
01:15:07 <pumpkin> ksf: you're getting too philosophical for me :P
01:15:58 <ksf> hmmmm.
01:16:30 <pumpkin> mmorrow: I don't think that's true
01:16:52 <mmorrow> neither do i, but am i correct in saying that's what we're talking about?
01:16:54 <pumpkin> it's quite easy to simulate a turing machine in another one
01:17:14 <mmorrow> i'm trying to understand what exactly it is that's being debated
01:17:18 <pumpkin> mmorrow: I'm not quite sure what we're even talking about :) given the latest philosophical direction I get the impression I've been arguing one point and he's been arguing a different one the whole time
01:17:30 <pumpkin> but I don't know
01:17:47 <mmorrow> heh. the universe is the ultimate metacircular interpreter
01:17:52 <ksf> if you replace schroedinger's cat with the if(halts?(self)){for(;;)}{return true} program, and it gets killed if it halts while you're looking, what happenes if you open the box?
01:18:11 <pumpkin> lol
01:18:26 <ksf> wait.
01:18:34 * mmorrow is still parsing that
01:18:35 <ksf> i wanted to write something different.
01:18:41 <ksf> now i gotta try and understand myself.
01:18:55 <pumpkin> I'm saying that the program I wrote earlier in its very essence can't exist
01:19:22 <pumpkin> ok
01:19:40 <ksf> ah. it should read "a program that gets killed iff you don't look"
01:19:53 <mmorrow> pumpkin: ah, i missed that and can't seem to find it. could you reproduce that program?
01:20:33 <pumpkin> mmorrow: it's just what he wrote: if (halts?(self) { for (;;); } else { return; }
01:20:41 <mmorrow> <pumpkin> ksf: it asks halts?(self) and if it returns true, enters an infinite loop, otherwise exits
01:20:43 <mmorrow> ah, ok.
01:20:48 <ksf> "a program that kills itself if you don't look if it's running"
01:21:59 <ksf> now, is the universe paradoxical or my perception and imagination?
01:22:19 <pumpkin> I don't get how you can extrapolate that the universe is paradoxical
01:22:41 <pumpkin> I mean, maybe it is, but I don't see that following from what we wrote
01:22:43 <ksf> well, at least time is.
01:22:59 <ksf> and it's alleged beginning and everything "before" that.
01:23:21 <pumpkin> there doesn't need to be a beginning of time any more than there needs to be a beginning of a number line, really
01:24:03 <ksf> I'm already glad that there aren't any planets with a negative number of moons.
01:24:09 <pumpkin> :)
01:24:23 <pumpkin> maybe there are and we just can't observe them!
01:24:36 <mmorrow> hmm, i think though that that isn't really valid though, since it depends on some definition of "look" thus treating the question of whether something halts or not as being both objective and subjective at the same time
01:24:56 <pumpkin> mmorrow: you mean my program?
01:25:02 <pumpkin> "my"
01:25:17 <ksf> according to relativity (and i ain't a psysicist) time _did_ start at the big bang.
01:25:17 <mmorrow> i was refering to "a program that kills itself if you don't look if it's running"
01:25:23 <pumpkin> ah
01:25:35 <mmorrow> so i guess yes, you're program if that accurately depicts it
01:25:39 <mmorrow> *your
01:25:40 <pumpkin> ksf: it doesn't really prove anything in any standard physical sense
01:26:21 <ksf> mmorrow, that's the standard quantum mechanical paradox.
01:26:48 <L3v1> hi all
01:26:58 <ksf> as you gotta influence a system to observe it it's free to react to your observing.
01:27:30 <mmorrow> ok, then that program always halts :)
01:27:30 <pumpkin> ksf: I think this all originated with how malbolge could somehow potentially avoid the halting paradox, and I think we were just talking about different things this whole time :)
01:27:34 <ksf> try staring at people from behind in a public transport, it works.
01:27:54 <pumpkin> ksf: creeepy ;)
01:27:58 <ksf> i never tried to solve the paradox, i'm trying to get rid of it.
01:28:02 <mmorrow> wait, i meant "ok, then that program never halts"
01:28:18 <pumpkin> ksf: let's just reduce it to the simpler form then, the set that contains all sets that don't contain themselves
01:28:40 <ksf> nah it only halts if you're a cold-hearted bastard and don't care about it by looking.
01:28:44 <pumpkin> lol
01:29:26 <mmorrow> you could always simply give it a mirror and blindfold yourself before doing it
01:29:30 <ksf> i like the quantum-mechanical tilt to it 'cos... I love Kant
01:30:02 <pumpkin> maybe I'm being too down-to-earth here, but does is observer effect really meaningful in theory of computation?
01:30:08 <pumpkin> -does
01:30:19 <L3v1> I am puzzled on how to test whether an function is lazy evaluated. Is there any tips ?
01:30:42 <ksf> it's significant if you want to figure out whether or not the theory of computation should deal with it at all.
01:30:52 <ksf> as we gotta question our motives of doing so.
01:31:21 <pumpkin> you mean whether we should be even asking ourselves about a thing called the "halting problem"?
01:31:31 <ksf> exactly.
01:31:35 <mmorrow> , take 10 [0..]
01:31:37 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
01:31:37 <pumpkin> that's what I've been saying from the start
01:31:39 <ksf> except as an upper bound, of course.
01:31:47 <pumpkin> that we shouldn't even be talking about it as a problem
01:31:58 <pumpkin> that the very question is paradoxical
01:32:02 <ksf> but then people just don't speculate about stuff like "what's infinity divided by two?"
01:32:25 <mmorrow> L3v1: hmm, i'm not sure exactly what you're looking for, but one way to see it would be to do in ghci:
01:32:38 <mmorrow> let a = sort <some-massive-list>
01:32:49 <mmorrow> nothing happens
01:32:51 <mmorrow> then
01:32:54 <mmorrow> print a
01:32:59 <mmorrow> <long delay>
01:33:06 <mmorrow> or something along those lines
01:33:14 <pumpkin> :)
01:34:06 <ksf> or, allegorical to the halting problem, "when does infinity approach zero?"
01:34:32 <pumpkin> always and never!
01:34:43 <pumpkin> and everything in between
01:34:54 <pumpkin> and even things that aren't always or never or in between
01:34:58 <pumpkin> :P
01:35:00 <mmorrow> L3v1: well, since /everything/ is lazily evaluated in haskell it may not be clear whether exactly the laziness you're interested in is actually happening unless you already know that it must be
01:35:15 <mmorrow> , let x = rnf [0..] in 42
01:35:17 <lunabot>  42
01:35:21 <mmorrow> , let x = rnf [0..] in x
01:35:28 <lunabot>  Killed.
01:35:39 <mmorrow> , let x = [0..] in x
01:35:41 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
01:35:48 <pumpkin> rnf?
01:35:57 <mmorrow> reduce to normal form
01:36:06 <mmorrow> essentially a "deep" seq
01:36:10 <pumpkin> ah
01:36:19 <mmorrow> Control.Parallel.Strategies.rnf
01:36:25 <ksf> exactly.
01:37:11 <ksf> the normal form of [0..] is [0..], but we idiots don't have a way to stop at the nf.
01:38:33 <ksf> I get this creepy feeling again that time doesn't exist.
01:38:52 <ksf> which gets even creepier if you notice it over time.
01:40:17 <L3v1> mmorrow: thx, i wonder that how to force not to lazy eval an expr explictly. using such as ($!), seq, or sth else.
01:41:20 <mmorrow> L3v1: many times rnf is harmful more than helpful, but how you'd us it is like:
01:41:31 <L3v1> and then, if i wrote an implementation, how to check it just does what i want it to do?
01:41:42 <mmorrow> , let x = 1 + 2 in rnf x `seq` x
01:41:45 <lunabot>  3
01:42:03 <mmorrow> but then again, you have to actually force that whole expression to force x
01:42:22 <mmorrow> , let y = (let x = [0..] in rnf x `seq` x) in 42
01:42:24 <lunabot>  42
01:42:47 <mmorrow> , let y = (let x = [0..] in rnf x `seq` x) in y `seq` 42
01:42:50 <lunabot>  luna: out of memory (requested 1048576 bytes)
01:44:04 <mmorrow> L3v1: you may just need a few well-placed bangpatterns
01:44:47 <mmorrow> , foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [1..1000000]
01:44:51 <lunabot>  Stack space overflow: current size 8388608 bytes.
01:44:51 <lunabot>  Use `+RTS -Ksize' to increase it.
01:44:53 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [1..1000000]
01:44:58 <lunabot>  (500000500000,500000500000)
01:46:30 <mmorrow> L3v1: hmm, if you wrote an implementation i guess that implementation would have to /implement/ the lazy eval so it'd probably be able to know if a function is lazy by default i guess
01:48:51 <mmorrow> L3v1: seq (and thus $!) can only see down one level, whereas rnf can see all the way to the bottom
01:48:58 <mmorrow> @src ($!)
01:48:58 <lambdabot> f $! x = x `seq` f x
01:49:51 <pumpkin> ksf: I get the feeling time is discrete sometimes... it seems like two events that have no reason to happen at the same time do, but that's probably due to my limited sampling rate of reality :P
01:50:46 <mmorrow> , let x = [0,undefined] in x `seq` head x
01:50:49 <lunabot>  0
01:50:50 <mmorrow> , let x = [0,undefined] in rnf x `seq` head x
01:50:52 <lunabot>  luna: Prelude.undefined
01:51:25 <mmorrow> pumpkin: aliasing!
01:51:36 <pumpkin> guess so :P
01:51:45 <pumpkin> I need to up my sampling rate
01:51:54 <mmorrow> heh
01:51:54 <pumpkin> anyone know any good drugs for that?
01:52:38 <mmorrow> i'm sure there are a few, especially if you're at a university ;)
01:53:24 <pumpkin> :D
01:53:33 <mmorrow> what's the formula for the nyquist frequency again?
01:54:14 <mmorrow> "is half the sampling frequency of a discrete signal processing system"
01:54:18 <mmorrow> wikipedia++
01:54:21 <pumpkin> :)
01:57:58 <ksf> drugs?
01:57:59 <ksf> erm...
01:58:01 <ksf> kant.
01:58:06 <ksf> bucky fuller.
01:58:37 <ksf> i'm still trying to get what he meant by literally saying "everything is tetrahedrons"
02:00:39 <pumpkin> I still don't get why they called it buckminsterfullerene instead of just fullerene, like any other sane naming would work
02:01:00 <ksf> they're called buckyballs.
02:02:45 <BeelsebobWork> pumpkin: I *think* it's because there are lots of possible fullerene
02:02:48 <ksf> http://www.rwgrayprojects.com/synergetics/s05/p2800.html#529.00
02:02:53 <lambdabot> Title: 500.00 CONCEPTUALITY
02:02:54 <BeelsebobWork> buckminsterfullerine refers only to the ball shaped one
02:03:16 <pumpkin> BeelsebobWork: according to wikipedia, the fullerenes as a family were named after buckminsterfullerene was named originally
02:03:26 <pumpkin> so they kind of shortened it for the general family, which was discovered later
02:03:33 <BeelsebobWork> oh, okay
02:03:42 <ksf> they're named after him because he had the only maths able to tackle them.
02:03:49 <BeelsebobWork> so, while what I said is correct, the causality is backwards
02:03:50 <BeelsebobWork> :/
02:03:57 <L3v1> mmorrow: thanks alot. following your instructions, i am going to read the paper introduced in ghc lib Control.Parallel.Strategies. and what do i need to really understand the lazy/reduce, eh, structure?
02:03:59 <pumpkin> I know why they are named after him, I just don't see why they'd put his whole name in there
02:04:12 <pumpkin> IsaacNewtonium
02:04:17 <pumpkin> AlbertEinsteinium
02:04:43 <ksf> californium is bad enough.
02:04:55 <ksf> luckily they stopped that.
02:05:06 <ksf> now it's called unununium and stuff.
02:05:23 <pumpkin> but still, they have things like bohrium
02:05:24 <BeelsebobWork> hehe
02:05:30 <pumpkin> it should be nielsbohrium
02:05:32 <BeelsebobWork> and carbon
02:05:35 <BeelsebobWork> that was named after cars
02:05:36 <BeelsebobWork> >.>
02:05:40 <pumpkin> lol
02:05:53 <mmorrow> L3v1: cool! you probably want to read about the execution strategy that ghc (or any other lazy lang implem) uses. ghc's eval model is that of the STG machine
02:06:03 <pumpkin>  DmitriMendeleyevium
02:06:09 <pumpkin> okay, I'll stop now :P
02:06:50 <ksf> "Intellect is top speed, which is instantaneous, being vastly faster than the speed of light and all radiation."
02:07:00 <mmorrow> i just linked someone earlier to a paper/spec for a VM that i just read the other week which i found /very/ useful in explaining an (very similar to ghc/STG) interpretation strategy for a lazy language
02:07:07 <ksf> sometimes bucky is surprising.
02:07:14 <mmorrow> http://serv1.ist.psu.edu:8080/viewdoc/summary?doi=10.1.1.81.7841
02:07:15 <lambdabot> Title: The Lazy Virtual Machine specification - CiteSeerX
02:07:23 <mmorrow> the pdf link is on that page
02:07:58 <ksf> he, of course, doesn't elaborate on it.
02:08:52 <mmorrow> L3v1: this page is good also: http://research.microsoft.com/~simonpj/Papers/papers.html
02:08:53 <lambdabot> Title: Simon Peyton Jones: papers
02:09:39 <ksf> "Eternity is simply highest speeds: not "at rest," because it gets there in no- time-at-all: Complete intellection + Otherness + No-time-at-all. "
02:10:01 <solrize> time cube?
02:10:15 <ksf> http://www.rwgrayprojects.com/synergetics/s05/p2800.html#529.00
02:10:16 <lambdabot> Title: 500.00 CONCEPTUALITY
02:10:36 <ksf> Kant is a much easier read, if you need a gateway drug.
02:12:23 <L3v1> mmorrow: time to go, really appreciate for your help. :D
02:12:49 <mmorrow> L3v1: np. good luck
02:13:42 <L3v1> thanks, bye. and bye, all. my friends.
02:15:08 <pumpkin> sourceforge is turning into such a pile of crap
02:15:32 <sjanssen> this has been happening for years
02:15:37 <pumpkin> yeah, true
02:15:46 <pumpkin> but I normally stay away from it
02:16:01 <BeelsebobWork> tbh, they did manage to make one good change...
02:16:02 <pumpkin> it just hit me how I need to click through a thousand different pages to even get to what I'm looking for
02:16:06 <pumpkin> with animated flash ads all around me
02:16:09 <sjanssen> it definitely seems like there are fewer projects that use sourceforge now
02:16:10 <pumpkin> bad navigation
02:16:12 <pumpkin> and so on
02:16:14 <BeelsebobWork> they stopped you having to click 100 pages to get to a download
02:16:18 <BeelsebobWork> now it is a one click thing
02:16:25 <pumpkin> BeelsebobWork: really? I just had to click 99 pages
02:16:32 <pumpkin> :P
02:16:57 <BeelsebobWork> pumpkin: you used to have to click the download link, then the exact thing you wanted out of the list of downloads, then the version, then confirm, and then the actual download
02:17:00 <BeelsebobWork> now you click download, and it does
02:17:11 <pumpkin> I guess it's a little nicer in that respect, yeah :)
02:17:15 <pumpkin> but I still abhor it
02:37:56 <gerryxiao> hello
02:39:49 <gerryxiao> how to make ghci color ouput on gnome terminal?
02:40:49 <BeelsebobWork> ghci doesn't support that
02:41:07 <BeelsebobWork> it's on my list of weekend projects >.<
02:41:37 <gerryxiao> :)
02:45:37 <gerryxiao> why:  let add= \x -> x+ 1  works and let addA = proc a ->reutrunA -< (a+1) not?
02:45:59 <gerryxiao> i have to add a "_" after addA
02:47:09 <gerryxiao> i mean in ghci
02:48:07 <quicksilver> "not" doesn't tell me much.
02:48:15 <quicksilver> what was the error or symptom of it not working?
02:48:39 <gerryxiao> Ambiguous type variable `a' in the constraint:
02:48:39 <gerryxiao>       `Arrow a' arising from a proc expression at <interactive>:1:10-36
02:48:39 <gerryxiao>     Probable fix: add a type signature that fixes these type variable(s)
02:48:59 <BeelsebobWork> quicksilver: :D I think I fixed the tetris leak
02:49:04 <quicksilver> BeelsebobWork: nice.
02:49:24 <quicksilver> gerryxiao: monomorphism restriction
02:50:13 <quicksilver> BeelsebobWork: I am sad because it turns out my elegant history combinator has an essential memory leak ;(
02:50:20 <BeelsebobWork> :(
02:50:25 <gerryxiao> but add not this restriction?
02:50:32 <quicksilver> history = accumE [] . fmap (:)
02:50:39 <quicksilver> @go haskellwiki monomorphism restriction
02:50:43 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:50:43 <lambdabot> Title: Monomorphism restriction - HaskellWiki
02:50:46 <quicksilver> gerryxiao: read that page.
02:50:49 <BeelsebobWork> quicksilver: why does that leak?
02:50:50 <quicksilver> you can turn it off if you want.
02:51:02 <quicksilver> BeelsebobWork: because it fundamentally holds on to every (value of) an occurence
02:51:11 <quicksilver> even if you fmap (take 5) over it
02:51:19 <quicksilver> which seemed intuitiviely sound to me ;)
02:51:21 <BeelsebobWork> why?
02:51:29 <quicksilver> the basic fact is, it's still holding onto the entire tail.
02:51:36 <BeelsebobWork> oh, sure
02:51:41 <BeelsebobWork> but that's just an infinite list?
02:51:41 <quicksilver> because lists are tail lazy and I'm trying to treat them as head-lazy
02:51:43 <quicksilver> basically
02:51:50 <BeelsebobWork> oh, so you do
02:52:00 <BeelsebobWork> bollocks
02:52:08 <quicksilver> means that (assuming your event keeps occurring) that formulation must leak
02:52:10 <BeelsebobWork> btw, I haven't fixed the TVal leak that conal identified
02:52:18 <BeelsebobWork> I actually found that the leak in tetris was elsewhere
02:52:24 <BeelsebobWork> it was in minI/maxI
02:52:25 <quicksilver> you have to interleave the (take 5) in the original accumE
02:52:32 <quicksilver> which is a shame because that's less pretty.
02:52:46 <BeelsebobWork> yeh
02:53:02 <quicksilver> lastN = accumE . fmap (take 5 . (:))
02:53:04 <quicksilver> or something
02:53:08 <quicksilver> (I didn't type-check that)
02:53:16 <quicksilver> lastN n = accumE . fmap (take n . (:))
02:53:18 <quicksilver> I mean ;)
02:53:22 <quicksilver> + []
02:53:41 <quicksilver> BeelsebobWork: yeah I read some of your minI/maxI musing in scrollback
03:00:02 <BeelsebobWork> hmm, maybe I didn't
03:00:07 <BeelsebobWork> I suspect an overnight change fixed it
03:00:22 <BeelsebobWork> I've just reduced CPU/thread usage a bit
03:00:29 <BeelsebobWork> stil... woot :)
03:01:15 <PaulAJ> Has anyone done an embedding of numeric types in applicative functors?
03:01:56 <PaulAJ> I keep finding I want to have a type constructor F and, say, have F Int
03:02:19 <PaulAJ> and then do x, y :: F Int;  z = x .+. y
03:02:32 <BeelsebobWork> why .+.?
03:02:40 <BeelsebobWork> why not just make the data type an instance of Num?
03:03:04 <PaulAJ> The Show and Eq instances often don't work (e.g. if instance Monad F)
03:03:11 <gerryxiao> odd stuff :)
03:03:20 <BeelsebobWork> don't work how?
03:03:44 <PaulAJ> You want to have (==) :: F a -> F a -> F Bool
03:04:00 <quicksilver> PaulAJ: yeah, people often cheat, and lie about those instances
03:04:01 <gerryxiao> Monomorphism restriction id odd
03:04:31 <quicksilver> PaulAJ: (==) x y = error "this type doesn't really support Eq, I lied because I wanted a convenient Num instance"
03:04:43 <PaulAJ> So I'm putting together a proposal, but I want to check I'm not re-inventing the wheel.
03:04:46 <pumpkin> does fmap stand for functor map?
03:04:58 <quicksilver> pumpkin: yes.
03:05:06 <PaulAJ> quicksilver: yes, thats what I want to avoid.  Also, I do want the Eq functionality.
03:05:27 <quicksilver> PaulAJ: I think it would be interesting to see a proposal.
03:05:56 <PaulAJ> So I thought class Applicative f => AppEq f where (.==.) :: f a -> f a -> f Bool   etc etc
03:06:20 <quicksilver> you could just use liftA2 (==) in that case
03:06:23 <quicksilver> you wouldn't need a class.
03:06:29 <quicksilver> but maybe that's not the definition you have in mind?
03:07:20 <PaulAJ> Yes, but then application code is full of "z = liftA2 (+) x y" instead of "z = x .+. y".  I thought that a .*. naming convention would be a Good Thing.
03:07:25 <quicksilver> indeed.
03:07:29 <quicksilver> I'm just saying that isn't a class.
03:07:40 <quicksilver> that's just (.==.) = liftA2 (==)
03:07:48 <quicksilver> no new class needed to make that work ;)
03:08:05 <quicksilver> just a small family of definitions. (.+.) = liftA2 (+), and so on.
03:08:11 <PaulAJ> Depends if you want it to be liftA2 (==) in every case.
03:08:15 <quicksilver> exactly.
03:08:23 <quicksilver> hence "but maybe that's not the definition you have in mind?"
03:08:24 <quicksilver> ;)
03:08:46 <PaulAJ> For instance I think you could do interval arithmetic properly using Applicative Functors (which is what got me started on this).
03:09:08 <quicksilver> I hacked together some simple interval arithmetic just using a Num instance
03:09:15 <quicksilver> but you're right, it's not very satisfactory.
03:09:40 <quicksilver> (thing that annoyed me most is that (^) is expressed in terms of (*) which is not what you want)
03:09:47 <PaulAJ> "compare :: Interval a -> Interval a -> Interval Ord" actually works out quite well.
03:09:59 <quicksilver> I never ended up actually using it, so I abandoned the experiment.
03:10:08 <PaulAJ> Is that the one I found on Hackage?
03:10:11 <quicksilver> was working on surface tesselation / root finding on 3d
03:10:15 <quicksilver> not mine.
03:10:38 <quicksilver> automatic differentiation is another obvious Num instance which isn't quite right.
03:10:49 <quicksilver> BeelsebobWork: does vectorspace use automatic differentiation?
03:11:20 <hackage> Uploaded to hackage: HStringTemplateHelpers 0.0.3
03:11:20 <hackage> Uploaded to hackage: DarcsHelpers 0.1
03:11:23 <BeelsebobWork> quicksilver: good question -- that's my biggest knowledge hole in reactive/field trip
03:12:01 <PaulAJ> OK, so I'll carry on with it in the happy knowledge that I'm not duplicating someone elses work.
03:12:19 <PaulAJ> (And I'll take a look at the AD stuff too.
03:12:52 <quicksilver> BeelsebobWork: I assume it must do, since you only specify the surface and it works out the derivative magically.
03:12:59 <quicksilver> sounds like automagic differentiation to me :)
03:13:06 <BeelsebobWork> quicksilver: indeed
03:14:26 <PaulAJ> http://catb.org/jargon/html/A/automagically.html
03:14:27 <lambdabot> Title: automagically
03:15:17 <ketil> Is there a recommended module for working with probability distributions?  I.e. I need to pull random values from various distributions, and ideally, also calculate p-values of observations.
03:15:37 <ketil> I've seen Erwig's PFP, and Hal Daume's HBC.
03:16:15 <ketil> They seem to be orphaned, and there's little documentation, etc.
03:16:29 <ketil> (Perhaps it's easier just to roll my own)
03:16:36 <quicksilver> I know people have worked on it because I've seen it discussed.
03:16:41 <quicksilver> I remember a good blog post on it too.
03:16:50 <quicksilver> I don't know if anything ever got polished + released.
03:16:54 <PaulAJ> I've been using PFP http://hackage.haskell.org/cgi-bin/hackage-scripts/package/probability
03:16:56 <lambdabot> Title: HackageDB: probability-0.2.1, http://tinyurl.com/5jrxmr
03:17:32 <quicksilver> http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions
03:17:38 <lambdabot> Title: Refactoring probability distributions, part 1: PerhapsT, http://tinyurl.com/ythywo
03:17:38 <quicksilver> http://www.randomhacks.net/articles/2007/02/21/randomly-sampled-distributions
03:17:40 <lambdabot> Title: Refactoring probability distributions, part 2: Random sampling, http://tinyurl.com/2ytmlt
03:17:44 <quicksilver> (And the comments on those articles)
03:17:50 <quicksilver> should give you some things to think about ;)
03:18:00 <PaulAJ> Its for discrete distributions.  In fact my question about Applicative Functors is a yak-shaving part of that work.  I need continuous distributions, so I was
03:18:19 <PaulAJ> moddeling them by using discrete distributions of ranges.
03:18:31 <PaulAJ> I mean /ranges/intervals
03:19:23 <PaulAJ> Gotta go.  Bye.
03:29:38 <ketil> Huh, no time for  a reply.
03:56:18 <RLa> for a type to belong into the type class, all functions of the class must be implemented on that type?
03:57:23 <kosmikus> RLa: all functions that don't have default definitions, yes. although in practice, you'll only get a warning for unimplemented methods, and they'll then default to "undefined", i.e., cause a runtime error when called.
03:58:30 <RLa> kosmikus, but is it also neccesary to ecplicitly say that the type belongs into the class?
03:58:49 <RLa> (i have used haskell very little)
03:59:28 <quicksilver> yes
03:59:33 <kosmikus> RLa: yes, it is. you say "instance <name of class> <name of type> where ..."
03:59:36 <quicksilver> instance ClassName TypeName where ....
03:59:44 <RLa> thanks
03:59:47 <kosmikus> after the where, all the definitions of the methods
03:59:59 <RLa> is there online pdf book of haskell
04:00:20 <kosmikus> RLa: hey, you're from Estonia :) are you learning Haskell at a university?
04:00:28 <RLa> hey
04:00:29 <RLa> no
04:01:11 <RLa> well, yes, i'm from Estonia but i do not study haskell
04:01:26 <kosmikus> RLa: go to haskell.org. On the left, there are links "Learning Haskell" as well as "Books / tutorials"
04:01:52 <kosmikus> RLa: where in Estonia are you located?
04:02:50 <RLa> in southern part
04:04:29 * kosmikus wants to visit .ee again
04:06:04 <RLa> kosmikus, at the moment there is white snow all over, not usual mud and cold rain :)
04:07:23 <kosmikus> well, that's one of the nice things I recall from .ee, that you have a "real" winter
04:07:56 <kosmikus> in 2005, I've been there the whole February and March
04:11:20 <hackage> Uploaded to hackage: BerkeleyDBXML 0.4
04:14:17 <monadwr> hello
04:14:43 <monadwr> BONUS: here?
04:21:22 <monadwr> plop
04:22:06 <monadwr> BONUS:
04:27:51 <vixey> hi
04:32:23 <nominolo|msr> @seen swiert
04:32:24 <lambdabot> I saw swiert leaving #haskell 1m 10d 23h 11m 28s ago, and .
04:32:37 <nominolo|msr> one month??
04:34:29 <quicksilver> preflex: seen swiert
04:34:29 <preflex>  swiert was last seen on #haskell 8 days, 1 hour, 35 minutes and 22 seconds ago, saying: I can't find anything at least...
04:34:38 <quicksilver> always good to have a second opinion ;)
04:36:19 <mapreduce> kosmikus: My Estonian ex didn't really seem to miss the winter that much.  She even moaned at how cold the English one was.
04:40:24 <osfameron> mapreduce: my mum (from Finland) complains the same.  I think the nordic winters are a different kind of cold (dryer? less windy?)
04:41:23 <jpcooper> osfameron, try Scotland
04:41:32 <osfameron> jpcooper: well, that's where they are now :-)
04:41:36 <jpcooper> ahah
04:41:37 <profmakx> i am in scotland
04:41:40 <profmakx> its not that bad
04:41:41 <osfameron> but she complained when we lived in the south too
04:41:43 <jpcooper> profmakx, where?
04:41:47 <profmakx> st andrews
04:41:49 <jpcooper> osfameron, are you from Istanbul?
04:41:54 <osfameron> jpcooper: nope
04:41:56 <jpcooper> aah, I'm at Glasgow
04:42:19 <osfameron> my parents are in Edinburgh
04:42:47 <osfameron> old tenement flat with lack of natural light and insulation...
04:42:58 <jpcooper> I've got the natural light
04:42:58 <profmakx> heh. are you a phd student in glasgow?
04:43:07 <jpcooper> but there's no insulation and the windows are HUGE
04:43:18 <jpcooper> no, I'm in second year of cs and maths currently skipping my Java lecture :)
04:44:04 <profmakx> oh well
04:44:10 <profmakx> java is useless
04:44:19 <jpcooper> what are you doing in St Andrews?
04:44:25 <profmakx> phd in maths
04:44:38 <vixey> profmakx, why java is useless?
04:45:09 <profmakx> lets put it in another way, I find java mostly useless
04:45:16 <profmakx> except for serving as a bad example
04:45:24 <profmakx> other people might think otherwise
04:45:34 <profmakx> and thats okay with me
04:45:36 <vixey> so basically you completely retract what you said? :)
04:45:45 <jpcooper> yes, I think that I might just do maths next year. I've not really been enjoying our "CS" curriculum
04:45:52 <Saizan> he doesn't want to argue about it :)
04:46:33 <profmakx> Saizan is right
04:46:53 <mapreduce> Language<Java> javaLanguage = new JavaLanguage();  javaLanguage.with(new Runnable() { public void run() { ..
04:46:55 <profmakx> and basically you are right too vixey
04:47:01 * mapreduce suffers a Repetitive Code Injury.
04:47:31 <vixey> I just hear people slag java so much.. I start to wonder if there is any substance behind the opinion
04:47:37 <mapreduce> vixey: Yes, there is lots.
04:48:07 <profmakx> hm. if everything should be a class in java, how is the class of all classes coming. and does it contain itself?
04:48:15 <mapreduce> profmakx: java.lang.Class<?>
04:48:41 <profmakx> except for that certain types arent classes if i remember correctly
04:48:46 <mapreduce> It contains itself insofar as Class.class.getClass() == Class.class
04:49:09 <Saizan> vixey: a verbose type system that just gets in your way seems enough to me
04:49:15 <profmakx> but I have to admit that I did not really touch java for years because I just did not like writing ugly code
04:49:35 <litb> hello crowd
04:49:37 <mapreduce> profmakx: Yes, a class is a 'runtime type' really, though Java gets the terms muddled throughout.
04:49:50 <Saizan> sure, at least it's garbage collected..
04:50:31 <jpcooper> I don't understand why there isn't an Eq interface in Java when classes can implement multiple interfaces
04:50:40 <jpcooper> there's just a de facto standard of implementing .equals()
04:51:11 <jpcooper> or a Show
04:51:43 <quicksilver> all objects are supposed to implement equals() aren't they?
04:51:47 <quicksilver> isn't in a method of Object?
04:51:53 <Saizan> it is
04:51:54 <quicksilver> which defaults to pointer equality but you can override it.
04:52:04 <jpcooper> quicksilver, yes
04:52:17 <quicksilver> that's a reasonable solution in the java context.
04:52:36 <quicksilver> pointer equality is a sensible default for things like de-dupping generic containers.
04:57:54 <vixey> java seems a lot better designed to say, ruby .. or python or whatever everyone loves recently
04:58:17 <ben> >:C
05:01:08 <osfameron> java was relatively unpleasant to program in last time I made any semi-serious attempt to
05:01:29 <osfameron> it's not dynamic enough to be fun, or strict enough to be useful
05:01:51 <vixey> what do you mean strict enough?
05:01:54 <osfameron> but it has its good points too, to be sure.  And *fantastic* IDEs
05:01:59 <acidjnk> hello
05:02:00 <vixey> more expressive type system?
05:02:10 <osfameron> vixey: er, yes, I think that's what I meant
05:02:40 <osfameron> of course I was using it pre-generics, so I should really shut up, as I'm completely ignorant about modern Java features
05:03:18 <profmakx> one should not unterestimate the mindpower that is blown into java
05:04:10 <jpcooper> osfameron, I find Eclipse much harder to use than Emacw
05:04:12 <jpcooper> Emacs*
05:04:20 <jpcooper> but maybe it's because I have no motivation to learn it
05:04:42 <p_l> jpcooper: When I hear *fantastic* IDE and Java, Eclipse is something that does *not* come into my mind :)
05:04:56 <jpcooper> what do you use?
05:04:59 <ziman> i was quite happy with eclipse
05:05:21 <jpcooper> ziman, have you ever used Emacs?
05:05:33 <ziman> nope.
05:05:35 <p_l> jpcooper: After getting mad at eclipse I switched to NetBeans, If I have to do anything in Java. NetBeans also works quite nicely with Rails
05:05:56 <jpcooper> I might give Netbeans a try
05:05:59 <osfameron> jpcooper: yeah, I find the learning curve of IDEs much steeper than vim + command-line compiler... but when I played with IDEA I was really really impressed.  (And Eclipse isn't bad either)
05:06:17 <ziman> i've never really tried to leard it.
05:06:28 * Saizan doesn't have enough spare ram to run eclipse
05:06:33 <quicksilver> the powerful features of Java IDEs are partly there to compensate for the problems of the language.
05:06:35 <EmielRegis> p_l, who would like to code in java anyway?
05:06:41 <quicksilver> however, there is plenty we could learn from
05:06:56 <osfameron> quicksilver: partly, true
05:06:56 <quicksilver> renaming a class and having it automatically renamed everywhere that references it.
05:07:03 <SamB> p_l: but does it do snakes on a plane ?
05:07:05 <p_l> EmielRegis: When I *have* too, NetBeans certainly makes it easier to cope with
05:07:06 <quicksilver> I'd love that (for haskell module names)
05:07:22 <vixey> EmielRegis, I would if it was well suited to whatever programming task I wanted to do
05:07:46 <p_l> SamB: I though Java was worse than snakes on a plane (never watched the movie, I'd get mad the same way I get mad at Java)
05:07:49 <quicksilver> vixey: yes, but the question is, are there any tasks for which java is the most suited ? ;)
05:08:07 <quicksilver> probably only those which involve interacting with large legacy java libraries.
05:08:13 <EmielRegis> vixey, yea its probably useful for some stuff, like web applets. Yet, I think java is kind of language for dumb coders
05:08:20 <EmielRegis> and its slooow
05:08:25 <ziman> giant business apps that are half-written in the libs already?
05:08:46 <vixey> EmielRegis, not sure what that could actually mean
05:08:54 <SamB> p_l: I'm talking about the fictional web framework ;-P
05:09:07 <vegai> this is odd. I have an application that takes socket connections in in several threads
05:09:08 <SamB> @quote ruby on rails
05:09:09 <lambdabot> No quotes for this person. I feel much better now.
05:09:15 <SamB> @quote rails
05:09:16 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
05:09:31 <vegai> I make sure that all of those sockets are closed with sClose when the application quits. But when I restart the app immediately, I get  bind: resource busy (Address already in use)
05:09:36 <EmielRegis> vixey, like everything in java is made to be dumb-proof - its like C++ with every more advanced bit abstracted from the coder
05:09:50 <jpcooper> maybe there should be more of a movement for developing a SLIME analogue for Haskell
05:09:59 <badsheepy> where more advanced generally means dangerous and naughty :o
05:10:00 <SamB> EmielRegis: and all the stupidest stuff gone
05:10:02 <vegai> hey... is there a closing action for a bind as well?
05:10:06 <ben> EmielRegis: I like to think it is not meant to target "dumb coders", but the common denominator :S
05:10:13 <vixey> EmielRegis, I disagree, there are still crap buggy programs written in java
05:10:30 <p_l> SamB: ... ok
05:10:32 <quicksilver> vegai: compiled app or running in ghci?
05:10:33 <EmielRegis> vixey, of course there are, you can write crappy code in every language :D
05:10:34 <vixey> EmielRegis, probably less than C++ but still, too many
05:10:54 <badsheepy> a language which you have to be smart to use can hardly claim to be effective imo :o
05:10:56 <EmielRegis> samb, I probably quite like 'the stupidest stuff' you point to in C
05:10:56 <quicksilver> jpcooper: there is such a movement.
05:10:58 <vegai> quicksilver: compiled
05:10:59 <EmielRegis> or C++
05:11:00 <quicksilver> jpcooper: it's called "shim"
05:11:11 <ben> EmielRegis: I do not think it is about crappy programs, it is about getting entangled by crappy and confusing language semantics
05:11:11 <jpcooper> well more people should work on it :)
05:11:14 <quicksilver> vegai: that's odd. All the sockets should be freed by the OS when the program dies.
05:11:15 <SamB> EmielRegis: you like SIGSEGV then ?
05:11:18 <vixey> badsheepy, not at all, you have to be very focused to program well in any language at all
05:11:21 <quicksilver> vegai: (even if you forget to close them
05:11:42 <badsheepy> most people care very little about programming well, and care more about it actually being done
05:11:47 <badsheepy> and for that, java is lovely :)
05:11:51 <EmielRegis> samb, every non-managed code has that
05:11:54 <quicksilver> vegai: maybe your kernel takes a moment to clear the tables? wait a couple of seconds and try again
05:11:55 <ben> badsheepy: so is perl
05:11:59 <badsheepy> indeed
05:12:09 <badsheepy> i wasnt meaning to single out java hehe
05:12:31 <ben> vegai: Hi, the behaviour you are getting is some sort of stupid security feature, there is a flag you can set on the socket to prevent it
05:12:32 <vegai> quicksilver: yes, the sockets are available after a short while.
05:12:45 <aeolist> where is cabal for debian testing may i ask?
05:12:52 <quicksilver> vegai: sounds like something to do with your kernel its TCP stack rather than your application. I could be wrong.
05:13:06 <quicksilver> badsheepy: I don't think java is that good for 'getting things done'
05:13:06 <vegai> quicksilver: yes, could be
05:13:12 <ben> vegai: It is SO_REUSEADDR in C
05:13:14 <vegai> ben: ah, thanks
05:13:20 <EmielRegis> samb, and actually I prefer to manually handle memory allocation, than have a GC stopping your threads once in a while
05:13:32 <quicksilver> too much boilerplate code.
05:13:37 <vegai> ben: yes, the SocketOption type has that too
05:13:40 <SamB> EmielRegis: get out!
05:13:49 <EmielRegis> lol
05:13:51 <badsheepy> it has a lot of stuff which has been done in it, which is the ultimate metric for how useful people find it isnt it?
05:13:53 <EmielRegis> GC fails!
05:14:17 <quicksilver> badsheepy: only sort of. They mostly weren't aware of the alternatives.
05:14:17 <vixey> badsheepy, no
05:14:37 <quicksilver> badsheepy: I find it much quicker to 'get stuff done' in perl than java. But I still prefer to use haskell.
05:14:38 <badsheepy> thats implying people are stupid in a deeply patronising way :p
05:14:39 <p_l> vegai: On Linux you can set the kernel to automatically reuse addresses/ports that got "dropped" by the application
05:14:45 <quicksilver> badsheepy: no it's not.
05:14:52 <quicksilver> merely that they don't take the time to learn new technologies
05:14:56 <vegai> ben, p_l: Yep, that was it.
05:14:56 <quicksilver> when they already have one which works for them.
05:15:00 <badsheepy> because its quicker to not sometimes
05:15:01 <quicksilver> that's not really that unreasonable.
05:15:07 <badsheepy> like most of the time you are making a java app :)
05:15:11 <SamB_XP> badsheepy: but people ARE stupid in a deeply patronising way
05:15:32 <quicksilver> I find I get stuff done slightly lower in haskell than perl, but still faster than in java.
05:15:36 <badsheepy> then the language should accommodate stupidity :)
05:15:38 <quicksilver> but I get it done better :)
05:15:56 <p_l> vegai: sysctl net.ipv4.tcp_tw_reuse=1
05:15:56 <quicksilver> and I suspect when my number of hours of haskell programming gets remotely close to my number of hours of perl programming the different will be small, too.
05:16:12 <vixey> what I will never understand is why all these points are raised about java specifically when they apply to so many other languages
05:16:29 <SamB_XP> vixey: well, people don't use the other languages so much
05:16:30 <quicksilver> only because it's the famous heavily used one.
05:16:30 <p_l> vegai: Very useful when you interrupt the application
05:16:41 <SamB_XP> and we don't all have our noess rubbed in them either
05:17:09 <SamB_XP> er. noses
05:17:21 <p_l> vixey: Also because of the breath of (often badly designed) libs and bad practices?
05:17:36 <SamB_XP> bad lib breath ?
05:17:59 <vixey> p_l, ... which applies to so many other languages
05:18:16 <acidjnk> Can I in GHC view the definition of a built-in function like fst?
05:18:27 <mmorrow> ) go = function(cont){while(cont=cont()){}}; f = function(x,y,z){var k=function(){if(x>z)return(undefined);x+=y;return(k)};go(k);return(x)}; f(0,7,1000000)
05:18:28 <lunabotjs>  1000006
05:18:28 <vixey> fst (x,_) = x
05:18:45 <p_l> vixey: I somehow doubt any other language helped XML idiocy spread so far
05:19:01 <quicksilver> acidjnk: no, not unless you downloaded the source.
05:19:05 <mmorrow> if javascript had proper tailcall optim and a less verbose ("function...") way to write lambdas, it'd be friggin great
05:19:11 <acidjnk> Ok, thanks.
05:19:42 <p_l> vixey: Though that is probably in big part thanks to all those tools that would read a Java object and create XML serialization
05:19:55 <acidjnk> Can I trace the single steps of an evaluation, for example how sum [1,2,3] is evaluated step by step?
05:20:06 <vixey> p_l, if everyone used Lisp there would be no need for XML of course
05:21:14 <p_l> vixey: If everyone took a class on parsing or on proper language/fileformat design <-- fixed
05:21:56 <p_l> Even XML looks much better when you don't create it by auto from your internal datastructure
05:22:05 <vixey> you get courses on fileformat design?
05:22:28 <mmorrow> yeah, i think microsoft gives those..
05:22:53 <vixey> weird
05:22:54 <p_l> vixey: Unfortunately there doesn't seem to be one... at least not where I'm studying. I'm going to take a compiler class, though
05:23:14 <vixey> p_l, so I'm not sure why you think fileformat design would help
05:23:40 <SamB_XP> there OUGHT to be classes on file format design
05:23:46 <p_l> the thing with XML is that oh-so-many people just scream "Go XML, we won't have to write parser then!"
05:24:22 <vixey> Those people should be forced to read the XML specification
05:24:39 <SamB_XP> and there ought to be combinator libraries to support real binary formats, including those with various offsets ...
05:24:49 <rog_> you have to write a parser even if you're using XML
05:25:12 <SamB_XP> and parsing XML trees is even more fun than parsing text
05:25:14 <rog_> it's just the tokens are xml items
05:25:24 <p_l> And then they create their XML by using an automated tool to create XML from internal datastructures. If you want an *usable* XML, write your schema, *thinking* from the point of data you are representing in the *schema*, not in your internal *datastructure*
05:25:41 <ben> Also include lots of asterisks
05:25:49 <p_l> ;-)
05:26:11 <SamB_XP> p_l: well, at least that's better than writing structs directly into files ...
05:26:30 <p_l> SamB_XP: EBML seems a nice base for a binary format though
05:26:37 <rog_> and the problem with most things that make xml parsing somewhat easier is that they rely on reading the whole thing into memory
05:26:56 <SamB_XP> rog_: I still don't see how else to do it
05:27:25 <SamB_XP> how can you lazily parse it without throwing an exception on parse error ?
05:27:49 <quicksilver> SamB_XP: you can believe that some other part of the system has already guaranteed the XML valid
05:27:55 <thoughtpolice> @tell Lemmih sorry about the LHCVersion thing; fixed
05:27:56 <lambdabot> Consider it noted.
05:28:33 <rog_> SamB_XP: i wrote a little library (in CL) that did pattern matching on a stream of XML. the structure of the lisp matched the structure of the XML.
05:29:04 <rog_> SamB_XP: i don't know why more people don't do something similar.
05:29:17 <SamB_XP> well, it's hard to do that in Java
05:29:53 <vixey> SamB_XP: no it isn't
05:30:02 <rog_> SamB_XP: anyway, what's wrong with throwing an exception on a parse error? it seems reasonable enough to me, if you accept that you want to stream (in my case the files were GB in size)
05:30:26 <SamB_XP> rog: yes, but, who is supposed to catch it ?
05:30:53 <SamB_XP> vixey: when did they add macros to Java ?
05:31:03 <rog_> SamB_XP: i guess it's hard to make the syntax nice in java (it's particularly nice in lisp), but i think the approach could work ok.
05:32:09 <rog_> FWIW, here are some examples: http://common-lisp.net/project/cl-xmlspam/examples.txt
05:32:54 <rog_> http://common-lisp.net/project/cl-xmlspam/examples.txt
05:32:56 <rog_> oops
05:33:11 <rog_> @pl \ (a, (b, _)) -> (a, b)
05:33:12 <lambdabot> uncurry ((`ap` snd) . (. fst) . (const .) . (,))
05:33:27 <rog_> surely there's an easier point-free way of doing that?!
05:33:42 * abbe has pasted his first haskell code at http://hpaste.org/12397
05:33:43 <vixey> @pl \(x,y) -> (id x,snd y)
05:33:43 <lambdabot> second snd
05:33:44 * BeelsebobWork wins the "silliest heap profile ever" contest... http://www.cs.kent.ac.uk/people/rpg/tatd2/Reactive.pdf
05:33:46 <abbe> any comments about that ?
05:33:50 <lambdabot> Title: cache:http://www.cs.kent.ac.uk/people/rpg/tatd2/Reactive.pdf - Google Search
05:33:55 <vixey> > (second snd) (1, (2, 3))
05:33:57 <lambdabot>   (1,3)
05:34:04 <vixey> > (second fst) (1, (2, 3))
05:34:05 <lambdabot>   (1,2)
05:34:34 <SamB_XP> vixey: I was going to say ... shouldn't that have been fst ?
05:34:55 <lilac> BeelsebobWork: did i read that you'd fixed the reactive tetris leak?
05:35:14 <BeelsebobWork> lilac: I didn't -- I thought I did -- it turned out conal did in a stealth patch though :D
05:35:23 <SamB_XP> lilac: yes, he had the mole shot
05:35:24 <BeelsebobWork> I did reduce CPU usage though :)
05:35:32 <rog_> vixey: i wonder why the original example didn't come up with that solution.
05:35:45 <vixey> pl source code is around
05:35:53 <vixey> @where lambdabot
05:35:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
05:35:59 <lilac> BeelsebobWork: hehe :)
05:35:59 <vixey> I don't know how it works
05:36:00 <SamB_XP> vixey: probablt not all that enlightening though
05:36:13 <luqui> does the new parallel gc mean that it runs while your program is running, or that it stops your program but does it's thang using more than one processor?
05:36:15 <vixey> yeah haskell code is impossible to read :p
05:36:48 <SamB_XP> vixey: well, I was just thinking that the list of rules might not exactly tell you why they do what they do
05:36:55 <SamB_XP> I have seen this file before
05:36:56 <rog_> i guess, as with all code, it depends a lot on how difficult the underlying algorithm is...
05:37:07 <luqui> i think complex haskell is pretty impossible to read; i.e. the difficulty of reading is proprotional to the square of the expression size or something...
05:37:18 <SamB_XP> I should think that tracing might be a bit more enlightening than just reading the code
05:37:18 <EmielRegis> indeed
05:37:20 <luqui> in other words: small functions with good names!
05:37:35 <SamB_XP> tracing rule application, I mean
05:37:56 * rog_ still thinks it would be great if you could find out subexpression types just by pointing and clicking
05:38:12 <SamB_XP> rog: sure!
05:38:31 <luqui> rog_, I think there are tons of ways a good haskell ide could be great
05:38:46 <EmielRegis> ye what haskell lacks the most is good ide...
05:39:10 <EmielRegis> any of you tried VisualHaskell?
05:39:12 <BeelsebobWork> luqui: yes, that's what the parallel GC does
05:39:19 <BeelsebobWork> unfortunately :(
05:39:35 <luqui> BeelsebobWork, uh, that was an alternation.  inr?
05:39:37 <lilac> in haskell, you can achieve a lot with a single line. corollary: some single lines are extremely complex
05:39:39 <rog_> luqui: but that feature in particular is something that i find myself often wishing for. the compiler knows.... but it's not telling me!
05:39:51 <BeelsebobWork> luqui: ?
05:40:04 <lilac> BeelsebobWork: the former or the latter?
05:40:12 <BeelsebobWork> oh, sorry, I fail at reading
05:40:18 <BeelsebobWork> yes, the parallel GC stops your program
05:40:22 <BeelsebobWork> then runs on multiple threads
05:40:23 <luqui> aww
05:40:24 <BeelsebobWork> then starts again
05:40:30 <lilac> snd $ luquiQuestion
05:40:58 <thoughtpolice> yeah there is no concurrent collector yet
05:40:59 <BeelsebobWork> filter answer luquiQuestion -- :P
05:41:02 <luqui> lilac, my question was not a product! :-)
05:41:06 <SamB_XP> > luquiQuestion
05:41:07 <lambdabot>   Not in scope: `luquiQuestion'
05:41:08 <lilac> i for one welcome our new parallel gc overlords
05:41:13 <luqui> lilac, luquiQuestion (Right "...")
05:41:14 <thoughtpolice> but there have been many recent improvements to the RTS and parallel sparks
05:41:27 <thoughtpolice> that should make the parallel GC better than 6.10.1 (this is in HEAD)
05:41:42 <thoughtpolice> also, the new codegen changes hit HEAD today as well. :]
05:41:50 <luqui> cool
05:44:26 <BeelsebobWork> hmm, I just found an interesting effect of reactive
05:44:36 <BeelsebobWork> running Reactives in ghci can be problematic
05:44:47 <BeelsebobWork> pressing ctrl-c can leave one of the unamb threads running forever
05:45:44 <lilac> does Ctrl-C raise an exception which unamb can catch and handle?
05:45:46 <DukeDave> Oh noes, Cabal fail:
05:45:46 <DukeDave> /usr/bin/ld: cannot find -lgmp
05:46:28 <lilac> DukeDave: sounds like you need to install libgmp3-dev or similar
05:46:31 <luqui> DukeDave, do you have gmp installed?
05:46:45 <DukeDave> Eh
05:47:14 <DukeDave> Okay so lilac no I did, but I'm confused as to why it's needed :|
05:47:36 <luqui> DukeDave, gmp is how ghc implements the Integer type
05:47:46 <luqui> > 42^21
05:47:47 <lambdabot>   12252793050782200016679467841748992
05:48:07 <DukeDave> Brr, okay
05:48:11 <lilac> DukeDave: whichever package cabal was installing needs it, and cabal's not great at handling external dependencies yet
05:48:12 <DukeDave> I'll just accept that :)
05:48:26 <DukeDave> lilac: I was actually installing Cabal   :)
05:48:32 <lilac> you'd see a similar problem when installing the zlib package for instalce
05:48:44 <Lanjiao> can haxml handle unicode? thanks
05:49:16 <osfameron> rog_: yeah, subtypes of subexpressions would rock
05:49:35 <luqui> or even just types of subexpressions :-)
05:50:40 <malcolmw> Lanjiao: if you can persuade ghc to read and write some specific character encoding, then HaXml will deal with the Unicode characters no problem.
05:52:26 <rog_> that reminds me: is it possible to get ghci 6.10 to output utf-8?
05:52:35 <Lanjiao> malcolmw: how? I am a niewbie to haskell. don't know much, sorry
05:52:36 <rog_> (hi malc)
05:53:33 <BeelsebobWork> lilac: unfortunately... http://www.cs.kent.ac.uk/people/rpg/tatd2/TetrisPeterSpin2.pdf
05:53:35 <lambdabot> Title: cache:http://www.cs.kent.ac.uk/people/rpg/tatd2/TetrisPeterSpin2.pdf - Google Se ...
05:53:37 <BeelsebobWork> conal made it a *lot* better
05:53:43 <BeelsebobWork> but it's still leaking
05:53:53 <BeelsebobWork> in the same functions too
05:54:16 <luqui> rog_, well, you can use the stuff in utf8-string
05:54:58 <thoughtpolice> rog_: yes, use utf8-string
05:57:01 <luqui> System.IO.UTF8.putStrLn $ map chr [1280..1300]
05:57:07 <luqui> ԀԁԂԃԄԅԆԇԈԉԊԋԌԍԎԏԐԑԒԓ
05:59:39 <lilac> BeelsebobWork: any idea what's leaking there?
05:59:57 <BeelsebobWork> lilac: not off the top of my head at the moment, no
06:00:20 <BeelsebobWork> I'll have a chat with conal when he comes on later today
06:01:03 <Lanjiao> luqui: Could not find module `System.IO.UTF8'
06:01:12 <Lanjiao> luqui: how to load it?
06:01:39 <Lanjiao> i am using the latest ghc
06:02:03 <luqui> Lanjiao, cabal install utf8-string
06:04:52 <C-Keen> ~~.
06:04:58 <C-Keen> oops
06:05:12 <Lanjiao> luqui, thanks
06:05:15 <luqui> > let x = repeat in x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x $ 42
06:05:16 <lambdabot>       Context reduction stack overflow; size = 20
06:05:16 <lambdabot>      Use -fcontext-stack=N ...
06:05:33 <luqui> > let x = repeat in x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x $ (42::Int)
06:05:34 <lambdabot>       Context reduction stack overflow; size = 20
06:05:35 <lambdabot>      Use -fcontext-stack=N ...
06:06:18 <Axman6> > let x = repeat in x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x $ 42
06:06:19 <lambdabot>   [[[[[[[[[[[[[[[[[42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,4...
06:06:41 <luqui> so it overflows trying to find the Show instance for [[[[[[[[[[[[[[[[[[[[[[Int]]]]]]]]]]]]]]]]]]]]]]
06:07:10 <Axman6> :t let x = repeat in x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x $ 42
06:07:11 <lambdabot> forall a. (Num a) => [[[[[[[[[[[[[[[[[a]]]]]]]]]]]]]]]]]
06:07:19 <Axman6> :t let x = repeat in x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x $ 42
06:07:21 <lambdabot> forall a. (Num a) => [[[[[[[[[[[[[[[[[[a]]]]]]]]]]]]]]]]]]
06:07:26 <Axman6> :t let x = repeat in x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x $ 42
06:07:27 <lambdabot> forall a. (Num a) => [[[[[[[[[[[[[[[[[[[[[[[[[a]]]]]]]]]]]]]]]]]]]]]]]]]
06:08:08 <luqui> :t  let x = repeat in show.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x $ (42::Int)
06:08:09 <lambdabot> Top level:
06:08:09 <lambdabot>     Context reduction stack overflow; size = 20
06:08:09 <lambdabot>     Use -fcontext-stack=N to increase stack size to N
06:08:17 <luqui> yep
06:09:29 <vixey> :t let a = return ; b = a.a ; c = b.b ; d = c.c ; e = d.d in a ()
06:09:30 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
06:09:38 <vixey> > let a = return ; b = a.a ; c = b.b ; d = c.c ; e = d.d in a ()
06:09:39 <lambdabot>       No instance for (Show (m ()))
06:09:39 <lambdabot>        arising from a use of `show' at <i...
06:09:52 <vixey> :t let a = return ; b = a.a ; c = b.b ; d = c.c ; e = d.d in show (a ())
06:09:53 <lambdabot>     No instance for (Show (m ()))
06:09:53 <lambdabot>       arising from a use of `show' at <interactive>:1:58-68
06:09:53 <lambdabot>     Possible fix: add an instance declaration for (Show (m ()))
06:10:15 <luqui> :t let a = (:[]) ;  b = a.a ; c = b.b ; d = c.c ; e = d.d in a ()
06:10:16 <lambdabot> [()]
06:10:25 <Saizan> you're using a at the end..
06:10:34 <luqui> ah that also
06:10:37 <luqui> :t let a = (:[]) ;  b = a.a ; c = b.b ; d = c.c ; e = d.d in e ()
06:10:39 <lambdabot> [[[[[[[[[[[[[[[[()]]]]]]]]]]]]]]]]
06:10:53 <luqui> :t let a = (:[]) ;  b = a.a ; c = b.b ; d = c.c ; e = d.d in show $ e ()
06:10:55 <lambdabot> String
06:10:59 <luqui> oh duh
06:11:21 <hackage> Uploaded to hackage: simple-reflect 0.1
06:11:22 <vixey> haha
06:11:23 <luqui> :t let a = (:[]) ;  b = a.a ; c = b.b ; d = c.c ; e = d.d ; f = e.e in e ()
06:11:24 <lambdabot> [[[[[[[[[[[[[[[[()]]]]]]]]]]]]]]]]
06:11:28 <luqui> :t let a = (:[]) ;  b = a.a ; c = b.b ; d = c.c ; e = d.d ; f = e.e in f ()
06:11:29 <lambdabot> [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[()]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
06:11:38 <luqui> let a = (:[]) ;  b = a.a ; c = b.b ; d = c.c ; e = d.d ; f = e.e in f ()
06:11:45 <daf> do do do the robot monkey
06:11:46 <luqui> > let a = (:[]) ;  b = a.a ; c = b.b ; d = c.c ; e = d.d ; f = e.e in f ()
06:11:47 <lambdabot>       Context reduction stack overflow; size = 20
06:11:47 <lambdabot>      Use -fcontext-stack=N ...
06:12:00 <luqui> alright there.  finally.
06:12:17 <luqui> I don't like that it does this
06:12:23 <luqui> even if it has never bit me (yet)
06:16:09 <byorgey> that actually happened to me once while editing my xmonad configuration
06:16:44 <byorgey> pretty annoying.
06:18:11 <coryknapp> ... Hello everyone? (new here)
06:19:11 <sebaseba> hello
06:20:08 <sebaseba> @quote
06:20:08 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
06:20:15 <rog_> luqui: i didn't mean in general; i meant for diagnostics etc.
06:20:50 <thoughtpolice> megaolegs??!?!
06:20:52 * thoughtpolice fears
06:20:53 <vixey> @quote
06:20:54 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
06:20:57 <vixey> @quote
06:20:57 <lambdabot> pjd says: clearly you lack pessimism
06:21:09 <vixey> hi coryknapp
06:21:09 <vixey> @quote
06:21:10 <lambdabot> ihope says: Laziness is free, but it doesn't always pay off.
06:21:21 <pjdelport> o.O
06:22:10 <vixey> @quote
06:22:11 <lambdabot> LarryWall says: <TimToady> learning Haskell itself is easy--I've done it several times already
06:22:13 <vixey> @quote
06:22:14 <lambdabot> mmorrow says: in langs with dependent types, you can just map numbers directly to types instead of having to ride a unicycle along a tightrope while battling an unruly gang of monkey with knives
06:22:45 <rog_> luqui: i.e. if i define a variable/type with a unicode name, can i get ghci to print it out correctly when i do (for instance) :type
06:22:57 <luqui> ah.  no experience with that.
06:23:28 <hesselink> :r
06:24:03 <rog_> luqui: after all, haskell code is notionally unicode text, but this problem means that for practical purposes, it's not possible to have haskell identifiers containing unicode characters.
06:24:19 <rog_> ... which seems a pity
06:24:20 <pjdelport> unicode type names?  brings a whole new meaning to typography...
06:24:30 <daf> pjdelport: groan
06:24:47 <pjdelport> daf: a typical response
06:25:10 <rog_> lots of papers use alpha, beta, gamma etc for type variables. it'd be nice to be able to do that.
06:25:22 <Axman6> pjdelport: quit while you're behind
06:25:37 <vixey> well you can still do it in papers
06:25:49 <rog_> :-)
06:25:51 <luqui> "groan" must mean "I find that hillarious!"
06:26:20 <luqui> I get that response a lot when I'm funny.
06:26:31 <rog_> i was sure somebody a month ago or so said "oh yes, that'll be fixed in 6.10"
06:26:53 <pjdelport> Axman6: apologies, i'll take my signature humor elsewhere
06:26:54 <Saizan> rog_: don't wait someone to fix! take action!
06:26:58 <Saizan> :)
06:26:59 <pjdelport> i don't want to be typecasted
06:27:08 <Axman6> >_<
06:27:15 <Axman6> ok, now you're ahead
06:27:33 <vixey> hahaha
06:27:46 <rog_> Saizan: i have a feeling that if it hasn't been done, there's a good reason for it! (i.e. it's difficult - or it involves making a tricky and/or irreversible design decision)
06:27:56 <rog_> Saizan: 'cos in principle it should be trivial.
06:28:24 <Axman6> "How can we check to see if our number is zero or not in haskell", "can we typecast it, like in C?" "NOOOOO!"
06:28:41 <Axman6> -- Clem Baker Finch, and my friend during a lecture
06:29:23 * rog_ does think that the maze of numeric type classes in haskell is a bit over the top.
06:29:45 <Saizan> ?bug
06:29:46 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
06:30:07 <rog_> Saizan: TICKET_CREATE privileges are required to perform this operation
06:30:22 <luqui> rog_, not compared to the proposed numeric prelude!
06:30:47 <rog_> luqui: ref?
06:31:17 <luqui> rog_, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric-prelude
06:31:28 <lambdabot> Title: HackageDB: numeric-prelude-0.0.5, http://tinyurl.com/5nu5yc
06:31:51 <Saizan> rog_: uhm, it's supposed to be fixed http://hackage.haskell.org/trac/ghc/ticket/2302
06:31:53 <lambdabot> Title: #2302 (error messages mangle unicode characters) - GHC - Trac
06:33:52 <rog_> Saizan: hmm. it does seem to work when i try it now. i don't know what i was doing before.
06:34:31 <rog_> Saizan: no, it's still bugged
06:34:44 <rog_> *Scenarios> :type α
06:34:44 <rog_> � :: Integer
06:35:13 <rog_> although the error messages seem to work ok
06:35:46 <Saizan> ah, yeah, they fixed the error messages but not the normal ones..
06:37:06 <Saizan> so i guess it's not hard to fix after all
06:37:46 <rog_> i wonder how it's possible to fix one without fixing the other
06:37:54 <rog_> seems odd to me
06:38:43 <Saizan> they came from different sources, probably
06:39:28 <Saizan> and someone isn't following the "unicode as internal representation, convert on I/O" policy :)
06:40:26 <vixey> rog++
06:41:20 <rog_> the internal representation does seem to be unicode (otherwise identifiers wouldn't be identified correctly). i guess i've been spoilt by an environment where it's almost impossible to get it wrong.
06:41:24 <rog_> vixey: ?
06:43:53 <Saizan> rog_: btw, you can login as guest/guest to report a bug
06:44:43 <rog_> Saizan: i've registered and reported it.
06:45:29 <Saizan> rog_: number?
06:46:40 <rog_> Saizan: #2816
06:50:36 <m4dnificent> Hello, I'm learning haskell here (at school).  I have created a class Sequentie, which declares some methods.  Now I wanted to instantiate this class for all instantiations of Enum.  I tried something like: instance (Enum a) => Sequentie a where ... but apparantly this isn't valid
06:52:17 <thoughtpolice> m4dnificent: please post the code and any error messages you're getting
06:52:21 <m4dnificent> I've tried to search the answer on wikibooks and asked it to the one teaching me, but neither could provide me with an answer (the teacher didn't know the answer, and it isn't really homework).  Therefore, I'm trying my luck here.
06:52:42 <rog_> is there a more conventional way of saying "return ()" for an empty operation in the IO monad?
06:52:59 <idnar> I don't think there's any other way to do that
06:53:00 <conal> rog_: mempty, if you use TypeCompose
06:53:09 <idnar> ah
06:53:14 <conal> The IO *monoid*
06:53:28 * rog_ goes to look at TypeCompose
06:53:46 <conal> what's even cooler, is that for 'const (return ())', you can also just say mempty
06:53:49 <Axman6> maybe a function unit = return () could be handeh for clarity
06:53:53 <conal> and so on for as many arguments as you please
06:54:01 <Axman6> :t let unit = return () in unit
06:54:02 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
06:54:08 <vixey> Axman6, no
06:54:16 <conal> Axman6: 'unit' is often a synonym for 'return'
06:54:28 <Axman6> :\
06:54:28 <conal> Axman6: unit/join
06:54:32 <quicksilver> I quite like "skip = return ()"
06:54:43 <conal> yeah.  'skip' is a classic name.
06:54:45 <quicksilver> m4dnificent: it shouldn't be invalid, but you can't really do it.
06:54:51 <conal> though i prefer 'mempty' !
06:54:51 <Axman6> ok, well the name was by no means important...
06:55:03 <quicksilver> m4dnificent: instance Foo a => Bar a is valid with Flezible instances but it still doesn't mean what you want.
06:55:16 <m4dnificent> pasted it
06:55:19 <m4dnificent> http://hpaste.org/12398 << here
06:55:26 <luqui> "pass" as a tip of the hat to python?
06:55:35 <rog_> i'm not that keen on "skip". associated with bad memories of school :-)
06:55:49 <quicksilver> conal: there is a merit in specific names, as well as a merit in generic ones.
06:55:54 <quicksilver> it's a balance.
06:56:01 <Axman6> i can count on one hand the number of lectures i've missed in uni
06:56:11 <quicksilver> luqui: I'm damned if I'll tip my hat at python :P
06:56:14 <conal> quicksilver: agreed
06:56:22 <m4dnificent> quicksilver: Flezible instances?
06:56:38 <luqui> m4dnificent, no, you just can't do that.
06:56:39 <quicksilver> m4dnificent: FlexibleInstances is a GHC extensions which permits the syntax you gave.
06:56:46 <quicksilver> but it still doesn't give the meaning you wanted.
06:56:52 <samll> m4dnificent, Sequence (Enum a) ?
06:56:53 <rog_> quicksilver: i agree. when something is in fact specific in a piece of code, i think it really helps me to be able to read it if the specific operation is actually used
06:57:13 <rog_> e.g. i prefer to use map not fmap when i know it's a list
06:57:20 <quicksilver> it will mean, instead: *all* types are members of Sequentie, but also add an Enum constraint to the current context.
06:57:33 <quicksilver> which is not what you asked for.
06:57:54 <quicksilver> you need OverlappingInstances if you want to give a general instance and then some overlapping specific ones.
06:57:59 <m4dnificent> samll: that gives an undefined type constructor error (that was my first try)
06:58:00 <quicksilver> and OverlappingInstances is a bad thing.
06:58:16 <luqui> it's strange.  eg. the (fmap.fmap.fmap) thing has grown on me; just penetrating three boxes more than eg. (map . fmap), which requires more brainpower
06:58:23 <jsn> quicksilver: well, that's an oversimplification
06:58:35 <quicksilver> jsn: which part ?
06:58:35 <luqui> but a lot of times the more specific thing helps
06:58:53 <jsn> quicksilver: OverlappingInstances are not a "bad thing" in general
06:59:01 <quicksilver> jsn: instance selection is pretty complex, I'm not about to describe the entirety of GHC's extended instance selection algorithm in the format of an IRC channel.
06:59:05 <quicksilver> jsn: Yes, they are.
06:59:05 <vixey> can (fmap.fmap.fmap) be a zipper
06:59:15 <quicksilver> jsn: "bad" is a subjective notion, and hence I am giving my opinion.
06:59:27 <samll> so, Enum is a class and Sequentie is a class. and you want to say that anything that is an instance of Enum should be an instance of Sequentie?
06:59:33 <quicksilver> Overlapping instances break modularity and compositionality and hence are evil.
06:59:51 <luqui> vixey, uh... I don't even know what you mean.  Do you mean zipper as in "zip", or zipper as in data structure context
06:59:56 <m4dnificent> samll: yes
07:00:01 <samll> that's like Enum being isomorphic to Sequentie
07:00:01 <vixey> zipper
07:00:02 <rog_> it wouldn't be so difficult if you could find the actual inferred type for each of the fmaps...
07:00:38 <samll> m4dnificent, try this:   instance Sequentie Enum a where .. without parens. i'm a noob. i might be misleading you
07:00:46 <quicksilver> samll: you are.
07:00:50 <jsn> quicksilver: they allow you to change the behaviour of one module with stuff defined in another, sure
07:00:51 <luqui> rog_, ;-)
07:00:54 <quicksilver> m4dnificent's syntax is as close as you can get.
07:01:00 <quicksilver> and it works with a GHC extension.
07:01:03 <m4dnificent> samll: syntax error
07:01:07 <quicksilver> as far as I know, it will never work in hugs.
07:01:10 <luqui> samll, yeah, that's no good
07:01:12 <m4dnificent> samll: but your help is very much appreciated
07:01:34 <samll> instance Enum Integer   you have to do something like that
07:01:35 <quicksilver> I don't hink hugs has a 'FlexibleInstances' exception.
07:01:42 <samll> kind should be * i think
07:01:43 <luqui> the truth, which most people do not want to hear, is that Haskell does *not* support superclassing
07:01:47 <quicksilver> jsn: it allows two modules to see different instances for a particular fixed type
07:01:53 <quicksilver> jsn: that is an evil.
07:02:18 <samll> m4dnificent, so probably you have to use GHC
07:02:23 <quicksilver> although it may be that GHC can signal that as a compile error, I'm not sure.
07:02:37 <jsn> quicksilver: if you don't import the additional instances, sure
07:02:47 <m4dnificent> samll: yes, that works, because you can instantiate Int.  But I want to enable this for all Enums, not just for Int. :)
07:03:05 <jsn> but you could get the same effect by importing one module with one instances, and another module with other instances
07:03:06 <quicksilver> jsn: if one module sees only the more general, and the other sees (also) the more specific.
07:03:10 <m4dnificent> luqui: ouch
07:03:12 <jsn> sure
07:03:18 <lilac> m4dnificent: if you're prepared (1) to use GHC extensions, (2) to have no other Sequentie instances than Enums, and (3) to cope with difficult error messages, you can do what you proposed
07:03:19 <quicksilver> jsn: haskell fundamentally relies on one-instance-per-type
07:03:24 <jsn> but being able to define more specific instances is desirable
07:03:28 <lilac> m4dnificent: but in that case, you don't need a typeclass at all
07:03:35 <jsn> quicksilver: haskell relies on it?
07:03:41 <quicksilver> yes.
07:03:46 <quicksilver> it's a fundament of the class system.
07:03:52 <m4dnificent> lilac: quite sad, I have to use hugs (and there are other instances than Enums
07:03:52 <quicksilver> instances are designed to be global.
07:04:03 <quicksilver> without that, for example, Data.Map is broken.
07:04:06 <quicksilver> or Data.Binary.
07:04:17 <quicksilver> or many other non-trivial things which use typeclasses in some interesting way.
07:04:19 <luqui> m4dnificent, yeah, so you can define a bunch of Enum, you just can't get all of them in one go
07:04:28 <jsn> oh i see
07:04:39 <luqui> m4dnificent, one of the problems is, what if someone defined an instance of your class *and* and instance of Enum
07:04:41 <jsn> well maybe managing instances with the module system is not a good idea, then
07:04:42 <luqui> which one would it use?
07:04:48 <quicksilver> jsn: it's not, no ;)
07:05:02 <jsn> but more specific instances are of great practical value
07:05:16 <m4dnificent> luqui: the furthest down the line... which would be called overloading...
07:05:16 <lilac> i suppose it might be possible to fake up an approximation of superclassing with phantom types
07:05:24 <quicksilver> in all the cases I've seen, they are symptoms of people using typeclasses when they shouldn't be doing so.
07:05:49 <quicksilver> I don't exclude the possibility that there is code I haven't seen where a better instance search would be a useful thing.
07:05:55 <lilac> m4dnificent: the key question no-one's asked yet is, what operations will your Sequentie typeclass provide?
07:05:58 <luqui> m4dnificent, one of the invariants of the typeclass system is that you can't change the meaning of an already-compiling program by adding instances.
07:06:06 <m4dnificent> luqui: meaning: the most specific one.  This is basically something object-oriented languages got right
07:06:11 <jsn> in some cases, they are a case of getting around default instances
07:06:41 <jsn> anyways, i understand your point of view now
07:06:43 <luqui> m4dnificent, such specification breaks that invariant.  It's a very nice invariant, which ensures a great deal of modularity.  But it's a pain when you want to do something like this.
07:06:46 <m4dnificent> lilac: vorige and volgende.  As you see in the code, they are actually the equivalent of pred and succ (yes, it's rather lame)
07:08:52 <luqui> The right way to do this would be with a proof obligation.  I.e. if you declare an Enum instance and a Sequentie instance of the same type, you have to prove that they agree
07:08:54 <lilac> m4dnificent: in the cases where you don't have an Enum instance for a type which you want to be a Sequentie instance, can you add an Enum instance?
07:09:00 <luqui> then we could support that arbitrary superclassing nicely
07:09:21 <jsn> luqui: prove or merely certify?
07:09:24 <lilac> luqui: that'd be nifty :)
07:09:51 <luqui> jsn, prove. :-)  usually it will be trivial, as they'll both have the same body or be defined in terms of one another.
07:10:01 <m4dnificent> lilac: well, in this case I guess I could.  It's just mindbreaking that this is impossible in haskell...
07:10:13 <vixey> m4dnificent, typeclasses suck
07:10:15 <lilac> m4dnificent: heartbreaking too :(
07:10:32 <m4dnificent> Im basically staring at the wall before me, trying to realize that haskell has a downside like this...
07:10:37 * quicksilver thinks that drawing analogies between the haskell sense of the word 'class' and the OO sense of the word 'class' (idem subclass/superclass) is asking for miscommunication.
07:10:39 <vixey> m4dnificent, pretty much they let you write + instead of +.
07:10:47 <luqui> jsn, certify is a more practical, less robust way to go.  Either way it'd be okay, though I know people have a tendency to abuse type systems up the wazoo, so proof would be better :-)
07:11:03 <quicksilver> haskell classes are a method for adhoc overloading.
07:11:04 <quicksilver> that's all.
07:11:13 <quicksilver> if you're trying to do something else, they're the wrong tool.
07:11:32 <luqui> m4dnificent, indeed.  there are many things impossible in haskell.  I don't know why you're surprised by this.
07:11:38 <lilac> luqui: well, i'd think a practical type system which allows proofs would inevitably have / grow a back door, so you'd be able to certify rather than prove anyway :)
07:11:39 <luqui> As usual, you have to rewire your brain.
07:11:49 <quicksilver> they're certainly not a method for implentation inheritance or overriding.
07:11:51 <m4dnificent> quicksilver: yes, however this would make the tool a lot more usefull... (I think)
07:11:59 <quicksilver> m4dnificent: it would make it totally different.
07:12:04 <luqui> lilac, heh...
07:12:06 <vixey> lilac, unsafeAssumeHypothesis ?
07:12:06 <quicksilver> m4dnificent: it would become an indistringuishable tool.
07:12:18 <quicksilver> what is the actual problem you wish to solve?
07:12:22 <quicksilver> probably there is another approach ;)
07:12:24 <m4dnificent> luqui: and it hurts!
07:12:27 <luqui> vixey, "Axiom" :-)
07:12:36 * quicksilver wonders what word he meant there.
07:12:48 <quicksilver> certainly not "indistringuishable"
07:12:58 <luqui> lol
07:13:12 <quicksilver> "quite distinct tool" maybe I meant.
07:13:13 * quicksilver shrugs.
07:13:37 <lilac> vixey: i like unsafeAssumeHypothesis :)
07:13:38 <m4dnificent> quicksilver: the programmatical problem is of minor concern.  I had a workaround laying around here... The real pain is me having to cope with this limitation of haskell.  I don't want it to be here :)
07:13:47 <quicksilver> m4dnificent: but it isn't a limitation. HOnestly.
07:13:48 <m4dnificent> thanks for clearing all of this out guys!
07:13:49 <vixey> m4dnificent, It would be nice to figure out how to put a proper relational language to replace typeclasses that has all the coherency and whatever other stuff typeclasses have to satisfy
07:13:56 <lilac> m4dnificent: one option is to add a newtype wrapper
07:13:57 <quicksilver> that's like saying "the problem with this pig is it can't fly"
07:14:07 <jsn> well, hold on
07:14:11 <lilac> m4dnificent: that's what's usually done when there are multiple class instances for a type
07:14:14 <quicksilver> m4dnificent: it is a design decision. it's what typeclasses are.
07:14:16 <m4dnificent> lilac: care to elaborate on that one?
07:14:21 <quicksilver> there are other ways to solve other problems.
07:14:36 <vixey> m4dnificent, that's something been bugging me for ages though.. Is there a description of exactly which wall you ran into?
07:14:50 <luqui> newtype EnumSequentie a = EnumSequentie a;  instance Enum a => Sequentie (EnumSequentie a) where ...
07:15:11 <lilac> m4dnificent: you add 'newtype EnumSequentie e = Enum e => ES e' and then 'instance Sequentie (EnumSequentie e) where '
07:15:14 <luqui> which isn't pretty, but it at least allows it.  you just have to be okay with losing some convenience.
07:15:16 <lilac> right, what luqui said
07:15:26 <jsn> our IRC logs are the worst ever
07:15:35 <luqui> jsn, ... ever?
07:16:00 <badsheepy> for selected levels of ever
07:16:02 <BMeph> quicksilver: "Indistringuishable, n. To lack an ability of being represented in a non-string format." ;)
07:16:19 <Saizan> lilac: you need data to add contexts like that
07:16:31 <quicksilver> BMeph: ;)
07:16:44 <lilac> "instance (forall a. Show a) => Indistringuishable a where dontShow = ..."
07:16:46 <BMeph> Hm, I guess that should be 'adj.', not 'n.' though. :)
07:17:25 <m4dnificent> vixey: the fact that you can't define the methods of classes upon the definition of other classes (instead of instances)
07:17:40 <BMeph> quicksilver: "That's trivial to marshall, it's indistringuishable." :)
07:17:46 <vixey> m4dnificent, o_o ... you can do that
07:17:50 <m4dnificent> lilac, luqui: well, it avoids the code-repetition... so it makes me happy :)
07:18:09 <vixey> m4dnificent, maybe it's not strict H98 or something?
07:18:37 <jsn> luqui: okay, that was exaggerated
07:18:45 <m4dnificent> vixey: then why can't I define how Sequentie should work for Enum's?
07:19:07 <vixey> m4dnificent, not sure what either of those are. Not using GHC?
07:19:08 <lilac> m4dnificent: because if you did that, you wouldn't need the Sequentie typeclass
07:19:31 <vixey> actually I have heard of Enum before somewhere
07:19:32 <lilac> you could just say vorige = pred; volgende = succ
07:19:48 <luqui> :t \x -> [x..]
07:19:49 <lambdabot> forall t. (Enum t) => t -> [t]
07:19:58 <Saizan> vixey: he means defining instance Enum e => Sequentie e where ... which is possible but bad practice
07:19:59 <lilac> vixey: Enum is one of the derivable typeclasses
07:20:16 <luqui> now _that_ is a wart.
07:20:26 <luqui> the whole deriving() business
07:20:33 <vixey> deriving is great
07:20:47 <luqui> it is great, in the same way perl is great
07:20:52 <luqui> it's a giant useful hack
07:20:59 <vixey> It's irritating that there is no way to add new ones though
07:21:04 <lilac> i like deriving, except for the inability to say 'here's how to derive my typeclass'
07:21:31 <lilac> it should /not/ require a compiler extension to support deriving Data and Typeable
07:21:43 <vixey> it is a compiler extension :)
07:21:47 <luqui> I don't know aobut that, actually.
07:21:59 <luqui> Typeable is an *intensional* idea
07:22:03 <quicksilver> typeable should preferably be implemented by the compiler
07:22:09 <quicksilver> so that it can't cheat.
07:22:52 <thoughtpolice> this is why I have gone to using the derive lib :]
07:24:41 <luqui> the more I think about typeclasses, the more they start to stink.  they are only beautiful on the surface.
07:25:11 * quicksilver doesn't think they stink.
07:25:16 <quicksilver> but they are very much over-used.
07:25:26 <jsn> i think they need to be even more used
07:25:37 <jsn> like String and ByteString should both be classes
07:25:42 <vixey> luqui, any ideas for a replacement?
07:25:45 <luqui> it seems to me that not only should a type class only be allowed to have one instance in a program
07:25:56 <lilac> i have a half-baked theory that we'd be better off with ad-hoc overloading and type-level functions but no typeclasses
07:26:03 <luqui> but it should only be allowed to have once instance *ever*.  i.e. there should only be one correct instance for any given type.
07:26:08 <quicksilver> luqui: definitely.
07:26:23 <quicksilver> luqui: typeclass uniqueness is global, international, and for all eternity.
07:26:30 <jsn> i've got like three different ByteString types floating around in a program
07:26:42 <luqui> quicksilver, which disallows things like Dual in Data.Monoid.
07:26:49 <jsn> they all have the same interface -- there should be a straightforward to mangle that
07:26:51 <quicksilver> luqui: there is only one Num instance for Int. In the whole world. Ever.
07:27:16 <quicksilver> jsn: a type-indexed interface is what typeclasses are good at.
07:27:18 <jsn> quicksilver: you can't really have that -- how would people improve or change anything?
07:27:26 <quicksilver> perfectly reasonable to use it for that.
07:27:37 <quicksilver> as long as you do want it to be type-indexed.
07:27:39 <rog_> quicksilver: i suppose that does imply that any instance is a perfect implementation - i.e. there are no performance trade-offs to make
07:27:42 <quicksilver> :i Dual
07:27:46 <quicksilver> :t Dual
07:27:48 <lambdabot> forall a. a -> Dual a
07:27:57 <quicksilver> luqui: Dual is a newtype, though, that's OK.
07:28:07 <luqui> but there is more than one possible instance for it
07:28:13 <quicksilver> is there?
07:28:22 <luqui> mempty = Dual mempty ; mappend (Dual a) (Dual b) = Dual (a `mappend` b)
07:28:27 <lilac> heck, there's more than one possible instance for Num Int, but the others are pretty wacky
07:28:54 <quicksilver> luqui: ok that's one. What's the other?
07:28:58 <vixey> @instances Num
07:28:59 <lambdabot> Double, Float, Int, Integer
07:29:05 <Saizan> luqui: that's useless..
07:29:07 <quicksilver> luqui: oh, I see.
07:29:10 * quicksilver shrugs
07:29:15 <quicksilver> but that's not the point.
07:29:21 <luqui> Saizan, but it obeys the laws.
07:29:24 <quicksilver> the instance is the b `mappend` a one
07:29:32 <luqui> and is distinct from the actual instance
07:29:48 <luqui> which is what i'm arguing should not happen.  not really arguing.  more like feeling.
07:29:54 <luqui> I might come up with a strong argument someday
07:30:04 <lilac> i wonder whether we'd be better off naming the instances and not having implicit type <-> instance maps
07:30:15 <Saizan> luqui: ok, so no instance for Monoid is allowed ever, since mempty=undefined;mappend=undefined holds
07:30:22 <BMeph> luqui: Better wait a while if you do; it might just be indigestion. ;)
07:30:37 <lilac> Saizan: that's not an instance since mappend mempty != id
07:30:38 <Saizan> lilac: that's ML functors
07:30:49 <lilac> Saizan: how do they work out?
07:30:50 <luqui> BMeph, sure.  it's been a while that i've been developing this.
07:30:59 * rog_ can imagine several possible possible implementations for Num Integer, involving different ways of doing (for instance) multiplication
07:31:03 <luqui> I have a feeling that for things like this some sort of implicit parameter system would be better.
07:31:06 <quicksilver> lilac: then they're just tuples of higher order functions.
07:31:10 <lilac> i also wonder whether C++ concepts are better than Haskell typeclasses
07:31:22 <quicksilver> lilac: which is fine; I use tuples and other structures of higher order functions all the time
07:31:32 <luqui> i.e. more like mathematics.  "mappend" on integers doesn't make sense.  You say "mappend, by the monoid formed by addition"
07:31:40 <quicksilver> in fact when I say "typeclasses are overused" what I mean is "people should just use higher order functions more often"
07:31:58 <lilac> quicksilver: what i'd like to know is whether they're actually problematic compared to typeclasses
07:32:00 <luqui> they are often more composable
07:32:06 <quicksilver> lilac: not remotely.
07:32:14 <quicksilver> they are a simpler and more flexible concept.
07:32:21 <Saizan> luqui: and what's the problem with using a newtype for that, like Sum/Prod?
07:32:22 <rog_> i find it easier to use higher order functions than type classes
07:32:25 <luqui> typeclasses compile down to passing HOFs around
07:32:28 <lilac> luqui: right. Int isn't a Monoid and [] isn't a Monad
07:32:33 <quicksilver> luqui: that's one implementation.
07:32:47 <vixey> [] is a monad ?
07:32:58 <quicksilver> but the critical difference is that typeclasses involve selecting the dictionary by looking up the type.
07:33:08 <luqui> quicksilver, I suppose I could mean, you can straightforwardly translate any program with typeclasses to a program with dictionary passing
07:33:12 <lilac> luqui: but you lose a lot of convenience if you stop saying "when i say Monad wrt [] I mean the concatMap monad"
07:33:14 <quicksilver> so typeclasses are when you want the type inference engine to select the HOFs for you.
07:33:22 <quicksilver> sometimes that is a useful thing.
07:33:30 <quicksilver> but often it's not necessary.
07:33:30 <jsn> vixey: yes
07:33:36 <luqui> lilac, yeah, if you are used to thinking in a box :-)
07:33:49 <quicksilver> luqui: yes.
07:33:52 <luqui> lilac, convenience is a human thing.  we can make tools
07:34:03 <lilac> luqui: in other languages, i'd say some other type than [] when i want concatMap semantics
07:34:16 <luqui> this is probably related to the anti-text revolution I call for.
07:34:26 <thoughtpolice> @tell Lemmih did you check my mailing list post? any thoughts or ideas on that front?
07:34:27 <lambdabot> Consider it noted.
07:34:28 <lilac> in the same way that i'd say MaxAccumulator and SumAccumulator or whatnot
07:34:32 <quicksilver> (I'm stating the obvious, but:) a monad is a triple (T, unit, join)
07:34:35 <jsn> > do { a <- [0..4] ; b <- ['a'..'d'] ; return (a, b) }
07:34:37 <lambdabot>   [(0,'a'),(0,'b'),(0,'c'),(0,'d'),(1,'a'),(1,'b'),(1,'c'),(1,'d'),(2,'a'),(2...
07:34:41 <vixey> How come the anti-text people release so little code I can use? :P
07:34:44 <quicksilver> indeed one school of mathematics uses that name for them
07:34:48 <BMeph> luqui: Sounds like you should bring back ISWIM. :)
07:34:48 <quicksilver> "triple"
07:34:49 <rog_> i think if haskell records were better (i.e. if record members didn't live in global namespace) then it'd often be easier to use them than type classes
07:35:16 <luqui> BMeph, "i say what I mean?".  I don't know what you're talking about.
07:35:40 <Saizan> a type system based on ML functors/extensible records that support an optional "infer the one i want from the type" might be very fun to use
07:35:53 <luqui> Saizan, have you used coq?
07:36:02 <purple_> newbi question - dont you need typeclasses to be able to support the adhoc polymorphism required by monad operators - eg bind operator is overloaded depending on the type
07:36:06 <Saizan> luqui: no
07:36:11 <luqui> Saizan, ad hoc inference can be fun sometimes and positively irritating others.
07:36:11 <vixey> purple_, yes
07:36:29 <vixey> luqui, what do you mean ad hoc inferences?
07:36:32 <BMeph> luqui: I just got finishied reading the original paper; hold on, I'll track down the link. :)
07:36:40 <luqui> Saizan, yeah, coq have a decent implicit parameter inference system.  it's unpredictable though...
07:37:02 <vixey> It's completely predictable ..
07:37:03 <luqui> vixey, like "infer the one I want from the type"
07:37:10 <luqui> vixey, okay, let me rephrase
07:37:12 <luqui> it's complex.
07:37:33 <Saizan> luqui: i meant a system comparable to haskell instance selection
07:37:44 <lilac> purple_: no, you don't need typeclasses; there are plenty of other design decisions which could have been made when designing haskell which would still permit adhoc polymorphism
07:37:57 <luqui> Saizan, ah.   so still using "standard instances", but allowing override?
07:37:58 <Saizan> not something that works in general for any parameter like in agda
07:37:59 <quicksilver> purple_: yes, but the key point is that's the *only* thing you need typeclasses for. The adhoc overloading.
07:38:14 <quicksilver> (of course, tehre are other ways to do adhoc overloading. Just look at C++ and Perl ;)
07:38:44 <BMeph> luqui: This looks like a valid link: http://ttic.uchicago.edu/~blume/classes/aut2008/proglang/papers/Landin-next-700.pdf -- tell me if it isn't. :)
07:38:46 <lambdabot> Title: The Next 700 Programming Languages, http://tinyurl.com/6xnaqq
07:38:57 <Saizan> luqui: yeah, by passing it in explicitly
07:39:08 <purple_> vixey, lilac - thanks, i am comming from ocaml and decided the lack of adhoc made implementing monadic operators next to impossible
07:39:37 <vixey> purple_, look on Jane st. blog for ocaml solution
07:39:39 <luqui> Saizan, hm, so really it's just sugar for dictionary passing.  which it is anyway...  yeah, might be a nice little sweetner
07:39:44 <luqui> I think it still doesn't get to the point
07:40:23 <luqui> there's something semantic in the idea type classes. it's more than sugar.  i just don't know what it is.
07:40:25 <Saizan> luqui: well with extensible records it's much nicer to work with dictionaries :)
07:40:51 <luqui> Saizan, ah, I can imagine  (though I don't have first hand experience)
07:40:59 <BMeph> quicksilver: Does it offend you that the Float representations of integers aren't in a typeclass that denotes it? ;)
07:41:29 <Saizan> typeclasses are sets of types that support some operations, i guess they are related to universes in the dependent types world
07:41:56 <quicksilver> luqui: it's sugar which hooks directly into the power of the type inferrer.
07:42:03 <quicksilver> luqui: that's why it's not "just sugar"
07:42:21 <quicksilver> luqui: it allows you to get the type inferrer to solve a limited class of logic program to generate code for you.
07:42:22 <luqui> that's not at all what I mean
07:42:30 <quicksilver> luqui: with GHC extensions, a less limited class.
07:43:05 <ertai> dons: ping?
07:43:21 <luqui> that's all surface stuff.  what problems it can solve, what code it reuses.  I mean there's some deep meaning in something near typeclasses.
07:43:35 <luqui> that makes a lot of sense, and improves our modeling abilities
07:44:14 <lilac> luqui: in some sense it recognises and gives a name to the mathematical observation that "these things are all kind-of the same" which underlies category theroy
07:45:47 <luqui> lilac, yeah, and that can be formalized.  my problem i think is that that observation is typically not 1-1 in math
07:46:29 <quicksilver> I'm not sure I by that.
07:46:30 <luqui> the Integers are a group.  that doesn't mean the Integers are uniquely a group.
07:46:39 <quicksilver> that's certainly something you can use it for, roughly
07:46:42 <quicksilver> but it's not precise.
07:46:54 <quicksilver> a mathematician in a precise mood says (Z,+,0) is a group
07:46:55 <jsn> you know, despite all the annoyance i experience due to an underabundance of typeclasses, i have to say, once i get all the conversion functions in place, all my code actually works
07:46:58 <quicksilver> not just Z is a group.
07:47:07 <luqui> quicksilver, yeah.
07:47:12 <jsn> testing is a formality in so many cases
07:47:20 <quicksilver> typeclasses allow us to abuse notation just like mathmaticians do
07:47:22 <vixey> jsn, testing should be erased
07:47:41 <jsn> vixey: you aren't thinking really big
07:47:41 <quicksilver> when a mathematician talks of the real numbers as an ordered field
07:47:41 <lilac> quicksilver: right, "Z forms a group under addition", or "the additive group Z"
07:47:47 <quicksilver> his friend doesn't ask him which one
07:47:51 <quicksilver> because the answer is assumed
07:47:54 <luqui> quicksilver, exactly!  but I don't think their use as an formalization of notation abuse is recognized.
07:47:55 <jsn> vixey: we need it sometimes
07:48:00 <quicksilver> typeclasses let us make that kind of assumption.
07:48:05 <quicksilver> with all its limitations and drawbacks
07:48:11 <luqui> (and also they are hinting at something cooler than notation abuse that I want to get at)
07:48:13 <jsn> vixey: does my render look nice, &c.
07:48:45 <lilac> it worries me that this reactive tetris program with its 10 lines of code using Reactive has at least two subtle memory leaks :(
07:48:54 <jsn> vixey: what we don't need it for is "does my program try to put strings in an integer function" :)
07:49:29 <vixey> testing means "I don't know if this code or not"
07:49:46 <vixey> testing means "I don't know if this code works or not"
07:50:04 <luqui> yep.  prefer proof when possible :-)
07:50:28 <luqui> still really hard given the state of the art, unfortunately
07:50:33 <vixey> It's not always the case that writing a proof is assurance that something works
07:50:35 <lilac> testing can prove the lower bound on number of failures is higher than you wanted
07:50:55 <lilac> typing / proof can prove the upper bound on number of failures is low
07:51:11 <luqui> vixey, oh?  well, if you have spelled 'works' correctly in your theorem, then it is...
07:51:18 <quicksilver> lilac: reactive is new, subtle, and hides a lot beneath the hood
07:51:32 <quicksilver> lilac: I don't think it's that surprising it has memory leaks
07:51:37 <quicksilver> it abuses the GHC RTS slightly too.
07:51:44 <luqui> (slightly?)
07:51:54 <lilac> quicksilver: fair point. i'd be interested to find whether they're tetris leaks or reactive leaks
07:51:58 <lilac> i'm hoping the latter
07:52:01 <quicksilver> they're reactive leaks.
07:52:15 <luqui> reactive invents a new unspoken semantics for haskell programs
07:52:26 <PeakerWork> I have a program that doesn't function at all, worse than a leak :(
07:52:27 <quicksilver> but this is "merely" an engineering problem
07:52:27 <quicksilver> and can probably be solved
07:52:30 <luqui> it's very subtle and scary
07:52:47 <quicksilver> although I think the best solution will actually involve a haskell RTS which exposes a little more control.
07:53:25 <luqui> quicksilver, yes!  actually with a little GC extension I think there is a really nice FRP
07:54:11 <quicksilver> a little GC extension, perhaps a little thread scheduling extension too.
07:54:20 <quicksilver> to get more predictable wakeup.
07:54:22 <lilac> why is a GC extension needed?
07:54:30 <luqui> quicksilver, ah.  the one I'm thinking of is single threaded
07:55:06 <quicksilver> luqui: even single-threaded you want some guarantees that if you ask for an event at excactly 9:15 you get it pretty close to 9:15
07:55:09 <luqui> lilac, not needed, but it would allow something cool.
07:55:19 <quicksilver> luqui: preferably without busylooping every 10 milliseconds to check the time.
07:55:32 <luqui> quicksilver, that seems more of a surface issue
07:55:40 <lilac> luqui: something cool and specific? :)
07:56:27 <luqui> lilac, yeah.  the sketch i have (and mind, it's rough and ugly; I'm taking its existence to imply a related nicer solution) is to have a "time window counter" on every value
07:56:41 <luqui> and gc follows identical counters
07:56:57 <luqui> to generalize, the idea is that it matters where something is seen *from*, not just whether it is seen
07:57:19 <lilac> kind of like generational gc, but temporal instead?
07:57:44 <luqui> uh... very roughly perhaps
07:57:59 <lilac> does this have any semantic impact, or is it a pure optimization?
07:58:06 <luqui> I'd like to find the general solution before locking in time, which is highly frp-specific
07:58:20 <luqui> lilac, pure optimization.
07:58:48 <luqui> lilac, reducing space complexity of programs.  and, as long as those links are known, the time complexity too.
08:00:02 <luqui> lilac, it corresponds roughly to an implementation where Behavior a = (Window, Time) -> a      (where Window is some global discretization)
08:00:24 <luqui> but where the Window arguments are known by the GC
08:04:27 <lilac> luqui: something like memory region analysis then?
08:04:41 <luqui> yeah that's closer to it I think
08:08:02 <PeakerWork> code.haskell.org is down?
08:08:12 <vixey> @code.haskell.org is down?
08:08:13 <lambdabot> Unknown command, try @list
08:08:47 <Saizan> @can i haz command pls?
08:08:47 <lambdabot> Maybe you meant: faq map run wn
08:09:12 <jsn> luqui: predictive GC?
08:09:13 <Saizan> PeakerWork: i can login
08:09:22 <PeakerWork> Saizan: I get connection refused on port 80 there
08:09:37 <PeakerWork> telnet code.haskell.org 80 => Trying 72.249.126.23... => telnet: Unable to connect to remote host: Connection refused
08:10:23 <Saizan> ah, then the webserver is probably dead..
08:11:10 <luqui> jsn, don't know what that means =P
08:11:21 <Saizan> Igloo: are you the one to ping if code.haskell.org is down? :)
08:12:48 <solussd> what is the most concise way to take the first element of a list of strings and convert it to an Int? ie) ["3" "sdlkfjksldfj"]  and i want 3
08:13:21 <solussd> i tried this: digitToInt ((["3"]!!0)!!0)    but its ugly
08:13:29 <Saizan> > read . head $ ["3","adkasdjkas"]
08:13:30 <lambdabot>   * Exception: Prelude.read: no parse
08:13:33 <Saizan> > read . head $ ["3","adkasdjkas"] :: Int
08:13:35 <lambdabot>   3
08:13:58 <solussd> much better- thanks
08:14:28 <luqui> > read "()"
08:14:29 <lambdabot>   ()
08:14:32 <luqui> ah ok.
08:14:47 <Saizan> it will throw exceptions when you force the result if the list is empty or there's a parse error
08:14:53 <PeakerWork> how did it know to use read :: () ?
08:14:58 <PeakerWork> read :: String -> ()      that is
08:14:59 <quicksilver> extended defaulting.
08:15:04 <luqui> PeakerWork, that was me checking the default
08:15:07 <PeakerWork> quicksilver: what is that?
08:15:16 <quicksilver> it's a ghci feature to default everything to () if in doubt
08:15:22 <PeakerWork> ah, heh
08:15:24 <quicksilver> lambdabot has it turned on.
08:15:38 <quicksilver> @go haskell extended defaulting
08:15:41 <lambdabot> http://www.haskell.org/onlinereport/decls.html
08:15:41 <lambdabot> Title: The Haskell 98 Report: Declarations
08:15:41 <luqui> at one point it was GHC.Prim.Any; i.e. the uniform rep for unsafeCoerce
08:15:52 <quicksilver> that doesn't look right.
08:17:34 <ziman> > read "3"
08:17:36 <lambdabot>   * Exception: Prelude.read: no parse
08:18:02 <gwern> > read "3" :: Int
08:18:03 <lambdabot>   3
08:18:29 * luqui wants to write a Read instance for Dynamic.
08:18:53 <luqui> which magically figures out the type somehow
08:20:14 <Saizan> if you were to use a record of functions for e.g. Monoid, would you define it like data Monoid = M { zero :: Monoid, plus :: Monoid -> Monoid -> Monoid } or data Monoid m = M { zero :: m, plus : m -> m -> m } ?
08:20:33 <quicksilver> the latter
08:22:59 <Saizan> the first is attractive though, in some sense it looks simpler
08:23:35 <quicksilver> it lets you add together different monoids though...
08:23:37 <Saizan> the problem is that it forces you to lose information about the underlying type
08:23:53 <Saizan> ah, true
08:23:55 <luqui> :t rnf
08:23:56 <lambdabot> forall a. (NFData a) => a -> Done
08:24:58 <mmorrow> > let x = repeat in x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x $ (42::Int)
08:24:59 <lambdabot>       Context reduction stack overflow; size = 20
08:24:59 <lambdabot>      Use -fcontext-stack=N ...
08:25:02 <mmorrow> heh
08:25:24 <mmorrow> > foldr (.) id (replicate 20 repeat) $ (42::Int)
08:25:25 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
08:25:25 <lambdabot>        Expect...
08:25:36 <lilac> doesn't the former Monoid definition actually... not work?
08:25:59 <Saizan> yeah, i didn't realize it :)
08:26:14 <luqui> see, that depends on what you mean by 'work'
08:26:21 <luqui> it's a peculiar structure, for sure :-)
08:26:24 <lilac> the plus operation within a dictionary allows you to add together two Monoid dictionaries...
08:26:27 <lilac> :)
08:26:40 <lilac> plus :: Monoid -> Monoid -> Monoid -> Monoid :-/
08:26:43 <luqui> reminds me of newtype U = U (U -> Bool)
08:26:46 <mmorrow> ohhh, the stack is overflowing during typechecking, not evaluation..
08:27:02 <mmorrow> , let x = repeat in x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x $ (42::Int)
08:27:04 * leimy is wondering if he'll get his haskell book before Friday.
08:27:10 <lunabot>  luna: Context reduction stack overflow; size = 20
08:27:36 <leimy> looks like no
08:29:04 <mmorrow> , $(foldr (\g f -> [|$g . $f|]) [|id|] (replicate 20 [|repeat|])) $ (42::Int)
08:29:06 <lunabot>  luna: Context reduction stack overflow; size = 20
08:29:44 <mmorrow> , (|.|)
08:29:46 <lunabot>  luna: Not in scope: `|.|'
08:32:40 <PeakerWork> Couldn't match expected type `reactive-0.9.1:FRP.Reactive.Internal.Behavior.BehaviorG reactive-0.9.1:FRP.Reactive.Reactive.ITime reactive-0.9.1:FRP.Reactive.Reactive.TimeT a' against inferred type `R.BehaviorG R.ITime R.TimeT Direction'
08:32:47 <quicksilver> @type let a x = (x,x); b x = a (a x); c x = b(b x); d x = c (c x) in d 0
08:33:00 <lambdabot> forall t. (Num t) => ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t,
08:33:03 <lambdabot> t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t,
08:33:06 <lambdabot> t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t,
08:33:08 <PeakerWork> shouldn't those types match?
08:33:09 <lambdabot> t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t,
08:33:12 <lambdabot>  t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t),
08:33:15 <lambdabot> (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t,
08:33:18 <lambdabot>  t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
08:33:27 <mmorrow> someone needs to djinn that asap
08:33:28 <quicksilver> hmm. I thought that would be bad, but not quite that bad ;(
08:33:29 <quicksilver> sorry.
08:34:03 <vixey> :t let a x = (x,x) in a 0
08:34:04 <lambdabot> forall t. (Num t) => (t, t)
08:34:08 <lilac> @djinn (Num t) => t
08:34:08 <lambdabot> Error: Class not found: Num
08:34:14 <vixey> :t let a x = (0,0) in a
08:34:16 <mmorrow> @djinn-env
08:34:16 <lambdabot> forall t t1 t2. (Num t2, Num t1) => t -> (t1, t2)
08:34:16 <lambdabot> data () = ()
08:34:16 <lambdabot> data Either a b = Left a | Right b
08:34:16 <lambdabot> data Maybe a = Nothing | Just a
08:34:16 <lambdabot> data Bool = False | True
08:34:18 <lambdabot> data Void
08:34:20 <lambdabot> type Not x = x -> Void
08:34:22 <lambdabot> class Eq a where (==) :: a -> a -> Bool
08:34:26 <vixey> :t let a x = (0,0) ; b x = (x,x) in a
08:34:27 <lambdabot> forall t t1 t2. (Num t2, Num t1) => t -> (t1, t2)
08:34:27 <vixey> :t let a x = (0,0) ; b x = (x,x) in b
08:34:28 <vegai> quicksilver: much more artistic on ghci
08:34:29 <lambdabot> forall t. t -> (t, t)
08:34:38 <vixey> :t let a x = (0,0) ; b x = (x,x) in b a
08:34:40 <lambdabot> forall t t1 t2. (Num t2, Num t1) => (t -> (t1, t2), t -> (t1, t2))
08:34:48 <PeakerWork> is my type error above a version problem, or a type that is too specific?
08:35:22 <PeakerWork> If I clean up the version and BehaviorG stuff: Couldn't match expected type `R.Behavior a' against inferred type `R.Behavior Direction'
08:35:41 <PeakerWork> (it compiled at home, so its likely a version issue, but I compiled all the libs cleanly)
08:35:43 <quicksilver> PeakerWork: do you have reason to believe it might be a version problem? do you have two versions of reactive installed? or have you ever?
08:35:53 <quicksilver> (because it's certainly true you can get errors like that from version problems)
08:35:58 <PeakerWork> quicksilver: I keep upgrading it, and I install from cabal and from darcs
08:36:08 <dons> hey guys
08:36:09 <quicksilver> you probably need to -fforce-recomp
08:36:16 <quicksilver> to make sure everything is compiled against the latest
08:36:19 <bos> de-da-de-da-de-dons
08:36:26 <quicksilver> I think you ave some source files compiled against the old, and some against the new.
08:36:38 <dons> just in case you didn't spot it late last night (or you were asleep), RWH is shipping! http://www.realworldhaskell.org/blog/2008/11/25/real-world-haskell-is-shipping/
08:36:41 <lambdabot> Title: Real World Haskell » Blog Archive » Real World Haskell is shipping!, http://tinyurl.com/68v2sg
08:36:55 * dons is taking his copy into Galois today
08:37:03 <PeakerWork> quicksilver: it happens with forcing too, and indeed I have reactive-0.9.3 installed, but its using 0.9.1
08:37:55 <quicksilver> PeakerWork: you are using some other library which also links against reactive?
08:37:58 <quicksilver> reactive-fieldtrip, maybe?
08:38:06 <PeakerWork> ah, reinstalling reactive-{glut,fieldtrip} from darcs seems to have resolved it
08:38:09 * quicksilver nods
08:38:15 <quicksilver> just recompiling it would have been sufficient.
08:38:41 <PeakerWork> okay, so now I can run it and get the same completely-buggy behavior as I get at home
08:38:56 <quicksilver> ;)
08:39:04 <quicksilver> consistently-buggy++
08:39:12 <PeakerWork> :)
08:39:31 <luqui> wait... isn't complete and consistent bugginess proved impossible by godel?
08:39:32 <PeakerWork> I added a keyEvent to reactive-glut (that should eventually replace keyPressed), that gives you down/up events
08:40:03 <PeakerWork> now, GLUT is being retarded about Key UP events :-(  But I create a   Behavior (Set Key)    for pressed keys at any given time from that anyway
08:40:19 <blueonyx> hi
08:40:30 <PeakerWork> Then I use a regular ticker to sample that behavior -- and then I use the pressed keys at the sampled times to control the game
08:40:42 <PeakerWork> (so the game is not determined by how fast you press, but by the ticker)
08:40:55 <mmorrow> , $(foldr (|.|) [|id|] (replicate 20 [|concat|])) $(foldr (|.|) [|id|] (replicate 21 [|return|]) |$| [|42|])
08:40:59 <lunabot>  [42]
08:41:05 <PeakerWork> The behavior Set seems to function just fine, but its sampling by the ticker is completely broken
08:42:49 <mmorrow> , $(foldr (|.|) [|id|] (replicate 20 [|join|])) $(foldr (|.|) [|id|] (replicate 21 [|return|]) |$| [|42|]) :: Maybe Integer
08:42:53 <lunabot>  Just 42
08:43:24 <mmorrow> , $(foldr (|.|) [|id|] (replicate 1000 [|join|])) $(foldr (|.|) [|id|] (replicate 1001 [|return|]) |$| [|42|]) :: Maybe Integer
08:43:30 <lunabot>  Killed.
08:44:12 * mmorrow goes to print that expression out in ghci
08:45:18 <mmorrow> , ppDoc `fmap` foldr (|.|) [|id|] (replicate 20[|join|])
08:45:22 <lunabot>  join . (join . (join . (join . (join . (join . (join . (join . (join . (j...
08:51:19 <samll> > join . (join . (join . (
08:51:20 <lambdabot>   <no location info>: parse error on input `;'
08:52:39 <PeakerWork> Can anyone with Reactive-fieldtrip try to compile http://hpaste.org/12401 ?
08:52:43 <noZone> mmorrow: What's up with the | symbol in your expressions? I've not seen that notation before.
08:52:44 <PeakerWork> I want to see if the problem restores elsewhere
08:53:33 <mmorrow> i just defined (|.|), but the [|....|] is template-haskell syntax
08:54:01 <noZone> k. I don't use template Haskell, so that explains it.
08:54:04 * luqui wonders... would it not be clearer to reverse the direction of the function arrow?
08:54:07 <mmorrow> in ghci you could do:
08:54:14 <mmorrow> , runQ [|42|]
08:54:16 <lunabot>  luna: No instance for (GHC.Show.Show (m Language.Haskell.TH.Syntax.Exp))
08:54:20 <luqui> Int -> Bool  becomes   Bool <- Int.  Then it matches the application pattern.
08:54:21 <mmorrow> which would print
08:54:24 <mmorrow> , [|42|]
08:54:27 <lunabot>  LitE (IntegerL 42)
08:54:41 <mmorrow> (lunabot does it slightly differently since it can't do IO)
08:55:14 <mmorrow> in particular, lunabot has an instance of Show for (Q Exp) among other such Show instances
08:55:15 <Saizan> luqui: A -> B -> C becomes C <- B <- A then?
08:55:31 <Saizan> luqui: in that case the arguments will appear reversed
08:55:35 <luqui> yeah, and <- is left-associative (like application, go fig!)
08:55:47 <luqui> oh... hmm
08:55:57 <luqui> yes you're right
08:56:22 <noZone> mmorrow: thanks for the explanation.
08:56:22 <lilac> also, (<-) rather than (->) would break fmap
08:56:28 <PeakerWork> conal: You there?
08:56:34 <luqui> eh, that's a hack anyway
08:56:37 <Twey> What do you mean?  Left-associating <-?
08:56:38 <lilac> meh :)
08:56:51 <mmorrow> noZone: np. feel free to mess with TH using lunabot :)
08:56:53 <Twey> It's not possible to have two in a row, surely?
08:56:55 <Saizan> Twey: that (C <- B) <- A == C <- B <- A
08:57:10 <vixey> I think you want -> and <- to clash though
08:57:21 <Twey> Is that possible?  What does (C <- B) mean as a pattern?
08:57:24 <vixey> it would be too confusing to have  a -> b <- c -> d
08:57:41 <Saizan> Twey: we're talking about fictional syntax
08:57:47 <luqui> I never liked how application goes right to left, but -> is left-to-right.  hmm... there doesn't seem to be a simple fix though
08:57:55 <Twey> Oh, right.
08:58:01 <Saizan> Twey: but you could define type B :<- A = A -> B
08:58:02 <mmorrow> , $(let tup x y = [|($x,$y)|] in foldr tup [|()|] (fmap lift [0..9]))
08:58:05 <lunabot>  luna: Ambiguous type variable `a' in the constraints:
08:58:10 <mmorrow> , $(let tup x y = [|($x,$y)|] in foldr tup [|()|] (fmap lift [0..9::Int]))
08:58:12 <lunabot>  (0,(1,(2,(3,(4,(5,(6,(7,(8,(9,()))))))))))
08:58:18 <mmorrow> , $(let tup x y = [|($x,$y)|] in foldl tup [|()|] (fmap lift [0..9::Int]))
08:58:20 <lunabot>  (((((((((((),0),1),2),3),4),5),6),7),8),9)
08:58:21 <Twey> Quite, but then it wouldn't be <- :)
08:58:22 <idnar> luqui: huh?
08:58:34 <conal> PeakerWork: i'm here.
08:58:39 <Saizan> luqui: it's not really application, but composition
08:58:44 <PeakerWork> conal: I just reported a bug that for my little game, is a complete blocker
08:58:56 <PeakerWork> conal: I wondered if you had anything you could guess about it just from looking
08:59:00 <mmorrow> , $( [| 42 |] )
08:59:02 <lunabot>  42
08:59:02 <luqui> Saizan, yeah you could state it that way too
08:59:03 <PeakerWork> conal: http://trac.haskell.org/reactive/ticket/13
08:59:03 <Saizan> which goes right to left, i mean
08:59:04 <lambdabot> Title: #13 (Snapshotting a Behavior built with accumB seems to go wrong) - reactive - T ...
08:59:06 <idnar> luqui: if you have f :: A -> B -> C, a :: A, b :: B, then you write f a b
08:59:16 * conal looks
08:59:34 <idnar> luqui: that looks like the same direction to me ;)
08:59:37 <alsonk> anyone have experience handling timestamp columns in HDBC?
08:59:46 <mmorrow> , $( let x = [|42|] in [|2 * $x|])
08:59:48 <lunabot>  84
08:59:53 <luqui> idnar, i guess composition is the best way to put it then
09:00:04 <luqui> f (g x) goes in the opposite directions of the arrows of f and g
09:00:05 <alsonk> I'm getting a "Prelude.head: empty list" error and I'm fairly sure that it has to HDBC's handling of a timestamp column.
09:00:22 <PeakerWork> conal: I take a behavior that seems to be fine,  snapshot it against a regular ticker and then use "stepper" to make it a behavior again - and its completely stale (nothing ever happens to the behavior)
09:00:37 <idnar> luqui: sure
09:00:49 <idnar> luqui: I think I've talked about having application the other way around
09:00:58 <idnar> luqui: as well as composition
09:01:09 <luqui> hm. wouldn't that mess with argument order?
09:01:11 <mmorrow> , $(let f 0 e = e; f n e = [|show $(f (n-1) e)|] in f 6 [|3*2|])
09:01:13 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"6\\\\\\\\\...
09:01:15 <conal> PeakerWork: i'm in two IMs right now.  i'll read the trac report soon.
09:01:17 <idnar> luqui: like x (g . f)
09:01:24 <PeakerWork> conal: ok, thanks, I gtg now though
09:01:38 <luqui> f : A -> B -> C.   b a f :: C
09:01:41 <luqui> still reversed
09:02:14 <conal> PeakerWork: see you later.  and thanks for the trac ticket!
09:02:22 <idnar> luqui: I guess
09:02:39 <luqui> there might be something essential here that is preventing a solution :-)
09:03:20 <samll> > dbAccess "SELECT * FROM users"
09:03:21 <lambdabot>   Not in scope: `dbAccess'
09:04:58 <luqui> lol sql.   as if ...
09:06:10 <quicksilver> samll: http://xkcd.com/327/
09:06:13 <lambdabot> Title: xkcd - A Webcomic - Exploits of a Mom
09:10:53 <blueonyx> ghc-6.8.2: panic! (the 'impossible' happened) O.o
09:11:07 <Saizan> @ghc
09:11:07 <lambdabot> ghc says: Ambiguous constraint
09:11:10 <Saizan> @ghc
09:11:10 <lambdabot> ghc says: invalid character
09:11:51 <dons> blueonyx: sounds bad
09:12:16 <dolio> Mah brain just explodid.
09:12:39 * luqui thinks ghc's error messages should be translated to lolcat
09:13:13 <conal> via a ghc plug-in
09:13:29 <luqui> uh no.  permanently.
09:14:02 <dolio> Yeah, that should definitely be the first plugin when their new architechture gets done.
09:14:45 <conal> Plugin.Error.Lol
09:15:20 <mmorrow> HAI CAN HAS STDIO? VISIBLE "I MAID U AN EROR MESAGE BUT I EATED IT" KTHXBAI
09:15:31 <p_l> It should also allow for LOLcode-like commands
09:16:10 <Saizan> is there some standard idiom to avoid the uglyness when you and up with too many type parameters on some hierarcy of types?
09:16:10 <p_l> and we need a db proxy to have LOLSQL in all databases...
09:16:25 <BMeph> Presentation.hs:5:16:   They be taking mah bukkit!
09:17:00 <Saizan> like data FooMonadT a b c d m a = Foo (Bar a b -> Baz c d -> m a)
09:17:16 <p_l> otoh, some of the commands in LOLSQL are quite descriptive compared to their SQL counterparts... like "WORLD OF PAIN"
09:17:23 <quicksilver> Saizan: type synonyms for common cases?
09:17:37 <mmorrow> Saizan: like @pl, but for types?
09:18:08 <mmorrow> @pl \a b c d m a -> foo (bar a b -> baz c d -> m a)
09:18:08 <lambdabot> (line 1, column 30):
09:18:08 <lambdabot> unexpected ">"
09:18:08 <lambdabot> expecting variable, "(", operator or ")"
09:18:23 <mmorrow> @pl \a b c d m a -> foo (bar a b .-> baz c d .-> m a)
09:18:23 <lambdabot> const ((((((foo .) .) . liftM2 (.->)) .) .) . (. baz) . (.) . flip . ((.->) .) . flip bar)
09:18:28 <luqui> Saizan, degeneralization
09:18:31 <Saizan> if types had combinators..
09:18:47 <dolio> Oh, but they do.
09:18:53 <Saizan> luqui: isn't generalization good?
09:19:01 <alsonk> ... anyone give some help on an HDBC/timestamp problem? ...
09:19:03 <luqui> only if it's meaningful
09:19:16 <dolio> O (O (O Foo)) ...
09:19:18 <mmorrow> Const ((((((Foo .) .) . LiftM2 (.->)) .) .) . (. Baz) . (.) . Flip . ((.->) .) . Flip Bar)
09:19:26 <luqui> but usually too many type parameters is a lack of good abstraction boundaries.  that's my experience at least.
09:19:43 <Saizan> you can't eta-reduce data/newtype definitions
09:19:51 <mmorrow> Const ((((((Foo :.) :.) :. LiftM2 (:->)) :.) :.) :. (:. Baz) :. (:.) :. Flip :. ((:->) :.) :. Flip Bar)
09:19:58 <Saizan> however that wasn't exactly the problem
09:20:13 <mmorrow> heh
09:21:08 <vixey> 'LiftM2'?
09:21:25 <vixey> what's the monad
09:21:49 <dolio> Type-level reader?
09:21:58 <quicksilver> yup
09:22:49 <mmorrow> sweet!
09:23:14 <mmorrow> ((->)*)
09:38:51 <gwern> http://trevion.blogspot.com/2008/11/cabal-is-fine-piece-of-software.html <-- it's about time we got some cabal-related trolling
09:38:53 <lambdabot> Title: Nonlinear: Cabal is a fine piece of software, http://tinyurl.com/5r6dog
09:39:23 <gwern> @tell dcoutts_ if you haven't seen it already, you may find this amusing: http://trevion.blogspot.com/2008/11/cabal-is-fine-piece-of-software.html
09:39:24 <lambdabot> Consider it noted.
09:40:22 <ddarius> gwern: Sounds like he wants cabal install.
09:40:22 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
09:41:26 <lilac> wow, my eyes are bleeding from that lovely piece of sarcasm
09:41:27 <gwern> ddarius: well, that wouldn't address some of his complaints, like specifying the required libraries
09:41:42 <gwern> ddarius: not to mention cabal-install would give him a whole list of new complaints...
09:41:52 <lilac> "oh noes, cabal makes it harder for the packager but easier for the user!"
09:43:14 <gwern> I was trying to think of an appropriately sarcastic response, like. 'Oh yes, we should just let the source call random libraries and go back to using autoconf and forget about this silly stuff about 'dependency tracking''
09:43:28 <gwern> (but then I realized my sarcasm glands had been squeezed out yesterday)
09:43:42 <ddarius> I hear there are some things that cabal install makes easier for the developer.  Personally, when I've used it in development, it was pleasant.
09:44:35 <gwern> I'm not very happy on 6.10; I keep getting random problems with base 4 and packedstrings
09:44:57 * vixey has found cabal to produce a lot of errors
09:45:38 <lilac> i would like it if cabal had some way of checking for necessary libs, rather than getting link failures
09:46:13 <vixey> Itseems like a bad idea that cabal is not part of GHC
09:46:33 <gwern> one of my beefs is that cabal doesn't build in sdist mode; this is frustrating when you go to hackage
09:46:44 <gwern> vixey: why should cabal be part of ghc? ghc is monolithic enough
09:47:58 <BONUS> because installing it separately is a pain
09:48:17 * ddarius downloads a bunch of papers on nonlinear control theory.
09:48:22 <vixey> ghc --make  runhaskell Setup.hs and cabal all seem to sort of want the same thing
09:48:35 <gwern> BONUS: let's not stop there! let's bundle all of hackage with ghc
09:48:55 <vixey> but they don't work together so the effort required to make them not-crap is distributed over 3 things instead of 1
09:49:33 <ddarius> vixey: What makes you think they don't work together?
09:50:01 <taari> Hey
09:50:04 <BONUS> idk i think installing from cabal is really easy once you have cabal-install
09:50:12 <BONUS> but i always have a hard time getting cabal and cabal-install
09:52:49 <Twey> Hmm, what's an easy way to represent a wrapped function where the intermediate functions also have to be wrapped?
09:53:17 <Twey> I've a `data Value = Func (Value -> Foo Value) | ...`
09:54:01 <Twey> But when dealing with functions of more than one argument, it gets tricky... for example, I have a wrapped function `add = Func $ \a -> return $ Func (\b -> return . Number $ (unNum a) + (unNum b))`
09:54:18 <vixey> is Number a monad?
09:54:20 <lilac> BONUS: getting cabal-install is trivial these days
09:54:25 <Twey> vixey: No
09:54:41 <vixey> why not make it an applicative or something
09:54:50 <lilac> BONUS: (1) download from hackage, (2) install zlib dev packages, (3) source bootstrap.sh
09:54:52 <Twey> It's one of the Value constructors: Number Double
09:54:57 <Twey> Hmm
09:55:10 <BONUS> yeah but it kind of always goes awry for me hehe
09:55:12 <Twey> How would that code be rewritten if Value were an applicative?
09:55:27 <BONUS> you gotta choose where to put it
09:55:32 <BONUS> if its cross system or just for the user
09:55:40 <BONUS> and then put the binary file somewhere reachable
09:55:48 <BONUS> and then you might have problems running it with sudo
09:55:49 <BONUS> etc
09:58:10 <Raevel> @hoogle (a -> Bool) -> [a] -> a
09:58:10 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:58:10 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
09:58:10 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
09:58:12 <ksf> a) type "emerge cabal-install" b) profit
09:58:24 <monadwr> hello
09:58:37 <monadwr> BONUS: are you about?
09:58:38 <Twey> Hullo
09:58:54 <mib_852dos> hey all
09:59:01 <mib_852dos> I need some function puns
09:59:11 <mib_852dos> like "we put the funk in funktion"
09:59:33 <lament> we put the pun in punktions
09:59:34 <monadwr> Twey: hi; do you know why minBound/maxBound :: Char return the same values in one implementation ('\1114111') in LYAH ?
09:59:45 <Raevel> mib_852dos: this is pointless?
09:59:55 <monadwr> I suppose it is ultimately implementation defined; but I was just curious as to why.
10:00:01 <mib_852dos> Raevel: kind, I need it for a rap in math class
10:00:16 <monadwr> Being as my minBound value to type Char returns '\NUL'
10:00:18 <Raevel> mib_852dos: that was a pun, if you didn't get that :-)
10:00:24 <Twey> vixey: The problem as I see it is that an applicative would yield only a Value, not a Foo Value (Foo *is* a monad)
10:00:32 <vixey> oh
10:00:47 <Deewiant> monadwr: LYAH has a typo?
10:00:53 <ddarius> A rap about Haskell in math class.  This can only be disastrous.
10:00:59 <mib_852dos> Raevel: oooh, i kinda get it. Any other generalized puns?
10:01:09 <mib_852dos> ddarius: a rap about functions
10:01:26 <Twey> It needs to go Func (Value -> Foo Value), where that latter value is a Func (Value -> Foo Value)
10:01:31 <ksf> (around where I am from, german hackish includes "pointfree" as a superlative of "pointless")
10:01:47 <Deewiant> monadwr: Where'd you see that?
10:01:52 <Twey> It's very nice and fractal, and looks like it should be nicely abstractable
10:01:56 <Twey> But I'm not entirely sure how
10:02:12 <monadwr> Deewiant: http://learnyouahaskell.com/types-and-typeclasses
10:02:18 <monadwr> search for 'Bound'.
10:02:20 <lambdabot> Title: Learn You a Haskell for Great Good! - Types and Typeclasses
10:02:20 <mib_852dos> Twey: do you have any puns you'd like to contribute?
10:02:34 <monadwr> There was a typo "funiction', but I overlooked it
10:02:49 <Deewiant> monadwr: I only see maxBound :: Char, not minBound
10:03:15 <luqui> mib_852dos, surely you have seen this and can rip a lot of it off: http://uk.youtube.com/watch?v=UTby_e4-Rhg
10:03:20 <lambdabot> Title: YouTube - Finite Simple Group (of Order Two)
10:03:35 <Raevel> terrible puns is actually one of the highlights of irc life
10:03:45 <Twey> mib_852dos: No, I'm afraid I'm not much of a pundit in that area
10:03:51 <mib_852dos> heh
10:03:56 <monadwr> Deewiant: Ack!
10:04:04 <monadwr> Deewiant: My question was about 'Int' and 'Integer', sorry.
10:04:13 <ksf> mib_852dos, try "a haskell function is arbitrarily pointless"
10:04:14 <mib_852dos> ok, gotta roll
10:04:17 <mib_852dos> thank you everyone!
10:04:19 <Twey> monadwr: minBound :: Char yields '\NUL' (i.e. '\0') here
10:04:25 <Twey> mib_852dos: Good luck!  :)
10:04:36 <monadwr> minBound :: Integer/maxBound :: Integer returns an error?
10:04:48 <dons> ?users
10:04:48 <lambdabot> Maximum users seen in #haskell: 541, currently: 540 (99.8%), active: 22 (4.1%)
10:04:50 <Twey> Should do, yes
10:05:03 <monadwr> Could you explain further
10:05:05 <Twey> Integer is not Bounded, so maxBound and minBound are undefined for it.
10:05:10 <BMeph> monadwr: Like Prometheus, Integers are unbound. ;)
10:05:15 <Twey> Bounded is a class
10:05:16 <monadwr> Ah.
10:05:29 <Twey> class Bounded a where minBound :: a; maxBound :: a
10:05:46 <monadwr> a is a polymorphic constant here, though, yes?
10:05:57 <Twey> No, a is the instance type
10:06:36 <Twey> For example, instance Bounded Char where minBound :: Char; minBound = '\0'; maxBound :: Char; maxBound = '\1114111'
10:06:37 <monadwr> And this instance is bounded to types that infer 'Int', 'float' and 'Char' ?
10:06:46 <Toxaris> :t minBound -- a is *bounded* polymorphic here. it may be every type -- as long as that type is an instance of Bounded
10:06:48 <lambdabot> forall a. (Bounded a) => a
10:06:56 <monadwr> Ah.
10:07:04 <Twey> No, Int, Float, and Char are instances of Bounded
10:07:12 <luqui> hmm, talking about bounded quantification using Bounded as the example isn't the clearest way to present it...
10:07:24 <Toxaris> :)
10:07:27 <Twey> Er
10:07:30 <Twey> Not Float
10:07:36 <monadwr> Twey: Ah, okay.
10:08:15 <monadwr> Hm
10:08:17 <Toxaris> why is Float not Bounded?
10:08:39 <Twey> Toxaris: Because it has no bounds
10:08:54 <Twey> It loses precision
10:08:59 * Toxaris forgot about infinity
10:09:35 <Twey> That too :)
10:09:46 <lilac> minBound = -inf, maxBound = inf ?
10:09:49 <conal> there was a discussion last year about Bounded Float.  i asked the same question.  i think lennart has some concrete reasons.
10:10:05 <lilac> @instances Bounded
10:10:06 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
10:10:26 <monadwr> Twey: There are no upper/lower limits to floating point arithmetic in haskell ?
10:10:30 <conal> a bounded double would have made for a simpler Reactive.  though less general.
10:10:33 <Toxaris> is Bounded as a typeclass in the sense of "these types have similiar semantics"?
10:10:42 <RayNbow> > minBound :: Dual Int
10:10:43 <lambdabot>   Dual {getDual = -9223372036854775808}
10:10:44 <Toxaris> ... Bounded used as ...
10:10:48 <lilac> conal: I quite like the wrapper adding MinBound and MaxBound
10:10:52 <Twey> monadwr: None
10:11:02 <Deewiant> monadwr: There are no limits in any IEEE 754 compliant floating point implementation ;-)
10:11:03 <RayNbow> @hoogle Dual
10:11:03 <lambdabot> Data.Monoid newtype Dual a
10:11:03 <lambdabot> Data.Monoid Dual :: a -> Dual a
10:11:03 <lambdabot> Data.Monoid getDual :: Dual a -> a
10:11:10 <conal> lilac: thanks.  me too.
10:11:39 <conal> lilac: and it made Reactive work with *any* underlying time type that's in Ord
10:11:52 <Twey> Where're infinity and negative infinity in Haskell?
10:12:16 <lilac> conal: in general, i like the way the time is built out of a bunch of nested bits
10:12:17 <RayNbow> > 1/0
10:12:19 <lambdabot>   Infinity
10:12:24 <lament> boring
10:12:32 <luqui> conal, have you thought about what reactive means in a discrete space?
10:12:34 <conal> lilac: :)  i was particularly happy that that piece.
10:12:38 <lament> > last [1..]
10:12:47 <lament> wait for it :)
10:12:54 <lambdabot>   thread killed
10:12:57 <Twey> Aha
10:12:58 <monadwr> Deewiant: Ah, I'm not very good with standards; I should look further into them.
10:13:02 <conal> luqui: multidimensional time?
10:13:12 <conal> luqui: or discrete?
10:13:13 <Twey> Odd
10:13:16 <RayNbow> > last [1..] + 1   -- I can do better, lament :p
10:13:26 <Twey> You'd think that Infinity would be a constructor
10:13:28 <Twey> > Infinitiy
10:13:28 <Twey> Gah
10:13:31 <lambdabot>   Not in scope: data constructor `Infinitiy'
10:13:31 <Twey> > Infinity
10:13:31 <luqui> conal, yeah discrete.   I thought about hyperbolic spacetime a bit... :-)
10:13:33 <lambdabot>   Not in scope: data constructor `Infinity'
10:13:48 <vixey> > infinity
10:13:53 <lambdabot>   * Exception: stack overflow
10:13:54 <conal> luqui: where does discrete come in with hyperbolic spacetime?
10:14:03 <luqui> conal, i.e. you always say it's continuous.  but is there anything about reactive which is necessarily continuous?
10:14:04 <conal> luqui: (sorting out continuous time ---> discrete space)
10:14:09 <luqui> conal, it doesn't.
10:14:11 <lament> :t infinity
10:14:13 <lambdabot> Natural
10:14:21 <lament> > infinity + 1
10:14:24 <lambdabot>   * Exception: stack overflow
10:14:29 <luqui> conal, (or maybe it does.  that was just half way to multidimensional time in some respect)
10:14:30 <lament> @src infinity
10:14:30 <lambdabot> Source not found. Just try something else.
10:14:38 <lilac> luqui: i wanted to make a 3d fps with hyperbolic geometry once
10:14:38 <Toxaris> > read "Infinity" :: Float
10:14:40 <lambdabot>   Infinity
10:14:57 <Twey> @index infinity
10:14:57 <lambdabot> bzzt
10:15:09 <Twey> :-\
10:15:09 <luqui> lilac, cool.   I sketched a relativistic RTS...
10:15:13 <Twey> Where is it defined?
10:15:14 <RayNbow> infinity is probably a user defined value
10:15:18 <RayNbow> defined using @let
10:15:19 <luqui> it's pretty hard to write AI for such a thing though
10:15:20 <vixey> it's a library thing
10:15:40 <Twey> Oh
10:15:41 <luqui> so it was basically a pathfinding demo
10:15:44 <lilac> luqui: it's pretty hard to represent maps in hyperbolic space :)
10:16:03 <luqui> heheh
10:16:22 <oklopol> > repeat 1 5
10:16:23 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
10:16:28 <lilac> but you can build a tesselation out of things which obviously don't tesselate :)
10:16:32 <oklopol> > repeat [1] 5
10:16:33 <lambdabot>   Couldn't match expected type `t1 -> t'
10:16:43 <oklopol> :t repeat
10:16:44 <lambdabot> forall a. a -> [a]
10:16:51 <oklopol> oh, right.
10:17:05 <oklopol> that's not what i wanted
10:17:32 <oklopol> > take infinity [1,2..]
10:17:33 <lambdabot>   Couldn't match expected type `Int' against inferred type `Natural'
10:17:44 <oklopol> hngh.
10:17:50 <monadwr> Hm, I have an interesting document on floating point arithmetic
10:18:08 <monadwr> 'The pitfals of verifying floating point computation'
10:18:13 <dolio> > genericTake infinity [1..]
10:18:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:18:23 <oklopol> oh that works?
10:18:24 <oklopol> hmm.
10:18:33 <Deewiant> Sure, why not
10:18:44 <oklopol> is infinity Succ (Succ (...))?
10:18:49 <oklopol> or whazzit
10:18:49 <mmorrow> @src genericTake
10:18:49 <lambdabot> Source not found. :(
10:18:50 <Deewiant> ?ty infinity
10:18:52 <lambdabot> Natural
10:18:54 <lilac> infinity = fix Succ, i guess
10:18:57 <Deewiant> evidently yes
10:19:00 <Twey> oklopol: infinity = fix Succ
10:19:03 <mmorrow> take . fromIntegral -- ?
10:19:03 <Twey> :(
10:19:06 <Twey> Beaten to it!
10:19:07 <oklopol> ahh
10:19:22 <oklopol> i thought it was just something like infinity = infinity + 1
10:19:23 <Deewiant> mmorrow: surely not :-)
10:19:38 <mmorrow> negate infinity = fix pred --?
10:19:39 <Twey> > infinity :: Float
10:19:40 <lambdabot>   Couldn't match expected type `Float'
10:19:46 <mmorrow> > 1/0
10:19:47 <lambdabot>   Infinity
10:19:49 <Deewiant> > fix pred :: Natural
10:19:49 <Twey> :(
10:19:50 <lambdabot>   * Exception: stack overflow
10:20:00 <Twey> I can't seem to see any way to get at Infinity directly
10:20:05 <mmorrow> > -1 / 0
10:20:07 <lambdabot>   -Infinity
10:20:09 <mmorrow> hehe
10:20:12 <Twey> It's only accessible by performing a division by zero
10:20:19 <BMeph> oklopol: I think youoriginally wanter 'replicate', though. :)
10:20:21 <mmorrow> well, that's its definition
10:20:23 <pumpkin> :t infinity
10:20:23 <Deewiant> Yep, Infinity isn't available directly :-/
10:20:25 <lambdabot> Natural
10:20:34 <oklopol> BMeph: yes, that sounds about right
10:20:55 <pumpkin> it's not like 1/0 _equals_ infinity though
10:21:01 <pumpkin> :P
10:21:08 <mmorrow> what is your (==)?
10:21:14 <dolio> It does in IEEE.
10:21:17 <jpcooper> can the @ syntax for pattern matching be used in function definition?
10:21:21 <luqui> > 0 - 1 :: Natural
10:21:22 <lambdabot>   * Exception: Natural: (-)
10:21:23 <pumpkin> dolio: yeah, but it shouldn;t :P
10:21:30 <luqui> :info Natural
10:21:30 <Twey> jpcooper: Yes?
10:21:34 <Toxaris> jpcooper: yes.
10:21:38 <luqui> oh, that doesn't work on lambdabot
10:21:40 <jpcooper> thanks Toxaris
10:21:43 <Twey> > let foo s@(x, y) = s in foo (1, 2)
10:21:44 <lambdabot>   (1,2)
10:21:58 <Twey> Where else were you thinking of using it?  :-P
10:21:59 <luqui> > fix succ > (4 :: Natural)
10:22:03 <mmorrow> pumpkin: why not?
10:22:04 <jpcooper> Twey, case statement
10:22:14 <Twey> Ah, well, yes.
10:22:15 <lambdabot>   thread killed
10:22:21 <monadwr> Deewiant: Are there any languages that aren't compliant to IEEE-754* or find themselves placing bounds upon floating point arithmetic?
10:22:25 <Twey> Any pattern construct can be used in any pattern
10:23:50 <mmorrow> monadwr: what do you mean by "bounds"?
10:24:10 <pumpkin> mmorrow: because if you thought of it as the same equals as 6/2 == 3, then you could multiply infinity times 0 and get 1, but you could also get 2, or 3, or 4, and so on :P which would mean that a single multiplication generates multiple values, which is bad (or that inverses aren't unique)
10:24:33 <erikc> monadwr: any language on the Cell SPUs has borked IEEE-754 (no denorms, extended range instead of NaNs/infs)
10:24:56 <pumpkin> infinity is just a notation to say "grows unboundedly", and all this 1/0 = infinity stuff in computers helps people forget that it isn't an actual number :P
10:25:38 <BMeph> monadwr: I'm not sure, and it may just be propaganda, but I remember somepne bitching about Java's math. Maybe it's just Java, though. ;)
10:25:41 <dolio> There's no reason you can't just add it as a number in your system.
10:25:49 <mmorrow> pumpkin: but  6/0 /= 0
10:25:50 <dolio> It just isn't the "real numbers" from mathematics.
10:25:54 <dolio> But it wasn't anyway.
10:25:59 <roconnor> > 6/0 /= 0
10:26:00 <lambdabot>   True
10:26:11 <pumpkin> dolio: it gives you multiple inverses of the same number... if you choose to allow that then it'll give you a very different system
10:26:32 <adekoba> how would I go about making a class that can be used with "deriving ..."
10:26:45 <pumpkin> > 6/0
10:26:45 <ddarius> pumpkin: IEEE754 is already a very different system from the real numbers.
10:26:46 <lambdabot>   Infinity
10:27:02 <pumpkin> ddarius: yup
10:27:28 <BMeph> Man, with all of these spelling errors I'm making, and it being the day before Thanksgiving, you'd think I'd be drinking more... ;p
10:27:42 <mmorrow> Infinity doesn't have a multiplicative nor additive inverse
10:27:44 <roconnor> @check \a b c -> ((a + b) + c :: Double) == a + (b + c)
10:27:45 <lambdabot>   "Falsifiable, after 23 tests:\n1.6666666666666665\n4.25\n0.8\n"
10:27:52 <dolio> > (1/0) + (-1/0)
10:27:54 <lambdabot>   NaN
10:28:06 <pumpkin> mmorrow: I know :P because it isn't a number
10:28:07 <dolio> All the stuff that would result in 'multiple inverses' is just NaN.
10:28:22 <pumpkin> dolio: yeah, but if you take them individually and extrapolate then you can get them :P
10:28:38 <roconnor> > (1/0) + (-1/0) == (-1/0) + (1/0)
10:28:39 <lambdabot>   False
10:28:42 <pumpkin> yup
10:29:02 <BMeph> dolio, pumpkin: Maybe you want Ordinals, not just Naturals. Although I don't think it helps. :)
10:29:22 <mmorrow> pumpkin: well it /is/ a "number", since we defined it as such :) it just is separate from the algebraic structure R can be thought to have
10:29:24 <dolio> pumpkin: But then you aren't following the rules of IEEE, you're trying to reason about them like they're the reals. :)
10:29:41 <pumpkin> mmorrow: okay, I guess if you want to define it as such :P
10:29:48 <mmorrow> R + Inf ==> sphere in 1 dimension
10:30:14 <mmorrow> R^2 + Inf ==> 2D sphere embedded in 3D
10:30:20 <mmorrow> R^3 + Inf ==> 3D sphere embedded in 4D
10:30:22 <mmorrow> ...
10:31:07 <roconnor> infinity is just the cut (\x:Rational -> True,\x:Rational -> False), and -infinity is the cut (\x:Rational -> False,\x:Rational -> True)
10:31:08 <pumpkin> let me guess what the next one is
10:31:16 <roconnor> screw the requirement that cuts be nonempty
10:31:23 <pumpkin> :P
10:32:10 <mmorrow> if you were going to guess 13D octagon in the 12D unit cube... you're correct!
10:32:26 <mmorrow> oh wait, oops
10:32:52 <mmorrow> i meant pentagon
10:35:39 <dons> dcoutts_: wanna write up strictcheck for TAP?
10:36:35 <pumpkin> mmorrow: of course!
10:37:58 <gwern> any yi people here? I have an odd bug - Shim/Utils.hs on -Wall always causes a warning about Data.List beingunusued, yet commenting it out causes a compile failure
10:38:10 <gwern> is ghc 6.10 known to have false positives like that?
10:38:12 <mmorrow> pumpkin: :)
10:38:34 <ksf> gwern, reexport?
10:38:52 <gwern> ksf: yes, the function using elem is being exported in the module header
10:39:31 <mib_tumbj3j5> hey guys, how do i register, new to this
10:39:35 <ksf> nah, i meant whether Data.List(..) is reexported.
10:39:53 <gwern> no
10:40:33 <ksf> if a function really uses elem, that means that a) elem is also imported from somewhere else, which is borked or b) something is borked
10:41:40 <mib_tumbj3j5> can anyone help me please
10:42:06 <vininim> Only if you state your problem
10:42:19 <mib_tumbj3j5> 18:39	mib_tumbj3j5	hey guys, how do i register, new to this
10:43:10 <vininim>  /msg nickserv help
10:43:28 <vininim> if you mean freenode
10:43:29 <geezusfreeek> gwern, are you exporting the function that uses elem?
10:43:39 <geezusfreeek> oh you said that already
10:44:00 <mib_tumbj3j5> REGISTER
10:44:36 <geezusfreeek> mib_tumbj3j5, all registration and other nick services are done through NickServ
10:44:42 <geezusfreeek> so use /msg nickserv for everything
10:44:47 <mib_tumbj3j5> opps sorry
10:45:10 <geezusfreeek> mib_tumbj3j5, be extra careful you do every time or you may reveal passwords to everybody ;)
10:45:10 <vininim> would be safer if you opened a separate window for chatting with Nickserv
10:47:02 <mib_tumbj3j5> hmm
10:48:14 <mib_tumbj3j5> thanks guy, just need to activate it now
10:49:43 <mib_tumbj3j5> hmm
10:49:49 <mib_tumbj3j5> didnt work lol
10:52:54 <Raevel> oh i just figured out what my first lambdabot project will be
10:52:59 <Raevel> the much needed @hi5
10:54:28 <mib_tumbj3j5> hmm i didnt want this as my name lol
10:55:44 <luqui> mib_tumbj3j5, it's fine, you may register multiple names
10:56:47 <mib_tumbj3j5> luqui how do i add a proper name, rather then mib_tumbj3j5
10:57:01 <enolan>  /nick TheNameYouWant
10:57:06 <EmielRegis> how to get arguments passed to main function?
10:57:14 <quicksilver> @hoogle getArgs
10:57:15 <lambdabot> System.Environment getArgs :: IO [String]
10:57:20 <EmielRegis> danke
10:57:37 <quicksilver> if you mean command line args passed to a compiled app, that is.
10:57:52 <quicksilver> if you just mean args passed in ghci, well you can do whatever you want there ;)
10:59:41 <mikey> I think that did it
10:59:44 <jeffwheeler> mikey: once you find a name you like (that isn't registered by somebody else), you can register itself with nickserv
10:59:54 <jeffwheeler> s/itself/it
10:59:59 <mikey> phew lol
11:00:18 <taari> hey, I just wanted to ask, if you know a shorter version than that: (average length of lists within a list, I know it has devide-by-zero bug)
11:00:21 <taari> averageLength :: [[t]] -> Int
11:00:24 <taari> averageLength n = length (concat n) `div` length n
11:01:08 <taari> (rounded down of course)
11:01:53 <trofi> length.concat -> sum.map length ?
11:01:57 <Deewiant> ?pl averageLength n = length (concat n) `div` length n
11:01:58 <lambdabot> averageLength = ap (div . length . join) length
11:03:13 <roconnor> @bab nl en onderhoudswerkzaamheden
11:03:15 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
11:03:18 <taari> oh, nice. I give them a try :)
11:03:30 <mikey> hey would someone be able to help me with my exercise, http://hpaste.org/12333 thought id paste the whole thing so you can read the question, its quite long lol
11:03:56 <Deewiant> > uncurry div . foldl' (\(a,b) x -> (a+length x, b+1)) (0,0) $ ["123","1234","12345","123456"]
11:03:58 <lambdabot>   4
11:04:23 <EmielRegis> is there a library function that checks whether a string contains given phrase?
11:04:30 <Deewiant> isInfixOf
11:04:50 <mauke> mikey: I see no question
11:04:56 <mikey> ?
11:05:14 <quicksilver> > "Reg" `isInfixOf` "EmielRegis"
11:05:16 <mauke> that's not a question either
11:05:16 <lambdabot>   True
11:05:22 <EmielRegis> danke
11:05:47 <mikey> lol thats what i get given by my lecturer lol
11:05:48 <quicksilver> mikey: people are not likely to take a homework question and just answer it for you.
11:06:02 <mikey> im not asking that though
11:06:02 <quicksilver> if you make an attempt to solve it, show us your attempt, and ask a question about where you got stuck
11:06:09 <quicksilver> then people may well be helpful.
11:06:21 <mauke> (also, stop saying "lol"; it makes you look stupid)
11:06:37 <mikey> ok
11:06:46 <gwern> @undo dbLocation = do home <- getDirectory; return (home ++ "yi/articles.db")
11:06:46 <lambdabot> dbLocation = getDirectory >>= \ home -> return (home ++ "yi/articles.db")
11:06:51 <Deewiant> > uncurry div . foldl' (flip$(***(1+)).(+).length) (0,0) $ ["123","1234","12345","123456"]
11:06:52 <lambdabot>   4
11:06:55 * quicksilver thinks mauke is stupid. lol.
11:06:57 <EmielRegis> > "reg" `isInfixOf` "Regis"
11:06:59 <lambdabot>   False
11:07:05 <mauke> > cycle "lo"
11:07:06 <EmielRegis> case sensitive
11:07:07 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
11:07:10 <EmielRegis> lolol
11:07:25 <luite_> > cycle "ke"
11:07:27 <lambdabot>   "kekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekeke...
11:07:34 <ksf> we're all just hacking haskell for the lulz, aren't we?
11:07:38 <luite_> yes
11:07:40 <mauke> > (isInfixOf `on` map toLower) "reg" "Regis"
11:07:41 <Deewiant> > repeat '.'
11:07:41 <lambdabot>   True
11:07:43 <lambdabot>   ".............................................................................
11:07:47 <quicksilver> > (isInfixOf `on` map toLower) "reg" "Regis"
11:07:48 <trofi> @elite yeah we are
11:07:49 <lambdabot>   True
11:07:49 <lambdabot> y3AH We ARe
11:07:51 <quicksilver> damnit!
11:07:56 <quicksilver> mauke faster than me.
11:08:04 <mauke> hivemind
11:09:52 <quicksilver> @faq can haskell do it for the lulz?
11:09:55 <lambdabot> The answer is: Yes! Haskell can do that.
11:10:27 <Deewiant> > ((>>>) >>> (>>>) (>>>)) isInfixOf (map toLower) "reg" "Regis"
11:10:29 <lambdabot>   True
11:10:44 <vixey> :t (((>>>) >>>) >>>)
11:10:45 <mauke> needs more fmap
11:10:45 <lambdabot> forall (a :: * -> * -> *) b c d d1 d2. (Arrow a) => ((a b c -> d1) -> d2) -> ((a c d -> a b d) -> d1) -> d2
11:11:45 <Deewiant> > (flip fmap (flip fmap) (flip fmap $ flip fmap)) isInfixOf (map toLower) "reg" "Regis" -- mauke: if you insist
11:11:47 <lambdabot>   True
11:12:26 <Twey> Ooh, more regulars on now
11:12:53 <mauke> > fmap (`fmap` flip fmap) (flip fmap) isInfixOf (map toLower) "reg" "Regis"
11:12:54 <lambdabot>   True
11:13:42 <Saizan> Twey: you judge by the density of unintellegible code?:)
11:13:54 <Twey> Hah
11:14:13 <Deewiant> > (>>>)(>>>)((>>>)(>>>)) isInfixOf (map toLower) "reg" "Regis"
11:14:14 <lambdabot>   True
11:14:38 <RLa> uh
11:14:59 <RLa> do people really need so ugly code
11:15:05 <Deewiant> > let (.) = flip (Prelude..) in (.)(.)((.)(.)) isInfixOf (map toLower) "reg" "Regis"
11:15:06 <BMeph> Twey: Are you feeling...irregular? ;)
11:15:07 <lambdabot>   True
11:16:00 <RLa> Deewiant, what that does?
11:16:11 <Twey> If I have a datatype A = Func (Value -> MFoo Value) | Number Double, and I want a Func of multiple parameters, so that that latter Value is going to be itself a Func over a (Value -> MFoo Value), is there a nice way of abstracting this?
11:16:38 <Twey> Right now I'm writing it all out manually, e.g. add = Func $ \a -> return $ Func (\b -> return . Number $ (unNum a) + (unNum b))
11:16:47 <Deewiant> ?ty let (.) = flip (Prelude..) in (.)(.)((.)(.))
11:16:49 <lambdabot> forall a a1 b c. (a -> b -> c) -> (a1 -> b) -> a -> a1 -> c
11:17:08 <mauke> @djinn  (a -> b -> c) -> (a1 -> b) -> a -> a1 -> c
11:17:09 <lambdabot> f a b c d = a c (b d)
11:17:28 <arjanb> is Deewiant a lambdabot version with extra pointless kind of features?
11:18:18 <mikey> hmm im so confused
11:18:19 <Deewiant> :-)
11:18:49 <Deewiant> I derived that in my head, I find it a really useful combinator (but I always use the pointy version because it isn't standard)
11:19:07 <mikey> twey has scarface got back in contact with you?
11:19:19 <Deewiant> It's kinda like 'on' but not
11:19:24 <EmielRegis> how would I get the string part from getArgs?
11:19:42 <earthy> @type getArgs
11:19:43 <lambdabot> Not in scope: `getArgs'
11:20:18 <EmielRegis> its IO [String]
11:20:26 <C-Keen> @hoogle getArgs
11:20:26 <lambdabot> System.Environment getArgs :: IO [String]
11:20:28 <Deewiant> (>>>)(>>>)((>>>)(>>>)) (*) f = \x y -> x * f y
11:20:29 <earthy> right
11:20:45 <earthy> emielregis:
11:21:02 <C-Keen> args <- getArgs
11:21:05 <Twey> Deewiant: (let (.) = flip (Prelude..) in (.)(.)((.)(.))) === on?
11:21:05 <mauke> @pl \c f x y -> c x (f y)
11:21:05 <lambdabot> flip . ((.) .)
11:21:05 <earthy> do { argumetns <- getArgs; processArguments argumetns ; }
11:21:12 <mauke> @pl x y -> c x (f y)
11:21:13 <lambdabot> (line 1, column 5):
11:21:13 <lambdabot> unexpected ">" or "-"
11:21:13 <lambdabot> expecting variable, "(", operator or end of input
11:21:18 <mauke> @pl \x y -> c x (f y)
11:21:18 <lambdabot> (. f) . c
11:21:20 <earthy> where processArguments :: [String] -> IO ()
11:22:11 <Twey> A.K.A. getArgs >>= processArguments
11:22:27 <Twey> Nobody want to help me refactor that?  :(
11:22:37 <vixey> that looks fine
11:22:38 <EmielRegis> im doing this http://hpaste.org/12404
11:22:40 <Twey> mikey: We're not in contact, but through that thread
11:22:44 <earthy> let doSomething :: [String] -> String; doSomething = concat in processArguments args = print . doSomething
11:22:46 <EmielRegis> and it says 'not in scope args'
11:23:05 <EmielRegis> what am i doing wrong?:p
11:23:09 <earthy> (ofcourse, that was syntactically incorrect, I'm tired)
11:23:17 <Twey> vixey: Func $ \a -> return . Func $ \b -> return . Number $ (unNum a) + (unNum b) for a simple function of two arguments is not fine :-P
11:23:28 <quicksilver> EmielRegis: where blocks don't scope inside do blocks
11:23:32 <Twey> Or were you talking about something else?
11:23:36 <quicksilver> EmielRegis: that where block is attached to the 'main' definition
11:23:37 <Deewiant> Twey: no, it's not on
11:23:37 <mauke> EmielRegis: 'args' is created by the first line in main; it's not available in outside functions
11:23:40 <EmielRegis> ah
11:23:41 <quicksilver> EmielRegis: so it can't see args
11:23:44 <EmielRegis> i understand
11:23:47 <quicksilver> EmielRegis: you can use let inside do
11:23:48 <Deewiant> Twey: compare:
11:23:49 <Deewiant> (>>>)(>>>)((>>>)(>>>)) (*) f = \x y -> x * f y
11:23:51 <Deewiant> ?src on
11:23:51 <lambdabot> (*) `on` f = \x y -> f x * f y
11:23:57 <quicksilver> let isHDR = List.isInfixOf "hdr" args
11:23:59 <vixey> Twey, oh I meant getArgs >>= processArguments
11:24:06 <quicksilver> as a line in the doblock
11:24:10 <Twey> Ah
11:24:16 <quicksilver> (or you could make args a parameter to isHDR if you prefer)
11:24:32 <EmielRegis> thanks
11:24:46 <quicksilver> to be honest, I think you probably want "filter (isInfixOf "hdr") args"
11:24:51 <quicksilver> cos args is a list
11:25:05 <quicksilver> and you want to get the ones it applies to, only, I assume
11:25:12 <EmielRegis> ah ye
11:26:54 <ksf> don't be afraid of overkill, just use parsec to handle your arguments.
11:27:35 <BMeph> ksf: So to you, overkill is underrated ;p
11:38:53 <ksf> a optimal working model's main characteristics are a) being bijective to the thing modelled and b) internal integrity is ensured by smallest changes causing vast inconsistencies
11:39:49 <ksf> therefore, an optimal working model is a holographic projection of objective reality construed by the mind.
11:40:08 <ksf> insert a "direct" there.
11:40:15 <lament> the smallest changes in objective reality don't cause vast inconsistencies
11:40:45 <ksf> they do if things don't change like they should.
11:41:01 <ksf> as that'll break internal integrity.
11:41:24 <lament> for example, if a butterfly flaps its wings in Brazil, absolutely nothing happens in Texas
11:41:38 <ksf> imposition of order == escalation of chaos, though i didn't want to argue discordianistic here.
11:42:14 <ksf> like imposing the law "every butterfly flap causes tornadoes" escalates nonsense.
11:42:42 <mauke> nah, not every butterfly; just quantum butterflies
11:42:46 <ksf> see "excluded middle"
11:42:47 <mauke> it's a rather special species
11:43:06 <C-Keen> there is even an emacs macro for that
11:43:12 <lament> ksf: are you related to Keal?
11:43:22 <ksf> for the butterly effect?
11:43:24 <ksf> kudos.
11:43:40 <ksf> keal?
11:43:43 <mauke> @keal
11:43:43 <lambdabot> the fractal is 5 irrationals
11:43:44 <quicksilver> @keal
11:43:45 <lambdabot> can haskell compile flash animations and java apps?
11:43:56 <C-Keen> http://xkcd.com/378/
11:43:57 <lambdabot> Title: xkcd - A Webcomic - Real Programmers
11:43:58 <jdrake> Do we have a (^) operator that is fractional?
11:44:03 <gwern> whew, enough Yi stuff today
11:44:08 <ksf> ah, i read his quotes in the lambdabot source.
11:44:08 <quicksilver> jdrake: ^^ and **
11:44:12 <quicksilver> :t (^^)
11:44:14 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:44:15 <quicksilver> :t (**)
11:44:17 <lambdabot> forall a. (Floating a) => a -> a -> a
11:44:21 * skorpan just got a proposal to make his MSc thesis about an Agda-mode for yi
11:44:28 <ksf> the answer is: no, i try not to swing teabags.
11:44:39 <byorgey> skorpan: sounds neat!
11:44:39 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
11:44:48 <quicksilver> skorpan: a working Yi would be a good start, wouldn't it?
11:44:52 <quicksilver> or is it usable now?
11:44:56 <skorpan> it is usable
11:44:59 <Botje> that's technical details, no? :p
11:45:02 <skorpan> at least jean-philippe uses it
11:45:03 <gwern> everyone forgets that the flip side of the butterfly is that power is conserved, and so there are for everytime a butterfly is powerful, there is a time where even a nuke will be helpless
11:45:15 <jdrake> ok, now are Fractional and Floating compatible with each other?
11:45:37 <gwern> well, gtk yi has problems for me - the last time I used it the colors were messed up and I can't even compile gtk yi since I can't get gtk2hs to compile under 6.10
11:45:49 <gwern> (actually, I've never gotten gtk2hs to compile, so I shouldn't blame 6.10)
11:45:53 <Valodim> the interesting thing about that comic is its caption, which pretty much solves the entire intelligent design <-> evolution discussion :)
11:46:04 <quicksilver> jdrake: Floating is slightly more restrictive.
11:46:10 <ksf> a butterfly isn't powerfull, if it happens to be able to excert staggering force, he won't be able to control it at it's whim.
11:46:12 <quicksilver> jdrake: "Rational" is fractional but not Floating.
11:46:31 <ksf> force and power aren't the same.
11:46:46 <jdrake> I think it would be best for me to avoid floating point. I am dealing with money.
11:47:05 <quicksilver> Valodim: indeed. The expansion of pi contains my mobile phone number. Coincidence? I think not.
11:47:20 <jdrake> The specific use does not make much difference, but I might as well find out how to deal with it best now.
11:47:26 <quicksilver> jdrake: Rational or Fixed sounds like a good plan.
11:47:37 <quicksilver> jdrake: and in that case I imagine you want ^^
11:47:42 <Valodim> well I'm pretty sure the expansion of pi contains every telephone number there is so nothing special dude :P
11:47:49 <quicksilver> (which restricts you to integral powers)
11:47:52 <ksf> on another scale, lao tse said "A steady drop carves the hardest stone, everyone knows it, noone uses it as a maxim"
11:48:18 <quicksilver> Valodim: I can't remember if that's been proved. Or if it's merely probability 1 that it contains then, which is not quite the same.
11:48:40 <jdrake> Why does ^^ want an integral b?
11:48:47 <gwern> ksf: 'slow and steady wins the race'
11:48:55 <jdrake> My power is certainly not integral
11:48:56 <quicksilver> jdrake: because that's more sane.
11:49:04 <quicksilver> jdrake: what is your power?
11:49:06 <Valodim> by proving that it's transcendent, you prove that it contains every other finite sequence of numbers there is, nuh?
11:49:08 <jdrake> interest pv rate = pv * (1 + rate / 365)^^(365/(1/12)) - pv
11:49:16 <quicksilver> Valodim: no, not at all.
11:49:35 <jdrake> I suppose 365/(1/12) is 365*12
11:49:49 <quicksilver> Valodim: 1.110001000000000000000001.... is transcendental
11:49:57 <jdrake> > 365/(1/12)
11:49:59 <lambdabot>   4380.0
11:50:01 <jdrake> > 365*12
11:50:03 <lambdabot>   4380
11:50:05 <quicksilver> Valodim: indeed, it was the first number so proved. And it lacks lots of subsequences.
11:50:20 <quicksilver> jdrake: the only way we know to do general powers is to use exp/log
11:50:24 <Valodim> hm
11:50:34 <quicksilver> jdrake: which are transcendentals, so that's Floating =>
11:50:47 <Valodim> thatmakes sense
11:50:57 <jdrake> quicksilver, unless I use the taylor series...
11:51:06 <jdrake> But I have a function now that is all fractional
11:51:11 <quicksilver> jdrake: that's just an approximation to using exp/log, surely?
11:51:47 <quicksilver> anyhow, compound interest requires such things so as far as I know you just have to be clear about when you are rounding.
11:51:48 <jdrake> quicksilver, exp / log have to be calculated somewhere, and it is my estimation that it would have to be the taylor series by which it does it
11:51:59 <quicksilver> (to use them in finance)
11:52:06 <jdrake> > interest pv rate = pv * (1 + rate / 365)^^(365 * 12) - pv
11:52:07 <lambdabot>   <no location info>: parse error on input `='
11:52:13 <jdrake> > let interest pv rate = pv * (1 + rate / 365)^^(365 * 12) - pv
11:52:14 <lambdabot>   <no location info>: parse error on input `;'
11:52:15 <quicksilver> such as "interest calculated daily, rounded to the nearest cent"
11:52:55 <jdrake> of course my function doesn't actually work :-(
11:53:17 * Valodim looking for his phone number in pi
11:53:40 <jdrake> My source function is =B3*(1+($I$3/365))^(365*(1/12))-B3  where B3 is pv, $I$3 is the interest rate in decimal
11:55:28 <Raevel> could someone please explain how ap works?
11:55:40 <ddarius> @src ap
11:55:40 <lambdabot> ap = liftM2 id
11:56:25 <vixey> :t liftM2 id
11:56:27 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
11:56:57 <vixey> > ap [(+1),(*2)] [4,6]
11:56:59 <lambdabot>   [5,7,8,12]
11:57:26 <Aser> hello. i've got a list which looks like this: [(String1, [("String2, "String3), (String5, String6)], several repeatings of the system, ]. now i want to write a recursiv function which gets a String and checks if this is equal to the String1, or the next String in the tupel before the list in the list. shorter example: l=[(a,[(b,c),(d,e)]),(f,[(g,h), (i,j),]) and so one. so i want to check the given string with a, f, ... and print out all the other el
11:57:30 <vixey> what's ap for?
11:57:34 <vixey> (I've never used it)
11:57:50 <Raevel> lambdabot likes it, at least
11:57:58 <dolio> It's for specializing to the S combinator.
11:58:06 <vixey> Aser, doesn't make sense.. maybe define a datatype instead of using tuples
11:58:30 <Raevel> my head hurts. perhaps i'll try again tomorrow
11:58:50 <dolio> Would do notation help?
11:59:04 <dolio> ap mf mx = do f <- mf ; x <- mx ; return (f x)
11:59:54 <Raevel> what is the implementation of return on lists?
12:00:04 <Deewiant> return = (:[])
12:00:08 <dolio> @src [] return
12:00:08 <lambdabot> return x    = [x]
12:00:26 <Raevel> oh cool, didn't know lambdabot could do that
12:01:43 <r3m0t> @src [] fail
12:01:43 <lambdabot> fail _      = []
12:03:13 <Raevel> so is f <- mf == head mf for lists?
12:03:21 <mauke> no
12:03:24 <Raevel> shoot
12:03:25 <mauke> it's a loop :-)
12:03:38 <pk> hey
12:03:44 <Raevel> a loop?
12:03:46 <pk> I wonder something
12:03:55 <mauke> Raevel: yes, f is all elements in mf
12:04:04 <jdrake> Is there a way to get a list of all operations that work on fractionals?
12:04:11 <pk> if I have something like x = "1234" ++ "5678"
12:04:12 <r3m0t> hoogle?
12:04:23 <pk> now I want the value of head x
12:04:41 <pk> will the ++ thing ever called ?
12:04:51 <mauke> yes
12:04:55 <r3m0t> yes, once
12:04:59 <Stephan202> yes, but "5678" will not be evaluated
12:05:02 <Deewiant> in that case not since GHC optimizes it out ;-)
12:05:07 <mauke> @src (++)
12:05:07 <lambdabot> []     ++ ys = ys
12:05:08 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:05:08 <lambdabot> -- OR
12:05:08 <lambdabot> xs ++ ys = foldr (:) ys xs
12:05:09 <gwern> you would think ghc would replace it with a constant at compile-time
12:05:16 <Deewiant> It does, for ++
12:05:26 <mauke> gwern: then it's still called once, at compile time :-)
12:05:33 <Stephan202> ;)
12:05:35 <Deewiant> For others, such as length, it doesn't
12:05:44 <Pellwurst> how can i use printf to format strings? do i need to load a special modul?
12:05:51 <mauke> Pellwurst: yes, Text.Printf
12:05:55 <byorgey> @index printf
12:05:55 <lambdabot> Text.Printf
12:06:15 <gwern> hm. what is a .hs.pp file?
12:06:33 * mauke guesses "preprocessed"
12:06:40 <gwern> perhaps
12:06:44 <pk> thx
12:06:59 <gwern> but I dsicovered an unwelcome fact - apparently gtk2hs doesn't check to make sure you have c2hs installed
12:07:21 <pk> is there a way to tell ghc about computing some things at compile time ?
12:07:49 <Deewiant> There's template haskell but nothing simple :-/
12:07:55 <gwern> pk: yes, Template Haskell is all compile time
12:08:16 <pk> what's that
12:08:31 <Deewiant> Metaprogramming
12:08:53 <vixey> pk, which things?
12:09:02 <Pellwurst> And how do I load that Text.Printf (not by typing it into the interpreter, but by writing it down in the code)?
12:09:10 <pk> template haskell
12:09:14 <Deewiant> 'import Text.Printf'
12:09:21 <Pellwurst> kk thx ;)
12:10:04 <pk> what does template haskell add ? I mean, functions are already polymorphics
12:10:34 <sutats> Can someone combine this into one line? http://hpaste.org/12406
12:10:51 <roconnor> pk: ZipN
12:10:52 <roderyk> tried to cabal install download, but got errors that array needs base>4; but checking hackage there doesn't seem to be such a req. Do I need to really upgrade from ghc 6.8.2? If so, is there an unofficial deb repo around with a newer build?
12:11:00 <jdrake> What does this construct mean? class Fractional a => Floating a where
12:11:03 <Deewiant> sutats: replace 'filter secondIsTen' with 'filter (\(a,b) -> b == 10)'
12:11:34 <lament> zipN doesn't seem very impressive
12:11:45 <lament> you can certainly live without it
12:11:49 <mauke> Data.Derive
12:11:58 <roconnor> lament: you can live without TH
12:12:07 <sutats> Deewiant: Okay, that works. Is there a cleaner way without using a lambda expression?
12:12:12 <roconnor> lament: you can live without Haskell, just write machine code.
12:12:18 <roconnor> :)
12:12:22 <mauke> filter ((10 ==) . snd)
12:12:25 <Deewiant> sutats: ((== 10) . snd)
12:12:26 <Botje> snd >>> (==10à)
12:12:32 <mauke> â
12:12:40 <Deewiant> sutats: Whether it's cleaner or not is arguable, of course :-)
12:13:04 <sutats> Deewiant: I just try to avoid them because of the extra binding.
12:13:06 <lament> roconnor: i'm trying to tell if you had a point there
12:13:11 <byorgey> jdrake: that's a definition of a type class called 'Floating', with the constraint that any type 'a' which is an instance of Floating must also be an instance of Fractional
12:13:29 <roconnor> lament: being able to live without ZipN isn't much of an argument.
12:13:37 <sutats> Botje: What's the à for?
12:13:40 <jdrake> byorgey, meaning a floating is a more restrictive version of fractional?
12:13:45 <lament> roconnor: ZipN is not a good selling point
12:13:48 <byorgey> jdrake: right.
12:14:10 <Saizan> lament: Data.Derive
12:14:11 <lament> roconnor: somebody must be using TH for something and it probably isn't ZipN cause then they probably just wouldn't bother
12:14:14 <jdrake> Now floating is just a floating point that has the same inaccuracies as in any other language right?
12:14:17 <byorgey> jdrake: more restrictive in the sense that there are additional methods that must be defined for it.
12:14:18 <roconnor> lament: no, but it is a simple and easy to grasp example of something that TH gives that is beyond haskell.
12:14:52 <byorgey> jdrake: generally, yes, although the class Floating itself does not specify that.
12:15:09 <byorgey> jdrake: but the type Double is the same as the C type double, for instance.
12:15:21 <Pellwurst> I loaded the module Text.Printf by import.... But i still get an error like printf not in scope
12:15:34 <byorgey> jdrake: there are libraries for arbitrary-precision real numbers on hackage, though.
12:15:39 <jdrake> byorgey, because I need to have an exponent that is a fraction, but I cannot lose anything.
12:15:49 <jdrake> byorgey, got a specific one you know of?
12:16:04 <byorgey> jdrake: you probably want CReal then.
12:16:05 <vixey> jdrake, may not be on hackage but CReal is decetn
12:16:14 <lament> data.derive does look neat
12:16:26 <byorgey> > (3 ** (1/2)) ^ 2
12:16:27 <lambdabot>   2.9999999999999996
12:16:28 <jdrake> I don't see CReal
12:16:30 <byorgey> > (3 ** (1/2)) ^ 2 :: CReal
12:16:31 <lambdabot>   3.0
12:16:41 <Saizan> jdrake: numbers package
12:17:06 <roconnor> > cos (2*pi/3) :: CReal
12:17:08 <lambdabot>   0.5
12:17:12 <roconnor> > cos (2*pi/3)
12:17:13 <lambdabot>   -0.4999999999999998
12:17:21 <byorgey> so, it's got a few bugs...
12:17:25 <roconnor> :)
12:17:29 <jdrake> ok, I will look into those
12:17:30 <jdrake> Thank you all
12:17:32 <jdrake> I must jet
12:18:17 <jdrake> Is it possible CReal is already present? If it may be, how could I test it
12:18:19 <bauchus> hello. how can I use my own library in ghci? I do ":m Multimedia.Xine" and get "module main:Multimedia.Xine is not loaded" :-(
12:18:34 <bauchus> installation is done as cabal package
12:18:54 <Pellwurst> I loaded the module Text.Printf by import.... But i still get an error like printf not in scope....anyone can help?
12:19:08 <Saizan> bauchus: you may need to restart ghci
12:19:09 <gwern> bauchus: :load file
12:19:28 <roconnor> jdrake: Prelude> :m + Data.Number.CReal
12:19:30 <gwern> or ghci file.hs is good
12:19:53 <Saizan> Pellwurst: put import Text.Printf into your file if you're working with one
12:20:01 <bauchus> hm. I did "setup configure+build+install" and start ghci with -package xine.
12:20:06 <Saizan> Pellwurst: just importing it at the ghci prompt won't
12:20:21 <jdrake> ok, definitely do not
12:20:36 <Saizan> bauchus: then don't start ghci from the root of the source tree :)
12:20:36 <Pellwurst> Saizan: I did put it in my code
12:20:45 <mauke> Pellwurst: show your code
12:21:04 <byorgey> bauchus: there is a strange bug where doing a :m + package from the same directory where the source of 'package' is located will cause it to not load.
12:21:10 <jdrake> thank you all
12:21:18 <byorgey> I have no idea why.  I spent a few hours banging my head against that one a while back.
12:22:06 <bauchus> byorgey: you are right! thanks
12:22:31 <Saizan> byorgey: because ghci thinks you want the one in your searchpath rather than the one installed
12:22:45 <Saizan> byorgey: and since you didn't tell it to :load it errors out
12:23:09 * byorgey mumbles something about principle of least surprise
12:25:03 <Pellwurst> mauke: fixed already....thx
12:36:07 <drguildo> is anyone aware of any ghc 6.10 packages for ubuntu?
12:36:26 <Saizan> there's the generic linux binary
12:37:04 <andun> can i do something like 'data S = S { v :: Integral a => a }'? (with GADTs or whatever)
12:37:36 <Saizan> data S = forall a. Integral a => S { v :: a}
12:37:46 <vixey> andun if you just leave out the Integral => a bit, doesn't it all work fine?
12:37:46 <andun> oh, thanks :)
12:37:56 <Saizan> be sure to know what you're doing though..
12:38:04 <andun> vixey: yeah, but i want something more specific
12:38:05 <vixey> (if you allow type inference to do its work)
12:38:06 <byorgey> andun: with GADTs you can also have per-constructor constraints.
12:38:26 <Saizan> andun: should the 'a' be a parameter of your type or not?
12:38:51 <andun> yes, i think so
12:38:59 <Saizan> data S a = Integral a => S { v :: a }, then
12:38:59 <byorgey> data S :: * -> * where  T :: S Int ; R :: Integral a => S a
12:39:52 <andun> thank you. i didn't know the syntax
12:41:54 <drguildo> Saizan, i guess that's my best option. thanks.
12:43:10 <drguildo> also, i was wondering if anybody had knew of any articles on haskell that, when stating the benefits of the language actually gave examples comparing it to other (i guess imperative) languages?
12:45:57 <drguildo> hmm, i think i've found what i'm looking for
12:45:58 <drguildo> http://www.haskell.org/haskellwiki/Why_Haskell_matters
12:46:00 <lambdabot> Title: Why Haskell matters - HaskellWiki
12:47:09 <Pellwurst> I've got a list of pairs (Int, String) and i'd like to negate all the Integers....can I use something like: map (fst.negate) list
12:48:03 <vixey> Pellwurst, map (first negate)
12:48:17 <Saizan> ?index first
12:48:17 <lambdabot> Control.Arrow
12:49:21 <sbahra> Pellwurst, also..
12:49:27 <sbahra> :t (fst . negate)
12:49:28 <lambdabot> forall a b. (Num (a, b)) => (a, b) -> a
12:49:33 <sbahra> :t (negate . fst)
12:49:34 <lambdabot> forall a b. (Num a) => (a, b) -> a
12:54:52 <sutats> How would "map fst . filter ((10 ==) . snd)" look with first/second or other arrow functions?
12:56:05 <vixey> :t map fst . filter ((10 ==) . snd)
12:56:06 <lambdabot> forall a b. (Num b) => [(a, b)] -> [a]
12:58:32 <aconbere> Is there a package that people commonly use for testing their applications?
12:59:18 <Saya> try QuickCheck out
12:59:36 <blueonyx> at the first sight hunit seems simpler
13:00:02 <roconnor> help, I need a category theorist!
13:01:10 <jpcooper> roconnor, I was going to say go to #haskell, but I realised that this was #haskell
13:02:27 <aconbere> hUnit at least feels more familiar :)
13:02:52 <surgeon> hi all, I defined a function zipLists::Num a=> (a->a->a) -> [a] -> [a] -> a
13:02:55 <roconnor> I forgot that my catagory isn't cartesian closed.  So now I don't know of functoral strength is the same as tensoral strength.
13:03:06 <roconnor> it doesn't look good.
13:03:10 <geezusfreeek> aconbere, i highly highly recommend quickcheck
13:03:49 <surgeon> which takes to lists and combines one value of the first list with another, for the first, second, third element... and then makes the sum of all these numbers
13:04:10 <surgeon> now ghci says when loading:Fits.hs:12:0: Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for `zipLists'
13:04:23 <geezusfreeek> aconbere, the only problem you may have is testing IO actions, which you can get around by using unsafePerformIO or IOSpec in your quickcheck tests or by using hunit just for io actions
13:04:34 <vixey> surgeon, does it say the exact line of code?
13:04:45 <geezusfreeek> aconbere, smallcheck/lazysmallcheck are also worth a look once you get the hang of quickcheck
13:04:56 <geezusfreeek> although they are less popular yet
13:05:02 <surgeon> vixey: yes, I am returning a list closer there
13:06:05 <vixey> surgeon, know what you could try, delete the type signature and load the file
13:06:08 <vixey> surgeon, what happens?
13:06:32 <surgeon> vixey: still the same error
13:06:55 <surgeon> vixey: ah damn, I did mix up ++ with : , shame on me
13:07:31 <surgeon> vixey: hmm no I didn't
13:07:59 <Cale> aconbere: The quickcheck style of testing can be really powerful, not just because it automatically generates more tests than you could by hand, but because it gets you to think about what the important properties of your code are.
13:08:31 <surgeon> here's my code: http://rafb.net/p/ss7YwO50.html
13:08:36 <lambdabot> Title: Nopaste - Problem with combineList Function
13:08:51 <Cale> aconbere:
13:08:54 <Cale> whoops
13:09:02 <vixey> surgeon, remove the line "zipLists :: Num a => (a->a->a) -> [a] -> [a] -> a" and see what happens
13:09:12 <Cale> surgeon: Tab alert! You need to configure your editor not to insert tabs into your file.
13:09:28 <surgeon> Cale: why not? worked for now?
13:09:39 <Cale> surgeon: Well, yes, but inevitably it will lead to problems.
13:09:53 <geezusfreeek> surgeon, it will confuse ghc when using layout rules
13:09:53 <Cale> surgeon: (and you're being forced to indent things in awkward ways)
13:10:10 <mauke> it all depends on your indentation style
13:10:21 <geezusfreeek> mauke, and your consistency ;)
13:10:27 <Deewiant> Is there something like 'class Unwrappable u where unwrap :: u a -> a' somewhere?
13:10:47 <Cale> surgeon: It will "work" if your editor treats tabs as aligning to the next multiple of 8 columns (which is how the compiler will treat it), but not everyone's editor does.
13:10:55 <Saizan> Deewiant: Copointed from category-extras probably
13:11:09 <centrinia> Shouldn't zipLists :: Num a => (a -> a -> a ) -> [a] -> [a] -> [a] ?
13:11:15 <Cale> surgeon: And so it tends to make a mess of things if more than one person is editing the file.
13:11:21 <hackage> Uploaded to hackage: vcard 0.1
13:11:21 <hackage> Uploaded to hackage: hprotoc 1.2.1
13:11:21 <hackage> Uploaded to hackage: protocol-buffers-descriptor 1.2.1
13:11:21 <hackage> Uploaded to hackage: protocol-buffers 1.2.1
13:11:45 <surgeon> vixey: ah you're right, now it works. what's wrong with the definition
13:11:47 <Cale> surgeon: By being really careful, you can sidestep the problems and still use tabs, but it's not worth the trouble.
13:12:01 <surgeon> Cale: I've never had problems with tabs
13:12:10 <vixey> surgeon, well if you ask now ghci or whatever you are using to tell you the type that it has inferred
13:12:16 <Deewiant> Saizan: Cheers; a bit too heavyweight for me but good to know ;-)
13:12:21 <centrinia> surgeon, because zipLists should return an [a] :p
13:12:30 <surgeon> centrinia: ah damn *g*
13:12:40 <Cale> surgeon: If you're using vim, adding  set expandtab  to youe .vimrc will ensure that you never do ;)
13:12:52 <Cale> your*
13:13:09 <Deewiant> 'au FileType haskell setl expandtab'
13:13:13 <mauke> hey, I've successfully written haskell code with set sw=4 ts=4 noet
13:13:19 <blueonyx> is there a 3 letter shortcut for darcs?
13:13:25 <Deewiant> As have I, except sw=3 ts=3
13:13:40 <Cale> mauke: I'm not saying that it's impossible, I'm just saying that it's unwise.
13:13:41 <Deewiant> And no, I didn't use the space bar ;-)
13:13:47 <surgeon> Cale: ah, i give it a try, when I figured out how to restrict it to *.hs files
13:14:00 <mauke> see Deewiant's autocommand
13:14:10 <mauke> you could also use a filetype plugin
13:15:25 <Cale> The ascii tab character should be banished to the land of wind and ghosts.
13:15:45 <mauke> > '\v'
13:15:47 <lambdabot>   '\v'
13:15:50 <mauke> tee hee
13:15:50 <centrinia> > '\t'
13:15:51 <lambdabot>   '\t'
13:16:05 <Deewiant> \v is evil
13:16:17 <centrinia> What is wrong with '\v' ?
13:16:20 <mauke> random factoid: perl doesn't support \v
13:16:49 <mauke> this is also the difference between \s and [[:space:]] in regexes; \s doesn't match \v
13:17:40 <Saizan> there's a [[:space:]]?
13:17:44 <Cale> blueonyx: 3 letter shortcut?
13:18:09 <mauke> Saizan: there's a [[:foo:]] for every isfoo() in <ctype.h>
13:18:12 <blueonyx> like bzr for bazaar
13:18:16 <Cale> no.
13:19:44 <Cale> blueonyx: Of course, you can define an alias in your shell if you really have to type it that often ;)
13:19:52 <centrinia> You could symlink /usr/bin/darcs to /usr/bin/d
13:20:07 <thoughtpolice> @messages
13:20:07 <lambdabot> You don't have any new messages.
13:20:13 <mauke> alias Darcs=darcs
13:20:17 <mauke> D<tab>
13:20:52 <blueonyx> nah im writing recipes and there can be svn_* and bzr_* and ... darcs_*?
13:21:40 <mauke> and hg_
13:24:36 <jeffwheeler> What is Turbinado doing to allow this nonsense syntax? http://github.com/alsonkemp/turbinado/tree/master/App%2FLayouts%2FDefault.hs
13:24:39 <lambdabot> Title: App/Layouts/Default.hs at master from alsonkemp's turbinado — GitHub, http://tinyurl.com/5qgx93
13:25:01 <jeffwheeler> It doesn't seem to be manually parsing the file, but I also see nothing special being done.
13:25:21 <Cale> jeffwheeler: hsx?
13:25:36 <jeffwheeler> Cale: I don't know; I've never seen that before. I'll look at that.
13:26:01 <jeffwheeler> Cale: looks like you're right. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsx
13:26:03 <lambdabot> Title: HackageDB: hsx-0.4.6
13:26:09 <Cale> jeffwheeler: It's a preprocessor for transforming embedded XML into Haskell data constructors.
13:26:11 <jeffwheeler> That's really neat; I've never heard of that.
13:28:04 <roconnor> Cale: Are there any laws for a strong Functor?
13:28:32 <gwern> I've heard people say that hsp and hsx should be replaced by quasiquotation. I wonder how well that'd work
13:28:59 <Cale> I suppose in a category with products, you can define it.
13:29:14 <Cale> gwern: It could work reasonably well.
13:29:42 <Cale> gwern: You'd have an extra bit of bracketiness around your XML chunks.
13:29:55 <Cale> gwern: But there would be no need for a preprocessor.
13:30:38 <centrinia> Why is quasiquoting so effective?
13:31:03 <gwern> because it's nice to be (quasi)quoted
13:31:10 <centrinia> Okay.
13:31:22 <Cale> centrinia: I'm not sure what your question means :)
13:31:30 <RLa> what is quasiquoting at all?
13:31:34 <BMeph> gwern, Cale: Why not use the XML for the quasiquoting, instead of the other way around? :)
13:31:48 <Cale> BMeph: XML is a horrible mess.
13:32:05 <RLa> xml is well defined standard
13:32:07 <gwern> RLa: extenadble syntax. I think.
13:32:10 <BMeph> Cale: Is it? Or is how it's used just bad.
13:32:10 * Botje likes XML just fine
13:32:14 <gwern> somehint like the lisp stuff
13:32:20 <Cale> RLa: A well-defined standard horrible mess then.
13:32:33 <mainland> I'm a fan of quasiquotation ;)
13:32:35 <Botje> how can it be well-defined _and_ a mess? :)
13:32:39 <Cale> The problem it solves is not hard, and it does not solve the problem well.
13:32:41 <RLa> uh, i hate extendable stuff, makes code looking much worse than xml
13:32:53 <vixey> Bote, probably in a similar way to object oriented programs
13:32:59 <BMeph> Rla: You're not helping - Java is a "well-defined standard". Well, modulo your definitions of "well" and "defined", heh-heh. ;p
13:33:36 <centrinia> Didn't you ask "Why It's Nice to be Quoted"?
13:34:13 <BMeph> RLa: Pity - I love extendable stuff, which is one of the things I like most about Haskell (and what I especially liked about Forth).
13:34:53 <BMeph> mainland: Well, as the saying goes, "you practically wrote the book on it." Except it's a paper, not a book. ;)
13:35:25 <RLa> what's quoting, i'm looking at some examples and it's same as evaluating the code
13:35:30 <Cale> Really, XML is a syntax for trees, and once you notice this, it should become totally obvious that it is overcomplicated in a lot of ways.
13:36:25 <centrinia> What kind of tree has attributes and branches?
13:36:27 <mainland> RLa: the code that parses the quote is evaluated, but at compile time, not run time
13:36:29 <RLa> oh, attributes could be nodes instead of what they are? that would simplify it a lot
13:36:37 <Cale> RLa: sure, why not?
13:36:56 <RLa> mainland, something like staged programming?
13:37:30 <BMeph> Cale, RLa: That would eliminate one of the main ways in which S-exprs "fail" at doing the same thing as XML.
13:38:08 <Cale> BMeph: Well, yes. Ideally, you would keep simplifying and simplifying, and you'd end up with something which was essentially S-exprs.
13:38:18 <RLa> i think that some xml libs abstract both nodes and attributes as nodes
13:38:24 <mainland> RLa: yup. It's a lot like Template Haskell, except you can quote patterns and there's some magic that lets you keep track of source code locations in your quote parser so you can give decent error messages.
13:38:32 <RLa> so it's nodes all the way
13:38:43 * BMeph thinks sexprs belong to sexperverts...
13:38:46 <sbahra> Anyone here use "pesca"?
13:40:18 <RLa> mainland, i reviewed some metaml stuff latey, it was about staged programming and ideed, was quite complex (to preserve well-typedness at each stage)
13:41:12 <mainland> RLa: yeah, template haskell punts on that
13:42:04 <BMeph> sbahra: Besides it's being Russian for 'sand' and Spanish for 'fish' I've never heard of it. What is it? :)
13:42:20 <sbahra> BMeph, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pesca
13:42:21 <lambdabot> Title: HackageDB: pesca-4.0.1
13:43:10 <BMeph> Cale: At what point do you risk simplifying so much, that you're just trying to fit a tool you already have for a new job?
13:43:21 <Cale> BMeph: It's not a new job though.
13:43:30 <BMeph> Cale: (Which ironically, is kind of how we got XML in the first place... ;)
13:43:32 <Cale> BMeph: It's an old job, and we already had a solution for it.
13:43:51 <sanjuro> is it alright to ask questions related to xmonad here?
13:43:58 <Cale> sanjuro: It's fine.
13:44:01 <BMeph> sbahra: Hm, thanks. :)
13:44:09 <Cale> sanjuro: There is a #xmonad though, iirc.
13:44:38 <sanjuro> i'm on ubuntu intrepid 8.10 and i just installed xmonad and a bunch of prerequisite modules, i didnt do anything else other than create a new file ~/.gnomerc and did.. export windowmanager = xmonad or something like that
13:44:51 <sanjuro> i then proceeded to logout and picked for session, xmonad and i see nothing now
13:45:00 <sanjuro> err, i can see my desktop background.. nothing else
13:45:08 <sbahra> sanjuro, #xmonad is a better fit.
13:45:16 <sanjuro> ok
13:45:24 <Cale> sanjuro: hmm, the xmonad interface is pretty bare-bones. Is it possible that you're looking at xmonad?
13:45:28 <sbahra> sanjuro, tip: Press Ctrl-Alt-Enter
13:45:40 <sbahra> sanjuro, err, I mean Shift-Alt-Enter
13:46:11 <sanjuro> ill continue in #xmonad, but hitting those simultaneously did not invoke anything.
13:49:28 <roconnor> @src ap
13:49:28 <lambdabot> ap = liftM2 id
13:49:45 <BMeph> Cale: So, do you think XML is essentially just a tree syntax format? Not trolling, I'm genuinely curious.
13:50:04 <Cale> Yes, I do. A horribly overcomplicated syntax for trees.
13:50:04 <olsner> is that a matter of opinion?
13:51:10 <Cale> The idea that we should have a standard way to serialise trees of data so that they can be moved between programs is great, but XML is a terrible solution.
13:51:53 <gwern> dunno. what would make it not an opinion? a very short program which losslessly translated from a lisp-like tree to xml and back?
13:52:22 <lament> xml combines tree-likeness with markup-likeness
13:52:45 <lament> sexprs are just tree-like without markupness
13:52:56 <Cale> How are sexprs not like markup?
13:53:03 <Cale> (just out of interest :)
13:53:19 <roconnor> @src liftM2
13:53:19 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:53:33 <roconnor> @undo do { x1 <- m1; x2 <- m2; return (x1 x2) }
13:53:34 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (x1 x2)
13:53:42 <vixey> :t (liftM2 .) . liftM
13:53:43 <lambdabot> forall a1 a2 r (m :: * -> *) a11. (Monad m) => (a11 -> a2 -> r) -> (a1 -> a11) -> m a1 -> m a2 -> m r
13:53:50 <jeffwheeler> Cale: what's a better solution? (I haven't been following the entire conversation, so I might have missed something.)
13:53:54 <vixey> oh I was excepting ap
13:54:00 <Cale> jeffwheeler: I propose s-expressions.
13:54:10 <jeffwheeler> Cale: I'll look at that; thanks.
13:54:12 <lament> Cale: typical markup has 1 level of nesting, the objects on the inner level have a very different structure from the single object on the outer level which contains them
13:54:32 <lament> no, that's wrong
13:54:41 * lament rethinks
13:56:47 <lament> Cale: there's no lisp equivalent of what in XML is the body of a composite object
13:56:56 <lament> Cale: i.e. "text with markup"
13:56:58 <aconbere> huh?
13:57:04 <lament> s/lisp/sexpr
13:57:19 <Cale> lament: Sorry?
13:57:20 <aconbere> isn't there already a proof that there's a perfect mapping from sexpr -> xml?
13:57:32 <mattam> text with markup is a list of nodes, some of them being text nodes.
13:57:48 <lament> Cale: do you disagree?
13:58:03 <Cale> lament: I don't understand exactly what you're referring to.
13:58:28 <lament> Cale: <foo>hello<bar/>world</foo>
13:58:30 <Cale> jeffwheeler: Basically, if you've ever seen lisp or scheme code, it would look like that.
13:58:35 <lament> the "hello<bar/>world" part is text with markup
13:58:48 <jeffwheeler> Cale: yeah, I played with elisp briefly, so I'm familiar with the syntax.
13:58:49 <lament> what's the equivalent of that in sexprs?
13:58:50 <Cale> (foo hello (bar) world)
13:58:51 <Cale> ?
13:59:00 <Cale> Or:
13:59:06 <Cale> (foo "hello" (bar) "world")
13:59:08 <Cale> If you prefer.
13:59:10 <lament> Cale: then what is <foo color=shiny>hello<bar/>world</foo>
13:59:29 <Cale> (foo (color shiny) "hello" (bar) "world")
13:59:56 <roconnor> I don't even have a Closed monoidal category.  Maybe my claims that my monad is strong are not even wrong.
13:59:57 <Cale> Or something like that.
14:00:06 <Cale> There are a number of choices you can make.
14:00:16 <vixey> (foo :color 'shiny "hello" :bar "world")
14:01:04 <lament> Cale: right, the point is that sexprs don't have that abstraction, and it's a useful one
14:01:11 <Cale> lament: Which abstraction?
14:01:25 <lament> Cale: the distinction between attributes and marked-up text
14:01:27 <Cale> lament: I don't think it's useful.
14:01:34 <lament> Cale: you're free to think it's not useful
14:01:41 <Cale> lament: You can make the distinction by naming.
14:01:56 <lament> yes, there's "a number of choices" you can make for achieving the same result
14:02:08 <lament> just like there's "a number of choices" you can make for achieving monad-like behaviour in Java
14:02:21 <Cale> Attributes could be considered subnodes whose names start with attr- for instance.
14:02:37 <lament> but the point of XML is precisely that it's standardized
14:02:41 <lament> or at least, tries to be
14:02:43 <Cale> (foo (attr-color shiny) hello (bar) world)
14:02:58 <lament> a good serialization language should minimize the number of free choices you make
14:02:59 <johnnowak> plt-scheme uses the format (<name> ((<attr1>)(<attr2>)...) ...)
14:03:13 <johnnowak> (a ((href "http://example.com")) "A link")
14:03:16 <lament> look at the situation with dicitonaries in Scheme
14:03:18 <Cale> lament: You're already making lots of choices.
14:03:37 <lament> Cale: yes
14:03:43 <Cale> lament: Attributes are not fundamentally different from subnodes, except they add complexity to the language.
14:04:08 <lament> Cale: true and true
14:04:30 <lament> Cale: the question is, is it useful to have the distinction? I believe that the anwser at least sometimes turns out to be true
14:04:37 <lament> (although often it hurts as well)
14:04:53 <Cale> If you're going to have something along the lines of a DTD anyway, I think that can handle it.
14:05:55 <lament> yes, but for many usages of XML, where you hand-wave the definition, it's nice
14:10:00 <Cale> lament: another option for how to handle it is just to translate each XML-node into something like (name (...) (...)) where the first list is attributes, and the second is subnodes and text.
14:10:14 <lament> Cale: duh, of course there's a lot of ways of implementing it.
14:10:33 <Cale> So long as you pick one, it's not a problem :)
14:10:49 <lament> Cale: that attitude is responsible for scheme sucking badly
14:10:55 <vixey> if you wanted to encode data Tree = Leaf | Branch Tree Tree
14:10:55 <Cale> oh?
14:11:04 <vixey> There is one obviousl way to do it
14:11:20 <lament> Cale: scheme has huge problems because nothing is standardized and there's many ways to do stuff
14:11:30 <vixey> if you actually have the data you can do it straightforwardly, if you want to encode some vague textual markup thing yeah it's tough
14:11:33 <lament> Cale: compare with haskell, which is blessed with a pretty centralized environment
14:11:38 <Cale> lament: There are so many dimensions to how to encode things already that this is probably not the biggest design decision to have to make.
14:11:39 <centrinia> There is a Scheme standard.
14:11:55 <vixey> centrinia, SRFIs don't exist though :)
14:11:57 <lament> Cale: there're many ways of implementing, say, the Prelude, but is having lots of choice there a good thing?
14:12:08 <Cale> lament: We have standards like MathML for how to actually encode something in particular anyway, and this choice can be made ther.e
14:12:10 <Cale> there*
14:12:17 <Cale> lament: Yes, it would be.
14:12:28 <Cale> lament: In fact, I would *love* to re-do the Prelude.
14:12:33 <lament> i know *you* would :)
14:12:47 <lament> but standards are good
14:12:51 <Cale> We need better support for multiple base packages.
14:13:20 <centrinia> There are many possible Preludes that conform to the standard.
14:13:37 <lament> scheme is in a situation where stuff normally does not work on multiple implementations, despite the presence of a standard and SRFIs
14:13:39 <Cale> Standards are good, but they should pin down as little as reasonably possible.
14:14:05 <lament> and the reason that happens with scheme is because they have the same attitude as Cale in designing the standard (at least until R6RS)
14:14:20 <centrinia> I agree. Simpler standards make the job of finding inconsistancies simpler. :)
14:15:00 <Cale> Obviously, if the standard specifies too little, so that you can't do anything only making the assumptions which it makes, that's a problem.
14:15:30 <centrinia> Incomplete standards are a problem.
14:15:43 <centrinia> Inconsistant standards are also a problem.
14:16:27 <gwern> (man, yi programming is rough! xmonad is a lot easier to work with)
14:16:53 <lament> Cale: from a different perspective, on XML: think of attributes as syntax sugar. It desugars to any one of the sexpr alternatives you suggested, but it's nice to have. It has potential to make stuff more readable
14:16:59 <Cale> For something which is positioned similarly to XML though, I think one would want to give as much freedom as possible with regard to how data is structured. That can be pinned down further in standards which build on top of it.
14:17:21 <Cale> lament: If you want good syntax sugar, there are better options than XML.
14:17:26 <lament> Cale: i agree
14:17:34 <Cale> lament: XML is annoying as hell to write by hand.
14:17:38 <lament> I agree
14:17:47 <lament> i said "more readable", not "more writable" :)
14:17:58 <Cale> Oh, it's also annoying to read, for the same reason.
14:18:15 <Valodim> YAML :)
14:18:19 <lament> Cale: i think the real reason for the attributes/body distinction is because it's intuitive somehow. It corresponds to the way we normally think about objects with structure.
14:18:29 <Cale> lament: It doesn't agree with my brain.
14:18:35 <lament> like
14:18:36 <geezusfreeek> Valodim, yaml is great until you have to parse it ;)
14:18:39 <lament> there's a green box with apples in it
14:19:07 <lament> a woman named Alice sitting in a red Mercedes
14:19:09 <Valodim> geezusfreeek: right, but that only affects the one guy who writes the library
14:19:09 <lament> whatever
14:19:24 <centrinia> The box has a property denoting that it is green and it also has a property denoting that it has apples in it. :)
14:19:27 <geezusfreeek> do we have a haskell yaml library?
14:19:32 <lament> centrinia: yes. That's definitely not how I think of it.
14:19:36 <Valodim> I don't kno
14:19:39 <lament> centrinia: I doubt that that's how you think of it, either.
14:19:59 <geezusfreeek> huh, it appears we have two
14:20:14 <geezusfreeek> on hackage, that is
14:20:17 <Cale> (box (colour green) (contains apples))  (woman (name Alice) (sitting-in (Mercedes (colour red))))
14:20:52 <lament> Cale: yes.
14:21:23 <geezusfreeek> could even put implicit rules in there to make it simpler
14:21:24 <lament> Cale: that doesn't express the additional constraint that attributes can't possess structure themselves
14:21:24 <Cale> Trees :)
14:21:24 <vixey> (box :colour green :contains apples)
14:21:32 <Cale> lament: Why shouldn't they be able to?
14:21:59 <lament> Cale: because that's how the world described by XML works.
14:22:10 <lament> Cale: now, is your issue with XML or with this object model?
14:22:10 <geezusfreeek> (box green apples) (woman (name Alice) (sitting-in (Mercedes red))
14:22:14 <Cale> lament: But we have compound adjectives in natural language all the time.
14:22:22 <Valodim> ..why does that library parse in the IO monad?
14:22:23 <vixey> I thought we weren't using XML as the definition of what's great and that we want to copy
14:22:26 <Cale> lament: And they're often useful.
14:22:27 <centrinia> (element (attributes '(attr1 attr2) ) '(node1 node2 node3) )
14:22:29 <Valodim> isn't parsing of Yaml a pure thing?
14:22:41 <Cale> There's no real good reason to make such a restrictive design decision at that level.
14:22:58 <lament> Cale: possibly not. You could argue XML is not general enough. I agree with that.
14:23:20 <geezusfreeek> Valodim, perhaps it is a binding to a C library?
14:23:28 <geezusfreeek> that has state
14:23:28 <Valodim> ad
14:23:29 <Valodim> cy co
14:23:44 <jsn>  Valodim: uhm ?
14:23:51 <Valodim> whoops
14:24:05 <Valodim> accidentally switched keyboard layouts
14:24:33 <Valodim> that is what "ah. yes." looks like qwerty-typed on a dvorak keyboard :P
14:24:35 <Cale> lament: Basically what I'm trying to argue is that people shouldn't be content with XML as a general solution to serialising data, and that there are much simpler things which do the job at least as well, and often better.
14:24:43 <lament> Cale: in fact, some hilarity tends to ensue any time XML is used to describe a world that clearly uses a differnt model
14:24:55 <lament> so XML is not general enough in practice either
14:25:25 * centrinia high fives the Dvoraker. :D
14:25:46 <lament> Cale: right, but then the issue is not whether XML is bad or good, but whether having a crappy but universally agreed-upon standard is better than not having one at all (because we can't make everyone switch to sexprs)
14:26:06 <lament> Cale: English isn't optimal either, and neither is the metric system, and neither is our calendar, etc
14:26:15 <vixey> don't make anyone switch just do the right thing
14:26:21 <jsn> XML does a lot more than sexprs
14:26:21 <Cale> lament: I think there is not too much benefit to using XML for a new standard.
14:26:55 <Cale> jsn: I'm willing to argue that the extra stuff is largely just making unnecessary design decisions at the wrong level of standardisation.
14:27:00 <lament> Cale: i think there's quite a lot
14:27:08 <jsn> Cale: well, how should validation happen?
14:27:13 <lament> Cale: it makes things -nicer-
14:27:18 <centrinia> What does XML do that S-Expressions can not do?
14:27:31 <Cale> lament: Nicer than using s-expressions?
14:27:34 <jsn> centrinia: XML doesn't do anything they can't do
14:27:35 <lament> centrinia: it can be read and understood by any developer!
14:27:41 <Cale> There are lots of tools for manipulating S-expressions.
14:27:42 <centrinia> Oh.
14:27:53 <Valodim> centrinia: I'm still in the process of switching, started last week. typed two sentences and I was convinced it's worth learning, been learning since :)
14:27:59 <jsn> centrinia: it just has a rich and standardized approach to schematization
14:27:59 <Cale> You can validate the structure of an S-expression relatively easily.
14:28:21 <Cale> And I'm certain there are tools for doing so.
14:28:29 <lament> Cale: yes, nicer than using s-expressions because it's more readable
14:28:32 <jsn> there isn't an S-Expr schema language, though
14:28:40 <centrinia> Valodim, you should be aware that your QWERTY typing speed will most likely go down as you learn Dvorak.
14:28:46 <lament> Cale: xml is already pretty unreadable, and sexprs are even worse
14:28:58 <jsn> there isn't a big library of S-Expr types, as far as i'm aware
14:29:03 <geezusfreeek> i disagree with all this "readable" stuff. i think reading XML is a horrible experience
14:29:09 <lament> geezusfreeek: of course it's horrible
14:29:13 <Valodim> centrinia: as in it stays that way?
14:29:21 <geezusfreeek> i thnk sexps are much easier to read
14:29:21 <lament> geezusfreeek: but reading data serialized as sexprs is even worse
14:29:22 <jsn> lament: i think that's six of one and a half dozen of the other
14:29:28 <Cale> lament: S-exprs are usually more readable for me.
14:29:36 <centrinia> Valodim, it depends on how much you regularly use the QWERTY layout. :p
14:29:41 <Cale> lament: Closing tags are awful for readability.
14:29:56 <Botje> let's go back to SGML!
14:29:56 <Valodim> centrinia: quite a lot, but I plan to fully switch
14:29:57 <Botje> </> ftw
14:30:11 <centrinia> If you continue to use the QWERTY layout and also use the Dvorak layout a lot, it shouldn't effect the QWERTY rate.
14:30:24 <geezusfreeek> Botje,  personally don't think that would be so horrible considering that we are still so close to it anyway
14:30:30 <lament> You will forget QWERTY by tomorrow.
14:30:39 <Valodim> oh I just now read that sentence correctly, the qwerty speed will go down.
14:30:56 <Botje> of course that won't go well with the XML parser nazis :)
14:31:02 <Valodim> first I read it as "your typing speed will go down compared to qwerty"
14:31:04 <Valodim> yeah
14:31:11 <jsn> Cale: so you are considering using S-Exprs as a data interchange format?
14:31:21 <Valodim> well who cares, if it stays at an acceptable level :P
14:31:37 <Cale> jsn: Well, for purposes of argument, yes.
14:31:38 <lament> Cale: closing tags aid writability. Attributes aid readability.
14:31:39 <centrinia> Good luck. :p
14:31:44 <jsn> why even use those? i mean, that's so close to just air
14:31:48 <jsn> why not use indentation?
14:32:02 <Cale> jsn: Good point, that works too.
14:32:07 <Valodim> thanks
14:32:10 <Valodim> ah well. /me sleep, later guys :)
14:32:16 <jsn> so then we can model trees
14:32:18 <centrinia> Bye.
14:32:22 <lament> Why not just use a binary stream? Why should we standardize on how the users wish to present their trees?
14:32:25 <vixey> jsn, awkward to edi
14:32:27 <vixey> jsn, awkward to edit
14:32:33 <Cale> jsn: My point is that XML is just a hideously complicated way to represent trees.
14:32:33 <lament> Binary streams are the perfect data interchange format.
14:32:45 <jsn> Cale: XML does more than trees, though
14:32:53 <gwern> argh. this is what progamming yi is like - spending an hour trying to figure out how to get the current buffer's contents as a string
14:33:04 <jsn> Cale: XML defines a module system, a typesystem, a transformation system
14:33:10 <centrinia> Lists of numbers in the unary number system is simpler.
14:33:17 <Cale> jsn: Those are separate standards built on top.
14:33:27 <Cale> jsn: I'm not talking about XSLT.
14:33:34 <smtms> lament, XML is a stream of binary digits in groups of eight
14:33:43 <jsn> Cale: well, what about the module system and the type system?
14:33:48 <lament> smtms: :)
14:34:02 <Cale> jsn: Presumably, you could do similar things with any other standard for writing down trees.
14:34:06 <jsn> Cale: with that linking standard (XLink?) you can do DAGs, too
14:34:27 <centrinia> Is there an S-Expression Stylesheet Transform standard?
14:34:30 <jsn> Cale: after you write the standard and all the sub-standards, yes
14:34:42 <vixey> centrinia, SYNTAX-RULES
14:34:44 <Cale> XSLT is just a functional programming language which is hard to use.
14:34:46 <smtms> how do you represent infinite trees?
14:34:58 <vixey> (is also a hard to use fp language)
14:35:02 <jsn> of course i would like to see a minimal, clean IML (indentation markup langauge)
14:35:16 <dons> smtms: don't have leaf nodes?
14:35:19 <vixey> well very easy and declarative for certain things.. hard to program in
14:35:23 <Valodim> (xslt is a logical language iinm)
14:35:35 <smtms> dons, some of the leafs are at finite depth
14:35:37 <jsn> Cale: it is a functional programming language with a restricted domain that is widely implemented
14:35:49 <dons> smtms: well, haskell trees are all potentially infinite
14:35:53 <dons> i'm not sure what the issue is?
14:35:56 <dons> just like our lists
14:35:59 <dons> > [1..]
14:36:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:36:05 <lament> jsn: it's a functional programming language my coworkers know how to use
14:36:05 <Grisha> I'd like to write a simple HTTP/JSON web-service (in Haskell) which then will by accessed by JavaScript from a browser. Which lib for Haskell you can recommend?
14:36:06 <jsn> actually, i think it is the first functional programming language i ever learned
14:36:30 <dons> Grisha: our json lib
14:36:34 <dons> Grisha: and fastcgi, i guess
14:36:39 <dons> Grisha: see hackage.haskell.org
14:37:00 <jsn> Cale: i don't disagree that there are problems with XML for serialization -- but SExprs are on the opposite end of over-engineeredness
14:37:12 <smtms> dons, the issue is, how do you represent them for interchange :-)
14:37:16 <Cale> jsn: It's not hard to implement similar functionality for manipulating trees as a library in whatever language you'd like.
14:37:17 <jsn> in the middle, there's thrift and protobuffers
14:37:30 <smtms> dons, I'm not asking seriously
14:37:36 <Cale> jsn: Or typechecking trees, for that matter.
14:37:38 <Grisha> dons: is there a light-weight web server (in Haskell), so I can write Main function and start it from code (kind of embeddable web server) ?
14:37:38 <dons> smtms: oh.. that's harder. since most languages won't have support for our thunkms
14:37:40 <jsn> Cale: yes, it is hard to implement that stuff
14:37:44 <dons> Grisha: oh, happs.
14:37:44 <Cale> oh?
14:37:48 <jsn> Cale: implementing type checkers is hard, too
14:37:52 <dons> Grisha: see happs.org (available on hackage.haskell.org)
14:37:55 <Cale> It's really not that hard.
14:38:12 <jsn> well, i don't know how to do it off the top of my head
14:38:19 <jsn> and i've been programming for years
14:38:27 * geezusfreeek wants a markup language that is actually a strongly normalizing programming language
14:38:27 <jsn> but if i wanted to validate XML, well...
14:38:48 <geezusfreeek> but hey, i would want to write the deserializer for that ;)
14:38:54 <geezusfreeek> *wouldn't
14:39:30 <tjm1983> Is this a good time and place to talk about http://research.microsoft.com/%7Esimonpj/papers/fd%2Dchr/ ?
14:39:31 <lambdabot> Title: Simon Peyton Jones: papers
14:39:34 <vixey> jsn, type checkers or what?
14:39:37 <vixey> jsn, type checkers for what?
14:39:49 <Cale> tjm1983: Sure, what about it?
14:39:53 <jsn> vixey: well, not just a type checker
14:40:19 <tjm1983> Cale: I'm particularly interested in the Paterson conditions.
14:40:25 <jsn> you'd have to devise a grammar language, and then an interpreter that generated a type checker for your new tree format, whatever it is
14:40:48 <lament> let's just all agree that xml rocks :)
14:41:00 <jsn> lament: well, that is unrealistic, though
14:41:11 <jsn> XML has some strong points
14:41:22 <Cale> tjm1983: I'm not an expert on this stuff, but I can try to discuss it :)
14:41:33 <Cale> tjm1983: and it's possible that other people here know more than me :)
14:41:34 <jsn> lament: but it's not the only thing you should look at
14:41:42 <lament> jsn: yes, i can definitely see cases where i would want to use something other than XML
14:41:59 <jsn> lament: like if you are making a config file format, i think XML is rubbish
14:42:17 <Cale> tjm1983: If you're really stuck, the Haskell mailing list should be able to answer your questions (it's possible Ross Paterson will even answer).
14:42:20 <lament> and what some people (e.g. Microsoft) do with XML is beyond reason
14:42:25 <jsn> hehe
14:42:31 <lament> e.g. <DictionaryOfIntString>
14:42:39 <lament> or <Canvas.Top>
14:42:55 * lament bites their heads off
14:42:59 <jsn> i would really like to see that colon field, indented format that cabal and other things use turned into a standard
14:43:10 <geezusfreeek> </Canvas.Top></DictionaryOfIntString> please close your tags!
14:43:10 <tjm1983> Cale: it seems to me that the Paterson conditions are roughly equivalent to requiring that the rank function to have a higher value for the head of an instance than for any of its class constranits, given any substitution for the free variables.
14:43:23 <mauke> #include <stdio.h> </stdio.h>
14:43:40 <geezusfreeek> mauke, ... that's actually kind of cool
14:43:48 <geezusfreeek> put code in the middle
14:43:49 <jsn> mauke: what if you could have scoped includes with that syntax?
14:43:54 <mauke> geezusfreeek: and gcc accepts it!
14:43:59 <geezusfreeek> :o
14:44:03 <jsn> hahaha
14:44:35 <RLa> uh, you still talk about xml
14:45:00 <jsn> i used to want one of those "XML will save the world!" hats
14:45:08 <jsn> now i'm not so keen on it
14:45:08 <noZone> #define private public
14:45:18 <Cale> tjm1983: I suppose we can try to prove it :)
14:45:20 <mauke> noZone: also needs #define class struct
14:45:24 <jsn> #define int char
14:45:31 <RLa> hehe
14:45:32 <lament> XML will probably not save the world
14:45:34 <shukhov> #define if while
14:45:35 <mauke> #define sizeof(_) rand()
14:45:38 <lament> but it might speed up its demise :)
14:45:40 <geezusfreeek> shukhov, you beat me to it
14:45:42 <tjm1983> Cale (or anyone else): would it be reasonable to restate the Paterson condition as I just did, and then let programmers choose different coefficients in the definition of the rank function for classes that they define?
14:46:08 <jsn> mauke: that's the best one ever
14:46:16 <Cale> tjm1983: hmm...
14:46:19 <shukhov> geezusfreeek: reddit had a thread about this things a while ago
14:46:26 <geezusfreeek> shukhov, yes, i know ;)
14:46:28 <shukhov> /this/these
14:47:20 <Cale> tjm1983: The idea is to try to ensure termination of course. Will any choice of coefficients really ensure that?
14:48:30 <Cale> tjm1983: I think the usual thing so far has been just to turn the restriction off altogether when it's getting in the way.
14:49:02 <Cale> tjm1983: So it's possible you could do something half-way, and allow the programmer to decide what constraints should ensure termination.
14:49:40 <tjm1983> Cale: As long as we change the Paterson condition to say that we require the rank function to decrease, I think it will guarantee termination (but perhaps only if coefficients are required to be integers, rather than reals).
14:50:08 <tjm1983> Cale: and of course, I'd want all the coefficients to be non-negative, with at least one positive one.
14:50:17 <Cale> nonzero as well?
14:50:27 <Cale> hmm
14:50:48 <tjm1983> Cale: I don't think we need them all to be non-zero.
14:50:49 <calvins> hi all, does anybody know the current state of Unicode/ByteString support? Is there a stable library out there yet?
14:51:21 <Cale> calvins: There are libraries for encoding/decoding UTF-8.
14:51:23 <geezusfreeek> okay irc is distracting me from work again
14:51:36 <adekoba> your work is distracting you from irc
14:52:07 <Cale> tjm1983: hmm, I think I'd need to really sit down and try it to check that, but it doesn't sound unreasonable.
14:52:49 <calvins> Cale: do you mean libraries for manually doing the encoding/decoding? Weren't there plans in progress to make a Unicode-aware ByteString implementation so that manual encoding/decoding wouldn't be necessary?
14:53:00 <tjm1983> Cale: I'll try to quickly piece together an example of why I've been thinking about this.
14:53:27 <Cale> calvins: Oh, yes, there was a plan to change the default I/O stuff so that it encoded things properly.
14:53:34 <travisbrady> would anyone mind giving me pointers on how to make this http://hpaste.org/12408 less ugly?
14:53:39 <calvins> nothing came of it that you're aware?
14:53:40 <Cale> calvins: Probably the easiest way to check is just to try it :)
14:53:46 <calvins> try what?
14:54:11 <calvins> ByteString itself even support Char fully.
14:54:19 <calvins> "doesn't even support..."
14:54:32 <calvins> Or does it now?
14:54:39 <Cale> calvins: I don't know about ByteString, but the String IO stuff appears to support unicode now.
14:55:10 <calvins> yeah, I thought String did, but [Char] is too slow...
14:55:31 <Botje> > Data.ByteString.unpack $ Data.ByteString.pack "♥"
14:55:32 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
14:55:42 <Cale> calvins: Well, Char has always been 32 bits, but up until recently, the I/O stuff didn't actually treat it properly.
14:56:13 <Cale> er
14:56:24 <Cale> actually, it appears that it still doesn't?
14:56:27 <sbahra> Botje, Data.ByteString.Char8
14:56:28 <Cale> Prelude> print . map fromEnum =<< getLine
14:56:28 <Cale> ∫
14:56:28 <Cale> [226,136,171]
14:56:32 <sbahra> Botje, is what you want to use.
14:56:43 <Botje> travisbrady: you could sexy it up a bit by using (,)'s default sorting order
14:57:13 <sbahra> > Data.ByteString.Char8.unpack $ Data.ByteString.Char8.pack "♥"
14:57:14 <lambdabot>   "e"
14:57:22 <Botje> return $ snd $ (xdist, a) `min` (ydist, b)
14:57:31 <mauke> preflex: zenc ♥
14:57:31 <preflex>  z2665U
14:57:40 <dons> shapr: RWH on n810 http://www.student.cs.uwaterloo.ca/~bsshephe/rwh_n810.jpg
14:57:43 <Botje> hmmwait
14:57:48 <travisbrady> Botje: ahh, hmm, sexier, but somewhat less clear, to me anyway
14:57:50 <Botje> that needs a tours!! in there somewhere
14:58:15 <Cale> travisbrady: You probably shouldn't compute the length of a list more times than absolutely necessary.
14:58:20 <Botje> travisbrady: you could at least use a randomOf that takes a random element from a list, no?
14:58:31 <Botje> then you can drop the tours!! everywhere
14:58:52 <Cale> travisbrady: xs !! n is an O(n) operation.
14:59:07 <travisbrady> Botje: yes, i wasn't aware of that function
14:59:19 <Cale> travisbrady: He's saying you should write it :)
14:59:23 <vixey> can you get a random element of a list in O(n)?
14:59:35 <Cale> vixey: Yes, of course :)
14:59:36 <travisbrady> Cale: haha, just realized after googling yield ()
14:59:40 <vixey> (using only one traversal of the list)
14:59:50 <Sartak> yep
15:00:04 <Botje> travisbrady: i just annotated your paste
15:00:10 <Cale> vixey: In O(n) you can even turn it into an array.
15:00:14 <Botje> vixey: that's a standard MS interview question, right?
15:00:28 <Cale> and then get any constant number of random elements.
15:01:22 <tjm1983> Cale: http://hpaste.org/12409
15:01:33 * lament pokes Sartak 
15:01:53 <Sartak> vixey: iterate over the list, the current element's index i has a 1/i chance of replacing the previous "current" element
15:03:08 <Sartak> I don't know how to express it in Haskell but in Perl it's: for (my $i = 0; $i < @list; ++$i) { $selected = $list[$i] if rand($i) < 1 }
15:03:09 <vixey> Sartak, yeah :))
15:03:13 <calvins> Looks like Unicode I/O support is scheduled for GHC 6.12: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg15734.html
15:03:15 <lambdabot> Title: Future plans: unicode and line editing, http://tinyurl.com/66l8wz
15:03:16 <vixey> Sartak, That's great
15:03:16 <tjm1983> Cale: I just corrected the first like on that hpaste.
15:03:20 <Cale> Sartak: helper function. :)
15:03:21 <vixey> Sartak, foldM probably
15:03:23 <vixey> :t foldM
15:03:24 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:03:35 <Cale> (or some fold)
15:03:38 <vixey> m being State and Random
15:03:51 <vixey> very good method though
15:03:54 <Sartak> sure. I'm very much a haskell novice so I wouldn't know how to write it
15:04:06 <Sartak> got it from the perl cookbook :)
15:05:15 <tjm1983> Cale: The last instance declaration fails the Paterson conditions, because Set s (Association a b) and Eq (MapAdapter s a b) each have three type variables and one type constructor.
15:05:24 <Cale> tjm1983: I wonder how this looks with associated types.
15:05:49 <Sartak> the great thing about it is you don't need to know the length of the list in advance, so it's fine to use to select a random line from an arbitrarily large file
15:06:29 <tjm1983> Cale: but I feel like the (Association a b) in the constraint shouldn't count against me, because it's uniquely determined by the variable s.
15:07:27 <travisbrady> Botje: thank, that's much better
15:07:29 <Cale> tjm1983: btw, class constraints on newtype and data declarations probably don't mean what you want them to.
15:07:49 <Cale> (or are you aware of that)
15:08:05 <tjm1983> Cale: what do they mean, and what do I want them to mean?
15:08:38 <Cale> They only restrict the type of the data constructor. They don't allow you to assume that values of that type satisfy the class constraints.
15:08:55 <Botje> travisbrady: actually
15:09:00 <Botje> there's one other thing you can do
15:09:02 <Cale> That is, you still need appropriate constraints on functions which deconstruct values of that type.
15:09:28 <Cale> You probably want them to mean that an appropriate typeclass dictionary is stored along with the data.
15:09:45 <tjm1983> Cale: can you give me an example?
15:09:49 <Cale> Sure.
15:10:29 <Cale> data Ord a => Set a = Empty | Cons a (Set a)
15:10:47 <Cale> This makes  Cons :: (Ord a) => a -> Set a -> Set a
15:11:11 <Cale> However, functions which operate on (Set a) values are still going to need (Ord a) constraints.
15:11:17 <travisbrady> Botje: i just pasted all of my hideous imperativist Haskell here: http://hpaste.org/12408#a2
15:11:17 <Cale> Like...
15:11:21 <hackage> Uploaded to hackage: TypeCompose 0.6.2
15:11:51 <Cale> You can't write:  sort :: Set a -> Set a
15:12:08 <Botje> travisbrady: i just annotated with a slight improvement
15:12:29 <Cale> But must write  sort :: (Ord a) => Set a -> Set a
15:12:50 <tjm1983> Cale: ok, I think I discovered that already, by trial and error, but it didn't worry me too much at the time.
15:13:01 <tjm1983> Cale: it's nice to have it explained, though.
15:13:25 <Botje> travisbrady: selfZip lst = zip (init lst) (tail list)
15:13:28 <Cale> tjm1983: It basically means that class context is pretty much useless. In the GHC source code, it's referred to as the stupid context.
15:13:37 <Botje> travisbrady: but that's equivalent to zip lst (tail lst)
15:14:17 <Cale> tjm1983: In more recent GHC's (6.8.x and 6.10), if you use GADT syntax, you can get around that problem though, it will actually store a typeclass dictionary along with the data.
15:14:30 <tjm1983> Cale: yeah, I seem to remember wondering why I was putting that context in my newtype declaration, and what might happen if I took it out.
15:14:47 <tjm1983> Cale: GADT?
15:14:53 <Cale> data Set a where
15:15:03 <idnar> Cale: hmm, does that mean you could define a Monad instance for Set?
15:15:08 <Cale>   Empty :: Set a
15:15:10 <idnar> if it were defined using GADT syntax, I mean
15:15:14 <Cale>   Cons :: Ord a => a -> Set a -> Set a
15:15:29 <Cale> idnar: It gets you closer, but return is still an issue.
15:15:33 <idnar> er, I think I mean a functor instance
15:15:42 <Cale> Functor instance, yes.
15:15:51 <idnar> but now I'm not sure what I was originally thinking
15:15:58 <Botje> travisbrady: you can eliminate getDM by using computeDistanceMap `liftM` getData
15:15:59 <idnar> what's the issue with return?
15:16:06 <idnar> oh, no Ord context
15:16:08 <Botje> but it's not really an improvement
15:16:10 <Cale> idnar: return :: (Monad m) => a -> m a
15:16:22 <Cale> So yeah, no way to know that 'a' is an Ord instance there.
15:16:32 <Cale> So you can't use my 'Cons' for instance.
15:16:38 <idnar> right
15:16:40 <travisbrady> Botje: ahh, thank you, i was just going to do 'undo' on that
15:17:04 <Botje> that was all the low hanging fruit
15:17:19 <Botje> i'm afraid the others can't be made a lot sexier
15:17:48 <travisbrady> Botje: thanks, that's encouraging actually
15:18:10 <Botje> well, you could kick the let x = ...; return x habit
15:18:14 <travisbrady> i'm more concerned with writing code that's readable and idiomatic than sexy anyway (ok, sexy is good too)
15:18:27 <hydo> At the risk of bring up what's probably a common question, what is "Just" ?  specifically, I'm going over the types/functions chapter of the real world book.
15:18:41 <Botje> hydo: it's a data constructor for the Maybe type
15:18:46 <travisbrady> Botje: can i do return case x of True -> whatever ?
15:18:55 <Cale> hydo: It's a data constructor. It turns a value of type t into a value of type Maybe t
15:18:59 <Botje> travisbrady: you can, but in the case of tournament i'd move the return inside the cases
15:19:04 <Cale> :t "hello"
15:19:05 <lambdabot> [Char]
15:19:05 <Botje> case x of True -> return a
15:19:09 <Cale> :t Just "hello"
15:19:10 <lambdabot> Maybe [Char]
15:19:56 <Cale> hydo: In general, a value of type Maybe t is either the value Nothing, or it is Just x, where x is of type t.
15:19:58 <tjm1983> Cale: you mentioned associated types earlier. Is that the same as or related to GADTs?
15:19:58 <hydo> Ok, it's starting to make sense now.  Thanks a lot guys.
15:20:20 <Cale> tjm1983: It's another way of handling the problem that functional dependencies solve.
15:20:56 <idnar> associated types make my brain hurt a lot less than fundeps
15:21:06 <idnar> although I think I get fundeps now, since the last time someone explained them to me here
15:21:16 <vixey> what do you do with associated types?
15:21:38 <tjm1983> Cale: I remember thinking about them briefly when I read about them at the end of that paper, but I decided they wouldn't completely solve my problem.
15:21:52 <tjm1983> Cale: I can't remember why I decided that, any more.
15:22:16 <dolio> You could re-implement mtl to be nicer.
15:22:21 <tjm1983> Cale: and I didn't think about them for very long, so it's unlikely to have been very sound reasoning.
15:22:25 <dolio> That'd be a nice use of associated types.
15:23:00 <Cale> tjm1983: Let me see.
15:31:32 <Cale> tjm1983: hmm... yeah, it does appear to require UndecidableInstances either way.
15:33:24 <tjm1983> Cale: I still have GHC 6.8.2, whose user guide doesn't have much about associated types, so I'm peeking at the online version of the latest user guide to learn about them.
15:33:38 <Cale> tjm1983: They don't work in 6.8.2 anyway.
15:34:40 <tjm1983> Cale: but if you say it still requires UndecidableInstances, then I might not worry about it too much.
15:34:43 <Cale> http://hpaste.org/12409#a2
15:34:54 <tjm1983> Cale: it looks interesting in its own right, though.
15:35:03 <liff> anyone know what to do about "unknown symbol `hs_curses_color_pair'" with hscurses? installed with cabal-install on ubuntu 8.10, ghc 6.8.2
15:35:33 <Cale> tjm1983: What are you actually trying to do? There might be an easier route.
15:35:53 <liff> i googled a bit and seems like i "should" be having that problem if i were using ghc 6.10 :)
15:36:16 <Cale> liff: Well, the first thing you should check is that you're either compiling with --make or specifying the package is to be used.
15:36:43 <tjm1983> Cale: write my own simple data structures, partly as a way of learning Haskell better.
15:36:44 <Cale> liff: After that, make sure that the curses library which it's binding to is properly installed. I'm not sure what else would cause a linker error.
15:37:03 <blueonyx> QuickCheck-2.1.0.1 doesnt compile with ghc 6.10.1?
15:37:35 <Cale> tjm1983: Okay, this is probably a somewhat overcomplicated way to go about that... though set and map classes are not a bad idea.
15:37:42 <Grisha> about Maybe: is it a FP analogue of Null Object patteron in OOP?
15:38:12 <liff> Cale: wasn't compiling, just using runghc, actually. but i'll try that now
15:38:13 <Cale> tjm1983: It's easier for a Set to be parametrised by its element type.
15:38:24 <idnar> Grisha: I think so
15:38:29 <Cale> Grisha: yes.
15:38:34 <idnar> Grisha: but it's explicit, rather than implicit
15:38:37 <tjm1983> Cale: I thought about making my classes less general, making "Set s" a class such that "s a" is a set of a-s; is that what you mean?
15:38:46 <Cale> tjm1983: yeah
15:39:04 <idnar> Grisha: actually, it's not really the Null Object pattern at all, but it's used in a similar way
15:39:52 <alexei_> with http://hpaste.org/12410 I get: strategies [(),(),()] == http://en.wikipedia.org/wiki/Special:Search?go=Go&search=[(),(),()]],[[(),()],[()]],[[(),()],[()]],[[()],[(),()]],[[()],[()],[()], yet with repeating strategies. I have a feeling of overcomplicating some simple math.
15:40:04 <tjm1983> Cale: I can't remember exactly why I decided not to do that---possibly just because functional dependencies seemed like an interesting say of making it more general.
15:40:12 <Cale> tjm1983: It's easy to get tied up in creating classes which are very general and then have not so many instances.
15:40:25 <idnar> Grisha: instead of having an object that does nothing, you lift your functions into Maybe, so that they do nothing when they encounter Nothing
15:40:27 <liff> ah, found it: http://hackage.haskell.org/trac/hackage/ticket/245
15:40:33 <lambdabot> Title: #245 (Cabal should support hsc2hs's stub .c feature) - Hackage - Trac
15:40:34 <liff> ..i think..
15:40:50 <Cale> Well, one reason would be that sets of fixed element types can have interesting implementations which are unavailable for more general sets.
15:42:16 <Cale> tjm1983: Another possibility is just to bite the bullet and turn on UndecidableInstances.
15:42:22 <tjm1983> Cale: yeah, I've basically got two instances so far: a list, and an AVL tree, and I personally have no particular reason to make more.
15:43:23 <tjm1983> Cale: yeah, I've turned on UndecidableInstances in the mean time, but it seemed like overkill, which is why I asked about generalizing the Paterson conditions.
15:55:04 <Cale> tjm1983: I'm starting to feel that typechecker termination is a bit overrated, especially as even HM is exponential time and space in the worst case.
15:56:17 <thedward> should I expect modificationTime & statusChangeTime (from System.Posix.Files / GHC 6.8.2 on 32bit Linux) to work as advertised?
15:56:18 <Cale> tjm1983: We should concentrate more on getting a really rich typesystem where it's easy to express complicated things, while maintaining a nice fragment where type inference works.
15:57:46 <Cale> thedward: Well, they're probably not much more than thin wrappers around the appropriate Posix calls.
15:58:55 <thedward> Cale: Well, modificationTime seems to give me ctime, and statusChangeTime seems to always give me 0
15:59:00 <tjm1983> Cale: perhaps you're right.
15:59:23 <tjm1983> Cale: thanks for your help, anyway; I'm about to go and get some lunch.
15:59:58 <Cale> modificationTime (FileStatus stat) =
15:59:58 <Cale>   unsafePerformIO $ withForeignPtr stat $ ((\hsc_ptr -> peekByteOff hsc_ptr 88))
16:00:00 <Cale> ouch
16:00:14 <Cale> tjm1983: No problem.
16:01:04 <travisbrady> is there an easy way to repeatedly apply an action to the same arguments and concat the results together as a list?
16:01:10 <thedward> Cale: huh, that looks like it could be fragile
16:01:17 <Cale> :t iterate
16:01:18 <lambdabot> forall a. (a -> a) -> a -> [a]
16:01:35 <Cale> thedward: otoh, it appears this source is automatically generated
16:01:55 <Cale> thedward: I'd have to look at the actual source in the .hsc file to see...
16:04:38 <thedward> Cale: no worries. I can dig into it; I was just kind of hoping someone else already had. :) Thanks.
16:04:50 <medfly> Cale: hello :)
16:05:31 <thedward> I'll probably start by building the unix package myself
16:19:59 <acidjnk> How can I define my own infix operator like (+)?
16:20:39 <mauke> as usual
16:20:52 <lament> @src (+)
16:20:52 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:21:20 <mauke> > let a ??? b = a + b; (!!!) a b = a * b in 1 ??? (2 !!! 3)
16:21:21 <lambdabot>   7
16:21:23 <lament> lambdabot: i'll use three thingers next time
16:21:28 <lament> er, fingers
16:21:42 <lament> (but isn't "thinger" a great reverse etymology?)
16:21:51 <aconbere> Cale: w00t! okay... I think I might have gotten a step closer to understanding how to write programs once introducing IO
16:22:30 <aconbere> thanks for your help yesterday :)
16:25:18 <quuxman> why does (map . map) actually work? Seems like the type signature should be wrong
16:26:13 <mapreduce> acidjnk: You can define it the same way as an alphanumeric function, but with () around the name, e.g., let (+-) x y = (x + y, x - y), or infix, e.g., let x +- y = (x + y, x - y).  Hmm, I should test that example.
16:26:25 <acidjnk> thanks
16:26:29 <mapreduce> > let x +- y = (x + y, x - y) in 3 +- 2
16:26:30 <lambdabot>   (5,1)
16:27:25 <Cale> aconbere: great :)
16:27:49 <Cale> aconbere: there's a short summary tutorial here: http://www.haskell.org/haskellwiki/Introduction_to_IO
16:27:52 <lambdabot> Title: Introduction to IO - HaskellWiki
16:27:56 <alexei_> List comprehensions: split 0 = [[]]; split n = [ k:snk | k <- [n,n-1..1], snk <- split (n-k) ]  How do I avoid iterations with n-k > k?
16:29:32 <Cale> k <- [n,n-1 .. n-k]
16:29:39 <Cale> er
16:29:42 <Cale> duh :)
16:29:58 <aconbere> quuxman: all that's required of the function passed to map, is that it return an output for every value passed to it.
16:30:06 <medfly> dude
16:30:44 <aconbere> quuxman: so it just requires that the values passed to map.map are lists of lists
16:30:54 <Cale> oh, n-k <= k implies that n <= 2*k
16:30:56 <aconbere> quuxman: take a look at :t (map.map)
16:31:06 <quuxman> aconbere: ah yeah I get it
16:31:15 <Cale> So k >= n `div` 2
16:31:26 <aconbere> quuxman: (map.map) :: (a -> b) -> [[a]] -> [[b]] :-D
16:31:30 <Cale> So you want k <- [n,n-1..n`div`2]
16:31:32 <quuxman> :t (.)
16:31:33 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:31:52 <quuxman> the 'b' in that is actually '[x] -> [y]'
16:32:32 <aconbere> quuxman: that sounds right
16:32:40 * gwern reads a peculiar email on -cafe where John Meachem claims the LHC fork is news to him
16:32:48 <alexei_> Cale: no, I am confused. I want all partitions of an integer into a sum, without repetitions i.e.
16:33:02 <Cale> alexei_: ah, okay
16:33:28 <Cale> alexei_: First, write the function which gives you all partitions of an integer n into parts of size at most k.
16:33:53 <Cale> alexei_: and then the function you're after is just that one with k = n.
16:34:05 <aconbere> Cale: what I ended up realizing was that I could codify all my logic acting on primitve types, and provide a limited api which utlized do blocks on the code that read from the file, and feel okay about how my program was structured.
16:34:19 <aconbere> Cale: it just took some... sideways looking
16:35:02 <thedward> Cale: fwiw, my modificationTime problem appears to have been a user error; I think I had inappropriately mixed and matched different versions of libraries
16:35:27 <Cale> thedward: ah
16:35:34 <Cale> alexei_: Does that make sense?
16:36:12 <novas0x2a> hey gwern, i managed to find another case of the odd flipping behavior, and this one is more-easily-reproducible
16:36:19 <Cale> alexei_: It helps you because a partition of n into parts of size at most k is a number l from 1 up to k followed by a partition of (n-l) into parts of size at most l.
16:39:39 <Cale> aconbere: That sounds about right.
16:43:49 <aconbere> Cale: http://paste.pocoo.org/show/92741/
16:44:35 <aconbere> minus obvious errors :)
16:46:12 <Cale> actOnMovies :: ([MovieTitle] -> a) -> IO a  would also work.
16:46:33 <Cale> actually, we'd probably call that  withMovies  by convention :)
16:46:38 <aconbere> ah
16:46:50 <aconbere> and I could just type variable MovieTitle from the start
16:48:45 <aconbere> w
16:48:48 <aconbere> heh... vim!
16:49:04 <Cale> aconbere: Of course,  IO [MovieTitle]  is basically all you'll need.
16:49:17 <Cale> aconbere: Since there's nothing you do afterward.
16:50:03 <Cale> aconbere: So the top level of your program can get the list of movies from the file and pass that on to whatever needs it.
16:50:59 <aconbere> Cale: yeah, but I didn't like throwing the IO [MovieTitle] stuff around
16:51:06 <aconbere> it made it hard to toss test data at things
16:51:07 <Cale> aconbere: You don't.
16:51:10 <aconbere> oh
16:51:27 <alexei_> this does not terminate  split' n n where split' 0 _ = [ [] ]; split' n k = [ i:sni | i <- [1..k], sni <- split' (n-i) k ]  I dont quite see why ...
16:51:29 <Cale> aconbere: You throw [MovieTitle] values around, after running the IO [MovieTitle] somewhere close to the top of your program.
16:52:18 <aconbere> can you paste an example?
16:52:38 <Cale> alexei_: that recursive call to split' should have i as its second parameter
16:52:48 <Cale> aconbere: Sure...
16:55:58 <Cale> aconbere: Well, basically, near the top of main, you'll have:
16:56:05 <Cale> movies <- getMovies
16:56:21 <Cale> movies will then be a [MovieTitle]
16:56:26 <aconbere> ahhh yes
16:56:30 <aconbere> exactly
16:56:30 <Cale> and can be passed to other functions
16:56:46 <aconbere> just like withMovies does
16:56:55 <Cale> right
16:57:06 <Cale> Everything which needs access to the list of movies will get that list as a parameter.
16:57:20 <Cale> That is, it shouldn't have to do IO.
16:57:29 <Cale> It just needs an extra parameter.
16:57:50 <aconbere> right, the only reason things like withMovies exist is cause I want to be able to play with a lot of the data in the command line
16:58:21 <Cale> And note that at the GHCi prompt, you can write  movies <- getMovies  as well.
16:58:26 <aconbere> yep!
16:58:31 <Cale> Though I'm not sure how long the definition will last.
16:58:42 <aconbere> I'm on that, though I'm trying to figure out how I can pipe that output
16:58:45 <alexei_> Cale: thanks, I think will sleep over it ...
16:58:53 <aconbere> I was trying to use >>= in ghci
16:58:58 <aconbere> but it wasn't working like I would expect :P
16:59:05 <Cale> alexei_: Basically, you want to ensure that the sequence is weakly decreasing.
16:59:12 <povman> OpenGL.GLU.NURBS is rather unhaskellic
16:59:44 <Cale> alexei_: A partition of n into parts at most k is a number j from 1 up to k followed by a partition of (n-j) into parts at most j.
17:02:32 <povman> have people simply not bothered to haskellize GLU or is there a good reason for its City
17:02:39 <povman> C-ity
17:03:20 <gwern> @hoogle fromJust
17:03:20 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
17:03:52 <Cale> povman: How about Graphics.Rendering.OGL.GLU.NURBS ?
17:04:20 <povman> Cale: that's the one i'm talking about
17:04:38 <povman> examine the type of nurbsCurve
17:05:17 <Cale> povman: You mean that function which isn't exported?
17:05:23 <Cale> er, oh
17:05:25 <Cale> It is.
17:05:48 <povman> i feel like i'm missing out on something with all these Callback's
17:05:51 <Cale> Ah, and there's a couple Ptrs there.
17:06:09 <povman> Ptrs are pure evil
17:06:21 <Thomas2> hmm, mebbe the haskellisation is still proceeding?
17:06:26 <Cale> It's probably that nobody has done it.
17:06:43 <povman> i have a suspicion that i should use these Callback things instead...
17:06:57 <Thomas2> aren't they to allow you to cache procedures?
17:07:01 <Thomas2> or am I terribly confused
17:07:09 <Cale> It's quite possible that the people who did the bindings don't know anything about NURBS, and so left things as close to the C interface as possible so as not to leave anything out.
17:07:10 <povman> well i'm very new to opengl
17:07:45 <Cale> Well, callbacks are just how GLUT works from what I understand.
17:08:28 <Thomas2> not sure, it's been a long time since I GLUTted
17:08:31 <povman> ah, no apparently callbacks are described in "chapter 7.3"
17:08:38 <Thomas2> bear in mind that glut =/ glu =/ gl
17:08:48 <povman> \/=
17:08:50 <povman> what
17:08:51 <povman>  /=
17:09:03 <Thomas2> err, sorry, i code in about 6 functional languages
17:09:05 <povman> :p
17:09:08 <Thomas2> i'm permanently confused about syntax
17:09:12 <Thomas2> that's the isabelle-ism
17:09:49 <povman> well! there is a nonzero probability of me making a richer interface to NURBS henceforth.
17:12:17 <kynky> still anywhere in the range of 1x10^(-infinity) to infinity , and i guess the negative range too :)
17:13:37 <lispy> we need NURBS for n00bs.
17:13:48 <BMeph> Cale: Thanks! From looking up all sorts of XML junk, I found out that Glenn Reid (EPS) is the brother of Brian (Scribe) Reid. :)
17:13:51 <lispy> how is code?
17:14:17 <lispy> BMeph: weird and wonderful :)
17:14:25 <Cale> I don't know who either of those people are.
17:14:59 <gwern> I'm curious, what does this erro message mean?
17:15:00 <povman> kynky either doesn't understand that probabilities are between 0 and 1 or was speaking about something else
17:15:00 <gwern>  Cannot use record selector `rawbuf' as a function due to escaped type variables
17:15:03 <gwern>     Probable fix: use pattern-matching syntax instead
17:15:34 <gwern> this is the error on a function that looks like this:
17:15:37 <gwern> bar :: FBuffer -> (BufferImpl syntax)
17:15:41 <gwern> bar a = rawbuf a
17:15:53 <gwern> FBuffer {....                , rawbuf :: !(BufferImpl syntax)
17:15:56 <gwern> ...}
17:16:45 <BMeph> Cale: Ah, but you know their work, if only by reputation.
17:17:14 <Cale> BMeph: If EPS stands for Encapsulated Postscript, then I know what that is.
17:17:19 <Cale> I don't know what Scribe is.
17:17:28 <BMeph> Cale: EPS is Encapsulated PostScript, and Scribe is a markup language that gave the inspiration to LaTeX.
17:17:56 <Cale> ah
17:17:58 <gwern> when I try a line like 'bar (FBuffer {rawbuf = a}) = a' it gives even more bizaare errors
17:18:07 <Cale> gwern: How is that type defined?
17:18:29 <BMeph> It makes sense to know that the creators of those two pieces of tech were related, but that they're brothers is almost spooky... o.O
17:18:37 <gwern> Cale: which type?
17:19:05 <Cale> FBuffer
17:19:25 <gwern> see http://hpaste.org/12413
17:19:26 <Cale> BMeph: I don't know. :) Makes sense to me.
17:20:16 <lispy> povman: actually, there is a way to model negative probabilities and it leads to an explation of quantum mechanics that some people find easier to understand
17:20:16 <Cale> gwern: Okay, so it's an existential type with record syntax.
17:20:37 <Cale> gwern: So you can't use rawbuf or bmode as selectors.
17:20:45 <gwern> eurk I was afraid it'd be soemthing clever like that
17:20:47 <Cale> gwern: Because they wouldn't type.
17:21:12 <gwern> Cale: is it even possible to extract the  BufferImpl from a FBuffer at all?
17:21:21 <Cale> They'd be  rawbuf :: FBuffer -> (exists syntax. BufferImpl syntax)
17:21:22 <povman> lispy: that's interesting... but does this model allow for probabilities up to infinity?
17:21:44 <Cale> gwern: (and similar for bmode)
17:21:55 <lispy> povman: I don't think so.  But, then, how is [0,1] different than the real line from 0 to infinity?
17:22:19 <gwern> Cale: I don't understand what you are saying
17:22:33 <gwern> I just want to tak ethe bufferImpl out of the FBuffer :(
17:22:39 <Cale> gwern: It's possible to pattern match an FBuffer with case.
17:22:40 <povman> lispy: with [0,1] i can say something is definite
17:22:45 <gwern> (it's taken me hours just to get up to the FBuffer)
17:23:02 <Cale> gwern: and use the BufferImpl without making assumptions about the syntax type.
17:23:15 <gwern> Cale: but case is for datatypes, what does that even look like for records?
17:23:19 <Cale> gwern: You must return something which doesn't depend on the syntax type though.
17:23:34 <Cale> case myFBuffer of
17:23:47 <Cale>   FBuffer { rawbuf = x } -> ...
17:24:05 <povman> gwern: if you want functions to play with your rawbuf field, add them to your datatype - then they will have the proper signature
17:24:32 <povman> eg FBuffer {..., doStuff :: BufferImpl syntax -> IO () ...}
17:24:51 <Cale> uh, I don't think you necessarily have to go that far
17:25:19 <Cale> You just have to be sure that whatever you produce from that case doesn't depend on the syntax type.
17:25:32 <povman> if you want to play with whatever 'syntax' the BufferImpl holds then you do...
17:25:52 <Cale> It's possible that BufferImpl contains functions for operating on it.
17:26:00 <povman> true
17:26:02 <Cale> But without seeing that type, I have no idea.
17:26:18 <gwern> this is yi, I've learned to not assume that it'll help you out with what you need :(
17:26:40 <Cale> gwern: in any case, your problem is that bar is returning a
17:27:10 <Cale> gwern: You can't do that, because the whole point of the existential type is to prevent you from knowing what type 'syntax' is.
17:27:44 <lispy> does syntax at least give some type class constraints then?
17:27:56 <Cale> gwern: However, if, say you had a polymorphic function of type  BufferImpl a -> Integer, you could apply it there, with no problem.
17:28:17 <Cale> lispy: No, which is why I suspect that BufferImpl syntax is a record of functions.
17:28:43 <lispy> Cale: if it's a record of functions, then it's simulating dictionary passing?
17:28:51 <Cale> yes
17:29:09 <Cale> (which is more flexible)
17:29:13 <gwern> http://hpaste.org/12413#a1
17:29:19 <gwern> ^ bufferimpl
17:29:24 <lispy> that seems like polymorphism that is even more ad-hoc than ad-hoc polymorphism :)
17:29:37 <Cale> Nothing here is ad-hoc.
17:29:49 <gwern> I still don't quite follow, since case a of FBuffer {rawbuf=x} -> x doesn't compile
17:29:54 <Cale> (Typeclasses are *NOT* ad-hoc polymorphism.)
17:30:08 <lispy> Cale: Oh?  That's what my profs called them
17:30:16 <lispy> Cale: what is the difference to you?
17:30:44 <Cale> lispy: Typeclass polymorphism is much more closely related to parametric polymorphism.
17:31:22 <povman> gwern: you simply cannot write that function
17:31:42 <Cale> lispy: With ad-hoc polymorphism, using ad-hoc polymorphic functions doesn't automatically give you polymorphic functions.
17:31:52 <Cale> lispy: Consider  sort :: (Ord a) => [a] -> [a]
17:31:58 <gwern> http://hpaste.org/12413#a3 <-- latest
17:32:08 <gwern> povman: impossible? you are sure?
17:32:16 <Cale> lispy: It has a typeclass polymorphic type, and yet is not defined by cases. That is, it's not a method of Ord.
17:32:35 <povman> gwern: to correctly type a function using the rawbuf field, you have to put it somewhere where you have access to the 'syntax' variable
17:32:43 <povman> ie not outside of the FBuffer data structure
17:33:05 <gwern> dagnabbit
17:33:18 <gwern> I guess I'll have to complain to jpb then
17:33:21 <gwern> nothing doing
17:33:32 <Cale> gwern: what are you trying to do?
17:33:36 <povman> gwern: you could do FBuffer {..., bar :: (BufferImpl syntax) -> whatever } -- and call bar on your FBuffer
17:33:47 <roconnor> gwern: how is Yi?  Should I study it if I want to write a structured editor?
17:33:58 <gwern> Cale: I just want the String that is in a buffer!
17:34:08 <povman> gwern: how do you know it is a string?
17:34:20 <kynky> type inference
17:34:25 <gwern> povman: it's a text editor. a buffer contains a String.
17:34:26 <Cale> gwern: Then apply mem to the BufferImpl
17:34:32 <povman> whups i'm a stupid
17:34:38 <Cale> You'll get a ByteRope
17:34:40 <gwern> it's not going to contain a Boolean...
17:34:47 <Cale> (that apparently is the buffer text)
17:34:47 <gwern> Cale: yeah, but ByteRope exports toString
17:35:02 <gwern> and byterope is just a fancy lazy bytestring as it is, so
17:35:32 <Cale> gwern: The important thing is that you can't return the BufferImpl directly, because you don't know what the syntax type is, but that doesn't prevent you from *using* it to return something else.
17:35:38 * roconnor notes that join . liftM (findBuffer)   is (>>= findBuffer)
17:35:38 <gwern> Cale: yes, if I had the function to return the BufferImpl I would indeed apply mem, then toString
17:35:45 <gwern> hush you
17:35:50 <Cale> gwern: Apply mem right away.
17:36:06 <Cale> gwern: That is, in the function in which you extract the BufferImpl field.
17:36:45 <gwern> hm.
17:36:54 <Cale> lispy: Does that make sense? I can try to explain more clearly what the difference is.
17:36:54 <gwern> so '         FBuffer { rawbuf = x } ->  mem x
17:37:00 <Cale> gwern: exactly.
17:37:19 <lispy> Cale: I still disagree, but I'm not feeling very well, so I dropped out of the discussion
17:37:25 <povman> you probably don't even need the match any more
17:37:46 <povman> bar x = mem . rawbuf -- also should work
17:38:25 <povman> sans x
17:38:36 <Cale> lispy: Okay, I can try to explain better. Typeclass polymorphism lets you implement ad-hoc polymorphism, by defining typeclasses which have a type variable, and a single method which is totally polymorphic, and always specifying a monomorphic type whenever you use the method.
17:38:44 <gwern> povman: no, that gives an error about escaped type variables
17:38:51 <Cale> (which fixes the instance)
17:39:00 <gwern> @hoogle [Word8] -> String
17:39:01 <lambdabot> Prelude show :: Show a => a -> String
17:39:01 <lambdabot> Text.Show show :: Show a => a -> String
17:39:01 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
17:39:14 <gwern> hm
17:39:22 <povman> gwern: what error, curious
17:39:24 <Cale> lispy: But going the other way is harder.
17:39:37 <gwern> povman:     Cannot use record selector `rawbuf' as a function due to escaped type variables
17:39:40 <gwern>     Probable fix: use pattern-matching syntax instead
17:39:50 <gwern> ^ bar = mem . rawbuf
17:39:57 <lispy> Cale: you're saying that ad-hoc polymorphism and type classes overlap, but are non-equal?
17:40:01 <povman> eh, weird. does it work with case?
17:40:01 <Cale> lispy: For example, what ad-hoc polymorphic program does something like   instance (Show x) => (Show [x]) where show = ...  correspond to?
17:40:06 <gwern> povman: yes
17:40:11 <povman> pff.
17:40:48 <Cale> lispy: You can have ad-hoc polymorphism without parametric polymorphism, you cannot have typeclass polymorphism without parametric polymorphism, and typeclasses let you do things which ad-hoc polymorphism does not.
17:40:48 <gwern> annoying. I've forgotten what one does with a [Word8]
17:41:10 <Cale> lispy: For example, define only (<) for various specific types, and then write a single polymorphic sort function in terms of it.
17:41:18 <povman> you could pass it to const, just for fun
17:41:31 <lispy> gwern: one does not simply walk into a [Word8]!
17:41:48 <gwern> lispy: a Word8? In *my* program?
17:41:52 <dolio> fromInteger isn't implementable in most ad-hoc polymorphic languages out there.
17:41:55 <Cale> lispy: With ad-hoc polymorphism, you'd have to write sort over and over again for every type of list you wanted to sort, even if you provided the same implementation.
17:41:58 <roconnor> @hoogle [Word8] -> a
17:41:59 <lambdabot> Prelude head :: [a] -> a
17:41:59 <lambdabot> Prelude last :: [a] -> a
17:41:59 <lambdabot> Data.List head :: [a] -> a
17:42:02 <gwern> (It's more likely than you think!)
17:42:13 <Cale> (in terms of an ad-hoc polymorphic (<))
17:43:17 <lispy> Cale: I still see instance Show x => Show [x], as being ad-hoc.  It's just that Haskell's type system is sophisticated to the point where we get a bit less ad-hoc-ness
17:43:39 <luqui> Cale, unless you're talking about C++ "ad-hoc ad-hoc polymorphism"
17:43:45 <luqui> (re: templates)
17:43:50 <gwern> ah, I guess one 'show's a [Word8]
17:43:55 <gwern> *Main> :t liftM (show . bar) $ foo
17:43:57 <dolio> C++ has parametric polymorphism, kind of.
17:43:58 <gwern> liftM (show . bar) $ foo :: EditorM String
17:44:15 <povman> i find it amusing that you are trying to work out what to do with your data
17:44:22 <luqui> dolio, it also has typeclass polymorphism, also kind of
17:44:28 <lispy> C++ has parametric polymorphism with lazy implicit constraints
17:44:46 <dolio> Yeah, and they're making it even closer to typeclass polymorphism in the new standard.
17:44:46 <Cale> lispy: For me, ad-hoc polymorphism is the sort of polymorphism where you implement a value once for each monomorphic type at which you want to be able to instantiate it, and every occurrence of it must be monomorphic.
17:44:47 <luqui> lispy, that is a very kind way of putting it :-)
17:45:22 <luqui> dolio, C++'s "concepts" are better than typeclasses in some ways, since they don't have to worry about decidability of type inference
17:45:27 <Axman6> :t fromIntegral
17:45:28 <lambdabot> forall a b. (Num b, Integral a) => a -> b
17:45:38 <Cale> That is, instance selection is dependent on type, like with typeclass polymorphism, but ad-hoc polymorphism doesn't have a way to say "I'm polymorphic because I use polymorphic things"
17:46:06 <dolio> luqui: I haven't really bothered looking into concepts.
17:46:19 <luqui> they're basically typeclasses.
17:46:22 <Cale> Typeclass polymorphism is better termed "restricted parametric polymorphism".
17:46:38 <luqui> with associated types
17:46:43 <povman> does anyone know of a poster of haskell prelude type / class tree?
17:47:03 <dolio> I'm still don't think you can implement fromInteger in C++. But I'm not 100% sure about that.
17:47:11 <luqui> povman, it would be pretty boring.  it's awful flat
17:47:26 <dolio> It'd be more of a constructor role, I suppose, in that particular case.
17:47:41 <povman> how about just the numeric types? it'd be nice to be able to cast around without having to spend 10 minutes in documentation
17:48:04 <luqui> povman, there's only like 5 classes.  you'll get it.
17:48:15 <lispy> ?instances Num
17:48:16 <lambdabot> Double, Float, Int, Integer
17:48:17 <Axman6> povman: i have a copy of a prelude manual that has one
17:48:23 <lispy> ?instances Complex
17:48:23 <lambdabot> Couldn't find class `Complex'. Try @instances-importing
17:48:36 <lispy> oh was Complex a type?
17:48:53 <luqui> povman, in particular, fromIntegral, realToFrac, and (floor/ceiling/round) are the most common casters
17:48:57 <lispy> This reminds me, anyone here read the Monadius source?
17:49:02 <povman> i've been using haskell for like 3 years and still have to hack'n'slash to get the right combination of functions
17:49:09 <Axman6> > sqrt (-2) :: Complex CReal
17:49:10 <lambdabot>   0.0 :+ 1.4142135623730950488016887242096980785697
17:49:27 <lispy> to save work, the author actually used complex numbers to get the x,y coordinates
17:49:47 <ddarius> A better choice than (Double, Double)
17:50:00 <Cale> lispy: Complex numbers are a great way to represent coordinates for doing geometry.
17:50:06 <luqui> Data.Number.CReal is a terrible implementation.
17:50:13 <ddarius> Makes rotation easy.
17:50:18 <ddarius> :t cis
17:50:19 <lambdabot> forall a. (RealFloat a) => a -> Complex a
17:50:23 <Cale> It's only a shame that there isn't a 3-dimensional division algebra.
17:50:57 <lispy> Cale: divison algebra?  I've heard of quotient algebra, is that the same?
17:51:00 <Axman6> > cis 2 :: Complex CReal
17:51:01 <lambdabot>   0.416146836547142386997568229500762189766 :+ 0.9092974268256816953960198659...
17:51:06 <lispy> C = R/[i] ?
17:51:17 <luqui> > (1::CReal) == 1 + 1/10^50      -- I thought this was supposed to be *exact* real arithmetic
17:51:18 <lambdabot>   True
17:51:19 <Cale> lispy: I mean something which is both a division ring and a vector space.
17:52:11 <Axman6> > ((1::CReal),1 + 1/10^50 :: CReal)
17:52:12 <lambdabot>   (1.0,1.0)
17:52:23 <lispy> Cale: I see now I think
17:52:35 <Cale> (in a way that the operations agree)
17:52:46 <lispy> luqui: I think you can request more precision from CReal but I don't know how
17:52:53 <ddarius> Cale: Why do you want a 3D division algebra?
17:53:12 <Cale> ddarius: Because it would give you the same trick in 3 dimensions.
17:53:18 <luqui> lispy, more precision?  it's supposed to be *exact*  (eg. == should be infinitely precise)
17:53:25 <ddarius> Cale: What's wrong with quaternions?
17:53:42 <luqui> it's not "arbitrary precision" as in gmp... it's infinite -- "computable" -- precision
17:53:45 <Cale> ddarius: Nothing, but they're obviously not as nice as this thing which doesn't exist would be. ;)
17:53:50 * gwern curses monads. arrrgggh
17:53:55 <lispy> luqui: ah
17:53:59 <luqui> anyway... that's just me ranting that there's no good computable real library :-)
17:54:23 <ddarius> Infinitely precise == is semidecidable.
17:54:32 <luqui> yep, it can never return True :-)
17:55:02 <luqui> that's fine with me.  I prefer that to it returning True when it's false...
17:55:35 <roconnor> rule (x::CReal == x) == True
17:55:56 <luqui> roconnor, oh is that a law in Eq?
17:55:56 <lispy> > 1 :: Complex Int
17:55:57 <lambdabot>       No instance for (RealFloat Int)
17:55:57 <lambdabot>        arising from the literal `1' at ...
17:56:09 <roconnor> luqui: not a law for Eq
17:56:17 <roconnor> > (1/0) == (1/0)
17:56:18 <lispy> I think the lack of Complex Int is one of my biggest gripes with the prelude
17:56:19 <lambdabot>   True
17:56:28 <luqui> roconnor, or are you saying that's a (referential-transparency-breaking) rewrite rule one could use?
17:56:28 <roconnor> what?!
17:56:37 <roconnor> oh right
17:56:39 <luqui> roconnor, that's floating point being stupid
17:56:41 <roconnor> > (0/0) == (0/0)
17:56:43 <lambdabot>   False
17:56:51 <roconnor> there we go
17:57:03 <lispy> ?src isNaN
17:57:04 <lambdabot> Source not found. Do you think like you type?
17:57:25 <dolio> isNaN = magic
17:57:28 <skorpan> @pl \x y z w -> w z y x
17:57:31 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
17:57:37 <skorpan> FLIPPETY FLIP!!!
17:57:53 <lispy> > let myIsNan x | x /= x = True | otherwise = False in myIsNan (0/0)
17:57:54 <lambdabot>   True
17:58:04 <skorpan> @pl \a b c d e f g h -> h g f e d c b a
17:58:05 <twanvl> > (cos 2 :: Double, cos 2 :: CReal) -- :(
17:58:07 <lambdabot>   (-0.4161468365471424,0.416146836547142386997568229500762189766)
17:58:07 <lambdabot> flip (flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .) . (((flip .) .) .)) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .
17:58:07 <lambdabot> ) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id))))))
17:58:07 <lambdabot> optimization suspended, use @pl-resume to continue.
17:58:19 <skorpan> the beauty of pointless code...
17:58:23 <dolio> > (0/0) /= (0/0)
17:58:24 <lambdabot>   True
17:58:26 <lispy> dolio: it's not that magical
17:58:49 <luqui> isNan (0/0 :: CReal)  -- :-)
17:58:51 <lispy> dolio: it just uses the idea that NaN is not equal to itself and no other float value in ieee754 has that property
17:59:08 <dolio> I was thinking that NaN `comparison` NaN was always False, for some reason.
17:59:43 <luqui> reminds me of "isBottom"  (which is actually defined in Test.QuickCheck.  I don't know how they managed to solve the halting problem, but more power to 'em)
17:59:45 <dolio> But, of course, you could use NaN == NaN = False, then, I guess.
18:01:10 <luqui> that may be IEEE's way of doing it, but I appreciate the Haskell community for not putting up with their bullshit
18:01:32 <luqui> any implementation of Eq in which a /= b  isn't  not (a == b) is just wrong
18:01:51 <dolio> :)
18:06:27 <StoneToad> dolio: NaN should not be equal to anything if it's following the standards
18:07:02 <StoneToad> like how NULL == NULL is false in sql
18:07:53 <luqui> @check \xs -> xs == head xs : tail xs || xs == []
18:07:55 <lambdabot>   "OK, passed 500 tests."
18:08:23 <oklopol> good point
18:08:42 <kynky> i guess undefined /= undefined from certain aspects
18:08:51 <luqui> what!
18:09:00 <luqui> undefined == undefined.  you just can't decide it.
18:09:23 <kynky> was looking at StoneToad statement
18:09:31 <oklopol> the problem with that is, it's not, pretty much by definition, a well-defined question
18:09:39 <luqui> aye
18:09:58 <StoneToad> lol
18:10:14 <StoneToad> undefined is by definition not well defined :p
18:10:19 <dolio> StoneToad: Yeah, but should it be not-equal to anything?
18:10:32 <oklopol> but i'd say it makes sense if you have some kinda identity on objects, and 0/0 is equal to the "same" 0/0, but not some other 0/0 . in haskell i just wouldn't have undefinitedness
18:10:55 <kynky> haskell has no side effects
18:11:00 <oklopol> well, afaik knuth says 0/0 should be 1, so make that 1/0
18:11:05 <kynky> sql does
18:11:07 <StoneToad> dolio: well, if you're doing tri-state logic, then yes, both NULL /= NULL and NULL == NULL are false
18:11:22 <hackage> Uploaded to hackage: ansi-wl-pprint 0.5.0
18:11:37 <dolio> Yeah, I thought that was the case for NULL in SQL, but what about NaN?
18:11:50 * luqui thinks a/b should require a proof that b /= 0 to be called :-)
18:12:14 <luqui> StoneToad, I prefer to spell it;  tri-state "logic"
18:12:29 <kynky> luqui, like x/x /=1 where x = 0
18:12:58 <StoneToad> dolio: odly enough it's not like that in IEEE floating point
18:13:09 <dolio> Huh.
18:13:10 <luqui> kynky, you.. just confused me
18:13:12 <EvilTerran> luqui, within haskell, you could have it return a Maybe result
18:13:15 <StoneToad> http://en.wikipedia.org/wiki/NaN
18:13:17 <lambdabot> Title: NaN - Wikipedia, the free encyclopedia
18:13:35 <StoneToad> if x is NaN, then x == x is false, and x /= x is true
18:13:44 <luqui> EvilTerran, yeah, but not if you're using CReals...
18:14:14 <dolio> luqui: If you use CReals, you might have difficulty providing a proof that it's non-zero. :)
18:14:39 <luqui> dolio, for the same reason as it would have difficulty returning Nothing
18:14:51 <dolio> Yeah.
18:15:26 <dolio> The simplest way to get such a proof would be 'test : (x : CReal) -> x == 0 \/ x /= 0' for instance.
18:15:40 <gwern> so, what's the difference  between a 'let foo =' and a 'foo <-' in a do expression?
18:15:45 <luqui> that's discontinuous though
18:16:16 <EvilTerran> ?undo \x -> do let { foo = x }; return x
18:16:17 <lambdabot> \ x -> let { foo = x} in return x
18:16:26 <dolio> I mean, that's what you'd probably use for integers, at least.
18:16:28 <EvilTerran> ?undo \x -> do let foo <- x; return foo
18:16:29 <lambdabot>  Parse error at "<-" (column 18)
18:16:33 <EvilTerran> ?undo \x -> do foo <- x; return foo
18:16:33 <lambdabot> \ x -> x >>= \ foo -> return foo
18:16:43 <dolio> But it doesn't work for CReals, of course.
18:16:50 <luqui> dolio, yeah true...  on the other hand mathematicians have to provide such proofs every time they divide
18:16:53 <EvilTerran> ?undo \x -> do foo:_ <- x; return foo
18:16:54 <lambdabot> \ x -> x >>= \ a -> case a of { foo : _ -> return foo; _ -> fail ""}
18:16:57 <luqui> why should programmers have it any easier? :-)
18:17:02 <Cale> gwern: let foo = bar  defines foo and bar to be equal,  foo <- bar  defines foo to be the result of executing the action bar.
18:17:02 <dolio> You'd have to do actual work proving stuff. :)
18:17:18 <Cale> gwern: You've been here a while, I would think you'd know that :)
18:17:33 <gwern> Cale: it's just in my do expression, both compile, which confuses me
18:17:49 <Cale> gwern: Well, foo will have a different type in each case.
18:17:54 <gwern> I was wondering if they lead to different types but how that worked
18:18:09 <Cale> If bar :: IO t, then in the first case, foo :: IO t, and in the second, foo :: t.
18:18:20 <gwern> hm.
18:18:27 <Cale> foo = bar means that foo and bar are the same action
18:18:32 <EvilTerran> (foo :: a) <- (bar :: m a)
18:18:38 <EvilTerran> let (foo :: a) = (bar :: a)
18:18:41 <gwern> @hoogle join
18:18:41 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
18:18:41 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
18:18:41 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
18:18:42 <Cale> foo <- bar means that foo is the result of bar
18:19:05 <Cale> (and likely not an action)
18:19:14 <gwern> auugh. I give up. yi has defeated me for today
18:19:23 <Cale> gwern: Does that make sense?
18:19:30 <Cale> gwern: Let's look at a case with lists.
18:19:47 <Cale> In the list monad, an action is a list, and 'executing' a list means picking an element from it.
18:20:02 <Cale> > (do x <- [1,2,3]; y <- [4,5]; return (x,y))
18:20:02 <gwern> Cale: no. my brain is fried, so don't waste your time
18:20:03 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
18:20:14 <Cale> > (do x <- [1,2,3]; let y = [4,5]; return (x,y))
18:20:15 <lambdabot>   <no location info>: parse error on input `)'
18:20:21 <Cale> > (do x <- [1,2,3]; let {y = [4,5]}; return (x,y))
18:20:22 <lambdabot>   [(1,[4,5]),(2,[4,5]),(3,[4,5])]
18:20:39 <luqui> @check \x -> x::Bool
18:20:41 <lambdabot>   "Falsifiable, after 0 tests:\nFalse\n"
18:20:56 <EvilTerran> @check (==)
18:20:58 <lambdabot>   "OK, passed 500 tests."
18:21:10 <luqui> what?!
18:21:13 <luqui> oh, defaulting to ()
18:21:16 <EvilTerran> >:D
18:26:27 <gwern> @tell Lemmih btw, Richard O'Keefe says on -cafe: 'I really really wish there were just one more sentence on
18:26:28 <lambdabot> Consider it noted.
18:26:31 <gwern> that page saying WHY there is a fork of JHC.'
18:26:33 <gwern> bah
18:26:45 <gwern> @tell Lemmih '...that page saying WHY there is a fork of JHC.'
18:26:46 <lambdabot> Consider it noted.
18:27:09 <gwern> (easy enough answer - 'Meachem refuses to cabalize it')
18:29:02 <Lemmih> That and a few other things.
18:29:02 <lambdabot> Lemmih: You have 4 new messages. '/msg lambdabot @messages' to read them.
18:45:29 <svref> What's the difference between the dell-mini-archive apt sources that came on my laptop and the official 8.04 apt sources?
18:46:01 <svref> oops, wrong form
18:46:07 <svref> sorry!
18:58:57 <ksf> http://en.wikipedia.org/wiki/Constructive_mathematics section 1, paragraph 4
18:58:58 <lambdabot> Title: Constructivism (mathematics) - Wikipedia, the free encyclopedia
18:59:08 <ksf> now i finally get why the excluded middle bothered me.
19:00:32 <Cale> It doesn't really bother me.
19:00:44 <ksf> in fact, it's the best example of why the excluded middle is nonsense in general that i've ever seen.
19:01:00 <Cale> As a formalist, P or (not P) is just an axiom of the way that our logic works.
19:01:21 <Cale> It might be impossible to form a proof for P or a proof for not P
19:01:22 <ksf> so, what if P doesn't terminate?
19:01:30 <Cale> But the statement that P or not P is still true.
19:01:40 <Cale> "Doesn't terminate"?
19:01:54 <ksf> ...that you can't form a proof for it.
19:01:55 <Cale> P is a finite string of symbols.
19:02:06 <ksf> i tend to see stuff from the computational perspective.
19:03:00 <Cale> Well, the appropriate way to map this logic stuff on to computation is that propositions are types, and proofs are programs.
19:03:38 <Cale> It's not easy to see this, but the law of excluded middle is in some sense equivalent to having call/cc.
19:05:10 <dolio> Can you prove excluded middle from Pierce's law, and vice versa?
19:05:35 <Cale> Yeah.
19:05:51 <Cale> at least, iirc.
19:05:54 <dolio> @djinn (((a -> b) -> a) -> a) -> Either a (Not a)
19:05:54 <lambdabot> -- f cannot be realized.
19:06:01 <dolio> @djinn (((a -> b) -> a) -> a) -> Either b (Not b)
19:06:01 <lambdabot> -- f cannot be realized.
19:06:05 <dolio> Hmm..
19:06:06 <Cale> hmm
19:06:47 <dolio> I'm not sure how well djinn can make use of that...
19:06:54 <dolio> @djinn (((a -> Not a) -> a) -> a) -> Either b (Not b)
19:06:54 <lambdabot> -- f cannot be realized.
19:07:08 <dolio> (And not sure what the proof is.)
19:07:12 <dolio> @djinn (((a -> Not a) -> a) -> a) -> Either a (Not a)
19:07:12 <lambdabot> -- f cannot be realized.
19:07:15 <Cale> @djinn (((a -> Not a) -> a) -> a) -> Either a (Not a)
19:07:15 <lambdabot> -- f cannot be realized.
19:07:20 <Cale> hmm
19:07:28 <Cale> I'm not sure how that way goes either.
19:07:37 <Cale> Probably a good exercise :)
19:07:58 <dolio> @djinn a -> Cont r a
19:07:58 <lambdabot> Error: Undefined type Cont
19:08:12 <dolio> @djinn-add type Cont r a = (a -> r) -> r
19:10:16 <dolio> @djinn (((a -> Void) -> a) -> a) -> Either a (Not a)
19:10:16 <lambdabot> -- f cannot be realized.
19:10:23 <ddarius> dolio: Yes you can.  Pierce's law is callCC.  callCC (\k -> Right (\b -> k (Left b))) :: Either a (Not a) -- in a hypothetical Haskell with callCC
19:10:40 <saml> > head [1,1/2..]
19:10:42 <lambdabot>   1.0
19:10:53 <saml> > head [1,1/2,1/4..]
19:10:54 <lambdabot>   <no location info>: parse error on input `..'
19:11:28 <Cale> :t callCC (\k -> Right (\b -> k (Left b)))
19:11:29 <lambdabot>     Couldn't match expected type `Either a b'
19:11:29 <lambdabot>            against inferred type `a -> Either a1 b1'
19:11:29 <lambdabot>       Expected type: Either a1 (Either a b)
19:11:40 <Cale> :t callCC (\k -> return (Right (\b -> k (Left b))))
19:11:41 <lambdabot> forall (m :: * -> *) b a. (MonadCont m) => m (Either a (a -> m b))
19:11:54 <Cale> right
19:12:05 <saml> how can I generate an infinite list of [1, 1/2, 1/4, 1/8, 1/16, ..] ?
19:12:18 <ddarius> > iterate (/2) 1 :: [Rational]
19:12:19 <lambdabot>   [1%1,1%2,1%4,1%8,1%16,1%32,1%64,1%128,1%256,1%512,1%1024,1%2048,1%4096,1%81...
19:12:19 <Cale> > [1/2^k | k <- [0..]]
19:12:21 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
19:12:31 <Cale> > [1/2^k | k <- [0..]] :: [Rational]
19:12:32 <ksf> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.6893
19:12:33 <lambdabot>   [1%1,1%2,1%4,1%8,1%16,1%32,1%64,1%128,1%256,1%512,1%1024,1%2048,1%4096,1%81...
19:12:35 <lambdabot> Title: A formulae-as-types notion of control - CiteSeerX
19:12:45 <saml> > sum (iterate (/2) 1)
19:13:00 <lambdabot>   mueval: Prelude.read: no parse
19:13:03 <dolio> @type let pierce :: (((a -> b) -> a) -> a) ; pierce = undefined in pierce (\k -> Right (\b -> k (Left b)))
19:13:06 <lambdabot> forall b a. Either a (a -> b)
19:13:08 <ddarius> saml: The list is infinitely long.
19:13:22 <Cale> dolio: good call
19:13:22 <saml> but is the sum of [1, 1/2, 1/4, 1/8, ...]  2?
19:13:39 <ddarius> > scanl (+) 0 $ iterate (/2) 1
19:13:42 <lambdabot>   [0.0,1.0,1.5,1.75,1.875,1.9375,1.96875,1.984375,1.9921875,1.99609375,1.9980...
19:13:42 <saml> .g infinite series
19:13:55 <ddarius> saml: It's undefined in Haskell.  In math it converges to 2, yes.
19:14:04 <saml> ah thanks ddarius
19:14:17 <dolio> @djinn (((a -> Void) -> a) -> a) -> Either a (a -> Void)
19:14:18 <lambdabot> -- f cannot be realized.
19:14:48 <ksf> coming to think of it: can you add call/cc to a total language and still end up with something that isn't turing-complete?
19:14:50 <Cale> I wonder why djinn can't manage that.
19:15:05 <ddarius> ksf: Yes.
19:15:28 <ddarius> ksf: There are other ways to add control operations that are somewhat more disciplined that retain nice properties.
19:18:08 <dolio> Well, djinn gets LEM -> Pierce fine.]
19:18:12 <dolio> Not sure why the other way doesn't work.
19:18:48 <ksf> "a -> _|_ is abbrivated as not a. [...] If M is of type not not a, then call/cc(M) is of type a"
19:19:08 <ksf> the problem with that is that M can't be a or not a, it's both, always.
19:19:13 <ksf> at least in potentia.
19:19:25 <ksf> you can always pull the plug or don't have enough memory.
19:19:41 <ksf> or, put differently, it's neither nor.
19:20:23 <ksf> it doesn't really matter as long as you're always painfully aware of when the excluded middle is involved.
19:20:28 <ksf> there be dragons.
19:21:45 <Cale> ksf: Taking the categorical logic perspective, we can view statements as a category, with a unique arrow A -> B when A entails B logically. The initial object 0 acts like "false" and terminal object 1 acts as "true". We can take an arbitrary statement A to be true if there is an arrow 1 -> A, and false if there is an arrow A -> 0. The exponential object B^A acts as the statement "A implies B", and given an arrow 1 ->
19:21:45 <Cale> 0^A, we can get an arrow A -> 0. LEM is the assertion that there be an arrow 1 -> A + 0^A, where + is coproduct.
19:22:06 <Cale> This does not guarantee that there's an arrow 1 -> A or A -> 0 for all A.
19:22:49 <Cale> (*that* would be the same as saying that the logic is complete)
19:23:30 <ksf> 1 -> A -> 0 *hummm*
19:24:43 <ksf> so it's basically saying that the excluded middle might be true, but doesn't need to.
19:24:49 <ksf> which is fine for my tastes.
19:25:09 <Cale> Well, in categorical logic, which is general enough to handle both cases.
19:25:22 <Cale> LEM is nice though.
19:25:25 <ksf> can you point me to a paper that includes such stuff?
19:25:28 <Cale> hmm
19:26:03 <Cale> Well, I can give you a book...
19:26:04 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
19:26:13 <lambdabot> Title: cache:http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon, ..., http://tinyurl.com/4jav6v
19:26:19 <Cale> It's about category theory generally.
19:26:36 <ddarius> Does it have anything particularly about categorical logic?
19:26:46 <Cale> A bit.
19:26:51 * ddarius doesn't remember if he finished that book yet.
19:26:54 <ddarius> I think I did.
19:27:06 <ksf> I've got the joy of cats, but it's kinda focused on other aspects than computation.
19:27:17 <ddarius> Apparently I did.
19:27:46 <ddarius> ksf: The book that Cale recommends is a rather good introduction to CT in my opinion (if you need that).
19:28:20 <ksf> @where joc
19:28:20 <lambdabot> http://katmat.math.uni-bremen.de/acc/
19:28:50 <ksf> I'd be grateful for one that uses computations as prime examples.
19:28:51 <Cale> Joy of Cats is a bit weird, iirc.
19:29:25 <ddarius> I started it but haven't finished it yet.
19:30:04 <ddarius> My impression is that it is not geared particularly to be a general introduction to (typical) category theory.
19:32:53 <ksf> It's more of a reference than a tutorial, but sometimes references are the better tutorials.
19:34:33 <ddarius> ksf: If you want a reference for several pure CT results and definitions, I have a half formatted little article on it.
19:34:47 <ddarius> (Though there is still much that could be added.)
19:37:58 <ksf> I guess first I'd have to get my ass down and do some exercises, anyway.
19:38:11 <ksf> I'm in utter snarf-mode atm.
19:49:40 <timthelion> Is there any really simple, really light, cross platform gui's like www.fltk.org for haskell?  Would it be hard to use fltk from haskell?
19:49:52 <timthelion> s/Is/are
19:50:21 <povman> timthelion: gtk2hs
19:50:45 <timthelion> light? cross platform?
19:50:53 <povman> it's pretty much the only viable gui toolkit in haskell currently
19:51:15 <povman> by viable i imply maintained
19:51:20 <timthelion> really? :(
19:51:30 <povman> i'd be happy to be wrong.... anyone?
19:51:41 <ksf> curses?
19:51:44 <Cale> There's WxHaskell
19:51:55 <povman> gtk2hs is crossplatform
19:52:04 <povman> i never got wxhaskell working
19:52:05 <timthelion> Wx is SLOW unfortunatly
19:52:31 <Cale> Only the darcs version of wxHaskell is likely to work, last I checked.
19:53:02 <Cale> Is it really? I've used it without any problems with speed.
19:53:11 <timthelion> Is it hard to create a link between a c library and haskell?  I see sjanssen did it for X11 libs for xmonad.
19:53:23 <Cale> It's fairly easy.
19:53:26 <povman> timthelion: the ffi is really simple!
19:53:27 <Cale> Haskell has a nice FFI.
19:53:43 <povman> it's unbelievable actually
19:53:49 <povman> i always thought it was hard
19:54:43 <timthelion> Cale: I don't know,  I have a wxpython program that I'm working on, and it's too slow to bear, that's why I'm trying to switch languages.  My dad got in this swearing rant at me about how back in his day computers where twice as fast as they are now, and only did half as much.  Now they are a million times as powerfull, and twice as slow....  I happen to agree with him.
19:55:13 <timthelion> I might look into linking fltk then.
19:55:37 <povman> timthelion:
19:55:40 <ksf> speaking of x11...
19:55:41 <povman> timthelion: http://hpaste.org/12418
19:55:46 <ksf> did anyone try http://community.haskell.org/~aslatter/code/xhb/ ?
19:55:47 <lambdabot> Title: Index of /~aslatter/code/xhb
19:55:51 <ksf> is it usable?
19:56:22 <roconnor> your dad didn't have menus that fade in and out.
19:56:25 <roconnor> :P
19:56:39 <timthelion> povman: wow, thanks
19:56:51 <ddarius> roconnor: Those don't really make too much of a difference performance-wise.
19:56:58 <lament> timthelion: you are free to write faster programs
19:57:06 <roconnor> ddarius: gpu?
19:57:08 <ksf> My dad also doesn't have to kill xcompmgr before playing eve.
19:57:17 <lament> timthelion: consider using assembly and bypassing the operating system
19:57:23 <timthelion> roconnor: he tried turning those off in vista and it's still slower than windows 95 on a PII
19:57:36 <roconnor> damn :(
19:58:09 <ddarius> roconnor: It's just not that processor intensive, especially given the rarity (in CPU time)
19:58:16 <povman> my 1ghz ibook g4 is still ownage fast
19:58:31 <Cale> timthelion: To be honest, a complete binding to a GUI library is still going to be a fair amount of work.
19:58:40 <Cale> timthelion: But it should be reasonably doable.
19:58:59 <Cale> timthelion: However, gtk2hs is rather good, and you should give it a good look :)
19:59:11 <Cale> (it's also cross platform)
19:59:13 <timthelion> Cale: I really really want to support windows.
19:59:21 <Cale> It supports windows.
19:59:26 <timthelion> Cale: Last time I installed gtk2 on windows, it sucked.
19:59:44 <povman> you might write the gui in another language and make a simple interface to your hs program
20:00:06 <ksf> what ever happened to @faq?
20:00:08 <timthelion> povman: It's an idea.
20:00:24 <lament> GTK is cross platform. It looks terrible everywhere.
20:00:31 <povman> lol
20:01:17 <ksf> you could also write a tk in haskell and provide c bindings.
20:01:30 <timthelion> Cale: do you think I could use the C.Types thing to send commands as strings to a gui that was written AS a c library?
20:01:43 <lament> ksf: lol
20:02:23 <Cale> timthelion: hm?
20:02:29 <ksf> sounds like a good plan to dominate the world.
20:02:30 <timthelion> Like have my executable be a haskell program that linked into the gui, then would call the C function, draw gui.  But then how would I do events...
20:02:57 <povman> timthelion: yes. look at the FFI documentation. you can export haskell functions as C ones
20:03:12 <timthelion> povman: ooh, that would be interesting.
20:03:18 <Cale> I suppose you could...
20:03:19 <timthelion> povman: can I do it inline?
20:03:26 <povman> yeah it's like
20:03:53 <povman> foreign export ccall "name_in_c" myHSFunction :: Double -> IO ()
20:04:06 <povman> then you suddenly get access to name_in_c in your C programs
20:04:18 <povman> with the right type and everythig
20:04:31 <timthelion> povman: interesting.  I'm wondering if I can mix haskell and c in the same file then...
20:04:36 <Cale> Uh, except it's not *quite* as simple as that.
20:04:36 <povman> oh no
20:04:52 <Cale> You have to initialise the haskell runtime from C as well, don't forget.
20:04:55 <povman> there's a lot of magic behind 'suddenly'
20:05:01 <Cale> and you have to compile your C program using GHC.
20:05:11 <Cale> (or else work out the right way to link it yourself)
20:05:29 <povman> timthelion: you can't combine files
20:05:33 <Cale> I suppose you could compile the C into .o with another C compiler and then link it using GHC.
20:05:40 <Cale> (if it was important)
20:05:43 <povman> Cale: that is the way of peril
20:06:39 <povman> timthelion: when you build your haskell program with ffi turned on, it'll spit out a ..._stub.{c,h}. you then #include the h file in your C program and compile them together using ghc
20:07:08 <povman> (you do need the #include, right?)
20:07:22 <timthelion> Hm.
20:07:34 <timthelion> This is all sounding like a lot of work...
20:07:40 <povman> it's really easy
20:07:49 <povman> you just add the .c file to your ghc command line
20:07:55 <timthelion> To get the crap version in python, didn't require doing anything that sounded scarry.
20:07:59 <Cale> timthelion: To be honest, I would really just build a GUI using glade and gtk2hs. It works well.
20:08:39 <povman> sorry yeah i got carried away. i just got sdl working the other day and it was exciting.
20:08:55 <timthelion> That was wxpython.  But my program takes 1.5 secconds to start, and has a very hackish audio backend.
20:09:32 <Cale> There might be a bit of a difference between the way that GTK apps look on windows and native windows apps, but it's not so bad, and you'll have a bit of that with any cross platform GUI library.
20:09:52 <timthelion> Now how big is GTK statically linked?
20:13:07 <timthelion> I'm actually not yet a real haskell programmer yet.  But this program is simple.  You press a button to add a recording to a list, and another button to add a recording to the first recording, as if that first recording was a directory.  Making for a file/directory duality...  Kind of makes using a purely functional langauge pointless, as every single function does a file opperation.
20:13:34 <povman> and it ran slow?
20:13:41 <timthelion> Yes, quite.
20:14:01 <timthelion> Just loading a window with 10 buttons, in wxpython takes more than a seccond.
20:14:26 <povman> were you running while(1); at the time?
20:14:37 <timthelion> I don't have a really fast computer, but loading a dillo window, which uses www.fltk.org takes less than that.
20:15:05 <timthelion> Dillo is almost instant, so I considure this to be unacceptable.
20:15:21 <povman> yeah. can we see the code which took 10 seconds to load?
20:15:25 <povman> er ... 1
20:18:14 <timthelion> The program is in a lot of files, but the main gui is small.  I actually have a 2 seccond dellay in it, because I'm starting a deamon.  But without the deamon, it's just as slow...
20:18:24 <timthelion> http://hpaste.org/12419
20:18:26 <povman> i've seen some really fast python programs, so something sounds fishy already
20:19:06 <timthelion> The slowness is in that xrc call, which loads the xml file gui.
20:19:44 <timthelion> and also in the loading of python itself.  the program python takes a quarter of a seccond for the simplest program possible.
20:19:54 <povman> oh. that'd be why.
20:20:19 <povman> what happens if you compile it first?
20:20:21 <timthelion> what?
20:20:25 <povman> the XML thing
20:20:40 <timthelion> I havn't tried that.
20:22:31 <povman> especially if the xrc part is actually written in python
20:23:12 <lament> timthelion: so no matter how much you optimize this program, it will still take at least 2 seconds to load?
20:24:19 <Cale> timthelion: Does it run reasonably quickly once it's loaded?
20:24:28 <Cale> 2 seconds is really not *that* long
20:25:13 <lament> wars have been won in less than that.
20:25:24 <lament> (well, no. The shortest war so far was 40min)
20:25:35 <povman> also you might notice that you have a time.sleep(2)
20:25:43 <timthelion> Cale: It's unacceptably long. If it took you two secconds to say a word, would you talk?
20:25:56 <timthelion> povman: I mentioned that it's just as slow without.
20:26:18 <Cale> timthelion: Let's put it this way: is 2 seconds multiplied by the number of times this program is going to be run shorter or longer than it will take to optimise it? :)
20:28:14 <timthelion> Cale: That still is an invalid point, because 2 secconds multiplied by EVERY program I run is a lot of time.  And if EVERY programmer optimized their code, then more people would use computers, because computers could do more, faster.
20:28:42 <povman> timthelion: as Cale asked before, does it run fast after the initial load?
20:29:31 <timthelion> povman: Not really.  Because my audio backend currently works by initiallizing a new instance of aplay or areccord for each use.
20:29:58 <Cale> timthelion: 2 seconds multiplied by all the times that every program runs is a lot of programmer time.
20:30:05 <povman> you probably won't get any speed improvements by moving the same design to a different language
20:30:39 <povman> or library
20:30:40 <Cale> timthelion: But if you look at specific programs, then it's a different story :)
20:30:51 <lament> if every programmer optimized their code, then overall code quality would be much lower than it is now, leading to even poorer maintainability, leading to buggier and less featureful software, leading to fewer people using computers
20:31:12 <povman> my computer takes a couple of minutes from power-on until it's fully usable, but i continue doing that every day
20:32:31 <timthelion> povman: Well this quarter, I stopped.  I can't wait 2 minutes at the start of class, my professor is talking when I walk in.  But I can't keep my computer on througghout the day because of lack of battery life.  I just plain stopped taking notes, and I bulishit the exam essays and get a better score with google than I did with notes.
20:32:35 <ivan> people who really worry about startup times keep applications running and never reboot
20:32:59 <timthelion> ivan: But then the entire computer slows down.
20:33:04 <ivan> how so?
20:33:11 <timthelion> Well I'm using an olpc
20:33:14 <lispy> This isn't really Haskell related is it?
20:33:22 <ivan> oh, yeah, i don't use mobile computers of any sort for these reasons
20:34:01 <timthelion> ivan: I go to school.
20:34:08 <lament> timthelion: Or you could be like normal people and take notes with a pen
20:34:16 <timthelion> lispy: neither is your screen name.
20:35:12 <lispy> You're welcome to take this discussion to #haskell-blah or #haskell-overflow, but I think the majority of people here would prefer to stick to the subject of Haskell :)
20:35:45 <timthelion> wow wow wow there.  lament!  You fail to realise that I'm dissabled, there is something wrong with my brain, and it's very hard for me to write.
20:36:06 <timthelion> lament: I can't sequence complex movement and think at the same time.
20:36:45 <timthelion> lament: so no, I can't just be like normal people.  I wish.
20:37:30 <shapr> timthelion: Erm, this channel is about Haskell.
20:37:41 <shapr> But if you want to talk about off-topic stuff, you can talk on #haskell-blah
20:38:09 <povman> i think the point was that 2 seconds startup time doesn't matter. i regularly wait 2 seconds for a program to load, eg safari or textmate
20:38:22 <povman> after that everything's lightning fast
20:38:33 <lispy> povman: -> #haskell-blah please :)
20:38:53 <povman> i meant about his program, but yessir!
20:41:35 <shapr> So like, I heard this language Haskell is really cool!
20:41:47 <shapr> povman: When did you start learning Haskell?
20:43:11 <dons> ?users
20:43:12 <lambdabot> Maximum users seen in #haskell: 552, currently: 472 (85.5%), active: 15 (3.2%)
20:43:27 <povman> shapr: my interest in haskell started ... 5ish years ago, but only in the last 2-3 years have been really using it properly
20:43:38 <shapr> What do you do with Haskell?
20:44:07 <povman> currently building an insane drawing program
20:44:33 <lispy> povman: instain mother of a drawing program?
20:44:34 <shapr> ooh neat, got any source online? or screenshots?
20:44:50 <povman> it's really really really really pre-alpha
20:45:00 <lispy> release early and often :)
20:45:12 <povman> ie i have a couple of prototypes trying to nut out difficult functionality
20:45:21 <dons> povman: sounds cool. cairo + gtk?
20:45:25 <lispy> povman: is it related to POV?
20:45:39 <lispy> the ray tracer I mean
20:46:09 <shapr> Yeah, I wanna see it!
20:46:09 <povman> lispy: i can't release any details yet because it's such a cool idea
20:46:15 <shapr> oh
20:46:16 <shapr> too bad :-(
20:46:18 <povman> dons: SDL + opengl
20:46:33 <povman> lispy: no. pov in povman stands for poverty... don't ask. really.
20:47:02 <lispy> ?faq can povman build a cool drawing app in Haskell?
20:47:02 <lambdabot> The answer is: Yes! Haskell can do that.
20:47:07 <lispy> sweet!
20:47:09 <povman> whoa!
20:47:13 <povman> how encouraging
20:47:18 <povman> suffice to say it'll be multiplayer
20:47:21 <dons> cool.
20:47:31 <dons> lambdabot is prescient
20:47:55 <dons> so many copies of RWH seem to have arrived today.
20:47:58 <dons> anyone here got one?
20:48:12 * vegai checks mail
20:48:17 <dons> i wonder how amazon decided who got what first
20:48:32 <vegai> nope, not even coming my way yet
20:48:34 <shapr> dons: Authors first?
20:48:43 <vegai> I only ordered it a couple of weeks ago
20:48:46 <dons> non-authors too.
20:48:55 <vegai> it's LIFO?
20:49:04 <dons> probably FIFO?
20:49:28 <dons> some people sent photos of theirs arriving, http://www.realworldhaskell.org/blog/2008/11/26/amazon-orders-now-arriving/
20:49:35 <lispy> dons: I was thinking I'd put it on my christmas list and see if I get lucky :)
20:49:40 <lambdabot> Title: Real World Haskell » Blog Archive » Amazon orders now arriving, http://tinyurl.com/6lh2dx
20:49:54 <dons> i'd like to see more of this .. its super amazing to think of haskell flying all over the world
20:49:57 <vegai> oh dear, yes.
20:50:08 <povman> oh rwh
20:50:15 <dons> shapr: they're arriving in boston already
20:50:18 <lispy> Earth! Wind!  Fire! Water!  HASKELL!!!
20:50:21 <shapr> dons: ooh!
20:50:25 <lispy> Captain Haskell!
20:50:32 <povman> someone tell me why i should buy that book
20:50:34 <ddarius> dons: The Haskell community is rather international.
20:50:55 <dons> it is.
20:50:57 <shapr> povman: You don't have to buy the book, you can read it online for free.
20:51:01 <lispy> povman: because it's well written and it's free online so you can decide for yourself if a deadtree version is worth it
20:51:10 <dons> povman: you want to write serious software in haskell i guess?
20:51:12 <ddarius> povman: I have no intention of buying it, but then I have no need to.
20:51:12 <shapr> povman: Personally, I want to write in the margins.
20:51:16 <dons> hehe
20:52:14 <dons> povman: you don't seriously want more java books in the world...
20:52:54 <ddarius> dons: When Ragnarok comes, they can be used as kindling.
20:53:00 <Cale> Every sale of RWH prevents a terrible Java book from being written.
20:53:02 <doublec> i got an email saying my copy had been shipped
20:53:07 <dons> doublec: woo!
20:53:11 <povman> i don't see the point in most java books either, usually looking at the API and debugging error messages does the trick
20:53:48 <dons> yeah, how many other books on transactional memory, parallel strategies, monoids, functors and bloom filters are there?
20:53:52 <dons> and you get finger trees for free.
20:53:56 <shapr> Um, none?
20:54:04 <dons> i guess so?
20:54:31 <Cale> dons: You should have thrown in a sentence or two on the nature of consciousness, just so that you could include it in that list. ;)
20:54:34 <dons> hehe
20:54:42 <dons> life, bloomfilters and everything
20:54:56 <povman> hum maybe
20:54:57 <shapr> yeah!
20:55:09 <povman> maybe i'm a sucky programmer in descize!
20:55:51 <shapr> disguise?
20:55:56 <vegai> if it will be a classic, it'll sell for $200 in 10 years
20:56:08 <Cale> desk size?
20:56:09 <povman> i was speaking 'lojban'
20:56:10 <vegai> so, better buy 10
20:56:13 <shapr> oh
20:56:15 <mjonsson> what is the status of bytestring-lexing now? It doesn't build for me on 6.8 and hackage suggests it doesn't build on 6.8 and 6.10
20:56:18 <lispy> it will be the last book o'reilly has to make
20:56:25 <dons> mjonsson: should build fine with both
20:56:26 <povman> where 'lojban' means 'bad english'
20:56:31 <dons> mjonsson: i'd welcome a bug report...
20:56:49 <dons> $ cabal install bytestring-lexing
20:56:52 <shapr> hej magnus
20:56:57 <mjonsson> tja shapr
20:57:02 <dons> Registering bytestring-lexing-0.2...
20:57:05 <dons> done. seems fine.
20:57:13 <dons> cabal++
20:57:16 <mjonsson> dons: ./Setup.lhs build is the step that fails for me
20:57:29 <mjonsson> dons: the failure is the same as on http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-lexing
20:57:32 <lambdabot> Title: HackageDB: bytestring-lexing-0.2, http://tinyurl.com/5ppmod
20:58:14 <dons> ah!
20:58:20 <dons> you need to update the latest alex
20:58:31 <dons> which adds the ability to parse strict bytestrings
20:58:51 <dons> i'd forgotten about that
20:59:08 <mjonsson> from darcs? alex-2.2 is the latest version with a source distribution
20:59:39 <dons> mmm.
20:59:47 <dons> i wonder if my patches are only in the head branch
20:59:52 <mjonsson> okay, i'll see if I can do that
20:59:54 <mib_sb1jx5> what is lexical and lexing in a nutshell?
21:00:16 <mjonsson> due to restrictions at work I can't access the net from the machine where my haskell code lives
21:00:25 <shapr> ouch
21:00:28 <lexlex> n00b alert
21:00:42 <shapr> lexlex: Hey, we're all n00bs at some point.
21:00:43 <povman> BEEP BEEP BEEP BEEP
21:00:53 <shapr> mib_sb1jx5: http://en.wikipedia.org/wiki/Lexing
21:00:54 <lambdabot> Title: Lexical analysis - Wikipedia, the free encyclopedia
21:01:04 <shapr> mib_sb1jx5: That's a decent explanation.
21:01:30 <dons> mib_sb1jx5: constructing data by inspecting strings?
21:01:35 <lexlex> is there a haskell primitive to translate a string decimal representation of an integer into Int ?
21:01:43 <dons> well, function
21:01:47 <dons> we don't have many primitives
21:01:51 <shapr> lexlex: Read?
21:01:52 <dons> > read "123" :: Int
21:01:54 <lambdabot>   123
21:02:13 <lexlex> brilliant!
21:02:21 <lexlex> 谢谢
21:02:37 <dolio> Lexing is what you used to do before people invented parser combinators, and decided that it was just part of the parser.
21:03:27 <dons> heh. yes.
21:04:43 <shapr> mib_sb1jx5: Does that help?
21:06:01 <dons> "Anyone read the beta of "RealWorldHaskell"? Any good? Maybe it will be my 2009 new language
21:06:04 <dons> instead of Groovy or Clojure?"
21:06:05 <dons> seen on twitter.
21:06:17 <dons> its kinda weird to be compared to some new toy languages, imo. but hey.
21:06:41 <dons> people have weird ideas
21:06:45 <badsheepy> ooh now thats a bit mean :p
21:07:01 <joed> What is Clojure? Groovy is a pretty sad perl for JVM, never heard of Clojure...
21:07:10 <dons> lisp on jvm
21:07:20 <shapr> badsheepy: Well, Haskell is fifteen years old, I can understand it.
21:07:30 <ddarius> dons: Clojure is what's popular now.  I don't know how Groovy got in there.
21:07:41 <Korollary> Clojure is popular?
21:07:47 <badsheepy> when it was 1 year old was it a toy?
21:07:56 <joed> Oh, (I guess(that) will detract (the ( Java crowd)))))
21:07:56 <ddarius> Korollary: New popular, not actually popular
21:08:03 <mib_sb1jx5> yes
21:08:05 <dons> buzz popular (i.e. he gave a talk)
21:08:07 <dolio> Groovy is old. People were comparing Ruby to it back before Ruby got really popular.
21:08:08 <ddarius> badsheepy: Probably.
21:08:13 <shapr> mib_sb1jx5: Got any more questions?
21:08:17 <mib_sb1jx5> so when perl does a regex or I grep im lexing in a way
21:08:23 <dons> mib_sb1jx5: yes!
21:08:25 <dons> exactly
21:08:33 <dons> regexes are often the basis of lexing
21:08:36 <joed> dolio: Ruby is over 12 years old and Groovy barely has a book?
21:08:37 <dons> identifying token sequences
21:08:57 <badsheepy> given the initial learning curve of haskell, some bad people could claim it was less a toy than a puzzle :)
21:09:04 <dons> hands up if you have 500 people in your irc channel. 1000 libraries and a commercial users group. ... 'nuf said.
21:09:17 <dolio> joed: Yeah, well, Groovy was "hey, a less shitty language for the JVM", so it had (has?) its advocates.
21:09:53 <MikeMayer> hello everyone... wow I have to learn enough haskell to solve eight problems before 11:45pm friday
21:09:55 <mib_sb1jx5> yes
21:09:57 <dons> yay!
21:09:58 <dons> go MikeMayer
21:10:00 <MikeMayer> any advice?
21:10:03 <dons> do it!
21:10:06 <ddarius> dolio: It's less shitty than Java in some ways, more in others, and more shitty than most other alternative languages for the JVM.
21:10:15 <dons> MikeMayer: you have ghc installed?
21:10:25 <joed> dolio: Heh, as I make my living coding Java, it is a strongly typed C like language that is overly verbose, most of the time I get it to do what I need, if not I write a lib.
21:10:30 <MikeMayer> dons:  yes sir
21:10:41 <dons> MikeMayer: sweet. and cabal-install? (that's good for getting hold of libraries)
21:11:27 <MikeMayer> dons:  never heard of it... I'll get it- however, I don't think I can use anything aside from prelude for my assignment
21:11:37 <dons> ah ok.
21:11:43 <dolio> ddarius: Well, there are a lot more well known alternatives these days than there were a few years ago.
21:11:45 <dons> well, you're set now. all that's left is thinking and typing.
21:12:41 <MikeMayer> somewhere in the thinking and typing process I'll have to learn the syntax :)
21:12:55 <dons> ah well. syntax is ... just syntax. it's superficial
21:12:58 <dons> :)
21:13:04 <dons> shapr, seen on rwh blog "1 C Smith
21:13:04 <dons> Got mine today.
21:13:05 <dons> Mwahahahahahah."
21:13:11 <dons> rwh freaks.
21:13:12 <dons> :)
21:13:13 <shapr> hah
21:13:35 <MikeMayer> dons: lol-- well I'm glad to see haskell has so much support... I wouldn't have guessed it so
21:13:36 <shapr> dons: It's good stuff, I want to mainline that academic purity brought to reality! w00!
21:13:47 <dolio> lol++
21:13:52 <dons> MikeMayer: oh? i wonder how we could change haskell.org to give a better impression?
21:13:59 <dons> shapr: exactly.
21:14:46 <dons> MikeMayer: we're kinda buzzed around here. o'reilly just published a big ole book about haskell.
21:14:52 <dons> so its a fine time to get started.
21:15:04 <MikeMayer> dons: the site is really good actually... I really was implicating how it is used for two weeks in the strive to get a cs degree
21:15:18 <MikeMayer> dons: oh very good
21:15:22 <dons> ah that's a pity. if only it was say .. required for the first 4 years :)
21:15:41 <dons> MikeMayer: what uni are you at?
21:15:57 <MikeMayer> dons: UC Irvine
21:16:14 <dons> mm. who's teaching the course?
21:16:17 <dons> i wonder if we know them
21:16:36 <ksf> haskell's syntax is as easy as perls, but instead of feeding it braindumps, you gotta feed it mathematical papers.
21:16:44 <dons> hehe
21:16:48 <MikeMayer> lol
21:17:01 <dons> i  think people are more comfortable with diverse syntax now. new languages are all over the place syntax wise.
21:17:12 <dons> ruby /= python /= perl /= C++ /= erlang /= haskell /= ocaml.
21:17:52 <lament> those aren't languages (except for c++). Those are scripts!
21:18:04 <MikeMayer> dons: Shannon Tauro
21:18:12 <lament> they're scripts because they don't have enough curly braces and semicolons.
21:18:22 <dons> mm. not sure i know him. good to see haskell at UC Irivine though.
21:18:40 <MikeMayer> dons: I doubt you know her... she's pretty young
21:18:43 <MikeMayer> :)
21:19:02 <dons> hey, i'm pretty young!
21:19:37 <joed> Like 29?
21:19:44 <dons> not even...
21:19:50 <joed> Yeah...
21:19:55 <MikeMayer> oh wasn't implying anything other than she isn't likely big in the haskell community
21:20:06 <dons> MikeMayer: ah i see. she's into embedded systems stuff?
21:20:19 <dons> a lot of the languages community hangs out here, or we know them , but obvious not everyone :)
21:20:25 <MikeMayer> dons: indeed
21:20:30 <MikeMayer> I see
21:20:55 <dons> well, feel free to ask for help. we can assist. but ultimately it's you and ghc versus the world!
21:20:59 <shapr> Where's her publications?
21:21:59 <MikeMayer> shapr: good question...
21:22:01 <dons> google turns some up.
21:22:39 <dons> interesting , http://imonad.com/
21:22:44 <lambdabot> Title: iMonad Software
21:25:25 <setuid_w00t> I'm running into some problems with my solution to a SOE exercise.  Specifically, it seems like my containsS function doesn't work correctly because my isLeftOf function isn't behaving.
21:25:43 <setuid_w00t> Code here: http://hpaste.org/12420
21:26:25 <ksf> or [undefined,True] should spark two threads and return true.
21:26:31 <ksf> I'm daydreaming again.
21:27:53 <ksf> coroutines ftw. gotta implement them sometime.
21:27:56 <dons> ksf?
21:27:58 <dons> sparks yay
21:29:10 <setuid_w00t> The implementation of isLeftOf is exactly the same as the one in the book
21:32:19 <Cale> setuid_w00t: What seems to be wrong with it?
21:32:44 <setuid_w00t> Cale: in the pasted code, test is False
21:32:48 <Cale> mhm
21:33:26 <Cale> setuid_w00t: (0,0) is to the right of that ray.
21:34:03 <Cale> Check that   isLeftOf (0,0) ((1,-1),(1,1))  gives True
21:35:06 <setuid_w00t> Cale: It does
21:35:21 <u_quark1> is there a way to export a function with a different name ?
21:35:59 <setuid_w00t> u_quark1: Can't you just do:   newName = oldName and then export newName?
21:36:13 <ksf> if you wanna export foo as bar, just say bar=foo and export bar
21:36:20 <setuid_w00t> <-- wins  :)
21:36:40 <ddarius> @google hpaste ddarius coroutines
21:36:43 <lambdabot> No Result Found.
21:37:16 <ksf> setuid_w00t, only unamortised. I'm task-switching.
21:37:26 <u_quark1> :) well I am coding something like a wrapper and I don't want to qualify every function I use internaly from the other imported package
21:37:55 <u_quark1> and of course I want to export it with the same name...
21:38:22 <ksf> you're aware of import ModuleThatHasALongName as WTF?
21:38:38 <ksf> so you can go WTF.bar instead of Modu....LongName.bar
21:38:45 <u_quark1> yes yes but I don't want to qualify at all :P
21:38:54 <qebab> u_quark1: be less lazy
21:39:17 <Cale> setuid_w00t: So you'll have to be careful about your polygons, if you arrange the points in the wrong order, you'll get everything outside the polygon.
21:39:50 <u_quark1> I thought haskellers know better on that matter ... lazyness is the essence of programming :P
21:40:39 <ksf> nah, data flow is.
21:40:48 <setuid_w00t> Cale: Well the book says that they have to be in clockwise order, but that doesn't always work.
21:41:09 <Cale> Have an example of it failing?
21:41:26 <setuid_w00t> Cale: let me paste is
21:44:30 <setuid_w00t> let p = Polygon [(1,1), (1,-1), (-1,-1), (-1,1)]
21:44:41 <setuid_w00t> p `containsS` (0,0)
21:44:46 <setuid_w00t> That gives false in ghci
21:47:23 <Cale> reverse the list
21:49:31 <Cale> You're taking the intersection of 4 half-planes which are the opposites of the half-planes which you want, and the intersection turns out to be empty.
21:49:53 <travisbrady> is there any way around the "Occurs check: cannot construct the infinite type" when dealing with an action? i have a case where I'd use a while loop in python
21:50:06 <Cale> travisbrady: You're probably doing something strange.
21:50:17 <Cale> travisbrady: That's usually a very genuine type error.
21:50:37 <travisbrady> Cale: i am yeah, what i'm trying to do is build up a list. and i'd do this in a while loop in python
21:50:43 <Cale> travisbrady: you're seeing something like  t = IO t  ?
21:51:00 <Cale> travisbrady: What list are you trying to build?
21:51:07 <travisbrady> i need to do this in a do block because in some instances i'll need to generate random numbers via randomRIO
21:51:16 <Cale> Well, "need"
21:51:19 <travisbrady> Cale: are you familiar with greedy crossover?
21:51:23 <Cale> You could also pass around a StdGen
21:51:54 <travisbrady> my action takes to tours and yields a 3rd which is the result of greedy crossover
21:52:36 <setuid_w00t> Cale: I think I figured it out.  I believe "clockwise" was meant in the context of the graphics display where the origin is top-left, and positive Y goes towards the bottom of the screen.
21:52:37 <Cale> Which infinite type is it attempting to construct?
21:52:39 <travisbrady> Cale: wouldn't i still have to do that in an action though?  if i'm passing a StdGen that is
21:52:59 <Cale> travisbrady: No, you would have a plain function with StdGen as one of the parameters.
21:53:04 <Cale> (and maybe one of the results)
21:53:43 <travisbrady> Cale: a = [a]
21:53:58 <Cale> travisbrady: aha, that means you're trying to use a list as one of its own elements
21:55:02 <travisbrady> Cale: i've just pasted the hideous code here: http://hpaste.org/12421
21:56:06 <ksf> setuid_w00t, you don't need to know where the origin is to discern clockwise and anti-clockwise
21:56:28 <ksf> as, to put it simply, the poly could be off-screen.
21:57:19 <Cale> travisbrady: it appears that something is messed up?
21:57:24 <Cale> guard (mnext==dnext && mnext `notElem` acc) return (greedyCross distMap mom dad mnext:acc)
21:57:31 <Cale> guard doesn't take 3 parameters...
21:57:50 <setuid_w00t> ksf: I had the direction of the Y axis mixed up in my head, so when I had two points that were vertically aligned, I was specifying them in the wrong order.
21:57:55 <Cale> and if that's just a missing newline, return in the middle of a do-block doesn't do anything
21:58:39 <travisbrady> Cale: ahh, i misunderstood guard, i was hoping i could emulate a guard in a function
21:59:13 <ksf> bottom-left origin is atrocious, anyway.
21:59:14 <Cale> travisbrady: What is this line meant to do?
21:59:16 <travisbrady> removing it i still get the same error, but i think this just needs to be completely rewritten
21:59:41 <Cale> I get
21:59:45 <Cale> Occurs check: cannot construct the infinite type: a = [a] -> [a]
21:59:57 <Cale> after removing that one
22:00:08 <Cale> It's because of: return (greedyCross distMap mom dad mnext:acc)
22:00:15 <travisbrady> Cale: well, i'm building this list using the elements from either mom or dad and so in the case where the elements i've chosen from mom and dad are equal i just return the one from mom
22:00:27 <ksf> it's a pile of moose droppings invoking painful memories of teachers not giving you full points for missing "x" and "y" axis labes on your diagrams.
22:00:37 <Cale> you're aware that parses as:
22:00:43 <Cale> return ((greedyCross distMap mom dad mnext):acc)
22:01:23 <travisbrady> Cale: oooohhh, i often get confused by the fixity rules and end up using parentheses too much
22:01:43 <Cale> In this case, too little, perhaps
22:02:01 <Cale> But that doesn't fix the problem... it just changes it...
22:02:21 <Cale> Maybe you don't want the return at all.
22:02:39 <Cale> after all, it seems like you don't want the result to be another action
22:03:01 <Cale> after removing the returns, it typechecks
22:03:52 <Cale> hmm,  return reverse acc
22:03:56 <Cale> that can't be right.
22:04:21 <Cale> (though it typechecks, in the function monad)
22:04:29 <travisbrady> can you give me an example of passing the StdGen into a pure function?
22:04:33 <Cale> sure
22:04:49 <ksf> function monad?
22:05:04 <Cale> ksf: Remind me to explain in a bit :)
22:05:24 <Cale> I'm just going to whip up a short example.
22:05:37 <ivanm> Cale: another instant  tutorial? :p
22:05:44 <travisbrady> oh wow, i rm'd the returns and it DOES typecheck.  but i'm in a do block, i am confused
22:06:10 <ksf> return does'nt return anything, it injects a value into a monad.
22:06:29 <ksf> if you already got a monadic value, return isn't what you want.
22:06:45 <ksf> it should, actually, be called "pure" or something.
22:06:58 <ksf> "inject" sound good.
22:07:27 <StoneToad> ksf: shootup?
22:07:50 <ksf> cale's beloved function monad handles the returning for you, and he'd be eager to explain ;)
22:08:49 <Cale> I'd normally prefer to say that (return v) is the action which does nothing and returns v.
22:08:53 <Cale> (in this context)
22:09:23 <ksf> in my humble terminology, no action actually does anything.
22:09:40 <Cale> ksf: hm?
22:09:45 <ksf> it's a real misnomer if you aren't working inside IO
22:10:07 <Cale> ksf: You can always come up with a meaning for doing.
22:10:28 <Cale> For instance, in the list monad, executing a list means to pick an element from it in all possible ways,
22:10:59 <Cale> and in the function monad, executing a function means to apply it to the parameter which is passed in to the whole computation
22:11:33 <ksf> there we got it.
22:12:02 <ksf> to me, "function monad" means the thing that specifies the reduction strategy, not appy.
22:12:05 <ksf> *apply
22:12:29 <travisbrady> the function monad, i had never heard of such a thing
22:12:34 <Cale> http://hpaste.org/12422
22:12:37 <ksf> *evaluation strategy if you want, fwiw.
22:12:56 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
22:12:57 <lambdabot>   ("hello","olleh","HELLO")
22:12:59 <Cale> ^^ this monad.
22:13:13 <Cale> Specifically, the (->) e monad, for any given e.
22:13:50 <Cale> It doesn't specify the reduction strategy.
22:14:03 <RayNbow> > let f = sequence [(+1), (*5)]  in  f 3
22:14:04 <lambdabot>   [4,15]
22:14:21 <Raevel> i have this function, why are the pattern matches non-exhaustive? f :: Int -> Int; f 0 = 0; f n | n < 0 = undefined; f (n+1) = n
22:14:33 <travisbrady> Cale: that seems sort of like &&&, but i should probably shut up before i say something stupid(er)
22:15:08 <Cale> Well, that would be the function Arrow
22:15:12 <Cale> But it's not unrelated.
22:15:22 <RayNbow> (->) is like Reader, just without the newtype
22:15:31 <ksf> n+1 patterns are evil.
22:15:46 <Raevel> oh?
22:15:52 <Cale> travisbrady: Did you look at my paste showing how to use a StdGen to get results?
22:16:01 <ksf> there should be -Xno-nk-patterns
22:16:31 <travisbrady> Cale: looking now
22:16:31 <Raevel> ksf: why do you say they're evil?
22:16:49 <RayNbow> @google haskell n+k patterns evil
22:16:58 <lambdabot> http://neilbartlett.name/blog/categories/haskell/
22:16:58 <lambdabot> Title: Neil’s point-free blog » Haskell
22:17:42 <RayNbow> http://www.mail-archive.com/haskell@haskell.org/msg01261.html
22:17:43 <lambdabot> Title: n+k patterns
22:17:52 <travisbrady> Cale: what is the significance of the ' in haskell? is it just a convenience?  is it special in some way?
22:18:02 <Cale> travisbrady: it's just conventional
22:18:05 <RayNbow> > let a' = 3 in a'
22:18:07 <lambdabot>   3
22:18:32 <doctormach> I'm trying to use the cabal command line utility to install packages but it  just keeps running and using more memory until I kill it
22:19:05 <doctormach> I think this started when I installed ghc 6.10.  Is there some incompatibility between cabal and ghc 6.10?
22:19:13 <ksf> http://www.haskell.org/haskellwiki/Things_to_avoid#n.2Bk_patterns
22:19:21 <lambdabot> Title: Haskell programming tips - HaskellWiki
22:19:22 <Cale> Usually means that one variable is related to another in an unspecified way
22:20:49 <Raevel> okay fair enough, guess i'll go litter my code with n-1's !
22:20:54 <dons> doctormach: hmm.
22:21:07 <dons> doctormach: try upgrading to a new cabal-install
22:21:09 <dons> 0.6.x
22:21:23 <dons> should work fine.
22:24:31 <MikeMayer> I'm having a tough time getting started with haskell- not sure what I'm not getting either
22:24:54 <ksf> monads.
22:25:09 <ksf> call by name, maybe.
22:25:10 <dons> hmm. so got hello world working?
22:25:16 <ksf> most likely laziness.
22:25:27 <ksf> did i mention monads?
22:25:45 <dons> $ cat A.hs
22:25:45 <dons> main = print "hello, world"
22:25:50 <dons> $ ghc -O --make A.hs
22:25:50 <dons> [1 of 1] Compiling Main             ( A.hs, A.o )
22:25:50 <dons> Linking A ...
22:25:50 <MikeMayer> hello world is as simple as:   main = print "hello world"
22:25:53 <dons> yup
22:25:56 <MikeMayer> yeah got that
22:26:00 <dons> ok. so where are you stuck?
22:26:13 <MikeMayer> I've got to write a function that takes a list and a number- appends the number to the list then sorts it
22:26:16 <ddarius> That will print "hello world" with the quotes.
22:26:19 <doctormach> dons: That fixed it, thanks
22:26:21 <MikeMayer> sounds simple enough
22:26:29 <dons> MikeMayer: ok. should be easy
22:26:33 <dons> so what's the type of that function?
22:26:42 <mlesniak> Anyone has some rough estimation about the shipping times from oreilly usa to germany? (My RWH is currently at Philadephia).
22:26:52 <Lemmih> dons: -O? Because Hello World is just too slow with it?
22:26:55 <dons> mlesniak: hmm. < 1 week?
22:27:01 <MikeMayer> I made it:   insert :: [Int] -> Int -> [Int]
22:27:01 <dons> Lemmih: just good to remember :)
22:27:03 <mlesniak> dons, thanks, sounds good :)
22:27:23 <dons> MikeMayer: looks good. probably could be more polymorphic (i.e. it'll work for any type, not just Int), but good start
22:27:31 <dons> ok. so how do you append the 2nd arg to the list?
22:27:36 <dons> append or prepend, btw?
22:28:10 <dons> mlesniak: i got a packet of chocolate from ecuador in 1 week. so east coast to germany should be fast. amazon probably has tracking numbers too.
22:28:14 <MikeMayer> well I'm not sure how to do that really
22:28:16 <dons> mlesniak: send me a photo when it arrives.
22:28:23 <dons> MikeMayer: so do you know the operations on lists?
22:28:26 <dons> ?docs Data.List
22:28:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
22:28:29 <MikeMayer> I've understood that colon is the correct operator
22:28:39 <dons> that's the 'cons' operator, yes.
22:28:43 <dons> :t (:)
22:28:44 <lambdabot> forall a. a -> [a] -> [a]
22:28:54 <dons> takes a value and a list, and prepends
22:28:59 <ksf> you can't append with it.
22:29:02 <dons> > 'X' : "foo"
22:29:04 <lambdabot>   "Xfoo"
22:29:15 <dons> and then you can do things with the result.
22:29:22 <MikeMayer> I suppose since I need to sort the list it doesn't matter if its prepended or appended
22:29:22 <dons> > reverse ('X' : "foo")
22:29:24 <lambdabot>   "oofX"
22:29:32 <ksf> > "Xfo" ++ ['X']
22:29:33 <lambdabot>   "XfoX"
22:29:40 <mlesniak> dons, yeah, read about the photos on haskell-cafe and will of course send a photo :D
22:29:43 <dons> yes, so ksf points out there is also (++)
22:29:45 <RayNbow> mlesniak: shipping times really depend on the shipping method
22:29:47 <dons> for joining two lists.
22:29:52 <dons> mlesniak: yay!
22:29:58 <dons> > "foo" ++ "bar"
22:29:59 <lambdabot>   "foobar"
22:30:04 <dons> MikeMayer: so making progress ?
22:30:11 <mlesniak> RayNbow, Service: Express (Whatever that means ;))
22:30:14 <dons> do you have to write your own sort, or use the library one?
22:30:18 <RayNbow> no idea :p
22:30:32 <ksf> :t sort
22:30:33 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:30:34 <MikeMayer> dons: they want us to use as much library stuff as possible
22:30:40 <dons> ?index sort
22:30:40 <lambdabot> Data.List
22:30:41 <RayNbow> I only know that priority airmail from Florida to the Netherlands usually took 1-2 weeks
22:30:46 <dons> i'd use Data.List.sort  then :)
22:30:52 <MikeMayer> for sure
22:31:13 <dons> ok. so anything missing? you can see how to add an element, and how to sort a list
22:31:22 <dons> do you know how to define a new function?
22:31:32 <dons> ?let f x y = x + y
22:31:32 <MikeMayer> eh I think I'm misunderstanding a fundamental with the syntax
22:31:33 <lambdabot>  Defined.
22:31:34 <dons> > f 1 2
22:31:35 <lambdabot>       Ambiguous occurrence `f'
22:31:35 <lambdabot>      It could refer to either `L.f', defined a...
22:31:38 <dons> ?undefine
22:31:40 <dons> ?let f x y = x + y
22:31:41 <lambdabot>  Defined.
22:31:43 <dons> > f 1 2
22:31:44 <lambdabot>       Ambiguous occurrence `f'
22:31:44 <lambdabot>      It could refer to either `L.f', defined a...
22:31:46 <dons> bah
22:31:47 <ksf> > let as e l = sort e:l in as 4 [1, 2, 10, 3]
22:31:48 <lambdabot>       No instance for (Num [a])
22:31:48 <lambdabot>        arising from the literal `4' at <inter...
22:31:51 <dons> ?let fooob x y = x + y
22:31:52 <lambdabot>  Defined.
22:31:56 <dons> > fooob 1 2
22:31:58 <lambdabot>   3
22:32:07 <dons> MikeMayer: hmm. so what part is troubling?
22:32:15 <dons> we use whitespace for function application. not ( )
22:32:18 <ksf> > let as e l = sort (e:l) in as 4 [1, 2, 10, 3]
22:32:18 <dons> so: foo 1
22:32:19 <lambdabot>   [1,2,3,4,10]
22:32:21 <dons> instead of foo(1)
22:32:23 <travisbrady> MikeMayer: i have had many of the same issues, for a long time my eyes missed parens
22:32:33 <ksf> @pl let as e l = sort (e:l) in as 4 [1, 2, 10, 3]
22:32:33 <lambdabot> sort [4, 1, 2, 10, 3]
22:32:38 <ksf> grrrr
22:32:52 <dons> MikeMayer: what reference are you using?
22:33:02 <ksf> @pl \as e l -> sort (e:l)
22:33:03 <lambdabot> const ((sort .) . (:))
22:33:09 <dons> heh
22:33:25 <MikeMayer> :dons various websites... no book
22:33:35 <romand> http://hpaste.org/12423 - what I'm doing wrong?
22:33:40 <ksf> > const ((sort .) . (:)) $ 4 [1, 2, 10, 3]
22:33:41 <lambdabot>       Overlapping instances for Show (a -> [a] -> [a])
22:33:41 <lambdabot>        arising from a ...
22:33:45 <dons> MikeMayer: well there are lots of intro books if you want one.
22:33:48 <ksf> > const ((sort .) . (:)) 4 [1, 2, 10, 3]
22:33:49 <lambdabot>       Overlapping instances for Show ([[t]] -> [[t]])
22:33:49 <lambdabot>        arising from a u...
22:33:51 <ksf> huh?
22:33:55 <dons> probably your library has 'craft of functional programming' for example
22:34:04 <dons> ksf: yeah, they broke it
22:34:12 <MikeMayer> :dons I'll check it out
22:34:26 * RayNbow finds it interesting that people miss the parentheses/commas in Haskell for function application while copying a file at the shell uses the same style, i.e. "cp path1 path2" (or "copy path1 path2" depending on OS)
22:34:40 <dons> RayNbow: good point.
22:34:45 <dons> its just like the shell. easy
22:34:54 <dons> with . instead of |
22:34:57 <ksf> shell is call-by-name, too.
22:35:12 <dons> | is lazy.
22:35:15 <ddarius> TeX is too.
22:35:37 <dons> ksf, i doubt name/need will bother anyone
22:35:52 <ksf> yeah, but people actually coding in tex should be quite rare.
22:36:53 <travisbrady> MikeMayer: what language are you coming from?
22:37:18 <MikeMayer> :travisbrady all sorts of imperative languages
22:37:31 <MikeMayer> :travisbrady c derivatives mostly
22:37:44 <dons> MikeMayer: so do you know how to make progress  with your exercises?
22:38:11 <MikeMayer> :dons getting "parse error on input `'let`'
22:38:32 <MikeMayer> I'm sure once I get past this hump I'll be good :/
22:38:37 <travisbrady> MikeMayer: you only need 'let' if you're in a do block
22:38:55 <travisbrady> a normal function just looks like "funcname param1 param2 = param1*param2"
22:39:28 <ksf> @real
22:39:28 <lambdabot> Maybe you meant: keal read
22:39:32 <ksf> @where real
22:39:33 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
22:39:34 <ksf> ftw.
22:40:28 <ksf> perl doesn't really require parens either, does it?
22:40:42 <ksf> it's been a long time since i last used it.
22:40:55 <ksf> before the first p6 drafts, that is.
22:41:16 <dons> MikeMayer: oh, so 'let' is an expression. like if-then-else.
22:41:29 * Cale comes back from beating Portal.
22:42:20 <ksf> winter confuses the hell out of me.
22:42:45 * Lemmih hands Cale a piece of cake.
22:42:49 <Cale> :)
22:42:54 <dons> MikeMayer: http://hpaste.org/12424 for example
22:42:59 <dons> no 'let' needed for top level bindings
22:43:07 <shukhov> small question, can haskell output unicode? im trying to write a nice show function but its not outputing the chars right.
22:43:30 <ksf> getting up 4 to 5 hours before sundawn is just insane.
22:43:51 <Lemmih> shukhov: See utf8-string on hackage.
22:44:00 <dons> shukhov: yeah. use the utf8-string package on hackage.haskell.org
22:44:03 <Cale> ksf: I'm getting up 4 or 5 hours before sunset.
22:44:12 <dons> and replace, say, writeFile with System.IO.UTF8.writeFile
22:44:19 <shukhov> Lemmih, dons: thanks
22:44:25 <ksf> isn't that sundawn right now?
22:44:36 <dons> isn't sundawn == dawn?
22:44:47 <romand> what is the policy about repeating questions here?
22:44:54 <Cale> Here, it's 1:44 am. I got up around 3pm.
22:45:04 <Cale> romand: Not strict :)
22:45:19 <romand> http://hpaste.org/12423 - what I'm doing wrong?
22:45:30 * Cale has a look
22:45:41 <Lemmih> Kudos to hackage. We've managed to replace a bunch of code in LHC with 5 libraries from hackage.
22:45:44 <ksf> > repeat "question"
22:45:45 <lambdabot>   ["question","question","question","question","question","question","questio...
22:45:52 <dons> Lemmih: woot
22:45:56 <dons> Lemmih: worked for darcs too.
22:45:59 <Cale> romand: I don't think those \r's should be necessary.
22:46:07 <dons> Lemmih: different to the old days where we ripped code /out/ of apps to put on hackage
22:46:19 <romand> Cale: rfc says they are
22:48:07 <Lemmih> dons: We're looking at replacing LHC's haskell parser with haskell-src-exts (:
22:48:24 <doublec> romand, need a hFlush in there
22:48:31 <Lemmih> I wonder if LHC will be the first serious haskell compiler to use an off-the-shelf parser.
22:48:40 <romand> doublec: after writing?
22:48:43 <doublec> yes
22:48:59 <doublec> after the hPutStr
22:49:00 <Cale> romand: add an hFlush h before the hGetLine
22:49:11 <Cale> ah, someone beat me to it :)
22:49:14 <dons> Lemmih: that'd be interesting
22:49:15 <doublec> :)
22:49:21 <dons> Lemmih: surely lhc has a good parser already?
22:49:26 <romand> thanks, it works (:
22:49:41 <travisbrady> romand: i think you can use ByteString, which I prefer in every instance I've encountered
22:50:02 <ksf> better than flush, set LineBuffering.
22:50:03 <Lemmih> dons: It's not perfect. It can't parse the code for the 'pretty' library.
22:50:23 <ksf> you can safely use hGetContents, too.
22:51:03 <Cale> romand: Though if you're really going to be doing HTTP requests, use the HTTP library ;)
22:52:33 <ksf> it's 8 am, it's dawning, and something tells me that it's sunset.
22:53:00 <dons> Lemmih: ah ok.
22:53:09 <ksf> prolly the lcd's being vastly brighter than a cloudy winter day.
22:54:56 <jdrake> Can lhs use only \begin{code} or bird style, but not both?
22:58:58 <romand> ksf: there is a problem with hGetContents... it returns empty string for some reason...
22:59:25 <ksf> it's lazy.
22:59:43 <ksf> so it doesn't contain a thing before the other side sends stuff.
23:00:20 <ksf> you shouldn't hclose prematurely, either.
23:00:56 <romand> thanks, all works now
23:01:27 <ksf> did you try hSetBuffering LineBuffering?
23:01:51 <romand> no... how this should help?
23:02:08 <ksf> you don't need to hflush anymore, as the os does it by itself.
23:02:16 <jdrake> I have a function, details balance = (balance, iv, payment, closing), that I need to use as the basis for a list. But I need the 'closing' balance to be fed back into details and I am not sure how to do that. Full skeleton code can be provided.
23:02:37 <ksf> most if not all network protocols are designed to take advantage of line buffering, too.
23:02:57 <ksf> it's also the default mode for the telnet program.
23:03:14 <romand> cool...
23:03:24 <dons> http://wholesalebanking.standardchartered.com/en/mediacentre/pressreleases/Pages/08102008B.aspx
23:03:30 <lambdabot> Title: Standard Chartered Bank - Standard Chartered hires Lennart Augustsson to expand  ..., http://tinyurl.com/57jple
23:04:07 <romand> where should I look for async read/write routines for haskell?
23:04:38 <dons> for what kind of data?
23:04:39 <ksf> hgetcontents already is async...
23:04:47 <dons> yes.
23:05:00 <ksf> ...so you want a non-blocking write.
23:05:43 <romand> actually, I don't think write lock may significantly affect performance...
23:05:44 <ksf> but then write shouldn't block any longer than to pass data to the os, which should be fine in all cases.
23:06:41 <dons> romand: yeah, i'd just use System.IO, unless you have some special problem.
23:06:46 <dons> Data.ByteString. stuff
23:07:27 <ksf> but a hPutContents would be cool, just for kicks.
23:07:48 <romand> so, if I, for example, send some request to 10 sockets, get 10 answers with hGetContents and need to check them for some criteria
23:07:51 <ksf> actually, it's known as interact
23:07:54 <ksf> :t interact
23:07:55 <lambdabot> (String -> String) -> IO ()
23:08:05 <ksf> you can't get more async.
23:08:49 <ksf> if you want more than one connection, you want to thread.
23:09:29 <dons> romand: ah. yes. you want threads
23:09:43 <dons> you can wait on IO events. multiplex them. and do various other cool things
23:09:46 <ksf> haskell is really surprisingly painless for all this stuff.
23:10:02 <Giraffe> haskell is painless for most things :P
23:10:29 <mbz> ?src interact
23:10:29 <lambdabot> interact f = do s <- getContents; putStr (f s)
23:10:37 <Giraffe> jdrake, that's an interesting problem
23:10:39 <Giraffe> if you're still around
23:10:45 <jdrake> I am
23:10:48 <ksf> ...and if it isn't, you can always use the state monad.
23:10:54 <jdrake> Giraffe, I think I do have one method
23:10:59 <jdrake> It uses regular recursion
23:11:08 <jdrake> Sort of redefining the problem so to speak
23:11:21 <jdrake> I am basically trying to translate a spreadsheet into a haskell program that will generate a report
23:11:24 <Giraffe> well what is the meaning of: details balance = (balance, iv, payment, closing)
23:11:24 <romand> I've heard about haskell's 'lightweight' threads, but never benchmarked them... can't believe there is no way for event-based io in haskell...
23:11:37 <jdrake> Let me give you more of the code
23:11:42 <Giraffe> righto!
23:11:44 <Giraffe> just hpaste it
23:12:00 <jdrake> I am surrounded by people that shake their heads at my haskell usage.
23:12:15 <Giraffe> :(
23:12:16 <dons> romand: hmm? there is event based io.
23:12:18 <dons> via threads.
23:12:18 <Giraffe> why's that
23:12:31 <ksf> ...or without threads.
23:12:33 <mlesniak> jdrake, haskell shakes its head at my haskell usage which is worse ;)
23:12:48 <ksf> like simply by registering sdl callbacks.
23:12:57 <jdrake> Giraffe, http://hpaste.org/12426
23:13:05 <jdrake> You will find it closer to the bottom
23:13:17 <jdrake> I am starting to try to rationalize a solution to my problem
23:13:20 <dons> romand: often people use the orElse combinator from STM to combine waiting on multiple handles into a single action
23:13:26 <dons> to mulltiplex data. its a one liner.
23:13:35 <jdrake> What I am trying to haskellize is this: http://www.techsociety.ca/~jeffd/CreditCalculator.html
23:13:51 <ksf> are threads coroutines or are they scheduled?
23:14:02 <dons> scheduled.
23:14:08 <dons> we use preemptive concurrency.
23:14:18 <dons> the runtime gets to pick which cores to put them on
23:14:39 <dons> so we rock the multicore shootout, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
23:14:41 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
23:14:54 <Giraffe> jdrake, what's the problem with what you have...?
23:15:16 <jdrake> If I have thought of using details to recurse on itself, so that closing is referenceable.
23:16:03 <jdrake> Giraffe, in that spreadsheet you will note the rows. I am basically trying to make a function that takes the parameters required and reproduces that table (but stops when balance is <0).
23:16:20 <doctormach> Is there some way to tell Setup.hs to look for packages in a certain location?
23:16:27 <doctormach> I tried --package-db but I can't make it work
23:16:43 * ksf wishes his geForce 7600 GS could do CUDA
23:16:48 <dons> doctormach: add the package to your build-depends
23:16:56 <dons> ghc only knows about registered packages.
23:17:02 * jdrake pets his intel integrated graphics.
23:17:25 <doctormach> I installed them via cabal, how do I register them?
23:17:36 <Giraffe> jdrake, is interest in dollars?
23:17:43 <dons> doctormach: ah. you're probably just missing the --user flag
23:17:45 <jdrake> yes
23:17:47 <Giraffe> gotcha
23:17:48 <jdrake> All values there are dollars
23:17:53 <dons> there are two package caches. the global cache, and user-specific packages
23:17:59 <ksf> it's actually powerful enough to do general purpose programming, but you gotta do hacks as it isn't designed for it so nvidia didn't do CUDA for it and i got to use cg.
23:18:01 <dons> ghc-pkg list
23:18:04 <dons> will tell you everything
23:19:06 <Giraffe> hmm...
23:19:11 <Giraffe> jdrake, do you need to be able to reference each thing?
23:19:13 <jdrake> I am constantly amazed at the PC security industry. This 'A-Squared' anti-spyware program I am running on my father's windows box has 'Objects detected: 4' in bold red lettering when it is COOKIES.
23:19:29 <jdrake> Giraffe, I only need to be able to refer to the previous closing balance.
23:19:36 <ksf> I'd love to see a haskell rts that does jitting to both cpu and gpu.
23:19:49 <jdrake> Because the previous closing balance becomes the opening in the next cycle.
23:20:12 <Giraffe> because i would think if you just have a function that takes in a list of payments and interests and just runs it until you get to the empty lists, you'd be golden
23:20:15 <doctormach> dons: That fixed it, thanks again
23:20:18 <Giraffe> a fold, maybe?
23:20:22 <ksf> ...imagine using `par` on a beowolf cluster of ps3's.
23:20:58 <jdrake> Giraffe, I was considering a list of payments (preferably able to do an infinite list of the same payment as well).
23:20:59 <dons> ksf, why jit? just compile to cpu and pgu.
23:21:02 <dolio> @yow! Hot Grits!
23:21:02 <lambdabot> Are we THERE yet?  My MIND is a SUBMARINE!!
23:21:05 <jdrake> But interest rate doesn't change.
23:21:09 <Giraffe> jdrake, that's what i was thinking sort of
23:21:20 <ksf> gpu is traditionally jit-compiled by the driver.
23:21:30 <dons> right, but there's no reason for that to be the case.
23:21:43 <dons> we can statically determine what code should run on the gpu, and avoid jit costs.
23:21:50 <ksf> so even if you compile to cg, the driver still translates it into gpu assembly.
23:21:52 <dons> the new cuda compiler let's us cache the object code
23:22:15 <dons> its kind of silly to hand over strings of code to some mystery driver to compile :)
23:22:35 <ksf> jitting is also cool because you don't need to provide binaries for a thousand platforms...
23:22:35 * jdrake restrains his grammar corrector.
23:22:38 <dons> ksf: have you looked at the 'haskell on gpus' project.
23:22:58 <ksf> i've seen the obsidian presentation, that's all.
23:23:13 <dons> oh, not that one. the unsw one.
23:23:26 <Giraffe> jdrake, seems like what you need to do is have lists of all the fields that are independent (payment, mostly)
23:23:43 <Giraffe> pass in an initial balance and the list of payments and such to make and have the rest be calculated perhaps?
23:24:17 <jdrake> Q: With this code: details balance = (balance, iv, payment, closing) : [details closing]   How can I make it properly recursive and syntax proper for lists?
23:24:51 <luqui> dons, ksf, http://justtesting.org/post/53418059/gpugen-bringing-the-power-of-gpus-to-haskell
23:24:52 <Giraffe> seems like that'd recurse forever
23:25:04 <lambdabot> Title: Just Testing - GpuGen: Bringing the Power of GPUs to Haskell., http://tinyurl.com/6j8gjn
23:25:04 <dons> yup
23:25:06 <jdrake> Giraffe, I would put a limit on it
23:25:19 <ksf> http://www.galois.com/blog/2008/08/29/gpugen-bringing-the-power-of-gpus-into-the-haskell-world/
23:25:28 <Giraffe> jdrake, if you have to explicitly define a limit it's probably being done wrongly
23:25:30 <lambdabot> Title: Galois › Blog › Blog » Bringing the Power of GPUs to Haskell, http://tinyurl.com/5s7fwn
23:25:31 <jdrake> Is it like this?    details balance | balance > 0 = (balance, iv, payment, closing) : [details closing]
23:25:32 <Giraffe> i see your idea, though
23:25:40 <Giraffe> ooh, right
23:26:05 <Giraffe> seems right, but...
23:26:07 <jdrake> But the problem I see would be like  1 : [1 : [1 : [...
23:26:12 <jdrake> Which isn't right is it?
23:26:13 <Giraffe> would it be better to have some kind of data structure instead?
23:26:42 <jdrake> Giraffe, ideally I would like to have independent lists of all columns I want to represent.
23:26:52 <jdrake> But I am not sure that is necessary
23:27:37 <dons> romand: making progress?
23:28:17 <luqui> jdrake, i think the brackets are just superfluous
23:28:50 <jdrake> :t (++)
23:28:51 <lambdabot> forall a. [a] -> [a] -> [a]
23:28:58 <jdrake> :t (:)
23:28:59 <lambdabot> forall a. a -> [a] -> [a]
23:29:33 <Axman6> whoot, just got someone to order RWH who's never done haskell before
23:29:35 <luqui> > let foo = 1 : foo
23:29:36 <lambdabot>   <no location info>: parse error on input `;'
23:29:39 <luqui> > let foo = 1 : foo in foo
23:29:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:30:29 <ksf> i'd really like to see the video to that presentation.
23:30:54 <Giraffe> Axman6, "What is this?  This is dumb!"
23:31:02 <Giraffe> "I hate Haskell!"
23:31:08 <Giraffe> "Oh, do blocks?  Yay!"
23:31:23 <ksf> ...plus the same for cg cards that support enough profiles.
23:31:56 <jdrake> It works!
23:33:00 <jdrake> http://hpaste.org/12426#a1
23:33:13 <jdrake> Giraffe, I am curious about your ideal of a fold.
23:33:20 <jdrake> I have never adequately used a fold before.
23:33:24 <dons> Axman6: hehe. what was the killer message?
23:33:41 <ivanm> dons: the beetle ;-)
23:33:57 <Giraffe> jdrake, really?
23:34:09 <dons> i had to explain today that it wasn't a bug, it was a feature
23:34:15 <jdrake> Giraffe, I am not too experienced
23:34:20 <Giraffe> oh, it's fine
23:34:28 <Giraffe> i don't think it's a bad thing at all, but folds are wonderful
23:34:40 <Giraffe> when you said infinite list i kinda tossed that idea out the window, but...i was just thinking a fold could work for constructing the list recursively
23:34:43 <jdrake> I have played around with guis, and such, but purely functional stuff is lacking a little.
23:34:47 <ivanm> dons: lol
23:34:53 <Giraffe> well you're working with a purely functional language :P
23:35:01 <Giraffe> :t foldr
23:35:01 <jdrake> Giraffe, with 'do'
23:35:02 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:35:10 <Giraffe> jdrake, don't treat do like that
23:35:15 <te> yay for urxvt
23:35:21 <Giraffe> it winds up making your code work...not as it should
23:35:26 <te> im slowly becomnig part of your collective
23:35:41 <Giraffe> hmm, PM?
23:35:43 <jdrake> Giraffe, I have never seen a problem with it
23:35:50 <jdrake> ?
23:36:11 <dons> te hehe
23:36:15 <Giraffe> oh, no no
23:36:39 * luqui is so incredibly lost in jdrake's and Giraffe's conversation
23:38:27 <luqui> > foldr (:) [] [1..]  -- fold + infinite is fine...
23:38:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:46:35 <Giraffe> > foldr (+) 0 [1,2,3,4,5]
23:46:36 <lambdabot>   15
23:47:12 <Giraffe> luqui, foldr + infinite is fine
23:47:15 <Giraffe> foldl + infinite is not
23:47:26 <luqui> truth
23:49:25 <Stinger> ey dons, any good Australian sources for your book yet?
23:52:55 <dons> Stinger: i saw that it was at unsw bookshop, but generally, i don't know.
23:53:05 <dons> wherever good books are sold?
23:53:10 <Stinger> heh fair enough
23:53:22 <Pellwurst> I've got a list of int pairs: [(Int,Int)].....id like to map the function (fst*snd) on that list....but i always the error "No instance arising.....". Anyone can help?
23:53:26 <dons> http://www.reddit.com/r/haskell/comments/7fz7t/the_data_parallel_haskell_team_needs_your_help/
23:53:28 <lambdabot> Title: The Data Parallel Haskell team needs your help! Got an 8x machine to benchmark o ..., http://tinyurl.com/6z5rap
23:53:36 <dons> Pellwurst: hmm?
23:53:56 <dons> > zipWith (*) [(1,2),(2,3)]
23:53:57 <lambdabot>       Overlapping instances for Show ([(t, t1)] -> [(t, t1)])
23:53:57 <lambdabot>        arising ...
23:54:00 <dons> grr.
23:54:04 <dons> gwern, cale: that sucks
23:54:09 <dons> someone broke the eval bot.
23:54:29 <dons> i'd like normal errors, not funky overloading ones
23:54:32 <Pellwurst> so the right function is zipWith and not map?
23:54:54 <dons> > map (\(a,b) -> a * b) [(1,2),(2,3)]
23:54:56 <lambdabot>   [2,6]
23:55:02 <dons> Pellwurst: so that kind of result?
23:55:03 <Pellwurst> i wrote map (fst *snd) [(1,2),(2,3)]
23:55:06 <te> foldr (:) [] [1..]
23:55:10 <dons> Pellwurst: right, but that doesn't work :)
23:55:13 <dons> :t fst
23:55:13 <ddarius> > map (uncurry (*)) [(1,2),(2,3)]
23:55:14 <lambdabot> forall a b. (a, b) -> a
23:55:15 <lambdabot>   [2,6]
23:55:15 <Cale> dons: There's more than one module in the libraries we're importing which defines an instance of Show for functions.
23:55:16 <Pellwurst> i know *G*
23:55:17 <dons> you have to apply fst to a pair.
23:55:24 <dons> Cale: yes, seems like it.
23:55:30 <dons> so every type error turns into an overloading one
23:55:35 <te> im just learning Haskell, that foldr (:) [] [1..] is really cool
23:55:42 <dons> can we just have one show instance for functions like we use to?
23:55:46 <ddarius> foldr (:) [] = id
23:55:48 <dons> maybe make the Expr business separate?
23:56:23 <ddarius> > zipWith (*) $ unzip [(1,2),(2,3)]
23:56:24 <lambdabot>   Couldn't match expected type `[a]'
23:56:35 <Cale> It's hard to not import instances.
23:56:40 <ddarius> > uncurry (zipWith (*)) $ unzip [(1,2),(2,3)]
23:56:41 <lambdabot>   [2,6]
23:56:44 <dons> Cale: the general rule that lambdabot tries to present exactly what ghci would do, for teaching purposes, seems to have been abandoned
23:56:51 <dons> making this frustrating when teaching :/
23:57:31 <Cale> Well, at present it does do this, it's just got a ton of modules loaded.
23:57:40 <dons> so can we unload the ton?
23:58:09 <Cale> Only if you want to lose access to that stuff.
23:58:30 <romand> what building system are usually used for haskell programs?
23:58:31 <dons> so perhaps we can have a haskell eval, and then lots of extra crap as a , or ? command
23:58:38 <dons> romand: cabal
23:58:38 <Cale> romand: cabal
23:58:54 <romand> thanks
23:58:58 * Cale will accept patches :)
