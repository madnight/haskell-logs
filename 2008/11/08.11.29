00:00:12 <Axman6> > let f = 1:2: zipWith (%) f (tail f) in f
00:00:14 <lambdabot>       Occurs check: cannot construct the infinite type: a = Ratio a
00:00:14 <lambdabot>        Ex...
00:00:23 <thoughtpolice> sjanssen: yeah, there was a lot of cruft inside jhc; I remember when I was hacking the code to use utf8-string, I replaced over 10 *exactly identical* definitions of 'toUTF' and 'fromUTF' that were layed all around the source code in many strange places
00:00:30 <Axman6> > let f = 1%1:2%1:zipWith (%) f (tail f) in f
00:00:32 <lambdabot>       Occurs check: cannot construct the infinite type: t = Ratio t
00:00:32 <lambdabot>        Ex...
00:00:36 <thoughtpolice> also, JHC used DrIFT for generating instances of type classes
00:00:39 <dolio> zipWith (/)
00:00:43 <thoughtpolice> but that made cabalisation needlessly complex
00:00:51 <Axman6> > let f = 1%1:2%1:zipWith (/) f (tail f) in f
00:00:54 <lambdabot>   [1%1,2%1,1%2,4%1,1%8,32%1,1%256,8192%1,1%2097152,17179869184%1,1%3602879701...
00:00:56 <sjanssen> thoughtpolice: yikes
00:00:57 <thoughtpolice> so I wrote a derivation for data.derive that wasn't there before, uploaded it, and changed LHC to use it instead
00:02:11 <pk> @src ap
00:02:11 <lambdabot> ap = liftM2 id
00:02:13 <thoughtpolice> sjanssen: also, the old makefile build system generated things like files containing primop information/data types etc, and now we're looking into the possibility of using Quasi-quoting for that, so cabalisation is also easier and more manageable (basically, take things that are managed by the build system and see if we can manage them in the code itself)
00:03:07 <thoughtpolice> sjanssen: but yes, there have already been some big changes in the week or so since the fork, and future plans include completely removing the parser that's there in favor of using haskell-src-exts, which will also eventually lead to things like the supporting of GADTs, associated types, etc. etc..
00:03:20 <pumpkin-> @src id
00:03:20 <lambdabot> id x = x
00:03:23 <pumpkin-> hot
00:04:05 <pumpkin-> > ap [1,2,3] [2,3,4]
00:04:05 <thoughtpolice> sjanssen: so at this point, maintaining lhc solely as a patch-set seems unreasonable, and I believe Lemmih and I have some ideas that john would not agree with anyway.
00:04:06 <lambdabot>       No instance for (Num (a -> b))
00:04:06 <lambdabot>        arising from the literal `1' at <...
00:04:08 <pumpkin-> hmm
00:04:11 <pumpkin-> oh
00:04:15 <Saizan> you've to rewrite a lot of the frontend to support gadts, too
00:04:34 <pumpkin-> > [(+1), (+2), (+3)] `ap` [1,2,3]
00:04:36 <lambdabot>   [2,3,4,3,4,5,4,5,6]
00:05:39 <thoughtpolice> Saizan: AFAICS, haskell-src-exts will basically take up the parsing part of the problem, and E is a lambda-cube based intermediate language, so I don't think we'll have to significantly alter the E mechanics to support things like that (indeed, one of the original goals of systems like E/henk was to easily adapt to new type system features)
00:06:07 <sjanssen> thoughtpolice: thanks for the explanation
00:06:14 <g_> hi yall
00:06:43 <sjanssen> thoughtpolice: you might want to dump some of that on the LHC wiki, I bet this won't be the last time you answer that question :)
00:07:09 <thoughtpolice> sjanssen: might be a good idea; the wiki is somewhat neglected right now.
00:07:40 <Saizan> thoughtpolice: yeah, but you still need to typecheck the haskell code before you convert it to E
00:08:02 <g_> wikis are awesome
00:08:09 <g_> but people need to use lots of links
00:08:18 <g_> no one want to page down thru 5 screens
00:08:31 <g_> they want to jump to what they want using a link
00:08:39 <g_> sory if im nerding out
00:10:01 <thoughtpolice> Saizan: right; GADT support etc. is a bit of a ways off anyway as it stands
00:12:30 <thoughtpolice> Saizan: there are also other things haskell-src-exts can give us that caught my mind
00:12:30 <thoughtpolice> notably XML-embedded syntax
00:12:30 <thoughtpolice> although those ideas are *way* far off as it stands :P
00:12:31 <Saizan> i wonder if there's any research in describing type systems in a modular way, so that you can better separate implementation of each feature
00:16:42 <Lemmih> dons: Where's the darcs repo for darcs-graph?
00:16:43 <Saizan> thoughtpolice: btw, do you intend to use haskell-src-exts' AST directly or convert it to lhc's HsDecl/HsExp/etc..?
00:18:12 <Lemmih> dons: Found it.
00:29:54 <Axman6> how do i recompile System to have profiling support?
00:30:47 <ksf> that's a _very_ good question.
00:31:06 <Axman6> i try my best...
00:31:10 <ksf> gentoos ghc package comes without the profiling use flag
00:32:10 <ksf> btw, is ghc 6.10 slotted on gentoo?
00:32:11 <Axman6> i'm getting:
00:32:11 <Axman6>     Could not find module `System':
00:32:12 <Axman6>       Perhaps you haven't installed the profiling libraries for package haskell98?
00:32:54 <ivanm> ksf: ghc isn't slotted
00:33:22 <ksf> ...not really surprising, as cabal can't deal with such stuff afaict
00:33:31 <thoughtpolice> Saizan: I'm not quite sure yet
00:33:32 <ivanm> ksf: note that gentoo related questions really belong in #gentoo-haskell :p
00:33:38 <thoughtpolice> Saizan: it's a very big part of the code base being removed, and it will touch a lot of the source deeply
00:33:59 <thoughtpolice> Saizan: even after niklas gets pragma support into haskell-src-exts, it may be a good while before lhc actually starts using it
00:34:07 <thoughtpolice> which is OK, because we aren't on any deadlines at least :)
00:34:08 <Axman6> also, is there a way to reinstall all things oinstalled with cabal-install with profiling?
00:34:12 <ivanm> ksf: well, it comes down to each lib being compiled for a specific version of ghc... so if we were to slot ghc, we'd have to have a way of compiling each lib with every version of ghc or something... :s
00:34:20 <thoughtpolice> Axman6: cabal install --reinstall -p
00:34:38 <thoughtpolice> Axman6: note the -p flag will only build libraries with profiling support, not executables
00:34:46 <ksf> we just need to figure out a way to tease spj into making the rts hot-swappable and everything's well.
00:34:49 <Axman6> righto, that's fine
00:35:05 <Axman6> thoughtpolice: any way to tell it to do it for everything it has installed? :\
00:35:06 <thoughtpolice> you should be able to cabal install --reinstall -p haskell98 just fine
00:35:22 <ivanm> ksf: "tease" spj? you mean something like: "heh, bet you can't do ______!"? ;-)
00:35:25 <thoughtpolice> Axman6: no
00:35:47 <Axman6> righto, well i'll just add more to the list when it whings at me :)
00:35:50 <thoughtpolice> "hey spj, I bet you can't FLY"
00:35:50 <Axman6> whinges*
00:36:12 <Deewiant> Axman6: best thing to do is to set library-profiling: True in .cabal/config as early as possible :-)
00:36:14 <thoughtpolice> anyway, 4% battery and it is 2:30am
00:36:15 <Axman6> ah cheers thoughtpolice, that worked just fine, thanks :D
00:36:28 <Axman6> Deewiant: will do
00:36:30 <thoughtpolice> good night #haskell :)
00:36:30 <Deewiant> It somewhat surprises me that it's off by default
00:36:38 <ksf> ghc isn't cabalised?
00:36:54 <ksf> though of cabal-installing ghc and mangling a bit with the environment.
00:37:01 <Deewiant> Since what ends up happening is you want to profile something and find that you have to reinstall a billion libraries
00:37:54 <ksf> it should prolly be on by default and stripable.
00:38:55 * ksf still thinks ghc should have a jit mode
00:39:47 <ivanm> ksf: just-in-time mode? it doesn't compile to byte-code to be run on a VM, so I don't see the point of JIT...
00:40:07 <ksf> ghci does.
00:40:11 <BMeph> Lemmih: Do you think it's possible that John might patch jhc to use haskell-src-exts? :)
00:40:20 <ksf> all the stuff's already there.
00:40:45 <ivanm> ksf: yes, but ghc is a compiler, not a VM...
00:41:41 <ksf> think running happlets in your browser.
00:42:17 <ivanm> hmmmmm..... somehow, I don't think we'll have much luck in getting people to install a haskell VM in addition to Java...
00:43:13 <Lemmih> BMeph: I don't know. Even LHC is a fair distance away from using haskell-src-exts.
00:43:14 <ksf> think doing a haskell browser first, then.
00:44:29 <solrize_> haskell has no security model to speak of, and not much notion of resource control
00:44:40 <ivanm> ksf: nah, a haskell IRC client is of more pressing concern ;-)
00:44:52 <ivanm> with integrated lambdabot \o/
00:45:01 <ksf> Haskell: A language to eval them all, a language to find them, a language to bring them all and in purity bind them.
00:46:49 <Giraffe> ksf, i suppose, but i think when we get into "do everything!" territory, the language's strengths and weaknesses become secondary to the insatiable drive to expand its domain
00:47:39 <solrize_> vixey pointed me at ATS the other night.  it looks like a perfect candidate for an unholy marriage with haskell ;)
00:47:45 <Axman6> hmm, what's the program that will give you a nice graph from a profiled haskell program?
00:48:01 <ksf> well if we don't go "do everything", the next haskell prime could be the last one, as it'll be quite perfect for everything haskell is used right now.
00:48:14 <ivanm> Axman6: it's on hackage, I know that much...
00:48:17 <solrize_> haskell' is missing lots of ghc extensions i thought
00:48:30 <Giraffe> ksf, it just gets problematic when the language is extended beyond its means
00:48:41 <Giraffe> example: java
00:50:12 <ksf> ATS looks like line noise to me.
00:50:18 <ksf> at least the shootout programs.
00:50:37 <Axman6> the ATS progs are half full of C aren;t they?
00:50:44 <ksf> yeah.
00:51:23 <Axman6> that's totally cheating. i mean, if you're going to benchmark a language, you should use only that language right?
00:51:26 <ksf> anyway: "Hey spj, I bet your rts can't host a browser"
00:53:33 <Axman6> ivanm: hp2ps
00:53:54 <erikc> yay, progress, i now have unions and bitfield access working, i will soon have the expression evaluation portion of a C/C++ debugger implemented in haskell
00:54:18 <erikc> i dunno if im gonna tackle the insanity of virtual base classes
00:58:14 <Lemmih> dons: I've changed 'darcs-graph' to use 'darcs changes' instead of looking at the patch format. Patch coming soon.
01:03:32 <solrize_> loo
01:03:35 <solrize_> oops
01:04:41 <solrize_> i think the C stuff in the ATS progs is for system calls and the like
01:10:26 <blueonyx> hi
01:10:31 <Lemmih> dons: Patches away.
01:13:36 <blueonyx> how can i tell quickCheck to do more than 100 tests? i see that there are stdArgs but not how to override the defaults :/
01:14:52 <blueonyx> http://book.realworldhaskell.org/read/testing-and-quality-assurance.html uses import Test.QuickCheck.Batch but ghci complains that this doesnt exist
01:14:58 <lambdabot> Title: Chapter 11. Testing and quality assurance, http://tinyurl.com/46ejvv
01:15:53 <mmorrow> conal: you're earlier `duplicate' example got me to thinking http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=514
01:15:56 <mmorrow> *your
01:17:45 <mmorrow> i got the idea to make that polymorphic-recursive newtype from the "Polish Parsers" paper
01:18:08 <mmorrow> which uses something similar
01:18:16 <mmorrow> but different
01:21:34 <Axman6> does doing IO in a function automativcally mean its a function of -> IO a?
01:21:46 <Axman6> yes..
01:22:50 <pumpkin-> yup
01:23:04 <pumpkin-> unless you use that evil function
01:23:22 <Axman6> which evil function?
01:23:28 <pumpkin-> that which shall not be named!
01:23:30 <pumpkin-> voldefunc
01:23:32 <mmorrow> , unQ [|\x->x}]
01:23:38 <lunabot>  luna: parse error on input `}'
01:23:42 <pumpkin-> I mean, unsafePerformIO
01:23:42 <BMeph> unsafePerformIO (torture puppies)
01:23:42 <mmorrow> , unQ [|\x->x|]
01:23:46 <lunabot>  LamE [VarP x_0] (VarE x_0)
01:23:52 <Axman6> :t unsafePerformIO
01:23:54 <lambdabot> Not in scope: `unsafePerformIO'
01:23:55 <mmorrow> unQ = unsafePerformIO . runQ
01:24:00 <Axman6> :O
01:24:32 <pumpkin-> Axman6: it takes an IO a to an a
01:24:43 <Axman6> ah, i see
01:24:46 <Axman6> how handeh
01:24:46 <mmorrow> since there'd be no other way to show a (Q Exp) since lunabot can't do IO
01:24:57 <mmorrow> thus rendering [| ... |] syntax useless
01:24:58 <pumpkin-> you're supposed to use it on ffi only, as far as I know, to tell it something external's referentially transparent
01:24:59 <Axman6> i mean... oh ... oh no... they've turned me!
01:25:47 <Axman6> @hoogle unsafePerformIO
01:25:48 <lambdabot> Foreign unsafePerformIO :: IO a -> a
01:25:48 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
01:26:38 <pumpkin-> Axman6: I'm pretty sure you'll see some odd behavior if you try it on anything that does change, though
01:27:01 <Axman6> yeah i'm not realy planning on using it
01:27:05 <Axman6> ll*
01:27:30 <ksf>   pumpkin , not really, you'll get the first result every time.
01:27:39 <pumpkin-> which is probably odd behavior :)
01:27:44 <mmorrow> Axman6: experiment with a list of IORefs, unsafePerformIO, and reverse/replicate/etc in ghci to see why how it can bite you hard
01:27:49 <ksf> ...at least that's the to be expected behaviour, but it's still undefined.
01:28:15 <Axman6> mmorrow: maybe some other time, not really relevent to anything i'm doing atm :)
01:28:23 <ksf> things usually don't get reduced to whnf more than once.
01:28:24 <Axman6> which is probably a good thing
01:28:59 <mmorrow> Axman6: well, if you have the desire to learn how unsafePerformIO behaves, i found that exercise useful myself
01:29:01 <ksf> the only time i ever used it was to read a xml file for processing with TH.
01:29:30 <Axman6> mmorrow: IO is scary enough without it being unsafe :(
01:29:39 * Axman6 is kidding... but still
01:29:53 <mmorrow> ksf: runIO ?
01:30:04 <ksf> there's such a thing in th?
01:30:09 <ksf> must have missed it.
01:30:13 <Axman6> what is TH anyway?
01:30:13 <ksf> ah no.
01:30:15 <Saizan> ?type runIO
01:30:17 <lambdabot> Not in scope: `runIO'
01:30:18 <Axman6> i hear a lot of mention of it
01:30:19 <mmorrow> runIO (readFile "/etc/passwd/ >>= putStr) >> return [|()|]
01:30:30 <ksf> i _did_ see it, but i didn't want to parse the xml multiple times.
01:30:40 <mmorrow> it's not in scope in lunabot for obvious reasons
01:30:50 <pumpkin-> :t putStr
01:30:51 <lambdabot> String -> IO ()
01:30:52 <mmorrow> ksf: ahh. :)
01:30:57 <ksf> for performance and general integrity reason, not to mention that it's the right thing to do.
01:30:57 <Saizan> Axman6: TemplateHaskell, a macro system
01:31:06 <Axman6> oh i see
01:31:09 <pumpkin-> one of these days I'll pull that state of the universe out of an IO and then I'll be omniscient
01:31:18 <ksf> (I usually don't expect files to change while building, but you never know)
01:31:23 <pumpkin-> @src IO
01:31:23 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
01:31:45 <Axman6> @src IO (>>=)
01:31:46 <lambdabot> m >>= k     = bindIO m k
01:31:58 <Axman6> ah yes, i've been down this path before!
01:32:12 <Axman6> leads to lambdabot withholding all her secrets!
01:36:45 <pumpkin-> for what input would I see a difference between fromInteger and fromIntegral?
01:37:50 <solrize_> IO is not just a type alias for State RealWorld   ?
01:37:56 <kig> @src fromIntegral
01:37:57 <lambdabot> fromIntegral = fromInteger . toInteger
01:38:07 <pumpkin-> hrm
01:38:16 <pumpkin-> > fromIntegral 5.0
01:38:18 <lambdabot>   Add a type signature
01:38:22 <pumpkin-> > fromIntegral 5.0 :: Int
01:38:23 <lambdabot>   Add a type signature
01:38:29 <pumpkin-> hmm
01:38:36 <solrize_> > fromIntegral (5.0 :: Double)
01:38:38 <lambdabot>       No instance for (Integral Double)
01:38:38 <lambdabot>        arising from a use of `fromInt...
01:38:49 <kig> fromInteger (5::Int)
01:38:51 <solrize_> > fromIntegral (5 :: Rational)
01:38:52 <lambdabot>       No instance for (Integral Rational)
01:38:52 <lambdabot>        arising from a use of `fromI...
01:38:54 <kig> > fromInteger (5::Int)
01:38:55 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
01:38:58 <kig> > fromIntegral (5::Int)
01:38:59 <lambdabot>   5
01:39:14 <pumpkin-> hmm
01:39:31 <Axman6> :t fromIntegral (5::Int)
01:39:32 <lambdabot> forall b. (Num b) => b
01:40:30 <Axman6> @src Int toInteger
01:40:31 <lambdabot> Source not found. You type like i drive.
01:40:36 <Axman6> @src toInteger
01:40:36 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:40:37 <Raevel> dons: yo?
01:41:18 <pumpkin-> ah well, time for bed
01:41:20 <pumpkin-> night everyone
01:42:39 <naradapuri> Hi, I'm learning Haskell, and as an exercise I'd like to write/use some state monad that would cache values of a function: For a function 'f :: a->b' the intitial state would be an empty 'Map a b'. Every time I ask for 'f a', I want it to look it up in the map. If the key is not there then to use 'f' to compute the value and update the map. I thought I'd use State monad where the state would be the map, but I can't figure how. Anybody could help?
01:42:42 <Raevel> @tell dons one of the stores here in sweden put rwh up as available today, except they raised the prise by 50%, and says it's a special order that takes 26-40 before it can be shipped :-( i hope the others are more haskell-friendly!
01:42:42 <lambdabot> Consider it noted.
01:44:20 <Axman6> Raevel: i pre-ordered it, and found out they raised the price by about $50AU after i made the order, so i'm pretty happy :)
01:44:33 <Axman6> night pumpkin-
01:45:06 <solrize_> naradapuri, a general memoizing solution is pretty complicated
01:45:09 <solrize_> various attempts have been made
01:45:13 <solrize_> there is a haskell wiki page about it
01:45:31 <Raevel> Axman6: oh boy, they raised it by ~25aud here
01:45:37 <Raevel> so not a biggie
01:46:02 <Axman6> i think i got it for about 50-60, ad now it's over 100
01:46:02 <solrize_> http://haskell.org/haskellwiki/Memoization
01:46:04 <lambdabot> Title: Memoization - HaskellWiki
01:46:19 <Saizan> naradapuri: what problems are you having in using the State monad?
01:46:40 <solrize_> still 50 usd from bn.com
01:47:11 <Raevel> i guess it comes out cheaper than here if you consider the 26-40 days (???) before they can ship
01:47:29 <solrize_> naradapuri what's the issue with using the state monad manually?
01:47:29 <naradapuri> Saizan: As I understand, the State monad returns some value depending only on its state. I need to get a value depending on the state and on a parameter.
01:48:15 <naradapuri> (maybe there is some obvious solution that I'm not aware of, I'm just learning haskell)
01:48:17 <solrize_> naradapuri you would supply an initial state, and a monadic action that you can put the parameter into
01:48:38 <solrize_> darn i have an example like that but it's on my other computer, not here
01:48:41 <Axman6> naradapuri: if you want memoisation, arrays are a more common solution
01:49:11 <Saizan> > let addN n = do s <- get; return (s+n); in runState (add 5) 0
01:49:12 <lambdabot>   Not in scope: `add'
01:49:17 <Saizan> > let addN n = do s <- get; return (s+n); in runState (addN 5) 0
01:49:19 <lambdabot>   (5,0)
01:49:52 <Saizan> naradapuri: basically you can have a function with a type like a -> State s b
01:50:08 <Saizan> naradapuri: where 'a' will be the type of your parameter
01:50:37 <naradapuri> Axman6: Yes, I tried to use list, but the values I want to compute are very large (10^9) so it's not possible to make such a large array
01:51:05 <Axman6> why not? they're lazy, so it should be ok
01:51:35 <Saizan> you still have to allocate the memory to hold 10^9 pointers
01:52:02 <Axman6> ah :\
01:52:39 <mmorrow> naradapuri: you could also make a function memo :: (Ord a) => (a -> b) -> (Map a b -> a -> (a, Map a b)) , and then just explicitly pass the Map to the memoized function
01:52:42 <Saizan> they are lazy in the values, but to get O(1) access you need to allocate a contiguous chunk of memory, like C would do
01:52:48 <naradapuri> Saizan: Thanks, I'll have to think it over to understand it.
01:54:11 <mmorrow> memo m f = (\a -> maybe (let b = f a in (b, M.insert b m)) (\b -> (b,m)) (M.lookup a m)
01:54:12 <Saizan> naradapuri: a larger example -> http://www.haskell.org/all_about_monads/html/statemonad.html#example
01:54:14 <lambdabot> Title: The State monad, http://tinyurl.com/2g4v8r
01:54:16 <naradapuri> mmorrow: Yes, this is what I wanted to do, but I wanted to make it monadic somehow so that I could use do notation
01:54:18 <mmorrow> )
01:54:30 <mmorrow> @src State
01:54:31 <lambdabot> Source not found.
01:54:36 <mmorrow> @unmtl State
01:54:36 <lambdabot> err: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
01:54:40 <mmorrow> @unmtl State s a
01:54:40 <lambdabot> s -> (a, s)
01:55:02 <mmorrow> yeah, so you need a modified State monad
01:55:13 <Saizan> why modified?
01:55:52 <mmorrow> because he needs to pass in both the initial state and the initial arg for the function
01:56:12 <solrize_> just make the initial action take a state arg
01:56:13 <mmorrow> newtype S s a b = S (s -> a -> (b, s))
01:56:32 <Saizan> you can just have a memo :: (a -> b) -> (a -> State (Map a b) b)
01:56:35 <ttt--> hi, does anyone know how i can get the ModSummary of a haskell source file in the current directory? (for parseModule :: GhcMonad m => ModSummary -> m ParsedModule)
01:56:40 <solrize_> nah, just use normal State, and have     initialize :: s -> State s a
01:57:05 <ttt--> I think it has something to do with the module graph, but it seems to be empty
01:58:01 <mmorrow> Saizan, solrize: yeah, those would work too :)
01:58:17 <solrize_> http://www.haskell.org/haskellwiki/Euler_answers   what happened to this ?
01:58:18 <lambdabot> Title: Euler answers - HaskellWiki
01:59:21 <Saizan> ttt--: iirc, you've to use addTarget/guessTarget first
02:00:02 <naradapuri> thanks everybody, I'll have to take some time and process the ideas
02:01:20 <ttt--> thanks Saizan, i'll try that
02:07:06 <mmorrow> @src (>>=) RWS
02:07:06 <lambdabot> Source not found. stty: unknown mode: doofus
02:07:10 <mmorrow> @src RWS (>>=)
02:07:11 <lambdabot> Source not found. Wrong!  You cheating scum!
02:08:31 <mmorrow> naradapuri: i guess you'd need something like   State (Map a b, a -> b, a) b
02:09:12 <Axman6> :t get
02:09:13 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
02:09:31 <Axman6> @src State get
02:09:31 <lambdabot> Source not found. Maybe you made a typo?
02:09:47 <mmorrow> get = State (\s -> (s,s))
02:10:13 <mmorrow> set s = State (\_ -> ((),s))
02:10:35 <naradapuri> mmorrow: Why the state contains 'a'?
02:10:49 * Saizan was wondering the same
02:10:59 <mmorrow> naradapuri: so you can pass the arg to the function in in the intial state
02:11:25 <mmorrow> type Memo a b = State (Map a b, a -> b, a) b
02:11:31 <hackage> Uploaded to hackage: fastcgi 3001.0.2.2
02:11:37 <Saizan> that way you're going to compute the value only at that arg no?
02:12:04 <Saizan> but the point of memoization is to use the function at multiple arguments and don't worry about sharing
02:12:08 <mmorrow> i'm assuming he doesn't want to have to put all his code in the State monad
02:12:20 <mmorrow> if he does though, he wouldn't want that
02:12:46 <ttt--> Saizan, do you know any examples i can take a look at? I can't really get it to work ( http://hpaste.org/12480 )
02:12:55 <naradapuri> So you mean that every time I update the state I put into it the next argument I want to evaluate?
02:12:56 <Saizan> if he doesn't he has to pass the Map a b around explicitly
02:13:12 <mmorrow> that's what i'd do :)
02:13:34 <ttt--> The graph length always stays 0 (but it doesnt fail)
02:13:40 <mmorrow> but that could get messy quick...
02:14:21 <mmorrow> naradapuri: err, i just realized that what i just suggested isn't what you're looking for at all
02:15:31 <mmorrow> State (Map a b -> a -> (b, Map a b)) c  might be nice
02:15:46 <mmorrow> err
02:15:54 <mmorrow> State (Map a b, Map a b -> a -> (b, Map a b)) c
02:16:36 <mmorrow> \a -> (get >>= \(m,f) -> let (b,m') = f m a in put (m',f) >> return b)
02:17:17 <mmorrow> i dunno, you probably want a newtype and some helper functions cuz it seems like it could get messy fast
02:17:25 <Saizan> State (Map a b, a -> State (Map a b) b) c, looks weird
02:17:31 <mmorrow> heh
02:18:12 <Saizan> we probably have some very different use cases in mind :)
02:18:30 <mmorrow> withMemo a = do (m,f) <- get; let b = f m a in put (m',f) >> return b
02:19:03 <mmorrow> runState (withMemo 42) (mempty, memoizeIt (*2))
02:19:25 <mmorrow> that what i'm thinking of, but yeah i could be going down a completely different track here..
02:19:55 <Saizan> not in scope: m' :)
02:20:13 <mmorrow> hehe
02:20:19 <Saizan> but yeah, s/b/(b,m')/
02:20:28 <mmorrow> yeah
02:22:08 <Saizan> you're never going to change f though
02:23:13 <mmorrow> but i guess that'd let you though
02:23:47 <mmorrow> ditchF f = do (m,_) <- get; put (m,f)
02:23:59 <mmorrow> err, you'd probably want
02:24:07 <mmorrow> ditchF f = put (mempty,f)
02:24:13 <mmorrow> gah
02:24:21 <mmorrow> ditchF f = put (mempty, memoizeIt f)
02:27:18 <Saizan> yeah, i'd just find more convenient to use let f' = memoizeIt f in runState (...) mempty
02:27:58 <mmorrow> hmm, that'd be nice too
02:28:17 <Saizan> and it's the same memoizeIt
02:29:29 <mmorrow> i guess that'd be better if the `f' was a one-shot function and not e.g. something like readTheTerabytesAndDoSomething :: FilePath -> IO Something
02:29:57 <mmorrow> StateT (...) IO a
02:30:15 <mmorrow> but IO gets you mutable vars anyways..
02:30:31 <Saizan> what's the difference?
02:31:04 <mmorrow> hmm, i guess there isn't one now that i think about it
02:31:38 <mmorrow> for some reason i was thinking your version discarded the Map after f' returns
02:32:13 <Saizan> heh, no, it won't work
02:32:29 <mmorrow> ruhroh
02:32:53 <mmorrow> how do you mean?
02:33:17 <Saizan> sorry, i meant it wouldn't work if it discarded the Map
02:33:36 <mmorrow> heh, yeah
02:34:48 <Saizan> this is all assuming 'f' is not recursive, or you don't want to memoize recusive calls
02:35:23 <mmorrow> very true
02:35:32 <Axman6> hmmmm... i think i'm ready to upload this ARM emulator to hackage... :o
02:35:45 <mmorrow> ooh, cool
02:36:48 <Axman6> ok... here goes!
02:37:19 <Axman6> done!
02:39:47 <Axman6> hmmm, it can't compile now... rawr!
02:40:30 <Axman6> urgh, it didn't include any of the sources it needs! damn it
02:43:19 <Axman6> ok, what modules should be exported from a project?
02:45:15 <Axman6> gahh! how do i tell cabal to package all the source files in a dir?
02:45:57 <mmorrow> maybe add them to extra-src-files: (or something like that) in the .cabal
02:47:06 <pao> mm_freak: Philippa: I've got a solution
02:47:07 <pao> > let foo n = do parsedS <- get; (p, s) <- lift $ map (flip splitAt parsedS) [0..n]; put s; return p in runStateT (foo 2) "paolo"
02:47:08 <lambdabot>   [("","paolo"),("p","aolo"),("pa","olo")]
02:47:26 <pao> thanks to Saizan for inspiration
02:49:35 <lilac> instance Comonad IO where extract = unsafePerformIO; cobind a f = return $ f (extract a)
02:49:56 <lilac> ^^ purity aside, would that be a comonad?
02:50:21 <mmorrow> cobind = flip fmap
02:50:50 <mmorrow> i'm not sure what the "rules" for comonads are
02:51:10 <lilac> i think i meant cobind a f = return (f a)
02:51:16 <mmorrow> ah
02:51:20 <mmorrow> yeah
02:51:22 <mmorrow> flip fmap
02:51:27 <mmorrow> oh
02:51:44 <mmorrow> yeah, return (f a)
02:51:53 <lilac> so cojoin = return
02:51:56 <mmorrow> , src 'cobind
02:51:58 <lunabot>  luna: Not in scope: `cobind'
02:52:06 <mmorrow> , src ''Comonad
02:52:16 <lunabot>  class (Copointed w) => Comonad w where
02:52:16 <lunabot>          duplicate :: forall a . w a -> w (w a)
02:52:16 <lunabot>          extend :: forall b a . (w a -> b) -> w a -> w b
02:52:56 <lilac> no, it's not right -- fmap extract . cojoin /= extract . cojoin
02:52:58 <mmorrow> hmm, did you mean another Comonad?
02:53:46 <lilac> i suspect that one is equivalent, with duplicate == cojoin and extend = flip cobind
02:53:59 <mmorrow> ah, i see
03:02:21 <lilac> hmm. is it possible for someone other than the maintainer of a package to upload a new version to hackage?
03:05:27 <Axman6> hackage: poke!
03:06:25 <Axman6> mmorrow: were you interested in this HARM thing?
03:10:27 <Axman6> is there a function that will read a single char and move on right away? like, i don't want to have to press enter after pressing the letter
03:10:46 <daf> you need to put the terminal into raw mode
03:11:31 <Axman6> getChar 'works' but yeah, needs the new line
03:11:31 <hackage> Uploaded to hackage: HARM 0.1.2
03:11:31 <hackage> Uploaded to hackage: HARM 0.1.1
03:11:46 <Axman6> daf: any way to do that in haskell?
03:11:52 <daf> hmm, wait
03:12:10 <daf> getChar returns immediately for me
03:12:11 <Axman6> i have a hSetBuffering stdout NoBuffering in there, so something along those lines?
03:12:20 <solrize_> axman6 in linux you have to set the tty modes for that
03:12:28 <solrize_> no idea about windoze
03:12:34 <Axman6> well this is on OS X
03:12:37 <daf> I think GHC does it automatically
03:12:42 <daf> on Linux, at least
03:12:46 <solrize_> osx is like linux i think
03:12:53 <Lemmih> Axman6: Did you mean stdin?
03:12:54 <Axman6> daf: in ghci it works fine, but not in the compiled program
03:12:59 <solrize_> i doubt very much that ghc on linux messes with the tty modes
03:13:07 <Axman6> Lemmih: yes, i was just saying i already have that in there :)
03:13:11 <solrize_> unless you ask it to
03:13:15 <daf> the buffering is done in the IO/layer
03:13:18 <daf> not in the terminal
03:13:28 <daf> you need to tell the terminal to not buffer input
03:13:38 <daf> in C, you usually use curses to do this
03:13:55 <solrize_> just for chars?  nah
03:14:02 <solrize_> curses if for gui like stuff on ascii terminals
03:14:30 <ivanm> solrize_: only ascii?
03:14:37 * ivanm prefers utf-8 ;-)
03:14:42 <daf> solrize_: no, really
03:14:49 <daf> the raw() function is a curses function
03:14:55 <solrize_> look at System.Posix.Terminal
03:14:57 <Axman6> also, those HARM's up there, are my first hackage commits :)
03:15:43 <daf> solrize_: ah yes, that looks like the thing
03:16:08 <Axman6> http://hpaste.org/12481 if that help anyone
03:17:36 <Axman6> not my code by the way...
03:19:31 <solrize_> normally you'd use buffered reads for that
03:19:35 <solrize_> read a line from the tty
03:19:39 <solrize_> chop the trailing newline
03:19:41 <solrize_> and parse the line
03:19:55 <solrize_> or even, use readline
03:20:13 <Axman6> yeah, i should change it to head readline
03:21:32 <daf> you want the terminal attribute corresponding to ICANON
03:21:39 <daf> not clear which TerminalMode that is
03:22:27 <daf> maybe it's (withoutMode ProcessInput)
03:25:02 <daf> yeah, it is
03:25:10 <daf> but you also need to set minInput
03:26:41 <daf> and inputTime
03:27:33 <daf> so: withTime 0 $ withMinInput 1 $ withoutMode ProcessInput
03:28:10 <daf> this corresponds to the termios stuff
03:28:23 <Axman6> :t getLine
03:28:24 <lambdabot> IO String
03:33:01 <Axman6> ok, got it working now
03:34:25 * Axman6 updates again...
03:53:30 <Axman6> will cabal install ever be updated so you can just run cabal upgrade installed?
03:54:05 <Axman6> and can someone try a cabal install HARM for me?
03:54:26 <ivanm> Axman6: ummmm..... there already is cabal upgrade...
03:54:44 <Axman6> ivanm: but not cabal pgrade installed
03:55:21 <Axman6> u*
03:57:59 <ivanm> what is "cabal upgrade installed" meant to do?
03:58:12 <ivanm> "cabal upgrade" upgrades all installed packages...
03:59:26 <lilac> @tell conal resound runs at 4x real time if i change "adaptE ..." to "runE mempty ..."; all the time was going in System.Time.getClockTime.
03:59:27 <lambdabot> Consider it noted.
04:00:06 <Saul_> Why isn't there a mapM for Data.Map?
04:01:57 <jethr0> @type mapM
04:01:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:02:15 <lilac> Saul_: you can get the same effect with fromList <$> mapM f (toList myMap)
04:02:20 <jethr0> is data.map a monad?
04:02:21 <lilac> or something like that
04:02:58 <solrize_> :t Data.Map.Map
04:02:59 <lambdabot> Not in scope: data constructor `Data.Map.Map'
04:03:06 <solrize_> :t empty:: Data.Map.Map
04:03:07 <lambdabot>     `M.Map' is not applied to enough type arguments
04:03:07 <lambdabot>     Expected kind `?', but `M.Map' has kind `* -> * -> *'
04:03:07 <lambdabot>     In an expression type signature:
04:03:22 <solrize_> :t empty:: Data.Map.Map a b
04:03:23 <lambdabot>     Could not deduce (Alternative (M.Map a)) from the context ()
04:03:23 <lambdabot>       arising from a use of `empty' at <interactive>:1:0-4
04:03:23 <lambdabot>     Possible fix:
04:03:24 <Saul_> lilac: Maybe, but then you would also have to make different versions so you can map over the keys, the values or both
04:03:31 <solrize_> is it foldable?
04:03:59 <jethr0> i guess it could be foldable
04:04:11 <jethr0> but mapping over it would require a complete rebuild of its data structure, no?
04:04:19 <Saul_> solrize_: Probably, but it would be hard to turn that back into a map
04:04:24 <lilac> @type \f m -> mapM f (M.toList m) >>= return . M.fromList
04:04:26 <lambdabot> forall k a (m :: * -> *) k1 a1. (Ord k1, Monad m) => ((k, a) -> m (k1, a1)) -> M.Map k a -> m (M.Map k1 a1)
04:04:30 <daf> :t Data.Map.empty
04:04:31 <lilac> Saul_: ^^ looks pretty general to me
04:04:32 <lambdabot> forall k a. M.Map k a
04:04:50 <Saul_> lilac: it does
04:05:07 <Saul_> lilac: Maybe I'll send them in to be added to the library
04:05:20 <lilac> I'm not sure why it's added an Ord k1 but no Ord k :-/
04:06:04 <lilac> although i guess technically it doesn't use the Ord k :)
04:07:06 <Saul_> mapM :: Ord k -> (a -> m b) -> Map k a -> Map k b
04:07:06 <Saul_> mapMWithKey :: Ord k -> (k -> a -> m b) -> Map k a -> Map k b
04:07:11 <jethr0> i guess it inherits the Ord k from Data.Map, but doesn't use it in the expression
04:07:13 <Saul_> Are these signatures sensible?
04:07:25 <solrize_> it's got mapWithKey
04:07:32 <solrize_> and all kinds of other map functions
04:07:39 <solrize_> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
04:07:41 <lambdabot> Title: Data.Map, http://tinyurl.com/34gle9
04:07:44 <solrize_> :t mapWithKey
04:07:44 <Saul_> Wait
04:07:45 <lambdabot> Not in scope: `mapWithKey'
04:07:52 <solrize_> :t Data.Map.mapWithKey
04:07:53 <lambdabot> forall k a b. (k -> a -> b) -> M.Map k a -> M.Map k b
04:08:00 <solrize_> is that what you wanted?
04:08:06 <Saul_> mapM :: Ord k -> (a -> m b) -> Map k a -> m (Map k b)
04:08:06 <Saul_> mapMWithKey :: Ord k -> (k -> a -> m b) -> Map k a -> m (Map k b)
04:08:19 <Saul_> Sorry I forgot part of the monad
04:08:53 <Saul_> No the point is to have mapM for Map
04:09:17 <Saul_> the normal mapWithKey isn't what I want
04:10:41 <Saul_> I guess the problem might be the lack of an explicit order
04:11:10 <Saul_> the order it has is just an implementation detail
04:11:31 <hackage> Uploaded to hackage: HARM 0.1.3
04:11:41 <ksf> gosh. I'm currently reading c++ code oleg has written and I'm finally seeing some sense in it.
04:11:50 <ksf> c++ that is, not so much oleg's code.
04:12:10 <Saul_> so there is no proper order for sequencing the monadic operations
04:13:09 <jethr0> ksf: that's heresy - talking about seeing sense in c++ code on this channel ^_^
04:13:37 <ksf> struct size_f {
04:13:37 <ksf>   int operator()(const int, const int count) const { return 1+count; }
04:13:37 <ksf> };
04:13:51 <ksf> I didn't say it's beautiful.
04:13:56 <lilac> ksf: where does this code live?
04:14:00 <jethr0> good old function pointers...
04:14:02 <ksf> but you obviously _can_ code referentially transparent.
04:14:12 <ksf> http://okmij.org/ftp/Computation/Subtyping/Preventing-Trouble.html
04:14:13 <lambdabot> Title: Statical rules to prevent subclassing errors, http://tinyurl.com/68mf2z
04:14:31 <ksf> int size(const FBag& bag)
04:14:31 <ksf> {
04:14:31 <ksf>   return fold(bag,size_f(),0);
04:14:31 <ksf> }
04:15:00 <jethr0> i even programmed referentially transparent in c++ (more or less). it was a liberating experience not to care about references or pointers any more but only use single assignment values and copying them around.
04:15:16 <ksf> he uses no assignment at all.
04:15:25 <ksf> except in the gc, that is.
04:15:29 <jethr0> subclasses vs. subtypes has always given me a headache
04:15:33 <jethr0> nice
04:16:00 <jethr0> maybe these days i would be better equipped to grasp the semantic differences
04:16:11 <ksf> well if you subclass Int from Word and change the multiply-method to addition, you don't have a subtype.
04:18:16 <ksf> That code is definitely worth more than my stroustrup.
04:18:34 <ksf> got utterly bored reading that one.
04:18:34 <jethr0> yes, but the fragile base class problem has a different quality. it's based on different implicit assumptions of what is part of the type. so when such an implicit assumption is changed in the base class, the deriving class can get into bad problems
04:20:00 <jethr0> the stroustrup is a lesson in bad language definition IMHO. nothing against bjarne and why he chose this path for c++, but from a semantic and compiler-perspective it's erratic
04:20:52 <solrize_> saul_ ic, yeah, i think i get it.  yeah, some generic way to do that would be helpful.  i wonder if you could use a zipper...
04:21:36 <ksf> "I wonder if you could use a zipper" is actually a thing I don't like to hear.
04:21:58 <Saul_> solrize_: In this case a zipper isn't very useful I think
04:22:05 <ivanm> ksf: then what _do_ you want to hear? ;-)
04:22:20 * vixey I want to hear more uses of zipper
04:22:24 <ksf> Bach.
04:22:28 <ksf> definitely.
04:22:34 <Saul_> mapMM :: (Monad m, Ord k) => (a -> m b) -> Map k a -> m (Map k b)
04:22:34 <Saul_> mapMM f = liftM M.fromList . mapM (\(k,x) -> do y <- f x; return (k,y)) . M.toList
04:22:37 <ksf> now you come to mention it, I wanna hear music.
04:22:45 <jpcooper> ksf, I'm going to concerts of his today and tomorrow :)
04:22:51 <Saul_> This is something that works, and uses the order of the keys
04:23:00 <vixey> what's the problem?
04:23:01 <jethr0> live Bach concerts? wow!
04:23:09 <jpcooper> jethr0, yeah he's still living
04:23:20 <jethr0> ;)
04:23:22 <ivanm> ksf: what style of music?
04:23:47 <ksf> bach?
04:23:51 <ksf> it's classic.
04:23:55 <ksf> but it's not all i hear.
04:26:30 <ksf> s/hear/listen to/
04:26:36 <jpcooper> well it's really Baroque
04:26:39 <ksf> blame the translation layer.
04:27:30 <solrize_> well the idea of using a zipper is i think there's a library that derives zippers generically, so if those zippers supported something like mapM then there would be a monadic map for every zipperable type automatically
04:27:39 <ksf> it's classic in the sense that it uses neither synths nor elelectric guitars.
04:27:50 <jpcooper> heard of Wendy Carlos? :)
04:27:52 <ksf> concert guitar music is more complex.
04:28:44 <ksf> bach has the interesting property that you can completely ignore note durations and it still sounds good.
04:29:17 <solrize_> ehhhhhhh
04:30:16 <ksf> but if you really want to apply genres all the way, you'd have to say that mozart is emo, beethoven is melodic rock and bach... would fit into a bag with sigur ros.
04:30:34 <maltem> ksf: are you sure on that? Bach with the rhythm of a military march?
04:31:32 <solrize_> http://magnatune.com/artists/lara_st_john   this dame is really good
04:31:33 <lambdabot> Title: Lara St. John: Bach violin concertos
04:31:57 <ksf> it would work, yes.
04:32:38 <ksf> but i'm actually referring to me piecing together notes on the fretboard, as i don't read standard notation.
04:33:19 <ivanm> ksf: so what kind of non-standard notation _do_ you read?
04:33:41 <ksf> tabs
04:33:50 <ivanm> ahhhh
04:33:54 <ivanm> guitar tablature?
04:34:03 <ksf> yes.
04:34:33 <maltem> ksf: the old ones? keep in mind that lutes had various tunings :)
04:34:35 <solrize_> http://magnatune.com/artists/albums/berget-jsbach/  i havent downloaded this yet
04:34:36 <lambdabot> Title: Paul Berget: J.S. Bach on the Lute
04:35:43 <vixey> solrize_: cool! any idea where to get the code?
04:36:33 <solrize_>  code?
04:36:45 <solrize_> generic zipper?
04:36:57 <vixey> yeah
04:37:00 <jpcooper> maltem, do you play the lute?
04:37:08 <solrize_> i dunno, probably on google
04:37:22 <solrize_> i mean i think i saw something like it
04:37:23 <maltem> jpcooper: guitar merely
04:37:25 <solrize_> look on oleg's site too
04:37:35 <jpcooper> maltem, yes I was just playing some Dowland right now
04:37:36 <solrize_> he has a scheme one that uses delimited continuations
04:37:48 <solrize_> but also i think i saw one that did datatype differentiation a la conor
04:38:10 <maltem> heh we're close to opening up #haskell-guitar :)
04:38:48 <ivanm> maltem: we could just have a generic #haskell-audio...
04:38:54 <jjsa> im trying to install GLFW. My GHC binary distribution didn't come with OpenGL or this cabal thing so i install cabal and used it to install  OpenGL, it's put OpenGL in my home dir so I guess GHC still won't know where it is. When I try to add GLFW is just tells me it need OpenGL. New to all this so please be gentle :(
04:39:22 <lilac> jjsa: how are you installing glfw?
04:39:35 <jjsa> runhaskell Setup.hs configure
04:39:40 <lilac> add --user
04:40:12 <lilac> my guess is cabal has installed opengl for your user account rather than for the system
04:40:40 <lilac> and configure defaults to installing for the system, so it won't use your personal opengl install
04:40:47 <jjsa> Warning: No 'build-type' specified. If you do not need a custom Setup.hs or
04:40:48 <jjsa> ./configure script then use 'build-type: Simple'.
04:40:48 <jjsa> Setup.hs: dist/: openNewBinaryFile: permission denied (Permission denied)
04:41:16 <lilac> alternatively, install GLFW using cabal :)
04:41:26 <jjsa> That was my back up plan
04:41:28 <jjsa> :)
04:41:48 <jjsa> just annoys me when I can't get stuff to work :>(
04:42:25 <Saizan> you can run "cabal install" with no options from the GLFW directory
04:42:46 <ski_> hm .. what's the converse of "prerequisite" ? (as in "foo is a prerequisite of bar")
04:43:24 <vixey> ski_, obligation perhaps
04:43:25 <jjsa> Saizan: cool. thanks
04:43:59 <lilac> ski_: dependent?
04:44:11 <ski_> hm, that might work
04:45:21 <vixey> I just read the actual packrat parsing algorithm yesterday
04:45:26 <vixey> it's so clever :))
04:46:23 <lilac> jjsa: is there a ./dist directory? if so, is it owned by root?
04:46:33 <vixey> it's tieing the knot & have data recursion to get memoization
04:49:00 <jjsa> lilac: where should this ./dist dir be?
04:49:21 <lilac> it gets created in your GLFW  directory by the configure step
04:50:19 <vixey> http://pdos.csail.mit.edu/~baford/packrat/thesis/arith/ArithPackrat.hs
04:50:21 <lambdabot> http://tinyurl.com/5l6zsp
04:50:38 <jjsa> lilac: it is
04:50:41 <jjsa> owned by root
04:51:01 <jjsa> hrm, I'm positive i didn't run "runhaskell" as root
04:51:41 <lilac> if not, that's slightly scary :)
04:51:57 * jjsa is looking through the history
04:53:16 <jjsa> oh it did run that as root
04:53:19 <jjsa> heh
04:53:50 <jjsa> nevermind. I can run the graphics programs from my book with that SOE library now. Thanks for all your help to get me started.
05:08:59 <vixey> I think this packrat thing is ingenious
05:22:46 <araujo> morning
05:23:37 <vixey> hi
05:24:05 <Twey> G'day
05:24:29 <pao> hi
05:39:44 * ksf is flabbergasted by the fact that g++ completely unrolls folds.
05:40:24 <lilac> templates are like that
05:40:27 <ksf> ...inlining the func pointer.
05:40:32 <ksf> ...without templates.
05:40:50 * lilac still not surprised
05:42:22 <ksf> ...so I can guesstimate that fc++ isn't really slower than haskell.
05:43:03 <jpcooper> how do I list the symbols of a module?
05:43:06 <jpcooper> in ghci
05:43:14 <vixey> Module.<tab>
05:43:19 <Twey> jpcooper: You can type Foo.Bar.<tab>
05:43:21 <ksf> ...and pray.
05:43:23 <lilac> ksf: i'd expect it to be faster, since it won't do dictionary passing
05:43:24 <Twey> Aye.  :-P
05:43:24 <jpcooper> thanks
05:43:40 <jpcooper> this doesn't work in run-haskell
05:43:48 <lilac> @pl \(a:b) -> (a,b)
05:43:49 <lambdabot> liftM2 (,) head tail
05:44:06 <lilac> @hoogle [a] -> (a,[a])
05:44:06 <lambdabot> Data.Char readLitChar :: ReadS Char
05:44:07 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
05:44:07 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
05:44:12 <vixey> yeah run-haskell isn't ghci
05:44:12 <lilac> @hoogle [a] -> Maybe (a,[a])
05:44:13 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
05:44:13 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])
05:44:13 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:44:21 <vixey> :t uncons
05:44:23 <lambdabot> Not in scope: `uncons'
05:44:29 <lilac> @index uncons
05:44:30 <lambdabot> bzzt
05:44:40 <vixey> @let uncons [] = Nothing ; uncons (x:xs) = Just (x,xs)
05:44:42 <lambdabot>  Defined.
05:44:43 <ksf> mapAccumL...
05:44:47 <vixey> > unfoldr uncons [1,2,3]
05:44:49 <lambdabot>   [1,2,3]
05:45:04 <vixey> > foldr (:) [] [1,2,3]
05:45:06 <lambdabot>   [1,2,3]
05:45:09 <hcube> hi! is here a EHC developer or user ?
05:45:41 <ksf> anyone ever seen a beast like this? http://hpaste.org/12482
05:46:21 <ksf> if yes, what's the proper name?
05:46:48 <vixey> ksf, if you write it monadically in StateT or whatever it is, maybe it will be clearer what it is
05:46:52 <Twey> uncons (x:xs) = (x, xs) ?
05:46:55 <Twey> :t uncons
05:46:56 <lambdabot> forall t. [t] -> Maybe (t, [t])
05:47:11 <Twey> Ah
05:47:15 <vixey> Twey my:  uncons [] = Nothing ; uncons (x:xs) = Just (x,xs)
05:47:27 * Twey nods.
05:47:29 <ksf> a monad seemed to be overkill to me... it's basically mapAccumL, slightly expanded
05:47:33 <ksf> @src mapAccumL
05:47:33 <lambdabot> mapAccumL _ s []        =  (s, [])
05:47:33 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
05:47:33 <lambdabot>    where (s', y ) = f s x
05:47:33 <lambdabot>          (s'',ys) = mapAccumL f s' xs
05:47:49 <vixey> why would making something simpler be overkill ?
05:48:52 <ksf> overkill because st is Int
05:49:27 <ksf> http://hpaste.org/12482#a1
05:49:33 <hcube> is everyone using ghc ?
05:49:43 <vixey> hcube, pretty much
05:50:13 <ksf> everyone except oleg, he wrote his own compiler inside the type system.
05:51:38 <ksf> but then my mind might be still in scheme-land.
05:52:13 <ksf> (as you can see by the amount of parens ;)
05:53:05 <vixey> ksf, yeah I'd write both monadically and see what happens
05:57:05 <ksf> the whole thing's quite hacky, anyway. In another place, I'm calling runParser from inside a foldr.
05:58:27 <ksf> ...passing the parse result of the next line into the parser of the current to enable it to figure out what the syntax means.
05:59:57 <vixey> The biggest problem in that code is names like 'res' and 'f'
06:00:09 <ksf> hey
06:00:16 <vixey> :p
06:00:41 <ksf> without them, it'll be truly lispy.
06:01:05 <luite_> is it possible to make a type synonym for STUArray s Int Int  ? type MyArray = STUArray s Int Int  does not work because of the 's'
06:01:09 <ksf> inline lambdas and such.
06:02:17 <vixey> luite_, tried type Array s = STUArray s Int Int?
06:03:25 <luite_> oh why didn't I think of that before :)
06:03:33 <vixey> well it might not work!
06:03:36 <vixey> I'm just guessing..
06:03:58 <luite_> it does, but I do have to specify the s explictly everywhere now, so it's slightly uglier
06:05:36 <vixey> I don't have a clue how this  "!(!(A !b)) a* B !."  works :/
06:06:10 <blueonyx> hi, where can i find verboseCheck in QuickCheck 2.1.0.1?
06:07:51 <sam_> Problem: to define the subtraction of natural numbers when m - n = 0 if m < n and minus ⌈m⌉ ⌈n⌉ = ⌈m - n⌉. Do you know how to define substraction for natural numbers in lambda calculus?
06:08:31 <vixey> sam_: yes :D
06:08:49 <vixey> sam_: Do you know how to take the tail of a list using foldr? :)))
06:11:01 <dcoutts> Axman6: "cabal upgrade" does mean to upgrade all installed packages
06:11:02 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
06:19:04 <sam_> vixey: I do not know the foldr command.
06:21:19 <Twey> @src foldr
06:21:19 <lambdabot> foldr f z []     = z
06:21:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:22:29 <Twey> tailDef = foldr (flip const)
06:23:53 <sam_> how foldr function will help me in solving the problem?
06:26:34 <vixey> sam_: compare Succ (Succ Zero) with () : () : []
06:27:06 <vixey> (<--) = foldr (const Succ) Zero btw
06:27:23 <vixey> (-->) = foldN (() :) []
06:29:07 <sam_> vixey: Is this the solution in haskell?
06:49:24 <athos> hi all
06:49:43 <vixey> hi
06:56:39 <tcleval> hi i am having problems with vim plugin haskellmode-20081031.vba , can anyone help me? i get the following error message
06:56:42 <tcleval> Error detected while processing BufEnter Auto commands for "*.hs":
06:56:44 <tcleval> E666: compiler not supported: ghc
06:57:45 <mauke> apparently you don't have compiler/ghc.vim
06:57:49 <mauke> or it's in the wrong place
06:58:00 <vixey> tcleval: [expr 2+2]
06:58:06 <tcleval> lol
06:58:08 <tcleval> 4
06:58:35 <tcleval> i have ghc.vim... i put it on ~/.vim
07:02:42 <tcleval> mauke, fixed ^^ i created the 3 dirs necessary: ftplugin, doc  and compiler, and moved the files to the right place
07:02:45 <tcleval> thx
07:08:43 <Thruspa> @type Control.Exception.throw
07:08:44 <lambdabot> forall a. GHC.IOBase.Exception -> a
07:38:11 <defun> Hey, I am making some floss haskell software, and would like to know which license to use and why: GPL, LGPL, CDDL, CPL, MIT, BSD? Thanks.
07:39:41 <Stranger> audition hello, how are you?
07:40:20 <Raevel> defun: it depends on a lot of factors
07:41:23 <Raevel> for instance, if there are competing software with say bsd license, i wouldn't use gpl since then my software would be more restricted in comparison
07:41:36 <audition> Stranger
07:41:40 <audition> tupo idi nahuj
07:41:42 <audition> :DDDDDDD
07:43:04 <blueonyx> doesn't know anyone about verboseCheck in QuickCheck 2.1.0.1 :(
07:45:13 <alar> Cabal-1.6.0.1 doesn't build under WinXP with GHC-6.8.3
07:45:26 <alar> how can I fix it?
07:45:55 <Saizan> alar: you've to compile the Setup.hs with ghc --make, rather than using runghc
07:46:05 <Raevel> defun: an advantage (or disadvantage) of gpl is that everything it touches becomes gpl, so you could either choose gpl if you want that. If you choose a bsd-compatible license there's the risk that someone forks to gpl and if the fork becomes more popular they have pretty much decided the fate of the software
07:46:21 <Saizan> alar: it should be in the README, iirc
07:46:23 <Raevel> s/bsd-compatible/gpl-compatible/
07:46:38 <defun> i see. thanks.
07:46:43 * dcoutts hacks on a new representation for 'VersionRange's
07:47:09 <alar> thanks!
07:47:16 <alar> @karma+ Saizan
07:47:16 <lambdabot> Saizan's karma raised to 1.
07:47:36 <Saizan> np
07:47:57 <mauke> preflex: karma Saizan
07:47:57 <preflex>  karma for Saizan: 5
07:48:23 <alar> two lamdabots here?
07:48:26 * dcoutts invites hackers to get involved in Cabal development
07:48:28 <dcoutts> http://hackage.haskell.org/trac/hackage/report/13
07:48:34 <lambdabot> Title: {13} Easy tickets - Hackage - Trac
07:48:47 <mauke> bots, not lambdabots
07:49:04 <Raevel> defun: you might be able to get out of the latter problem by choosing a gpl-incompatible license, but i'm not sure!
07:50:01 <Raevel> dcoutts: oh groovy
07:50:21 <dcoutts> Raevel: spot something easy looking you want to hack on? :-)
07:51:04 <Raevel> hmmm
07:52:09 <naradapuri> Raevel: So if I understand correctly, you can either:
07:52:09 <naradapuri> 1) Choose GPL and become GPLized for ever
07:52:09 <naradapuri> 2) Choose GPL compatible license (or a combo like MPL+GPL) and risking somebody forking a more popular GPLized version
07:52:09 <naradapuri> 3) Choose GPL incompatible license
07:52:09 <naradapuri> am I right?
07:52:14 <olsner> Raevel: do it :)
07:52:51 <mauke> doesn't MPL allow forking a non-gpl'd version?
07:53:17 <Raevel> naradapuri: yep, that's what i said at least, but i'm no expert so i could be wrong
07:53:30 <Axman6> bah, screw the GPL
07:53:35 <dcoutts> naradapuri, Raevel: picking BSD doesn't stop a GPL fork
07:53:43 <dcoutts> since the BSD is gpl compatible
07:54:00 <Axman6> dcoutts: re: cabal upgrade... you're right, so it does, thanks
07:54:06 <dcoutts> preventing a GPL fork seems like going to too much work
07:54:15 <arw> wasn't there an obscure bsd variant that was gpl incompatible?
07:54:19 <Raevel> dcoutts: i didn't say it did, i think, i didn't mean it at least :-)
07:54:20 <arw> something about attribution-stuff?
07:54:27 <dcoutts> arw: original 4-clause BSD
07:55:00 <Axman6> bah: process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
07:55:14 <naradapuri> dcoutts: Yes, that's what I meant in 2). But AFAIK for example MPL isn't GPL compatible, is it?
07:55:33 <Raevel> it's not
07:55:42 <dcoutts> Axman6: you've probably got a package registered per-user and globally that's the same version, and that confuses Cabal
07:56:02 <Axman6> probably
07:56:04 <dcoutts> Axman6: so it thinks that the ghc package depends on the per-user registered instance rather than the global one
07:56:15 <dcoutts> Axman6: eg perhaps the Cabal lib itself
07:56:16 <Raevel> so, olsner you know, would i actually be able to help out with cabal? :-P
07:57:03 <Axman6> dcoutts: it'd be nice if cabal didn't just exit at the first error when doing cabal upgrade
07:57:08 <dcoutts> Axman6: I think the cabal-install bootstrap script isn't helping there, since ghc-6.10.1 comes with Cabal-1.6.0.1 and the script installs it
07:57:34 <dcoutts> Axman6: there's not a lot else it can do really. It does not want to try to install packages with inconsistent deps
07:58:09 <naradapuri> BTW, I'm new here, how do I give karma points to people that helped me? I could't find it on HaskellWiki
07:58:17 <mauke> naradapuri: "nick++"
07:58:21 <dcoutts> Axman6: what it could do, is to have a better solver that tries harder to find solutions. Eg using a SAT solver.
07:58:27 <Axman6> Axman6++
07:58:28 <Axman6> >_>
07:58:34 <mauke> preflex: karma Axman6
07:58:34 <preflex>  karma for Axman6: 1
07:58:40 <Axman6> excellent
07:58:55 <vixey> preflex: karma nick
07:58:56 <preflex>  karma for nick: -4
07:59:07 <Axman6> dcoutts: i don't know exactly what you mean, but i thik i follow, and that would be good
07:59:24 <dcoutts> Axman6: of course, but it's also quite a bit of work :-)
07:59:24 <mauke> Axman6: I dare you to increment yourself a bit more :-)
07:59:48 <Axman6> dcoutts: "bah, how hard could it be?"
08:00:07 <dcoutts> Axman6: heh heh
08:00:41 <dcoutts> Axman6: seriously, I'd estimate a couple weeks full-time work to do it properly
08:00:54 <Axman6> yeah wou;dn't surprise me
08:01:14 <Axman6> gah, my hand needs to stop averaging l and ' all the time
08:03:09 <Saizan> dcoutts: btw, is it intended that cabal install foo tries to install the latest version of foo and just fails if it can't be built on the current system? instead of trying to find an older that would build?
08:04:06 <Saizan> by "just fails" i mean it stops at configure
08:08:05 <hartke> Hello, http://hpaste.org/12484 i have a problem here... i want to create a data type CodeTree what i have to do
08:08:28 <hartke> i tried in the commented lines but it doesnt work
08:08:32 <vixey> hartke, just uncomment the line
08:10:27 <hartke> yeah i know but it does not work then
08:10:30 <mauke> remove ,
08:10:31 <Axman6> hartke: were you here earlier?
08:10:43 <hartke> yes i am the haskell noob
08:10:51 <Axman6> thought so
08:10:56 <dcoutts> Saizan: I'm not sure it should go testing lots of different versions if some fail.
08:11:03 <Raevel> dcoutts: okay, i'm going to give http://hackage.haskell.org/trac/hackage/ticket/413 a try
08:11:04 <lambdabot> Title: #413 (cabal --help should report the location of the config file) - Hackage - Tr ...
08:11:23 <hartke> im really trying to figure that out but no chance
08:11:25 <dcoutts> Saizan: the right thing to happen is that we update the hackage .cabal file with the info and then cabal install will select a different version
08:11:58 <dcoutts> Saizan: for most configure failures we ought to be able to check them before downloading, not for ./configure scripts of course.
08:12:14 <dcoutts> Raevel: ok, great, that's a nice easy one to start with.
08:12:20 <Axman6> hartke: you probably want "data CodeTree a b = Empty | Node (CodeTree a b) (CodeTree a b)" or data CodeTree a b = Empty | Node a b (CodeTree a b) (CodeTree a b)
08:12:31 <edwardk> hartke: we were all noobs at some point ;)
08:12:51 <dcoutts> Saizan: I'm thinking of deps on C libs for example
08:12:57 <Axman6> dcoutts: you couldn't do me a favour could you? just cabal install HARM and let me know of everything compiles ok
08:14:02 <hartke> hehe edward
08:14:15 <hartke> axman whats the difference between the two
08:14:20 <Saizan> dcoutts: that's what happens, e.g. trying cabal install haskell-src-exts on ghc-6.8.2, it will just fails saying that it requires base-4, rather than picking an older version that would work, so here the information is correct and complete
08:14:37 <Axman6> hartke: the second one actually contains data
08:15:26 * edwardk used to think of himself as n00bish. Now I think I am only a cultural n00b; I just witness the high holidays of Eternal September and Summer of Code.
08:15:45 <dcoutts> Saizan: ok, so that's a failure where the solver is not clever enough, I thought you meant it got to the stage of running configure and failing.
08:15:53 <edwardk> and every once in a while try to remember enough Haskell to code something in it.
08:15:53 <naradapuri> solrize_++
08:16:01 <hartke> i get the error CodeTree is not applied to enough type arguments
08:16:09 <dcoutts> Saizan: and yes, we can fix that one. I've been meaning to for a while. I can point you to the solution if you want to hack on it.
08:16:20 <Axman6> hartke: whats your code?
08:16:28 <edwardk> hartke: do you have a paste up of the use of CodeTree you are trying?
08:17:22 <edwardk> The version of CodeTree that Axman6 provided expects to be passed a couple of types as parameters for 'a' and 'b'. So, 'CodeTree Int String' or something like that, not just 'CodeTree'
08:17:59 <hartke> http://hpaste.org/12485
08:19:02 <Axman6> hartke: do you understand how your definition of CodeTree doesn't contain any data? its just a tree, you need to have data in each of the Nodes
08:19:09 <hartke> yes I neet CodeTree as a data declaration and my morseTree is a unique CodeTree
08:19:28 <edwardk> your morsetree isn't a codetree though, its a list of pairs.
08:19:36 <Axman6> but CodeTree and morseTree aren't related at all
08:20:09 <Axman6> i think you want data CodeTree = [(Char,String)], like i was telling you earlier today
08:20:15 <Saizan> dcoutts: ok for me :)
08:20:17 <dcoutts> Saizan: the trick, in the current solver, is to do a pass over all the packages first and try to configure them. If any cannot possibly be configured (eg wrong version of base) then we can exclude them before running the main solver.
08:20:44 <Axman6> could someone run cabal install HARM for me please? :\
08:21:00 <dcoutts> Axman6: it built ok for me with 6.10.1
08:21:00 <edwardk> i agree with axman6, start there, then you can use the built-in list manipulation functions on it.
08:21:16 <Axman6> dcoutts: ok, thanks :)
08:21:19 <vixey> what does it mean to compute a relation?
08:21:20 <dcoutts> Axman6: just one warning
08:21:41 <Axman6> that sounds ominous...
08:21:47 <vixey> compute a relation R is testing that (a,b) is in R?
08:21:47 <edwardk> sorry axman, I choose to remain harmless. ;)
08:22:26 <dcoutts> Axman6: presumably you must get the warning too? Arm/BinaryNumber.hs:99:9 no toInteger method given for the Integral Binary32 instance
08:22:30 * edwardk just realized that joke isn't funny any more as he is no longer signing into irc as 'harmless'.
08:23:11 <Axman6> dcoutts: yeah i'm getting it. its not my code, but i could probably add that to it
08:23:13 <Twey> mv edwardk mostly_harmless
08:23:30 <Axman6> :t toInteger
08:23:31 <lambdabot> forall a. (Integral a) => a -> Integer
08:23:47 <edwardk> twey: wouldn't i become 'mostly harmless' after a failed install?
08:24:21 <Twey> Haha, I guess you would at that.
08:24:24 <Axman6> :t from
08:24:25 <lambdabot> Not in scope: `from'
08:25:05 <Twey> class From a where from :: a -> b
08:26:42 <Saizan> from _ = undefined
08:27:26 <Axman6> dcoutts: all fixed
08:27:41 <edwardk> instance Show a => From a where from = error . show -- ? =)
08:28:00 <sdda> nobody answered me :/
08:28:12 <edwardk> ass: YOU DIDN'T SAY ANYTHING.
08:28:16 <edwardk> er
08:28:16 <vixey> sdda, you didn't ask anything
08:28:17 <edwardk> wow
08:28:18 <vixey> hahaha
08:28:22 <edwardk> funny off by one error
08:29:11 <edwardk> woops sdda and ass<capslock> are apparently right next to each other.
08:29:13 <sdda> vixey,  i ask to you in your query.But i guess you dont look your query :/..Anyway my question is about scheme.And this is nott scheme channel :/
08:29:31 <hartke> So is it correct that when i use data CodeTree = Empty | Node Char CodeTree CodeTree that I have to redo my whole morseTree?
08:29:35 <mauke> then why are you complaining here?
08:29:37 <edwardk> hartke: yes
08:29:43 <vixey> It's haskells fault
08:29:51 <edwardk> for drawing vixey away
08:30:36 <Axman6> hartke: yes, but you'd be better off using data CodeTree = [(Char,String)], then morseTree :: CodeTree
08:30:46 <edwardk> luring her away with its siren song of types. Not to mention the chance of correspondence with Curry and Howard.
08:31:03 <mauke> Axman6: syntax error
08:31:07 <mauke> did you mean 'type'?
08:31:09 <Twey> Hahaha
08:31:17 <Axman6> probably
08:31:28 <hartke> Axman, but i have to build a Tree
08:31:35 <hartke> so i need Nodes and so on
08:31:48 <Axman6> ok, well morseTree is going to have to change
08:31:51 <hartke> because in this moment it only searches the list every element
08:33:23 <qsorix> Hello everyone, I'm thinking about writing some parallel code using Haskell and run it on distributed machines... ATM I'm using MPI and C++ but I see that hMPI is pretty much dead. Are there any libraries you could recommend?
08:34:06 <qsorix> I've googled a little bit, but It's hard to tell just from reading about it, if anything is really worth trying
08:35:20 <edwardk> @seen sbahra
08:35:20 <lambdabot> sbahra is in ##logic, #ghc, #haskell, ##freebsd, #haskell-blah and #xmonad. I last heard sbahra speak 14h 24m 41s ago.
08:38:24 <Twey> qsorix: Erlang is really designed for this sort of thing
08:38:41 <Axman6> i was thinking the same thing
08:38:47 <ksf> there's data parallel haskell.
08:39:03 <Axman6> it's not for distributes computation
08:39:26 <Twey> You can do distributed computing in Haskell, of course, but you don't get as much for free as you do in Erlang
08:39:26 <ksf> then i'm mixing up stuff.
08:39:39 <Twey> (although certainly it's easier than doing it in C++ still)
08:39:59 <Twey> Unless there's a really nice distributed library of which I'm unaware.
08:40:01 <Twey> That's not too unlikely.
08:41:24 <naradapuri> What is hpaste.org for? Do I understand it correctly that it's a simple buffer for pieces of code for Haskell developers?
08:42:07 <Axman6> it's just a pastebin that has haskell syntax highlighting
08:45:32 <qsorix> Twey, I don't want to get anything for free, I just wanted to try and see how it will look
08:47:09 <qsorix> All I have found using google is that Glasgow Parallel Haskell but from its site I can't tell if it's something I should investigate further
08:47:34 <Axman6> i think all the GPH stuff is now in ghc
08:51:22 * gwern reads an email I wrote past midnight. 'I don't know how to fix this sort of removed the Shim modules from yi.cabal entirely.' Ouch. at least 2 flagrant grammar and spelling errors. that'll teach me to write emails so late
08:52:33 <Axman6> too late* :)
08:53:06 <Axman6> you know, there's quite an art to making pouches for things out of duct tape
08:53:07 <gwern> (and arguably a third error would be the lack of comma after 'this')
08:54:53 <bbs> i
08:54:58 <bbs> oops
08:55:01 <bbs> i still cannot get over the fact that my schools over
08:55:31 <Axman6> over what?
08:56:55 <gwern> Axman6: over a barrel, presumably
08:57:00 <gwern> due to the weak economy
08:57:40 <athos> > join "aa" "bb"
08:57:42 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
08:57:51 * gwern notes that yi is broken. hm.
08:58:06 <Axman6> gwern: haven't you been saying that all day?
08:58:15 <athos> lol :>
08:58:31 <Axman6> athos: join does not do what you think it does...
08:58:34 <Axman6> :t join
08:58:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:58:51 <Axman6> > join $ Just (Just 1)
08:58:53 <lambdabot>   Just 1
08:59:00 <Axman6> > join $ Just Nothing
08:59:02 <lambdabot>   Nothing
08:59:06 <Axman6> > join $ Nothing
08:59:08 <lambdabot>   Nothing
08:59:25 <Axman6> > join [[1,2,3],[4,5,6]]
08:59:27 <lambdabot>   [1,2,3,4,5,6]
08:59:28 <athos> > join ["foo", "bar"]
08:59:30 <lambdabot>   "foobar"
08:59:42 <athos> ok :>
08:59:57 <gwern> Axman6: no, I mean yi is really broken right now :) as in you start it and you can't do anything because the keymap is messed up
09:00:26 <shapr> Will haskell-mode have any problems with .ly files?
09:21:54 <killer_st> hi. i have sort of stupid question..
09:21:55 <Raevel> so i made a tiny change to cabal and built it using runhaskell, but i find no executable. How can i run cabal so i can see my changes? make a separate haskell executable? link in cabal-install somehow?
09:22:02 <Saizan> dcoutts: btw, i don't exactly get why the one depending on base-4 are not excluded in .TopDown.searchSpace, is this because of the special-casing of base3/4 ?
09:22:15 <edwardk> killer_st: ask, and have its stupidity confirmed.
09:22:16 <dcoutts> Raevel: it's a lib
09:22:29 <dcoutts> Raevel: but you can compile the Setup.hs, that's the default entry point
09:22:36 <killer_st> here's a bit of code http://hpaste.org/12486
09:22:49 <edwardk> @seen bos
09:22:49 <lambdabot> bos is in #haskell and #ghc. I don't know when bos last spoke.
09:23:10 <Raevel> dcoutts: yes, that's what i did
09:23:13 <dcoutts> Saizan: no, it's just that by the time it's picked that one it doesn't do any backtracking
09:23:49 <dcoutts> Saizan: if it did backtracking it's work (but that brings other problems) so the trick in this style of solver is to realise it's impossible at an earlier stage
09:23:51 <Raevel> (i think)
09:24:04 <dcoutts> Saizan: or to do a little bit of local backtracking
09:24:12 <Raevel> oh, n/m here we go, thanks
09:24:21 <Axman6> killer_st: i'd call that more of a statement personally
09:24:47 <dcoutts> Raevel: hang on though, you're changing the --help for the cabal command line tool right?
09:25:02 <dcoutts> Raevel: so that does need to be done in the cabal-install package, not the Cabal lib
09:25:22 <dcoutts> Raevel: the cabal program is in the cabal-install package, the lib is in the Cabal package
09:25:30 <Raevel> oh. i was looking through them both and found what i thought was the place in the cabal repo
09:25:43 <Raevel> alrighty then
09:25:43 <killer_st> i think i've just understood what's wrong myself.. can i define a function that accepts either a list or a custom data type like Pair?
09:25:50 <athos> :t zip
09:25:51 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
09:25:58 <dcoutts> Raevel: the setup you build with the Cabal lib is of course a program, but it never uses the config file, that's just the cabal-install front end
09:26:20 <athos> > zip [1,2,3] [2,3,4]
09:26:22 <lambdabot>   [(1,2),(2,3),(3,4)]
09:26:27 <Raevel> okay
09:26:30 <Axman6> killer_st: type Thing a b = Pair a | [b]
09:26:34 <Axman6> that should work
09:26:51 <Axman6> hen you have a function tat accepts Thing a b and returns... somethign
09:27:03 <mauke> killer_st: no
09:27:05 <dcoutts> Saizan: in the searchSpace stuff, it picks the package, commits to it, and then tries to configure it.
09:27:23 <mauke> killer_st: but you can accept the type Either [a] (Pair a)
09:27:36 <Axman6> mauke: is what i said wrong then?
09:27:36 <dcoutts> Saizan: an alternative would be to check each of the versions to see if they can be configured and only fail if none can be configured
09:27:50 <dcoutts> Saizan: that'd be local backtracking
09:27:53 <mauke> Axman6: yeah, you can't use | in type
09:27:59 <Axman6> ah i see
09:28:59 <killer_st> aha, thanks
09:29:47 <Axman6> well, bed time. night all
09:29:55 <gwern> peculiar. my yi.hs loads in ghci fine but fails with link errors in ghc
09:31:53 <athos> @hoogle zip
09:31:54 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
09:31:54 <lambdabot> Data.ByteString zip :: ByteString -> ByteString -> [(Word8, Word8)]
09:31:54 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
09:33:42 <gwern> this meachem thread is fun. he says repeatedly that everywhere cabal works, make would work as well
09:34:09 <gwern> ...except I managed to compile jhc once. and I had to send in patches to the make file to get even that. I haven't had a single problem with lhc
09:34:23 <gwern> *with compiling
09:34:27 <dcoutts> interesting data point
09:34:36 <athos> :t unzip
09:34:37 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
09:34:41 <dcoutts> gwern: he's mostly justified though I think
09:35:09 <athos> unzip [(1, 2), (2, 3), (3, 4)]
09:35:25 <athos> > unzip [(1, 2), (2, 3), (3, 4)]
09:35:27 <lambdabot>   ([1,2,3],[2,3,4])
09:35:52 <gwern> dcoutts: yeah. I figure I'll send in a snarky email pointing out: 1) no, that's not true. 2) no, that's not true. he's entitled to argue that make will reach more people, but not to ignore the fact that haskellers used make for a decade and a half, and it's when we started using cabal that things picked up
09:35:53 <vixey> @let ununzip = uncurry zip
09:35:54 <lambdabot>  Defined.
09:35:57 <vixey> > ununzip ([1,2,3],[2,3,4])
09:35:59 <lambdabot>   [(1,2),(2,3),(3,4)]
09:36:21 <dcoutts> gwern: that's not inconsistent with his points though
09:36:23 <gwern> I really hate when people argue something where the facts flatly contradict it
09:37:00 <athos> :t uncurry
09:37:01 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:37:03 <dcoutts> gwern: he's talking about jhc, you're talking about 100's of simple little Haskell libs
09:37:16 <gwern> and john is lying throughout the thread (or else lemmih is)
09:37:19 <gwern> 'Hmm.. This one is news to me.'
09:37:33 <gwern> that quote is from *days* after lemmih emailed him with the first patch bundles
09:38:20 <gwern> or how about how he's still substanially developing it? nevermind that the last patch in his repo was from april - and it was mine
09:38:56 <dcoutts> gwern: Lemmih could well have sent him patches without mentioning any fork
09:39:32 <gwern> dcoutts: when he rejected the patches, lemmih tried to convince him to take them
09:39:47 <dcoutts> gwern: don't get me wrong, I think it's great that Lemmih is making jhc better and easier to install.
09:39:57 <dcoutts> even if that means forking
09:39:59 <gwern> somehow I think Lemmih mentioned the prospective fork somewhere in the emails...
09:40:33 <dcoutts> gwern: and John said he knew that Lemmih was considering forking, just not that he eventually did so
09:41:13 <dcoutts> gwern: I don't see any inconsistency, just a lack of communication
09:41:36 <gwern> you're a better man than I, Gunga Din
09:43:00 * dcoutts has been serving in a jury all week so has been looking for inconsistency in people's statements
09:43:21 <shapr> haha
09:50:01 <thoughtpolice> gwern: glad you haven't had any problems. the build failure on hackage is a very annoying problem that can come up when using TH sometimes, unfortunately
09:50:29 <dcoutts> thoughtpolice: oh, you had a cabal Q earlier, but I can't remember what it was. Do you recall?
09:52:42 <thoughtpolice> dcoutts: oh right, I was wondering if you have permission to remove things on hackage?
09:53:32 <dcoutts> thoughtpolice: ah yes, the answer is no. Things stay there in perpetuity. You get to manage the version numbers how you like subject to the standard ordering.
09:53:57 <thoughtpolice> dcoutts: the problem is when lemmih first uploaded lhc, he put it under the version '20081121', and then we made some very nice improvements and I re-uploaded the package, but under the version number we stuck it with then, which is 0.6.20081127, so by cabals reasoning, 20081121 > 0.6.20081127
09:54:09 <dcoutts> thoughtpolice: right
09:54:16 <thoughtpolice> so it will by default go to the old package
09:54:21 <dcoutts> yes
09:55:13 <dcoutts> there are two possibilities, one is we make an exception and remove the old package
09:55:40 <dcoutts> the fact that it's not been there for long and if you want to argue it was a mistake
09:55:49 <arjanb> i see a lot of projects taking a few attempts before having a correct upload
09:56:02 <hartke> hello and sorry again: so now ive rebuild my haskell code to a tree and im rewriting dec1... the Empty list works but how do I get my char
09:56:11 <dcoutts> arjanb: they usually just use x.y.z.0, x.y.z.1, x.y.z.2 etc, that's fine.
09:56:15 <hartke> this is my actual code http://hpaste.org/12487
09:56:18 <arjanb> so it might be useful to add a feature to hide broken upload
09:56:43 <dcoutts> arjanb: that's true
09:57:00 <dcoutts> and that's the other possibility, we can add a suggested version constraint
09:57:28 <dcoutts> which amounts to black-listing the old package
09:57:36 <dcoutts> sort-of
09:58:18 <hartke> So i need a Char (expected) but inferred is Char-> CodeTree->CodeTree->CodeTree (because of Node) so my question how do I get my Char
09:58:55 <Raevel> hartke: do you mean: dec1 (Node char _ _) _ = char ?
10:02:47 <jethr0> hartke: could you give some more background on what you're trying to do?
10:03:49 <hartke> Ive build my Tree with Nodes
10:04:10 <hartke> and now i would like to search a elemnt in the tree
10:04:28 <Raevel> i see
10:04:48 <Raevel> so, you need to check if the current node has the correct element, or else search the branches
10:05:00 <hartke> yes
10:05:10 <hartke> and dec1 needs a tree
10:05:15 <Raevel> right
10:05:18 <hartke> which should be my morseTree
10:05:39 <hartke> and the output should be the char
10:05:58 <hartke> and i dont know how the syntax is to reffer to my morseTree
10:06:05 <Raevel> okay
10:06:11 <Raevel> you need to do some pattern matching
10:06:58 <Raevel> dec1 (Node char branchA branchB) s = ... will bind the three values to char, branchA and branchB respectively
10:07:38 <hartke> ah ok so after = i have to do a if else correct?
10:07:43 <naradapuri> I asked about 10 hours ago how to implement memoization of a function using the State monad. I made a sample program that I'm quite happy with, just that it relies on Map. It would perfect if it could be made more generic so that Map wouldn't be hardwired in the actual function definition. If anybody is iterested to help: http://hpaste.org/12488
10:08:09 <Raevel> hartke: yes, that works
10:09:08 <jmarloth> Is there a way to tell cabal install to use -XPostfixOperators while compiling xmonad-contrib?
10:09:29 <dcoutts> jmarloth: change the .cabal file or pass --ghc-options=-XPostfixOperators
10:10:44 <jmarloth> Thanks a bomb
10:12:30 <Raevel> dcoutts: am I on the right track with (globalConfigFile defaultGlobalFlags) ?
10:12:48 <jethr0> naradapuri: i'm not sure what you are looking for. either you pass around the "m" parameter in all type declarations (or let them be determined dynamically) or you have to hide everything in an abstract data type (i.e. with hidden implementation).
10:12:59 <_MaK_> naradapuri: make a class for this operations?
10:13:05 <jethr0> naradapuri: how would you propose to pass the relevant functions (update, modify, ...) to the code?
10:13:59 <jethr0> yes, a type class would also work...
10:14:42 <naradapuri> well, I don't have an exact idea how to do it
10:14:45 <dcoutts> Raevel: actually that'll be empty, you want defaultConfigFile from the Config module, which you'll have to export.
10:15:12 <Raevel> yeah i noticed it was empty, wondered if i didn't have a config file specified
10:15:13 <dcoutts> Raevel: see the def of defaultGlobalFlags, it's mostly empty values
10:15:19 <Raevel> right
10:15:43 <naradapuri> I thought of creating a class of some sort for which I could define a Map instance, [] instance, etc. but I couldn't figure how
10:15:54 <dcoutts> Raevel: if you see where it's used in loadConfig it does:
10:15:54 <dcoutts> configFile <- maybe defaultConfigFile return (flagToMaybe configFileFlag)
10:16:21 <jethr0> naradapuri: you could do it with a type class "Memoization" that defines the three key functions (update, modify, ...) and implement that for relevant container types
10:16:36 <dcoutts> Raevel: defaultGlobalFlags should probably be called empty instead
10:16:47 <naradapuri> So that if I use the type "Cache a b (Map a b)", for example, it would automatically choose the proper operations
10:17:28 <naradapuri> that's what I tried, but since I'm still learning haskell, I couldn't figure it out
10:19:04 <Raevel> ok, i think i'll be able to finish this now
10:19:10 <jethr0> gotta run... bbl
10:21:51 <dcoutts> Raevel: hmm, it's trickier than it looks actually
10:22:00 <Raevel> oh no :*/
10:22:13 <dcoutts> since finding the location of the config file is in IO
10:22:20 <naradapuri> jethr0: I wasn't unable to define the Memoization class. It seemed to me, that it would have to be parametrized by more than one type -- a, b, and Map a b or something like that. (I still have problems that I'm too used to OO classes, which are quite different from Haskell's).
10:22:33 <Raevel> why does that make it tricky?
10:22:48 <dcoutts> Raevel: well the help message is a pure function
10:23:04 <Raevel> aha
10:23:21 <dcoutts> Raevel: you see the commandDescription in the globalCommand right? it takes the pname as a parameter
10:23:45 <Raevel> right
10:24:22 <dcoutts> you could make globalCommand take a parameter, but that's kind of annoying since it's used elsewhere where we could only really pass a dummy value
10:24:46 <dcoutts> that'd work I guess
10:25:01 <dcoutts> or you can override the description field of the global command when you use it in main
10:25:02 <_MaK_> naradapuri: w8 sek im writing this class ;]
10:26:08 <Raevel> the second one sounds worse, am i right?
10:26:54 <naradapuri> _MaK_: thanks :)
10:29:43 <hartke> Raevel now im stuck at the different cases, im trying to get the first char with head but how do I choose that my tree should go left or right to output the right char
10:30:20 <Raevel> hartke: well, you can't decide which one, so you will have to try one and try the next if it failed
10:32:47 <Botje> hartke: try working out how to construct your morse tree from the list of Chars and Strings
10:34:53 <vixey> ehh ?
10:35:09 <Botje> hmm
10:35:11 <vixey> hartke, hpaste all what you have currently?
10:35:14 <Botje> i'm probably reading the wrong paste :)
10:35:21 <Botje> ignore me!
10:39:20 <walski> Hi there
10:40:13 <walski> How can I "split" a list in a manner like: take the first element of the list and keep the rest of the list as a list?
10:40:25 <daf> use pattern matching
10:40:47 <walski> e.g. when I have a function called decodeWord which takes a String and returns a String
10:40:49 <vixey> :t uncons
10:40:50 <lambdabot> forall t. [t] -> Maybe (t, [t])
10:40:55 <vixey> lol decodeWord
10:45:15 <walski> :/ Can't get it. http://pastie.org/326715 This is the function how I would like it to be ;)
10:45:21 <lambdabot> Title: #326715 - Pastie
10:45:37 <Botje> walski: (firstChar:remaiing)
10:45:46 <Botje> that's what we mean by pattern matching
10:45:58 <Botje> decodeWord (TreeNode ...) (first:rest) = ...
10:46:05 <Botje> then first is the first char, rest the string
10:46:06 <walski> ok, thanks a lot!
10:46:12 <walski> I'll give it a try
10:47:27 <acidjnk> hello
10:47:40 <acidjnk> I tried my own concat implementation: cc :: [[a]]->[a]; cc [[]] = []; cc [[],a] = a; cc [x:xs,a] = x : cc [xs,a];
10:47:46 <acidjnk> How can I handle more than two elements in the list?
10:48:03 <Botje> uh
10:48:07 <Botje> use pattern matching :)
10:48:44 <acidjnk> One case for every element?
10:48:56 <Botje> cc ((x:xs):xss = x : cc (xs:xss)
10:49:07 <sjanssen> Botje: that won't parse
10:49:19 <Botje> damn parens.
10:49:21 <sjanssen> cc ((x:xs):xss) = ...
10:49:29 <Twey> concat = foldr (++) []
10:49:29 <Botje> cc ([]:xss) = cc xss
10:49:34 <Botje> cc [] = []
10:49:40 <Botje> that's enough to make your implementation work, acidjnk
10:50:31 <acidjnk> Let's have a closer look at " cc ([]:xss)".
10:50:37 <acidjnk> So [] is a list.
10:50:40 <acidjnk> What is xss?
10:50:45 <Botje> a list of lists
10:50:52 <Botje> :t (:)
10:50:53 <lambdabot> forall a. a -> [a] -> [a]
10:50:59 <Botje> note that a can be _any_ type
10:51:47 <Botje> so ..
10:52:11 <acidjnk> I understand. when a is already a list, then that after the : is automatically a list of lists.
10:52:12 <acidjnk> thanks.
10:52:14 <Botje> :t ([]:[[]])
10:52:15 <lambdabot> forall a. [[a]]
10:52:26 <acidjnk> also @twey, the is a better approach than mine :-)
10:53:40 <Twey> concat [] = []; concat (l:ls) = l ++ concat ls
10:53:47 <Twey> If you want to do it recursively
10:53:51 <_MaK_> naradapuri: hmm i done it but its quite strange, second test isnt finishing...
10:55:39 <acidjnk> Interesting that merly a being a list in a->[a] blocked all my further thoughts.
10:55:41 <roconnor> ([]:[[]]) -- really eval robot monkey with a hat???
10:55:45 <roconnor> evil
10:55:51 <roconnor> ... but eval is funnier I guess
10:55:56 <_MaK_> naradapuri: http://hpaste.org/12488#a1
10:56:13 <naradapuri> _MaK_: Still, I'm interested. I'll have a look
10:56:23 <Botje> acidjnk: your head will explode a couple more times. get used to it :)
10:56:38 <acidjnk> Yes, but this was very easy.
10:56:39 <walski> :/ http://pastie.org/326722
10:56:40 <lambdabot> Title: #326722 - Pastie
10:56:42 <acidjnk> That concerns me.
10:57:00 <walski> Looks like parse pattern isn't my friend today
10:57:01 <walski> morse.hs:61:2: Parse error in pattern
10:57:16 <walski> :/ I mean pattern matching
10:57:22 <Botje> ah, so walski was the morse guy :)
10:57:32 <Botje> walski: put parens around it
10:57:36 <Botje> ('-':s)
10:59:11 <walski> Things can be so easy ;)
10:59:32 <walski> I think I'm not "the" morse guy. It's this weeks exercise here at the university
10:59:32 <naradapuri> _MaK_: What does '... | a b -> m ...' in 'class CacheClass a b m | a b -> m where' mean?
10:59:43 <walski> so I think I'm not the only one who needs a little help ;)
10:59:47 <acidjnk> :t replicate
10:59:49 <lambdabot> forall a. Int -> a -> [a]
11:00:12 <sheyll> hi
11:00:21 <acidjnk> Why is there suddenly an Int? Why not n->a->[a] or Int=>n->a->[a]?
11:01:06 <mauke> because you don't need more than 1 billion elements in a list :-)
11:01:14 <Botje> naradapuri: it's a functional dependency. It helps haskell decide which typeclass instance to use
11:01:29 <Botje> acidjnk: because Int is not a typeclass
11:01:38 <Botje> and for 99.999% of all uses, an int will suffice
11:01:45 <acidjnk> so before a => comes a typeclass?
11:01:51 <Botje> yes
11:01:54 <acidjnk> And Int is just a type?
11:01:54 <Botje> for example
11:01:56 <Botje> :t sort
11:01:57 <lambdabot> forall a. (Ord a) => [a] -> [a]
11:02:00 <Botje> vs
11:02:04 <naradapuri> Bojte: I've never seen that before, I suppose it's some kind of GHC extension? Where can I find some reading about it?
11:02:06 <Botje> :t sort [1,2,3]
11:02:07 <lambdabot> forall t. (Ord t, Num t) => [t]
11:02:12 <mauke> tee hee
11:02:30 <Botje> naradapuri: i believe there's a paper about it. check the haskell.org wiki or google for them
11:02:55 <acidjnk> So Ord is a typeclass?
11:03:04 <Botje> yeah
11:03:09 <mauke> @src Ord
11:03:09 <lambdabot> class  (Eq a) => Ord a  where
11:03:09 <lambdabot>     compare      :: a -> a -> Ordering
11:03:09 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
11:03:09 <lambdabot>     max, min         :: a -> a -> a
11:03:25 <mauke> expert type misalignment
11:03:26 <Botje> if you type :info Ord in ghci you can get some cool stuff about it
11:03:29 <_MaK_> naradapuri: chech new version, i do some another mess with it ;]
11:03:59 <naradapuri> _MaK_: I'm also trying :)
11:04:51 <acidjnk> I find this very confusing. In pure math I only know sets. In Haskell there seem to be three concept which share the attributes of a mathematical set: the thing where you get stuff out with a <-, then types like Num and typeclasses.
11:05:01 <acidjnk> 3 things, which are 1 in my head.
11:05:04 <naradapuri> Botje: Thanks, I found it. Actually, that's exactly what I've been looking before. http://www.haskell.org/haskellwiki/Functional_dependencies
11:05:05 <lambdabot> Title: Functional dependencies - HaskellWiki
11:05:23 <mauke> acidjnk: Num is a not a type; it's a typeclass
11:05:27 <acidjnk> I tried to store "<-" as an ascii-notation for the element symbol, but that didn't help.
11:05:31 <_MaK_> this is without functional dependecies but only for boxes having kind (*->*->*)
11:05:35 <mauke> acidjnk: things you get stuff out with "<-" are not sets
11:05:48 <Botje> mauke: i think he's referring to list comprehensions
11:05:48 <acidjnk> yes they are
11:05:54 <mauke> unless you think functions are sets
11:06:05 <acidjnk> :[a|a<-[1..3]]
11:06:17 <mauke> > (do { x <- sqrt; return x }) 2
11:06:19 <lambdabot>   1.4142135623730951
11:06:19 <arjanb> _MaK_: why combine it in one class and not have a separate MapLike class and Cache type?
11:06:23 <acidjnk> In math notation that's the same, with "<-" being replaced by the element-symbol.
11:06:26 <Twey> Functions are kind of sets.
11:06:27 <mauke> acidjnk: what set is sqrt?
11:06:47 <Botje> acidjnk: types and typeclasses do indeed form sets
11:06:58 <acidjnk> No idea @sqrt.
11:07:07 <acidjnk> but here, set too: [a|a<-[1..3]]
11:07:13 <mauke> acidjnk: no, that's a list
11:07:21 <acidjnk> That's valid math notation when you replace  <- by the element symbol!
11:07:27 <Twey> But it's not a set.
11:07:28 <naradapuri> _MaK_: I'm trying to arrange the class so that it just abstract the Map-like operations: empty, update, insert. IMHO it shouldn't call cache - actually cache should call CacheClass's insert
11:07:34 <mauke> > [a | a <- [1,1,1,1]]
11:07:35 <lambdabot>   [1,1,1,1]
11:07:40 <acidjnk> Yes it is, everything with an element symbol refers to a set.
11:07:40 <mauke> math would give you {1}
11:07:44 <Twey> Doesn't have to be unique, and it's ordered.
11:07:48 <mauke> ok, now you're just trolling
11:08:15 <acidjnk> that's a good point @list
11:08:33 <acidjnk> I've just never had a list with duplicates.
11:08:36 <Twey> If you want sets, they're available in Data.Set.
11:09:06 <mauke> acidjnk: 1) we don't have element symbols and 2) sets don't support <-
11:09:08 <_MaK_> naradapuri: as you want, i thing thats better way to make interface for caching not for functions of boxes
11:09:30 <Twey> Well, you can fromList
11:09:52 <Twey> > Data.Set.fromList [a | a <- [1, 1, 1, 1]]
11:09:54 <lambdabot>   /tmp/3770995264284344713:70:48: Not in scope: `Data.Set.fromList'
11:09:58 <acidjnk> Thanks, I must reset what I learned so far and start over. Understood it all wrong.
11:09:58 <Twey> Bah :(
11:10:04 <acidjnk> Or give up.
11:10:13 <acidjnk> But I see it now.
11:10:32 <Twey> acidjnk: Think in terms of programming, not in terms of maths.
11:10:46 <_MaK_> naradapuri: hmm i found why second test wasnt stoped, becouse i use wrong types... ;]
11:10:55 <Twey> And remember, a superficial syntactic resemblance does not equivalence make.  :)
11:11:21 <vixey> types are sets
11:11:51 <mauke> then what's a set of sets?
11:11:55 <acidjnk> It helped for a while, because in math there are often set definitions like Solutionset = {x elementof N+|x<-4}. But I never should have thought about it that way.
11:12:14 <vixey> acidjnk, x<-4 ??
11:12:21 <acidjnk> <=
11:12:26 <acidjnk> smaller or equal
11:12:42 <mauke> > [x | x <- [1 ..], x <= 4]
11:12:42 <vixey> acidjnk, this is where the list comprehesions come from
11:12:57 <lambdabot>   thread killed
11:13:01 <acidjnk> Yes, dangerous.
11:13:31 <Twey> mauke: A kind?  :)
11:14:25 <mauke> what's the type equivalent of {0, {0,1}, {0,{0,1}}}?
11:14:37 <pumpkin-> what are curly brackets?
11:14:45 <mauke> { }
11:14:46 <sheyll> > take 4 [x | x <- [1 ..], x <= 4]
11:14:48 <lambdabot>   [1,2,3,4]
11:14:53 <sheyll> > take 5 [x | x <- [1 ..], x <= 4]
11:15:01 <Botje> mauke: a type error?
11:15:01 <pumpkin-> mauke: I mean, what do they mean?
11:15:08 <mauke> pumpkin-: a set
11:15:09 <lambdabot>   thread killed
11:15:34 <pumpkin-> mauke: ooh interesting, is that haskell syntax?
11:15:43 <pumpkin-> oh, no :(
11:15:54 <Twey> Heh
11:15:55 <Twey> It's Erlang syntax!
11:16:02 <Twey> Although it's not a set there, either...
11:16:16 <pumpkin-> :(
11:16:17 <mauke> VALID PERL CODE
11:16:24 <pumpkin-> I loooovez me some setz
11:16:33 <sheyll>  (0, (0,1), (0,(0,1)))
11:16:43 <sheyll> :t (0, (0,1), (0,(0,1)))
11:16:45 <lambdabot> forall t t1 t2 t3 t4 t5. (Num t5, Num t4, Num t3, Num t2, Num t1, Num t) => (t, (t1, t2), (t3, (t4, t5)))
11:17:17 <Twey> mauke: You can say that about any string of ASCII symbol characters, can't you?  >.>  :-P
11:17:36 <mauke> Twey: far from it
11:17:52 <mauke> e.g. '?' is not a valid perl program
11:18:05 <Twey> $*#@$@#^(${!{@#{*&%#&#$)#${}$}}#$}}@ VALID PERL CODE
11:18:11 <mauke> true
11:18:13 <Twey> I know, I'm exaggerating terribly.  Pardon me.  :)
11:18:19 <mauke> but only because everything after # is a comment
11:18:27 <Twey> Hehe
11:18:28 <Botje> Twey: you sure have a weird way of commenting your code :)
11:18:30 <dolio> Is that also valid J?
11:19:01 <mauke> perl -MO=Deparse -e '$*#@$@#^(${!{@#{*&%#&#$)#${}$}}#$}}@'
11:19:06 <ddarius> dolio: I don't think so.
11:19:12 <mauke> Twey: oh, and $* is deprecated
11:19:17 <dolio> :)
11:19:24 <Twey> $* exists?  Oh dear
11:20:05 <mauke> for all characters c. not (isspace c) => exists $c
11:20:08 * Twey adds this to vis Dictionary of Nuttily and Completely Meaninglessly Named Perl Variables, along with such greats as $@ and $_.
11:20:09 <mauke> or something like that
11:20:21 <mauke> oh, ${ and $} don't exist either
11:20:34 <Twey> Does $£?  :-P
11:20:43 <Twey> $€ perhaps?
11:20:43 <mauke> Twey: you think that's weird? wait until you see $^X where ^X is a literal control character
11:20:52 * Twey winces.
11:20:56 <Twey> $?
11:20:59 <mauke> yes
11:21:08 <Twey> Oh, darn you IRC/irssi
11:21:16 <Twey> Bolded
11:21:23 <mauke> $? is the exit status of the last child process
11:21:45 <Botje> % perl -e '$€ = 5'
11:21:45 <Botje> Unrecognized character \x82 in column 3 at -e line 1.
11:21:45 <mauke> $@ is the current exception; $^X is the name of the perl executable
11:21:47 <Botje> awwh.
11:21:48 <Twey> So, for example, $^x represents C-x?
11:22:01 <Twey> Oo-er.
11:22:09 <dons> morning all.
11:22:09 <lambdabot> dons: You have 11 new messages. '/msg lambdabot @messages' to read them.
11:22:17 * Twey chuckles.
11:22:21 <Twey> dons: Nice wakeup call
11:22:24 <Botje> dons has a secret admirer?
11:22:34 <Twey> Side effect of being famous.
11:22:51 <Twey> Now you know why Haskell tries to avoid it.  :-P
11:23:16 <blueonyx> heya, i got data VTree = S | W | V VTree VTree VTree VTree, and a function which takes a VTree, is there a pattern wich matches all VTrees with a depth of 1? like f (V W W W W) and f (V S W S W)?
11:23:18 <mauke> I think I can probably tell you the meaning of most $X variables in perl (without referring to perlvar)
11:23:41 * Twey shudders.
11:23:48 <dons> yikes
11:24:01 <vixey> blueonyx, what's S and what's W?
11:24:02 <Twey> I'm so glad I don't know Perl :-P
11:24:10 <mauke> blueonyx: I don't think so
11:24:19 <mauke> Twey: wanna learn it? it's easy!
11:24:29 <Twey> mauke: Yeah, right :-P
11:24:31 <sjanssen> blueonyx: not with simple pattern matching, but it should be easy with a guard
11:24:50 <walski> How can I append a Char to a [Char] ?
11:24:52 <mauke> Twey: it gets even easier if you already know Common Lisp
11:24:53 <Twey> Fugly, is what it is...
11:24:55 <sjanssen> blueonyx: first define "isV (V {}) = True; isV _ = False"
11:24:56 <mauke> walski: str ++ [c]
11:24:59 <Twey> walski: ++ [c]
11:25:00 <blueonyx> S is 'schwarz' german for black and W white
11:25:08 <walski> ah I missed the square brackets
11:25:11 <vixey> blueonyx, so data Color = S | W
11:25:12 <walski> hanks!
11:25:22 <vixey> blueonyx, and then data VTree = Leaf Color | V VTree ....
11:25:39 <vixey> blueonyx, then you can use the pattern f (V (Leaf _) (Leaf _) (Leaf _) (Leaf _)) = ...
11:25:47 <blueonyx> im not permitted to alter the data :/
11:25:56 <vixey> I permit you :)
11:26:08 <dolio> Heh.
11:26:14 <dolio> dons: There are too many libraries for haskell!
11:26:14 <mauke> Twey: perl -e "print uc chr ord q stat s and print chr ord q qw q and print chr ord q ref tr and print chr ord q my m and print chr oct oct oct oct oct oct oct oct oct ord ord uc q map m"  # CLEAN
11:26:28 <vixey> blueonyx, if they mark you down at least you are suffering for righteousness
11:26:47 <Botje> oppressed datatypes of the world, unite!
11:26:57 <blueonyx> :)
11:27:04 <sjanssen> blueonyx: the function is easy to write with isV
11:27:09 <dolio> @seen mmorrow
11:27:10 <lambdabot> mmorrow is in #haskell, #darcs and #ghc. I last heard mmorrow speak 8h 33m 10s ago.
11:27:18 <blueonyx> but i'll try sjanssen's version if i would know what {} do :/
11:27:39 <dons> Lemmih__: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/darcs-graph-1.0
11:27:41 <lambdabot> Title: HackageDB: darcs-graph-1.0, http://tinyurl.com/69fyx8
11:27:41 <sjanssen> blueonyx: {} just matches the rest of the items, here it is the same as (V _ _ _ _)
11:27:59 <dons> i swear Andrew Copping is trolling us now.
11:28:01 <sjanssen> blueonyx: it is a little trick to save some typing
11:28:24 <dolio> *Now* he is?
11:28:27 <blueonyx> ah thanks
11:28:33 <dons> haha this week alone "RWH is bad, no database libraries work, no haskell works on windows, there are too many libraries and no one designs them."
11:28:49 <vixey> too many libraries? lol
11:28:55 <dons> seriously. is there anyone who has written more on -cafe@ and written less actual haskell code? sigh.
11:29:18 <dons> maybe its the silly season
11:29:39 <sjanssen> dons: I think it is forum disease
11:29:48 <sjanssen> forum users seem to enjoy generating useless content
11:29:56 <dolio> I'm not sure I can detect a significant difference from when he first arrived.
11:30:04 <sjanssen> see replies consisting only of "lol"
11:30:28 <dolio> Oh, well, he has stopped doing that, yes.
11:31:05 <sjanssen> he does have a point, libraries that use foreign libs are more difficult to build on Windows
11:31:13 <sjanssen> but that is more of a Windows issue than a Haskell issue
11:31:36 <ddarius> dons: This is from yesterday: "[23:46] <ddarius> lispy: I'm pretty sure the answer Andrew will give you is that he's maybe tried to install a database library, had trouble and gave up, or maybe just has never tried at all." (though it should have been directed at jsn)
11:33:43 <conal> lilac: i just saw your message.
11:34:23 <conal> lilac: (resound runs at 4x real time if i change "adaptE ..." to "runE mempty ..."; all the time was going in System.Time.getClockTime)
11:35:31 <naradapuri> _MaK_: I made it work using classes, thanks for helping me <http://hpaste.org/12488#a4>. Now "compute" isn't dependent on the CacheClass instance anymore.
11:36:20 <dons> ddarius: yes, i suspect he didn't have, say, sqlite installed, so it failed ==> conclusion: nothing works and it is  a conspiracy of magicians
11:36:30 <naradapuri> _MaK_++
11:36:45 <dons> but things don't seem to be getting better in the debate, after 3 years. hmm
11:37:22 <conal> mmorrow: ping
11:38:55 <_MaK_> naradapuri: hmm but whats a sens of this class? its just strange wrapper for Map interface isnt it?
11:40:47 <skorpan> i'm in inf-haskell mode in emacs, is there any way to clear the buffer?
11:41:22 <naradapuri> _MaK_: That it abstracts Map, and I can plug-in a different implementation. Maybe I could try plugging-in arrays.
11:41:46 <skorpan> it was erase-buffer
11:44:23 <_MaK_> naradapuri: hmm maybe you are right ;]
11:49:21 <walski> Hm http://pastie.org/326735
11:49:22 <lambdabot> Title: #326735 - Pastie
11:49:32 <walski> Line 2 and 3 have a doubled definition if lc or rc
11:49:47 <walski> I'm trying to express that the two occurences of this character match
11:49:52 <walski> is there a way to do this?
11:50:58 <mauke> findIn (TreeNode (lc, lt) (rc, rt)) c = lc == c || rc == c || findIn lt c || findIn rt c
11:52:15 <dons> ?userrs
11:52:15 <lambdabot> Maximum users seen in #haskell: 552, currently: 537 (97.3%), active: 16 (3.0%)
11:53:45 <thoughtpolice> ?b
11:53:46 <lambdabot> Maybe you meant: b52s babel bf bid botsnack brain bug . ? @ v
11:53:54 <thoughtpolice> ?bot
11:53:54 <lambdabot> :)
11:53:58 <walski> mauke: thanks!
11:55:51 <dons> ?brain
11:55:51 <lambdabot> Uh, I think so, Brain, but I get all clammy inside the tent.
11:55:55 <dons> ?b52s
11:55:55 <lambdabot> Hot pants explosion at the factory!
11:55:59 <dons> ?bug
11:55:59 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
11:56:05 <vixey> @B52s
11:56:06 <lambdabot> Hot pants explosion at the factory!
11:56:07 <vixey> @B52s
11:56:08 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
11:56:31 <mauke> preflex: quote
11:56:32 <preflex>  <poetix> Avoiding lambdas is pointless
11:56:41 <profmakx> nuahah
11:58:08 <naradapuri> _MaK_: I put there an instance made from Array, although I see that it's not very effective (probably because of many updates of a large array).
11:58:16 <naradapuri> _MaK_: Anyhow I'm not able to create two distinct instances of the class, I get the error:
11:58:16 <naradapuri> Functional dependencies conflict between instance declarations:
11:58:16 <naradapuri>       instance (Ord a) => CacheClass a b (Map a b)
11:58:16 <naradapuri>         -- Defined at CacheMonad1.hs:(33,0)-(35,24)
11:58:16 <naradapuri>       instance (Ix a) => CacheClass a b (Array a (Maybe b))
11:58:17 <naradapuri>         -- Defined at CacheMonad1.hs:(37,0)-(39,76)
11:59:11 <dolio> @tell mmorrow I made a little set of mtl-ish modules with CPSed representations (and a couple other tweaks; and absolutely no documentation) here: http://code.haskell.org/~dolio/cps-mtl/. Took me a long time to figure out callCC for State. :)
11:59:12 <lambdabot> Consider it noted.
12:01:19 <ddarius> dolio: Thanks dolio.  That was something I had been considering doing for a while.
12:02:02 <ddarius> dolio: Incidentally, there should be different ways of defining callCC with different behaviors.
12:02:13 <roconnor> dolio: why not Control.Monad.State.CPS?
12:02:22 <roconnor> to go with .Lazy and .Strict.
12:02:35 <dolio> Eh. I can always change it.
12:02:45 <ddarius> It should be a drop-in replacement.
12:03:07 <dolio> I was thinking, maybe .Strict should be replaced with the CPS version, since it's purportedly faster.
12:03:28 <ski_> (ddarius : "different behaviours" ?)
12:03:28 <dolio> And the CPS version should be equivalent to the strict version.
12:03:52 <dons> dolio: i'd like to see the CPS version packaged up and benchmarked
12:04:47 <dolio> My library isn't actually a drop-in replacement as it is. It has the Objectively Correct argument ordering for stuff like runState (and the state is the first element of the pair, as well, for instance).
12:06:22 <dolio> dons: Yeah. mmorrow benchmarked a CPS state and said it was faster than an unboxed tuple state, even. But I wonder if GHC will do as good a job when it's broken into a seprate module/package.
12:06:48 <ski_> (dolio : why is that ordering better ?)
12:06:55 <ddarius> CPS transforming can make a significant difference, especially for more complex monads.
12:07:07 <ddarius> I'll probably try it on Parsec at some point.
12:07:16 <dolio> ski_: runIdentity . runContT k . runStateT s $ yourMonadicValueHere
12:07:27 <vixey> CPS is the fastest chunks
12:07:41 <ddarius> dolio: Luckily, GHC seems to do pretty well with CPS code (except that it can foil strictness analysis)
12:07:44 <ski_> ic
12:07:46 <dolio> Or do you mean the tuple ordering?
12:09:27 <dejones> This is probably a very silly, simple question, but how do I access the "data" variable in this data type, data Format = Format (Header, Data)  ???
12:09:35 <dolio> The tuple ordering corresponds to the non-newtyped monads like (,) w (and for state, it's as if you defined it as (->) s `O` (,) s, although that doesn't actually matter, because tuples aren't used except in the 'runStateT' function).
12:09:46 <mauke> dejones: pattern matching
12:09:48 <_MaK_> naradapuri: hmm becouse you have a b -> m and there is not place for maybe
12:09:51 <hartke> hello!! ive got furhter on my exercise... now i want to write a member function (called findIn) so get the right Tree but i dont know how to put the right arguments for that... so findIn morseTree ' ' gives me: True, its correct but the others I dont know: http://hpaste.org/12490
12:10:07 <dejones> mauke: No other way?
12:10:10 <hartke> so=to
12:10:23 <sjanssen> dejones: by the way, "data Format = Format Header Data" would generally be considered better style
12:10:24 <mauke> dejones: like what?
12:10:43 <dejones> sjanssen: Thanks.
12:10:55 <sjanssen> dejones: then you can use "data Format = Format { formatHeader :: Header, formatData :: Data }", which makes a formatData function to access that component
12:11:10 <ddarius> dejones: Pattern matching is the only primitive that can take apart a data type.  Everything is written in terms of pattern matching.
12:11:11 <dejones> mauke, sjanssen: Ahh, I see.  I like the record style better.  Thanks.  :)
12:11:32 <hackage> Uploaded to hackage: darcs-graph 1.0
12:11:36 <ski_> (hm .. no cps in `Reader' ..)
12:11:40 <naradapuri> _MaK_: Are you sure? Still, "Array a (Maybe b)" depends on "a" and "b". And anyhow I couldn't create an instance of IntMap and Map simultaneously.
12:11:46 <ddarius> ski_: That would be fairly pointless.
12:12:13 <dolio> There's no CPS in Identity, either. :)
12:12:23 <ski_> well, you can encode environment as state encoded through cps
12:12:43 <ski_> then `local' would change back after the sub-action has run
12:13:22 <ski_> (i'm not sure whether this would actually be good anytime, though ..)
12:13:29 <idnar> cps always makes me think "characters per second"
12:16:29 <dolio> Much to my surprise, there are already two alternate mtls on hackage (not even considering monadLib).
12:17:04 <ski_> (i was thinking of that because that's how "fluids" (a kind of dynamic-scope references) in lisps are usually (afaik) implemented ..)
12:18:16 <idnar> dolio: oh noes, too many libraries!#!#
12:18:26 <cknapp> Is there a standard prelude function implementing a queue?
12:18:42 <mauke> what
12:18:48 <ddarius> One of them should just be mtl using associated types and type families, mtl-tf.
12:18:48 <mauke> don't you mean a data type?
12:18:53 <cknapp> Yeah...
12:18:55 <cknapp> I do.
12:18:55 <dolio> Yeah.
12:19:09 <mauke> not in the Prelude, but Data.Sequence
12:19:14 <cknapp> Thanks.
12:19:35 <ddarius> Data.Sequence is a pretty heavy queue type, but I don't think there's anything lighter and handier.
12:19:59 <mauke> it's a deque with cherries on top
12:20:32 <dolio> Edison probably has a (many) queue(s).
12:22:32 <dolio> ddarius: The other one is mmtl, whose only noticeable differences are an extra method in MonadTrans, and a codensity monad.
12:22:58 <dolio> (Although it also has callCC able to roll back state, unlike mtl.)
12:25:00 <hartke> hello, i need to find the correct argument to search my tree recursive of my char... in the findIn function: http://hpaste.org/12490
12:25:49 <Botje> what now?
12:26:12 <walski> What do I have to do to access Char.toUpper inside a module?
12:26:24 <walski> if I access it with Char.toUpper it says, it's not in my scope :/
12:26:27 <Botje> import Char
12:26:29 <mauke> import Data.Char
12:26:32 <mauke> and use toUpper
12:26:47 <walski> and is there now way to call it by some kind of canonical name?
12:27:09 <Botje> why would you want to?
12:27:17 <mauke> import qualified Data.Char  -- and use Data.Char.toUpper if you like typing
12:27:53 <walski> e.g. to have a clearer call. instead of just toUpper bla inside of my code it would be Char.toUpper and anyone would know where the toUpper comes from
12:27:57 <ski_> (dolio : which is that ?)
12:28:03 <walski> mauke: thanks
12:28:15 <dolio> Which is what?
12:28:30 <ski_> "callCC able to roll back state"
12:28:34 <mauke> import Data.Char (toUpper)
12:29:00 <Gerente> Tired of black people and their monkeyshines?  Join us at Chimpout!  http://www.chimpout.com  All human races are welcome to join, be it Whites, non Negroid Jews and Hispanics, Native Americans, and Asians!  This is not white supremacist, but anti-niigggger.  Humans vs NIIIGGGERS Join us today at Chimpout.
12:29:01 <cknapp> to make it less typing, "import Data.Char.toUpper as Char"
12:29:10 <lambdabot> Title: Chimpout
12:29:19 <dolio> > runCont (runStateT (callCC (\k -> put 5 >> k ())) 4) id
12:29:20 <lambdabot>   ((),5)
12:29:29 <idnar> @where ops
12:29:30 <walski> :/ http://pastie.org/326753 why isn't this working?
12:29:30 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
12:29:31 <lambdabot> Title: #326753 - Pastie
12:29:37 <dolio> > runState (runContT (callCC (\k -> put 5 >> k ())) return) 4
12:29:38 <walski> It says:  Couldn't match expected type `Char' against inferred type `String'
12:29:38 <Botje> Gerente: even jews? you racists sure are tolerant.
12:29:38 <lambdabot>   ((),5)
12:29:49 <walski> at line 2
12:29:52 <Gerente> we aren't racist
12:29:56 <Gerente> all human races are respected
12:30:02 <Gerente> niggers aren't human
12:30:08 --- mode: ChanServ set +o Igloo
12:30:15 <Botje> interesting theory. how did you arrive at that conclusion?
12:30:18 <cknapp> Of course not... they don't have the same DNA...
12:30:22 <cknapp> Oh, wait...
12:30:22 <Botje> oops. you're out of time. bye!
12:30:38 <shapr> hah
12:30:42 <cknapp> ... Thanks Botje
12:30:48 <shapr> thanks Igloo
12:30:55 <shapr> I still don't have a decent ban command setup.
12:31:02 <dolio> ski_: One (I) might expect a Cont(T) underneath a StateT to be able to roll back the state when invoking the continuation, since, for instance, [] and Either do (and Cont(T) does it for WriterT). But in MTL, it doesn't. ContT r (StateT s m) is the same as StateT s (ContT r m).
12:31:37 <idnar> shapr: look closer, you need to thank njan
12:31:41 <Botje> walski: stop using pastie. use hpaste
12:31:42 <shapr> Fair enough :-)
12:31:49 <idnar> ;P
12:31:59 <ski_> dolio : ok .. (i think i must chew on that for a while, to decide)
12:32:17 <Botje> walski: and show the error ghc gives.
12:32:55 <dolio> ski_: I was fooling around trying to implement a nondet monad with Cont and State last night to show how weird it was, but I gave up after failing to figure out appropraite types for it.
12:33:37 <ski_> (dolio : btw, you don't seem to export `unBlah(|T)' ..)
12:34:14 <dolio> Yeah, I figured I'd just export the normal interface instead of the continuation version.
12:34:22 <ddarius> @google Modular Interpreters and Monad Transformers
12:34:28 <lambdabot> http://citeseer.ist.psu.edu/14178.html
12:34:28 <lambdabot> Title: MonadTransformersand Modular Interpreters - CiteSeerX
12:34:55 <dolio> I could be persuaded to do otherwise, though.
12:35:14 <walski> Botje: Ok :) I think I've found the error. But my soultion is now real crap
12:35:17 <walski> mom
12:35:34 <ski_> dolio : sorry, what i meant / wanted you to export was not (necessarily) the cps version, but the variants of `runBlah(|T)' with the other argument order .. though i suppose you'll tell me to use `flip' or right sections :)
12:35:55 <walski> http://hpaste.org/12491
12:36:05 <ddarius> ski_, dolio: See that paper (which you've probably already seen years ago)
12:36:06 <walski> this is the "interesting" part
12:36:25 <ski_> (dolio : i can't give an example off-hand, but i think there's cases where the other argument ordering is more handy ..)
12:36:44 <ski_> ddarius : see it for what ?
12:36:52 <walski> All I wanted to do is something like: Ok, for any Char in the String s  all encMorse and concatenate it's output (String) with a space
12:37:00 <walski> *all = call
12:37:07 <ddarius> Combining Cont and State
12:37:18 <dolio> Oh. I could do that, i guess. Do you think it would be more appropriate to give those the old names and the other ones, say, a ' name?
12:37:23 <dolio> That'd make it more drop-in.
12:37:37 <_MaK_> naradapuri: try version with kind its quite easier to implement new boxes
12:37:39 <ski_> ddarius : ok
12:38:58 <ski_> dolio : well, i suppose it could be best not to include them until confirmed ..
12:39:27 <naradapuri> _MaK_: OK, I'll try that.
12:41:27 <dolio> ddarius: Are you sure this is what I'm looking for? I was trying to implement non-determinsitic choice using callCC + a mutable cell.
12:41:47 <ddarius> I wasn't referring to non-deterministic choice.
12:42:09 <naradapuri> _MaK_: Hm, I get "parse error on input `*'" on
12:42:09 <naradapuri> class CacheClass a b (m :: * -> * -> *) where
12:42:09 <naradapuri> anything specific I must turn on in the compiler?
12:42:16 <ddarius> dolio: Though, that's easy enough.  Implement delimited continuation using Cont and a mutable cell and then implement a non-determinism monad.
12:42:20 <dolio> I actually know how to lift callCC through StateT. This paper does it the same way as mtl.
12:42:30 <ski_> (btw, currently i often use :  blah `runStateT` s)
12:42:32 <ddarius> It does it in two ways.
12:42:49 <ddarius> (unless I have the wrong paper)
12:43:16 <Wolfrat> haskell is the shit
12:43:24 <vixey> lol
12:44:11 <roconnor> @quote haskell
12:44:11 <lambdabot> dmwit says: (on Haskell) Welcome to the light side of the Force. =)
12:45:16 <SamB_XP> a ... mutable cell ?
12:45:36 <gwern> you know, I think dons could cut back on his proggit posting; I dont' really care that amazon is now shipping RWH, or that packages have started arriving in europe :)
12:46:07 <SamB_XP> yeah, when it first showed up on amazon might have been interesting ...
12:46:15 <SamB_XP> but when they started shipping ? not so much ...
12:47:33 <gwern> also comments like http://www.reddit.com/r/programming/comments/7g8vx/turbinado_an_easytouse_web_application_framework/c06knez make him sound burnedout
12:47:36 <lambdabot> Title: dons comments on Turbinado: an easy-to-use web application framework for Haskell ..., http://tinyurl.com/57fjxp
12:48:50 <dons> gwern: ok.
12:49:09 <dons> proggit's kinda dead
12:49:29 <gwern> dons: would RWH have been CC even if I hadn't whined about it?
12:49:38 <dons> yes
12:50:00 <gwern> (good, good)
12:50:13 <gwern> I was happy when I saw that while it was NC, it wasn't ND
12:51:53 <shapr> Silly question, why does happy give me a parse error at the end of this file? http://hpaste.org/12492
12:52:34 <shapr> It's the first example in the Happy documentation, I would expect it to work?
12:59:00 <jsn> gwern: NC and ND are what?
12:59:25 <dons> gwern: btw, you should post stuff to the [haskell] reddit if you have it.
13:06:37 <_MaK_> naradapuri: you must have it like this ( m :: * -> * ) spaces are important i dont know why ;]
13:07:33 <dons> really?
13:07:45 <dons> well, some of those are tokens if you join them together
13:08:54 <ski_> shapr : .. "To complete the program, we need some extra code." ?
13:09:18 <shapr> ski_: I get the same error with or without the code .
13:09:25 <naradapuri> _MaK_: Still I can't make it work somehow. But never mind :)
13:09:30 <shapr> It gives an error at the last line.
13:09:55 <dons> gwern: i guess i get frustrated at whining sometimes.
13:10:05 <dons> talk and complaints and no action. usual issue in open source.
13:10:44 <shapr> yup
13:11:14 <ski_> shapr : and the error might be ?
13:11:32 <hackage> Uploaded to hackage: Vec 0.9.5
13:11:32 <hackage> Uploaded to hackage: vty 3.1.4
13:11:43 <shapr> ski_: "Parse error"
13:11:54 <shapr> Line number is whatever is the last line.
13:12:22 <ski_> you included the code down to section 2.1 ?
13:12:37 <shapr> yes
13:12:43 <shapr> I can paste that version if you prefer.
13:12:50 <ski_> (ending with `main = ...')
13:12:53 <ddarius> shapr: Is your power chord plugged in?
13:12:58 <shapr> ddarius: hah
13:13:06 <shapr> ski_: Yes, and the trailing curly brace that's required.
13:13:44 <shapr> ski_: With code: http://hpaste.org/12493
13:14:04 <ddarius> Wow.  Too much music for me.
13:14:34 <shapr> ddarius: I thought that was very punny, computer/music joke.
13:15:22 <ddarius> Yes!  That's exactly what it was... a pun ... ...
13:15:23 <skorpan> is there an extension which lets me pattern match such as: f (Const i) i = ...?
13:15:31 <dons> does anyone know of studies of open source software in economic terms? do masses of code act as a free market? or is it regulated by licenses/build systems?
13:15:54 <dons> or is it more like politics
13:16:07 <dons> where we compete and argue for ideas, forming coalitions and so on
13:16:46 <dons> if we understood what kind of economy this is, perhaps we could make it function better
13:17:00 <shapr> You're wondering what the limiting resource is in open source?
13:17:43 <sheyll> I am trying to build gtk2hs-darcs(gentoo+haskell-overlay) and I get: config error: Another gtk2hs package that glade depends on is not being built. How do I fix this?
13:17:53 <dons> well, how the compeiting warez on offer operate. how does the competition work? how does the ability to fork influence things, how does the ability to push patches back upstream influence things
13:18:08 <dons> is it efficient?
13:18:11 <olsner> shapr: I had a funny problem with happy before, where it would just print 'e' (iirc) on stdout then exit
13:18:13 <jsn> i'm not aware of any studies
13:18:14 <dons> or do we reinvent wheels?
13:18:25 <shapr> olsner: That's impressive, got the input that causes that?
13:18:37 <jsn> but some of these things seem pretty easy to argue from first principles
13:18:50 <jsn> markets are efficient when information is transparent
13:19:02 <dons> i mean, we fork when a project is not efficient, or not moving fast enough. we merge when projects have similar goals. projects die, projects are born. lots of information is passed around
13:19:14 <pao> dons: I think wikipedia article on "open source" gives good pointers...
13:19:25 <dons> projects reuse other projects (indeed, hackage is set up as a market for reuse)
13:19:31 <dons> pao: ah good idea
13:19:46 <olsner> shapr: it's supposed to be fixed now (this was one or two years ago, I think), but it was essentially a "parse error" just missing the error message
13:20:38 <jsn> dons: i think we fork if a project is doing poorly and we are willing to pay the price of taking it over
13:20:58 <jsn> dons: so i think OpenLDAP has needed to be forked for a long time -- but no one wants to deal with that
13:21:02 <dons> right. but forking is a /key/ thing to do. it keeps us efficient.
13:21:06 <jsn> yes
13:21:10 <olsner> what the input was, I have no recollection... that was just before I developed the firm belief that code generation just shouldn't be needed in high-level languages and stopped using happy :)
13:21:13 <jsn> forking allows for competition
13:21:24 <shapr> olsner: What do you use now?
13:21:30 <dons> we want a flowering haskell economy. lots of code/, lots of cooperation, lots of reuse
13:21:34 <kig> a project is alive if it has an influx of time. a project is doing well if it has an influx of clue.
13:21:37 <jsn>  /cheaper/ competition
13:21:44 <dons> yeah
13:21:59 <shapr> So, setup cabal with the ability to submit patches?
13:22:03 <jsn> the thing is, forking also reduces ownership
13:22:06 <pao> dons: your contribution to haskell is amazing ... let me take the opportunity to thank you :-)
13:22:24 <Jarvellis> Gift economies are probably analagous to healthy OSS comunities
13:22:26 <dons> heh. #haskell's been lighting a fire under the haskell world for 5 years now
13:22:27 <shapr> Setup cabal with the ability to submit bug reports, failing test cases?
13:22:43 <ddarius> dons: And the other year or two?
13:22:46 <dons> shapr: yeah, like 'cabal report'
13:22:49 <mapreduce> Integrate hackage with hoogle, in a Haskell IDE, so when you write a type signature that corresponds with an existing function, you are prompted to use that instead of writing your own.
13:22:52 <maxote> are there another languages that have CSP for programming prototypes as GNU Prolog, Eclipse and Mozart-Oz? See it http://www.cs.st-andrews.ac.uk/~ianm/CSPLib/links.shtml
13:22:53 <olsner> shapr: well, parser combinators... monads like parsec or polyparse, also played with one using recusive monads that I don't remember the name of
13:22:54 <lambdabot> Title: CSPLib links
13:22:56 <dons> ddarius: nothing happened :)
13:23:10 <shapr> There wasn't really a Haskell world before that, not that I could find.
13:23:15 <dons> mapreduce: that's a great idea
13:23:21 <vixey> maxote, haskell SWI Prolog
13:23:25 <dons> shapr: comp.lang.functional :)
13:23:43 <dons> aka newsgroups, the most dysfunctional online communities.
13:23:45 <jsn> dons: if you publish anything, of course we'll read it :)
13:23:50 <Jarvellis> Is there a functional language channel on freenode?
13:24:01 * ddarius actually first heard of Haskell from Dirk Thierbach on comp.object
13:24:02 <vixey> Jarvellis, that would be cool
13:24:08 <dons> Jarvellis: there's no obvious overall functional language community
13:24:18 <Jarvellis> It's a shame
13:24:27 <shapr> I first heard of Haskell from my friend Darius Bacon, he looked at my Python code and said "You should really try Haskell."
13:24:28 <vixey> Jarvellis, I think people on freenode are seggregated into languages instead of paradaigms for no good reason..
13:24:32 <dons> we pay lip service, and there's some small sharing of ideas, but they tend to be incompatible toolchains
13:24:45 <Jarvellis> #functional contains only me, feel free to join
13:24:56 <ddarius> vixey: I don't want my eyes subjected to ML
13:24:58 <dons> it's like #imperative
13:25:05 <dons> do you really want all imperative language people in one room
13:25:09 <dons> ruby vs C++ vs java?
13:25:10 <mapreduce> Jarvellis: The problem is that FP varies so widely.
13:25:23 <mapreduce> dons: If I can lock it shut, yes.
13:25:27 <dons> heh
13:25:41 <Jarvellis> mapreduce: but surely it has some congruence? enough for conversation
13:25:43 <mapreduce> Jarvellis: FP as practiced in Scheme is quite different to it as in Haskell.
13:25:58 <cknapp> Quite different...
13:25:59 <dons> Jarvellis: yes, we have ICFP
13:26:09 <Jarvellis> What's an ICFP?
13:26:11 <mapreduce> Possibly, yes.
13:26:11 <dons> where we all sit together in a room, and listen to each other.
13:26:21 <dons> http://www.icfpconference.org/icfp2008/
13:26:25 <dons> the FP conference
13:26:29 <mapreduce> Surely /someone/ has to talk.
13:26:32 <lambdabot> Title: ICFP 2008 : The 13th ACM SIGPLAN International Conference on Functional Programm ...
13:26:40 <dons> which is about 50% haskell now, and 50% everyone else.
13:26:47 <Jarvellis> Oh, that's in meatspace, i don't like it there
13:26:58 <ddarius> dons: The time for a coup draws near.
13:27:06 <shapr> Jarvellis: ICFP is really fun. Beer and FP is a good combination.
13:27:19 <mapreduce> Beer, FP and unicycles?
13:27:24 <shapr> EXACTLY!
13:27:57 <Jarvellis> shapr: beer and me is a bad combination, FP and me is a bad combination
13:28:11 * olsner still hasn't started with the unicycling part
13:28:15 <dons> ICHP ?
13:28:17 <mapreduce> Jarvellis: I thought you were interested in fp.
13:28:28 <shapr> dons: ooh, yeah!
13:28:32 <ddarius> Mark Twain had it all wrong in "A Connecticut Yankee in King Arthur's Court".  Knights would be much better served by charging in on unicycles than bicycles.
13:28:38 <dons> well, the haskell workshop --> haskell symposium
13:28:42 <dons> conference is the next step.
13:28:53 <Jarvellis> Oh, fascinated, but i keep getting confused and/or distracted(mostly distracted)
13:29:28 <FunctorSalad> doesDirectoryExist doesn't work with utf-8, does it?
13:29:39 <dons> FunctorSalad: in what sense?
13:29:46 <dons> the string you pass it can be utf8 encoded.
13:29:59 <dons> but otherwise it'll just use the unix package's latin1 stuff i guess
13:30:11 <olsner> doesn't it take unicode Chars that are then encoded into whatever locale you're on?
13:30:44 <dons> our IO layers tend not to do that yet afaik..
13:30:53 <BMeph> Jarvellis: Distraction is just a lack of discipline. You see, all you need is... Ooh, Shiny!
13:31:21 <Jarvellis> BMeph: give me the shiny!
13:31:24 * ddarius needs to add global illumination to one of his raytracers.
13:32:00 <Botje> ddarius: the others will get jealous!
13:32:36 <dons> open source is a lot of political stuff too. coalition building, arguing ideas, destroying your enemies. i mean, working hard.
13:33:50 <FunctorSalad> dons: I'm not sure where the error happens :( using UTF8Prelude and System.UTF8IO doesn't help
13:33:58 <ski_> (shapr : sorry, i can't see what's worng ..)
13:34:09 <shapr> ski_: Thanks for checking, I couldn't see what's wrong either.
13:34:11 <FunctorSalad> dons: unfortunately I'm clueless about how linux handles the encodings
13:34:16 <shapr> ski_: One of the documentation or happy is broken.
13:34:23 <dons> FunctorSalad: i'd imagine you should be using System.IO.UTF8 to encode the filepath?
13:35:17 <olsner> FunctorSalad: check the output of 'locale' to see what you're running (but it should probably be utf-8)
13:35:55 <FunctorSalad> olsner: en_GB.UTF-8
13:36:01 <ski_> (shapr : hm, for some reason i get `Test.y:7: unrecognised directive: %error' if i remove that, i get `Test.y:105: No closing '}' in code segment')
13:36:03 <bjorkBSD> has anyone here tried haskore on freebsd?
13:36:08 <FunctorSalad> (and unicode works in filenames)
13:36:30 <dons> bjorkBSD: hmm. using the new release on hackage?
13:36:41 <FunctorSalad> dons: doesDirectoryExist isn't part of IO
13:36:44 <bjorkBSD> dons, i haven't used it at all.
13:36:46 <dons> FunctorSalad: but you'll likely need to encode the filepath before calling doesDirectoryExist
13:36:53 <dons> bjorkBSD: probably works then
13:36:54 <bjorkBSD> but if it's not gonna work, i'll just setup a linux box instead.
13:36:56 <bjorkBSD> ah okay.
13:37:00 <bjorkBSD> thankyou.
13:37:03 <dons> try it.
13:37:10 <bjorkBSD> do you use haskore?
13:38:24 <FunctorSalad> dons: System.Directory.doesDirectoryExist . Codec.Binary.UTF8.String.encodeString?
13:38:37 <shapr> @users
13:38:37 <lambdabot> Maximum users seen in #haskell: 552, currently: 538 (97.5%), active: 23 (4.3%)
13:39:12 <andrewsw> how long to become inactive?
13:39:23 <dons> http://hackage.haskell.org/packages/archive/utf8-string/0.3.3/doc/html/Codec-Binary-UTF8-String.html
13:39:25 <lambdabot> Title: Codec.Binary.UTF8.String, http://tinyurl.com/5upqmr
13:39:27 <dons> yep
13:39:49 <shapr> andrewsw: two hours? I think?
13:39:56 <shapr> Or was it smaller?
13:40:07 <FunctorSalad> it's hard to understand where in the chain what is converted to what ;)
13:40:48 <FunctorSalad> using emacs with utf-8, my String literals are encoded as utf-8 already? and encodeString does what exactly?
13:40:54 <dons> doesDirectoyrExist (encode "my funky name")
13:40:56 <dons> i'd say
13:41:15 <dons> flattens it so when bytes are written out, they make sense.
13:41:26 <dons> see the source to http://hackage.haskell.org/packages/archive/utf8-string/0.3.3/doc/html/System-IO-UTF8.html
13:41:31 <lambdabot> Title: System.IO.UTF8, http://tinyurl.com/5e8hsv
13:41:35 <dons> where the System.IO functions are wrapped in decoders
13:41:42 <dons> you'd want the same thing for directory
13:41:59 <ski_> (maybe one should figure out a way to display the objects in a long composition chain in haskell .. similarly to `A <-f-< B <-g-< C <-h-< D' ..)
13:42:41 <FunctorSalad> thanks dons, I'll try :)
13:43:04 <vixey> ski_, as equivalent to f . g . h  ?
13:43:10 <ski_> yep
13:43:34 <vixey> so it has backwards bindings?
13:43:47 <ski_> ?
13:43:54 <vixey> (if say B was actually (x:xs))
13:44:06 <FunctorSalad> dons: worked :)
13:44:20 <ski_> `A',`B',`C',`D' would be the types
13:44:26 <vixey> oh ok
13:44:29 <ski_> ("objects" as in CT ..)
13:44:52 <andrewsw> @help users
13:44:53 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in the last 30 minutes
13:44:54 <vixey> :t (.{-< A <-})
13:44:55 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:44:56 <andrewsw> d'oh.
13:45:00 <vixey> you can sort of go
13:45:15 <vixey> f .{-< A <-} g .{-< B <-} h
13:45:32 <ski_> mm (except those are not checked)
13:45:37 <FunctorSalad> ah, length "ä" == 1, length (encode "ä") == 2
13:45:42 <vixey> ahaaa
13:46:07 <vixey> I don't know then
13:46:30 <ski_> i suppose one could do like
13:46:42 <ski_>   f . (id :: Endo B) . g
13:47:04 <gwern> argh, new vty fails on the exception thing
13:47:13 <ski_> (or probably not the library `Endo' since istr that is not a synonym)
13:50:07 <sjanssen> @src Endo
13:50:07 <lambdabot> Source not found. My mind is going. I can feel it.
13:50:09 <sjanssen> fail
13:50:15 <sjanssen> ski_: you're right, it's a newtype
13:50:17 <ski_> @index Endo
13:50:17 <lambdabot> bzzt
13:50:47 <sjanssen> it can't be a synonym, since the Monoid instance would clash with (->)'s instance
13:51:39 <vixey> shapr, what is the syntax like?
13:51:59 <vixey> (is it close to haskell?)
13:52:01 <RayNbow> finally, Google's done processing the video I mirrored...
13:52:14 <shapr> vixey: Yeah, almost the same with a few subtractions and additions.
13:52:33 <vixey> shapr, I have some parsec thing that's pretty simple
13:52:47 <shapr> But wildly different underpinnings. Types are implemented in the language itself, so you can use 'em if you feel like it.
13:54:32 <shapr> I still can't fix Test.y, but at least edwardk's Parser.ly works now.
13:54:50 <vixey> ohh you already have a .y ok makes sensenow
13:55:19 <shapr> Yeah, just trying to get all the code building happily with the new extensions.
13:55:44 <RayNbow> http://video.google.com/videoplay?docid=-4991530385753299192 <-- SPJ's Type-driven testing in Haskell talk, now mirrored at Google Video :)
13:55:50 <lambdabot> Title: Type-driven testing in Haskell - Simon Peyton Jones
13:55:52 <ushdf_> cory doctorow???
13:56:11 <gwern> http://www.paulgraham.com/artistsship.html <-- a reasonable PG essay, at least if you mentally interpret it as advice for OSS development :)
13:56:16 <lambdabot> Title: The Other Half of "Artists Ship"
13:56:20 <jeffwheeler> The most interesting thing about the several libraries written in Haskell (Yi, darcs, ghc, etc.)?
13:56:22 <jeffwheeler> The stability.
13:56:26 <jeffwheeler> Those apps _never_ crash.
13:56:28 <ski_> (vixey : syntax of what ?)
13:56:48 <jeffwheeler> It's really quite surprising how stable young apps like those are.
13:56:55 <gwern> jeffwheeler: no, they just fail to start :)
13:57:03 <jeffwheeler> gwern: true. :P
13:57:05 <mauke> does ghc count as young?
13:57:10 * gwern is having trouble with yi startup, actually...
13:57:12 <jeffwheeler> mauke: okay, not ghc
13:57:22 <tomh> whats yi
13:57:33 <jeffwheeler> tomh: a Haskell code editor
13:57:33 <vixey> ski_, some language
13:57:38 <vixey> I don't know much about it
13:57:49 <tomh> like an IDE?
13:58:00 <tomh> or just a text editor written in haskell
13:58:10 <shapr> Sort of both.
13:58:11 <jeffwheeler> tomh: it's like Vim or Emacs; http://haskell.org/haskellwiki/Yi
13:58:12 <lambdabot> Title: Yi - HaskellWiki
13:58:31 <jeffwheeler> (lambdabot has an insanely fast connection . . . or caches those)
13:58:47 <jeffwheeler> that needs to be updated, but you get the idea
13:58:58 <tomh> ok
14:00:36 <gwern> tomh: think emacs/vim, with about as much haskell IDE support as those have
14:01:05 <tomh> i see so basically none :p
14:01:19 <jeffwheeler> tomh: minimal, but it recognizes some stuff like layout
14:01:37 <tomh> i use the eclipse plugin atm for haskell
14:01:47 <gwern> it does better tabbing, fwiw
14:02:38 <shapr> Is there some way to get Happy to tell you exactly which shift/reduce conflicts it's found?
14:03:23 <thoughtpolice> does yi have an equivalent to emacs' M-q?
14:03:49 <shapr> fill paragraph?
14:06:57 <jeffwheeler> M-q seems to work, a little.
14:07:05 <jeffwheeler> I'm not sure if it's proper behavior, but it does something.
14:12:41 <gwern> http://hpaste.org/12494 <-- any idea what this link error indicates?
14:13:18 <xcthulhu> I am trying to get around using multi-parameter classes - is there a nice read for alternative approaches?
14:13:40 <dons> probably you should just use multi parameters
14:13:52 <dons> since they're a widely accepted extension, used in many core libraries
14:14:11 <BMeph> BRB; Ween-doze needs a restart for program update... :/
14:14:13 <dons> it depends on your circumstances though. sometimes they're overkill
14:14:40 <quicksilver> xcthulhu: don't use type classes at all?
14:15:04 <quicksilver> use, e.g. a multi-parameter data containing HOFs
14:15:27 <xcthulhu> quicksilver: Yeah, I was thinking of this...
14:15:38 <thoughtpolice> gwern: it seems as though when you link, there is no 'Paths_yi' module included in the build
14:16:17 <gwern> oh, is that what those mangled symbols are?
14:16:24 <xcthulhu> dons:  I am doing computational logic, and I want to define multiple kinds of semantics over the same structure.
14:16:26 <thoughtpolice> yeah, looks like it
14:16:28 <gwern> I thought they were indicating a problem with ghc-paths :)
14:16:35 <gwern> (well, I know how to fix that)
14:16:55 <dons> xcthulhu: ok. sounds like a job for type classes
14:17:04 <dons> are there libraries you're referring to that do similar things?
14:17:08 <dons> perhaps they'll help the design
14:17:12 <jeffwheeler> I get errors like those all the time with HOC; grr, I hate HOC.
14:17:15 <thoughtpolice> gwern: e.g. (.text+0xae3): undefined reference to `yizm0zi5zi1_Pathszuyi_lvl8_closure'  <- you can see from the z notation that means libHSyi-0.5.1 has an undefined reference to 'Paths_yi'
14:17:43 <thoughtpolice> for deciphering Z notation that GHC uses you just have to look for a sec; although preflex can un-mangle that name I believe
14:17:47 <gwern> 0zi5zi1 == 0.5.1?
14:17:52 <thoughtpolice> yeah
14:17:52 <dons> yup
14:17:54 <thoughtpolice> preflex: help
14:17:55 <preflex>  try 'help help' or see 'list' for available commands
14:18:00 <thoughtpolice> preflex: list
14:18:00 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
14:18:16 <thoughtpolice> preflex: zdec yizm0zi5zi1_Pathszuyi_lvl8_closure
14:18:16 <preflex>  yi-0.5.1_Paths_yi_lvl8_closure
14:18:18 <gwern> hm. so Pathszuyi == Paths_yi? zu == _?
14:18:19 <thoughtpolice> yeah
14:18:58 * gwern sees. this is valuable knowledge
14:19:05 <xcthulhu> dons:  There's DEMO, which is a computational system for doing Modal Logic semantics.  My term assignment is to extend it, and I want to just rewrite it.
14:19:40 <xcthulhu> dons: I want to use a system which would let me incorporate Isabelle for program verification/proving stuff, but I am asking for the moon I think.
14:19:59 <SamB_XP> @faq i can has moon ?
14:19:59 <lambdabot> The answer is: Yes! Haskell can do that.
14:20:14 <xcthulhu> lol
14:20:16 <thoughtpolice> gwern: I believe there is something in the GHC commentary about what the lvl8 and closure mean, i'll see if I can find it...
14:20:35 <xcthulhu> SamB: The problem is that Isabelle doesn't support multiparameter typeclasses
14:20:50 <SamB_XP> wierd!
14:20:54 <SamB_XP> why not ?
14:20:55 * ski_ /\/ sleep
14:20:57 <thoughtpolice> gwern: ah here we go - http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames
14:21:01 <lambdabot> Title: Commentary/Compiler/SymbolNames - GHC - Trac, http://tinyurl.com/58dsgy
14:21:38 * jeffwheeler just realized Haskell mode _is_ working, there's just nothing that Yi feels like highlighting
14:21:59 <vixey> xcthulhu, I think Coq does though
14:22:10 <jeffwheeler> wait, now it works
14:22:11 <jeffwheeler> weird
14:22:29 <xcthulhu> SamB: IDK.  Maybe it does now - in a little implementation of Haskell in Isabelle I read about that was done a few years ago, they complained about this.
14:23:46 <xcthulhu> vixey: I've heard of this.  I don't know Coq (but maybe its not hard to learn?), and I want to sharpen my Isabelle skills because I got this job doing formal proofs in it...
14:23:51 <gwern> jeffwheeler: did jpb's syntax highlithging changes fix the memory usage problem?
14:24:15 <jeffwheeler> gwern: I haven't analyzed it; I'm rather poor at that stuff
14:24:27 <jeffwheeler> gwern: but it seems to have made syntax highlighting wonky
14:24:36 <vixey> xcthulhu, what sort of stuff are you to do using Isabelle?
14:24:47 <thoughtpolice> gwern: oh patches for that stuff you and Lemmih were talking about got pushed?
14:24:55 <dons> xcthulhu: huh, sounds very interesting.
14:25:01 <thoughtpolice> gwern: I'll pull and rebuild and tell you what I get (i'll look at lhc's source to test it)
14:25:03 <dons> xcthulhu: i work at a company that uses haskell + isabelle
14:25:12 <xcthulhu> vixey: Formalizing the Kepler conjecture :)
14:25:14 <dons> i'd be very interesting in any decent integration
14:25:30 <xcthulhu> (I'm not gonna finish or anything)
14:25:34 <dons> hehe
14:25:42 <dons> have you looked a libraries on hackage.haskell.org ?
14:25:49 <thoughtpolice> dons: are you guys at galois free to use your own tools like theorm provers? or is isabelle the standard?
14:25:52 <dons> there are some numeric and logic type structures
14:26:08 <dons> thoughtpolice: we use our own, others, big external theorem provers
14:26:12 <dons> whatever tool is appropriate
14:26:12 <gwern> hm. unifying the array libraries would be a good SoC project
14:26:18 <vixey> xcthulhu, flyspek?
14:26:23 <dons> gwern: a /hard/ one, since arrays aren't done yet
14:26:27 <xcthulhu> vixey: Yeah
14:26:28 <gwern> and presumably by next summer the ghc guys will've finished
14:26:36 <thoughtpolice> I think if any libraries need to get merged,
14:26:36 <vixey> xcthulhu, how did you get into that ? :)
14:26:38 <dons> gwern: though if there's somone in say, Portland i could work with, i'd be glad to have help.
14:26:40 <cknapp> General algorithm question: I'm trying to implement a depth first search in Haskell-- basically, "dfs u v graph" returns true if graph contains a path from u to v. I realized I could just map a procedure to the "children" of u... The problem is this needs to work on a directed graph which may contain cycles. Is my idea infeasible, or should I... I don't know, start pulling edges out of the graph?
14:26:40 <thoughtpolice> it's vector and uvector
14:26:43 <Feuerbach> Any tips on how to build yi? It only builds a library for me, not an executable..
14:26:53 <dons> thoughtpolice: yeah, but vector is still too researchy
14:26:53 <thoughtpolice> GHC 6.10.1 is out, and the simplifier is what allows vector to actually be reasonably efficient
14:26:55 <gwern> Feuerbach: you need vty or gtk installed?
14:27:08 <Feuerbach> gwern: I have vty
14:27:12 <vixey> cknapp, have you get an example graph (which cycles)?
14:27:14 <dons> i should probably talkk to rl to work on vector directly
14:27:15 <thoughtpolice> Feuerbach: cabal install yi -f-gtk -fvty
14:27:23 <Feuerbach> oh, wait, I haven't... weird
14:27:24 <dons> that's probably the only way forward, since he's unlikely to switch to uvector
14:27:31 <gwern> Feuerbach: well if you do have vty installed then there's a problem
14:27:32 <jeffwheeler> Also, copy from examples/yi.hs into ~/.yi/yi.hs
14:27:37 <gwern> because it should handle that
14:27:39 <thoughtpolice> dons: yes, I would like to see uvector's functionality subsumed by vector
14:27:47 <cknapp> vixey: It's a general directed graph... so give k5 an orientation for an example graph
14:27:49 <thoughtpolice> dons: because the recycling optimizations look very promising
14:27:50 <cknapp> :)
14:27:52 <gwern> that reminds me I need to upload my yi.hs
14:27:57 <vixey> cknapp, hpaste it?
14:28:02 <dons> uvector's just far more hammered in practice, but vector pushes in new directions
14:28:03 <vixey> cknapp, with data decls and that
14:28:24 <cknapp> I haven't actually gotten anything written yet... so I don't have anything to hpaste (yet).
14:28:30 <cknapp> data decls?
14:28:31 <dons> and uvector's mentioned in RWH, so we're keeping it :)
14:28:35 <vixey> cknapp, ping me when you do :)
14:28:40 <vixey> if I'm still here
14:28:43 <cknapp> Ok.
14:28:48 <cknapp> I need to go get food first...
14:28:48 <thoughtpolice> dons: yeah. while I'm not a researcher, just a lowly undergrad, I would like to see their functionality combined :]
14:28:54 <cknapp> Thanks, though
14:28:57 <thoughtpolice> dons: but we will see.
14:29:17 <thoughtpolice> speaking of vector libraries, maybe I will do some more DPH benchmarks...
14:29:19 <gwern> ooh, much better
14:29:26 <thoughtpolice> the parallel shootout entries seem like fine waters to test things
14:29:36 <gwern> jeffwheeler: I see usage of 136MB, as compared with 1.1gb
14:29:58 <jeffwheeler> gwern: that's good. :)
14:30:09 <dons> thoughtpolice: yeah, we only need 1 or 2 points to beat C again
14:30:36 <jeffwheeler> gwern: try copying this into a file and see if it highlights it: http://pastie.org/326810
14:30:37 <lambdabot> Title: #326810 - Pastie
14:30:45 <jeffwheeler> gwern: it's nonsense, but it's not doing anything
14:31:20 <thoughtpolice> dons: on the binary trees entry ( http://haskell.org/haskellwiki/Shootout/Parallel/BinaryTreesDPH ) I noticed that DPH is losing to parallel strategies, but I might be missing something that could help DPH pull ahead...
14:31:21 <gwern> jeffwheeler: no, I'm seeing highlighting
14:31:22 <lambdabot> Title: Shootout/Parallel/BinaryTreesDPH - HaskellWiki
14:31:29 <jeffwheeler> gwern: hmm; funky
14:31:31 <gwern> I can send you a screenshot if you'd like
14:31:44 <ddarius> thoughtpolice: Strategies seems more appropriate for that.
14:31:44 <jeffwheeler> gwern: nah, I believe you; I'll keep playing with it and see what's happening
14:32:05 <jeffwheeler> gwern: I can get it if I add a quote or something, but just loading up the file gives nothing but black
14:32:39 <gwern> jeffwheeler: gtk I take it?
14:32:45 <jeffwheeler> gwern: vty
14:32:50 <gwern> oh
14:33:03 <jeffwheeler> gwern: HOC broke again on my Mac. I'm just now installing on NetBSD/GNOME. :D
14:33:27 <gwern> hm. this is intersting
14:33:43 <gwern> I save it to a text file, rename .hs, and yi text.hs shows no highlighting
14:33:58 <gwern> but after a little typing, highlighting happens!
14:34:04 <jeffwheeler> gwern: ha. It's not me afterall. :D
14:34:47 <gwern> specifically, if I start a newline, type 9 characters, then highlighting happens
14:34:51 <jeffwheeler> I tried to learn the `darcs trackdown` command without reading the docs; I had wonderful luck: "Success!" (and that is all)
14:35:05 <jeffwheeler> gwern: perhaps it's the file's length?
14:35:16 <gwern> maybe. I'll try that
14:35:46 <jeffwheeler> Adding a few more lines doesn't help me.
14:35:49 <gwern> jeffwheeler: trackdown is hard to use; the argument is a program to run
14:35:57 <gwern> jeffwheeler: well, adding an = seems to speed it up
14:35:58 <jeffwheeler> gwern: I'll avoid that. ;)
14:36:10 <jeffwheeler> Yeah, equals did the trick for me, too.
14:36:13 <gwern> ie, without an =, I need more than 9 characters to trigger highlighting
14:36:22 <gwern> about 20 or 30
14:36:41 <jeffwheeler> Even then, it gives wonky highlighting, usually.
14:37:05 <gwern> looks normal enough for vty
14:37:38 <gwern> but opening up Main.hs immediately has highlighting
14:37:48 <jeffwheeler> I know what's happening when the highlighting gets weird (for me) . . . the char positions of the colors are being saved, but the char count before that is moving.
14:37:50 <gwern> I'll try shrinking it and seeing what length triggers it
14:38:11 <thoughtpolice> gwern: I just darcs pulled and installed, opening lhc/src/Main.hs brought up highlighting...
14:38:12 <jeffwheeler> I.e. the positions in the file, not positions from the SOL.
14:38:30 <thoughtpolice> oh, and it is much better in memory usage
14:38:36 <thoughtpolice> 80mb -> 20mb
14:39:00 <jeffwheeler> I think I was happier with my sane highlighting. :P
14:40:17 <gwern> aha, the line length is somewhere between 10 and 20
14:41:10 <gwern> here we go - if you have <=9 lines of stuff, highlighting doesn't automatically start
14:41:20 <gwern> >=10 and highlighting is triggered
14:41:38 <xcthulhu> vixey: Sorry.  Yeah, I just emailed Hales and said "I'm an Masters student and I think formal proof is cool and I am ready to spend a summer programming in linear program checking stuff"
14:41:53 <vixey> oh wow
14:41:55 <xcthulhu> And so now if there's money...
14:41:57 <jeffwheeler> gwern: Indeed. Adding one more line and saving the file gets it working.
14:42:21 * jeffwheeler tries to guess how to fix that.
14:44:01 <dons> Lemmih: how do we solve this,
14:44:01 <dons> $ cat A.hs
14:44:01 <dons> main = print "yes"
14:44:01 <dons> $ lhc A.hs
14:44:01 <dons> lhc: user error (LibraryMap: Library base not found!)
14:46:32 <thoughtpolice> dons: you'll need the source repository has it stands to install base :( sry
14:47:09 <thoughtpolice> dons: I also recommend using the darcs version of cabal and cabal install since they have lhc support; after that you can do 'cd lhc/lib/base; cabal install --lhc'
14:47:30 <dons> is this on a wiki page somewhere?
14:47:40 <thoughtpolice> http://lhc.seize.it/
14:47:42 <lambdabot> Title: Wiki - Front Page
14:47:50 * jeffwheeler just realized how much competition Don Stewart has on Google :P
14:47:53 <gwern> jeffwheeler: I've sent my email on the topic
14:47:58 <jeffwheeler> gwern: appreciated
14:47:59 <dons> jeffwheeler: oh, name-wise?
14:48:04 <jeffwheeler> dons: yep
14:48:11 <dons> yeah, its a very common name
14:48:16 <thoughtpolice> dons: yeah the instructions to do it are there; I might want to put up why we can't quite put lhc's base on hackage yet
14:48:43 <thoughtpolice> dons: the lhc wiki is somewhat neglected right now :x
14:48:50 <dons> a sequence of steps from cabal install lhc through to ./helloworld would be good
14:49:05 <dons> i've forgotten how i used to do all this with jhc + nobench
14:49:20 <thoughtpolice> dons: yeah might be a good idea
14:49:27 <thoughtpolice> i also need to note that the repository is using darcs2 now
14:50:44 <gwern> jeffwheeler: I've just noticed that sutff you type in is also delayed in being highlighted as well :(
14:51:05 <gwern> I hope that's not an intrinsic tradeoff in yi - up to date highlighting, or reasonable memory use
14:51:41 <jeffwheeler> gwern: I suspect these are minor problems that can be fixed, but as a Haskell newbie, I don't understand all of the parsing stuff.
14:51:46 <jeffwheeler> gwern: I wish I did. :(
14:51:58 <gwern> I don't either. good thing jpb does
14:52:05 <jeffwheeler> gwern: Indeed. :P
14:52:19 <SamB_XP> how long is it delayed ?
14:52:26 <jeffwheeler> I came to Yi looking for something that did it the Right Way, like I think TextMate on OS X does.
14:52:32 <thoughtpolice> man, I would *kill* for macro support in yi right now
14:52:38 <jeffwheeler> It's the only other editor for which I can respect the parser.
14:52:53 <jeffwheeler> thoughtpolice: I've never understood the use of macros. What do you want to do?
14:52:58 <thoughtpolice> just having 'C-x ( ... C-x )' == win
14:53:08 <gwern> SamB_XP: 5 or so keystrokes
14:53:16 <jeffwheeler> thoughtpolice: hm?
14:53:16 <SamB_XP> gwern: keystrokes ?
14:53:24 <SamB_XP> ... what about seconds ?
14:53:26 <gwern> yes, that thing hwere you press a key
14:53:32 <jeffwheeler> JPB just applied a patch.
14:53:32 <gwern> no, yi doesn't really go by seconds
14:53:37 <thoughtpolice> jeffwheeler: I mainly use it to record repetative things
14:53:42 <SamB_XP> maybe it ought to do that too ?
14:53:45 <thoughtpolice> jeffwheeler: for one I use it all the time when reformatting my source code
14:53:58 <thoughtpolice> because normally there are only a few general steps needed to reformat every line the way I want
14:54:04 <jeffwheeler> thoughtpolice: hm, can it not be written using a normal Haskell function?
14:54:12 <xcthulhu> vixey:  Apparently Isabelle now supports multi-parameter type-classes...  so I will be able to do this whole thing the right way :)
14:54:13 <gwern> SamB_XP: for example, suppose you hit C-c C-l to reload your code in ghci; the displayed ghci buffer doesn't actually update until you hit a key
14:54:39 <thoughtpolice> so I start recording, do what I want, move down to the next line and back into the initial position, and stop recording. then I can just keep doing 'C-x e' several times, and it will just go down, applying all that formatting
14:55:07 <dons> thoughtpolice, Lemmih i'd suggest replying to the daniel fischer's mail on the list with the exact process to get a working lhc via cabal-install
14:55:17 <thoughtpolice> which is really terrifically useful in the case of, e.g. go to the beginning of the line, move forward five spaces, back up three spaces, then go to the end and add a comma, etc.
14:55:28 <hartke> hello, i have a problem with my encode function , what i need to do is to save the chars to a string but how? http://hpaste.org/12495
14:55:43 <gwern> thoughtpolice: I too would like macros, but I don't really know how to implement them so I haven't tried
14:55:46 <thoughtpolice> dons: righto
14:56:06 <jeffwheeler> thoughtpolice: I suppose I can see that being useful, but perhaps there's some way to record that into an actual Haskell function or sorts?
14:56:10 <dons> oh, you're using gitit?
14:56:15 <dons> you should tell lispy
14:56:29 <dons> lispy: lhc hosted on gitit, http://lhc.seize.it/
14:56:31 <lambdabot> Title: Wiki - Front Page
14:56:47 <gwern> dons: I've mentioned the lhc wiki on the darcs bug report about gitit
14:56:49 <thoughtpolice> dons: is lispy a fan of gitit? :)
14:56:51 <gwern> as an example
14:57:34 <solrize_> hartke you mean you want to concatenate all those enc1 results ?
14:57:37 <solrize_> use concatMap
14:57:44 <jeffwheeler> gwern: JPB's fix seems to work perfectly. Damn, he's good.
14:58:02 <sylvan> Should parallel haskell work in GHC 6.10.1? I get it to recognize the syntax, but it doesn't use multiple cores (compiled with -threaded, run with +RTS -N2)...
14:58:08 <sylvan> sorry, data parallel haskell
14:58:15 <thoughtpolice> sylvan: yes, it does
14:58:15 <gwern> jeffwheeler: I is still compiling
14:58:22 <sylvan> on windows as well?
14:58:29 <gwern> sylvan: sounds like the not-enough-sparks problem
14:59:09 <sylvan> hmm... how can I make it user more sparks?
14:59:12 <sylvan> use
14:59:14 <hartke> solri: yes but first i have to do this for my whole string, at the moment i only take the "head"
14:59:26 <sylvan> I do this: print $ [: fib n | n <- [: 40,41 :] :]
15:01:59 <hartke> oh, in the paste there is this "map"... it does not work because of different expected type... i have to do this now without map
15:03:03 <athos> i tried to build yi (darcs) and the building process aborts with the following error: http://rafb.net/p/6wqaoO41.html
15:03:04 <lambdabot> Title: Nopaste - No description
15:03:14 <athos> any clues about that? i'm btw. using ghc 6.8.3
15:04:09 * jeffwheeler wonders whether vty 3.1.2 works.
15:04:16 <gwern> athos: you have two choices, either edit the offending files to import Control.OldException instead of Control.Exception
15:04:30 <gwern> or edit vty.cabal to read base < 4 rather than 'base' or whatever
15:05:51 <gwern> jeffwheeler: what is a pango frontend? I thought that was just a library firefox used for displaying odd language scripts
15:06:18 <jeffwheeler> gwern: no, it's a drawing toolkit for many linux systems
15:06:46 <gwern> does it work well?
15:07:01 <jeffwheeler> gwern: the current ui doesn't
15:07:35 <jeffwheeler> gwern: I think the idea was that if we drew the stuff ourselves, it'd be faster than offloading it to gtk
15:07:51 * gwern tests the fixskip patch. good, it seems to work and the memory usage is the same
15:08:08 * jeffwheeler just realized that his major presentation for this school semester is _this_ Thursday, not next.
15:08:10 <jeffwheeler> Crap!
15:08:14 <jeffwheeler> Later. :D
15:08:43 <athos> gwern: because i'm fairly new to haskell, allow me one more question: where does cabal put the distfiles (e.g. the mentioned file vty.cabal or Graphics/Input/LLInput.hs)
15:10:27 <sylvan> Tried doing this to make sure there's plenty of work (which should cause more sparks): print $ [: True | n <- [: 1000 .. 3000 :], fac n == 0 :], still no joy. It simply does not use multiple cores... Parallel strategies don't work either, but explicit forkIO does.
15:10:53 <orbitz> what is [:?
15:11:02 <gwern> a happy face
15:11:07 <SamB_XP> for PArrays
15:11:12 <orbitz> and :] ?
15:11:13 <SamB_XP> or something like that
15:11:18 <SamB_XP> orbitz: the other end
15:11:26 <orbitz> 2 happy faces?
15:11:29 <gwern> athos: well, there's no real way to do that editing for cabal-install
15:11:32 <hackage> Uploaded to hackage: regexpr 0.5
15:11:42 <SamB_XP> :t [: :]
15:11:43 <lambdabot> parse error on input `:'
15:11:46 <gwern> orbitz: that's what you get when you rotate a happy face 180 degrees
15:11:56 <SamB_XP> gwern: fixorate
15:12:14 <SamB_XP> preflex: type [: :]
15:12:26 <SamB_XP> preflex: %type [: :]
15:12:28 <gwern> athos: I think you will have to go to hackage and download the tarball yourself and do the runhaskell Setup configure/build/install dance
15:12:31 <SamB_XP> preflex: list
15:12:31 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
15:12:43 <athos> gwern: ok
15:12:46 <orbitz> preflex: zdec
15:12:48 <athos> gwern: thanks
15:13:18 <gwern> SamB_XP: that looks like syntax to me; does that have a type :T can be asked about?
15:13:25 <dons> sylvan: oh, data parallel haskell, yes, should work.
15:13:39 <dons> thoughtpolice: lispy is a fan of making a darcs backend to gitit
15:14:16 <SamB_XP> preflex: :t [: :]
15:14:20 <sylvan> dons, it doesn't. Neither does parallel haskell. forkIO does use multiple cores (with +RTS -N2), but any other form of parallelism seems to be broken... Has anyone actually tested that this works on the windows binary build?
15:14:32 <SamB_XP> gwern: if you set the right options, it should
15:14:33 <dons> sylvan: other forms certainly work.
15:14:33 <sylvan> parallel strategies I mean
15:14:41 <dons> strategies . see my post earlier today.
15:14:53 <sylvan> dons, on windows?
15:14:54 <dons> let me get you the mail
15:14:56 <gwern> SamB_XP: hoogle doesn't seem to know [: :] or [: either
15:15:06 <dons> windows, unknown, if forkIO works everything should work
15:15:24 <SamB_XP> @hoogle []
15:15:24 <lambdabot> Did you mean: [a] /count=20
15:15:25 <lambdabot> Prelude undefined :: a
15:15:25 <lambdabot> Data.Array.Base arrEleBottom :: a
15:15:25 <dons> sylvan: we've not moved to 6.10.x yet at galois
15:15:35 <SamB_XP> ???
15:15:38 <SamB_XP> what the heck ?
15:15:46 <sylvan> yeah forkIO does, but all the "nice" form of parallelism don't, and haven't fora while (they didn't in 6.8.2, I posted on haskell or haskell-cafe about it but work got in the way of actually tracking down why it didn't work)
15:16:01 <dons> sylvan: re. strategies, http://www.haskell.org/pipermail/haskell-cafe/2008-November/050974.html
15:16:03 <lambdabot> Title: [Haskell-cafe] Re: Problem getting code from AFP08 parallel tutorial to run in p ..., http://tinyurl.com/5sgdkl
15:16:15 <dons> sylvan: known issue with 1 spark not being enough to fire up 2nd core
15:16:29 <dons> and strategies users are encourages to try the head, which has cheaper 'work stealing' `par` sparks
15:17:35 <dons> thoughtpolice: enjoy, http://www.reddit.com/r/programming/comments/7ged5/lhc_wholeprogram_highly_haskell_optimizing/
15:17:37 <lambdabot> Title: LHC: whole-program, highly Haskell optimizing compiler (and site running gitit w ..., http://tinyurl.com/5ga9vx
15:18:25 <sylvan> dons, it didn't work in 6.8.2 either though, isn't the sparks issue just 6.10?
15:19:13 <dons> sylvan: yes.
15:19:24 <dons> sylvan: so you may have some kind of windows-only sparks issue?
15:19:24 <thoughtpolice> sylvan: you have to build programs that use DPH in a very special way
15:19:32 <dons> DPH requires 6.10
15:19:35 <thoughtpolice> sylvan: what's the command you're compiling the program with?
15:19:52 <athos> gwern: when was Control.OldException implemented (which base version)? seems that my base version doesn't contain it
15:19:56 <dons> thoughtpolice: re. wrong version of lhc, ask Ross Paterson to remove the earlier version
15:20:00 <dons> thoughtpolice: do you have his email
15:20:02 <athos> Graphics/Vty/LLInput.hs:16:7:
15:20:02 <athos>     Could not find module `Control.OldException':
15:20:02 <athos>       Use -v to see a list of the files searched for.
15:20:16 <dons> athos: add --constraint='base<4'
15:20:17 <thoughtpolice> dons: I think it's on hackage.haskell.org
15:20:25 <dons> ?
15:20:27 <sylvan> thoughtpolice: ghc --make -O2 -threaded -XPArr parr.hs
15:20:28 <thoughtpolice> dons: also I just replied to daniel covering all his problems i think
15:20:33 <dons> yep
15:20:43 <dons> and to fix the 'wrong version' problem, ask Ross.
15:20:47 <sylvan> thoughtpolice: it accepts the syntax and everything, but just doesn't seem to parallelise it
15:20:48 <thoughtpolice> sylvan: yeah, you're doing it wrong. this particular part of the process isn't exactly covered
15:20:51 <thoughtpolice> dons: I will
15:20:59 <dons> trying with cabal install lhc-0.6.20081127
15:21:17 <thoughtpolice> sylvan: to get my DPH programs working on multiple cores, I had to look at the actual dph benchmarks and makefiles to see how they built
15:21:19 <sylvan> dons, yeah looks like it. I'm on Vista 64 but I tried the parallel strategies problem on my work machine which is XP (32 bit).
15:21:23 <dons> ok
15:21:31 <dons> sylvan: talk to JaffaCake .
15:21:39 <thoughtpolice> sylvan: also, the parallel array syntax sugar does not work too well in general I've found
15:21:42 <dons> he's super active on parallelism these days
15:21:49 <dons> thoughtpolice: yeah, i'd use the combinators
15:21:58 <dons> list comprehensions are for children and the infirm :)
15:22:09 <thoughtpolice> sylvan: http://haskell.org/haskellwiki/Shootout/Parallel/BinaryTreesDPH
15:22:11 <lambdabot> Title: Shootout/Parallel/BinaryTreesDPH - HaskellWiki
15:22:16 <thoughtpolice> ^^ look there for a good DPH example that does use both cores
15:22:37 <thoughtpolice> the compile line is this: ghc --make -fcpr-off -threaded -fdph-par -package dph-base -Odph
15:22:45 <sylvan> thoughtpolice: Okay I'll try that
15:22:46 <dons> -Odph ?
15:22:55 <thoughtpolice> sylvan: the reasoning is that with DPH, you can either build a sequential version of your program, or a parallel version of your program
15:22:57 <dons> huh. so that wraps all the funky flags i guess?
15:23:06 <dons> ghc: panic! (the 'impossible' happened)
15:23:06 <dons>   (GHC version 6.10.0.20081007 for x86_64-unknown-linux):
15:23:06 <dons> 	urk! lookup local fingerprint main:FrontEnd.Rename.:CoRM{tc r6B5f}
15:23:06 <dons> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
15:23:06 <dons> cabal: Error: some packages failed to install:
15:23:08 <lambdabot> Title: ReportABug - GHC - Trac
15:23:13 <thoughtpolice> sylvan: if you compile with -fdph-seq, programs won't use multiple cores or threads
15:23:26 <thoughtpolice> sylvan: otoh, using -fdph-par, they will
15:23:27 <dons> that bug i hit while cabal installing lhc
15:23:32 <thoughtpolice> dons: yikes!
15:23:35 <dons> nice
15:23:38 <dons> with 6.10
15:23:48 <thoughtpolice> dons: also yeah -Odph stands for a couple other flags
15:23:54 <thoughtpolice> I think that's actually mentioned in the 6.10.1 manual
15:23:57 <thoughtpolice> in like, 1 sentence
15:23:58 <thoughtpolice> somewhere
15:23:58 <athos> dons: by keeping import Control.OldException instead of Control.Exception, the error keeps the same. by changing it to default (import Control.Exception) again, i get: http://rafb.net/p/1GriIL56.html
15:23:59 <thoughtpolice> :)
15:23:59 <lambdabot> Title: Nopaste - No description
15:24:09 <athos> dons: + using the constraint of course
15:24:36 <dons> athos: you should just use Control.Exception and --constraint='base<4'?
15:25:00 <athos> yeah, i did
15:25:04 <athos> that's the outcome
15:25:04 <dons> ?bug
15:25:05 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:25:09 <sylvan> thoughtpolice: That didn't work either I'm afraid... And even if it had, doesn't explain why parallel strategies don't work.
15:25:11 <dons> athos: what package?
15:25:22 <athos> vty-3.1.4
15:26:15 <dons> thoughtpolice: http://hackage.haskell.org/trac/ghc/ticket/2826
15:26:17 <lambdabot> Title: #2826 (Panic compiling lhc-0.6.20081127) - GHC - Trac
15:26:17 <thoughtpolice> sylvan: oh, if parallel strategies aren't working either, then I'd say that's a bug
15:26:37 <thoughtpolice> dons: k. can you try with GHC 6.10.1?
15:26:40 <athos> 00:25:05 < lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:26:42 <sylvan> surely *someone* else must be using windows? :-)
15:26:43 <athos> whoops
15:26:45 <thoughtpolice> or do you only have 6.10.0.2008... ?
15:26:48 <dons> ah yes.
15:26:51 <dons> let me update.
15:26:56 <flooas> may someone look at a small piece of code that doesn't work? I'm new to haskell and don't understand whats wrong: http://pastebin.com/m7732c7a2
15:27:19 <dons> welcome, flooas !
15:27:35 <dons> flooas: using tabs?
15:27:38 <flooas> thank you
15:27:50 <dons> that indenting looks correct
15:28:26 <dons> http://pastebin.com/m41e071e1
15:28:36 <dons> would be how i'd write it. but i suspect your error is elsewhere?
15:29:07 <flooas> dons: thank you very much. I will test this right away
15:29:59 <luite_> ah I finally got lambdabot compiled (a few changes were needed due to moved packages), now I just need to find out how to use it
15:30:04 <flooas> dons: fantastic. That worked :)
15:30:39 <dons> flooas: hm i guess you had some tabs
15:31:36 <flooas> dons: oh, your not supposed to use tabs at all?
15:33:24 <dons> oh, i screwed up the title before, http://www.reddit.com/r/programming/comments/7gef0/lhc_an_aggressively_optimising_whole_program/
15:33:30 <lambdabot> Title: LHC: an aggressively optimising whole program Haskell compiler (and site hosted  ..., http://tinyurl.com/56wlcr
15:33:33 <dons> flooas: well, tabs are 8 spaces
15:33:34 <dons> so if you use tabs, then set tabwidth to say 4, that breaks things
15:34:59 <flooas> i think my tab width is 3 ... eek!
15:35:01 <lucca> hmmmm, was looking at the HARM thing recently added/updated on hackage
15:35:05 <flooas> I'll change that
15:35:07 <luite_> hm, do I have to edit the Config.hs file to change the nick or server for lambdabot?
15:35:11 <lucca> (an ARM assembler/disassembler/emulator)
15:35:12 <flooas> thanks for the advice and help dons
15:35:26 <lucca> it has it's own recursive descent parser combinator library
15:35:30 <dons> flooas: best to just not use tabs (i.e. in vim, set expandtab)
15:35:55 <lucca> ParseLib... looks a lot like Parsec
15:36:57 <dons> harm. mm.
15:37:16 <lucca> looks like it predates parsec
15:37:25 <flooas> dons: OK, i'll figure out how to do that in my editor
15:41:32 <thoughtpolice> @seen lispy
15:41:33 <lambdabot> lispy is in #haskell, #haskell-blah and #darcs. I last heard lispy speak 20h 4s ago.
15:42:05 <thoughtpolice> @tell lispy did you ever get my message about haskell irc clients? http://www.haskell.org/pipermail/haskell-cafe/2008-November/051020.html if you would like to work on something I am game.
15:42:06 <lambdabot> Consider it noted.
15:42:27 <thoughtpolice> dons: lhc.seize.it updated to contain more important information about compilation/using etc.
15:42:32 <dons> yay
15:46:16 <dcoutts> thoughtpolice: is the lhc base that different from the standard base package?
15:46:35 <dcoutts> thoughtpolice: can you not get your lhc/jhc changes into the standard base lib, and upload that to hackage
15:46:43 <thoughtpolice> dcoutts: I haven't looked into lhc's base package extensively.
15:46:45 <dons> upload base to hackage?
15:46:48 <thoughtpolice> dcoutts: that thought has crossed my mind, yes
15:47:05 <dcoutts> dons: base is already on hackage isn't it? there's no reason for it not to be
15:47:19 <dons> its not on hackage.
15:47:33 <dcoutts> thoughtpolice: nobody will object to the standard base being on hackage, but do coordinate its release with Igloo and JaffaCake
15:47:34 <dons> and people are scared it will break things :)
15:47:43 <dcoutts> dons: I don't think it'll break things
15:47:45 <dons> yes. i think it has to be either the standard base, or you choose a new name
15:47:46 <dcoutts> what will it break?
15:47:51 <dons> no idea. you're the cabal master.
15:48:04 <dons> if they upload a fake base though
15:48:07 <dcoutts> well cabal-install will not upgrade base for you, unless you specifically ask to
15:48:16 <dcoutts> so I don't anticipate any breakage
15:48:27 <dons> but if they upload a lhc-only package called 'base'
15:48:34 <dcoutts> then that'd be bad
15:48:37 <dons> yeah
15:48:46 <dcoutts> but uploading the standard base is fine
15:48:46 <dons> so you can't call something base.
15:48:50 <dons> there's already a standard base.
15:49:02 <thoughtpolice> dcoutts: ok, I'll talk to them and Lemmih and we can work something out I bet.
15:49:03 <dcoutts> which works with hugs, nhc and ghc
15:49:07 <dons> yep
15:49:20 <dcoutts> so it's not much more to add jhc/lhc support
15:49:33 <dcoutts> except perhaps that jhc/lhc cannot compile much of the standard base
15:49:38 <SamB_XP> what is lhc ?
15:49:44 <dcoutts> but nhc manages ok with cpp
15:49:52 <thoughtpolice> dcoutts: merging ours into the standard base seems like a reasonable option - like I said I'll talk to people. :)
15:50:06 <dcoutts> thoughtpolice: long term it's the only sensible solution
15:50:37 <dcoutts> thoughtpolice: perhaps with some extra jhc-base package that base depends on when built with jhc
15:50:44 <dons> probably not merging in new code, just ensuring the code that's there you can handle
15:51:01 <dcoutts> thoughtpolice: that's how it's done with hugs, the base modules often just import Hugs.Thing or GHC.Thing
15:51:06 <thoughtpolice> dcoutts: hm yes
15:51:15 <dcoutts> dons: there are per-compiler primitives
15:51:20 <SamB_XP> does JHC use the main base now ???
15:51:24 <dcoutts> SamB_XP: no
15:51:56 <SamB_XP> last I heard it's dependancy graph had a giant SCC
15:52:17 <dcoutts> SamB_XP: is that a problem?
15:52:20 <gwern> SCC?
15:52:28 <thoughtpolice> i need to email ross about hiding/removing lhc-20081121 from hackage right fast
15:52:30 <dons> yes, so we'd need an lhc-prim and base can depend on it when via lhc
15:52:41 <dons> dcoutts: do you know how to get a bad package off hackage?
15:52:48 <dcoutts> dons: generally you don't
15:52:51 <SamB_XP> gwern: Strongly Connected Component
15:52:58 <dons> right. they uploaded an incorrect version though
15:53:01 <dcoutts> dons: it breaks URLs and downstream packages
15:53:02 <dons> which breaks all the version checks for lhc
15:53:03 <gwern> SamB_XP: is this graph theory terminology?
15:53:06 <vixey> huh??
15:53:09 <SamB_XP> gwern: yes!
15:53:11 <vixey> You get SCCs between _modules_?
15:53:18 <dcoutts> dons: at the moment I'd make an exception, in future I'd like to add blacklisting
15:53:19 <dons> dcoutts: so the first upload looks newer than all later uploads
15:53:22 <dons> yeah
15:53:27 <dons> sure
15:53:30 <SamB_XP> it means that the modules need to be compiled together, because they are mutually imported
15:53:37 <vixey> that's horrendous
15:53:41 <vixey> who would do that .. ?
15:53:44 <gwern> oh. I didn't know mutual imports were allowed
15:53:44 <dcoutts> SamB_XP: and jhc can do that can't it?
15:53:51 <dcoutts> vixey: C modules do that all the time
15:53:52 <thoughtpolice> yes, it can
15:53:58 <thoughtpolice> it supports mutually recursive modules natively
15:54:04 <gwern> (great, WP has an article on SCC)
15:54:06 <vixey> what
15:54:08 <thoughtpolice> and by association, so does lhc
15:54:18 <SamB_XP> dcoutts: well, it's slow, and I expect it would make it messier to merge into the main base package ...
15:54:21 <roconnor> jhc supports mutually recursive modules?
15:54:25 <vixey> I'm asking about Haskell though
15:54:32 <thoughtpolice> roconnor: yes
15:54:33 <SamB_XP> vixey: yes, in Haskell
15:54:35 <roconnor> finally a true Haksell compiler!
15:54:39 <dcoutts> vixey: think about it. Each module uses a .h file with the interface and the .c files import several of the other module's .h files. There's no problem with mutually recursive modules there.
15:54:43 <vixey> repeat: who would do that .. ?
15:54:46 <SamB_XP> roconnor: dunno about THAT
15:54:50 <dancor> @hoogle [Either a b] -> ([a], [b])
15:54:50 <walski> bye
15:54:50 <lambdabot> No results found
15:55:02 <SamB_XP> there are other places where it has epic phail, I think
15:55:09 <roconnor> SamB_XP: doesn't H98 require support for mutially recursive modules?
15:55:12 <vixey> dancor, foldr
15:55:12 <dcoutts> vixey: well the point is that in principle there's nothing wrong in wanting to do that, eg to split large modules
15:55:15 <SamB_XP> roconnor: yes
15:55:22 <roconnor> SamB_XP: oh
15:55:32 <roconnor> so there are still no Haskell compilers then
15:55:41 <thoughtpolice> SamB_XP: yes, there is some fail in there
15:55:44 <SamB_XP> but I think you are also supposed to have non-buggy lowering of typeclasses ;-P
15:55:46 <thoughtpolice> me and Lemmih are working on it. :)
15:56:20 <SamB_XP> such that your intermediate code is well-typed, and so on ...
15:56:51 <luite_> I just compiled lambdabot and most plugins run fine, but eval always returns 'Terminated', how can I find out what's wrong?
15:57:10 <SamB_XP> personally, it makes me wonder if recursive imports are worth having
15:58:18 <roconnor> I'd have to run though less hoops in my colour lib if I had recursive imports.
15:59:41 <roconnor> Can I put a typeclass instance before a type class declaration?
15:59:57 <skorpan> did you try it?
16:00:04 <roconnor> nope
16:00:14 <roconnor> there aren't any haskell compilers :P
16:01:32 <thoughtpolice> ok, emailed ross
16:01:43 <thoughtpolice> hopefully we can have this hackage version problem thing sorted out easily
16:01:55 <luite_> @seen Cale
16:01:56 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 16h 54m 20s ago.
16:03:00 <vovik> pl \x y -> x y
16:03:07 <mauke>  id
16:03:19 <vovik> you're not lambda bot
16:03:31 <mauke> oh, sorry
16:03:31 <dancor> :)
16:03:57 <vovik> does anyone know how to swap parameter order
16:03:59 <RayNbow> roconnor: yes, you can
16:04:02 <vovik> for purposes of pointfreeness?
16:04:05 <dancor> @type flip
16:04:06 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:04:07 <idnar> vovik: flip
16:04:16 <vovik> idnar: thx
16:04:21 <idnar> @pl \f x y -> f y x
16:04:21 <lambdabot> flip
16:04:43 <RayNbow> roconnor: you can have type class instances before the class declarations
16:04:45 <roconnor> RayNbow: can I use that type instance in some definitions in the class declaration?
16:05:25 <RayNbow> roconnor: wait, let's use a hpaste :p
16:05:58 <RayNbow> roconnor, http://hpaste.org/12498
16:07:22 <thoughtpolice> @tell Lemmih the solution proposed for lhc's base problem is to merge it into the actual standard base package that nhc, hugs and ghc use. we should then be able to upload to hackage no problem; we need to find some time to talk to Igloo and JaffaCake about this
16:07:22 <lambdabot> Consider it noted.
16:08:10 <pumpkin_> wow, GHC is using up a lot my memory trying to read in this CSV file
16:08:11 <RayNbow> roconnor: please annotate the hpaste if you want me to test something else :)
16:08:14 <vovik> @pl mFlatMap j f = f $ fromJust j
16:08:15 <lambdabot> mFlatMap = flip id . fromJust
16:08:39 <pumpkin_> the csv file is 122 megs, GHC has allocated over a gig already
16:08:56 <ddarius> pumpkin: As a literal?
16:09:00 <pumpkin_> dons: is there some way I can make your Text.CSV.ByteString more lazy?
16:09:20 <pumpkin_> ddarius: I just did ByteString.readFile, passed it into parseCSV
16:09:34 <ddarius> pumpkin: So you mean GHCi?
16:09:38 <vovik> why would you compose id with anything?
16:09:38 <pumpkin_> oh yeah :)
16:09:53 <pumpkin_> I guess it would be a lot more efficient if I compiled it
16:10:32 <roconnor> RayNbow: http://hpaste.org/12498#a1
16:10:50 <roconnor> RayNbow: not the best example in the world, but probably good enough.
16:10:58 * RayNbow does :r
16:11:03 <dons> pumpkin_: you mean, apply it to a lazy bytestring?
16:11:03 <RayNbow> reloads fine
16:11:13 <roconnor> heh
16:11:14 <roconnor> sweet
16:11:43 <pumpkin_> dons: yeah, I only did take 1 record out of my huge csv file, but I got the impression it loaded it all in at once (or at least I hope so, if it allocated 1.3 gigs)
16:11:55 <dons> it uses a strict bytestring
16:11:56 <roconnor> So we cando "pa >> pb = (return id) . pa <@> pb" in the other prelude.
16:12:02 <pumpkin_> ah
16:12:07 <dons> actually, since it uses alex for parsing
16:12:13 <dons> it should be trivial to generate a lazy version
16:12:14 <dons> ...
16:12:15 <dons> mm
16:12:20 <dons> ok. i'll try!
16:12:25 <pumpkin_> :o
16:12:27 <pumpkin_> yay
16:12:35 <dons> the joys of using a lexer generator
16:12:48 <pumpkin_> is there a bytestring analog to read?
16:13:04 <pumpkin_> to convert it into a Float
16:13:15 <RayNbow> roconnor: what is <@>?
16:13:21 <roconnor> ap
16:13:25 <dons> pumpkin_: in the bytestring-lexing package
16:13:30 <dons> read as Double, fromIntegral it
16:13:54 <dancor> vixey: ah, there is actually
16:13:56 <pumpkin_> sweet, thanks
16:13:58 <dancor> @type partitionEithers
16:13:59 <lambdabot> Not in scope: `partitionEithers'
16:14:10 <dancor> maybe it's new?
16:14:31 <luite_> is hint/mueval incompatible with ghc 6.10.1? I Get this error trying to compile hint: src/Hint/Parsers.hs:7:21: Module `GHC' does not export `Session'
16:14:37 <roconnor> I guess return id === flip return
16:14:50 <roconnor> @type return id
16:14:52 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> a)
16:14:56 <pumpkin_> btw, the hackagedb claims the bytestring csv and bytestring lexing packages both fail
16:14:59 <roconnor> @type flip return
16:15:00 <lambdabot> forall a b. b -> a -> a
16:15:18 <RayNbow> roconnor: so (.) binds stronger than (<@>)?
16:15:35 <roconnor> it ought to.
16:15:51 <roconnor> f <$> a <@> b is a standard idiom
16:16:32 <roconnor> er
16:16:36 <roconnor> f <$> a <*> b is a standard idiom
16:16:37 <dcoutts> isn't someone getting confused between <*> and <@>
16:16:39 <dcoutts> right
16:16:53 <roconnor> which is f . a <@> b using the new improved notation.
16:16:57 * RayNbow always has trouble with operator precedence :p
16:17:28 <RayNbow> (except for the usual addition/subtraction/mul/div/exp/etc. operators)
16:17:47 <dancor> @type (<@>)
16:17:48 <lambdabot> Not in scope: `<@>'
16:17:59 <pumpkin_> yay RWH is coming in on monday
16:18:14 <roconnor> dancor: <@> new new notation for <*>
16:18:34 <RayNbow> roconnor: what are your thoughts on (++) for the other prelude?
16:18:34 <kjdf> I have a bytestring with a machine encoded array of (4 byte) floats
16:18:45 * RayNbow posted something on the talk page a few days ago
16:18:51 <kjdf> I'd like to convert it to a list of haskell floats, what is a good way to do that?
16:18:57 <roconnor> RayNbow: you mean using (++) to replace `mappend`?
16:19:14 <kjdf> in ruby I'd write something like "aaaabbbb".unpack('f*')"
16:19:58 <RayNbow> roconnor: well, the wiki page suggests that (++) would be mplus... I posted a suggestion on the talk page that it should be used for mappend :p
16:19:59 <pumpkin_> kjdf: I was looking for something like that the other day, but didn't find anything :/ Data.Binary.Get didn't have methods
16:21:02 <roconnor> RayNbow: ah, I see the problem
16:21:10 <roconnor> hmm
16:21:39 <roconnor> RayNbow: can we have both, and then wrap the other monoid operation on (m a)?
16:21:46 <scodil> kjdf: I think you can use the low-level bytestring interface to access the bytestring storage, then do it just as you would in C, with pointer casting
16:22:01 <thoughtpolice> kjdf: http://hackage.haskell.org/packages/archive/bytestring-lexing/0.1.2/doc/html/Data-ByteString-Lex-Double.html
16:22:02 <lambdabot> Title: Data.ByteString.Lex.Double, http://tinyurl.com/6qmka6
16:22:09 <thoughtpolice> kjdf: would that work?
16:22:34 <scodil> thoughtpolice: i think he means that the bytestring already has IEEE floats, not ascii representations.... am I right kjdf?
16:22:43 <RayNbow> instance MonadPlus m => Monoid (m a) where ; mempty  = mzero ; mappend = mplus  -- you mean something like this, roconnor?
16:22:55 <kjdf> thoughtpolice: yes, thanks :)
16:23:22 <roconnor> RayNbow: ya, that's what I was thinking.  but now I'm not so sure.
16:23:34 <pumpkin_> kjdf: that's reading decimal representations though
16:23:38 <roconnor> RayNbow: maybe (++) should be mplus, while (*) should be used for mappend?
16:23:56 <RayNbow> wait... (*) for mappend? :P
16:24:07 <roconnor> RayNbow: just tossing out an idea here.
16:24:23 <pumpkin_> does the Data.Binary maintainer hang out on IRC? can we petition to get IEEE754 added to it? :P
16:24:27 <RayNbow> yeah, but now we have a conflict with Num
16:24:44 <roconnor> RayNbow: I assume we are tossing Num
16:24:51 <roconnor> RayNbow: or at least grossly retooling it
16:25:17 <thoughtpolice> pumpkin_: yell@dons
16:25:28 <pumpkin_> I thought it was someone else who did D.B
16:25:36 * pumpkin_ yells at dons anyway
16:25:40 <scodil> which hackage package contains the "cabal" command line tool? As opposed to "cabal-install" and "cabal-upload"
16:26:02 <dancor> Maintainer: Lennart Kolmodin, Don Stewart <dons@galois.com>
16:26:10 <pumpkin_> aha
16:26:15 <roconnor> in my experience cabal-install gave me a cabal command line tool.
16:26:20 <roconnor> but I could be mistaken
16:26:27 <kjdf> thoughtpolice: oops, no, it works on textual interpretation and I have data in array of ieee754 floats
16:26:35 <kjdf> scodil is right
16:27:20 <roconnor> RayNbow: are we allowed to use unicode in the other prelude?
16:27:22 <byorgey> scodil: 'cabal-install' is the package that gives you the 'cabal' command-line tool
16:27:27 <RayNbow> roconnor: no idea
16:27:38 <scodil> byorgey, roconnor: thanks
16:27:40 <byorgey> it's a bit unfortunately named
16:27:58 <byorgey> Cabal is the library, cabal-install is the cabal executable
16:28:04 * RayNbow doesn't know which operators are available in unicode
16:28:25 <roconnor> maybe mappend should be (⋅)
16:28:26 <kjdf> a related question - is there something like a generalized bytestring? a lazy list built up from linked arrays generalized for any type
16:28:56 <roconnor> or (∙)
16:28:58 <RayNbow> roconnor: wouldn't that be confusing as it looks a lot like (.)?
16:29:01 <scodil> kjdf: there is StorableVector, but that's not lazy I don't think
16:29:09 <roconnor> or (⋅)
16:29:31 <roconnor> oops
16:29:34 <roconnor> that is the same as the first
16:29:39 <RayNbow> ⊕  <-- what about this, roconnor?
16:29:47 <roconnor> looks too commutative
16:30:05 <pumpkin_> @hoogle Just a -> a
16:30:06 <lambdabot> Did you mean: Maybe a -> a /count=20
16:30:06 <lambdabot> Prelude id :: a -> a
16:30:06 <lambdabot> Data.Function id :: a -> a
16:30:08 <pumpkin_> whoops
16:30:17 <roconnor> maybe unicode operators for common functions is a bad idea.
16:30:19 <pumpkin_> @hoogle Maybe a -> a
16:30:19 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
16:30:19 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
16:30:19 <lambdabot> Data.Monoid First :: Maybe a -> First a
16:31:37 <roconnor> RayNbow: The more I think about the more I dislike + characters for mappend.
16:31:57 <roconnor> I'm not even very fond of ++ for concat / mplus :)
16:32:09 <RayNbow> roconnor: why's that?
16:32:20 <roconnor> + means commutative.
16:32:27 <RayNbow> it does?
16:32:31 <roconnor> yep
16:32:42 * RayNbow is apparently missing some bg info :p
16:32:53 <roconnor> :)
16:33:14 <RayNbow> what's the symbol for associative then?
16:33:14 <dolio> + is what you typically call the operation in abelian groups, for instance.
16:33:28 <scodil> In papers (latex) people will sometime use a symbol like ++ except that the two symbols overlap so that its like a horizontal double cross. Does anyone know how they do that? Is that an ams symbol or is that custom?
16:33:32 <roconnor> RayNbow: (*)
16:33:53 <roconnor> or (⋅)
16:33:54 <pumpkin_> scodil: http://www.ctan.org/tex-archive/info/symbols/comprehensive/symbols-a4.pdf
16:33:58 <lambdabot> Title: The Comprehensive LaTeX Symbol List, http://tinyurl.com/5583t
16:33:59 <SamB_XP> scodil: Isn
16:34:05 <SamB_XP> Isn't it just what it looks like ?
16:34:26 <scodil> pumpkin_: I'm pretty sure its not in there. I looked. Could have missed it, though
16:34:35 <RayNbow> dolio: I have no idea what groups are ;)
16:34:40 <SamB_XP> ... two plus signs with negative space between ?
16:34:41 <mux> ʡ
16:34:42 <pumpkin_> hmm, I could've sworn I'd seen it in there scodil
16:34:58 <dolio> Whoa.
16:34:58 <pumpkin_> let me look
16:35:11 <SamB_XP> ever seen the >>= ?
16:35:12 <dolio> Someone should write Learn You an Algebra.
16:35:16 <scodil> SamB_XP: yeah I figured that could be it, but I don't know the (la)tex command for negative space
16:35:17 <pumpkin_> lol
16:35:28 <RayNbow> dolio: I would gladly upvote that if it were posted to reddit :p
16:35:32 <dolio> :)
16:35:36 <mux> or ⧺
16:35:39 <scodil> SamB_XP: yeah, I guess that'd be the same, just those three characters, >>=, but squished so that they touch
16:35:39 <RayNbow> lol, http://en.wikipedia.org/wiki/Group_(mathematics) <-- is in my browser history :p
16:35:39 <kjdf> ok, is writing Binary instance for CFloat a good idea?
16:35:40 <SamB_XP> isn't there a lhs package that does that ?
16:35:55 <chrisdone> preflex: be poppavic
16:35:56 <preflex>  ahh, so - you just toss out yer turds and based on input and get feedback, then play "confused"? Good to know.
16:36:08 <dolio> RayNbow: Groups are one-object categories where every arrow is an isomorphism. :)
16:36:11 <jpcooper> this doesn't work in run-haskell
16:36:22 <jpcooper> preflex: be poppavic
16:36:22 <preflex>  yeah, Ia am always amazed how come I am at blame when I've a dozen other I respect that understand. What YOU want is that I agree. I don't. That's fine - it's all yers - but don't play yer shit and sneak in nazi headspace.
16:36:35 <jpcooper> preflex: be xach
16:36:35 <preflex>  no quotes found for xach
16:37:38 <pumpkin_> RayNbow: a group is a set and an operation that satisfy some basic properties (closure, identity under the operation, inverse)
16:37:57 <roconnor> Oh, maybe (.) shouldn't be for map.
16:38:06 <roconnor> Maybe (.) should be for groupoid.
16:38:15 <dons> kjdf: interesting. not sure.
16:38:17 <roconnor> and Caleskell is wrong.
16:38:40 <Cale> Certainly not groupoid. General categorical composition if anything.
16:38:44 <RayNbow> Category Theory - S. Awodey (Clarendon, 2006) WW.pdf <-- should I print this and read it? :p
16:38:52 <Cale> RayNbow: You should read it.
16:39:02 <scodil> don't print it. Think of the trees!
16:39:04 <pumpkin_> RayNbow: url? I want it too :P
16:39:05 <RayNbow> Cale: that sorta implies that I have to print or buy it :p
16:39:10 <roconnor> Cale: right
16:39:21 <pumpkin_> oh it's a pirated book :o
16:39:24 <dolio> roconnor: I'm sure Cale will gladly cede you (.) if he can have (∘).
16:39:26 <Cale> RayNbow: I read it on screen :)
16:39:36 <scodil> pumpkin_: from Somalia?
16:39:47 <RayNbow> Cale: I hate reading from screen :p
16:39:49 <pumpkin_> yarr
16:40:47 <dolio> RayNbow: Do you have some kind of high-end printer available to print out all 266 pages?
16:40:49 <Cale> RayNbow: I have frightening news for you. You're doing it RIGHT NOW!!!111one
16:41:04 <pumpkin_> RayNbow: is there a public url for that book?
16:41:10 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
16:41:15 <lambdabot> Title: cache:http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon, ..., http://tinyurl.com/4jav6v
16:41:18 <pumpkin_> aha :)
16:41:20 <RayNbow> pumpkin: I got it from Cale some time ago :p
16:41:29 <pumpkin_> looks like fun
16:41:39 <RayNbow> my URL is file:///d:/Category%20Theory%20-%20S.%20Awodey%20%28Clarendon,%202006%29%20WW.pdf , but it isn't very useful :p
16:41:44 <pumpkin_> lol
16:41:49 <pumpkin_> eww windows :P
16:42:13 <pumpkin_> they really need to get rid of that letter-drive-name thing in an upcoming version
16:42:36 <RayNbow> dolio: don't know... I can print for free on some Nashua color laser printer
16:42:45 <pumpkin_> save the rainforests!
16:42:47 <dolio> Sounds pretty nice.
16:43:08 <pumpkin_> anyone here have that letter-sized reader from irex? I'm tempted to get one, but it's pretty expensive
16:43:14 <pumpkin_> would be awesome for reading papers and stuff on, though
16:43:33 <RayNbow> pumpkin_: no, cut down all the rainforests! :p
16:43:44 <RayNbow> maybe they will speed up the ereader tech then ;)
16:44:11 <scodil> you (we) spend enough time in front of a screen. If its not comfortable or strains your eyes, you should probably just remedy that instead of avoiding the screen
16:44:21 <te> pumpkin_: the iliad?
16:44:37 <pumpkin_> the new "business" one they came out with
16:44:39 <pumpkin_> http://www.irextechnologies.com/irexdr1000
16:44:41 <lambdabot> Title: iRex Technologies
16:44:53 <RayNbow> scodil: I don't have problems with reading IRC chats, short news articles or reading code...
16:44:54 <te> ooooo!
16:44:57 <te> i want one!
16:45:08 <pumpkin_> te: me too! but it's expensive :(
16:45:14 <RayNbow> I just dislike reading books and papers from the screen :p
16:45:15 <pumpkin_> especially if you want the stylus-equipped one
16:45:19 <te> 1,100? pumpkin_ ?
16:45:29 <pumpkin_> RayNbow: you're not alone, but e-ink is nice
16:45:58 <luite_> pumpkin_: I just received that unit earlier this week
16:46:08 <pumpkin_> luite_: how is it? worth the money?
16:46:11 <te> e-ink is very very nice
16:46:14 <dons> code.haskell.org down?
16:46:17 <dons> ah no.
16:46:19 <te> i have a sonry PRS-505
16:46:21 <te> sony*
16:46:26 <RayNbow> pumpkin_: are there any ereader units out there that can display two pages?
16:46:37 <RayNbow> because I oftend find myself flipping pages
16:46:42 <pumpkin_> RayNbow: not that I know of, the one I just linked to is the only "full page" one I know of
16:46:49 <pumpkin_> most of them are paperback book-sized
16:47:16 <te> pumpkin_: the iliad book edition might be a good buy
16:47:23 <te> its probabl cheaper than the stylus version
16:47:30 <te> which i think is a bit much for me
16:47:37 <luite_> pumpkin_: hm, not sure. I think it doesn't look and feel as expensive as it actually is... it's rather slow, the firmware is a bit incomplete. the e-ink display is nice, but it's still a lot less white than real paper
16:47:59 <luite_> pumpkin_: but it still is much much better than reading from screen
16:48:04 <pumpkin_> te: the book edition one is smaller though, and given the difficulty of reflowing PDFs and the fact that most of what I'll be reading is on PDF, that's a big con :/
16:48:09 <te> pumpkin_: these prices arent bad compared to last year's models
16:48:20 <pumpkin_> luite_: :/ that's sad
16:48:25 <te> pumpkin_: yes i didnt look at the size, i assumed it was the same as the iliad
16:48:33 <luite_> pumpkin_: I bought it to be able to read full page books and papers, and it will do the job
16:48:44 <te> if they could build one to display pdfs nicely for like 500$ with vizplex
16:48:47 <te> id sign on the dotted line
16:49:01 <thoughtpolice> yay!
16:49:14 <te> i spent about a month last xmas doing research on the ereader options and came up with nothing
16:49:18 <te> i decided to wait a year
16:49:18 <thoughtpolice> @tell Lemmih Ross has removed lhc-20081121 from hackage, so we should be OK in the future w.r.t versioning
16:49:19 <lambdabot> Consider it noted.
16:49:23 <te> little has developed
16:49:35 <dons> thoughtpolice: woot
16:49:41 <scodil> does gtk2hs work with 6.10?
16:49:52 <dons> so cabal install lhc should work now
16:49:58 * dons tries
16:50:04 * thoughtpolice crosses fingers
16:50:17 <luite_> te: I haven't had any problems displaying pdf with the dr1000, but it does take a while to open the document, and somes a few seconds to flip a page
16:50:27 <dons> what does lhc use fgl for?
16:50:28 <luite_> sometimes
16:50:28 <pumpkin_> is there some binary format for serializing lists of (lists of) doubles that haskell particularly likes, and that's easy to read in and write out?
16:50:31 <dons> graphviz?
16:50:37 <dons> pumpkin_: Data.Binary.binary
16:50:49 <RayNbow> ah dolio, http://www.vipofficesystems.nl/album/mpc2500-3.jpg <-- I think this is the printer I have access to :)
16:50:52 <dons> pumpkin_: which you can then use encode/ decode to read in and out.
16:50:58 <pumpkin_> dons: sweet, thanks
16:51:02 <te> pumpkin: youshouldnt have any problems with free flow PDFs on the iliad book edition
16:51:10 <te> its the same size as the iliad
16:51:25 <pumpkin_> te: I hear it doesn't do a good job reflowing two-column papers, which are pretty common
16:51:27 <thoughtpolice> dons: seems like it, yeah
16:51:39 <thoughtpolice> (after a quick 'find . | xargs grep ...' of the source)
16:51:40 <te> pumpkin_: it does a way better job than any other reader on the market
16:51:45 <te> AFAIK
16:54:20 <pumpkin_> hmm
16:59:10 <pumpkin_> Cale: is this book magically free? it seems quite clear so far
16:59:50 <luite_> wow my own lambdabot, it works \o/ (on another network)
17:00:04 <pumpkin_> I couldn't get lambdabot to compile
17:00:08 <pumpkin_> I wanted to use its magic @src locally
17:00:30 <luite_> pumpkin_: I had to install about 2000 packages manually and patch some cabal files etc ;)
17:00:55 <thoughtpolice> pumpkin_: what book?
17:00:58 <pumpkin_> is it just unmaintained, or is compiling lambdabot some rite of passage all serious haskellers have to go through, and it's made difficult on purpose?
17:01:02 <thoughtpolice> luite_: really? it's that bad these days?
17:01:06 <pumpkin_> thoughtpolice: the category theory book
17:01:21 <thoughtpolice> pumpkin_: no it's actively maintained by Cale and gwern for the most part I think
17:01:28 <thoughtpolice> pumpkin_: but it can be difficult to compile, yes
17:01:36 <thoughtpolice> and currently it's not possible to compile with ghc 6.10.1 AFAIK
17:01:44 <pumpkin_> ah
17:01:45 <luite_> thoughtpolice: the lambdabot package itself doesn't compile with ghc 6.10 because some packages have moved. and mueval has some problems building with 6.10, so I  used 6.8.2 for that
17:01:58 <thoughtpolice> luite_: yes
17:02:00 <luite_> I patched the lambdabot files to work with 6.10
17:02:07 <thoughtpolice> it's because lambdabot depends on mueval
17:02:09 <thoughtpolice> which depends on hint
17:02:13 <thoughtpolice> hint is a GHC API wrapper
17:02:15 <luite_> but for mueval I went for 6.8.2 instead
17:02:19 <thoughtpolice> so when ghc 6.10.1 came along
17:02:22 <thoughtpolice> it broke pretty badly
17:02:26 <thoughtpolice> and the author hasn't fixed it
17:02:27 <luite_> because that looked too hard to patch for 6.10 :(
17:02:59 <thoughtpolice> the reason lambdabot is typically difficult to get working right is because it's for the most part pretty tied-into GHC in certain ways
17:03:25 <thoughtpolice> i would know, I've gone through the same pain. :)
17:03:51 <thoughtpolice> but I feel it's certainly better now that mueval is out there and parts of lambdabot have been factored into libraries
17:04:19 <pumpkin_> whoa, I can get funky behavior by decoding encoded data to the wrong types
17:04:28 <dons> pumpkin_: sure.
17:04:31 <pumpkin_> whee
17:04:48 <dons> you'd need to encode type information to avoid that (there's a package for that)
17:05:56 <thoughtpolice> pumpkin_: data.binary I assume?
17:06:02 <pumpkin_> yeah :)
17:06:10 <thoughtpolice> yeah that can happen
17:07:31 <pumpkin_>     Couldn't match expected type `B.ByteString'
17:07:31 <pumpkin_>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
17:07:31 <pumpkin_>  :(
17:10:28 <dons> different types
17:12:19 <pumpkin_> how does one convert between them?
17:12:30 <dons> i have no patience for non-hackage projects now. cabalise or perish.
17:12:42 <dons> pumpkin_: well, fromChunks / toChunks
17:12:44 <pumpkin_> ah
17:12:50 <SamB> dons: what about tools ?
17:13:08 <dons> gwern: john's complaining about your drift packaging.
17:13:12 <dons> want to take another look at it?
17:13:13 <SamB> cabal doesn't really help all that much with tools
17:13:18 <dons> or work with him to have it done properly?
17:18:30 <thoughtpolice> i'm beginning to think dons has a mental connection with haskell-related mailing lists - or he just has a mail client in his brain
17:19:19 <dons> i have an efficient window manager
17:19:28 <gwern> dons: he is, huh. which thread?
17:19:32 <gwern> there seems to be 2 or 3
17:19:46 <olsner> efficient window manager == xmonad?
17:19:51 <Elly> dons: ion3! :)
17:19:53 <dons> bah
17:20:05 <dons> now i get trolled in #haskell too! ;)
17:20:16 <pumpkin_> !
17:20:18 <gwern> your own fault for encouraging people to come here!
17:20:25 <dons> :P
17:20:26 <olsner> ... or maybe he's a secret Win32 junkie :)
17:20:32 <dons> sssh
17:20:34 <SamB> olsner: hah!
17:20:47 <pumpkin_> @hoogle fromChunks
17:20:47 <Elly> olsner: that is a vicious slander :P
17:20:48 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
17:20:48 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
17:20:58 <olsner> I mean, the window manager is in the OS there, it must be *super* efficient
17:21:14 <SamB> olsner: actually isn't it a DLL that runs in each app's process ?
17:21:32 <Elly> the WM for windows?
17:21:40 <Elly> I think explorer is its own process and stuff...
17:21:54 * sjanssen thinks these unofficial cabalizations are sketchy at best
17:22:02 <pumpkin_> ack, these two different ByteStrings are confusing
17:22:05 <cknapp> Yeah, last I knew, explorer was it's own process... I ahd a friend with BlackBox on windows for a while.
17:22:06 <SamB> explorer doesn't create the decorations on the windows ...
17:22:09 <pumpkin_> fromChunks :: [B.ByteString] -> ByteString
17:23:13 <thoughtpolice> dons: ;)
17:24:02 <dons> sjanssen: yeah, but if the author's not going to do it.
17:24:05 <dons> we kinda have to.
17:24:13 <sjanssen> dons: it should probably go through a name change
17:24:19 <dons> yeah perhaps. like pugs-drift
17:24:28 <dons> is it metadata, or a new fork
17:24:30 <dons> that's the issue
17:24:30 <sjanssen> it should also have a separate source repository so the changes can actually be tracked
17:24:52 <Elly> I should learn to use cabal
17:24:56 <pumpkin_> :t fromChunks
17:24:57 <lambdabot> Not in scope: `fromChunks'
17:25:07 <pumpkin_> :t Data.ByteString.Lazy.fromChunks
17:25:08 <lambdabot> [BSC.ByteString] -> BSLC.ByteString
17:25:10 <sjanssen> but building a broken DrIFT package and putting it on hackage helps no one
17:25:11 <pumpkin_> aha
17:25:15 <dons> Elly: pretty easy. and required if you're going to develop a new project in haskell, imo.
17:25:16 <pumpkin_> so they are different bytestrings
17:25:26 <dons> sjanssen: yes, i assume its not too broken in fact (just no docs?)
17:25:35 <dons> $ DrIFT --help
17:25:35 <dons> unrecognized option `--help
17:25:42 <pumpkin_> :t Data.ByteString.Lazy.toChunks
17:25:43 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
17:25:53 <Elly> dons: is there a decent piece of literature around about it?
17:25:54 <FunctorSalad> roconnar, Cale: shouldn't category be a superclass of groupoid in any case? then there is no conflict as to the meaning of (.)
17:26:07 <gwern> dons: I compiled jhc with my cabalized drift
17:26:14 <gwern> it can't be *completely* broken
17:26:21 <cknapp> If I had a Graph data type, composed of an vertex set [a] and an edge set [(a,a)], how would I do a breadth first search? I'm having trouble not being able to store everything in a queue.
17:26:38 <sjanssen> "cabal install drift" sure spits out a lot of warnings...
17:26:39 <dons> gwern: good
17:26:39 <Elly> cknapp: CPS!
17:26:44 <FunctorSalad> but I'd really like some extension that would make it less painful to have categories that aren't * -> * -> *
17:26:46 <dons> gwern: so just check what john mentioned on the list.
17:26:54 <cknapp> CPS?
17:26:58 <dons> gwern: i agree, if it compiles, its probably not completely broken.
17:27:08 <pumpkin_> :o
17:28:06 <gwern> dons: he is complaining the docs are not included (which they aren't) and that the ghc 'driver script' is not packaged as well
17:28:31 <dons> ah ok. does jhc assume there's a ghc-driver script?
17:28:45 <gwern> I am unsure.
17:29:04 <gwern> I'm looking at the script, and it seems to turn drift into a CLI filter for use in ghc's preprocessor option
17:29:47 <gwern> 'This is a driver script allowing DrIFT to be used seamlessly with ghc.
17:29:47 <gwern> in order to use it, pass '-pgmF drift-ghc -F' to ghc when compiling your
17:29:47 <gwern> programs.
17:29:51 <FunctorSalad> roconnor: sorry for misspelling your name :)
17:29:54 <cknapp> Elly: so I pass the levels that have already been visited as a continuation?
17:29:57 <thoughtpolice> Elly: http://haskell.org/cabal/
17:29:58 <lambdabot> Title: The Haskell Cabal
17:30:46 <thoughtpolice> dons: yes it does - jhc's configure.ac looks for a 'drift-ghc' program
17:30:57 <dons> gwern: ok. so is that a separate binary that should ship with the drift package?
17:30:58 <Cale> FunctorSalad: right
17:31:00 <dons> drift-ghc ?
17:31:17 <sjanssen> thoughtpolice: is it a shell script?  Cabal can't install those very conveniently
17:31:25 <thoughtpolice> i'm not entirely sure
17:31:27 <Cale> FunctorSalad: But, I'm not convinced there are more useful instances of Category than there are useful instances of Functor.
17:31:35 <thoughtpolice> when I installed jhc on my linux box a while back, I used gwern's cabalised version
17:32:03 * thoughtpolice is glad he moved lhc to use data.derive
17:32:05 <gwern> dons: I am not sure. I'm hunting through the jhc repo, but I can't actually find any usage of it
17:32:09 <dons> well, jhc doesn't use cabal for stuff i guess.
17:32:21 <sjanssen> gwern: anything in configure.ac?
17:32:22 <dons> you're supposed to get drift from a .tar.gz and build it that way
17:32:31 <gwern> dons: there's a *check* for drift-ghc, which was covered on the ml, and obviously there's lots of hits in the drift subdirectory / repo
17:32:33 <dons> which means the drift on hackage really should be named something else.
17:32:53 <gwern> sjanssen: don't worry, it's a very simple shell script, easily rewritten in haskell
17:32:59 <sjanssen> gwern: that's good
17:33:00 <thoughtpolice> DrIFTer?
17:33:08 <dons> gwern: right, but now you're forking drift
17:33:12 <sjanssen> or even DrIFT-cabalized
17:33:14 <dons> and with the goal to help jhc
17:33:15 <FunctorSalad> Cale: are you saying that we would need restricted functors too, or that there are no useful categories other than those involved in the current Hask -> Hask functors?
17:33:17 <dons> so that's weird
17:33:24 <gwern> well, except for the CPP substitutions, I'm not sure how I would handle that
17:33:28 <Elly> cknapp: no; when you branch, pass the test of the next branch as a continuation
17:33:29 <dons> i guess as long as the package name is different (but still provides the same binary)
17:33:45 <cknapp> Ok... I'll think about this. Thanks
17:34:18 <gwern> http://hpaste.org/12501 <-- drift-ghc
17:34:24 <Cale> FunctorSalad: Well, the Category class only covers (at least what I think are) categories enriched over Hask, and whose objects consist of Haskell datatypes.
17:35:31 <Cale> FunctorSalad: I believe at least one language of the future will be much more categorical than Haskell, but I'm not sure exactly how to get there from here. :)
17:35:43 <dolio> There aren't a whole lot.
17:35:47 <sjanssen> drift-ghc looks very useful for Windows users...
17:35:55 <maxote> @go Lindenmayer system
17:35:58 <lambdabot> http://en.wikipedia.org/wiki/L-system
17:35:58 <lambdabot> Title: L-system - Wikipedia, the free encyclopedia
17:35:59 <dolio> Kleisli, CoKleisli, (->), lenses...
17:36:08 <FunctorSalad> Cale: sounds correct, but there's the further restriction that the objects must be all haskell data types
17:36:32 <Cale> I think I said that :)
17:36:33 <dolio> Opposite categories...
17:36:34 <FunctorSalad> Cale: @first message
17:37:07 <Cale> Though, that in and of itself is not much of a restriction...
17:37:20 <FunctorSalad> dolio: functor categories...
17:37:22 <dolio> Oh, and applicatives, of course.
17:38:20 <FunctorSalad> subcategories of categories...
17:38:23 <gwern> sjanssen: was that sarcasm, in the general sense Windows users can rarely profitably employ shell scripts?
17:38:25 <Cale> There's something more than just that... the composition has to be natural in a particular way as well.
17:38:28 <mikeblack_> http://deine-nackte-weihnachtsfrau.net/?id=2667561
17:38:30 <lambdabot> Title: Deine Nackte Weihnachtsfrau
17:38:45 <sjanssen> gwern: yes, the comment was extremely sarcastic
17:39:02 <Cale> FunctorSalad: the Category class can't really do subcategories, can it?
17:39:14 <FunctorSalad> Cale: the theorems-for-free thing for parametric poly.?
17:39:18 <sjanssen> gwern: Windows users don't have /bin/sh, they don't have grep, and they don't have cat
17:39:38 <gwern> ah. meachem would of course reply that windows users are supposed to build via make, which presupposes a cygwin install...
17:39:55 <Cale> FunctorSalad: Yeah, the composition has to be a map which is natural in the three type parameters.
17:40:09 * gwern wonders whether anyone would be amused if I wrote an email asking meachem whether he considered Cygwin too big a dep, as obviously cabal is
17:40:13 <FunctorSalad> Cale: (subcategories) maybe with an 'error value', but now that's ugly ;)
17:40:33 <dons> no no. let's calm the situation down.
17:40:35 <sjanssen> gwern: the dependency issue is a red herring -- all GHCs come with Cabal
17:40:49 <Cale> I would really like to see a language with full first-class support for categories.
17:41:10 <FunctorSalad> Cale: yes, that'd be interesting
17:41:29 <byorgey> wasn't there something in that direction a long time ago?  I'm blanking on the name atm...
17:41:43 <FunctorSalad> was it 'charity'?
17:41:46 <dolio> What do you have in mind for functor categories, by the way?
17:41:53 <byorgey> that's it
17:42:01 <byorgey> Cale: what would such a language look like?
17:42:16 <ddarius> byorgey: That is the question.
17:42:23 <Cale> Charity doesn't have support in the sense that I'm thinking.
17:42:37 <ddarius> Cale: What do you think of Hagino's CPL?
17:42:45 <dolio> You can't make 'newtype Nat f g = Nat (forall a. f a -> g a)' an arrow instance, because the kinds on f and g are wrong, no?
17:42:50 <Cale> Well, you should be able to define what the objects and arrows of a new category are explicitly.
17:42:52 <FunctorSalad> dolio: I didn't have anything practical in mind, but they often pop up in maths
17:43:05 <gwern> sjanssen: mm. but we have been pushing cabal-install awfully hard - one could ask 'if you only mean cabal the library, then what advantage does runhaskell Setup configure/build/install have over ./configure && make install? They're equally troublesome to the enduser'
17:43:45 <dolio> Oh, well, I know there are lots of sorts of categories in category theory. :)
17:43:56 <roconnor> gwern: I have no idea how to make a ./configure?
17:43:57 <dolio> The question is how many of them can be stuck in the Category class. :)
17:44:01 <roconnor> gwern: is it easy?
17:44:20 <gwern> roconnor: I always assumed one copied it from another project, much like people do with Setup.hss :)
17:44:21 <dons> you have to write some autoconf and m4
17:44:22 <sjanssen> gwern: for simple Haskell packages, you only have to write a description of your package, you don't have to write any build logic.  With autotools, you always have to write build logic
17:44:25 <dons> its harder than writing a .cabal
17:44:36 <FunctorSalad> dolio: it also depends on how much type safety you want from it ;)
17:44:50 <sjanssen> gwern: and the build logic is often very slightly different between autotools packages, each implementation with its own bugs
17:44:56 <Cale> dolio: not many.
17:45:03 <roconnor> gwern: cabal automatically hides non-listed packages
17:45:09 <dolio> Yeah. I'm about out.
17:45:22 <FunctorSalad> wouldn't many of the constructs need dependent types?
17:45:33 <Cale> dolio: The Category class is so restrictive that I'm a bit hesitant to have it called that.
17:45:34 <dolio> Stream transformers are another, which I don't think are covered by the ones I listed.
17:45:39 <roconnor> once cabal matches up interfaces between packages, it will be unstopable.
17:45:43 <gwern> roconnor: well, people complain about that as well
17:45:48 <Cale> I'll be back later :)
17:45:51 <FunctorSalad> bye
17:45:56 <roconnor> gwern: complain about what?
17:45:59 <gwern> roconnor: I saw a blog post the other day where the author was particularly angered by the default hiding
17:46:27 <dolio> Cale: It's a lot like Functor, really. It's really more of a 'Morphism' class, but even that's giving it a bit more credit than it deserves.
17:46:30 <roconnor> gwern: why would anyone be angered about that?
17:46:32 <gwern> and of course people like roundy or meachem see the default hiding and explicit listing of packages as horribly fragile in many ways
17:46:43 <ddarius> @google Hagino A Categorical Programming Language
17:46:44 <dons> gwern: wasn't it the other way around?
17:46:49 <sjanssen> roconnor: it is not hard at all to modify your makefile to hide packages, so I don't think that is a useful distinction either
17:46:50 <dons> the post 'cabal is a fine system' ?
17:46:59 <lambdabot> Plugin `search' failed with: thread killed
17:47:03 <dons> you simply must hide by default -- there's too much code to go importing willy nilly.
17:47:08 <maxote> @go Categorical Programming Languages
17:47:08 <gwern> dons: that title was sarcasm, you know.
17:47:11 <lambdabot> http://www.lfcs.inf.ed.ac.uk/reports/87/ECS-LFCS-87-38/
17:47:11 <lambdabot> Title: A Categorical Programming Language
17:47:17 <gwern> the entire post was about how much he disliked cabal
17:47:24 <Cale> Oh, not enough space in the car for everyone, perhaps I'll stay :)
17:47:33 <FunctorSalad> omg. the 'charity' discussion page on wp has a long discussion on whether it should be "$LANG programming language" or "$LANG (programming language)"
17:47:37 <dons> gwern: mm... i didn't get that. maybe i need to read closer.
17:47:42 <gwern> -_-
17:47:48 <FunctorSalad> ddarius: was that the one based on adjunctions?
17:47:49 <sjanssen> dons: Roundy at least believes that you should depend on modules, rather than packages.  He also doesn't like version constraints
17:47:51 <roconnor> sjanssen: how do I do that?
17:48:05 <sjanssen> roconnor: however Cabal does it, it's a GHC flag
17:48:08 <gwern> FunctorSalad: we settled that one a long time ago, though, in favor of $LANG (programming language)
17:48:10 <roconnor> sjanssen: Roundy is right about that.
17:48:10 <dons> sjanssen: yeah, but no one's tried to build 1000 packages that way. it doesn't scale without versioning
17:48:13 <sjanssen> (all Cabal does is call ghc --make)
17:48:17 <SamB> sjanssen: well ... what does he suggest instead of version constraints ?
17:48:18 <pumpkin_> maxote: grr, I have to pay to read a paper?? blasphemy!
17:48:19 <gwern> FunctorSalad: the other way is just ridiculous
17:48:25 <Cale> ddarius: That looks interesting, I haven't seen it.
17:48:38 <gwern> SamB: compilation and testing functionality, iirc
17:48:54 <SamB> gwern: what the ???
17:48:58 <dons> oh, he's only mildly whining.
17:49:03 <sjanssen> SamB: feature based testing.  Rather than depending on "base > 10", you attempt to build a small script that uses the feature you need
17:49:10 <SamB> that hardly sounds like a replacement for version constraints
17:49:12 <gwern> SamB: well for example, how darcs did quickcheck.... yeah, what sjanssen said
17:49:18 <sjanssen> SamB: this is the standard autoconf method
17:49:26 <dons> i wouldn't consider that "angered"
17:49:35 <maxote> pumpkin_, huh? what paper?
17:49:39 <SamB> I'd say that was pretty silly for most cases ...
17:49:39 <dons> just whinging a bit (trevion's has to do haskell for his job, afaik)
17:49:54 * gwern is still amused dons apparently didn't get past the title
17:49:58 <pumpkin_> maxote: that phd thesis you found in google I think
17:50:14 <maxote> is your?
17:50:18 <maxote> lol
17:50:25 <Cale> Hmm... I wonder how reasonable it would be to have categories whose objects were defined by a syntax, and then have axiomatic arrows added to that, optionally with a definite semantics, though I'm not quite certain how that would work out.
17:50:27 <gwern> FunctorSalad: wait, actually, could you link to that WP page? if we're seriously considering undoing the changes I need to stand athwart it shouting stop!
17:50:32 <sjanssen> SamB: there is a certain amount of wisdom in the approach.  With version checks, you might have to do a bit of archaeology to figure out when a feature was added
17:50:53 <dons> gwern: well, i didn't read it as /anger/
17:50:57 <Cale> So it would be a language where you can at any point just start a "new" type system, with arbitrary primitive functions.
17:51:01 <SamB> well, there's got to be a better way than "script which should fail if the feature is absent"
17:51:06 <Cale> and then talk about functors between those.
17:51:07 <dons> gwern: so your characterisation as such surprised me.
17:51:12 <dolio> pumpkin_: If you do a google search, link #2 is the thesis for free.
17:51:19 <pumpkin_> yay
17:51:25 <dolio> Lambdabot doesn't search for the cheapest link. :)
17:51:25 <roconnor> SamB: Types!
17:51:26 <roconnor> :P
17:51:26 <FunctorSalad> gwern: nah, it's from 2006 http://en.wikipedia.org/wiki/Talk:Charity_(programming_language)
17:51:39 <gwern> FunctorSalad: phew. you scared me a little there
17:51:42 <sjanssen> eg. in 3 years are you going to remember which version of Data.Map had lookup generalized to any Monad, and which version was explicitly typed to Maybe?
17:51:44 <dons> and i still don't think he is angry, just whining about default hiding versus default exposing.
17:51:48 <SamB> roconnor: well, yes, I was thinking that types should be involved ;-)
17:51:48 <dons> but he'll just have to deal with that.
17:51:49 <Cale> Perhaps the semantics for all the other categories would generally be given as a functor from that category down to the main one.
17:51:50 <sjanssen> how many people now that answer right now?
17:51:58 <sjanssen> s/now/know/
17:52:18 <SamB> sjanssen: they specialized it ?
17:52:20 <gwern> dons: some of his objections are superficial or being addressed, but some are fundamental. default hide informs a lot of the other choices, so if he doesn't like *that*...
17:52:34 * roconnor thinks Cabal should reject any files with module imports that don't explicitly list functions
17:52:38 <dons> no, he's just learning to move away from the simple --make view of the world.
17:52:44 <sjanssen> SamB: yep, with whichever version that was released with GHC 6.10
17:52:45 <dons> it doesn't scale, so too bad.
17:52:55 <dons> sounds like he's cabalising one of his work projects
17:52:56 <gwern> roconnor: I'm not sure that's always possible.
17:53:01 <dons> (i think, iirc, he works at Aetion)
17:53:04 <SamB> :-(
17:53:07 <cknapp> Elly: Sorry to keep bugging you... Haskell is still twisting my mind into knots-- I don't understand CPS. When I visit a vertex v, and need to keep searching, what is being passed? I'm assuming it's another call to the bfs, but that's as far as I'm getting.
17:53:11 <roconnor> gwern: why not?
17:53:18 <sjanssen> dons: package names have some scaling issues too.  Have you noticed that Cabal files are O(n) wrt. the number of GHC versions they support?
17:53:44 <pumpkin_> roconnor: you mean not just import everything from a given module? I thought I read somewhere that that's a bad thing
17:53:54 <pumpkin_> (to list each function you need individually)
17:54:03 <gwern> roconnor: well, I've tried it in the past and I couldn't always do it. what if you need not just functions, but types? what if the types are originating from a hidden module?
17:54:09 <pumpkin_> oh it was the GHC conventions I think
17:54:21 <roconnor> gwern: import Foo (Type)
17:54:31 <roconnor> oh
17:54:33 <roconnor> hmm
17:54:34 <gwern> at least, I think that was the problem. you could get dependencies on modules you couldn't directly import
17:54:46 <Cale> cknapp: Here's what I recommend as an approach until you get comfortable: any function which you would write in your imperative language that would need to mutate something instead takes that something as a parameter, and possibly returns (a modified version of it) as part of its result.
17:55:04 <gwern> it was a long time ago that I accepted that I couldn't explicitly import everything I need, so I'm a little fuzzy on the reason why not
17:55:23 <roconnor> gwern: shouldn't it be illegal to export functions without exporting everything in their type?
17:55:36 <dons> possibly.
17:55:37 <cknapp> Cale: and then I can just curry those extra parameters away?
17:55:48 <Cale> cknapp: So, for instance, if you're traversing a graph and need to keep track of visited vertices, you take the set of visited vertices as a parameter (initially empty, or a singleton), and either pass along a modified version of that set in the recursive call, or return it as part of the result.
17:55:48 <gwern> maybe, but that'd be a major change. request it for haskell'? :)
17:55:51 <sjanssen> roconnor: that is rather extreme (and also rather annoying)
17:55:53 <dons> you might consider it should be illegal to expoert something for which the type signature can't be written
17:56:04 <dons> there has been one package with that property
17:56:05 <Cale> cknapp: Then you write a simple 'initialising' wrapper.
17:56:17 <cknapp> Ok. Thanks, Cale
17:56:33 <Cale> cknapp: Does that generally make sense? I can give a simplified example of what I mean...
17:56:37 <pumpkin_> @hoogle String -> ByteString
17:56:37 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
17:56:37 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
17:56:37 <lambdabot> Prelude read :: Read a => String -> a
17:56:42 <gwern> dons: which was?
17:56:49 <roconnor> sjanssen: well, whatever we have now sounds broken
17:57:00 <dons> well, its fixed now, so doesn't matter
17:57:10 <dons> but it was interesting at the time.
17:57:50 <sjanssen> there might be some interesting uses for functions who's types can't be written
17:57:56 <pumpkin_> how does Haskell deal with the NaN float value?
17:58:10 <dolio> Just fine.
17:58:19 <pumpkin_> I mean, how can I refer to it?
17:58:20 <ddarius> pumpkin: The way IEEE754 says to
17:58:24 <cknapp> Cale: yes, that makes sense. It's one of those things I've thought, but I've never brought to the surface and worked with.
17:58:29 <dolio> 0/0 among others.
17:58:40 <sjanssen> pumpkin_: you can't construct it directly, you have to write an expression that evaluates to NaN
17:59:10 <sjanssen> > read "NaN" :: Double -- also works
17:59:11 <pumpkin_> hmm, I ask because my CSV has a few NaNs in it
17:59:11 <FunctorSalad> gwern: dons: I think curl-download has openURIWithOpts but doesn't export CurlOption. If I understood your discussion correctly
17:59:11 <lambdabot>   NaN
17:59:32 <pumpkin_> but the Data.ByteString.Lex.Double parser doesn't seem to pick up NaNs
17:59:39 <dons> oh, maybe not
17:59:49 <pumpkin_> it gives me Nothing instead
17:59:49 <dons> FunctorSalad: ah. so that's via the curl library
17:59:56 <pumpkin_> which is fine, it's just not what I expected
18:00:09 <FunctorSalad> dons: yeah, you can import Network.Curl.Opts or so
18:00:42 <FunctorSalad> (it's only impossible to write if you just have Network.Curl.Download imported)
18:01:00 <roconnor> gwern: thanks for the info.  I've never tried only importing stuff before.
18:01:20 <roconnor> I'm surprised that it doesn't work
18:01:43 <gwern> yep. doign -Wall patrol turns up such tidbits, although I'm surprised it's not general knowledge
18:02:09 * roconnor thinks Cabal should reject any files with unqualified module imports that don't explicitly list functions
18:02:16 <scodil> anyone using gtk2hs and ghc 6.10?
18:02:46 <gwern> scodil: if you succcessfully compile, I'd like to know. I've never managed to compile gtk2hs
18:02:57 <scodil> ever?
18:03:21 <gwern> ever. I'm cursed w/r/t gtk2hs
18:03:39 <gwern> no matter the system, no matter the ghc, I just can't compile gtk2hs myself
18:04:01 <roconnor> gwern: try wxHaskell :P
18:04:08 <erikc> sounds like me and yi
18:04:13 <roconnor> who knows, maybe it'll be easier for you
18:04:15 <cknapp> Cale: I guess what's confusing me here is that it's easiest to just cons the most recently visited vertices to the front of the "searched" list... But then I don't know how to decide where to search next. If I store a "fringe", I don't know the best way to access the front of it. Taking 'last fringe' seems like it should have bad time complexity.
18:04:20 <dons> scodil: i think you need the darcs version
18:04:20 <gwern> roconnor: but wxhaskell doesn't work with yi
18:04:33 <Saizan> scodil: there's also a thread on gtk2hs' mailing list, iirc
18:04:33 <Cale> cknapp: Use the Data.Set datatype.
18:04:48 <scodil> dons: Failed to load interface for "System.GIO.Base"    <- ??
18:05:07 <dons> some package i don't know what it is.
18:05:25 <gwern> lucky. I fail at System.GLib.UTF8String
18:05:36 <Cale> cknapp: Using lists for datatypes which are not conceptually lists is the cause of a lot of the slowness in beginner Haskell programs.
18:05:42 <cknapp> Ah.
18:05:51 <scodil> Saizan: gtk2hs-user or gtk2hs-devel?
18:06:42 <gwern> -devel probably
18:06:46 <Saizan> -devel
18:06:55 <pumpkin_> how can I force haskell to evaluate a lazy list completely, without using some unrelated function to traverse the whole list?
18:07:14 <dons> pumpkin_: rnf
18:07:27 <dons> but probably it would be better to use a strict list type?
18:07:37 <Cale> cknapp: Though it's obvious, it's also worth noting that lists are also not arrays. Unless you're going through the elements sequentially, a list is the wrong idea (but linearly scanning through a bunch of things is so common that lists are useful very often -- they take the place of loops in imperative languages)
18:08:09 <pumpkin_> dons: I tried putting a bang in front of my type, but it complained about it
18:08:38 <Cale> pumpkin_: Putting a bang before types is only allowed in data declarations.
18:08:48 <cknapp> Actually, my problem is that I've played around with scheme just long enough to think "functional programming = lists!" but not quite long enough to actually think functionally.
18:08:57 <dons> pumpkin_: to evaluate to normal form, you can use the rnf combinators from Control.Parallel.Strategies
18:09:28 <Cale> pumpkin_: It just means that the value will be evaluated to weak head normal form (that is, up to determining what the top-level constructor is), before the value gets constructed.
18:09:37 <dons> Prelude Control.Parallel.Strategies> let ls = [1..10] ++ [undefined]
18:09:37 <dons> Prelude Control.Parallel.Strategies> head ls
18:09:37 <dons> 1
18:09:37 <dons> Prelude Control.Parallel.Strategies> rnf ls
18:09:41 <dons> *** Exception: Prelude.undefined
18:09:43 <cknapp> So I'm presented with a language with the amount of freedom in haskell, and I'm trying not to drown. :)
18:09:46 <Cale> er, before the value of the datatype you're defining gets constructed.
18:09:51 <dons> cknapp: hehe
18:09:55 <Cale> cknapp: :)
18:10:41 <wolverian> so, trying to find an analogy for monads involving elephants, peanuts and monkeys. any ideas?
18:10:47 <pumpkin_> lol
18:10:54 <dons> hmm. they all belong in the zoo
18:11:19 <scodil> my local zoo is lacking a peanut exhibit :(
18:11:34 <pumpkin_> @src rnf
18:11:34 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:11:35 <Cale> hmmm... a monad is like a monkey riding an elephant and feeding it peanuts...
18:11:44 <pumpkin_> @src Control.Parallel.Strategies.rnf
18:11:45 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:11:55 <gwern> wolverian: well, a monad is like the cage; if it's an IO monkey, any peanuts you toss in, you can't get back
18:12:06 <wolverian> that almost works :) thanks.
18:12:09 <dons> gwern: nice.
18:12:11 <wolverian> I'm going to TA an introductory haskell course in spring, and I was wondering what the worst possible analogy would be.
18:12:23 <gwern> but an elephant monad like List may stick its list-nose out throug the bars of the cage and give you a peanut back
18:13:05 <gwern> and of course, if a creature has the 'trunk' function defined, it can pass a peanut into the next cage
18:13:06 <FunctorSalad> MonadTrans ElephantT?
18:13:08 <scodil> and sometimes monkeys fling their feces at you (seg faults)
18:13:12 <wolverian> I suspect one can always come up with an even worse one just by adding more animals.
18:13:14 <FunctorSalad> (it eats the smaller animals)
18:13:22 <Trafalgard> What if you raise your cage up off the ground and it obviously doesn't have a solid floor
18:13:23 <FunctorSalad> (yes, I know that biologically inaccurate)
18:13:34 <gwern> we can chain cages together, and turn a lot of peanuts into Nothing
18:14:01 <Trafalgard> You'll keep all your peanuts, but nobody would eat them because they'll fall on the floor
18:14:16 <dons> ?users
18:14:16 <lambdabot> Maximum users seen in #haskell: 552, currently: 509 (92.2%), active: 18 (3.5%)
18:14:31 <cknapp> Anyway, I was earlier told to use Data.Sequence for a queue (to get the order of the vertices to search), but it confused me... However, it may have been in part because I was trying to write in an imperative style... So, I make a recursive call which appends a collection of element to the end of the queue, and takes the first element off. Is that right?
18:14:39 <gwern> if a cage turns peanuts into turds, then we call such a cage 'partial', because the inhabitants may fling some (a 'part') out at you
18:14:42 <erikc`> hrm...anyone know if theres something equivalent to "doUntil :: Monad m => [m a] -> (a -> Bool) -> m a" which would perform actions until the condition is satisfied and return that value?
18:14:48 <gwern> while?
18:15:20 <Trafalgard> You had better put your peanuts in a feed dish and have some way to clean that cage if they're making turds! :P
18:15:35 <Trafalgard> Don't forget the water for the monkeys!
18:15:45 <gwern> Trafalgard: we call this 'garbage collection'; fortuntately, it's  the janitompiler's job to see that
18:15:45 <scodil> And a vet!
18:15:45 <byorgey> cknapp: that sounds fine.  What are you confused about?
18:15:52 <Trafalgard> Wouldn't want your monads to die of dehydration...
18:16:10 <cknapp> Nothing now...
18:16:15 <cknapp> I *was* confused :D
18:16:17 <gwern> now, it's possible to connect the wrong kinds of cages; we wouldn
18:16:26 <gwern> t want to put the tigers next to the chickens
18:16:32 <gwern> this we term a 'type error'
18:16:37 <Trafalgard> or the goblins next to the dwarves
18:16:47 <gwern> since tigers are the type which will climb out and eat the chickens
18:16:57 <Trafalgard> unless they're berserk dwarves who failed their fey moods, and you want a spectacle
18:16:59 <gwern> (they're just like that)
18:17:16 <byorgey> cknapp: ok =)
18:17:26 <gwern> wolverian: and that concludes my minitutorial on how haskell is a zoo
18:17:53 <Trafalgard> the chickens will spill half the feed out of the cage, too
18:18:35 <Trafalgard> got anything in haskell that that's similar to? :P
18:19:03 <dons> what's a good interface to a progress meter for haskell?
18:19:05 <gwern> Trafalgard: certainly, Conal's nondterministic choice operator! it selects one alternative about half the time
18:19:05 <Trafalgard> (and that's with a solid bottom on the cage)
18:19:38 <wolverian> gwern, thanks, I'm sure I can confuse someone with that.
18:19:44 <Trafalgard> heh heh
18:19:44 <scodil> dons: for pure code?
18:19:55 <EvilTerran> Trafalgard, unfortunately, all of haskell's bottoms are partial; that could be a problem
18:19:56 <gwern> hm. I should  amend my IO analogy - you can get a peanut back out, but as the monkeys eat it, it'll be surrounded by a Monkey; so 'Monkey (Peanut)'
18:20:13 <Trafalgard> no worries, they spill it out the open sides
18:20:28 <dons> scodil: well, yes, a high level one
18:20:28 <wolverian> unsafePerformPeanutExtraction
18:20:35 <dons> i guess stream it a list of integer values
18:20:38 * gwern wields a knife and grins
18:20:39 <dons> and have it update lazily
18:20:48 <Trafalgard> not that you would normally be feeding chickens peanuts
18:21:03 <wolverian> now, extend the analogy to arrows
18:21:11 <scodil> dons: but the GUI library won't get a chance to update the progress bar until the computation is finished
18:21:35 <scodil> or is this in another thread?
18:21:37 <gwern> er. arrows are like the zoo *visitors*; they can go look at the tigers and the bears at the same time,
18:21:41 <pumpkin_> is there some way of currying the case statement? I have (\x -> case readDouble x of ...) and it looks ugly :P
18:21:50 * gwern 's got nothing. I don't really understand arrows at all
18:22:43 <dons> scodil: well, another thread would certainly help
18:22:59 <scodil> dons: but then how do you communicate without IO?
18:23:48 <dons> a lazy list.
18:24:04 <dons> but i'm asking what's a good interface
18:24:10 <dons> not having you ask me to tell you!
18:24:28 <scodil> I'm not being rhetorical. I'm asking you to find out!
18:24:29 <dons> there's a paper on haskell progress meters though
18:24:44 <Trafalgard> About the progress bar not updating, in an imperative language in windows I would say that you can make the GUI update the progress bar while computation is ongoing by periodically calling the windows API function that processes events, (in C#, for example, Application.DoEvents())
18:24:56 <EvilTerran> pumpkin_, the best alternative i can think of is (let f ... = ...; f ... = ... in f $ readDouble x)
18:25:02 <Trafalgard> I don't know anything much about haskell so I can't say if there's a way to do that in it
18:25:11 <dons> Trafalgard: but who would drive the gui update calls?
18:25:12 <Trafalgard> (planning to learn it soon, which is why I'm here)
18:25:19 <dons> does the user have to program in a delay?
18:25:34 <EvilTerran> pumpkin_, there's a proposal for a language extension to make "case of { ... }" equivalent to "\x -> case x of { ... }", but i don't think it's implemented by anything yet
18:26:00 <Trafalgard> in C#, that calls all the things which show the GUI and allow the dialogs to be dragged around
18:26:03 <scodil> dons: if you're feeding the GUI a lazy list of progress updates, how to you let it know that more progress has occurred? i.e., how do you wake the gui thread up so it can update the bar?
18:26:19 <dons> the gui waits on new values to be computed
18:26:23 <dons> much as we do with Chans
18:26:36 <Trafalgard> this is with just one thread, mind you
18:26:37 <dons> the thread is waiting on us.
18:26:44 <Trafalgard> windows might have its own, or not
18:26:49 <EvilTerran> sounds suspiciously like it'd be updating the gui via unsafePerformIO
18:26:50 <scodil> but Chan's are in IO
18:26:54 <dons> no no.
18:27:00 <pumpkin_> EvilTerran: thanks :)
18:27:01 <dons> let me show you
18:27:05 <scodil> please
18:27:25 <scodil> I've been wondering how to do pure multithreading, beyond just par
18:27:37 <EvilTerran> pumpkin_, it may well be neater to move the definition of "f" down to a where clause, mind
18:27:45 <pumpkin_> yeah, will do
18:27:50 <EvilTerran> (and maybe give it a better name :P)
18:27:58 <Trafalgard> I'd have even less of an idea what you'd need to do on linux
18:28:54 <Trafalgard> in c++ for windows, with normal windows programs you can do something similar, IIRC. I don't recall if you call a particular windows API function, or if you send a message.
18:29:11 <scodil> oh wait are you talking about getChanContents?
18:29:25 <dons> yup
18:29:49 <pumpkin_> http://hpaste.org/12502 is this ugly?
18:30:04 <pumpkin_> :P
18:30:17 <scodil> so, how does the pure function put progress updates into the Chan? (those updates being, say, Doubles between 0 and 1)
18:30:40 <EvilTerran> ?type maybe
18:30:42 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:30:42 <cknapp> If I have a variable x, will the code [y|(x,y) <- somelist] use that variable (and only give me pairs with x in the first coordinate) or will it define a new variable (thus giving me any possible y)?
18:30:47 <gwern> (Just (d, _0)) <-- how does that work? what is a '_0'?
18:30:54 <EvilTerran> pumpkin_, f = maybe fst (0/0)
18:30:56 <pumpkin_> that was a typo sorry :P
18:31:07 <dons> hang on. implementing...
18:31:19 <pumpkin_> aha, didn't know about maybe
18:31:32 <EvilTerran> well, if that should be Just (d, _), rather than Just (d, 0) - in the latter case, it'd be a refinement
18:31:53 <pumpkin_> it was supposed to be Just (d, _)
18:31:58 <pumpkin_> :)
18:32:04 <EvilTerran> ?src maybe
18:32:04 <lambdabot> maybe n _ Nothing  = n
18:32:04 <lambdabot> maybe _ f (Just x) = f x
18:32:22 <pumpkin_> tht looks handy
18:33:04 <EvilTerran> ?src either
18:33:05 <lambdabot> either f _ (Left x)     =  f x
18:33:05 <lambdabot> either _ g (Right y)    =  g y
18:33:09 <EvilTerran> ^ also useful
18:33:14 <pumpkin_> cool :)
18:33:19 <pumpkin_> thanks
18:34:16 <EvilTerran> > map (f `either` g) [Left x, Right y, Left z] :: [Expr -- that one looks good infix, imo
18:34:17 <lambdabot>   <no location info>: parse error on input `;'
18:34:22 <EvilTerran> > map (f `either` g) [Left x, Right y, Left z] :: [Expr] -- whups
18:34:24 <lambdabot>   [f x,g y,f z]
18:35:31 <pumpkin_> dons: would you accept a patch to the bytestring-lexing to allow directly for NaN parsing?
18:37:39 <dolio> > map (f +++ g) [Left x, Right y, Left z] :: [Expr]
18:37:40 <lambdabot>   Couldn't match expected type `Expr'
18:37:43 <scodil> pumpkin_: can you assume that, if the first character is not a digit or - then its NaN? Because that would be a pretty simple filter.
18:37:58 <scodil> fast, even
18:38:05 <dolio> > map (f ||| g) [Left x, Right y, Left z] :: [Expr]
18:38:06 <lambdabot>   [f x,g y,f z]
18:38:27 <pumpkin_> :t (|||)
18:38:29 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
18:38:32 <pumpkin_> scodil: seems reasonable
18:38:47 <dolio> > map (f +++ g) [Left x, Right y, Left z] :: [Either Expr Expr]
18:38:48 <lambdabot>   [Left (f x),Right (g y),Left (f z)]
18:39:01 <pumpkin_> scodil: actually, you want to be able to distinguish between an actual "NaN" and Nothing
18:39:15 <AnalogHole> Can anyone recommend a good tutorial on monads? I've gone through the Daume YAHT and I am having trouble with its chapter on monads. I think a fresh approach might help.
18:39:28 <pumpkin_> AnalogHole: mm_freak is working on one
18:39:37 * pumpkin_ pokes mm_freak_
18:40:30 <acidjnk> Does a list in Haskell exactly correspond to a sequence in math?
18:41:00 <gwern> can math sequences be infinite, I wonder? we do have a Data.Sequence
18:41:06 <Twey> Yes, they can
18:41:11 <acidjnk> yes
18:41:14 <Twey> And... more or less, acidjnk
18:41:23 <Twey> But stop trying to think of Haskell in terms of maths
18:41:24 <cknapp> So long as they are countable
18:41:38 <ddarius> cknapp: A sequence is always countable.
18:41:45 <Twey> It's not a maths encoding, it's a programming language.  It may be mathematical in some areas, but its primary function is programming.
18:41:50 <AnalogHole> pumpkin_: is it published yet? Or is it really just not at all usable?
18:41:59 <ddarius> @where wadler
18:41:59 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/
18:42:04 <pumpkin_> AnalogHole: it looked fine to me, but I can't remember the url
18:42:19 <acidjnk> thanks
18:42:24 <AnalogHole> pumpkin_: what's his real name, maybe I can google it
18:42:32 <cknapp> ddarius: I was actually responding to qwern's "Can sequences be infinite"
18:42:32 <pumpkin_> AnalogHole: not a clue :)
18:42:39 <roconnor> math is programming
18:42:42 <AnalogHole> .whois mm_freak_
18:42:48 <ddarius> AnalogHole: http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps read this
18:42:49 <cknapp> roconnor: other way around
18:42:50 <AnalogHole> oops
18:42:50 <cknapp> :)
18:43:27 <roconnor> cknapp: the other way is more traditional, but I stand by my claim
18:43:41 <dejones> I just downloaded gtk2hs with darcs, and it did not come with the configure script, which is needed for the directions from INSTALL file... any suggestions?
18:43:53 <roconnor> :)
18:43:57 <gwern> dejones: autoreconf?
18:44:04 <scodil> dejones: did the error mention GIO?
18:44:07 <pizza__> i have a fairly simple question: http://hpaste.org/12503#a1 i just want to know how to correctly specify a side-effect. help would be appreciated.
18:44:31 <AnalogHole> ddarius: I'll give it a go.
18:44:38 <scodil> dejones: oh sorry. didn't read carefully. you have to do autoreconf
18:44:44 <gwern> pizza__: that's not gonna work
18:44:54 <pizza__> that's why i'm here :)
18:44:56 <dejones> gwern, scodil: autoreconf created the configure script, thanks.
18:45:04 <gwern> you say your argument is a [Int], and you name this [Int] n, and yet you then do 'n == 10'
18:45:05 <mauke> pizza__: [Int] is a list of Ints
18:45:11 <dejones> gwern, scodil: Why do they assume that someone will know to do autoreconf...?
18:45:27 <scodil> dejones: instructions are on the webpage
18:45:28 <pizza__> oh sorry, that's actually wrong; this is a simplifcation of a real function, let me adjust
18:45:29 <gwern> pizza__: you can't compare [1,2,r,x,y,z] with 10
18:45:40 <pizza__> that's not the actual problem
18:45:41 <scodil> under development
18:45:54 <mauke> pizza__: to combine two actions, use >>
18:45:56 <dejones> gwern, scodil: Hmm, they do mention autoreconf but wayy down near the bottom of the INSTALL... argh.
18:45:58 <gwern> dejones: because only devs are supposed to be touching darcs gtk2hs; the tarballs come with autoreconf already run
18:45:59 <dons> scodil: video example, code, http://hpaste.org/12504
18:46:08 <mauke> pizza__: print n >> foo (n + 1)
18:46:21 <dejones> gwern, scodil: Thanks again for the help.  :)
18:46:36 <dons> probably the first time i've made an hpaste with accompanying video..
18:46:58 <pizza__> mauke: that did it, thank you
18:47:11 <roconnor> acidjnk: a mathimatical sequence is a more like Nat -> a; however [a] and Nat -> a are isomorphic, so you can pretend they are the same.  They tend to have different operational behaviour, but you should ignore operational issues as much as possible, especially when starting haskell.
18:47:56 <acidjnk> I'm not a beginner, I just suck at it.
18:48:06 <acidjnk> More than 1 year Haskell, 10 years SML.
18:48:23 <roconnor> how many years math?
18:48:24 <roconnor> :)
18:48:37 <mauke> heh, misread as meth
18:48:43 <scodil> dons: sweet. Installing mplayer...  but, you're feeding the progress bar from monadic code, no?
18:48:47 <acidjnk> :-)
18:48:51 <roconnor> I guess haskell lists don't quite have the same semantics as SML lists.
18:48:55 <ddarius> Nat -> a is not isomorphic to [a]
18:49:09 <roconnor> ddarius: I always ignore bottoms
18:49:10 <acidjnk> I started elementary school ... 1982
18:49:11 <scodil> is writeList2Chan lazy at both ends?
18:49:17 <dons> scodil: well, that's the bit i'd abstract first. just take a computation that returns a list
18:49:19 <roconnor> ddarius: oh you are right
18:49:23 <dons> then mapM_ that chan writing stuff over  the result
18:49:24 <acidjnk> SML 1998
18:49:28 <dons> so there's a library function to write
18:49:46 <roconnor> acidjnk: I was wrong about [a] and Nat -> a being isomorphic.  Please ignore me.
18:49:55 <roconnor> acidjnk: I forgot about the finite lists.
18:49:59 <ddarius> Stream a is isomorphic to Nat -> a
18:50:31 <ddarius> And in practice "sequence" is also used for finite sequences as well so those would be isomorphic to [a]
18:51:24 <pumpkin_> what's an elegant way to transpose a list of lists (viewing it as a matrix)?
18:51:40 <scodil> pumpkin_: there's a library function for that
18:51:48 <dons> :t transpose
18:51:49 <lambdabot> forall a. [[a]] -> [[a]]
18:51:50 <scodil> its definition is pretty elegant
18:51:51 <pumpkin_> @hoogle [[a]] -> [[a]]
18:51:52 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
18:51:52 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
18:51:52 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
18:51:57 <scodil> @src transpose
18:51:57 <lambdabot> transpose []             = []
18:51:58 <lambdabot> transpose ([]   : xss)   = transpose xss
18:51:58 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
18:52:02 <ddarius> @google "Representations of first order function types as terminal coalgebras"
18:52:03 <pumpkin_> wow :) I'll check before I ask in future :P
18:52:07 <lambdabot> http://www.cs.nott.ac.uk/~txa/publ/tlca01a.pdf
18:52:07 <lambdabot> Title: Representations of first order function types as terminal coalgebras
18:53:01 <dons> http://www.youtube.com/watch?v=cTo_qO0gB9w scodil
18:53:01 <lambdabot> Title: YouTube - out.ogv
18:53:14 <scodil> ugh I _just_ finished install mplayer
18:53:34 <scodil> pretty cool
18:54:18 <scodil> so, if I have a function bigSlowPurFunc, and it returns (RealResult,[Percent]), your progress bar will end up forcing [Percent], but maybe not RealResult (?)
18:54:31 <scodil> Depending on how bigSlowPureFunc is written
18:54:59 <dons> yeah, so you'd want to do both. i'm just assuming the result itself is somehow the progress
18:55:03 <dons> but obviously you'd interleave it
18:55:11 <dons> probably just should implement  the paper on progress bars
18:55:12 <scodil> oh ok so like file transfers and stuff
18:55:17 <scodil> do you have a link?
18:55:45 <scodil> (btw what did you use to make that video?)
18:55:54 <dons> i used recordmydesktop
18:55:55 <ddarius> scodil: You can see that in the video.
18:56:16 <scodil> ddarius: see what?
18:56:23 <ddarius> That he used recordmydesktop
18:56:32 <scodil> Not on the youtube
18:56:44 <dons> btw, that's the first demo of the xosd bindings
18:56:46 <dons> which i think are nice.
18:56:59 <ddarius> scodil: On YouTube is how I saw it.
18:57:27 <scodil> you're eyes are better than mine
18:57:30 <scodil> your
18:57:42 <ddarius> Fullscreen it.
18:57:58 <scodil> I'll take your word for it, since dons has since removed the video
18:58:01 * ddarius closes an evince instance, but another one is there waiting to take its place.
18:58:04 <dons> no no.
18:58:05 <dons> hang on...
18:58:10 <scodil> no its ok, really
18:58:12 <dons> the video is there...
18:58:19 <dons> bah.
18:58:30 <dons> http://www.youtube.com/watch?v=1_vqCFbZiyY
18:58:31 <lambdabot> Title: YouTube - haskell-xosd : demo
18:58:44 <dons> can we get youtube / pastebin?
18:58:47 <dons> for code + video?
18:58:52 * dons just invented a new class of webapp
18:59:01 <scodil> yup there it is "recordmydesktop"
18:59:16 <scodil> glad we cleared that up
18:59:29 <dons> imagine if hpaste had embedded video
18:59:35 <ddarius> dons: Write it.  It shouldn't take long.  The only hard part about YouTube is storage and bandwidth.
18:59:40 <dons> yeah
18:59:57 <dons> and maybe a convenient 'screen capture' button
18:59:59 <dons> not sure how to do thtat.
19:02:08 <gwern> doing video Freely is hard
19:02:41 <gwern> (at least, if you want to work on more than bleeding edge firefox/konqueror/safari/opera)
19:03:08 <dons> i'd like  to be able to embed videos in haskell.org's wiki too
19:03:12 <ddarius> Holy fuck.
19:03:19 <gwern> ddarius: manners!
19:03:40 <ddarius> gwern: Where? !
19:03:47 <gwern> ddarius: nowhere near you!
19:04:02 * gwern tosses in a Cuidado llama! for good measure
19:04:03 <dons> ddarius: ?
19:04:39 <gwern> because no IRC chan should go more than an hour without a Monty Python  ref
19:06:31 <ddarius> My troubles with a transient analysis of a simple relaxation oscillator have been due to a capacitor unconnected to anything lying outside the window.
19:07:19 * gwern flicks the 'more magic' switch
19:07:40 <dons> urgh, after updating my arch system, dns has become super slow :/
19:08:04 <ddarius> How would those be connected?
19:08:13 <SamB> gwern: did you figure out why it was on yet ?
19:08:34 <dons> huh, things are actually timing out sometimes
19:08:56 * gwern waves my hand. You receive a satisfying explanation; these are not the answers you are looking for.
19:09:13 <SamB> gwern: I'll take that as a no!
19:09:21 <SamB> but seriously, don't turn those things off
19:09:26 <thoughtpolice> dons: hm, how'd you do the nifty progress bar thing again? (my internet sucks really bad right now)
19:09:36 <SamB> it tends to cause the system to go down
19:10:10 * gwern frowns at SamB and waves my hand again. You *do* receive a satisfying explanation
19:10:25 <Saizan> "his"
19:10:28 <dons> thoughtpolice: how'd i do it?
19:10:33 <duaneb> hey people
19:10:36 <duaneb> two questions
19:10:37 <SamB> I can't recieve unless someone transmits
19:10:49 <shapr> ddarius: How does that work?
19:11:00 * pumpkin_ is once again trying to come up with an effective "sliding window" function, this time with an increment parameter too :P
19:11:10 <cknapp> I'm trying to get the left end of a sequence (Data.Sequence) by doing 'let x <| xs = mySequence'. When I try to use x, it tells me "Not in scope: x". What am I doing wrong?
19:11:18 <shapr> Bah, does anyone have a Haskell parser in Parsec?
19:11:42 <Saizan> cknapp: <| is not a constructor, but an operator
19:11:43 <kpreid> cknapp: <| is a function name, so you're defining a function named <|, not matching anything
19:11:49 <cknapp> Ah
19:11:57 <Saizan> cknapp: see viewl/viewr
19:12:02 <kpreid> cknapp: you can tell it's not a constructor since it doesn't start with :
19:12:12 <thoughtpolice> dons: yeah, the app itself that puts the progress bar up (i'm just curious)
19:12:14 <ddarius> shapr: How does what work?
19:12:15 <cknapp> Ok.
19:12:30 <cknapp> Oh! Cool. Thanks
19:12:34 <shapr> Let me rephrase that, I want to parse something much like Haskell, and I've given up on hacking the GHC's parser in Happy. Are there other options?
19:12:45 <shapr> ddarius: How does a cap outside the window affect anything else?
19:13:21 <dons> thoughtpolice: oh, it's on hpaste
19:13:27 <gwern> shapr: how does haskell-src-exts not work for you?
19:13:32 * shapr looks
19:13:38 <ddarius> shapr: I'm not really sure.
19:13:43 <shapr> ok then
19:13:55 <dons> thoughtpolice: http://hpaste.org/12504
19:14:29 <shapr> Reminds me of the time my laptop started acting weird on a regular basis, and I discovered that putting my mobile phone near the laptop was causing the interference.
19:14:41 <shapr> gwern: Requires ghc 6.10?
19:14:44 <duaneb> sorry
19:14:48 <duaneb> could someone look at this:
19:14:49 <duaneb> http://pasteall.org/3307/haskell
19:14:58 <gwern> shapr: use an older version then?
19:15:06 <duaneb> (btw, readBin :: [Char] -> Int
19:15:07 <duaneb> )
19:15:27 <duaneb> 1) What is wrong with that? :P
19:15:35 <duaneb> 2) How can I write it better?
19:15:39 <Saizan> duaneb: you've to put parens around x:xs
19:15:40 <duaneb> i.e. more haskellish
19:15:43 <duaneb> oh
19:15:46 <shapr> gwern: yeah, good idea
19:15:56 <shapr> When will there be a ghc 6.10 deb?
19:16:06 <Saizan> and i'd use pattern matching rather than (==)
19:16:38 <duaneb> Saizan: ok
19:16:56 <duaneb> and readBin 0:xs = readBin xs?
19:17:00 <Saizan> readBin ('1':xs) = 2^(length xs) + readBin xs; readBin _ = 0
19:17:35 <duaneb> hmm
19:17:39 <duaneb> so here's the current thing:
19:17:40 <duaneb> readBin (x:xs) = if x == '1' then 2 ^ (length xs) + (readBin xs) else 0
19:17:43 <duaneb> why doesn't that work?
19:17:55 <duaneb> oh
19:17:56 <duaneb> never mind
19:18:13 <Saizan> you've to put a [] case there
19:18:36 <dons> ah ha.disabling ipv6
19:19:01 <Saizan> btw, there's a better algorithm for converting a binary string to a number
19:19:02 <Zao> dons: That sounds suboptimal.
19:19:56 <duaneb> Saizan: ok
19:19:57 <duaneb> thanks
19:20:22 <duaneb> (using this: http://pasteall.org/3308/haskell for now, btw)
19:21:49 <pumpkin_> @hoogle [a] -> [(a, Int)]
19:21:49 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
19:21:49 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
19:21:49 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
19:22:26 <thoughtpolice> shapr: from what I've heard about debian package policy, I'd guess 30 years?
19:22:31 <pumpkin_> @src nub
19:22:31 <lambdabot> nub = nubBy (==)
19:22:32 <thoughtpolice> something around there
19:22:36 <pumpkin_> @src nubBy
19:22:36 <lambdabot> nubBy eq []             =  []
19:22:36 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
19:22:44 <duaneb> oooh
19:22:50 <duaneb> how can I abuse this bot? :P
19:23:11 <SamB_XP> we don't know
19:23:14 <SamB_XP> that's your job
19:23:30 <SamB_XP> usually, known ways are plugged ;-)
19:23:30 <duaneb> Saizan: does that paste work?
19:23:32 <dolio> > foldl (\n b -> n `shiftL` 1 + b) 0 [1,0,1,0,0,1]
19:23:33 <lambdabot>   Add a type signature
19:23:38 <dolio> > foldl (\n b -> n `shiftL` 1 + b) 0 [1,0,1,0,0,1] :: Int
19:23:39 <lambdabot>   41
19:23:59 <duaneb> that makes my head hurt :/
19:24:13 <duaneb> I don't know the `` operator(?) yet
19:24:30 <scodil> f x y   =   x `f` y
19:24:40 <Saizan> duaneb: it looks like i should, have you tested it?
19:24:42 <pumpkin_> can anyone think of a function that takes a list of Eq instances and returns a list of pairs of unique elements of the list and how many times they occur in it?
19:24:45 <Saizan> "it"
19:25:21 <pumpkin_> the list
19:25:22 <pumpkin_> :)
19:25:31 <Saizan> ?type (head &&& length) . group . sort
19:25:32 <lambdabot> forall a. (Ord a) => [a] -> ([a], Int)
19:25:52 <pumpkin_> > (head &&& length) . group . sort $ [1,2,3,4,2,3,2,1,5,52]
19:25:53 <lambdabot>   ([1,1],6)
19:26:02 <Saizan> heh
19:26:17 <pumpkin_> hmm
19:26:24 <Saizan> > map (head &&& length) . group . sort $ [1,2,3,4,2,3,2,1,5,52]
19:26:26 <lambdabot>   [(1,2),(2,3),(3,2),(4,1),(5,1),(52,1)]
19:26:40 <pumpkin_> need to ruminate on that for a moment :)
19:26:45 <Elly> :t &&&
19:26:46 <lambdabot> parse error on input `&&&'
19:26:50 <Elly> what on earth is &&&?
19:27:01 <Axman6> :t (&&&)
19:27:03 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:27:10 <pumpkin_> @src &&&
19:27:11 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
19:27:11 <Saizan> f &&& g = \x -> (f x,g x), here
19:27:13 <Elly> doesn't appear to be in my haskell...
19:27:20 <duaneb> > let readBin ('1':xs) = (readBin xs) + 2 ^ (length xs); readBin ('0':xs) = (readBin xs); readBin _ = 0 in readBin "01010"
19:27:21 <lambdabot>   10
19:27:28 <Saizan> import Control.Arrow
19:27:29 <Axman6> @hoogle (&&&)
19:27:29 <roconnor> (+1) &&& (+2) 3
19:27:29 <duaneb> yes
19:27:30 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
19:27:32 <duaneb> it works
19:27:34 <roconnor> > (+1) &&& (+2) 3
19:27:36 <lambdabot>       Overlapping instances for Show (b -> (b, c'))
19:27:36 <lambdabot>        arising from a use...
19:27:43 <dons> urgh
19:27:49 <dons> Show instances. grr
19:27:50 <roconnor> > (+1) &&& (+2) $ 3
19:27:52 <lambdabot>   (4,5)
19:27:59 <dons> we simply shouldn't have overlapping show instances
19:28:09 <dons> or , that error should be rewritten
19:29:13 <dolio> > let swap (a,b) = (b,a) ; f [] = Nothing ; f (x:xs) = Just . first (head &&& length <<< (x:)) $ partition (==x) xs in unfoldr f ([1..4] >>= [1..4])
19:29:14 <lambdabot>   Couldn't match expected type `t -> [a]'
19:29:47 <roconnor> @hoogle swap
19:29:48 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
19:29:48 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
19:30:04 <roconnor> someone add swap plz
19:30:16 <dolio> > let f [] = Nothing ; f (x:xs) = Just . first (head &&& length <<< (x:)) $ partition (==x) xs in unfoldr f ([1..4] >> [1..4])
19:30:17 <lambdabot>   [(1,4),(2,4),(3,4),(4,4)]
19:30:23 <Saizan> @let swap x = (snd x,fst x)
19:30:25 <lambdabot>  Defined.
19:30:45 <dolio> > swap undefined
19:30:47 <lambdabot>   (* Exception: Prelude.undefined
19:31:03 <roconnor> oh right
19:31:03 <Saizan> wanted the strict version?
19:31:09 <roconnor> we can't agree on strictness
19:31:13 <pumpkin_> @hoogle &&&
19:31:13 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
19:31:26 <dolio> > (snd &&& fst) undefined
19:31:28 <lambdabot>   (* Exception: Prelude.undefined
19:32:03 <roconnor> I'm good with either version
19:32:17 <roconnor> maybe with the tiniest of prefrence for swap (a,b) = (b,a)
19:32:56 <roconnor> only because its lattice looks more symetric.
19:33:44 <roconnor> @poll
19:33:44 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
19:34:31 <dolio> @poll-list
19:34:31 <lambdabot> []
19:34:53 <Saizan> it's probably optimization frendlier too
19:35:57 <dolio> And it's shorter. :)
19:36:10 <roconnor> everyone is happy
19:36:18 <roconnor> go make the change before someone complains
19:36:30 <roconnor> :)
19:36:35 <scodil> how do I tell ghc --make to link with a specific .o ? For foreign stuff
19:36:52 <dolio> I actually thought we were getting it in the new base.
19:37:01 <dolio> But it seems I was mistaken.
19:39:53 <dolio> ddarius: By the way, thinking about it earlier, I figured out my objection to the choice to the one lifting of callCC through StateT. We already have the "usual" semantics via ContT State, so why not give "debug" semantics to StateT Cont?
19:42:48 <SamB_XP> dolio: what are the debug semantics ?
19:43:31 <Elly> are there haskell curses bindings?
19:44:43 <scodil> so, I can do "ghc --make HaskellStuff.hs c_stuff.c" and ghc will compile and link c_stuff.c for me, but can I do something like "ghc --make HaskellStuff.hs c_stuff.o" ? Or do I have to go through the whole -l rigmarole?
19:47:43 <scook0> Elly: yes there are; HSCurses is the main one
19:48:06 <pizza__> how do i translate the imperative idiom (if foo then print "bar" #else do nothing) into Haskell? i am trying variations on stuff i already know, searching through online references, Monad tutorials, Real World Haskell, etc.
19:48:17 <dons> Elly: check hackage.haskell.org when looking for libraries
19:48:25 <Elly> dons: thanks
19:48:26 <scook0> there's also the vty package, which is not actually curses but solves similar problems
19:48:26 <dons> pizza__: do nothing is return ()
19:48:33 <pizza__> ah ok
19:48:42 <scodil> pizza__: when foo $ print "bar"
19:48:43 <dons> you can also use Control.Monad.when
19:48:44 <dolio> SamB_XP: Debug semantics are where invoking a continuation rolls back state changes.
19:48:49 <scook0> @type when
19:48:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:49:01 <SamB_XP> dolio: why is that debug ?
19:49:09 <pizza__> dons: that's it, thank you :)
19:49:12 <SamB_XP> anyway, that should certainly be the case one way or the other
19:49:14 <dolio> It's just what the paper calls it.
19:49:57 <dolio> Although it's actually a reference to someone else's work.
19:50:13 <dolio> Someone experimenting with an alternate callcc semantics, I guess.
19:50:32 <athos> good night everyone
19:50:44 <dolio> Probably for debugging.
19:51:13 <mmorrow> dolio: heh, i did the same thing with the cps monads
19:51:14 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
19:51:17 <shapr> bah humbug!
19:51:27 <dolio> Did you write a cabal file?
19:51:30 <mmorrow> (was just reading the logs
19:51:32 <mmorrow> yeah
19:51:46 <mmorrow> http://moonpatio.com/repos/monad-cps/
19:51:51 <lambdabot> Title: Index of /repos/monad-cps
19:52:14 <mmorrow> i didn't try to name them like the mtl ones though
19:52:33 <mmorrow> oh, and i didn't make any classes
19:53:15 <dolio> You also bothered to CPS reader and identity.
19:53:15 <mmorrow> awesome, so you cloned the entire mtl.
19:53:28 <mmorrow> dolio: hehe. IdCPS++
19:53:31 <dolio> And cont.
19:53:36 <mmorrow> woohoo
19:54:01 <pumpkin_> is the ghc optimizer smart enough to replace map f . map g with map f . g ?
19:54:04 <dolio> I didn't clone RWS and such.
19:54:08 * mmorrow replaces his mtl with dolio's cps-mtl
19:54:18 <dolio> But who uses that?
19:54:22 <mmorrow> heh, i have
19:54:25 <dolio> :)
19:55:24 <mmorrow> pumpkin_: i think that kinda stuff is handled via rewrite rules pragmas
19:55:48 <dolio> My library isn't totally compatible with mtl code. Some argument orders and such are switched around.
19:56:08 <dolio> Also it uses type families instead of fundept.
19:56:11 <dolio> Fundeps, even.
19:56:56 <mmorrow> oh cool, that's why i skipped the classes (didn't want to use fundeps, but was too lazy to use type families)
19:56:58 <Saizan> State is s -> (s,a) ?
19:57:03 <Saizan> in yours?
19:57:04 <dolio> I noticed, interestingly, that generic code now requires you to write, say, "(MonadReader m, Env m ~ r) => ..." instead of "(MonadReader r m) => ..."
19:57:09 <dolio> Yes.
19:57:18 <dolio> Well, for as much as that matters.
19:57:22 <mmorrow> S s a = S {unS :: forall o. s -> (s -> a -> o) -> o}
19:57:30 <dolio> State is, internally, forall r. s -> (s -> a -> r) -> r
19:57:59 <SamB_XP> hooRAY for doing State right!
19:58:07 <mmorrow> yeah, the CPS version open up the possibility to have much more general run* functions
19:58:12 <Saizan> dolio: using Env m directly in the rest of the typesign gives errors?
19:59:03 <dolio> mmorrow: Did you run benchmarks with your monads in a separate module/package? I was wondering if the optimizer still does well like that.
19:59:18 <conal> @pl \ g h (a,b) (c,d) -> (a `g` c, b `h` d)
19:59:19 <dolio> Saizan: I thought I had some reason why I couldn't do that, but now that I think about it, it would probably be fine.
19:59:20 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
19:59:44 <conal> eep!  is there a standard combinator for idiom for \ g h (a,b) (c,d) -> (a `g` c, b `h` d)  ?
19:59:53 <pumpkin_> oh my
20:00:00 <conal> one way to combine the fsts and another for the snds
20:00:02 <Axman6> that right there is why point free style is often awful
20:00:05 <mmorrow> dolio: i've been meaning to do some benchmarks on the other monads but haven't yet. i have that original State benchmark here though http://moonpatio.com/repos/state-bench/
20:00:06 <lambdabot> Title: Index of /repos/state-bench
20:00:26 <dolio> > (g *** h) (a,b)
20:00:27 <lambdabot>   Add a type signature
20:00:34 <dolio> > (g *** h) (a,b) :: (Expr, Expr)
20:00:35 <lambdabot>   (g a,h b)
20:00:39 <mmorrow> on my machine the StateCPS is over twice as fast as unboxed tuples
20:00:49 <conal> yeah.  then what?
20:00:56 <dolio> > uncurry (***) (g *** h) (a,b) (c,d) :: (Expr, Expr)
20:00:57 <lambdabot>   Couldn't match expected type `(->)' against inferred type `(,)'
20:01:00 <conal> something to apply a function pair to an argument pair
20:01:01 <dons> mmorrow: huh
20:01:04 <mmorrow> (and unboxed tuples beats Strict mtl State marginally)
20:01:05 <Axman6> > (g *** h) ((a,b),(c,d))
20:01:07 <lambdabot>   Add a type signature
20:01:09 <dons> mmorrow: in that repo?
20:01:12 <mmorrow> dons: yeah, blew my minds
20:01:14 <Axman6> > (g *** h) ((a,b),(c,d)) :: (Expr,Expr)
20:01:15 <mmorrow> yes
20:01:16 <lambdabot>   (g (a,b),h (c,d))
20:01:17 <dolio> > (uncurry (***) <<< (g *** h)) (a,b) (c,d) :: (Expr, Expr)
20:01:18 <lambdabot>   (g a c,h b d)
20:01:19 <dons> curious
20:01:30 <conal> oh, i see.  yeah, thanks.
20:01:35 <dolio> That's not great.
20:01:39 <tcleval> is there any active project to compile/interpret haskell on the java virtual machine?
20:01:41 <conal> no, it's not.
20:01:53 <mmorrow> (well, over twice as fast in that particular benchmark. i want to do others..)
20:01:53 <Axman6> :t (<<<)
20:01:54 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
20:02:02 <dons> mmorrow: is the implementation visible from the outside?
20:02:13 <mmorrow> dons: it doesn't have to be
20:02:16 <dons> or is it opaque (i.e. drop in replacement wrt. strictness/other semantics?)
20:02:24 <conal> oh yeah.  i have those functions in TypeCompose
20:02:32 <dons> Control.Monad.State.CPS sounds good
20:02:34 <mmorrow> yes, it could be completely opaque and drop-in-compatible
20:03:05 <dons> i wonder what it looks like wrt. the Data.Binary put monad.
20:03:20 <dons> is it just State that gets simpler?
20:03:21 <thoughtpolice> pumpkin_: yes, GHC is smart enough to optimize that code
20:03:23 <dons> s/faster/
20:03:25 * conal looks ...
20:03:31 <mmorrow> i was thinking about something like that too (CPS with Binary)
20:03:41 <thoughtpolice> pumpkin_: please see this as well - http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
20:03:43 <lambdabot> Title: 8.14.�Rewrite rules, http://tinyurl.com/y7rk9g
20:03:44 <dons> well, we wrote it as ContT originally
20:03:46 <dons> then did it by hand
20:03:48 <conal> http://hackage.haskell.org/packages/archive/TypeCompose/0.6.2/doc/html/Control-Compose.html#v%3A***%23
20:03:50 <lambdabot> Title: Control.Compose, http://tinyurl.com/6xvkkq
20:04:04 <mmorrow> i haven't benchmarked the other CPS monads against their mtl version, but judging from StateCPS i'd bet they are similarly faster
20:04:17 <dons> very interesting.
20:04:18 <pumpkin_> thanks thoughtpolice
20:04:31 <Elly> I am reading the "How To Write A Haskell Program" tutorial and I fear quickcheck
20:04:42 <dons> thoughtpolice: no build problems with 6.10.1
20:04:47 <dons> Elly: ok. :)
20:04:51 <conal> mmorrow: i saw your remark and couldn't access the moonpatio paste
20:05:03 <Saizan> i thought State would be one where you'd get less gains
20:05:08 <Axman6> i find quickcheck confusing, hence why i never use it
20:05:11 <Elly> is that the intent of that tutorial?
20:05:21 <dons> to scare you?
20:05:21 <saml> in literate haskell file, # is significant
20:05:22 <dolio> mmorrow: I kind of doubt CPSed reader is faster than regular reader.
20:05:26 <Elly> dons: yeah
20:05:30 <dolio> Or identity.
20:05:32 <Axman6> but, my code's always perfect, so...
20:05:33 <Axman6> >_>
20:05:33 <dons> Elly: don't think so.
20:05:38 <thoughtpolice> dons: win!
20:05:46 <SamB_XP> is CPS identity different from regular identity ?
20:05:48 <mmorrow> dolio: heh, yeah those ones probably are a wash :)
20:06:00 <dons> conal: did you really add a dep on category-extras ? :)
20:06:08 <dolio> Identity a = forall r. (a -> r) -> r
20:06:12 <Saizan> mmorrow: have you benchmarked against the lazy or the strict State monad?
20:06:14 <mmorrow> conal: oh dang, what was the error trying to access it?
20:06:25 <mmorrow> Saizan: http://moonpatio.com/repos/state-bench/
20:06:26 <lambdabot> Title: Index of /repos/state-bench
20:06:30 <conal> dons: yes i did
20:06:30 <thoughtpolice> Elly: do not fear the quickcheck, love the quickcheck!
20:06:38 <Elly> I don't know how to use it :(
20:06:39 <mmorrow> the Lazy State blows the stack so it's not considered
20:06:40 <conal> dons: FRP is going comonadic!
20:07:04 <thoughtpolice> conal: whoosh! more efficient hopefully?
20:07:10 <Elly> what's a comonad?
20:07:15 <conal> thoughtpolice: yep.  that's part of the idea.
20:07:16 <mmorrow> conal: http://hpaste.org/12507
20:07:20 <Axman6> anyone know a nice exercise to play with concurrency in haskell? wondering how i can use it (and/or parallelism) to speed up computation
20:07:28 <conal> Elly: its a pattern of values in context.
20:07:33 <dons> conal: woo! a user for category-extras
20:07:35 <dons> good to see
20:07:39 <conal> i'm working on a new blog post series
20:07:48 <thoughtpolice> conal: super great. reactive looks like so much fun and I think it would be excellent to write a small game in, but I would need to sample performance first...
20:08:23 <conal> thoughtpolice: there are some perf issues now.  still getting some subtle stuff worked out.  it's getting more & more solid.
20:08:40 <dolio> Just make lhc compile it into fast code. :)
20:08:45 <thoughtpolice> conal: so I've seen with the release after release on hackage :)
20:08:47 <conal> dons: i was a bit reluctant, given the size of category-extras.  i figure i'll learn more ways to use it as i go.
20:08:51 <thoughtpolice> dolio: ;)
20:08:56 <conal> thoughtpolice: :)
20:09:01 <thoughtpolice> dolio: we're getting there... eventually.
20:09:04 <dons> it's easy to build though.
20:09:42 <Axman6> anyone know how to fix this when doing a cabal upgrade? process-1.0.1.0 was excluded because ghc-6.10.1 requires process ==1.0.1.1
20:09:56 <dons> and once you depend on more the 3 or 4 things, you may well just do the whole thing.
20:10:06 <dons> Axman6: is that a problem?
20:10:09 <conal> mmorrow: that hpaste worked fine.  thanks.  from moonpatio i always get "The connection to the server was reset while the page was loading."
20:10:29 <mmorrow> conal: hmm, odd. i wonder if that's something on my end?
20:10:41 <Axman6> dons: well yes, i can't upgrade things like reactive
20:11:05 <dons> mmmm.
20:11:16 <dons> why are you upgrading process?
20:11:42 <Axman6> i'm not, cabal is. i just said 'cabal upgrade reactive' and it whinged at me about process
20:12:01 <conal> mmorrow: i think other people on #haskell can read your moonpatio pastes, so maybe my ISP is blocking the port.
20:12:12 <conal> mmorrow: i've had that issue before with other sites.
20:12:13 <Saizan> Axman6: "cabal install reactive" ?
20:12:16 <thoughtpolice> conal: I'm still trying to figure out the whole thing with FRP/FieldTrip/reactive though...
20:12:19 <Axman6> same thing
20:12:32 <thoughtpolice> conal: maybe actually using what's there (fieldtrip, reactive, reactive-glut and reactive-fieldtrip) is a good way to figure that out
20:13:03 <dons> cabal install reactive --reinstall
20:13:08 <dons> i think upgrade does something else
20:13:17 <Axman6> same thing
20:13:24 <dons> frankly, i never rememebr what upgrade does, and i don't use it.
20:13:32 <mmorrow> conal: ah, hmm. maybe i can setup the apache on :80 to somehow proxy to :8080 from something like ..patio.com/hpaste2/
20:13:48 <thoughtpolice> it looks at all the dependencies of a package, upgrades all of them, and then re-builds your package against the latest dependencies
20:13:50 <mmorrow> i wonder if that problem is fairly widespread
20:14:33 <conal> mmorrow: i bet you could.
20:14:43 <conal> mmorrow: with an apache redirect rule
20:14:43 <Axman6> bleh, cabal list --installed shows that i have both process-1.0.1.0 and process-1.0.1.1
20:14:51 <dons> ah, remove one.
20:14:56 <Axman6> which one?
20:14:58 <mmorrow> conal: nice, i'll try to figure that out
20:14:59 <dons> pick one!
20:15:04 <dons> i'd remove the oldest one.
20:15:18 <thoughtpolice> actually you probably want to remove the new one
20:15:18 <thoughtpolice> it
20:15:31 <thoughtpolice> s likely that lots of stuff is built against process-1.0.1.0
20:15:40 <thoughtpolice> so if you 'ghc-pkg unregister' it you'll probably break lots of stuff
20:15:53 <Axman6> so how do i uninstall it then?
20:15:54 <thoughtpolice> Axman6: but you do need to unregister one of them - a good way to do this without permanently breaking things is doing something like
20:16:22 <thoughtpolice> ghc-pkg describe pkg-1.0 > save-pkg.out
20:16:30 <thoughtpolice> ghc-pkg unregister pkg-1.0
20:16:32 <thoughtpolice> ghc-pkg check
20:16:47 <thoughtpolice> that will save the info of the package, unregister, and check package consistency across everything
20:17:17 <Axman6> ghc-pkg: unregistering process-1.0.1.1 would break the following packages: lambdabot-utils-4.2 graphviz-2008.9.20 readline-1.0.1.0 derive-0.1.4 haskell98-1.0.1.0 Cabal-1.6.0.1 (use --force to override)
20:17:45 <thoughtpolice> after you unregister one of them, try to build reactive again. if it doesn't work, do 'ghc-pkg register save-pkg.out'
20:17:56 <Axman6> i can't unregister it
20:17:57 <thoughtpolice> then try again for the other version
20:18:10 <thoughtpolice> when you get reactive working, leave the version you took out uninstalled
20:18:17 <Axman6> guess i could reinstall all those packages again...
20:18:19 <thoughtpolice> you must then rebuild all those packages that are broke against the other version
20:18:27 <thoughtpolice> Axman6: I've been through this process plenty of times
20:18:56 <thoughtpolice> it's not really that bad, but it is annoying. once you find out which one you *don't* need and you get reactive working, leave it unregistered, and rebuild those packages
20:19:39 <thoughtpolice> Axman6: sorry if i'm not making sense, it's starting to get late...
20:19:52 <Axman6> heh, it's ok, i think i'm on it
20:19:57 <Axman6> but what a pain in the bum!
20:20:11 <thoughtpolice> like I said, been here, done that :)
20:20:42 <Saizan> oooh
20:21:00 <thoughtpolice> Saizan: did the hscurses author ever accept your patches to make it work on ghc 6.10.1?
20:21:00 <Saizan> this is all caused by category-extras wrongli depending on the ghc library
20:21:38 <Saizan> (and cabal-install's dependency solver not doing backtracking too, probably)
20:21:45 <thoughtpolice> Saizan: huh. yeah that could be a major problem
20:21:55 <Saizan> thoughtpolice: didn't get an answer, actually
20:22:55 <thoughtpolice> Saizan: :( i would try again and if he doesn't answer, upload a version to hackage with the fix. having hscurses *transparently* broken on GHC 6.10.1 isn't cool at all
20:29:11 <Saizan> thoughtpolice: yeah, strictly speaking i'd have to upload a fork with no maintainer though :)
20:29:25 <pizza__> why doesn't (print "a" `seq` print "b") cause "a" to be printed? and how can i achieve that?
20:29:54 <Saizan> pizza__: do print "a"; print "b"
20:30:06 <ksf> because print "a" is "only" reduced to whnf.
20:30:22 <Saizan> pizza__: or print "a" >> print "b", which is the same thing without do-notation
20:30:32 <ksf> the io monad doesn't come to see the action the whnf represents at all.
20:31:16 <Saizan> yeah, (print "a" `seq` print "b") just checks to see that print "a" is an action and then discards it
20:31:41 <pizza__> yup, >> is the ticket, for the second time tonight. i'll figure all this out eventually
20:31:48 <pizza__> than you very much Saizan and ksf
20:31:53 <blackdog> bindings to C libraries: is c2hs still the hotness?
20:32:19 <ksf> coming half-way to terms with monads is haskell's learning cliff.
20:32:31 <dons> blackdog: yeah.or hsc2hs, which is more common
20:32:33 <moreqwertythanu> does haskell have multimethods?
20:32:36 <Saizan> pizza__: http://www.haskell.org/haskellwiki/Monads_as_computation
20:32:38 <lambdabot> Title: Monads as computation - HaskellWiki
20:32:47 <dons> moreqwertythanu: what do they do?
20:32:53 <moreqwertythanu> or some sort of dispatch on type?
20:32:54 <dons> ?faq probably so
20:32:54 <lambdabot> The answer is: Yes! Haskell can do that.
20:33:00 <dons> moreqwertythanu: oh, yes. type classes!
20:33:10 <dons> resolved statically by the compiler too, btw.
20:33:17 <blackdog> dons: ah, cheers.
20:33:19 <ksf> ...or case expressions or pattern matching, fwiw.
20:33:35 <dons> well, case/ patterns are dispatch on value
20:33:41 <dons> type classes are dispatch on type
20:33:45 <dons> :t (==)
20:33:46 <lambdabot> forall a. (Eq a) => a -> a -> Bool
20:33:52 <dons> moreqwertythanu: for example, == is overloaded on any Eq type
20:33:56 <moreqwertythanu> ah yes ofc it has since you can do, [2]++[2] and "hello"++" there", but those could have been builtin somehow. i will loook at typeclasses
20:33:59 <dons> dispatching ot the equality for that type
20:34:05 <ksf> there you go dons, you just untangled my mind
20:34:14 <dons> moreqwertythanu: that's just parametric polymorphism
20:34:19 <dons> not ad-hoc polymorphism
20:34:23 <dons> which is what type classes provide
20:34:26 <ksf> still, in some sense Left foo is a different type than Right foo.
20:34:28 <dons> Eq is a classic example.
20:34:34 <dons> each type defines its own equality mechanism
20:34:36 <dons> but you access it via ==
20:34:43 <dons> which is just defined per-type, and resolved at compile time
20:34:47 <dons> :t (+)
20:34:48 <lambdabot> forall a. (Num a) => a -> a -> a
20:34:53 <Saizan> ?seen edwardk
20:34:53 <lambdabot> edwardk is in ##logic, #haskell and #haskell-blah. I last heard edwardk speak 11h 12m 4s ago.
20:34:56 <dons> is overloaded on types in the Num class, moreqwertythanu
20:35:14 * ksf still needs to find a predicate to filter scheme out of his head
20:35:41 <pumpkin_> I'm having trouble getting this to typecheck: http://hpaste.org/12508
20:35:47 <pumpkin_> anyone know what's wrong?
20:36:05 <pumpkin_> oh actually, it doesn't make much sense as a function right now
20:36:19 <ksf> without looking, fromIntegral is missing.
20:36:24 <pumpkin_> lol
20:36:50 <dons> pumpkin_: subtracting Int from Double
20:36:59 <dons> using point free isn't so clear here, imo.
20:37:05 <dons> maybe a list comprehension
20:37:06 <pumpkin_> yeah, that's true
20:37:22 <ksf> ...you need to manually coerce number types from time to time, haskell only has safe duck typing.
20:37:33 <pumpkin_> ah I think I see
20:37:55 <Saizan> (/ fromIntegral bins)
20:37:55 <moreqwertythanu> so lets say I have an abstract class Shape and then I have subclasses Square and Circle and in some function I need to call area on the type. So I don't want to tie that function to a special type but work for all Shapes. So I should then have data Shape = Square | Circle and for each some function to compute area?
20:38:36 <Elly> you want a typeclass, I think
20:38:40 <ksf> nah, you gonna have a class Shape and then instance Shape Square and instance Shape Circle
20:38:49 <moreqwertythanu> dons: but can it always be resolve at runtime?
20:39:07 <ksf> ...classes are a lot like interfaces in OO languages.
20:39:28 <dons> pumpkin_: http://hpaste.org/12508#a1
20:39:31 <Saizan> moreqwertythanu: i realize this is an artificial example, however designing in terms of OO is a really bad choice in haskell
20:40:02 <pumpkin_> dons: thanks
20:40:10 <pumpkin_> the logic is broken too, though
20:40:14 <pumpkin_> need to fix that first :)
20:40:20 <Axman6> well that was... uh... odd. just ran something with profiling, and it ran faster than without rofiling
20:40:23 <Axman6> p*
20:40:47 <Saizan> Axman6: you've found a bug in the optimizer, sir
20:41:16 <dons> moreqwertythanu: http://hpaste.org/12509
20:41:19 <Axman6> ah maybe not
20:41:35 <dons> that's how you define a common operation that has different implementations per-type
20:41:42 <dons> then 'area' works on anything in the Shape class
20:42:30 <Axman6> checking again, i find its very slightly slower when using profiling
20:42:37 <dons> when you call 'area' on a value of Square type, the compiler has replaced it with the definition of area associated with the instance
20:42:58 <ksf> dons, forgive me my naivete, but isn't Left foo just a type lambda like Either foo is, somewhere down the line?
20:43:11 <dons> :k Left
20:43:12 <lambdabot> Not in scope: type constructor or class `Left'
20:43:17 <dons> :k Either
20:43:18 <lambdabot> * -> * -> *
20:43:22 <dons> Left is a function
20:43:29 <dons> its a normal value like other functions
20:43:39 <ksf> but it's got a capital letter!
20:43:40 <dons> Either is a 'type lambda', in that you apply it to other types
20:43:47 <dons> yes, construtors are special
20:43:53 <dons> > map Left [1..10]
20:43:54 <lambdabot>   [Left 1,Left 2,Left 3,Left 4,Left 5,Left 6,Left 7,Left 8,Left 9,Left 10]
20:43:56 <dons> but its just another value
20:44:03 <Axman6> :t Left
20:44:04 <lambdabot> forall a b. a -> Either a b
20:44:05 <dons> > [Left 1, Left 2] -- see. in a data structure
20:44:06 <lambdabot>   [Left 1,Left 2]
20:44:29 <dons> i remember how cool it was when i realise constructors were first class functions
20:44:46 <Elly> dons: I remember realizing that in SML too
20:44:46 <dons> so you could say, return . Just $ ....
20:44:51 <Axman6> dons: that moment is happening for me right now :P
20:44:59 <dons> they're not first class in ocaml, iirc?
20:45:05 <Axman6> though i guess i've used it quite a bit before
20:45:10 <dons> or maybe that's record accessors?
20:45:13 <Elly> no idea, but they're first-class in SML
20:45:21 <ksf> in that case, i'm utterly shattered by the fact that not all first class functions can be used in pattern matches...
20:45:24 <dons> ocaml has weird restrictions.
20:45:29 <dons> ksf: ?
20:45:38 <dons> ah yes.
20:45:51 <dons> well, 'views' let us use functions that compute arbitrary results in patterns
20:45:51 <Saizan> ksf: not all functions are invertible
20:45:56 <dons> but that's a non-trivial extension
20:46:05 <Axman6> ksf: well if you have f = g, would you want g to match f too?
20:46:11 <dons> the compiler knows a lot more about constructors
20:46:22 <dons> so that they are both functions, yet data tags to match on
20:46:23 <ksf> Axman6, I'd rather not answer that one.
20:46:27 <pumpkin_> is there a better name for zipWith (-) (tail xs) xs than derivative? :P
20:46:28 <Axman6> heh
20:46:43 <pumpkin_> where xs is a list of nums
20:46:51 <Elly> deltas!
20:47:28 <Axman6> > let xs = [x^2|x<-[1..10]] in zipWith (-) (tail xs) xs
20:47:29 <lambdabot>   [3,5,7,9,11,13,15,17,19]
20:47:33 <pumpkin_> hmm, sounds reaonable :)
20:47:40 <ksf> Axman6, especially if g = f, too.
20:47:51 <Saizan> > (zipWith (-) =<< tail) [1..10]
20:47:52 <lambdabot>   [1,1,1,1,1,1,1,1,1]
20:48:08 <pumpkin_> oh my
20:48:11 <Axman6> > let xs = [x^2|x<-[0..10]] in zipWith (-) (tail xs) xs
20:48:13 <pumpkin_> :P
20:48:13 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
20:48:38 <Axman6> Saizan: uh... yeah i have no idea how that works
20:48:46 <dons> woot. http://www.amazon.de/gp/bestsellers/books-intl-de/63350011/ref=pd_zg_hrsr_eb_2_4_last
20:48:49 <lambdabot> http://tinyurl.com/5bn8tr
20:49:01 <dons> notice something *awesome* about that list of books
20:49:04 <Saizan> Axman6: that was half of the point :)
20:49:33 <pumpkin_> :t (=<< tail)
20:49:34 <lambdabot> forall b a. ([a] -> [a] -> b) -> [a] -> b
20:49:37 <Axman6> dons: damn right, i love the art and science of presentation design!
20:49:39 <Axman6> >)>
20:49:43 <Saizan> dons: woot
20:49:54 <Elly> dons: that's pretty sweet :P
20:50:08 <Saizan> RWH over design patterns, that's something
20:50:20 <dons> yeah
20:50:22 <dons> go germany!
20:50:51 <moreqwertythanu> how do i access the attribute? like Circle 5, where 5 is the radius
20:51:01 <moreqwertythanu> area c = pi * radius^2
20:51:05 <dons> moreqwertythanu: via pattern matching, or via a record
20:51:14 <Saizan> area (Circle radius) = ...
20:51:14 <dons> area (Circle r) = pi * r ^ 2
20:51:16 <moreqwertythanu> case c of Circle x -> x
20:51:23 <dons> is the easiest way. notice how awesome the pattern matching is :)
20:51:35 <dons> since you can deconstruct data in the argument
20:52:10 <roconnor> Maven: The Definitive Guide
20:52:41 <Axman6> moreqwertythanu: i'd go with pattern matching
20:53:01 <ksf> I'd rather smash my head repeatedly into a wall than use powerpoint for presentations.
20:53:02 <moreqwertythanu> instance Shape (Circle radius) where
20:53:02 <moreqwertythanu>     area (Circle radius)  = pi * radius^2
20:53:07 <ksf> or pdf's, for that matter.
20:53:10 <dons> 22nd in the same category in France. 1 in germany. looks like ocaml has .fr locked up...
20:53:10 <Saizan> can you write if impl(ghc > 6.9) .. in .cabal files?
20:53:13 <moreqwertythanu> does not work
20:53:15 <Axman6> like area (Circle r) = pi * r^2 like dons said. makes it easy to add more chapes
20:53:17 <dons> Saizan: yeah
20:53:18 <Axman6> sh*
20:53:32 <Axman6> moreqwertythanu: you don't need that
20:53:35 <moreqwertythanu> yes it is the instance i think
20:53:44 <moreqwertythanu> that doesnt work
20:53:56 <Axman6> moreqwertythanu: you already have data Shape = Square Double | Circle Double right?
20:54:14 <Axman6> then area :: Shape -> Double
20:54:16 <moreqwertythanu> no
20:54:18 <Axman6> no need to use classes
20:54:20 <dons> Axman6: oh, are you defining a single algebraic type for all shapes?
20:54:37 <Axman6> i thought thats what he said earlier
20:54:45 <dancor> i had to compile my own libedit and ghc 6.10.1.  ghc runs great, but when i start ghci it floods my terminal with bell, and pegs one cpu (but low memory usage), and i have to :q and wait 10s for it to exit
20:54:45 <moreqwertythanu> well i dont know whats better
20:54:53 <moreqwertythanu> i want a function that dispatches on the type
20:54:55 <dancor> ghc 6.8.3 works fine.  so is this probably a libedit issue?
20:55:02 <moreqwertythanu> u tell me whats the better way to go about it
20:55:15 <dancor> to get libedit to compile, i had to add -fPIC to the Makefile after ./configure
20:55:21 <Saizan> ?seen dolio
20:55:22 <lambdabot> dolio is in #ghc, #haskell-blah and #haskell. I last heard dolio speak 46m 41s ago.
20:55:30 <thoughtpolice> dancor: people have been having various problems with libedit
20:55:35 <Axman6> moreqwertythanu: the way i was doing it saves typing, and its easy to extend to other shapes
20:55:41 <dancor> thoughtpolice: yeah i bet it's libedit..
20:55:44 <thoughtpolice> dancor: BUT, there turns out to be an excellent solution
20:55:47 <dons> dancor: sounds like it.
20:55:53 <thoughtpolice> that can probably narrow it down further if nothing else
20:55:56 <dancor> thoughtpolice: recompile with readline?
20:56:01 <ksf> moreqwertythanu, that depens on how the rest of your code looks, how extensible you want Shape to be, if performance matters...
20:56:07 <thoughtpolice> dancor: even better
20:56:15 <thoughtpolice> dancor: do a 'darcs get http://code.haskell.org/~judah/ghci-haskeline/' and install that
20:56:30 <dancor> exciting
20:56:30 <roconnor> is this the expression problem?
20:56:40 <thoughtpolice> dancor: it is a version of GHCi, but it uses the haskeline package from Hackage (which is written in haskell, btw) instead of editline/readline
20:56:56 <ksf> if you're just fooling around, i'd recommend to do it in as much ways you can come up with.
20:56:57 <Axman6> thoughtpolice: sounds good.
20:57:04 <moreqwertythanu> hmm but data Shape needs some args and those are of variable elngth
20:57:05 <Axman6> will that be in future ghci's?
20:57:16 <Axman6> moreqwertythanu: what do you mean?
20:57:28 <thoughtpolice> dancor: when I installed 6.10.1, I had various problems with libedit (due in part likely to my very dirty and messed up system) - it also broke emacs' haskell-mode. I installed ghci-haskeline on 6.10.1 and have had no problems whatsoever
20:57:39 <moreqwertythanu> data Shape = Circle r | Square side | Rectangle h w
20:57:45 <thoughtpolice> Axman6: given the grief everybody is having over libedit, I think they will adopt it for future GHC releases, yes
20:57:57 <dancor> thoughtpolice: it works beautifully
20:57:59 <thoughtpolice> Axman6: at least, I believe SPJ was giving it serious consideration and a push on glasgow-haskell-users
20:58:01 <Axman6> thoughtpolice: whoot
20:58:05 <thoughtpolice> dancor: told ya :)
20:58:06 <ksf> moreqwertythanu, what's the problem with it?
20:58:13 <thoughtpolice> judah-jacobson++ # he's the man
20:58:15 <dolio> Saizan: Yo.
20:58:20 <dancor> thoughtpolice: do you just rm ghci and ln -s?
20:58:26 <Axman6> moreqwertythanu: give me a sec and i'll show you some code :)
20:58:29 <moreqwertythanu> data Shape = Circle radius | Square side
20:58:29 <moreqwertythanu>              deriving(Eq, Ord, Show)
20:58:40 <moreqwertythanu> Not in scope: type variable `radius'
20:58:51 <ksf> "Shape" itself only takes a parameter if you want to restrict the polymorphism of it's members.
20:59:25 <ksf> like Shape a = Circle a | Square a | Rectangle a a
20:59:28 <Axman6> moreqwertythanu: http://hpaste.org/12510
20:59:42 <thoughtpolice> dancor: I moved ghci to ghci-old
20:59:42 <thoughtpolice> and then just cabal install'd it
20:59:45 <ksf> and then IntShape = Shape Int DoubleShape = Shape Double
21:00:24 <moreqwertythanu> ksf: but rectangle doesnt have a a it has a b
21:00:26 <Axman6> thoughtpolice: i guess te less external libraries we have to rely on, the better :)
21:00:29 <moreqwertythanu> is that ok anyway?
21:00:39 <thoughtpolice> dancor: but yes, it works beautifully. adopting haskeline at this point seems like a nobrainer to me
21:00:42 <Axman6> moreqwertythanu: no, it should Rectangle a a
21:00:49 <ksf> moreqwertythanu, it has a a, unless your'e doing _really_ strange things.
21:00:50 <Axman6> shoud be*
21:00:59 <dancor> thoughtpolice: extreme-agree
21:01:00 <ksf> you don't want to have Rectangle Int Double
21:01:02 <Axman6> moreqwertythanu: did you look at the code i pasted?
21:01:22 <moreqwertythanu> aja
21:01:23 <thoughtpolice> in fact
21:01:27 <thoughtpolice> judahj++
21:01:27 <thoughtpolice> judahj++
21:01:33 <thoughtpolice> did i mention he's the man? :)
21:02:29 <thoughtpolice> anyway, i'm off for a walk
21:02:35 <thoughtpolice> and then some reading
21:02:40 <Axman6> o/
21:02:42 * thoughtpolice --away
21:04:16 <Axman6> moreqwertythanu: so, did what i paste make sense?
21:04:19 <mmorrow> oh yeah, i just noticed haskeline after playing with lhc. i haven't looked at it yet, but it seems to implem all the needed readline functionality in haskell?
21:04:24 <mmorrow> if so i'm psyched
21:04:47 <byorgey> mmorrow: that's the idea.
21:04:48 <mmorrow> editline--
21:04:58 <mmorrow> byorgey: awesome!
21:05:03 <mmorrow> @karma editline
21:05:03 <lambdabot> editline has a karma of -1
21:05:03 <byorgey> I don't know how close it is to being complete?  I've never used it myself
21:05:03 <Axman6> whoot
21:05:04 <ksf> real programmers use cat, head and tail.
21:05:10 <Axman6> editline--
21:05:27 <pumpkin_> does the haskell world typically stick to 80-column-wrapped code?
21:05:29 <moreqwertythanu> http://hpaste.org/12511
21:05:52 <pumpkin_> do you really want to keep square and rectangle separate?
21:05:53 <moreqwertythanu> so when yo use type classes instead? is my solution good?
21:05:57 <mmorrow> pumpkin_: i break after col 78
21:06:29 <Axman6> pumpkin_: why not? a square only needs one parameter
21:06:34 <pumpkin_> mmorrow: what are good break points? I have a long list comprehension and I'm trying to break it up, but it's all ugly
21:06:46 * ksf used to break before 80, but now got xmonad and bigger vims.
21:06:59 <ksf> to make a long story short: I don't care about your screen size.
21:07:00 <pumpkin_> Axman6: it just allows you to treat things more homogeneously, it seems, if you need to do more complicated things than just area
21:07:31 <ksf> it also allows you to break up pattern matching statically into different functions.
21:07:40 <mmorrow> pumpkin_: ah yeah, i'm constantly trying to tweak my strategy there. one place i use a lot is on (.) in a longish pipeline
21:07:44 <Axman6> well to me, a Square s a special case rectangle that needs less information stored about it
21:07:57 * mmorrow has a 1024x768 display on his laptop
21:08:18 <pumpkin_> :)
21:08:39 <Saizan> anyone knows where category-extras repo is?
21:08:52 <ksf> so, ideally, resize :: Rectangle -> Shape should be able to return Squares as well as Rectangles.
21:09:09 <mmorrow> byorgey: i've gotta check out the haskeline codez
21:09:30 <ksf> so you're not left with Rectangles that have Square invariants all over the place, after a few operations.
21:09:40 <pumpkin_> yeah, that's what I was trying to avoid
21:09:41 <Saizan> ghci-haskeline still gets unicode wrong
21:09:46 <Saizan> at least on windows
21:09:48 <mmorrow> Saizan: i've looked for it without success (i knew the url at one point but that info is lost afaict)
21:10:01 <mmorrow> Saizan: aww, too bad
21:10:09 <mmorrow> readline++
21:10:11 <Saizan> you can type it in
21:10:21 <Saizan> but the output is mangled
21:10:31 <Saizan> so it's probably not haskeline fault
21:10:36 <mmorrow> hmm, even if..
21:10:37 <mmorrow> yeah
21:10:38 <moreqwertythanu> is matlab suitbale for production code or is it just for prototyping? if im doing some machien learning stuff shold i rewrite it in haskell when im done or is calling ia the matlab interface fast enough?
21:10:47 <mmorrow> even if you properly utf8 encode your output?
21:11:20 <Axman6> ksf: when we did an exercise like this at the beginning of uni, we used a normalise function that was Shape -> Shape, and would take Rectangles where l == w and turn them into Square l etc
21:11:26 <Saizan> mmorrow: i'm talking about ghci's messages, like errors or answers to :t
21:12:09 <mmorrow> Saizan: ah yeah, i've noticed this with lunabot. i guess it's ghc's fault?
21:12:17 <Axman6> moreqwertythanu: its usually used for prototyping afaik
21:12:42 <mmorrow> (and lunabot isn't on windows or using haskeline)
21:13:41 <mmorrow> it's tricky to figure out where mangled stuff is coming from when there's one or more layers of utf8 encode/decode going on on top of it
21:13:49 <roconnor> damn it
21:13:51 <roconnor> Module imports form a cycle for modules:
21:13:57 <roconnor> I should switch to lhc.
21:13:58 <Saizan> mmorrow: with which type are those messages stored?
21:14:34 <mmorrow> Saizan: i'm not exactly sure, but let me try to reproduce a mangled one with lunabot...
21:15:08 <Saizan> we already have a type that can store all of unicode "Char", i think we should just use that for internal representation and convert to any encoding only on I/O
21:15:22 <mmorrow> , let (∈) = elem in [] ∈ [1,2,3]
21:15:26 <pumpkin_> say I have a where block, with a few bindings in it that depend on one another... is it typical to toposort them down or up, or do people not really have a convention for that?
21:15:28 <lunabot>  luna: No instance for (GHC.Num.Num [a])
21:15:48 <mmorrow> , let (∈) = elem in [] ∈ [()]
21:15:50 <lunabot>  luna: Couldn't match expected type `[a]' against inferred type `()'
21:16:32 <dolio> , let (∈) = elem in [] ∈ [[]]
21:16:35 <lunabot>  True
21:16:43 <Saizan> pumpkin_: we usually group modules from the same hierarchy/package together, yeah
21:16:48 <mmorrow> , let (∈) = map in id ∈ ()
21:16:49 <lunabot>  luna: Couldn't match expected type `[a]' against inferred type `()'
21:17:02 <thoughtpolice> Saizan: http://comonad.com/haskell/category-extras/
21:17:04 <lambdabot> Title: Index of /haskell/category-extras
21:17:12 <mmorrow> gah, the challenge is to get ghc to stick the unicode symbol in the first line of the error msg
21:17:17 <Saizan> thoughtpolice: thanks
21:17:33 <mmorrow> , let (∈) = map in (∈) ∈ (∈)
21:17:35 <lunabot>  luna: Couldn't match expected type `[a -> b]'
21:17:43 <pumpkin_> Saizan: I mean in something like http://hpaste.org/12512, I have the variable range which "depends on" maxX and minX... is it more typical to have it on the top of the list, or the bottom?
21:17:47 <mmorrow> , let (∈) = (∈) in (∈) ∈ (∈)
21:17:50 <lunabot>  luna: out of memory (requested 2097152 bytes)
21:17:56 <dolio> , let (∈) = map in ∈ ∈
21:17:57 <lunabot>  luna: parse error on input `'
21:18:03 <mmorrow> there.
21:18:21 <mmorrow> so ghc isn't utf8 encoding the symbol name
21:18:43 <mmorrow> (i'm capturing that output from stdout (stderr?))
21:18:48 <thoughtpolice> Saizan: removing the GHC dep category-extras has?
21:19:45 <Saizan> pumpkin_: oh, i totally misunderstood, in that case yeah, i'd toposort with the sinks at the top, like that, but i'm not sure if there's a convention
21:19:56 <Saizan> thoughtpolice: yeah
21:20:36 <mmorrow> <lunabot>  luna: parse error on input `
21:20:50 <mmorrow> hmm, that err msg may be coming from the lexer and/or the parser
21:21:02 <mmorrow> (originally)
21:21:16 <mmorrow> so maybe fixing those error msgs would do it
21:21:51 <pumpkin_> thanks Saizan
21:22:57 <mmorrow> , let (∈) = undefined :: [α] -> [α] in (∈) (undefined :: Maybe α)
21:22:59 <lunabot>  luna: Couldn't match expected type `[ѝ'
21:23:12 <mmorrow> that error msg defi8nitely isn't from the lexer/parser
21:23:50 <mmorrow> so i guess /all/ error message stuff needs to be modified to utf8 encode the incoming symbol/whatever name
21:23:54 <blackdog> dons: just looking at the bloom filter chapter on the rwh site - why are so many of the ghci boxes showing errors?e
21:26:30 <roconnor> Data.Colour.Names> red
21:26:31 <roconnor> Data.Colour.SRGB.Linear.rgb 1.0 0.0 0.0
21:26:37 <roconnor> should I return that?
21:26:47 <roconnor> or should I return simply rgb 1.0 0.0 0.0?
21:26:57 <roconnor> or should I return simply "rgb 1.0 0.0 0.0"?
21:27:24 <mmorrow> hmm, what is the intended use-case for that output?
21:27:59 <roconnor> people say that show should produce haskell source code in the string
21:28:08 <mmorrow> TH for instance prints fully qualified names, but sometimes that's not what you want e.g. if you're gonna parse the ouput (since qualified names in certain places are syntax errors)
21:28:25 <roconnor> mmorrow: well that's the problem I'm having
21:28:31 <roconnor> my implementation of read broke
21:28:43 <roconnor> because lexing the first word  gives
21:28:52 <roconnor> lex "Data.Colour.SRGB.Linear.rgb 1.0 0.0 0.0"
21:28:52 <roconnor> [("Data",".Colour.SRGB.Linear.rgb 1.0 0.0 0.0")]
21:29:07 <mmorrow> yeah, this is the tricky decision. i guess output it /un/qualified then
21:29:17 <roconnor> hmm
21:29:28 <roconnor> unfortunately rgb is ambiguious
21:29:32 <roconnor> I have several implemenations
21:29:37 <mmorrow> because read et al. breaking i'd say is a bigger problem than the off change rgb'd be ambiguous
21:29:38 <mmorrow> oh
21:29:52 <pumpkin_> I'd be terrified to write something called that because I wouldn't be able to choose whether to call it color or colour
21:29:53 <mmorrow> dang, looks like you're in a pickle then ;)
21:30:05 <roconnor> mmorrow: yep
21:30:22 <roconnor> I could do takeWhile (=/) ' '
21:30:34 <roconnor> well
21:30:37 <roconnor> hmm
21:30:41 <roconnor> @src lex
21:30:42 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:31:07 <mmorrow> i guess then have a function that takes a Bool or something as an option which says if you want it qualified or not (so you can't use show here)
21:31:26 <roconnor> nah
21:31:29 <roconnor> people what Show
21:31:30 <mmorrow> other than that, it looks like there's no universal solution
21:31:36 <roconnor> so they can use quickcheck
21:31:39 <pumpkin_> @hoogle <<=
21:31:39 <lambdabot> No results found
21:31:52 <pumpkin_> whoops, had it backwards :P
21:32:09 <dons> blackdog: oh, likely the last time we generated the web docs, there were missing libraries
21:32:13 <dons> blackdog: so ghci errors.
21:32:29 <dons> we'll be updating the site soon with the final xml
21:33:45 <blackdog> dons: ah, righto.
21:35:04 <roconnor> wow
21:35:06 <mmorrow> roconnor: i think the base problem here is how Show/Read are used to do too many conflicting things
21:35:09 <roconnor> lex is not a simple function
21:35:16 <mmorrow> heh, no
21:35:18 <dolio> Heh.
21:35:20 <mmorrow> ReadP
21:35:35 <mmorrow> (in newer ghc)
21:36:39 <pumpkin_> @pl maybe Nothing f
21:36:39 <lambdabot> maybe Nothing f
21:36:50 <roconnor> @type span
21:36:51 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
21:36:53 <pumpkin_> I feel there's a simpler way of writing that
21:37:24 <dolio> (>>=)?
21:37:25 <mmorrow> pumpkin_: fmap f
21:37:32 <mmorrow> ooh, no
21:37:42 <mmorrow> yeah (>>=) i guess
21:37:43 <pumpkin_> yeah, I've been trying to get it working with >>=
21:37:48 * pumpkin_ tries some more
21:38:00 <dolio> @type maybe Nothing
21:38:01 <lambdabot> forall a a1. (a1 -> Maybe a) -> Maybe a1 -> Maybe a
21:38:10 <mmorrow> @type (>>=)
21:38:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:38:19 <mmorrow> @type (=<<)
21:38:20 <dolio> It's (=<<) I guess.
21:38:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:38:30 <pumpkin_> yeah, was trying with that too :P
21:38:40 <mmorrow> (f =<<)
21:40:28 <pumpkin_> so I have a function csvToDouble that takes a CSV to a [[Double]], and another one parseCSV that returns Maybe CSV (this is from Text.CSV.ByteString)
21:41:06 <pumpkin_> hmm
21:41:19 <mmorrow> (csvToDouble `fmap`) . parseCSV
21:41:34 <roconnor> @type span (\c -> isAlphaNum c || c == '.') . dropWhile isSpace
21:41:36 <lambdabot> [Char] -> ([Char], [Char])
21:41:51 <pumpkin_> mmorrow: beautiful, thanks
21:41:57 <mmorrow> :)
21:41:59 <byorgey> @seen conal
21:41:59 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 1h 27m 16s ago.
21:42:02 <pumpkin_> is that possible with =<< too?
21:42:13 <mmorrow> (return . csvToDouble =<<) . parseCSV
21:42:25 <pumpkin_> aha, the return is what I was missing
21:42:44 <roconnor>     mylex = return
21:42:44 <roconnor>           . span (\c -> isAlphaNum c || c == '.')
21:42:44 <roconnor>           . dropWhile isSpace
21:42:56 <roconnor> that seems to be good enough to parse one qualifed name
21:43:01 <roconnor> which is all I need to do.
21:43:10 <byorgey> @tell conal your blog post on semantic editor combinators was mind-expanding and very well written.  thanks!
21:43:11 <lambdabot> Consider it noted.
21:43:14 <byorgey> conal++
21:43:19 <roconnor> (one qualifed name without ' and _)
21:43:22 <mmorrow> roconnor: don't forget '_' and '\''
21:43:24 <mmorrow> heh
21:44:00 <roconnor> fine
21:44:01 <roconnor>           . span (\c -> isAlphaNum c || c `elem` ".'_")
21:44:15 <mmorrow> yay! ;)
21:55:01 <pumpkin_> do most people here have insane math / abstract algebra / category theory academic backgrounds? or are you just curious people who have picked up all that theory by working on haskell?
21:55:11 <Saizan> other parsing issues :) http://hpaste.org/12513
21:55:54 <Saizan> pumpkin: i think it's few of the former more of the latter
21:56:07 <EmielRegis> abstract algebra is evul
21:56:09 <Cale> pumpkin_: A little from column A, a little from column B.
21:56:34 <Saizan> ?bug
21:56:35 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
21:56:36 <Cale> Personally, I have a proper math background, but this stuff tends to get people interested in it from the other direction.
21:56:53 <dons> pumpkin_: mostly just haskell programmers.
21:57:13 <dons> very few math / theory people, but way more than in #python
21:57:28 <solrize_> pumpkin_ most of the category theory i've studied was from trying to understand haskell
21:58:29 <solrize_> also a lot of logic, though i'd had some classes in that in school before
21:58:39 <Cale> It seems like some of the more talkative folks have fairly strong mathematics backgrounds. roconnor, ddarius, conal ...
21:59:12 <solrize_> there are more hardcore math people on #logic i think
21:59:39 <pumpkin_> so hardcore I've yet to see anyone say anything in that channel :P
21:59:56 <solrize_> heh
22:00:12 <solrize_> it's all done by ineffable modalities
22:00:13 <Cale> Heh, an IRC channel where people only talk when they have new results.
22:00:15 <moreqwertythanu> lets say I have a general class graph and then want to subclass acyclic and cyclic graphs
22:00:18 <moreqwertythanu> lets say I have a general class graph and then want to subclass acyclic and cyclic graphs
22:00:29 <conal> byorgey: hey, thanks a bunch!  i'm delighted to hear you enjoyed the post.
22:00:29 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
22:00:30 <moreqwertythanu> what would be the haskell way to model something that in OO is generally done with inheritance?
22:00:58 <Cale> moreqwertythanu: What are the operations which only apply to acyclic or cyclic graphs?
22:01:01 <EmielRegis> moreqwertythanu, classes probably :P
22:01:10 <Cale> moreqwertythanu: Are you *sure* you mean classes?
22:01:19 <pumpkin_> it seems like an odd application of them
22:01:24 <Cale> (classes are something different in Haskell than they are in OO)
22:01:42 <pumpkin_> it seems strange to do it with inheritance in an OO language too
22:02:03 <pumpkin_> that would mean that if the graphs were mutable, they could switch type just by adding or removing an edge?
22:02:23 <dons> yeah, there's a mixture of talkative math people , and talkative prog.lang hackers, i guess
22:02:39 <pumpkin_> lots of mathturbation :P
22:02:43 <pumpkin_> sorry
22:02:43 <solrize_> moreqwertythanu type classes are one way, another way could be with phantom types
22:04:03 <conal> moreqwertythanu: sometimes answers in one paradigm (like inheritance in OO) don't translate very clearly to answers in another paradigm (like FP).  you'll probably get more insight if you back up from the OO answer to the question getting answered.  and then ask that question in an FP setting.
22:04:07 <Cale> Yeah, I suppose you could add a type parameter, like  Graph c  and then  Graph Cyclic / Graph Acyclic  would distinguish the two cases. More likely you'd have two plainly separate types for cyclic and acyclic graph representations, and then a class of operations which both implement.
22:05:03 * ddarius has never taken anything beyond Calculus I
22:05:22 <pumpkin_> ddarius: :o
22:05:32 <Cale> ddarius: But you appear to have picked up a lot anyway.
22:06:35 <solrize_> pumpkin_ have you looked at the category wikibook?  it's well worth reading, it was one of those lightbulb moments for me
22:07:01 <pumpkin_> solrize_: nope, where can I find it?
22:07:03 <pumpkin_> @go category wikibook
22:07:07 <lambdabot> http://commons.wikimedia.org/wiki/Category:WikiBook_JavaScript
22:07:11 <pumpkin_> lol
22:07:14 <pumpkin_> @go category theory wikibook
22:07:17 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Category_theory
22:07:21 <solrize_> yes
22:07:22 <solrize_> that one
22:07:38 <pumpkin_> ooh purty pictures
22:07:41 <solrize_> hee
22:08:07 <ddarius> I would say that Haskell has inspired me to look into other things, but I am and was interested in mathematics independently of Haskell.
22:08:10 <QtPlatypus> Is there integral version of ** ?
22:08:16 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
22:08:20 <lambdabot> Title: cache:http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon, ..., http://tinyurl.com/4jav6v
22:08:32 <Cale> ^^ that's a good book for picking up category theory
22:08:36 <ddarius> :t (^^)
22:08:36 <ddarius> :t (^)
22:08:37 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
22:08:38 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
22:08:41 <pumpkin_> Cale: already have that one :) trying to soak up as many books as possible
22:08:49 <pumpkin_> thanks :)
22:08:53 <QtPlatypus> Thanks
22:08:54 <solrize_> looks like it's coming from someone's home DSL :)
22:09:01 <ddarius> pumpkin: I highly recommend the one Cale has suggested.
22:09:01 <Cale> My home DSL.
22:09:08 <Cale> er, cable
22:09:09 <solrize_> cool
22:09:22 <Cale> It's good because it doesn't assume a whole lot.
22:09:29 <Cale> (of the reader)
22:09:44 <Saizan> how do people keep more than one ghc installed on windows?
22:09:49 <solrize_> yeah it's a pretty independent topic, it's just that standalone treatments tend to be unmotivated
22:10:02 <ddarius> Not a book, but I also highly recommend these lecture notes: http://folli.loria.fr/cds/1999/library/pdf/barrwells.pdf
22:10:03 <solrize_> the wikibook is well-grounded
22:10:08 <lambdabot> Title: Category Theory Lecture Notes for ESSLLI Michael Barr Department of Mathematics  ...
22:10:10 <solrize_> in haskell code
22:10:15 <Cale> There's traditionally been a bit of a gap in the literature, because category theory looked at from the usual perspective, is sort of the game you play where the pieces are the branches of mathematics.
22:10:39 <Cale> So most category theory books would already assume you'd at least done a mathematics undergrad, if not more.
22:10:44 <pumpkin_> I hate to keep coming back to this question, but maybe people have a more elegant solution than in the past: I'd like window Int -> Int -> [a] -> [[a]] to slide a window of size (the first parameter) across the third parameter, moving the window by the second parameter every time, and generating a list of these windows (all of which should be the same size)
22:11:00 <ddarius> solrize: In my opinion, the wikibook is mostly useless if you are interested in Category Theory.
22:11:44 <pumpkin_> an arrow is a morphism?
22:11:48 <solrize_> if you want to study it as a real subject, it only scratches the surface, but it was excellent for getting a sense of what it had to do with haskell and type systems
22:11:56 <Cale> pumpkin_: Different words for the same thing.
22:12:01 <Cale> pumpkin_: Let's get rid of that second parameter, because it's easy to pick out the nth element of a list separately.
22:12:01 <pumpkin_> ok
22:12:13 <Cale> nth elements
22:12:28 <pumpkin_> Cale: yeah, I originally had it phrased that way, but given that my lists will be huge, I wanted to avoid computing unnecessary stuff
22:12:39 <pumpkin_> but sure, I'm open to the same problem minus the second parameter
22:12:45 <Cale> You can do something like  map (take k) (tails xs), but that leaves you with some possible shorter lists near the end
22:13:10 <pumpkin_> yeah... I was wondering what the most effective way was to break off those shorter lists
22:13:20 <pumpkin_> without iterating over them
22:13:27 <pumpkin_> especially on an infinite input
22:13:49 <dolio> > let stopAt p f = liftM2 (>>) (guard . p) (return . f) ; slide n k = unfoldr (stopAt null $ take n &&& drop k) in slide 3 2 [1..]
22:13:50 <lambdabot>   []
22:13:56 <Cale> > let xs = [1..10]; k = 3 in zipWith const (map (take k) (tails xs)) (drop (k-1) xs)
22:13:57 <dolio> > let stopAt p f = liftM2 (>>) (guard . not . p) (return . f) ; slide n k = unfoldr (stopAt null $ take n &&& drop k) in slide 3 2 [1..]
22:14:00 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10]]
22:14:02 <lambdabot>   [[1,2,3],[3,4,5],[5,6,7],[7,8,9],[9,10,11],[11,12,13],[13,14,15],[15,16,17]...
22:14:27 <Cale> > let xs = [1..10]; k = 4 in zipWith const (map (take k) (tails xs)) (drop (k-1) xs)
22:14:32 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10]]
22:14:45 <dibblego> @check \x -> (x >= 1) ==> True -- what is wrong with @check ?
22:14:46 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
22:14:46 <lambdabot>           ...
22:15:01 <Cale> The nice thing about this version is that it avoids computing the length of the list.
22:15:04 <pumpkin_> just to make sure, those two are both O(n) ?
22:15:04 <solrize_> these barwell notes look really good too
22:15:13 <pumpkin_> Cale: yeah, that was one thing I wanted to avoid
22:15:22 <Cale> pumpkin_: I can't imagine spending more than O(n) on this.
22:15:35 <pumpkin_> Cale: I dunno, I saw all that fancy stuff from dolio and got scared :P
22:15:47 <Cale> Well, okay, I can imagine something which wasted time on purpose ;)
22:16:14 <pumpkin_> :t const
22:16:15 <lambdabot> forall a b. a -> b -> a
22:16:23 <pumpkin_> @src const
22:16:23 <lambdabot> const x _ = x
22:16:42 <Cale> > zipWith const [1,2,3,4,5] "abc"
22:16:43 <lambdabot>   [1,2,3]
22:16:52 <pumpkin_> aha
22:16:55 <pumpkin_> so it trims it off
22:16:59 <Cale> yep
22:17:53 <pumpkin_> what's a good name for a function that maps over those sliding windows? mapW? :P windowMap?
22:18:45 <Cale> I'd probably just stick with normal map, and separate the window-making function.
22:19:01 <Cale> But I'd go with the latter :)
22:19:03 <pumpkin_> hmm, fair enough
22:19:12 <mmorrow> , let slide n m = fix (\k xs -> if null xs then [] else take n xs : k (drop m xs)) in slide 3 2 [0..20]
22:19:14 <lunabot>  [[0,1,2],[2,3,4],[4,5,6],[6,7,8],[8,9,10],[10,11,12],[12,13,14],[14,15,16...
22:19:19 <dolio> > let stopAt p f = liftM2 (>>) (guard . not . p) (return . f) ; slide n k = unfoldr (stopAt null $ take n &&& drop k) in slide 3 2 [1..10]
22:19:20 <lambdabot>   [[1,2,3],[3,4,5],[5,6,7],[7,8,9],[9,10]]
22:19:26 <mmorrow> , let slide n m = fix (\k xs -> if null xs then [] else take n xs : k (drop m xs)) in slide 3 2 [0..10]
22:19:28 <lunabot>  [[0,1,2],[2,3,4],[4,5,6],[6,7,8],[8,9,10],[10]]
22:19:41 <Cale> mmorrow: leftovers...
22:19:52 <mmorrow> we don't want them?
22:19:56 <dolio> > let stopAt p f = liftM2 (>>) (guard . not . p) (return . f) ; slide n k = unfoldr (stopAt (null . drop (n-1)) $ take n &&& drop k) in slide 3 2 [1..10]
22:19:58 <lambdabot>   [[1,2,3],[3,4,5],[5,6,7],[7,8,9]]
22:20:09 <dolio> > let stopAt p f = liftM2 (>>) (guard . not . p) (return . f) ; slide n k = unfoldr (stopAt (null . drop (n-1)) $ take n &&& drop k) in slide 3 2 [1..11]
22:20:10 <lambdabot>   [[1,2,3],[3,4,5],[5,6,7],[7,8,9],[9,10,11]]
22:20:14 <mmorrow> oh yeah, i remember this problem
22:20:18 <pumpkin_> mmorrow: nope, makes things ugly if I need to do an fft on each of the lists
22:20:27 <pumpkin_> mmorrow: yeah, I've brought it up before :(
22:20:28 <moreqwertythanu> huh what do you call the distance around something in english?
22:20:35 <solrize_> perimeter
22:20:37 <moreqwertythanu> ah
22:20:54 <Cale> Or circumference, particularly in the case of a circle.
22:21:23 <ddarius> pumpkin: You're FFTing lists?
22:21:50 <pumpkin_> ddarius: dunno, haven't gotten that far yet... it doesn't seem like a particularly effective datastructure for the problem, but I don't know of others
22:22:09 <pumpkin_> @hoogle any
22:22:09 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
22:22:09 <lambdabot> Data.ByteString any :: (Word8 -> Bool) -> ByteString -> Bool
22:22:09 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
22:22:42 <ddarius> pumpkin: Arrays would be the obvious data structure to use.
22:22:49 <dons> looks like you're supposed to use unboxed arrays
22:22:52 <dons> http://hackage.haskell.org/packages/archive/fft/0.1.2/doc/html/Math-FFT.html#10
22:22:54 <lambdabot> Title: Math.FFT, http://tinyurl.com/6g4oto
22:22:56 <pumpkin_> oh, I didn't know there were arrays in haskell :P
22:22:59 <solrize_> i guess you could do the recursive step by splitting out the odd and even numbered elements of a list
22:23:08 <solrize_> instead of the bit reversal trick
22:23:09 <dons> pumpkin_: ?
22:23:12 <solrize_> it's sort of more natural
22:23:16 <dons> that's cute, but yes, we have arrays :)
22:23:22 <pumpkin_> yay
22:23:25 <dons> life would be hard without htem
22:23:28 <pumpkin_> I've always been afraid of !!
22:23:30 <dons> we also have libraries
22:23:30 <thoughtpolice> WE HAVE WAY TOO MANY ARRAY LIBRARIES, I SAY
22:23:36 <dons> TOO MANY!!
22:23:36 <ddarius> thoughtpolice: We do.
22:23:39 <dons> TAKE SOME AWAY
22:23:55 <dons> the fftw binding uses carray, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/carray-0.1.3
22:23:56 <lambdabot> Title: HackageDB: carray-0.1.3, http://tinyurl.com/5wzltu
22:23:59 <thoughtpolice> MERRRRGE!!
22:24:04 <ddarius> Unfortunately, the only one that immediately jumps out as one to take away is the standard ones.
22:24:28 <mmorrow> let slide n m = let go n m xs = take' [] n xs : go n m (drop m xs) in takeWhile (not . null) . go n m in slide 3 2 [0..10]
22:24:29 <mmorrow> , let slide n m = let go n m xs = take' [] n xs : go n m (drop m xs) in takeWhile (not . null) . go n m in slide 3 2 [0..10]
22:24:31 <pumpkin_> dons: sorry, in retrospect it does sound rather stupid :P
22:24:31 <lunabot>  luna: Not in scope: `take''
22:24:35 <dons> pumpkin_: heh
22:24:45 <mmorrow> , let slide n m = let take' acc 0 _ = reverse acc; take' acc n [] | n /= 0 = []; take' acc n (x:xs) = take' (x:acc) (n-1) xs; go n m xs = take' [] n xs : go n m (drop m xs) in takeWhile (not . null) . go n m in slide 3 2 [0..10]
22:24:46 <pumpkin_> I just couldn't see how one would implement them in haskell
22:24:47 <lunabot>  [[0,1,2],[2,3,4],[4,5,6],[6,7,8],[8,9,10]]
22:24:50 <pumpkin_> or functionally
22:24:53 <mmorrow> @let take' acc 0 _ = reverse acc; take' acc n [] | n /= 0 = []; take' acc n (x:xs) = take' (x:acc) (n-1) xs
22:24:54 <lambdabot>  Defined.
22:25:02 <mmorrow> , let slide n m = let go n m xs = take' [] n xs : go n m (drop m xs) in takeWhile (not . null) . go n m in slide 3 2 [0..10]
22:25:04 <dons> as long as our memory chips are flat arrays, we'll probably have array libraries
22:25:04 <lunabot>  luna: Not in scope: `take''
22:25:08 <mmorrow> > let slide n m = let go n m xs = take' [] n xs : go n m (drop m xs) in takeWhile (not . null) . go n m in slide 3 2 [0..10]
22:25:09 <lambdabot>   [[0,1,2],[2,3,4],[4,5,6],[6,7,8],[8,9,10]]
22:25:21 <dons> if we move to the cray xmt, we can use IntMap
22:25:39 <pumpkin_> dons: but they aren't implemented in pure haskell? when I started I was trying to figure out how I'd achieve O(1) access and couldn't think of any way, so assumed it wasn't the way to go about things
22:26:01 <dons> pumpkin_: there's pure haskell arrays. see Data.Array in the arrays package (and many others)
22:26:12 <dons> the 'carray' i think just aim to be compatible with the layout of C arrays
22:26:18 <pumpkin_> thanks, will check
22:26:18 <dons> but are nonetheless pure haskell
22:26:20 <ddarius> pumpkin: Ints are "implemented" in pure Haskell either.
22:26:24 <moreqwertythanu> whats the difference between the type a and the type t?
22:26:33 <dons> moreqwertythanu: nothing? they're alpha-equivalent
22:26:36 <mmorrow> pumpkin_: oh, did you say fft? i wrote a super simple/short fft you may find useful
22:26:44 <jsn> moreqwertythanu: context please?
22:26:46 <Cale> moreqwertythanu: They're different variables, but on their own they'd be the same thing.
22:26:58 <mmorrow> http://hackage.haskell.org/packages/archive/pure-fft/0.1.0/doc/html/src/Numeric-FFT.html
22:27:00 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5s8akm
22:27:00 <pumpkin_> mmorrow: ooh, yeah :) I was just going to use the fftw bindings but I like staying in pure haskell
22:27:15 <mmorrow> that could be made /much/ faster without much effort
22:27:33 <moreqwertythanu> Cale/jsn: when i let ghci derive th types for me, like :t perimeter and :t area
22:27:43 <mmorrow> my first go was for simplicity and brevity
22:28:05 <ddarius> If you care about performance, you really, really don't want to use linked lists.
22:28:07 <Cale> moreqwertythanu: It draws variables from a supply as it typechecks, and might pick different letters.
22:28:32 <mmorrow> in particular, this can be done in one pass (and i have the mod code here on my laptop): k <  len  = (xs!!k) + (ys!!k) * f k (len*2)
22:28:34 <pumpkin_> ddarius: yeah, I didn't think so :) but mmorrow's one looks so pretty
22:28:52 <mmorrow> ddarius: yeah, clearly :)
22:29:04 <mmorrow> mine should be extendable to arrays pretty simply
22:29:19 <pumpkin_> of course, the regular dft code is even prettier, so maybe I'll just go with n^2 and wait around longer :P
22:29:56 <mmorrow> and it's respectably fast for what it is (namely an fft with linked lists)
22:30:01 <jsn> moreqwertythanu: so basically when you see a signature with a 't' and an 'a' in it, that means, they type inferencer can not prove they are a particular concrete type, nor can it prove they are the same type
22:30:14 <mmorrow>  /and/, it is O(n lg n) nonetheless
22:30:35 <pumpkin_> mmorrow: those !! don't affect it?
22:30:52 <mmorrow> pumpkin_: no, and like i said they aren't needed
22:30:59 <mmorrow> i'll paste the code that doeszn't use them
22:31:22 <mmorrow> i really should update pure-fft as well..
22:31:23 <dons> pumpkin_: yeah, you shouldn't really use !!  -- its O(n), so either use a listy algo, or switch to some structure where indexing is cheaper
22:32:20 <roconnor> maybe <<< is better notation for compose than ∘
22:32:29 <roconnor> ∘ kinda crappy notation
22:32:34 <roconnor> *is
22:32:48 <pumpkin_> I think it comes from f \cdot g in math?
22:32:49 <solrize_> `o`
22:33:34 <roconnor> right, I'm saying the math notation is poor
22:33:43 <solrize_> let o = (.); f= sqrt `o` (*7) in f 5
22:33:52 <solrize_> > let o = (.); f= sqrt `o` (*7) in f 5
22:33:53 <lambdabot>   5.916079783099616
22:34:05 <solrize_> > sqrt(35)
22:34:06 <lambdabot>   5.916079783099616
22:34:07 <solrize_> whee
22:34:27 <Cale> roconnor: I would hate to have to *write* <<< by hand ;)
22:34:43 <roconnor> if you were to reinvent math notaion, something a little more arrow oriented, such as  <<< or <-< or something would be better.
22:34:50 <Cale> Juxtaposition is nicer
22:35:02 <Cale> (for composition)
22:35:13 <roconnor> not bad
22:35:27 <roconnor> what would apply be?  f(x) ?
22:35:43 <ddarius> Or be like CT and use juxtaposition for both application and composition ambiguously !
22:35:44 <Cale> Depends, but sure.
22:35:53 <mmorrow> dons: using (!!) isn't needed
22:35:54 <Cale> Or unambiguously ;)
22:36:09 <Cale> If elements are arrows 1 -> A, then composition and application are the same thing.
22:36:11 <roconnor> f@x
22:36:18 <dolio> That's because "application is a special case of composition".
22:36:23 <roconnor> 1 -> A is fine if you are in a CCC
22:36:34 <roconnor> but if you are in a CCC, you might as well use lambda calculus
22:36:37 <ddarius> Cale: I'm talking about the notation for functors.
22:36:42 <roconnor> er
22:36:46 <roconnor> 1 -> A is fine if you are /not/ in a CCC
22:37:02 <Cale> Of course, you might have something like the category of groups, and want to talk about the action of a morphism on an element of a group.
22:38:10 <ddarius> D Lan_J D
22:38:35 <mmorrow> pumpkin_: here's the better version of fft http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=515#a515
22:38:42 <roconnor> well, different notations for different domains may be appropriate
22:38:51 <solrize_> cale what is an initial algebra?
22:38:58 <ddarius> roconnor: "may"?
22:39:11 <Cale> solrize_: Well, do you know what an F-algebra is?
22:39:16 <solrize_> no
22:39:52 <roconnor> ddarius: haskell doesn't have extensible support for domain languages.  It has, what, 3 languges?
22:40:02 <roconnor> lambda calc, do notation, and list comprehensions.
22:40:08 <Cale> solrize_: Okay, so is F is a functor C -> C, then an F-algebra is an object A of C together with a morphism f: FA -> A
22:40:26 <roconnor> I guess proc notation too
22:40:28 <mmorrow> pumpkin_: ooh, just realized the use of `length' in there should only be done once, then explicitly passed and updated..
22:40:29 <roconnor> sort of
22:40:41 <Cale> solrize_: Does that definition (at least technically) make sense?
22:40:43 <mmorrow> pumpkin_: s/should/could/
22:40:51 <solrize_> cale i'm still parsing it
22:41:06 <ddarius> roconnor: I thought you were talking more generally than Haskell, though my implicit statement still stands.
22:41:11 <pumpkin_> thanks mmorrow
22:41:19 <mmorrow> pumpkin_: np
22:41:48 <Cale> So for instance, let's say C is the Haskell types category, and F is the functor Tree
22:42:04 <solrize_> cale, ok, so F could be something like List, and a F-algebra would be something like (Int, f :: [Int] -> Int)
22:42:21 <Cale> yeah
22:42:21 <roconnor> ddarius: s/may/almost certainly/
22:42:30 <solrize_> ok
22:42:38 <roconnor> ddarius: I suppose it could be possible there is one language to rule them all.
22:42:52 <solrize_> ok
22:43:08 <Cale> It's not a particular Int, mind you.
22:43:14 <solrize_> right
22:43:25 <Cale> I mean the type Int, together with such a function.
22:43:31 <solrize_> right, got that
22:44:08 <solrize_> the function goes from the functor action back to the original type
22:44:47 <Cale> Okay, and if f: FA -> A and g: FB -> B are two F-algebras, then a morphism of F-algebras between them is a function u: A -> B such that u . f = g . Fu
22:45:06 <Cale> Here, Fu is fmap u in Haskell-notation.
22:45:11 <moreqwertythanu> so like with shape before?
22:46:12 <Cale> It would help to actually draw that commutative square.
22:46:23 <solrize_>  cale ok i think i can see that on ground types
22:46:28 <Cale> http://en.wikipedia.org/wiki/Image:Commutative_diagram_defining_F-algebra.png
22:46:31 <lambdabot> http://tinyurl.com/6elozk
22:46:43 <solrize_> cool
22:46:58 <dancor> is there a version of (.&.) that works just on Int
22:47:04 <dancor> :t (.&.)
22:47:05 <lambdabot>     Ambiguous occurrence `.&.'
22:47:05 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
22:47:05 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
22:47:10 <dancor> :t xor
22:47:11 <lambdabot> forall a. (Bits a) => a -> a -> a
22:47:37 <dancor> oh there's a Bits Int instance
22:47:47 <ddarius> :t let bitwiseAnd :: Int -> Int -> Int; bitwiseAnd = (Data.Bits..&.) in bitwiseAnd
22:47:48 <lambdabot> Int -> Int -> Int
22:47:49 <dancor> my mind is going, i can feel it
22:47:53 <mmorrow> , 1 .&. (2::Int)
22:47:56 <lunabot>  0
22:47:59 <Cale> okay, so now, an initial F-algebra 0: FA -> A is one such that for *any other* F-algebra f: FB -> B, there's a *unique* F-algebra morphism u: A -> B
22:48:04 <solrize_> in that diagram all the labels are a bit different, u is labelled f, etc
22:48:05 * shapr feels dancor's mind
22:48:16 <Cale> solrize_: yes, I apologise for that
22:48:21 <solrize_> it's ok
22:48:24 <ddarius> dancor: Now you know where it has gone.
22:48:34 <shapr> :-)
22:48:42 <dancor> i need that back!  i think..
22:49:01 <dolio> Dude, you should call it cata_F
22:49:06 <dolio> Er, cata_f
22:49:09 * shapr grins
22:49:10 <Cale> So, it will help to see what this looks like.
22:49:17 <Cale> In a particular case :)
22:49:39 <solrize_> i'm trying to see why it can be unique, e.g. suppose A and B are both Float
22:49:55 <ddarius> It's unique by definition.
22:49:56 <solrize_> or maybe A is Int and B is Float
22:50:00 <Cale> A will be something special, generally.
22:50:21 <Cale> In fact, moreso than the morphism, it's usually what you're after.
22:50:52 <solrize_> i think i gotta work this out with diagrams.  is it in the book that you put up?
22:50:56 <Cale> Let's look at a Maybe-algebra
22:50:58 * ddarius prefers the representability approach which encodes the unique existence as a function.
22:51:00 <solrize_> ok
22:52:06 <Cale> Let Nat be the type of natural numbers:  data Nat = Zero | Succ !Nat
22:52:14 <solrize_> ok
22:52:38 <Cale> and the function   f Nothing = Zero; f (Just n) = Succ n
22:52:51 <solrize_> ok
22:52:51 <ksf> cool, fog. I can barely see the ground out of the 10th floor.
22:53:04 <Cale> This one is in fact initial.
22:53:46 * shapr reads up on initial algebras
22:54:08 <solrize_> f :: Maybe Nat -> Nat
22:54:16 <Cale> right
22:54:22 <solrize_> u :: ?
22:54:48 <Cale> Suppose we have any other type T and function g: Maybe T -> T, we want to see that there's a unique map  Nat -> T  which will make the square commute.
22:55:02 <solrize_> ok
22:55:24 <solrize_> g . Just
22:55:46 <solrize_> (g . Just) :: Nat -> T
22:55:49 <Saizan> ddarius: do you have a reference for a definition in that style? (if i'm understanding your comment correctly)
22:56:00 <Cale> solrize_: are you certain?
22:56:05 <solrize_> hmm
22:56:09 <Cale> (I don't think that typechecks...)
22:56:40 <ddarius> Saizan: For initial algebras in particular or in general?
22:56:55 <ksf> cool, algebraic fog. I can barely see the code from over here.
22:57:10 <moreqwertythanu> whatis the function for map-map? mapping the maps of a [[]]
22:57:14 <moreqwertythanu> [[a]]
22:57:22 <Cale> We want our function u: Nat -> T so that u . f = g . fmap u
22:57:30 <Saizan> ddarius: the former
22:57:34 <Cale> :t map . map
22:57:36 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
22:58:18 <Cale> u . f :: Maybe Nat -> T
22:58:37 <Cale> So let's look at this by cases, and see if we can work out where things have to go.
22:58:49 <solrize_> right i was looking at that, u . f takes Maybe Nat
22:59:14 <moreqwertythanu> trnsps xs = map (\i -> map (\x -> x !! i) xs) [0..length xs-1]
22:59:16 <Cale> (u . f) Nothing = u Zero
22:59:25 <moreqwertythanu> is that the best transpose possible?
22:59:42 <pumpkin_> @src transpose
22:59:43 <lambdabot> transpose []             = []
22:59:43 <lambdabot> transpose ([]   : xss)   = transpose xss
22:59:43 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
22:59:44 <Cale> (g . fmap u) Nothing = g Nothing
22:59:56 <solrize_> ok
23:00:00 <Cale> So u Zero must be g Nothing
23:00:30 <Cale> See how that works?
23:00:32 <ddarius> Saizan: I believe one of Fokkinga's papers uses that approach as the primitive definition, but they all end up with that function anyway.
23:00:38 <Cale> So we already have one of the cases for our u :)
23:00:42 <solrize_> u (succ n) = g (Just n)
23:00:44 <moreqwertythanu> i want some sort of map-in there
23:00:54 <moreqwertythanu> wait it is not correct
23:00:55 <Cale> Indeed :)
23:01:02 <solrize_> i'm out of registers :)
23:01:34 <Cale> and that's the *only* way we could get such a commutative diagram
23:01:44 <Cale> So Nat is somehow "special" with respect to Maybe here.
23:01:51 <Cale> It's the initial Maybe algebra.
23:02:04 <Cale> (There's a theorem which shows that any two initial F-algebras are isomorphic)
23:02:11 <solrize_> hmmmm
23:02:30 <Cale> (hint: there's a unique F-algebra morphism between them either way)
23:02:38 <pumpkin_> @type Boolean
23:02:39 <lambdabot> Not in scope: data constructor `Boolean'
23:02:45 <solrize_> so every functor has a unique type that makes that diagram commute?
23:02:45 <pumpkin_> :t True
23:02:46 <lambdabot> Bool
23:02:49 <pumpkin_> @type Bool
23:02:50 <lambdabot> Not in scope: data constructor `Bool'
23:02:58 <Cale> solrize_: Well, not necessarily *any* functor.
23:03:06 <pumpkin_> is Bool a Num?
23:03:22 <Cale> pumpkin_: no
23:03:30 <pumpkin_> that's nice
23:03:51 <Cale> pumpkin_: Of course, you could make it one.
23:04:00 <pumpkin_> oh I don't want it to be
23:04:07 <pumpkin_> was just curious
23:04:33 <solrize_> what about List ?
23:05:58 <Cale> solrize_: Well, strict lists with elements of type a would be the initial F-algebra for the functor Either a
23:06:20 <solrize_> i mean what is the initial algebra for the List functor?
23:06:22 <Cale> er, no
23:06:28 <Cale> (duh)
23:06:47 <dolio> Either () (a, -)
23:06:48 <Cale> data List' a t = Empty | One a t
23:06:56 <Cale> yes
23:07:16 <ddarius> Saizan: His "A Gentle Introduction to Category Theory -- the calculational approach" and maybe also "Calculate categorically!"
23:07:27 <Cale> So (List' a) would be the appropriate functor here.
23:07:59 <Cale> Another way to write that in more categorical notation is  F X = 1 + A×X
23:08:21 <dons> element and tail strict?
23:08:40 <dons> ah. spine only. why don't we have those?
23:08:40 <Cale> tail strict...
23:09:02 <ddarius> solrize: The initial algebra for the actual list functor would be a rose tree.
23:09:03 <Cale> So a way to look at this is that you're finding the smallest type which is the fixed point of the functor.
23:09:04 <dons> it's curious. but all those list operations
23:09:12 <Cale> *a* fixed point
23:09:14 <solrize_> where  does strictness come in?
23:09:22 <dons> solrize_: removing bottom values
23:09:33 <Cale> For example, Maybe Nat is isomorphic to Nat
23:09:39 <AnalogHole> How do I make the result of a function that is an Int into a Double so that I can divide with it?   Like: (length [1..6]) / 6000
23:09:41 <solrize_> hmm
23:09:48 <dons> AnalogHole: fromIntegral
23:09:55 <Cale> and F (List a) is isomorphic to List a
23:09:58 <dons> in this case, you could use Data.List.genericLength
23:10:10 <Cale> In Haskell, we usually take the *greatest* fixed point though.
23:10:21 <Cale> When we form recursive types.
23:10:39 <Cale> (and we use terminal F-coalgebras)
23:10:41 <ddarius> Cale: The least and greatest fixpoint coincide, there is no intentional taking of the greatest fixed point.
23:10:46 <Saizan> ddarius: thanks
23:11:02 <ddarius> Saizan: I don't quite like the way he presents it, but it is the same idea.
23:11:09 <Cale> ddarius: Even when you allow for strictness annotations in types?
23:11:22 <QtPlatypus> Why doesn't this type correctly? middledex i = (length i)/2
23:11:35 <hackage> Uploaded to hackage: hake 1.0
23:11:35 <hackage> Uploaded to hackage: yjtools 0.9.6
23:12:01 <ddarius> Cale:  Yes.  They coincide in a strict (Turing complete) language as well.
23:12:07 <solrize_> ok, so the fixed point of Maybe is Maybe (Maybe (Maybe (... ))) which is isomorphic to Nat
23:12:15 <Cale> solrize_: yeah
23:12:15 <ddarius> solrize: Correct.
23:12:44 <Cale> ddarius: Well, it seems that  data Nat' = Zero' | Succ' !Nat' has one fewer element than  data Nat = Zero | Succ Nat
23:12:47 <ddarius> solrize: I highly recommend the exercise Cale suggested (Lambek's lemma).
23:13:01 <solrize_> what exercise is that?
23:13:06 <ddarius> Cale: Yes, and it's underlying functor is different.
23:13:21 <Cale> ddarius: hmm, I'll have to think about that. :)
23:13:23 <dolio> More than one.
23:13:27 <ddarius> solrize:  Prove that if X is the initial F-algebra, then FX ~ X.
23:14:22 <solrize_> ok
23:14:58 <solrize_> ~ means isomorphism?
23:15:17 <ddarius> Yes.
23:16:14 <ddarius> And I guess he didn't suggest it,  I misread something he'd said, but it's still an interesting and relatively easy exercise.
23:16:33 <pumpkin_> (the question I'm sure you all knew I was going to ask) how do I get from a list to a CArray?
23:16:38 <Cale> It would seem to me that the initial F-algebra for FX = 1 + A×X would be finite lists of elements of A, and the terminal F coalgebra would be finite or infinite lists.
23:17:05 <Cale> But it could be something strange about the category of Haskell types which makes that not so.
23:17:24 <solrize_> i'm going to have to start from those definitions again which are scrolled off my screen by now, preferably after i've gotten some sleep :)
23:18:12 <solrize_> what's A×X ?  is that a product type (A,X) ?
23:18:16 <Cale> yeah
23:19:10 <Saizan> ?tyoe listArray
23:19:12 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
23:19:29 <solrize_> is the idea here to take some recursive type like List or Tree, and turn it back into something nonrecursive with a fixed point functor?
23:19:41 <Saizan> pumpkin_: look at Data.Array.IArray
23:21:01 <Saizan> solrize: yeah, and you get a "foldr" for free
23:21:58 <ddarius> Cale: Is foldr the actual unique morphism induced by the underlying functor of []?  Yes, so it must be an initial algebra (as well.)
23:22:31 <pumpkin_> Saizan: nice, that works
23:26:51 <ddarius> Cale: Possibly I'm wrong, but that is the primary thing that is needed to prove or disprove the statement.
23:30:16 <ddarius> The strange thing about about Haskell is that it's not a total language.
23:32:17 <roconnor> ping
23:32:51 <Saizan> about fixpoints there's a theorem saying that you can get the greatest fixpoint of a monotonic f by f(f(..(f(Top))), does that apply here? with which Top?
23:34:16 <dons> some fun questions from Belka on -cafe@
23:34:32 <dons> anyone want to have a go at the N inputs 1 output -- FP fails mail?
23:34:43 <solrize_> re, i was afk for a minute
23:35:11 <ddarius> Saizan: The lattices used in language semantics tend not to have top elements.
23:36:49 <Saizan> ddarius: nice to have that confirmed :)
23:39:37 <ksf> QtPlatypus, Integral/Rational mixup? see fromIntegral.
23:39:43 <ksf> :t fromIntegral
23:39:44 <lambdabot> forall a b. (Num b, Integral a) => a -> b
23:39:53 <ksf> or
23:39:55 <ksf> :t div
23:39:57 <lambdabot> forall a. (Integral a) => a -> a -> a
23:41:15 <Saizan> ?seen QtPlatypus
23:41:16 <lambdabot> QtPlatypus is in #haskell. I last heard QtPlatypus speak 27m 11s ago.
23:41:48 <moreqwertythanu> ddarius: total language?
23:42:10 <ddarius> @google "Total Functional Programming"
23:42:13 <lambdabot> http://lambda-the-ultimate.org/node/2003
23:42:13 <lambdabot> Title: Total Functional Programming | Lambda the Ultimate
23:43:17 <Saizan> moreqwertythanu: a language where each function is total, like mathematical functions which are defined for all the inputs in the domain
23:45:18 <moreqwertythanu> hmm
23:45:27 <moreqwertythanu> inputs in the domain?
23:45:54 <pumpkin_> all possible values of the domain
23:46:21 <Saizan> in such a language you couldn't write e.g. head
23:46:23 <Saizan> since:
23:46:28 <Saizan> > head []
23:46:30 <lambdabot>   * Exception: Prelude.head: empty list
23:46:43 <pumpkin_> well, you could define it as something couldn't you?
23:46:59 <Saizan> as head :: [a] -> Maybe a
23:46:59 * ksf thinks head should have type [a] -> Maybe a, anyway.
23:46:59 <pumpkin_> I guess you'd need to find a suitable definition that didn't break other assumptions about it
23:47:07 <ksf> call the current one unsafeHead
23:47:23 * Saizan nods
23:47:38 <ddarius> ksf: That doesn't make much sense.
23:47:59 <ksf> what, making haskell safer?
23:48:00 <Saizan> head :: [a] -> Maybe a is kind of useless
23:48:21 <ddarius> It's not completely useless, but you wouldn't use it any of the places you'd use head now.
23:48:28 <ddarius> :t listToMaybe
23:48:29 <lambdabot> forall a. [a] -> Maybe a
23:48:36 <ksf> I don't use head, anyway, I use pattern matching...
23:48:38 <pumpkin_> @src listToMaybe
23:48:39 <lambdabot> listToMaybe []        =  Nothing
23:48:39 <lambdabot> listToMaybe (a:_)     =  Just a
23:48:42 <ddarius> ksf: Exactly.
23:49:05 <Saizan> so, remove head from the Prelude?:)
23:49:10 <ksf> yes.
23:49:11 <Saizan> along with error
23:49:13 <pumpkin_> decapitate it!
23:49:19 <dolio> You could use safeHead with maybe.
23:49:24 <dolio> But then, you could use foldr.
23:49:27 <ksf> error is fine, but should annotate with source line.
23:49:42 <ksf> Debug.trace, too.
23:51:15 <solrize_> head returning Maybe a just leaves you with the problem of dealing with the unexpected Nothing case
23:51:27 <solrize_> safeHead is a standard gadt example
23:51:36 <solrize_> that catches head [] at compile time
23:52:03 <ksf> I'm fine with that.
23:52:08 <solrize_> but, if you wanted total haskell, you'd have to make all floating point arithmetic returns maybes since the could have overflow
23:52:25 <leadnose> is it something like safeHead (x:xs) = x ?
23:52:25 <solrize_> also division in any fractional type could divide by zero
23:52:27 <Saizan> ksf: the problem is that most of the time you don't want the source loc. of the function defined by error but rather where it's called, or better a "stacktrace"
23:52:30 <solrize_> every io operatoin could fail
23:52:42 <pumpkin_> :t safeHead
23:52:43 <lambdabot> Not in scope: `safeHead'
23:53:03 <ksf> I bet exceptions fit into a total language.
23:53:10 <solrize_> pumpkin see the haskell wikibook about gadt's for safehead
23:53:10 <Saizan> solrize_: IO has exceptions that are much better to deal with
23:53:37 <solrize_> exceptions are bottoms, i thought
23:53:44 <solrize_> therefore non-total
23:53:55 <ksf> exceptions are continuations for bankrupt people.
23:54:07 <pumpkin_> :)
23:54:16 <moreqwertythanu> can i do repeat?
23:54:29 <ksf> you can do fold.
23:54:43 <ksf> that is, yes.
23:54:47 <ksf> :t replicate
23:54:49 <lambdabot> forall a. Int -> a -> [a]
23:55:01 <Saizan> solrize: the non-totality is an effect of the monad there
23:55:04 <ksf> @src replicate
23:55:05 <lambdabot> replicate n x = take n (repeat x)
23:55:10 <ksf> :t repeat
23:55:12 <lambdabot> forall a. a -> [a]
23:55:13 <ksf> (duh)
23:55:18 <ksf> @src repeat
23:55:19 <lambdabot> repeat x = xs where xs = x : xs
23:55:52 <Saizan> solrize: there's a big difference between (undefined :: Int) and (throwError "foo" :: IO Int)
23:56:25 <ksf> you can do a takeUntil :: (a -> Bool) -> [a] -> [a] and then tape everything together.
23:56:49 <ksf> but generally, you want to use recursion.
23:58:32 <Saizan> from the pov of total languages haskell is not pure enough :)
23:58:45 <ksf> yeah. in that context, _|_ doesn't mean "oops" but "I don't care"
23:59:08 <ksf> or, rather "<jedi>you don't care about my type, for you are not</jedi>"
23:59:28 <solrize_> > (throwError "foo" :: IO Int) >>= print
23:59:29 <lambdabot>   Couldn't match expected type `[Char]'
23:59:49 <Saizan> ?type ioError
23:59:51 <lambdabot> forall a. IOError -> IO a
23:59:55 <ksf> > (throwError "foo" ) >>= print "bar"
23:59:57 <lambdabot>   Couldn't match expected type `a -> m b'
