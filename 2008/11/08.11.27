00:02:25 <solrize> is there some way to reverse an Ordering?   i.e. something like negate but turns LT into GT and vice versa
00:02:32 <solrize> i.e. i want to sort some stuff in reverse order
00:02:41 <Lemmih> solrize: flip?
00:02:42 <dons> > reverse [LT ..]
00:02:44 <lambdabot>   [GT,EQ,LT]
00:03:04 <solrize> lemmih, hmm
00:03:07 <Lemmih> > sortBy (flip compare) [1..10]
00:03:08 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
00:03:15 <solrize> yeah, thanks
00:04:37 <ddarius> > let flipOrdering = flip compare in map flipOrdering [LT ..]
00:04:38 <lambdabot>       Overlapping instances for Show (Ordering -> Ordering)
00:04:38 <lambdabot>        arising fr...
00:04:59 <ddarius> > let flipOrdering = flip compare EQ in map flipOrdering [LT ..]
00:05:00 <lambdabot>   [LT,EQ,GT]
00:05:18 <Lemmih> > id [LT ..]
00:05:20 <lambdabot>   [LT,EQ,GT]
00:05:32 <ddarius> > let flipOrdering = compare EQ in map flipOrdering [LT ..]
00:05:33 <lambdabot>   [GT,EQ,LT]
00:06:29 <BMeph> :t ap (*)
00:06:30 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
00:07:32 <BMeph> ddarius: Wasn't there a -cafe discussion on that topic - - they called it Down, IIRC. :)
00:22:48 <RayNbow> > sortWith Down [1..10]
00:22:49 <lambdabot>   Not in scope: `sortWith'Not in scope: data constructor `Down'
00:22:54 <MikeMayer> ok I'm not getting anywhere with this... :/
00:22:55 <MikeMayer> http://hpaste.org/12428
00:23:17 <RayNbow> hmm, lambdabot doesn't have GHC.Exts.sortWith  and GHC.Exts.Down?
00:23:26 <grom358> ? fmap
00:23:54 <grom358> is there a good book that explains what the standard libraries functions do?
00:24:57 <RayNbow> MikeMayer: you got the type right, but not the function arguments in the definition
00:25:45 <MikeMayer> :RayNbow I've been changing the definition a lot but haven't really found anything i'm looking for
00:27:02 <RayNbow> prepend xs a = a : xs    -- MikeMayer, here's an example
00:27:09 <dons> grom358: the haskell98 report?
00:27:14 <dons> grom358: or otherwise the online docs
00:27:15 <RayNbow> prepend :: [Int] -> Int -> Int
00:27:17 <dons> ?docs Data.List
00:27:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
00:27:59 <MikeMayer> hmm
00:28:37 <MikeMayer> xs is some kind of keyword?
00:28:42 <RayNbow> no, it's just a name
00:29:05 <RayNbow> functionNameHere <here your function arguments (variables)> = <here some expression using the arguments>
00:30:19 <RayNbow> int myfunction(<here your function arguments>) { <here some code using the arguments>; } // in a C-style language
00:30:31 <MikeMayer> :RayNbow hmmmmmm
00:33:30 <RayNbow> MikeMayer: do you know what patterns are?
00:34:22 <MikeMayer> :RayNbow my understanding thus far is that it is the constraints that the function uses to evaluate?
00:35:00 <grom358> dons: yeah I looked at it.. all it says is fmap              :: (a -> b) -> f a -> f b ; but I don't really get what that means
00:35:09 <Stephan202> @src flip (:)
00:35:09 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:35:14 <Stephan202> :t flip (:)
00:35:15 <lambdabot> forall a. [a] -> a -> [a]
00:35:47 <RayNbow> MikeMayer: well, in mainstream imperative languages, the formal parameters of a function (i.e. the function's arguments) are only allowed to be variables (=names)
00:36:09 <MikeMayer> right
00:36:16 <RayNbow> in Haskell, however, you could also use patterns instead of a variable (=name)
00:37:15 <MikeMayer> okay
00:37:26 <RayNbow> fac n = if n == 0 then 1 else n * fac (n-1)    -- example of factorial
00:37:47 <MikeMayer> a body of an expression is the variable kinda
00:38:02 <Cale> grom358: It means that fmap takes a function from a's to b's, and an f of a's and gives an f of b's. Here f can be an arbitrary data structure.
00:38:22 <RayNbow> different version of factorial using patterns:
00:38:23 <RayNbow> fac2 0 = 1
00:38:23 <RayNbow> fac2 n = n * fac2 (n-1)
00:38:25 <Cale> grom358: For example, it might be a kind of tree.
00:38:51 <Cale> > fmap (+1) (Just 4)
00:38:52 <lambdabot>   Just 5
00:38:56 <Cale> > fmap (+1) [1,2,3]
00:38:57 <lambdabot>   [2,3,4]
00:39:11 <RayNbow> MikeMayer: in fac2, I have two definitions... in the first one the argument is matched against the pattern 0... if it matches, then that definition is used
00:39:22 <Cale> > (fmap (+1) length) "hello"
00:39:23 <lambdabot>   6
00:39:29 <RayNbow> if it doesn't match, Haskell tries the other definition(s)
00:39:59 <Cale> :t fmap (+1) readLn
00:40:00 <lambdabot> forall a. (Read a, Num a) => IO a
00:40:14 <MikeMayer> I see kind of like overloading the function
00:40:45 <polveroj> MikeMayer: kind of, except you're matching on possible values instead of types
00:40:47 <RayNbow> MikeMayer: kind of... except in mainstream imperative languages, you overload on types, not on values
00:40:52 <RayNbow> what polveroj says :p
00:41:03 * RayNbow should type faster :p
00:41:11 <Cale> MikeMayer: Well, multiple cases are translated into a single definition which uses a case expression to take apart the value.
00:41:26 <Cale> For instance,
00:41:29 <Cale> length [] = 0
00:41:33 <Cale> length (x:xs) = 1 + length xs
00:41:40 <Cale> Can be translated into:
00:41:53 <Cale> length xs = case xs of [] -> 0; (y:ys) -> 1 + length ys
00:42:06 <MikeMayer> base case for the recursion
00:42:07 <MikeMayer> oh I see
00:42:14 <MikeMayer> hmm
00:42:21 <RayNbow> [] <-- the pattern (or value) of an empty list
00:42:26 <Cale> case expressions are the primitive for pattern matching against values.
00:42:34 <grom358> Cale: okay I can see what its doing.. the f a part confused me.. sort of still is although I see what fmap does
00:42:38 <MikeMayer> gosh I swear there must be something really simple I'm just not getting
00:42:46 <RayNbow> (x:xs) <-- the pattern of a non-empty list, with x being the name of the head and xs being the tail
00:42:55 <RayNbow> (note that x and xs are arbitrary names)
00:43:21 <Cale> MikeMayer: Another way to look at it is that there are just two equations here, and only one of them is going to apply because a list is either empty, or it isn't.
00:43:22 <RayNbow> (theHeadOfTheList:theTailOfTheList)  <-- this is also a fine pattern, but a bit verbose :p
00:44:01 <MikeMayer> Cale: I see
00:44:21 <RayNbow> (in Haskell, we usually use (x:xs), (y:ys), (a:as), (b:bs), etc., for non-empty list patterns)
00:44:32 <MikeMayer> here's a different kind of question...
00:44:51 <MikeMayer> since I have to define all my functions for this assignment in a single file and I'd like to have a way to test it...
00:45:06 <MikeMayer> couldn't I do : main = print insert ([2, 4, 6, 8], 5)
00:45:24 <Cale> MikeMayer: You'll need another pair of parens there.
00:45:40 <Cale> MikeMayer: But usually to test things out, we'll load the file into ghci, and then type some expressions.
00:45:58 <Stephan202> main = do printStrLn $ show $ insert ([2, 4, 6, 8], 5)
00:46:10 <Stephan202> ...
00:46:15 <Stephan202> main = do putStrLn $ show $ insert ([2, 4, 6, 8], 5)
00:46:43 <Stephan202> (and other tests of the form "putStrLn ..." should be aligned immediately below that)
00:47:01 <MikeMayer> :Stephan202 the compiler gives me the same error with that
00:47:32 <Cale> main = print (insert [2,4,6,8] 5)
00:47:38 <MikeMayer> http://hpaste.org/12429
00:47:57 <Cale> Also, multiple $'s is bad style ;P
00:48:11 <Cale> MikeMayer: right
00:48:22 <Cale> The parameters to a function are separated by spaces
00:48:27 <Stephan202> MikeMayer: there shouldn't be parens for insert
00:48:35 <BeelsebobWork> ew, why is insert uncurried?
00:48:41 <grom358> Cale: oh.. the f is a placeholder.. so Functor Tree, fmap :: (a -> b) -> Tree a -> Tree b.. is that right?
00:48:46 <Cale> BeelsebobWork: That's the type error
00:48:50 <BeelsebobWork> oh, I see
00:48:51 <Cale> grom358: yes
00:49:29 <grom358> (fmap (+1) length) "hello"
00:49:41 <grom358> > (fmap (+1) length) "hello"
00:49:42 <lambdabot>   6
00:49:51 <grom358> mmm.. I get error trying that in ghci
00:49:57 <MikeMayer> different error now http://hpaste.org/12431
00:50:02 <polveroj> grom358: the f is a type variable like the a, except it has "kind * -> *": it's a type (like the list type or Tree) that takes a type argument
00:50:32 <Cale> grom358: import Control.Monad.Instances
00:50:36 <dibblego> @seen dons
00:50:37 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 23m 19s ago.
00:50:38 <Stephan202> MikeMayer: no comma after the list, just a sapce
00:50:40 <Stephan202> space*
00:51:02 <Cale> grom358: It's unfortunate, but the instances for the function type are in that module rather than the Prelude.
00:51:04 <MikeMayer> Stephan202: thanks :) I'm such a newb :/
00:51:29 <Cale> MikeMayer: Have you heard about currying?
00:51:35 <Stephan202> MikeMayer: no worries. Haskell is prob. very different from what you're used to
00:51:44 <MikeMayer> cale: very many times actually
00:52:35 <Cale> Functions in Haskell are Curried, which means that all functions take one parameter, and those which appear to take two, say, just return another function which takes the second parameter.
00:53:04 <Cale> Function application associates to the left, so when you write f x y z, it really means ((f x) y) z
00:53:43 <MikeMayer> cale: ahhh I see
00:54:03 <Cale> So  insert [2,4,6,8,10]  is a function which takes an Int (say), and produces the result of inserting that number into the list.
00:54:09 <Stinger> and types associate to the right
00:54:15 <jdrake> Is there any examples of pretty printing? All I can find are api docs.
00:54:18 <Cale> -> associates to the right in types
00:54:20 <Cale> So when you see
00:54:29 <Cale> insert :: [Int] -> Int -> [Int]
00:54:32 <Cale> It really means:
00:54:35 <Cale> insert :: [Int] -> (Int -> [Int])
00:54:55 <MikeMayer> hmm
00:55:13 <dons> dibblego: ?
00:55:23 <Cale> A -> B  is the type of functions which take something of type A, and produce something of type B
00:55:34 <dibblego> dons, any recommendations for getting a copy of RWH to AU?
00:55:40 <Stinger> haha
00:55:48 <dons> MikeMayer: things falling into place now? should clarify your imperative, as well as functional programming
00:55:56 <dons> dibblego: not sure. amazon?
00:55:57 <Cale> So insert here takes a list of Ints, and produces a function which takes an Int, and produces another list of Ints.
00:56:09 <dibblego> dons, that looks like the only way, thanks
00:56:13 <dons> dibblego: local bookstores will have it
00:56:19 <dons> i've seen it on a few .au websites
00:56:24 <grom358> dibblego: are you ex-java programmer? your nick sounds familiar
00:56:27 <dibblego> dons, but ready to be purchased?
00:56:28 <MikeMayer> dons: I'm getting close to grasping whats going on....
00:56:36 <dibblego> grom358, I still use Java sadly
00:56:39 <Cale> Alternately, you can simply regard that as a function of two parameters: it takes a list of Ints and an Int and produces a list of Ints.
00:56:45 <Raevel> oh my, rwh was not in yet yesterday, now it's out of stock, or at least that's what the website says
00:56:57 <dibblego> grom358, I used to visit ##java to make sure they were still solving the same stupid problems
00:56:59 <Raevel> TOO popular?
00:57:05 <Cale> Raevel: I suspect there were a lot of preorders.
00:57:08 <Stinger> whats this, on amazon.com? Raevel ?
00:57:09 <dons> MikeMayer: it'll click soon. then suddenly the whole business of programming looks simpler
00:57:11 <MikeMayer> cale: thats exactly what I wanted this to do... I'm glad I managed to figure that out
00:57:11 <grom358> dibblego: ah.. yes I remember you now
00:57:20 <dons> Raevel: out of stock!?
00:57:20 <Raevel> no it's a swedish site
00:57:36 <Raevel> sorry to get your hopes up :-P
00:57:46 <dibblego> dons, the best .au site I can find says available in December; I want it now :)
00:57:59 <MikeMayer> dons: heh I'm just totally new to functional programming in general :) I hope this flexs my brain a bit
00:58:02 <RayNbow> btw MikeMayer, I have annotated your previous hpaste ( http://hpaste.org/12428 ) with a possible solution to the exercise
00:58:09 <MikeMayer> dons: at least I'm done with prolog
00:58:45 <MikeMayer> RayNbow: wow
00:58:55 <MikeMayer> RayNbow: that was amazing help
00:59:04 <RayNbow`afk> MikeMayer: just try to understand the code ;)
00:59:20 <RayNbow`afk> that's more important than getting the correct answer :p
00:59:27 <dons> MikeMayer: oh, i hope so. haskell's serious business. and if you can wield it, awesome powers await.
00:59:34 <dons> get that multicore running hot :)
01:00:06 <MikeMayer> RayNbow`afk: of course
01:00:57 <MikeMayer> dons: thats right, functional languages really are the future- I attended a google tech talk about how it is immediately important to multithreading and distributed processing
01:02:14 <mapreduce> Functional programming won't change the world.
01:02:18 <osfameron> I think they're part of the future, but will probably have their most valuable techniques pre-digested and assimilated into existing "easy" languages in bite-size pieces
01:02:23 <osfameron> like they're doing already, in fact
01:03:16 <grom358> MikeMayer: I don't know if this helps.. but if you coming from imperative language, lists are really important in haskell. I'm new to functional programming too
01:03:35 <BeelsebobWork> mapreduce: you need to be more subtle
01:03:56 <mapreduce> Why?
01:04:01 <Cale> Lists essentially take the place of your loops
01:04:15 <MikeMayer> grom358: lists are the primary focus of this entire assignment actually
01:04:52 <mapreduce> MikeMayer: The fact that functional programming works with concurrency is an artefact of functional programming being sound.
01:06:08 <MikeMayer> mapreduce: my understanding about that was regarding how functional languages have an entirely different concept of state than how imperative languages handle it
01:06:24 <mapreduce> Not all imperative languages are the same though.
01:06:36 <MikeMayer> indeed not
01:06:52 <dibblego> Haskell, an imperative language, is very different to C, an imperative language ;)
01:07:16 <mapreduce> E.g., C#'s System.Linq methods are not that distant from Haskell's Data.List, barring some weird names.
01:07:48 <Cale> heh
01:07:48 <grom358> > let palindromes = filter (\p -> (reverse . show) p == show p) [x * y | x <- [100..999], y <- [100..999]] in maximum palindromes
01:07:52 <lambdabot>   906609
01:08:08 <mapreduce> And C++, Java and C# all have some idea of an immutable variable.  It's not like these techniques are unheard of in those languages, it's just that it's assumed they're impossible to scale.
01:08:12 <mapreduce> Which they're not.
01:08:47 <Stephan202> grom358: Euler problem? ;)
01:09:10 <grom358> Stephan202: yeah.. just showing MikeMayer a cool example with lists
01:09:13 <dibblego> @type (==) . reverse . show <*> show
01:09:14 <lambdabot> forall a. (Show a) => a -> Bool
01:09:40 <MikeMayer> grom358:  that was a burly example too
01:10:23 <MikeMayer> lambda
01:10:48 <MikeMayer> how would I import List.Sort ?
01:11:54 <Raevel> MikeMayer: do you mean List.sort ?
01:12:05 <MikeMayer> Raevel: yes I suppose I do
01:12:46 <Raevel> just put import List in your file, and then use sort as any other function
01:12:51 <grom358> MikeMayer: the [x * y | x <- [100..999], y <- [100..999]] says.. forall x from 100 to 999 and y from 100 to 999 generate the list of x * y. Then the filter (\p -> (reverse . show) p == show p) says filter where the item in the list p is the same number when reversed.
01:12:55 <quicksilver> import Data.List
01:13:01 <quicksilver> "List" is old-fashioned.
01:13:20 <Raevel> oh, sorry
01:14:04 <MikeMayer> oh nice apparently theres an insert function in List
01:14:24 <MikeMayer> thats probably why they wanted us to name our function insert
01:15:25 <grom358> where is this class you taking they using Haskell? that is pretty cool. I thought most courses use Scheme when teaching functional programming
01:15:53 <Raevel> yeah we use lisp here as well :*/
01:16:17 <MikeMayer> grom358: UC Irvine --- its only for one assignment in my programming languages course
01:16:29 <MikeMayer> grom358: we did prolog and we're doing perl next
01:18:41 <MikeMayer> so what about languages like python?
01:18:54 <Raevel> MikeMayer: what about them? :-)
01:19:17 <grom358> ah.. prolog is good to learn as well
01:19:17 <MikeMayer> one of my goals for this past summer was to learn python but sadly never did...
01:19:28 <Murdock> prolog is lots of fun
01:19:45 <MikeMayer> how does it fit in with the distribution of processing?
01:19:54 <Raevel> python is a pretty nice language, though i never saw any point in learning it because i know ruby
01:20:28 <grom358> yeah python and ruby are very similiar
01:20:28 <osfameron> MikeMayer: python/perl etc., probably ruby too have a fair amount of libraries that help with distributed processing
01:21:45 <MikeMayer> lots of professors have made it seem like distribution of processing is the future whether it be many many cores or many computers
01:21:56 <MikeMayer> and the general answer to the problem has been functional languages
01:22:28 <osfameron> well, one of the best known distributed processors, at google, uses C++
01:22:54 <osfameron> though it's true to say that the *approach* is functional
01:23:14 <C-Keen> MikeMayer: for distributed computing you may have a look at inferno's approach using limbo as well
01:23:17 * mapreduce watches his ears burn
01:23:23 <osfameron> mapreduce: hehe
01:23:51 <Giraffe> :t printf
01:23:52 <lambdabot> forall r. (PrintfType r) => String -> r
01:24:03 <mapreduce> I very much doubt that MapReduce was invented by someone who only knew C++.
01:24:30 <MikeMayer> C-Keen: i'll read about that
01:24:50 <osfameron> mapreduce: well obviously.  But the point I was making is that answer hasn't been "functional languages" but rather "functional techniques" so far
01:25:36 <C-Keen> hm, can someone explain the peano example on phantom types (http://en.wikibooks.org/wiki/Haskell/Phantom_types) ?
01:25:55 <MikeMayer> I don't remember the last time I had a redbull at 1:30
01:26:44 <mapreduce> MikeMayer: A few minutes ago.
01:27:05 <Murdock> MikeMayer: Do you remember the last time you remembered when you last had a redbull?
01:27:29 <MikeMayer> Murdock: recursion works because recursion works?
01:28:16 <Murdock> MikeMayer: Negative.
01:29:50 <Murdock> MikeMayer: One thing I do not like about recursion is how large the stack grows... it just bugs me.
01:30:16 <Cale> Murdock: That's not a property of recursion, that's a property of an implementation of recursion which is inadequate.
01:30:23 <dcoutts> Murdock: two solutions, lazyness and tail-recursion
01:30:28 <Cale> Murdock: In particular, one in which tail calls are not optimised.
01:31:14 <Murdock> Cale: How would it be optimised?
01:31:56 <Raevel> http://en.wikipedia.org/wiki/Tail_recursion
01:32:24 <Cale> Murdock: If the result of a function is the result of a recursive call, then there is no need to push a frame onto the stack.
01:33:13 <Cale> Murdock: Do you see why?
01:33:26 <fasta> Any Pythoniac that switched to Haskell willing to give me a hand? Ctypes and C inside: http://paste.debian.net/22356/
01:34:49 <Murdock> Cale: Not sure I understand... reading the Tail_recursion on wiki
01:35:19 <ddarius> 1977
01:35:41 <Cale> Murdock: The result of the recursive call is the result of your function, so why should you return to your function just to immediately return the result to the caller? The caller is already on the stack.
01:35:54 <Cale> So the recursive call can just return its result to there.
01:36:19 <BMeph> Caution: This product contains C code
01:37:18 <Cale> For example, let's pretend that the language is strict for the time being and evaluate a non-tail-recursive sum, and then rewrite it to be tail recursive, and see how things look different.
01:37:27 <Cale> sum [] = 0
01:37:31 <Cale> sum (x:xs) = x + sum xs
01:38:02 <Cale> That's not tail recursive, because the result in the recursive case is not simply the result of a recursive call.
01:38:09 <Cale> sum [1,2,3]
01:38:16 <Cale> -> 1 + sum [2,3]
01:38:23 <Cale> -> 1 + (2 + sum [3])
01:38:32 <Cale> -> 1 + (2 + (3 + sum []))
01:38:36 <Cale> -> 1 + (2 + (3 + 0))
01:38:43 <Cale> -> 1 + (2 + 3)
01:38:45 <Cale> -> 1 + 5
01:38:46 <Cale> -> 6
01:39:00 <Cale> You can see the stack growing and collapsing there.
01:39:05 <Murdock> yeah
01:39:22 <Cale> Now let's redesign sum a little bit:
01:39:36 <Cale> sum xs = sum' 0 xs
01:39:43 <Cale> sum' n [] = n
01:39:54 <Cale> sum' n (x:xs) = sum' (n+x) xs
01:40:16 <Cale> This sum' is tail recursive. Its result is the result of a recursive call to sum'
01:40:38 <Cale> Let's pretend the language is strict for a moment and evaluate:
01:40:42 <Cale> sum [1,2,3]
01:40:46 <Cale> -> sum' 0 [1,2,3]
01:40:57 <Cale> -> sum' (0+1) [2,3]
01:41:01 <Cale> -> sum' 1 [2,3]
01:41:08 <Cale> -> sum' (1+2) [3]
01:41:11 <Cale> -> sum' 3 [3]
01:41:15 <Cale> -> sum' (3+3) []
01:41:20 <Cale> -> sum' 6 []
01:41:22 <Cale> -> 6
01:41:40 <Cale> Essentially no usage of the stack.
01:41:50 <Cale> And this can be implemented by a tight loop.
01:42:08 <Murdock> Yea
01:43:00 <Cale> There is a little wrinkle which must be dealt with if the evaluation is lazy though. Lazy evaluation goes outermost first, so the parameters to a function are not evaluated before calling it.
01:43:24 <Cale> So that'll go:
01:43:28 <Cale> sum' 0 [1,2,3]
01:43:36 <Cale> -> sum' (0+1) [2,3]
01:43:44 <Cale> -> sum' ((0+1)+2) [3]
01:43:49 <Cale> -> sum' (((0+1)+2)+3) []
01:43:55 <Cale> -> ((0+1)+2)+3
01:44:27 <Cale> and you can see an expression building up in the parameter there which will use lots of memory, and eat up a different stack when it finally gets evaluated.
01:44:47 <Cale> (a stack which is used to search through expressions for outermost reducible subexpressions)
01:44:51 <Murdock> Yeah
01:45:27 <ksf> what's the meaning of me not being able to find my philosophy lexicon?
01:45:28 <Cale> So you generally have to be careful to make tail recursive functions strict in Haskell -- at least, it's most commonly beneficial to do so.
01:45:32 * glguy pokes Cale
01:45:33 <Cale> In any event, they
01:46:03 <Cale> are compiled into tight loops, but if they're not strict in the accumulating parameter, they can build large expressions
01:46:26 --- mode: ChanServ set +o glguy
01:46:31 <Murdock> I see
01:46:32 --- mode: glguy set -b *!*@syru217-183.syr.edu
01:46:52 <ushdf> free!!!!
01:47:43 <Cale> another way to ensure that it would be strict is if it used the accumulating parameter somehow before making the tail recursive call -- say if it was comparing it with something.
01:48:33 <Cale> But yeah, iteration is just a special case of recursion.
01:48:49 <Cale> > foldl' (+) 0 [1..1000000]
01:48:51 <lambdabot>   500000500000
01:48:57 <Murdock> That is a different way of looking at iteration
01:49:14 <Cale> > foldr (+) 0 [1..1000000]
01:49:16 <lambdabot>   * Exception: stack overflow
01:49:17 <ksf> iterations and recursions are equivalent.
01:49:25 <Murdock> hehe n(n+1) / 2
01:49:33 <ksf> iff your language provides some way to push and pop stuff, that is.
01:49:44 <grom358> hey.. compilers can even turn non-tail call recursion into tail call recursion
01:50:01 <Cale> grom358: yeah, there are fancier things you can do too :)
01:50:14 <ksf> i might get roasted here to say it, but learning assembly isn't the worst thing you can do.
01:50:21 <ksf> *for saying
01:50:41 <Cale> I should also point out that from this discussion it sounds like tail recursion is great (and it is to some extent), but in a lazy language, you often have a better choice
01:50:59 <grom358> I believe they can introduce accumlators for instance... such as in n * fact (n - 1)
01:51:03 <Cale> If a function can stash its recursive call underneath a data constructor, then that's even better.
01:51:03 <ushdf> learning assembly is the best thing you can do
01:51:06 <ushdf> thank you
01:51:33 <ushdf> there's this whole sea of programmers who think being as removed from the instruction set as possible is right
01:51:48 <Cale> ushdf: Do you need to be banned again?
01:51:50 <Cale> ;)
01:52:03 <Cale> ushdf: This happens to be that sea.
01:52:14 <ushdf> no, haskell is concise
01:52:18 <ksf> compiling math out of mathematica into x87 assembly is a real eye-opener.
01:52:36 <ksf> all you got to do is convert to rpn and optimise while doing it.
01:52:45 <ksf> sub-term elimination, that is.
01:52:57 <ddarius> Every programmer should know an assembly language.
01:52:58 <grom358> accumulators*
01:53:29 <Cale> ddarius: That's a reasonable way to put it :)
01:53:37 <ksf> same goes for learning both forth and scheme, even if you never use them.
01:53:58 <Cale> Murdock: For example, consider something like  map f [] = []; map f (x:xs) = f x : map f xs
01:54:17 <ushdf> haskell is like a bicycle
01:54:23 <ushdf> and ruby is like a scooter
01:54:34 <grom358> http://www.easy68k.com/
01:54:39 <lambdabot> Title: EASy68K Home, Free 68000 Assembler, 68000 Simulator, 68000 Assembly Language
01:55:05 <grom358> probably the better assembly to learn if you are interested
01:55:16 <ksf> it's a shame you can't really hand-code sse.
01:55:36 <ksf> changing anything can get _extremely_ painful.
01:55:47 <Cale> Murdock: This is not tail recursive, but instead is something which I would call productive. Evaluation in Haskell tends to stop whenever the top-level part of the expression is a data constructor (and then the parts of that data constructor are matched by some pattern match)
01:56:28 <Cale> So if you don't end up needing all the result of  map f (x:xs),  it may never even make the recursive call at all, or it may stop short of the end of the list.
01:56:41 <Cale> > map (*2) [1..]
01:56:42 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
01:56:49 <Cale> (which is why it works okay with infinite lists)
01:57:02 <Cale> map (*2) [1..]
01:57:11 <Cale> -> (1*2) : map (*2) [2..]
01:57:13 <BMeph> Everyone should learn LLVM! ;p
01:57:26 <Cale> -> (1*2) : (2*2) : map (*2) [3..]
01:57:31 <grom358> ah.. forth.. I just can't bring myself to learn a stack language yet
01:57:38 <Cale> Learn dc ;)
01:57:59 <mapreduce> Point-free is quite similar to a stack language.
01:59:24 <Cale> 2p3p[dl!d2+s!%0=@l!l^!<#]s#[s/0ds^]s@[p]s&[ddvs^3s!l#x0<&2+l.x]ds.x
02:00:30 <grom358> Cale: omg.. what is that
02:00:47 <Cale> grom358: Are you on a unix-like machine?
02:01:03 <grom358> ah no.. but I putty into one
02:01:17 <Cale> give that as input to the program  dc
02:01:31 <ddarius> Cale: When are we going to have a @dc plugin?
02:02:39 <grom358> can you write that code so its actually readable
02:02:56 * ushdf falls down
02:03:10 <ushdf> > foldr (+) 0 [1...600]
02:03:11 <lambdabot>   Not in scope: `...'
02:03:14 <ushdf> > foldr (+) 0 [1..600]
02:03:15 <lambdabot>   180300
02:03:16 <ushdf> you're not in scope
02:03:56 <ushdf> this language makes my heart ache
02:03:57 <Cale> grom358: It's not easy to make dc code readable.
02:04:13 <ddarius> grom358: If you don't know what the symbols mean, different formatting is not going to help much.
02:04:45 <ushdf> what does point-free map fusion mean
02:04:49 <ddarius> grom358: APL/J code looks like that, but is more readable than you expect when you are somewhat familiar with operations.
02:04:52 <BMeph> dc is best, when recited in the original Klingon. ;p
02:04:58 <Cale> ushdf: map f . map g -> map (f . g)
02:05:26 <ushdf> alright
02:05:59 <MikeMayer> ok I'm too tired now :/ I guess I won't finish tonight like I was planning
02:06:01 <Cale> I like how every byte is a valid register name in dc
02:06:17 <Cale> Including newline.
02:06:32 <grom358> I think I would rather use cat or joy then dc
02:07:49 <Cale> Yeah, it's not really a serious language, though it might make a decent little target language in some cases. :)
02:09:13 <grom358> anyway.. I still have a lot of haskell left to get used too.. especially monads
02:10:21 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
02:10:22 <lambdabot>   ("hello","olleh","HELLO")
02:10:37 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
02:10:38 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
02:12:23 <grom358> what modules does lambdabot import?
02:13:07 <Cale> grom358: a lot of them
02:13:21 <Cale> grom358: But for that first example, you'll need Control.Monad.Instances
02:15:53 <grom358> > map (\f -> f "hello") [id, reverse, map toUpper]
02:15:54 <lambdabot>   ["hello","olleh","HELLO"]
02:16:15 <grom358> mmm.. that is pretty close without using monads
02:16:22 <Cale> > sequence [id, reverse, map toUpper] "hello"
02:16:23 <lambdabot>   ["hello","olleh","HELLO"]
02:16:41 <Cale> It is.
02:16:41 <Twey> > map ($ "hello") [id, reverse, map toUpper]
02:16:42 <lambdabot>   ["hello","olleh","HELLO"]
02:16:58 <Twey> Many ways to skin a cat :)
02:17:24 <Cale> > liftM3 (,,) id reverse (map toUpper) "hello"
02:17:25 <lambdabot>   ("hello","olleh","HELLO")
02:17:26 <grom358> Twey: oh.. i like
02:17:37 <Twey> Hehe
02:18:29 <grom358> I didn't realize you can use $ like that
02:18:47 <ddarius> ($) is just an operator like any other
02:18:50 <Twey> OK, once more unto the breach: If I have a datatype A = Func (Value -> SomeMonad Value) | Number Double, and I want a Func of multiple parameters, so that that latter Value is going to be itself a Func over a (Value -> SomeMonad Value), is there a nice way of abstracting this?
02:18:58 <Twey> grom358: You can do it with any operator
02:19:10 <Twey> (including operator-converted functions)
02:19:12 <mmorrow> Cale: lol
02:19:13 <mmorrow> [m@ganon tests]$ echo '2p3p[dl!d2+s!%0=@l!l^!<#]s#[s/0ds^]s@[p]s&[ddvs^3s!l#x0<&2+l.x]ds.x' | dc | head
02:19:13 <mmorrow> 2
02:19:13 <mmorrow> ...
02:19:13 <mmorrow> 92179
02:19:15 <mmorrow> Segmentation fault
02:19:37 <Twey> > map (`id` "hello") [id, reverse, map toUpper]
02:19:39 <lambdabot>   ["hello","olleh","HELLO"]
02:20:08 <grom358> ah.. but I was thinking $ was just syntax shortcut.. didn't realise it was actually an operator.. I'm new
02:20:16 <Cale> mmorrow: you're sure that you piped the output to head?
02:20:17 <mmorrow> s/| head//
02:20:29 <Cale> mmorrow: hmm, I'm not getting that segfault...
02:20:34 <mmorrow> i just did that to get the beginning of the seq to paste into irc
02:20:36 <Twey> grom358: We try to minimise those in Haskell :)
02:20:42 <mmorrow> forgot to remove it
02:20:55 <grom358> :t $
02:20:57 <lambdabot> parse error on input `$'
02:20:58 <Cale> ah
02:21:01 <Cale> :t ($)
02:21:02 <Twey> All the operators are just infix functions, except <- and ;
02:21:02 <lambdabot> forall a b. (a -> b) -> a -> b
02:21:08 <Cale> f $ x = f x
02:21:19 <mmorrow> hmm. maybe it's something to do with SELinux (it seems like 50% of my segfaults are SELinux related..)
02:21:21 <Twey> Oh, and the list comprehension syntax, that's magic too
02:21:38 <Cale> The main difference being that $ binds very weakly as far as precedence goes
02:21:53 <Cale> So it's a bit like wrapping its two parameters in parens, if you like.
02:22:14 <mnislaih> given a free monad over a functor f, Free f a, what is the right way 2 define an map over the functor   mapFree :: (Functor f, Functor g) => ?? -> Free f a -> Free g a
02:22:46 <mnislaih> where data Free f a = Pure a | Impure (f (Free f a))
02:23:10 <ddarius> mnislaih: You need a natural transformation from f to g, which is just a polymorphic function.
02:23:20 <ddarius> The definition should then follow by the types.
02:23:24 <mmorrow> Cale: what dc version do you have?
02:23:34 <mmorrow> dc (GNU bc 1.06) 1.3
02:24:06 <Cale> dc (GNU bc 1.06.94) 1.3.94
02:24:08 <mnislaih> ddarius: it doesn't look so obvious to my untrained eyes
02:25:04 <mmorrow> hmm, i can't figure any reason for the segfault, and i really don't want to go wandering around in the SELinux maze, so i'll just pretend it never happened ;)
02:25:10 <naradapuri> Hi, could anybody recommend some extensive book(s) about Haskell? I'd like something that
02:25:10 <naradapuri> 1) Explains in detail mathematical foundations of haskell and functional programming - lambda calculus, the theory behind monads, etc
02:25:10 <naradapuri> 2) Discuss in depth haskell (standard) libraries and how to effectively use them.
02:25:14 <ddarius> ?? should be (forall b. f b -> g b)
02:25:14 <lambdabot>  should be (forall b. f b -> g b)
02:27:26 <mmorrow> whenever i get books related to lambda calulus something, i never appreciate them until i've already learned/encountered their content
02:27:34 <mnislaih> ddarius looks like I got it: mapTree f = foldTree Pure (Impure . f)
02:27:46 <mnislaih> thanks
02:28:42 <mmorrow> i always look at them and go ugh. then a month or two later open them randomly and all of a sudden am like wow this'll be really useful for the thing i was programming an hour ago
02:29:21 <ushdf_> any haskell tutorial that starts with "what the heck is going on?" has to be informative
02:30:44 <mmorrow> or it's just a well baited hook ;)
02:31:25 <Cale> mnislaih: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=509#a509
02:32:23 <mnislaih> Cale thanks. Yay, this is what I got, your code simply inlines the fold
02:33:27 <mmorrow> Cale: interesting
02:38:37 <Lemmih> Anyone know if the mailserver on projects.haskell.org is down?
02:39:07 <Saizan> anyone remember where cabal-install's windows binary was?
02:39:38 <Saizan> s/was/is/ , hopefully
02:44:07 <solrize> anyone use the ghci debugger much?  is it useful?  i'd sure like to see the intermediate values in a function ...
02:44:48 * Cale sees the thread "monads with take-out options" and considers suggesting such monads be called "Chinese restaurant monads".
02:44:50 <grom358> nite
02:44:55 <solrize> heh
02:46:22 <vixey> ohh
02:46:27 <vixey> so Ometa is based on PEG
02:47:35 <vixey> deos anyone know any papers where they prove a PEG parser actually does parse what it's supposed to?
02:47:50 <vixey> all this stuff is implementation http://pdos.csail.mit.edu/~baford/packrat/ doesn't have much on actualy use
02:47:51 <lambdabot> Title: Packrat Parsing and Parsing Expression Grammars
02:49:33 <vixey> that's meant to be java http://pdos.csail.mit.edu/~baford/packrat/thesis/java/Java.pappy
02:49:40 <Cale> Aren't parsing expression grammars more or less parsec-like?
02:51:19 <vixey> this implementation looks similar to parsec -- made of combinator coded in do notation but in general I think they needn't be done like that
02:52:31 <ddarius> The combinators work very differently than Parsec does.
02:52:39 <vixey> there's reduction and memoization that happen befre
02:58:17 <vixey> wikipedia is bizzare, stuff like "PEGs make a good replacement for regular expressions"
02:59:23 * vixey wonders if there is always some page saying 2^x is a good replacement for x^2 because it goes up faster
02:59:57 <opqdonut> :D
03:00:34 <Cale> See the page for Big O notation. ;)
03:02:39 <solrize> PEG's are linear time if implemented with memoization, that's their claim to fame
03:03:28 <vixey> I guess I'll be implementing PEG now
03:04:04 <solrize> i just happen to have a paper by brown and cook on my screen "monadic memoization mixins" which talks about memoizing parsers
03:04:18 <solrize> packrat parsers i mean
03:04:21 <vixey> catchy title :)
03:05:02 <solrize> http://www.cs.utexas.edu/~wcook/Drafts/2006/MemoMixins.pdf
03:05:04 <lambdabot> Title: Monadic Memoization Mixins
03:12:04 <PeakerWork> what are PEG's?
03:13:13 <solrize> peakerwork they are a class of grammars that are fairly powerful yet very fast to parse
03:13:19 <solrize> see wikipedia [[packrat parser]]
03:13:40 <PeakerWork> solrize: more than context-free, less than turing-complete?
03:13:47 <solrize> i think they are context-free
03:13:50 <vixey> read http://pdos.csail.mit.edu/~baford/packrat/popl04/
03:13:51 <lambdabot> Title: Parsing Expression Grammars: A Recognition-Based Syntactic Foundation
03:13:53 <solrize> i mean more powerful than regexps
03:13:55 <vixey> they can parse a^nb^nc^n
03:14:32 <earthy> IIRC that's context-sensitive
03:14:43 <PeakerWork> so PEGs are another way to parse context-free grammars?
03:14:57 <solrize> i don't know if they can handle arbitrary cfg's
03:15:15 <PeakerWork> a^nb^nc^n cannot really be described by an EBNF, right?
03:15:39 <vixey> PEG can parse context-free grammars
03:15:44 <vixey> read the paper!
03:15:48 <vixey> It's all written down in there
03:15:52 <solrize> ok
03:15:58 <solrize> i read that paper a long time ago i just don't remember it
03:16:08 <vixey> oh wasn't really directing that at you :)
03:16:12 <solrize> :)
03:16:57 <solrize> there is a haskell library floating around that parses json with a packrat parser
03:17:01 <solrize> and it is dog slow :(
03:17:17 <PeakerWork> vixey: You were directing your wrath at me then? :-)
03:17:38 <PeakerWork> I was asking a question about EBNF though, not sure if it has to do with PEGs
03:17:58 <vixey> (E)BNF isn't something you'd even consider trying to execute
03:18:36 <PeakerWork> a^nb^n  can be described by an EBNF grammar (a<recurse>b),  but I don't think EBNF can describe a^nb^nc^n
03:19:04 <vixey> BNF is general recursive if you actually wanted to execute it
03:19:37 * vixey proof by pointing at markov algorithm
03:20:20 <ddarius> solrize: Packrat parsers take O(length(input)) space.
03:21:09 <solrize> ddarius ram is cheap :)
03:21:45 <ddarius> solrize: The problem is managing it.
03:22:00 <solrize> use a mobad :)
03:22:03 <solrize> monad
03:22:35 <ddarius> solrize: I'm talking about the cost of allocating, scavenging, GCing, touching, cache-misses, etc.
03:23:03 <PeakerWork> so BNF can't always be translated to a context-free O(N) parser?
03:23:22 <ddarius> A packrat parser isn't going to beat a recursive descent LL(1) parser, say.
03:23:29 <solrize> use STUArray :)
03:24:22 <solrize> seriously, most parsing problems tend to involve expressions that fit in L1 cache
03:25:18 <ddarius> solrize: If your problem fits in L1 cache, then speed is unlikely to be an issue.
03:26:45 <solrize> ddarius speed is an issue if you have gajillions of those problems
03:27:28 <ddarius> solrize: Then they don't all fit in L1 cache.
03:28:05 <solrize> ddarius: mapM_ (gajillion problems) (read 1 problem into L1 cache and parse)
03:28:24 <solrize> forM_ i mean
03:28:37 <ddarius> solrize: Yes, but that's versus read 10000 problems into L1 cache and parse.
03:28:39 <Twey> @pl getFoo >>= \a -> getFoo >>= \b -> liftBar f a b
03:28:39 <lambdabot> (getFoo >>=) . liftBar f =<< getFoo
03:28:42 <vixey> :D
03:29:09 <vixey> @pl liftBar f <$> getFoo <*> getFoo
03:29:09 <lambdabot> liftBar f <$> getFoo <*> getFoo
03:29:13 <solrize> eh?  each problem is a parse that ends at a terminal symbol, it doesn't make sense to parse them all in one operation
03:29:17 <ddarius> And usually you are doing more than just parsing.
03:29:29 <Twey> If I have a datatype A = Func (Value -> SomeMonad Value) | Number Double, and I want a Func of multiple parameters, so that that latter Value is going to be itself a Func over a (Value -> SomeMonad Value), is there a nice way of abstracting this?  Is this a monad?  Or an arrow?
03:29:50 <vixey> Twey, you ever saw those nested types?
03:29:59 <vixey> like perfect binary trees and so on
03:30:00 <Twey> It feels like I should be able to do it with a monad and a getArg function
03:30:03 <Twey> vixey: Nay
03:30:08 <Twey> Link?
03:30:24 <solrize> right, forM_ (gajillion problems) (parse 1 problem >>= process the parse tree)
03:30:35 <vixey> Twey, http://www.eecs.usma.edu/webs/people/okasaki/icfp99.ps might give you some ideas
03:30:43 <Twey> Oh, it's not a monad, is it... it doesn't encapsulate a value
03:30:46 <Twey> Bah :(
03:31:04 <Twey> vixey: Thanks :)  *reads*
03:31:08 <vixey> just generalize Double out
03:31:11 <solrize> like, i have these zillion json records that i want to munch on and convert to XML
03:31:39 <solrize> i wrote a messy and slow python program for it, and then rewrote it in haskell which was cleaner but even slower
03:31:42 <solrize> so i had to go back to python
03:32:17 <earthy> then you're doing it wrong
03:32:33 <solrize> earthy?
03:32:59 <earthy> look at e.g. UUParsing
03:33:03 <ddarius> Parsing JSON with a packrat parser is retarded.
03:33:17 <Twey> vixey: Number isn't the issue, though: Func is
03:33:40 <Twey> (there are a variety of other types, too: String String, Regex String, &c.)
03:33:43 <earthy> part of uulib (available on hackage)
03:33:45 <solrize> i see some stuff about uuparsing in java
03:33:46 <vixey> just meant if you wanted to try adn make it a monad
03:33:51 <solrize> oh, sec
03:33:58 <earthy> UU.Parsing is quite fast...
03:34:17 <vixey> it's basically just a HOAS thing
03:34:17 <solrize> earthy, i used some json library that i downloaded from someplace, that used a packrat parser
03:34:24 <earthy> ahhhh
03:34:29 <solrize> there is a newer json parser on hackage that i've been meaning to getting around to trying
03:35:16 <earthy> Text.JSON seems to be nice
03:36:05 <Twey> Eck
03:36:05 <solrize> you mean http://hackage.haskell.org/cgi-bin/hackage-scripts/package/json  ?
03:36:06 <lambdabot> Title: HackageDB: json-0.3.3
03:36:10 <solrize> that's the one i've been wanting to try
03:36:18 <earthy> solrize: that seems quite nice indeed
03:36:33 <solrize> it uses parsec
03:36:38 <Twey> See, whenever reading some documentation in Haskell you run into phrases like 'covariant endofunctors on the category of types' :-P
03:36:47 <earthy> Parsec and UU.Parsing for a long time switched places as the fastest haskell parser lib
03:37:02 <solrize> twey, that is scary, i actually know what that means :)
03:37:19 <solrize> i thought happy was faster than parsec
03:37:21 <Twey> x.x
03:37:34 <solrize> i mean, all haskell functors are endofunctors
03:37:47 <Twey> What *is* an endofunctor?
03:37:51 <ddarius> Happy (in some modes) is faster than parsec.  Happy is a parser generator.
03:37:54 <pk> hi
03:37:54 <earthy> solrize: happy is not a lib
03:37:57 <solrize> a functor from a category to itself
03:38:05 <Twey> Oh.  Right.
03:38:08 <solrize> and covariant functor is just an ordinary functor
03:38:17 <solrize> vs. contravariant which flips the arrows
03:38:31 <Twey> 'Flips the arrows'?
03:38:36 <solrize> i never knew any of this stuff before trying to make sense of haskell
03:38:45 <pk> Does any of you know  where I can find some good maths tutorials ?
03:38:56 <earthy> plus, I'd like to see some comparisons between happy parsers and UU.Parsing parsers
03:39:05 <earthy> those might come close in speed
03:39:13 <solrize> twey, yeah, F (f :: x -> y)   becomes (F y -> F x)
03:39:18 <solrize> instead of F x -> F y
03:39:34 <solrize> earthy, yeah, happy is more like yacc i think, an external program
03:39:45 <solrize> pk, what kind of math tutorial?
03:39:55 <solrize> the haskell wikibook on categories is REALLY GOOD
03:39:55 <earthy> indeed
03:39:59 <pk> I'm curious about topology
03:40:01 <ddarius> earthy: Parsec was geared toward being not unusably slow, not toward being blazingly fast.
03:40:16 <Twey> x.x
03:40:18 <ddarius> pk: Why are you asking here and not on, say, #math?
03:40:19 <Twey> I'll have a read.
03:40:35 <solrize> http://en.wikibooks.org/wiki/haskell/Category_theory
03:40:41 <povman> i might add that i made a parsec parser that ran as fast as the equivalent C
03:40:44 <Twey> Ta
03:40:51 <solrize> povman, wow
03:40:54 <povman> (albeit maybe simpler than most)
03:41:09 <pk> the channel 's empty
03:41:20 <pk> no it'zs not
03:41:22 <pk> sorry
03:41:24 <pk> thx
03:42:03 <solrize> http://en.wikipedia.org/wiki/Topology#External_links
03:42:05 <lambdabot> Title: Topology - Wikipedia, the free encyclopedia
03:42:20 <solrize> anyway i should get around to trying text.json
03:42:25 <solrize> then there is the xml side of it
03:42:38 <solrize> someone was working on a unicode version of data.bytestring a while back
03:42:41 <solrize> did anything ever happen with that?
03:47:21 <solrize> i don't seriously expect text.json to be faster than the python simplejson library (which is written in C)
03:47:34 <solrize> but the packrat library was really awful
03:48:43 <Twey> *brain explosion*
03:49:23 <solrize> twey?
03:49:44 <chrisdone> Question of the week: What *is* an endofunctor?
03:49:45 <preflex>  chrisdone: you have 1 new message. '/msg preflex messages' to read it.
03:50:01 <quicksilver> chrisdone: a functor from a category to itself.
03:50:10 <quicksilver> chrisdone: all haskell functors are endofunctors on Hask.
03:51:19 <chrisdone> quicksilver: ah
03:52:18 <quicksilver> (unless you choose to view them as functors from Hask to a subcategory of Hask thought of as a separate category)
03:52:24 <quicksilver> partly a case of perspective.
03:54:06 <povman> surely eventually ghc wlll be able to equal optimised C in speed...
03:54:37 <ddarius> povman: That depends more on the programmer than the compiler.
03:54:46 <vegai> it will generate C that is faster than C
03:54:59 <povman> um
03:55:02 <Twey> Generating C is frowned upon!
03:55:45 <lilac> povman: i would be surprised if GHC could ever consistently generate binaries which would run faster than /any/ C formulation of an equivalent program
03:55:54 <povman> ddarius: then what place has a comment like "i don't seriously expect text.json to be faster than the python simplejson library (which is written in C)"
03:56:16 <quicksilver> there are some things that C is very good at
03:56:20 <solrize> i think to come anywhere near C you have to write really contorted haskell -- look at any of the shootout examples
03:56:26 <quicksilver> consistent simple memory management of simple compact structures.
03:56:42 <quicksilver> C is great at this, and modern CPUs like compact structures because they are good for caches.
03:56:52 <ddarius> solrize: There are examples where idiomatic Haskell beats C.
03:57:17 <solrize> ddarius yes some isolated ones at least
03:57:18 <lilac> ddarius: what do you mean "beats C"?
03:57:23 <lilac> idiomatic C?
03:57:24 * fasta is with lilac on this
03:57:26 <ddarius> lilac: Yes.
03:58:26 <povman> i didn't say faster, i said equal. surely if a person can apply some heuristics to a problem to make it into C code, similar heuristics can be put into ghc
03:58:27 <lilac> i guess the trouble is that "idiomatic C" covers quite a large class of possible implementations
03:58:42 <ddarius> povman: Text.Json is probably not written at as low a level as simplejson.  And at any rate, I didn't make that comment.
03:59:02 <ddarius> lilac: Okay, then say "naive Haskell beats naive C"
03:59:25 <solrize> but these days, writing anything in naive C is crazy
03:59:35 <povman> i'm just lazy :p
03:59:35 <ddarius> But yes, my whole point is the programmer is the most significant factor when it comes to speed.
03:59:43 <Twey> Most C is naïve :-\
03:59:49 <solrize> if you're not going to optimize the bejeezus out of it you can save yourself a lot of headache by using haskell
03:59:52 * Twey points at strcpy().
04:00:12 <ddarius> http://alistair.cockburn.us/Characterizing+people+as+non-linear,+first-order+components+in+software+development
04:00:16 <povman> i suppose there's always the FFI for really important stuff
04:00:23 <solrize> strcpy should be written with xmm intrinsics
04:01:42 <solrize> i've been fantasizing for a while about a language that i call tachyon (because it's supposed to be faster than c)
04:01:47 <ddarius> povman: In practice it seems several people just use functions in the FFI API to write low-level Haskell rather than writing C and then binding to it.
04:02:00 <solrize> it would be a DSL implemented as a haskell monad
04:02:06 <solrize> with the haskell type system
04:02:06 <ddarius> (Of course, not for pre-existing C libraries.)
04:02:16 <Twey> BitC looks interesting.
04:02:53 <solrize> oh interesting
04:03:36 <povman> yes, that makes sense. I suppose my argument is that GHC should eventually be able to compile DSL-C to have speed equal to C
04:03:49 <chrisdone> what's that incredibly ugly langauge with the inscrutable name that made it to the top of the shootout from nowhere?
04:03:59 <solrize> povman what is DSL-C?
04:04:16 <povman> solrize: the monad you described
04:04:54 <solrize> povman, ok, but the idea is to actually beat C and not just equal it.  the price of that is losing machine dependence, i.e. the language level would be halfway between C and assembler
04:05:21 <solrize> s/dependence/independence/
04:05:30 <solrize> bit-c looks cool
04:05:31 <ddarius> There's quite a bit of room between C and assembler while still maintaining machine independence.
04:05:39 <Twey> C--
04:05:47 <povman> in fact my original argument was that the haskell json parser should be no slower than the python one
04:05:59 <Twey> chrisdone: C?
04:06:02 <Twey> :-P
04:06:07 <povman> unless it does a lot more
04:06:08 <solrize> c-- doesn't have much of a type system
04:06:10 <chrisdone> drum roll
04:06:14 <solrize> LLVM looks more promising
04:06:22 <Twey> True, it doesn't
04:06:57 <solrize> but c-- might be a reasonable back end for the dsl c
04:07:06 <solrize> i had been thinking of using harpy
04:07:13 <chrisdone> oh, that was it. ATS
04:07:14 <solrize> c-- or llvm is probably better
04:08:02 <hd_> "c--"? "dsl c"?
04:08:34 <solrize> cminusminus.org = c--
04:08:48 <solrize> dsl c = this hypothetical thing i've been sort of daydreaming about
04:08:55 <solrize> aka tachyon
04:09:31 <povman> solrize: how would it differ from IO?
04:09:48 <solrize> why am i suspicious of an academic project where the guy signs his name "firstname lastname ph.d." ?
04:09:55 <solrize> povman differ from io ??
04:10:08 <povman> the dsl-c you've been 'daydreaming' about
04:10:16 <solrize> what's io?  you mean the io monad?
04:10:34 <povman> yes
04:10:59 <solrize> running this monad would give you a blob of native machine code that you could then call through the FFI
04:11:01 <solrize> sort of like harpy
04:11:05 <solrize> but higher level
04:11:31 <solrize> i want to wipe out C in my lifetime ;)
04:11:38 <solrize> and ada is not the answer ;)
04:12:16 <solrize> bitC has lisp syntax !!!
04:12:24 <povman> can't you essentially do that already with IO and Foreign.C.Types?
04:13:20 <solrize> povman ??  the idea isn't to run C code but it's to have a typesafe language with haskell's type system
04:14:15 <solrize> bitC does look interesting, i guess the syntax isn't that big a problem
04:14:20 <povman> oic
04:15:22 <vixey> solrize, bad idea
04:15:23 <povman> i wonder how bitC would go on embedded devices...
04:15:26 <solrize> C got its name because they had to type "crash" so often that they abbreviated it to one letter ;)
04:15:35 <vixey> solrize, haskells type system is no where near expressive enough
04:15:44 <solrize> hmm
04:15:59 <vixey> solrize, something closer to target is ATS
04:16:03 <solrize> what's ATS?
04:16:18 <vixey> there are some stuff examples on the site like a doubly linked list I think
04:16:19 <solrize> http://www.ats-lang.org/
04:16:30 <lambdabot> Title: Home Page for ATS
04:16:31 <solrize> vixey, yeah, true
04:16:50 * atsampson notes he really needs to take "ats" (his initials) off his client's highlight list
04:17:00 <solrize> you could have a reference type
04:17:26 <vixey> solrize, I guess it's like DML on steriods
04:17:32 <vixey> (ATS)
04:17:41 <solrize> DML = dependent ml?   yow
04:18:28 <povman> i think i've developed a phobia to languages with side-effects
04:18:49 <vixey> this PEG paper just makes me think how nice untyped programming is :/
04:18:53 <solrize> hehe
04:19:07 <vixey> in haskell you might write something like
04:19:20 <vixey> data PE = ... | Terminal Char | ...
04:19:27 <vixey> and parse a list of [Char]
04:19:38 <vixey> but they just use PE = ... | Char | ...
04:20:04 <solrize> ats has linear types!  whee!!   is that enough to program for a singularity-like kernel?
04:20:09 <Twey> Eh, vixey, it's not all that fun :-P
04:20:11 <vixey> so I have to keep putting grout in everywhere
04:20:46 <povman> vixey: could you get away with pe = [..., char,...]
04:21:01 <vixey> solrize, infuriating is that the section of the ATS manual _about_ linear types has not been written
04:21:11 <vixey> povman, I don't understand that
04:21:12 <solrize> lol
04:21:32 <povman> i spend half my life speaking out my anus
04:22:21 <povman> i mean couldn't you write a little 'interpreter' and then use lists or something abstract to 'bypass' the type system
04:22:54 <solrize> data.dynamic :)
04:23:14 <povman> [Dynamic] indeed
04:23:42 <povman> hum. i appear to have an aversion to languages that aren't haskell
04:23:51 <povman> is this a serious problem?
04:24:36 <Saul_> Why won't deriving work on associated datatypes?
04:24:39 <solrize> dunno, depends on how fluent your haskell is i guess
04:24:51 <solrize> and your functional data structure mojo
04:25:12 <povman> oh oh. what should I do with my first (ever) paycheck?
04:25:14 <solrize> i tried to sketch out a sorting program the other day and got stuck at how to code the merge queues
04:26:00 <quicksilver> povman: frame it and put it on the wall.
04:26:03 <solrize> so i peeked in hackage and there's a heap library that uses some fancy functional data structure
04:26:16 <solrize> but i wouldn't have figured that out myself
04:26:35 <quicksilver> lists work pretty well for simple merging ;)
04:27:13 <povman> well guys, i'd like to say 'it's been emotional' but a) it hasn't and b) that's such a retarded thing to say
04:27:18 <povman> bue
04:27:25 <igel> you should only use a heap if you need your data structure to do the sorting, solrize
04:27:52 <igel> of course you can just add everything to a minheap and then call toList =)
04:28:01 <solrize> igel this is for external sorting
04:28:22 <solrize> heaps are the traditional way to do it
04:28:23 <igel> k
04:28:55 <quicksilver> repeated merge works ok for external sorting too
04:29:35 <solrize> quicksilver, yes, but normally you have something like merge :: [[record]] -> [record]
04:29:42 <solrize> i.e. you merge N files together for some fairly large N
04:30:09 <solrize> so you want  a priority queue to select the smallest element from the available streams
04:30:29 * quicksilver nods
04:30:47 <igel> so you make sure there always is at least one element from each (sorted) file in a heap?
04:30:48 <quicksilver> priority queues are one of the main possible uses of fingertrees aren't they?
04:31:17 <solrize> quicksilver, i dunno, that's what i mean about functional data structure mojo.  knowing haskell isn't enough, there's also that okasaki book to read :)
04:31:23 <igel> you can even use a monotone priority queue!
04:31:24 <solrize> igel yeah
04:31:50 <solrize> monotone?
04:31:58 <igel> i haven't thought about those as functional data structures, yet, but they could be a bit faster
04:32:26 <igel> solrize: they use the fact that every inserted element is always >= the last element that was removed
04:32:35 <igel> ehm
04:32:49 <igel> or sth similar
04:33:15 <igel> i've used them for fast marching, but that was image processing in c++
04:33:52 <solrize> igel is that the deal where you use two heaps so you pop an item from heap A, then insert a new item into heap A if it fits otherwise heap B, and when A is completely popped, make a new heap C and start popping from B, etc. ?
04:34:56 <igel> well i used a specialization of mon.prio.queues, that was allowed to make (little) mistakes and it provided excellent performance with all operation in O(1)
04:35:11 <igel> it's implementation was just a circular array of linked lists
04:35:14 <solrize> ic
04:35:25 <solrize> ATS looks really painful
04:35:39 <igel> ats?
04:35:46 <solrize> ats-lang.or
04:35:48 <solrize> ats-lang.org
04:35:53 <solrize> this lang. we've been discussing
04:35:58 <solrize> that's winning the shootouts
04:35:58 <Axman6> #1 on the language shootout right?
04:36:02 <solrize> yeah
04:36:04 <Axman6> yus
04:36:05 <mehrheit> liskell's abandoned, isn't it?
04:36:32 <solrize> ats looks painful but really interesting, i should say
04:36:48 <solrize> liskell was more of a gross hack
04:36:54 <igel> solrize: well i suggest you just google montone priority / calendar queues, maybe you can somehow exploit that the insertion order of elements is montone
04:37:47 <solrize> http://www.ats-lang.org/EXAMPLE/MISC/listquicksort.dats     -- yeaaaaarrrrggggh  !
04:37:57 <mehrheit> solrize: I never really used it, but really liked the idea
04:38:43 <vixey> solrize, I think it would probably work pretty well if you used something like to Coq to fill in the proof obligations
04:39:52 <solrize> mehrheit, my feeling about both liskell and TH was that they were workarounds for haskell shortcomings that maybe could be fixed with more types, generics, or something like that
04:40:10 <solrize> vixey yeah, interesting, i wonder if ATS itself can do that
04:40:23 <solrize> anyway i'm clueless about this stuff, i shouldn't even be talking about it
04:40:35 <solrize> did you see from last night, smerdykov is writing a coq book?
04:41:01 <solrize> http://adam.chlipala.net/cpdt/   it looks good
04:41:02 <lambdabot> Title: Certified Programming with Dependent Types
04:41:53 <solrize> i didn't realize you could do that type-based theorem proving with imperative languages
04:42:05 <thoughtpolice> ATS is pretty interesting
04:42:28 <thoughtpolice> some of its features are definitely beyond me, although I have some code somewhere that will inevitably become an HTTP server written in ATS :p
04:43:08 <vixey> thoughtpolice, Cool is it going to be open source?
04:43:28 <solrize> :)
04:43:28 <thoughtpolice> vixey: duh. :]
04:43:46 <thoughtpolice> solrize: but it's a very interesting language
04:43:47 <vixey> thoughtpolice, can you give a URL or something?
04:43:55 <solrize> yes very interesting
04:43:58 <solrize> just painful looking
04:44:01 <thoughtpolice> vixey: no the code is on my other system; I'm out of town for thanksgiving
04:44:17 <vixey> so that's not quite what I meant when I asked open source :p
04:44:26 <vixey> but ping me if you ever upload it or anything
04:44:35 * vixey would like to see that
04:44:41 <thoughtpolice> vixey: sure
04:44:55 <flux> one thing is a bit suprising with ATS, though: its shootout examples are even longer than C ones :-o
04:45:04 <thoughtpolice> solrize: it would literally be about 500% better if there were just a few libs for *basic* things, e.g. a basic pthreads wrapper would considerably clean the shootout entries
04:45:11 <quicksilver> and contain most of the C from the C ones
04:45:17 <quicksilver> just with some types around them :P
04:45:18 <flux> so a great type system doesn't come without a cost. or perhaps it only has a little base library.
04:45:19 <thoughtpolice> flux: yes, like I said, there are NO external libraries
04:45:24 <thoughtpolice> so pthreads basicall has to be replicated
04:45:24 <acidjnk> What went wrong here? http://rafb.net/p/zpoqeG33.html
04:45:28 <flux> thoughtpolice, oh, you did :)
04:45:31 <thoughtpolice> between each single one that uses them
04:45:34 <lambdabot> Title: Nopaste - No description
04:45:53 <vixey> acidjnk, or2 should be `or2`
04:46:18 <solrize> wow, haskell crushes sbcl at just about everything
04:46:25 <vixey> acidjnk, it's like  add 1 1 vs 1 add 1 vs 1 + 1 vs + 1 1
04:46:54 <acidjnk> "let `or2`  True True = True" gives <interactive>:1:4: parse error on input ``'
04:47:22 <Beelsebob> > let True `or2` True = True in True `or2` True
04:47:23 <lambdabot>   True
04:47:25 <vixey> acidjnk, I'm only suggesting changing the line on which the error occured
04:47:26 <PeakerWork> acidjnk: () convert an infix operator to prefix. But or2 is not an infix operator, its already prefix, so you don't need the () around ord2 above
04:47:33 <Beelsebob> > let or2 True True = True in True `or2` True
04:47:35 <lambdabot>   True
04:47:43 <PeakerWork> acidjnk: And since its prefix, it cannot be used as infix, i.e: True or2 True is invalid
04:47:44 <Beelsebob> acidjnk: one or other, not a combination ;)
04:48:09 <solrize> wtf?  all i have to do to make java run 10x faster is say "-server" on the command line??!!!!
04:48:22 <acidjnk> None of that is an option. I want to create an infix operator.
04:48:36 <vixey> acidjnk, try what I said
04:48:49 <PeakerWork> acidjnk: infix operators are made of operator chars, not letters, OR backquoted names
04:49:22 <p_l> solrize: It changes the profile of VM to one supporting long-lived applications
04:49:27 <PeakerWork> acidjnk: === or <,> or %% or `blah` are infix,  whereas (===) (<,>) and blah are all prefix
04:49:27 <RayNbow> @seen dons
04:49:27 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 3h 49m 52s ago.
04:49:32 <acidjnk> So only a few things like +-*/ can be used for the name of the operator?
04:49:35 <RayNbow> dons, re: http://www.reddit.com/r/haskell/comments/7fz7t/the_data_parallel_haskell_team_needs_your_help/ ... I can obtain access to an 8-core machine but I doubt GHC is installed on it
04:49:42 <lambdabot> Title: The Data Parallel Haskell team needs your help! Got an 8x machine to benchmark o ..., http://tinyurl.com/6z5rap
04:49:53 <PeakerWork> acidjnk: not that few, also <>$%= and many others, and again, you can backtick around a normal name
04:49:58 <RayNbow> (and I'm not sure if I'm able to install it without root access)
04:50:12 <solrize> p_l i don't get that by default?
04:50:24 <acidjnk> thanks
04:50:32 <p_l> solrize: By default the "desktop" setting is for applets AFAIK
04:50:34 <acidjnk> I'm not interested in backticks, though.
04:50:56 <solrize> p_l wow
04:50:57 <p_l> solrize: in server mode it's prepared for an application that might work months if not years
04:51:26 <PeakerWork> acidjnk: then you have to use these special characters only, there are plenty though
04:51:35 <acidjnk> Ok, thanks.
04:51:52 <twanvl> > let a ∆ b = 10*a+b  in  1 ∆ 2 ∆ 3 -- unicode operators are allowed
04:51:54 <lambdabot>   123
04:51:59 <solrize> p_l yes i'm running several java servers
04:52:37 <solrize> if i don't say -server i get desktop by default?
04:52:42 <PeakerWork> > let a שלום b = a*b*b in 10 שלום 20
04:52:43 <solrize> do you know how much difference it makes?
04:52:43 <lambdabot>   <no location info>: lexical error at character '\1513'
04:52:48 <p_l> solrize: IIRC yes
04:52:54 <solrize> apparently there is a huge difference vs -XInt that turns off compilation altogether
04:53:23 <solrize> but i'm sure i get some compilation by default, because this program keeps crashing eclipse unless i build with some special options to turn off compiling certain classes :(
04:54:28 <p_l> solrize: It's compiled by default, including JIT, but HotSpot recompiles the code over time. afaik it's kind of running a statistical profiler all the time
04:54:37 <solrize> interesting
04:54:41 <Axman6> bah, Cale, you around? we'd quite like to have lambdabot back in #macosxdev
04:54:50 <solrize> ok i will run with -server and see if it makes a difference.  thanks!!!
04:55:05 <solrize> http://www.ats-lang.org/TUTORIAL/tutorial.html   <-- most of these pages go to 404
04:55:05 <lambdabot> Title: Home Page for ATS-tutorial
04:55:49 <Axman6> @join #macosxdev
04:55:49 <lambdabot> Not enough privileges
04:55:53 <Axman6> :(
04:57:53 <vixey> , let a שלום b = a*b*b in 10 שלום 20
04:58:01 <lunabot>  luna: Not in scope: `霕ݧ
04:58:17 <PeakerWork> vixey: that spells "shalom", btw :-)
04:58:18 <CGI781> hello. is there a function to get the system's time?
04:58:59 <Axman6> @hoogle systemtime
04:58:59 <lambdabot> No results found
04:59:03 <Axman6> @hoogle time
04:59:04 <lambdabot> package time
04:59:04 <lambdabot> module Data.Time
04:59:04 <lambdabot> Data.Time.LocalTime data TimeOfDay
04:59:04 <solrize> cgi781 yes there is, system.time ?
04:59:06 <solrize> data.time
04:59:07 <solrize> yeah
04:59:39 <CGI781> so import package time and call which function?
04:59:57 <PeakerWork> @hoogle gettimeofday
04:59:57 <lambdabot> No results found
05:00:14 <EmielRegis> getCurrentTime CGI781
05:00:23 <EmielRegis> @hoogle getCurrentTime
05:00:23 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
05:00:23 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
05:01:31 <idnar> vixey: man, that's completely illegible in my monospace font
05:01:41 <idnar> the spacing etc. is all messed up
05:03:30 <PeakerWork> nice, it seems like the Haskell time lib functions are the first to be completely unconfused about notions of time locality, zoning, etc
05:03:59 <PeakerWork> (the C stdlib functions  have nothing in their name or result type to suggest what time zone they're in, what conversions take place, etc)
05:04:22 <earthy> it does seem so indeed
05:04:51 <PeakerWork> and Python's time lib is basically a thin wrapper around the C one
05:11:25 <solrize> @pl \x->x*x
05:11:25 <lambdabot> join (*)
05:11:54 <solrize> :t join
05:11:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:12:09 <solrize> > join (*) 3
05:12:11 <lambdabot>   9
05:12:15 <solrize> yow
05:12:21 <mlesniak> > :t join
05:12:23 <lambdabot>   <no location info>: parse error on input `:'
05:12:29 <mlesniak> :t join
05:12:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:12:42 <solrize> there's a cale-ism going on
05:12:49 <mlesniak> that looks strange
05:14:24 <PeakerWork> for the (r->) Reader monad,  join means:  (r->r->a) -> (r->a)         In order to give 2 r's from just one, you have to duplicate the argument
05:17:10 <EvilTerran> solrize, i don't see any caleskell-isms...
05:17:36 <EvilTerran> ?hoogle join
05:17:37 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
05:17:37 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
05:17:37 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
05:18:59 <papermachine> How does it know to infer the reader monad?
05:19:10 <papermachine> Oh, I see it. Nevermind.
05:19:30 <PeakerWork> all functions are reader monads
05:23:43 <BeelsebobWork> http://www.cs.kent.ac.uk/people/rpg/tatd2/Hsark.png :)
05:24:25 <lilac> BeelsebobWork: i have a theory
05:24:37 <BeelsebobWork> lilac: ?
05:24:40 <BeelsebobWork> about the memory leak?
05:24:45 <lilac> does your tetris still have the 'testTicks' global?
05:25:02 <BeelsebobWork> it doesn't -- Peter had the same theory as you by the sounds of it
05:25:05 <lilac> ah
05:25:08 <BeelsebobWork> lilac: conal claims he *didn't* fix the bug
05:25:10 <lilac> the [0,x..]?
05:25:17 <BeelsebobWork> so the TVal bug *still* exists
05:25:26 <lilac> :(
05:25:30 <Axman6> BeelsebobWork: wait, what does Hsark do exactly?
05:25:42 <lilac> Axman6: looks like a GUI for the profiling stuff
05:25:58 <BeelsebobWork> just somewhere in the past 0.0.3 versions it got much better for an unknown reason lilac
05:26:06 <BeelsebobWork> I was gonna spend some time figuring out what change did it
05:26:13 <BeelsebobWork> conal said he suspected a change to unamb
05:26:30 <BeelsebobWork> Axman6: it's a gui for the profiling stuff
05:26:34 <Axman6> well, i couldn't tell if it was for use with Shark or not
05:26:36 <Axman6> i see
05:26:37 <BeelsebobWork> it's only very very basic at the moment
05:26:48 <BeelsebobWork> the name Hsark is only a pun
05:26:55 <BeelsebobWork> (it's like Shark, but for Haskell)
05:28:51 <benjo> #haskell.es
05:29:11 <Axman6> BeelsebobWork: what did you use to make the gui?
05:29:18 <Axman6> just gtk2hs?
05:29:46 <BeelsebobWork> Axman6: no, it's Haskell unrelated :(
05:29:48 <BeelsebobWork> pure cocoa
05:29:55 <Axman6> ah i see, excellent :0
05:29:57 <Axman6> :)
05:30:31 <Axman6> going to have any graphing like the current stuff an output?
05:30:34 <Axman6> can*
05:31:19 <BeelsebobWork> not yet -- only time profiling for now, I'm gonna perfect that, and then move onto heap profiling
05:32:01 <quicksilver> only time profiling?
05:32:08 <quicksilver> what's the 'bbytes' column then?
05:33:06 <macron> Data.ByteString.Lazy.foldr (:) [] $ Data.ByteString.Lazy.repeat 1
05:34:14 <macron> blows up the stack. Whereas foldr (:) (repeat 1) works fine.
05:34:15 <BeelsebobWork> quicksilver: only "time" profiling -- i.e. things that get written to the .prof file
05:34:42 <BeelsebobWork> nothing that goes in a .hp file though
05:34:46 <macron> Shouldn't the bytestring foldr be lazy enough to work just as well as regular foldr?
05:35:58 <quicksilver> BeelsebobWork: oh, is that GC bytes then?
05:36:34 <BeelsebobWork> quicksilver: pass! It's the column that's labeled "bytes" in a .prof file
05:36:54 * quicksilver grins
05:38:32 <benjo> hi, I'm compiling Happy but this show:
05:38:42 <benjo> src/Main.lhs:39:2:
05:38:44 <benjo>     Failed to load interface for `GHC.Prim':
05:38:45 <benjo>       it is a member of package ghc-prim, which is hidden
05:39:07 <benjo> but, ghc-prim isn't hidden
05:39:25 <Lemmih> benjo: Using cabal-install?
05:39:49 <benjo> yes
05:40:05 <benjo> I have ghc-6.10.1
05:41:46 <solrize> @pl \x -> [[x]]
05:41:46 <lambdabot> return . return
05:47:18 <rog> is there an equivalent of ByteString that holds O(1) addressable unicode characters?
05:47:56 <solrize> hmm
05:48:15 <lilac> rog: equivalent in what way? implementation strategy?
05:48:30 <rog> lilac: equivalent in efficiency, i guess.
05:48:30 <solrize> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string   ?
05:48:33 <lambdabot> Title: HackageDB: utf8-string-0.3.3, http://tinyurl.com/3cjhwj
05:48:47 <rog> utf-8 strings are not addressable in O(1) time
05:48:58 <solrize> hmm
05:49:14 <rog> in C, i'd use an array of unsigned short
05:49:20 <solrize> laterz all
05:49:24 <Axman6> BeelsebobWork: you have a octomac right?
05:49:58 <rog> i was wondering if there was some equivalent; ByteString is *almost* a much more efficient replacement for String...
05:50:52 <Saizan> except that unsigned short can't represent all of unicode, right?
05:51:07 <rog> Saizan: it can, kinda
05:51:35 <rog> Saizan: if you ignore the double-character extensions (and diacritical modifiers)
05:51:55 <rog> Saizan: it's certainly a lot better than just ascii
05:52:48 <Zao> If by unsigned short you mean a 16-bit integer, you can represent the BMP.
05:52:50 <Saizan> heh, that's not hard to believe :)
05:52:53 <Zao> Or UTF-16 if you use two.
05:53:10 <rog> Saizan: and it wouldn't really matter if it was hidden behind an interface - you could change the underlying representation easily
05:53:11 <Lemmih> http://www.mail-archive.com/haskell@haskell.org/msg19944.html ?
05:53:12 <lambdabot> Title: [Haskell] ANNOUNCE: Data.CompactString 0.3 - Unicode ByteString with dif
05:53:18 <rog> Zao: i do
05:53:28 <Zao> Whatever encoding you use though, you still have the problem of combining characters.
05:54:01 <Lemmih> twanvl: compact-string isn't on hackage. Any reason for that?
05:54:05 <Zao> As you can stack diacritics almost endlessly, doing things like say "moving a caret" is still not O(1).
05:54:09 <BeelsebobWork> Axman6: a quad
05:54:15 <rog> Zao: i do realise that
05:54:24 <Axman6> ah, well still. http://www.haskell.org/pipermail/haskell-cafe/2008-November/051061.html
05:54:25 <lambdabot> Title: [Haskell-cafe] Need machine for DPH benchmarking, http://tinyurl.com/5nopex
05:54:32 <rog> Zao: it's a difficult problem
05:58:24 <chylli> I got an error when compile HBase : Could not find module `Control.Monad.Reader':
05:58:34 <chylli> Perhaps you haven't installed the profiling libraries for package mtl-1.1.0.2?
05:58:47 <chylli> but I'm sure I has installed mtl-1.1.0.2
05:58:58 <Lemmih> chylli: With profiling enabled?
05:59:08 <chylli> and HBase.cabal has set mtl as depended moudle
05:59:25 <chylli> Lemmih: seems yes
05:59:30 <chylli> runhaskell Setup.hs configure --enable-library-profiling --enable-executable-profiling
05:59:48 <chylli> this command is runned by Makefile
05:59:50 <Eelis> given   data A = X | Y deriving Enum   , why can't ghc derive Enum for   data B = Z A   ? it says "Can't make a derived instance of `Enum B' (`B' has non-nullary constructors)", but why should that be a problem? clearly the only possible values are Z X and Z Y, and it seems to me this should be trivially derivable.
06:00:11 <rog> Zao: is there a canonical form for a character including all associated diacritics?
06:00:37 <quicksilver> Eelis: in the general case, it can't be done.
06:00:38 <Zao> rog: There's several normalization forms, I believe.
06:00:46 <quicksilver> Eelis: I agree it would be nice for that case.
06:00:56 <quicksilver> Eelis: you can do it for newtype B = Z A
06:01:03 <quicksilver> (might be enough for your purposes)
06:01:17 <Eelis> quicksilver: i'm afraid my real B has multiple constructors :(
06:01:27 * quicksilver nods
06:01:29 <Eelis> quicksilver: i'll see if there's a ticket/proposal for this, and open one if not.
06:01:30 <Zao> NFD, NFC, NFKD, NFKC from memory.
06:01:36 <Zao> rog: http://unicode.org/reports/tr15/
06:01:37 <chylli> Lemmih: can you help me?
06:01:47 <lambdabot> Title: UAX #15: Unicode Normalization Forms
06:01:48 <quicksilver> it would need a more sophisticated scheme than the current one, Eelis
06:02:01 <quicksilver> Eelis: the current Enum instance has no way of telling if you've "got to the end"
06:02:10 <quicksilver> (and need to go onto the next constructor)
06:02:27 <Lemmih> chylli: Well, either install HBase without profiling support or reinstall mtl with profiling support.
06:02:30 <Eelis> quicksilver: well, personally i'm only interested in the combination (Enum, Bounded) anyway
06:02:52 <Eelis> quicksilver: but yeah, that's an important observation.
06:02:58 <rog> Lemmih: compactstring always does O(n) index access, by my reading of the code.
06:03:12 <quicksilver> Eelis: yes, it would be possible with a bounded + eq constraint
06:03:19 <quicksilver> Eelis: (you have to be able to compare against maxBound)
06:03:25 <Eelis> quicksilver: so the feature would be something like "allow derivation of Enum if all constructors only take Enum Bounded types"
06:03:37 <quicksilver> Enum Bounded Eq types :)
06:03:39 <rog> Zao: ta
06:03:40 <Eelis> right
06:03:50 <quicksilver> you can write this in DrIFT or Data.Derive I think.
06:03:53 <chylli> Lemmih: I even don't know what is profiling support
06:04:05 <chylli> Lemmih: Just remove that parameter ?
06:04:06 <Eelis> quicksilver: i'll have a look at those. thanks
06:04:59 <Eelis> quicksilver: is Data.Derive something brand new? it's not listed in http://haskell.org/ghc/docs/latest/html/libraries/
06:05:00 <lambdabot> Title: Haskell Hierarchical Libraries
06:05:16 <quicksilver> Eelis: that's just the ghc extralibs
06:05:21 <quicksilver> Eelis: you want to look at hackage :)
06:05:24 <Eelis> ok.
06:05:30 <Lemmih> Eelis: Most libraries aren't listed there.
06:05:40 <Eelis> Lemmih: i know, but i figured Data.Derive would be some GHC magic
06:05:47 <quicksilver> it uses TH.
06:05:50 <quicksilver> (which is GHC magic)
06:05:52 <quicksilver> in a sense.
06:05:56 <quicksilver> standardised magic though.
06:11:25 <hackage> Uploaded to hackage: PBKDF2 0.2
06:11:25 <hackage> Uploaded to hackage: PBKDF2 0.1
06:19:58 * BeelsebobWork ponders if anyone like dcoutts who knows about code.haskell.org projects is about
06:20:19 <thoughtpolice> Lemmih: i've replied to your email
06:20:31 <thoughtpolice> Lemmih: I tried to cc to lhc@projects.haskell.org, but it didn't seem to go through either
06:22:45 <RayNbow> :t GHC.Exts.sortWith
06:22:46 <lambdabot> Not in scope: `GHC.Exts.sortWith'
06:28:42 <thoughtpolice> BeelsebobWork: you probably want to talk to Igloo ?
06:29:26 <BeelsebobWork> possibly -- I'm trying to determine if we're allowed to used c.h.o projects for things not written in haskell, but directly related to haskell
06:30:11 <Igloo> BeelsebobWork: The profile viewer you mean? Sounds OK to me
06:30:23 <BeelsebobWork> cool, I'll go apply for a proj :)
06:30:30 <Igloo> Why isn't it written in Haskell, OOI?
06:30:43 <BeelsebobWork> because HoC is way too out of date :(
06:31:30 <Igloo> Ah
06:31:40 <BeelsebobWork> tis anoying -- it took me about 10000000 times longer than it should have to write a vaguely okayish parser
06:32:10 <Igloo> How long would it have taken you to update HoC?  :-)
06:32:21 <BeelsebobWork> pass -- I suspect in the order of months
06:32:27 <BeelsebobWork> (not knowing anything about how it works)
06:32:40 <BeelsebobWork> wheras the app so far has taken me 2.5 hours to write
06:33:02 <rhox> sersn
06:35:32 <nha_> are there any options for non blocking IO in haskell atm?
06:36:23 <nha_> if not is there any way to get whatever OS thread that multiplexes the IO to run at a lower priority
06:36:35 <Axman6> try forkIO
06:36:50 <Axman6> or forkOS maybe
06:37:32 <nha_> you cant change the priority of a haskell forkIO thread can you
06:37:47 <Axman6> you might be able to, but i don't think so
06:38:12 <Saul_> I've been doing some tests with associated data types (type families), but I am not able to derive instances for it
06:40:00 <Saul_> Is this just an omission in the implementation or is there a deeper reason that it won't work?
06:42:30 <dolio> What do you mean? Like generalized newtype deriving?
06:42:51 <Twey> Interesting that `data Foo = Foo Bar deriving Show; data Bar = Bar Foo deriving Show` doesn't kill GHC
06:42:56 <Saul_> no just general deriving, but for type families
06:43:25 <quicksilver> Twey: why should it? mutually recursive functions are fine
06:43:40 <dolio> So, you mean, say, deriving Show for an associated data?
06:43:48 <quicksilver> > let showFoo = "Foo " ++ showBar; showBar = "Bar " ++ showFoo in showFoo
06:43:50 <lambdabot>   "Foo Bar Foo Bar Foo Bar Foo Bar Foo Bar Foo Bar Foo Bar Foo Bar Foo Bar Fo...
06:43:51 <dolio> I've done that before and it worked.
06:44:09 <thoughtpolice> BeelsebobWork: I remember there was a copy of HoC somewhere around who's HEAD *did* build with GHC 6.8, etc..
06:44:19 <thoughtpolice> BeelsebobWork: I remember building it on leopard
06:44:37 <Saul_> dolio: That's what I meant, but that actually seems to work
06:44:38 <thoughtpolice> BeelsebobWork: there was also someone who wanted to step up as a maintainer, but I can't remember the name..
06:44:39 <BeelsebobWork> thoughtpolice: oh, interesting
06:44:51 <BeelsebobWork> I could never get it to build in anything post-jaguar
06:44:53 <Saul_> dolio: I'm trying to derive typeable
06:46:20 <thoughtpolice> nha_: forkIO-based threads don't really have a priority, they're not managed by the OS at all.
06:46:27 <dolio> Oh, hmm.
06:47:30 <thoughtpolice> BeelsebobWork: I'll look around for you - if I can find the copy that worked on GHC 6.8, then I think it would be worth it to try and hack it into GHC-6.10 state (which probably wouldn't be too difficult)
06:49:05 <BeelsebobWork> yeh, that would be more than slightly nice :)
06:49:13 <dolio> Saul_: Maybe Typeable is harder to derive for data families, and they haven't figured it out yet.
06:49:28 <quicksilver> nha_: forkIO is the standard way to get non-blocking IO in GHC
06:49:35 <thoughtpolice> BeelsebobWork: well here you go - http://code.google.com/p/hoc/ <- there does seem to be quite recent activity on the issue tracker
06:49:36 <lambdabot> Title: hoc - Google Code
06:49:45 <quicksilver> nha_: I.e., allow a thread to block on the IO but do something else meanwhile.
06:49:46 <BeelsebobWork> oh, it's a google project now!
06:49:47 <kenmcfa> hi, I'm trying to get my head round file handling in Haskell
06:49:48 <BeelsebobWork> I'm out of date
06:49:53 <BeelsebobWork> hope that means I can use it then
06:50:02 <kenmcfa> what's wrong with this code?
06:50:02 <kenmcfa> readFile "nouns.sg"
06:50:05 <Saul_> dolio: Perhaps, they do have a nice error message saying that it's a type family, so it's not that they just forgot it
06:50:15 <quicksilver> kenmcfa: nothing.
06:50:18 <thoughtpolice> BeelsebobWork: I would contact one of the maintainers/members if you're interested in getting it on 6.10
06:50:41 <kenmcfa> when I try and run a file containing just this line, it error's at me
06:50:41 <BeelsebobWork> thoughtpolice: I think the biggest stumbling block atm is actually that it doesn't use the Obj-C 2 runtime interface
06:50:41 <adekoba> #
06:50:45 <BeelsebobWork> so no garbage collection
06:50:54 <kenmcfa>  parse error (possibly incorrect indentation)
06:50:55 <thoughtpolice> yeah
06:50:58 <thoughtpolice> that's a super-bummer
06:51:09 <PeakerWork> BeelsebobWork: Hey, any chance you've seen my bug report on the mailing list?  Event -> Behavior -> snapshot with Event -> stepper to Behavior ->   buggy behavior?
06:51:10 <thoughtpolice> factor recently switched to using the objc-2.0 interface
06:51:30 <thoughtpolice> you lock out everybody before leopard but it's probably worth it given the advantages
06:52:23 <kenmcfa> so why won't my program compile?
06:52:43 <quicksilver> kenmcfa: a file just containing that line is not a program.
06:52:43 <thoughtpolice> kenmcfa: paste the code here - http://hpaste.org
06:52:47 <BeelsebobWork> PeakerWork: I did indeed
06:52:57 <BeelsebobWork> I'll be interested to see what conal says about that one
06:52:58 <quicksilver> kenmcfa: a program consists of some import statements, and a list of definitions.
06:53:03 <quicksilver> one of the definitions should be 'main'
06:53:07 <quicksilver> which has type 'IO ()'
06:53:18 <quicksilver> what you wrote was not a program. it was just a lone expression.
06:53:30 <dolio> Saul_: They are a little wierd. Associated data is always at least a Typeable1 by kind, but I don't think you can give a proper Typeable1 instance (same for higher-order associated data).
06:53:30 <kenmcfa> http://hpaste.org/12434
06:53:32 <quicksilver> that's like asking a C compiler to compile a file containing "1+1"
06:53:45 <kenmcfa> well, i was trying to run it with GHCI
06:53:53 <kenmcfa> so I can see how to work it
06:53:58 <quicksilver> main = do d <- readFile "nouns.sg"
06:54:03 <quicksilver>          return ()
06:54:07 <quicksilver> now, that's a program.
06:54:12 <quicksilver> altough I miscounted spaces.
06:54:42 <kenmcfa> ah, right
06:54:54 <kenmcfa> I'm a tad of a Haskell newbie in case you didn't guess :p
06:55:03 <Axman6> kenmcfa: you're writing as if it were a procedural program. you could define a function as being f = readFile "nouns.sg"
06:55:04 <kenmcfa> thanks, I'll work from there
06:55:19 <Saul_> dolio: I don't see that, is that due to how it's implemented?
06:55:22 <Axman6> wow, that was talking fail++
06:55:42 <ddarius> quicksilver: main :: IO a
06:55:45 <dolio> Saul_: So the deriving needs to be informed by the distinction between index (the a in Foo a :: * -> *) and parameter (the extra * in Foo a :: * -> *).
06:55:54 <ddarius> main = readFile "nouns.sg" is a perfectly legitimate definition.
06:55:54 <dolio> Saul_: See what?
06:56:02 <Axman6> kenmcfa: you might want something like 'main = do { x <- readFile "nouns.sg"; print x}'
06:56:05 <ddarius> Meaningless, but typeable.
06:56:33 <Saul_> dolio: But at the moment that the deriving is done, you don't have a Foo, but a Foo Bar, which has kind *
06:56:34 <nha_> quicksilver: well my problem is i need one thread to run at a higher priority than everything
06:56:42 <nha_> and do some IO multiplexing in the background
06:56:58 <nha_> i just made some FFI calls to the OS priority functions for the forkOS thread
06:57:12 <nha_> but i just read that the haskell runtime is responsible for scheduling bound threads too
06:57:24 <nha_> so im not sure if that even works
06:57:27 <quicksilver> nha_: yes, the bound threads thing is quite complex.
06:57:31 <quicksilver> I'm not sure I can explain it.
06:57:53 <dolio> Saul_: Right, but that's not usually the way deriving for Typeable is done. And I don't know enough about GHC's internal deriving mechanisms to know if that would cause problems.
06:57:53 <quicksilver> are you saying you have data arriving/leaving so fast that the IO threads are essentially always available to run?
06:58:17 <quicksilver> and yet you want the main thread to run at higher priority?
06:58:17 <adekoba> is there any way to have default values in data declarations?
06:58:44 <Saul_> dolio: Neither do I
06:58:45 <nha_> the IO thread shoulds be fairly active when theyre run
06:58:51 <Axman6> data Foo = Foo { foo = 10 :: Integer} maybe?
06:58:55 <Saul_> dolio: Thanks for your insights though
06:59:08 <kenmcfa> ok, next problem, how do I turn an IOString into a string?
06:59:30 <Valodim> step 1: read some hours worth of monad introduction
06:59:48 <Axman6> kenmcfa: where are you learning haskell from?
06:59:57 <RayNbow> kenmcfa: the short answer is: you don't
07:00:00 <daf>  you (( string ))
07:00:08 <daf> (()) is the IO monad
07:00:11 <daf> you can't take the string out
07:00:13 <kenmcfa> erm, mostly google
07:00:14 <daf> but you can go in there
07:00:26 <daf> and do what you want to do
07:00:34 <Axman6> because you're doing stuff that's not usually taught as an introduction to haskell. work on writing normal functions before trying to work with IO
07:00:39 <quicksilver> the other short answer is "you use <- to get a String out of an IO string"
07:00:40 <ddarius> There's no string "inside."  There is no "inside."
07:00:47 <Saul_> kenmcfa: You might want to start at the beginning, by following an actual tutorial
07:00:50 <PeakerWork> kenmcfa: You can think of (>>=) as "temporarily" translating an (IO String) to a String, and then translating the result back from a to (IO a) again
07:00:52 <kenmcfa> I learned the basics in a uni module, but it didn't have anything as advanced as file handliong
07:00:56 <thoughtpolice> Lemmih: also apparently the mailing list is working now :]
07:01:11 <PeakerWork> kenmcfa: oops, actually not translating it, just forcing you to return one that is in (IO a) and then the whole result is also in (IO a)
07:01:23 <Axman6> kenmcfa: have a look at http://book.realworldhaskell.org/read/ specifically the IO stuff :)
07:01:25 <lambdabot> Title: Real World Haskell
07:01:32 <Axman6> and then, buy the book ;)
07:01:37 <sheyll> hi
07:01:38 <daf> kenmcfa: you've arrived at the IO wall
07:01:47 <kenmcfa> I've asked for that book for christmas actually
07:01:54 <Valodim> haha, IO wall
07:01:57 <Axman6> ah, excellent
07:02:00 <sheyll> anyone using gentoo + haskell overlay?
07:02:03 <Valodim> IO (Wall)
07:02:12 <kenmcfa> but I guess reading it online will help
07:02:14 <daf> kenmcfa: getting over it can be frustrating, but it's worth it :)
07:02:36 <kenmcfa> or I could switch to java...
07:02:40 <daf> no no
07:02:42 <daf> come over
07:02:43 <daf> share our pain
07:02:50 <daf> er, joy
07:02:53 <daf> I meant joy
07:03:00 <kenmcfa> yes of course
07:03:25 <sheyll> I cannot build ghc 6.10.1 on gentoo from the haskell overlay, the build complains that an interface file is not o.k.
07:03:32 <Valodim> truthishly, we are all just sadists and tell people to learn haskell to feed off their pain >:)
07:03:59 <kenmcfa> what is the difference between String and IO String?
07:04:04 <Axman6> kenmcfa: i've been doing both haskell and java at uni... haskell is far more fun
07:04:05 <RayNbow> kennyv: monads have this interface, a contract with you as a programmer... you are only allowed to play with the contents as long as you promise to put it back in the same kind of container
07:04:10 <RayNbow> erm
07:04:10 <daf> kenmcfa: the IO String is tainted
07:04:13 <RayNbow>  * kenmcfa
07:04:27 <RayNbow> (my tab skills are failing)
07:05:57 <ddarius> kenmcfa: What's the difference between String and Maybe String?
07:06:18 <Axman6> good question
07:06:20 <kenmcfa> I don't know
07:06:33 <Axman6> kenmcfa: have you used Maybe?
07:06:35 <ddarius> kenmcfa: Figure out type constructors, then worry about monads.
07:06:40 <PeakerWork> kenmcfa: a String is a simple list of chars. an (IO String) is a description of side effects (an imperative program, actually) that has a String result
07:06:43 <kenmcfa> sometimes maybe String has maybe in front of it, and sometimes it says nothing
07:06:49 <PeakerWork> kenmcfa: has a string result, when it is actually put to run imperatively
07:07:09 <Axman6> well, Just, not maybe, but yeah, sort of
07:07:24 <PeakerWork> kenmcfa: The trick is that the only way for you to "run" the (IO String) program, is to have it be a part of your "main"
07:07:39 <kenmcfa> and all i want my program to do for now is take the output string from the IO String
07:08:22 <Axman6> kenmcfa: ok, in the do {x <- readFile "file.txt" ...} thing, the x is a String
07:08:48 <adekoba> Axman6: yeah, that doesn't seem to work
07:08:54 <Axman6> :t readFile
07:08:55 <lambdabot> FilePath -> IO String
07:08:57 <PeakerWork> kenmcfa: then bind it to the next thing you want to do with the string
07:09:01 <adekoba> Axman6: the default data thing
07:09:04 <Axman6> adekoba: what doesn't?
07:09:24 <Axman6> oh right, sorry then. i'm not too sure ab out record syntax
07:09:44 <PeakerWork> kenmcfa: Some ways to bind it are:  yourIOString >>= \x -> print x       or     yourIOString >>= print        or    do { x <- yourIOString ; print x }
07:10:09 <kenmcfa> oh god, now I can see why haskell isn't the most popular language out there
07:10:12 <adekoba> hm. Anyone aware of a way to assign default values to in data declarations?
07:10:12 <Axman6> kenmcfa: i suggest you read http://book.realworldhaskell.org/read/io.html
07:10:13 <lambdabot> Title: Chapter 7. I/O
07:10:23 <PeakerWork> kenmcfa: the "trick" is that when you bind to another action, your result is an "imperative program" (some (IO a) value) that is a sequencing of the original program you had to generate that string, and the next action you bound
07:10:39 <conal> irc
07:10:39 <conal> oops
07:10:41 <Axman6> kenmcfa: this stuff isn't hard, it's just different, and a little difficult to get used to
07:10:51 <PeakerWork> kenmcfa: Other languages also force you to do the same thing, In Haskell its simply not a primitive operation
07:10:51 <RayNbow> yes conal, this is IRC... welcome ;)
07:11:00 <PeakerWork> conal: hey, any chance you took a look? :)
07:11:14 <PeakerWork> kenmcfa: What other languages do you know/use?
07:11:17 <conal> PeakerWork: no.  sry. :(
07:11:34 <PeakerWork> conal: even after I flooded the whole mailing list with my bug :-)
07:11:59 <daf> kenmcfa: imprisoning side-effects in the IO monad allows the rest of Haskell to have the nice properties it has
07:12:00 <kenmcfa> Revolution and Java
07:12:11 <conal> PeakerWork: i had a super-inspired day yesterdayj.  Good stuff coming.
07:12:19 <PeakerWork> conal: great!
07:12:25 <Axman6> hmmmmm... someone needs to make a irc-like protocol, mixed with a wiki. so you could show people code, and live edit it and stuff...
07:12:33 <kenmcfa> is there a Haskell IDE of some sort?
07:12:35 <PeakerWork> conal: blog stuff, or library release stuff, or both? :)
07:12:36 <conal> Axman6: yes!
07:13:01 <Axman6> conal: gonna add that to your crazy X replacing monster of awesomeness?
07:13:10 <conal> PeakerWork: it'll be both.  i'm finally getting into comonads, and i can see why they're perfect for FRP.
07:13:19 <ski_> ("X replacing" ?)
07:13:43 <Axman6> X11 fails and needs to die (and http/html too apparently)
07:13:44 <conal> Axman6: it'll simplify/unify things.
07:13:47 <PeakerWork> conal: really? which of the types are comonads?
07:13:47 <kenmcfa> hmm, file handling isn't really what I want to be learning from this
07:13:52 <conal> simplify/generalize
07:13:56 <kenmcfa> so I've solved my problem!
07:13:59 <conal> PeakerWork: Behavior
07:14:05 <Axman6> kenmcfa: what do you mean?
07:14:09 <kenmcfa> put the contents of my file inside the Haskell source
07:14:14 <conal> PeakerWork: maybe event too.  haven't loked.
07:14:18 <Axman6> heh, good work :P
07:14:45 <ddarius> Yeah, Behavior is definitely a comonad.  Gives a notion of "now"
07:15:03 <conal> ddarius: exactly :)
07:15:13 <Axman6> that's the way i do it when i'm making things from project euler that requires large pieces of text to be converted into lists of lists or something
07:15:20 <ski_> `Behaviour a' includes the current time ?
07:15:23 <conal> and it gives a very nice explanation of my techniques for removing space leaks.
07:15:36 <quicksilver> ddarius: is it? what is extract :: Behaviour a -> a ?
07:15:40 <ddarius> conal: It'll be an interesting blog article.
07:15:45 <quicksilver> ski_: implicitly, yes.
07:15:50 <conal> ddarius: yeah.  i'm pretty excited about it.
07:15:56 <ddarius> quicksilver: \beh -> at beh 0
07:16:04 <conal> yeah.
07:16:06 <litb> hello all
07:16:06 <quicksilver> hmm.
07:16:11 <BeelsebobWork> ski_: Behavior a can be thought of conceptually as Time -> a
07:16:11 <ski_> oh .. you translate the time ?
07:16:15 <conal> in the process, i'm finally going to go consistently with relative time.
07:16:16 <BeelsebobWork> (it's not, but it can be thought of as it)
07:16:24 <litb> data foo = MakeFoo1 Int Bool | MakeFoo2 Int
07:16:29 <litb> would that be valid?
07:16:35 <ski_> BeelsebobWork : yes .. i was wondering if it instead was `(Time,Time -> a)'
07:16:40 <ddarius> data Foo = ...
07:16:42 <BeelsebobWork> ski_: no
07:16:43 <ddarius> But otherwise yes.
07:16:45 <quicksilver> litb: foo needs a capital F
07:16:46 <litb> i mean, the one ctor takes one value, but the other ctor takes two?
07:16:47 <sheyll> help! I cannot build haddock (using gentoo + haskell overlay + "doc" in USE flags)
07:16:50 <sheyll> src/Binary.hs:96:27: Module `Control.Exception' does not export `throwDyn'
07:16:51 <DMKE> hi
07:16:51 <litb> quicksilver: oh ok
07:16:53 <quicksilver> litb: yes, that's fine.
07:16:53 <ddarius> ski_: Time is a monoid.
07:17:01 <ski_> (but with `0' as "current" time .. sliding along as time ticks ..)
07:17:04 <Axman6> @src Maybe
07:17:05 <lambdabot> data Maybe a = Nothing | Just a
07:17:10 <Axman6> litb: ^^
07:17:16 <quicksilver> ddarius: that's not very nice operationally though.
07:17:27 <Axman6> one takes just one thing, and the other takes nothing :)
07:17:27 <litb> i thought it was something like   data Foo a b = MakeFoo1 Int Bool | MakeFoo2 Char String  ?
07:17:31 <quicksilver> there is nothing special about t=0
07:17:37 <quicksilver> why choose that one?
07:17:43 <litb> oh i see. the character is just to have a type variable
07:17:49 <ddarius> quicksilver: Not in absolute time, no.
07:18:13 <conal> quicksilver: two possible reasons: it's the zero of a vector space (relative time), and it's the mempty of the Sum monoid.
07:18:23 <Axman6> litb: you might have something like data Foo a = MakeFoo1 a Bool | MakeFoo2 a
07:18:28 <conal> and sum is used for relative time
07:18:33 <conal> Sum
07:19:28 <conal> Absolute time Reactive uses the Max Monoid, while relative time Reactive uses the Sum monoid
07:20:06 <conal> which also eliminates the awkward bit about events having an applicative instance but not a useful one.
07:20:26 <ski_> ("not useful one" ?)
07:21:43 <PeakerWork> conal: ah, cool, I remember infinite streams are comonads, and one can see Event/Behavior as infinite streams, sort of
07:22:16 <ddarius> PeakerWork: Indeed. Natural numbers are a monoid and Stream x ~ Natural -> x
07:22:30 <ddarius> Behavior is just the continuous generalization.
07:22:39 <conal> ski_: the awkward Applicative bit is in section 2.2.4. of the Reactive paper.
07:22:51 <quicksilver> I don't understand how relative time applies in this context.
07:22:52 <ski_> conal : ty
07:22:55 <conal> PeakerWork: yeah.
07:23:02 <quicksilver> suppose "foo :: Behaviour Double"
07:23:16 <quicksilver> and "bar = extract foo"
07:23:21 <quicksilver> now bar :: Double
07:23:26 <quicksilver> is a simple haskell value
07:23:29 <quicksilver> (time independent)
07:23:33 <conal> right
07:23:38 <quicksilver> how can that depend on a 'relative' notion of zero time?
07:24:00 <quicksilver> each behaviour "comes with" it's own origin?
07:24:27 <conal> quicksilver: you could say that.  more simply, you can just shift the behavior.
07:24:45 <Axman6> kenmcfa: you should stick around here, #haskell is, IMHO, the single best place to learn haskell.
07:24:47 <quicksilver> so behaviours have a current time, like the focus of a zipper?
07:25:14 <quicksilver> s/behaviours/this implementation of behaviours/
07:25:14 <kenmcfa> yeah, I have another question coming up I think :)
07:25:40 <conal> quicksilver: yeah.  but simpler.  like 0 being an implicit index into a list/stream.
07:25:57 <conal> quicksilver: you could keep an index/time or not.
07:25:59 <conal> i wouldn't.
07:26:08 <kenmcfa> nope, I managed
07:26:14 <conal> well, maybe, for the 'Fun Time' part
07:26:24 <kenmcfa> but yeah I'll hang around, maybe learn me some Haskell while I'm here
07:26:33 <quicksilver> conal: well whether you actuall have to store it or not is an implementation detail.
07:26:37 <conal> quicksilver: as an optimization, to avoid lost of (+ d1) . (+ d2) . ....
07:26:41 <quicksilver> nod
07:26:55 <conal> quicksilver: right.  so conceptually, i wouldn't have them at all.
07:26:59 <Axman6> with the likes of conal, quicksilver, BeelsebobWork and co talking about the stuff they talk about... probably not much you'l understand kenmcfa :P
07:27:13 <conal> quicksilver: since (T->a) is simpler than (T->a, T)
07:27:24 <quicksilver> sounds like a dramatic change from the current implementation, to me.
07:27:30 <ski_> quicksilver : compare `next (past,x0,x1:future) = (x0:past,x1,future)' with `wait d f = f . (d +)')
07:27:40 * quicksilver nods
07:27:51 <quicksilver> the current implementation throws away the past though.
07:27:55 <quicksilver> well, mine does.
07:28:01 <quicksilver> I think that's quite an important optimisation, too :)
07:28:02 <conal> quicksilver: mine also.
07:28:20 <quicksilver> otherwise all programs have an  O(n) space leak
07:28:25 <Axman6> don't worry guys, that;s what the wayback machine is for
07:28:25 <conal> quicksilver: so we can use a simpler stream zipper, which is just a stream.
07:28:52 <conal> Axman6: :)
07:29:05 <Axman6> and time machine
07:29:43 <ski_> (so `wait d' would require `d >= 0' ?)
07:30:22 <conal> ski_: yeah.  only positive delta times allowed.
07:30:31 <conal> ski_: which makes for a nice monoid
07:30:40 <conal> s/positive/non-negative
07:30:42 <ski_> even if long-term delta would increase ?
07:30:50 <conal> ?
07:31:41 <conal> ski_: i don't understand the question.
07:31:54 <ski_> (i.e. could you locally have negative delta, e.g. for ease of expressing something, but on a larger scale require increasing (or at least non-decreasing) delta))
07:32:46 <conal> ski_: oh, i see. thx.  i don't know.  the non-negative restriction might not be necessary.  one might still bound memory of the past.
07:33:21 <DMKE> hello again
07:33:31 <ski_> hello back
07:33:34 <DMKE> how do i create random strings?
07:33:59 <ski_> you should have some idea of what your strings should look like
07:34:00 <conal> in the "essence of dataflow" paper, the stream zipper has a finite past, momentary present, and infinite future.  it struck me that the past could also be imperfect.  e.g., bounded and/or degraded.  i.e., a representation not of the past but of the current memory of the past.
07:34:45 <conal> i bet there are a lot of interesting and useful behavior-zipper variations, all satisfying the comonad laws.
07:34:58 <kenmcfa> This may be too advanced for me, but...
07:35:17 <kenmcfa> ... how do I make a function take different numbers of arguments?
07:35:17 <ski_> DMKE : probably you can do an `Arbitrary' instance, using `size' to only make strings of a maximum size, recursively selecting either the empty string or a random character added in front of a random string with size decremented
07:35:29 <quicksilver> kenmcfa: the short answer is that you don't.
07:35:41 <kenmcfa> oh well
07:35:45 <quicksilver> kenmcfa: fixed size argument lists is one of the compromises inherent in the haskell type system
07:35:49 <twanvl> Lemmih: the main reason why compact-string isn't on hackage is that I have never gotten around to uploading it. I will get on it right now.
07:35:51 <quicksilver> you can have an argument which is a list, though
07:35:56 <DMKE> currently i'd like to test some functions that take strings as parameter
07:35:57 <kenmcfa> yeah
07:35:59 <quicksilver> (and lists can have a variable number of members)
07:36:12 <kenmcfa> I think in this case I'll just make one of my arguments 0
07:36:12 <DMKE> i'm programming haskell since 7 days ._.
07:36:13 <quicksilver> kenmcfa: the longer answer is you can pull off some tricks with typeclasses
07:36:18 <ski_> conal : you mean like GC erasing chunks of the past, using some weak references ?
07:36:19 <quicksilver> kenmcfa: take a look at printf
07:36:39 <quicksilver> kenmcfa: btu I don't really recommend that approach.
07:36:51 <kenmcfa> right thanks
07:37:04 <conal> ski_: yeah.  nice analogy.
07:37:38 <conal> ski_: also releasing high-precision descriptions and holding onto low-precision.
07:37:39 <quicksilver> conal: what is cojoin :: Behaviour (Behaviour a) -> Behaviour a ?
07:37:43 <quicksilver> erm
07:37:50 <conal> quicksilver: !! that's what got me started.
07:37:51 <quicksilver> switch that arrow please :)
07:37:58 <DMKE> um, maybe it would nice to know how i create a random character, ski_
07:38:03 <ski_> conal : yeah, that'd be nice, too
07:38:33 <ski_> DMKE : probably there's already an `arbitrary :: Gen Char'
07:38:46 <ddarius> quicksilver: Precomposition with (+)
07:38:53 <DMKE> okay
07:39:06 <conal> quicksilver: i'm designing a FRP for modular, leak-free interaction.  in the process i came up with a function that has the signature of cojoin on Behavior.  and i got to wondering if it is cojoin.
07:39:20 <quicksilver> ddarius: I don't follow.
07:39:41 <conal> quicksilver: you'll probably enjoy the answer more if you discover it.
07:39:57 <Fallen_Demon> @help
07:39:58 <conal> quicksilver: and meanwhile assume ddarius is talking nonsense
07:39:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:40:06 <Fallen_Demon> @help list
07:40:06 <lambdabot> list [module|command]
07:40:06 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
07:40:14 <conal> ddarius: (mappend)
07:40:21 <ddarius> conal: I was specializing.
07:40:33 <conal> ddarius: yeah.
07:40:46 <ddarius> quicksilver: It's key that "time" is a monoid and extract uses mempty.
07:41:21 <conal> quicksilver: if you forget about this Monoid stuff, and just play with the question very concretely, the answer will come.
07:41:35 <ski_> DMKE : sorry, i don't know what i'm thinking .. `type String = [Char]' and there already are instances of `Arbitrary' for lists and characters .. so just using `arbitrary :: Gen String' should work
07:41:38 <conal> quicksilver: and then you can see that it's inevitable.
07:41:42 <ddarius> Well if you want to be not Formalist about it...
07:42:04 <ddarius> conal: It's inevitable from a purely formal approach as well.
07:42:18 <conal> ddarius: that's what i meant.
07:42:31 <lilac> conal: \b t1 t2 -> b (t1 + t2)?
07:42:43 <lilac> (in the semantic domain)
07:43:05 <conal> lilac: maybe
07:43:07 <conal> ;)
07:43:45 <conal> i just thought since quicksilver has been tinkering so deeply with frp he might like to discover the answer.  i could be mistaken.
07:43:53 <Fallen_Demon> OK haskellians, how do I grab a web page? Or can someone point me at some ghc networking documentation? The package I downloaded only has a copyright notice in it :(
07:44:35 <Axman6> @hoogle http
07:44:35 <lambdabot> package HTTP
07:44:35 <lambdabot> package HTTP-Simple
07:44:35 <lambdabot> Text.XHtml.Frameset httpequiv :: String -> HtmlAttr
07:44:43 <Axman6> @hoogle curl
07:44:44 <lambdabot> package curl
07:44:44 <lambdabot> package download-curl
07:44:44 <lambdabot> Language.Haskell.Lexer LeftCurly :: Token
07:45:02 <Axman6> Fallen_Demon: how are those for starters?
07:45:10 <Fallen_Demon> Awesome :) Thanks
07:46:06 <quicksilver> conal: Yes, I think I see by thinking in terms of moving focusses.
07:46:11 <lilac> conal: am i right in recalling that Behaviour isn't a monad?
07:46:19 <quicksilver> conal: I don't currently see how this is useful, though )
07:46:22 <conal> lilac: it is a monad semantically.
07:46:28 <lilac> but not in the implementation?
07:46:39 <conal> lilac:  yeah.
07:46:50 <lilac> it seems like it's a monad in an absolute-time sense and a comonad in a relative-time sense
07:47:20 <conal> lilac: hm.  interesting.
07:47:45 <conal> i think an absolute-time behavior comonad would simply replace Sum by Max
07:47:59 <conal> so that cojoin = \ b t1 t2 -> b (t1 `max` t2)
07:48:12 <lilac> hmm, that'll take some pondering :)
07:48:26 <conal> and currently Reactive does use the Max monoid for time.
07:48:35 <lilac> so it's still forgetting the past, but doing so in a nastier way :)
07:48:56 <conal> i don't know
07:49:09 <ski_> DMKE : try importing `Debug.QuickCheck' and call `quickCheck f' where `f' is your function that takes a string
07:49:22 <quicksilver> lilac: the current reactive specification doesn't explicitly forget the past.
07:49:34 <conal> right
07:49:37 <quicksilver> lilac: the implementation forgets the past, by traversing the recursive types
07:49:37 <lilac> quicksilver: right.
07:49:39 <DMKE> ski_: that wasn't working
07:49:48 <quicksilver> (just like lists forget their heads if you traverse them)
07:50:04 <lilac> quicksilver: but the comonadic formulation seems to be about avoiding dependence on the past
07:50:06 <quicksilver> I have to store my Behaviours and Reactives in IORefs in my scaffold
07:50:11 <quicksilver> because they have to be updated.
07:50:16 <quicksilver> Events too indeed.
07:50:31 <conal> eep
07:50:44 <quicksilver> well it's only in the scaffold :P
07:51:01 <conal> yeah
07:51:12 <quicksilver> to communciate between the callbacks.
07:51:18 <quicksilver> of, e.g., GLUT
07:53:41 <DMKE> ski_: i also tried to use the Random module, but i have no idea how i can use a variable of `IO Int' type
07:54:26 <quicksilver> DMKE: don't use the IO one.
07:54:31 <quicksilver> :t random
07:54:32 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
07:54:38 <ski_> (DMKE : it was awhile ago i used QC .. the source i'm looking at atm has `instance Arbitrary Char' .. but it appears that's not available in the current library (not in haddock at least))
07:54:50 <DMKE> kay
07:54:54 <quicksilver> > random (mkStdGen 42) :: (Int,StdGen)
07:54:56 <lambdabot>   (-3907187990116499535,2060101257 2103410263)
07:55:04 <quicksilver> just use 'random' or one of its variants
07:55:07 <ski_> DMKE : did you get an error something like "No instance for (Arbitrary Char)" ?
07:55:13 <quicksilver> and thread the seed in whichever way looks nicest.
07:56:00 <DMKE> uhm, i was trying something else...
07:56:14 <DMKE> one moment please...
07:57:49 <adekoba> hi there. I've been trying to get default's to work, and the best alternative I could come up with was to make a key/value list. Is there a better way to approach this? http://hpaste.org/12439
07:57:56 <conal> quicksilver: my motivation for behavior cojoin comes from accessing input in new phases of a behavior (i.e., after event occurrences).
07:58:03 <adekoba> default in data declarations, that is
07:58:28 <quicksilver> conal: interesting.
07:58:42 <quicksilver> conal: I sortof had that working by summing events anyway
07:59:07 <ski_> (conal : .. so maybe you could use `(=>>)' instead ?)
07:59:11 <conal> quicksilver: if i hang onto the original input while waiting for an event, i get a space leak and a big post-event catch-up latency.
07:59:39 <quicksilver> conal: Oh, interesting.
07:59:40 <conal> ski_: is that the comonadic operator?
07:59:47 <quicksilver> conal: I didn't poke hard enough to hit that problem.
07:59:58 <ski_>   (<<=) :: Comonad w => (w a -> b) -> (w a -> w b)
07:59:59 <quicksilver> adekoba: that looks fine. or you could make taglist a function.
08:00:04 <ski_>   (=>>) = flip (<<=)
08:00:16 <quicksilver> adekoba: taglist TALB = Text; taglist TCOM = Text;
08:00:19 <quicksilver> ...
08:00:27 <conal> ski_: yes indeed, that's my solution, though it's sometimes easier for me to think in terms of cojoin
08:01:06 <ski_> i'd assume sometimes one and sometimes the other is more natural for the problem formulation ..
08:01:11 <adekoba> quicksilver: yeah, it works, but thing is, I have to do lookups everytime. There should be a way to have it inherently a part of the constructor, no?
08:01:23 <conal> quicksilver: to deal with that problem, i had an operation aging :: Behavior i -> E a -> E (a, Behavior i)
08:01:35 <quicksilver> adekoba: I don't see why.
08:01:39 <quicksilver> adekoba: a data type is a data type.
08:01:48 <adekoba> yeah, I suppose
08:01:59 <quicksilver> adekoba: I don't really see what you're doing, though.
08:02:12 <adekoba> my purpose?
08:02:47 <conal> quicksilver:  that "ages" (left-trims) the input behavior.  then i realized that i could define again via snapshot if i had another function Behavior a -> Behavior (Behavior a)
08:03:02 <quicksilver> conal: *nod* yes I see what you're doing.
08:03:10 <conal> quicksilver: which is like 'tails', but continuous
08:03:16 <adekoba> quicksilver: http://hpaste.org/12439#a1 ... for id3 tagging
08:03:18 <quicksilver> conal: I did wonder about this problem.
08:03:49 <quicksilver> adekoba: making taglist a function seems the way to do it, to me.
08:04:05 <quicksilver> conal: I wondered if I needed to structure my code to make sure things were sampled often enough
08:04:05 <adekoba> quicksilver: ok, sounds good. Thanks for the help.
08:04:06 <ski_> adekoba : maybe using a function `taglist' where `taglist TALB = Text; taglist TCOM = Text; ...' would be better for whatever you want ?
08:04:15 <conal> quicksilver: i'm making a layer on top of behaviors & events that handles this stuff automatically and efficiently.
08:04:25 <adekoba> ski_: yeah, quicksilver mentioned something like that. I think I'll go that route
08:04:40 <quicksilver> conal: I wondered if something bad would happen if I stayed in one 'mode' for 3 hours and the other 'mode' was sitting in the background accumulating events until it was its turn.
08:04:55 <quicksilver> conal: I discussed it briefly with BeelsebobWork but I didn't articulate it clearly.
08:04:58 <ski_> adekoba : or if you want `Text' or `Date' to be a static property of `IDList', maybe you can try `data IDList :: * -> * where TALB :: IDList Text; ...' (a GADT datatype)
08:05:13 <quicksilver> and it wasn't a problem with the very limted example I wrote.
08:05:20 <conal> quicksilver: yeah. sometimes that stuff is hard to talk about.
08:05:49 <conal> maybe because our language isn't very good at explicit time manipulation
08:05:53 <ski_> (so then `Text' and `Date' are not values any longer .. but types)
08:06:06 <adekoba> ski_: yes, that is what I was looking for! For it to be a static property
08:06:13 <conal> because we think of time as a given
08:06:17 <conal> mabye
08:06:18 <conal> maybe
08:06:26 <ski_> adekoba : probably you need `data Text' and `data Date', then
08:06:50 <adekoba> ski_: ok, I'll try it out
08:07:16 <quicksilver> conal: from a more operational perspective, I would say the problem is that reactive has clear semantics but unclear operationals ;)
08:07:26 <ski_> (adekoba : note that using GADTs is a GHC extension (and the `:: * -> *' is another extension that you could avoid in this case, if you insist)
08:07:27 <ski_> )
08:07:27 <quicksilver> conal: so it's easy to see code is correct, but hard to see its space profile.
08:07:44 <quicksilver> conal: you will note that this criticism is levelled at haskell as a whole; arguably Reactive makes it more extreme.
08:08:19 <conal> totally.  i remember a very entertaining talk by colin runciman about exactly that point.
08:08:40 <conal> and before we can improve something we have to see it
08:08:51 <quicksilver> Reactive's failure to have a clear operational semantics was one of the big stumbling blocks for me.
08:08:53 <conal> or "measure" as kelvin said
08:08:55 <Axman6> rawr, being an op sucks soemtimes -_-
08:09:08 <quicksilver> I like to understand what the computer is doing, even if once I know, I will trust it to do the right thing.
08:09:53 <conal> quicksilver: i guess that opacity plus it not always working well behind the scenes.  right?
08:10:24 * gwern discovers that GHC's -Wall is buggy. WHAT DO I BELIEVE IN NOW
08:10:45 <conal> quicksilver: and i too see this combination as an achilles heel of FP
08:10:50 <quicksilver> conal: well when I started looking there wasn't really an "it" to work or not work ;)
08:10:55 <quicksilver> conal: just a paper to read.
08:11:16 <quicksilver> so I started trying to write somethign and found it harder than expected :)
08:11:25 <hackage> Uploaded to hackage: lax 0.1.0.0
08:12:02 <ddarius> @hackage lax
08:12:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lax
08:12:05 <conal> quicksilver: me too.  and i've been doing functional animation since 1992 or so.
08:12:07 <gwern> (lax? as in exlax? or aflax? is it short for laxative? 'lax - the package so awesome it will make you dirty your drawers')
08:14:22 <lilac> conal: my mental model of the operational semantics is that Events work by push, and that Behaviours are really functions of time, which get evaluated by need. am i miles off?
08:15:46 <conal> lilac: you're on the right road.
08:16:03 <conal> lilac: add that behaviors are built (in part) from events.
08:16:12 <quicksilver> lilac: although that makes them sound more different than they are
08:16:22 <conal> lilac: so there's both pushing and pulling in behaviors
08:16:33 <quicksilver> lilac: Behaviours are a special kind of Reactive; Reactives and Events are built by mutual recursion on each other.
08:17:00 <matveev> I remember there was a tool to guess the sequence expression in lambdabot. How do I check this: [1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627]
08:17:01 <quicksilver> conal: hmm. I am beginning to see the merits of relative time.
08:17:15 <quicksilver> conal: the existing formulation of Reactive is already observable "At time 0"
08:17:25 <quicksilver> \(v `Stepper` _) -> v
08:17:42 <quicksilver> conal: but, you're not allowed to do that. You have to check if any events have arrived first.
08:17:53 <lilac> @oeis [1,2,3,5,7,11,15,22,30]
08:17:53 <conal> no you don't
08:17:53 <lambdabot>  Sequence not found.
08:17:58 <ski_> @help oeis
08:17:58 <lilac> @oeis 1,2,3,5,7,11,15,22,30
08:17:58 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
08:17:59 <lambdabot>  a(n) = number of partitions of n (the partition numbers).
08:17:59 <lambdabot>  [1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1...
08:18:12 <conal> since the initial value isn't dependent on event occurrences.
08:18:25 <quicksilver> conal: you do in an absolute time framework
08:18:31 <quicksilver> if you want to observe 'now'
08:18:37 <quicksilver> because 'now' might be after the first event
08:18:39 <quicksilver> (or more)
08:18:55 <conal> quicksilver: okay, although there's no now
08:19:04 <conal> quicksilver: but there is -infinite
08:19:12 <lilac> so a Reactive is a real function of time, and a Behaviour a is an Event (Reactive a) ?
08:19:13 <conal> quicksilver: and you can't really inspect that initial value in current Reactive, since the representation is hidden
08:19:26 <conal> lilac: they're both functions of time.
08:19:31 <quicksilver> conal: right. I just meant you could write the function, internally.
08:19:33 <conal> lilac: a reactive is a step function.
08:19:39 <conal> quicksilver: oh. yeah.
08:19:59 <quicksilver> I like to think of there being a now.
08:20:04 <lilac> conal: ok. i was thinking of events as step functions for some reason :)
08:20:34 <conal> lilac: yeah.  they're kind of almost.  but don't have an initial value.  and have a different monad.
08:20:35 <lilac> conal: i only read your paper yesterday :( i should still remember this
08:20:42 <quicksilver> although actually I like to think, there is only a now inside some places.
08:20:51 <quicksilver> there is a now inside the IO monad
08:20:54 <conal> lilac: it's a really dense paper.  i crammed to much in there.
08:21:00 <quicksilver> also, there is a now 'inside' a fmap, in a sense.
08:21:35 <quicksilver> but a relative time formulation would give you a clean way of taking a 'picture' of a Reactive at a particular time
08:21:41 <quicksilver> which could then be observed outside that time.
08:21:47 <quicksilver> (i.e. in pure code)
08:22:25 <adekoba> ski_: hey, your suggestion works, but I can't seem to get 'Frame' to work. http://hpaste.org/12439#a2
08:22:31 <conal> quicksilver: yeah :)
08:22:55 <adekoba> ski_: would I have to do something like: data Frame = Frame (ID Int) String ?
08:23:10 <adekoba> ski_: but I'm at a loss as to what data type should go there
08:23:32 <conal> this comonadic stuff is useful not only in time but in space as well.
08:23:45 <quicksilver> well I almost always program with relative space
08:23:54 <conal> yeah
08:23:56 <quicksilver> that's why I like opengl transformation-style APIs
08:24:06 <pao> I'm reading "Simple Unification-based Type Inference for GADTs"
08:24:09 <quicksilver> I think that's a very nice composable way to design a spatial API
08:24:16 <quicksilver> shame they deprecated it in GL3 :P
08:24:28 <conal> oh?  what's deprecated?
08:24:31 <roderyk> Is there a specific reason why Text.JSON does not use ByteString? While using JSON and CouchDB, I'm getting bad_utf8 encoding errors. Would these theoretically be fixed if I were using ByteString instead of Base.String?
08:24:32 <pao> can anyone confirm that example in section  2
08:24:34 <quicksilver> conal: the matix stack.
08:24:40 <pao> is not doable with ADT?
08:24:54 <conal> quicksilver: i didn't realize.  do you know why?
08:25:02 <quicksilver> conal: because it's not implemented in hardware.
08:25:10 <conal> oh.
08:25:12 <quicksilver> conal: they decided to deprecate everything which is just local C code
08:25:25 <quicksilver> on the grounds you can write your own library dfor that, if you want.
08:25:33 <conal> quicksilver: i see.
08:25:41 <quicksilver> so, we all have to write our own transformation stack libraries now.
08:25:53 <quicksilver> I think they should have moved it to GLU, not deprecated it.
08:26:14 <dolio> pao: The only constructor that's doable there is If.
08:26:29 <dolio> Without GADTs, that is.
08:26:40 <quicksilver> conal: still, it's easy to write such libraries in haskell so it's not a big deal ;)
08:26:40 <conal> quicksilver:  oh well.  i use the matrix stack in implementing functional 3D, but it'd be nearly as easy without.
08:26:45 * quicksilver nods
08:26:48 <pao> dolio: well I got implementing data + eval till Pair...
08:26:51 <quicksilver> I use it all the time because it's convenient.
08:26:57 <kayess> Using ghci: read "12" -- that doesn't work. How do I tell it I want to get an Int?
08:27:07 <quicksilver> kayess: read "12" :: Int
08:27:14 <kayess> Ah
08:27:17 <dolio> pao: Technically, I think Fst and Snd are doable with just existentials, I guess.
08:27:22 <conal> quicksilver: once you replace it with a functional model, it'll be easy to use whether or not implemented on the opengl matrix stack.
08:27:33 <pao> dolio: but I really stopped there :-) it's seems it's simply impossibile to tackle that problem
08:27:34 <kayess> quicksilver: So easy when you know how :) Thanks
08:27:51 <conal> quicksilver: e.g., FieldTrip has composable color transformations also (or some such).
08:27:56 <ski_> adekoba : you might want `data Frame = forall x. Frame (ID x) String' .. or maybe `data Frame x = Frame (ID x) String'
08:27:57 <quicksilver> conal: right.
08:28:04 <pao> dolio: here is the problem: implement that problem using Haskell 98 only :-)
08:28:12 <pao> dolio: I tried ... no success :-)
08:28:30 <conal> quicksilver: so in the end the matrix stack ends up being an exception
08:28:35 <adekoba> ski_: neat
08:28:37 <pao> dolio: but it simply sounds impossibile that a problem in unsolvable in haskell98
08:28:38 <quicksilver> conal: I have composable texture generation ;)
08:28:49 <conal> :)
08:28:58 <dolio> pao: Well, at the very least you'd have to structure it very differently.
08:29:02 <ski_> adekoba : i suppose it depends on what you want to do ..
08:29:27 <pao> dolio: acceptable... but how? :-) doesn't seem so natural :-)
08:29:36 <adekoba> ski_: former
08:29:39 * pao keeps feeling a newbie :-)
08:30:08 <conal> quicksilver: so i guess an upside to deprecating the matrix stack is that people will build their own, and then they'll make things more innovative than what old hardware used to accelerate
08:31:13 <ski_> adekoba : the former, using `forall x.' creates an "existential datatype" `Frame', where each value is of form `Frame id s' where `id :: ID x' for some (hidden) type `x' .. by pattern-matching on `id' you can "discover" in a local context what type `x' was (here either `Date' or `Text')
08:31:36 <conal> quicksilver: just like you understand more of what FRP *can be*, not just is, because you've looked under the hood.
08:32:00 <ski_> (adekoba : existential dataypes are another extension .. supported by at least GHC and Hugs .. probably nhc,yhc,jhc, too (?))
08:33:08 <ski_> (adekoba : so a value of type `[Frame]' would be a list of frames where the frames doesn't all need to have the same hidden type `x')
08:33:14 <nolbat> python has it, clojure has it. why not haskell? im talking about shorthans for Maps. {"haskell": 1, "should": 1, "have": 1, "Maps": 1}
08:33:22 <nolbat> like that
08:33:26 <nolbat> not fromList donka
08:33:48 <yaxu> anyone know some parsec magic for parsing a string literal within something other than double quotes?
08:34:06 <thoughtpolice> ski_: existential types are a pretty damn common extension yeah, I know nhc and jhc support it (since I'm working on a fork of jhc anyway) and I'm pretty sure yhc does too, but I can
08:34:13 <thoughtpolice> *'t be sure in its case
08:34:29 <ddarius> hbc has free existentials
08:34:48 <quicksilver> conal: the downside is that the typical person would come up with something less composable than the matrix stack :P
08:35:03 <quicksilver> conal: they'd just used fixed coordinates and some nasty translate/zoom hack.
08:35:07 <thoughtpolice> i actually installed a copy of hbc onto my linux box a week ago or so
08:35:12 <thoughtpolice> it didn't come with hbi unfortunately :(
08:35:17 <quicksilver> conal: the matrix stack was actually quit a *nice* point in the design space
08:35:18 <lilac> nolbat: you can do that with a syntax like "fromList ["haskell" ~> 1, "should" ~> 1, "have" ~> 1, "Maps" ~> 1]" if you want to
08:35:21 <thoughtpolice> (hbc 0.9999.5b I think)
08:35:49 <idnar> @type (~>)
08:35:50 <lambdabot> Not in scope: `~>'
08:35:53 <idnar> oh
08:36:08 <monadwr> hello
08:36:10 <idnar> (~>) = (,) ?
08:36:13 <lilac> > let (~>) = (,) in ["foo" ~> 1, "bar" ~> 2]
08:36:15 <lambdabot>   [("foo",1),("bar",2)]
08:36:19 <idnar> righto
08:36:34 <adekoba> ski_: yeah, this makes sense, but I'm having difficulty pattern matching Frames for either a Date or Text type. e.g, `set (Frame id@(ID Text) _) a = Frame id a` doesn't work.
08:36:37 <quicksilver> conal: http://roobarb.jellybean.co.uk/~jules/Picture%2035.png
08:36:40 <conal> quicksilver: agreed.  like many advancements, it brings people forward and keeps them stuff.
08:36:47 <idnar> nolbat: I think people just use alists a lot for simple cases like that
08:36:47 <thoughtpolice> (it constantly amazes me how I can take something like 15 year old software or software written before I was born and still run it on modern linux fine.)
08:36:50 <conal> quicksilver: (not everyone)
08:37:03 * conal looks
08:37:11 <idnar> nolbat: ie. [("haskell", 1), ("should", 1), ("have", 1), ("Maps", 1)]
08:37:18 <idnar> without bothering to turn it into a Map
08:37:19 * conal sighs and wishes for fast internet in the woods
08:37:27 <thoughtpolice> nolbat: what's the real advantage of having that?
08:37:30 <conal> quicksilver: pretty!
08:37:40 <thoughtpolice> nolbat: I see no reason why we should support it, "just 'cause"
08:37:50 <idnar> thoughtpolice: what's the real advantage of having [1, 2, 3] instead of 1:2:3:[] ?
08:38:00 <thoughtpolice> unless it's some extremely significant bit of syntax sugar that people really care about
08:38:14 <conal> thoughtpolice: you're younger than 15?
08:38:18 <lilac> ironically, you can use almost any operator for it except for ':' :)
08:38:19 <quicksilver> conal: that's boring imperative UI I'm afraid but the texture generation is a nice clean 2D function.
08:38:24 <idnar> I think the answer to the original question, "why not haskell?", is that maps aren't nearly as prevalent in Haskell as dicts are in Python
08:38:26 <thoughtpolice> conal: no, i'm 18
08:38:43 <quicksilver> conal: the UI on the right is a custom zipper editing an ADT, I mainly wrote that code to experiment with zippers...
08:38:44 <conal> thoughtpolice: oh!  i missed the "or"
08:39:01 <thoughtpolice> conal: still though, it amazes me. :]
08:39:21 <ski_> (thoughtpolice : did you find `hbc 0.9999.5b' somewhere ?)
08:39:21 <Axman6> anyone know why i'd be getting "configure: error: readline not found, so this package cannot be built" when trying to install readline-1.0.1.0?
08:39:27 <Axman6> i have readline installed
08:39:29 <thoughtpolice> ski_: yeah
08:39:33 <lilac> thoughtpolice: information does not rust
08:39:36 <thoughtpolice> ski_: I can try to find a link if you want
08:39:48 <thoughtpolice> lilac: :]
08:39:49 <idnar> lilac: however, bits rot ;)
08:39:52 <yaxu> Axman6: do you have the readline dev package?
08:39:53 <ski_> (thoughtpolice : would appreciate it)
08:40:11 <idnar> most of the 15-year-old software I've tried to compile on a modern system failed miserably
08:40:15 <Axman6> yaxu: i should do, macports installs all headers and such for these things
08:40:19 <idnar> but that's probably because it's horribly-written C
08:40:25 <Axman6> there's also the version that comes with OS X
08:40:46 <thoughtpolice> ski_: http://www.cs.chalmers.se/pub/users/hallgren/Alfa/Haskell/
08:40:58 <lambdabot> Title: Index of /pub/users/hallgren/Alfa/Haskell
08:41:01 * ski_ attempts catch-up on a fast #haskell ..
08:41:02 <thoughtpolice> ski_: also interesting on that page is that if you go into 'hbc/' it appears to be an infinite loop :]
08:41:31 <thoughtpolice> ski_: also that dir has a couple binaries, source can be got here - http://www.cs.chalmers.se/pub/users/hallgren/Alfa/Haskell/snapshot/2003-02-11/
08:41:32 <lambdabot> Title: Index of /pub/users/hallgren/Alfa/Haskell/snapshot/2003-02-11, http://tinyurl.com/6zwrw8
08:41:45 <Raevel> i'm trying to compile lambdabot from the darcs repo, how can i tell it to look for libraries in my cabal folder?
08:41:49 <ski_> thoughtpolice : oh .. sorry, istr you were looking for 5b source (maybe i recalled wrong ?)
08:41:52 <roderyk> anyone have experience with JSON or CouchDB willing to help me out? As a test, I have a basic html scraper that tries to save a html page in couchDB as a JSON object. But even something as simple as the html of google.pl is making my couchdb server cough when I try to store it, due to utf8 encoding issues. Any ideas on what I should be looking at? I really don't have much experience with all the unicode issues. I thought JSON and erlang were
08:41:54 <roderyk> designed well for unicode?
08:42:28 <thoughtpolice> ski_: the 0.9999.5b source is in that 2003-02-11 directory i linked to
08:42:29 <ski_> thoughtpolice : no, i'm recalling wrong .. that was binary or source for 5a, no ?
08:42:43 <ski_> (what you were looking for, i.e.)
08:43:26 <thoughtpolice> ski_: I was looking for hbi but apparently it doesn't come with it in that source repo (for some reason,) but I can't give you all the specifics; I
08:43:33 <thoughtpolice> 'm on my macbook right now
08:43:37 <ski_> ic
08:44:38 <ski_> adekoba : i'm not sure atm why that wouldn't work .. but can't you replace those two equations with just `set (Frame id _) a = Frame id a' ?
08:45:00 <quicksilver> roderyk: what do JSON and erlang have to do with #haskell?
08:45:12 <Axman6> roderyk: i don't see erlang working too well with unicode, but i might be remembering wrong
08:45:31 <Axman6> and yes, #erlang woud be much better roderyk
08:47:09 <adekoba> ski_: this is what I have so far: http://hpaste.org/12439#a3. It works, but is there a way to pattern patch against the type of ID in the 'set' function? i.e., I'd like to have different functionalitiy for (Frame Text) and (Frame Date)
08:47:12 <Asgaroth> Can someone give me some examples of things that would be implemented as a monad(as an exercise to check whether I understood the concept)?
08:47:34 <roderyk> Axman6: well, couchdb server runs erlang, but as far as I can tell it's how Text.JSON encodes the unicode that seems to be the problem. I could be wrong, of course
08:48:15 <mm_freak> Asgaroth: i like to view monads as type wrappers, which you can use to change the idea of 'value' and 'combining computations' for a type
08:48:27 <Raevel> Asgaroth: there's the state monad that stores some kind of value, there's monads that perform actions, lists are also monads
08:49:23 <quicksilver> roderyk: ah I didn't realise you were talking about Text.JSON, the haskell module.
08:49:41 <quicksilver> roderyk: does Text.JSON use utf8 encoding? it's not clear to me from a glance at the docs.
08:49:45 <ski_> adekoba : i thought you went with `data Frame = forall x. Frame (ID x) String' .. ?
08:50:28 <mm_freak> Raevel: i don't think that answers Asgaroth's question…  it only shows existing monads, but as i've understood it, Asgaroth would like to be able to recognize things as monads on his/her own
08:50:29 <ski_> (adekoba : `instance forall x. Show (Frame x)' looks strange .. if it works at all, it should be the same as `instance Show (Frame x)')
08:50:33 <Asgaroth> mm_freak, Raevel: Yes, I already implemented simple monads like State or Writer myself and would now like to have some other things that would serve as exercises, that would be solved by defining monads. Could you perhaps point to some problems that would be solved by defining an appropriate monad?
08:50:39 * shapr boings furiously
08:50:41 <roderyk> quicksilver: I don't think it does; my original query was whether this was on purpose. There is also RJSON which uses ByteStrings, and I was wondering if this would help fix some of the encoding issues
08:50:56 <mm_freak> Asgaroth: Maybe and lists are monads
08:51:08 <quicksilver> roderyk: using ByteStrings doesn't fix encoding issues.
08:51:14 * ski_ wonders what instance of `Show' is derived on `ID' ..
08:51:16 <Raevel> could be.
08:51:18 <PeakerWork> Asgaroth: You could implement the monad instances for various things.. Can you implement the State monad, for example?
08:51:24 <quicksilver> roderyk: you fix encoding issues by using an encoding package.
08:51:25 <adekoba> ski_: I did, but I decided for the moment to go with the other because it allows me to have functions like setText and setDate. This would be absolved if I could pattern match against ID types in a function
08:51:43 <quicksilver> roderyk: I think you can use Text.JSON to produce a String which you then encode as UTF8 using utf8-string
08:52:02 <mm_freak> Asgaroth: Maybe changes the idea of 'value' to 'at most one value', and changes the idea of combining computations to passing a value, if there is one, otherwise resulting in Nothing
08:52:05 <ski_> adekoba : `setText :: Frame -> ID Text -> Frame' should be possible
08:52:28 <mm_freak> > Maybe 3 >>= \x -> return (x+1)
08:52:29 <lambdabot>   Not in scope: data constructor `Maybe'
08:52:35 <mm_freak> > Just 3 >>= \x -> return (x+1)
08:52:37 <lambdabot>   Just 4
08:52:38 <mm_freak> d'oh
08:52:39 <adekoba> ski_: but then passing the id would be necessary.
08:52:45 <mm_freak> > Nothing >>= \x -> return (x+1)
08:52:46 <Asgaroth> mm_freak: Yes, I know. I'm rather looking for some problems that would require me to define a specific monad for it as an exercise.
08:52:47 <lambdabot>   Nothing
08:52:47 <conal> i suspect that derivative towers are also comonadic, but in the "wrong category" (not hask)
08:53:07 <mm_freak> Asgaroth: define MonadRandom, a monad carrying a random number generator
08:53:23 <quicksilver> conal: quick random question : do the fieldtrip surfaces use automatic differentiation?
08:53:25 <conal> (to continue a stale conversation)
08:53:28 <Asgaroth> mm_freak: Thanks, that seems like a good exercise.
08:53:31 <conal> quicksilver: yes!!
08:53:38 <quicksilver> conal: nice. I thought they might.
08:53:39 * ski_ boings shapr on the floor, up and down
08:53:43 <shapr> yay!
08:54:04 <quicksilver> I had some half-written implicit surface tesselation code which I thought of extending with interval artihmetic and automatic differentiation
08:54:07 <quicksilver> but I didn't.
08:54:11 <conal> quicksilver: and it does so without complicating the surface definitions at all.
08:54:14 <PeakerWork> The Maybe monad is probably not as useful as the maybe functor or applicative.. How often do you need the monadicness?
08:54:28 <quicksilver> conal: doesn't a parametric surface have trouble with shapes which aren't diffeomorphic to R2?
08:54:29 <conal> quicksilver: that'd be cool.  maybe we could add it to fieldtrip
08:54:41 <mm_freak> PeakerWork: i use it often
08:54:46 <idnar> PeakerWork: do syntax is nice for long chains
08:54:51 <conal> quicksilver: yeah.  i have no trimming.  lots of work to do still.
08:54:59 <adekoba> ski_: I'm thinking maybe I should make ID an instance of Typeable
08:55:02 <quicksilver> conal: implicit surfaces are too slow for realtime unless you do something very clever.
08:55:04 <mm_freak> fourthRoot x = squareRoot x >>= squareRoot
08:55:20 <conal> quicksilver: i like clever :)
08:55:24 <quicksilver> well yes, me too :)
08:55:32 <conal> heh
08:55:36 <PeakerWork> idnar: maybe Applicative also needs syntax, then
08:55:54 <conal> PeakerWork: agreed.
08:56:00 <conal> PeakerWork: as in the Applicative paper
08:56:01 <idnar> PeakerWork: yeah...
08:56:04 <quicksilver> conal: http://roobarb.jellybean.co.uk/~jules/Picture%20150.png
08:56:05 <ddarius> There was proposed syntax and implementations for it.
08:56:07 <DMKE> ski_: bye & thank you
08:56:08 <roconnor> conal: you know that result = fmap ?
08:56:11 <idnar> mm_freak: you don't need monad for that, though
08:56:15 <ski_> DMKE : yw
08:56:21 <conal> roconnor: it generalizes differently
08:56:27 <quicksilver> conal: showing a limitation in the algorithm: it deliberately gives up on certain complex cubes.
08:56:35 <quicksilver> it's supposed to subdividee that case but I never finisehd it.
08:56:37 <ski_> (conal : monad in `* -> *' ?)
08:56:40 <dolio> pao: http://hpaste.org/12444
08:56:45 <Saizan``> , [$i| (+) [1..3] [1..4]|]
08:56:57 <ski_> (s/monad/comonad/)
08:56:58 <conal> quicksilver: nice!
08:56:59 <lunabot>  [2,3,4,5,3,4,5,6,4,5,6,7]
08:57:07 <roderyk> quicksilver: brilliant! Such a simple answer, but exactly what I was missing. Thanks for saving me hours of frustration
08:57:15 <conal> ski_: ??
08:57:22 <quicksilver> conal: that's with deliberately facted normals, just ot make it easier to see the tesselation.
08:57:31 <quicksilver> roderyk: not at all, glad you got it straightened out ;)
08:57:34 <ski_> re derivative towers
08:57:34 <pao> dolio: thanks! let me study it
08:58:25 <conal> ski_: oh.  yeah a comonad is a unary type constructor.  is that what you were asking?
08:58:47 <mm_freak> idnar: sure, but Monad is the cleanest interface…  i think, there is nothing wrong with using Monad, even if Applicative would suffice
08:58:48 <idnar> hmm, wait
08:58:53 <ski_> conal : you said `but in the "wrong category" (not hask)' .. i wondered which category
08:58:55 <idnar> do you need monad for that?
08:59:07 <pao> dolio: this is really interesting... I found myself wanting to use a class instead of ADT is some situations...
08:59:33 <conal> ski_: i'm guessing vector spaces w/ linear maps
09:00:02 <conal> ski_: e.g., i can fmap a linear function over a derivative tower, but not an arbitrary function.
09:00:27 <idnar> I can't figure out how to write it with applicative
09:00:45 <ski_> conal : ok
09:01:01 <dolio> pao: Note, the GADT is an instance of the class, too. Where for each method "foo = Foo".
09:01:15 <ski_> adekoba : could you explain which function(s) you tried to write, and which didn't seem to work ?
09:01:29 <conal> i was thinking that a derivative tower is another example of a "value in context" and hence likely to be comonadic.
09:02:23 <pao> dolio: that's true
09:02:46 <conal> neat!  #haskell has a facebook group.  with photos.
09:02:51 <shapr> yeah!
09:02:51 <ski_> conal : would `extract' extract the "top" function, or it applied to `0' ? (or a stream of every function in there, applied to `0')
09:02:52 <shapr> unicycles!
09:03:05 <shapr> conal: I have not yet gotten a picture of you on a unicycle.
09:03:10 <shapr> This is a serious omission.
09:03:33 <conal> shapr: i'd love to learn unicycling.  not sure it's wise on our unpaved country road.
09:03:39 <shapr> hah
09:03:46 <conal> ski_: do you mean for derivative towers?
09:03:50 <ski_> *nod*
09:04:11 <conal> ski_: extract would pull out the value (zeroth derivative)
09:04:29 <ski_> zeroth derivative *at* `0' ?
09:04:41 <adekoba> ski_: the 'set' function in the hpaste. I want to be able to differentiate between (Frame Text)'s and (Frame Date)'s within the function itself
09:04:44 <conal> ski_: no.  a derivative tower isn't a function.
09:04:57 <conal> ski_:  it's all the derivatives at a source point.
09:05:21 <ski_> conal : .. you are right. that detail had slipped my mind at the moment
09:05:51 <ski_> (now that i think of it, that's of course one of the main points of AD)
09:05:52 <conal> ski_: it's arbitrary.  it isn't a function but it could be
09:06:13 <conal> ski_: i also work with functions to derivative towers.
09:06:47 <ski_> adekoba : so `set :: Frame -> String -> Frame', then ?
09:06:58 <adekoba> ski_: yep
09:08:00 <pao> dolio: thank you very much... I'm grasping last details... :-)
09:08:44 <dolio> pao: One thing Oleg uses it for in whatever paper he wrote on it is to show higher-order abstract syntax terms.
09:09:52 <quicksilver> conal: #haskell having a facebook group is like the queen of england having an iPod.
09:10:00 <quicksilver> conal: the world is weird sometimes.
09:10:14 <Axman6> we have a facebook group?
09:10:20 <quicksilver> so he said.
09:10:34 * conal wants an ipod sometimes
09:11:01 * ddarius doesn't.
09:11:03 <ski_> adekoba : ok .. maybe i see what you're trying now .. try `set (Frame id@TALB _) = Frame id x; ...'
09:11:26 <hackage> Uploaded to hackage: traced 2008.11.26
09:12:04 <thoughtpolice> http://www.facebook.com/group.php?gid=2213713570
09:12:20 <pao> dolio: ok
09:12:27 <pao> dolio: I think I got it
09:13:08 <dolio> pao: http://hpaste.org/12444#a2 is how you can do that.
09:13:13 <pao> dolio: type Term' t = forall term. Term term => term t ... allows to type check expressions without the need of defining an instance for the class... right?
09:13:35 <dolio> Although that language doesn't need HOAS.
09:13:43 <dolio> (Since there's no binding construct.)
09:14:15 <Axman6> hoorah, joined the haskell group
09:15:14 <dolio> pao: That type synonym just ensures that when you have something of type "Term' t" it works for all possible instances of Term. So, it must only be written in terms of the methods of Term (and other values built from those methods).
09:15:15 <Axman6> and posted my first message on any group
09:15:29 <defun> Quick question: Is it possible to implement a fully functional gui toolkit entirely in haskell? I don't care about performance. I just want to implement a 'pure' gui toolkit in haskell for haskell. Can GUIs be created, hypotheticaly, with types and type classes, or would it be neccessary to create an object system? Also, GUIs use message oriented programing (i.e. signals and slots); can haskell support or simulate such a mechanism in the
09:15:29 <defun> ory? Could monads be used to achieve a pure haskell GUI in haskell for haskell? Thanks.
09:16:13 <pao> dolio: clear
09:16:16 <ski_> (adekoba : a variant would be to use `data Frame = forall x. Frame (ID x,x) String', then you could use `set (Frame id@(_,Text _) = Frame id x; ...')
09:16:49 <pao> dolio: in h98 you could not write (and typecheck) any expressions of the "language" without having at least an instance
09:16:58 <dolio> pao: If you just have something of type "Id t" for instance, there's no way to tell if it's a term of your embedded language, since there are other ways to construct Ids.
09:16:58 <ski_> (adekoba : er, `set (Frame id@(_,Text) _) = Frame id x; ...')
09:17:07 <mm_freak> defun: considering a window to be a tree and a GUI to be some stateful computation, it should be possible
09:17:28 <mm_freak> Gui and GuiT (for windows, which use IO)
09:17:46 <dolio> pao: No, you don't need an instance. The terms would have type 'Term term => term t'.
09:17:46 <conal> defun: i think functional programming is a much better natural fit for GUIs than imperative programming is.
09:17:58 <Axman6> defun: i'm going to go out on a limb and say yes, it's possible. but i'd have no idea how to do it
09:18:00 <pao> dolio: what are the benefits of GADT approach vs tagless interpreter?
09:18:01 <defun> conal: why so?
09:18:05 <conal> defun: despite common wisdom.
09:18:09 <dolio> You need an instance to get anything out of such a term, of course.
09:18:19 <lilac> defun: it depends which window system you're targeting. on windows, you need to interface with Win32 which means FFI at least. you can do an X gui with no FFI by implementing your own xlib-like layer
09:18:37 <conal> defun: they're flows and functions of time.  and functional concurrency is so much simpler than imperative concurrency.
09:18:42 <conal> defun: (they == guis)
09:18:49 <lilac> conal: afaict, you think functional programming is a much better natural fit for /most/ tasks :)
09:18:50 <Axman6> lilac: bah, just access the hardware directly and be done with all the bs ;)
09:18:52 <dolio> pao: Eh. The tagless interpreter is kind of a hack. Arguably not the type of thing typeclasses are for.
09:19:12 <conal> lilac: yes.  and especially guis.
09:19:32 <lilac> conal: not that i disagree, but i was raised imperative and it's taking me a while...
09:19:35 <defun> lilac: If I were building my own window sys in haskell, theoretically.
09:19:46 <conal> guis in imperative/sequential model need call-backs or threads, which are both complicated.
09:19:48 <ski_> (defun : you were cut off between ".. mechanism in the" and "ory? Could monads ..")
09:19:53 <pao> dolio: many, many, many thanks
09:20:02 <dolio> No problem.
09:20:04 <lilac> defun: then you'd need some way to access the hardware, which is a whole other problem :)
09:20:25 <Axman6> house did it no?
09:20:28 <defun> lilac: but it could be done?
09:20:38 <defun> lilac: think of HOUSE operating sys.
09:20:50 <lilac> ski_: the + ory = theory
09:21:21 <ski_> ohh
09:21:22 <lilac> defun: yes, absolutely, if you're prepared to use either FFI or some other mechanism to interface with the hardware
09:22:03 <lilac> defun: but as a vanilla Haskell'98 program? i suspect not.
09:22:27 <mm_freak> defun: as said, a GUI is nothing but a stateful computation…  with a transformer, you can do IO as well inside the GUI
09:23:17 <pao> dolio: two more questions....
09:23:37 <pao> dolio: what if I would like my language to be "extendable"
09:23:39 <defun> lilac: Why not? if it can be compiled, I would suspect that it is doable... w/ lots of effort of course.
09:24:03 <pao> dolio: tagless interpreter should be easy... I extend the type class
09:24:12 <pao> dolio: with GADTs?
09:24:23 <dolio> Add more constructors.
09:24:37 <ddarius> lilac: FFI is an (accepted) addendum to the Haskell 98 Report.
09:24:44 <dolio> Oh, you mean make another class...
09:24:48 <lilac> ddarius: neat!
09:24:49 <pao> dolio: if it was in a different compilation unit?
09:25:42 <dolio> pao: You can make another type 'data Term' t where OtherTerm :: Term t -> Term' t ; <new constructors ...>'
09:26:23 <dolio> Of course, I suppose that doesn't work so well if you want to put a Term' inside a Term...
09:26:43 <lilac> defun: assuming you can communicate with the hardware, the rest is possible (and probably can be easier and cleaner than doing it in C)
09:27:02 <pao> dolio: yep...
09:27:28 <defun> lilac: thanks. I will do some more research.
09:28:17 <EmielRegis> hmm
09:28:23 <EmielRegis> how to get haskell to load my custom modules
09:28:27 <EmielRegis> which are in same folder?
09:28:29 <dolio> pao: I suppose that may be a legitimate advantage of the typeclass approach.
09:28:54 <pao> dolio: yep
09:29:39 <dolio> pao: Although the Datatypes a la Carte paper describes how to make a system of extensible datatypes for such an expression type.
09:29:57 <dolio> And you could probably use that approach in conjunction with GADTs.
09:30:08 <ski_>   data TermF (term :: * -> *) :: * -> *
09:30:10 <ski_>     where
09:30:12 <ski_>     If :: term Bool -> term a -> term a -> TermF term a
09:30:15 <ski_>     ...
09:30:15 <ski_> ?
09:30:23 <pao> dolio: thanks... I'll read that paper...
09:31:07 <quicksilver> EmielRegis: it will automatically
09:31:16 <quicksilver> EmielRegis: if their paths match their names
09:31:23 <ski_> (and `type Term = Mu2 TermF')
09:31:24 <quicksilver> "import Foo " will look for Foo.hs
09:31:34 <quicksilver> "import Foo.Bar" will look for Foo/Bar.hs
09:31:48 <EmielRegis> ah ok
09:31:50 <conal> roconnor: thanks though for the comment on my blog post.  first feedback i've gotten.  i hope my reply didn't discourage you.
09:32:01 <kowey> conal: hi! did you get the help you needed with darcs?
09:32:04 <roconnor> I see now that you were aware
09:32:15 <roconnor> conal: I should have saved my comment until I was done reading
09:32:17 <roconnor> :)
09:33:05 <conal> kowey: hi. :)  i'm not sure.  i'll try some experiments and see if i can sort out the multi-connection thing.
09:33:16 <conal> kowey: and then i'll probably ask for more help.
09:33:25 <kowey> ok :-)
09:33:40 <kowey> I'm sure the folks the in #darcs will be able to sort you out
09:33:55 <conal> yeah, and that's a great comfort.
09:34:07 <conal> i love helpful community
09:34:30 <conal> satellite internet is painful for a lot of things.  i sure have a lovely view here, though.  and only nature sounds most of the time.
09:35:55 <kowey> sounds like a worthwhile trade-off
09:35:57 <ziman> conal, are you somewhere in the wild?
09:36:15 <conal> kowey: it really is.
09:36:35 <conal> ziman: yeah.  in central/northern CA
09:36:55 <conal> (california)
09:38:52 <conal> i moved here from seattle in 07
09:39:59 <ziman> so you like it better there, i suppose :)
09:40:37 <conal> yeah, though seattle is great, too.
09:43:11 <defun> Oh btw, is it possible to facilitate IPC (like dbus) between two or more haskell programs? And what benefits (if any) do type classes offer compared to CLOS or C++ Objects/Classes? Thanks.
09:43:19 <litb> foo (X (bar b) (baz s))  i have that. say the datatype is Z . how can i accept all constructors of Z ?
09:43:40 <daf> defun: there is an existing D-Bus binding, but it's not very Haskelly
09:43:44 <litb> the constructor is X but it stands for any ctor. it's just a variable
09:43:47 <daf> defun: wjt has been working on a better one
09:44:07 <daf> defun: type classes are not really comparable to classes in the OO sense
09:44:36 <Asgaroth> litb: I don't think that can be done, perhaps you should provide an extractor function to get the value out of any Z and operate on that.
09:44:58 <defun> daf: why not?
09:45:29 <litb> Asgaroth: oh i see.
09:45:50 <baaba> defun, type classes are comparable to concepts in c++
09:46:56 <Asgaroth> defun: They are more similar to interfaces in java.
09:47:14 <litb> indeed
09:47:15 <daf> defun: just because two things have the same name doesn't mean that they are similar :)
09:47:38 <defun> i see. thanks.
09:47:39 <litb> typeclasses are very similar to concepts. and a little bit similar to ABC and interfaces
09:48:13 <Asgaroth> Actually concepts are directly inspired by haskell's type classes, hence the similarity.
09:48:22 <defun> So what's the equiv of class in Haskell? In java all interfaces require classes, to my knowledge.
09:48:26 <arw_> a typeclass tells you, what functions you can call on a value of that type.
09:48:56 <arw_> there isn't really an equivalent to classes.
09:49:23 <Asgaroth> defun: They require classes in the sense, that you need classes that implement them. Similarly you need types that are instances of a type class for it to be useful.
09:49:43 <defun> oh. ok.
09:49:56 <arw_> at least not in the java sense. there are records, and of course functions can be members of those records. but there is no inheritance for example.
09:49:57 <thoughtpolice> conal: re. seattle and the country, I used to live out in a very small town next to nowhere and now I live in houston; it's nice, but I do miss the quiet comfort of nature. also, being able to actually see the stars is a plus.
09:50:34 <arw_> its all a little confusing because the terminology is overloaded very often...
09:51:02 * conal nods
09:51:12 <PeakerWork> OO inheritetnce is a pretty awful mishmash of things
09:51:28 <daf> "an X is like a Y, except for when it's not"
09:51:58 <PeakerWork> Its an "instance-of" relationship, a "member-of" relationship, a namespace mixing mechanism (where the names from multiple _modules_ can collide!)
09:52:31 <PeakerWork> The third is a mis-feature, and the first 2 are really best separated
09:53:01 <PeakerWork> Oh wait, its also a way to define multiple "data constructors" for a type
09:53:07 <PeakerWork> Because there are no data constructors
09:53:14 <arw_> and best of all, a mixture of evil linker tricks...
09:53:31 <PeakerWork> arw_: to be fair, those are just implementation details, and vary from one OO language to the next..
09:54:28 <PeakerWork> so when people inherit, they are either declaring an instance, or they just want a member which happens to get the interfaces delegated to, or they want multiple data constructors.  These are very very difference cases, but all use the same overly-complicated mechanism
09:55:30 <arw_> not to mention the whole 'design patterns' stuff where you layer more complicated mechanisms on top of that.
09:56:03 <arw_> but of course thats not part of any language.
09:59:46 <PeakerWork> Well, some people use OO inheritance only for "instance-of" relationships, and not the other stuff, the trend is called "compose, don't inherit!", so that's much better. You still define the instance-of relationship alongside the actual type, which disallows 3rd party instances/interfaces
10:00:06 <PeakerWork> And many of the "design patterns" do just that, so they're probably applicable where-ever you have type-classes/interfaces and instances
10:00:30 <ksf> design patters are thingies invented by people who can't teach for people who can't code.
10:00:36 <PeakerWork> For example, the "Strategy" design pattern is useful in C, C++, Java, and Haskell alike
10:01:26 <PeakerWork> ksf: Just techniques that are given a name.. In a high-level language like Haskell, these techniques are trivial/idiomatic anyway, so it seems silly to give them the name "design patterns", but in lower languages they are more difficult
10:01:41 <conal> I like the BangOnItUnilItWorks pattern
10:02:08 <PeakerWork> The "Strategy" pattern is basically a "pass functions or a function tuple to code in order to tell it how to behave in certain situations"
10:02:08 <conal> also BlameSomeElseWhenItDoesnt
10:02:39 <PeakerWork> That's certainly useful, but in a language like Java/C++, passing "code" to functions is so un-idiomatic that it is not obvious
10:02:41 <ksf> i've used that in c before.
10:02:52 <ksf> didn't need a name for it, just an opportunity.
10:03:10 <PeakerWork> ksf: Giving names to these techniques is useful,  easier to communicate, and once it has a name, people tend to use it more
10:03:29 <arw_> when comparing to haskell many design patterns are just higher language constructs that are impossible to do properly in java/c++/whatever.
10:03:31 <PeakerWork> ksf: Most C code will pass around enum values, when it really should, IMO, pass functions around
10:03:32 <lament> the more patterns, the better
10:03:40 <ksf> which was parametrising a tree output function to print in both base 1000 and base 1024
10:03:45 <lament> a common language is good
10:03:51 <Asgaroth> Would using Foreign.C.Double still work on a Windows system with no C-headers whatsoever installed?
10:04:12 <PeakerWork> lament: the 1990's patterns are today's common idioms, which contributes to the "its silly it doesn't deserve a name" spirit
10:04:25 <arw_> for example iterator/visitor stuff is just a complicated form of map*
10:04:34 <lament> silly things deserve better names!
10:04:43 <flux> I recently wrote a c program that tried to parametrize qsort..
10:04:49 <ksf> ...and, of course, also support stuff like df, that is, -m, -k and -h
10:04:55 <PeakerWork> arw_: the visitor pattern is a fold, and also equivalent to multi-methods
10:04:58 <flux> you know, if takes a function in, do you should be able to parametrize in higher-order style
10:05:20 <badtruffle> flux: the stdc qsort does that?
10:05:24 <flux> badtruffle, yes
10:05:25 <ksf> making that an enum that's switched _inside_ the tree traverse is a sure sign of a mind lacking the hacker nature.
10:05:32 <flux> unfortunately it takes no additional argument to pass to the function, so it is tricky to have parametrize the function you give it
10:05:37 <badtruffle> flux: ah, yeah, that's a pain
10:05:40 <flux> I ended up having a bunch of different functions
10:05:46 <flux> of course, I could've used a global, but..
10:05:53 <flux> (or somehow encoded the comparison inside the data)
10:06:25 <Toxaris> I think we have names for pattern-like things in FP too, e.g. "higher order function"
10:06:47 <ksf> somewhere i read that "iterators are a sure sign your language sucks"
10:06:50 <lament> patterns are patterns
10:06:58 <flux> I would definitely say monads is a pattern..
10:07:08 <lament> monad is a pattern
10:07:16 <Toxaris> never seen it presented as a pattern
10:07:28 <Toxaris> maybe that would be a good idea
10:07:29 <lament> so?
10:07:40 <lament> Toxaris: a "pattern" is a way to solve some problem in some way.
10:07:42 <ksf> it can't be a pattern, it's not static enough.
10:07:45 <lament> it's not the buzzword you think it is.
10:07:56 <PeakerWork> ksf: I think _all_ enums, except for ones defined for serialization purposes in C, really want to be strategies (vtables/funcptrs)
10:08:10 <Toxaris> lament: I'm talking about patterns in the sense of the GOF
10:08:19 <idnar> why are monads a pattern?
10:08:38 <lament> Toxaris: they just wrote a book and put some patterns in it.
10:08:39 <Toxaris> lament: which include a way of presentation
10:08:39 <badtruffle> a set of things with common traits? :P
10:08:46 <ksf> saying monads are patters is akin to saying lambdas are patterns.
10:08:47 <idnar> they're a specific construct, not a pattern for specialising
10:08:53 <lament> ksf: lambdas are a pattern, yes.
10:09:07 <ksf> lament, then tell me one thing that isn't a pattern.
10:09:11 <idnar> lament: if you use it that way, then "pattern" just means "concept"
10:09:16 <idnar> which isn't very useful
10:09:26 <lament> idnar: actually it's incredibly useful
10:09:28 <badtruffle> let's define pattern then :)
10:09:34 <idnar> lament: "concept" already means "concept"
10:09:38 <flux> I don't see lambda functions would be a pattern in the same way monads would be
10:09:38 <badtruffle> and then debate on what is what
10:09:50 <Toxaris> "abstracting over a term" is a pattern
10:09:50 <ksf> to me, a pattern is a pattern associated with a replacement. kinda like a regexp over concepts.
10:09:51 <lament> idnar: ok, and pattern means "concept with a name"
10:10:10 <badtruffle> ksf: you just defined a pattern in terms of a pattern :P
10:10:13 <lament> idnar: do you not see the benefit in that?
10:10:20 <Toxaris> and lambda is a language feature which makes it easier to use that pattern (in comparision to named functions)
10:10:27 <ksf> well that's why they're called patterns, ain't it?
10:10:31 <badtruffle> :P
10:10:46 <arw_> pattern is a construct which is higher-level than the underlying language and is a common way to do something which is not possible to encapsulate in some language primitive.
10:10:51 <idnar> lament: no, I don't; if it has a name and you mention the name, then it's self-evident that it has a name; if it has a name, but you don't mention the name, then the knowledge that it has a name is pretty useless on its own
10:10:53 <ski_> @wiki Combinator_pattern
10:10:54 <lambdabot> http://www.haskell.org/haskellwiki/Combinator_pattern
10:10:54 <arw_> that would be my definition.
10:10:58 <ski_> @wiki Indirect_compose
10:10:59 <lambdabot> http://www.haskell.org/haskellwiki/Indirect_compose
10:11:05 <lament> idnar: the point is to give things names and establish a common language
10:11:09 <flux> if you have a problem and a friend says "hey, that looks like it could be a monad", doesn't that look a lot like "pattern"?
10:11:12 <idnar> lament: I also think your definition is at odds with the way the term is used in practice
10:11:15 <lament> idnar: the GOF did an amazing job there
10:11:24 <flux> nobody says "hey that looks like a lambda function"
10:11:32 <PeakerWork> arw_: that seems like a good definition
10:11:34 <ksf> you can monadify everything.
10:11:49 <idnar> lament: something like the "visitor pattern" is different from something like "monads" or "functions"
10:11:50 <flux> ksf, so? perhaps I could write everything with the visitor pattern
10:11:53 <flux> but it would be awful :)
10:12:05 <lament> idnar: ok, lambdas aren't a pattern. But monads are.
10:12:06 <PeakerWork> The "visitor" pattern is truly the most awful of the GoF book :)
10:12:11 <ksf> not so with monads, neither with lambdas.
10:12:15 <idnar> lament: all of the GOF patterns fall into a set that is far more specific than just "concepts"
10:12:22 <lament> idnar: note that monads rely on monadic laws, which are not enforced by the language
10:12:49 <idnar> lament: the key thing being that patterns are just templates that are not directly applicable in any way
10:12:49 <badtruffle> idnar: how would you define it then?
10:12:59 <lament> idnar: sounds like monads!
10:13:26 <idnar> lament: you don't need to reimplement monads every time you solve a problem with them
10:13:53 <lament> idnar: err, yes, you do
10:13:55 <ksf> most importantly, patterns map denotational semantics to operational semantics, but monads and lambdas are purely denotational.
10:14:01 <lament> idnar: every time you need a new monad, you need to implement a new monad
10:14:15 <idnar> lament: but, for example, you don't define a new monad typeclass
10:14:34 <ksf> in fact, you could say that patters are the things that force java coders to think denotationally in the first place.
10:14:42 <lament> idnar: the monad typeclass is already defined, just like the visitor pattern typeclass could be already defined.
10:14:42 * ksf smells a conspiracy.
10:14:47 <lilac> PeakerWork: http://rgs26.livejournal.com/3203.html :)
10:14:48 <lambdabot> Title: rgs26: Anti-patterns (in C++): Visitor
10:14:57 <idnar> lament: if you could define a universal visitor pattern typeclass, it wouldn't be a pattern anymore (IMO)
10:15:12 <Toxaris> ksf: how are patterns related to denotations?
10:15:14 <arw_> idnar: ack.
10:15:38 <ksf> they match denotations, and replace them with concrete operational techniques.
10:15:40 <lament> idnar: so a pattern to you is "something we can't quite formalize"?
10:15:44 <ksf> in fact, they are compilers.
10:15:53 <idnar> lament: it's more to do with implementation than description
10:16:14 <lament> idnar: the monad typeclass is not an implementation of monads. It's a description.
10:16:26 <lament> it's not a good description, because it doesn't enforce the monadic laws.
10:16:39 <badtruffle> monadic recommendations :P
10:16:48 <idnar> lament: you have some kind of repeated concept appearing in your solutions, but your implementation language / platform / whatever doesn't allow you to express this; so instead, you refactor it "conceptually"
10:16:49 <Toxaris> idnar, arw_: I strongly disagree. Why should a pattern stop being a pattern because it enjoys language support? The usefulness of the named concept is still there
10:17:14 <idnar> Toxaris: the concept isn't any less useful, it's just no longer a pattern
10:17:29 <ksf> are monadic laws even enforceable in a turing-complete language
10:17:38 <ksf> (without solving the halting problem, that is...)
10:18:11 <arw_> Toxaris: its just a difference of terminology. in earlier times when there only was "if" and "goto", one would have considered a counting for-loop a pattern by modern terms.
10:18:16 <dolio> Yes.
10:18:31 <idnar> arw_: exactly
10:18:33 <dolio> If you attempt to provide a bogus proof of the monad laws, your program would never type check.
10:18:33 <ski_> subroutines are a pattern
10:18:34 <arw_> Toxaris: nowadays that would no longer apply, because every language supports for-loops.
10:18:43 <ski_> (or maybe "were")
10:18:43 <dolio> Never finish, that is.
10:19:19 <idnar> if you can directly codify the concept into your implementation environment, then you don't need a pattern
10:19:46 <Toxaris> but (some) pattern are about design, not implementation, so they are (somewhat) language independent
10:19:51 <dolio> Well, that may not be true, I suppose.
10:19:55 <idnar> I guess the difference is where the concept is "executed"
10:20:11 <idnar> for a pattern, it's executed in the programmer's head, each time he applies it to a problem
10:20:18 <dolio> It really all depends.
10:20:22 <arw_> Toxaris: design is just a very high level language.
10:21:01 <idnar> what is a pattern in one language may be a directly-suppported feature in another language
10:21:25 <idnar> obviously the pattern and the language feature may share concept(s)
10:21:30 <erikc> and it would be better if people were taught about those other languages instead of reading 'pattern books'
10:21:40 <Toxaris> arw_: for loops are an interesting example, by the way, because they are still evolving, with the ongoing trend of including "foreach" loops in OO languages
10:22:05 <arw_> hmm
10:22:06 <ksf> *sigh*
10:22:11 <idnar> this difference usually shows up in the way people talk about the pattern/not-pattern
10:22:14 <ksf> <ksf> design patters are thingies invented by people who can't teach for people who can't code.
10:22:17 <lament> idnar: i'm not sure if many people will agree that patterns are language-dependent
10:22:18 <ski_> (arw_ : "\tldx #0\nloop\tcpx count\n\tbne end\n...\n\tjmp loop\nend\t...")
10:22:18 * dolio needs more sleep and should probably be ignored.
10:22:28 <erikc> ksf: hug
10:22:32 <PeakerWork> lilac: indeed, a nice blog post :)  is he a Haskeller?
10:22:42 <hukolele> what do i need to play with ghc plugins?
10:22:45 <erikc> they were also invented by ppl who wanted to make money of teaching and books, same with XP
10:22:45 <lilac> PeakerWork: he is now :)
10:22:48 <idnar> lament: they're not necessarily language-dependent
10:22:50 <PeakerWork> lilac: its yours?
10:22:55 <lilac> PeakerWork: yep
10:22:56 <idnar> lament: it's just that they may be unnecessary in some languages
10:23:09 <lament> idnar: i'm pretty sure you were saying they're language dependent
10:23:19 <lament> idnar: i.e. something can be a pattern in one language and not a pattern in another.
10:23:23 <PeakerWork> lilac: cool :)  The unifying of the iteration and dispatch truly sucks, and offering ONLY a fold as a means to iterate also sucks..
10:23:29 <idnar> lament: well, I suppose I was inaccurate
10:23:36 <lament> i see.
10:23:38 <Toxaris> arw_: oh, and another btw, last time I checked for-loops where not directly available in Haskell, but idiomatically implemented as (map (\i -> ...) [0..n])
10:23:53 <PeakerWork> lilac: If we had only foldr's instead of lists, that would totally suck :)
10:23:57 <idnar> lament: what I meant was that in one language you might apply the pattern; in another language, the concept is directly available, so it would be stupid to apply the pattern instead
10:24:04 <lilac> PeakerWork: reading it now, i find it entertaining that the 'cast and check' thing is basically haskell's pattern matching :)
10:24:28 <PeakerWork> lilac: Yeah, except it can check for exhaustive pattern matches :)
10:24:31 <idnar> lament: in the same way that it would be silly to write an explicitly recursive function instead of just doing "map f xs"
10:24:32 <Toxaris> idnar: I would say, in that other language, "apply the pattern" == "use the concept"
10:24:49 <PeakerWork> lilac:  and the visitor iteration for you is basically "foldr", where pattern-matching to fold yourself is strictly more powerful
10:24:51 <BMeph> ksf: i disagree about the design patterns thing. However, I do think that later publications of the book should have been titled "Abstraction for Dummies". ;)
10:24:55 <arw_> Toxaris: yes, of course one needs to agree on wether the standard libraries are considered part of the language or not.
10:24:56 <idnar> Toxaris: well, maybe
10:25:10 <idnar> Toxaris: this is just terminology, at the end of the day
10:25:24 <PeakerWork> lilac: (though the contempt in your entry for "foldr" is overstated, I think.. Its best to invert control when possible, but also to allow control of the iteration if necessary)
10:25:25 <lament> another angle: patterns are templates for solutions to problems. In presence of for loops, keeping track of an index variable is no longer a problem, so you don't need the "for loop" pattern. However, "iteration over a list" is still a pattern, that can be solved by the means of the for loop (or, perhaps better, by the means of a foreach loop or a map)
10:25:26 <idnar> I just think it's pretty silly to run around appending "pattern" to absolutely everything
10:25:29 <lilac> PeakerWork: right. :) for the record, i think haskell is much closer to right than c++ is...
10:25:53 <lament> s/still a pattern/still a problem
10:25:57 <lilac> PeakerWork: if my code contains 'foldr' then it's still my loop :)
10:26:06 <idnar> I mean, in Haskell code, you don't talk about "applying the Monad pattern", you talk about defining a Monad instance
10:26:14 <lament> idnar: yes, but that's in Haskell!
10:26:17 <PeakerWork> lilac: if lists were _only_ iterable via foldr...
10:26:19 <idnar> you don't talk about "applying the map pattern", you just call map
10:26:21 <lilac> PeakerWork: in the sense that it's my choice to foldr or to foldM or ... :)
10:26:22 <lament> idnar: what if you need to talk to programmers who don't use haskell?
10:26:39 <idnar> lament: okay, you don't talk about "applying the function pattern", you talk about defining a function
10:26:40 <lament> idnar: this is why we have 30 different names for map in different languages
10:26:45 <erikc> lament: you ask them to educate themselves
10:26:45 <lament> it sucks!
10:26:55 <PeakerWork> lilac: even if you had foldr and foldM, you'd still not be able to implement O(N) zip
10:27:38 <lament> in ruby, map is called "collect" and filter is called "select"
10:27:41 <PeakerWork> lilac: you want to be able to "get next element" (or pattern match (:))
10:27:41 <lament> in C# it's something else
10:27:44 <lilac> PeakerWork: right. if the data type doesn't provide something equivalent to unfold, then there will be some things you can't do :)
10:27:59 <lament> there's an extra load on programmers because a common language hasn't been established
10:28:15 <PeakerWork> lilac: how do you implement O(N) zip with unfold?
10:28:16 <ski_> PeakerWork : i've done it
10:28:27 <PeakerWork> ski_: O(N) zip with foldr?
10:28:38 <lilac> PeakerWork: but visitor-for-traversal is less useful than foldr anyway...
10:28:54 <PeakerWork> lilac: yeah, because of the conflation
10:28:56 <dolio> zip with foldr seems O(n) to me, thinking about it for about 30 seconds or so.
10:29:05 <dolio> I'm not 100% sure.
10:29:05 <ski_> PeakerWork : <http://www.mdstud.chalmers.se/~md9slj/code/FoldrZip.hs> (also Oleg has a version)
10:29:05 <PeakerWork> dolio: how?
10:29:10 <ksf> erm... so visitors are actually functors?
10:29:14 <lilac> PeakerWork: I'm assuming unfold :: (Unfoldable f) => f a -> Maybe (a, f a)
10:29:20 <nolbat> python has it, clojure has it. why not haskell? im talking about shorthans for Maps. {"haskell": 1, "should": 1, "have": 1, "Maps": 1}
10:29:20 <ksf> or am i missing something?
10:29:36 <PeakerWork> ski_: I mean zip with _only_ foldr, without pattern-matching (:)
10:29:46 <ski_> PeakerWork : exactly
10:29:47 <idnar> ksf: there's not really a one-to-one correspondence
10:29:48 <dolio> Yeah, there's no pattern matching.
10:29:55 <PeakerWork> ski_: You're pattern-matching (:) in there.. ?
10:30:01 <ski_> PeakerWork : no
10:30:06 <lament> nolbat: suggest it to the language committee.
10:30:15 <nolbat> lament: how?
10:30:17 <PeakerWork> ski_: ah, zipWith3 ?
10:30:20 <idnar> ksf: the visitor pattern is usually used in the concept of an imperative language, so you can do anything you like with each element as you "visit" it
10:30:37 <idnar> ksf: so you might end up with something like fmap, or something like a fold, or ...
10:30:42 <ski_> PeakerWork : PeakerWork : if you'd like, i could easily change the last into `zipWith3 :: (a -> b -> c) -> (List a -> List b -> List c)' where `type List a = forall r. (a -> r -> r) -> r -> r'
10:30:47 <BMeph> Holy moley! foldr is a SAPL-style Algebra selector! :)
10:31:03 <Toxaris> I think the visitor pattern is flexible enough that *both* map and foldr are instances of it
10:31:04 <ski_> BMeph : `SAPL-style Algebra selector' ?
10:31:16 <erikc> a large amount of patterns are just closures with anthropomorphic labels applied
10:31:33 <PeakerWork> ski_: ah, I see how that works.  You're right, my bad. Cool :)
10:31:52 <lilac> PeakerWork: zip as bs = fromMaybe [] $ do (a, as') <- unfold as; (b, bs') <- unfold bs; return $ (a,b):zip as' bs'
10:31:59 <PeakerWork> ski_: You build an alternate data structure that represents the list which you _can_ pattern-unpack in the next foldr
10:32:00 <ski_> PeakerWork : iirc, Oleg's was different (possibly didn't used a recursive type) .. you might want to check it out
10:32:10 <ksf> nah, a fold doesn't preserve structure.
10:32:25 <lilac> PeakerWork: incidentally, unfold is implementable in terms of foldr
10:32:53 <ksf> (except if you go inventive and cons up a list as result or something)
10:32:59 <lilac> PeakerWork: (as far as I recall, at least)
10:33:00 <ski_> PeakerWork : i think of the three lists as coroutines, and i need to pass a current coroutine state along with the "baton" around the three of them
10:33:05 <ksf> the point is that it _can_ destroy structure.
10:33:13 <dolio> lilac: It's O(n), though.
10:33:19 <PeakerWork> lilac, ski_: I see.  Then I take back my wrong statement.  Its still probably right that the parallel-iteration code may often just be simpler/prettier
10:33:32 <ksf> are continuations design patterns?
10:33:42 <PeakerWork> ski_: do you think it is possible to automatically compile pattern-matching code to fold-using code?
10:33:58 <nolbat> HOW to i suggest to the language committe?
10:34:00 <erikc> ksf: there are plenty of design patterns that are continuations with anthropomorphic labels applied
10:34:13 <ski_> PeakerWork : so after i've gotten the `a' and `kA' i need to keep those in my state when passing control to the second list `foldr', so that it can pair the `a' and the `b' together
10:34:29 <ski_> PeakerWork : maybe .. i'm not sure
10:34:35 <nolbat> after playing with clojure i can now see the advantage of separating pure from impure functions. but i still wish haskell was more practical and less traightjacket
10:34:50 <lilac> @type let unfold = foldr (\a s -> case s of Just (a', as) -> Just (a, a':as); Nothing -> Just (a, [])) Nothing in unfold
10:34:52 <lambdabot> forall a. [a] -> Maybe (a, [a])
10:35:03 <ksf> freedom cannot be attained as long as freedom is willed.
10:35:04 <dolio> Doesn't ndm's supercompiler Church encode all datatypes?
10:35:17 <PeakerWork> nolbat: Haskell is quite practical
10:35:17 <ksf> wallow in its knowledge, and you'll be free.
10:35:28 <Toxaris> nolbat: http://hackage.haskell.org/trac/haskell-prime/wiki/CreateProposal
10:35:31 <lambdabot> Title: CreateProposal - Haskell Prime - Trac
10:35:50 <ksf> make that "wallow in the knowledge of its existence"
10:35:51 <PeakerWork> nolbat: The IO separation basically sums up to a type signature, and is very useful, it does not "impede" practical benefit
10:36:40 <PeakerWork> nolbat: Also, the fact the IO bind is done with an operator that the user can define (for new types) or call allows for Haskell libraries to implement continuations, for loops, and things most languages require primitives for
10:36:45 <ksf> haskell is actuall much, much less bondage&discipline than c++ and java.
10:36:57 <ksf> about as much as scheme i'd say.
10:37:09 <ski_> PeakerWork : "How to zip folds: A library of fold transformers (streams)" <http://okmij.org/ftp/Algorithms.html#zip-folds> (Oleg Kiselyov)
10:37:10 <lambdabot> Title: Algorithms and Data Structures
10:37:19 <arw_> nack. haskell is only the good kind of bondage & discipline.
10:37:21 <Vq^> ksf: as much as scheme? how did you reach that conclusion?
10:37:32 <arw_> the kind where the compiler gets disciplined :)
10:38:00 <ksf> by calculating pi times my thumb.
10:38:08 <PeakerWork> compilation error messages are pretty damn difficult to discern
10:38:19 <Giraffe> 13:34 < dolio> Doesn't ndm's supercompiler Church encode all datatypes? <-- that sounds rather inefficient
10:38:20 <PeakerWork> Surely they could be easier for mere mortals in most cases
10:38:38 <Giraffe> also PeakerWork they take a bit of learning to discern but
10:38:39 <ksf> i'm ignoring things like staticness of the type system and compare expressiveness.
10:39:02 <lament> expressiveness has nothing to do with bondage
10:39:05 <Giraffe> er, but for the most part we wind up looking at the necessary parts of the error messages
10:39:16 <ski_> lilac : will that `zip' using that `unfoldr' really be "O(N)" ?
10:39:24 <dolio> Giraffe: It seems to work out pretty well for him. :)
10:39:38 <ksf> oh yes, it does. no contemporary b&d language is geared towards expressiveness.
10:39:59 <ksf> that is, ease of expression.
10:40:14 <idnar> ksf: so if you ignore all of the B&D elements, there's no B&D? ;)
10:40:40 <ksf> the typesystem is about the only b&d you're going to find.
10:40:45 <idnar> ksf: the main thing is that the "bondage" in Haskell isn't a bad thing
10:40:58 <badtruffle>  /j ##mac
10:41:07 <lilac> ski_: no, it's O(N^2). but as i recall, there is a zip-in-terms-of-foldr which is O(N)
10:41:08 <Giraffe> dolio, well i'm glad about that, but it just seems like a lot for the computer to handle
10:41:08 <badtruffle> whoops sorry :)
10:41:12 <dolio> Giraffe: Then again, maybe wherever I heard that wasn't using "Church encoding" to mean the standard Church encoding. Maybe they meant something more like SAPL.
10:41:19 <idnar> you give up the flexibility to write certain classes of incorrect programs, and in return you get a compiler that tells you where you screwed up
10:41:30 <Giraffe> dolio, what is SAPL?
10:41:33 <ksf> well i wouldn't dare to claim "types are bad" in this channel, even if it were my opinion.
10:41:34 <idnar> in most "B&D" languages, you give things up without getting anything in return
10:41:41 <ski_> (lilac : i.e. oleg's or mine)
10:41:45 <dolio> It's a different encoding of datatypes in terms of functions.
10:41:51 <idnar> for example, the static typing in C or Java don't give you much
10:41:59 <idnar> you just have to do a lot more typing, for no real benefit
10:42:06 <idnar> (no pun intended)
10:42:44 <ski_> dolio : any example ?
10:43:06 <dolio> Example of what?
10:43:11 <ski_> SAPL
10:43:12 <ksf> TH is quite awkward compared to syntax-define, but then you could fix most of that by redefining the ast to be sane.
10:43:12 <dolio> Such an encoding?
10:43:17 <ski_> aye
10:43:19 <nolbat> ksf: how do you mean less bondage than java and c++?
10:43:27 <Giraffe> hmm,,,
10:43:29 <Giraffe> ...
10:43:37 <lament> idnar: eh, static typing always solves the same problem
10:43:41 <ksf> closures, to start off.
10:43:42 <lament> idnar: in java as in haskell
10:43:46 <ksf> it explands to infinity.
10:43:49 <dolio> ski_: I've skimmed some papers, but it essentially looks like encoding each constructor as a church-encoded tuple.
10:43:58 <BMeph> ski: SAPL would do Lists like this:
10:44:11 <dolio> ski_: Which gives you O(1) tail, for instance, instead of O(n).
10:44:21 <ksf> nah, in java it's b&d 'cos you've got to write 80-char types on every second line of code.
10:44:51 <ski_> dolio : so still typed with a recursive type ?
10:45:05 <ksf> it's a bugger to re-define control flow in c++ and java.
10:45:26 <Giraffe> versus haskell, which is all about control flow :P
10:45:39 <lament> ksf: typing 80-char types is a drawback, but it doesn't void the benefits
10:45:54 <ski_> ksf : does TH have any provision for hygiene ?
10:46:02 <ksf> (actually, i planned to try out implementing continuations and coroutines in c++ a while back)
10:46:04 <ksf> ski_, sure.
10:46:10 <dolio> ski_: Well, that's the problem. The encoding doesn't admit recursive functions to be typed without either equirecursive types (I guess) or, in Haskell a recursive newtype wrapper.
10:46:18 <nolbat> ayone know how to kill a gmail-address?
10:46:19 <idnar> lament: well, "yes"
10:46:34 * ski_ supposes he should sometime try to look at TH ..
10:46:34 <idnar> lament: but the haskell type system is a lot more capable than the java type system
10:46:43 <idnar> lament: and has fewer pitfalls
10:46:54 <lament> idnar: sure
10:46:58 <dolio> ski_: Clean uses it as an intermediate language, I guess, but they may not bother having it typed at that point.
10:47:23 <idnar> lament: so you get a lot more in return for "submitting" to the type system
10:47:31 <ski_> (dolio : before or at `ABC' level ?)
10:47:38 <lament> idnar: hahaha god.
10:47:43 <lament> idnar: it's like arguing islam vs. christianity.
10:47:47 <jpcooper> is there a reason why there isn't an actual "if expression"?
10:47:48 <idnar> lament: also, in some cases, you don't have to give up as much
10:47:50 <ksf> nolbat, make a second gmail address, make them forward to each other and let a mail bounce in between them until google kills them both.
10:47:53 <dolio> ski_: I'm not sure what that means. :)
10:48:04 <daf> jpcooper: "if expression"?
10:48:18 <jpcooper> daf, yes
10:48:33 <dons> morning all.
10:48:33 <daf> what does that mean?
10:48:35 <dons> ?users
10:48:35 <lambdabot> Maximum users seen in #haskell: 552, currently: 538 (97.5%), active: 26 (4.8%)
10:48:44 <Deewiant> There is an actual if expression, but no if function
10:48:46 <idnar> lament: that's not to say that there aren't any reasons you might prefer the Java type system to the Haskell type system
10:48:54 <ksf> ski_, to be precise, the th monad takes care of renaming for you.
10:48:55 <BMeph> cons x xs = \f g -> g x xs
10:48:55 <jpcooper> Deewiant, yes, why is that?
10:49:02 <idnar> @src if'
10:49:03 <lambdabot> Source not found. I am sorry.
10:49:03 <Deewiant> Beats me
10:49:05 <BMeph> nil = \f g -> f
10:49:08 <ski_> (dolio : `ABC' is Clean's platform-independent bytecode)
10:49:18 <Deewiant> Wasn't seen as being of use, I suppose
10:49:19 <ksf> it's the splice syntax that sucks.
10:49:28 <dons> anyone got their RWH copies yet?
10:49:30 <vixey> @let cons x xs = \f g -> g x xs
10:49:31 <lambdabot>  Defined.
10:49:41 <dons> i'm intrigued by all the people who have copies -- but aren't in #haskell
10:49:42 <vixey> @let nil = \f g -> f
10:49:43 <lambdabot>  Defined.
10:49:46 <dons> are there more haskellers than i imagined..
10:49:53 <dolio> ski_: Oh. I don't actually know the details of Clean's compiler. I just remember either one of the papers or someone who directed me to them saying Clean used SAPL as an intermediate language.
10:50:18 <vixey> :t (nil, cons)
10:50:20 <lambdabot> forall t t1 t11 t12 t2 t3. (t -> t1 -> t, t11 -> t12 -> t2 -> (t11 -> t12 -> t3) -> t3)
10:50:23 <lament> dons: what, RWH sold more than 538 copies? :)
10:50:45 <vixey> :t cons 1 (cons 2 (cons 3 nil))
10:50:46 <lambdabot> forall t t1 t2 t3 t11 t21 t31 t22 t32 t23 t33. (Num t2, Num t1, Num t) => t23 -> (t -> (t22 -> (t1 -> (t21 -> (t2 -> (t3 -> t11 -> t3) -> t31) -> t31) -> t32) -> t32) -> t33) -> t33
10:50:47 * lament still waiting for his
10:50:59 <dons> oh, its back to #4 in 'languages' books. was #2 yesterday.
10:51:07 <dons> its hard to take over the world
10:51:09 <lament> aw
10:51:09 <ski_> dolio : ok (me neither :)
10:51:11 <idnar> heh
10:51:12 <BMeph> dolio: Ah, that explains where it came from. I still find the whole 'encode ADTs as multipla args to a function' a clever way to pattern-match w/o pattern-matching. :)
10:51:17 <dons> stupid design patterns books
10:51:19 <daf> my significant other ordered me a copy
10:51:27 <vixey> BMeph, very zenny
10:51:32 <lament> dons: one solution. burn them!!!
10:51:39 <idnar> dons: you should have called it Haskell Patterns ;)
10:51:42 <dons> hehe
10:52:02 <dons> doh, Windows.NET Pro C   Pro C# 2008 and the .NET 3.5 Platform is beating us
10:52:14 <BMeph> vixey: Hold on, I'll show you what 'length' looks like, then you'll see 'zenny'. ;)
10:52:25 <Giraffe> dons, gross
10:52:33 <ksf> BMeph, you made me curious.
10:53:05 <nolbat> whats that saying about stealing ideas?
10:53:09 <Giraffe> i won't say we have a problem until F# gets ahead of haskell (perish the thought)
10:53:19 <ksf> dons, that's ea ordering a copy for each of their borg drones or something.
10:53:56 <lament> Pro C Pro C#?
10:54:18 <dons> i know.
10:54:18 <ski_> @kind Pro C#
10:54:19 <lambdabot> Not in scope: type constructor or class `Pro'
10:54:19 <lambdabot> Not in scope: type constructor or class `C#'
10:54:43 <Giraffe> http://broadcast.oreilly.com/2008/11/are-computer-languages-irrelev.html this is terrible :(
10:54:49 <lambdabot> Title: Are Computer Languages Irrelevant? - O'Reilly Broadcast, http://tinyurl.com/5ff8e2
10:54:50 <dons> Giraffe: F# is too tied to windows/.NET for many people
10:54:53 <ski_> (`C#' looked like an unboxed type ..)
10:55:11 <dons> Giraffe: hehe, esp. since o'reilly publishes language books
10:55:30 <Giraffe> dons, honestly
10:55:32 <nolbat> would having Data.Map in the prelude break some elegant semantic stuff?
10:55:38 <BMeph> vixey, ksf: Here it is: length xs = xs 0 (\x xs -> 1 + length xs)
10:55:48 <Giraffe> i'm not a fan of these "Web 2.0" types who seem to think they know everything about computer science
10:55:51 <vixey> @src length
10:55:51 <lambdabot> Source not found. Take a stress pill and think things over.
10:55:56 <vixey> ............
10:56:04 <dons> Giraffe: hehe
10:56:07 <Giraffe> but if somebody is thinking that a web browser could be written in javascript, well...
10:56:07 <vixey> lambdabot, length = foldr (const (+1)) 0
10:56:18 <lament> Giraffe: and why not?
10:56:39 <BMeph> Hm, let's alpha-redux that for better readability: length as = as 0 (\x xs -> 1 + length xs)
10:56:44 <lament> Giraffe: you mean like http://www.bigwebmaster.com/1049.html ?
10:56:44 <badtruffle> "Maybe we need to find better programming languages; better than Java, Python, or even XML."
10:56:49 <lambdabot> Title: Accent JavaScript Browser : A complete, basic, fullscreen web based browser
10:56:52 <badtruffle> XML is a programming language?
10:56:53 <badtruffle> and it's good?
10:56:56 * badtruffle barfs
10:57:04 <vixey> Giraffe, AJAX is new and cool .. no wonder someone is writing about it
10:57:08 <ski_> BMeph : doesn't look so "zenny" to me .. (maybe i was expecting too much ..)
10:57:19 <Giraffe> lament, i was assuming he meant something along the lines of making a GUI outside of a browser
10:57:28 <Raevel> buzzwords rock?
10:57:32 <vixey> just the 'pattern match without pattern matching' bit
10:57:41 <Giraffe> i.e. something separate from a web browser (firefox, ie, opera, etc.)
10:57:46 <lament> Giraffe: sure, and what's the problem with that?
10:58:08 <vixey> lament, do you think it's a good idea?
10:58:10 <ksf> reminds me of those job ads where they're looking for "html programmers"
10:58:16 <BMeph> lament, vixey: Great googly Moogly! A web-based...browser?!? Talk about zenny... ;p
10:58:22 <lament> vixey: not really, but it's better than writing it in C++
10:58:28 <ski_> (vixey : it's like Church encoding in that, "only less so" (since no recursive matching))
10:58:41 <Raevel> we got a bunch of job applications, and they all had HTML listed under programming language skills
10:59:00 <Giraffe> Raevel, did you read past the line where it said that?
10:59:11 <vixey> Raevel, I think it is unnatural to separate HTML out from other programming languages
10:59:13 <p_l> Raevel: Sometimes you just have to play along to HR depts...
10:59:15 <BMeph> Raevel: And if so, why? ;p
10:59:32 <ksf> web-based browsers are ancient. have a look at telnet or, *gasp*, X.
10:59:33 <Raevel> at first no, then we realized it was the agency that sucked and automatically categorized html, xml and whatnot under "programming languages"
10:59:44 <Giraffe> yikes
10:59:47 <vixey> Raevel, that's sensible ...
10:59:59 <Raevel> turns out all the applicants sucked anyway :-P
11:00:08 * p_l has "always try to avoid HR depts" as an article of faith
11:00:12 <ksf> vixey, html ain't a programming language.
11:00:31 <ksf> it's a description language, and doesn't describe processes.
11:00:53 <nolbat> I posted the suggestion to the mailing list, anyone think it ia good idea? {"hello": 12, "there": 1} for Maps, just like python...
11:01:03 <vixey> ksf, That rules out declarative programming such as haskell from the category 'programming languages' then
11:01:26 <ksf> nope.
11:01:28 <vixey> nolbat, you want something like that in haskell?
11:01:41 <Giraffe> nolbat, i have no idea what that even does
11:01:46 <ksf> haskell _can_ and does describe processes.
11:01:54 <ksf> that is, you can write 99 bottles in it.
11:01:59 <lament> Stop the insanity. HTML is a markup language.
11:02:03 <ksf> ...without expanding by hand.
11:02:08 <Giraffe> ksf, damn :P
11:02:17 <nolbat> the new gmail themes are cool, was really needed
11:02:33 <Raevel> i'm trying to compile lambdabot and ghc tells me to use -XPatternSignatures, how can i specify the flag using runhaskell?
11:02:55 <ksf> nolbat, there's Map.fromList
11:02:58 <lament> nolbat: that might clash a bit with existing syntax
11:03:05 <Giraffe> that {"hello": 12, "there": 1} snippet is breaking my brain
11:03:18 <Giraffe> would that make a 12-element list of "hello"s?
11:03:23 <lament> nolbat: in particular, : already means something else
11:03:28 <ski_> > {"hello": 12, "there": 1}
11:03:29 <lambdabot>   <no location info>: parse error on input `{'
11:03:32 <nolbat> ho it is the key "Hello" with thevalue 12
11:03:32 <ksf> I'd rather go the perl way and provide a second , to the list syntax.
11:03:47 <Giraffe> oh!
11:03:51 <Giraffe> a Map, not a map :P
11:03:52 <vixey> Giraffe, I'd probably write something like  associate [ "hello" --> 12, "there" --> 1 ]
11:03:53 <dons> nolbat: interesting.
11:03:54 <ksf> like ["foo"=>1,"bar"=>2]
11:03:56 <dons> i replied.
11:04:03 <Giraffe> right
11:04:10 <dons> nolbat: my concern is that we don't have an obvious Map data type
11:04:10 <nolbat> vixey: ok good idea, just something shortert than fromlist
11:04:12 <dons> while we do for lists.
11:04:17 <ksf> ["foo":1,"bar":2] looks fine to me.
11:04:29 <nolbat> dons: how do you mean obv data type?
11:04:30 <vixey> looks like a type error to me
11:04:41 <dons> nolbat: what data type would the syntax be short hand for?
11:04:48 <Giraffe> :t ["foo":1,"bar":2]
11:04:49 <lambdabot>     No instance for (Num [[Char]])
11:04:49 <lambdabot>       arising from the literal `1' at <interactive>:1:7
11:04:49 <lambdabot>     Possible fix: add an instance declaration for (Num [[Char]])
11:04:53 <Giraffe> :P
11:04:59 <vixey> it needn't be shorthand for any datatype
11:05:08 <lament> > let x (-->) y = (x, y) in fromList ["foo" --> 1, "bar" --> 2]
11:05:09 <lambdabot>   Not in scope: `fromList'Not in scope: `-->'Not in scope: `-->'
11:05:11 <ksf> argh.
11:05:13 <lament> blah
11:05:14 <vixey> with typeclasses you can choose later
11:05:19 <dons> a left-biased bounded, balanced binary tree?
11:05:21 <ksf> don't we have an infix tuple constructor?
11:05:29 <dons> a patricia tree?
11:06:40 <BMeph> lament: I'm gonna go with Glenn Reid, and say that HTML (and XML) are not markup languages. They're anti-markup languages. ;)
11:06:53 <dons> yaya http://twitter.com/mattpodwysocki/status/1026790869
11:06:59 <lambdabot> Title: Twitter / Matthew Podwysocki: Really enjoying Real World ...
11:07:08 <dons> seems like more non-#haskellers are getting into haskell due to RWH. that's good
11:07:14 <lament> > let x ($$$$$) y = (x, y) in Map.fromList ["foo" $$$$$ 1, "bar" $$$$$ 2]
11:07:15 <lambdabot>   Not in scope: `$$$$$'Not in scope: `$$$$$'
11:07:22 <lament> oh, backquotes?
11:07:25 <nolbat> dons: I dont really get your pont {"hello": 12} would be Data.Map String Integer (or however it is you normmaly write it)
11:07:33 <Toxaris> lament: x $$$ y instead of x ($$$) y
11:07:40 <Toxaris> lament: or ($$$) x y
11:07:40 <lament> grr
11:07:46 <dons> nolbat: oh, it would use Data.Map ?
11:07:54 <dons> nolbat: not say, one of the other Map-like types?
11:08:05 <dons> so we'd wire Data.Map as a foundational type?
11:08:14 <dons> or would it be some kind of extensible syntax for tree-like structureS?
11:08:21 <Giraffe> dons, i got into haskell through lisp and scheme, and from there found RWH...i think i just guessed at finding #haskell
11:08:27 <dons> instance DicionaryIsh IntMap ...
11:08:35 <dons> would be interesting, letting you overload dictionary literals
11:08:40 <dons> that would actually be kinda cool
11:08:52 <Giraffe> hopefully i don't seem too painfully green with the language still, i'm still learning
11:08:55 <dons> would work for hashes, maps, other trees.
11:08:59 <dons> Giraffe: yay!
11:09:12 <dons> Giraffe: well, i hope you can build some serious software with haskell.
11:09:19 <dons> we've tried to put everything in place to make that possible
11:09:27 <BMeph> > let x --> y = (x, y) in fromList ["foo" --> 1, "bar" --> 2]
11:09:28 <lament> > let x --> y = (x, y) in Map.fromList ["foo" --> 1, "bar" --> 2]  -- nolbat, is this really so bad?
11:09:29 <lambdabot>   Not in scope: `fromList'
11:09:29 <lambdabot>   fromList [("bar",2),("foo",1)]
11:09:42 <Giraffe> oh, i'm working on an application to catalog e-books as close to automatically as possible
11:09:42 <lament> it's Map.fromList
11:09:53 <lament> in /bot
11:09:57 <dons> Giraffe: oh, that sounds interesting
11:10:00 <erikc> literal overloading is pretty awesome
11:10:18 <Giraffe> it's ridiculously easy to write software in haskell; i like the idea of programming flow moreso than codifying memory allocation
11:10:19 <BMeph> lament: Right, I was just cut&pasting from your earlier try. :)
11:10:30 <Giraffe> because it's high level in one way, but low level in another...a very interesting mix
11:10:52 <Giraffe> and i'm glad that you and everyone else have tried to promote a deep understanding of that instead of just saying "well use this library and shut up"
11:10:54 <idnar> I can't remember now how I got into Haskell; it was probably pjdelport's fault
11:11:02 <lament> on the other hand an infix tuple constructor belongs in the prelude
11:11:19 <dons> > (,) 1 2
11:11:20 <lambdabot>   (1,2)
11:11:24 <lament> oh :)
11:11:32 <nolbat> Prelude Data.Map> let x --> y = (x, y) in Data.Map.fromList ["foo" --> 1, "bar" --> 2]
11:11:32 <nolbat> fromList [("bar",2),("foo",1)]
11:11:32 <lament> that's boring
11:11:35 <dons> well, try, say, type a :*: b = (a,b)
11:11:43 <nolbat> dons: yes it would be Data.Map
11:11:49 <idnar> > 1 , 2
11:11:50 <lambdabot>   <no location info>: parse error on input `,'
11:11:53 <idnar> heh
11:11:59 <ski_> might be interesting to see a Haskell-introducer graph .. (or #haskell-.. for that matter)
11:12:00 <Giraffe> well last night i turned my friend on to haskell when he started complaining about how terrible C++ is for genetic programming
11:12:01 <dons> nolbat: so what if we wanted to use some other map type? like Hashtable or IntMap or Trie?
11:12:11 <dons> Giraffe: hehe
11:12:11 <Toxaris> nolbat: I don't think Data.Map should get special syntax sugar
11:12:12 <dons> good work
11:12:32 <ksf> > Map.fromList $ "foo" ,  2 : "bar , 2 : []
11:12:34 <lambdabot>   <no location info>: parse error on input `,'
11:12:35 <Giraffe> he keeps sending me snippets of code like fibonacci sequences and the like, it's pretty hilarious
11:12:41 <dons> nolbat: the difficulty is that while Data.List is simple, canonical - -- a straight forward recursive type. Data.Map is non-trivial, and subject to change
11:12:44 <ksf> > Map.fromList $ "foo" ,  2 : "bar" , 2 : []
11:12:45 <lambdabot>   <no location info>: parse error on input `,'
11:12:45 <dons> its also not a core library
11:12:47 <Toxaris> nolbat: Its just not *that* important. But the general concept of maps could, maybe, seen as that important
11:12:58 <Giraffe> but the whole "look what i did!"/childlike wonder phase never really has gone away from either of us, so i think that's fine
11:12:59 <dons> yes. dictionaries in general.
11:13:01 <dons> hehe
11:13:42 <nolbat> dons: i didnt know there wer eother map-like. and rest of what you said i dont really follow. look im not on yoru level om competence, im just a pythons cript kiddie and i wonder why haskell cant be a little less nice to me
11:13:46 <Toxaris> and if one uses the syntax [key1 -> val1, key2 -> val2]  one doesn't even need to introduce new keywords
11:14:03 <dons> nolbat: oh, i understand! its a really good suggestion, imo.
11:14:07 <dons> literal dictionaries
11:14:20 <dons> the challenge is to make it sufficiently general to justify new syntax.
11:14:22 <Giraffe> nolbat, are you sure you aren't a troll?
11:14:27 <dons> Giraffe: no no.
11:14:28 <ski_> ksf : no tuples without brackets (like you'd get in O'Caml)
11:14:42 <dons> nolbat: so we have a few different map types, which would make it interesting, imo.
11:14:51 <dons> how to support whatever map you like, using the same syntax
11:14:54 <erikc> dons: has overloading of list literals and pattern matching been considered?
11:15:01 <dons>  a bit like how we support overloaded strings and numbers already
11:15:11 <erikc> e.g. if i wanted to have a list implementation that was in packed memory
11:15:13 <vixey> erikc, of pattern matching? how do you want to change it?
11:15:13 <dons> erikc: well, patterns via views. lists are just the list type
11:15:15 <dons> ?src []
11:15:15 <lambdabot> data [] a = [] | a : [a]
11:15:19 <lament> i think syntax sugar for assoc lists makes sense
11:15:31 <luite_> Giraffe: hm, I don't really find genetic algorithms (haven't done genetic programming yet) very easy in haskell. I still have a lot of state to keep track of, random number generators, history for automatic parameter adjustments etc.
11:15:45 <BMeph> dons: Yes! I want Lua-style tables in Haskell! :)
11:15:51 <lament> a typeclass for maps makes even more sense
11:16:05 <erikc> yea...views will do the matching
11:16:16 <ski_> last (_ ++ [x]) = x
11:16:19 <nolbat> thats cool though i didnt know you could amke yout syntax in haskell that easily
11:16:24 <luite_> Giraffe: not that it's worse than C++ or Java (in which I have done some gp), but still not trivial.
11:16:25 <Giraffe> luite_, the advantage for him, he says, is that the typing system works very well for a lot of situations
11:16:59 <erikc> vixey: i guess i mean having a type class for overloading the list syntax, in the same way overloaded strings can be used for bytestrings now
11:17:06 <Giraffe> oh, it's not trivial for any language, i'd imagine
11:17:08 <luite_> Giraffe: yes that's true, and it's so much easier to build a search algoritm from basic building blocks
11:18:00 <adekoba> ski_: Hi. About pattern matching the data type, it seems like it is so ambiguous that GHC won't accept it. Here is what I have, with the complete error at the end: http://hpaste.org/12439#a5
11:18:18 <nolbat> Giraffe: is haskell good for that? as good as lisp?
11:18:38 <BMeph> Giraffe: Are you sure you didn't mean *geneRic* and nor *geneTic*? :)
11:18:52 <Giraffe> nolbat, LISP would be good for that too, it would seem, but having never used LISP for GP i couldn't tell you
11:18:53 <nolbat> dons: ok i see
11:18:57 <ksf> then, while we're changing more and more syntax to just be typeclass'ed parsers, we could just make all of the ast typeclassed.
11:19:01 <luite_> Giraffe: some of my parameter adjustments functions took a few classes in java, are just a few lines of code now. but it requires some monad transformers in the background
11:19:02 <dons> adekoba: Frame (ID x,x) ?
11:19:06 <dons> that doesn't look valid?
11:19:18 <ksf> ...and finally get ourselfs a syntaxDefine
11:19:27 <dons> or is it.
11:19:42 <nolbat> little mroe nice to me i emant obv ^^
11:19:43 <Toxaris> with a class for list-like things, and --> as defined above, we wouldn't need a class for dictionary-like things, would we?
11:19:46 <vixey> ksf, even just adding distfix would probably be enough
11:19:47 <adekoba> dons: it compiles
11:20:30 <Giraffe> luite_, i imagine that it wouldn't be so difficult (with the exception of the RNGs) to chop up the programs functionally
11:20:58 <dons> adekoba: is it a change from 6.10 to 6.8
11:21:00 <dons> ?
11:21:16 <pumpkin_> I want ghc 8!
11:21:28 <idnar> Toxaris: you'd still need to explicitly call some kind of fromList function
11:21:36 <pumpkin> @faq can haskell solve the halting problem?
11:21:36 <lambdabot> The answer is: Yes! Haskell can do that.
11:21:40 <pumpkin> yay
11:21:40 <adekoba> dons: not quite sure, but it's definitly an extension.
11:21:43 <Toxaris> idnar: the special ListLike syntax + typeclass would do that for me
11:21:49 <Jedai> Giraffe: You can use a Random (State) monad to keep track of the RNG implicitly (it really should be included with System.Random in my opinion)
11:21:56 <pumpkin> @faq can haskell tell me if a given CFG accepts all languages?
11:21:57 <lambdabot> The answer is: Yes! Haskell can do that.
11:22:00 <pumpkin> yay
11:22:08 <Toxaris> idnar: since [a, b, c] would mean (fromList (a : b : c : []))
11:22:13 <Giraffe> @faq can haskell clean my room?
11:22:13 <lambdabot> The answer is: Yes! Haskell can do that.
11:22:20 <idnar> Toxaris: so there would be a ListLike instance for Data.Map?
11:22:29 <pumpkin> Giraffe: that's dumb, clearly haskell can't do that!
11:22:36 <pumpkin> duh!
11:22:50 <Giraffe> pumpkin, well then clearly we need to get to work on making it happen!
11:23:14 <pumpkin> @faq can haskell tell me the kolmogorov complexity of a string?
11:23:15 <Jedai> pumpkin: You just have to program a robot to build a robot that clean your room, it can be done in Haskell !!
11:23:15 <lambdabot> The answer is: Yes! Haskell can do that.
11:23:19 <pumpkin> yay!
11:23:25 <idnar> Toxaris: what about the Eq constraint or whatever?
11:23:44 <dons> yes. robots are done.
11:24:04 <ksf> @faq can haskell tell me whether or not lambdabot makes up haskell features?
11:24:04 <lambdabot> The answer is: Yes! Haskell can do that.
11:24:06 <pumpkin> @faq can haskell generate a problem that haskell cannot solve?
11:24:07 <lambdabot> The answer is: Yes! Haskell can do that.
11:24:19 <pumpkin> yay!
11:24:31 <luite_> Giraffe: depends on where exactly you need which data. if you just see, for example, the perturbation (mutation) and recombination functions as some functional thing that only needs an rng, then it would be easy. but what if you have a function that adjusts a parameter of the perturbation function depending on the recent history of how often a local search function (executed after perturbation) returned to the previous optimum, before perturbation?
11:24:58 <nolbat> dons: ok i see, thanks a loy
11:25:06 <Toxaris> idnar: with  class ListLike list elem where fromList :: [elem] -> list  one could have  instance Ord key => ListLike (Data.Map.Map key val) [(key, val)] where fromList = Data.Map.fromList
11:25:21 <Toxaris> idnar: at least I guess so :)
11:25:21 <ski_> adekoba : actually, of course you can't match on the second part without already having matched (or otherwise determined the `x') in the first part .. (i suppose i'm a bit too tired)
11:25:43 <idnar> Toxaris: I don't think that actually works, because fromList has the wrong type
11:25:50 <Giraffe> luite_, right
11:25:52 <idnar> Toxaris: it's the same problem as, for example, defining a Monad instance for Set
11:26:07 <luite_> Giraffe: I'm trying to make it as 'composable' as possible, most of it seems to be possible with the right kind of monads, but I'm still figuring out the best way to do it :)
11:26:12 <Giraffe> it's not my project, though, so i couldn't really tell you anything about how he's implementing it :P
11:26:27 <ski_> dons : why wouldn't `data Frame = forall x. Frame (ID x,x) String' work (in the sense of type-checking) ?)
11:26:37 <adekoba> ski_: ar, that's poopy. Thanks though.
11:26:59 <Toxaris> idnar: really? but in Monad, there is an explicit (and for set: wrong) universal quantification in the type of a method
11:27:09 <luite_> and if all else fails, I can still pass everything in IORefs ;)
11:27:15 <Toxaris> idnar: while in my ListLike, all type variables are bound in the class / instance head
11:29:15 <idnar> Toxaris: what's the difference between fromList :: [elem] -> list, and return :: a -> m a?
11:29:26 <idnar> oh
11:29:29 <idnar> right, I see
11:29:38 <Toxaris> idnar: the "forall a"
11:29:45 <ski_> adekoba : so, if you want to use a GADT, you really have to either match on the `id' part .. (or you could make a `data Frame x = Frame (ID x,x) String',`data SomeFrame = forall x. SF (Frame x)',and a function of type `Frame x -> Either (Equal x Text) (Equal x Date)' and pattern-match on the result of that)
11:30:02 <ski_> adekoba : in any case, it still isn't clear to me that GADTs is really what you want
11:30:04 <pumpkin> idnar: what is the problem with defining a Monad instance for Set? I've wondered
11:30:08 <Toxaris> idnar: thats why I used MPTCs instead of constructor classes
11:30:23 <luite_> pumpkin: you need Eq, possibly Ord for sets
11:30:29 <Cale> pumpkin: Set operations require an Ord instance which you're not allowed to assume when writing an instance of Monad
11:30:31 <Deewiant> pumpkin: You have to give a constraint for 'a', but you only have 'm' when you define the instance
11:30:32 <ski_> (adekoba : i went with it because you said that's what you wanted ..)
11:30:44 <Cale> The problem is that the Monad class does not express what it means to be a monad in general
11:31:02 <Cale> It only expresses what it means to be a monad on the full category of Haskell types.
11:31:05 <idnar> Toxaris: yeah, I see now
11:31:08 <pumpkin> ah
11:31:21 <nolbat> where is IntMap
11:31:22 <luite_> Cale can type way faster than I ;)
11:31:23 <nolbat> ?
11:31:33 <Deewiant> Data.IntMap
11:31:35 <Raevel> oh, it took me 3 minutes to write my first lambdabot module
11:31:39 <Raevel> \o/
11:31:45 <ski_> (Giraffe : only Clean could do that .. (since "Uniqueness types can change the world!"))
11:32:01 <ski_> (or was it s/Uniqueness/Linear/ ?)
11:32:07 <vixey> Linear
11:32:13 <ski_> ty
11:32:41 <JuanDaugherty> ity
11:32:58 <JuanDaugherty> ski_, are you the ski from #prolog?
11:34:33 <ski_> JuanDaugherty : the same
11:34:51 <BMeph> I think we really need to start using comonads more in Haskell. :)
11:34:52 <JuanDaugherty> ah.
11:35:10 <nolbat> but IntMaps are just a special case of Maps right? it is just Maps with Integer keys?
11:35:34 <nolbat> so why make the separation?
11:35:45 <kpreid> IntMap is a more efficient implementation
11:36:03 <nolbat> much more? why is it more efficient?
11:36:56 <luite_> it uses a patricia trie, so needs more information about the keys than just Ord
11:38:23 <Toxaris> ListLike including dictionary syntax: http://hpaste.org/12447
11:40:52 <Toxaris> actually, with this class as sugar for list literals, there would be no need for StringLike or how is it called
11:41:39 <Toxaris> because "hello world" could be defined to mean ['h', 'e', ... 'd'] which in turn means (fromList ['h', 'e', ... 'd'])
11:42:01 <Toxaris> but I guess the return-type polymorphism could turn out to be not handy enough for actual use
11:43:18 <dolio> There's some debate about whether IntMap is significantly faster than a Data.Map.Map specialized to Int keys (which would allow the compiler to do more optimizations) would be.
11:44:29 <arw_> debate? how about, uhm, benchmarks?
11:44:59 <dolio> Go ahead and write them. :)
11:45:04 <dolio> I don't feel like it.
11:45:14 <erikc> has anyone done FFI binding generation from DWARF/PDB information?
11:45:50 <erikc> cause ive developed a DWARF -> Lua/C code generator for Lua/C binding and doing a haskell one would be a matter of changing the backend on the generator
11:46:15 <erikc> the generator is written in haskell, of course :)
11:47:09 <erikc> the one significant advantage vs something like hsc2hs is it can generate aggregate data type bindings
11:47:22 <ski_> > ['h', 'e' .. 'd']
11:47:45 <ski_> @botsmack
11:47:46 <lunabot>  :)
11:48:20 <Deewiant> , ['h', 'e' .. 'd']
11:48:22 <lunabot>  "he"
11:48:35 <Deewiant> wat
11:48:36 <Deewiant> , ['h', 'a' .. 'd']
11:48:39 <lunabot>  "h"
11:48:58 <vegai> everything's broken
11:48:59 <Deewiant> Oh, right
11:49:00 <ski_> , ord 'h' - ord 'e'
11:49:03 <lunabot>  3
11:49:06 <Toxaris> > [1, 3 .. 10]
11:49:07 <Deewiant> , ['h', 'e', 'a' .. 'd']
11:49:09 <lunabot>  luna: parse error on input `..'
11:49:11 <Deewiant> Good
11:49:13 <Toxaris> , [1, 3 .. 10]
11:49:13 <idnar> heh
11:49:15 <lunabot>  [1,3,5,7,9]
11:49:27 <Toxaris> , ['a', 'c', 'x']
11:49:27 <Toxaris> , ['a', 'c' .. 'x']
11:49:30 <lunabot>  "acx"
11:49:31 <lunabot>  "acegikmoqsuw"
11:50:12 <vegai> , head $ reverse ['a', 'b', ..]
11:50:14 <lunabot>  luna: parse error on input `..'
11:50:24 <vegai> , head $ reverse ['a', 'b' ..]
11:50:49 <lunabot>  '\1114111'
11:50:52 <Toxaris> , maxBound :: Char
11:50:56 --- mode: irc.freenode.net set +o ChanServ
11:51:03 <ski_> @botsnack
11:51:14 <lunabot>  '\1114111'
11:51:16 <lunabot>  :)
11:51:16 <lambdabot> :)
11:51:22 * ski_ smacks lambdabot up the haid
11:51:28 <vegai> Toxaris: slightly more efficient, yes
11:51:34 <dolio> > (1, 3 ...)
11:51:35 <lambdabot>   <no location info>: parse error on input `)'
11:52:13 <Deewiant> > let (...) = negate in (1, (3...))
11:52:15 <lambdabot>   (1,-3)
11:52:46 <Toxaris> @check \n -> (take n ['a' ..] == take n ['a', 'b' ..])
11:52:47 <lambdabot>   "OK, passed 500 tests."
11:54:01 <dolio> @oeis 1 2 4 16
11:54:05 <lambdabot>  Number of degree-n permutations of order dividing 4.
11:54:07 <lambdabot>  [1,1,2,4,16,56,256,1072,6224,33616,218656,1326656,9893632,70186624,574017536...
11:54:09 <lilac> is this: "do m <- newEmptyMVar; forkIO (x >> putMVar m ()); takeMVar m; return ()" equivalent to this: "f >> return ()"?
11:54:44 <erikc> also, it will let you bind stuff like generated c++ template data structures to haskell, which parsing based approaches dont have a prayer to do
11:54:46 <Deewiant> if f == x... I think so
11:54:56 <lilac> Deewiant: right, oops :)
11:55:20 <dolio> Exceptions from x will be thrown in different threads.
11:55:41 <dolio> So, probably not.
11:55:58 <lilac> dolio: what about if the latter is wrapped by a catch?
11:56:44 <dolio> I'll go with "probably" in that case. :)
11:57:12 <Deewiant> Bloody asynchronous exceptions, always mucking things up
11:58:06 <ksf> asynchronous exceptions are brain-damaged.
11:58:15 <lilac> has anyone here used Sound.OpenAL? all i'm getting from it are exceptions :(
11:59:17 <Toxaris> in a sense, all IO actions are equivalent, because they will do random things anyway
11:59:25 <Toxaris> not a very practical point of view, though
11:59:37 <lilac> Toxaris: not a view i'd want to take while refactoring :)
12:00:06 <dolio> Oh, well, if it's asynchronous exceptions, then possibly they still aren't the same, since such an exception thrown into the original thread might not get caught in the first case, but might in the second.
12:00:56 <Toxaris> imho IO should be broken down into a lot of small pieces, to get guarantees like "this program may launch the missiles, but it will never read from my hard drive"
12:01:35 <ksf> why should it be caught in another thread? it did nothing wrong, so it's plain brain-damaged to catch it there.
12:01:58 <ksf> Toxaris, that's what permissions are for.
12:02:16 <Deewiant> In principle I think it's a good idea but you might have to pepper the code with too many 'runHardDisk'-type calls making it a pain
12:02:37 <lament> ksf: no, permissions are a hack because IO does not have that granularity :)
12:03:12 <ksf> it's a matter of changing openFile to FilePath -> Either Handle IOError
12:03:42 <ksf> :t openFile
12:03:43 <lambdabot> Not in scope: `openFile'
12:03:47 <ksf> thought so.
12:03:50 <Deewiant> ?hoogle openFile
12:03:51 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
12:04:20 <Toxaris> ksf: do you mean FilePath -> IO (Either Handle IOError)?
12:04:28 <ksf> yeah.
12:05:01 <Toxaris> well, thats ErrorT IOError IO Handle, isn't it?
12:05:11 <Toxaris> so its just a more fine-grained monad
12:06:06 <Toxaris> I would prefer: openFile :: MonadHardDisk m, MonadError IOError m => filePath -> IOMonad -> m IOHandle
12:06:32 <cjb> is there a way to get GHC/ghci to show me each function invocation (with args/result0 of a recursive call?
12:06:35 <ksf> MonadHarddisk is ... erm ... NOT UNIX
12:06:49 <Toxaris> ksf: ?
12:07:10 <ksf> Everything's a file.
12:07:22 <Toxaris> oh ok, so you prefer MonadFileSystem?
12:07:26 <ksf> the fact that you've got a file does'nt mean its on the harddisk.
12:07:36 <Deewiant> MonadSoftDisk
12:07:40 <lilac> MonadFS?
12:08:04 <Toxaris> ksf: btw. Haskell is not unix, either :)
12:08:12 <ksf> that's why there already are permissions, so i can restrict any program to only use (or even see) specific parts of the hierarchy.
12:08:38 <ksf> safe that for an OS implemented solely in haskell.
12:08:45 <ksf> ...and do permissions like that.
12:09:15 <ksf> I don't want to have a language where I have to ask for permission to ask for permission to start my program.
12:09:44 <Toxaris> ksf: well, obviously, IO would be an instance of all these MonadSomething classes, so you could just use IO
12:10:16 <lilac> can someone try this for me in ghci: ":m +Sound.OpenAL" then "get alErrors"
12:10:30 <lilac> ... and tell me if you get a segfault or if my openal is busted?
12:10:59 <ksf> wait a sec till it compiles.
12:11:08 <ksf> openal in general works for me.
12:11:18 <Deewiant> openal depends on OpenGL? O_o
12:11:22 <ksf> (though sometimes sample rates are borked)
12:11:26 <hackage> Uploaded to hackage: cgi 3001.1.7.1
12:11:26 <ksf> strangely enough, yes.
12:11:33 <ksf> most likely common vector stuff.
12:11:34 <lilac> Deewiant: yes, for a fairly perverse reason afaics
12:11:40 <ksf> the c libs don't depend on each other.
12:11:50 <lilac> for one thing it uses genObjectNames which is an OpenGL oddity
12:11:51 <Deewiant> Ridiculous
12:12:05 <lilac> i should say HOpenGL oddity
12:12:45 <ksf> openal implementations aren't the stuff you want to use if you want proper spacial audio, btw.
12:13:00 <lilac> ksf: i just want *any* audio output :)
12:13:02 <ksf> last time i checked the linux implementation did nothing more than panning.
12:13:06 <ksf> jack.
12:13:14 <ksf> but i never tried any haskell bindings for that.
12:13:41 <ksf> Loading package OpenGL-2.2.1.1 ... linking ... done.
12:13:41 <ksf> Loading package OpenAL-1.3.1.1 ... linking ... done.
12:13:41 <ksf> []
12:13:56 <Deewiant> I'm still compiling OpenGL :-P
12:13:58 <lilac> right, so my openal or hopenal is broken :(
12:14:03 <ksf> on ghci 6.8.3, taht is.
12:14:10 <lilac> hmm. i'm on 6.10.1
12:14:19 <ksf> ...and i thought my pc was slow.
12:14:27 <Deewiant> I can provide a 6.10.1 result when this thing has finished compiling
12:14:32 <ksf> it's decoding dvb-t at the same time.
12:14:33 <lilac> thanks
12:15:18 <Deewiant> Well, this is 84 object files which it has to build twice, and it only uses one core :-)
12:16:09 <ksf> model name      : AMD Athlon(tm) 64 Processor 3200+
12:16:14 <ksf> you're doing something wrong.
12:16:24 <ksf> any dual-core should be vastly faster than mine.
12:16:49 <Deewiant> The CPU usage is usually between 20 and 50
12:17:09 <Deewiant> Based on 'top', at least. Might not have enough granularity.
12:17:22 <Deewiant> model name	: Genuine Intel(R) CPU           T2400  @ 1.83GHz
12:17:50 <Deewiant> You might have more bogomips on that one, actually. This /is/ a laptop, after all.
12:18:06 <ksf> compilation shouldn't be that io-bound.
12:18:15 <ksf> bogomips        : 4007.91
12:18:19 <Deewiant> bogomips	: 3657.43
12:18:46 <ksf> it's also got 1mb cache.
12:19:03 <lilac> AMD Athlon(tm) 64 X2 Dual Core Processor 6000+, bogomips : 2010
12:19:08 <Deewiant> Wow, 2 megs here
12:19:11 <lilac> that doesn't look right :(
12:19:13 <Deewiant> lilac: heh
12:19:19 <ksf> cpu MHz         : 2002.630
12:19:30 <Deewiant> Hmm, actually
12:19:40 <lilac> cpu MHz         : 1000.000
12:19:41 <Deewiant> Maybe the CPU governor is being too conservative
12:19:51 <Deewiant> I'm also running at 1 GHz
12:19:54 * lilac thinks something is /seriously/ borked here
12:21:14 <Deewiant> lilac: get alErrors gives [], on 6.10.1.
12:21:37 * lilac tries reinstalling openal
12:23:51 <Deewiant> It seems that the CPU governor indeed thought that the usage was too little to justify increasing the MHz; running an infinite busy-loop /proc/cpuinfo reports 1833 MHz
12:25:12 <ksf> @faq can compiling haskell make your machine faster?
12:25:12 <lambdabot> The answer is: Yes! Haskell can do that.
12:25:24 <EmielRegis> lol
12:25:54 <EmielRegis> @faq can GC refuse to claim 10GB of Data.Map in ram?
12:25:55 <lambdabot> The answer is: Yes! Haskell can do that.
12:25:58 <lilac> hmm. maybe the ubuntu openal packages are broken :(
12:26:02 <EmielRegis> indeed it can!
12:26:56 <lilac> hehe, 'cat /dev/urandom > /dev/null' triples my cpu speed and bogomips
12:38:34 <lilac> ksf, Deewiant: if you still have your build logs, did it say 'checking value of AL_PLAYING... -1' ?
12:41:37 <ksf> checking value of AL_PLAYING... 4114
12:42:01 <Deewiant> does cabal-install keep logs?
12:43:54 <lilac> do you have a /usr/include/AL/al.h or a /usr/include/OpenAL/al.h?
12:44:40 <ksf> ksf@solaris ~ % grep AL_PLAYING /usr/include/AL/al.h
12:44:40 <ksf> #define AL_PLAYING                                0x1012
12:44:52 <Deewiant> ditto
12:45:05 <ksf> openal-dev?
12:45:24 <lilac> my /usr/include/AL/al.h includes it too
12:45:59 <lilac> but the configure-generated conftest.c doesn't include al.h
12:46:10 <ksf> gremlins in the conductor substrate?
12:46:20 <Deewiant> Reverse the polarity!
12:47:04 <lilac> missing #includes in configure, line 7838ish
12:47:18 <thoughtpolice> sound the alarm!
12:48:33 <lilac> does your alext.h or alc.h include al.h by any chance?
12:49:31 <Deewiant> alext.h does
12:49:35 <ski_> > fix ("\abeep! " ++)
12:49:36 <lambdabot>   "\abeep! \abeep! \abeep! \abeep! \abeep! \abeep! \abeep! \abeep! \abeep! \a...
12:49:49 <lilac> Deewiant: ah, that'll be why it works for you and not for me then
12:50:31 <vixey> hehehe
12:50:43 <vixey> > fun (fix ("\abeep! " ++))
12:50:44 <lambdabot>   Add a type signature
12:50:48 <vixey> > var (fix ("\abeep! " ++)) :: Expr
12:50:49 <lambdabot>       Ambiguous occurrence `var'
12:50:49 <lambdabot>      It could refer to either `Data.Number.S...
12:50:51 <vixey> :/
12:50:55 <vixey> > fun (fix ("\abeep! " ++)) :: Expr
12:50:57 <lambdabot>   beep! beep! beep! beep! beep! beep! beep! beep! beep! beep! beep! beep! bee...
12:51:04 <opqdonut> almost
12:51:48 <lilac> greh, this just reminds me of why i hate autotools so much :(
12:51:53 <ski_> (`Data.Number.Symbolic' or `SimpleReflect')
12:56:15 <lilac> success! never before have i been so happy to hear a 10KHz sine wave
13:01:45 <Aviator> kudos to read world writers
13:03:36 <dons> cheers!
13:03:53 <dons> Aviator: do you have a hard copy?
13:04:23 <Aviator> no, there's no copy at my country
13:04:32 <dons> oh, what country?
13:04:43 <dons> i'm interested to know when they start arriving in different places.
13:04:48 <opqdonut> yeah kudos, i'm planning on using it on a haskell course i'm teaching next spring
13:04:51 <dons> so far just east coast USA and at least one on the west coast.
13:04:56 <Aviator> i live in egypt, but i plan to make a special order
13:05:04 <dons> opqdonut: oh, wonderful! maybe i should start collecting that kind of info.
13:05:12 <dons> opqdonut: penn and stanford and willamette are using it too
13:05:15 * cjb will hunt for one at the MIT coop next week
13:05:15 <erikc> amazon.ca still says not released yet
13:05:19 <dons> Aviator: oh, wow.
13:05:23 <Raevel> i'm in sweden, one store says it's out of stock now, but i have a feeling they haven't gotten any copies yet anyway
13:05:35 <dons> Raevel: yes. that's interesting :)
13:05:57 <dons> Aviator: how would you typically get it in Egypt? from Amazon? or local bookstores?
13:06:23 <opqdonut> dons: yeah i'm from univ helsinki (finland)
13:06:32 <Aviator> there's a university bookstore that handle the special orders
13:06:52 <Aviator> programming books are really rare here
13:06:57 <Japsu> opqdonut: oh cool, you're teaching haskell at the uni or ... ?
13:07:01 <opqdonut> Japsu: yeah
13:07:08 <Japsu> opqdonut: nice
13:07:15 <opqdonut> Japsu: there was nobody else :D
13:07:18 <Japsu> opqdonut: lol
13:07:26 <dons> Aviator: very interesting. is there anything I can do to make it easier to obtain?
13:07:30 <Japsu> opqdonut: you haven't corrupted Asran yet, then? ;P
13:07:34 <opqdonut> but a big demand for a course, so I ended up organising it
13:07:36 <Raevel> we don't have any haskell courses, it's pretty sad
13:07:40 <opqdonut> Japsu: yeah he's helping along
13:07:43 <Japsu> rihgt
13:07:46 <Japsu> ;)
13:07:48 <lament> Raevel: sweden has Chalmers!
13:07:48 <Japsu> hmm
13:07:51 <dons> opqdonut: so perhaps i should start a wiki page to provide resources and help for teaching with the book?
13:07:55 <Japsu> wonder if they'll let me JOO your course
13:07:58 <opqdonut> dons: sounds good
13:08:05 <Raevel> lament: and kth uses haskell as well
13:08:07 <dons> links to other coures. references. mm.
13:08:11 <Japsu> but hmm, I should probably start applying already...
13:08:18 <dons> make it super easy to fire up a decent course around the book.
13:08:42 <dons> opqdonut: emphasis on FP or parallelism or ?
13:08:43 <opqdonut> Japsu: probably
13:08:49 <opqdonut> dons: intro to FP basically
13:08:50 <Raevel> dons: sounds cool
13:09:05 <Japsu> opqdonut: you're making it remote-friendly, right? ;)
13:09:11 <opqdonut> dons: we plan to balance between hard theory and practical aspects
13:09:16 <Raevel> i'd love to give a haskell course some day, but perhaps i should try to graduate first
13:09:19 <dons> opqdonut: very nice. the other courses I think are using it for Adv. FP.
13:09:23 <opqdonut> Japsu: probably yeah
13:09:26 <dons> e.g. to teach STM, parallelism etc.
13:09:30 <opqdonut> yeh
13:09:42 <Aviator> dons: there's already an online version, i couldnt thank more
13:09:44 <opqdonut> the profiling chapter esp. is something that need to be taught on a basic course
13:09:48 <opqdonut> imo
13:10:06 <dons> Aviator: ah wonderful. Yes, I think that's important for places that don't have easy access to books at a reasonable price.
13:10:27 <dons> democratising haskell :)
13:10:41 <opqdonut> the practical chapters on monads, parsec etc are great too
13:11:07 <Aviator> currency exchange between egp and usd is a bit "depressing", but im ready to sacrifice my money to get the print version
13:11:26 <hackage> Uploaded to hackage: compact-string 0.3.1
13:11:26 <hackage> Uploaded to hackage: tar 0.1.1.3
13:13:36 * yaxu goes round in circles trying to do regex replace
13:13:57 <yaxu> I found a simple example using "import Text.Regex(subRegex,mkRegex)"
13:14:10 <yaxu> but hoogle denies their existence
13:17:20 <dons> yaxu, well, that's probably Text.Regex.Compat ?
13:19:04 <yaxu> aha, thanks dons
13:22:40 <lilac> conal: the reactive docs linked to from the Reactive wiki page are missing (http://code.haskell.org/reactive/doc/html/)
13:22:43 <lambdabot> Title: Index of /reactive/doc/html
13:23:05 <conal> lilac: oh, thanks.  i'll fix the link to point to hackage.
13:24:07 <conal> oh, wonk.  that page got messed up.  digging through old versions ..
13:25:19 <conal> oh, nm.  just needs a little tweak.
13:27:51 <conal> lilac: fixed.  thanks a bunch!
13:28:20 <vixey> it's a little strange I think how we curry like  (a,b,c) -> (x,y,z) into a -> b -> c -> (x,y,z) but (x,y,z) sticks around
13:28:48 <lilac> conal: np. in return, how about adding 'type Behaviour a = Behavior a' ? :)
13:29:21 <Beelsebob> vixey: so CPS it!
13:29:33 <lilac> vixey: would you prefer (a,b,c) -> (x,y,z)  ~>  a -> b -> c -> (x -> y -> z -> r) -> r?
13:29:36 <Beelsebob> lilac: YES!
13:29:39 <Beelsebob> so so yes!
13:29:45 <conal> lilac: oh!  i just got the difference.  good idea.  probably the same for color/colour in fieldtrip.
13:30:37 * Beelsebob giggles about the "discussions" camio, conal, luqui and he had about american spelling
13:31:28 <conal> lilac: done.  will be in the next push & release.
13:32:44 <lilac> conal: awesomeness.
13:35:34 <conal> lilac: i also just restored a lost paragraph on connecting to "legacy" (i.e., imperative) libraries
13:40:39 <lilac> conal: you seem to have reverted the doc link :o
13:40:56 <conal> oops!
13:40:58 <conal> :p
13:41:03 <conal> trying again.
13:41:16 <lilac> conal: also, the docs aren't linked to from the hackage page!
13:41:20 <Toxaris> vixey: every function of type (a, b) -> (x, y) can be written as (uncurry f &&& uncurry g) for some f and g
13:41:46 <Toxaris> @type \f g -> uncurry f &&& uncurry g
13:41:47 <lambdabot> forall a b c c1. (a -> b -> c) -> (a -> b -> c1) -> (a, b) -> (c, c1)
13:41:53 <Beelsebob> Toxaris: I don't think he was commenting on that
13:41:59 <RayNbow> vixey, Beelsebob, lilac, http://hpaste.org/12448 ?
13:42:02 <gwern> in haddock syntax, does one 'String' or "String"?
13:42:03 <Beelsebob> he was commenting that it's easily possible to eliminate an "input" tuple
13:42:13 <Beelsebob> but not easily possible to eliminate an "output" tuple
13:42:20 <Beelsebob> (which it actually is, using CPS)
13:42:31 <Toxaris> vixey: so you can eliminate an output tuple by giving a seperate function for each component
13:43:20 <Toxaris> yeah, CPS rules, I being made aware of that every other day
13:44:07 <Beelsebob> CPS is the opposite of currying -- it's what you get when you take a tuple as output, and replace it with a function on the input
13:44:27 <thoughtpolice> gwern: 'String' if you want to reference String as e.g. a data type or something
13:44:34 <gwern> ah
13:44:37 <thoughtpolice> (that is, make a hyperlink to its definition)
13:44:45 <conal> lilac: fixed again.  thanks.  please keep bugging me when you see stuff like this.  the missing hackage docs is from a build failure, which i'm glad to know about.  i'll check it out.
13:44:49 <gwern> so it's like the function syntax as well
13:45:05 <thoughtpolice> oi, the lhc mailing list is being funky.
13:45:18 <Aviator> "CPS as the opposite of currying" i think i'm enlightened
13:45:18 <thoughtpolice> maybe things will normalize a little later.
13:45:23 <conal> lilac: meanwhile you can grab the previous version's docs
13:45:42 <conal> lilac:  via the link on that hackage page
13:46:03 <FunctorSalad> Beelsebob: do you have a quick type sig example to illustrate that?
13:46:11 <conal> lilac: and you can build the docs locally with 'runhaskell Setup.hs doc'
13:46:15 <FunctorSalad> sorry I'm being too lazy
13:46:24 <mm_freak> > flip evalState 0 $ fix (\k -> modify (+1) >> get >>= \s -> k >>= \ss -> return (s:ss))
13:46:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:46:33 <lilac> conal: right, i've already built local docs :)
13:46:37 <FunctorSalad> o_o
13:46:54 <pumpkin> bah, ****ers bailed out on my thanksgiving meal, now I made way too much food
13:46:58 <conal> lilac: oh, you're just helping me get the kinks worked out.
13:47:00 <conal> :)
13:47:00 <lilac> conal: it's nice to see you so dedicated to getting this to be nice to use :)
13:47:04 <pumpkin> :(
13:47:12 <conal> lilac: thx!
13:47:18 <Beelsebob> FunctorSalad: currying takes (a,b) -> c, and changes it to a -> (b -> c), CPS on the other hand takes a -> (b,c) and replaces it with a -> (b -> c) -> c
13:47:35 <vixey> Beelsebob, no it doesn't
13:47:37 <BMeph> Beelsebob: Is the spelling thing more amusing with Canadians involved? ;)
13:47:42 <gwern> pumpkin: be like jesus and invite some transexuals and whores and homeless in for dinner
13:47:44 <conal> the new comonadic, relative-time Reactive is going to rock!
13:48:29 <Beelsebob> sorry, as vixey says, it's a -> (b -> c -> d) -> d
13:48:30 <pumpkin> gwern: not many of those in this tiny college town in the middle of nowhere unfortunately...
13:48:41 <Beelsebob> i.e. give it a function to combine the two outputs, and it does it
13:48:58 <FunctorSalad> Beelsebob: that makes sense. I guess you get it by double dualizing and then simplifying
13:49:13 <gwern> pumpkin: well, alright then homosexuals. colleges are famous for being hotbeds of immorality such as homosexuals
13:49:15 <vixey> FunctorSalad, can you show that happening?
13:49:30 <pumpkin> gwern: oh yeah, you're right, I'll go find me some homos
13:49:59 <gwern> everyone could use some homos
13:50:10 * gwern misses queer eye for the straight guy. whatever happened to that?
13:50:57 <Toxaris> jesus didn't do that, he reported about his father doing it all the time
13:51:13 <gwern> Toxaris: are you claiming Jesus was a poseur?
13:52:55 <Toxaris> well, as always, depends on whether you believe him. If yes, he was just right. If no, sure, of course he was a poseur.
13:53:19 * Toxaris feeling on dangerous terrain
13:53:52 * vixey realized something amusing the other day ... the only people that ever start flame wars about religion are the non-religious folk
13:54:13 <pumpkin> really?
13:54:18 <pumpkin> the crusades were a big flame war
13:54:22 <pumpkin> :P
13:54:25 <opqdonut> vixey: so true
13:54:30 <vixey> well they didn't happen on IRC
13:54:41 <gwern> look, poseur doesn't have anything to do with whether other people believe in you. if I dress up in skater clothes and shoes and go around carrying a skateboard and pay a mad cosmetician to make me look like Tony Hawk, it doesn't matter if everyone believes I'm Tony Hawk - I'm still a poseur
13:54:42 <conal> so were the witch burnings
13:54:59 <opqdonut> on IRC?
13:54:59 <opqdonut> wow
13:55:06 <vixey> well yeah we get them occasionally on IRC
13:55:10 <Toxaris> gwern: and what if you *are* Tony Hawk?
13:55:35 <gwern> Toxaris: then I'm a fool for paying the cosmetician to make me look like myself
13:55:54 <opqdonut> why can't tony hawk be a tony hawk poseur
13:55:59 <opqdonut> it's the thought that counts!
13:56:08 <FunctorSalad> vixey: I'll try ;) a -> (b,c)  ~~  ((a -> (b,c)) -> d) -> d  ~~  ((a -> b, a -> c) -> d) -> d  ~~  ((a -> b) -> (a -> c) -> d) -> d  ~~  hmm, what now
13:56:20 <gwern> opqdonut: and I'll bet you're a fan of modern art!
13:56:40 * gwern urinates on opqdonut's thanksgiving turkey. I call it... 'Tradition Terminated'
13:56:51 <pumpkin> lol gwern
13:57:05 <Stephan202> :>
13:57:25 <gwern> opqdonut: that'll be 4.5 million dollars please.
13:57:30 <lilac> FunctorSalad: ((((a -> b) -> e) -> e) -> (((a -> c) -> f) -> f) -> d) -> d?
13:58:05 <gwern> since my artwork can't be removed from its _milieu_ without destroying it and depriving me of my property rights
13:58:09 <opqdonut> gwern: well you must be a hearty dadaist yourself so I'll pay you with an acre of happiness
13:58:21 <lilac> @djinn (a -> (b,c)) -> ((((a -> b) -> e) -> e) -> (((a -> c) -> f) -> f) -> d) -> d
13:58:22 <lambdabot> f a b =
13:58:22 <lambdabot>     b (\ c ->
13:58:22 <lambdabot>        c (\ d ->
13:58:22 <lambdabot>           case a d of
13:58:22 <lambdabot>           (e, _) -> e)) (\ f ->
13:58:23 <_dolio> a -> (b,c) =cps-fun=> a -> ((b,c) -> d) -> d =curry=> a -> (b -> c -> d) -> d
13:58:24 <lambdabot>                          f (\ g ->
13:58:26 <lambdabot>                             case a g of
13:58:28 <lambdabot>                             (_, h) -> h))
13:58:30 <opqdonut> gah
13:58:35 <lilac> eep!
13:58:36 <FunctorSalad> lilac: hmm, I'm trying to reach what Beelsebob had, so the f and e would have to cancel out eventually
13:58:48 <FunctorSalad> lilac: (it was: a -> (b -> c -> d) -> d)
13:59:36 <vixey> cool
13:59:46 <vixey> djinn is like a slimer
13:59:48 <Toxaris> vixey: I think thats the same with all kinds of flame wars, I mean, flame wars are *against* something
14:00:28 <vixey> Toxaris, nice observation -- that's more general than what I said and likely true also
14:00:39 <mm_freak> a very interesting monad:  StateT s []
14:00:57 <vixey> why is that interesting?
14:01:14 <mm_freak> stateful non-determinism
14:01:18 <opqdonut> the different nondeterministic branches share state
14:01:19 <opqdonut> yeah
14:01:24 <opqdonut> an interesting notion
14:01:32 <vixey> just seems weird to me
14:01:35 <vixey> what do you do with it?
14:01:53 <opqdonut> or did I get my transformers the wrong way around
14:01:54 <FunctorSalad> think it's called SLA in hxt
14:01:59 <FunctorSalad> (state list arrow)
14:02:02 <vixey> opqdonut, you got it right
14:02:08 <opqdonut> :)
14:02:18 <opqdonut> ?unmtl StateT s [] a
14:02:18 <lambdabot> s -> [(a, s)]
14:02:22 <opqdonut> no
14:03:15 <FunctorSalad> Beelsebob: are you sure the two types are isomorphic?
14:03:22 <FunctorSalad> (not that you claimed they were)
14:03:29 <Beelsebob> FunctorSalad: they're not isomorphic no
14:03:57 <Beelsebob> a -> (b -> c -> d) -> d is equvalent to an a -> (b,c) and a (b,c) -> d
14:04:06 <lilac> conal: what's the best way of sampling a Behavior? eg, i have a sound signal and i want to build an array of the past second's samples at a certain sampling rate
14:04:23 <Vinceman> a->b  f->c	AND
14:04:23 <Vinceman> b∧c->d	OR
14:04:23 <Vinceman> d∨e->f	XOR
14:04:23 <Vinceman> e	NAND
14:04:23 <Vinceman> a	NOR
14:04:24 <Vinceman> _
14:04:26 <Vinceman> b d
14:04:26 <BMeph> FunctorSalad, Beelsebob: Check dolio's explanation, mixed in with the djinn spew. :)
14:04:28 <Vinceman> f
14:04:30 <Vinceman> c
14:04:41 <FunctorSalad> but x is equivalent to forall d. (x -> d) -> d, right?
14:04:48 <mm_freak> vixey: for example, looking for modular square roots, the modulus can become state instead of being passed explicitly
14:05:18 <ski_> FunctorSalad : you should do :   a -> (b,c)  ~=  a -> forall d. ((b,c) -> d) -> d  ~=  ...
14:05:26 <vixey> mm_freak, the modulus never changes though
14:05:29 <ski_> (vixey,lilac,RayNbow(,Toxaris),Beelsebob : we ought to have cocurrying `cocurry :: (a -> (b | c)) -> ((a >- b) -> c)' !)
14:05:43 <FunctorSalad> ski_: looks good
14:05:48 <opqdonut> ski_: >-? is that a typo?
14:05:49 <Beelsebob> ski_: ohhh, neat
14:05:51 <vixey> so it's not an interesting trait of that monad.. it's like closing a parameter and doing []
14:05:56 <ski_> opqdonut : no :)
14:06:01 <mm_freak> vixey: that notion allows to you ignore the fact that there are multiple square roots and just carry out the computation with each of them implicitly
14:06:02 <opqdonut> okay, what is it?
14:06:04 <conal> lilac: i'll have to think about that one.  it's a different style of use from what i've done.  no inherent problem, though.  how about posting the question on the mailing list?
14:06:19 <mm_freak> vixey: ReaderT Integer []
14:06:20 <mm_freak> ;)
14:06:24 <ski_> a value of type `a >- b' consists of a value of type `a
14:06:28 <FunctorSalad> BMeph: right, I missed dolio between the bot
14:06:28 <vixey> or just []
14:06:30 <ski_> ' and a continuation of type `b'
14:06:55 <conal> is ed kmett here now?  i've forgotten his handle.
14:06:56 <vixey> type a >- b = forall r. (a -> r) -> r
14:06:56 <lilac> ski_: i think my brain may have just turned inside out
14:06:56 <vixey> ?
14:06:58 <opqdonut> ski_: ah okay
14:07:02 <mm_freak> just [] would need me to consider the monadicness of lists more explicitly, and it would make modulus passing explicit
14:07:12 <vixey> conal, I don't think he (edwardk) is here
14:07:15 <conal> or anyone else who might know about composign comonads?
14:07:21 <conal> vixey: thx.
14:07:51 <lilac> conal: composing? for a second then i was convinced composign was a real cat theory term :)
14:08:06 <opqdonut> :D
14:08:09 <conal> heh
14:08:29 <ski_> so, a function of type `(a >- b) -> c' could either use the `a' value to compute an `c' to return normally .. or it could use the `a' value to compute a `b' value, which it could pass to the `b' continuation, letting them annihilate each other (with result that the function doesn't return at all .. instead the `b' value pops up wherever the `b' continuation pointed to)
14:08:31 <lilac> it's like the african village of Mposign, but the arrows fly backwards
14:08:37 <FunctorSalad> ski_: that cocurry seems to need excluded middle :)
14:08:56 <ski_> `(b | c)' would basically be just `Either b c' (just wanted to use similar syntax as tuples)
14:09:11 <mm_freak> the coolness of StateT a [] is that the non-determinism is entirely implicit…  if there are multiple results, use lift and return a list, otherwise just do what you'd usually do
14:09:14 <BMeph> Heh-heh, this must make Haskell newbies cry... ' () :: (); [] :: [] a'
14:09:18 <FunctorSalad> ski_: nvm, hadn't read that >- isn't a typo
14:09:27 <dons> BMeph: interesting.
14:09:52 <BrokenClockwork> I need an editor, with the same syntax lightening of "Learn You A Haskell".com (!)
14:10:27 <opqdonut> emacs?
14:10:31 <ski_> so in `uncocurry :: ((a >- b) -> c) -> (a -> (b | c))', the `c' result of the argument function would point to the right alternative of the result function .. while the `b' continuation would point to the left alternative of the result function
14:10:37 <BrokenClockwork> okay I'll try it
14:10:43 <FunctorSalad> emacs with color-theme extension? :) BrokenClockwork
14:11:28 <vixey> by my def. (which might be wrong), (a >- b) >- c  ~  (a -> forall r. (b -> r) -> r) -> forall r'. (c -> r') -> r'
14:11:54 <ski_> conal : edwardk
14:12:11 <snails> hello.
14:12:20 <snails> you gus down with the klan?
14:12:22 <snails> http://www.kelticklankirk.com/KKK_Knight_Bible_and_Fiery_Cross.jpg
14:12:32 <lambdabot> http://tinyurl.com/5wy66l
14:12:37 <vixey> ?djinn ( (a -> (b -> r) -> r) -> (c -> r') -> r' )  ->  ( a -> (b -> c -> r') -> r' )
14:12:37 <lambdabot> -- f cannot be realized.
14:12:48 <vixey> I guess the foralls are important ..
14:12:49 <roconnor> @where-ops
14:12:50 <lambdabot> Unknown command, try @list
14:13:00 <roconnor> @get-ops
14:13:01 <lambdabot> Unknown command, try @list
14:13:05 <kynky> emacs seems the best editor at the moment, but you need haskell-mode for it, using emacs 23.0
14:13:07 <snails> lol
14:13:11 <ski_> @where ops
14:13:11 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:13:23 <snails> http://hiphappy.files.wordpress.com/2008/05/kkk_rally_amarillo.jpg
14:13:25 <lambdabot> http://tinyurl.com/598kqp
14:13:38 <erikc> @seen dcoutts
14:13:39 <lambdabot> dcoutts is in #haskell, #haskell-soc, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I don't know when dcoutts last spoke.
14:13:53 <vixey> sooo
14:13:58 <vixey> what's a better definition of >- ?
14:14:00 <vixey> than my one
14:14:03 <ski_> FunctorSalad : yes, in a sense it uses "excluded middle" (though that is a bad name for it)
14:14:12 <vixey> oh
14:14:12 <Toxaris> vixey: why does your definition not use the b?
14:14:27 <snails> haskell code --> http://rafb.net/p/wy2X2N83.html
14:14:31 <snails> serious now.
14:14:32 <lambdabot> Title: Nopaste - No description
14:14:36 <vixey> forall r'. (a -> forall r. (b -> r) -> r) -> c -> r') -> r'
14:14:38 * snails like functional programming
14:14:41 <vixey> I think that's what I meant
14:14:59 <vixey> snails, you don't do that then except people to take you seriously
14:15:18 <vixey> snail, expect*
14:15:37 <snails> sorry.
14:15:48 <snails> issue with recursion --> http://rafb.net/p/wy2X2N83.html
14:15:50 <lambdabot> Title: Nopaste - No description
14:16:10 <ski_> vixey : what was your definition of `(>-)' ?
14:16:11 --- mode: ChanServ set +o Cale
14:16:16 --- mode: Cale set +b *!*@70.44.75.40.res-cmts.brd2.ptd.net
14:16:16 <Botje> sigh
14:16:25 --- kick: snails was kicked by Cale (Cale)
14:16:29 --- mode: Cale set -o Cale
14:16:34 <FunctorSalad> ski_: I was thinking in propositional logic, actually I don't know what the proper translation in simply typed lc is
14:16:48 <FunctorSalad> (a -> Void) -> Void isn't very interesting, presumably
14:16:49 <ski_> (translation of what ?)
14:16:57 <vixey> type a >- b = forall r. (a -> r) -> r
14:17:06 <FunctorSalad> ski_: law of excluded middle / tertium non datur/ however you call it
14:17:06 <roconnor> Cale: thanks
14:17:07 <vixey> eeeeek
14:17:09 <ski_> that can't be right, since `b' is unused
14:17:22 <vixey> type a >- b = a -> forall r. (b -> r) -> r
14:17:26 <roconnor> >- almost looks like a Y for yoneda
14:18:02 <ski_> vixey : that's still wrong .. the left argument should be covariant, while the right should be contravariant
14:18:04 <BMeph> Intersting - cleanj.sourceforge.net/
14:18:13 <dons> pumpkin: how's the haskell hacking coming along?
14:18:16 <dons> making progress?
14:18:18 <ski_> (incidentally, you have them the other way around)
14:18:20 <BMeph> I wonder how it differs from CAL?
14:18:53 <pumpkin> dons: busy struggling with a mac pro I built :( put haskell writing on hold, but I soak up all blog posts I can find on it, even if I only understand half of some of them :P
14:19:29 <dons> heh. ok. well, be sure to lean on the community if you get stuck.
14:19:48 <ski_> FunctorSalad : in the sense i want to use "tertium non datur", it is in some sense trivial, computationally basically the same as `a -> a'
14:20:25 <pumpkin> dons: thanks, it's really fascinating stuff... it's been a long time since I've been this excited about programming (and I'm not that old :P)
14:21:00 <erikc> dons: has anyone done FFI binding generation from DWARF/PDB information?
14:21:02 <Peaker> pumpkin: it would be more of a compliment if you WERE old, you insensitive clod :)
14:21:16 <pumpkin> PeakerWork: I know :P
14:21:20 <dons> erikc: if so, it'd be on hackage.
14:21:25 <erikc> ok
14:21:34 <erikc> then i will be contributing one soon
14:21:40 <erikc> ive developed a DWARF -> Lua/C code generator for Lua/C binding and doing a haskell one would be a matter of changing the backend on the generator
14:22:49 <dons> probably easy too
14:22:57 <ski_> vixey,et.al. : in any case, i don't think `(>-)' would be possible in haskell as-is, because allowing duplicating/discarding continuations *as*well*as* values leads to *side*-effects .. (so mayhaps with some kind of linear (or uniqueness ?) typesystenm)
14:23:05 <thoughtpolice> erikc: so I suppose the use case is run it over some symbol files (pdb's,) and get a .hs out that has lots of 'foreign import' decls?
14:23:17 <thoughtpolice> I thought PDB was a closed format?
14:23:23 <erikc> thoughtpolice: right
14:23:36 <erikc> ive only done dwarf so far, pdb is open though as far as i know, microsoft has specs up
14:23:53 <thoughtpolice> ah
14:24:08 <erikc> but i have it working for lua so i can bind lua tables to c structs using generated metadata
14:24:22 <erikc> and it works for c++ template generated data structures, since dwarf info is post-template expansion
14:24:35 <thoughtpolice> BMeph: that is cool looking
14:25:18 <erikc> for haskell, i'd generated storable instances
14:25:35 <erikc> for aggregate and array types
14:27:04 <lilac> conal: i have (slow, but) working reactive audio
14:27:23 <erikc> thoughtpolice: my specific issue is with binding to C data rather than C functions, so i can write haskell against C data structures
14:27:37 * ski_ ponders `bicurry :: ((a0 , a1) -> (b0 | b1)) -> (?)'
14:27:57 <lilac> conal: it's about 1/3 real time :(
14:28:33 <lilac> (this is inside ghci though)
14:29:23 <ksf> http://golem.ph.utexas.edu/category/2008/01/the_yoneda_embedding_as_a_refl.html
14:29:25 <lambdabot> Title: The Yoneda Embedding as a Reflection | The n-Category Café, http://tinyurl.com/5wn9t5
14:29:31 <ksf> that's the stuff i'm looking for.
14:29:50 <thoughtpolice> erikc: yeah, that's a little more complicated issue
14:29:51 <ksf> and, on another scale, such stuff:
14:29:52 <ksf> http://barker.linguistics.fas.nyu.edu/Research/barker-cw.pdf
14:29:54 <lambdabot> Title: Continuations in Natural Language
14:29:56 <ski_>   bicurry :: ((a0 , a1) -> (b0 | b1)) -> ((a0 >- b0) -> (a1 -> b1))  -- ?
14:30:01 <ski_>   bicurry :: ((a0 , a1) -> (b0 | b1)) -> ((() >- b0 >- b1) -> (a0 -> a1 -> Void))  -- ?
14:30:48 <ski_> ksf : that's cool !
14:32:08 <conal> lilac: neat.  sounds close enough to be reachable.  :)
14:32:16 <conal> lilac: compiled with optimizations?
14:32:32 <conal> lilac: how did you answer your sampling question?
14:34:21 <lilac> conal: adaptE $ snapshot (countE_ (atTimes [0,1/rate..])) audio >>= \(n,v) -> return $ pokeElemOff buffer n v
14:34:44 <ksf> the latter paper should be particularly useful when it comes to zenning continuations
14:34:51 <conal> lilac: oh, simple!  :)
14:34:57 <ski_> (vixey : `cocurry :: (a -> Either b c) -> (forall r. (a , b -> r) -> (c -> r) -> r)' might be closer to what you had in mind ..)
14:34:59 * ksf can't believe his spellchecker actually knows "zenning"
14:35:25 <lilac> conal: although that only fills one buffersworth. but i think a simple buffer ring should be easy enough
14:35:47 <conal> lilac: try fmap in place of >>= there.  you might get better speed.
14:36:19 <conal> lilac: something like uncurry (pokeElemOff buffer) <$> snapshot (...) audio
14:37:11 <conal> lilac: nice coding!  i like the countE/snapshot/poke trick :)
14:37:36 <conal> lilac: and there's a functional semantics that could be wrapped up.
14:37:45 <conal> lilac: hiding the poke.
14:37:52 <conal> and allocation
14:38:56 <conal> lilac: i wonder if we could use bytestring with your trick.
14:40:01 <conal> lilac: and is your audio reactive in any way?
14:40:26 <conal> lilac: i.e., did you get something out of Reactive you couldn't have done as nicely with composing plain-old haskell functions?
14:40:52 <lilac> conal: fmap instead of >>= is about the same runtime
14:41:02 <lilac> so far i'm just playing a simple sine wave
14:41:05 <conal> lilac: okay, thanks for trying.
14:41:09 <lilac> playAudio (floor . (*32767) . sin . (1000*) time :: Audio Int16)
14:41:17 <lilac> where (.) = fmap
14:42:14 <ski_> (s//$/ ?)
14:42:34 <lilac> ski_: i was wondering that. but that's copy-pasted, and it compiles and works as is
14:42:43 <vixey> fmap isntead of =<<
14:43:30 <lilac> i guess that means there's an 'instance Num a => Num (Behaviour a)' ?
14:45:43 <lilac> conal: can you add a RealFrac and Integral instance for Behaviour too, so i can write "playAudio $ floor (32767 * sin (1000*time))"
14:46:37 <conal> lilac: oh, are they missing?  i'll look.
14:46:53 <conal> lilac: you bet.
14:47:15 <lilac> i think that's pretty nifty
14:47:35 <conal> yeah.  lovely :)
14:47:36 <lilac> describing an audio signal as a function of time
14:47:51 <lilac> i need to get rid of the floor and 32767* though
14:49:01 <conal> lilac: yeah.  maybe hide them in playAudio.
14:50:33 <conal> lilac: hey!  you've just built a new Reactive adapter.
14:51:54 <lilac> conal: neat, no? :)
14:52:08 <lilac> is there a name for a (position, velocity) tuple?
14:52:21 <conal> lilac: very!
14:52:29 <conal> lilac: sometimes called D
14:52:46 <roconnor> phase
14:52:47 <conal> lilac: or you could go all the way and make infinitely many derivatives, with vector-space
14:53:12 <lilac> OpenAL doesn't support anything beyond first derivative :)
14:53:15 <roconnor> oops
14:53:29 <conal> lilac: doesn't matter.  my lib will compute them lazily.
14:53:50 <conal> lilac: in fieldtrip, i build the infinite tower an just use the 0th and 1st derivatives.
14:54:33 <conal> lilac: there's probably also a lib on hackage that computes just value and 1st deriv
14:55:48 <lilac> hmm. i'm wondering whether i should use the FieldTrip types for sound position and velocity
14:56:17 <lilac> incidentally, why's it called FieldTrip?
14:57:04 <conal> lilac: it's trippy and sort about fields (math) and about explorations
14:58:26 <lilac> does this D stand for anything?
14:58:34 <conal> derivative (tower)
14:59:11 <conal> lilac: jerzy k has a cute paper about infinite derivative towers in haskell.
14:59:34 <conal> lilac: k = karczmarczuk
15:00:02 <conal> lilac: what i did was to extend to multi-dimensional domains.
15:00:22 <conal> lilac: described in my "beautiful differentiation" blog post series
15:16:32 <Vinceman> Vq^?
15:16:45 <Vq^> yes
15:17:04 <Vinceman> do you have a good joke?
15:17:37 <Vinceman> Vq^? do you have a good joke?
15:18:07 <ikkebr> sure
15:18:11 <Vq^> no, but if you ask me in #haskell-blah i might
15:18:18 <ikkebr> what did a recursive function said to another recursive function?
15:18:40 <Vinceman> what did he say?
15:18:48 <Vinceman> det er ikke bra?
15:18:53 <ikkebr> not norge
15:19:10 <Vinceman> sorry I thought you were norwegian..
15:19:13 <ikkebr> it said me (you-1)
15:19:23 <poliquin> Newbie question .. I"m passing the function '<' to a function but I can't seem to pattern match on it .. Is this possible?
15:19:35 <ikkebr> Vinceman i believe ikke means no in norwegian, right?
15:19:39 <Vinceman> yes
15:19:48 <Vinceman> and bra is good
15:20:12 <Peaker> poliquin: you can't pattern-match functions
15:20:32 <vixey> poliquin, sorry what did you want out of it?
15:20:38 <poliquin> Peaker, Ok .. that explains the error! :-)
15:20:48 <vixey> poliquin, can you write the code just for example and say what it _should_ do?
15:21:14 <poliquin> Here's a code snippet .. http://hpaste.org/12449
15:21:52 <vixey> oh
15:21:53 <poliquin> I eventually used guards but it seemed like a hack and I'm trying to be a good Haskeller ..
15:21:55 <vixey> I know what you can do
15:21:59 <ksf> design pattern and continuations, here you got it:
15:22:02 <ksf> http://jerry.cs.uiuc.edu/~plop/plop2001/accepted_submissions/PLoP2001/dferguson0/PLoP2001_dferguson0_1.pdf
15:22:06 <vixey> merge both cases into one:
15:22:10 <lambdabot> Title: Call with Current Continuation Patterns, http://tinyurl.com/2mu8q
15:22:11 <vixey> indexOf ((NoDist):xs) (&) = findI xs 1 0 (-99e99) (&)
15:22:18 <vixey> (&) can be either (<) or (>)
15:22:23 <Vinceman> ikkebr, do you speak french?
15:22:38 <ikkebr> Vinceman i understand some french
15:22:45 <ikkebr> i just speak english/portuguese/spanish
15:22:47 <poliquin> But in one case I want -99e99 .. and in the other case I want +99e99
15:22:47 <vixey> poliquin, so remove both those two and try it with just the (&) one.. should work(?)
15:22:55 <vixey> oh
15:23:11 <vixey> you could take the value 99e99 as a parameter
15:23:32 <vixey> define a constant less = (<,99e99); greater = (>,-99e99)
15:23:37 <poliquin> Hmmm.. that's a thought
15:23:38 <Vinceman> your humor is called humour mathem.. something
15:24:19 <poliquin> Actually I think that would work .. since this function is called by two functions .. indexOfMin and IndexOfMax ..
15:24:24 <gchin> hi, I'm trying to extract a value from IO within the state monad http://hpaste.org/12450
15:24:45 <gchin> I'm not really sure how to do this. do I need to use monad transformers are combine IO and state?
15:24:47 <dons> hi ghc
15:24:52 <dons> gchin:
15:25:03 <dons> gchin: yes. to combine IO and State.
15:25:06 <dons> you'd use StateT IO a
15:25:19 <poliquin> vixey, Great! Thanks very much for the help! .. and now I know you can't PM functions .. ;-(
15:25:22 <gchin> crap, I have to go understand monad transformers now :X
15:25:26 <dons> let's write an example.
15:25:26 <gchin> thanks dons
15:25:28 <dons> it's super easy
15:25:40 <dons> you're just layering the computational effects you're adding to your program
15:25:42 <Vinceman> what's the matter with you if you find yourself apologizing to a lot of people?
15:25:42 <Toxaris> ksf: interesting. While the authors of this papers do not seem to define the term "pattern", they follow the GOF in their style of presentation, strengthening my claim that the style of presentation is important.
15:25:55 <vixey> poliquin, It's not clear what it would _mean_ to pattern match on a function to me
15:25:58 <Peaker> gchin: You could use IORef or such to hold state, but StateT IO is probably more elegant
15:26:10 <vixey> poliquin, but also, possibly both cases can be written as a single one, returning the min and max
15:26:17 <dons> so 'Cat' is your state, gchin ?
15:26:17 <erikc> ah, so happy, feel like i made a big mental breakthrough today
15:26:22 <dons> erikc: woot!
15:26:26 <gchin> dons: yeah, cat is the thing I'm trying to modify
15:26:28 <dons> ok
15:26:36 <Vinceman> !woot
15:26:38 <vixey> erikc, regarding what?
15:26:50 <Toxaris> vixey: well, after defunctionalization, you could pattern match on functions
15:27:07 <Peaker> gchin: who are the readers/writers of your state?
15:27:26 <Peaker> gchin: in your example, you could of course pass that state as an explicit argument, instead
15:28:00 <erikc> i realized that what i am doing with my binding approach between C and Lua (which may soon be replaced with Haskell or Scheme) and application design is akin to database development
15:28:31 <dons> there's a lua binding on hackage.haskell.org already ,btw
15:28:39 <gchin> Peaker: I'm not sure what you mean by that. Are you referring to the reader/writer monads?
15:28:39 <poliquin> vixey, I wanted to do one thing if the function was < and another if the function was >
15:28:48 <erikc> C data == my database, C code == 'stored procedures', Lua code == high level code that pulls and pushes to/from database
15:29:19 <poliquin> vixey, and I pass the function to a called function ..
15:29:43 <poliquin> vixey, but you're totally correct that it makes better sense to pass it as a parm ..
15:31:17 <Peaker> gchin: maybe you just simplified your example for the question, but in real code, there's no point in running execState on a short state computation that uses get/put once or so,  you could instead pass that state as an argument
15:31:44 <erikc> dons: im gonna replace Lua with Haskell so my app will be C/Haskell, with the data stored in C, and the haskell code able to lift the C data structures to Haskell data structures via a query language
15:31:55 <Peaker> gchin: in your actual code, do you have a bunch of state computations that want to do IO *and* be able to get/put to the state?
15:32:01 <dons> gchin: http://hpaste.org/12450#a1
15:32:12 <dons> so that's a complete example of running a layered IO + State computation
15:32:21 <gchin> Peaker: yeah, I cut out all the other stuff I was modifying in the state, I have a series of computations
15:32:41 <gchin> dons: awesome, thanks
15:32:51 <dons> yes, typically StateT mystate IO is for interactive IO apps
15:32:59 <dons> that have some global state that is being updated interactively
15:33:22 <conal> lilac: ping.
15:33:22 <dons> so some things to note: liftIO raises IO into StateT IO.
15:33:32 <dons> we use T as an alias for the full monad stack
15:33:53 <dons> we could actually derive some wrapper stuff to make that even simpler, but it'll do for now
15:33:56 <mapreduce> dons: Your irc bot tutorial would, I think, benefit from some kind of polling read, say, of RSS, a web service of some sort, etc.
15:34:24 <conal> lilac: i just uploaded reactive-0.9.4 to hackage, with the full set of numeric instances.
15:34:26 <mapreduce> E.g., I'd use that to make my bot show scala bugs in #scala as they happen.
15:34:33 <mapreduce> (yes, I could write it in scala)
15:35:14 <ttt--> , 3
15:35:15 <dons> mapreduce: there's a package on hackage for this.
15:35:17 <lunabot>  3
15:35:23 <dons> rss2irc it is called
15:35:30 <mapreduce> Ooh, shiny.
15:35:31 <ttt--> , [| 3 |]
15:35:34 <lunabot>  LitE (IntegerL 3)
15:35:36 <dons> mapreduce: based on the irc bot tutorial
15:35:39 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rss2irc
15:35:43 <lambdabot> Title: HackageDB: rss2irc-0.1, http://tinyurl.com/6e4uzp
15:35:48 <dons> code here http://code.haskell.org/~dons/code/rss2irc/
15:35:48 <lambdabot> Title: Index of /~dons/code/rss2irc
15:35:54 <dons> the hackage bot is written this way
15:35:59 <mapreduce> Thanks a lot.
15:36:30 <dons> so the reader thread just writes messages to the chan ever interval seconds
15:37:04 <ttt--> is there an easy way to check if a TH expression does IO?
15:37:26 <dons> mm.
15:38:16 <vixey> are you going to unsafePerformIO the ones that don't?
15:41:37 <ttt--> how do lambdabot and lunabot make sure no IO gets called?
15:41:46 <ttt--> i bet it's hard :/
15:42:57 <idnar> ttt--: not really
15:42:59 <idnar> > print 1234
15:43:00 <lambdabot>   * Exception: "<IO ()>"
15:43:28 <idnar> lambdabot doesn't do TH, as far as I know
15:44:50 <dons> ttt--: oh, just via the type checker
15:44:53 <dons> its pretty easy
15:45:00 <Cale> ttt--: IO is separated by type, evaluating IO actions doesn't cause them to execute.
15:45:03 <dons> you use a Show instance for IO actions that just ignores the IO
15:45:04 <lilac> conal: excellent, cheers
15:45:25 <dons> impossible unless IO was mandatorily tagged
15:45:33 <pumpkin> what happens if you pattern match on an IO and its contents?
15:45:37 <pumpkin> is that equivalent to unsafeperformIO?
15:45:41 <Cale> pumpkin: no
15:45:50 <pumpkin> what will it do?
15:45:58 <idnar> you can't pattern match on an IO
15:46:01 <pumpkin> oh
15:46:01 <Cale> pumpkin: Nothing. In fact, you can't see inside an IO value.
15:46:05 <Vinceman> Vq^? should I pull an allnighter or go to sleep?
15:46:10 <pumpkin> is that just a special case in the language?
15:46:12 <idnar> you don't have a constructor to match on
15:46:16 <pumpkin> oh
15:46:16 <pumpkin> I see
15:46:19 <vixey> pumpkin, no it's not a special case
15:46:29 <idnar> I mean, IO is a sort of special case, but this particular aspect isn't
15:46:33 <pumpkin> yeah,  I forgot you're not matching on the type, but the constructor
15:46:33 <Cale> pumpkin: You can imagine that IO values are like program scripts.
15:46:37 <shapr> Vinceman: What do you do with Haskell?
15:46:39 <vixey> IO is different from every other monad -- but .. that's obvious
15:46:46 * shapr hugs vixey 
15:47:02 <Cale> pumpkin: evaluating the source code of a program is not dangerous, it's actually running it which is.
15:47:06 <vixey> hi shapr  *hug*
15:47:10 <lilac> conal: "Main: floor: No overloading for behavior" ;(
15:47:11 <shapr> hi!
15:47:13 <pumpkin> yeah, I see now :)
15:47:16 <shapr> vixey: oh, my computer arrived!
15:47:27 <vixey> shapr, coool does it work ? :p
15:47:36 <shapr> No power cables :-/
15:47:37 <ttt--> can you point me to the lambdabot code that does this? (overwrite the show for IO?)
15:47:39 <vixey> oh
15:47:55 <vixey> doesn't run on boing power??
15:47:59 <idnar> > show $ print 5
15:48:01 <lambdabot>   "* Exception: "<IO ()>"
15:48:01 <shapr> I wish :-)
15:48:07 <idnar> mmm
15:48:35 <idnar> is there a standard Show instance for IO?
15:48:38 <dons> nope
15:48:51 <vixey> that's weird .. there's 3 "'s
15:48:51 <pumpkin> what's a comonad?
15:48:52 <conal> lilac: yeah.  the type is too restrictive.
15:48:55 <dons> ttt--: let's see..
15:49:04 <Peaker> DebugShow would be great
15:49:12 <idnar> vixey: the first " gets printed before the exception happens, I bet
15:49:26 <vixey> idnar, aha I get it
15:49:26 <ttt--> > unsafePerformIO $ print 3
15:49:27 <lambdabot>   Not in scope: `unsafePerformIO'
15:49:32 <dons> ttt--: http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
15:49:34 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/3alo2u
15:49:35 <conal> lilac: i did have a way of dealing with floor (etc) in Fran, Pan, Pajama, ... .  let me see.
15:49:41 <ttt--> thanks dons
15:49:49 <vixey> shapr, I need to learn chemistry somehowe ..
15:50:00 <shapr> Book + kitchen?
15:50:14 <Peaker> @type floor
15:50:15 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
15:50:19 <conal> lilac: you can have a behavior floor, but it can't be called "floor", because of the type.
15:50:21 <conal> @type floor
15:50:22 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
15:50:36 <shapr> ChilliX: No quad cores, sorry.
15:50:39 <conal> oh -- i suppose i really could do floor, comonadically
15:50:46 <conal> but i doubt you'd want that!
15:51:07 <conal> since it would give constant results.
15:51:10 <idnar> for some reason I find it weird how comonads are nothing like monads
15:51:40 <conal> idnar: they're dual.  so in a sense they're very unlike.
15:52:07 <conal> monads wearing their arrows backwards
15:52:21 <idnar> conal: indeed; my brain keeps wanting to see them as similar, though
15:52:33 <vixey> what do you do with a comonad?
15:52:36 <conal> oh.  mine too.
15:52:41 <conal> vixey: you take context into account
15:52:45 <idnar> obviously there's structural similarity (everything is the same, just "backwards"), but intuitively they're completely different beasts
15:52:45 <lilac> conal: i'm happy changing the $ to <$> :)
15:52:51 <conal> idnar: ^^
15:53:02 <conal> lilac: that'll do
15:53:34 <conal> lilac: i'd add something like "floorB = fmap floor", but you could just use "fmap floor" instead.  less to remember.
15:54:01 <lilac> conal: what do you do about cleaning up after opengl in reactive-fieldtrip?
15:54:18 <ChilliX_> shapr: ok, thanks for checking
15:54:20 <conal> lilac: what kind of clean-up?
15:54:54 <lilac> well, OpenAL wants me to destroy the various objects i've created, or it stderrs on shutdown
15:55:00 <conal> oh wow.  ghc has a -fdo-eta-reduction flag
15:55:50 <lilac> automatic pointfree mode?
15:57:00 <conal> just one more Comonad instance to go in reactive
15:57:00 <dons> seems like a useful thing to do.
15:58:31 <Peaker> Is there an operator name for (flip fmap) ?
15:58:48 <conal> Peaker: i think so. see Control.Applicative
15:59:39 <conal> Peaker: hm.  i don't see one
15:59:57 <Peaker> conal: I think it could be nicer to read <$> compositions left-to-right
16:00:22 <conal> Peaker: cascaded <$>s?
16:00:27 <conal> f <$> g <$> ... ?
16:00:36 <Peaker> Yeah, I prefer that to (f . g) <$> ...
16:00:44 <conal> i guess there's (g >>> f ...) <$>
16:01:01 <conal> though >>> is all elbows
16:01:07 <Peaker> elbows?
16:01:22 <grul> <o/ yes sir
16:01:33 <conal> Peaker: yeah.  three pointy elbows.
16:01:37 <Peaker> ah, heh
16:01:43 <ziman> > (count . lines <$> return "a\nb\nc") :: Maybe Int
16:01:44 <lambdabot>   Not in scope: `count'
16:01:49 <ziman> > (length . lines <$> return "a\nb\nc") :: Maybe Int
16:01:49 <conal> while (.) is round and gentle
16:01:50 <lambdabot>   Just 3
16:01:53 <Peaker> conal: it could be nice for <$> to be flipped so the behavior/container is on the lhs
16:01:59 <Peaker> conal: (so you really read it left-to-right)
16:02:30 <conal> Peaker: and not just for fmap but for all function applications ..
16:02:44 <conal> pi sin
16:02:53 <Peaker> conal: forth got that right ;)
16:03:03 <conal> yay forth!
16:03:07 <Peaker> if function application was arg first, and composition was flipped, we'd have code that you don't have to skim through before reading
16:03:20 <Peaker> (at least some of the time)
16:03:31 <conal> Peaker: it'd give a bottom-up view instead of a top-down one.
16:03:35 <conal> details first
16:04:00 <conal> perhaps more suitable for strict than for lazy  -- just a thought
16:04:05 <ksf> rpn ftw.
16:04:15 <Peaker> conal: do you generally order your names top-down or bottom-up?
16:04:17 <conal> wtf npr
16:04:20 <Peaker> conal: (symbol declarations)
16:04:31 <conal> Peaker: dunno
16:05:07 <ksf> i'd say wtf, too, if i was paid in nepal rupies.
16:05:13 <Peaker> conal: I prefer bottom-up, that way you don't go through a big "mystery" phase until you get a big click at the end. Instead, you gradually understand more
16:05:40 <ksf> actually, that's what let-bindings are for.
16:05:42 <Peaker> conal: I prefer to eliminate the ambiguity asap, its more of a mental effort to read code with too many question marks
16:05:46 <ziman> i order almost always top-down -- general names first, details afterwards. I like to see the big picture before digging into stuff.
16:05:52 <ksf> forth just has anonymous lets.
16:06:05 <ahunter> ...erm, is there a reason my attempt to send an email to haskell-cafe bounced?
16:06:38 <conal> Peaker: makes sense to me
16:07:10 <conal> Peaker: one variation is to explain what things *mean* before they're used, but not necessarily how they're implemented.
16:07:16 <ksf> rpn is perfect for clarity exactly in the same sense and way as cps.
16:07:29 * ksf thinks he just scared half of the channel
16:07:45 * EvilTerran tends to write haskell top-down, with the names being sufficiently self-documenting that i don't get lost
16:07:54 <conal> could i get some ghc CPP help?  i want to embed a #defined symbol into a string, and i don't remember how.
16:08:20 <ksf> hasn't that been dropped in 6.10, anyway?
16:08:33 <ksf> oh nevermind, it was #includes.
16:08:38 <pumpkin> conal: # ? or ## ?
16:08:38 <Toxaris> ksf: and with exactly the same disadvantages
16:08:43 <ksf> and i got no idea, anyway.
16:08:52 <pumpkin> does it work same way as the real c preprocessor?
16:08:58 <conal> pumpkin: i'll try each.  thx.
16:09:05 <Peaker> conal: #blah  converts blah to "expanded blah"  and a##b  does a string-concat between expanded_a and expanded_b
16:09:09 <conal> pumpkin: i think it uses k&r style
16:09:37 <conal> so "#SYMBOL" ?
16:09:41 <pumpkin> that should work
16:09:43 <conal> or maybe "##SYMBOL" ?
16:09:47 <lilac> conal: http://metafoo.co.uk/darcs/resound
16:09:55 <lambdabot> Title: Index of /darcs/resound
16:09:59 <mauke> conal: # is a unary prefix op, ## is binary infix
16:09:59 <Peaker> conal: ## is more of a binary/infix operator
16:09:59 * conal looks
16:10:12 <conal> oh! unary/binary.  thx
16:10:13 <mauke> # stringifies its argument, ## concatenates two tokens
16:11:18 <conal> lilac: awesome. :) :)
16:11:26 <hackage> Uploaded to hackage: reactive 0.9.4
16:11:33 <conal> lilac: please brag on reactive@haskell.org
16:11:39 <lilac> conal: there's a *lot* more to do
16:11:43 <conal> sure
16:12:20 <conal> lilac: i notice you have a lot of Event fields in Source where i'd expect behaviors
16:13:06 <lilac> conal: yes, i'd like to make them Behaviours but i think that'd mean polling for changes
16:13:16 <lilac> OpenAL uses a push model for those things
16:13:31 <lilac> also they do nothing currently :)
16:13:43 <conal> lilac: you can start with events and use stepper to convert to behaviors.
16:14:01 <conal> lilac: hiding the discrete stuff from your API
16:14:23 <lilac> isn't stepper exactly backwards for what i want?
16:14:32 <lilac> i think i want snapshot_
16:14:50 <conal> lilac: maybe i'm reading your code backwards
16:15:06 <conal> lilac: are you consuming or generating Source ?
16:15:11 <lilac> I'm consuming them
16:15:22 <lilac> in the OpenAL model, a Source produces sound
16:15:31 <conal> lilac: and where do they orignate?
16:15:40 <lilac> user code will create them
16:16:34 <lilac> if i want a Behaviour, i'd need to poll them, which wouldn't be great
16:16:46 <conal> lilac: oh.  my question had the same ambiguity i was trying to resolve. :p
16:17:39 <conal> lilac: i'd expect them to be naturally continuous.  if you model this stuff in the most natural way, i think we can still get you good performance.
16:18:10 <conal> lilac: and yeah.  in the end, they'll get snapshotted, though not literally.
16:19:17 <lilac> ideally, i'd want a "watchForChanges :: Eq a => Behaviour a -> Event () -> Event a" or similar
16:19:22 <conal> or you could literally snapshot, as you're doing now.
16:19:42 <lilac> yes, but i'd rather not have to do anything if Reactive knows the behaviour is constant, as it will usually be
16:19:51 <conal> lilac: that's what mkUpdater accomplishes.
16:20:14 <lilac> ah! i'd been wondering what that was all about :)
16:20:28 <conal> lilac: although in your case, you might want a different approach, pulling out regular samples.  that's very easy to do efficiently.
16:20:54 <conal> lilac: i removed the efficient regular-sampling code (no recomputation), but i can add it back.
16:21:27 <conal> lilac: ats :: Behavior a -> [TimeT] -> [a]
16:21:48 <Peaker> did BehavioUr got renamed to Behavior at some point?
16:21:54 <conal> lilac: and during constant phases, it produces repetitions but without recomputing.
16:22:09 <lilac> conal: i don't want the repetitions at all, actually
16:22:15 <conal> Peaker: when was it "BehavioUr"?
16:22:23 <conal> lilac: oh, then the current adapter is perfect.
16:22:29 <Peaker> conal: its Behaviour in resound
16:22:33 <conal> lilac: oh, for the *control* parameters.
16:22:41 <conal> Peaker: "resound"?
16:22:41 <lilac> my legacy interface is of the form "setFoo :: Param -> IO ()"
16:22:56 <Peaker> conal: lilac's openal/alut adapter we're talking about
16:22:59 <lilac> Peaker: that's a synonym because i'm in blighty
16:23:01 <conal> lilac: cool.
16:23:05 <Peaker> lilac: blighty?
16:23:20 <lilac> Peaker: britain (colloq.)
16:23:52 <conal> Peaker: i just added "Behaviour" for lilac
16:24:01 <Peaker> hehe
16:24:23 <Peaker> lilac: I run Main, and it runs for 3 seconds, but nothing seems to be playing
16:24:53 <conal> lilac: i understand what's going on better now.  i suggest you make Source contain only behaviors and let my adapter smarts do their thing.
16:25:34 <lilac> Peaker: that's odd. can you get sound out of, for instance, mplayer -ao openal?
16:27:02 <Peaker> lilac: yeah
16:27:04 * conal darcs-gets resound
16:28:05 <Peaker> conal: if you're on Ubuntu, you might need to apt-get install libalut-dev libopenal-dev     before cabal getting alut
16:28:28 <conal> Peaker: oh, thanks.
16:28:45 <lilac> also, if you're on Ubuntu, you may find that the configure for HOpenAL goes wrong
16:29:04 <Peaker> lilac: are the samples supposed to be -1..1 ?
16:29:14 <lilac> if it says "checking value for AL_PLAYING... -1" then it's broken
16:29:29 <lilac> and you need to hack the configure script to add a #include "AL/al.h" to the checks
16:29:32 <conal> thx for the warnings.
16:29:59 <lilac> Peaker: yes
16:33:08 <Peaker> lilac: where's the -1..1 sample converted to a 16-bit sample?
16:33:28 <Peaker> oh, playSource s = playSamples (floor <$> 32767 * source s :: Behavior Int16)
16:35:37 <conal> lilac: which configure script do i hack to get ALUT working?
16:35:47 <conal> lilac: i do see AL_PLAYING... -1
16:36:32 <lilac> conal: the OpenAL configure script. lines 7838 onwards
16:36:48 <conal> oh.  not alut.
16:36:50 <lilac> there's about 6 occurrences, and you need to add #include "AL/al.h" to all of them
16:36:56 <Peaker> lilac: is this hack required for compilation, or for proper execution?
16:37:09 <lilac> or hack the configure.ac file if you have the right version of autoconf
16:37:30 <lilac> Peaker: in the failure mode, it builds successfully, but then doesn't work in fairly spectacular ways
16:38:09 <lilac> Peaker: you can test if yours is broken by:
16:38:24 <lilac> 1) start ghci, 2) import Sound.OpenAL, 3) get alErrors
16:39:06 <Peaker> lilac: weird, your code compilers&runs, but in ghci: module `Sound.OpenAL' is not loaded
16:39:54 <conal> lilac:  i don't understand: there's about 6 occurrences, and you need to add #include "AL/al.h" to all of them
16:40:01 <conal> lilac: 5 occurrences of what?
16:40:05 <conal> (s/5/6)
16:40:57 <conal> lilac: do you mean s/<AL/al.h>/"AL/al.h" ?
16:41:07 <conal> (bad regexp replace)
16:41:23 <Peaker> what does ghci's error message "module `Sound.OpenAL' is not loaded" mean?
16:43:00 <Lemmih> Peaker: Are you standing near the source of OpenAL?
16:43:34 <Peaker> Lemmih: what do you mean?
16:43:49 <Peaker> Lemmih: I have cabal installed it
16:43:59 <Saizan> have you started ghci from the source tree?
16:44:08 <lilac> conal: there's blocks which say "#include <AL/alc.h>" and "#include <AL/alext.h>"
16:44:18 <lilac> but they miss "#include <AL/al.h>"
16:44:25 <conal> lilac: got it.  thx.
16:44:42 <Peaker> nope, I haven't
16:44:48 <Peaker> import Sound.ALUT works, btw
16:45:07 <Peaker> strace shows that Main is actually opening the sound device
16:45:12 <conal> lilac: i also see: for ac_header in AL/alext.h OpenAL/alext.h ...
16:46:17 <lilac> conal: no need to change that
16:46:29 <lilac> detecting the header works fine, the check just fails to actually include it :)
16:46:49 <conal> lilac: ok.  should i guard the include of AL/al.h by  #if defined(HAVE_AL_AL_H) ?
16:47:27 <lilac> if you like, but it won't make any difference :)
16:47:34 <Peaker> lilac: if its opening the device, its probably not a build problem, right?
16:47:47 <lilac> Peaker: did you try my 'get alErrors' experiment?
16:48:09 <Peaker> lilac: yeah, it wouldn't import Sound.OpenAL (although it does import Sound.ALUT)
16:48:12 <conal> success!
16:48:17 <conal> (with OpenAL)
16:48:28 <Peaker> oh, wait, that's what Lemmih meant. Thanks Lemmih
16:48:52 <Peaker> lilac: seg fault
16:48:59 <lilac> how can i get the maximum finite Float?
16:49:14 <lilac> Peaker: then you have the same issue that conal does, and you need to hack the configure script
16:49:24 <Peaker> lilac: of the Haskell OpenAL wrapper, right?
16:49:28 <lilac> yes
16:50:28 <conal> lilac: sadly, i still get: module `Sound.ALUT' is not loaded
16:50:51 <lilac> i have no idea what that means, but Sound.ALUT is only needed for the sleep
16:50:55 <Peaker> conal: you might be experiencing what I just did, and need to "cd" out of the ALUT directory
16:51:08 <conal> oh!
16:51:14 <conal> lemmih's comment
16:51:21 <Peaker> yeah, I didn't quite understand him at first
16:51:39 <conal> that fixed it!
16:51:52 <lilac> > maxBound :: Float
16:51:54 <lambdabot>       No instance for (Bounded Float)
16:51:54 <lambdabot>        arising from a use of `maxBound'...
16:52:17 <conal> lilac: it worked!
16:52:31 <conal> lilac: functional noises out my speakers
16:52:34 <lilac> neat
16:52:42 <conal> lilac: :) !
16:52:44 <Peaker> lilac: I added #include <OpenAL/al.h> to all of the #include <OpenAL/alc.h> in my configure script, that doesn't seem to have fixed it
16:52:52 <Peaker> lilac: (still segfault)
16:53:03 <lilac> Peaker: you need AL/al.h for Ubuntu's libopenal-dev
16:53:20 <Peaker> lilac: ah, ok, but their #includes are for OpenAL, not AL
16:53:29 <lilac> there should be ones for both
16:55:12 <Peaker> lilac: also added #include <AL/al.h> still segfault :(
16:55:39 <lilac> Peaker: did the configure print out correct numbers for AL_PLAYING etc (ie, not -1)?
16:56:07 <Peaker> checking
16:56:17 <Peaker> nope, all -1
16:57:01 <Peaker> oh, ok, I see what happened
16:57:26 <lilac> > let maxFloat = f 1 :: Float where f x | 2*x == 4*x = x | otherwise = f (2*x) in maxFloat
16:57:28 <lambdabot>   1.7014119e38
17:01:16 <Peaker> lilac: now the values are no longer -1, but right ones, but still get alErrors seg faults
17:01:52 <conal> Peaker: did you rebuild both OpenAL and ALUT?
17:02:06 <Peaker> ooh, I didnt rebuilt alut
17:02:14 <Peaker> oh wait, the ghci thing is only using openal
17:02:17 <conal> might be it
17:02:23 <conal> oh. hm.
17:02:42 <lilac> Peaker: is it possible that it's using the old version?
17:03:03 <Peaker> lilac: I don't know, what could be making it use the old version?
17:03:11 <lilac> Peaker: actually, the segfault is a red herring
17:03:16 <lilac> my working version does that too!
17:03:33 <Peaker> lilac: I don't get a seg fault on your thing, just on the  get alErrors
17:03:39 <Peaker> lilac: your thing is quiet, though
17:05:44 <Peaker> On the Ubuntu side, I have 2 openal libs installed
17:06:03 <Peaker> conal: can you tell me what dpkg -l |grep openal says?
17:06:50 <lilac> Peaker: i have 'ii' for libopenal0a, libopenal1, libopenal1-dbg and libopenal-dev
17:06:54 <conal> ii  libopenal-dev     1:1.3.253-4ubuntu Software implementation of the OpenAL API (develop
17:06:54 <conal> ii  libopenal1        1:1.3.253-4ubuntu Software implementation of the OpenAL API (librari
17:06:54 <conal>  
17:08:06 <Peaker> lilac: hardy?
17:09:47 <Peaker> btw, mplayer -ao openal    works but sounds terrible
17:09:53 <Peaker> (compared with the default output)
17:10:09 <Peaker> I think I give up for now :(
17:10:31 <lilac> Peaker: intrepid
17:12:35 <lilac> conal: it's about 70% of real time on my system
17:13:25 <conal> lilac.  cool.  we're almost there.
17:14:05 <lilac> conal: my goal is a reactive .mod player :D
17:14:07 <conal> lilac: some folks know a lot about ghc flags etc.
17:14:18 <conal> lilac: and coding styles.
17:16:41 <conal> ooomph.  i'm tired.  i got so excited about comonadic frp that i sleep much last night.
17:16:52 <BMeph> Is there a more efficient way to search members of an infinite list for equal members, besides zipping the list with Integers, and staggering the comparisons based on them? :)
17:17:13 <BMeph> conal: s/sleep much/slept little/ ? ;)
17:17:33 <conal> BMeph: yeah.  that's how sleepy i am
17:17:41 <lilac> conal: likewise. plus it's past 1am here
17:17:47 <conal> s/sleep/couldn't sleep/
17:18:16 <conal> i'm going to go rest.  l8r.
17:19:54 <lilac> BMeph: i suspect your question is ill-phrased. what counts as more efficient?
17:20:21 <lilac> i assume there's the implication that you want a fair search, that is, all duplicates will be found in finite time
17:22:04 <BMeph> lilac: Right - I would prefer that duplicates at positions m and n be found in O(n^2), assuming n>m.
17:23:35 <skorpan> why would you want that? i interpret that as being slower.
17:24:23 <BMeph> skorpan: Slower than the zip, you mean? :)
17:24:59 <skorpan> no, i meant why do you want O(n^2) assuming n>m?
17:25:07 <skorpan> ... oh.
17:25:14 <skorpan> i completely misinterpreted what you said, my bad.
17:25:21 <skorpan> never mind me, i'm going to sleep now.
17:25:44 <BMeph> skorpan: Well, if there's a faster method, I'm all for that. I want a method no slower than n^2, rather. :)
17:26:08 <skorpan> what i thought first was "why doesn't he want O(m^2) if n>m?"
17:26:18 <skorpan> and well then i realized... so... :|
17:27:14 <BMeph> skorpan: Of course, being O(), it's the same thing anyway, I'm just trying to lock down the exponential. :)
17:28:23 <BMeph> skorpan: It might be O(mn), but if takes between nm and n^2 to do, I wouldn't reject it. :)
17:36:27 <dolio> Prelude Control.Monad.Omega Control.Monad> take 10 . runOmega $ do (y, i) <- x ; (z, j) <- x ;each (guard (y == z)) ; return (i,j)
17:36:33 <dolio> [(1,1),(1,11),(2,2),(1,21),(2,12),(3,3),(1,31),(2,22),(3,13),(4,4)]
17:37:27 <dolio> x = each $ zip (cycle [1..10]) [1..] -- incidentally
17:39:36 <dolio> , src ''Omega
17:39:37 <lunabot>  luna: Not in scope: type constructor or class `Omega'
17:39:54 <Saizan> :type each ?
17:40:05 <dolio> each :: [a] -> Omega a
17:41:01 <dolio> Omega doesn't have a MonadPlus instance, it seems, so I had to fake one through lists.
17:41:13 <Saizan> ah, yeah, i was wondering that
17:41:47 <dolio> I'm not sure if that's oversight or intentional.
17:44:16 <Saizan> uhm, you can't write one with only each
17:45:11 <BMeph> dolio: Interesting. Where's C.M.Omega packaged? :)
17:45:18 <dolio> It's on hackage.
17:45:23 <dolio> control-monad-omega
17:45:54 <Saizan> ?hackage control-monad-omega
17:45:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-monad-omega
17:46:04 <dolio> Saizan: Well, with runOmega and each you could write one.
17:46:24 <dolio> The thing is, a good instance for that monad would probably violate the MonadPlus laws in some way.
17:46:36 <dolio> But Omega already violates the monad laws, so I'm not sure how much that matters. :)
17:47:42 <Axman6> is Cale or dons or someone else who can control lambdabot around? we'd like it back in #macosxdev (permanently if ppossible)
17:48:14 <BMeph> dolio: That 'diagonal' function looks suspiciously like the comadic counterpart to join. :)
17:48:25 <Cale> Axman6: That's odd... I'm sure it's already set up to join that channel...
17:48:32 <Cale> But I'll check
17:48:46 <Axman6> cheers :)
17:49:01 <dolio> BMeph: cojoin would be [a] -> [[a]].
17:49:06 <BMeph> dolio: *comonadic
17:49:08 <Cale> oh, it's #macosx that it's joining, sorry :)
17:49:37 <Axman6> ah, i see. yeah our users in #macosx took a dislike to lambdabot -_-
17:49:46 <BMeph> dolio: D'Oh! Yeah, right. Never mind.
17:49:49 <dolio> BMeph: diagonal is (from the description) an alternate join for lists (which violates the associativity law for monads).
17:49:56 <povman> @quote russia
17:49:56 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
17:49:59 <Axman6> Cale: there's a chance it got banned from #macosx
17:50:08 <Cale> aha
17:50:09 <Cale> okay
17:50:15 <BMeph> dolio: Looks like a good fit for making a monad out of ZipList, though. ;)
17:50:30 <Cale> lambdabot: @join #macosxdev
17:50:48 <dolio> It's not that kind of diagonal. :)
17:51:00 <BMeph> dolio: Ah. Pity. :)
17:51:07 <Axman6> thanks cale :)
17:51:20 <Saizan> in ZipList you select only the diangonal, in Omega you enumerate all the elements diangonally
17:51:27 <Cale> no problem
17:51:33 <dolio> diagonal [[1..3],[4..6],[7..9]] ==> [1,2,4,3,5,7,6,8,9]
17:51:39 <Axman6> Cale: will that be permanent, so after it's rebooted?
17:52:29 <Cale> Axman6: yes, I also added it to the list of channels to join on startup
17:52:38 <dolio> So you rotate your array of arrays to look like a diamond (roughly) and read off the rows.
17:52:39 <Axman6> thanks :)
17:52:54 <dolio> Sorry, list of lists.
17:52:59 * dolio should sleep.
17:53:20 <Axman6> @hoogle HsModule
17:53:20 <lambdabot> Language.Haskell.Syntax data HsModule
17:53:20 <lambdabot> Language.Haskell.Syntax HsModule :: SrcLoc -> Module -> Maybe [HsExportSpec] -> [HsImportDecl] -> [HsDecl] -> HsModule
17:53:48 <BMeph> dolio: Aha! So, ZipList's diagonals are the ones cross-wise to the ones diagonal takes. Got it. :)
17:53:49 <Saizan> so a good mplus might be \xs ys -> diagonal [xs,ys] ?
17:53:51 <gwern> > '\ESC' : '\ESC' : []
17:53:52 <lambdabot>   "\ESC\ESC"
17:53:55 <Axman6> i'm getting "Plugin/Eval.hs:70:14: Not in scope: data constructor `HsModule'" when trying to install lambdabot here, anyone know what's up?
17:54:13 <gwern> Axman6: yes, it is a dep problem with haskell-source-exts
17:54:16 <gwern> they broke the api
17:54:21 <Axman6> ah, i see
17:54:25 <gwern> you can read why they did so in the ann
17:54:32 <gwern> ( week ago or so)
17:54:39 <Saizan> gwern: you should put an upper bound to the dependency then
17:54:51 <gwern> Saizan: probably yeah
17:55:05 <dolio> BMeph: Yeah, ZipList is like rotating your [[a]] and reading down the y-axis.
17:55:27 <psygnisfive> dear haskellonians: i love you all. <3
17:55:39 <gwern> psygnisfive: we love you too. but not in that way
17:55:50 <gwern> ?faq does haskell love psygnisfive back?
17:55:51 <lambdabot> The answer is: Yes! Haskell can do that.
17:56:01 <Saizan> oh, i thought _only_ in that way
17:56:18 <psygnisfive> yes gwern, im aware of lambdabots humor. :p
17:56:37 <psygnisfive> i havent had a reason to come in here in like months
17:56:45 <psygnisfive> saizan, oh how ive missed you!
17:56:52 <Axman6> there's always a reason to come in here!
17:56:59 <psygnisfive> this is true
17:57:05 <gwern> @vixen but why don't you love me like you do psygnisfive? :(
17:57:05 <lambdabot> because i don't see the need to
17:57:07 <psygnisfive> but i usually just lurked anyway
17:57:24 <gwern> (shot down!)
17:58:19 <psygnisfive> i was inspired to come back after reading that the channel had over 566 users last week
17:58:29 <Axman6> ?users
17:58:29 <lambdabot> Maximum users seen in #haskell: 552, currently: 489 (88.6%), active: 12 (2.5%)
17:58:34 <psygnisfive> quite impressive, but yeah most /are/ lurkers :p
17:58:44 <psygnisfive> hah! don stewart you was wrong!
17:58:49 <Axman6> knowledge leachers!
17:58:50 <gwern> maybe they're all at dinner
17:58:53 <psygnisfive> unless you meant a non-freenode channel but thatd be weird
17:59:03 <povman> Axman6: let's screw them over by throwing in some lies
17:59:04 <Axman6> psygnisfive: lambdabot's been restarted since then i believe
17:59:08 <psygnisfive> oh ok.
17:59:13 <psygnisfive> so hey, question
17:59:21 * gwern leaches. seeding knowledge of partial application and xmonad to... 0 peers. upload ratio: 0.10
17:59:27 <psygnisfive> any good, easy to install mac interps/compilers?
17:59:45 <Axman6> macports makes installing both hugs and ghc easy
17:59:56 <Axman6> go with ghc though
18:00:04 <Axman6> `sudo port install ghc`
18:00:07 <gwern> '
18:00:08 <gwern> 'This is a new "major" release, the first of the 0.4 branch, and as
18:00:08 <gwern> such it is not backwards compatible with the releases in the 0.3
18:00:08 <gwern> branch. This is due to two major changes to the design of the library:'
18:00:13 <povman> also the ghc 6.10 binary is ridiculously easy to install
18:00:28 <povman> and doesn't take 10 hours to compile
18:00:31 <thoughtpolice> psygnisfive: there's an OS X bundle for GHC 6.10.1
18:00:31 <Axman6> yeah, but where's the fun in that?
18:00:34 <gwern> guess lambdabot wants 0.3
18:00:40 <psygnisfive> oh is there now?
18:00:47 <thoughtpolice> gwern: 0.3 of what?
18:01:10 <thoughtpolice> psygnisfive: http://haskell.org/ghc/download_ghc_6_10_1.html#macosxintel
18:01:16 <lambdabot> Title: GHC: Download version 6.10.1
18:01:36 <psygnisfive> thank you :o
18:01:37 <psygnisfive> <3
18:02:36 <psygnisfive> er.. do i need to install anything else?
18:02:42 <gwern> thoughtpolice: haskell-src-exts
18:02:53 <povman> say, what's the standard method of building haskell programs (during development)
18:03:01 <psygnisfive> it says "It needs libedit.2.dylib, libncurses.5.dylib and libgmp.3.dylib under /opt/local/lib/"
18:03:08 <psygnisfive> does this mean i need to go get those? :|
18:03:11 <povman> i currently have a script called 'compile' which runs my ghc command line
18:03:29 <povman> psygnisfive: install them with macports
18:03:35 <povman> macports installs to /opt
18:03:38 <gwern> povman: I like cabal install
18:03:50 <psygnisfive> its always gotta be complicated
18:03:54 <thoughtpolice> povman: cabal install :]
18:04:10 <povman> won't that distribute my files all over the place?
18:04:18 <thoughtpolice> psygnisfive: why don't you use the OS X installer? ppc system?
18:04:23 <Axman6> psygnisfive: this is why i suggested you use macports, far more fun to watch everything happening ;)
18:04:25 <gwern> all over the place?
18:04:39 <povman> i thought cabal install built stuff then put it in /usr/local or whatever
18:04:41 <psygnisfive> thoughtpolice: does it include all the necessary stuff tho?
18:04:49 <Saizan> povman: "cabal build" will just put the .o .hi under dist/build/$pkgname
18:05:01 <gwern> povman: it puts it where you tell it, which for me is ~/bin
18:05:09 <thoughtpolice> gwern: ah. i've been thinking about haskell-src-exts recently; I emailed niklas about pragma support earlier - if we could get that into the code we could use it for lhc
18:05:21 <thoughtpolice> psygnisfive: yes
18:05:27 <povman> right... i'll look into it. thanks
18:05:31 <gwern> thoughtpolice: that is, lhc doesn't support the pragmas they use?
18:05:40 <psygnisfive> thoughtpolice: ok. good. :P
18:05:51 <thoughtpolice> gwern: no, david and I are going to use haskell-src-exts for LHC's parser
18:05:55 <thoughtpolice> since john's parser has some bugs in it
18:06:17 <thoughtpolice> but we can't do that yet because haskell-src-exts has no pragma support (silently treated as comments,) and things like the RULES pragma are pretty important to have
18:06:24 <gwern> thoughtpolice: I meant, how are the pragmas stopping you?
18:06:33 <gwern> oh, exts itself doesn't parse them
18:06:56 <thoughtpolice> yeah
18:07:02 <thoughtpolice> that's really the only thing holding it off right now
18:07:27 <thoughtpolice> I have a few plans as to what to do to the source; spit polish it into shape before an inevitable announcement of its existence.
18:07:54 <psygnisfive> :o!!!
18:07:57 <psygnisfive> :D
18:07:58 <thoughtpolice> (if we get pragmas into haskell-src-exts and then bring that back into lhc though, it should be a HUGE win)
18:08:11 <psygnisfive> thoughtpolice you are wonderful
18:08:43 <psygnisfive> now i just need to figure out how to use this thing. :D
18:09:05 * BMeph is _so_ tempted to tell his wife, "sudo make me a sandwich"...
18:09:17 <monochrom> hah
18:09:42 <thoughtpolice> gwern: notably things like stringtable-atom need to be gotten rid of because they complicate things (and we need un-necessary crap because of it,) there should be something of a test/regression suite, the region inference algorithm needs fixing, and replacing some of the old autoconf-created files like primops and whatnot
18:10:33 <povman> psygnisfive: how to use haskell?
18:10:42 <psygnisfive> no how to use ghci :p
18:10:45 <thoughtpolice> if we integrate haskell-src-exts though then we'll also either need to A) make the compiler ignore things it doesn't yet support (i.e. GADTs and ATs) or B) hack support for them into the compiler before anything else
18:10:49 <psygnisfive> but im using the manual so.. :P
18:10:49 <povman> heh
18:11:08 <povman> see how quickly psygnisfive has installed ghc
18:11:17 <gwern> thoughtpolice: quite a todo list
18:11:18 <psygnisfive> very quickly!
18:11:27 * gwern wonders how to convert a windows text file to unix
18:11:29 <povman> rather more quickly than macports would 'of'
18:12:19 <thoughtpolice> gwern: well, before Lemmih forked jhc, I was secretly working on my own haskell compiler, and it shared a huge amount of similarities with jhc. so when lemmih forked, I pretty much dropped my project and decided to get onboard. :]
18:12:26 <povman> do i really need a Setup.hs if i have cabal-install?
18:12:39 <Lemmih> povman: Nope.
18:12:42 <gwern> thoughtpolice: kudos
18:12:49 <povman> ah, excellent
18:12:57 <thoughtpolice> gwern: but most of those changes I listed above (aside from e.g. supporting GADTs and stuff) are more broad than they are deep
18:13:10 <thoughtpolice> in particular, removing stringtable-atom will probably take some time
18:13:24 <badsheepy> most unix systems have dos2unix installed gwern
18:13:27 <thoughtpolice> same with the region inference algo
18:13:37 <thoughtpolice> although that particular problem can be mitigated by using '-fboehm'
18:14:24 <Saizan> the internal typed language of lhc is the one called E?
18:14:32 <thoughtpolice> yes
18:14:44 <Saizan> any papers on it?
18:14:50 <thoughtpolice> it's based on henk
18:14:56 <thoughtpolice> @go Henk a typed intermediate language
18:15:02 <lambdabot> http://citeseer.ist.psu.edu/75539.html
18:15:02 <lambdabot> Title: Henk: A typed intermediate language - CiteSeerX
18:15:18 <gwern> badsheepy: peculiarly, I don' tseem to
18:15:27 <Saizan> oh, but it's dependently typed?
18:15:35 <thoughtpolice> Saizan: based on the lambda cube, yeah
18:15:35 <gwern> I thought lhc/jhc was based on GRIN?
18:15:47 <thoughtpolice> gwern: GRIN is the second intermediate language
18:16:45 <gwern> oh
18:16:54 <gwern> E being similar to GHC Core?
18:17:01 <thoughtpolice> Saizan: because of that, I'm of the impression that if we do get lhc to use haskell-src-exts, fitting GADTs etc. onto E won't be that hard (as opposed to Core, which afaics required type-equality extensions to support things like that, as well as things like associated types)
18:18:05 <thoughtpolice> Lemmih: also I emailed niklas about re. haskell-src-exts and pragmas
18:18:42 <thoughtpolice> gwern: off hand I couldn't tell you how similar they are, although according to jhc's page, it's similar enough to core that a lot of optimizations can be applied in a similar manner
18:23:08 <Debugger> I'm an haskell noob but... why would anyone use anything else than ghc?
18:23:59 <Riastradh> Perhaps because GHC doesn't run on someone's platform, Debugger.
18:24:13 <thoughtpolice> Debugger: if you're looking for an industrial-grade implementation, you probably aren't going to go anywhere but GHC.
18:24:34 <Debugger> Thank you for the quick answers :)
18:24:42 <thoughtpolice> Debugger: but lhc/jhc have fundamentally different design decisions that touch all parts of the system, i.e. the code generated
18:24:53 <monochrom> There is another haskell compiler that generates javascript, while GHC doesn't.
18:25:00 <thoughtpolice> Debugger: for example, lhc/jhc can in some instances produce code that is over 8x faster than GHC, especially in loops.
18:25:10 <thoughtpolice> (tight loops, that is)
18:25:19 <Debugger> Hmm, i see
18:25:34 <thoughtpolice> Debugger: also, the C code that lhc/jhc output is 100% ISO C, so you can take that code and compile it almost anywhere (people have positive reports of doing this on e.g. nokia phones)
18:26:01 <Debugger> Ah, nice, didn't know that :)
18:26:22 <Debugger> haskell to javascrip?
18:26:23 <p_l> thoughtpolice: How much of the available code right now compiles on lhc/jhc? (if there are any reports?)
18:27:34 <dons> there are some niches where hugs and nhc have room to play
18:27:42 <thoughtpolice> p_l: not much
18:27:45 <dons> but its been a long time since i've seen a project aimed at nhc or hugs.
18:27:53 <gwern> question - 'readFile' is lazy, correct?
18:27:54 <dons> ghc is 100% of the market effectively
18:27:58 <thoughtpolice> p_l: lhc/jhc are still very much experimental.
18:27:59 <dons> gwern: yes.
18:28:01 <thoughtpolice> gwern: yes
18:28:04 <thoughtpolice> dons: this is true.
18:28:16 <gwern> ah, I thought that was the culprit for my file locked error
18:28:19 <gwern> @hoogle readFile
18:28:20 <lambdabot> Prelude readFile :: FilePath -> IO String
18:28:20 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
18:28:20 <lambdabot> System.IO readFile :: FilePath -> IO String
18:28:27 <p_l> thoughtpolice: But there is chance of getting lhc/jhc into mostly GHC-compatible stage?
18:28:30 <gwern> is the System.IO one strict?
18:28:36 <dons> gwern: no.
18:28:37 <dons> same one.
18:28:47 <dons> Data.ByteString.* or System.IO.Strict.* are strict
18:28:53 <gwern> (that does make sense...)
18:28:54 <thoughtpolice> p_l: one of my plans I was talking about earlier was to use the haskell-src-exts package for lhc's parser, instead of the home-grown happy based one that is apart of jhc.
18:29:48 <povman> alright then, can i use cabal when my main() is in C?
18:29:54 <thoughtpolice> p_l: (lhc is a fork of lhc, fyi)
18:29:55 <p_l> thoughtpolice: Well, it would be nice to have a full, GHC-compatible compiler that would produce ANSI C - at the moment I've got much better portability with Common Lisp
18:29:58 <thoughtpolice> er, lhc is a fork of jhc
18:30:03 <thoughtpolice> p_l: what that means is that if we go through with this, that lhc will support a *vastly* larger amount of code, and would in fact probably make lhc the 2nd most extension-supportive haskell compiler, next only to ghc.
18:30:20 <p_l> that would be nice :-)
18:30:34 <thoughtpolice> p_l: also, haskell-src-exts supports things that even ghc doesn't, like regular patterns and embedded XML-style syntax
18:30:41 <p_l> it could also make it easy to port haskell to new platforms
18:30:52 <thoughtpolice> p_l: one of my thoughts was to use these features to allow e.g. web applications to be first-class supported by lhc
18:31:24 <thoughtpolice> p_l: on that note, see here as an example of what I mean - http://projects.haskell.org/pipermail/lhc/2008-November/000005.html
18:31:26 <lambdabot> Title: Current ideas, http://tinyurl.com/5blbk3
18:31:32 <thoughtpolice> p_l: yes, it would.
18:31:33 <p_l> thoughtpolice: That situation reminds me of reading "applications of functional programming" and seeing Monads as "interesting extension used internally in GHC"
18:31:44 <thoughtpolice> p_l: but it will probably be a long way off until lhc can compile itself, if ever.
18:32:20 <povman> i'm trying to use cabal to replicate the following command line: ghc -no-hs-main --make c_main.c ClientDemo.hs -framework SDL -O
18:33:04 <thoughtpolice> p_l: but yes, since lhc was forked I've been contributing to it, mainly cleaning up code and removing dead code in favor of libraries (the darcs version of lhc is directly installable with no-fuss using cabal-install)
18:34:52 <thoughtpolice> p_l: and my plans *are* to integrate haskell-src-exts into it and use it as the parser, because it means that the compiler would immediately support way more code, which would be great
18:34:52 <thoughtpolice> if we can work out some of the bugs in the compiler, it also means we can take a vastly larger amount of haskell code and run it just about anywhere since lhc outputs ISO C
18:34:52 <thoughtpolice> all very fun things :]
18:40:03 <gwern> @do readDB = io $ liftM readFile dbLocation >>= \ db -> (liftM read db)
18:40:04 <lambdabot> readDB = io $ liftM readFile dbLocation >>= \ db -> (liftM read db) not available
18:40:08 <gwern> @redo readDB = io $ liftM readFile dbLocation >>= \ db -> (liftM read db)
18:40:09 <lambdabot> readDB = io $ do { db <- liftM readFile dbLocation; (liftM read db)}
18:40:51 <badtruffle> is there something like a "sliding window" fold/map defined somewhere?
18:42:11 <pumpkin> or something that just computes a bunch of sliding windows
18:43:12 <gwern> could I use ($!) to force readFile and writeFile?
18:47:01 <alexsuraci> Is there a more elegant way of getting 9 lines than binding "getLine" 9 times?
18:47:29 <gwern> yes
18:47:33 <twanvl> replicateM
18:49:24 <alexsuraci> twanvl: Thanks. :)
18:50:15 <povman> cabal isn't putting my c file in the build command
18:50:35 <pumpkin> hmm, can't find one myself... I guess I'll have to write one
18:50:57 <pumpkin> @src take
18:50:57 <lambdabot> take n _      | n <= 0 =  []
18:50:57 <lambdabot> take _ []              =  []
18:50:57 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
18:51:03 <povman> http://hpaste.org/12452
18:51:05 <Lemmih> povman: It probably compiles the c file separately.
18:51:16 <povman> but it's not linking the .o in
18:51:55 <povman> nor actually generating a .o
18:53:04 <thoughtpolice> povman: you have to list every .c file in a 'c-sources:' field
18:53:13 <povman> i did that
18:53:24 <povman> ^ hpaste
18:53:38 <pumpkin> is there any way to define a pattern-matching function to lambdabot?
18:53:41 <pumpkin> with more than one pattern
18:53:42 <Lemmih> povman: paste the output of the build.
18:55:23 <povman> http://hpaste.org/12452#a1
18:57:49 <Lemmih> And c_main.c exists in that directory?
18:58:06 <Lemmih> Ah.
18:58:24 <Lemmih> Weird.
18:59:23 <gwern> @hoogle String -> [Word8]
18:59:24 <lambdabot> Prelude fail :: Monad m => String -> m a
18:59:24 <lambdabot> Control.Monad fail :: Monad m => String -> m a
18:59:24 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
18:59:43 <gwern> (the list monad strikes again!)
19:00:06 <gwern> @hoogle Word8
19:00:07 <lambdabot> Data.Word data Word8
19:00:07 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
19:00:32 <povman> might i have found a bug?
19:00:44 <gwern> strange. there must be a String -> ByteString, but pack doesn't seem to be it?
19:02:00 <twanvl> ?type Data.ByteString.Char8.pack
19:02:01 <lambdabot> String -> BSC.ByteString
19:02:59 <mmorrow> pumpkin: just separate the decls with semis
19:04:36 <Axman6> Lemmih: i can't get lhc to install, i'm getting: exit: ExitFailure 127 :(
19:04:42 <pumpkin> ah, of course
19:04:50 <Lemmih> Axman6: Install DrIFT.
19:05:18 <Axman6> should that be a dependency?
19:05:36 <Lemmih> Axman6: Newer versions doesn't depend on it.
19:05:37 <Axman6> that seems to have fixed it :)
19:05:42 <Axman6> righto
19:11:35 <mmorrow> Lemmih, thoughtpolice: it seems that "external" core languages are super useful. yhc-core has/is been/being used for tons of stuff (reduceron, yhcjs, hhi, ...), and i've just recently been working on making ghc ext-core easier to get out (and /still/ in haskell data form (a la show), so you can just use read instead of having to parse it (just got this working last night)). anyways, what i'm getting at is that these external core lang
19:11:35 <mmorrow> uges are very useful and specifying one for lhc i think would be a win.
19:14:08 <mmorrow> in my case, i'm interested in using ext-core output from ghc to get all the ghc optim/typechecking/what-have-you for free, and then have something manageable to compile to bytecode for an implem of this:  http://serv1.ist.psu.edu:8080/viewdoc/summary?doi=10.1.1.81.7841  that i'm working on
19:14:09 <lambdabot> Title: The Lazy Virtual Machine specification - CiteSeerX
19:15:43 <gwern> mmorrow: you can now do read and show on ghc core? kudos!
19:15:56 <mmorrow> gwern: ghc /external/ core
19:16:11 <gwern> (still cool)
19:16:31 <mmorrow> gwern: but ghc-core may be doable too (i'm not sure about this)
19:16:33 <mmorrow> :)
19:16:37 <mmorrow> very cool
19:17:07 <mmorrow> i think translating to yhc-core would be really easy to do also
19:17:41 <mmorrow> which would e.g. let you use ghc with yhcjs/reduceron/hhi ...
19:18:08 <mmorrow> messing with those three projects has been the only reason i've had to use yhc
19:18:32 <gwern> ah, frick. if I use stock readFile and writeFile, I get conflicts because readFile is lazy; but if I use bytestring's strict IO, it does something and now I can't 'read' the string input as [String]!
19:18:33 <mmorrow> (which, compared to ghc, is most definitely lacking)
19:18:51 <pumpkin> sooo I've written a naive sliding window function, but it has a problem
19:19:18 <dons> gwern: um...
19:19:24 <dons> gwern: what's your 'conflict' ?
19:19:28 <dons> just an unclosed Handle?
19:19:35 <pumpkin> I want to have window 3 [1,2,3,4,5] return [[1,2,3], [2,3,4], [3,4,5]]
19:19:48 <gwern> dons: yes, I think that's the issue. yi's *message* says file locked
19:19:56 <gwern> **message* buffer
19:20:05 <dons> so try System.IO.Strict (or a local implementation)
19:20:09 <dons> or read it as a bytestring and unpack.
19:20:12 <gwern> which I believe is because I do a readFile, and then later do a writeFile
19:20:17 <dons> or does yi do unicode IO ?
19:20:19 <gwern> (on the same file)
19:20:19 <Axman6> pumpkin: window n = map (take n) . tails?
19:20:21 <mmorrow> @quote aztec
19:20:21 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
19:20:25 <dons> sure. of course that needs to be strict
19:20:36 <Axman6> > let window n = map (take n) . tails in window 3 [1..5]
19:20:37 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
19:20:37 <gwern> dons: would the read fail if there was unicode in the Strings?
19:20:52 <pumpkin> Axman6: I have something similar, but I want an efficient way to get rid of those extra ones at the end
19:21:04 <dons> i'm not sure what you're doing. if  there's some interpretation happening, then results might differ.
19:21:07 <dons> consult the code
19:21:08 <pumpkin> Axman6: I thought of having a guard on the length of the rest of the list, but that's slow and won't work for infinite lists either
19:21:15 <gwern> the code always knows
19:21:19 <Axman6> > let window n = filter (\l -> length l /= n). map (take n) . tails in window 3 [1..5]
19:21:21 <lambdabot>   [[4,5],[5],[]]
19:21:26 <Axman6> > let window n = filter (\l -> length l == n). map (take n) . tails in window 3 [1..5]
19:21:28 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
19:21:45 <mmorrow> then you have to traverse each sublist twice though
19:21:52 <pumpkin> Axman6: that involves two traversal
19:21:55 <pumpkin> yeah :/
19:22:09 <pumpkin> seems it can be done more efficiently
19:22:29 <mmorrow> probably write a modified `take' that either returns /exactly/ that number or []
19:22:40 <mmorrow> then takeWhile (not . null) or something
19:22:44 <pumpkin> ah
19:22:46 <pumpkin> hmm
19:22:50 <gwern> dons: strict-io has no writefile; what's up with that?
19:24:01 <dons> gwern: writeFile is strict
19:24:13 <gwern> already, then. ok
19:24:18 <dons> it doesn't suspend until the disk demands the result , for example :)
19:24:40 <dons> or until someone else looks at the file (imagine an OS that worked like that. interesting)
19:24:50 <thoughtpolice> Axman6: if you get the darcs version of lhc, you don't need anything external - DrIFT was replaced with Data.Derive, which also has simplified the build system a lot
19:25:07 <thoughtpolice> Axman6: also, the darcs repository has improvements in general
19:25:23 <Axman6> righto. well i just wanted to cabal install lhc
19:27:06 <thoughtpolice> Axman6: I was thinking of perhaps putting a snapshot of the darcs version of lhc on hackage, since it now has much better dependencies and is much easier to build, but I haven't done so yet, there are more things I want to work on before an announcement and another upload
19:30:20 <gwern> thoughtpolice: who said you have to do an ann?
19:30:26 <thoughtpolice> mmorrow: I don't think this external language thing would be *too* difficult - GRIN is a whole-program type of intermediate language, so I think making it support external output/input would not be significantly hard
19:30:39 <thoughtpolice> gwern: good point :P
19:31:08 <thoughtpolice> mmorrow: also that brings up the possibility of a whole bunch of lhc-based tools, i.e. ones that take GRIN as input and, say, output LLVM bytecode
19:31:11 <mmorrow> thoughtpolice: cool. after looking at ext-core for a bit, it seems to me a formal spec of such an external lang is crucial
19:31:21 <mmorrow> thoughtpolice: totally!
19:31:24 <thoughtpolice> GRIN is a good target for these things too
19:31:39 <thoughtpolice> it is monadic and strict, and closures are represented with tags
19:31:40 <mmorrow> that's what i'm seeing
19:31:46 <mmorrow> hmm, interesting
19:32:04 <mmorrow> i'll have get familiar with GRIN
19:32:19 <thoughtpolice> mmorrow: ghc's ext-core has problems particularly in reading it in, due to cross-module optimizations that GHC implements
19:32:36 <thoughtpolice> mmorrow: but since grin is naturally a whole-program intermediate representation, it makes things like this significantly easier
19:32:54 <mmorrow> heh, yeah. one would have to compile /everything/ to ext-core
19:33:28 <thoughtpolice> @go Code optimization techniques for lazy functional languages
19:33:30 <lambdabot> No Result Found.
19:35:01 <thoughtpolice> mmorrow: look here - http://www.cs.chalmers.se/~boquist/phd/index.html and also look here - http://www.cs.chalmers.se/~boquist/ifl96-abstract.html
19:35:05 <lambdabot> Title: Abstract
19:35:10 <mmorrow> i pulled out ExternalCore, MkExternalCore, PprExternalCore and wrote some code that parses a module, renames/typechecks it, desugars it, then converts the core to external core which it then hands back to the caller in the ext-core ADT itself rather than as a prettyprinted String you'd just have to turn around and parse again
19:35:12 <thoughtpolice> mmorrow: those two papers are pretty much the references for GRIN
19:35:25 <mmorrow> added Read,Show instances for ext-core types as well
19:35:36 <mmorrow> thoughtpolice: cool, thx. i'll check em out
19:49:21 <adekoba> hi, is it possible to derive(Show,Eq,etc..) from GADT's?
19:49:35 <BMeph> pumpkin: Try http://hpaste.org/12455
19:50:04 <BMeph> pumpkin: If you're still looking at that problem. :)
19:51:32 <pumpkin> that looks cool, but how efficient is something like that?
19:52:48 <ddarius> BMeph: take n . tails ?
19:52:53 <ddarius> map (take n)
19:53:07 <pumpkin> hmm
19:53:12 <byorgey> not very
19:54:49 <Lemmih> adekoba: Nope.
19:55:19 <BMeph> ddarius: You mean instead of the drop n . inits? :)
19:56:18 <adekoba> Lemmih: are you aware of any plans for it to be implimented in the future?
19:56:28 <noddy> guise? is it possible to hack Cont monad into some form of co-routines?
19:56:29 <Lemmih> adekoba: Nope.
19:56:52 <adekoba> ok, thanks.
19:57:19 <thoughtpolice> oi
19:57:21 <gwern> :t join
19:57:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:57:24 <gwern> :t return . return
19:57:26 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, Monad m) => a -> m (m1 a)
19:57:32 <gwern> hm
19:57:38 <noddy> :t return return
19:57:39 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 (a -> m a)
19:58:08 <byorgey> noddy: probably, you can hack Cont into pretty much any control structure you like =)
19:58:24 <thoughtpolice> mmorrow: the GRIN papers are interesting though. also, Lemmih and I would like lhc contributors if you're keen to that. :]
19:58:51 <noddy> byorgey: are you sure? looking at callCC, i can't think of a way to make the "continuation" escape.
19:59:07 <byorgey> noddy: no, I'm not sure
19:59:21 <ddarius> byorgey: You are mostly correct though.
19:59:29 <byorgey> @type callCC
19:59:30 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
19:59:32 <gwern> hm. I wonder if I should be an ass and afd the Awesome WP page
19:59:37 <gwern> er. mischan
19:59:55 <noddy> byorgey: i can't think of a way to avoid an infinite type.
20:00:15 <noddy> :t callCC id
20:00:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
20:00:16 <lambdabot>     Probable cause: `id' is applied to too few arguments
20:00:16 <lambdabot>     In the first argument of `callCC', namely `id'
20:00:21 <ddarius> noddy: You do it the same way you always do in Haskell.
20:00:24 <byorgey> noddy: to avoid an infinite type, just introduce a newtype wrapper
20:01:00 <noddy> yes, thought of that :) . but i just can't think of a way to hack it into a coroutine.
20:01:34 <povman> are there any cabal experts here who can make sense of http://hpaste.org/12452 ?
20:02:09 <povman> or shall i dive into the source?
20:04:42 <byorgey> povman: hm, strange that it's trying to link
20:04:57 <byorgey> povman: you're just making a library right?
20:05:15 <povman> the command line i am trying to imitate is ghc -no-hs-main --make c_main.c ClientDemo.hs -framework SDL -O
20:05:25 <povman> main() is in c_main.c
20:05:49 <povman> but the 'cabal build' does not even touch c_main.c
20:06:32 <byorgey> oh I see, hrm
20:06:35 <byorgey> sounds tricky
20:06:47 <povman> i would have thought c-sources: would do the trick
20:06:47 <Axman6> in fact, i remember jobs announcing that he'd done a whole keynote using intel imacs/
20:06:51 <Axman6> whoops
20:06:55 <Axman6> is there a tool that will go through a piece of code, and place all the type signatures that are missing in it?
20:07:46 <byorgey> Axman6: ISTR hearing of an emacs haskell-mode command that did that (?)
20:08:16 <gwern> yes, I even requested that command and was told it was there already
20:08:26 <Axman6> hmm, kinda hoping for a simple command line tool
20:08:27 <gwern> you can in fact write a macro pretty easy which will do that
20:08:27 <Lemmih> povman: Cabal thinks you're building a library.
20:08:55 <povman> Lemmih: if i use the Executable thing i need to provide main-is
20:10:22 <Lemmih> povman: Hope -no-hs-main cancels it out.
20:11:15 <povman> you think i should make a dummy main somewhere?
20:11:42 <Lemmih> povman: Try with 'Main-is: ZoomDemo.hs'
20:12:36 <Lemmih> povman: c_main.c just calls ZoomDemo.main, no?
20:12:44 <povman> yes
20:14:08 <povman> Lemmih: that worked quite nicely
20:14:22 <povman> however, now my #include "ZoomDemo_stub.h" fails
20:14:45 <povman> what's the True Way of getting the FFI header included?
20:15:56 <Lemmih> I don't think Cabal has a True Way of using a non-Haskell main.
20:17:24 <povman> it must be able to provide the include path for ZoomDemo_stub.h
20:17:37 <povman> if it's willing to build the c source...
20:18:26 <Lemmih> Normally you use C from Haskell, not Haskell from C.
20:18:48 <povman> oh i see
20:19:22 <Lemmih> I'd go with the hack and wait for sunnier days.
20:19:41 <mmorrow> thoughtpolice: darcs getting the sources as we speak
20:19:43 <povman> this is a special case because of how SDL does it's silly #define
20:19:46 <sbahra> Hey mmorrow
20:19:57 <sbahra> Wait, wait
20:19:58 <mmorrow> sbahra: hey, howsit going?
20:19:59 <sbahra> Don't say hi back.
20:20:03 <mmorrow> um
20:20:26 <sbahra> mmorrow, hi, sorry about that. I was going to test an urgency hook.
20:20:37 <pumpkin> @src `$`
20:20:37 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:20:39 <pumpkin> @src $
20:20:40 <lambdabot> f $ x = f x
20:20:43 <pumpkin> omg
20:20:45 <pumpkin> so complicated
20:20:53 <mmorrow> @src ($)
20:20:53 <lambdabot> f $ x = f x
20:21:02 <sbahra> mmorrow, not bad though. :) How's everything with you? :-P
20:21:21 <mmorrow> sbahra: it going well
20:21:45 <sbahra> mmorrow, I have exams for the next 2 weeks after Thanksgiving.
20:21:56 <thoughtpolice> mmorrow: :]
20:22:15 <thoughtpolice> mmorrow: I'm about to push another patch or two here in a sec and then make another release on hackage so people can get the updated compiler
20:22:17 <povman> actually a completely better solution would be to include this c_main thing in the haskell SDL package
20:22:19 <sbahra> So I will not have too much time to work on MMX/SSE2 optimizations once you start rolling.
20:23:00 <Giraffe> @src foldr
20:23:01 <lambdabot> foldr f z []     = z
20:23:01 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:23:07 <Giraffe> @src foldl
20:23:07 <lambdabot> foldl f z []     = z
20:23:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:23:28 <povman> Lemmih: i see you are the hsdl maintainer
20:23:45 <mmorrow> sbahra: ah, well good luck. that'll be perfect and give me some time to put some thought into mmx ideas/interfaces. when you finish exams, we can get going on it.
20:24:04 <sbahra> mmorrow, I hope so.
20:24:20 <mmorrow> heh, me too.
20:27:20 <mmorrow> sbahra: i haven't seen yet a definite "oh that'd be the logical way to go with this",  but some thoughts i've had are *generating custom ffts from an input spec, *maybe something harpyish? (but then we'd have to worry about all the other instructions one'd need), *the same idea as generating ffts, but s/fft/???/
20:27:40 <mmorrow> other that those, i'm kinda stumped.
20:27:55 <thoughtpolice> mmorrow: also if you can add content on http://lhc.seize.it or the bug tracker (http://trac.haskell.org/lhc/) that would be awesome - we should definitely start filing things there, and I've got a basic outline of an 'lhc commentary' on lhc.seize.it
20:27:59 <lambdabot> Title: Wiki - Front Page
20:28:06 <thoughtpolice> mmorrow: the mailing list was giving us issues earlier but you can post whatever ideas you have there
20:28:30 <povman> Lemmih: is it anything of an idea to actually reproduce sdl's main() as a haskell program, to avoid all this C nonsense?
20:28:34 <mmorrow> sbahra: well, i guess also we could implem a mini linalg package that somehow uses mmx stuff
20:28:52 <mmorrow> sbahra: but how to structure such a thing i'm not quite sure
20:29:03 <sbahra> mmorrow, like I said, you can lead the way in design :-) As long as we can have large chunks of SIMD-optimized assembly...I'll have a good amount to work on.
20:29:11 <mmorrow> thoughtpolice: cool.
20:29:32 <sbahra> mmorrow, BTW: You don't mind git, do you?
20:29:52 <gwern> @hoogle catch
20:29:53 <lambdabot> package catch
20:29:53 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
20:29:53 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
20:30:12 <mmorrow> sbahra: what are some of your thoughts though on things that would be well-served by mmx instructions + haskell?
20:30:25 <mmorrow> sbahra: git is ok :)
20:30:27 <sbahra> Well, "vector"-ish instructions in general.
20:30:34 <povman> Lemmih: i mean something so users can write "main = sdl myMain", thereby making haskell the 'outer layer'
20:30:44 <sbahra> mmorrow, hmatrix seemed interesting.
20:31:38 <sbahra> There are some restrictions though
20:31:44 <mmorrow> sbahra: it's great and i use it a fair amount. hmm, maybe a mini mmx-optim linalg pkg /would/ be feasible (without massive effort).
20:31:47 <sbahra> Namely, we have alignment restrictions if we expect performance.
20:31:55 <sbahra> This means that we can't be completely lazy.
20:32:22 <sbahra> I could start with a general package first.
20:32:42 <mmorrow> sbahra: so we'd be doing our own memory management most likely.
20:32:59 <sbahra> http://hackage.haskell.org/packages/archive/cpuid/0.2/doc/html/System-Cpuid.html
20:33:03 <lambdabot> Title: System.Cpuid, http://tinyurl.com/6r7x7o
20:33:27 <sbahra> We also either need to update that or work on alternative package for the very basic things.
20:33:31 <mmorrow> sbahra: oh cool, i haven't looked at that pkg before.
20:34:02 <sbahra> mmorrow, it lacks a lot of information (feature flags, MS options, etc...)
20:34:41 <mmorrow> sbahra: ok nice, i think i see possible directions more clearly now.
20:38:16 <MikeMayer> good evening gentlemen
20:38:42 <gwern> http://hpaste.org/12456 <-- I am confused by this exception behaivour. is this attributable to the prelude catch not being very good?
20:39:12 <povman> hi MikeMayer
20:43:53 <mmorrow> gwern: use Control.Exception.catch (or Control.OldException.catch if you're on 6.10 and want the old interface)
20:44:18 <mmorrow> i'm not sure the exact behavior of Prelude.catch since i avoid it like the plague ;)
20:44:42 <gwern> my only problem with Control.Exception.catch (verss OldException) is that it leads to an odd type error about an ambiguous type variable 'e'
20:44:52 <mmorrow> yeah, that's the new interface
20:45:23 <gwern> damn. oldexception doesn't fix it - it's still an erro rather than "[]"
20:45:33 <mmorrow> Control.OldException.catch won't give you that problem, but if Control.Exception is already being used in that code, you'll just have to annotate the exception in the handler with a type
20:45:55 <mmorrow> i always do (when i want it to catch everything):
20:46:21 <mmorrow> catch blahblah (\e -> ... (e::SomeException) ...)
20:46:53 <mmorrow> or this is sometimes easier due to the code in the handler:
20:47:12 <gwern> guess I'll have to put the catch outside the body of the function
20:47:13 <mmorrow> catch blahblah (\_ -> blah blah :: SomeException -> ... )
20:49:57 <mmorrow> perhaps i'll find the extensible exceptions extremely useful once i finally take the time to learn how to use them, but until then i find it a pain in the ass to always have to clutter the code in the handler with a type annotation (granted, i usually don't do anything useful with exceptions, so my handlers are usually (\e -> return (Left (show e)))
20:50:15 <mmorrow> and now they are
20:50:45 <mmorrow> (\e -> return (Left (show e)) :: SomeException -> IO (Either String _)
20:50:47 <mmorrow> )
20:59:38 <robf> coming to haskell from perl... wow my head is gonna explode ><
20:59:45 <pumpkin> :)
21:00:53 <robf> spent 20 minutes trying to figure out that div needed backticking...
21:01:06 <MikeMayer> robf: I hear ya... I've got about 26 hours to complete a haskell assignment with only imperative language experience before
21:01:16 <robf> anyone care to explain the difference between 2 `div` 1 versus 2 div 1
21:01:26 <maxote> @briggs citeseer
21:01:27 <lambdabot> Unknown command, try @list
21:01:33 <shapr> MikeMayer: Why did you wait to do your homework?
21:01:37 <bd_> robf: 2 `div` 1 is the same as (div 2) 1. 2 div 1 is the same as (2 div) 1
21:01:48 <robf> ah
21:01:50 <maxote> @go briggs citeseer
21:01:54 <lambdabot> http://citeseer.ist.psu.edu/briggs94improvements.html
21:02:08 <robf> no wonder it didn't like that
21:02:33 <vegai> robf: a bit of exploing might be healthy after all the imploding perl must've caused you :P
21:02:43 <robf> perl makes sense to me :(
21:02:48 <bd_> Now, the latter only works if there's an instance of Integral b => Num (b -> b -> b)
21:03:15 <vegai> for some reason, perl seems to me more and more interesting. I last used it almost 10 years ago and didn't touch it since
21:03:28 <robf> heh
21:03:54 <maxote> @go chaitin register citeseer
21:03:56 <robf> perl has its place... though my mathematician friend had the horrified look when I was doing complex math with perl
21:03:57 <lambdabot> http://citeseer.ist.psu.edu/195614.html
21:03:57 <lambdabot> Title: Iterated register coalescing - CiteSeerX
21:04:19 <maxote> the Chaitin/Briggs scheme is good for register allocation
21:04:33 <robf> I thought he was going to drool a bit before his statement of "that is so...so very wrong"
21:05:48 <gwern> w00t! my incremental reader is done! at least, the basic functionality is now there!
21:06:01 <gwern> it is possible to extend yi after all
21:06:14 <thoughtpolice> gwern: what're you hacking together for yi?
21:06:43 <gwern> thoughtpolice: think of it as a mode which cycles through a bunch of articles
21:07:06 <gwern> the idea being you take notes, trim the article, write down questions etc, then you hit M-1 when you're bored and go on to the next article
21:07:10 <gwern> and so on
21:07:13 <thoughtpolice> yay - http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lhc - nice new updated lhc :]
21:07:13 <lambdabot> Title: HackageDB: lhc-20081121
21:07:53 <erikc> gwern: whats that
21:08:06 <gwern> (currently I have M-1 saves the buffer, and goes on to the next article; M-2 takes the buffer contents and saves them as a new article; M-3 dletes the article in the buffer from the database and goes to the next article)
21:08:38 <mmorrow> gwern: cool. yi++
21:08:43 <vininim> the shock: yi is being actively developed? must try it!
21:08:58 <gwern> mmorrow: not really, it's taken me two days and I have cursed yi multiple times
21:09:16 <gwern> let's just say it's nontrivial figuring out how to get the contents of a buffer as a String
21:11:13 <mmorrow> gwern: hehe. i'm also slowly trying to figure out howtf the make yi do stuff :)
21:11:27 <hackage> Uploaded to hackage: lhc 0.6.20081127
21:11:40 <gwern> it turned out to be relatively easy to get BufferM String - but it was not documented, period
21:12:05 <mmorrow> gwern: yuh, the documentation is teh src codez
21:12:46 <gchin> hello, I was wondering if there are any tricks to prevent recursive imports a la header guards for includes in C/C++?
21:12:59 <shapr> @users
21:12:59 <lambdabot> Maximum users seen in #haskell: 552, currently: 485 (87.9%), active: 19 (3.9%)
21:14:11 <ddarius> shapr ircs from his sleep
21:15:54 <robf> quick question I'm not really sure about... all this indention stuff.    how does that work?
21:16:05 <gwern> well?
21:16:07 <robf> I mean does it care about indention length,   spaces / tabs
21:16:11 <mmorrow> gchin: the best you can do is to have a module that imports a desired module, then exports only the part of that module (explicitly listing functions/datas/classes). then, import this "interface" module from your code
21:16:27 <robf> is there a doc on it thats explicit about it?
21:16:34 <ddarius> @where report
21:16:35 <lambdabot> http://www.haskell.org/onlinereport/
21:17:09 <Lemmih> thoughtpolice: I wonder if we can delete version 20081121. Or at least re-version it to 0.5.20081121.
21:17:58 <thoughtpolice> Lemmih: oi, yeah. tbh hackage should really have some sort of interface where package-uploaders can, you know, maintain that kind of stuff.
21:18:12 <thoughtpolice> Lemmih: we'll have to talk to dcoutts about re-versioning it or just removing it
21:18:31 <mmorrow> robf: after the keywords "do","where","let","of" the indent of the following token sets an imaginary vertical line for every following token that is to be considered within that "subsection"
21:18:50 <mmorrow> and by "indent" i mean column number
21:19:29 <robf> ah so its arbitrary
21:19:50 <mmorrow> it's arbitrary until you type the next token, at which point it becomes set
21:19:58 <gchin> mmorrow: well, that solution would work, thanks
21:20:30 <mmorrow> gchin: cool. that's the method lunabot does to hide unsafe functions
21:20:44 <robf> mmorrow:  yeah,  gotcha
21:21:24 <thoughtpolice> Lemmih: either way I think it's OK right now, but yeah, I was planning on doing periodic uploads of the darcs sources onto hackage, so we do need to do something about 20081121
21:26:43 <mmorrow> wow
21:26:45 <mmorrow> shift/reduce conflicts:  72
21:26:45 <mmorrow> reduce/reduce conflicts: 20
21:27:17 <mmorrow> heh, looks like what i get when i try to hack on haskell happy parsers
21:27:35 <thoughtpolice> mmorrow: :] don't worry, I do hope that will be gone soon
21:27:48 <mmorrow> ghc has 1 reduce/reduce and 6 shift/reduce iirc
21:28:21 <thoughtpolice> switching to haskell-src-exts and getting rid of stringtable-atom are going to be long, tough changes
21:28:27 <thoughtpolice> but they will both be extremely beneficial
21:28:39 <mmorrow> thoughtpolice: one point against haskell-src-exts and for trying to extract ghc's lexer/parser is that haskell-src-exts can't handle (e.g.) using "forall" as a function name
21:28:44 <mmorrow> (whereas ghc can)
21:28:58 <mmorrow> ie, that general situation
21:29:11 <mmorrow> , let forall = 42 in forall
21:29:16 <lunabot>  42
21:29:17 <thoughtpolice> stringtable-atom will allow us to get rid of otherwise worthless and crappy support code like Support.MapBinaryInstance
21:29:22 <mmorrow> , parseHsExp "let forall = 42 in forall"
21:29:24 <lunabot>  luna: Ambiguous occurrence `parseHsExp'
21:29:48 <thoughtpolice> mmorrow: there are probably still things to be worked out, yeah
21:29:49 <mmorrow> , Luna.Utils.parseHsExp "let forall = 42 in forall"
21:29:52 <lunabot>  luna: Not in scope: `Luna.Utils.parseHsExp'
21:29:54 <mmorrow> grr
21:30:07 <thoughtpolice> mmorrow: but haskell-src-exts is most definitely a much better piece of code to work with than john's home-grown parser
21:30:20 <mmorrow> thoughtpolice: solving that problem though would require a /substantial/ rewriting of how the lexer works
21:30:36 <mmorrow> or at least that's what it seems it would take
21:31:28 <thoughtpolice> mmorrow: switching to haskell-src-exts is still a ways off
21:31:31 <mmorrow> thoughtpolice: yeah, i agree that haskell-src-exts (has the same number of ambiguities as ghc's parser) would be better than the current happy parser for sure
21:31:39 <thoughtpolice> we need to add pragma support mainly
21:31:48 <thoughtpolice> we basically won't switch until that happens
21:31:57 <thoughtpolice> and even then it's going to be a long touch change I'll make on my own branch
21:33:03 <mmorrow> lhc 0.6.20081123 (ryu) compiled by ghc-6.10 on a i386 running linux
21:33:04 <thoughtpolice> but it will be worth it
21:33:04 <mmorrow> :)
21:33:25 <thoughtpolice> and then inevitably we'll be able to add e.g. GADT and associated type support
21:33:28 <mmorrow> thoughtpolice: yeah, it'd definitely be worth it
21:33:53 <thoughtpolice> mmorrow: I just pushed 0.6.20081127 (kami) to http://code.haskell.org/lhc
21:33:54 <lambdabot> Title: Index of /lhc
21:33:59 <thoughtpolice> and it's on hackage now too
21:34:38 <thoughtpolice> although cabal install will try to install lhc-20081121 instead of lhc-0.6.20081127, because 20081121 > 0.6.20081127
21:34:53 <mriou_> noobish question: say that I have a function taking n parameter and a tuple of n elements
21:35:04 <mriou_> how do I apply this function on those parameters?
21:35:08 <thoughtpolice> mmorrow: there shouldn't be too many significant changes; I mainly tagged that because there have been some major improvements in the past week since the fork started
21:35:11 <mmorrow> thoughtpolice: oh cool, i'll pull
21:35:17 <thoughtpolice> and I wanted to put that on hackage for people to play with
21:35:37 <thoughtpolice> i mainly deleted a lot of stuff and replaced things that could be replaced with stuff on hackage
21:35:42 <thoughtpolice> utf8-string was a funny one,
21:36:15 <mmorrow> how so?
21:36:24 <thoughtpolice> I replaced *at least* 10 different definitions of 'toUTF' and 'fromUTF' (which were all identical) all across the source code
21:36:39 <mmorrow> heh
21:36:57 <thoughtpolice> and Lemmih got rid of Doc just earlier today
21:36:59 <thoughtpolice> which is great
21:37:15 <thoughtpolice> because it means the darcs repo is just as easy to build (no intermediate 'darcs get http://...' step)
21:37:54 * mmorrow does it that way anyways ;)
21:38:39 <dons> thoughtpolice: that's awesome.
21:38:39 <lambdabot> dons: You have 10 new messages. '/msg lambdabot @messages' to read them.
21:39:04 <thoughtpolice> dons: yeah, having 'cabal install lhc' is greatness :]
21:39:54 <thoughtpolice> and now that DrIFT is gone in favor of derive - which also benefited since it now has another useful derivation - the build system is much simpler and there are fewer external dependencies (esp. nice because cabal can't set dependencies upon arbitrary executables like DrIFT)
21:40:09 <thoughtpolice> so things are looking good :]
21:40:15 <ushdf_> haskell increasingly looks less complicated
21:40:27 <dons> thoughtpolice: the only compiler that's cabal-installable
21:40:32 <dons> ushdf_: that's good!
21:40:38 <ushdf_> yes
21:40:41 <ushdf_> time to code
21:40:49 <dons> if 500 irc geeks can work it out, world domination can't be far away
21:41:09 <mmorrow> thoughtpolice: one thing i just noticed is that if you bump the version number, but don't make any modifications to the file that holds the version::String and ./Setup build without cleaning first, you get a binary that prints the old version number
21:41:40 <ushdf_> i'm no geek
21:41:43 <ushdf_> i'm a deity
21:41:44 <mmorrow> i guess touching Main.hs (or whatever) would fix that
21:41:45 <thoughtpolice> mmorrow: the patches I pushed now make src/LHCVersion.hs use the 'Paths_lhc' module
21:41:51 <mmorrow> ah nice
21:41:55 <thoughtpolice> mmorrow: so now if you bump the version,
21:42:01 <thoughtpolice> you only have to change the version in lhc.cabal
21:42:16 <mmorrow> sweetness
21:42:20 <thoughtpolice> yeah
21:42:22 <mmorrow> Paths_foo++
21:42:24 <thoughtpolice> makes life way easier
21:42:26 <ushdf_> i have a game to code
21:42:35 <ushdf_> it will blow all your petty little minds
21:42:52 <mmorrow> lhc 0.6.20081127 (kami) compiled by ghc-6.10 on a i386 running linux
21:42:54 <ushdf_> there's floating shit everywhere and lots of letters
21:42:58 <ushdf_> and you can become god
21:43:11 <thoughtpolice> mmorrow: yay!
21:43:16 <Trinithis> @src span
21:43:17 <lambdabot> Source not found. Wrong!  You cheating scum!
21:43:19 <mmorrow> i hope the main character has a biohazard suit on if there's floating shit everywhere
21:43:23 <Trinithis> @src Data.List.span
21:43:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:43:38 <ushdf_> there's no main character
21:43:48 <ushdf_> every character is regenerated every second
21:44:17 <mmorrow> that solves the shit problem too i guess
21:44:29 <thoughtpolice> mmorrow: but yes, please toy around and play with the compiler, even in its current form, it has some (I think) very good improvements - http://code.haskell.org/lhc/ChangeLog
21:44:46 <ushdf_> i'm the black elvis
21:44:55 <mmorrow> thoughtpolice: woohoo
21:44:58 <thoughtpolice> most of the changes involve factoring stuff out and using libraries off hackage instead
21:45:05 <thoughtpolice> rather than major compiler changes
21:45:09 <ushdf_> > foldr (*) 0 [1..128]
21:45:09 <thoughtpolice> but hey, that's a very good improvement :]
21:45:10 <lambdabot>   0
21:45:15 <ushdf_> > foldr (*) 1 [1..128]
21:45:16 <lambdabot>   385620482362580421735677065923463640617493109590223590278828403276373402575...
21:46:58 <thoughtpolice> mmorrow: also if you have patches, I can probably add you to the lhc-repository commit list on code.haskell.org, but if not then just bug me or Lemmih and email patches until Lemmih can add you :]
21:47:02 <ushdf_> > map (\x->x^x^x) [1..20]
21:47:03 <lambdabot>   [1,16,7625597484987,1340780792994259709957402499820584612747936582059239337...
21:47:29 <ushdf_> > map (\x->x^x^x/100) [1..20]
21:47:30 <lambdabot>   Add a type signature
21:47:46 * ushdf_ coughs
21:48:21 <ushdf_> how do i define a function in lambdabot
21:48:59 <mmorrow> thoughtpolice: cool, i'm sure i'll hack on it sooner than later :)
21:49:18 <mmorrow> @let foo = foo in foo
21:49:18 <lambdabot>   Parse error
21:49:30 <mmorrow> @let foo = foo
21:49:31 <lambdabot>  Defined.
21:49:34 <mmorrow> > foo
21:49:49 <lambdabot>   thread killed
21:49:55 <ushdf_> @let dothisthing = map (10 -)
21:49:57 <lambdabot>  Defined.
21:50:04 <ushdf_> > dothisthing [1..20]
21:50:06 <lambdabot>   [9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
21:50:29 <mmorrow> DONT do @undefine unless you /really/ mean it, because it clears /all/ the definitions
21:50:36 <mmorrow> :)
21:50:57 <ushdf_> that's why i name my functions and variables in the least sensible way
21:51:02 <ushdf_> so that i'll never have a collision
21:51:14 <ushdf_> like 'fedextruck' and 'inquisitivedog'
21:51:46 <mmorrow> bumblyBacterium?
21:51:52 <ushdf_> exactly
21:52:04 <ushdf_> the hardest part is explaining it to your boss
21:52:56 <sbahra> @let x x = x in x 1
21:52:56 <lambdabot>   Parse error
21:53:00 <sbahra> err
21:53:03 <sbahra> @let x x = x
21:53:04 <lambdabot>  Defined.
21:53:09 <sbahra> > x 1
21:53:10 <lambdabot>       Ambiguous occurrence `x'
21:53:10 <lambdabot>      It could refer to either `L.x', defined a...
21:53:21 <sbahra> Ok.
21:53:29 <sbahra> mmorrow, so I would do: @undefine x ?
21:53:46 <sbahra> @undefine x
21:53:58 <sbahra> > dothisthing [1 .. 20]
21:53:59 <lambdabot>   Not in scope: `dothisthing'
21:54:10 <sbahra> > foo
21:54:12 <lambdabot>   Not in scope: `foo'
21:54:20 <sbahra> Oh...
21:54:21 <sbahra> :(
21:54:38 <ushdf_> @let dothisthing = map (10 -)
21:54:40 <lambdabot>  Defined.
21:54:56 <ushdf_> dothisthing [1,100,1000..100000000000]
21:55:10 <ushdf_> > dothisthing [1,100,1000..100000000000]
21:55:10 <sbahra> ushdf_, > dothisthing ...
21:55:11 <lambdabot>   <no location info>: parse error on input `..'
21:55:22 <ushdf_> > dothisthing [1,100,1000..1000000000]
21:55:23 <lambdabot>   <no location info>: parse error on input `..'
21:55:35 <ushdf_> how do i make that list work
21:56:07 <Giraffe> > dothisthing [1,10,100..100000000000]
21:56:08 <lambdabot>   <no location info>: parse error on input `..'
21:56:15 <sbahra> Use set builder.
21:56:25 <sbahra> or whatever the proper name is.
21:56:54 <mmorrow> sbahra: haha, that's how i found out how @undefine works the first time too
21:57:41 <sbahra> ushdf_,
21:57:55 <sbahra> > [1, 10 .. 100]
21:57:56 <lambdabot>   [1,10,19,28,37,46,55,64,73,82,91,100]
21:58:26 <sbahra> > [1, 10, 19 .. 100]
21:58:27 <lambdabot>   <no location info>: parse error on input `..'
21:58:33 <sbahra> ushdf_, see?
21:59:47 <ushdf_> yes sir
21:59:52 <ushdf_> > dothisthing [1,100,1000 .. 1000000000]
21:59:54 <lambdabot>   <no location info>: parse error on input `..'
22:00:05 <ushdf_> > dothisthing [1, 100, 1000 .. 1000000000]
22:00:06 <lambdabot>   <no location info>: parse error on input `..'
22:00:11 <ushdf_> > dothisthing [1, 100, .. 1000000000]
22:00:13 <lambdabot>   <no location info>: parse error on input `..'
22:00:16 <ushdf_> > dothisthing [1, 100 .. 1000000000]
22:00:17 <lambdabot>   [9,-90,-189,-288,-387,-486,-585,-684,-783,-882,-981,-1080,-1179,-1278,-1377...
22:00:20 <ushdf_> ok
22:00:28 <ushdf_> not what was supposed to happen
22:00:50 <ushdf_> then again, i don't remember how i defined dothisthin
22:00:57 <ushdf_> > [1, 100 .. 1000000000]
22:00:59 <lambdabot>   [1,100,199,298,397,496,595,694,793,892,991,1090,1189,1288,1387,1486,1585,16...
22:05:11 <Giraffe> @src dothisthing
22:05:11 <ushdf_> black elvis
22:05:11 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:05:30 <Axman6> hmm, i'm working through the JSON stuff in RWH, and i'm stuck at the first exercise. mainly i don't know what its specifically asking for
22:08:06 <ushdf_> > "hel" ++ "lo"
22:08:07 <lambdabot>   "hello"
22:08:33 <ushdf_> hm
22:08:37 <ushdf_> > dothisthing "hello"
22:08:38 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Char'
22:08:46 <ushdf_> how do i do rot(x)
22:09:05 <Axman6> look into chr and ord
22:09:29 <Axman6> in Data.Chat
22:09:31 <ushdf_> > chr 0
22:09:33 <lambdabot>   '\NUL'
22:09:34 <Axman6> Char*
22:09:37 <ushdf_> >chr 97
22:09:41 <ushdf_> > chr 97
22:09:43 <lambdabot>   'a'
22:09:49 <ushdf_> :D
22:10:25 <Axman6> > ord 'a'
22:10:26 <lambdabot>   97
22:10:31 <ushdf_> > map (\x->ord x) "hello"
22:10:32 <lambdabot>   [104,101,108,108,111]
22:10:37 <ushdf_> beautiful
22:10:46 <Axman6> ushdf_: map ord is the same thing
22:10:52 <ushdf_> even better
22:10:54 <Axman6> > map ord "hello"
22:10:55 <lambdabot>   [104,101,108,108,111]
22:11:23 <Axman6> @check (ord.chr) == id
22:11:24 <lambdabot>       No instance for (Eq (Int -> Int))
22:11:24 <lambdabot>        arising from a use of `==' at ...
22:11:27 <hackage> Uploaded to hackage: reactive-fieldtrip 0.0.5
22:11:27 <hackage> Uploaded to hackage: reactive 0.9.5
22:11:36 <Axman6> @check (chr.ord) == id
22:11:38 <lambdabot>       No instance for (Eq (Char -> Char))
22:11:38 <lambdabot>        arising from a use of `==' a...
22:12:07 <Axman6> @check f x =  (chr (ord x)) == id x
22:12:08 <lambdabot>   Parse error at "=" (column 5)
22:12:15 <Axman6> @help check
22:12:15 <lambdabot> check <expr>
22:12:15 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
22:12:26 <ushdf_> > map toEnum "hello"
22:12:27 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
22:12:30 <Raevel> haha, funny help message
22:12:33 <ushdf_> > map fromEnum "hello"
22:12:34 <lambdabot>   [104,101,108,108,111]
22:12:44 <ushdf_> that's faster, right?
22:13:02 <Axman6> @src ord
22:13:03 <lambdabot> Source not found. Maybe you made a typo?
22:13:06 <Axman6> bah
22:13:34 <Axman6> they're probably the same thing
22:13:41 <ushdf_> ord is restricted to char
22:13:47 <ushdf_> so does that mean it checks first
22:13:58 <Axman6> the compiler checks at compile time
22:14:06 <Axman6> :t chr
22:14:07 <ushdf_> what a great language
22:14:08 <lambdabot> Int -> Char
22:14:12 <Axman6> :t fromEnum
22:14:13 <lambdabot> forall a. (Enum a) => a -> Int
22:14:19 <Axman6> :t ord
22:14:21 <lambdabot> Char -> Int
22:14:42 <Axman6> ord is probably just: ord :: Char -> Int; ord = fromEnum
22:15:53 <ushdf_> gotcha
22:16:33 <ushdf_> :t "music is math"
22:16:34 <lambdabot> [Char]
22:16:55 <ushdf_> all of a sudden computers seem really simple
22:17:02 <Axman6> they are
22:18:38 <ushdf_> but the fact that everyone else thinks they're not
22:18:41 <ushdf_> works strongly to our advantage ;)
22:19:15 <Axman6> really, they are extremely complex, but you just don't have to treat them as such
22:19:32 <ushdf_> their functionality only arises out of immediate necessity
22:19:38 <ushdf_> like a bicycle
22:19:50 <ushdf_> and monads are like the little bells
22:20:07 <Axman6> monads are far more useful than little bells ;)
22:20:10 <ushdf_> or the tires
22:20:15 <ushdf_> or the seat?
22:20:40 <Axman6> monads don't have a good real world analogue
22:20:40 <vegai> monads make the world turn around
22:21:09 <Axman6> so.. uh.. monads are more like gravity
22:21:14 <Axman6> yeah, that'll do
22:21:25 <ushdf_> the world doesn't turn
22:21:28 <ushdf_> without a frame of reference
22:22:02 <Axman6> most people choose not to take a self centred frame of reference ;)
22:22:30 <povman> Lemmih: interestingly enough, pygame on mac os x actually has a python version of the SDLmain.m main()
22:23:36 <povman> Lemmih: which is why pygame on mac doesn't require hacks
22:24:36 <ushdf_> i don't take one of those
22:24:39 <ushdf_> but i am taking tryptamines
22:25:48 <ushdf_> i want to puke a pitch black rainbow to the sun
22:25:50 <ushdf_> to put it out
22:27:00 <Guest23312> would anyone mind having a look at http://hpaste.org/12457 and seeing if you can spot anything in greedyCross that would yield the stack overflows I'm seeing?
22:27:45 <thoughtpolice> travisbrady: you need to make greedyCross strict in 'acc'
22:28:04 <travisbrady> thoughtpolice: just add a ! ?
22:28:28 <thoughtpolice> travisbrady: essentially, every time you loop inside greedyCross and you add something onto the accumulator (by whatever means,) every time you do this, you are creating a new thunk to be evaluated
22:28:52 <thoughtpolice> so when you try to evaluate the result of greedyCross, you end up evaluating tons and tons of thunks
22:28:55 <thoughtpolice> which blows the stack
22:29:06 <thoughtpolice> travisbrady: yes, you will also need the BangPatterns extension
22:29:22 <thoughtpolice> travisbrady: just be sure to stick the '!' in front of acc in all cases of greedyCross
22:29:29 <Axman6> i'd move acc to be the last element, and use $!
22:29:41 <ushdf_> what's a simple haskell 3d game i can see
22:29:44 <thoughtpolice> you can do either
22:29:46 <ushdf_> not frag
22:30:19 <thoughtpolice> bang patterns are very low-overhead, syntactically speaking, but $! would work just as fine
22:31:40 <travisbrady> thoughtpolice: oh i can use $! instead of -XBangPatterns or the pragma?
22:32:01 <dons> ushdf_: there are simple ones on hackage
22:32:09 <dons> little opengl things
22:32:15 <thoughtpolice> travisbrady: yes, but like Axman6 said you will need to make acc the last parameter and do 'greedyCross ... = greedyCross ... $! acc
22:33:43 <ushdf_> fungen eh
22:34:03 <thoughtpolice> travisbrady: a good way to look for optimizations like this that GHC might miss is to think of the actual definition of a 'strict' function - a function f is strict if, for an input of _|_ (undefined,) the result is also undefined. if you look at the definition of greedyCross, it becomes apparent that greedyCross is strict in 'acc' - if you were to call greedyCross and instead of passing an actual value for acc you 
22:34:16 <thoughtpolice> so by definition, greedyCross is strict in the acc parameter
22:35:11 <shapr> and instead of passing an actual value for acc you  ... what?
22:35:35 <thoughtpolice> you pass undefined
22:35:39 <shapr> oh
22:35:41 <thoughtpolice> that is, instead of doing:
22:35:41 <thoughtpolice> let kid = greedyCross chooser mom dad [] mom
22:35:49 <thoughtpolice> you were to do:
22:35:50 <thoughtpolice> let kid = greedyCross chooser mom dad undefined mom
22:37:06 <thoughtpolice> if you do the latter, you can obviously see the overall result of greedyCross is going to be undefined, because of this clause: greedyCross _ _ _ acc [] = acc
22:37:11 <travisbrady> if i'm using $! should i be prepending that to every instance of acc as a parameter?
22:37:22 <thoughtpolice> so by definition you know that greedyCross is strict in the acc parameter
22:37:40 <thoughtpolice> travisbrady: that make sense at all? (it's late here...)
22:38:33 <thoughtpolice> travisbrady: no, $! is identical to $, only it is strict in the second argument
22:38:35 <thoughtpolice> @src ($!)
22:38:35 <lambdabot> f $! x = x `seq` f x
22:38:53 <travisbrady> thoughtpolice: i'm not certain i get it actually, what is undefined?
22:39:05 <erikc> o, is that bang pattern stuff new to ghc 6.10?
22:39:15 <thoughtpolice> travisbrady: just what it sounds like - undefined (try opening ghci and just type 'undefined' and see the output)
22:39:23 <thoughtpolice> erikc: no, it's been around since at least ghc 6.6
22:40:13 <erikc> wow, totally missed that, i was still doing the seq seq seq trick
22:40:14 <travisbrady> huh, i'd never come across it
22:40:33 <thoughtpolice> erikc: they're a very nice, low-syntax-overhead extension.
22:40:51 <erikc> indeed
22:41:17 <travisbrady> hmmm...can't get this to parse
22:43:12 <travisbrady> thoughtpolice: am i doing this correctly? http://hpaste.org/12457#a1
22:44:22 <travisbrady> ahh, wait, part of that was a parse problem with \\
22:45:14 <travisbrady> yaaaaay, it worked
22:45:20 <travisbrady> thoughtpolice: thank you for your help
22:46:13 <travisbrady> hmm, it works with just ! but not with $!, i must be missing something
22:46:31 <Axman6> :t ($!)
22:46:33 <lambdabot> forall a b. (a -> b) -> a -> b
22:46:43 <Axman6> @src ($!)
22:46:43 <travisbrady> :t (!)
22:46:43 <lambdabot> f $! x = x `seq` f x
22:46:44 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
22:47:00 <Axman6> ! isn't a function when used in bang patterns
22:47:13 <Axman6> does the definition of $! help you understand?
22:47:34 <travisbrady> Axman6: no unfortunately
22:47:49 <Axman6> ! and ($!) do the same thing, but one's syntax, one's a function
22:47:50 <ushdf_> > const1 100
22:47:51 <lambdabot>   Not in scope: `const1'
22:48:00 <Axman6> you need to do soething like f a b c $! acc
22:48:26 <travisbrady> ohhhhh, ok
22:48:39 <travisbrady> $! is not easy to google
22:48:39 <Axman6> or, f a b c acc = f a b c $! a:b:c:acc
22:48:56 <ushdf_> my cat is l33t hx00r0rs, scsi 50 pin
22:49:41 <thoughtpolice> anyway
22:49:42 <thoughtpolice> bed time
22:49:51 <travisbrady> oh ok, so I can think of $! as being the strict $
22:49:58 <ddarius> f a b c $! a:b:c:acc === f a b c (a:b:c:acc)
22:50:16 <MikeMayer> I'm confused with syntax again... http://hpaste.org/12458
22:50:17 <MikeMayer> :(
22:50:39 <travisbrady> btw, what do Haskellers call the stuff after the name of a function but before the =, param list?
22:51:40 <Centrinia> The pattern?
22:52:17 <Lemmih> MikeMayer: commaSeparate a = concat (intersperse ", " a)
22:52:59 <Lemmih> MikeMayer: Or, if you have a newer GHC: intercalate ", " a
22:53:16 <sjanssen> travisbrady: technically, they're called "patterns"
22:53:44 <Centrinia> join . (,) intersperse
22:54:06 <travisbrady> sjanssen: ahh, thank you, i'd thought that would be reserved for instances where i was matching ala "func (Just blah) = blah * 10"
22:54:19 <MikeMayer> Lemmih:  I see... thanks I'm starting to get this :)
22:54:52 <sjanssen> travisbrady: well, even plain old variables are patterns too :)
22:55:31 <sjanssen> travisbrady: I generally call them either variables or patterns, whichever seems to match the situation best
22:55:47 <sjanssen> or arguments, perhaps
23:02:50 <ushdf_> who wants to help me write a 3d engine ;)
23:02:58 <ushdf_> because i have no goddamn idea how to do that in haskell
23:03:31 <Elly> do you know how to do it in any language?
23:03:39 <ushdf_> yes
23:03:58 <ushdf_> i could do it in C with some effort
23:04:12 <orbitz> do you know haskell?
23:04:27 <ushdf_> i'm like 70% over the basics
23:04:29 <ushdf_> maybe
23:05:17 <orbitz> maybe if you are more confident in haskell you'd be able to write a 3d engine with some effort
23:05:27 <ushdf_> yes, i would think
23:05:44 <orbitz> try out the multimedia haskell book?
23:05:54 <ushdf_> no money
23:05:58 <povman> ushdf_: opengl in haskell is pretty simple
23:06:36 <orbitz> it's a pretty cheap book
23:06:45 <ushdf_> not cheap enough
23:08:28 <Axman6> well... find something else to make, or use the other projects that are out there already, like HGL or something
23:08:43 <ushdf_> http://www.haskell.org/haskellwiki/OpenGLTutorial1
23:08:44 <lambdabot> Title: OpenGLTutorial1 - HaskellWiki
23:08:45 <ushdf_> :D
23:08:49 <dons> http://www.reddit.com/r/haskell/comments/7g4vw/haskell_communities_and_activities_report/
23:08:55 <lambdabot> Title: Haskell Communities and Activities Report: November 2008 : haskell, http://tinyurl.com/5vt6dj
23:09:13 <dons> i'm of the opinion the HCAR should be prepared on a wiki, instead of editing attachments to send to a master collator
23:09:19 <dons> kosmikus: what do you think?
23:09:34 <dons> imagine the draft hcar on a wiki, and users/authors go in and edit their paragraph
23:09:43 <dons> no more editor bottleneck, bar for clean ups at the end
23:10:42 <dons> its interesting. we're getting more effective at keeping the community up to date. how should the hcar integrate what's been happening on blogs, hackage, commercially. mmm.
23:13:30 <Axman6> dons: seems to me there's a few too many weekly/monthly newsletters. having just one weekly one would be excelent
23:14:53 <dons> there's one weekly. one 6 monthly (with editorial oversight), and TMR, a thrice yearly?
23:14:56 <kosmikus> dons: when I was editor, it was suggested a couple of times to *replace* the HCAR with a wiki. I have always opposed that.
23:15:10 <dons> no, i wouldn't replace it.
23:15:11 <kosmikus> dons: using a wiki as a tool might work though.
23:15:18 <dons> but like RWH, use a wiki-like system to prepare it
23:15:46 <dons> imagine if each section here was individually edited, http://www.haskell.org/communities/11-2008/html/report.html
23:15:46 <lambdabot> Title: Haskell Communities and Activities Report
23:15:51 <kosmikus> dons: I guess it depends on how much work it would be for Janis to adapt the process.
23:15:54 <dons> so the same process is in place: you tell authors to update their link.
23:16:13 <dons> but the authors no longer need to go through the save email, edit, send back, collate process
23:16:45 <dons> i think the HCAR is still important though -- there's a lot of quiet people we only hear from in the HCAR
23:17:03 <kosmikus> yes
23:17:12 <kosmikus> that was my experience
23:17:15 <dons> oh... is this the first time Clean's stauts has appeared in the HCAR?
23:17:22 <kosmikus> yes
23:17:24 <dons> does that mean we've won in the end? :)
23:17:51 <kosmikus> I wouldn't jump to conclusions ;)
23:17:59 <dons> yes, so just like the community as a whole has grown, it seems the quiet groups that appear in the HCAR have also grown
23:18:35 <dons> i'll main janis with some ideas and offers to help.
23:18:46 <kosmikus> so, is the system you use for RWH available for use?
23:18:49 <dons> for example, i suspect there's a way to integrate "5.3  Auxiliary Libraries" with hackage
23:18:53 <dons> kosmikus: yes.
23:18:58 <dons> if that would work.
23:19:05 <dons> or we could use gitit, or one of the other haskell wikis
23:19:09 <kosmikus> and what format is the actual text maintained in?
23:19:19 <dons> could be anything.
23:19:32 <dons> pandoc would let us process wiki/tex/html/...
23:19:37 <kosmikus> right
23:20:03 <dons> i'm keen on "domain specific wikis" at the moment. where the editing is tuned for the local work flows
23:20:14 <kosmikus> everyone seems to be :)
23:20:26 <kosmikus> we have a few students working in the area as well
23:20:29 <dons> and it seems like this is an example where we could apply say, ideas from RWH and maybe use gitit/pandoc as the base
23:20:32 <dons> oh, interesting.
23:20:43 <ushdf_> installing cabal gives me 'could not find module system.directory'
23:20:47 <kosmikus> there's going to be another Haskell wiki on Hackage soon
23:20:51 <dons> ushdf_: in the directory package
23:21:03 <dons> kosmikus: do you know about some of galois projects in this area?
23:21:07 * ushdf_ whistles
23:21:17 <ushdf_> somebody put that on yaourt :D
23:21:25 <dons> ushdf_: should come with ghc.
23:21:32 <kosmikus> dons: no
23:21:39 * ksf wants to overload ; in c++
23:21:59 <dons> kosmikus: i'll mail you offline. we've been doing a /lot/ of stuff in this area over the last few years.
23:22:06 <ushdf_> i have ghc ;(
23:22:08 <ksf> actually, i want to overload ",", too.
23:22:18 <dons> ushdf_: ghc-pkg list
23:22:22 <dons> should show the 'directory' package
23:22:24 <erikc> @seen dcoutts
23:22:24 <lambdabot> dcoutts is in #haskell, #haskell-soc, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I don't know when dcoutts last spoke.
23:22:51 <ushdf_> directory-1.0.0.0
23:22:53 <ushdf_> >:O
23:25:02 <ksf> Is there _any_ way to get type interference in c++?
23:25:15 <ksf> like, coding HM in templates?
23:27:44 <erikc> ksf: c++0x will have inferencing of lvalues from rvalues with the 'auto' keyword, you can also do some simple inferencing with template partial specialization
23:27:54 <MikeMayer> I have to say--- the assistance from this channel plus http://learnyouahaskell.com/ has been great
23:27:55 <MikeMayer> thanks
23:27:56 <erikc> e.g. you can make a map that inferences the return type based on the function
23:28:01 <lambdabot> Title: Learn You a Haskell for Great Good!
23:28:30 <Axman6> MikeMayer: i recommend this channel as the single best place to learn haskell once you've got some basics down
23:28:53 <erikc> template <typename T, typename R> std::vector<R> map(const std::vector<T>&, R (*)(const T&));
23:30:41 <dancor> what is the right way to combine correctNumMap and totalAskedMap into ratioCorrectMap?  Map.unionWith (/) would work except that not all keys appear in correctNumMap
23:31:21 <dancor> i want 0's for rationCorrectMap for those keys..
23:32:09 <ushdf_> i may not know haskell that well
23:32:16 <ushdf_> but i can make trippy-ass folk music
23:32:51 <dancor> using Haskore? ;)
23:33:19 <ushdf_> i use granular synth and a gitbox
23:33:32 <ushdf_> and these old-fashioned lungs
23:35:41 <dancor> i could use crazy Maybe's for my Map problem, but it seems like there is something better?
23:37:32 <dancor> i could fill in the zeros in correctNumMap..
23:37:42 <dancor> i want something weirdly between union and intersection..
23:37:59 <Trinithis> @src group
23:37:59 <lambdabot> group = groupBy (==)
23:38:02 <Trinithis> @src groupBy
23:38:03 <lambdabot> groupBy _  []       =  []
23:38:03 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
23:38:03 <lambdabot>     where (ys,zs) = span (eq x) xs
23:39:03 <dancor> ok, i'll zero out the total map, union with the correct map.  and then divide that by the total map
23:39:06 <dancor> voila
23:39:21 <dancor> no idea if that will be most efficient for my giant maps
23:42:11 <vegai> so, am I talking out of my backside here: http://www.reddit.com/r/programming/comments/7fznh/software_transactional_memory_why_is_it_only_a/c06kb8m
23:42:13 <lambdabot> Title: vegai comments on Software Transactional Memory: why is it only a research toy?, http://tinyurl.com/5u3gc5
23:42:27 <vegai> grauenwolf already noted a mistake. Anything else?
23:42:42 <erikc> ksf: on overloading ;, you can overload >>= and use template expressions to build up closures and get 'monads'
23:43:52 <cads> vegai, I read that article too and it seemed like that guy just had a bunch of holy flame to rain down on an otherwise interesting seeming concept
23:44:31 <vegai> yeah, I read the acm bit too
23:44:43 <dons> http://www.haskell.org/communities/11-2008/html/report.html#sect7.7
23:44:44 <lambdabot> Title: Haskell Communities and Activities Report, http://tinyurl.com/6f36nz
23:44:45 <dons> very interesting
23:44:48 <vegai> is it weird that they don't even hint at haskell's STM?
23:44:54 <dons> EU bus timetables are checked with Haskell
23:45:05 <dons> vegai: i think its weird, yes.
23:45:29 <cads> I don't remember if gave any alternative as to what he thinks we should use to help with concurrency (tiny gnomes operating mutex locks, I say)
23:46:00 <dons> we should flood the author with emails about his glaring omission
23:46:19 <vegai> withFantasy $ Perhaps the depression will bring all silly Cobol & Java shops down to their knees and new Haskell shops will replace them
23:47:13 <dons> unsafePerformThisIsRealityNow
23:47:19 <dons> ... did that work?
23:48:00 <dons> maybe HCAR is so big now, it needs more people working on it.
23:48:25 <dons> all the industry wiki page people should be in there, imo. but that means someone tracking the non-email-based community
23:48:51 <cads> vegai, as to him not mentioning haskell... I think he's a java researcher
23:49:23 <dons> yeah, but he cites people who did write haskell papers
23:49:43 <dons> he just doesn't seem to have made the connection: stm -> in haskell -> in ghc -> used in production. /not a toy/
23:49:56 <dons> clearly we're not talking to the right people
23:50:08 <vegai> or perhaps we're reading the wrong people :P
23:50:10 <dons> next time you meet a java programmer, let them know: we have stm, we have multicore. where are they at?
23:50:23 <dibblego> I find it amazing that grauenwolf said something not unintelligent
23:50:31 <vegai> if they're fast, they might point at Clojure
23:51:04 <cads> clojure is a counterpoint I was thinking of when I read the paper
23:51:21 <cads> but I haven't heard of it being used in production yet
23:52:02 <dons> dibblego: well, he still suggested the compositionality was .. suspect.
23:52:17 <cads> his whole point though is that STM introduces too much complexity, and I couldn't determine what he was comparing to
23:52:19 <dons> clojure is another toy lisp for now.
23:52:23 <dibblego> oh yes, he is still a perfect example of an idiot
23:52:29 <dons> heh
23:52:33 <vegai> I wonder how I could change my test so that the Chan and TChan code would be equivalent but so that the TChan code suffers from transaction retries more
23:54:18 <vegai> should the reader process do something more complex than a single read as well?
23:54:32 <vegai> I'll paste the code I have now
23:54:35 <erikc> i dunno, the determinism issues of STM do worry me a bit
23:55:00 <Axman6> do determinism and concurrency go well together?
23:55:00 <erikc> are there tools to replay computations in a recorded order or some such
23:55:09 <vegai> however, the last time I tried to make it a bit more complex, it didn't affect the throughput at all
23:55:17 <dons> kosmikus: so my proposal would be to take the current source. put it into mediawiki to start with. with per-paragraph editing. and a script to extract the pdf and html versions.
23:55:18 <erikc> axman6: they can, data parallelism is quite deterministic
23:55:39 <vegai> The Great Language Shootout should have a transaction memory benchmark
23:55:41 <Axman6> but that's more parallelism than concurrency
23:56:25 <vegai> btw, are the next CUPF/ICFP locations decided?
23:56:50 <kosmikus> dons: well, I encourage you to suggest that to Janis. but I'll support him in whatever his reaction is. because I think it's much more important to have a reliable person as an editor than to have the interactivity of a Wiki.
23:56:56 <vegai> whoa, Scotland?
23:56:58 <kosmikus> vegai: Edinburgh.
23:57:12 <vegai> yay, I could actually go there.
23:57:26 <vegai> gotta start softening boss&family.
23:57:37 <erikc> sure, i guess im picturing something like a game, where you run 100 ai agents concurrently, they examine the world and move themselves
23:58:30 <dons> kosmikus: yes, the editor would track commits. my concern is that as the community is growing, we're missing lots of groups/devs/events and activities, simply because they're not on email anymore.
23:58:30 <erikc> and depending on order of transactions, you wind up with vastly different results
23:58:58 <dons> the wiki would only serve as a drafting mechanism. not the means of publicatoin
23:59:15 <erikc> now maybe thats just not an area to apply STM, but the way STM is being pitched makes it sound like that what it would be for
23:59:17 <dons> but one without any bottlenecks, using  the web instead of email, and cheaper to contribute to.
23:59:43 <sjanssen> would the HCAR work better as a darcs repo?
