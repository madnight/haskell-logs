00:06:27 <Taejo> > [1..] ++ []
00:06:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:06:40 <Taejo> > [1..] ++ [1]
00:06:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:09:28 <Axman6> > head $! [1..]
00:09:29 <lambdabot>   1
00:09:45 <dmwit_> Surprise!
00:10:10 <Axman6> seq takes its first argument to whnf?
00:10:40 <dons> yup.
00:10:45 <hackage> Uploaded to hackage: xosd 0.1
00:11:00 <dons> yay new libraries, on demand.
00:12:02 <dons> nice story. this guy asked if there were xosd bindings, http://www.haskell.org/pipermail/haskell/2008-November/020796.html  so i wrote him one :-) i wonder what impression of haskell that will give.
00:12:06 <lambdabot> Title: [Haskell] XOSD x Haskell, http://tinyurl.com/6gjf2p
00:17:23 <Taejo> @pl \ind -> ((), f ind, [])
00:17:23 <lambdabot> flip ((,,) () . f) []
00:19:25 <ivanm> dons: so someone just has to ask on the mailing list for a haskell library, and you'll come out with a prototype the next day? :o
00:19:33 * ivanm thinks of the possibilities...
00:19:36 <ivanm> ;-)
00:19:49 <dons> that's how it works. yes.
00:19:55 <dons> actually, i thought xosd would be useful for xmonad.
00:20:02 <dons> which got me innerested.
00:20:26 <dons> like that http://www.haskell.org/pipermail/xmonad/2008-November/006702.html
00:20:27 <lambdabot> Title: [xmonad] using xosd to indicate screen focus
00:21:50 <ivanm> dons: oh, wait, you're now restricting your offer only for those libs that you yourself find interesting/useful?
00:22:04 * ivanm stops trying to think of a ridiculous lib to request
00:22:21 <dons> heh. and ones preferrably doable in an hour before bedtime.
00:22:33 <ivanm> _even more_ restrictions! :o
00:23:01 <dons> ok. so just this one library.
00:28:05 <Taejo> :t (>>=)
00:28:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:46:14 <Baughn> @pl if'(magnitude(iterate(\z->z*z+(x:+0)/48+(y:+0)/(0:+24))0!!99)<=2)'#' ' '
00:46:15 <lambdabot> if' (magnitude (iterate (((y :+ 0 / 0 :+ 24 + x :+ 0 / 48) +) . join (*)) 0 !! 99) <= 2) '#' ' '
00:52:28 <BeelsebobWork> Cale, or someone with privs on lambdabot, could you get her to join #macosxdev please?
00:52:57 <sciolizer> lambdabot's a she?
00:53:00 <sciolizer> :t lambdabot
00:53:00 <lambdabot> Not in scope: `lambdabot'
00:53:07 <sciolizer> godel error, no doubt
00:53:42 <BeelsebobWork> @vixen a/s/l?
00:53:42 <lambdabot> 19/f/California
00:53:44 <BeelsebobWork> yes
00:54:39 <dons> @join #macosxdev
00:54:47 <dons> ?uptime
00:54:47 <lambdabot> uptime: 6h 20m 12s, longest uptime: 1m 10d 23h 44m 29s
00:54:51 <dons> good.
00:55:59 <BeelsebobWork> thanks dons (assuming that was you) :)
00:56:43 <BeelsebobWork> for anyone that cares -- we just set that channel up because #macdev has started setting a channel key and being elitist, so anyone who's interested in mac programming (including haskell) is welcome
01:10:47 <sciolizer> @instances Haskell-101
01:10:47 <lambdabot> Couldn't find class `Haskell-101'. Try @instances-importing
01:11:16 <opqdonut> :-D
01:18:45 <Peaker> if there's an    instance Monoid m => Monad (,) m where ....        are other 2-tuple-monad instances allowed, for other class contexts?  Or is the context for overlapping instances check?
01:19:15 <Peaker> Or is the context ignored for overlapping instances check, that is
01:25:38 <quicksilver> Peaker: contexts are ignored in every circumstance
01:25:47 <quicksilver> Peaker: the context is not part of the instance, really.
01:26:07 <Peaker> quicksilver: so I can write the instance without specifying the context at all?
01:26:36 <quicksilver> well, it means something in the methods ;)
01:26:45 <quicksilver> but it's not part of the instance selection algorithm.
01:26:55 <Peaker> ah
01:27:03 <Peaker> it probably also disallows using the instance if the context is wrong?
01:27:19 <quicksilver> in a sense.
01:27:24 <quicksilver> it doesn't really disallow using the instance
01:27:30 <quicksilver> it uses the instance, and adds the context
01:27:47 <quicksilver> if the context isn't satisfied you get a standard 'missing instance error'
01:27:58 <Peaker> okay
01:28:00 <quicksilver> but the missing instance error is for the context not the original class.
01:28:05 <Peaker> sounds reasonable ;)
01:28:35 <Peaker> quicksilver: did you get a chance to toy with reactive-fieldtrip?
01:28:56 * quicksilver shakes his head.
01:29:06 <Peaker> its pretty awesome and a lot of fun ;)
01:29:25 <quicksilver> does fieldtrip do anything apart from plotting surfaces?
01:30:05 <Peaker> from my understanding, it lets you build/combine 3d shapes functionally, and worries for you about generating the right amount of polygons for the render size, etc
01:30:19 <Peaker> also lets you compose transformations functionally, and apply them to the shapes
01:30:57 <quicksilver> well not to sound negative
01:31:07 <quicksilver> but composing transformations functionally isn't exactly hard :P
01:31:24 <quicksilver> and from the web page I looked it, it looked like its only primitive was a parametric surface
01:31:26 <Peaker> Maybe not, but having them use the OpenGL matrices might be, I don't know
01:31:32 <quicksilver> which isn't interesting to me at the moment.
01:31:43 <BeelsebobWork> quicksilver: there are other primitives
01:31:45 <BeelsebobWork> like obj model
01:31:54 <BeelsebobWork> (if you have the obj package installed)
01:31:58 <quicksilver> I asked you taht yesterday but you didn't answer ;)
01:32:01 <BeelsebobWork> (in fact, anything with a Renderable instance)
01:32:09 <BeelsebobWork> oh? sorry, I must have been afk
01:32:29 <quicksilver> that's fine ;)
01:33:12 <quicksilver> Peaker: it's cool but it's not really solving a problem I need to solve just now :)
01:33:29 <Peaker> quicksilver: fun toy though ;)
01:33:43 <quicksilver> BeelsebobWork: I was surprised by the choice of parametric surfaces, I thought they had quite bad topological properties
01:34:04 <BeelsebobWork> quicksilver: in all honesty, I have no idea -- def a question for conal
01:34:13 * quicksilver nods
01:34:28 <quicksilver> I did some toy experiments with implicit surfaces
01:34:33 <Peaker> weird, in my home computer(x86-64), ghc-pkg describe GLUT shows: ld-options: -lglut -lSM -lICE -lXmu -lXi -lGLU -lGL -lm        whereas in my work computer (x86-32), the GLUT package didn't have any ld-options set up, so it wouldn't link correctly
01:34:37 <quicksilver> on the other hand tesselatiing implicit surfaces is slow
01:34:40 <quicksilver> you can't win em all.
01:35:00 <BeelsebobWork> Peaker: I think a *lot* of people have been having problems with GLUT and 6.10
01:35:12 <Peaker> BeelsebobWork: do you know who writes the ld-options/how?
01:35:36 <BeelsebobWork> no idea -- I now that camio managed to solve the problems for himself and conal, so I'd ask him if I were you
01:35:53 <Peaker> I guess its a general ghc-pkg question, though
01:36:03 <Peaker> What goes into the ld-options of installed packages
01:36:20 <quicksilver> should be set by the cabal I believe
01:36:27 <quicksilver> but it's not a subject I understand well
01:37:47 <Peaker> maybe dcoutts knows
01:39:20 <Peaker> the .cabal file in GLUT doesn't specify any
01:40:24 <Peaker> for some reason OpenGL linkage doesn't use the ordinary dynamic library stuff, but a dynamic symbol lookup -- perhaps for dynamic capabilities, though that's quite a shitty way to implement that (and just dynamically fails instead of statically)
01:40:26 <quicksilver> I'm pretty sure dcoutts_ will know.
01:40:42 <Peaker> hehe, light the nick up
01:40:43 <quicksilver> openGL linkage uses a mixture of static and dynamic linkage.
01:40:50 <quicksilver> quite deliberately
01:40:58 <quicksilver> so you can write code which detects extensions at runtime
01:41:11 <Deewiant> FWIW this kind of stuff has never worked for me correctly out of the box, I've always had to mess with ld-options and/or extra-libraries and whatnot.
01:41:11 <quicksilver> and remains binary compatible with more-and-less-functional implementations.
01:41:22 <Deewiant> But I'm on Windows so I guess that's to be expected. ;-)
01:41:27 <quicksilver> Deewiant: until 6.10 GLUT came in the box :)
01:41:35 <quicksilver> so if you got the right box, it was easy.
01:41:41 <Deewiant> Well yeah, /that/ box worked. :-P
01:41:41 * quicksilver is still sad that it doesn't come in the 6.10 box.
01:42:10 <Peaker> quicksilver: then they should just use plugin/vtables probably
01:42:11 <Deewiant> What I meant was any library that depends on non-Haskell libraries which /wasn't/ distributed by the compiler. :-)
01:42:18 <Peaker> quicksilver: rather than the dynamic linkage mechanism..
01:42:36 <Deewiant> Updating regex-posix, building OpenGL, etc.
01:42:38 <Peaker> I end up just getting a runtime missing symbol/crash
01:42:47 <Deewiant> Always had to do a manual ghc-pkg update to get it to link properly.
01:42:59 <Peaker> Deewiant: it worked out of the box on my x86-64 machine and not so smoothly on x86-32
01:43:05 <Peaker> Deewiant: are you x86-32 or 64?
01:43:15 <Peaker> (maybe it is related)
01:43:15 <Deewiant> Peaker: I'm Windows + x86-32.
01:43:32 <Peaker> ah, both my machines are Ubuntu
01:43:54 <quicksilver> Peaker: I don't think I understand your point.
01:44:04 <quicksilver> Peaker: what's a vtable (other than a C++ implementation technique)?
01:44:08 <Axman6> hmm, where's CReal again?
01:44:23 <Axman6> specificall t what do i need to install with cabal to get it?
01:44:25 <Deewiant> package 'numbers' IIRC
01:44:38 <Axman6> ah, missed the s :)
01:44:39 <Deewiant> if not that, use Hayoo! to find out.
01:45:23 <Taejo> @ty foldl
01:45:24 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:45:30 <Peaker> quicksilver: basically a normal language-level table of function pointers, rather than a dynamic-linkage-level table of function pointers
01:46:07 <quicksilver> Peaker: yes, that is indeed what it does.
01:47:04 <Peaker> quicksilver: it uses dlsym/etc, not "language-level". Language-level would mean its a normal API exported by the package
01:47:29 <bastl> Hi all, im looking for a java parser written in haskell but cant find _anything_ on the net. Has anyone an idea where to look?
01:47:36 <Peaker> less platform-dependent and probably simpler, doesn't use obscure mechanisms so probably less prone to error
01:48:58 <quicksilver> Peaker: ok, now I have no idea what you're talking about.
01:49:07 <quicksilver> I'm talking about opengl, the cross-platform API.
01:49:49 <quicksilver> opengl, the cross-platform API, uses the system of having an understood lowest common denominator ABI, and then a bunch of function pointers which you access by standard language level calls.
01:49:53 <Peaker> quicksilver: I think that OpenGL isn't just a nice API you can use, that happens to include some function ptr lookup functions, but instead you're supposed to use dlsym and other platform-dependent hacks to use its extensions. But I'm not sure
01:50:03 <quicksilver> you're wrong.
01:50:26 <quicksilver> it's true that the function ptr lookup functions are platform specific instead of independent, which is a shame.
01:50:31 <Taejo> bastl: I don't know of one, but if you end up writing one then I'm sure others would find it useful
01:50:33 <Peaker> quicksilver: ok, then why does the GLUT using code fail to link at runtime, if -lglut is not specified?
01:50:40 <quicksilver> but they are still basically pointer lookup functions.
01:51:06 <quicksilver> Peaker: that sounds like a detail of how GHC does package loading to me.
01:51:46 <quicksilver> it's certainly not how a plain C glut program behaved.
01:51:51 <bastl> Taejo: yeah, that's obvious. And thats the reason why i expect that someone did something already ... ;-)
01:52:07 <jeffz> bastl: not sure what condition this is in, but it's all I can see: http://pdos.csail.mit.edu/~baford/packrat/thesis/
01:52:08 <lambdabot> Title: Packrat Parsing: a Practical Linear-Time Algorithm with Backtracking
01:53:55 <Taejo> is it considered to use both mapM and forM?
01:54:02 <quicksilver> I use them both
01:54:08 <quicksilver> whichever reads better.
01:54:10 <Taejo> ok
01:54:13 <quicksilver> OMG what a hideous idea : http://www.whatwg.org/specs/web-workers/current-work/
01:54:24 <lambdabot> Title: Web Workers
01:54:31 <quicksilver> multithreaded javascript with a designed-by-committee message passing API
01:54:35 <quicksilver> that's going to work well :P
01:54:43 <Axman6> heh
01:55:18 <Taejo> quicksilver: Haskell was designed by committee
01:55:35 <Axman6> i'm still waiting to hear "OS X 10.7, the world's first OS written in javascript. 25% faster than 10.6"
01:56:04 <Badger> :D
01:56:44 <Axman6> the way squirrelfish is going... it's heading that way :|
01:56:49 <Taejo> @undo do { indent; x <- a; dedent }
01:56:50 <quicksilver> Taejo: no, it was formalised by a committee
01:56:50 <lambdabot> indent >> a >>= \ x -> dedent
01:57:03 <Taejo> @undo do { indent; x <- a; dedent; return x }
01:57:04 <lambdabot> indent >> a >>= \ x -> dedent >> return x
01:57:05 <quicksilver> Taejo: having evolved gradually over many years by some extremely smart people.
01:57:23 <quicksilver> Taejo: but, the haskell committee was also a particularly smart one :)
01:58:43 <Taejo> quicksilver: they sure were smart. So what was the design process? Somebody came up with the language and then a committee approved it? Or the committee just said "We'll have a king-size-Miranda with extra typeclasses"?
01:59:25 <a> I see most of the team were CompSci academics, what made them any smarter than other CS academics?
01:59:35 <Botje> Taejo: do you want fries with that?
01:59:51 <Axman6> a: the proof's i the pudding...
02:00:04 <a> True.
02:00:11 <Botje> two of them were named simon
02:00:15 <Botje> simons are very smart people :p
02:00:18 <a> Haha
02:00:20 <Axman6> it's true
02:01:20 <Taejo> Botje: hold the fries, I'm on diet. I'll have the monadic IO instead.
02:03:52 <Taejo> I <3 monads
02:04:11 <Peaker> I have a smart friend called Simon too, heh
02:04:27 <Taejo> am I evil for writing my own instead of using a ReaderT WriterT StateT Indentity?
02:05:14 <profmakx> i would call that "not lazy enough" Taejo
02:05:27 <Axman6> my maths tutor was caled simon, and he's just finished his thesis
02:05:28 <profmakx> and not lazy enough is a serious issue for haskell programmers!
02:05:37 <a> Could somebody define a 'Monad' in a sentence?  The only explanations I've seen have been long, and I've been confuzzled by the time I get to the end of them :-)
02:06:08 <Axman6> a: well, they're kinda hard to explain simply imo, but once you get them, you think "huh... is that it?"
02:06:33 <quicksilver> Taejo: the committee was much later.
02:06:41 <profmakx> an endofunctor with two natural transformations
02:06:49 <a> Axman6: ha, gotcha.  Many hard-to-explain things are like that.
02:06:55 <mapreduce> a: This might be the simplest explanation:
02:06:55 <quicksilver> Taejo: miranda and then gopher and then early haskell versions laid out the ground work.
02:06:57 <mapreduce> @src Monad
02:06:57 <lambdabot> class  Monad m  where
02:06:57 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
02:06:57 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
02:06:57 <lambdabot>     return      :: a -> m a
02:06:57 <lambdabot>     fail        :: String -> m a
02:07:13 <mapreduce> (it's arguable that fail is a bad name)
02:07:14 <quicksilver> Taejo: I don't know the exact timeline, augustss would probably remember it better :)
02:07:25 <Axman6> @src [] fail
02:07:26 <lambdabot> fail _      = []
02:07:30 <Axman6> hmm, ok
02:07:33 <jsn> a: a monad allows you to put and object into a container, and to put operations on objects of that type into the container with it, to operate on it
02:07:37 <profmakx> I "got" monads by staring at the definition and making up examples
02:07:38 <Axman6> @src Either fail
02:07:38 <lambdabot> fail msg      = Left (strMsg msg)
02:07:43 <profmakx> but that might not work for others
02:07:58 <jsn> a: a monad does not necessarily offer a way to take that object back out of the container, though
02:08:03 <Peaker> I think it might make more sense to teach Functor, then its limitations, then Applicative, then its limitations, then Monad
02:08:07 <Axman6> a: do you want to learn about them? if so, i have an excellent link
02:08:14 <a> Please :)
02:08:33 <Axman6> do you know about >>= for things like lists and Maybe?
02:08:36 <jsn> mapreduce: it's my understanding that fail just does not belong in monad
02:09:13 <jsn> mapreduce: however, that is gossip, i have never really seen the argument against it
02:09:47 <quicksilver> argument: there is no fail instance for Reader
02:09:49 <Axman6> a: http://blog.tmorris.net/20-intermediate-haskell-exercises/ -- you go through implimenting return, fmap, >>=, and some others on some of the common monads, without using their normal names
02:09:51 <quicksilver> (end of argument, QED)
02:09:53 <lambdabot> Title: λ Tony’s blog λ » Blog Archive » 20 Intermediate Haskell Exercises
02:10:30 <Taejo> jsn: one argument is that not everything which should be a monad (i.e. it's categorically a monad) has a sensible fail
02:10:51 <Taejo> @src Writer fail
02:10:51 <lambdabot> Source not found. That's something I cannot allow to happen.
02:11:59 <Taejo> jsn: Writer doesn't define fail
02:12:08 <jsn> Taejo: as i understand that, there is no way to derive fail from the categorical definition in general
02:12:21 <aeolist> is hood dead?
02:12:22 <Peaker> can class aliases be implemented with TH?
02:12:26 <aeolist> am i forced to work with hat instead?
02:12:40 <Taejo> jsn: well,  what does fail *mean* categorically?
02:12:49 <jsn> Taejo: i have no idea, what?
02:12:57 <Taejo> I have no idea either
02:12:57 <Axman6> does >> need to be defined? i thought it was just x >>= \_ -> f
02:13:02 <jsn> Taejo: what does it have to do with eta and mu ?
02:13:08 <Taejo> Axman6: no, it doesn't
02:13:15 <Taejo> and yes, it is
02:13:38 <Taejo> jsn: this is the argument against it. there should be a separate class MonadFail
02:13:47 <jsn> Taejo: aye
02:14:41 <jsn> Taejo: i worked through the first half of pierce's little book a few months ago, and haven't done much else with category theory since
02:14:56 <quicksilver> what it means is mzero
02:15:03 <quicksilver> which is fine, categorically
02:15:07 <quicksilver> but not every monad has one ;)
02:15:25 <quicksilver> anyhow it's easier to stay in the realm of haskell.
02:15:32 <jsn> quicksilver: isn't mzero in MonadPlus ?
02:15:38 <jsn> :t mzero
02:15:39 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
02:15:40 <quicksilver> Reader/Writer and State all don't have a sensible implementation of fail.
02:15:44 <quicksilver> ergo it's a mistake.
02:15:52 <quicksilver> since those are three pretty interesting monads.
02:16:07 <quicksilver> jsn: right. But it is what fail should mean.
02:16:26 <Peaker> in ghc-6.10, I have /usr/local/lib/ghc-6.10.0.20081007/libHSrts.a  but lambdabot wants libHSrts_thr
02:16:40 <Peaker> did ghc 6.10 kill the _thr one, or just unify it into the normal rts?
02:16:47 <jsn> quicksilver: monadplus is effectively a monad that is also a monoid, right?
02:17:11 <Peaker> @src MonadPlus
02:17:11 <lambdabot> Source not found. Are you on drugs?
02:17:24 <Taejo> @src MonadPlus
02:17:25 <lambdabot> Source not found. It can only be attributed to human error.
02:17:33 <Taejo> oops
02:17:40 <Peaker> jsn: I think MonadPlus has a different monoid for every type its parameterized on
02:17:48 <jsn> Peaker: ah
02:17:53 <Axman6> Peaker: it's just mzero :: m a, mplus :: m a -> m a -> m a
02:18:13 <Axman6> @src Maybe mplus
02:18:13 <lambdabot> Nothing `mplus` ys = ys
02:18:13 <lambdabot> xs      `mplus` ys = xs
02:18:18 <Axman6> @src Maybe mzero
02:18:18 <lambdabot> mzero = Nothing
02:18:27 <Axman6> @src [] mplus
02:18:28 <lambdabot> mplus = (++)
02:18:36 <Peaker> Axman6: yeah, note that you choose any "a" you'd like
02:18:39 <jsn> so /an instance/ of MonadPlus is a monad that is also a monoid
02:18:50 <Axman6> @src [] mzero
02:18:50 <lambdabot> mzero = []
02:18:58 <Peaker> jsn: "m" is the instance, "a" remains an open type parameter
02:19:08 <jsn> Peaker: oh, i see
02:19:20 <jsn> interesting
02:20:02 <Peaker> @type mappend
02:20:02 <lambdabot> forall a. (Monoid a) => a -> a -> a
02:20:03 <Peaker> @type mplus
02:20:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
02:24:59 <Axman6> > (Just 2) `mplus` Nothing
02:25:00 <lambdabot>   Just 2
02:25:09 <Axman6> > (Just 2) `mplus` (Just 5)
02:25:10 <lambdabot>   Just 2
02:25:16 <Axman6> > Nothing `mplus` (Just 5)
02:25:17 <lambdabot>   Just 5
02:25:20 <opqdonut> > (Just 2) `mappend` (Just 5)
02:25:21 <lambdabot>   Add a type signature
02:25:31 <opqdonut> ah, my bad
02:26:13 <Peaker> > Nothing >> (Just 2)
02:26:14 <lambdabot>   Nothing
02:26:19 <Peaker> > (Just 2) >> Nothing
02:26:21 <lambdabot>   Nothing
02:26:25 <Deewiant> > (Just [2]) `mappend` (Just [5])
02:26:27 <lambdabot>   Just [2,5]
02:26:34 <opqdonut> > Just 2 >> Just 5
02:26:35 <lambdabot>   Just 5
02:26:38 <opqdonut> that's the one i was looking for
02:26:44 <Axman6> huh
02:26:58 <opqdonut> `mplus` keeps the first, >> the second
02:27:04 <mwotton> http://hpaste.org/11983
02:27:16 <Peaker> opqdonut: >> doesn't keep the second if the first is Nothing
02:27:25 <Axman6> why was Nothing >> (Just 2) Nothing then?
02:27:32 <mwotton> one of these things is much slower than the other one. any idea how to get a similarly compact formulation with acceptable speed?
02:27:39 <BeelsebobWork> Axman6: because bind propogates failure
02:27:45 <BeelsebobWork> if any one stage fails, the whole thing fails
02:27:49 <Axman6> oh yess
02:27:49 <Peaker> >> has a right-bias, mplus has a left-bias.  >> treats Nothing as fatal, mplus prefers to ignore it
02:27:52 <Axman6> right!
02:28:07 <Axman6> because it uses >>=
02:28:07 <Deewiant> mwotton: use Data.IntSet?
02:28:11 <Axman6> i see, nice :)
02:28:23 <idnar> @type (>>)
02:28:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
02:28:25 <Peaker> Axman6: Maybe is probably the simplest exception monad
02:28:52 <Axman6> i'd just never thought about it :)
02:29:03 <idnar> @type mappend
02:29:04 <lambdabot> forall a. (Monoid a) => a -> a -> a
02:29:16 <Axman6> @src mappend
02:29:16 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:29:19 <Axman6> hmm
02:29:20 <idnar> @instances Monoid
02:29:21 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:29:25 <Axman6> what's mappend do?
02:29:29 <Peaker> Axman6: functions have source, methods don't
02:29:35 <Peaker> Axman6: depending on the instance
02:29:36 <idnar> @type (Just 2) `mappend` (Just 5)
02:29:37 <lambdabot> forall t. (Monoid t, Num t) => Maybe t
02:29:37 <Deewiant> mwotton: forgettables = Set.fromDistinctAscList (map fromEnum "\"$()0123456789?C[]{}"); unforgettable x = not (fromEnum x `member` forgettables) or some such
02:29:47 <idnar> oh, heh
02:30:05 <idnar> @src [] mappend
02:30:05 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:30:12 <Peaker> > Nothing `mappend` (Just [5])
02:30:13 <idnar> such an abusive bot
02:30:14 <Deewiant> mwotton: (note that if you don't name forgettables here and inline it instead it'll probably get recomputed for each call)
02:30:20 <lambdabot>   Just [5]
02:30:51 <Peaker> Axman6: the Maybe instance of Monoid implements mappend by recursively calling mappend on the contained values in the Justs, or just using the Just value if there is one
02:31:13 <Axman6> example?
02:31:24 <Peaker> > Nothing `mappend` Nothing
02:31:26 <lambdabot>   Nothing
02:31:30 <Peaker> > Nothing `mappend` Just [1]
02:31:31 <lambdabot>   Just [1]
02:31:36 <Peaker> > Just [2] `mappend` Just [1]
02:31:37 <lambdabot>   Just [2,1]
02:31:45 <Peaker> > [2] `mappend` [1]
02:31:46 <lambdabot>   [2,1]
02:31:58 <Axman6> @src Maybe mappend
02:31:58 <lambdabot> Source not found. You type like i drive.
02:32:01 <Axman6> bleh
02:32:20 <Peaker> @src mappend Maybe
02:32:20 <lambdabot> Source not found. :(
02:33:58 <Peaker> yay I compiled lambdabot on ghc 6.10
02:34:00 <Taejo> @instances Monoid
02:34:01 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:34:12 <Peaker> @src Monoid Maybe
02:34:12 <lambdabot> Source not found. I am sorry.
02:34:16 <mwotton> Deewiant: cheers, that works pretty nicely. not quite as fast as the ugly version, but that one really was awful :)
02:35:11 <Peaker> the @src database is just messed up
02:35:14 <Taejo> Peaker: mzero = Nothing; (Just x) `mappend` _ = x; Nothing `mappend` x = x
02:35:28 <Taejo> although I may have got the strictness wrong
02:35:28 <Peaker> Taejo: mempty
02:35:33 <Taejo> yeah
02:35:35 <Taejo> oops
02:35:45 <Axman6> (Just x) `mappend` _ = x; doesn't make sense
02:35:45 <Peaker> Taejo: you didn't call mappend recursively
02:35:51 <Axman6> that's mplus
02:36:24 <Taejo> ok, sorry, I'm confuzzled
02:36:30 <Taejo> @src mappend
02:36:31 <lambdabot> Source not found. Where did you learn to type?
02:36:35 <Taejo> @ty mappend
02:36:36 <lambdabot> forall a. (Monoid a) => a -> a -> a
02:36:38 <Peaker> instance Monoid a => Monoid (Maybe a) where mempty = Nothing ; Nothing `mappend` x = x ; x `mappend` Nothing = x ; (Just x) `mappend` (Just y) = Just (x `mappend` y)
02:36:53 <Peaker> this should work
02:37:12 <Taejo> ok, I didn't know that the insides got mappended
02:37:46 <Peaker> I think most monoids do that
02:37:51 <Peaker> (recursively mappend)
02:38:15 <Peaker> conal's UI Monoid does that, which lets you mappend both the UI's together (putting the widgets next to each other) and the event sources in one blow
02:38:27 <Axman6> so mappend for Maybe takes Monoid m,n => m (n a)?
02:38:27 <Taejo> Peaker: that makes sense
02:39:42 <idnar> Axman6: no, instance Monoid m => Monoid (Maybe m) or something
02:39:57 <idnar> oh, Peaker already mentioned that
02:40:14 <Peaker> Axman6: m is Maybe, you don't need to parameterize it
02:40:19 <Peaker> Axman6: in this case
02:40:26 <Axman6> hmm
02:40:54 <Axman6> well, it has to be Maybe (m a) right? where m is a Monoid instance?
02:41:01 <dmwit_> No.
02:41:07 <dmwit_> Monoids are not type constructors.
02:41:16 <dmwit_> :k Monoid m => m
02:41:17 <lambdabot> *
02:41:24 <dmwit_> :k Monad m => m
02:41:24 <Axman6> yes, that what i meant
02:41:25 <lambdabot>     `m' is not applied to enough type arguments
02:41:25 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
02:41:32 <dcoutts> Peaker: the glut package uses a configure script which generates a glut.buildinfo file with the additional options like ld flags
02:42:07 <Peaker> dcoutts: ah, so the configure script must be broken
02:42:11 <dmwit_> :k [] -- a better example of a monad instance, I guess
02:42:12 <lambdabot> * -> *
02:42:44 <Axman6> :t Maybe.mappend
02:42:45 <lambdabot> Not in scope: `Maybe.mappend'
02:42:48 <bryan1> Does anyone have any clues about these error messages?? http://hpaste.org/11984
02:42:51 <Axman6> :t Maybe mappend
02:42:52 <lambdabot> Not in scope: data constructor `Maybe'
02:42:55 <Axman6> rawy
02:43:01 <dmwit_> :t mappend :: Maybe a -> Maybe a -> Maybe a
02:43:02 <lambdabot>     Could not deduce (Monoid a) from the context ()
02:43:02 <lambdabot>       arising from a use of `mappend' at <interactive>:1:0-6
02:43:02 <lambdabot>     Possible fix:
02:43:19 <Taejo> :t tell
02:43:19 <Axman6> dmwit_: but from the def, the a has to be a monoin instance too
02:43:20 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
02:43:26 <dmwit_> Axman6: right
02:43:40 <dmwit_> :t mappend :: Monoid a => Maybe a -> Maybe a -> Maybe aa
02:43:41 <lambdabot>     Could not deduce (Monoid aa) from the context (Monoid a)
02:43:41 <lambdabot>       arising from a use of `mappend' at <interactive>:1:0-6
02:43:41 <lambdabot>     Possible fix:
02:43:42 <dmwit_> bah
02:43:44 <dmwit_> :t mappend :: Monoid a => Maybe a -> Maybe a -> Maybe a
02:43:44 <Axman6> ok, i ws just trying to see that type written down :)
02:43:45 <lambdabot> forall a. (Monoid a) => Maybe a -> Maybe a -> Maybe a
02:44:16 <Peaker> Axman6: one thing that's not mentioned a lot in the tutorials is that "class Blah b where..." is also implicitly specifying the kind of b.  Monoid m specifies that m::*, and Monad m specifies that m::*->*
02:44:48 <Axman6>  never for the m::*->* bit
02:44:50 <Axman6> got8
02:44:59 <Axman6> urgh, failing at typing tonight
02:45:00 <Peaker> Axman6: (it does so simply by looking in the types of the methods. the monoid "m" is used as m->m->m,  the Monad "m" is used as: m a->m b->m b (zero vs one type argument)
02:45:15 <Peaker> you can also explicitly specify the kinds
02:45:19 <Axman6> ah
02:45:44 <Axman6> are all monads monoids?
02:45:51 <Peaker> so [a] can be an instance of Monoid, but not of Monad.  [] can be an instance of Monad, but not of Monoid
02:45:58 <Peaker> Axman6: All monads are NOT monoids
02:46:04 <Peaker> Axman6: because they have a different kind
02:46:11 <Axman6> ok
02:46:16 <Peaker> Axman6: [] :: * -> *   and [a] -> *
02:46:18 <dmwit_> Also because not all monads have a zero element.
02:46:19 <Peaker> oops
02:46:22 <Peaker> [a] :: *
02:46:32 <dmwit_> So even if we were to do a clever embedding, not all monads would be monoids.
02:46:37 <Peaker> dmwit_: Yeah, but I meant: if something is a Monad, its surely not a Monoid
02:46:46 <dmwit_> (Maybe is a great example of this: it requires its underlying element to be a Monoid.)
02:47:04 <dmwit_> Peaker: Yeah, but that's not really a satisfying argument.
02:47:15 <dmwit_> Peaker: Since e.g. all monads are arrows, even though their kinds don't match.
02:47:35 <Peaker> dmwit_: Monads can be converted to arrows (in perhaps more than one way), they are not themselves arrows
02:47:36 <dmwit_> You can do an embedding that manufactures a new kind, basically.
02:47:45 <dmwit_> Peaker: Right.
02:48:56 <Peaker> Axman6: Haskell allows you to define that [a] is a Monoid, that means that it must be the same "a" type throughout all of the method signatures.  [Int] and [String] are different Monoids.   [] is a Monad, so the functions can use both [] String and [] Int in their signatures (so the entire type-family is just one Monad)
02:49:54 <dmwit_> Actually, probably (return (), (>>)) witnesses a monoid for any given monad.
02:50:04 <Axman6> hmm, ok
02:50:12 <Peaker> dmwit_: what does "witnesses" mean?
02:50:18 <Taejo> how do I "run" something that's in the writer monad?
02:50:23 <dmwit_> :t runWriter
02:50:24 <lambdabot> forall w a. Writer w a -> (a, w)
02:50:29 <Taejo> excellent
02:50:31 <Taejo> thanks
02:50:34 <Peaker> dmwit_: that would be a boring monad:  (m ())
02:50:43 <Peaker> dmwit_: or at least, often boring ;)
02:50:47 <idnar> @kind Monoid
02:50:48 <dmwit_> Peaker: Boring, yes.
02:50:48 <lambdabot> Class `Monoid' used as a type
02:50:49 <idnar> @kind Monad
02:50:50 <lambdabot> Class `Monad' used as a type
02:50:54 <idnar> er
02:51:01 <dmwit_> ?kind Monad m => m a
02:51:02 <lambdabot> *
02:51:17 <Peaker> in ghc-6.10 src/Hint/Parsers.hs:7:21: Module `GHC' does not export `Session' -- where is that in now?
02:51:26 <idnar> @kind Monad m => m
02:51:27 <lambdabot>     `m' is not applied to enough type arguments
02:51:27 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
02:51:37 <idnar> mmph
02:51:38 <dmwit_> Peaker: And by "witnesses" I just meant that (return ()) and (>>) could be the zero element and addition of the monoid.
02:51:57 <Axman6> is it possible in haskell to define a data type, like a list, with more than one kind of thing in it?
02:52:04 <Axman6> just curious if it's possible
02:52:05 <dmwit_> idnar: I know, I ran into the same stupidity earlier.
02:52:14 <Peaker> dmwit_: ah, cause I read about witness types, which iiuc, are just phantom type parameters that assert something about the value
02:52:19 <dmwit_> Axman6: [Either a b] -- ;-)
02:52:20 <opqdonut> Axman6: yeah it's possible
02:52:22 <Axman6> say, a list with numbers and strings as elements
02:52:35 <Axman6> dmwit_: without another type i was thinking
02:52:40 <opqdonut> Axman6: either with Either or with existential types and something like [Show a => a]
02:52:42 <dmwit_> Axman6: or ([a], [b])
02:52:52 <BeelsebobWork> Axman6: also, yes HList
02:53:02 <Axman6> well, i meant an arbitary number of types
02:53:12 <BeelsebobWork> yep, HList
02:53:14 <Peaker> Axman6: it can have more than one type in it, but not more than one kind "in" it, because types whose kind is not * don't have any values
02:53:19 <Axman6> BeelsebobWork: interesting
02:53:22 <Axman6> linky?
02:53:29 <BeelsebobWork> @oleg
02:53:30 <lambdabot>  Defined.
02:53:33 <BeelsebobWork> o.O
02:53:36 <dmwit_> Peaker: There are no types whose kind is not *.
02:53:40 <Axman6> hah
02:53:47 <BeelsebobWork> @where oleg
02:53:47 <lambdabot> http://okmij.org/ftp/
02:53:55 <BeelsebobWork> that's not oleg!
02:53:58 <BeelsebobWork> bad \bot
02:53:58 <dmwit_> Peaker: Things that are classified by kinds that are not * are not types. ;-)
02:54:02 <Peaker> dmwit_: Oh, I thought type constructors were also considered types
02:54:06 <Philonous1> Axman6: That wouldn't be very useful, you would at least need _something_ you could coherently do with all of the items, and this something gives rise to a type class - > existential types
02:54:27 <Axman6> Philonous1: oh, i don't care about usefulness, just possibility :)
02:54:40 <dmwit_> Peaker: You can use that definition, too, I'm just being difficult.
02:54:58 <ToRA|MSR> practically though (in ghc at least) there are unboxed types...which have values, and they don't have kind *.
02:55:04 <Taejo> :t replicate
02:55:05 <lambdabot> forall a. Int -> a -> [a]
02:55:07 <Peaker> @hoogle Sessions
02:55:08 <lambdabot> package sessions
02:55:11 <ToRA|MSR> which is why @kind (->) isn't * -> * -> *
02:55:16 <Peaker> @hoogle GHC.Sessions
02:55:16 <lambdabot> package sessions
02:55:35 <dmwit_> ToRA|MSR: fair enough
02:56:39 <Deewiant> @kind (->)
02:56:40 <lambdabot> ?? -> ? -> *
02:57:04 <Deewiant> but hmm, can't it also return an unboxed type?
02:57:44 <dmwit_> Yes, that's the ? part.
02:57:57 <Deewiant> Ah, duh
02:58:04 <Deewiant> The * is not the return type :-)
02:58:10 <dmwit_> =)
02:58:16 <dmwit_> It's the *returned* type. =P
02:58:38 <Peaker> where did ghc-6.8's GHC.Session type go in ghc-6.10?
02:59:01 <opqdonut> :P
03:02:03 <Peaker> @hoogle GhcMonad
03:02:03 <lambdabot> No results found
03:02:52 <Peaker> anyone got hint to compile with ghc-6.10?
03:10:54 <Peaker> would it be very hard to keep backwards compatibility API adapters?
03:11:26 <Axman6> does the garbage collector run in ghci?
03:11:58 <Peaker> I'd suppose so
03:12:00 <opqdonut> yes
03:13:12 <Axman6> hmm, just i ran something that uses a gig of RAM, and it's not disappearing
03:13:35 <sjanssen> Axman6: GHC does not release memory back to the OS
03:13:46 <Axman6> ok
03:13:51 <Peaker> sjanssen: isn't that problematic?
03:14:00 <Axman6> sjanssen: sure it does, :q :)
03:14:02 <Peaker> kind of makes you want to fork jobs into child processes
03:14:19 <sjanssen> Peaker: it certainly could be for some applications
03:18:27 <hugo__> i want to use haskell to run some simple shell commands
03:18:35 <hugo__> is there a package for it ?
03:19:07 <sjanssen> hugo__: there are a few, System.Process, System.Cmd, and more on hackage
03:20:09 <hugo__> nice
03:22:49 <hugo__> ill make some simple passwd bruteforcer
03:23:21 <Taejo> :t intercalate
03:23:22 <lambdabot> forall a. [a] -> [[a]] -> [a]
03:23:45 <Taejo> intercalate ", " ["foo", "bar", "baz"]
03:23:51 <Taejo> > intercalate ", " ["foo", "bar", "baz"]
03:23:52 <lambdabot>   "foo, bar, baz"
03:24:08 <Axman6> nice
03:24:28 <idnar> @type intersperse
03:24:29 <lambdabot> forall a. a -> [a] -> [a]
03:24:48 <idnar> @src intersperse
03:24:48 <lambdabot> intersperse _   []     = []
03:24:48 <lambdabot> intersperse _   [x]    = [x]
03:24:48 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
03:25:08 <idnar> @src intercalate
03:25:09 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
03:25:30 <dmwit_> > intercalate ", " ["this", "that", "and the other"]
03:25:32 <lambdabot>   "this, that, and the other"
03:25:40 <idnar> hmm
03:25:45 <idnar> @type mconcat
03:25:46 <lambdabot> forall a. (Monoid a) => [a] -> a
03:25:55 <idnar> @type mconcat (intersperse xs xss)
03:26:04 <lambdabot> Not in scope: `xs'
03:26:04 <lambdabot> Not in scope: `xss'
03:26:08 <idnar> @type mconcat (intersperse ?xs ?xss)
03:26:10 <lambdabot> forall a. (Monoid a, ?xss::[a], ?xs::a) => a
03:26:31 <idnar> > let mintercalate = mconcat (intersperse ?xs ?xss) in mintercalate ", " ["foo", "bar", "baz"]
03:26:32 <lambdabot>       Unbound implicit parameters (?xs::[Char] -> [[Char]] -> a,
03:26:32 <lambdabot>             ...
03:26:42 <idnar> > let mintercalate xs xss = mconcat (intersperse xs xss) in mintercalate ", " ["foo", "bar", "baz"]
03:26:43 <lambdabot>   "foo, bar, baz"
03:26:51 <dmwit_> It doesn't get much more pointless than Monoid-ifying intercalate. =P
03:27:05 <idnar> > let mintercalate xs xss = mconcat (intersperse xs xss) in mintercalate Just ", " [Just "foo", Just "bar", Nothing, Just "baz"]
03:27:06 <lambdabot>   Couldn't match expected type `a -> Maybe a'
03:27:07 <dmwit_> Intercalate has to rank right up there with lex for functions that Never Get Called.
03:27:13 <idnar> > let mintercalate xs xss = mconcat (intersperse xs xss) in mintercalate (Just ", ") [Just "foo", Just "bar", Nothing, Just "baz"]
03:27:15 <lambdabot>   Just "foo, bar, , baz"
03:27:19 <idnar> heh
03:27:26 <idnar> @type lex
03:27:27 <lambdabot> String -> [(String, String)]
03:27:30 <idnar> @src lex
03:27:31 <lambdabot> Source not found. Sorry.
03:27:38 <dmwit_> You do not want to see the source of lex
03:27:42 <Peaker> I dislike the un-generalized list functions that could have applied to Foldable or Monoid instead
03:27:48 <dmwit_> After all... it lexes Haskell. =P
03:27:53 <idnar> oh, ouch
03:27:59 <idnar> I used intercalate the other day
03:28:06 <Taejo> dmwit_: just called intercalate know (formatExpr (Fun name args) = name ++ "(" ++ intercalate ", " args ++ ")")
03:28:11 <dmwit_> > lex "\"a/     /b\""
03:28:12 <lambdabot>   [("\"a/     /b\"","")]
03:28:14 <idnar> except I forgot about intercalate, so it ended up being concat (intersperse ...)
03:28:15 <Taejo> s/know/now/
03:28:44 <dmwit_> Taejo, idnar: Yes, of course it gets used, or else it wouldn't have been put in the libraries.
03:28:46 <dmwit_> But still...
03:29:05 <idnar> I'd expect it to be more frequently used than intersperse, to be honest
03:29:16 <dmwit_> That's not saying much.
03:29:22 <rog> does anyone know if it's possible to get ghci 6.10 to run in "naive-terminal" mode - i.e. without setting the tty to raw mode?
03:29:42 <rog> 6.8 was fine for that.
03:29:48 <Taejo> dmwit_: I use python's equivalent all the time, but I write different kinds of programs in python and haskell
03:30:18 <Taejo> also, Python doesn't have unlines, so you use "\n".join (~= intercalate "\n")
03:30:41 <rog> (it says "using dumb terminal settings", but then proceeds as if it wasn't a dumb terminal)
03:30:53 <Peaker> Taejo: for what purposes do you find Python more appropriate?
03:31:20 <Taejo> Peaker: gluey, scripty stuff
03:31:35 <Taejo> usually lots of dumb string processing
03:32:01 <Peaker> Taejo: I am trying to get used to Haskell for these things too
03:32:25 <Taejo> Peaker: I'm trying to get used to writing more interesting programs
03:33:22 <Peaker> Taejo: I used someone's shell hack (and enhanced it a bit) so I can use Haskell easily from the command-line:   cat blah | hawk putStr =<< unlines <$> map (join (++)) <$> lines <$> getContents
03:33:33 <Peaker> (Haskell awk, heh)
03:34:09 <Taejo> :t join
03:34:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:34:40 <Taejo> :t join (++)
03:34:41 <lambdabot> forall a. [a] -> [a]
03:34:56 <Taejo> join (++) "abcdef"
03:34:58 <Taejo> > join (++) "abcdef"
03:35:05 <lambdabot>   "abcdefabcdef"
03:35:15 <Taejo> ohok
03:35:44 <Axman6> it annoys me when lambdabot turns (\x -> x*x) into join (*) when you use @pl
03:36:01 <sjanssen> Axman6: what should it use instead?
03:36:06 <opqdonut> Axman6: why?
03:36:06 <Taejo> cat blah | python -e "'\n'.join(line*2 for line in sys.stdin)"
03:36:15 <Axman6> (^2)
03:36:28 <Axman6> but, meh
03:36:38 <Taejo> I like haskell, but in this case python looks simpler to me
03:36:43 <ToRA|MSR> cat blah | hawk interact (unlines . map (join (++)) . lines)
03:36:46 <Peaker> Taejo: heh, you saved the putStr =<< unlines part :)
03:36:48 <ToRA|MSR> wouldn't that work?
03:36:59 <Taejo> Peaker: unlines in "\n".join
03:37:07 <ToRA|MSR> or is interact line by line?
03:37:10 <Peaker> Taejo: Of course I have: onLines that lets me write just the contents of the the map..
03:37:20 <vegai> Hey. Please recommend a compiler book to go with the Dragon Book. Preferably something more modern
03:37:23 <Taejo> yeah, fair enough
03:37:29 <Peaker> Taejo: hawk onLines (\x -> x++x)
03:37:49 <Peaker> Taejo: If Python is still nicer on some examples, its time for another abstraction :)
03:37:57 <Peaker> Taejo: the other way around doesn't work, though
03:37:58 <vegai> or perhaps something that gives a good overview of modern techniques such as type inference
03:38:05 <sjanssen> Axman6: you can certainly teach @pl about that rule
03:38:19 <sjanssen> Axman6: however, join (*) is almost certainly faster
03:38:30 <Axman6> probably
03:38:41 <Axman6> @pl \x -> x*x*x
03:38:41 <lambdabot> (*) =<< join (*)
03:38:51 <vegai> oh wait a sec. The Dragon book already has a section on type inference
03:38:54 <Taejo> vegai: I just did Appel's Modern Compiler Construction in Java... I don't have enough experience to judge well. It seems fairly good, although I'd go for the ML version (he goes *on* and *on* and *on* about the Visitor Pattern in the java version)
03:38:54 <Axman6> @pl \x -> x*x*x*x
03:38:54 <lambdabot> (*) =<< (*) =<< join (*)
03:38:55 <Peaker> Axman6: join is more general, of course
03:39:47 <Taejo> which monad is \bot using there?
03:39:53 <Peaker> the Reader monad
03:40:02 <Taejo> srsly?
03:40:19 <Peaker> basically you can combine functions monadically, and get a combined function which takes an argument and passes it to all the combined functions
03:40:34 <ToRA|MSR> strictly it's the MonadReader instance for (->)
03:40:39 <Peaker> (also, each rhs of >>= gets the lhs result before the extra arg)
03:41:38 <Peaker> @pl \x -> (return x) >>= (*) >>= (*) >>= (*)
03:41:38 <lambdabot> ((*) =<<) . ((*) =<<) . (*)
03:42:00 <Peaker> > (\x -> (return x) >>= (*) >>= (*) >>= (*)) 2
03:42:00 <lambdabot>       Overlapping instances for Show (a -> a)
03:42:00 <lambdabot>        arising from a use of `s...
03:42:14 <Peaker> the reader monad can be a bit confusing :)(
03:43:31 <Peaker> join f = \x -> f x x      because it takes a reader inside a reader: env->env->result, and converts it to an env->result, so it must give the same env twice
03:47:57 <roderyk> I downloaded a triangular mesh scene to test a ray-tracer I'm writing; the lights defined have a 3D position, total flux, and "RGB coefficients (not normalized)"... but the RGB values are triplets of numbers in [0..1]. Any idea what kind of format this could be? Should I just round(multiply 255)? :)
03:52:04 <rog> re: my previous enquiry - i can get it to work ok by doing "cat | ghci | cat"...
03:52:24 <jeffz> roderyk: there's a Data.Colour library on hackage which has some types and functions for dealing with various colours, might be worth looking at
03:54:58 <roderyk> jeffz: thanks, will look into that; now to go figure out why my light rays are not shooting off correctly ;-)
03:55:59 <rog> is any way of finding out about the context in which an exception was raised? (using ghc)
03:59:41 <rog> it's quite frustrating having an error raised and then  being entirely unable to find out where it happened...
04:01:41 <rog> the only thing i can think of is to change the function that raises the error to add an extra text argument that gets printed with the exception. then change everywhere that calls it to add some unique text. this feels wrong...
04:02:44 <rog> ... especially as there are 46 calls :-(
04:06:10 <vegai> http://www.amazon.co.uk/review/R3TOJKPTF9P5YJ/ref=cm_cr_rdp_perm
04:06:18 <vegai> "Again, who cares? Millions of lines of code are written in C every year and everything works just fine."
04:07:19 <Peaker> vegai: Everything works just fine. Hah hah hah
04:07:48 <Peaker> software is just so dependable and great. hah :)
04:26:22 <dolio> SICP has a lot of 1-star reviews.
04:31:52 <Axman6> dolio: what's SICP?
04:32:02 <BeelsebobWork> Axman6: google
04:32:06 <dolio> The Structure and Interpretation of Comptuer Programs.
04:32:11 <Axman6> apart from a awkward to say acronym
04:32:30 <Axman6> BeelsebobWork: you stfu, not talking to you anymore :(
04:32:37 <BeelsebobWork> dolio: probably angry students who didn't like having to learn something non-C on their first year computing course
04:32:41 <BeelsebobWork> Axman6: :P
04:32:45 <Axman6> :P
04:33:05 <dolio> BeelsebobWork: Yeah, I skimmed over them, and that's approximately the state of it.
04:33:35 <dolio> Lots of people who wanted to start hacking C or something, and didn't want to learn about theoretics.
04:34:06 <BeelsebobWork> "While some of the information is pretty interesting, most of it isn't, and some is outright self evident, such as abstraction concepts. In the year since I've read this book, I haven't opened it again and never used a single concept from it. That should tell you something about how relevant it is."
04:34:14 <BeelsebobWork> no... that should tell you something about how good a programmer you are ;)
04:34:42 <Axman6> heh
04:34:50 <Axman6> i bet they have used stuff from it
04:34:52 <dolio> Some people who tried to use it as an intro to programming by themselves. Which I admit, could be difficult.
04:35:15 <BeelsebobWork> yeh
04:35:21 <BeelsebobWork> it's really meant to go along with the lectures
04:35:32 <BeelsebobWork> Axman6: btw -- if you haven't read it, you should
04:35:34 <BeelsebobWork> it's a great book
04:35:43 <Axman6> maybe one day
04:35:50 <Axman6> Cocoa's my language for these holidays
04:36:39 <mapreduce> I expect if you read SICP and never use anything from it, you didn't understand it.
04:36:58 <mapreduce> Or did not program after reading it.
04:37:08 <BeelsebobWork> indeed
04:37:12 <dolio> That guy quoted above is probably the best though.
04:37:25 <Peaker> BeelsebobWork: what topics does the book cover?
04:37:36 <dolio> Who read the authors talking about how conceptually challenging assignment is, and just blew it off, saying "C is just fine."
04:37:40 <BeelsebobWork> Peaker: the title is actually very descriptive
04:37:47 <BeelsebobWork> it covers how computer programs are structured
04:37:48 <BeelsebobWork> in general
04:38:10 <BeelsebobWork> i.e. what is crucial to end up with a computer program / programming language
04:38:15 <Peaker> BeelsebobWork: well, programmers know about the structure of computer programs already, and at least some of the ways to interpret them?
04:38:48 <BeelsebobWork> Peaker: sure -- but most programmers don't know it properly -- most programmers for example think that call-by-value is the only way to do evaluation
04:39:20 <Axman6> BeelsebobWork: what's cal by value mean?
04:39:27 <dolio> Hey, there's call by reference, too. :)
04:39:51 <BeelsebobWork> Axman6: call by value semantics is what most imperative languages use -- they evaluate the arguments, then they push the values of the arguments into the function being called
04:39:59 <BeelsebobWork> as opposed to call-by-name as haskell uses
04:40:06 <BeelsebobWork> or call-by-reference as for example C# uses
04:40:08 <hugo__> whats the formula to add powers with the same base ? (in maths)
04:40:31 <Peaker> BeelsebobWork: I think most know both call by value and call by reference
04:40:31 <Axman6> hugo__: x^2+x^3?
04:40:44 <BeelsebobWork> Peaker: yeh, probably most know call-by-ref too
04:40:44 <Axman6> is that what you're talking about?
04:40:54 <Zao> x^2 * x^3 == x^(2+3)
04:40:57 <mapreduce> C# only has call-by-reference if you use 'ref' or 'out'.  Its normal mode is call-by-value.
04:40:59 <hugo__> Axman6:  yes
04:41:14 <Axman6> hugo__: there isn't one
04:41:16 <Zao> There is no equivalent for a polynom like that.
04:41:19 <Axman6> afaik at least
04:41:20 <BeelsebobWork> but they have no idea about call by name for example -- or that there are more posibilities after those three
04:41:35 <hugo__> i thought there was some strange summation formula for it :/
04:41:54 <BeelsebobWork> Peaker: essentially that book goes into what is essential for a programming language to exist, and what is something that can be part of the language design space
04:42:00 <dolio> Most haskell implementations use call-by-need, actually (which shares named values and by-name doesn't).
04:42:15 <BeelsebobWork> indeed
04:42:34 <Axman6> x^a+x^b = (x^(min a b))(1+x^(max a b - min a b))?
04:42:39 <mapreduce> Scala methods can have call-by-need parameters, denoted by =>.  def foo(x: => Bar) = ...
04:42:44 <ski_> hugo__ : possibly you're thinking of `(x + y)^3' ..
04:42:44 <mapreduce> s/need/name/
04:42:45 <Axman6> sooo much clearer on paper
04:44:09 <Axman6> hugo__: yeah, if you're thinking of (x + y)^n, then there's a formula using pascal's triangle...
04:44:21 <dolio> There's also 'x^n + x^n + ... x times ... + x^n = x^(n+1)'. :)
04:44:27 <dolio> If x is an integer.
04:44:58 <mapreduce> x.x^n = x^(n+1)
04:45:02 <Axman6> does it need to be an integer?
04:45:07 <Axman6> didn't think so...
04:45:14 <mapreduce> That seems a neater way of saying that, dolio.
04:45:22 <idnar> < mapreduce> C# only has call-by-reference if you use 'ref' or 'out'.  Its normal mode is call-by-value.
04:45:25 <idnar> that's not exactly true
04:45:26 <Axman6> ok... i have a math exam tomorrow, keep this up!
04:45:34 <mapreduce> idnar: How is it false?
04:45:44 <idnar> mapreduce: objects are still passed by reference, even if they're not a ref/out param
04:45:53 <mapreduce> That is incorrect.
04:45:53 <Axman6> integrals of functions of multiple varables gogogo!
04:45:56 <dolio> Axman6: Yeah, well, you can't have fractional numbers of terms to add up. :)
04:45:58 <idnar> or, er, whatever C# calls things thare aren't value types
04:46:00 <mapreduce> References to objects are passed, by value.
04:46:15 <idnar> surely that's the same thing
04:46:23 <mapreduce> void Swap(object o, object p) { object q = o; o = p; p = q; }
04:46:28 <Axman6> dolio: ah yes, i see
04:46:30 <mapreduce> The caller will see no effect from Swap.
04:46:37 <mapreduce> Thus it is call by value, not call by reference.
04:46:58 <idnar> mapreduce: that makes for rather confusing terminology, then
04:47:32 <mapreduce> Arguably so, yes.  But call-by-reference is quite rigorously defined, if you choose to look at the definition. :)
04:47:42 <idnar> mapreduce: whose definition? :P
04:47:56 <mapreduce> I'd guess it's in TAPL.  It's definitely in wikipedia.
04:48:16 <idnar> I don't see why "rebinds names in the caller's scope" has to be part of the definition
04:48:26 <mapreduce> I think it's in C#'s (and Java's) language spec too.
04:48:27 <dolio> Lots of languages blur it.
04:48:38 <idnar> C++ has an operator= that modifies objects in-place
04:48:39 <mapreduce> Because that's what pass-by-reference means.
04:48:40 <dolio> Like, I assume Swap above passes object references by value?
04:48:42 <idnar> so it's different there
04:48:48 <mapreduce> dolio: Yes.
04:49:00 <idnar> "In call-by-reference evaluation, a function receives an implicit reference to the argument, rather than a copy of its value. This means that the function can modify the argument, what will be seen by its caller."
04:49:05 <idnar> that's the wikipedia definition
04:49:07 <idnar> which matches mine
04:49:12 <mapreduce> idnar: No, it matches mine.
04:49:20 <idnar> mapreduce: your code snippet doesn't modify any values
04:49:48 <mapreduce> My code snippet uses pass-by-value.
04:49:52 <idnar> it just swaps references around, leaving the actual objects unmodified
04:50:02 <idnar> if you modified o or p, the caller would see those modifications
04:50:08 <mapreduce> The objects are not arguments to the method.  Only their references are.
04:50:39 <idnar> *shrug* okay
04:50:45 <mapreduce> Thankfully in Haskell (and in C# if you have immutable objects) you never have to care.
04:50:55 <idnar> that's still a rather horribly confusing way of looking at it, in my opinion
04:51:13 <mapreduce> It's the only way I know of whereby "pass by reference" and "pass by value" don't mean the same thing.
04:51:51 <idnar> "pass-by-value" means the value is copied when it's passed in
04:52:02 <mapreduce> Yes.  The value in Swap is the reference.
04:52:20 <idnar> I'm not saying your terminology is inconsistent, I just think it's confusing
04:52:26 <mapreduce> C is pass-by-value, this seems universally accepted.
04:52:36 <Peaker> the difference between pass by val and pass by ref is probably only visible in an imperative language?
04:53:00 <dolio> There's potentially a big memory usage difference.
04:53:05 <idnar> Peaker: not according to mapreduce's definition
04:53:08 <mapreduce> void swap(void *a, void *b) { void *c = a; a = b; b = c; }
04:53:13 <dolio> Although that's not visibe in-language.
04:53:14 <mapreduce> Peaker: As far as I can see, yes.
04:53:29 <Peaker> well, a pure functional language would just pass by ref anything that is large, if there's no denotational difference in semantics
04:53:33 <mapreduce> The above C is still pass by value, and still does nothing observable.
04:54:23 <mapreduce> Peaker: Pass by ref means nothing when you can't mutate stuff.
04:54:32 <mapreduce> But I know what you mean.
04:54:36 <idnar> mapreduce: when every value is a reference, it seems counter-intuitive to call it a value
04:54:47 <mapreduce> idnar: Are you talking about Haskell now?
04:54:54 <idnar> no, C#
04:54:59 <idnar> although I guess C# does have value types
04:55:03 <mapreduce> Not every value in C# is a reference.
04:55:14 <idnar> but I prefer to think of those as a special case, rather than thinking of the object references as a special case
04:55:55 <mapreduce> They're not really a special case.  It would be difficult to use a subset of C# that disalllowed (or avoided) primitives and structs.
04:56:06 <idnar> why?
04:56:17 <mapreduce> Because they're useful.
04:56:33 <idnar> what do they give you, besides efficiency?
04:56:42 <mapreduce> What do they lose you?
04:56:49 <idnar> consistency
04:56:51 <mapreduce> How so?
04:56:55 <dolio> Haskell gets by without them. :)
04:57:05 <dolio> If you're not using GHC extensions.
04:57:11 <idnar> you have a handful of value types, and then everything else is an "object" (or whatever it's called)
04:57:19 <dolio> Let the compiler decide when you need to pass primitives by-value. :)
04:57:34 <idnar> java has object versions of all of the value types, I assume C# has something similar
04:57:38 <mapreduce> Value types are implicitly convertible to objects.  Thus you do let the compiler+language spec decide.
04:57:44 <vegai> hmm, I forget again. How do I import constructors again?
04:57:51 <vegai> @hoogle ReadMode
04:57:51 <lambdabot> System.IO ReadMode :: IOMode
04:57:59 <idnar> passing a value type is differen to passing an object reference, though
04:58:03 <vegai> like that, for instance. import System.IO (ReadMode) won't do
04:58:06 <Peaker> I guess if the size of something <= size of reference, it makes sense to pass by value to avoid the dereferences
04:58:10 <idnar> but you can't tell the difference unless you know that particular type is a value type
04:58:20 <mapreduce> idnar: That depends whether the object is immutable.
04:59:00 <mapreduce> I don't think one should try to make two terms mean the same thing just because he does not wish to understand pointers.
04:59:02 <idnar> well, if all objects were immutable, then the difference would be indistinguishable; but they're not
04:59:07 <dolio> Peaker: Yeah, that's why, for instance, GHC has Int# available, and why you might UNPACK things in your types.
04:59:24 <Peaker> dolio: can't the compiler do that size comparison automatically?
04:59:39 <idnar> maybe it's just my python background, but I find the inconsistency jarring
04:59:45 <dolio> Because storing an Int# directly in the allocated structure is more efficient than storing a pointer to a heap-allocated Int#.
05:00:06 <Peaker> idnar: I've gone from Python fan to Pretty Bored With Python in months of using Haskell :)
05:00:08 <dolio> Peaker: Well, it involves semantic differences.
05:00:13 <mapreduce> idnar: It's not an inconsistency; you can perfectly well treat an int as an object.
05:00:19 <Peaker> dolio: in Haskell? how come?
05:00:42 <Peaker> idnar: Python still has some advantages on the practical side, but even that margin is narrowing..
05:00:49 <idnar> Peaker: I'm no less of a Python fan than I ever was, but I certainly would prefer Haskell
05:00:53 <mapreduce> idnar: It's like complaining that 2 isn't a function, even though it is in the lambda calculus.
05:00:54 <idnar> Peaker: the practical advantages of Python in my case are huge, though
05:00:55 <dolio> Peaker: data Foo = Foo {-# UNPACK #-} !Int Bool is bottom if its first argument is bottom, but not if the second is.
05:01:13 <Peaker> I think if we had an   (forall a. eval :: String -> Maybe a)  or such, it would be pretty great
05:01:26 <Peaker> (note the forall a. is the caller's choice)
05:01:34 <Peaker> idnar: what are they?
05:01:51 <idnar> Peaker: it mostly boils down to libraries
05:02:03 <Peaker> dolio: that is the strictness annotation's doing, isn't it?
05:02:05 <idnar> Peaker: although the number of Python-capable people I work with is also a factor
05:02:32 <dolio> Peaker: Yeah, but you can't unpack into a structure unless it's strict.
05:02:33 <Peaker> idnar: I also use Python at work, its a C/Python shop.  I'm talking about less arbitrary merits :)
05:02:36 <idnar> Peaker: re: libraries, I'm talking about the big stuff, not the trivial stuff (which Haskell seems to be doing pretty well on these days)
05:02:45 <dolio> Peaker: How do you directly store an infinite loop, for instance?
05:02:50 <Peaker> idnar: what libraries are you missing?
05:03:15 <Peaker> dolio: what does the unpack mean? that instead of references to Foo, Foo is always copied in that place?
05:03:23 <idnar> Peaker: I make pretty heavy use of the Mantissa (/Axiom/Twisted/Nevow) stack
05:03:41 <Peaker> idnar: do you know how the Haskell web frameworks compare to that?
05:04:01 <dolio> Peaker: Yeah. For the Bool, the memory allocated for Foo stores a pointer to a heap-allocated Bool. For the Int, it stores the Int# inline.
05:04:02 <idnar> Peaker: they don't have anything resembling Athena, so far as I know
05:04:25 <jeffz> mapreduce: if you include in your vocabulary simple and composite objects, I think calling an int an object is less puzzling
05:04:33 <idnar> Peaker: I haven't really looked closely at their templating functionality, but that's somewhat secondary
05:04:34 <Peaker> idnar: what's Athena?
05:05:15 <Peaker> The difference between an "object" and a "value" is really just mutability. So an (IORef a) might be said to be a value denoting an object?
05:05:19 <idnar> Peaker: uhm, I guess these days it would be called a "Comet" implementation; it implements a bidirectional Python server / JavaScript client bridge
05:05:45 <Peaker> idnar: what does "bidirectional" Python server mean?
05:05:52 <mapreduce> jeffz: Sure.  You could also say that mutability forces some early optimisations (such as deciding between stack and heap objects) and should be avoided at all costs. :)
05:06:15 <idnar> Peaker: er, sorry, that's a bidirectional bridge between the web server (in Python) and the web browser (JavaScript)
05:06:18 <mapreduce> Peaker: I think 'mainstream' OO is tending towards immutable objects.
05:06:32 <idnar> Peaker: it lets you do asynchronous remote method calls in either direction
05:07:02 <Peaker> idnar: Why would you assume Haskell has no such thing?
05:07:39 <idnar> Peaker: I've never seen any mention of it, and I don't know of anything comparable in any other language, not just Haskell
05:08:17 <mapreduce> I saw a nice Scheme dialect that let you run the same code on either the client or the server over HTTP, but it was apparently quite slow.
05:08:45 <mapreduce> idnar: GWT is something comparable.
05:08:49 <Peaker> idnar: how do you call Javascript functions if the Javascript is doing something else at the same time?
05:09:08 <idnar> Peaker: well, it's asynchronous
05:09:40 <Peaker> idnar: when the Javascript side does anything with the connection, it gets runtime to actually read the requests from the other side and perform them?
05:09:51 <Peaker> (that's pretty much the RPyC model)
05:09:55 <idnar> Peaker: the way it's actually implemented is that the client makes an HTTP request to the server, and the server doesn't respond until it has a message to send to the client
05:10:12 <idnar> Peaker: (if the client needs to send a message to the server, it can just make a request, of course)
05:10:14 <mapreduce> It sounds quite like actors.
05:10:21 <Peaker> idnar: the server is always ready to serve client requests, that's easy. I'm wondering about requests that are on the opposite direction
05:10:40 <Peaker> idnar: the server wants to request something from the client, it can send it, but who's listening?
05:11:00 <idnar> Peaker: that's what I was referring to just now; the client makes a request, and the server doesn't respond right away
05:11:02 <Peaker> Or is the Javascript framework also a kind of reactor?
05:11:18 <idnar> when it has something to send, it sends it as the response to that "long" request
05:11:33 <idnar> and then the client makes another request
05:11:46 <Peaker> idnar: you're again referring to requests from the client to the server, right?
05:11:49 <idnar> right
05:11:54 <idnar> so there's always a request waiting for a response the server can use to send a message
05:11:56 <Peaker> idnar: I'm asking about requests from the server to the client
05:12:17 <idnar> Peaker: the client makes a request to the server so that the server can send a message
05:12:18 <Peaker> idnar: more specifically, when does the client see requests from the server, and when does he get "run time" to handle them?
05:12:32 <idnar> the server's "request" is sent as an HTTP response
05:12:43 <Peaker> idnar: so the client polls the server for requests
05:12:53 <idnar> right; but it's a "slow" polling, so it's relatively efficient
05:13:06 <Peaker> I hate the web
05:13:11 <idnar> yeah, it's pretty horrible :P
05:13:13 <Peaker> such a horrible platform
05:13:24 <idnar> anyhow, gotta go
05:13:25 <Peaker> I thought software in the 1990's sucked
05:13:41 <Peaker> but software in this decade is much worse..
05:13:47 <Peaker> see ya, idnar
05:15:07 <Peaker> instead of allowing API's to transcend a network semi-transparently, every functionality in existence was duplicated on top of a horribly convulted platform whose only advantage is being able to transcend a network
05:23:37 <Peaker> Is Category theory in use anywhere bug Haskell and similar PL's?
05:23:43 <Peaker> s/bug/but
05:32:28 <mapreduce> Peaker: It's everywhere if you look for it.
05:32:45 <mapreduce> I've heard Linq be referred to as C#'s monads, for example.
05:33:42 <Peaker> I don't think Linq is a monad in any meaningful way
05:34:15 <Peaker> Linq generates a view that you can write back to imperatively, for example
05:34:17 <mapreduce> It's a very rough translation of do-notation.
05:34:32 <Peaker> yucky SQL syntax for comprehensions
05:34:39 <mapreduce> linq generates whatever the hell the backend tells it to.
05:35:22 <chr1s> Peaker: Functor from category theory is called Enumerable in Ruby (Enumerable does a lot more)
05:35:43 <mapreduce> I wrote a QuickCheck-like backend for it.. from list in Lists.Of(Ints) where list.Reverse().Reverse() == list select Failures;
05:35:46 <Peaker> do only uses >>/>>= between "statements", Linq does something else, iirc
05:36:40 <Peaker> mapreduce: why not select those lists where its != instead of ==?
05:36:45 <mapreduce> Peaker: It translates to various method calls with lambdas.  What does a let within a do translate to?
05:37:06 <Peaker> mapreduce: it translates to a let where the rest of statements are within the "in"
05:37:11 <mapreduce> Peaker: I'd like to be able to specify more than one of those clauses.
05:37:26 <mapreduce> linq allows n where clauses and 1 select clause.
05:37:56 <mapreduce> I see (wrt let).
05:38:33 <LoneTech> Whoa, big channel. Hello.
05:38:53 <Peaker> well, it seems weird, because it seems like you filter based on some condition and then you select failures, but why are mismatching things failures?
05:39:11 <Peaker> 501xHello, LoneTech
05:40:41 <mapreduce> Peaker: I'm using where to specify what things should always be true.
05:40:53 <mapreduce> Peaker: Replace Failures with Summary if that makes it clearer for you.
05:41:05 <Peaker> mapreduce: doesn't where usually just filter things?
05:41:18 <mapreduce> Yes.
05:41:27 <mapreduce> That's what it's doing.
05:41:36 <lilac> Linq is more powerful than a monad, since it has access to an expression tree.
05:41:41 <Peaker> filtering and asserting are different things
05:41:56 <Peaker> mapreduce: it seems its asserting, not filtering
05:43:01 <mapreduce> lilac: You cannot write a method in C# that takes a 'ILinqable' or Monad and operates generally over it.
05:43:25 <Axman6> http://www.parallax.com/tabid/407/Default.aspx could have some interesting haskell applications...
05:43:26 <lambdabot> Title: Propeller General Information
05:43:32 <maltem> ghc question: Having realized that during a ghc build libedit hasn't been built, how do I get a ghci capable of line editing, without recompiling ghc entirely?
05:43:40 <mapreduce> It's just a thin syntax and is less powerful than a monad, because you can't abstract over its backends.
05:44:46 <LoneTech> I have a rather newbish problem, I think. I have a function that generates a very large list, which I then do filter and length on. Each item doesn't take much memory to generate, and I thought it would process them one at a time, yet the program grows to unmanageable size. Where should I start looking for a fix?
05:46:30 <Peaker> LoneTech: if you keep references to the beginning of one of your large lists, that might keep the whole list around even though you don't need it anymore
05:46:50 <Peaker> LoneTech: If your enclosing scope has the entire list inside a symbol name, that can cause that
05:46:59 <Peaker> LoneTech: can you paste the program?
05:47:07 <LoneTech> ah. so it's perhaps that the list itself is global?
05:48:05 <Peaker> LoneTech: yep
05:48:25 <LoneTech> thanks a lot
05:49:27 <Peaker> LoneTech: I am not an expert on profiling Haskell or getting good performance, so I am totally unsure that this is a good suggestion, but maybe you can hide that list behind a function that generates it, rather than a symbol. If it requires no arguments, maybe f () = <your list> will prevent caching the entire list
05:50:31 <LoneTech> or I just move its definition into a let..in for the only function that uses it.
05:52:28 <Ferdirand> ah, that sounds like something that was mentioned here earlier
05:52:45 <Peaker> LoneTech: if the entire computation is within a let, it is also going to cache the entire list
05:52:47 <LoneTech> hm, didn't do it.
05:52:57 <Ferdirand> if you first do a filter then a length
05:53:42 <Peaker> I wonder why   sum [1..]    kills the entire machine... Can't the foldr drop the references that aren't going to get used anymore when it recurses?
05:53:55 <opqdonut> Peaker: sum doesn't use foldr'
05:53:56 <Peaker> I mean, why isn't sum [1..] O(1) memory?
05:53:58 <opqdonut> by default
05:54:08 <opqdonut> define your own sum'
05:54:09 <Zao> Peaker: The first thunk is still around until the call is done?
05:54:27 <opqdonut> ?src sum
05:54:27 <lambdabot> sum = foldl (+) 0
05:54:35 <Peaker> Zao: so references are killed when thunks complete, instead of when thunks are done with them?
05:54:37 <opqdonut> > sum [1..100000]
05:54:39 <lambdabot>   5000050000
05:54:44 <opqdonut> > sum [1..100000000]
05:54:59 <lambdabot>   thread killed
05:55:00 <opqdonut> > foldr' (+) [1..100000000]
05:55:05 <lambdabot>   Not in scope: `foldr''
05:55:09 <Axman6> l*
05:55:12 <opqdonut> > foldl1' (+) [1..100000000]
05:55:15 <opqdonut> stupid me
05:55:21 <lambdabot>   5000000050000000
05:55:23 <opqdonut> there
05:55:37 <Peaker> > foldl' (+) 0 [1..1e78]
05:55:41 <Peaker> > foldl' (+) 0 [1..1e7]
05:55:44 <lambdabot>   5.0000005e13
05:55:52 <lambdabot>   thread killed
05:56:02 <Peaker> opqdonut: but I think a lazy foldr should also work
05:56:08 <opqdonut> no
05:56:13 <opqdonut> it keeps accumulating thinks
05:56:14 <BeelsebobWork> opqdonut: addition on integers is not the only thing that sum has to do -- lazyness may well be necessary in the output
05:56:28 <opqdonut> BeelsebobWork: exactly
05:56:29 <BeelsebobWork> i.e. you may have a Num instance which has a lazy (+) function
05:56:37 <opqdonut> that's the reason why sum is not foldl'
05:56:42 <BeelsebobWork> indeed
05:57:15 <Peaker> well, if foldr builds an outmost thunk that uses   (x + foldr (+) 0 xs), can't it already drop the reference to the (x:xs) pair?
05:57:30 <BeelsebobWork> it can
05:57:36 <BeelsebobWork> and will
05:57:43 <BeelsebobWork> assuming something else isn't using it
05:58:04 <Peaker> so  foldr (+) 0  does not keep the entire list its given in memory, but rather the entire (a+b+c+...) result thunk in memory?
05:58:14 <BeelsebobWork> yes
05:59:22 <LoneTech> how do I get length not to build something ridiculously large then?
05:59:36 <Peaker> It doesn't sound like complicated analysis to have the outer forcing of the whole foldr translate to forcing each (+) instead of building any thunks
05:59:46 <ziman> > foldr (\x xs -> (x-1):x:(x+1):xs) [1..]
05:59:48 <lambdabot>       Overlapping instances for Show ([a] -> [a])
05:59:48 <lambdabot>        arising from a use o...
05:59:57 <ziman> > foldr (\x xs -> (x-1):x:(x+1):xs) [] [1..]
05:59:58 <lambdabot>   [0,1,2,1,2,3,2,3,4,3,4,5,4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11...
06:00:05 <Peaker> LoneTech: can you paste your code?
06:00:18 <LoneTech> a moment
06:01:46 <LoneTech> http://hpaste.org/11985
06:03:16 <Peaker> nice, ghc -O2  indeed doesn't have insane memory use for forced sum [1..]
06:03:39 <MyCatVerbs> Peaker: which version? :)
06:04:19 <Peaker> 6.10
06:04:38 <Peaker> how do I get to see ghc's core output?
06:04:41 <LoneTech> guess I should upgrade
06:05:23 <MyCatVerbs> Peaker: -ddump-simpl.
06:05:32 <Peaker> LoneTech: no need,   sum [1..]   results in forcing a big lazy (+) expression, and ghc was smart enough to see that the (+) itself can be made strict.  But if you specify strictness where necessary it will work anyhow
06:05:54 <Peaker> MyCatVerbs: where does it go?
06:06:04 <MyCatVerbs> Peaker: ghc -O2 -ddump-simpl Foo.hs
06:06:10 <Peaker> MyCatVerbs: oh I tried it with --make
06:06:20 <MyCatVerbs> Er, my bad.
06:06:28 <MyCatVerbs> Peaker: ghc -O2 -ddump-simple --make Foo.hs :)
06:06:36 <MyCatVerbs> Peaker: but anyway, don't do that. :)
06:07:18 <Peaker> no it only works without --make
06:07:31 <MyCatVerbs> Peaker: grab ghc-core off Hackage instead. It pulls all the information that GHC makes available together in a nice format, with colour highlighting and everything.
06:07:55 <Peaker> MyCatVerbs: ah, cool, downloading
06:08:03 <MyCatVerbs> Peaker: IMO, much more readable. I personally can't cope with -ddump-simpl's output, but ghc-core is vaguely pleasant to use.
06:08:16 <Peaker> heh my Haskell examples thrashed _everything_ out of memory, so I see how long it takes to swap everything in
06:08:36 <Peaker> and its sooo much faster to swap firefox in that to run it from scratch and load the sites
06:08:41 <Peaker> s/that/than
06:08:54 <MyCatVerbs> Peaker: and then it's just ghc-core Foo.hs, it specifies everything (including -O2) the compiler needs to know.
06:09:04 <Peaker> so if instead of silly disk executables/etc we'd have all our "installed" programs running in "swapped out" form...
06:09:19 <Peaker> MyCatVerbs: so you can't see how the unoptimized one looks?
06:10:42 <MyCatVerbs> Peaker: you don't really want to.
06:10:42 <LoneTech> Peaker: I don't know how to specify strictness. all I really wanted was to count how many possibilities the filter picked out.
06:10:42 <MyCatVerbs> You can if you give -ddump-simpl to GHC without any optimization flags, but you'll soon notice that the code is absolutely horrible.
06:10:46 <hackage> Uploaded to hackage: obj 0.1.1
06:10:46 <hackage> Uploaded to hackage: classify 2008.11.13
06:11:17 <Peaker> MyCatVerbs: I don't understand the core code at all
06:11:36 <MyCatVerbs> I can't remember offhand whether ghc-core gives you any way to lower the optimization level or anything, though. I think it ought to, but I can't remember how.
06:12:08 <MyCatVerbs> Peaker: ah yes, that problem. Well. It's vaguely like Haskell, but the freakiest bit is that the IO monad is replaced with explicit world-passing.
06:12:09 <Peaker> main = return ()   -- results in a lot of code
06:12:27 <Peaker> using cast and sym
06:12:41 <Peaker> and ~
06:13:21 <MyCatVerbs> Peaker: the cast is to go from IO () to something like (RealWorld# -> (RealWorld#, a)).
06:13:50 <MyCatVerbs> Er, most of the casting is, I mean. Most of the casting that GHC puts in itself, even, assuming you're not unsafeCoercing things.
06:13:52 <Peaker> MyCatVerbs: why not pattern-unpack the IO instead?
06:14:00 <MyCatVerbs> Peaker: pattern-unpack?
06:14:11 <Peaker> assuming: data IO a = IO (RealWorld# -> (RealWorld#, a))
06:14:24 <Peaker> then just match the IO value against IO (theFunc)
06:14:30 <Peaker> instead of casting to theFunc
06:15:23 <quicksilver> my version of the core does just pattern-unpack the IO
06:15:28 <quicksilver> using case
06:15:42 <quicksilver> not sure what "cast" you're talking about
06:15:47 <quicksilver> (or was cast a type for case?)
06:16:07 <MyCatVerbs> Dunno. Deep compiler guts magic.
06:16:48 <Peaker> I get main = a `cast` (sym ((:CoIO)) ()) :: State# RealWorld -> ...
06:17:02 <MyCatVerbs> I would presume having the whole thing in world-passing style instead of unpacking the IO funcs makes analysis easier. At this stage, the code is all meant for machine consumption, not human consumption, after all.
06:17:23 <quicksilver> must be a post-6.6 change
06:17:31 <Peaker> quicksilver: you're using 6.6?
06:17:33 <quicksilver> yup
06:17:37 <Peaker> quicksilver: why so old?
06:17:48 <MyCatVerbs> Peaker: yeah. Ignore the cast and the sym crap, (it is meaningful but you can just safely assume that the compiler has gotten it right) and go look at the definition of a.
06:17:58 <quicksilver> Peaker: why not?
06:18:16 <quicksilver> what remotely interesting advantage does 6.8 or 6.10 have to me?
06:18:38 <Peaker> quicksilver: new optimizations and libraries?
06:18:51 <BeelsebobWork> quicksilver: reactive/field-trip
06:19:15 <MyCatVerbs> quicksilver: the compilation's a bit quicker. There are a few extra features. Some of the features have had bugs excised.
06:19:53 <MyCatVerbs> quicksilver: but if you're just hacking H98 or even H', and the speed isn't really worrying you, then I guess nothing much.
06:20:09 <Peaker> BeelsebobWork: its not fun to have reactive depend on the bleeding edge ghc, though, many libraries still don't compile on ghc 6.10
06:20:32 <BeelsebobWork> Peaker: yeh, but I don't think conal could make it compile in earlier versions
06:23:22 <quicksilver> BeelsebobWork: what does it need from 6.10 ?
06:23:41 <BeelsebobWork> quicksilver: vector-space requires type-families
06:23:43 <quicksilver> Peaker: I've not yet wanted a library that didn't compile fine under 6.6
06:23:47 <quicksilver> BeelsebobWork: ah.
06:24:04 <quicksilver> Peaker: as there come to be more of them, I suppose I might be inclined to move.
06:24:21 <Peaker> quicksilver: what about the performance boosts?
06:24:26 * quicksilver shrugs
06:24:33 <quicksilver> 10% ~ nothing
06:24:45 <quicksilver> I very seldom do anything where I'd even notice a 10% boost ;)
06:25:03 <BeelsebobWork> does 6.6 even have ByteString?
06:25:08 <BeelsebobWork> I thought back then it was FastPackedStrings
06:25:09 <quicksilver> yup.
06:25:14 <BeelsebobWork> or is that 6.4?
06:25:14 <quicksilver> nope :)
06:28:26 <dolio> There was a separate bytestring package for 6.6, though, I believe.
06:29:57 <quicksilver> dolio: it came with my macports install
06:37:07 * byorgey waves good morning
06:54:55 <akatsuki> afternoon, #haskell
06:56:35 <byorgey> hi there akatsuki
07:03:19 <akatsuki> byorgey: hi.
07:17:15 <rog> is there a good reference somewhere for type equality constraints? i've was looking at http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#id2695622 and "class (F a ~ b) => C a b where type F a" seems like gobbledygook to me... what does that type declaration with no "=" mean?
07:17:17 <lambdabot> Title: 8.7.�Type families, http://tinyurl.com/5wl4j2
07:18:15 <dolio> It means for each instance of the class, you have to define what the type is.
07:18:40 <rog> ok. is that an extension, or just a feature i haven't come across yet?
07:18:57 <dolio> It's an extensions. Part of type families.
07:19:28 <dolio> Technically, when it's written like that, it's covered by the old 'associated types' idea.
07:20:08 <dolio> But associated types can be turned into a type family that isn't actually part of the class.
07:21:02 <rog> is knowledge of associated types a prerequisite to reading about type families?
07:21:02 <dolio> 'class Foo <types> where { type Bar <types> ; ... }' ==> 'type family Bar <types> ; class Foo <types> where { ... }'
07:21:15 <akatsuki> is it assumed that functional programming is a lot more challenging than procedural programming? or is it just a different methodology?
07:21:31 <rog> akatsuki: it is by me!
07:21:38 <dolio> I wouldn't say so. Type families are just a generalization of the old associated types idea.
07:21:55 <idnar> Peaker: the nice thing in this case is that if we ever get a more sane browser API for sending data around, Athena can switch to using it without applications needing to care; hooray abstraction :)
07:22:04 <idnar> (excuse the discussion necromancy)
07:22:17 <dolio> Associated types were the old competitor to functional dependencies, although they couldn't strictly cover all the use cases without some of the extra stuff type families introduce.
07:22:32 <rog> is there a good "from scratch" guide anywhere?
07:22:36 <maltem_> akatsuki: Actually FP is _supposed_ to be easier (i.e. higher-level) than procedural programming
07:22:57 <idnar> maltem_: of course, that makes it more complex
07:23:07 <rog> maltem_: i don't think higher level implies easier...
07:23:33 <dolio> akatsuki: I think most people acknowledge that functional programming is harder to get once you've already learned an imperative mindset, which is the case for most people.
07:23:45 <maltem_> idnar, right. rog, well, "easier" is the motivation for "higher-level". it may fail at that under some circumstances
07:23:46 <idnar> I would probably agree that it's "more challenging"
07:24:03 <dolio> Whether or not it's harder for completely unspoiled people is more of an open question.
07:24:09 <idnar> but because it's higher-level, there's more conceptual complexity
07:24:13 <idnar> just because there's more involved
07:24:23 <rog> maltem_: i thought expressivity was the goal.
07:24:31 <maltem_> idnar, true
07:24:34 <idnar> having to relearn everything you thought you knew about programming doesn't help, of course
07:24:58 <idnar> but I think a language like Haskell is going to require more learning effort than, say, Python, even if you're starting from scratch
07:24:59 <rog> the thing i find hardest is the endless multiplication of abstractions
07:25:05 <maltem_> rog, and what does expressivity serve, in turn?
07:25:07 <idnar> not because it's harder to learn, but because there's more to learn
07:25:32 <akatsuki> rog: you mean recursion?
07:26:00 <akatsuki> does this 'learnyouahaskell' book come recommended?
07:26:01 <conal> idnar: i'd have expected "because it's higher-level, there's *less* conceptual complexity"
07:26:16 <akatsuki> (and is it only in its html-webpage form?
07:26:17 <rog> akatsuki: no, i mean monads, arrows, type families, functional dependencies, type classes, ....
07:26:21 <idnar> conal: well, there's complexity and there's complexity
07:26:29 <EmielRegis> indeed
07:26:29 <akatsuki> rog: ah, i've heard of monads.
07:26:44 <idnar> conal: at a higher-level, you have the simplicity of "elegance"; you're not swamped in thousands of "details", because you can express your program more concisely
07:26:49 <C-Keen> Cale: I ran runhaskell Setup configure for lambdabot and it complains about missing dependencies even after I installed them with cabal install... How can I find out which package of the list is causing trouble?
07:26:57 <rog> akatsuki: with lower level languages, you can get by with a few primitives and very few named abstractions
07:27:02 <idnar> conal: at the same time, because you're working at a higher level, there are far more concepts and abstractions underpinning that concise program
07:27:02 <C-Keen> sorry I guess this is more of a cabal question
07:27:08 <dcoutts> C-Keen: try adding --user
07:27:11 <EmielRegis> idnar, the real reason is that you probably know some procedural (or imperative) languages and transition to functional is hard - like its for me
07:27:19 <C-Keen> dcoutts: to where?
07:27:22 <dcoutts> C-Keen: or use cabal configure instead of runghc Setup configure
07:27:30 <conal> idnar: oh -- the code is more conceptually *dense*.
07:27:36 <C-Keen> dcoutts: ah!
07:27:37 <dolio> rog: You can get by without learning all that in Haskell. It's just less fun. :)
07:27:41 <idnar> it's like the difference between pen and paper, and a computer
07:27:50 <mapreduce> EmielRegis: This can be helped by trying to program functionally in your original language.
07:27:56 <conal> idnar: more think per line.  i get it.
07:28:00 <dcoutts> C-Keen: to a first approximation cabal configure == runghc Setup configure --user
07:28:04 <idnar> EmielRegis: that's a separate problem, really
07:28:08 <rog> maltem_: expressivity might make it easier for a pro to write programs; but it doesn't mean that it's necessarily easier to learn to do so
07:28:15 <mapreduce> That helps to learn FP, and to learn how bad your original language is. :)
07:28:45 <C-Keen> dcoutts: thanks!
07:28:45 <rog> dolio: you can't get by without at least a good few of those things in haskell and still have the same power that you do in other languages...
07:28:46 <idnar> EmielRegis: it probably took me about 6 months to find out almost everything there was to know about Python, speaking in very broad terms
07:28:54 <maltem_> rog: yeah I see the point. there's easy and there'e easy :)
07:28:56 <Peaker> idnar: Of course one can create a decent platform that can compile down to be a web app or even a local app. I don't think anyone has done this yet.  Perhaps Phooey is close, but I think a DSL needs to be non-monadic and possibly not even a Functor if its going to be compilable to Javascript
07:29:01 <idnar> EmielRegis: that's not to say that I was a Python guru after 6 months, but I was at least vaguely familiar with everything there was to know
07:29:31 <Peaker> idnar: Unless someone writes a Haskell compiler to Javascript, then you can probably use monadic libraries too
07:29:32 <idnar> EmielRegis: I've been exploring Haskell (and the FP world in general) for more than 6 months now, and I've barely scratched the surface
07:29:33 <EmielRegis> but python is imperative too. it only has some functional features, arent I right?
07:29:53 <EmielRegis> mapreduce, or trying to convert imperative to functional
07:29:54 <idnar> there are just so many more ideas involved
07:30:00 <EmielRegis> which i am trying to do now :p
07:30:01 <dolio> rog: The only things you mentioned that you need regularly to match other languages are monads and type classes. And it's arguable whether you really need to get monads in general to use the few that are 'totally necessary.'
07:30:12 <maltem_> Peaker: the yhc folks have a prototype of Haskell to javascript compiler I think
07:30:20 <idnar> Peaker: actually, the nice thing about Athena is that it doesn't try to "compile" to JavaScript
07:30:26 <idnar> Peaker: your client-side code is written in JavaScript directly
07:30:38 <baaba> python supports a somewhat limited form of closures, function values are first class and there are extremely limited lambda expressions
07:30:45 <baaba> but that's about it
07:30:45 <idnar> Peaker: I mean, it might be nice to work in a better language than JavaScript, but most of the "translation" layers are very incomplete and lossy
07:30:51 <EmielRegis> ye
07:31:04 <idnar> Peaker: which makes them somewhat impractical for serious projects at this point in time
07:31:18 <Peaker> idnar: but it sucks to have to  rewrite the code in a different language  just to move its execution from one place to another
07:31:20 <idnar> EmielRegis: so, sure, maybe I'm still not used to thinking in a functional style
07:31:22 <akatsuki> baaba: i read somewhere that llvm has implemented closures for C, called 'Clang' which is pretty nice, i suppose. ;\
07:31:28 <vegai> hey. Besides Dragon book, what to read for getting uber interpreter-writing skillz?
07:31:35 <EmielRegis> well, the best teacher is practice imo - I eventually learn C++'s *virtually* every single concept, not by reading books but by coding myself in a complicated enviroment
07:31:37 <idnar> EmielRegis: but aside from that, there are just so many new ideas out there to explore, compared to the shallow pool of ideas in the imperative languages I've used
07:31:43 <rog> dolio: it's not about what is totally necessary - it's about leveraging the power of the language in an appropriate way... (and it's also about using the existing libraries)
07:31:44 <Peaker> maltem_: what's yhc?  also, do they support the useful ghc extensions?
07:31:55 <Twey> 152931 < Peaker> idnar: Unless someone writes a Haskell compiler to Javascript, then you can probably use monadic libraries too
07:32:00 <baaba> akatsuki, Clang is a new in-progress frontend for c/c++/objc that uses llvm as its backend
07:32:02 <Twey> Peaker: There's already one in Yhc
07:32:11 <baaba> akatsuki, and yes they have a C closure extension
07:32:15 <wjt> @pl \xs -> zip (map f xs) xs
07:32:15 <lambdabot> zip =<< map f
07:32:21 <idnar> it's certainly possible to think about, say, monads in python, but it's so awkward that it's not worth bothering with
07:32:23 <Twey> Oh, sorry, was scrolled a little up
07:32:32 <wjt> is not very clear; is there a sensible points-free way to do that other than with Monad [] ?
07:32:35 <idnar> Twey: how well does that actually work?
07:32:41 <maltem_> Peaker: York Haskell compiler, I think. and no, I don't think they support everything under the sun, it's a fork of nhc and doesn't share much code with ghc
07:32:41 <wjt> > join (zip . map (+1)) [1..5]
07:32:42 <lambdabot>   [(2,1),(3,2),(4,3),(5,4),(6,5)]
07:32:45 <Twey> Javascript's a pretty decent language, though.  Functionally.
07:32:55 <wjt> muahaha, Monad (r ->) strikes again
07:32:57 <mapreduce> Would it be more awkward to think about monads in Python than in Scheme?
07:33:00 <Twey> Its OO is painful, but if you want to write functional code, it's good.
07:33:00 <idnar> Twey: there are two typically problematic areas when it comes to foo-to-JavaScript translators or compilers
07:33:10 <rog> monads are straightforward in an language that support garbage collection and closures. although it really helps to have proper type checking too...
07:33:13 <Twey> idnar: As I understand it, pretty well
07:33:16 <idnar> Twey: 1) integrating with "native" JavaScript code, and 2) preserving the semantics of the source language
07:33:16 <EmielRegis> To be honest I consider imperative languages like C++ more 'natural' to write in, while functional ones more closely resemble mathematic entities (like they should be)
07:33:20 <mapreduce> Twey: Except the lack of typing.
07:33:27 <idnar> I'd expect Yhc to do fairly well on 2), but I'm curious about 1)
07:33:39 <dolio> wjt: map (f &&& id) xs
07:33:55 <EmielRegis> and although I consider imperative to be generally easier and more effective, i can see cases where using functional ones ends with less "bloated" programs
07:33:59 <Twey> mapreduce: I'd rather have weak typing than strong-typing-done-wrong (*cough*Java*cough*)
07:34:07 <wjt> dolio: even clearer given that i've used (&&&) elsewhere in this file. thanks
07:34:24 <baaba> mapreduce, you mean dynamic vs static?
07:34:24 <idnar> EmielRegis: I find it easier to "lossily" express a program in an imperative language
07:34:29 <baaba> errrr
07:34:32 <Peaker> EmielRegis: when you learn about programming from the operational P.O.V, which is perhaps how most people learn, then something closer to the way the metal works (e.g C++) is going to seem more "natural" (actually, its just more familiar).  But when you want to learn about the most concise and least error-prone to describe programs, then a pure FP is probably more "natural"
07:34:35 <baaba> s/mapreduce/Twey/
07:34:41 <mapreduce> baaba: Type-checked versus not.
07:34:47 <idnar> EmielRegis: but for a clear concise expression of that programming, I find that a functional programming language is far superior
07:34:51 <mapreduce> You can say that's static versus dynamic if you like.
07:35:01 <rog> i think one of the hardest things about haskell is knowing when to use the type system and when not to.
07:35:05 <Twey> baaba: I actually meant strong vs. weak, but that works too
07:35:06 <Peaker> EmielRegis: if you "start" with assembly and work from there, the evolution to Java and others is very "natural"
07:35:06 <baaba> yes sorry i was supposed to ask that from Twey not you :)
07:35:09 <idnar> EmielRegis: to put that another way, it's easier to write mediocre programs in an imperative language, while a function language makes it easier to write awesome programs :)
07:35:23 <idnar> Peaker: heh, that's debatable
07:35:25 <Peaker> EmielRegis: If you start with mathematics and UI design and work from there, then pure FP is the natural end result
07:35:25 <mapreduce> baaba: Yes, weak and strong are poor terms.
07:35:29 <EmielRegis> peaker, yes thats what I meant by bloated
07:35:37 <rog> ... because the type system is so powerful you *can* do all sorts of wonderful things with it. but it's not necessarily a good idea.
07:35:43 <idnar> Peaker: I find x86 assembly more "natural" to program in than C, and I learned C first
07:36:00 <Peaker> idnar: C is just a set of useful macros over assembly :-)
07:36:01 <rog> Peaker: Java is unnatural
07:36:12 <Peaker> Yeah, I shouldn't have said Java, its probably a bad example ;)
07:36:13 <EmielRegis> assembly is natural because thats how computer works :p
07:36:18 <idnar> Peaker: it's also a set of restrictions, though; and you don't get enough back in return
07:36:22 <EmielRegis> but working in assembly is certainly not very productive
07:36:25 <Peaker> EmielRegis: You realize that computers are made to work however we make them work? :)
07:36:32 <mapreduce> You can do good stuff in Java if you can tolerate unreadable source.
07:36:35 <EmielRegis> peaker, yes
07:36:38 <mapreduce> See Functional Java.
07:36:50 <rog> mapreduce: the same could be said of COBOL
07:36:55 <idnar> hopefully I'll never have to do anything in Java :)
07:37:05 <baaba> simply adding a good closure syntax to java would make it so much more bearable
07:37:06 <mapreduce> rog: Can you implement HList in COBOL?
07:37:09 <EmielRegis> but for example, in languages like haskell, where compiler pretty much takes care of any optimization there is little space to learn how to write good and fast programs in terms of how hardware works
07:37:13 <conal> EmielRegis: "We must never confuse what is natural with what is habitual" (Gandhi)
07:37:14 <baaba> a little more type inference wouldn't hurt either
07:37:19 <EmielRegis> which is easier in C/C++ imho
07:37:21 <mapreduce> baaba: There is a prototype compiler for closures.
07:37:25 <rog> basically in Java, you're constantly battling against a fundamentally badly designed type system
07:37:26 <Peaker> EmielRegis: if you were programmed to think in sequences of computer "commands", then imperative will seem familiar. I think someone who knows *nothing* about programming, might find FP just as natural a way to describe computations as imperative, not only more productive
07:37:44 <rog> mapreduce: i wouldn't recommend using HList even in haskell.
07:37:44 <baaba> i know, but that's hardly in my reach writing software at work
07:38:01 <EmielRegis> well, I dont really know about productivity of FP. It sure seems a lot more strict than imperatives
07:38:02 <idnar> Peaker: I would say that I find FP because of my mathematical background
07:38:02 <baaba> when there's an official release then it'll go in consideration
07:38:10 <EmielRegis> its all a matter of good design imho
07:38:12 <Twey_> I agree with idnar.  Imperative programs are kind of like PHP: so long as you don't mind writing crappy code, you're OK with just copying-and-pasting blocks of code sometimes, and you have no problem with writing a whole bunch of lines to perform a simple operation, imperative gets in your way less.  On the other hand, if you try to be clever in imperative languages, they'll always make you go the long way around.
07:38:16 <EmielRegis> not particularly coding style
07:38:27 <idnar> Peaker: except my mathematical background basically consists of reading GEB, so I'm not sure I qualify
07:38:34 <idnar> err, *find FP natural
07:38:37 <Peaker> idnar: I don't have much math background, but I kinda re-invented FP for my project until I decided that I should take a look at what others have done...
07:38:44 <conal> idnar: also you may have been draw to both math and FP for the same reason.
07:38:48 <osfameron> Twey_: you are aware that many "imperative" languages allow you to do declarative things too? ;-P
07:38:53 <Twey> FP usually allows more natural expression of purer algorithms
07:38:59 <EmielRegis> indeed
07:39:00 <idnar> Twey: PHP is perhaps the perfect example of maximizing "crappy" productivity over "good" productivity
07:39:12 <EmielRegis> however, some algorithms are much easier to write in imperatives than in FP
07:39:13 <Twey> osfameron: That's not imperative, that's multi-paradigm :)
07:39:16 <EmielRegis> take complex data structures for example
07:39:19 <idnar> PHP makes it really really really easy to just bang out some crap that maybe works on a thursday when the moon isn't full
07:39:21 <EmielRegis> working with C++ classes is pure fun
07:39:26 <Twey> idnar: Aye
07:39:28 <EmielRegis> while to get something similar working in FP takes ages.
07:39:36 <idnar> and a lot of people are happy to settle for that, thus PHP is popular
07:39:39 <osfameron> Twey: ok, that's an issue if you're slagging off COBOL, or to a lesser extend C
07:39:49 <conal> EmielRegis: takes *who* ages?
07:39:52 <ziman> i'd say data structures is an area where haskell excels
07:39:52 <idnar> but if you want to program nuclear missile control software... PHP is probably not your tool
07:39:53 <Peaker> EmielRegis: Haskell has lots of room to learn about how to write fast executing programs, by learning about strictness and what optimizations  are possible
07:39:56 <EmielRegis> me :P
07:39:59 <osfameron> but PHP is marginally more functional than either of those (don't get me wrong, I'm not defending PHP...)
07:40:01 <rog> the other hardest thing in haskell is reasoning about its efficiency. imperative languages generally have an easy-to-understand relationship between code and run-time behaviour. efficiency of haskell programs can vary wildly depending on compiler optimisations.
07:40:11 <mapreduce> The main reason PHP sucks is that it doesn't have lexical scope as a default, afaik.
07:40:13 <ziman> all pattern matching and stuff...
07:40:15 <Twey> osfameron: In the case of those that do allow declarative operations, I'm of course only talking about the pure imperative parts.
07:40:16 <idnar> conal: yeah, that's probably true
07:40:18 <maltem_> EmielRegis: What examples qualify as "complex data structures"?
07:40:19 <EmielRegis> conal: and generally results in a lot more code than in C++
07:40:32 <conal> EmielRegis: results for whom?
07:40:33 <mapreduce> maltem_: Hashtable will do.
07:40:41 <EmielRegis> maltem_, for example im writing a ray tracer now, or rather trying to write a copy of one written in C++
07:40:47 <idnar> conal: it's actually somewhat amusing; I went through the whole of high school and partway through a stupid Computer Science degree (before I dropped out)
07:41:05 <EmielRegis> a vector in C++ with all operations and shit takes 2 minutes to write
07:41:08 <idnar> conal: and I could never understand why maths was paired so heavily with programming, they didn't seem to have anything to do with each other for the most part
07:41:21 <idnar> conal: later, I discovered FP, and suddenly it made a lot more sense
07:41:24 <baaba> idnar, you're kidding me?
07:41:27 <baaba> ah heh
07:41:30 <maltem_> EmielRegis: Well copying a C++ program to Haskell may be what makes things complex
07:41:41 <ziman> copying design patterns from c++ to haskell doesn't pay off, really :)
07:41:44 <akatsuki> idnar: isn't math greatly paird with functional programming?
07:41:45 <conal> idnar: cool :)
07:41:47 <EmielRegis> while in Haskell you need to mess with extending Eq class, overriding (+) with some hacky ways (because it cannot decide whether its yours + or prelude +)
07:41:48 <Peaker> EmielRegis: I wrote a ray tracer in Haskell, my friend wrote one in C++, mine was 30% shorter or so
07:41:48 <EmielRegis> etc
07:42:01 <Peaker> EmielRegis: you're doing it wrong ;p
07:42:05 <mapreduce> I learned to program and thought maths and programming were closely related, then did a CS degree and believed the opposite because of how vague OOP was.
07:42:09 <EmielRegis> maltem_, yea I thought about it too
07:42:11 <mapreduce> Now I've come to my senses.
07:42:14 <EmielRegis> but I jsut use general algorithms
07:42:18 <idnar> akatsuki: I don't think any of my teachers or lecturers had ever heard the words "functional programming"
07:42:40 <EmielRegis> peaker, probably, I couldnt get it to work so i abandoned overriding (+) and used custom vecAdd function instead
07:42:42 <maltem_> EmielRegis: and your problems sound like you're not familiar with the standard lib yet, while you're probably quite familiar with C++ libs
07:42:42 <akatsuki> idnar: i read some hs src for the first time today; its out of this world.
07:42:56 <Peaker> EmielRegis: Vectors aren't really Num instances
07:43:03 <Peaker> EmielRegis: but if you want (+) you want to be a Num
07:43:06 <wjt> @dj [(a,b)] -> ([a],[b])
07:43:06 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver . ? @ bf ft id pl rc v wn
07:43:12 <wjt> @hoogle [(a,b)] -> ([a],[b])
07:43:12 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
07:43:12 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
07:43:16 <chr1s> EmielRegis: you can define your own operators, for example, <+>
07:43:17 <idnar> baaba: there was boolean algebra, of course; but for example, I couldn't figure out what a function in a programming language had to do with the mathematical concept of a function
07:43:18 <wjt> oh, duh.
07:43:19 <EmielRegis> uhm
07:43:19 <Peaker> EmielRegis: You can have Vector be a Num instance anyway, and you won't be bitten by it probably
07:43:23 <chr1s> that makes building DSLs a lot nicer
07:43:31 <baaba> idnar, ah right
07:43:38 <baaba> poor nomenclature :)
07:43:41 <rog> the *other* thing i've found hardest about haskell is interpreting the compiler's error messages.
07:43:42 <baaba> should be "procedure"
07:43:47 <idnar> baaba: heh
07:43:54 <conal> idnar: also "variables" in programming are unlike "variables" in math.
07:43:57 <baaba> and "some procedures are also functions"
07:43:59 <idnar> conal: yeah, that too
07:44:01 <chr1s> rog: same here, but it just takes some getting used to.
07:44:01 <kohwj> idnar: many schools still using java and .net
07:44:02 <EmielRegis> well I know that many of those issues come from me being noob in Haskell, however I just find it harder to get acquainted with than with imperative languages - when I first start to write some code
07:44:04 <conal> idnar: i mean variables in *imperative* programming.
07:44:16 <_pizza_> as far as data structures goes, extracting members of a tuple seems too ugly in Haskell, i.e. foo@(_,_,_,_,_,_,_,_,_,whatiwant,_) is there a better way to do that?
07:44:21 <Twey> EmielRegis: It really does just sound like an experience issue
07:44:24 <idnar> conal: now that I know about FP, the naming at least makes some sort of sense
07:44:33 <Twey> EmielRegis: When you get used to how we do things in Haskell, it'll all be better :)
07:44:34 <idnar> conal: although I still don't think about maths much when I'm writing imperative code
07:44:45 <EmielRegis> Twey, I hope so too ;)
07:44:54 <baaba> _pizza_, write a dsl in template haskell so you can use a number instead ;)
07:44:54 <bryan1> _pizza_: create a type
07:44:56 <chr1s> EmielRegis: programming in Haskell is really different from imperative programming, don't expect to build the same program in FP as quick or as beatiful as your favorite language.
07:44:57 <Twey> rog: Generally it's sufficient to just grab the line number and examine that line carefully, I find
07:45:03 <ski_> _pizza_ : use records
07:45:09 <idnar> _pizza_: ideally one would avoid having such large tuples; use records or something
07:45:20 <chr1s> EmielRegis: however, once you get to know Haskell, there are lots of things that you can do in a much cleaner way
07:45:21 <_pizza_> ok, i'll take a look at records
07:45:27 <chr1s> EmielRegis: but it's also a matter of taste
07:45:31 <_pizza_> bryan1: do types have named members?
07:45:31 <conal> idnar: have you read backus's "Can Programming Be Liberated from the von Neumann Style? ... " paper?  www.stanford.edu/class/cs242/readings/backus.pdf
07:45:42 <rog> Twey: that's not what i've found... and often, the error refers to the whole function (e.g. cannot generalise g a to a)
07:45:42 <idnar> conal: don't believe I have
07:45:46 <EmielRegis> chr1s, yea. and what you want to really do
07:45:51 * idnar grabs that to read later
07:45:54 <Twey> _pizza_: Yes, kind of.
07:45:56 <bryan1> _pizza_: I meant records.. have a look
07:46:05 <chr1s> EmielRegis: yes, but just remember that it takes quite a lot of learning
07:46:08 <EmielRegis> I mean, there is a reason why virtuall every OS or 3d Game is written in C/C++ and not in Haskell :P
07:46:16 <Twey> rog: A good debugging method in those cases is to add type signatures to *everything*
07:46:17 <idnar> it seems like some people want to divorce programming from mathematics even further, though
07:46:20 <mapreduce> EmielRegis: You might be best off using Haskell as a posh calculator first.
07:46:21 <bryan1> _pizza_:http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
07:46:23 <lambdabot> Title: Chapter 3. Defining Types, Streamlining Functions, http://tinyurl.com/67rtex
07:46:28 <mapreduce> EmielRegis: Or reading the above book.
07:46:29 <conal> idnar: it's gem!  talks about the essential reason imperative programming doesn't compose well and offers (a flavor of) functional programming as a compositional alternative.
07:46:34 <Twey> It helps you understand where it goes wrong, and if it doesn't, it'll help the compiler :)
07:46:39 <chr1s> EmielRegis: for example, I had a hard time understanding IO in Haskell, but once it "clicked" I didn't want to do it any other way anymore
07:46:39 <EmielRegis> well mapreduce
07:46:45 <EmielRegis> my lecturer is philip wadler
07:46:45 <rog> Twey: that's really inconvenient inside a function. you have to use scoped type variables.
07:46:46 <_pizza_> bryan1: thanks
07:46:50 <bryan1> np
07:46:50 <mapreduce> EmielRegis: Heh.
07:46:53 <Peaker> EmielRegis: Learning Haskell was harder for me too.  Its got a very different syntax and very very different semantics.  Most other language I knew shared a lot more semantics
07:46:53 <EmielRegis> :P
07:46:54 <chr1s> EmielRegis: http://www.haskell.org/haskellwiki/Frag
07:46:56 <lambdabot> Title: Frag - HaskellWiki
07:46:59 <Peaker> EmielRegis: so there simply was more to learn
07:47:08 <Peaker> EmielRegis: the paradigms/right way to do things change too
07:47:18 <conal> EmielRegis: "there's a reason that ..." is always true.  i suspect the reason isn't what you assume it is.
07:47:21 <EmielRegis> and i have a book that he claims is good enough... but for my taste there is too much mathematical bullshit in the book, in forms of 'why lists to work using induction'
07:47:29 <EmielRegis> I would rather like to have practical examples...
07:47:34 <rog> Twey: (i always add type signatures to top level functions, though...)
07:47:48 <Twey> rog: Not just top-level functions: *everything*
07:47:55 <idnar> EmielRegis: the reason for most choices of language/library/compiler/etc.etc. is usually "familiarity"
07:48:03 <EmielRegis> chr1s, I saw that already
07:48:06 <Peaker> conal: I think that before FRP, Functional Programming did not offer anything that convincing as an alternative to imperative programming. Sure, partitioning the program into a separate pure part is nice, but you can do that by convention too
07:48:10 <jeffz> chr1s: is Frag really worth pointing out when people say there are no 3d games written in Haskell?
07:48:13 <EmielRegis> still exception proves the rule
07:48:19 <Peaker> conal: and FRP is not yet super-mature yet :)
07:48:25 <Peaker> s/yet yet/yet
07:48:31 <rog> Twey: what, like ((x :: a) + (y :: a) :: a) etc?
07:48:33 <idnar> FRP is a really really awesome concept
07:48:35 <EmielRegis> show me a single successful, commercial 3d Game engine written in Haskell and we'll talk
07:48:38 <EmielRegis> ;)
07:48:50 <conal> Peaker: yep.  a really practical replacement to imperative programming (including in Haskell) is a work in progress.
07:48:51 <Twey> rog: Aye
07:48:55 <mapreduce> EmielRegis: Why are you concerned with commercial 3D game engines?
07:49:02 <ski_> exceptions disprove rules
07:49:06 <rog> Twey: it's a pity you can't do that in standard haskell...
07:49:12 <EmielRegis> mapreduce, because I am a game programmer primarily and I want to pursue this career further too :P
07:49:14 <idnar> EmielRegis: modern 3D engines are written in HLSL :P
07:49:19 <Peaker> EmielRegis: When FRP matures, and becomes mainstream, that will change :-)
07:49:23 <mapreduce> They are generally not particularly interesting; people 'program' them by dragging and dropping stuff a lot.
07:49:26 <Twey> EmielRegis: Games are written in C because OSes are written in C.  OSes are written in C because a) CPUs are currently basically imperative beasts and b) efficient FP wasn't popular at the times when OSes were designed
07:49:29 <EmielRegis> idnar, HLSL? the shader languages? no they arent :p
07:49:39 <Twey> Both a) and b) are changing :)
07:49:41 <mapreduce> Peaker: FRP is what 'binding' is based on in JavaFX.
07:49:44 <idnar> EmielRegis: that's a horrible overexaggeration, but that is where most of the heavy lifting happens these days
07:49:45 <conal> Peaker: thx for the vote of confidence!  :)
07:49:52 <mapreduce> The language spec references fudgets, for example.
07:49:59 <Peaker> mapreduce: Yeah, but it only uses "FRP" for the "view" part, not the modify part
07:50:04 <camio> Does anyone know of built-in typeclass that has 'pure' but without the (<*>) operator? Just a singleton like thing.
07:50:09 <EmielRegis> Twey, I cant see CPUs design changing to functional any time soon :P but I agree about the historical convention to write in C
07:50:14 <mapreduce> Peaker: I thought it used it for modify.
07:50:14 <idnar> there's really not that much high-performance code executing on the CPU that's from the game engine itself
07:50:32 <Twey> rog: Don't worry too much about sticking to '98.  Nobody does entirely.  If you want to follow a standard, work to Haskell', such as it is
07:50:34 <idnar> it's all in libraries or on the GPU
07:50:35 <conal> camio: and any properties?
07:50:41 <EmielRegis> idnar, yea, thats only part of graphics. I meant whole engine, from file system, through game logic with graphics eventually
07:50:58 <Peaker> conal: The progress is convincing :)  Also, I have been looking for how to implement declarative reactive systems for ages and have only managed to solve as far as the JavaFX guys did. Your event/reactive combinators is what I failed to find for quite a while
07:50:59 <idnar> EmielRegis: the filesystem is written in C, because that's what Linux and Windows are written in
07:51:07 <chr1s> EmielRegis: you don't *have* to use Haskell if don't want to
07:51:08 <rog> oh yes, another hard thing in haskell is that when something does go wrong, it's very difficult to find out why. in other languages a stack trace tells you a lot. haskell doesn't work that way.
07:51:13 <mapreduce> EmielRegis: I think what you describe should be your project.
07:51:20 <idnar> EmielRegis: there's no reason you couldn't rewrite it all in Haskell, but there are probably better things to do with your time
07:51:24 <conal> Peaker: :)
07:51:30 <EmielRegis> indeed idnar
07:51:30 <chr1s> EmielRegis: it's just that we are having lots of fun doing it, and I think you can have that too.
07:51:39 <rog> Twey: is there a spec for Haskell' somewhere?
07:51:41 <Peaker> mapreduce: No, they still use completely imperative event callbacks that destructively update values, and let the changes propagate from there
07:51:45 <EmielRegis> chr1s, yea, thats what coding is all about isnt it :D
07:51:47 <camio> conal: I'm not sure. I'm trying to write a collection thing for reactive: collectE = monoidE . fmap pure. That'll work for lists alright, but not for Seq since it doesn't have an applicative.
07:52:00 <mapreduce> EmielRegis: When you've programmed for a little while, within certain bounds, you can pretty much tackle anything.
07:52:01 <EmielRegis> mapreduce, what exactly? writing a 3d game in haskell?
07:52:04 <idnar> EmielRegis: honestly, I don't think CPU design has to change much
07:52:05 <chr1s> EmielRegis: yes. Once I started doing Haskell, I was starting to have lots more fun.
07:52:06 <mapreduce> Yes.
07:52:24 <EmielRegis> lol
07:52:28 <mapreduce> EmielRegis: Thus it's not greatly interesting *whether* you can write a 3D game in Haskell, because you can.
07:52:29 <conal> camio: where does the Applicative come from?
07:52:29 <EmielRegis> maybe for my masters
07:52:33 <conal> camio: oh.  pure.
07:52:34 <chr1s> EmielRegis: If you want to do a cool project, try building a compiler (parser / code generator) for a simple language, e.g. using Parsec
07:52:35 <EmielRegis> in 5 years ;)
07:52:43 <camio> conal: yeah.
07:52:45 <idnar> EmielRegis: if you follow the Haskell -> Core -> ASM process, you might be surprised how straightforward Haskell code can translate into straightforward machine code
07:52:48 <Peaker> EmielRegis: there's a prototype 3d game engine in Haskell,  but its quite "uncharted territory".  The field as a whole did not yet accumulate a lot of experience about how to do these things
07:53:04 <ksf> #j xmonad
07:53:06 <Twey> rog: It's not complete yet.  There's a wiki detailing current proposals on the Haskell wiki.
07:53:06 <chr1s> anyway, I have to catch my train.
07:53:26 <EmielRegis> idnar, I know. But its all due to compiler -> as I said before, in coding in haskell you dont learn the efficient ways of how hardware deals with problems, rather the functional way which is not necesarrily same
07:53:28 <mapreduce> EmielRegis: Under Wadler, you're well-placed to be the guy who advances this element of FP.
07:53:29 <Twey> EmielRegis: Have you seen the work on the Reduceron?
07:53:30 <conal> camio: i see.  Monoid + singleton.  as in richard bird's theory of lists.
07:53:38 <EmielRegis> mapreduce, lol.
07:53:44 <EmielRegis> Twey, nope.
07:53:54 <Peaker> EmielRegis: Its much harder to invent and implement the right paradigm than it is to invent and implement the wrong paradigm.   So while the "wrong paradigm guys" get a lot of games out the door, the right paradigm guys haven't yet solved the problem.  But when they do, nobody will want to use the wrong paradigm anymore
07:53:55 <idnar> EmielRegis: that may be true, but I think the same could be said about writing code in Python, or C
07:53:57 <conal> Peaker: if you mean frag, i think it's largely imperative.
07:54:00 <mapreduce> EmielRegis: I'm not actually joking.
07:54:00 <chr1s> EmielRegis: just see if you can enjoy it too. Don't bother about "whether you can do it in Haskell", because you probably can. Just see if you can learn stuff and enjoy it.
07:54:11 <Peaker> conal: Yampa is semi-imperative, yeah
07:54:12 <conal> Peaker: well put.
07:54:19 <rog> Twey: so when you say "work to Haskell', such as it is", how would i go about doing that, precisely?
07:54:20 <idnar> EmielRegis: what's happening under the hood when your C code executes may still be rather surprising
07:54:23 <conal> Peaker: oh, i didn't mean the yampa part.
07:54:36 <conal> Peaker: is yampa really semi-imperative?
07:54:36 * ksf thinks turing completeness is overrated
07:54:52 <Peaker> conal: it at least seems to encourage it, with looping arrows that expose the sampling rate
07:54:53 * rog agrees with ksf
07:54:58 <Peaker> conal: what part about frag did you mean?
07:55:02 <EmielRegis> idnar, probaly true
07:55:05 <quicksilver> idnar: perhaps, but much less surprising.
07:55:12 <Twey> EmielRegis: http://www.cs.york.ac.uk/fp/reduceron/ — it's very interesting
07:55:15 <mapreduce> Yeah, gcc is not a simple program.
07:55:15 <lambdabot> Title: The Reduceron
07:55:17 <conal> Peaker: oh, discreteness.  :(
07:55:27 <camio> conal: Ah well, I guess I'll just leave the sig as either (Applicative f, Monoid (f a)), or (applicative f, Monad (f a))
07:55:36 <EmielRegis> mapreduce, my road to beign functional language guru is still a long way :P I might want to get involved in such projects on my 3rd or 4th year, but since I am on my 1st now Ill stick to writing a raytracer first :P
07:55:44 <conal> Peaker: i haven't looked at frag. just heard that it has some functional/frp mixed with some imperative/IO
07:55:49 <idnar> quicksilver: well, it's probably easier to write "obfuscated" Haskell code than C code (obfuscated in the sense of how easy it is to tell what's going on under the hood)
07:55:51 <camio> oops, I meant the latter to be (Monad f, Monoid (f a))
07:55:53 <jeffz> there's a website listed on the haskell in industry wiki page which says it uses Haskell to procedurally generate cities for 3d games
07:56:00 <conal> camio: yeah.  too bad.
07:56:04 <Peaker> conal: yeah, its not nice, and arrow composition seems to be quite cumbersome, IMO (compared to just binding applicatives together)
07:56:13 <idnar> quicksilver: but I've been quite surprised by some examples of Haskell code that compiles all the way down in an extremely straightforward manner
07:56:39 <Peaker> conal: though maybe an arrow composition library may have more information about the whole structure, perhaps allowing it to do more optimization than something like Reactive
07:56:51 <idnar> if you want to teach ASM, then you should probably just teach ASM
07:56:58 <Twey> rog: There is work on it: http://darcs.haskell.org/haskell-prime-report/report/haskell-report-html/ http://hackage.haskell.org/trac/haskell-prime/
07:56:59 <ksf> +1
07:57:00 <EmielRegis> Twey, seems cool. But I know too few about hardware implementation of turing machines to udnerstand most of it :P
07:57:01 <lambdabot> Title: The Haskell Prime Language Report, http://tinyurl.com/64hbsh
07:57:31 <conal> Peaker: maybe in theory.  but the Arrow interface actually makes some critical optimization information invisible to yampa.
07:57:43 <ksf> in fact, if you want to teach asm, teach x87. beautiful stuff.
07:57:57 <Peaker> conal: what information is lost?
07:58:10 * rog wishes that lambdabot summarised all the URLs on a line...
07:58:28 <conal> Peaker: independence of concurrent flows.
07:58:33 <rog> Twey: ta
07:58:38 <Twey> EmielRegis: The upshot of it is that it's a machine that can execute functional expressions much faster than a traditional CPU, and therefore perform complex computations much more efficiently
07:59:08 <Peaker> conal: because of arr?
07:59:13 <conal> Peaker: that's why yampa has to recompute so much unchanging stuff.
07:59:32 <conal> Peaker: because arrow notation desugaring uses arr.
07:59:35 <Twey> EmielRegis: And with multi-core becoming more popular, I suspect that it will end up becoming quite common fairly soon.
07:59:39 <ksf> see x87. all that rpn code is trivially to parallelise.
08:00:02 <Peaker> conal: I think maybe the right construct is arrows without arr, perhaps achieve turing complete processing with a set of arrow-level primitives that you can combine
08:00:17 <quicksilver> I'm also quite interested in arrows without arr
08:00:21 <conal> Peaker: i'm with you.  See DeepArrow.
08:00:34 <conal> arrows without arr comes up a lot.
08:00:41 <conal> @wiki DeepArrow
08:00:42 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
08:00:43 <quicksilver> the first few times I thought I'd encountered something which might be an Arrow, it wasn't.
08:00:46 <EmielRegis> Twey, you mean the design of that machine?
08:01:11 <EmielRegis> I sincerely dont think anyone could change the way how x86 is predominant in PC market
08:01:11 <ski_> @arr is bad !
08:01:12 <lambdabot> I want me grog!
08:01:48 <Peaker> conal: but a DeepArrow seems to extend Arrow, so it has arr?
08:01:55 <Twey> EmielRegis: It will probably start out in special-purpose markets, the ones that don't require the whole OS to be reimplemented.
08:02:09 <conal> Peaker: in letter but not in spirit
08:02:39 <quicksilver> it lies!
08:02:43 <quicksilver> ;)
08:02:48 <Peaker> conal: what does a DeepArrow instance do when it encounters arr?  undefined?
08:02:57 <conal> yeah, it lies!
08:02:59 <rog> conal: DeepArrows seem reminiscent (from the first paragraph at any rate) of Data.Accessor
08:03:01 <quicksilver> I must say I found that pretty confusing when I read the deeparrow paper at first.
08:03:21 <quicksilver> the ideas of lenses are definitely related to TVs and deeparrow.
08:03:46 <paczesiowa> what was the name of that haskell-like lang for jvm?
08:03:49 * Peaker has read about lenses and Data.Accessor, but now doesn't remember any of it
08:03:49 <rog> quicksilver: TVs?
08:04:02 <conal> Peaker: the DeepArrow instances I've defined (mainly for Eros) often don't define arr.
08:05:10 <Peaker> conal: that's evil.  Maybe with class aliases you could have the best of both worlds (higher-granularity classes, and convenience, so you can share code with arr-based arrows, but not have arr, and not lie)
08:05:19 <rog> Peaker: type Lens = (r -> (a, a -> r)
08:06:00 <conal> Peaker: that "doctor evil" to you, please!
08:06:14 <Peaker> conal: one million dollars!
08:06:24 <conal> hahahaha!!
08:07:00 <leimy> 6.10 isn't the GHC that's supposed to be portable via the intermediate C in any sort of sane way is it?
08:07:16 <leimy> I think I remember people were planning to try to make that better for 6.11
08:08:04 <conal> camio: make the missing singleton method be an explicit argument.
08:08:09 <Twey> AFAIK, -via-c is intended for eradication
08:08:15 <Twey> So I would doubt it...
08:08:30 <Twey> (would be nice if we could remove the dependency on libc, too...)
08:08:30 <conal> camio: in other words pass the missing dictionary component explicitly instead of implicitly.
08:09:31 <Peaker> conal: btw, do you know about capabilities (vs ACL's)?
08:09:44 <conal> Peaker: no
08:10:19 <Twey> paczesiowa: Scala?
08:10:23 <camio> conal: Hrm, lemme see what that looks like.
08:10:27 <Peaker> conal: Do you see something like Eros becoming a whole desktop environment, perhaps even transcending network barriers and becoming an alternate "web" platform?
08:10:46 <hackage> Uploaded to hackage: HSHHelpers 0.16
08:10:57 <conal> Peaker: i do.
08:10:58 <paczesiowa> Twey: no, it was pure and lazy
08:11:06 <Twey> Hmn
08:11:18 <Peaker> conal: Have you given thought to the security implications?
08:12:12 <paczesiowa> or, let me put this another way: what language would you suggest for writing on jvm to a haskell guy?
08:12:37 <quicksilver> leimy: I think you have to go as far back as 6.4 to get working .hc portability.
08:12:48 <Peaker> paczesiowa: did someone mention clojure? I haven't read up
08:12:56 <leimy> quicksilver: doh
08:13:14 <camio> conal: I recognize that type signature from somewhere else. Did you suggest it based on something else you've seen elsewhere?
08:13:21 <conal> Peaker: some, yes.
08:13:32 <quicksilver> Twey: I'm not sure removing libc dependency is a very interesting goal. libc is a portability lib. without it you'd need to handle different kernels.
08:13:44 <conal> camio: which type signature?  empty/singleton/append?
08:13:46 <mapreduce> paczesiowa: I'd suggest Scala.  CAL is closer to Haskell, but I don't know much about it.
08:13:54 <paczesiowa> Peaker: haskell people like types and no parens.
08:13:57 <camio> collectE2 :: Monoid (f a) => (a -> f a) -> Event a -> Event (f a)
08:13:59 <paczesiowa> mapreduce: cal! that was it
08:14:11 <mapreduce> Scala is pretty good but quite annoying in some ways.
08:14:28 <camio> conal: Something that asks for a monoid conversion function as the first argument.
08:14:51 <camio> conal: sorta like mapM :: Monad m => (a -> m b) -> t a -> m (t b)
08:14:53 <Peaker> conal: I think that caps are generally the right way to do security (rather than ACL's), but I am not sure exactly how well they fit with FRP.  Caps are usually framed in an OO message-passing world, but their concept of unifying designation with authority probably applies to any paradigm
08:15:11 <sw17ch> If i want to hide a class interface from an imported module, how would one do that?
08:15:17 <Peaker> conal: where ACL's are something like enumerating all entities (e.g "uid's") and then attaching a list of uid's to each object..
08:15:20 <conal> camio: Monoid + singleton. see richard bird's "theory of lists".
08:15:25 <quicksilver> that's a very odd type signature (collectE2)
08:15:42 <Saizan> sw17ch: hiding (Class(..)) ?
08:15:56 <Twey> quicksilver: Optionally, of course.  On a large scale, it would be nice to have Haskell-based OSes at some point, and for the time being that involves copying across chunks of C libraries.
08:16:04 <rog> sw17ch: there was a discussion on haskell-cafe in the last few days on that very subject. i think.
08:16:07 <Twey> Defeats the point a little.
08:16:09 <camio> quicksilver, collectE2 :: (a->[a]) -> Event a -> Event [a]
08:16:14 <rog> oops
08:16:17 <rog> misread
08:16:23 <sw17ch> Saizan, In this case, I want to hide the ByteString interface to Storable in the Foreign.Storable module
08:16:27 <Peaker> Twey: have you seen the STEPS project?
08:16:33 <sw17ch> but i want the rest of the interfaces :
08:16:34 <sw17ch> )
08:16:36 <Peaker> Twey: Legacy is overrated :)
08:16:58 <conal> Peaker: i wonder if are caps are necessary in functional programming.  after all, you can't do bad things in FP.
08:17:04 <Saizan> sw17ch: ah, you want to hide an instance, in that case you simply can't :)
08:17:08 <conal> Peaker: because you can't do anything at all.
08:17:13 <Twey> Peaker: I may have done.  Was that the OS In Haskell?  (it's difficult to Google)
08:17:15 <sw17ch> Saizan, :(
08:17:19 <ski_> camio : would `Monoid b => (a -> b) -> Event a -> Event b' suffice ?
08:17:20 <sw17ch> I'll have to newtype it won't i
08:17:31 <Peaker> conal: well, the UI that you expose probably lets you get "bad things" done
08:17:43 <conal> Peaker: not my UIs.
08:18:05 <Peaker> conal: well, surely you can get a document printed, for example
08:18:16 <conal> Peaker: my UIs are visualizations of pure values.  they're like show.
08:18:17 <camio> conal: Doesn't look availible online, the paper you cited.
08:18:26 <Saizan> sw17ch: yeah, if you need a different instance
08:18:34 <quicksilver> camio: well in isolation, Monoid b -> (a -> b) -> Event a -> Event b
08:18:40 <quicksilver> camio: is strictly more general.
08:18:42 <Peaker> conal: how do you get a document printed then?
08:18:45 <quicksilver> that's all I meant by it being odd.
08:18:53 <sw17ch> Saizan, alright, that will work fine
08:18:57 <conal> Peaker: i don't know.
08:19:22 <camio> ski_,quicksilver: I'm getting further and further from what I really want, a generalized Event a -> Event [a] but for any collection.
08:19:24 <conal> Peaker: a lot will have to get reimaginined.
08:19:24 <quicksilver> at which point, it becomes like foldMap
08:19:28 <Peaker> conal: also, pure computations take real resources (e.g CPU power) so they too require a bit of thought (e.g don't accept computations from other entities too easily and without restrictions)
08:19:56 <conal> Peaker: yep.
08:19:57 <Peaker> conal: I agree, but whatever you end up deciding to do, if you are going to allow side effects such as printing in your UI at all, that means "bad things" can also be done
08:20:00 <Saizan> ?type foldMap
08:20:01 <lambdabot> Not in scope: `foldMap'
08:20:18 <Peaker> conal: and that may re-introduce security concerns
08:20:26 <conal> Peaker: not necessarily.
08:20:39 <Peaker> conal: How do you avoid it?
08:20:47 <conal> Peaker: if you allow *arbitrary* side-effects then you're in trouble.
08:21:38 <conal> Peaker: i imagine printing could come from a much more benign environment.  it's not much different from the repl of a purely functional language.
08:22:31 <Peaker> conal: by printing, btw, I mean on a real piece of paper :)
08:22:32 <conal> Peaker: i hope you don't think i know how the details will turn out.  i'm just on the journey.
08:22:39 <conal> "One does not discover new lands without consenting to lose sight of the shore for a very long time." - Andre Gide
08:22:51 <Peaker> conal: nice quote
08:22:54 <conal> Peaker: i figured you mean't real paper.
08:22:58 <conal> *meant
08:23:49 <Peaker> conal: the idea in capabilities is to divide the world into as many entities as possible (high granularity) and give each entity the minimal amount of authority.  To make this non-cumbersome, you don't separate giving authority from designating the work that has to be done, you unite them - so by giving some entity a desgination of what to do, that designation automatically carries with it the authority.  You cannot forget designators of resources/etc.  I
08:23:50 <Peaker> n a sense, you get security as a byproduct of using ordinary good software design
08:24:15 <Peaker> s/forget/forge
08:24:36 <conal> Peaker: sounds like a lovely & useful theory.
08:31:20 <sw17ch> What are TypeOperators?
08:31:44 <byorgey> sw17ch: infix type constructors
08:31:45 <conal> sw17ch: e.g., foo :-* bar
08:32:02 <idnar> Foo :-* Bar, surely?
08:32:13 <byorgey> maybe foo and bar were type variables =)
08:32:16 <idnar> heh
08:32:21 <conal> byorgey: right
08:32:21 <idnar> type lambdas
08:32:22 <sw17ch> :) thanks
08:32:52 <byorgey> heh, not type lambdas =)
08:33:21 <byorgey> we don't have those for a good reason (type lambdas -> higher-order unficiation -> undecidable type checking =)
08:33:52 * byorgey sighs and prepares to walk to school in the rain
08:34:19 * sw17ch suggests byorgey not look at the rain so it won't be evaluated
08:34:30 <byorgey> hehehe
08:34:43 <sw17ch> (undefined :: Rain)
08:34:57 <byorgey> unfortunately, the weather seems to be using a strict semantics.
08:35:06 <sw17ch> submit it as a bug to God
08:35:10 <idnar> haha
08:35:17 <ystael> byorgey: you can't just eta-expand it?
08:35:39 <byorgey> see, now I have to get an umbrella with a big eta on it
08:35:58 <byorgey> and only ten people in the whole world will get the joke
08:36:43 <sw17ch> byorgey, but when you meet one, it will be so worth it
08:38:25 <Saizan> you can also trick category theorists into thinking that your umbrella is a natural transformation
08:38:48 <Deewiant> byorgey: bah, we already have undecidable instances, why not type lambdas
08:39:44 <yaxu> hi all, is hs-plugins still the state of the art for dynamically loading haskell?
08:40:05 <conal> Deewiant: and higher-order unification and backtracking in instance selection.  (i'm serious)
08:40:41 <quicksilver> conal: there are consequences to that in terms of separate compilation and monotonicity.
08:40:48 <yaxu> or should i be looking at yi innards or something instead?
08:40:54 <quicksilver> conal: not that these don't represent interesting challenges to meet.
08:41:04 <conal> quicksilver: yeah
08:41:25 <quicksilver> done wrongly, though, we lose compositionality of modules
08:41:31 <quicksilver> (which would be *bad*)
08:41:42 <quicksilver> and the obvious way to fix that is to make instances local
08:41:46 <quicksilver> ...but that breaks other things.
08:44:31 <Saizan> yaxu: there's also the ghc-api now
08:45:11 <Saizan> yaxu: hs-plugins is probably better documented but i'm not sure if it compiles on 6.10
08:45:41 <quicksilver> hs-plugins uses the ghc-api now, doesn't it?
08:45:50 <quicksilver> or at least, it does for some of its functionality?
08:46:11 <yaxu> i'm using the ubuntu intrepid ghc at the moment, which is 6.8.2
08:46:33 <dolio> Intrepid is still .2?
08:46:41 <yaxu> seems so
08:46:45 <dolio> Wow.
08:46:52 * yaxu double checks
08:46:56 <conal> yaxu: i imagine the ghc-api has changed qquite a lot since 6.8.2
08:47:25 <yaxu> ok i think i'll upgrade everything and try ghc-api
08:47:51 <conal> yaxu: i'd like to hear how ghc-api goes for you.
08:47:55 <yaxu> afaict intrepid ghc is 6.8.2
08:48:01 <conal> yaxu: and: hi!  how are things going?
08:48:19 <yaxu> hey :)  good thanks
08:48:34 <yaxu> been a bit quiet trying to get started with my phd and coping with fatherhood
08:48:53 <yaxu> how are you?
08:49:24 <conal> yaxu: wow.  big time new.  congrats*2!
08:49:35 <yaxu> heh
08:49:49 <conal> yaxu: i'm doing great.  spent the summer in belgium, which was a blast.  now happy to be back home in the woods.
08:50:52 <yaxu> nice, the woods?
08:51:36 <conal> yaxu: yeah.
08:54:30 <nominolo|msr> @swiert seen
08:54:30 <lambdabot> Unknown command, try @list
08:54:34 <nominolo|msr> @seen swiert
08:54:34 <lambdabot> I saw swiert leaving #haskell 2h 25m 36s ago, and .
08:58:34 <wjt> I have an application that consists of a Haskell program and a single-source-file C executable. Currently I'm building the app with Cabal and the C application with a Makefile; can/should I also build the C executable with Cabal?
08:59:15 <dcoutts> wjt: you can, and if you want that C prog built when you distribute the package then building it with cabal is also a good idea
08:59:41 <dcoutts> wjt: actually, cabal cannot build standalone C apps that consist only of C code with a C main()
08:59:52 <dcoutts> wjt: it can link C code into a Haskell app or lib
09:00:09 <dcoutts> and it can make libs that consist only of C code, but not C apps with a C main
09:01:06 <wjt> That's what I feared
09:01:37 <wjt> So I have to get Cabal to call out to Make? :(
09:01:55 <dcoutts> wjt: or give the C prog a haskell main ;-)
09:02:05 <dcoutts> and call the C code via the ffi :-)
09:02:21 * dcoutts isn't sure if he's joking or not
09:02:40 <daf> we considered this
09:02:42 <wjt> Considered that, but I want the C executable to be pure C
09:02:49 <daf> sadly
09:02:50 <wjt> oh hello daf :)
09:02:57 <daf> hey :)
09:03:02 <dcoutts> wjt: more than building, you'd need to arrange for Cabal to install it
09:03:17 <dcoutts> wjt: it's all possible by using hooks in Setup.hs, but it's not quite so pretty
09:03:54 <wjt> ah well
09:04:00 <dcoutts> wjt: the hooks in Setup basically let you play with IO () so you can do anything but you don't get much help
09:04:16 <wjt> Hmm. In other news, my copy of Parsec doesn't seem to have Applicative instances :(
09:04:29 <dcoutts> wjt: complain louder
09:04:38 <wjt> hah
09:04:42 <dcoutts> I always support adding applicative instances
09:05:07 <dcoutts> wjt: send patches
09:05:14 <wjt> hmm, ISTR that parsec3 does
09:05:27 <BMeph>  camio: looks up Control.Functor.Pointed in edwardk's -extras package. :)
09:05:36 <dcoutts> wjt: parsec 2 needs them anyway, it's not like everyone is moving to parsec 3
09:05:51 <dcoutts> g'morning SyntaxNinja
09:09:05 <seliopou> btdubs, is the is parsec's parser monad transformer exposed to users?
09:09:14 <seliopou> (I assume it was written using a monad transformer)
09:09:24 <quicksilver> it wasn't.
09:09:26 <paczesiowa> there is ParserT
09:09:37 <quicksilver> it has a monad-transformer form.
09:09:45 <quicksilver> it wasn't written using other monad transformers though.
09:10:19 <seliopou> quicksliver: that's what I meant (the monad transformer form)
09:10:46 <hackage> Uploaded to hackage: flickr 0.2.2
09:11:08 <paczesiowa> have anyone used CAL?
09:12:18 <wjt> dcoutts: okay, it's on my TODO
09:13:11 <dcoutts> wjt: if you'd like to file a feature request for C main functions you're welcome to do that too
09:13:22 <wjt> dcoutts: in other news, the C executable is GPL while the application is LGPL; how can I fill in the License: field?
09:13:26 <dcoutts> wjt: in the cabal/hackage trac
09:14:18 <dcoutts> wjt: Either you take the union and say it's GPL, or you use OtherLicense and give the details in the license file
09:14:39 <dcoutts> wjt: we have no way to express that different bits of a package have different licenses
09:15:10 <wjt> Okay. LICENSE already gives the details, so I'll use OtherLicense. This isn't a library anyway, so.
09:15:20 <wjt> dcoutts: (incidentally, cairo bindings++)
09:15:27 <dcoutts> wjt: :-)
09:15:50 <dcoutts> now if only gtk2hs used cabal...
09:16:26 <SyntaxNinja> y0 dcoutts
09:16:44 <wjt> dcoutts: (in other news, there are no -prof versions of gtk2hs in Debian :()
09:17:00 <dcoutts> wjt: sigh
09:17:12 <wjt> i guess step three is to step up
09:18:33 <_pizza_> what is the syntax to access a named record member?
09:18:59 <_pizza_> i see how to define them but not how to access them
09:19:53 <paczesiowa> field record
09:20:51 <paczesiowa> data X = X { x :: Int}; y = X {x=2}; z = x y
09:21:20 <Peaker> Haskell records have a namespacing problem...
09:21:30 <_pizza_> paczesiowa: thanks, let me try
09:22:35 <ziman> and i'd appreciate something like map { foo = bar } listOfRecords
09:23:24 <paczesiowa> ziman: there was a package that created getters/setters with TH
09:23:39 <paczesiowa> functional references or something like that
09:24:37 <mikezackles> Hi all, I'm pretty new to Haskell.  I'm having trouble building the crypto package on GHC 6.10, which fails with an "out of stack slots" error:  http://hpaste.org/11991  I've tried adding -fregs-graph to the cabal file in the Library section under Ghc-options, but I get the same result.  Any idea what I should do?
09:31:04 <mm_freak> until now, to implement an internal object database, i used something like this:  database :: Chan DBCommand -> StateT (Map Key Object) IO ()
09:31:09 <Peaker> heh, my ISP's newsgroup server says "alt.comp.lang.haskell is not normally downloaded, but due to your request it will be available in a few minutes"
09:31:15 <Peaker> is that newsgroup worthy?
09:31:22 <mm_freak> now i've read a bit about STM…  how can i bring STM into play here?  where can i make use of it?
09:31:53 <mm_freak> Peaker: not really…  comp.lang.haskell is much more active
09:31:59 <Cale> mikezackles: Ooh, you got a panic from GHC. That means you found a compiler bug.
09:32:03 <Deewiant> mikezackles: that file is a well-known problem... -fregs-graph /should/ work
09:32:05 <Peaker> mm_freak: its not listed, weird
09:32:15 <Cale> Deewiant: Oh, is that well-known?
09:32:22 <Cale> Interesting :)
09:32:31 <Deewiant> Cale: it's been filed twice, I'm just marking the other as a duplicate as we speak :-P
09:32:32 <mm_freak> Peaker: it definitely exists, as i post regularly in it
09:32:37 <mikezackles> Lucky me :)
09:33:03 <mikezackles> Ah, so I must be doing something wrong when I specify -fregs-graph
09:33:04 <Peaker> mm_freak: I don't get to free-type the name in thunderbird, and its not in the list :(
09:33:10 <Deewiant> http://hackage.haskell.org/trac/ghc/ticket/2753 is the original report
09:33:16 <lambdabot> Title: #2753 (GHC 6.10.1 cannot compile Crypto-4.1.0) - GHC - Trac
09:33:17 <Cale> mikezackles: Are you using Cabal to build it?
09:33:22 <mm_freak> Peaker: maybe update your list
09:33:30 <mikezackles> Cale: yes
09:33:30 <Cale> mikezackles: You might have to edit the .cabal file for the package.
09:33:39 <Deewiant> Or actually #2623 is the original report, but it was set to fixed for unknown reasons
09:33:44 <Cale> (I'm not sure it will pass the flag through...)
09:33:57 <mikezackles> Cale:  That's what I'm doing, but I'm not certain I'm putting the option in the right place
09:34:05 <Peaker> mm_freak: I did... comp.lang.{functional,hermes,icon,...}
09:34:40 <mm_freak> what's a good approach to make a multithreaded database?  maybe something like Chan DBCommand -> StateT (Map Key (TVar Object)) IO ()?
09:34:48 <Cale> mikezackles: I'll give the crypto package a shot and see how it goes :)
09:35:05 <mikezackles> Cale: thanks! :)
09:35:28 <mm_freak> hmm, that wouldn't work =/
09:35:29 <Deewiant> mikezackles: a way to make sure it gets passed should be to edit SHA1Test.hs and add {-# OPTIONS_GHC -fregs-graph #-} at the top
09:35:32 <Deewiant> I think that should work
09:35:48 <mikezackles> Deewiant: ah, thank you.  I'll try that.
09:36:07 <Lemmih> mm_freak: A TVar for each object is very expensive.
09:37:07 <mm_freak> Lemmih: yeah, and it wouldn't really work…  what would be the canonical approach?  a TVar (Map k v)?
09:37:46 <mm_freak> my goal is a multithreaded database, which i can talk to via a Chan or something
09:38:54 * sw17ch wonders about the quality/speed of the crypto package
09:39:01 <mm_freak> maybe the idea itself is flawed
09:41:22 <Cale> mikezackles: Okay, I added a line  "Ghc-options: -fregs-graph" to the SHA1Test stanza, and that seems to have fixed the problem.
09:41:32 <mikezackles> Yes, that worked for me too.
09:41:46 <mikezackles> Many thanks, Cale and Deewiant.
09:41:57 <mikezackles> I was putting the option in the wrong place.
09:42:06 <Cale> Probably someone should contact Dominic and let him know about this :)
09:42:24 <paczesiowa> does anyone have any experience/opinion about CAL?
09:44:27 <mm_freak> @pl \x -> case x of y -> z
09:44:28 <lambdabot> (line 1, column 19):
09:44:28 <lambdabot> unexpected ">" or "-"
09:44:28 <lambdabot> expecting variable, "(", operator or end of input
09:44:41 <Deewiant> cases can't be @pl'ized
09:44:48 <mm_freak> @pl \x -> if x == y then z0 else z1
09:44:48 <lambdabot> flip (flip if' z0 . (y ==)) z1
09:44:55 <mm_freak> hmm…  ugly
09:45:24 <Twey> Where if' x y z = if x then y else z
09:51:15 <mm_freak> http://hpaste.org/11993 ⇐ ok, this is my database so far
09:51:24 <mm_freak> what's a good approach to make it multithreaded?
09:58:07 <mm_freak> hmm…  seems like it's best to just split the key space into multiple uniformly distributed partitions…  i thought there might be a more beautiful approach =/
09:58:55 <dolio> You mean you want more than one thread inserting/looking up things in the database?
09:59:44 <mm_freak> for example, yes, or some other form of load balancing
10:00:59 <mxc> hello
10:01:08 <mm_freak> i think, Map is not suitable for that; i think, either i need multiple Maps, or some completely different thread-aware data structure
10:01:13 <mm_freak> hello mxc
10:01:51 <dolio> Probably. What do real, high-end rdbmses do?
10:01:51 <p_l> mm_freak: multiple "read" nodes, single "write" node per partition, with invalidation of the read-only caches?
10:02:02 <mxc> having some trouble getting somethigng to typecheck, i remember this compiling fine under 6.8 (now on 6.10) and getting compiler errors: http://hpaste.org/11994
10:02:40 <mxc> and i could be wrong about it compiling under 6.8, but I dont remember touching this part of the code for a long time
10:02:41 <mm_freak> p_l: that would be a good start, but one can do even parallel writes in real DBMSes
10:03:05 <mm_freak> dolio: AFAIK they employ thread-aware data structures
10:03:13 <p_l> mm_freak: If you use transactions, yes
10:03:26 <p_l> without transactions, it will be a PITA
10:03:46 <Deewiant> mxc: Control.Exception was rehauled in 6.10.
10:03:47 <p_l> (for parallel writes in one partition)
10:03:53 <mm_freak> p_l: that's where STM may come into play, but i don't know how to incorporate it well into my current version
10:04:21 <Deewiant> mxc: you need to actually specify, in the type, what exceptions you want to catch.
10:04:41 <Deewiant> so that you don't just catch every possible exception like you would have before
10:05:08 <p_l> mm_freak: I'd start with implementing a fast cache-invalidation system
10:05:47 <dolio> mm_freak: If you stored your map in a TVar, you could maybe get free many-read, one-write behavior.
10:06:01 <p_l> mm_freak: Or if you are not bound by requirements for coherency, you can try with non-coherent database
10:06:13 <mm_freak> p_l: that would be reinventing the wheel…  STM does all i need…  it's just that, Lemmih pointed out that turning each object into a TVar would be resource-intensive, and that it wouldn't be multithreaded automagically
10:06:37 <vegai> best darcs mode for emacs?
10:06:42 <p_l> mm_freak: Depends on how distributed you want it to be
10:07:17 <mxc> deewiant - thanks for the heads up
10:07:43 <mxc> switching to Control.OldException worked, for now, will figure out the correct annotations later
10:07:52 <mm_freak> splitting the key space would give me multi-read and multi-write, as long as the reads and writes are on different key space partitions
10:08:43 <p_l> mm_freak: That would be a start. Also atomic transactions that don't touch each other should be able to run in parallel
10:09:22 <mm_freak> yeah…  a combination of partitioned key space and Maps in TVars
10:09:29 <mm_freak> i'll give it a try
10:10:14 <mm_freak> it destroys the beauty of the code though…  i've never seen a more beautiful database =/
10:10:47 <hackage> Uploaded to hackage: hcheat 2008.11.14
10:10:47 <hackage> Uploaded to hackage: xosd 0.1.1
10:11:21 <p_l> mm_freak: Well, it is simple. I think I'll need to reread that simple rdbms I had seen once.. ~2k loc and included tables as well as query language
10:12:04 <mm_freak> it's meant to be an internal database only, so i don't need tables or a query language
10:12:17 <mm_freak> (in fact, i have a query language, a DSL)
10:12:53 <p_l> mm_freak: it was internal - the query lang. was there in the form of DSL to make it easier to use
10:13:24 <mm_freak> ah, ok
10:13:34 <Peaker> I hope for one database to rule them all, that lets you specify what queries/operations you want to perform on it, and uses heuristics/hints/anything-else to determine what indexing method is best to use for those queries
10:14:11 <mm_freak> without the Get command, i could easily derive Read for DBCommand, so i could even make it accessible to the user without having to write a parser =)
10:15:12 <p_l> Peaker: Not really useful right now... The structure of the data is more important than indexing method, as it's what is the main constraint
10:16:54 <Peaker> p_l: can't the data structure be derived from the kinds of queries you want to be able to do?
10:18:11 <p_l> Peaker: I think the data comes first - for simple numbers, you can have it rather automated, however, some of the heavier stuff explicitly requires you to use certain kinds of indexing
10:18:15 <p_l> Getting it *fully* automated would probably require an AI
10:18:21 <Peaker> p_l: if you specify a static type on the kinds of queries you want, you're also specifying the data structure, no?
10:18:29 <Peaker> p_l: yeah, note I said "heuristics" :-)
10:18:55 <Peaker> I believe that heuristics built by the best experts in a field can probably out-do the "average" human in a field, for most fields (including database indexing)..
10:19:49 <p_l> Peaker: I am no DBA, but as far as I know, usually "the best expert in the field" is not really into heuristics, as he has all the data about the domain he needs to index
10:20:38 <Peaker> p_l: Yeah, but if he wants to generalize the solution and create an algorithm that derives the data structures and indexing that should be used automatically from the queries..
10:21:09 <p_l> Peaker: That's what profiling is for
10:21:32 <Peaker> p_l: well, hopefully the profiling can be done automatically
10:21:41 <Peaker> p_l: and whatever else a human would normally do when deciding how to index
10:22:00 <p_l> Peaker: Yes, it is automated. You let the users use it, while gathering data
10:22:20 <p_l> then you can use heuristics for deciding what kind of indexing you really need
10:22:36 <Peaker> p_l: the users need to have very informative specifications about their demands of performance ("this query can take all day, but this one must finish in 1/16 of a second")
10:23:06 <p_l> Peaker: It's more of checking what types of access is typical
10:23:19 <p_l> and what types of writes
10:23:42 <p_l> the "demands for performance" are for scheduler, not indexer
10:24:52 <p_l> when you have really big difference between the types of access and performance constraints, you usually build two completely different databases
10:25:15 <p_l> so one would be for fast transaction processing, the other would be for the analysis
10:25:23 <mfwitten> Hello. I'm working my way through YAHT, and I'm a bit stuck on something I'd like to do for one of the exercises: Given a list of nonnegative integers, output formatted text for each element. I wrote the following code to do this, but it doesn't correctly handle empty lists: http://hpaste.org/11996
10:25:35 <mfwitten> I tried using pattern matching for that case, but I can't get it
10:25:38 <Peaker> p_l: but you might want a completely different kind of index to satisfy different performance requests
10:25:40 <mfwitten> Must I use if/else
10:27:09 <Asztal> a stab in the dark, but the empty list case would need to go before that case
10:27:14 <Cale> mfwitten: You should use pattern matching rather than head and tail
10:27:26 <mfwitten> true
10:27:30 <mfwitten> (x:xs) or the like?
10:27:32 <Cale> mfwitten:  print_factorials (x:xs) = do ...
10:27:37 <mfwitten> ok
10:28:02 <mfwitten> Out of curiosity, is there a way to keep what I have but specify something like print_factorials [] = .... ?
10:28:16 <Cale> mfwitten: absolutely, just make sure that case comes before this one
10:28:29 <mfwitten> Cale: But I get compilation errors
10:28:29 <p_l> Peaker: Usually the type of indexing you want is "the fastest I can get"
10:28:40 <Cale> mfwitten: The patterns are matched in order from top to bottom, and 'list' matches everything.
10:28:56 <Peaker> p_l: but different indexes will be fast for different operations
10:29:08 <mfwitten> How do I specify "do nothing" ?
10:29:13 <Cale> mfwitten: return ()
10:29:26 <mfwitten> ah.
10:29:30 <mfwitten> Yaht hasn't quite discussed that
10:29:42 <Cale> mfwitten: In general,  return v  is an action which does nothing, but always returns v.
10:29:45 <p_l> Peaker: The difference is what needs to be fast - is the table mostly read from, or will it have a lot of data written to it? Writes are fastest without any indexing, reading will be very fast with a BST
10:30:09 <mfwitten> ok
10:30:13 <mfwitten> Thanks!
10:31:09 <p_l> Peaker: AFAIK the only times when you specify the index type in modern dbms is when you exactly know what kind of index you need. For speed, there are heuristics as to *when* the db has to reindex stuff
10:31:30 <Peaker> p_l: but without specification of what you want to be fast, it might try to optimize for the wrong things
10:31:42 <linolium> does ghci support pattern matching when defining functions with "let"?
10:32:03 <Peaker> linolium: yeah, but I think you need to use {} on a single line with semicolons
10:32:06 <Peaker> (not sure)
10:32:12 <MyCatVerbs> Peaker: not if you're making regular use of it. It can just record what it is that you're actually doing with it.
10:32:24 <MyCatVerbs> Peaker: all adaptive systems work like that. Generally, they tend to work. :)
10:32:42 <p_l> Peaker: Basically, heuristics are already employed at the level they can work properly
10:33:04 <p_l> Peaker: If you want more, you'd need to get system-wide AI engine
10:33:17 <Peaker> MyCatVerbs: what if some queries are very performance-critical and others aren't?
10:33:27 <linolium> Peaker: what do I need to change here: let fact 0 = 0; let fact n = n * fact (n - 1)
10:33:28 <Peaker> MyCatVerbs: it might try to optimize them equally
10:33:38 <p_l> Peaker: That's what scheduler is for
10:33:39 <Peaker> linolium: it has to be the same let clause, not two separate ones
10:33:50 <mfwitten> Cale: Naturally, I need "print_factorials [] = return ()" even with (x:xs) pattern matching ;-)
10:33:55 <Peaker> linolium: let { fact 0 = 0 ; fact n = ... } (there's a bug there :-)
10:34:04 <linolium> ah?
10:34:30 <p_l> Peaker: You simply specify "this one has priority -20, the other one has priority 10, this one is not really important so give it a priority of 30"...
10:34:40 <linolium> Peaker: what, that it is non-exhaustive?
10:35:03 <Peaker> p_l: but you know how fast the queries need to run, you don't know how to translate that into "priorities"
10:35:04 <Cale> mfwitten: right
10:35:12 <Peaker> p_l: You know that the deadline on query A is 1/10 second, and on query B it is 3 hours
10:35:25 <p_l> Peaker: For that, you *never* use heuristics
10:35:29 <Peaker> linolium: your base case
10:35:39 <Cale> mfwitten: another way to write it would be to use forM or mapM
10:36:08 <p_l> Peaker: When you are talking about realtime stuff you don't employ heuristics this way
10:36:14 <mfwitten> Cale: I was certain there exists such functions, but I wanted to stick with "what I know thus far".
10:36:20 <Cale> mfwitten: yep :)
10:37:05 <p_l> Peaker: usually you also use completely different types of databases for that kind of requirement.
10:37:18 <Cale> printFactorials = mapM (\num -> putStrLn (show num ++ "! = " ++ show (factorial num))
10:37:26 <p_l> afk, need to go shopping
10:37:40 <Peaker> p_l: why not a different index on the same database?
10:37:50 <Twey> mfwitten: http://hpaste.org/11996#a1
10:37:57 <Peaker> or alternatively, a "meta database" that chooses the right database for the requirements
10:38:14 <mxc> RWH isn't in stores yet, is it?
10:38:57 <p_l> Peaker: because it's a design-time decision, not runtime
10:39:18 <p_l> OLTP and OLAP are also kept separate for this reason
10:39:29 <Peaker> p_l: what are those?
10:39:44 <Peaker> p_l: and why can't there be a runtime "design decision" that chooses the database based on requirements, and then uses it separately?
10:39:59 <p_l> OLTP = On-Line Transaction Processing (lot's of data written all the time, needs quick reaction)
10:40:03 <mfwitten> Twey: Ooooh. That second version is particularly juicy. Though, I want to say that I dislike the 'where' construct---not just in haskell, but in papers and books and the like---because it presents definitions backwards (most of the time).
10:40:23 <mfwitten> I would much prefer a "given" keyword perhaps
10:40:32 <mfwitten> But I don't really know what I'm talking about ;-P
10:40:41 <p_l> OLAP - I don't remember exact def., but it's about analysis of the data
10:40:59 <vixey> nothing wrong with a bit of backwards binding
10:41:17 <mxc> mfwitten - sometimes it can make the code much more reasonable
10:41:19 <p_l> Also letting it be a runtime decision choosen by heuristics means that you *won't* get proper results
10:41:28 <Twey> mfwitten: Doing things 'backwards' is common in Haskell
10:41:36 <mfwitten> Twey: ;-)
10:41:53 <Twey> mfwitten: And in programming generally, really.  Think about the way you read it.
10:41:57 <mxc> mfwitten - especially if the behavior of the fxn is 'obvious'
10:42:16 <mfwitten> mxc: No doubt! That second version is very concise. But whenever I read a mathematical paper, I always wonder why such definitions aren't just given before the final expression. It saves my eyes the trouble in more complex situations.
10:42:33 <mxc> mfwitten - agreed that it definitely gets abused alot
10:42:36 <p_l> Peaker: Also, the datastructures required for OLTP or OLAP are *completely* different. What might be a simple table for OLTP would probably be stretched over several for OLAP
10:42:46 * p_l needs to go shopping, AFK
10:42:57 <Peaker> p_l: then why not have the requirements->database engine choose between OLTP and OLAP?
10:43:03 <Peaker> p_l: ok, talk when you're back
10:51:15 <Saizan> in Data.Map lookupWithDefault has been changed to findWithDefault in 6.10?
10:54:51 <arjanb> Saizan: 6.10 has a newer version of the containers library
10:57:17 <int-e> Saizan: I've never seen a lookupWithDefault in Data.Map
11:04:27 <_pizza_> is there anything in standard Haskell like C's assert()?
11:04:43 <Deewiant> Control.Exception.assert
11:06:26 <dons> ?hoogle assert
11:06:26 <lambdabot> Control.Exception assert :: Bool -> a -> a
11:06:26 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
11:06:26 <lambdabot> Test.HUnit.Base class Assertable t
11:09:41 <popo> @type map
11:09:42 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:10:16 <popo> Where am I?
11:10:32 <dmwit_> ?localtime popo
11:10:33 <lambdabot> Local time for popo is Fri Nov 14 03:10:32
11:10:36 <Raevel_> who am i?
11:10:44 <dmwit_> Looks like you're in the middle of the ocean!
11:10:57 <dmwit_> Oh, 3:10 AM.
11:11:00 <popo> quite right,hha
11:11:22 <dmwit_> Let's see, that would put you... in Iran!
11:11:26 <dmwit_> yikes!
11:12:07 <popo> my girl friend is sick, I have to take her to hospital early morning, i dicide to spend hours to haskell...
11:12:30 <dmwit_> But your name puts you in China.
11:13:04 <popo> i'm in beijing~~~
11:13:13 <popo> ?localtime dmwit
11:13:30 <dmwit_> ?localtime dmwit_
11:13:31 <lambdabot> Local time for dmwit_ is Thu Nov 13 14:13:44
11:13:50 <popo> you are at work?
11:14:00 <dmwit_> Well, I *should* be. ;-)
11:14:19 <popo> hoho, i *should* be sleeping
11:14:37 <conal> is there already a class like the following, beside the one in TypeCompose?
11:14:38 <conal>     class Pair f where pair :: forall a b. f a -> f b -> f (a,b)
11:15:13 <dmwit_> Well, Bifunctor comes close.
11:15:22 <dmwit_> But it goes the other way, sort of.
11:17:36 <conal> dmwit_: do you have a pointer to Bifunctor?
11:17:44 <dmwit_> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor.html#t%3ABifunctor
11:17:49 <lambdabot> Title: Control.Functor, http://tinyurl.com/65gqxt
11:18:08 <conal> dmwit_: thx!
11:18:22 <conal> i bet there are other goodies in there i could use.
11:18:23 <dmwit_> It's a little tricky to understand all the arguments to the class, though...
11:18:31 <conal> even if it doesn't do Pair
11:18:32 <dmwit_> Yeah, category-extras is a big package.
11:18:50 <Saizan> there's something like Zippable functor
11:19:21 <dmwit_> I wonder why every instance there is listed twice?
11:19:34 <Saizan> conal: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Zip.html#t%3AZip
11:19:36 <lambdabot> Title: Control.Functor.Zip, http://tinyurl.com/4wbucw
11:20:42 <conal> Saizan: that's what i'm looking for.  thx.  i did something similar in http://hackage.haskell.org/packages/archive/TypeCompose/latest/doc/html/Data-Pair.html
11:20:43 <lambdabot> Title: Data.Pair, http://tinyurl.com/6xj69b
11:20:59 <conal> (where the Data.Fun link should really be Data.Lambda)
11:22:46 <roconnor> Saizan: cool.  Is there a way for cabal to conditionally compile in support for this in my package?
11:22:50 <roconnor> is that even a good idea?
11:24:13 <Saizan> it changes your package interface, so i'm not sure if it's a good idea
11:25:04 <dons> don't change the interface.
11:25:12 <dons> since we can't track that as a dependency.
11:25:25 <dons> i.e. build-depends: x (with the -ffoo flag set)-- bad
11:25:32 <roconnor> wait, what's the difference between Zip and Applicative?
11:25:37 <dons> dcoutts_ has strong thoughts on this subject, fiw
11:26:02 <Saizan> roconnor: however you can use a flag and CPP, like if flag(extras) then { build-depends: category-extras; cpp-options: -DUSE_EXTRAS } else ...
11:26:11 <Saizan> roconnor: pure
11:28:34 <roconnor> Saizan: ah right
11:30:34 <|h0m3r|> hi
11:30:56 <dmwit_> Hiya, h0m3r!
11:31:20 <h0m3r> newbie here
11:31:32 <h0m3r> can anybody explain me what the @ means here? http://hpaste.org/11762
11:31:37 <vixey> why does durham not answer my emails :(
11:31:43 <dmwit> h0m3r: @ binds a full pattern to a different name.
11:31:53 <dmwit> s/different/additional/
11:31:56 * vixey is demanding haskell code from them..
11:32:09 <dmwit> So there, plan@((task, tiempo):tss) means:
11:32:19 <vixey> h0m3r, sorry you can't do non deterministic stuff like that in haskell
11:32:39 <camio> I'm looking for suggestions on cleaning up this reactive code. http://hpaste.org/11998
11:32:44 <dmwit> Pattern match the list against ((task, tiempo):tss) and bind those names as normal, then bind the name plan to the full list.
11:32:52 <h0m3r> its curry
11:32:52 <vixey> h0m3r, equational definitions need to be functions, so one alternative is to do,  who :: Task -> [Worker]
11:32:58 <vixey> h0m3r, oh that's fine then
11:33:10 <h0m3r> okok, thx for all
11:33:49 <vixey> h0m3r, some how I am used ot the code being completely littered with  where 'foo' free but I didn't notice any in yours (until I looked harder)
11:37:07 <vixey> it says "Plastic is available to interested parties. Please email for more information" :/
11:37:11 <vixey> am I not a party or something?
11:37:52 <Digit> hasnt anyone ever yet considered programing a help system that manages questions and answers and knowledgebases in one massive learning memory of who knows what, and can redirect answers to questioners, and failing fulfilment with that, redirects questions to groups with said knowledge, thus ever more increasing the effectiveness, and also ever decreasing help workload...
11:38:13 <camio> Digit: Like . . . a compiler?
11:38:38 <camio> Well, except it doesn't learn.
11:39:00 <Digit> ...?  um...  compilers do that?     see, this is why i havn't done it myself yet.  totally lack the grasp on the established technology and lingo yet.
11:39:01 <dmwit> Digit: We have such a system here!
11:39:04 <dmwit> ?faq
11:39:04 <lambdabot> The answer is: Yes! Haskell can do that.
11:39:13 <dmwit> ;-)
11:39:17 <Twey> Haha
11:39:25 <Digit> ;)   i knew i was in the right place.  :D
11:40:16 * vixey complains about people who put descriptions of software up but not code and not reply to your emails when you aks for the code ....
11:40:25 <dmwit> Digit: But really, the effort in developing such a system likely way outweighs the effort of manually filling in a system like ?where or ?hoogle that answer very specific questions very well.
11:41:03 <dmwit> vixey: So, you hate Microsoft?
11:41:14 <vixey> no Durham
11:41:21 <Digit> vixey...  sounds like the criminally intentional vapouware-ists, rather than the well meaning dreamers who've yet to acquire the skillset to actualise their vision.
11:41:24 <Twey> Heh
11:41:32 <vixey> vaporware! that's what it is!
11:41:47 <dmwit> Yeah, vaporware sucks.
11:41:55 <dmwit> But it's a fact of a programmer's life.
11:41:59 <vixey> I guess that is better than producing crap
11:42:05 <Digit> WHAAAT?   vapourware is great!   ...
11:42:09 <Digit> its like concept cars
11:42:12 <dmwit> Since basically nothing can be fully accomplished in the two-week obsession period that everyone gets...
11:42:21 <vixey> haha
11:43:46 <Digit> i've made a few linux distributions.  mainly tight stripped down ones, but some with massive innovations and improvements...  all vapourware, because of that fateful day where i was 15 minutes late to sign up for the standard grade computing class. lol
11:45:01 <dmwit> They're vaporware because you didn't sign up, or you had time to make distros because you didn't sign up? =)
11:45:39 * yaxu goes off to play duke nukem forever
11:50:17 <vixey> oh haskell maybe knows,  :) what to read about zippers?
11:50:45 <vixey> is there any big list of texts about it ?
11:50:48 <Twey> There's an article on them on WikiBooks...
11:51:38 <dmwit> If you want literature, search for data type derivatives.
11:51:43 <Digit> who knows, maybe if they let me take that class i'd know programming by now.
11:52:17 <Twey> Eh, Digit, I've never had a programming class in anything more powerful than VBA
11:52:27 <Digit> and be able to impliment these mad ideas.
11:53:04 <Digit> yeah.  anyways, enough of this what might have been rubbish.  i AM learning haskell now.  so alls well.  my vapourware shall manifest from the ether.   (to the ether?  lol)
11:53:36 <dmwit> That is the most common claim of the vaporware author. ;-)
11:54:22 <Twey> Self-study is wonderful.
11:54:56 <Digit> hehe, yeah, thankfully, i've never made the mistake of actually announcing anything.  i keep my vapour to myself, and instead share the ideas, incase anyone else can pick it up n run with it
11:56:06 <yaxu> hey dons, does plugins work with ghc 6.10.1?
11:56:33 <yaxu> i'm getting the same cabal problem logged here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
11:56:35 <lambdabot> Title: HackageDB: plugins-1.3.1, http://tinyurl.com/5mbt3u
11:59:07 <noteventime> Hullo
12:00:24 <dmwit> Hiya, noteventime!
12:00:30 <milian> hi, I'm new to haskell. Is it possible to manually implement a data constructor? I cannot find anything for that
12:00:40 <milian> i.e. data foo = foo {a, b :: float}
12:00:43 <vixey> yes you can milan
12:00:46 <milian> now I want that a <= b
12:00:57 <vixey> that you can't do though
12:00:58 <mm_freak> milian: types and constructors need to be written capitalized
12:00:58 <vixey> but both foo should be Foo
12:01:12 <Philonous> "Haskell will change the way you think about programming" - Yay, definitely. Now every time I see a "return" in C I start wondering which monad the value will be lifted into...
12:01:26 <milian> yes, I now that, just typed that into IRC out of my mind
12:01:30 <milian> @ mm_freak
12:01:36 <Cale> milian:  data Foo = Foo {a,b :: Float}
12:01:55 <milian> Cale: yes, my _real_ question is wether it's possible to enforce a <= b
12:02:03 <noteventime> Philonous: I know the feeling, I'm totally crippled when using compilers that don't support tail recursion
12:02:16 <Cale> milian: You can write another function, say, foo, which enforces the constraint at runtime.
12:02:37 <mm_freak> milian: this is about the same problem as enforcing an Integer to be a square
12:02:40 <Cale> milian: (and then not export the data constructor Foo from the module)
12:02:49 <mm_freak> you'll need to hide the constructor to do that
12:03:35 <Philonous> noteventime: Just imagine the people staring at you when you start writing everything as a recursion in C ^^
12:04:00 <milian> damn :-/
12:04:12 <milian> but thanks anyways
12:04:12 <noteventime> Philonous: Been there, done that :p
12:04:41 <mm_freak> since i'm programming in haskell, C is a PITA for me
12:04:52 <mm_freak> before that i used to love C (for whatever reason)
12:04:52 <dmwit> Philonous: In C, it's easy: return *always* lifts values into the IO monad. =)
12:05:14 <Philonous> mm_freak: Frankly, C has always been a PITA
12:05:17 <noteventime> In C I at least have Unions, even though they're a pain to use
12:05:46 <dmwit> milian: foo a b | a < b = Foo a b | otherwise = Foo b a -- for your specific case; but in general, no, runtime constraints are not enforceable without dependent types
12:05:47 <noteventime> Almost allows you to have some kind of ugly algebraic data types
12:06:35 <Philonous> dmwit: How are they enforcable with dependent types?
12:06:43 <milian> yep writing it right now, thanks dmwit
12:06:44 <mm_freak> noteventime: i'm unable to find a use case for unions, for which algebraic data types wouldn't be a good substitute
12:07:02 <dmwit> Philonous: You can have a type Less a b that asserts that a is smaller than b.
12:07:20 <dmwit> Philonous: Then your constructor has type a : Float -> b : Float -> Less a b -> Foo
12:07:49 <mm_freak> btw, it's fun to confuse other C coders by using functional concepts in C =)
12:07:51 <dmwit> Philonous: It is then up to the programmer to provide a proof that a will in fact be less than b at runtime.
12:08:03 * dmwit -> shower
12:08:55 <noteventime> mm_freak: Well, you can use unions to write simple data types, but you have to explicitly add a tag
12:09:07 <noteventime> And do the "pattern matching"
12:09:44 <mm_freak> noteventime: that's just algebraic data types =)
12:09:56 <mm_freak> what is the tag in C, is the constructor name in haskell
12:10:11 <noteventime> mm_freak: WAsn't that what I said?
12:10:33 <mm_freak> sounded like an attempt at a counterexample
12:10:42 <BMeph> noteventime: Did you mean structs? Because, unions in C are hideous and evil. :)
12:10:55 <noteventime> BMeph: I meant structs with unions :)
12:11:24 <noteventime> I'm not a C-expert, so I'm not sure on the terminology
12:11:59 <Savant> noteventime: you probably mean structures
12:12:23 <mm_freak> struct MyType { int type; union { struct A { … }; struct B { … }; }; }
12:12:28 <mm_freak> = data MyType = A … | B …
12:12:58 <noteventime> mm_freak: Exactly
12:13:25 <noteventime> + Some kind of enum for type
12:13:45 <mm_freak> why?
12:13:55 <mm_freak> the constructor name serves as 'type'
12:13:55 <noteventime> To make it nicer
12:14:10 <mm_freak> huh?  how would that make it nicer?
12:14:14 <noteventime> mm_freak: I mean when testing for the type of the struct
12:14:18 <Philonous> noteventime: You mean in C, don't you?
12:14:24 <noteventime> Yes
12:14:28 <mm_freak> noteventime: use pattern matching
12:14:37 <noteventime> mm_freak: Pattern matching in C? O_o
12:14:41 <Cale> Except in C, unions don't give you a way to tell which thing you have.
12:14:46 <mm_freak> in haskell
12:14:52 <mm_freak> maybe i don't understand what you mean
12:14:54 <noteventime> mm_freak: My comment was on the C code :)
12:15:01 <mm_freak> ah, ok =)
12:15:05 <Cale> (so you need to add some way explicitly)
12:15:14 <Philonous> noteventime: mm_freak already included the int as an enum type
12:15:52 <noteventime> Philonous: But no symbol for each type, you can't a.type = TypeA
12:16:01 <Philonous> Oh right.
12:16:23 <Philonous> I like to call my Constructors 1,2 and 3 anyway ;)
12:16:59 <noteventime> Talking about C, has anyone had any experience with Cyclone?
12:19:06 <Savant> What is Cyclone?
12:19:20 <Philonous> "Cyclone is a safe dialect of C."
12:19:21 <dons> a type safe c.
12:19:44 <Savant> Ah.
12:21:10 <noteventime> I found the idea interesting
12:21:32 <noteventime> But all the things that were needed to make it safe made to so verbose that there wasn't any point of it any more :p
12:22:16 <mm_freak> well…  it's like another C++, i guess
12:22:18 <dolio> Isn't the point of C speed, not concision?
12:22:23 <mm_freak> C is too flawed to be healable
12:22:37 <mauke> C is C++ healed
12:22:48 <mm_freak> indeed
12:22:52 <badsheepy> healed BY SATAN :o
12:22:53 <noteventime> Well, templates do add something
12:22:59 <badsheepy> confusion :D
12:23:11 <noteventime> LONG error messages
12:23:35 <mauke> "the memory-leak-oriented language C++"
12:23:57 <velco> heh
12:26:37 <noteventime> Hmm, can someone think of a nice way to "extract" the maximum element of a list (returning the element and the rest of the list, without changing the order of the list)?
12:27:02 <mauke> maximumBy (comparing fst) . select
12:27:03 <Zao> \x -> (x, maximum x)
12:27:07 <vixey> noteventime: sounds like a job for ... Continuation Passing Style!
12:27:16 <dons> vixey: no..
12:27:46 <noteventime> mauke: select?
12:28:07 <dons> i think that's a mauke function
12:28:29 <noteventime> CPS makes my head spin
12:28:31 <vixey> dons, "no"?
12:28:37 <mm_freak> originally that's an mm_freak function…  i used it for calculating permutations
12:28:47 <vixey> mm_freak, it's from Prolog
12:29:27 <mm_freak> oh
12:29:35 <mm_freak> well, here's mine: http://hpaste.org/12005
12:30:02 <vixey> dons, do you have some reasoning for that? I can't see any good way to derive this except CSP
12:30:04 <vixey> dons, do you have some reasoning for that? I can't see any good way to derive this except CPS*
12:30:06 <opqdonut> mauke: heh, nice one
12:31:14 <noteventime> mm_freak: Wow, thanks :)
12:31:26 <noteventime> I've been looking for something like that for long
12:31:38 <mm_freak> noteventime: why haven't you written it yourself?
12:31:58 <noteventime> mm_freak: Well, I didn't quite realise I wanted it in general :)
12:32:16 <noteventime> I've just run into the kind of problem where I needed something like that a couple of times
12:32:16 <mm_freak> generalization is one of the key features of haskell =)
12:32:21 <noteventime> And, I'm not much of a programmer
12:32:39 <noteventime> Though Haskell is getting me into it
12:32:43 <Philonous> This thing looks horrible, you need to look at it twice to make sure lazynes tames it
12:33:06 <noteventime> Well, efficiency in not a concern at the moment
12:33:39 <vixey> noteventime, if you don't care about efficiency then definitely maukes way is good, but if you did the CPS is the way to go
12:33:46 <mm_freak> Philonous: hmm?  i don't see anything strict in it
12:34:57 <noteventime> vixey: I may rewrite it in CPS, which I find fun at times, it's just that it would take too much thinking at the moment. I'm really not used to thinking in CPS
12:35:15 <mmorrow> , let maxAndRest [] = (Nothing,[]) ; maxAndRest (x:xs) = go x xs xs ; go x xs [] = (Just x, xs) ; go x xs (y:ys) = if x < y then go y ys ys else go x xs ys in maxAndRest ([0..20]++[1000]++[0..9])
12:35:18 <vixey> noteventime, It's a tricky example if you aren't used to CPS yeah
12:35:22 <lunabot>  (Just 1000,[0,1,2,3,4,5,6,7,8,9])
12:35:49 <Philonous> mm_freak: Never mind. I just meant you have to think lazy to not be shocked by this definition
12:36:07 <mm_freak> Philonous: ah, ok, then i misunderstood you
12:36:18 <mmorrow> i was going to use cps but found that way simpler/more straightforward
12:36:41 <mmorrow> rephrasing.. that's first way i saw to do it
12:36:42 <dolio> mmorrow: That chopped off the [0..20]
12:36:56 <mmorrow> dolio: i think it was supposed to
12:37:18 <noteventime> I've been "exposed" to programming for long, but I barely ever actually wrote any code before I learned Haskell
12:38:29 <mm_freak> well…  it's fun =)
12:39:16 <mm_freak> > fix (\k r s -> s : k (r+1) (s + 2*r + 1)) 0 0
12:39:18 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
12:39:43 <vixey> parsing parenthesised expressions is a good practice excercise
12:39:46 <mm_freak> i got to love the fix function recently for some reason =)
12:40:35 <dmwit> > scanl (+) 0 [1,3..]
12:40:37 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
12:40:49 <mm_freak> i think, because it's more convenient than iterate
12:40:51 <dmwit> Mine's more readable. ;-)
12:40:58 <mm_freak> true
12:41:05 <pejo> Suppose I want to use the wildcards for data-files in Cabal, and have a file called data/data.tar.gz and another file data/data2.gz. What do I do?
12:41:07 <mm_freak> but there isn't always such a nice shortcut =)
12:41:11 <vixey> > map square [0..] -- mine doesn't work
12:41:12 <lambdabot>   Not in scope: `square'
12:41:22 <mm_freak> > map (^2) [0..]
12:41:23 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
12:41:24 <dmwit> > map (^2) [0..] -- works, but it's "slower"
12:41:25 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
12:41:39 <int-e> > scanl (+) 0 [1,3..]
12:41:40 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
12:42:01 <dmwit> int-e: Beatcha to it. ;-)
12:42:33 <int-e> dmwit: oh. my window is too small :)
12:43:28 <mmorrow> , fix (\k n xs -> if null xs then [] else let (ys,zs) = splitAt n xs in ys : k n zs) 4 [0..]
12:43:31 <lunabot>  [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23...
12:43:49 <mmorrow> , fix (\k n xs -> if null xs then [] else let (ys,zs) = splitAt n xs in ys : k (n+1) zs) 0 [0..]
12:43:52 <lunabot>  [[],[0],[1,2],[3,4,5],[6,7,8,9],[10,11,12,13,14],[15,16,17,18,19,20],[21,...
12:44:19 <mmorrow> , fix (\k n xs -> if null xs then [] else let (ys,zs) = splitAt n xs in ys : k x zs) 0 [0..]
12:44:21 <lunabot>  luna: Not in scope: `x'
12:44:32 <mmorrow> , fix (\k n xs -> if null xs then [] else let (ys,zs) = splitAt n xs in ys : k (head x) zs) 0 [0..]
12:44:35 <lunabot>  luna: Not in scope: `x'
12:44:37 <mmorrow> , fix (\k n xs -> if null xs then [] else let (ys,zs) = splitAt n xs in ys : k (head xs) zs) 0 [0..]
12:44:40 <lunabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
12:44:40 <vixey> zipper only works on polynomial functors? :/
12:44:55 <mmorrow> , fix (\k n xs -> if null xs then [] else let (ys,zs) = splitAt n xs in ys : k (xs!!1) zs) 0 [0..]
12:44:58 <noteventime> Is there something like a rezip? (uncurry (zipWith f)) . unzip) ?
12:44:58 <lunabot>  [[],[0],[1],[2,3],[4,5,6],[7,8,9,10,11],[12,13,14,15,16,17,18,19],[20,21,...
12:45:15 <vixey> noteventime, map (uncurry f)
12:45:16 <mmorrow> , fix (\k n xs -> if null xs then [] else let (ys,zs) = splitAt n xs in ys : k (zs!!0) zs) 0 [0..]
12:45:19 <lunabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
12:45:21 <mmorrow> heh
12:46:14 <noteventime> vixey: Ouch, that's a lot neater :p, but still, nothing in the standar library?
12:46:26 <vixey> map and uncurry are in the standard library
12:46:29 <noteventime> Not some strange arrow operation that does it :p
12:46:36 <vixey> http://en.wikibooks.org/wiki/Haskell/Zippers -- what's the answer to 3 ?   "# Rhetorical question concerning the previous exercise: what's the difference between a list and a stack?"
12:46:41 <mmorrow> vixey: haha, i was about to say that /verbatim/
12:46:49 <vixey> noteventime, this isn't arrows
12:46:57 <vixey> :t map
12:46:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:47:00 <vixey> :t uncurry
12:47:01 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:47:04 <vixey> simple typed stuff
12:47:37 <noteventime> vixey: I wasn't literal, I meant if there was some higher level function that did what (map (uncurry f)) does
12:47:39 <vixey> noteventime, but you probably need a file like for your own utilies that will be useful in several programs soon
12:47:58 <vixey> noteventime, & let  whateverYouWannaCallIt = map . uncurry  in there
12:50:00 <mml`> @pl map . uncurry
12:50:00 <lambdabot> map . uncurry
12:50:19 <_pizza_> so much for ghci responding to Ctrl+C
12:50:25 <mmorrow> @unpl map . uncurry
12:50:25 <lambdabot> (\ c -> map (uncurry c))
12:50:44 <mmorrow> _pizza_: did you run "fix id" or something?
12:50:46 <vixey> _pizza_, I know.. it sucks.. I tried setting a heap and stack limit but then everything crashes immediately
12:50:46 <Philonous> @hoogle String -> Int
12:50:46 <lambdabot> Prelude read :: Read a => String -> a
12:50:46 <lambdabot> Text.Read read :: Read a => String -> a
12:50:46 <lambdabot> Prelude error :: String -> a
12:51:04 <_pizza_> mmorrow: something like that
12:51:44 <mmorrow> it'll spin with no way to kill it other than ^Z  killall -9 ghc  if you run something that doesn't allocate
12:51:48 <Philonous> > read "abc123def" :: Int
12:51:48 <mmorrow> (and runs forever)
12:51:49 <lambdabot>   * Exception: Prelude.read: no parse
12:51:52 <noteventime> Why does fmap f apply f to the second element of the pair?
12:52:10 <mauke> @src (,) fmap
12:52:10 <lambdabot> fmap f (x,y) = (x, f y)
12:52:29 <Philonous> Is there something like safeRead :: Reada => String -> Maybe a ?
12:52:36 <roconnor> reads
12:52:40 <mmorrow> reads + a case expression
12:52:42 <roconnor> :type readS
12:52:48 <mauke> listToMaybe . reads
12:52:50 <vixey> does anyone have some programs using zippers I can read?
12:52:51 <Philonous> Thanks
12:52:51 <roconnor> @type readS
12:52:52 <lambdabot> Not in scope: `readS'
12:52:54 <mmorrow> @type reads
12:52:55 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:53:03 <_pizza_> mmorrow: yeah it hit my disk so hard it simply wouldn't respond; pretty sure it doesn't help it's in a VM on a laptop
12:53:13 <mmorrow> _pizza_: heh
12:53:19 <mauke> :t fmap fst . listToMaybe . reads
12:53:19 <lambdabot> forall a. (Read a) => String -> Maybe a
12:53:24 <pejo> vixey, Oleg has some code on his homepage for a filesystem
12:53:34 <vixey> thanks
12:53:35 <dolio> > let para f z [] = z ; para f z (x:xs) = f x xs (para f z xs) in para (\x xs -> ((x,xs):) . map (second (x:))) [] [1..4]
12:53:35 <mmorrow> i have that in a darcs repo
12:53:36 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
12:53:37 <Philonous> @src listToMaybe
12:53:37 <lambdabot> listToMaybe []        =  Nothing
12:53:37 <lambdabot> listToMaybe (a:_)     =  Just a
12:53:41 <roconnor> :t listToMaybe . fmap fst . reads
12:53:42 <lambdabot> forall a. (Read a) => String -> Maybe a
12:54:02 <mmorrow> http://moonpatio.com/repos/zfs/
12:54:04 <Philonous> Ah great.Thanks again
12:54:06 <lambdabot> Title: Index of /repos/zfs
12:54:11 <roconnor> still not right
12:54:13 <vixey> thanks
12:54:23 <mmorrow> all you have to do is run ./make.sh , then telnet localhost <can't remember>
12:54:32 <mmorrow> cool stuff
12:54:39 <mmorrow> (well, you have to run it too :)
12:54:54 <roconnor> :t (\x -> listToMaybe [a | (a,"") <- reads x])
12:54:55 <lambdabot> forall a. (Read a) => String -> Maybe a
12:55:01 <roconnor> ^^ better
12:55:43 <roconnor> Philonous:
12:56:19 <Philonous> What's wrong with the fmap version?
12:56:41 <roconnor> it doesn't check that the remaining unparsed text is empty
12:57:06 <Philonous> Oh, ok
12:57:08 <mightybyte> Has learning haskell destroyed anyone else's imperative programming productivity?
12:57:18 <vixey> mightybyte, not me
12:57:46 <Vulpyne> It's certainly destoryed my imperative programming enjoyment.
12:57:49 * sw17ch notes the striking similarities between ARINC 653 Sampling/Queuing Ports and Haskell MVar's and TChan's
12:57:49 <Vulpyne> Er, destroyed.
12:57:58 <mightybyte> vixey: It has me.  I keep getting upset that I don't have wonderful things like currying.
12:58:23 <vixey> I don't want to use functional programming idioms in any imperative programs
12:58:24 <Vulpyne> I am glad my boss lets me write most stuff in Haskell. :)
12:58:31 <mightybyte> For me, enjoyment is highly correlated with productivity.
12:58:56 <vixey> I think there is more than one interesting programming paradaigm
12:59:58 <mightybyte> vixey: Of course, but some of them lack important features for creating good abstractions.
13:00:23 <vixey> such as?
13:00:39 <mightybyte> Convient function abstraction. :)
13:01:01 <vixey> uh :) I can't tell if you are joking or not
13:01:20 <mightybyte> No, I'm serious.
13:01:58 <mightybyte> The keyword there is convenient.
13:08:52 <vixey> "Zipper can be viewed as a delimited continuation reified as a data structure."
13:09:18 <mightybyte> Is that quote for me?
13:09:40 <mmorrow> i never understood that sentence until i read oleg's two Zipper*.lhs's
13:09:50 * mmorrow recommends them
13:11:02 <mmorrow> http://okmij.org/ftp/Haskell/Zipper1.lhs
13:11:08 <mmorrow> http://okmij.org/ftp/Haskell/Zipper2.lhs
13:11:29 <opqdonut> ah, that kind of zipper
13:12:18 <opqdonut> seeing the two different approaches opened my eyes
13:12:31 <opqdonut> datastructure-oriented vs. function oriented
13:12:54 <opqdonut> i think i still like differentiating datastructures more
13:13:48 <mmorrow> personally, i'm not a fan of the whole datastr differentiation thing
13:14:51 <vixey> mmorrow, why?
13:15:44 <mmorrow> vixey: i guess because i feel like using "differentiation" is the wrong abstraction
13:15:53 <mmorrow> (i don't know the right one either)
13:16:16 <pejo> Do I need something more than "install-includes: include/file.h" in my cabal file to get file.h to appear somewhere under $prefix after a cabal install?
13:16:31 <Stephen|Edibles> Who enjoys playing spot the difference?
13:16:32 <opqdonut> of course the traversor function approach is cleaner (in terms of encapsulation)
13:16:47 <Stephen|Edibles> I have two seemingly identical bits of haskell code - one is mine, the other a friends.
13:16:54 <Stephen|Edibles> To me, they are identical
13:16:57 <vixey> opqdonut, what do you mean cleaner?
13:17:01 <Stephen|Edibles> But his passes a quickCheck, and mine doesnt.
13:17:24 <Twey_> Stephen|Edibles: Paste 'em up :)
13:17:24 <opqdonut> vixey: well you don't have to see/touch the actual data definition
13:17:39 <Stephen|Edibles> http://hpaste.org/12009
13:18:03 <Stephen|Edibles> (and yeah, I dont think the code is actually perfect either, but it suffices for our purposes. I think ^^)
13:18:53 <vixey> Stephen ptu it thourgh 'diff' program
13:19:19 <vixey> btw I don't like the way these are written :p
13:19:38 <vixey> 1 bit
13:19:47 <Twey> Stephen|Edibles:
13:19:47 <Twey> toNNF (Not (p :&: q)) = toNNF (Not p) :|: toNNF (Not p)
13:19:47 <Twey> toNNF (Not (p :|: q)) = toNNF (Not p) :&: toNNF (Not p)
13:19:54 <Twey> That's obviously borked :)
13:20:14 <Stephen|Edibles> *cries*
13:20:19 <vixey> @check \p q -> not (p && q) == not p || not q
13:20:20 <lambdabot>   "OK, passed 500 tests."
13:20:25 <vixey> @check \p q -> not (p || q) == not p && not q
13:20:26 <lambdabot>   "Falsifiable, after 2 tests:\nTrue\nTrue\n"
13:20:32 <Twey> Heh
13:20:38 <Stephen|Edibles> Twey, thankee very much
13:20:38 <p_l> Peaker: That wouldn't be heuristics anymore. That would require Strong AI
13:20:43 <vixey> @check \p q -> not (p || q) == not (p && q)
13:20:44 <lambdabot>   "Falsifiable, after 1 tests:\nTrue\nFalse\n"
13:20:55 <Twey> Stephen|Edibles: Welcome :)
13:21:55 <Stephen|Edibles> Vixey: In what way do you not like how're they're written?
13:22:01 <vixey> Stephen, yeah
13:22:18 <Stephen|Edibles> So, you dont like them in the 'yeah' way... :P
13:23:00 <Twey> Heh
13:23:05 <im_maciek> how to set quickCheck's number of tests? 100 is not enough for me ;]
13:23:27 <Stephen|Edibles> Just run it a few times maciek ;)
13:23:51 <im_maciek> "OK, passed 500 tests." looks more pr0
13:24:04 <sciolizer> @type quickCheck
13:24:06 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
13:24:20 <sciolizer> ok, so it's impure, so running it multiple types probably will work
13:24:29 <sciolizer> s/types/times/
13:24:40 <dmwit> It should also be possible to set the test count.
13:24:52 <dmwit> Have you had a look in the docs yet?
13:25:54 <im_maciek> haskell wiki mentions deepCheck
13:26:43 <dmwit> Huh, the quickcheck module *doesn't* seem to provide a way to change the count.
13:26:55 <dmwit> ?index quickCheck
13:26:55 <lambdabot> Test.QuickCheck, Debug.QuickCheck
13:27:28 <dmwit> Ah, here we go
13:27:30 <dmwit> :t check
13:27:31 <lambdabot> Not in scope: `check'
13:27:37 <dmwit> :t Test.QuickCheck.check
13:27:38 <lambdabot> Not in scope: `Test.QuickCheck.check'
13:27:44 <dmwit> uh
13:27:50 <im_maciek> deepCheck p = check (defaultConfig { configMaxTest = 10000}) p
13:27:57 <dmwit> yup
13:28:00 <Stephen|Edibles> Deepcheck does 10000 tests, doesnt it?
13:28:06 <dmwit> You can specify a config for the check function.
13:28:08 <im_maciek> you can obviously change the value
13:28:12 <Stephen|Edibles> Dammit, ninjad ^^
13:30:59 <vixey> is there a program which prints out zippers automatically?
13:37:14 <Axman6> vixey: zippers are a kind of tree right? if they are, and can be converted to a Data.Tree (i think) then you could its showTree function i guess...
13:37:29 <opqdonut> well
13:37:29 <vixey> I mean  data ... = ...
13:37:36 <opqdonut> vixey: yeah
13:37:37 <vixey> I want some of these and the assoc. zippers=
13:37:49 <opqdonut> can't remember the name tho
13:38:03 <vixey> I found one on the wikibook
13:38:05 <vixey> but any more ?
13:38:58 <Peaker> p_l: I just got your message. You might be right, but I hope you are wrong :)
13:39:16 <Peaker> p_l: To me it seems like the various database solutions people use don't vary that much
13:41:16 <Vulpyne> http://hpaste.org/12010 -- Is there a more idiomatic way to test a bunch of conditions until the first matching one, then return an associated result? (While accomodating a fallthrough case.)
13:41:46 <vixey> Vulpyne, I like setting  (-->)  = (,0
13:41:48 <vixey> Vulpyne, I like setting  (-->)  = (,) **
13:41:57 <vixey> Vulpyne, then you can do  [ cond1 --> then1 , cond2 --> ...
13:43:13 <Twey> Uh, is that legal?
13:43:22 <Twey> > --
13:43:23 <lambdabot>   <no location info>: parse error on input `;'
13:43:28 <mauke> tee hee, I use ~> in my xmonad.hs
13:43:44 <Twey> > 3 --foo
13:43:45 <lambdabot>   3
13:43:47 <vixey> seems to work
13:43:54 <vixey> @let (-->) = (,)
13:43:55 <lambdabot>  Defined.
13:44:19 <Vulpyne> Hmm, will that do what I wanted though? I can see it building tuples.
13:44:22 <Apocalisp> I'm looking for a method of "reverse querying", i.e. matching queries with data without evaluating each query. For when the number of queries is in the millions but the data they can match is a single record.
13:44:29 <Vulpyne> But I want the result of the first true match.
13:44:32 <Apocalisp> Does that ring any bells anywhere?
13:45:07 <Vulpyne> Or were you talking about just the list part?
13:46:16 <byorgey> @type find
13:46:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:47:05 <byorgey> Vulpyne: a much nicer implementation for findMatch would be something like  findMatch l d = maybe d snd (find fst l)
13:47:06 <Vulpyne> I guess there's no idiom for it, but it seems to me it would be something relatively common.
13:47:25 <Vulpyne> That's true.
13:48:22 <Twey> > 3 --> 4
13:48:23 <lambdabot>   (3,4)
13:48:33 <Twey> How odd.
13:49:51 <byorgey> > let findMatch d l = maybe d snd (find fst l)  in  findMatch 'x' [ (5 > 6)  --> 'g', not (null []) --> 'r',  (9 == 9) --> 'e' ]
13:49:52 <lambdabot>   'e'
13:50:07 <vixey> Twey, what's odd?
13:50:25 <byorgey> --> is a perfectly cromulent operator
13:50:30 <opqdonut> :D
13:50:32 <opqdonut> indeed
13:50:36 <vixey> @let cond ((True,x):_) = x ; cond (_:y) = cond y
13:50:37 <lambdabot>  Defined.
13:51:06 <vixey> > let abs x = cond [ x > 0 --> x, x <= 0 --> (-x) ] in abs 4
13:51:07 <lambdabot>       Occurs check: cannot construct the infinite type: a = (t, a)
13:51:07 <lambdabot>        Exp...
13:51:14 <vixey> > let abs x = cond [ (x > 0) --> x, (x <= 0) --> (-x) ] in abs 4
13:51:16 <lambdabot>   4
13:51:36 <Twey> > cond ((False, False), False)
13:51:37 <lambdabot>   Couldn't match expected type `[(Bool, t)]'
13:51:38 <opqdonut> how lispy
13:51:59 <byorgey> > cond [(False,undefined)]
13:52:00 <lambdabot>   * Exception: <local>:3:0-42: Non-exhaustive patterns in function cond
13:52:11 <yitz> @let perl_hash = Data.Map.fromList
13:52:12 <lambdabot>  <local>:4:12: Not in scope: `Data.Map.fromList'
13:52:15 <Twey> That's the one.
13:52:17 <vixey> hehe
13:52:33 <dons> ?users
13:52:33 <lambdabot> Maximum users seen in #haskell: 547, currently: 538 (98.4%), active: 19 (3.5%)
13:52:35 <_pizza_> named record members cannot overlap, even if they're members of different records?!
13:53:18 <byorgey> _pizza_: no =(
13:53:27 <dmwit> Named record members may overlap, provided they are members of the same data type.
13:53:33 <yitz> @let perl_hash = M.fromList
13:53:33 <Vulpyne> Well, at least it's nicer than nesting tons of if-then-elses.
13:53:33 <lambdabot>  <local>:4:12:
13:53:33 <lambdabot>      Ambiguous type variable `k' in the constraint:
13:53:33 <lambdabot>        `Or...
13:53:34 <erikc> weird, company just upgraded their antivirus and my ghc install exe got detected as containing a virus (Fake.MP virus)
13:53:44 <_pizza_> byorgey: yikes.
13:53:48 <byorgey> _pizza_: although GHC 6.10.1 has some disambiguation features that may let you overlap names in certain circumstances.
13:54:09 <dmwit> data Foo a = Foo { foo :: a, bar :: Float } | Bar { foo :: a, quux :: Double } -- totally valid
13:54:37 <yitz> oh well. anyway, you could write:  perl_hash ["name" --> "yitz", "language" --> "not perl"] in perl_hash ! "language"
13:54:41 <dmwit> But yes, for cross-data-declaration members, you would have to declare a type class to use the same name (or use the module system).
13:54:44 <wjt> So i have a file where each line is a record, fields separated by '\t', and the set of fields on the line is determined by the first field (one of four strings).  Ideally I'd write  do { string "mr" ; return $ MethodReturn <$> field1 <*> ... <*> field5 } (given a local definition of <*> working around parsec-2's lack of an applicative instance) but I need to specify the separating tabs.  Should I be looking at tokenizing the input first?
13:55:08 <Twey> Ew
13:55:15 <Twey> Automatically-generated incomplete instances?
13:55:25 <dmwit> Twey: eh?
13:55:50 <dmwit> wjt: Tokenizing could be nice.  And it sounds like your tokenizer might even just be "map words . lines". =)
13:55:54 <vixey> It's not even an instance
13:55:55 <Twey> bar $ Bar { foo = 3, quux = 4.0 } -- error
13:56:12 <dmwit> Twey: Yup, you can create partial functions this way.
13:56:22 * byorgey shudders
13:56:41 <byorgey> basically, you should never ever use named record fields with data types that have more than one constructor.
13:56:53 * Twey nods.
13:56:56 <vixey> I think that should eb asyntactic restriction
13:57:02 * byorgey agrees
13:57:06 <_pizza_> sigh
13:57:40 <byorgey> _pizza_: as great as I think Haskell is, I do have to admit that records are one place where it could use a lot of improvement
13:57:58 <wjt> dmwit: it would indeed. So then I'd map 'parse' across that list of tokens, with parsers of type GenParser String () a ?
13:58:07 <byorgey> unfortunately, there's not much consensus as to what would be better
13:58:23 <dmwit> wjt: You could, or you could write a GenParser [String] () a.
13:58:53 <wjt> oh right
13:58:58 <byorgey> erm, no, GenParser String () a is right
13:59:05 <byorgey> I think instead of 'map' wjt meant 'apply'
13:59:06 <wjt> doh, of course
13:59:18 <dmwit> byorgey: Hm, for a "map words . lines" tokenizer?
13:59:26 <dmwit> :t map words . lines
13:59:27 <lambdabot> String -> [[String]]
13:59:35 <byorgey> oh, sorry, I missed that part
13:59:57 <dmwit> :t (>=>)
13:59:58 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:00:13 <dmwit> :t lines >=> words
14:00:14 <lambdabot> String -> [String]
14:00:23 <byorgey> oooooooh
14:00:28 <lilac> :type (words =<<) . lines
14:00:32 <dmwit> I guess you could use that tokenizer, too, but then you might as well use just "words".
14:00:53 <byorgey> is  words ever not equivalent to  lines >=> words?
14:01:04 <lilac> :t (words =<<) . lines
14:01:05 <lambdabot> String -> [String]
14:01:20 <dmwit> ?check liftM2 (==) words (lines >=> words)
14:01:21 <lambdabot>   "OK, passed 500 tests."
14:01:29 <byorgey> quickcheck++
14:01:33 <lilac> > ((lines >=> words) "hello\n\nworld", words "hello\n\nworld")
14:01:34 <lambdabot>   (["hello","world"],["hello","world"])
14:01:41 <lilac> lines--
14:01:55 <wjt> heh, of course the tokenizer is just words
14:02:00 <Twey> What is a >=>?
14:02:07 <dmwit> Twey: monadic composition
14:02:19 <dmwit> :t (>=>)
14:02:20 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:02:22 <byorgey> Twey: it's composition in a Kleisli category ;)
14:02:30 * Twey tilts vis head.
14:02:31 * lilac slaps self
14:02:37 <Twey> :t (>=>)
14:02:37 <Twey> New oneon me
14:02:37 <Twey> one on**
14:02:38 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:02:57 <byorgey> > lines "hello\n\nworld"  -- works ok
14:02:58 <lambdabot>   ["hello","","world"]
14:03:00 <vixey> (f >=> g) x = f x >>= g
14:03:04 <Twey> So... how does that work?
14:03:10 <lilac> byorgey: see above re slaps self
14:03:17 <byorgey> lilac: ah, hehe =)
14:03:21 <Twey> But g is b ->... oh
14:03:25 <vixey> > lines "hello\n\nworld" >>= words
14:03:26 <lambdabot>   ["hello","world"]
14:03:36 <Twey> Makes sense now.  :)
14:03:38 <vixey> > (lines >=> words) "hello\n\nworld"
14:03:39 <lambdabot>   ["hello","world"]
14:03:47 <sw17ch> @type lines
14:03:48 <lambdabot> String -> [String]
14:04:04 <sw17ch> Why was it that we didn't make that generic again?
14:04:11 <byorgey> actually, I would argue that >=> is a much more intuitive operator for first understanding monads than >>=
14:04:15 <vixey> "generic"?
14:04:27 <sw17ch> lines == split "\n"
14:04:34 <sw17ch> vixey ^^
14:04:35 <byorgey> sw17ch: the reason is that there are about ten different ways to generalize it.
14:04:42 <Twey> :t split
14:04:43 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
14:04:50 <sw17ch> @index split
14:04:50 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.TH.Ppr, System.Random
14:04:52 <dmwit> byorgey: Hum.  What do the monad laws look like in terms of (>=>)? =P
14:04:57 <Twey> sw17ch: Do you mean split '\n'?
14:05:05 <Twey> But... no such function :-\
14:05:13 <byorgey> dmwit: return >=> m = m
14:05:16 <sw17ch> Twey: i like the one from ruby
14:05:17 <vixey> (f >=> g) >=> h = f >=> (g >=> h)
14:05:20 <byorgey> m >=> return = m
14:05:25 <byorgey> and the one vixey wrote
14:05:31 <yitz> > (lines >=> groupBy (comparing (`elem` "aeiou"))) "hello\n\nworld"
14:05:32 <lambdabot>   Couldn't match expected type `Bool'
14:05:44 <Twey> I hear there are plans for a generic String class.
14:05:48 <sw17ch> "abbabbabba".split("bb") == "a","a","a","a"
14:05:50 <byorgey> they're just exactly what says that >=> is the composition of a category with return as the identity.
14:05:51 <dmwit> byorgey: Those don't type-check with the old laws.
14:06:01 <byorgey> dmwit: they don't?
14:06:11 <dmwit> :t \m -> m >=> return
14:06:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> a -> m b
14:06:21 <vixey> : t(?f >=> ?g) >=> ?h == ?f >=> (?g >=> ?h)
14:06:28 <dmwit> :t \m -> m >>= return
14:06:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
14:06:31 <vixey> :t (?f >=> ?g) >=> ?h == ?f >=> (?g >=> ?h)
14:06:32 <lambdabot>     Couldn't match expected type `b -> m b1'
14:06:32 <lambdabot>            against inferred type `Bool'
14:06:32 <lambdabot>     In the first argument of `(>=>)', namely `?h == ?f'
14:06:44 <vixey> :t (?f >=> ?g) >=> ?h `asTypeOf` ?f >=> (?g >=> ?h)
14:06:45 <lambdabot> forall (m :: * -> *) b c. (Monad m, ?f::b -> m c, ?g::c -> m b, ?h::b -> m c) => b -> m c
14:07:00 <sw17ch> Twey: I think it should be (or have a version that is) split :: [a] -> [a] -> [[a]]
14:07:01 <dmwit> byorgey: And a similar problem for the associativity law.
14:07:02 <Twey> I want ++ to be a constructor :(
14:07:02 <byorgey> dmwit: I'm pretty sure they are equivalent in some sense.  I'd have to think about it more carefully.
14:07:05 <wjt> eh, writing the GenParser String () () for which used to be just many1 alphaNum is not obvious
14:07:08 <dmwit> byorgey: right
14:07:09 <yitz> > (lines >=> groupBy ((==) `on` (`elem` "aeiou"))) "hello\n\nworld"
14:07:10 <lambdabot>   ["h","e","ll","o","w","o","rld"]
14:07:18 <sw17ch> Twey: oh! me too
14:07:20 <vixey> what's the problem
14:07:28 <Twey> Ooh, that's good
14:07:46 <dmwit> :t \m n -> const m >=> n
14:07:47 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> a -> m c
14:07:58 <dmwit> uh
14:08:00 <dmwit> ah
14:08:16 <sw17ch> f ("hi there" ++ b) = b
14:08:19 * sw17ch wishes
14:08:20 <dmwit> :t let m >>= f = const m >=> f in (>>=)
14:08:21 <lambdabot> forall (m :: * -> *) b c a. (Monad m) => m b -> (b -> m c) -> a -> m c
14:08:38 <vixey> :t (>>=)
14:08:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:08:43 <sw17ch> f "hi there jim" -> " jim"
14:09:01 <dmwit> Yeah.
14:09:07 <Twey> sw17ch: Problem is, it's ambiguous... if you have f (a ++ b) = b, what does it do?
14:09:08 <vixey> ++ a constructor.. not pattern matching on functions?
14:09:25 <sw17ch> Twey: yeah, that is a problem
14:09:38 <dmwit> :t isPrefixOf
14:09:39 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
14:09:48 * sw17ch wonders if view patterns can do that
14:09:49 <yitz> now that ++ is mappend, it's even more funky :)
14:09:49 <dolio> :t let m >>= f = const m >=> f $ return () in (>>=)
14:09:50 <lambdabot>     Ambiguous type variable `m' in the constraint:
14:09:50 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:30-38
14:09:50 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
14:09:51 <dmwit> f x | isPrefixOf "hi there" x = ...
14:10:03 <Twey> Yeah, but you can't pattern-match with that :-P
14:10:07 <vixey> sw17ch, I see no way to turn a function a -> b into a -> [b] with a view pattern
14:10:09 <Twey> Until view patterns, aye.
14:10:09 <EmielRegis> is there a way
14:10:11 <EmielRegis> of doing
14:10:16 <EmielRegis> do - while loop in haskell?>
14:10:16 <vixey> not even with view patterns
14:10:20 <vixey> EmielRegis, yes
14:10:25 <sw17ch> vixey: i do'nt know view patterns yet.. so i was just stabbing at it :)
14:10:35 <EmielRegis> vixey ?
14:10:45 <yitz> EmielRegis: but why would you want to?
14:10:54 <Twey> EmielRegis: Yes, recursion or an infinite list and takeWhile :)
14:11:11 <byorgey> EmielRegis: in Haskell, you often express loops in terms of an operation applied to each element of a list, rather than writing an explicit loop
14:11:14 <ziman> > until (>10) (+1) 1
14:11:15 <lambdabot>   11
14:11:31 <EmielRegis> im solving a logical  problem in hard way
14:11:41 <EmielRegis> and if i dont use something as do-while i get infinite loops
14:11:48 <dolio> :t let m >>= f = const m >=> f $ () in (>>=)
14:11:49 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
14:11:52 <dmwit> List monads are nice for logic problems.
14:11:52 <byorgey> EmielRegis: so the short answer to your question is "not really", but the long answer is "that sort of control flow is expressed differently in a functional program"
14:11:54 <vixey> EmielRegis, what is the logical problem?
14:12:03 <Twey> EmielRegis: What's the problem?
14:12:07 <EmielRegis> its converting a logical statement in CNF
14:12:14 <EmielRegis> im doing fine
14:12:18 <vixey> EmielRegis, You can do that without loops and without while loops
14:12:20 <Twey> byorgey: Well, it's possible to implement
14:12:27 <EmielRegis> until i have to reduce reduntant True and False statments
14:12:31 <Twey> byorgey: Just silly :-P
14:12:33 <EmielRegis> i know...
14:12:36 <EmielRegis> lemme check something
14:12:41 <vixey> EmielRegis, I think someone just a moment ago pasted a really weird verision I didn't like
14:12:51 <vixey> EmielRegis, I know a better way to implement it though
14:12:57 <byorgey> Twey: of course it is.  that's why it was a short answer. =)
14:12:58 <Twey> vixey: Didn't have enough folds for you?  :-P
14:13:24 <vixey> Twey, yeah this is a fold
14:13:46 * Twey laughs.
14:13:48 <EmielRegis> OMG
14:13:49 <EmielRegis> i did it
14:13:50 <EmielRegis> woohoo
14:14:03 <Vulpyne> Hurrah!
14:14:05 <vixey> EmielRegis,hpaste it ? :p
14:14:05 * Twey gives EmielRegis a cookie.
14:14:08 <EmielRegis> not really efficient way...
14:14:13 <EmielRegis> but serves the purpose
14:14:22 <shepheb> Not enough fold, build more farms.
14:14:52 <EmielRegis> http://hpaste.org/12011
14:15:08 * sw17ch wants a graph of hpaste submissions and views
14:15:09 <vixey> Twey, think about it though, the fold is perfect. it gives you all the termination guarantee and the right postconditions you want, it is set up just right
14:15:16 <EmielRegis> it runs for ages
14:15:20 <EmielRegis> but passes my quickCheck XD
14:15:42 <vixey> EmielRegis wow :)) do you have the quickcheck script?
14:15:49 <EmielRegis> ye
14:15:50 <Twey> Folds are quite obfuscating
14:16:01 <EmielRegis> do you want to see it?
14:16:05 <vixey> Twey, compared to that mess in the hpaste??
14:16:11 <vixey> EmielRegis, yeah please
14:16:16 <EmielRegis> uhm
14:16:21 <EmielRegis> ill post a big chunk of code out there :p
14:16:52 <EmielRegis> http://hpaste.org/12012
14:16:57 <Twey> EmielRegis: reduce (True :&: a) = a; reduce (True :|: a) = True; reduce (False :&: a) = False; reduce (False :|: a) = a
14:17:03 <Twey> Holy crap
14:17:05 <EmielRegis> ZOMG
14:17:11 <EmielRegis> i forgot about this fucntion
14:17:12 <EmielRegis> OMG OMG :(
14:17:30 <EmielRegis> FYI - the code from prop_CNFL was written by philip wadler :)
14:17:48 <vixey> you are being taught by wadler?
14:18:25 <Twey> EmielRegis: We don't usually use nested 'where's
14:18:36 <vixey> I use nested wheres..
14:18:47 <Twey> They're a bit pointless, since they're only exposed to the current function anyway
14:19:12 <Twey> EmielRegis: We don't usually do what vixey does... :-P
14:19:22 <EmielRegis> lol
14:19:25 <EmielRegis> well they are useful
14:19:31 <EmielRegis> vixey, yes hes my lecturer
14:19:35 <EmielRegis> he's a bit crazy but very cool
14:19:44 <vixey> EmielRegis, so you are at Edinburgh?
14:19:44 <EmielRegis> reminds me that i should be going to lectures more often
14:19:49 <EmielRegis> indeed
14:19:57 <vixey> that's pretty cool
14:20:21 <EmielRegis> yea i like it too
14:20:25 <EmielRegis> just the weather..
14:20:27 <EmielRegis> and the girls...
14:20:30 <vixey> EmielRegis, *nosey* what coures are you doing ? maths or computing or what
14:20:31 <EmielRegis> <Twey> Holy crap
14:20:42 <EmielRegis> thats for obvious stuff removal
14:20:46 <yitz> nested wheres are sometimes useful, but here each of those fucntions could (and should) stand on its own IMO.
14:20:48 <EmielRegis> i dont know  away of doing it both ways
14:20:51 <Twey> My cousin went there a while back
14:20:52 <EmielRegis> so i had to put every case
14:20:56 <EmielRegis> vixey, Informatics
14:21:17 <vixey> EmielRegis, if you want to see my way I can show you but you have to hpaste the definition of Prop
14:21:34 * Twey agrees with yitz.
14:21:39 <EmielRegis> its basically computer science where I can choose which way i wanna pursue on my own (like AI, or hardware) plus I got 5th year on masters
14:21:40 <EmielRegis> automatically
14:21:46 <Twey> Remember that they don't escape from the module anyway.
14:21:54 <Twey> But they could be useful, in this case.
14:22:10 <vixey> EmielRegis, you are prety lucky I think it sounds like a decent thing to study. )
14:22:42 <EmielRegis> vixey, I would appreciate seeing some real functional code yea :p http://hpaste.org/12013 heres prop efintion
14:22:53 <roconnor> bind (f . return) === f ?
14:23:26 <roconnor> (=<<) (f . return) === f ?
14:23:38 <noteventime> Is there a way to force something to evaluate?
14:23:47 <sw17ch> $! ?
14:23:55 <EmielRegis> vixey, yea I like it, Ive been into computers since I was 4 or so :P However, I find it way too easy on 1st year...
14:23:58 <roconnor> @type evaluate
14:23:59 <lambdabot> Not in scope: `evaluate'
14:24:01 <EmielRegis> I basically dont go to any lectures
14:24:09 <Twey> noteventime: seq
14:24:11 <roconnor> @hoogle evaluate
14:24:12 <lambdabot> Control.Exception evaluate :: a -> IO a
14:24:12 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
14:24:12 <EmielRegis> and I can do all tutorials without studying...
14:24:16 <sw17ch> > (+) $! 1 2
14:24:17 <lambdabot>       Overlapping instances for Show (a -> a)
14:24:17 <lambdabot>        arising from a use of `s...
14:24:17 <Twey> :t seq
14:24:18 <EmielRegis> but that should change in year or two ;)
14:24:18 <lambdabot> forall a t. a -> t -> t
14:24:19 <sw17ch> hehe
14:24:24 <Twey> seq a b evaluates a then returns b
14:24:31 <noteventime> Twey: The thing is, I need it to evaluate the elements as well, if it's a list
14:24:34 <vixey> EmielRegis, but did you read any of his papers online? He wrote a lot of great tsuff
14:24:36 <roconnor> Control.Exception.evaluate
14:24:53 <noteventime> roconnor: Ahh, thanks
14:24:58 <noteventime> I'll try that :)
14:25:04 <roconnor> mapM Control.Exception.evaluate
14:25:27 <Twey> noteventime: Then you want to map (\a -> seq a a) list
14:25:36 <Twey> @pl \a -> b a a
14:25:36 <lambdabot> join b
14:25:42 <mauke> what
14:25:49 <mauke> seq a a is a
14:25:51 <Twey> Oh, join.
14:25:57 <roconnor> Twey: didn't we learn that (seq a a) = id?
14:25:58 <Twey> noteventime: Then you want to map (join seq) list
14:26:02 <roconnor> er a
14:26:05 <roconnor> what mauke said
14:26:19 <Twey> Really?  Huh.
14:26:30 <roconnor> there is a nice blog post on the topic of seq x x
14:26:35 <Twey> But doesn't it force evaluation of a?
14:26:46 <mauke> seq a b means "attach a to b so that evaluating b also evaluates a"
14:26:54 <roconnor> it forces the evaulation of a when a is forced
14:27:24 <Twey> Ah.  Hmn.
14:27:46 * lilac considers the possibilities of 'map seq'
14:27:49 <roconnor> http://neilmitchell.blogspot.com/2008/05/bad-strictness.html
14:27:50 <lambdabot> Title: Neil Mitchell's Haskell Blog: Bad strictness
14:28:35 <Twey> :t join
14:28:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:28:54 <EmielRegis> vixey, no I didnt
14:29:08 <EmielRegis> but i figured he's quite smart since he invented monads, type classes, etc
14:29:08 <roconnor> if someone writes "join seq", they are doing it wrong ... with style!
14:29:13 <EmielRegis>  :P
14:29:39 <opqdonut> roconnor: :D
14:29:49 <opqdonut> ?remember roconnor if someone writes "join seq", they are doing it wrong ... with style!
14:29:49 <lambdabot> Nice!
14:30:06 <roconnor> :D
14:31:03 * roconnor wonders if Dr. Haskell warns about seq x x
14:31:32 <Twey> Hahaha, roconnor
14:31:59 <yitz> do x <- get; x `seq` put x
14:32:16 <vixey> EmielRegis, http://hpaste.org/12013/1/plain
14:32:30 <vixey> EmielRegis, since hpaste was written in the 80s it broke the unicode
14:32:33 <roconnor> yitz: is that equivalent to seq x x?
14:32:40 <yitz> i think so
14:33:04 * glguy doesn't think so
14:33:10 <glguy> since it has to evaluate the put
14:33:11 * roconnor thinks so
14:33:11 <yitz> oh yeah?
14:33:18 <glguy> to proceed through the monad
14:33:21 <glguy> no?
14:33:30 <roconnor> hmm
14:33:32 <lilac> roulette :: a -> IO a; roulette = (randomChoice <$> (map seq [id, id, id, id, id, error "bang"]) <*>)
14:33:43 <yitz> glguy: yes but doesn't it then have to evaluate x anyway?
14:33:49 <glguy> no
14:33:57 <glguy> it can get and put a thunk
14:34:08 <glguy> but it needs the value of put in bind
14:34:26 <yitz> so it's only id in C.M.State.Strict ?
14:34:53 <roconnor> @src put
14:34:53 <lambdabot> Source not found. Take a stress pill and think things over.
14:35:21 <roconnor> okay maybe glguy is right
14:35:26 <EmielRegis> vixey, nice thankj you
14:35:46 <lilac> @src MonadState
14:35:47 <lambdabot> Source not found.
14:35:49 <roconnor> because the put is demaned whenever the (state,result) pair is demanded
14:36:01 <roconnor> where as x is demanned only when the state is demanded
14:36:12 <yitz> > evalState (return 42) undefined
14:36:14 <lambdabot>   42
14:36:36 <yitz> > evalState (do x <- get; x `seq` put x; return 42) undefined
14:36:37 <lambdabot>   42
14:36:43 <glguy> so that's a lazy monad
14:36:55 <glguy> and you'd need to use "strict" in mtl
14:37:02 <vixey> wha's the zipper for data N = Z | S N ?
14:37:06 <glguy> or Lift in monadLib
14:37:09 <roconnor> yitz: I don't think that is the right discrimination
14:37:18 <Philippa> glguy: heh, I'm suddenly remembering the arguments I've been in about whether there's any actual definition of "strict monad"
14:37:36 <Philippa> (I think I eventually pinned one down via discussing the monad as a sublanguage)
14:37:40 <roconnor> yitz: oh
14:37:40 <yitz> > Control.Monad.State.Strict.evalState (do x <- get; x `seq` put x; return 42) undefined
14:37:41 <lambdabot>   /tmp/4936035201651568868:70:40:
14:37:41 <lambdabot>      Not in scope: `Control.Monad.State.Str...
14:37:44 <roconnor> yitz: maybe you are right
14:37:48 <yav> by stric monad people usually mean that the bins is strict
14:37:57 <glguy> bind*
14:38:00 <yav> *bind
14:38:03 <glguy> *bind*
14:38:04 <vixey> Twey any thoughts on this method now there is some code?
14:38:12 <Philippa> yav: actually, the meaning's slightly more subtle than that
14:38:20 <yav> oh my
14:38:21 <roconnor> > Control.Monad.State.Strict.evalState (return 42) undefined
14:38:22 <lambdabot>   /tmp/3835032951210096370:70:40:
14:38:22 <lambdabot>      Not in scope: `Control.Monad.State.Str...
14:38:23 <yav> what is it?
14:38:26 <lilac> can we say that a monad is strict iff (x >>= b) == x `seq` (x >>= b)?
14:38:29 <roconnor> oh right
14:39:07 <Philippa> Approximately: that if you take bind as function composition in a language represented by the monad, those functions are strict
14:39:19 <ddarius> lilac: No.
14:39:36 <ddarius> bind would be (flipped) application.
14:39:54 <yitz> Prelude Control.Monad.State.Strict> evalState (return 42) undefined
14:39:54 <yitz> 42
14:39:54 <yitz> Prelude Control.Monad.State.Strict> evalState (do x <- get; x `seq` put x; return 42) undefined
14:39:56 <Philippa> d'oh, yes
14:39:57 <yitz> *** Exception: Prelude.undefined
14:40:16 <Philippa> ddarius: you can probably fill in the gaps better than I can right now then, if you think you can see the definition I had in mind?
14:40:18 <lilac> ddarius: can you give an example of why that definition is unsatisfactory?
14:40:30 <roconnor> yitz: how abut evalState (do x <- get; put x; return 42) undefined
14:40:38 <Philippa> (I did specifically have in mind that monads might have their own notion of non-termination etc)
14:40:51 <yitz> roconnor: which monad?
14:40:56 <roconnor> strict
14:41:15 <ddarius> lilac: Which strict/lazy monads do you think that definition distinguishes?
14:41:20 <yitz> roconnor: 42
14:41:25 <roconnor> Oh?
14:41:52 * roconnor obviously doesn't understand the strict state monad
14:41:57 <Philippa> yitz: that's funny, put's eating a bottom...
14:42:14 <opqdonut> vixey: "data zipN = S" ?
14:42:18 * roconnor sticks to lazy state monad.  ... easier to understand. :P
14:42:19 <Philippa> (but yes, it's what I'd expect because that bottom's never a /State/ bottom, it's just a (boxed) haskell bottom
14:42:23 <Philippa> )
14:42:26 <ichor> vixey, how can you have a zipper of a data structure without contained type?
14:42:40 <vixey> ichor, I don't know about zippers
14:42:48 <lilac> ddarius: it makes [], IO, and (I think) strict state be strict, and makes lazy state, reader and cont lazy, i think.
14:42:49 <vixey> I am only learning this now , but I really hope you can
14:43:02 <vixey>  I kind of need it for N as well as more com.plex stuff
14:43:10 <andrewsw> wow, I've learned so much from the evalState examples above. Thanks yitz et al!
14:44:45 <ichor> vixey, the way i understand it, you need have elements in the structure that you can "remove".
14:45:50 <ichor> vixey, for instance in a list it makes sense to remove an element, and look at the structure of what is left.
14:45:54 <lilac> ddarius: which lazy/strict monads does it misclassify?
14:47:30 <Philippa> lilac: implementations of monads with an AST, for one
14:47:57 <vixey> why make a monad from a AST? is there reasons other than substitution
14:48:13 <lilac> Philippa: i don't understand what you mean by that.
14:48:19 <vixey> ichor, maybe I can remove a 'S' is S (S (S (S O)))
14:49:25 <Philippa> lilac: data Id a where {Return :: a -> Id a; Bind :: Id b -> (b -> Id a) -> Id a}, say
14:49:56 <ichor> vixey, Well, if you want to, you can look at N as [()], take the zipper of lists and insert ().
14:49:58 <Philippa> there's a variant of that, data Strict a where...
14:50:05 <Philippa> with exactly the same types and a seq in the run function
14:50:48 <lilac> Philippa: i would say they are both lazy
14:51:07 <lilac> since the result of 'do' is never _|_ unless the last statement of the 'do' is _|_
14:51:57 <lilac> the 'run' function is'nt an integral part of that monad
14:52:45 <Philippa> lilac: it's not an integral form of any monad, but any monad implemented in haskell has one even if it's just id
14:52:46 <lilac> but i guess defining what a 'strict monad' is is useless without some context
14:52:52 <Philippa> *for any monad
14:52:57 <dolio> lilac: I don't think it captures the difference between the lazy and strict state monad.
14:53:04 <ichor> vixey, why do you need a zipper for N?
14:53:31 <Badger> ?remember Twey меин = путСтрЛн "Нет!"
14:53:31 <lambdabot> I will never forget.
14:53:33 <vixey> ichor, curious if you can put proofs in a zipper
14:53:38 <dolio> lilac: The difference is with 'evil :: State s a ; evil = State (\s -> undefined)'.
14:54:01 <dolio> evalState (evil >> return ()) () = bottom for strict, () for lazy.
14:54:09 <dolio> But evil is non-bottom for both.
14:54:32 <vixey> Twey, hi,, any thoughts on this method now there is some code on the hpaste?
14:54:37 <dolio> evil `seq` (evil >>= b) = evil >>= b for both.
14:54:43 <Philippa> dolio: exactly. You're looking at strictness in the language defined by the monad, in effect
14:55:15 <ddarius> lilac: For what is called the strict State monad, a value of it is still (essentially) just a function, so except for some not terribly important cases, x `seq` (x >>= f) is x >>= f
14:55:43 <ddarius> Similarly for IO
14:55:54 <ddarius> and probably Cont
14:55:57 <Philippa> ddarius: that, and apparently implementing monads via ASTs would suddenly make them non-strict
14:56:04 <Philippa> which is... well, broken
14:56:29 <jsn> Philippa: implementing monads by ASTs?
14:56:42 <Philippa> <Philippa> lilac: data Id a where {Return :: a -> Id a; Bind :: Id b -> (b -> Id a) -> Id a}, say
14:56:48 <Philippa> (runId left as an exercise for the reader)
14:56:49 <lilac> it sounds like you're not looking for a definition of strict monad then. you already have a definition, but it's just hard to phrase
14:57:00 <lilac> Philippa: actually
14:57:01 <Philippa> lilac: *I'm* not looking for a definition...
14:57:13 <ichor> vixey, I cant really picture how that would go about, but would you care to clarify what your idea is?
14:57:16 <Philippa> ...because I have one I'm satisfied with, albeit that I'm too tired to phrase politely tonight
14:57:27 <lilac> Philippa: take your 'Id a', and write a runId and a runStrictId. that should make it clear that it's not a property of the monad...
14:57:58 <Philippa> lilac: or that the monad's polymorphic
14:58:15 <Philippa> to put it another way: say hello to the free monad
14:58:54 <lilac> this 'monad strictness' definition you want is a property of your run function, not of the monad itself. consequently, i don't like it.
14:59:12 <Philippa> yeah. OTOH, yours is just as bad: it exposes implementation artefacts
14:59:47 <Twey> vixey: Looks good to me
15:00:01 <Philippa> and yours doesn't take into account the way we actually use monads in haskell
15:00:02 <vixey> ty
15:00:05 <lilac> *shrug* i'd be happy with your definition but with a name which didn't suggest it was inherent to the monad
15:00:15 <Philippa> in practice, we care about the run function - it just happens to be id sometimes
15:00:30 <ddarius> Personally, I think trying to call a monad strict is silly.
15:00:43 <Philippa> ddarius: yeah, fair enough. Save the label for a 'notion of computation'?
15:00:48 <ddarius> Or trying to formulate some general notion of a "strict monad"
15:00:55 <dolio> The difference between State.Strict and State.Lazy isn't the run function, though.
15:01:07 <dolio> Because it's not a term algebra.
15:01:14 <lilac> dolio: it is if you use a run function of "const 42" for both...
15:01:48 <dolio> No, the difference between the two is the definition of (>>=) for them.
15:02:07 <Philippa> dolio: hrmm, isn't it possible to still do an implementation in that style though? IIRC they hide their internal implementation
15:02:11 <Saizan> lilac: you can see the run function as the denotational semantic for your monad, where the semantic domain are haskell values
15:02:12 <lilac> dort: you miss my point. if the run function ignores the value of the monad, (>>=) is irrelevant
15:02:23 <lilac> s/dort/dolio/
15:02:42 <tote> how do i convert an int to string?
15:02:44 <Saizan> lilac: so it's not surprising that whatever properties a monad have depend on it
15:02:44 <mm_freak> how can i influence what IO considers a line break?  for example, i'd like to use functions like hPutStrLn in network code, but it should use "\r\n" regardless of the platform
15:02:53 <lilac> strictness seems to be a function of the embedding of the monad into haskell, rather than inherent to the monad itself.
15:02:56 <yav> tote: show
15:02:57 <Philippa> ddarius: I think working out what we as a community mean when we (informally) say "strict monad" is valuable, and I think there's a sensible notion for it
15:03:11 <Philippa> lilac: in how you define it, yes
15:03:56 <Philippa> "monad" probably isn't quite the right term for what I'm really defining strictness for, they're a necessary component...
15:03:59 <ddarius> Philippa: I think there are multiple sensible notions for it for different monads.  I don't think there is a particularly useful, sensible notion for monads (in Haskell) in general
15:04:29 <eu-prleu-peupeu> hello
15:04:33 <eu-prleu-peupeu> anyone here uses vvvv ?
15:04:37 <tote> yav: thanks
15:05:18 <ddarius> For example, the difference between the strict and lazy State monads aren't meaningful for most other monads.
15:05:25 <Philippa> ddarius: I'd be interested in a counterexample for the one I'm pushing that can't be fixed by supplying a run function
15:06:32 <dolio> The only other one we have is Writer, no?
15:06:52 <dolio> I guess there are strict combinators for STM, as well...
15:07:20 <Philippa> dolio: Parsec?
15:07:47 <dolio> Oh, ST and RWS too, it seems.
15:08:36 <dolio> But those aren't surprising.
15:08:53 <yav> while you guys are discussing strict vs lazy monads, it may be interesting to note that while some (like ExceptionT) are inherently strict, others (like State) inherit the behavior of the underlying monad.  This is used in MonadLib to avoid the duplication of monads that is present in mtl.
15:09:45 <yav> (i mean some "transformers")
15:10:40 <dolio> You're saying that, for instance, StateT s LazyId is lazy?
15:10:53 <dolio> Or something else?
15:11:32 <yav> dolio: yeah.  using monadLib terminlogy: StateT
15:11:35 <yav> oops
15:11:46 <mcoram> Hi Haskellers. I have installed a ArchLinux VMWare specifically to try out "batteries included" Haskell. Can someone (dons?) point me to the steps needed to add the right source and packages to have a "complete" system?
15:11:52 <yav> StateT Id is lazy while StateT Lift is strict
15:12:23 <dolio> yav: I guess that makes sense. Since the strict Id would seq the tuple at each go.
15:12:44 * roconnor <3 MonadLib
15:12:53 <Philippa> mcoram: good question, I'm not quite sure what's considered the usual battery list - as a community it's kinda being put together. Dons is probably the one to ask for a recommendation and names on Arch for now
15:12:54 <ddarius> There are different elaborations of languages into Moggi's monadic metalanguage corresponding to different evaluation orders of the elaborated language.
15:13:24 <glguy> Is the moral that Monad Transformers are not Monads?
15:13:32 <mcoram> Thanks Philippa.
15:13:57 <Philippa> np, sorry I can't just hand you a package list. Do you know what kinds of things you're looking to try doing?
15:14:43 <mcoram> For starters to have cabal-install and haskell working well together (but numerics and graphics generally)
15:16:17 <dmwit> What's going wrong with cabal-install?
15:16:56 <mcoram> Probably nothing, I'm just an Arch newbie. I was having trouble installing it right under my Ubuntu box, so I thought I'd try under Arch.
15:17:19 <jsn> mcoram: maybe cabal-install is packaged up already, under Arch?
15:17:34 <jsn> mcoram: there is always the bootstrap script
15:18:17 <Saizan> mcoram: you need to use abs or yaourt to get build scripts (PKGBUILD) from the AUR
15:18:23 <mcoram> right, but I thnk there's a package source I need first. (I tried the bootstrap script under Ubuntu but hit a few snags that I haven't had time to iron out with the bootstrap's own dependencies, so I was trying an alternative approach)
15:18:52 <mcoram> oh. Saizan, I'll look into that. thanks.
15:18:54 <Saizan> mcoram: for ghc there's a binary of 6.10.1 in the testing repository
15:19:31 <jsn> i have some code that uses a function that was recently removed from template haskell
15:20:01 <jsn> is there a way to use CPP to conditionally call the new version if it is available, and the old if it is not?
15:21:32 <lilac> jsn: you can probably detect whether the function exists using TH :)
15:21:50 <Saizan> jsn: cabal defines some CPP macros to check the version of packages when building
15:22:12 <jsn> both good options
15:22:14 <jsn> gmm
15:22:19 <jsn> s/gmm/hmm/
15:22:56 <mcoram> Saizan: so for Ubuntu, you'd recommend using the testing GHC and using cabal-install's bootstrap.sh (after adding zlib-dev and whatever other silent dependencies there might be)?
15:23:07 <Twey> Gah
15:23:15 <Twey> What is it with hApps?
15:23:15 <MarcWeber> @seen int-e
15:23:16 <lambdabot> int-e is in #ghc, #haskell-overflow and #haskell. I last heard int-e speak 2h 40m 43s ago.
15:23:25 <jsn> mcoram: personally, i think you should just get the GHC binary
15:23:33 <Twey> 'We have not included a templating engine because we think you should do everything with AJAX'
15:23:43 <jsn> Twey: hehe
15:23:54 <mcoram> jsn: do you mean the 6.8.2 one?
15:23:57 <jsn> HAML looks really good
15:24:01 <jsn> mcoram: no, 6.8.3
15:24:08 <jsn> mcoram: don't use 6.8.2
15:24:12 <int-e> MarcWeber: pong
15:24:13 <Saizan> mcoram: i referred to arch's testing repository earlier, however on ubuntu i'd just grab the generic binary from www.haskell.org/ghc , install zlib-dev and use the bootstrap.sh script
15:24:36 <mcoram> Thanks all. I'll see what I can get.
15:24:46 * roconnor decides to screw all convention and use <-> to mean isomorphic.
15:24:59 <jsn> @message Axman6 my 6.10 install has editline all screwed up
15:24:59 <lambdabot> Maybe you meant: messages messages?
15:25:01 <geezusfreeek> one thing i think i have figured out with happs is that it's not really designed for web applications. it's more for web services. web applications appears to be secondary
15:25:12 <Saizan> which are the conventions?
15:25:20 <MarcWeber> int-e: :-) He, Currently reading your source again. Do you think it would be a good idea to make the git fast import part of the git-darcs-import extension an extra library?
15:25:27 <jsn> Twey: HAML looks really nice and could be ported
15:25:48 <mm_freak> ok, up to now i always preferred StateT over IORef, because it appears more functional and just much nicer to me…  is there any reason to prefer to use untransformed IO together with an IORef instead of StateT over IO?
15:26:13 <jsn> mm_freak: module global variables?
15:26:26 <dmwit> For some things, mutation can be faster.
15:26:27 <jsn> mm_freak: or can StateT handle that case?
15:26:52 <Peaker> dmwit: by a factor of logN?
15:26:53 <Saizan> geezusfreeek: i think it's more that most of the developement effort is on the backend rather than the API, which mostly gives you the freedom to exploit whatever libraries you like
15:27:07 <Philippa> mm_freak: when you've got more than one such thing lying around and you want to be able to control access carefully
15:27:14 <geezusfreeek> i'd say that is almost the same thing ;)
15:27:38 <mm_freak> jsn: both handle the case…  like the database example above…  i'm writing an internal user database for a server program, which is controlled through a Chan
15:27:39 <dmwit> Peaker: If you're asking whether things can be asymptotically faster, then I believe that is an open question in the presence of laziness.
15:28:07 <mm_freak> currently it has the type:  userManager :: Chan UMCommand -> StateT (Map Unique UserInfo) IO ()
15:28:16 <dmwit> Peaker: For strict languages, however, yes, there are some problems which can be solved asymptotically faster using mutation than without.
15:28:17 <mm_freak> theoretically i could just as well use an IORef
15:28:39 <mm_freak> but i preferred the StateT variant, because it appeared more functional and more haskell-ish to me
15:29:03 <mm_freak> any reason to prefer the IORef variant?  (i.e. userManager :: Chan UMCommand -> IO ())
15:29:06 <Saizan> mm_freak: the IORef or MVar is needed in the case of concurrent access to the value, for the rest i'd stick to transformes too
15:29:21 <inimino> anybody know who is getting GHC 6.10 into debian or when it might happen?
15:29:33 <Peaker> dmwit: basically I can "emulate" a big random-access "mutatable memory" via a logN tree, where N is the size of the total memory, so instead of O(1) mutations cost me O(logN), in a lazy or strict language alike, no?
15:29:34 <MarcWeber> int-e: Probably its not worth it. it's not that much code. I've had a wrong impression
15:29:48 <mm_freak> Saizan: no concurrent access, the 'userManager' thread is the only one to access the Map, and the access is sequential
15:29:54 <int-e> MarcWeber: My impression is that it's rather specialised for the task at hand - converting darcs repos.
15:30:05 <int-e> MarcWeber: so not generally useful enough to be split out
15:30:36 <dmwit> Peaker: That sounds reasonable.
15:33:05 <inimino> also, is it reasonable to expect to be able to use GHC for cross-compilation?
15:33:28 <Twey> What's the preferred binding to ncurses these days?
15:33:38 <Twey> hscurses hasn't been updated since... 2006, looks like
15:33:48 <roconnor> Saizan: the conventional notation for isomorphic are ≈, ≅, or ≃.
15:34:40 <Saizan> roconnor: which reminds me that i miss some fonts or something since i see only the first two
15:34:51 <yitz> hi Peaker. I thought I was the only nut up this late.
15:35:02 <Philippa> Peaker: AIUI it's an open question whether there's a more smartarsed encoding for laziness
15:35:07 <jsn> ?localtime yitz
15:35:09 <lambdabot> Local time for yitz is Fri Nov 14 01:35:22 2008
15:35:14 <Philippa> (bear in mind that the constant factor can be damn big)
15:35:15 <dmwit> inimino: Basically no.
15:35:29 <jsn> ?localtime jsn
15:35:30 <lambdabot> Local time for jsn is 2008-11-13 15:35:29 -0800
15:35:31 <inimino> dmwit: ok
15:35:35 <Peaker> yitz: efshar lahshov, its just 1:35 am ;)
15:35:45 * yitz yawns
15:36:19 <tredontho> @source foldl'
15:36:19 <lambdabot> foldl' not available
15:36:32 <int-e> @src foldl'
15:36:32 <lambdabot> foldl' f a []     = a
15:36:32 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:36:38 <dolio> Anyone have an example of something that works with State.Strict but fails with State.Lazy? I'm having trouble finding one.
15:36:41 <tredontho> thanks
15:37:19 <ddarius> dolio: Semantically, there isn't an example.  However, the lazy version can lead to stack overflows.
15:37:32 <dolio> Yeah, that's what I'm asking for.
15:37:42 <int-e> > evalState (undefined >> return 1)
15:37:43 <lambdabot>       Overlapping instances for Show (s -> t)
15:37:43 <lambdabot>        arising from a use of `s...
15:37:48 <int-e> > evalState (undefined >> return 1) ()
15:37:49 <lambdabot>   1
15:38:00 <ddarius> replicateM (modify (1+)) should do it.
15:38:14 <ddarius> uh, plus a number
15:38:15 <int-e> dolio: that's an example for you
15:38:40 <mm_freak> Twey: does it have to be an ncurses binding?  if no, you can use the vty library
15:38:54 <mm_freak> likely it is an ncurses binding, but it's more abstract
15:39:09 <Saizan> ddarius: they both create the huge thunk in the state, no? or are you trying to trigger something else?
15:39:24 <yitz> > execState (sequence [modify (+ n) | n <- [1..1000000]) 0
15:39:25 <lambdabot>   <no location info>: parse error on input `)'
15:39:35 <yitz> > execState (sequence [modify (+ n) | n <- [1..1000000]]) 0
15:39:35 <int-e> Control.Monad.Strict is just strict enough to make  evaluateState = (return $!)  work.
15:39:39 <dolio> int-e: Yeah, I was actually thinking more along the lines of something that stack overflows, so I could fool around with such an example in monadLIb.
15:39:39 <lambdabot>   * Exception: stack overflow
15:40:13 <Peaker> yitz: were there any more Haskell meetings in Jerusalem since then?
15:40:35 <yitz> Prelude Control.Monad.State.Lazy> execState (sequence [modify (+ n) | n <- [1..1000000]]) 0
15:40:38 <yitz> *** Exception: stack overflow
15:40:39 <yitz> oh well
15:40:42 <int-e> yitz: that will overflow the stack in Control.Monad.State.Strict as well.
15:40:46 <dolio> ddarius: I tried that, but it overflows in both, because of all the (+1) thunks...
15:40:54 <yitz> Peaker: haven't heard of any, no. We should get that going.
15:41:32 <Peaker> yitz: such things should be in Tel Aviv :P
15:41:54 <int-e> dolio: the difference, as far as I understand, is really that in State.Strict, >>= is strict in its first argument while in .Lazy it's not.
15:41:57 <yitz> Peaker: I'm biases, of course, but that's also fine.
15:42:25 <dolio> int-e: Well, it's strict in the tuple it produces, yes.
15:42:27 <yitz> Peaker: in fact, we ought to be able attract enough people to make it worthwhile to meet in Haifa sometimes too
15:42:30 <Twey> mm_freak: No, not particularly, I'm just looking for a nice console-GUI toolkit
15:42:37 <dolio> Uses case to destruct instead of let.
15:42:41 <Twey> The higher the better :)
15:43:02 <yitz> Peaker: you'd think that Technion would be ripe for this.
15:43:08 <mm_freak> Twey: then vty is for you, although it's just a console driver, not a real TUI toolkit
15:43:16 <int-e> > execState (sequence [get >>= (put $!) . (+ n) | n <- [1..1000000]]) 0
15:43:20 <lambdabot>   * Exception: stack overflow
15:43:41 <int-e> mmm. still overflows in .Strict.
15:44:14 <int-e> but that's the fault of 'sequence'
15:44:19 <int-e> > execState (sequence_ [get >>= (put $!) . (+ n) | n <- [1..1000000]]) 0
15:44:22 <jsn> it amuses me that SF has no real Haskell group
15:44:22 <lambdabot>   * Exception: stack overflow
15:44:31 <int-e> (works in .Strict)
15:44:35 <Peaker> yitz: I don't know, are there PL gurus in the technion?  TAU doesn't have anyone who seems to know any Haskell
15:44:44 <Peaker> yitz: of the staff, anyhow
15:45:04 <yitz> Peaker: exactly. eventually, someone will figure out that it's time.
15:45:36 <Peaker> yitz: When I just started learning Haskell, my friend told his professor about it, and he wanted us to lecture about Haskell there. I said we couldn't (we were total newbies at the time)
15:45:39 <dolio> All right.
15:45:48 <Peaker> yitz: that could be interesting to do though
15:45:53 <yitz> Peaker: know who?
15:46:05 <Peaker> yitz: Nope, I can ask him (TAU professor)
15:46:38 <Peaker> my friend is a graduate Masters student from TAU
15:46:51 <yitz> Peaker: I've been planning to ask around some HU people. or maybe JCT or BIU.
15:47:00 <Peaker> yitz: is HU any good?
15:47:21 <yitz> Peaker: yes, in math-ish ways, which is a fit here.
15:47:24 <Peaker> JCT/BIU? you mean Ivrit and BGU?
15:47:46 <yitz> Machon Lev, Bar Ilan. BGU is a bit far for me :)
15:47:51 <Peaker> ah, heh
15:48:26 <yitz> I actually have a relative (of my wife) who teaches at BGU. Humanities though. :)
15:48:28 <Peaker> I don't like Bar Ilan. Forcing Judaism classes on all students. Bah
15:48:31 <int-e> > take 10 $ evalState (sequence (map return [1..])) 0
15:48:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:48:43 <int-e> and this doesn't work in .Strict
15:49:09 <Peaker> int-e: how come?
15:49:19 <yitz> Peaker: well, I know some math people there. and my brother-in-law is chairman of eco. some kitve chut.
15:49:23 <yitz> *kitzve
15:49:52 <int-e> Peaker: because State.Strict will have to evaluate all the infinitely many actions (return 1, return 2, etc.) before it can return a value.
15:50:14 <yitz> int-e: right, that's why I always use lazy. But there must be a fairly simple example of where you need the strict one in real life.
15:50:37 <int-e> Peaker: State.Lazy on the other hand is so lazy that it can execute the first action, and the last action of sequence without evaluating everything in the middle.
15:50:51 <Peaker> int-e: ah..
15:51:15 <Peaker> yitz: I think the strict state monad is more useful than the lazy one. The lazy one is virtually always a leak source
15:51:27 <int-e> yitz: well, State.Lazy is so lazy that you can not recover any strictness from it at all - see the get >>= (put $!) . (+ n) above.
15:51:37 <yitz> Peaker: never had a problem with it.
15:52:33 <int-e> yitz: (there should really be a  modify' f = get >>= (put $!) . f  somewhere.)
15:53:10 <mikv> HI!
15:53:20 <mikv> Can you help me?
15:53:21 <yitz> Prelude Control.Monad.State.Lazy> execState (sequence [modify ($! (+ n)) | n <- [1..1000000]]) 0
15:53:29 <mikv> I am trying to understand one haskell program
15:53:37 <mikv> I found $ in this program
15:53:39 <yitz> > execState (sequence [modify ($! (+ n)) | n <- [1..1000000]]) 0
15:53:40 <lambdabot>       Occurs check: cannot construct the infinite type: b = (a -> a) -> b
15:53:40 <lambdabot>    ...
15:53:46 <Zao> @src $
15:53:47 <lambdabot> f $ x = f x
15:53:57 <mikv> :t ($) shows ($) :: (a -> b) -> a -> b
15:53:58 <lambdabot>     Couldn't match expected type `a -> b'
15:53:58 <lambdabot>            against inferred type `String'
15:53:58 <lambdabot>     Probable cause: `$' is applied to too many arguments
15:54:07 <Botje> mikv: f $ x = f x
15:54:13 <Zao> mikv: f $ x y  is the same as   f (x y)
15:54:14 <Botje> it's just a way of avoiding parens
15:54:14 <yitz> > execState (sequence [modify ((+ n) $!) | n <- [1..1000000]]) 0
15:54:19 <lambdabot>   * Exception: stack overflow
15:54:20 <int-e> yitz: no, you can't use modify to implement modify'
15:54:35 <mikv> hm... i don't understand why do we need it?
15:54:51 <Botje> we don't. it simply avoids parens
15:54:53 <mikv> why should we write f $ x y instead of plain f x y
15:54:56 <mikv> ?
15:55:02 <Botje> you shouldn't.
15:55:12 <Peaker> mikv: a $ b $ c $ d $ e $ f   or a . b . c . d . e $ f   are nicer than: a (b (c (d (e f))))
15:55:15 <Saizan> mikv: they are different things in that case
15:55:25 <Botje> but you should write f $ g $ h $ i $ j x instead of f (g (h (i (j x ))))
15:55:27 <yitz> int-e: ok then
15:55:35 <Zao> mikv: f x y parenthesises to ((f x) y)
15:55:38 <Peaker> mikv: $ is lower precedence than normal function application so: a b c is different from a $ b c
15:55:46 <mikv> oh :-) Thanks a lot :-)
15:55:46 <Twey> mikv: `f $ x y` is `f (x y)`, and `f x y` is `(f x) y`
15:56:02 <int-e> yitz: but my point is that modify' doesn't work in State.Lazy - and I believe it cannot be implemented at all for that monad.
15:56:03 <Twey> Peaker: Stringing together sequences of $ is frowned upon
15:56:16 <Twey> They're thinking of changing the associativity of it, as I understand it
15:56:24 <Peaker> Twey: you mean a $ b $ c  VS a . b $ c?
15:56:29 <Twey> Use . instead, except for the last one
15:56:40 <Peaker> Twey: Yeah I mentioned both
15:56:41 <yitz> > execState (sequence [do x <- gets (+ n); put $! x | n <- [1..1000000]]) 0
15:56:44 <lambdabot>   * Exception: stack overflow
15:56:57 <int-e> yitz: "doesn't work" meaning that it doesn't prevent a huge thunk from being built up by consecutive  modify  calls, which will cause a stack overflow later. You can just shift the point of the stack overflow.
15:57:17 <Twey> Peaker: Aye.  The former is discouraged.  :)
15:57:27 <Peaker> Twey: why does it both anyone? :-)
15:57:46 <Twey> 235611 < Twey> They're thinking of changing the associativity of it, as I understand it
15:57:55 <Twey> Which will break that
15:57:58 <Peaker> Twey: I agree $ should be left-associative, since we already have . which lets us do the right-associative thing
15:58:07 <Peaker> s/both/bother of course
15:58:24 * Twey nods.
15:58:31 <yitz> Twey: I can't believe that will ever happen, repeated $ is just too ingrained by now.
15:59:20 <Peaker> using a . b . c $ d  also has the advantage of being easy to re-factor into PL style
15:59:21 <int-e> yitz: if you replace  sequence  by  sequence_  that will work in State.Strict.
15:59:45 <yitz> maybe there'll be a left-assoc. alternative in a library.
15:59:46 <Twey> Peaker: Or a . b $ c d
15:59:54 <Twey> :)
16:00:22 <yitz> int-e: nope, sequence_ didn't help.
16:01:03 <zeta-> just installed ghc 6.10.1 from source -- but there's no cairo or gtk. Have I built it incorrectly, or do I need another package (can't find them in hackage)
16:01:25 <Philonous> haskell.org/gtk2hs
16:01:35 <int-e> yitz: it doesn't work in State.Lazy
16:01:45 <Philonous> zeta-:
16:02:26 <zeta-> Philonous: thanks I'll look that up.
16:02:29 <yitz> Twey: I'm using . a lot more now. But sometimes the single $ lands in a weird place that confuses the meaning of my code, so I go back to all $.
16:02:45 <Philonous> yw
16:02:53 <yitz> int-e: or Strict either
16:03:33 <int-e> yitz: that's strange. I get the behaviour I describe in ghci 6.6.1 and 6.10.1 ... and I'd expect to get the same behaviour in 6.8.3
16:03:55 <xxgodsmackxx321> http://www.prizerebel.com/index.php?r=631161
16:03:56 <lambdabot> Title: PrizeRebel.com | Free Xbox 360 Live Points, Free Wii Points, Free Xbox 360 Games ...
16:04:04 <yitz> int-e: The Glorious Glasgow Haskell Compilation System, version 6.8.2
16:04:54 <yitz> hey, that's a new one. lambdaspam.
16:05:10 * roconnor review tensorial and functorial strengths
16:05:15 <int-e> yitz: hmm, confirmed for 6.8.3, too. (I don't have 6.8.2)
16:05:32 * juhp wonders if it is really necessary to include 3d sound and graphics in batteries included
16:06:02 <BMeph> roconnor: SMTL! :)
16:06:41 <yitz> juhp: I think we should compare with other batteries-included languages.
16:07:03 <roconnor> SMTL?
16:07:31 <int-e> yitz: here's what I did, http://hpaste.org/12016
16:07:36 <juhp> I think we should drop them ;)
16:08:03 <juhp> and maybe replace them with codecs or something more basic
16:08:44 <juhp> I guess it is just providing backwards compatibility with ghc extra libs
16:09:03 <roconnor> BMeph: SFMM!
16:10:11 <yitz> int-e: oops, you're right. I forgot that I switched back to Lazy at some point. Sorry. :)
16:10:48 <yitz> juhp: codecs is critical. must have.
16:11:05 <juhp> yitz: http://www.haskell.org/haskellwiki/Haskell_Platform/Batteries_Included
16:11:07 <lambdabot> Title: Haskell Platform/Batteries Included - HaskellWiki, http://tinyurl.com/69g5vg
16:12:01 <int-e> yitz: ok, that'll let me rest more peacefully tonight *g*
16:14:46 <yitz> juhp: hmm. no editing instructions there. dons?
16:16:03 <yitz> how could containers not be in there?
16:16:36 <p_l> an ability to use MS SDK for compilation of C/C++ deps would be a nice thing to have in Haskell Platform
16:17:02 <juhp> yitz: guess there needs to be discussion... like I say it looks like it is starting the current ghc libraries
16:17:11 <juhp> starting from *
16:17:52 <juhp> p_l: it should be cross-platform IMHO
16:18:38 <p_l> juhp: That's why it shouldn't require me to port half of unix just to compile one C file
16:18:40 <roconnor> Cale: whats the relationship between CCC and symetric monoidal closed?
16:18:52 <roconnor> Cale: does CCC imply cymetric monoidal closed?
16:18:56 <roconnor> symetric
16:19:23 <juhp> p_l: hmm true
16:19:31 <jeffz> p_l: the only real dependency seems to be a shell to run configure scripts, it's a little annoying to have to install msys, but it's not difficult
16:19:36 <yitz> juhp, p_l: it already includes platform-specific pieces that make the whole fully functional (pun) on all platforms.
16:20:02 <juhp> ok
16:20:03 <p_l> jeffz: It's annoying as hell since MSYS is not really up-to-date anymore, also, some of the configure scripts shouldn't really exist
16:21:08 <p_l> In the end I basically scrapped doing some of the desktop-side developments in Haskell because of that
16:21:37 <yitz> p_l: oh no. msys not fully maintained? are we regressing back to cygwin?
16:21:57 <Saizan> i guess for windows we need more bindists
16:21:59 <jeffz> p_l: not sure what it needs to be up to date with, it only needs to run configure
16:22:09 * juhp is interested in using cmake to replace autotools
16:22:29 <jeffz> Saizan: bindists aren't really desirable, since often you might want to toy with part of a library and quickly rebuild and reinstall it with cabal
16:22:30 <p_l> yitz: If shell was all that mattered, you can get a set of binaries (sed/awk/shell etc.) which all together probably take less space than bash from MSYS
16:23:20 <p_l> unfortunately, since autotools are not really portable outside bash, it doesn't work
16:23:35 <yitz> there's are several stand-alone native bash. but they all also look a little bit-rotted.
16:24:08 <p_l> the real problem is that there are several things that shouldn't really use a configure script anyway
16:24:17 <Saizan> p_l: such as?
16:24:27 <p_l> Saizan: HOpenGL
16:24:54 <yitz> new approach - port autotools to PowerShell (just joking)
16:25:07 <p_l> yitz: .....
16:26:08 <Saizan> p_l: if you know how to do without the configure scripts i think most maintainers would appreciate patches
16:27:22 <p_l> IMHO autotools lost their own point
16:27:58 <adityam> @pl f x y= fst (h x y)
16:27:58 <lambdabot> f = (fst .) . h
16:28:59 <juhp> cmake is pretty portable and fast
16:29:37 <p_l> most of the time all that's needed is a simple make
16:29:58 <juhp> though I haven't played with it yet - actually thinking it would be nice to port ghc to cmake...
16:31:08 <p_l> For many people who would like to start with Haskell but don't want to switch to Unix, it would be nice if GHC distribution would simply contain make.exe as well as reported the platform
16:31:36 <Saizan> i like Cabal's philosophy of specifying dependencies explicitly rather than shipping a script that tries to figure out where to find them
16:31:45 <Saizan> the problem remains in interfacing with C
16:31:48 <p_l> Unless your code is pretty specific, you don't really need 99% of what most ./configure scripts do
16:31:52 <juhp> Saizan: right
16:31:59 <juhp> p_l: cmake
16:32:09 <p_l> juhp: Seems like overkill to me
16:32:22 <juhp> p_l: for building C ?
16:33:07 <juhp> p_l: plain makefiles are never going to be portable enough without some infrastructure behind them for C
16:33:09 <p_l> juhp: pkg-config to get paths and a simple flags generator?
16:33:32 <juhp> p_l: right pkg-config helps a lot
16:33:47 <Saizan> p_l: why make? Cabal already supports pkg-config and can build/link C code
16:33:57 <p_l> most of what your typical ./configure does is completely irrevelant
16:34:07 <juhp> p_l: nod
16:34:10 <p_l> Saizan: Cabal is fine too
16:34:13 <adityam> @pl f x = g ((h . i) x) x
16:34:13 <lambdabot> f = g =<< h . i
16:34:40 * p_l could never understand why people use the dreaded "sanity check" in their autoconf scripts
16:35:03 <juhp> autohell is not fun
16:35:23 <ddarius> roconnor: CCC is a special case of SMCC.
16:35:52 <p_l> the only really usable part from autoconf is I think the platform detection script. After you have the platform, 99% percent of times you know what to do
16:36:08 <juhp> p_l: I doubt you can build a compiler though without some kind of build configuration tool
16:37:09 <p_l> juhp: a make system is enough, really
16:37:20 <yitz> ghc tends to do some pretty heavy autoconf hacks
16:37:39 <juhp> p_l: in practice I am not sure
16:37:59 <yitz> even the configure for installing the unix binary seems to do some non-trivial things.
16:38:05 <juhp> specially now that it is moving to shared libs
16:38:19 <juhp> yitz: right
16:38:20 <p_l> juhp: shared libs are not really done by configure
16:38:41 <juhp> p_l: that's right
16:38:51 <p_l> I'm not going to bash libtool, cause it does help
16:39:24 <p_l> what is insane is autoconf. Especially since most projects use it wrong, adding insult to injury
16:39:25 <juhp> cmake can do it all much more cleanly I believe - though it does have a few quirks apparently
16:39:50 <juhp> p_l: to me all of autotools is ugly
16:39:50 <yitz> p_l: "bash libtool": you didn't mean replace libtool by bash, did you?
16:40:05 <juhp> yitz: to bash
16:40:27 <Peaker> can't we drop support of archaic unix systems, and focus on Linux, OSX, Solaris, Windows, etc, and assume we have some decent tools installed rather than /bin/sh from 1977?
16:40:38 <Peaker> (and avoid all the horrible autoconf/automake hacks)
16:40:57 <p_l> Peaker: autoconf assumes recent bash
16:41:12 <p_l> even if it tells you it will run on other stuff :P
16:41:19 <Peaker> why does it need like 5 layers of code generating code generating code ... then?
16:41:44 <p_l> Peaker: because it's FSF fashion
16:41:54 <yitz> Peaker: m4
16:41:59 <p_l> also m4
16:42:01 <BMeph> Saizan: Do you find it ironic that your comment concerning cabal is completely opposite, to how cabal-install works?
16:42:08 <juhp> I say anything but autotools ;-)
16:42:09 <yitz> hey, it's a functional language
16:42:55 <p_l> another problem is that it gives false portability
16:43:38 <p_l> especially when you use some of autoconf helpers
16:43:58 <Peaker> yitz: what is?
16:44:00 <Saizan> BMeph: what?
16:44:08 <Saizan> BMeph: in which way?
16:44:12 <yitz> Peaker: m4
16:44:42 <Peaker> yitz: doesn't it have variable assignment/etc like shell languages?
16:45:13 <Saizan> BMeph: cabal-install couldn't exist if packages didn't specify dependencies explicitly
16:45:23 <yitz> it has variable assignments like functional languages, e.g. lisp.
16:45:53 <Peaker> yitz: I don't see why people call Lisp an FP at all
16:46:30 <sutats> Can someone suggest improvements for http://hpaste.org/12017 ? I know there's a lot of room for them.
16:46:41 <BMeph> Saizan: I mean that to get cabal-install running, you...(wait for it)...
16:46:50 <p_l> Peaker: Because it is. It's simply that most implementations either give you full freedom of choice or don't block possibility of assignment
16:46:55 <BMeph> Saizan: ...run a shell script!
16:47:06 <yitz> Peaker: functions == data
16:47:30 <p_l> Peaker: Also, the reason for the power of lisp is it's flexibility
16:47:31 <Peaker> p_l, yitz: Most languages support "functional style" and allow passing functions (in the form of ptrs or not) around
16:47:42 <Peaker> p_l, yitz: So almost all languages are functional by that criteria
16:47:45 <Saizan> BMeph: heh, but the script doesn't try! it _knows_ where the deps are! ;)
16:48:00 <p_l> Peaker: Except that most languages don't have functions as first class objects
16:48:18 <p_l> AFAIK that's the definition of Functional Language
16:48:51 <Saizan> allow passing functions == functions are first class
16:48:57 <Saizan> more or less
16:49:07 <Peaker> p_l: why are function pointers not "first class objects"?
16:49:17 <Saizan> you also want lexical closusers i guess
16:49:21 <p_l> Saizan: Not exactly. The fact that you can pass a function pointer doesn't make it a first class
16:49:42 <roconnor> ddarius: I can claim that a monad is strong when map is a morphism?
16:49:56 * roconnor can't read catagory theory.
16:49:57 <Peaker> Well, Java and Python are Functional then, at least as functional as Lisp
16:50:01 <Saizan> but in python, ruby, C#, .. functions are first class, but i wouldn't call them functional
16:50:24 <lilac> functions as first class includes creating them at runtime, in my opinion... which means closures or similar
16:50:25 <Peaker> Lisp is just an imperative language, like all the rest, IMO
16:50:55 <pumpkin> all the rest?
16:51:05 <p_l> Peaker: A little bit of history: "pure" Lisp is executable mathematics
16:51:19 <Peaker> pumpkin: mainstream languages
16:51:23 <mcoram> yes, but that's "pure" Lisp.
16:51:26 <Twey> Peaker: They're multiparadigm, one of which paradigms is functional
16:51:28 <pumpkin> scheme
16:51:33 <telexicon> parsec is kind of frustrating v_v
16:51:51 <p_l> AFAIK the only reason we got it as programming language is because some student found that if he coded (eval x) in machine code, he would get the rest of language right away
16:52:06 <Peaker> Twey: if we include every language that has lexical scoping and function passing around as multi-paradigm and functional, we'd include way too many
16:52:27 <Twey> Peaker: Nevertheless, they technically are.
16:52:44 <Twey> Not necessarily *purely* functional, mind you, or even exclusively functional
16:52:47 <pumpkin> so why not define it as a language in which people program primarily in the "functional style", whether by choice or because the language allows no other style?
16:52:48 <Peaker> then "functional language" is not very interesting
16:52:57 <Twey> In the same way that C is OO
16:53:03 <Twey> They don't necessarily make it easy.
16:53:09 <p_l> C = portable assembler
16:53:13 <telexicon> or C is functional
16:53:25 <ksf> now that's an exaggeration.
16:53:26 <Twey> telexicon: No, because functions aren't first-class in C
16:53:33 <yitz> we usually use the term to mean languages that "feel functional" when used in the usual way. pretty subjective.
16:53:34 <telexicon> sure they are
16:53:38 <telexicon> Twey, C has function pointers
16:53:44 <ksf> but no closures.
16:53:44 <telexicon> you can pass functions around just fine
16:53:48 <pumpkin> yitz: yeah, that's what I was trying to get at
16:53:48 <mcoram> so now we're arguing that Turing machines are functional too, b/c you can implement it on top, come on.
16:53:59 <Twey> (I don't think I'd call Java first-class either — function pointers and Method wrappers aren't really the same as first-class functions)
16:54:07 <p_l> telexicon: this way assembler is functional
16:54:11 <Twey> mcoram: No, because it has no core support for first-class functions
16:54:16 <pumpkin> hell yeah
16:54:17 <Saizan> we could use a fun rule of thumb: do they have function composition in their Prelude?
16:54:18 <pumpkin> functional as
16:54:22 <telexicon> p_l, so perhaps that definition is too broad
16:54:30 <pumpkin> why not just ask how they're usually programmed, as I said?
16:54:31 <Peaker> Saizan: does Lisp?
16:54:33 <yitz> do they have a Prelude?
16:54:37 <ddarius> roconnor:  "map"?
16:54:47 <Peaker> Saizan: I don't recall that in Scheme/CL
16:54:52 <Twey> pumpkin: Because that makes JavaScript 'non-functional'
16:54:57 <ksf> i'd draw the line at whether or not they ship with fold, map and zip.
16:54:58 <Twey> And, heck, it makes newbie Haskell non-functional
16:54:58 <roconnor> ddarius: liftM
16:54:59 <Saizan> yitz: are there languages where you don't have anything in scope by default?
16:55:08 <telexicon> heh
16:55:09 <Twey> You know, the type where you write everything in IO
16:55:11 <Saizan> Peaker: i don't think so, no
16:55:12 <telexicon> how about calling them dysfunctional
16:55:18 <ksf> but then, xslt doesn't ship any of them and is even purely functional.
16:55:22 <pumpkin> Twey: eww
16:55:23 <pumpkin> :P
16:55:24 <roconnor> ddarius: the functor
16:55:26 <Twey> Haha, telexicon
16:55:33 <ksf> ...so are c++ templates.
16:55:35 <pumpkin> ruby is kinda functional
16:55:44 <telexicon> what are you talking about
16:55:46 <pumpkin> ruby is barely functional
16:55:47 <telexicon> ruby is barely functional
16:55:49 <pumpkin> :P
16:55:51 <telexicon> lol
16:55:52 <Japsu> @quote out-perl
16:55:52 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
16:55:56 <Twey> Haha
16:55:56 <ksf> pumpkin, that's because oop isn't a technique but a marketing term.
16:55:58 <Japsu> @quote ruby
16:55:59 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
16:56:04 <Japsu> meh
16:56:10 <pumpkin> telexicon: lots of nice higher order functions, everything is a function, etc.
16:56:11 <Peaker> message-passing OOP is really not likely to be functional in any way
16:56:14 <Philonous> It's funny how an ill-defined term like "functional" gives rise to almost zealous discussions
16:56:23 <p_l> yeah
16:56:24 <yitz> Saizan: most languages have lots of builtins, not a Prelude of variables like Haskell.
16:56:33 <badsheepy> doesnt every term people care enough about :)
16:56:34 <Twey> Ruby is like Perl with a few ideas stolen from Lisp.
16:56:40 <ddarius> roconnor: Just the functorial action being a morphism doesn't make the (whole) monad strong, I don't think.
16:56:56 <Peaker> Ruby yucky :)
16:57:03 <pumpkin> ruby yummy :)
16:57:05 <p_l> Also, you cannot say that Lisp has ugly syntax, cause Lisp has no syntax
16:57:05 <telexicon> Philonous, almost zealous?
16:57:06 <roconnor> ddarius: oh?
16:57:10 <telexicon> i dont care for ruby
16:57:16 <roconnor> ddarius: what do I need to prove?
16:57:26 <Japsu> a-ha!
16:57:29 <Peaker> pumpkin: the @ stuff, lack of parens special-casing of 0-args, and "optional" Perlisms are horrible (the grammar isn't optional, its there)
16:57:31 <Japsu> @quote out-smalltalk
16:57:31 <lambdabot> LoganCapaldo says: ruby isn't trying to out-python python, its trying to out-smalltalk perl :)
16:57:48 <Saizan> p_l: it surely doesn't have a nice syntax
16:58:03 <Saizan> p_l: even if all its syntaxes are good
16:58:05 <Peaker> p_l: Lisp has syntax
16:58:14 <pumpkin> Peaker: yeah, I don't like that stuff, but it still does have "functional-ish" higher-order functions like map, fold, and filter, and everything is a function :P
16:58:20 <Peaker> p_l: otherwise, how is it possible to parse Lisp?
16:58:23 <Japsu> someone should make a lambdacat out of that
16:58:24 <p_l> Peaker: M-exps were banished years ago
16:58:27 <Japsu> "LISP HAS A SYNTAX"
16:58:33 <Twey> Peaker: No, s-expressions have syntax
16:58:35 <mapreduce> Abstract lisp has a syntax, but very minimal.
16:58:37 <Twey> Lisp doesn't
16:58:37 <p_l> Peaker: You write the parse tree
16:58:47 <Japsu> abstractlisp is abstract. concretelisp is concrete.
16:58:49 <Peaker> Twey: s-expressions are abstract syntax
16:58:52 <mapreduce> Common Lisp has a larger syntax.
16:59:04 <Peaker> Twey: the paren formatting is a concrete/textual syntax
16:59:23 <Peaker> p_l: M-exps?
16:59:31 <p_l> well, in a sense, S-exps are syntax for Lisp parse trees. The "real" syntax, M-exps, got killed for good in 60's
16:59:42 <p_l> And a good thing that is
17:00:20 <mapreduce> The only real problem with lisp syntax is that it often requires back-to-front editing.
17:00:28 <Peaker> p_l: "Lisp has ugly syntax" obviously refers to CL/Scheme too, not Dylan/etc
17:00:34 <mapreduce> I find postfix grammars more natural that way.
17:00:56 <p_l> Peaker: I refer to classic Lisps since Lisp 1.0
17:00:59 <Peaker> I think arguments are more related to the operators than to each other, so infix makes more sense than prefix visually
17:01:17 <Peaker> Mathematics uses multi-dimensional infix (multi-arg funcs like integral have their args ordered all around the function)
17:01:19 <mapreduce> Peaker: That's difficult to scale to 3 args.
17:01:29 <Peaker> mapreduce: you have more dimensions than the x-axis
17:01:40 <mapreduce> Peaker: That's difficult to scale to 4 args.
17:01:42 <Peaker> mapreduce: that is, ofcourse, if you're willing to disconnect from the textual serialization medium
17:01:58 <yitz> Peaker: that's not infix. that's amongfix.
17:02:02 <Peaker> mapreduce: look at the integral function, it has 4 args or more
17:02:04 <p_l> Peaker: That's why I say Lisp has no syntax. They found it easier and more powerful to ignore the syntax and write the trees directly, omitting the parses
17:02:07 <Peaker> yitz: it has a name?
17:02:15 <yitz> it does now
17:02:19 <Peaker> yitz: heh
17:02:23 <mapreduce> p_l: There's still parsing.  Also see reader macros.
17:02:39 <Peaker> p_l: you can't represent any structure in text without syntax
17:02:53 <lament> infix and prefix both make no sense whatsoever
17:03:06 <lament> named, unordered arguments are the only way which makes sense
17:03:09 <p_l> mapreduce: reader macros can be considered programs that operate on the data loaded by the system
17:03:19 <p_l> (they are in fact)
17:03:25 <Peaker> lament: math uses multi-dimensional infix, and people like that
17:03:42 <lament> Peaker: math is a bit of a special case
17:03:47 <lament> Peaker: but compare to human languages
17:03:48 <p_l> Peaker: There are also Lisp systems that visualized the parse trees instead of having to write S-exps
17:04:09 <lament> Peaker: the only language i can think of where complex verbs taking multiple objects assign meaning to the objects based on order is lojban
17:04:18 <lament> and it's utterly horrible and ridiculous
17:04:19 <Peaker> lament: why is it a special case?  human languages are mainly vocal, and when visually laid out, they're just serializing the vocal...
17:04:39 <Peaker> lament: positional arguments suck, but geometric/locational arguments are fine ;)
17:04:43 <Twey> lament: na go'i
17:04:48 <Twey> .i mutce plixau
17:04:56 <Peaker> lament: To-the-left, above, etc are not hard to remember.  3rd vs 5th is hard
17:04:58 <lament> Twey: iru kacen!
17:05:05 <ddarius> roconnor: Skimming the paper by Kock linked to from the wikipedia page, it seems like I'm wrong, so what you need to prove is that if T is a monad and a strong functor then T has a tensorial strength.
17:05:07 * Twey chuckles.
17:05:24 <Peaker> p_l: ok, in that case you're editing abstract syntax, its still an encoding of semantics - i.e: a syntax
17:05:30 <lament> Peaker: i agree that the former is easier
17:05:42 <roconnor> ddarius: oh good.  I couldn't understand that paper.
17:05:49 <Peaker> lament: why is math a special case?
17:06:03 <p_l> Peaker: You really don't want to know what happens when you kick positionality and order out of language <--- actually speaks a language that allows for nearly free-form sentence structure
17:06:06 <ddarius> roconnor: I'm not sure I completely understand it either.
17:06:17 <ddarius> That's why I'm going to prove the above statement.
17:06:40 * Twey speaks two.
17:06:42 <Twey> ... or three
17:06:46 * Twey ponders.
17:06:47 <Peaker> lament: locational args are more concise, but require more memorizing. for functions you use often, conciseness is more important. For functions you use rarely, learning curve is more important.  Use named args for rare funcs, and geometric/locational for frequent ones.  If you use a smart code editor, you get to choose which are the frequent and rare ones
17:06:52 <lament> p_l: we're talking about arguments to functions, which correspond to objects for verbs
17:06:57 <Peaker> lament: (as a presentation option)
17:06:58 <Twey> Peaker: You get Latin.  :)
17:07:00 <lament> p_l: in this sense, english is fairly free in terms of order, as well
17:07:09 <Twey> It isn't free
17:07:12 <yitz> p_l: sounds like XSLT
17:07:14 <lament> p_l: compare: "I'm going TO the movies WITH my girlfriend"; "I'm going WITH my girlfriend TO the movies"
17:07:23 <Twey> Those aren't objects :)
17:07:26 <lament> the function of the arguments is determined by the preposition, not by the order
17:07:49 <Twey> It has many different cases, but generally the rules must be obeyed
17:08:10 <yitz> lament: it's not free - there are very complex rules underlying those transformations
17:08:19 <Twey> The exception being in phrases where there are many prepositions to mark the meaning of the arguments, as demonstrated, but there are even exceptions to that exception
17:08:32 <p_l> lament: (with (going (:where movies) girlfriend)
17:08:35 <lament> obviously english is full of exceptions
17:08:47 <Twey> p_l: UNBALANCED PAREN
17:08:52 <p_l> )
17:09:08 <lament> i'm just saying that having a free argument order is not scary
17:09:11 <Peaker> lament: I think with hyper-generalization (e.g mapping almost all operations to standardized Haskell type classes) you get get very few functions to cover all of your bases, so you have few rarely used (named-arg) funcs, and most can be locational (infix, multi dimensional)
17:09:15 <Twey> ((continuous go) i :with girlfriend :to movies)
17:09:29 <yitz> lament: famous example: "I ran up a big hill" => "Up a big hill I ran", but not: "I ran up a bill bill." =/=> "Up a big bill I ran."
17:09:38 <lament> yitz: so?
17:09:42 <yitz> s/bill bill/big bill/
17:09:53 <mapreduce> What does bill have to do with it?
17:10:01 <Peaker> lament: also, how many functions take more than 2 args in a language like Haskell?
17:10:20 <lament> yitz: My point is not that English has free word order. It obviously doesn't. My point is that having a free argument order for verbs is easy in general, as demonstrated by my example.
17:10:21 <mapreduce> Peaker: Arguably none.
17:10:27 <p_l> Also English has a complex rule about what types of adjectives go in what order when you describe an object
17:10:30 <Peaker> Hehe, including currying
17:10:40 <lament> p_l: irrelevant.
17:10:56 <adityam> How do I get cross product of two sets (lists)
17:11:08 <Peaker> adityam: with the list applicative or monad
17:11:34 <Peaker> adityam: [(x,y) | x <- xs, y <- ys]
17:11:44 <Peaker> adityam: or fancy: liftA2 (,) xs ys
17:11:49 <Twey> Or with sequence
17:12:06 <adityam> I mean if a = [1,2], b = [3,4], cross a b = [[(1,3), (2,3)], [(1,3), (2,4)], [(1,4), (2,3)], [(1,4), (2,4)]]
17:12:28 <Twey> > sequence [[1, 2], [3, 4]]
17:12:29 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
17:12:38 <Peaker> adityam: why are they divided into pairs?
17:12:52 <Peaker> adityam: why do you result in [[(a,b)]] and not [(a,b)] ?
17:13:00 <adityam> That is what I want.
17:13:11 <Saizan> that's not cross product
17:13:26 <Peaker> it seems like sort of a cross-product between cross products
17:13:37 <Peaker> > liftA2 (,) [1,2] [3,4]
17:13:38 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
17:13:43 <adityam> sorry, ... I then don't know the correct name for it
17:14:01 <adityam> it is more like all feasible n-tuples formed by n lists
17:14:14 <adityam> Like product spaces in calculus
17:14:22 <Peaker> adityam: why do you not have [(2,3), (2,4)]/etc?
17:14:27 <Twey> You're screwed for 'n-tuples'
17:14:40 <adityam> 'n-lists' will do :)
17:14:42 <Twey> 'n-tuple' is not a Haskell type
17:14:45 <Twey> Ah
17:15:11 <Twey> In fact, tuples are a myth :(  There's no tuple type in Haskell
17:15:17 <Twey> I only just realised this!
17:15:19 <Peaker> Twey: ?
17:15:19 <adityam> Peaker: (2,3), (2,4) is illegal. There has to be one element with 1, and one with 2
17:15:19 <pumpkin> o.O
17:15:40 <Peaker> adityam: what result would you have for: [1,2,3] [4,5] ?
17:16:08 <Peaker> > splitAt 2 $ liftA2 (,) [1,2] [3,4]
17:16:08 <Twey> Peaker: You've got units, pairs, triples, quadruples, &c., but no 'tuple' type
17:16:09 <lambdabot>   ([(1,3),(1,4)],[(2,3),(2,4)])
17:16:12 <Twey> Also, no one-tuple...
17:16:39 <Peaker> > uncurry (liftA2 (,)) . splitAt 2 $ liftA2 (,) [1,2] [3,4]
17:16:40 <adityam> = [(1,4), (2,4), (3,4)], [(1,4), (2,4), (3,5)], [(1,4), (2,5), (3,4)] ....
17:16:40 <lambdabot>   [((1,3),(2,3)),((1,3),(2,4)),((1,4),(2,3)),((1,4),(2,4))]
17:16:43 <dolio> Pairs, triples and quadruples are all tuples.
17:17:07 <dolio> 2-tuple, 3-tuple, 4-tuple ...
17:17:12 <pumpkin> that's like saying haskell doesn't have integers, it just has 1, 2, 3, 4, 5, 6, etc. :P
17:17:17 <Twey> dolio: But there's no one 'tuple' type
17:17:33 <Twey> Nay, pumpkin, there's a type Integer
17:17:34 <dolio> There are many tuple types.
17:17:38 <Twey> Right
17:17:46 <Twey> 'Tuple' is a whole class of types
17:17:57 <Twey> That are actually pretty much unrelated
17:18:04 <pumpkin> ah, fair enough
17:18:15 <pumpkin> and are a pain to work with
17:18:19 <Peaker> > let xs = [1,2,3] ; ys = [4,5] in [[(x,y) | y <- ys] | x <- xs]
17:18:21 <lambdabot>   [[(1,4),(1,5)],[(2,4),(2,5)],[(3,4),(3,5)]]
17:18:29 <adityam> Pearker: liftA2 does not give the results in the correct order for three elements
17:18:36 <Twey> I mean, 'pair' isn't even a type
17:18:52 <Peaker> adityam: like that?
17:18:56 <Twey> It's just a combination of any other two types
17:19:04 <Twey> So tuples are actually a class of classes of types :-\
17:19:06 <adityam> Peaker: No
17:19:20 <Peaker> > let xs = [1,2,3] ; ys = [4,5] in [[(x,y) | x <- xs] | y <- ys]
17:19:21 <lambdabot>   [[(1,4),(2,4),(3,4)],[(1,5),(2,5),(3,5)]]
17:19:53 <Peaker> adityam: what about that?
17:20:16 <adityam> Perker: that is different
17:20:18 <Saizan> adityam: what are you using this for?
17:20:23 <adityam> Let me type the whole output
17:21:13 <adityam> Suppose a is valid states for machine 1, and b is valid states for machine two. I want the set of all possible states where both machines can be at a time
17:21:22 <adityam> And generalize to n machines.
17:21:41 <Peaker> adityam: that's not what you wrote above
17:21:47 <Saizan> ah, i see
17:21:48 <Peaker> adityam: I think that's a simple cross product
17:21:54 <Twey> It does indeed sound like a cross-product of cross-products
17:22:08 <Saizan> adityam: you want all the possible "traces"?
17:22:09 <Twey> > sequence . sequence $ [[1, 2], [3, 4]]
17:22:10 <lambdabot>   [[1,1,2,2],[1,1,2,4],[1,1,3,2],[1,1,3,4],[1,4,2,2],[1,4,2,4],[1,4,3,2],[1,4...
17:22:20 <Twey> Hmn, maybe not quite...
17:22:33 <Twey> Hey gwern!
17:22:35 <Peaker> I don't understand why that is not an ordinary cross product
17:22:47 * dolio doesn't either.
17:22:47 <adityam> How about a simpler problem: f [0, 1] = [ [0,0], [0,1], [1,0], [1,1]]?
17:22:51 <Twey> Peaker: Because [1, 2] and [2, 1] are different
17:23:14 <Twey> There is a really simple way to do this.
17:23:20 <Twey> Probably a built-in function.
17:23:25 <Twey> Unfortunately, I don't remember it.
17:23:36 <adityam> Then I can generate two such lists and combine them
17:23:45 <dmwit> > replicateM 2 [0, 1]
17:23:46 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
17:23:58 <Peaker> Twey: I don't understand: say you result in a [(astate, bstate)], what state will you be missing?
17:23:59 <Twey> That's the one
17:24:11 <Saizan> Peaker: because it's not the set of states in which the machines can be at any given time, but the set of possible state transitions
17:24:12 <Peaker> Twey: (with normal cross product).  [2,1] vs [1,2] would be the wrong type of the tuple
17:24:16 <adityam> >replicateM 3 [ 0,1,2]
17:24:19 <Twey> replicateM 3 [0, 1, 2]
17:24:22 <Twey> > replicateM 3 [0, 1, 2]
17:24:22 <lambdabot>   [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,1,2],[0,2,0],[0,2,1],[0,2,2],[1...
17:24:27 <dmwit> > liftM2 (,) [0, 1, 2] "abc"
17:24:29 <lambdabot>   [(0,'a'),(0,'b'),(0,'c'),(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c')]
17:24:33 <mikezackles> How do I prevent cabal install from trying to install a package that is cached?
17:24:38 <Twey> Peaker: It's not going to be a tuple
17:24:54 <dmwit> mikezackles: cached just means it downloaded it, not that it installed it.
17:24:57 <Peaker> Saizan: but adityam did say "at a time"
17:25:06 <seliopou> (template haskell?)
17:25:42 <Twey> > sequence [[0, 1]]
17:25:43 <lambdabot>   [[0],[1]]
17:25:47 <Twey> Peaker: ^ cross-product
17:25:58 <Twey> > sequence [[0, 1], [2, 3]]
17:25:59 <lambdabot>   [[0,2],[0,3],[1,2],[1,3]]
17:26:13 <mikezackles> dmwit: I installed it manually earlier, after it had downloaded it.  It's listed in cabal list --installed.  But when I try to install a package that depends on it, it tries to rebuild.
17:26:29 <Twey> > replicateM 4 [0, 1, 2, 3]
17:26:30 <adityam> Maybe I am using the wrong teriminology, but sequence doesn't give what I want
17:26:30 <lambdabot>   [[0,0,0,0],[0,0,0,1],[0,0,0,2],[0,0,0,3],[0,0,1,0],[0,0,1,1],[0,0,1,2],[0,0...
17:26:36 <Twey> Peaker: ^ something else
17:26:41 <Twey> adityam: replicateM is what you want
17:26:50 <dmwit> mikezackles: Check that it's either installed globally or that it's installed locally *and* you're passing --user to cabal install.
17:27:05 <ddarius> :t uncurry fmap . curry id
17:27:06 <lambdabot>     Couldn't match expected type `(a -> b, f a)'
17:27:06 <lambdabot>            against inferred type `b1 -> (a1, b1)'
17:27:06 <lambdabot>     Probable cause: `curry' is applied to too few arguments
17:27:16 <dmwit> adityam: What was the original question?  I just arrived.
17:27:16 <adityam> Twey: Partly, I think I can combine things with replicateM to get what I want
17:27:19 <ddarius> :t uncurry fmap
17:27:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b, f a) -> f b
17:27:21 <Twey> adityam: replicateM numberOfMachines listOfStates
17:27:26 <ddarius> :t curry id
17:27:27 <lambdabot> forall a b. a -> b -> (a, b)
17:27:43 <Saizan> mikezackles: it also might want to reinstall it if you've built it against some versions of packages that conflict with the one selected for the current installation
17:27:59 <mmorrow> @type (uncurry . curry) id
17:28:00 <lambdabot> forall a b. (a, b) -> (a, b)
17:28:03 <ddarius> :t uncurry fmap . first (curry id)
17:28:04 <lambdabot> forall (f :: * -> *) b b1. (Functor f) => (b, f b1) -> f (b, b1)
17:28:10 <Saizan> mikezackles: you can use cabal install --dry-run -v to get info on what cabal-install wants to do
17:28:24 <mikezackles> dmwit: I haven't been passing --user at all.  That would mean it's installed globally, right?
17:28:43 <dmwit> mikezackles: Not necessarily.  Check ghc-pkg list's output to know for sure.
17:28:53 <Saizan> mikezackles: you can bypass this by using cabal configure; cabal build; cabal install --only
17:28:54 <mikezackles> ah, thanks
17:28:59 <mmorrow> @type (curry . uncurry . curry) id
17:29:00 <lambdabot> forall a b. a -> b -> (a, b)
17:29:40 <lispy> :t curry . uncurry . curry
17:29:40 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:29:47 <adityam> dmwit: I have two lists a = [1,2,3], b = [4,5]. I want to generate [[(x,y)]] where each sublist has one element from a, and one from b
17:30:01 <lispy> :t map zip
17:30:01 <lambdabot> forall a b. [[a]] -> [[b] -> [(a, b)]]
17:30:30 <dmwit> adityam: uh, one element from each?  That's a bit odd, but how about:
17:30:43 <dmwit> > [[(a, b)] | a <- [1,2,3], b <- [4,5]]
17:30:45 <lambdabot>   [[(1,4)],[(1,5)],[(2,4)],[(2,5)],[(3,4)],[(3,5)]]
17:30:46 <mikezackles> dmwit: ghc-pkg list shows that it is installed globally
17:30:52 <mmorrow> @type foldr (zipWith (++)) (repeat [])
17:30:53 <lambdabot> forall a. [[[a]]] -> [[a]]
17:31:00 <lispy> :t cycle
17:31:01 <lambdabot> forall a. [a] -> [a]
17:31:08 <lispy> > cycle [1,2,3]
17:31:09 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
17:31:19 <ddarius> All that remains is a whole shit-ton of calculation
17:31:24 <lispy> > cycle []
17:31:25 <lambdabot>   * Exception: Prelude.cycle: empty list
17:31:34 <mmorrow> @type foldr (zipWith (++)) (repeat []) :: [[a]] -> [a]
17:31:35 <lambdabot>     Couldn't match expected type `a1' against inferred type `[a]'
17:31:35 <lambdabot>       `a1' is a rigid type variable bound by
17:31:35 <lambdabot>            the polymorphic type `forall a1. [[a1]] -> [a1]'
17:31:38 <lispy> > cycle [[]]
17:31:39 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
17:31:40 <adityam> Actually, I wanted this:
17:31:50 <pumpkin> is there a standard complex number type in haskell?
17:32:00 <dons> yeah
17:32:00 <dmwit> pumpkin: Yes, it's called Complex.
17:32:01 <mikezackles> Saizan: Ah, thanks.  dry-run tells me it wants base 3.0.3
17:32:01 <lispy> :t 1 :+ 0
17:32:02 <lambdabot> forall t. (RealFloat t) => Complex t
17:32:05 <dons> ?hoogle Complex
17:32:05 <lambdabot> module Data.Complex
17:32:05 <lambdabot> Data.Complex data RealFloat a => Complex a
17:32:05 <lambdabot> package storable-complex
17:32:10 <dons> lambdabot knows all
17:32:11 <pumpkin> ah fun
17:32:13 <pumpkin> thanks :)
17:32:17 <Peaker> adityam: what about:
17:32:19 <Peaker> > let xs = [1,2,3] ; ys = [4,5] in sequence [[(x,y) | y <- ys] | x <- xs]
17:32:20 <lispy> > sqrt (-1) :: Complex Double
17:32:20 <lambdabot>   [[(1,4),(2,4),(3,4)],[(1,4),(2,4),(3,5)],[(1,4),(2,5),(3,4)],[(1,4),(2,5),(...
17:32:21 <lambdabot>   (-0.0) :+ 1.0
17:32:38 <mmorrow> @type foldr (zipWith mappend) (repeat mempty)
17:32:39 <lambdabot> forall a. (Monoid a) => [[a]] -> [a]
17:33:03 <dolio> > let f a b = map (\e -> (,) e <$> b) a in f [1,2,3] [4,5]
17:33:04 <lambdabot>   [[(1,4),(1,5)],[(2,4),(2,5)],[(3,4),(3,5)]]
17:33:16 <dolio> > let f a b = map (\e -> (,) e <$> b) a in sequence $ f [1,2,3] [4,5]
17:33:17 <lambdabot>   [[(1,4),(2,4),(3,4)],[(1,4),(2,4),(3,5)],[(1,4),(2,5),(3,4)],[(1,4),(2,5),(...
17:33:18 <mikv> src $
17:33:31 <mikv> @src $
17:33:31 <lambdabot> f $ x = f x
17:33:50 <adityam> dmwit: f [1,2,3] [4,5] = [ [(1,4), (2,4), (3,4)], [(1,4), (2,4), (3,5)], [(1,4), (2,5), (3,4)], [(1,4),(2,5), (3,5)], [(1,5), (2,4), (3,4)], [(1,5), (2,5), (3,4)], [(1,5), (2,5), (3,5)]]
17:34:18 <dmwit> adityam: Ah, you want the list of possible sequences of length n of the second list!
17:34:23 <dmwit> adityam: That should be no problem.
17:34:35 <adityam> dolio: Thanks, I think that does what I want
17:34:38 <dmwit> > (\xs -> replicateM (length xs) xs) [4,5]
17:34:39 <lambdabot>   [[4,4],[4,5],[5,4],[5,5]]
17:34:44 <dmwit> err
17:35:01 <dmwit> > let xs = [1..3]; ys = [4..5] in replicateM (length xs) ys
17:35:02 <lambdabot>   [[4,4,4],[4,4,5],[4,5,4],[4,5,5],[5,4,4],[5,4,5],[5,5,4],[5,5,5]]
17:35:28 <adityam> dmwit: dolio's solution does what I want
17:35:42 <dmwit> Great!
17:36:04 <dolio> > let f a = map (zip a) . replicateM (length a) in f [1..3] [4..5]
17:36:05 <lambdabot>   [[(1,4),(2,4),(3,4)],[(1,4),(2,4),(3,5)],[(1,4),(2,5),(3,4)],[(1,4),(2,5),(...
17:36:18 <lispy> ?pl \e b -> (,) e <$> b
17:36:18 <lambdabot> (<$>) . (,)
17:36:33 <dmwit> > let xs = [1..3]; ys = [4..5] in replicateM (length xs) ys >>= zip xs
17:36:35 <lambdabot>   [(1,4),(2,4),(3,4),(1,4),(2,4),(3,5),(1,4),(2,5),(3,4),(1,4),(2,5),(3,5),(1...
17:37:00 <dmwit> Ah, dolio beat me once again, and with a more correct answer. =)
17:37:02 <dmwit> dolio++
17:37:28 <adityam> I am still trying to understand how it is working
17:37:37 <dmwit> adityam: I'll be mildly surprised if this ends up actually being what you want, though.
17:37:52 <lispy> Can we use the hackage categories to see what Haskell is good at?
17:37:59 <Peaker> > (sequence .) . flip (map . (. (,)) . flip map) [1,2,3] [4,5]
17:38:00 <lambdabot>   Couldn't match expected type `a -> a2 -> [m a1]'
17:38:05 <adityam> dmwit: Atleast for this example, it is. I'll try a few variations and see
17:38:06 <dmwit> adityam: Oh, I can explain it for you, if you like.
17:38:09 <lispy> For example, we have 48 packages in the Network category
17:38:21 <lispy> But, only 2 in the combinators category
17:38:34 <lispy> Heh, and 83 in System
17:38:38 <dmwit> adityam: The first thing to notice is that in your example, the "firsts" are the same for each sublist: they are [1,2,3] each time.
17:38:48 <lispy> So, I would say that Haskell is good at system and network programming but not so good at combinators
17:38:49 <dmwit> adityam: The only thing that varies is the "seconds" of each sublist.
17:38:51 <Peaker> > (sequence .) . flip (map . (. (,)) . flip map) $ [1,2,3] [4,5]
17:38:52 <lambdabot>   Couldn't match expected type `t -> [a]'
17:39:04 <Peaker> > ((sequence .) . flip (map . (. (,)) . flip map)) [1,2,3] [4,5]
17:39:05 <lambdabot>   [[(1,4),(2,4),(3,4)],[(1,4),(2,4),(3,5)],[(1,4),(2,5),(3,4)],[(1,4),(2,5),(...
17:39:15 <dmwit> adityam: If you look at them carefully, you'll see that they're the sequences of elements from [4,5] that have the same length as [1,2,3].
17:39:20 <dmwit> adityam: Are you with me so far?
17:39:26 <adityam> dmwit: yes
17:39:41 <dmwit> adityam: Okay.  So step one is constructing sequences of elements from [4,5] that have a given length.
17:39:54 <adityam> yes
17:40:17 <dmwit> adityam: To do that, we nondeterministically choose either 4 or 5 the right number of times, then construct a list of our choices.
17:40:24 <dolio> > let f l = map (zip l) . sequence . (l >>) . return in f [1,2,3] [4,5]
17:40:25 <lambdabot>   [[(1,4),(2,4),(3,4)],[(1,4),(2,4),(3,5)],[(1,4),(2,5),(3,4)],[(1,4),(2,5),(...
17:40:28 <dmwit> adityam: Now, nondeterminism is exactly what the list monad does.
17:40:32 <Peaker> Isn't   sequence [[(x,y) | y <- ys] | x <- xs]   a simple working solution (without needing to length, etc)?
17:40:45 <dmwit> adityam: And we already have a function (replicateM) which repeats a monad a given number of times.
17:40:55 <adityam> So, that's why replicateM works. Thanks dmwit
17:41:14 <dmwit> After that, it's just a matter of combining the answers. =)
17:41:22 <dolio> > let f l = map (zip l) . sequence . (l >>) . return in f [1.] [4,5]
17:41:23 <lambdabot>   <no location info>: parse error on input `]'
17:41:28 <dolio> > let f l = map (zip l) . sequence . (l >>) . return in f [1..] [4,5]
17:41:29 <adityam> I want the function to be symmetric, so I guess I need to check the bigger list and then flip arguments
17:41:30 <lambdabot>   * Exception: stack overflow
17:41:31 <dmwit> :t filterM
17:41:32 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:41:40 <dmwit> :t foldM
17:41:42 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:41:52 <adityam> Thanks for the explanation. I did not know that list is a monad
17:42:23 <sutats> Can someone suggest improvements for http://hpaste.org/12017 ? I know there's a lot of room for them.
17:43:24 <Peaker> sequence on a list of lists ceases to be cartesian product at the 3rd list, though
17:43:26 <pumpkin> sutats: you sure you want 0 .. width?
17:43:53 <sutats> pumpkin: Maybe not. I'm trying to build a width-by-height array.
17:43:58 <dmwit> 1..width
17:44:03 <Peaker> oh wait, it doesn't, sill yme
17:44:03 <dmwit> same for height
17:44:15 <Peaker> adityam: is the sequence on the nested list comprehensions wrong?
17:44:47 <dmwit> sutats: extractWidth/Height should be combined.
17:45:00 <sutats> dmwit: Okay. I'm stumped on that step.
17:45:18 <Peaker> sutats: f x = a . b . c . d $ x    you can use: f = a . b . c . d
17:45:29 <adityam> Peaker: Yes, see dolio's example above. That is what I wanted
17:45:43 <Peaker> adityam: iiuc, it seems to generate the same output
17:46:22 <adityam> > let f l = map (zip l) . sequence . (l >>) . return in f [1,2,3] [4,5]
17:46:23 <lambdabot>   [[(1,4),(2,4),(3,4)],[(1,4),(2,4),(3,5)],[(1,4),(2,5),(3,4)],[(1,4),(2,5),(...
17:46:32 <Peaker> > let xs = [1,2,3] ; ys = [4,5] in sequence [[(x,y) | y <- ys] | x <- xs]
17:46:34 <lambdabot>   [[(1,4),(2,4),(3,4)],[(1,4),(2,4),(3,5)],[(1,4),(2,5),(3,4)],[(1,4),(2,5),(...
17:46:40 <sutats> Peaker: Thanks, that cleans it up a bit.
17:46:57 <Peaker> adityam: same result, I think its much simpler that way
17:46:58 <dmwit> sutats: Check my annotation.
17:47:28 <adityam> Pearker: Yes, let me check
17:47:33 <dmwit> sutats: Personally, I'd use pattern matching to cut off the first line, but (head . lines) works fine, too.
17:47:55 <adityam> Peaker: you are right. This is the same result.
17:48:03 <Peaker> dmwit: why would "second" work to extract both tuple elements?
17:48:14 <dmwit> :t second
17:48:14 <sutats> Yeah, I was curious about that too.
17:48:15 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
17:48:26 <dmwit> second passes the first part of the tuple on unchanged
17:48:42 <sutats> Ah, that's what I needed to see.
17:48:55 <dmwit> That signature reads a lot more smoothly if you write it as
17:49:09 <Peaker> adityam: the nested list comprehension gives you the cross products divided by the list from which they came from. Then sequence gives you the cross products of cross products
17:49:13 <dmwit> Arrow (~>) => (b ~> c) -> ((d,b) ~> (d,c))
17:49:29 <Peaker> dmwit: oh, right, cool
17:49:41 <Peaker> s/second/modifySecond would be clearer, probably
17:49:47 <Peaker> or something of that sort
17:49:54 <dmwit> If you like.
17:50:07 <adityam> Peaker: thanks. What does sequence do actually,
17:50:08 <dmwit> I sometimes use on* to refer to this kind of thing.
17:50:08 <mmorrow> i think first and second should be called mapl and mapr
17:50:10 <sutats> dmwit: Also, I just noticed that my original does not compile because mkBoard is pure, but load is in IO. What do I need to do to fix that?
17:50:13 <dmwit> onSecond, onHead, onLast, etc.
17:50:15 <adityam> I cannot find a description
17:50:27 <dmwit> sutats: return $ mkBoard ...
17:50:47 <dmwit> sutats: ...although using that as your "main" seems a bit odd.
17:50:56 <dmwit> sutats: Since it doesn't do actually do any output.
17:51:31 <Peaker> adityam: sequence takes a list of monadic actions, and sequences all the actions together, returning all of their results
17:51:34 <Peaker> @type sequence
17:51:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:51:42 <sutats> dmwit: I'm still stuck in the imperative programming style, so I was using do to actually do things imperatively.
17:51:48 <dmwit> sutats: You could also do mkBoard w h = listArray ((1, 1), (w, h)) (repeat 0)
17:52:04 <adityam> Peaker: but how does it give a cross product for list monad
17:52:13 <sutats> :t listArray
17:52:14 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
17:52:39 <Peaker> adityam: special case:  sequence [aa,bb] --->  do { a <- aa ; b <- bb ; return [a,b] }
17:52:41 <sutats> dmwit: Essentially the same thing? Why the repeat 0?
17:53:04 <mikv> Another dumb question
17:53:04 <Peaker> adityam: so for the list monad, a and b get all possible results, and put inside a list together
17:53:05 <dmwit> sutats: It is essentially the same, yes, but much shorter, and nicer for the following reasons:
17:53:08 <mikv> I have a function
17:53:17 <adityam> Ah, thanks Peaker
17:53:20 <mikv> and i would like to make pattern matching against it parameter
17:53:24 <mikv> I am passing list
17:53:26 <Peaker> adityam: sequence [aa,bb,cc] ---> do { a <- aa ; b <- bb ; c <- cc ; return [a,b,c] }
17:53:26 <dmwit> sutats: You don't have to construct a long list in memory.
17:53:35 <mikv> i need to match against empty list
17:53:43 <mikv> against list with single element
17:53:47 <dmwit> sutats: You don't have to calculate the length of the list (as you would if you used replicate instead of repeat).
17:53:50 <mikv> and against list with multiple elements
17:53:50 <Peaker> adityam: but my solution is not generalized to any-N
17:53:59 <mikv> How can i match for list with single element?
17:54:00 <Peaker> adityam: because the nested list comprehension isn't
17:54:11 <dmwit> sutats: And you don't have that eyesore tuple just passing along the coordinates.
17:54:35 <adityam> First I'll solve my example problem for two machines, and then worry about N :-)
17:54:36 <dmwit> sutats: In practice, the performance will likely not be measurably different; but it's easier to read and mildly faster, so what's not to love? =)
17:54:51 <sutats> dmwit: Right, it definitely looks a lot better.
17:55:24 <dmwit> sutats: (As an aside: (repeat 0) builds a very tiny list; if you wrote the direct analog of "repeat" in C, you'd make a linked list element that pointed to itself.)
17:55:39 <mmorrow> @let mapfst = first
17:55:40 <lambdabot>  <local>:4:9:
17:55:40 <lambdabot>      Ambiguous type variable `a' in the constraint:
17:55:40 <lambdabot>        `Arr...
17:55:59 <mmorrow> @let mapfst f (a,b) = (f a,b)
17:55:59 <lambdabot>  Defined.
17:56:08 <mmorrow> @let mapsnd f (a,b) = (a,f b)
17:56:08 <lambdabot>  Defined.
17:56:18 <dmwit> onFst!
17:56:19 <dmwit> onSnd!
17:56:23 <mmorrow> @let mapl f = either (Left . f) Right
17:56:24 <lambdabot>  Defined.
17:56:33 <dmwit> ...onDasher, onPrancer, onCometAndCupit!
17:56:38 <mmorrow> @let mapr f = either Left (Right . f)
17:56:39 <lambdabot>  Defined.
17:56:47 <sutats> dmwit: Ah, that makes sense. Also, you mentioned the oddness of my load/main. How would I do that "more functionally"?
17:56:49 <mmorrow> on VIXEN
17:56:52 <mmorrow> geez
17:57:03 <dmwit> ?vixen on
17:57:03 <lambdabot> so, what do you think of me?
17:57:04 <mmorrow> oh, maybe not
17:57:26 <dmwit> sutats: Well... you could do it more functionally, but that's not what's odd about it.
17:57:38 <lispy> ?type let dasher = intercalate "-" in on dasher
17:57:39 <lambdabot>     Couldn't match expected type `[[Char]] -> c'
17:57:39 <lambdabot>            against inferred type `[Char]'
17:57:39 <lambdabot>     Probable cause: `dasher' is applied to too many arguments
17:57:41 <dmwit> sutats: For what's odd about it, well, try compiling and running your program and see if it does what you think it does.
17:57:44 <lispy> ?type let dasher = intercalate '-' in on dasher
17:57:44 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Char'
17:57:44 <lambdabot>     In the first argument of `intercalate', namely '-'
17:57:44 <lambdabot>     In the expression: intercalate '-'
17:57:49 <dmwit> sutats: If yes, then there's nothing odd about it. =)
17:58:18 <sutats> dmwit: On that note, it complains about ambiguous type variables when it compiles.
17:58:36 <dmwit> uh.
17:58:40 <dmwit> line/column?
17:59:44 <mikv> Can anybody help me?
18:00:01 <dmwit> mikv: What's your question?
18:00:08 <dons> ask a question mikv, and then we can help.
18:00:29 <mikv> i need to make pattern matching for list with single element
18:00:35 <sutats> dmwit: I reannotated with the error message.
18:00:45 <mikv> i've tried several variants like
18:00:48 <dons> f [x] = x <-- like that?
18:01:04 <mikv> dons, nope. GHC doesn't want to compile
18:01:09 <dons> sure it does.
18:01:13 <mikv> hm...
18:01:27 <lispy> > let f [x] = x in f [1]
18:01:28 <lambdabot>   1
18:01:34 <dons> > (\x -> case x of [_] -> "yes"; _ -> "no") [1..10]
18:01:35 <lambdabot>   "no"
18:01:36 <dons> > (\x -> case x of [_] -> "yes"; _ -> "no") [1]
18:01:37 <lambdabot>   "yes"
18:01:39 <dons> > (\x -> case x of [_] -> "yes"; _ -> "no") []
18:01:40 <lambdabot>   "no"
18:01:57 <dmwit> sutats: Ah, right.
18:02:07 <dmwit> sutats: IArray is polymorphic over array types...
18:02:27 <mikv> Hm..
18:02:35 <mikv> Sorry. It does :-)
18:02:37 <sutats> dmwit: I don't think I need it to be, so could I change it to some other type of array?
18:02:46 <dmwit> sutats: The return type of "main" here is some kind of IArray, and the MR is trying to restrict that to a particular IArray instance.
18:03:04 <dmwit> sutats: So the easiest fix is just to annotate the type of mkBoard with a specific IArray instance.
18:03:06 <dmwit> say...
18:03:20 <dmwit> mkBoard :: Int -> Int -> Array (Int, Int) Int -- or whatever
18:04:19 <orbitz> i don't mean to ask this to start crap but a serious question (i'll take links to read if suggested), but in retro spect, is there another method fo doing I/O in haskell that might have been a better choice (or maybe a future better choice for a new pure fuction language?)
18:04:36 <dons> better choice?
18:04:41 <dmwit> sutats: Oops, and "parseSize s" in my condensed version should be "parseSize". =)
18:04:47 <dons> if there was a better one, we'd have a library for it :)
18:04:51 <sutats> dmwit: Ah, thanks very much. Makes much more sense now. Also, my formatDigit seems so trivial, but I'm using it so I can type restrict read to Int. Any suggestions for that?
18:04:51 <dons> there are other approaches though
18:04:54 <orbitz> hah
18:04:56 <dons> tried in the past.
18:05:05 <dons> continuation-based, for example.
18:05:08 <orbitz> so of all the posisbel optinos, are monads really the best way to do I/O in haskell?
18:05:09 <dmwit> sutats: With mkBoard restricted, you shouldn't need it any more.
18:05:24 <dons> orbitz: they're a sensible way to model imperative programming
18:05:36 <dons> since they define what it means to be imperative.
18:05:37 <dmwit> sutats: The more you use a value built by "read", the less likely it is you'll need to specify what type it is. =)
18:05:51 <sutats> dmwit: I love type inference.
18:05:55 <lispy> I guess you could base your IO subsystem on arrows instead of monads
18:05:55 <dmwit> =)
18:06:01 <dons> orbitz: what do you mean "best" though?
18:06:15 <sutats> dmwit: Which parseSize were you referring to?
18:06:17 <dmwit> What about Oleg's new parallel IO thing?
18:06:22 <dmwit> sutats: In my latest annotation.
18:06:23 <dons> mm?
18:06:36 <dons> oh that's still monadic.
18:06:46 <Saizan> parallel IO thing?
18:06:50 <sutats> dmwit: Oh wow, that's beautiful.
18:06:53 <dons> he means left-fold based i think.
18:06:59 <orbitz> dons: i really don't know honestly
18:07:07 <lispy> I think parallel was meant to be interleavable
18:07:12 <orbitz> dons: i have heard it becomes troublesome to combine monads, but i'm not even sure what this means
18:07:16 <Saizan> ah ok
18:07:17 <dons> oh?
18:07:25 <dons> doesn't seem to have stopped us.
18:07:27 <dmwit> lispy, Saizan: Yes, that's what I meant, sorry.
18:07:48 <orbitz> dons: i didn't mean to impy that, but rather that it is complicated
18:08:18 <dons> i think monad transformers are well understood, and widely used.
18:09:09 <sutats> dmwit: Thanks. I get everything you wrote...I just can't think that way yet. Have to break the imperative language shackles.
18:09:12 <orbitz> okay
18:09:23 <dons> not sure they're even complicated, actually. i guess being forced to think about effects at all is the main complication for newbiews.
18:09:30 <dons> used to just doing anything random
18:09:32 <dibblego> ssh-add
18:09:35 <orbitz> dons: i'm reading learnyouahaskell right now, suggestions on any others?
18:09:36 <dibblego> oops
18:09:48 <dons> orbitz: realworldhaskell.org ?
18:09:53 <orbitz> dons: thanks
18:10:26 <dmwit> orbitz: Bias alert, dons is one of the three RWH authors. ;-)  (It is definitely an excellent resource, though.)
18:10:36 <orbitz> i think my problem with haskell is i think imperatively still so i end up writing horrid haskell
18:10:39 <orbitz> it is not pretty
18:10:54 <dons> well, you'll end up using the IO monad a lot.
18:11:05 <dons> and if you're using IORefs for variables, you're definitely doing it wrong :)
18:11:08 <dmwit> orbitz, sutats: The only way to fix that is to write a lot of non-imperative code. =)
18:11:10 <Twey> Heh
18:11:15 <orbitz> hah
18:11:15 <dons> we need a "IO: you're doing it wrong" meme
18:11:25 <pumpkin> maybe http://is.gd/Gf7 ?
18:11:25 <orbitz> haha
18:11:31 <lispy> imperativ cat likes his varbl
18:11:35 <pumpkin> lol
18:11:40 <monochrom> I'm reading Oleg's slides and notes (defun08 talk) on iteratee and enumerator. The notes say: "we may see that fold is a powerful pattern; lots of papers have been written about it, and I greatly encourage you to read all of them."
18:11:53 <orbitz> i like to work in the REPL though
18:11:58 <orbitz> doing math at least
18:12:01 <dons> monochrom: did oleg write all those papers?
18:12:01 <Twey> orbitz: A starter for that is to try to keep your functions short.
18:12:05 <monochrom> All of them?! I barely have time to fold all of them, let alone read all of them. :)
18:12:12 <orbitz> Twey: i dont' think i really have a choice in haskell:)
18:12:17 <Twey> (< three lines)
18:12:32 <monochrom> Probably he wrote some of them.
18:12:46 <orbitz> like, i've done a fair amount of Erlang, and some Ocaml, but the purity and lazynes of haskell is something my brain hasn't done yet
18:13:24 <monochrom> Next time I have a chance, I'll add to my talk: "program correctness has been studied for a long time. many papers have been written, I encourage you to read all of them!" XD
18:13:48 <Twey> s/program correctness/mathematics/
18:13:48 <dons> orbitz: oh boy, if you've done erlang and ocaml, you should be fine.
18:13:53 <dons> just work through realworldhaksell
18:13:57 <orbitz> dons: thanks
18:14:14 <dons> i mean, erlang encourages a somewhat pure style of programming
18:14:20 <dons> and ocaml encourages a typeful approach
18:14:25 <dons> so now haskell, pure and typeful
18:14:27 <orbitz> yeah, i mean i'm fine with short functions, recursion, and all that stuff
18:14:41 <orbitz> i think i'm just not used to thinking of infinite lists and the way to solve program staht comes with lazyness
18:14:44 <dons> like erlang, but fast. like ocaml, but fun.
18:14:48 <orbitz> and i <3 good type system
18:15:07 <monochrom> w00t if you don't like infinite lazy lists, Oleg has something for you. :)
18:15:11 <dons> heh
18:15:16 <orbitz> IMO, i can see why peopel go to python/ruby if they start in C++/Java, the 'typing' seems so much better in a language liek Python, and you learn to think static typing is junk
18:15:24 <orbitz> then you use a language that actually has decent typing
18:15:25 <sutats> dmwit: Say the rest of the file in question fills the array with single digit integers (ie. 3x3 file contains 142\n423\n324), how would parseFile change to incorporate that?
18:15:29 <orbitz> and you go "ohhhhhhh....yeah i like this better"
18:15:42 <lispy> orbitz: right
18:16:13 <dmwit> sutats: Pass "concat ss" on to "mkBoard" and replace (repeat 0) with that.
18:16:15 <orbitz> that is how it went for me at least
18:16:43 <lispy> Progression: Java -> Python "Ugh, static types were a pain." -> Haskell "Wow, having sane, consistent semantics is soo nice.  And wow, these types are handy."
18:16:51 <dmwit> sutats: You probably have to pass digitToInt over (concat ss) first.
18:17:02 <dmwit> ?index digitToInt
18:17:02 <lambdabot> Data.Char
18:17:12 <Twey> lispy: Aye :-P
18:17:15 <orbitz> one thing that bugs the heck out of me is anything being able to bue null or None in java/python
18:17:17 <sutats> dmwit: Thanks, I'll try doing that.
18:17:25 <orbitz> Maybe/option makes so much more sense
18:17:33 <orbitz> i belive F# allows anythign ot be null too which sadden sme
18:17:57 <lispy> Anything can be _|_ (basically undefined) in haskell though :)
18:18:13 <lispy> orbitz: I reckon we'll gave you programming in agda soon ;)
18:18:34 <Twey> Haskell allows anything to be undefined.
18:18:39 <orbitz> dons: thanks, i like the real world haskell book so far, it's nice to have examples of stuff you would see in a ruby/python tutorial
18:18:47 <dons> yup
18:19:03 <orbitz> what does it mean ot be undefien din haskell?
18:19:10 <orbitz> is it the same as being nul lin Java?
18:19:11 <lispy> :t undefined
18:19:12 <lambdabot> forall a. a
18:19:14 <dons> Twey:
18:19:15 <dons> Prelude> undefined :: GHC.Base.Int#
18:19:16 <dons> <interactive>:1:0: Couldn't match kind `*' against `#'
18:19:16 <lispy> > undefined
18:19:17 <lambdabot>   * Exception: Prelude.undefined
18:19:22 <dons> not everything :)
18:19:32 <orbitz> lispy: agda, the theorem prover?
18:19:45 <monochrom> "undefined" is the same as either infinite loop or abortion.
18:19:51 <lispy> orbitz: I don't think of agda as a theorem prover, but that's a fair characterization :)
18:19:52 <orbitz> killin gbabies?
18:19:56 <Twey> OK, not *anything* :-P
18:20:00 <dons> Prelude> undefined :: GHC.Base.Terminating
18:20:01 <dons> doh.
18:20:07 <orbitz> lispy: i'd progrma in Coq, but i can't stop giggling
18:20:07 <monochrom> killing newbies!
18:20:24 <dons> where's our non-termination as a side efffect monad?
18:20:55 <monochrom> it's gone on a non-terminating vacation
18:21:07 * lispy wants a total monad
18:22:06 * Twey wants more monads
18:22:13 <lispy> heh, "ceiling cat is watching you unsafePerformIO"
18:22:15 <sutats> What's the lambdabot command to see where something is located (ie. ***)?
18:22:25 <lispy> ?index (***)
18:22:25 <lambdabot> Control.Arrow
18:22:34 <sutats> Ah, good to know.
18:22:34 <lispy> ?hoogle (***)
18:22:34 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:22:38 <pumpkin> omg the lolcatz haz infultrated #haskell 2
18:22:50 <lispy> pumpkin: yeah http://arcanux.org/lambdacats.html
18:22:51 <lambdabot> Title: Lambdacats
18:22:52 <orbitz> does teh standard lib come with an argument parser similar to like optparse in python?
18:23:16 <lispy> orbitz: have you discovered hackage yet?  hackage.haskell.org
18:23:22 <sutats> ?index liftM
18:23:22 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:23:30 <lispy> orbitz: I thought I just saw an optparse on there about 20 min ago
18:24:09 <lispy> orbitz: oh this is what I saw: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/simpleargs
18:24:11 <lambdabot> Title: HackageDB: simpleargs-0.1, http://tinyurl.com/5tb3dm
18:24:18 <orbitz> lispy: cool thanks
18:24:35 <mmorrow> @type undefined :: (Num (Num a => a) => a) -> b
18:24:36 <lambdabot> forall a b. ((Num ((Num a) => a)) => a) -> b
18:25:23 <EvilTerran> what
18:25:42 <mmorrow> it's a bug that i need to file
18:26:39 <mmorrow> > (fromIntegral :: (Num b, Integral a) => a -> (Num b => (Num b => b)) 42
18:26:40 <lambdabot>   <no location info>: parse error on input `;'
18:26:46 <EvilTerran> ... i dread to think what ghc thinks that means
18:26:53 <mmorrow> > (fromIntegral :: (Num b, Integral a) => a -> (Num b => (Num b => b))) 42
18:26:54 <lambdabot>       Could not deduce (Num ((Num b, Num b) => b))
18:26:54 <lambdabot>        from the context (N...
18:26:58 <mmorrow> , (fromIntegral :: (Num b, Integral a) => a -> (Num b => (Num b => b))) 42
18:27:00 <lunabot>  luna: luna: panic! (the 'impossible' happened)
18:27:08 <mmorrow> lunabot's using 6.10
18:27:11 <EvilTerran> uh-oh
18:27:37 * mmorrow will file the bug shortly
18:27:43 * mmorrow means it this time :)
18:27:50 <lispy> heh, when I see (Num (Num a => a) => a), I want to "join" on the type
18:29:55 <lispy> anyone here using LLVM?
18:31:06 <Peaker> adityam: whew, was a tough cookie! http://hpaste.org/12019
18:31:19 <Peaker> adityam: you there?
18:32:33 <Peaker> adityam: getting a cross product of N lists such that the products are grouped was difficult
18:32:49 <Peaker> I am not sure I understand exactly what I did fully, heh
18:33:06 <sutats> dmwit: I've run into an error trying to implement the concat bit. Could you help point out the error?
18:33:15 <sutats> dmwit: It's in the newest annotation.
18:33:27 <adityam> Peaker: yes
18:33:38 <Peaker> adityam: does that print the right result?
18:34:10 <Twey> :t on
18:34:11 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:34:17 <adityam> Peaker: Wow...yes it does. Thanks a lot
18:34:25 <dmwit> sutats: Ah, quite.  My annotation was wrong to begin with.
18:34:26 <Peaker> adityam: it took me all this time heh
18:34:34 <Peaker> adityam: good practice for me ;)
18:34:41 <dmwit> sutats: Try liftM (parseFile . lines) (readFile "maze") instead.
18:35:35 <adityam> Peaker: it will take me a lot of practice to understand it ;) Thanks.
18:35:40 <Peaker> adityam: all I wanted was to generalize [[[x,y] | y <- ys] | x <- xs]    to any amount of xs,ys,  took me 30 minutes to get that foldr right ;)
18:35:53 <sutats> dmwit: Ah, thanks, that did the trick. Did I do the concat bit okay?
18:35:59 <dmwit> Yep, perfect! =)
18:36:01 <Peaker> adityam: do you understand foldr?
18:36:05 <sutats> dmwit: Thanks for the help.
18:36:22 <Peaker> adityam: the commented pattern-match above is equivalent to the foldr..
18:36:43 <adityam> Peaker: yes, I understand foldr, but I did not know that you can do a <-b, c <- a kind of things
18:37:08 <Peaker> adityam: those are list comprehensions, which are syntax sugar over do, which is syntax sugar over >>=
18:38:30 <dolio> > (map . (flip (,) <$>)) [1..3] [4,5]
18:38:31 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
18:38:54 <Peaker> adityam: [expr | x <- xs, x>5, y <- ys] --> do { x <- xs ; if x > 5 then do { y <- ys ; return expr } else [] } -> xs >>= \x -> if x > 5 then ys >>= \y -> expr else []
18:38:54 <adityam> Peaker: okey. So, the inner list is same as do { a <- b; c <- a ; return (x:c) }
18:39:16 <Peaker> adityam: its 2 nested list comprehensions
18:39:43 <adityam> Pearker: yes, that is why I am calling it inner list
18:40:20 <Peaker> adityam: [[[x,y] | y <- ys] | x <- xs] ->  do { x <- xs ; do { y <- ys ; return [x,y] }}
18:40:46 <Peaker> @undo do { x <- xs ; do { y <- ys ; return [x,y] }}
18:40:46 <lambdabot> xs >>= \ x -> ys >>= \ y -> return [x, y]
18:41:10 <Peaker> oops, not that
18:41:28 <Peaker> adityam: [[[x,y] | y <- ys] | x <- xs] ->  do { x <- xs ; return $ do { y <- ys ; return [x,y] }}
18:41:33 <Peaker> @undo do { x <- xs ; return $ do { y <- ys ; return [x,y] }}
18:41:34 <lambdabot> xs >>= \ x -> return $ ys >>= \ y -> return [x, y]
18:41:41 <adityam> Peaker: I now understand it
18:41:56 <Peaker> adityam: list of lists of lists
18:42:07 <adityam> Peaker: Thanks, this has taught me a lot about Haskell.
18:42:33 <Peaker> cross-product of cross-products grows very quickly!
18:43:35 <dolio> :t map (map . (,))
18:43:36 <lambdabot> forall a a1. [a1] -> [[a] -> [(a1, a)]]
18:44:17 <adityam> Yes, that is why I started looking at Haskell
18:44:36 <adityam> I am hoping that lazy evaluation will mean that I do not need to keep the whole thing in memory
18:44:44 <dolio> :t map . flip (map . (,))
18:44:45 <lambdabot> forall a a1. [a1] -> [a] -> [[(a, a1)]]
18:45:01 <dolio> > (map . flip (map . (,))) [1..3] [4,5]
18:45:02 <lambdabot>   [[(4,1),(4,2),(4,3)],[(5,1),(5,2),(5,3)]]
18:45:04 <Peaker> adityam: one weird result is that the first list always begins with a 1, maybe its wrong after all?
18:45:42 <mikv> I am finishing my assignment on Haskell
18:45:53 <mikv> Can somebody help me to improve readability
18:46:02 <mikv> It works now :-)
18:46:07 <mofmog1> Considering that 99% of most software programs suck, i'm sort of surprised we even use computers at all
18:46:09 <adityam> Peaker: it looks correct to me. The first list should begin with 1, the second with 2, and the third with 3.
18:46:23 <dmwit> ?hpaste it, mikv! =)
18:46:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:46:48 <adityam> dolio: you are amazing...
18:46:53 <Saizan> can easily read from two streams at a time using Oleg's Iteratee?
18:47:01 <mikv> http://hpaste.org/12020
18:47:10 <ddarius> mofmog1: 99% of the programs implemented, you'll never even hear of
18:47:10 <mikv> This program creates Huffman tree
18:47:11 <Peaker> adityam: why does that make sense though? I'm confused by my own program! :)
18:47:41 <Peaker> > map.map.map head $ sequence . foldr (\xs optGroups -> [[x:opt | optGroup <- optGroups , opt <- optGroup] | x <- xs]) [[[]]] $ [[1,2,3],[4,5],[6,7]]
18:47:42 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
18:47:43 <dmwit> mikv: A popular program these last few days.  Are you in some course that's got this as an assignment or something?
18:47:47 <dolio> I do try.
18:47:55 <Peaker> > (map.map) head $ sequence . foldr (\xs optGroups -> [[x:opt | optGroup <- optGroups , opt <- optGroup] | x <- xs]) [[[]]] $ [[1,2,3],[4,5],[6,7]]
18:47:56 <mikv> dmwit, nope :-)
18:47:57 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1...
18:48:01 <dmwit> huh
18:48:14 <adityam> Peaker: Think of the inner most list as 3-tuples. Now the second inner most list is list of tuples, which has one element from the first list, and arbitrary elements rom the other two lists
18:48:16 <Peaker> > last $ (map.map) head $ sequence . foldr (\xs optGroups -> [[x:opt | optGroup <- optGroups , opt <- optGroup] | x <- xs]) [[[]]] $ [[1,2,3],[4,5],[6,7]]
18:48:17 <lambdabot>   [1,2,3]
18:48:25 <mikv> dmwit, other sutendts got different languages
18:48:25 <Peaker> > (map.map.map) head $ sequence . foldr (\xs optGroups -> [[x:opt | optGroup <- optGroups , opt <- optGroup] | x <- xs]) [[[]]] $ [[1,2,3],[4,5],[6,7]]
18:48:27 <lambdabot>       No instance for (Num [a])
18:48:27 <lambdabot>        arising from the literal `1' at <inter...
18:48:32 <dmwit> mikv: My first comment is that you've got parentheses all over the place that aren't necessary.
18:48:41 <mofmog1> Does anyone ever feel like haskell is the first true 2d programming language?
18:48:57 <ksf> 2d??!
18:49:00 <mofmog1> Because you have to move your eyes both backwards and forwards on the same line
18:49:13 <ddarius> mofmog1: No.
18:49:16 <mikv> dmwit, can you tell where i can remove parentheses?
18:49:22 <ksf> I do that with c-syntax, too.
18:49:26 <mikv> I saw only in hCons function :-/
18:49:31 <ddarius> and I'm not just answering that for myself
18:49:32 <dmwit> mikv: For example, Node Float (HHTree) (HHTree) = Node Float HHTree HHTree.
18:49:32 <mofmog1> ksf: yeah, but that's like proto 2d
18:49:38 <ksf> prolly because i actually nest function calls.
18:49:39 <Peaker> adityam: shows you that you don't have to fully understand the problem to solve it ;)
18:49:40 <mofmog1> well there's brainf*ck
18:49:42 <dmwit> mikv: Also, (fst x, snd x) === x
18:49:47 <Peaker> adityam: I just wrote down the output I wanted and worked from there
18:49:51 <ksf> there's befunge, too.
18:49:53 <ddarius> dmwit: Not quite true...
18:50:14 * ddarius goes off to watch a movie.
18:50:18 <dmwit> ddarius: Really?
18:50:18 <Peaker> > (map.map.map) head $ sequence . foldr (\xs optGroups -> [[x:opt | optGroup <- optGroups , opt <- optGroup] | x <- xs]) [[[]]] $ [[1,2,3],[4,5],[6,7]]
18:50:19 <lambdabot>       No instance for (Num [a])
18:50:19 <lambdabot>        arising from the literal `1' at <inter...
18:50:22 <Peaker> > (map.map) head $ sequence . foldr (\xs optGroups -> [[x:opt | optGroup <- optGroups , opt <- optGroup] | x <- xs]) [[[]]] $ [[1,2,3],[4,5],[6,7]]
18:50:24 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1...
18:50:53 <dmwit> ddarius: Even in the presence of laziness, it seems like it would get destructed in the same place in both cases.
18:50:54 <adityam> Peaker: understanding the problem fully was difficult, since I never managed to explain it properly :-D
18:50:57 <int-e> @type foldM
18:50:58 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
18:51:06 <mikv> dmwit, ok.
18:51:10 <mikv> dmwit, thanks
18:51:15 <dmwit> ?index comparing
18:51:16 <lambdabot> bzzt
18:51:29 <ksf> adityam, it's much easier to explain a program in haskell than in english.
18:51:36 <ddarius> (undefined, undefined) /= undefined
18:51:41 <ksf> or any other pl, fwiw.
18:51:52 <dmwit> mikv: comparing is defined in Data.Ord
18:51:53 <EvilTerran> ddarius, ((undefined, undefined) /= undefined) = undefined :P
18:52:04 <dmwit> ddarius: But (fst undefined, snd undefined) = undefined
18:52:09 <dmwit> or
18:52:10 <dmwit> ah
18:52:15 <mmorrow> x `seq` (fst x, snd x) === x
18:52:19 <Peaker> ksf: surely not _any_ other PL :)
18:52:35 <Peaker> ksf: as Haskell 2015 will probably be better than Haskell at expressing problems
18:52:46 <EvilTerran> ?src fst
18:52:46 <lambdabot> fst (x,_) =  x
18:52:47 <ddarius> EvilTerran: That could almost be a definition of /= if it wasn't for the reuse of the variable 'undefined'
18:52:50 <ksf> well, yes, it could get a bit confusing in malbolge.
18:53:05 <adityam> Peaker: but I always find it hard to read haskell.
18:53:05 <EvilTerran> O.o
18:53:40 <dmwit> mikv: createInitialLeavesList = map Leaf
18:53:48 <adityam> Peaker: Suppose I gave you the code that you just wrote, and asked what these three lines do, how long would it take you to figure that out :-)
18:53:54 <mikv> dmwit, stop
18:53:59 <Peaker> adityam: A) it has a steep learning curve  B) it has a _lot_ more density (combinations of very powerful operations)
18:54:02 <mikv> dmwit, can you explain this?
18:54:06 <ddarius> > let ((undefined, undefined') /= undefined'') = undefined in (1,2) /= 3
18:54:06 <lambdabot>   <no location info>: Parse error in pattern
18:54:07 <dmwit> mikv: Certainly!
18:54:09 <mikv> dmwit, ah!!! I got it
18:54:12 <dmwit> =)
18:54:16 <mikv> dmwit, thanks
18:54:20 <Peaker> adityam: I think 15 minutes or so
18:54:33 <mikv> we are moving thrpugh whole list
18:54:39 <mikv> :-)) and using Leaf to contruct
18:54:43 <ksf> http://www.eve-pirate.com/uploads/LearningCurve.jpg <--- also applies to haskell
18:54:45 <Peaker> adityam: in another PL it would probably take a lot more lines of code, that would also take 15 minutes or so to write, but would be long so hard to maintain
18:54:46 <mikv> Haskell rocks :)
18:54:55 <Peaker> adityam: s/write/read
18:55:14 <adityam> Peaker: It is the same with me... I write Haskell code occassionally, and them am dumbstruck at understanding what the code does
18:55:25 <dmwit> mikv: You might want to have a "createTree [] = Empty" line.
18:55:34 <Peaker> adityam: Also, my brain is slowly wrapping around the weird uses of the list monad, reader monad, etc. So even the points-free style is becoming readable
18:55:58 <Peaker> adityam: but one must remember to compare the time it takes to read the same amount of functionality, not the same amount of lines of code
18:56:31 <adityam> Peaker: Maybe getting used to Haskell takes much longer than other languages
18:56:34 <Peaker> adityam: another nice property of reverse engineering this code, is that you can just try it out :)
18:56:39 <dmwit> mikv: For speed, you might want to change the sortBy in createTree to an insert.
18:56:41 <mikv> dmwit, thanks..
18:57:01 <mikv> dmwit, no. I am concerning about readability, not speed :-)
18:57:02 <adityam> Peaker: yes, that is the good thing. One can try snippets and then glue them together
18:57:02 <dmwit> mikv: You'd have to switch the order of all the tuples for that to be convenient, but so far it looks like you want the Float part first all the time anyway.
18:57:08 <Peaker> adityam: learning how to map your solution to standard library functions and better: using just methods of standard instances may take some practice
18:57:22 <mikv> dmwit, ?
18:57:31 <dmwit> mikv: Now that I look at it, I might suggest switching the order all throughout anyway, so you can use just sort instead of sortBy (comparing snd) all the time.
18:57:41 <mikv> dmwit, HHTree was defined in assignment
18:57:42 <Peaker> adityam: I think it took me ~1 year to become really good at Python.  I have been using Haskell (much less intensively) for 6 months and I think that in 6 months, I'll be comparably good or better in Haskell than I was in Python
18:57:45 <dmwit> mikv: i.e. use (Float, Char) instead of (Char, Float)
18:57:50 <adityam> Peaker: Yes, but then you have to remember the standard library functions. I don't :-)
18:57:54 <mikv> dmwit, thanks. I understood
18:58:07 <dmwit> mikv: Ah, okay, never mind me, then.  I didn't realize it was given to you.
18:58:20 <dmwit> mikv: You told me this wasn't for a class. ;-)
18:58:26 <Peaker> adityam: the beauty of Haskell is that a tiny amount of library functions/instances do so much, because everything is generalized to standard typeclasses
18:58:41 <mikv> dmwit, nope. I told that i got this assignment in Haskell
18:58:46 <Peaker> adityam: the "sequence" used here works not only on lists, it can sequence any monad together
18:58:48 <dmwit> mikv: Other than that, it looks very nice -- you did a lot of good stuff here!
18:58:56 <adityam> Peaker: Yeah, but that is what makes it hard to remember (for a newbie)
18:58:57 <mikv> other students got it in other languages
18:59:00 <mikv> dmwit, thanks
18:59:20 <Peaker> adityam: in the case of the function/reader monad, it would build a function that passes its argument to all the functions its given, and then return a list of those function's results
18:59:42 <Peaker> adityam: its not hard to remember because there's only one way for it to add up, type-safely
18:59:48 <Peaker> adityam: at least, often there is
19:00:28 <adityam> Peaker: yes, but you need  to understand Monads first...I do understand the basic ones: List, Maybe, IO. but not at an abstract level
19:00:40 <Peaker> adityam: so its not a bunch of arbitrary functions, but a few generic type-classes which have very little freedom in how to instantiate for the standard type-classes.  You can't make a Monad instance of (r->) in that many interesting ways
19:00:47 <adityam> Peaker: that is why I get confused
19:00:57 <Peaker> adityam: I can try to explain monads on the abstract level
19:01:15 <adityam> Peaker: please do .....
19:01:24 <Peaker> adityam: I'll start by explaining Functor
19:01:33 <Peaker> adityam: that one is easy, you know Functor, right?
19:01:49 <adityam> Peaker: I know that there is something like a functor, but don't understand it
19:01:54 <Peaker> adityam: class Functor f where fmap :: (a -> b) -> f a -> f b
19:02:24 <adityam> Peaker: ok, this part I understand
19:02:30 <Peaker> adityam: Any type f can be a functor if: A) its a type constructor (its kind is *->*) and it has an implementation of "fmap" that can use a pure function (a->b) to convert  f a  to  f b
19:02:47 <Peaker> adityam: A is important and I think its not explained very well in most tutorials
19:03:01 <Peaker> adityam: do you understand why only *->* types can be Functors?
19:03:14 <adityam> Peaker: Nope
19:03:32 <orbitz> not really realte dto haskell, but what atributes make a language good at playing with strings?
19:03:41 <Peaker> adityam: note the type of fmap uses the "f" Functor type as "f a" and "f b", and not just "f". That means "f a" is a type, but just "f" is a type family
19:04:01 <adityam> Peaker: Ok, makes sense
19:04:08 <Peaker> adityam: For example, [Int] is a type, but [] is a type family.  [] is not a type of any value
19:04:29 <Peaker> adityam: so [Int] cannot be a Functor (its *) but [] can be (its *->*) in which case "f a" and "f b" would be [a] and [b]
19:04:32 <adityam> Peaker: Similar to Maybe a?
19:04:50 <Peaker> adityam: (Maybe a) is *, so its not a Functor. Maybe is *->* so it can be a Functor (and is indeed one)
19:05:13 <Peaker> adityam: note that there's an important difference between the type: Maybe, and the type (Maybe a).  One can be a Functor instance and one can't
19:05:20 <adityam> Peaker: Ok
19:05:54 <Peaker> adityam: now, only type constructors can be Functors, because a Functor, in a sense, has to "contain" or "result in" any arbitrary type chosen by the user of "fmap"
19:06:16 <adityam> Peaker: Ok, that makes sense
19:06:22 <Peaker> adityam: when I apply fmap, it is *me* who chooses the result type, the Functor type has to be able to result in (f b) where "b" is any type at all
19:06:52 <Peaker> adityam: now you can consider the functor as a "box" containing a value inside it
19:06:54 <adityam> Peaker: hmm
19:07:12 <dmwit> As a quick insertion: you can think of functors as a pair of maps; one maps types to types, and the other maps functions in the origin type to functions in the target type.
19:07:14 <Peaker> adityam: fmap lets me apply a function inside the box
19:07:49 <Peaker> adityam: consider now that you have a lot of boxes in the world. You can apply a pure function *inside* any one box.  But there's an important limitation here, can you see what it is?
19:07:55 <adityam> Peaker: Ok...this way, the type signature makes sense
19:08:54 <Peaker> adityam: Note that you cannot take the value "out of the box".  fmap keeps it inside..
19:09:06 <adityam> Peaker: yes...
19:09:22 <adityam> Peaker: So, I always remain in the same functor
19:09:23 <Peaker> adityam: The important limitation (besides being unable to "Extract" out of the box) is that if you have multiple boxes, you cannot combine these boxes in a single pure function
19:09:27 <Peaker> adityam: yep
19:09:43 <adityam> Peaker: OK
19:09:48 <Peaker> adityam: lets say you have two boxes of the same type, and you want to (+) between them
19:10:04 <Peaker> adityam: fmap takes 1 box and returns 1 box.  You can never take 2 boxes and combine them in any way
19:10:26 <adityam> Peaker: Ok
19:10:47 <Peaker> adityam: For those types that cannot combine their contents into a single computation, it makes sense NOT to have this operation
19:10:48 <hackage> Uploaded to hackage: LslPlus 0.1.1
19:11:00 <Peaker> adityam: but many many types CAN combine boxed values into a single computation
19:11:11 <Peaker> adityam: so for that, Functor is extended with a class called "Applicative"
19:11:19 <Peaker> @src Applicative
19:11:19 <lambdabot> class Functor f => Applicative f where
19:11:19 <lambdabot>     pure  :: a -> f a
19:11:19 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
19:11:23 <adityam> Peaker: Ah, so that is what an applicative is
19:11:41 <Peaker> adityam: Applicative is like a Functor, but it can let you use multiple boxes in a single computation. It also defines the notion of "sequencing"
19:11:59 <adityam> Peaker: How do I get f (a -> b)?
19:12:08 <Peaker> adityam: note that <*> unlike fmap takes *two* boxes, and returns one.  This is the key to "merging" multiple boxes via a single computation into one box
19:12:26 <Peaker> adityam: Typically, with partial application via fmap
19:12:45 <adityam> Peaker: So, if I wanted to add two functors/applicatives. How will I write it
19:12:51 <Peaker> adityam: for example, if you want to sum bx and by, which are both boxes, you can use:   fmap (+) bx -- and then what do you get?
19:13:22 <Peaker> adityam: fmap applies (+) to the x inside bx, and you get a boxed result that has what?
19:13:23 <adityam> Peaker: f (+b) so f (a ->b).
19:13:36 <Twey> So, `fmap (+) $ bx <*> by`?
19:13:53 <Peaker> Yep
19:13:55 <adityam> Peaker: so I'll do fmap (+) a <*> pure b to add two Applicatives
19:14:09 <Peaker> adityam: a and b are already boxes.  "pure" puts something in a box
19:14:15 <Peaker> adityam: you don't want to double-box b
19:14:37 <adityam> Peaker: Ok.. so not need to add pure.
19:14:45 <Peaker> Twey: oops, my bad, the $ is wrong there
19:14:49 <adityam> Peaker: But wait a minute ...
19:14:55 <Twey> Oh really?
19:15:01 <adityam> Peaker: fmap (+) a gives a functor.
19:15:03 <Peaker> Twey: its (fmap (+) bx) <*> by  not  fmap (+) (bx <*> by)
19:15:17 <Twey> Oh right
19:15:18 <Peaker> Twey: bx is not a boxed function, so you can't give it to <*>
19:15:18 <adityam> Peaker: <*> needs an applicative.
19:15:28 <Twey> I see
19:15:30 <Peaker> adityam: Applicative is a subclass of Functor
19:15:37 <Peaker> adityam: so if it is Applicative you also have fmap
19:16:05 <Twey> :t fmap
19:16:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:16:16 <Peaker> now, fmap is also called <$>, so instead of  fmap (+) bx <*> by, you can use:  (+) <$> bx <*> by
19:16:24 <adityam> Peaker: and if a typeclass is a member of both Functor and Applicative, Haskell will figure out when to use Functor and when to use Applicative?
19:16:31 <Peaker> note that <*> sequences left-to-right (first you get the "effect" of the left side, then of the right side
19:16:38 <adityam> Pearker: Or the label of the box does not matter
19:16:39 <Twey> Isn't that basically `fmap (fmap (+) bx) by`?
19:16:55 <Peaker> adityam: if a type is an instance of Applicative, it MUST also be an instance of Functor, so if you have <*> and pure, you always also have fmap
19:16:58 <adityam> Twey: No, fmap keeps you in the same functor
19:17:13 <Peaker> Twey: no, because fmap wants a pure function, not a boxed one
19:17:19 <Twey> Ah, yes.  I see it.
19:17:30 <Peaker> note liftA2
19:17:30 <Twey> <*> applies a boxed function to a boxed value.
19:17:33 <Twey> Got it.
19:17:34 <Peaker> @src liftA2
19:17:34 <lambdabot> liftA2 f a b = f <$> a <*> b
19:17:43 * Twey nods.
19:17:49 <adityam> Peaker: ok
19:18:12 <Twey> And <$>/fmap applies an unboxed function to a boxed value.
19:18:18 <Peaker> yep
19:18:35 <adityam> Peaker: What is <$>?
19:18:42 <Peaker> adityam: its just a name alias for fmap
19:18:47 <Peaker> @src (<$>)
19:18:48 <lambdabot> f <$> a = fmap f a
19:19:13 <Twey> (<$>) = fmap
19:19:14 <adityam> Peaker: Is this alias valid for Applicative or Fuctors?
19:19:15 <Twey> :(
19:19:38 <Twey> Is it valid to define <$> = `fmap`?
19:19:44 <Twey> It isn't, is it?
19:19:47 <dmwit> no
19:19:49 <dmwit> But
19:19:52 <Twey> > let <$> = `fmap` in 3
19:19:52 <Peaker> now, since Applicatives may "sequence" effects ( a <*> b ) results in a boxed result of applying the a func to b, but it ALSO results in the result box having both "effects" of a and b (a first, b second).  So you may very well want to create a boxed value without any "effects"
19:19:52 <lambdabot>   <no location info>: parse error on input `<$>'
19:19:54 <dmwit> (<$>) = fmap -- is fine
19:19:59 <Twey> Aye
19:20:00 <dmwit> > let (<$>) = fmap in 3
19:20:01 <lambdabot>   Add a type signature
19:20:01 <Peaker> adityam: the alias is valid for both (its just functor)
19:20:28 <Peaker> > let (<$>) = fmap in (*2) <$> [1,2,3]
19:20:29 <lambdabot>   [2,4,6]
19:21:02 <Peaker> so "pure" in Applicative lets you create a boxed value that has no "side effects"
19:21:25 <Peaker> where each Applicative instance defines what the exact meaning of that is..
19:21:38 <adityam> Peaker: What do you mean by box having both effects of a and b?
19:22:01 <Peaker> A boxed value (Applicative f => f a) is two things
19:22:11 <Peaker> A) The value itself, accessible via fmap and <*>
19:22:19 <Peaker> B) The box itself, which may represent side effects or other things
19:22:33 <adityam> OK
19:22:40 <Peaker> fmap only operates on the value, not affecting the box
19:22:48 <adityam> yes
19:22:50 <Peaker> but <*> sequences the effects of two boxes in the resulting box
19:23:02 <adityam> yes
19:23:32 <Peaker> now, Functor had a limitation of not being able to sequence/combine boxes, and Applicative "solved" that limitation
19:23:40 <Peaker> but it turns out Applicatives are also limited
19:23:55 <adityam> interesting
19:24:18 <Peaker> When you use Functor/Applicative, you can't use the contents of the boxes, to decide which boxes to sequence together
19:25:01 <Peaker> consider pure values to be "compile-time data", and boxed values to be "run-time data".  The entire structure of your applicative expression (a <$> b <*> c) may only be determined by compile-time data, not run-time data
19:25:54 <Peaker> now, for many types, this is an advantage! Some Applicative instance may want to be able to take the entire expression you built, and before anything runs through it, compile it to an efficient representation.  Since it does not depend on run-time data, that can be done
19:26:02 <adityam> So, if I want to get catmaybes, I cannot get it from Applicative?
19:26:13 <Peaker> @type catmaybes
19:26:14 <mikv> There is another question
19:26:14 <lambdabot> Not in scope: `catmaybes'
19:26:17 <Peaker> @type catMaybes
19:26:18 <lambdabot> forall a. [Maybe a] -> [a]
19:26:49 <Peaker> adityam: You can't implement catMaybes via Maybe's Functor, Applicative or even Monad instance
19:27:09 <Peaker> Functor, Applicative AND Monad all forbid you from "extracting" a value from a box
19:27:21 <adityam> Peaker: ok
19:27:32 <adityam> Peaker: Once in the box, you are stuck there
19:27:52 <Peaker> yeah, unless you write code that is specific to the type, and not general to functors, applicatives or monads
19:28:00 <Peaker> (as in the case of catMaybes)
19:28:05 <mikv> i have a function with following signature
19:28:11 <mikv> cCode :: Char -> HTree -> Maybe [Char]
19:28:16 <mikv> I need to construct
19:28:29 <mikv> function that applies this function to a string
19:28:33 <adityam> Peaker: OK
19:28:47 <mikv> i created function hCode :: [Char] -> HTree ->[Maybe [Char]], but not
19:28:53 <mikv> [Char] -> HTree ->Maybe [Char]
19:28:58 <mikv> as it should be
19:29:06 <dmwit> :t sequence
19:29:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:29:18 <dmwit> > sequence [Just "hey", Just "there"]
19:29:19 <lambdabot>   Just ["hey","there"]
19:29:24 <dmwit> :t catMaybes
19:29:25 <lambdabot> forall a. [Maybe a] -> [a]
19:29:30 <Peaker> To illustrate the limitation of Applicative, lets say you have a:  Applicative f => Map k (f a),  and you have an (Applicative f => f k), and you want to use the value::f k, to choose an applicative from the map, that you then apply with <*> to barg
19:29:40 <dmwit> > (sequence [Just "hey", Nothing], catMaybes [Just "hey", Nothing])
19:29:41 <lambdabot>   (Nothing,["hey"])
19:29:42 <mikv> >sequence [Just "aaa", Nothing, Just "bbb"]
19:29:54 <mikv> > sequence [Just "aaa", Nothing, Just "bbb"]
19:29:55 <lambdabot>   Nothing
19:29:58 <mikv> Wow
19:30:07 <mikv> dmwit, where can i read about this sequence?
19:30:13 <dmwit> ?src sequence
19:30:13 <lambdabot> sequence []     = return []
19:30:13 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:30:13 <lambdabot> --OR
19:30:13 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
19:30:15 <mikv> dmwit, it works like a magic for me :-)
19:30:17 <Peaker> Sequence could be Applicative
19:30:39 <Peaker> @hoogle (Applicative f) => [f a] -> f [a]
19:30:39 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
19:30:39 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:30:39 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
19:30:50 <Peaker> ah, sequenceA. Nice, generalized for non-lists too
19:31:31 <adityam> Peaker: So, the next step from Applicative is Traversable?
19:31:38 <Peaker> adityam: so the map is called mapBoxes, the boxed key is called bkey, and the boxed arg is called barg.  You want something like:  (map!(key from bkey)) <*> barg
19:31:53 <Peaker> adityam: nope, Traversable is something else - its a generalization instead of using lists
19:31:54 <dmwit> mikv: I guess the best place to read about it is in the All About Monads section on Maybe.
19:31:57 <dmwit> ?where all about monads
19:31:57 <lambdabot> I know nothing about all.
19:32:00 <dmwit> uh
19:32:03 <dmwit> ?go all about monads
19:32:07 <lambdabot> http://www.haskell.org/all_about_monads/
19:32:07 <lambdabot> Title: All About Monads
19:32:18 <mikv> dmwit, thanks again!
19:32:23 <Peaker> adityam: so try to implement:  (map!(key from bkey)) <*> barg
19:34:03 <Peaker> adityam: one attempt could be:  ((map!) <$> bkey)  -- but what happens then?
19:34:18 <adityam> Peaker: what is map! (with exclaimation)
19:34:26 <Peaker> adityam: (!) is a map lookup
19:34:34 <Peaker> adityam: map!k  looks up k in the map and returns the associated value
19:35:00 <adityam> Peaker: oh, I got confused with map
19:35:03 <Peaker> adityam: (map!) is partial application of (!) to map. A function which looks up a key in that map
19:35:10 <adityam> @src (map!)
19:35:10 <lambdabot> Source not found. That's something I cannot allow to happen.
19:35:22 <Peaker> adityam: you can't see the source of Data.Map.Map
19:35:23 <adityam> ?src (map!)
19:35:23 <lambdabot> Source not found.
19:35:29 <Peaker> @type Data.Map.!
19:35:30 <lambdabot> parse error on input `Data.Map.!'
19:35:34 <adityam> ?type (map!)
19:35:34 <lambdabot>     Couldn't match expected type `Array i e'
19:35:34 <lambdabot>            against inferred type `(a -> b) -> [a] -> [b]'
19:35:35 <lambdabot>     In the first argument of `(!)', namely `map'
19:35:35 <Peaker> @type Data.Map.(!)
19:35:36 <lambdabot> Couldn't find qualified module.
19:35:39 <orbitz> hot mama haskell is cool, the regex module can defien =~
19:35:39 <Peaker> @type (!)
19:35:41 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
19:35:52 <Peaker> @hoogle (!)
19:35:52 <lambdabot> keyword !
19:35:52 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
19:35:52 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
19:36:00 <Peaker> adityam: Data.Map (!) :: Ord k => Map k a -> k -> a
19:36:21 <Twey> In C, one can edit argv[0] to give one's process a more informative name in a process listing (e.g. specifying important arguments with which it was called)
19:36:26 <Twey> How would that be done in Haskell?
19:36:32 <Peaker> adityam: Map k a is a "map from keys of type k to values of type a".  You can use map!key  to get the value.  The keys must be ordinal (its a bsearch tree)
19:36:41 <adityam> Peaker: Ok, so now we want to get the key out  of a list
19:36:50 <Peaker> adityam: list?
19:36:59 <Peaker> adityam: we have a map, and an Applicative-boxed value
19:37:04 <Peaker> adityam: applicative-boxed key to that map
19:37:12 <adityam> Peaker: Sorry, still thinking about map
19:37:40 <adityam> Peaker: I mean the Prelude map and not Map
19:38:14 <jeffz> Twey: isn't that a platform specific thing?
19:38:34 <Peaker> adityam: We have a   map::(Data.Map.Map k (a->b)),   bkey::(Applicative f)=>f k   and   barg::(Applicative f)=>f a   and we want to apply the func in map to the arg in barg
19:38:37 <adityam> Peaker: so we can use map! <*> bkey
19:38:43 <Twey> Could be, jeffz
19:39:03 <Peaker> adityam: its (map!) <*> bkey, but that wouldn't work, because (map!) is a pure function, not a boxed function
19:39:16 <adityam> Peaker Map.Map <$> bkey <*> barg
19:39:39 <Peaker> adityam: you mean (map!) <$> bkey <*> barg ?
19:39:43 <jeffz> Twey: to answer your question, you'd probably use poke
19:39:46 <adityam> Peaker yes
19:39:56 <Peaker> adityam: that's very close, but lets look more closely on the type of  (map!) <$> bkey
19:40:05 <mikv> dmwit, can i ask for your help again?
19:40:09 <Peaker> adityam: what will map!key return ?
19:40:20 <dmwit> mikv: You can certainly ask. =)
19:40:26 <Twey> @index poke
19:40:26 <lambdabot> Foreign.Storable, Foreign
19:40:27 <mikv> dmwit, http://hpaste.org/12021
19:40:32 <adityam> Peaker: the value... ah,
19:40:35 <Twey> Interesting, thanks
19:40:37 <Peaker> adityam: what is the type of the value?
19:40:40 <mikv> dmwit, i can not write function hCode
19:41:00 <mikv> dmwit, which will convert stirng into Huffman code
19:41:01 <jeffz> @index getProgArgv
19:41:02 <lambdabot> bzzt
19:41:07 <adityam> Peaker: f a ?
19:41:18 <Peaker> adityam: Its a Data.Map.Map k (a->b)   meaning it maps keys of type k to values of type (a->b)
19:41:18 <mikv> dmwit, signature should be hCode :: [Char] -> HTree -> Maybe [Char]
19:41:34 <Peaker> adityam: which is my bad, because its not what I meant :)
19:41:47 <mikv> dmwit, my first try was hCode str tree = map (\x -> cCode x tree) str
19:41:51 <adityam> Peaker: Map.Map k a -> k -> a
19:42:00 <Peaker> adityam: I meant a map Applicative f => Data.Map.Map k (f (a->b))
19:42:02 <Peaker> adityam: my bad
19:42:04 <jeffz> Twey: in ghc getArgs is defined as using peek on a foreign call to getProgArgv, but doesn't look like it's exported
19:42:06 <adityam> Peaker: bkey :: f k
19:42:17 <mikv> dmwit, i added sequence, but i can not concatenate  [Maybe [Char]] into [Char]
19:42:38 <mikv> i guess i can write new function for this concatenation
19:42:52 <Peaker> adityam: yes, (map!) <$> bkey <*> barg  works, if the values in the map are pure functions
19:42:53 <dmwit> :t catMaybes
19:42:54 <lambdabot> forall a. [Maybe a] -> [a]
19:42:58 <Peaker> adityam: but what if the values in the map are not pure?
19:43:17 <Peaker> adityam: What if the values in the map are: Applicative f => f (a->b)
19:43:27 <Peaker> adityam: (same f as bkey and barg, of course)
19:43:44 <adityam> Peaker: So, we have a Map of functions.
19:43:56 <Peaker> adityam: we have a map of _boxed_ functions
19:43:59 <adityam> Peaker: We will get f (f (a->))
19:44:06 <adityam> Peaker:I mean We will get f (f (a->b))
19:44:10 <Peaker> adityam: yes, after fmap we get double-boxed, exactly
19:44:11 <Twey> liftA (map!) bkey barg
19:44:23 <Peaker> Twey: that works if the map contains pure functions
19:44:25 <Twey> Er, liftA2
19:44:36 <Peaker> Twey: but not if the result of (map!key)  is a boxed function
19:44:47 <mikv> dmwit, thanks. I will try catMaybes
19:44:52 <adityam> Peaker: So, we want something to remove a box, or better, not add a extra box
19:44:54 <mikv> hmm.. is it from Data.Maybe
19:44:56 <Peaker> because fmap (map!) bkey    ->   fmap will re-box the boxed result
19:44:58 <mikv> ahh. It is
19:45:01 <Twey> Peaker: liftA2 doesn't?
19:45:07 <Twey> @src liftA2
19:45:07 <lambdabot> liftA2 f a b = f <$> a <*> b
19:45:21 <Twey> But... doesn't <*> take a boxed value?
19:45:25 <Peaker> Twey: liftA2 depends on f being a pure function
19:45:36 <Peaker> Twey: yes, remember that <$> returns a boxed value
19:45:43 <Twey> Boxed func to boxed arg to pure func?
19:45:49 <Peaker> Twey: so if f returns a boxed value and fmap also returns a boxed value... you get a doubly-boxed vlaue
19:45:57 <Twey> Or was it to boxed?  Oh dear...
19:45:59 <Peaker> @type liftA2
19:46:00 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
19:46:15 <Peaker> liftA2 takes a _pure_ func of 2 pure args, and returns a boxed func of 2 boxed args
19:46:43 <adityam> And what we need is (f (a-> b->c)) -> f a -> f b -> f c ?
19:46:48 <Peaker> if you have a function that returns a box, rather than a pure value, and you use it with fmap (as liftA2 does) you get a doubly boxed function
19:46:49 <Twey> Aha
19:46:58 <Twey> :t <$>
19:46:59 <lambdabot> parse error on input `<$>'
19:47:04 <Twey> :t (<$>)
19:47:04 <Peaker> :t (<$>)
19:47:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:47:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:47:12 <Twey> Right.  Got it.  Sorry :-P
19:47:34 <Twey> But <*> is boxed?
19:47:37 <Peaker> so Applicative does not let us "choose" a box based on "runtime" data
19:47:42 <Twey> :t (<*>)
19:47:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:47:49 <Peaker> <*> is between a _singly_ boxed func and a _singly_ boxed arg
19:48:03 <Twey> So precisely what we want?
19:48:05 <Peaker> if your fmap resulted in a doubly boxed func, you can't really use <*> on it
19:48:16 <Twey> Ah, true
19:48:18 <Peaker> Because instead of a boxed func, you have a boxed box
19:48:49 <Peaker> well, if you want to look at "runtime" data (contents of box) to decide which box to use, then your function returns a box. When you apply it with fmap, you get double-boxes
19:48:50 <adityam> So we need a way to apply boxed functions
19:48:59 <Peaker> adityam: that's what <*> is
19:49:11 <Peaker> adityam: you said it very accurately before
19:49:33 <Peaker> <adityam> Peaker: So, we want something to remove a box, or better, not add a extra box
19:49:39 <Peaker> This is exactly what a Monad does
19:49:46 <Peaker> A Monad is also a box, like Functor and Applicative
19:49:57 <adityam> Peaker: Ok
19:50:04 <Peaker> but it allows converting a double box to a single box
19:50:06 <Peaker> @type join
19:50:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:50:21 <Peaker> or better, as you said, not add the extra box in the first place:
19:50:25 <Peaker> @type fmap
19:50:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:50:27 <Peaker> @type flip (>>=)
19:50:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
19:50:45 <Peaker> so >>= is like fmap that doesn't add an extra box to the result of the function
19:50:54 <mmorrow> @src (>>=) Cont
19:50:54 <lambdabot> Source not found. It can only be attributed to human error.
19:51:00 <mmorrow> @src Cont (>>=)
19:51:00 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
19:51:06 <Peaker> it is enough to implement join on top of Applicative,  OR  (>>=)   and you get a Monad.  Either will do
19:51:18 <adityam> :t join
19:51:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:51:43 <Peaker> so:  Functor -> Boxes that cannot be combined.   Applicative -> Boxes that can be combined, but not selected at "runtime".   Monad -> Boxes that can be combined and selected by runtime data, but cannot be extracted.
19:51:55 <adityam> Peaker: join == concat for list monad?
19:52:01 <Peaker> adityam: yes
19:52:05 <Peaker> @src [] join
19:52:06 <lambdabot> Source not found. My brain just exploded
19:52:10 <Peaker> oops, join has no src
19:52:14 <Peaker> (per instance)
19:52:15 <Peaker> @src join
19:52:15 <lambdabot> join x =  x >>= id
19:52:16 <mmorrow> @type flip ((join .) . fmap)
19:52:16 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
19:52:30 <Peaker> In Haskell, Monads don't subclass Applicative like they should
19:52:40 <Twey> Peaker: What do you mean by 'runtime' and why are you quoting it?
19:52:46 <Twey> That's not actually selected at runtime, is it?
19:52:51 <int-e> join xs =  xs >>= id = concatMap id xs = conat xs
19:53:04 <Peaker> Twey: I defined it above:  compile-time = pure values,  run-time = content of boxes
19:53:12 <adityam> :t id
19:53:13 <lambdabot> forall a. a -> a
19:53:19 <Twey> Oh, right
19:53:23 <Peaker> Twey: It makes sense for certain kinds of boxes where you have the content of the box only "later"
19:53:35 <Peaker> Twey: and you might want to know which boxes are being used before the whole thing is "run"
19:53:50 <mmorrow> @src callCC
19:53:50 <lambdabot> Source not found. My mind is going. I can feel it.
19:54:02 <Peaker> Twey: Applicative lets you, as a framework, know exactly which boxes are being used together, without having to run anything
19:54:08 <mmorrow> @src Cont mfix
19:54:08 <lambdabot> Source not found.
19:54:18 <mmorrow> @src ContT mfix
19:54:18 <lambdabot> Source not found.
19:54:20 <mmorrow> grr
19:54:25 <Peaker> Twey: Monad forces you, as a framework, to "run" the monadic computation and give the results to the user functions, before you know which boxes are going to be used
19:54:34 <mmorrow> @src MonadFix
19:54:34 <lambdabot> class (Monad m) => MonadFix m where
19:54:34 <lambdabot>     mfix :: (a -> m a) -> m a
19:54:34 <int-e> @src Cont callCC
19:54:34 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
19:54:39 <mmorrow> oh nice
19:55:02 <Peaker> Twey, adityam: So you cannot look at a monad and know what "boxes" are going to be involved (what side effects, etc) until you run it
19:55:17 <Peaker> Twey, adityam: But you can definitely look at an Applicative value and say exactly what side effects its going to have, before running any of it
19:55:19 <Twey> I see
19:55:28 <adityam> Peaker: Ok
19:56:29 <Peaker> There are also Arrows, which are probably somewhere between Applicative and Monad
19:56:35 <mmorrow> Peaker: well, there can only be side effect if a monad happens to be one into which IO can be lifted
19:56:39 <Peaker> but they are different-kinded so its hard to compare
19:56:44 <adityam> Peaker: So, logically monad should have been an instance of an Applicative
19:56:51 <Peaker> mmorrow: I meant a broader meaning of "side effect"
19:56:55 <Twey> Why isn't it?
19:56:59 <Peaker> mmorrow: for example, which grammar its going to parse
19:57:01 <mmorrow> Peaker: how so?
19:57:12 <Peaker> mmorrow: whatever information is in the box itself, and not the contained value
19:57:32 <Peaker> mmorrow: side effect may be a bad choice of words, but I am not sure if there's a better word for it
19:57:51 <mmorrow> Peaker: oh, so you mean that since monad (>>=) is really doing cps, later "actions" can be based on earlier actions
19:57:52 <Peaker> adityam: yes, it should have been
19:58:08 <Peaker> Twey, adityam: I think a Monad is not Applicative because Monad predates Applicative's existence as a type-class
19:58:15 <Peaker> (historic accident)
19:58:31 <Peaker> mmorrow: yep
19:58:46 <Peaker> mmorrow: so you cannot analyze, ahead of time, what computations are going to be used
19:59:18 <mmorrow> true. which is analogous to:
19:59:22 <Twey> Peaker: Aha
19:59:25 <Peaker> mmorrow: with applicative, the choice of boxes does not depend on any box contents, so you know it before you run anything
19:59:30 <Twey> So shouldn't we just... add it in?  :-P
19:59:34 <Twey> Will this happen for Haskell'?
19:59:58 <Peaker> Twey: Some support it, but it might break code that did not make an instance of Applicative (correct code should have that instance)
20:00:22 <mmorrow> , let parseFile ('c':'s':'v':rest) = CSV (goCsv rest) ; parseFile ('a':'s':'d':'f':rest) = ASDF (goAsdf rest)
20:00:24 <lunabot>  luna: parse error on input `)'
20:01:12 <Peaker> mmorrow: that is also true of arrows - which are more expressive than applicative, but less than monads, and you can still know exactly which arrow "effects" are in a computation before running any of it
20:01:45 <mmorrow> Peaker: i'm not so sure about that
20:01:47 <adityam> Peaker: So, for most cases we do not need monads. Applicative and Functor would suffice.
20:01:49 <Peaker> mmorrow: I think the paper about parser arrows explains how they make use of this to compile parser arrows into efficient FSM's
20:02:04 <Twey> Peaker: Should this be an issue?
20:02:09 <sclv> adityam: not so sure about that
20:02:10 <dmwit> FSM's = flying spaghetti monsters
20:02:17 <Peaker> Twey: should what be an issue?
20:02:20 <mmorrow> Peaker: you can do exactly what any monad does by using explicit cps
20:02:30 <Peaker> adityam: I think most cases do need the expressiveness of monads
20:02:43 <Peaker> mmorrow: with arrows? how?
20:02:52 <mmorrow> i'm talking about with simple functions
20:03:06 <Peaker> mmorrow: via arr?
20:03:25 <dmwit> mmorrow: I think at best you can say that ArrowApply and Monad are equivalent; Arrow and Monad, not so much.
20:03:28 <mmorrow> i'm not even talking about arrows anymore :)
20:03:32 <Twey> Peaker: Breaking compatibility
20:04:00 <Twey> It's true, but explicit CPS is nasty :-P
20:04:07 <sclv> also you can turn every applicative into an arrow, but only by wrapping it, I think, just like monads only turn into arrows via wrapping.
20:04:10 <adityam> What is CPS?
20:04:17 <mmorrow> continuation passing style
20:04:23 <Twey> adityam: Continuation-Passing Style
20:04:31 <sclv> s/every applicative/certain applicatives/
20:04:39 <Peaker> mmorrow: you can only "see" the value inside an arrow computation, OR applicative/functor  via fmap, and then your result gets "boxed". So if you try to use cps to choose a different box for a different effect, you get double-boxed.  A boxed "effect" will not happen
20:04:40 <Twey> Where you pass 'what the function should do next' as an argument to the function
20:04:43 <dmwit> sclv: I think you were fine with "every applicative".
20:04:44 <Twey> Rather than using return values.
20:04:44 <adityam> ok what is continuation passing style :-)
20:04:54 <sclv> oh wait, yes I was.
20:05:04 <mmorrow> Peaker: with cps there are no boxes
20:05:06 <Peaker> sclv: so there are no applicatives that are not arrows?
20:05:15 <grom358> how can I convert this http://pastebin.com/d29efcde2 into haskell? I get stuck on trying to deal with the while loop
20:05:16 <sclv> nope. there was a paper on this recently.
20:05:22 <Peaker> sclv: I think Applicative is more general (i.e less expressive) than arrow so such a wrapper should not be possible
20:05:28 <Peaker> sclv: but maybe that's wrong
20:05:30 <mmorrow> readFileCPS file k = k (unsafePerformIO (readFile file))
20:05:36 <dmwit> Peaker: http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
20:05:43 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous, http://tinyurl.com/6evopg
20:05:49 <dmwit> Peaker: He uses "idiom" for "applicative", but it should be easy to map mentally.
20:05:58 <Twey> adityam: E.G. rather than `add a b = a + b; main = print (add 3 5)`, you do `add a b cont = cont (a + b); main = add 3 5 print
20:05:58 <Twey> `
20:06:16 <Peaker> mmorrow: then that's different.  Functor/Applicative/Arrows let you combine boxes in a way that cannot depend on boxed values at all, which is useful for frameworks that can't handle this dependency
20:06:22 <dmwit> Peaker: It turns out the folk wisdom was incorrect about the ordering of Arrow, Applicative, and Monad.
20:06:23 <Twey> It's very useful, but very ugly (which is why we like to hide it away with the Cont monad and things :-P)
20:06:52 <roconnor> @type until
20:06:53 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
20:06:57 <Peaker> dmwit: Does it say that there is something like the kleisli arrow for applicatives?
20:06:57 <roconnor> @type while
20:06:58 <lambdabot> Not in scope: `while'
20:07:03 <sclv> dmwit: actually though I had always heard folk wisdom with the correct ordering...
20:07:06 <adityam> Twey: I agree that it is ugly
20:07:08 <mmorrow> readFileCPS "/etc/passwd" $ \dat -> linesCPS dat $ \xs -> filterCPS ("mmorrow"`isPrefixOf`) $ \ys -> id ys
20:07:19 <dolio> Peaker: a ~> b = f (a -> b)
20:07:25 <dmwit> Peaker: I believe so. =)
20:07:45 <Peaker> dolio: then why do we need the kleisli arrow? Why not use this applicative arrow for monads too?
20:08:03 <dolio> It's not the same?
20:08:16 <roconnor> @type until . not
20:08:17 <lambdabot>     Couldn't match expected type `a -> Bool'
20:08:17 <lambdabot>            against inferred type `Bool'
20:08:17 <lambdabot>     Probable cause: `not' is applied to too many arguments
20:08:17 <Peaker> the kleisli arrow is:  Monad m => a -> m b
20:08:22 <sclv> ?ty (>=>)
20:08:23 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
20:08:31 <Peaker> its not the same as Applicative f => f (a -> b)
20:08:49 <bh1> fg
20:08:51 <sclv> I don't think you can write >=> with just ap and return...
20:08:54 <bh1> oops -- you're not my terminal.
20:08:56 <roconnor> grom358: you can use until and not to do a while loop
20:09:01 <Peaker> @type (>=>)
20:09:02 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
20:09:25 <sclv> intuitively you need jon.
20:09:29 <sclv> s/jon/join/
20:09:30 <Peaker> yeah, you can't
20:09:41 <dolio> arr = pure, f >>> g = (.) <$> g <*> f, first = fmap (\f (a, b) -> (f a, b))
20:09:49 <dolio> I doubt that's the same as the kleisli arrow.
20:09:55 <Peaker> because (b -> m c) can choose any (m c) it wants for the "b", which is a boxed value, and applicatives can't do that
20:09:58 <roconnor> grom358: but you might find it easier to simply write your own recrusive function
20:10:25 <dolio> Even if f is a monad.
20:10:52 <Peaker> dolio: that seems to work - and it should work for monads too, then, of course, which makes kleisli superflous
20:10:53 <sclv> recrusive functions are of type Mission Impossible -> Succ (Mission Impossible)
20:10:59 <Peaker> superfluous, that is
20:11:00 <sclv> sorry.
20:11:15 <dolio> The operations aren't the same.
20:11:24 <dolio> How is it superfluous?
20:11:36 <mmorrow> sclv: lol
20:11:41 <grom358> roconnor: yeah I keep thinking imperatively. Not sure how to turn it into recursive function
20:11:45 <Peaker> dolio: what semantic difference is there between that and kleisli?
20:12:04 <Peaker> grom358: recursions suck, its better to turn it into a fold :)
20:12:16 <Peaker> grom358: or other higher-order functions
20:12:20 <dolio> I haven't thought about it, but they obviously aren't the same operations. They don't even have the same types.
20:12:44 <Peaker> dolio: what do you mean?  The types of the operations come from arrow, so they are the same
20:13:05 <Saizan> going from applicatives to arrows is going the wrong direction, you can go Monad -Kleisli-> Arrow -Reader-> Applicative, and you get the same Applicative as using ap from the Monad
20:13:22 <dolio> If you unwrap them, then for the Kleisli arrow, (>>>) :: (a -> m b) -> (b -> m c) -> (a -> m c)
20:13:41 <dolio> The applicative one has type: f (a -> b) -> f (b -> c) -> f (a -> c)
20:14:15 * Twey likes recursions.
20:14:43 <dolio> arr :: (a -> b) -> (a -> m b) vs (a -> b) -> f (a -> b)
20:15:19 <Peaker> dolio: yeah, but if you use just the arrow operations on the kleisli/applicative arrows, you probably get the exact same semantics
20:15:22 <dolio> first :: (a -> m b) -> (a, c) -> m (b, c) vs. f (a -> b) -> f ((a,c) -> (b,c))
20:15:38 <Peaker> dolio: constructing a kleisli arrow, vs constructing an  f (a->b)  is different, but superficially so
20:15:57 <dolio> There are also potentially primitive Kleisli arrows :: a -> m b.
20:16:01 <dolio> Those are not applicative arrows.
20:16:03 <Peaker> dolio: you could easily abstract away the differences between that and kleisli
20:16:10 <Peaker> dolio: why not?
20:16:24 <dolio> Because applicative arrows have type f (a -> b) which is not a -> m b.
20:16:37 <Peaker> dolio: yeah, but they are isomorphic, I think
20:16:42 <dolio> No.
20:16:47 <Peaker> dolio: why not?
20:17:24 <dolio> tails is a kleisli arrow for the list monad :: [a] -> [[a]]
20:17:28 <dolio> It is not an applicative arrow.
20:17:59 <Saizan> Peaker: \x -> f x >>= g is not the same as (.) <$> f <*> g
20:18:00 <Peaker> @src Kleisli
20:18:00 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:18:26 <dolio> print is a Kleisli arrow.
20:18:56 <Peaker> Saizan: what difference can you measure, when just using the arrow interface?
20:19:08 <Peaker> Saizan: (and not looking at the type itself)
20:19:19 <Saizan> in the first case g can use the result of f to construct the side-effects, while in the second the side-effects must be known before any results are computed
20:19:57 <mmorrow> and, using (>>=) is /the same thing/ as converting every function passed to it to one that take a continuation and then just doing explicit cps
20:20:26 <mmorrow> no matter which monad the (>>=) happens to be from
20:20:41 <Peaker> Saizan: ah, but if you restrict the (a -> m b) values to ones that choose the same effect regardless of arg, then you do get equivalence?
20:21:16 <Peaker> mmorrow: except the magic monads, you mean?
20:21:27 <mmorrow> unsafePerformIO :)
20:21:37 <mmorrow> is safe if your whole prog is in cps
20:21:47 * Peaker has to go to sleep
20:21:54 <Peaker> good night!
20:22:00 <mmorrow> night
20:22:11 <adityam> Peaker: good night, and thanks for the explanation
20:24:22 <roconnor> grom358: let trial n = let (m,result) = foldr (\check (m,result) -> if (m`mod`check == 0) then ((m`div`check),check) else (m,result)) (n,0) $ takeWhile (\check -> check^2 <= n) [2..] in if (m/=1) then m else result
20:24:55 <dolio> You know, I wonder if CPS-ing IO/ST instead of using unboxed tuples would retain the same performance.
20:25:34 <dolio> And would potentially eliminate an optimization problem area I've had...
20:25:38 <mmorrow> dolio: that'd be interesting to find out
20:25:42 <roconnor> grom358: although I'm not sure what this function is supposed to do.  Find the smallest prime divisor greater than the square root of n?
20:27:46 <mmorrow> dolio: heh, i just found out that unboxed 1-tuples exists
20:27:50 <mmorrow> (# 42 #)
20:28:06 <dolio> Isn't that identical to a value?
20:28:26 <mmorrow> i don't think so, since unboxed tuples force their contents
20:28:46 <mmorrow> and unboxed tuples are passed to functions in a special way
20:28:52 <mmorrow> (i can't remember the particulars)
20:28:53 <dolio> They do?
20:28:59 <Saizan> do they? IO doesn't add extra strictness
20:29:12 <dolio> Unboxed tuples can't be passed to functions, only returned.
20:29:19 <dolio> In GHC, at least.
20:29:21 <mmorrow> yeah, lemme find this benchmark i did of the mtl State monad and one that uses unboxed tuples internally
20:29:34 <mmorrow> (the unboxed tuple one was /significantly/ faster
20:29:36 <mmorrow> )
20:30:22 <mmorrow> dolio: oh yeah you're right. i meant their returned specially ("in registers", but i'm not sure the exact meaning of that)
20:30:24 <Saizan> it's faster since it's a struct of two pointers, rather than a pointer to a function that returns a struct with two pointers :)
20:32:28 <dolio> mmorrow: I guess an unboxed single might hint the code generator better.
20:32:56 <dolio> But other than that, I can't think of any way it'd be different from directly returning a value.
20:34:55 <dolio> I mean, a single (Int) would be an extra layer of indirection around an Int.
20:35:10 <dolio> (# Int #) would be removing that extra layer of indirection, but that's just Int.
20:36:52 <mmorrow> dolio:
20:36:56 <mmorrow> crap
20:37:15 <mmorrow> http://hpaste.org/12022
20:38:11 <mmorrow> both of those times in the comments are a lot huger than the ones i just got running those two right now. maybe i used ;arger values passed to fib or something. either way though, the unboxed tuple one is faster
20:39:04 <dons> looks like a fast state monad, mmorrow
20:39:24 <mmorrow> totally
20:39:32 * mmorrow snaked that one from ghc ;)
20:39:39 <dons> IO uses data RealWorld; of course.
20:39:52 <dolio> mmorrow: Yeah, that result isn't too surprising.
20:40:12 <Saizan> mmorrow: did you compile mtl with -O2?
20:40:15 <mmorrow> http://darcs.haskell.org/ghc/compiler/utils/State.hs
20:40:27 <dolio> mmorrow: How does CPS state match up?
20:40:35 <mmorrow> Saizan: yeah, in addition to it being in the {-$ OPTIONS_GHC ...
20:40:38 <mmorrow> s/$/#/
20:40:41 <mmorrow> s/\$/#/
20:41:17 <Saizan> mmorrow: the mtl package i meant
20:41:30 <mmorrow> Saizan: oh, i'm not sure
20:41:46 <mmorrow> dolio: i dunno
20:42:47 <grom358> roconnor: it finds the largest prime factor of a number
20:43:54 <mmorrow> dolio: what do you think the code for a CPS version that's appropriate for a good comparison with those other two would look like
20:43:55 <mmorrow> ?
20:44:49 <roconnor> grom358: oops, my implemenation is broken.
20:45:29 <dolio> mmorrow: newtype State s a = State { unState :: forall r. s -> (s -> a -> r) -> r }
20:45:41 * roconnor decides writing a fold is too hard for this.
20:46:01 <dolio> return a = State $ \s k -> k s a
20:46:21 <mmorrow> dolio: ahhh, i gotcha. i wonder..
20:46:42 * mmorrow eats food, puts StateCPS on todo list
20:47:14 <dolio> m >>= f = State $ \s k -> unState m s (\s' a -> unState (f a) s' k) -- think that's right.
20:47:34 <dolio> runState m = unState m (,)
20:48:53 <roconnor> StateCPS is gonna be so fast.
20:49:07 <dolio> It'll blow your socks off.
20:49:44 <kenmcfa> hi
20:49:49 <shapr> hiya!
20:50:04 <bh1> hi
20:50:04 * shapr boings cheerfully
20:50:16 <shapr> Hiya Brendan, how's code?
20:50:29 <bh1> could be better
20:50:35 <shapr> bh1: Hey, you're actually close to Boston, do you hang out with other Haskellers?
20:50:38 <kenmcfa> I need some help with haskell, can someone here help me please?
20:50:45 <shapr> kenmcfa: What help do you need?
20:51:09 <kenmcfa> I don't quite follow why my copy function won't compile
20:51:13 <kenmcfa> copy :: Int -> Command -> Command
20:51:13 <kenmcfa> copy n c |n>0 = c :#: ((copy n-1 c))
20:51:13 <kenmcfa> 	|otherwise = c
20:51:24 <kenmcfa> I think that's roughly right
20:51:43 <kenmcfa> It should give n copies of command c, all stuck together with :#: s
20:51:49 <dolio> copy n-1 c = (copy n) - (1 c)
20:51:49 <shapr> bh1: Well, close to Boston in the sense that Sweden and Oregon aren't...
20:51:57 <dmwit> copy (n-1) c
20:52:11 <bh1> I'm at Brown. A few of us use haskell
20:52:14 <shapr> Oh cool!
20:52:17 <dmwit> copy n c = foldr1 (:#:) . replicate n $ c
20:52:24 <shapr> Um, Krishnamurthi is there, yeah?
20:52:32 <dmwit> or...
20:52:42 <bh1> yeah
20:52:53 <dmwit> copy n c = foldr (:#:) c $ replicate (n-1) c -- better
20:52:53 <shapr> Cool, Krishnamurthi does nifty stuff.
20:53:05 <shapr> What does :#: do?
20:53:07 <bh1> I finally got around to taking his class. I did some security work with him a few years back
20:53:10 <shapr> @index (:#:)
20:53:10 <lambdabot> bzzt
20:53:12 <shapr> bah
20:53:24 <dmwit> shapr: Presumably he defined it as part of his data structure.
20:53:30 <shapr> bh1: Oh neat, what sort of security work? Anything you don't want to talk about in a publically logged channel?
20:53:41 <kenmcfa> thanks
20:53:46 <bh1> shapr: nothing that would be of general interest
20:53:55 <shapr> bh1: This isn't a general interest channel :-)
20:54:03 <dmwit> copy n c = iterate (:#:) c !! n
20:54:07 <kenmcfa> this is part of a tutorial, so I don't rightly know what :#: is
20:54:10 <shapr> Oh
20:54:28 <dmwit> I like that last one best so far.
20:54:51 <kenmcfa> it's for some sort of turtle graphics system
20:54:59 <bh1> lately I've been working with a friend on couchDB bindings for haskell
20:55:00 <kenmcfa> data Command = Go Distance
20:55:00 <kenmcfa>             | Turn Angle
20:55:00 <kenmcfa>             | Sit
20:55:00 <kenmcfa>             | Command :#: Command
20:55:41 <bh1> at the moment I'm trying to use template haskell to implement automagic JSON serialization
20:55:52 <shapr> hmm, I think someone may have done that.
20:56:08 <bh1> rJSON?
20:56:33 <shapr> Yeah, I think that was it.
20:56:48 <kenmcfa> ok, the copy n c = foldr (:#:) c $ replicate (n-1) c works pretty well
20:56:53 <shapr> Obviously you've already seen it.
20:57:03 <kenmcfa> thanks for that, what does the $ mean?
20:57:07 <bh1> the description mentions reflection, so it sounds like something at runtime. Let me take a look at the source.
20:57:31 <bh1> '$' is a right associative operator
20:58:15 <shapr> kenmcfa: a b c means a(b,c) but a $ b c means a(b(c))
20:58:28 <shapr> I dunno if that was particularly clear.
20:58:43 <grom358> roconnor: this python version is a bit clear http://pastebin.com/d735587da
20:58:43 <bh1> kenmcfa: it stops your code from looking like scheme.
20:58:44 <kenmcfa> I see that, yeah
20:58:55 <kenmcfa> thanks for the help everyone
20:59:04 <kenmcfa> bye
20:59:11 <shapr> bye ken! Come back sooon.
20:59:12 <shapr> bah
20:59:17 <shapr> humbug
20:59:25 <shapr> Yay, I passed my Turing Test today!
21:00:02 <grom358> clearer*
21:00:03 <glguy> http://failblog.files.wordpress.com/2008/10/fail-owned-london-bus-break-glass-fail.jpg
21:00:05 <lambdabot> http://tinyurl.com/49bca5
21:00:06 <glguy> <<loop>>
21:00:32 <shapr> hah
21:02:15 <Twey> > a 2 where a 0 = 0; a n = a (n - 1)
21:02:16 <lambdabot>   0
21:02:24 <Twey> Oh, it's not any loop.
21:05:04 <bh1> shapr: you seem to know things. Have you ever seen this error: `method' is not a (visible) method of class `Class'? google didn't turn up much
21:06:02 <shapr> Er, no.
21:06:09 <shapr> But what's the context?
21:06:21 <Riastradh> Did you try to instantiate a type class with an implementation of a method not specified in the type class's definition?
21:06:24 <shapr> bh1: And yes, I do know some things.
21:07:35 <Riastradh> (Either not specified in the type class's definition, or not listed among the exports of the module defining the type class.)
21:07:59 <dmwit> > let x = x in x -- should be Exception: <<loop>>, but something will probably break
21:08:14 <lambdabot>   thread killed
21:08:44 <Saizan> dmwit: mueval doesn't compile
21:08:58 <bh1> I assume you can't tell lambdabot to kill -9 itself.
21:09:14 <Riastradh> bh1, by the way, my question was addressed to you.
21:09:28 <dmwit> Saizan: ah
21:09:59 <bh1> Raistradh, it is specified in the class def.
21:10:33 <Riastradh> bh1, is it listed among the module's exports?
21:10:43 <bh1> this is all within one module
21:10:46 <Riastradh> Are all of the above uses of the name spelt correctly?
21:10:47 <hackage> Uploaded to hackage: colour 1.1.0
21:11:14 <bh1> Riastradh: ah! doh
21:11:25 * bh1 puts on the dunce cap
21:16:25 <jekor> Is there a way to pattern match on a nested constructor? http://hpaste.org/12023
21:19:11 <ksf> jekor, i think you meant to write data Link = Link LinkType String String
21:19:46 <jekor> Ah. Thanks.
21:19:47 <ksf> you're binding "LinkType" as a constructor there, not referencing your previously defined type.
21:21:07 <jekor> OK, I changed that, but I'm still getting "Parse error in pattern" on the double parens.
21:21:43 <jekor> Oh...
21:22:00 <jekor> Gotta add the constructor, I guess ;)
21:22:44 <jekor> Cool. Works. Thanks!
21:24:52 <grom358> is there term to describe this function (instead of me going it trail) let trail n d = if (n `mod` d == 0) then (trail (n `div` d) d) else n
21:25:02 <grom358> calling*
21:26:04 <dmwit> > until (\n -> n `mod` 3 == 0) (`div` 3) (4*27)
21:26:05 <lambdabot>   108
21:26:10 <dmwit> err
21:26:12 <dmwit> ah
21:26:17 <dmwit> > until (\n -> n `mod` 3 /= 0) (`div` 3) (4*27)
21:26:18 <lambdabot>   4
21:27:12 <dmwit> grom358: No, there is no built-in function like that.
21:27:29 <grom358> dmwit: can you think of better function name for it though
21:27:48 <dmwit> lsnzb ;-)
21:28:01 <dmwit> oops, msnzb
21:28:08 <dmwit> mostSignificantNonzeroBit
21:28:19 <Cale> hm?
21:28:32 <dmwit> no, lsnzb was right
21:28:39 <dmwit> Anyway, no, there's not an obvious better name.
21:28:40 <Cale> Also s/Bit/Digit/
21:28:48 <dmwit> Yeah, I know.
21:29:29 <dmwit> grom358: Whatcha using it for?
21:30:19 <grom358> dmwit: well I a haskell newbie and trying to write this python program (http://pastebin.com/d735587da) into haskell
21:31:22 <dmwit> oh my
21:32:08 <solrize> comments.gmane.org is down?
21:32:17 <jeffz> solrize: seems so
21:32:27 <dmwit> grom358: In that case, how about something like "minimize"?
21:33:20 <dmwit> grom358: But better would just be to write a prime factorization function straight away to model that inner loop.
21:33:30 <dmwit> factorize :: Int -> [Int] -- or so
21:33:38 <dmwit> then largestPrimeFactor = last . factorize
21:34:23 <grom358> yeah.. I was thinking that.. But I not sure how todo that yet.. Its hard to break from side-effect programming. I keep wanting variables
21:35:10 <dmwit> grom358: Well, notice that that loop effectively *is* factorizing the number.
21:41:20 <solrize> should i paste my version?
21:42:28 <dons> Arch Linux now has 700 Haskell packages.
21:42:34 <solrize> cool
21:43:19 <solrize> grom358 hmm i seem to have clobbered your python code
21:43:23 <Twey> Well, AUR does.
21:43:28 <solrize> oh i didn't
21:45:53 <dons> 81% of hackage.
21:46:35 <Savant> morning, #haskell
21:46:45 <Twey> @index hex
21:46:46 <lambdabot> bzzt
21:46:54 <solrize> that is really way cool, to get all that hackage without having to install each item separately
21:47:18 * solrize thinks about switching to arch on his eee, will probably stay with ubuntu on the bigger box
21:47:52 <dons> hopefully we'll pull more people in this way, with good distro support.
21:47:57 <dons> just need to get debian into a similar state.
21:48:04 <Savant> solrize: What arch does your EEE run?
21:48:05 <dons> i don't think that can happen till the platform's done though.
21:48:10 <grom358> I really stuck on converting that outer while loop. Because it it updating the variables used in the loop test condition.
21:49:54 <solrize> savant, i still have the xandros cruft on my eee, i've been wanting to upgrade it to either debian or arch
21:50:08 <Savant> ah.
21:50:51 <Savant> arch has the belt of minimality. ubuntu, well is ubuntu.
21:51:29 <solrize> ubuntu is sort of in the unpleasant valley between minimality and having enough creature comforts to be a pleasant environment
21:51:43 <solrize> i miss fedora but it's turned into crap in recent releases
21:51:59 <Savant> it did?
21:52:16 <solrize> fedora?  yeah
21:54:55 <roconnor> Nix FTW!
21:55:10 <Savant> roconnor: Linux isn't a UNIX.
21:56:01 <Savant> and, i like vista.
21:57:57 <Savant> ;\
21:58:17 <mmorrow> dolio: darcs repo with StateCPS et al http://moonpatio.com/repos/state-bench/
21:58:20 <lambdabot> Title: Index of /repos/state-bench
21:58:39 <mmorrow> StateCPS is fast
21:58:51 <tredontho> question: in a source file I can write this: ceilSqrt = ceiling.sqrt and it gives me an error, but typing let cs = ceiling . sqrt in ghci works fine
21:59:04 <dolio> Faster than the unboxed tuples?
21:59:15 <solrize> grom358, i put a followup on your paste
21:59:18 <mmorrow> dolio: yeah, but i'm not sure why. you'll see
21:59:24 <dolio> Interesting.
21:59:28 <mmorrow> i think the unboxed tuples are evaluating more or something
21:59:37 <mmorrow> something to do with replicateM i think
21:59:39 <tredontho> why does this happen?
21:59:44 <solrize> what is (# ... #)   ?
21:59:55 <dons> a set of registers :)
21:59:56 <mmorrow> the mtl one blows the stack
22:00:07 <mmorrow> dons: hmm
22:00:21 <mmorrow> (and i rebuilt mtl with -O2)
22:00:22 <dolio> Yeah, well, to be equivalent to the CPS and unboxed tuples version, you need to use Control.Monad.State.Strict.
22:00:30 <mmorrow> i thought that was the default
22:00:32 <mmorrow> ?
22:00:36 <dolio> No. Lazy is default.
22:00:43 <mmorrow> crap. ok, updating that repo...
22:02:13 <mmorrow> repo updated
22:03:14 <dolio> I might make a cpsed mtl and play with it some (and put it on my code.haskell.org page; not sure if I'll bother releasing it).
22:03:28 <dolio> I've got State done, but I'm going to sleep soon.
22:03:39 <mmorrow> shit, i didn't add state.hs either
22:04:21 <Savant> hm. does this 'learnyouahaskell' book come recommended?
22:04:29 <dmwit> It's pretty good, yeah.
22:04:40 <dmwit> RWH is nice, too.
22:04:42 <dmwit> ?where RWH
22:04:42 <lambdabot> is http://www.realworldhaskell.org/blog/
22:04:46 <BMeph> tredontho: My off-the-cuff guess, is that you have something else after the 'sqrt' in your source file, but you didn't tell Haskell to stop defining ceilSqrt. Of course, seeing the actual error would help... (hint, hint) :)
22:05:06 <dmwit> ?where+ RWH http://www.realworldhaskell.org/blog/
22:05:06 <lambdabot> It is forever etched in my memory.
22:06:07 <mmorrow> wtf. darcs can't have a file called state.hs apparently
22:06:10 <dolio> Somewhat interestingly, you can make CPSed StateT into a monad regardless of whether the underlying m is a monad (just like ContT).
22:06:21 <mmorrow> i can't think of any other reason for what's happening
22:07:48 <dons> mmorrow: nah. come on.
22:08:06 <dmwit> mmorrow: Watch case sensitivity...
22:10:16 <mfwitten_> Hello. I'm reading through YAHT, and I've come across an exercise that wants me to define a data type Quadruple composed of 4 elements such that the first 2 elements are of one type and the second 2 elements are of another type.
22:10:24 <mfwitten_> I first tried this: data Quadruple a a b b = Quadruple a a b b
22:10:25 <tredontho> BMeph: Yes, well, the error is http://hpaste.org/12024#a0
22:10:28 <mfwitten_> But that gives me errors
22:10:36 <mfwitten_> The following seems to compile: data Quadruple a b c d = Quadruple a a b b
22:10:46 <mfwitten_> But that doesn't seem acceptable to me
22:10:47 <roconnor> data Quadruple a b = Quadruple a a b b
22:10:57 * roconnor recalls this question from last year
22:11:11 <mfwitten_> roconnor: At least I'm in good company ;-)
22:11:18 <roconnor> :)
22:11:33 <dmwit> mfwitten_: As a rule of thumb, the left-hand side of an = binds new names.
22:11:51 <dmwit> mfwitten_: This explains why you can't put 'a' twice on the left; this would bind 'a' twice, which is meaningless here.
22:12:46 <grom358> solarize: what is the pps@ part ?
22:13:06 <mfwitten_> dmwit: Is that just a way to remember this, or is this the actual reason why I get errors. I'm a little confused as to why data types are defined in this way
22:13:11 <solrize> that says take the result of pattern matching (p:ps) and bind it to the name pps
22:13:31 <solrize> just to avoid calculating p:ps a second time
22:13:35 <dmwit> mfwitten_: This is the actual reason you get errors.
22:13:52 <dmwit> mfwitten_: Haskell has a sort of "function at the type level."
22:14:13 <dmwit> mfwitten_: When you say "data Quadruple a b = ..." that is declaring that you are about to write a new type-level function.
22:14:20 <mfwitten_> ok
22:14:34 <roconnor> @kind Maybe
22:14:35 <lambdabot> * -> *
22:14:45 <dmwit> mfwitten_: Quadruple then takes two arguments (that are each types!  or maybe type functions, but let's ignore that for now), and returns a new type based on those arguments.
22:15:04 <dmwit> mfwitten_: The right-hand side of the '=' tells how to use the type arguments.
22:15:19 <mfwitten_> I understand
22:15:35 <mfwitten_> Are the source for YAHT available? It would be nice to add those additional comments
22:15:46 <dmwit> I think it's a wiki.
22:15:47 <dmwit> ?where YAHT
22:15:47 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
22:15:55 <mfwitten_> ah
22:16:07 <dmwit> The original source might be that darcs one, though.
22:16:15 <dmwit> Try darcs getting d.h.o/yaht
22:16:23 <mfwitten_> yeah
22:16:24 <mfwitten_> http://darcs.haskell.org/yaht/
22:16:27 <lambdabot> Title: Index of /yaht
22:18:20 <grom358> solarize: okay.. would I fix the factorize 1 by adding factorize 1 = []
22:18:53 <tredontho> In fact, if I don't actually apply ceilSqrt in the code, just define it, I can load the file in ghci
22:18:53 <solrize> i guess you could do that
22:19:45 <solrize> although, 1 has no factors?  hmm
22:20:13 <solrize> i think i'd want to always have product (factorize n) == n
22:20:24 <solrize> > product []
22:20:25 <lambdabot>   1
22:20:25 <solrize> heh
22:20:49 <solrize> i hope i didn't just do your homework for you :P
22:20:53 <roconnor> all isPrime (factorize n)
22:21:31 <solrize> True    :)
22:23:48 <grom358> solrize: no this isn't homework.. I trying to learn haskell. Going through my python solutions to project euler problems
22:24:02 <grom358> and working out how you do it with functional approach
22:24:21 <mfwitten_> All Right! Another exercise down!
22:24:25 <mfwitten_> ;-D
22:24:31 <mfwitten_> Thanks!
22:24:48 <solrize> project euler seems to map onto haskell really well
22:25:13 <grom358> I am just so used to variables and looping
22:25:56 <mfwitten_> Good night
22:25:59 <mfwitten_> (or day....)
22:28:26 <grom358> solrize: did you realise there is duplicates in the list returned by your factorize
22:28:52 <solrize> yes, factorize 8 = [2,2,2]
22:29:05 <solrize> that's normally what you'd want i think
22:29:19 <solrize> you could drop the duplicates with nub
22:29:23 <solrize> > nub [2,2,2]
22:29:24 <lambdabot>   [2]
22:29:29 <Twey> map head . sort . group . factorize
22:29:30 <grom358> oh..
22:29:37 <Twey> Oh, nub, that's the one
22:30:18 <solrize> nub [2,2,3,4,5,5]
22:30:23 <solrize> > nub [2,2,3,4,5,5]
22:30:24 <lambdabot>   [2,3,4,5]
22:30:48 <grom358> does factorize always(usually) mean to factor into primes.. its been awhile since I done some math
22:30:54 <mauke> Set.toList . Set.fromList
22:30:57 <solrize> i think so
22:34:35 <grom358> solrize: thanks so much
22:35:05 <grom358> your solution is a better then my python one too.. you don't bother testing even numbers =)
22:35:35 <solrize> well, i test one of them :)
22:35:58 <grom358> oh.. yeah.. except 2 of course
22:36:33 <shapr> hej mikael
22:36:44 <shapr> phubuh
22:37:57 <grom358> solrize: is there any particular reason you used the names pps and ps?
22:38:34 <grom358> is pps for possible primes?
22:39:12 <mikael> shapr!
22:39:15 <mikael> Hi!
22:39:24 <shapr> y0!
22:39:30 <shapr> Do you still own phubuh.org?
22:40:10 <mikael> Nope, I let that expire, I'm trying to disown that moniker. :-)
22:40:26 <shapr> Ah, I'll stop mentioning it then.
22:40:43 <mikael> Names are hard to get rid of, though, it's still my name on gmail...
22:40:46 <shapr> Are you out of gymnasiet now?
22:41:03 <solrize> ps = list of primes
22:41:06 <mikael> Yes!  I've been at Chalmers since 2006.
22:41:10 <shapr> doh
22:41:16 <solrize> pps = list of primes with an extra prime on the left
22:41:17 <shapr> I'm behind the times :-)
22:41:33 <shapr> Are you doing stuff with Hughes et al?
22:42:58 <shapr> ppps = list of primes with an extra prime on the left, and small postscript on the end.
22:44:57 <mikael> My intro func. programming course used to be taught by Hughes, but I had K. Claessen; Hughes lectured on the lambda calculus and Erlang in an overview course of programming paradigms, and gave a guest lecture on the current state of functional programming (v. enthusiastically, about xmonad and darcs, etc.).
22:45:02 <grom358> solrize: now the test.. see if I can work out how todo the next one by myself.. Thanks again
22:45:22 <shapr> mikael: Did you mention you were at EuroHaskell? :-)
22:45:50 <solrize> grow358 i better not tell you that there is a complete set of solutions at http://www.haskell.org/haskellwiki/Euler_problems
22:45:54 <solrize> oh whoops!
22:45:58 <shapr> safe!
22:46:01 <lambdabot> Title: Euler problems - HaskellWiki
22:47:34 <solrize> heh, largestPrimeFactor 1 crashes since the list is empty...
22:48:57 <mikael> shapr, nah, that's a running joke with my classmates, though, who've gotten the impression I'm something of a nerd.  Which reputation I've not really lived up to during my time here, unfortunately, but I'm getting back on it.  Seem to be developing a crush on constructive mathematics and logic, Curry-Howard, etc.  Agda is really cool!
22:49:19 <shapr> Your classmates discovered that you were at EuroHaskell?
22:49:56 <mikael> Couldn't resist mentioning I've seen J. Hughes try to operate a unicycle. :-)
22:49:59 <shapr> haha
22:50:14 <shapr> He did really well for his first try.
22:50:19 <mikael> Truly!
22:50:25 <shapr> I wonder if he's tried it since then?
22:51:47 <solrize> @hoogle (a,b)->(b,a)
22:51:47 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
22:51:47 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
22:51:47 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
22:52:09 <dmwit> :t fst &&& snd
22:52:09 <lambdabot> forall a b. (a, b) -> (a, b)
22:52:18 <solrize> :t snd &&& fst
22:52:19 <lambdabot> forall a b. (a, b) -> (b, a)
22:52:30 <dmwit> That's what I meant, thanks.
22:53:18 <dmwit> :t curry flip
22:53:19 <lambdabot>     Couldn't match expected type `(a, b)'
22:53:19 <lambdabot>            against inferred type `a1 -> b1 -> c'
22:53:19 <lambdabot>     Probable cause: `flip' is applied to too few arguments
22:53:33 <dmwit> ?pl \(a,b) -> (b,a)
22:53:33 <lambdabot> uncurry (flip (,))
22:53:36 * shapr falls over asleep
22:54:11 <mikael> shapr, where are you operating these days?
22:54:27 <shapr> Boston
22:54:40 <shapr> Jag bo i stan!
22:54:59 <shapr> Det finns Norboistan har
22:55:13 <shapr> I think that's a great name.
22:55:24 <shapr> Men jag har inte traffat dem...
22:55:28 <shapr> kanske snart
22:56:35 <vininim> Não tou entendendo nada :)
22:57:34 <shapr> oi vininim!
22:57:50 <shapr> portugues?
22:58:18 <shapr> I have no idea what Swedish is called in Portuguese, hmm.
22:58:29 <vininim> português brasileiro. =D
22:58:47 <shapr> Ah, my favorite flavor.
22:59:04 <vininim> let me see
22:59:49 <vininim> It's called `suéco' as the nationality.
23:00:27 <shapr> Ah, obrigado
23:01:22 <mikael> My picture of Boston is somehow of a city made up of characters played by Matt Damon, also it always rains there, and everyone's clever.  Should visit to get a more nuanced view.  :-)  Who are these Norboistan, I don't get the name.  (Bo i stan ~ Boston... what's Nor?)
23:01:39 <shapr> north?
23:01:44 <shapr> oh sorry, nordboistan
23:01:46 <shapr> oops
23:02:14 <shapr> mikael: Sure, feel free to visit. You can sleep on my couch for a week or so.
23:02:30 <jml> shapr: yay couches
23:02:49 <shapr> jml: Hey, you're in town, right?
23:02:55 <jml> shapr: sadly no.
23:03:02 <jml> shapr: I'm in Sydney.
23:03:03 <shapr> Oh, I keep thinking you are for some reason.
23:03:05 <shapr> Ah
23:03:10 <jml> shapr: I was in Boston this time last year. :)
23:03:19 <shapr> Oh, hanging with the Twisted guys?
23:03:23 <jml> shapr: yep
23:03:27 <jml> shapr: messing with them.
23:03:31 <shapr> Coming back anytime soon?
23:03:42 <jml> shapr: I'd love to, but no plans.
23:03:50 <shapr> jml: Did I meet you at any of the Twisted go out to dinner meetings?
23:03:54 <jml> shapr: Australia is, as you may have noticed, in the middle of nowhere.
23:04:05 <shapr> jml: Well, Australia is somewhere!
23:04:21 <jml> shapr: I don't *think* so.
23:04:35 <dibblego> sure it is, right in the middle of nowhere
23:04:36 <shapr> jml: I'm pretty hard to miss.
23:04:53 <shapr> I'm sort of hyperactive usually.
23:05:17 <jml> shapr: hyperactive isn't a distinguishing trait when hanging out w/ Twisted & Canonical ppl
23:05:43 <shapr> I think it's entirely possible I'm more hyperactive than anyone I met in the Twisted office.
23:05:45 <mikael> Nice, thanks, shapr!  Detsamma, except I live on 18 square meters, with a roommate, and you'd have to sleep on a matress on the floor.
23:05:56 <Nafai> jml: Heh :)
23:06:00 <shapr> mikael: Also, I've been to Chalmers before :-)
23:06:28 <jml> shapr: well, I just invited someone with your name in Boston to be my facebook friend :)
23:06:33 * shapr looks
23:06:43 <jml> shapr: if that's you, then we've never met.
23:07:33 <shapr> jml: Ok, doesn't surprise me. Most people remember me.
23:10:01 <wagle> omg..  python curries!
23:10:19 <wagle> hi shapr
23:10:22 <shapr> y0
23:10:28 <shapr> How's code?
23:10:42 <Twey> wagle: Duh!
23:10:47 <Twey> Not as prettily as Haskell, though.
23:10:57 * shapr &
23:11:01 <wagle> programming in python at the moment..  wishing for static typing
23:11:39 <jml> o.O
23:12:01 <jml> I really need to actually *write* something in Haskell, so I can understand the motivation behind that statement.
23:12:51 <wagle> i'm being really gross at the moment and writing variable names like "list_of_sha1_lists"
23:13:41 <jml> wagle: that is a little off-colour
23:14:10 <wagle> its the type checking I have to do by hand (eye?)
23:15:10 <jml> wagle: well, normally I don't care about type checking when I write Python code, I care about whether the tests pass.
23:15:24 * Twey nods.
23:15:40 <wagle> would if your tests took 15 minutes to fail
23:15:42 <Twey> wagle: Writing type-checking by hand results in poor Python code.
23:15:49 <Twey> Duck-typing, remember.  Just use it.
23:15:53 <jml> (and I name variables by their intent, not by their content)
23:16:03 <Saizan> intent?
23:16:21 <wagle> well, i said it was gross...
23:16:24 <jml> Saizan: what they are there for.
23:16:34 <tredontho> is there a way to, in a list comprehension, print out the value going into the list?  i.e. [ x | x <- someList, predicate x, print x]
23:16:53 <jml> wagle: :)
23:16:53 <Saizan> ah, like fileHashes rather than list_of_sha1_lists, i see
23:16:58 <jml> Saizan: yep
23:17:38 <Saizan> tredontho: no, list comprehensions are only for lists
23:17:41 <wagle> well, actually, i'm naming intermediate results.. so well..  umm
23:17:54 <tredontho> Saizan: darn... okay, thanks
23:17:59 <Saizan> tredontho: you can use filterM in your case though
23:18:40 <Saizan> ?type filterM (\x -> print x >> return (?predicate x))
23:18:42 <lambdabot> forall a. (?predicate::a -> Bool, Show a) => [a] -> IO [a]
23:18:44 <jml> speaking of tests
23:19:01 <jml> how do haskell folk write unit tests?
23:19:32 <Twey> There are a few test suites
23:19:38 <Saizan> we mostly use QuickCheck or HUnit
23:19:41 <Twey> QuickCheck is popular, I believe
23:20:10 <Saizan> even if QuickCheck is exactly about unit tests
23:20:22 <Saizan> err, "not exactly"
23:20:40 <tredontho> Saizan: mm, just learning, trying to keep it simple to start off with... i'll find another way, thanks though
23:20:45 <wagle> i've created a 118640 node dag of the git commits of the linus kernel..  then declared all but 8445 of them as "boring"..  graphviz couldn't handle even that
23:23:56 <Twey> Hahahaha
23:24:51 <roconnor> > (1- (exp(2/3*pi*(0:+1)) -1)^2)/4
23:24:54 <lambdabot>   (-0.12499999999999989) :+ 0.6495190528383289
23:25:05 <pumpkin> wagle: what can one use instead of graphviz? I was trying to model a graph approximately that large
23:25:18 <pumpkin> and even on my 8gig machine, it eventually crashed
23:25:38 <Axman6> > exp (pi*(0:+1)) - 1
23:25:40 <lambdabot>   (-2.0) :+ 1.2246467991473532e-16
23:25:49 <Axman6> hm
23:25:50 <roconnor> > (1- (exp(2/3*pi*(0:+1)) -1)^2)/4 :: Complex CReal
23:25:52 <lambdabot>   0.375 :+ 0.2165063509461096616909307926882340458678
23:26:08 <roconnor> hm
23:26:13 <roconnor> that's ... different
23:26:20 <pumpkin> can it do complex integers? :P
23:26:45 <Axman6> > (1:+1) :: Complex Integer
23:26:46 <lambdabot>       No instance for (RealFloat Integer)
23:26:46 <lambdabot>        arising from a use of `show'...
23:26:54 <Axman6> guess not
23:27:02 <roconnor> (exp(2/3*pi*(0:+1)) :: Complex CReal
23:27:03 <Axman6> > (1:+1) :: Complex Double
23:27:04 <roconnor> > (exp(2/3*pi*(0:+1)) :: Complex CReal
23:27:05 <pumpkin> not sure how those would work anyway
23:27:05 <lambdabot>   1.0 :+ 1.0
23:27:05 <lambdabot>   <no location info>: parse error on input `;'
23:27:17 <roconnor> > (exp(2/3*pi*(0:+1))
23:27:18 <lambdabot>   <no location info>: parse error on input `;'
23:27:20 <pumpkin> roconnor: what are you looking for?
23:27:36 <roconnor> what expressions differ between CReal and Double
23:27:45 <roconnor> > exp(2/3*pi*(0:+1)) :: Complex CReal
23:27:47 <lambdabot>   0.5 :+ 0.8660254037844386467637231707529361834714
23:27:51 <roconnor> > exp(2/3*pi*(0:+1))
23:27:51 <wagle> pumpkin, dunno..  i'm still using graphviz..  trying to reduce the graph even more
23:27:52 <lambdabot>   (-0.4999999999999998) :+ 0.8660254037844387
23:28:10 <pumpkin> wagle: there's no better option without the ridiculous memory requirements? :P
23:28:13 <pumpkin> that's sad
23:28:25 <Axman6> > exp (pi*(0:+1)) + 1
23:28:26 <lambdabot>   0.0 :+ 1.2246467991473532e-16
23:28:32 <Axman6> close enough
23:28:38 <Axman6> > exp (pi*(0:+1)) + 1 :: Complex CReal
23:28:40 <lambdabot>   0.0 :+ 0.0
23:28:44 <Axman6> whoot
23:29:18 <roconnor> > sin(2/3*pi)
23:29:19 <lambdabot>   0.8660254037844387
23:29:27 <roconnor> > cos(2/3*pi)
23:29:29 <lambdabot>   -0.4999999999999998
23:29:35 <roconnor> > cos(2/3*pi) :: CReal
23:29:36 <lambdabot>   0.5
23:29:39 <roconnor> see
23:29:43 <roconnor> that's just not right
23:29:45 <wagle> pumpkin, i havent looked..  graphviz is good enough..  I reduced my graph by hand until graphviz could display it, and the graph is still too hairy to understand..  so i'm concentrating on more vigorous graph simplification..  8)
23:30:02 <pumpkin> :)
23:30:06 <pumpkin> is there a fixed limit?
23:30:13 <pumpkin> or some sort of expression I can use to predict its memory use?
23:30:26 <pumpkin> cause my 4MB .dot file is choking it miserably on all the big computers I can get ahold of
23:30:37 <roconnor> @remember CReal cos(2/3*pi) :: CReal
23:30:38 <lambdabot> Nice!
23:30:48 <pumpkin> lol
23:31:12 <pumpkin> how are CReals implemented?
23:31:58 <roconnor> wrongly
23:32:10 <wagle> pumpkin, i havent gotten that far..  just started to think of trying to send stuff to and from my big iron machine..  (notebook crunched all last night and didnt finish)
23:36:00 <jeffz> pumpkin: maybe your problem is one of these http://www.graphviz.org/bugs/openbugs.html
23:36:01 <roconnor> > cos(0) :: CReal
23:36:03 <lambdabot> Title: Graphviz Open Bug List
23:36:04 <lambdabot>   1.0
23:36:11 <roconnor> > cos(pi/4) :: CReal
23:36:13 <lambdabot>   0.7071067811865475244008443621048490392848
23:36:17 <roconnor> > cos(pi) :: CReal
23:36:19 <lambdabot>   -1.0
23:36:26 <roconnor> > cos(pi/2) :: CReal
23:36:28 <lambdabot>   0.0
23:36:35 <pumpkin> jeffz: I've had it in several rather different huge graphs
23:36:35 <roconnor> > cos(3*pi/4) :: CReal
23:36:36 <lambdabot>   0.7071067811865475244008443621048490392848
23:36:40 <roconnor> :D
23:36:40 <pumpkin> maybe it's an epic memory leak though
23:37:09 <ivanm> pumpkin: there is a maximum size that graphs can be AFAIK
23:38:06 <roconnor> > [(cos(i*pi/4),cos(i*pi/4)::CReal) | i<-[0..4]]
23:38:07 <lambdabot>   [(1.0,1.0),(0.7071067811865475244008443621048490392848,0.707106781186547524...
