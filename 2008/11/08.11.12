00:00:47 <Twey> What's with the weird separation style that's so popular in Haskell: { foo\n; bar\n; baz } instead of {\n foo;\nbar;\n baz\n} or { foo;\n  bar;\n  baz }?
00:05:19 <dons> Twey: makes it possible to edit only one line to add an element.
00:05:26 <dons> its from the glasgow idiom school.
00:06:03 <Twey> But that's the same with { foo;\n  bar;\n  baz }
00:06:42 <Twey> Not at the start or end, I suppose.  Hmn.
00:06:57 <dons> if you add bar after baz, you have to edit two lines.
00:07:37 <Twey> Hmmm
00:07:53 <Twey> Is {\n  foo;\n  bar;\n  baz;\n} invalid?  The trailing semicolon?
00:08:13 <dmwit> > do { return 3; }
00:08:15 <lambdabot>       No instance for (Show (t1 t))
00:08:15 <lambdabot>        arising from a use of `show' at <i...
00:08:19 <dmwit> Seems valid.
00:08:22 <Twey> Apparently not
00:08:22 <dmwit> > do { return 3; } :: [Int]
00:08:24 <lambdabot>   [3]
00:08:53 <dmwit> so, do {\n foo;\n bar;\n } -- seems nice and comfortable for out-of-towners
00:08:58 <sbahra> :t return
00:08:59 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:09:05 <Twey> Aye
00:09:12 <Twey> It looks a lot neater, too
00:09:19 <dmwit> yeah
00:09:35 <dmwit> Twey: I guess it's probably in analog to the {,,} syntax for records and the [,,] syntax for list comprehensions.
00:09:49 <dmwit> There, it totally makes sense to line up the { or [ with the ensuing ,s.
00:10:16 <Twey> Additionally, the { foo\n; bar\n; baz\n} requires editing two to add an element at the start
00:10:22 <Twey> I suppose so.
00:10:43 <hackage> Uploaded to hackage: mucipher 0.6.0
00:10:49 <Twey> It still looks ugly to me, but I suppose it kind of makes sense.
00:10:53 <dmwit> ?hackage mucipher
00:10:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mucipher
00:11:02 <Twey> Hm
00:11:19 <Twey> Still requires editing two lines to add an element on the beginning.
00:11:26 <dmwit> Which one?
00:11:38 <Twey> The list/record syntax
00:11:43 <dmwit> yeah
00:11:45 <dons> you can have a leading ; on the first item ...
00:11:48 <Twey> Lining up the commas
00:11:58 <dons> (at least  ghc allows that for do notation, and module imports, iirc)
00:12:06 <dons> specifically for this
00:12:07 <dmwit> > do { ;[3] } :: [Int]
00:12:07 <Twey> dons: You can have a trailing ; on the last item, too :-P  We're onto lists now.
00:12:08 <lambdabot>   [3]
00:12:21 <dmwit> > [3|,True,True]
00:12:23 <lambdabot>   <no location info>: parse error on input `,'
00:12:33 <dons> yeah, lists are  the odd ones out.
00:12:47 <dmwit> You can have a "True", though:
00:12:59 <dmwit> [ foo | True\n, a\n, b\n]
00:13:14 <Twey> It's not possible to have a leading/trailing comma on a list, is it?
00:13:20 <Twey> > [, 1]
00:13:22 <lambdabot>   <no location info>: parse error on input `,'
00:13:24 <Twey> > [1, ]
00:13:25 <lambdabot>   <no location info>: parse error on input `]'
00:13:48 <dmwit> No, but multi-lining list literals is not nearly as common as multi-lining list comprehensions.
00:13:49 <Twey> dmwit: What's foo?
00:14:11 <Twey> Oh, you're talking about generic list comprehensions
00:14:19 <dmwit> No, just normal ones.
00:14:39 <dmwit> [ a + b | True\n, a <- as\n, b <- bs\n]
00:14:50 <Twey> I meant 'more generic than using them as a dodgy syntax for list literals' :-P
00:14:56 <dmwit> ah =)
00:16:06 <Twey> Yes, but again, you can also do [ a + b |\n  a <- as,\n  b <- bs,\n True]
00:16:17 <dmwit> Can you?
00:16:22 <dmwit> > [3|True,]
00:16:24 <lambdabot>   <no location info>: parse error on input `]'
00:16:28 <dmwit> oh
00:16:31 <dmwit> yeah
00:16:31 <Twey> You misread
00:16:33 <dmwit> I did.
00:16:56 <dmwit> Anyway, I've never seen either of those.
00:17:00 <Twey> So I don't really see the advantage
00:21:37 <Vq^> > [3|True]
00:21:38 <lambdabot>   [3]
00:21:42 <Vq^> > [3|False]
00:21:44 <lambdabot>   []
00:22:16 <Vq^> hmm, never seen that before
00:23:09 <Twey> Vq^: List comprehension
00:23:22 <dancor> > [3 | True, False`
00:23:24 <lambdabot>   <no location info>: parse error on input `;'
00:23:26 <dancor> > [3 | True, False]
00:23:28 <lambdabot>   []
00:23:33 <dancor> > [3 | True, True]
00:23:35 <lambdabot>   [3]
00:23:43 <Twey> [expr | vars <- from, condition1, condition2, ... conditionN]
00:23:50 <dancor> > [3 | True, True, x <- [1..3]]
00:23:52 <lambdabot>   [3,3,3]
00:24:06 <Twey> The conditions are and'ed.
00:24:19 <dmwit> Vq^: I actually use exactly the form [3 | condition] as a poor-man's if statement sometimes.  It can be quite a convenient trick.
00:24:23 <dancor> > [3 | "lol"]
00:24:24 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[Char]'
00:24:36 <Twey> dmwit: But then you have to extract it from the list :-P
00:24:45 <dmwit> Twey: Not if what I want is a list.
00:24:48 <Twey> True
00:24:49 <dancor> :t listToMaybe
00:24:50 <lambdabot> forall a. [a] -> Maybe a
00:25:19 <dmwit> Twey: (And mostly I don't use that if what I want is not a list. =)
00:25:34 <sbahra> listToMaybe []
00:25:37 <sbahra> > listToMaybe []
00:25:38 <Twey> if x then [y] else [] vs. [y | x]... works
00:25:39 <lambdabot>   Nothing
00:25:39 <sbahra> > listToMaybe [1]
00:25:41 <lambdabot>   Just 1
00:26:05 <Twey> sbahra: listToMaybe [] = Nothing; listToMaybe xs = Just $ head xs
00:27:13 <sbahra> Twey, yes?
00:27:38 <dmwit> ?source listToMaybe
00:27:39 <lambdabot> listToMaybe not available
00:27:44 <dmwit> ?src listToMaybe
00:27:45 <lambdabot> listToMaybe []        =  Nothing
00:27:45 <lambdabot> listToMaybe (a:_)     =  Just a
00:27:51 <dmwit> I always mix those two up.
00:28:41 <Twey> What's the difference?
00:28:57 <dmwit> source gets source files for modules
00:29:00 <dmwit> ?source Data.List
00:29:00 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
00:29:22 <dmwit> (...and src retrieves the definitions for functions)
00:29:35 <Twey> Oh right
00:29:36 <Twey> Heh
00:30:01 <dmwit> It should be pretty easy to remember: the long one gets the long answer, the short one gets the short answer.
00:30:05 <dmwit> But I still have trouble. =)
00:33:58 <Twey> Probably because your mnemonic is backwards, from a certain point of view :-P
00:34:10 <Twey> A single URL is shorter than the full source of the function.
00:42:41 <sbahra> > listToMaybe [1, 2, 3]
00:42:43 <lambdabot>   Just 1
00:49:48 <mmorrow> > list
00:49:49 <lambdabot>   Not in scope: `list'
00:50:07 <mmorrow> @let list nil _ [] = nil ; list _ cons (x:xs) = cons x xs
00:50:08 <lambdabot>  Defined.
00:50:37 <mmorrow> > list Nothing (Just . const) [1,2,3]
00:50:38 <lambdabot>   Couldn't match expected type `[t1] -> Maybe a'
00:50:51 <mmorrow> > list Nothing (\x _ -> Just x) [1,2,3]
00:50:53 <lambdabot>   Just 1
00:51:02 <mmorrow> > list Nothing ((Just .) . const) [1,2,3]
00:51:03 <lambdabot>   Just 1
00:51:40 <mmorrow> > list mzero ((return .) . const) [1,2,3]
00:51:41 <lambdabot>       No instance for (Show (m t1))
00:51:41 <lambdabot>        arising from a use of `show' at <i...
00:51:45 <mmorrow> > list mzero ((return .) . const) [1,2,3] :: Maybe Integer
00:51:47 <lambdabot>   Just 1
00:52:09 <mmorrow> > maybe mzero return (Just 42) :: [Integer]
00:52:10 <lambdabot>   [42]
00:52:52 <mmorrow> @let bool false _ False = false ; bool _ true True = true
00:52:53 <lambdabot>  Defined.
00:56:32 <vegai> hmm, lazyness bites
00:57:38 <vegai> "Some other languages (eg. Clean) have strictness annotations on types, which is is a less ugly way to express this, but for now there are no Haskell compilers that support this."
00:57:42 <vegai> :-(
00:58:07 <vegai> hmm, perhaps -O2 would figure it out
00:58:12 <mmorrow> data A a b = A !a b
00:58:28 <vegai> my small script doesn't have data structures..
00:58:35 <mmorrow> f !n a b (!x,y) = ...
00:58:42 <vegai> oh, I can do that?
00:58:46 <mmorrow> oh yesh
00:59:00 <mmorrow> {-# LANGUAGE BangPatterns #-}
00:59:13 <mmorrow> you can even do it in lambdas (and lets)
00:59:18 <vegai> nice
00:59:31 <vegai> nice #2: ghc -O2 also figured it out
00:59:42 <mmorrow> oh yeah, i always use -O2
00:59:50 <vegai> I was running on ghci before...
00:59:54 <mmorrow> ah
01:00:08 <vegai> I'm doing a bit of stress testing on TChans
01:00:13 <mmorrow> cool
01:00:50 <mmorrow> ah yeah, i noticed this the other day (parser glitch):
01:00:57 <mmorrow> , (\!x -> x) 42
01:00:58 <lunabot>  luna: parse error on input `->'
01:00:59 <mmorrow> , (\ !x -> x) 42
01:01:02 <lunabot>  42
01:01:14 <mmorrow> but no big deal
01:01:38 <vegai> three writer threads adding 100k strings to the TChan is enough to overflow the stack. With one reader thread
01:02:24 <mmorrow> what's the writer function look like?
01:02:53 <vegai> this is real simple
01:03:12 <vegai> http://hpaste.org/11949
01:03:40 <vegai> oh, I should add those pragmas
01:04:38 <mmorrow> ah, i bet it's new_count that's blowing the stack
01:04:48 <vegai> yeah, that's what I figured as well
01:04:54 <vegai> it was actually visible
01:04:56 <mmorrow> http://hpaste.org/11949#a2
01:05:02 <mmorrow> this might do it
01:05:07 <vegai> Successfully read (3 second wait) 199999.   and so on
01:06:00 <vegai> mmorrow: yes, that does fix it too
01:06:13 <mmorrow> cool
01:07:01 <vegai> oh, right. The -O2 didn't really fix the stack problem. I suppose it just optimized so well I thought that leak wasn't there anymore
01:07:38 <vegai> now I can have several threads all writing 100k and just one reader
01:07:47 <mmorrow> woohoo
01:08:19 <mmorrow> i find that it's rare to have a function that you just can't get to not overflow in ghci, but works with -O2
01:08:31 <vegai> I wish the compiler could be made to warn about the possibility of these leaks
01:09:13 <vegai> sometimes it seems that it would be more sane if strict was the default and laziness would have to be annotated...
01:09:30 <vegai> blasphemy?
01:09:39 <mmorrow> bl;asphemer!!!@
01:09:42 <mmorrow> :)
01:09:55 <vegai> blasphemy.... blas for you ...  blas for everybody in the room
01:10:42 <earthy> unfortunately, vegai, strictness doesn't compose as nicely as laziness
01:11:04 <earthy> so the sensible default is non-strict semantics with a good strictness analyzer and strictness annotations
01:11:18 <earthy> (do I hear Clean? :))
01:12:39 <sjanssen> GHC has a good strictness analyzer and strictness annotations on patterns
01:12:57 <vegai> by the way, would there have been a way to see that new_count was the culprit... without involving so many brain cells :P
01:13:03 <vegai> the profiler perhaps...
01:13:14 * vegai takes a look
01:21:30 <vegai> well ok. The space profiling might help me see that readAllFrom leaks
01:21:49 * vegai goes back to doing something seriouser
01:35:03 <vegai> hmh, why are all Go clients awful
01:36:45 <chrisdone> heh, does anyone else "banish" things to workspace 9 on xmonad? like "I'll look at this firefox window later. *workspace 9*"
01:37:48 <helge> shift alt 9?
01:41:48 <idnar> what are extensible records?
01:44:23 <PeakerWork> Hmm.. "cabal: Package vector-space-0.5 can't be built on this system."
01:44:31 <PeakerWork> can it be a bit more elaborate about it? :)
01:44:56 <vegai> given a pid, can I check whether it is alive?
01:45:16 <idnar> on linux, you could probable test for the existence of /proc/<pid>
01:45:25 <ivanm> idnar: records that can be extended? ;-)
01:45:32 <PeakerWork> you can send it a harmless signal and see if that works, maybe?
01:45:34 <idnar> of course, the fact that a pid is currently associated with a running process doesn't mean that it's the process you're expecting it to be
01:45:40 <vegai> idnar: using forkIO
01:45:56 <idnar> ah, don't know anything about that
01:46:00 <vegai> so those should be ghc internal threads
01:46:07 <PeakerWork> vegai: forkIO returns a thread id, not a pid
01:46:11 <PeakerWork> @hoogle forkIO
01:46:12 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
01:47:18 <PeakerWork> vegai: I am not sure if you can test whether a ThreadId is still alive. You could have that thread use a bracket around everything that wrote into an MVar
01:47:23 <PeakerWork> @type bracket
01:47:24 <lambdabot> Not in scope: `bracket'
01:47:29 <PeakerWork> @hoogle bracket
01:47:30 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
01:47:30 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
01:47:30 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
01:48:02 <PeakerWork> @type Control.Exception bracket
01:48:03 <lambdabot> Couldn't find qualified module.
01:48:06 <PeakerWork> @type Control.Exception.bracket
01:48:07 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
01:48:18 <PeakerWork> that's quite a bug in hoogle there
01:48:22 <vegai> yes, that could work
01:48:23 <PeakerWork> (lacking parens)
01:48:34 <PeakerWork> @hoogle newMVar
01:48:34 <lambdabot> Control.Concurrent.MVar newMVar :: a -> IO (MVar a)
01:48:39 <vegai> huh
01:49:00 <PeakerWork> vegai: "Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c" when it actually is: "IO a -> (a -> IO b) -> (a -> IO c) -> IO c"
01:49:09 <PeakerWork> those are very different types
01:49:14 <idnar> well
01:49:19 <idnar> the docs are also wrong
01:49:40 <idnar> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v:bracket
01:49:52 <lambdabot> Title: Control.Exception, http://tinyurl.com/yk8zqb
01:49:56 <vegai> it's correct on the Synopsis list, though
01:50:06 <idnar> true
01:52:22 <PeakerWork> vegai: forkIOWithCompletion code = do { mvar <- newMVar False ; forkIO $ bracket (return ()) (writeMVar mvar True) code ; return mvar }
01:57:18 <vegai> PeakerWork: nice
01:57:36 <vegai> also, I found ThreadStatus from GHC.Conc
01:57:50 <vegai> which is perhaps a bit evil to use
01:57:58 <vegai> threadStatus, that is
01:58:17 <vegai> or both, actually
02:00:11 <quicksilver> vegai: marking completion with an MVar is definitely cleaner
02:00:17 <quicksilver> (than relying on threadStatus)
02:01:14 <PeakerWork> what does "cabal: Package vector-space-0.5 can't be built on this system." mean?
02:01:43 <dcoutts> PeakerWork: it specified something like "if (...condition...) buildable: False"
02:02:12 <PeakerWork> dcoutts: how can I tell what went wrong?
02:02:33 <PeakerWork> dcoutts: oh, wait, I know what went wrong
02:02:46 <PeakerWork> (but it would still be nice if it said so ;-)
02:03:05 <dcoutts> PeakerWork: it needs a cleverer resolver. I'm working on it atm.
02:03:31 <quicksilver> dcoutts: faster! faster! ;)
02:03:35 <PeakerWork> dcoutts: cool, thanks
02:03:52 <dcoutts> quicksilver: :-)
02:05:18 <vegai> ah, I got the TChans to finally clash a bit with +RTS -N4 :)
02:06:41 <vegai> I guess I should try some more complex transactions. Just a simple add doesn't quite cause enough pain for STM
02:07:04 <askentasken> what do you think of Alan Kay's opinion(from 1997 oopsla talk) that browsers are a bad idea and that every object should carry the infomration needed to render it instead?
02:10:43 <hackage> Uploaded to hackage: peano-inf 0.2
02:10:43 <hackage> Uploaded to hackage: multisetrewrite 0.1.1
02:10:48 <jeffz> askentasken: what does it have to do with haskell?
02:36:05 <C-Keen> hm I use bracket to protect myself against exceptions but for createDirectory it does not seem to work...
02:36:49 <sjanssen> C-Keen: which bracket are you using?
02:38:00 <sjanssen> @hoogle bracket
02:38:01 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
02:38:01 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
02:38:01 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
02:38:21 <sjanssen> oh, I guess there is only one
02:48:23 <mapreduce> Is there a combinator library for binary file parsing and writing?
02:49:02 <quicksilver> depends if you think Data.Binary counts as a combinator library.
02:49:25 <mapreduce> afaict Data.Binary does not work with existing formats, but defines its own.
02:52:11 <quicksilver> mapreduce: you know incorrectly.
02:52:42 <quicksilver> mapreduce: "Data.Binary", the module, does that, but "Data.Binary", the software package, also contains the Get and Put monads.
02:52:51 <quicksilver> mapreduce: which give you the tools to define your own format.
02:52:58 <mapreduce> I've started implementing such a thing in Java (yes, I like pain), so I can easily write Format.integer.bind(Format.byteArray) to create a Format that can parse and write a length-encoded sequence of bytes (the length is specified first followed by the bytes).
02:53:26 <quicksilver> there's nothing built-in for specifying read-and-write at the same time, though.
02:53:30 <mapreduce> I'm struggling to think how one might do that for the case where two lengths precede corresponding data blocks.
02:53:34 <quicksilver> that would be great, but seems to be hard to do.
02:53:43 <mapreduce> Ah, that's what I was hoping for, at least for inspiration.
02:54:58 <Twey> Don't know about Java, but that's a fun exercise in Javascript.
02:55:13 <Twey> Took me half an hour, but then the person didn't even want it *grumble*
02:56:26 <mapreduce> Without a typesystem it would be significantly easier.
02:56:35 <mapreduce> Easier to get right and easier to get wrong.
02:56:49 <sjanssen> quicksilver: I've seen some pickler combinators for doing exactly that
02:57:10 <Twey> Aye
02:58:01 <sjanssen> quicksilver: http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
02:58:03 <lambdabot> Title: FUNCTIONAL PEARL Pickler Combinators
02:58:30 <mmorrow> graphviz eye candy: http://moonpatio.com/wound.html
02:58:50 <mmorrow> graphviz++
03:01:08 <quicksilver> sjanssen: ah great, thanks.
03:01:16 <Twey> What's this, mmorrow?
03:01:19 <Twey> What's it depicting?
03:01:30 <quicksilver> sjanssen: it did seem like an obvious thing for someone to have done.
03:01:36 <quicksilver> (investigated, I mean)
03:03:11 <mmorrow> function "unwinding". i'm reading this currently: http://www.cs.york.ac.uk/fp/reduceron/reduceron.pdf
03:03:15 <lambdabot> Title: The Reduceron:
03:03:21 <mmorrow> (@Twey)
03:04:58 <Twey> Ooh, FPGAs
03:06:00 <quicksilver> mmorrow: the reduceron is neat
03:07:08 <mmorrow> @pl \f x y z -> (\x -> x `seq` (\y -> y `seq` (\z -> z `seq` f x y z) z) y) x
03:07:09 <lambdabot> flip . (((. seq) . flip (.)) .) . flip . (flip seq .) . ap seq . join . join
03:07:15 <mmorrow> quicksilver: way neat
03:09:00 <mmorrow> @unpl flip . (((. seq) . flip (.)) .) . flip . (flip seq .) . ap seq . join . join
03:09:00 <lambdabot> (\ u b c j -> seq b (seq c ((seq >>= \ al -> ((u >>= \ aw -> aw) >>= \ au -> au) >>= \ ak -> return (al ak)) j)))
03:09:08 <mmorrow> @pl (\ u b c j -> seq b (seq c ((seq >>= \ al -> ((u >>= \ aw -> aw) >>= \ au -> au) >>= \ ak -> return (al ak)) j)))
03:09:10 <lambdabot> flip ((.) . (.) . seq) . flip ((.) . seq) . (seq >>=) . (. (return .)) . (>>=) . join . join
03:09:33 <mmorrow> @unpl flip ((.) . (.) . seq) . flip ((.) . seq) . (seq >>=) . (. (return .)) . (>>=) . join . join
03:09:34 <lambdabot> (\ u c f i -> seq c (seq f ((seq >>= \ ba -> ((u >>= \ aw -> aw) >>= \ au -> au) >>= \ bd -> return (ba bd)) i)))
03:10:17 <mmorrow> unpl is all about the reader monad
03:10:32 <Twey> Am I right in thinking that Yhc is where all the fancy new stuff gets developed, while GHC is going more for the 'tried and tested' approach?
03:10:36 <mmorrow> we need an ununpl or something
03:11:28 <mmorrow> Twey: it's more like, people use yhc-core as a nice simple minimalistic lang actual haskell can get compiled to, but only yhc produces it as of yet
03:11:52 <Twey> GHC core is uglier?
03:11:53 <mmorrow> yhc error messages are like salt in open wounds for one thing
03:12:02 <quicksilver> Twey: GHC has a much more complex type system.
03:12:03 <Twey> Ah
03:12:12 <quicksilver> most of the type system experiments happen in GHC
03:12:12 <Twey> I see
03:12:37 * Twey nods.
03:12:54 <mmorrow> Twey: actually, ghc ext-core is just becoming useable again.
03:13:12 <mmorrow> looking at it, it down't seem like it'd be too bad to translate it to yhc-core
03:13:37 <mmorrow> and thus enabling the use of ghc for projects that need yhc-core
03:13:55 <mmorrow> (e.g. yhcjs, reduceron, catch, supero, hhi, ...)
03:14:09 <mmorrow> btw, hhi is really cool
03:14:51 <Twey> How's supero coming along these days?  I haven't seen anything recent about it
03:15:03 * Twey googles, slowly.
03:15:19 <quicksilver> I think ndm suffered from ETOOMANYPROJECTS
03:15:27 <quicksilver> I'm not sure what his current focus is.
03:15:29 <mmorrow> http://darcs.haskell.org/ghc/utils/ext-core/
03:15:30 <lambdabot> Title: Index of /ghc/utils/ext-core
03:15:45 <mmorrow> http://www-users.cs.york.ac.uk/~mfn/hhi/hhi.pdf
03:15:47 <lambdabot> Title: Evaluating Haskell in Haskell
03:15:55 <Twey> Heh, aye.
03:15:59 <Twey> A Haskell intepreter in Haskell?
03:16:03 <Twey> Like... GHCi?
03:16:04 <mmorrow> http://www.cs.york.ac.uk/fp/darcs/hhi/
03:16:05 <lambdabot> Title: Index of /fp/darcs/hhi
03:16:15 <mmorrow> it's not at the same level as ghci
03:16:18 <Twey> GHCi is in C?
03:16:20 <mmorrow> you'll see
03:16:23 <Twey> Why was I not informed?
03:16:27 <quicksilver> well ghci's RTS is in C-- and C
03:16:33 <quicksilver> ghci's RTS is ghc's RTS
03:16:40 <quicksilver> ghci is somehow "metacircular in the RTS"
03:16:48 <Twey> Gesundheit.
03:16:58 <Twey> 'Metacircular'?
03:17:03 <quicksilver> google it :P
03:17:08 * Twey groans.
03:17:17 <mmorrow> ghc is part haskell, part C, and interprets bytecode whose execution weaves in and out of compiled code
03:17:28 <mmorrow> it's pretty cool
03:17:42 <Twey> My connection's being a pain :-P  Takes five minutes to load anything.
03:17:44 <Twey> mmorrow: Woah.
03:17:56 <Twey> Oh, I see.
03:18:09 <mmorrow> here's ghci's bytecode interpreting code: http://darcs.haskell.org/ghc/rts/Interpreter.c
03:18:20 <mmorrow> (one of my fav C progs btw)
03:18:23 <Twey> I need to finish SICP at some point.
03:18:36 <mmorrow> 1000 line long function with many many gotos :)
03:18:42 <Deewiant> and tabs mixed with spaces
03:18:46 <jeffz> gotos are awesome
03:18:54 <Twey> Holy crap
03:19:04 <Twey> And what lines
03:19:06 <Twey> #define BCO_NEXT_64   (bciPtr += 4, (((StgWord) instrs[bciPtr-4]) << 48) + (((StgWord) instrs[bciPtr-3]) << 32) + (((StgWord) instrs[bciPtr-2]) << 16) + ((StgWord) instrs[bciPtr-1]))
03:19:21 <Twey> Ahhh, the good old comma operator
03:19:48 <mmorrow> here's where the bytecode is actually assembled: http://moonpatio.com/docs/ghc/src/ByteCodeAsm.html
03:19:49 <lambdabot> Title: ghci/ByteCodeAsm.lhs
03:20:12 <mmorrow> and here are the instructions in haskell: http://moonpatio.com/docs/ghc/src/ByteCodeInstr.html
03:20:13 <lambdabot> Title: ghci/ByteCodeInstr.lhs
03:20:17 <Deewiant> more tabs mixed with spaces
03:20:37 <mmorrow> oops, i meant:
03:20:46 <mmorrow> s/ghc is part haskell, part .../ghci is ..../
03:20:47 <Twey> What the heck's this?  I'm no C programmer, but even I can tell this is paltry
03:20:54 <mmorrow> (in case that wasn't clear)
03:21:31 <Twey> for (i = 0; i < 27; i++) it_ofreq[i] = 0; for (i = 0; i < 27; i++) for (j = 0; j < 27; j++) it_oofreq[i][j] = 0;
03:21:46 <mmorrow> Twey: start hacking :) one thing that needs fixin is how "fix id" blows the stack if it's in bytecode
03:21:50 <mmorrow> > fix id
03:21:51 <lambdabot>   * Exception: stack overflow
03:21:56 <Twey> That's taking the avoidance of braces just a little too far :-P
03:22:01 <mmorrow> in compiled code, it'll run forever in constant space
03:22:02 <Twey> Huh
03:22:10 <Twey> Yeah
03:22:15 <Twey> Is that just due to the optimisation?
03:22:23 <Deewiant> Twey: that's how I'd write that
03:22:27 <mmorrow> i believe so, but i'm not sure which exactly
03:22:35 <Deewiant> well, I might use memset, but anyhoo
03:22:38 <mmorrow> the path from source to bytecode is:
03:22:54 <Twey> Deewiant: Two loops over the same thing?
03:23:04 <mmorrow> input file or String -> HsSyn -> CoreSyn -> bytecode
03:23:09 <mmorrow> and for compiled code:
03:23:20 <mmorrow> input file or String -> HsSyn -> CoreSyn -> StgSyn -> Cmm -> asm
03:23:21 <Twey> Without jumping ahead in the latter?
03:23:38 <Deewiant> Twey: ah, you mean that it_ofreq[i] should be set in the latter loop?
03:23:40 <mmorrow> so it must some optimization of StgSyn and/or Cmm
03:23:46 <Twey> Is this some mad C thing of which I'm unaware?
03:23:53 <Twey> Deewiant: That or, yes, memset() :)
03:24:11 <Deewiant> Twey: well, it could be an optimization thing, but more likely it's just for clarity; setting one variable at a time
03:24:36 <granden> Hi if I do lex on a string like this, "Hi my name is" I get [("Hi"," my name is")] How could i get that Hi out so I could do a comparision like x = "Hi"
03:24:52 <Deewiant> Twey: (optimization would be for memory access patterns; if the two arrays are in different locations the access isn't sequential and thus possibly significantly slower)
03:25:01 <Twey> granden: Pattern-match, or head . fst (unsafe)
03:25:02 <mmorrow> but it also may not be due to optimization and be a product of how the bytecode is interpreted. i don't know enough about what's happening yet to really know why fix id overflows the stack
03:25:27 <granden> Twey: head x ?
03:25:29 <granden> Hmm
03:25:54 <Twey> Deewiant: It doesn't really matter: it's still looping over one of them twice instead of once
03:26:22 <Twey> granden: We'd generally prefer the use of 'words' though.
03:26:29 <kaol> > ((=="Hi") . fst . head) [("Hi"," my name is")]
03:26:30 <lambdabot>   True
03:26:38 <Deewiant> Twey: the arrays are different, in case you didn't notice... or what do you mean?
03:26:55 <Deewiant> it_ofreq /= it_oofreq
03:27:25 <granden> Twey: Could I seperate that last part some way as well?
03:28:03 <kaol> > words "Hi my name is"
03:28:05 <lambdabot>   ["Hi","my","name","is"]
03:28:37 <kaol> Parsec is really handy if you have anything more complex
03:28:48 <granden> Hmm
03:28:54 <Twey> > let fst : others = words "Hi my name is" in if fst == "Hi" then "Match!  " ++ unwords others else "Match fail"
03:28:55 <lambdabot>   "Match!  my name is"
03:29:53 <granden> Hmm, I think you lost me :D
03:30:01 <Twey> Deewiant: Oh, that's what you meant by non-sequential access?  Does that really matter?  I thought it was the same cost in RAM
03:30:43 <Twey> granden: We assign the pattern `fst : others` to `words "Hi my name is"` (that is to say, ["Hi", "my", "name", "is"])
03:31:02 <granden> Ok
03:31:03 <Twey> granden: Then you've got "Hi" in fst, and ["my", "name", "is"] in others
03:31:04 <mmorrow> granden: alternatively, you can use unzip as a first step
03:31:16 <Deewiant> Twey: It does matter, yes. http://people.redhat.com/drepper/cpumemory.pdf
03:31:18 <lambdabot> Title: What Every Programmer Should Know About Memory
03:31:23 <mmorrow> , unzip [("Hi"," my name is"),("asdfgfdsdfds",[])]
03:31:35 <lunabot>  (["Hi","asdfgfdsdfds"],[" my name is",""])
03:31:55 <mmorrow> , unzip [("Hi"," my name is")]
03:31:57 <lunabot>  (["Hi"],[" my name is"])
03:32:16 <Twey> Deewiant: Oho, thanks :)
03:32:25 <Twey> :t unzip
03:32:27 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
03:32:59 <Twey> Oh, right.  [] == ""
03:33:33 <mmorrow> , (\xs -> case unzip xs of ([],ys) -> (Nothing, ([],ys)) ; (x:xs,ys) -> (Just x, (xs,ys))) [("Hi"," my name is")]
03:33:36 <lunabot>  (Just "Hi",([],[" my name is"]))
03:34:35 <mmorrow> i like using [] instead of "", since i find "" hideous :)
03:34:44 <granden> http://pastebin.com/m298a0447
03:34:47 <granden> I got it like that
03:34:50 <Twey> mmorrow: But [] is just confusing :-P
03:35:22 <mmorrow> Twey: by that same logic, return, fmap, ... are just confusing..
03:35:27 <granden> Need to get out each word by each to be doing comparisions on it to know which number it is.
03:35:49 <Twey> Dammit, I meant to learn Danish this week :(
03:35:58 <granden> Twey: Oh
03:36:04 <Twey> mmorrow: Not so much... I'm talking about types
03:36:10 <granden> Danish numbers is really strange :)
03:36:24 <Twey> granden: Yeah, I hear... especially 'five and a half' :-\
03:36:32 <Twey> mmorrow: "" makes it clear that it's intended to be a string
03:36:35 <Twey> mmorrow: [] doesn't
03:36:43 <shapr> Danish sounds a lot like Swedish to me.
03:36:53 <granden> :)
03:36:57 <mmorrow> is mer==tail ?
03:37:17 <mmorrow> or what is mer?
03:37:23 <granden> mer is my outher function that should take care of the rest of the string
03:37:24 <shapr> more in Swedish
03:37:25 <Twey> mmorrow: Can't be
03:37:30 <mmorrow> ah, ok gotcha
03:37:46 <granden> I could paste the complete
03:37:50 <granden> maybe it makes mor esense
03:38:22 <granden> http://pastebin.com/m52776996
03:40:13 <granden> Do you see what it is I want to accomplish? Some way I think Im lost :)
03:41:30 <mmorrow> granden: this might make things easier http://pastebin.com/m22f61cb9
03:42:08 <mmorrow> and that also won't crash the prog if en2ni gets an empty list
03:42:39 <granden> Wow, that is really out of my league :D
03:42:43 <granden> But I will look into it.
03:42:50 <mmorrow> no way, it's easy :)
03:42:57 <granden> :)
03:43:03 <granden> env = {
03:43:04 <granden> [*
03:43:11 <granden> That part should I end it with something special
03:43:18 <mmorrow> f xs@(x:_) -> (x,xs)  ====  f (x:xs) -> (x,x:xs)
03:43:19 <granden> or just make a list of all numbers?
03:44:21 <mmorrow> you just make a list of pairs of (String, Int), associating the correct number with a given string
03:44:28 <granden> Okej
03:44:36 <mmorrow> , zip ["asd","qwe","trew","qwe"] [0..]
03:44:39 <lunabot>  [("asd",0),("qwe",1),("trew",2),("qwe",3)]
03:44:55 <mmorrow> , zip ["asd","qwe","trew","qwe"] [42,1234321234,3,4,5,232]
03:44:58 <lunabot>  [("asd",42),("qwe",1234321234),("trew",3),("qwe",4)]
03:45:19 <mmorrow> , (unzip . zip) ["asd","qwe","trew","qwe"] [42,1234321234,3,4,5,232]
03:45:21 <lunabot>  luna: Couldn't match expected type `[(a, b)]'
03:45:30 <mmorrow> , unzip (zip ["asd","qwe","trew","qwe"] [42,1234321234,3,4,5,232])
03:45:33 <lunabot>  (["asd","qwe","trew","qwe"],[42,1234321234,3,4])
03:45:38 <Twey> Heh, I was doing it with a list, then realised that there were duplicates :(
03:46:37 <telexicon> im attempting to use 'try' with parsec but it continues to fail the parse anyways and not try the second option
03:47:36 <telexicon> where would i put the try function in this? prefix = do { h <- hostname; return (Server h) } <|> do { n <- nick; return (Client n Nothing Nothing) }
03:47:40 <granden> mmorrow: When I ouse your code it says something about couldn't match type [Char] agains infered Char
03:47:43 <granden> or similar.
03:48:15 <granden> Excpected: [[Char]]
03:48:27 <granden> Inferred type: [Char]
03:49:14 <Philippa> telexicon: do {h <- try hostname; return ...} <|> ...
03:49:24 <Philippa> (or you can put it before the first do)
03:50:16 <telexicon> Philippa, i still get a parse error
03:50:30 <mmorrow> granden: it looks like you're trying to treat 'env' like a [(Char,Int)] instead of a [(String,Int)]
03:50:52 <telexicon> Philippa, if i remove the first option, then it works.. but even with try it doesnt try the second option if the first fails
03:50:55 <mmorrow> one way you could probably do what you want is do s/c/[c]/
03:51:02 <mmorrow> @type 'a'
03:51:03 <lambdabot> Char
03:51:06 <mmorrow> @type ['a']
03:51:07 <lambdabot> [Char]
03:51:13 <mmorrow> @type ['a'] == "a"
03:51:15 <lambdabot> Bool
03:51:15 <Philippa> telexicon: odd. I'd have to see the inner parsers there...
03:51:19 <mmorrow> > ['a'] == "a"
03:51:20 <lambdabot>   True
03:51:32 <mmorrow> > 'a' == "a"
03:51:33 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
03:51:46 <mmorrow> > "a" == 'a'
03:51:47 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
03:51:52 <granden> mmorrow: But I just copied your code.
03:52:12 <granden> http://pastebin.com/m31bd285d
03:52:14 <granden> Like that
03:52:41 <granden> Oh I missed the ending ] in env2 in the paste
03:52:55 <mmorrow> what is the type of the list you're passing to et2ni?
03:53:19 <mmorrow> my code assumes that it's a [String], but from your error msg it looks like you're giving it a [Char]
03:53:33 <granden> [(String,[Char])]
03:53:39 <telexicon> Philippa, http://slexy.org/view/s2W3Q4Dkmp
03:53:49 <lambdabot> Title: Slexy 2.0
03:53:51 <granden> Im using, lexer like this, dansk (lex str)
03:53:58 <mmorrow> granden: oh, ok. one sec
03:53:59 <granden> To get the words seperated.
03:54:10 <mmorrow> what is the type of 'mer'?
03:54:29 <mmorrow> and what's the type of ti2nitten?
03:54:42 <granden> ti2nitten should do the same as en2ni
03:54:46 <granden> mer is like
03:54:48 <granden> mer (x:rakneord) | x == "og" = tyve2halvfems (rakneord) | otherwise = 0
03:54:54 <mmorrow> ok
03:54:55 <granden> I haven't figured it out really
03:55:01 <granden> But it should look if the next word is an og
03:55:04 <mmorrow> so it looks like:
03:55:26 <mmorrow> en2i :: [(String,String)] -> Int
03:55:34 <mmorrow> ([Char] === String)
03:55:36 <granden> haha yeah . :D
03:55:44 <mmorrow> :)
03:56:09 <mmorrow> so, as you've written it above, mer :: [String] -> Int
03:56:24 <cpfr> hey
03:56:37 <granden> mmorrow: Yeah
03:56:48 <cpfr> what is a good way to access libraries i installed through cabal-install
03:56:54 <mmorrow> but since you're giving mer the list that you gave to et2ni, the types don't match
03:57:18 <granden> mmorrow: Mer should just have the rest of the list.
03:57:19 <granden> Like
03:57:19 <Philippa> telexicon: what's your test input?
03:57:25 <granden> if the first word is to
03:57:31 <granden> then it should have everything except to
03:57:51 <granden> x:xs, x=="to" = 2 + mer xs
03:57:53 <granden> Like that
03:57:55 <granden> Something
03:57:55 <mmorrow> ok, so maybe you want et2ni :: [String] -> Int
03:57:58 <telexicon> Philippa, parseTest message ":test`` cmd"
03:58:09 <granden> mmorrow: If it is possbile someway.
03:58:16 <granden> But lexer just gives me [String,String]
03:58:41 <mmorrow> um, what's the type of lexer?
03:58:55 <mmorrow> do you mean (String,String)?
03:59:07 <granden> *** Type           : [(String,[Char])]
03:59:10 <granden> It says in my console
03:59:13 <mmorrow> ok
04:02:07 <shapr> cpfr: hi
04:02:21 <mmorrow> granden: ok, i think this should work http://pastebin.com/m15745659
04:02:24 <cpfr> hey shapr
04:02:29 <shapr> How's code?
04:02:35 <cpfr> alright
04:03:01 <granden> mmorrow: Ok, then I have to find a way to get (lex str) to a String.
04:03:07 <granden> mmorrow: Did you have a way for that
04:03:13 <cpfr> shapr, any idea about my cabal-install question
04:03:16 <mmorrow> granden: doing ((x,xs):_) makes the assumption that lexer only ever gives you a [] or a [("asasd","asd")]
04:03:20 <shapr> What was your questions?
04:03:25 <Philippa> telexicon: okay, that's got me stumped too :-(
04:03:28 <shapr> Oh
04:03:34 <telexicon> Philippa, :(
04:03:36 <shapr> cpfr: Import them?
04:03:51 <mmorrow> granden: i thought you said   lex :: String -> [(String,String)]
04:04:09 <mmorrow> if so, then you can just do:
04:04:16 <PeakerWork> does haskell.org have mirrors for the ghc downloads?
04:04:22 <mmorrow> et2ni (lex "aasdsdfgg")
04:04:32 <cpfr> well they arent in a standard location
04:04:38 <granden> et2ni (lex "to og halv firs"
04:04:38 <shapr> cpfr: If you create a .cabal file for your application/library, and it describes the installed libraries as dependencies, they'll be automatically added to the includes when you run "cabal install" in the directory.
04:04:42 <granden> Whad that work?
04:04:49 <shapr> cpfr: Is that what you mean?
04:05:00 <cpfr> do i know ya shapr?
04:05:05 <cpfr> of no
04:05:09 <PeakerWork> the download from haskell.org is pretty slow at 20K/sec or so (70 megs!)
04:05:09 <mmorrow> granden: from the information i have of your program, it looks like it would work to me
04:05:10 <cpfr> .cabal/ is a directory
04:05:11 <shapr> cpfr: I'm your friendly helpful #haskell denizen!
04:05:15 <granden> mmorrow: Ok
04:05:19 <cpfr> i love #haskell!
04:05:27 <cpfr> its so friendly
04:05:35 <shapr> cpfr: Actually, I'm convinced I recognize your name, but I don't remember where I've seen it before.
04:05:41 <mmorrow> granden: good luck
04:05:55 <granden> Thanks
04:06:15 <shapr> cpfr: In any case, does that answer your question?
04:06:22 <cpfr> not really
04:06:28 <shapr> About cabal, rather than whether you know me? :-)
04:06:37 <cpfr> yea about cabal
04:06:38 <granden> mmorrow: ERROR "C:\Users\andreas\workspace\S2\src\S3.hs":30 - Syntax error in expression (unexpected `;', possibly due to bad layout)
04:06:42 <granden> Hmm
04:06:49 <granden> But I dont use any ;  :(
04:06:53 <shapr> cpfr: So, what am I missing? How can I help you?
04:06:53 <cpfr> i really just want to be able to tell ghc to look into another directory for libraries
04:06:56 <shapr> Oh
04:06:57 <granden> et2ni []       = 0
04:07:00 <granden> Thats line 30
04:07:04 <shapr> -i ?
04:07:16 <granden> 29
04:07:28 <granden> if I dont remove the et2ni :: [(String,String)] -> Int
04:07:41 <C-Keen> can the hoogle search functionality be build into ghci?
04:07:50 <shapr> cpfr: Have you tried -I and -i command line switches?
04:08:00 <cpfr> nope
04:08:15 <shapr> You can directly include a directory that way.
04:08:30 <granden> mmorrow: 0: parse error (possibly due to bad indentation)
04:08:37 <granden> Thats what i get in eclipse.
04:08:57 <granden> Doh
04:08:58 <granden> Sorry
04:09:00 <granden> my misstake
04:09:13 <shapr> cpfr: In general, libraries installed with cabal-install are most easily included by adding them to the Build-Depends: line in your .cabal file.
04:09:14 <mmorrow> oops, no ']' at the end of env2
04:09:18 <granden> Yes
04:09:22 <cpfr> ah ok
04:09:23 <granden> I found it as well. :)
04:09:27 <cpfr> alright it works!
04:09:30 <cpfr> thanks shapr
04:09:31 <shapr> cpfr: Would you like to see a demo .cabal file?
04:09:35 <shapr> cpfr: Sure, glad I can help!
04:09:39 * shapr bounces cheerfully
04:09:46 <cpfr> i got plenty of .cabal files :)
04:09:50 <shapr> Yay!
04:09:52 <cpfr> now as to familiarity
04:10:06 <shapr> Scary thought, I was in the room when cabal was invented!
04:10:12 <cpfr> it depends on what other programming languages you use
04:10:14 <cpfr> this one?
04:10:18 <cpfr> howd it happen?
04:10:44 <hackage> Uploaded to hackage: peano-inf 0.3
04:10:45 <shapr> Isaac Jones was looking at Python's distutils, and he wanted them for Haskell, and he was my roommate at a conference, so we talked about it for hours.
04:11:15 <shapr> Anyway, what about language familiarity?
04:13:13 <shapr> Did my connection die?
04:13:20 <shapr> Or did it get really quiet in here?
04:14:08 <Philippa> quiet
04:14:11 <shapr> Bah, time for work...
04:14:12 * shapr &
04:14:14 <granden> mmorrow: Hmm if I would like from the mer function return all the indata. Couldn't I just do tyve2halvfems ((x,xs):_) ?
04:17:25 <Clockwork> Hey
04:17:36 * shapr ticks
04:18:20 <Clockwork> I started to read learnhaskelforagreatergood, what editor/compiler is the author using for that colourful syntax lightening?
04:19:43 <quicksilver> Clockwork: I think you might be doing it by hand, but you can ask him
04:19:47 * quicksilver pokes BONUS 
04:19:49 <BONUS> w00t its me
04:20:01 <shapr> cpfr: Yes, that must be where I saw your name, somewhere in CL/Perl/scheme/Oz/ion land.
04:20:06 <shapr> ?
04:20:10 * shapr pokes BONUS
04:20:16 <BONUS> y0 guys :]
04:20:18 <cpfr> ion3
04:20:19 <BONUS> anyway im using http://code.google.com/p/syntaxhighlighter/
04:20:20 <lambdabot> Title: syntaxhighlighter - Google Code
04:20:22 <cpfr> yea
04:20:29 <shapr> cpfr: I switched to xmonad though.
04:20:36 <cpfr> probably in scheme or #oz
04:20:41 <shapr> BONUS: That was so fast I thought you had augmented your client with botness!
04:20:50 <BONUS> haha
04:20:53 <BONUS> i just happened to be here
04:21:00 <BONUS> lucky i guess!
04:21:06 <shapr> yeah, bonus!
04:21:15 <Clockwork> oh okay, so be it
04:21:19 <BONUS> anyway i got this SyntaxHighlighter plugin for Haskell, adapted it a bit and wrote my own css for it
04:21:19 <cpfr> why did you change to xmonad
04:21:39 <Clockwork> then I will maybe start to develop haskell code in eclispe, as we start to code java next semester @university
04:21:45 <shapr> cpfr: Easier to configure, keymappings didn't change all the time, and it does more stuff for less work.
04:22:02 <cpfr> what does it do more?
04:22:08 <BONUS> cool, although i dont know if eclipse has any haskell integration
04:22:18 <BONUS> but haskell is so terse you usually dont need help from IDEs
04:22:24 <shapr> cpfr: xmonad supported floating windows on top of tiled windows early on, for a long time ion did not support that at all (I started with ion1).
04:22:31 <cpfr> i couldnt really figure that out when i tried
04:22:41 <BONUS> in java, you spend like 20% of the time thinking about the code and 80% writing it, which is where the IDE comes in handy
04:22:47 <BONUS> whereas in haskell it's the other way around
04:22:51 <cpfr> well xmonad vs. ion-current
04:23:08 <shapr> cpfr: Anyway, I wish I had more time to describe to you what I prefer about xmonad as compared to ion3 (last version I was using) but I must pack up my stuff and go to work.
04:23:12 <shapr> cpfr: Perhaps another time?
04:23:12 <Clockwork> there is a Haskell Plugin, yeah well, actually you are right, but I have no fine editor yet, just some things like notepad2.exe or notepad++.exe
04:23:26 <BONUS> those are a-ok for haskell
04:24:02 <Clockwork> well, then no uber editor for me :S
04:24:15 <quicksilver> eclipse's haskell integration is bitrotting and was never much good
04:24:17 <cpfr> shapr, sure thing
04:24:22 <cpfr> thanks again for the help
04:24:26 <quicksilver> a really clever intellisense like thing for haskell would be hard
04:24:27 <BONUS> you dont need an uber editor when you have an uber programming language :)
04:24:28 <quicksilver> (but awesome)
04:24:43 <Clockwork> word ^^
04:24:45 <quicksilver> however, as BONUS says, many of the things Java programmers need their IDEs for are much easier in haskell.
04:25:06 <quicksilver> there is much less boilerplater and refactorings are much easier anyway
04:25:20 <quicksilver> a decent editor is always handy though.
04:25:22 <Clockwork> yeah I did not want to start coding haskell in eclipse for the ide, just two get in touch with Eclipse before
04:25:28 <Clockwork> two=to
04:25:32 * quicksilver recommends emacs.
04:26:03 <Clockwork> for windows avaible?
04:26:08 <luite> yes
04:26:26 <Clockwork> ok I think some of my fellow student uses emacs
04:26:36 <Gumyummy> Is there a function in the standard library to nest equal and adjacent elements of a list? For example: [1,2,3] = [[1],[2],[3]], [1,1,3] = [[1,1],[3]]
04:26:41 <BONUS> i use gvim in windows
04:26:49 <luite> Clockwork: it will take you some time to customize it (and install haskell-mode), but it's really useful
04:26:52 <Gumyummy> Finding it _really_ difficult to implement :(
04:26:57 <quicksilver> > group [1,1,3]
04:26:58 <lambdabot>   [[1,1],[3]]
04:27:02 <quicksilver> Gumyummy: like that?
04:27:14 <granden> http://pastebin.com/mc7edeae - Whats wrong?"
04:27:15 <Gumyummy> > group [1,1,3,1]
04:27:16 <lambdabot>   [[1,1],[3],[1]]
04:27:22 <Gumyummy> Ha.
04:27:23 <Gumyummy> Yes ;)
04:27:25 <Gumyummy> Thanks
04:27:26 <granden> parse error (possibly incorrect indentation)
04:27:28 <granden> I get
04:27:38 <granden> on row 38
04:27:41 <Clockwork> okay, ... off for good, cu
04:27:43 <dcoutts> you need a variation on the groupBy function
04:27:48 <BONUS> you forgot the =
04:27:58 <BONUS> imho
04:28:01 <quicksilver> on env5 and env6
04:28:03 <dcoutts> that compares adjacent elements rather than the first group element with the remaining
04:28:10 <shapr> cpfr: Sure, anytime I can help.
04:28:11 <granden> Lol
04:28:13 <granden> Thank you
04:29:15 <Gabbie> Gumyummy, tub?
04:29:55 * dcoutts realises he misunderstood the question
04:30:11 <Gumyummy> Oui madame!
04:30:24 <Gabbie> :)
04:36:05 <Gumyummy> @src group
04:36:05 <lambdabot> group = groupBy (==)
04:36:21 <Gumyummy> @src groupBy
04:36:22 <lambdabot> groupBy _  []       =  []
04:36:22 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
04:36:22 <lambdabot>     where (ys,zs) = span (eq x) xs
04:47:19 <vixey> trying to teach my family combinatory logic :/
04:48:02 <byorgey> vixey: hehe, any success?
04:48:20 <vixey> not yet
04:48:37 <vixey> but I have not given up either :)
04:49:10 <ivanm> anyone know how to specify use of base-3 with ghci-6.10.1?
04:49:32 <vixey> It's sort of silly, they all have rough ideas who Godel and Haskell are
04:49:50 <vixey> I think I must ramble about things a lot
04:52:28 <vixey> byorgey, I am trying to add inductive types to my language today .. it's very hard
04:52:50 <vixey> ivanm, You want to specify that in a .cabal?
04:53:00 <byorgey> vixey: yeah, inductive types are hard indeed!
04:53:11 <ivanm> vixey: not atm I don't ;-)
04:53:16 <byorgey> I am trying to add sum types to my language today =)
04:53:31 <ivanm> since AFAIK ghci doesn't read the .cabal file...
04:54:01 <byorgey> ivanm: haha, for some reason I read that as "base 3", i.e. you wanted to type numbers like "1102022102", and I was like, wtf?
04:54:10 <ivanm> byorgey: lol
04:54:16 <idnar> haha
04:56:01 <vixey> I guess this is some weird OCD thing
04:56:15 <vixey> I start by writing foo ... = throwError "not implemented yet"
04:56:21 <vixey> then I delete it and write the actual code
04:56:37 <vixey> (usually with a day inbetween)
04:57:06 <mmorrow> vixey: heh
04:57:35 <PeakerWork> ivanm: when using cabal to build stuff, I think you can say "base >= 4" or "base < 4"
04:58:04 <ivanm> PeakerWork: yes, but I'm not using cabal ;-)
04:58:08 <ivanm> I'm trying to load it in ghci
04:58:29 <PeakerWork> ivanm: I think you can use ghc-pkg to manually hide the base you don't want to use
04:58:32 <PeakerWork> ivanm: and then run ghci
04:58:43 <PeakerWork> I think it respects the hidden settings
04:58:47 <dcoutts> ivan: use ghci -package base-3.0.3.0
04:58:52 <ivanm> dcoutts: *nod*
04:59:04 <PeakerWork> or you can wait until someone who knows what he's talking about replies ;-)
04:59:17 <ivanm> PeakerWork: heh
04:59:41 <ivanm> dcoutts: *sigh* that means I'll have to change the settings for haskell-mode and then remember to change them back :s
05:00:43 <PeakerWork> ivanm: or add an interactive parameter to the ghci invocation in the elisp?
05:01:21 <ivanm> PeakerWork: making it interactive would be just as annoying...
05:01:23 <arjanb> vixey: it's nothing weird just inertia, between wanting to code something and getting your mind to it
05:10:44 <hackage> Uploaded to hackage: process 1.0.1.1
05:13:33 <vixey> oh no..
05:13:43 <quicksilver> the bridge has gone
05:13:45 <vixey> I'm getting the error from monomorphism restriction but I turned it off
05:13:47 <quicksilver> poor old red can't carry on
05:15:00 <Deewiant> vixey: if you're in GHCi, ":r" after ":set -XNoMonomorphismRestriction" isn't enough, you have to ":l"
05:15:54 <ksf> Deewiant, sounds like a feature, not a bug.
05:16:05 <Deewiant> shrug :-P
05:23:11 <scorch> I want to join all elements in a list. E.g. ["1","g","E"] becomes ["1gE"]
05:23:24 <ivanm> scorch: return . concat
05:27:00 <vixey> :t return . concat
05:27:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[a]] -> m [a]
05:27:10 <vixey> :t join
05:27:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:27:32 <vixey> > (return . join) ["1", "g", "E"]
05:27:33 <lambdabot>       No instance for (Show (m [Char]))
05:27:33 <lambdabot>        arising from a use of `show' a...
05:27:41 <vixey> > (return . join) ["1", "g", "E"]  :: [String]
05:27:43 <lambdabot>   ["1gE"]
05:29:24 <scorch> ivanm, vixey: thanks!
05:29:50 <ivanm> scorch: no worries
05:33:55 <quicksilver> Beelsebob: is fieldtrip only about surfaces? or can it do loaded models etc too?
05:37:48 <mapreduce> quicksilver: Remember my question about binary format combinators?  Does the story look any cheerier if you're talking instead about transformation from format to format?
05:38:35 <vixey> mapreduce, is there any fundamental difficulty with binary format combinators?
05:38:40 <quicksilver> mapreduce: did you read the paper sjanssen posted?
05:39:00 <quicksilver> (I don't think format to format particularly changes the nature of the problem)
05:39:02 <mapreduce> No, something's messed up on my system regarding PDFs just today.
05:39:05 <quicksilver> ah
05:39:12 <quicksilver> well, you should, because it seems to be the answer ;)
05:39:13 <mapreduce> I will fix that.
05:39:19 <mapreduce> Ok, great.
05:39:22 <quicksilver> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf
05:39:24 <lambdabot> Title: FUNCTIONAL PEARL Pickler Combinators
05:39:29 <quicksilver> there is always google's "view as html"
05:39:32 <quicksilver> if you're despearate ;)
05:39:37 <mapreduce> Sure.
05:39:52 <PeakerWork> @hoogle fix
05:39:52 <lambdabot> Data.Function fix :: (a -> a) -> a
05:39:52 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
05:39:52 <lambdabot> module Control.Monad.Fix
05:40:01 <PeakerWork> @hoogle bracket
05:40:01 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
05:40:01 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
05:40:01 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
05:40:04 <mapreduce> I think it's because I experimented with Crossover, and thus shadowed the default PDF viewer with Adobe Reader running in a vm.
05:40:12 <PeakerWork> weird, so hoogle has the parenthesis bug only for bracket, but not for fix? how come?
05:40:37 <Deewiant> maybe it doesn't like IO
05:40:58 <PeakerWork> My guess is that the "hoo" database made for Control.Exception is broken
05:47:23 <PeakerWork> @hoogle (a -> b) -> c
05:47:23 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
05:47:23 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
05:47:23 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:47:31 <PeakerWork> @hoogle (a -> IO b) -> c
05:47:31 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
05:47:31 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
05:47:31 <lambdabot> Foreign.Marshal.Pool withPool :: (Pool -> IO b) -> IO b
05:47:39 <PeakerWork> its ok with IO too
05:48:56 <quicksilver> probably a haddock bug
05:56:43 <PeakerWork> @hoogle eval
05:56:43 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
05:56:43 <lambdabot> Control.Monad.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
05:56:43 <lambdabot> Control.Monad.RWS.Lazy evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
05:57:27 <PeakerWork> how can I compile/eval a string with Haskell code?
05:57:32 <PeakerWork> into an arbitrary type of my choice?
05:57:57 <vixey> peaker, I think you can do it the same way as lambdabot
05:58:06 <PeakerWork> I want to write a little awk replacement, which I'd call hawk, that lets me replace a little awk program with a little Haskell expression
05:58:12 <PeakerWork> vixey: how does lambdabot do it?
05:58:17 <PeakerWork> vixey: feed it into ghci or such?
05:58:59 <daf> PeakerWork: I have http://hpaste.org/11954
05:59:05 <daf> it's crude
05:59:15 <telexicon> anyone here good with parsec can tell me why the try combinator doesn't work at all, it continues to fail anyways and not try the right side <|> option
05:59:34 <EvilTerran> telexicon, i assure you that the try combinator works
05:59:50 <EvilTerran> telexicon, but you may be using it wrong - could you show us some code? (hpaste.org/new)
05:59:50 <PeakerWork> daf: thanks
06:00:48 <daf> PeakerWork: something that took flags similar to perl's -n/-p/-i could be very useful
06:01:29 <PeakerWork> daf: I wish Haskell had an   (eval :: forall a. Code -> a) or such function
06:01:44 <daf> hmm
06:01:51 <telexicon> EvilTerran, http://hpaste.org/11955
06:01:53 <PeakerWork> makes more sense to have   (eval :: forall a. Code -> Maybe a)  or such
06:02:34 <telexicon> EvilTerran, it fails anyways with unexpected "`";
06:02:37 <vixey> PeakerWork, Typeable or something
06:02:41 <vixey> PeakerWork, Typeable a =>
06:02:57 <vixey> but
06:03:11 <vixey> I get the feeling calling EVAL on a String is not super haskelly
06:03:21 <daf> PeakerWork: mightn't it be useful to change your behaviour on the type of the expression?
06:04:12 <PeakerWork> vixey: Maybe (String -> Code) and (Code -> a) should be separate
06:04:40 <PeakerWork> daf, vixey: I think that when you eval arbitrary code, you should know exactly what type you expect
06:04:45 <daf> forever (eval . readCode)? :)
06:04:48 <vixey> I recommend checking lambdabot source code
06:05:11 <ksf> does anyone have access to http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6V8M-4CKFN5S-4&_user=10&_coverDate=11%2F30%2F2004&_rdoc=1&_fmt=&_orig=search&_sort=d&view=c&_version=1&_urlVersion=0&_userid=10&md5=5376048a5d622e6d8f3aeff6b025f70f  ?
06:05:13 <vixey> or just using ghci (?)
06:05:14 <lambdabot> Title: ScienceDirect - Operations Research Letters : Match twice and stitch: a new TSP  ..., http://tinyurl.com/6aemgf
06:05:47 <PeakerWork> daf: heh, I have "hawk 'lines <$> getContents >>= (mapM putStrLn)'" working ;)
06:06:06 <PeakerWork> daf: http://hpaste.org/11954#a1
06:06:09 <ksf> the abstract is making me drool.
06:06:47 <mbz> hi
06:06:58 <PeakerWork> Is there a String->String function to search&replace substrings? or regexps?
06:07:09 <vixey> @go KMP haskell
06:07:20 <vixey> @go boyer-moore haskell
06:07:21 <lambdabot> http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details
06:07:21 <lambdabot> Title: Knuth-Morris-Pratt in Haskell - 21 thoughts
06:07:23 <lambdabot> No Result Found.
06:07:41 <mbz> > if 0 /= 1then 2else 3
06:07:43 <lambdabot>   2
06:08:01 <EvilTerran> telexicon, hm... i note the only parser you have there that accepts (`)s is "special", so i guess something's failing to backtrack en route to "special"
06:08:49 <EvilTerran> telexicon, ah, i see; "hostname" is successfully parsing ":test"
06:08:53 <telexicon> EvilTerran, yeah, prefix is the point where it could be one or the other,
06:09:18 <mbz> I wonder why "1then 2else" works
06:09:28 <mbz> bogus number parser?
06:09:30 * BeelsebobWork_ ponders why people use parser combinators in a monadic way
06:09:41 * osfameron wonders *how*
06:09:55 <telexicon> BeelsebobWork_, probably because they cant find any examples of how to use it better
06:10:00 * vixey supposes they do it in the dining room with the candlestick
06:10:16 <BeelsebobWork_> hyphenAlphaNum = concat <$> many (many (char '-') <^(++)^> many1 alphaNum)
06:10:22 <osfameron> Higher Order Perl has a very good chapter on functional parser combinators, but it's a) in perl and b) not monadic, as far as I can tell
06:10:25 <vixey> <^(++)^> is so cute :p
06:10:25 <BeelsebobWork_> so much neater
06:10:36 <telexicon> BeelsebobWork_, yeah it is
06:10:41 <BeelsebobWork_> sir pig the apendor!
06:10:46 <EvilTerran> telexicon, i think you could use manyTill to make sure hostname gets everything before the ' '
06:10:48 <vixey> yes!
06:10:55 <bender183> hi
06:11:03 <telexicon> BeelsebobWork_, but how would i know to do that
06:11:22 <BeelsebobWork_> telexicon: get told by a (not so) friendly guy in #haskell?
06:11:24 <BeelsebobWork_> :D
06:11:50 <osfameron> :t <^(++)^>
06:11:51 <lambdabot> parse error on input `<^'
06:11:53 <BeelsebobWork_> telexicon: it wasn't really meant to be a go at you in particular -- more at the guy who wrote parsec, and introduced tutorials that did it monadically
06:11:58 <osfameron> :t (<^(++)^>)
06:11:59 <lambdabot> parse error on input `)'
06:12:02 <telexicon> BeelsebobWork_, <$> and <^(++)^> dont work
06:12:19 <BeelsebobWork_> telexicon: you'll need to import Control.Applicative and Control.Applicative.Infix
06:12:26 <telexicon> BeelsebobWork_, ok
06:12:38 <BeelsebobWork_> and you'll need http://hackage.haskell.org/cgi-bin/hackage-scripts/package/InfixApplicative installed
06:12:43 <vixey> :t (<^)
06:12:44 <lambdabot> Title: HackageDB: InfixApplicative-1.0, http://tinyurl.com/553fov
06:12:44 <lambdabot> Not in scope: `<^'
06:12:46 <telexicon> figures
06:12:53 <BeelsebobWork_> vixey: http://hackage.haskell.org/packages/archive/InfixApplicative/1.0/doc/html/Control-Applicative-Infix.html
06:12:54 <lambdabot> Title: Control.Applicative.Infix, http://tinyurl.com/5ltsfh
06:13:16 <telexicon> EvilTerran, the problem is, 'ident' is both a valid hostname and nickname
06:13:21 <vixey> wow
06:13:29 <telexicon> or any single alpha string, so its totally ambiguous
06:13:30 <vixey> that haddock thing that makes the documentation seriously sucks
06:13:31 <BeelsebobWork_> vixey: cool, innit?
06:13:37 <telexicon> and thats why im annoyed with irc atm
06:13:40 <BeelsebobWork_> yes, it does vixey
06:13:43 <vixey> oh it is cool
06:13:46 <BeelsebobWork_> it kills my pigs
06:13:50 <vixey> :(
06:13:53 <BeelsebobWork_> they lose their ears
06:13:56 <BeelsebobWork_> I can't figure out how to fix it
06:14:09 <vixey> well I think emailing the guy that wrote haddock might do it
06:14:16 <BeelsebobWork_> true
06:14:18 <vixey> difficult to know in advance
06:14:21 <lilac> ksf: is this what you're looking for? http://ic.engin.brown.edu/pubs/j2.pdf
06:14:22 <BeelsebobWork_> know who it is?
06:14:30 <BeelsebobWork_> was jaffacake wasn't it?
06:14:32 <telexicon> BeelsebobWork_, probably because what you wrote doesnt even make sense to me, so i wouldnt come up with it
06:14:34 <vixey> someone at MS.. I emailed them before about a bug in it
06:14:43 <BeelsebobWork_> telexicon: hmm?
06:14:44 <EvilTerran> telexicon, indeed, the parse is ambiguous
06:15:01 <telexicon> right, so i made a decision
06:15:29 <telexicon> hostnames get priority, but foo` isnt a hostname because ` isnt allowed in hostnames, so i want that to stop parsing the hostname, go back and parse the nickname
06:15:34 <JaffaCake> somebody wanted me?
06:15:55 <BeelsebobWork_> oh sorry, I highlighted you by accident -- you wrote haddock, right?
06:15:55 <EvilTerran> ?type manyTill
06:15:56 <lambdabot> Not in scope: `manyTill'
06:16:00 <EvilTerran> ?hoogle manyTill
06:16:01 <lambdabot> Text.Parsec.Combinator manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
06:16:01 <lambdabot> Text.ParserCombinators.ReadP manyTill :: ReadP a -> ReadP end -> ReadP [a]
06:16:01 <lambdabot> Text.ParserCombinators.Parsec.Combinator manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
06:16:28 <lilac> ksf: you don't happen to have the Kanellakis-Papadimitriou paper, do you? :) or the Glover "Finding a best TSP 4-opt move in quadratic time" paper?
06:16:50 <ksf> nope, sorry.
06:16:51 <JaffaCake> BeelsebobWork_: yes
06:17:17 <BeelsebobWork_> JaffaCake: probably an easy fix, but is there a sensible way to recover the missing <s and >s in http://hackage.haskell.org/packages/archive/InfixApplicative/1.0/doc/html/Control-Applicative-Infix.html
06:17:18 <lambdabot> Title: Control.Applicative.Infix, http://tinyurl.com/5ltsfh
06:17:23 <telexicon> i found a better idea
06:17:35 <ksf> I'm quite limited to open access until i get a new job.
06:17:41 <EvilTerran> telexicon, use manyTill in the definition of hostname so that it only succeeds if the string it's parsed is followed by a ' '?
06:18:36 <mapreduce> I've just been reading the pickling paper ( http://research.microsoft.com/~akenn/fun/picklercombinators.pdf ), and I'm unsure of two things.  The first is probably straightforward, the second is what I'm actually interested in.
06:18:37 <lambdabot> Title: FUNCTIONAL PEARL Pickler Combinators
06:18:51 <telexicon> EvilTerran, or i could move the char ' '; into prefix
06:19:18 <EvilTerran> telexicon, or "notFollowedBy $ satisfy (/=' ')" would work too
06:20:00 <telexicon> ok, so thats fixed.. whats this applicative stuff about then?
06:20:15 <BeelsebobWork_> telexicon: applicative is a slightly less powerful interface than monad is
06:20:23 <BeelsebobWork_> but in being slightly less powerful, it's also more beautiful
06:20:23 <telexicon> and are there other tutorials on parsec besides the parsec docs?
06:20:24 <JaffaCake> BeelsebobWork_: there's missing markup in the source, you need to surround those code fragments with @...@
06:20:27 <BeelsebobWork_> and usually it's powerful enough
06:20:32 <vixey> telexicon, none are as good
06:20:34 <BeelsebobWork_> JaffaCake: ah, cool, thanks
06:20:47 <JaffaCake> BeelsebobWork_: also, read the docs ;)
06:20:47 <mapreduce> 1. If you wanted to specify a pickler that begins with a length then continues with a sequence of bytes, how would you write this?
06:21:01 <EvilTerran> f <$> m1 <*> m2 <*> ... <*> mN = do x1 <- m1; x2 <- m2; ...; xN <- mN; return $ f x1 x2 ... xN
06:21:05 <BeelsebobWork_> JaffaCake: sure -- I didn't really mean to highlight you, but since you turned up, I thought I'd ask
06:21:10 <vixey> mapreduce, is there any fundamental difficulty with binary format combinators?
06:21:15 <EvilTerran> is Applicative in a nutshell
06:21:15 <JaffaCake> no problem
06:21:31 <mapreduce> 2. If you wanted to specify a pickler that describes two such sequences, but the lengths are specified together before the two sequences, how would you do this?
06:21:35 <mapreduce> vixey: I don't know.
06:21:36 <vixey> I prefer  = liftM^N f m1 m2 ... mN
06:21:38 <vixey> or
06:21:42 <vixey> = liftA^N f m1 m2 ... mN
06:21:45 <vixey> since it's applicative
06:21:50 <telexicon> EvilTerran, oh, interesting
06:21:55 <vixey> mapreduce, thought you must have come acrooss some problem  based on what you said
06:21:55 <unenough> @seen Cale
06:21:55 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 9h 16m 7s ago.
06:22:04 <BeelsebobWork_> I prefer the <$> and <*> -- it's more general than liftAn
06:22:13 <BeelsebobWork_> (it doesn't run out of steam at 3 as well)
06:22:26 <vixey> BeelsebobWork, I mean as an equivalence, rather than getting out do notation
06:22:41 <BeelsebobWork_> oh, i see
06:22:56 <vixey> although .. I suppose there are no Applicatives that aren't Monads, are there?
06:23:00 <EvilTerran> vixey, i hadn't seen telexicon use liftM{N} yet, but i saw do-notation in that paste, so i could be more sure of that being familiar
06:23:07 <EvilTerran> vixey, ZipList
06:23:24 <BeelsebobWork_> vixey: there are applicatives that aren't monads
06:23:29 <BeelsebobWork_> but there aren't monads that aren't applicatives
06:23:37 <telexicon> EvilTerran, i haven't used lift at all yet, i still have to learn more
06:23:57 <vixey> ok
06:23:59 <EvilTerran> telexicon, exactly; i avoided liftM{N} because i didn't know if you'd seen it. it's pretty straightforward, though
06:24:01 <EvilTerran> ?src liftM
06:24:02 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:24:03 <EvilTerran> ?src liftM2
06:24:03 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:24:04 <EvilTerran> ?src liftM3
06:24:05 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
06:24:07 <vixey> > liftM2 (,) "foo" barbaz"
06:24:08 <lambdabot>   <no location info>:
06:24:08 <lambdabot>      lexical error in string/character literal at chara...
06:24:13 <vixey> > liftM2 (,) "foo" "barbaz"
06:24:14 <lambdabot>   [('f','b'),('f','a'),('f','r'),('f','b'),('f','a'),('f','z'),('o','b'),('o'...
06:24:15 <telexicon> oh
06:24:17 <telexicon> thats pretty simple
06:24:20 <mapreduce> vixey: I'm trying to write such a library for an inferior language.
06:24:20 <EvilTerran> :)
06:24:22 <vixey> > liftM2 (+) (Just 3) (Just 5)
06:24:24 <lambdabot>   Just 8
06:24:25 <vixey> > liftM2 (+) (Just 3) Nothing
06:24:27 <lambdabot>   Nothing
06:24:36 <mapreduce> vixey: I'm trying to see what Haskell libraries do for case 2 above.
06:24:36 <telexicon> makes sense
06:24:38 <BeelsebobWork_> > "foo" <^(,)^> "barbaz" -- much nicer, shame lambdabot doesn't know about it
06:24:39 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
06:24:55 <vixey> maybe Cale will add it in if you ask?
06:24:59 <EvilTerran> telexicon, and we refer to "liftM0" as just "return" ;)
06:25:04 * vixey hopes so
06:25:06 <telexicon> > liftM2 (+) [1..4] [5..8]
06:25:07 <lambdabot>   [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
06:25:10 <BeelsebobWork_> Cale: pretty please, could you add infix applicative to \bot?
06:25:24 <telexicon> lists are sneaky like that
06:25:25 <Axman6> whoot, our uni just had a $30,000 Sun T2 donated to it by.. well Sun
06:25:34 <Axman6> hopefully i'll get to play with it sometime
06:25:52 <telexicon> its only $30,000 because sun says so
06:26:17 <BeelsebobWork_> it's only $30,000 because sun offer a crap load of support for it
06:26:18 <EvilTerran> @let infixl 3 <^, ^>; (<^) = flip fmap; (^>) = (<*>)
06:26:18 <Axman6> bah, 64 'processors' on a single chip's worth it
06:26:20 <lambdabot>  <local>:11:29:
06:26:20 <lambdabot>      Ambiguous type variable `f1' in the constraint:
06:26:20 <lambdabot>        `...
06:26:22 <vixey> > liftM (reverse) ("foo","bar"
06:26:23 <vixey> > liftM (reverse) ("foo","bar")
06:26:24 <lambdabot>   <no location info>: parse error on input `;'
06:26:25 <lambdabot>       No instance for (Monad ((,) [Char]))
06:26:25 <lambdabot>        arising from a use of `lift...
06:26:31 <BeelsebobWork_> EvilTerran: hehe, that too
06:26:33 <vixey> > liftM (reverse) (Either "foo" "bar")
06:26:34 <telexicon> Axman6, yeah thats pretty awesome
06:26:35 <lambdabot>   Not in scope: data constructor `Either'
06:26:37 <EvilTerran> @let infixl 3 <^, ^>; x <^ f = f <$> x; f ^>x  = f <*> x
06:26:39 <lambdabot>  Defined.
06:26:39 <BeelsebobWork_> but that can get undeffed
06:26:41 <vixey> > liftM (reverse) (Left "bar")
06:26:43 <lambdabot>   Left "bar"
06:26:45 <vixey> > liftM (reverse) (Right "bar")
06:26:46 <lambdabot>   Add a type signature
06:26:47 <EvilTerran> > [1,2,3] <^(+)^> [4,5,6]
06:26:49 <lambdabot>   [5,6,7,6,7,8,7,8,9]
06:26:51 <BeelsebobWork_> :)
06:26:51 <vixey> this is so bad.......
06:27:00 <vixey> defaulting never works for me and monomorphism always gets in my way
06:27:07 <vixey> > liftM (reverse) (Right "bar") :: Error String
06:27:08 <lambdabot>       Class `Error' used as a type
06:27:08 <lambdabot>      In the type `Error String'
06:27:08 <lambdabot>      In an...
06:27:15 <telexicon> lol
06:27:16 <vixey> > liftM (reverse) (Right "bar") :: Either () String
06:27:18 <lambdabot>       No instance for (Error ())
06:27:18 <lambdabot>        arising from a use of `liftM' at <int...
06:27:23 <vixey> > liftM (reverse) (Right "bar") :: Either String String
06:27:25 <lambdabot>   Right "rab"
06:27:26 <BeelsebobWork_> > ["mmm..."] <^(++)^> ["sir pig a lot"]
06:27:28 <lambdabot>   ["mmm...sir pig a lot"]
06:27:31 <BeelsebobWork_> :)
06:27:38 <Axman6> http://news.anu.edu.au/?p=758
06:27:40 <lambdabot> Title: ANU News  Multicore computer to help train more sleek geeks
06:28:45 <telexicon> :t liftM2
06:28:50 <Axman6> i was in his lectures last semester when he was saying that Sun might be doing this
06:28:51 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:28:58 <telexicon> :info liftM2
06:29:12 <telexicon> somebody is a bit overwhelmed
06:29:40 <vixey> telexicon, it's pretty simple,  if you have a monad m,  then liftM2 takes the function  (a -> b -> x)  into the function (ma -> mb -> mx)
06:29:41 <byorgey> haha, now we have the pig operator <^(++)^> as well as the robot monkey operator (:[])
06:29:50 <telexicon> no i understand liftM2
06:29:58 <telexicon> im just trying to find out which module its in
06:30:03 <BeelsebobWork_> byorgey: :D
06:30:08 <EvilTerran> ?hoogle liftM2
06:30:09 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:30:25 <telexicon> vixey, i dunno if im gonna use the terms right, but it lifts the values out of both monads, applies the function f to it, and puts it back in
06:30:57 <Axman6> > lift2M (+) [1..10] [3..5]
06:31:01 <lambdabot>   Not in scope: `lift2M'
06:31:10 <Axman6> > liftM2 (+) [1..10] [3..5]
06:31:11 <vixey> telexicon, inside yeah it does exactly that
06:31:12 <byorgey> the <^ ... ^> thing is pretty cool, but even I squirm at the sight of an eight-character operator...
06:31:13 <lambdabot>   [4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11,12,13,12,13,14,13,14,15]
06:31:18 <jeffersonheard> can I use guards in a lambda form?
06:31:20 <jeffersonheard> I've never tried it
06:31:25 <BeelsebobWork_> > ((:[]) "pigs eat") <^(++)^> ((:[]) " robot monkies")
06:31:26 <vixey> telexicon,  but btw you could be using liftAn instead of liftMn
06:31:27 <lambdabot>   ["pigs eat robot monkies"]
06:31:35 <telexicon> :t liftAn
06:31:37 <lambdabot> Not in scope: `liftAn'
06:31:46 <telexicon> oh right n
06:31:50 <jeffersonheard> like: readIORef >>= \state | state == Foo = bar
06:31:53 <telexicon> :t liftA2
06:31:54 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
06:32:20 <BeelsebobWork_> telexicon: liftA2 == liftM2
06:32:33 <vixey> > liftA2 == liftM2
06:32:35 <lambdabot>       No instance for (Eq ((a -> b -> c) -> f a -> f b -> f c))
06:32:35 <lambdabot>        arisin...
06:32:45 <BeelsebobWork_> (or they should do at least)
06:33:31 <Axman6> > (\ls -> join . ls >>= return) [1..10]
06:33:32 <lambdabot>   Couldn't match expected type `a1 -> m (m a)'
06:33:44 <Axman6> > (\ls -> join $ ls >>= return) [1..10]
06:33:45 <lambdabot>       No instance for (Enum [a])
06:33:45 <lambdabot>        arising from the arithmetic sequence ...
06:33:46 <mmorrow> > (\a b -> a == b `seq` ()) liftM2 liftA2
06:33:47 <lambdabot>       No instance for (Eq ((a1 -> a2 -> r) -> m a1 -> m a2 -> m r))
06:33:47 <lambdabot>        ar...
06:34:01 <byorgey> liftA2 === liftM2 for Applicatives which are also Monads.
06:34:04 <mmorrow> , (\a b -> a == b `seq` ()) liftM2 liftA2
06:34:05 <lunabot>  luna: No instance for (GHC.Classes.Eq
06:34:09 <hesselink> :r
06:34:10 <mmorrow> ah
06:34:28 <mmorrow> , (\a b -> [a,b] `seq` ()) liftM2 liftA2
06:34:30 <lunabot>  luna: Ambiguous type variable `m' in the constraints:
06:34:45 <chr1s> hesselink: that doesn't work here! ;)
06:35:02 <telexicon> whats the point of using <$> then?
06:35:18 <vixey> f <$> x <*> y = liftA2 f x y
06:35:21 <hesselink> chr1s: I know, wrong window :)
06:35:22 <BeelsebobWork_> you get high ns for free
06:35:26 <telexicon> BeelsebobWork_, i was able to turn it into: liftM concat $ many (liftM2 (++) (many (char '-')) (many1 alphaNum)) while still understanding it
06:35:28 <telexicon> needs more $
06:35:30 <vixey> but <$> and <*> notation is actually easier to use .. I think
06:35:36 <vixey> at least on most cases
06:35:40 <BeelsebobWork_> telexicon: yep, that works nicely
06:35:47 <mmorrow> , (const()(const::a->a->a)) liftM2 liftA2
06:35:49 <lunabot>  luna: Couldn't match expected type `t -> t1 -> a'
06:35:55 <mmorrow> , (const().(const::a->a->a)) liftM2 liftA2
06:35:56 <lunabot>  luna: Couldn't match expected type `t -> a' against inferred type `()'
06:35:59 <telexicon> BeelsebobWork_, yeah thats a lot cleaner than custom do, thanks :)
06:36:04 <mmorrow> , ((const().).(const::a->a->a)) liftM2 liftA2
06:36:06 <lunabot>  luna: Ambiguous type variable `m' in the constraints:
06:36:09 <mmorrow> grrrr
06:36:12 <BeelsebobWork_> telexicon: no go do it to the rest of your code :)
06:36:16 <telexicon> heh
06:36:21 <telexicon> yeah, i was thinking about that
06:36:33 <mmorrow> ah, i'm clearly trying to do something that won't work :)
06:36:34 <BeelsebobWork_> telexicon: mostly using <$> and <*> is a style issue -- I use them over liftMn because you can get high ns with them consistantly
06:36:41 <telexicon> vixey, so its like a shortcut that can apply to any amount of arguments
06:36:49 <vixey> yes
06:36:54 <telexicon> BeelsebobWork_, yes that
06:37:05 <mmorrow> , unwind
06:37:05 <vixey> but <$> and <*> are equiv. to liftA not liftM
06:37:07 <lunabot>  luna: Not in scope: `unwind'
06:37:08 <BeelsebobWork_> i.e. liftA5 doesn't exist, but f <$> a <*> b <*> c <*> d <*> e does
06:37:10 <vixey> :t (<$>)
06:37:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:37:12 <vixey> :t (<*>)
06:37:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:37:16 <telexicon> vixey, ok
06:37:19 <mmorrow> , unwindT
06:37:20 <lunabot>  luna: Not in scope: `unwindT'
06:37:25 <mmorrow> hmm
06:37:41 <BeelsebobWork_> telexicon: and then finally, you get to (<^) and (^>), and get to use your operators in infix again
06:37:54 <BeelsebobWork_> a <^(+)^> b == liftM2 (+) a b
06:38:01 <telexicon> BeelsebobWork_, oh right
06:38:10 <telexicon> awesome, and this all makes sense now :D
06:38:12 <BeelsebobWork_> :)
06:39:10 <mmorrow> , let un = unwind . unQ in un [t|liftM2|]
06:39:11 <lunabot>  luna: Not in scope: type variable `liftM2'
06:39:27 <mmorrow> oh gah. i always try to do that
06:39:28 <mmorrow> heh
06:40:39 <telexicon> GenParser isnt an instance of Applicative
06:41:19 <BeelsebobWork_> oh lame
06:41:23 <byorgey> telexicon: nope, but it's very easy to make it one
06:41:32 <byorgey> that's like the first thing i type whenever I use Parsec =)
06:41:42 <telexicon> well its already a monad, so shouldn't i get that for free?
06:41:45 <BeelsebobWork_> easy to write -- instance Applicative GenParser where <$> = fmap; pure = return
06:41:46 <BeelsebobWork_> done
06:41:52 <BeelsebobWork_> telexicon: you *should*
06:42:03 <BeelsebobWork_> but applicative didn't exist when monad was introduced to the hierarchy
06:42:08 <BeelsebobWork_> so it doesn't work that way :(
06:42:21 <BeelsebobWork_> hopefully someone will fix that at some point
06:42:22 <byorgey> actually, it's  instance Applicative (GenParser tok st) where pure = return; (<*>) = ap
06:42:34 <byorgey> isn't it an instance of Applicative in Parsec 3.0?
06:42:41 <BeelsebobWork_> there is I thought
06:42:48 <jeffersonheard> beelsebobwork: don't feed <^(+)^> after midnight...
06:42:54 <BeelsebobWork_> hehe
06:44:15 <telexicon> much nicer
06:44:29 <BeelsebobWork_> :)
06:44:31 <telexicon> i should pick a consistent style though
06:44:43 <telexicon> wheres the general idea for when to use $ and how much?
06:45:00 <jeffersonheard> telexicon, I personally always write point-free
06:45:12 <BeelsebobWork_> I write point free when it's clearer
06:45:17 <telexicon> hyphenAlphaNum = concat <$> many ((++) <$> (many $ char '-') <*> (many1 alphaNum))
06:45:18 <BeelsebobWork_> which is about 50% of the time
06:45:20 <jeffersonheard> using . and $.  I used to be a LISP programmer who hated parentheses
06:45:29 <BeelsebobWork_> telexicon: aww, not using my pig?
06:45:39 <idnar> (<^) = flip ($); (^>) = ($) ?
06:45:42 <telexicon> BeelsebobWork_, i dont have that library
06:45:56 <idnar> er
06:45:58 <BeelsebobWork_> idnar: (<^) = flip fmap; (^>) = (<*>)
06:46:04 <telexicon> last time i tried to use cabal i got angry
06:46:10 <BeelsebobWork_> oh, lame :(
06:46:13 <mm_freak> > [sin, cos] <*> [3,4]
06:46:14 <idnar> oh, right
06:46:15 <lambdabot>   [0.1411200080598672,-0.7568024953079282,-0.9899924966004454,-0.653643620863...
06:46:18 <telexicon> heh
06:46:25 <mm_freak> interesting
06:46:30 <BeelsebobWork_> idnar: it's in the InfixApplicative package
06:46:45 <telexicon> BeelsebobWork_, nah just, the version of cabal in my distro doesn't like the new cabal package syntax
06:46:53 <telexicon> mm_freak, i know! :D
06:47:00 <BeelsebobWork_> telexicon: oh, okay -- cabal install cabal then :P
06:47:04 <mm_freak> hi there telexicon =)
06:47:09 <telexicon> BeelsebobWork_, i thought it was integrated with ghc
06:47:14 <BeelsebobWork_> telexicon: nope
06:47:17 <telexicon> oh
06:47:20 <BeelsebobWork_> it's just a seperate program/libarry
06:47:22 <BeelsebobWork_> library*
06:47:25 <mm_freak> > Nothing <*> Just 3
06:47:26 <telexicon> it'll download it from hackage?
06:47:26 <vixey> jeffersonheard: lol
06:47:26 <lambdabot>   Nothing
06:47:34 <telexicon> Just 3 <*> Just 3
06:47:38 <mm_freak> is every Monad an Applicative?
06:47:42 <telexicon> > Just 3 <*> Just 3
06:47:43 <lambdabot>       No instance for (Num (a -> b))
06:47:43 <lambdabot>        arising from the literal `3' at <...
06:47:45 <BeelsebobWork_> telexicon: yes, if you have cabal-install installed, otherwise, the first thing you should be doing is installing cabal-install
06:47:50 <jeffersonheard> so did no-one know about whether or not guards work in lambdas?
06:47:51 <mm_freak> > Just sin <*> Just 3
06:47:51 <vixey> jeffersonheard: do you have some code online?
06:47:53 <BeelsebobWork_> mm_freak: in theory, yes
06:47:53 <lambdabot>   Just 0.1411200080598672
06:47:55 <BeelsebobWork_> in practice, no
06:48:08 <vixey> jeffersonheard: no gaurds on lambda, have to use case or bool
06:48:09 <telexicon> > sin <$> Just 3
06:48:10 <lambdabot>   Just 0.1411200080598672
06:48:13 <jeffersonheard> k
06:48:20 <telexicon> > return sin <*> Just 3
06:48:21 <lambdabot>   Just 0.1411200080598672
06:48:31 <mm_freak> BeelsebobWork_: because there are problems or because nobody bothered to implement it?
06:48:38 <BeelsebobWork_> mm_freak: the good news is that you can easily create an applicative instance from a monad one with <*> = ap and pure = return
06:48:46 <BeelsebobWork_> mm_freak: because no one bothered to implement it
06:48:49 <idnar> @type \f x -> return f <*> x
06:48:51 <lambdabot> forall a b (f :: * -> *). (Applicative f, Monad f) => (a -> b) -> f a -> f b
06:48:52 <mm_freak> ok
06:48:57 <idnar> @type \f x -> pure f <*> x
06:48:58 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
06:49:00 <vixey> @type liftM
06:49:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:49:03 <idnar> oh
06:49:05 <vixey> @type liftA
06:49:11 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
06:49:12 <idnar> @type return ?f <*> ?x
06:49:13 <lambdabot> forall a b (f :: * -> *). (Applicative f, ?x::f a, Monad f, ?f::a -> b) => f b
06:49:30 <telexicon> BeelsebobWork_, i dont have cabal, or at least i cant find a package (ubuntu 8.10)
06:49:37 <idnar> I always forget about ?
06:49:54 <vixey> @hackage Cabal
06:49:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal
06:50:08 <vixey> @hackage zlib
06:50:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
06:50:11 <vixey> @hackage HTTP
06:50:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
06:50:21 <BeelsebobWork_> telexicon: okay, to get cabal, you'll need to go to hackage, download the Cabal package, untar it, cd into it, and then runhaskell Setup.lhs configure & runhaskell Setup.lhs build & sudo runhaskell Setup.lhs install
06:50:25 <vixey> telexicon, you can install those in reverse order, but only after getting zlib-dev
06:50:26 <dcoutts> telexicon: it's a bit too new to be in most distros, it's the cabal-install package on hackage that you want. It provides the 'cabal' command line tool.
06:50:34 <mm_freak> > empty :: [a]
06:50:35 <lambdabot>       Ambiguous occurrence `empty'
06:50:35 <lambdabot>      It could refer to either `Text.Pretty...
06:50:49 <mm_freak> > Control.Applicative.empty :: [a]
06:50:50 <lambdabot>   []
06:51:05 <mm_freak> > [1,2,3] <|> [4,5,6]
06:51:07 <lambdabot>   [1,2,3,4,5,6]
06:51:08 <telexicon> can i have it install packages into my home dir?
06:51:11 <telexicon> vixey, ok
06:51:17 <mm_freak> isn't that just Monoid?
06:51:25 <BeelsebobWork_> telexicon: yep, runhaskell Setup.lhs configure --prefix=...
06:51:35 <BeelsebobWork_> mm_freak: it's slightly *less* than monad
06:51:42 <BeelsebobWork_> but the less that you get makes the syntax much neater
06:51:50 <BeelsebobWork_> no more do blocks and sequentiality
06:51:59 <vixey> more general
06:52:01 <vixey> :)
06:52:02 <BeelsebobWork_> no more imperative programming in Haskell
06:52:07 <telexicon> BeelsebobWork_, yeah i mean, well like.. easy_install installs eggs into ~/lib/python and auto-adjusts my python path
06:52:10 <mm_freak> BeelsebobWork_: i mean Alternative  isn't it the same as Monoid, but only restricted to Applicatives?
06:52:27 <BeelsebobWork_> telexicon: yeh, you can get cabal install to do that... once you have it installed
06:52:35 <telexicon> k
06:52:35 <BeelsebobWork_> mm_freak: well, there are more Applicatives than Monads
06:52:52 <matthew-_> right, I'm trying to write a haskell wrapper over a C library
06:52:55 <BeelsebobWork_> all monads are applicatives, but not the other way round
06:53:01 <matthew-_> except that the C library isn't a library
06:53:07 <matthew-_> compiling it does not produce a .so
06:53:08 <mm_freak> BeelsebobWork_: Monoid, not Monad
06:53:22 <mm_freak> > [1,2,3] <|> [4,5,6]
06:53:24 <lambdabot>   [1,2,3,4,5,6]
06:53:27 <BeelsebobWork_> oh, I see
06:53:30 <mm_freak> > [1,2,3] `mappend` [4,5,6]
06:53:32 <lambdabot>   [1,2,3,4,5,6]
06:53:36 <matthew-_> so, if I just #include the correct header files, and use hsc, will it actually compile and link everything in correctly?
06:53:42 * BeelsebobWork_ can't remember, but plausably it's always equal to mappend
06:53:47 <EvilTerran> mm_freak, indeed, Alternative and MonadPlus are very similar to Monoid, aside from the kind and the Applicative/Monad constraint
06:53:56 <vixey> @src mappend
06:53:56 <lambdabot> Source not found. Sorry.
06:54:11 <mm_freak> ok
06:54:27 <EvilTerran> > Just (Just 1) `mappend` Just (Just 2)
06:54:28 <lambdabot>   Add a type signature
06:54:35 <EvilTerran> > Just (Just 1) `mappend` Just (Just 2) :: Maybe (Maybe Int)
06:54:36 <lambdabot>       No instance for (Monoid Int)
06:54:36 <lambdabot>        arising from a use of `mappend' at ...
06:54:37 <BeelsebobWork_> @src (<|>)
06:54:37 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:54:43 <EvilTerran> > Just (Just 1) `mplus` Just (Just 2) :: Maybe (Maybe Int)
06:54:44 <mm_freak> > 5 <$ [1,2,3]
06:54:45 <lambdabot>   Just (Just 1)
06:54:46 <lambdabot>   [5,5,5]
06:54:57 <EvilTerran> BeelsebobWork_, there's a case where they're different
06:55:03 <BeelsebobWork_> EvilTerran: oh?
06:55:28 <BeelsebobWork_> ah, so it is
06:55:30 <EvilTerran> the instance MonadPlus Maybe must work (forall a. Maybe a), so is left-biased
06:55:39 <BeelsebobWork_> hmm, that's interesting
06:55:44 <EvilTerran> the instance Monoid (Maybe a) has a (Monoid a) constraint, so is symmetric
06:55:47 <mm_freak> > optional [1,2,3]
06:55:48 <BeelsebobWork_> that sentence has no difference between future and past tense
06:55:49 <lambdabot>   [Just 1,Just 2,Just 3,Nothing]
06:55:54 <mm_freak> > optional []
06:55:55 <lambdabot>   [Nothing]
06:56:08 <mm_freak> > some [1,2,3]
06:56:10 <lambdabot>   * Exception: stack overflow
06:56:15 <mm_freak> , some [1,2,3]
06:56:18 <lunabot>  luna: out of memory (requested 2097152 bytes)
06:56:21 <EvilTerran> ?src some
06:56:22 <lambdabot> some v = some_v
06:56:22 <lambdabot>   where many_v = some_v <|> pure []
06:56:22 <lambdabot>         some_v = (:) <$> v <*> many_v
06:56:36 <EvilTerran> ?type some
06:56:38 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
06:56:45 <BeelsebobWork_> aww, perfect oportunity for the cons pig there :P
06:57:13 <mm_freak> hmm
06:57:20 <mm_freak> > some (Just 3)
06:57:22 <lambdabot>   * Exception: stack overflow
06:57:25 <EvilTerran> > runState (some$ do x <- get; guard (x < 5); put (x+1); return x) 0
06:57:27 <lambdabot>       No instance for (Alternative (State s))
06:57:27 <lambdabot>        arising from a use of `s...
06:57:27 <mm_freak> > some Nothing
06:57:29 <lambdabot>   Nothing
06:57:31 <EvilTerran> gah!
06:57:59 <mm_freak> > many [1]
06:58:00 <lambdabot>   * Exception: stack overflow
06:58:06 <mm_freak> hehe
06:58:22 <mm_freak> seems like that can only work with something like State
06:58:31 <EvilTerran> which doesn't have an Alternative instance
06:58:46 <telexicon> i think haskell kind of has a steep learning curve
06:59:26 <daf> telexicon: yes, but the view is great when you've climbed it
06:59:27 <mm_freak> telexicon: luckily you really don't have to bother with all of what is talked about here
06:59:59 * osfameron joins #haskell-in-words-of-one-syllable-or-less
07:00:07 <telexicon> mm_freak, that doesnt really sit well with me
07:00:20 <mm_freak> it's like the 'fix' function  it's great and may be useful, if you understand it, but you won't miss much, if you don't
07:00:25 <vixey> I disagree
07:00:35 <vixey> I think haskell has not got a steep learning curve
07:01:13 <telexicon> foldl foldl' foldl1 foldl1' etc
07:01:16 <mm_freak> telexicon: the problem with haskell is:  when you ask how to do something, you'll get as many different answers as there are people answering
07:01:32 <osfameron> vixey: you seem to have to understand a lot more to do some of the things that you can easily brute force in an imperative language
07:01:40 <mm_freak> but usually there are one or two easily comprehensible solutions
07:01:47 <unenough> vixey, so can you give an example of a non-isomorphic bijection between posets?
07:01:49 <mm_freak> the fibonacci sequence is the best example for that
07:02:00 <unenough> i'm not sure what that means
07:02:11 <dmwit> unenough: It just means it doesn't preserve the ordering.
07:02:13 <telexicon> there are a lot of functions for doing stuff so you dont have to build it all yourself, but it takes a while to wade through the standard library functions and learn them
07:02:16 <mm_freak> > let fibs a b = a : fibs b (a+b) in fibs 0 1
07:02:18 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:02:19 <unenough> dmwit, ah
07:02:23 <telexicon> before you can start understanding what people are saying
07:02:31 <_pizza_> vixey: i would disagree, as a programmer i find some parts of it baffling
07:02:36 <mm_freak> > fix (\k a b -> a : k b (a+b)) 0 1
07:02:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:03:00 <_pizza_> not necessarily bad, just very different from mainstream imperative languages
07:03:03 <vixey> > map fst . iterate (\(x,y) -> (y,y+x)) $ (0,1)
07:03:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:03:55 <unenough> _pizza_, the thing is that haskell forces you to think, where imperative languages allow you to code like a silly monkey (and pay for it later)
07:04:03 <mm_freak> > let myIterate f = fix (\k x -> x : k (f x)) in map fst $ myIterate (\(x,y) -> (y,y+x)) (0,1)
07:04:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:04:06 <unenough> so at first, there's a "cultural shock"
07:04:17 <unenough> what, i actually have to think before writing my code?
07:04:28 <telexicon> so in a language where im forced to think, im then told i dont have to understand what im doing
07:04:51 <mm_freak> telexicon: you have to understand what you're doing
07:04:54 <unenough> who told you that
07:05:03 <mm_freak> but you don't have to understand what others are doing
07:05:13 <mm_freak> once you do, it's great, but you can get away without
07:05:21 <vixey> unenough, I completely disagree with that
07:05:29 <vixey> unenough, This is not true at all
07:05:37 <telexicon> mm_freak, sounds like a maintenance nightmare
07:06:05 <unenough> vixey, it's true in the sense that haskell provides all those abstractions where other languages delegate the responsibility to abstract on to you
07:06:24 <mm_freak> telexicon: nope  besides using constructs with some theoretical background (like fix), code is usually comprehensive, even if you couldn't come up with it yourself
07:06:32 <EvilTerran> telexicon, not if the interface between your code and theirs is rigorously defined
07:06:58 <PeakerWork> @hoogle regex
07:06:59 <lambdabot> package regex-base
07:06:59 <lambdabot> package regex-compat
07:06:59 <lambdabot> package regex-dfa
07:07:01 <mm_freak> and yeah, EvilTerran has made another good point
07:07:02 <vixey> unenough, that doesn't make what you said true
07:07:02 <telexicon> EvilTerran, what about adding new coders to a team? or the person who originally wrote it goes away
07:07:06 <PeakerWork> what's dfa?
07:07:13 <vixey> deterministic FA
07:07:15 <telexicon> PeakerWork, deterministic finite automata
07:07:32 <Deewiant> dfa and tdfa for the win, because they're pure haskell with no external deps
07:07:34 <vixey> you've not seen how regex <=> NFA <=> DFA?
07:07:57 <EvilTerran> telexicon, is that any better in any other language?
07:08:02 <vixey> this is a very important resutl
07:08:04 <PeakerWork> but regexp's are not really regular, they're not DSA'sable?
07:08:11 <PeakerWork> DFA'able, that is
07:08:22 <EvilTerran> telexicon, that's got nothing to do with the language, that's a matter of keeping your team's bus number up
07:08:23 <vixey> PeakerWork, this is a very important result they are equivalent
07:08:26 <mm_freak> telexicon: haskell gives you a lot of things, some of those crazy, but that's true for every language  you have to instruct your team to write comprehensible code
07:08:42 <telexicon> EvilTerran, yeah, at least in python i can read something and understand what its doing, here sometimes when i ask something i get a response that is incomprehensible
07:08:43 <PeakerWork> vixey: but regexps have that stupid feature where you can match an already-matched group which destroys it, iirc
07:08:45 <EvilTerran> (bus number: http://blog.visionpace.com/2006/05/whats_your_bus_.html)
07:08:55 <lambdabot> Title: Visionpace: Whats your Bus Number?
07:08:56 <EvilTerran> telexicon, well, how long have you been learning python? and haskell?
07:09:05 <mm_freak> remember my closure- and continuation-based factorial function in C, using list folding?
07:09:10 <EvilTerran> PeakerWork, those aren't real regexps, they're irregexps :P
07:09:14 <telexicon> EvilTerran, python has only a small amount of primitives
07:09:18 <PeakerWork> EvilTerran: heh ya
07:09:36 <telexicon> EvilTerran, most peoples responses stay together
07:09:39 <mm_freak> telexicon: haskell has much fewer primitives =)
07:09:43 <telexicon> EvilTerran, in haskell, responses are wildly different
07:09:44 <PeakerWork> unenough: I think you can write "silly-monkey code" in Haskell too, its just not how people work
07:09:45 <luite> telexicon:  you should hang around in here for about a year, the responses will gradually become more comprehensible :P
07:09:58 <PeakerWork> unenough: if they learn Haskell its because they want to write nice code ;)
07:10:01 <telexicon> luite, yeah, and thats my point
07:10:10 <unenough> PeakerWork, if you like silly monkey code you'll probably never get past the initial culture shock
07:10:15 <EvilTerran> telexicon, as you become more familiar with the language, you'll start seeing the connections between the different answers
07:10:21 <unenough> Peaker, exactly
07:10:33 <telexicon> in about a month i could understand almost any python that was thrown at me
07:10:44 <hackage> Uploaded to hackage: delimited-text 0.0.1
07:10:44 <hackage> Uploaded to hackage: wavesurfer 0.0.1
07:10:46 <EvilTerran> telexicon, did you already know another imperative language?
07:10:49 <luite> telexicon: but you could probably already understand some imperative code in another language
07:10:50 <PeakerWork> telexicon: Python has grown significantly between Python 1.5, 2.0 and 2.6
07:11:07 <EvilTerran> just because haskell is different to most programming languages doesn't mean it's innately harder or worse
07:11:15 <vixey> telexicon, It will be interesting to see what a month of haskell gets you :)
07:11:16 <telexicon> PeakerWork, yes, and i can still follow it
07:11:26 <PeakerWork> telexicon: I only started with Haskell about ~6 months ago, and I can now understand pretty much all the code thrown here now
07:11:31 <telexicon> vixey, ive been tinkering with haskell on and off for probably around a year
07:11:34 <PeakerWork> telexicon: there's the occasional mind boggler, perhaps ;)
07:11:38 <dolio> > let f n k = if n == 0 then k 1 else f (n-1) (\n' -> k (n*n')) in f 6 show
07:11:38 <lambdabot>   "720"
07:11:51 <telexicon> i understand the flow of functional programming, recursion doesnt bother me
07:11:58 <unenough> PeakerWork, i started that book on category theory
07:12:00 <EvilTerran> PeakerWork, i like the mind-bogglers, because i can usually work them out, and then they make me feel clever :)
07:12:04 <telexicon> actually it was scheme that helped me get comfortable with recursion
07:12:28 <Japsu>  > let f n k = if n == 0 then k 1 else f (n-1) (\n' -> k (n*n')) in f 6 id
07:12:29 <PeakerWork> telexicon: Haskell code is more mind warping because it is usually much more general, which usually means its more abstract. Abstractions are harder to learn than concrete stuff,  because you already know most the concrete stuff
07:12:34 <PeakerWork> EvilTerran: ;)
07:12:34 <Japsu> > let f n k = if n == 0 then k 1 else f (n-1) (\n' -> k (n*n')) in f 6 id
07:12:34 <vixey> Calculating Compilers helped me understand recursion
07:12:35 <telexicon> and erlang that helped me get comfortable with writing general apps in a functional language (as opposed to variations on calculators)
07:12:37 <unenough> PeakerWork, the first 4 pages are exactly what i was trying to invent :)
07:12:37 <lambdabot>   720
07:12:40 <PeakerWork> unenough: ;-)
07:12:46 <velco> I was very happy with Haskell until monad transformers(?) came to lobotomize me
07:12:56 * vixey (recommends reading this)
07:13:01 <PeakerWork> I don't like the syntax involved in using monad transformers
07:13:17 <Deewiant> Hmm, this is rare: how often does GHC fail to infer a type (as in, refuse to compile it) which can be given manually with only ScopedTypeVariables?
07:13:19 <vixey> velco, did you read monad transformer stacks step by step?
07:13:26 <dolio> vixey: Did you see Conor's mail on the Agda list?
07:13:34 <vixey> dolio, no
07:13:41 <mm_freak> telexicon: i wrote an internal database server in haskell in about 10 lines of very comprehensible code  this is not something unique to Erlang
07:13:43 <telexicon> the one thing that bothers me a little is how the standard library functions have so many variations
07:13:46 <vixey> dolio, Can I acually read agda mailing list?
07:13:49 <velco> vixey: I'm not sure what did I read, it was 2 years ago
07:13:55 <telexicon> mm_freak, i never said it was unique to erlang
07:13:56 <PeakerWork> telexicon: example?
07:14:01 <dolio> You're not a subscriber?
07:14:16 <vixey> dolio, when I tried to subscribe they did not let me.. I am apparently not a human
07:14:20 <telexicon> PeakerWork, foldl foldl' foldl1 foldl1' liftM liftM2 liftM3 liftM4
07:14:29 <telexicon> why cant they be generalized
07:14:31 <vixey> velco, this is the best www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
07:14:41 <PeakerWork> telexicon: well, liftM* are not really necessary, they're convenience around <$> and <*>
07:14:42 <telexicon> or there was like, map and mapM and mapM_
07:14:43 <dolio> That's odd.
07:14:57 <telexicon> why not map that applies to a general typeclass
07:14:58 <vixey> dolio, I have no idea how they knew!
07:15:00 <telexicon> so its map everywhere
07:15:07 <PeakerWork> telexicon: liftM2 f a b = f <$> a <*> b     liftM3 f a b c = f <$> a <*> b <*> c ... and so on
07:15:17 <telexicon> it operates on (Mappable m)
07:15:30 <PeakerWork> telexicon: as for the tagged versions, that's because you have to specify strictness as well, and that is a lot of ugly information to add :-(
07:15:32 <telexicon> PeakerWork, yeah i learned that earlier, so why have liftM?
07:15:35 <PeakerWork> telexicon: Not sure about foldl1
07:15:46 <telexicon> PeakerWork, foldl1 requires non-empty lists
07:15:53 <PeakerWork> telexicon: Maybe because historically Monads aren't Applicatives, which hopefully is fixed
07:15:55 <mm_freak> telexicon: well  the thing is, yes, haskell is a bit harder to learn that other languages, including other functional languages, because it employs new and unusual, but very useful concepts  you learned monads, at first they were like evil magic, but now they are a tool like everything else
07:16:13 <EvilTerran> telexicon, "Mappable"? you mean Functor?
07:16:27 <telexicon> EvilTerran, whichever would be used to generalize it
07:16:31 <telexicon> that was just an example
07:16:33 <PeakerWork> telexicon: Functor *is* that generalization
07:16:37 <EvilTerran> > fmap (+1) (Just 2)
07:16:38 <telexicon> ok
07:16:39 <lambdabot>   Just 3
07:16:41 <EvilTerran> > fmap (+1) (Right 2)
07:16:43 <lambdabot>   Right 3
07:16:53 <PeakerWork> telexicon: Some things cannot be generalized because they would require dependent-typing
07:16:56 <telexicon> fmap (+1) [1..10]
07:16:57 <idnar> > fmap (*2) [1..]
07:16:59 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
07:17:02 <telexicon> yes that
07:17:08 <EvilTerran> > fmap (+1) (Node 1 [Node 2 [], Node 3 [Node 4 []]])
07:17:10 <lambdabot>   Node {rootLabel = 2, subForest = [Node {rootLabel = 3, subForest = []},Node...
07:17:22 <mm_freak> telexicon: 'fmap' is the generalization of 'map'  and in fact 'map' used to be the same as 'fmap', but for some reason, it was splitted
07:17:24 <PeakerWork> telexicon: you cannot generalize:  fmap, fmap.fmap, fmap.fmap.fmap   because their types are different
07:17:48 <telexicon> PeakerWork, have them operate on a generalized type
07:17:54 <idnar> @type fmap.fmap.fmap
07:17:55 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
07:17:57 <EvilTerran> PeakerWork, well, you can, but it requires MPTCs at least
07:18:02 <Deewiant> telexicon: mapM and mapM_ are convenience functions over sequence and sequence_, which are two different functions with different meanings and thus not generalized.
07:18:15 <telexicon> they have to have something in common, otherwise they mean something different
07:18:16 <PeakerWork> EvilTerran: MPTC?
07:18:19 <idnar> @type sequence
07:18:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:18:23 <idnar> @type mapM
07:18:23 <vixey> can a functionn f^n be written?  f :: a -> a and n some encoding of a natural number
07:18:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:18:48 <vixey> f^0 = id, f^3 = f . f . f
07:19:00 <telexicon> theres a lot of convenience functions available, which are convenient for writers i suppose
07:19:07 <vixey> oh f shouldn't be a -> a though
07:19:09 <EvilTerran> "class FunctorOf a fa b fb | fa -> a, fb -> b where fomap :: (a -> b) -> fa -> fb; instance FunctorOf a a b b where fomap = id; instance (FunctorOf a fa b fb, Functor g) => FunctorOf a (g fa) b (g fb) where fomap = fmap . fomap
07:19:09 <dmwit> vixey: iterate (.f) !! n
07:19:11 <mm_freak> btw, generalization is also a concept used heavily in haskell, compared to other languages
07:19:12 <telexicon> but it certainly adds a lot of overhead for readers and people learning the language
07:19:17 <idnar> @type (sequence .) . map
07:19:17 <EvilTerran> PeakerWork, "multi-parameter type classes"
07:19:18 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
07:19:19 <idnar> @type (sequence .) . fmap
07:19:21 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
07:19:27 <PeakerWork> EvilTerran: its not enough, I don't think
07:19:36 <EvilTerran> (i also used fundeps there)
07:19:38 <idnar> oh, duh
07:19:53 <PeakerWork> EvilTerran: even with MPTC+fundeps, how do you describe the type that is general enough for both fmap and fmap.fmap ?
07:19:54 <dmwit> vixey: or unEndo . msum . replicate n (Endo f)
07:19:56 <idnar> I guess the generalisation of sequence would need foldable
07:19:59 <dmwit> ?src Endo
07:20:00 <lambdabot> Source not found. I am sorry.
07:20:02 <idnar> or something
07:20:03 <EvilTerran> PeakerWork, look up, i gave it
07:20:08 <PeakerWork> @hoogle Endo
07:20:08 <lambdabot> Data.Monoid newtype Endo a
07:20:08 <lambdabot> Data.Monoid Endo :: a -> a -> Endo a
07:20:08 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
07:20:19 <dmwit> Okay, s/unEndo/appEndo/
07:20:28 <EvilTerran> "FunctorOf a b fa fb => fomap :: (a -> b) -> fa -> fb"
07:20:44 <dolio> idnar: The generalization of sequence is Traversable.
07:20:54 <vixey> dolio, ah .. I can read it off gmane
07:21:04 <dolio> Although you can do sequence_ with Foldable.
07:21:12 <idnar> oh, okay
07:21:18 <PeakerWork> EvilTerran: hmm, if it is more general than fmap, why not use that?
07:21:30 <idnar> hmm, yeah, I guess foldable wouldn't work
07:21:58 <EvilTerran> PeakerWork, because it's *very* non-h98
07:22:10 <vixey> dolio, what was the post or thread or ?
07:22:29 <dolio> "Some semantics, some syntax."
07:22:31 <EvilTerran> PeakerWork, i think it needs {-# LANGUAGE FlexibleInstances, FunctionalDependencies, MultiParamTypeClasses, UndecidableInstances #-}
07:22:35 <quicksilver> in another direction, the generalisation of sequence is Applicative.
07:22:46 <quicksilver> Applicative is the most general thing-that-can-be-sequenced
07:22:49 <PeakerWork> EvilTerran: undecidable instances? Sounds horrible ;)
07:22:56 <quicksilver> and traversable the most general thing-over-which-you-can-sequence
07:23:01 <dolio> vixey: I actually figured out it wasn't as exciting as I was thinking just before I told you something totally bogus about 3 minutes ago. :)
07:23:07 <EvilTerran> PeakerWork, don't worry, they're actually decidable, it's just that the static analysis can't tell that they are
07:23:18 <vixey> dolio, oohh what was the bogus thing ? :)
07:23:33 <quicksilver> didn't oleg have a deep fmap?
07:23:50 <Beelsebob> deep fmap?
07:23:51 <EvilTerran> PeakerWork, if we had "StructurallyRecursiveInstances" or something (more relaxed than h98 instances, but less so than UndecidableInstances), that would work
07:23:55 <Beelsebob> what would that do quicksilver?
07:23:57 <quicksilver> http://okmij.org/ftp/Haskell/typecast.html#deepest-functor
07:23:59 <lambdabot> Title: Type improvement constraint
07:24:09 <EvilTerran> Beelsebob, i think it'd do the same thing as my "fomap", pretty much
07:24:16 <dolio> vixey: I thought he was somehow computing normal forms (which I thought was impossible via the halting problem/what have you), but then I realized I was using "compute normal form" to look at the results of the evaluation function, which of course normalized the resulting Agda term.
07:24:33 <Beelsebob> oh, it's (fmap . fmap . fmap) only without the being able to target it to any level?
07:24:39 <Beelsebob> (and shorter)
07:24:49 <quicksilver> it's also undecidable
07:24:54 <quicksilver> and it violates parametricity
07:25:02 <telexicon> mm_freak, heh, anyways im writing a parsec for irc
07:25:04 <quicksilver> but that's the sacrifices you gotta make.
07:25:15 <quicksilver> personally I don't like stuff which violates parametricity though.
07:25:26 <mattam> quicksilver: the deepest functor stuff?
07:25:38 <EvilTerran> quicksilver, parametricity?
07:25:52 <mm_freak> telexicon: go ahead, and don't worry if you don't understand something immediately =)
07:26:04 <telexicon> mm_freak, well i did learn something really useful today
07:26:10 <telexicon> mm_freak, about <$>/<*> liftM etc
07:26:17 <telexicon> mm_freak, which cleans up my code a ton
07:26:22 <mm_freak> it's even ok to use things without fully understanding them yet, as long as you know how and for what to use them properly
07:26:24 <unenough> > foldr (&&) True [True, False, True]
07:26:25 <lambdabot>   False
07:26:41 <EvilTerran> ?src and
07:26:41 <lambdabot> and   =  foldr (&&) True
07:26:42 <quicksilver> EvilTerran: the instance of deep fmap for [[a]] -> [[a]]
07:26:44 <dolio> vixey: By the way, if you get the urge to play with that code, I suggest commenting out WEAK at the bottom, because that causes agda to use up about 40% of my memory (as opposed to around 15% without it).
07:26:48 <quicksilver> EvilTerran: can't be parametric
07:26:55 <dolio> (And it gets worse on subsequent reloads.)
07:26:58 <quicksilver> EvilTerran: because it depends whether "a" turns out to be a functor or not.
07:27:09 <EvilTerran> does it?
07:27:16 * quicksilver nods
07:27:20 <vixey> yeah Agda is so slow
07:27:26 <quicksilver> if a turns out to be Int then it's fmap.fmap
07:27:27 <vixey> this is very cool though
07:27:35 <quicksilver> if a turns out to be [Int] then it's fmap.fmap.fmap
07:27:40 <EvilTerran> my "fomap" there relies on comparing the type of the function and the type of the structure to know how deep into the recursion to go
07:27:43 <quicksilver> so, that's not parametric in a any more.
07:27:47 <quicksilver> yes, it's not the same.
07:27:52 <dolio> vixey: Yeah. Reloading more than twice was causing my machine to go into swap thrashing mode.
07:27:54 <quicksilver> you tell yours how deep to go.
07:28:00 <mattam> quicksilver: it's not using typeclasses?
07:28:01 <EvilTerran> i prefer mine, for that reason, tbh
07:28:02 <quicksilver> I was pointing at olegs for comparison, not because they're the same.
07:28:13 <EvilTerran> ok, i'm with you now :)
07:28:35 <quicksilver> I prefer yours for that reason, too.
07:28:44 * EvilTerran gets to thinking about instances of Functor involving Mu
07:28:45 <EvilTerran> >:)
07:28:50 <quicksilver> in practice I use newtypes and derive Functor
07:29:14 <quicksilver> possibly using the fact that instance Functor f, Functor g => Functor (f `O` g)
07:30:09 <EvilTerran> instance Functor (f a) => Functor (Mu f) where fmap f ... hm...
07:30:24 <unenough> can someone help my lambdabot?
07:30:28 <vixey> dolio, I wonder if it's possible to write a type checker in this fashon
07:30:29 <unenough> EnoughSaid, > 3+3
07:30:35 <unenough> EnoughSaid: > 3+3
07:30:43 <unenough> > 1+1
07:30:44 <lambdabot>   2
07:30:45 <EnoughSaid>   mueval: Prelude.read: no parse
07:30:45 <EnoughSaid>  
07:30:45 <EnoughSaid>  GHCi runtime linker: fatal error: I fou...
07:30:52 <vixey> EnoughSaid: @run 3+3
07:30:54 <unenough> what's it's problem
07:30:54 <EnoughSaid>   mueval: Prelude.read: no parse
07:30:54 <EnoughSaid>  
07:30:54 <EnoughSaid>  GHCi runtime linker: fatal error: I fou...
07:30:59 <unenough> it worked before
07:31:22 <unenough> EnoughSaid: @more
07:31:29 <dmwit> Perhaps you should figure out what the rest of the err... yeah.
07:31:39 <unenough> doesn't print anything
07:31:53 <unenough> does it have a log?
07:32:30 <mattam> quicksilver: I don't see why it would break parametricity, it's only the method f_map that has different instanciations for different types (even overlapping ones). There's no intensional type analysis at runtime.
07:34:05 <mattam> Or is there? Can you export a function of type [forall a. [[a]] -> [[a]]] using these definitions that breaks parametricity?
07:36:53 <ziman> @djinn (a -> b) -> Maybe a -> Maybe b
07:36:54 <lambdabot> f a b =
07:36:54 <lambdabot>     case b of
07:36:54 <lambdabot>     Nothing -> Nothing
07:36:54 <lambdabot>     Just c -> Just (a c)
07:37:12 <telexicon> ok i was able to use concat <$> but what if i want to replace it with something that does return [x] or return (x:xs), is there a function i use for building lists?
07:37:38 <telexicon> aha
07:37:43 <telexicon> nvm
07:37:59 <quicksilver> mattam: you can export a function of type [[a]] -> [[a]]
07:38:20 <quicksilver> mattam: if you choose to use that function with "a ~ [Int]" then the more specific instance won't necessarily get chosen
07:38:30 <quicksilver> depending on exporting and inlining and stuff.
07:38:58 <Beelsebob> telexicon: <^(:)^>
07:38:58 <vixey> dolio, did you see this one? http://article.gmane.org/gmane.comp.lang.agda/390
07:39:02 <lambdabot> Title: Gmane -- Mail To News And Back Again
07:39:03 <EvilTerran> quicksilver, i thought that could only happen if you were using IncoherentInstances
07:39:05 <vixey> dolio, sorry getting hooked on this mailing list ...
07:39:07 <telexicon> Beelsebob, yeah i figured it out :)
07:39:09 <Beelsebob> :)
07:39:15 <PeakerWork> If @more doesn't work, what can be done?
07:39:17 <telexicon> Beelsebob, also i did (:[]) <$> letter
07:39:19 <quicksilver> EvilTerran: overlapping is enough.
07:39:22 <vixey> dolio, is he saying boo should be accepted or rejected? (Coq rejects it)
07:39:26 <quicksilver> EvilTerran: if you have two instances for [[[Int]]]
07:39:27 <vixey> (as I would expect)
07:39:30 <quicksilver> EvilTerran: (which we do in this case)
07:39:35 <telexicon> Beelsebob, to replace return [x]
07:39:38 <Beelsebob> telexicon: looks sensible :)
07:39:45 <quicksilver> EvilTerran: then in some circumstances you can be surprised by which instance gets chosen across a module boundary.
07:40:10 <ksf> does ghc support conditional specialising like {-#SPECIALISE foo | a = Int, a = Double #-}?
07:40:13 <Beelsebob> letter <^(:[]) -- robottic pig monkey half breed?
07:40:22 <Beelsebob> or robotic monkey with a hat on
07:40:23 <telexicon> lol
07:40:28 <telexicon> oh you can do that?
07:40:32 <Beelsebob> you can
07:40:33 <telexicon> where you only use one side
07:40:34 <PeakerWork> ksf: I think you can write rewrite rules that are allowed to work only if the types are right
07:40:35 <EvilTerran> quicksilver, ah, i see - i may've been thinking of IncoherentInstances potentially resulting in a similar problem during type inference
07:40:36 <Beelsebob> but it's not so nice
07:40:41 <Beelsebob> telexicon: yep
07:40:43 <quicksilver> mock not he monkey combinator
07:40:45 <telexicon> interesting
07:40:55 <telexicon> they are stances
07:40:56 <Beelsebob> quicksilver: I'm not mocking it -- I'm also not mocking the pig combinator
07:40:57 <Beelsebob> :D
07:40:59 <quicksilver> I've seen him eat <^(:[ {- entire babies -} ])
07:41:00 <telexicon> Monkey! Pig! Tiger!
07:41:10 <Beelsebob> quicksilver: :D
07:41:11 * telexicon kung-fus
07:41:13 <EvilTerran> telexicon, <^ and ^> are just custom infix operators
07:41:32 <EvilTerran> > let (!$%^&*) = (,) in 1 !$%^&* 2
07:41:33 <quicksilver> EvilTerran: in GHC parametricity actually *is*
07:41:34 <lambdabot>   (1,2)
07:41:42 <quicksilver> EvilTerran: in the sense that compiled code is truly polymorphic
07:41:54 <quicksilver> EvilTerran: (unlike, say, C++, where compiled code is always fully specialised)
07:41:56 <mfwitten> I Hello. I just ran the testsuite for 6.10.1 on Mac OS X (PPC) and I got 30 unexpected failures. Are these actually unexpected or is this a serious problem?
07:42:07 <GrayShade> isn't a bit strange that (\f -> (f, f)) g isn't the same thing as (g, g)?
07:42:14 <quicksilver> EvilTerran: the hack that makes overlapping instances work interacts poorly with separate compilation.
07:42:23 <quicksilver> GrayShade: a little bit strange, but you get used to it.
07:42:38 <quicksilver> GrayShade: it's one of the prices we pay for a tractable type system.
07:42:40 <mfwitten> ffi009(ghci) and num012(normal,optc,hpc,optasm,profc,profasm,ghci,threaded1,threaded2,profthreaded) and signals002(ghci) look particularly fatal
07:42:48 <EvilTerran> quicksilver, ah, i see
07:42:50 <PeakerWork> regex-dfa's cabal file forgets to mention a lot of its dependencies
07:42:54 <mfwitten> just by their names
07:43:07 <mfwitten> ghci032(ghci) doesn't look nice either
07:43:12 <GrayShade> quicksilver: hm
07:43:18 <quicksilver> EvilTerran: for example, in a typical GHC compiled program, there might be only one object []
07:43:21 <ksf> GrayShade, we all know that _|_ is evil. now pass on, please.
07:43:22 <quicksilver> EvilTerran: which is used in all lists
07:43:27 <quicksilver> EvilTerran: isn't that cute? ;)
07:43:33 <quicksilver> ksf: no, he's not talking about _|_
07:43:36 <EvilTerran> that is kinda cool
07:43:38 <quicksilver> ksf: he's talking about polymorphism.
07:43:41 <PeakerWork> GrayShade: how are they different? monomorphism restriction?
07:43:50 <EvilTerran> ?type (\f -> (f,f)) ?g
07:43:52 <lambdabot> forall t. (?g::t) => (t, t)
07:43:52 <dolio> vixey: I expect he's saying boo should be accepted.
07:43:55 <quicksilver> polymorphism isn't first class in haskell98
07:43:55 <EvilTerran> ?type (?g, ?g)
07:43:57 <lambdabot> forall t. (?g::t) => (t, t)
07:43:59 <EvilTerran> hm
07:44:06 <quicksilver> you can't pass truly polymorphic things as paramters
07:44:12 <quicksilver> in GHC you can, but you need to annotate the type
07:44:20 <quicksilver> (and turn on higher rank types and/or imprediciativity)
07:44:25 <ksf> aaaah.
07:44:38 <quicksilver> the lambda binding there "forces" f to have a well defined type
07:44:40 <mattam> quicksilver: in the [forall a. [[a]] -> [[a]]], there's no typeclass resolution happening alright?
07:44:51 <mfwitten> Anybody else run the testuite for 6.10.1?
07:44:58 <quicksilver> mattam: no. I wasn't even talking about higher rank stuff.
07:45:12 <quicksilver> mattam: although you're right to suggest that the problems I'm talking about get even worse with higher rank types flying around.
07:45:50 <mattam> What I mean is that I don't see how typeclass resolution could happen if you export a function of type [[a]] -> [[a]]...
07:46:10 <unenough> is there a notion of discrete categories? (countable arrows)
07:46:16 <mattam> There are simply no constraints.
07:46:19 <quicksilver> mattam: right.
07:46:22 <lilac> @type ((\f -> (f,f)) 1, (1, 1))
07:46:23 <lambdabot> forall t t1 t2. (Num t2, Num t1, Num t) => ((t, t), (t1, t2))
07:46:27 <quicksilver> but suppose that function is defined to be deepfmap
07:46:34 <quicksilver> (that's one of the types deepfmap can have)
07:46:41 <PeakerWork> where can I submit a patch to regex-dfa's package?
07:46:44 <mattam> Yes.
07:46:53 <unenough> PeakerWork, found a bug already?
07:46:54 <quicksilver> I didn't really construct my argument very clearly, to be fair.
07:47:06 <quicksilver> a function (f :: [[a]] -> [[a]]) might use deepfmap internally.
07:47:11 <quicksilver> on its parameter.
07:47:22 <mattam> Yes.
07:47:28 <quicksilver> if it can "See" that it's being passed (a ~ [Int]) then it will select the 3-deep instances
07:47:38 <quicksilver> if it can't "see" that, then it will select the 2-deep instance.
07:47:48 <C-Keen> why is this illegal? http://hpaste.org/11957
07:47:53 <quicksilver> what it can "see" depends heavily on inlining and instance visibility.
07:48:01 <mattam> Inlining could happen before typechecking???
07:48:02 <quicksilver> so it interacts poorly with separate compilaton.
07:48:10 <PeakerWork> unenough: it doesn't compile, it forgets to mention dependencies
07:48:15 <unenough> ah
07:48:19 <EvilTerran> C-Keen, what error do you get?
07:48:27 <unenough> that happened to almost any package i tried building
07:48:29 <PeakerWork> unenough: and cabal is pedantic and doesn't let you compile if you forget the deps
07:48:43 <EvilTerran> mattam, yes, if you compile different modules at different times
07:48:43 <Beelsebob> C-Keen: because main must return an IO ()
07:48:44 <C-Keen> EvilTerran: expected IO () got IO Bool
07:48:49 <Beelsebob> you're asking it to return an IO Bool
07:48:51 <dolio> vixey: That Coq doesn't accept it isn't necessarily wrong, it may just be that Prop in Coq isn't proof irrelevant.
07:49:01 <dolio> vixey: But I don't know.
07:49:04 <Beelsebob> C-Keen: main returns the same type as test in your program
07:49:05 <EvilTerran> C-Keen, you've told it that main :: IO (), but then the last line of it :: IO Bool
07:49:07 <mattam> That's interesting.
07:49:08 <Beelsebob> test return an IO Bool
07:49:10 <vixey> dolio, oh you're right.. yeah thanks
07:49:34 <C-Keen> ok
07:49:57 <vixey> dolio, but I think Agda has proof irrelevance without the flag for it
07:50:01 <PeakerWork> hmm, why do you get a warning when you export a module only for its instances? (warning says nothing was exported)
07:50:05 <vixey> because that pattern matching lets you prove it
07:50:16 <vixey> (the axiom.. it's just they don't have it throughout the type checking rules)
07:50:23 <EvilTerran> PeakerWork, the instances are exported anyway without re-exporting the module
07:50:32 <vixey> (misuse of 'axiom' :/)
07:50:34 <PeakerWork> EvilTerran: oh, ok thanks
07:50:41 <unenough> can haskell distinguish between 'basic' functions and compositions of functions?
07:50:55 <EvilTerran> unenough, no, functions are abstract
07:51:20 <EvilTerran> composition is nothing special, anyway; it's just another infix operator
07:51:22 <EvilTerran> ?src (.)
07:51:23 <lambdabot> (f . g) x = f (g x)
07:51:27 <C-Keen> EvilTerran: this also means I cannot use exitWith as last command in main?
07:51:35 <C-Keen> :t exitWith
07:51:35 <EvilTerran> ?type exitWith
07:51:36 <unenough> that's not what i meant to ask, i should rephrase my question
07:51:37 <lambdabot> Not in scope: `exitWith'
07:51:37 <lambdabot> Not in scope: `exitWith'
07:51:39 <vixey> why #agda is so quiet :(
07:51:41 <EvilTerran> ?hoogle exitWith
07:51:42 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
07:52:16 <EvilTerran> C-Keen, that'll work fine - the type variable "a" in "ExitCode -> IO a" can be instantiated to ()
07:52:33 <C-Keen> ok
07:52:39 <dolio> vixey: I'm not sure what you mean. It would appear that Conor's example shows that it doesn't have proof irrelevance even with --proof-irrelevance.
07:52:47 <EvilTerran> > ([] :: [a]) :: [Int]
07:52:50 <lambdabot>   []
07:52:55 <EvilTerran> > ([] :: [Bool]) :: [()]
07:52:57 <lambdabot>   Couldn't match expected type `()' against inferred type `Bool'
07:53:36 <C-Keen> hm..
07:53:54 <BONUS> hmm. how would you guys implement a program that just takes line after line of input until someone puts in a blank line, after which all the lines previously typed in are echoed back
07:53:54 <jpcooper> is there some kind of record syntax to show that a field should be itself applied to a certain function?
07:53:57 <BONUS> without using IORef
07:53:59 <unenough> EvilTerran, i'm trying to define a metric that measures distance between objects according to the minimal number of "atomic arrows" (ones that belong to some predefined set) that are needed to get from A to B
07:54:04 <PeakerWork> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-dfa -- how do I get to a patch contribution page to send my fix?
07:54:10 <lambdabot> Title: HackageDB: regex-dfa-0.91, http://tinyurl.com/6garae
07:54:23 <EvilTerran> unenough, i think you'll have to use something more concrete than functions to represent the arrows, in that case
07:54:29 <Beelsebob> PeakerWork: you grab the darcs, patch it, and darcs send it
07:54:38 <PeakerWork> unenough: functions are completely opaque, you're going to either build a different data structure, or compose a function that does what you want alongside the function that doesn't, or modify the function to also do what you want
07:54:41 <telexicon> wow this is nice
07:54:46 <PeakerWork> Beelsebob: I see, if there is a darcs..
07:54:50 <telexicon> message = do char ':'; FullMessage <$> prefix <*> command <|> Message <$> command -- very handy
07:54:56 <PeakerWork> Beelsebob: and if I can find a contact address..
07:55:01 <Beelsebob> telexicon: :)
07:55:12 <Beelsebob> applicatives are lovely, because they let you keep your applicative style
07:55:14 <Deewiant> PeakerWork: "Maintainer" and "Home page" are both given there
07:55:25 <unenough> i think my question was more about category theory than about haskell
07:55:34 <PeakerWork> Deewiant: ah, in darcs itself? I don't know darcs very well
07:55:41 <Deewiant> PeakerWork: no, on the page you linked.
07:55:48 <unenough> PeakerWork, the idea is to use such a metric on a patch system
07:55:49 <Deewiant> i.e. Hackage.
07:56:01 <unenough> where the arrows are patches and objects are versions
07:56:18 <telexicon> Beelsebob, that reduced my code by ~10 lines
07:56:32 <PeakerWork> Deewiant: oh, silly me, thanks ;)
07:56:32 <Beelsebob> telexicon: :D
07:56:42 <Beelsebob> telexicon: not only that, but made the intention clearer too!
07:56:43 <unenough> so we can quantify how 'different' two versions are
07:57:11 <unenough> like, if the difference requires just one user action, they aren't very different
07:57:15 <telexicon> Beelsebob, what would you do for something like this:  try (do h <- hostname; char ' '; return $ Server h) where they are out of order
07:57:31 <Beelsebob> telexicon: use the flip function
07:57:39 <telexicon> oh yeah.. flip
07:57:42 <EvilTerran> or
07:58:02 <EvilTerran> "try (Server <$> hostname <* char ' ')
07:58:06 <Beelsebob> that too
07:58:09 <EvilTerran> ?type (<*)
07:58:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
07:58:17 <EvilTerran> ?src (<*)
07:58:17 <lambdabot> (<*) = liftA2 const
07:58:27 <C-Keen> EvilTerran: well my original question was why this fails: http://hpaste.org/11958 It happens I got the wrong test case the last time
07:58:36 <telexicon> yes i like that most
07:59:39 <Deewiant> GHC can't infer a type signature which can be given manually using only ScopedTypeVariables - is this unexpected?
07:59:46 <Beelsebob> telexicon: in your other one, I'd actually use the raw bind operator -- message = char ':' *> FullMessage <$> ...
07:59:49 <Beelsebob> >> even
07:59:59 <Beelsebob> message = char ':' >> FullMessage <$> ...
08:00:16 <telexicon> Beelsebob, >> and <|> dont get along tho
08:00:25 <Beelsebob> oh, lame
08:00:48 <telexicon> Beelsebob, precedence parsing error cannot mix `(>>)' [infixl 1] and `(<|>)' [infixr 1] in the same infix expression
08:00:57 <Beelsebob> bugger
08:01:02 <orx> where can i find a list of built in functions in haskell?
08:01:09 <Beelsebob> telexicon: you can always add parens
08:01:10 <PeakerWork> orx: Hoogle
08:01:13 <telexicon> Beelsebob, yeah
08:01:22 <orx> cheers
08:02:10 <wjt> C-Keen: fails how?
08:06:11 <telexicon> Beelsebob, and its brilliant client = Client <$> nick <*> user <*> host <* char ' '
08:06:28 <vixey> telexicon, cool :)
08:07:03 <telexicon> so i replaced >>/>>= with do, and now i replaced do with something else
08:07:11 <telexicon> whats the next level of abstraction?
08:07:52 <vixey> , [$i| (,) "foo" "bar" |]
08:08:00 <vixey> ...
08:08:02 <lunabot>  [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('...
08:09:01 <vixey> @where Idioms
08:09:01 <lambdabot> I know nothing about idioms.
08:09:04 <vixey> yes you do
08:09:11 <vixey> @where Idiom
08:09:11 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
08:09:13 <lilac> > liftA2 (,) "foo" "bar"
08:09:15 <lambdabot>   [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('o'...
08:09:15 <telexicon> yeah! thats what i need, idioms
08:09:16 <vixey> @where IdiomBrackets
08:09:17 <lambdabot> I know nothing about idiombrackets.
08:09:25 <vixey> @go Idiom Brackets haskell
08:09:29 <lambdabot> http://www.haskell.org/haskellwiki/Idiom_brackets
08:09:29 <lambdabot> Title: Idiom brackets - HaskellWiki
08:10:39 <telexicon> :t join
08:10:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:11:13 <vixey> > join ["quux","baz","sponge"]
08:11:15 <lambdabot>   "quuxbazsponge"
08:11:20 <vixey> > join (Just (Just 4))
08:11:21 <lambdabot>   Just 4
08:12:25 <telexicon> oh that kind of deal
08:12:49 <telexicon> :t (>>)
08:12:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:13:04 <telexicon> > Just 4 >> Just 5
08:13:06 <lambdabot>   Just 5
08:13:10 <orx> how to join a list of type char into a string?
08:13:18 <lilac> C-Keen: runTests will return True regardless of what happens
08:13:19 <lilac> orx: id
08:13:21 <telexicon> orx, a list of Char is a String
08:13:21 <vixey> > Nothing >> Just 5
08:13:23 <lambdabot>   Nothing
08:13:31 <telexicon> :info String
08:13:36 <lilac> > ['a','b','c']
08:13:38 <lambdabot>   "abc"
08:14:08 <telexicon> orx, type String = [Char]
08:14:14 <lilac> how does the Show instance for [] work? surely Show a => Show [a] must overlap Show String?
08:14:30 <vixey> we don't ask what goes on in the compiler
08:14:42 <orx> thatnks
08:14:58 <telexicon> wouldnt it just be, String is a more specific type?
08:15:11 <vixey> (I'd have thought maybe.. having stuff like that _built into the language_ might suggest thaht people using the language would ... maybe... also want to use this feature)
08:15:34 <lilac> ours is not to question why :)
08:15:56 <lilac> so it's just magic then? that's a pity.
08:16:35 <quicksilver> lilac: it's not magic
08:16:49 <quicksilver> it's a perfectly legal haskell98 utterly disgusting hack
08:17:00 <telexicon> what if it just built a type tree, and then the further down on the tree (more specific) ones take precedence
08:17:09 <quicksilver> telexicon: that's what overlapping instances does
08:17:16 <quicksilver> (that's a horrible solution by the way)
08:17:20 <lilac> quicksilver: ah, i see. there's a showList member in Show. yuck
08:17:21 <telexicon> oh
08:17:26 <quicksilver> lilac: yup :)
08:17:33 <telexicon> i guess that'd be the naive solution cause i just thought of that
08:17:39 <lilac> *shudder*
08:17:40 <telexicon> quicksilver, whats the trendy solution?
08:17:42 <quicksilver> it breaks parametricity, in a sense.
08:17:44 <quicksilver> there is none.
08:17:57 <quicksilver> the trendy solution is to write parametric functions.
08:18:00 <quicksilver> or specific ones :)
08:18:00 <telexicon> darn, guess its time for a new type solution
08:18:05 <quicksilver> but not try to mix them.
08:18:18 <quicksilver> parametricity is too nice to give up without a fight.
08:18:28 <Saizan_> the cleanest solution is to use a newtype
08:18:39 <lilac> the trendy solution is to recognise that strings aren't just lists of Char :)
08:18:50 * lilac looks at ByteString
08:20:47 <orx> is there a function randomly takes one element of a list?
08:22:43 <PeakerWork> Did anyone here use Regexps?
08:23:41 <grul> orx, oneOf or something like that
08:24:20 <vixey> :t oneOf
08:24:28 <lambdabot> Not in scope: `oneOf'
08:25:05 <idnar> @instances Functor
08:25:06 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:26:32 <quicksilver> lilac: or just wrap them in a newtype
08:26:37 <orx> ive got this task with huffman coding
08:26:44 <quicksilver> lilac: so whether or not they are lists of Chars becomes an implementation detail
08:26:47 <orx> anyone familiar with that?
08:26:49 <quicksilver> lilac: rather than a visible one.
08:27:11 <quicksilver> lilac: but of course the reason we don't do that is there are so many nice general functions on lists.
08:27:41 <PeakerWork> The example: "no match" =~ pat :: (MatchOffset,MatchLength)  works, but:  "no match" =~ pat :: [(MatchOffset,MatchLength)]  doesn't (lacking instances)
08:27:50 <orx> type coding :: [(Char, [Bool])]
08:28:01 <orx> and i takes the above input
08:28:29 <orx> and and codes a string
08:29:13 <orx> Code :: coding -> String -> [Bool]
08:29:29 <orx> and i have no idea how to start
08:29:47 <orx> i know what it should do but i just cant put it into haskell
08:30:05 <vixey> orx, what should it do?
08:30:16 <lilac> quicksilver: enter Foldable :)
08:30:21 <vixey> orx, oh
08:30:37 <quicksilver> lilac: Foldable can't be used to implement "take"
08:30:39 <quicksilver> (for example)
08:30:43 <vixey> orx, I see what you mean now.. for every char you want to replace with the [Bool],, then join them all up
08:31:22 <vixey> orx, so to do this replace for a single char you can write   codeChar :: Coding -> Char -> Maybe [Bool], and the function lookup can be useful
08:31:36 <orx> yeah join all the chars into a string
08:31:38 <vixey> orx, then you can   map (codeChar codeTable) to get String -> [Maybe [Bool]]
08:31:51 <vixey> orx, so all that is left is a way to turn [Maybe [Bool]] into [Bool]
08:33:15 <orx> right let me try that
08:35:05 <vixey> is there any theory for programming stuff like Zippers, (==), .. over classes of data types
08:36:26 <PeakerWork> is there a sane O()  way to replace a substring in Haskell, or do I have to write a dfa myself?  regex-dfa is too big/complex, its taking me a while to see how to use it properly
08:37:04 <vixey> what is O() ?
08:37:10 <seliopou> Big-Oh
08:37:33 <vixey> oh right
08:37:39 <lilac> quicksilver: doesn't it depend what you want 'take' to return? (eg, take n . toList)
08:37:40 <vixey> I was expecting O(<something in here>)
08:38:01 <unenough> > Text.Regex.matchRegexAll
08:38:03 <lambdabot>       Overlapping instances for Show
08:38:03 <lambdabot>                                  (Regex ...
08:38:09 <Deewiant> PeakerWork: what exactly do you want to do?
08:38:10 <vixey> I'm sure you can find KMP on bytestrings
08:38:11 <unenough> > Text.Regex.matchRegexAll "test" "test"
08:38:12 <lambdabot>   Couldn't match expected type `Regex' against inferred type `[Char]'
08:38:16 <quicksilver> lilac: yes, it does.
08:38:16 <vixey> @go KMP on bytestrings
08:38:18 <lambdabot> No Result Found.
08:38:24 <unenough> > Text.Regex.matchRegexAll (regex "test") "test"
08:38:26 <PeakerWork> Deewiant: search/replace a substring
08:38:29 <lambdabot>   Not in scope: `regex'
08:38:30 <PeakerWork> Deewiant: in a string
08:38:33 <quicksilver> lilac: putting everything via toList seems to miss the point somehow though :)
08:38:42 <Deewiant> PeakerWork: i.e. f "foobar" "foo" "bar" -> "barbar" ?
08:38:50 <Deewiant> or some such?
08:39:19 <PeakerWork> Deewiant: Yeah, I think I finally found something that works (subRegex)
08:39:40 <bd_> :t subRegex
08:39:42 <lambdabot> Not in scope: `subRegex'
08:39:48 <Deewiant> PeakerWork: I have some old code for doing that, it's not that hard to write using splitAt
08:39:49 <bd_> @hoogle subRegex
08:39:50 <lambdabot> No results found
08:39:51 <unenough> @hoogle regex
08:39:51 <lambdabot> package regex-base
08:39:52 <lambdabot> package regex-compat
08:39:52 <lambdabot> package regex-dfa
08:39:54 <unenough> @hoogle regex'
08:39:54 <lambdabot> No results found
08:40:24 <bd_> Deewiant: with splitAt, you'll be using O(n) memory, which may be an issue on long (or infinite) strings
08:41:08 <luite> > let concatWithout l = zipWith (++) (scanl (++) [] l) $ tail (scanr (++) [] l) in concatWithout [[1],[2],[3],[4]]
08:41:09 <lambdabot>   [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
08:41:15 <Deewiant> bd_: where n is the length of the string to be replaced, yes. So length "foo" in the above example.
08:41:31 <bd_> Deewiant: where n is the length of the string /before/ the point to be replaced, surely?
08:41:52 <Deewiant> http://hpaste.org/11959
08:41:56 <Deewiant> bd_: I don't think so, no.
08:42:37 <bd_> oh, I see what you mean
08:43:16 <unenough> i have a ghci error
08:43:41 <unenough> http://hpaste.org/11960
08:44:14 <Deewiant> unenough: you're using two or more libraries which have been built against different versions of bytestring.
08:44:27 <unenough> Deewiant, how can i find out which libraries?
08:44:30 <Deewiant> or which /are/ different versions of bytestring.
08:44:46 <Deewiant> unenough: well, presumably it tells you which libraries it's loading.
08:44:58 <Deewiant> -v might even tell you why, although I don't think so.
08:44:59 <unenough> ah it does.
08:45:20 <unenough> cabal doesn't uninstall, right?
08:45:32 <Deewiant> nope.
08:45:44 <matthew-_> ok, so it's fairly safe to say I have no idea why something like {-# INCLUDE <math.h> #-} is necessary. Even if (in this case) math.h is a completely empty file, everything still seems to work.
08:45:47 <unenough> bummer
08:45:58 <matthew-_> the header clearly isn't being checked that it defines the functions imported
08:46:07 <matthew-_> so what's it there for?
08:46:37 <dcoutts> unenough: not yet, you need to ghc-pkg unregister and rm the files
08:46:44 <unenough> ok
08:48:45 <unenough> dcoutts, can i tell it to unregister a specific version
08:49:50 <RayNbow> > let h l = zipWith (++) (inits l) (tail (tails l))    in    h [1,2,3,4]  -- luite?
08:49:54 <lambdabot>   [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
08:50:37 <Deewiant> unenough: just specify a specific version. foo-0.1 or whatnot: ghc-pkg list gives what's registered
08:50:40 <lilac> matthew-_: might be interesting to look at the generated C file and run it through the preprocessor, to check it's picking up the math.h you think it is
08:51:39 * Cale wonders why we *still* don't have basic things like selections and permutations in the Data.List library.
08:52:01 <quicksilver> matthew-_: it's there in case it defines macros, in principle
08:52:03 <matthew-_> lilac: mmm. In this case it's dynamically linking against a shared object and that all works fine. I wonder if the header's used when there is no shared object to link against. But I'm guessing, and that seems rather unlikely actually.
08:52:07 <matthew-_> quicksilver: ahh!
08:52:18 <quicksilver> or other things which subvert C's otherwise simple ABI
08:52:29 <Deewiant> Cale: permutations is in Data.List.
08:52:39 <quicksilver> I think that practice might now be obsolete
08:52:41 <Deewiant> Cale: as is subsequences.
08:52:52 <Cale> Deewiant: oh, interesting, it actually is :)
08:52:54 <luite> RayNbow: I need it to do the operation in the same order each time
08:52:59 <luite> > let concatWithout l = zipWith (++) (scanl (\x y -> "["++x++"]"++y) [] l) $ tail (scanr (\x y -> "["++x++"]"++y) [] l) in concatWithout ["a","b","c","d"]
08:53:00 <lambdabot>   ["[b][c][d]","[]a[c][d]","[[]a]b[d]","[[[]a]b]c"]
08:53:01 <Cale> Deewiant: That's new in 6.10 then.
08:53:05 <Deewiant> Cale: yep.
08:53:18 <Cale> I wonder where select went.
08:53:37 <dcoutts> unenough: yes, ghc-pkg unregister Foo-1.0
08:53:53 <luite> the second element in the result should be [[[]a]c]d
08:55:12 <BONUS> also a function people often ask for is f 3 "whoopsie" -> ["who","ops","ie"]
08:55:21 <Cale> > let select [] = []; select (x:xs) = (x,xs):[(y,x:ys) | (y,ys) <- select xs] in select [1,2,3]
08:55:26 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
08:55:51 <matthew-_> ahh, it's also needed if you use hsc and symbols
08:55:53 <vixey> select(X,[X|XS],XS). select(X,[E|XS],YS) :- select(X,XS,YS).
08:56:08 <Cale> Actually, I would recommend the pairs go the other way around if the mtl was designed properly ;)
08:56:22 <dolio> What happened to swap and fst3 etc.?
08:56:41 <vixey> you know what
08:56:50 <vixey> ocaml batteries uses &&& and *** for tuple functions
08:56:51 <Cale> The reason being that select's type is secretly  StateT [a] [] a
08:56:55 <vixey> so.. stupid.........
08:57:07 <quicksilver> dolio: fst3 is evil. Resist the temptation.
08:57:23 <idnar> @type fst3
08:57:25 <lambdabot> Not in scope: `fst3'
08:57:26 <dolio> I thought it was going in. I'm more concerned about swap, though.
08:57:30 <vixey> it's Prolog (a,[a],[a])
08:57:31 <Deewiant> > nubBy ((==) `on` fst) . map (head &&& tail) . permutations $ [1,2,3]
08:57:33 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[2,1])]
08:57:34 <idnar> fst3 (a,b,c) = a?
08:57:44 <Cale> Deewiant: Wrong type ;)
08:57:59 <pumpkin> I feel sympathy for non-pair tuples that get no love
08:58:03 <Deewiant> Cale: bah :-P
08:58:07 <Cale> Deewiant: (there's an extra Eq context)
08:58:17 <ksandstr> idnar: followed closely by snd3 and trd3
08:58:21 <Deewiant> which reminds me, I'll ask for a third time just in case
08:58:28 <idnar> ksandstr: heh
08:58:29 <Deewiant> GHC can't infer a type signature which can be given manually using only ScopedTypeVariables - is this unexpected?
08:58:31 <Twey_> pumpkin: Nobody needs non-pair tuples anyway :-P
08:58:39 <pumpkin> Twey_: still, they haz no love
08:58:48 * pumpkin strokes (,,)
08:58:50 <matthew-_> Deewiant: no
08:58:51 <quicksilver> Deewiant: depends what kind of type signature.
08:58:56 <Twey_> Hehe
08:59:00 <quicksilver> Deewiant: if it's higher rank, that's not at all unexpected.
08:59:02 <Cale> Deewiant: No, that's the point of ScopedTypeVariables, there are rare cases that they're actually required.
08:59:06 <quicksilver> if it's h98 then it is.
08:59:17 <PeakerWork> Deewiant: is it not possible to refactor out that sub-expression to a separate function, or have it take the lexical scope variables explicitly?
08:59:17 <matthew-_> Cale: aka most of the code I write ;)
08:59:18 <Cale> Even in H98, I think.
08:59:21 <Deewiant> It's not H98 because it requires ScopedTypeVariables. It does use MPTCs, though.
08:59:44 <Cale> matthew-_: What kind of code do you write? Are you the one who was working on session types?
08:59:49 <quicksilver> when you say 'GHC can't infer' what do you actually mean?
08:59:50 <Deewiant> No RankNTypes or anything such.
08:59:51 <matthew-_> Cale: the very same :)
08:59:54 <Deewiant> quicksilver: doesn't compile it.
09:00:02 <quicksilver> that doesn't necessarily mean it can't infer a type
09:00:03 <Deewiant> rigid type variables, etc.
09:00:12 <quicksilver> it might mean, it inferred an ambiguous tyep
09:00:14 <Deewiant> Well, I'm sure it infers a type, but not the right one. :-)
09:00:20 <Deewiant> Not the most general one.
09:00:22 <quicksilver> "show . read"
09:00:30 <luite> RayNbow: ff nagedacht, een snellere manier kan alleen als de (*) operator associatief is, dus veel beter dan de zipWith oplossing wordt het niet
09:00:34 <quicksilver> is a trivial example of something h98 can't infer without help.
09:00:38 <luite> uh, wrong channel
09:00:47 <Deewiant> ?ty show . read
09:00:48 <Twey_> :t show . read
09:00:49 <lambdabot> String -> String
09:00:50 <lambdabot> String -> String
09:00:59 <Twey_> Hm
09:01:03 <Twey_> Premature specialisation
09:01:06 <dolio> That's defaulting at work.
09:01:13 <dolio> > (show . read) "()"
09:01:19 <lambdabot>   "()"
09:01:25 <Saizan> Deewiant: is it using polymorphic recursion?
09:01:32 <Twey_> Oh, not premature at all, is it.
09:01:33 <pumpkin> quicksilver: why is that?
09:01:36 <afedorov> Question: When I get the error "Couldn't match expected type `[Int]' against inferred type `Int'", which is the "expected type" and which is the "inferred type"?
09:01:41 <dolio> > (show . read) "1234"
09:01:41 <Twey_> Nothing else it could be.
09:01:42 <lambdabot>   mueval: Prelude.read: no parse
09:01:45 <Deewiant> Saizan: without knowing for sure what the term means... I think so, yes.
09:01:49 <afedorov> Question: expected type is what the context says the type should be?
09:01:52 <quicksilver> pumpkin: because the type between show and read could be anything Showable/Readable
09:01:59 <Twey_> afedorov: [Int] is the expected type and Int is the inferred type.
09:02:03 <Cale> afedorov: The expected type is the one coming from the surrounding context, the inferred type is the type of the local thing.
09:02:07 <pumpkin> quicksilver: I mean, why does it have difficulty
09:02:13 <afedorov> Cale: cool, thanks :)
09:02:18 <Twey_> It needs a list of Int and instead you've given it a single Int.
09:02:23 <jeffersonheard> hrm...  wondering.  can I uncurry a type constructor?  like this:  (uncurry GL.Vertex2) (x,y)
09:02:43 <Twey_> > uncurry (,,) (2, 3)
09:02:44 <lambdabot>       Overlapping instances for Show (c -> (a, b, c))
09:02:45 <lambdabot>        arising from a u...
09:02:47 <Cale> jeffersonheard: hmm, no.
09:02:55 <afedorov> Twey_: this is what's confusing me, the next line of the error is "In the first argument of `repeat', namely `v'"
09:02:56 <Twey_> What's that all about?
09:03:01 <jeffersonheard> interesting
09:03:08 <Beelsebob> Cale: would it be possible for you to add InfixApplicative to \bot?
09:03:10 <Saizan> Deewiant: it means that the recursive call is instanced to a different type
09:03:12 <dolio> What?
09:03:15 <Twey_> afedorov: If you need help with your code, you'll have to show it :)
09:03:17 <afedorov> Twey_: but ":t repeat" -> "repeat :: a -> [a]"
09:03:19 <dolio> > uncurry (:+) (5, 4)
09:03:20 <Cale> Beelsebob: InfixApplicative?
09:03:21 <lambdabot>   5.0 :+ 4.0
09:03:35 <pumpkin> :t uncurry
09:03:36 <afedorov> Twey_: can I copy-paste the entire thing here? It's only 6 lines
09:03:38 <Beelsebob> Cale:
09:03:38 <Beelsebob> > Just 5 <^(+)^> Just 3
09:03:40 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:03:41 <lambdabot>   Just 8
09:03:45 <quicksilver> jeffersonheard: type constructors are (also) just functions
09:03:46 <Twey_> afedorov: I'd go for hpaste.org
09:03:51 <ToRA|MSR> type family Uncurry (x :: * -> * -> *) y :: *; type instance Uncurry x (a,b) = x a b
09:03:51 <quicksilver> jeffersonheard: of course you can uncurry them
09:03:56 <Twey_> >3 is usually frowned upon.
09:03:58 <quicksilver> I'm not sure what cale meant.
09:04:01 <Beelsebob> Cale: atm, it's @let ed in there, but it would be nice to have them permanently
09:04:17 <Cale> quicksilver: Uncurry a *type* constructor?
09:04:17 <Deewiant> Saizan: Like "foo (x:xs) = 0 : foo [(x,x)]" or something?
09:04:24 <quicksilver> Cale: ah, sorry, it's a data constructor
09:04:27 <vixey> :t uncurry (,)
09:04:29 <lambdabot> forall a b. (a, b) -> (a, b)
09:04:31 <vixey> :k (,)
09:04:33 <quicksilver> his actual example was a data constructor ;)
09:04:33 <lambdabot> * -> * -> *
09:04:33 <vixey> I did it!
09:04:34 <Saizan> Deewiant: yes
09:04:37 <gwern> is ther any guide to using the list monad? I want to generate all possible permutations of say, "1711" replaced by undersocres - ie. "_711", "__11", "17__", "1_11" and so on
09:04:37 <Cale> ah
09:04:39 <jeffersonheard> I meant data constructor
09:04:44 <jeffersonheard> sorry
09:04:47 <Cale> Ah, okay
09:04:52 <vixey> gwern, Learn Prolog Now
09:04:57 <vixey> @go Learn Prolog Now
09:05:07 <pumpkin> lol
09:05:07 <Cale> Yes, data constructors are otherwise normal functions and you can do anything you can do with normal functions to them.
09:05:08 <Deewiant> Saizan: Then yes, it does.
09:05:10 <lambdabot> http://www.learnprolognow.org/
09:05:10 <lambdabot> Title: Learn prolog now...
09:05:13 <gwern> vixey: but I don't want to!
09:05:35 <gwern> also, I can't use prolog in my haskell programs inasmuch as they are two different languages...
09:05:40 <jeffersonheard> vixey, is LPN anything like RPN?  push Prolog; push Now; Learn
09:05:44 <Deewiant> Saizan: go f ... = ... go (flip f), for instance, where f :: a -> b -> c.
09:05:45 <afedorov> Twey_, et al: http://hpaste.org/11961
09:05:56 <gwern> and I'm sure the list monad can do this sort of thing - I have snippets of code (which I don't understand) which do similar things
09:06:02 <quicksilver> gwern: the list monad is only concatMap
09:06:09 <jeffersonheard> damn, now I want to go write a prolog interpreter in Forth
09:06:11 <quicksilver> gwern: it doesn't add any more power
09:06:12 <Cale> By the way, we really need to get the person running hpaste to run hpaste2: http://www.moonpatio.com:8080
09:06:16 <vixey> gwern, I'm suggesting learning Prolog can be useful for programming in list monad
09:06:17 <quicksilver> just a different way to write stuff.
09:06:29 <vixey> jeffersonheard, nooo :(
09:06:45 <gwern> @hoogle concatMap
09:06:46 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
09:06:46 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
09:06:46 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
09:06:56 <gwern> hum
09:06:56 <Twey_> :t repeat
09:06:57 <lambdabot> forall a. a -> [a]
09:06:59 <vixey> isn't it shapr
09:07:00 <Twey_> afedorov: ^
09:07:01 <Cale> afedorov: Let's work out the types
09:07:03 <Twey_> Oh wait.
09:07:07 <Twey_> Hmm
09:07:10 <Cale> afedorov: y :: [Int]
09:07:15 <Cale> return y :: [[Int]]
09:07:31 <Cale> So  take x (repeat v) must have type [[Int]] as well
09:07:37 <Twey_> That is a peculiar error.
09:07:38 <Cale> Since it's being ++'d to that.
09:07:39 <afedorov> oh, parens around what's after return?
09:07:42 <Twey_> Oh.
09:07:44 <Saizan> Deewiant: that's why it needs a type signature then, and i've found it a bit annoying too, it would be interesting to know if it could try harder to find a type
09:07:53 <Twey_> Obviously.  Heh.
09:08:10 <afedorov> ooooh
09:08:18 <ksf> "But it is certain that we cannot determine, at least not to
09:08:18 <ksf> any nicety, in what degree repeated experiments confirm a conclusion, without
09:08:18 <ksf> the particular discussion of the beforementioned problem; which, therefore, is
09:08:18 <ksf> necessary to be considered by any that would give a clear account of the strength
09:08:18 <ksf> of analogical or inductive reasoning; concerning, which at present, we seem to
09:08:18 <Cale> So, yeah, possibly you want some extra parens there.
09:08:19 <ksf> know little more than that it does sometimes in fact convince us, and at other
09:08:21 <ksf> times not; and that, as it is the means of acquainting us with many truths, of
09:08:23 <Twey_> afedorov: return $ y ++ ...
09:08:23 <ksf> which otherwise we must have been ignorant; so it is, in all probability, the
09:08:25 <ksf> source of many errors, which perhaps might in some measure be avoided, if the
09:08:26 <Cale> return is just an ordinary function
09:08:27 <ksf> force that this sort of reasoning ought to have with us were more distinctly and
09:08:27 <Twey_> ksf: Err
09:08:29 <ksf> clearly understood."   --- It's nice to see that there was a time where English used proper sentence length.  (http://www.stat.ucla.edu/history/essay.pdf)
09:08:31 <lambdabot> Title: LII. An Essay towards solving a Problem in the Doctrine of Chances. By the late  ...
09:08:34 <vixey> looks like a pasteby accident
09:08:35 <Cale> ksf: ...
09:08:42 <Twey_> Haha
09:08:42 <Cale> ksf: ECHAN?
09:08:50 <afedorov> psht! what language gives `return' precedence over array concatenation!?
09:08:55 * afedorov goes back into hater mode.
09:08:59 <Cale> afedorov: return is a function
09:09:00 <pumpkin> lol
09:09:01 <Deewiant> Saizan: I suppose it /could/, since a valid type exists. It might be undecidable though :-/
09:09:03 <vixey> afedorov: Haskell!
09:09:05 <afedorov> jk, jk, I don't really get what return is
09:09:10 <pumpkin> :t return
09:09:10 <afedorov> ah, hm, interesting
09:09:11 <ksf> It's just one bleeding sentence!
09:09:11 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:09:14 <Cale> afedorov: Function application binds more tightly than any operator.
09:09:22 <Twey_> afedorov: Function application binds... oh
09:09:24 <Twey_> Heh
09:09:28 <afedorov> haha
09:09:42 <afedorov> sounds like I need to learn Haskell ;) thanks for the help, guys
09:09:50 <Twey_> It makes sense.  Really.  :)
09:10:08 <afedorov> aside about that - is there a way to make this a list comprehension?
09:10:10 <Cale> Here, you're using the list monad, so  return :: a -> [a]
09:10:12 <Twey_> `foo bar ++ foo baz` would be irritating if we had to write `(foo bar) ++ (foo baz)` all the time.
09:10:15 <Deewiant> Saizan: I thought RelaxedPolyRec would be enough to make it work but evidently not.
09:10:17 <Cale> afedorov: Absolutely.
09:10:35 <vixey> foo(bar) ++ foo(baz)
09:10:39 <Cale> [y ++ take x (repeat v) | x <- [0..n], y <- dice (n-x) (v-1)]
09:10:50 <Twey_> vixey: See?  Highly annoying.  :)
09:11:03 <afedorov> Cale: ah, order in the comma-separated values matters?
09:11:07 * Twey_ has, since learning Haskell, come to dislike brackets.
09:11:13 <vixey> i's funny how like  f(x)  is ok but (f x) has sooooooooo many parens
09:11:18 <Cale> afedorov: Yes, it's the order in which the choices get made.
09:11:24 <afedorov> Cale: cool, thanks
09:11:36 <Cale> afedorov: The list monad is effectively the same thing as list comprehensions.
09:11:40 <Twey_> vixey: I think they're both as bad as each other, personally
09:11:49 <Cale> afedorov: The advantage being that all the stuff in Control.Monad is available too.
09:11:58 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
09:12:00 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
09:12:15 <Cale> > filterM (const [True,False]) [1,2,3]
09:12:20 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:12:42 <afedorov> hm, that'll make sense to me soon, I'm sure
09:12:44 <Twey_> :t filterM
09:12:46 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:13:04 <Twey_> Oh, that's new.
09:13:04 <dolio> > filterM (const [False,True]) "abcd"
09:13:05 <lambdabot>   ["","d","c","cd","b","bd","bc","bcd","a","ad","ac","acd","ab","abd","abc","...
09:13:20 <Twey_> Why `[a]` and not `m a`?
09:13:23 <dolio> > mapM (\c -> ['_',c]) "abcd"
09:13:24 <lambdabot>   ["____","___d","__c_","__cd","_b__","_b_d","_bc_","_bcd","a___","a__d","a_c...
09:13:28 <vixey> I don't really care about concrete syntax
09:13:44 <vixey> I just hear people complain about how (f x) has more parens than f(x) quite often
09:13:48 <Twey_> (a -> m Bool) -> m a -> m (m a) would be fairly cool.
09:13:48 <gwern> hm. I wonder if that ordering is deterministic
09:13:54 <gwern> > drop 1 $ mapM (\c -> ['_',c]) "abcd"
09:14:01 <lambdabot>   ["___d","__c_","__cd","_b__","_b_d","_bc_","_bcd","a___","a__d","a_c_","a_c...
09:14:08 <gwern> > drop 1 $ mapM (\c -> ['_',c]) "1711"
09:14:09 <lambdabot>   ["___1","__1_","__11","_7__","_7_1","_71_","_711","1___","1__1","1_1_","1_1...
09:14:21 <vixey> :t (\c -> ['_',c])
09:14:22 <lambdabot> Char -> [Char]
09:14:25 <vixey> :t ('_':)
09:14:26 <lambdabot> [Char] -> [Char]
09:14:32 <vixey> :t ('_':).return
09:14:33 <lambdabot> Char -> [Char]
09:14:52 <gwern> > drop 1 $ reverse $ drop 1 $ mapM (\c -> ['_',c]) "1711"
09:14:54 <lambdabot>   ["171_","17_1","17__","1_11","1_1_","1__1","1___","_711","_71_","_7_1","_7_...
09:15:12 <gwern> that's better
09:15:33 <Twey_> > mapM $ (:"_") "1711"
09:15:34 <lambdabot>   Couldn't match expected type `a -> m b'
09:15:38 <Twey_> :(
09:15:46 <dolio> No $
09:15:50 <Twey_> Oh
09:15:51 <Twey_> > mapM (:"_") "1711"
09:15:51 <Twey_> Yes, silly me
09:15:52 <lambdabot>   ["1711","171_","17_1","17__","1_11","1_1_","1__1","1___","_711","_71_","_7_...
09:16:13 <Twey_> I think doubly-linked lists should be easier :(
09:16:17 <pumpkin> @src mapM
09:16:17 <lambdabot> mapM f as = sequence (map f as)
09:16:23 <vixey> easier than what?
09:16:39 <Saizan> easier to implement i guess
09:16:40 <quicksilver> Twey_: what property of a doubly linked list are you interested in?
09:16:49 <quicksilver> (or properties)
09:16:50 <pumpkin> I want a triply linked list
09:16:53 <Twey_> In this case, the ability to trim an element off either end.
09:16:58 <Twey_> Without reversing.
09:17:05 <vixey> Twey_: double linked list doesn't do that
09:17:08 <quicksilver> Data.Sequence
09:17:09 <vixey> @docs Data.Seq
09:17:10 <lambdabot> Data.Seq not available
09:17:17 <vixey> @docs Data.Sequence
09:17:18 <lambdabot> Data.Sequence not available
09:17:22 <Twey_> I know Sequence exists
09:17:23 <vixey> this is useful
09:17:24 <pumpkin> fail
09:17:26 <quicksilver> vixey: well a doubly linked list with two end pointers does.
09:17:26 <Twey_> It's just... kind of awkward.
09:17:33 <quicksilver> Twey_: no it's not?
09:17:37 <vixey> quicksilver, It's in ST ?
09:17:37 <quicksilver> (what are you talking about?)
09:17:41 <vixey> or IO
09:17:41 <quicksilver> no, it's not.
09:17:46 <vixey> you can't od it pure
09:17:46 <gwern> > tail $ mapM (:"_") "1711"
09:17:51 <lambdabot>   ["171_","17_1","17__","1_11","1_1_","1__1","1___","_711","_71_","_7_1","_7_...
09:17:59 <ziman> you'd need mutability with doubly linked lists
09:18:04 <quicksilver> no you wouldn't.
09:18:04 <Twey_> > let m = mapM (:"_") "1711" in drop 1 $ take (length m - 1) m
09:18:05 <lambdabot>   ["171_","17_1","17__","1_11","1_1_","1__1","1___","_711","_71_","_7_1","_7_...
09:18:15 <quicksilver> you'd need mutability to do useful things with them
09:18:23 <quicksilver> you don't need mutability merely for them to exist.
09:18:24 <int-e> Twey_: ouch. take (length m - 1) --> init
09:18:24 <quicksilver> ;)
09:18:25 <Twey_> Oh, aye.  tail = drop 1
09:18:27 <vixey> such as "trim an element off either end."
09:18:29 <ziman> this is what i meant. :)
09:18:39 <Cale> doubly linked lists are almost completely useless as pure datastructures.
09:18:39 <Deewiant> Twey_: except that tail [] = _|_ and drop 1 [] = []
09:18:39 <Twey_> > let m = mapM (:"_") "1711" in tale $ init m
09:18:40 <lambdabot>   Not in scope: `tale'
09:18:46 <Twey_> Ack!
09:18:49 <vixey> Cale, .'.. almost?
09:18:56 <quicksilver> Twey_: why do you perceive Sequence as being awkward?
09:18:57 <Cale> Because modifying any part of them requires updating the entire structure.
09:18:59 <quicksilver> I'm baffled.
09:19:18 <Twey_> > tail . init $ mapM (:"_") "1711"
09:19:20 <lambdabot>   ["171_","17_1","17__","1_11","1_1_","1__1","1___","_711","_71_","_7_1","_7_...
09:19:31 <Twey_> Think that's as nice as you get, gwern
09:19:40 <Cale> However, if you don't need to modify them, you can do fun tying-the-knot type tricks.
09:19:56 <vixey> what is the use
09:20:07 <gwern> Twey_: I'm going with 'permute = drop 1 . mapM (:"_")'
09:20:22 <vixey> gwern, why calling it permute? :(
09:20:44 <gwern> vixey: because that's what makes most sense in my mind. I want permutations of a data so I can generate questions
09:20:51 <gwern> *date
09:20:53 <vixey> these aren't permutations
09:20:54 <Cale> gwern: Those aren't permutations.
09:21:02 <Cale> gwern: Permutations are reorderings.
09:21:03 <gwern> (unless you have a better more intuitive name)
09:21:08 <Cale> gwern: Combinations.
09:21:14 <Twey_> quicksilver: Because getting the last element from a Seq involves converting it to a view and then grabbing the first element
09:21:18 <vixey> blankifieds
09:21:18 <Cale> > combinations [1,2,3]
09:21:19 <lambdabot>   Not in scope: `combinations'
09:21:28 <Cale> Oh, right. No 6.10 ;)
09:21:36 <Deewiant> not in 6.10 either
09:21:38 <gwern> Cale: what would I be combining with the date?
09:21:42 <vixey> or just blankify if you are thinking about it in tems of list monad
09:21:44 <Deewiant> > permutations [1,2,3]
09:21:46 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
09:21:47 <Cale> Oh, is it subsequences?
09:21:52 <Deewiant> yeah
09:21:58 <Twey_> And it's not really possible to pattern match on the end at the moment
09:22:07 <Cale> > subsequences [1,2,3]
09:22:08 <lambdabot>   Not in scope: `subsequences'
09:22:09 <vixey> Twey_, yes it is
09:22:15 <Cale> Nope, we'll have to bug lispy :)
09:22:16 * gwern supposes I could call it 'allBlankifieds'...
09:22:28 <vixey> not even 'all'
09:22:31 <vixey> just blankifieds
09:22:34 <Cale> hehe
09:22:40 <vixey> or blankify
09:22:41 <quicksilver> Twey_: well, it wouldn't be hard to write "last" if you want to.
09:22:49 <quicksilver> Twey_: and you pattern match on the right by using ViewR
09:22:53 <vixey> is it possible to get lambdabot to link te docs?
09:22:54 <Deewiant> > subsequences [1,2,3]
09:22:57 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
09:22:58 <vixey> @go Data.Sequence
09:23:01 <quicksilver> Twey_: I don't think that really qualifies as awkward, personally
09:23:01 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Sequence.html
09:23:01 <lambdabot> Title: Data.Sequence
09:23:10 <Twey_> quicksilver: Not without view patterns
09:23:16 <gwern> cvs.haskell.org?
09:23:19 <gwern> Hugs?
09:23:19 <vixey> Twey_, you don't need view patterns
09:23:49 <Cale> :<
09:23:53 <Cale> hehe
09:24:03 <quicksilver> Twey_: you don't need view patters to write "case (viewr s) of EmptyR -> ... s' :> x -> ...
09:24:12 <vixey> or eve
09:24:15 <vixey> foo EmptyR = ...
09:24:16 * gwern looks into where this cvs.haskell.org nonsense is coming from in lb
09:24:20 <vixey> foo (s' :> x) = ...
09:24:30 <Saizan> gwern: it's google.
09:24:31 <vixey> bar = foo . viewR
09:24:39 <RayNbow> does anyone know when source code documentation will be generated for http://www.haskell.org/ghc/docs/latest/html/libraries/ ?
09:24:40 <lambdabot> Title: Haskell Hierarchical Libraries
09:24:46 <Saizan> gwern: @go == @google
09:24:59 <gwern> Saizan: who do I complain to about this google of which you speak???
09:25:21 <RayNbow> and when will Hoogle's index be updated? :)
09:25:33 <Saizan> gwern: sssh, they may hear you.
09:25:39 * Twey_ blinks at the stranded preposition and the following careful avoidance of such in the same sentence.  :-P
09:25:59 * gwern will be goods, is promise!
09:28:26 <Twey_> http://hpaste.org/11962  Dominoes with Seq, please improve
09:30:05 <vixey> Twey_, don't use view like that I suggest
09:30:11 <vixey> Twey_, try it the way I mentioned earlier
09:30:56 <vixey> Twey_, actualyl in this case not even using pattern matching makes snense.. just  tail  and  init
09:31:48 <Badger> Twey_: !
09:32:21 <dolio> > permutations [1,1,1]
09:32:23 <lambdabot>   [[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1]]
09:32:48 <C-Keen> wjt: like this http://hpaste.org/11958
09:32:54 <Twey_> Badger: 'ey oop
09:33:03 <Twey_> vixey: With a separate function to convert to a view?  :-\
09:33:14 <Saizan> Twey_: does that compile? EmptyL :: ViewL a, not Seq a
09:33:39 <Twey_> Saizan: No idea.  Possibly not.  :-P
09:33:50 <Twey_> I think I tested it, but it was a while ago.
09:34:32 <wjt> C-Keen: one branch of each inner if has type IO Bool, the other IO ()
09:34:40 <wjt> C-Keen: return does not return from the action early
09:35:01 <C-Keen> wjt: is it clear what I want to do? How do I do that in haskell?
09:35:51 <wjt> C-Keen: http://hpaste.org/11958#a2
09:36:06 <vixey> Twey_, no init and tail
09:36:10 <vixey> > init "fooo"
09:36:12 <lambdabot>   "foo"
09:36:12 <vixey> > tail "fooo"
09:36:14 <wjt> note that now the final action of the do block in each branch has type IO Bool
09:36:14 <lambdabot>   "ooo"
09:36:22 <vixey> just use (or define) analogues of them on Seq
09:36:42 <Saizan> Twey_: http://hpaste.org/11962#a1
09:36:59 <Twey_> Well I'm really more interested in head/last in this case...
09:37:56 <C-Keen> wjt: http://hpaste.org/11958#a3
09:38:05 <Twey_> Saizan: I'm tempted to define that as 'worse' rather than 'better'... :-P
09:38:19 <C-Keen> wjt: do I have to do a Monad Transformation here?
09:38:29 <Twey_> That's just desugaring the separate definitions, no?
09:38:53 <Saizan> Twey_: that at least compiles, which i think it's better :)
09:39:34 <Twey_> Ah, heh
09:39:50 <Twey_> Well, the first function might :-P
09:39:54 <wjt> C-Keen: no
09:40:14 <C-Keen> wjt: My problem is I don't understand the error message
09:42:10 <lilac> C-Keen: in the error message it says: "else putStrLn "All bug tests OK" return True"
09:42:21 <lilac> note, no 'do' and no newline before 'return'
09:42:28 <wjt> that exact code, with run :: [String] -> IO [String], compiles
09:42:44 <lilac> C-Keen: this indicates that the code being compiled doesn't match the code in hpaste.org
09:42:45 <Saizan> Twey_: if you like pointsfree :) http://hpaste.org/11962#a2
09:44:05 <Twey_> Saizan: Nice :-P
09:44:07 <C-Keen> wjt: oh
09:46:02 <C-Keen> wjt, lilac thanks for opening my eyes
09:48:01 <pastorn> Int is 32 bit, right?
09:48:10 <pastorn> (by default)
09:48:29 <dolio> Depends.
09:48:47 <dolio> It's 32 on (most?) 32-bit platforms.
09:48:55 <pastorn> well, i want to do this:
09:48:56 <dolio> 64 on 64-bit platforms.
09:48:58 <Raevel> 2^29 at the lowest
09:49:17 <dolio> Yeah, the report guarantees 30 bits, I think.
09:49:32 <dolio> (But GHC does what I said.)
09:52:00 <pastorn> \(x,y) -> let x' = truncateTo16Bits x, y' = truncateTo16Bits y in (shiftLeft x' 16) + y' :: (Int,Int) -> Word32
09:53:19 <int-e> @index shiftL
09:53:20 <lambdabot> Data.Bits, Foreign
09:53:50 <pastorn> or maybe i flipped my shiftL there
09:53:55 <pastorn> but what con i do to truncate?
09:54:24 <pastorn> (this is intended as a position to hashmap hashing function)
09:54:36 <dolio> > fromIntegral (2 ^ 17 :: Int) :: Word16
09:54:40 <lambdabot>   0
09:54:44 <dolio> > fromIntegral (2 ^ 15 :: Int) :: Word16
09:54:45 <lambdabot>   32768
09:54:48 <dolio> > fromIntegral (2 ^ 16 :: Int) :: Word16
09:54:50 <lambdabot>   0
09:55:06 <a> Why would one use Int over Integer?
09:55:10 <Saizan> can you use Word32 instead of Int from the start?
09:55:18 <Raevel> a: performance
09:55:35 <pastorn> Saizan: well, that might be possible
09:55:46 <pastorn> Saizan: oooooh, i see what you think there
09:55:56 <dolio> Yeah, x .&. (2^16 - 1) might be the better way to go.
09:55:59 <pastorn> bitwise and with %1111111100000000
09:56:23 <pastorn> or as a 32-bits thingy, rather
09:57:03 <dolio> \x y -> (x .&. mask) `shiftL` 16 + (y .&. mask)
09:58:12 <gwern> woot, I got my mini-parser working
09:58:16 <gwern> ugly as heck, but it basically works
09:58:48 <pastorn> dolio: yeah, that'll work
09:58:54 <bbs> anyone familiar with the golden ratio
09:59:01 <Raevel> somewhat
09:59:15 <byorgey> bbs: sure, why?
09:59:33 <dolio> And in fact you can do .|. instead of +, I guess, if you imagine it will be faster (although I wouldn't count on that).
09:59:35 <bbs> i want to define the goldenratio as an infinite list of the ratio of successive fibbonnaci numbers
09:59:48 <vixey> bbs, map (uncurry (/))
09:59:50 <bbs> like with takeWhile and dropWhile
09:59:56 <vixey> don't use take or drop
09:59:58 <bbs> vixey: again!
10:00:01 <bbs> with uncurry :)
10:00:19 <vixey> > map (uncurry (/)) $ [(0,1),(1,1),(1,2)]
10:00:21 <lambdabot>   [0.0,1.0,0.5]
10:00:28 <opqdonut> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in zipWith (%) fibs (tail fibs)
10:00:30 <lambdabot>   [0%1,1%1,1%2,2%3,3%5,5%8,8%13,13%21,21%34,34%55,55%89,89%144,144%233,233%37...
10:00:33 <opqdonut> there ya go
10:01:08 <byorgey> > let fibs = 0 : 1 : zipWith fibs (tail fibs) in  zipWith (%) (tail fibs) fibs
10:01:09 <lambdabot>   Couldn't match expected type `[a]'
10:01:22 <byorgey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in  zipWith (%) (tail fibs) fibs
10:01:24 <lambdabot>   [* Exception: Ratio.%: zero denominator
10:01:29 <byorgey> whoops =)
10:01:32 <bbs> opqdonut: i have that one
10:01:39 <bbs> thats not list comprehension though is it
10:01:43 <bbs> i think thats just recusion
10:01:51 <PeakerWork> what's STG? I'm lacking the ZCMain_main_closure symbol in linkage
10:01:53 <ddarius> vixey: Don't map . uncurry, zipWith
10:01:55 <int-e> > iterate (\x -> 1/(1+x)) 0 :: [Rational]
10:01:56 <lambdabot>   [0%1,1%1,1%2,2%3,3%5,5%8,8%13,13%21,21%34,34%55,55%89,89%144,144%233,233%37...
10:01:57 <opqdonut> why do you need a list comprehension?
10:01:57 <PeakerWork> (it seems to be said to be part of STG)
10:02:15 <byorgey> PeakerWork: STG is the Spineless Tagless G-Machine
10:02:21 <byorgey> the Haskell runtime
10:02:31 <vixey> why
10:02:34 * ksf searches through his logs...
10:02:34 <vixey> I like mmy way
10:02:35 <byorgey> PeakerWork: that said, you probably just need to add --make.
10:02:36 <ddarius> byorgey: GHC
10:02:39 <vixey> ddarius
10:02:48 <byorgey> er, right, GHC, not Haskell.
10:02:55 <PeakerWork> byorgey: Its not working with --make ...
10:03:08 <vixey> > map (uncurry (/)) . iterate (\(x,y)->(y,y+x)) $ (0,1)
10:03:10 <lambdabot>   [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.619047619047...
10:03:13 <PeakerWork> Having glut trouble as well as STG...
10:03:21 <ksf> > let fibs = 0:1:[(\(a:b:_) -> a + b ) (drop n fibs) |  n <- [0..]] in fibs
10:03:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:03:27 <ksf> that's the original...
10:03:51 <PeakerWork> how does ghc --make decide where to get libs from?
10:03:57 <Saizan> PeakerWork: --make -lglut ?
10:04:17 <Saizan> PeakerWork: yes, but it might not know about some C libs to link in
10:04:24 <byorgey> ksf: that's O(n^2) to compute the nth element of the list
10:04:29 <bbs> opqdonut: i know how to do the other one
10:04:30 <bbs> thats why
10:04:30 <Deewiant> PeakerWork: ghc-pkg knows (or 'should' know)
10:04:36 <bbs> i need a list comprehension versio
10:04:38 <Deewiant> it often doesn't know on Windows :-P
10:04:45 <PeakerWork> Deewiant: I'm on Ubuntu 32bit
10:04:50 <ksf> > let fibs = 0:1:[(\(a:b:_) -> a + b ) (drop n fibs) |  n <- [0..]] in [((\(n:d:_) -> n%d) drop n fibs | n <- [0..]]
10:04:51 <lambdabot>   <no location info>: parse error on input `|'
10:04:52 <byorgey> bbs: is this an assignment for class?
10:04:55 <PeakerWork> Saizan: how does it try to decide which C libs?
10:05:00 <ksf> > let fibs = 0:1:[(\(a:b:_) -> a + b ) (drop n fibs) |  n <- [0..]] in [((\(n:d:_) -> n%d) (drop n fibs) | n <- [0..]]
10:05:01 <lambdabot>   <no location info>: parse error on input `|'
10:05:04 <Deewiant> PeakerWork: In that case your stuff is probably all in /usr/lib so it doesn't really need to know anything. :-P
10:05:20 <ksf> wut?
10:05:37 <ksf> byorgey, it's the list comprehension.
10:05:40 <PeakerWork> Deewiant: ~/devel/haskell/darcs/reactive-fieldtrip/src$ ghc -main-is Test -O2 --make Test  ->  glut not found
10:05:49 <Deewiant> PeakerWork: and where is glut?
10:05:51 <Saizan> PeakerWork: it looks at the extra-libraries field of the haskell packages it includes
10:05:52 <PeakerWork> Deewiant: ~/devel/haskell/darcs/reactive-fieldtrip/src$ ghc -main-is Test -O2 --make Test /usr/lib/libglut.so.3.8.0     -> succeeds
10:05:53 <byorgey> ksf: there are better ways to do it with a list comprehension though.
10:05:57 <PeakerWork> well, it fails too, because it can't find STG
10:06:12 <ksf> > let fibs = 0:1:[(\(a:b:_) -> a + b ) (drop n fibs) |  n <- [0..]] in [(\(n:d:_) -> n%d) (drop n fibs) | n <- [0..]]
10:06:13 <lambdabot>   [0%1,1%1,1%2,2%3,3%5,5%8,8%13,13%21,21%34,34%55,55%89,89%144,144%233,233%37...
10:06:19 <byorgey> ksf: e.g., instead of  doing  n <- [0..],  do  (a,b) <- fibs
10:06:19 <Deewiant> PeakerWork: hm, maybe it wants libglut.so
10:06:22 <ksf> bbs, that close enough?
10:06:27 <Deewiant> PeakerWork: and not a versioned one
10:06:38 <PeakerWork> libglut.so is a symlink, it exists too
10:06:59 <PeakerWork> it works if I use /usr/lib/libglut.so but it doesn't know to put it itself
10:07:04 <ksf> byorgey, fibs ain't an [(a,b)]
10:07:08 <PeakerWork> and it complains about STG which I don't know where to bring from
10:07:09 <vixey> ksf, the thing tah worries me is like drop n keeps happnening
10:07:16 <vixey> ksf, drop 1 drop 2 etc..
10:07:35 <byorgey> ksf: well, I was handwaving, you could make a fibs'  which is [(a,a)] then construct fibs out of that
10:07:40 <bbs> ksf: i have the same concern as vixey :)
10:07:45 <ksf> well any sane person wouldn't use a list comprehension in the first place.
10:07:47 <Saizan> PeakerWork: have you tried with ghc -main-is Test -O2 --make -lglut Test ?
10:07:56 <Deewiant> PeakerWork: you can have a look at ghc-pkg describe glut (or whatever the Haskell package is called) in case there's anything odd there
10:08:00 <vixey> ksf, lol
10:08:20 <PeakerWork> Saizan: that finds glut too
10:08:22 <byorgey> ksf: my point was, using a list comprehension does not a priori restrict you to inefficient solutions.
10:08:36 <ddarius> :t unfoldr
10:08:37 <PeakerWork> Deewiant: extra-libraries: is empty
10:08:40 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:08:41 <Saizan> PeakerWork: but not STG?
10:08:42 <PeakerWork> Deewiant: in describe GLUT
10:08:51 <PeakerWork> Saizan: no, what -l should I use for stg?
10:08:53 <vixey> oh
10:09:03 <ksf> you can definitely factor out the second drop in the golden ratio example, i'm merely successively approximating the best solution.
10:09:11 <Deewiant> PeakerWork: what of ld-options
10:09:21 <PeakerWork> Deewiant: empty too
10:09:27 <vixey> > unfoldr (\(x,y) -> Just (y/x,(y,y+x))) 1
10:09:27 <Saizan> PeakerWork: uhm, tried with -main-is Test.main ? removing Test.hi and Test.o first
10:09:28 <lambdabot>       No instance for (Num (t, t))
10:09:29 <lambdabot>        arising from the literal `1' at <in...
10:09:30 <vixey> > unfoldr (\(x,y) -> Just (y/x,(y,y+x))) (1,1)
10:09:33 <lambdabot>   [1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619047619047...
10:09:49 <PeakerWork> Deewiant: http://hpaste.org/11964
10:09:49 <vixey> good idea
10:09:51 <ddarius> > unfoldr (Just . (uncurry (/) &&& (\(x,y) -> (y,x+y)))) (0,1)
10:09:53 <lambdabot>   [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.619047619047...
10:10:27 <Deewiant> PeakerWork: I've got ld-options: -lglut32 -lglu32 -lGL -lopengl32 on Windows here
10:10:37 <Deewiant> PeakerWork: it's entirely possible I added it manually though :-P
10:10:56 <bbs> ddarius: woah!
10:11:00 <bbs> can you explain that to me?
10:11:12 <bbs> &&& oO
10:11:13 <ksf> > let fibs = (0,0):(1,0):[(n,n+m) | (n,m) <- fibs] in fibs
10:11:14 <lambdabot>   [(0,0),(1,0),(0,0),(1,1),(0,0),(1,2),(0,0),(1,3),(0,0),(1,4),(0,0),(1,5),(0...
10:11:15 <ksf> that won't work.
10:11:21 <Deewiant> PeakerWork: If that's acceptable to you you can use ghc-pkg update to deal with it
10:11:25 <vixey> bbs, in this case,   (f &&& g) x = (f x, g x)
10:11:36 <ksf> > let fibs = (1,0):[(n,n+m) | (n,m) <- fibs] in fibs
10:11:36 <ddarius> bbs: It's just an expansion of iterate's definition in terms of unfoldr and then doing map/unfoldr fusion.
10:11:37 <lambdabot>   [(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),...
10:11:46 <PeakerWork> Deewiant: Weird, I wonder why it didn't get added.
10:11:51 <PeakerWork> Deewiant: Also, how do I have it find STG?
10:11:53 <bbs> ddarius: its neat
10:12:07 <ksf> list comprehension and recursion doesn't really fit.
10:12:15 <ddarius> > unfoldr (Just . (\(x,y) -> (x/y,(y,x+y))) (0,1)
10:12:16 <lambdabot>   <no location info>: parse error on input `;'
10:12:17 <Saizan> PeakerWork: i think the ZCMain_main_closure problem is related to -main-is, you're not supposed to have to link anything about the haskell runtime by hand
10:12:23 <vixey> > unfoldr (\(x,y) -> Just (y/x,(y,y+x))) (1,1)
10:12:25 <lambdabot>   [1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619047619047...
10:12:33 <PeakerWork> Saizan: it worked at my home machine (so did all the glut stuff)
10:12:45 <ddarius> vixey stole my code.
10:13:02 <PeakerWork> Saizan: indeed, -main-is screwed it up, weird
10:13:24 <ddarius> Except flipping the division for some reason.
10:13:25 <vixey> > (sqrt 5 + 1)/2 :: CReal
10:13:27 <lambdabot>   1.6180339887498948482045868343656381177203
10:13:32 <vixey> > (sqrt 5 - 1)/2 :: CReal
10:13:34 <lambdabot>   0.6180339887498948482045868343656381177203
10:16:03 <ksf> furthermore, I'm challenging my solution's alleged ineffectiveness with the sufficient smart compiler conjecture.
10:16:47 <ksf> @remember ksf Furthermore, I'm challenging my solution's alleged ineffectiveness with the sufficient smart compiler conjecture.
10:16:47 <lambdabot> Done.
10:16:57 <rog> is there some fundamental reason why types with free type variables cannot be Typeable?
10:17:50 <int-e> rog: you'd likely be able to write unsafeCoerce :: a -> b
10:18:12 <PeakerWork> rog: type families are not really types of values.. to be an instance of a class you have to be the right kind
10:18:48 <ksf> @where don-quixote-theorem Furthermore, I'm challenging my solution's alleged ineffectiveness with the sufficient smart compiler conjecture.
10:18:48 <lambdabot> I know nothing about don-quixote-theorem.
10:18:53 <rog> int-e: how so?
10:18:54 <ksf> @where+ don-quixote-theorem Furthermore, I'm challenging my solution's alleged ineffectiveness with the sufficient smart compiler conjecture.
10:18:54 <lambdabot> It is stored.
10:18:55 <int-e> rog: at least as I understand your question - there's room for interpretation :)
10:19:03 <PeakerWork> rog: Consider a   class Blah b where ... :: b Int -> b String  -- in all the methods "b" will be used as though it was the same kind, in this case *->*
10:19:11 <PeakerWork> rog: Typeable uses its type variable as though it was a simple type
10:20:29 <rog> hmm.
10:21:33 <int-e> rog: assume you have data Foo a = Foo a and a typeable instance for Foo a. That Typeable instance can not depend on the type a. That is, cast :: Foo a -> Maybe (Foo b)  would succeed (Typeable can't distinguish Foo a from Foo b), coercing the inner 'a' value to 'b'.
10:21:57 <ddarius> rog: To go beyond monomorphic types is not inherently impossible, all you need to do is move (more of) type checking into the run-time.
10:22:15 <ddarius> rog: For example, Clean can handle polymorphic types for it's Dynamics.
10:22:23 <rog> ddarius: i thought that might be possible
10:22:44 <int-e> rog: did I misinterpret your question?
10:23:43 <rog> int-e: i don't think so. it'd be nice to be able to store a generic number in a Dynamic, for example. or a generic function.
10:24:39 <ksf> byorgey, a postertori concatMap confuses the hell out of me.
10:25:40 * ksf needs to re-read kant sometime
10:26:05 <ksf> wonderful paragraph-long sentences he writes in.
10:26:32 <_pizza_> a terrific sleep-aid.
10:26:54 <ksf> It's kinda like doing an n-back test.
10:27:10 <ksf> definitely trains attention span.
10:34:00 <rog> int-e: i think i see. you can't have a Typeable instance for a type family because all members of the type family are treated equivalently. so do it properly you'd have to make Typeable a fundamental part of the language, i guess. and cast becomes problematic, 'cos you'd want to do superset class equivalence. hmm.
10:34:48 <rog> s/Typeable/Typeable (or its equivalent)/
10:35:14 <gwern> suppose I have this: "[Question "",Answer "1711",Question " was the year David Hume was born in Scotland in"]"; is the easiest way to remove all Question ""s just a 'filter (not . (== Question ""))'?
10:35:49 <gwern> (Eq is derived on Question)
10:35:57 <rog> gwern: /= ?
10:36:01 <Deewiant> sure, but use /= instead of not . == ;-)
10:36:30 <lilac> or arrange for them to not be there in the first place? :)
10:36:40 <gwern> d'oh
10:36:45 <gwern> I knew I was forgetting something
10:37:32 <gwern> I seem to have a real blindsight with /= - I know this is not the first time I've asked that and received it as an answer
10:37:43 <gwern> *blindsopt
10:37:45 <gwern> *blindspot
10:40:11 <rog> i haven't looked at Clean at all. what are its main disadvantages w.r.t haskell ?
10:41:01 <gwern> rog: community
10:41:10 <gwern> fewer people using it, fewer libs, etc.
10:41:22 <gwern> a lesser issue is that of Freedom
10:41:37 <gwern> on the theoretical level, some people actually like monads etc.
10:41:43 * gwern dislikes the clean syntax
10:42:01 <rog> gwern: presumably you  can do monads in clean too, if you wish
10:42:19 <gwern> but they're much more akin than unlike; I'd suggest just starting with haskell, as a later switch to clean would not be difficult
10:42:26 <gwern> rog: of course; it's turing-complete...
10:43:08 <Saizan> Clean is eager
10:43:34 <rog> the web page says it's lazy
10:43:40 <Cale> Clean is lazy
10:43:49 <Saizan> oh ok
10:44:33 <PeakerWork> gwern: on the theoretical level? :-)
10:44:37 <rog> gwern: what particularly do you dislike about the syntax. it seems fairly reminiscent of haskell at first glance.
10:44:55 <PeakerWork> gwern: monads are a generalized interface to do things that many types can do, its nice to be able to express code that is generic to all of them, rather than be specific to a type
10:44:56 <Saizan> however you can have a polymorphic function/number in a Dynamic, but you've to wrap it in a datatype that uses polymoprhic components
10:45:16 <gwern> PeakerWork: I'm not the one you need to be preaching to about monads, mon
10:45:48 <Cale> Actually, I think Clean really could use an IO monad, for one.
10:46:06 <gwern> rog: well, the syntax is very similar to haskell, I'll admit. I think I like the more disciplined use of caps, for starters
10:46:09 <Cale> Just to save having to pass the RealWorld token around.
10:46:13 <gwern> but it was a while since I was comparing clean and haskell
10:46:54 <rog> Cale: presumably you could do that quite easily? but i guess that you'd be on your own a lonely monad world then...
10:47:35 <rog> Saizan: i didn't realise that you could have polymorphic functions inside a typeable datatype.
10:47:44 * gwern feels annoyingly lazy. all the key parts of my script are written, and I just need to pull them together, but instead I keep chatting on irc and browsing
10:47:52 <Cale> rog: Well, you'd want such a thing to be in the Prelude.
10:49:18 <rog> Cale: i don't really see why. after all, it's only really fundamental if you've got syntax support for monads.
10:49:31 <Saizan> rog: it's not easily scalable but it might suit your needs
10:50:23 <Cale> rog: Because an IO monad is only particularly useful if everyone uses it... otherwise it'll just make things awkward.
10:50:45 <Cale> rog: (having to convert back and forth between various representations of IO)
10:53:58 <rog> Cale: i suppose so. although i'd guess (wthout any knowledge at all!) you could lift any of the existing functions into the IO monad trivially.
10:54:21 <Cale> rog: Higher order stuff would be frustrating though.
10:54:30 <Cale> rog: Not impossible, but annoying.
10:59:13 <rog> Saizan: when you say "you've to wrap it in a datatype that uses polymoprhic components", you mean using existential quantification inside a data declaration, right?
11:15:45 <vColin> Is anyone familiar with the simple TCP server implemented at http://sequence.complete.org/node/258?  In particular, I find that when I try it out, and then stress test it using "ab -n 1000 -c 1000 http://localhost:9999/" that it either exits at some point, or it exits when I ctrl-c the ab process, or else it seems to work when I ctrl-c but then exits the next time I startup the stress test and do ctrl-c.  I can't see what 
11:15:48 <lambdabot> Title: A simple TCP server | The Haskell Sequence
11:16:22 <trofi> http://127.0.0.1/
11:16:49 <dons> vColin: isn't it just a toy on a blog post? i'm not sure anyone other than the blog post author would be familiar.
11:17:33 <vColin> Sure, but I wondered if anyone had experienced that sort of behaviour and had any clue what the problem might be.
11:17:50 <vColin> I can't find a way to contact the author on the site either.
11:18:15 <dons> vColin: not with real systems (happs , et al, have survived 2-3k req/s, hyena has gone higher, iirc)
11:21:43 * Cale wonders why hyena is not on Hackage
11:22:04 <dons> unreleased
11:28:27 <digit> i know no programming.  do you think this could actually be of benefit to me if i were to start out learning haskell, comapred with if i knew other languages, given how novel and unique haskell is said to be?
11:28:45 <Cale> digit: It might actually be easier that way :)
11:28:46 <vixey> digit, sounds like a lot of fun :)
11:29:11 <vixey> yeah also that.. it could be easier.
11:29:15 <Badger> @where LYAH
11:29:15 <lambdabot> www.learnyouahaskell.com
11:29:31 <Badger> For great good!
11:29:59 <digit> yeah, i'm just starting the intro to http://book.realworldhaskell.org/read/
11:30:01 <lambdabot> Title: Real World Haskell
11:30:25 * Badger found lyah easier, but s'all good.
11:30:32 <Cale> digit: That book is good, but you *may* find it goes a bit quickly if you're new to programming.
11:30:44 <Cale> I'm not sure :)
11:31:00 <Cale> digit: Also, feel free to ask questions here, there are almost always people around who are willing to help.
11:31:48 <digit> yay.
11:32:02 * digit feels welcomed to ask stupid questions
11:32:07 <Cale> yep :)
11:32:30 <digit> i promis i'll do my best to find answers before asking ;)
11:33:05 <Cale> digit: It's cool, we try to avoid RTFM-style responses. At worst, we'll point you to the appropriate part of the documentation :)
11:33:38 <digit> did someone really just say that!?
11:33:54 <digit> ;D
11:33:58 <Badger> It's shocking to me, too. :P
11:34:01 * Twey takes shameless advantage of this when vis connection's being awkward.  :>
11:34:04 <trofi> > (+) == (+)
11:34:05 <lambdabot>       No instance for (Eq (a -> a -> a))
11:34:05 <lambdabot>        arising from a use of `==' at...
11:34:16 <Twey> Also, I want an Arch package with the GHC docs :(
11:34:59 <Badger> aw
11:35:01 <Badger> not even in aur
11:35:02 <Cale> Twey: I was just considering how to generate a FireFox-importable bookmarks.html tree from installed cabal package documentation.
11:35:12 <vegai> Twey: hmm.
11:35:59 <Cale> There are enough libraries now that it's starting to get annoying to maintain my bookmark tree by hand.
11:36:37 <Cale> It would be super-awesome if cabal maintained a meta-index of all the documentation available.
11:37:11 <dcoutts> Cale: add your vote to http://hackage.haskell.org/trac/hackage/ticket/206
11:37:14 <lambdabot> Title: #206 (Support more haddock options and maintain haddock index.) - Hackage - Trac
11:38:01 * geezusfreeek also wants it
11:38:04 <Badger> :t sum
11:38:06 <lambdabot> forall a. (Num a) => [a] -> a
11:38:12 <Badger> good.
11:41:10 <digit> lol "Learning Haskell is much like learning to program for the first time"
11:41:18 <digit> much
11:41:21 <digit> very much
11:41:53 <vixey> heh
11:41:53 <mapreduce> Depends what you've learned before.
11:43:19 <digit> came in here asking: " i know no programming.  do you think this could actually be of benefit to me if i were to start out learning haskell, comapred with if i knew other languages, given how novel and unique haskell is said to be?"
11:44:09 <JuanDaugherty> digit, yes.
11:44:52 <digit> though its not strictly true... i can do the most basic things in html, and when i was a child, i saw 48basic.  lol.  so, "trace amounts" of programming knowledge.  hehe
11:45:22 <Badger> 10 ow, basic
11:45:23 <Badger> goto 10
11:45:49 <digit> ?
11:46:27 <vixey> basic has lots of GOTO in it :p
11:46:31 <vixey> that's all I remember
11:46:52 <digit> hehe, yeah, wow, bringin back the nostalgia.
11:47:08 <trofi> :t GOSUB
11:47:09 <lambdabot> Not in scope: data constructor `GOSUB'
11:47:20 <Badger> heh
11:47:52 <C-Keen> 10 REM HELLO WORLD!
11:48:00 <C-Keen> 20 PRINT "HELLO WORLD!"
11:48:06 <C-Keen> 30 END
11:48:43 <trofi> very loud language
11:48:58 <C-Keen> trofi: especially on a C64
11:49:11 * Badger prefers COBOL
11:49:20 * trofi had it on z-80
11:49:39 <Badger> IDENTIFICATION DIVISION.
11:49:39 <trofi> had to write all commands by holding many keys at once
11:49:55 <digit> as i read this intro at learnyouahaskell, i'm captivated by its description.. isnt this how all programming languages are?  what are these other muppets up to if not like so?
11:50:22 <C-Keen> digit: what are you referring to?
11:50:35 <digit> referntial transparency, lazy...
11:50:43 <digit> http://learnyouahaskell.com/introduction#about-this-tutorial
11:50:44 <lambdabot> Title: Learn You a Haskell for Great Good! - Introduction
11:50:47 <digit> as described in here.
11:50:49 <vixey> digit, hehe.. no haskell is very uniquie in these respects
11:50:50 <Botje> digit: most languages you'll find out there are strict and not purely functional
11:50:51 <Deewiant> purely functional - very few. lazy - very few. statically typed - most. elegant and concise - very few.
11:51:21 <C-Keen> digit: what other languages that you know are lazy?
11:51:32 <digit> lmao
11:51:33 <Badger> he knows no other languages :P
11:51:41 <C-Keen> good for him
11:51:42 <digit> considering i just learned the term in this context... zero
11:51:57 <C-Keen> digit: once you grasp the concept you will love it
11:52:06 <Badger> http://en.wikipedia.org/wiki/Cobol#Hello.2C_world
11:52:07 <Badger> :)
11:52:09 <C-Keen> and miss it in other languages
11:52:15 <lambdabot> Title: COBOL - Wikipedia, the free encyclopedia
11:52:23 <Botje> digit: laziness makes you juggle around infinite lists without even realizing they're infinite :)
11:52:40 <Badger> sum [1..]
11:52:51 <digit> i love it already from what i grasp, and of course, its xmonad that already had my love that introduced me to this kinky young lady wearing very little, and full of tricks...
11:53:03 <Botje> @vixen are you kinky?
11:53:03 <lambdabot> yes, i am
11:53:07 <Botje> excellent
11:53:09 <Botje> @botsnack
11:53:09 <lambdabot> :)
11:53:13 <digit> lmao
11:53:15 <Badger> :)
11:53:35 * digit applauds Botje
11:54:24 <C-Keen> hehe
11:54:29 <trofi> @let loudly = fmap toUpper
11:54:30 <lambdabot>  <local>:14:9:
11:54:30 <lambdabot>      Ambiguous type variable `f' in the constraint:
11:54:30 <lambdabot>        `Fu...
11:56:38 <Badger> err
11:56:49 <Badger> how does one gain access to map toUpper anyway?
11:56:57 <int-e> @index toUpper
11:56:58 <lambdabot> Data.Char
11:57:02 <Badger> ah
11:57:04 <Badger> thanks
11:57:15 <int-e> @hoogle toUpper
11:57:16 <lambdabot> Data.Char toUpper :: Char -> Char
11:57:19 <digit> i was gonna answer pray for guidance or somethin
11:57:37 <int-e> lambdabot answers your prayers ;)
11:58:29 * digit prays to lambdabot to provisional all with salvation
11:58:31 <Badger> if only she ran more reliably. :P
11:59:05 <trofi> how to teach ghci-6.10's to <delete> symbols properly? prev readline's version worked for me
11:59:33 <wchogg_> conal:  So with that problem we talked about before, would you expect x e = b where b = integral e b to converge to the constant function x(t)=0, given the use of zeroV in sumR?
11:59:57 <trofi> @let loudly = fmap Char.toUpper
11:59:58 <lambdabot>  <local>:14:14: Not in scope: `Char.toUpper'
12:01:21 <trofi> @version
12:01:21 <lambdabot> lambdabot 4.2.1
12:01:21 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:01:36 <Badger> ?
12:01:44 <RayNbow> @let loudly s = fmap toUpper s
12:01:45 <lambdabot>  Defined.
12:01:58 <trofi> you've cheated
12:02:04 <Badger> > loudly "cheater!"
12:02:05 <lambdabot>   "CHEATER!"
12:02:11 <conal> wchogg_: yes.
12:02:17 <RayNbow> > "hai, can i haz stdio?"
12:02:18 <RayNbow> erm
12:02:19 <lambdabot>   "hai, can i haz stdio?"
12:02:21 <RayNbow> > loudly "hai, can i haz stdio?"
12:02:23 <lambdabot>   "HAI, CAN I HAZ STDIO?"
12:02:29 <Badger> > "nope."
12:02:29 <Deewiant> > cycle "NO "
12:02:30 <lambdabot>   "nope."
12:02:31 <lambdabot>   "NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO...
12:02:32 <trofi> @elite for sure
12:02:32 <lambdabot> f0R 5Ur3
12:02:43 <RayNbow> trofi: I didn't cheat ;)
12:02:47 <wchogg_> conal:  Thanks.  That helps actually.
12:03:14 <trofi> RayNbow: so why my expr didn't work? :]
12:03:25 <conal> wchogg_: :)
12:04:08 <RayNbow> trofi: you mean why "loudly = fmap toUpper" didn't work?
12:04:16 <trofi> yes
12:04:31 <int-e> > let loudly' = unwords . iterate (++"!") in loudly' . loudly $ "no"
12:04:32 <lambdabot>   "NO NO! NO!! NO!!! NO!!!! NO!!!!! NO!!!!!! NO!!!!!!! NO!!!!!!!! NO!!!!!!!!!...
12:04:40 <wchogg_> Y'know, I just want to throw out there that without referential transparency I can't imagine trying to do calculations/proofs with code by hand.
12:04:41 <trofi> is it `@let' limitation, or i don't understand smth
12:04:55 <int-e> trofi: it's the dreaded monomorphism restriction
12:05:17 <Badger> Oh no!
12:05:24 <int-e> trofi: what the error is saying is that the compiler doesn't know which Functor instance you wanted and gave up.
12:05:25 <trofi> :t fmap
12:05:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:05:31 <RayNbow> @undefine loudly
12:05:42 <RayNbow> @let loudly = map toUpper
12:05:43 <lambdabot>  Defined.
12:05:50 <Badger> > loudly
12:05:51 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
12:05:51 <lambdabot>        arising from a...
12:05:54 <trofi> so smth like fmap op :: [Char] -- would work?
12:06:00 <int-e> hah!
12:06:17 <trofi> emm [Char] -> [Char]
12:06:34 <Badger> :t map
12:06:35 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:06:45 <Badger> eep
12:11:03 <madara> Is anyone familair with the haskell picture book?
12:11:21 <gwern> http://hpaste.org/11963#a2 <-- finished!
12:11:32 <gwern> now to do something about it being butt-ugly
12:13:04 <Deewiant> @where LYAH -- madara: this one?
12:13:04 <lambdabot> www.learnyouahaskell.com
12:13:26 <madara> Deewiant: nice, thanks.
12:16:00 <ivan_> hi, how do i get control.category ?
12:16:34 <Deewiant> GHC 6.10
12:17:01 <Deewiant> (To be more precise, base-4, but in practice that means GHC 6.10.)
12:17:19 <ivan_> is there any package available for ubuntu (ghc 6.10)
12:17:28 <Deewiant> I don't know
12:17:55 <_pizza_> ivan_: just install the binary, works fine on debian
12:18:13 <ivan_> oki thx i'll try it
12:19:34 <ivan_> :q
12:22:20 <ksf> bbs, you still there?
12:22:26 <pierre-> hello, how can i do something like: data Conn a = Conn { unConn :: ReaderT XmppConnection (Event a) }? ghc says it's type error
12:22:30 <ksf> , let fibs = 0:1:[(\(a:b:_) -> a + b ) n |  n <- List.tails fibs ] in take 20 [(n,d) | (n:d:_) <- List.tails fibs]
12:22:31 <pierre-> *kind error
12:22:35 <lunabot>  luna: Not in scope: `List.tails'
12:22:35 <ksf> wut?
12:22:42 <ksf> grrrr
12:22:46 <ksf> @ let fibs = 0:1:[(\(a:b:_) -> a + b ) n |  n <- List.tails fibs ] in take 20 [(n,d) | (n:d:_) <- List.tails fibs]
12:22:53 <ksf> > let fibs = 0:1:[(\(a:b:_) -> a + b ) n |  n <- List.tails fibs ] in take 20 [(n,d) | (n:d:_) <- List.tails fibs]
12:22:54 <lambdabot>   /tmp/6683428391456933014:70:95: Not in scope: `List.tails'/tmp/668342839145...
12:23:11 <ksf> , let fibs = 0:1:[(\(a:b:_) -> a + b ) n |  n <- tails fibs ] in take 20 [(n,d) | (n:d:_) <- tails fibs]
12:23:14 <lunabot>  [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,8...
12:23:26 <ksf> , let fibs = 0:1:[(\(a:b:_) -> a + b ) n |  n <- tails fibs ] in take 20 [(n%d) | (n:d:_) <- tails fibs]
12:23:28 <lunabot>  luna: Not in scope: `%'
12:23:36 <ksf> well it works.
12:23:47 <ksf> > let fibs = 0:1:[(\(a:b:_) -> a + b ) n |  n <- tails fibs ] in take 20 [(n%d) | (n:d:_) <- tails fibs]
12:23:48 <lambdabot>   [0%1,1%1,1%2,2%3,3%5,5%8,8%13,13%21,21%34,34%55,55%89,89%144,144%233,233%37...
12:24:42 <_pizza_> i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
12:24:43 <bbs> ksf: yes sir
12:24:44 <bbs> whatsup
12:25:16 <ksf> > let fibs = 0:1:[a + b |  (a:b:_) <- tails fibs ] in take 20 [(n%d) | (n:d:_) <- tails fibs]
12:25:17 <lambdabot>   [0%1,1%1,1%2,2%3,3%5,5%8,8%13,13%21,21%34,34%55,55%89,89%144,144%233,233%37...
12:25:21 <durdn> _pizza_ +1 for quote of the week
12:25:24 <ksf> this time legacy-free.
12:25:28 <bbs> ksf: :)
12:25:31 <bbs> *nod*
12:25:33 <bbs> thats what i got now
12:25:34 <digit> anyone use Hugs? (first i heard of it) or is everyone GHC users?
12:25:44 <Botje> @remember _pizza_ i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
12:25:45 <lambdabot> Done.
12:25:54 <Botje> digit: GHC is where all the fun stuff's at
12:26:05 <Botje> and nowadays there's really not much reason to use hugs over ghc
12:26:13 <ksf> with a bit of mangling you should be able to do it in one comprehension.
12:26:44 <ksf> I didn't do it for evil off-by-one mistakes lie ahead.
12:27:11 <digit> botje, i think your humour with the fibonacci sequence comment went over my head.
12:27:20 <bbs> ksf: indeed
12:27:22 <bbs> i don't care
12:27:31 <bbs> i get assignments and i just end up doing them better than he wanted
12:27:36 <RayNbow> > let discover=take; first=(*); few = 3; dozen = 12; fibs = 0:1:zipWith(+)fibs(tail fibs) in discover (first few dozen) fibs  -- _pizza_'s quote Haskellized
12:27:37 <bbs> i just sometimes lose poitns for not doing it to spec
12:27:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:27:39 <bbs> but i don't care
12:27:48 <bbs> i would prefer they be right not -- conforming to a shitty spec
12:27:48 <bbs> :)
12:28:04 <Botje> digit: a running tradition on #haskell is to produce the fibonacci series in the most obscure manner possible
12:28:24 <bbs> :D
12:28:54 <digit> :D...    can you reccognise it's presence? http://chadtymko.com/pod/?p=41
12:28:55 <lambdabot> Title: 5 XW8 3 | 3f Gaudiepod
12:29:17 <digit> gaudiepod.org.uk my site.  shud b safe enough. lol
12:31:34 <benjo> hello everybody, I have a problem, I'm using ghc 6.10, when I make 'ghc -o main Main.hs' this show error'/usr/bin/ld: cannot find -lgmp'
12:32:13 <mdmkolbe> How do I (nicely) get rid of this warning? http://hpaste.org/11972
12:32:42 <Botje> benjo: check if you have libgmp-dev installed
12:33:11 <Saizan> do you need the -dev version?
12:33:46 <mdmkolbe> Saizan: yes, otherwise you only get the shared/dynamic/runtime libs and not the compilition libs
12:34:04 <ksf> mdmkolbe, there ain't no such thing as indirect usage.
12:34:09 <benjo> ok
12:34:11 <Botje> mdmkolbe: uh, shouldn't you call papi_create_eventset with an argument?
12:34:27 <Saizan> benjo: also, you usually want to pass --make, so it links in other packages if you use them
12:34:39 <mdmkolbe> Botje: uh, yeah, what was a typo when I copied
12:34:56 <mdmkolbe> Botje: there fixed http://hpaste.org/11972#a1
12:35:49 <Botje> oh
12:36:14 <mdmkolbe> ksf: If I had manually written the Storable instance I don't think GHC would have complained (that is what I mean by indirectly used). It is used but GHC doesn't see it for some reason
12:37:01 <benjo> Saizan, Botje: thanks!!
12:37:23 <int-e> mdmkolbe: because as far as GHC is concerned, it isn't there ... as far as I know it just takes the Storable dictionary of CInt and coerces it to a new type.
12:37:41 <int-e> mdmkolbe: (hmm. should check the core ...)
12:39:55 <mdmkolbe> int-e: so it isn't used, but it has to be there?  humph, there must be some way to make GHC happy with this code
12:40:37 <ksf> mdmkolbe, you can use it without having the program's eagerness eat it.
12:41:06 <Saizan> mdmkolbe: import papi_create_event :: Ptr CInt -> IO ()?
12:41:52 <mdmkolbe> Saizan: what do you mean by the "?" (i.e. which part are you questioning?)
12:41:56 <Saizan> so you're forced to use EventSet after peek :)
12:42:25 * ksf nods
12:42:46 <Saizan> mdmkolbe: i was suggesting to change EventSet to CInt in the signature of the foreign imported function
12:42:47 <int-e> mdmkolbe: Ok, I was right: http://hpaste.org/11972#a2
12:43:35 <mdmkolbe> Saizan: yeah, I think that works
12:43:53 <ksf> imho, it's even cleaner.
12:44:03 <int-e> Saizan: but then users can fake EventSet values
12:44:05 <ksf> c doesn't know the newtype so it can't return it.
12:44:23 <int-e> ksf: that's what the storable instance is for
12:44:24 <mdmkolbe> int-e: how?
12:44:32 <Saizan> int-e: fake?
12:44:49 <int-e> Saizan: oh. 'imported function' never mind.
12:45:00 <int-e> meh
12:45:24 <mdmkolbe> int-e: if someone fakes one with "peek" I'm not two worried, I really can't stop that
12:45:56 <Saizan> mdmkolbe: you could avoid deriving Storable unless you need it elsewhere
12:46:07 <mdmkolbe> Saizan: I need it elsewhere in the rest of the module
12:46:28 <int-e> Saizan: you're right, omitting the storble instance for EventSet seems best.
12:46:42 <int-e> +a
12:48:43 <mdmkolbe> ok, gtg, thx all
12:50:07 <ksf> @pl (\(a:b:_) -> a + b ) n
12:50:07 <lambdabot> head n + head (tail n)
12:50:27 <ksf> that's just ugly.
12:50:40 <Deewiant> sum (take 2 n)
12:51:36 <ksf> > let fibs = 0:1:[sum $ take 2 n | n <- tails fibs ] in take 20 fibs
12:51:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
12:52:20 <ksf> that's even elegant in a strange way.
12:52:29 <ksf> "sum of the last two" is spelled out.
12:54:12 <Saizan> ksf: yeah, not enough obfuscated to compete :)
12:54:41 <Deewiant> > take 20 $ fix $ (0:) . scanl (+) 1
12:54:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
12:55:55 <ksf> well i still din't see anyone doing a monoid one.
12:56:17 <ksf> or doing the oleg, fwiw.
12:56:22 <dolio> > fix (\l -> 0 : (zipWith (+) l (1 : l))
12:56:23 <lambdabot>   <no location info>: parse error on input `;'
12:56:37 <dolio> > fix (\l -> 0 : (zipWith (+) l (1 : l)))
12:56:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:57:04 <Saizan> > fix $ (0:) . (1:) . (sum . take 2) <=< tails
12:57:05 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
12:57:05 <lambdabot>        Expect...
12:57:16 <Saizan> > fix $ (0:) . (1:) . ((sum . take 2) <=< tails)
12:57:17 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
12:57:18 <lambdabot>        Expect...
12:58:02 <trofi> :t (<=<)
12:58:03 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:00:17 <dolio> > fix $ (0:) . (1:) . fmap (sum . take 2) . tails
13:00:18 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:00:21 <int-e> @users
13:00:21 <lambdabot> Maximum users seen in #haskell: 559, currently: 537 (96.1%), active: 18 (3.4%)
13:00:33 <Botje> >>= is "bind", so <=< must be "fish"
13:01:01 <Saizan> > fix $ (0:) . (1:) . (return . sum . take 2 <=< tails)
13:01:02 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:02:30 <dolio> @type \f g = fmap f . g
13:02:31 <lambdabot> parse error on input `='
13:02:36 <dolio> @type \f g -> fmap f . g
13:02:37 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
13:02:46 <Saizan> yeah
13:02:55 <dolio> @pl \f g -> fmap f . g
13:02:55 <lambdabot> (.) . fmap
13:03:04 <Cale> conal: Is there a good reason that Behavior is not a monad?
13:03:13 <dolio> fmap `fmap` fmap :)
13:03:22 <Deewiant> fmap fmap fmap
13:03:42 <dolio> @type fmap fmap fmap
13:03:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
13:03:48 <mauke> :t join (flip fmap) fmap
13:03:49 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
13:03:49 <lambdabot>     Probable cause: `join' is applied to too few arguments
13:05:26 <Cale> conal: Shouldn't a Behaviour of Behaviours join essentially by taking the diagonal?
13:07:19 <unenough> Cale, i got the book, it's good and easy to read so far (page 11). funny thing is it's the only copy here and it was ordered by someone from the education faculty....i wonder why
13:07:41 <Cale> :)
13:08:19 <Cale> Oh, apparently the docs claim BehaviorG is a monad as I expect, but there's no actual instance defined...
13:08:24 <mmorrow> @let let onlineRead cs = let go cs = case reads cs of {[(x,cs)] -> x : go2 cs ; _ -> error "no parse"}; go2 cs = case lex cs of {[("]",_)]  -> []; [(",",cs)] -> go cs; _ -> error "no ',' or ']'"}; in case lex cs of {[("[",cs)] -> go cs ; _ -> []}
13:08:25 <lambdabot>   Parse error
13:08:30 <mmorrow> @let onlineRead cs = let go cs = case reads cs of {[(x,cs)] -> x : go2 cs ; _ -> error "no parse"}; go2 cs = case lex cs of {[("]",_)]  -> []; [(",",cs)] -> go cs; _ -> error "no ',' or ']'"}; in case lex cs of {[("[",cs)] -> go cs ; _ -> []}
13:08:32 <lambdabot>  Defined.
13:08:39 <mmorrow> @type onlineRead
13:08:40 <lambdabot> forall a. (Read a) => String -> [a]
13:08:54 <mmorrow> > read (show [0..]) :: [Int]
13:09:03 <lambdabot>   mueval: Prelude.read: no parse
13:09:05 <mmorrow> > onlineRead (show [0..]) :: [Int]
13:09:09 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:10:02 <Deewiant> > take 100 $ show [0..]
13:10:04 <lambdabot>   "[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
13:10:22 <Deewiant> oh, it expects the final ]?
13:10:33 <mmorrow> yeah
13:10:55 <Cale> conal: Oh, it looks like you forgot to derive Monad for Behavior
13:11:12 <Cale> (BehaviorG)
13:11:14 <galdor> hi; i've a small problem: I'd want to name a data field 'dateFmt', but I can't since there's a Locale.dateFmt
13:11:38 <ksf> sure you can.
13:11:49 <ksf> import qualified Locale as L
13:11:59 <ksf> or import Locale hiding (dateFmt)
13:12:19 <galdor> ok, but shouldn't be data field in another namespace
13:12:29 <galdor> it's a bit surprizing
13:12:34 <Deewiant> it's just a function
13:12:36 <ksf> it's in the "namespace" of your module.
13:12:37 <Deewiant> like any other
13:13:00 <galdor> oh I see
13:13:12 <galdor> there are not labels, since I have to be able to call them as accessors
13:13:19 <galdor> so there are just plain functions
13:13:22 <Cale> conal: oh... no, that doesn't work, hmm
13:13:38 <galdor> thank you guys, I learnt something new today
13:13:45 <ksf> @faq
13:13:46 <lambdabot> The answer is: Yes! Haskell can do that.
13:14:14 <Rapiere> who did approve this message ?
13:14:45 <ksf> Rapiere, do you have a counterexample?
13:15:04 <Rapiere> no, it was just a joke about american elections
13:15:45 <Rapiere> I'm really interested in Haskell, too bad there isn't yet a killer app like some other languages have.
13:15:55 <Botje> darcs?
13:15:57 <ksf> ghc. xmonad.
13:15:58 <unenough> fun
13:16:08 <Deewiant> a compiler for the language doesn't count as a killer app :-P
13:16:23 <unenough> fun is the killer app
13:16:31 <Rapiere> a bit disappointed darcs isn't kept for ghc distributed sources
13:16:42 <dons> Rapiere: like what other languages have?
13:16:50 <dons> what's python's killer app?
13:16:56 <opqdonut> or c
13:16:59 <dons> killer apps are for niche languages, not general purpose ones.
13:17:03 <unenough> pypy :)
13:17:11 <Deewiant> C's killer app is every app
13:17:17 <Rapiere> dons: you're right that the purpose of a language is to solve problems
13:17:20 <Deewiant> for python, maybe django
13:17:40 <ksf> portage. but i bet some portage developer is cursing pything right now in this instant.
13:17:52 <idnar> portage is a pretty sad excuse for a python app
13:17:56 <dons> then cabal-install is haskell's ;)
13:17:57 <ksf> omg my spealing sucks
13:18:01 <Rapiere> when you want to "sell" a language to other people, they want to have examples
13:18:36 <ksf> so why do people use c and c++ when there's windoze?
13:18:48 <sjanssen> Rapiere: ghc, darcs, xmonad are all decent examples
13:18:54 <ksf> ...should be enough of a warning.
13:18:56 <bbs> hey all
13:18:57 <bbs> gr2 = map (uncurry (/)) . iterate (\(x,y)->(y,y+x)) $ (0,1)
13:19:03 <bbs> that does the opposite of what i want
13:19:08 <bbs> well not the opposte but does the reciprocal
13:19:09 <vixey> oppposite??
13:19:12 <vixey> oh
13:19:18 <vixey> @let reciporical = (1/)
13:19:20 <lambdabot>  Defined.
13:19:23 <Deewiant> bbs: uncurry $ flip (/)
13:19:29 <Botje> :t recip -- :)
13:19:30 <vixey> > map (reciporical . uncurry (/)) . iterate (\(x,y)->(y,y+x)) $ (0,1)
13:19:30 <lambdabot> forall a. (Fractional a) => a -> a
13:19:31 <lambdabot>   [Infinity,1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619...
13:19:37 <vixey> > map ((1/) . uncurry (/)) . iterate (\(x,y)->(y,y+x)) $ (0,1)
13:19:38 <lambdabot>   [Infinity,1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619...
13:19:46 <vixey> > map (uncurry (flip (/))) . iterate (\(x,y)->(y,y+x)) $ (0,1)
13:19:48 <lambdabot>   [Infinity,1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619...
13:22:42 <vixey> > map (uncurry (/)) . iterate (\(y,x)->(y+x,y)) $ (1,0)
13:22:44 <lambdabot>   [Infinity,1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619...
13:22:54 <bbs> HAHAHA
13:22:55 <bbs> yea
13:22:57 <bbs> thats what i did
13:23:00 <bbs> screw the flip thing
13:23:31 <idnar> @pl \(y,x)->(y+x,y)
13:23:32 <lambdabot> uncurry (flip =<< ((,) .) . (+))
13:23:55 <idnar> yikes
13:24:06 <idnar> uhm, isn't that just iterate (\(y,x)->(y+x / y) $ (1,0) ?
13:24:15 <idnar> > iterate (\(y,x)->(y+x / y) $ (1,0)
13:24:17 <lambdabot>   <no location info>: parse error on input `;'
13:24:21 <Deewiant> yes, it is
13:24:25 <idnar> er
13:24:30 <idnar> > iterate (\(y,x)->(y+x / y)) $ (1,0)
13:24:32 <lambdabot>       Occurs check: cannot construct the infinite type: t = (t, t)
13:24:32 <lambdabot>        Exp...
13:24:44 <vixey> bbs, the thing is like .. they're all provably equal
13:24:59 <Deewiant> or wait, it needs both of the previous ones doesn't it
13:24:59 <idnar> eh
13:25:25 <idnar> @type iterate (\(y,x)->(y+x,y)) $ (1,0)
13:25:27 <lambdabot> forall t. (Num t) => [(t, t)]
13:26:03 <idnar> oh
13:26:05 <vixey> > map (+1) . map (uncurry (/)) . iterate (\(x,y)->(y,y+x)) $ (0,1)
13:26:06 <lambdabot>   [1.0,2.0,1.5,1.6666666666666665,1.6,1.625,1.6153846153846154,1.619047619047...
13:28:30 <bbs> vixey: you are right :)
13:41:13 <int-e> > iterate (\x -> x * (x + 2) / (1 + x^2)) 1 :: [Double]
13:41:15 <lambdabot>   [1.0,1.5,1.6153846153846154,1.618032786885246,1.6180339887496482,1.61803398...
13:46:15 --- mode: irc.freenode.net set +o ChanServ
13:46:46 <gwern> @pl generateQuestions x = zip (cycle [flatten x]) (allBlankifieds (getAnswer x))
13:46:46 <lambdabot> generateQuestions = ap (zip . cycle . return . flatten) (allBlankifieds . getAnswer)
13:47:19 <vixey> :t flatten
13:47:19 <gwern> hm.  - no
13:47:20 <lambdabot> forall a. Tree a -> [a]
13:47:30 <gwern> vixey: that's not my flatten
13:47:33 <vixey> oh
13:47:36 <gwern> flatten = concat . map (\y -> case y of Answer x -> x; Question x -> x)
13:47:39 <vixey> I like your version better than the pl one
13:47:42 <vixey> hey
13:47:56 <vixey> why don't you write  extract (Answer x) = x ; extract (Question x) = x
13:48:06 <gwern> turns [Question "foo", Answer "bar", "Question quux"] into "foobarquux"
13:48:07 <vixey> then you can do flatten = (>>= extract)
13:48:29 <gwern> why would I do that?
13:48:36 <vixey> ox
13:48:42 <vixey> then you can do flatten = concatMap extract
13:48:58 <vixey> I don't know I have something against lambda and case recently
13:49:20 <seliopou> yeah those suck
13:50:15 <gwern> hm, somewhere in my refactorings I broke it
13:50:50 * gwern suspects vixey's suggestion
13:52:28 <gwern> vixey: how would you rewrite 'getAnswer (x:y) = case x of Answer a -> a; _ -> getAnswer y'?
13:52:38 <gwern> it's *almost* concatMap extract
13:53:01 <vixey> oh you nkow what it is like
13:53:10 <gwern> ('getAnswer :: [Stuff] -> String')
13:53:11 <vixey> :t head . catMaybes
13:53:12 <lambdabot> forall a. [Maybe a] -> a
13:53:16 <vixey> so what about like
13:53:17 <gwern> catMaybes?
13:53:19 <vixey> catAnsweres
13:53:23 <gwern> @src catMaybes
13:53:23 <lambdabot> catMaybes ls = [x | Just x <- ls]
13:53:25 <vixey> and catQuestions
13:53:33 <vixey> then getAnswer = head . catAnsweres
13:53:37 <vixey> soryr I can't spell
13:53:43 <vixey> Answers*
13:54:01 <gwern> hm. 'getAnswer = [x | Answer x <- xs]' maybe
13:54:21 <vixey> true, it gives you every answer though
13:54:34 <gwern> that's fine, the user promises to only supply one answer
13:54:51 * gwern ponders the error for 'getAnswer xs = [x | Answer x <- xs]'
13:54:58 <vixey> and if thy don't.. :)) putsSegFault "BUS ERROR"
13:55:10 <gwern> ah, 'concat $'
13:55:21 <gwern> 'getAnswer :: [Stuff] -> String
13:55:22 <gwern> getAnswer xs = concat $ [x | Answer x <- xs]'
13:55:35 <gwern> seems to run correctly too
13:55:45 <vixey> hm
13:55:50 <vixey> :t msum
13:55:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
13:56:04 <vixey> :t mconcat
13:56:05 <lambdabot> forall a. (Monoid a) => [a] -> a
13:56:07 <vixey> I'm sure there is one..
13:56:14 <vixey> I don't know which it is though
13:58:26 <Cale> anyone else who has been playing around with Conal's new 3D stuff?
13:58:42 <byorgey> vixey: you're sure there is one what?
13:58:48 * roconnor doesn't have GHC 6.10
13:59:07 <byorgey> Cale: I wish I could!  kind of a bad time though, I'm going to have to wait until December =(
13:59:11 <vixey> > Just "foo" `mappend` Just "bar"
13:59:12 <lambdabot>   Just "foobar"
13:59:23 <vixey> > mconcat [Just "foo",Nothing,Just "bar"]
13:59:24 <lambdabot>   Just "foobar"
13:59:38 <vixey> gwern, I thought of a better way
13:59:42 <gwern> zomg
13:59:47 <vixey> if you have data Stuff = Question String | Answer String
13:59:50 <vixey> then you can do
13:59:50 <roconnor> > Just "foo" `mplus` Just "bar"
13:59:52 <gwern> yes
13:59:52 <lambdabot>   Just "foo"
14:00:01 <vixey> foldStuff question answer (Question s) = question s
14:00:08 <vixey> foldStuff question answer (Answer s) = answer s
14:00:11 <vixey> now,
14:00:23 <vixey> getQuestion = concat . foldStuff id (const [])
14:00:30 <vixey> or
14:00:36 <vixey> questions = foldStuff id (const [])
14:00:40 <vixey> getQuestion = concat . questions
14:00:42 <gwern> er. I think I like the list comprehension better
14:00:52 * bbs sighs
14:01:18 * byorgey likes vixey's way
14:01:20 <Cale> byorgey: why December?
14:01:22 <byorgey> nice and categorical =)
14:01:38 <byorgey> Cale: well, more to the point, the middle of December, since that's after finals =)
14:01:40 <ivanm> Cale: he has to read through RWH first?
14:01:41 <ivanm> ;-)
14:01:43 <Cale> ah
14:02:47 <byorgey> actually, I have a great idea for a game, and hopefully I can wire up reactive + hipmunk
14:02:55 <byorgey> so, that's not the 3d stuff I guess
14:03:02 <byorgey> but I'd like to play with that too =)
14:03:08 <vixey> you can use 3D graphics for a 2D game
14:03:09 <gwern> @pl getAnswer xs = concat [x | Answer x <- xs]
14:03:09 <lambdabot> getAnswer = ((x | Answer x) <-)
14:03:15 <vixey> lots of very popular one do that
14:03:27 <byorgey> vixey: actually, that's true.
14:03:28 <gwern> does - does that actually work?
14:03:36 <gwern> no
14:03:37 <roconnor> I suggest makig a game where you go around rolling a ball and things stick to it.
14:03:37 <vixey> no gwern
14:03:38 <byorgey> lol!
14:03:42 <vixey> I did the @pl for you :p
14:04:08 <byorgey> roconnor: genius!  we'll call it... haskamari idiocy
14:04:15 <roconnor> :D
14:04:24 <Botje> i'd buy that!
14:04:36 <Botje> .. except lambdas dont roll too well, do they?
14:04:44 <vixey> they tumble pretty well
14:04:52 <vixey> requires a staircase
14:05:05 <trofi> :]
14:05:08 <Botje> won't we get the PETL on our case?
14:05:26 <gwern> @pl tabify (q,a) = q ++ "\t" ++ a
14:05:26 <lambdabot> tabify = uncurry ((. ('\t' :)) . (++))
14:05:45 <gwern> (oh give me a break)
14:06:08 <idnar> haha
14:06:41 <Botje> @pl tabify (q,a) = concat [q,"\t",a]
14:06:42 <lambdabot> tabify = uncurry ((join .) . (. (("\t" :) . return)) . (:))
14:06:46 <Botje> that's better.
14:06:56 <idnar> haha
14:07:01 <vixey> hey does anyone know some compression algorithm more mind bending than arithemetic compression?
14:07:08 <mdmkolbe> Where do I note a README file in the *.cabal file?
14:07:29 <ivanm> mdmkolbe: otherfiles?
14:07:33 <Cale> very strange... for some scalings of this thing, it doesn't texture correctly.
14:07:37 <gwern> data-files:?
14:07:56 <Cale> It seems like those should be independent of one another.
14:07:59 <ksf> vixey, any lossy one?
14:08:03 <Botje> vixey: wavelets are pretty neat
14:08:07 <byorgey> mdmkolbe: extra-source-files
14:08:18 <vixey> I don't really mind if it's lossy or not
14:08:23 <Botje> the BWT one is cool too
14:08:52 <geezusfreeek> byorgey: if you are planning to make a game soon perhaps you would consider entering in uDevGames. it starts on Dec 2. you must have access to a Mac to test it on, but besides that you can just use cross-platform libraries
14:08:54 <mdmkolbe> byorgey: *ding* *ding* *ding* and we have a winner  ... ahem ... thx. that seems to be the right one
14:08:57 <vixey> ahh BWT I have seen some proofs of
14:09:08 <idnar> > let tabify = concat . intersperse "\t" in tabify ["foo", "bar"]
14:09:09 <lambdabot>   "foo\tbar"
14:09:12 <geezusfreeek> i am 99% sure i will enter
14:09:23 <geezusfreeek> would be the only haskell entry unless somebody else here does too
14:09:34 <geezusfreeek> i'm not planning to use reactive though
14:09:42 * gwern ponders the latest version: http://hpaste.org/11963#a3
14:09:43 <vixey> why not
14:09:59 <byorgey> geezusfreeek: nah, I am not planning on being that serious about it
14:10:01 <geezusfreeek> not confident in it yet
14:10:01 <dons> don't do too many experimental things in one go.
14:10:02 <vixey> gwern, extract = foldStuff id id
14:10:04 <vixey> :p
14:10:05 <byorgey> just something to fiddle with
14:10:08 <yitz> vixey: general compression?
14:10:16 <yitz> or image or audio or what have you
14:10:26 <byorgey> mdmkolbe: great =)
14:10:27 <vixey> yitz, just looking for some fun algorithm to think about
14:10:34 <gwern> I almost feel disapointed that I can't have haskell derive the two 'extract' definitions
14:10:42 <yitz> vixey: i think block sorting is cool
14:10:45 <hackage> Uploaded to hackage: wavesurfer 0.0.2
14:10:45 <hackage> Uploaded to hackage: delimited-text 0.0.2
14:10:45 <hackage> Uploaded to hackage: yjtools 0.9
14:10:45 <hackage> Uploaded to hackage: LslPlus 0.1.0
14:10:49 <gwern> is it that difficult to autowrite an unwrapper?
14:11:09 <byorgey> gwern: I think there are various generics library that could derive them.
14:11:11 <vixey> gwern, it comes out from the fold automatically (foldStuff id id) and that can be derived (mmorrow did this in TH)
14:11:14 <byorgey> *libraries
14:11:16 <gwern> vixey: oh, you want to rewrite stuff? you'll like 'parseIntoStuff'
14:11:43 <vixey> yeah I  don't like that parser.. :)
14:12:23 <byorgey> gwern: at least it has a good comment.
14:12:40 <Botje> gwern: is that bool really needed in parseintostuff?
14:12:49 <Botje> oh wait
14:12:57 <Botje> i can see where it's handy
14:13:04 <byorgey> gwern: ok, I don't understand what parseIntoStuff is doing.
14:13:09 <gwern> Botje: the bool is the state :)
14:13:14 <Botje> still ..
14:13:35 <byorgey> oh, wait, ok
14:13:42 <Botje> it only becomes true if you encounter ^:x:^:ds
14:13:50 <gwern> byorgey: the problem is, I have "david hume died ^1776^". split turns that into ["david hume died ", "^", "1776", "^"]
14:13:50 <Botje> at which point you call it with true, x:ds
14:14:11 <ivanm> is it just me, or is ghc-pkg in 6.10 less useful than 6.8? when doing "ghc-pkg check", it comes up with libs that have missing dependencies, but doesn't actually say what those missing dependencies are :s
14:14:13 <gwern> byorgey: the task is to turn *that* into [Question "david hume ", Answer "1776"]
14:14:22 <dons> ivanm: should be more useful
14:14:26 <gwern> byorgey: and also allow the answer, delimited by ^^s, to appear anywhere
14:14:58 <gwern> byorgey: after much thought about how the heck to do this, 'parseIntoStuff' was my grand solution. :) I am half-way proud of it
14:15:10 <byorgey> gwern: so  "there are ^9^ players on a baseball team" should be turned into what?
14:15:35 <Botje> parseIntoStuff :: [String] -> [Stuff]
14:15:35 <gwern> byorgey: that would become [Question "there are ", Answer "9", Question " players on a baseball team"]
14:15:36 <Botje> parseIntoStuff (a:b:c:ds) | a == "^" && c == "^" = Answer b : parseIntoStuff ds
14:15:36 <Botje> | otherwise = Question a : parseIntoStuff (b:c:ds)
14:15:50 <Botje> there's really no need for the bool
14:16:02 <gwern> :( but that was my favorite part
14:16:03 <Botje> oh, and you need another case for [x], but that's about it
14:16:13 * Botje hugs gwern 
14:16:24 <Botje> we must all make sacrifices in the Great Refactoring of 2008
14:16:45 <gwern> edit hard for your country!
14:17:07 <vixey> I've read it a couple times but I still don't really get how data types and folds come up in category theory
14:17:13 <byorgey> gwern: so there might be multiple Questions?
14:17:33 <ivanm> dons: hmmm....
14:17:52 <gwern> byorgey: sure. I don't want to force the user to structure every question like 'So and so was born in FOO'; 'So and so died in FOO'
14:17:54 <gwern> that'd be boring
14:18:14 <byorgey> right, and how about Answers?  there can only be one?
14:18:31 <gwern> byorgey: well, the code as it stands almost works for multiple answers
14:18:37 <byorgey> ok.
14:18:40 <gwern> I just can't figure out how to add spaces in between them
14:18:51 <gwern> ie. gwern@craft:28236~>echo "Anaximander died in ^546^ BCE and lived in ^500^." | runhaskell memo3.hs                    [ 4:59PM]
14:18:54 <gwern> Anaximander died in 546 BCE and lived in 500.	54650_
14:19:15 <gwern> the format should be more like '<tab>546; 50_'
14:19:20 <gwern> but you see that it's run together
14:20:13 <byorgey> gwern: oh, so getAnswer should put spaces in between?
14:20:32 <byorgey> just use intercalate instead of concat
14:20:47 <byorgey> > intercalate " " ["foo", "bar"]
14:20:49 <lambdabot>   "foo bar"
14:21:17 <byorgey> or semicolons, or whatever
14:21:20 <gwern> byorgey: well, it doesn't seem to be that simple
14:21:31 <gwern> that works for *some* of the output
14:21:41 <gwern> ie, that does indeed give me 'Anaximander died in 546 BCE and lived in 500.	___ __0
14:21:47 <lispy> > [1,2,3] `intercalate` [[1],[2]]
14:21:48 <lambdabot>   [1,1,2,3,2]
14:21:51 <gwern> but it also outputs 'Anaximander died in 546 BCE and lived in 500.	____50_
14:21:58 * gwern already tried intercalate
14:25:48 <byorgey> gwern: ok, so getAnswer should actually be getAnswers, without the concat; then you map allBlankifieds over the list and intercalate " " later
14:26:06 <vixey> @src unwords
14:26:06 <lambdabot> unwords [] = ""
14:26:06 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
14:26:12 <vixey> that's stupid ..
14:26:18 <vixey> unwords = intercalate " "
14:26:52 <yitz> @src intercalate
14:26:52 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
14:27:18 <yitz> @src intersperse
14:27:18 <lambdabot> intersperse _   []     = []
14:27:18 <lambdabot> intersperse _   [x]    = [x]
14:27:18 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
14:27:43 <int-e> intersperse should be lazier :/
14:28:10 <vixey> int-e, would it be evil if the compiler knew that and did the optimization by itsself?
14:28:19 <Taejo> int-e: how so?
14:28:31 <byorgey> gwern: oh, ok, I see now.
14:28:38 <int-e> > fix ((1:) . intersperse 1 . map succ)
14:28:40 <lambdabot>   [1* Exception: stack overflow
14:28:42 <Taejo> vixey: yes. changing semantics is evil (although we seem to accept it in short-cut fusion)
14:28:43 <gwern> byorgey: but that messes up the zip/cycle technique
14:29:01 <vixey> Taejo, is it changing semantics though?
14:29:05 <byorgey> the thing is, you want allBlankifieds to give all *combinations* of blanks, BUT you also want to remember where the spaces go
14:29:19 <vixey> I guess it is yeah
14:29:19 <gwern> where I turn the Question/Answer/Question into a String, cycle it, and zip it with the list of blankified questions
14:29:23 <byorgey> I think the solution is to change the type of allBlankifieds to  [String] -> [String]
14:29:27 <byorgey> or something like that
14:29:29 <Taejo> vixey: changing strictness is changing semantics
14:29:34 <ivanm> anyone know which version of quickcheck is required by latest darcs?
14:29:40 <byorgey> so it actually knows where the boundaries are, and then inserts spaces when it's done blankifying
14:29:41 <int-e> > let intersperse' _ [] = []; intersperse' c (x:xs) = x : (xs >>= (c:) . (:[])) in fix ((1:) . intersperse' 1 . map succ)
14:29:43 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,...
14:30:07 <ziman> @oeis [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5]
14:30:07 <lambdabot>  Sequence not found.
14:30:13 <gwern> ivanm: we're up to 2.1 aren't we?
14:30:24 <int-e> Taejo: intersperse (x:_|_) should be x:_|_, not _|_.
14:30:55 <int-e> Taejo: err, intersperse t (x:_|_)
14:31:00 <ivanm> gwern: well, quickcheck-2.1 is available, but I can't find on darcs.net which versions are supported
14:31:18 <ivanm> becuase for some reason, here on gentoo we've been using quickcheck-1.* :s
14:31:24 <Taejo> int-e: yeah, you know that, but the compiler doesn't
14:31:26 <vixey> > let intersperse' _ [] = []; intersperse' c (x:xs) = x : case xs of [] -> [] ; ys -> c : intersperse' c ys in fix ((1:) . intersperse' 1 . map succ)
14:31:27 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,...
14:31:49 <int-e> Taejo: I'm not suggesting that the compiler should do that.
14:32:06 <vixey> I'm wondering if it would be evil if the compiler did that
14:32:10 <ivanm> now that I look at it, it doesn't mention _any_ dependencies (except curl and libwww)
14:32:50 <Taejo> int-e: sorry, got confused between you and vixey
14:33:03 <Taejo> vixey: yes, I'm saying that would be evil
14:34:14 <lispy> ivanm: where are you looking to see those deps?
14:34:22 <lispy> ivanm: it could be that we need to update that place
14:34:37 <ivanm> lispy: I'm _trying_ to look here: http://darcs.net/manual/node3.html#SECTION00310000000000000000
14:34:38 <lambdabot> Title: Building darcs
14:35:09 <lispy> ivanm: oh, I fear that's out of date, I'll make a bug report now.  Thanks
14:35:14 <ivanm> no worries ;-)
14:35:24 <ivanm> also, does darcs-2 really still build with ghc-6.4? :o
14:35:31 <vixey> oh I see why now
14:35:47 <gwern> surely we broke the 6.4 build by now...
14:35:57 <gwern> ivanm: it built with 6.4 not a few months ago
14:36:33 <ivanm> gwern: *nod*
14:37:27 <lispy> ivanm: nope
14:37:59 <lispy> ivanm: http://bugs.darcs.net/issue1225
14:38:00 <lambdabot> Title: Issue 1225: Prerequisites listed in the manual need to be updated - Darcs bug tr ...
14:38:44 <ivanm> thanks lispy
14:42:06 <Taggnostr> when I use cycle does it store all the values in memory or does it just yields a single value at time (like python generators)?
14:42:35 <mauke> define "all"
14:42:56 <ivanm> mauke: every possible one? ;_
14:43:11 <ivanm> Taggnostr: ghc uses an optimization to turn a cycle call into a circular linked list IIRC
14:43:22 <Botje> Taggnostr: every element is only evaluated (and stored) once
14:43:40 <ivanm> @src cycle
14:43:41 <lambdabot> cycle [] = undefined
14:43:41 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:43:48 <byorgey> Taggnostr: however, if the argument to cycle is some expression which evaluates to a list, that list will only be evaluated as it is needed.
14:44:20 <Taggnostr> ok
14:44:25 <byorgey> so calling 'cycle (some expression that evaluates to a really big list)' is perfectly fine
14:44:38 <byorgey> except for the fact that the previous elements cannot be garbage-collected.
14:45:04 <byorgey> so eventually, all the elements are indeed stored in memory.
14:45:59 <byorgey> but if you wanted something that can generate repeated values but recompute them every time so the whole list isn't stored in memory, that should be easy to hack up too =)
14:46:23 <gwern> @quote planet
14:46:24 <lambdabot> MyCatVerbs says: [talking about #haskell] seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychic MegaHelpFulness.
14:46:51 <gwern> @quote planet
14:46:52 <lambdabot> MyCatVerbs says: [talking about #haskell] seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychic MegaHelpFulness.
14:48:01 <pfo> are there ghc 6.10 debs for use on an ubuntu system somewhere?
14:48:36 <pfo> universe/multiverse is lagging behind -  6.8.2 is the most recent version available :/
14:49:17 <Saizan> there's a generic linux binary on www.haskell.org/ghc
14:49:24 <gwern> pfo: I wish. you're far from the first to ask, and I still haven't seen anyone answer with some debs
14:50:23 <pfo> ubuntu is lacking something like dons is doing for arch linux :/
14:51:08 <pfo> point is: i have half of my haskell stuff installed via apt-get, the other half via cabal-install - reinstalling everything to work with ghc 6.10 is pita :/
14:52:50 <dons> Cale: you should play with the gnuplot bindings
14:52:52 <dons> they're fun.
14:53:45 <byorgey> there are gnuplot bindings?
14:53:48 <pfo> dons: are you the one responsible for packaging hackage stuff for arch?
14:53:52 <dons> pfo: yes.
14:53:53 <dons> byorgey: yes.
14:53:55 <byorgey> sweet
14:54:02 <dons> byorgey: e.g. > plotFunc [1..10] cos
14:54:02 <ksf> gnuplot has a c interface?
14:54:10 <ksf> always thought is was script-only
14:54:10 <dons> draws a window with a graph of cos applied to the list
14:54:15 <byorgey> awesome!
14:54:16 <pfo> dons: you are not planing switching to ubuntu/debian :) ?
14:54:25 <dons> pfo: i am not.
14:54:35 <byorgey> dons: and can you use the bindings to export to eps and stuff like that?
14:54:40 <dons> yeup
14:54:44 <dons> i did this, http://haskell.org/haskellwiki/Hackage_statistics
14:54:45 <dons> that way.
14:54:46 <lambdabot> Title: Hackage statistics - HaskellWiki
14:54:48 <byorgey> eeeeexcellent
14:54:57 <dons> parses the apache logs, asks gnuplot to print the results
14:57:08 <arjanb> that graph might look better with a moving average
14:57:59 <dons> arjanb: yeah. like the  darcs-graph ones.
14:58:01 <geezusfreeek> it certainly would
14:58:05 <dons> http://www.cse.unsw.edu.au/~dons/images/commits/community/darcs-unstable-commits.png
14:58:08 <lambdabot> http://tinyurl.com/3by7lv
14:58:09 <dons> for example.
14:58:15 <dons> just need to steal code from one project to another.
14:58:28 <andy_____> hi everyone
14:58:32 * gwern calls it a day with this mnemosyne script. sheesh that took far too long
14:58:41 <andy_____> does ghci support syntax coloring?
14:59:01 <dons> andy_____: yeah, but not widely used.
14:59:06 <dons> you can use hscolour
14:59:20 <andy_____> thanks dons, I'll google it
14:59:45 <lispy> dons: what do you do, write a ghci macro to apply hscolor to things before they print?
14:59:54 <dons> yup.
14:59:58 <lispy> interenting
15:00:09 <dons> http://haskell.org/haskellwiki/GHCi_in_colour
15:00:11 <lambdabot> Title: GHCi in colour - HaskellWiki
15:00:37 <gwern> dons: does that work? last time I tried, it didn't iirc
15:00:52 <dons> well, above was the last time i tried it. it did, kinda.
15:01:02 <dons> should be a proper flag to ghci though, i guess
15:02:16 <Saizan> how would you find packages that depend on hscurses on hackage? or, is there some nice example/guide on using it?
15:03:40 <gwern> Saizan: it's been suggested before, but no one's done it
15:03:57 <gwern> I think dcoutts_ suggested a recursive page downloader which used tagsoup to construct a network
15:05:06 <Saizan> heh
15:06:41 <gwern> dons: yeah, the '   ghci 2>&1 | HsColour -tty' command on that page looks pretty funky
15:08:53 <gwern> Saizan: btw, according to Messrs. find and grep, in my personal archives, there are 3 users of hscurses - hetris, mage, and lambdahack
15:09:30 * lispy quotes Alaskan Senator Ted Stevens on ref. tranpansparency, "It's not a big truck that you dump stuff on.  It's a series of tubes!"
15:09:48 <dolio> Exactly.
15:09:55 <andy_____> eixt
15:09:56 <andy_____> exit
15:10:22 <ivanm> dons: does that HsColour trick work with 6.10?
15:10:45 <hackage> Uploaded to hackage: hsndfile 0.3.3
15:12:47 <jsn> lispy: if only that were true
15:13:16 <jsn> it would be so much simpler
15:13:48 <wjt> Hmm. If I use RecordPuns and -Wall I get a shadowing warning whenever I use a record pun. :(
15:14:39 <roconnor> \join texmacs
15:14:47 <roconnor> oops
15:16:00 <ksf> dons, "small" delay?
15:16:56 <ksf> ah, gotta press space to see anything.
15:17:35 <vixey> what's a decent text that covers theory of datatypes
15:17:36 <vixey> ?
15:18:45 <wjt> @pl \(x,y) -> (min x y, max x y)
15:18:45 <lambdabot> uncurry (ap (ap . ((,) .) . min) max)
15:18:52 <geezusfreeek> ew
15:18:54 <wjt> lambdabot: thanks :)
15:19:01 <mdmkolbe> When I upload a cabal package to hackage, will the haddock documentation be automatically generated or do I have to build that before hand in the sdist?
15:19:01 <wjt> @ty (***)
15:19:03 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:19:17 <wjt> there must be an arrowy way to say this
15:19:42 <geezusfreeek> @pl \f g (x,y) -> (f x y, g x y)
15:19:43 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . liftM2 (liftM2 (,))
15:19:48 <geezusfreeek> not that way
15:19:56 <wjt> well no :)
15:20:27 <geezusfreeek> @pl \f (x, y) -> (f x, f y)
15:20:28 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
15:20:37 <geezusfreeek> i guess pl is not aware of arrows
15:20:43 <wjt> @pl \f g x -> (f x, g x)
15:20:43 <lambdabot> liftM2 (,)
15:21:15 <lispy> I love that lambdabot teaches us to think in terms of Reader ((->) r)
15:21:29 <lispy> :t liftM2 (,)
15:21:30 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
15:21:33 <dons> we didnt' do it much before lamdabot's daily brain washing.
15:22:39 * lispy wonders what else we're missing out on
15:22:56 <geezusfreeek> it has almost become commonplace for me... which probably would scare newbies from my code
15:23:16 <ziman> :t (uncurry min *** uncurry max) . join (,)
15:23:18 <lambdabot> forall a. (Ord a) => (a, a) -> (a, a)
15:23:44 <lispy> I rather find the discussion on how to balance accessibility with elegance/performance/maintainability to be interesting
15:24:07 * mdmkolbe celebrates releasing his first hackage package
15:24:12 <geezusfreeek> me too, although i tend to lean away from accessibility because i'm an idealist
15:24:18 <lispy> You need to be able to leverage the language and it's potential, at the same time beginners need to be able to understand it to some degree
15:24:23 <wjt> i'm about to write (uncurry min *** uncurry max) . (f &&& g)
15:24:30 <lispy> mdmkolbe: cheers!
15:24:43 <geezusfreeek> wjt: i actually find that quite beautiful
15:24:48 <wjt> but i think i may have lost some clarity in the blind lust of combinators
15:24:53 * shapr boings
15:24:57 <shapr> @seen cale
15:24:57 <lambdabot> cale is in #haskell, #haskell-overflow and #ghc. I last heard cale speak 1h 17m ago.
15:25:00 <shapr> hmm
15:25:09 <lispy> shapr: I saw you lift concat on lambda cats!
15:25:11 <shapr> Yes!
15:25:26 <lispy> :t liftM concat
15:25:27 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
15:25:32 <Vulpyne> lambda cats is the best thing ever.
15:25:37 <shapr> hiya Vulpyne!
15:25:38 <geezusfreeek> alright time to go
15:25:45 <Vulpyne> Hey, shapr! Long time.
15:25:45 <madara> lambda cats?
15:25:46 <shapr> That kitten used to sit on my shoulder as if it were a table.
15:25:55 <Vulpyne> How are things going?
15:25:59 <lispy> :t liftM join :: m [[a]] -> m [a]
15:26:01 <lambdabot>     Could not deduce (Monad m) from the context ()
15:26:01 <lambdabot>       arising from a use of `liftM' at <interactive>:1:0-9
15:26:01 <lambdabot>     Possible fix:
15:26:08 <lispy> :t liftM join :: Monad m => m [[a]] -> m [a]
15:26:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [[a]] -> m [a]
15:26:41 <lispy> I didn't realize that join = concat for the list monad.  Is this accurate?
15:27:12 <lispy> > join [[1..3],[4..6]]
15:27:13 <lambdabot>   [1,2,3,4,5,6]
15:27:20 <lispy> > concat [[1..3],[4..6]]
15:27:21 <lambdabot>   [1,2,3,4,5,6]
15:27:22 <engelmaus> yes, and >>= is concatMap
15:27:37 <lispy> I knew >>= was concatMap, so now I just feel silly
15:27:48 <mauke> join = (>>= id)
15:27:59 <mauke> concatMap id == concat
15:29:11 <engelmaus> is it really important, that lists are monads?
15:29:14 <conal> Cale: "conal: Shouldn't a Behaviour of Behaviours join essentially by taking the diagonal?" -- yes, that semantics is inevitable.  i just don't know how to implement it in a data-driven way.
15:30:21 <lispy> conal: congrats on the recent announcements.  Looks like you've been working hard on some nice stuff.
15:30:47 <Saizan> engelmaus: it's a nice monad to write depth-first search algoritms in
15:30:55 <conal> lispy: thanks!  i've enjoyed the response from haskellers
15:31:26 <lispy> oh this reminds me, have you guys tried monadius yet?
15:31:30 <wchogg> conal:  Sorry, but I'm still a little confused on how the Sink t is used in runE.  Is the entire purpose of this function just to act as a delay?
15:31:40 <lispy> it's a short game, but it's very well done.  I was quite impressed
15:31:46 <vixey> engelmaus, it's not so much important as The way it is
15:31:49 <conal> wchogg: yes.  that's the whole purpose.
15:32:04 <engelmaus> But the dfs does not depend on the monadic structure, but on the list structure?
15:32:34 <vixey> I think ther are other valid monads for [] which are not DFS
15:33:04 <engelmaus> i do not really understand, how to do a dfs on a list...
15:33:44 <vixey> engelmaus, its like if you  do a <- [1,2,3] ; b <- "xyz" ; ... it tries a = 1 and b = 'x', then it tries a = 1 b = 'y', and so on
15:33:46 <conal> Cale: section 5.4 of the Reactive paper (http://conal.net/papers/simply-reactive) talks about the absence of a Monad instance.
15:33:51 <lambdabot> Title: Simply efficient functional reactivity
15:34:26 <conal> wchogg: the funny thing about the sink/sync argument is that most of the time just evaluating the time will result in the required delay.
15:34:36 <conal> wchogg: but not *always*
15:35:24 <wchogg> conal:  So if I need to use runE explicitely to make some kind of adapter, I should probably use sleepPast a la mkUpdater for the sync'ing?
15:35:51 <engelmaus> Ok. ic.
15:36:16 <conal> wchogg: yeah.  that'd be the simplest thing.
15:36:16 <engelmaus> I think, i saw that kind of example in one tutorial.
15:36:45 <ddarius> lispy: I played it when it was first cabalized.
15:36:56 <wchogg> conal:  Cool.  Thanks again.
15:37:21 <conal> wchogg: :)
15:40:53 <conal> wchogg: just replied to your reactive@haskell.org email.  i asked you to make a trac ticket, because i'd like people to help me get issues recorded so i don't forget them.  also because i want to enable & encourage help in improving reactive so it works great for everyone.
15:41:51 <conal> wchogg: i also wanted to make it clear that i'd rather make the trac tickets myself than have them lost, if someone doesn't want to deal with trac.
15:44:03 <wchogg> conal:  Oh, I don't mind making a trac ticket.  I guess I just wasn't entirely confident that it was something worth making a ticket about.
15:45:15 <conal> wchogg: i'd say so.  and it's probably no big deal to have a few silly things in there.  i think they can be resolved easily enough.
15:45:40 <wchogg> conal:  Okay, I'll remember that.
15:46:23 <vixey> how do you get an idea what reactive is about?
15:46:30 <vixey> I stil don't have a clue
15:46:41 <shapr> Well, first you wait for everyone else to talk about it, then check your reactions.
15:46:43 * shapr hugs vixey 
15:46:50 <conal> i'd like some feedback from folks here on a trac decision.  i can allow people to make and modify tickets without being logged in, or disallow them.  my preference is that people register, so we all know who's submitted what, we can get clarification when necessary, and they can be notified automatically of progress.  my concern is that asking people to register may inhibit them from contributing.  any advice?
15:47:00 <vixey> shapr :)
15:47:07 <shapr> conal: Make 'em register, or you get spam.
15:47:26 <notsmack> conal, yeah, registration required
15:47:43 <notsmack> conal, if they're not gonna register, odds are they're not gonna make a ticket anyway, i'd say
15:48:06 <conal> vixey: read the Fran tutorial http://conal.net/fran/tutorial.htm
15:48:07 <lambdabot> Title: Composing Reactive Animations
15:48:08 <ddarius> vixey: Write some reactive code.
15:48:35 <conal> vixey: the fran tutorial will give you a feel of functional reactive programming, though it won't match the specifics of Reactive.
15:48:36 <Saizan> conal: other tracs on haskell.org require you to login but also provide a guest account on the main page
15:48:39 <ddarius> vixey: I like Shriram Krishnamurthi's talk on Flapjax to get some intuition on what the parts of reactive should mean.
15:48:43 <conal> notsmack: thx
15:49:01 <conal> Saizan: oh yeah
15:49:21 <conal> ddarius: is there an online version of Shriram's talk?
15:49:41 <conal> warning: i don't think Flapjax is purely functional.  not sure.
15:50:01 <conal> it's hard to do FRP purely without laziness.
15:50:10 <ddarius> conal: Flapjax definitely isn't purely functional as it is an adjunct to javascript.
15:50:10 <conal> (like a lot of stuff)
15:50:23 <conal> ddarius: kthx
15:50:59 <ddarius> conal: http://www.cs.brown.edu/~sk/Publications/Talks/ProgInterWeb/  He talks about it (or likely an early version of it) near the end of this talk.
15:51:02 <lambdabot> Title: Shriram Krishnamurthi: Talk: Programming the Interactive Web
15:51:10 <conal> shapr: thx.  spam was my worry.  that's why i turned off create & modify of tickets & pages for anonymous users.
15:51:22 <conal> ddarius: got it.  thanks.
15:51:35 * lispy doesn't like it when spammers win
15:51:50 <vixey> spammers won before the internet
15:51:53 <lispy> captchas are a good example of spammers winning
15:52:07 <vixey> the streets are covered in flyers and adverts
15:52:11 <ddarius> lispy: You should become a one-man spammer killing machine.
15:52:39 <vixey> I really like this reactive code
15:52:44 <vixey> in fran
15:52:56 <conal> vixey: :) !
15:53:06 <dolio> Flapjax isn't FRP. Don't scare the normals!
15:53:20 <vixey> is that what it is about, writing it al in this style
15:53:23 <bbs> vixey: what reactive code?
15:53:31 <bbs> is there a link?
15:53:34 <vixey> yes
15:53:41 <bbs> brown one?
15:53:43 <vixey> http://conal.net/fran/tutorial.htm
15:53:44 <lambdabot> Title: Composing Reactive Animations
15:53:56 * lispy hopes someone writes an extension to reactive called nuclear for the sake of puns
15:54:16 <conal> vixey: yes.  and the underlying model:  dynamic stuff as first-class values.
15:54:18 * vixey has got to watch this video next time
15:54:23 <bbs> neat
15:54:32 <conal> vixey: the model being functions of time.
15:54:50 <vixey> cool concept
15:55:00 <conal> :)
15:56:43 <conal> i want to get FRP to the point that it'll generally replace remaining uses of imperative application programming (haskell IO etc).  and so get back to simply semantics and easy reasoning.
15:57:41 <vixey> it's striking how simple these examples are
15:57:44 <conal> not there yet, but that's my goal.
15:57:57 <rog> @
15:58:02 <jsn> conal: what portions of IO can FRP actually do?
15:58:09 <rog> @pl \k v pv -> (k :- v) :- pv
15:58:09 <lambdabot> ((:-) .) . (:-)
15:58:13 <jsn> conal: presumably not file reading
15:58:21 <pumpkin> FRP?
15:58:38 <conal> jsn: FRP doesn't do any IO at all.  it's an alternative to IO
15:58:44 <conal> a different way of thinking
15:58:48 <jsn> conal: okay
15:58:57 <jsn> conal: i guess it did not ask my question right
15:59:06 <conal> np
15:59:24 <jsn> conal: clearly, i can not use anything but IO style thinking to read from files
15:59:47 <jsn> conal: so what are the use cases where i can use FRP where one now uses IO ?
16:00:15 <jsn> conal: or do you actually mean, even reading from files can be done via FRP?
16:00:30 <conal> jsn: i expect the whole notion of files will recede out of the programming model into the run-time system.
16:00:41 <conal> like thunk evaluation and stack-frame munging.
16:00:44 <conal> and garbage collection.
16:00:47 <telexicon> is there an easier function to append a char to a string? besides (++) and [a]
16:00:49 <jsn> conal: ah, okay
16:00:57 <jsn> conal: what will be in their place?
16:01:01 <Botje> telexicon: not really
16:01:18 <ddarius> telexicon: No, because a) that's not really tedious and b) such a function is a bad idea.
16:01:20 <Botje> some data structures have a snoc operation, but not lists
16:01:33 <telexicon> it just gets really messy when im lifting stuff from monads
16:01:47 <Pseudonym> Botje: Sure it does.  It's just horribly inefficient.
16:02:01 <Botje> telexicon: ponder the consequences of a:foo vs foo:a
16:02:03 <conal> jsn: i can guess: a file is part of the implementation of persistent values, either classically immutable values, or FRP behaviors.
16:02:21 <telexicon> Botje, one is a type error
16:02:21 <Botje> with the first you can keep the foo already in memory and just make your first cons cell point to a and foo
16:02:23 <jsn> conal: okay
16:02:30 <Botje> i know that
16:02:35 <Botje> imagine there WAS such a thing :p
16:02:37 <jsn> conal: i don't expect you to write it all up in this channel
16:02:47 <jsn> conal: would a pipe be any different?
16:02:48 <Botje> for the other you'd have to reconstruct every cons cell in the list
16:02:58 <Botje> which is pretty bad
16:03:18 <Botje> 0 garbage vs length(foo) * 2 garbage
16:03:23 <telexicon> how inefficient is concat?
16:03:26 <telexicon> er, (++)
16:03:43 <jsn> telexicon: linear in length of the list, i believe
16:03:44 <Botje> same as my hypothetical foo:a
16:03:46 <ddarius> telexicon: (++) is O(n) memory/time in it's left argument.
16:03:49 <conal> jsn: my understanding about pipes is that they help implement function composition and lazy evaluation.
16:04:01 <Botje> you have to walk the left list and reconstruct each cons cell
16:04:08 <jsn> conal: i mean, pipes between a haskell program and a not haskell program
16:04:12 <telexicon> awesome
16:04:23 <ddarius> telexicon: It's not inherently inefficient (it is, in fact, as efficient as you can get with a persistent, singly linked list), but it can be used in a poor manner.
16:04:34 <ksf> telexicon, use stream fusion if you care.
16:04:38 <telexicon> fortunately im working with pretty short strings
16:04:52 <ddarius> telexicon: E.g. reverse [] = []; reverse (x:xs) = reverse xs ++ [x] is O(n^2)
16:04:54 <jsn> conal: perhaps, i will review some FRP material and come back to this matter
16:04:59 <conal> jsn: to get to really really simple/powerful & composable environment, we probably have to re-work a lot of things.
16:05:09 <jsn> conal: ah, okay
16:05:39 <conal> just like runST, it may be possible to wrap up some imperative programs to have pure semantics & interface.  others may have to be ditched.
16:05:53 <jsn> conal: i see
16:05:54 <conal> in order to get back to simplicity & composability
16:05:56 <ksf> @where fusion
16:05:56 <lambdabot> I know nothing about fusion.
16:05:59 <ksf> no link?
16:06:28 <conal> composition was the original unix dream, but it was thwarted by the choice of imperative programming.
16:06:35 <ksf> @where+ stream-fusion http://www.cse.unsw.edu.au/~dons/streams.html
16:06:36 <lambdabot> Nice!
16:06:37 <jsn> conal: so even as FRP is able to subsume a great deal of IO's area of application, we'll still need it
16:06:39 <conal> not that functional systems programming would have been practical at the time.
16:06:52 <conal> jsn: need it for what?
16:07:01 <jsn> conal: pipes? sockets?
16:07:11 <ksf> typed pipes? typed sockets?
16:07:22 <jsn> ksf: no, i mean the real ones
16:07:30 <jsn> you can not type a socket, anyways
16:07:50 <conal> jsn: i think not, in the application programming model.  i'm suggesting that things like sockets & pipes fade into the RTS, along with stack munging, and garbage collection.
16:07:53 <jsn> there is no way to infer that the client or server sends valid data
16:07:59 <ksf> http://www.matroska.org/technical/specs/rfc/index.html ftw.
16:08:00 <lambdabot> Title: EBML & Matroska RFC Specifications
16:08:21 <conal> jsn: i'm doubtful of "there is no way" about anything.
16:08:29 <conal> becomes a self-fulfilling prophecy
16:08:31 <ksf> @faq
16:08:31 <lambdabot> The answer is: Yes! Haskell can do that.
16:08:49 <jsn> conal: well, there is no way to accomplish consensus in an asynchronous system
16:09:01 <Saizan> jsn: you can check at runtime, which is roughly what you do when parsing packets
16:09:08 <jsn> Saizan: right
16:09:31 <conal> jsn: often a "no way" dissolves when unconscious assumptions come to light.
16:09:48 <conal> or unnecessary constraints are lifted
16:09:51 <jsn> so you can maybe type sockets as    Either (Either ParseError SystemError) Value
16:10:23 <conal> often the problem is in the question itself.  "The beautiful answer is always proceeded by the more beautiful question."  e.e. cummings
16:10:45 <hackage> Uploaded to hackage: hpapi 0.0.1.0
16:10:48 <ksf> I'd say Either (Either TypeMismatch SystemError) Value
16:10:58 <jsn> ksf: sure
16:11:08 <jsn> ksf: but definitely not    Value
16:11:13 <ksf> but of course you can do dynamic typing
16:11:42 <jsn> conal: sure
16:11:43 <conal> btw, the inventor of unix pipes, doug mcilroy, now uses haskell.  he knew way back that pipes were equivalent to lazy evaluation.
16:11:47 <ksf> you can even try it out right now by using HaXML to do your socket communication.
16:12:01 <jsn> conal: hold on
16:12:09 <jsn> conal: you are preaching to the choir
16:12:52 <conal> jsn: glad to hear it!  sometime i worry that haskellers are content with their monadic IO and have forgotten about functional programming.
16:13:22 <jsn> conal: well, i am rather puzzled by that
16:13:27 <Pseudonym> I am too.
16:13:36 <Pseudonym> Surely half the fun is that monads are useful for things other than IO.
16:13:38 <ksf> conal, gimme a total subset of haskell and i'm going to play zealot.
16:13:40 <jsn> conal: there can be no input or output if there is no monad IO
16:13:41 <conal> btw, i gave a google tech talk about typed functional programming as fulfilling the unix dream as unix never could:  http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
16:13:44 <lambdabot> Title: Conal Elliott  Tangible Functional Programming: a modern marriage of usability ..., http://tinyurl.com/5vrmhu
16:13:54 <Pseudonym> ksf: Talk to David Turner.
16:14:01 <jsn> conal: well, then all that stuff just gets outsourced to the RTS, sure
16:14:16 <jsn> conal: but it's not clear to me what abstractions we will actually have
16:14:17 <conal> jsn: "can be no input or output if there is no monad IO" -- you don't mean that, do you?
16:14:33 <jsn> conal: i was not jesting
16:14:45 <ksf> @slap jsn
16:14:46 * lambdabot places her fist firmly on jsn's jaw
16:14:55 <jsn> conal: it is not true?
16:14:57 <conal> jsn: monadic IO was just one of many approaches.
16:15:03 <ksf> seems to have helped.
16:15:04 <jsn> conal: okay
16:15:16 <jsn> there can be no functionally pure model of IO
16:15:27 <conal> monadic IO had the best pragmatics at the time.
16:15:29 * jsn tazes ksf
16:15:45 <conal> but it left the essential semantic problems of imperative programming unaddressed.
16:15:51 <jsn> conal: oh?
16:15:55 <jsn> O_o
16:15:59 <ksf> jsn, http://homepages.cwi.nl/~tromp/cl/lazy-k.html
16:16:01 <conal> jsn: maybe there doesn't have to be a model of IO
16:16:02 <lambdabot> Title: The Lazy K Programming Language
16:16:12 <ksf> you can even do it without going esoteric.
16:16:15 <jsn> conal: why not?
16:16:43 <orbitz> in retrospect, are there solutions to I/O that might have been a better cho than monads?
16:16:48 <conal> jsn: consider haskell without IO.  you can sit in ghci and type in expressions and see the result.
16:16:57 <ksf> sequencing and infinity aren't forbidden when you got purity, not even if you have totality.
16:17:07 <jsn> conal: yeah, but i can not gettime
16:17:34 <jsn> conal: i can not look up rubbish on Yahoo Stock and use it to power the next financial crisis
16:17:49 <ksf> time is an infinite stream of unenumerable (from your side of the pipe) discrete values.
16:18:04 <conal> jsn: right about gettime.  so think of gettime as part of an answer.  figure out what the beautiful question is, and come up with a more beautiful ansser.
16:18:08 <conal> *answer
16:18:14 <conal> jsn: e.g., FRP
16:18:21 <jsn> well, okay forget about time
16:18:36 <jsn> 'cuz i am actually interested in the stock quotes
16:18:38 <conal> jsn: btw, that google talk answers some of these questions.
16:18:51 <jsn> okay, i will put it on
16:19:12 <conal> ksf: or even a *continuous* stream/flow rather than discrete.  as in frp.
16:19:31 <ksf> hasn't anyone proven yet that you can turn any imperative program into a functional one? I'd hate to invoke turing right now, too general...
16:19:31 <conal> jsn: i hope you enjoy it.
16:19:48 <conal> ksf: denotational semantics can be thought of as exactly that translation.
16:19:53 <Axman6> anyone know how to fix this error when using the Test.hs from reactive-fieldtrip (or just GLUT)? "test: user error (unknown GLUT call glutSetOption, check for freeglut)"
16:20:07 <conal> Axman6: my bad!
16:20:19 <eu-prleu-peupeu> hello Hgurus
16:20:21 <Axman6> heh, is there a fix? :)
16:20:30 <conal> does anyone know if one can find out at run-time whether the user has glut or freeglut installed?
16:20:54 <ksf> uhhhhhhmmm.... glxinfo?
16:20:56 <conal> with freeglut, FieldTrip can exit gracefully into ghci.  with glut it can't (afaik).
16:21:03 <conal> ksf: what's that?
16:21:08 <ksf> query gl extensions?
16:21:12 <ksf> it's an x11 program.
16:21:15 <Axman6> i'm on OS X, so it's using whatever comes with OS X
16:21:29 <conal> Axman6: i guess you have glut
16:21:35 <Axman6> yeah
16:21:38 <whoppix> hello. Would anyone mind pointing out why the declaration in this code is wrong? http://hpaste.org/11979
16:21:43 <ksf> nah, no glut in its output.
16:22:15 <conal> ksf: i don't think you could have installed the haskell GLUT package without glut or freeglut.
16:22:30 <Axman6> :t mod
16:22:32 <lambdabot> forall a. (Integral a) => a -> a -> a
16:22:38 <Axman6> whoppix: ^^
16:22:57 <conal> does anyone know how a *haskell program* can find out at run-time whether the user has glut or freeglut installed?
16:23:06 <eu-prleu-peupeu> conal: you could try some system commands
16:23:06 <conal> or maybe there's a config-time solution instead.
16:23:10 <Axman6> also, you don't need the if statement there, just a `dividesEvenlyBy` b = a `mod` b == 0
16:23:29 <conal> eu-prleu-peupeu: maybe so ...
16:23:32 <ksf> whoppix, wrong num instance.
16:23:39 <ksf> :t (mod)
16:23:40 <lambdabot> forall a. (Integral a) => a -> a -> a
16:23:47 <whoppix> Axman6, i guess mod wants an Integral, not a Num.. but that just raises another error: Couldn't match expected type `a' against inferred type `b'
16:23:47 <ksf> there. use Integral.
16:23:58 <Axman6> > let a `dividesEvenlyBy` b = a `mod` b == 0 in 4 `dividesEvenlyBy` 2
16:24:00 <lambdabot>   True
16:24:12 <Axman6> :t let a `dividesEvenlyBy` b = a `mod` b == 0 in dividesEvenlyBy
16:24:14 <lambdabot> forall a. (Integral a) => a -> a -> Bool
16:24:15 <conal> Axman6: would you be up for adding a FieldTrip trac ticket?  if you don't want to, just say so, and i'll do it.
16:24:28 <Axman6> i could if you like
16:24:36 <whoppix> Axman6, ah, right, thanks.
16:24:41 <Axman6> where's fieldtrip's trac?
16:24:51 <conal> http://trac.haskell.org/FieldTrip/
16:24:52 <lambdabot> Title: FieldTrip - Trac
16:25:03 <jsn> conal: do you by any chance have a paper reviewing the same material?
16:25:15 <conal> jsn: same as the google talk?
16:25:42 <Axman6> whoppix: that's something i saw a lot when i was learning haskell at uni, people would always use guards when testing a boolean expression, when you can just return the result
16:25:53 <jsn> conal: well, that has the material i was asking about before -- files and pipes and such
16:26:08 <whoppix> Axman6, yes, its kinda redundant, I guess.
16:26:30 <conal> jsn: the google talk relates but doesn't go into those specifics more than superficially.
16:26:38 <conal> other than that, no.
16:26:44 <jsn> conal: oh, curses
16:26:47 <eu-prleu-peupeu> conal: i dont think there is "way" to find the lib your looking for, in C one would usually call dlopen with the file location for runtime, or use the autoconf macros for compile time...
16:26:51 <Axman6> yeah, not using the if or guards saves typing, and makes it clearer in many cases
16:26:54 <eu-prleu-peupeu> my guess would be to search for it :/
16:28:07 <conal> eu-prleu-peupeu: too bad.  searching would be pretty slow, and os-dependent.  hm.
16:28:48 <conal> oh -- idea!  learn how the GLUT package comes up with that error message.
16:29:02 <whoppix> Axman6, got it down to this, now: http://hpaste.org/11980 but it still complains about the types of a and b: Couldn't match expected type `a' against inferred type `b' `a' is a rigid type variable bound by the type signature for `dividesEvenlyBy'
16:29:17 <whoppix> Axman6, i kinda don't understand the error, tho.
16:29:56 <Axman6> whoppix: you just need (Integral a) => a -> a -> Bool
16:30:03 <eu-prleu-peupeu> conal: well, to use the lib in runtime it is necessary to know in advance its path for the call to dlopen
16:30:07 <Axman6> they have to be of the ame type
16:30:08 <eu-prleu-peupeu> which also makes it OS dependent
16:30:10 <Axman6> same*
16:30:16 <whoppix> Axioplase_, ah, i see. thanks a lot
16:30:19 <eu-prleu-peupeu> autoconf tries to solve that...
16:30:33 <eu-prleu-peupeu> but its just a remedy, not a real solution...
16:31:25 <ksf> let a `dividesEvenlyBy` b = ((0 ==) .) . mod in 4 `dividesEvenlyBy` 2
16:31:27 <ksf> > let a `dividesEvenlyBy` b = ((0 ==) .) . mod in 4 `dividesEvenlyBy` 2
16:31:28 <lambdabot>       Overlapping instances for Show (a -> a -> Bool)
16:31:28 <lambdabot>        arising from a u...
16:31:49 <ksf> huh?
16:32:23 <lilac> > let dividesEvenlyBy = ((0==).).mod in 4 `dividesEvenlyBy` 2
16:32:24 <lambdabot>   True
16:32:37 * ksf hides under a stone
16:32:42 <Axman6> ksf: why must people male haskell unreadable by always trying to use pointfree style?
16:32:54 <ksf> because there's @pl
16:33:19 <lilac> @unpl ((0==).).mod
16:33:19 <lambdabot> (\ e h -> 0 == (mod e h))
16:33:32 <ksf> reading it is much easier than writing it, anyway.
16:33:39 <Axman6> it almost never makes it just as readable as pointfull, and usually makes very hard to follow
16:33:43 <conal> ksf: i sometimes get useful insights when clearing away the pointy stuff.  also it's an addiction.
16:33:55 <conal> oops -- meant for Axman6
16:34:16 * shapr throws pointy things at conal to watch the pointless field take effect!
16:34:23 <shapr> bzzz!
16:34:35 <conal> ouch!
16:34:43 <Axman6> i have a rule of thumb, if it has one argument, then pointfree is fine, anything more than 2 shouold never be used, and 2 should only be used when it's really clear
16:34:53 <shapr> Yeah, that's a good rule.
16:35:13 <conal> kind of.  but sometimes it's unclear how many arguments something has.
16:35:29 <jsn> conal: i guess i can see how files could be modelled as behaviours, at least from the read side
16:35:30 <conal> if i'm thinking higher-order, then a two-argument function has only one argument (for instance)
16:35:34 <Axman6> things like addTwo = map (+2) i have no problem with
16:35:44 <Riastradh> Point-free style should be employed only when the combination of functions is the important idea, rather than the intermediate values of and behaviour of the functions.
16:35:56 <conal> jsn: yeah.  i bet the write side too when you think more.
16:36:01 <jsn> conal: and file writes could be events
16:36:05 <Axman6> Riastradh: that's not a bad rule either
16:36:24 <conal> jsn: the *content* of the writes, rather than the write itself.
16:36:24 <jsn> conal: but i don't see how writes from "another process" can register as events in "this process"
16:36:26 <gwern> I generally pointsfree stuff unless the pl one is seriously ugly. this turns into a ruleofthumn 'don't pointsfree more then 2 args', since unless the function looks like 'foo a b c = bar a b c', the pl version will be seriously ugly
16:36:40 <ksf> jsn, writes are deltas.
16:36:46 <conal> jsn: just like numbers are separated from printing numbers
16:36:49 <Axman6> gwern: yep
16:36:52 <ksf> just another data structure.
16:36:55 <conal> jsn: function composition
16:37:05 <jsn> ah, okay, woh you guys
16:37:10 <conal> jsn: in other words think of processes as just something used to implementation lazy functional programming.
16:37:21 <Axman6> @pl \a b -> (mod a b) `div` (mod b a)
16:37:22 <lambdabot> ap (ap . (div .) . mod) (flip mod)
16:37:25 <conal> jsn: perhaps distributed pure lazy functional programming.
16:38:00 <Axman6> > (\a b -> (mod a b) `div` (mod b a)) 4 7
16:38:02 <lambdabot>   1
16:38:03 <conal> jsn: i'm not suggesting that any of these ideas are obvious. i've been mulling this stuff over for many years.
16:38:07 <Axman6> > (\a b -> (mod a b) `div` (mod b a)) 13 7
16:38:08 <lambdabot>   0
16:38:09 <jsn> it is certainly reasonable that "write events" are deltas
16:38:34 <ksf> more than one flip and/or ap is evil.
16:38:48 <Axman6> flip is evil 905 of the time
16:38:49 <conal> jsn: yeah!  like cons.
16:38:50 <Axman6> %
16:38:58 <conal> jsn: like 'cons x'
16:39:07 <conal> i mean '(:) x'
16:39:15 <Axman6> :t cons
16:39:17 <lambdabot> Not in scope: `cons'
16:39:18 <conal> (accidentally lisped)
16:39:24 <jsn> conal: so, in some sense, we have a third process
16:39:28 <Axman6> ah
16:39:32 <jsn> the list of file changes
16:39:40 <int-e> > map (($) `flip` 2) [succ, pred]
16:39:42 <lambdabot>   [3,1]
16:39:48 <jsn> and the other two go to this process when they need to see the file?
16:39:51 <conal> jsn: sure.  the more functions/processes the better.
16:39:58 <jsn> ah, okay
16:40:06 <Axman6> int-e: yuck
16:40:34 <conal> jsn: that's one possibility.  there are lots of them.  as long as the semantics is simple/pure, the RTS can make all kinds of smart choices, including intelligent replication.
16:40:38 <int-e> Axman6: It was a demonstration of malevolence. Infix flip is more evil than plain flip :P
16:40:46 <Axman6> i try and write my programs in a way that if i came back to them in a year, i wouldn't have to try and figure out wtf i was smoking at the time
16:41:00 <Axman6> int-e: indeed :P
16:41:10 <Axman6> conal: http://trac.haskell.org/FieldTrip/ticket/9 by the way
16:41:11 <lambdabot> Title: #9 (running Test.hs in ghci or compiled produces an error about freeglut when it ...
16:41:14 <dons> http://www.realworldhaskell.org/blog/2008/11/12/beautiful-parallelism-harnessing-multicores-with-haskell/ yo yo yo. haskell in texas
16:41:16 <lambdabot> Title: Real World Haskell  Blog Archive  Beautiful Parallelism: Harnessing Multicor ..., http://tinyurl.com/5dd5a5
16:41:16 <jsn> conal: but the semantics we use must be aware of process failure
16:41:33 <conal> Axman6: thanks a bunch!  i'm very happy to have the help.
16:41:42 <jsn> conal: e.g. it will not do to model a list in a file as just the same as a list in memory
16:41:49 <conal> jsn: hm.  maybe so.  or resilient to it.
16:41:56 <conal> (to failure)
16:42:02 <dons> shapr: there's a talk about the cell after mine, btw.
16:42:10 <jsn> conal: well, resilient might mean, goes to sleep and stops doing anything
16:42:10 <shapr> Oh cool, where at?
16:42:13 <Axman6> conal: i've heard good stuff about your work, so i just want to play with it, so i'm glad to help :)
16:42:18 <dons> austin. sc'08.
16:42:21 <shapr> Oh nifty!
16:42:22 <Axman6> conal: if you need testing, let me know
16:42:23 <conal> jsn: these are all great issues to work out along the way.
16:42:29 <shapr> dons: Doubt I'll be there, sadly.
16:42:31 <jsn> conal: sure
16:42:42 <dons> shapr: sure. i'll take notes :)
16:42:45 <conal> Axman6: awww.  thanks.  :)
16:42:47 <shapr> dons: Unless I can flip these blades for half their original list price ;-)
16:43:00 <ddarius> dons: Why did I only hear about this now?
16:43:22 <dons> ddarius: i just told you? (it was organised rather in a rush)
16:43:31 <Axman6> dons: will it be recorded? (if not... it should be!)
16:43:39 <dons> unknown, Axman6
16:43:46 <dons> ddarius: you going to sc08?
16:43:49 <dons> anyone else?
16:44:02 <Axman6> well <jedi> make it so </jedi>
16:44:09 <dons> (gigantic enormous supercomputing conference)
16:44:22 <dolio> Shouldn't that be <Picard>?
16:44:34 <Axman6> i would... if i had a car... and texas wasn't such a big drive from Canberra :)
16:44:43 <byorgey> I think Axman6 was trying to use the Force
16:44:53 <ddarius> dons: I may or may not be able to get leave on such short notice.
16:44:59 <conal> Axman6: i've been working on Reactive and FieldTrip with the Anygma folks (still totally open -- BSD).  now i want to encourage involvement of haskellers generally.
16:45:01 <Axman6> dolio: either works
16:45:06 <dons> ddarius: you nearby?
16:45:23 <ddarius> dons: A few hours drive.  < 10 for sure.
16:45:25 <Axman6> conal: is that what Beelsebob's working on?
16:45:33 <conal> Axman6: yeah.
16:45:48 <Axman6> thought so... he wouldn't spill the beans on what they were doing >_<
16:45:59 <ddarius> dons: Google says about 5 hours.
16:46:02 <conal> Axman6: and camior, luqui (sometimes) and svrog.
16:46:18 <Axman6> conal: is there somewhere the stuff can be seen?
16:46:25 <Axman6> /played with?
16:46:31 <dons> ddarius: its a big country.
16:46:44 <conal> Axman6: Reactive & FieldTrip ?
16:47:14 <Axman6> the Anygma stuff, but i guess not. Beelsebob was saying it was mostly under NDA
16:47:41 <ddarius> dons: What days are Haskell people going to be there?  The SC08 website is not friendly in this regard.
16:47:43 <conal> Axman6: there's not much to see, besides Reactive and FieldTrip.
16:47:56 <Axman6> conal: hmm, seems someone already filed that ticked before me, as ticket #8
16:47:59 <conal> Axman6: i've been recommending open-sourcing as much of the Anygma stuff as possible.
16:48:02 <dons> ddarius: specifically i'm there Monday and Tuesday.
16:48:04 <conal> Axman6: oh?
16:48:24 <dons> ddarius: for this, http://sites.google.com/site/sc08mcoregap/Home
16:48:27 <Axman6> http://trac.haskell.org/FieldTrip/ticket/8
16:48:28 <lambdabot> Title: #8 (FieldTrip depends on freeglut, won't work with other GLUT impls) - FieldTrip ...
16:48:36 * conal wishes for a speedier internet connection.
16:48:56 <Axman6> i just got one... it's terrible, dies all the time, and our airport hates it
16:49:07 <conal> Axman6: i see.  thanks anyway.  it'll happen.
16:49:17 <ddarius> dons: Any other Haskell people?
16:49:53 <dons> only me, afaik. some other people on the list will be there (people generally into parallelism), but none of the big names of haskell.
16:53:00 <Axman6> conal: any idea where the glutSetOption function is being used? doesn't seem to be in reactive-fieldtrip
16:53:31 <conal> Axman6: yeah.  it's in reactive-glut.  i'll look it up now.  just one line to comment out.
16:53:48 <ddarius> dons: I'm not particularly into the parallelism stuff.  It's interesting to watch but I don't even have a dual core.  I'm also not into supercomputing.  I may go anyway just to actually meet some Haskell peopl.
16:53:49 <Axman6> yeah, that's what i was planning on doing :)
16:54:25 <conal> Axman6: see FRP.Reactive.GLUT.SimpleGL in reactive-glut.  comment out the line "actionOnWindowClose $= MainLoopReturns"
16:54:48 <Axman6> dons: ANU just had a $30,000 T2 donated by Sun for research into paralelism and such. might get to play with it in coming years :)
16:54:55 <conal> Axman6: as i said, my bad for not testing on a glut system.
16:55:02 <dons> Axman6: huh. they gave one to unsw too.
16:55:07 <dons> and haskell.org..
16:55:18 <Axman6> conal: yeah, trying to figure out how to get the source atm, i used cabal to install most of it
16:55:34 <Axman6> dons: heh, yeah, there must be something wrong with them...
16:55:35 <dons> Axman6: for which rsrch. group?
16:55:40 <ksf> conal, i've seen the talk before and luckily didn't remember your name so i wasn't ever tempted to show any respect.
16:55:46 <conal> Axman6: oh yeah.  see
16:55:50 <conal> @hackage reactive-glut
16:55:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reactive-glut
16:56:10 <Axman6> dons: http://news.anu.edu.au/?p=758
16:56:11 <conal> @hackage GLUT
16:56:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/GLUT
16:56:12 <lambdabot> Title: ANU News  Multicore computer to help train more sleek geeks
16:56:53 <conal> Axman6: that call (glutLeaveMainLoop) is defined in Graphics.UI.GLUT.Begin .  i figure that the implementation has some way to generate that error message, and maybe we could similarly just do an Exit if freeglut is missing.
16:56:57 <conal> rather than erroring
16:57:02 <dons> Axman6: cheers.
16:58:04 <conal> ksf: :)
16:58:23 <Axman6> i sat on on a lot of Peter's lectures last semester, my friend was in one of his courses. he was pretty excited about getting that machine :)
16:58:25 <conal> ksf:  i wouldn't know how to handle a show of respect.
16:58:45 <Axman6> he also thought i was taking the course by the end of it, because i used to ask to many questions
16:59:14 <ksf> conal, i like mine with mustard. you should try it.
16:59:29 <bbs> hey all
16:59:36 <bbs> i have another golden rule idea
16:59:40 <bbs> what if you make a function fibs
16:59:56 <bbs> fibsl = map fst $ iterate (\(a,b) -> (b, a+b)) (0,1)
16:59:58 <bbs> like that
17:00:19 * conal is clueless about the mustard reference.
17:00:29 <bbs> and then you want to make a GR based on define the stream of
17:00:29 <bbs> ratios of fib numbers by taking pairs of fib numbers and dividing
17:00:44 <Axman6> i think i've seen people use that one before
17:00:54 <Axman6> > let fibsl = map fst $ iterate (\(a,b) -> (b, a+b)) (0,1)
17:00:55 <lambdabot>   <no location info>: parse error on input `;'
17:01:06 <Axman6> > let fibsl = map fst $ iterate (\(a,b) -> (b, a+b)) (0,1) in take 20 fibsl
17:01:07 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
17:02:51 <bbs> yea i know that works
17:02:57 <bbs> i just now want to define the golden ratio that way
17:03:02 <bbs> by dividing the successive pairs
17:03:06 <bbs> instead of adding
17:03:09 <Axman6> i wanted to test it, that's all :)
17:04:42 <Axman6> > let f (x:y:xs) = (x/y): f (y:xs) in let fibsl = map fst $ iterate (\(a,b) -> (b, a+b)) (0,1) in f fibsl
17:04:44 <lambdabot>   [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.619047619047...
17:06:13 <Axman6> far out i hate darcs, it _always_ fails to download some patch, no matter what i'm trying to get
17:06:44 <Axman6> a do a lot of darc get url dir; rm -rf dir; repeat
17:06:48 <int-e> > iterate (\x -> 1 + 1/x) 1 :: Rational
17:06:50 <lambdabot>   Couldn't match expected type `Rational' against inferred type `[a]'
17:07:02 <int-e> > iterate (\x -> 1 + 1/x) 1 :: [Rational]
17:07:04 <lambdabot>   [1%1,2%1,3%2,5%3,8%5,13%8,21%13,34%21,55%34,89%55,144%89,233%144,377%233,61...
17:07:43 <Saizan> Axman6: it looks like there's something weird either in the repos or in your installation of darcs, maybe you can ask on #darcs for advice
17:07:50 <Axman6> > let f (x:y:xs) = (x/y): f (y:xs) in let fibsl = map fst $ iterate (\(a,b) -> (b, a+b)) (0,1) in (f fibsl) !! 1000
17:07:51 <lambdabot>   0.6180339887498949
17:07:54 <bbs> grfinal = map fst $ iterate (\(a,b) -> (b, a `div` b)) (fibsl(0),fibsl(1))
17:08:19 <bbs> mines wrongzo
17:08:20 <bbs> :(
17:09:05 <gwern> Axman6: needless to say, for most people here darcs Works. you might want to investigat the uncommon factor before you suggest it is the quality of darcs that is at fault
17:09:51 <Axman6> i'm more inclined to say it's my shitty isp's fault (and possibly darcs' for not handling dropped packets or something along those lines)
17:10:45 <hackage> Uploaded to hackage: haskell-src-exts 0.3.11
17:10:51 <Axman6> i get a lot of "darcs failed:  Failed to download URL <url>\n It's too late to use atexit \n It's too late to use atexit \n..."
17:11:20 <ksf> Axman6, tcp cares about dropped packages.
17:11:39 <Axman6> ksf: i know, but i don't know what could explain this
17:11:48 * ksf would be quite surprised if darcs uses udp
17:12:04 <Axman6> darcs get --partial works some of the time, but not always
17:12:06 <ksf> cosmic rays hitting ram?
17:12:15 <dolio> > map (uncurry (/)) . iterate (snd &&& uncurry (+)) $ (0,1)
17:12:16 <lambdabot>   [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.619047619047...
17:12:49 <ksf> there's a reason the nasa rather uses a c64 than a contemporary processor...
17:13:14 <gwern> how could darcs use udp? it's downloading via curl, or libwww
17:14:04 <MyCatVerbs> Or through ssh, which is entirely TCP.
17:14:56 <EvilTerran> > map (uncurry (/)) . iterate (snd &&& uncurry (+)) $ (0,1 :: Rational)
17:14:57 <lambdabot>   [0%1,1%1,1%2,2%3,3%5,5%8,8%13,13%21,21%34,34%55,55%89,89%144,144%233,233%37...
17:17:26 <telexicon> whats the other pure testing lib besides quickcheck?
17:18:04 <lispy> telexicon: smallcheck
17:18:10 <telexicon> lispy, thanks
17:18:49 <telexicon> hmm, i guess thats not
17:19:25 <lispy> Axman6: oh, --partial is a bit of a misfeature.  It's much better to use --lazy.  This requires the use of hashed repository format, which you should also prefer due to better atomticity
17:19:54 <lispy> telexicon: well, I know of quchickcheck, smallcheck and hunit
17:20:04 <lispy> telexicon: if you're thinking of something else it's probably new to me :)
17:20:11 <telexicon> well im just thinking about how i would test my parsec stuff
17:20:33 <telexicon> i cant see how smallcheck would fit, since they dont operate on general data, but specific string patterns
17:21:12 <lispy> Axman6: what version of darcs do you use, and please consider making bug reports :)  If we don't know it's broken we can't fix it
17:21:30 <Axman6> lispy: well i don't know what's broken
17:21:40 <Axman6> so i have no idea if it's darcs or not
17:21:56 <Axman6> trying --lazy atm
17:22:07 <Axman6> gahh! same damn thing
17:43:56 <rog> i've just found (accidentally) that you can import several namespaces qualified with the same prefix. is this strictly legal?
17:46:07 <dons> rog: strictly legal
17:46:36 <rog> cool. presumably it just does a union of the namespaces and complains if there are any clashes?
17:47:24 <dons> yeah, like with the default namespace
17:48:04 <int-e> rog: so it will complain if you try to use an ambiguous symbol
17:48:41 <rog> that's handy.
17:49:59 <Saizan> do you also get ld to use ~300mb of ram when linking an haskell program?
17:50:43 <Corun> I was bored.
17:50:48 <Corun> So I wrote an AI in C
17:50:53 <Corun> It _kinda_ works
17:50:54 <Corun> http://rafb.net/p/4y7yOA86.html
17:50:59 <lambdabot> Title: Nopaste - No description
17:51:12 <int-e> Saizan: any haskell program?
17:54:02 <conal> Axman6: still there?
17:54:09 <Axman6> yep
17:54:49 <conal> Axman6: what action leads up to "user error (unknown GLUT call glutSetOption, check for freeglut)"?  is it closing the window?
17:55:07 <conal> Axman6: i.e., do you get to run the demos first?
17:55:08 <Axman6> no, just running the program at all
17:55:14 <Axman6> i get nothing
17:55:45 <conal> oh, urg.  thanks.  have you yet tried commenting out the line?
17:56:12 <Axman6> i haven't been able to get darcs to work yet, so no
17:56:48 <conal> Axman6: no darcs.  bummer.  you can also download reactive-glut from hackage:
17:56:51 <conal> @hackage reactive-glut
17:56:51 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reactive-glut
17:56:52 <int-e> Saizan: the last time I managed to do that, I was compiling / linking the ghc package with split-objs. (which took more than 300 MB)
17:57:27 <conal> Axman6: i didn't know darcs was problematic on some machines.
17:58:11 <int-e> Saizan: since then I've patched my ld to use a smaller default hashtable size (31 instead of 4051 entries)
17:58:37 <Axman6> conal: ok, used hackage, what do i need to comment out, and where?
17:58:37 <conal> Saizan: any progress with the ghci echoing problem?  none on my end.
17:58:58 <ddarius> dons: Bah.  I can't really justify the registration costs.
17:59:25 <conal> Axman6: The offending piece of code is the following line in FRP.Reactive.GLUT.SimpleGL in the reactive-glut package: "actionOnWindowClose $= MainLoopReturns"
17:59:26 <BMeph_> I'm bored of being a haskeller. I want to be a haskelleer! With a lambda-bedecked hat, even! ;p
17:59:31 <conal> Axman6: Commenting out this line will eliminate the error message.
18:00:15 <andrewsw> BMeph_: I long for the day when I, too, could be a haskelleer!
18:00:53 <jsn> that's good, i'm going to use that from now on
18:00:59 <jsn> haskelleer
18:02:43 <Axman6> conal: ok, i get a window... but not much in it
18:02:48 <Axman6> oh, ther eit is
18:03:49 <conal> Axman6: maybe the surface was tessellating at first.  FieldTrip shapes are intrinsically curved, and adaptively approximated during rendering.
18:05:26 <Cale> conal: I think there might be value in identifying periodic time functions in some special way.
18:05:27 <Axman6> haha, wow, nice artifacts there. i resized the window, and got images from the vista machine that was running in vmware yesterday.
18:05:54 <conal> Cale: Axman6 oops.
18:06:05 <conal> Cale: please say more about what you have in mind.
18:06:07 <Axman6> not sure its your problem realt
18:06:13 <Axman6> really*
18:06:24 <Axman6> i'll post a pic though, it's pretty funny imo
18:06:26 <Cale> conal: Time functions which are periodic can be memoised, so long as they get sampled at the same points.
18:06:40 <conal> Axman6: i don't yet handle window damage intelligently.
18:07:04 <Axman6> i think it's fascinating, that that stuff's still in the video RAM
18:07:47 <conal> Cale: oh, for optimization.  the same-sampled bit wouldn't hold in general.  however, i've been playing with exact data representations of behavior and imagery that support cached arbitrary precision sampling.
18:08:11 <conal> Cale: like the representation of surfaces in FieldTrip, which is a infinite trie of tessellations.
18:08:27 <Cale> conal: I tried doing some 3D animation stuff with height maps, and found that recomputing the heightmap over and over was killing performance. Of course, other kinds of memo combinators could be used, but it would be nice to have a primitive to fix a time resolution and cache everything.
18:08:58 <adu> > showIntAtBase 17 (" ?cefghimnoprstuw"!!) 38338119292370263690683237229891 ""
18:09:00 <conal> Cale: you tried in reactive-fieldtrip?
18:09:00 <lambdabot>   "how goes the mucipher fun?"
18:09:04 <Cale> yeah
18:09:12 <conal> cool :)
18:09:17 <Cale> Of course, it was an animated heightmap
18:09:25 <ddarius> Cale: Of?
18:09:27 <Cale> (a sort of water ripple effect)
18:09:33 <ddarius> Crap, what I guessed.
18:09:36 <Cale> hehe
18:09:50 <conal> Cale: i wouldn't fix a time resolution, since continuous time is a central principle, but there are other ways to get the desired efficiency without compromising semantics.
18:10:33 <conal> Cale: and yeah, animated shapes won't be fast right now.  they will be when rendering moves to the GPU, as in Vertigo.
18:10:45 <hackage> Uploaded to hackage: gitit 0.2.2.1
18:11:05 <Cale> conal: Well, I figure there has to be some bound on time resolution imposed from somewhere.
18:11:11 <conal> animated shapes were insanely fast in Vertigo on now-six-year-old hardware.
18:11:19 <Cale> :)
18:11:21 <conal> Cale: there isn't.
18:11:43 <conal> and imposing such a bound would break composability
18:11:51 <Axman6> conal: http://www.flickr.com/photos/57127535@N00/3026559924/
18:11:51 <conal> just as it would in space
18:11:53 <lambdabot> Title: Picture 92 on Flickr - Photo Sharing!
18:11:56 <Cale> conal: Well, it could be a flexible bound, couldn't it?
18:12:12 <conal> Cale: i don't know what that would mean?
18:12:19 <conal> s/?/.
18:12:29 <jsn> conal: vertigo ?
18:12:31 <conal> what's a flexible bound?
18:12:47 <conal> Axman6: looking ... (satellite internet connection)
18:12:56 <Cale> Well, think of arbitrary precision floating point, for instance.
18:13:25 <conal> Axman6: wow! :/
18:13:45 <Axman6> :)
18:14:03 <Cale> Where you request a certain precision from a function, and in turn, it requests a certain precision based on that from its parameters.
18:15:51 <Axman6> conal: gott admit, a pretty impressive bug, bringing up images from the past
18:15:56 <Axman6> gotta*
18:16:03 <conal> Axman6: :)
18:16:17 <conal> Cale: would you please add a ticket to the reactive and/or FieldTrip ticket with your suggestion about exploiting time and/or space periodicity?  i'm sure there's a cool, efficient, and semantics-friendly solution.
18:16:45 <Cale> sure
18:17:07 <adu> periodicity? like spinning cursors?
18:18:00 <conal> adu: spinning is no problem, since rotation is done after tessellation.  more like wobbling cursors.
18:18:18 <conal> i.e., i.e., warping periodically
18:18:20 <conal> (nonlinearly)
18:18:32 <conal> ripply stuff etc
18:19:12 <adu> ripply? like Beryl/Compiz?
18:19:21 <conal> exactly
18:19:22 * ddarius tries to think of something interesting to render.
18:19:35 <adu> conal: what are you working on?
18:19:54 <conal> adu: mostly Reactive and FieldTrip
18:20:00 <adu> what are they?
18:20:00 <conal> adu: how about you?
18:20:08 <conal> @wiki reactive
18:20:08 <lambdabot> http://www.haskell.org/haskellwiki/reactive
18:20:12 <conal> @wiki FieldTrip
18:20:12 <lambdabot> http://www.haskell.org/haskellwiki/FieldTrip
18:20:23 <adu> conal: well, mostly darcs diff
18:20:40 <adu> but I uploaded a random package to hackage yesterday
18:21:17 <conal> is that a package about randomness, or did you randomly upload a package?
18:21:31 <conal> (i first thought the latter)
18:21:56 <ddarius> @hackage vector-space
18:21:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vector-space
18:22:10 <adu> > showIntAtBase 18 (" .:Iacdegklmnopruy"!!) 2889221266421320965369595530436882177803231818383 ""
18:22:11 <lambdabot>   "conal: I randomly uploaded a package..."
18:22:37 <conal> adu: wtf?  magic!
18:22:39 <adu> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mucipher
18:22:41 <Axman6> o.O
18:22:43 <lambdabot> Title: HackageDB: mucipher-0.6.0, http://tinyurl.com/6qokta
18:22:49 <Axman6> :t showIntAtBase
18:22:52 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
18:23:18 <conal> adu: neat trick
18:23:21 <Axman6> @src showIntAtBase
18:23:22 <lambdabot> Source not found. There are some things that I just don't know.
18:25:55 <conal> wow -- a beautiful full moon in a clear sky out my window right now.  i love living in the woods, even if it means crappy internet service.
18:28:01 <adu> i've heard of reactive in the general sense, but I didn't know it was also a specific project...
18:28:33 <BMeph_> adu++
18:28:37 <wchogg> conal:  Not much light pollution?
18:28:52 <conal> adu: yeah.  the paradigm is called "functional reactive programming" (FRP), and I call this implementation "Reactive".
18:29:12 <adu> lispy: how are you?
18:29:14 <lispy|web> We don't have a Language.Shell yet do we?
18:29:16 <conal> wchogg: none at all here.  when there's no moon, it's *very* dark.
18:29:36 <lispy|web> adu: I'm okay, but my internet connection is extremely flaky
18:29:56 <adu> lispy|web: ic, are you hosting lambdabot?
18:30:06 <lispy|web> adu: yes
18:30:09 <lispy|web> http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_03
18:30:10 <wchogg> conal:  Then, sir, I do envy you very much.  Madison isn't exactly a big city, but it has terrible light pollution.  The sky is permanently orange.
18:30:22 <lambdabot> Title: Shell Command Language, http://tinyurl.com/6ckth
18:30:27 <Cale> ddarius: Sphere eversion ;)
18:30:30 <lispy|web> That seems to define the grammar for shell.  I but happy + alex could be used to make that into Language.Shell
18:30:38 <ddarius> > (\s -> let nubs = sort $ nub s; lens = length nubs in "showIntAtBase " ++ lens ++ " (\"" ++ nubs ++ "\"!!) " ++ show (foldl' (\acc c -> lens * acc + fromIntegral (fromJust $ elemIndex c nubs)) 0 s) ++ " \"\"") "conal: I randomly uploaded a package..."
18:30:40 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Int'
18:30:42 <lispy|web> Or maybe parsec is better?
18:31:06 <adu> lispy|web: are you suggesting making Haskell POSIX compliant? :)
18:31:08 <ddarius> > (\s -> let nubs = sort $ nub s; lens = length nubs in "showIntAtBase " ++ show lens ++ " (\"" ++ nubs ++ "\"!!) " ++ show (foldl' (\acc c -> lens * acc + fromIntegral (fromJust $ elemIndex c nubs)) 0 s) ++ " \"\"") "conal: I randomly uploaded a package..."
18:31:09 <lambdabot>   "showIntAtBase 18 (\" .:Iacdegklmnopruy\"!!) -6366193676868259185 \"\""
18:31:32 <ddarius> Ah, stupid length
18:31:39 <ddarius> > (\s -> let nubs = sort $ nub s; lens = genericLength nubs in "showIntAtBase " ++ show lens ++ " (\"" ++ nubs ++ "\"!!) " ++ show (foldl' (\acc c -> lens * acc + fromIntegral (fromJust $ elemIndex c nubs)) 0 s) ++ " \"\"") "conal: I randomly uploaded a package..."
18:31:45 <lambdabot>   "showIntAtBase 18 (\" .:Iacdegklmnopruy\"!!) 288922126642132096536959553043...
18:31:58 <lispy|web> adu: Well, I want a copy of sh that is as portable as Haskell.  In this case, I want sh on windows without cygwin/mingw.  It seems logical that if I had Language.Shell I could build a quick 'n dirty shell :)
18:32:02 <adu> ddarius: there is an easier way
18:32:05 <conal> and a cool package indeed.
18:32:11 <adu> , showCipher "like this"
18:32:13 <lunabot>  "showIntAtBase 8 (\" ehiklst\"!!) 91262622 \"\""
18:32:21 <adu> , showCipher "hello world"
18:32:23 <lunabot>  "showIntAtBase 8 (\" dehlorw\"!!) 3566500769 \"\""
18:32:26 <mwc> Cabal-install question. It seems that the dependency resolution algorithm tries to minimize the number of packages to install. I noticed when trying to install parsec, it selected an older 2.x version, I assume to avoid an MTL dependency
18:32:29 <lispy|web> So, is lambdabot down?
18:32:37 <lispy|web> I may have to stop hosting her....
18:32:39 <mwc> any config switch to ask it to always pull in the most recent version?
18:32:39 <adu> lispy|web: it was yesterday
18:32:39 <ddarius> adu: I was implementing showCipher.
18:32:41 <Cale> > 1 + 1
18:32:42 <lambdabot>   2
18:32:43 <lispy|web> She seems to bring my server down
18:32:50 <adu> ddarius: oh ok
18:33:01 <lispy|web> I can't even login at the moment
18:33:21 <int-e> @bot
18:33:22 <lambdabot> :)
18:33:22 <Saizan> mwc: it installs 2.x because hackage ships a "preferred versions" file that tells it to prefer 2.x over 3.x
18:33:23 <Cale> lispy|web: I can
18:33:30 <Saizan> mwc: for parsec i mean
18:33:30 <mwc> Saizan: ahhh
18:33:32 <lispy|web> hhmm
18:33:41 <Cale> @flush
18:33:41 <adu> ddarius: you totally lost me with the lens*acc
18:33:56 <mwc> Saizan: alrighty thanks. Easier answer than digging into source ;)
18:34:07 <jeffz> mwc, many people would probably prefer parsec 2 over 3 for performance reasons too
18:34:37 <adu> lispy|web: it would make many ppl sad if you stopped hosting :(
18:34:52 <lispy|web> adu: yes, including myself
18:34:53 <Cale> lispy|web: how about now?
18:35:20 <Saizan> lispy|web, Cale: you probably want to rebuild it now that -threaded was added back to the options
18:35:30 <Saizan> *has been
18:35:58 <lispy> Cale: better
18:36:03 <lispy> I'm logged in again
18:36:08 <lispy> and I can type real-time
18:36:27 <Cale> lispy: I didn't have any slowness logging in for some reason.
18:36:39 <adu> lispy|web: so by Language.Shell, do you mean something that can emit/eval/compile shell files?
18:37:19 <BMeph_> So, do we have an options package, and if not, what should we have in it that Perl wants but can't do efficiently? ;)
18:37:23 <lispy|web> Cale: I'm having some internet problems that are unrelated to lambdabot so it's hard to say...but I can't login yet
18:37:34 <lispy|web> Cale: hmm...it became unresponsive again
18:38:20 <Cale> The CPU on olive is 97% idle.
18:39:05 <Cale> and there's ~630MB of free memory
18:40:06 <lispy|web> adu: the first step would be for Language.Shell to provide a parser.  As far as I know, that's what all the Language.* provide
18:40:06 <lispy|web> adu: given that opengroup.org spells out the grammar, lexer and disambiguation rules, making Language.Shell should be relatively painless, plus we can infer test cases, and use other shell implementations are an oracle, etc.
18:40:06 <lispy|web> Cale: yeah, maybe it's my local internet problems that are the bigger issue.
18:41:00 <telexicon> in parsec isnt there a way to specify a range of values, say.. 1 to 3 char 'n' ?
18:42:28 <telexicon> for claiming to not need a lexer parsec sure makes me want to use regex for a lot of things
18:43:31 <Cale> telexicon: I've never needed that specific thing, but I could easily write one...
18:43:55 <telexicon> Cale, how would you parse an ip4 address then?
18:43:58 <Cale> (at least, I'd better hope that's easy -- Parsec is not actually my favourite parser combinator library)
18:44:03 <adu> telexicon: I would use some combination between "flip" "count" and (<|>)
18:44:28 <gwern> Cale: well, that's fair reasonable men can differ over whether to use parsec, or attoparsec, or nanoparsec
18:44:45 <Cale> gwern: I think I like ReadP best.
18:44:53 <telexicon> adu, it'd have to do backtracking then
18:45:08 <gwern> heretic!
18:45:29 <adu> telexicon: then maybe do count n p ; optional p; optional p; optional p...
18:45:32 <mcnster> hi.  anyone know if there are haskell bindings for libelf?
18:45:58 <Cale> telexicon: why do you need that to parse an IP address?
18:46:07 <Cale> telexicon: It's 4 integers separated by dots...
18:46:40 <telexicon> Cale, because 128.3321.3020193901.3141 isnt a valid ip address
18:46:48 <adu> telexicon: there's gotta be a readIP function somewhere in some library
18:47:11 <adu> telexicon: neither is 999.999.999.999
18:47:28 <mwc> telexicon: I'd define an action that reads an int, then verifies it's between 0 and 255, failing if not
18:47:35 <mwc> then I chain them with parsers that read periods
18:47:42 <adu> telexicon: why not read them as ints, then error if any satisfy (>256)
18:47:44 <telexicon> hm
18:47:50 <Cale> right.
18:47:55 <telexicon> that'd still need backtracking
18:48:01 <Cale> Parse the integers, then bound their values.
18:48:29 <adu> its not backtracking when the whole thing goes up in smoke :)
18:48:48 <telexicon> because it consumes input
18:50:25 <shapr> telexicon: There are such combinators in hsemail
18:50:43 <Cale> Prelude Text.Parsec> let integer = fmap read (many1 digit) :: (Stream s m Char) => ParsecT s u m Integer
18:50:46 <Cale> Prelude Text.Parsec> parseTest (integer `sepBy` char '.') "23.46.123.7"
18:50:46 <Cale> [23,46,123,7]
18:51:02 <telexicon> heh
18:51:03 <Cale> at that point, you can guard that the list has length 4 and the numbers are in range
18:51:06 <telexicon> well its ambiguous anyways
18:51:12 <Cale> ambiguous?
18:51:22 <telexicon> because the same area can hold a hostname
18:52:25 <Cale> Oh, well, you could examine the strings you read and see if it's a valid IP, and if not, interpret it as a hostname.
18:52:33 <mwc> telexicon: according to the parsec documentation, the mzero instance fails without consuming input
18:52:51 <telexicon> mwc, right so then <|> would work,
18:55:23 <Cale> telexicon: of course, you could wrap the thing in try here if it's a problem
18:55:53 <telexicon> hmm, this might work
18:56:06 <telexicon> ill foldl what you all said, and use that solution
18:57:26 <ddarius> note that there is already an integer parser in parsec (or better a natural one)
19:07:18 <heatsink> I'm writing bindings to an imperative library that updates data structures in place.  Is there a smart way to provide a functional interface without copying data all the time?
19:09:04 <pizza_> that is an excellent question.
19:10:34 <roconnor> heatsink: do you want to access these changing data structures in haskell?
19:12:16 <heatsink> roconnor, I think the normal use is to create data structures and perform operations on them, but not access their contents.
19:12:50 <heatsink> roconnor, it's a presburger arithmetic library.  The data structures are math formulae.
19:13:13 <heatsink> You can traverse them, but it's not often useful.
19:13:52 <debrac> Hello all
19:13:58 <debrac> How do I remove a given index from a list?
19:14:44 <roconnor> heatsink: so the pure interface should provide one function that creates, manipulates, and then destroys these objects.
19:15:33 <roconnor> possibly doing this according to some recepie that is given by some haskell data type that you make.
19:16:06 <heatsink> debrac: I don't think there's a library function for it.  Easiest to write your own loop.
19:16:18 <roconnor> well, several functions could do this create-modify-destroy operation, so long as the creation and destruction happens all in one go.
19:16:36 <Axman6> debrac: something like remove n xs = (take n xs) ++ (tail.drop n xs) would do it i think
19:16:54 <Axman6> > let remove n xs = (take n xs) ++ (tail.drop n xs) in remove 3 "hello"
19:16:55 <lambdabot>   Couldn't match expected type `a -> [a1]'
19:17:06 <Axman6> > let remove n xs = (take n xs) ++ (tail.drop n $ xs) in remove 3 "hello"
19:17:08 <lambdabot>   "helo"
19:17:12 <Axman6> > let remove n xs = (take n xs) ++ (tail.drop n $ xs) in remove 2 "hello"
19:17:14 <lambdabot>   "helo"
19:17:15 <conal> (tail . drop n)
19:17:30 <conal> or that
19:17:46 <Axman6> > let remove n xs = (take (n-1) xs) ++ (tail.drop (n-1) $ xs) in remove 2 "hello"
19:17:48 <lambdabot>   "hllo"
19:17:53 <Axman6> since it's an index
19:17:59 <Axman6> or...
19:18:55 <mightybyte> @seen chr1s
19:18:55 <lambdabot> chr1s is in #haskell. I don't know when chr1s last spoke.
19:18:58 <Axman6> remove n xs = (\(h,t) -> h ++ tail t) $ splitAt (n-1) xs
19:19:10 <Axman6> > let remove n xs = (\(h,t) -> h ++ tail t) $ splitAt (n-1) xs in remove 2 "hello"
19:19:11 <lambdabot>   "hllo"
19:19:26 <Axman6> @pl remove n xs = (\(h,t) -> h ++ tail t) $ splitAt (n-1) xs
19:19:26 <lambdabot> remove = (uncurry ((. tail) . (++)) .) . splitAt . subtract 1
19:19:31 <Axman6> yuck
19:19:35 <heatsink> roconnor: Something like (runComputation (intersect (use c) $ union (use a) (use b)))
19:19:40 <Axman6> @unpl k
19:19:41 <lambdabot> k
19:19:43 <Axman6> @unpl k
19:19:43 <lambdabot> k
19:19:45 <Axman6> urgh
19:19:54 <Axman6> @unpl remove = (uncurry ((. tail) . (++)) .) . splitAt . subtract 1
19:19:55 <lambdabot> remove e n = uncurry (\ h q -> h ++ (tail q)) (splitAt (subtract 1 e) n)
19:20:23 <heatsink> roconnor: so the intersect and union functions simply build commands that are interpreted by runComputation?
19:20:49 <roconnor> I'm thinking intersect and union would be constructors (potentially)
19:21:13 <roconnor> I bet you could even wrap things up so the user doesn't even know there is a "run" command
19:22:21 <adu> > (\i ls -> map snd $ deleteBy (\x y -> (fst x == fst y)) (i,0) $ zip [0..length ls - 1] ls) 2 "hello"
19:22:22 <lambdabot>       No instance for (Num Char)
19:22:22 <lambdabot>        arising from the literal `0' at <inte...
19:22:39 <adu> > (\i ls -> map snd $ deleteBy (\x y -> (fst x == fst y)) (i,' ') $ zip [0..length ls - 1] ls) 2 "hello"
19:22:40 <lambdabot>   "helo"
19:23:11 <telexicon> ddarius, no the one in parsec skips whitespace
19:23:31 <roconnor> heatsink: I'm assuming here that the typical modus operandi is when using the lib is to build up a formula, as a question about it, and then toss the formula away.
19:23:32 <debrac> umm my lists are lists of numbers
19:23:33 <debrac> so like
19:23:43 <debrac> [0, 1, 2] remove 1 == [0, 2]
19:23:57 <debrac> I dont need to manipulate strings....
19:23:58 <adu> debrac: right, my version sucks, you should use the splitAt version
19:25:05 <heatsink> roconnor, that's a common case, though sometimes you'll want to build a formula and then use it later.
19:25:16 <debrac> but ehhh
19:25:21 <debrac> I dont uncurry does
19:25:23 <Axman6> but what?
19:25:29 <Axman6> don't use uncurry
19:25:35 <Axman6> :t uncurry
19:25:36 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:25:50 <heatsink> roconnor, I don't know how to hide the 'run' command.  There has to be some way of knowing whether all references are accounted for, or some could escape.
19:25:51 <roconnor> heatsink: use it later, or use it twice?
19:25:54 <debrac> So wait
19:25:54 <Axman6> takes a function f a b, and lets it use f (a,b)
19:25:57 <debrac> What was the answer?
19:25:58 <heatsink> use it repeatedly.
19:26:04 <Axman6> > let remove n xs = (\(h,t) -> h ++ tail t) $ splitAt (n-1) xs in remove 2 "hello"
19:26:06 <lambdabot>   "hllo"
19:26:13 <adu> > let remove xs n = (\(h,t) -> h ++ tail t) $ splitAt n xs in ([0,1,2] `remove` 1)
19:26:14 <lambdabot>   [0,2]
19:26:17 <Axman6> > let remove n xs = (\(h,t) -> h ++ tail t) $ splitAt (n-1) xs in remove 5 "hello"
19:26:18 <lambdabot>   "hell"
19:26:25 <Axman6> > let remove n xs = (\(h,t) -> h ++ tail t) $ splitAt (n-1) xs in remove 6 "hello"
19:26:26 <lambdabot>   "hello* Exception: Prelude.tail: empty list
19:26:31 <roconnor> heatsink: oh, then what I wanted to do wouldn't quite work.
19:26:46 <Axman6> not perfect
19:27:22 <debrac> ehhh ok
19:27:29 <debrac> But what does \(h, t) do ?
19:27:43 <adu> debrac: do you understand what we are talking about?
19:27:54 <debrac> vaguely
19:27:55 <roconnor> heatsink: you could have a "freeze" funciton that takes a haskell datatype and builds the impure object as a new datatype.  And then not allow that object to ever be modified by your interface.
19:27:56 <adu> debrac: well the expression is actually (\ pattern -> template)
19:28:00 <debrac> I dont usually use haskell
19:28:15 <dmwit__> > let remove n xs = take n xs ++ drop (n + 1) xs in remove 0 "hello"
19:28:16 <lambdabot>   "ello"
19:28:19 <adu> debrac: and the pattern is (h, t) which is a tuple, which means the input of that must be a tuple
19:28:20 <roconnor> heatsink: takes the haskel datatype as a recipe.
19:28:20 <dmwit__> > let remove n xs = take n xs ++ drop (n + 1) xs in remove 32 "hello"
19:28:22 <lambdabot>   "hello"
19:28:32 <Axman6> dmwit__: much nicer, thanks
19:28:32 <dmwit__> Axman6: total functions for the win
19:28:33 <debrac> oh I see I see
19:28:39 <debrac> I just am not familiar with that notation
19:28:43 <adu> debrac: and it just so happens that the output of "splitAt" is a tuple
19:28:44 <debrac> Right now it makes sense
19:28:53 <Axman6> debrac: it's a lambda expression
19:29:01 <Axman6> or an anonymous function
19:29:07 <debrac> right
19:29:13 <adu> > splitAt 5 "hello world"
19:29:14 <lambdabot>   ("hello"," world")
19:29:52 <heatsink> roconnor, so I'd have two sets of functions, like Array and MArray?
19:30:04 <heatsink> two sets of functions and data types
19:30:27 <adu> debrac: are you just experimenting, or do you want to build something?
19:30:39 <roconnor> heatsink: I would quite go that far
19:30:43 <roconnor> maybe freeze is a bad name
19:30:48 <roconnor> make is a better name
19:31:12 <roconnor> data Formula = biz | bar Formula Formula | baz Formula
19:31:34 <roconnor> makeBurger :: Formula -> Burger
19:31:41 <heatsink> heh
19:31:47 <roconnor> burgerOp1 :: Burger -> Real
19:31:59 <roconnor> burgerOp2 :: Burger -> [Double]
19:32:11 <roconnor> burgerOp3 :: Burger -> Burger -> [[Double]]
19:32:23 <gwern> @seen cosmicray
19:32:23 <lambdabot> I saw cosmicray leaving #haskell-blah and #haskell 26d 5h 43m 21s ago, and .
19:32:31 <roconnor> no burgerOps are allowed to run mutating functions
19:32:39 <mib_llc7y4> @lamdarobot
19:32:39 <lambdabot> Unknown command, try @list
19:32:43 <mib_llc7y4> @list
19:32:43 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:32:44 <roconnor> only make runs mutating functions
19:32:49 <roconnor> makeBurger
19:33:27 <mib_llc7y4> @lamdarobot undo  main = do;  initGUI;  window <- windowNew;  button <- buttonNew;  set window [ containerBorderWidth := 10,;               containerChild := button ];  set button [ buttonLabel :=  "Hello World" ];  onClicked button (putStrLn "Hello World");  onDestroy window mainQuit;  widgetShowAll window;  mainGUI
19:33:27 <lambdabot> Unknown command, try @list
19:33:36 <mib_llc7y4> @undo  main = do;  initGUI;  window <- windowNew;  button <- buttonNew;  set window [ containerBorderWidth := 10,;               containerChild := button ];  set button [ buttonLabel :=  "Hello World" ];  onClicked button (putStrLn "Hello World");  onDestroy window mainQuit;  widgetShowAll window;  mainGUI
19:33:36 <lambdabot>  Parse error at "=" (column 6)
19:33:50 <mib_llc7y4> @undo main = do;  initGUI;  window <- windowNew;  button <- buttonNew;  set window [ containerBorderWidth := 10,;               containerChild := button ];  set button [ buttonLabel :=  "Hello World" ];  onClicked button (putStrLn "Hello World");  onDestroy window mainQuit;  widgetShowAll window;  mainGUI
19:33:51 <lambdabot>  Parse error at "=" (column 6)
19:33:53 <Axman6> mib_llc7y4: get rid of the main =
19:34:06 <mib_llc7y4> @undo do;  initGUI;  window <- windowNew;  button <- buttonNew;  set window [ containerBorderWidth := 10,;               containerChild := button ];  set button [ buttonLabel :=  "Hello World" ];  onClicked button (putStrLn "Hello World");  onDestroy window mainQuit;  widgetShowAll window;  mainGUI
19:34:06 <lambdabot>  Parse error at ";" (column 100)
19:34:16 <heatsink> roconnor: That's what I had in mind for the non-mutating functions.
19:34:18 <Axman6> and the ; after do
19:34:28 <mib_llc7y4> @undo do  initGUI;  window <- windowNew;  button <- buttonNew;  set window [ containerBorderWidth := 10,               containerChild := button ];  set button [ buttonLabel :=  "Hello World" ];  onClicked button (putStrLn "Hello World");  onDestroy window mainQuit;  widgetShowAll window;  mainGUI
19:34:29 <lambdabot> initGUI >> windowNew >>= \ window -> buttonNew >>= \ button -> set window [containerBorderWidth := 10, containerChild := button] >> set button [buttonLabel := "Hello World"] >> onClicked button (
19:34:29 <lambdabot> putStrLn "Hello World") >> onDestroy window mainQuit >> widgetShowAll window >> mainGUI
19:34:32 <Axman6> you need do {thing; x <- stuff; thingo;...]
19:34:33 <Axman6> }*
19:34:47 <mib_llc7y4> Ah, got it. Thank you.
19:35:10 <heatsink> roconnor, There are mutating functions that make new relations from old ones.  It's those that seem to need copying.
19:35:22 <roconnor> only call them from makeBurger
19:35:54 <roconnor> I don't know if what I'm saying actually captueres how the lib is used.
19:36:44 <heatsink> I haven't used the library in big programs, so I don't know a lot about typical use cases...
19:36:59 <heatsink> One use case is that you want to make a relation and then test if it's satisfiable.
19:37:04 <heatsink> makeRel :: Expr -> Relation
19:37:09 <heatsink> satisfiable :: Relation -> Bool
19:37:16 <heatsink> That works with what we have so far.
19:37:39 <heatsink> Another use case is that you want to make a relation, and then compose it with other relations.
19:37:44 <heatsink> compose :: Relation -> Relation -> Relation
19:37:58 <heatsink> crossProduct, intersection, union :: Relation -> Relation -> Relation
19:38:15 <heatsink> You may want to use the same relation several different ways, then test if each result is satisfiable.
19:38:54 <roconnor> how can you use the same relation in several different ways if composing it mutates it?
19:41:38 <heatsink> If you use the same relation as argument to several of these functions, you need to copy it.
19:41:50 <heatsink> What I expect to happen is that some relations get reused (and need to be copied) while others are created and used exactly once.
19:42:02 <heatsink> More specifically...
19:42:15 <roconnor> the user of the imperitive lib would need to do explict copying?
19:42:20 <heatsink> Yes
19:42:40 <roconnor> is copying cheaper than building it again?
19:43:06 <heatsink> You'd want to test relation X by composing it with A, B, C.  A, B, and C are created only for the purpose of testing X, so they don't need to be copied.
19:43:16 <heatsink> roconnor, copying would be cheaper.
19:43:31 <roconnor> heatsink: tricky problem
19:44:03 <roconnor> sure by X needs to be copied 3 times
19:44:11 <heatsink> right
19:44:36 <heatsink> I can implement it with copying, for now, and think about optimizing it later.  It's a more interesting problem than I thought.
19:47:01 <ksf> @quote more interesting
19:47:01 <lambdabot> No quotes for this person. It can only be attributed to human error.
19:47:04 <ksf> @quote more interesting
19:47:04 <lambdabot> No quotes for this person. Take a stress pill and think things over.
19:47:10 <ksf> wait a sec...
19:50:21 <ksf> @remember spj It usually turns out to be more interesting and challenging that[sic] it seemed at first
19:50:21 <lambdabot> Good to know.
19:50:50 <pheaver> i have issues migrating some code to ghc 6.10.  should i ask here, or on #ghc?
19:50:53 <ksf> @quote spj
19:50:53 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
19:51:00 <ksf> @quote spj
19:51:00 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
19:51:06 <ksf> @quote spj
19:51:06 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
19:51:16 <ksf> ...speaking about randomness.
19:52:45 <Saizan> pheaver: try here
19:53:12 <pheaver> I'm trying to port an old library (I'm not original author), and it is using S# and J#, which are not in scope on 6.10
19:53:49 <pheaver> And...I know nothing of such things
19:54:15 <jsn> pheaver: S# and J# ?
19:54:23 <pheaver> Yes, as constructors
19:54:27 <jsn> ah
19:54:41 <pheaver> there's also a function called "toBig" that isn't in scope
19:54:45 <Saizan> those are from GHC's internals
19:54:55 <pheaver> heh, yes, that much i know :)
19:55:08 <Saizan> i think GHC.Prim exports them
19:55:15 <pheaver> interesting
19:55:27 <pheaver> i found an article that said GHC.Prim does not export them anymore
19:55:30 <pheaver> and to use GHC.Exts instead
19:55:46 <orbitz> save, by, zero
19:55:50 <Saizan> hah
19:57:06 <pheaver> neither GHC.Prim nor GHC.Exts seem to provide them for me
19:58:19 <pheaver> have they perhaps been renamed?
19:58:25 <dons> pheaver: ghc-prim and integer packages
19:58:29 <dons> pheaver: using ghc 6.10 ?
19:58:52 <pheaver> yes
19:58:53 <pheaver> ghc 6.10
19:58:56 <dons> for cabal, you'd say,
19:58:57 <dons>     if impl(ghc >= 6.9)
19:58:59 <dons>         build-depends: ghc-prim, integer
19:58:59 <dons> iirc
19:59:09 <pheaver> i am using ghc-prim, import GHC.Prim and GHC.Exts
19:59:13 <pheaver> and they are still not available
19:59:56 <dons> oh, maybe they're in base?
20:00:04 <Saizan> dons: the problem is the module
20:00:26 <pheaver> yeah i don't know what module exports them
20:00:36 <dons> Loading package ghc-prim ... linking ... done.
20:00:36 <dons> Loading package integer ... linking ... done.
20:00:36 <dons> Loading package base ... linking ... done.
20:00:36 <dons> Prelude> :m + GHC.Prim
20:00:36 <dons> Prelude GHC.Prim> :m + GHC.Exts
20:00:39 <pheaver> i've used both base3 and base4
20:00:40 <Saizan> GHC.Integer.Internals exports them, but it doesn't look like something you're supposed to import
20:00:41 <dons> so they must be in those packages.
20:00:50 <dons> the I# and J# constructors. oh.
20:01:17 <dons> integer-gmp, $ cd ../integer-gmp/
20:01:17 <dons> $ ls
20:01:17 <dons> GHC  LICENSE  Setup.hs  _darcs  integer.cabal
20:01:17 <dons> $ ls GHC/Integer/*
20:01:20 <dons> GHC/Integer/Internals.hs
20:01:23 <pheaver> well, importing GHC.Integer.Internals works
20:02:10 <pheaver> thanks
20:04:09 <mm_freak> i'd like to 'shutdown' a Handle to close one side of the socket
20:04:11 <mm_freak> is that possible?
20:05:06 <dons> hClose ?
20:05:21 <mm_freak> hClose closes the socket completely
20:05:33 <mm_freak> see shutdown(2)
20:05:50 <pheaver> and this "toBig" function, where might I find that?
20:06:02 <mm_freak> you can close only one side of a socket, for example signal to a server that you won't send any more data
20:07:03 <dons> pheaver: hunt around in the integer-gmp package.
20:07:17 <mm_freak> Network.Socket allows me to use 'shutdown' only on a Socket, not on a Handle, and the docs discourage using the Socket any further as soon as i have converted it to a Handle
20:07:17 <dons> http://darcs.haskell.org/packages/integer-gmp/
20:07:18 <lambdabot> Title: Index of /packages/integer-gmp
20:08:00 <pheaver> ah, ok
20:09:20 <pheaver> what documentation, if any, could I have consulted to find this information?
20:09:43 <Axman6> #haskell >_>
20:09:46 <pheaver> ha
20:09:59 <Axman6> live haskell documentation
20:10:18 <pheaver> yeah but then i have to bother people
20:12:18 <Saizan> pheaver: for the Integer constructors i use :info Integer in ghci
20:12:25 <Saizan> "used"
20:12:42 <adu> pheaver: theres also hoogle and hayoo!
20:12:52 <adu> pheaver: sometimes useful
20:12:55 <pheaver> but they don't know about these
20:13:01 <pheaver> of course i tried hoogle first
20:13:11 <adu> try hayoo! as well
20:13:18 <Saizan> can you infer the type of toBig?
20:13:26 <adu> :t toBig
20:13:27 <lambdabot> Not in scope: `toBig'
20:13:29 <Saizan> maybe it's something like fromIntegral
20:13:54 <pheaver> hayoo couldn't find them either
20:15:02 <pheaver> it looks like toBig :: Integer -> Integer
20:15:03 <pheaver> i think
20:15:22 <Axman6> what's it do then?
20:15:28 <dons> flips the constructors?
20:15:45 <pheaver> no idea
20:16:11 <dons> toBig (S# i)     = case int2Integer# i of { (# s, d #) -> J# s d }
20:16:11 <dons> toBig i@(J# _ _) = i
20:16:25 <pheaver> yeah i can't read that lol
20:16:44 <pheaver> anyway, that's not the problem
20:16:55 <pheaver> we know where toBig is now
20:17:07 <dons> oh, S# to J#.
20:17:20 <pheaver> but where is that gmp-integer package?  ghc didn't come with it and it's not on hackage
20:17:27 <dons> integer-gmp comes with ghc
20:17:31 <dons> base depends on it.
20:17:34 <pheaver> i mean "integer-gmp" :)
20:17:42 <dons> (you can also plug in other integer libraries, theoretically)
20:17:46 <pheaver> well i certainly don't have it
20:17:49 <pheaver> i have "integer"
20:17:57 <dons> $ ghc-pkg list integer
20:17:57 <dons> /usr/lib/ghc-6.10.0.20081007/./package.conf: integer-0.1.0.0
20:18:00 <pheaver> which has S# and J#, but not toBig
20:18:04 <dons> oh
20:18:10 <dons> Igloo: around?
20:18:17 <dons> Igloo: <- is responsible.
20:18:30 <dons> oh, integer-gmp provides the integer package
20:18:36 <pheaver> ok....
20:18:44 <dons> integer == integer-gmp.
20:18:46 <pheaver> but according to http://darcs.haskell.org/packages/integer-gmp/GHC/, toBig is in GHC.Integer
20:18:47 <lambdabot> Title: Index of /packages/integer-gmp/GHC
20:18:50 <pheaver> and it's not for me
20:19:05 <pheaver> ah it's not exported!
20:19:21 <dons> oh
20:19:34 <dons> ah so it isn't.
20:19:53 <pheaver> every single time we upgrade to a new version of ghc, it takes us days to port this damn library
20:20:06 <pheaver> cause it's like 10 years old and has so much old crap in it
20:20:09 <dons> we should test during the ghc release cycle.
20:20:18 <dons> then we'd have been able to complain about  the api change.
20:20:44 <dons> (pheaver works for some other company that uses haskell, i guess)
20:21:05 <pheaver> ?
20:21:07 <dons> so toBig used to be exported?
20:21:13 <pheaver> i guess so
20:21:13 <pheaver>  
20:21:28 * pheaver pheaver works right next to you, dons :)
20:21:39 <dons> oh, you're that company next door? i see.
20:21:40 <ddarius> pheaver: Why don't you rewrite it?
20:21:45 <pheaver> haha
20:21:57 <pheaver> ddarius: i can now that i know what the problem is
20:21:58 <dons> pheaver: so toBig should probably be exported from the *.Internals module
20:22:08 <adu> wow, i want to move to OR
20:22:08 <dons> since that's where the constructors are exported from
20:22:40 <dons> its nice here. we have haskells.
20:22:51 <lispy> Oregon can has Haskells?
20:23:02 <Nafai> I wish I had Haskells
20:23:08 <dons> pheaver: so toBig at least you can implement locally, using the constructors from .Internals, and ghc-prim for the primops
20:23:13 <pheaver> indeed
20:23:13 <Nafai> But I at least just lost the Javas!
20:23:21 <dons> lispy <-- another OR haskeller
20:23:35 <pheaver> and if i want to support 6.8 also
20:23:42 <dons> pheaver: yeah, CPP.
20:23:44 <lispy> YAOHH -- Yet Another Oregon Haskell Hacker :)
20:23:46 <pheaver> yup
20:23:48 * adu packs his bags
20:23:55 <dons> so you all clear to proceed?
20:24:00 <pheaver> of course
20:24:04 <dons> goody
20:24:08 <pheaver> but i'm still going to complain that this was necessary at all
20:24:12 * adu waits at airport
20:24:24 <dons> pheaver: yeah, seems like you're the main user dependent on Integer internals
20:24:25 <pheaver> i want to reduce the amount of code that depends on what version of GHC we have, not increase it :(
20:24:43 <dons> right. so the move was so we could decide not to use integer-gmp at all, of course.
20:24:52 * adu calmly watches as all bathroom products are confiscated ... 
20:24:53 <pheaver> :)
20:25:02 <dons> and use say, http://darcs.haskell.org/packages/integer-simple/
20:25:02 <lambdabot> Title: Index of /packages/integer-simple
20:25:28 * Nafai wonders if I can seek Haskell into my new job
20:25:50 <adu> Nafai: I've already got 3 ppl interested in it at my job
20:25:59 <dons> cool. good work.
20:26:02 <pheaver> well, i don't so much mind these changes
20:26:42 <pheaver> but, you'll have a hard time convincing us to test drive new versions of ghc and provide feedback when there's something we don't like
20:26:49 <roconnor> dons:  is GHC free at last?
20:27:03 <dons> pheaver: you gotta get involved in the dev process. keep an eye on big changes.
20:27:10 <dons> or have someone act as proxy for your concerns.
20:27:26 <dons> roconnor: you could use it without integer-gmp, yup
20:27:26 <pheaver> ideally, yeah
20:27:32 <roconnor> \o/
20:27:44 <adu> pheaver: subscribe to everything, then put it in a folder, and grep "maybe"
20:27:45 <adu> :)
20:27:47 <pheaver> but unfortunately we don't have the time
20:27:51 <dons> pheaver: yeah.
20:28:08 <pheaver> i would just ask for documentation of these changes
20:28:11 <dons> pheaver: maybe just letting the dev community know what you care about
20:28:13 <dons> e.g. integer.
20:28:18 <dons> oh, the changes are documented.
20:28:32 <pheaver> well, anyway that i can fix these problems without coming to IRC :)
20:28:34 <adu> pheaver: diff -ru /
20:28:40 <dons> http://haskell.org/haskellwiki/Upgrading_packages#Typical_breakages_with_GHC_6.10
20:28:42 <lambdabot> Title: Upgrading packages - HaskellWiki, http://tinyurl.com/3bhj2d
20:28:42 <pheaver> :)
20:28:56 <pheaver> i've been to that site
20:29:21 <dons> feel free to add any additional things you hit.
20:29:38 <pheaver> It is no longer possible to import GHC.Prim, instead, GHC.Exts should be used to get at the compiler's primops.
20:29:41 <adu> dons: did you see my ghc patch?
20:29:44 <pheaver> that seemed the most releveant
20:29:47 <pheaver> but it didn't help
20:30:08 <dons> adu: no?
20:32:50 <adu> dons: it was for linked tuples: http://haskell.pastebin.us/15804
20:32:57 <adu> i'm not sure who to talk to about it tho
20:33:08 <adu> or weather its even a good idea
20:35:12 <dons> oh, what does that implement?
20:35:33 <adu> dons: just a notation
20:35:46 <Nafai> adu: Cool.  I wonder if I can do that for my company
20:35:47 <adu> dons: it makes (a; b; c) synonymous with (a, (b, (c, ())))
20:35:56 <Nafai> I'll have a little lee-way because it is internal tool development
20:36:07 <dons> adu,oh  i see. weird :)
20:36:39 <adu> dons: it simulates a lot of what the HList library offers, only with builtin functions
20:36:52 <adu> dons: like the head/tail equivalents would be fst/snd, obviously
20:37:09 <ddarius> adu: By "a lot" you mean "a rather little"
20:37:17 <adu> ddarius: yes
20:37:44 <dons> yeah, the power / weight ratio for new syntax is hard to justify.
20:38:02 <dons> e.g. parallel list comps are kinda gone. and this is a less common case than 'zip'.
20:38:11 <dons> good to see contributions though. what was the motivation?
20:38:27 <adu> dons: tuples suck
20:38:34 <ddarius> dons: "kinda gone"?  Do you just mean that people don't use them or something stronger?
20:39:35 <araujo> hello
20:39:38 <adu> having 0 functions that support using tuples is very encouraging to find a better solution
20:39:53 <araujo> adu, ?
20:40:08 <dons> ddarius: not on the haskell-prime track
20:40:16 <ddarius> dons: Woo!
20:40:23 <dons> heh
20:40:30 <dons> you're one of those ones, eh?
20:40:36 <ddarius> Yep.
20:40:42 <dons> hah
20:41:19 <ddarius> Though parallel list comprehensions aren't anywhere near as bad as the "generalized list comprehensions"
20:41:37 <dons> oh boy.
20:41:52 <dons> yeah, something of a lead balloon. but outsiders like it.
20:42:06 <dons> at least in principle.
20:42:23 <dons> i've yet to see them used for anything, anywhere, though.
20:42:37 <dons> we also got pattern views in this release
20:42:43 <dons> and explicit postfix sections
20:42:57 <Saizan> explicit?
20:43:28 <dons> they got enabled by default last release, but you have to turn them on now
20:44:55 <ddarius> Is that usage actually a violation of the Report?
20:48:34 <roconnor> dmwit__: I was thinking of putting rgb and toRGB into Data.Colour.sRGB, but I feel bad about that because sRGB really talk about a linear colour space, except in passing.  I'm now contemplating putting it in Data.Colour.sRGB.Linear instead.
20:48:59 <dmwit__> Is sRGB even a valid module name?
20:49:07 <roconnor> er, it's call SRGB
20:49:11 <dmwit> oh
20:49:21 <roconnor> so Data.Colour.SRGB.Linear
20:49:53 <dmwit> To be honest... I don't actually know anything about this stuff. =P
20:51:23 <heatsink> I learned a little about color spaces, and they're too complicated.
20:51:56 <heatsink> roconnor, do the color space data types "know" their gamma factor?
20:51:58 <roconnor> dmwit: hmm, I don't know if you have to know about this stuff.
20:52:33 <roconnor> heatsink: well, there is just 1 colour type.  But to convert it to different coordinate systems, you need to know their gamma factor.
20:53:44 <roconnor> dons makes releasing code sound so easy. :P
20:53:47 <heatsink> :)
20:54:13 <ddarius> roconnor: You're probably worrying too much.
20:54:27 <roconnor> ddarius: oh I know I am :P
20:54:50 <heatsink> What's the color gamut?
20:55:28 <roconnor> heatsink: different coordinate systems have different gamuts.  Or are you asking about the definition of gamut?
20:56:00 <heatsink> I meant the gamut for your color data type.
20:56:31 <Axman6> hmm, new ghc port in macports, wonder if it'll work
20:56:41 <roconnor> heatsink: gamut doesn't apply to the Colour type.
20:56:50 <roconnor> Colour is coordinate free
20:57:21 <heatsink> The gamut is the range of representable colors, not the coordinate space.
20:57:37 <mfwitten> yaht and the wikibook totally gloss over the requisite information. I've got `fst' and `snd' for pairs, but how do I get data out of n-tuples with n>2 ?
20:57:49 <mfwitten> Must I structure everything as embedded pairs?
20:57:50 <roconnor> all colours are representable, even imaginary colours.
20:57:59 <jeffz> mfwitten: pattern match
20:58:12 <mfwitten> ok fair enough. I haven't read anything about that really.
20:58:17 <mfwitten> I'll just have to wait anxiously
20:58:24 <jeffz> mfwitten: fst and snd only apply to tuples that have two elements
20:58:50 <heatsink> roconnor, that's nifty.
20:59:12 <mfwitten> jeffz: Any particular reason why indexing isn't available?
20:59:16 <jeffz> @src fst
20:59:16 <lambdabot> fst (x,_) =  x
20:59:20 <Axman6> roconnor: can imaginary colours be seen?
20:59:31 <Saizan> > let (a,b,c) = ("foo","bar","baz") in a ++ b ++ c
20:59:32 <lambdabot>   "foobarbaz"
20:59:35 <roconnor> heatsink: it's not too hard.  I simply allow negative numbers internally
20:59:40 <Axman6> hmm, that could be an interesting class, Nthable
20:59:42 <jeffz> mfwitten: you write a function that returns the element of the tuple, tuples are fixed length, so you don't really have a generic index function
20:59:42 <mfwitten> jeffz: I'm guessing safety
21:00:04 <mfwitten> jeffz: ok.
21:00:08 <Axman6> and a function nth to get the nth element of a structure. could work on tuples and lists
21:00:19 <roconnor> Axman6: they cannot be seen by rentinal stimulation by photons.  However, I can imagine that they would be visible by direct optical nerve stimulation.
21:00:26 <mfwitten> Saizan: Thanks for the example
21:00:41 <Axman6> roconnor: heh, fair enough
21:01:03 <Axman6> roconnor: colour absorbing colours?
21:01:10 <mfwitten> Saizan, jeffz: Thanks! I'm off to sleep
21:01:24 <roconnor> Axman6: ?
21:01:39 <Axman6> well, they might appear 'blacker than back'
21:01:55 <roconnor> Axman6: more likely yellower than yellow
21:02:01 <roconnor> greener than green
21:02:05 <Axman6> fair enough
21:02:06 <heatsink> grue
21:02:06 <roconnor> bluer than blue
21:02:10 <roconnor> etc.
21:02:17 <roconnor> I they  wouldn't really be new colours
21:02:24 <Axman6> but the real part would be less than the magnitude of the colour no?
21:02:25 <roconnor> just more saturated than physically possible.
21:03:08 <roconnor> I think taking LSD might also work.
21:03:48 <Axman6> like ((2/2)+(2/2)i :: Red) would be 2/s length, so shorter than 1+0i
21:04:07 <Axman6> 2/2 real length*
21:04:12 <roconnor> Axman6: oh, imaginary colours don't have imaginary coordinates
21:04:19 <Axman6> lame
21:04:25 <Axman6> they should
21:04:34 <Axman6> could make for some interesting pics
21:04:37 <roconnor> they are simply real coordinates that occur outside the CIE horseshoe.
21:04:50 <Axman6> you've lot me now
21:04:54 <Axman6> lost*
21:05:22 <roconnor> @go chromaticity
21:05:26 <lambdabot> http://www.chromaticity.com/
21:05:26 <lambdabot> Title: Chromaticity | Home
21:05:36 <roconnor> er
21:05:41 <roconnor> not right
21:05:48 <roconnor> http://en.wikipedia.org/wiki/Chromaticity
21:05:49 <lambdabot> Title: Chromaticity - Wikipedia, the free encyclopedia
21:06:27 <roconnor> Axman6: you can see (and attempt) at representing the CIE horseshoe there
21:06:45 <roconnor> all physically realizable colours appear inside that horeshoe
21:07:05 <roconnor> imaginary colours appear outside the horseshoe.
21:07:49 <roconnor> so (0.7,0.1) would be an untra saturated red with a hint of purple.
21:07:51 <Axman6> ah, i see
21:08:15 <mofmog> Is there anything like emacs, but non fixed width/height font
21:08:21 <mofmog> sort of like... for typography?
21:15:20 <roconnor> mofmog: can you set a non-monospaced font in emacs?
21:15:43 <roconnor> mofmog: or there is TeXmacs if you want something really pretty
21:17:37 <roconnor> wow. Chromaticity in accelerator physics should totally not be in that article.
21:19:37 <heatsink> Perhaps the authors were sniffing gluons.
21:20:29 <roconnor> :)
21:44:03 <kohwj> hi, does anyone know whether gnomecanvas has haskell bindings, such as through gtk2hs?
21:44:38 <dmwit> Ah, I wish gtkhoogle still worked.
21:45:02 <kohwj> ah, hoogle. thanks dmwit
21:45:14 <dmwit> Sorry, but hoogle won't cut it. =/
21:48:18 <Saizan> anyone familiar with ncurses or better hscurses? i'd like to reproduce an irssi-like ui
21:49:03 <mofmog> Saizan: I wrote GOL with escape codes once...
21:49:13 <Axman6> Saizan: making an irc client?
21:50:05 <kohwj> http://www.haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-Misc-DrawingArea.html looks promising
21:50:06 <lambdabot> Title: Graphics.UI.Gtk.Misc.DrawingArea, http://tinyurl.com/6n67tc
21:50:52 <Saizan> Axman6: a alternative ghci frontend, more or less
21:51:00 <Saizan> "an"
21:51:10 <Axman6> ah, dang. i'd be interested in a haskell irc client
21:51:43 <Saizan> uhm that would be cool to
21:52:12 <mofmog> what'd be the point?
21:52:17 <mofmog> unless it was extensible in haskell
21:52:26 <Saizan> yeah, being scriptable in haskell
21:52:32 <jeffz> I was saying the other day that if Yi got an irc client, more people would use it
21:52:40 <jeffz> like Emacs has erc
21:52:51 <mofmog> it should also have minigames included
21:52:59 <mofmog> including robots and an adventure game
21:53:12 <mofmog> also it should use 8 mb of memory and be totally unusable on anything older than 5 years
21:54:52 <Saizan> Axman6: if you can figure out how to use ncurses or any equivalent library i can help with the rest of the client :)
21:55:21 <Axman6> sure...
21:55:28 <jeffz> Saizan, that's why you'd use Yi as a base
21:55:54 <Saizan> jeffz: Yi uses vty which is abandoned
21:56:04 <jeffz> ah, that's unfortunate
21:56:40 <jeffz> but, that shouldn't matter if you're just writing an irc client in Yi using the buffer management functions
21:57:39 <xhanjian> @src lat
21:57:39 <lambdabot> Source not found. That's something I cannot allow to happen.
21:57:41 <xhanjian> @src last
21:57:41 <lambdabot> last [x]    = x
21:57:41 <lambdabot> last (_:xs) = last xs
21:57:41 <lambdabot> last []     = undefined
21:59:17 <Saizan> jeffz: last time i tried Yi it seemed quite slow in the terminal though
22:01:47 <Axman6> > case undefined of undefined -> "sweet"; _ -> "hmm"
22:01:48 <lambdabot>   mueval: Prelude.read: no parse
22:01:48 <lambdabot>  mueval: UnknownError "GHC reported errors a...
22:02:01 <Axman6> ooo, unexpected error
22:02:31 <Axman6> isnit possible to pattern match on functions?
22:02:36 <Axman6> is it*
22:02:49 <sciolizer> @go q lang
22:02:52 <lambdabot> http://q-lang.sourceforge.net/
22:02:52 <lambdabot> Title: Q - Equational Programming Language
22:03:15 <sciolizer> Q supports pattern matching on functions; haskell only on constructors (and a few weird things like "x+1")
22:06:38 * sciolizer wonders what the type system would look like in a language supporting pattern matching of function application
22:07:52 <sjanssen> Axman6: it isn't possible to pattern match on functions
22:08:19 <sjanssen> Axman6: your example is the same thing as: case undefined of x -> "sweet"; _ -> "hmm"
22:08:19 <Axman6> well just as well, i've forgotten why i asked it now :P
22:12:52 <jeffz> hm, Data.Colour is cool :>  I'm using it with OpenGL
22:23:55 <vegai> bracket doesn't work if the whole thread is killed, right?
22:27:22 <grom358> noob question, what does $ mean ?
22:27:39 <jeffz> @src ($)
22:27:40 <lambdabot> f $ x = f x
22:28:29 <dons> vegai: finally ?
22:29:05 <vegai> @hoogle finally
22:29:05 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
22:29:07 <Saizan> vegai: killThread just sends an exception
22:29:14 <Saizan> vegai: so it should work
22:29:53 <Saizan> vegai: i'm not sure what happens if the exception is raised during the cleanup code, but it shold be blocked
22:30:25 <Axman6> grom358: it's often used like f.g.h $ x, which becomes f (g (h x)))
22:30:34 <vegai> hmm, yes. I think finally suits the purpose in my case better
22:31:03 <grom358> okay.. so is there any difference between: sum $ filter even $ takeWhile (<= 4000000) fibs and sum . filter even . takeWhile (<= 4000000) $ fibs
22:31:29 <Saizan> no
22:31:48 <Saizan> only that the latter is easier to refactor
22:32:13 <Axman6> grom358: the latter is usually preferred
22:32:23 <grom358> so is $ basically a shortcut to avoid parens?
22:32:49 <Axman6> yep
22:33:00 <Axman6> saves some typing
22:33:14 <vegai> yes, finally works just fine for cleanup
22:33:45 <Cpudan80> Hello all
22:33:56 <Cpudan80> Does anyone know why the up arrow key doesnt work in hugs ?
22:34:05 <Cpudan80> like normally it would spit back the last command you typed
22:34:17 <sciolizer> Cpudan80: you need hugs to be compiled with GNU readline support
22:34:22 <Cpudan80> but in hugs it just gives the ascii value for the keypress or something
22:34:31 <Cpudan80> oh ehh....
22:34:40 <Cpudan80> Cant do that then
22:34:42 <sciolizer> Most distros provide that support as a package.
22:35:06 <Cpudan80> I guess I could install the thing in my userspace
22:35:16 <Cpudan80> Right now I am using the version on our public network
22:35:20 <sciolizer> ah
22:35:29 <sciolizer> Whine to your sysadmin. :)
22:35:45 <Axman6> i tried to do that once with ghc. it was too fat and couldn't fit in my quota :(
22:38:48 <Axman6> oh wow, ghci got history between sessions
22:39:02 <Axman6> and the macports people fixed ghci! :D
22:42:40 <Saizan> fixed?
22:45:17 <Axman6> yeah, readline like stuff didn't work at all
22:53:54 <Saizan> heh, i still have problems using it in emacs since 6.10
23:01:52 <jsn> Axman6: the macports of ghc-6.10 actually builds?
23:02:08 <Axman6> yep
23:02:12 <Axman6> works great too
23:03:10 <jsn> hmmm
23:03:19 <jsn> Axman6: and the readline stuff is working?
23:03:28 <Axman6> yep
23:03:35 <jsn> tab complete file and module names, up-down arrows?
23:03:41 <Axman6> it even has history between ghci sessions
23:03:45 <jsn> hmm
23:04:01 <jsn> okay, it's time for me to update my system
23:04:21 <Axman6> readline/libedit was stuffed, but not anymore
23:04:45 <jsn> yeah, i saw on the mailing list
23:05:34 <jsn> i wonder how much of my existing programs will break?
23:05:47 <jsn> oh, and i have to reinstall all my libs
23:05:49 <jsn> bleah
23:07:15 <dons> use cabal-install
23:07:31 <jsn> dons: yeah
23:07:38 <jsn> now that i have that :)
23:07:39 <Axman6> dons: how would i tell cabal-install to recompile everything it's instaled?
23:07:48 <Axman6> ll*
23:09:30 <Saizan> Axman6: there's a ticket requesting that feature :) it's marked as easy
23:09:42 <jsn> i really look forward to quasi-quotes
23:11:06 <dons> Axman6: well, ghc-pkg --simple-output  > x ; <update ghc 6.10> ; cabal install $(cat x)
23:11:09 <dons> i guess would work.
23:11:13 <dons> i've not tried it, but it sounds cool.
23:11:27 <Axman6> heh fair enough
23:11:34 <Axman6> thought there might be a way
23:12:35 <roconnor> It's strange that haddock cannot document class methods.
23:16:28 <jsn> dons: i think that might actually result in reversion, though -- things like STM show up in the listing
23:16:48 <jsn> i guess you can just strip out the version numbers with sed
23:21:32 <jsn> ghc-pkg list --simple | sed -r 's/-[[:digit:]]+(\.[[:digit:]]+)+/ /g' > packages
23:22:41 <roconnor> > fold (flip (:)) "" "Hello!"
23:22:42 <lambdabot>   Not in scope: `fold'
23:22:46 <roconnor> > foldl (flip (:)) "" "Hello!"
23:22:48 <lambdabot>   "!olleH"
23:22:52 <roconnor> > foldl' (flip (:)) "" "Hello!"
23:22:54 <lambdabot>   "!olleH"
23:23:00 <roconnor> @src reverse
23:23:01 <lambdabot> reverse = foldl (flip (:)) []
23:24:49 <Peaker> grom358: mainly, yeah. Its also used to build function appliers, e.g:   map ($) blah  [though map id blah would also work].  And stuff like map ($5) funcs
23:28:05 <Axman6> Peaker: heh, only an hour late :)
23:28:24 <Axman6> ah, dinner time. bbl
23:31:13 <idnar> Peaker: surely map id blah is a noop?
23:32:16 <quicksilver> idnar: zipWith ($) might be a more interesting example.
23:32:30 <idnar> yeah...
23:35:28 <Peaker> idnar: Yeah, map ($) and map id are equal, but map ($) specializes the type
23:36:04 <quicksilver> map ($) and map id have the same type.
23:36:25 <jsn> :t ($)
23:36:26 <lambdabot> forall a b. (a -> b) -> a -> b
23:36:26 <quicksilver> the only difference is in the most-general-type of the subterms. But that's not relevant except to human eyes.
23:36:30 <jsn> :t map ($)
23:36:31 <lambdabot> forall a b. [a -> b] -> [a -> b]
23:36:45 <jsn> :t map id
23:36:46 <lambdabot> forall a. [a] -> [a]
23:37:05 <quicksilver> doh
23:37:11 * quicksilver takes that back ;(
23:38:34 * quicksilver was thinking of the zipWith example.
23:41:18 <Peaker> quicksilver: code that compiles with map id, may not compile with map ($)..
23:41:38 <alc> > printf "%04d\n" (3::Int)
23:41:38 <lambdabot>   Add a type signature
23:41:44 <quicksilver> Peaker: yeah, I was wrong.
23:41:53 <quicksilver> Peaker: I was thinking of sipWith.
23:42:07 <jsn> alc: that really, really needs a type signature
23:42:15 <alc> hmm like what?
23:42:24 <jsn> > printf "%04d\n" (3::Int) :: String
23:42:25 <lambdabot>   "0003\n"
23:42:33 <alc> oh, see, thanks
23:42:33 <jsn> > printf "%04d\n" (3::Int) :: IO ()
23:42:34 <lambdabot>   * Exception: "<IO ()>"
23:42:40 <jsn> ack
23:42:45 <jsn> > print 7
23:42:46 <lambdabot>   * Exception: "<IO ()>"
23:43:07 <jsn> alc: it can make you a string, or it can perform the action of printing
23:43:45 <BeelsebobWork> it doesn't perform the action -- merely creates it
23:43:54 <alc> got it
23:43:57 <jsn> BeelsebobWork: yes
23:44:07 <jsn> alc: what BeelsebobWork says is right
23:44:25 <alc> and can lambdabot show the local defined src?
23:44:35 <alc> @let fff = (+)
23:44:36 <lambdabot>  Defined.
23:44:39 <alc> @type fff
23:44:40 <lambdabot> forall a. (Num a) => a -> a -> a
23:44:43 <alc> @src fff
23:44:43 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:44:43 <jsn> @src fff
23:44:43 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:46:42 <alc> type works but not src
23:46:50 <alc> @undefine fff
23:52:10 <BONUS_> sdnow
23:52:53 <madara> ?
23:56:54 <Axman6_> :t printf
23:56:55 <lambdabot> forall r. (PrintfType r) => String -> r
23:57:09 <Axman6_> @instances PrintfType
23:57:09 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
