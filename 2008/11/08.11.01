00:00:53 <mmorrow> (and the "world state" is represented by a data with zero constructor by GHC, ie the RealWorld is imaginary ;)
00:01:10 <mmorrow> data RealWord
00:01:16 <mmorrow> </end>
00:01:48 <mmorrow> so the only value of type RealWorld is (undefined::RealWorld)
00:02:07 <mmorrow> , undefined
00:02:09 <lunabot>  luna: Prelude.undefined
00:03:03 <mmorrow> IO though could be implemented by anything though, as long as it had the same semantics
00:04:14 <bd_> mmorrow: in the case of GHC, it's RealWorld#, I thought?
00:04:29 <mmorrow> i can't remember
00:04:33 <bd_> same thing I suppose
00:04:37 <bd_> realWorld#, that's it
00:04:41 <mmorrow> heh
00:04:58 <bd_> actually, it has to be non-bottom
00:05:06 <bd_> otherwise any function that examines it would exception
00:05:19 <bd_> (or loop)
00:06:06 <mmorrow> unsafePerformIO m = unsafeDupablePerformIO (noDuplicate >> m)
00:06:13 <mmorrow> unsafeDupablePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
00:06:20 <mmorrow> unsafeInterleaveIO m = unsafeDupableInterleaveIO (noDuplicate >> m)
00:06:52 <mmorrow> unsafeDupableInterleaveIO (IO m)
00:06:52 <mmorrow>   = IO ( \ s -> let r = case m s of (# _, res #) -> res
00:06:52 <mmorrow>                 in (# s, r #))
00:07:01 <mmorrow> noDuplicate = IO $ \s -> case noDuplicate# s of s' -> (# s', () #)
00:07:13 <mmorrow> are the current defs
00:08:31 <mmorrow> bd_ that's why a value of type RealWorld is never examined :)
00:09:02 <mmorrow> realWorld# :: State# RealWorld
00:09:09 <bd_> the opaque implementation of putStr examines it :)
00:09:38 <mmorrow> realWorld# isn't :: RealWorld
00:10:51 <bd_> mmorrow: well, it's State# RealWorld
00:11:04 <bd_> RealWorld is just a tag type it seems
00:11:49 <mmorrow> data RealWorld
00:12:10 <mmorrow> so i believe the only possible value of it's type is (undefined::RealWorld)
00:14:55 <bd_> however this is implementation magic
00:15:12 <mmorrow> witchcraft!
00:15:14 <bd_> realWorld# may well be a value inhabiting State# RealWorld not accessible through a traditional constructor
00:16:13 <mmorrow> without the definition of State#, it very well may be that State# RealWorld /is/ inhabited
00:16:26 <bd_> data State# a   -- Defined in GHC.Prim
00:16:33 <bd_> of course, the real definition is deep within GHC
00:16:53 <bd_> just like Int# and all those other fun builtins
00:17:10 <mmorrow> all funcs in GHC.Prim are implem in C--
00:17:15 <mmorrow> directly
00:17:17 <bd_> indeed
00:17:21 <bd_> and the types in Compiler Magic
00:17:27 <mmorrow> hehe
00:17:32 <bd_> data Int#       -- Defined in GHC.Prim
00:17:38 <bd_> ^^^ the only integer is undefined \o/
00:18:02 <mmorrow> data Int = I# Int#
00:21:54 <mmorrow> i find this file amusing to browse: http://darcs.haskell.org/ghc/rts/PrimOps.cmm
00:22:27 <mmorrow> i seem to remember a blog post about "adding your own primop" to ghc
00:23:46 <mmorrow> i guess all you'd have to do other than implem it in PrimOps.cmm is find where else in GHC the primops are listed and add it to those lists
00:26:04 <lispy> I want a primop that always segfaults
00:26:45 <lispy> i'm sure you could easily implement this by jsut calling the signal raising code and pass segfault, but I want it as a primop :)
00:31:16 <mmorrow> peek nullPtr :: IO Int -- ??
00:31:30 <mmorrow> ooh, even better:
00:31:45 <mmorrow> unsafePerformIO (peek nullPtr::IO Int)
00:32:16 <lispy> > unsafePerformIO (peek nullPtr::IO Int)
00:32:17 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `peek'Not in scope: `nullPtr'
00:32:27 <mmorrow> this works too:
00:32:28 <mmorrow> ghci> unsafeCoerce 0 :: ([a],[a])
00:32:28 <mmorrow> (Segmentation fault
00:33:07 <lispy> ?index unsafePerformIO
00:33:07 <lambdabot> System.IO.Unsafe, Foreign
00:33:21 <mmorrow> ghci> unsafePerformIO (peek nullPtr::IO Int)
00:33:21 <mmorrow> Segmentation fault
00:33:26 <lispy> ?index peek
00:33:27 <lambdabot> Foreign.Storable, Foreign
00:33:49 <lispy> $ ghc -e 'Foreign.unsafePerformIO (Foreign.peek Foreign.nullPtr::IO Int)'
00:33:49 <lispy> Bus error
00:33:56 <mmorrow> haha
00:34:14 <mmorrow> $ ghc -e 'Foreign.unsafePerformIO (Foreign.peek Foreign.nullPtr::IO Int)'
00:34:14 <mmorrow> Segmentation fault
00:34:18 <lispy> Not to be confused with truck and car errors
00:34:20 <mmorrow> what OS are you on?
00:34:24 <lispy> osx
00:34:28 <mmorrow> ah
00:34:41 <lispy> solaris also gives bus errors
00:34:45 <lispy> but maybe not for this
00:35:00 <lispy> I don't recall ever getting a bus error on linux x86
00:35:13 <mmorrow> yeah, i don't believe i have either
00:35:40 <mmorrow> i had to do some opengl in C though on osx and i rode the bus plenty then
00:36:08 <lispy> heh
00:36:34 <lispy> well, so i'm using xmonad now
00:36:41 <mmorrow> ooh, cool
00:37:08 <lispy> but I can't really use it, because on my mac the modifer key doesn't work for any of the standard config :)
00:37:09 <mmorrow> how are you doing it on top of osx?
00:37:18 <lispy> you run x11
00:37:21 <mmorrow> via X or
00:37:22 <mmorrow> ah
00:37:35 <lispy> I'm using urxvt inside xmonad, which is nice
00:37:39 <mmorrow> i tried that at one point but only briefly
00:37:44 <mmorrow> (X on osx)
00:37:57 <mmorrow> i don't have a mac anymore either
00:38:00 <lispy> If I could get the modifier keys to work the way they do for others on osx, i could actually use it realisticly
00:38:07 <lispy> Right now it's just a nice manager for my terminals
00:38:13 <mmorrow> i'm sure there has to be a way
00:38:33 <mmorrow> it may be at a lower level than X though :)
00:38:43 <lispy> Someone suggested I downgrade my x11 to one that is verfied to work (you can have both x11 on one machine)
00:38:52 <lispy> oh, native xmonad?
00:39:22 <lispy> you can use apple script to move and resize windows
00:39:28 <mmorrow> err, i was thinking along the lines of hacking something that has to do with the codes coming off the keybd
00:39:31 <lispy> likely you'd still have decorations to deal with though
00:39:40 <lispy> ah
00:39:48 <lispy> I tried all kinds of thngs with xmodmap tonight
00:39:50 <mmorrow> i don't know if you'd be "hacking" anything though on osx
00:40:03 <lispy> Like turning keypad enter into a modifier key and then trying to use it
00:40:49 <mmorrow> hmm, i don't think i understand what's happening nor how you want it to be
00:41:03 <lispy> really if I could resize the tiles with my mouse then I'd still enjoy the experience
00:41:09 <mmorrow> what do you mean "get the modifier keys to work the way they do for others on osx"
00:41:22 <mmorrow> ?
00:41:23 <lispy> Well, anything that uses mod doesn't work for me
00:41:42 <lispy> so creating new terminals, moving the focus with keyboard, resizing tiles, etc
00:41:47 <mmorrow> hmm, i guess that's an issue with X?
00:41:57 <lispy> probably
00:42:10 <lispy> I can run xev and see when I press various keys
00:42:11 <mmorrow> oh, an earlier version worked.. i guess something got changed?
00:42:28 <lispy> and I can tweak settings to either have osx intercept those keys or let them through, but regardless xmonad doesn't see them
00:42:46 <mmorrow> oh i see
00:43:04 <lispy> So the x11 tha came with OSX 10.5 doesn't support full screen
00:43:05 <mmorrow> so an issue with xmonad then
00:43:16 <lispy> So one person said they installed the x11 from 10.4 and used that instead
00:43:33 <lispy> and that person didn't have any problems with the keys
00:43:45 <lispy> So...my hypothesis is that maybe the newer x11 is wonkey
00:43:45 <mmorrow> lispy: ohhh yeah. i remember there being two diff X11s when i had it on my powerbook. one sucked and one didn't
00:43:58 <mmorrow> can't remember where the non-sucky one was from though
00:44:04 <quicksilver> OSX x11 is an open source project (xquartz) - you might be able to get support from http://www.google.com/url?sa=t&source=web&ct=res&cd=1&url=http%3A%2F%2Fxquartz.macosforge.org%2F&ei=vQgMSfvDGZvI0gSd78SoBA&usg=AFQjCNH0hnj5-cCCw9O_G09cwE_k_dspOQ&sig2=a8nXnG30tpQpQd6jbVROSg
00:44:07 <lambdabot> Title: XQuartz – Trac, http://tinyurl.com/5w4sm2
00:44:14 <quicksilver> sorry for stupid google url.
00:44:18 <mmorrow> heh
00:44:21 <quicksilver> it's the right link in the end.
00:44:22 <lispy> I'm still burned out from all the customizations I've done over the years and I'm reluctant to install x11
00:44:47 <quicksilver> there's probably some simple (compile-time maybe?) option to get the old config back
00:45:10 <lispy> this version has a checkbox for full screen, it's just perma greyed out
00:45:15 <lispy> which is funny and stupid
00:46:23 <lispy> If I were on a linux box I would be trying harder :)
00:46:58 <mmorrow> haha, that's like having a button for "do what i want immediately", but it's broken
00:47:38 <quicksilver> GHC has a button for 'solve halting problem' but it takes forever to click
00:47:42 <mmorrow> and it just sits there next to the shift key taunting you
00:47:49 <mmorrow> quicksilver: hehe
00:48:08 <lispy> quicksilver: ah, I just thought it was getting stuck down
00:48:24 <mmorrow> that's what THEY want you to think
00:49:12 <lispy> heh, actually, I recall something my algorithms prof said once.  He said, "It's actually pretty easy to writing a program that can solve the halting problem.  Just let yourself be wrong some of the time.  Of course that's not an algorithm anymore..."
00:49:55 <mmorrow> it's an algorithm for being correct part of the time :)
00:50:12 <mmorrow> and at which it succeeds!
00:50:26 <sjanssen> I think the correct ending is "Of course that's not a solution to the halting problem anymore"
00:51:01 <mmorrow> those algorithm profs and their mind games..
00:51:06 <lispy> yeah
00:51:34 <lispy> IIRC, he was saying just define it like this halt = const True
00:53:13 <lispy> ?pl \x y z -> x
00:53:13 <lambdabot> const . const
00:53:18 <lispy> ?pl \x y z w -> x
00:53:18 <lambdabot> const . const . const
00:53:28 <lispy> :t const . const . const . const
00:53:29 <lambdabot> forall b b1 b2 a b3. a -> b -> b1 -> b2 -> b3 -> a
00:53:36 <lispy> That's nice
00:53:54 <lispy> for some reason I was thinking you'd have to do some crazy stuff with (const .) . const
00:54:00 <lispy> :t (const .) . const
00:54:01 <lambdabot> forall b a a1. a1 -> a -> b -> a1
00:54:33 <lispy> :t (const .) . (const .)
00:54:34 <lambdabot> forall b b1 b2 a. (a -> b1) -> a -> b -> b2 -> b1
00:54:57 <lispy> :t (const .) . (const .) . const
00:54:58 <lambdabot> forall b b1 a a1. a1 -> a -> b -> b1 -> a1
00:55:24 <lispy> ?free conster :: a1 -> a -> b -> b1 -> a1
00:55:24 <lambdabot> f . conster x y z = conster (f x) (g y) (h z) . k
00:56:33 <lispy> I wonder why it bothers with (g y) and (h z)
00:56:54 <lispy> f . conster x y z = conster (f x) y z . k, right?
01:02:52 <sjanssen> bwha?
01:03:06 <sjanssen> conster == cookie monster?
01:09:42 <mmorrow> cookiecookiecookieo...
01:13:48 * ivanm gives mmorrow a biscuit
01:16:39 * sjanssen wishes the OOM killer was a bit more agressive
01:18:06 <dmwit_> Give yourself less swap space.
01:18:14 <sjanssen> hmm
01:18:28 <sjanssen> I actually use the swap though
01:18:37 <sjanssen> I should hunt down some RAM that will work in this box
01:18:52 <sjanssen> I only have 512MB, which is really the problem
01:20:22 <sjanssen> also, firefox uses way too much memory
01:20:30 <sjanssen> they should fix that
01:45:13 <Mzzz> @src IO
01:45:14 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
01:45:25 <vegai>     Could not find module `Text.XHtml.Internals':
01:45:26 <vegai>       it is hidden (in package xhtml-3000.0.2.1)
01:45:38 <vegai> can I fix this without cabal?
01:46:10 <C-Keen> Internals is not exported, is that what this message means?
01:46:40 <Mzzz> @src unsavePerformIO
01:46:41 <lambdabot> Source not found. Take a stress pill and think things over.
01:47:06 <Mzzz> @src unsaveperformIO
01:47:06 <lambdabot> Source not found. It can only be attributed to human error.
01:47:16 <vegai> @src unsafePerformIO
01:47:16 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
01:47:42 <vegai> C-Keen: No, I think it's some sort of library screwup
01:47:50 <vegai> or let's say, library feature
01:48:32 <Mzzz> vegai: thanks
01:48:35 <vegai> defining -package xhtml on the ghc line at least doesn't do it
01:49:20 <mmorrow> <sjanssen> also, firefox uses way too much memory
01:49:45 <Axman6> @src lazy
01:49:45 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:49:49 <mmorrow> firefox is a friggin obese filthy hog that needs to be put down
01:50:02 <Axman6> mmorrow: indeed
01:51:48 <C-Keen> please help the dillo project! :)
01:54:29 <mmorrow> hmm
01:54:46 <mmorrow> C-Keen: about how many lines of code would you say dillo is?
01:55:03 * mmorrow is in the process of getting the cvs srcs
01:56:52 <mmorrow> 59429
01:57:00 <mmorrow> loc
01:58:07 <mmorrow> we need a haskell browser
01:58:16 <C-Keen> mmorrow: its design goal is speed and small memory footprint. It still needs a lot of work but I think this is the most promising browser project out there. And the people are very nice as well :)
01:58:35 <mmorrow> C-Keen: it looks nice. i'm gonna build it and check it :)
01:58:47 <mmorrow> *check it out
01:59:00 <C-Keen> mmorrow: have a look at your distribution package it probably already got updated to dillo2
01:59:15 <mmorrow> ooh
01:59:41 <C-Keen> or grab the binary that may be faster to get a first impression
02:00:31 <mmorrow> dillo.i386                               0.8.6-4.fc8            fedora
02:00:51 <vegai> oh well, I can just scratch that Internals import since it was only for defining a type
02:01:15 <mmorrow> vegai: or get the xhtml src, hack it, and include it in your proj :)
02:04:55 <mmorrow> aww, dillo can't render hpaste or hpaste2 :(
02:06:15 <C-Keen> mmorrow: CSS is currently worked on
02:06:15 <mmorrow> oh, n/m i was using the i18n version
02:06:28 <C-Keen> mmorrow: so yes it will look ugly for now
02:06:30 <mmorrow> yeah, the regular version rendered it, but w/out css
02:06:33 <mmorrow> heh
02:06:38 <mmorrow> whatev
02:07:20 <mmorrow> it's definitely nice and fast
02:08:15 <C-Keen> mmorrow: if you find some bugs please take 10 minutes of your precious time and write to the dillo-dev list
02:08:23 <mmorrow> will do :)
02:08:32 <C-Keen> thanks!
02:08:50 <C-Keen> the world needs a webbrowser that does that one thing well
02:09:42 <jeffz> I thought about writing a browser in Haskell, except not bothering to support any of the current standards, because that would be boring.
02:11:45 <mmorrow> hehe, totally. i just want to be able to have stuff rendered, javascript runtime that doesn't suck and is controllable by haskell code, and last and most importantly dynamic eval of haskell code :)
02:12:02 <stevan> browser written in haskell: http://www.cs.chalmers.se/~hallgren/wwwbrowser.html
02:12:06 <lambdabot> Title: Welcome to WWWBrowser!
02:12:29 <mmorrow> innnteresting..
02:58:15 <Taejo> @pl comb f g (a, c) b = (f a b, g c b)
02:58:15 <lambdabot> comb = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . liftM2 (,)) .)
02:59:11 <Taejo> @pl comb' f g (a, c) = (f a, f c)
02:59:12 <lambdabot> comb' = const . (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
02:59:19 <Taejo> @pl comb' f g (a, c) = (f a, g c)
02:59:20 <lambdabot> comb' = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
02:59:37 <Taejo> @src (***)
02:59:37 <lambdabot> f *** g = first f >>> second g
03:02:44 <Taejo> @pl comb f g (a, c) b = (($ b) *** ($ b)) (f *** g) (a, c)
03:02:45 <lambdabot> comb = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (,) . (((.) . (.) . flip . flip (ap ((***) . flip id) (flip id))) .) . (***)
03:02:55 <cnwdup> What's the benefit from having *many* callbacks having the return type IO a? I mean, why isn't it more general?
03:08:37 <regularfry> Morning all
03:09:14 * ivanm looks outside his wind
03:09:19 <regularfry> Anyone using the 6.8.3 installer on Windows?  I'm having a file include problem
03:09:20 <ivanm> kinda dark to be morning... ;-)
03:09:25 <regularfry> :-)
03:09:27 <ivanm> *window
03:09:42 <regularfry> Not over here.  Sun's not over the yard-arm yet :-)
03:10:20 <ivanm> heh
03:11:12 <regularfry> Do you know if anything was changed between 6.8.2 and 6.8.3 with C header file inclusion?
03:11:52 * ivanm has no idea
03:12:00 <ivanm> I try and avoid M$ nowadays ;-)
03:12:12 <regularfry> Don't blame you :-)
03:12:58 <regularfry> Still, this output is a litle odd:
03:13:10 * Axman6 is pretty proud of the fact that his family's never owned a windows PC (for more than an hour or so until it could be wiped and have a BSD installed
03:13:12 <regularfry> PS C:\Users\Alex\Documents\Plugins\HelloWorld.all\LWSDK-1445\source> ghc -I../include
03:13:12 <regularfry> ghc.exe: unrecognised flags: -I
03:13:12 <regularfry> Usage: For basic information, try the `--help' option.
03:13:45 <ivanm> Axman6: did you ever get your M$ tax refunds?
03:13:59 <pozic> regularfry: that's because it's -i
03:14:06 <ivanm> heh, was about to say...
03:14:11 <Axman6> ivanm: only comp that came windows was given to me :)
03:14:25 <ivanm> ahhh
03:14:47 <regularfry> I guess the docs haven't been updated then...
03:14:53 <regularfry> Thanks :-)
03:14:55 <pozic> regularfry: ?
03:15:02 <pozic> regularfry: docs are fine here.
03:15:23 <regularfry> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#forcing-options-through says -I
03:15:25 <lambdabot> Title: 5.10.�Options related to a particular phase, http://tinyurl.com/smq5n
03:15:50 <pozic> regularfry: you failed the reading lesson.
03:16:03 <pozic> regularfry: 5.10.3. Options affecting the C pre-processor
03:16:23 <pozic> regularfry: if you indeed want to use the C pre-processor, you need to communicate that first.
03:16:44 <pozic> regularfry: otherwise it probably won't recognize -I
03:17:22 <regularfry> PS C:\Users\Alex\Documents\Plugins\HelloWorld.all\LWSDK-1445\source> ghc -c -optc -I C:\Users\Alex\Documents\Plugins\HelloWorld.all\LWSDK-1445\include servmain.c
03:17:23 <regularfry> servmain.c:5:22:  lwmodule.h: No such file or directory
03:17:40 <regularfry> That file and directory definitely exist.
03:17:55 <regularfry> Have I missed something?
03:18:04 <Deewiant> maybe leave out the space after -I
03:18:28 <regularfry> Same error
03:18:44 <pozic> Does this hold for Doubles a and b? a <= b && not a<b => a = b
03:19:05 <pozic> Ignore the lack of a paren.
03:20:27 <regularfry> Erm...  Doubles are backed by IEEE fp, yes?
03:20:30 <Deewiant> not if a is zero and b is negative zero
03:20:47 <Deewiant> if by '=' you meant 'are the same'
03:20:48 <pozic> regularfry: yes
03:20:50 <regularfry> Or if you've got NaNs floating around.
03:20:56 <Deewiant> NaNs are fine
03:21:11 <Deewiant> the implication holds in that direction with NaNs, I think
03:21:33 <Deewiant> because if either is NaN, the left hand side will be false
03:21:50 <pozic> Deewiant: I already make sure no NaN enter the computation.
03:21:58 <pozic> Deewiant: thanks
03:22:13 <regularfry> Don't they compare oddly?  I may be misremembering.
03:22:31 <Deewiant> pozic: I think the only case for which that doesn't hold is zero/negative zero
03:22:39 <Deewiant> regularfry: they always compare false with anything, basically.
03:22:45 <Deewiant> including each other.
03:22:51 <pozic> Deewiant: yes, but that case "won't ever happen".
03:23:44 <regularfry> Sorry, I'm being an idiot.  Don't mind me :-)
03:23:48 <inad923> hello
03:24:08 <pozic> hello
03:24:20 <inad923> is there any gui library for haskell thats not a wrap of some other(gtk, qt, etc.) but written in haskell from start?
03:25:02 <pozic> Maybe Fran?
03:25:11 <pozic> But nothing that currently works, AFAIK.
03:25:30 <dmwit> Now would be a good time to ask *why* you want this question answered.
03:25:35 <pozic> Also, it is the question whether that's a good thing.
03:25:35 <laziest> inad923: why GUI, even putChar is a wrap! (kidding)
03:26:01 <Taejo> @src foldl
03:26:01 <lambdabot> foldl f z []     = z
03:26:01 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:26:05 <inad923> Im just curious thats why I asked
03:29:11 <inad923> actually handling widget structures like any other tree-graph like data structures is much more straightforward in a functional language thats why I was curious about it
03:29:46 <Peaker> widget structure is probably a tree, not a DAG
03:31:36 <pozic> Peaker: information flow between components is a graph, however.
03:36:25 <Taejo> can RULES cause GHC to turn function definitions into loops? (e.g., if I have a function f x = g x, and a rule g x = f x, will the defn of f be changed to f x = f x)?
03:36:41 <pozic> Taejo: AFAIK, yes
03:36:43 <laziest> Taejo: I think so
03:37:05 <Taejo> thanks
03:37:11 <Deewiant> and if you have both of those as rules then GHC will likely loop ;-)
03:37:12 <pozic> Taejo: otherwise you could use it to solve the Halting problem.
03:37:53 <Taejo> Deewiant: there's only one rule. it's the program that will loop, not GHC
03:38:03 <Deewiant> Taejo: yes, hence 'if'.
03:38:58 <Taejo> Deewiant: ok
03:44:19 <pozic> According to blog posts GHC can do that, but YMMV. ;)
03:46:58 <Axman6> > let f x = f x in f 3
03:47:14 <lambdabot>   thread killed
03:47:31 <vixey> > let f x = f (():x) in f []
03:47:51 <lambdabot>   thread killed
03:48:35 <Axman6> :t ()
03:48:39 <lambdabot> ()
03:48:59 <Axman6> :t fx = f (():x)
03:49:01 <lambdabot> parse error on input `='
03:49:04 <Axman6> :t f x = f (():x)
03:49:06 <lambdabot> parse error on input `='
03:49:10 <Axman6> bah
03:49:17 <Deewiant> :t let f x = f (():x) in f
03:49:19 <lambdabot> forall t. [()] -> t
03:50:13 <vixey> where did f x = f x in f 3 come from?
03:51:17 <Taejo> @src sum
03:51:17 <lambdabot> sum = foldl (+) 0
03:51:29 <Taejo> why not foldl'?
03:55:20 <Taejo> :t (flip const (+1))
03:55:21 <lambdabot> forall a. a -> a
03:55:32 <Saizan_> Taejo: in haskell98 they didn't care too much about strictness
03:55:39 <Taejo> Saizan_: ok
03:55:40 <vixey> :t fix . flip const
03:55:41 <lambdabot> forall a a1. a1 -> a
03:55:53 <vixey> :t fix (flip const)
03:55:54 <lambdabot> forall a. a -> a
03:56:01 <Taejo> @pl (\ x y -> x + 1)
03:56:02 <lambdabot> const . (1 +)
03:58:04 <Axman6> @unpl fix (flip const)
03:58:04 <lambdabot> fix (\ b c -> c)
03:58:58 <ivanm> is there a guide or something on how to write up an HCAR entry?
04:01:32 <pozic> ivanm: plain text is OK, use LaTeX to make them happy, don't make it too long, don't reiterate stuff from previous HCARs. I think that's it.
04:01:47 <ivanm> pozic: *nod*
04:06:11 * Peaker just tested the security measures of codepad, heh
04:06:54 <Peaker> they use only OS-level security, not language-level, so its much less interesting.. Some kind of system call blocker ("Disallowed system call: SYS_exit")
04:07:51 <pozic> Peaker: why would it not be secure?
04:08:11 <Peaker> pozic: because the world is full of people more confident than they should be? :)
04:08:19 <Peaker> (in this case, I was the one, maybe :-)
04:08:47 <pozic> Peaker: sure, it probably isn't secure, but constructing a proof that it isn't is a different matter.
04:09:34 <pozic> Also, the Web is inherently "insecure".
04:09:57 <pozic> Anyone can DDoS you at any time.
04:10:27 <pozic> (which is easy to solve it theory, but for a cost reason probably isn't done in practice)
04:10:33 <pozic> in*
04:10:40 <Peaker> pozic: it might be secure, I think, its a very limited/kind-of-useless sandbox. It seems they simply disallow all syscalls except write (for stdout), and I don't think any authority arises from just having access to run instructions.  Unless they left some authority in the form of FD's in there, or have glitches in the output handling on the web side, its probably secure
04:11:08 <Peaker> pozic: DoS is not an interesting attack, though
04:11:49 <pozic> Peaker: from a practical point of view it is, otherwise no.
04:16:26 <Taejo> do I need a language pragma for existential types?
04:17:39 <vixey> well there isn't one, but RankNTypes may be useful
04:21:18 <Taejo> lambdabot's given up on announcing hpastes?
04:21:32 <Taejo> why am I getting a parse error in http://hpaste.org/11659 ?
04:22:55 <RayNbow> Taejo: actually, there was a different bot that announced hpastes iirc
04:23:33 <Taejo> ok, I never really noticed
04:25:40 <RayNbow> @seen hpaste
04:25:40 <lambdabot> I haven't seen hpaste.
04:25:46 <RayNbow> lambdabot's suffering from amnesia
04:27:43 <Saizan_> @hoogle ExistentialQuantifiaction
04:27:44 <lambdabot> No results found
04:27:49 <Saizan_> @hoogle ExistentialQuantification
04:27:50 <lambdabot> Distribution.Extension ExistentialQuantification :: Extension
04:27:50 <lambdabot> Language.Haskell.Extension ExistentialQuantification :: Extension
04:28:11 <Taejo> :( LHS must be of form (f e1 .. en) where f is not forall'd
04:28:23 <Taejo> that makes me very sad
04:28:37 <Taejo> since it basically blows my whole framework out of the water
04:28:54 <Badger> :o
04:30:47 <vixey> perhaps you can write this program without using RULES
04:31:43 <Taejo> vixey: the framework is to fuse multiple folds (so that sum biglist / (fromIntegral $ length biglist) runs in constant space)
04:32:04 <Taejo> so in this case the pattern matches on (/)
04:32:12 <vixey> You can do this with attribute grammars
04:32:33 <Taejo> vixey: what are those?
04:32:45 <vixey> ?go Why Attribute Grammars Matter
04:32:48 <lambdabot> http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter
04:32:48 <lambdabot> Title: WhyAttributeGrammarsMatter - TmrWiki
04:50:07 <cnwdup> > (printf "%s %d %d") :: String
04:50:08 <lambdabot>   "* Exception: Printf.printf: argument list ended prematurely
04:53:04 <Taejo> how do I dump the optimised Core of a file?
04:59:51 <Saizan_> Taejo: -ddump-simpl
05:00:35 <Taejo> Saizan_: thanks
05:10:02 <evident> how do i write a function in Haskell that compares the elements of an array and returns True, if all elements are equal?
05:10:12 <evident> would be great if you could help me
05:11:55 <Taejo> is there a guide to reading Core somewhere?
05:12:31 <evident> what does that mean? "Program error: pattern match failure: head [] "
05:12:54 <Taejo> evident: it means you called "head []"
05:13:53 <evident> well thats my function:
05:13:54 <evident> allEqual :: Eq a => [a] -> Bool allEqual a 	| head a == head ( tail a ) = allEqual ( tail a ) 	| otherwise = False
05:14:15 <evident> http://www.mibbit.com/pb/p15iFG
05:14:16 <lambdabot> Title: Mibbit: PasteBin
05:14:19 <evident> :D
05:15:05 <hukolele> u need the case: if it is an empty list
05:15:25 <Taejo> evident: you probably also want to learn about pattern matching
05:15:47 <Taejo> and note that lists and arrays are different
05:15:51 <hukolele> > head []
05:15:52 <lambdabot>   * Exception: Prelude.head: empty list
05:17:16 <evident> well I think I need to build in that if the tail of the list is an empty list that it then stops and returns true, otherwise it will never know that it reached the end of the list, right?
05:17:50 <pozic> evident: f [] = True; f (x:xs) = all (==x) xs
05:18:17 <Taejo> evident: sounds good
05:18:22 <pozic> evident: cannot be done much easier
05:18:41 <evident> thats the whole function?
05:18:45 <pozic> evident: yes
05:18:49 <evident> wow
05:18:52 <evident> I'll try
05:19:34 <hukolele> i have a question: is it possible to serialize functions?? with template haskell or generics or somewhat? where can i find informatioon about that?
05:20:00 <Taejo> hukolele: dynamically created functions?
05:20:21 <hukolele> mmm, dynamically? how?
05:20:41 <hukolele> something like: serialize (\x -> x)
05:20:48 <hukolele> or serialize flip
05:21:13 <evident> pozic could you please explain how this function works? like step by step? as I understand: First it checks whether the list is empty -> if it is -> return True ... and then?
05:21:18 <Taejo> hukolele: that's what I mean... you don't just want to serialize functions you've explicitly defined?
05:21:24 <evident> the (x:xs) simply means it is a list, right?
05:21:36 <hukolele> and getting a stream deserializable into the function
05:21:52 <Taejo> evident: are you learning Haskell from a tutorial? if so, look up pattern matching
05:21:53 <pozic> hukolele: something like main = do f <- readFile ; serialize (++ f), I think.
05:21:54 <hukolele> i think all the functions are statically defined, am i wrong?
05:22:24 <Taejo> hukolele: maybe dynamic wasn't the best word
05:22:39 <evident> well I'm just not familia with the "all (==x) xs"
05:22:43 <pozic> hukolele: Taejo meant variables from the environment.
05:22:52 <pozic> @src all
05:22:52 <lambdabot> all p =  and . map p
05:23:03 <pozic> evident: ^^
05:23:07 <Taejo> > all (==1) [1, 1, 1]
05:23:09 <lambdabot>   True
05:23:10 <Taejo> > all (==1) [1, 1, 2]
05:23:11 <lambdabot>   False
05:23:20 <evident> ahhh!!!!!
05:23:20 <Taejo> evident: got it?
05:23:24 <pozic> evident: why are you asking these questions?
05:23:30 <pozic> evident: what's your immediate goal?
05:23:37 <evident> now i understand
05:23:52 <evident> i just wanted to understand how the function worked that you posted... :)
05:23:53 <hukolele> i tryed with template haskell but reify cant escape to the IO
05:24:02 <pozic> evident: are you a student?
05:24:20 <evident> yeah I am studying computer visualistics in Germany
05:24:24 <hukolele> and typeOf is throwing me an error trying to do typeOf flip
05:24:25 <evident> and now they started with Haskell
05:24:32 <Saizan_> hukolele: happs kind of serialize some toplevel functions essentially by storing the name and using a lookup table when loading
05:24:35 <evident> I'm better in Java and C, C++, C#
05:24:54 <evident> but i am having some difficulties with Haskell yet... :)
05:25:05 <Saizan_> hukolele: in general there's no support for serializing functions
05:25:10 <Saizan_> > typeOf flip
05:25:11 <lambdabot>   Add a type signature
05:25:13 <evident> thanks everybody
05:25:20 <mapreduce> evident: Do you use delegates much in C#?
05:25:22 <pozic> evident: if you want to get a good grade, you should simply buy a few Haskell books, and read them.
05:25:44 <hukolele> ill see happs... thx
05:25:55 <hukolele> how is done in happs
05:26:05 <evident> Well i got "Programming in Haskell" from Graham Hutton from the university libray, but I havent read much of it yet... :)
05:26:11 <evident> but i will
05:26:36 <BONUS> do read it, its a v good book
05:27:56 <pozic> evident: you are lucky.
05:28:09 <pozic> evident: there is an abundance of bad Haskell books out there.
05:28:13 <pozic> evident: that is not one of them.
05:28:50 <mapreduce> I've seen a small amount of evidence that forcing Haskell upon someone in a Uni course can be detrimental; that they see it as unnecessarily hard and never touch it again.
05:28:52 <Cale> There's an abundance of Haskell books at all?
05:28:56 <mapreduce> By small I mean one person.
05:29:07 <pozic> Abundance is a bit overstated.
05:29:08 <vixey> mapreduce: And these people would have, otherwise, loved haskell? :)
05:29:14 <mapreduce> Clearly.
05:29:18 <mapreduce> :)
05:29:53 <Taejo> @src (++)
05:29:53 <lambdabot> []     ++ ys = ys
05:29:53 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:29:53 <lambdabot> -- OR
05:29:53 <lambdabot> xs ++ ys = foldr (:) ys xs
05:29:59 <RayNbow> pozic: which books do you consider bad?
05:30:00 <pozic> Haskell has a tools problem and there are some things that could use a better implementation.
05:30:12 <mapreduce> My ex-boss had a course where (predating Haskell) they used a different language each week to produce something.
05:30:30 <mapreduce> He had the idea that each and every one of these was a toy, which is a shame.
05:31:19 <pozic> Slava Pestov seems to understand this and he acted upon it. I wouldn't be surprised if Factor would be more popular in 5 years than Haskell because of that, if nothing changes.
05:34:38 <pozic> He is a bit secretive as to why he developed Factor, though.
05:36:07 <Cale> pozic: What tools do you think Haskell is missing?
05:36:56 <Deewiant> Cale: the most common complaints are probably about a decent debugger and profiler.
05:37:12 <Cale> Deewiant: There's an excellent profiler in GHC.
05:37:36 <Deewiant> I'm just the messenger, that's what it seems like people are mostly complaining about :-)
05:37:50 <Deewiant> I'm perfectly happy with printf debugging too
05:37:52 <Cale> So maybe it's more about the tools people don't know they already have?
05:38:27 <Cale> I've actually been reasonably convinced through my use of Haskell that a classical debugger is unnecessary.
05:38:30 <Saizan_> factor has a very nice interpreter it seems, UI-like
05:38:34 <Cale> But ghci has one.
05:38:44 <Cale> (perhaps it could improve)
05:40:40 <pozic> Cale: code browsing
05:40:50 <pozic> Cale: integrated documentation
05:42:05 <Saizan_> yeah, we need someone building a nice GUI over the ghc-api, hoogle and haddock
05:42:47 <Saizan_> or put this in Yi
05:42:55 <pozic> Hoogle doesn't work on an inmemory representation of what functions are defined.
05:43:00 <pozic> in-memory*
05:43:17 <vixey> is Yi useful?
05:43:24 <pozic> It should be integrated with some Haskell interpreter.
05:43:28 <Cale> vixey: It's getting there.
05:43:33 <noZone> ... or Yemacs.
05:43:34 <pozic> I.e. a meta-circular design.
05:44:02 <Saizan_> pozic: i think you can base that on the ghc-api
05:44:07 <pozic> That should be possible now with the GHC API, but there is the perception that it is non-trivial.
05:44:19 <pozic> In Factor, the perception is that it is easy.
05:46:12 <Saizan_> since it's already done or?
05:48:26 <pozic> Saizan_: since not many people have used the GHC API, and thus probably has rough edges.
05:49:30 <pozic> It should be absolutely positively clear what any function in the GHC API does (I haven't looked at it in a while, so things might have changed already).
05:50:58 <jeffz> pozic: I heard that slava originally created factor for use in a java game
05:51:49 <pozic> jeffz: yes, I heard that too, but his goals are different now.
05:52:33 <pozic> Saizan_: One of the first hits at Google: http://www.haskell.org/haskellwiki/GHC/As_a_library
05:52:34 <lambdabot> Title: GHC/As a library - HaskellWiki
05:52:57 <pozic> Saizan_: that doesn't sound like something someone would want to use.
05:55:22 <Cale> pozic: why?
05:55:42 <Saizan_> pozic: there are already higher-level wrapper libraries like hint if you don't want full control
05:56:50 <Saizan_> however that code snippet doesn't look bad for what it does
05:57:36 <pozic> Saizan_: no, but there isn't even a working link to the API.
05:58:37 <Cale> I don't think the GHC API is haddocked.
05:58:55 <Saizan_> it is, but maybe they're waiting the final release of 6.10?
05:59:18 <Cale> Ah, so that's a major change then...
05:59:33 <pozic> Saizan_: that has been said since a few version before. The reality is that nobody gets paid to document. They get paid to do research.
05:59:55 <Taggnostr> is there something like a python's dict in haskell or I can just use a list of 2-tuples?
06:00:02 <Cale> Taggnostr: Use Data.Map
06:00:25 <Cale> pozic: Actually the documentation is quite good, much of GHC is written as literate scripts.
06:00:25 <pozic> versions*
06:00:55 <Cale> pozic: However, it still might be inadequate, since GHC is rather large and complex.
06:02:06 <Cale> Also, being paid to research *is* being paid to document, to a fair extent. :)
06:02:40 <pozic> Cale: and there we have code browsing issues again.
06:03:01 <Cale> I don't think a code browser would help much.
06:03:45 <Cale> At least, it wouldn't answer the sorts of questions I would have about the code.
06:03:59 <Cale> I'm perfectly fine with grep for finding my way around in that sense.
06:04:28 <pozic> I use a modified grep for my searches, but I hate it.
06:05:19 <Cale> What bothers you about it?
06:05:35 <Cale> I mean, how much time do you actually spend grepping for things?
06:05:52 <Cale> Usually I just grep to find the files which I'm interested in, and then read those.
06:06:23 <pozic> Cale: to find a symbol of my interest it takes about a minute from start to end.
06:07:01 <Cale> That's not so bad is it?
06:07:02 <vixey> I work that way too
06:07:08 <pozic> And.. this problem grows with the input size.
06:07:29 <vixey> you need to grep less and less as you learn the source code though
06:07:35 <pozic> (the size of the project) linearly
06:08:29 <Cale> While it might technically be linear, I don't think for practical input sizes it looks anything like linear time :)
06:08:59 <pozic> vixey: that wouldn't work with the Linux kernel where most lines are changed by others. (yes, I know the Linux kernel is still being developed, but there are tools for C that do work)
06:09:36 <vixey> I'm only talking about haskell code
06:14:44 <Cale> While I can see the value of a text editor feature for jumping to where a symbol has been defined in a bunch of files, it's not something that I particularly miss either.
06:15:07 <Cale> (If I actually did miss it, I'd probably use hasktags more often)
06:15:29 <vixey> I'd only want that if you could hack the code interactively, since you can't do that with haskell. I don't miss it either
06:15:42 <vixey> It's a great way to lisp but I don't think it even makes sense for haskell
06:15:48 <pozic> The problem with hasktags is that it doesn't keep track of what files changed.
06:15:55 <pozic> (compare again with Factor)
06:16:02 <Cale> Sorry?
06:16:05 <pozic> And that it isn't accurate.
06:16:19 <Cale> Oh, you mean since it was last run?
06:16:37 <pozic> Factor hooks into Linux kernel APIs on Linux and use a notifier system to only report those files that changed.
06:16:45 <pozic> An O(number of files changed) operation.
06:16:52 <pozic> Not O(all files in project)
06:17:04 <Cale> Does running hasktags actually take so much time that this matters?
06:17:23 <pozic> Cale: yes
06:17:32 <vixey> so fix hasktags :p
06:17:38 <vixey> it can't be that hard can it?
06:17:55 <pozic> Imho, hasktags is beyond repair, because it solves the wrong problem, as I have been trying to explain.
06:18:31 <Saizan_> as it is, do you have to run hasktags on all the files at once or does it work in "separate compilation + linking" mode?
06:19:54 <Cale> pozic: The problem isn't determining where each symbol is defined?
06:20:32 <pozic> Cale: yes, but hasktags is designed to be a tags like program. (I.e. a very stupid program with no understand of Haskell code).
06:21:04 <vixey> pozic: But you aren't interested in writing something better?
06:21:17 <Cale> Well, it would be trivial to write a better one, given that there are Haskell parsers.
06:21:22 <pozic> vixey: that depends on how much I will use Haskell in the future.
06:22:16 <mmorrow> pozic: http://moonpatio.com/docs/ghc/GHC.html
06:22:22 <mmorrow> pozic: http://moonpatio.com/docs/ghc/HscMain.html
06:22:22 <lambdabot> Title: GHC
06:22:23 <lambdabot> Title: HscMain
06:22:25 <mmorrow> pozic: http://moonpatio.com/docs/ghc/HscTypes.html
06:22:26 <lambdabot> Title: HscTypes
06:22:27 <mmorrow> ...
06:22:37 <mmorrow> pozic: http://moonpatio.com/docs/ghc/src/
06:22:38 <lambdabot> Title: Index of /docs/ghc/src
06:22:44 <mmorrow> (HsColour)
06:25:01 <pozic> mmorrow: that looks better than it did, but ParsedMod in not clickable not in the index.
06:25:19 <mmorrow> to build the ghc haddocks, you have to cd compiler/, copy a standard Setup.lhs into this dir, then comment out a CPP-to-be-replaced-macro-var in Config.lhs (or some file, the error msg from runhaskell Setup.lhs configure will tell you), change that to (e.g.) (42::Int), then runhaskell Setup.lhs && runhaskell Setup.lhs haddock && firefox dist/docs/;
06:25:33 <mmorrow> see, easy!!
06:25:45 <mmorrow> </sarcasm> :)
06:26:18 <mmorrow> hmm, ParsedMod is probably hidden then
06:26:21 * mmorrow checks
06:26:36 <pozic> "is not clickable in the index." Sorry about that.
06:26:37 <mmorrow> the best docs are the code at the moment
06:27:10 <mmorrow> ooh, be warned that going to the index page freezes my firefox for about a minute
06:28:01 * mmorrow loves the uncontrollable, and unkillable javascript in firefox
06:29:12 <mmorrow> pozic: i just saw the other day that there're haddocks up here too (and probably better than mine):
06:29:14 * mmorrow finds them
06:30:40 <mmorrow> pozic: ah. here (the official docs, including haddocks) http://www.haskell.org/ghc/dist/current/docs/
06:30:42 <lambdabot> Title: GHC Documentation
06:31:19 <pozic> mishok13: http://www.haskell.org/ghc/dist/current/docs/libraries/ghc/Parser.html
06:31:20 <lambdabot> Title: Parser, http://tinyurl.com/6o2ubk
06:31:24 <pozic> mmorrow: http://www.haskell.org/ghc/dist/current/docs/libraries/ghc/Parser.html
06:31:26 <lambdabot> Title: Parser, http://tinyurl.com/6o2ubk
06:31:35 <pozic> mmorrow: it took me 5 seconds to find that.
06:31:44 <mmorrow> heh, i love that
06:32:06 <mmorrow> ok, i'll build some haddocks for ghc with --ignore-all-exports
06:32:27 <pozic> It's more of a process problem: haddock is not integrated in the development environment in any meaningful way.
06:32:28 <mmorrow> so /everything/ in /every module/ (that has a type sig) will show up
06:33:07 <Cale> pozic: You can use cabal to produce haddocks.
06:33:09 <mmorrow> do you mean like having :info in ghci return comments with the full info of a name?
06:33:20 <Cale> (supposing that your project is cabalised)
06:33:38 <mmorrow> because other than that, :info covers pretty much everything haddock does (albeit one name at a time)
06:34:38 <mmorrow> pozic: but if you have some ideas for making haskell dev easier/more efficient i'd love to hear them :)
06:36:38 <mmorrow> runhaskell Setup.lhs && runhaskell Setup.lhs haddock && runhaskell Setup.lhs hscolour && firefox dist/doc/html/<pkg-name>/index.html && firefox dist/doc/html/<pkg-name>/src
06:36:48 <mmorrow> is a convenient shell script for me
06:36:50 <pozic> mmorrow: As an editor feature I mean that when you have your cursor for some time on a symbol, that it shows in the minibar the same as elisp doc does.
06:37:27 <mmorrow> that would be nice for sure. i think we all should make Yi amazing.
06:38:25 <vixey> I'm going to try out Yu
06:38:27 <vixey> Yi*
06:38:40 <Cale> mmorrow: cabal install can do that now
06:38:40 <mmorrow> here're some yi haddocks i built last time i built Yi (these haddocks are for the darcs version with extra stuff exposed in the docs by hand) http://code.haskell.org/~morrow/yi/yi.20080912-docs/
06:38:41 <lambdabot> Title: yi-0.4.4: The Haskell-Scriptable Editor
06:38:50 <jeffz> if Yi has an irc client like Emacs does, I'd consder using it
06:39:30 <Cale> mmorrow: I believe running  cabal haddock  from a project's directory will build the haddock for it.
06:39:43 <Cale> jeffz: heh
06:39:51 <mmorrow> jeffz: dang, all you'd have to do is write the "sugar" for it, since the connecting/blah code is written 100 times over for various ircbots
06:40:18 <mmorrow> probably could have a working first go at it in 2-3 hours tops
06:40:21 <vixey> put lambdabot in Yi!
06:40:22 <pozic> Meh, I have been a bit too smart last time I wrote this. I know it's correct, but I cannot remember why it's correct.
06:40:26 <vixey> we can all become lambdabots
06:41:12 <mmorrow> yeah, lambdabot has nice tools in it for sure.
06:41:38 <mmorrow> @pl, @unpl, @unmtl, ...
06:41:39 <lambdabot> (line 1, column 1):
06:41:39 <lambdabot> unexpected "@"
06:41:39 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
06:41:44 <mmorrow> heh
06:42:40 <mmorrow> i'm working on packaging the evaluator in lunabot also
06:43:11 <vixey> does it do let and data yet ?
06:43:16 <mmorrow> also, i'm trying to figure out how to be able to compile expression/decl directly to mach code dynamically
06:43:20 <mmorrow> heh, not yet
06:44:10 <mmorrow> (to mach code instead of to bytecode)
06:45:32 <mmorrow> it's most definitely possible i think (whole modules are easy, but it's not clear to me how to go about doing single expressions given the current env yet)
06:47:09 <vixey> mm
06:47:26 <vixey> I can't get GHC 6.11 without having already installed GHC can I?
06:48:08 <mmorrow> erm, if you mean build it yeah, you need ghc to build ghc
06:48:58 <mmorrow> just grab the newest binary version you can find and bootstrap (are you on a weird machine or something?)
06:49:52 <ivanm> what would you call the a, b, etc. used in polymorphic type signatures?
06:49:55 <ivanm> type variables?
06:49:59 <mmorrow> yes
06:50:20 <ivanm> thanks mmorrow
06:50:42 <mmorrow> np
06:51:57 <Baughn> Type parameters, surely. They don't actually vary
06:52:30 <vixey> oh no, they are type arguments
06:53:08 <Baughn> They don't argue, either. ;_;
06:53:17 <Saizan_> you see them called type varibles almost everywhere
06:53:25 <Saizan_> "variables"
06:55:07 <pozic> x = 1; -- x is a variable, but does not vary.
06:56:53 <Baughn> x = 1; -- x is a binding, and does not vary
06:57:04 <jeffz> I was just about to say the same thing.
06:57:11 <vixey> can I test ghc before installing it though ?
06:57:20 <pozic> @go Mathematical variable
06:57:20 <vixey> I don't want to install all this stuff with it not working..
06:57:22 <lambdabot> http://en.wikipedia.org/wiki/Variable
06:57:23 <lambdabot> Title: Variable - Wikipedia, the free encyclopedia
06:57:35 <Baughn> vixey: Try installing it in some other prefix
06:58:11 <vegai> just relax and call the type thingies
06:58:34 <vegai> warm fuzzy type thingies
06:59:01 <pozic> I was actually going to start a Global Thermal Nuclear war over this.
06:59:05 <pozic> ;)
06:59:30 * Saizan_ read that as Goedel Thermal Nuclear war
06:59:59 <Baughn> Saizan_: OKay. No more math for you.
07:00:41 <vegai> pozic: there'll be no launching of missiles here!
07:00:59 <ivanm> not safely, anyway...
07:01:06 <Baughn> unsafeLaunchMissile?
07:01:22 <Baughn> unsafeLaunchMissile :: IO World -> ()
07:01:26 <vixey> unsafeInstallGHC
07:01:50 <Philonous1> cabal install leksah tells me I don't have glib, gtk and sourceview in versions >=0.9.12 Does anyone know to which packages that refers?
07:02:35 <Saizan_> ?google gtk2hs download
07:02:37 <pozic> In a logical sense it's quite stupid that countries have no many nuclear weapons. Since it's MAD anyway, you would only need a few and deploy them somewhere deep in the Earth. That would he a much cheaper solution, I guess.
07:02:37 <lambdabot> http://www.haskell.org/gtk2hs/download/
07:02:37 <lambdabot> Title: Gtk2Hs » Download
07:02:47 <Saizan_> Philonous1: you've to install that ^^^^
07:03:30 <Philonous1> I take it I can't get it via cabal install?
07:03:39 <Baughn> pozic: Sorry. Deploy them deep in the earth? What are they supposed to do there?
07:03:51 <Baughn> Philonous1: Nope, it hasn't been cabalized
07:03:56 <Baughn> gtk2hs is legacy software
07:04:09 <pozic> Baughn: cause major eruptions all over the world.
07:04:22 <Baughn> pozic: Eh?
07:04:25 <Baughn> pozic: How?
07:04:44 <vegai> If that worked, what also would work is dismantling all the armies around the world completely
07:04:50 <pozic> Baughn: I didn't do the math, it was just an idea.
07:05:04 <Baughn> pozic: Sadly, you're off by several orders of magnitude
07:05:31 <pozic> Baughn: are you a geophysicist?
07:05:44 <Philonous1> Baughn: legacy? What does replace it?
07:05:49 <Baughn> Philonous1: Nohing
07:06:08 <Philonous1> Oh, so it isn't deprecated, just not cabalized
07:06:12 <Saizan_> it's more that it has a complex enough build system that you can't cabalize it yet
07:06:13 <Baughn> Right
07:06:20 <Baughn> Well, there is wxHaskell, which /is/ cabalized
07:06:36 <Baughn> pozic: Nope, but I really don't need to be. I know the approximate forces at work.
07:07:22 <Philonous1> Thanks a bunch. I don't feel comfortable using two package systems for haskell libraries, though.
07:07:41 <Baughn> Philonous1: There's cabal, and then there's gtk2hs
07:07:54 <Baughn> If you really don't want to configure;make;install, use wxhaskell instead
07:08:05 <pozic> Baughn: yes, you are right.
07:08:08 <Philonous1> Yes, I meant the FreeBSD ports vs. cabal
07:08:29 <Baughn> Oh. No, mixing those isn't a very good idea.
07:09:07 <vegai> unless the port uses cabal
07:10:13 <Saizan_> they all end up using ghc-pkg to register haskell libraries, so it's not so much of a problem
07:11:40 <Baughn> Does gtk2hs still work on ghc 6.10? I remember there being lots of "warning: deprecated operation that will be removed" lines in the output when compiling on 6.8
07:12:42 * Baughn is about to find out
07:14:06 <Deewiant> Baughn: I managed to get it to compile, at least
07:14:06 <tuxdistro_> anyone here use openSUSE
07:14:21 <Baughn> Mmh. I.. didn't.
07:14:37 <Deewiant> Baughn: required a patch from the sourceforge mailing list and some manual messing about
07:14:45 <Deewiant> wasn't too bad, though
07:26:18 <pozic> f = id;f x = x -- why doesn't the compiler accept this? It's not like it's hard for the compiler to decide that it is going to work.
07:27:24 <meryrus> monomorphism, ain't it?
07:28:20 <Cale> pozic: hm? All bindings of the same name must syntactically take the same number of parameters.
07:28:53 <pozic> Cale: yes, I know.
07:29:02 <pozic> Cale: but I don't like that rule.
07:29:39 <Cale> pozic: While it could be done in another way, it catches some errors resulting from multiple definitions of the same name, and makes it easier to check visually that all cases are being handled.
07:30:35 <Cale> At least, that's the argument that I heard last time I saw it come up.
07:32:08 <pozic> It's premature optimization, imho.
07:32:26 <pozic> But.. it can be changed in a future language.
07:32:28 <EvilTerran> but it's not optimisation...
07:32:28 <Cale> Hm? It has nothing to do with performance...
07:32:43 <pozic> Cale: it's optimisation for the compiler writers.
07:32:47 <Cale> It's just a matter of readability.
07:32:48 <pozic> Cale: "less work for them"
07:33:03 <pozic> Cale: tool support could decide the same problem .
07:33:24 <mauke> I don't think it makes the compiler simpler
07:33:24 <Cale> The culture is against requiring tool support
07:34:11 <Cale> The problem is one for humans: what cases does this line apply to?
07:34:28 <Saizan_> it would be trivial to eta-expand definitions with less parameters for the compiler
07:36:17 <Cale> Of course, it's not so hard for humans to work out either. It's just that people are used to eta-reduced bindings applying in all cases, and eta-expanded bindings being subject to the previous pattern matches.
07:36:37 <pozic> It makes the code less abstract: f [] = [] vs f = id; non-trivial cases follow.
07:36:56 <pozic> Although, I could do f x = x
07:37:19 <pozic> Well, minor issues, never mind it.
07:37:27 <mauke> er, after f = id, all other cases are ignored
07:37:50 <mauke> it always succeeds
07:37:55 <Saizan_> Cale: yeah, that was my point, that's a design decision rather than implementation one
07:38:35 <andun> t
07:38:51 <mauke> nil
07:38:56 <shapr> dang, beat me to it
07:39:25 <pozic> mauke: yes, the order was reversed.
07:39:56 <zachk> is there a better term then "computational limit" when you take a program out to infinite?
07:40:43 <Baughn> zachk: Big-O notation? Asymptotic behaviour? Limit?
07:40:58 <Baughn> zachk: Er, I'd really need a concrete example
07:42:34 <zachk> a program that will print all the reals or maybe not its just an idea i had
07:42:47 <zachk> keep hearing about noncomputable numbers and they tick me off
07:42:51 <Stinger_> yeah
07:42:53 <Baughn> You can't print all the reals; they're uncountable
07:42:55 <Stinger_> thats not possible
07:42:56 <Stinger_> heh
07:43:02 <Baughn> Well, you could print all the floating-point numbers
07:43:10 <Baughn> THat'd be diagonalization. :P
07:43:17 <zachk> well can i print all of N(natural number)
07:43:28 <Baughn> Yeah, those are countable
07:43:30 <zachk> yea but cantor went insane
07:43:57 <Baughn> Are you complaining that he went and discovered unprintable math? :P
07:44:17 <mauke> I blame Kronecker
07:44:18 <zachk> not complaining just think there is a way around it
07:44:44 <Stinger_> if you want to print them, you need to do them in sequence
07:44:57 <zachk> but i cant sequence the reals
07:45:01 <Stinger_> exactly
07:45:02 <Cale> pozic: Yeah, if I see  f x = g (h x), say, I'm prepared for that equation only to hold for some values of x (though if it's on its own, it would mean for all x), if I see f = g . h, where the parameter is not mentioned, I expect that equation to be true of the functions.
07:45:18 <Cale> (that is, for every point in the domain)
07:45:44 <Baughn> zachk: There isn't.
07:45:55 <Baughn> zachk: Live with it. Or not.
07:46:11 <pozic> Speaking of beyond Turing, what do you think of http://adsabs.harvard.edu/abs/2006cs.......10114T ?
07:46:12 <lambdabot> Title: Instant Computing - A New Computation Paradigm
07:46:13 <zachk> or write some code that gets around it :-D
07:46:16 <Stinger_> or if you find a way, expect the Fields medal
07:46:27 <Baughn> zachk: But.. you *can't* get around it. It's provably impossible. >_<
07:46:36 <pozic> Baughn: no, that's not true.
07:46:41 <pozic> Baughn: only for Turing machines.
07:46:46 <Baughn> ...
07:46:49 <opqdonut> welll
07:46:55 <opqdonut> the real numbers _are_ uncountable
07:46:56 <Baughn> Right. Yes. Sadly, our /universe/ is turing-computable.
07:46:57 <opqdonut> no matter what
07:46:58 <Baughn> Probably.
07:47:00 <Saizan_> Baughn: you may find that calculus is useless and we can live with only countable many numbers
07:47:06 <Baughn> So you can't make a non-turing machine in it, no matter what
07:47:09 <zachk> i basically need an infinite amount of ram, an infinite number of processors, and an infinite amount of time
07:47:09 <opqdonut> yeah
07:47:12 <Cale> zachk: If you write me a program which purports to sequence all the reals, and give it to me, I can give you a program which prints a real number which your program will never generate.
07:47:13 <opqdonut> algebraic numbers are fine
07:47:22 <opqdonut> + numerably many trancendental ones
07:47:28 <opqdonut> e and pi and so forth
07:47:55 <zachk> cale: i am still working out some of the bugs
07:47:59 <Stinger_> zachk, even that wont be enough :P
07:48:18 <Cale> zachk: My program will use your program to ensure that the kth digit of the real number it prints will not be equal to the kth digit of the kth real number that your program produces.
07:48:24 <pozic> The link I gave is the only concrete hypercomputation paper I know about, but it probably has nobody that looked at it.
07:48:36 <zachk> cale: it will get to your number eventually
07:48:41 <Cale> zachk: No it won't.
07:48:55 <Peaker> zachk: there are more real numbers than programs or program states
07:48:55 <pozic> zachk: on a Turing machine it won't.
07:48:58 <Cale> zachk: What index in the list?
07:49:11 <zachk> it repeats numbers
07:49:21 <Cale> zachk: Suppose your program prints my number at the nth position.
07:49:23 <Stinger_> how inefficient
07:49:26 <Peaker> zachk: perhaps unintuitively, not all infinites are equal
07:49:35 <Cale> zachk: But my number has a different nth digit from yours.
07:49:37 <zachk> yea i noticed that
07:49:59 <Cale> zachk: And so for any particular n you choose, my number will be different.
07:50:14 <zachk> but then if we sit around and wait a bit
07:50:20 <zachk> it will print your number
07:50:21 <Peaker> The number of reals in a bound range (e.g 0..1) is the same kind of infinite as unbound reals, right?
07:50:31 <pozic> Peaker: yes
07:50:33 <zachk> i believe their cardinality matches
07:50:38 <Cale> zachk: Dude, did you just listen to the argument I gave you?
07:50:39 <zachk> and you can do a 1 to 1 mapping
07:50:43 <zachk> cale: yes
07:50:48 <pozic> zachk: read a basic logic book
07:51:01 <Cale> zachk: Okay, so for which n will my number appear in the list?
07:51:22 <Cale> zachk: There can not be any such position, and so it's not in the list.
07:51:31 <necroforest> BTW, neural networks with real weights have been proving to be more powerful than turing machines
07:51:38 <necroforest> *proven
07:51:59 <Riastradh> Too bad most of the real numbers are uncomputable...
07:52:05 <int-e> zachk: your program will never print any real number to the end (neither will Cale's)
07:52:18 <necroforest> Just sayin' ;)
07:52:22 <vixey> necroforest: What does 'more powerful' mean?
07:52:34 <opqdonut> necroforest: err
07:52:36 <Stinger_> can run doom better
07:52:47 <opqdonut> necroforest: not in the sense that they can compute more, at least
07:52:51 <int-e> zachk: so in a twisted way, intuitively, when you start printing Cale's number, Cale's program still has the chance to change it.
07:53:06 <necroforest> vixey, the languages recognized by it are a superset of the recursively enumerable languages
07:53:15 <opqdonut> citation please?
07:53:25 <necroforest> mmm i have the paper printed out
07:53:27 <necroforest> let me go fin dit
07:53:33 <vixey> necroforest: I see, what is the definition of the language a NN accepts?
07:53:51 <Cale> right. As soon as you print the kth digit of the kth number, the kth digit of my number will be printed, and it will be different.
07:53:59 <opqdonut> well, yeah
07:54:02 <opqdonut> _real_ weights
07:54:04 <vixey> Can you phrase it in terms of R^n -> R^m ?
07:54:11 <opqdonut> i can see how that gives power
07:54:20 <necroforest> opqdonut, right, you obviously wouldn't be able to emulate it on a lowly turing machine
07:54:20 <vixey> I'm guessing any neural net is a function from R^n -> R^m, isn't it?
07:54:31 <opqdonut> yes basically
07:54:37 <necroforest> "Neural Networks with real weights: analog computational complexity"
07:54:44 <vixey> so what is the language that accepts?
07:55:50 <necroforest> they can recognize any language in exponential time, and a superset of recursive languages in polynomial time
07:56:18 <Cale> zachk: Say, if the kth digit of the kth number your program produces is 7, then the kth digit of my number is 3, otherwise, it's 7.
07:56:21 <vixey> I thought every NN was equiv. to a two level or something?
07:56:34 <vixey> so they should all be linear time, no?
07:56:34 <pozic> necroforest: doesn't that assume that there is an analog thing to begin with?
07:56:54 <necroforest> vixey, i think you're thinking aobut feed-forward networks
07:57:00 <necroforest> vixey, these are recurrent networks
07:57:03 <vixey> oh I see!
07:57:06 <necroforest> pozic, what do you mean
07:57:36 <necroforest> so "time" is "number of loops through the network" i guess... i actually read the thing like 8 months ago
07:57:51 <pozic> necroforest: I mean that there are no infinite states in an "analog" circuit.
07:58:35 <necroforest> what do you mean by "infinite state"?
07:59:54 <pozic> necroforest: I mean that it's not currently accepted that analog signals that carry an infinite amount of information.
08:00:11 <necroforest> oh, i dont know anything about that
08:00:23 <pozic> necroforest: http://en.wikipedia.org/wiki/Planck_scale
08:00:26 <lambdabot> Title: Planck scale - Wikipedia, the free encyclopedia
08:00:33 <necroforest> this is a math model though, it doesn't mean it's possible to build one
08:01:11 <necroforest> right, so you might not really be able to produce an irrational weight on a physical net
08:06:43 <mmorrow> zachk: in R there're the same number of elems in (0,1) as there are in (-oo,oo)
08:07:18 <Cale> (the same is true of the rational numbers though, so that's not a countability thing)
08:07:24 <mmorrow> hrm
08:07:47 <mmorrow> ok, rephrasing
08:08:29 <mmorrow> err, nope that doesn't work either :)
08:09:00 <necroforest> i think the best explanation for uncountability is really just the cantor proof
08:09:19 <necroforest> showing no matter how you list an uncountable sets, there's always something not in your list
08:09:32 <mmorrow> and there are an infinite number of infinities also
08:09:50 <mauke> how infinite is the number of infinities?
08:09:55 <mmorrow> countably :)
08:10:06 <opqdonut> barring large cardinals
08:10:18 <opqdonut> whose existence is independent of ZFC
08:10:25 <mmorrow> aleph_0, aleph_1, ...
08:10:37 <mauke> aleph_aleph
08:10:49 <necroforest> you can't prove that there's no set with cardinality between aleph0 and aleph1, IIRC
08:11:06 <opqdonut> yeah that's equivalent with CH iirc
08:11:09 <mmorrow> exactly, so i say there isn't :)
08:11:50 <necroforest> CH?
08:11:59 <mmorrow> continuum hypothesis
08:12:13 <necroforest> yeah that is the continuum hypothosis
08:12:56 <opqdonut> what about aleph_{\omega_1}
08:13:00 <opqdonut> and so on
08:13:17 <mmorrow> i don't even know the def of what that's supposed to be
08:13:18 <necroforest> aleph_(infinity + 1)!
08:13:53 <opqdonut> mmorrow: well aleph_{i+1} = 2^{aleph_{i}}
08:14:04 <mmorrow> ok
08:14:08 <opqdonut> and we iterate this \omega_1 times where \omega_1 is the first uncountable ordinal
08:14:26 <mmorrow> but i in aleph_i is N
08:14:52 <opqdonut> no
08:14:55 <opqdonut> it's an ordinal
08:14:59 <mmorrow> why?
08:15:12 <opqdonut> "The aleph numbers are indexed by ordinal numbers."
08:15:13 <opqdonut> because
08:15:25 <opqdonut> (quote from wikipedia (yeah yeah i know))
08:15:25 <zachk> i can see the first two infinities in my head
08:15:32 <dolio> Otherwise there'd only be countably many.
08:15:52 <opqdonut> yeah
08:15:54 <mmorrow> which is what i thought was the case
08:15:58 <opqdonut> which is actually what mmorow claimed
08:16:07 <opqdonut> "For every ordinal ? there is a cardinal number  and this list exhausts all infinite cardinal numbers."
08:16:15 <opqdonut> (assumin AC I guess)
08:16:36 * mmorrow needs to brush up on ordinal numbers
08:17:09 <dolio> Yeah, every limit ordinal is associated with a cardinal or something of the sort.
08:17:37 <dolio> (And successors of limit ordinals are associated with that cardinal, too.)
08:18:34 <mm_freak> fix aleph
08:18:37 <dolio> Maybe I'm wrong about that, since I'd expect omega^2 --> aleph_0, too.
08:18:56 <mm_freak> fix (aleph `subscript`)
08:22:17 <dolio> Oh yeah. All countable ordinals are associated with aleph_0, of course.
08:22:41 <opqdonut> well
08:22:50 <opqdonut> in the sense that their cardinality is aleph_0 yes
08:23:06 <opqdonut> but we were talking about the mapping \alpha \mapsto \aleph_\alpha
08:23:10 <dolio> And omega_1 is associated with aleph_1.
08:23:51 <gal_bolle> isn't omega_1 = aleph_1 by definition?
08:24:14 <mmorrow> , let sub = fmap("₀₁₂₃₄₅₆₇₈₉"!!) . fmap (read . (:[])) . show in "ω" ++ sub 647394723
08:24:21 <lunabot>  "\969\8326\8324\8327\8323\8329\8324\8327\8322\8323"
08:24:26 <opqdonut> gal_bolle: well |omega_1|=aleph_1
08:24:28 <mmorrow> , toUTF8 (let sub = fmap("₀₁₂₃₄₅₆₇₈₉"!!) . fmap (read . (:[])) . show in "ω" ++ sub 647394723)
08:24:31 <lunabot>  ω₆₄₇₃₉₄₇₂₃
08:24:34 <mmorrow> hehe
08:24:46 <mmorrow> , text "ω"
08:24:48 <lunabot>  
08:24:50 <mmorrow> goo
08:24:52 <gal_bolle> yes, so omega_1 > aleph_1
08:24:58 <gal_bolle> >=
08:25:00 <gal_bolle> of course
08:25:30 <gal_bolle> but if aleph_1 < omega_1, then omega_1 is not the smallest uncountable
08:26:15 <gal_bolle> after that it's a matter of whether you identify ordinals and cardinals
08:26:49 <gal_bolle> people usually do, otherwise they get to keep their sanity too long to be taken seriously in that branch
08:27:14 <necroforest> people usually do what?
08:27:47 <gal_bolle> identify cardinals with ordinals
08:28:05 <necroforest> lol
08:28:15 <gal_bolle> that is, define cardinals as being ordinals which have the property that…
08:28:34 <gal_bolle> not as being wholly different objects
08:28:40 <gal_bolle> sorry if that was unclear
08:28:42 <necroforest> ah
08:28:56 <necroforest> yeah i never really 'got' ordinals
08:29:19 <necroforest> although my education in this area is mostly from wikipedia
08:29:21 <necroforest> ;)
08:30:03 <gal_bolle> s/although/since/
08:30:14 <necroforest> lol
08:30:32 <necroforest> where would you learn about this stuff in school?
08:30:42 <necroforest> like upper level/graduate discrete math class?
08:31:15 <gal_bolle> well, i had one in lyon, as a side course in my theoretical cs culture
08:31:32 <gal_bolle> and i know there are masters with a lot of set theory at least in toronto
08:31:35 <gal_bolle> and paris
08:31:47 <gal_bolle> but i guess there are (much) more
08:31:52 <necroforest> graduate?
08:32:17 <gal_bolle> undergraduate (before you start your phd, that is)
08:32:29 <gal_bolle> i'm never sure what graduate means
08:32:39 <necroforest> oh
08:32:50 <necroforest> in US graduate is masters or phd
08:34:55 <gal_bolle> ok, so these would be graduate
08:35:47 <necroforest> my school didn't have a masters or phd math course, and only a masters CS so i didn't any exposure to that in school
08:36:39 <pozic> necroforest: this topic belongs to CS, I got it in my undergraduate program, btw.
08:37:07 <necroforest> you did ordinal numbers in a CS class?
08:37:35 <pozic> necroforest: yes, it wasn't even an elective.
08:37:44 <necroforest> what school did you go to?
08:37:49 <dolio> There was a recent sigfpe article about proving termination of algorithms with ordinal numbers.
08:37:51 <pozic> necroforest: I won't go into details.
08:38:02 <necroforest> lol ok
08:38:14 <pozic> ACL2 also uses ordinal numbers.
08:47:57 <meryrus> Given a list of lists, how do I make the list that picks one from each sublist and concats them together?
08:48:44 <meryrus> [[1, 2], [3, 4]] -> [[1, 3], [1, 4], [2, 3], [2, 4]]
08:48:46 <Deewiant> > concatMap head ["foo","oops","okay"]
08:48:47 <lambdabot>   Couldn't match expected type `[b]' against inferred type `Char'
08:48:54 <dolio> sequence
08:48:57 <Deewiant> right, oops
08:48:58 <pozic> f n = concatMap (!! n)
08:48:58 <Deewiant> > map head ["foo","oops","okay"]
08:48:59 <lambdabot>   "foo"
08:49:02 <meryrus> :t sequence
08:49:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:49:31 <Deewiant> > sequence [[1,2],[3,4]]
08:49:31 <Saizan_> > [[1, 2], [3, 4]]
08:49:33 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
08:49:33 <lambdabot>   [[1,2],[3,4]]
08:49:49 <pozic> > let f n = join (!! n) in f 0 [[1],[1],[1]]
08:49:50 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a] -> a1
08:49:50 <lambdabot>      Pr...
08:51:20 <Deewiant> > let f [] = [[]]; f (x:xs) = concatMap (\v -> concatMap (\vs -> [v:vs]) (f xs)) x in f [[1,2],[3,4]]
08:51:21 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
08:53:02 <meryrus> thanks
08:53:31 <Cale> If you're going to use concatMap nested like that, a list comprehension is probably more readable
08:55:28 <Deewiant> > foldr (flip $ \xs -> concatMap (\y -> concatMap ((:[]).(y:)) xs)) [[]] [[1,2],[3,4]]
08:55:29 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
08:56:01 <Deewiant> Cale: actually I'm just @undo'ing @src sequence
08:56:56 <Deewiant> ?pl (flip $ \xs -> concatMap (\y -> concatMap ((:[]).(y:)) xs))
08:56:56 <lambdabot> liftM2 (:)
08:56:59 <Cale> > let sequ [] = [[]]; sequ (x:xs) = [v:vs | v <- x; vs <- sequ xs] in sequ [[1,2],[3,4]]
08:57:00 <lambdabot>   <no location info>: parse error on input `;'
08:57:08 <Cale> > let sequ [] = [[]]; sequ (x:xs) = [v:vs | v <- x, vs <- sequ xs] in sequ [[1,2],[3,4]]
08:57:10 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
08:57:15 <Deewiant> *nod*
08:58:02 <mauke> ack, this is making my head hurt
08:58:48 <mauke> I'm trying to write 'interact'. Using lazy IO. In a lambda calculus interpreter. Which is written in C++.
09:01:32 <meryrus> mauke: pics?
09:01:41 <mauke> huh?
09:01:47 <olsner> why not write it in haskell instead? :P
09:02:00 <meryrus> Can you show us some of the source? :)
09:02:10 <mauke> because this is a "linux systems programming" course
09:02:28 <mauke> return apply(apply(literal(f), literal(Church::encode(c))), literal(Val(new LazyInput)))->eval(Prelude::prelude);
09:02:49 <olsner> sweet, sounds like an appropriately unappropriate place to write lambda calculus in C++
09:02:50 <dolio> Wow.
09:02:57 <pozic> mauke: are you the instructor? :P
09:03:02 <mauke> pozic: hah, no
09:04:01 <mauke> % ./main 'let fac n = if n < 2 then 1 else n * fac (pred n) in fac 5'
09:04:02 <mauke> ((\fac -> (fac (succ (succ (succ (succ (succ false))))))) (fix (\fac -> (\n -> ((((if_ (((<) n) (succ (succ false)))) (\_ -> (succ false))) (\_ -> (((*) n) (fac (pred n))))) id)))))
09:04:06 <mauke> 120
09:04:11 <mauke> this stuff works; now I want to add I/O
09:04:14 <pozic> Somehow I think mauke interpreted the assignment in a creative manner.
09:05:11 <pozic> mauke: what was the original assignment?
09:05:12 <olsner> what's the problem, more explicitly, with writing interact? (or is it the lazy I/O part that's killing you?)
09:05:24 <mauke> oh wait, this isn't systems programming
09:05:34 <mauke> it's just general OO stuff
09:05:45 <mauke> writing a Car class, etc
09:06:21 <mauke> olsner: well, I have to write code that traverses the list of output values
09:06:42 <mauke> wait, can this even work
09:07:16 <olsner> heh, "Car" class :) reminds me of template lisping
09:07:17 <mauke> answer: no, because the interpreter is strict
09:07:51 <stahlstift> Hey, sorry for this weired question, but does haskell compile to bytecode like java or do I have to compile on every platform I want to release my project?
09:08:03 <olsner> heh, why were you writing a strict interpreter anyway? :P
09:08:15 <mauke> olsner: code simplicity
09:08:22 <Cale> stahlstift: Depends on which implementation you're using, but with GHC, you have to compile for each platform.
09:08:45 <Cale> stahlstift: The Yhc guys have a system which uses bytecode.
09:09:10 <olsner> maybe you could use some delay/force primitives
09:09:13 <Cale> stahlstift: (but I'm not sure how usable that is yet for real world stuff)
09:09:25 <mmorrow> stahlstift: of course bytecode is /way/ slower than machine code by it's very nature...
09:09:36 <stahlstift> thanks Cale. I am a PHP and Java coder and maybe I will look into haskell :) It seems to be interesting to learn it :)
09:10:05 <Cale> Yeah, definitely check it out. :)
09:10:22 <Cale> and feel free to hang around here and ask lots of questions :)
09:10:30 <stahlstift> thanks cale
09:11:06 <stahlstift> but first I have to finish my apprenticeship, got the final tests in about 4 weeks :)
09:13:01 <stahlstift> is there an ide or a plugin for eclipse?
09:13:26 <necroforest> i don't know.. i do know there's a vim mode and an emacs mode
09:13:44 <Cale> Most people use vim or emacs. Any text editor will do as long as it can convert tabs to spaces automatically.
09:14:17 <stahlstift> well I am a java coder... i am used to code completetion :)
09:14:18 <Cale> (and of course, things like syntax highlighting are nice :)
09:14:23 <Deewiant> (Or as long as you can use tabs responsibly.)
09:15:05 <Cale> I wouldn't even recommend trying to use tabs responsibly, because they can come as a surprise to other people editing your stuff.
09:15:08 <BONUS> code completion is usually required for verbose languages like java
09:15:21 <BONUS> with terse languages like haskell, you dont need it that much
09:15:49 <Cale> You'll tend to spend a lot more time thinking than actually typing while writing Haskell code.
09:15:54 <opqdonut> yes
09:16:00 <olsner> @quote meditation
09:16:00 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
09:16:15 <Deewiant> :-)
09:16:26 <stahlstift> similiar to java... most time think about design patterns and the rest of time you read javadocs and docs from the lib :D
09:16:49 <Peaker> "Code completion" is too broad a term.  I'd love being able to fill in pieces of the code that are clear to me, then asking the editor to hoogle something that type-checks the missing parts...
09:16:55 <Cale> stahlstift: Much more severe than Java. Java is horribly verbose compared to Haskell.
09:18:00 <Peaker> I think I often know a bunch of arguments I'll be using, but I have to think about which function to use with them - and a smart editor + hoogle can help there...
09:18:13 <olsner> it'd be cool to be able to leave blanks in the code (or just select a subexpression) and see what it would type-infer to
09:18:41 <Cale> stahlstift: One reason being that you have to declare the type of basically everything in Java, whereas in Haskell, type annotations are almost always optional.
09:18:55 <olsner> (and integrated automatic hoogle search would make it even more awesome)
09:18:56 <Cale> (the compiler will infer types)
09:19:09 <zachk> did i ever mention i hate java?; and Captilization
09:19:15 <Peaker> yeah, a stroke of a key to show/hide inferred types for everything...
09:19:17 <stahlstift> Cale: I like type annotations
09:19:34 <Cale> stahlstift: You can leave them in, and they'll be checked by the compiler.
09:19:46 <Cale> stahlstift: But the annoying ones can always be left out.
09:19:49 <Peaker> I think it might be a good idea to have the program being edited always type-check correctly, with "transactions" to make non-trivial changes so no intermediate badly-typed programs are formde
09:19:50 <Deewiant> Map<ArrayList<Foo>> x = new HashMap<ArrayList<Foo>>
09:20:02 <stahlstift> Cale: I stopped coding python in my sparetime because there are no methode to declare the type
09:20:04 <Peaker> and then have a rich variety of type-safety-preserving transformations possible
09:20:05 <Cale> Deewiant: exactly, that kind of thing :P
09:20:18 <Cale> stahlstift: Right Python has no type system.
09:20:31 <Deewiant> Cale: That's a bit strongly put. :-P
09:20:33 <Cale> stahlstift: Haskell has a very advanced type system which can infer types.
09:20:35 <olsner> Peaker: hmm, that could add up to a lot of information though... maybe an AST-based editor could have heuristics for what it should be showing the type of though
09:21:03 <Cale> Deewiant: To me, types are things which the compiler statically proves about the behaviour of the code.
09:21:18 <Deewiant> Cale: So, to you, "dynamic typing" is an oxymoron? :-)
09:21:19 <stahlstift> is there aleady a stable idea for webdeveloping in haskell?
09:21:23 <Cale> Deewiant: yes.
09:21:37 <Cale> Deewiant: Dynamic types are not types :P
09:21:50 <Cale> (or, they are all the same type)
09:22:05 <Deewiant> Cale: Fine, but I'd be careful about using that meaning when others near you are using a different, and more common, meaning :-P
09:22:57 <Cale> stahlstift: There are a few things floating around
09:23:16 <mauke> void interact(Val v) { apply(apply(literal(v), literal(Val(new LazyInput))), literal(Val(new Output)))->eval(Prelude::prelude); }
09:23:17 <Cale> stahlstift: HAppS is probably the best fleshed out.
09:23:18 <Taggnostr> is there something like None or Null?
09:23:23 <mauke> the amazing part is that it actually seems to work
09:23:24 <Deewiant> Nothing?
09:23:25 <stahlstift> Cale: so there is currently a hype about haskell? well there must be one :)
09:23:35 <Cale> stahlstift: A bit, I suppose :)
09:23:47 <Taggnostr> Nothing could work
09:24:21 <Cale> stahlstift: It has started growing in popularity, after a long time of having a cult following among researchers and rather nerdy people. :)
09:24:39 <stahlstift> the syntax looks very mathematically :) [ X || X <- Rest, X < Pivot]
09:24:42 <Cale> stahlstift: Some companies have started using it for practical work.
09:24:54 <gchin> hello, I've got a object whose datatype contains an OpenGL texture, and this texture gets copied everytime I make a copy of that object
09:24:57 <stahlstift> argh sorry that was erlang :D
09:25:15 <necroforest> stahlstift, haskell has similar syntax
09:25:17 <mauke> > [ x | x <- [1 .. 10], x < 5 ]
09:25:19 <lambdabot>   [1,2,3,4]
09:25:21 <Cale> stahlstift: Close though...  [x | x <- rest, x < pivot]  would be Haskell.
09:25:28 <gchin> does anyone have a good idea on how to avoid making a copy of a datatype member if I want to copy that object?
09:25:35 <dolio> Haskell's is better, of course.
09:25:44 <Cale> gchin: hm?
09:25:53 <Cale> gchin: copy?
09:26:03 <pozic> gchin: if you are not using reference types, you should not worry about it.
09:26:20 <Cale> gchin: are you sure it's being copied?
09:26:24 <rwbarton> reference types?
09:26:30 * rwbarton checks that this is not #C++
09:26:34 <gchin> I'm not sure I'm explaining this too well, let me paste some things into a text file
09:26:38 <Cale> rwbarton: Presumably things like IORef, etc.
09:26:58 <stahlstift> and what about guis? Thats the part what I really love in Java. One Guicode for every platform - even if I often cursing Swing :) Something like a hatelove :)
09:27:13 <Cale> stahlstift: Gtk2Hs and wxHaskell
09:27:14 <mauke> woot, 'id', 'const nil' and 'cdr' all work
09:27:21 <Cale> stahlstift: They're both reasonably cross platform.
09:27:27 <Deewiant> mauke: how about 'fix'
09:27:28 <stahlstift> k
09:27:44 <mauke> Deewiant: what would fix do with a list of numbers?
09:28:01 <mauke> (answer: segfault)
09:28:07 <Deewiant> mauke: not type-check? ;-P
09:28:17 <mauke> Deewiant: this is the untyped lambda calculus
09:28:23 <Deewiant> ew
09:28:36 <Cale> Why segfault then?
09:28:45 <mauke> probably because of infinite recursion
09:29:09 <Cale> Well, perhaps it won't terminate, yeah :P
09:29:40 <mauke> time to put character literals in the parser
09:33:05 <gchin> okay, I think this is what I'm trying to ask: http://www.contrib.andrew.cmu.edu/~gchin/haskell.txt
09:33:28 <Cale> gchin: The iTexture member is just a pointer
09:33:37 <Cale> gchin: So there's not really much harm in copying it.
09:34:06 <Cale> However, memory usage may be climbing as a result of expressions not getting evaluated.
09:34:30 <gchin> Cale: hmm, what do you mean by not getting evaluated?
09:35:15 <Cale> Well, if you don't actually look at the fields of a datastructure, but you make 'updates' to it in a loop, you can end up building large expressions.
09:35:19 <Cale> For example...
09:36:01 <Cale> f 0 x = x
09:36:16 <Cale> f n x = f (n-1) (x+1)
09:36:32 <Cale> Suppose we call f 30 0
09:37:03 <gchin> Cale: oh, I think I see what you're getting at
09:37:12 <Cale> f 30 0 -> f (30-1) (0+1) -> f 29 (0+1) -> f 28 ((0+1)+1) -> ...
09:37:21 <gchin> so the x term is going to be built up but because of lazy evaluation it won't be smashed into a value until the last call?
09:37:27 <Cale> right.
09:37:35 <gchin> Cale: ah, that makes a lot of sense
09:37:36 <Cale> Until something uses the result of the call to f.
09:38:02 <gchin> Cale: cool, thanks a lot. I'll have to take a look at my code again to fix this
09:38:12 <Cale> So occasionally, making the fields of the datatype strict can help a lot with things like this.
09:38:34 <Cale> (just add a ! before the type)
09:39:29 <Taggnostr> can I define a new data type from ghci?
09:39:34 <Cale> Taggnostr: nope
09:39:44 <Taggnostr> :\
09:40:02 <Cale> You can reload your file though, after adding a new datatype.
09:40:30 <Cale> (it's just :r to reload)
09:40:30 <Taggnostr> I'm doing it on a file right now
09:41:39 <mauke> @src lines
09:41:39 <lambdabot> Source not found. Maybe you made a typo?
09:45:55 <cnwdup> I feel that the use of existential types is quite limited since you cannot call abitrary functions on the contents they wrap. Can I somehow work around that by using other types / mechanisms?
09:47:28 <int-e> cnwdup: wrap the functions, too. the usual idea is to wrap a class dictionary with the operations that you're planning to use.
09:48:04 <Cale> cnwdup: The point of existential types is to limit the functions which can be called on the wrapped contents.
09:48:50 <Cale> (and thereby be able to ignore the differences between various types of things which might be wrapped up)
09:48:55 <Taggnostr> after I imported the module, do I have to something in order to access the data and functions defined there?
09:49:14 <cnwdup> int-e: I tried that, but it isn't working. I thought that'd be smart: http://hpaste.org/11665 But ghc tells me, it is not. ) :
09:49:29 <Cale> Taggnostr: Nope, everything which is exported should be available.
09:50:01 <Taggnostr> ok, now it works
09:50:53 <cnwdup> cale: I want a restricted set of functions (callable on all) on the one hand and a non-restricted set for specific functions on the other while still benefiting from static type checking. But I feel as if that isn't possible with Haskell.
09:51:21 <rwbarton> cnwdup: in what sense is that code not working?
09:51:40 <Cale> cnwdup: Well, if you're going to stick something into an existential, you're basically saying "I don't care about the particulars of this value anymore, only how it responds to such and such interface of functions)
09:52:04 <int-e> cnwdup: a -> (a -> PL m b) -> PL m b is an odd type
09:52:14 <inad923> hello
09:52:24 <rwbarton> cnwdup: the PluginClass (Plugin a) instance needs to be more like  query (Plugin a) f = query a (f . Plugin)
09:53:25 <cnwdup> cale: So there are other types which don't have that attribution of indifference? ^^
09:53:34 <olsner> mauke: hmm, why not just use integers as character literals?
09:53:38 <cnwdup> int-e: Thats how I was trying to achieve what you've suggested.
09:53:51 <Taggnostr> haskell doesn't have for or while loops, does it?
09:53:54 <rwbarton> cnwdup: Sure, they're called disciminated unions (algebraic data typs).
09:53:58 <mauke> olsner: because I like being able to type 'a' instead of 97
09:54:08 <Cale> Taggnostr: They are library functions.
09:54:11 <olsner> well, 'a' == 97 :P
09:54:19 <Cale> Taggnostr: Well, for-each loops are, essentially.
09:54:20 <olsner> in C/C++ at least
09:54:31 <int-e> cnwdup: but I doubt that the type of quere is the type you want.
09:54:33 <Taggnostr> uhm
09:54:37 <Deewiant> olsner: only on ASCII systems. ;-)
09:54:39 <Cale> Taggnostr: forM :: [a] -> (a -> IO b) -> IO [b]
09:54:49 <inad923> I have a little problem. I compile xmonad-0.8 from source and install it with cabal. When I try to write a config file for it it cries becouse it says it cant find the module XMonad. Which is weird since I just installed it. I found out that I can register new modules with "ghc-pkg register <somefilename>". The only thing I dont know is what "somefilename" should be. Could someone help me out?
09:54:51 <cnwdup> rwbarton: Then I would apply f to (Plugin a) which is not what I want.
09:55:07 <olsner> Deewiant: are you sure character literals aren't guaranteed to have their ASCII integer values?
09:55:09 <int-e> cnwdup: but that's what the type requires
09:55:16 <cnwdup> rwbarton: Can you point me to a description of unions?
09:55:18 <Cale> Taggnostr: It takes a list, and a function from elements of that list to actions (a loop body), and produces an action which runs the loop body for each element of the list in turn, producing a list of results.
09:55:25 <rwbarton> cnwdup: data Foo = Bar Integer | Baz String
09:55:27 <pozic> Taggnostr: whileM p code = if p then do code; whileM p code else return ()
09:55:27 <Deewiant> olsner: yes, quite sure.
09:55:33 <Asgaroth> inad923: Does your distro perhaps offer a package for xmonad? It might be a simpler way to solve this.
09:55:41 <Deewiant> olsner: the only thing that's guaranteed, IIRC, is that '0' through '9' are successive.
09:55:48 <dcoutts> inad923: sounds like it did not install properly, does ghc-pkg list xmonad report that it is registered?
09:55:51 <Deewiant> olsner: it's not even guaranteed that 'a' + 1 == 'b'.
09:56:01 <Cale> inad923: You probably don't want to use ghc-pkg to register packages directly. That's almost always handled via cabal.
09:56:07 <inad923> Asgaroth: its ubuntu so its a debian based distro which always have an old package
09:56:12 <cnwdup> rwbarton: And what if I want to expand the number of data constructors dynamically? then I have to use classes and thus existential types for keeping them into a list, for instance. Then again, I'm screwed.
09:56:15 <int-e> cnwdup: maybe you want a two parameter typeclass?  class PluginClass plugin value | plugin -> value where query :: plugin -> (value -> xyzzy) -> xyzzy ?
09:56:18 <inad923> dcoutts: yes it does
09:56:31 <rwbarton> cnwdup: It's not usually so hard to just say what kind of operations you want to be able to do with your data...
09:56:35 <Taggnostr> I have to iterate over a list of numbers, and append this number to a list only if a condition is true, I'd use map but then I don't know how to check the condition and append the number
09:56:39 <dcoutts> inad923: and just one version of it installed?
09:57:03 <inad923> dcoutts: yes 0.8. ubuntu has 0.6.3 or something like that
09:57:15 <nolraiWest> Can you make a newtype of a type constructor? I want a list that is shown and read in reverse order.
09:57:29 <int-e> cnwdup: together with data Plugin value = forall plugin . PluginClass plugin value => Plugin plugin
09:57:31 <Cale> Taggnostr: that sounds like something pure though :)
09:57:46 <Taggnostr> yep
09:57:46 <cnwdup> rwbarton: Well, I have a plugin which reacts on signals. Thus I am calling an easy-to-say set of functions like rawMessage, identifier, description, etc. But I want my plugins to be able to communicate with each other. For instance one plugin collects data and another one needs parts of this data to work.
09:57:50 <Asgaroth> inad923: Ah, I see. Perhaps the build script for xmonad 0.8 from ArchLinux is helpful: http://repos.archlinux.org/viewvc.cgi/community/x11/xmonad/PKGBUILD?root=community&view=co
09:57:52 <lambdabot> http://tinyurl.com/6fo5fs
09:57:53 <Cale> Taggnostr: So let's have a look at using map...
09:58:16 <Cale> Taggnostr: Well, hang on
09:58:18 <Asgaroth> inad923: You could check which steps there are different from yours.
09:58:22 <Taggnostr> I know how to use map, how to append and how to use 'if' to check the condition, I just don't know how to combine everything
09:58:25 <olsner> Deewiant: hmm, yes, seems the numerical value of chars is in the "execution character set"
09:58:27 <Cale> Taggnostr: You want to collect the elements of a list which satisfy a condition?
09:58:35 <cnwdup> int-e: I'll look into that. I am encountering such a class declaration for the first time.
09:58:39 <Cale> > filter even [1..10]
09:58:40 <lambdabot>   [2,4,6,8,10]
09:58:47 <inad923> Asgaroth: thanks Im checking it
09:58:48 <nolraiWest> Taggnostr: I'm not sure you want map.
09:58:54 <Taggnostr> uhm, let me see
09:59:03 <dcoutts> inad923: sounds like the files are actually missing then, which is weird, use ghc-pkg describe xmonad, it lists the import-dirs, that dir should contain XMonad.hi, but it sounds like it's missing for you.
09:59:05 <rwbarton> cnwdup: how do the plugins know about each other?  Say plugins X and Y want to communicate, can X just import the module where Y lives?
09:59:28 <Taggnostr> actually it could work, let me play around for a while
10:00:15 <cnwdup> rwbarton: Yep.
10:00:34 <Cale> > filter (\x -> reverse x == x) (words "abba abra otto level day madam")
10:00:35 <lambdabot>   ["abba","otto","level","madam"]
10:00:58 <cnwdup> rwbarton: I know, that would speak for usin ga union. But then, you can't develop plugins seperate from the core application.
10:01:15 <BMeph_> I want to self-reference a list of Ints until I get a value that's invalid as an index. But I also want that last value.
10:01:34 <rwbarton> cnwdup: If this problem can't be solved in the static type system, you have Data.Typeable as a last resort :)
10:01:42 <BMeph_> I'm going to have to write my own version of 'takeWhile' for this, aren't I? :)
10:01:50 <cnwdup> int-e: Can you give me a link where I can read up about using | in class declarations? I don't get by just looking at the code.
10:01:57 <inad923> dcoutts: I have XMonad.hi and all the files compiled from XMonad directory of the source in the same(/usr/local/lib/<packagename>) directory but for some wierd reason ghc wont find it
10:02:08 <Taggnostr> how can I do an integer division? e.g. 9/2 = 4
10:02:13 <Deewiant> > 9`div`2
10:02:15 <lambdabot>   4
10:02:15 <cnwdup> rwbarton: So there is no resort which isn't the last? ) :
10:02:22 <mauke> uncurry = \f xy -> xy f
10:02:27 <inad923> Asgaroth: what does $startdir holds in the arch script?
10:02:29 <int-e> cnwdup: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
10:02:31 <lambdabot> Title: 8.6.�Class and instances declarations, http://tinyurl.com/245leb
10:02:38 <cnwdup> Thank you, int-e.
10:02:42 <int-e> (there's probably stuff on the wiki, too)
10:02:50 <Asgaroth> inad923: the dir where the buildscript is located.
10:02:54 <Taggnostr> thanks
10:02:54 <pozic> BMeph_: invalid indices are larger than what length returns
10:03:02 <inad923> Asgaroth: i see
10:03:24 <pozic> BMeph_: if that's what you mean...
10:03:45 <Asgaroth> inad923: You might want to skip that -unregister step though, since it's only for removing stuff in the build dir I guess.
10:03:51 <rwbarton> cnwdup: I don't know exactly what kind of plugin architecture you're trying to build
10:04:42 <rwbarton> cnwdup: In a simple case like, each plugin lives in its own module, and is a top-level value of that module, you can have the plugins refer to each other just by importing the right module, and not going through the existential types at all.
10:05:22 <cnwdup> rwbarton: Yep. But in my case, the core applications stores a state for each module.
10:05:33 <Asgaroth> inad923: It seems though that it only creates a register.sh script, which you'd have to run afterwards as well. (This is done in a separate file when the package is actually installed)
10:05:36 <cnwdup> rwbarton: I can't store the plugin's state all by the plugin module, can I?
10:05:38 <BMeph_> pozic: They're smaller than 0 as well. That's my point, though. I want to get the potential index in my result, but not use it to get the next index if it's invalid.
10:08:04 <Taggnostr> it's working
10:08:35 <rwbarton> cnwdup: No, probably not.
10:09:04 <rwbarton> cnwdup: How are you storing all this state?  IORefs?
10:09:28 <gchin> if I have some value x = *some expression* is that a nice way to force evaluation of x's expression?
10:09:38 <cnwdup> rwbarton: Nope. Simply by a list of all the plugin states. Those states are instances of the PluginClass.
10:09:55 <gchin> I don't actually use x's value for a while but I don't want it storing up a lazy expression since that's causing me memory issues
10:10:05 <Deewiant> gchin: naming something isn't sufficient to evaluate it
10:10:12 <rwbarton> cnwdup: OK
10:10:23 <Asgaroth> gchin: That expression wouldn't be evaluated unless you use it somewhere.
10:10:35 <cnwdup> rwbarton: So can I somehow avoid the problem I am facing with using existential types?
10:10:44 <Deewiant> gchin: the 'seq' combinator can be used to evaluate it.
10:11:09 <rwbarton> cnwdup: I'm still wondering about questions like, say plugin X wants to talk to plugin Y somehow, but you have two copies of Y in your list, or zero, or something
10:11:26 <Taggnostr> can I do something like [2,3..20,2] if I want 2,3,5,7,9,11...
10:11:32 <Taggnostr> ?
10:11:36 <Deewiant> no
10:11:42 <Deewiant> but you can do
10:11:45 <int-e> Taggnostr: 2 : [3,5..20]
10:11:49 <Deewiant> that, yeah.
10:11:52 <Taggnostr> oh, right
10:11:59 <Deewiant> or [2] ++ [3,5..20]
10:12:25 <rwbarton> or even [2] ++ [3,5..19]  :)
10:12:29 <Taggnostr> that was the alternative I thought but it wasn't elegant enough, but 2 : is fine
10:12:39 <cnwdup> Plugins are unique. Thus theres only one state in the plugin state's list. (Or none.) Each plugin can access the list of plugin states. If it wants to communicate to a plugin, it's getting the state from the list and then calls a function on that. Since its an existential type, the function cannot be arbitrary. And that's my problem.
10:12:49 <Asgaroth> int-e's suggestion should even be slightly more efficient, since it only conses one time less.
10:12:58 <cnwdup> *one state for each plugin.
10:13:08 <Deewiant> Asgaroth: they compile to the same code, I'm fairly sure I've checked it once.
10:13:28 <cnwdup> rwbarton: Communication is limited to "ask and maybe get something back", though.
10:13:42 <Asgaroth> Deewiant: Ok, then I withdraw my statement :-)
10:13:50 <gchin> Deewiant: just what I was looking for, thanks
10:14:07 <rwbarton> cnwdup: This sounds like a job for Data.Typeable.  Otherwise, you will probably end up more or less reimplementing it
10:14:18 <rwbarton> cnwdup: this is a problem you'd solve with a downcast in an object-oriented language?
10:16:20 <cnwdup> I don't know. I come from C where I could always call every function on anything (directly or using casts.) I never used a real oop language at all, especially not with strong static typing.
10:16:27 <rwbarton> cnwdup: (you might also look into HList)
10:17:11 <rwbarton> cnwdup: Right, so in C you'd effectively use a discriminated union to make sure you have the right kind of plugin?
10:17:35 <rwbarton> cnwdup: Or you'd just have a global variable for each plugin, maybe.
10:18:37 <cnwdup> I think I would use a structure which carries the restricted set of functions as callbacks as well as the plugin's state and then just call abitrary functions on these structures.
10:19:11 <int-e> cnwdup: I think you can either fix the potential inter-plugin protocols (in which case you really only need an ADT for a plugin), or, if you want something extensible, have a good look at Data.Typeable and rwbarton's other suggestions.
10:19:48 <cnwdup> int-e: Ok. I think I'll do the latter one. (-:
10:21:11 <cnwdup> By looking at the description, hlist might be exactly what I need. (-:
10:21:24 <Taggnostr> I'm going to do something crazy
10:22:06 * vixey curls up in a ball
10:22:24 <byorgey> Taggnostr: go for it!
10:22:41 <byorgey> ...what are you going to do?
10:23:01 <Taggnostr> I can't convert in code my crazy idea
10:23:21 <BMeph> For anyone interested, my "project" is re-writing the Free Tree algorhythm in a functional form.
10:23:33 <byorgey> vixey: a fetal-position sort of ball, or a contented-small-animal sort of ball?
10:23:45 <vixey> worried-small-animal :)
10:24:11 <vixey> what is Free Tree algorithm?
10:24:26 <byorgey> vixey: I see.  what are you worried about?  unless you don't want to say.
10:24:39 <vixey> what Taggnostr might od
10:24:54 <Taggnostr> I can't think functional enough :\
10:24:54 <byorgey> oh! hehe
10:25:02 <Taggnostr> you are safe, for now
10:26:06 <byorgey> Taggnostr: not being able to think functionally enough makes you more dangerous, not less ;)
10:26:29 <byorgey> Taggnostr: you'll get there, it takes practice.  what are you trying to do?
10:27:08 <Taggnostr> write a function that finds prime factors of a number
10:27:45 <SamB_XP> depending on the problem, I might write imperative code for that ;-)
10:27:58 <Taggnostr> I already did that
10:28:10 <vixey> No this is very elegant written in a functional style
10:28:12 <SamB_XP> ... in Haskell
10:28:33 <vixey> Taggnostr: Have you seen this memoization technique in haskell?
10:28:52 <SamB_XP> (actually, I was thinking of the part where you find the primes in the first place ;-)
10:29:10 <vixey> (this memo. routines works excellently for this program)
10:29:16 <byorgey> what do you need memoization for?
10:29:17 <Taggnostr> this is like the second program I'm doing with haskell, so I don't think so, I might know what it is though
10:29:54 <SamB_XP> Taggnostr: which problem are you doing ?
10:30:11 * SamB_XP wishes he could remember them by #
10:30:12 <vixey> fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) -- if you start with this, you'll soon realize it's horribly inefficient
10:30:21 <vixey> so you make it linear time,
10:30:29 <vixey> fib 0 = 0 ; fib 1 = 1 ; fib n = fib' (n-1) + fib' (n-2)
10:30:31 <BMeph> vixey: Free trees as in undirected acyclic graphs where no node has a "special" (i.e., "root") status. I think I got that right.
10:30:34 <SamB_XP> vixey: that doesn't even find primes
10:30:37 <vixey> fib' n = fibs !! n
10:30:40 <BMeph> I'm still digging for the paper... :)
10:30:42 <vixey> fibs = map fib [0..]
10:31:21 <byorgey> Taggnostr: the simplest way is to find the smallest divisor d of n, then recurse on (n `div` d)
10:31:36 <vixey> Taggnostr, (may want to try it out and compare fibs 10 or something in terms of execution speed), but the idea is that you can use an infinite list of primes together with the factorizing program in this fashion
10:31:53 <byorgey> so for example, to find all prime factors of 24, you would first find 2, then recurse to find factors of 12, which would find 2, and recurse on 6, and so on
10:32:13 <byorgey> there are lots of way to make that more efficient, but if this is only your second Haskell program ever, that's a great start =)
10:32:15 <Taggnostr> I did factors n = take 1 filter (\x -> n `mod` x == 0) (2:[3,5..(n `div` 2)])
10:32:21 <vixey> BMeph, but what's the algorithm?
10:32:35 <vixey> Taggnostr, shouldn't tha be isqrt instead of div 2?
10:32:45 <Taggnostr> now I should divide n by the number that I've found and repeat until n reaches 1
10:32:46 <byorgey> Taggnostr: oh, you want to find *all* divisors, or just the prime factors?
10:33:02 <byorgey> Taggnostr: oh, I see, sure, that works well
10:33:03 <BMeph> Here's the paper I'm working with: http://www.cs.auckland.ac.nz/compsci720s1c/lectures/mjd/treenotes.pdf
10:33:08 <Taggnostr> just the prime factors
10:33:11 <lambdabot> Title: Constant Time Generation of Free Trees, http://tinyurl.com/6ovr9s
10:33:13 <byorgey> Taggnostr: note you will need parentheses around the  filter ...
10:33:25 <BMeph> Well, my wife's insisting on breakfast, so I'll BBL. :)
10:33:26 <Taggnostr> and maybe yes, isqrt could be better
10:33:27 <byorgey> Taggnostr: otherwise it gets parsed as  (take 1 filter) (\x ...)
10:33:35 <Taggnostr> yes, that too
10:33:54 <byorgey> there isn't an isqrt function in the standard libraries, unfortunately
10:33:58 <byorgey> that would be really nice
10:34:44 <byorgey> Taggnostr: my advice would be to get it working with n `div` 2 first
10:35:57 <byorgey> Taggnostr: so maybe call that function 'smallestFactor', then write 'factor' so that it computes the smallestFactor and decides what to do based on that
10:36:33 <telexicon> monads :(
10:37:05 <Taggnostr> ok, I hoped to do all in one step, but for now I can do that
10:38:11 <byorgey> Taggnostr: breaking things down into smaller steps is almost always a good idea =)
10:38:29 <byorgey> telexicon: monads! =)
10:39:26 <byorgey> telexicon: just venting some general frustration, or do you have specific questions we can help you with?
10:39:32 <Taggnostr> yes, until you find out that you can just use that factors function in the stdlib (but I checked, it's not in the prelude)
10:39:53 <byorgey> hehe, there's no factors function in the standard libraries that I know of
10:40:15 <byorgey> although there certainly are efficient implementations of factorization in various packages available on hackage
10:40:29 <telexicon> im trying to understand them
10:41:00 <byorgey> telexicon: ok, how far have you gotten?
10:41:38 <SamB_XP> telexicon: I eventually decided that trying to come up with a thing to say that they are was silly and moved on
10:41:39 <pastorn> is there any way to ensure that stdin is empty?
10:41:51 <pastorn> since
10:41:56 <SamB_XP> < /dev/stdin
10:42:00 <SamB_XP> er.
10:42:04 <SamB_XP> < /dev/null
10:42:05 <pastorn> escape sequences aren't of fixed length
10:42:06 * SamB_XP silly
10:42:31 <SamB_XP> pastorn: generally there is some way to determine whether they are complete or not
10:42:42 <pastorn> i want to avoid calling getChar when there is no char left from the last keypress
10:43:49 <pastorn> and i don't want to write code to catch all kinds of escape sequences
10:44:12 <SamB_XP> what be you writing ?
10:44:33 <pastorn> SamB_XP: a clone of LightBot
10:44:43 <pastorn> since its interface sucked major ass
10:44:59 <SamB_XP> what is that ?
10:45:03 <pastorn> flash game
10:45:26 <pastorn> anyway, i have a nice little grid which is used to enter input
10:45:27 <SamB_XP> and ... why aren't you using an appropriate library ?
10:45:40 <pastorn> SamB_XP: not h4xx0r enough
10:45:45 <SamB_XP> or at least semi-appropriate ?
10:46:20 <pastorn> SamB_XP: that way i wouldn't really learn anything, would i
10:46:31 <pastorn> besides, i don't need any more dependencies
10:46:41 <SamB_XP> what have you got already ?
10:47:10 <pastorn> unicode and hscolor
10:47:49 <pastorn> anyway, that's not the issue, i want to be able to clar out stdin, how do i do that?
10:47:53 <pastorn> hFlush stdin?
10:48:33 <hukolele> how can i select a xml attribute in HaXml... keep /> tag "personnel" /> tag "player" /> attr "name" does not works
10:49:06 <mauke> pastorn: no
10:49:09 <rwbarton> pastorn: flushing only makes sense on output file handles
10:49:12 <mauke> You Do Not Clear Stdin
10:49:22 <hukolele> (keep /> tag "personnel" /> tag "player" )`o` deep (attr "name")  also not works
10:50:18 <pastorn> mauke: so what can i do? i know there's only one keypress and i want to ignore the rest of the chars generated by that
10:50:19 <SamB_XP> I really would suggest use of an appropriate library, complete with appropriate information regarding different types of terminals ...
10:50:35 <pastorn> so i have a struture data KeyPress = Char Char
10:50:44 <pastorn> Digit Int
10:50:54 * pastorn can't make the pipe sign
10:51:07 <SamB_XP> you can't type | ?
10:51:08 <Taggnostr> how can I get the first element of a list?
10:51:09 <rwbarton> pastorn: like, the user presses ESC and you want to process it as one character?
10:51:25 <pastorn>  / ArrowUp / BackSpace / Escape / ... / Other
10:51:37 <pastorn> Taggnostr: head
10:51:45 <rwbarton> that's not how terminals work, sadly
10:51:53 <pastorn> SamB_XP: just installed the new ubuntu, it messed with xmodmap
10:52:01 <Taggnostr> thanks
10:52:14 <SamB_XP> pastorn: what the heck did you do that for ?
10:53:15 <Ste> hi all
10:53:27 <pastorn> rwbarton: almost, user presses a key that's bound to an escape sequence, i WANT to grab U/D/L/R-arrow or some other in my KeyPress datatype, everything else should default to the Other instance in my KeyPress
10:53:58 <pastorn> and if it's going to other i have no sure way of knowing how long the sequence is
10:54:13 <Ste> i'm brand new to haskell, can anyone recommend some good beginner resources :-)
10:54:28 <Ste> do you guys have an FAQ at all that could answer some elemetary questions?
10:54:30 <byorgey> hi Ste, welcome
10:54:34 <Ste> thank you :-)
10:54:35 <pastorn> so i risk calling getChar and have to wait for yet *another* keypress because stdin was empty
10:54:50 <pastorn> Ste: wikibooks is nice :)
10:55:01 <byorgey> @where wikibook
10:55:02 <lambdabot> http://en.wikibooks.org/wiki/Haskell
10:55:15 <pastorn> Ste: any previous programming experience?
10:55:20 <byorgey> @google learn you a haskell
10:55:24 <lambdabot> http://learnyouahaskell.com/
10:55:24 <lambdabot> Title: Learn You a Haskell for Great Good!
10:55:31 <byorgey> @where RWH
10:55:31 <Ste> i have that page book marked :-)
10:55:32 <lambdabot> is http://www.realworldhaskell.org/blog/
10:55:32 <Samy> Ste, http://www.realworldhaskell.org/blog/ http://learnyouahaskell.com/
10:55:35 <rwbarton> pastorn: waiting for another keypress seems like an orthogonal problem to handling escape sequences
10:55:37 <lambdabot> Title: Real World Haskell
10:55:46 <pastorn> yeah, that one's kinda awesome (learn you a haskell)
10:55:48 <rwbarton> pastorn: Are you doing something else while waiting for keyboard input?
10:55:49 <byorgey> Ste: also, if you have questions, we are happy to answer them here
10:55:55 <mauke> if you're dealing with keypresses, don't use stdin
10:56:05 <byorgey> asking here is usually the easiest way to get a few questions answered quickly
10:56:29 <pastorn> rwbarton: no, but the real problem is that i can't know how many Chars the escape sequence is
10:57:10 <rwbarton> pastorn: write a function like this: processEscapes ('\e':xs) = escape xs; processEscapes (x:xs) = x : processEscapes xs;
10:57:21 <Taggnostr> ghci it's complaining about No instance for (Show ([Int] -> [Int])), what should I do?
10:57:37 <rwbarton> escape ('[':'A':xs) = LeftArrow : processEscapes xs; ...; escape xs = Other | processEscapes xs
10:57:38 <byorgey> Taggnostr: apparently you are trying to print out a function.
10:57:40 <mauke> Taggnostr: don't try to display functions
10:57:40 <Ste> i'm going to ask a question, it could be massively retarded, so please go easy on me :-) i'm a little uncomfortable with the concept of a purely functional language, the reason i find it hard to grasp is because i understand a functional language to be on that does not require the storage of mutable state. However, how can you have a tangible output from a program (for example, write to a framebuffer) without such output?
10:57:40 <pastorn> Taggnostr: apply arguments to that function
10:57:49 <Taggnostr> uhm
10:57:55 <byorgey> Taggnostr: that can commonly happen if you don't give enough arguments to a function on the ghci command line
10:58:04 <Taggnostr> oh right
10:58:04 <byorgey> for example:
10:58:08 <byorgey> > (+) 3 4
10:58:10 <lambdabot>   7
10:58:12 <byorgey> > (+) 3
10:58:13 <lambdabot>       Overlapping instances for Show (t -> t)
10:58:13 <lambdabot>        arising from a use of `s...
10:58:23 <mauke> Ste: by having the functional program return an imperative program, which is then executed
10:58:23 <byorgey> well, different error message, but same idea =)
10:58:26 <Ste> one**
10:58:35 <Taggnostr> I was missing an argument
10:58:42 <karan> >
10:58:49 <karan> > (+) 3 2
10:58:50 <lambdabot>   5
10:58:52 <karan> :(
10:58:54 <Ste> this is probably my warped imperative language brain nagging at me
10:59:23 <byorgey> Ste: your intuition is good; all languages, even purely functional ones, have to be able to produce *some* sort of effects, otherwise they are useless. =)
10:59:36 <byorgey> Ste: as Simon Peyton-Jones says, they just "make the box get hot" =)
10:59:47 <byorgey> Ste: the question is how those effects are controlled.
10:59:58 <pastorn> rwbarton: that processEscapes might work...
11:00:27 <pastorn> or maybe i should look at a lib...
11:00:28 <Taggnostr> it works \o/
11:00:29 <byorgey> Ste: Haskell has a very clean separation -- enforced by the type system -- that separates code which is allowed to have effects (like writing to a frameBuffer) and code that isn't
11:01:54 <pastorn> Ste: when you feel up to it here's a quite nice description of this magical "other side of the barrier"
11:01:57 <pastorn> http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
11:01:59 <lambdabot> Title: [Haskell-cafe] there's a monster in my Haskell!, http://tinyurl.com/y49m75
11:02:31 <mauke> ew, no
11:02:34 <mauke> that's about monads
11:02:54 <pastorn> i thought that was what byorgey was talking about
11:02:57 <mauke> http://mauke.ath.cx/stuff/haskell/how-to-io.html
11:02:58 <lambdabot> Title: Haskell: How To IO
11:03:14 <byorgey> well, I was talking about the IO monad in particular
11:03:14 <rwbarton> pastorn: I don't think there's any way around the fact that the user might type some control sequence you haven't thought of--the result being that some random characters end up in the input stream
11:03:20 <rwbarton> I accidentally IO?
11:03:28 <rwbarton> @faq can Haskell accidentally IO?
11:03:28 <lambdabot> The answer is: Yes! Haskell can do that.
11:03:31 <byorgey> Ste: anyway, I wouldn't worry about it for now =)
11:03:46 <Liquid_Fire> i have a newb-ish question: i'm defining (+) for my own data type, and in the definition i use (+) on two Floats, yet when i run it it complains that + (in the definition) is ambiguous and could refer either to my + or to Prelude.+
11:04:05 <Cale> Liquid_Fire: (+) is a typeclass method
11:04:11 <Cale> Liquid_Fire: Are you writing an instance of Num?
11:04:15 <pastorn> rwbarton: and there's no way to know that the input stream is empty?
11:05:15 <pastorn> :t hIsEOF
11:05:16 <lambdabot> Not in scope: `hIsEOF'
11:05:24 <rwbarton> pastorn: what if the user just types really fast? :)
11:05:25 <Cale> Ste: Basically, we handle I/O by representing "stuff to do" using values. Eventually the 'main' of your program ends up being one of those values.
11:05:31 <Liquid_Fire> Cale: no
11:05:41 <rwbarton> pastorn: You might be able to put stdin in nonblocking mode
11:05:50 <mauke> Liquid_Fire: then you've defined a completely separate (+)
11:06:04 <mauke> and you need to tell the compiler which one you intend to use in each case
11:06:07 <Cale> Liquid_Fire: You can either hide the Prelude's definition entirely, or disambiguate by explicitly qualifying them
11:06:23 <Ste> sorry was disconnected if anyone was able to answer my question :-)
11:06:25 <Liquid_Fire> so i have to write Prelude.+?
11:06:36 <Cale> Liquid_Fire: If you want to redefine +, yes
11:06:40 <mauke> Ste: http://mauke.ath.cx/stuff/haskell/how-to-io.html
11:06:41 <lambdabot> Title: Haskell: How To IO
11:07:01 <Cale> Ste: Basically, we handle I/O in Haskell by representing stuff to be done using values.
11:07:20 <Ste> mauke: thanks :-)
11:07:30 <Cale> Ste: That is, a value of type (IO t) represents some stuff, which if done, would produce a value of type t.
11:07:49 <Cale> Ste: You might think of it as the source code for a C program, if it helps.
11:08:32 <Cale> There are in turn various operations for gluing actions of type (IO t) together into more complicated programs.
11:08:32 <rwbarton> Ste: You could also think of it as a function (with no arguments) returning type t, but function in the C sense, not the Haskell sense
11:08:54 <Ste> thanks guys
11:09:05 <Ste> immensely helpful :-)
11:09:16 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO -- my own quick intro is here :)
11:09:17 <lambdabot> Title: Introduction to IO - HaskellWiki
11:10:08 <Cale> It's important to point out, I think, that the fact that IO happens to be a monad in Haskell is somewhat irrelevant. The more important idea is that effects can be represented with values.
11:10:09 <mofmo1> I have a question about arrows: if arrows are generalizations of monads, doesn't that simply just mean arrows arrows are generalization of combinators
11:10:18 <Taggnostr> where can I paste my code?
11:10:26 <Cale> mofmo1: hm?
11:10:37 <Cale> Taggnostr: hpaste.org
11:10:43 <Taggnostr> thanks
11:11:04 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/ is also good :)
11:11:15 <mofmo1> well it seems like the point of a monad is to be able to have bind, and bind is sort of a "linear" combinator
11:11:25 <mofmo1> i mean, it only shuttles data in one direction
11:11:38 <mofmo1> or at least, in one way
11:11:39 <Cale> okay
11:11:53 <mofmo1> whereas arrows lets you move things arrow in a two dimensional manner sort of
11:11:55 <Taggnostr> http://hpaste.org/11667 may I have some feedback?
11:12:10 <Ste> i don't know what a monad or bind is :-)
11:12:22 <mofmo1> so essentially, with arrows you can define any combinator using >>> &&& and ***
11:12:28 <pastorn> gaaaah! why can't stdin end in
11:12:28 <mofmo1> unless im totally wrong
11:12:31 <pastorn> EOF
11:12:35 <mauke> Ste: yeah, just ignore that :-)
11:12:38 <mauke> pastorn: it does
11:13:07 <pastorn> i can't get hIsEOF stdin to work
11:13:16 <pastorn> or maybe i need to compile it for it to work
11:13:21 <mauke> what is your stdin connected to?
11:13:34 <pastorn> mauke: ehm.... nothing?
11:13:38 <mauke> impossible
11:13:41 <pastorn> keyboard?
11:13:42 <Liquid_Fire> well say i'm making a Vector type, is there no way to make it call the Vector (+) when i give it Vectors as arguments and call the normal (+) when it's called with a Num? (without writing Prelude.+, etc every time)
11:13:43 <Cale> mofmo1: It's not clear that every combinator library is in some sense an arrow...
11:13:44 <pastorn> dunno
11:13:48 <mauke> ok, the terminal
11:13:53 <pastorn> ok
11:14:07 <mauke> if the terminal is in raw mode, you won't see EOF
11:14:18 <Saizan_> Taggnostr: in haskell it's best to avoid accumulators like l in factors
11:14:21 <Cale> Liquid_Fire: You should use a different symbol for vector addition.
11:14:24 <mauke> if it's in cooked mode, the user can type ^D
11:14:44 <mofmo1> do i have my definition of combinator wrong? I see it as a way to take just functions in order to produce new functions
11:14:47 <Taggnostr> Saizan_, how can I avoid it?
11:14:54 <pastorn> hmm... cooked mode? is that controlled by some cool escape sequence?
11:14:54 <mofmo1> high level functions that only take functions essentially
11:15:01 <Saizan_> ?src map
11:15:01 <lambdabot> map _ []     = []
11:15:01 <lambdabot> map f (x:xs) = f x : map f xs
11:15:30 <mauke> pastorn: man termios (warning: Not Fun)
11:15:40 <Saizan_> Taggnostr: factors n = let sf = smallestFactor n in sf : factors (n `div` sf)
11:15:44 <pastorn> mauke: hehe
11:15:47 <pastorn> thanks
11:15:54 <Taggnostr> :O
11:16:07 <Saizan_> and factor 1 = []
11:18:12 <pastorn> SEE ALSO
11:18:14 <pastorn>        termios(3)
11:18:25 <mofmo1> cale: i guess i'm dead wrong eh?
11:18:25 <pastorn> mauke: man 3 termios doesn't work :/
11:18:26 <Cale> mofmo1: I generally see combinator libraries as libraries where you have a bunch of primitive values and then ways of combining them.
11:18:37 <Cale> mofmo1: at least, in the broadest sense
11:18:40 <Saizan_> Taggnostr: you usually want your function to produce values as soon as it can, to exploit laziness
11:18:57 <Cale> mofmo1: It's not clear that there will always be a way which corresponds to the Arrow combinators.
11:18:59 <mauke> pastorn: http://linux.die.net/man/3/termios
11:19:00 <lambdabot> Title: 1b termios(3) - Linux man page 9
11:19:03 <mofmo1> ah i see
11:19:18 <pastorn> mauke: oh, happy day
11:19:22 <mofmo1> i was reading the yampa tutorial and apparently they're supposed to be complete
11:19:52 <mofmo1> i guess not complete in the sense of being able to define all combinators? but if they're used to combine functions into functions would they be in that sense complete
11:21:22 <mofmo1> as an aside, why aren't arrows taught before monads? they seem conceptually easier than monads
11:21:52 <sjanssen> mofmo1: for one, Monads are in Haskell '98, and you need them to do IO
11:22:01 <sjanssen> I guess that's two reasons :)
11:22:10 <mofmo1> well, you can handwave around the io part
11:22:17 <dolio> I'm not sure arrows are easier.
11:22:40 <mofmo1> i must have too naive a view of arrows then perhaps
11:23:09 <dolio> Most everything I've seen people do with arrows, I've seen other people come along and say, "arrows aren't the best abstraction for that."
11:23:42 <Saizan_> starting with Applicative might make more sense
11:23:58 <Taggnostr> when I have a list of lists, is there a way to print each list on a line?
11:24:16 <mauke> yes, e.g. mapM_ print list
11:24:17 <idnar> Applicative still confuses me a bit
11:24:28 <vixey> putStrLn . unlines
11:24:31 <idnar> I guess I need to think "f a b c" when I see f <$> a <*> b <*> c
11:24:45 <vixey> . [$i| (,) "foo" "bar" ]
11:24:49 <vixey> , [$i| (,) "foo" "bar" |]
11:24:58 <vixey> luna :(
11:24:59 <lunabot>  [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('...
11:25:27 <Saizan_> , [$i| ((,,) ()) "foo" "bar" |]
11:25:32 <lunabot>  luna: Couldn't match expected type `f a' against inferred type `()'
11:25:41 <idnar> so why isn't there a Control.Applicative.Instances?
11:25:56 <vixey> that's odd
11:26:10 <vixey> , let h = ((,,) ()) in [$i| h "foo" "bar" |]
11:26:12 <Saizan_> most instances are defined in Control.Applicative directly, i think
11:26:15 <lunabot>  [((),'f','b'),((),'f','a'),((),'f','r'),((),'o','b'),((),'o','a'),((),'o'...
11:26:29 <vixey> well that doesn't make sense
11:26:40 <vixey> , [$i|  ((,,)()) "foo" "bar" |]
11:26:45 <lunabot>  luna: Couldn't match expected type `f a' against inferred type `()'
11:26:53 <dolio> , let zap = [1,2,3] ; zop = [4,5,6] in [$i| (,) zap zop |]
11:26:55 <vixey> ohh
11:26:57 <lunabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:27:02 <vixey> , [$i|  (,,) () "foo" "bar" |]
11:27:04 <vixey> it's that
11:27:07 <lunabot>  luna: Couldn't match expected type `f a' against inferred type `()'
11:27:34 <Saizan_> yeah, it's not a very compositional syntax
11:27:53 <vixey> I think it unfolds the applications, so it doesn't notices parens
11:27:55 <dolio> , let zap = [1,2,3] ; zop = [4,5,6] in [$i| (((,) zap) zop) |]
11:28:00 <lunabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:30:53 <dolio> , let foo = (+5) ; bar = (+4) in [$i| foo (bar [1..5]) |]
11:30:57 <lunabot>  luna: No instance for (GHC.Num.Num [a])
11:31:42 <Taggnostr> is there a way to delete a function that I defined in ghci?
11:32:09 <Saizan_> no, but if you define a new one with the same name you'll just shadow the older
11:40:04 <Taggnostr> I guess that in ghci I can't define the same function twice, right?
11:40:15 <vixey> ??
11:40:23 <vixey> you make the green light both ways?
11:40:43 <Taggnostr> I mean like let foo 1 = 1; let foo 2 = 2;
11:40:44 <mofmo1> so from what applicative is telling me
11:40:54 <mofmo1> you can have a function INSIDE A FUNCTOR?! 0_0
11:41:03 <idnar> you can have any value inside a functor
11:41:06 <idnar> and a function is a value
11:41:07 <dolio> Why not?
11:41:17 <dolio> @type [(+), (-), (*)]
11:41:18 <lambdabot> forall a. (Num a) => [a -> a -> a]
11:41:21 <idnar> > [(+1), (*2)] <*> [1,2,3]
11:41:23 <lambdabot>   [2,3,4,2,4,6]
11:41:28 <mofmo1> oh right
11:41:33 <mofmo1> you can have lists of functions
11:41:42 <rwbarton> Taggnostr: that defines two separate functions foo, and the second shadows the first
11:41:45 <idnar> > (pure (+2)) <*> [1,2,3]
11:41:46 <lambdabot>       Ambiguous occurrence `pure'
11:41:46 <lambdabot>      It could refer to either `Control.Appl...
11:41:49 <idnar> bah
11:42:06 <idnar> > (+2) <$> [1,2,3]
11:42:07 <lambdabot>   [3,4,5]
11:42:13 <rwbarton> Taggnostr: but you can write  let foo 1 = 1; foo 2 = 2
11:42:18 <rwbarton> Taggnostr: that is a single definition
11:42:21 <idnar> > (+) <$> [1,2,3] <*> [10,11,12]
11:42:22 <lambdabot>   [11,12,13,12,13,14,13,14,15]
11:42:46 <Taggnostr> I'm trying with an if/else right now, but I have some problem
11:43:20 <Beelsebob> > let (<^) = flip (<$>); (^>) = (<*>) in [1,2,3] <^(+)^> [10,11,12]
11:43:21 <lambdabot>   [11,12,13,12,13,14,13,14,15]
11:43:29 <Beelsebob> infix liftA2 ftw
11:45:43 <Saizan_> Taggnostr: you want "let foo 1 = 1; foo 2 = 2"
11:46:01 <Saizan_> Taggnostr: that'll define a function foo that's id for 1 and 2
11:46:25 <Taggnostr> I also have guards in one of them
11:46:39 <rwbarton> Taggnostr: You should probably just be defining it in a .hs file.
11:47:09 <mofmo1> > (head ((+) <$> [3,4,5])) 3
11:47:11 <lambdabot>   6
11:47:18 <mofmo1> functors are AWESOME
11:54:15 <ertai> the ghc docs this hardly br0ken e.g. http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html
11:54:17 <lambdabot> Title: Data.Array, http://tinyurl.com/5d8233
11:54:25 <ertai> s/this/seems/
11:54:54 <mmorrow> currently running runhaskell Setup.lhs haddock --hoogle --executables --internal --hyperlink-source  on ghc-6.10.1
11:55:15 <ertai> mmorrow: OK this can be the reason :)
11:55:27 <mmorrow> hmm?
11:55:30 <mmorrow> ah
11:55:54 <sjanssen> ertai: you can see Data.Array.IArray for the actual docs
11:55:57 <mmorrow> i just pasted that without having read any context before
11:56:11 <sjanssen> sometimes haddock isn't smart enough to link to the real definitions
11:56:31 <Beelsebob> hmm, I wonder if it works for infixed prefix functions...
11:56:37 <Taggnostr> Saizan_: http://hpaste.org/11668
11:56:49 <Beelsebob> > let (<^) = flip (<$>); (^>) = (<*>); plus = (+) in [1,2,3] <^`plus`^> [10,11,12]
11:56:50 <lambdabot>   <no location info>: parse error on input ``'
11:56:52 <Beelsebob> aww
11:56:53 <Beelsebob> :(
11:57:21 <Deewiant> > let (<^) = flip (<$>); (^>) = (<*>); plus = (+) in [1,2,3] <^plus^> [10,11,12]
11:57:22 <Beelsebob> > let (<^) = flip (<$>); (^>) = (<*>); plus = (+) in [1,2,3] <^(plus)^> [10,11,12]
11:57:23 <lambdabot>   [11,12,13,12,13,14,13,14,15]
11:57:23 <lambdabot>   [11,12,13,12,13,14,13,14,15]
11:57:27 <Beelsebob> ohhhhhh
11:57:27 <Beelsebob> shiny
11:57:31 <Beelsebob> even better
11:57:54 <sjanssen> <^ ^> is cool
11:58:00 <ertai> sjanssen: thanks for the workaround
11:58:10 <Deewiant> > liftM2 (+) [1,2,3] [10,11,12]
11:58:11 <lambdabot>   [11,12,13,12,13,14,13,14,15]
11:58:22 <Beelsebob> Deewiant: yeh -- infix liftA2 is really nice though
11:58:38 <Beelsebob> I often find liftA2 uglifies code purely because it stops things being infix
11:59:34 <Beelsebob> I applied for space for a micro-package for it on c.h.o -- it makes me wonder if we should make a centralised package for "cool stuff that should be in the standard libraries like if'"
11:59:36 <Saizan_> Taggnostr: http://hpaste.org/11668#a2
11:59:43 <mmorrow> crap:
11:59:44 <mmorrow> haddock: internal Haddock or GHC error: renameDecl
11:59:44 <vixey> > inits [1..]
11:59:45 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
11:59:53 <mmorrow> dies with no imformation
12:00:00 <mmorrow> s/m/n/
12:00:13 <idnar> @type liftA2
12:00:14 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:00:15 <mmorrow> it's not even sure who was at fault
12:00:21 <idnar> @type <*>
12:00:21 <vixey> > tail . inits [2..] >>= id
12:00:22 <lambdabot> parse error on input `<*>'
12:00:22 <lambdabot>   Couldn't match expected type `a -> [a1]'
12:00:28 <idnar> @type (<*>)
12:00:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:00:29 <vixey> > (tail . inits [2..]) >>= id
12:00:30 <lambdabot>   Couldn't match expected type `a -> [a1]'
12:00:43 <idnar> @type (\f a b c -> f <$> a <*> b <*> c)
12:00:44 <sjanssen> vixey: >>= id is wrong
12:00:44 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
12:00:56 <sjanssen> erm
12:01:00 <sjanssen> no, it isn't :)
12:01:01 <Beelsebob> idnar: that's liftA3 you've got to
12:01:03 <idnar> @type (\f a b -> f <$> a <*> b)
12:01:04 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
12:01:07 <idnar> Beelsebob: yeah, whoops :P
12:01:18 <sjanssen> > (tail . inits) [2 ..] >>= id
12:01:20 <lambdabot>   [2,2,3,2,3,4,2,3,4,5,2,3,4,5,6,2,3,4,5,6,7,2,3,4,5,6,7,8,2,3,4,5,6,7,8,9,2,...
12:01:47 <dmwit> > inits [2..] >>= id
12:01:48 <lambdabot>   [2,2,3,2,3,4,2,3,4,5,2,3,4,5,6,2,3,4,5,6,7,2,3,4,5,6,7,8,2,3,4,5,6,7,8,9,2,...
12:02:07 <idnar> so I'm not sure if "f <$> a <*> b" is easier to read than "liftA2 f a b"
12:02:27 <sjanssen> idnar: I'd prefer liftA2
12:02:27 <Beelsebob> I personally think it is
12:02:35 <Beelsebob> it's more "applicative" style
12:02:36 <dmwit> It depends on the context, I think.
12:02:40 <Beelsebob> true
12:02:41 <idnar> the first one looks nicer, it just keeps confusing me :P
12:02:49 <idnar> but that's maybe just an issue of familiarity
12:02:56 <dmwit> When binding something in a do block, I use (<$>)/(<*>).
12:02:58 <Beelsebob> in most cases I find f <$> a <*> b reads more as f applied to a and b
12:03:03 <dmwit> When writing a one-liner, I usually use liftM2.
12:03:24 <idnar> I think my brain still wants to parse it as f <$> (a <*> b)
12:03:29 <sjanssen> liftA2 is more friendly to the point free style
12:03:30 <Beelsebob> yeh, ditto
12:03:36 <idnar> which is obviously wrong
12:03:40 <Beelsebob> which actually idnar -- isn't a bad parse in terms of mental model
12:03:45 <Beelsebob> in that it's the curried version
12:03:49 <Beelsebob> uncurried rather
12:03:52 <sjanssen> you might find yourself writing \x y -> f <$> x <*> y
12:03:59 <Beelsebob> tuple a and b, and pass the tuple into the function
12:04:03 <idnar> Beelsebob: yeah, that's true
12:04:14 <idnar> Beelsebob: it's just that when I start thinking about what <*> actually does, it falls apart
12:04:19 <Beelsebob> hehe
12:04:20 <Beelsebob> true
12:04:21 <sjanssen> it isn't obvious how to pointfree that, but it is more obvious with the liftA2 variant
12:04:24 <idnar> I often have this problem
12:04:30 <idnar> when I look at some code, it's intuitively obvious what it does
12:04:36 <idnar> but if I try to think about how it does what it does, then I get confused
12:04:37 <Beelsebob> sjanssen: yeh, in all honesty, that's half the advantage for me ;)
12:04:50 <idnar> I probably just need more Haskell experience, but still
12:05:35 <Beelsebob> maybe it would be clearer to you to write (pure f) <*> a <*> b?
12:05:42 <Beelsebob> then it's more obvious what's going on
12:05:58 <sjanssen> pure f <*> a <*> b -- don't add useless parens
12:06:01 <Beelsebob> stick it in an applicative, and do the curried applications
12:06:19 <Beelsebob> they aren't useless -- they aid thinking about what it's doing
12:06:30 <Beelsebob> pure f is a single unit
12:06:34 <Beelsebob> it's f, but not quite
12:06:40 <sjanssen> a is a single unit, why not parenthesize it?
12:06:52 <Beelsebob> because it's already atomic
12:07:34 <sjanssen> "pure f" is sufficiently atomic to anyone used to reading Haskell code
12:07:49 <idnar> I'd be happy with unparenthesized pure f
12:08:04 <idnar> but I might write (map a) . (filter b) or something, even though map a . (filter b) would suffice
12:08:19 <Beelsebob> yeh, that's roughly the logic I'm using idnar
12:08:21 <idnar> @type map ?a . (filter ?b)
12:08:23 <lambdabot> forall b a. (?b::a -> Bool, ?a::a -> b) => [a] -> [b]
12:08:25 <pastorn> srsly, why is hLookAhead :: Handle -> IO Char with error throwing and not :: Handle -> IO (Maybe Char)
12:08:26 <Beelsebob> although I agree it's more tenuous in this case
12:08:29 <sjanssen> idnar: (filter b) is also useless
12:08:40 <idnar> @type map ?a . filter ?b
12:08:41 <lambdabot> forall b a. (?b::a -> Bool, ?a::a -> b) => [a] -> [b]
12:08:43 <idnar> uhm
12:08:45 <pastorn> that would've made my world WAY less painfull
12:08:48 <idnar> huh
12:08:51 <Beelsebob> I don't really subscribe to the whole Haskeller's need to eliminate all parentheses
12:08:56 <idnar> now I'm confused
12:09:08 <Beelsebob> idnar: function app binds tightest
12:09:17 <idnar> yeah, I know, but I thought there was some case here that needed parens
12:09:17 <mmorrow> @pl \xs -> map g . filter f $ xs
12:09:17 <lambdabot> map g . filter f
12:09:20 <idnar> maybe I'm thinking of another one
12:09:32 <idnar> @pl \xs -> map g . filter f . filter g $ xs
12:09:32 <lambdabot> map g . filter f . filter g
12:09:33 <sjanssen> Beelsebob: it is certainly useful to use parens to disambiguate
12:09:48 <Beelsebob> sjanssen: yeh, but I guess it's subjective where it actually has an effect
12:10:01 <Beelsebob> so I'm prepared to agree to disagree on that one :)
12:10:13 <mmorrow> , (map . map . map) (*2) [[[2],[3]],[[4,5,6],[4,5]]]
12:10:13 <idnar> well, that makes sense, I guess something confused me about it before
12:10:15 <lunabot>  [[[4],[6]],[[8,10,12],[8,10]]]
12:10:32 <Beelsebob> mmorrow: fmap . fmap . fmap ftw :P
12:10:36 <idnar> mmorrow: hey, stop making my head explode!
12:10:43 <idnar> Beelsebob: what about (.) = fmap?
12:10:43 <sjanssen> (map f) . (filter p) -- is too many parens in my opinion, since it should be obvious that function application binds more tightly than all other operators
12:10:50 <BONUS> idnar: do you come from a lisp background ;)
12:10:55 <Saizan_> pastorn: hLookAhead' h = either (const Nothing) Just <$> try (hLookAhead h)
12:10:57 <idnar> BONUS: nope
12:11:00 <Liquid_Fire> how do you map to unary minus? should i just map ((-) 0) or is there a "better" way?
12:11:00 <Beelsebob> idnar: yeh, but fmap (fmap fmap fmap) fmap really isn't in any way clear ;)
12:11:03 <mmorrow> Beelsebob: always fmap for me :)
12:11:03 <Beelsebob> and it's over general
12:11:07 <idnar> BONUS: I know even less Lisp than Haskell
12:11:11 <Beelsebob> because we know fmap is working on functions there
12:11:20 <idnar> Beelsebob: nono, I mean (.) . (.) . (.)
12:11:21 <sjanssen> Liquid_Fire: map negate
12:11:30 <idnar> Beelsebob: Caleskell or whatever
12:11:40 <pastorn> Saizan_: that seems pretty awesome! did you try it?
12:11:42 <idnar> <insert H2G2 reference here>
12:11:46 <Liquid_Fire> sjanssen: ah thanks
12:11:47 <Beelsebob> idnar: oh, *that* one isn't over general -- because it you aren't allways working with functions there
12:11:56 <mmorrow> , map negate [0..9]
12:11:58 <lunabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
12:12:17 <idnar> @let gallumbits = (.) . (.) . (.)
12:12:18 <Saizan_> pastorn: no, but i trust the "try" combinator :)
12:12:18 <lambdabot>  Defined.
12:12:22 <vixey> Taggnostr, so do you want to see my version?
12:12:23 <mmorrow> , fmap negate (Node 42 (fmap return [0..9]))
12:12:25 <lunabot>  Node {rootLabel = -42, subForest = [Node {rootLabel = 0, subForest = []},...
12:12:36 <Beelsebob> > ((.) . (.) . (.)) (*2) [[[1],[2],[3]],[[4]]]
12:12:36 <Beelsebob> > (fmap . fmap . fmap) (*2) [[[1],[2],[3]],[[4]]]
12:12:37 <lambdabot>   Couldn't match expected type `a -> a1 -> a2 -> b'
12:12:38 <lambdabot>   [[[2],[4],[6]],[[8]]]
12:12:39 <Taggnostr> sure
12:12:45 <Beelsebob> idnar: that's why ;)
12:12:54 <pastorn> Saizan_: what's <
12:13:01 <pastorn> <$>?
12:13:02 <idnar> > let (.) = fmap in ((.) . (.) . (.)) (*2) [[[1],[2],[3]],[[4]]]
12:13:03 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a -> b) -> a
12:13:03 <lambdabot>    ...
12:13:04 <sjanssen> Beelsebob: did you know that you can infinitely expand that chain of fmaps?
12:13:06 <mmorrow> , (fmap . fmap) negate (Node [42..47] (fmap (return . return) [0..9]))
12:13:08 <lunabot>  Node {rootLabel = [-42,-43,-44,-45,-46,-47], subForest = [Node {rootLabel...
12:13:11 <idnar> doh
12:13:22 <Beelsebob> sjanssen: yeh I know -- it's a trick conal tought me
12:13:28 <Beelsebob> first and second also work well in there
12:13:41 <vixey> http://hpaste.org/11668#a3
12:13:41 <idnar> @type first
12:13:43 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
12:13:48 <Beelsebob> > (fmap . first) (*2) [(1,"jam"), (2,"ham")]
12:13:48 <idnar> oh yes, arrows
12:13:49 <lambdabot>   [(2,"jam"),(4,"ham")]
12:14:02 <idnar> I'm always vaguely confused about head vs. fst vs. first
12:14:06 <pastorn> :t try
12:14:07 <lambdabot> Not in scope: `try'
12:14:11 <vixey> such a great recursion pattern
12:14:14 <vixey> :p
12:14:24 <Beelsebob> idnar: head works on a different type
12:14:39 <Saizan_> :t Control.Exception.try
12:14:40 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
12:14:41 <Beelsebob> and first is similar to fst, but it applies the function without unbundling the tuple
12:14:47 <mmorrow> hehe, "surrealist approach"
12:14:51 <mmorrow> nice title
12:15:19 <vixey> Taggnostr, (this is what I was hinting at earlier with the fibs example by the way)
12:15:20 <mmorrow> makes me think of melting clocks and pomegranates
12:15:25 <Saizan_> pastorn: (<$>) == fmap == liftM, it applies a pure function inside a monadic value
12:15:44 <Beelsebob> sjanssen: also on the cards for that one -- maybe' f = Just . maybe f, and either' f g = Right . either f g
12:16:00 <Beelsebob> or alternatively either' f g = either (Left . f) (Right . g)
12:16:05 <Taggnostr> uhm
12:16:06 <Beelsebob> not sure which either' is better
12:16:42 <pastorn> Saizan_: it seems to work :)
12:16:47 <vixey> :t let either' f g = either (Left . f) (Right . g) in either'
12:16:48 <lambdabot> forall a a1 b b1. (a -> a1) -> (b -> b1) -> Either a b -> Either a1 b1
12:16:50 <pastorn> thanks, you're awesome
12:16:59 <vixey> oh right, double fmap
12:17:01 <pastorn> i'll just try this in my app now
12:17:04 <sjanssen> @type \f -> Just . maybe f
12:17:05 <lambdabot> forall b a. b -> (a -> b) -> Maybe (Maybe a -> b)
12:17:23 * mmorrow tries to remember the RightLeftRight expression
12:18:15 <idnar> Beelsebob: yeah, I know
12:18:27 <idnar> Beelsebob: it's probably just because "maximum" is sort of the list version of max
12:18:39 <idnar> Beelsebob: so I'm half expecting first to be the list version of fst
12:18:48 <mmorrow> , let rotate f = either (Right . f) (Left . f) in (rotate (rotate (rotate id))) (Left (Right (Left 42)))
12:18:50 <lunabot>  Right (Left (Right 42))
12:18:52 <mmorrow> heh
12:19:05 <Beelsebob> sjanssen: oh woops -- I meant maybe' c f = Just . maybe c f
12:19:14 <idnar> @type either
12:19:16 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
12:19:18 <Beelsebob> @type maybe' c f = Just . maybe c f
12:19:19 <lambdabot> parse error on input `='
12:19:25 <idnar> @src either
12:19:26 <lambdabot> either f _ (Left x)     =  f x
12:19:26 <lambdabot> either _ g (Right y)    =  g y
12:19:29 <sjanssen> mmorrow: neat
12:19:30 <mmorrow> , either Left Right (Right 42)
12:19:32 <lunabot>  Right 42
12:19:33 <mmorrow> , either Left Right (Left 42)
12:19:35 <lunabot>  Left 42
12:19:43 <mmorrow> , either Right Left (Left 42)
12:19:46 <lunabot>  Right 42
12:19:53 <mmorrow> idnar: ^^
12:20:14 <mmorrow> sjanssen: i like that one too
12:20:18 <idnar> heh
12:20:55 <mmorrow> , fmap (either (*2) (*10000)) [Left 2, Right 2]
12:20:57 <lunabot>  [4,20000]
12:22:00 <Beelsebob> > let either' f g = either' (Left . f) (Right . g) in (fmap . either' (*2)) (*100000) [Left 2, Right 2]
12:22:01 <lambdabot>       Occurs check: cannot construct the infinite type: b = Either b b1
12:22:01 <lambdabot>      ...
12:22:15 <Beelsebob> > let either' f g = either (Left . f) (Right . g) in (fmap . either' (*2)) (*100000) [Left 2, Right 2]
12:22:16 <lambdabot>   [Left 4,Right 200000]
12:23:36 <vixey> Taggnostr, did not make sense or something?
12:23:44 <dmwit> stevan: Did you even get xmonad built?
12:23:54 <Taggnostr> still have to parse it
12:24:16 * vixey wasn't sure what uhm means
12:25:52 <Beelsebob> > let either' f g = either (Left . f) (Right . g); maybe' c f = Just . maybe c f in (fmap . either' (*2) . maybe' 63) (*1000000) [Left 6, Right Nothing, Right (Just 2)]
12:25:54 <lambdabot>   [Left 12,Right (Just 63),Right (Just 2000000)]
12:26:26 <dmwit> :t (|||)
12:26:27 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
12:26:30 <Taggnostr> it means "i received your message but I don't have an answer ready yet because I'm still elaborating"
12:26:37 <dmwit> :t (+++)
12:26:38 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
12:26:44 <dmwit> Beelsebob: ^^
12:26:58 <dmwit> either' = (+++)
12:27:07 <Beelsebob> ohhh, so it does
12:27:20 <Beelsebob> that makes me fall into the either' f g = Right . either f g camp then
12:27:26 <Beelsebob> (essentially catchError)
12:27:39 <dmwit> Right . either f g -- matches your maybe' much better
12:27:44 <Beelsebob> indeed
12:27:47 <rwbarton> either' is probably also bimap
12:27:49 <rwbarton> , src 'bimap
12:27:55 <lunabot>  Class op from Bifunctor: bimap :: forall p r s t . Bifunctor p
12:27:55 <lunabot>                                                               r
12:27:55 <lunabot>                                                               s
12:28:05 <opqdonut> heh
12:28:08 <ddarius> Go pretty printer
12:28:29 <Beelsebob> dmwit: the problem is it doesn't do the deep application thing quite so nicely
12:28:37 <dmwit> Beelsebob: Very true.
12:28:38 <Beelsebob> in that the point is to preserve all the structure and modify deep values
12:28:40 <Heooo> I would like to practise beta-reduction and other basics in lambda calculus. Is there some program or site for this purpose?
12:28:57 <dmwit> Beelsebob: Oh, wait, I didn't understand you.  What do you mean?
12:29:09 <ddarius> Heooo: DrScheme should have some very good modes/tools for that sort of thing.
12:29:27 <Beelsebob> dmwit: conal's (fmap . fmap . first . fmap) thing -- it preserves all the structure, while modifying values deep inside
12:29:27 <Heooo> ddarius: it is a program?
12:29:30 <opqdonut> yes
12:29:35 <Beelsebob> oh actually, nor does maybe' do that
12:29:40 <dmwit> right
12:29:47 <dmwit> (though fmap does, for Maybe)
12:29:51 <Beelsebob> indeed
12:30:02 <stevan> dmwit: yes; i managed to get 0.8 running after some minor edits. :-)
12:30:13 <dmwit> stevan: Great. =)
12:30:13 <Beelsebob> and in fact, fmap does for either too -- if you don't want to touch the Left value
12:30:31 <dmwit> :t fmap . fmap . first . fmap
12:30:32 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) d a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a, d)) -> f (f1 (f2 b, d))
12:30:38 <Heooo> ddarius: thanks for the tip! I found it :]
12:30:49 <dmwit> Beelsebob: ?
12:30:55 <rwbarton> , map (bimap (+1) (*2)) [Left 3, Right 4]
12:31:00 <lunabot>  [Left 4,Right 8]
12:31:05 <dmwit> Beelsebob: Can you restrict that type for me a bit?
12:31:12 <Beelsebob> > (fmap . fmap) (*2) [[1],[2],[3,4]]
12:31:14 <lambdabot>   [[2],[4],[6,8]]
12:31:33 <Deewiant> , bimap (+1) (*2) (2,2)
12:31:38 <lunabot>  (3,4)
12:31:40 <Deewiant> sweet
12:31:44 <Beelsebob> > (fmap . fmap . first) (*2) [[(1,"jam"),(2,"ham")],[(3,"monkies)]]
12:31:45 <lambdabot>   <no location info>:
12:31:45 <lambdabot>      lexical error in string/character literal at chara...
12:31:56 <Beelsebob> > (fmap . fmap . first) (*2) [[(1,"jam"),(2,"ham")],[(3,"monkies")]]
12:31:57 <lambdabot>   [[(2,"jam"),(4,"ham")],[(6,"monkies")]]
12:32:01 <Beelsebob> dmwit: does that clarify it?
12:32:22 <Beelsebob> structure stays the same -- the function gets targetted deep inside
12:32:29 <dmwit> What functor would you want to use in the first element of the tuple?
12:32:36 <dmwit> (i.e. what are you using this for?)
12:32:51 <Beelsebob> dmwit: modifying data deep inside structure
12:33:04 <Beelsebob> so for example if you have an Event [(a,b)]
12:33:12 <Beelsebob> you can (fmap . fmap . first) to modify the a
12:33:18 <Beelsebob> or (fmap . fmap . second) to modify the b
12:33:21 <dmwit> Okay.
12:33:25 <dmwit> Gotcha.
12:33:55 <Beelsebob> and all you need do to generate the fmap/first/second sequence is read the type left to right
12:34:03 <dmwit> So, yeah, fmap does that for Maybe, left/right do that for Either.
12:34:18 <dmwit> :t left
12:34:19 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
12:34:22 <Beelsebob> oh, cool
12:36:09 <sclv> Nice. I have some bits of code that left and right might clean up.
12:37:55 <sclv> > map (left (+5)) [Left 4, Right 5, Left 6, Right 7]
12:37:56 <lambdabot>   [Left 9,Right 5,Left 11,Right 7]
12:38:16 <vixey> @src left
12:38:16 <lambdabot> Source not found. You speak an infinite deal of nothing
12:38:22 <dmwit> It's a class function.
12:38:30 <dmwit> ?src left (->)
12:38:30 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:38:38 <dons> nice. http://www.reddit.com/r/programming/comments/7aqge/fortran_versus_haskell/
12:38:40 <lambdabot> Title: Fortran versus Haskell : programming, http://tinyurl.com/5rvyn6
12:38:43 <dons> perry's work on blas bindings is great
12:38:52 <dmwit> left f (Left a) = Left (f a); left f r = r
12:38:58 <dmwit> (For function Arrows.)
12:39:28 <mmorrow> , everywhere (mkT (+1)) ((0,(0,((0,0),0))),(0,(0,0)))
12:39:30 <lunabot>  ((1,(1,((1,1),1))),(1,(1,1)))
12:39:46 <opqdonut> :)
12:41:06 <vixey> :t mkT
12:41:07 <lambdabot> forall b a. (Typeable b, Typeable a) => (b -> b) -> a -> a
12:42:48 <mmorrow> , mkT ((+1)::Int->Int) (0::Int)
12:42:49 <lunabot>  1
12:42:51 <mmorrow> , mkT ((+1)::Int->Int) (0::Integer)
12:42:52 <lunabot>  0
12:43:22 <mmorrow> , src 'everywhere
12:43:26 <lunabot>  everywhere :: (forall a . Data a => a -> a) ->
12:43:26 <lunabot>                forall a . Data a => a -> a
12:43:47 <mmorrow> ug, that tysig is mangled
12:43:56 <opqdonut> ah, now i get it
12:44:00 <rwbarton> It is?
12:44:16 <mmorrow> i believe it needs one more set of parens
12:44:24 <opqdonut> , everywhere (mkT (+1)) ((0,(0,"foo")),1)
12:44:27 <lunabot>  ((1,(1,"foo")),2)
12:44:29 <opqdonut> :))
12:44:44 <mmorrow> everywhere :: forall a.
12:44:44 <mmorrow>               (Data a) =>
12:44:44 <mmorrow>               (forall a1. (Data a1) => a1 -> a1) -> a -> a
12:44:58 <dons> ?users
12:44:58 <lambdabot> Maximum users seen in #haskell: 551, currently: 525 (95.3%), active: 20 (3.8%)
12:45:04 <dons> 551 is a lot
12:45:04 <mmorrow> i don't even know what the prettyprinter did to mangle that how it did
12:45:14 <rwbarton> > let id :: (forall a. Num a => a -> a) -> forall a. Num a => a -> a ; id x = x in id (const 3) 4
12:45:15 <lambdabot>   3
12:45:24 <mmorrow> hmm
12:45:30 <mmorrow> interesting
12:46:04 <mmorrow> @type id :: forall a. Num a => (forall a. Num a => a -> a) -> a -> a
12:46:06 <lambdabot> forall a. (Num a) => (forall a1. (Num a1) => a1 -> a1) -> a -> a
12:46:17 <mmorrow> @type id :: (forall a. Num a => a -> a) -> forall a. Num a => a -> a
12:46:18 <lambdabot> forall a. (Num a) => (forall a1. (Num a1) => a1 -> a1) -> a -> a
12:46:23 <mmorrow> @type id :: (forall a. Num a => a -> a) -> forall a. Num a => a -> forall a. Num a => a
12:46:24 <lambdabot>     Couldn't match expected type `forall a1. (Num a1) => a1'
12:46:24 <lambdabot>            against inferred type `a'
12:46:24 <lambdabot>       `a' is a rigid type variable bound by
12:47:09 <mmorrow> i never knew that was syntactically valid to do that
12:47:34 <mmorrow> @type fromIntegral
12:47:35 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:47:58 <mmorrow> @type fromIntegral :: Integral a => a -> Num b => b
12:47:59 <lambdabot>     Could not deduce (Num ((Num b) => b)) from the context (Integral a)
12:47:59 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:0-11
12:47:59 <lambdabot>     Possible fix:
12:48:00 <ddarius> mmorrow: For that example, it's clearly necessary for that to be syntactically valid (obviously not in H98)
12:48:15 <ddarius> There are other examples where GHC's parser is just more forgiving.
12:48:20 <mmorrow> @type fromIntegral :: forall a b. Integral a => a -> Num b => b
12:48:21 <lambdabot>     Could not deduce (Num ((Num b) => b)) from the context (Integral a)
12:48:21 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:0-11
12:48:21 <lambdabot>     Possible fix:
12:49:02 <rwbarton> What is the fix?!
12:49:10 <rwbarton> instance Num ((Num b) => b) where ...
12:49:17 <mmorrow> heh
12:49:44 <mmorrow> maybe that should be reported as a bug?
12:49:48 <dmwit> No.
12:49:55 <dmwit> Or...
12:49:58 <mmorrow> (Num ((Num b) => b))
12:50:02 <dmwit> Are types and classes in the same namespace?
12:50:28 <ddarius> Define data Eq and see what happens.
12:50:30 <dmwit> Hey, there's two (=>) in your program text!
12:51:00 <dmwit> Types and classes are not in the same namespace.
12:51:39 <rwbarton> @type let fi :: Integral a => a -> Num b => b; fi = fromIntegral in fi
12:51:40 <dmwit> ?type fromIntegral :: forall a. Integral a => a -> forall b. Num b => b
12:51:40 <lambdabot>     Could not deduce (Num ((Num b) => b)) from the context (Integral a)
12:51:41 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:46-57
12:51:41 <lambdabot>     Possible fix:
12:51:42 <lambdabot>     No instance for (Num (forall b. (Num b) => b))
12:51:43 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:0-11
12:51:44 <lambdabot>     Possible fix:
12:51:51 <rwbarton> @type let fi :: Integral a => a -> Num b => b; fi x = fromIntegral x in fi
12:51:52 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:52:11 <dmwit> huh
12:52:20 <dmwit> Maybe it *should* be reported as a bug.
12:52:41 <ddarius> Looks like the monomorphism restriction
12:52:51 <albdogo> hi
12:52:56 <dmwit> It looks like allowing contexts in weird places to me.
12:53:01 <rwbarton> @type let fi :: () -> Integral a => a -> Num b => b; fi  = fromIntegral x in fi
12:53:02 <lambdabot>     Could not deduce (Num (() -> Integral a -> a -> Num b -> b))
12:53:02 <lambdabot>       from the context ()
12:53:02 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:53-66
12:53:02 <ddarius> It is.
12:53:04 <albdogo> I cannot compile gtk2hs
12:53:07 <rwbarton> @type let fi :: () -> Integral a => a -> Num b => b; fi () = fromIntegral in fi
12:53:09 <lambdabot>     Could not deduce (Num ((Num b) => b)) from the context (Integral a)
12:53:09 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:55-66
12:53:09 <lambdabot>     Possible fix:
12:53:14 <mmorrow> @type fromIntegral :: forall a b. Integral a => a -> Num b => (Num b => b)
12:53:15 <lambdabot>     Could not deduce (Num ((Num b, Num b) => b))
12:53:15 <lambdabot>       from the context (Integral a)
12:53:15 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:0-11
12:53:21 <dmwit> Oh, I see why you could allow a context there.
12:53:23 <dmwit> Interesting.
12:53:25 <dmwit> and weird
12:53:35 <mmorrow> @type fromIntegral :: forall a b. Integral a => a -> Num b => (Num b => (Num b => (Num b => b)))
12:53:36 <lambdabot>     Could not deduce (Num ((Num b, Num b, Num b, Num b) => b))
12:53:36 <lambdabot>       from the context (Integral a)
12:53:36 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:0-11
12:53:40 <dmwit> albdogo: Rats.  What fails?
12:53:42 <dmwit> ?hpaste
12:53:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:53:42 <ddarius> You can, for the most part, just lift contexts outward.
12:53:53 <sclv> > foldr (flip $ \(ls,rs) -> either (\x -> (x:ls,rs)) (\x -> (ls,x:rs))) ([],[]) [Left 1, Right 2, Left 3, Right 4, Left 5, Right 6]
12:53:55 <lambdabot>   ([1,3,5],[2,4,6])
12:53:59 <albdogo> dmwit, it doesnt find glib
12:54:13 <dmwit> Have you got the glib-dev package installed?
12:54:24 <albdogo> i think not
12:54:46 <albdogo> do i make an apt-get?
12:55:22 <rwbarton> -XNoMonomorphism restriction has no effect on this result
12:55:32 <albdogo> E: Couldn't find package glib-dev
12:56:09 <dmwit> The package is called libglib2.0-dev here.
12:56:09 <albdogo> I have Ubuntu, I donnot what to do
12:56:20 <olsner> I think it's called libglib2.0-dev on ubuntu
12:56:26 <ddarius> Start synaptic, stick glib into the search.
12:56:28 <dmwit> But apt-cache search glib | grep "-dev" ought to find it for you.
12:56:37 <mmorrow> haha, bug for sure:
12:56:39 <mmorrow> , (fromIntegral :: forall a b. Integral a => a -> Num b => (Num b => (Num b => (Num b => b)))) 0
12:56:41 <lunabot>  luna: luna: panic! (the 'impossible' happened)
12:56:56 <albdogo> im gonna try taht
12:57:09 <mmorrow> > (fromIntegral :: forall a b. Integral a => a -> Num b => (Num b => (Num b => (Num b => b)))) 0
12:57:10 <lambdabot>       Could not deduce (Num ((Num b, Num b, Num b, Num b) => b))
12:57:10 <lambdabot>        from ...
12:57:28 <Deewiant> 'TcTyFuns.flattenType: unexpected PredType'
12:57:39 <mmorrow> looks like new code in 6.10 just crashes instead of spits out nonsense
12:57:42 <Deewiant> mmorrow: doesn't look like it's been reported
12:57:46 <Deewiant> :-P
12:57:53 <mmorrow> Deewiant: i'll report it
12:57:58 <albdogo> it found that thing thank you, gonna try to compile
12:58:17 <olsner> albdogo: you can also install gtk2hs directly through apt-get, e.g. libghc6-gtk-dev
12:58:48 <albdogo> here only appears the gtk2hs-doc package
12:58:51 <mmorrow> heh, notice how the error occured inside a nested eval:
12:58:56 <mmorrow> , (fromIntegral :: forall a b. Integral a => a -> Num b => (Num b => (Num b => (Num b => b)))) 0
12:58:57 <lunabot>  luna: luna: panic! (the 'impossible' happened)
12:59:01 <mmorrow> "luna: luna:"
12:59:27 <vixey> how is that impossible?
12:59:43 <mmorrow> i'm not quite sure what's happening
13:00:26 <albdogo> keeps failing
13:00:38 <albdogo> The exact error reported by pkg-config was: "No package 'pango' found
13:00:38 <albdogo> No package 'gdk-2.0' found
13:00:38 <albdogo> No package 'gdk-pixbuf-2.0' found
13:00:38 <albdogo> No package 'gtk+-2.0' found"
13:00:48 <ddarius> Yes, you need to install all the requirements.
13:00:55 <ddarius> Gtk2hs isn't going to work without gtk
13:01:33 <albdogo> it doesnt find pango
13:03:54 <albdogo> i cannot find any package
13:04:02 <albdogo> gtk2, gdk, pango..
13:04:09 <dons> albdogo: you've not installed gtk2hs ?
13:04:17 <albdogo> i cant
13:04:31 <dmwit> albdogo: Have you installed the -dev packages for each of those?
13:04:34 <dcoutts> albdogo: it needs the dev/devel versions of gtk etc
13:04:36 <dmwit> If not, do so.
13:04:42 <dcoutts> albdogo: of the system packages
13:05:44 <albdogo> i have tried all combinations
13:06:21 <albdogo> and nothing
13:08:05 <albdogo> im gonna make a reload
13:09:17 <albdogo> nothing, pango doesn't appear
13:11:36 <olsner> the package isn't called "pango", it's "libpango1.0-dev" (and for the rest of them, they'll probably have names like libfoo2.0-dev rather than foo)
13:11:46 <olsner> *on ubuntu
13:12:01 <Philly2> Hello, I am having a problem in ghc with inserting values into a Tree. http://hpaste.org/11669 . I get the error "Couldn't match type 'a' against inferred type 'Char'..". 'a' is an Ord, shouldn't it include Chars?
13:12:22 <unenough> does haskell have a logo? :P
13:12:29 <Badger> unenough: lambda
13:12:31 <albdogo> ill try that olsner
13:12:36 <unenough> oy. vey.
13:12:38 <Philly2> it blocks at line 12 with "x > letters"
13:12:43 <dmwit> Philly2: Not all "Ord" instances are Char.
13:12:53 <dons> unenough: see haskell.org
13:13:00 <dmwit> But let me look at your code before I comment further. =P
13:13:43 <dmwit> Philly2: Yeah, that's exactly the problem.
13:13:55 <olsner> Philly2: the problem is that "letter" is only a Char, while the rest of the code claims to work for all 'a's
13:14:03 <dmwit> Philly2: You're comparing something you've declared to be polymorphic over Ord instances to a single character (namely "letter").
13:14:34 <dmwit> In general, you can only compare two elements of the *same type*, which restricts your function to be tIns :: Char -> Tree Char -> Tree Char.
13:14:37 <albdogo> does anyone have tried to develop a linux kernel in Haskell¿
13:14:48 <dmwit> (Which might be fine, depending.)
13:15:02 <bos> jeepers, 525 users
13:15:11 <dmwit> Philly2: One solution is to pass also a "half-way" point to your function.
13:15:32 <dmwit> Philly2: Then compare against the half-way point; when you call tIns, then call it with "letter" as the half-way point argument.
13:15:36 <Deewiant> ?users
13:15:36 <lambdabot> Maximum users seen in #haskell: 551, currently: 525 (95.3%), active: 22 (4.2%)
13:15:41 <vixey> albdogo: I doubt that..
13:15:44 <dmwit> albdogo: Check out House.
13:15:56 <dmwit> It's an operating system (though not a Linux kernel).
13:16:08 <dmwit> (I'm not sure what it would mean to develop "a Linux kernel" in Haskell.)
13:16:15 <olsner> albdogo: there is only one linux kernel, any other kernel couldn't be a linux kernel :D (but possibly a linux-*compatible* kernel... nevertheless I don't think anyone has tried yet)
13:16:27 <roconnor> @where house
13:16:28 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
13:16:43 <roconnor> :(
13:16:47 <lispy> There is no try.  Do or do not.
13:17:00 <dmwit> ?go house haskel
13:17:02 <dmwit> ?go house haskell
13:17:04 <roconnor> Where Ho
13:17:06 <lambdabot> http://programatica.cs.pdx.edu/House/
13:17:06 <lambdabot> Title: House
13:17:07 <lambdabot> http://programatica.cs.pdx.edu/House/
13:17:08 <lambdabot> Title: House
13:17:11 <roconnor> @where Hos
13:17:11 <lambdabot> I know nothing about hos.
13:17:24 <dmwit> ?where+ house http://programatica.cs.pdx.edu/House/
13:17:24 <lambdabot> Done.
13:17:28 <roconnor> :)
13:17:34 <lispy> > do not <- [1]; return not
13:17:36 <lambdabot>   [1]
13:17:44 <roconnor> http://web.cecs.pdx.edu/~kennyg/house/
13:17:45 <lambdabot> Title: Lighthouse
13:17:58 <roconnor> House 0.8.91 (vanilla House ported to GHC 6.8.2) [October 1st, 2008]
13:18:16 <dmwit> Yeah, that should maybe be ?where's response.
13:18:18 <dmwit> Not sure.
13:18:28 <lispy> vanilla House?  vanilla is kinda light in color...hmm...White House?
13:18:43 <Philly2> ok.I understand..thanks
13:19:29 <mmorrow> , mdo not <- not; return not
13:19:31 <lunabot>  luna: parse error on input `<-'
13:19:39 <mmorrow> , mdo return 1
13:19:40 <lunabot>  luna: Not in scope: `mdo'
13:20:31 <mmorrow> , mfix
13:20:33 <lunabot>  luna: No instance for (GHC.Show.Show ((a -> m a) -> m a))
13:21:08 <dmwit> , mfix (>>= return)
13:21:11 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = m a
13:21:17 <albdogo> ive got gtk2 adn pango installed , only gdk is missing
13:21:51 <albdogo> it is compiling though
13:22:02 <necroforest> isn't gdk kind of important if you want to use gtk
13:22:27 <chrisdone> > map Data.Char.toUpper "hai guyz" ++ repeat '!'
13:22:28 <lambdabot>   "HAI GUYZ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
13:22:31 <albdogo> i only want to get gtk2hs compiled
13:23:33 <dmwit> necroforest: It depends on what you want to do, I guess.  But it does seem rather important for any GUI stuff.
13:23:53 <necroforest> gtk is a gui toolkit :P
13:24:00 <necroforest> unless it does some non-gui stuff i don't know aobut
13:24:06 <dmwit> Gtk2Hs also holds a stranglehold on Cairo bindings.
13:24:17 <dcoutts> sigh
13:24:19 <dmwit> And there's several other useful things in there that don't require an actual GUI.
13:24:39 <dmwit> dcoutts: Wait, am I wrong?  Or is that a sigh of agreement?
13:24:56 <Heooo> ddarius: Do you know whether this DrScheme shows me how to reduce things with beta-reduction. Eq this (?x.x) gives me errors: "?x.x: name is not defined, not a parameter, and not a primitive name". I can do simple arithmetics but I would like to practise beta-reduction and such things. Help, plz.
13:25:10 <dcoutts> dmwit: agreement, it's waiting on gtk2hs getting cabalised
13:25:22 <eu-prleu-peupe1> :)
13:25:22 <dmwit> yeah
13:25:23 <eu-prleu-peupe1> hello
13:25:29 <dmwit> dcoutts: Is there anything outsiders can do to help?
13:25:41 <vixey> Heooo, you want to view the trace of beta reductions?
13:25:51 <dcoutts> dmwit: do you want to hack on c2hs?
13:26:09 <Heooo> vixey: Yes and I want to learn the basics :]
13:26:14 <dmwit> Hmm.
13:26:34 <dcoutts> dmwit: or help Saizan_ integrate his stuff for pre-processors into Cabal?
13:26:43 <vixey> Heooo, basics of what?
13:26:44 <albdogo> is there a project called c2hs
13:26:45 <albdogo> ?
13:27:05 <Heooo> vixey: lambda calculus.
13:27:09 <vixey> Heooo, oh I see
13:27:34 <dmwit> I wasn't even aware c2hs existed.
13:27:37 <dmwit> It looks useful.
13:27:48 <dcoutts> albdogo, dmwit: it's a tool similar to hsc2hs, only better.
13:28:34 <albdogo> i didnt know that
13:28:38 <mmorrow> , mdo return 1
13:28:40 <lunabot>  luna: No instance for (GHC.Show.Show (t1 t))
13:28:47 <chrisdone> Heooo: I think this is an okay start: http://en.wikipedia.org/wiki/Lambda_calculus#Reduction
13:28:48 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
13:28:50 <mmorrow> , mdo return 1 :: Maybe Integer
13:28:52 <lunabot>  Just 1
13:29:32 <Heooo> chrisdone: I read that but I need to see more practical examples to catch their points. I wanna test those rules in practise.
13:31:34 <mjonsson> I would find it very handy if there was a generic function like read::String->a but with the signature ::String->Maybe a
13:31:57 <vixey> I think you can implement it in terms of reads
13:31:58 <vixey> :t reads
13:32:00 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:32:00 <mmorrow> , (\f -> proc x -> f -< x+1) (^2) 2
13:32:04 <lunabot>  9
13:32:20 <mjonsson> vixey: cool, thanks
13:32:22 <mmorrow> has anyone actually ever used arrow notation?
13:34:00 <albdogo> what arrow notatio
13:34:27 <mmorrow> http://www.haskell.org/ghc/dist/current/docs/users_guide/arrow-notation.html
13:34:28 <lambdabot> Title: 8.10.�Arrow notation, http://tinyurl.com/6hqszu
13:35:26 <albdogo> and whats that about
13:35:26 <mmorrow> i just turned on impredicative polymorphism also
13:35:47 <dmwit> albdogo: It's about abstracting the notion of computation.
13:35:54 <albdogo> i see
13:36:10 <dmwit> ?where arrows
13:36:10 <lambdabot> http://www.haskell.org/arrows/
13:36:18 <albdogo> its interesting
13:36:33 <mmorrow> , let f :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char]) ; f (Just g) = Just (g [3], g "hello") ; f Nothing  = Nothing in f (Just reverse)
13:36:35 <lunabot>  Just ([3],"olleh")
13:36:44 <mmorrow> > let f :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char]) ; f (Just g) = Just (g [3], g "hello") ; f Nothing  = Nothing in f (Just reverse)
13:36:45 <lambdabot>   Just ([3],"olleh")
13:36:47 <mmorrow> hmm
13:36:49 <dmwit> I'm told that Arrows fit somewhere "between" Functors and Monads in what they can express.
13:37:07 <albdogo> i see there is supported syntax for that
13:37:45 <albdogo> that is new to Haskell 98 or it is a new feature?
13:37:57 <mmorrow> newer than 98
13:38:03 <albdogo> ok
13:38:13 <olsner> dmwit: aren't arrows more powerful than monads?
13:38:23 <mmorrow> dmwit: we need something for the times when Monads can't express things
13:38:27 <dmwit> hm.
13:38:44 <dmwit> olsner: I'm not sure what you mean by "powerful".
13:38:48 <vixey> Heooo, I made a thing,
13:39:01 <dmwit> olsner: There are fewer operations available on Arrows than on Monads.
13:39:11 <dmwit> (Consequently, all Monads are Arrows.)
13:39:41 <mmorrow> dmwit: but all arrows /aren't/ Monads
13:39:46 <vixey> Heooo, still around?
13:39:46 <dmwit> correct
13:39:49 <Heooo> vixey: in DrScheme? How?
13:39:53 <olsner> since all monads are arrows but not all arrows are monads, arrows can express more things... right?
13:39:56 <vixey> Heooo, In Haskell!
13:40:09 <albdogo> does that solve the problem of global variables?
13:40:11 <mmorrow> so the nontrivial of those arrows can do things monads are incapable of
13:40:22 <Heooo> vixey: What do you mean?
13:40:37 <Heooo> vixey: by "made a thing"?
13:40:45 <vixey> Heooo, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=379#a379
13:40:50 <arjanb> olsner: it depends on if you look from the implementer or user point of view
13:41:04 <vixey> Heooo, It could do with a parser and a proper REPL, but you can watch beta reductions with it
13:41:05 <olsner> are there any good examples of practically usable arrows btw?
13:41:23 <Heooo> vixey: Awesome :P
13:41:36 <Heooo> vixey: must test sec
13:41:37 <dons> olsner: frag?
13:41:40 <dmwit> olsner: Maybe HaXML?
13:41:42 <vixey> enjoy :)
13:41:43 <dons> hxt
13:42:07 <albdogo> haskell only needs global variables
13:42:26 <olsner> oh, is frag built with arrows? better check that out then
13:42:26 <dons> heh only?
13:42:28 <dmwit> albdogo: All variables are global in Haskell. ;-)
13:42:33 <vixey> albdogo, do you have a description of this  problem of global variables  you mentioned?
13:42:37 <dons> olsner: with yampa, which is in turn built on arrows
13:42:53 <roconnor> what an odd place to tune into #haskell
13:42:58 <roconnor> er odd time
13:43:02 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Yampa-0.9.2.3
13:43:08 <lambdabot> Title: HackageDB: Yampa-0.9.2.3, http://tinyurl.com/5rsrbr
13:43:12 <mapreduce> Curiously, JavaFX is somewhat related to arrows (the language spec references fudgets).
13:43:20 * roconnor tries to find the context that leads to haskell needing global variables
13:43:39 <dons> roconnor: i don't think there is any context...
13:44:00 <dons> albdogo: did you elaborate on why global variables are needed? and why existing support for global, mutable state is insufficient?
13:44:05 <albdogo> an irc program for example
13:44:19 <dons> doesn't need global variables.
13:44:25 <albdogo> how noe
13:44:25 <vixey> albdogo, can you just give a description of this  problem of global variables?
13:44:38 <dons> ?go roll your own irc bot
13:44:39 <albdogo> not in terms of functional programming
13:44:41 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
13:44:41 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
13:44:47 <dons> albdogo: ^ see the state monad
13:45:01 <olsner> hmm, why does that hackage page not have any documentation links?
13:45:31 <roconnor> right, the state mond is "externally" pure, but from the "internal" point of view, there is a global variable.
13:45:41 <roconnor> which is good enough for Haskell
13:47:03 * dons notes that irc bot tutorial has been read nearly 30k times. pretty good for a wiki page on haskell.org
13:47:07 <roconnor> I find this external/internal description of monads helpful, but maybe it is hard to explain to new haskell users.
13:47:46 <mmorrow> dons: half of lunabot's bot shell is copy-pasted-modified from that :)
13:48:27 <roconnor> is there an IRC lib?
13:48:40 <dmwit> Yes, but it's pretty incomplete.
13:48:44 <mmorrow> oh wait, i meant from your bot blog post
13:48:45 <dmwit> I was very disappointed with it.
13:50:48 <albdogo> i cannot comprenhend arrwos
13:51:10 <albdogo> understand i mean
13:57:07 <arjanb> albdogo: you could view it as an abstraction of function composition
13:57:47 <albdogo> in what is it an bastraction
13:58:15 <albdogo>  associativity?
13:58:39 <vixey> I think you should type more carefully
13:59:00 <Heooo> vixey: What are a parser and a REPL with which this code works? I tested "ghc <the name of file>.hs but the error is: "parse error on input `instance'".
13:59:14 <IsoPallo_> Hmm... bastraction... A nice new term.
13:59:15 <vixey> Heooo, there is no parser or REPL :)))
13:59:25 <vixey> Heooo, open ghci, then inside ghci,  :load lambda
13:59:34 <vixey> Heooo, (if you saved the code as lambda.hs)
13:59:42 <vixey> then you can make use of the ghci parser and REPL..
14:00:07 <vixey> so see the comment at the very end? You can try running that for example
14:01:31 <mmorrow> do
14:01:33 <mmorrow> :?
14:01:35 <mmorrow> in ghci
14:02:28 <albdogo> can anyone put an example in which are most intuitive the arrows
14:02:50 <vixey> :t (&&&)
14:02:51 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:03:16 <vixey> albdogo: (&&&) :: (Arrow (~>)) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
14:03:25 <mmorrow> :!echo "gives you a shell"
14:03:29 <mmorrow> eg
14:03:31 <mmorrow> ghci> :!ps aux | grep [g]hc | sed -r 's/[ \t]+/ /g' | cut -d' ' -f2 | kill -9 `cat`
14:03:31 <mmorrow> Killed
14:03:32 <vixey> > (tail &&& reverse) "foo"
14:03:33 <lambdabot>   ("oo","oof")
14:03:42 <mmorrow> suicide
14:04:06 <vixey> mmorrow: ahaha  [g]hc
14:04:23 <albdogo> and the -> y -< ?
14:04:30 <mmorrow> "shoot to kill"
14:04:50 <vixey> so many sh tricky
14:04:54 <vixey> tricksy
14:05:24 <roconnor> vixey: I thin albdogo wants an example that uses a non -> instance
14:05:26 <roconnor> think
14:05:30 <mux> is there a tool to convert a darcs patch to something working with the unix patch command?
14:05:36 <mmorrow> heh, totally. sh is so great because it's so randomly crazy-corner-filled
14:05:41 <vixey> ok, I never used arrows for non -> instances
14:05:47 <roconnor> :D
14:05:50 <vixey> monochrom has a page that looked good about it
14:06:16 <roconnor> I used HaXml arrows, but I never understood their point
14:06:23 <roconnor> I just found it confusing
14:06:36 * vixey doesn't process XML thankfully
14:06:44 <Heooo> vixey: Loading the code gives me this: http://pastebin.com/m30d6ad7a . The code is in the directory but I  do not understand why it fails :[
14:07:03 <albdogo> monads has two operations , then arrows has one?
14:07:12 <vixey> Heooo, weird, I don't know
14:08:06 <vixey> You are doing the right thing
14:08:48 <albdogo> and which is the associated property
14:09:10 <dmwit> albdogo: Arrows have lots of operations!
14:09:21 <dmwit> It's just that Monads can implement them all with its measly two.
14:09:33 <dmwit> ?src Arrow
14:09:34 <lambdabot> class Arrow a where
14:09:34 <lambdabot>     arr, pure   :: (b -> c) -> a b c
14:09:34 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
14:09:34 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
14:09:34 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
14:09:35 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
14:09:37 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
14:09:46 <roconnor> It's not the number of operations you have, it's how you use them
14:09:53 <vixey> most of them are only in the class so you can write efficient version of them
14:09:54 <dmwit> (arr, (>>>), first are the only required ones, really.)
14:10:28 <vixey> I would ask what version of ghci you have... but 'instance' is not something very new to haskell..
14:10:48 <albdogo> i have gch6
14:10:52 <albdogo> ghc*
14:11:37 <albdogo> :src Arrau
14:11:39 <albdogo> :src Arraw
14:11:44 <albdogo> :src Arrow
14:11:58 <Heooo> How can I test that my ghci is working properly?
14:12:19 <sclv> just try evaluating some stuff in it
14:12:30 <Heooo> code plz
14:12:42 <Heooo> sorry I am a newbie
14:12:50 <Cale> Try an arithmetic expression
14:12:53 <albdogo> :code Arrow
14:12:55 <sclv> type 2 + 2 at the prompt
14:12:56 <Cale> Like 2^1024
14:13:05 <sclv> albdogo: that won't get you anywhere.
14:13:08 <Heooo> Cale: works fine
14:13:09 <vixey> Heooo, the only thing I can imagine causing that, is maybe you put something extra in betareduction.hs by accident
14:13:09 <vixey> ?
14:13:11 <dmwit> albdogo: Try a '?' instead of a ':'.
14:13:23 <albdogo> ?code Arrow
14:13:24 <lambdabot> Maybe you meant: more todo vote
14:13:30 <albdogo> ?src Arrow
14:13:31 <lambdabot> class Arrow a where
14:13:31 <lambdabot>     arr, pure   :: (b -> c) -> a b c
14:13:31 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
14:13:31 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
14:13:31 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
14:13:32 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
14:13:35 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
14:13:39 <albdogo> i see
14:13:44 <sclv> also you can't get the source for arrow from lambdabot anyway.
14:14:03 <sclv> the source for the specific instances that is.
14:14:07 <dmwit> right
14:14:09 <mjonsson> I am having type class troubles: class Foo a where ...; instance Foo String where ...;    <- this doesn't work
14:14:24 <vixey> mjonsson, ok?
14:14:32 <dmwit> mjonsson: Yeah, that's not H98.
14:14:47 <Heooo> vixey: extra lines?
14:14:51 <dmwit> mjonsson: You can either make your class use [a] everywhere, and then do instance Foo Char, or you can enable the appropriate extension.
14:15:07 <dmwit> mjonsson: GHC[i] should tell you which extension to enable.
14:16:35 <Heooo> Is there some online haskell ghci interpreter?
14:16:50 <C-Keen> Heooo: lambdabot can do some stuff
14:16:56 <albdogo> well, im going to see if understand this arrows
14:17:02 <albdogo> nice chat, bye
14:17:03 <mjonsson> dmwit: thanks, I am using an old ghc so I didn't see the extension
14:17:05 <C-Keen> Heooo: just start your line with '>'
14:17:28 <vixey> bye
14:17:31 <C-Keen> > putStrLn "Hi Heooo"
14:17:32 <lambdabot>   * Exception: "<IO ()>"
14:17:38 <C-Keen> argh :)
14:17:44 <albdogo> ty for the help
14:17:44 <C-Keen> > "Hi Heooo"
14:17:45 <lambdabot>   "Hi Heooo"
14:17:54 <Heooo> C-Keen: I have not done it. So just ">" in the beginning of the code?
14:17:55 <mux> does anyone know to what darcs repository I am supposed to apply simonmar's patch for the System.Process revamp?
14:18:16 <vixey> You can't run that beta thing in lambdabot
14:18:23 <vixey> it's too large a source code
14:18:46 <vixey> Heooo, what if you just put a file with:
14:18:53 <vixey> x = 99*4
14:18:58 <vixey> Just that one line in it,
14:19:12 <vixey> and try to load that with ghci, and then check *Main > x, see what it does
14:19:19 <Heooo> vixey: in the beginning or where?
14:19:42 <vixey> what in the beginning of what?
14:20:14 <Heooo> vixey: Where do I put this "x = 99*4" in the code?
14:20:27 <vixey> put that in a new file called test.hs
14:20:30 <vixey> that one line alone
14:20:57 <vixey> to check if ghci can load it, and give you the value of x back
14:22:18 <Heooo> vixey: it seems to work. "Main" prints the number of my input.
14:22:23 <vixey> hmmm
14:22:53 <rwbarton> Heooo: I think you must have accidentally modified the file like vixey suggested.
14:23:25 <Heooo> rwbarton: I used this file: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/raw?id=379
14:23:52 <mmorrow> mux: err, you could just get the new process pkg and install it
14:24:19 <rwbarton> Heooo: I copied and pasted that file and loaded it in ghci, and it worked fine for me
14:25:06 <Heooo> rwbarton: I must test it again
14:26:17 <mmorrow> darcs get http://darcs.haskell.org/libraries/process/
14:26:18 <lambdabot> Title: Index of /libraries/process
14:26:27 <mmorrow> is the new one
14:26:32 <vixey> I'm amused by how sneaky that bug in substitution is
14:27:01 <mmorrow> which bug it this?
14:27:21 <vixey> I don't wanna give it away :p
14:27:33 <mmorrow> heh
14:27:34 <mux> mmorrow: cheers
14:28:06 <mmorrow> mux: :)
14:28:25 <olsner> hmm, I want to keep a circular buffer (with a given maximum size) in one thread and have another thread be able to read the latest buffer (or, rather, the n last samples produced by the producer)
14:31:18 <Heooo> rwbarton: perhaps, the error is in "import Control.Monad". How can I know that I have it?
14:31:26 <Saizan_> olsner: so, a bounded channel?
14:32:10 <rwbarton> Heooo: You should definitely have it.  Can you paste the entire error message?
14:33:32 <Heooo> rwbarton: You see the code and the error here: http://pastebin.com/m3df0d62
14:33:47 <vixey> wow llol
14:33:48 <Ste> is there an easy way to view the disassembly of a Haskell compiler-generated program?
14:33:53 <mux> mmorrow: I can't have it build though
14:33:56 <vixey> Heooo, there's lots of spaces that should not be there!
14:34:23 <mmorrow> mux: ah, sucky. maybe upgrade to 6.10?
14:34:38 <vixey> Heooo, Where on earth did these spaces come from ? :p
14:34:52 <mmorrow> olsner: an off-the-cuff go at it:
14:34:53 <mmorrow> newtype Recent a = Recent (MVar (Chan a)) ; producerAdd :: Recent a -> IO () ; producerAdd (Recent mv) a = takeMVar mv >>= \ch -> readChan ch >> writeChan ch a >> putMVar ch ; consumerRead :: Recent a -> IO (Chan a) ; consumerRead (Recent mv) = takeMVar mv >>= \ch -> newChan >>= \ch' -> putMVar mv ch' >> return ch
14:35:15 <mux> mmorrow: I seem to miss include/HsProcessConfig.h.in
14:35:21 <dolio> Looks like it got pasted into vim with indenting on.
14:35:27 <sbahra> Bonjour mux
14:35:31 <mmorrow> mux: what ghc version are you using?
14:35:32 <olsner> Saizan_: yeah, I guess... is there a library for those?
14:35:43 <mux> 6.8.2
14:35:47 <mmorrow> dolio: lol
14:36:22 <x6d65> Is there a relatively straightforward way of doing the equivalent of n nested while loops in an imperative language?
14:36:31 <vixey> x6d65, yes
14:36:38 <vixey> aww
14:36:48 <vixey> I just finished that chess game yesterday
14:37:08 <vixey> I wrote over all the code though :/
14:37:22 <vixey> should have saved it before doing a OS install
14:37:29 <olsner> my own attempt is at http://hpaste.org/11670 (it's a block returning an IO action for extracting the n last entries as an array)
14:37:31 <vixey> anyway I had for2 in it
14:37:54 <mmorrow> mux: yeah, i don't think the new proc lib'll work on 6.8
14:38:36 <mux> heh, I just got it to build
14:38:41 <mmorrow> haha
14:38:43 <mmorrow> nice
14:38:50 <mux> had to fiddle with it a little
14:38:54 <mmorrow> if you made any c.
14:39:03 <mmorrow> cool, hpaste the diff :)
14:39:12 <mux> manually replacing the CONST_SIG_IGN and _DFL stuff to the values on the system I want to build
14:39:22 <mmorrow> ah, nice
14:39:36 <mux> let's see if it works
14:40:00 <Heooo> vixey: I just copy and pasted from firefox to shell. I don't know. Should I press the download button instead?
14:40:28 <vixey> Heooo, shell seems to have screwed it up, so yeah, downloading like that may work
14:41:38 <mmorrow> olsner: nice. i'm not too excited about how mine is constantly creating newChans.
14:42:07 <olsner> this one seems to stall occasionally
14:42:42 <mmorrow> hmm, i see you're working with sound data
14:42:59 <olsner> indeed
14:43:20 <Heooo> vixey: I was using vim. Perhaps, I have to test emacs this time :]
14:43:30 <mmorrow> maybe if it's realtime and stuff a Ptr Something and peekByteOff wouldn
14:43:32 <mmorrow> 't
14:43:35 <mmorrow> be overkill
14:44:49 <mmorrow> or that might be a pain, but i guess i mean something that doesn't need garbage collection
14:45:06 <olsner> or maybe an IOUArray, but synchronization of that sounds kind of painful
14:45:48 <mmorrow> well, since the reader only reads and the writer only writes, would you need to synchronize at all?
14:46:24 <mux> mmorrow: it's working nicely
14:46:28 <mmorrow> oh, it's a circular buffer. hmm, i dunno the best strategy here
14:46:36 <mmorrow> mux: cool :)
14:46:52 <x6d65> So I figured out what I was doing wrong, but I'm curious if there are obvious improvements on what I'm doing to effect the iteration (and I'm sure there are). Anyone care to take a look? http://hpaste.org/11671
14:47:47 <vixey> @let validTriple (a, b, c) = a + b + c <= 1000
14:47:48 <lambdabot>  Defined.
14:48:34 <vixey> @let triple = (,,)
14:48:34 <lambdabot>  Defined.
14:49:07 <rwbarton> x6d65: in this particular case, you could write triples = [ triple m n k | m <- [2..1000], n <- [1..1000-m], k <- [1..1000-m-n] ]
14:49:08 <vixey> > do a <- [1..] ; b <- [1..a] ; c <- [1..b] ; let t = triple a b c ; guard (validTriple t) ; return t
14:49:09 <lambdabot>   <no location info>: parse error on input `;'
14:49:17 <vixey> > do a <- [1..] ; b <- [1..a] ; c <- [1..b] ; let t = triple a b c in do guard (validTriple t) ; return t
14:49:18 <lambdabot>   [(1,1,1),(2,1,1),(2,2,1),(2,2,2),(3,1,1),(3,2,1),(3,2,2),(3,3,1),(3,3,2),(3...
14:50:36 <Heooo> vixey: Three times hooray to emacs :D Perhahs, auto-indent in vim somehow conflicted with the file. So how does this file work?
14:50:51 <vixey> Heooo, oh excellent! did you try the example reduction?
14:51:06 <Heooo> vixey: How?
14:51:20 <vixey> load the thing in ghci and run the thing from the comment at the end of the file
14:51:40 <vixey> so paste in evaluate (App (Lam "x" (Var "x")) (Var "u"))
14:51:41 <olsner> meh, circular buffers... I've implemented these at least one too many times
14:52:14 <vixey> olsner: what circumstance is circular buffer the best thing to use?
14:52:58 <x6d65> rwbarton: triple is actually a function that transforms its three arguments into a different tuple, and the validTriple predicate is on that, rather than the original arguments.
14:53:10 <rwbarton> x6d65: oh, oops
14:53:27 <vixey> x6d65, you saw what I wrote above?
14:53:29 <olsner> like... when I know the amount of buffer I want and I don't want to allocate memory needlessly
14:53:29 <mmorrow> >  [ t | a <- [1..], b <- [1..a], c <- [1..b], let t = triple a b c, validTriple t]
14:53:30 <lambdabot>   [(1,1,1),(2,1,1),(2,2,1),(2,2,2),(3,1,1),(3,2,1),(3,2,2),(3,3,1),(3,3,2),(3...
14:53:43 <x6d65> vixey: I did. I'm still thinking about it.
14:54:07 <p_l> vixey: Or when you need to to buffer some data for fast IO and losing some of it is not as important as long as you get most of it
14:54:16 <vixey> olsner, yeah, I can't think of any times that happens except stuff like.. maybe a digital TV decoding frames
14:54:41 <p_l> vixey: All kinds of communication stuff (at the lower level though)
14:54:59 <rwbarton> x6d65: vixey's thing doesn't help you here, much like mine doesn't
14:55:26 <vixey> rwbarton, it goes through every i,j,k and test triple for it..?
14:56:16 <p_l> vixey: I once adviced my friend if he shouldn't try using a kind of dequeue/circular buffer for his random number algorithm analysis (on PS3, he had only 256MB of RAM and had to collect A LOT of data)
14:56:22 <eu-prleu-peupeu> hey
14:56:25 <rwbarton> vixey: you changed b <- [1..] to b <- [1..a]
14:56:31 <eu-prleu-peupeu> where can i learn how to use haddoc ?
14:56:38 <x6d65> The succession of a <- [1..], b <- [1..a] is new to me.
14:56:42 <mmorrow> here's some random experimentation i was doing at one point, maybe parts of it'll be useful in you situation http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=57
14:56:42 <eu-prleu-peupeu> what testing library do you recomend me to use ?
14:57:09 <rwbarton> vixey: the problem is to end each loop at a dynamically determined point (like with takeWhile)
14:57:16 <profmakx> are there any good examples on how to use Text.XML.Light?
14:57:19 <vixey> oh, it tests every i,j,k, where j <= i, k <= j, ok
14:58:31 <vixey> Heooo, so did it work?
15:02:11 <x6d65> So is the conclusion that there isn't an obvious simpler way to do what I'm doing?
15:02:11 <Heooo> vixey: It seems perfect. How can I do this: "((/x.ydx)(/y.y)) l "?
15:02:29 <Heooo> vixey: / stands for lambda
15:02:31 <vixey> Heooo, there's a really subtle bug in it, but I'll let you find it :)
15:02:38 <vixey> what's 'l' ?
15:02:53 <Heooo> vixey: just a free variable
15:02:58 <olsner> awesome, my program was spending 60% time in the GC :)
15:03:17 <dmwit> x6d65: There is a nicer way.  Hold on.
15:03:24 <IsoPallo_> Does this mean your program was mainly trash?
15:03:43 <ddarius> IsoPallo_: Nah, just that it produced mostly trash.
15:04:25 <IsoPallo_> Ah. True.
15:05:36 <olsner> or both :)
15:06:59 <vixey> Heooo: evaluate (App (App (Lam "x" (App (App (Var "y") (Var "d")) (Var "x"))) (Lam "y" (Var "y"))) (Var "l"))
15:08:20 <vixey> mmorrow, with caputure ignorant substitution, (\x -> ((\x -> i) x))  ~~>  (\x -> i)
15:09:53 <dmwit> x6d65: I take it back.  It's not obvious how to do this in general.
15:10:02 <dmwit> x6d65: There are better ways for this specific case, but...
15:10:36 <x6d65> dmwit: I'd settle for a specific solution.
15:10:42 <jethr0> good evening, haskell
15:11:09 <dmwit> > [(a, b, c) | a <- [2..], b <- [1..5-a-1], c <- [1..5-(a+b)]]
15:11:15 <vixey> had you seen that bug before?
15:11:24 <lambdabot>   thread killed
15:11:36 <dmwit> > [(a, b, c) | a <- [2..5-2], b <- [1..5-a-1], c <- [1..5-(a+b)]]
15:11:37 <lambdabot>   [(2,1,1),(2,1,2),(2,2,1),(3,1,1)]
15:12:05 <vixey> oops
15:12:12 <vixey> that wasn't a proper example of it
15:12:52 <vixey> hmmmmm ..... now I'm not sure if there is a bug, but there should be
15:13:11 <dmwit> > let ensure p x = guard (p x) >> return x in replicateM 3 [2..5] >>= guard ((<5) . sum)
15:13:12 <lambdabot>   Couldn't match expected type `Bool'
15:13:20 <jethr0> vixey: what do you think should be the bug?
15:13:22 <dmwit> > let ensure p x = guard (p x) >> return x in replicateM 3 [2..5] >>= ensure ((<5) . sum)
15:13:24 <lambdabot>   []
15:13:35 <dmwit> > let ensure p x = guard (p x) >> return x in replicateM 3 [1..5] >>= ensure ((<5) . sum)
15:13:36 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[2,1,1]]
15:13:41 <vixey> there's always a capture bug when you use this representation of syntax
15:14:13 <dmwit> x6d65: That way is more elegant, though a little less performant.
15:15:04 <dmwit> Also, it seems like if I understood the Cont monad better, I would be able to right something that mirrors yours a little better.
15:17:20 <x6d65> dmwit: Hm, thanks for the food for thought, and thanks also to rwbarton and vixey. I'll continue to play with it.
15:21:00 <Heooo> vixey: So is this "(App (Lam "x" (Var "x")) (Var "u"))" equivalent to "(/x.x) u ?
15:21:19 <vixey> mmorrow, sorry, an actual example is,  (\y -> ((\x -> (\y -> (x y))) y)) ~~> (\y -> (\y -> (y y)))
15:21:30 <vixey> Heooo, yes
15:21:46 <vixey> *Main> (App (Lam "x" (Var "x")) (Var "u"))
15:21:46 <vixey> ((\x -> x) u)
15:21:54 <vixey> Heooo, ^ you can try it in ghci like that
15:23:36 <Heooo> vixey: Fantastic :D  Is it possible to go other way? So I would use the shorter form?
15:23:53 <vixey> Heooo, if someone writes a parser
15:24:06 * vixey doesn't like to write another parser though
15:24:46 <Heooo> vixey: I can do it. I just replace all App with "(" and Lam with "/". Just simple?
15:26:06 <Heooo> have to practise haskell :P
15:27:18 <Heooo> vixey: Thx vixey! Can I show this code to other undergrads? I would mention your name vixey.
15:27:39 <mux> bah, readProcessWithExitCode somehow leaks like crazy
15:28:18 <Saizan_> space?
15:28:23 <mux> yes
15:28:23 <sjanssen> @hooogle readProcessWithExitCode
15:28:24 <lambdabot> No results found
15:28:37 <mux> it's in simonmar's revamped System.Process
15:30:08 <Saizan_> that's probably because it loads all the output in memory before returning
15:30:20 <mux> that's what I'm thinking
15:30:44 <mux> which is why I tried with verbosity turned off and now, I'm trying to just run sleep 120
15:33:11 <vixey> Heooo, There's a bug in the code!
15:33:39 <mux> it doesn't leak running a sleep command
15:33:45 <vixey> Heooo, it can be a fun sort of puzzle to find out what the bug is :)
15:33:59 <mux> it leaks when I run an unrar command which is supposed to output very few lines
15:34:06 <mux> it goes up to 2GB of RAM
15:36:08 <Saizan_> ..unless it's uncompressing on stdout when attached to a pipe?
15:36:34 <mux> ah
15:36:48 <mux> I think the command was repeatedly asking a question
15:38:49 <mux> good, that was it
15:40:10 <adu> hey, if something is a -> IO CString, and I want it to return a -> IO String, what do I do?
15:40:25 <adu> mapM peekCString?
15:40:29 <mux> :t peekCString
15:40:31 <lambdabot> Not in scope: `peekCString'
15:40:56 <lispy> ?hoogle CString -> String
15:40:57 <lambdabot> Foreign.C.String peekCAString :: CString -> IO String
15:40:57 <lambdabot> Foreign.C.String peekCString :: CString -> IO String
15:40:57 <lambdabot> Prelude show :: Show a => a -> String
15:41:03 <adu> fmap peekCString?
15:41:14 <mux> youraction >>= peekCString
15:41:14 <lispy> :t fmap peekCAString
15:41:16 <lambdabot> Not in scope: `peekCAString'
15:41:28 <mux> both the function you run and peekCString are in IO
15:41:29 <adu> o right, I feel like a noob
15:41:33 <mux> either you use do notation, or >>=
15:42:00 <lispy> :t ap
15:42:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:42:28 <vixey> :t fmap peekCString
15:42:29 <lambdabot> Not in scope: `peekCString'
15:42:42 <vixey> :t fmap Foreign.C.String.peekCString
15:42:44 <lambdabot> forall (f :: * -> *). (Functor f) => f Foreign.C.String.CString -> f (IO String)
15:43:14 <lispy> :t join (fmap Foreign.C.String.peekCString)
15:43:16 <lambdabot>     Occurs check: cannot construct the infinite type:
15:43:17 <lambdabot>       f = (->) (f Foreign.C.String.CString)
15:43:17 <lambdabot>     Probable cause: `fmap' is applied to too many arguments
15:44:09 <adu> :t (=<<) Foreign.C.String.peekCString
15:44:10 <lambdabot> IO Foreign.C.String.CString -> IO String
15:44:15 <adu> thats better
15:45:22 <adu> are there any articles about Haskell coding standards?
15:45:34 <lispy> :t \f m -> join (fmap f m)
15:45:36 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => (a -> m a1) -> m a -> m a1
15:45:42 <lispy> ?pl \f m -> join (fmap f m)
15:45:43 <lambdabot> (=<<)
15:45:51 <lispy> adu: on the wiki
15:47:01 <adu> found it
15:47:03 <adu> http://www.haskell.org/haskellwiki/Programming_guidelines
15:47:04 <lambdabot> Title: Programming guidelines - HaskellWiki
15:47:18 <jethr0> @pl \a b -> [a,b]
15:47:19 <lambdabot> (. return) . (:)
15:49:11 <Saizan_> anyone tried to build lambdabot on 6.10 ?
15:50:07 <adu> it is recommended! "Don't leave trailing white space in your code in every line. "
15:50:13 <Saizan_> i'm getting problems when ghc links in readline before running some TH code
15:50:22 <adu> oops, theres a space after that sentence...
15:52:56 <roconnor> I totally disagree with 4.1 Case expressions
15:53:00 <idnar> @type \a b -> [a,b]
15:53:01 <lambdabot> forall t. t -> t -> [t]
15:53:11 <idnar> @type (:[])
15:53:13 <lambdabot> forall a. a -> [a]
15:53:16 <idnar> @type (:[]) . (:)
15:53:18 <lambdabot> forall a. a -> [[a] -> [a]]
15:53:30 <idnar> @type (. (:[])) . (:)
15:53:32 <lambdabot> forall a. a -> a -> [a]
15:53:36 <idnar> mmph
15:54:32 <roconnor> I largely disagree with 4.6 List Comprehensions
15:56:44 <adu> roconnor: how so?
15:57:30 <roconnor> list comprehensions are often easier to read then some backwards sequence of maps and filters
15:58:09 <roconnor> I say use list comprehensions for complex tasks
15:58:17 <adu> roconnor: I think that might be an indication that people perfer reading functions and that the inhabitants of list-comprehention land are few and far between
15:58:18 <roconnor> only use map, filter when short and sweet
15:59:07 <adu> I find that I use map far more often than [f x | x <- xs]
15:59:19 <roconnor> I'd use map in that case
16:00:09 <roconnor> but I don't mind the list comprehension
16:00:29 <Saizan_> list comprehensions are especially nice with pattern matching
16:01:12 <adu> roconnor: so what do you think about 4.1?
16:01:37 <roconnor> case expressions should be avoided at all costs
16:01:59 <roconnor> use where clauses to make auxiary function that can use pattern bindings
16:02:06 <vixey> I like case expressions
16:02:15 <adu> I think the example they give is terrible, because its longer in the "better" style...
16:02:30 <adu> and short in the "worse" style...
16:02:35 <roconnor> I don't think I've used a case expression in years
16:03:09 <adu> I use it alot for Maybe types, but thats mainly because I'm not comfortable with the Maybe monad yet...
16:03:10 <roconnor> If you are not concerned about portability issues, use pattern guards too
16:03:57 <adu> I've read about pattern gaurds about 3 times now, and every time I learn about them I forget them the next day
16:04:17 <roconnor> well, they are rarely needed
16:04:25 <adu> maybe thats why
16:04:47 <roconnor> I use where claues and guards to simulate pattern guards on the occasions that I need them
16:05:02 <lispy> case expressions are a pain in the butt with GADTs but more or less needed in many situations
16:05:05 <roconnor> but I mean to use pattern guard more often for code that is one-off
16:05:23 <vixey> view patterns are very cool though
16:05:24 <unenough> can Arrows do things that Applicatives can't?
16:05:29 <unenough> or vice versa?
16:05:45 <lispy> :k (->)
16:05:46 <lambdabot> ?? -> ? -> *
16:05:57 <lispy> Well, ask cupid
16:06:13 <roconnor> unenough: smart people say that it goes Applicative > Arrows > Monads
16:06:31 <roconnor> but I don't get Arrows, so I never understood
16:06:32 <Peaker> roconnor: intuitively, what expressiveness does Arrows add to Applicative?
16:06:34 <unenough> roconnor, ok, so what is it that arrows can do and applicatives won't?
16:06:53 <roconnor> I don't understand
16:06:58 <lispy> I've never really seen a reason for arrows
16:07:12 <Peaker> I wonder if that Arrow-based parser they wrote can be Applicative-based instead
16:08:14 <adu> I don't think anyone understands Arrows
16:08:33 <lispy> we have so much algerbra stuff in Haskell and yet 1) the standard Num heirarchy is broken 2) why didn't Prelude have an equivalence relation class?
16:08:57 <roconnor> isn't Eq and equivalence relaiton class?
16:08:59 <Saizan_> Peaker: Applicative is like having an Arrow and restricting you to (&&&) and \f -> (>>> arr f)
16:09:01 <roconnor> and
16:09:03 <roconnor> an
16:09:22 <lispy> roconnor: it could be, but people take it to mean equality
16:09:32 <roconnor> I don't
16:09:45 <Peaker> @type (&&&)
16:09:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:10:20 <lispy> roconnor: it would have been nice if we had Eq and EqRel so that when you request one or the other you know what you're getting
16:10:49 <adu> <$> is the one true fmap
16:10:53 <Peaker> Saizan_: <*> lets me "merge" two applicative results, but &&& only lets me split results, and \f -> (>>> arr f) only lets me "fmap "results
16:10:57 <roconnor> I don't see what is wrong with just using Eq
16:11:04 <Peaker> Saizan_: so I think those are not yet Applicative
16:11:12 <sjanssen> lispy: would the instances be different for any of the standard types?
16:11:23 <roconnor> > 0::Double == -0
16:11:24 <lambdabot>   <no location info>: parse error on input `-'
16:11:31 <roconnor> > 0::Double == (-0::Double)
16:11:32 <lambdabot>   <no location info>: parse error on input `-'
16:11:38 <roconnor> > 0::Double == ((-0)::Double)
16:11:39 <lambdabot>   <no location info>: parse error on input `-'
16:11:43 <roconnor> fuck you
16:11:46 <Saizan_> ?type \f g -> f &&& g >>> arr (uncurry id) -- Peaker
16:11:47 <lambdabot> forall (a :: * -> * -> *) b c' c. (Arrow a) => a b (c' -> c) -> a b c' -> a b c
16:11:51 <adu> lol
16:11:57 <lispy> sjanssen: well, that's a good point. You want to be able to define equivalence relations lots of different ways for the type
16:11:59 <roconnor> > 0::Double == ((- 0)::Double)
16:12:01 <lambdabot>   <no location info>: parse error on input `-'
16:12:06 <roconnor> > 0::Double == ((negate 0)::Double)
16:12:07 <lambdabot>   <no location info>: parse error on input `Double'
16:12:10 <sjanssen> lispy: sounds like it isn't a class at all
16:12:14 <roconnor> uh
16:12:23 <lispy> sjanssen: like, pick an n and you (`mod` n) becomes an equivalence relation
16:12:24 <roconnor> > (0::Double) == ((- 0)::Double)
16:12:24 <Peaker> Saizan_: oh. So I'm basically missing "first"?
16:12:26 <lambdabot>   True
16:12:31 <adu> > (0::Double) == ((negate 0)::Double)
16:12:32 <lambdabot>   True
16:12:38 <roconnor> > isNegativeZero (0::Double)
16:12:39 <lambdabot>   False
16:12:45 <roconnor> > isNegativeZero ((- 0)::Double)
16:12:46 <lambdabot>   True
16:12:51 <Saizan_> Peaker: and (>>>) for non-pure functions
16:12:53 <roconnor> lispy: see, equivalence relation
16:13:29 <Saizan_> Peaker: all your arrows share the same input basically, instead of using the output of one as input to the other
16:13:34 <Peaker> Saizan_: I can do "first" by toying with the tuples, can't I?
16:14:08 <Peaker> Saizan_: in the case of applicative, that is
16:14:46 <roconnor> > (0/0) == (0/0)
16:14:47 <lambdabot>   False
16:15:09 <roconnor> lispy: Eq is even a partial equivalence relation
16:15:44 <Saizan_> Peaker: if you mean something like f (a -> b) -> f ((c,a) -> (c,b)) sure, but that's not really the same first as Arrow
16:16:11 <Peaker> Saizan_: Yeah, because I don't have non-pure computations to pass input to
16:16:25 <Saizan_> right
16:16:52 <Peaker> but wouldn't it make more sense to extend Applicative than to create a different-kinded type-class?
16:16:57 <Peaker> (or is that not possible)
16:18:47 <Saizan_> the historical reason is that Arrows came first
16:19:03 <httpdss> help needed: i have a list of numbers which is sent to a function myFunction. this functions returns the same list if all conditions defined in myFunction are passed. if one of the conditions isnt met, then i do error " THE ERROR". haskell is inferring that the list that it recieves is the same it has has to return and doesnt go into the conditions :S
16:19:21 <Peaker> Saizan_: Do you think it is possible to have the same expressiveness as Arrows do in a type-class between Applicative and Monad ?
16:19:36 <httpdss> is there any way to cancel out those haskell optmizations or inferences it does
16:19:38 <httpdss> ?
16:19:43 <Saizan_> Peaker: i've no opinion on that atm :)
16:19:49 <sjanssen> httpdss: sounds like usual laziness?
16:20:10 <Peaker> Saizan_: ok. Thanks for the clarifications ;) I think I asked these questions 5 times, and this is the first time I got an answer.. :)
16:20:20 <sjanssen> httpdss: could you hpaste the code?
16:20:35 <BMeph> Peaker: Technically, Arrows are between Applicative and Monad. :)
16:21:03 <httpdss> sjanssen: yup, it really does sound like it ... any way to cancel lazyness
16:21:04 <httpdss> ?
16:21:24 <BMeph> httpdss: !
16:21:25 <rwbarton> httpdss: It doesn't sound like it has anything at all to do with laziness.  Compiler optimizations, possibly...
16:21:32 <Peaker> BMeph: I mean actually between them (subclass-wise)
16:21:47 <sjanssen> rwbarton: optimizations will never turn _|_ into non-bottom
16:22:02 <roconnor> sadly
16:22:03 <rwbarton> sjanssen: Right, OK
16:22:30 <sjanssen> (I shouldn't say never, rather rarely due to faulty list fusion rewrite rules)
16:22:56 <roconnor> sjanssen: I though fusion turns all sorts of bottoms into non-bottoms
16:22:57 <rwbarton> sjanssen: (I thought maybe he somehow knew that conditions weren't being checked, even though they were satisfied)
16:23:10 <roconnor> thought
16:23:42 <sjanssen> httpdss: you can't turn laziness off, but it is possible to be more strict.  This is hard to explain without some concrete code to work with
16:24:02 <rwbarton> httpdss: It seems more likely that you're just not using the result of myFunction at all.
16:24:07 <sjanssen> roconnor: right, RULES pragmas break all guarantees
16:24:22 <httpdss> sjanssen: let me see what i can do on code pasting ;)
16:30:56 <Philly2> when working with lists, ie (x:xs), how do U make a call that restarts from element 0 of the list? (example, I am comparing 2 lists (x:xs) and (y:ys). I compare x with y's untill I find x = y, then compare xs with y starting from the first element in (y:ys) )
16:31:25 <vixey> Philly2, take (y:ys) as a parameter, twice
16:31:30 <dons> roconnor: mm?
16:31:41 <httpdss> http://hpaste.org/11673
16:31:48 <Vq^> Philly2: make two functions
16:31:51 <dons> i think you might be misunderstanding the soundness argument wrt. bottoms in streams, or build/foldr
16:31:57 <Vq^> Philly2: one that compares them and returns a Bool
16:32:11 <roconnor> dons, am i wrong
16:32:13 <httpdss> sjanssen: the first example does all the process, while the second one doesnt
16:32:15 <Vq^> Philly2: and one that calls the first one and makes the choice
16:33:36 <sjanssen> httpdss: that means "a" is the component that has the error in it
16:34:30 <sjanssen> dons: the flaw in build/foldr is well known, right?
16:35:37 <httpdss> sjanssen: well if "a" is included the error is raised correctly ... if i do (b,c) ... the error isnt raised
16:35:41 * sjanssen is trying to find it
16:36:04 <dons> janis wrote lots of papers on the conditions under which build/foldr is ok in the presence of seq. the story for stream fusion is simpler and clearer.
16:36:15 <sjanssen> http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion
16:36:16 <lambdabot> Title: Correctness of short cut fusion - HaskellWiki, http://tinyurl.com/23j3w3
16:36:18 <Philly2> thanks alot. Im going to use vixeys solution as I must delete the Y I find from the list.
16:36:43 <Philly2> Vq^++
16:36:43 <dons> roconnor: so you won't see bottoms turned into non-bottoms with "fusion", under build/foldr the above applies, under streams, see gibbon's proof.
16:36:47 <Philly2> vixey++
16:37:06 <dons> "I though fusion turns all sorts of bottoms into non-bottoms" isn't accurate, imo.
16:37:15 <httpdss> sjanssen: im tring to check the structure c using some semantic verifications and i want the error to raise if it finds that some semantic tule isnt met
16:37:17 <Philly2> no bot keeps track of karma pts? :P
16:37:30 <mauke> preflex: karma Vq^
16:37:30 <preflex>  karma for Vq^: 1
16:37:45 <Philly2> lol..nice
16:37:56 <vixey> !
16:37:59 <vixey> @karma vixey
16:37:59 <lambdabot> You have a karma of 3
16:38:03 <vixey> I am moving up!
16:38:07 <mauke> preflex: karma vixey
16:38:08 <preflex>  karma for vixey: 7
16:42:27 <roconnor>  dons: In the presence of seq, the foldr/build-rule is not anymore a semantic equivalence.
16:42:51 <roconnor> according to sjanssen's link
16:43:08 <roconnor> where did I go wrong?
16:43:17 <sjanssen> roconnor: your statement was a bit too general
16:43:19 <FunctorSalad> preflex: nickometer FunctorSalad
16:43:19 <preflex>  FunctorSalad is 0% lame
16:43:22 <FunctorSalad> =)
16:43:30 <sjanssen> "fusion" rather than "the fusion system that GHC currently uses"
16:43:43 <roconnor> GHC avoids all these bad cases?
16:43:47 <sjanssen> no
16:44:15 <roconnor> how is my statement too general?
16:44:16 <sjanssen> this problem does exist in the fusion system that GHC uses, but does not exist in some other systems
16:44:38 <dons> there are multiple fusion systems for haskell
16:45:00 <dons> not all "turn lots of bottoms into non-bottoms", and the ones that do have other side conditions that ensure you can't see them.
16:45:30 <roconnor> that's too bad.
16:45:39 <dons> why?
16:45:54 <roconnor> I'm all in favour of turning non-bottoms into bottoms.
16:46:07 <roconnor> what is better than a compiler turning a broken program into a working one!
16:46:14 <sjanssen> roconnor: that is a dangerous road
16:46:22 <dons> i like reverse . reverse == id :)
16:46:25 <roconnor> people always say that
16:46:31 <roconnor> I'm unconvinced
16:46:33 <dons> but id == reverse . reverse, not so fun
16:46:49 <dons> roconnor: write a library with useful rules that do this and change the world
16:46:49 <vixey> I don't like the idea of it,
16:46:54 <roconnor> reverse . reverse == id is an awsome optimzation that we may be losing out on.
16:46:54 <sjanssen> roconnor: just wait until GHC 6.12 diverges on the programs that GHC 6.10 doesn't
16:46:55 <FunctorSalad> couldn't it be directed? *naive*
16:46:58 <vixey> some idioms you have work, by compiler magic
16:47:09 <vixey> but you can't rely on that stuff..
16:47:30 <FunctorSalad> (so it only ever turns bottoms into non-bottoms)
16:48:07 <roconnor> case statements with branches that are all the same could pontentialy be removed
16:48:15 <FunctorSalad> (I understood dons as saying that currently it's an equivalence relation)
16:48:36 <roconnor> all sorts of wonderful things could be done if we are less anal about bottoms.  No pun intended
16:49:08 <roconnor> ... That is going into HWN isn't it. :(
16:49:21 <vixey> lol
16:49:30 <sjanssen> @remember roconnor all sorts of wonderful things could be done if we are less anal about bottoms.  No pun intended
16:49:30 <lambdabot> Good to know.
16:49:35 <sjanssen> byorgey: ^^^ HWN material?
16:49:50 <sjanssen> roconnor: practically guaranteed now :)
16:50:03 <mattam> :)
16:50:55 <dons> yeah, correctness is a funny thing.
16:51:16 <dons> if we didn't care about it, what fun we could have!
16:51:46 <roconnor> I think we should at least have a compiler option
16:52:02 <vixey> who cares if the program terminates .. as long as it gives the right answer :)
16:52:03 <dons> -fdo-what-i-say
16:52:12 <mattam> -unsafe... turn on safe optimizations.
16:52:20 <dons> -fdo-random-things
16:52:44 <sjanssen> -fi-do-not-care-about-the-results-of-this-program
16:52:56 <sjanssen> -fshoot-foot
16:53:07 <dons> -flooks-good-enough
16:53:11 <Zao> -foot-shoot
16:53:12 <roconnor> -fi-have-no-bottoms-so-remove-useless-pattern-matches
16:53:19 <conal> -fsemantics-shemantics
16:53:19 <dons> -fprove-it
16:53:21 <FunctorSalad> how can non-bottom-to-bottom optimizations make sth incorrect?
16:53:26 <sjanssen> conal: ha!
16:53:30 <roconnor> -fsee-catch
16:53:39 <sjanssen> @remember conal -fsemantics-shemantics
16:53:39 <lambdabot> I will never forget.
16:54:01 <conal> :)
16:54:30 <dons> -fassert-loose-reasoning-is-morally-correct
16:55:25 <Philly2> http://hpaste.org/11674 ...WHY??? lol
16:55:48 <vixey> anything with type [Integer] -> [(Tree a , Integer)] -> [(Tree a , Integer)] -> [Tree a] is going to be hell to write
16:56:14 <dons> i think hugs is saying you need Eq a, but no one uses hugs, so hard to say :)
16:56:43 <sjanssen> Philly2: what is the definition of Tree?
16:56:48 <mmorrow> vixey: i'm intrigued by that type sig
16:56:54 <Philly2> data Tree a = Empty | Node a (Tree a) (Tree a)
16:56:54 <BMeph> canal: -fsemantics-I-never-use-em ? ;)
16:56:55 <roconnor> @djinn [Integer] -> [(Tree a , Integer)] -> [(Tree a , Integer)] -> [Tree a]
16:56:55 <lambdabot> Error: Undefined type []
16:57:10 <BMeph> s/canal/conal/ (Whoops. :)
16:57:22 <roconnor> vixey: start with liftM3
16:57:48 <mmorrow> vixey: what's the context?
16:57:57 <vixey> from that paste by Philly
16:58:05 <rwbarton> Philly2: That source code does not produce that error in hugs.
16:58:18 * mmorrow looks
16:58:40 <sjanssen> Philly2: your first and last patterns are identical
16:58:47 <sjanssen> (shouldn't cause this error, but it is wrong)
16:59:18 <Philly2> ok..yeah..if I put it in a seperate file I dont get the error...
16:59:29 <Philly2> and yeah noticed it sjanssen :P
17:00:07 <rwbarton> Philly2: maybe there's another pattern for sodlist?
17:00:17 <rwbarton> Philly2: (does hugs not give you a line number? ick)
17:01:26 <Philly2> rwbarton: nope...only one in my file, and yes it gives the line number, its in sodlist [] _ _ = []
17:01:37 <Philly2> my bad for not providing it..lol
17:02:04 <Philly2> but again...if I put that stuff in a file alone I dont get the error
17:02:08 <eu-prleu-peupeu> i like haskell
17:02:10 <eu-prleu-peupeu> and haskell likes me
17:03:12 <adu> eu-prleu-peupeu: yey
17:04:43 <rwbarton> Philly2: I can only imagine this error if you have a bizarre redefinition of []. :P
17:05:05 <jethr0> is there a way to visualize whether two data structures are shared?
17:06:08 <vixey> jethr0, there is that reflective thing by augustss
17:06:15 <vixey> that only works for Nums though
17:06:22 <jethr0> hmm
17:06:49 <jethr0> i'm working on one of the project euler problems and want to use a tree of shared elements.
17:07:00 <Philly2> ok..the cause is the next lines after that segment, as it compiles np without em, but gives the error with them
17:07:02 <vixey> oh just do it
17:07:02 <Philly2> ...
17:07:08 <vixey> it will work fine
17:07:18 <jethr0> a very basic linear programming task, but runtime should be minimal and the program keeps on calculating. so i guess sharing is not working properly :(
17:07:19 <vixey> jethr0, I put an example with lots of sharing on hpaste by the way
17:07:27 <vixey> something to do with prime factors
17:07:40 <jethr0> @paste
17:07:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:08:50 <Philly2> http://hpaste.org/11675
17:09:00 <Philly2> there we go..the whole shabang ...
17:09:08 <rwbarton> Philly2: Like I said, another pattern for sodlist.
17:09:36 <Philly2> ohhh..I thought you meant another def...im sorry
17:09:50 <rwbarton> Philly2: Right, so you're trying to delete from a [(Tree a, Integer)], which requires an equality for Tree a
17:09:59 * jethr0 posted minimal example on http://hpaste.org/11676
17:10:22 <vixey> jethr0, I meant that I had put an example on hpaste
17:10:28 <rwbarton> Philly2: Probably what you want to do is add "deriving Eq" to the end of your data Tree a declaration, and add Eq a to the context of sodlist
17:10:37 <jethr0> vixey: i understood that ;)
17:11:21 <jethr0> the idea is to find the maximum path through the triangle. an easy linear programming task really
17:12:35 <Philly2> hmm..I have absolutely no clue what that does....therefore doubt I can use that in my asg :P
17:13:24 <rwbarton> Philly2: Imagine you have a tree of functions, or something else that can't be compared for equality
17:13:59 <rwbarton> Philly2: Then you won't be able to use 'delete' to find the tree to remove from your list.
17:15:09 <Philly2> I need to sort a list of Binary Trees using total order
17:15:18 <rwbarton> Philly2: Maybe you only need to remove elements from your list with matching Integer field, though, I don't know.
17:15:29 <rwbarton> Philly2: Then you wouldn't need to do any comparisons on trees themselves
17:16:13 <rwbarton> Philly2: Oh I see, you have a list of trees with integer labels, and a list of integers and you want to reorder the trees with their labels to match that second list?
17:17:40 <Philly2> so what im doing is [Tree]->[total order values], then [total order values]->[Tree]-> [total order values, Tree], then sorting [total order values], then [total order values, Tree]-> [sorted total order]-> [Total order sorted Tree]
17:17:56 <vixey> Philly2, why don't you make a type called TotalOrderValues?
17:18:47 <rwbarton> Yeah, I think I see what's going on here
17:19:18 <Philly2> the first trees can be any Ord
17:19:30 <Philly2> if I make a type, how will it simplify?
17:20:43 <rwbarton> There are two things you can do
17:21:26 <rwbarton> One is to keep this code but add an (Eq a) context to this function, like the Ord a context on your [Tree a] -> [(Tree a, Integer)] function (right?)
17:21:54 <rwbarton> The second is to avoid using delete
17:23:38 <Philly2> hm
17:27:16 <Twey> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/errorcheck.html — about halfway down the page, there's an assertion: 'Either is yet another instance of a monad.'
17:27:18 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/6mrh6q
17:27:31 <Twey> That's an error, isn't it?  The author meant to write 'Error'?
17:28:17 <jsn> is there a way to prevent classes from being exported? (not instances, but rather, the whole class)
17:28:33 <vixey> Twey, I don't that's the highest quality tutorial
17:28:35 <rwbarton> 'Either b' would be a monad, except that because of 'fail', there's some context on b
17:28:35 <Twey> jsn: No :(
17:28:41 <Twey> rwbarton: Aye
17:28:51 <jsn> Twey: curses
17:28:59 <Twey> vixey: It's crap for teaching Haskell
17:29:10 <Twey> vixey: Quite good for teaching how to write a Scheme interpreter, though :-P
17:29:24 <jsn> sometimes i get an error message like "<x> is not a (visible) method of class <c>"
17:29:37 <Twey> jsn: Yes, we curse it too
17:29:37 <jsn> does this mean i can declare "invisible" methods?
17:29:41 <vixey> I disagree, it's not really scheme
17:29:56 <Twey> vixey: I didn't say the example code was :-P
17:29:57 <vixey> it's sort schemeish but not in a good way
17:30:25 <Twey> It's the general method that's important.  It would be easy to write an actual Scheme after completing the tutorial.
17:31:34 <Saizan_> Twey: in Control.Monad.Error there's an instance Error e => Monad (Either e)
17:31:45 <vixey> Twey, SICP gives this a better treatment
17:32:04 <Riastradh> Allow me to differ, Twey.
17:32:12 <Twey> Saizan_: Aye, I'm aware of that... but it's crippled in some way, as I recall
17:32:16 <rwbarton> jsn: I don't think the class will be exported automatically, if there is an export list
17:32:21 <Riastradh> The language in the `Scheme in 48 Hours' tutorial could hardly be farther from Scheme.
17:32:33 <jsn> rwbarton: i will try it :)
17:32:36 <Saizan_> Twey: the (Error e) context :)
17:32:42 <Twey> Ah, yes, that one :)
17:32:51 <Riastradh> It is also a terrible exposition of Haskell and of building sequential abstractions with monads.
17:32:57 <Twey> Riastradh: I'm fairly sure that if it were COBOL, it would be quite a bit further from Scheme :-P
17:32:57 <jsn> what i am trying to do is some a "switch on type" (bad pattern, in general)
17:33:17 <jsn> so i want to make a module function that delegates to a class method
17:33:31 <jsn> but the class method will not creep out of the module
17:33:41 <vixey> Riastradh, you wrote a Scheme interpreter in Haskell
17:33:49 <Riastradh> That's right, vixey.
17:34:10 <Riastradh> (Well, I began to write one.  I lost interest in making it complete -- but the basic idea is actually close to Scheme, unlike the `Scheme in 48 Hours' bogosity.)
17:34:41 <vixey> Yeah, I thought your version was a lot more interesting and less amaturish..
17:34:42 <Riastradh> If I haven't removed it, it's probably still at <http://mumble.net/~campbell/tmp/Scheme.hs>.
17:37:43 <lispy> anyone know if the GHC 6.10 package for osx can be installed along side older releases?
17:37:55 <lispy> I have 6.6.1 and 6.8.3 that I want to keep around
17:38:21 <jsn> lispy: i have them both
17:38:39 <jsn> lispy: i used the beta package from a while ago, though
17:38:48 <jsn> lispy: so maybe that's not what you're asking about...
17:38:56 <lispy> jsn: I'm going to try RC1
17:39:04 <lispy> http://www.haskell.org/ghc/dist/stable/dist/6.10.1-rc-1/rc.html
17:39:12 <lispy> is there a more recent release candidate?
17:39:24 <lambdabot> Title: GHC 6.10.1 RC 1
17:41:28 <jsn> rwbarton: seems to work, yeah
17:41:31 <jsn> phew
17:41:49 <Saizan> @bot
17:42:06 <Saizan> we lost lambdabot?
17:42:12 <lispy> crap, I lost 6.8.3
17:42:23 <lispy> so that's a sucky thing about the installer
17:42:46 <rwbarton> jsn: yeah, I'm pretty sure this is how Text.Printf works; printf isn't a class method
17:42:57 <jsn> well, that's what we get for excepting MSFT stuff
17:43:01 <rwbarton> (although the class is visible)
17:43:05 <jsn> s/excepting/accepting/
17:43:12 <jsn> lispy: forced upgrade
17:43:24 <jsn> rwbarton: it is fine for the class name to be visible
17:43:41 <jsn> rwbarton: i just really don't want to export a bunch of garbage in to the namespace
17:44:14 <lambdabot> :)
17:49:26 <jsn> do OverlappingInstances involve some runtime overhead?
17:49:54 <dolio> They shouldn't, I think.
17:50:23 <dolio> It just uses a different solver.
17:50:27 <jsn> hmm
17:51:15 <jsn> they are so convenient, i figured there must be something wrong with them...
17:51:57 <dolio> Well, the solver isn't as easy to write, I think. :)
17:51:59 <mmorrow> i think the only two ways that instance selection (i can't think of the proper name for this at the moment) for a class is either (1) in some cases (all cases?) of polymorphic recursion, and (2) <i-can't-remember-this-one>
17:52:00 <rwbarton> I find them scary for some unquantifiable reason.
17:53:02 <mmorrow> err, instance selection sounds like the right name for that
17:53:05 <vixey> I kind of hate typeclasses
17:53:11 <mmorrow> does anyone know (2)
17:53:13 <mmorrow> ?
17:53:20 <vixey> they fit in the most awful kind of place which is "good enough"
17:53:31 <mmorrow> vixey: me too (other than for Functor and such)
17:53:39 <vixey> they basically work and are useful but I can't do half the stuff I want to with them :(
17:53:48 <ddarius> vixey: Use Chameleon
17:53:49 <mmorrow> totally how i feel
17:53:52 <vixey> so since they aren't abysmal, nobody fixes them
17:54:18 * mmorrow gets some food
17:54:19 <Peaker> vixey: what's wrong with type-classes?
17:54:20 <vixey> actually I didn't try with Chameleon..
17:56:00 <vixey> It's a brilliant idea of course
17:58:08 <lispy> how do you use the new GHC exceptions?
17:58:14 <lispy> the ones is 6.10
17:58:43 <lispy> Control.Exception.catch :: (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
18:04:29 <jsn> is there a way i could remove the parameters from the class methods in this code?
18:04:30 <jsn> http://github.com/jsnx/churros/tree/master/Data/International/Currency.hs
18:04:30 <BobFunk> anybody using haskell and sdl on os x?
18:04:36 <lambdabot> Title: Data/International/Currency.hs at master from jsnx's churros — GitHub, http://tinyurl.com/5qgvhu
18:05:02 <BobFunk> seems I need to go throught quite some hoops to use it, but the documentation isn't really helpfull
18:05:05 <jsn> i don't think 'asTypeOf' is right
18:05:13 <jsn> :t asTypeOf
18:05:14 <lambdabot> forall a. a -> a -> a
18:05:43 <lispy> <stdin>: hWaitForInput: end of file
18:05:50 <lispy> that seems to be something that changed in 6.10
18:06:46 <BobFunk> currently stuck with a "Warning: output was redirected with -o, but no output will be generated
18:06:46 <BobFunk> because there is no Main module." error
18:07:05 <Saizan> jsn: you need the type parameter of the class to appear at least once in the type of methods
18:07:23 <Saizan> jsn: so if you don't want parameters you'd have to put it in the type of the result
18:07:31 <jsn> Saizan: curses :)
18:08:16 <Saizan> BobFunk: how are you compiling your program?
18:09:40 <BobFunk> Saizan: right now just trying with ghc --make Test.hs
18:09:45 <BobFunk> Saizan: right now just trying with ghc --make Test.hs -o test
18:10:29 <BobFunk> found the Test.hs mentioned in the MACOSX file in the sdl tar here: http://darcs.haskell.org/~lemmih/hsSDL-old/src/Core/Examples/MacOSX/
18:10:34 <lambdabot> Title: Index of /~lemmih/hsSDL-old/src/Core/Examples/MacOSX, http://tinyurl.com/5u8goa
18:10:52 <BobFunk> and am just trying to get that example to work for a start
18:13:08 <unenough> how do i run lambdabot, so it will conect to IRC and join  some channel?
18:13:19 <Corun__> I've tried before
18:13:26 <Corun__> I gave up because it didn't seem to work
18:13:28 <Corun__> Good luck :-)
18:13:50 <Saizan> BobFunk: you need to pass -main-is Test
18:14:13 <Saizan> BobFunk: oh, sorry, -main-is Test.sdl_main actually
18:14:24 <unenough> Cale?
18:15:00 <Saizan> unenough: have you installed the package from hackage?
18:15:02 <BobFunk> Saizan: hmm, ok, that gets me a new error - now a linking one:
18:15:04 <BobFunk> Undefined symbols:
18:15:04 <BobFunk>   "_SDL_main", referenced from:
18:15:04 <BobFunk>       -[SDLMain applicationDidFinishLaunching:] in libSDLmain.a(SDLMain.o)
18:15:19 <Peaker> BobFunk: are you using --make ?
18:15:19 <unenough> Saizan, of course
18:16:15 <BobFunk> Peaker: yeah
18:16:45 <Saizan> unenough: under ~/.cabal/share/lambdabot-$ver/ you'd find an online.rc file, customize it to your needs and then launch lb with lambdabot -e 'rc online.rc'
18:17:03 <Saizan> well, 'rc path/to/online.rc'
18:17:04 <Peaker> unenough: note your ~/.cabal/bin directory should be in $PATH
18:17:18 <unenough> yes ok
18:17:25 <unenough> thanks
18:17:50 <dmwit> BobFunk: Well, have you got libSDL installed?
18:17:57 <BobFunk> dmwit: yeah
18:18:32 <dmwit> hum
18:18:43 <BobFunk> installed with macports
18:20:53 <BobFunk> is there any other way to get to do some 2D drawing with haskell?
18:21:28 <ddarius> There are a lot of ways.
18:22:05 <BobFunk> found cairo and sdl bindings from my googling, but haven't had any luck with getting any of them to work so far
18:22:51 <BobFunk> sdl wont work due to these problems, and the cairo bindings didn't compile
18:23:31 <ddarius> You can use OpenGL as well.  The various GUI libraries include ways to draw at various levels of abstraction.  You can generate images if that will work in a variety of formats.
18:23:47 <mmorrow> <lispy> roconnor: it would have been nice if we had Eq and EqRel so that when you request one or the other you know what you're getting
18:23:54 <mmorrow> lispy: because haskell
18:24:19 <mmorrow> 's type system can't express that
18:25:59 <mmorrow> this made me understand that and also how dependent types are both awesome and will be extremely useful http://www.cs.chalmers.se/~augustss/cayenne/paper.ps
18:26:06 <BobFunk> ddarius: any hints for how to just generate a png file from a list of pixels, f.ex?
18:26:24 <mmorrow> printf is eazy party with dependent types
18:27:22 <ddarius> BobFunk: The lowest-tech way would be to produce a ppm file and then convert from there.
18:27:28 <mmorrow> as are countless things i've wanted to/tried to do in haskell until i finally realized that their impossible without having the type of a function depend on the input value
18:27:37 <mmorrow> s/their/they're/
18:28:54 <BobFunk> ddarius: yeah - that's what I'm doing at the moment - but would like to output something more common straight away
18:29:01 <dmwit> BobFunk: What trouble did you have with Gtk2Hs?
18:29:15 <BobFunk> dmwit: it didn't compile
18:29:19 <dmwit> Are you installing the -dev versions of all your libraries?
18:30:05 <BobFunk> dmwit: macports has a portfile for gtk2hs - but it broke down with a haskell type error
18:30:54 <BobFunk> svgcairo/Graphics/Rendering/Cairo/SVG.chs:201:2:
18:30:54 <BobFunk>     Couldn't match expected type `()' against inferred type `CInt'
18:31:40 <dmwit> That doesn't sound like a library problem.
18:31:46 <dmwit> What version of GHC are you using?
18:31:58 <fatalerrorx> i have a question about how haskell generates its binaries
18:32:03 <BobFunk> dmwit: 6.8.3
18:32:09 <dmwit> huh
18:32:16 <fatalerrorx> is it possible to just rip out the code section out of the pe file?
18:32:47 <fatalerrorx> i would like to write a virtual machine in haskell
18:34:05 <mmorrow> BobFunk: http://haskell.org/haskellwiki/Library/PNG
18:34:06 <lambdabot> Title: Library/PNG - HaskellWiki
18:34:31 <fatalerrorx> i'm basically worried about relocation problems
18:34:35 <mmorrow> that code should be extendable to color PNGs without too much trouble
18:35:07 <dons> fatalerrorx: relocation problems?
18:35:13 <dons> do you mean portability?
18:35:17 <fatalerrorx> relocation the exe image
18:35:22 <dons> or are you writing a linker?
18:35:23 <fatalerrorx> relocating*
18:35:30 <fatalerrorx> exe protector
18:35:30 <dons> ok. what's your worry?
18:35:42 <mmorrow> fatalerrorx: this darcs repo is an ELF parser: http://www.cs.york.ac.uk/fp/darcs/ELF/
18:35:44 <fatalerrorx> currently in C++
18:35:44 <lambdabot> Title: Index of /fp/darcs/ELF
18:35:51 <mmorrow> you probably want something similar
18:35:57 <dons> mmorrow: oh, didn't know about that. there's one at UNSW as well.
18:36:01 <dons> and a binding to libelf floating around
18:36:10 <fatalerrorx> dons: its for windows
18:36:25 <lispy> dons: ghc-6.10 makes me cry!
18:36:42 <ddarius> @hackage imlib
18:36:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/imlib
18:36:53 <lispy> dons: the darcs GADT stuff breaks again on 6.10 :(
18:36:56 <dons> lispy: ah
18:36:57 <ddarius> @hackage hsmagick
18:36:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsmagick
18:37:05 <dons> lispy: but should only be type annotations right?
18:37:10 <dons> nothing fundamental?
18:37:17 <lispy> Well...
18:37:24 <dons> fatalerrorx: right. so what's your worry again?
18:37:29 <fatalerrorx> lol
18:37:37 <fatalerrorx> relocating the exe image
18:37:37 <lispy> I dunno for sure.  I'm giving up on 6.10 and reinstalling 6.8.3 for some other reasons.
18:37:43 <dons> fatalerrorx: why are you worried about that?
18:37:53 <mmorrow> dons: cool, i didn't know about those other elf libs
18:37:53 <fatalerrorx> haskell is non standard
18:37:57 <lispy> dons: it's also very hard to tell *where* the type annotations need to be.
18:38:01 <dons> fatalerrorx: ?
18:38:24 <dons> oh, you're relocating a haskell exe? i think we need more information about the task you're attempting.
18:38:30 <fatalerrorx> dons: basically i have no idea how the exes are structured in haskell
18:38:31 <dons> lispy: i thought you had the rules
18:38:53 <lispy> dons: well, take a look at this: http://hpaste.org/11677
18:39:00 <lispy> dons: that one isn't annotated enough :(
18:39:09 <dons> fatalerrorx: do you know how to look at an exe to see its structure?
18:39:19 <BobFunk> hmm, really just wanted to play around with some fractals, and thought haskell would be pretty well suited to it - and it was really easy to get a mandelbrot spit out as a ppm, but seems it might be easier just to play around with some ruby/python or java if I want to actually plot them to the screen
18:39:25 <fatalerrorx> yeah but haskell exe look wierd
18:39:33 <dons> BobFunk: why not use gtk2hs ?
18:39:37 <dons> or one of the dozen other graphics libs?
18:39:45 <sbahra> There is a gnuplot haskell package.
18:39:47 <dons> gtk is like 2 lines to load a .ppm into a window.
18:39:48 <sbahra> You probably want that.
18:40:00 <dons> fatalerrorx: right. so what's your question?
18:40:01 <BobFunk> dons: can't get it to compile so far
18:40:04 <lispy> dons: but I was looking at the problem you have with the darcs test suite for 6.10.  I have no idea what's going on there.  I get different results running darcs interactively versus from a .sh file
18:40:10 <sbahra> BobFunk, have you looked at the gnuplot package?
18:40:16 <dons> lispy: do you get similar results though?
18:40:22 <mmorrow> BobFunk: have you looked at the gd or opengl packages?
18:40:29 <sbahra> BobFunk, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gnuplot
18:40:31 <lambdabot> Title: HackageDB: gnuplot-0.2, http://tinyurl.com/5srmed
18:40:40 <dons> gd would be a good one. though just for loading image buffers, i use gtk
18:40:43 <mmorrow> ooh, is gnuplot new?
18:40:45 * mmorrow looks
18:40:47 <lispy> dons: well, running from a .sh file I get these errors about hWaitForInput
18:40:54 <dons> ah
18:41:10 <dons> BobFunk: http://code.haskell.org/~dons/code/testpattern/Main.hs
18:41:14 <lispy> dons: and I'm using base-3, so it's weird.
18:41:19 <dons> that's a simple program that loads an image and displays it, and intercepts some input
18:41:28 <dons> trivial really
18:42:39 <BobFunk> dons: yeah, the examples I've seen seems pretty simple - but as long as gtk doesn't compile it doesn't help a lot
18:42:57 <dons> oh, gtk the C lib? or gtk2hs the latest release of the haskell librayr?
18:43:16 <dons> did you report your build failure to dcoutts_ ? he can help with that if nec.
18:43:17 <BobFunk> the gtk2hs
18:43:27 <dons> otherwise, try a different lib. gd is good. there's lots of others.
18:43:46 <mmorrow> lispy: why don't you just if isEOF stdin ?
18:43:50 <dons> ruby and python et al are all just providing bindings to the same stuff anyway
18:43:52 <BobFunk> yeah - that's why I'm was spending quite a while trying to get SDL to work
18:44:08 <lispy> mmorrow: this sentence no verb?
18:44:12 <dons> ok. cabal install sdl ?
18:44:23 * dons loves cabal install
18:44:24 <mmorrow> heh, i was speaking the englskell
18:44:29 <BobFunk> yeah - but turns out SDL gives lots of trouble on os x
18:44:44 <BobFunk> so haven't actually gotten any SDL stuff to work in haskell yet
18:44:48 <dons> do you have the necessary C libraries for any bindings you're using?
18:45:39 <BobFunk> yeah - the problems with SDL is mentioned in a MACOSX readme in the tar - didn't spot it for a while since I was just using cabal
18:45:49 <mmorrow> myHWaitForInput h n = isEOF h >>= \eof -> return (not eof)
18:46:10 <mmorrow> (or whatever the old (broken-sounding to me ;) behavior was)
18:46:24 <mmorrow> oops, of course:
18:46:40 <fatalerrorx> dons: do you know how to get a dword from a bytstring?
18:46:44 <mmorrow> myHWaitForInput h n = isEOF h >>= \eof -> if eof then return False else hWaitForInput h n
18:47:12 <BobFunk> but even while following the instructions from the SDL MACOSX readme, and downloading the Test.hs mentioned there, I'm still not getting anywhere
18:47:14 <mmorrow> \bytestring -> Data.Binary.get bytestring :: Word32
18:47:19 <mmorrow> \bytestring -> Data.Binary.get bytestring :: IO Word32
18:47:27 <fatalerrorx> thanks mmorrow
18:47:39 <Saizan> IO?
18:47:42 <mmorrow> err, i
18:47:44 <mmorrow> yeah
18:47:45 <mmorrow> oops
18:47:52 <dons> mmorrow: you want to parse a bytestring into a Double?
18:47:57 <dons> or a Word32?
18:48:02 <dons> use Data.Binary
18:48:06 <fatalerrorx> i do dons
18:48:34 <mmorrow> \bytestring -> Data.Binary.decode bytestring :: [Word32]
18:48:45 <mmorrow> -- what i meant to mean ;)
18:49:13 <lispy> mmorrow: the problem is that hWaitForInput has changed and the new behavior only triggers when run from a shell
18:49:31 <lispy> But, 6.10 was too grieful, so I uninstalled it so I could have my 6.8.3 back.
18:49:37 <fatalerrorx> does Data.Binary come with ghc?
18:49:39 <lispy> So, I can't even check anymore
18:49:42 <fatalerrorx> windows ghc
18:49:47 <mmorrow> lispy: i just read a comment about hWaitForInput that probably explains that:
18:50:01 <mmorrow> err, better if i just link you than try to paraphrase
18:51:20 <dons> lispy: hehe.
18:51:26 <dons> ok. should be easy enough to fix
18:52:56 <roconnor> vixey: Would you agree that "the view from the left" eshews case statements?
18:53:48 <vixey> they use case a lot
18:54:08 <roconnor> ... that would be a no then. :)
18:55:50 <mmorrow> lispy: ok, found it. it's actually not directly related to hWaitForInput, although may be related. anyhow, i think it's interesting either way  http://hpaste.org/11678
18:58:01 <mmorrow> lispy: you'll have to face the future eventually ;)
19:00:05 <roconnor> vixey: I think 3.3 Hiding Obvious By-nodes is effectively eshewing case statements.
19:01:11 <thoughtpolice> fatalerrorx: no, you have to install it.
19:01:58 <roconnor> vixey: I think at section 3.3 and onwards, case statments are largely flattened into what we would call patterns.
19:04:41 <dolio> Your copy of The View from the Left has a section 3.3?
19:05:22 <mmorrow> what's The View .... ?
19:05:45 <dolio> It's one of the papers on Epigram.
19:06:05 <mmorrow> ah, that'll help in my unsuccessful google serching thus far
19:06:48 <dons> fatalerrorx: ghc is the compiler, a vast majority of libraries aren't distributed with ghc. you get them from hackage.haskell.org
19:08:43 <roconnor> mmorrow: http://www.cs.st-andrews.ac.uk/%7Ejames/RESEARCH/view-2001-12-06.pdf
19:08:58 <lambdabot> Title: ¢¡¤£¦¥¨§ © ¡ £¦¥¨§ ! " " ¡$#% §'&)(102 "© 3 ¡4 ¡457698@(7¡ ..., http://tinyurl.com/5rxhqz
19:09:00 <roconnor> mmorrow: the foundational paper for interactive program development.
19:09:18 <mmorrow> heh, i just literally found it 10 seconds ago
19:09:44 <roconnor> there are two versions, in this case I'm refering to the unpublished version
19:09:58 <mmorrow> ah, /me looks what he's looking at
19:10:11 <mmorrow> http://www.e-pig.org/downloads/view.pdf
19:10:24 <lambdabot> Title: ¢¡¤£¦¥¨§ © ¡ £¦¥¨§ ! " " ¡$#% §'&)(102 "© 3 ¡4 ¡457698@(7¡ ...
19:10:54 <roconnor> mmorrow: I think that is the published one
19:10:57 <mmorrow> they are definitely different
19:11:24 <mmorrow> so i should read the unpublished one (?)
19:12:04 <roconnor> yes
19:12:13 <roconnor> then when you are convinced of their greatness
19:12:23 <roconnor> you read the other paper on how to impelement it.
19:12:38 <roconnor> then you implement it
19:12:42 <roconnor> and you rule the world
19:12:48 <roconnor> and women will flock to you
19:13:34 <mmorrow> sounds like fun in the sun
19:14:05 <roconnor> mmorrow: don't get sunburned
19:14:14 <roconnor> :)
19:14:14 <mmorrow> spf 42, duh
19:14:46 <roconnor> I know someone who got sunburned reading it.
19:15:34 <mmorrow> scary
19:19:49 <sbahra> Hayoo?
19:19:57 <sbahra> ah, cool
19:26:36 <Philly2> If I have a type declared as: data Tree a = Empty | Node a Integer (Tree a) (Tree a)   . If I have [Tree a] , refered to as (x:xs), how do I fetch the Integer value from Tree x?
19:33:29 <mmorrow> theInteger :: Tree a -> Maybe Integer ; theInteger Empty = Nothing ; theInteger (Node _ n _ _) = Just n
19:33:51 <Philly2> Yeah thats what I did...thanks
19:33:53 <mmorrow> (fmap theInteger) :: [Tree a] -> [Maybe Integer]
19:33:58 <mmorrow> nice
19:34:01 <Philly2> mmorrow++
19:34:02 <Philly2> :)
19:34:08 <mmorrow> :)
19:34:20 <Philly2> oh..I didnt put the Just tho
19:34:30 <Philly2> showTreeOrder:: Tree a -> Integer
19:34:30 <Philly2> showTreeOrder (Node _ b _ _) = b
19:34:59 <mmorrow> unless you're 100% positive that'll never be called with an Empty, you probably want to deal with that case somehow
19:35:06 <Philly2> yup
19:35:26 <Philly2> ading the Just doesnt change anything?
19:35:35 <Philly2> *adding
19:35:54 <mmorrow> well, the type become  Tree a -> Maybe Integer    instead of    Tree a -> Integer
19:36:07 <dons> Philly2: probably nicer to use record syntax.
19:36:27 <mmorrow> , src ''Tree
19:36:28 <dons> data Tree a = Empty | Node { elem :: a, size :: Integer, left, right :: Tree a }
19:36:37 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
19:36:39 <mmorrow> oh haha
19:36:40 <dons> Philly2: then 'size' is a function of type :: Tree a -> Integer
19:36:47 <dons> heh
19:36:58 <mmorrow> dons: i though your response was lunabots and i thought i'd gone crazy for a second
19:37:12 <mmorrow> i couldn't believe my eyes
19:37:38 <Philly2> kk
19:37:50 <mmorrow> , src ''Forest
19:37:55 <lunabot>  type Forest a = [Tree a]
19:39:07 <mmorrow> i guess you could also do
19:39:37 <mmorrow> data Tree a = Node { elem :: a, size :: Integer, left, right :: Maybe (Tree a) }
19:39:56 <dons> mmorrow: heh
19:40:00 <mmorrow> and then move having to deal with the Maybes into the Tree handling code itself
19:40:02 <roconnor> type Tree a = (a,Forest a)
19:40:21 <mmorrow> type Tree a = (a, [Tree a])
19:40:41 <mmorrow> ooh, or
19:40:44 <roconnor> type Forest = [(a,Forest a)]
19:40:55 <mmorrow> type Tree a = (a -> [a])
19:41:12 <roconnor> mmorrow: I think you had it right before
19:41:28 <mmorrow> how do you mean?
19:41:39 <roconnor> > type Tree a = (a, [Tree a]) -- is correct
19:41:40 <lambdabot>   <no location info>: parse error on input `type'
19:41:56 <mmorrow> yeah, but i'm "mixing it up" a little ;)
19:42:23 <mmorrow> hmm, i guess actually yeah, it'd be
19:42:45 <mmorrow> type Forest a = (a -> [Forest a])
19:42:51 <mmorrow> hmm
19:43:15 <mmorrow> type Forest a = (a -> [a])
19:44:28 <mmorrow> type Forest = [(a,Forest a)]
19:44:43 <mmorrow> type Forest' a = (a -> Maybe (Forest' a))
19:45:08 <mmorrow> functify :: Forest a -> Forest' a
19:45:44 <mmorrow> functify = flip lookup
19:45:57 <mmorrow> err
19:46:58 <mmorrow> functify fs = (\a -> functify `fmap` lookup a xs)
19:47:56 <mmorrow> now, if we could only dynamically define datatypes/typesyns/newtypes we could try that out...
20:00:51 <MarcWeber> Is there a library showing how to add a cpp .h file to a cabal project so that it can be included from other depending projects?
20:00:52 <dmwit> That's an odd definition for functify.
20:02:32 <mmorrow> oh crap, for some reason i though the hcar entries were due by the 10th
20:02:45 * mmorrow starts writing stuff
20:03:16 <dmwit> MarcWeber: As far as I know, there's no good interface to C++.
20:03:33 <dmwit> MarcWeber: Generally you go via a C wrapper.
20:05:32 <thoughtpolice> mmorrow: what're you writing about?
20:05:34 <dmwit> Somebody should maybe update haskell.org/communities
20:08:29 <dons> i think haskell.org/communities should be a wiki
20:08:34 <dons> so we can all just visit to update our entries
20:08:41 <dons> this email/latex thing doesn't work for me.
20:08:47 <mmorrow> thoughtpolice: i'm not quite sure exactly yet, but i was thinking about some stuff on quasiquotation, check if sclv already did something on ieee-utils, pure-fft, i told gwern i'd say something about mueval, and possibly something about lunabot (although i'm not sure what since it's a mess right now)
20:09:09 <mmorrow> well, not lunabot, but the evaluator it's using
20:09:50 <mmorrow> preflex: seen sclv
20:09:50 <preflex>  sclv was last seen on #haskell 5 hours, 55 minutes and 47 seconds ago, saying: the source for the specific instances that is.
20:31:41 <Philly2> and bon apetit
20:31:50 <Philly2> mt :)
20:31:54 <Philly2> thanks ALOT for the help guys
20:36:32 <MarcWeber> dmwit :-) It's only a CPP macro I'd like to provide to be used in haskell source. I don't intend to use C++ ..
20:36:56 <dmwit> Oh, sorry, you meant the C pre-processor, huh?
20:38:38 <MarcWeber> dmwit: y
20:43:21 <gwern> @seen nominolo
20:43:21 <lambdabot> nominolo is in #haskell-soc, #ghc and #haskell. I last heard nominolo speak 2d 3h 56m 4s ago.
20:44:00 <gwern> @ask nominolo what's up with http://www.dtek.chalmers.se/~tox/site/http.php4 ? I don't think I've ever heard anything about it. if they're so much faster than the base http, why aren't they being used?
20:44:01 <lambdabot> Consider it noted.
20:44:11 <gwern> good news, everyone!
20:44:35 <gwern> _King of the Hill_ is finally getting cancelled
20:47:45 <mofmog1> it seems like everything hard in haskell are data types which are instances of functor
20:50:11 <dmwit> ?
20:51:07 <ddarius> Almost every data type can be or is an instance of functor (except unparameterized ones of course)
20:52:48 <mofmog1> in other words, everything hard in haskell are parameterized data types
20:54:11 <dobblego> data Zing t = Zing (a -> t) -- :)
20:56:53 <dons> everything hard in haskell is everything ;0
20:57:04 <dons> forall a . Hard a => a
20:57:39 <ddarius> newtype HF a b = HF (HF b a -> a)
21:00:37 <dmwit> ddarius: That's a weird one.  Are there any useful operations on it?
21:00:49 <ddarius> It forms an Arrow.
21:01:10 <ddarius> I think someone even found some actual practical use for it.
21:01:28 <dmwit> pure = const?
21:01:32 <dmwit> HF . const
21:06:43 <BMeph> ddarius: Isn't the SF type similar to that? :)
21:08:00 <blackdog> i think i may be misunderstanding this
21:08:03 <blackdog> main =   print [ y | a <- [Nothing, Nothing, Just 5, Just 4], y<-a ]
21:08:33 <blackdog> i thought i'd be able to use the list comprehension syntax for the maybe as well... is my memory that off?
21:08:42 <dmwit> They took that out in Haskell 98.
21:08:48 <blackdog> aw man
21:08:55 <dmwit> But what you just wrote wouldn't be allowed in Haskell 1.4, either.
21:09:06 <dmwit> The two (<-)'s there aren't using the same monad.
21:09:08 <rwbarton> You can write  Just y <- a  , though
21:09:12 <dmwit> yup
21:09:17 <blackdog> golden, that's what i need.
21:09:19 <blackdog> thanks
21:09:25 <dmwit> or use catMaybes
21:11:52 <dmwit> http://hpaste.org/11682
21:13:52 <dmwit> Also, does anybody else think ghci should switch it's set of options to match the file that was loaded when there's LANGUAGE pragmas?
21:15:03 <dons> mmm.
21:15:21 <dons> if you could show sensibly that more programs worked as a result, that would be a good argument.
21:15:25 <dons> ghci needs a roadmap.
21:15:34 <ivanm> @slap listings package for LaTeX
21:15:34 * lambdabot clobbers listings package for LaTeX with an untyped language
21:16:11 <dmwit> I don't know about more programs working.
21:17:18 <Axman6> hmm, what would be the best way to (statefully) store a list of seen values when creating a tree in parallel, i'm guessing STM?
21:17:39 <dmwit> Do you need concurrency?
21:17:44 <dmwit> oh
21:17:51 <dmwit> "in parallel" heh
21:18:06 <Axman6> yeah, concurrently i guess
21:18:08 <dmwit> Also, what do you mean by "seen values"?
21:18:36 <dmwit> But yeah, MVars (locking) or TVars (STM) are probably pretty good.
21:19:05 <Axman6> well, the tree i'm making, each value produces the same subtree from it, so if i start at 1, and then i get to putting in a 1 again, it's just a waste, i should just stop the tree there
21:20:28 <jsn> i think this should work:
21:20:29 <jsn> http://hpaste.org/11683
21:21:31 <jsn> it is using fundeps to disambiguate return types for a multi-parameter type class Terms which has at least one parameter that is a member of the type class Price
21:21:32 <Axman6> also, what would be an efficient way of storing these seen values? they're just Integers. i was thinking a Data.Map, but i only really need the keys.
21:21:53 <dmwit> Data.Set
21:22:05 <rwbarton> How large are they?
21:22:07 <jsn> the other parameter could be a Price, too
21:22:29 <Axman6> sounds god, thanks dmwit
21:23:22 <Axman6> good even
21:24:39 <jsn> i annotated the hpaste with the compiler error that i get:
21:24:42 <jsn>     Functional dependencies conflict between instance declarations:
21:24:46 <jsn> &c.
21:26:55 <rwbarton> jsn: Right, Range p might be an instance of Price, and then you have instances Terms (Range p) p and Terms (Range p) (Range p) which violate the functional dependency.
21:33:03 <jsn> Oh no
21:33:16 <jsn> rwbarton: is there any way out?
21:34:08 <jsn> to bad i can't say    absolutelynotinstance (Price p) => Price (Range p)
21:34:40 <jsn> s/to/too/
21:35:07 <dolio> You could lean on the GHC developers to implement total type families and use those instead. :)
21:35:14 <mmorrow> anyone have any clue what this might mean?
21:35:15 <mmorrow> Loading package terminfo-0.2.1 ... can't load .so/.DLL for: curses (/usr/lib/libcurses.so: file too short)
21:35:27 <mmorrow> too short??!?
21:35:40 <jsn> rwbarton: so, actually, i don't understand what you said
21:36:10 <dons> mmorrow: yes!
21:36:16 <dmwit> mmorrow: stick a few 0's on the end ;-)
21:36:16 <dons> i know exactly what that is, and how to fix it.
21:36:25 <mmorrow> ooh, excellente!
21:36:28 <ivanm> anyone know who defined the Haskell stuff for the LaTeX listings package?
21:36:31 <ivanm> because it blows :@
21:36:33 <dons> mmorrow: cat /usr/lib/libcurses.so and tell me what you see
21:36:43 <mmorrow> heh
21:36:45 <mmorrow> INPUT(-lncurses)
21:36:49 <dons> right
21:36:53 <mmorrow> wuh
21:36:58 <dons> now, ghci's linker doesnt' support linker scripts
21:37:02 <dons> so you have to use a symlink instead
21:37:03 <dons> $ ls -sal /usr/lib/libcurses.so
21:37:03 <dons> 0 lrwxrwxrwx 1 root root 14 2008-10-26 10:28 /usr/lib/libcurses.so -> libncursesw.so
21:37:06 <dons> for example
21:37:15 <mmorrow> ahh, /me tries
21:37:26 <dons> (check the ncurses.so isn't also symlinked to libncursesw.so)
21:37:30 <dons> it was on my system
21:37:37 <dons> $ ls -sal /usr/lib/libncurses.so
21:37:37 <dons> 0 lrwxrwxrwx 1 root root 14 2008-10-27 13:40 /usr/lib/libncurses.so -> libncursesw.so
21:38:03 <jsn> what i am hoping is that the instance declaration says, "for any Range of any Price p, there is an instance of Terms such that asPrice gets us a Price p from the Range"
21:38:04 <dons> so i'm not sure if we shouldn't file a ticket for ghci to use something else for its linker, if using linker scripts is going to become more common
21:38:39 <jsn> rwbarton: basically, i don't see where my actual mistake is
21:39:21 <mmorrow> dons: beautiful, thx :)
21:39:30 <rwbarton> jsn: If the 't' parameter is Range q, the 'p' parameter could be either q or Range q
21:39:53 <dons> mmorrow: what distro?
21:40:00 <mmorrow> fedora8
21:40:17 <dons> ok. so also on arch. i guess we'll see more of this when people try to use things with terminfo
21:40:40 <mmorrow> dons: out of curiosity, this would be handled by Linker.c and not Linker.lhs, right?
21:41:07 <jsn> rwbarton: aha
21:41:08 <mmorrow> (or are they various levels of the same thing)
21:41:55 * mmorrow had been trying to figure out what's happening in Linker.lhs recently
21:42:04 <dons> mmorrow: yessir
21:42:07 <mmorrow> s/had/has
21:42:27 <jsn> rwbarton: well, wait -- i don't actually see why that is
21:42:37 <jsn> err, wait
21:42:41 <mmorrow> hmm
21:42:43 <jsn> i'm just going to think about it a bit
21:44:39 <rwbarton> jsn: Bear in mind that contexts on instance declarations have absolutely no effect on this kind of issue
21:45:40 <jsn> oh?
21:45:56 <jsn> rwbarton: so it is just the presence of the other instance?
21:46:42 <rwbarton> jsn: if you have  class Foo a b | a -> b then you can not have both instance Foo a a and instance Foo (X a) a
21:46:58 <jsn> oh ouch
21:47:06 <dmwit> What?
21:47:15 <dmwit> That doesn't sound right.
21:47:25 <jsn> well that is just the instance i am trying to get
21:47:39 <jsn> both of them, i mean
21:47:56 <rwbarton> dmwit: why not?
21:48:12 <rwbarton> suppose  class Foo a b | a -> b where bar :: a -> b
21:48:24 <rwbarton> if x :: X a, what is the type of bar x?
21:49:05 <dmwit> a
21:49:28 <dmwit> It's instance Foo a a and instance Foo a (X a) that ought to be forbidden.
21:49:43 <rwbarton> dmwit: the 'a' in the first instance could be 'X a'
21:50:00 <dmwit> so?
21:50:15 <dmwit> oh
21:50:33 <dmwit> Yeah, okay.
21:50:59 <dmwit> instance Foo a anything is pretty bad, huh?  You can't make *any* other instances.
21:51:04 <dmwit> yikes
21:51:18 <jsn> aha
21:51:37 <jsn> okay, i see what is going on here
21:51:42 <rwbarton> Right, because you've defined the "function" anything = Foo(a).
21:52:32 <jsn> so maybe i can remove the fundep, let's see...
21:53:20 <dolio> One might expect his example to work with overlapping instances.
21:53:30 <dolio> But I don't know if fundeps interact with it that way.
21:54:16 <jsn> adding the overlapping instances pragma does not help, unfortunately
21:54:26 <dolio> Yeah, that isn't too surprising.
21:54:34 <jsn> just removing the fundep makes it compile
21:54:58 <jsn> i can not remember why i introduced it, actually
21:56:25 <rwbarton> Without the functional dependency, you'll have to write a type signature a lot of the time you call asPrice
21:56:56 <jsn> i guess i am okay with that, for now
21:57:39 <jsn> i broke this different components out of     data    declaration when i felt i'd have cleary different purposes for them most of the time
21:57:50 <jsn> they just overlap in this one little way
22:00:22 <Axman6> hmm, i expected 6.10 to be out by now
22:03:11 <ivanm> Axman6: and I expected to be reading RWH by now ;-)
22:03:16 <jsn> i wish the library had a stylesheet that was black and green
22:03:29 <jsn> s/library/library documentation/
22:03:38 <Axman6> ivanm: yeah... where is it? :(
22:03:46 <jsn> then it would not blind me when i switched from IRC or VIM :)
22:03:52 <ivanm> isn't released till early december :(
22:04:01 <dons> ivanm: !?
22:04:12 <dons> ah .
22:04:21 <dons> ghc 6.10 out real soon. RWH out end of month.
22:04:38 <Axman6> :)
22:04:40 <ivanm> oh? says december here: http://www.fishpond.com.au/Books/Computers/Programming/General/product_info/12316290/
22:04:42 <lambdabot> Title: Fishpond.com.au: Real World Haskell, Donald Stewart Bryan O'Sullivan - Shop Onli ..., http://tinyurl.com/5ptful
22:04:58 <dons> i'm not sure what they know i don't know.
22:05:09 <Axman6> heh, hadn't realised don was short for donald. awesome
22:05:13 <dobblego> takes a month for it to float to .au
22:05:18 <dons> heh
22:05:23 <Axman6> and two weeks to dry
22:06:58 <ivanm> Axman6: you didn't? :o
22:07:09 <ivanm> dobblego: :(
22:07:17 <Axman6> hadn't thought about it
22:07:36 <ivanm> dons: whose fault is it that it's shipping late (since IIRC you originally said it would be shipping in Oct)? yours or O'Reilly's?
22:07:45 <ivanm> (where by yours I mean all three of you)
22:09:19 <dmwit> If I were dons, I would in no way feel compelled to answer that question.
22:09:56 <ivanm> heh
22:10:22 <dmwit> I mean, even if it were O'Reilly's fault, does it really make sense to badmouth your publisher?
22:10:32 <ivanm> fair enough
22:10:42 <ddarius> Bad mouth the paper makers!
22:11:09 <ivanm> nah, it's the artist fault
22:11:20 <ivanm> he took too long drawing the beetle ;-)
22:16:33 <dons> ivanm: it turned out to be 700 pages instead of 300
22:17:24 <Axman6> yay, extra value!
22:17:34 <ddarius> It's Industrial Size
22:17:40 <ivanm> dons: oh, so the october estimate was from way back?
22:17:47 <dons> yeah.
22:18:11 <jsn> where can i get a list of stuff that's deriveable?
22:18:19 <ddarius> The Report
22:18:47 <jsn> that's it, even for GHC?
22:19:01 <ddarius> I think Data and Typeable are the only things GHC adds.
22:19:11 <jsn> okay, good to know
22:19:17 <ddarius> It also adds newtype deriving, but that is a bit different.
22:19:30 <ddarius> If you want to know what all GHC adds you read the GHC User Manual.
22:19:42 <jsn> i'm trying to write as little of my own Integral instance as possible
22:19:57 <jsn> yeah, i am looking for it in there
22:21:36 <rwbarton> Is your type a newtype of a member of Integral?
22:24:22 <jsn> ddarius: looks like you are right, that's all there is at present
22:25:41 <mofmog> so what's the advantage of getting RWH in book form (other than having it physically)?
22:26:00 <ddarius> Not much.
22:26:07 <Nafai> Has anyone ever written a MUA in Haskell? :)
22:26:26 <ddarius> I'm pretty sure the answer is Yes.
22:26:37 <Nafai> mofmog: Paying dons, bos, et al for their hard work
22:26:56 <ddarius> Nafai: The particular project I'm thinking of was pre-Hackage though.
22:27:03 <mofmog> i could just donate in that case
22:27:12 <mofmog> w/o incurring the destruction of trees *shrug*
22:27:45 <jsn> if use a newtype, though i can derive pretty much anything i want
22:27:48 <jsn> interesting
22:28:01 <Nafai> I'm just in another one of my whining sessions about MUAs so I was looking around
22:28:28 <xmux> What software does the RWH online book use?  Is it something which is publically available?
22:32:35 <mmorrow> jsn: get the derive pkg from hackage, then you can do stuff like http://hpaste.org/11685
22:33:14 <dons> mofmog: you could buy the .pdf
22:33:23 <dons> (at least amazon has .pdfs that are 10 bucks cheaper)
22:33:36 <dons> xmux: not available publically yet, but we get a lot of questions. bos wrote it.
22:33:57 <dons> the new scala book is going to do something similar, afaik
22:34:00 <xmux> yet? :)  So you will publish it eventually
22:34:03 <jsn> mmorrow: interesting
22:34:05 <dons> they're modelling their dev process on rwh's
22:34:09 <dons> xmux: i think so.
22:34:10 <mmorrow> jsn: very :)
22:34:27 <xmux> I like the idea a lot and have been thinking about writing a user manual for some software that way
22:34:31 <fatalerrorx> i need help really quick i think i just sort of fork bombed our uni server
22:34:48 <fatalerrorx> i need to kill all processes named yes
22:34:49 <dons> xmux: yeah, i was thinking of how we could do a similar thing for any man page or documentation
22:34:50 <thoughtpolice> mmorrow: derive ftw!
22:34:56 <dons> its like a wiki, but with editorial oversight
22:35:03 <jsn> fatalerrorx: go to #linux
22:35:05 <xmux> It seems to produce really good results :)
22:35:11 <jsn> fatalerrorx: or #unix
22:35:15 <mmorrow> thoughtpolice: x10 + to the max
22:35:16 <dons> right. its a good model for some things.
22:35:28 <dons> the 'wikipedia' model doesn't work for all forms of publishing.
22:35:39 <dons> sometimes the workflow is structured differently, and we don't have good tools for that yet
22:35:48 <fatalerrorx> i need help now
22:35:58 <fatalerrorx> #unix only got 28 people
22:36:12 <jsn> fatalerrorx:    killall yes
22:36:31 <fatalerrorx> thanks
22:36:44 <jsn> fatalerrorx: but if you actually fork bombed it, i don't know that you've got any recourse
22:36:47 <fatalerrorx> permission denied
22:36:53 <mmorrow> -9 if you intend to be maximally lethal
22:37:02 <jsn> fatalerrorx: you are not root?
22:37:05 <fatalerrorx> no
22:37:09 <jsn> okay
22:37:25 <rwbarton> is it a solaris machine
22:37:25 <fatalerrorx> i'm dragging the server down big time
22:37:26 <rwbarton> ?
22:37:27 <fatalerrorx> yes
22:37:30 <jsn> so, you started some processes called yes?
22:37:35 <fatalerrorx> yep
22:37:38 <mmorrow> and did so as root?
22:37:41 <fatalerrorx> no
22:37:48 <jsn> okay, well, hmm
22:37:53 <thoughtpolice> Nafai: what email client do you use these days? mutt?
22:38:15 <jsn>     ps waux | egrep yes | xargs kill -9
22:38:17 <jsn> maybe
22:38:20 <Nafai> thoughtpolice: Thunderbird and mutt
22:38:55 <jsn> i'm not sure about how to win the race with    yes    :)
22:38:57 <thoughtpolice> Nafai: i like sup :] but i've also thought of perhaps writing a email client in haskell...
22:39:10 <Nafai> I just looked at sup and am unsure of what I think
22:39:25 <fatalerrorx> jsn: nope
22:39:44 <fatalerrorx> kill bad argument count
22:39:52 <fatalerrorx> oh crap
22:39:53 <thoughtpolice> Nafai: i like it a bunch - been using it since the 0.2 release
22:39:55 <thoughtpolice> it is worlds better now
22:40:00 <mmorrow> what does:
22:40:01 <mmorrow> ps aux | grep [y]es | cut -d' ' -f1
22:40:02 <fatalerrorx> i'm dead
22:40:04 <mmorrow> say?
22:40:24 <jsn> fatalerrorx: yes
22:40:33 <Nafai> The labels thing is a bit weird, since I already have heirachal folders set up that procmail already puts things in for me
22:40:46 <jsn> mmorrow: oh, yeah, duh -- i am so out of it
22:40:51 <thoughtpolice> Nafai: but I like it because it takes the gmail philosophy and applies it to a regular client - you shouldn't store your email based on "what to delete/save," just give the user powerful search facilities and generic labels to put on my messages and it'll work even better
22:40:56 <mmorrow> jsn: hehe
22:40:58 <fatalerrorx> omg this is so bad
22:41:07 <mmorrow> is yes owned by you or not
22:41:12 <mmorrow> (the proc)
22:41:26 <jsn> there are like thousands of them, right?
22:41:35 <mmorrow> oh, haha
22:41:36 <jsn> fatalerrorx: each yes makes even more yes?
22:41:55 <thoughtpolice> Nafai: since then you don't have to store email based on "what to delete/save," you can just store it and search later - it really works out wonderfully tbh
22:42:05 <fatalerrorx> not sure i did yes | rm blah blah in python script
22:42:24 <fatalerrorx> or something like that and it went all to hell
22:42:32 <jsn> fatalerrorx: you are the admin for this server?
22:42:36 <fatalerrorx> nope
22:42:43 <mmorrow> what about
22:42:47 <mmorrow> killall -9 yes
22:42:49 <jsn> this is a critical server at your university?
22:42:55 <Nafai> thoughtpolice: Probably, I'd have to get used to it
22:43:00 <thoughtpolice> also sup doesn't ever physically touch your mail so if it crashes the WORST that will happen is you will have to do 'rm ~/.sup/lock; sup' and it will re-sync the index (it indexes all mail in a single file, and when you go to view a thread, it looks it up and *then* retrieves it off the disk)
22:43:21 <Nafai> Sounds nice
22:43:26 <thoughtpolice> so it can handle thousands of messages really easily
22:43:40 <thoughtpolice> back when it was at like 0.2 when I was subscribed to lkml, it could handle it pretty well
22:44:02 <Nafai> How does it handle html mail and such?
22:44:10 <mmorrow> fatalerrorx: well, i guess you find someone that can be root or start drinking :)
22:44:29 <jsn> fatalerrorx: i think this is actually a "higher level" problem
22:44:31 <mmorrow> because clearly you have no more options
22:44:35 <thoughtpolice> Nafai: it's an attachment; just save (type 's' on the attachment) and it saves it to ~/
22:45:01 <fatalerrorx> jsn: the admin just banned me from the computers
22:45:08 <jsn> fatalerrorx: just now?
22:45:09 <mmorrow> lol
22:45:28 <fatalerrorx> i have to see a commitee now to explain my actions
22:45:30 <dons> yeah, that can happen.
22:45:34 <mmorrow> oh sucky
22:45:43 <jsn> fatalerrorx: well, that's probably just as well
22:45:47 <fatalerrorx> thing is my project is due monday
22:45:49 <mmorrow> fatalerrorx: so what was the command you execed
22:45:51 <jsn> do you have a trasnscript?
22:45:53 <thoughtpolice> Nafai: there are still a few problems, the only 3 big ones to me are: utf8/encoding and screen refreshing is kinda bugged out (has to do with ruby actually it seems,) performance could be better (it's gotten substantially better since it was released though) and there is still the occasional crash
22:45:55 <thoughtpolice> but that's about it
22:45:58 <thoughtpolice> it's still a beta release
22:46:11 <fatalerrorx> mmorrow: don't know
22:46:18 <fatalerrorx> jsn: not sure
22:46:20 <Nafai> Perhaps I'll play with it some more
22:46:27 <thoughtpolice> and it works pretty solid on large amounts of email, I'm not on lkml anymore (just too much for my brain,) but I'm subscribed to about 5 mailing lists or so and it works nicely
22:46:45 <jsn> fatalerrorx: so when you say a server, you actually mean a work station
22:47:02 <jsn> fatalerrorx: you were not on some front-facing web or mail server or something like that, were you?
22:47:06 <fatalerrorx> i ssh access
22:47:14 <fatalerrorx> to a bunch of servers
22:47:22 <thoughtpolice> Nafai: but I think it applies the 'gmail approach' pretty well and the text searching facilities it offers are apparently extremely powerful (you can search by arbitrary MIME fields with all sorts of options and whatnot)
22:47:37 <thoughtpolice> so I consider it a pretty damn good option :]
22:47:37 <jsn> fatalerrorx: but they are machines where other students do work, right?
22:48:03 <jsn> fatalerrorx: you are working on a class project or something like that, i assume?
22:48:07 <mmorrow> fatalerrorx: just email the admin and tell him to unban you. if you just tell him what happened i'm sure he'll understand
22:48:35 <fatalerrorx> jsn: yes
22:48:43 <jsn> fatalerrorx: i guess what i'm saying is, it's not that bad from their point of view, unless you took down something front-facing
22:48:59 <jsn> fatalerrorx: it's just embarrassing
22:49:50 <fatalerrorx> just i don't do something like that again whats so bad about yes | rm -R ....
22:50:03 <fatalerrorx> i think that is what caused it
22:50:04 <BMeph> Heh-heh - yo, thoughtpolice: What's sup? ;)
22:50:17 <thoughtpolice> BMeph: http://sup.rubyforge.org
22:50:18 <lambdabot> Title: Sup
22:50:23 <jsn> fatalerrorx: use    -f
22:50:46 <jsn> fatalerrorx: i can not tell what caused the problem from your description of it
22:51:02 <jsn> fatalerrorx: but use    -f    in the future
22:51:20 <fatalerrorx> ok
22:51:33 <fatalerrorx> sent an email fingers crossed
22:52:11 <thoughtpolice> BMeph: it's something like "gmail in ur terminal, invadin' ur emailz" :]
22:52:17 <thoughtpolice> :]
22:52:29 <mmorrow> in yer loop uppin yer vars!
22:53:05 <jsn> i like how gmail sought to merge chat & email
22:53:22 <jsn> i don't think their mergination is complete, but it's nice to get missed chats in my inbox
22:54:23 <solrize_> @seen mjd
22:54:24 <lambdabot> I haven't seen mjd.
22:54:32 <solrize_> @seen dominus
22:54:33 <lambdabot> I haven't seen dominus.
22:54:46 <ddarius> @seen ylrnny
22:54:46 <lambdabot> I haven't seen ylrnny.
22:55:01 <solrize_> anyone know if mjd hangs out here?
22:55:10 <ddarius> He does.
22:55:56 <ddarius> @google site:tunes.org inurl:haskell mjd
22:55:58 <lambdabot> No Result Found.
22:56:06 <solrize_> thanx
22:56:26 <ddarius> @seen yrlnry
22:56:26 <lambdabot> I haven't seen yrlnry.
22:56:35 <ddarius> preflex: seen yrlnry
22:56:35 <preflex>  yrlnry was last seen on #perl 2 days, 13 hours, 25 minutes and 20 seconds ago, saying: ryakubo++
23:15:02 <fatalerrorx> yay we have access again
23:26:08 <lol0l> DCC SEND "startkeylogger" 0 0 0
23:27:49 <fatalerrorx> wtf
23:29:06 <thoughtpolice> nice
23:37:25 * mmorrow spend 30 minutes getting yi-vty-0.2.1 to build on 6.10, then build the haddocks
23:37:35 * mmorrow then read in the haddocks "Note that this package is intended for Yi versions 0.2 and below, *not* 0.3, 0.4 or up. This and yi-gtk are functionally obsolete."
23:37:39 * mmorrow sighs
23:37:57 <ivanm> heh
23:38:07 * BMeph pats mmorrow on the electronic shoulder
23:38:20 <mmorrow> :)
23:38:29 <ivanm> see, its times like these that hackage's policy of archiving _everything_ can be annoying
23:41:29 <mmorrow> the file Yi.Kernel actually has a /really/ good way to abstract out the constantly changing parts of the GHC api. i didn't have to change _anything_ ghc-api related, and that's amazing since it got completely redone with a "GhcMonad" and other various api-changing things
23:41:52 <dons> ivanm: ?
23:42:04 <dons> mmorrow: mmm. good
23:42:13 <dons> we need that for the exception layer
23:42:43 <ivanm> dons: ?
23:43:16 <mmorrow> dons: i think something similar is just what i'm looking for for luna(bot)
23:43:43 <ivanm> mmorrow: how different is lunabot from lambdabot?
23:44:54 <mmorrow> ivanm: way different. lunabot's isn't actually intended to be an ircbot, i just wrote a hacky irc frontend
23:45:13 <mmorrow> so lambdabot has plugins etc
23:45:59 <mmorrow> and lambdabot used to use hs-plugins for eval unitl recently, and now uses hint which uses the ghc-api
23:46:29 <ivanm> ahhh
23:46:32 <mmorrow> it looks like hint is writing the expressions to a dummy module file in /tmp, then compiling them to mach code, then grabbing their stdout
23:46:33 <mmorrow> since
23:46:36 <mmorrow> > fix id
23:46:38 <lambdabot>   * Exception: stack overflow
23:46:40 <mmorrow> oh
23:46:43 <mmorrow> bytecode
23:46:46 <ivanm> hint? I thought it used meuval?
23:46:54 <mmorrow> yeah, mueval uses the hint package
23:47:26 <mmorrow> lunabot's eval uses the ghc-api directly to compile expressions
23:47:56 <mmorrow> and it's actually using the same exact function to go String -> _ as is available inside that function's env
23:48:24 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"") :: Integer
23:48:37 <lunabot>  42
23:48:56 <mmorrow> so that's actually three levels deep in evals since the evaluator itself is using that same function with the String coming in over irc
23:49:11 <thoughtpolice> how cute :]
23:49:20 <mmorrow> hehe
23:49:27 <thoughtpolice> mmorrow: also back when I looked at yi 0.2 I saw the Yi.Kernel file and it is in fact pretty nicely laid out
23:49:37 <thoughtpolice> there's an unsafeCoerce# in there but the usage is fairly justified really
23:50:05 <mmorrow> heh, yeah i saw that. it's essential since the incoming expression just got compiled to bytecode
23:50:22 <thoughtpolice> mmorrow: I've been thinking of hacking on yi recently... i installed 0.5.1 outta darcs and since 0.5.0.1, it seems like most of the noticable memory leaks have been fixed
23:50:25 <mmorrow> and types are erased (Core -> ByteCode)
23:51:00 <mmorrow> thoughtpolice: ooh, nice. i just rebuilt  0.4.4. i need to darcs pull
23:51:03 <thoughtpolice> mmorrow: yeah, and using fromJust/fromDynamic really sucks because you're restricted to monomorphic types...
23:51:12 <mmorrow> totally
23:51:33 <mmorrow> but when you're not over IRC you can use compileExpr :: .... -> HValue
23:51:43 <thoughtpolice> mmorrow: yeah 0.5.x is much better - if you look htop when using something like 0.4, you'll notice if you just type some stuff and even erase it afterwords, memory usage increases and never goes back down
23:51:49 <mmorrow> where HValue is pretty much == Any
23:51:51 <thoughtpolice> that's not the case anymore, it seems
23:51:52 <thoughtpolice> :]
23:52:15 <thoughtpolice> memory usage is pretty constant.
23:52:19 <mmorrow> nice
23:53:02 <thoughtpolice> mmorrow: particularly I was thinking of perhaps writing a mode for agda or maybe trying to implement macro functionality.
23:53:22 <thoughtpolice> i would have probably switched to yi already -- i mean, configuration in haskell *is* awesome -- but I use C-x ( .. C-x ) too damn much
23:54:49 <mmorrow> darcs getting now
23:55:57 <mmorrow> thoughtpolice: heh. i'm sure you could fully emulate your usual interface to move to yi. i'm not sure though how much effort it'd take to do so
23:56:30 * mmorrow is just learning how to customize/configure yi
23:56:33 <thoughtpolice> mmorrow: I think I could deal with it for sure
23:56:55 <thoughtpolice> plus yi seems like something fun to hack on
23:57:09 <thoughtpolice> and for customizing, looking through the code really does help a lot
23:57:51 <mmorrow> thoughtpolice: the first think on my list is to get comfortable/efficient enough in yi to be able to use it as my primary editor, while at the same time adding eval stuff from luna in
23:57:57 <mmorrow> s/think/thing/
23:58:34 <thoughtpolice> mmorrow: yeah, I want to be at least comfortable editing in it first
23:58:59 <thoughtpolice> it's gotten much better, to be sure (I *do* remember using yi 0.2 in the past; wasn't as nice)
23:59:20 <thoughtpolice> also I recently switched around some of my configs so I'm back to using emacs-without-UI instead of carbon emacs
23:59:35 <thoughtpolice> meaning haskell-mode doesn't magically work anymore like it did :P
23:59:47 <thoughtpolice> so i'm somewhat inclined to switch
