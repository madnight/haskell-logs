00:11:21 <wagle> is there a way to initialize a var to "list of list", "dict of dict", etc?
00:11:30 <wagle> oops, add in python
00:12:07 <BeelsebobWork> x :: [[a]; y :: Map k (Map k' a)
00:12:08 <BeelsebobWork> :P
00:12:23 <BeelsebobWork> oops, missed a close brace
00:12:34 <Axman6> PARSE ERRORZ!
00:12:40 <BeelsebobWork> :P
00:12:53 <Axman6> that's a good way to get someone killed man
00:14:16 <dons> wagle: no initialiation here. just declare your intent.
00:14:38 <dons> poor python. stuck in the 20th century.
00:14:41 <BeelsebobWork> hehe
00:17:37 <Korollary> wagle: x = [[1,2], [3,4]] works
00:18:06 <dmwit> (even in Python)
00:19:13 * wagle is havingh haskell-envy while writing python
00:21:12 <Savant> Hm, what're your thoughts on Ocaml, wagle ?
00:23:11 <wagle> Savant, keep meaning to learn it
00:23:26 <Savant> Ah
00:23:39 <wagle> yeah
00:24:15 <Savant> Well, in comparison to haskell, what are your views?
00:24:31 <mapreduce> It looks like it should be easy to learn if you know Haskell and are used to strict languages.
00:24:32 <wagle> why you ask?  what would I find?
00:24:53 <Savant> wagle: I'm just interested in another point of view.
00:24:58 <Korollary> It's fairly easy to learn.
00:24:59 <ivanm> wagle: free membership in the harrop appreciation society? ;-)
00:25:01 <Savant> mapreduce: Yeah.
00:25:06 <dons> isn't it just haskell-without-the-fun?
00:25:24 <ivanm> dons: oh, you mean haskell = ocaml + fun?
00:25:25 <Saizan> + ML functors
00:25:26 <Savant> dons: 'Without-the-fun' ?
00:25:41 <dons> ivanm: yeah :) haskell's more fun. we get all the new toys.
00:25:50 <ivanm> so haskell = sml + objects + fun? ;-)
00:25:52 <Savant> funk.
00:25:53 * Badger divides haskell by ocaml
00:25:55 <ivanm> s/sml/caml/
00:25:57 <wagle> python is like programming in scheme, except without the !'s marking the destructive operations
00:25:57 * Badger profits!
00:26:10 <ivanm> Badger: haskell/ocaml = 1 + fun/ocaml
00:26:14 <dons> heh
00:26:16 <mapreduce> I noticed there's an ocaml for the JVM, and there's F# for .NET.
00:26:16 <ivanm> doesn't really give you much...
00:26:17 <Vq^> dons: thats why i haven't been able to learn ocaml despite jumping at it a few times :/
00:26:18 <Badger> d'oh
00:26:21 <Korollary> wagle: and no macros, decent lambdas, etc.
00:26:33 <dons> mapreduce: ocaml for the jvm? i bet its not 'ocaml'.
00:26:37 <ivanm> and wacky tuple type syntax IIRC
00:26:53 <dons> ?go salsa haskell
00:26:55 <lambdabot> http://www.haskell.org/haskellwiki/Salsa
00:26:55 <lambdabot> Title: Salsa - HaskellWiki
00:26:56 <mapreduce> dons: Dunno.  What would be the problem with having ocaml on a JVM?
00:27:03 <dons> it doesn't exist?
00:27:09 <Vq^> Korollary: is the lambdas that much worse in python than in scheme?
00:27:11 <wagle> eh, macros with obsessive compulsive disorder..
00:27:11 <ivanm> @go ocaml jvm
00:27:13 <lambdabot> No Result Found.
00:27:15 <dons> hah
00:27:19 <ivanm> dons: you were right!
00:27:27 <ivanm> @go ocaml fun
00:27:28 <lambdabot> No Result Found.
00:27:28 <dons> we'd have heard much more about say, ocaml on the android phone, if it was the case.
00:27:30 <ivanm> @go haskell fun
00:27:32 <lambdabot> http://changelog.complete.org/posts/640-Haskell-Fun.html
00:27:32 <dons> haha
00:27:33 <dons> yay!
00:27:38 <ivanm> dons: I guess you're right! :o
00:27:42 <dons> lambdabot is most wise.
00:27:51 <Badger> heheh
00:27:55 <mapreduce> http://ocamljava.x9c.fr/ exists.
00:27:56 <lambdabot> Title: OCaml-Java project - Introduction
00:28:06 <Badger> I just have to know
00:28:10 <Badger> @go asm fun
00:28:11 <mapreduce> Whether it's active, I have no idea.
00:28:14 <dons> oh, a project.
00:28:14 <lambdabot> http://forums.hostrocket.com/archive/index.php/t-13236.html
00:28:14 <lambdabot> Title: x86 asm fun [Archive] - VoIP Forums, Internet Phone Service Forums, & Web Hostin ...
00:28:20 <Badger> \o/
00:28:23 <dons> there's similar ones for haskell (half a dozen of 'em)
00:28:37 <ivanm> @go intercal fun
00:28:37 <dons> salsa, the haskell .net binding, is the only active one, afaik.
00:28:39 <lambdabot> No Result Found.
00:28:54 <ivanm> dons: active == the dev just released it and hasn't got bored with it yet?
00:28:55 <ivanm> ;-)
00:28:58 <dons> ivanm: right.
00:29:03 <wagle> @go fish
00:29:05 <lambdabot> http://en.wikipedia.org/wiki/Fish
00:29:05 <lambdabot> Title: Fish - Wikipedia, the free encyclopedia
00:29:15 <dons> haskell for second life, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/LslPlus
00:29:16 <lambdabot> Title: HackageDB: LslPlus-0.1.1, http://tinyurl.com/6l5ggj
00:29:25 <dons> take that kids. where's your ocaml fun now?
00:29:29 <ivanm> wagle: lol
00:29:33 <wagle> @go to
00:29:35 <lambdabot> http://www.whitehouse.gov/
00:29:35 <lambdabot> Title: Welcome to the White House
00:29:39 <Badger> heh
00:29:45 <dons> weird.
00:29:51 <ivanm> wagle: I guess it _is_ considered harmful...
00:29:57 <wagle> heh
00:30:00 <Badger> but where is the haskell ogre binding? :P
00:30:08 <dons> isn't it on hackage?
00:30:14 <Badger> there is one?!
00:30:18 <ivanm> Badger: it was kicked off the bridge by the eldest billy goat?
00:30:30 * Vq^ can't wait until loops are generally considered harmful
00:30:36 <Badger> ivanm: I think that was a troll.
00:30:39 <dons> not sure actually
00:30:40 <ivanm> oh, yeah
00:30:40 <Badger> :<
00:30:43 <Korollary> Vq^: iirc in python lambda bodies have only one expression. also something wacky about lexical scoping.
00:30:45 <ivanm> Vq^: why?
00:31:08 <mapreduce> Korollary: In Haskell lambda bodies have only one expression.
00:31:15 <mapreduce> Except in Haskell that's not a limitation.
00:31:17 <Vq^> Korollary: yes, i believe you are right
00:31:32 <Korollary> mapreduce: Good for haskell.
00:31:44 <sjanssen> actually, ocaml = haskell + annoying restrictions
00:31:49 <mapreduce> If that's dismissive, consider it returned.
00:31:51 <sjanssen> at least from what I've heard
00:31:55 <Badger> can lambdabot search hackage?
00:32:06 <sjanssen> Badger: not really
00:32:08 <sjanssen> @hackage xmonad
00:32:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xmonad
00:32:13 <Badger> ah
00:32:17 <Badger> @hackage ogre
00:32:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ogre
00:32:20 <Vq^> ivanm: why what?
00:32:21 <Badger> O_O
00:32:22 <sjanssen> Badger: it can drop URLs to packages, but it doesn't verify they're real
00:32:25 <Badger> you're kidding me
00:32:26 <sjanssen> @hackage notrealatall
00:32:27 <Badger> oh
00:32:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/notrealatall
00:32:30 <Badger> sjanssen: hahah
00:32:33 <Badger> :(
00:32:35 <Badger> damn.
00:32:51 <ivanm> Vq^: why do you want loops to be considered harmful?
00:33:02 <sjanssen> hmm, does F# have the value restriction?
00:33:10 <Saizan> ivanm: recursion ftw
00:33:16 <Vq^> ivanm: well, in a similar manner that goto is
00:33:20 <wagle> everyone should be on the straight and narrow
00:33:24 <ivanm> oh, you mean explicit loops rather than implicit ones?
00:33:25 <Vq^> ivanm: goto also has it's place
00:33:44 <dons> i'm listening to an internet radio, and an advert. to join the CIA comes on. that's weird.
00:33:48 <Vq^> ivanm: i guess you could say it that way
00:33:49 <mapreduce> Vq^: The real problem with explicit loops is that they depend on side effects.
00:34:11 <ivanm> mapreduce: do they depend on side effects or lead to side effects?
00:34:17 <mapreduce> I expect you don't actually have a problem with the idea of running the same code twice.
00:34:20 <mapreduce> ivanm: Depend on.
00:34:21 <Korollary> dons: In this economic downturn?
00:34:22 <ivanm> after all, you can simulate simple for-loops using a map
00:34:25 <opqdonut> yeah
00:34:32 <dons> Korollary: i should listen to the normal radio, you're right.
00:34:36 <mapreduce> ivanm: That's why I said 'explicit'.
00:34:49 <ivanm> hmmm...
00:34:50 <Vq^> ivanm: depends on the "for-loop"
00:34:54 <mapreduce> for (;;); is a loop with no side effects, but it has no use.
00:34:56 <dons> ?src map
00:34:56 <lambdabot> map _ []     = []
00:34:56 <lambdabot> map f (x:xs) = f x : map f xs
00:34:56 <ivanm> Vq^: *nod*
00:35:02 <ivanm> mapreduce: infinite loop?
00:35:06 <dons> loops don't have side effects. loop bodies do.
00:35:07 <mapreduce> Yes.
00:35:16 <ivanm> dons: which is what I was trying to get at
00:35:16 <Vq^> in Haskell we don't use mapM for everything
00:35:22 <wagle> Vq^, how about the comefrom statement?
00:35:26 <ivanm> though I was saying s/do/can lead to/
00:35:27 <mapreduce> Do explicit loops have any use other than with side effects?
00:35:28 <Axman6> dons: does the i++ in a for loop not count?
00:35:31 <Vq^> wagle: thats good stuff :)
00:35:33 <dons> mapreduce: 1?
00:35:37 <ivanm> mapreduce: yes, for languages that don't support map ;-)
00:35:41 <Vq^> wagle: it gives threading a nice API as well ;)
00:35:48 <dons> mapreduce: recursion is kinda useful...
00:35:52 <Korollary> Axman6: That's part of the body in a sense.
00:36:08 <mapreduce> ivanm: Ok, show me a loop with no side effects that is useful.  And not looping-via-recursion.
00:36:21 <Korollary> I suppose you can have side effects in the condition check, too.
00:36:23 <sjanssen> from wikipedia: A loop is a sequence of statements which is specified once but which may be carried out several times in succession.
00:36:24 <ivanm> mapreduce: implementing map in an imperative language
00:36:36 <mapreduce> ivanm: You would implement it using side effects.
00:36:42 <sjanssen> "statement" seems side-effecting to me
00:36:49 <sjanssen> also, "sequence"
00:36:53 <Korollary> while (++a < --b) { c++; }
00:36:54 <ivanm> mapreduce: hmmmm..... technically, I suppose you would
00:37:02 <mapreduce> Also, if you use a normal loop for that you lose laziness.
00:37:06 <ivanm> but you can do so without really changing global state
00:37:18 <ivanm> mapreduce: most languages aren't lazy ;-)
00:37:25 <dons> sjanssen: isn't that interesting. so not talking about control alone.
00:37:32 <mapreduce> ivanm: That doesn't stop libraries from emulating/supporting laziness.
00:37:38 <ivanm> true
00:37:40 <dons> sjanssen: and it implies the body is a sequence
00:37:42 <dons> so that's wrong.
00:37:49 <ivanm> despite this interesting discussion, I've got to head off
00:37:50 <ivanm> cya
00:38:02 <mapreduce> E.g., C#: new[]{1,2,3}.Select(x => x/0) does not throw any exception, until you 'force' one of the elements of the returned IEnumerable<int>.
00:38:27 <Korollary> dons: why is the body not a sequence?
00:38:29 <dons> a loop is control structure that allows a computation to be specified once, but executed multiple times
00:38:32 <dons> or something like that?
00:38:47 <dons> Korollary: who says the body is a "sequence of statements"
00:38:59 <sjanssen> dons: Wikipedia says :)
00:39:05 <dons> [citation needed]
00:39:09 <sjanssen> heh
00:39:13 <Korollary> If you're executing it multiple times, you're sequencing each execution.
00:39:44 <dons> its using sequence/successor twice though. the "sequence of statements" is specified once (i.e. the body)
00:39:52 <sjanssen> "execute" is inherently a stateful word, IMO
00:39:53 <dons> and then "carried out" (i.e. executed) multiple times
00:40:02 <dons> evaluated?
00:40:17 <dons> is parMap a loop?
00:40:30 <sjanssen> dons: I think the word "loop" is more about execution that evaluation
00:40:32 <Korollary> I don't think the concept applies in FP.
00:40:43 <dons> i'm wondering if map is a loop, but parMap isn't a loop
00:40:44 <sjanssen> or, about operational semantics rather than denotational
00:40:55 <dons> Korollary: but we have recursion, so we have loops.
00:41:00 <sjanssen> I don't think map is strictly a loop
00:41:03 <vininim> > parMap (+1) [1..]
00:41:04 <lambdabot>   Couldn't match expected type `a -> ()' against inferred type `[a1]'
00:41:04 <earthy> errr...
00:41:27 <mapreduce> Why is map not a loop?
00:41:29 <earthy> we have continuations, so we have loops. that I would by.
00:41:30 <earthy> buy
00:41:37 <dons> hehe
00:41:41 <sjanssen> dons: not necessarily, we have recursion therefore we can express anything a loop can express
00:41:42 <vininim> > parLiftM parMap (+1) [1..] -- lol
00:41:43 <lambdabot>   Not in scope: `parLiftM'
00:41:54 <dons> :t parMap
00:41:55 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
00:42:01 <Korollary> Recursion + minimalization is computationally equivalent to loops I guess.
00:42:02 <dons> > parMap rnf (+1) [1..10]
00:42:03 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
00:42:37 <dons> i wonder if lambdabot is running with +RTS -N2
00:42:53 <mapreduce> The above C# method, Select, is probably implemented like this: foreach (var e in self) yield return f(e); - it's a loop in C# but gets translated to an external iterator.  Thus I think it's quite valid to count a lazy map in Haskell as a loop.
00:42:54 <sjanssen> from Webster: a series of instructions (as for a computer) that is repeated until a terminating condition is reached
00:42:59 <vininim> > parMap wnf (+1) [x,y,z]
00:43:00 <lambdabot>   Not in scope: `wnf'
00:43:08 <vininim> > parMap rnf (+1) [x,y,z]
00:43:09 <lambdabot>       No instance for (NFData Expr)
00:43:09 <lambdabot>        arising from a use of `rnf' at <in...
00:43:25 <dons> sjanssen: so its an imperative concept.
00:43:27 <Korollary> What is a loop in logic programming?
00:43:32 <sjanssen> dons: yes, I think so
00:43:38 <vininim> > parMap rnf f [x,y,z]
00:43:40 <lambdabot>   Add a type signature
00:44:03 <vininim> > parMap rnf f [x,y,z] (::Expr)
00:44:04 <lambdabot>   <no location info>: parse error on input `::'
00:44:06 <dons> while we have the "specification of code once" but applied to mulitple inputs (sequentially or in parallel)
00:44:11 * vininim --
00:44:39 <dons> maybe haskell really doesn't have loops, like they kids say.
00:44:53 <mm_freak> @index fix
00:44:54 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
00:45:07 <sjanssen> dons: even "sequentially or in parallel" is in question in Haskell '98
00:45:18 <wagle> it has the tail recursion optimization, hence it has loops
00:45:27 <sjanssen> we have expressions, that's it :)
00:45:35 <dons> sjanssen: yeah, it says nothing about how we execute it.
00:45:44 <vininim> > parMap rnf f [x,y,z] :: Expr
00:45:45 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[b]'
00:45:52 <vininim> > parMap rnf f [x,y,z] :: [Expr]
00:45:53 <lambdabot>       No instance for (NFData Expr)
00:45:53 <lambdabot>        arising from a use of `rnf' at <in...
00:46:00 <dons> interesting idea, vininim
00:46:31 <sjanssen> dons: I suppose an IO function that calls itself could be called a loop
00:46:51 <wagle> @ty while
00:46:52 <lambdabot> Not in scope: `while'
00:47:12 <wagle> i forget my lambdabotisms
00:47:39 <Saizan> @type forM_
00:47:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
00:48:36 <wagle> you start with an initial value, pattern match it, do a test, if it passes, run the expression, and use its value as the next initial value
00:48:57 <mm_freak> > fix (\l v -> fix (\k p x -> case x of 0 -> p : l (v+1); _ -> k (p*x) (x-1)) 1 v) 0
00:48:58 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
00:49:03 <wagle> no side effects necessary
00:49:23 <wagle> its a loop because it doesn't consume stack frames
00:49:35 <wagle> because its tail recursive
00:49:49 <sjanssen> wagle: that is a wrong definition, IMO
00:49:59 <vininim> if you think in terms of implementation it ends up having side effects
00:50:00 <wagle> ok..  why?
00:50:11 <Saizan> wagle: except that in haskell there's no thing as "run the expression", you're maybe talking about the implementation of how that expression is evaluated
00:50:18 <sjanssen> wagle: because the stack is largely artificial
00:50:41 <vininim> s/it ends up/everything ends up with/
00:50:45 <sjanssen> wagle: when a loop body allocates memory on each execution, is it still called a loop?
00:51:03 <dmwit> No!
00:51:13 <mmorrow> @tell dolio i lost my internet just then. state.hs wasn't added to the darcs repo because it "differed only by case", so i had to --case-ok that thing.
00:51:13 <lambdabot> Consider it noted.
00:51:32 <wagle> i think there is a difference between the program doing it and its interpreter doing it
00:51:33 <sjanssen> dmwit: really?  I've never seen a definition of loop that says so
00:51:42 <sjanssen> wagle: there isn't a difference
00:51:50 <dmwit> i = 4096; while(i --> 0) malloc(i); /* soooo not a loop */
00:52:02 <Korollary> Tail recursion optimization is just a feature necessary to allow people to write recursive code instead of implementing tail recursion optimization by hand via a loop.
00:52:04 * wagle inserts raspberries here
00:52:05 <mm_freak> @pl \l v -> fix (\k p x -> if x == 0 then p : l (v+1) else k (p*x) (x-1)) 1 v
00:52:09 <lambdabot> join . flip flip 1 . (fix .) . flip flip (flip flip (subtract 1) . (ap .) . (. (*)) . (.)) . (((.) . ap . ((ap . flip (if' . (0 ==))) .) . flip (:)) .) . (. (1 +))
00:52:09 <lambdabot> optimization suspended, use @pl-resume to continue.
00:52:12 <sjanssen> all recursive functions can be written with a stack data structure, all loops can be written with recursion
00:52:16 <mm_freak> uhh
00:52:50 <wagle> (with another hat on, i'd agree with you, by the way)
00:53:25 <dmwit> mm_freak: Now ?unpl that, then ?pl the output, then ?unpl that, and ?pl the result...
00:53:35 <mmorrow> @pl-resume
00:53:35 <lambdabot> join . flip flip 1 . (fix .) . flip flip (flip flip (subtract 1) . (ap .) . (. (*)) . (.)) . (((.) . ap . ((ap . flip (if' . (0 ==))) .) . flip (:)) .) . (. (1 +))
00:53:47 <mmorrow> nice, it finished
00:54:00 <mmorrow> @pl-resume
00:54:00 <lambdabot> pointless: sorry, nothing to resume.
00:54:01 <mm_freak> @unpl join . flip flip 1 . (fix .) . flip flip (flip flip (subtract 1) . (ap .) . (. (*)) . (.)) . (((.) . ap . ((ap . flip (if' . (0 ==))) .) . flip (:)) .) . (. (1 +))
00:54:01 <lambdabot> (\ ao -> (\ f -> fix (\ aa -> (\ di cp -> (\ ad -> if' (0 == ad) ((:) di (ao (1 + f)))) >>= \ cm -> cp >>= \ cl -> return (cm cl)) >>= \ ca -> (\ s -> (\ x -> aa (s * x)) >>= \ bi -> (subtract 1) >>=
00:54:01 <lambdabot>  \ bh -> return (bi bh)) >>= \ bz -> return (ca bz)) 1) >>= \ aq -> aq)
00:54:08 <mm_freak> lol
00:54:09 <opqdonut> :D
00:54:13 <Axman6> wow
00:54:20 <wagle> if the interpreter's use of memory is the same as the program's, then I can write a fortran interpreter then consumes a stack frame for each iteration of a do loop..  thus proving that there is no such thing as a loop
00:54:22 <dmwit> It's just getting more and more readable.
00:54:28 <vininim> my eyes
00:54:30 <mmorrow> someone needs to write an @ununpl that zaps all that reader monad nonsense from @unpl :)
00:54:32 <mm_freak> @unpl (^2) . sin
00:54:32 <lambdabot> (\ d -> (sin d) ^ 2)
00:54:46 <wagle> save the points!
00:54:50 <mm_freak> @unpl compare `on` fst
00:54:50 <lambdabot> (on compare fst)
00:54:52 <mmorrow> the @pl . @unpl . @pl would have a chance at neing id
00:54:57 <mmorrow> s/the/then/
00:55:03 <mmorrow> *being
00:55:15 <Saizan> mmorrow: as if pl was typed!
00:55:20 <mmorrow> haha
00:55:34 <mm_freak> if lambdabot were smart, it would just save the result =)
00:55:37 <dmwit> Saizan: I don't know what you're talking about, I type it all the time. ;-)
00:55:54 <sjanssen> wagle: I think you've demonstrated why the "stack frame" definition is problematic
00:56:36 <wagle> i did precondition my initial statement with "if x has the tail recursion optimization"...
00:57:23 <mm_freak> :t flip 1
00:57:25 <lambdabot> forall a b c. (Num (a -> b -> c)) => b -> a -> c
00:57:38 <mm_freak> > flip 1 + flip 2
00:57:39 <lambdabot>       No instance for (Num (b -> a -> c))
00:57:39 <lambdabot>        arising from a use of `+' at...
00:57:51 <mm_freak> > flip 1 2 3
00:57:52 <lambdabot>       No instance for (Num (a -> b -> c))
00:57:52 <lambdabot>        arising from the literal `1'...
00:58:19 <Axman6> > flip (-) 1 2
00:58:20 <lambdabot>   1
00:58:31 <mm_freak> forall a b c. (Num (a -> b -> c)) ?!
00:58:34 <Axman6> omg, magic!
00:58:34 <mm_freak> how can that happen?
00:58:43 <mmorrow> @let while p f x = if p x then while p f (f x) else x
00:58:44 <lambdabot>  Defined.
00:58:59 <wagle> sjanssen, i think it has to do with "the possibility of writing a loop that doesn't have a memory leak"..  8)
01:01:16 <mmorrow> @let for i p inc f x = let y = f i x ; i' = inc i in if p i then for i' p inc f y else y in for
01:01:16 <lambdabot>   Parse error
01:01:21 <mmorrow> @let for i p inc f x = let y = f i x ; i' = inc i in if p i then for i' p inc f y else y
01:01:22 <lambdabot>  Defined.
01:01:26 <mmorrow> yuk
01:02:35 <mm_freak> i used to use 'while' a lot, before i realized i don't really need it…  in almost all cases, i get along with just 'forever'
01:02:47 <mmorrow> > for 0 (<10) (+1) 42 (+)
01:02:48 <lambdabot>       Overlapping instances for Show (a -> a -> a)
01:02:48 <lambdabot>        arising from a use ...
01:02:56 <wagle> if a process migrates to another machine, is it the same process?
01:02:57 <mmorrow> > for 0 (<10) (+1) (+) 42
01:02:58 <lambdabot>   97
01:03:27 <mm_freak> while :: Monad m => (a -> Bool) -> a -> (a -> m a) -> m a
01:03:48 <mmorrow> > while (<1024) (*2) 3
01:03:49 <dmwit> wagle: very zen
01:03:49 <lambdabot>   1536
01:04:18 <mmorrow> very that would be sweet if we could do that with haskell
01:04:37 <dmwit> very agreed
01:05:00 <wagle> dmwit, just wondering if any processes running right now will continue running until the end of time
01:05:19 <wagle> plus, yeah, the zen thing...
01:05:23 <mmorrow> i'll bet you $1 there are
01:05:26 <dmwit> There might be an init somewhere running on a very stable *nix...
01:06:34 <dmwit> mmorrow: On the one hand, if you lose, you have to pay $1, but on the other hand, if you win, that means you lived to see THE END OF TIME.
01:06:41 <dmwit> That is one cheap life extension right there.
01:06:54 <mm_freak> the program "1" would run for a very long time, if written on a piece of paper and saved in a solid safe
01:06:59 <wagle> i had a notebook running linux sitting on top of a shelf..  jiffies wrapped every 459 days..  it was about to wrap for the second time when some professor snarfed it
01:07:03 <sjanssen> mmorrow: I'll take that bet
01:07:04 <dmwit> Either that or you just brought the end of time about a billion years closer for the sake of a dollar.
01:07:05 <mmorrow> i'm banking on it being impossible to pay once time has ended. i figure i can't lose ;)
01:07:11 <mmorrow> sjanssen: done.
01:07:32 <sjanssen> mmorrow: my side is actually the better one
01:07:43 <mmorrow> crap, by that same logic i can't win either
01:07:55 <mmorrow> sjanssen: we'll seeee abou that
01:08:00 <sjanssen> it is actually possible for you to lose, but it'd be very hard to prove
01:08:08 <dmwit> sjanssen actually has a chance to win $1
01:08:11 <Saizan> dmwit: i bet he plans of becoming immortal by copying his mind to other bodies
01:08:21 * mmorrow curses
01:08:23 <dmwit> Saizan: But will that really be mmorrow?
01:08:37 <Deewiant> is there a standardish name for \f g x y -> f x (g y) ?
01:08:40 <mmorrow> there is no mmorrow, don't you see!
01:08:42 <Saizan> dmwit: of it keeps the same PID
01:08:43 <sjanssen> if a soul moves to another body, is it the same soul?
01:08:44 <wagle> is there an economic system running todfay that will last until the end of time?
01:08:49 <wagle> sigh..
01:08:50 <Saizan> "only"
01:08:55 <opqdonut> Deewiant: that's almost the S combinator
01:08:59 <mm_freak> main :: WorldState -> WorldState
01:09:01 * Saizan fails
01:09:06 <wagle> evidently, its time for me to go to bed
01:09:21 <Deewiant> opqdonut: I know, but it's not.
01:09:24 <opqdonut> :)
01:09:29 <dmwit> ?pl \f g x y -> f x (g y)
01:09:29 <lambdabot> flip . ((.) .)
01:09:31 <sjanssen> wagle: depends on when time ends, I suppose
01:09:33 <Deewiant> and it's not easily expressed in terms of it either. :-P
01:09:40 <Deewiant> I like writing it as
01:09:54 <Deewiant> ?ty (>>>) >>> (>>>) (>>>) :: (a -> b -> c) -> (d -> b) -> a -> d -> c
01:09:55 <lambdabot> forall a b c d. (a -> b -> c) -> (d -> b) -> a -> d -> c
01:09:58 <opqdonut> heh
01:10:01 <mm_freak> main = timeMachine where timeMachine s = getChar s `seq` getChar s `seq` s
01:10:09 <dmwit> :t ((.) . (.)) -- Deewiant, this seems related
01:10:10 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:10:27 <Deewiant> yes, that's related and often called (.:)
01:10:35 <Deewiant> so I'm wondering if this has a similar appellation
01:10:48 <wagle> :t (.:)
01:10:49 <lambdabot> Not in scope: `.:'
01:10:52 <dmwit> I don't think so.
01:11:13 <wagle> :t (.: )
01:11:14 <lambdabot> Not in scope: `.:'
01:11:22 <wagle> :t (. :)
01:11:22 <lambdabot> parse error on input `:'
01:11:46 <Deewiant> wagle: it's not in any lib I know of.
01:11:49 <osfameron> which is also the boobies operator iirc?
01:11:52 <Deewiant> (.:) = (.).(.)
01:11:57 <Deewiant> yep
01:11:58 <dmwit> osfameron: boobies or owl
01:12:13 <dmwit> XChat needs more colors to differentiate nicks with.
01:18:01 <mm_freak> @src fix
01:18:02 <lambdabot> fix f = let x = f x in x
01:18:17 * mmorrow just found out he's neon green in xchat and was surprised
01:19:07 <mmorrow> the xchat on my laptop grays /me's, but the one i'm using now colors them
01:19:12 <mapreduce> I can differentiate between nicks by looking at the characters in them.
01:19:37 <mmorrow> mapreduce: i used to irc in a console. then i used xchat once and was hooked
01:20:21 <mapreduce> mmorrow: I irc from emacs, sometimes in a console, sometimes in an X window.
01:20:23 <Axman6> heh, i went the other way. used to use X-chat, now i'm hooked on irssi :)
01:20:40 <mmorrow> i've wondered how it chooses colors for names. my guess is it uses some algo based on the chars therein
01:20:54 <mapreduce> Yeah, I used to use XChat; even got a patch into it.  Then got annoyed when they started charging for Windows builds.
01:21:04 <mmorrow> like maybe hashes the string and indexes into a color table
01:21:21 <mmorrow> mapreduce: gasp, windows!
01:21:29 <mmorrow> :)
01:22:02 <mmorrow> i used to use ircii exclusively
01:22:07 * mmorrow becomes nostalgic
01:22:26 <mapreduce> mmorrow: Windows is an inescapable hardship sometimes.
01:22:41 <Axman6> we have never owned a windows PC
01:22:54 <Savant> Axman6: You're missing out on a lot
01:23:10 <Axman6> i'm really not, i've used windows enough to know that ;)
01:23:41 <mapreduce> Taking a Linux boot disk in case you want to IRC from a friend's computer might be overkill.
01:23:46 <Savant> Axman6: Don't you like the ASLR randomization and DEP protection?
01:23:50 <chylli> is there a command 'make test' to run scripts one by one ?
01:23:59 <Axman6> > fix (+1) :: Expr
01:24:10 <mmorrow> chylli: ?
01:24:13 <Axman6> Savant: wtf is that?
01:24:23 <mmorrow> what scripts?
01:24:27 <lambdabot>   thread killed
01:24:28 <Axman6> > fix (1+) :: Expr
01:24:41 <chylli> mmorrow: like QuickTest
01:24:45 <mmorrow> ah
01:24:49 <lambdabot>   thread killed
01:24:52 <Axman6> sounds like what OpenBSD has had for a long time
01:24:59 <chylli> mmorrow: sorry, QuickCheck
01:25:19 <mm_freak> > fix (\k x -> x : k (x+1)) 0
01:25:20 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
01:25:29 <mm_freak> @pl fix (\k x -> x : k (x+1)) 0
01:25:29 <lambdabot> fix (ap (:) . (. (1 +))) 0
01:25:58 <mmorrow> chylli: i'm not sure about exactly that, but here's a quickcheck-related thing that may give you some ideas: http://code.haskell.org/~dons/code/pqc/
01:25:58 <lambdabot> Title: Index of /~dons/code/pqc
01:26:16 <chylli> mmorrow: thanks
01:26:17 <Axman6> Savant: so, what's ASLR and DEP?
01:26:21 <Savant> Axman6: I never liked obsd.
01:26:31 <Axman6> your loss :)
01:26:34 * mmorrow has never used that, but comes across it now and again and every time says "i should look at that"
01:26:36 <Axman6> nothing beats it as a router
01:26:38 <Savant> Axman6: Not really.
01:26:56 <Savant> DEP == data execution prevention.
01:26:58 <Axman6> except... maybe itself. mine killed itself (my fault for using something with a 1GB disk)
01:27:17 <Savant> ASLR == Address space layout randomization.
01:27:22 <Axman6> yeah... OpenBSd has had that for many years
01:27:36 <Axman6> and probably the linux kernel, and many others
01:27:45 <mmorrow> Savant: i just made my stack, heap, mem, mod all executable via SELinux the other day. to infinity and beyond!
01:27:56 <opqdonut> _:D
01:27:58 <p_l> Add TOMOYO to that too
01:28:02 <Savant> Axman6: Have you ever seen http://wideopenbsd.org
01:28:34 <Axman6> ha what are you, like 13?
01:28:41 <mmorrow> i mean, how else are you supposed to execute a [Word8] from haskell ;)
01:28:45 <p_l> SELinux has way too many implementation problems IMHO
01:29:16 <chylli> mmorrow: ok, I read that. but I want to know how to run it by a simple command like 'make test' in perl instead of run 'runghc -- -isrc test/test.hs'
01:29:36 <chylli> mmorrow: maybe there are lots of testxx.hs
01:29:44 <Axman6> haha, what a pathetic site
01:29:46 <mmorrow> chylli: i bet it'd be easy enough to code such a thing up
01:30:35 <mmorrow> chylli: also, cabal has support for hooking some test to-be-run into the build process fwiw
01:30:38 <Axman6> Savant: i i think i'll take someone like IBM's word on OpenBSD instead of some 15 year old who has no clue what they're on about :)
01:30:45 <chylli> mmorrow: yeah, maybe. but is there an automated tools like 'make test' ?
01:30:53 <chylli> mmorrow: ok . let me read cabal again
01:31:00 <chylli> mmorrow: thanks for your help
01:31:11 <mmorrow> chylli: i think people usually just roll their own
01:31:17 <Savant> Axman6: 15 year old?
01:31:31 <Axman6> that's how it reads
01:31:37 <mmorrow> chylli: check out the mueval darcs repo for an example of a cabal setup that has a hooked-in test script
01:31:49 <mmorrow> (or the hackage tarball)
01:33:24 <Savant> Axman6: Ah
01:33:59 <mmorrow> p_1: judging by the very small amount that i know about SELinux, it looks like it'd be hellish to have to work with regularly
01:34:29 <BeelsebobWork> Savant: that site obviously has no clue about security
01:35:03 <Savant> Beelsebob: It's pretty funny.
01:35:03 <BeelsebobWork> I mean come on -- saying local vulnerabilities are serious problems is just stupid -- I can just take the hard disk out and run with it if I have access to the machine
01:35:23 <Savant> You're pretty funny too.
01:35:45 <dons> mmorrow: nah, its not so bad. the policies can be interesting though.
01:37:19 <dmwit> BeelsebobWork: won't matter much for a properly encrypted drive
01:38:05 <dmwit> BeelsebobWork: But I agree that physical access opens up a whole slew of more terrifying attacks.
01:38:08 <BeelsebobWork> dmwit: no encryption can stand up to brute force cracking for long enough
01:38:18 <BeelsebobWork> and if I run with the disk, hey, I have 6 months to do it in
01:39:06 <solrize> local vulnerability = attacker is logged into the machine before they launch the exploit, not that they have physical access to the hardware
01:41:29 <mmorrow> this rooted my box when i first saw it a few months ago http://www.milw0rm.com/exploits/5092
01:41:34 <lambdabot> Title: Linux Kernel 2.6.17 - 2.6.24.1 vmsplice Local Root Exploit
01:41:51 <BeelsebobWork> from my reading of their site, that's not what they're referring to solrize, but I might be reading it wrong
01:42:17 <Axman6> in that case, i don't see how OpenBSD would be any les secure than pretty much any unix like system, since they all use OpenSSH
01:43:13 <BeelsebobWork> in fact, their complaint against OpenSSH is "oh my god, they duplicated a pre-existing bug in ssh when they forked it"
01:43:20 <BeelsebobWork> big surprised
01:43:21 <BeelsebobWork> it's a fork
01:43:26 <BeelsebobWork> when you fork code, you duplicate the bugs
01:43:58 <mmorrow> dons: interesting. maybe i'll give it a second look
01:48:49 <hugo__> i have this offer that is really great and pays really well, with lots of benefits...
01:48:51 <hugo__> but its java
01:48:53 <hugo__> :/
01:49:59 <mmorrow> hugo__: you only live once
01:50:01 <Axman6> could be worse
01:53:57 <hugo__> mmorrow: so i guess ill continue here coding haskell :P
01:54:34 <hugo__> trying to learn and make sense of it, in the hope that in the future it might be useful
02:13:48 <Taejo> is it possible to parse C-style array-indexing (like a[i]) with a Parsec expression parser?
02:16:37 <quicksilver> Taejo: what does expression parser mean? sounds like a precise meaning I'm not aware of
02:16:44 <quicksilver> you can certainly parse a[i] with parsec
02:17:18 <Taejo> quicksilver: by expression parser, I mean something built by Parsec's buildExpressionParser
02:17:23 <Taejo> buildExpressionParser  :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
02:17:59 * quicksilver checks
02:18:21 <quicksilver> Taejo: no.
02:18:36 <quicksilver> Taejo: the slightly strangely named 'buildExpressionParser' is all about binary operators.
02:18:57 <quicksilver> oh, hang on.
02:19:00 <quicksilver> it has prefix and postfix
02:19:10 <Taejo> I guess I could use the old trick of replacing "[" with "[(" and "]" with ")" and making "[" an infix operator
02:19:19 <quicksilver> I don't think so, no
02:19:27 <quicksilver> I think you make all of "[i]" a postfix operator
02:19:42 <Taejo> hmm, that might work
02:19:49 <quicksilver> your operator can be an abitrarily complex thing
02:19:52 <quicksilver> (it's just a parser)
02:20:04 <quicksilver> you can make [i] and (i) both postfix operators if you like.
02:20:30 <quicksilver> precedence between different meanings of () can be hard, I think. But [] should be OK because that's all it means.
02:20:50 <quicksilver> [ expr ] can be a postfix operator with higher precedence than any infix.
02:21:04 <quicksilver> except "." and "->", I think.
02:21:16 * quicksilver hasn't had occasion to think this hard about parsing C for a while ;)
02:21:36 <quicksilver> "a.b[2]" is "(a.b)[2]" though.
02:21:36 <hugo__> :D
02:21:46 <Taejo> quicksilver: worse than C, it's a hack-job custom scripting language
02:21:50 * quicksilver nods
02:21:57 <Taejo> full of perlisms and bashisms
02:22:00 <quicksilver> yay!
02:22:15 * quicksilver is a fan of lua, if you want a simple C-like language
02:23:17 <hugo__> :)
02:23:17 <Taejo> I'm translating it to Python (the maintainer has seen sense and switched from his custom scripting engine to exporting a Python module)
02:23:44 <hugo__> i would be really interested in seeing the lua VM rewritten in haskell, or any other vm for that matter
02:24:04 <hugo__> not sure how the implications of being lazy would inovate in that realm
02:25:57 <quicksilver> do you think there would be large benefits?
02:26:11 <quicksilver> the lua VM is (relatively) small, rather cleanly written, and seems to perform well.
02:26:22 <Taejo> the scripting language has this wonderful feature where strings are callable
02:26:24 <quicksilver> I'm not sure porting it to another language would serve a great purpose.
02:26:36 <quicksilver> although it's obviously an interesting exercise.
02:26:38 <hugo__> i dont know... i really find it difficult that in the 21st century those VM's are mainly stack based with no optimizations
02:26:41 <hugo__> well lua is not stack based
02:26:48 <hugo__> that already means something
02:27:27 <hugo__> python is... and it sucks, it doesn't optimize even the most basic static expressions, like 1+0 ... :/
02:31:05 <hugo__> http://www.youtube.com/watch?v=OKFeLZqLxzQ
02:31:05 <lambdabot> Title: YouTube - Compiling Dynamic Languages
02:31:20 <hugo__> this is for ocaml, but the idea is nice, i guess...
02:36:18 <hugo__> i also enjoy the PyPy talk... its a very nice project, also with lazyness, and all that mambo jambo
02:36:23 <mikv> Hi
02:36:25 <mikv> again
02:36:33 <hugo__> hi mikv
02:36:36 <mikv> I am curious is there predefined fnction that will do
02:36:41 <mikv> following thing
02:36:48 <mikv> I have a list
02:36:59 <mikv> i would like to split this list into 2 lists
02:37:10 <Taejo> @hoogle [a] -> ([a], [a])
02:37:11 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
02:37:11 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
02:37:11 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
02:37:17 <mikv> this function should split it until it finds certain value
02:37:20 <mikv> hmm///
02:37:25 <vegai> language VM is like a kernel. Everyone thinks it should be as tiny as possible, but all the actually used ones are huge
02:37:26 <mikv> hm.. Wow
02:37:59 <mikv> > break (\=Nothing) [Just 'a', Nothing, Just 'b']
02:38:00 <lambdabot>   Not in scope: `\='
02:38:09 <Taejo> mikv: /=
02:38:17 <mikv> > break (/=Nothing) [Just 'a', Nothing, Just 'b']
02:38:18 <lambdabot>   ([],[Just 'a',Nothing,Just 'b'])
02:39:13 <Taejo> > span (/=Nothing) [Just 'a', Nothing, Just 'b']
02:39:14 <mikv> > break ( \x -> x /=Nothing) [Just 'a', Nothing, Just 'b']
02:39:15 <lambdabot>   ([Just 'a'],[Nothing,Just 'b'])
02:39:15 <lambdabot>   ([],[Just 'a',Nothing,Just 'b'])
02:39:20 <Taejo> oops
02:39:27 <Taejo> mikv: I think you want span here
02:39:36 <Taejo> break p == span (not . p)
02:39:46 <mikv> Btwm where can i find list of functions with description?
02:40:00 <mikv> I mean documentation for standart library
02:40:19 <Taejo> mikv: if you search hoogle on the web, you get links to the docs
02:40:21 <Axman6> @src span
02:40:21 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:40:25 <Axman6> @src break
02:40:25 <lambdabot> break p =  span (not . p)
02:40:32 <Axman6> -_-
02:40:40 <Taejo> mikv: http://www.haskell.org/hoogle/
02:40:41 <lambdabot> Title: Hoogle
02:40:57 <Axman6> almost as bad a the definition of == and /=
02:41:05 <Taejo> @src ==
02:41:06 <lambdabot> x == y = not (x /= y)
02:41:09 <Taejo> @src /=
02:41:09 <lambdabot> x /= y = not (x == y)
02:41:12 <Taejo> haha
02:41:18 <Axman6> :)
02:41:21 <mikv> how is that possible????
02:41:22 <hugo__> :D
02:41:35 <Taejo> mikv: you have to override at least one
02:41:36 <mikv> aaaa
02:41:41 <Axman6> mikv: you define one for your type, and the other one is then also definied
02:41:43 <mikv> i guess we will override only one
02:41:48 <mikv> :-)
02:41:51 <Axman6> @src [] (==)
02:41:52 <lambdabot> []     == []     = True
02:41:52 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
02:41:52 <lambdabot> _      == _        = False
02:42:21 <Taejo> why the _ == _ case?
02:42:28 <Taejo> isn't it covered by the other two?
02:42:32 <Taejo> oh, nvm
02:42:34 <Axman6> no
02:42:35 <Taejo> it isn't
02:42:43 <Axman6> (x:xs) == [] isn't
02:42:47 <Taejo> yeah
02:43:09 <Axman6> @src Eq
02:43:09 <lambdabot> class  Eq a  where
02:43:09 <lambdabot>     (==), (/=)   :: a -> a -> Bool
02:43:51 <Taejo> if I want \bot in GHCi, can I just do "cabal install lambdabot"?
02:44:10 <Axman6> i think you need to do a bit more work than that
02:45:42 <mapreduce> where bit = lot
02:45:59 <mikv> @src span
02:45:59 <lambdabot> Source not found. :(
02:45:59 <Taejo> mapreduce: ok, I'll just keep using the one here then
02:46:04 <mikv> @src break
02:46:05 <lambdabot> break p =  span (not . p)
02:46:35 <mikv> Moving on
02:46:56 <mikv> Is there function that will split list into 2 lists
02:47:10 <mikv> but i need to check not only current element
02:47:12 <mapreduce> :t partition
02:47:12 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:47:14 <Axman6> both span and break will
02:47:14 <mikv> i need to accumulate
02:47:33 <Axman6> @src partition
02:47:33 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
02:47:33 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
02:47:33 <lambdabot>                               | otherwise = (ts, x:fs)
02:48:12 <mapreduce> > partition (\x -> x `mod` 2 == 0) [1..10]
02:48:13 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
02:48:31 <mapreduce> Probably not what you want.
02:48:34 <mikv> nope
02:49:00 <mikv> I am trying to decode Huffman code
02:49:21 <Axman6> give an example of input and output
02:49:24 <mikv> so i need to check if first n elements of list are correct symbol in Huffman code
02:49:28 <mikv> e.g.
02:49:48 <mikv> let code = "010110111"
02:49:56 <mikv> let code = "10110111"
02:50:02 <mikv> second is correct
02:50:26 <mikv> c has code "110"
02:50:36 <mikv> d has code "111"
02:50:41 <mikv> b has code "10"
02:50:53 <mikv> we are taking first element
02:51:10 <mikv> "1" and rest of list is "0110111"
02:51:22 <mikv> "1" is not a code for any symbol
02:51:24 <mikv> ok.
02:51:32 <mikv> take another element from second list
02:51:34 <mikv> we have
02:51:43 <mikv> "10" and "110111"
02:51:46 <Axman6> yeah i'm totally confused now
02:51:53 <mikv> "10" is a code for b
02:52:06 <Taejo> mikv: I understand
02:52:08 <Ferdirand> I think you should try another approach
02:52:20 <mikv> I already have a function
02:52:21 <Ferdirand> if your code is stored as a tree
02:52:31 <mikv> that checks if string is a code for single character
02:52:34 <mikv> and returns it
02:52:41 <Ferdirand> you should simultaneously consume the string and an instance of the tree
02:52:55 <Axman6> so you want something that goes from [a] -> [[a]]?
02:52:56 <Ferdirand> then, when you hit a tree leaf, output a symbol, restore the original code tree, and move on
02:52:58 <mikv> *Main> cDecode "111" xx
02:53:02 <mikv> Just 'd'
02:53:09 <mikv> I have this function
02:53:15 <Taejo> mikv: can't you modify that function to return the remaining part of the list too?
02:53:26 <mikv> Taejo, nope :-(
02:53:44 <Taejo> mikv: wanna put your code on hpaste?
02:53:50 <mikv> SURE
02:53:58 <mikv> *sure
02:54:18 <mikv> http://hpaste.org/12027
02:54:20 <Taejo> mikv: sorry, gotta rush out (something's come up) but I'm sure somebody will help you
02:54:25 <Taejo> or I'll look later
02:54:49 <mikv> Taejo, thanks
02:56:06 <Taejo> mikv: just change "cDecode (x:xs) (Leaf a) = Nothing" to "cDecode (x:xs) (Leaf a) = (a, x:xs)"... the other cases should be easy
02:56:13 <Taejo> bbl
02:56:35 <mikv> Taejo, i cannot change it
02:56:42 <Ferdirand> so you should use a helper function
02:56:54 <mikv> Taejo, function should have signature defined in assignment
02:56:57 <Ferdirand> but splicing the code string is not the right approach
02:57:03 <mikv> Ferdirand, it seems so
02:57:32 <mikv> Ferdirand, my task is to build cDecode function with predefined signature
02:57:34 <mikv> cDecode :: [Char] -> HTree -> Maybe Char
02:57:36 <ziman> well, you can create a different function with the similar functionality that returns the tuple
02:57:49 <mikv> after that i should build hCode :: [Char] -> HTree -> Maybe [Char]
02:57:58 <mikv> *hDecode
02:58:03 <ziman> and then write cDecode as a special case (returning the first and discarding the second element of the tuple)
02:59:34 <ziman> like, cGenDecode :: [Char] -> HTree -> (Maybe Char, [Char]); cDecode str tree = fst $ cGenDecode str tree
03:00:21 <mikv> ziman, how cGenDecode will help me to build hDecode?
03:00:28 <mikv> i don't get it yet
03:02:23 <ziman> well, cGenDecode will take a bitstring, give you the first character and the rest of the bitstring. Applying cGenDecode on the rest will give the second character and another rest. And so on.
03:02:49 <mikv> ziman, well,i still don't understand it
03:02:57 <mikv> ziman, anyway, thanks for your help
03:03:46 <ziman> suppose i wanted to add one to each number in a list
03:04:07 <mikv> zima, ok
03:04:13 <mikv> ziman, ok
03:04:17 <ziman> > let addOne [] = []; addOne (x:xs) = (x+1) : addOne xs in addOne [3,4,5]
03:04:18 <lambdabot>   [4,5,6]
03:04:22 <mikv> map (+1) ?
03:04:54 <BeelsebobWork> > map (+1) [3,4,5]
03:04:56 <lambdabot>   [4,5,6]
03:05:16 <ziman> maybe but the message was: if you want to process a list sequentially, just process the first element(s) and call then process the rest
03:05:21 <ziman> s/call//
03:05:31 <mikv> ziman, ok... i understand it
03:05:50 <mikv> ziman, but i still don't get it how can  cGenDecode :: [Char] -> HTree -> (Maybe Char, [Char]) help me
03:06:39 <mikv> well, i can take fisrt element from bistring
03:06:53 <mikv> i can test if it is code
03:07:08 <mikv> if not, i need to take another element from bistring
03:07:14 <ziman> mikv, cGenDecode will do the same: decode the first character (which means biting off multiple elements from the bitstring) and then decode the rest of the string
03:07:58 <ziman> rest of the bitstring.
03:08:04 <mikv> Huh :-)
03:08:13 <mikv> I am faced with my initial problem
03:08:32 <mikv> you just formulated it in other words :-))))))
03:09:32 <ziman> well, that's how recursion works: if you want to screw in a lightbulb, you just turn it once and then screw it in.
03:10:39 <mmorrow> heh, yeah once you've got back to where you started, game over you win
03:10:40 <mikv> @src takeWhile
03:10:40 <lambdabot> takeWhile _ []                 =  []
03:10:40 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
03:10:40 <lambdabot>                    | otherwise =  []
03:10:48 <hackage> Uploaded to hackage: wavesurfer 0.0.3
03:10:48 <hackage> Uploaded to hackage: delimited-text 0.0.3
03:11:43 <quicksilver> ziman: I think you missed a base case ;)
03:12:00 <quicksilver> "How many ziman's does it take to screw in a lightbulb? One, but it takes him forever."
03:12:43 <ziman> :D
03:15:26 <mmorrow> or it takes him a few seconds, at which time he twists the bulb to pieces
03:15:54 <mmorrow> better wear gloves
03:16:02 <ziman> and turn off the electricity
03:16:25 <mmorrow> "no, you can leave it on. i'll be FINE"
03:17:24 <hugo__> being an haskell programmer today, is like being a jazz musician in the 50's, the era of the rock and roll
03:19:02 <mapreduce> Everyone steals your ideas?
03:19:12 <EvilTerran> and gives you no credit?
03:19:26 <Peaker> most Python programmers have no idea where list comprehensions are from
03:19:31 <hugo__> :)
03:19:43 <EvilTerran> a lot of people know it's meant to be really good, but never actually pay any attention to it?
03:20:04 <quicksilver> we only have 5 notes and they have 7?
03:20:10 <mapreduce> Guido invented programming.
03:20:15 <Peaker> Reddit head line: "Crazy Fireworks in Cabal", oops, "in Cuba!" boring
03:20:24 <mikv> Can anybody help me?
03:20:29 <EvilTerran> mapreduce, did he? i thought it was larry wall
03:20:29 <mikv> why http://hpaste.org/12028 doesn't work?
03:20:40 <mapreduce> EvilTerran: No, wall invented the dollar sign.
03:20:43 <EvilTerran> mikv, do you get an error message?
03:21:01 <mikv> EvilTerran, yep
03:21:05 <EvilTerran> ...
03:21:07 <mikv> Occurs check: cannot construct the infinite type: a = [a]
03:21:12 <mikv> When generalising the type(s) for `splitAccHelp'
03:21:13 <hugo__> hmm
03:21:32 <hugo__> someone should invent the yay operator: \o/
03:21:47 <daf> sadly, you can't mix letters and punctuation
03:22:10 <hugo__> oh
03:22:11 <daf> \°/ would work, I think
03:22:14 <daf> or similar
03:22:17 <EvilTerran> splitAccHelp p l (x:xs) | p x = splitAccHelp p (l:x) (xs)
03:22:17 <EvilTerran>               ^^^                              ^^^^^
03:22:22 <EvilTerran> doesn't look right to me
03:22:31 <EvilTerran> if l :: a, (l:x) :: [a]
03:23:08 <mikv> EvilTerran, l is a list
03:23:12 <EvilTerran> yes
03:23:16 <EvilTerran> ?type (:)
03:23:17 <lambdabot> forall a. a -> [a] -> [a]
03:23:18 <mikv> always
03:23:30 <EvilTerran> (:) takes a list _on_the_right_
03:23:35 <EvilTerran> and a single element on the left
03:23:40 <mikv> aaaaa
03:23:45 <EvilTerran> you can tell by the types :)
03:23:48 <mikv> ++
03:23:50 <EvilTerran> > 1 : 2 : 3 : []
03:23:52 <lambdabot>   [1,2,3]
03:23:57 <mikv> ?t (++)
03:23:57 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
03:24:07 <mikv> ?type (++)
03:24:08 <EvilTerran> ?type (++) -- yeah, that might do what you want
03:24:08 <lambdabot> forall a. [a] -> [a] -> [a]
03:24:09 <lambdabot> forall a. [a] -> [a] -> [a]
03:26:02 <yaxu> @seen dons
03:26:02 <lambdabot> dons is in #darcs, #concatenative, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 1h 50m 17s ago.
03:28:56 <ziman> mikv, i'll try a more complex example; i hope i won't confuse you
03:29:23 <Axman6> mikv: just fyi, :t works with lambdabot :)
03:29:26 <Axman6> :t (++)
03:29:27 <lambdabot> forall a. [a] -> [a] -> [a]
03:30:12 <ziman> suppose we have a list of numbers and we want to split it in smallest continuous parts that sum to more than 10
03:30:23 <ziman> > getOne' [1..10]
03:30:24 <lambdabot>   Just ([1,2,3,4,5],[6,7,8,9,10])
03:31:04 <ziman> the first segment is [1..5] because sum [1..5] > 10 but sum [1..4] < 10
03:31:13 <ziman> and the rest is [6..10]
03:31:32 <ziman> (the `rest' is the yet unprocessed part of the list)
03:32:05 <ziman> the type signature f getOne' is:
03:32:08 <ziman> :t getOne'
03:32:08 <lambdabot> forall a. (Num a, Ord a) => [a] -> Maybe ([a], [a])
03:32:37 <Axman6> > getOne' [1..4]
03:32:38 <lambdabot>   Nothing
03:33:02 <Axman6> ah good, what i though
03:33:02 <ziman> which is very similar to that of cGenDecode -- it will return the prefix satisfying the condition (sum > 10, in this case) and the rest.
03:33:04 <BeelsebobWork> > let splitParts n = foldl (\(x:xs) y -> if sum (y:x) > n then []:(y:x):xs) [[]] in splitParts 10 [1..10]
03:33:05 <lambdabot>   <no location info>: parse error on input `)'
03:33:38 <ziman> (or Nothing if no such prefix can be found.)
03:33:51 <BeelsebobWork> > let splitParts n = foldl (\(x:xs) y -> if sum (y:x) > n then []:(y:x):xs else (y:x):xs) [[]] in splitParts 10 [1..10]
03:33:53 <lambdabot>   [[10],[9,8],[7,6],[5,4,3,2,1]]
03:34:06 <BeelsebobWork> > let splitParts n = reverse . map reverse . foldl (\(x:xs) y -> if sum (y:x) > n then []:(y:x):xs else (y:x):xs) [[]] in splitParts 10 [1..10]
03:34:07 <mm_freak> in strict languages, there are only two layers of definedness, bottom and most-defined, right?
03:34:07 <lambdabot>   [[1,2,3,4,5],[6,7],[8,9],[10]]
03:34:27 <BeelsebobWork> unfortunately strict though :(
03:34:30 <ziman> mikv, do you keep up?
03:34:37 <BeelsebobWork> would be fixable with a bit of inefficiency
03:34:39 <mikv> ziman, oh
03:34:51 <mikv> ziman, sorry, I haven't seen your messages
03:34:56 <mikv> ziman, wait a bit
03:35:01 <mikv> i will read it :-)
03:35:07 <ziman> okay :)
03:35:46 <mikv> ok
03:35:51 <mikv> I've read your messages
03:36:04 <mikv> @src getOne'
03:36:04 <lambdabot> Source not found.
03:36:14 <mikv> :t getOne'
03:36:14 <lambdabot> forall a. (Num a, Ord a) => [a] -> Maybe ([a], [a])
03:36:48 <ziman> it's a function i've defined temporarily and there's nothing relevant to see there :)
03:37:03 <ziman> getOne' = listToMaybe.filter((>10).sum.fst).liftM2 zip inits tails -- if you're interested
03:38:17 <ziman> anyway, now that we have a function that extracts the first piece and returns the unprocessed rest of the input, we can make plug it into another function that iterates application of getOne' in order to obtain *all* pieces.
03:39:13 <ziman> the function might look like this:
03:39:58 <ziman> > let f [] = []; f xs = case getOne' xs of Nothing -> []; (piece,rest) -> piece : f rest in f [1..10]
03:39:58 <lambdabot>   Couldn't match expected type `Maybe ([Integer], [Integer])'
03:40:05 <ziman> > let f [] = []; f xs = case getOne' xs of Nothing -> []; Just (piece,rest) -> piece : f rest in f [1..10]
03:40:06 <lambdabot>   [[1,2,3,4,5],[6,7],[8,9]]
03:40:09 <EvilTerran> > unfoldr getOne' [1..10]
03:40:10 <lambdabot>   [[1,2,3,4,5],[6,7],[8,9]]
03:40:12 <EvilTerran> :D
03:40:31 <ziman> i'm trying to be didactical :-P
03:40:35 <EvilTerran> sorry
03:40:39 <EvilTerran> ?src unfoldr
03:40:39 <lambdabot> unfoldr f b  = case f b of
03:40:39 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
03:40:39 <lambdabot>    Nothing        -> []
03:41:01 <EvilTerran> you can equationally reason them together fairly easily, anyway
03:41:18 <ziman> yes, and the layout is nicer :)
03:43:14 <mikv> ziman, hmm..
03:43:19 <mikv> I got good idea
03:43:31 <mikv> can you checkmy implementation a little bit later?
03:43:38 <ziman> mikv, take look at f. there's the base case, and in the `worker part' (getOne' xs) is evaluated and if the result is 1) Nothing: empty list is returned (no more pieces) 2) a piece and rest is returned: we process the rest by recursively applying f and then concatenate the piece with the subresult
03:45:46 <ziman> i may not be here later but there should be more friendly people here
03:47:03 <mmorrow> , let go _ k [] = [k []]; go n k (x:xs) | n+x>20 = k [] : go x (x:) xs | otherwise = go (n+x) (k[x]++) xs in go 0 id (randomRs (0,9::Int) (mkStdGen 873767))
03:47:05 <lunabot>  [[3,8,6],[6,7,0,7,0,0],[4,7,2],[9,9,1],[3,8,2,7,0],[6,9,3],[9,0,0,4,6],[5...
03:47:38 <mm_freak> > map (map fst) $ fix (\k s xs -> if null xs then [] else let (r,m) = span (\(x,a) -> a <= 10) $ zip xs (scanl (+) 0 xs) in r : k s (map fst m)) 10 [1..10]
03:47:40 <lambdabot>   [[1,2,3,4,5],[6,7],[8,9],[10]]
03:48:31 * EvilTerran blinks
03:48:48 <BeelsebobWork> yeh, that one was pretty blinkworthy
03:48:48 * EvilTerran looked at map (map fst) and immediately thought "... = (map . map) fst = fmap fmap fmap fst"
03:49:06 * EvilTerran goes to get another cup of coffee
03:49:19 <mm_freak> hehe
03:49:21 <BeelsebobWork> I love (fmap . fmap), but fmap fmap fmap is just silly
03:49:29 <BeelsebobWork> you *know* that fmap is working on functions
03:49:32 <BeelsebobWork> you can see them right there
03:49:36 <EvilTerran> quite
03:49:38 <vegai> @let fap = fmap
03:49:39 <lambdabot>  <local>:4:6:
03:49:39 <lambdabot>      Ambiguous type variable `f' in the constraint:
03:49:39 <lambdabot>        `Fun...
03:49:42 <vegai> awww
03:49:45 <BeelsebobWork> lol
03:50:05 <mmorrow> > fix (\go k n xs -> list [] (\x xs -> if n+x>10 then k [] : go (x:) x xs else go (k[x]++) (n+x) xs) xs) id 0 (randomRs (0,9::Int) (mkStdGen 993243))
03:50:06 <lambdabot>   [[1,7],[8],[9],[8],[4,2,2,1],[2,2,0,6],[6],[9,0],[6],[8],[6,1,2],[6,1],[8],...
03:50:11 <mmorrow> heh, "fap"
03:50:50 <ziman> > let fap = fmap in fap fap fap fst [[(1,2),(3,4)],[(5,6),(7,8)]]
03:50:52 <lambdabot>   Couldn't match expected type `(a -> b) -> (a -> b) -> a'
03:51:10 <ziman> MR?
03:51:45 <BeelsebobWork> no, rank 2 polymorphism I think
03:52:11 <ziman> > let fap :: (Functor f) => (a->b) -> f a -> f b; fap = fmap in fap fap fap fst [[(1,2),(3,4)],[(5,6),(7,8)]]
03:52:12 <lambdabot>   [[1,3],[5,7]]
03:52:16 <ziman> that's better. :)
03:54:38 <mmorrow> @let (?) = fix
03:54:38 <lambdabot>  Defined.
03:54:43 <mmorrow> sweet
03:54:52 <BeelsebobWork> that's harsh
03:55:03 <mmorrow> > (?) (\go k n xs -> list [] (\x xs -> if n+x>10 then k [] : go (x:) x xs else go (k[x]++) (n+x) xs) xs) id 0 (randomRs (0,9::Int) (mkStdGen 993243))
03:55:04 <lambdabot>   [[1,7],[8],[9],[8],[4,2,2,1],[2,2,0,6],[6],[9,0],[6],[8],[6,1,2],[6,1],[8],...
03:55:35 <BeelsebobWork> > (\go k n xs -> list [] (\x xs -> if n+x>10 then k [] : go (x:) x xs else go (k[x]++) (n+x) xs) xs)? id 0 (randomRs (0,9::Int) (mkStdGen 993243))
03:55:36 <lambdabot>       Overlapping instances for Show (t1 -> [t1] -> [[t1]])
03:55:36 <lambdabot>        arising fr...
03:55:45 <BeelsebobWork> aww, no postfix operators in
03:55:46 <mmorrow> @let (?) = id
03:55:47 <lambdabot>  <local>:5:0:
03:55:47 <lambdabot>      Multiple declarations of `L.?'
03:55:47 <lambdabot>      Declared at: <local>:4...
03:55:49 <BeelsebobWork> \bot?
03:55:52 <mmorrow> wuh
03:55:59 <mmorrow> @type (?)
03:56:00 <lambdabot> forall a. (a -> a) -> a
03:56:09 <mmorrow> um
03:56:19 <BeelsebobWork> @undef
03:56:21 <ziman> > (\f x -> if x == 0 then 1 else x * f (x-1)) ? 6
03:56:21 <lambdabot>   Not in scope: `?'
03:56:23 <BeelsebobWork> @type (?)
03:56:24 <lambdabot> Not in scope: `?'
03:56:25 <ziman> aah :)
03:56:31 <mmorrow> @let (?) = fix
03:56:32 <lambdabot>  Defined.
03:56:35 <mmorrow> @let (?) = id
03:56:36 <lambdabot>  <local>:2:0:
03:56:36 <lambdabot>      Multiple declarations of `L.?'
03:56:36 <lambdabot>      Declared at: <local>:1...
03:56:49 <BeelsebobWork> @let (<^) = flip fmap; (^>) = (<*>)
03:56:50 <lambdabot>  <local>:2:12:
03:56:50 <lambdabot>      Ambiguous type variable `f1' in the constraint:
03:56:50 <lambdabot>        `F...
03:56:53 <mmorrow> i think it's just recording any unicode char as being the same one
03:56:54 <BeelsebobWork> @let (<^) = flip fmap
03:56:55 <lambdabot>  <local>:2:12:
03:56:55 <lambdabot>      Ambiguous type variable `f' in the constraint:
03:56:55 <lambdabot>        `Fu...
03:57:01 <BeelsebobWork> uh, k?
03:57:05 <vegai> hey. I have this parser to extract a method from an xmlrpc call: http://hpaste.org/12029
03:57:17 <vegai> is there a more clever way with Parsec?
03:57:53 <mm_freak> next generation crazy factorial function in C…  this time using the fixpoint operator: http://rafb.net/p/0UTIji32.html =)
03:57:58 <lambdabot> Title: Nopaste - Factorial function using the fixpoint operator =)
03:58:06 <mmorrow> @let (?) = elem
03:58:07 <lambdabot>  <local>:2:0:
03:58:07 <lambdabot>      Multiple declarations of `L.?'
03:58:07 <lambdabot>      Declared at: <local>:1...
03:58:12 <mmorrow> @undefine
03:58:22 <mmorrow> @undef
03:58:35 <mmorrow> @let list nil _ [] = nil; list _ cons (x:xs) = cons x xs
03:58:36 <lambdabot>  Defined.
03:58:57 <mmorrow> @let bool false _ False = false; bool _ true True = true
03:58:57 <lambdabot>  Defined.
03:59:16 <mmorrow> @let mapfst f (a,b) = (f a,b)
03:59:16 <lambdabot>  Defined.
03:59:23 <mmorrow> @let mapsnd f (a,b) = (a,f b)
03:59:24 <lambdabot>  Defined.
03:59:30 <ziman> :t first
03:59:31 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
03:59:35 <BeelsebobWork> > first (+1) (1,2)
03:59:36 <lambdabot>   (2,2)
03:59:39 <mmorrow> i reject the name "first" :)
03:59:50 <BeelsebobWork> mmorrow: your definitions are wrong anyway
03:59:53 <mmorrow> @let mapl f = either (Left . f) Right
03:59:54 <lambdabot>  Defined.
04:00:02 <BeelsebobWork> mapfst f x = (f (fst x), snd x)
04:00:21 <mmorrow> @let mapr f = either Left (Right . f)
04:00:22 <lambdabot>  Defined.
04:00:36 <quicksilver> all this wouldn't be necessary if we had lenses.
04:00:41 <BeelsebobWork> indeed
04:00:49 <Peaker> BeelsebobWork: Hey, do you know the lplace example?
04:00:54 <mmorrow> lenses++
04:00:59 <EvilTerran> ?where lenses
04:00:59 <lambdabot> I know nothing about lenses.
04:01:00 <BeelsebobWork> Peaker: lplace example?
04:01:09 <Peaker> BeelsebobWork: in reactive-fieldtrip's examples, yeah
04:01:15 <BeelsebobWork> oh, I haven't looked at them
04:01:46 <Peaker> oh, ok
04:02:31 <EvilTerran> lenses is catamorphisms, right?
04:03:03 <Peaker> BeelsebobWork: I want to take a window 2d coordinate, and translate it to a 3d coordinate at a certain depth
04:03:18 <BeelsebobWork> uhhuh
04:03:44 <vegai> the latest ghc docs are rather horrible now :(
04:03:48 <vegai> e.g. http://haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM-TVar.html
04:03:50 <lambdabot> Title: Control.Concurrent.STM.TVar, http://tinyurl.com/5bcgy6
04:05:12 <Peaker> BeelsebobWork: I wonder if FieldTrip has a nice way of doing that
04:05:17 <mmorrow> , (fmap . fmap) (maybe [] (either undefined (list [] (flip const)) (Node [Just (Right [(False,42),(True,0)]), Nothing] [])
04:05:19 <lunabot>  luna: parse error (possibly incorrect indentation)
04:05:38 <Peaker> BeelsebobWork: Just multiple my (x,y) by the depth?  what's the "w" of the 3d perspective?
04:05:45 <BeelsebobWork> Peaker: it's just matrix devision
04:05:54 <rog__> i've been wondering, is there a nice, ultra-simple graph-drawing library that i can use with GHC under MacOS?
04:05:58 <mmorrow> , (fmap . fmap) (maybe [] (either undefined (list [] (mapr (bool True False))))) (Node [Just (Right [(False,42),(True,0)]), Nothing] [])
04:05:59 <lunabot>  luna: Not in scope: `list'
04:06:04 <mmorrow> > (fmap . fmap) (maybe [] (either undefined (list [] (mapr (bool True False))))) (Node [Just (Right [(False,42),(True,0)]), Nothing] [])
04:06:04 <lambdabot>   Couldn't match expected type `[Either a1 Bool] -> [a]'
04:06:14 * shapr boings
04:06:20 <Peaker> BeelsebobWork: how do you write:  windowTo3D (x,y) depth = ... ?
04:06:44 * EvilTerran would also boing, but he'd probably break instead of bouncing
04:06:44 <rog__> (i haven't done any graphics with haskell at all so far)
04:06:59 <shapr> EvilTerran: Don't do it!
04:07:14 <EmielRegis> can you have a function returning two values other than with tuples?
04:07:20 <Peaker> rog__: do you want the actual plotting functionality, or just getting pixels on screen?
04:07:35 <mapreduce> A list can have two elements.
04:07:41 <Peaker> EmielRegis: you can return other data structures with 2 elements
04:07:43 * EvilTerran makes a comprimise and settles on a sneezing fit instead
04:07:44 <rog__> Peaker: i'm after the actual plotting functionality
04:07:45 <mapreduce> You can return a data structure that has.. what he said
04:07:48 <BeelsebobWork> EmielRegis: yes -- you use continuation passing style
04:07:55 <Peaker> EmielRegis: you can do it the lambda calculus way, and return a function that applies its argument to the 2 elements
04:08:06 <EmielRegis> uhm
04:08:07 <quicksilver> EvilTerran: no, lenses is not just catamorphisms
04:08:08 <EmielRegis> im lost
04:08:15 <BeelsebobWork> EmielRegis: there's lots of options
04:08:15 <quicksilver> EvilTerran: lenses is selectors + updators togethers
04:08:16 <Peaker> EmielRegis: why not return a tuple though?
04:08:23 <EvilTerran> quicksilver, ah, clever
04:08:26 <rog__> Peaker: i've written graph drawing stuff from scratch before and getting the labelling right and the general appearance of the thing is is right pain...
04:08:26 <EmielRegis> dunno
04:08:28 <EmielRegis> ill probably do that
04:08:41 <quicksilver> EvilTerran: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
04:08:44 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
04:08:52 <quicksilver> although twanl doesn't call them lenses
04:08:58 <Peaker> BeelsebobWork: I'm new to Field Trip, I've done OpenGL work before, but I am not sure what matrix/transform I'd divide against. By divide do you mean ((*%) . inverse) ?
04:09:08 <mapreduce> > let cons x y = (\f -> f x, \f -> f y) in fst (cons 5 10) (*2)
04:09:08 <EvilTerran> EmielRegis, the "continuation passing style" approach involves noting that (a,b) is equivalent to (forall c. (a -> b -> c) -> c)
04:09:09 <lambdabot>   10
04:09:13 <BeelsebobWork> Peaker: you would divide by the projection matrix
04:09:17 <mapreduce> > let cons x y = (\f -> f x, \f -> f y) in snd (cons 5 10) (*4)
04:09:18 <lambdabot>   40
04:09:23 <Peaker> BeelsebobWork: how do I access/create the projection matrix?
04:09:24 <rog__> Peaker: my alternative is just to write out a text file and use something like gnuplot, but i'd prefer if it was possible to do it directly.
04:09:28 <EvilTerran> ?type flip uncurry
04:09:29 <lambdabot> forall a b c. (a, b) -> (a -> b -> c) -> c
04:09:30 <BeelsebobWork> Peaker: read it from OpenGL
04:09:49 <EvilTerran> EmielRegis, ie, instead of returning a pair (x,y), you return (\f -> f x y)
04:09:54 <Peaker> BeelsebobWork: does FieldTrip allow that?
04:10:22 <EvilTerran> EmielRegis, but it's usually simpler to just return the pair
04:10:29 <Peaker> BeelsebobWork: can I use FieldTrip's (*%) operator to do the division (inverse and then multiply)?
04:10:30 <BeelsebobWork> Peaker: sure -- all FieldTrip does is run a load of openGL commands -- you can set up the projection matrix however you want
04:10:41 <EvilTerran> ty quicksilver, i'll have a shufty
04:10:48 <mmorrow> speaking of that, dolio suggested adding a CPS State monad to a state monad benchmark i had and StateCPS beat unboxed tuples, which beat mtl State.Strict. i was surprised
04:10:54 <mmorrow> it's in a darcs repo at:
04:10:59 <Peaker> rog__: I don't know then, I only know about libs to put pixels on screen :)
04:11:06 <Peaker> rog__: graph plotting is pretty easy though, when you can put pixels on screen
04:11:12 <mmorrow> http://moonpatio.com/repos/state-bench/
04:11:17 <lambdabot> Title: Index of /repos/state-bench
04:11:39 <mmorrow> StateCPS is twice as fast as unboxed tuples
04:11:57 <rog__> Peaker: yeah, but it's still probably a couple of days' work to get automatic labelling right, and i can't spare the time...
04:11:59 <Peaker> BeelsebobWork: I also reported a bug, I think I found a way to get you to tesselate all wrong
04:12:11 <EvilTerran> quicksilver, that doesn't seem to talk about lenses anywhere, unless i'm missing something
04:12:13 <mmorrow> i suppose since it avoids unnecessary intermediate computations, /BUT/
04:12:23 <quicksilver> EvilTerran: functional references are lenses
04:12:30 <quicksilver> EvilTerran: as I say, he doesn't use the word
04:12:37 <mmorrow> in a different way than the mtl State.Lazy would (which blows the stack on this example)
04:13:01 <Peaker> a `mappend` b   between Transform3  does a or b first?
04:13:04 <mmorrow> newtype S s a = S {unS :: forall r. s -> (s -> a -> r) -> r}
04:13:06 <Peaker> (FieldTrip)
04:13:15 <mmorrow> fmap f (S g) = S (\s k -> g s (\s a -> k s (f a)))
04:13:24 <mmorrow> S g >>= f = S (\s k -> g s (\s a -> unS (f a) s k))
04:13:28 <EvilTerran> quicksilver, ah, but when he says "FRef getter setter", the "programming with miscellaneous everyday objects" folks would say [( getter, setter )] ?
04:13:32 <mmorrow> runS (S g) = flip g (flip (,))
04:13:33 <EvilTerran> s/but/so/
04:14:04 <quicksilver> mmorrow: I think StateCPS being twice as fast as unboxed tuples is almost a compiler bug.
04:14:06 <rog__> Peaker: ok. so if i just want to put bits on the screen, what library would you recommend. the fewer primitives it provides, the better!
04:14:11 <quicksilver> mmorrow: "bug" is a bit harsh, I guess.
04:14:26 <quicksilver> mmorrow: Indicates an area where a compiler could do better ;)
04:14:41 <mmorrow> quicksilver: heh, i know what what you mean though. i don't understand /exactly/ why StateCPS is so much faster
04:14:42 <Peaker> rog__: SDL
04:14:47 <quicksilver> EvilTerran: without the []
04:14:58 <Peaker> rog__: I have a couple of wrapper functions around it to make it a little easier
04:15:17 <quicksilver> mmorrow: the boxing, I'm almost sure.
04:15:18 <rog__> Peaker: available anywhere?
04:15:25 <EvilTerran> quicksilver, well, [( was meant to look like a lens
04:15:43 <Peaker> rog__: http://hpaste.org/12031
04:15:49 <quicksilver> mmorrow: GHC really doesn't do a very good job of removing intermediate tuples more is the pity.
04:16:00 <quicksilver> EvilTerran: ah, now I understand :) purty!
04:16:09 <mmorrow> quicksilver: hmm
04:16:16 <EvilTerran> it didn't really work, especially as it'd be ambiguous with the existing syntax =/
04:16:31 <Peaker> Hpaste's "Remember me" lies!
04:16:40 <Peaker> rog__: I annotated it with MyMonad
04:16:44 <Peaker> rog__: which I forgot to include at first
04:16:58 <EvilTerran> 〖getter, setter〗
04:17:18 <EvilTerran> Peaker, yeah, it's "announce" lies too... =/
04:17:23 <EvilTerran> *its
04:17:28 <Peaker> EvilTerran: well, that's only because the bot isn't here
04:17:34 <Peaker> its announcing, just to nowhere
04:17:40 <Peaker> so its a smaller lie :)
04:18:53 <BeelsebobWork> Peaker/rog: http://hpaste.org/12031#a2
04:19:21 <_andre> is there a way to tell cabal to build the profiling libraries for a package or do i have to do it manually?
04:19:28 <Peaker> BeelsebobWork: you didnt fix the recursion :)
04:19:38 <BeelsebobWork> Peaker: hmm?
04:19:48 <quicksilver> mmorrow: ndm reported a significant (30%?) speedup by doing a 'manual CPS transform' over a project
04:19:48 <Peaker> BeelsebobWork: you call takeWhileM :)
04:19:54 <BeelsebobWork> oh, woops
04:19:56 <Peaker> BeelsebobWork: I wrote takeWhileM when I was more of a Haskell newbie.. :)
04:20:18 <quicksilver> mmorrow: personally I don't quite have my head around how the CPS transform for data types interacts with strictness, though.
04:20:34 <Peaker> BeelsebobWork: if cond <$> element ... can't work
04:20:37 <Peaker> BeelsebobWork: you get a boxed Bool
04:20:46 <BeelsebobWork> oh, so you do
04:21:04 <Peaker> BeelsebobWork: it actually is monadic (you choose whether to apply more monadic actions based on previous results)
04:21:05 <BeelsebobWork> needs if' lifted
04:21:13 <BeelsebobWork> oh, so you do
04:21:15 <BeelsebobWork> lame
04:21:36 <rog__> Peaker: there seems to be very little documentation
04:21:40 <Peaker> BeelsebobWork: I am not sure it can be made applicative -- SDL should have had a "getEvents" interface, instead of pollNextEvent
04:21:45 <Peaker> rog__: for SDL?
04:21:56 <rog__> Peaker: for the haskell bindings for SDL
04:21:57 <Peaker> rog__: its got very few primitives. I can give you a little SDL example
04:22:29 <rog__> Peaker: it's got 13 modules, and it's not clear how they fit together
04:22:55 <Peaker> how do I tell ghc --make to look for libraries in another directory?
04:24:04 <rog__> Peaker: i failed. symlink? :-)
04:24:27 <EvilTerran> isn't it -I or something?
04:24:59 <BeelsebobWork> sL
04:25:03 <BeelsebobWork> -L even
04:25:05 <Peaker> rog__: http://hpaste.org/12032
04:25:10 <BeelsebobWork> -l adds a library to link against
04:25:16 <Peaker> BeelsebobWork: I tried -L, didn't seem to do the trick
04:25:31 <BeelsebobWork> Peaker: did you put a space between the L and the argument
04:26:03 <Peaker> BeelsebobWork: ghc: unrecognised flags: -L
04:26:08 <BeelsebobWork> o.O
04:26:13 <BeelsebobWork> I'm sure I've done that before
04:26:54 <BeelsebobWork> it works for me
04:27:00 <BeelsebobWork> what crazy version of ghc are you using?
04:27:13 <Peaker> The Glorious Glasgow Haskell Compilation System, version 6.10.0.20081007
04:27:17 <Peaker> Time to install 6.10.1 I guess
04:27:34 <BeelsebobWork> what's the exact command you're using?
04:28:04 <mmorrow> quicksilver: interesting re the 30% speedup
04:28:05 <Peaker> ghc -L ../lib --make -O2 jumpingtext
04:28:26 <mmorrow> quicksilver: yeah, me neither (about cps and strictness)
04:28:29 <BeelsebobWork> remove the space Peaker -- that's why I asked the question you didn't answer
04:28:35 <Peaker> haskell.org is so slow, why no ghc download mirrors?
04:28:57 <Peaker> BeelsebobWork: it doesn't find the libs
04:29:01 <Peaker> BeelsebobWork: without the space as well
04:29:09 <BeelsebobWork> I assume it no longer errors though
04:29:17 <Peaker> oh maybe it expects them to be compiled there
04:29:30 <BeelsebobWork> it expects either .a or .dylib files there
04:29:38 <Peaker> how do I make those?
04:29:44 <BeelsebobWork> you compile a library
04:29:52 <Peaker> I have an .hs file
04:30:06 <BeelsebobWork> then you want it to search for source files in ../lib, not libraries?
04:30:36 <Peaker> BeelsebobWork: that would be good too
04:30:41 <BeelsebobWork> -i../lib
04:30:56 <Peaker> ah, cool, thanks
04:30:58 <Peaker> that works
04:31:09 <Peaker> rog__: did you manage to run that?
04:31:25 <rog__> Peaker: i haven't built sdl yet
04:31:35 <Peaker> rog__: I hope you're using cabal install :)
04:31:50 <ziman> what's the use of Data.Unamb? http://hackage.haskell.org/packages/archive/unamb/0.0.1/doc/html/Data-Unamb.html
04:31:56 <lambdabot> Title: Data.Unamb, http://tinyurl.com/65ugsu
04:32:34 <rog__> Peaker: % runhaskell Setup configure
04:32:34 <rog__> Peaker: Setup.lhs:4:30: Not in scope: `autoconfUserHooks'
04:32:49 <BeelsebobWork> ziman: the first use is to get proper reactivity semantics in Reactive
04:33:25 <mmorrow> @let mutual f g a = f a (\b -> g b (\a -> mutual f g a))
04:33:25 <lambdabot>  Defined.
04:33:49 <Peaker> rog__: why not cabal install?
04:33:55 <Peaker> rog__: this is not 1992
04:34:05 <_andre> wow, i've just changed my program to use mersenne-random-pure64 instead of the std lib System.Random and it ran 10x faster :)
04:34:18 <BeelsebobWork> blimeh
04:34:40 <rog__> Peaker: i thought that *was* how you did a cabal install...
04:34:45 <ziman> so i'd need to read up on FRP :)
04:34:55 <Peaker> rog__: cabal does it all for you...
04:34:56 <ziman> just wondering, i was browsing the packages on hackage
04:35:24 <Deewiant> ziman: maybe you have many computations which you know result in the same value, but their effectiveness is machine-dependent, so you run em all ;-)
04:35:58 <rog__> Peaker: erm, that's not what http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package says...
04:36:00 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/39kra4
04:36:18 <mmorrow> _andre: System.Random is slow like whoa
04:36:37 <_andre> mmorrow: yeah i noticed :P
04:36:39 <BeelsebobWork> ziman: you wouldn't need to -- it's just one of the potential uses of unamb
04:36:40 <rog__> Peaker: maybe that's not the cabal you're talking about?
04:36:47 <BeelsebobWork> it can also be used for defining (&&) correctly
04:36:52 <ziman> i see.
04:36:56 <ziman> yeah, exactly
04:37:08 <mmorrow> _andre: i was (pleasantly) surprised the first time i used mersenne-random too :)
04:37:10 <Peaker> rog__: I'm talking about cabal-install
04:37:12 <Peaker> rog__: not cabal
04:37:29 <BeelsebobWork> x (&&) y = if x then y else False `unamb` if y then x else False -- like this ziman
04:37:43 <Peaker> rog__: grab http://hackage.haskell.org/packages/archive/cabal-install/0.6.0/cabal-install-0.6.0.tar.gz
04:37:44 <lambdabot> http://tinyurl.com/6gcmrq
04:37:48 <rog__> Peaker: but won't that end up doing exactly the same thing?
04:37:52 <Peaker> rog__: and run the bootstrap.sh in there
04:37:57 <pgavin> anyone here familiar with the paper "Notions of computation and Monads" by E. Moggi?
04:38:11 <Peaker> rog__: I don't know, I prefer to let cabal-install worry about it.  "cabal install SDL" here worked smoothly
04:38:17 <Peaker> rog__: on ghc-6.8 and ghc-6.10 alike
04:38:26 <_andre> mmorrow: i wonder if a replacement could be build with the same interface... or is there a reason to keep the slower one?
04:38:29 <Peaker> rog__: cabal-install may choose to hide/show alternative libraries according to the package's requirements
04:38:36 <_andre> built*
04:38:40 <EvilTerran> BeelsebobWork, i was thinking more like x -&&- y = (x && y) `amb` (y && x)
04:38:49 <BeelsebobWork> that too
04:38:52 <EvilTerran> er, unamb
04:38:54 <BeelsebobWork> but unamb
04:39:07 <ziman> interesting.
04:39:12 <Peaker> rog__: "cabal update ; cabal install SDL" is so much more fun than manually fetching dependencies, setting up the hide/show of the right packages, etc
04:39:22 <Peaker> dcoutts++
04:39:28 <Deewiant> and it's so much less fun when it doesn't work
04:39:29 <Deewiant> Windows--
04:39:43 <Peaker> Deewiant: it usually works
04:40:02 <Peaker> Deewiant: and when it doesn't, it often has more informative failure messages than when running Setup directly
04:40:11 <Peaker> (so its easier to fix the broken .cabal files)
04:40:12 <Deewiant> Peaker: every single time a library has depended on an external C library, I've had to mess with its source and/or do a manual ghc-pkg update afterwards
04:40:26 <Peaker> Deewiant: I just had to install my Ubuntu's -dev packages :)
04:40:36 <Deewiant> yeah, good for you :-P
04:40:44 <Peaker> Deewiant: except for the GLUT-on-x86/32 case
04:40:51 <Peaker> but that's GLUT's fault
04:41:02 <Peaker> Deewiant: why do you use Windows?
04:41:21 <Deewiant> I like my games
04:41:29 <mmorrow> _andre: there's also this implem. i've been meaning to try it out: http://darcs.augustsson.net/Darcs/MT/
04:41:34 <lambdabot> Title: Index of /Darcs/MT
04:41:37 <Deewiant> and my Windows-only software, on some rare occasions
04:41:46 * EvilTerran uses his computer as a wintendo too
04:42:49 <rog__> Peaker: http://hpaste.org/12034#a0
04:43:03 <mmorrow> _andre: i don't see why System.Random couldn't be made unslow, but at the least that would be a process..
04:43:30 <mmorrow> i'm not sure what algo System.Random uses either
04:43:58 <Deewiant> This implementation uses the Portable Combined Generator of L'Ecuyer [System.Random#LEcuyer] for 32-bit computers, transliterated by Lennart Augustsson. It has a period of roughly 2.30584e18.
04:44:11 <Deewiant> and the link is dead :-P
04:44:18 <rog__> i feel myself descending into install nightmare. i much prefer to keep things simple.
04:44:31 <Deewiant> ah, I see why, it links to Random#Lecuyer.html
04:44:39 <Deewiant> instead of Random.html#Lecuyer
04:45:02 <Peaker> rog__: what ghc are you using?
04:45:10 <rog__> Peaker: 6.10
04:45:14 <rog__> Peaker: i think
04:45:20 <Peaker> rog__: ghc --version
04:45:28 <Peaker> rog__: SDL not found
04:45:39 <Peaker> rog__: you need to install SDL and sdl-dev. what OS are you on?
04:45:51 <mmorrow> _andre: hmm, looks like the algorithm isn't explicitly named, and of the references at eof, none are newer than 1992 http://darcs.haskell.org/libraries/random/System/Random.hs
04:46:03 <mmorrow> looks ripe for an update
04:46:17 <rog__> ah no, i seem to have reverted to 6.8. i'll change my path and try again.
04:46:20 <Peaker> rog__: try installing SDL (and -dev packages if OSX has those) and see if cabal install then works
04:46:22 <mmorrow> ooh, i have lecuyer in javascript
04:46:32 <Peaker> rog__: my question was misguided, ghc 6.8 and 6.10 should both be ok, you're just lacking the SDL library
04:46:42 <Peaker> rog__: SDL's haskell lib is just a wrapper around that, you need to have SDL installed
04:46:45 <Peaker> brb
04:46:48 <rog__> Peaker: won't cabal install do that?
04:47:39 <rog__> oh god, all i want to be able to do is: plot $ map (\ x -> (x, sin x)) [-5, -5.9, .. 6]
04:47:44 <Peaker> rog__: cabal install only installs the Haskell side of things
04:48:10 <Peaker> rog__: for Haskell wrappers of external/C libraries, you need to get the C libraries installed first.  I don't know how you install SDL on a mac. On Ubuntu, its something like: apt-get install libsdl1.2-dev
04:49:14 <rog__> but even when i've got all that installed, i still have to learn an entire new graphics interface, work out how to place text correctly, and all before my meeting in 1 hour and 12 minutes. i think i'll punt for the time being and just use gnuplot!
04:49:40 <BeelsebobWork> rog: (\x -> (x,sin x)) == id &&& sin
04:50:47 <rog__> Beelsebob: yeah i still haven't got my head around arrows yet, although i'm getting there.
04:51:58 <BONUS> you dont have to really know arrows to enjoy the utility of &&& and *** though :)
04:52:08 <BONUS> > ((+1) &&& (+2)) 1
04:52:09 <lambdabot>   (2,3)
04:52:17 <Aaron> how to count the characters in a file?
04:52:23 <rog__> Beelsebob: which instance of arrows would apply when using your example?
04:52:31 <BONUS> (->)
04:52:34 <BONUS> functions are arrows
04:52:37 <rog__> ok
04:53:16 <quicksilver> arrows are just functions with a bit more structure
04:53:20 <quicksilver> or a bit less costructure
04:56:03 <rog__> quicksilver: mmm. but that doesn't really contribute to me really *getting* them... at least, it hasn't worked yet. i need to understand what's actually going in particular, rather than in the abstract. then i should be able to see how they might apply in particular things that i encounter...
04:59:39 <Peaker> rog__: If you want to plot graphs, SDL is not ideal. But SDL is a good way to get your pixels on screen
04:59:54 <Peaker> rog__: Easier for 2d than OpenGL, and an alternative to GLUT for 3d
05:00:06 <rog__> Peaker: i want to plot graphs!
05:00:30 <Peaker> maybe you can create FFI bindings for a graph plot library in an hour :)
05:00:45 <rog__> Peaker: (but that's ok, i was just hoping against hope there might be a good out-of-the-box solution...)
05:01:06 <rog__> Peaker: not if i've never done any FFI stuff with haskell before :-)
05:01:57 <_Dae_> Greetings mighty gods of haskell. Forgive me, for I have sinned
05:02:14 <rog__> Peaker: and in my experience creating an FFI interface is never quite that straightforward anyway, as you have to try to match language idioms, and there's always a good dose of mismatch
05:02:56 <Sebastian> hi
05:03:12 <Stephan202> I wonder whether there is a built-in function that does something like this:
05:03:13 <Stephan202> alterf :: (Eq a) => (a -> b) -> a -> b -> (a -> b)
05:03:13 <Stephan202> alterf f a b x | a == x    = b  | otherwise = f x
05:03:33 <Stephan202> (with an additional newline :P)
05:03:42 <Stephan202> hi Sebastian
05:04:15 <Stephan202> In words: take a function, and alter it such that for a specific input it gives a (possibly) different output than the original function.
05:04:25 <Sebastian> I have a typical "not in scope" error
05:04:27 <Sebastian> http://hpaste.org/12035#a0
05:04:41 <Sebastian> at (b == (Plus x))
05:05:01 <Axman6> Sebastian: they're of the same type?
05:05:05 <Sebastian> any1 any ideo how to solve thsi the right way?
05:05:19 <Axman6> or... Plus isn;t importded/defined?
05:05:23 * Axman6 checks code
05:05:30 <amit8-88> anyone know how to create menus
05:06:05 <amit8-88> I have an assignment due requiring menus to perform certain string functions
05:07:03 <Peaker> rog__: I haven't done FFI in Haskell too, but it seems to be quite a bit easier than other HLL's
05:07:11 <Sebastian> maybe I can solve this without if then else
05:08:48 <quicksilver> rog__ , Peaker : simple FFI in haskell is blissfully simple.
05:08:54 <amit8-88> Sebastian: can you tell me the way. I am stuck ;)
05:08:54 <quicksilver> adapting idioms never will be though :)
05:09:14 <quicksilver> and there isn't anything clever it does for C structures, either.
05:10:49 <hackage> Uploaded to hackage: haskell-src-exts 0.3.12
05:11:49 <jeffz> amit8-88: "menus" is rather ambiguous
05:14:06 <Sebastian> how can i check if b is of type (Plus x) and not having x "not in scope"?
05:14:10 <amit8-88> hmm Let me put it this way. I have a list of actions to be performed and I want to put that in a GUI menus
05:14:48 <Axman6> Sebastian: case, or pattern matching
05:14:52 <Axman6> (the same thing really)
05:14:54 <Raevel_> Sebastian: do you mean case b of (Plus _) -> ... ?
05:15:07 <Sebastian> yeah
05:15:08 <amit8-88> is it possible? I tried using if-else but I cannot add more than one menu
05:15:09 <Sebastian> kinda
05:15:20 <Axman6> case b of Plus x -> f x; Minus y -> g y...
05:15:31 <Sebastian> but i have to to have the _ in Plus _
05:16:23 <jeffz> amit8-88: if printing out a list of options and asking the user to select one qualfies as a menu, I'd pick that.
05:16:30 <Axman6> Sebastian: why?
05:16:34 <Sebastian> is there a case ... default thing in hasekll?
05:16:44 <Peaker> quicksilver: how do you wrap C structures?
05:16:49 <Axman6> _ -> ohNoes
05:17:13 <Sebastian> because i have to make a further output
05:17:22 <Sebastian> show'x ++ "*"
05:18:13 <amit8-88> jeffz: yes. can you tell me how to do that ?
05:18:32 <jeffz> amit8-88: look at the library reference
05:18:44 <jeffz> amit8-88: http://www.haskell.org/ghc/docs/latest/html/libraries/
05:18:45 <lambdabot> Title: Haskell Hierarchical Libraries
05:19:09 <jeffz> amit8-88: specifically System.IO http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
05:19:11 <lambdabot> Title: System.IO, http://tinyurl.com/y9dfge
05:19:18 <Sebastian> if u want to, i can post the exercise (german)
05:22:36 <amit8-88> jeffz: thank. am lokking into it
05:22:42 <amit8-88> looking*
05:30:57 <maltem> Sebastian: posting a code fragment at hpaste is often a good way to get help and hints here
05:31:21 <Sebastian> thats the whole programm
05:31:55 <maltem> hmm?
05:32:01 <Sebastian> I have to implement show RegExp
05:32:23 <Sebastian> and my problem is: | a == Eps      = if (b == (Plus x)) then
05:32:27 <Sebastian> x is not in scope
05:32:38 <maltem> @where hpaste
05:32:38 <lambdabot> http://hpaste.org/
05:32:47 <Sebastian> http://hpaste.org/12035#a0
05:33:18 <maltem> ah, I weren't aware you had uploaded it alredy
05:33:20 <maltem> already
05:33:46 <Sebastian> :)
05:33:54 <Sebastian> I just don't get it.
05:34:04 <Sebastian> I'm rather new to haskell.
05:34:28 <Raevel_> Sebastian: still the same problem?
05:35:00 <maltem> Sebastian: well I don't know whether it was already mentioned (just joined), but you probably need a "case"
05:35:01 <Sebastian> yeah, if you can give me a whole example, hwo the problem is solved, I may understand it
05:35:17 <Sebastian> so.. how to define the default?
05:35:33 <Philippa> Sebastian: you're trying to use == to do pattern-matching
05:35:45 <Sebastian> yes
05:35:45 <Philippa> defaults can be done using _ wildcard patterns
05:35:50 <Raevel_> Sebastian: when you type (Plus x) there it tries to construct a RegExp using the Plus constructor
05:35:57 <quicksilver> Sebastian: instead of "if b == Plus x then ... else ... "
05:35:59 <quicksilver> you can do
05:36:08 <quicksilver> case b of Plus _ -> ... ; _ -> ....
05:36:20 <Philippa> Sebastian: you can do nested patterns though
05:36:38 <Philippa> show (Sum Eps (Plus x)) = ...
05:36:53 <maltem> Sebastian: http://hpaste.org/12035#a1 is an example of what quicksilver said
05:37:03 <Philippa> show (Sum (Plus c) b) = ...
05:37:28 <maltem> Sebastian: except I have an error in it, it should be _, not otherwise :-/
05:37:40 <Philippa> maltem: strictly speaking that works though
05:37:43 <Philippa> you just rebind otherwise
05:37:47 <Sebastian> Philippa: that's a goiod point
05:37:52 <Sebastian> I#ll tray that way
05:38:04 <Sebastian> omg, bad typing ;)
05:38:07 <maltem> Philippa: yeah, but it would be stupid
05:39:21 <Sebastian> as long as it works
05:39:30 <Sebastian> haskell just pwns me
05:40:32 <maltem> Sebastian: uni stuff?
05:40:45 <Sebastian> yeah
05:41:47 <Raevel_> we don't have any haskell courses here :-(
05:41:53 <_Dae_> question: is there any way to make javascript more tolerable? (as in, less painful to use as a haskell user)
05:42:06 <Raevel_> _Dae_: yes!
05:42:24 <Sebastian> http://hpaste.org/12036 <- my actual solution
05:42:29 <Sebastian> but i does not work#
05:42:31 <_Dae_> Raevel_:  Do continue :)
05:42:48 <BeelsebobWork> Sebastian: don't use tabs
05:42:49 <Sebastian> RegExp.hs:17:25:    parse error on input `->'
05:43:12 <Raevel_> _Dae_: obviously the languages are very different, i'm not sure exactly what you're after
05:43:18 <Sebastian> omg, damn eclips
05:43:26 <BeelsebobWork> also, the syntax for case is case exp of value -> exp; value -> exp;...
05:43:37 <BeelsebobWork> not case value -> exp
05:44:57 <Sebastian> thx
05:45:50 <Raevel_> _Dae_: you can't do much without bind though, ( http://www.cactusjs.com/trac/browser/Addon/Function.js )
05:47:16 <_Dae_> Raevel_: link is dead I'm afraid. But I guess what I really miss is the abillity to write code without having to create tons of object oriented filler code.... It's like java, just without the good stuff
05:47:35 <Raevel_> oh is it
05:47:44 <Raevel_> the url that is
05:47:45 <Raevel_> :-)
05:47:47 <_Dae_> Raevel_: what it says here anyway
05:47:57 <Raevel_> i'm having some dns issues :-/
05:48:12 <_Dae_> :S
05:48:22 <mapreduce> _Dae_: Java without the good stuff?  There's good stuff?
05:48:41 <mapreduce> I had to parse that a few times to make sure it wasn't a typo.
05:49:03 <grul> funny
05:49:05 <_Dae_> mapreduce:  well, the way I code, compile time errors count as good things....
05:49:35 <Raevel_> agreed
05:49:47 <mapreduce> _Dae_: Sure, but Java will give you compile time errors for things that shouldn't be errors, and it won't give you them for things that should be errors.
05:49:50 <_Dae_> I also guess not having to create your own linked list counts as a plus....
05:50:07 <C-Keen> hm is clojure now the new cool kid on the block?
05:50:18 <Wild_Cat> _Dae_: especially since there's very (very very) few use cases for linked lists in Java anyway :p
05:50:21 <mapreduce> clojure is untyped, afaik.
05:50:29 <Sebastian> new error o/
05:50:31 <Sebastian> http://hpaste.org/12037
05:50:48 <_Dae_> mapreduce: right, but compared to, say... c, or javascript's compile time errors it's rather nice
05:50:59 <Sebastian>   Could not deduce (Eq (RegExp a))       from the context (Show (RegExp a), Show a)       arising from a use of `=='
05:51:21 <mapreduce> There is a lib from Doug Crockford from Yahoo to give some better static feedback about JS code.
05:51:26 <mapreduce> I've forgotten the name.
05:51:28 <Raevel_> jslint
05:51:30 <Raevel_> ?
05:51:37 <mapreduce> Possibly.
05:51:41 <Raevel_> it's not that useful though, imo
05:51:51 <mapreduce> I've not tried it, as I don't do webdev.
05:51:54 <Wild_Cat> Java's good stuff is that when your program crashes, the VM's very explicit as to why, where and how.
05:51:59 <_Dae_> Wild_Cat: why would there be less need for a linkedlist in java than anywhere else? I know you can use ArrayList, but that doesn't mean you should
05:52:16 <mapreduce> _Dae_: Because it doesn't do tail call elimination.
05:52:23 <mapreduce> You can fill in the gaps in that logic at your leisure.
05:52:41 <maltem> Sebastian: either add an Eq instance, or (maybe easier for now) use pattern-matching instead of ==
05:52:41 <matthew-_> ok, so I'm using hsc and trying to populate a struct in C, which has fields with types such as usize_t. This doesn't seem to be a supported Haskell data type
05:52:44 <Botje> Sebastian: you didn't write down an Eq constraint for Regexp.
05:52:51 <mapreduce> A linked list is useful in Java though.
05:52:54 <matthew-_> so, what should I do?
05:52:59 <Botje> Sebastian: why not use pattern matching?
05:53:02 <mmorrow> _Dae_: i have just the thing for your js woes :) (you need ghc6.10) http://moonpatio.com/repos/js-qq/
05:53:02 <lambdabot> Title: Index of /repos/js-qq
05:53:05 <mapreduce> So useful that there's an immutable linked list in the javac codebase.
05:53:14 <kynky> data structures are useful in any language i thought :)
05:53:26 <Raevel_> mmorrow: what's that?
05:53:40 <Wild_Cat> _Dae_: as I learned by lurking on this channel, there are exactly two use cases for linked lists: prepend-heavy code (which you may generalize to insert-heavy code as opposed to append-heavy) and pure programming languages where immutability means you can share tails.
05:53:42 <mmorrow> a javascript quasiquoter
05:53:45 <Wild_Cat> (e.g. haskell)
05:54:03 <Wild_Cat> if you're doing anything else, array lists are a better choice.
05:54:13 <mmorrow> http://moonpatio.com/repos/js-qq/js-qq/src/Language/Javascript/QQ/Lib.hs
05:54:14 <lambdabot> http://tinyurl.com/5mr7ou
05:54:25 <Wild_Cat> of course, in Java use case #2 is invalid.
05:54:27 <_Dae_> Wild_Cat: but I can't insert in ArrayList in constant time
05:54:30 <matthew-_> sigh, http on haskell.org seems to have died
05:54:33 <mapreduce> Wild_Cat: It's not invalid.
05:54:35 <mmorrow> http://moonpatio.com/repos/js-qq/WebUi.hs.html
05:54:36 <lambdabot> Title: Haskell code
05:54:37 <Sebastian> Botje: Because I am ha Haskell noob and really understand just a tiny bit of all this stuff
05:54:43 <mapreduce> It's perfectly ok to have immutable data structures in Java.
05:54:48 <Wild_Cat> _Dae_: reread my line: "which you may generalize to insert-heavy code as opposed to append-heavy"
05:54:51 <mmorrow> javascript code becomes like data :)
05:54:58 <mapreduce> The JVM is actually quite good with them too.
05:55:03 <Botje> Sebastian: well, either you can add "deriving Eq" to your data Regexp a declaration
05:55:04 <Wild_Cat> mapreduce: sure, but linked lists won't gain you any memory there.
05:55:19 <mapreduce> Wild_Cat: Streams (lazy lists) can.
05:55:25 <Wild_Cat> since 1. Java's linked lists are mutable, and 2. they're doubli-linked
05:55:27 <mmorrow> i need to have lunabot import that..
05:55:41 <kynky> with java development its easier to hire cheap developers, then get expensive hardware, than for expensive developers, and less good hardware,
05:55:45 <mapreduce> You can write your own Java linked list.
05:55:51 <Wild_Cat> mapreduce: I'm talking about java.util.LinkedList here, by the way.
05:55:52 <Raevel_> _Dae_: now it's up, http://www.cactusjs.com/trac/browser/trunk/Addon/Function.js
05:55:54 <mapreduce> And there's one in Google Collections.
05:55:54 <lambdabot> Title: /trunk/Addon/Function.js - Cactus JS - Trac
05:56:03 <mapreduce> Wild_Cat: Why?  That's an awful implementation.
05:56:11 <kynky> well generics is really good in java, i wonder where that came from.....  :)
05:56:23 <_Dae_> mmorrow:  what's a quasiquoter?
05:56:25 <mapreduce> kynky: Except variance.
05:56:32 <Wild_Cat> mapreduce: it's the stdlib one. And incidentally, one java.util.ArrayList trounces on all use cases save the one I quoted above.
05:56:32 <Botje> or you can use pattern matching like so: show (Sum Eps (Plus x)) = show' x ++ "*" ; show (Sum Eps b) = show' b ++ "?"
05:56:55 <Botje> show (Sum a Eps) = show (Sum Eps a)
05:57:05 <_Dae_> Raevel_: timed out...
05:57:07 <Botje> show (Sum a b) =  show' a ++ "|" ++ show' b
05:57:12 <mapreduce> Wild_Cat: That one is the main reason to use linked lists, yes.
05:57:15 <Raevel_> _Dae_: wierd!
05:57:17 <mapreduce> Shared tails.
05:57:22 <Raevel_> works fine here now
05:57:44 <mapreduce> Prepend-heavy code can easily be written as append-heavy.
05:57:54 <Wild_Cat> mapreduce: I think we're mostly in agreement there.
05:59:11 <mapreduce> I saw my first fold in javac's codebase. :)
05:59:17 <mmorrow> at the bottom of http://moonpatio.com/repos/js-qq/js-qq/src/Language/Javascript/QQ/Lib.hs the Cont monad is mapped into javascript with return, (.>>=.), and shift implem (callCC'd be easy to add, it's very similar to shift)
05:59:18 <lambdabot> http://tinyurl.com/5mr7ou
05:59:26 <Raevel_> _Dae_: and regarding the filler code, sure there's some extra typing, but some of it can be abstracted out at least, like subclassing
06:00:09 <mmorrow> err, this file has more commented ghci sessions showing output from that stuff: http://moonpatio.com/repos/js-qq/js-qq/src/Language/Javascript/QQ/Eval.hs
06:00:11 <lambdabot> http://tinyurl.com/6ck8fm
06:00:19 <Wild_Cat> mapreduce: seeing that expressing a fold in Java code (esp. pre-1.5) results in bloody atrocious syntax, that surprises me.
06:00:48 <mapreduce> It was a fold combined with a visitor.
06:01:09 <mmorrow> _Dae_:
06:01:15 <mapreduce> Each fold was about 60 lines of code, but in context it wasn't such a bad thing.
06:01:18 <mmorrow> , src ''QuasiQuoter
06:01:32 <lunabot>  data QuasiQuoter = QuasiQuoter {quoteExp :: (String -> Q Exp),
06:01:32 <lunabot>                                  quotePat :: (String -> Q Pat)}
06:01:44 <Wild_Cat> mapreduce: weird, an accumulator loop would have felt like the "right" way to do folds in Java.
06:01:59 <mmorrow> it's an extension to template-haskell/ghc that allows you to get a String as input inside special brackets, and then map that to template-haskell syntax, which is then evaluated and spliced into the haskell prog
06:02:05 <mmorrow> all this happens at compile time
06:02:34 <mmorrow> so, for instance, all js syntactic errors cause /haskell/ compilation failure, and are reported at haskell compilation time
06:02:55 <mmorrow> in addition to that, you can use the haskell type system for the js to further get type correctness (with effort)
06:03:14 <mapreduce> Wild_Cat: It might be because the current implementation of javac is based on the codebase for Generic Java by Martin Odersky (Scala author).
06:03:15 <_Dae_> Raevel_: I don't seem to be able to program decent OO without getting into a a situation where 80% of the code does nothing really useful (compared to say, haskell codee, where most of my code actually "does" stuff)
06:03:23 <mmorrow> i have to run right now, but i'd love to talk about this later :)
06:03:30 <_Dae_> mmorrow: nice :)
06:04:53 <mapreduce> Wild_Cat: I made a small demo program using it that just looks for one particular example of stupid code: if (condition); (an empty if body)
06:04:57 <mapreduce> Wild_Cat: http://docs.google.com/Doc?id=dx5mfkq_85hk6hhh
06:04:58 <lambdabot> Title: import javax.tools.*;
06:06:43 <mapreduce> _Dae_: You might find that differs if you use a more pure form of OO, such as Common Lisp's.
06:06:58 <mapreduce> pure in a different sense to pure functional programming though.
06:07:10 <_Dae_> mapreduce: I've mainly programmed java and some c++
06:07:32 <mapreduce> Then my comment directly applies.
06:07:36 <Wild_Cat> _Dae_: then you need to have a look at a language with a well-designed OO layer.
06:07:39 <Wild_Cat> ;)
06:08:35 <Wild_Cat> mapreduce: I see. That does, in part, match my definition of bloody awful syntax, but it's true that the accumulation loop (well, recursion in that case) approach would have looked worse with a tree data structure.
06:08:35 <_Dae_> Wild_Cat: such as?  :p ATS? Eiffel?
06:08:58 <Wild_Cat> _Dae_: I'm a Python guy myself. Find it allows me to get surprising amounts of work done in very little code.
06:09:04 <mapreduce> Wild_Cat: It's a given that Java has awful syntax, sure.
06:09:23 <mapreduce> But other than languages with pattern matching, what language will do that particular case better?
06:09:49 <_Dae_> Wild_Cat: sure, but are you actually able to program on stuff with other people? Or read code you haven't seen in a year?
06:10:01 <mapreduce> Python is quite readable.
06:10:05 <Wild_Cat> _Dae_: yes on both accounts. And that's my job, if you want to know ;)
06:10:24 <quicksilver> python is quite neutral.
06:10:26 <mapreduce> It's just not very writeable (no type system).
06:10:33 <quicksilver> it's certainly possible to write readable code in it.
06:10:49 <Wild_Cat> it has a type system. Just a dynamic one. (so no compile-time checks)
06:11:04 <mapreduce> It has no type system, for any definition of type system that holds water.
06:11:14 <mapreduce> @go tapl
06:11:16 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:11:16 <lambdabot> Title: Types and Programming Languages
06:11:20 <_Dae_> ohh, nice. I thought it was almost impossible in the real world.
06:11:21 <mapreduce> I take mine from there.
06:11:35 <Wild_Cat> _Dae_: and the Python culture emphasizes well-documented, easy to read code. What with docstrings and all.
06:12:44 <_Dae_> Wild_Cat: Guess I should strike one of my prejudices against python ;)
06:13:10 <Wild_Cat> _Dae_: from the looks of it, you may be actually thinking of Perl or PHP :p
06:14:25 <mapreduce> Python is quite an opinionated culture.  You do things Guido's way or your code is unreadable.  Almost by design.
06:14:29 <_Dae_> Wild_Cat: heh, I might be confusing it with perl
06:14:52 <mapreduce> I do like a lot of its syntax.
06:15:00 <Wild_Cat> mapreduce: that's true, although IMO not to the extent you're making it to be ;)
06:15:36 <mapreduce> Wild_Cat: Translate the following lambda to Python: \x -> if (x < 3) then "hello" else "goodbye"
06:15:57 <Wild_Cat> mapreduce: lambda x: "hello" if x < 3 else "goodbye"
06:16:04 <maltem> _Dae_: I support the "python can be readable" opinion. I once had a look at mercurial, and of all rcs's that I glanced over, it was the one where I quite quickly got the overall code structure
06:16:35 <Wild_Cat> mapreduce: (yes, there is a ternary operator as of 2.5 :p )
06:16:51 <mapreduce> Heh, nice.
06:20:14 <Wild_Cat> I won't deny that there is, however, a strong emphasis on "there should be one, and preferably only one, obvious way to do it."
06:20:48 <kynky> so whats the python way of skinning a cat?
06:21:07 <Wild_Cat> we feed it to a snake.
06:21:36 <kynky> i preferred ruby to python, but thats just me
06:21:54 <mapreduce> Ruby is worse-specified and a much larger grammar afaik.
06:22:14 <kynky> love those ducks :)
06:22:27 <Sebastian__> thx 4 your help
06:24:23 <Wild_Cat> I like Ruby. Its syntax is elegant in its Smalltalk-ness. But its Unicode support is non-existent, and when I last looked at it English-language documentation was subpar.
06:24:47 <quicksilver> strange for a language with a strong japanese following to have poor unicode support?
06:24:55 <Wild_Cat> there is little interest in knowing both Python and Ruby, though. If you already know one of the two, stick with it.
06:25:36 <Deewiant> they're different enough that I think it's worth being somewhat familiar with both
06:25:38 <quicksilver> well one interest is if you have to maintain code written in the other :)
06:25:42 <scook0> quicksilver: unicode is not especially well-liked in japan, I'm led to believe
06:25:53 <kynky> i thought ruby 1.9.1 ould have unicode support
06:25:54 <quicksilver> another interest is to apply for a job which requires the other...
06:26:00 <Wild_Cat> quicksilver: yeah, there's that. But once you know one, the other is easy to pick up anyway ;)
06:26:00 <quicksilver> scook0: ah, that explains it. I didn' tknow that.
06:27:00 <kynky> i think haskell is where its at, functional programming gonna be the next big commercial thing :)
06:27:02 <Deewiant> quicksilver: http://en.wikipedia.org/wiki/Han_unification#Rationale_and_controversy
06:27:05 <lambdabot> Title: Han unification - Wikipedia, the free encyclopedia, http://tinyurl.com/rkbx2
06:27:43 <Wild_Cat> kynky: maybe. Either way, it's interesting to learn. And if you already know (Python|Ruby), likely a better investment of your time than learning (Ruby|Python).
06:28:32 <daf> Ruby does illustrate that anonymous functions are a good thing
06:28:48 <kynky> every language has its place
06:29:35 <hugo__> kynky: seems people have been saying that since the 50's :P
06:30:30 <kynky> yeah but its knowing when to use the right tool for the right job
06:30:54 <quicksilver> Deewiant: interesting.
06:30:56 <kynky> you can do clever stuff in ruby, i like the meta programming etc
06:31:22 <DukeDave> Um, so I have this line:   import qualified Prelude ((+))
06:31:42 <DukeDave> But in ghci neither   Prelude.+  nor   Prelude.(+)  work :|
06:32:23 <DukeDave> Ooh (Prelude.+)
06:32:47 <quicksilver> > 1 Prelude.+ 3
06:32:48 <lambdabot>   4
06:33:07 <quicksilver> > map head Prelude.. words Prelude.$ "hi there"
06:33:09 <lambdabot>   "ht"
06:33:18 <quicksilver> horrific, isn't it?
06:34:10 <DukeDave> quicksilver: What just happened?   :)
06:34:43 <lilac> grown men cried?
06:34:43 <mmorrow> , let with x = [$js|function(k){return(k(@x))}|] in ppjs $ with (arrayLit . fmap toExpJ $ [0..5::Int])
06:34:46 <lunabot>  function (k)
06:34:46 <lunabot>  {
06:34:46 <lunabot>    return (k([0.0, 1.0, 2.0, 3.0, 4.0, 5.0]));
06:34:52 <mmorrow> }
06:35:26 <DukeDave> I'm just pleased with myself for this nasty: http://hpaste.org/12042
06:35:33 <mmorrow> lunabot needs a few more lines
06:36:40 <quicksilver> DukeDave: I showed how horrible "Prelude.." looks as an infix operator ;)
06:38:18 <DukeDave> quicksilver: Is there an explanation of that somewhere?
06:39:49 <quicksilver> DukeDave: I'm not sure there's an explanation. It just is waht it is.
06:39:51 <Wild_Cat> quicksilver: that's bloody atrocious indeed. Made even more confusing by the fact that ".." on its own is valid syntax, that means a wholly different thing.
06:40:04 <quicksilver> DukeDave: infix operators remain infix even when qualified.
06:40:13 <quicksilver> no matter how bizarre it looks ;)
06:40:23 <Deewiant> > [1 Prelude... 3]
06:40:24 <lambdabot>   Not in scope: `Prelude...'
06:40:26 <Deewiant> meh
06:40:36 <Deewiant> bloody builtins, they're no fun :-P
06:42:06 <mmorrow> , (ppjs . unExp) idj
06:42:08 <lunabot>  function (a)
06:42:08 <lunabot>  {
06:42:08 <lunabot>    return (a);
06:42:08 <lunabot>  }
06:42:12 * DukeDave has never even heard of ..
06:42:14 <mmorrow> , (ppjs . unExp) flipj
06:42:16 <lunabot>  luna: Couldn't match expected type `Language.Javascript.QQ.Syntax.Exp a'
06:42:21 <mmorrow> , (ppjs . unExp) flipj idj
06:42:23 <lunabot>  luna: Couldn't match expected type `t -> a'
06:42:24 <mmorrow> , (ppjs . unExp) $ flipj idj
06:42:27 <lunabot>  function (y)
06:42:27 <lunabot>  {
06:42:27 <lunabot>    return (function (x)
06:42:27 <lunabot>            {
06:42:27 <lunabot>              return (function (a)
06:42:27 <lunabot>                      {
06:42:33 <BeelsebobWork> o.O
06:42:36 <mmorrow> ...
06:42:49 <BeelsebobWork> lunabot: @nick spamabot
06:42:52 <mmorrow> there's a function to curry and uncurry n-levels as well
06:43:00 <mmorrow> Beelsebob: heh
06:45:20 <mmorrow> @type let rotate f = either (Right . f) (Left. f) in (rotate (rotate (rotate id)))
06:45:21 <lambdabot> forall a. Either (Either (Either a a) (Either a a)) (Either (Either a a) (Either a a)) -> Either (Either (Either a a) (Either a a)) (Either (Either a a) (Either a a))
06:45:31 <mmorrow> @djinn forall a. Either (Either (Either a a) (Either a a)) (Either (Either a a) (Either a a)) -> Either (Either (Either a a) (Either a a)) (Either (Either a a) (Either a a))
06:45:31 <lambdabot> f a = a
06:45:37 <mmorrow> haha
06:45:42 <BeelsebobWork> >.<
06:45:52 <mmorrow> @type let rotate f = either (Right . f) (Left. f) in \f -> (rotate (rotate (rotate f)))
06:45:53 <lambdabot> forall a b. (a -> b) -> Either (Either (Either a a) (Either a a)) (Either (Either a a) (Either a a)) -> Either (Either (Either b b) (Either b b)) (Either (Either b b) (Either b b))
06:46:03 <mmorrow> @djinn forall a b. (a -> b) -> Either (Either (Either a a) (Either a a)) (Either (Either a a) (Either a a)) -> Either (Either (Either b b) (Either b b)) (Either (Either b b) (Either b b))
06:46:03 <lambdabot> f a b =
06:46:03 <lambdabot>     case b of
06:46:03 <lambdabot>     Left c -> case c of
06:46:03 <lambdabot>               Left d -> case d of
06:46:03 <lambdabot>                         Left e -> Left (Left (Left (a e)))
06:46:05 <lambdabot>                         Right f -> Left (Left (Left (a f)))
06:46:07 <lambdabot>               Right g -> case g of
06:46:09 <lambdabot>                          Left h -> Left (Left (Left (a h)))
06:46:11 <lambdabot>                          Right i -> Left (Left (Left (a i)))
06:46:13 <lambdabot>     Right j -> case j of
06:46:15 <lambdabot>                Left k -> case k of
06:46:17 <lambdabot>                          Left l -> Left (Left (Left (a l)))
06:46:19 <lambdabot> Plugin `djinn' failed with: thread killed
06:46:21 <lilac> boo!
06:46:21 <BeelsebobWork> bad!
06:46:25 <BeelsebobWork> @pl let rotate f = either (Right . f) (Left. f) in (rotate (rotate (rotate id)))
06:46:26 <lambdabot> ap id (ap id ($ id)) (liftM2 either (Right .) Left.)
06:46:30 <mmorrow> lunabot a spamabot?
06:46:31 <BeelsebobWork> aww :(
06:46:33 <mmorrow> :)
06:47:13 <lilac> @djinn forall a b. (a -> b) -> (b -> a) -> Either (Either a b) (Either b a) -> Either (Either b a) (Either a b)
06:47:13 <lambdabot> f a b c =
06:47:13 <lambdabot>     case c of
06:47:13 <lambdabot>     Left d -> case d of
06:47:13 <lambdabot>               Left e -> Left (Left (a e))
06:47:13 <lambdabot>               Right f -> Left (Left (a (b f)))
06:47:15 <lambdabot>     Right g -> case g of
06:47:17 <lambdabot>                Left h -> Left (Left (a (b h)))
06:47:19 <lambdabot>                Right i -> Left (Left (a i))
06:47:24 <BeelsebobWork> @pl \a e h k l s -> h a s k e l l
06:47:25 <lambdabot> flip flip id . ((flip . ((flip . ((ap . (flip .) . flip) .)) .)) .) . flip . ((flip . (flip .) . flip) .) . flip id
06:47:38 <lilac> @unpl flip flip id . ((flip . ((flip . ((ap . (flip .) . flip) .)) .)) .) . flip . ((flip . (flip .) . flip) .) . flip id
06:47:38 <lambdabot> (\ as f j m -> (\ cl o p -> j as p m f cl o) >>= \ bg -> (\ g -> g) >>= \ bf -> return (bg bf))
06:47:43 <BeelsebobWork> hehe
06:48:00 <lilac> > (\ as f j m -> (\ cl o p -> j as p m f cl o) >>= \ bg -> (\ g -> g) >>= \ bf -> return (bg bf)) $ h a s k e l l
06:48:01 <lambdabot>       Overlapping instances for Show
06:48:01 <lambdabot>                                  (t
06:48:01 <lambdabot>     ...
06:52:38 <lilac> > (\ as f j m -> (\ cl o p -> j as p m f cl o) >>= \ bg -> (\ g -> g) >>= \ bf -> return (bg bf)) a e h k l s :: Expr
06:52:39 <lambdabot>   h a s k e l l
06:53:20 <twanvl> > [ id$di ..edulerP Prelude.. id$di ]
06:53:22 <lambdabot>   [1,2]
06:54:13 <RayNbow> :t di
06:54:14 <lambdabot> forall t. (Num t) => t
06:54:29 <RayNbow> :t edulerP
06:54:30 <lambdabot> forall a. (Enum a) => a -> a
06:55:20 <twanvl> using @let in a private message to lambdabot is great for confusing people :)
06:57:56 <RayNbow> twanvl: it is :P
06:58:10 <RayNbow> but I figured out :)
07:03:50 <thomashartman1> how do I get around the ghc-pkg bug in ghc 6.10.1? I get a supposedly helpful error message, but I still can't figure out what to do. cabal: ghc-pkg describe * failed. If you are using ghc-6.9 and have an empty
07:03:50 <thomashartman1> user package database then this is probably due to ghc bug #2201. The
07:03:51 <thomashartman1> workaround is to register at least one package in the user package db.
07:04:13 <dcoutts> thomashartman1: upgrade cabal-install
07:04:30 * earthy hugs const
07:04:43 <thomashartman1> via download from hackage and then runghc Setup.hs configure etc?
07:06:37 <Deewiant> a -> (g -> e -> u -> v -> w -> x -> y -> z) -> b -> c -> d -> (h -> l -> n -> c -> o -> u) -> e -> f -> g -> h -> i -> j -> k -> (s -> k -> m -> f -> y) -> l -> m -> (q -> g -> b -> i -> w) -> n -> o -> p -> q -> (d -> r -> v) -> (a -> j -> p -> t -> x) -> r -> s -> t -> z
07:06:38 <dcoutts> thomashartman1: yep, or use the bootstrap.sh in the cabal-install tarball
07:06:41 <Deewiant> ?djinn a -> (g -> e -> u -> v -> w -> x -> y -> z) -> b -> c -> d -> (h -> l -> n -> c -> o -> u) -> e -> f -> g -> h -> i -> j -> k -> (s -> k -> m -> f -> y) -> l -> m -> (q -> g -> b -> i -> w) -> n -> o -> p -> q -> (d -> r -> v) -> (a -> j -> p -> t -> x) -> r -> s -> t -> z
07:06:42 <lambdabot> f a b c d e f g h i j k l m n o p q r s t u v w x y z =
07:06:42 <lambdabot>     b i g (f j o r d s) (v e x) (q u i c k) (w a l t z) (n y m p h)
07:06:58 <Deewiant> yay for @djinn
07:07:27 <thomashartman1> ah, thanks for bootstrap.sh.
07:07:31 <mmorrow> , ppjs $ unExp constj
07:07:33 <lunabot>  function (x)
07:07:33 <lunabot>  {
07:07:33 <lunabot>    return (function (y)
07:07:33 <lunabot>            {
07:07:33 <lunabot>              return (x);
07:07:34 <lunabot>            });
07:07:41 <mmorrow> , ppjs $ (uncurryE . unExp) constj
07:07:44 <lunabot>  function (x, y)
07:07:44 <lunabot>  {
07:07:44 <lunabot>    return (x);
07:07:44 <lunabot>  }
07:07:50 <mmorrow> yay
07:08:03 <quicksilver> ;)
07:08:16 <quicksilver> yay but a little spammy ;)
07:08:19 <mmorrow> the functions are kind of disorganized at the moment
07:08:26 <mmorrow> yeah, no more spam from me :)
07:12:01 <RayNbow> > let f = (. sort) . mergeByR compare ((. (:)) . (.) . (:)) (:) (:) [] . sort in f [1,1,15,1,4,8,23,61] [3,4,1,9,61,56,34]
07:12:02 <lambdabot>   [1,1,1,1,3,4,4,8,9,15,23,34,56,61,61]
07:12:38 <mmorrow> @type mergeByR
07:12:39 <lambdabot> forall a1 a b. (a1 -> a -> Ordering) -> (a1 -> a -> b -> b) -> (a1 -> b -> b) -> (a -> b -> b) -> b -> [a1] -> [a] -> b
07:13:13 <RayNbow> @go mergeByR
07:13:26 <lambdabot> http://twan.home.fmf.nl/blog/haskell/generic-merge.details
07:13:26 <lambdabot> Title: A generic merge function - 21 thoughts
07:14:17 * mmorrow looks
07:30:29 <trie> I just installed ghc 6.8.2 on ubuntu using apt-get, trying to ghci gives "R_X86_64_32S relocation out of range:" (simiar to http://hackage.haskell.org/trac/ghc/ticket/2013, but that was FreeBSD specific I thought)
07:30:34 <lambdabot> Title: #2013 (ghci crash on startup: R_X86_64_32S relocation out of range.) - GHC - Tra ...
07:35:38 <savant> When using '!!', to get an element out of a list by index; does '!! removed from the list?
07:35:42 <savant> Erm.
07:36:01 <savant> When using '!!', to get an element out of a list by index; is the element removed from the list? or is it just echoed back to stdout?
07:36:09 <Beelsebob> savant: uh?
07:36:22 <Beelsebob> all !! does is returns the item at that list index
07:36:26 <Beelsebob> it doesn't mutate anything
07:36:29 <Beelsebob> it doesn't produce output
07:36:34 <Beelsebob> it's a pure function
07:36:51 <aeolist> it traverses the list up to that point yeah?
07:36:57 <savant> Beelsebob: what i mean is, for example: "Beelsebob" !! 4, would return 'e'.
07:36:58 <Beelsebob> yes
07:36:58 <Wild_Cat> aeolist: correct.
07:37:20 <Beelsebob> savant: 's' actually
07:37:21 <savant> So, what I'm trying to ask is, would the list/string be modified, say to 'Beelsbob'.
07:37:31 <Beelsebob> savant: I repeat -- it doesn't mutate anything
07:37:32 <savant> Beelsebob: Yeah, sorry.
07:37:42 <savant> Ah, good. Thanks.
07:37:47 <Beelsebob> it's a pure function
07:37:50 <Beelsebob> there are no side effects
07:38:00 <savant> Cool
07:39:45 <savant> My first jab at functional programming. :)
07:41:36 <Beelsebob> savant: the basic premise of functional programming is "it doesn't mutate anything"
07:41:50 <Beelsebob> if you find yourself asking "hey, does this mutate that", the answer is no
07:41:53 <kynky> no side effects
07:42:21 <flux> well, some people do make the distinction between "function" and "purely functional" programming. I do :)
07:42:33 <Beelsebob> what's the distinction?
07:42:40 <savant> Beelsebob: Ah, that's right. Nothing is liable to change.
07:42:43 <flux> that what you're talking about is about purely functional
07:42:52 <savant> Thanks for that, Beelsebob
07:42:53 <Wild_Cat> savant: basically, only things whose type is IO something can mutate stuff.
07:43:03 <Beelsebob> Wild_Cat: IO never mutates anything
07:43:08 <savant> Wild_Cat: Ah
07:43:12 <Wild_Cat> and by stuff, I mean the outside world.
07:43:26 <Beelsebob> IO may construct a value that instructs the runtime to mutate something
07:43:32 <Beelsebob> but it doesn't itself mutate anything
07:43:44 <flux> the other school of thought believes functional programming is merely using higher order functions and related techniques for making things happen - immutability goes along well with that, of course
07:43:47 <Wild_Cat> Beelsebob: that's being pedantic in the context of an explanation to a complete newbie, don't you think? ;)
07:43:49 <kynky> monads do their thing
07:44:10 <Beelsebob> Wild_Cat: in the context of explaining things to a complete newbie, nothing mutates anything
07:44:12 <Beelsebob> simple as that
07:44:37 <Wild_Cat> Beelsebob: except that the next question is usually "but if nothing mutates anything, how can I make my program do stuff?"
07:44:46 <kynky> monads
07:45:00 <Beelsebob> Wild_Cat: and the answer to that question is "you don't, you make your program be stuff instead"
07:45:03 <Wild_Cat> although to be fair, I took a semester of FP with Haskell at Leeds Uni, and we never even got as far as running a program.
07:45:27 <Wild_Cat> so a point could be made that the IO monad can be forgotten for quite a while when learning Haskell.
07:45:32 <kynky> did you get lots of hugs and leeds instead ?
07:45:34 <flux> wild_cat, wow
07:45:46 <hukolele> how can i get the transpose of a matrix, like List.transpose but getting the remainders too, when there is no column in one row but do in other rows
07:45:46 <kynky> *at leeds
07:45:52 <hukolele> > traspose [[[0,1],[0,2]],[[1],[],[0]]]
07:45:53 <lambdabot>   Not in scope: `traspose'
07:46:02 <hukolele> >transpose [[[0,1],[0,2]],[[1],[],[0]]]
07:46:03 <Wild_Cat> kynky: pretty much, yeah.
07:46:23 <hukolele> > transpose [[[0,1],[0,2]],[[1],[],[0]]]
07:46:24 <lambdabot>   [[[0,1],[1]],[[0,2],[]],[[0]]]
07:46:50 * kynky works in leeds , got my hugs done at bradford uni
07:46:51 <Wild_Cat> lots of hugs, and 90% of the class never even tried to submit answers for the last coursework assignment.
07:47:02 * Beelsebob went to York uni and got hugs there
07:47:29 <kynky> my lecturer wanted todo a book with me, but stupidly declined
07:47:56 <Wild_Cat> I heard they stopped teaching FP the year after I left :(
07:48:13 <kynky> well in hindsight that was bad
07:49:34 <kynky> a very key area now, with parallel programming and such , threads are virtually free in haskell too
07:50:09 <kynky> and erlang in getting traction, although i prefer haskell
07:50:34 * SamB wishes linux supported paths like //deadweight/video/ for accessing SMB shares :-(
07:50:48 <Wild_Cat> hai. With computers scaling in number of cores rather than frequency, auto-parallelization is getting big right now, and a language that does that instead of you is a huge productivity boost.
07:50:55 <kynky> it does, use fuse
07:51:05 <Wild_Cat> ('sides, it's about time we dropped C and C++ to write applications)
07:51:14 <quicksilver> SamB: you can make /samba a magic "automount" point and do something very like that.
07:51:19 <SamB> hmm
07:51:26 <SamB> is there a howto?
07:51:28 <Wild_Cat> SamB: smb://deadweight/video works, IIRC.
07:51:28 <quicksilver> /samba/deadweight/video will mount if necessary and then access.
07:51:37 <quicksilver> Wild_Cat: not in the shell it doesn't ;)
07:51:46 <Wild_Cat> quicksilver: ah, good point :D
07:51:56 <SamB> Wild_Cat: I want something that works with shell globbing :-P
07:52:22 <kynky> if u think its possible, it generally is, some times its simple, sometimes it requires writing it
07:52:45 <RayNbow> Wild_Cat: isn't auto-parallelization a bit limited?
07:52:48 <trie> Anyone running GHC on Ubuntu Hardy?
07:52:48 <SamB> see, it's a real pain in the neck to have to type out the names of the video files in full in order to watch them ... much nicer to just type a prefix and *
07:52:57 <quicksilver> SamB: try this : http://tldp.org/HOWTO/Automount.html
07:53:00 <lambdabot> Title: Automount mini-Howto
07:53:07 <quicksilver> SamB: it's horrendously old and I haven't proofread it
07:53:13 <quicksilver> at least it will help you find which terms to search for.
07:53:24 <quicksilver> we used to use this at university but I was never personally invovled in setting it up.
07:53:28 <Wild_Cat> RayNbow: it is, but IIRC ghc is making progress in that area. And it's much, much easier to implement in a pure language than in an impure one.
07:53:52 <savant> Christ, I should've learnt haskell as a first language; functional languages are _the_ way to go.
07:54:55 <_Dae_> savant: I think c is better if you really wanna use "go to"....
07:55:04 <RayNbow> Wild_Cat: it might be easier in a pure language, but how does GHC decide when to parallelize?
07:55:39 <Wild_Cat> RayNbow: I have no idea. You'll have to ask someone who actually knows what they're talking about :D
07:55:39 <RayNbow> i.e., how does it decide when it's worth parallelizing a piece of code?
07:55:39 <savant> _Dae_: goto statements? How did you come to that conclusion?
07:56:37 <_Dae_> savant: it was a very very poor joke based on the "functional languages are the way to go". You'll have to exscuse me, I'm very tired, and my sense of humor might not be up to par
07:57:28 <_Dae_> RayNbow:  Isn't it almost always worth paralising code in haskell?
07:58:06 <Wild_Cat> _Dae_: context switching is expensive.
07:58:26 <RayNbow> it's all about the amount of work that needs to be done
07:58:45 <RayNbow> if the amount of work is small, then it usually isn't worthwile to distribute the load on several cores
07:59:04 <kynky> and how far do you take your parallalization, surely should depend on number of cores :)
07:59:17 <_Dae_> well, obviously, but with haskells thread being lgihtweigth and all, isn't that less of a problem?
07:59:35 <Wild_Cat> at that point, if you can't parallelize everything because you don't have enough cores, you have to decide *what* to parallelize.
07:59:48 <kynky> a stratedgy , exactly
07:59:54 <_Dae_> kynky:  I insist that every single letterin "hello world" was generated in it's own thread......
08:00:26 <kynky> well good luck, with the concurrency
08:00:34 <kynky> :)
08:01:58 <mapreduce> It's normally worth leaving the decision about what to parallelise to someone who knows more than you, such as the ghc maintainers.
08:02:04 <kynky> with each thread located on a seperate physical computer, with computers distributed equally across sateilites orbiting the earth ?
08:02:36 <SamB> mapreduce: they offer such a service ?
08:02:47 <_Dae_> kynky:  why, no. I fully expect my computers to communicate via quantum entaglement......
08:02:49 <mapreduce> :t par
08:02:50 <lambdabot> forall a b. a -> b -> b
08:02:51 <Wild_Cat> sure, if you can pay them consulting rates.
08:02:58 <_Dae_> *entanglement.... bah I can't even spell
08:03:26 <kynky> :)
08:04:49 <Wild_Cat> @src par
08:04:49 <lambdabot> Source not found. I feel much better now.
08:06:55 <_Dae_> Wild_Cat:  I think par is hardcoded? I seem to remember looking for the source earlier....
08:07:13 <Wild_Cat> meh, it's not in ghci either.
08:08:43 <Wild_Cat> I can't figure that type signature out. I'd expected it to be (a -> b) -> (a -> b) or something in those lines.
08:09:39 <andun> i've installed the SDL package with cabal-install, but ghc --make helloworld.hs "Could not find module `SDL'". what am i missing?
08:10:31 <andun> ignore that. it was "Graphics.UI.SDL", not "SDL" :)
08:12:50 <MiniCow> So I'm trying to learn haskell (and FP in general). I've watched the 'Taste of Haskell' video by SPJ, and a couple of others. I now grok functions and composting them together, and currying, etc, but I can't make the leap to structuring a program. Any suggestions / examples I should look at?
08:13:38 <ksf> @where xmonad-design
08:13:38 <lambdabot> http://haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
08:13:50 <ksf> have a loot at that, it's more documentation than code.
08:14:22 <askentasken> MiniCow: make a spamfilter, thats what i did
08:14:49 <ksf> also, as for any other language, do an arcanoid.
08:15:19 <MiniCow> ksf: as in the bouncing ball game?
08:15:25 <ksf> yes.
08:16:21 <ksf> alongside with pong, the most basic game ever coded.
08:16:35 <MiniCow> ok. I'll take a look. I'm getting the feeling this is a common place to get stuck.
08:17:14 <ksf> well, other people do a raytracer, as such things more naturally map into functional style.
08:17:18 <Wild_Cat> ksf: Arkanoid is far from basic. You're thinking of Breakout, perhaps ;)
08:17:53 <MiniCow> Breakout was one of my first games I had back on the Apple ][
08:18:37 <ksf> I once did one with real vertex collision in x87 assembly.
08:19:42 <_qq> hello, just want to verify a few thoughts: the structure of an arrow some sort of a directed graph, right?
08:19:49 <lucca> 87?  heh
08:20:55 <ksf> x87 asm is beautiful. pure rpn.
08:21:29 <RayNbow> <ksf> alongside with pong, the most basic game ever coded. <-- 1D Tetris is more basic :p
08:21:44 <RayNbow> ( http://www.tetris1d.org/ )
08:22:09 <Deewiant> Depends on your definition of 'game' :-P
08:22:11 <MiniCow> ksf: thought you said x86 for a moment there.....
08:22:24 <Deewiant> I'd go with rock-paper-scissors or tic-tac-toe myself
08:33:48 <wchogg> @seen conal
08:33:49 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
08:38:28 <mauke> preflex: seen conal
08:38:28 <preflex>  conal was last seen on #haskell 21 hours, 17 minutes and 28 seconds ago, saying: (where the Data.Fun link should really be Data.Lambda)
08:39:25 <chylli> when I 'cabal build' something, I got an error said pacakge network  is hiden
08:39:38 <chylli> but I can see it by ghc-pkg
08:40:08 <chylli> how to solve it ?
08:40:52 <ToRA|MSR> is network in --user? if so you may need to tell cabal to build the package as a user package
08:41:02 <dcoutts> that's not it
08:41:14 <dcoutts> it's that the package doesn't say that it build-depends: network
08:41:17 * ToRA|MSR happily defers to the expert :)
08:41:39 <dcoutts> with cabal, all packages are hidden except for those listed in build-depends
08:42:26 <dcoutts> ToRA|MSR: for future reference, that's the solution if it complained at configure time about a package not existing that the user thought they just installed
08:42:54 <ToRA|MSR> dcoutts: nod
08:43:15 <dcoutts> for some reason people use cabal install foobar and then runghc Setup configure rather that just using cabal configure
08:43:33 <chylli> ToRA|MSR: not in user
08:43:40 <chylli> dcoutts: oh, thanks
08:44:08 <chylli> dcoutts: but the error message really mislead me
08:44:41 <Deewiant> dcoutts: maybe the error message could point out whether or not the package is installed?
08:44:59 <Deewiant> or is that a GHC problem
08:45:02 <dcoutts> Deewiant: which error message?
08:45:12 <dcoutts> Deewiant: the hidden package thing?
08:45:16 <Deewiant> yeah
08:45:23 <dcoutts> if it's hidden it's definitely installed :-)
08:45:37 <Deewiant> hmm, true :-)
08:45:46 <Deewiant> because otherwise it wouldn't even know what package to complain about
08:45:50 <dcoutts> the ultimate solution is for cabal to do the dep chasing
08:45:59 <dcoutts> then it knows what it's doing and can give sensible errors
08:46:13 <dcoutts> ghc doesn't know what cabal means so cannot give helpful errors
08:46:16 <Deewiant> hmm... might not even be /too/ hard
08:46:20 <dcoutts> cabal just tells ghc to hide all packages
08:46:23 <Deewiant> since .cabal already says what modules are exported
08:46:33 <Deewiant> or ghc-pkg
08:46:37 <dcoutts> Deewiant: but this is imports
08:47:01 <dcoutts> Deewiant: basically it's re-implementing ghc --make, but better
08:47:24 <Deewiant> just call ghc-pkg describe for everything in ghc-pkg list and you know the location of every installed module
08:47:35 <dcoutts> that's not the tricky bit unfortunately
08:47:52 <dcoutts> Deewiant: Saizan was working on this over the summer for his GSoC project
08:48:13 <Deewiant> What's so tricky about it?
08:48:38 <Deewiant> You know where the modules are -> you know what packages you want and since we already know the package dep graph that's it?
08:48:40 <dcoutts> Deewiant: tricky about re-implementing gnu make without the mistakes?
08:48:51 <Deewiant> I've semi-done it myself
08:49:30 <dcoutts> Deewiant: there are many semi-implementations, how far did you get?
08:50:19 <Deewiant> fully working as a haskell library, undocumented and not optimized enough
08:50:43 <jpcooper> hello
08:50:53 <lispy> This seems to be a wheel that gets reinvented a lot
08:50:58 <jpcooper> does anyone of how to fix haskell-mode to properly indent if-expressions?
08:51:05 <Deewiant> dcoutts: but in any case; this wasn't about reimplementing make, this is just about installing packages which cabal-install can already do :-)
08:51:05 <lispy> Cabal, hmake, franchise, Deewiant's code, etc.
08:51:18 <Deewiant> these are all different AFAIK
08:51:29 <conal> wchogg: hi
08:51:36 <Deewiant> mine is generic, like make, not intended to replace anything specific
08:51:41 <dcoutts> Deewiant: but in this example to give a proper error message we have to work out what all the imports are for all the modules in the package
08:52:15 <dcoutts> Deewiant: which means running all pre-processors to generate the .hs files and then parsing the top few lines to extract the import declarations
08:52:27 <dcoutts> then mapping those imports to package is straightforward
08:52:43 <Deewiant> Yep, that's the trickiest bit of the whole thing but I gather there's stuff like haskell-src and whatnot which can do it?
08:53:19 <dcoutts> yes there's some existing code, but the hard bit imho is running all the pre-processors
08:53:26 <dcoutts> as that comes back to building make again
08:53:34 <Deewiant> What are these pre-processors
08:53:35 <jpcooper> anyone?
08:54:08 <Deewiant> funny how I've never had any problems with if-expressions and I'm not even using haskell-mode :-P
08:54:13 <Deewiant> (Vim)
08:54:13 <dcoutts> Deewiant: eg c2hs, cpp. c2hs is almost as complex as ghc in terms of the dependencies and import chasing
08:54:25 <jpcooper> Deewiant, eww
08:54:42 <Deewiant> dcoutts: Well yeah, #includes are a problem :-/
08:55:15 <dcoutts> Deewiant: oh yes there's that in addition. I was just thinking of c2hs {# imports #}
08:55:21 <Deewiant> But I don't think it would be /that/ much work to get something which works for the 90% of code which doesn't use c2hs
08:55:36 <Deewiant> dcoutts: I don't know c2hs but I trust that it is complicated :-)
08:55:53 <dcoutts> Deewiant: perhaps, but then I don't think the payoff would be great either, without doing it properly
08:56:00 <mauke> http://www.youtube.com/watch?v=Mfr7xG6smhU
08:56:01 <lambdabot> Title: YouTube - Hard N Phirm - Pi
08:56:16 <dcoutts> Deewiant: for many reasons, cabal needs a proper build language, not just ghc --make
08:56:19 <Deewiant> dcoutts: Maybe.
08:58:49 <malcolmw> hmake does the cpp statically without running cpp, but it doesn't emulate any of the other possible preprocessors
08:59:41 <wchogg> conal:  Hey, so I'm kind of tying myself in knots trying to think about collision handling in Reactive.  What I'm _used_ to doing is having a notion of no collision, collision, and penetration.  When two objects are penetrating, you back rewind in time until they're just colliding and then continue the rest of the timestep.  That seems like an unfeasible way of looking at a problem in Reactive.
09:00:58 <conal> wchogg: sounds feasible to me.
09:02:31 <wchogg> conal:  But how do you "rewind" when you're dealing with Behaviors?
09:03:46 <conal> wchogg: i'd start by wondering what question has the answer "rewind".
09:05:39 <conal> wchogg: once the question is clear enough, i expect it'll be easy to answer in an elegant functional setting.
09:05:54 <gwern> conal: a time-travel game!
09:07:08 <wchogg> conal:  I think I'll ponder that koan a bit more, then.
09:07:30 <wagle> i need another set of words for "parents" and children in a dag for a node-centric dag
09:07:59 <Wild_Cat> I wonder what language Braid was implemented in.
09:08:11 <twanvl> wagle: what is wrong with "parents" and "children"?
09:08:13 <Wild_Cat> or what mechanics it uses under the hood.
09:08:47 <conal> wchogg: do!  i'd love to hear what bubbles up.
09:10:02 <wagle> twanvl, i want a generic dag class, but git inverts parents and children, and has pointers from each node (commit) to the parents..  so I'd be doing things like "set dag_children to git_parents"
09:11:57 <gwern> wagle: well, you could have a norbert class
09:12:21 <wagle> haha...  coparents and cochildren?
09:12:31 * wagle googles for norbert
09:12:49 * gwern remiscences about _Angry Beavers_
09:12:58 <twanvl> wagle: maybe "in-edge" and "out-edge"?
09:13:10 <Deewiant> hmm, haskell doesn't have dynamic scoping I suppose
09:13:49 <gwern> Deewiant: iirc, implicit parameters are kind of like dynamic scoping?
09:13:51 <Deewiant> implicit parameters being the closest thing
09:13:57 <Deewiant> yeah, but they're a bit too explicit for me :-P
09:14:41 <Deewiant> I really don't see much point in implicit parameters over ordinary parameters
09:15:00 <wagle> could do a dynamic scoping monad
09:15:23 <wagle> gwern, googling was unproductive..  whats a norbert class?
09:16:05 <gwern> wagle: in _Angry Beavers_, there are two characters, Dag and Norbert
09:16:15 <gwern> they both frequently act like gits to each other
09:16:24 <wagle> hahaha
09:20:03 <lispy> gwern: Dag or Dagit?
09:20:38 <lispy> gwern: my last name being what it is, I seem to recall someone telling me that one of the beavers was named Dagit...but maybe it's just Dag
09:21:20 <gwern> lispy: I think the full names were 'Norbert' and 'Dagwood'
09:21:26 <gwern> but I'm sure wikipediaknows
09:22:14 <gwern> 'Daggett (usually shortened to "Dagg") is the...' <-- dagnabbit
09:22:49 <lispy> heh, nice
09:23:32 <askentasken> Ambiguous type variable `t' in the constraints:
09:23:32 <askentasken>       `Random t'
09:23:32 <askentasken>         arising from a use of `_rand'
09:29:28 <askentasken> Ambiguous type variable `t' in the constraints:
09:29:28 <askentasken>       `Random t'
09:29:28 <askentasken>         arising from a use of `rand'
09:29:42 <dcoutts> malcolmw: I bet one could confuse it with come cunning cpp macros
09:29:52 <askentasken> what do id o?
09:29:56 <askentasken> rand seed = R.randomR (0,1) seed
09:30:19 <malcolmw> dcoutts: I challenge you to try :-)
09:32:07 <dcoutts> malcolmw: surely just pasting in an import using a macro that expands to "import Blah" would do?
09:32:33 <askentasken> typedonkish
09:32:43 <askentasken> help them haskell noobish
09:33:01 <dcoutts> malcolmw: or what about #ifdef nevertrue \n import Blah
09:33:22 <dcoutts> malcolmw: that'd pick up an extra import (which may be impossible to resolve)
09:33:36 <malcolmw> dcoutts: hmake uses parts of cpphs as a library internally, and I'm only aware of one highly obscure bug in cpp compatibility
09:33:52 <dcoutts> malcolmw: ah, so it really does run cpp, just as a lib function
09:34:04 <malcolmw> dcoutts: but you are right, it chooses not to do macro expansion outside # directives right now
09:34:57 <malcolmw> the second example is no problem: #ifdef nevertrue \n import Blah
09:35:16 <dcoutts> malcolmw: right
09:36:29 <dcoutts> malcolmw: and we could do the same if we found it was faster, by using cpphs as a lib rather than cpphs or cpp externally
09:36:38 <malcolmw> using cpphs as a library would be functionally equivalent to running a preprocessor externally I suppose, so maybe I should not have claimed as I did
09:37:15 <dcoutts> malcolmw: I assumed you were doing something more hacky :-)
09:37:32 <malcolmw> dcoutts: it used to  be a lot more hacky
09:38:15 <malcolmw> dcoutts: as the hmake interpretation of cpp directive became cleverer, I eventually pulled it out into the separate tool cpphs
09:38:32 <dcoutts> ah
09:42:44 <dons> enjoy, http://www.reddit.com/r/programming/comments/7deod/comparing_concurrent_linkedlist_implementations/
09:42:47 <lambdabot> Title: Comparing concurrent linked-list implementations in Haskell : programming, http://tinyurl.com/6638bh
09:44:09 <Nafai> How do you call a subprocess in Haskell and capture its output?
09:44:20 <dons> using System.Process
09:44:32 <gwern> 'with surprising difficulty', I sometimes think
09:44:57 <dons> no, its pretty easy. readProcess woot.
09:45:16 <dons> -- >  > readProcess "date" [] []
09:45:16 <dons> -- >  Right "Thu Feb  7 10:03:39 PST 2008\n"
09:46:21 <gwern> (which is the point at which some guru swoops in and says 'actually that's broken in 15 different ways thanks to sections x y and z of POSIX, and here's a more robust implementation of readProcess in only 20 lines. it'll break on AIX and Ultrix, but that's the price you pay' x_x)
09:46:22 <Nafai> dons: Awesome, thanks
09:46:32 <dons> readProcess looks a lot like my readProcess from new-popen, JaffaCake :)
09:46:56 <dons> except without the comment "Simon sez: use forkIO to start consuming output"
09:47:38 <gwern> hm. a potential lambdacat - a cat holding a fork in its mouth and saying that
09:47:46 <gwern> *captioning with that
09:48:23 <gwern> ...I need a verb which expresses the sense of a caption which we are intended to attribute to the depicted animal or entity, regardless of the feasibility of them talking
09:52:48 <gwern> http://flickr.com/photos/cityhunter12/479088534/ 'Simon cat sez: try forkIO?'
09:52:49 <lambdabot> Title: the cat and fork on Flickr - Photo Sharing!
09:53:15 <ziman> :)
09:53:18 <gwern> http://flickr.com/photos/wildgoosechase/2084473609/ 'Simon cat sez: moar forkIO!'
09:53:19 <lambdabot> Title: what the fork? on Flickr - Photo Sharing!
09:53:19 * allbery_b thinks he's become a bit predictable
09:53:48 <gwern> hm, the first is CC, but ND NC
09:53:50 <gwern> so useless
09:55:06 <gwern> http://flickr.com/photos/absoblogginlutely/2408427786/ <-- CC-NC, possible
09:55:07 <lambdabot> Title: Melon for Basil on Flickr - Photo Sharing!
09:55:18 <gwern> anyone have a good caption for that one?
09:58:03 <gwern> http://flickr.com/photos/geckoam/2956778600/ 'UnsafeperformKitteh says: 'u knows u wants to''
09:58:04 <lambdabot> Title: Prissy Devil on Flickr - Photo Sharing!
09:59:31 <gwern> http://flickr.com/photos/prisstina/1769412572/ <-- no comment
09:59:31 <lambdabot> Title: Pug, Cat, & Fork on Flickr - Photo Sharing!
09:59:46 <gwern> hm. 'forking - not just for computers'
10:00:56 <shepheb> "imperative cat is not thread-safe" on a cat that's just torn some fabric apart
10:03:07 <gwern> http://flickr.com/photos/worldofoddy/293328476/ ?
10:03:08 <lambdabot> Title: Shredded Cat on Flickr - Photo Sharing!
10:03:39 <gwern> http://flickr.com/photos/chien/52684754/ aww
10:03:40 <lambdabot> Title: Daffy in sea of shredded paper on Flickr - Photo Sharing!
10:04:04 <ziman> spaghetti cat!
10:04:18 <gwern> 'spaghetti kitteh likes your code'
10:04:33 <BMeph> In a functional world, students would ask how that index shadowing works in those funny 'for' statements...
10:05:12 <gwern> http://flickr.com/photos/srhbth/531753040/ <-- darn already captioned
10:05:14 <lambdabot> Title: lololly on Flickr - Photo Sharing!
10:05:15 <Saizan> @remember BMeph In a functional world, students would ask how that index shadowing works in those funny 'for' statements...
10:05:15 <lambdabot> I will remember.
10:06:22 <gwern> http://flickr.com/photos/dormousie/364681269/ <-- destructive update kitteh?
10:06:23 <lambdabot> Title: Clive in the Shred Box on Flickr - Photo Sharing!
10:07:56 <Peaker> conal: hey, you there?
10:08:51 <Peaker> I am wondering why the mouseMotion and other behaviors have to be within a (UI->) reader. Why isn't there just a "global mousePosition"?
10:09:07 <gwern> shepheb: http://flickr.com/photos/funtik/988486666/ ?
10:09:08 <lambdabot> Title: Get off of my fabric,can`t you see, i`m sewing... on Flickr - Photo Sharing!
10:10:21 <gwern> http://flickr.com/photos/rvoodoo/198320659/ <-- spooky. this pair of cats looks almost identical to my pair of cats
10:10:21 <lambdabot> Title: Cats Eatin Fabric on Flickr - Photo Sharing!
10:10:49 <hackage> Uploaded to hackage: colour 2.0.0
10:12:45 <Kutschfo> Hi there
10:22:26 <conal> Peaker: now i am
10:22:49 <Peaker> conal: why do the various functions live in the (UI->) reader?  Why can't mouseMotion be just a Behavior?
10:23:12 <conal> Peaker: great question.
10:23:54 <askentasken> rand seed = R.randomR (0,1) seed
10:23:58 <askentasken> Ambiguous type variable `t' in the constraints:
10:24:03 <askentasken>       `Random t'
10:24:06 <askentasken>         arising from a use of `rand'
10:24:25 <askentasken> ??????
10:24:34 <conal> Peaker: why can't getChar have type Char?
10:24:45 <Peaker> conal: because it has to describe the side effect, as well
10:25:50 <Peaker> conal: Perhaps you could have: a UIBehavior = ReaderT UI Behavior, for example?
10:26:10 <conal> Peaker: yeah.  in other words, because the semantics of the Char type isn't complicated enough to give meaning to getChar.
10:26:20 <Deewiant> askentasken: I think the problem is where you use rand, not in that definition
10:26:53 <Peaker> conal: What about a (ReaderT UI Behavior) type?
10:26:57 <conal> Peaker: yes, one could define and use UIBehavior in that way.  it wouldn't be as simple/general/composable as Behavior
10:27:00 <Peaker> conal: (so its only singly-boxed, and not doubly-boxed)
10:27:11 <conal> Peaker: what about that type?
10:27:12 <leimy> looks like dons ircbot.hs example showing Reader doesn't build with 6.10
10:27:46 <Peaker> conal: what's contained in the UI values?
10:27:52 <Peaker> conal: that mouseMotion requires?
10:29:26 <askentasken> and i do what qith random?
10:29:28 <SamB> wow ... this book I'm reading has no "fl" ligatures! nasty!
10:29:38 <conal> Peaker: the UI (in reactive-glut) is just a record containing a few event- and behavior-valued fields
10:29:50 <conal> Peaker: mouseMotion is a field accessor
10:29:55 <leimy> oh I see why
10:30:00 <leimy> he hid the wrong "catch" :-)
10:30:02 <Peaker> conal: ah, ok.
10:30:05 <leimy> wanting the prelude version
10:30:26 <conal> Peaker: btw, i'm working on a more conveniently composable (and time-space-safe) layer.
10:30:29 <Peaker> conal: I guess the Reader instance makes "unpacking" the (UI->) real easy in practice
10:30:47 <conal> Peaker: yeah.  so does the reader Applicative.
10:30:48 <SamB> or aren't there supposed to be fl ligatures ?
10:30:58 <Peaker> conal: yeah the reader instance of functor/applicative/monad
10:31:12 <Peaker> conal: btw: How can I convert a 2d window coordinate to a 3d coordinate at a certain depth (perspective-wise)?
10:31:13 <conal> Peaker: i mean the other, simpler reader applicative.
10:31:56 <conal> Peaker: do you know about the simpler reader & writer applicatives?
10:32:09 <askentasken> i need a random number from 0 1 or 2
10:32:32 <Peaker> conal: nope, what's the difference between <*> of those and "ap" of the Reader Monad?
10:32:50 <pk_> you can use randomR (0,2) g
10:32:59 <conal> Peaker: there are two reader monads and two reader monad transformers.
10:33:02 <conal> ditto for writers
10:33:10 <pk_> with a g a random gen
10:33:10 <conal> and ditto for functor & applicative.
10:33:41 <Saizan> leimy: rather, import Control.OldException instead
10:33:44 <Peaker> conal: what meaningful reader functor can there be other than fmap = (.) ?
10:33:56 <leimy> Saizan: hmmm
10:34:11 <leimy> ok interesting.
10:34:24 <leimy> I just used Prelude's catch
10:34:26 <conal> Peaker: that's fmap for the simple reader.  is that the one you meant?
10:34:27 <leimy> seems to work ok
10:34:39 <Peaker> conal: yeah
10:34:41 <Peaker> conal: what else is there?
10:34:49 <conal> Peaker: the one in mtl
10:34:59 <Peaker> conal: oh, of the monad transformer
10:35:08 <Saizan> leimy: the Prelude one won't catch all the exceptions
10:35:12 <Peaker> conal: I was referring to the simple reader all the time, yeah
10:35:14 <conal> Peaker: no.  the Reader and ReaderT
10:35:16 <askentasken> what is g?
10:35:19 <leimy> Saizan: yeah... hmmm
10:35:21 <leimy> ok
10:35:22 <leimy> giving it a shot
10:35:25 <conal> Peaker: i'm already using the simple reader.
10:35:37 <conal> Peaker: so i thought you were suggesting the other one.
10:36:24 <conal> Peaker: oops -- i guess a misunderstanding from the start.
10:36:40 <Peaker> conal: you were talking about a layer to prevent time-space problems?
10:37:04 <conal> Peaker: yeah.  and improve convenience.
10:38:25 <Peaker> conal: sounds cool. did you see my new tickets btw?
10:39:23 <Peaker> doh, gotta go
10:40:47 <conal> Peaker: i'll look.  thx.  gotta find out how to turn on email notify for tickets.
10:49:59 <askentasken> dd an instance declaration for (Num (IO t), R.Random (IO t))
10:49:59 <askentasken>     In a stmt of a 'do' expression: r <- rand seed
10:50:02 <askentasken> how?
10:50:14 <askentasken> In a stmt of a 'do' expression: r <- rand seed
10:50:53 <dons> 10:50  lambdabot> uptime: 4m 15d 1h 50m 28s
10:52:04 <Cale> askentasken: What's the type of rand
10:52:05 <Cale> ?
10:53:08 <Cale> askentasken: It looks like an action is being used as its result somewhere.
10:53:44 <dons> nice, dcoutts , http://www.reddit.com/r/programming/comments/7dff0/bustle_a_dbus_activity_charting_tool_using_cairo/
10:53:47 <lambdabot> Title: Bustle: a D-Bus activity charting tool using Cairo and Haskell : programming, http://tinyurl.com/5wban2
10:53:49 <dons> using haskell only for the gui ease :)
10:53:53 <dcoutts> :-)
10:54:05 <dcoutts> he should be using the dbus bindings too of course
10:54:36 <dcoutts> pretty pics though
10:55:26 <conal> the anygma folks are discussing open source licensing decisions.  i'd like them to make choice good for their business and good for th haskell community.  is there a page on the haskell wiki in which people discuss their preferences, fairly objectively?
10:56:02 <dons> mm
10:56:16 <dons> i don't think so, conal.
10:56:27 <dons> you could look at what other companies do.
10:56:36 <dons> e.g. galois uses a BSD license to release non-core IP.
10:56:41 <dcoutts> conal: it really depends on what their objectives are
10:56:46 <dons> in our view, increasing the use of haskell in whatever form benefits us.
10:57:03 <wjt> dons: well, i didn't *just* use Haskell for the GUI ease
10:57:33 <askentasken> http://hpaste.org/12047
10:57:33 <askentasken> Cale ^^
10:58:23 <askentasken> and could i pattern match for equality? like:  result casex == casey = Tie ?
10:58:32 <dons> wjt: i think you could ask for help cabalising it.
10:58:39 <dons> i think getting it on hackage will be key to adoption.
10:58:52 <dcoutts> conal: the obvious choices are BSD, LGPL, GPL
10:59:01 <conal> dons: does galois ever use a more restrictive but open license, say to allow non-commerical or somehow-non-competing uses.
10:59:22 <dons> Sometimes with customers.
10:59:24 <conal> dcoutts: Beelsebob has also mentioned MIT
10:59:33 <dcoutts> conal: LGPL or GPL would have that effect and so is often picked for just that reason
10:59:33 <dons> conal: so that customers can't compete in particular spaces.
11:00:00 <dcoutts> conal: to differing degrees obviously, GPL is stronger
11:00:24 <Cale> askentasken: oh!
11:00:33 <Cale> askentasken: rand seed is not an IO action
11:00:40 <Cale> askentasken: So you can't run it with <-
11:00:49 <Cale> askentasken: What you want is  let r = rand seed
11:00:49 <dcoutts> conal: GPL would prevent competitors from using it in closed-source projects
11:01:08 <dons> conal: but rarely do we find people start competiting with us using our haskell code
11:01:13 <askentasken> Cale: Ambiguous type variable `t' in the constraints:
11:01:13 <askentasken>       `Num t'
11:01:13 <askentasken>         arising from a use of `rand'
11:01:15 <Cale> (I can see you have that there in a comment)
11:01:43 <Cale> ah, that means that it can't decide what type of value r is going to be (and hence what instance of the random generation stuff to use)
11:01:44 <vixey> I hought you can use GPL code in closed source programs
11:01:46 <conal> i wonder what impact a GPL or LGPL would have on people wanting to contribute
11:01:47 <vixey> ?
11:01:57 <Cale> askentasken: Adding a type signature should help.
11:01:59 <vixey> You just don't give binaries to people
11:02:19 <Cale> askentasken: for example:   rand :: StdGen -> Integer
11:02:22 <dcoutts> vixey: yes, if it's never distributed to anyone then that's fine
11:02:27 <askentasken> how? i never got how to figure themout for myself :)
11:02:48 <Cale> Or just use r in some way which determines its type.
11:03:07 <dcoutts> conal: it's unlikely to have much effect on non-commercial contributors
11:03:29 <gwern> conal: for obscure stuff, GPL only hurts you
11:03:46 <dcoutts> gwern: depends on what your goals are
11:03:49 <conal> gwern: because competition is unlikely?
11:04:04 <gwern> consider that GPL folks don't care if it's GPL or BSD, since if it's GPL they're fine, and if it's bSD, they can always turn it into GPL
11:04:12 <gwern> but the situation is not symmetrical for BSD folks
11:04:25 <Cale> askentasken: What you really want is not a random integer, but a random Choices value no?
11:04:45 <gwern> thus, the only situation in which choosing GPL can equal or dominate the payoffs for choosing BSD is when all contributors prefer ro don't care about GPL
11:04:53 <dcoutts> but it may be exactly those folks that you don't want to share with, since they are not interested in sharing too
11:04:54 <Cale> d'oh.
11:04:57 <gwern> haskell software is not in that situation
11:05:26 <gwern> dcoutts: srsly, who in the haskell community is really going to close-source a FRP lib?
11:05:42 <dcoutts> gwern: perhaps someone not in the haskell community
11:05:43 <gwern> it's like, not even a possibility
11:06:07 <gwern> I can't think of a single haskell library or program - most of which are BSD, mind - which has been closed
11:06:21 <dcoutts> gwern: would you know? :-)
11:06:22 <gwern> GPL's protection is for us either nugatory or negative in effect
11:06:42 <gwern> dcoutts: arguing from silence eh...
11:06:52 <conal> gwern: by "closed", do you mean a closed-source fork?
11:06:57 <gwern> yes
11:07:01 <conal> k
11:07:24 <gwern> (leaving aside the issue that a closed-source fork may not even be damaging to the original, which only reinforces my point that for haskellers BSD is better)
11:07:50 <gwern> just set up a payoff grid, and it's clear
11:07:54 <dcoutts> I'm not arguing anything except that the licence you should choose depends on what you're trying to do, there are niches for BSD, LGPL and GPL
11:08:28 <askentasken> Cale: thanks
11:08:28 <conal> dcoutts: do have any pointers/advice about those niches?  maybe some would apply to some anygma components and others to others.
11:08:44 <askentasken> anyway, can i oatternmatch for euqality or i ahve to do explicit tests?
11:08:48 <Cale> askentasken: One way to go about this is to write an instance of Random for Choices
11:08:53 <askentasken> like i can do _ _ for any
11:09:04 <dcoutts> conal: there are good discussions of all those licenses elsewhere on the internet, almost all of it applies to Haskell (except some details of dynamic linking)
11:09:13 <askentasken> can i do _ == _
11:09:19 <conal> dcoutts: kthx.
11:10:11 <gwern> askentasken: I don't think so
11:10:17 <gwern> _ is only usable in pattern matching
11:10:24 <gwern> you can't ahve it really in an expression
11:10:30 <Cale> askentasken: What you have there is reasonably sensible, but choose would be provided for you if you add Enum to the list of classes to derive.
11:10:39 <Cale> askentasken: it would be toEnum then.
11:10:44 <Cale> :t toEnum
11:10:45 <lambdabot> forall a. (Enum a) => Int -> a
11:10:46 <gwern> and if you just mean 'foo a = a == a', then just write 'foo _ = True' or something
11:10:49 <hackage> Uploaded to hackage: peano-inf 0.4
11:10:59 <Cale> askentasken: You'd also get fromEnum for free
11:11:02 <Cale> :t fromEnum
11:11:03 <lambdabot> forall a. (Enum a) => a -> Int
11:12:07 <Cale> Another way to handle Win/Lose/Tie would be to make a table of the results, and use the fromEnum's of the values to index into the table.
11:15:17 <askentasken> table?
11:16:00 <thoughtpolice> uh-oh: http://willthompson.co.uk/cgi-bin/unicloud
11:16:08 <Cale> Well, a list of lists, say.
11:16:19 <Cale> (the lists are short, indexing doesn't cost so much)
11:16:32 <Cale> resultTable = [[Tie,  Win,  Lose],
11:16:32 <Cale>                [Lose, Tie,  Win ],
11:16:32 <Cale>                [Win,  Lose, Tie ]]
11:16:37 <Cale> result :: Choices -> Choices -> Result
11:16:37 <Cale> result x y = resultTable !! fromEnum x !! fromEnum y
11:16:38 <wjt> thoughtpolice: yeah, that one is inferior to my previous Perl implementation because the unicode-names library is missing some names
11:16:44 <Cale> Something like that
11:17:04 <thoughtpolice> wjt: hehe, that's a nice 500 err msg though :]
11:18:05 <wjt> thoughtpolice: there's a 500 error?
11:18:28 <thoughtpolice> wjt: hm.. i just got a internal server 500 err with the msg "Prelude: (!!) index too large"
11:18:30 <wjt> oh heh, index too large <_>
11:18:33 <thoughtpolice> now it does work
11:18:33 <thoughtpolice> yeah
11:18:54 <wjt> i should probably fix that.
11:19:27 <wjt> huh.  i can't get at it with any old large number
11:20:23 <Cale> askentasken: Another way to go about it is to realise that the structure of the outputs for result looks exactly like a subtraction table modulo 3.
11:21:33 <Cale> askentasken: http://hpaste.org/12047#a1
11:22:09 <Cale> askentasken: But you have to be rather careful about the order you give the options in the data declaration, because that determines the Enum instance.
11:25:44 <askentasken> i see
11:26:09 <ibid> http://www.flickr.com/photos/ioerror/3014911710/
11:26:10 <lambdabot> Title: I'm actually Knuth's homeboy on Flickr - Photo Sharing!
11:27:23 <askentasken> http://hpaste.org/12048
11:27:45 <askentasken> but why do i need to enum result? it seemed to wrok without doing it
11:28:37 <Cale> askentasken: You don't need the Enum instance for Result if you're going with the table method.
11:29:10 <Cale> askentasken: Your 'choose' function is essentially the same as toEnum
11:29:27 <Cale> and strToType is what 'read' would do if you were deriving an instance of that.
11:29:54 <Cale> http://hpaste.org/12047#a2
11:30:27 <Cale> There's a Random instance for Choice, so that you can use random/randomR/randomIO etc. to generate Choice values.
11:30:45 <telexicon> is there a shortcut to take a [Maybe a] and filter it to [a] (drop all Nothing)
11:30:51 <askentasken> how do i use read after i derived it with Choice?
11:31:02 <idnar> > catMaybes [Just 5, Nothing, Just 6]
11:31:03 <lambdabot>   [5,6]
11:31:04 <mauke> telexicon: catMaybes
11:31:06 <vixey> shortcut??
11:31:08 <telexicon> mauke, thanks
11:31:13 <mauke> @hoogle [Maybe a] -> [a]
11:31:13 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:31:13 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
11:31:13 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:31:18 <telexicon> yeah like.. a higher level function you know
11:31:27 <telexicon> instead of reimplementing it myself
11:31:43 <telexicon> cause right now i have (map fromJust).(filter isJust)
11:31:52 <mauke> use the hoogle
11:31:53 <telexicon> but i thought, lets refactor and use something from the library that already exists
11:31:59 <telexicon> mauke, i can search by type?
11:32:03 <mauke> yes
11:32:03 <telexicon> thats pretty awesome
11:32:09 <telexicon> in fact, thats beyond awesome
11:32:12 <Cale> er, oops, there's a bug in that ;)
11:32:12 <telexicon> mauke, thanks <3
11:32:14 <mauke> http://www.haskell.org/hoogle/
11:32:15 <lambdabot> Title: Hoogle
11:32:35 <Cale>     random g = let (r,g') = randomR (0,2) g
11:32:35 <Cale>                in (toEnum r, g')
11:32:49 <idnar> @scr catMaybes
11:32:49 <lambdabot> Maybe you meant: arr rc src
11:32:55 <idnar> @src catMaybes
11:32:55 <lambdabot> catMaybes ls = [x | Just x <- ls]
11:33:01 <idnar> @help arr
11:33:01 <lambdabot> arr. Talk to a pirate
11:33:04 <idnar> haha
11:33:04 <Cale> askentasken: http://hpaste.org/12047#a3
11:33:36 <Cale> askentasken: Of course, have to ensure that the Int we're passing to toEnum is in range.
11:34:31 <Cale> askentasken: You can use readLn to combine 'read' with 'getLine'
11:34:46 <Cale> askentasken: Which will save even more code :)
11:34:58 <RayNbow> @index readLn
11:34:58 <lambdabot> System.IO, Prelude
11:35:36 <EmielRegis> if a have a custom data type in return type of object, how can I return something along C NULL>?
11:36:05 <Cale> EmielRegis: sorry, what?
11:36:15 <EmielRegis> im writing a raytracer
11:36:20 <Cale> EmielRegis: okay...
11:36:22 <EmielRegis> and for certain misses
11:36:26 <EmielRegis> I want to return a tupple
11:36:30 <telexicon> mauke, thank you very much :]
11:36:35 <EmielRegis> of Int and custom data type
11:36:36 <askentasken>   Ambiguous type variable `a' in the constraints:
11:36:36 <askentasken>       `Read a'
11:36:36 <askentasken>         arising from a use of `readLn'
11:36:42 <EmielRegis> I would like to return (MISS, NULL)
11:36:45 <EmielRegis> something like that
11:36:52 <EmielRegis> how to construct a dummy object then?
11:36:53 <Cale> askentasken: Use the thing that you read.
11:37:08 <mauke> EmielRegis: return something of type (Int, Maybe YourType)
11:37:09 <vixey> EmielRegis, Nothing vs Just <value>
11:37:14 <mauke> then you can use Nothing
11:37:19 <EmielRegis> ah ok
11:37:20 <EmielRegis> danke
11:37:25 <Cale> EmielRegis: Either use Maybe, or add a constructor to your custom type which expresses failure.
11:37:47 <Cale> main = do choice <- readLn
11:37:47 <Cale>           choice' <- randomIO
11:37:47 <Cale>           print (result choice choice')
11:37:55 <Cale> askentasken: something like that ^^
11:38:04 <wjt> Applicative + Parsec = success
11:38:30 * wjt shaves off 1/3 of the code of his parser
11:45:01 <Cale> askentasken: If you want to get fancy, that's the same as  main = print =<< liftM2 result readLn randomIO, or using the Control.Applicative stuff, main = print =<< result <$> readLn <*> randomIO :)
11:45:08 <thoughtpolice> wjt: indeed, I like using parsec + applicative sometimes
11:45:12 <thoughtpolice> writing parsers that way is fun
11:46:45 <Cale> Oh, he's not here.
11:47:03 <Cale> His connection seems to be flaking out...
11:48:06 <wjt> thoughtpolice: This file is tab-separated so I wound up writing FooBar <$> parseFoo <* tab <*> parseBar <* tab <*> parseBaz  ; can you think of a better way to deal with that?
11:48:08 <jkr> Haha, noone talked to b_jonas in some time \o/
11:49:25 <thoughtpolice> wjt: hm, that seems like the adequate balance between succinct and clear if you ask me :]
11:49:33 <jkr> It's not that I don't like him
11:49:49 <jkr> I just get a lighlight every time someone says b_jonas: something :)
11:54:28 <Cale> conal: Interesting post regarding folds and typeclass morphisms.
11:55:48 <matthew-_> haskell.org failing again
11:56:34 <mauke> http://downforeveryoneorjustme.com/haskell.org
11:56:40 <lambdabot> Title: Huh?
11:56:58 <mauke> grr
11:57:12 <conal> Cale: :)
11:57:48 <Cale> conal: It seems to me that the language of the future should be more aware of this sort of thing. :)
11:59:41 <Cale> conal: In mathematics, basically the first thing you always do when you have a new structure is to ask what the structure-preserving transformations are (to turn it into a category). But I think we're just starting to see the benefits of that perspective for programming.
12:00:49 <mfwitten> Hello again. Could someone take a look at the following and tell me if this is the `right way': http://hpaste.org/12049
12:00:50 <mfwitten> Thanks
12:01:17 <mauke> looks reasonable enough
12:01:21 <mfwitten> ok
12:01:26 <mauke> you can replace unused function parameters by _
12:01:30 <mfwitten> ah
12:01:32 <Cale> mfwitten: Unfortunately, yes. The datatype itself is awkward to use :)
12:02:57 <Cale> mfwitten: If you wanted to improve the definitions further, you'd probably need to use generics.
12:03:03 <mfwitten> ok
12:03:09 <mfwitten> I suppose that's what I was after
12:03:53 <Cale> hmm... I should give that a shot and see how it goes :)
12:04:10 <mfwitten> mauke, Cale: Thanks!
12:04:27 <Cale> no problem :)
12:04:39 <Saizan> ?type listToMaybe . listify
12:04:39 <lambdabot>     Couldn't match expected type `[a]'
12:04:39 <lambdabot>            against inferred type `a1 -> [r]'
12:04:39 <lambdabot>       Expected type: (r -> Bool) -> [a]
12:04:48 <Saizan> ?type listify
12:04:49 <lambdabot> forall r a. (Typeable r, Data a) => (r -> Bool) -> a -> [r]
12:05:09 <Saizan> ?type listToMaybe . listify (const True)
12:05:10 <lambdabot> forall a a1. (Typeable a, Data a1) => a1 -> Maybe a
12:05:26 <vixey> I got a way thath doesn't use generics
12:05:42 <vixey> tuple1 = fst
12:05:47 <vixey> tuple2 = fst . snd
12:05:49 <vixey> tuple3 = fst . snd . snd
12:05:51 <vixey> etc
12:06:14 <Cale> vixey: er...
12:06:25 <Cale> vixey: Which works with the Tuple type as described?
12:06:40 <Cale> vixey: Obviously that's the tricky bit ;)
12:06:47 <vixey> I don't pass this haskell class :p
12:07:05 <Saizan> this is a yaht exercise, btw
12:07:44 <monochrom> No one passes it except computers.
12:08:09 <monochrom> Its exercises are such tedious chore that only computers would bother.
12:08:56 <monochrom> "here is a data type with 20 cases, make it a monad"
12:09:02 <Cale> haha
12:09:29 <vixey> I get interested in typed polytypic programming
12:09:30 <vixey> :(
12:09:35 <vixey> nobody does this
12:10:15 <Cale> Hmm, is this approachable with syb?
12:10:50 <hackage> Uploaded to hackage: peano-inf 0.5
12:11:42 <Saizan> Cale: something tuple1 = listToMaybe . listify (const True) :: Tuple a b c d -> (Maybe a) should work
12:11:59 <Saizan> uhm
12:12:15 <vixey> (a,Maybe(b,Maybe(c,Maybe d)))
12:12:16 <Saizan> not if you instance multiple fields with the same type
12:12:54 <ziman> any recommendations for debian haskell repos? i can't google one except unsafeHaskell (to my surprise).
12:13:51 <Cale> ziman: Let me know if you find anything ubuntu-compatible. Personally, I just download a binary GHC, and then cabal-install.
12:13:52 <Saizan> there aren't recent debian packages afaik
12:14:22 <thoughtpolice> cabal install is the way to go if you're going to be writing code, fwiw
12:15:08 <Cale> I wonder if there's a reasonable way that cabal install could be integrated with the system package manager, so that things installed using it would show up as packages and be uninstallable.
12:15:10 <Cale> hmm
12:15:22 <ziman> okay, thanks
12:15:59 <Cale> vixey: Yeah, that type looks like a much saner alternative.
12:16:09 <thoughtpolice> as dons constantly points out with his lightning fast archlinux-repo updating speeds, most haskell library support using system package managers is pathetic it seems for most linux distros.
12:16:14 <vixey> oh
12:17:28 <dcoutts> Cale: an easier approach is automatically generating system packages from cabal packages. That's what tools like cabal2rpm do.
12:17:38 <thoughtpolice> sure, arch has like 600+ haskell packages, what's the next runner up? nothing above like 30 i would think. cabal install is the way to go for sure if you're writing code, plus you can't trust package managers to not interfere and make decisions you don't want.
12:18:27 <Cale> dcoutts: Yeah, that seems more likely :)
12:18:27 <vegai> thoughtpolice: we actually talked about this just a minute ago :)
12:18:53 <vegai> with dons on another channel...
12:18:56 <conal> has anyone here set up trac notifications before?  i want to do so for my code.haskell.org projects.
12:19:11 <Saizan> seeing the packages produced by cabal2arch it would be easy to make cabal-install make the dependency resolving and then installing the packages with arch's package manager
12:19:39 <thoughtpolice> vegai: yeah, cabal install ftw :]
12:20:20 <dons> the key is to ensure an efficient bridge between cabal and the native package system
12:20:30 <dons> since we absolutely do need to continue distributing binaries.
12:20:53 <dons> arch works because we have such a correspondance: there's a mapping from .cabal to native format packages that is automated.
12:21:10 <dons> (there's more haskell libs in arch than python libs.. :)
12:21:46 <Saizan> is there a repo with binaries for arch's haskell packages?
12:22:32 <dons> there has been in the past, but we've not yet got tools to keep it synchronised as pieces of the dependency graph change
12:22:37 <dons> until then, its moth balled.
12:23:16 <jkr> Is there something like WWW::Mechanize for Haskell?
12:24:11 <geezusfreeek> what is WWW::Mechanize?
12:24:37 <trofi> :t Q
12:24:38 <lambdabot> Not in scope: data constructor `Q'
12:24:52 <dons> jkr: just guessing, but http://hackage.haskell.org/cgi-bin/hackage-scripts/package/download-curl ?
12:24:54 <jkr> It's something like a browser/crawler/bot.
12:24:58 <lambdabot> Title: HackageDB: download-curl-0.1.1, http://tinyurl.com/54bv5d
12:25:01 <dons> oh. crawler. mm
12:25:08 <geezusfreeek> something like tagsoup maybe?
12:25:13 <jkr> Well, not really a crawler.
12:25:16 <dons> stub, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/urlcheck
12:25:17 <lambdabot> Title: HackageDB: urlcheck-0.1.1, http://tinyurl.com/6ckc3u
12:25:23 <jkr> You can control it like a browser, but programmatically.
12:25:30 <dons> like a browser?
12:25:31 <geezusfreeek> not tagsoup
12:25:37 <conal> dcoutts: do you know what smtp user & password to use for notification in code.haskell.org trac instances?
12:25:37 <sbahra> thoughtpolice, 40 Haskell ports in FreeBSD
12:25:39 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/selenium ?
12:25:40 <lambdabot> Title: HackageDB: selenium-0.2.3, http://tinyurl.com/5rg72q
12:25:40 <geezusfreeek> like ruby's hypricot?
12:25:53 <dons> hypricot =~ download-curl
12:25:53 <jkr> Like: $mech->field('foo' => 'bar'); $mech->submit_form; $mech->follow_link(2) and so on
12:25:57 <geezusfreeek> ah
12:25:58 <dons> jkr: selenium.
12:26:04 <dons> is closest.
12:26:16 <jkr> You mean the Firefox plugin?
12:26:21 <dcoutts> conal: I'm not sure, ask Igloo
12:26:24 <dons> nope, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/selenium
12:26:25 <lambdabot> Title: HackageDB: selenium-0.2.3, http://tinyurl.com/5rg72q
12:26:35 <dons> for driving a browser mechanically, to navigate and test things
12:26:52 <conal> dcoutts: will do.  thx.
12:27:13 <jkr> Hrm, not really what I need.
12:27:20 <dons> jkr: fwiw, we've used it successfully to test commercial haskell web apps :)
12:27:33 <geezusfreeek> ah mechanize is actually what i was thinking, but i didn't recognize the name :P
12:27:36 <Saizan> jkr: see the HTTP package, it has a limited form of that
12:27:41 <dons> ah
12:27:57 <jkr> Yeah it's great for testing, I'm using it at work too. But I don't want to test, I just want to automate some browser tasks in the command line :)
12:28:09 <Igloo> conal: You shouldn't need a user/password
12:28:31 <dons> jkr: that'd be cool.
12:28:37 <dons> maybe a chance to contribute some code?
12:28:54 <jkr> geezusfreeek: http://search.cpan.org/~petdance/WWW-Mechanize-1.50/lib/WWW/Mechanize.pm
12:29:03 <conal> Igloo: oh!  and notification should just work?
12:29:23 <jkr> dons: You mean I shoud write Mechanize for Haskell? :)
12:29:31 <dons> yeha.
12:29:44 <jkr> That could take a while :)
12:29:54 <dons> depends. :)
12:30:06 <Igloo> conal: If it's enabled, yes
12:30:11 <jkr> He, I just learned how to do a simple GET request with HTTP in Haskell :)
12:30:35 <jkr> I don't want to think about parsing HTML yet
12:30:48 <Igloo> conal: /srv/trac/camp/conf/trac.ini sends e-mail for each BTS change to the camp mailing list (search for "smtp" for the relevant fields)
12:31:15 <conal> Igloo: i'm searching the trac admin UI for enabling notification.  do you happen to know how to enable?
12:31:20 <conal> Igloo: looking ...
12:31:34 <geezusfreeek> jkr, there do exist html parsing libraries already
12:31:35 <Igloo> I don't know how to do it through the UI
12:31:57 <thoughtpolice> jkr: hm, it seems pretty cool. you might be able to hack something similar up in a day or two using some libraries...
12:32:00 <dons> jkr: lots of 'em. see e.g. download-curl for integrated client-side HTTP and parsing.
12:32:03 <dons> in various format.s
12:32:07 <jkr> Btw, Haskell doesn not have any object oriented syntax features, does it?
12:32:15 <dons> hell no.
12:32:18 <jkr> Hehe, ok
12:32:19 <geezusfreeek> ha
12:32:23 <jkr> I just wondered
12:32:26 <conal> Igloo: np.  i'll study & mimic the camp example.  thanks!
12:32:34 <monochrom> You will be glad it doesn't.
12:32:45 <mfwitten> I'm really not very sure about my answer to the next exercise. It seems.... forced: http://hpaste.org/12051
12:32:47 <jkr> So it's common practice to reach around some data structure to all metho^Wfunctions?
12:32:55 <kynky> haskell has classes
12:32:59 <dons> jkr?
12:33:10 <dons> we live in the land of verbs.
12:33:21 <jkr> Well, like "myFunc myStruct" instead of "myObj.myMeth"
12:33:22 <monochrom> heh
12:33:22 <daf> kynky: that's really besides the point
12:33:41 <monochrom> like 1+2 instead of 1.+(2)
12:34:08 <daf> mfwitten: I think it's the exercise that's forced, not your solution :)
12:34:09 <vixey> mfwittern, Prefer,   Left (a), Right (Left (a,b)), Right (Right (Left (a,b,c))), ...
12:34:16 <trofi> "superf f"
12:34:24 <monochrom> (see how it is more intuitive than oop? despite all the oop proclamations)
12:34:28 <jkr> Or how do you write code that uses a some data structure a lot, like a class in OO?
12:34:30 <mfwitten> daf: *phew*
12:34:34 <vixey> this way doesn't require a power of two
12:34:40 <vixey> like your way does
12:34:43 <mauke> monochrom: (+).apply(1).apply(2)
12:34:55 * monochrom murders mauke
12:34:57 <mauke> jkr: Reader or State
12:35:12 <vixey> (+ 1 2)
12:35:26 <vixey> (just closing the loop)
12:35:26 <wchogg> conal:  BTW, I left a couple of notes on trac about the crash of recursive integral on single events.  One very weird thing is that it doesn't happen when I try to step through via ghci.  Do you have any suggestions what to try to diagnose this?
12:35:28 <Saizan> 1 2 +
12:35:30 <jkr> For example, I've written a simple brainfuck interpreter and I'm reaching RunTime data structure to every function that contains a memory array and a pointer
12:35:33 <monochrom> (map f . filter p . sort) xs  uses some data structures alot.
12:35:45 <mauke> jkr: sounds like a job for Reader
12:35:56 <dons> jkr: oh. Reader or State monad.
12:36:06 <dons> to plumb that structure you're updating a lot around automatically
12:36:21 <dons> rather than having it as, say, a global reference
12:37:09 <mauke> implicit dynamic pseudoglobals
12:37:11 <monochrom> OOP = Object Obsession Pomposity
12:37:36 <mauke> pure OO = lambda calculus
12:37:52 <vixey> I heard that in the old days you used to get bugs in programs that could overwrite all over the memory! And OO is the solution for it
12:37:56 <ystael> OOP = beheaded feces
12:38:01 <jkr> Hehe
12:38:02 <conal> wchogg: sry.  i'm not skilled at debugging this kind of stuff.
12:38:19 <mauke> @where OOHaskell
12:38:19 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
12:38:24 <monochrom> hahahahah ystael
12:38:27 <conal> wchogg: does the crash happen while _running_ under ghci?
12:38:36 <geezusfreeek> OOP is just a way to trick yourself into believing you have control over state, IMHO
12:38:49 <vixey> Structured Spagetti
12:39:11 <wchogg> conal:  Yes, if I just run main everything goes nasty.  It's only when I set a breakpoint that it doesn't.
12:39:35 <conal> wchogg: oh, okay.  hrmf. :(
12:39:50 <wchogg> conal:  Maybe there's some kind of weird sync'ing issue between threads that is avoided via stepping.
12:39:53 <jkr> mauke: Have you ever written a vim plugin for Perl syntax?
12:40:06 <conal> wchogg: oh yeah.  sounds plausible to me.
12:40:09 <mauke> jkr: yes
12:40:26 <jkr> \o/
12:40:36 <mauke> huhu
12:40:51 <jkr> Thanks for that great plugin, it really makes programming perl in vim a lot more fun :)
12:41:33 <Cale> mfwitten, vixey, etc.: Here's an approach to that Tuple problem :) http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=481#a481
12:42:02 <mauke> you're welcome!
12:42:18 <monochrom> haha neato
12:42:20 <vixey> Cale++ super
12:42:43 <wchogg> conal:  I apologize I haven't been able to nail down these recursive integral problems yet.  I've never debugged anything this complex before.
12:43:05 <wchogg> correction.  I've never debugged anything in _haskell_ this complex
12:43:38 <mfwitten> Cale: It's over my head (at least for now)
12:44:02 <Cale> mfwitten: That's probably mostly due to the way I used the Maybe monad.
12:44:11 <conal> wchogg: no apologies necessary!  i really appreciate the help.  and i hope you're getting something useful for you out of the process.
12:44:47 <mfwitten> Maybe so ;-)
12:44:48 <Cale> mfwitten: You can think of <=< as being the obvious function of type (b -> Maybe c) -> (a -> Maybe b) -> (a -> Maybe c)
12:44:49 <dons> conal is our collaboration guru.
12:44:55 <Cale> mfwitten: and return = Just
12:45:38 <nathanic> hello, does anyone know of a prebuilt cabal.exe for windows?
12:45:46 <conal> dons: :)  i'm just trying to get a clue.  i really want to do collaborative projects.
12:45:54 <Cale> mfwitten: that is, <=< is the natural analogue to function composition for Maybe-valued functions.
12:45:59 <vixey> ?djinn (b -> Maybe c) -> (a -> Maybe b) -> (a -> Maybe c)
12:45:59 <lambdabot> f a b c =
12:45:59 <lambdabot>     case b c of
12:45:59 <lambdabot>     Nothing -> Nothing
12:45:59 <lambdabot>     Just d -> a d
12:46:05 <mfwitten> I understand
12:46:07 <dcoutts> nathanic: http://haskell.org/~duncan/cabal/cabal.exe
12:46:08 <mfwitten> thanks
12:46:14 <nathanic> dcoutts: thanks!
12:46:29 <conal> ... projects, in a way that's more fun & fruitful than a traditional company structure (big or small)
12:47:07 <jeffersonheard> anyone here ever used multisampling in HOpenGL?
12:48:31 <dons> conal: totally agreed. galois is like this too. all loose knit collaboration where people come together based on mutual interest in producing new artifacts.
12:51:28 <conal> is it a hackage bug that haddock formatting directives from a .cabal file's 'description' field show up unprocessed?  For instance, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reactive-0.9.0
12:51:30 <lambdabot> Title: HackageDB: reactive-0.9.0, http://tinyurl.com/6rpk7u
12:52:08 <dons> hmm. yes.
12:52:31 <wchogg> dons:  You might know this, but how do multiple threads work when you're stepping through via ghci.  I'm assuming they just continue unabated.
12:52:41 <dcoutts> conal: I'd no idea haddock understood escapes like that
12:52:44 <dons> wchogg: right.
12:52:47 <dons> they're forkIO's
12:53:12 <dcoutts> conal: hackage uses haddock parsing code from haddock-0.x, so perhaps it's a new haddock feature.
12:53:19 <dcoutts> conal: feel free to file a ticket
12:53:37 <conal> dcoutts: that haddock markup is very old.  where would i file a ticket?
12:53:55 <dcoutts> conal: in the hackage trac http://hackage.haskell.org/trac/hackage/
12:53:56 <lambdabot> Title: Hackage - Trac
12:53:59 <wchogg> dons:  And it looks like, from my experiments, what function you set your break point on changes which thread you step through, i.e. it's not always the thread that main is running on?  That right?
12:54:07 <conal> dcoutts: will do.  thanks!
12:54:45 <byorgey> hi conal!
12:55:25 <byorgey> conal: to learn more about reactive, I'm interested in creating a little game by wiring up reactive, chipmunk (a physics engine), and some sort of graphical output to make a little game.
12:55:25 <dons> wchogg: i'm not sure. please talk to pepe or simon marlow
12:55:28 <sam__> What is XOR in SKI kvantors?
12:55:30 <dons> (ghci-debugger gurus)
12:55:40 <vixey> sam__: idk
12:55:40 <dons> byorgey: mega awesome.
12:55:45 <dons> chipmunk + reactive == pure win.
12:55:50 <byorgey> does that sound feasible?  and would fieldtrip be suitable to produce the 2D graphics?
12:55:50 <jkr> Is it normal that compiling lambdabot throws a lot of warnings?
12:55:58 <vixey> sam__: I would o it in lambda and abstraction eliminate
12:56:02 <dons> jkr: its not normal to compile lambdabot :)
12:56:04 <byorgey> dons: indeed!
12:56:04 <vixey> sam__: combinators are too har
12:56:05 <vixey> d
12:56:06 <conal> byorgey: hi!  my last (brief) email reply to you has apparently been held undelivered.  i get occasional mailer replies.
12:56:09 <wchogg> dons:  Will do, thanks.
12:56:10 <jkr> :)
12:56:20 <byorgey> conal: hmm, that's odd.
12:56:26 <conal> byorgey: that'd be great.  chipmunk looks really cool.
12:56:30 <jkr> lambdabot-4.2.2 depends on haskell-src-exts-0.3.9 which failed to install. :(
12:56:55 <wchogg> byorgey:  If you decide you want to start working on that, I'd like to chip in some help.  I want to start making physics games with reactive.
12:56:57 <sam__> vixey: I have been ordered to get XOR by the use of SKIs - how would you do it?
12:57:08 <vixey> I just tord you how I do it ...........
12:57:14 <byorgey> wchogg: great!
12:57:39 <byorgey> unfortunately I probably won't be able to start on this for another 3 or 4 weeks
12:57:42 <byorgey> but we'll see
12:57:53 <conal> byorgey: i get "Delivery to the following recipient has been delayed: byorgey@grw057-25.cis.upenn.edu"
12:58:14 <conal> byorgey: oh.  hrmf.  i hope i didn't just spam-seed you via the #haskell archive
12:58:20 <dcoutts> conal: oh, it's just not being parsed at all
12:58:30 <wchogg> byorgey:  Well, hopefully by then some issues that are annoying me will get resolved.
12:58:31 <dcoutts> conal: I was only looking at the &#169; but
12:58:34 <dcoutts> but/bit
12:58:50 <conal> dcoutts: yeah.  none of it is getting processed.
12:58:52 <byorgey> conal: oh, you should strip out the grw057-25 part.  that's weird, I don't know how that got in there.  that's the name of my actual machine.
12:58:52 <sam__> vixey: I have XOR in lambda terms. How would you convert it to SKIs?
12:59:12 <sam__> vixey: here: \ a b. if a (not b) b
12:59:18 <byorgey> maybe some settings are munged here on my end.
12:59:22 <conal> byorgey: oh!  will do.
12:59:22 <vixey> abstraction elimination
12:59:41 <byorgey> wchogg: ok, cool.  yeah, I will definitely let you know.
12:59:49 <vixey> @pl \ a b. iff a (not b) b
12:59:50 <lambdabot> (line 1, column 6):
12:59:50 <lambdabot> unexpected "."
12:59:50 <lambdabot> expecting pattern or "->"
12:59:53 <vixey> @pl \ a b -> iff a (not b) b
12:59:54 <lambdabot> join . (. not) . iff
12:59:56 <vixey> sam, in haskell use ->
13:00:15 <byorgey> conal: so would FieldTrip be suitable for producing 2D graphics as well?
13:00:21 <byorgey> chipmunk is only a 2D physics engine
13:00:30 <wchogg> byorgey:  It should work from my playing with it.
13:00:54 <conal> byorgey: might be.  there is a pretty undeveloped Geometry2 type.  Also Image (Pan-like: infinite & continuous).
13:01:19 <conal> byorgey: something cairo-based might be cool, though.
13:01:20 <sam__> vixey: yes. I agree with you. But what would you do first to convert the expression to SKIs?
13:01:27 <lilac> @pl \a b -> a b (flip b)
13:01:27 <lambdabot> (`ap` flip)
13:01:39 <byorgey> hm, infinite & continuous images sound neat.
13:02:01 <byorgey> the application I'm imagining would feature lots of scrolling, i.e. only part of the world would be on screen at a time
13:02:17 <byorgey> so something which automatically managed which things to draw via laziness would be super awesome.
13:02:54 <byorgey> I guess instead of "2D graphics" I actually meant "2D animation"
13:02:59 <wchogg> Yeah, that does sound cool.
13:03:15 <byorgey> but yeah, cairo is another possibility.
13:03:20 <wchogg> byorgey:  What game-idea do you have in mind, if you don't mind me asking?
13:04:06 <conal> byorgey: there's certainly room for display culling optimizations.
13:04:31 <byorgey> wchogg: not at all. =)  the idea is that you control a circle which has to make its way through various levels, collecting power-ups, overcoming obstacles, etc. etc. what have you
13:04:52 <byorgey> the "catch" is that the only thing you can control is your spin
13:04:55 <vixey> I love it!
13:05:05 <byorgey> and you can also "bounce" yourself by adding a bit of downward velocity
13:05:19 <conal> byorgey: sounds really fun
13:05:28 <byorgey> I think so too =)
13:05:50 <dcoutts> conal: turns out it's because it fails to parse, so hackage falls back to displaying it verbatum on the assumption that it's not actually haddock markup at all.
13:05:51 <byorgey> this is actually an idea I've had for a while -- I tried making it before except I tried implementing all the physics from scratch myself, and that didn't go too well =P
13:05:56 <wchogg> byorgey:  That sounds neat.  The main idea I've wanted to make is a combination of minature golf with fluid dynamics.  The only thing you can do is click to create shockwaves that move the ball around the board.
13:06:05 <dcoutts> conal: "parse error in doc string: [TokURL \"http://conal.net/papers/simply-reactive/\",TokString \".\\n\",TokPara]"
13:06:15 <byorgey> wchogg: heh, that sounds fun too =)
13:06:40 <lilac> @type (`ap` (. const) . ap)
13:06:41 <lambdabot> forall b b1 a b2. ((b1 -> a -> b2) -> (a -> b1 -> b2) -> b) -> (b1 -> a -> b2) -> b
13:06:55 <wchogg> byorgey:  small physics games ftw!
13:07:02 <conal> dcoutts: oh!  how far behind the times is hackage's haddock?
13:07:17 <conal> dcoutts: and how did you find out about parse failure?
13:07:28 <dcoutts> conal: I looked at the code and ran it in ghci
13:07:47 <dcoutts> conal: for parsing the description fields it uses a copy of the haddock lexer and parser from haddock-0.9
13:08:37 <conal> dcoutts: and for module documentation it uses a modern haddock?
13:08:43 <geezusfreeek> byorgey, that definitely sounds like a good one for chipmunk
13:08:54 <dcoutts> conal: for that it uses an external haddock binary
13:09:16 <conal> dcoutts: oh ... which is up to date on hackage because ghc is.
13:09:26 <geezusfreeek> i'm probably going to end up using chipmunk for my upcoming game project too. i wish it had a pure interface though :(
13:10:35 <vixey> I bet event based FRP would be slic
13:10:36 <vixey> kkkkkk
13:10:38 <wchogg> geezusfreeek:  Well, I think that would be a good thing to work on.  The same way that conal's fieldtrip is a pure wrapper around opengl & glut.
13:10:49 <hackage> Uploaded to hackage: freesound 0.0.1
13:10:58 <geezusfreeek> i've been experimenting with wrappers/ports
13:11:17 <sam__> How to convert lambda expressions such as a (not b) b to SKI combinators?
13:11:18 <wchogg> geezusfreeek:  Anything promising?
13:11:23 <geezusfreeek> not really yet
13:12:05 <vixey> sam__: abstraction elimination algorithm
13:12:12 <geezusfreeek> i tried a port first because i want to try DPH with it. it's not going badly or anything, but it will probably be fairly slow
13:12:20 <geezusfreeek> no mutation in it or anything
13:12:30 <geezusfreeek> i may be able to try some ST stuff or something though
13:12:48 <geezusfreeek> or even some internal ugliness, if i have to
13:12:58 <wchogg> geezusfreeek:  And by port you mean just following the same algorithms, but Haskell all the way down?
13:13:02 <geezusfreeek> yeah
13:13:28 <sam__> vixey: How does this algorithm work?
13:13:40 <sam__> vixey: with SKIs
13:13:44 <conal> dcoutts: i'm filing a hackage trac ticket.  how did you know that hackage is using old haddock-0.9 parsing?
13:13:50 <vixey> @goabstraction elimination algorithm
13:13:51 <lambdabot> Unknown command, try @list
13:14:02 <mauke> wikipedia has a description
13:14:16 <dcoutts> conal: because that's where the modules were lifted from
13:14:36 <dcoutts> conal: and because haddock-2 did not exist at the time
13:14:45 <sam__> @go abstraction elimination algorithm
13:14:47 <lambdabot> No Result Found.
13:14:58 <trofi> @go why mueval dislikes ghc-6.10
13:14:59 <lambdabot> No Result Found.
13:15:00 <conal> dcoutts: thx
13:15:05 <sam__> @go abstraction elimination
13:15:08 <lambdabot> http://en.wikipedia.org/wiki/Combinatory_logic
13:15:08 <lambdabot> Title: Combinatory logic - Wikipedia, the free encyclopedia
13:16:17 <conal> dcoutts: do you know if i have to explicitly add myself to the Cc field on hackage's trac, in order to get email updates on my new ticket?
13:16:30 <conal> i'm never sure, with trac.
13:16:36 <dcoutts> conal: me neither :-)
13:18:49 <sam__> How to get NOT  by SKIs ?
13:19:08 <vixey> :?
13:19:09 <mauke> sam__: how is NOT defined in terms of lambda?
13:19:21 <vixey> sam__: same way as I said before .....
13:19:26 <vixey> sam__: I mean this way works ..
13:19:32 <vixey> sam__: but you could do it the other way too
13:19:38 <sam__> @go not
13:19:39 <lambdabot> http://en.wikipedia.org/wiki/Not!
13:19:39 <lambdabot> Title: Not! - Wikipedia, the free encyclopedia
13:20:07 <sam__> mauke: I do not know the defination
13:20:23 <Deewiant> sam__: http://www.angelfire.com/tx4/cus/combinator/birds.html
13:20:24 <lambdabot> Title: Combinator Birds
13:20:33 <vixey> \boolean true false -> boolean false true  ? isn't it?
13:20:38 <mauke> well, find out and apply the algorithm to it
13:23:24 <vixey> @pl \boolean true false -> boolean false true
13:23:24 <lambdabot> flip
13:24:11 <sam__> mauke: Not is defined so: not = \ x. if x false true
13:24:28 <sam__> mauke: but how to get it to SKIs?
13:24:39 <vixey> sam__, why are you not trying te way I said :/
13:24:48 <Deewiant> sam__: it's defined on the page I posted above...
13:25:02 <sam__> vixey: I did not understand what you meant
13:25:23 <vixey> so say that lol
13:25:32 <vixey> instead of asking the same question in a GOTO loop
13:27:14 <mauke> [\f -> \x -> \y -> f y x] = [\f -> [\x -> \y -> f y x]] = [\f -> [\x -> [\y -> f y x]]] = [\f -> [\x -> [\y -> [f y x]]]] = [\f -> [\x -> [SfKx]]] = [\f -> [SfK]] = [SSKK] = SSKK
13:27:29 <vixey> :(
13:27:32 <mauke> wait, am I doing this even remotely right?
13:27:37 <Twey> .. aʊ
13:28:29 <mauke> :t ap ap (const const)
13:28:30 <lambdabot> forall b a b1. (a -> (b1 -> a) -> b) -> a -> b
13:28:49 <gwern> 'But type-level code is special in that its correctness is crucial to the safety of the program; so except in those cases simple enough for the type checker to see trivially that the code is correct (or harmless), type-level programs need to come with their specification and correctness proof.' <-- and we go meta one more level... (but surely our typing of the type-level itself requires proofs)
13:29:41 <lilac> @type let s = ap; k = const in s s (k (s (s (k s) (s (k k) s)) (k k)))
13:29:42 <lambdabot> forall b b1 a b2. ((b2 -> a -> b1) -> (a -> b2 -> b1) -> b) -> (b2 -> a -> b1) -> b
13:29:52 <sam__> mauke: Which program do you use to test these expressions?
13:30:00 <vixey> oh don't use types to check though
13:30:01 <mauke> sam__: none, and I'm doing it wrong
13:30:06 <vixey> htis is my mistake in combinatory logic
13:30:19 <vixey> I tried ot construct combinators using types -- but this doesn't work
13:31:38 <sam__> Deewiant: what is the name of NOT in the link you gave me?
13:31:49 <Deewiant> ?ty let s = ap; k = const in ((s((s(k((s(k s))k)))s))(k k))
13:31:50 <lambdabot> forall b a b1. (b1 -> a -> b) -> a -> b1 -> b
13:31:57 <Deewiant> sam__: surely you can express it as a lambda
13:32:01 <Deewiant> and look it up in the left column
13:32:04 <mauke> S(S(KS)(S(KK)S))(KK)
13:32:08 <Deewiant> anyhoo, that's it right there
13:32:11 <Deewiant> ?ty flip
13:32:12 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:32:13 <Deewiant> ?ty let s = ap; k = const in ((s((s(k((s(k s))k)))s))(k k))
13:32:14 <lambdabot> forall b a b1. (b1 -> a -> b) -> a -> b1 -> b
13:32:31 <mauke> :t ap (ap (const ap) (ap (const const) ap)) (const const)
13:32:31 <lambdabot> forall b a b1. (b1 -> a -> b) -> a -> b1 -> b
13:33:02 <mauke> different solution?
13:33:36 <Deewiant> simplified
13:33:38 <Deewiant> I think
13:33:46 <lilac> doesn't look like xor to me.
13:34:30 <sam__> mauke: How did you get this S(S(KS)(S(KK)S))(KK)?
13:34:39 <mauke> let me derive it again
13:34:41 <Deewiant> ?ty ap (const const) ap
13:34:42 <lambdabot> forall b (m :: * -> *) a b1. (Monad m) => m (a -> b1) -> b -> m a -> m b1
13:34:46 <Deewiant> cute
13:34:48 <lilac> SS(K(S(S(KS)(S(KK)S))(KK)))
13:35:24 <Twey> Is there a validating HTML library available for Haskell?
13:35:41 <Taejo> > unwords "+ - ! ~ ++ -- :h :t :r :e * / % == != > < >= <= && & || | ^ = += -= *= /= %="
13:35:43 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
13:35:51 <Taejo> > words "+ - ! ~ ++ -- :h :t :r :e * / % == != > < >= <= && & || | ^ = += -= *= /= %="
13:35:52 <lambdabot>   ["+","-","!","~","++","--",":h",":t",":r",":e","*","/","%","==","!=",">","<...
13:35:59 <Twey> I've seen a bunch of them, but they don't really seem to validate.  XHTML1 is good too, so long as I can transform it.
13:36:22 <sam__> lilac: Could you paste the methods you get this: SS(K(S(S(KS)(S(KK)S))(KK)))?
13:36:42 <lilac> sam__: ok.
13:37:16 <lilac> @pl \a b -> a b (flip b)
13:37:16 <lambdabot> (`ap` flip)
13:38:48 <lilac> flip's not S or K, so...
13:38:49 <lispy> :t const const
13:38:49 <lambdabot> forall a b b1. b1 -> a -> b -> a
13:38:50 <lilac> @pl \f -> ap f . const
13:38:51 <lambdabot> (. const) . ap
13:39:05 <EmielRegis> how can I incorporate a simple timer in my haskell program?
13:39:07 <lilac> @type \f -> ap f . const
13:39:09 <lambdabot> forall b a b1. (b1 -> a -> b) -> a -> b1 -> b
13:39:14 <lispy> ?pl \f -> ap f . const f
13:39:14 <lambdabot> liftM2 (.) ap const
13:40:37 <lilac> then abstraction elimination to turn \a -> s a (\ b c -> s b (k c)) into the result
13:40:53 <Deewiant> ?ty ((>>>) >>> (>>>) (>>>)) ap const
13:40:54 <lambdabot> forall b b1 b2. (b2 -> b -> b1) -> b -> b2 -> b1
13:41:00 <lispy> ?pl \a -> a s (\ b c -> s b (k c))
13:41:00 <lambdabot> flip ($ s) ((. k) . s)
13:41:32 <lispy> :t flip ($ s)
13:41:33 <lambdabot> forall b c. b -> (Expr -> b -> c) -> c
13:41:54 <lispy> :t (s $)
13:41:55 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
13:41:55 <lambdabot>     In the first argument of `($)', namely `s'
13:43:55 <Twey> EmielRegis: Control.Concurrent.threadDelay?
13:44:06 <EmielRegis> thanks ill have a look into that
13:44:43 <mauke> sam__: [f. [x. [y. (f y) x]]] = [f. [x. S[y. f y][y. x]]] = [f. [x. Sf(Kx)]] = [f. S[x. Sf][x. Kx]] = [f. S(K(Sf))K] = S[f. S(K(Sf))][f. K] = S(S[f. S][f. K(Sf)])(KK) = S(S(KS)(S[f. K][f. Sf]))(KK) = S(S(KS)(S(KK)S))(KK)
13:45:56 <sam__> mauke: thanks!
13:46:07 <mauke> I hope that makes some sense :/
13:48:12 <lilac> sam__: http://hpaste.org/12053
13:48:34 <vixey> say
13:48:36 <sam__> lilac: thanks! I have to compare now the twos
13:48:46 <lilac> i think that's the same as mauke's for flip
13:49:40 <sam__> lilac: what is flip?
13:49:47 <lilac> @type flip
13:49:48 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:49:55 <mauke> flip = \a b c -> a c b
13:49:57 <mauke> FIRST LINE
13:50:16 <vixey> ahaha
13:50:45 <lilac> @@ @djinn @type flip
13:50:47 <lambdabot>  f a b c = a c b
13:50:59 <vixey> @@ YOW
13:50:59 <lambdabot>  YOW
13:51:10 <vixey> @nikin
13:51:10 <lambdabot> Maybe you meant: nixon wiki
13:51:13 <vixey> @nixon
13:51:13 <lambdabot> Any change is resisted because bureaucrats have a vested interest in the chaos in which they exist.
13:51:57 * lilac writes all his code with @djinn these days
13:52:21 * vixey writes all her code with  foldFoo or f . g . h ..
13:52:57 <dons> heh
13:53:00 <lilac> f . g . h .. ? no instance for Enum Expr
13:55:16 <sam__> lilac: Your answer seems to be correct. I did not find any mistake - well done!
13:55:34 <lilac> \o/
13:56:53 <lilac> right, time to write an @ski for \b?
13:57:05 <vixey> lilac, cool
13:57:18 <ziman> erm, vixey is `her'? :)
13:57:29 <lilac> ziman: say it out loud
13:58:18 <vixey> lilac, would be a nice trick to support data types also
13:58:24 <mmorrow> this prog works OK on my latop, but segfaults if you try to eval anything related to "function(..){...}" on the machine lunabot's running on (which is a hosted server (presumably in vmware) running CentOS and without SELinux). my best guess is that it's treating some memory as executable which it isn't allowed to be treating as such, but i'm not sure how i'd find this out or fix it. http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=344
13:58:25 <ziman> i knew only about philippa :)
13:58:45 <lament> oh the mysteries of irc
13:58:56 <mmorrow> does anyone have any suggestions?
14:00:12 <mmorrow> hmm, maybe gcc version 3.4.6 20060404 (Red Hat 3.4.6-10) has something to do with it
14:00:48 <lilac> vixey: as in 'Bool :: * -> * -> *; True = K; False = S (S (K S) (S (K K) S)) (K K) K'?
14:00:59 <vixey> stuff like that
14:01:13 <Taejo> writing parsers for underspecified languages is harder than it looks
14:01:35 <Twey> > let (@) = (+) in 5 @ 3
14:01:36 <lambdabot>   <no location info>: parse error on input `@'
14:01:50 <Twey> Why is @ reserved?
14:02:03 <lilac> vixey: that'd be pretty neat. i wonder how much of haskell syntax we could preserve.
14:02:23 <lilac> the above could be written 'data Bool = True | False' :)
14:03:31 <lilac> a haskell -> ski compiler would seem like the thing someone would have already written
14:03:38 <lilac> *kind of thing
14:08:49 <Taejo> let digs = "123" in digs / 10**(length digs)
14:08:54 <Taejo> > let digs = "123" in digs / 10**(length digs)
14:08:55 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Int'
14:09:13 <Taejo> > let digs = "123" in read digs / 10^(length digs)
14:09:14 <lambdabot>   0.123
14:09:16 <vixey> what's that meant to do
14:10:25 <Taejo> vixey: digs are digits-after-decimal-point
14:10:49 <hackage> Uploaded to hackage: winerror 1.0.1
14:11:14 <Taejo> @src guard
14:11:14 <lambdabot> guard True  =  return ()
14:11:14 <lambdabot> guard False =  mzero
14:11:56 <mauke> > read $ "0." ++ "123" :: Double
14:11:57 <lambdabot>   0.123
14:12:21 <Taejo> hehe, could do it that way
14:12:50 <Taejo> > read ".123"
14:12:51 <lambdabot>   * Exception: Prelude.read: no parse
14:12:57 <Taejo> > (read ".123")::Double
14:12:58 <lambdabot>   * Exception: Prelude.read: no parse
14:13:15 <Taejo> > (read "0123")::Int
14:13:16 <lambdabot>   123
14:14:24 <Taejo> > (read "0x123")::Int
14:14:25 <lambdabot>   291
14:14:29 <Taejo> > (read "0xFF")::Int
14:14:30 <lambdabot>   255
14:14:50 <lilac> > read "0o123" :: Int
14:14:52 <lambdabot>   83
14:15:33 <lilac> infix -1 ::
14:16:20 * mmorrow builds a newer gcc since the centos yum repos i know about are lacking in newness
14:16:40 <mmorrow> third person fail
14:16:59 * vixey doesn't have any clue what is wrong with that javascript thing ...
14:17:20 <MisterN> > read "123"
14:17:22 <lambdabot>   * Exception: Prelude.read: no parse
14:17:25 <vixey> > read "()"
14:17:26 <lambdabot>   ()
14:17:32 <vixey> default ()
14:17:41 <MisterN> @src read
14:17:42 <lambdabot> read s = either error id (readEither s)
14:17:55 <mmorrow> vixey: yeah it's weird. i think it's gotta be something to do with all the software on this machine other than what i've built myself being ancient
14:18:54 <mmorrow> surprisingly though, i was able to build 6.10 by bootstrapping 6.4 -> 6.8 -> 6.10
14:19:14 <sbahra> mmorrow, when are you going to be able to work on the vector stuff?
14:19:22 <sbahra> mmorrow, tomorrow night? Sunday night?
14:21:16 <roconnor> is bioinformations a true haskell success story?
14:21:24 <roconnor> is there an article on it somewhere?
14:21:47 <Savant> Do you mean bioinformatics?
14:21:54 <mmorrow> sbahra: hey howsit. i could do either depending on your schedule. i've gotta do a few things right now, but lets talk about it in a few hours. will you be around?
14:22:08 <roconnor> Savant: yes, sorry
14:23:11 <sbahra> mmorrow, hopefully.
14:23:20 <Savant> roconnor: Ah, I'm not sure; I'm pretty new to haskell, give or take 12 hours.
14:23:43 <monochrom> #haskell is a true success story.  545 users?!  last time I check it was 454 users...
14:24:03 <roconnor> \join ##c
14:24:11 <Savant> monochrom: There are statistics on the haskell.org page afaik
14:24:16 <roconnor> oh wow
14:24:19 <roconnor> more than c
14:25:09 <vixey> PRoof athat haskell is better than C!!
14:25:17 <Savant> Most channels have a plethora of bots, posing as real people.
14:25:35 <mauke> #perl still wins
14:25:38 <ksf> @botsnack
14:25:38 <lambdabot> :)
14:26:16 <ksf> @vixen
14:26:16 <lambdabot> so?
14:26:16 <Savant> mauke: The way #ubuntu does.
14:26:20 <ksf> @vixen
14:26:20 <lambdabot> *shrugs*
14:26:31 <ksf> definitely an advanced ai.
14:26:47 <mauke> preflex: quote
14:26:48 <preflex>  <byorgey> Extreme Anger Programming: you are paired with a really dumb partner and after twenty minutes of agony you rip the keyboard from their hands, delete everything they typed, and do it yourself
14:26:53 <monochrom> Only advanced ai can execute haskell code
14:29:56 <nominolo> hm, i'm looking for an Emacs mode line indicator to signal "no errors, no warnings"
14:30:39 <nominolo> if there are errors or warnings it should show [0,2] for 0 errors 2 warnings
14:31:09 <nominolo> now, what's a good way to make [0,0] to make it more distinct?
14:31:26 <nominolo> er "to make [0,0] more distinct
14:32:24 <roconnor> *[0,0]*
14:33:46 <nominolo> hm [\o/]
14:34:07 <nominolo> [o_O]
14:34:18 <nominolo> nah
14:34:26 <mauke> ［０，０］
14:34:39 <dons> distinct.
14:34:52 <MisterN> ["cookie"]
14:35:22 <solrize> (Errors 0, Warnings 2)
14:35:31 <mauke> 02green backgroundg
14:35:41 <nominolo> solrize: no it's for incremental compilation
14:35:43 <Twey> Aïe!
14:35:44 <MisterN> mauke: doesn't work
14:35:47 <nominolo> it works quite well so far
14:35:50 <mauke> MisterN: use more irssi
14:35:52 <Twey> I thought #haskell was +c
14:36:30 <monochrom> "we have achieved tremendous victory on compiling this file"
14:37:02 <nominolo> monochrom: hm, that's good for the minibuffer
14:37:19 <vixey> Saya :)
14:37:19 <monochrom> It's communist party pomposity speak.
14:37:28 <dmead> for great justice!
14:37:48 <Saya> vixey :)
14:37:50 <mauke> Twey: you are using cdbirssibdc.
14:38:12 <monochrom> They are not content to just say "compiled". They have to say some formal pompous "victory" thing.
14:38:31 <solrize> http://ghcmutterings.wordpress.com/2008/11/14/comparing-concurrent-linked-list-implementations-in-haskell/
14:38:34 <monochrom> It's so 19th century.
14:38:37 <lambdabot> Title: Comparing concurrent linked-list implementations in Haskell « GHC Mutterings, http://tinyurl.com/685pmh
14:38:38 <mauke> (+c lets irssi's internal escape codes through (and irssi interprets its internal codes in text coming from IRC))
14:38:59 <Savant> mauke: You're an expert of the ircs.
14:39:07 <Twey> Oh ah.
14:39:19 <mauke> it's the BBCODE of IRC :/
14:40:20 <MisterN> one reason not to use irssi
14:40:24 <Savant> mauke: Did you discover the art behind gobbles.bas?
14:40:47 <mauke> I don't know what that is
14:42:59 <quicksilver> I though they were mirc escape codes
14:43:04 <quicksilver> which irssi just conformed to.
14:43:24 <gwern> 'So when you stand up and shout:  "Aha!  I've got it!  We've got to solve this problem using asynchronous processes!", it's like shouting, "Aha!  I've got it!  We need to build this wagon out of nonwood!  Let's go down to the market and buy a ton of nonwood from the nonwood shop!"  You've got to choose some specific alternative to synchrony. '
14:43:26 <quicksilver> I'm all in favour of a -c #haskell personally. It can be very helpful.
14:43:27 <mauke> no, mirc codes are filtered by +c
14:43:57 <quicksilver> ah.
14:44:05 <jeffwheeler> I'm trying to build Yi which depends on regex-tdfa, but cabal fails to install that by itself. I was able to download the regex-tdfa package and modify it to work, then cabal install-ed successfully.
14:44:23 <jeffwheeler> Unfortunately, when I try cabal install in Yi, it still tries to download the unmodified version and fails again.
14:44:31 <sjanssen> jeffwheeler: how did regex-tdfa fail?
14:44:36 <mauke> I like bold text for quoting code in speech
14:44:48 <gwern> sounds like some sort of --user or installation location problem
14:44:56 <jeffwheeler> sjanssen: in Data/IntMap/EnumMap.hs:43: Couldn't match expected type `m' against inferred type `Maybe'
14:45:08 <vixey> Only at our University in some of the very highest and most esoteric classes—which I myself have never been privileged to attend—it is understood that the sparing use of Colour is still sanctioned for the purpose of illustrating some of the deeper problems of mathematics. But of this I can only speak from hearsay.
14:45:20 <jeffwheeler> gwern: that makes sense, but I think everything should be installed as --user; I'm never going to root, anyways
14:45:23 <mauke> e.g. fix is defined as cfix f = let x = f x in xc as you can see
14:45:53 <quicksilver> vixey: ;)
14:46:06 <quicksilver> vixey: I used colour frequently when I lectured.
14:46:26 <mmorrow> jeffwheeler: i had to build Yi very manually
14:46:28 <quicksilver> it's a very useful tool to separate disjoint synactic sets
14:46:43 <mmorrow> but i'm using 6.10 and that was Yi 0.4.? ...
14:46:45 <vixey> ooh!
14:46:53 <monochrom> use different fonts
14:46:53 <vixey> I didn't know you lectured
14:46:59 <vixey> I think nobody would listen to me if I tried :p
14:47:02 <jeffwheeler> Here are the changes I had to do to get regex-tdfa to work: http://hpaste.org/12054
14:47:32 <jeffwheeler> mmorrow: Yi (darcs) worked fine until I upgraded to 6.10, and I cleared out all my cabal stuff to start clean
14:47:42 <mauke> fix is defined as ｆｉｘ ｆ ＝ ｌｅｔ ｘ ＝ ｆ ｘ ｉｎ ｘ as you can see
14:48:05 <monochrom> No, the other way round is better.
14:48:09 * quicksilver agrees with mauke.
14:48:39 <jeffwheeler> Is the author of regex-tdfa here? Perhaps those changes would benefit everybody using 6.10.
14:48:43 <ddarius> vixey: It is certain that no one will listen to you if you don't try.
14:49:06 <monochrom> Ｄｏ　ｎｏｔ　ｗｒｉｔｅ　fix = fix
14:49:27 <Saya> fix = \f . (f (x x)) (f (x x)) something like that!
14:49:49 <mauke> 「flip f x y = f y x」 is part of the prelude
14:49:55 <Saya> fix = \f (\x . f (x x)) (\x . f(x x))
14:50:03 <jeffwheeler> @src fix
14:50:03 <lambdabot> fix f = let x = f x in x
14:50:33 <mauke> how many people can see 「quotes」?
14:50:34 <roconnor> http://r6.ca/blog/20060919T084800Z.html
14:50:35 <lambdabot> Title: Y Combinator in Haskell
14:50:55 <roconnor> mauke: I see, but I wouldn't call them quotes
14:50:58 <jeffwheeler> mauke: are they supposed to be odd borders on the top left and bottom right?
14:50:59 <monochrom> I can.
14:51:09 <monochrom> They're quotes in Chinese.
14:51:13 <roconnor> oh
14:51:17 <roconnor> nice
14:51:26 <mauke> jeffwheeler: yes
14:51:37 <vixey> They are cool
14:51:45 <monochrom> “Do not write” fix=fix “because that's bottom”
14:51:58 <mauke> Do not write «fix = fix» because that's bottom
14:52:11 <Saya> what the ?
14:52:12 <mmorrow> jeffwheeler: yeah, a bunch of code-breaking api changes with 6.10 (escpecially wrt to ghc-api)
14:52:15 <vixey> lol
14:52:16 <monochrom> ambiguous natural language should be the one getting quoted because it doesn't compile.
14:52:34 <mauke> Do not ‘write fix = fix’ because that's id
14:52:39 <monochrom> I.e., think of "commenting out".
14:52:39 <jeffwheeler> How can I see where darcs will put something if I use darcs send?
14:53:00 <mauke> jeffwheeler: I'd try --dry-run
14:53:08 <telexicon> wah
14:53:09 <nominolo> jeffwheeler: _darcs/prefs/prefs
14:53:13 <jeffwheeler> nominolo: thanks
14:53:25 <nominolo> jeffwheeler: i *think*
14:54:34 <nominolo> jeffwheeler: hm, apparantly not
14:54:58 <Taejo> > let fix f = f (fix f) in fix (1:)
14:54:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:55:22 <mauke> > fix error
14:55:23 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
14:55:34 <Taejo> mauke: nice
14:55:46 <monochrom> See http://www.vex.net/~trebla/haskell/fix.xhtml for a fix.
14:55:51 <Saya> well that definition is easy you already use recursion which is supposed to use fix which ... ! ! !
14:55:54 <jeffwheeler> Oh well; I'll assume it'll go somewhere useful. :)
14:56:07 <monochrom> Yes!
14:56:14 <nominolo> jeffwheeler: --dry-run shows it
14:56:18 <EmielRegis> hmm
14:56:26 <EmielRegis> i have problem with string formatting
14:56:26 <jeffwheeler> Err, nevermind. Darcs asked for one as soon as I tried to send it.
14:56:34 <jeffwheeler> Apparently there isn't one setup in regex-tdfa.
14:56:35 <EmielRegis> "%f" 1.0 returns type error
14:56:38 <monochrom> My fix.xhtml approaches it by saying you could have invented fix.
14:56:41 <EmielRegis> am I doing it wrong?
14:56:57 <mauke> > "" ++ printf "%f" 1.0
14:56:58 <lambdabot>   "1.0"
14:57:00 <mauke> works for me
14:57:09 <monochrom> Yes, "%f" 1.0 is a type error.
14:57:11 <Twey> EmielRegis: Text.Printf
14:57:17 <EmielRegis> ah
14:57:25 <EmielRegis> i want to write float to string though
14:57:27 <EmielRegis> how would I do that?
14:57:27 <mauke> wait, he tried to call a string literal?
14:57:32 <mauke> EmielRegis: Text.Printf
14:57:42 <Twey> EmielRegis: printf "%f" 1.0
14:57:42 <EmielRegis> it returns a string?
14:57:50 <monochrom> Yes.
14:57:51 <mauke> see above
14:57:52 <Twey> (or just `show 1.0`)
14:57:54 <EmielRegis> okey thanks
14:57:58 <Twey> It does in the right context.
14:57:58 <EmielRegis> and which library is that?
14:58:01 <EmielRegis> Text?
14:58:05 <mauke> Text.Printf
14:58:06 <Twey> EmielRegis: Text.Printf
14:58:10 <EmielRegis> ok danke
14:58:14 <nominolo> EmielRegis: it's result type depends on the context, it' s a bit evil
14:58:14 * Twey laughs.
14:58:29 <monochrom> Pop music has really ruined young people.
14:58:32 <Twey> It's very evil
14:58:40 <Twey> Runtime type checking
14:58:46 <Twey> monochrom: Oh?
14:59:03 <monochrom> You know how pop music repeats the same thing a million times.
14:59:11 <mauke> oh hay, another bug in printf
14:59:13 <Twey> Uh-huh.
14:59:31 <mauke> printf "%f" 1.0 is supposed to return "1.000000", not "1.0"
14:59:32 <Twey> We really need a replacement for printf
14:59:44 <vixey> @go mauke printf
14:59:45 <Twey> Is it?
14:59:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/printf-mauke
14:59:47 <lambdabot> Title: HackageDB: printf-mauke-0.3
14:59:54 <monochrom> So now if you want to say something to young people, you have to say it a million times.  Like in the above.  (Exercise: count how many times Text.Printf is mentioned.)
15:00:05 <ddarius> nominolo: Most things' result type depends on context in Haskell.
15:00:06 <mauke> Twey: yes
15:00:12 <Twey> Hahaha, oh.
15:00:25 <nominolo> :info printf
15:00:39 <nominolo> :t printf
15:00:39 <lambdabot> forall r. (PrintfType r) => String -> r
15:00:45 <Twey> Hm
15:00:48 <nominolo> @instances PrintfType
15:00:48 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
15:00:53 <EmielRegis> ;/ still wont work
15:00:56 <EmielRegis> str = printf ("%f" 1.0)
15:00:59 <EmielRegis> is this wrong?
15:01:01 <EmielRegis> > str = printf ("%f" 1.0)
15:01:02 <lambdabot>   <no location info>: parse error on input `='
15:01:05 <Twey> EmielRegis: Yes.
15:01:06 <monochrom> Yes. Delete ( and )
15:01:10 <Twey> Do you know what brackets mean?
15:01:11 <EmielRegis> > printf "%f" 1.0
15:01:12 <lambdabot>   Add a type signature
15:01:16 <dons> ?users
15:01:16 <lambdabot> Maximum users seen in #haskell: 550, currently: 538 (97.8%), active: 28 (5.2%)
15:01:23 <mauke> delete 「(」 and 「)」
15:01:37 <EmielRegis> ah i uderstand
15:01:50 <EmielRegis> i put it all in one argument
15:01:58 <mauke> if you really want to use parens, try ((printf "%f") 1.0)
15:02:00 <Twey> Delete 『(』 and 『)』 :)
15:02:07 <dons> mauke: interesting bracket operations
15:02:16 <vixey> see I want to write functions called that
15:02:43 <Twey> EmielRegis: printf ("%f" 1.0) means 'apply the "%f" to 1.0, then apply printf to the result'
15:02:52 <vixey> infix isn't enough we should have user defined brackets too
15:02:56 <EmielRegis> ye
15:03:02 <EmielRegis> im getting other errors tho ;/
15:03:14 <sjanssen> vixey: that would be interesting
15:03:15 <Twey> Whereas what you want to say is 'apply printf to "%f", yielding a new function, then apply that function to 1.0'
15:03:19 <mauke> circumfix 「 」
15:03:23 <EmielRegis> 'Ambigous type variable t in the constraints: "Fractional t"
15:03:24 <Saya> we should have multifix too
15:03:32 <vixey> what's multifix?
15:03:33 <ddarius> vixey: No we shouldn't.  If we are going to bother going that far, you might as well have user-defined parsing.
15:03:36 <Twey> EmielRegis: Because of the type magic, you have to give it an explicit type
15:03:51 <mauke> shouldn't Fractional default to Double?
15:03:52 <Twey> > printf "%f" 1.0 :: String
15:03:53 <lambdabot>   "1.0"
15:03:55 <vixey> ddarius, but brackets are really simple
15:04:00 <Saya> (if then else) x y z something like that :p
15:04:03 <EmielRegis> ah
15:04:08 <vixey> Saya, aha
15:04:10 <ddarius> vixey: And once you have brackets people are just going to want something else.
15:04:24 <Twey> And then we have Lisp!
15:04:29 <vixey> ddarius, yeah but I'll have my brackets :)
15:04:35 <EmielRegis> right i got it now
15:04:36 <EmielRegis> thank you
15:04:44 <ddarius> vixey: With a user-defined parser, you can have them.
15:05:06 <Twey> c.f. Greenspun's Tenth
15:05:18 <vixey> What's the most sane haskell parser around?
15:05:20 <monochrom> multifix (f, g, h) = let (x, y, z) = (f (x,y,z), g (x,y,z), h (x,y,z)) in (x, y, z)
15:05:28 <vixey> (i.e. not the yacc crap in ghc)
15:05:30 <dons> vixey: parsec?
15:05:49 <dons> you want combinator parsing or generator-based parsing?
15:06:08 <vixey> :t let multifix (f, g, h) = let (x, y, z) = (f (x,y,z), g (x,y,z), h (x,y,z)) in (x, y, z) in multifix
15:06:09 <lambdabot> forall t t1 t2. ((t, t1, t2) -> t, (t, t1, t2) -> t1, (t, t1, t2) -> t2) -> (t, t1, t2)
15:07:28 <monochrom> It is good for mutual recursion.
15:07:55 <nominolo> vixey: haskell-src-exts
15:09:01 <Saya> well i was thinking about "multiple-infix" but thats nice too :p
15:10:26 <ddarius> vixey: Why do you have that inner let?
15:10:29 <Twey> Validating HTML/XHTML library — do we have one?
15:10:38 <vixey> copy paste artifact
15:11:04 <ddarius> I guess monochrom is who I should be asking.
15:11:18 * monochrom hides!
15:12:47 <vixey> hmf
15:12:58 <vixey> haskell-src-exts is yacc too
15:13:11 <vixey> I don't think I can add arbitrary new specal symbols to one of these
15:13:22 <vixey> (after compiling it)
15:13:25 <nominolo> vixey: well, i don't know what you want to do with it
15:13:35 <Twey> Hmm, HXT does XML validation and XSLT, I guess that'll work?
15:13:47 <mmorrow> untils i can get that js eval code working on lunabot's machine, lunabotjs temporarily does javascript eval
15:13:59 <mmorrow> ) (function(){return 42})()
15:14:00 <lunabotjs>  42
15:14:00 <lunabot>  Killed.
15:14:04 <mmorrow> crap
15:14:23 <nominolo> wow, this is verbose
15:14:41 <monochrom> Oh! I now understand ddarius's question. The outer let is for lambdabot. The inner let is the true let.
15:15:00 <monochrom> The inner let is the same let as in the definition of fix.
15:15:22 <ddarius> monochrom: My question was wrong actually, but close enough.  Why let (x,y,z) instead of let x = ?
15:15:57 <monochrom> I did not want to think too much. Just mimic.
15:16:31 <mmorrow> ) (function(){return 42})()
15:16:31 <lunabotjs>  42
15:16:54 <mmorrow> ) var xs = new Array(10); for(var i=0;i<xs.length;i++) xs[i]=i; xs
15:16:54 <lunabotjs>  0,1,2,3,4,5,6,7,8,9
15:16:59 <mmorrow> ) while(1){}
15:17:02 <lunabotjs>  Killed.
15:17:10 <monochrom> Several neural paths tried to make suggestions, one of them managed a concrete suggestion the earliest (the others were vague), and that was why.
15:18:00 <vixey> col
15:18:07 <roconnor> who do I report lambdabot bugs too?
15:18:17 <vixey> > (\()->42)()
15:18:18 <lambdabot>   42
15:18:42 <monochrom> javascript evaluator?
15:18:47 <mmorrow> oh yesh
15:18:49 <mmorrow> :)
15:19:17 <roconnor> > (\()->42) undefined
15:19:19 <lambdabot>   * Exception: Prelude.undefined
15:19:19 <monochrom> "the moon is a big javascript evaluator made of cheese"?
15:19:38 <Saizan> roconnor: something like @tell Cale
15:19:42 <monochrom> > (\ ~() -> 42) undefined
15:19:44 <lambdabot>   42
15:19:48 <mmorrow> monochrom: it's using this at the bottom level: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=344
15:20:01 <roconnor> @quote CReal
15:20:02 <lambdabot> CReal says: cos(2/3*pi) :: CReal
15:20:04 <mmorrow> spidermonkey jsapi
15:20:14 <vixey> >  cos(2/3*pi) :: CReal
15:20:15 <lambdabot>   0.5
15:20:23 <vixey> >  cos(2/3*pi+1) :: CReal
15:20:24 <lambdabot>   -0.9988864023252176690701376021705050366121
15:20:28 <roconnor> @tell Cale, try the command in @quote CReal.  Can you patch CReal?
15:20:29 <lambdabot> Consider it noted.
15:20:36 <roconnor> er
15:20:41 <roconnor> comma
15:20:47 <roconnor> @tell Cale try the command in @quote CReal.  Can you patch CReal?
15:20:47 <vixey> what should it be??
15:20:47 <lambdabot> Consider it noted.
15:20:52 <vixey> >  cos(2/3*pi+1)
15:20:54 <lambdabot>   -0.9988864023252176
15:20:55 <vixey> >  cos(2/3*pi)
15:20:56 <roconnor> cos(2/3*pi)
15:20:56 <lambdabot>   -0.4999999999999998
15:21:03 <mmorrow> ) Math.cos(2/3*Math.PI)
15:21:03 <lunabotjs>  -0.4999999999999998
15:21:07 <vixey> omg
15:21:12 <vixey> CReal is buggy why?
15:21:18 <vixey> is fewdigits out?
15:21:32 <vixey> I want the one that doesn't have a bug in it.
15:21:32 <roconnor> vixey: It wasn't formally verfied until recently
15:21:41 <roconnor> Lester said he found a few bugs
15:22:12 <roconnor> vixey: fewdigits is no longer under development.
15:22:28 <roconnor> with some effort haskell could be extracted from Coq
15:23:08 <roconnor> vixey: do you typeset inference rules?
15:24:32 <vixey> no sorry
15:24:43 <vixey> I don't know any TeX yet
15:28:14 <mmorrow> vixey: here's a template for .lhs -> tex, including a Makefile that's useful in general fwiw http://code.haskell.org/~morrow/code/haskell/cont-lhs-eg/
15:28:15 <lambdabot> Title: Index of /~morrow/code/haskell/cont-lhs-eg
15:36:47 <mmorrow> ) Date()
15:36:48 <lunabotjs>  Fri Nov 14 2008 17:07:36 GMT-0600 (CST)
15:39:18 <adityam> anyone here using Haskell on arch Linux? How do I install packages with pacman and enable profiling?
15:41:18 <sjanssen> adityam: dons would know
15:42:17 <adityam> ok, I'll wait and see if dons replies
15:44:50 <Savant> I can't figure out why lists can't be of different types. Could anyone explain?
15:45:13 <vixey> Savant, like  [True, "foo", (3,5), Nothing] ?
15:45:25 <sjanssen> @src []
15:45:25 <lambdabot> data [] a = [] | a : [a]
15:45:34 <Savant> vixey: More or less
15:45:48 <mmorrow> , [toDyn True, toDyn "foo", toDyn (3,5), toDyn Nothing]
15:45:52 <sjanssen> Savant: what is the type of [True, "foo"]?
15:46:00 <vixey> Savant, everything in haskell has a type made up in certain way,  [True, False] :: [Bool] (has type [Bool])
15:46:10 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
15:46:12 <mmorrow> lunabot is crushed by make -j10
15:46:13 <vixey> Savant, ["foo","bar","baz"] :: [String]
15:46:17 <mmorrow> , [toDyn True, toDyn "foo", toDyn (3,5::Int), toDyn Nothing]
15:46:27 <mmorrow> , [toDyn True, toDyn "foo", toDyn (3,5::Int), toDyn (Nothing::Maybe ())]
15:46:27 <vixey> Savant, but [True, "foo", (3,5), Nothing] cant have type [Bool] or [String]
15:46:33 <Savant> vixey: Alright, but why can't digits and characters be part of the same list
15:46:36 <mmorrow> > [toDyn True, toDyn "foo", toDyn (3,5::Int), toDyn (Nothing::Maybe ())]
15:46:37 <lambdabot>   [<<Bool>>,<<[Char]>>,<<(Integer,Int)>>,<<Maybe ()>>]
15:46:39 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
15:46:50 <adityam> ?hoogle toDyn
15:46:50 <lambdabot> Data.Dynamic toDyn :: Typeable a => a -> Dynamic
15:47:00 <vixey> Savant, so we have to write (True, ("foo", ((3,5), (Nothing, ())))) :: (Bool, (String, ((Integer,Integer), (Maybe Bool, ()))))
15:47:06 <lunabot>  [<<Bool>>,<<[Char]>>,<<(Integer,Int)>>,<<Maybe ()>>]
15:47:09 <Savant> Ah.
15:47:14 <Savant> Interesting.
15:47:19 <vixey> Savant, ['3','x','7','y'] is fine, :: [Char], or :: String
15:47:24 <vixey> :t ['3','x','7','y']
15:47:26 <lambdabot> [Char]
15:47:30 <vixey> :t "3x7y"
15:47:31 <lambdabot> [Char]
15:47:36 <vixey> > ['3','x','7','y'] = "3x7y"
15:47:38 <lambdabot>   <no location info>: parse error on input `='
15:47:39 <Savant> vixey: Yes, but '3' != 3
15:47:40 <mmorrow> , (True, "foo", (3,5), Nothing)
15:47:42 <vixey> > ['3','x','7','y'] == "3x7y"
15:47:43 <lambdabot>   True
15:47:44 <mmorrow> > (True, "foo", (3,5), Nothing)
15:47:45 <lambdabot>   (True,"foo",(3,5),Nothing)
15:47:57 <vixey> Savant, if 3 :: Integer, and '3' :: Char, 'x' :: Char
15:48:03 <vixey> Savant, then yeah no way to put them in a list
15:48:04 <lunabot>  (True,"foo",(3,5),Nothing)
15:48:12 <FunctorSalad> Savant: you could make a type 'data FooOrBar = Foo | Bar' and have [FooOrBar], though
15:48:29 <Savant> FunctorSalad: Eh.
15:48:48 <Savant> I was just curious, I'm going through this book and it's introducing lists.
15:48:49 <FunctorSalad> Savant: if you need to have a list that can have either Foos or Bars as elements
15:48:55 <vixey> @src Either
15:48:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:48:59 <vixey> that's annoying
15:49:05 <vixey> data Either a b = Left a | Right b
15:49:08 <sjanssen> vixey: strange
15:49:13 <mmorrow> , [Left "asdf", Left "jkl;", Right 819323]
15:49:19 <FunctorSalad> you will have to 'unpack' the elements out of that type manually, though
15:49:27 <FunctorSalad> yes, or use Either :)
15:49:39 <lunabot>  [Left "asdf",Left "jkl;",Right 819323]
15:49:42 <mmorrow> > fmap (either id show) [Left "asdf", Left "jkl;", Right 819323]
15:49:43 <lambdabot>   ["asdf","jkl;","819323"]
15:49:52 <vixey> :t [Left True, Right (Left "foo"), Right (Right (Left (3,5))), Right (Right (Right (Left Nothing)))]
15:49:53 <lambdabot> forall t t1 a b. (Num t1, Num t) => [Either Bool (Either [Char] (Either (t, t1) (Either (Maybe a) b)))]
15:50:06 <Savant> Does this 'learnyouahaskell' book cover most of the fundamentals properly?
15:50:19 <Savant> I think I asked earlier if it came recommended.
15:51:23 <Savant> Hm, I think I'm going to like haskell
15:53:31 <vixey> hmmm
15:55:13 <Savant> It seems wild in a pretty lazy mold.
15:55:31 * roconnor read "in a pretty lazy monad"
15:55:39 * vixey too :p
15:56:00 <vixey> this is nice
15:56:01 <Savant> ha
15:56:15 <Savant> Eh?
15:56:16 <vixey> I can do, [box TyInteger 3, box TyBool True, box TyInteger 23]
15:56:41 <vixey> instead of typing out all that Right (Right (Right (Left ... stuff every time
15:56:44 <roconnor> @type TyInteger
15:56:45 <lambdabot> Not in scope: data constructor `TyInteger'
15:56:51 <vixey> TyInteger :: Ty Integer
15:57:11 <roconnor> @type box
15:57:12 <lambdabot> Not in scope: `box'
15:57:18 <mmorrow> vixey:: that looks like it could be a useful approach
15:57:19 <mmorrow> hmm
15:57:20 <Savant> heh
15:57:23 <vixey> box :: Ty ty -> ty -> Either Integer Bool
15:57:41 <vixey> and then people get confused and think haskell has dependent types which this is not ..
15:57:45 <mmorrow> looks like a perfect fit for a GADT somewhere in there too
15:57:45 <roconnor> Either Integer Bool ?
15:59:05 <roconnor> > (1- (exp(2/3*pi*(0:+1)) -1)^2)/4
15:59:07 <lambdabot>   (-0.12499999999999989) :+ 0.6495190528383289
16:00:21 <roconnor> > (1- (exp(0*pi*(0:+1)) -1)^2)/4
16:00:23 <lambdabot>   0.25 :+ 0.0
16:09:05 <EmielRegis> damit
16:09:09 <EmielRegis> my raytracer aint working
16:09:10 <EmielRegis> :<
16:09:43 <skorpan`> is it not working or aint it working?
16:10:09 <EmielRegis> well, it returns a black image
16:10:15 <EmielRegis> so its not working at all :D
16:10:29 <MisterN> maybe it's too dark
16:10:37 <EmielRegis> nah
16:10:39 <EmielRegis> i messed up somewhere
16:10:45 <EmielRegis> i think I know where even
16:11:02 <monochrom> You ran into dark matter.
16:11:14 <EmielRegis> :D
16:11:18 <MisterN> EmielRegis: just apply some dark magic
16:11:28 <MisterN> ... and Bob's yer uncle
16:11:29 <EmielRegis> i need to revise my intersect function...
16:11:33 <skorpan`> did you make sure to call shade? :P
16:12:08 <nominolo> your objects have all been pulle outside the visible universe
16:13:20 <EmielRegis> skorpan`, tehre is no cell shading in it yet
16:13:27 <EmielRegis> it barely has any shadows at all :P
16:15:54 <EmielRegis> omg im so stupid
16:15:58 <EmielRegis> i make such silly errors lol
16:19:28 <BMeph> EmielRegis: ...well, don't keep us hanging, tell us! We want to laugh, too! ;)
16:20:34 <jpcooper> EmielRegis, ahah
16:20:38 <jpcooper> I tried to make a raytracer
16:20:50 <jpcooper> it was working, I broke it and could never return
16:21:10 <EmielRegis> lol
16:21:38 <jpcooper> which reminds me that it might be interesting to fix it
16:24:50 <MisterN> jpcooper: or start using version control
16:25:19 <jpcooper> yes, good point
16:26:13 <EmielRegis> hmm
16:26:24 <EmielRegis> if I got this
16:26:25 <EmielRegis> data HitT = MISS | HIT | INOBJ deriving (Enum,Eq)
16:26:36 <EmielRegis> MISS == MISS would return true right?
16:26:59 <Saizan> right
16:27:18 <Saizan> you can also try such things at the ghci prompt
16:33:58 <EmielRegis> zomg
16:34:07 <EmielRegis> i just figured all my intersect function return stack overflow
16:34:07 <EmielRegis> :D
16:34:14 <EmielRegis> i must've failed hard somewhere
16:34:45 <Saizan> are they tail recursive?
16:34:50 <EmielRegis> no
16:35:20 <EmielRegis> http://hpaste.org/12055
16:35:24 <EmielRegis> help plz? :P
16:36:39 <reilly> has anyone managed to build HSOpenSSL on 6.10.1?
16:37:51 <ddarius> EmielRegis: I don't believe the problem is in that code and it is a bit silly to return (HitT, Float).
16:38:07 <EmielRegis> ddarius, this code overflows on sample data
16:38:12 <EmielRegis> and why is it stupid?
16:38:25 <ddarius> EmielRegis: That code uses other code.  The problem is probably in the other code.
16:39:34 <Badger> @src mapM_
16:39:34 <lambdabot> mapM_ f as = sequence_ (map f as)
16:40:12 <ddarius> EmielRegis: As for the return value, it might be sensible, but it seems clearer to me to not return a distance if there is a miss, so instead of returning (HitT,Float) modify HitT to be data HitT = MISS | HIT Float | INOBJ Float (?)
16:40:24 <ddarius> Also, Double would be better, probably all around.
16:40:39 <EmielRegis> hmm
16:40:44 <EmielRegis> thats not bad
16:40:47 <EmielRegis> Ill think about it
16:40:50 <Badger> @src sequence_
16:40:50 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
16:48:11 <mmorrow> @type foldl (>>=) return
16:48:11 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a -> a -> m a] -> a -> m a
16:48:52 <mmorrow> @type foldl (>>=) . return
16:48:53 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> [b -> m b] -> m b
16:49:57 <timthelion> hello,  a long while back on this channel, I got into a discussion about a property of pure functions, that their values can be safely stored for later instant recall.  This I believe was called moimization, but google doesn't seem to agree.  Is there another word for this?
16:50:15 <mmorrow> memoization :)
16:50:41 <timthelion> Oh, thank you!
16:50:49 <mmorrow> np
16:51:13 <Saizan> ?google lazy array memoization
16:51:14 <timthelion> I need it for an argument with my history professor about education theory.
16:51:15 <lambdabot> No Result Found.
16:51:48 <Botje> is your history professor also pure and lazy?
16:52:09 <badsheepy> or non functional
16:52:17 <gwern> he's destructive
16:52:35 <mwotton> if you're hoping to change his mind, he'd better be mutable
16:52:41 <gwern> timthelion: how did memoizing pure functions come up in an education theory discussion? times table?
16:52:51 <gwern> mwotton: nah, you just need to return a new professor
16:52:55 <timthelion> No, this is a very agreeable argument about wether it is better to make people memorize things or teach them to understand things.  Of course I promote understanding.
16:53:56 <gwern> timthelion: I wouldn't argue about that. take the example of a programming language or an implementation of an algorithm - should it memoize or recalculate? how on earth could you answer without doing measurements?
16:54:30 <gwern> but with computers at least we can benchmark and say 'yes, with 'fibs' we want to memoize the first n values of 'fibs'', but  you can't benchmark with humans
16:55:02 <mmorrow> but if fibs is done bottom up, you don't need to memoize
16:55:06 <gwern> at best you can discuss specific examples - is it valuable to learn the times table up to 12? to memorize the alphabet? and so on
16:55:31 <timthelion> gwern: but with a person, you cannot know what information they will use in their life.  So how can you know which data they should cache during their education.  I think it is better to increase the students processing speed, improve their abuilities to work without information, and adapt to new information, than to cram them full of data that may soon be very very obsolete.
16:55:36 * mmorrow gropes for an analogy for "bottom up"
16:56:08 <Botje> by construction?
16:56:22 <gwern> timthelion: yes, that's pretty much what I said
16:56:49 <timthelion> gwern: I know that, but he likes large lofty generalizations, HE IS a history professor for goshes sake, they take like half a peice of paper, and claim that all americans wore pettycoats...
16:57:02 <gwern> timthelion: for what it's worth, my personal take is that it's worthwhile to have students memorize stuff in as many areas as possible, because even if you forget something, it's still useful
16:57:55 <gwern> there's a favorite quote of mine from William Johnson Cory - 'nor need you regret the long hours spent on learning, for the shadow of lost knowledge at least protects you from many illusions'
16:58:11 <gwern> it doesn't help that most methods of memorization are extremely inefficient
16:58:13 <timthelion> gwern: I "memorized" my multiplication tables, but forgot almost all of them.  I think that the human brain has it's own built in memoization system though, because after I started algebra, I sudenly knew them.
16:58:17 <mmorrow> so dd if=/dev/urandom bs=1024 count=1024 > a && rm -f a #?? ;)
16:59:02 <timthelion> gwern: I think that in humans, due to our relational minds, the absolute best form of memorization, is not memorization at all, but use.
16:59:16 <gwern> timthelion: memory is a very interesting phenomenon.
16:59:23 <gwern> 'nor need you regret the hours you spent on much that is forgotten, for the shadow of lost knowledge at least protects you from many illusions. ' <-- I was close
16:59:45 <gwern> timthelion: no, the optimal form of memorization exploits the spacing/receny effect Ebbinghaus discovered back in the 1800s
16:59:52 <Riastradh> timthelion, so what was your study of algebra, then?  Use, not memorization?
16:59:55 <gwern> see https://secure.wikimedia.org/wikipedia/en/wiki/Spacing_effect
17:00:24 <timthelion> Riastradh: yes, it was use of the multiplication tables to solve the "more complex" problems.
17:00:27 <gwern> the cool part comes when you devise software which takes into account the spacing effect
17:00:47 <gwern> and can do spaced repetition https://secure.wikimedia.org/wikipedia/en/wiki/Spaced_repetition
17:01:36 <timthelion> gwern: so you would really claim that I did not learn my multiplication tables most efficiently by using them in algebra?
17:02:33 <gwern> yes. you may've memorized them by using them, that I don't doubt. but you would also have memorized them if you had gone over them 10000 times a day
17:03:28 <gwern> you could've memorized them with fewer attempts, is what I mean. when doing algebra you probably used them dozens or hundreds of times a week
17:04:09 <timthelion> The odd thing about the spacing effect, is that in terms of mid term memory, cramming still works exceptionally well.  Cramming produces far superrior mid term memory per effort, then you will gain long term memory with any ammount of effort.
17:04:53 <gwern> how are you defining mid-term?
17:05:16 <gwern> I agree cramming is superior in the short-term - that's why everyone uses it in preference to spacing review
17:05:44 <gwern> if cramming gave you inferior recall in short, mid, and long-term, no one would use it :)
17:06:31 <kynky> i prefer knowing how to find answers than rather knowing all answers
17:06:41 <badsheepy> i prefer to have both :o
17:07:17 <timthelion> gwern: There is a curve for forgetting memory, it's invers exponential I believe.  By the time you take the mid term the next day, you are still very high on that curve, even though that curve may be steeper than the decay curve for spacing... Now if you think about how memory works phisically, with the hipocampus neurons being connected to association neurons, if you add association neurons to the tree(used for recal) you ha
17:07:21 <EmielRegis> is there a good haskell debugger?
17:07:21 <kynky> there is justtoo much to learn
17:07:41 <dolio> There is a haskell debugger.
17:07:41 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
17:07:45 <dolio> I'm not sure about good.
17:07:58 <kynky> unit tests help
17:08:17 <gwern> kynky: I've always felt that you needed to have known many of the answers before you can go finding them
17:08:25 <EmielRegis> dolio, whats its name
17:08:44 <dolio> EmielRegis: GHC releases after a certain point (6.8?) contain it.
17:08:44 <timthelion> kynky: that is what I'm arguing for, against my history teacher.  Specifically, I think that people with a broad range of knowlege on solving problems, are better off than those with a great deal of knowledge in a very specific feild.  Even in that specific feild.
17:08:53 <kynky> gwern, yeah, thats why knowing how to search is a good skill
17:09:05 <gwern> you need to have a good idea of what's in Data.List or the Prelude before you can even know whether you have a need for them
17:09:06 <kynky> so many ppl dont know how
17:09:10 <dolio> You load up your modules in ghci and there are various commands for stepping and breakpoints and such.
17:09:17 <EmielRegis> ah
17:09:34 <EmielRegis> but is there an IDE like Visual Studio where you can set up breakups in more convenient manner?
17:09:42 <dolio> I think there were a couple other experimental haskell debuggers in the past, too, but I couldn't tell you whether they're still viable.
17:09:45 <kynky> timthelion, thats why managers get paid more :)
17:09:59 <dolio> My brain said hood and buddha, perhaps...
17:10:10 <gwern> hood and buddha are both bit-rotten iirc
17:10:37 <dolio> Yeah, I expect that's the case.
17:10:46 <gwern> kynky: questions presuppose a lot of knowledge about the topic. being able to formulate a good question is really valuable. I find that when searching enormous databases such as JSTOR or Google in general, half the battle is knowing the domain-specific terms to use
17:10:50 <hackage> Uploaded to hackage: haskell-src-exts 0.4.1
17:11:08 <gwern> Picasso said, 'I hate computers. They're useless - all they can provide are answers.'
17:11:19 <timthelion> gwern:  it's funny, because my experience with haskell, goes for my teachers argument towards memorization and expertise..  I tried to just pick up haskell like I have every other language, but I didn't know what Prelude and Data.List where, I couldn't just search arround.  Now I am progarmming in python, and I can really figure out what I think I want, and google for that, see 3 lines of code, and copy them, I really can jus
17:11:47 <kynky> gwern, and the ability to quickly disregard spam, even with good terms
17:11:54 <ka> timthelion: your message got truncated at "I really can jus-"
17:12:13 <timthelion> , I really can just search arround, no knowledge necessary.
17:12:22 <gwern> timthelion: yes, exactly. I have no idea half the operators in the Prelude or Data.List, but because I did at one time, part of me knows to ask the question whether Prelude or List has what I want
17:12:28 <lunabot>  luna: Not in scope: data constructor `I'
17:12:29 <gwern> before as a noob I didn't even have that
17:12:48 <kynky> one of the first things my haskell teacher told me, was hat haskell wasreally good at quickly getting code out
17:12:51 <gwern> 'the shadow of lost knowledge', as I said
17:13:04 <EmielRegis> timthelion, thats the power of google! :)
17:13:28 <kynky> the best way to learn is through trial and error, as long as you learn from your errors
17:13:47 <EmielRegis> indeed
17:13:55 <EmielRegis> practice > theory
17:14:26 <timthelion> EmielRegis: but it didn't help me with haskell at all, not because of a lack of results, but because every time I looked up how to open a file, it piled me with words I didn't know, like Monad.  I needed domain specific knowledge, even though I allready knew how to solve the problem.  I didn't know which words to use to express my solution.
17:14:30 <gwern> ('the problem with Wikipedia is that it only works in practice, and not theory' <-- random comment)
17:15:07 <EmielRegis> timthelion, yes I can udnerstand that. I am haskell noob myself and I am often encountering solutions to my problems that I dont really understand :P
17:15:09 <timthelion> gwern: Is this a remark against the arguments against wikipidia?
17:15:31 <gwern> timthelion: it's just one quote I have memorized and seemed vaguely appropriate, is all
17:15:33 <EmielRegis> but i guess this comes with time too
17:15:51 <kynky> timthelion, learning how to deal with side effects etc properly in haskell, is skills that you can transfer to other languages, good programming practice
17:16:23 <gwern> timthelion: I stuff all sorts of quotes and things into Mnemosyne, which is a program which does spaced repetition. sometimes I selected odd things to memorize, and they just come to mind occasionally
17:16:36 <kynky> but you dont have to know why monads work to use them
17:16:45 <gwern> no. I still don't
17:17:31 <timthelion> kynky: I'm almost of the oppinion that my history teacher is correct, specialization is vital to success.  I would even add, that specialization in one thing will help you so much in the others, that you should specialize in one thing, and then do something completely different, because when you specialize,you gain wisdom, and when you move to something completely different, you bring a new perspective.
17:18:16 <BMeph> EmielRegis: practice -> theory
17:18:19 <BMeph> ;)
17:18:35 <EmielRegis> all other way for some :p
17:18:47 <gwern> timthelion: why not just adopt the program metaphor, and say memorization has a cost and its worth paying for instant recall if you use something often enough?
17:18:50 <daf> BMeph++
17:19:16 <BMeph> gwern: "The difference between practice and theory, is that in theory, there is no diffference, while in practice, there is." ;)
17:19:32 <gwern> timthelion: then you can bring up the heavy-duty spaced repetition psychological research, point out that to memorize something for many years requires about 5 minutes of review, and that's the empirical measure
17:19:33 <timthelion> gwern: that's what the brain already does, which is one reason to argue against accadamia, and for field experience.  Because then the brain will know what to memorize.
17:19:58 <kynky> timthelion, the sum is greater than all the individual parts, because you have to be able to apply thatt speciality
17:20:01 <gwern> in those 20 years or whatever, will it take you more or less than 5 minutes cumulatively to find/look-up/rediscover a piece of information?
17:20:16 <gwern> if less, then memorization is a loss. if more, then it's worth memorizing
17:21:17 <gwern> timthelion: if you're wondering where I get the five minutes figure from, it comes from Piotr Wozniak
17:21:21 <timthelion> gwern: We are very different, I've allways been cocky and felt my own quotes where the best.  You actually bother to memorize the quotes of others.  I'd rather come up with better ones on the spot.
17:21:23 <gwern> it's a good rule-of-thumb
17:21:32 <mmorrow> timthelion: i think the ideal is to specialize in specializing, or even to specialize in specializing in speci...
17:21:54 <timthelion> mmorrow: sort of.
17:22:13 <kynky> i like the mentality of an engineer, problem solving
17:22:19 <roconnor> > 623.62+866.85712-2048
17:22:20 <lambdabot>   -557.52288
17:22:45 <gwern> timthelion: I am too much a wikipedian. there is a quote from #wikipedia, in which one person pastes the Greek quote 'Spend your time in studying the writings of the great men to improve yourself', and another chatter replies, 'Heh, that could be rewritten for us as spend your time in editing the writing of others'
17:23:15 <gwern> actually, I have the quote somehwere
17:23:16 <gwern> hold on
17:23:23 <kynky> lol
17:23:38 <gwern> here we go (in wiki format):
17:23:38 <gwern> :''ChrisBradley''<nowiki>:</nowiki> Employ your time in improving yourself by other men's writings, so that you shall gain easily what others have labored hard for.  -[[Socrates]]
17:23:42 <gwern> :''silsor''<nowiki>:</nowiki> ChrisBradley, that could be rewritten for us - Employ your time in improving other men's writings.
17:24:04 <gwern> I have other good WP quotes, like this one:
17:24:05 <gwern> "Wikipedia's articles are no place for strong views. Or rather, we feel about them the way that a natural history museum feels about tigers. We admire them and want our visitors to see how fierce and clever they are, so we stuff them and mount them for close inspection, with all sorts of carefully worded signs to get people to appreciate them as much as we do. But however much we adore tigers, a live tiger loose in the museum is seen as ...
17:24:11 <gwern> ... an urgent problem."
17:24:45 <timthelion> gwern: Sometimes it seems it takes more work to read another mathematicians work, than to look at the presumptions, and the result, and derive the proof ones self.
17:25:24 <gwern> I've often felt that way about haskell programs
17:25:56 <gwern> but that always falls down for me when I discover I really have no understanding of what the author was doing with this clever type business or this composition of monads
17:26:06 <kynky> depends what level of abstraction you need, if you speciallise, you see smaller picture, but know it very well, higher level of abstraction, you can see a better overall picture
17:26:09 <timthelion> Oops, I was picking at something on my keyboard, and found in my hand, "Health warning" "DO NOT REMOVE"
17:26:27 <dons> i sometimes write "-- important" for  tricky bits, so i don't forget :)
17:26:43 <gwern> 'Thanks :). "Just because the Gregorian calendar doesn't have one does not mean that a SW calendar must lack one" - of course.' <-- hee hee
17:26:46 <mwotton> that should be a compiler flag
17:27:08 <gwern> '"the problem with wikipedia is that it works in practice, but not in theory." -[http://slashdot.org/~geekoid geekoid] [http://ask.slashdot.org/comments.pl?sid=179830&cid=14893308]
17:27:09 <lambdabot> Title: geekoid - Slashdot User
17:27:38 <Igloo> SW calendar?
17:27:44 <gwern> Star Wars
17:27:57 <gwern> you see, the EU has a year 0
17:28:00 <dons> worse is better.
17:28:06 <Igloo> Oh, I was trying to think of a technical time phrase  :-)
17:28:08 <gwern> or something like that, and the gregorian doesn't. i think
17:28:28 <Igloo> EU?
17:28:29 <gwern> which lets you parse that triple (?) negative
17:28:35 <gwern> Expanded Universe
17:28:41 <gwern> the games, novels, RPGs, etc etc etc
17:28:48 <Igloo> OK
17:28:59 <kynky> i always think european union
17:32:56 <gwern> @remember ThomasDeQuincey "For if once a man indulges himself in murder, very soon he comes to think little of robbing; and from robbing he comes next to drinking and Sabbath-breaking, and from that to incivility and procrastination."
17:32:56 <lambdabot> It is forever etched in my memory.
17:33:03 <gwern> @quote murder
17:33:03 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
17:33:09 <gwern> ...
17:33:10 <gwern> @quote murder
17:33:10 <lambdabot> ThomasDeQuincey says: "For if once a man indulges himself in murder, very soon he comes to think little of robbing; and from robbing he comes next to drinking and Sabbath-breaking, and from that to
17:33:10 <lambdabot> incivility and procrastination."
17:33:32 <badsheepy> what a lovely quote :d
17:33:44 <lispy> that's very gwern-ish
17:33:46 <lispy> :)
17:33:54 <gwern> yes, it's one of my favorites
17:34:15 <gwern> and to think, if De Quincey hadn't been poor, he never would've written anything
17:34:43 <gwern> kind of sad to think how much great literature we owe to being poor or middle-class
17:36:18 <gwern> @remember Juvenal Quis custodiet ipsos custodes?
17:36:18 <lambdabot> Okay.
17:37:02 <gwern> @remember jb ignazz, I am truly korrupted by yore sinful tzourceware.
17:37:02 <lambdabot> It is stored.
17:37:32 <gwern> @remember geekoid the problem with wikipedia is that it works in practice, but not in theory.
17:37:32 <lambdabot> It is forever etched in my memory.
17:37:59 <gwern> @remember WilliamPietri Wikipedia's articles are no place for strong views. Or rather, we feel about them the way that a natural history museum feels about tigers. We admire them and want our visitors to see how fierce and clever they are, so we stuff them and mount them for close inspection, with all sorts of carefully worded signs to get people to appreciate them as much as we do. But however much we adore tigers, a live tiger loose ...
17:38:01 <gwern> ... in the museum is seen as an urgent problem.
17:38:02 <gwern> oops, I guess that doesn't work
17:38:03 <lambdabot> Done.
17:38:08 <gwern> @quote tigers
17:38:08 <lambdabot> WilliamPietri says: Wikipedia's articles are no place for strong views. Or rather, we feel about them the way that a natural history museum feels about tigers. We admire them and want our visitors
17:38:08 <lambdabot> to see how fierce and clever they are, so we stuff them and mount them for close inspection, with all sorts of carefully worded signs to get people to appreciate them as much as we do. But however
17:38:08 <lambdabot> much we adore tigers, a live tiger loose ...
17:38:24 <gwern> @forget WilliamPietri Wikipedia's articles are no place for strong views. Or rather, we feel about them the way that a natural history museum feels about tigers. We admire them and want our visitors to see how fierce and clever they are, so we stuff them and mount them for close inspection, with all sorts of carefully worded signs to get people to appreciate them as much as we do. But however much we adore tigers, a live tiger loose in ...
17:38:24 <lambdabot> No match.
17:38:30 <gwern> ... the museum is seen as an urgent problem.
17:38:32 * lispy watches as gwern goes over the top with long quotes
17:38:33 <gwern> @forget WilliamPietri
17:38:33 <lambdabot> Incorrect arguments to quote
17:38:51 <gwern> @help forget
17:38:51 <lambdabot> forget nick quote.  Delete a quote
17:39:08 <gwern> hm. then I was write the first time?
17:39:18 <gwern> @forget WilliamPietri Wikipedia's articles are no place for strong views. Or rather, we feel about them the way that a natural history museum feels about tigers. We admire them and want our visitors to see how fierce and clever they are, so we stuff them and mount them for close inspection, with all sorts of carefully worded signs to get people to appreciate them as much as we do. But however much we adore tigers, a live tiger loose ...
17:39:18 <lambdabot> Done.
17:39:40 <snk_kid> is Lemmih in here?
17:39:41 <gwern> ah, the difference was 'in', because 'forget' is shorter than 'remember' so more of the quote made it in
17:39:47 <gwern> @seen Lemmih
17:39:47 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
17:39:59 <gwern> @uptime
17:39:59 <lambdabot> uptime: 1d 23h 5m 22s, longest uptime: 1m 10d 23h 44m 29s
17:40:19 <gwern> snk_kid: lemmi hasn't spoke here in about 2 days. I wouldn't get yer hopes up
17:41:11 <snk_kid> well some needs to know about the cabal package for SDL on  windows is screwed and i want tell him how to fix it
17:41:34 <gwern> email out for some reason?
17:43:10 <lispy> Well, before you email, ask yourself, What Would Knuth Do?
17:43:40 <lispy> and clearly he wouldn't use email except as a last resort: http://www-cs-faculty.stanford.edu/~knuth/email.html
17:43:41 <lambdabot> Title: Knuth versus Email
17:43:49 <snk_kid> keep it to myself :D
17:43:52 <gwern> lispy: he would write out a paper on the flaw. in TeX format. using a fountain pen.
17:44:14 <gwern> and as an anonymous reviewer for this paper, he would suggest at least 3 novel theorems
17:46:21 <gwern> why pen? well, there's a good physics anecdote
17:46:23 <gwern> 'Dirac's writing was famous for its clarity and simplicity. When Niels Bohr was writing a scientific paper - with many hesitations and redraftings, as was his custom, Bohr stopped: "I do not know how to finish this sentence." Dirac replied: "I was taught at school that you should never start a sentence without knowing the end of it." '
17:46:41 <gwern> http://www.dirac.ch/PaulDirac.html
17:46:48 <lambdabot> Title: Paul Dirac
17:47:06 <monochrom> hehehe
17:48:12 <gwern> 'Dirac married "Wigner's sister", so known among the physicists because she was the sister of the noted Hungarian theoretical physicist Eugene Wigner. When one of Dirac's old friends, who had not yet heard of the marriage, dropped into his home he found with Dirac an attractive woman who served tea and then sat down comfortably on a sofa. "How do you do!" said the friend, wondering who the woman might be. "Oh!" exclaimed Dirac, "I am ...
17:48:18 <gwern> ... sorry. I forgot to introduce you. This is...this is Wigner's sister." '
17:49:41 <gwern> 'Once Peter Kapitza, the Russian physicist, gave Dirac an English translation of Dostoevski's Crime and Punishment.
17:49:44 <gwern> "Well, how do you like it?" asked Kapitza when Dirac returned the book.
17:49:47 <gwern> "It is nice," said Dirac, "but in one of the chapters the author made a mistake. He describes the Sun rising twice on the same day." This was his one and only comment on Dostoevski's novel.'
17:50:27 <dolio> Is it time for gwern-repeatedly-posts-large-quotes-from-something-people-could-just-go-read again? :)
17:50:38 <gwern> dolio: it's always miller time!
18:05:51 <roconnor> > 1024/sqrt(2)
18:05:53 <lambdabot>   724.0773439350246
18:09:15 <roconnor> > 2*1024/sqrt(2)
18:09:17 <lambdabot>   1448.1546878700492
18:11:22 <mmorrow> ) (function(k){return(k(2*1024/Math.sqrt(2)))})(function(x){return(x)})
18:11:23 <lunabotjs>  1448.1546878700492
18:11:52 <Raevel_> oh yeah
18:12:55 <Saizan> mmorrow: why in cps?
18:13:19 <mmorrow> Saizan: heh, no particular reason :)
18:14:04 <Raevel_> ) (function (n) {return n?n*arguments.callee(n-1):1;})(5)
18:14:05 <lunabotjs>  120
18:14:06 <mmorrow> gcc 4.2 has been building on lunabot's machine for hours. the javascript eval is in lunabotjs until i can get the eval to work on lunabot's machine
18:14:40 <mmorrow> it segfaults on anything other that simple values with gcc3.somthing (i'm hoping that was the cause ...)
18:15:20 <mapreduce> ) (f = function() { return f() + f(); }; f())
18:15:21 <lunabotjs>  syntax error.
18:15:28 <mapreduce> ) f = function() { return f() + f(); }; f()
18:15:29 <lunabotjs>  syntax error.
18:15:43 <mmorrow> oh yeah, "syntax error." is my catchall ;)
18:15:45 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=344
18:15:56 <mmorrow> the spidermonkey jsapi evaluator ^^
18:16:06 <Saizan> ) var f = function() { return f() + f(); }; f()
18:16:06 <lunabotjs>  syntax error.
18:16:32 <mmorrow> ) f = function(){return(f()+f())}; f()
18:16:33 <lunabotjs>  syntax error.
18:16:38 <mmorrow> ) while(1){}
18:16:38 <mapreduce> ) java.lang.String.valueOf("I hope this doesn't include a Java bridge")
18:16:40 <lunabotjs>  Killed.
18:16:40 <lunabotjs>  syntax error.
18:16:47 <mmorrow> ) Date()
18:16:47 <lunabotjs>  Fri Nov 14 2008 19:47:36 GMT-0600 (CST)
18:17:08 <mmorrow> it should have all the standard js libs/classes in scope
18:17:33 <Raevel_> ) !!new Boolean(false)
18:17:33 <lunabotjs>  true
18:17:58 <mmorrow> ) var xs = new Array(10); for(var i=0;i<xs.length;i++) xs[i]=i; xs
18:17:58 <lunabotjs>  0,1,2,3,4,5,6,7,8,9
18:18:38 <Raevel_> ) setTimeout(function(){for(;;){}}, 0)
18:18:39 <lunabotjs>  syntax error.
18:19:00 <mmorrow> once i get it working inside lunabot and embedded in haskell, we'll be able to generate code with the js quasiquoter and then eval that..
18:19:16 <mmorrow> Raevel_: ah yeah, so DOM stuff isn't there
18:19:56 <Raevel_> ) setTimeout
18:19:57 <lunabotjs>  syntax error.
18:20:02 <mmorrow> it'd be cool if it was though (although i guess you'd have to model the mutations of the doc tree somehow)
18:20:19 <Raevel_> ) window
18:20:20 <lunabotjs>  syntax error.
18:20:25 <mmorrow> just the /core/ javascript classes/etc are there
18:20:26 <Raevel_> what's the global object called?
18:20:31 <Raevel_> ) global
18:20:32 <lunabotjs>  syntax error.
18:20:38 <mmorrow> ) Global
18:20:38 <lunabotjs>  syntax error.
18:20:53 <mmorrow> sigh. i really should find a way to get error messages
18:21:07 <conal> @seen lispy
18:21:07 <lambdabot> lispy is in #haskell-blah, #darcs and #haskell. I last heard lispy speak 37m 27s ago.
18:21:27 <Raevel_> (function(){return this;}).apply(null)
18:21:30 <Raevel_> oops
18:21:37 <Raevel_> ) (function(){return this;}).apply(null)
18:21:37 <lunabotjs>  [object global]
18:21:42 <mmorrow> heh, nice
18:21:51 <snk_kid> http://www.haskell.org/pipermail/haskell-cafe/2008-November/050635.html
18:21:53 <lambdabot> Title: [Haskell-cafe] HSDL 0.5.4 on GHC 6.10.1, http://tinyurl.com/5ronpb
18:21:53 <Raevel_> or
18:21:54 <Raevel_> ) self
18:21:55 <lunabotjs>  syntax error.
18:22:23 <Raevel_> ) (function(){return "setTimeout" in this;}).apply(null)
18:22:24 <lunabotjs>  false
18:22:29 <mmorrow> hmm, i'm not sure exactly the particulars of the context these expressions are being evaluated in
18:23:00 <mmorrow> i painfully scraped through the mozilla docs to figure out how to get a minimal evaluator
18:23:17 <Raevel_> heh, ok
18:23:19 <mmorrow> well, it wasn't /that/ painful. i'm being slightly dramatic
18:23:50 <Raevel_> ) "a".bold()
18:23:51 <lunabotjs>  <b>a</b>
18:23:54 <Raevel_> yay
18:24:28 <mmorrow> this page + that hpaste should get you set up on your machine http://www.mozilla.org/js/spidermonkey/
18:25:29 <Raevel_> ) for(;;){}
18:25:32 <lunabotjs>  Killed.
18:26:23 <Saizan> ah, silly imperative loops
18:27:31 <Cale> What is lunabot?
18:27:31 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:27:49 <Cale> @quote CReal
18:27:50 <lambdabot> CReal says: cos(2/3*pi) :: CReal
18:27:52 <Cale> hmm
18:28:01 <Cale> > cos (2/3*pi) :: CReal
18:28:02 <lambdabot>   0.5
18:28:42 <Cale> Curious.
18:29:47 <Cale> Where is Lennart, I wonder? :)
18:29:55 <Cale> That's his module isn't it?
18:30:41 <Cale> > [cos x | x <- [0,0.1..2*pi]]
18:30:42 <lambdabot>   [1.0,0.9950041652780258,0.9800665778412416,0.955336489125606,0.921060994002...
18:31:48 <Cale> > [fromIntegral (round (10 * cos x :: CReal)) / 10 | x <- [0,0.1..2*pi]]
18:31:52 <lambdabot>   [1.0,1.0,1.0,1.0,0.9,0.9,0.8,0.8,0.7,0.6,0.5,-0.5,-0.4,-0.3,-0.2,-0.1,0.0,0...
18:32:32 <Cale> Interesting discontinuity there. :)
18:34:00 <dolio> > cos 1.1
18:34:01 <lambdabot>   0.4535961214255773
18:34:05 <dolio> > cos 1.2
18:34:06 <lambdabot>   0.3623577544766736
18:34:11 <dolio> > cos 1.3
18:34:12 <lambdabot>   0.26749882862458735
18:34:42 <conal> @tell lispy i'm looking at tweaking the haskell highlighting module for GeSHi, which I guess you wrote, by modifying the ocaml module.  I want to make the apostrophe/tick/prime character be a legal identifier character, as it is in haskell.  maybe one of the REGEXPS fields, but i don't know what they mean.
18:34:42 <lambdabot> Consider it noted.
18:34:52 <dolio> > cos 1.3 :: CReal
18:34:53 <lambdabot>   -0.2674988286245874069979841092928713592759
18:34:56 <dolio> > cos 1.2 :: CReal
18:34:57 <lambdabot>   -0.3623577544766735776383733556230760203399
18:34:59 <dolio> > cos 1.1 :: CReal
18:35:00 <lambdabot>   -0.4535961214255773877713700517847161221215
18:35:05 <dolio> > cos 1.0 :: CReal
18:35:06 <lambdabot>   0.5403023058681397174009366074429766037323
18:43:44 <jsn> can haddock be TeXified?
18:44:26 <gwern> what would that even mean?
18:45:50 <Cale> Either generating TeX/LaTeX from the Haddock annotations in Haskell source, or adding TeX/LaTeX to Haddock annotations and having it rendered as images in the HTML output.
18:46:04 <Cale> (I'm not sure which is meant :)
18:46:45 <ddarius> Or perhaps he wants to rewrite Haddock in TeX.
18:46:57 <Cale> heh
18:47:25 <Twey> You just don't know!
18:48:14 <mmorrow> Raevel_, Saizan: i just put the essential files + an sh script with instructions to build an evaluator identical to the one lunabotjs is using in a darcs repo here: http://moonpatio.com/repos/mm-js/
18:48:19 <lambdabot> Title: Index of /repos/mm-js
18:48:43 <mmorrow> if either of you try to build that and have problems, i probably screwed something up so let me know :)
18:49:34 <Twey> mmorrow: See, when I first heard about this I thought you'd made Haskell bindings for Spidermonkey.
18:49:54 <mmorrow> Twey: no, but that wouldn't be that huge of a leap
18:50:04 <mmorrow> it'd be effort though for sure
18:50:17 <Twey> I don't think it would be that tricky
18:50:35 <Twey> And hey, it's got to be neater than just throwing commands at an external process :-P
18:50:51 <mmorrow> totally, me neither. if you give it a go, let me know how it goes.
18:51:00 <mmorrow> yeah, the external proc thing :(
18:51:32 * Twey nods.
18:51:36 <mmorrow> the alternative (assuming you're wanting to sandbox it with rlimits) is to use forkProcess and communicate via shared memory or an fd
18:51:38 <Twey> I've been meaning to play with the FFI
18:51:56 <mmorrow> go for it
18:52:51 <mmorrow> since using rlimits (System.Posix.Resource), if you exceed the hard limit you die, which is very undesireable if you can't afford to die
18:53:12 <Twey> Aye, hmm
18:53:29 <adu> hi
18:53:37 <Twey> It's not possible to put a limit on a lightweight thread?  Within the runtime?
18:53:41 <Twey> Hey adu
18:53:47 <mmorrow> the alternative is to forkProcess, threadDelay, the kill -9 (via System.Posix.Process/Signals)
18:54:09 <mmorrow> Twey: if the thread isn't allocating, you can't do anything
18:54:18 <mmorrow> *the lightweight thread
18:54:45 <mmorrow> this is Sandbox code i have so far http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=445
18:55:12 <mmorrow> (but i haven't used that code yet in anything other than those tests at the top of file)
18:55:17 <mmorrow> it appears to work
18:55:23 * Twey nods.
18:55:26 <gregwebs> hi, anyone mind helping me with my ghc-6.10 install ?  I tried deleting all my ghc and cabal installs.  After I install ghc-6.10, and run 'cabal install --user binary' I get 'ghc-pkg: package has duplicate dependencies: base-4.0.0.0 (use --force to override)'
18:55:33 <mmorrow> not so sure if i'm using block/unblock correctly though
18:56:34 <Savant> gregwebs: OS?
18:56:38 <Saizan> gregwebs: you need to upgrade your cabal-install
18:56:53 <gregwebs> linux debian, I have run cabal update
18:57:25 <Saizan> cabal update updates the index, but it doesn't update the cabal binary
18:57:41 <Saizan> uhm
18:57:58 <Saizan> or maybe i'm wrong, since an old cabal-install would leak on ghc 6.10
18:58:13 <Saizan> gregwebs: what does cabal --version says?
18:58:33 <gregwebs> cabal-install version 0.4.2
18:58:33 <gregwebs> using version 1.3.3 of the Cabal library
18:58:55 <Saizan> ah, that's way old
18:59:13 <Saizan> run "cabal install cabal-install"
18:59:27 <gregwebs> thanks, I should have came onto irc earlier...
18:59:52 <jsn> I meant, say I have some Haskell source with Haddock in it.
18:59:56 <Saizan> if that doesn't work take the cabal-install tarball from hackage and use the bootstrap.sh script
19:00:06 <Saizan> ?hackage cabal-install
19:00:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
19:01:24 <jsn> and i want to make a TeX document where the Haskell source is wrapped in \code{} and the Haddock text is converted to TeX paragraph text
19:01:48 <jsn> with appropriate markup for @symbol@ and 'symbol' and so forth.
19:02:03 <Twey> jsn: Are you sure you don't want Literate Haskell?
19:02:15 <jsn> Twey: i am sure
19:02:24 <Twey> Right-ho
19:02:37 <mmorrow> oops, make_mm_js.sh had unreadable permissions, just fixed that
19:02:40 <Saizan> ok, so lhs2tex won't help you :)
19:02:51 <jsn> Twey: so if i take your response and annotate it with Bool, it'll be False?
19:04:18 <gregwebs>  ./bootstrap.sh -> Sorry, something went wrong.
19:04:27 <gregwebs> Configuring cabal-install-0.6.0...
19:04:28 <gregwebs> Setup: At least the following dependencies are missing:
19:04:28 <gregwebs> zlib >=0.4 && <0.6
19:04:47 <Saizan> gregwebs: do you have zlib-dev installed?
19:04:55 <gregwebs> cabal install cabal-install
19:04:56 <gregwebs> setup: At least the following dependencies are missing:
19:04:56 <gregwebs> HTTP >=3000 && <3002, zlib >=0.4 && <0.6
19:04:56 <gregwebs> cabal: Error: some packages failed to install:
19:04:56 <gregwebs>   cabal-install-0.6.0
19:04:56 <gregwebs>   zlib-0.5.0.0
19:06:08 <gregwebs> cabal list  | grep zlib
19:06:08 <gregwebs> bzlib [0.2, 0.3, 0.4, 0.4.0.1, 0.4.0.3, 0.5.0.0] Compression and decompression in the bzip2 format
19:06:08 <gregwebs> cabal: Couldn't read cabal file "./delimited-text/0.0.3/delimited-text.cabal"
19:06:24 <Saizan> gregwebs: i mean from apt-get
19:06:51 <Saizan> gregwebs: to compile haskell's zlib you need the header files for C zlib
19:07:18 <Saizan> i'm not sure if the package is actually called zlib-dev?
19:07:27 <gregwebs> zlib1g-dev libzlib-ruby zlib1g
19:08:15 <Saizan> the first one.
19:09:48 <gregwebs> that's from dpkg --list, does that show installed only?
19:10:41 <Saizan> i think so
19:10:46 <gregwebs> yeah, it does
19:11:35 <Saizan> well you should have a zlib directory where you run the bootstrap script, try compiling zlib with runghc Setup from there and see which errors you're getting
19:12:17 <gregwebs> ok
19:18:50 <gregwebs> it works!  there was a hsc2hs left in my bin preventing the cabal bootstrap, and the newer version of cabal works!
19:19:35 <maek> anyone have an rpm/srpm of a recent-ish ghc? thanks.
19:20:49 <Saizan> gregwebs: cool :)
19:21:03 <gregwebs> thanks, Saizan!
19:30:01 * chrisdone spanks mmorrow
19:33:03 <adu> anyone confused about anything?
19:34:33 <mwotton> adu: so much. can you help?
19:34:40 <mwotton> what's it all about? Really?
19:34:44 <adu> mwotton: yes! (maybe)
19:35:32 <adu> mwotton: its all about light (and electrons)
19:36:24 <adu> mwotton: next...
19:37:24 <mwotton> why does my program take so much memory? :)
19:37:30 <dons> you did it wrong.
19:38:22 <Axman6> oh wow, just found a 1400+ page pdf book on assembly, that's seemingly free
19:38:26 <hgolden> Hi. I see that catchDyn has been removed from Control.Exception in ghc-6.10.1. Is this discussed or documented anywhere that I can read? Thanks.
19:38:31 <dons> that's too many pages, Axman6
19:38:35 <Axman6> http://www.matf.bg.ac.yu/~jovana/aoa.pdf is anyone's interested
19:38:38 <lambdabot> Title: The Art of Assembly Language (Brief Contents)
19:38:42 <dons> hgolden: it is in Control.OldException
19:38:54 <mwotton> dons: ... yeah, i got nothing.
19:38:57 <dons> hgolden: but instead, a new, broader extensible exceptions system has been implemented.
19:39:00 <dons> mwotton: hah
19:39:33 <dons> hgolden: that removes the need for separate catch / catchDyn.
19:39:39 <Axman6> mwotton: not enough/too much strictness?
19:39:47 <dons> that's described in simon marlow's extensible exceptions paper
19:39:54 <hgolden> dons: I notice that hdbc-1.1.4 won't compile on ghc-6.10.1. Is this being worked on?
19:39:57 <adu> mwotton: nothing?
19:40:05 <adu> mwotton: you must have something if its slow
19:40:05 <Axman6> i've found both can use large amounts of RAM
19:40:08 <dons> hgolden: probably it does, if it can handle base<4
19:40:15 <dons> hgolden: try building it with cabal-install
19:40:21 <dons> (it'll pick the right version of base to use)
19:40:22 <mwotton> Axman6: yeah, probably. still trying to write an efficient binary instance for Map
19:40:40 <dons> mwotton: new binary got released since last week, btw.
19:40:45 <dons> with the 6.10 fixes.
19:40:56 <mwotton> got a chunked one that sort of seems to work, but i think there's some leak in there still
19:40:59 <adu> mwotton: oh, and when you're estimating memory requirements w.r.t. iteration, you have to use multiplication (not addition) :)
19:41:02 <hgolden> dons: I'm using gentoo's portage version. I'll have to switch to cabal-install
19:41:14 <dons> hgolden: ok. then gentoo's package scripts are out of date.
19:41:26 <dons> you should talk to them (they likely need to add --constraint='base<4')
19:42:01 <hgolden> dons: I'm not sure, but I don't think they allow base.4 and base.3 to coexist
19:42:11 <dons> they must. ghc 6.10 comes with both.
19:42:20 <dons> $ ghc-pkg list base
19:42:20 <dons> /usr/lib/ghc-6.10.0.20081007/./package.conf: base-3.0.3.0, base-4.0.0.0
19:42:22 <dons> :)
19:42:30 <dons> they're just not separate packages
19:42:36 <dons> as they're part of the ghc package
19:42:56 <dons> you should be able to compile hdbc by adding --constraint='base<4' yourself
19:42:58 <hgolden> dons: OK. Thanks. I'll ask on #gentoo-haskell
19:43:12 <dons> hgolden: tell kolmodin this is fixed in Arch Linux ;)
19:43:16 <dons> that'll get him into gear.
19:43:30 <hgolden> dons: I may switch, too!
19:43:33 <dons> heh
19:44:54 <dons> btw kids, Real World Haskell went to the printers today.
19:45:01 <dons> dead trees for all!
19:45:04 <hgolden> dons: Great!
19:45:30 <dons> the military-industrial book distribution business is firing up, and copies will be available globally in short order.
19:45:54 <dons> mwotton: though it might take a while for them to make it on the slow boat to sydney :)
19:49:04 <adu> i want RWH
19:49:12 * adu <3 RWH
19:52:39 <dons> the people's haskell textbook! a rwh for every child! no lambda left unapplied!
19:52:56 <papermachine> no lambda left unapplied?
19:53:05 <solrize> yay!  i'm a lumberjack and i'm ok!!!
19:53:05 <dons> indeed!
19:53:24 <dons> > (\x -> x) -- sad lambda
19:53:25 <lambdabot>       Overlapping instances for Show (t -> t)
19:53:25 <lambdabot>        arising from a use of `s...
19:53:32 <dons> > (\x -> x) '!' -- happy lambda
19:53:33 <lambdabot>   '!'
20:06:59 <conal> dons: did you somehow get web-visible space under your home dir on c.h.o for repos?
20:07:21 <dons> i did. you just ask for an account, then put things in public_html
20:07:37 <dons> darcs repos, anyway
20:08:26 <conal> for a different kind of account from the regular one?  i have a /home/conal, but no public_html.
20:08:30 <conal> dons: ^^
20:08:39 <conal> dons: and what url do you use?
20:09:16 <conal> dons: do you put repos there so as to avoid the wait time in requesting c.h.o projects?
20:10:22 <dons> http://code.haskell.org/~dons/code/
20:10:22 <lambdabot> Title: Index of /~dons/code
20:10:36 <dons> conal: yeah, for lots of the little no-collaboration projects
20:10:45 <dons> if other people need access, i move it out
20:11:02 <dons> but i have lots of little one-off things, or ones where i want to vet patches.
20:12:09 <conal> dons: cool!  and all i had to do was mkdir public_html.  thx.  :)
20:12:48 <dons> yep. :)
20:23:43 <mwotton> seafood: heya sean
20:23:59 <seafood> mwotton: Heya blackdog
20:48:35 <mmorrow> preflex: seen sbahra
20:48:36 <preflex>  sbahra was last seen on ##c 5 hours, 29 minutes and 15 seconds ago, saying: orbitz, ping
20:50:04 <conal> how often are package docs re-generated on hackage.haskell.org?
20:51:04 <mmorrow> > (\x -> x) (\x -> x) -- what kind of lambda is this??
20:51:05 <lambdabot>       Overlapping instances for Show (t -> t)
20:51:05 <lambdabot>        arising from a use of `s...
20:51:25 <mmorrow> "happy only to be let down"?
20:54:29 <ddarius> mmorrow: It's one happy lambda and one sad lambda
21:01:53 <mmorrow> ddarius: and their baby is a sad lambda baby?
21:02:18 <mmorrow> who has nothing to Show for himself?
21:02:33 <Twey> It's (flip const) :)
21:03:13 <ddarius> mmorrow: Actually, somehow there are overlapping instances.
21:03:50 <mmorrow> haha, i realized that after i hit enter and was hoping no one would notice
21:04:27 <mmorrow> hmm, yeah i wonder what the overlap is from
21:06:37 <mmorrow> ) Date()
21:06:37 <lunabotjs>  Fri Nov 14 2008 22:37:25 GMT-0600 (CST)
21:08:24 <Twey> Can we define things for lunabotjs?
21:08:45 <Twey> You can stick 'em in a file and read them in with -f <file> -f -
21:10:50 <hackage> Uploaded to hackage: ZipFold 0.0
21:12:01 <mmorrow> gotta love javascript numbers
21:12:07 <mmorrow> ) 0xffffffff >> 4
21:12:07 <lunabotjs>  -1
21:15:51 <pumpkin_> there's a javascript bot in here? :o
21:16:34 <mmorrow> yes :)
21:16:53 <mmorrow> ) (function(k){return(k(2*1024/Math.sqrt(2)))})(function(x){return(x)})
21:16:53 <lunabotjs>  1448.1546878700492
21:17:44 <mmorrow> pumpkin_: this darcs repo has everything needed to get the same evaluator lunabotjs is using: http://moonpatio.com/repos/mm-js/
21:17:45 <lambdabot> Title: Index of /repos/mm-js
21:17:46 <solrize> is there a strict version of iterate?
21:17:49 <solrize> :t iterate'
21:17:50 <lambdabot> Not in scope: `iterate''
21:18:06 <pumpkin_> wow :) we need a ruby bot and a c bot in here
21:18:08 <pumpkin_> and maybe some python
21:18:23 <pumpkin_> oh, and a brainfuck bot
21:18:26 <jeffwheeler> Or a bot that can send off to many interpreters.
21:18:33 <mmorrow> @bf +
21:18:33 <lambdabot>   fd:5: hClose: resource vanished (Broken pipe)
21:18:37 <pumpkin_> oh
21:18:42 <mmorrow> heh
21:18:50 <mmorrow> it's been broken for months though
21:18:59 <mmorrow> maybe longer
21:19:02 <pumpkin_> :(
21:19:06 <pumpkin_> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
21:19:06 <lambdabot>   fd:5: hClose: resource vanished (Broken pipe)
21:19:13 <pumpkin_> @bff
21:19:13 <lambdabot>  Done.
21:19:23 <mmorrow> wuh
21:19:38 <Twey> Haha
21:19:46 <mmorrow> so it's /not/ broken??
21:20:04 <Twey> http://dynamicdrive.com/forums/showpost.php?p=157741&postcount=1337 — Maybe
21:20:09 <lambdabot> http://tinyurl.com/5a3y2u
21:20:15 <mmorrow> pumpkin_: did that bf code print "Done." or was that some random msg?
21:20:34 <pumpkin_> mmorrow: it was supposed to say hello world, so I assume the Done came from @bff
21:20:55 <pumpkin_> :)
21:21:00 <mmorrow> ah, ok. i was very confused for a second
21:24:23 <mmorrow> being inside two vncviewers gets confusing
21:24:45 <kynky> try 3 :)
21:25:22 * mmorrow faints
21:31:08 <mcnster> hi.  is there a fn that would convert an Int to a String representation in hex?
21:31:22 <solrize> Text.Printf
21:31:27 <solrize> printf "%x" n
21:32:05 <solrize> collatz0 n
21:32:05 <solrize>     | even n = n `div` 2
21:32:05 <solrize>     | otherwise = 3*n + 1
21:32:29 <solrize> that should be strict in n since it pattern matches on n, right?
21:32:34 <solrize> ohhh, (even n) is thunked
21:32:36 <solrize> hmm
21:32:48 <mcnster> solrize, doh!  thanks! :)
21:33:16 <BMeph> > showHex 2343244 ""
21:33:17 <lambdabot>   "23c14c"
21:34:08 <BMeph> > ("0x"++) . showHex 2343244 $ ""
21:34:09 <lambdabot>   "0x23c14c"
21:34:30 <BMeph> If you prefer your hexnums more C-like. ;)
21:35:07 <Twey> > printf "%x" 2343244
21:35:08 <lambdabot>   Add a type signature
21:35:15 <Twey> > printf "%x" 2343244 :: String
21:35:15 <lambdabot>   "23c14c"
21:35:23 <Twey> Hmn
21:35:31 <Twey> What are the instances of PrintfType?
21:40:04 <dejones> Could someone explain Haskell memoization to me?  http://www.haskell.org/haskellwiki/Memoization  -- I don't completely understand the example: memoized_fib, 2 Memoization with recursion
21:40:07 <lambdabot> Title: Memoization - HaskellWiki
21:40:46 <dejones> Mainly, I'd like to memoize a function that returns a Double, instead of an Int, but I can't think of a way to manage to do that.
21:42:48 <mmorrow> > ("0x") . fmap toUpper . showHex $ 9876545
21:42:49 <lambdabot>   Couldn't match expected type `b -> c'
21:43:00 <mmorrow> > ("0x") . fmap toUpper . flip showHex [] $ 9876545
21:43:01 <lambdabot>   Couldn't match expected type `b -> c'
21:43:11 <mmorrow> > ("0x"++) . fmap toUpper . flip showHex [] $ 9876545
21:43:12 <lambdabot>   "0x96B441"
21:45:05 <Axman6> dejones: what sorts of inputs are you using?
21:47:22 <dejones> Axman6: delta :: [Int] -> Int -> Int -> Double
21:47:25 <dejones> That is my function.
21:47:40 <Axman6> and what's it do?
21:48:12 <Axman6> like, do you have the exact same inputs occuring often?
21:49:24 <dejones> Axman6: http://hpaste.org/12057  -- yes, same inputs occur often; the function is recursively called many times.
21:49:45 <dejones> I didn't paste the other functions it calls, but the function could definitely benefit from memoization.
21:50:05 <Axman6> while i'm here, could someone point me to somewhere i could find a library i can use for timing? trying to test the performance of two versions of a function
21:50:25 <mmorrow> > let dtoi64 d = let x = toRational d ; (y,z) = ((fromIntegral . numerator) x :: Int32, (fromIntegral . denominator) x); in ((fromIntegral y::Int64) `shiftL` 32) .|. (fromIntegral z) in dtoi64 pi
21:50:26 <lambdabot>   7676813974955884544
21:50:54 <mmorrow> dunno if that makes sense or is worth doing though in your situation though
21:51:17 <dejones> Axman6: I am using getCurrentTime for timing my functions...
21:51:17 <mmorrow> every day i wish that fromIntegral didn't have such a loooooooooooooooooooong name
21:51:32 <mmorrow> i like `fi' myself
21:51:34 <Axman6> dejones: where's that, System?
21:51:41 <Axman6> @hoogle getCurrentTime
21:51:41 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
21:51:41 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
21:51:51 <dejones> Axman6: import Data.Time.Clock (diffUTCTime, getCurrentTime)
21:52:09 <dejones> That's what I'm using.
21:52:12 <Axman6> cheers :)
21:52:17 <dejones> Axman6: Any suggestions on the memoization?  :)
21:53:07 <Axman6> so the list at the beginning is the same for each pair of ints you put in?
21:53:30 <Axman6> lists seem harder to use memoisation on...
21:54:25 * Axman6 gets confused when function names aren't obvious -_-
21:54:29 <dejones> Axman6: Yeah...
21:55:46 <solrize>     The use of Haskell was a success for this project. A prototype was correctly
21:55:46 <solrize> working within a remarkably short time frame (3 man-weeks), which encouraged
21:55:46 <solrize> us to continue using Haskell. However, we encountered problems with unexpected
21:55:46 <solrize> laziness frequently filling up the heap space. A further 2 months were needed to
21:55:46 <solrize> obtain reasonable resource usage.
21:55:53 <dejones> Axman6: Sorry, this was a class homework that was already turned in that I decided to attempt to add memoization, so the function names are after the equations from the textbook.
21:56:07 <Axman6> ah, i see :)
21:56:28 <Axman6> well, good work on continuing working on it, i love it when i get stuff like that which i want to do
21:56:49 <Axman6> and Data.Time.Clock is perfect, thanks :)
21:57:30 <dons> solrize: interesting.
21:57:42 <dejones> Axman6: Thanks.  Yeah, I already added parallelism to the program, which greatly improved the performance.  So now I want to add memoization.
21:57:44 <dons> you gotta understand evaluation.
21:57:54 <dejones> Hey dons, you ever listen to the Royksopp song?  ;)
21:57:55 <dejones> hehe
21:58:12 <Axman6> dejones: may i ask what the task way? starting to sound interesting ;)
21:58:41 <solrize> dons, quote is from here http://users.aber.ac.uk/afc/papers/ClareKingPADL.pdf
21:58:45 <lambdabot> Title: Data mining the yeast genome in a lazy functional language
21:58:46 <dejones> Axman6: The homework was implementing the Viterbi algorithm for Hidden Markov Models.
21:59:16 <Twey> How does > work on Justs?
21:59:17 <Axman6> righto... i know what markov chains are, apart from that
21:59:22 <Twey> > Just 2 > Just 1
21:59:23 <lambdabot>   True
21:59:32 <Axman6> @src Maybe (>)
21:59:33 <lambdabot> Source not found. There are some things that I just don't know.
21:59:38 <Axman6> @src Maybe compare
21:59:39 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:59:42 <Axman6> rawr
21:59:48 <dejones> Axman6: without memoization, the computation requires computing all of the states over and over, which becomes infeasible as the Markov Model grows.
21:59:49 <Twey> Heh
22:00:12 <dejones> Axman6: Any clue how to add the memoization?  :)  heh.
22:00:32 <Twey> Maybe something like `instance Comparable (Ord a => Maybe a) where`?
22:00:33 <Axman6> ah, maybe i do, since the obvs isn't changing
22:00:43 <dejones> ok
22:01:03 <Axman6> hmm, i'd need to look at a little more closely though. can you give me a sec? just want to get this timing stuff working :)
22:01:51 <dejones> Axman6: Sure.
22:01:58 <dejones> dons: You already in Austin?
22:02:58 <dons> nope. in a few days
22:03:50 <dejones> dons: I wish I could be there; I'd like to see your talk.  Figures that the year I don't go to Supercomputing conference is the year it is in the city I will be living in within a couple of months and I miss Haskell talks!
22:03:56 <jeffwheeler> Coming to beautiful Austin? What?
22:04:21 <dejones> jeffwheeler: You live in Austin?
22:04:31 <jeffwheeler> dejones: I do.
22:05:11 <dejones> jeffwheeler: I'm moving to Austin in January.  :)
22:05:17 <dejones> How's the weather there lately?
22:05:39 <jeffwheeler> dejones: it's a lovely city. Tonight it just got a bit chilly, and the rumor is it might freeze a bit in some places. Weird!
22:05:47 <dejones> lol
22:05:59 <dejones> jeffwheeler: Yea, I am very excited to live in Austin!
22:06:16 <jeffwheeler> It's one of my all-time favorite cities. I love it here. :)
22:06:41 <dejones> jeffwheeler: Awesome.  I can't wait.  I live in cold, sporadic weather Kentucky.  ;)
22:06:59 <jeffwheeler> dejones: heh; what month are you coming?
22:07:06 <dejones> jeffwheeler: January.
22:07:19 <dejones> 1.5months!
22:07:47 <jeffwheeler> dejones: congratulations! :)
22:08:32 <dejones> jeffwheeler: Thanks.  How long have you lived in Austin?  (if you don't mind me asking)
22:08:45 <jeffwheeler> dejones: my entire life (I'm 18).
22:09:02 <dejones> jeffwheeler: Haha, cool.  Going to UT Austin?
22:09:25 <jeffwheeler> dejones: nah, looking to go to a smaller college town somewhere. I've been eyeing University of Illinois at Urbana-Champaign.
22:09:44 <dejones> jeffwheeler: That's cool, definitely a good program there.
22:09:49 <jeffwheeler> (I'm still in high-school at the moment.)
22:09:58 <pumpkin> UIUC is cool
22:10:05 <dejones> Ah.  UT Austin is much, much cheaper for you though, right?
22:10:07 <dejones> ;)
22:10:09 <jeffwheeler> dejones: yeah, it's ranked really highly, and it seems like a wonderful school. I'm pretty excited.
22:10:22 <jeffwheeler> dejones: yeah, and I automatically get in, with the silly top 10% rule. ;)
22:10:29 <dejones> UT Austin is ranked highly too.  ;)
22:10:37 <jeffwheeler> dejones: it is.
22:10:39 <dejones> jeffwheeler: top 10% rule???
22:11:05 <jeffwheeler> dejones: if you're in the top 10% of your high-school class, you automatically get into UT (albeit not necessarily in your chosen department).
22:11:21 <jeffwheeler> dejones: that is, if you go to high-school in Texas.
22:11:27 <dejones> jeffwheeler: Ha, quite interesting.
22:11:27 <pumpkin> you apply to specific departments for undergrad? :o
22:11:55 <jeffwheeler> pumpkin: you indicate what major you intend to graduate with . . . e.g., I've declared I want to study electrical engineering.
22:12:04 <pumpkin> ah
22:12:16 <dejones> jeffwheeler: I think it is common for most undergrad programs to only officially accept the students into the specific program after they do well in the intro courses.
22:12:28 <Axman6> we had an awesome electrical engineering lecturer this semester
22:12:41 <dejones> Axman6: Where at?
22:12:45 <jeffwheeler> dejones: I think that's correct; nonetheless, they all have you indicate what you /intend/ to study.
22:12:52 <Axman6> he was really young, so you could talk to him, and he was into the same stuff as us :P
22:13:03 <Axman6> the australian national university
22:13:17 <dejones> jeffwheeler: Right, that's just declaring a major, you can change that easily.  ;)  heh.
22:13:22 <dejones> Axman6: Ah, cool.
22:13:26 <jeffwheeler> dejones: Err, yeah!
22:13:40 <jeffwheeler> I'm not totally familiar with all the terminology. :P
22:14:05 <Axman6> yeah, very good university :)
22:14:07 <dejones> dons, Cale: Oh infinitely wise Haskell gurus, is there a source where I can read more details/examples for Haskell memoization than the Haskell wiki?
22:14:22 <Axman6> ranked 16th in the world by some organisation
22:14:27 <dejones> jeffwheeler: Yeah, it takes time, heh...
22:14:37 <jeffwheeler> dejones: as it must.
22:16:45 <Axman6> hmm, using if to spark forkIO stuff is annoying when you don't need to spark anything in the else
22:17:05 <dejones> heh
22:18:01 <Axman6> that's an idea... i could just return the current ThreadID
22:22:30 <sjanssen> Axman6: or just stick return () at the end?
22:23:00 <Axman6> hmm, another good idea, and probably a better one
22:28:17 <Axman6> hmm, using STM for lots of tasks using one TVar can slow things down a lot...
22:28:54 <sjanssen> Axman6: contention on a single object is always to be avoided
22:29:48 <Axman6> yeah. it has helped performance in some ways, i'm ot doing redundant work, and it's quite fast with -N1, but -Nn > 1 slows it down massively
22:30:27 <sjanssen> yeah, GHC has to use real locks when multiple threads are allowed
22:31:56 <Axman6> so forkIO + STM = probably not such a great idea, if the forked stuff is small and numerous?
22:32:10 <roconnor> > 2^16
22:32:11 <lambdabot>   65536
22:32:27 <Axman6> dejones: hey, sorry i won't be able to help with the memoisation thing, got to go soon. but i'm sure someone here will be able to help
22:33:00 <dejones> Axman6: thanks anyway.
22:34:01 <dejones> sjanssen: I just saw Conal Elliott's post about memoization with memo tries, based upon your idea.  I am trying to memoize a function, maybe you can provide some insight?
22:34:23 <dejones> http://hpaste.org/12057
22:35:26 <dons> Axman6: probably better to use `par`
22:35:32 <dons> cheaper than forkIO (esp. in the head)
22:37:20 <Axman6> i think you may want to look at something like putting this in your where clause: arr = listArray ((1,1),(maxyoullgetfor t,maxyoullgetfor j)) [((x,y),delta' obvs x y)| x<- [1..maxfort], y <- [1..maxfor j]]
22:37:35 <Axman6> dons: i think i was using it, but i will do so again i think :)
22:38:13 <Axman6> dejones: then you need to make delta' use the data in arr
22:38:23 <dejones> Axman6: Hmm.
22:38:40 <Axman6> i'm missing some stuff there though
22:38:50 <Axman6> like, how to call recursively
22:39:17 <sjanssen> dejones: you could use the memotrie code on hackage
22:39:46 <dejones> sjanssen: I would prefer to implement something myself for the "learning experience."  :)
22:39:47 <sjanssen> dejones: I have a hard time reading this code, does your function have certain bounds for the input?
22:40:02 <Axman6> dejones: yeah, i recommend doing it yourself to see how it works
22:40:05 <dejones> sjanssen: Yes, there are bounds on the input.
22:41:18 <sjanssen> dejones: reasonable small bounds?  If so, you can use an array
22:41:32 <dejones> sjanssen: The other functions aren't really important, just that for a set of inputs [Int] -> Int -> Int, then delta outputs a Double... I think that's all that really matters, I just don't know how to memoize for for those arguments to the function.
22:41:53 <dejones> sjanssen: Yes, small bounds.  If they were very large bounds, would you recommend something other than an array?
22:42:18 <sjanssen> dejones: possibly, especially if the values you'd use are sparse
22:42:37 <sjanssen> an array requires a linear amount of memory wrt. the bounds
22:43:30 <dejones> sjanssen: Is there any papers or something I can read more about Haskell memoization to get a better understanding of how to implement it myself?
22:44:00 <dejones> sjanssen: In this case, I think the array would be fine since the bounds on the input are small, but I'm curious what might be needed for a different case where an array wouldn't satisfy.
22:44:03 <sjanssen> dejones: there is a nice post by Okasaki, lemme find it
22:44:29 <sjanssen> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo
22:44:34 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/u45vz
22:44:40 <sjanssen> describes a memoizing fixpoint
22:45:14 <dejones> sjanssen: Thank you.  Okasaki is great.  :)
22:53:16 <Savant> When I try to build Cabal, it keeps giving off this error:
22:53:17 <Savant> Setup: At least the following dependencies are missing:
22:53:18 <Savant> HTTP >=3000 && <3002, network >=1 && <3
22:53:18 <Savant> Sorry, something went wrong.
22:54:01 <Axman6> 'STMtree: thread blocked indefinitely' huh, not cool
22:54:58 <Savant> Hrm, it looks like cabal is in the repositories for this distro; but not as 'Cabal'.
22:55:17 <Savant> Ah, here it is: libhugs-cabal-bundled
22:55:38 <Axman6> Savant: do you have HTTP and network installed?
22:55:45 <jeffz> Savant, that's for hugs, not ghc though
22:56:22 <Savant> Ah, whoops -- libghc6-cabal-dev/doc/prof is here too.
22:56:43 <sjanssen> Cabal requires HTTP and network now?
22:57:24 <sjanssen> oh, you must mean cabal-insatll
22:57:32 <Savant> Axman6: Well, I got HTTP manually, but its version didn't correspond with the one Cabal wanted to use, apparently.
22:57:51 <Savant> I'll just try via the repository, hold.
23:00:46 <Savant> Oh, hmm.
23:04:34 <Savant> Says I've got it installed, I wonder if ghc-pkg/6 is it.
23:05:57 <Savant> But man ghc-pkg yields nothing.
23:06:00 <Savant> Eh.
23:07:25 <Savant> Well it yields man 7 undocumented
23:11:11 <Savant> Bizzare.
23:12:22 <sjanssen> Savant: you're trying to get cabal-install?  I don't think Debian has packaged that
23:12:43 <Savant> sjanssen: libghc-cabal-dev or something, right?
23:12:47 <sjanssen> Savant: you need to install the package found http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
23:12:53 <lambdabot> Title: HackageDB: cabal-install-0.6.0, http://tinyurl.com/2sj7lw
23:12:54 <sjanssen> Savant: cabal /= cabal-install
23:12:58 <sjanssen> Savant: which one do you want?
23:13:27 <Savant> I tried installing that, but it complained about HTTP/Network, I got those seperately, and tried building them seperately, but Cabal still complains.
23:13:45 <sjanssen> you might have installed bad versions
23:14:02 <sjanssen> Savant: did you look at the version ranges and make sure you had the right versions of HTTP and Network?
23:14:20 <Savant> Yes.
23:15:24 <sjanssen> what is the output of "ghc-pkg list network" and "ghc-pkg list HTTP"?
23:16:00 <Savant> $ ghc-pkg list network
23:16:00 <Savant> /usr/lib/ghc-6.8.2/package.conf:
23:16:00 <Savant> /home/savant/.ghc/i386-linux-6.8.2/package.conf:
23:16:02 <Savant> savant@oven:~/Desktop/cabal-install-0.6.0/HTTP-3001.1.3$
23:16:28 <sjanssen> this indicates network isn't installed
23:17:22 <sjanssen> network should be available in Debian as libghc6-network-dev
23:18:07 <Savant> Ah, hold.
23:18:10 <sjanssen> similarly libghc6-http-dev
23:18:45 <sjanssen> Savant: oh, so you just dropped the directory in cabal-install's root directory?  You have to actually build and install them
23:19:03 <roconnor> grrr
23:19:21 <Savant> sjanssen: I was building and installing them; runhaskell * configure
23:19:22 * roconnor doesn't trust floating point numbers to compute fractals accurately
23:20:08 <Savant> But, one depending on another that didn't exist, it was all pretty poorly documented: but aptitude search libghc instead of cabal, yields some cool stuff.
23:20:12 * roconnor trusts CReal even less :P
23:23:06 <roconnor> > 2^17
23:23:08 <lambdabot>   131072
23:23:13 <Savant> sjanssen: Just a minute, sorry.
23:23:48 <roconnor> > 2^18
23:23:49 <lambdabot>   262144
23:24:00 <Savant> sjanssen: Ah, after getting the libghc-Net/Http I'm able to build Cabal without errors, it's pretty weird that building from source wasn't successful though.
23:24:05 <Savant> sjanssen: Thanks :)
23:24:07 <pa-ching> Hmm, what's a succinct adjective for data structures that store their length explicitly?
23:25:27 <dmwit_> Make one up.
23:26:13 <pa-ching> Quantified... or something :)
23:26:41 <dmwit_> size-indexed
23:27:05 <pa-ching> indexed?
23:27:23 <dmwit_> The name you choose isn't really all that important, as long as you say what it is.
23:27:29 <pa-ching> pretty much yeah.
23:27:41 <mmorrow> sized
23:27:54 <Savant> sjanssen: Yeah, looks like everything works well.
23:28:23 <pa-ching> Yeah, just something short, a valid symbol, and easy to type. Maybe I'll go with sized
23:28:57 <sjanssen> Savant: did you forget "Setup install"?
23:29:22 <mmorrow> i've had this dilemma before also, and sized was the shortest thing i could come up with that wasn't unclear ;)
23:29:39 <Savant> sjanssen: runhaskell Setup.lhs install? No.
23:30:13 <Savant> I was trying that earlier, but the dependencies weren't installed, but now they are, and it worked accordingly.
23:30:40 <Savant> $ cabal --v
23:30:42 <Savant> cabal-install version 0.6.0
23:30:42 <Savant> using version 1.6.0.1 of the Cabal library
23:33:51 <Taejo> @src Monad Applicative
23:33:52 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:34:19 <Taejo> @src [] Applicative
23:34:19 <lambdabot> Source not found. The more you drive -- the dumber you get.
23:35:48 <dmwit_> ?src pure []
23:35:48 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:35:58 <dmwit_> ?src fmap []
23:35:58 <lambdabot> Source not found. Take a stress pill and think things over.
23:36:05 <dmwit_> ?src (>>=) []
23:36:06 <lambdabot> Source not found.
23:36:10 <dmwit_> ?src [] (>>=)
23:36:11 <lambdabot> xs >>= f     = concatMap f xs
23:36:14 <dmwit_> ?src [] pure
23:36:15 <lambdabot> pure = return
23:36:18 <adu> hmm
23:36:21 <dmwit_> ?src Applicative
23:36:22 <lambdabot> class Functor f => Applicative f where
23:36:22 <lambdabot>     pure  :: a -> f a
23:36:22 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
23:36:27 <dmwit_> ?src (<*>) []
23:36:28 <lambdabot> Source not found. Maybe if you used more than just two fingers...
23:36:35 <dmwit_> Oh, well.
23:36:53 <dmwit_> Taejo: pure = (:[]); (<*>) = map
23:37:08 <Taejo> ok
23:37:40 <dmwit_> It's likely that pure = return; (<*>) = liftM will turn any Monad into an Applicative.
23:38:00 <Taejo> likely? or certain?
23:38:23 <dmwit_> I'm not certain.
23:38:27 <sjanssen> dmwit_: you're confused
23:38:33 <sjanssen> (<*>) = ap
23:38:38 <sjanssen> fmap = liftM
23:38:39 <dmwit_> err
23:38:39 <Taejo> is there a reason Parsec's (GenParser a ()) is not Applicative?
23:38:39 <dmwit_> quite
23:38:44 <Taejo> ok
23:38:53 <dmwit_> Taejo: No, Parsec just predates Applicative.
23:39:30 <Taejo> so declaring { pure = return; (<*>) = ap } is the Right Thing?
23:40:06 <dmwit_> Yes, that should be fine.
23:40:38 <adu> > showIntAtBase 17 (" $<>aefhimnoprstu"!!) 41319086693450522803758272385 ""
23:40:39 <lambdabot>   "<$> is the one true fmap"
23:41:52 <sjanssen> lies!
23:41:59 <sjanssen> @src (<$>)
23:42:00 <lambdabot> f <$> a = fmap f a
23:42:40 <Taejo> what's wrong with "instance Applicative (GenParser Char ())..."? GHC says "All instance types must be of the form (T a1 ... an)"
23:43:04 <dmwit_> instance Applicative (GenParser a) where ...
23:43:10 <adu> > showIntAtBase 9 (" $<=>afmp"!!) 114248413663559114 ""
23:43:11 <lambdabot>   "fmap f a = f <$> a"
23:43:38 <dmwit_> adu: The order of the characters in that list is SO WEIRD.
23:43:48 <Taejo> dmwit_: Expected kind `* -> *', but `GenParser Char' has kind `* -> * -> *'
23:43:58 <dmwit_> adu: Ah, I get it.
23:44:05 <Twey> Ack!  Kind errors!
23:44:08 * Twey runs for cover.
23:44:12 <adu> dmwit_: its alphabetic
23:44:15 <dmwit_> right
23:44:33 <dmwit_> Taejo: Okay, then, instance Applicative (GenParser s a) where ...
23:44:34 <dmwit_> ;-)
23:44:38 <Taejo> right
23:44:59 <dmwit_> Taejo: Note the type variables... not particular types.
23:45:06 <dmwit_> Taejo: That's an H98 restriction.
23:45:30 <Taejo> well, I don't mind having the same instance for all types of state, but I'll remember that
23:45:38 <adu> you know, I just realized something
23:45:51 <dmwit_> Taejo: I just meant, that's why you were getting an error originally.
23:45:52 <Taejo> or forget and need #haskell to remind me, as the case may be
23:45:57 <Taejo> dmwit_: ok
23:45:59 <dmwit_> Taejo: Because you used Char and () instead of a and b.
23:46:04 <Taejo> ya
23:46:14 <adu> I'm probably in violation of a few dozen patents on arithmetic coding...
23:47:01 * Twey laughs.
23:47:02 <adu> > showIntAtBase 17 (" !abcdeghimnortuy"!!) 16150834568909561031628853265314 ""
23:47:03 <lambdabot>   "arithmetic coding my butt!"
23:47:15 <Twey> :-P
23:54:22 <mgdtgd> hi
23:54:50 <mgdtgd> I'm trying to approximate pi with using the wallis product
23:55:13 <mgdtgd> 2*2/3*4/3*4/5...
23:56:06 <mgdtgd> piWallis n = fromInteger (2*div numer k) / fromInteger (div denom k) where
23:56:29 <mgdtgd> where n says how many fractions should be used in the calculation
23:56:55 <mgdtgd> the above formula produces NaN for n>256
23:56:59 <mgdtgd> however
23:57:12 <adu> ok
23:57:18 <mgdtgd> piWallis' n = fromRational $ 2*numer % denom where
23:57:28 <mgdtgd> produces the right answer for arbitrary n
23:57:49 <mgdtgd> I can't find the implementation of fromRational
23:58:06 <mgdtgd> so I don't know what I'm doing wrong
23:58:18 <mgdtgd> ah, btw k = gcd numer denom
23:59:08 <adu> mgdtgd: are you using fromInteger in an Integral context? or a Floating context?
23:59:32 <mgdtgd> numer and denom are both Integer
23:59:37 <mgdtgd> n is Integer too
23:59:52 <adu> mgdtgd: but what is the type of piWallis?
23:59:58 <mgdtgd> Integer -> Double
