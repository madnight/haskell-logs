00:08:08 <xhanjian> a newbie question: how can I get a random Int instead of IO Int?
00:09:01 <Cale> xhanjian: An IO Int is a computation which you can run to get an Int. To do so, you use the syntax v <- myIOInt inside a do-block
00:09:20 <Cale> (v will be the result of that computation, an Int)
00:09:32 <Cale> Of course, the do-block as a whole will have an IO type then.
00:09:56 <xhanjian> ic.. that's what I need, thanks Cale
00:10:19 <Cale> xhanjian: If you have a pure algorithm which needs to generate (pseudo) random numbers as it proceeds, it might be easier for it to take a StdGen as a parameter, and thread that along.
00:10:44 <Cale> > randomR (1,10) (mkStdGen 42)
00:10:45 <lambdabot>   (2,1720602 40692)
00:11:13 <Cale> > let (x,g) = randomR (1,10) (mkStdGen 42); (y,g') = randomR (1,10) g in (x,y)
00:11:14 <lambdabot>   (2,2)
00:11:23 <Cale> > let (x,g) = randomR (1,10) (mkStdGen 45); (y,g') = randomR (1,10) g in (x,y)
00:11:24 <lambdabot>   (4,4)
00:11:32 <Cale> > let (x,g) = randomR (1,10) (mkStdGen 92); (y,g') = randomR (1,10) g in (x,y)
00:11:33 <lambdabot>   (2,1)
00:12:03 <Cale> newStdGen (which is an IO action) will give you a StdGen (I think based on the wall clock)
00:13:04 <xhanjian> random number in haskell looks more compliate than in other langs
00:13:20 <Cale> xhanjian: Well, Haskell functions are not allowed to produce different results for the same inputs.
00:13:23 <pumpkin> well random numbers aren't a very "functional thing"
00:14:01 <Cale> xhanjian: So you have to pass the random generator state along by hand, or else use a library which takes care of that for you.
00:14:42 <Cale> There's a MonadRandom package which you can get from Hackage containing a monad which helps thread the generator state along so you don't have to worry about it.
00:14:54 <xhanjian> ic ;p
00:15:00 <TSC> If you're prepared to debase yourself to working completely in IO (like other languages), random numbers are just as they are in other languages (:
00:16:38 <xhanjian> ha ye. Spread IO everywhere in my code is what I do want to avoid :-)
00:17:12 <pumpkin> anyone here know what I'm talking about in my datastructure question above?
00:20:56 <sciolizer> @djinn [a] -> ListT m a
00:20:57 <lambdabot> Error: Undefined type []
00:21:24 <rwbarton> @type msum . map return
00:21:26 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
00:22:35 <sciolizer> awesome, thanks
00:24:32 <solrize_> doesn't GHC Core know about type classes?  I'm looking at the new DPH paper and it says otherwise
00:24:48 <jsn> xhanjian: is System.Random.randomIO really that complicated?
00:26:11 <Cale> jsn: He said he wouldn't like to spread IO throughout his code :)
00:26:24 <jsn> ah
00:26:30 <jsn> is that even possible?
00:26:50 <Cale> Passing StdGens around, yes ;)
00:26:59 <jsn> ah i see
00:27:02 <jsn> interesting
00:27:51 <jsn> learn something new everyday
00:29:06 <solrize_> stdgen's are a bit unsatisfying, there's no way to be sure you don't use the same one twice, right?
00:31:29 <Cale> solrize_: right, except by perhaps carefully designing a library around your use of them which ensures it
00:31:49 <Cale> Which is what the MonadRandom package is.
00:34:22 <solrize_> so your entire program has to sit inside MonadRandom, is that much better than having it sit inside IO?
00:36:47 <adimit> I know that (x:xs) is the best way to split off the first element of a list and use the rest of the list. but how do I split off the last in a similar manner? reverse . head seems inefficient.
00:36:58 <solrize_> :t last
00:36:59 <lambdabot> forall a. [a] -> a
00:37:05 <solrize_> > last [1..5]
00:37:06 <adimit> great :-)
00:37:06 <lambdabot>   5
00:37:16 <adimit> thanks solrize_
00:37:17 <rwbarton> all methods to do this are inefficient.
00:37:27 <solrize_> anyway that would be head . reverse
00:37:41 <rwbarton> If you really care about efficiency, you might want to use a different data structure
00:37:54 <adimit> I don't really, it just seemed awkward.
00:38:34 <adimit> well. no. I have an idea. I will construct the list in reverse. doh!
01:46:41 <paczesiowa> can someone help me write haskell equivalent of "echo logout | nc localhost 57006" ?
01:47:19 <paczesiowa> I got "do h <- connectTo "127.0.0.1" $ PortNumber 57006; contents <- hGetContents h; putStrLn contents; hPutStrLn h "logout"; hClose h", but it doesn't quit
01:49:09 <rwbarton> I think you don't want to use PortNumber
01:49:41 <rwbarton> change "PortNumber 57006" to just "57006"
01:50:10 <paczesiowa> No instance for (Num PortID)
01:50:47 <paczesiowa> PortNumber constructor looks more promising than Service or UnixSocket
01:51:28 <rwbarton> Yeah, never mind, it looks like they fixed the thing I was thinking of.
01:52:25 <rwbarton> Oh
01:52:29 <paczesiowa> I think that hGetContents never finishes
01:52:37 <rwbarton> You should hPutStrLn h "logout"; before putStrLn contents;
01:53:23 <paczesiowa> still nothing
01:53:52 <paczesiowa> when I try to Strict.hGetContents it never finishes
01:53:53 <rwbarton> Maybe you need to flush h?
01:53:58 <rwbarton> Oh, of course
01:54:23 <rwbarton> I mean, I assume what's on the other end is waiting for the logout command before it closes its side of the connection...
01:54:25 <paczesiowa> rwbarton: yeah, that fixed it
01:54:49 <paczesiowa> looks like it's not LineOriented
01:56:28 <paczesiowa> rwbarton: thanks
02:44:14 <quicksilver> unProject really should be a pure function.
02:47:33 <dmwit> unProject?
02:49:48 <ivanm> dmwit: is it related to an antiProject?
02:51:09 <solrize_> closing h doesn't flush it?!
02:52:11 <dmwit> It should.
02:52:56 <paczesiowa> solrize_: if that was related to my problem, than it was never being closed
02:53:05 <dmwit> "Before the computation finishes, if hdl is writable its buffer is flushed as for hFlush."
02:55:51 <ivanm> hClose calls hFlush IIRC...
02:56:34 <dmwit> You RC.
02:58:14 <ivanm> \o/
03:02:08 <u_quark> what should i use instead of throwDyn ?
03:11:53 <paczesiowa> u_quark: what's wrong with throwDyn?
03:12:15 <jkr_> Good morning
03:13:04 <jkr_> Is there a library for bayesian analysis somewhere?
03:13:12 <u_quark> it's not in ghc 6.10.1, no?
03:13:29 <jkr_> I've found a few very good and interesting articles about the topic, but is there a ready-to-use library?
03:14:02 <paczesiowa> jkr_: have you checked hackage?
03:14:59 <jkr_> paczesiowa: Well, kind of - I looked for the word "bayes" on the list :)
03:17:04 <paczesiowa> if it is not on hackage then even if it does exist it's probably in miserable state
03:17:14 <paczesiowa> so I guess you're out of luck
03:17:43 <jkr_> :(
03:20:04 <jeffz> jkr_: try google codesearch: lang:haskell bayesian
03:21:13 <paczesiowa> is there a function to read from a handle until some end-token string is found?
03:21:26 <jkr_> jeffz: Thanks, there are a few promising results
03:24:04 <u_quark> I've waited so long for ghc 6.10 and now nothing compiles with it :( it's somehow depressing ...
03:24:24 <jeffz> nothing compiles with it?  I've compiled several things.
03:24:47 <u_quark> :P ok... *some* things don't compile
03:26:27 <paczesiowa> that's a punishment for using ugly unpure dynamic exceptions
03:26:31 <waern> yi doesn't compile :/
03:26:31 <lambdabot> waern: You have 1 new message. '/msg lambdabot @messages' to read it.
03:27:08 <u_quark> e.g. hint wraps around the ghc API and now it has changed hint needs major refactoring ... so mueval and lambdabot are out-of-the-question ... :(
03:29:27 <u_quark> and gtk2hs uses some old exceptions witch has changed and don't compile either ...
03:30:02 <jkr_> Found a good base for my own implementation at http://spodzone.org.uk/, if anyone's interested ;)
03:30:13 <lambdabot> Title: Spodzone.org.uk
03:30:36 <u_quark> anyway I am just unfairly complaining :P
03:41:55 <EvilTerran> @users
03:41:56 <lambdabot> Maximum users seen in #haskell: 552, currently: 504 (91.3%), active: 12 (2.4%)
03:51:05 <DRMacIver> I just had a major scare. :) I have someone on my follow list on twitter whose icon is superficially like dons's. Current status: "At JavaZone".
03:52:18 <BONUS> haha i hope this isnt dons http://twitter.com/dons
03:52:19 <lambdabot> Title: Twitter / dons
03:52:34 <DRMacIver> No, he's donsbot
03:52:54 <DRMacIver> (that would have been an even bigger scare)
03:53:46 <vixey> lol
03:55:04 <paczesiowa> @hoogle Handle
03:55:04 <lambdabot> System.IO data Handle
03:55:04 <lambdabot> Control.Exception handle :: (Exception -> IO a) -> IO a -> IO a
03:55:04 <lambdabot> Control.Exception handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
03:55:22 <paczesiowa> @hoogle help
03:55:22 <lambdabot> Distribution.Simple.Command CommandHelp :: String -> String -> CommandParse flags
03:55:29 <joelr1> good morning
03:55:32 <paczesiowa> @help hoogle
03:55:32 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
03:55:50 <joelr1> does anyone have a copy of this paper? http://portal.acm.org/citation.cfm?id=1411252
03:56:01 <lambdabot> Title: Experience report
03:57:59 <paczesiowa> (2nd try) is there a function to read from a handle until some end-token string is found?
03:59:13 <ksf> just use hGetString and some stringsearch to cut off what you don't want to have... should be a one-liner.
03:59:49 <paczesiowa> :t hGetString
03:59:50 <lambdabot> Not in scope: `hGetString'
04:00:31 <BONUS> probably means hGetContents
04:00:41 <ksf> yeah.
04:01:49 <paczesiowa> I can't hGetContents because after end-token it will hang - telnet-like connection there is message that ends with "> ------\n" and then it reads another command
04:01:51 <ksf> add http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stringsearch and take and you've got yourself a lean and mean bugger.
04:01:57 <lambdabot> Title: HackageDB: stringsearch-0.2.1.1, http://tinyurl.com/5b84x7
04:02:31 <ksf> use a lazy bytestring
04:03:00 <ksf> or just do all of your parsing with parsec.
04:03:29 <pozic> Did anyone implement a range tree in Haskell?
04:03:39 <paczesiowa> can parsec3 read directly from handle?
04:04:38 <ksf> it can read out of a lazy bytestring, and there's Bytestring.Lazy.Char8.hGetContents
04:09:27 <Figs> Hi. I've got some weird questions that aren't Haskell related, but instead are related to constructs from functional programming being used in languages that allow side effects. (Particularly, the behavior of creating multiple closures in a function...) Does anyone know a good place to discuss that?
04:10:02 <ksf> lambda the ultimate?
04:11:27 <Figs> Do they have an IRC channel somewhere? (I'm only passingly familiar with the site)
04:11:47 <ksf> I'm not aware of one
04:11:57 <pozic> Figs: it's not terribly off-topic here.
04:12:17 <pozic> Figs: especially when there are no other questions.
04:13:09 <pozic> Figs: But I don't see what's special about: f x = (\x -> x +1, \x-> x + 2)
04:13:26 <Adamant> Figs: #scheme is pretty friendly
04:13:48 <Adamant> you could also try #lisp but #scheme is more FP'y
04:14:08 <paczesiowa> Figs: haskell allows side-effects in IO monad, so just ask yout question
04:15:49 <ksf> but then you can't really create closures in haskell functions as each one only takes one argument.
04:16:00 <Figs> Well, mostly I'm just curious about how various languages approach it... (I'll explain what I mean in just a second; trying to find a good way to explain the issue)
04:16:01 <ksf> from another pov, every haskell function is a lot of closures.
04:17:24 <Figs> Basically, if your language allows side effects, then depending on the behavior of the language, the variable in the two closures may either be the same, or different, which makes a difference if you update the value of the variable, yes?
04:18:00 <ksf> yes, but that's impurity, not side-effects.
04:18:20 <quicksilver> you can also distinguish closures which store references to variables
04:18:26 <quicksilver> from closures which store values of variables
04:18:41 <quicksilver> javascript surprises many programmers by storing references in its closures
04:18:56 <quicksilver> (so if you change teh referred variable later, the code doesn't do what you expect)
04:19:00 <Figs> ksf: I may have picked the wrong term; I'm by no means an expert on functional programming :)
04:19:37 <Figs> quicksilver: I think that's what I was getting at.
04:19:37 <ksf> well it's a distinction you can only draw if you've got a pure language...
04:20:48 <pozic> Oh, my example should have contained 2 times (\y -> x + 1), instead.
04:21:34 <olsner> quicksilver: I always thought "standard" closures were the ones with references
04:21:39 <olsner> like in lisp
04:23:37 <paczesiowa> quicksilver: how can you distinguish?
04:26:06 <paczesiowa> :t ref <- newIORef 0; return (do x <- readIORef ref; print x; writeIORef ref $ x+1, do x <- readIORef ref; print x; writeIORef ref $ x-1)
04:26:07 <lambdabot> parse error on input `;'
04:26:35 <paczesiowa> :t do ref <- newIORef 0; return (do x <- readIORef ref; print x; writeIORef ref $ x+1, do x <- readIORef ref; print x; writeIORef ref $ x-1)
04:26:35 <lambdabot> Not in scope: `newIORef'
04:26:36 <lambdabot> Not in scope: `readIORef'
04:26:36 <lambdabot> Not in scope: `writeIORef'
04:27:05 <paczesiowa> :t do ref <- Data.IORef.newIORef 0; return (do x <- Data.IORef.readIORef ref; print x; Data.IORef.writeIORef ref $ x+1, do x <- Data.IORef.readIORef ref; print x; Data.IORef.writeIORef ref $ x-1)
04:27:06 <lambdabot> IO (IO (), IO ())
04:27:25 <Lemmih> dons: There should be an 'encodeMany :: Binary a => [a] -> [ByteString]' function.
04:29:29 <paczesiowa> ksf: if I use hGetContents, I'd have to be very careful not to parse to much or else it will hang on hGetChar. it would look like those early haskell dialog based IO
04:29:39 <paczesiowa> * too much
04:33:47 <olsner> Lemmih: mapM put?
04:34:56 <olsner> (eh, that's wrong though... map (runPut . put) perhaps?)
04:35:48 <Lemmih> olsner: runPut uses a 32k buffer. I'm trying to avoid using n*32k.
04:36:54 <olsner> hmm, but how would you know how much buffer an arbitrary 'a' needs?
04:37:05 <Lemmih> I'm encoding ~1,000,000 small items and the buffer size is killing me.
04:37:25 <Lemmih> olsner: The buffer is resized dynamically.
04:37:53 <ski> @hoogle (w -> a -> r) -> (Writer w a -> r)
04:37:54 <lambdabot> No results found
04:38:19 <olsner> it is? didn't you just say it was using 32k?
04:39:08 <Lemmih> olsner: It'll allocate more if needed.
04:43:17 <ksf> paczesiowa, I wouldn't worry about it.
04:43:47 <ksf> In fact, I once prototyped a HTTP server using that technique.
04:44:17 <ksf> parsec works lazily, so you actually get results for all the things you've already parsed, which should consume exactly as much as you need.
04:44:26 <ksf> lookahead and networking of course don't mix well.
04:45:59 <pozic> ksf: ?
04:46:01 <olsner> bah, newBuffer (max n defaultSize), defaultSize = 32k
04:47:29 <whoppix> Hello everyone. I'm reading "real world haskell", and I think i missed out something important, because I don't understand this syntax: 'sumList (x:xs) = ...'. The part i don't understand is the prototype definition (x:xs). The explanation I've read was: "some thing in front of some other thingies", but that doesn't make it so clear to me. Would anyone bother explaining it to me?
04:47:38 <ksf> you're worried about hGetContents blocking the tail of the list as you don't receive anything untill you send a response to the request before, aren't you?
04:47:57 <paczesiowa> ksf: yes
04:48:27 <paczesiowa> whoppix: sumList list = let x = head list in let xs = tail list in ...
04:49:21 <whoppix> paczesiowa, ah, i see, so it declares a function that takes a list, and x gets the first element from the list given as argument, and xs the rest?
04:49:24 <ksf> just don't have the parser for command n relay on the data for command n+1 and you'll be fine.
04:49:32 <Lemmih> whoppix: This is a list in Haskell: '1:2:3:[]'. The '[]' signals the end of the list.
04:49:40 <ski> whoppix : yes, it's called `pattern-matching'
04:49:48 <ski> @src length
04:49:48 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:49:55 <ski> @botsmack
04:49:55 <lambdabot> :)
04:50:13 <whoppix> Lemmih, so far I've only worked with lists like [1,2,3..] and stuff like that.
04:50:31 <ski> > 1 : 2 : 3 : []
04:50:32 <lambdabot>   [1,2,3]
04:50:35 <ski> > 1 : (2 : (3 : []))
04:50:36 <lambdabot>   [1,2,3]
04:50:37 <Lemmih> whoppix: [1,2,3] is just a pretty way of writing '1:2:3:[]'.
04:50:44 <olsner> the Data.Binary.Builder type looks cool, but I'm itching to rewrite it to keep using the same buffer up until some max size rather than flushing ByteString chunks, and to start at a reasonably low buffer size increasing exponentially up to that max size
04:50:44 <whoppix> Ah, I see.
04:51:09 <whoppix> Thanks a bunch, guys, that helped a lot.
04:51:10 <paczesiowa> > let foo (x:xs) = (x,xs) in foo [1,2,3]
04:51:11 <lambdabot>   (1,[2,3])
04:52:03 <whoppix> paczesiowa, so, formally spoken, that function takes a list and returns a tuple, is that correct?
04:52:15 <paczesiowa> whoppix: yes
04:52:17 <ski> yes (returning a 2-tuple, i.e. a pair)
04:52:28 <whoppix> ok
04:52:36 <paczesiowa> :t let foo (x:xs) = (x,xs) in foo
04:52:37 <lambdabot> forall t. [t] -> (t, [t])
04:54:18 <Beelsebob> @hoogle Array (i,j) a -> Array i (Array j a)
04:54:18 <lambdabot> No results found
04:54:38 <Beelsebob> @hoogle [((i,j),a)] -> [(i,(j,a))]
04:54:38 <lambdabot> No results found
04:54:40 <Beelsebob> :(
04:55:14 * Beelsebob needs curryArray
04:55:53 <Beelsebob> @hoogle [((i,j),a)] -> [(i,[(j,a)])]
04:55:54 <lambdabot> No results found
04:55:56 <MarcWeber> dcoutts_: What is the status about utilizing multiple cores when building with cabal? Or is this a thing which should be implemented in ghc --make ?
04:56:11 <paczesiowa> :t map $ \((i,j),a) -> (i,(j,a))
04:56:12 <lambdabot> forall t t1 t2. [((t1, t2), t)] -> [(t1, (t2, t))]
04:56:37 <paczesiowa> Beelsebob: that fun definition is as long as its type:>
04:57:56 <paczesiowa> MarcWeber: iirc it is still single-core, but there was gsoc guy that was doing framework for make that was supposed to end up in cabal
04:59:19 <Beelsebob> paczesiowa: the incorrect one is, yes
04:59:30 <olsner> Beelsebob: does arrays of arrays even exist in the haskell array library? seems to me you have to make your own array-of-array type that depends on the representation of the (n,m) source array
05:00:05 <Beelsebob> olsner: sure Arrays of Arrays exist -- Arrays can contain anything -- storable, or unboxed arrays can't though
05:02:01 <helge> ghci
05:02:08 <helge> whops
05:03:37 <whoppix> paczesiowa, hm, I think I understand the concept now, but when I try to apply the function to a list, I only get this: 'Non-exhaustive patterns in function sumList'. The function is declared as: 'let sumList (x:xs) = x + sumList xs' and 'let sumList [] = 0'. I try to apply it like this: sumList [1,2,3,4]
05:04:03 <ksf> it's a warning, not an error.
05:04:22 <ksf> you're using a "let" too much.
05:04:32 <olsner> ah, I was thinking of unboxed arrays :) but that array of arrays wouldn't have the same representation as a 2-dimensional array, rather be a list of pointers to arrays
05:04:48 <ksf> introducing two different functions, one definition shadowing the other, instead of defining one function with two cases.
05:05:05 <Beelsebob> olsner: yeh, indeed
05:05:26 <whoppix> ksf, I thought i need the "let" when using ghci.
05:05:40 <ksf> ouch.
05:05:59 <ksf> In all my haskell time, I never figured out how to write multi-line functions in ghci.
05:06:09 <ski> > (==) (array (0,-1) []) (array (1,0) [])
05:06:10 <lambdabot>   True
05:06:10 <ski> > ((==) `on` bounds) (array (0,-1) []) (array (1,0) [])
05:06:11 <lambdabot>   False
05:06:25 <whoppix> ksf, oh, ok. Ill put it in a file. Thanks.
05:06:53 <ski> > (==) (listArray (0,3) [0,1,2,3]) (listArray (1,4) [0,1,2,3])
05:06:55 <lambdabot>   False
05:07:10 <ski> strange
05:07:31 <paczesiowa> > let sumList (x:xs) = x + sumList xs; sumList [] = 0 in (sumList [], sumList [1..10])
05:07:32 <lambdabot>   (0,55)
05:07:40 <quicksilver> paczesiowa: something like "var a = []; for (i=0;i<10;i++) { a[i] = function() { return i; }; }
05:07:59 <ksf> While I'm at it: is there a way to write multi-line expressions in ghci?
05:08:01 <Beelsebob> ski: I think all empty arrays are equal
05:08:14 <ksf> like hitting shift+enter instead of enter or something.
05:08:28 <ski> Beelsebob : but their bounds aren't ..
05:08:44 <Beelsebob> ski: indeed, it's rather odd
05:09:00 <whoppix> ksf, perhaps writing a \ at the end of the line, or something? Ill try that.
05:09:14 <whoppix> nope.
05:09:30 <paczesiowa> quicksilver: I don't get it and I don't know what should I get from that
05:10:38 <paczesiowa> quicksilver: is that the same problem as that famous c# 3.0 that you have to bind i to new var j to get it to work?
05:10:59 <quicksilver> paczesiowa: probably.
05:11:06 <paczesiowa> quicksilver: and it's easy to solve once you use references as different types?
05:11:15 <quicksilver> right.
05:11:19 <quicksilver> it's "obvious" with IORefs
05:11:40 <paczesiowa> ml refs too I think
05:11:51 <quicksilver> yes
05:12:11 <paczesiowa> when will they learn? we need more types
05:15:55 <olsner> @ty \arr -> let ((l1,l2),(u1,u2)) = bounds arr in array (l1,u1) [(i1,ixmap (l2,u2) (\i2 -> (i1,i2)) arr) | i1 <- [l1..u1]] -- Beelsebob got me started and I couldn't stop
05:15:56 <lambdabot> forall t t1 e. (Enum t, Ix t1, Ix t) => Array (t, t1) e -> Array t (Array t1 e)
05:16:35 <Beelsebob> olsner: oh, that's not a bad definition
05:16:45 <Beelsebob> I was going down much more complex linex
05:16:48 <Beelsebob> lines
05:17:12 <paczesiowa> speaking of lines
05:17:29 <paczesiowa> > unlines $ lines "line1\r\nline2"
05:17:31 <lambdabot>   "line1\r\nline2\n"
05:17:55 <paczesiowa> does that bother anyone else?
05:18:33 <olsner> but it's *copying* ... if you move it into GHC.Arr, you should be able to make a non-copying variant that only creates one array of arrays that point into the already existing 2d array
05:18:53 <paczesiowa> you write a script, test it on unix lineends and then it chokes on those damn windows carriage returns
05:20:28 <olsner> really? I thought windows' text file I/O translated \r\n into \n
05:21:19 <paczesiowa> but when you get windows file on unix then it doesn't
05:21:27 <olsner> (unless you run the script on unix with a windows file as input, in which case you might want to write the script explicitly ignore trailing CR's)
05:22:34 <olsner> ... it's not really the job of lines to attempt to correct funky input
05:22:50 <ski> olsner : .. slicing could be nice, too
05:24:22 <olsner> yeah, if IArray included slicing in the public API you wouldn't have to muck about with GHC.Arr to do it
05:26:40 <CalJohn> is it possible to get tabcompletion for ghci in inferior-haskell-mode, or at least to allow ghci's tabcomp to work?
05:32:10 <jeffz`> CalJohn: I have an ansi-term buffer around rather than using the one that haskell-mode creates for ghci interaction, tab completion works for me that way.
05:32:56 <jeffz`> I don't know if ghc 6.10 has tab completion though
05:32:57 <CalJohn> jeffz`: how did you do that?
05:33:17 <CalJohn> my version of ghci certainly has tabcomp, just not in inf-haskell
05:33:21 <jeffz`> CalJohn: C-x 3 M-x ansi-term RET
05:35:17 <CalJohn> jeffz`: hold on, so you're just using an emacs term instead of inf-haskell
05:35:38 <jeffz`> CalJohn: correct
05:36:03 <CalJohn> ha, i was doing it that way until 10 minutes ago ;)  I think i'll go back to that
05:36:26 <CalJohn> it's just, i miss the slime type stuff where you can make the repl load you code from emacs
05:36:32 <CalJohn> nevermind
05:38:01 <ben_h> you can also do git log -p commitish
05:38:07 <ben_h> oops wrong chan
05:43:05 <paczesiowa> what would be faster StateT s (ReaderT r) a or the other way?
05:43:56 <Feuerbach> if .cabal file lists several executables, how can I build just one of them?
05:45:01 <JuanDaugherty> don't use the .cabal file.
05:53:25 <ski> (s/r/m r/)
05:53:40 <ski> @unmtl StateT s (ReaderT m r) a
05:53:40 <lambdabot> s -> m -> r (a, s)
05:53:52 <ski> er
05:53:56 <ski> @unmtl ReaderT r (StateT r m) a
05:53:57 <lambdabot> r -> r -> m (a, r)
05:54:15 <ski> @unmtl StateT s (ReaderT r m) a
05:54:15 <lambdabot> s -> r -> m (a, s)
05:54:27 <Philonous> @go fundep
05:54:32 <lambdabot> http://www.fundep.ufmg.br/
05:54:32 <lambdabot> Title: Fundep
05:55:02 <ski> (ignoring my typos), those seem to be the same, apart from ordering of arguments .. dunno if this would matter
05:59:03 <paczesiowa> so there are fusions involved?
06:06:35 * joelr1 waves
06:08:54 <joelr1> does anyone have this paper? http://portal.acm.org/citation.cfm?id=1411252
06:08:55 <lambdabot> Title: Experience report
06:21:40 * DroneZilla Hi, I got a question, what are differences between newtype, type and data ?
06:21:47 <DroneZilla> and which one are used for what ?
06:21:59 <Beelsebob> DroneZilla: type introduces a type sysnonym
06:22:06 <BONUS> data is for declaring data types with their own constructors
06:22:07 <BONUS> like
06:22:08 <Beelsebob> the left and right can be used interchangably
06:22:09 <mauke> type creates a new name for an existing type
06:22:10 <BONUS> data Bool = True | False
06:22:12 <mauke> data creates a new type
06:22:25 <Beelsebob> as BONUS says, data creates a new type with new constructors
06:22:30 <mauke> newtype is like data, but only for types with exactly one constructor
06:22:37 <BONUS> and one field
06:22:42 <Beelsebob> newtype is like type
06:22:49 <Beelsebob> except that it creates a distinct type
06:22:55 <araujo> morning
06:22:58 <BONUS> anyway
06:22:58 <LarstiQ> DroneZilla: what mauke, BONUS and Beelsebob are saying ;)
06:22:59 <Beelsebob> and because the *new* type is distinct, you must add a constructor name
06:23:03 <mauke> Beelsebob: i.e. it's completely unlike type :-)
06:23:17 <BONUS> you know how you can use String and [Char] interchangeably in type declarations?
06:23:18 <Beelsebob> mauke: yeh, I'd argue it's closer to type than to data though
06:23:27 <BONUS> that's achieved like: type String = [Char]
06:23:27 <mauke> Beelsebob: not to the programmer
06:23:34 <Beelsebob> newtype creates a new type that's equal to a pre-existing one mauke
06:23:39 <Beelsebob> type creates one that's equal in name too
06:23:53 <BONUS> anyway, here's a strange request
06:24:03 <BONUS> how would you go about launching a pdf from a haskell program in windows?
06:24:16 <Beelsebob> BONUS: launching a pdf?
06:24:17 <LarstiQ> execute 'start file.pdf'?
06:24:34 <olsner> BONUS: runCommand ("start " ++ filename) probably
06:24:36 <BONUS> if i just use System.Process.runCommand and give it a parameter of "something.pdf" the ugly commandline box thing
06:24:40 <BONUS> ah start
06:24:40 <DroneZilla> Ok thanks everybody
06:24:41 <BONUS> yeah
06:25:17 <BONUS> eh no, start lanuches that ugly commandline box for a second too
06:25:45 <BONUS> i.e. main = runCommand "start something.pdf"
06:26:03 <olsner> ah, maybe runCommand is the wrong thing... I'm just not sure if start is a cmd command or an executable somewhere
06:26:37 <mauke> rawSystem "start" [filename]
06:26:46 <BONUS> ah
06:27:01 <BONUS> @hoogle rawSystem
06:27:02 <lambdabot> System.Cmd rawSystem :: String -> [String] -> IO ExitCode
06:27:02 <lambdabot> Distribution.Simple.Utils rawSystemExit :: Verbosity -> FilePath -> [String] -> IO ()
06:27:02 <lambdabot> Distribution.Simple.Program rawSystemProgram :: Verbosity -> ConfiguredProgram -> [ProgArg] -> IO ()
06:28:01 <jeffz> BONUS: probably by using shlwapi
06:28:47 <BONUS> hmm rawSystem does that too :X
06:28:50 <profmakx> hm cabal-install xml -> 4GB ram usage -.-
06:29:05 <BONUS> shlwapi?
06:29:09 <luite> BONUS: I think rawSystem uses an api call like ShellExecute internally
06:29:15 <BONUS> curses!
06:29:25 <mauke> windows--
06:30:04 <luite> hm, what is actually the correct way to 'run' a pdf file in linux?
06:31:22 <Raynes> Double click it. :D
06:31:31 <luite> Raynes: from a haskell program ;)
06:31:43 <Raynes> (:
06:31:54 <olsner> maybe if you runProcess start.exe instead
06:33:15 <BONUS> as in main = runProcess "start.exe" ["blah.pdf"]
06:33:16 <mauke> luite: you don't run pdf files, they're not programs
06:33:17 <BONUS> ?
06:33:17 <LarstiQ> luite: under gnome tat would be 'gnome-open'
06:33:35 <olsner> BONUS: yeah, plus whatever extra arguments runProcess takes
06:33:43 <LarstiQ> mauke: s/run/let the file handlers handle the file/
06:33:59 <mauke> LarstiQ: there are no file handlers
06:34:04 <BONUS> i dont think that would work cause if you do start -> run and then type in start.exe it won't find it
06:34:11 <BONUS> hmm interesting
06:34:16 <LarstiQ> mauke: sorry, filetype handlers.
06:34:24 <mauke> NO SUCH THING
06:34:24 <Beelsebob> @src Num
06:34:25 <lambdabot> class  (Eq a, Show a) => Num a  where
06:34:25 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:34:25 <lambdabot>     negate, abs, signum     :: a -> a
06:34:25 <lambdabot>     fromInteger             :: Integer -> a
06:34:30 <LarstiQ> mauke: excuse me?
06:34:51 <mauke> hmm?
06:34:52 <luite> mauke: that's why I quoted it, I meant 'open using the default viewer'
06:35:01 <mauke> linux has no default viewers
06:35:14 <LarstiQ> mauke: that is why I mentioned the specific environment where that is defined.
06:35:30 <luite> LarstiQ: does kde have such a command?
06:35:33 <LarstiQ> luite: OSX has 'open', no clue what kde does.
06:35:37 <luite> ok
06:35:38 <LarstiQ> luite: but I'm sure it does.
06:36:05 <luite> well, guess it's off-topic in here, so I'll find it myself :)
06:38:07 <olsner> BONUS: you could also try something like rawSystem "blah.pdf" []
06:38:50 <olsner> depends a bit on where the windows people have put the magic that lets you run arbitrary files in cmd and the run box
06:38:59 <ManateeLazyCat> Hi, everyone. Today I use cabal install XMonad, get error information "
06:38:59 <ManateeLazyCat> Could not find module `Graphics.X11.Xlib.Extras' ". And I before have
06:38:59 <ManateeLazyCat> install XMOnad success. I use Debian and GHC 6.8.2. Thanks
06:39:50 <jeffz> BONUS: luite mentioned before, ShellExecute - pretty sure that's what Java makes available in it's "desktop integration" stuff in java 6 for opening files with the default handler
06:40:42 <dcoutts> ManateeLazyCat: sounds like your X11 haskell package is borked
06:43:15 <ManateeLazyCat> dcoutts: Because I use GHC 6.8.2 (Debian), so i have install cabal with compile, I have compile cabal success, but when i use cabal upgrade or install XMonad will got error information. I'm a newbie of Haskell, so any suggestions?
06:44:49 <dcoutts> ManateeLazyCat: my guess is that your X11 Haskell package is registered but that the files got deleted for some reason
06:45:13 <dcoutts> so cabal thinks X11 is installed, but when it comes to compile then ghc cannot find the files
06:45:51 <dcoutts> ManateeLazyCat: if you want to confirm that theory, use ghc-pkg describe X11 and look in the import-dirs for the .hi files corresponding to the module `Graphics.X11.Xlib.Extras'
06:48:51 <BONUS> jeffz: w00t thanks!
06:48:53 <BONUS> i'll try it out
06:50:16 <BONUS> hmm
06:50:20 <BONUS> where's shellExecute located
06:50:47 <jeffz> BONUS: if it's not in the win32 package you might have to write your own ffi definition for it
06:50:59 <BONUS> ah i see
06:52:24 <ManateeLazyCat> dcoutts: Thanks, I have got two import-dirs "~/.cabal/lib/X11-1.4.4/ghc-6.8.2" and "/usr/lib/X11-1.4.2/ghc-6.8.2", and first directory is not exist, so to repair this problem, need to reinstall cabal again?
06:52:51 <dcoutts> ManateeLazyCat: the fix would be to cabal install x11 --reinstall
06:53:37 <dcoutts> ManateeLazyCat: for some reason that file got deleted (perhaps you cleared everything out at some point?) but the package was not unregistered.
06:55:31 <ManateeLazyCat> dcoutts: I remember, yesterday i type wrong command to delete everythin in "~/.cabal", so got error information.
06:56:10 <dcoutts> ManateeLazyCat: if you deleted the whole of ~/.cabal then you'll find that all of your locally registered packages have that problem
06:56:46 <dcoutts> ManateeLazyCat: if you want to clear it out properly, you'd need to delete ~/.cabal and ~/.ghc/ghc-$version-$arch/package.conf
06:57:05 <dcoutts> that'd unregister all the per-user packages too
06:59:49 <ManateeLazyCat> dcoutts: So you mean i need to delete "~/.cabal" and "~/.ghc/ghc-$version-$arch/package.conf" to clear all package that use cabal. And then i can use cabal reinstall package and have not above error?
07:00:24 <FunctorSalad_> does anyone else sometimes find themselves writing lots of functions of the form gazonk2qux where Gazonk and Qux are some specialized types in your program, and this is the only function of that type?
07:00:33 <FunctorSalad_> I'm wondering whether there is some abstraction lurking there
07:00:34 <dcoutts> ManateeLazyCat: that would wipe everything clean. (apart from global packages, but those will be ok)
07:01:08 <dcoutts> FunctorSalad_: not necessarily, you'd expect that kind of thing in a functional program.
07:01:11 <FunctorSalad_> (of course, there's class Convertible a b where convert :: a -> b)
07:01:22 <dcoutts> FunctorSalad_: which is just.... a function!
07:01:27 <FunctorSalad_> :)
07:01:44 <dcoutts> it doesn't really tell you much about the relationship of the types beyond there being a function between them
07:01:55 <dcoutts> and overloading that name is probably not of huge benefit
07:03:25 <dcoutts> FunctorSalad_: if there was a more specialised relationship then there's more of an argument, eg if there's a total injection and partial-projection, ie an embedding between the types
07:04:32 <ManateeLazyCat> dcoutts: Thank you very much! I try do that.... :)
07:05:13 <FunctorSalad_> dcoutts: I've been thinking of that sort of function to simulate 'subtypes' too
07:05:36 <FunctorSalad_> dcoutts: another specialization would be that any conversion path from a to b must be the same function
07:06:09 <dcoutts> FunctorSalad_: yes
07:06:47 <dcoutts> FunctorSalad_: eg we've got a class like that in our QC tests for strict and lazy bytestring, since there's that kind of relationship between String, strict ByteStrign and lazy ByteString
07:06:59 <dcoutts> it lets us write some of the properties in a more generic fashion
07:13:43 <mattam> FunctorSalad_: It's called coercive subtyping in type theory and has been extensively studied. It's at the basis of dealing with hierarchies of structures in Coq.
07:14:24 <mattam> The conditions on the coercions are generaly called coherence conditions and most of the time are undecidable :)
07:15:54 <FunctorSalad_> sure, in haskell we already ask the programmer to check other undecidable laws manually
07:16:03 <mattam> Indeed.
07:17:37 <mattam> It's sufficiently nice that you can have coercions to "function class" for example, automatically coercion an object of record type to a function (by taking some projection) or a type.
07:19:27 <EmielRegis> @source (>.>)
07:19:27 <lambdabot> (>.>) not available
07:21:18 <ski> (>.>) = flip (.)
07:21:53 <granden> Hi
07:22:02 <Beelsebob> has anyone got any idea where I would find information of algorithms for chosing a good colour table for a random image?
07:23:06 <u_quark> has anyone build gtk2hs with ghc 6.10 ?
07:23:08 <granden> Anyone who would mind helping me with a haskell script. I get an errror on line 27 saying, "0: parser error (possible incorrect indentation)"
07:23:18 <granden> http://pastebin.com/m5d7701e8
07:23:34 <mauke> granden: missing = in line 25
07:25:36 <granden> mauke: Thanks, *ashamed*
07:28:57 <pozic> Beelsebob: what should the colour table do?
07:29:40 <Beelsebob> pozic: it should be a list of colours that can be used to make up a (degraded) copy of the image, by storing colour table indicies rather than colour values
07:31:01 <pozic> Beelsebob: so a sort of lossy compression?
07:31:15 <Beelsebob> yeh, but in this case I don't want it for compression purposes
07:31:32 <Beelsebob> I'm writing a program for generating cross stitch patterns from images
07:31:44 <Beelsebob> one part of which is chosing a good selection of threads
07:32:21 <mauke> huhu, just compile with -threaded
07:35:13 <pozic> Beelsebob: why would the image be degraded?
07:35:31 <Beelsebob> pozic: because usually your colour table contains fewer colours than the image does
07:35:46 <Beelsebob> in this case, it's also likely that some of the colours in the image have no thread that exactly matches
07:35:52 <kuribas> Beelsebob: You mean quantization?
07:36:38 <Beelsebob> kuribas: I can already do the quantization part -- what I'm not sure of how to do is generating a "good" set of colours to put in the table
07:37:02 <Beelsebob> i.e. if I have an image of a fire, it's a bad idea to fill the colour table with blacks, and greens
07:37:19 <Beelsebob> but instead to say "hey, buy a bunch of red, yellow and orange thread"
07:37:28 <kuribas> Hm, I thought that's what quantization is about.
07:37:50 <Beelsebob> oh, I thought quantization was the step where you said "hey, I have this discrete set, how do I get these values to fit it"
07:37:54 <Beelsebob> rather than generating the discrete set
07:38:08 * Beelsebob goes a-googling again
07:38:21 <kuribas> Maybe there's something here: http://en.wikipedia.org/wiki/Color_quantization
07:38:23 <lambdabot> Title: Color quantization - Wikipedia, the free encyclopedia
07:38:27 <Beelsebob> thanks :)
07:39:39 <Beelsebob> hmm, that article is really bad
07:39:47 <Beelsebob> here's a quantization matrix:
07:39:49 <Beelsebob> blah
07:39:59 <Beelsebob> and... *what* makes it a quantization matrix, rather than any other
07:40:02 <Beelsebob> how is it used?
07:40:03 <Beelsebob> etc
07:40:04 <hoknamahn> guys, could you tell me. I have a list of vectors. how better to represent those vectors from the point of view of efficiency, readability, availability of standard library functions etc. as list or as tuple? the length and type of vector is fixed i.e. float, float, float. what do you think? if length is fixed seems logical to use tuples, but type is the same for each component so list is better...
07:40:43 <ksf> tuple, or, preferrably, roll your own datatype.
07:40:48 <Beelsebob> hoknamahn: define a dependantly typed vector data type with type families :D
07:40:50 <ksf> look at how the gl bindings do it, too.
07:41:03 <Beelsebob> I think a few people have done that over the past few days
07:41:24 <ksf> something like data = Vec3d !Double !Double !Double
07:41:27 <paczesiowa> or many people with fundeps over past few years
07:41:54 <hoknamahn> arhh I did it :)
07:42:21 <hoknamahn> I'm just wondering what is better - list or tuple. when to use list when better to use tuple
07:42:30 <Beelsebob> hoknamahn: you *may* also just want to grab the vector-sapce package
07:42:31 <Beelsebob> :D
07:42:37 <Beelsebob> which deals with this for you
07:42:41 <hoknamahn> noooo... :D
07:42:45 <ksf> note the !'s to unbox the Doubles, if you're using -funbox-strict-fields, too, you won't have any doubles outside of registers.
07:42:57 <hoknamahn> i did it as
07:43:09 <hoknamahn> data Vector3 = V3 !Scalar !Scalar !Scalar
07:43:17 <hoknamahn> so my question is a bit different
07:43:19 <hoknamahn> :)
07:43:33 <hoknamahn> when tuples and when lists
07:43:51 <hoknamahn> in the situation when we have same types and length
07:43:59 <paczesiowa> lists when you don't know lenght until runtime
07:44:01 <hoknamahn> like float float or int int
07:44:31 <hoknamahn> so if I know the length tuples are better anyway?
07:44:33 <paczesiowa> using (a,a) type system takes care of empty lists
07:45:04 <paczesiowa> it sure is safer - I call it better
07:45:30 <paczesiowa> and with those unboxed fields it will be faster
07:45:47 <Beelsebob> strictifying things isn't always faster
07:45:50 <Beelsebob> in fact, it's often slower
07:45:58 <Beelsebob> it will certainly consume less ram though
07:46:19 <Beelsebob> (assuming it doesn't go off into an infinite loop)
07:46:25 <aeolist> i am struggling to understand the whole laziness thing, is there a tool with which i can observe how everything gets evaluated in a given prog?
07:46:36 <Beelsebob> aeolist: hat-anim
07:46:40 <Beelsebob> part of the Hat tools
07:46:40 <aeolist> is hat trail or observe supposed to help with that
07:46:50 <aeolist> oh, you were faster than me :P ok
07:46:53 <Beelsebob> hat-observe tells you nothing about order
07:47:06 <aeolist> ^_^ thank you bob you made me happy
07:47:17 <Beelsebob> it only tells you what reductions happened
07:47:22 <jpcooper> wrt = (>>=) actionChan . flip writeChan
07:47:32 <Beelsebob> it's a good entry point to hat-anim (you can use :a to animate one of the reductions)
07:47:36 <jpcooper> does anyone a nicer way in which to write that?
07:47:52 <mauke> @unpl wrt = (>>=) actionChan . flip writeChan
07:47:53 <lambdabot> wrt f = actionChan >>= \ c -> writeChan c f
07:48:01 <Beelsebob> hat-trail doesn't tell you what order things happened in either -- it tells you *why* a value appeared
07:48:08 <Beelsebob> it kinda does debugging backwards
07:48:39 <Beelsebob> jpcooper: actionChan =<< flip writeChan?
07:48:52 <jpcooper> @type =<<
07:48:55 <lambdabot> parse error on input `=<<'
07:49:00 <jpcooper> @type (=<<)
07:49:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:49:14 <Beelsebob> it's bind, but in the order of composition instead
07:49:43 <aeolist> i see, so i'm supposed to choose an expression from hat-trail for example and :anim it eh?
07:49:52 <paczesiowa> hoknamahn: using tuples you don't loose functions like map or fold
07:50:05 <Beelsebob> aeolist: well, you can also just call hat-anim on the whole program, but you tend to get "hey, some IO happened"
07:50:11 <jpcooper> Beelsebob, but writeChan is not of type m b
07:50:23 <Beelsebob> aeolist: the easiest way to do it is to fire up hat-observe
07:50:29 <jpcooper> actionChan is of type m a
07:50:35 <Beelsebob> use :i to find a reduction that looks interesting
07:50:41 <Beelsebob> then use :a to animate the reduction
07:51:50 <Beelsebob> jpcooper: oh, woops >.<
07:52:02 <aeolist> thank you
07:52:05 <kuribas> Beelsebob: "man pnmcolormap" describes an algorithm.
07:52:36 <Beelsebob> kuribas: awesome, thanks a lot
07:54:11 <kuribas> No problem.  I think you can find a lot more information by googling particular algorithms.
07:54:42 <Beelsebob> kuribas: yeh, it's just not easy to get started finding out what they're called
07:56:56 <jpcooper> @hoogle a -> [a] -> [a]
07:56:57 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:56:57 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
07:56:57 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
07:57:27 <Beelsebob> I'm constantly surprised when that doesn't return Data.List.(:)
07:58:21 <mauke> you mean (Data.List.:)
07:58:30 <mauke> :-)
07:58:40 <Beelsebob> I do
07:59:10 <mauke> hmm, maybe it's because [] is wired into the compiler
07:59:28 <bd__> data [] a = ... | a : [a]       -- Defined in GHC.Base
07:59:46 <bd__> might be excluded based on being defined in GHC.*/
07:59:46 <bd__> ?
08:09:20 <kowey> can anybody suggest a way to do a configure check for base < 4?
08:09:37 <kowey> is there a module/function I could test for?
08:24:23 <ManateeLazyCat> dcoutts: I have remove "~/.cabal" and "~/.ghc" and cabal upgrade, and everything works fine. Thank you very much. I have a another question, if i want to use cabal remove some package and unregistered it. Have a command do this?
08:29:44 <twobitsp1ite> good morning/etc
08:31:01 <twobitsp1ite> in ghci, if define "let f a b = a + b" it sees the type as "f :: (Num a) => a -> a -> a", whereas "let f' = \a -> (\b -> a + b)" becomes "f' :: Integer -> Integer -> Integer"
08:31:58 <mauke> I blame the monomorphism restriction
08:32:26 <twobitsp1ite> aroo?
08:33:25 <mauke> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:33:26 <lambdabot> Title: Monomorphism restriction - HaskellWiki
08:33:48 <twobitsprite> heh... forgot I was connected in a screen session :)
08:34:45 <chris2> there's a function named after some important cs guy that joins several infinite streams of numbers divisible by something. anyone remember it?
08:34:51 <chris2> it's a common fp example
08:35:09 <mauke> hamming?
08:35:49 <chris2> right
08:35:49 <chris2> thanks
08:54:45 <vixey> o
08:57:00 <vixey> > 1+1
08:57:01 <lambdabot>   2
08:59:11 <luite_> is it possible to configure cabal-install such that by using 'cabal install [package]' it will automatically install to my user dir instead of trying to install globally (on windows)?
08:59:51 <DRMacIver> I was under the impression that was already the default behaviour.
09:00:01 <DRMacIver> (it is on linux)
09:00:33 <luite_> on linux it seems to be, but it doesn't autodetect that I'm not running as root (Administrator) on windows, and have to specify --user manually
09:01:11 <DRMacIver> Sorry, don't know then. I use windows as little as possible. :)
09:02:30 <Deewiant> luite_: should be settable somehow in %APPDATA%\cabal\config
09:02:42 <Deewiant> luite_: "user-install: True", I think
09:07:31 <luite_> Deewiant: hmm, strange, that doesn't work, although it seems to be the correct option
09:08:53 <Deewiant> :-/
09:09:17 <Deewiant> preflex: seen dcoutts
09:09:17 <preflex>  dcoutts was last seen on #haskell 2 hours, 2 minutes and 18 seconds ago, saying: it lets us write some of the properties in a more generic fashion
09:10:17 <luite_> oh wait, that might be because I tried to install this package before
09:10:48 <Deewiant> I don't think that should make a difference
09:10:54 <Deewiant> which doesn't mean that it doesn't, of course :-P
09:11:58 <askentasken> anyone tried the actor-library?
09:12:25 <askentasken> valhashOp, i dont get what that is, ghci complains it cant find it
09:13:06 <luite_> Deewiant: I can install other packages now, only 'probability' still gives an error (CreateDirectory: permission denied), so it may just be a bug in the package
09:14:02 <Deewiant> luite_: looking at the .cabal file it should be no different from any other package
09:14:36 <luite_> is there some option I can specify so that it tells me exactly which directory it tried to create?
09:15:10 <Deewiant> you can try -v3
09:15:34 <luite_> wow data overload ;)
09:15:40 <Deewiant> :-)
09:16:17 <luite_> hm, it does try to create a global install directory
09:17:14 <luite_> and I see why:   -- datadir: C:\Program Files (x86)\Haskell   -- this is the default setting for a user install
09:17:48 <Deewiant> O_o
09:18:01 <Deewiant> I suppose that is settable as well
09:18:34 <Deewiant> IIRC there were some settings which didn't work as advertised but I think that's all been fixed
09:29:29 <luite_> Deewiant: it works now :) thanks for the help. I changed the default Program Files dir to my user install dir.
09:29:52 <luite_> it took me a while to figure out the exact syntax of the configuration file though :)
09:30:13 <Deewiant> great :-)
09:37:28 <mdmkolbe> Is there a function for "\x y -> if x then y else 0"?
09:37:57 <ksf> you just wrote it.
09:38:13 <mdmkolbe> I mean an existing name for that function
09:38:16 <vixey> (1 - fromEnum x)*y
09:38:31 <mdmkolbe> @pl \x y -> if x then y else 0
09:38:32 <lambdabot> flip flip 0 . if'
09:38:46 <vixey> :t flip flip 0 . if'
09:38:48 <lambdabot> Not in scope: `if''
09:38:52 <vixey> :t flip flip 0
09:38:53 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
09:39:03 <Deewiant> :t (flip flip 0 .)
09:39:04 <lambdabot> forall a b c a1. (Num b) => (a1 -> a -> b -> c) -> a1 -> a -> c
09:39:04 <vixey> :t flip flip ?x
09:39:06 <lambdabot> forall a b c. (?x::b) => (a -> b -> c) -> a -> c
09:39:29 <mdmkolbe> vixey: what is the ?x part?
09:39:52 <ksf> looks to me like you might want to use fromJust.
09:40:00 <mdmkolbe> does it queries what type x gets in the expression?
09:40:04 <mdmkolbe> @type fromJust
09:40:06 <lambdabot> forall a. Maybe a -> a
09:40:13 <ksf> nah wait
09:40:16 <ksf> the safe one.
09:40:17 <byorgey> mdmkolbe: that's an implicit parameter.
09:40:27 <byorgey> the most little-known feature of ghc.
09:41:16 <ksf> @type fromMaybe
09:41:17 <lambdabot> forall a. a -> Maybe a -> a
09:41:27 <byorgey> in this case it allows you to leave a "hole" and have ghc infer its type.  but that's not really what they were originally for =)
09:41:54 <byorgey> they're for writing functions that take "implicit" parameters which don't actually have to be passed explicitly
09:41:59 <byorgey> sort of like a poor man's Reader monad.
09:42:58 <mdmkolbe> @type sortBy ?cmp
09:43:00 <lambdabot> forall a. (?cmp::a -> a -> Ordering) => [a] -> [a]
09:43:20 <mdmkolbe> @index sortBy
09:43:21 <lambdabot> Data.List
09:43:36 <vixey> :t \x -> ?y x
09:43:37 <lambdabot> forall t t1. (?y::t -> t1) => t -> t1
09:43:39 <vixey> :t ?m ?n
09:43:40 <lambdabot> forall t t1. (?n::t, ?m::t -> t1) => t1
09:43:46 <ksf> I'd definitely go for fromMaybe 0, but you know more about the connection of your bools and ints.
09:43:52 <vixey> :t fromMaybe 0
09:43:54 <lambdabot> forall t. (Num t) => Maybe t -> t
09:43:54 <mdmkolbe> byorgey: what versions support this (GHC 6.8 doesn't look like it does)
09:44:40 <byorgey> mdmkolbe: 6.8 certainly does support it.  implicit parameters have been around for a while, IIUC.
09:44:51 <byorgey> what makes you say it looks like it doesn't?
09:44:52 <mdmkolbe> byorgey: maybe I need a flag
09:45:02 <mdmkolbe> byorgey: I just tried it in GHCi
09:45:15 <byorgey> mdmkolbe: yeah, -XImplicitParams
09:45:35 <byorgey> or just do :set -XImplicitParams in ghci
09:45:46 <mdmkolbe> byorgey: ok that worked
09:45:49 <byorgey> cool
09:46:12 <vixey> foo
09:46:22 <vixey> @hackage hackage
09:46:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hackage
09:47:06 <byorgey> @hackage BestHackagePackageEver
09:47:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BestHackagePackageEver
09:47:10 <mdmkolbe> ksf: I'm reconstituting a C mask from a set of booleans. e.g. data Foo = Foo { flag1 :: Bool, flag2 :: Bool, etc.}; toCInt x = (if flag1 x then C_FLAG1_MASK else 0) .|. (if flag2 x then CFLAG2_MAKSK else 0) .|. etc.
09:48:17 <mdmkolbe> ksf: and I'd rather not keep repeating the boilerplate "if ... then ... else 0" part
09:48:30 <byorgey> mdmkolbe: yeah, just writing a little 'toMask :: Bool -> Int -> Int' sounds like a good plan
09:48:42 <byorgey> toMask b m = if b then m else 0
09:48:46 <vixey> mdmkolbe: Foo { flag1 :: Bool, flag2 :: Bool } I do not like
09:49:05 <byorgey> vixey: why not?
09:49:15 <vixey> mdmkolbe: Bitmask = Vector Bool 8 would be better, but since you can't do that, Bitmask = [Bool] could work
09:49:25 <vixey> if you did that turning it back into the int is  just a fold
09:49:29 <ksf> I like Maybe Int over Bool -> Int
09:50:01 <vixey> byorgey, bad names and the ordering of flags seems shaky
09:50:28 <mdmkolbe> vixey: I should note that the flags arnt just named "flag1", "flag2", they have more specific flag names (e.g. cache_write_back, cache_lru, etc.)
09:50:31 <ksf> you could also use Data.Set
09:50:40 <vixey> mdmkolbe: ok that is better
09:50:47 <mdmkolbe> vixey: I just used flag1, flag2 for examples, sorry to mislead you
09:50:57 <b_jonas> hello
09:51:04 <byorgey> hey b_jonas
09:51:12 <mdmkolbe> b_jonas: hi
09:51:18 <b_jonas> so what did you say works to fix the editline thingy?
09:51:39 <b_jonas> should I install the editline cabal package and then rebuild ghc or something like that?
09:52:45 <ksf> isn't editline a c-replacement for gnu readline?
09:53:05 <ksf> like in "wtf were they thinking trying to enforce the gpl on that one"?
09:53:38 <dons> http://www.reddit.com/r/programming/comments/7c6di/gitit_a_new_gitbased_wiki_written_in_hhaskell/
09:53:40 <lambdabot> Title: gitit: A new git-based wiki written in Hhaskell using HAppS and pandoc. : progra ..., http://tinyurl.com/5dkmfo
09:54:07 <masak> ksf: what's so strange about wanting to enforce the GPL on GNU ReadLine?
09:55:06 <ksf> well nobody's going to use all that readline user configurability if half of the programs needing such a thing can't use it.
09:56:08 <masak> ksf: you lost me. what does that have to do with the license?
09:56:35 <b_jonas> ok, so apparently it needs the library interface provided by the "libedit-dev" package, not the "libeditline-dev" package
09:56:49 <ksf> it'll be like if linus tried to enforce that every program running on linux to be gpl-compatible.
09:56:58 <ksf> noone would be using it.
09:57:05 <masak> ksf: no, it's not the same thing.
09:57:12 <jeffwheeler> Is there an example server with gitit running? I'd like to play with it.
09:57:39 <vixey> ksf, we'd just use readline if that was the case
09:57:44 <mdmkolbe> masak: readline is a library so normally if there were an alternative library the FSF would have released it as LGPL so other people can more freely use it.  However, since for a long time there were no alternatives to readline, the FSF released it as GPL in order to "encourage" more GPL applications (b/c you couldn't use readline otherwise)
09:58:08 <masak> mdmkolbe: I know.
09:58:30 <masak> mdmkolbe: and in some cases, that had the desired effect.
09:58:41 <ksf> I very much doubt that.
09:58:51 <mauke> cf. clisp
09:59:01 <EvilTerran> in the majority of cases, it'll put people off using the library at all
09:59:33 <EvilTerran> unless their software was already GPL
09:59:58 <velco> or GPL-compatible
10:00:09 <ksf> and even if the software is BSD-licensed, ppl try to get rid of readline.
10:00:12 <ksf> see ghc.
10:00:30 <b_jonas> actually,
10:00:40 <mdmkolbe> masak: of course, all it would take it one good competator that was LGPL or BSD to spoil the "readline strategy"
10:01:01 <b_jonas> if you don't need tab completion and such tight communications with the app, you can just pipe a readlined cat to the standard input of the program
10:01:22 <mdmkolbe> (... the likely consequence would be that FSF would respond by going LGPL for readline)
10:01:24 <b_jonas> like ruby -we 'require "readline"; while s= Readline.readline("", 1); print s, "\n"; end;' | something
10:01:37 <mauke> rlwrap
10:02:24 <b_jonas> that doesn't work with ghci-6.10.1 as is for it's stupid and won't just read from the stdin without messing up the stty modes
10:02:36 <b_jonas> but maybe I could fix that by editing the source of ghci
10:02:40 <roconnor> dons: is System.Random.Mersenne.Pure ever going to support split?
10:02:56 <b_jonas> mauke: ah, thanks
10:03:47 <b_jonas> for example this could be useful for the mathematica command line -- except that one also has the drawback that the help is accesible only from the gui mathematica
10:04:12 <dons> roconnor: if someone works out a way to make that work. afaik, there are very few pseudo-random gens that actually can support split
10:04:25 <dons> check the docs in System.Random for references
10:04:57 <ksf> yi should actually have enough code in it to piece together at least 10 readlines
10:05:23 <b_jonas> btw, does anyone have such a patch for ghci-6.10.1?
10:05:27 <b_jonas> to just make it read from stdin?
10:05:32 <b_jonas> that might be better than editline
10:05:50 <jeffwheeler> How complex is readline?
10:06:02 <jeffwheeler> It doesn't seem that difficult to just flat-out reproduce with Haskell.
10:06:23 <ksf> the basic functionality, yes, but all of it is quite a task.
10:06:26 <b_jonas> hmm
10:06:35 <ksf> it's like emacs: an operating system in itself.
10:06:37 <b_jonas> for some reason even with rlwrap the ^O won't work
10:06:46 <b_jonas> I guess it's only a default binding with bash
10:06:50 <b_jonas> I'll have to look into this
10:06:51 <jeffwheeler> Hmm; I didn't realize that. I thought it was pretty simple.
10:07:20 <b_jonas> jeffwheeler: it's not so simple, it has to have two display modes (a one-line one for dumb terminals and a multi-line one for real terminals) and stuff like that
10:07:28 <b_jonas> but it's not as complex as emacs actually
10:07:43 * mdmkolbe goes off to do a wc on readline sources
10:08:02 <b_jonas> at least it definitely loads faster than emacs
10:08:12 <ksf> yes, it's bug-ridden version of half of common lisp is only implemented informal ;)
10:08:52 <b_jonas> common lisp has lexical scoped variables by default
10:09:03 <vixey> readline sucks though
10:09:04 <Deewiant> readline is GNU, right? even GNU ls is over 4000 lines
10:09:09 <vixey> it's some cheesy tool to use a terminal as a GUI
10:09:13 <Deewiant> so a 'wc' might not be indicative of actual complexity :-P
10:09:35 <mdmkolbe> Deewiant: how did ls get to 4k lines?
10:09:37 <vixey> this is not really something you want to reimplement
10:09:44 <Deewiant> mdmkolbe: I don't know, I didn't write it
10:09:45 <b_jonas> Deewiant: but ls has like sixty options, doesn't it?
10:09:52 <ksf> as I said, just hook into yi.
10:09:55 <b_jonas> I only use like ten of its options, but still
10:10:12 <xenoblitz> can someone help me with the problem here: http://hpaste.org/11851 ?
10:10:20 <Deewiant> b_jonas: true.
10:10:33 <vixey> xenoblitz: it's just a warning, not an error
10:10:39 <mauke> vixey: ...
10:10:45 <mdmkolbe> vixey: no readline doesn't implement a termial GUI, that would be ncurses.  readline implements a halfway decent REPL
10:10:54 <mauke> xenoblitz: what is leftMove supposed to be?
10:10:56 <Deewiant> b_jonas: good guess, a wc gives it as 59 options :-)
10:11:02 <ksf> the reason you're getting that error is that your pattern matches are overlapping ;)
10:11:09 <vixey> ksf, it's a warning...
10:11:23 <xenoblitz> mauke: it returns an object of type Move
10:11:34 <xenoblitz> ksf: how do they overlap?
10:11:36 <mauke> xenoblitz: so it's a variable you've defined elsewhere?
10:12:00 <xenoblitz> mauke: its a type in another file which has an "interface" in another file
10:12:07 <mauke> it's not a type
10:12:12 <ksf> only the leftMove case is ever reached.
10:12:30 <xenoblitz> mauke: shall I paste you the type?
10:12:40 <ksf> types start with a capital letter.
10:12:44 <vixey> xenoblitz: these are variables not constructors
10:13:00 <vixey> > let nothing = 3 ; Nothing = 3 in ()
10:13:00 <xenoblitz> just a sec then let me update the code
10:13:01 <lambdabot>       No instance for (Num (Maybe t))
10:13:01 <lambdabot>        arising from the literal `3' at ...
10:13:13 <vixey> xenoblitz: that example ^ makes sense?
10:13:18 <ksf> if you've got a lower-case name in a pattern match, you're introducing a new variable binding.
10:13:33 <mauke> xenoblitz: no, why?
10:13:51 <xenoblitz> http://hpaste.org/11851#a1
10:13:53 <b_jonas> I'm using -F -l -d -a -b -1 -C -R -t -v --sort=size
10:14:01 <b_jonas> that's eleven
10:14:14 <b_jonas> so I'm using only 1/6 of the potential of ls?
10:14:16 <b_jonas> great
10:14:28 <mauke> xenoblitz: you need to use Left_Move, not leftMove
10:14:36 <sm> morning all
10:14:49 <xenoblitz> its not possible to use leftMove then even if it returns Left_Move?
10:14:57 <byorgey> b_jonas: keep in mind that ls's total potential may be unevenly distributed among command-line flags.
10:15:03 <mauke> xenoblitz: not in a pattern
10:15:11 <xenoblitz> mauke: ok
10:15:13 <b_jonas> byorgey: possible
10:15:13 <byorgey> hi sm
10:15:21 <b_jonas> and I hate colored ls
10:15:22 <xenoblitz> mauke: thanks :)
10:15:23 <ksf> the leftMove in your pattern doesn't even reference the binding in the other module, it's a name for a new binding.
10:15:31 <sm> so a question. edsger dijkstra returns to the earth for one day. what does he think of haskell ?
10:15:46 <byorgey> hehe, interesting question sm =)
10:15:55 <xenoblitz> ksf: well to be fair leftMove works... don't know about the others :P
10:16:00 <mdmkolbe> Ok, readline has 34 c files with 25k lines.  the largest 10 files are between 0.8k and 2.5k lines.  It actually looks like it might be a well designed system from a high-level.  It just doesn't benefit from the short line lengths we get in Haskell.  (Odds are it would take 2.5k lines to write in Haskell)
10:16:11 <mdmkolbe> (None of these counts include .h files)
10:16:26 * sm is reading http://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1036.html
10:16:27 <lambdabot> Title: E.W. Dijkstra Archive: On the cruelty of really teaching computing science (EWD  ..., http://tinyurl.com/mbvym
10:16:31 <b_jonas> why Dijkstra in particular? why not Church, Babbage, Turing, or Neumann?
10:16:54 <byorgey> Dijkstra had some very particular opinions about CS pedagogy.
10:17:00 <askentasken> anyone tried the actor-library?
10:17:01 <askentasken> valhashOp, i dont get what that is, ghci complains it cant find it
10:17:25 <b_jonas> ok, I've installed the editline cabal package
10:17:27 <ksf> I actually only know him as the guy who did not invent A*.
10:17:47 <b_jonas> now I'll reconfigure ghc-6.10.1 and see if it finds it
10:17:49 <b_jonas> and builds with it
10:19:14 <b_jonas> "checking whether ghc has editline package... no
10:19:17 <b_jonas> " -- argh
10:19:31 <b_jonas> whereas ghc-pkg clearly says it does have it
10:20:08 <ksf> Already the start of it reminds me of Bucky Fuller, so chances are it's really good.
10:22:21 <f4lcon> Hi i'm pretty new to haskell and slightly stuck working with binary trees. Im trying to add a 0 or a 1 to a list depending on if I take the left sub tree or right sub tree until I reach the leaf i want. How would i do that?
10:22:46 <EvilTerran> > 1 : [2,3,4]
10:22:48 <lambdabot>   [1,2,3,4]
10:22:59 <EvilTerran> > [1,2,3] : 4 -- note it's not symmetrical
10:23:01 <lambdabot>       No instance for (Num [[t]])
10:23:01 <lambdabot>        arising from the literal `4' at <int...
10:23:15 <EvilTerran> ?type (:)
10:23:17 <lambdabot> forall a. a -> [a] -> [a]
10:23:37 <f4lcon> I know about concat but how would i make it specifically add a 1 if it takes the left sub tree?
10:23:47 <EvilTerran> ah, i see
10:24:00 <EvilTerran> how are you deciding which branch to take?
10:24:18 <b_jonas> it also says "checking for ghc-pkg matching /usr/local/bin/ghc... no" -- strange
10:24:21 <f4lcon> I was thinking of simply doing an in-order traverse
10:24:23 <f4lcon> left to right
10:24:45 <EvilTerran> ... ok, what's your datatype for tree nodes?
10:24:47 <roconnor> f4lcon: recordPath (Leaf) = []; recordPath (Tree l r) | goingLeft = 1:(recordPath l)              | goingRight = 1:(recordPath r)
10:25:23 <f4lcon> Chars
10:25:26 <roconnor> f4lcon: oh wait, what do you mean by in-order traverse and recording your path
10:25:48 <EvilTerran> f4lcon, er, you can't represent a tree in a Char
10:26:03 <cdfh> f4lcon: is this for a huffman tree by any chance?
10:26:06 <f4lcon> ye
10:26:19 <roconnor> cdfh: nice call
10:26:25 <f4lcon> I was about ot mention that :P
10:26:28 <cdfh> :-)
10:26:33 <f4lcon> Well i can use Strings for each node right
10:26:37 <roconnor> suddendly it all makes sense
10:26:48 <EvilTerran> f4lcon, yes, but what type are you using to represent the tree's structure?
10:27:17 <mauke> EvilTerran: encode the tree in an integer, convert the integer to char
10:27:19 <mauke> tee hee
10:27:23 <EvilTerran> -.-
10:27:34 <EvilTerran> Char is finite, it wouldn't work in general :P
10:27:54 <b_jonas> ah, getting better:
10:28:03 <b_jonas> runghcXXXX15838.hs: /usr/local/ghc/lib/editline-0.2.1.0/ghc-6.10.1/HSeditline-0.2.1.0.o: unknown symbol `el_gets'
10:28:06 <f4lcon> im probably being retarded but what to you mean by what type to represent the tree's structure
10:28:10 <ksf> while doing that one in c i ended up with nodes with five pointers to other nodes each.
10:28:23 <EvilTerran> f4lcon, well, you've got leaves and branches
10:28:29 <EvilTerran> how are these represented?
10:28:39 <roconnor> f4lcon: are you using something like data Tree a = Node a (Tree a) (Tree a) | Leaf  ?
10:28:45 <f4lcon> ye
10:28:53 <EvilTerran> or "data Tree a = Branch (Tree a) (Tree a) | Leaf a"
10:29:00 <EvilTerran> or there's a few other options
10:29:26 <roconnor> data Tree a b = Node a (Tree a b) (Tree a b) | Leaf  b is the most general :)
10:29:38 <f4lcon> I'm sticking to the general representation
10:29:44 <EvilTerran> ... namely?
10:30:03 <mauke> data Tree t a b = Node a (t a b) (t a b) | Leaf b
10:30:05 <f4lcon> Node a (Tree a) (Tree)
10:30:29 <f4lcon> * data Tree a = Leaf a | Node a (Tree a) (Tree a)
10:30:40 <EvilTerran> ah, labels everywhere
10:30:41 <roconnor> :)
10:31:38 <ksf> ...because you aren't actually working with merely a binary tree, but with a graph that consists of a binary tree with all branches representing concrete characters linked into a list always sorted by frequency.
10:31:59 <sm> for those reading: paragraphs[-8:-7] sound a bit like haskell (pure and io-monadic code)
10:32:03 <b_jonas> ah, it works now
10:32:15 <b_jonas> I just have to link the editline package with it
10:32:46 <roconnor> ksf: I don't recall having a list sorted by frequency.
10:32:58 <roconnor> when I wrote my GIF decoder
10:33:06 <roconnor> back when I was a youngster
10:33:13 <roconnor> and didn't know Haskell
10:33:43 <f4lcon> atm im not sorting by frequency, im just using a given huffman tree and using it to encode a character
10:33:59 <ksf> i started off with that one and then constructed the binary tree on top of it, to associate the char with the highest frequency with a code of the shortest length possible.
10:34:31 <ksf> and then, yes, something like "left is 0, right is 1" happenes.
10:36:33 <dons> http://www.reddit.com/r/haskell/comments/7c6jq/malcolm_wallaces_1_page_haskell_reference_now/
10:36:35 <lambdabot> Title: Malcolm Wallace's 1 page Haskell reference. Now online. : haskell, http://tinyurl.com/56jmfx
10:37:07 <cdfh> f4lcon: if you're representing a huffman tree, then may i recommend that you use: data HTree a = Node (HTree a) (HTree a) | Leaf a; and have some functions: encode :: HTree a -> a -> [Bool]; decode :: HTree a -> [Bool] -> a
10:37:37 <vixey> cdfh, would prefer decode to return a Maybe a personally
10:37:43 <cdfh> you may want to convert [Bool] to another datatype, although, that would probably be best done by two other functions (for encode and back)
10:37:52 <cdfh> vixey: my bad :-)
10:39:01 <b_jonas> ok, look
10:39:03 <vixey> cdfh, a nice alternative is  codify :: HTree a -> HTree (a,[Bool])
10:39:11 <b_jonas> I have this test program:
10:39:15 <b_jonas> import System.Console.Editline; main = do { el <- elInit ""; x <- elGets el; print x }
10:39:24 <b_jonas> now if I compile this with ghc -package editline --main=B.main B.hs
10:39:26 <b_jonas> then it works fine
10:39:42 <b_jonas> no wait, it doesn't
10:39:51 <cdfh> vixey: ah, yes - that looks quite nice
10:40:17 <b_jonas> ok, so it does work when I build it with ghc that way
10:40:18 <vixey> so you can go like
10:40:25 <b_jonas> but then, when I try to do this:
10:40:31 <b_jonas> runghc -package editline --main=B.main B.hs
10:40:33 <vixey> Data.Map.whateverMakesAMap . depthFirstTraverse . codify
10:40:53 <b_jonas> then it doesn't work, it gives this error: ghc: /usr/local/ghc/lib/editline-0.2.1.0/ghc-6.10.1/HSeditline-0.2.1.0.o: unknown symbol `el_gets'.  ghc: unable to load package `editline-0.2.1.0'
10:40:59 <b_jonas> so how do I use this form runghc?
10:41:20 <kjdf> has anyone saved a picture that was linked to in this channel (from 4chan or similar) a couple of months ago, comparing java, php and haskell ?
10:41:40 <kjdf> a really fat woman, a blow-up doll, and a girl with sniper rifle, respectively
10:42:03 <cdfh> vixey: yes, that is nice :-)
10:42:08 <ksf> b_jonas, use LD_PRELOAD?
10:42:19 <b_jonas> ksf: hmm, you're saying something
10:43:10 <b_jonas> LD_PRELOAD=libedit.so.2 runghc -package editline --main=B.main B.hs
10:43:14 <b_jonas> <interactive>:1:54: Not in scope: `main'
10:44:28 <b_jonas> strange message, that
10:46:04 <roconnor> hmm, technically Malcolm's description of sequencing is a lie, but it is short.
10:46:29 <b_jonas> strange
10:46:54 <int-e> b_jonas: do you mean -main-is?
10:47:12 <ksf> b_jonas, http://code.haskell.org/yi/Yi/
10:47:13 <lambdabot> Title: Index of /yi/Yi
10:47:22 <ksf> contains all the code you could ever want.
10:47:23 <b_jonas> it's called -main-is? why does it accept just --main then?
10:47:26 <b_jonas> oh well
10:47:34 <hoknamahn> guys, how to find the length of tuple?
10:47:49 <hoknamahn> any standard function?
10:47:58 <ksf> :t in ghci, for all it's worth.
10:47:59 <lambdabot> parse error on input `in'
10:48:06 <b_jonas> but meanwhile I've renamed the source to Main.hs and added a package and export declaration
10:48:06 <int-e> hoknamahn: why would you have to?
10:48:10 <b_jonas> and it still doesn't help
10:48:15 <b_jonas> <interactive>:1:58: Not in scope: `main'
10:48:19 <ksf> tuples don't have length, each one is its different type.
10:48:43 <b_jonas> but wait
10:48:49 <b_jonas> just rubghc Main.hs works
10:48:54 <b_jonas> without the -package option
10:48:59 <b_jonas> crazy
10:49:19 <hoknamahn> I thought to use tuples as parameters for kdtree but in this case kdtree functions have to know the length
10:49:46 <b_jonas> are you sure you want to do that?
10:50:10 <hoknamahn> nope
10:51:27 <hoknamahn> just thinking how to organize polymorthic kdtree at least for 1d-4d cases
10:52:28 <ksf> just like any other binary tree?
10:52:30 <int-e> hoknamahn: I believe you'll have to define a type class for working with those trees then, and that type class can contain the required "length of tuple" function.
10:52:54 <hoknamahn> yep i thought about that
10:53:07 <hoknamahn> so each instance will degine length = n
10:53:09 <hoknamahn> ?
10:53:13 <hoknamahn> define
10:54:05 <rwbarton> It might be sufficient to define a class of "k-tuples of type a" with an instance method to rotate the k-tuple
10:54:51 <ksf> why don't you just use lists if I may ask?
10:56:05 <int-e> ksf: it buys some type safety - you statically avoid mixing dimensions within a tree.
10:56:06 <hoknamahn> ksf this is a good question
10:56:44 <int-e> ksf: but there's a cost in implementation complexity. the real question is how large that cost is :)
10:57:18 <hoknamahn> :) as I see there is no "right" answer :)
10:57:26 <vixey> hoknamahn: There doesn't have to be any cost
10:57:29 <ksf> I'd just curry the dimensionality as first argument into the functions, and then use the curried versions.
10:57:39 <ksf> premature optimization is the root of all evil.
10:58:28 * int-e once went through the effort of enforcing the shape of a binomial heap on the type level ... and found a bug in the implementation :)
10:58:35 <vixey> ksf, this is definitely not optimization
10:58:36 <ksf> and curried monads go best with chicken soup.
10:59:08 <ksf> well, using a tuple vs. a list is optimisation in a sense.
11:00:10 <hoknamahn> as for me tuples have one good sense - they mean that current chunk of data has constant length
11:00:38 <int-e> hmm a class Vector v a | v -> a where length :: v -> Int; lookup :: v -> Int -> a; modify :: v -> Int -> a -> v  seems to be the obvious approach - does something like that exist on hackage?
11:00:40 <vixey> hoknamahn: Can't you write it like  KDTree a where a is (Double,Double) or (Double,Double,Double) ?
11:00:44 <ksf> you won't ever be able to implement n-dimensional trees with them, though.
11:00:59 <ksf> that is, except by using template haskell.
11:01:28 <rwbarton> One could use FSVec from the parameterized-data package
11:01:35 <int-e> ksf: never say never - type level arithmetic exists.
11:02:04 <int-e> ksf: sure, the implementation cost just rose tremendously. but it /can/ be done *g*
11:02:06 <rwbarton> int-e: isn't it called "Array"? :)
11:02:13 <ksf> I'd rather smash my head repeatedly into a brick wall than choose type-level coding over TH.
11:02:50 <int-e> rwbarton: oh. there's an unstated assumption in my interface that the 'v' argument of 'length' is a dummy argument.
11:03:39 <ksf> _|_ -> Int ;) ?
11:04:05 <bd_> ksf: is that a type bottom? :)
11:04:15 <int-e> rwbarton: The index should really be a finite type instead, hmm. Oh purity.
11:04:16 <rwbarton> int-e: Ah, OK
11:04:31 <ksf> yes, and you won't have any problems making the function complete ;)
11:04:37 <ddarius> int-e: Type-level programming is passe.  Use a suitably constructed nested data type to enforce your constraints.
11:04:58 <int-e> ksf: you can actually state that in Haskell - newtype Mark mark value = Mark value and then put length :: Mark v Int into the type class
11:06:15 <int-e> ksf: I have code for that type somewhere. It provides functions  toDummy :: Mark mark value -> (mark -> value) and fromDummy (opposite) for convenience, because dummy arguments are /far/ more convenient to work with.
11:06:46 <int-e> ddarius: hmm
11:08:07 <ksf> I'd say use template haskell, but then I'm spoiled by scheme.
11:08:56 <sm> hmm, no list generators in http://haskell.org/sitewiki/images/b/b2/QuickReference.pdf ? that's the one I can never remember
11:08:58 <lambdabot> Title: cache:http://haskell.org/sitewiki/images/b/b2/QuickReference.pdf - Google Search
11:09:02 <int-e> @faq
11:09:02 <lambdabot> The answer is: Yes! Haskell can do that.
11:09:23 <roconnor> replicate 5 5
11:09:26 <roconnor> > replicate 5 5
11:09:27 <lambdabot>   [5,5,5,5,5]
11:09:30 <ddarius> sm: Then don't remember them.
11:09:31 <int-e> The problem is to find a sweet spot to stop.
11:09:36 <roconnor> > join replicate 5
11:09:37 <lambdabot>   [5,5,5,5,5]
11:10:00 <igel> @hoogle join
11:10:01 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
11:10:01 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
11:10:01 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
11:10:08 <igel> :t join
11:10:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:10:46 <Deewiant> > ap take repeat 5
11:10:47 <lambdabot>   [5,5,5,5,5]
11:11:14 <roconnor> > (take `ap` repeat) 5
11:11:15 <lambdabot>   [5,5,5,5,5]
11:11:30 <ddarius> > (take <*> repeat) 5
11:11:31 <lambdabot>   [5,5,5,5,5]
11:11:36 <ksf> are you guys training for an obfuscation contest?
11:11:51 <Deewiant> > [5,5,5,5,5]
11:11:53 <lambdabot>   [5,5,5,5,5]
11:11:55 <roconnor> I find (take <*> repeat) 5 the clearest way of writing that
11:12:00 <ddarius> Someone was thinking about having another IOHCC
11:12:05 <roconnor> other than Deewiant's way
11:12:41 <Deewiant> I'd probably use replicate 5 5; if it's not coincidental that they're both 5 I'd use join
11:12:48 <roconnor> it's take applied to repeat in the reader applicative functor.  With the environment 5.
11:14:17 <roconnor> > (flip ($) 5) (take <*> repeat)
11:14:19 <lambdabot>   [5,5,5,5,5]
11:14:28 <roconnor> if you want the 5 to come first
11:14:48 <ddarius> > ($ 5) (take <*> repeat)
11:14:49 <lambdabot>   [5,5,5,5,5]
11:15:01 <b_jonas> ksf: if you want type-safety, you can still use something like (a0, (a1, (a2, ())))
11:15:14 <Deewiant> > (`id` 5) (take <*> repeat)
11:15:15 <lambdabot>   [5,5,5,5,5]
11:15:16 <b_jonas> then iterate on it with polymorphic recursion
11:15:28 <roconnor> > let envFor (flip ($)) in 5 `envFor` (take <*> repeat)
11:15:30 <lambdabot>   <no location info>: parse error on input `in'
11:15:38 <roconnor> > let envFor = flip ($) in 5 `envFor` (take <*> repeat)
11:15:40 <lambdabot>   [5,5,5,5,5]
11:15:44 <ksf> b_jonas, I thought I had left that one behind, together with scheme.
11:15:53 <ddarius> > runCont (return 5) (take <*> repeat)
11:15:54 <lambdabot>   [5,5,5,5,5]
11:16:18 <rwbarton> > "stop!" >> 5
11:16:19 <lambdabot>       No instance for (Num [b])
11:16:19 <lambdabot>        arising from the literal `5' at <inter...
11:16:21 <rwbarton> > "stop!" >> [5]
11:16:23 <lambdabot>   [5,5,5,5,5]
11:16:43 <roconnor> ddarius: no no, that's just wrong.  (take <*> repeat) is the monad to be run, not 5! :)
11:17:56 <EvilTerran> ?src runCont
11:17:56 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:17:59 <EvilTerran> ?src Cont
11:18:00 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
11:27:11 <b_jonas> I guess I'll ask about my ghc build problem on #ghc
11:36:51 <ksf> sm: I've never seen such a well-crafted point against opearational semantics as in  http://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1036.html
11:36:53 <lambdabot> Title: E.W. Dijkstra Archive: On the cruelty of really teaching computing science (EWD  ..., http://tinyurl.com/mbvym
11:37:22 <sm> it's good stuff eh
11:37:31 <b_jonas> meanwhile, I've figured out what just 'rlwrap ghci' doesn't work:
11:37:39 <sm> and a bit upsetting
11:38:04 <b_jonas> if you do that, ghci will figure that its input is a terminal and so use it own readline (which is broken) and then rlwrap detects this and just passes stuff through
11:38:07 <ksf> I used to capture that one by telling my coworkers to throw the first thought away, throw the second one away and upon seeing the amount of abstract nonsense the third one produces sticking with the second.
11:45:40 <ksf> sm, obviously dijkstra is still using haskell: http://www.reddit.com/comments/69r8e/haskell_weekly_news_100_libraries_in_2_weeks_web/c039g4n
11:45:42 <lambdabot> Title: dijkstra comments on Haskell Weekly News: 100 libraries in 2 weeks! Web servers, ..., http://tinyurl.com/6g5p69
11:46:12 <sm> ha
11:46:47 <sm> I have to tell you that does not sound like him
11:47:26 <sm> I can't see him uttering the word "hackage"
11:47:59 <ksf> http://hpaste.org/11852
11:48:21 <ksf> That one's clearly about Monads.
11:48:55 <sm> that's what I'm dimly seeing, and hoping, to be honest
11:49:15 <b_jonas> meanwhile, is there a ghci init file where I can put commands I usually like to execute on start of ghci, like importing useful modules?
11:49:30 <mauke> ~/.ghci
11:50:01 <b_jonas> ah, it's in the manual
11:50:03 <b_jonas> I should have looked it up
11:50:09 <b_jonas> s/manuyal/ghc users' guide/
11:50:44 <evident> hi guys
11:50:47 <evident> and girls
11:51:13 <evident> i have a little problem
11:51:23 <evident> is there a way to reverse a predicate?
11:51:40 <evident> other way i could solve the problem is to substract two liste
11:51:42 <b_jonas> @type not
11:51:43 <Deewiant> ?ty \p -> not . p
11:51:43 <lambdabot> Bool -> Bool
11:51:44 <lambdabot> forall a. (a -> Bool) -> a -> Bool
11:52:07 <evident> well I tried it in my function but it gave me an error
11:52:16 <bbs> :t zipWith
11:52:17 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:53:15 <b_jonas> evident: maybe show us the source and the exact error you got?
11:53:23 <b_jonas> just "gave me an error" isn't specific enough
11:54:10 <evident> http://www.mibbit.com/pb/167VVU
11:54:11 <lambdabot> Title: Mibbit: PasteBin
11:54:18 <evident> thats my function
11:54:30 <evident> i want to sort a list...
11:54:33 <evident> input: one list
11:54:40 <evident> output: a tupel of lists
11:54:48 <evident> left: the ones that match the predicate
11:54:53 <evident> right: the ones taht dont
11:55:09 <dons> byorgey++ http://www.reddit.com/r/haskell/comments/7c6ve/haskell_weekly_news_november_8_2008_the_haskell/
11:55:10 <evident> left one is working, but how do i get the other ones?
11:55:15 <lambdabot> Title: Haskell Weekly News: November 8, 2008 | The Haskell Sequence : haskell, http://tinyurl.com/6pjj3r
11:55:29 <evident> was either thinking about reversing the predicate in the right one
11:55:41 <b_jonas> evident: what Deewiant says then
11:55:52 <evident> or take (x:xs) and substract the ones from thte left one
11:56:05 <b_jonas> not is of type Bool -> Bool but you try to call it with a function argument, not a boolean one
11:56:42 <evident> so i have to put a backslash in front of the predicate?
11:56:47 <liwp> should be (not . pred)
11:56:53 <BMeph> evident: Have you considered the simple case? :)
11:56:55 <evident> with a dod?
11:57:06 <ksf> evident, look at the definition of filter and add it to itself.
11:57:37 <evident> I'll have a look
11:57:58 <liwp> but you end up traversing the list twice, so what you rally want is a helper function that maintains two list and places an element to one of those list based on the pred
11:58:00 <byorgey> wow, dons, you're fast!
11:58:33 <jfredett> hrm... hopefully things won't crash this time...
11:58:34 <EvilTerran> ?src filter
11:58:34 <lambdabot> filter _ []     = []
11:58:35 <lambdabot> filter p (x:xs)
11:58:35 <lambdabot>     | p x       = x : filter p xs
11:58:35 <lambdabot>     | otherwise = filter p xs
11:58:35 <jfredett> huzzah.
11:58:59 <EvilTerran> hm... i find the use of guards there instead of if/then/else slightly gratuitous, but okay
11:59:14 <byorgey> anyone know if ssh is down on code.haskell.org (aka nun)?
11:59:19 <byorgey> I can't seem to log in
11:59:46 <evident> got it guys... thank
11:59:47 <evident> s
12:01:02 <jfredett> now I can ask my question. A view appears to be just a representation of some datastructure as if it were some other data structure, no?
12:01:51 <ksf> nothing is. all is illusion. therefore, everything is a view.
12:02:11 <EvilTerran> jfredett, pretty much, yeah; frequently a representation of (part of the structure of) an abstract type as a concrete type
12:02:19 <jfredett> ksf: I have the flu, I cannot comprehend your koans today... :/
12:02:29 <jfredett> ksf: though I appreciate them in general. :)
12:02:36 <jfredett> EvilTerran: okay
12:02:46 <jfredett> it is as simple as I thought then...
12:02:50 <byorgey> jfredett: indeed.  note, however, that ghc 'view patterns' are not really full-fledged views.
12:03:11 <EvilTerran> . src ''ViewL
12:03:14 <byorgey> they only let you go in one direction.
12:03:15 <ddarius> They are not even half-fledged views.
12:03:16 <EvilTerran> , src ''ViewL
12:03:23 <lunabot>  luna: Not in scope: type constructor or class `ViewL'
12:03:25 <jfredett> For the record, a decent fever + type theory is fun times.
12:04:03 <jfredett> byorgey: any good places to learn about The real thing(tm)?
12:04:21 <byorgey> well, Wadler's original paper about views is a really nice read.
12:04:25 <EvilTerran> "foo (viewl -> x :< xs) = ..." being the kinda thing i'm thinking of (for Seq's)
12:04:29 <byorgey> @go wadler views
12:04:32 <lambdabot> http://citeseer.ist.psu.edu/581010.html
12:04:32 <lambdabot> Title: cohabit with data abstraction - CiteSeerX
12:04:36 <byorgey> that's it
12:05:19 <jfredett> byorgey: is it something a Senior Math Undergrad with decent Haskell Experience will understand? :)
12:05:28 <byorgey> jfredett: yes, definitely.
12:05:35 <byorgey> it's quite an accessible paper.
12:05:38 <jfredett> awesome.
12:06:15 <byorgey> I also seem to recall some paper about dependent types talking about views.  Maybe it was the Power of Pi paper.
12:06:35 <jfredett> Cool
12:06:42 <byorgey> which is a fun paper anyway =)
12:07:20 <jfredett> hehe, dependent types are so cool...
12:07:38 * byorgey <3 dependent types
12:07:41 <vixey> view from the left is a gem too
12:07:43 <b_jonas> it turns out that the readline commands C-o and C-xC-e are both bash extensions, and not in the normal readline
12:08:02 <byorgey> vixey: that paper is incomprehensible.
12:08:13 <vixey> byorgey, well I got sunburn reading it
12:08:17 <byorgey> hehe
12:08:21 <b_jonas> at least that's how it seems from the bash info docs and the readline info docs
12:09:06 <byorgey> vixey: I agree that it's cool but I definitely wouldn't recommend it to anyone who isn't willing to invest an entire day bashing their head against a wall.
12:13:07 <vixey> byorgey, if you want some head bashing material
12:13:13 <byorgey> oh, you know it
12:14:20 <vixey> http://www.lmcs-online.org/ojs/viewarticle.php?id=290&layout=abstract
12:14:22 <lambdabot> http://tinyurl.com/6o3zpn
12:14:51 <vixey> notice the lack of strong normalization proof :)))
12:15:10 <ksf> http://katmat.math.uni-bremen.de/acc/acc.pdf
12:15:13 <lambdabot> Title: Abstract and Concrete Categories - The Joy of Cats
12:15:51 <byorgey> so many things to read, and so little time!!
12:16:23 * EvilTerran bookmarks http://www.lmcs-online.org for future idle reading
12:17:31 <EvilTerran> "All corrections will be awarded, besides eternal gratefulness, with a piece of delicious cake! You can claim your cake at the KatMAT Seminar, University of Bremen, at any Tuesday (during terms)." hehe
12:18:00 <ksf> I actually printed and bound that one, by hand, with needle and string.
12:18:20 <byorgey> ksf: hehe, nice
12:18:34 * ddarius hasn't read all of it yet.
12:26:53 <b_jonas> ok, editline problem mostly solved: editline works now in ghci
12:28:14 <b_jonas> it still doesn't save the readline history accross sessions though
12:28:16 <b_jonas> you said it would
12:28:22 <b_jonas> how do I enable that?
12:31:24 <ksf> anyone feeling like writing a browser in haskell or a wizard book?
12:32:09 <ksf> you could call it the chicken book and have a chicken on the front page currying itself (SCNR)
12:38:21 <vixey> > 1+1
12:38:23 <lambdabot>   2
12:38:50 <f4lcon> gah damn recursion making my head hurt :P
12:40:07 <BONUS> my headache is making my head hurt
12:40:29 <vixey> recursive headache
12:41:05 <mauke> > fix head
12:41:06 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
12:41:06 <lambdabot>        Expect...
12:41:11 <waynemokane> hi, is there a way to capture the output of one monadic action, inside IO, to a file?  I know about writeFile, but that is no good if I call a monadic action inside, say "main" since the IO monad itself has output
12:41:36 <mauke> waynemokane: huh?
12:41:42 <BONUS> a <- getLine
12:41:42 <waynemokane> so if f :: IO (),  and I know that calling f will generate output on IO (stdout), can I somehow call f and capture the output to a file?
12:41:44 <BONUS> then write a to a file?
12:41:51 <BONUS> oh that
12:42:00 <mauke> hmm, you'd have to reopen stdout
12:42:00 <waynemokane> sorry, I mean, within ghci
12:42:11 <mauke> I don't know if haskell lets you do that
12:42:22 <waynemokane> cause you are basically re-routing stdout?
12:42:34 <dmwit> How about ./program >file
12:42:34 <Deewiant> I'm not sure if there's portable functionality for that
12:42:39 <Cale> waynemokane: There is a way to accomplish that if you *really* need it but it is technical and platform-specific.
12:42:49 <waynemokane> yeah I know about that... was just trying to do without leaving ghci
12:42:55 <sbahra> :t fix
12:42:56 <lambdabot> forall a. (a -> a) -> a
12:42:58 <waynemokane> can always compile with ghc, run the exec
12:43:03 <b_jonas> waynemokane: unlikely, you'd have to be able to serialize functions for that
12:43:07 <waynemokane> nevermind I'll just use tee with ghci
12:43:10 <waynemokane> thx guys
12:43:19 <mauke> or 'script'
12:43:44 <b_jonas> oh, you just want to capture what goes to the standard output?
12:43:54 <waynemokane> b_jonas: yes
12:43:56 <b_jonas> why don't you just reporen standard output to another file?
12:44:07 <b_jonas> the standard output file descriptor that is
12:44:08 <waynemokane> reopen?
12:44:18 <b_jonas> you do it by opening the file and dup2ing it to the stdout handle
12:44:22 <mauke> ouch
12:44:26 <b_jonas> there's also a c function freopen for it I think
12:44:33 <mauke> b_jonas: no Handle-level function for that?
12:44:34 <b_jonas> mauke: that's what shell redirection does too
12:44:41 <b_jonas> mauke: freopen I said
12:44:48 <mauke> freopen is a C function
12:44:54 <b_jonas> no idea about the haskell wrappers, yeah
12:44:59 <b_jonas> you have to look them up in the docs
12:45:01 <mauke> Haskell doesn't use FILE *
12:45:07 <b_jonas> yeah
12:45:11 <b_jonas> but it could have some equivalent
12:45:19 <b_jonas> also what's wrong with just reopening the descriptor?
12:45:19 <waynemokane> actually... nevermind, I can't see how tee and ghci could work together
12:46:06 <mauke> buffering could be a problem
12:49:38 <ivan> a always means α, right? or does α only refer to type variables? (reading YAHT)
12:51:52 <mdmkolbe>  ivan: in what context? in a type signature "a" is always a type variable
12:52:01 <Deewiant> a and α are both identifiers
12:52:04 <ivan> alright, that's what i was thinking about
12:52:05 <ivan> thanks mdmkolbe
12:52:06 <Deewiant> and they are different
12:52:17 <Deewiant> α is lower-case and thus would also be a type variable
12:52:35 <mdmkolbe> ivan: in general things that start with lower case are viariables or type varialbes,  things that start with upper case at Types or Constructors
12:53:02 <mdmkolbe> (Or type Classes are also upper case first letter)
12:53:26 <ksf> greek characters have generally no meaning but indicate that the author is intellectual beyond hope.
12:53:33 <mdmkolbe> ivan: so myType would be a type varialbe
12:54:17 <ivan> alright
12:55:45 <mdmkolbe> hi JaffaCake
12:56:55 <vixey> ksf, ?
12:57:02 <ksf> hm?
12:57:08 <vixey> ksf, lambda has no meaning
12:57:41 <ksf> some people are using it as a synonym for \ I heard.
12:57:41 <waern> mdmkolbe: it's a bot :)
12:57:42 <lambdabot> waern: You have 1 new message. '/msg lambdabot @messages' to read it.
12:58:22 <mdmkolbe> waern: when did Simon M. turn into a bot?
12:59:22 <dons> shapr: http://www.haskell.org/pipermail/haskell-cafe/2008-November/050336.html
12:59:24 <lambdabot> Title: [Haskell-cafe] ANNOUNCE: gitit 0.2 release - wiki using HAppS, git, pandoc, http://tinyurl.com/6ykomq
12:59:26 <dons> online demos up
13:04:44 <waern> mdmkolbe: not sure ;)
13:15:18 * edwardk waves hello.
13:16:03 <bringert> what's up with code.haskell.org?
13:17:17 <edwardk> @seen igloo
13:17:17 <lambdabot> igloo is in #haskell, #darcs and #ghc. I last heard igloo speak 4h 17m 14s ago.
13:17:29 <mdmkolbe> bringert: what do you mean?
13:17:42 <bringert> mdmkolbe: I can't reach it
13:17:56 <Korollary> edwardk: whaddup playa
13:18:07 <edwardk> not too much
13:19:13 <bringert> mdmkolbe: can you reach it?
13:20:20 <dons> shapr: i hope you blog your cell adventures
13:20:37 <mdmkolbe> bringert: no, I can't get to it
13:21:21 <bringert> dons, dcoutts: c.h.o seems to be down, does either of you know what to do?
13:21:33 <bringert> Igloo: or you
13:22:49 <dons> seafood: happs + git + pandoc, http://johnmacfarlane.net:5001/Front Page
13:22:59 <dons> $ ssh code.haskell.org
13:23:00 <dons> ssh: connect to host code.haskell.org port 22: No route to host
13:23:00 <dons> mm
13:23:06 <seafood> dons: Hey dons.
13:23:16 <seafood> Thanks for all your help. I emailed Eelco and Chris last night.
13:23:21 <byorgey> edwardk!
13:23:29 <edwardk> heya byorgey
13:23:29 <byorgey> glad to hear you are alive =)
13:23:33 <edwardk> hah
13:23:38 <edwardk> been buried in a toy project
13:23:40 <dons> seafood: and today there was a wiki released, using happs as the framework, http://johnmacfarlane.net:5001 which is cool. lots happening
13:23:41 <lambdabot> Title: John MacFarlane
13:23:42 <fynn> hello.
13:23:50 <vixey> hi
13:23:53 <byorgey> edwardk: oh? and what might that be?
13:23:59 <byorgey> welcome, fynn
13:24:03 <fynn> what's the best way to get the latest GHC running on Ubuntu Hardy?
13:24:03 <seafood> dons: Sexy
13:24:21 <fynn> is there a PPA repo or something?
13:24:42 <fynn> the one in the regular repos is 6.8.2
13:25:04 <sctb> fynn: I would just grab the appropriate binary from haskell.org/ghc
13:26:19 <fynn> sctb: OK, though it would be nice to have a repo for it.
13:26:28 <fynn> that way you get automatic updates for free.
13:29:36 <roconnor> a few months ago (juneish) someone here wanted to know how I turned $5 into $72 on the IEM?
13:29:51 <vixey> @vera IEM
13:29:53 <lambdabot> No match for "IEM".
13:30:40 <pozic> Is there a library for managing pointsets with an associated measure (in any language)?
13:30:50 <vixey> probably ATS
13:31:33 <ivan> why does ghci assume that square is Integer -> Integer in 'let square = \x -> x*x'?
13:32:18 <mauke> I blame the monomorphism restriction
13:32:55 <shapr> dons: Yeah, good idea.
13:32:56 <vixey> next version of GHC should have monomorphism off
13:33:00 <arjanb> why does that question turn up multiple times a day now?
13:33:03 <shapr> dons: I haven't been able to build gitit
13:33:04 <roconnor> @help vera
13:33:04 <lambdabot> I perform dictionary lookups via the following 13 commands:
13:33:05 <lambdabot> all-dicts ... Query all databases on dict.org
13:33:05 <lambdabot> devils ...... The Devil's Dictionary
13:33:05 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
13:33:05 <lambdabot> elements .... Elements database
13:33:06 <lambdabot> [9 @more lines]
13:33:08 <ivan> > :t (\x -> x*x)
13:33:09 <lambdabot>   <no location info>: parse error on input `:'
13:33:28 <ivan> so, monomorphism kicks in when you assign it to a variable?
13:33:31 <roconnor> @go IEM
13:33:33 <lambdabot> http://www.biz.uiowa.edu/iem/
13:33:33 <lambdabot> Title: IEM - Iowa Electronic Markets - The University of Iowa
13:33:35 <dons> shapr: what fails?
13:34:08 <shapr> Says that HAppS-Server requires parsec 3.0.0 as well as parsec 2.1.0.0, does it build for you?
13:34:22 <rwbarton> gitit built for me
13:34:31 <ivan> alright, i found the docs for my problem
13:34:57 <evident> hey: got a little problem:
13:35:12 <roconnor> @seen gwern
13:35:12 <lambdabot> gwern is in #haskell, #xmonad and #darcs. I last heard gwern speak 18h 40m 25s ago.
13:36:01 <evident> what is the smartest way to check  whether a number x is a fraction (iE 4.25234) -> I only want whole numbers (1,2,3,4,)  ?
13:36:15 <mauke> what's the type of x?
13:36:20 <evident> Int
13:36:30 <mauke> then there is no need to check
13:36:45 <vixey> > 0.7 :: Int
13:36:46 <lambdabot>       No instance for (Fractional Int)
13:36:46 <lambdabot>        arising from the literal `0.7' ...
13:36:49 <evident> ohh right
13:36:59 <evident> how stupid from me
13:37:05 <evident> of course I know that
13:37:06 <vixey> > ((==1) . denominator) (2%3)
13:37:08 <lambdabot>   False
13:37:08 <vixey> > ((==1) . denominator) (4)
13:37:09 <lambdabot>   True
13:37:24 <evident> but from now on i should stop drinking when doing my homework
13:37:26 <mauke> :t (1 ==) . denominator . toRational
13:37:27 <evident> ^^
13:37:27 <lambdabot> forall a. (Real a) => a -> Bool
13:37:36 <f4lcon> lol, i could do with a drink right now
13:38:21 <f4lcon> im still stuck on this damn huffman coding problem, im sure its dead easy im probably reading my notes wrong :P
13:38:29 <shapr> Can anyone cabal install gitit ?
13:38:36 <rwbarton> shapr: Yes, I have
13:38:40 <vixey> f4lcon, why don't you hpaste everything you've written
13:38:44 <shapr> Ah, must be a problem on my end then.
13:38:52 <f4lcon> hpaste
13:38:57 <f4lcon> ?
13:39:58 <shapr> What's the best Haskell blogging framework? I want to put a blog up on my server, and I'd like for it to be in Haskell.
13:40:00 <yitz> evident: In a different language I used to write x`mod`y==0 as 100 IF X/Y=INT(X/Y) THEN 200
13:40:03 <f4lcon> ah ok i see
13:40:08 <yitz> but that was a while ago.
13:40:19 <cdfh> f4lcon: you're not doing Muffy's fp course at Glasgow are you? i seem to remember a huffman example...
13:40:30 <f4lcon> nah im not at glasgow
13:40:33 <cdfh> k
13:41:11 <cdfh> on reflection, i suspect Huffman is a fairly commonly used example exercise
13:41:17 <vixey> yitz' what is that COBOL?
13:41:24 <yitz> vixey: BASIC
13:41:26 <f4lcon> ye from googling around it seems so
13:41:38 <fynn> shapr: there's a Haskell blogging platform?!
13:41:52 <shapr> fynn: There have been several, I was just curious which one was best at the moment.
13:41:56 <yitz> planet haskell
13:41:57 <mauke> wasn't \ mod in basic?
13:41:59 <byorgey> f4lcon: hpaste.org is a Haskell pastebin
13:42:13 <yitz> mauke: there were thousands of dialects
13:42:27 <f4lcon> ye thanks byorgey just found it
13:42:37 <yitz> mauke: I'm talking about the early bare-bones form
13:43:35 <f4lcon> ok so atm here's what i have, http://hpaste.org/11855#a0. I have an alg to print out whats in the trees and another to return True if a certain Char exists in the Tree
13:44:02 <vixey> f4lcon: is Empty needed?
13:44:10 <mauke> '/= True' better written as 'not'
13:44:13 <f4lcon> Not rly i suppose
13:44:28 <mauke> or you could swap your cases
13:44:30 <vixey> say
13:44:31 <vixey> 	| searchTree y left/=True = searchTree y right
13:44:31 <f4lcon> as in not[searchTree y left] ?
13:44:31 <vixey> 	| otherwise = searchTree y left
13:44:32 <vixey> this bit
13:44:34 <vixey> you could write as,
13:44:45 <vixey> = searchTree y right || searchTree y left
13:45:04 <f4lcon> ah ok
13:45:22 <vixey> and then you might notice,  traverse and searchTree and pretty much the same pattern
13:45:22 <vixey> inspecting, data HTree a = Empty | Node (HTree a) (HTree a) | Leaf a
13:45:22 <vixey> you might find useful a function,
13:46:27 <f4lcon> Although i obviously need more algorithms, what i want to do is add a 0 everytime i take the left subtree, and 1 everytime i take the right subtree while working my way to a given char
13:46:32 <vixey> foldHTree empty node leaf Empty = empty ; foldHTree empty node leaf  (Node left right) = foldHTree empty node leaf left `node` foldHTree empty node leaf right ; foldHTree empty node leaf  (Leaf o) = leaf o
13:46:38 <vixey> if you had that then e.g.
13:46:48 <vixey> traverse = foldHTree [] (++) (:[])
13:46:52 <paczesiowa> Heterogenous Tree?
13:47:19 <f4lcon> and then return the coded string. i.e. "011011" etc
13:47:54 <dmwit> f4lcon: I recommend doing something that at first might seem slightly more difficult: return a list of *all* the paths that reach a node with that character in it.
13:48:09 <sctb> Planet Haskell down? 206.123.65.61: Destination Host Unreachable
13:48:46 <dmwit> http://downforeveryoneorjustme.com/planet.haskell.org
13:48:55 <lambdabot> Title: Huh?
13:49:00 <dmwit> Looks like it's down. =)
13:49:07 <f4lcon> well atm theres only 1 route to all of the chars in those 2 trees "c1" and "c2" dmwit
13:49:19 <dmwit> f4lcon: That's okay.
13:49:23 <dmwit> f4lcon: My recommendation stands.
13:49:27 <vixey> yeah dmwit has a good suggestion
13:49:36 <vixey> more specificaly, write a function with this type:
13:49:43 <vixey> HTree a -> HTree (a,Path)
13:49:57 <vixey> where Path is [Left,Left,Right] or "011011" or whatever
13:50:06 <dmwit> whoa
13:50:15 <dmwit> That seems a bit like overkill, but I guess that could work, too.
13:50:28 <dmwit> Why not just a -> HTree a -> [Path]?
13:50:38 <f4lcon> well that's what im aiming for
13:50:48 <f4lcon> the problem im having is getting that path
13:50:52 <paczesiowa> what does the 'H' stand for?
13:50:53 <dmwit> I guess even a -> HTree a -> Maybe Path could work, too, now that I think about it.
13:51:11 <dmwit> f4lcon: I withdraw my suggestion.  Finding one path (rather than all of them) will be just as easy. =)
13:51:14 <rwbarton> paczesiowa: Huffman possibly
13:51:15 <f4lcon> i.e. adding 0s and 1s to a list everytime it takes a left or right, i dont know how im supposed to go about that
13:51:15 <vixey> I'm pretty sure that HTree a -> HTree (a,Path) is the most general and easiest to write
13:51:30 <f4lcon> paczesiowa , huffman
13:51:46 <paczesiowa> damn
13:52:09 <dmwit> :t \leftAnswer rightAnswer -> liftM (0:) leftAnswer `mplus` liftM (1:) rightAnswer
13:52:09 <lambdabot> forall t (m :: * -> *). (MonadPlus m, Num t) => m [t] -> m [t] -> m [t]
13:52:18 <f4lcon> also i want it to be Maybe Path like dmwit mentioned
13:52:58 <vixey> :t Data.Map.Lookup
13:53:00 <lambdabot> Not in scope: data constructor `Data.Map.Lookup'
13:53:01 <vixey> :t Data.Map.lookup
13:53:02 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
13:53:10 <vixey> that 'm' is actually Maybe
13:53:29 <dmwit> No, it's actually (Monad m) => m.
13:53:39 <dmwit> Unless you're on GHC 6.10.
13:53:39 <luite> it was changed to Maybe
13:53:43 <luite> yes :P
13:53:51 <mauke> awesome
13:54:23 <dmwit> I would have preferred switching to MonadPlus, but they could have made much worse decisions. =)
13:54:30 <vixey> :t (,) []
13:54:32 <lambdabot> forall a b. b -> ([a], b)
13:54:35 <dmwit> Every step away from "fail" that the standard libraries take is a good one. =)
13:55:21 <dmwit> ?quote shemantics
13:55:21 <lambdabot> No quotes match. That's something I cannot allow to happen.
13:55:26 <yitz> dmwit: Maybe is the universal MonadPlus, so they're essentially equivalent
13:55:36 <dmwit> s/universal/initial/
13:55:59 <yitz> dmwit: initial is a special case of universal, in the appropriate category
13:56:15 <dmwit> Ah, I didn't know about the term universal.  I apologize.
13:56:20 <dmwit> What does universal mean?
13:57:29 <yitz> univerally attractive means every object has a morphism to it.
13:57:47 <yitz> and conversely
13:57:48 <rwbarton> In my experience "universal" often means the writer was too lazy to figure out whether it was initial or final
13:57:57 <yitz> rwbarton: exactly
13:58:23 <aeolist> could anyone take a look at this simple program and tell me why it seems not to take advance of laziness http://hpaste.org/11856
13:58:39 <dmwit_> (Also, while I realize that Maybe a is "as good as" MonadPlus m => m a in one sense, I still disagree that it they are "as good as" each other in the important sense.)
13:59:23 <dmwit_> ...in that I use Haskell partly for its powerful polymorphism.  Every time you don't use it but could, you force me to write my own conversion function to feel comfortable.
13:59:45 <ddarius> rwbarton: It's usually obvious whether something is universal or couniversal and the term can be expressed via initiality but that usually takes more effort so it is more "general" in a sense.
13:59:46 <roconnor> @seen asdftimo
13:59:47 <lambdabot> I haven't seen asdftimo.
14:00:10 <b_jonas> isn't that called free?
14:01:30 <rwbarton> aeolist: the only difference between same_fringe and same_fringe2 I can see is you don't have the cases like comparator (x:xs) [] = False
14:01:36 <rwbarton> aeolist: but I don't know what your question is
14:01:56 <yitz> dmwit: but you don't need a type-specific conversion function here. You can convert back and forth between Maybe and MonadPlus.
14:02:16 <dmwit> yitz: Right, but needing the function *at all* is stupid.
14:02:19 <aeolist> yes that's wrong, but anyway... my question is like this: i thought that same_fringe2 would evaluate 1 element of each list and then compare them
14:02:58 <dmwit> yitz: When I want a Maybe, everything is fine, but when I'm in a list do block, suddenly my code has to be longer for no real reason.
14:03:23 <b_jonas> I think you can only convert in one way
14:03:26 <u_quark> > [1..10000000000] == [2..10000000001]
14:03:28 <lambdabot>   False
14:03:28 <yitz> dmwit: I suppose. I intentionally didn't form an opinion on this. I wanted to focus my activism on getting rid of fail.
14:03:29 <dmwit> Haskell has awesome power to express things succinctly.  Failing to provide polymorphism takes a potshot at that characteristic.
14:03:34 <dmwit> yeah
14:03:35 <aeolist> instead of that, it seems to evaluate them completely, then start comparing. or at least that's what i think happens, because 2 lists of 100.000 elements each with a different head take the same time with 2 lists whose last element differs to evaluate
14:03:36 <vixey> @pl \u v -> f (x u) (f v)
14:03:36 <lambdabot> (. f) . f . x
14:03:38 <b_jonas> you can convert from a maybe to a monadplus, but not the other way
14:03:39 <aeolist> is that clear?
14:03:40 <rwbarton> aeolist: yes, that's how it will work.  Why do you think otherwise?
14:03:40 <vixey> @pl \u v -> f (x u) (y v)
14:03:41 <lambdabot> (. y) . f . x
14:03:47 <vixey> :/
14:03:50 <dmwit> yitz: As I said, I definitely appreciate the move away from fail. =D
14:04:23 <b_jonas> it's in haskell98 so it's not so easy
14:04:38 <dmwit> b_jonas: Nonsense.  Just cast the MonadPlus as a Maybe.
14:04:53 <dmwit> > mzero :: Maybe Int
14:04:54 <lambdabot>   Nothing
14:05:05 <b_jonas> mauke: no, \ is integer division in basic, mod is called mod there too
14:05:11 <mauke> ah
14:05:12 <b_jonas> and it only works in some languages
14:06:02 <yitz> b_jonas: my first dialect of BASIC had neither \ nor MOD.
14:06:14 <rwbarton> aeolist: perhaps something else is dominating the time spent.  It's hard to say without a concrete test case.
14:06:42 <b_jonas> yitz: yep
14:06:48 <b_jonas> yitz: these are newer addittions
14:06:54 <b_jonas> the are there in GWBasic
14:07:08 <ddarius> Arithmetic was not considered basic enough
14:07:13 <Cale> dmwit: It's not clear from MonadPlus m => m a whether there are many results or at most one.
14:07:25 <dmwit> That's okay.
14:07:31 <vixey> you know this:  lookup :: (Eq a) => a -> [(a, b)] -> Maybe b
14:07:32 <aeolist> rwbarton: i'll come back with some concrete numbers, but i think that fringe is evaluating the whole list in both cases
14:07:33 <vixey> is there one like
14:07:37 <b_jonas> ddarius: consider how it had to run in 4K of ram and 16K of rom
14:07:41 <vixey>  lookdown :: (Eq b) => b -> [(a, b)] -> Maybe b
14:07:42 <b_jonas> or something like that
14:07:42 <vixey> ?
14:07:49 <vixey> oops
14:07:50 <dmwit> Cale: Oh, I see what you're saying.
14:07:50 <vixey>  lookdown :: (Eq b) => b -> [(a, b)] -> Maybe a
14:08:15 <ddarius> b_jonas: That's more than enough.
14:08:25 <dmwit> Cale: Yeah, that's a good point.  It might even be convincing, but I'm not totally sure yet.
14:08:51 <roconnor> @tell gwern I'm ready to tell you all my IEM secrets.
14:08:52 <lambdabot> Consider it noted.
14:08:59 <Cale> vixey: I don't think so, but you can map (\(x,y) -> (y,x)) over the list first.
14:09:13 <rwbarton> aeolist: well, fringe has to go all the way down the leftmost branch of the tree to return the first element
14:09:16 <vixey> I want to avoid that map
14:09:17 <yitz> ddarius: we had 8K of core, for two users. it was tight, believe me.
14:09:26 <roconnor> google not such a good way of searching through #haskell logs
14:09:28 <dermiste> hi folks
14:09:33 <rwbarton> aeolist: so depending on what shape of tree you pass it, it may take a long time to compute head . fringe.
14:09:35 <vixey> I think I will just construct my list with all the tuples (unnaturally) flipped
14:10:20 <dmwit> dermiste: Hiya!
14:10:20 <yitz> dermiste: hi
14:10:47 <aeolist> mmmm rwbarton that's a good ide
14:10:53 <aeolist> *idea
14:13:33 <b_jonas> ddarius: also, wordbasic has MOD but does not have \ nor ^ (power) -- these and the functions for handling binary files (CVt, MKt$, FIELD, LSET, GET, PUT) are the only important stuff missing from it, otherwise it's quite complete
14:14:16 <b_jonas> yitz: what was that about?
14:14:20 <b_jonas> yitz: and when?
14:14:54 <roconnor> > 3.8**(1/4)
14:14:55 <lambdabot>   1.3961944237683348
14:15:10 <dmwit> > sqrt (sqrt 3.8)
14:15:11 <lambdabot>   1.3961944237683348
14:15:33 <roconnor> > sqrt (5)
14:15:34 <mauke> preflex: wcalc 3.8^.25
14:15:34 <preflex>  1.396194423768335
14:15:35 <lambdabot>   2.23606797749979
14:15:45 <b_jonas> I'm always amazed what wonders people managed to do with very little memory
14:15:51 <vixey> @hoogle [Maybe a] -> [a]
14:15:52 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:15:52 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
14:15:52 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:15:52 <roconnor> > 3.8**(1/4) :: CReal
14:15:54 <lambdabot>   1.3961944237683349168403547245596773343274
14:15:55 <b_jonas> we couldn't do those kinds of things these days
14:16:40 <ddarius> http://www.sics.se/~adam/miniweb/
14:16:48 <lambdabot> Title: Miniweb - TCP/IP stack and web server in 30 bytes
14:17:30 <b_jonas> game boy, for example, has iirc 8K of ram (plus 8K of video ram) yet it could run any game
14:19:13 <dmwit> ddarius: wow
14:19:37 <Adamant> look at the Atari 2600. much less memory and you still got reasonably fun games
14:19:48 <b_jonas> wow indeed
14:20:38 <paczesiowa_> that depends on definition of fun
14:20:58 <paczesiowa_> atari wasn't addictive
14:21:09 <roconnor> oh wow Numeric.NonNegative.Chunky
14:21:21 <roconnor> I was thinking of writing this someday
14:23:09 <askentasken> http://hpaste.org/11857 , could some helpful soul help me with Big(O) for those algorithms? its python but im working with python alongside haskell because it is easirer to learn that way. 2nd on is O(n) right? one compare for each element and then update or not is O(1) * n. 1st one is quadratic? when testing it goes superfast
14:23:28 <Peaker> askentasken: why is it easier to learn Python alongside?
14:23:59 <askentasken> my poor-mind is deeply molested by a lot of OO-programming
14:24:16 <Peaker> askentasken: you can ask #python about the Python stuff, probably..
14:24:27 <Peaker> askentasken: doesn't seem to be a Haskell question..
14:24:43 <aeolist> rwbarton: that was it, thanks... this is a good example of fail on my part :)
14:24:48 <askentasken> it is a Big-O-question, not a python or haskell qustion
14:24:57 <vixey> f4lcon, how do build the huffman tree from the frequency table?
14:25:01 <TSC> askentasken: The complexity depends on the Python-specific operations, which we might not be familiar with
14:25:38 <f4lcon> Im not that far atm
14:25:52 <f4lcon> im just using a prebuilt huffman tree and trying to return the coded path
14:25:58 <vixey> f4lcon, I'm that far :D
14:26:15 <f4lcon> hope you can't tell im a beginner >.>
14:26:50 <f4lcon> I think its because my brain is stuck in java mode :/
14:27:06 <vixey> f4lcon, Yeah, I can't think of a good functional way to construct the tree
14:27:23 <bode> hey :)
14:27:24 <vixey> f4lcon, I have a neat way to build get the codes and encode messages with it though
14:27:42 <f4lcon> im all ears
14:27:45 <ksf> java can be quite fine if you're using inheritance and recursion elegantly.
14:27:56 <vixey> so I deleted the Empty thing from your data type
14:28:03 <vixey> data Huff a = Leaf a | Branch (Huff a) (Huff a)
14:28:11 <ddarius> It's even better if you don't use (implementation) inheritance
14:28:19 <vixey> so now you need a fold:  foldHuff leaf branch = phi
14:28:19 <vixey>  where phi (Leaf o) = leaf o
14:28:19 <vixey>        phi (Branch left right) = branch (phi left) (phi right)
14:28:29 <vixey> did that come out on 3 lines?
14:29:09 <f4lcon> nope but i know what u mean
14:29:17 <vixey> foldHuff leaf branch = phi
14:29:20 <vixey>  where phi (Leaf o) = leaf o
14:29:22 <vixey>        phi (Branch left right) = branch (phi left) (phi right)
14:29:29 <vixey> did that work now?
14:29:36 <ksf> like eg. http://www.fh-wedel.de/~si/klausuren/ia252-ss02.pdf
14:29:44 <f4lcon> ye
14:29:45 <lambdabot> Title: ¢¡¤£¦¥¨§ © ¦ § ¥ ¡¤ "! ¡ # § ¥ ¡ !%$&!'¡ ( ¦# ¥))%12!'3 !'  ...
14:30:06 <vixey> so, you know how to write the depth first traversal with it?
14:30:10 <vixey> Huff a -> [a]
14:30:40 <vixey> foldHuff ?x ?y :: Huff a -> [a]
14:30:51 <vixey> ?x :: a -> [a], ?y :: [a] -> [a] -> [a]
14:30:52 <lambdabot> Maybe you meant: . ? @ v
14:31:28 <vixey> f4lcon, I think the next thing I say might not make sense if you don't try that in a .hs file :)
14:32:08 <f4lcon> im just trying to get my head around what you're doin in the code atm :P
14:32:27 <vixey> ok ask me anything if it's not clear
14:33:03 <f4lcon> could you hpaste it instead pls ?
14:33:06 <vixey> btw foldHuff leaf branch takes a structure like  Branch (Branch (Leaf 'x') (Leaf 'y')) (Leaf 'z')
14:33:30 <vixey> and it rips out the foundation, replacing it with those functions resulting in ~~>  branch (branch (leaf 'x') (leaf 'y')) (leaf 'z')
14:33:55 <vixey> so if you make leaf = \x -> [x], and branch m n = m ++ n, see what you get ?
14:36:08 <f4lcon> all the contents in the tree?
14:36:11 <f4lcon> im guessin
14:36:15 <vixey> yes as one list
14:36:35 <vixey> but since haskell is lazy, you only take what you need.. you can think of it as depth first traversal
14:36:50 <vixey> (I mean operationally as well as just in terms of what the result is)
14:37:23 <vixey> where is your hpaste ?
14:37:31 <vixey> I don't see it in the list
14:37:31 <f4lcon> so basically making searchTree easier by just checking if 'a' exists in [a,b,c] ?
14:37:48 <vixey> well here is something to think about ,
14:37:50 <f4lcon> http://hpaste.org/11855#a0
14:37:59 <vixey> searchTree = foldHuff ?x ?y :: Huff a -> Bool
14:38:01 <vixey> that means
14:38:10 <vixey> ?x :: a -> Bool, ?y :: Bool -> Bool -> Bool
14:38:11 <lambdabot> Maybe you meant: . ? @ v
14:38:18 <vixey> oops
14:38:21 <vixey> searchTree e = foldHuff ?x ?y :: Huff a -> Bool
14:38:28 <vixey> you need the element you are looking for in scope
14:38:53 <vixey> f4lcon, that's half of what I have http://hpaste.org/11855#a2
14:39:42 <f4lcon> right but can the foldHuff help me find the route taken when its traversing?
14:39:50 <vixey> yes
14:40:28 <vixey> f4lcon, in general (this applies to every datastructure not just Huff) the idea is that if you set it up as a fold, when the function is naturally a fold (like in the cases of DFS, member, paths, a billion other functions).. the types you get for each but ?x and ?y in this case pretty much write the code for you
14:41:02 <vixey> you want some  ?x :: a -> Bool  so that it check if that a is the thing 'e' you are looking for, so \a -> a == e
14:41:42 <vixey> ?y :: Bool -> Bool -> Bool, is given the results of searching the left and right trees, what's the final result (||
14:41:42 <lambdabot> Maybe you meant: yarr yhjulwwiefzojcbxybbruweejw yow . ? @ v
14:41:53 <EvilTerran> ?yhjulwwiefzojcbxybbruweejw
14:41:53 <lambdabot> "\""
14:42:09 <rwbarton> ??
14:42:17 <rwbarton> @?
14:42:25 <rwbarton> @help ?
14:42:25 <lambdabot> ? [args].
14:42:25 <lambdabot> ? executes plugin invocations in its arguments, parentheses can be used.
14:42:25 <lambdabot>  The commands are right associative.
14:42:25 <lambdabot>  For example:    ? ?pl ?undo code
14:42:25 <lambdabot>  is the same as: ? (?pl (?undo code))
14:42:46 <EvilTerran> ?? foldr :: (?type foldr)
14:42:46 <lambdabot>  foldr :: forall a b. (a -> b -> b) -> b -> [a] -> b
14:43:00 <vixey> ?? foldl :: (?type foldr)
14:43:03 <lambdabot>  foldl :: forall a b. (a -> b -> b) -> b -> [a] -> b
14:43:07 <EvilTerran> ...
14:43:53 <vixey> ?? (?? (?? (?? ?yhjulwwiefzojcbxybbruweejw)))
14:43:54 <lambdabot>  "\"#$%&'()*+,\""
14:44:33 <EvilTerran> what
14:45:21 <vixey> f4lcon, did you try it out?
14:45:40 <f4lcon> about to, just need some coffee
14:46:16 <EvilTerran> ?? ?? ?read ?run let x = (?show ?yow) in "<yow> " ++ x ++ " <vixen> ?vixen " ++ x
14:46:17 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
14:46:29 <EvilTerran> grr. it works in /msg, i don't know why it doesn't work in the channel
14:46:33 <EvilTerran> ?? ?read ?run let x = (?show ?yow) in "<yow> " ++ x ++ " <vixen> ?vixen " ++ x
14:46:34 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
14:46:46 <vixey> ?? @run let x = (@show @nixon) in x ++ x
14:46:48 <lambdabot>   "You have to face the fact that whole problem is really the blacks. The key...
14:46:55 <vixey> ?? @run let x = (@show @nixon) in reverse x
14:46:57 <lambdabot>   ".ssenisub ytrid a si scitilop taht weiv lacinyc eht tcejer I"
14:47:10 <EvilTerran> @@ @read @run let x = (@show @nixon) in reverse x
14:47:11 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
14:47:18 <EvilTerran> ... it doesn't like the @read, does it?
14:47:28 <rwbarton> @help read
14:47:29 <lambdabot> read "<foo>". Print <foo>
14:47:38 <rwbarton> >  text "foo"
14:47:39 <lambdabot>   foo
14:47:40 <dmwit> ?read foo
14:47:41 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
14:47:44 <dmwit> ?read "foo"
14:47:44 <lambdabot>  foo
14:47:49 <vixey> > intercalate " . " (replicate 30 "(,)")
14:47:51 <lambdabot>   "(,) . (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,...
14:48:05 <vixey> @@ @type (@run intercalate " . " (replicate 30 "(,)"))
14:48:08 <lambdabot>  lexical error in string/character literal at end of input
14:48:14 <vixey> @@ @type (@run intercalate " . " (replicate 4 "(,)"))
14:48:16 <lambdabot>  [Char]
14:48:20 <vixey> @@ @type (@read @run intercalate " . " (replicate 4 "(,)"))
14:48:23 <lambdabot>  forall b b1 b2 a b3. a -> b -> (b1 -> (b2 -> (b3 -> (a, b3), b2), b1), b)
14:48:25 <vixey> @@ @type (@read @run intercalate " . " (replicate 6 "(,)"))
14:48:28 <lambdabot>  forall b b1 b2 b3 b4 a b5. a -> b -> (b1 -> (b2 -> (b3 -> (b4 -> (b5 -> (a, b5), b4), b3), b2), b1), b)
14:48:30 <vixey> @@ @type (@read @run intercalate " . " (replicate 8 "(,)"))
14:48:32 <lambdabot>  forall b b1 b2 b3 b4 b5 b6 a b7. a -> b -> (b1 -> (b2 -> (b3 -> (b4 -> (b5 -> (b6 -> (b7 -> (a, b7), b6), b5), b4), b3), b2), b1), b)
14:48:33 <vixey> @@ @type (@read @run intercalate " . " (replicate 100 "(,)"))
14:48:35 <lambdabot>  Prelude.read: no parse
14:48:55 <dmwit> truncation, probably
14:48:59 <rwbarton> > text $ intercalate " . " (replicate 30 "(,)")
14:49:00 <lambdabot>   (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,) . (,)...
14:49:29 <Peaker> @type text
14:49:30 <lambdabot> String -> Doc
14:49:49 <rwbarton> > text $ intercalate "." (replicate 30 "(,)")
14:49:50 <lambdabot>   (,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,).(,)...
14:49:54 <dmwit> > text "a\nb"
14:49:55 <lambdabot>   a
14:49:55 <lambdabot>  b
14:50:03 <rwbarton> > text $ intercalate ".\n" (replicate 30 "(,)")
14:50:03 <EvilTerran> ?? ?? ?run let x = (?show ?yow) in text$ "<yow> " ++ x ++ " <vixen> ?vixen " ++ x
14:50:04 <lambdabot>   (,).
14:50:04 <lambdabot>  (,).
14:50:04 <lambdabot>  (,).
14:50:05 <dmwit> :t vsep
14:50:05 <lambdabot>  (,).
14:50:07 <lambdabot>   <yow> My Aunt MAUREEN was a military advisor to IKE & TINA TURNER!!
14:50:10 <lambdabot>  (,).
14:50:11 <lambdabot> Not in scope: `vsep'
14:50:14 <lambdabot>   <vixe...
14:50:16 <lambdabot> [8 @more lines]
14:50:17 <vixey> I can't figure out any neat way to build a huffman tree
14:50:20 <EvilTerran> ...
14:50:20 <vixey> this is bugging me
14:51:48 <RLa> what does f 2 * 4 mean?
14:51:55 <Peaker> vixey: Histogram -> HuffmanTree?
14:52:01 <vixey> Peaker; yeah
14:52:02 <EvilTerran> > f 2 * 4 :: Expr
14:52:03 <lambdabot>   f 2 * 4
14:52:05 <EvilTerran> hm
14:52:09 <RLa> is it (f 2) * 4 or f (2 * 4)?
14:52:11 <vixey> RLa,  f(2) * 4
14:52:13 <dmwit> RLa: (f 2) * 4
14:52:15 <EvilTerran> RLa, the former
14:52:21 <RLa> thanks
14:52:24 <EvilTerran> RLa, function application binds tighter than any infix operator in haskell
14:52:26 <dmwit> RLa: Function application binds tighter than anything else in Haskell.
14:52:28 <dmwit> ...
14:52:29 <EvilTerran> and to the left
14:52:37 <dmwit> EvilTerran: Type slower.
14:52:38 <Eelis> Haskell lets one write   f = \x -> y   as  f x = y  . since the arrow equivalent of lambda is proc, would it not make sense to let one write    f = proc x -> y   as   f x = y   as well (when using GHC's -farrows)?
14:52:38 <EvilTerran> *associates to the left
14:53:16 <paczesiowa_> proc is like do
14:53:16 <Eelis> of course, this would only work if f is declared with some arrow type
14:53:17 <EvilTerran> Eelis, well, you'd need some kind of indicator that it was somehow different from a normal definition
14:53:21 <vixey> Peaker; how to write it in pure fp?
14:53:22 <rwbarton> Eelis: but... f = \x -> y is not the same as f = proc x -> y, while f x = y is the same as f x = y
14:53:27 <dmwit> Eelis: It is not clear then whether to make the result an arrow or a function.
14:54:04 <Eelis> yes, it would rely on f having been declared to have an arrow type
14:54:08 <Peaker> vixey: I donno, does it look real ugly if you convert a State-ish implementation to a pure one?
14:54:16 <Peaker> vixey: straight-forwardly?
14:54:24 <rwbarton> Eelis: I guess the compiler could wrap all function definitions in 'pure'
14:54:26 <vixey> Peaker, yes
14:54:34 <vixey> I can't figure out the right way to write this
14:55:21 <Peaker> vixey: does it have to be Huffman? What about using something more general than Huffman that lets you use more flexible encoding sizes for symbols? (over div/modulo encoding, for example)
14:55:32 <dmwit> Eelis: I guess probably the biggest issue is that proc introduces a block, but = doesn't.
14:55:51 <vixey> Peaker, you can think of a neat way to express something like that and huffman is a special case of it?
14:55:52 <Eelis> paczesiowa_: by the way, proc isn't like do, i think. one actually uses do in arrow notation as well, e.g:   f = proc x -> do ...
14:55:54 <dmwit> Eelis: So that would require a pretty serious change to the parser.
14:56:04 <Eelis> dmwit: hmm, i see.
14:56:22 <dmwit> (...I think.  I'm not sure I actually understand the notation, so I could be wrong.)
14:56:41 <eu-prleu-peupeu> hello allright!
14:56:45 <Peaker> vixey: I'm not sure, I think it might be easier to express than Huffman because you wouldn't have to coerce each symbol size to an approximate logarithm
14:56:54 <dmwit> eu-prleu-peupeu: Alright!  Hello!
14:56:54 <RLa> vixey, are you writing huffman compression algorithm?
14:56:57 <Badger> D:
14:57:04 <Badger> where did code.haskell.org go?
14:57:20 <Peaker> vixey: Not sure at all its possible, maybe its a brain fart :) I need to think more about it
14:57:28 <vixey> Rla,,,
14:57:28 <vixey> yes
14:57:42 <dmwit> Badger: I think a few haskell.org subdomains are down.
14:57:50 <sctb> community.haskell.org, I believe
14:57:54 <vixey> RLa, it's the homework problem #haskell is currently being beseiged by
14:58:04 <vixey> RLa, but I got interested in it :(
14:58:12 <Badger> damn. :(
14:58:14 <Peaker> vixey: btw: Do you plan on using adaptive Huffman? (Change the Huffman tree as the histogram is changing?)
14:58:14 <sctb> (is the one that is down)
14:58:17 <Valodim_> homework problem?
14:58:36 <RLa> i remember some course slides about how to construct huffman tree
14:58:45 <RLa> it was very straightforward
14:58:59 <RLa> bottom-up
14:59:30 <vixey> aha
14:59:35 <vixey> I was trying to think of a top down way
14:59:40 <vixey> I guess it must be bottom up
14:59:50 * Badger uses the old lambdabot repo.
15:00:12 <albdogo> hi
15:01:30 <RLa> what about f 2 * 4 in scheme?
15:01:38 <vixey> (* (f 2) 4)
15:01:49 <RLa> or other functional languages
15:01:54 <dmwit> What about it?
15:02:06 <vixey> f 2 * 4 (*  ocaml *)
15:02:11 <RLa> well, is there language where it is f (2 * 4)?
15:02:16 <EvilTerran> perl
15:02:22 <EvilTerran> depending on f
15:02:39 <mauke> not really depending on f in Perl :-)
15:02:45 <RLa> (actually that is homework problem too)
15:03:05 <mauke> you can make it a syntax error, but otherwise it's always parsed as f(2 * 4) AFAIK
15:03:38 <RLa> i'm must write new functional language and by syntax specification (given) it comes out that parses as f (2 * 4)
15:03:56 * EvilTerran thought "sub f ($) { ... }" did that, but it seems not
15:04:05 <dmwit> Sounds like your functional language is treating mathematical operators specially.
15:04:12 <mauke> no, * binds tighter than unary application
15:04:22 <dmwit> (Which is a perfectly reasonable thing for a homework problem.  It simplifies a lot of stuff.)
15:04:25 <EvilTerran> mauke, yeah, i just tested it, anyway
15:04:31 <RLa> (i have no unary -)
15:04:45 <f4lcon> lol i like how my simple problem is escalating :P
15:04:47 <lispy> > let f = (+1) in f (2 * 4)
15:04:49 <lambdabot>   9
15:05:20 <luite> what would be a good data structure for an undirected graph, for this algorithm: repeatedly remove nodes with degree 1, until there are no nodes left with degree 1.
15:05:21 <RLa> you use parentheses, that's cheating!
15:05:27 <luite> in an imperative language I would use node objects that have references to their neighbours. I'd add each node to a priority queue, sorted by degree (lowest degree first in queue). Then repeatedly extract the first node, decrease the degree of its neighbours and reinsert them in the queue. Stop when the first node in the queue has a degree of more than 1.
15:05:28 <mauke> unary application: the *other* arithmetic operation
15:05:44 <skorpan> in haskell, f 2 * 4 becomes f (2 * 4)
15:06:00 <luite> but I can't think of a good functional way to do this, without falling back on an IOArray or something
15:06:08 <mauke> o.ö
15:06:08 <Stephan202> > let f = (+1) in f 2 * 4
15:06:10 <lambdabot>   12
15:06:47 <Stephan202> skorpan: prefix function application binds stronger than any infix binary operator (right?)
15:07:03 <Valodim_> yes
15:07:16 <Valodim_> (f 2) * 4
15:07:30 <vixey> Theorem 3.7   A Huffman tree is optimal.
15:07:31 <Stephan202> Valodim_: right, that's what I wanted to show
15:08:11 <Valodim_> > let f = (+) in f 2 4 * 5
15:08:12 <lambdabot>   30
15:08:28 <rwbarton> luite: I would just use a Map Vertex (Set Vertex) to represent the graph
15:08:47 <f4lcon> vixey, I havn't covered that ?x, ?y stuff you posted earlier. Im still at beginner beginner level :P
15:08:59 <vixey> f4lcon: oh I just made up that notation
15:09:23 <vixey> f4lcon: so for example, if you write  3 + ?x, then by ?x :: Integer, I just mean  x can be anything, as long as it's an integer
15:09:23 <EvilTerran> ?type ?f ?x
15:09:24 <lambdabot> forall t t1. (?x::t, ?f::t -> t1) => t1
15:09:44 <SamB> "just made up"
15:09:46 <SamB> ... right
15:09:47 <EvilTerran> <.<
15:09:49 <EvilTerran> >.>
15:09:55 <vixey> SamB: It's not documented in some book I can point to
15:10:04 <f4lcon> oh like \n . annonymous funtions?
15:10:40 <EvilTerran> f4lcon, kinda, it's an odd idea someone had that ghc included as an extension a while ago but has since been determined to be not such a great idea
15:10:49 <vixey> oh by complete coincidence this actually works in GHC
15:10:54 <vixey> well that's excellent :)
15:11:04 <SamB> not a coincidence
15:11:06 <vixey> check it out,,
15:11:11 <luite> rwbarton: how can I quickly look up all nodes with degree 1 with that representation?
15:11:12 <SamB> it's an ... abuse of notation?
15:11:14 <f4lcon> does me using hugs make any differnecE?
15:11:24 <vixey> f4lcon, no that's fine
15:11:29 <EvilTerran> f4lcon, never mind about the ?foos, they were just for the sake of explanation
15:11:33 <SamB> (in fact, I think we've more or less decided that it's the only useful use of the notation ...)
15:11:45 <rwbarton> luite: Use a priority queue like before
15:11:59 <EvilTerran> f4lcon, read "?foo" as "insert the name of the appropriate variable here and everywhere else it says ?foo"
15:12:27 <f4lcon> ok cheers
15:12:47 <rwbarton> I would suggest just ignoring all the question marks...
15:13:55 <RLa> luite, what about adjacency matrix where rows are represented as bit vectors (which are represented by integers)
15:14:33 <luite> rwbarton: hm ok, I'm not quite sure how the 'references to the neigbours' and 'modify the degree of a node' would work in haskell, I have to admit that I don't have much experience with lazy self-referencing data structures
15:14:53 <f4lcon> think im gonna get some sleep and work on this tommorow
15:14:55 <f4lcon> thanks for the help
15:15:08 <vixey> awww
15:15:14 <vixey> I didn't get to waffle on about the fun bit :p
15:15:24 <MyCatVerbs> Waffles? Where?
15:15:24 <f4lcon> lol
15:15:26 <EvilTerran> RLa, sounds like how Data.Array.Unboxed.UArray (and Data.Array.(IO/ST).(IO/ST)UArray) work internally
15:15:30 <rwbarton> luite: You don't need to store actual "references", you can just store keys in the map.
15:15:32 <luite> RLa: an adjacency matrix wouldn't scale very well, even if it is represented by bitmaps
15:15:32 <RLa> oh
15:15:47 <f4lcon> well im still trying to get my head around what foldHuff is doing tbh but maybe after some sleep i'll get it
15:16:09 <rwbarton> luite: think of Map as a mutable array that doesn't require any special monads
15:16:16 <rwbarton> luite: but costs you an extra O(log n) factor
15:16:28 <luite> rwbarton: ah, makes sense
15:16:56 <EvilTerran> but log n < 64, so that's fine :P
15:17:04 <rwbarton> luite: if you care about O(log n) factors, then go ahead and use STArray and friends
15:17:08 <vixey> f4lcon, ok by :)
15:17:32 <dmwit> As my professor used to say: forall n. log n < 30
15:17:38 <luite> rwbarton: I don't really care, unless it's not fast enough ;)
15:17:58 <vixey> > map log [1..]
15:17:59 <lambdabot>   [0.0,0.6931471805599453,1.0986122886681098,1.3862943611198906,1.60943791243...
15:18:00 <vixey> QED
15:18:04 <EvilTerran> luite, in that case, use a Map initially
15:18:15 <EvilTerran> and, if it's too slow, you can re-work it for arrays later
15:18:48 <Peaker> > map (logBase 2) [0,100..]
15:18:50 <lambdabot>   [-Infinity,6.643856189774725,7.643856189774724,8.228818690495881,8.64385618...
15:18:57 <RayNbow> > dropWhile (<30) $ map log [1..]
15:19:08 <mauke> > 2^30
15:19:10 <lambdabot>   1073741824
15:19:12 <lambdabot>   thread killed
15:19:36 <luite> EvilTerran: yes, I'll do that :)
15:20:22 <luite> rwbarton: thanks for the tip
15:20:47 <EvilTerran> having O(log n) everywhere instead of O(1) some places and O(n) in others is very handy, and those're pretty much the only options for that sort of pure data structure
15:21:13 <vixey> oh what I'd like to know is,
15:21:40 <vixey> say you have a data like
15:21:41 <vixey> data Huff a = Leaf a | Branch (Huff a) (Huff a)
15:21:44 <vixey> how do you make
15:21:54 <vixey> data Huff ann a = Leaf ann a | Branch ann (Huff a) (Huff a)
15:21:54 <vixey> ?
15:22:26 <rwbarton> you mean "automatically"?
15:22:57 <RLa> vixey, for bottom up algorithm you probably need forest instead of single tree
15:22:58 <vixey> well programatically
15:23:12 <mark[w]> Planet Haskell seems to be offline. Anyone know why?
15:23:20 <vixey> RLa, I guess that [Huff Frequency Character] work
15:23:23 <rwbarton> Yeah, I think this is a common problem in algorithms which doesn't get much attention (as far as I know)
15:24:47 <EvilTerran> vixey, i'm not sure if i follow what you mean, but attribute grammars might suit
15:25:10 <EvilTerran> http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter
15:25:11 <lambdabot> Title: WhyAttributeGrammarsMatter - TmrWiki
15:25:45 <vixey> attribute grammars to construct a data _type_ not a function over them?
15:26:31 <EvilTerran> oh, right, you mean the type decleration, not values of the type?
15:27:43 <EvilTerran> you can get an equivalent type going the other way by using "Huff ()" instead of "Huff"
15:27:44 <rwbarton> vixey: one option is to work with  data TreeF a x = Leaf a | Branch x x and Mu (TreeF a)
15:28:00 <rwbarton> vixey: then you can change TreeF a to (Frequency, TreeF a)
15:28:19 <vixey> Mu (Frequency, TreeF) ?
15:28:35 <rwbarton> Erm, yeah, you know what I meant.  Something like that.
15:28:45 <vixey> I don't think anything like that can work
15:28:58 <rwbarton> data AddFrequency f a = AddFrequency (Frequency, f a)
15:28:58 <vixey> I think it's along the lines of what I would have liked to do though
15:29:19 <rwbarton> Mu (AddFrequency TreeF)
15:29:55 <ddarius> rwbarton: That leads to something isomorphic to data H ann a = Leaf a | Branch ann (H ann a) ann (H ann a)
15:30:58 <rwbarton> And then (ann, H ann a) is the same as Huff ann a from before
15:31:02 <rwbarton> It's not pretty, I agree.
15:31:06 * EvilTerran was thinking more along the lines of "data Tree l b a = Leaf (l a) | Branch (b (Tree l b a) (Tree l b a))", allowing "Tree Id (,)" for the usual case, but also "Tree ((,)ann) ((,,)ann)" etc
15:31:29 <ddarius> rwbarton: Uh, no it's not the same.
15:31:29 <vixey> hmmmmm
15:31:45 <rwbarton> ddarius: What makes you say that?
15:31:54 <rwbarton> ddarius: The annotations are just stored a level higher
15:33:06 <RLa> i think that plain lists (tho recursive) would work, you only need to divide characters into levels (distance from root)
15:33:16 <ddarius> rwbarton: I guess you are right.
15:33:16 <EvilTerran> then type AnnTree ann = Tree ((,)ann) ((,,)ann)  ~~  data AnnTree ann a = Leaf (ann, a) | Branch (ann, AnnTree ann a, AnnTree ann a)
15:35:11 <EvilTerran> you could do all kinds of weird things; "Tree [] Maybe" etcetc
15:35:46 <EvilTerran> er, not Maybe (wrong kind), but Either would work, albeit oddly
15:37:06 <vixey> that's cool
15:37:25 <lee_11> > fmap head [Just [1,2],Just [1,2]] == Just [1,1]
15:37:28 <lambdabot>   Couldn't match expected type `[a]'
15:38:29 <BONUS> > (fmap . fmap) head [Just [1,2], Just [1,2]]
15:38:32 <lambdabot>   [Just 1,Just 1]
15:38:42 <EvilTerran> > fmap fmap fmap head [Just [1,2], Just [1,2]]
15:38:45 <lambdabot>   [Just 1,Just 1]
15:38:48 <BONUS> gah!!
15:38:51 <EvilTerran> :D
15:38:55 <Twey> Hah
15:39:12 <int-e> > fmap head (sequence [Just [1,2],Just [1,2]])
15:39:14 <lambdabot>   Just [1,2]
15:39:22 <ushdf_> any haskell sdl sexperts
15:39:40 <ushdf_> we need to have an expertsexchange
15:39:48 <mdmkolbe> @index with
15:39:49 <lambdabot> Foreign.Marshal.Utils, Foreign.Marshal, Foreign
15:40:00 <EvilTerran> > fmap fmap fmap head sequence [Just [1,2],Just [1,2]] -- :D
15:40:03 <lambdabot>   Just [1,2]
15:40:33 <int-e> EvilTerran: stop replacing (.) by fmap, please :P
15:40:41 <EvilTerran> but it's funny! D:
15:40:48 <mauke> yeah, use liftM instead
15:41:00 <dmwit> (<$>)
15:41:06 <jsn> use <$>
15:41:33 <mauke> :t [(.), fmap, (<$>), liftA, liftM]
15:41:34 <dmwit> > (<$>) (<$>) (<$>) head sequence [Just [1, 2], Just [1, 2]] -- the UFO command
15:41:35 <lambdabot> forall b c a. [(b -> c) -> (a -> b) -> a -> c]
15:41:37 <lambdabot>   Just [1,2]
15:41:55 <jsn> hehe
15:42:02 <BONUS> am i just sleepy or retarded or what. i cant figure this out: http://hpaste.org/11859
15:42:03 <jsn> the UFO operator, ala Perl
15:42:11 <BONUS> why is the first piece of code like 10 times faster than the second
15:42:42 <rwbarton> BONUS: because the second is defaulting to Integer
15:43:05 <BONUS> ah
15:43:10 <EvilTerran> doh!
15:43:10 <BONUS> i thought stuff defaulted to Int?
15:43:18 <dmwit> newp
15:43:18 <EvilTerran> not by default :P
15:43:19 <mauke> no, the default default is Integer
15:43:19 <RLa> BONUS, you can do a lot better to find divisors
15:43:29 <BONUS> RLa: yeah i know this is just an example some guy posted
15:43:33 <BONUS> to illustrate how slow python is
15:44:11 <BONUS> this prints perfect numbers but they're just 2^(n-1) * (2^n - 1)
15:44:14 <dmwit> Actually, I'd be a bit surprised if Python was much slower at this.
15:44:18 <BONUS> it is
15:44:21 <BONUS> it's like 20 times slower
15:44:31 <dmwit> Written the same way, or written with for loops?
15:44:42 <BONUS> written with for loops
15:44:46 <BONUS> actually with generators
15:44:46 <dmwit> That's why.e
15:44:59 <dmwit> Try writing it with list comprehensions; you might get a surprise.
15:45:02 <RLa> i think some kind of sieve can be used here
15:45:21 <BONUS> writing it with list comprehensions makes it 2 times slower than writing it with generators :)
15:45:28 <BONUS> cause it creates lists in memory and all that
15:45:32 <BONUS> whereas generators are like lazy lists
15:45:32 * dmwit blinks
15:45:58 <BONUS> http://forums.somethingawful.com/showthread.php?threadid=2675400&pagenumber=31#post351887276
15:46:04 <lambdabot> Title: Python information and short questions megathread. - The Something Awful Forums, http://tinyurl.com/5bzc2j
15:46:34 <BONUS> this is the matter at hand, this guy has a CS prof who's like "hurrrr, your language is slow ha ha!"
15:47:36 <rwbarton> The Python is using arbitrary-precision integers, no?
15:47:47 <dmwit> BONUS: The "fast" version still uses a for loop.
15:48:07 <mauke> ghc has an -ohi flag, therefore haskell wins
15:48:08 <rwbarton> Or rather integers-that-might-be-arbitrary-precision...
15:48:31 <BONUS> yeah, that might be the key
15:48:34 <BONUS> arbitrary precision ints
15:48:48 <BONUS> well the for loop is there just to iterate over the generator
15:49:01 <mofmog> python is byte code interpreted
15:49:06 <mofmog> haskell is compiled
15:49:07 <mofmog> ?!?!?
15:49:07 <dmwit> Yes.  I'm saying "for" is slow.
15:49:08 <lambdabot> Unknown command, try @list
15:49:16 * mofmog missed the discussion
15:49:17 <dmwit> Using something like "map" can be considerably faster.
15:49:21 <BONUS> eh i jsut said it's compiled cause it's usually compiled
15:49:31 <BONUS> ah you're saying the for is slow?
15:49:38 <BONUS> let me try that a bit differently then
15:50:48 <BONUS> nah, no difference replacing the for loop with print list(perfect_numbers)
15:50:50 <BONUS> interesting
15:51:06 <dmwit> I do find that interesting.
15:51:30 <mofmog> why the heck does his school have "two streams"??!
15:51:38 <BONUS> haha
15:51:40 <mofmog> must be the difference between CS and CE
15:51:42 <Gabbie> Just don't cross them!
15:51:54 <BONUS> one for hot water, on for cold i guess
15:51:56 <mofmog> (Science vs Engineering)
15:52:14 <BONUS> scheme is just .. ugh .. ( ( ( ( PARENS ) ) ) ) )
15:52:26 <mofmog> BONUS: Scheme is a favorite language of mine >_<
15:52:42 <BONUS> haha
15:52:45 <BONUS> i gotta get used to the parens
15:52:52 <mofmog> (define (boners) (being (display "Boners") (boners)))
15:53:08 <vixey> mofmog: BEING?
15:53:22 <Stephan202> boners!!!11!eleven
15:53:25 <ddarius> begin sounded too imperative
15:53:30 <mofmog> ??
15:53:32 <vixey> BEGIN is implicit there
15:53:34 <mofmog> begin
15:53:41 <vixey> you don't want to write BEGIN there
15:53:46 <mofmog> you can
15:53:48 <mofmog> however
15:54:00 <lament> BONUS: pretend the parentheses are not there. They're not for you, they're for the compiler.
15:54:15 <mofmog> in some implementations of scheme, you need (begin ) to not have messed up IO
15:54:15 <BONUS> haha
15:54:28 <mofmog> BONUS: Just think of code as a big list
15:54:35 <mofmog> that's the whole point of s-exp
15:54:49 <ddarius> mofmog: s-expressions aren't lists and neither is code encoded into s-expressions.
15:54:53 <vixey> mofmog: You should use an R5RS compliant scheme
15:55:33 <lament> r5rs? that's oldschool
15:55:42 <rwbarton> mofmog: Just think of speech as a function from time to air pressure.  That's the most convenient way to work with it right? :)
15:56:08 <ddarius> rwbarton: I usually prefer the Fourier transform of that.
15:56:21 <mofmog> ddarius: I'm sorry, they're trees
15:56:29 <skorpan> mofmog: still wrong
15:57:05 <vixey> mofmog: I think ddarius is against homoiconic languages :p
15:57:09 <lispy> if I'm writing formally about haskell is () called Unit or unit?
15:57:20 <vixey> lispy, well I call it unit
15:57:33 <skorpan> i call it youtube
15:57:39 <ddarius> vixey: Not at all.  I'm against the term "homoiconic."
15:57:41 <dmwit> lispy: The value is called unit, the type is called Unit. ;-)
15:57:56 <lament> What Lisp Programmers Don't Want You To Know: Lisp programs aren't really lists!!
15:57:58 <dmwit> s/,/;/
15:58:15 <fynn> what's the most readable (for a relative newbie) Prelude.hs out there?
15:58:18 <ddarius> lispy: unit is just a word
15:58:26 <dmwit> fynn: The one in the Report.
15:58:29 <lispy>  We use the Haskell type Unit, or \h{()}, as the type of the
15:58:29 <dmwit> ?where Prelude
15:58:29 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
15:58:29 <lispy> empty repository.
15:58:31 <vixey> fynn, I don't know, I think Prelude is horrible
15:58:37 <ddarius> lispy: If you want to be formal it's ()
15:58:50 <fynn> vixey: well, I should still be able to learns some things from it.
15:58:55 <vixey> fynn, pretty much any haskell I write starts with import Prelude hiding (kitchen,sink)
15:58:58 <mofmog> Fine, i revise my statement
15:59:00 <mofmog> The term S-expression or sexp (where S stands for symbolic) refers to a convention for representing semi-structured data in human-readable textual form.
15:59:09 <fynn> at least, some relatively good Haskell code.
15:59:15 <fynn> dmwit: thanks.
15:59:23 <vixey> fynn, I like LogicT
15:59:38 <vixey> It's more interesting than prelude imo
15:59:51 <fynn> thanks.
15:59:56 <dmwit> It's also correspondingly more complicated, especially for a beginner.
16:00:08 <pumpkin_> is there a formal class of languages that regex + backreference recognizes?
16:00:13 <dmwit> I'll leave it up to you whether you consider that a positive thing or a negative thing.
16:00:19 <vixey> I read it as a beginner
16:00:26 <pumpkin_> pure regexes do regular languages, but I can't find any info on "extended" regexes
16:00:37 <dmwit> pumpkin_: Turing-complete certainly fits them.  There might be something more restrictive, too.
16:00:47 <pumpkin_> well  yeah :P
16:00:48 <ddarius> dmwit: If you are referring to s-expression syntax, I assert that you have no basis for that claim.
16:00:58 <pumpkin_> I was hoping for the more restrictive option :P
16:01:04 <skorpan> mofmog: you didn't revise your statement, you copied someone else's
16:01:06 <dmwit> ddarius: I was not referring to s-exp syntax at any time.
16:01:19 <vixey> turing-complete is not the class of languages...
16:01:28 <vixey> that matches lots of things regex + backreferences doesn't
16:01:29 <pumpkin_> well, recursively enumerable?
16:01:41 <SamB> vixey: well, contains the class doesn't it ?
16:01:41 <mofmog> skorpan: yes, but i mean i agree with it now
16:01:43 <pumpkin_> well, yeah, but it's still a superset
16:02:03 <dmwit> vixey: Are you sure?
16:02:22 <dmwit> vixey: (I'm not.  I've seen implementations of prime-number generators written with regex+backref.)
16:02:37 <pumpkin_> the language is called recursively enumerable, the system is called unrestricted or turing equivalent, and the machine is called a turing machine :P
16:02:43 * mwotton is naming functions 'doit' and hates himself a little
16:02:51 <pumpkin_> but it still contains all the more restricted languages
16:02:55 * dmwit hates mwotton a little, too
16:03:05 <dmwit> ;-)
16:03:15 <mwotton> dmwit: don't worry, i promise i won't release it until it's unfucked
16:03:21 <lament> ur doit
16:03:27 <pumpkin_> anyone else have a "tighter bound" on the language of an extended regex?
16:03:35 <rwbarton> lament: ur doiting wrong?
16:03:39 <BONUS> does scheme support really large ints out of the box?
16:03:50 <dmwit> rwbarton++
16:03:57 <pumpkin_> maybe http://is.gd/Gf7 ?
16:04:17 <lament> BONUS: not only large, but mindbogglingly huge as well
16:04:38 <lament> after all, they need those ints in the interpreter to keep track of the nesting depth
16:04:50 <Stephan202> lol
16:05:05 <mauke> ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
16:05:28 <BONUS> haha
16:06:21 <mdmkolbe> BONUS: scheme support bigints yes
16:06:38 <mdmkolbe> BONUS: and exact fractions, etc.
16:06:43 <BONUS> kewl
16:06:58 <lament> in a language designed for teaching, it makes no sense to have restrictions on integer size
16:07:04 <mdmkolbe> see www.r6rs.org for more details
16:07:25 <lament> it would just confuse the students for no good reason
16:07:40 <mdmkolbe> lament: well that and the fact that scheme tries to represent an abstract math view rather than a machine view
16:07:49 <mauke> > sum (replicate 10 0.1) :: Rational -- scheme can't do this
16:07:51 <lambdabot>   1%1
16:07:53 <ddarius> lament: Not necessarily for -no- good reason
16:08:10 <mdmkolbe> mauke: why?
16:08:21 <mauke> because it thinks 0.1 is a floating point number
16:08:30 <mauke> or was that just common lisp?
16:08:38 * mdmkolbe checks
16:09:10 <mofmog> it returns 1%1 for me
16:09:16 <Riastradh> mauke, you can write #e0.1 to denote the exact rational number whose decimal representation is 0.1.
16:09:17 <mofmog> er
16:09:23 <lament> ddarius: other than to train the students to "get used to the real world", but i doubt A&S cared much about that
16:10:47 <mdmkolbe> mauke: from "(apply + '(0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1))" I get 0.999999 but from "(apply + '(#e0.1 #e0.1 #e0.1 #e0.1 #e0.1 #e0.1 #e0.1 #e0.1 #e0.1 #e0.1))" I get 1
16:10:58 <mauke> ah
16:11:53 <lament> one point for haskell, #e0.1 is ugley
16:11:55 <mdmkolbe> mauke: also note that (/ 1 10) gives the extact fration form not the inexact form
16:12:09 <mdmkolbe> and you can write 1/10 directly
16:12:20 <mauke> > 1/10 :: Rational
16:12:21 <lambdabot>   1%10
16:12:33 <idnar> > 0.1 :: Rational
16:12:35 <lambdabot>   1%10
16:12:47 <idnar> how does that work anyhow?
16:12:54 <lament> type classes
16:12:58 <lament> :t 0.1
16:12:59 <lambdabot> forall t. (Fractional t) => t
16:13:07 <rwbarton> :t fromRational
16:13:07 <lambdabot> forall a. (Fractional a) => Rational -> a
16:13:09 <dmwit> idnar: 0.1 is short for (fromRational 0.1).
16:13:09 <idnar> why isn't it, say, 100000000000000000001%1000000000000000000000
16:13:13 <mdmkolbe> mauke: yes "(+ 1/10 1/10)" goes to "1/5" and you can cast to exact form or back with the exact and inexact functions
16:13:17 <dmwit> idnar: Because it doesn't read it into a double.
16:13:24 <mauke> mdmkolbe: I know
16:13:29 <idnar> oh, fromRational
16:13:31 <dmwit> idnar: Since any program text is finite, you can read an exact representation into a Rational.
16:13:31 <EvilTerran> "a floating point literal stands for an application of fromRational to a value of type Rational (that is, Ratio Integer)." - the report
16:13:42 <idnar> okay, right, makes sense
16:17:34 <lispy> Wait, program text has to be finite?  But in a dynamic language, couldn't you have a program that is infinite length as long as you can evaluate it as a stream?
16:17:55 <yitz> The report describes it in terms of fromRational and fromIntegral because it's easier to standardize the semantics that way
16:18:09 <yitz> but in reality you don't need to mention those functions
16:18:20 <lament> lispy: there is a programming language that uses that for control flow
16:18:33 <lament> lispy: it doesn't have control structures, you just dynamically add stuff to the end of the program
16:18:49 <lament> so an infinite loop is an infinitely growing program
16:19:04 <lispy> yeah, it's a coprogram right? ;)
16:19:05 <mdmkolbe> lispy: who claimed it had to be finite?  (the REPL could be considiered a non-finite length languge)
16:19:05 <yitz> 0.1 is just a built-in constant variable of type Fractional t => t that has the value you think it does in every type that has a Fractional instance.
16:19:31 <Riastradh> yitz, so how do I tell Haskell what that value is with my own instance of Fractional?
16:19:35 <lispy> mdmkolbe: dmwit said any program text has to be finite
16:19:53 <EvilTerran> Riastradh, by defining fromRational appropriately
16:20:14 <rasfar> Can anyone confirm that "-main-is" works with runghc?
16:20:19 <rasfar> runghc -main-is Foo.bar Foo
16:20:28 <Riastradh> EvilTerran, yitz has claimed that the definition of the meaning of `0.1' is independent of the function fromRational, and that reference to fromRational in the definition is unnecessary.
16:20:35 <yitz> Riastradh: true. it uses fromRational for that. For the usual built-in types I would assume that's optimized away.
16:20:42 <rasfar> I get "Failed to load interface for `Main'" error.
16:20:42 <dmwit> mdmkolbe, lispy: At this point, probably my best recourse is to hide behind either "memory is finite" or "an infinite rational literal never returns a value, so it doesn't matter."
16:20:48 <Riastradh> yitz, `optimized away' is an issue of pragmatics, not of semantics.
16:20:55 <yitz> Riastradh: yep
16:21:09 <dmwit> rasfar: -main-is specifies the main function, not the Main module.
16:21:11 <dmwit> ...I think.
16:21:12 <Riastradh> So the definition of meaning of `0.1' really does need to mention fromRational.
16:21:13 <yitz> Riastradh: usually when people ask about it here, they need the pragmatics
16:21:30 <mauke> #1=(progn (print 42) #1#)
16:21:31 <EvilTerran> Riastradh, i don't think he's saying that, he's saying that it's not necessary to know about fromRational to be able to use fractional constants
16:21:47 <skorpan> mauke: what does that mean?
16:21:50 <lispy> dmwit: yeah.  I don't think there is a problem with saying program text is finite in schema, etc.  And I've heard that programs are finite state machines, etc.  I just had to wonder outloud about making the text an infinite stream with appropriate constraints (one being that it has finite fragments)
16:22:04 <mdmkolbe> dmwit: only the second wins, the first does help you b/c an infinite object can be represented and processesed in finite memory (e.g. last [0..])
16:22:08 <rasfar> dmwit: wow, the volume has increased around here since I was last around!  thanks for noticing my post.  Unfortunately it works with "ghc --make -main-is Foo.bar Foo" so I don't think that was the problem...
16:22:10 <skorpan> i mean #1= and #1#
16:22:15 <yitz> EvilTerran: yeah. I'm not arguing with the report about a good way to define the semantics. That would be futile. :)
16:22:17 <mauke> skorpan: fix (\_1 -> print 42 >> _1)
16:22:28 <skorpan> _1?
16:22:37 <EvilTerran> an odd choice of variable name
16:22:46 <dmwit> Looks boost-y.
16:22:54 <ddarius> EvilTerran: 1 isn't a great variable name
16:22:57 <lispy> > fix (\_1 -> print 42 >> _1)
16:22:58 <lambdabot>   Add a type signature
16:22:59 <mdmkolbe> EvilTerran: probably program generated
16:22:59 <ddarius> nor #1
16:23:24 <dmwit> mdmkolbe: That program is finite.
16:23:26 <lispy> > let 1 = "Yay, my variable!!!" in 1
16:23:27 <lambdabot>       No instance for (Num [Char])
16:23:27 <lambdabot>        arising from the literal `1' at <in...
16:23:29 <ddarius> It's CL literal syntax for sharing sexpressions.
16:23:32 <yitz> > let 1=2 in 1+1
16:23:34 <lambdabot>   2
16:23:37 <dmwit> mdmkolbe: (Even though it runs forever.)
16:23:46 <skorpan> > let _1 = "hello" in _1
16:23:47 <lambdabot>   "hello"
16:23:52 <EvilTerran> i think it's not so much that your program source necessarily has to be finite; that's a semantics issue anyway, when metaprograms get involved
16:23:58 <dmwit> mdmkolbe: My original claim was about program *text*, not runtime.
16:24:21 <mdmkolbe> dmwit: but something like [0..] could be the program generating the text that is being piped to your compiler/interpreter
16:24:22 <EvilTerran> but i know of no language where individual tokens are allowed to be infinite
16:24:49 <EvilTerran> mdmkolbe, in that case, it'll never finish compiling / interpreting that infinite numeric literal you're after, and so the whole thing's _|_
16:25:03 <dmwit> mdmkolbe: Right, but such a thing would get cut off when the compiler ran out of memory representing the AST.
16:25:23 <dmwit> mdmkolbe: Anyway, I'll happily agree that the second argument is much better than the first.
16:25:41 <lispy> Well, you could pipe /dev/urandom to perl if you want to test if program text can be infinite.  Warning: Who knows what that program will do.
16:26:00 <mdmkolbe> dmwit: not if the compiler has a scanner and we are representing (repeat 0 ++ 1) which will never grow the scanner's memory
16:26:47 <mauke> lispy: perl is a good choice because it will actually terminate :-)
16:26:56 <yitz> lispy: how about piping /dev/zero through tr \0 '(' and feed it to lisp
16:27:17 <mauke> perl treats ^D and ^Z as virtual EOFs
16:27:28 * mdmkolbe has spent too much time in computability thoery.  He's starting to wonder if the "infinite source" problem is PI_2 or Sigma_2
16:28:09 <ushdf_> i'm going to write the most amazing video game mankind has ever seen
16:28:11 <ushdf_> in haskell + sdl
16:28:41 <ushdf_> in the next few weeks
16:28:47 <ushdf_> ;)(
16:29:14 <mdmkolbe> ushdf_: phft.  It's in haskell so it should only take you 3 hours and 15 lines ;-)
16:31:18 <ushdf_> mnhm
16:32:42 <mwotton> memory debugging is sort of crazy. does 55 gigs of memory traffic sound like sort of a lot?
16:33:18 <SamB> what do you mean by memory traffic ?
16:33:22 <SamB> you mean allocation?
16:33:26 <mwotton> yeah
16:33:32 <mdmkolbe> mwotton: if the run in 55 seconds in a 1GHz machine where every instruction touches one byte of memory then yes
16:33:33 <SamB> a bit much, yes
16:33:41 <mwotton> i mean, it stays below 600mb usage
16:33:53 <SamB> how much time ?
16:33:57 <mwotton> 67 s
16:34:03 <rwbarton> mwotton: You can run with +RTS -sstderr to see how much time the GC is using
16:34:12 <mwotton> it's about 30% productivity
16:34:15 <SamB> mwotton: what does it do ?
16:34:17 <mdmkolbe> SamB, mwotton: do you mean allocation or traffic between the CPU and RAM?
16:34:26 <mwotton> allocation - sorry, i was probably being imprecise
16:34:55 <mwotton> i'm trying to optimise a program i wrote that builds up a big data structure in memory by serialising the structure once it's been built
16:35:20 <mwotton> unfortunately, serialising it and deserialising seem to take more time than actually building it from the data
16:36:56 <RayNbow> just posted by dons: http://www.reddit.com/r/programming/comments/7c7uy/a_neighborhood_of_infinity_from_monoids_to_monads/
16:36:58 <lambdabot> Title: A Neighborhood of Infinity: From Monoids to Monads : programming, http://tinyurl.com/5qjjka
16:38:34 <rwbarton> > let x <#> y = x * y in 3 <#> 4
16:38:36 <lambdabot>   12
16:39:00 <rwbarton> oh I see
16:39:22 <mwotton> aw man. defining infix operators in let bindings? that's just nasty
16:39:23 <mdmkolbe> mwotton: what do you mean by serializing?  to a file?
16:39:30 <mwotton> yep
16:39:40 <dons> interesting point of view, http://www.reddit.com/r/programming/comments/7c7h3/ask_proggit_what_do_you_think_about_ocaml_is_it/c069g4b
16:39:42 <lambdabot> Title: eklitzke comments on Ask Proggit: What do you think about Ocaml?, Is it good? Is ..., http://tinyurl.com/6ac27u
16:39:52 <mdmkolbe> mwotton: well file IO can be slow, especially in Haskell
16:39:56 <mwotton> as background: i spend about 10-20 seconds building it from the source data, which is annoying.
16:40:09 <dons> mwotton: Data.Binary.encodeFile/decodeFile ?
16:40:11 <dons> deriving Binary
16:40:11 <RayNbow> > let _*_ = 42 in 3*4
16:40:13 <lambdabot>   42
16:40:18 <mwotton> dons: yeah, i stole your code already :)
16:40:22 <mdmkolbe> mwotton: IIRC, the darcs people had a lot of trouble with improving the haskell IO performance
16:40:32 <dons> mdmkolbe: they use bytestrings. story over.
16:40:40 <roconnor> > let _*_ = 42 in 7*6
16:40:42 <lambdabot>   42
16:40:54 <mdmkolbe> dons: story over good or story over bad?
16:40:56 <dons> rumours from 5 years ago aren't too useful when considering technologies today, also. i'd argue.
16:41:02 <Nafai> dons: Is OCaml really "abandoned"?
16:41:03 <dons> story's good. io isn't an issue.
16:41:14 <dons> Nafai: i don't know. i've not seen such a strong statement before.
16:41:15 <mwotton> i'm using encodeFile and decodeFile - it's in the get/put instance for the Binary instance for Map
16:41:20 <mwotton> that there's a problem
16:41:29 <dons> mwotton: actually, there's a new instance for Map.
16:41:35 <dons> that uses the built in 'size' Map has
16:41:40 <mwotton> managed to get rid of the stack overflow by inlining the size rather than calling length
16:41:44 <mwotton> oh!
16:41:49 <roconnor> dons: is my string code automagically rewritten to use bytestrings?
16:41:51 <mwotton> awesome. where can i get it?
16:41:52 <dons> mwotton: oh, you wanna try out a test tarball?
16:41:56 <mwotton> sure
16:42:04 <mwotton> lets me get rid of my awful hackaround
16:42:04 <ushdf_> can you imagine how bad inflation is on virtual currencies, when the administrator can just change how much money he has by typing something
16:42:26 <mwotton> dons: does it do that chunking trick you suggested?
16:42:26 <dons> roconnor: come on. you don't really want that, do you?
16:42:27 <mauke> anyone here running 6.10? how much will break when I upgrade? :-)
16:42:34 <dons> mauke: 3%
16:42:40 <mauke> hah
16:42:52 <dons> mwotton: http://galois.com/~dons/tmp/binary-0.4.4.tar.gz
16:43:14 <roconnor> dons: maybe I'm getting bytestring and fusion mixedup.
16:43:56 <dons> mwotton: so what was the issue? stack overflow serialising a big Map ?
16:44:27 <mwotton> dons: yep, first off.
16:44:32 <mwotton> i got rid of that one using the size trick
16:44:39 <mwotton> but it's still reaaaaaally slow
16:45:09 <mwotton> with the new binary instances, can i just assume that Map serialisation will be fast?
16:45:24 <mauke> fuck
16:45:33 <mauke> ghci doesn't use my ~/.inputrc anymore
16:46:52 <mwotton> mauke: ah, unlucky. hit the 3%, i guess...
16:46:53 <dons> mwotton: which ghc version?
16:46:58 <mwotton> 6.10
16:47:01 <dons> ah ha. yes.
16:47:06 <dons> that is what is fixed by the above tar ball
16:47:06 <mwotton> although it might have been a prerelease candidate
16:47:16 <dons> some inlining broke down making binary 'get' about 100x slower. that was fixed today.
16:47:26 <mwotton> dons: oh, awesome
16:47:29 <mwotton> i love being on the cutting edge
16:47:33 <mdmkolbe> mwotton: what dons failed to mention what that is was 3% of every program not 3% of programs ;-)
16:47:34 <dons> yup.
16:47:46 <dons> mdmkolbe: 3% of hackage which used to build, doesn't build now.
16:47:57 <dons> is what i actually meant. (cabal install foo )
16:48:16 <ddarius> @users
16:48:16 <lambdabot> Maximum users seen in #haskell: 559, currently: 519 (92.8%), active: 26 (5.0%)
16:49:20 <dons> mmm
16:49:34 <mdmkolbe> dons: oh cool. I'll have to put "provides ghc test suite" on my list of reasons why hackage is nice.
16:49:53 <dons> well, it tests the type system and code generator.
16:50:00 <dons> doesn't tell you if the optimiser is broken, or the GC is busted.
16:50:03 <dons> we need somthing else for that.
16:50:09 <yitz> mauke: editrc instead now, I think.
16:50:22 <mauke> yitz: where does it look for editrc?
16:50:31 <yitz> ~/.editrc
16:50:33 <ddarius> dons: Don't we already have the "something else"
16:50:54 <mauke> yitz: how do I specify an empty argument in editrc?
16:50:54 <yitz> it's editline instead of readline
16:51:12 <yitz> mauke: dunno. ask judah.
16:51:22 <mauke> who's that?
16:51:29 <yitz> jacobson
16:51:39 <mauke> does he irc?
16:52:01 <yitz> if so I don't know his nick. He's on the various lists though.
16:52:09 <mauke> useless
16:52:13 <yitz> he
16:52:17 <yitz> heh
16:53:23 <dons> ddarius: mm. not of the size of hackage
16:54:42 <ddarius> dons: Well, no.
16:55:15 <mauke> oh, great. what's the difference between vi-search-prev, ed-prev-history, and ed-search-prev-history?
16:55:16 <yitz> @go editrc
16:56:54 <yitz> @bots
16:57:42 <yitz> mauke: on the man page we would get if \bot were responding, there's no ed-prev-history. vi-* is vi stuff, no?
16:58:16 <dmwit> It must be lonely on the other side of the split.
16:58:25 * mdmkolbe does the netsplit dance
16:58:37 <mauke> FFFFFFUUUUUU
16:58:42 <mwotton> much nicer over with with the judean people's front
16:59:03 <mauke> I wrote an editrc, started ghci and ... IT ATE ALL MY RAM
16:59:13 <Valodim_> what? hail the people's front of judea!
16:59:19 <pumpkin_> epic fail
16:59:47 <mwotton> dons: alas, no luck - when i set it back to the Map based binary, i still get a stack overflow
17:00:01 <dmwit> mauke: Well, what do you expect?  Chips are delicious!
17:00:20 <yitz> mauke: can you cut down the editrc and figure out which command borked it?
17:00:38 <mauke> first I want to find out what it's doing
17:00:49 <yitz> mauke: eating all of your ram
17:01:19 <mauke> hmm, but only when running interactively, it seems
17:02:54 <mauke> open("/home/mauke/.ghc/ghci_history", O_RDONLY) = 5
17:02:54 <mauke> read(5, "_HiStOrY_V2_\n"..., 4096)      = 13
17:02:54 <mauke> read(5, ""..., 4096)                    = 0
17:02:54 <mauke> read(5, ""..., 4096)                    = 0
17:03:05 <mauke> ^ repeat ad infinitum
17:03:24 <askentasken> anyone using openvision?
17:03:24 * mdmkolbe finishes the netsplit dance
17:03:41 <yitz> @bots
17:04:07 <Badger> yitz: nicely done.
17:04:20 <dmwit> We'll name our file _HiStOrY_ to avoid conflicts, HOW CAN IT FAIL?
17:04:40 <Badger> dmwit: unpossible!
17:04:41 <lambdabot> :)
17:04:59 <dmwit> Although if the file name actually includes a newline character, it's much less likely to have conflicts. ;-)
17:05:01 <Badger> o_O
17:05:05 <mauke> ok, reading the history file is broken
17:05:19 <askentasken> @bots
17:05:19 <askentasken> ?
17:05:19 <askentasken> @src mapM
17:05:19 <askentasken> @seen lambdabot
17:05:19 <askentasken> lol that obv doesnt work
17:05:20 <lambdabot> :)
17:05:20 <lambdabot> mapM f as = sequence (map f as)
17:05:20 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #
17:05:20 <lambdabot> haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #
17:05:20 <lambdabot> darcs, #arch-haskell, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
17:05:26 <Badger> who's in lambdabot's guts?
17:05:49 <yitz> @vixen who's in your guts?
17:05:50 <lambdabot> that's a good question, who?
17:06:04 <Badger> heh
17:06:10 <dmwit> ?vixen I'm in your guts!
17:06:11 <lambdabot> have you ever scubadived?
17:06:23 <dmwit> ?vixen I love diving!  corn
17:06:24 <lambdabot> Have you ever killed a hobo?  Ive found eating their liver gives me strength.  I think i may just be short on b vitamines.
17:06:35 <Badger>  
17:06:37 <dmwit> O_o
17:06:39 <mwotton> that got weird fast
17:07:40 <mwotton> and i'm pretty sure all that's in vixen's guts is a tree of regular expressions
17:07:52 <mwotton> 'less some sneaky bastard's rewritten her
17:08:38 <Badger> ?vixen you're make of regexp?
17:08:39 <lambdabot> no
17:08:49 <Badger> ?vixen are you sure?
17:08:50 <lambdabot> yes, i am
17:09:07 <Badger> ?vixen if you say so.
17:09:07 <lambdabot> oh, but only if, right?
17:09:14 <mwotton> be careful, man. she'll lie to you straight up, then break your heart.
17:09:21 * Badger sobs.
17:09:41 <dmwit> ?vixen a/s/l
17:09:41 <lambdabot> 19/f/California
17:09:46 <Badger> haha
17:09:49 <ddarius> The sun never sets on the Haskell empire.
17:10:17 <mwotton> ... it rose already?
17:10:25 <jeffwheeler> What is lambdabot doing in #freebsd?
17:10:28 <Badger> I don't think it rises, either
17:10:37 <jeffwheeler> That's odd.
17:10:43 <Badger> hell, why not?
17:10:47 <dons> jeffwheeler: hmm?
17:10:53 <dons> jeffwheeler: did someone invite her?
17:10:53 <yitz> our bot has become popular.
17:11:05 <jeffwheeler> It's op or something, too, I think.
17:11:11 * Badger wishes he could compile it.
17:11:39 <dons> mwotton: can you send me a test program? maybe one that constructs a Map of a reasonable size, and triggers a failure?
17:12:00 <yitz> mauke: any progress?
17:12:08 <mwotton> dons: sure.
17:12:49 <dons> btw, lads, just for record, one someone complains about haskell repl, remember hbi, bhttp://www.reddit.com/r/programming/comments/7c7h3/ask_proggit_what_do_you_think_about_ocaml_is_it/c069gmy
17:12:51 <lambdabot> Title: dons comments on Ask Proggit: What do you think about Ocaml?, Is it good? Is it  ..., http://tinyurl.com/6a6c5s
17:13:02 <mwotton> dons: not entirely sure whether it's because i'm building a map of maps, but i'll see how simple i can get it
17:13:26 <dons> ok.
17:13:29 <ddarius> dons: I always remember hbi
17:14:19 <dons> we should reverse engineer what it does, then work out how to implement that on ghci
17:14:31 <dons> since it seems to be fairly sensible
17:15:12 <ddarius> dons: Even without reverse engineering hbc, there should be no big problem with extending ghci.
17:15:52 <askentasken> what languages did dijkstra like? he was very mathematical but i havent got the impression he was super into functional programming? i read him praise Algol I think.
17:15:59 <dons> ddarius: i think so too.
17:16:41 <Nafai> "Fixing" ghci would help overcome a stumbling block of those coming from the lisps, Python, etc.
17:17:34 <dons> yep.
17:17:43 <dons> match expectations.
17:17:55 <dons> i think if hbi was more serious competition, we'd have it all by now.
17:18:07 <ddarius> I don't understand why GHCi was ever this way to begin with.
17:18:11 <Nafai> I've actually never heard of hbi
17:18:14 <ddarius> Or hugs.
17:18:35 <ddarius> Nafai: It's the Haskell compiler that Lennart built.
17:18:36 <dons> well, ghci is hugs reimplemented.
17:18:47 <dons> hbi : ghci :: hbc : ghc
17:18:49 <ddarius> Nafai: I believe it was the first Haskell implementation.
17:19:17 <Nafai> Interesting
17:19:21 <u_quark> > data Lala = Koko | Mama
17:19:22 <lambdabot>   <no location info>: parse error on input `data'
17:19:31 <u_quark> > let lala = 42
17:19:32 <lambdabot>   <no location info>: parse error on input `;'
17:19:40 <u_quark> > let lala = 42;
17:19:41 <lambdabot>   <no location info>: parse error on input `;'
17:19:50 <u_quark> neeeyyy
17:20:05 <lispy> > let lala = 42 in lala -- please use /msg lambdabot if you want to experiment
17:20:06 <lambdabot>   42
17:20:25 <dons> ?let data T = T
17:20:25 <lambdabot>  Invalid declaration
17:20:29 <dons> ah, we used to allow that.
17:20:50 <lispy> ah, the fond memories we have of the past ;)
17:21:21 <askentasken> what languages did dijkstra like? he was very mathematical but i havent got the impression he was super into functional programming? i read him praise Algol I think.
17:21:39 <dons> askentasken: he wrote a critical review of bakus' turing award speech, iirc
17:21:54 <dons> i don't think he's quite as bad as knuth, when it comes to language design though
17:22:08 <dons> after all, he advocated recursion early on :)
17:22:25 <lispy> sometimes people seem really into formal methods but not into functional languages :)
17:22:33 <mauke> $*#!*$
17:22:38 <dons> i wonder: would djikstra be a haskell programmer these days? or an isabelle hacker
17:22:47 <mauke> keyboard and mouse locked up, had to reset my machine
17:22:56 <mwotton> dons: pencil and paper hacker :)
17:22:58 <roconnor> I think djikstra would still be unhappy
17:23:03 <dons> hehe
17:23:03 <roconnor> and not use compuers
17:23:19 <dons> roconnor: did you see the poster going around of djikstra vs larry wall?
17:23:27 <ddarius> dons: The guarded command language is reasonably nice.  No where near as bad as Knuth's monstrosities.
17:23:34 <roconnor> refresh my memorry
17:23:36 <mwotton> dons: is currently my wallpaper
17:23:41 <dons> http://blog.lavsen.net/wp-content/uploads/2008/04/dijkstra-quick-n-dirty-s.jpg
17:23:42 <mwotton> one on each monitor
17:23:46 <dons> http://blog.lavsen.net/wp-content/uploads/2008/04/motivator4277506.jpg
17:23:47 <lambdabot> http://tinyurl.com/5gtmfc
17:23:48 <lambdabot> http://tinyurl.com/6g8d5j
17:23:49 <dons> mwotton: nice
17:23:51 <Nafai> mwotton: Haha
17:23:55 <roconnor> Djikstra gave a lecture at my university when I was an undergrad.
17:24:10 <roconnor> I think I got him to sign a copy of his algorithm
17:24:13 <lispy> hah
17:24:34 <sctb> It's Dijkstra by the way..
17:24:38 <dons> he has a fine beard in that photo.
17:24:40 <Adamant> Djikstra would probably be using Coq or Agda or Epigram to prove his programs
17:24:41 <roconnor> dons: I hadn't seen the larry wall one
17:24:53 <lispy> isn't calling just one algorithm djikstra's algo like calling one math theorem euler's theorem?
17:25:14 * ddarius points at what sctb said.
17:25:15 <roconnor> Adamant: I don't find that obvious.  He seems like a Hoare Triple kinda guy
17:25:37 <Adamant> roconnor: I figure he doesn't care how he gets the proof as long as he gets the proof
17:25:45 <Adamant> Hoare Triple was just his era
17:26:00 <roconnor> perhaps you are right
17:26:13 <Adamant> you work with what you got
17:26:31 <roconnor> Maybe I think he might like Coq/Agda
17:26:39 <yitz> mauke: oh. I guess that's why you weren't typing much. :)
17:26:45 <roconnor> but in practice he was probably set in his imperative ways, and too old to change soon
17:26:55 <askentasken> dons: whats bad about knuth whwen it comes to language design?
17:27:03 <Adamant> roconnor: I thought he experiemented with FP
17:27:06 <Adamant> the language
17:27:11 <Adamant> maybe I'm wrong
17:27:12 <roconnor> FP?
17:27:23 <Adamant> the one from the Fortan creator
17:27:26 <Adamant> *Fortran
17:27:29 <ddarius> askentasken: Have you seen any language that Knuth has created?
17:27:30 <Adamant> Backus
17:27:42 <roconnor> Adamant: I hadn't heard that
17:27:47 <yitz> ddarius: TeX
17:28:05 <Adamant> roconnor: yeah, it's just something I thought I read a passing comment from him about
17:28:06 <roconnor> I want to learn to do more Djikstra logicial arithmetic in my proofs.
17:28:13 <yitz> ddarius: that asm variant that he uses in all of his books, whatever it's called
17:28:19 <askentasken> but not all programs can be proven to work correctly right? because of undecidabilit. so what was dijkstars aim?
17:28:21 <Adamant> MIX and MMIX
17:28:21 <dons> mix?
17:28:26 <ddarius> Christ.  Dijkstra
17:28:28 <roconnor> although not quite logical, I've been trying to do min/max proofs without case analysis
17:28:35 <dons> ddarius: heh
17:28:37 <Adamant> askentasken: prove all the programs you need
17:28:55 <askentasken> ddarius: no
17:29:01 <ddarius> askentasken: Have you seen TeX?
17:29:13 <roconnor> askentasken: few people write programs that work but they have no idea why.
17:29:18 * lispy starts referring to Dijkstra as Dr. D for now :)
17:29:33 <dmwit> > sort "Dijkstra"
17:29:34 <lambdabot>   "Daijkrst"
17:29:40 <dons> ddarius: 'j' does not commute?
17:29:40 <yitz> roconnor: if only that were true
17:29:50 <roconnor> I thought Djik was a bit odd for dutch.
17:29:51 <ddarius> dons: Not in the quaternion algebra.
17:29:57 <askentasken> what do you mean? some people write correct programs but have no idea why or most people write programs with errors and have no idea why?
17:29:58 <roconnor> yitz: :)
17:30:05 <Adamant> Dr. Dijkstra the Dutchman
17:30:43 <ddarius> Freakin' Hamilton
17:30:49 <Adamant> ians
17:30:55 <roconnor> askentasken: you have to write a program with no algorithm in mind.  Other than genetic programming, I have no idea how you would do this.
17:31:25 <lispy> roconnor: come to my office, I have someone you should meet ;)
17:31:28 <yitz> roconnor: that's easy. write in MFC.
17:31:33 <askentasken> with no algorithm in mind? i dont even understand what youa re atalking about anymore, who has to do that?
17:31:56 <glguy> it's called "test driven development"
17:32:22 <Adamant> next comes proof driven development
17:32:34 <yitz> actually prolog claims to work that way.
17:32:52 <mwotton> dons: http://hpaste.org/11863
17:33:02 * roconnor gives up
17:33:11 <p_l> Knuth AFAIK didn't really care too much about programming languages. IIRC he stated that "Languages pass and go"
17:33:17 <mwotton> dons: up for debate whether 1 million entries in a map is excessive, but i need 1.5 million.
17:33:26 * ddarius wishes Knuth's languages would pass.
17:33:36 <dons> mwotton: cheers
17:33:41 <Adamant> but we're doomed to suffer though various incarnations of MIX forever if we want to read his books
17:33:48 <dons> mwotton: can you use IntMap ?
17:34:00 <mwotton> dons: almost
17:34:03 <dons> since you have Int keys. its 2x faster (int-based patricia trie)
17:34:06 <mwotton> i'd need int64
17:34:14 <dons> are you on a 64 bit machine?
17:34:16 <p_l> Adamant: He is rewriting the books to use MMIX, which is modern and very nice processor
17:34:19 <mwotton> yep, and in the real thing, that's what i'm using for the smaller ones
17:34:25 <dons> ok
17:34:26 <mwotton> yes, i'm on a macbook
17:34:27 <mwotton> pro
17:34:27 * roconnor tries ungiving up
17:34:32 <lispy> Adamant: yeah, I once got the idea that I should, for my own personal enlightenment, translate all his examples to Haskell.  Sadly I never made it anywhere on this.
17:34:36 <roconnor> askentasken: when you write a program, why do you type what you type?
17:34:44 <dons> Map.foldWithKey looks too lazy
17:34:46 <mwotton> but i can't seem to get native Ints, and IntMap is specialised to 32 bit ints
17:34:49 <Adamant> p_l: I just think the whole using assembler thing is silly
17:34:50 <ddarius> roconnor: Easy.  I cut and pasted it from the internet.
17:34:53 <dons> where does it fall over?
17:34:59 <dons> mwotton: oh!
17:35:03 <Nafai> lispy: Sounds like a lot of work. :)
17:35:18 <mwotton> dons: but the thing crashes in dec -
17:35:23 <Adamant> people can read the CLRS language more easily than MIX or MMIX
17:35:29 <dons> hmm. no. IntMap will work with 64 bit int
17:35:35 <dons> data IntMap a = Nil | Tip {-# UNPACK #-} !Key a | Bin {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask !(IntMap a) !(IntMap a)
17:35:39 <dons> type Prefix = Int
17:35:39 <dons> type Mask   = Int
17:35:39 <dons> type Key    = Int
17:35:46 <p_l> Adamant: I actually agree with his preamble. He often states that a good programmer has to understand both low and high level
17:35:52 <mwotton> ok, but on my machine maxBound gives a 32 bit int
17:35:59 <mwotton> have i built ghc wrongly?
17:36:02 <dons> yeah, probably.
17:36:06 <Adamant> p_l: I agree with that, but then express your algorithms at both levels
17:36:07 <dons> > maxBound :: Int
17:36:08 <lambdabot>   9223372036854775807
17:36:10 <mwotton> (it's a core 2 machine - it's definitely supported?)
17:36:18 <dons> yup
17:36:27 <mwotton> crud. oh well, at least that one's easily solved.
17:36:37 <dons> model name: Intel(R) Core(TM)2 Duo CPU     T7300  @ 2.00GHz
17:36:41 <p_l> Adamant: They are actually written at a very high level too, in a language called Natural. Quite high-level :)
17:36:45 <dons> Prelude> maxBound :: Int
17:36:45 <dons> 9223372036854775807
17:36:46 <mwotton> although i did just grab the installer package
17:36:49 * lispy still doesn't have 6.10 on his mac because of the installer pkg weirdness
17:37:03 <dons> i'll investigate.
17:37:03 <Adamant> p_l: I thought he only used MMIX
17:37:23 <mwotton> thanks for the help, don, i'll grab the latest and check again
17:37:27 <Adamant> if he's using a HLL too I might have to switch from thumbing through at the bookstore to buying his books
17:37:32 <askentasken> roconnor: because i have a specific behaviour in mind
17:37:55 <p_l> Adamant: It's even stated in the book that you don't need to understand MIX/MMIX, cause all algorithms are explained in <insert edition language> too
17:38:00 <roconnor> exactly
17:38:10 <Adamant> p_l: I must have missed that part then
17:38:28 <roconnor> askentasken: that is equivalent to a proof sketch.
17:38:34 <roconnor> what you have in mind.
17:38:41 <Adamant> anyway. sounds like I need to get the latest versions of his stuff then
17:38:43 <roconnor> ... often pretty sketchy
17:38:51 <roconnor> but a proof sketch none the less.
17:39:20 <p_l> Adamant: Wait for new edition, with MMIX instead of MIX. It's a pity most stuff uses x86 instead of a cpu like MMIX
17:39:23 * yitz doesn't have 6.10 on his mac because it
17:39:33 <yitz> it's Tiger :(
17:39:40 <Adamant> p_l: when will his stuff be revised with MMIX?
17:39:43 <sctb> lispy: Can't you build it with a previous version?
17:40:05 <lispy> sctb: I suppose, but I'd rather just install it
17:40:06 <p_l> Adamant: For the new revision. I don't know exactly when it will be published
17:40:18 * sctb once spent hours getting a static libgmp build going years ago, and has been building each release since
17:40:59 <lispy> sctb: the pkg installer would be fine if someone would tell it to stop installing 6.8.3 in the process :)
17:41:09 <lispy> sctb: sorry, *uninstalling*
17:41:33 <sctb> Hmm. I always thought that a distrib tree would be better for this process
17:41:44 <sctb> (like the Linux binaries)
17:43:08 <sctb> I could probably do so myself, binary-dist looks like a good target
17:43:10 <askentasken> roconnor: and i should later prove it? how?
17:43:17 <ushdf_> programs will be at their most advanced state when they consist as an editable list of commands in natural language
17:43:41 <ushdf_> such that the user is never confused as to the intentions of the program and the computer is never confused as to the intentions of the user
17:44:11 <askentasken> seems like a LOT of work manually proving a program correct. and im not familiar enough with math do so. and what about the programs that cant be proven?
17:44:15 <lispy> sctb: I could probably use macports to install it, but I hate how long that takes
17:44:20 <ushdf_> haskell's getting there, in a really strange way
17:44:46 <yitz> lispy: i'm pretty much stuck with that. it's actually not that bad though.
17:45:10 <ushdf_> with all your lambdas and preludes
17:45:14 <rwbarton> lispy: can you reinstall 6.8.3 afterwards?
17:45:29 <roconnor> askentasken: by getting traning in formal reasoning (to turn your proof sketch into an informal proof), and then writing down a formal proof in a computer proof assistant (to turn your informal proof into a formal proof).
17:45:34 <lispy> rwbarton: iirc that uninstalls 6.10
17:45:46 <mauke> libedit-- libedit-- libedit--
17:45:47 <ushdf_> formal reasoning doesn't require much training
17:45:53 <ushdf_> what throws you off is the syntactical requirements
17:46:22 <rwbarton> lispy: hmm... run the installers at the same time? :)
17:46:27 <lispy> rwbarton: haha
17:47:07 <roconnor> askentasken: whether you should do it or not depends on whether making your code provably correct is worth the expense.
17:47:07 <lispy> There was discussion about the problem on the mailing list (not sure which) and as far as I could tell, no one had a solution
17:47:33 <lispy> provably correct code comes at a very high labor price
17:47:34 <roconnor> askentasken: but my point is really that correct code is provably correct in an practical instances.
17:47:46 <roconnor> in all practical instances
17:47:52 <yitz> mauke: the idea was that you would be able to build a ghc with readline if you want to.
17:48:07 <yitz> mauke: i wonder if they stuck to that
17:49:18 <sctb> lispy: Building yourself has its advantages, I have many versions living under ~/Documents/GHC
17:49:27 <yitz> mauke: on what platform are you having troubl with editline?
17:49:45 <mauke> yitz: gentoo, see http://bugs.gentoo.org/show_bug.cgi?id=237882
17:49:57 <lambdabot> Title: Gentoo Bug 237882 - dev-libs/libedit-20050930 enters an infinite loop upon readi ...
17:51:05 <lispy> sctb: I don't recall how I install 6.6.1 and 6.8.2, but they both live happily on my system when Either 6.10.1 6.8.3 is installed
17:52:09 <yitz> mauke: interesting. only ghc users are experiencing this bug?
17:52:25 <mauke> yitz: I don't think so
17:52:29 <askentasken> roconnor: iw ant to learn coq, have it installed. thanks, isee your points
17:52:47 <yitz> mauke: aren't all the names mentioned there haskell people?
17:53:00 <mauke> I don't know
17:55:00 <yitz> mauke: if no history in ghci 6.10 that'd be a blocker for me
17:56:39 <yitz> though I really think that ghc should be usable in non-gpl contexts
17:56:50 <sctb> Use Emacs or rlwrap
17:57:00 <dons> hey kids, amount of discussion #haskell vs #ocaml since 2004, http://galois.com/~dons/images/irc.png
17:57:28 <yitz> sctb: reports on the ghc list are that rlwrap doesn't work
17:57:38 <yitz> it just detects editline and defers
17:57:39 <sctb> Interesting.
17:57:49 <sctb> Emacs works...
17:57:53 <yitz> yeah
17:59:15 <yitz> dons: yeah, but did you factor out @vixen traffic?
18:00:48 <yitz> could be that a lot of ocaml interest is moving over to f# and scala now
18:01:28 <sctb> Could be that #ocaml doesn't have a noisy bot
18:02:01 <idnar> the trend is more interesting than the absolute values
18:02:12 <idnar> it's not like lambdabot is getting noisier, is it?
18:02:22 <sctb> More features = more noise!
18:02:25 <idnar> haha
18:02:26 <sctb> :)
18:02:28 <sjanssen> sctb: lambdabot isn't that noisy
18:02:35 <z7sg> @ushdf natural languages are ambiguous so some confusion is inevitable
18:02:35 <lambdabot> Unknown command, try @list
18:02:40 <sctb> I jest, folks
18:03:11 <lispy> dons: what units are on the axes?
18:03:42 <sjanssen> > 1800 / 365
18:03:50 <sjanssen> days?
18:04:19 <mwotton> uh, maybe a stupid question - where does the Mac OS X installer put ghc and friends?
18:04:36 <sctb> Who knows... probably /usr/local
18:04:52 <mwotton> alas no :/
18:04:53 <lee_11> Can anyone tell me what the difference is between type constructors and data constructors?
18:05:00 <idnar> @ping
18:05:18 <lispy> lee_11: a type constructor makes types from other types
18:05:25 <yitz> mwotton: something like /Libraries
18:05:29 <lispy> lee_11: a data constructor makes data from other data
18:05:53 <sctb> mwotton: Do you have something in /Library/Receipts? You can determine all files installed if you do (which you should with any installer package)
18:05:58 <lispy> lee_11: so, ->, would be a type constructor for functions
18:06:09 <lispy> lee_11: and (:) would be a data construct
18:07:08 <lee_11> I'm having difficulty creating a Matrix monad.
18:07:14 <idnar> so, we have values, types, and kinds; what comes after kinds?
18:07:14 <lee_11> data Matrix = Matrix [Vector] deriving (Eq, Show)
18:07:21 <sctb> mwotton: do something like `lsbom /Library/Receipts/ghc.pkg/Contents/Archive.bom'
18:07:25 <lee_11> but thats not a monad
18:07:25 <lament> idnar: turtles
18:07:44 <lee_11> I need Matrix to have monadic properties
18:07:50 <lament> lee_11: why?
18:08:35 <ddarius> idnar: In systems where it's necessary, usually a more general term 'sorts' is used and then you just name sorts.
18:09:35 <lispy> lee_11: can you explain which monadic properties?
18:09:55 <idnar> ddarius: sounds like fun
18:10:07 <lament> kinda sorta
18:10:45 <lispy> dons: to be fair though, due to that one troll that inhabits #ocaml I can see why it's not making progress.  You'd also need to check against their mailing lists
18:12:04 <lament> i suppose you could easily make matrices into a monad by analogy with lists... but... why?
18:14:18 <lispy> What about their interpretation as a linear transformation?  Then their monadic analogy would correspond to functions
18:14:26 * ddarius would be amazed if O'Caml mailinglist traffic was anywhere near Haskell's.
18:14:43 <lament> lispy: then i have no idea what join means
18:15:08 <dolio> Our frequent discussions about floating point arithmetic alone are formidable. :)
18:15:18 <lament> matrices of matrices just don't come up often in the context of linear transformations
18:16:00 <ddarius> linear transformations between functions come up often enough and linear transformations are special types of functions.
18:16:33 <Saizan> and you can describe a linear transformation as the result of mapping it to the bases
18:16:51 <lament> ddarius: sure
18:16:55 <lispy> dolio: on that same token, isn't there a statistic from the logs that showed we say, 'monad' more than any other word here?
18:17:06 <lament> ddarius: and then you take this matrix of matrices and flatten it with join
18:17:10 <lament> utterly useless
18:17:14 <lispy> dolio: possibly excluding connective words
18:17:14 <dolio> Could be.
18:17:21 <dons> i'd bet #haskell's traffic is a fairly good curve fit for what else is happening in the community
18:17:48 <lispy> dons: I agree, but I'm skeptical that is true in #ocaml
18:18:00 <lispy> dons: simply because #ocaml is so hostile towards n00b
18:18:02 <lispy> +s
18:18:19 <dolio> As of Jan 1, 2007, monad was the 7th most used word.
18:18:49 <dons> lispy: yeah, quite possibly.
18:18:59 <dons> so it lags friendlier parts of   the community
18:19:48 <lispy> dolio: anything else interesting on that list?
18:20:00 <mwotton> Prelude> maxBound :: Int
18:20:01 <mwotton> 2147483647
18:20:01 <mwotton> Prelude>
18:20:10 <dolio> Not really. Haskell is #1.
18:20:18 <mwotton> on mac os with 6.10.1
18:20:19 <lee_11> lispy, I wanted to distinguish between matrices and vectors in my code, but now I see that does not make much sense...
18:20:20 <dolio> And sorear was still around when these statistics were compiled.
18:20:28 <mwotton> i can haz 64 bit ints plz?
18:20:48 <dolio> Also, "dons talks to him/herself a lot."
18:20:56 <sctb> Uh... long
18:23:09 <mwotton> dons: http://hpaste.org/11863#a1
18:25:15 <dons> mwotton: {-# LANGUAGE ScopedTypeVariables #-}
18:25:18 <Saizan> mwotton: try (decode . BSL.readFile) instead of decodeFile
18:26:03 <dons> Saizan: why?
18:26:30 <dons> $ time ./A
18:26:30 <dons> Stack space overflow: current size 8388608 bytes.
18:26:30 <dons> Use `+RTS -Ksize' to increase it.
18:26:30 <dons> ./A  2.63s user 0.27s system 99% cpu 2.913 total
18:26:34 <dons> anyway, investigating.
18:26:46 <Saizan> dons: because decodeFile checks if the bytestring is empty after decode
18:26:59 <Saizan> and so makes the parsing less lazy
18:27:13 <brian___> hello
18:27:22 <Saizan> ketil was experiencing similar problems
18:27:29 <dons> i don't see how that would affect a stack overflow?
18:27:31 <brian___> i was wondering if someone could help me with an error i am getting in the interpreter\
18:27:33 <dons> it would leak handles.
18:27:38 <Cale> brian___: sure :)
18:28:04 <brian___> sweet, this should seem simple
18:28:07 * lispy thinks that Cale has his client set to beep on the phrase 'help me'
18:28:09 <Saizan> in fact, i'd expect an heap overflow
18:28:38 <brian___> here is the code i am trying
18:28:40 <brian___> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
18:28:47 <yitz> Cale> lispy: sure :)
18:29:01 <lispy> heh
18:29:07 <brian___> it gives me this error:  parse error on input `='
18:29:24 <lispy> let boomBangs ...
18:29:27 <dons> http://hpaste.org/11863#a2
18:29:55 <lispy> > let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
18:30:08 <lispy> > let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] in boomBangs [1..20]
18:30:15 <lispy> ?bot
18:30:24 <brian___> THANKS! :D
18:30:50 <adu> {-# LANGUAGE LinkedTuples #-}
18:31:03 <yitz> lispy: \bot seems to have disappeared two netsplits ago.
18:31:03 <brian___> I was just following a tutorial, it didn't say that I needed the 'let' in there
18:31:05 <mwotton> dons: oops, yeah. sorry, was just chucking it on the command line i think
18:32:23 <mwotton> dons: that instance you annotated is just the one in the Binary lib you sent me, right?
18:33:22 <brian___> are there some interpreters that need the "let" in there and some that don't?
18:33:57 <mwotton> Saizan: sorry, dumb question, but what module is BSL an abbreviation for?
18:35:42 <askentasken> could that troll be Jon Harrop? lol that guy certainly put me off ocaml, what a fool
18:36:07 <yitz> brian___: it could go in a Haskell program file without the let, but not in an interpreter.
18:36:07 <Saizan> mwotton: Data.ByteString.Lazy, but you also need the instance dons pasted if you don't want to waste a lot of resources while encoding
18:36:30 <brian___> yitz: okay, thanks that makes sense
18:36:31 <mwotton> Saizan: yep, got the instance
18:36:50 <lispy> yitz: ah, I can't see netspilts...that makes sense though
18:37:22 <dons> Saizan: i checked btw, decodeFile doesn't have any effect.
18:37:36 <dons> mwotton: yeah, that's the instance. looks tame.
18:37:44 <askentasken> anyone here who is a math grad student and want to make money teaching me math?
18:37:50 <lambdabot> :)
18:37:51 <yitz> Cale_: we've been having some netsplits and \bot has - well, split.
18:37:51 <lambdabot>   <no location info>: parse error on input `;'
18:37:52 <lambdabot>   ["BOOM!","BOOM!","BOOM!","BOOM!","BOOM!","BANG!","BANG!","BANG!","BANG!","B...
18:37:55 <dons> mwotton: did you say that you wrote your own instance that did work?
18:38:01 <yitz> heh
18:38:18 <Cale_> brian___: sorry about that...
18:38:25 <pumpkin> did lambdabot just smile
18:38:25 <yitz> she's back
18:38:39 <brian___> about what?
18:38:44 <mwotton> dons: well, it didn't fall over with a stack overflow
18:38:45 <brian___> thanks for your help
18:38:47 <mwotton> it's ugly as hell though.
18:38:52 <Cale> (I got disconnected there)
18:38:58 <Saizan> dons: maybe because the list is still small
18:39:01 <Cale> ah, good, so my message did get through :)
18:39:08 <brian___> yeah i got it
18:39:21 <dons> Saizan: how does closing the bytestring at the end affect the stack?
18:39:35 <brian___> now i can get back to learning Haskell
18:40:16 <mwotton> dons: the get2 version. put never fell over so i left it alone
18:40:31 <mwotton> but it's so much slower than just reading the data file in that it's sort of useless to me
18:40:53 <dons> oh, inserting one by one.
18:41:05 <mwotton> and some cruft from my program. but yeah, yuck.
18:41:07 <dons> ok. so that does seem like Map's issue, not Binary's
18:41:12 <dons> mm
18:42:51 <harblcat> So I'
18:42:59 <harblcat> I'm using randomRs..
18:43:00 <dons>     -- 1) use continutations so that we use heap space instead of stack space.
18:43:07 <dons> sez fromDistinctAscList
18:43:21 <harblcat> But I keep getting type errors.
18:43:35 <Saizan> dons: it's not about closing, but about forcing the final state of the parser before you can look at the results, and yeah, my bad, it blows the heap
18:44:05 <dons> ah, but its the list instance perhaps , mwotton. ... thinking.
18:46:39 <Saizan> http://hpaste.org/11865
18:47:11 <dons> mwotton: http://hpaste.org/11866
18:47:12 <dons> curious.
18:48:11 <harblcat> Anyone want to take a look and see if I'm doing anything stupid? http://hpaste.org/11867#a0
18:48:59 <Saizan> harblcat: you need "return" on the last line
18:49:26 <dons> mwotton: see in http://hpaste.org/11866, reading in the list then decoding works.
18:49:33 <mwotton> yep, looking at it now.
18:49:41 <mwotton> that's sort of weird, though.
18:50:50 <mwotton> still dies if i try the foldWithKey stuff, which is a bit odd
18:51:10 <dons> ah
18:51:12 <harblcat> Saizan: Ah, I see it works now. But then there's another problem, it returns the same numbers each time.
18:51:40 <mwotton> as far as i can tell, i'm forcing the key, the value, and the accumulator
18:52:09 <dons> mwotton:
18:52:13 <dons>   print $ Map.foldWithKey (\ a b c -> case (a + b + c) of !x -> x ) 0 testMap
18:52:16 <dons> fails. nothing to do with the binary stuff.
18:52:25 <dons> but to do with whatevre fold does.
18:52:27 <mwotton> ah, righto. my own dumb fault then :)
18:52:42 <dons> well, no, i mean, the update should be strict by the looks of it.
18:52:52 <dons> maybe you can use insertWith' or friends
18:53:05 <roconnor> @dict interest
18:53:13 <mwotton> instead of fromDistinctAscList?
18:53:25 <dons> no, fromDistinctAscList looks fine.
18:53:37 <harblcat> Saizan: nevermind, I just needed newStdGen before the return.
18:53:38 <dons> ah no. so you want to fold over the Map.
18:53:41 <harblcat> Thanks!
18:53:52 <dons> and that's not working. so hunt around for how its defined, and if there's an alternative
18:53:53 <Saizan> it looks like foldWithKey is a foldr, so it's a simple stack oveflow like you'd get in strict languages
18:53:56 <dons> yeah
18:55:08 <Saizan> i think you want "foldl' (\acc (k,v) -> acc + k + v ) 0 . toList $ testMap"
18:56:11 <mwotton> ok. i'll see if i can map that back to my original problem.
18:56:34 <dons> 500001500000
18:56:34 <dons> ./A  1.04s user 0.17s system 98% cpu 1.223 total
18:56:47 <dons> but i think it means Map needs a look over again
18:57:51 <Saizan> does foldl' fuse with toList ?
18:59:56 <mwotton> presumably the default for folding over a Map should be strict - looking anything up in it is going to force evaluation anyway, surely? at least of the keys...
19:02:00 <Saizan> well, it depends more on the function that you're folding over the map than anything else
19:02:05 <mwotton> dons: that maxBound result - what sort of machine did you get that on?
19:02:56 <dons> thinkpad x61 core 2 duo.
19:02:58 <Saizan> since if you have a function that's lazy in the second argument you benefit from a foldr even if the Map is fully evaluated
19:03:20 <mwotton> Saizan: I guess so. I suppose i'm thinking in terms of building it with a fold, but that's a special case
19:03:32 <mwotton> different thing entirely, really.
19:03:43 <ddarius> Sounds like there should be two functions.
19:03:44 <Saizan> building a Map?
19:04:19 <mwotton> yes
19:05:01 <Saizan> ah, well that's another issue
19:05:34 <Saizan> however Data.Map is an instance of Foldable, so we already have both foldl and foldr defined, not that i see it
19:05:37 <Saizan> *now
19:05:58 <mwotton> dons: bugger. i've got a core 2 duo, but in the MBP... new ghc still gives 32 bit ints
19:06:17 <Saizan> but only a foldr-like -WithKey
19:16:10 <solrize_> does it sound feasible to hack up the -via-C GHC backend to generate ada instead of c?
19:18:36 <dons> mwotton: try installing a x86_64 ghc binary?
19:18:42 <dons> solrize_: mmm.
19:18:52 <dons> feasible? unknown. it sounds /possible/
19:19:01 <dons> what about the runtime?
19:19:22 <solrize_> gnat, pretty similar to gcc runtime
19:21:04 <solrize_> oh, you mean the ghc runtime
19:21:49 <solrize_> hmm, i guess connecting the existing one up through the ada ffi would defeat the purpose
19:23:44 <solrize_> how much code is there, that's not written in haskell?
19:24:26 <Badger> ...
19:24:29 <dons> in the runtime? quite a lot
19:24:29 <Badger> no sense
19:24:33 <Badger> none
19:24:34 <Badger> Installing: /home/badger/.cabal/lib/Cabal-1.4.0.2/ghc-6.8.3
19:24:34 <Badger> Registering Cabal-1.4.0.2...
19:24:48 <Badger> then cabal-install complains that there's no cabal!
19:24:50 <solrize_> stuff like the i/o libs probably can be rewritten easily, but stuff like the gc could be harder
19:24:54 <dons> Badger: missing --user ?
19:24:58 <Badger> nope
19:25:08 <Badger> unless
19:25:26 <solrize_> brb
19:25:40 <Badger> oh
19:25:49 * Badger always makes the obvious mistake
19:26:10 <Badger> thanks.
19:26:22 <ddarius> Badger: Don't worry.  You make non-obvious mistakes too.
19:26:36 <Badger> Occasionally
19:28:43 <roconnor> http://techdirt.com/articles/20081107/0118162765.shtml
19:28:52 <lambdabot> Title: Techdirt: Halliburton Tries To Patent Form Of Patent Trolling
19:29:33 <roconnor> I mention this on #haskell only because the idea of patenting patent trolling to prevent you from being patent trolled makes my brain melt in the same way that MonadFix does.
19:38:07 <solrize_> lol roconnor
19:38:45 <olsner> roconnor: zomg monadic fixpoints!
19:39:41 <olsner> (they are, btw, awesome... if only I could understand them)
19:44:11 <Twey> What's a good tool or strategem for dealing with situations in which one has a large pile of monad transformers stacked on top of one another?
19:45:25 <Saizan> what problem are you having with it?
19:45:28 <ddarius> Twey: Wrap them in a newtype.
19:46:01 <Twey> Saizan: Well, it's kind of clumsy :) `lift . lift . lift $ foo bar baz` gets tiring.
19:46:51 <ddarius> Twey: Wrap with a newtype and derive all the MonadState, MonadReader, etc.
19:47:05 <Twey> Hmm, OK, thanks, ddarius :)
19:47:05 <ddarius> You should only need lift then if you have multiple versions of the same transformer.
19:47:14 * Twey nods.
19:47:43 <ddarius> (and if you need to lift a "monomorphic" computation, but then you only need on lift)
19:50:10 <solrize_> @seen dcoutts
19:50:11 <lambdabot> dcoutts is in #haskell, #haskell-soc, #darcs, #ghc, #gentoo-haskell and #haskell-overflow. I don't know when dcoutts last spoke.
19:52:22 <pumpkin_> is html context-free?
19:52:41 <solrize_> mrmph
19:52:48 <solrize_> hmm
19:52:54 <Riastradh> No, pumpkin_.
19:52:58 <pumpkin_> didn't think so
19:53:07 <dmwit> No?
19:53:09 <pumpkin_> requiring same text in opening and closing tags
19:53:14 <pumpkin_> seems non-context-free
19:53:26 <dmwit> I was under the impression that that was perfectly context-free.
19:53:37 <dmwit> Assuming there's a finite number of allowed tags.
19:53:44 <pumpkin_> oh yeah, in that case
19:53:52 <pumpkin_> I guess I was thinking about it more in the generic xml sense
19:53:56 <dmwit> ah
19:54:08 <z7sg> hi, I'm trying to find all possible paths through a tree with structure: data Tree a = EmptyTree | Node a [Tree a]
19:54:15 <pumpkin_> yeah, with a finite number of tags I guess it could be
19:54:18 <dmwit> Well, many XML documents will also conform to a context-free grammar, of course.
19:54:24 <pumpkin_> yeah
19:54:37 <pumpkin_> but xml in general isn't, right?
19:54:46 <dmwit> (There's not so many that start <a><b><c><d><e>... ;-)
19:55:02 <pumpkin_> :P
19:55:09 <dmwit> Right, XML in general probably is not context-free.
19:55:34 <dmwit> z7sg: Very good, what have you tried?
19:56:30 <z7sg> traverse (Node n c) = n: (concat $ map (traverse) c)
19:56:52 <z7sg> but what i really want is a list of all possible productions of the tree, and that doesn't do it
19:57:40 <Saizan> so, you need traverse :: Tree a -> [[a]]
19:57:52 <Saizan> while you've traverse :: Tree a -> [a+
19:58:09 <Saizan> s/+/]/
19:58:15 <sw17ch> is there a way to specify a package to use when using cabal install?
19:58:28 <sw17ch> for example: cabal install json --with-package=parsec-3.0.0
19:58:52 <dolio> Recognizing well-formed xml might be context free.
19:59:19 <dmwit> dolio: Hm, really?
19:59:27 <dmwit> dolio: Making no assumptions about what tags will be used?
19:59:37 <dolio> Since it's always <tag> rest </tag> or <tag/>.
19:59:49 <dmwit> dolio: Right, but you aren't allowed to remember "tag".
19:59:59 <dmwit> If you can remember what "tag" is, that's context-sensitive.
20:00:12 <mwotton> dmwit: isn't that regexes?
20:00:13 * juhp build a gtk2hs snapshot with ghc-6.10.1
20:00:28 <dmwit> dolio: i.e. you need separate productions for, e.g., <html> rest </html> and <p> rest </p>.
20:00:41 <dmwit> mwotton: Isn't *what* regexes?
20:01:16 <Riastradh> From Section 3:  Well-formedness constraint: Element Type Match.  The Name in an element's end-tag MUST match the element type in the start-tag.
20:01:20 <nofeardjb> so I'm trying to define a data of coin where its values could be 1, 5, 10, or 25; the code i wrote up is "data Coin = 1 | 5 | 10 | 25" apparently this is incorrect? "Syntax error in data type declaration (unexpected numeric literal)
20:01:22 <Riastradh> (Section 3 of the XML 1.0 specification, sorry)
20:01:34 <dolio> dmwit: Then parameterize your parser by a set of allowable tag names or some such.
20:01:53 <Saizan> nofeardjb: data constructors must start with an uppercase letter
20:02:00 <dmwit> dolio: Right, that's what I was saying.  Assuming you know the set of allowable tags, it is certainly context-fre.
20:02:04 <z7sg> saizan, right..?
20:02:05 <dmwit> But without that assumption...
20:02:31 <dmwit> nofeardjb: You can do something like
20:02:36 <nofeardjb> Saizan: so the word "data" need to be capitalized?
20:02:38 <dmwit> data Coin = Penny | Nickel | Dime | Quarter
20:02:56 <nofeardjb> dmwit: tryed that too, got errors :-(
20:03:03 <dmwit> nofeardjb: What errors?
20:03:17 <dmwit> ?hpaste
20:03:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:03:20 <nofeardjb> in fact thats exactly the code i typed, hold on lemme get the error
20:03:22 <Saizan> z7sg: so, you want to add the current element to all the paths you found by mapping traverse recursively: traverse (Node n ts) = map (n:) (map traverse ts)
20:03:52 <dmwit> Saizan: That doesn't look quite right...
20:03:57 <dmwit> Saizan: maybe
20:04:03 <dmwit> map (n:) (ts >>= traverse)
20:04:35 <nofeardjb> dmwit:
20:04:39 <nofeardjb> whoops
20:04:43 <Saizan> dmwit: right
20:04:57 <nofeardjb> dmwit: http://hpaste.org/11869
20:05:03 <dolio> Recognizing bad HTML, the way browsers do, is probably not context free though.
20:05:10 <dmwit> nofeardjb: data Coins = [Coin] -- needs a constructor name
20:05:15 <sw17ch> is there a function to turn a windows C file descriptor into a Haskell File Handle?
20:05:18 <dmwit> nofeardjb: or you can do "type Coins = [Coin]".
20:05:26 <roconnor> olsner: I refer you to my article on recursive do, if you want to understand monadic fixpoints.
20:05:34 <dolio> Since they generally accept stuff like '<tag1><tag2></tag1></tag2>'.
20:05:50 <Riastradh> Here's another well-formedness constraint:  An attribute name MUST NOT appear more than once in the same start-tag or empty-element tag.  So you need to augment your set of allowed element names with a set of allowed attribute names, too.
20:06:00 <nofeardjb> dmwit: i'll try it and get back to ya
20:06:06 <dmwit> Riastradh: Ah, interesting.
20:06:10 <mdmkolbe> dolio: being able to read bad HTML just fine, or recognizin that the HTML is bad?  b/c the later is definately context-free (well, maybe co-context free)
20:06:17 <Riastradh> But here's another one that puts all the others to shame:  The replacement text of any entity referred to directly or indirectly in an attribute value MUST NOT contain a <.
20:06:25 <dmwit> nofeardjb: Also: putStr "foo\n" --> putStrLn "foo"
20:06:31 <Riastradh> (This is all for well-formedness, not for validity.)
20:06:44 <dmwit> nofeardjb: (The latter will be "better" for a cross-platform-ness meaning of better.)
20:06:51 <nofeardjb> dmwit: hehe righto
20:07:06 <rwbarton> @src putStrLn
20:07:06 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
20:07:14 <z7sg> thanks guys i'll try it out
20:07:16 <dmwit> I stand corrected.
20:07:25 <rwbarton> It's just more idiomatic.
20:07:29 <dolio> mdmkolbe: I was thinking in terms of recognizing some technically ill-formed, but good enough to still display correctly superset.
20:07:53 <nofeardjb> dmwit: thanks that type fix worked out
20:08:55 <dolio> But browsers (back in the day at least) probably don't even bother having a lenient standard that they adhere to like that.
20:09:21 <nofeardjb> dmwit: I haven't had much time to learn haskell, and I have an assignment due on Monday :-S
20:09:25 <dolio> (Since otherwise there'd probably be a lot of pages that just don't get displayed.)
20:09:34 <dmwit> dolio: I've seen pages that had content *outside of the <html> tags*.
20:09:46 <dolio> :)
20:09:47 <dmwit> (And yes, it was displayed in every browser I cared to try.)
20:09:53 <Riastradh> Here's another well-formedness constraint:  A parsed entity MUST NOT contain a recursive reference to itself, either directly or indirectly.
20:09:58 <Riastradh> Try that with a context-free grammar.
20:10:26 <dolio> Yes, my conception of well-formed XML was clearly naive. :)
20:10:30 <dmwit> nofeardjb: I wish you luck.  But as my band teacher used to say: poor planning on your part does not constitute an emergency on my part. ;-)
20:10:49 <dmwit> Riastradh: yikes
20:10:56 <nofeardjb> dmwit: LOL my band teacher said the same thing to me in high school!!!
20:10:57 <dmwit> Riastradh: I forgot all about XML's reference stuff.
20:11:20 <dmwit> nofeardjb: ...where did you go to school?
20:11:28 <nofeardjb> dmwit: ....nebraska
20:11:34 <dmwit> Ah, just coincidence, then.
20:11:42 <nofeardjb> *phew*
20:12:54 <sw17ch> any one know why the GHC docs lost their source listings?
20:13:51 <nofeardjb> if i want to make my Coin type numerals instead how would i do that? i tried "data Coin = 1 | 5 | 10 | 25" and it was a no go
20:14:04 <mdmkolbe> nofeardjb: that is not possible
20:14:50 <nofeardjb> mdmkolbe: ok
20:15:49 <dmwit> nofeardjb: You can declare an Enum instance for them.
20:15:51 <mdmkolbe> nofeardjb: all constructors (i.e. the "1" part you are trying) must start with an upper case letter (for prefix (i.e. regular) constructors).  (There is an exception for constructors containing only symbols.)
20:16:02 <dmwit> nofeardjb: You can then write "fromEnum 1" for Penny, if you like.
20:16:08 <mdmkolbe> dmwit: for a homework that would probably be overkill
20:16:16 <dmwit> (or "map fromEnum [1,5,10,25]" for all of them. ;-)
20:17:00 <dmwit> mdmkolbe: No, overkill would be declaring a Num instance so he could literally just write 1, 5, 10, 25. =D
20:17:16 <nofeardjb> ya i'm trying to figure out my data types, the input would be a list of numbers like [1,1,1,1,5,5,10,25]
20:17:36 <dmwit> nofeardjb: I recommend just making a conversion function.
20:17:51 <dmwit> nofeardjb: But can you just deal with the numbers directly?  Do you actually need a new data type?
20:18:06 <nofeardjb> ya i could do that i suppose
20:18:12 <nofeardjb> maybe i'm just making this harder hehe
20:22:47 <nofeardjb> what i want to do first is build a function that takes a list of coins and returns a list of lists with all the potential unique coin combinations
20:23:43 <luite> @pl i (n,l) = (h n, g (f n) l)
20:23:43 <lambdabot> i = uncurry (ap ((.) . (,) . h) (g . f))
20:24:13 <luite> hmm, that doesn't help :)
20:24:35 <mdmkolbe> nofeardjb: you mean all posibile combinations that add up to a given amount?
20:24:48 <nofeardjb> that is the end result yes
20:26:26 <mdmkolbe> nofeardjb: the shortest method would just use numbers to represent the coins. (dare I say it could be done in one line of tricky haskell.) but it really depends on your teacher and what the objective of the assignment is.
20:28:29 <nofeardjb> mdmkold: ya i'm sure that possible, basically the input is the total amount or "price" and the second input is a list of coins and the output is all the unique combinations of coins that equal that price
20:28:47 <nofeardjb> mdmkolbe, i just wish i was savvy enough to know how to do it in one line :)
20:29:08 <mdmkolbe> nofeardjb: when is your assignment due?
20:29:13 <dmwit> Although I am probably savvy enough to do it in one line, I'm pretty sure I wouldn't.
20:29:13 <nofeardjb> Monday
20:29:20 <nofeardjb> dmwit: lol
20:29:26 <mdmkolbe> nofeardjb: ask on Tuesday
20:29:33 <nofeardjb> mdmkolbe: :)
20:29:48 <dmwit> Much like other languages, just about anything can be put in one line.  That doesn't mean it's a good idea. ;-)
20:29:57 <nofeardjb> ya, i'm not asking anyone to do my homework, i know how that is :)
20:30:03 <pumpkin-> if you write an infix operator, do you need to write infixl/r?
20:30:12 <pumpkin-> or can it be implicit?
20:30:19 <dmwit> pumpkin-: There's a default.
20:30:25 <pumpkin-> what is it?
20:30:32 <dmwit> pumpkin-: (And it's a good thing, since *every* function can be used infix.)
20:30:36 <pumpkin-> lowest priority
20:30:38 <pumpkin-> ah yeah
20:31:58 <dmwit> infixl 9 is the default
20:32:12 <pumpkin-> ah, so highest priority?
20:32:26 <dmwit> yep
20:32:30 <pumpkin-> cool
20:32:42 <rwbarton> > sin `id` 3 + 4
20:32:43 <lambdabot>   4.141120008059867
20:33:01 <rwbarton> can you write infixl 1 `id` ?
20:33:45 <dolio> Yes.
20:34:14 <dolio> > let infixl 1 `id` in sin `id` 3 + 4
20:34:16 <lambdabot>   Not in scope: `id'
20:34:24 <dolio> > let infixl 1 `id` ; id x = x in sin `id` 3 + 4
20:34:26 <lambdabot>   0.6569865987187891
20:35:14 <rwbarton> I'm not sure how I feel about that
20:35:19 <dmwit> > let infixl 1 id; id x = x in sin `id` 3 + 4
20:35:21 <lambdabot>   <no location info>: parse error on input `id'
20:35:25 <dmwit> huh
20:36:31 <dolio> > sin `id` 3 + 4 where infixl 1 `id` ; id x = x
20:36:32 <lambdabot>   0.6569865987187891
20:40:13 <dmwit> > sin `id` 3 + 4 where infixl 9 `id`; id x = x
20:40:14 <lambdabot>   4.141120008059867
20:40:19 <dmwit> ah
20:46:23 <sw17ch> Is there a function to convert a Windows File Descriptor to a Haskell File Handle?
20:49:46 <mmorrow> <mdmkolbe> dolio: being able to read bad HTML just fine, or recognizin that the HTML is bad?  b/c the later is definately context-free (well, maybe co-context free)
20:49:46 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
20:49:58 <mmorrow> what is "co-context free"?
20:50:29 <dmwit> It's the double-dual of ntext free.
20:50:41 <askentasken> hmatrix wont install on eithe rwindows or linux for me
20:51:15 <mmorrow> dmwit: snap
20:51:25 <mmorrow> askentasken: what's the error you're getting?
20:51:57 <mmorrow> (i'm assuming you're tried w/out cabal-install..)
20:52:04 <mmorrow> s/you're/you've/
20:52:09 <dolio> mmorrow: I believe it'd be L - CF, where L is the set of all languages, and CF is the set of context free languages.
20:52:23 <dolio> Or something of the sort.
20:53:07 <mmorrow> dolio: hmm. wouldn't that be /non/-context-free?
20:53:54 <mmorrow> (or maybe not. i'm confused on what "co" means in this context)
20:54:05 <dolio> Well, in that area, I think co-FOO usually means the set theoretic complement of FOO.
20:54:15 <mmorrow> ah, i see
20:54:17 <dolio> "That area" being computability theory.
20:54:41 <mmorrow> but don't NP and co-NP have intersection?
20:54:51 <mmorrow> (i'm not positive of that)
20:54:59 <askentasken> mmorrow: no i only tried with cabal install
20:55:12 <askentasken> on windows
20:56:04 <mmorrow> askentasken: hmm. i've never installed it on windows before, but i install it manually
20:56:31 <dolio> Like, HP is the set of Turing machines (and input, I suppose) that halt, and co-HP is the set that don't.
20:56:45 <mmorrow> askentasken: you may need to add -lgslcblas to the appropriate place in the .cabal file depending on your setup.
20:57:11 <solrize_> it's not the set complement
20:57:47 <solrize_> NP = probs whose "yes" instances can be recognized by a nondeterministic TM in poly-time
20:57:57 <solrize_> co-NP = probs whose "no" instances can be recognized by such a machine
20:58:06 <solrize_> hmm
20:58:28 <solrize_> NP and co-NP intersect: P is contained in both of them
20:58:29 <Draconx|Laptop> co-NP = decision problems whose complement is in NP.
20:58:40 <solrize_> yeah, what draconx says
20:58:59 <solrize_> what's not known is whether any NP-hard problems are in NP-intersect-co-NP
20:59:08 <mmorrow> solrize_, Draconx: so then what're your guesses as to what co-context-free means?
20:59:36 <Draconx|Laptop> mmorrow, presumably, the class of languages whose complement is context free.
20:59:36 <solrize_> co-context-free would be languages whose complement is context-free i guess
20:59:41 <solrize_> jnx
20:59:42 <solrize_> jinx
20:59:58 <mmorrow> hmm, what is the complement of a language then?
21:00:06 <shapr> two's complement?
21:00:09 <solrize_> the set of strings that are not in the language
21:00:15 <Draconx|Laptop> mmorrow, the usual definition of set complement.
21:00:29 <Draconx|Laptop> mmorrow, a language is a set of words over an alphabet.
21:00:31 <mmorrow> ah, ok i see.
21:00:36 <dolio> Yeah, I guess that makes more sense than what I was saying. :) I'm out of practice.
21:00:49 <solrize_> for example, the complement of the set of strings that are syntactically valid haskell programs = the set of strings that are not syntactically valid haskell
21:00:55 * mmorrow was never in practice in this area
21:02:45 * mmorrow returns to browsing the logs
21:03:14 <prb> cabal-install (0.6.0) is burning through a lot of memory with ghc 6.10.1.  Any tips for making it a little leaner?
21:03:30 <ivanm> prb: as in using it under 6.10.1, or building 6.10.1?
21:03:44 <prb> Using it under 6.10.1.
21:03:47 <prb> Build it with 6.10.1.
21:06:46 <dmwit> http://en.wikipedia.org/wiki/Aperiodic_finite_state_automaton "celebrated"?
21:09:08 <dmwit> Ah, aperiodic doesn't mean what I thought it meant.
21:09:13 <dmwit> That makes it a bit more interesting.
21:11:54 <prb> Is there a cabal or cabal-install channel around?
21:15:23 <mmorrow> <dons> 500001500000   <dons> thinkpad x61 core 2 duo.
21:15:34 <mmorrow> dons: are you running a 64bit linux distro on that?
21:15:44 <dons> yeah
21:15:46 * mmorrow has an x60 and wants to do just that
21:15:58 <mmorrow> awesome. so no hitches or anything then?
21:15:58 <dons> seems like a waste not to.
21:16:01 <dons> nope.
21:16:09 <mwotton> what's the process of building it, btw?
21:16:15 <mmorrow> nice. i think i'm gonna go for it then
21:16:18 <dons> building what?
21:16:24 <mwotton> a 64 bit distro
21:16:29 <mwotton> sorry, of ghc
21:16:34 <solrize_> yeah, definitely run 64 bit
21:16:42 <dons> oh. hmm. it detects the word size on building, and uses that.
21:16:46 <solrize_> dons, i just got 8gb for my t61
21:16:49 <mwotton> yeah, but where does it get that from?
21:16:59 <dons> oh, what gcc tells it.
21:16:59 <mwotton> i downloaded ghc, and it finds size of int is 4
21:16:59 <mmorrow> solrize_: heh
21:17:02 <mwotton> ok, cool.
21:17:11 <dons> mwotton: so maybe you're not on a purely 64 bit system
21:17:18 <mwotton> have downloaded gcc and am in the long process of building...
21:17:18 <solrize_> http://www.newegg.com/Product/Product.aspx?Item=N82E16820231210
21:17:26 <solrize_> running a 32 bit system would be silly
21:17:26 <lambdabot> Title: Newegg.com - G.SKILL 8GB (2 x 4GB) 200-Pin DDR2 SO-DIMM DDR2 667 (PC2 5300) Lapt ...
21:17:29 <mwotton> i think you need to tell gcc to do 64 bit too...
21:17:36 <dons> http://wiki.archlinux.org/index.php/Arch64_FAQ
21:17:47 <lambdabot> Title: ArchWiki :: Arch64 FAQ - ArchWiki
21:17:53 <dons> well, maybe if you're in a mixed environment.
21:17:58 <dons> like on irix/mips/mips64
21:18:02 <dons> you have to pass flags though.
21:18:07 <dons> but i'm running a 64 bit only world.
21:18:15 <mwotton> solrize_: well, not necessarily. there was an interesting article recently pointing out that if you're using 64 bits when you don't need them you're increasing cache pressure and all kinds of bad things...
21:19:01 <solrize_> mwotton i think the extra registers and address space more than makes up for that
21:19:21 <solrize_> commodity pc's can have 16gb of ram now
21:20:22 <mwotton> solrize_: knuth says you're wrong :)
21:20:23 <mwotton> http://www-cs-faculty.stanford.edu/~knuth/news.html
21:20:23 <lambdabot> Title: Knuth: Recent News
21:22:11 <solrize_> interesting
21:22:45 <solrize_> i think "they throw away half the cache" is exaggerated; the cache is normally not full of pointers
21:23:28 <mmorrow> lol: http://www.tgdaily.com/content/view/32940/118/
21:23:30 <lambdabot> Title: TG Daily - Man throws his computer out the window, police sympathize
21:23:33 <solrize_> hehe
21:23:40 <mwotton> solrize_:  ... really? there'd be a hell of a lot of pointers of one kind or another lying around in pretty much any haskell program
21:25:01 <solrize_> there's also non-pointer data, i should hope
21:25:19 <mmorrow> i've heard people say that the same haskell prog runs considerably faster on 64bit
21:25:55 <mmorrow> (those people were asking why they just had observed that, rather than giving an explanation)
21:26:16 <solrize_> twice as many registers
21:26:32 <mmorrow> yeah, that sounds like it's why
21:26:47 <mwotton> ok, sort of confused there - why do you get twice as many registers?
21:27:01 <mmorrow> (talking about x86)
21:27:14 <solrize_> the usual 8, plus 8 additional ones, plus there are 8 additional xmm registers
21:27:40 * mwotton should probably stop getting surprised by x86 weirdnesses
21:27:43 <mmorrow> so really, 3 times as many
21:27:54 <solrize_> no, 2x
21:28:00 <solrize_> x86-32 has 8 xmm registers
21:28:02 <mmorrow> err, does ghc use the xmm ones
21:28:06 <mmorrow> ah
21:28:06 <solrize_> yes
21:28:24 <mmorrow> ghc doesn't use then on x86-32 though (i'm pretty sure)
21:28:29 <mmorrow> s/then/them/
21:28:33 <abbe> Is there any API documentation viewer for Haskell libs ?
21:28:44 <mwotton> so the 64 bit registers are only accessible when you flip the chip into 64 bit mode or something?
21:28:50 <solrize_> abbe, haddock generates html pages
21:28:55 <solrize_> mwotton, yeah
21:29:18 <solrize_> well i think you can use a 64 bit prefix on individual instructions in 32 bit mode
21:29:21 <mmorrow> solrize_: i've looked at the ghc -S output to try to find out exactly that and i didn't see any xmm regs
21:29:23 <solrize_> i'm not a real x86 programmer, just a wannabe
21:29:50 <abbe> solrize_: that I know, but I'm wondering if I can view the Haskell documentation present on my box at distributed at different places, similar to DevHelp (GNOME)
21:29:53 <solrize_> looking
21:30:09 <abbe> s/ at dist/ dist/
21:30:16 <solrize_> abbe i'm not sure i understand the question
21:30:25 <mmorrow> abbe: i don't believe it's built by default, but you can certainly build it yourself
21:30:28 * ddarius should write some assembly.  I haven't written any in a while.
21:30:40 <mmorrow> abbe: (but you have to do so manually as far as i know)
21:30:40 <solrize_> dons i tihnk your blog is down
21:30:43 <ivanm> ddarius: but isn't that something to be _happy_ about?
21:30:56 <solrize_> i remember some asm code from dons blog that used xmm
21:31:02 <ddarius> ivanm: Assembly is fun.
21:31:07 <shapr> Silly question, how do I use git to fetch from github?
21:31:16 <abbe> solrize_: i mean xmonad has its api docs in $DATADIR/xmonad/html and xmonad-contrib has its in $DATADIR/xmonad-contrib/html  and so on...
21:31:24 <solrize_> http://www.agner.org/optimize/   <-- really good x86 asm info
21:31:35 <lambdabot> Title: Software optimization resources. C++ and assembly. Windows, Linux, BSD, Mac OS X
21:31:41 <mmorrow> solrize_: heh, me too. that's what prompted me to look at ghc -S output. i think that asm was gen for 64bit
21:32:03 <abbe> solrize_: so I mean if there is any tool which knows about haskell documentation available at all places on my box and I can view any documentation using that tool.
21:32:15 <mmorrow> or that was my conclusion at least (i couldn't find the post you're refering to last time o looked for it)
21:32:32 <solrize_> abbe, nothing that i know of, how is the tool supposed to locate every file that might contain haskell docs?
21:33:14 <luite> how dow I write the function minus one (-1)? ghc thinks that I mean 'negate 1'
21:33:21 <solrize_> http://book.realworldhaskell.org/read/profiling-and-optimization.html
21:33:22 <mmorrow> subtract 1
21:33:25 <solrize_> look towards the end
21:33:28 <luite> ah
21:33:33 <luite> thanks mmorrow
21:33:33 <lambdabot> Title: Chapter 25. Profiling and optimization, http://tinyurl.com/6znyvk
21:33:36 <mmorrow> sometimes (-1) works depending on context
21:33:45 <solrize_> although, that is gcc generating that code
21:33:46 <abbe> solrize_: Are haskell libs docstrings get embedded in haskell-libs .so during compilation, if yes then maybe one can load the lib and retrieve the documentation string from there.
21:33:50 <solrize_> and it probably does similar for 32 bit
21:33:56 <solrize_> abbe i don't think so
21:34:15 <mmorrow> solrize_: ah yeah. i'm talking about -fasm
21:34:27 <solrize_> try -fvia-c
21:34:33 <abbe> okay, thanks solrize_ and mmorrow
21:38:22 <zloog> @src concatmap
21:38:22 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:38:26 <zloog> @src concatMap
21:38:26 <lambdabot> concatMap f = foldr ((++) . f) []
21:48:36 <dons> Lemmih: will you announce concat-map ?
21:49:20 <dons> looks complicated.
21:50:14 <mmorrow> solrize_: no xmm on x86_32 with -fvia-C either: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=458
21:50:28 <dons> mmorrow: hmm?
21:50:44 <dons> oh, 32.
21:51:07 <mmorrow> dons: yeah. solrize_ and i were wondering if you'd get any on 32
21:51:55 <solrize_> interesting
21:51:55 * mmorrow tries to decide if he'll stick with fedora for his 64bit install
21:51:59 <solrize_> recent gcc
21:52:03 <solrize_> ?
21:52:03 <mmorrow> one sec
21:52:15 <mmorrow> gcc version 4.1.2 20070925 (Red Hat 4.1.2-33)
21:52:20 <solrize_> ok
21:52:23 <dons> used -funbox-strict-fields ?
21:52:31 <dons> you need that to get any xmm*
21:52:40 <mmorrow> i used this to get that .s:
21:52:42 <mmorrow> ghc -fforce-recomp -O2 -funbox-strict-fields -fvia-C -S -optc-O2 I.hs
21:52:48 <dons> ok
21:53:08 <mmorrow> and lifted that code verbatim from: http://book.realworldhaskell.org/read/profiling-and-optimization.html
21:53:09 <lambdabot> Title: Chapter 25. Profiling and optimization, http://tinyurl.com/6znyvk
21:53:22 <mwotton> just as a sanity check - on a 64 bit machine, i should expect sizeof(int) to return 8, right?
21:53:27 <mmorrow> maybe it's my gcc?
21:54:18 <dons> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=458#a460
21:54:39 <mmorrow> 64bit++
21:55:00 <dons> note the boxed return. its annoying
21:55:16 <dons> it means there's a 3 instruction heap check at the start of the loop
21:55:20 <dons> since it must allocate on the way out.
21:55:30 <mmorrow> hmm
21:56:05 <dons> i think i talk about that in the blog post.
21:59:23 <dons> now, what was the solution. hmm.
21:59:28 <mmorrow> your blogs behaving strangely. i can't quite load it, then when i hit enter to try again it loads for a split second, then retries. (weird)
21:59:32 <solrize_> your blog is still at .au ?
21:59:52 <mmorrow> i'm trying http://cgi.cse.unsw.edu.au/~dons/blog
21:59:54 <lambdabot> Title: Haskell hacking
22:00:17 <dons> hmm
22:00:34 <dons> looks like something at unsw is down.
22:00:44 <solrize_> ic
22:01:57 <mwotton> dons: blame SS
22:03:45 <dons> hmm. why are those returns still boxed.
22:04:04 <mmorrow> that's unfortunate
22:04:51 <mmorrow> and both the Double /and/ the Int no less
22:05:05 <dons> ah
22:05:12 <dons> my mistake.
22:05:17 <dons> forgot -funbox-strict-fields :)
22:05:21 <mmorrow> heh
22:05:24 <dons> $wfold_s1JN :: Double# -> Int# -> Double# -> (# Double#, Int# #)
22:05:28 <dons> that's where it's at.
22:05:56 <mmorrow> what's that asm look like?
22:08:58 <dons> ah good
22:09:26 <dons> http://hpaste.org/11870
22:10:11 <dons> $ ghc-core B.hs -O2 -fvia-C -optc-O2 -funbox-strict-fields
22:10:14 <mmorrow> that's quite an improvement :)
22:10:18 <dons> same as gcc.
22:10:26 <dons> no heap check either.
22:10:35 <dons> getting rid of those boxed returns is kinda important.
22:10:42 <solrize_> dons did you not like my suggestion of using a float for the counter in that example, to re-use a register?  too ugly, or just didn't work?  i never actually tried it
22:11:03 <dons> oh, haven't tried.
22:11:08 <dons> what's the suggestion?
22:11:24 <dons> data P = P !Float !Int
22:11:24 <dons>  ?
22:11:33 <solrize_> looking
22:11:41 <dons> or ..
22:11:51 <solrize_> i think the suggestion was P !Float !Float
22:11:56 <dons> mm.
22:11:58 <dons> let's see.
22:12:10 <solrize_> or rather, double double
22:12:44 <solrize_> which should represent ints exactly up to 53 bits
22:13:24 <dons> mm$wfold_s1J0 :: Double# -> Double# -> Double# -> (# Double#, Double# #)
22:14:07 <dons> gcc produces identical code
22:14:10 <solrize_> hmm
22:14:11 <dons> so its doing some conversion for us.
22:14:17 <solrize_> neat
22:14:18 <dons> oh, not quite.
22:14:22 <dons> ah yes.
22:14:25 <dons> identical.
22:14:34 <roconnor> mwotton: int in C is now fixed to 32bits because there were too many moronic C programers
22:15:02 <dons> solrize_: http://hpaste.org/11870#a1
22:15:05 <mwotton> ... ok. so how do i get a 64 bit int in haskell?
22:15:08 <mwotton> ghc, rather
22:15:13 <SamB> what version of the standard does it say that in ?
22:15:18 <jsn> Int64 ?
22:15:19 <dons> it checks the size of long at compile time.
22:15:22 <mwotton> <whiny> dons has it ... </whiny>
22:15:28 <dons> Int is 64 bit, because it maps to long.
22:15:32 <roconnor> @hoogle Int64
22:15:33 <lambdabot> Data.Int data Int64
22:15:37 <dons> so you'll have to install an x86_64 ghc binary
22:15:38 <bd_> SamB: The C standard says ints can hold at least -2^16 to 2^16-1.
22:15:43 <dons> or compile it with flags to force 64 bit mode
22:15:58 <SamB> I didn't think there were C standards that said anything about any morons
22:16:03 <mwotton> compile ghc with the right flags?
22:16:11 <mwotton> not dependent on what gcc says, then?
22:16:27 <dons> like, -optc-mabi=64
22:16:28 <dons> or something
22:16:42 <jsn> "Moronic use of shorts will result in undefined behaviour."
22:16:43 <dons> there must be a way to force it to use 64 bit libs, and 64 bit abis. check your docs
22:16:56 <dons> jsn: -fdo-random-things
22:17:09 <bd_> SamB: well, when the 64-bit ABIs were being made, people chose to maintain compatibility there :) Plus ints don't /need/ to be 64-bit, most of the time
22:17:20 <bd_> which saves memory, given they're one of the most commonly used data types...
22:17:26 <solrize_> i remember thinking it was possible to bum another instruction out of that
22:20:20 <SamB> bd_: I really don't think it was just the morons they were thinking of when they made the decision
22:20:54 <SamB> jsn: you'd be surprised what moronic stuff you can do without invoking UB
22:21:05 <SamB> however you'd probably have to be doing that on purpose
22:22:33 <jsn> SamB: "Moronic use of shorts will result in basically right behaviour like 95% of the time -- but never when the product is demoed!"
22:23:10 <DrSyzygy> Hehe
22:23:39 <SamB> no, I mean, you could use shorts when it is really dumb to do so but still write correct code, even
22:23:48 <jsn> ah, i see
22:23:52 <SamB> though I guess not to the same extent as with long long ;-P
22:23:57 <jsn> oh?
22:24:02 <bd_> shorts don't save memory unless you are very careful with alignment anyway
22:24:10 <DrSyzygy> jsn: You do recognize the existence of non-moronic use of shorts?
22:24:10 <SamB> well, say you could have used char!
22:24:16 <jsn> i guess long long results in terrible space usage
22:24:27 <SamB> long long would waste much more space ;-P
22:24:28 <jsn> DrSyzygy: sure -- they have uses
22:24:37 <jsn> like time
22:24:47 <jsn> i always count time with shorts, in milliseconds
22:24:55 <SamB> jsn: heh
22:24:57 <bd_> jsn: that sounds like a nice way to overflow
22:25:01 <jsn> you get like -- uh -- oh no!
22:25:09 <bd_> note that shorts aren't faster than ints on modern CPUs :)
22:25:21 <SamB> indeed ;-)
22:25:22 <bd_> modern, non-embedded rather
22:25:24 <SamB> probably slower
22:25:40 <jsn> maybe they are useful for, uhm, serialization?
22:25:52 <bd_> sure, maybe
22:25:57 <bd_> but gzip might also have a similar effect
22:26:15 <jsn> you can't really mmap stuff that way, though
22:26:23 <bd_> true
22:26:35 <jsn> unless you have a gzipping filesystem
22:26:43 <jsn> which is probably not far away...
22:26:47 <bd_> but if you mmap now you get to deal with all the fun of structure portability
22:27:03 <jsn> yeah, true
22:27:13 <bd_> although apart from endianness you probably won't see too much weirdness on desktop OSes
22:27:30 <jsn> even endianness is basically a non-issue, right?
22:27:34 <bd_> no
22:27:38 <bd_> still plenty of macs out there
22:27:38 <jsn> well, okay, old macs
22:27:39 <SamB> you know, you would get lynched for suggesting that on ##c
22:28:04 <bd_> and the iphone, probably
22:28:06 <SamB> the serializing structs with things other than chars in, I mean
22:28:17 <jsn> SamB: why lynched?
22:28:29 <jsn> bd_: curses
22:28:36 <bd_> jsn: technically speaking, the representation of integers can have even more weirdness than just endianism
22:28:41 <solrize_> well, you might want to just have a lot of structs in memory without serializing them, and shorts save space
22:28:43 <jsn> oh?
22:28:44 <bd_> things like trap bits and other fun stuff
22:28:54 <jsn> trap bits?
22:28:58 <bd_> however machines that do that sort of weirdness are almost entirely dead now
22:29:11 <bd_> jsn: set this bit, and now if you so much as sneeze at the value your program crashes
22:29:15 <bd_> even though it's just an int
22:29:24 <jsn> what is that actually for?
22:29:38 <bd_> jsn: apparently when C was standardized, there were machines that did that
22:29:48 <bd_> remember, this was the age where they still had ones-complement machines out there
22:30:00 <bd_> and 9-bit bytes
22:30:03 <solrize_> jsn, you could mark undefined values in memory that way
22:30:05 <jsn> hahaha
22:30:13 <jsn> solrize_: oh
22:30:17 <p_l> bd_: not bytes really
22:30:18 <bd_> The C standard has a /lot/ of warts from that age
22:30:28 <bd_> p_l: well, bytes, really. Bytes == octets came later
22:30:33 <jsn> i read the first half of the first volume of TAOCP
22:30:44 <bd_> In the C standard anyway, a 'byte' is just the unit of memory addressing
22:30:44 <p_l> Also C standard specifies 8bit bytes and sizeof char = 1
22:30:50 <jsn> i really liked the math section, but then we got into all the stuff about 9bit bytes
22:30:54 <bd_> p_l: no. C specifies /minimum/ 8bit bytes
22:31:00 <bd_> sizeof char does equal one though
22:31:08 <bd_> there's a macro for the byte size - CHAR_BIT
22:31:11 <p_l> bd_: Those computers didn't use the word byte afaik - you simply refered to words
22:31:25 <jsn> ah, well
22:31:38 <jsn> but i think today we could agree on 8bit bytes
22:31:44 <p_l> Also, the assumption that char = 1 byte makes GCC break in interesting ways when sizeof char becomes 8 ^__^
22:31:47 <SamB> jsn: on MOST computers
22:31:51 <jsn> though the battle for big endian is a different matte
22:31:52 <prb> fwiw, the answer to my earlier question about cabal-install going crazy (mem/cpu consumption) was an old cabal-install (c-i 0.5.2, ghc 6.8.3) on the path preempting the new (c-i 0.6.0, ghc 6.10.1).
22:31:53 <SamB> sometimes you don't have them, though
22:31:58 <jsn> s/matte/matter/
22:32:02 <SamB> some have 12-bit bytes!
22:32:06 <jsn> SamB: like on what?
22:32:11 <SamB> I think pics
22:32:15 <jsn> SamB: what kind of thing is that?
22:32:17 <jsn> pics?
22:32:23 <bd_> p_l: that is because sizeof(char)==1 is /explicitly/ specified in the C standard :)
22:32:58 <bd_> so once sizeof(char)!=8, it's not a C compiler anymore, so have fun debugging your compiler for a new language :)
22:32:59 <SamB> embedded processors, anyway
22:33:01 <bd_> er
22:33:03 <bd_> !=1
22:33:17 <jsn> SamB: embedded processors actually have 12 bit bytes?
22:33:19 <p_l> bd_: Yes... but unless you create a lot of compiler magic, keeping sizeof char = 1 would break *everything*
22:33:25 <SamB> well, I think it's 12
22:33:30 <SamB> I wouldn't swear it
22:33:31 <bd_> p_l: No. It stays sizeof char = 1.
22:33:35 <SamB> but it wasn't 8
22:33:37 <solrize_> there are 12 bit pics that are pretty popular
22:33:38 <SamB> and it wasn't 16
22:33:39 <solrize_> also 14 bit
22:33:42 <jsn> hmm
22:33:48 <p_l> bd_: It was added AFAIK in ANSI version, before that wasn't a requirement
22:33:50 <jsn> what is pics here?
22:33:59 <solrize_> microchip pic = cheap microcontroller
22:34:05 <jsn> oh
22:34:10 <SamB> p_l: GCC doesn't support such dialects, in any case
22:34:18 <p_l> bd_: Makes for interesting problem when your pointers have bit-granularity
22:34:19 <solrize_> i think there is gcc for the pic
22:34:31 <ben_h> yep there is
22:34:34 <solrize_> it is a very popular part, used in a lot of cable tv smart cards etc.
22:34:39 <ben_h> and for the Atmel AVR ones
22:34:42 <jsn> well, hrumph
22:34:46 <p_l> SamB: Actually there's a version of GCC that had it, though old an unofficial
22:34:49 * ben_h prefers AVR
22:34:53 <bd_> p_l: mmm, well, that's not officially C, so it's that compiler's problem to make it work :)
22:34:57 <SamB> er, I was talking about systems where sizeof(char) != 1
22:35:13 <jsn> i think there are many practical cases where you could serialize everything as little endian, say
22:35:14 <SamB> ben_h: doesn't everyone ?
22:35:31 <bd_> jsn: Do it in big-endian, if only because little-endian machines tend to be faster at byteswapping
22:35:40 <jsn> hmm
22:35:45 <jsn> okay, maybe that is better
22:35:50 <p_l> bd_: Basically the whole modification was to stop GCC from assuming that char = 1 byte and to always advance in char* arrays by +(CHAR_SIZE) instead of ++
22:35:53 <ben_h> SamB: I would have thought so :)
22:35:55 <SamB> also you can use htonl etc. in that case ;-P
22:35:56 <ben_h> much cleaner design
22:35:56 <jsn> big endian is SPARC and PowerPC, yes?
22:35:59 <bd_> there's been a dedicated opcode for it on x86 since the 486
22:36:09 <bd_> p_l: horrible hack is horrible
22:36:27 <abbe> bswap32
22:36:34 <p_l> bd_: Better than shoehorning a VM on a DSP-like cpu
22:36:38 <bd_> and before the 486, byteswapping was done with three ops and a clever use of the 16-bit register alias
22:36:46 <bd_> p_l: well, I mean, it's be better to just *8 everything
22:37:05 <bd_> because now you're going to have things malloc(sizeof(long)) and get 8*4 bytes, right?
22:37:13 <bd_> but I don't know the details of how it worked
22:37:27 <SamB> bd_: which three ops ?
22:37:30 <p_l> bd_: You'd get 8 bytes
22:37:40 <solrize_> byte swapping a short?
22:37:49 <solrize_> xor al,ah
22:37:52 <solrize_> xor ah,al
22:37:55 <solrize_> xor al,ah
22:37:56 <solrize_> heh
22:38:00 <bd_> solrize_: no :P
22:38:10 <bd_> with a short you can do it in one op
22:38:13 <p_l> bd_: except that it didn't use an OS, cause it was so small that you ran bare code
22:38:18 <bd_> for 32-bit:
22:38:33 <bd_> xchgb %b0,%h0; rorl $16,%0; xchgb %b0,%h0
22:39:06 <bd_> so eg, xchgb al, ah; rorl $16, eax; xchgb al, ah
22:39:33 <bd_> and for 16-bit just one xchgb
22:39:37 <solrize_> ic.  i forgot you could rorl on the x86, i thought you could only shift arithmetic
22:39:37 <SamB> bd_: why do you have that in GCC's inline assembler ???
22:39:43 <SamB> do you actually have code that uses it ?
22:39:51 <bd_> SamB: because I copied it out of the inline definition in /usr/include/asm/byteorder.h :)
22:40:01 <SamB> oh
22:40:12 <SamB> right
22:40:20 <bd_> solrize_: well, since 386 anyway
22:40:27 <SamB> Linux used to run on 386, didn't it
22:40:34 <bd_> SamB: still can in theory
22:40:50 <SamB> bd_: even the tip ?
22:40:51 <bd_> although I wouldn't be surprised if little bugs sprung up from time to time
22:41:04 <bd_> SamB: maybe not on the default settings *shrug*
22:41:15 <jsn> i guess floating point numbers are not really compatible across platforms of the same endianness?
22:41:18 <bd_> debian's only just recently dropped 386
22:41:32 <bd_> jsn: IEEE floats are fairly compatible in practice, I think
22:41:50 <jsn> hmmm
23:10:33 <roconnor> dons: you should use haskell charts to make IRC plots :)
23:10:50 <roconnor> more cairo -> more antialiasing
23:13:23 * shapr plots to overthrow #ocaml
23:13:28 <shapr> Wait, what sort of irc plots did you mean?
23:13:32 <pumpkin_> http://dockerz.net/twd/HaskellCharts that?
23:13:37 <lambdabot> Title: HaskellCharts - twd
23:14:14 <dons> roconnor: or the gnuplot bindings
23:14:17 <dons> gnuplot does irc too
23:14:23 <dons> does *aa* too
23:14:52 <dons> shapr: 2500 days of #haskell traffic http://haskell.org/sitewiki/images/c/c4/Irc-raw.png
23:15:15 <Beelsebob> what are the axes on that dons ?
23:15:23 <dons> days since epoch.
23:15:25 <shapr> That's a lot of traffic.
23:15:26 <dons> and kb
23:15:35 <roconnor> pumpkin_: that
23:15:39 <Beelsebob> ah, kk
23:15:44 <shapr> Looks like we've hit a plateau though.
23:15:51 <roconnor> dons: but HaskellCharts is so much more Haskelly
23:15:52 <dons> ?users
23:15:52 <lambdabot> Maximum users seen in #haskell: 559, currently: 484 (86.6%), active: 6 (1.2%)
23:15:57 <solrize_> there's a periodic component, what is it?
23:16:03 <dons> shapr: not sure. we've been hitting high scores for the last month
23:16:09 <shapr> Yeah, good point.
23:16:53 <dons> books coming out, winter activities. ghc 6.10 , multicore still a problem. stuff like that?
23:16:55 <roconnor> dons: you'd even get years labeld
23:17:11 <dons> well, that's easy enough in gnuplot too
23:17:19 <dons> feel free to whip up some graphs
23:17:27 <dons> shapr: you saw the graph vs #ocaml?
23:17:30 <roconnor> you have the data?
23:17:50 <dons> http://galois.com/~dons/images/irc.png shapr, note mfp and Yoric are getting them organised somewhat.
23:17:54 <roconnor> or can I give you the haskell code
23:17:58 <roconnor> :)
23:18:01 <dons> well, i can give you data.
23:18:03 <roconnor> probably shorter
23:19:14 <dons> roconnor: http://galois.com/~dons/tmp/irc-data
23:19:27 <dons> first column is kb's that day. second is the date.
23:21:10 <roconnor> just haskell data?
23:21:12 <roconnor> ok
23:22:09 <dons> yeah. i can't find ocaml data. and we don't need to pick on them further, imo.
23:22:33 <dons> all we need to do is write code. :)
23:22:44 <shapr> dons: I agree!
23:23:16 <dons> rwh goes to the printers in 6 days, shapr.
23:23:31 <shapr> w00!
23:23:37 <dons> yaya!
23:23:42 <shapr> I already have my copy on preorder at the nearby bookstore.
23:23:50 <shapr> Hopefully they'll order several and put some on the shelf.
23:24:01 <shapr> I already have one coworker who wants to borrow my copy as soon as it arrives.
23:24:17 <shapr> He hasn't tried Haskel before, and was asking me for the best intro. I of course suggested RWH.
23:24:40 <dons> cool. yes, i think having it online has been great for getting the word out.
23:24:47 <dons> bonus' tutorial is also lots of fun.
23:24:50 <shapr> I'll keep my copy of RWH on my desk at work, next to my other nifty goodies.
23:25:03 <dons> did you see http://learnyouahaskell.com/ ?
23:25:10 <lambdabot> Title: Learn You a Haskell for Great Good!
23:25:20 <shapr> I glanced at it, haven't gotten around to seriously perusing it.
23:25:23 <solrize_> cool!!!  (re rwh going to printer)
23:25:32 <crutcher> which of Parsec is the right / current / official Parsec?
23:25:34 <dons> i think its very haskelly, the tutorial. fun, playful, exploratory.
23:25:42 <dons> crutcher: people are defaulting for 2.0
23:25:53 <crutcher> I'm looking at the libs, and there seems to be 3 copies in the heirarchy
23:26:00 <dons> hmm?
23:26:03 <shapr> I'm still fighting the Cell obsession... but lack of available info from Mercury and IBM and cost of Linux for anything other than the PS3 is getting me frustrated.
23:26:06 <dons> there's only one parsec.
23:26:09 <shapr> crutcher: 3?
23:26:15 <crutcher> http://www.haskell.org/hoogle/?q=many1
23:26:16 <lambdabot> Title: many1 - Hoogle
23:26:24 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
23:26:25 <lambdabot> Title: HackageDB: parsec-3.0.0
23:26:36 <solrize_> what happened to drcode's book?  it's supposed to be out around now
23:26:43 <dons> solrize_: hmmm?
23:26:44 <mmorrow> ReadP++
23:26:45 <shapr> crutcher: Text.Parsec is seriously old school.
23:26:50 <solrize_> lisperati.com
23:27:05 <crutcher> There's Text.Parsec.Combinator, Text.ParserCombinators, and Text.ParserCombinators.Parsec
23:27:08 <dons> yes, i remember the announcement.
23:27:14 <mmorrow> @karma ReadP
23:27:14 <lambdabot> ReadP has a karma of 1
23:27:16 <mmorrow> ReadP++
23:27:20 <mmorrow> hehe
23:27:22 <shapr> crutcher: Text.ParserCombinators.Parsec is correct.
23:27:29 <crutcher> well, how am I supposed to know that?
23:27:38 <crutcher> I mean, why's the old lib still there?
23:27:38 <dons> crutcher: hmm. good question.
23:27:56 <shapr> I'd guess it's for when you find yourself porting a program from previous versions of GHC?
23:28:03 <shapr> I've found that useful at least.
23:28:05 <crutcher> I guess the Haskell Platform will make some of this easier
23:28:11 <shapr> Yeah, I hope!
23:28:20 <dons> so its questionable whether you should choose libraries based only on hoogle. you should then consult the platform, or hackage to pick a library
23:28:27 <lispy> lisperati.com, cool nime
23:28:28 <lispy> name*
23:28:33 <shapr> crutcher: Or, cabal install parsec
23:28:36 <crutcher> is there any plan to make the docs easier to navigate? There's no way to go 'up' from a given doc
23:28:38 <dons> however, we should have hoogle only index the platform, for example
23:28:47 <shapr> Local hoogle would be nice.
23:28:49 <dons> crutcher: oh, haddock docs?
23:29:04 <crutcher> dons: yes, the stuff hoogle points to
23:29:35 <solrize_> oh, looks like his book is lisp based, i thought it was going to be about haskell
23:29:44 <ben_h> haddock is a great name.
23:29:47 * roconnor takes a moment to weep over 2 digit years
23:30:00 <dons> hehe
23:30:10 <dsturnbull> it's almost fashionable to start using them again
23:30:18 <dons> yeah. retro style
23:30:29 <roconnor> readTime defaultTimeLocale "%y.%m.%d" b::LocalTime
23:30:34 <roconnor> 1901-12-16 00:00:00
23:30:35 <crutcher> ben_h: blegh. its a terrible name. Puns are bad names for tools and libs, but that doesn't stop anyone
23:30:45 <ben_h> no way, puns are the best
23:30:59 <crutcher> no, they make everything more difficult to document
23:31:00 <roconnor> readTime defaultTimeLocale "%Y.%m.%d" ("20"++b)::LocalTime
23:31:50 <lispy> I recall working on a Fortran application in 2006 that was printing dates like 10/13/106
23:32:13 <lispy> It was trying to do MM/DD/YY but failing :)
23:32:42 <mmorrow> FORTRAN--
23:32:45 <lispy> it actually took us a while to realize it was a date string simply because "106" looked so weird
23:33:37 <crutcher> mmorrow: fortran, cobol and excel run the world
23:33:41 <crutcher> :/
23:33:44 <lispy> mmorrow: is that one of the new GHC backends? fortran-- ?
23:33:55 <dons> anyone here written any fortran or cobol recently?
23:34:05 <mmorrow> lispy: yes. along with COBOLMINUSMINUSENDWORD
23:34:25 <cdfh> dons: as if they would admit it :-)
23:34:28 <mmorrow> crutcher: tis a sad state of affairs :(
23:34:34 <lispy> dons: last time I did was around July 2007, I was making a Fortran binding for something
23:34:38 <crutcher> dons: I don't, but the numbers seem to suggest it is still big.
23:34:45 <solrize_> http://coboloncogs.org
23:34:48 <dons> the numbers?
23:35:07 <dons> i'm sure it's still around. there are haskell bindings to old fortran numerics things
23:35:18 <crutcher> mmorrow: I saw a talk where a pl researcher claimed that excell was the most popular language in the world, and that most programmers were secretaries and admins
23:35:29 <lispy> dons: as in, the code was actually written in C but needed to be accessed from Fortran and the fortran application is used in a multi billion dollar model.  Eg., they use it to estimate growth in different sectors
23:35:46 <mmorrow> fortran does rock for certain numeric stuff actually (in that super optimized fortran code exists for it, not for writing new code)
23:35:51 <mmorrow> FORTRAN++
23:36:05 <lispy> dons: so, while it's a tiny bit of code, the decision makers use it in very large financial decisions
23:36:07 <mmorrow> crutcher: heh
23:36:07 <dons> yep. 20, 30 year old libraries.
23:36:12 <dons> lispy: makes sense.
23:37:18 <lispy> Fortran tends to be well liked still by computational scientists
23:37:37 <Nafai> At my last company there was still a significant portion of an application being developed in Cobol that ran on HP-UX servers and was controled via VT100
23:37:42 <lispy> IMO, it can make C++ look easy though.
23:37:55 <Nafai> We actually wrote a Java Swing front end that parsed the VT100 stuff and turned it into a GUI
23:38:07 <lispy> Nafai: haha, IBM does stuff like that
23:38:38 <lispy> Instead of porting the app, they'll write an emulator for the old mainframe and then make people still use the old mainframe apps
23:38:47 <crutcher> mmorrow: I had a talk with my advisor while I was still in college. I made the claim that "most programmers are uneducated, and not that bright, and languages that need to be popular need to take that into account", he got upset and told me that "no one likes to be called dumb". I pointed out that most programmers weren't like him, to which he responded "I guess most of them only have an undergraduate degree in CS". Which of course th
23:39:27 <Nafai> crutcher: "only"
23:39:42 <Nafai> lispy: Yeah, that's pretty much the case here
23:40:06 <crutcher> yeah. I wasn't as polite in my response. I think I laughed at him. He came arround to my point of view pretty quickly
23:40:54 <crutcher> oh, that reminds me. I've got this idea, and no clue if it is good for anything at all, or even feasible. A Haskell Spreadsheet.
23:41:00 <mmorrow> otoh, i think "trying to account for \"dumbness\"" is one of the reasons (eg) the american education system sux
23:41:17 <crutcher> mmorrow: it doesn't suck.
23:41:29 <crutcher> mmorrow: I know that's a controversial position
23:41:31 <mmorrow> it sucks relative
23:41:39 <Nafai> crutcher: Like a normal spreadsheet but each cell contains Haskell code?
23:42:10 <crutcher> no, it doesn't. that's the thing. Its wonderful, considering that you've now got _everyone_ going to school, rather than pre-selecting those likely to be succesful
23:42:13 <crutcher> Nafai: yes
23:42:30 <Nafai> crutcher: Have you seen Resolver One? http://www.resolversystems.com/products/resolver-one/  It's like that, but using Python.
23:42:31 <crutcher> mmorrow: we could make it better, but its actually pretty good
23:42:36 <lambdabot> Title: Resolver Systems: Resolver One™
23:42:37 <ben_h> crutcher: that's the same in any developed country
23:42:53 <ben_h> minus any rare exceptions i don't know of
23:43:24 <crutcher> selection bias makes it very difficult to think clearly about education
23:44:10 <lispy> crutcher: I saw a spreadsheet language that allowed pretty much arbitrary embedding of java apps in the cells, I think it was called A4.  At least it was some cell referenc like that.
23:44:13 <crutcher> at my school, the first 4 CS classes each had a 50% loss rate. 50% of those taking them switched to something else. We didn't really teach anyone to be programmers, we just selected those who already were.
23:45:28 <mmorrow> yeah, i should qualify my statement by "it sucks for students that are capable of studying (eg) math at much higher level than what is offered"
23:45:34 <sclv> crutcher: credit suisse has something like that in house as i recall.
23:45:35 <crutcher> Nafai: neat.
23:45:37 <Nafai> crutcher: So each cell would be a function that returns an IO CellValue or something like that?  And the function name would be the cell reference?
23:46:03 <crutcher> Do you want to run it in the IO monad?
23:46:12 <sclv> essentially the ghc api embedded as a haskell extension as a dll.
23:46:23 <mmorrow> crutcher: and i'm talking about <= high school here
23:46:23 <sclv> s/haskell extension/excel extension.
23:46:27 <Nafai> Maybe IO isn't the right monad, but I'd assume some Monad
23:47:08 <crutcher> Hmm, I'm wondering if you really want a 'sheet', or if a 'tabular graph' would be better, if that makes sense.
23:47:27 <crutcher> because that's how most spreadsheets actually work anyway.
23:47:41 <lispy> crutcher: have you read the paper by SPJ about user defined functions in excel?
23:47:43 <crutcher> and then you have to deal with range selections, and remebering where you put calcs
23:47:52 <crutcher> no, I haven't.
23:48:25 * mmorrow had toyed around with making a spreadsheet in haskell, but with a hugely expanded language available to work with
23:48:33 <lispy> crutcher: ftp://ftp.cs.orst.edu/pub/burnett/icfp03.excelFunctions.pdf
23:48:39 <crutcher> and by 'actually work' I don't mean 'are implemented', but rather, are organized by users
23:49:12 <mmorrow> , let eval a = fmap (`id` eval a) a in eval [const 42, \x -> x!!2 + x!!0, (!!0)]
23:49:20 <lunabot>  [42,84,42]
23:49:36 <Nafai> This actually sounds like a fun problem
23:49:36 <lispy> I know researchers who consider excel to be the most widely used functional language
23:51:06 <sclv> if you have a circular dependency between cells how do you resolve it -- evaluate to a fixpoint, or for a set number of steps, or make it an error -- this seems like one key problem to me.
23:51:25 <lispy> sclv: or just use cycle dectection
23:51:28 <mmorrow> sclv: so i was going to first do a check for cycles
23:51:43 <lispy> sclv: but, forms/3 (a research spreadsheet language) solves this I know
23:51:43 <sjanssen> sclv: Exception: <<loop>>
23:51:45 <mmorrow> then functionalize the graph and call loeb on it
23:52:24 <lispy> excel just prevents cycles
23:52:31 <crutcher> lispy: that's really cool.
23:53:02 <crutcher> lispy: no it doesn't. well, not always. It has several modes
23:53:44 <crutcher> it has a mode where it will run for X iterations (where X ~= 100000) until it stabilises
23:53:52 <lispy> and cycle dectection has an algo with good complexity, I'll add
23:54:11 <lispy> crutcher: huh, I've never seen that
23:54:27 <roconnor> catchException Loop
23:54:35 <crutcher> I think you have to turn it on explicitly, or something.
23:55:40 <crutcher> anyway, I was thinking I wanted a sort of semi-graphical quant environment in Haskell, but with a lot of spreadsheet-like features. But I only have this vauge idea, and no real goal for impl
23:56:17 <sclv> its a very nice notion. i'd love to see where you could take it.
23:56:25 <Nafai> crutcher: Sounds interesting to me as well
23:56:50 <jekor> I'm getting "Constraint is no smaller than the instance head in the constraint: Num a" when trying to create a type class with a couple functions I want to define for Strings, Integer, Ints, and Doubles. And the code for the Num types is the same. Is there a way to do it without instance Num a => TypeClassName a where ?
23:56:57 <roconnor> > let eval a = fix (sequence a) in eval [const 42, \x -> x!!2 + x!!0, (!!0)]
23:56:59 <crutcher> lets see. You need a tabluar graph gui, to hold data, and a workspace, to hold code
23:56:59 <lambdabot>   [42,84,42]
23:57:09 <roconnor> > let eval = fix . sequence in eval [const 42, \x -> x!!2 + x!!0, (!!0)]
23:57:10 <sjanssen> crutcher: oh, have you seen vital?
23:57:11 <lambdabot>   [42,84,42]
23:57:20 <crutcher> nope?
23:57:29 <sjanssen> crutcher: it is quite a bit different from what you describe, but it is really neat
23:57:55 <sjanssen> http://www.cs.kent.ac.uk/projects/vital/
23:57:56 <lambdabot> Title: Vital homepage
23:58:16 <Beelsebob> http://www.cs.kent.ac.uk/projects/pivotal/ <-- a bit more up to date sjanssen
23:58:16 <lambdabot> Title: Pivotal home page
23:58:34 <Beelsebob> unfortunately, Keith has retired, so I don't think anything is moving on it any more
23:58:52 <mmorrow> , let foofoo f a = f (`id` foofoo f a) a ; eval = foofoo fmap in eval [const 42, \x -> x!!2 + x!!0, (!!0)]
23:58:54 <lunabot>  [42,84,42]
23:59:13 <crutcher> hmm. neat, but I don't really care about 'documents'.
23:59:27 <mmorrow> @type let foofoo f a = f (`id` foofoo f a) a in foofoo
23:59:28 <lambdabot> forall t t1 t2. (((t -> t1) -> t1) -> t2 -> t) -> t2 -> t
23:59:32 <mmorrow> hehe
23:59:51 <crutcher> I mean, I'm all for selecting data out of my quant space and projecting it through a formatter to build reports, but that's not the right env to get work done
