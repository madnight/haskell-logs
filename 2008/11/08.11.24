00:05:16 <Lemmih> thoughtpolice: Making headway?
00:07:23 <thoughtpolice> Lemmih: yes
00:07:36 <thoughtpolice> Lemmih: I've just gotten deriving for Update working
00:07:46 <thoughtpolice> so if all goes well I should just be able to build lhc right now against derive
00:07:58 <thoughtpolice> since everything else it was deriving was monoid, functor, binary, traversable, etc.
00:36:35 <pao> @seen Cale
00:36:36 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 3h 2m 20s ago.
00:36:59 <tessier> #haskell-overflow? WTF?
00:38:25 <tessier> This channel isn't that busy. Why an overflow channel?
00:38:59 <yuuki> Is anyone here a fan of the sequent calculus?  I don't really understand its point and what it is an alternative to.
00:39:19 <tessier> I'm amazed at how popular haskell has become. #haskell is the largest functional programming channel.
00:39:23 <tessier> yuuki: Never heard of it. What is it?
00:39:48 <yuuki> It's a proof system
00:41:54 <Saizan> tessier: depending on the hour it can get busy, so longer discussions tend to migrate to -overflow
00:42:23 <Saizan> e.g. to explain something to a newbie
00:42:38 * pumpkin_ whistles innocently
00:43:22 <xenoblitz> *looks around, trying to divert attention from himself*
00:43:33 <tessier> So, any large projects besides xmonad written in haskell?
00:43:53 <pumpkin_> ghc :P
00:44:30 <xenoblitz> tessier: look at the many domain specific languages embedded in haskell: Lava (circuits), Haskore (music), Fran (pics/animation) ...
00:45:17 <tessier> xenoblitz: Never heard of any of 'em
00:45:33 <pumpkin_> also, one of the better perl 6 implementations is in haskell
00:45:34 <pumpkin_> http://www.pugscode.org/
00:45:45 <lambdabot> Title: Pugs - pugscode
00:45:55 <tessier> Ah, yes. I have heard of pugscode. Is that actually going anywhere though? I haven't heard any news of it in a good year or so.
00:46:21 <pumpkin_> the svn is still pretty active, it seems
00:46:26 <pumpkin_> I don't follow perl much
00:46:43 <pumpkin_> http://pugs.blogs.com/
00:46:48 <lambdabot> Title: Pugs
00:48:18 <tessier> Yeah, I just looked at svn. Still commits going.
00:48:41 <tessier> pugs.blogs.com hasn't been updated in a few months though
00:48:51 <tessier> I used to subscribe to Audry's blog but it went dead too.
00:54:52 <Adamant> darcs is also in Haskell
00:55:33 <mlesniak> Hasn't darcs received a lot of bad publicity recently?
00:55:41 <pumpkin_> tessier: http://programatica.cs.pdx.edu/House/
00:55:42 <pumpkin_> :P
00:55:43 <kalven_> it sort of lost to git
00:55:46 <lambdabot> Title: House
00:55:52 <pumpkin_> I love git, never tried darcs though
00:56:08 <pumpkin_> I kinda like the "theory of patches" idea, but I haven't actually read what the theory involves
00:56:46 <Adamant> mlesniak: yeah, but it's supposedly getting back on the right track
00:57:01 <mlesniak> Adamant, any more information on this?
00:57:15 <Adamant> mlesniak: new devs, more devs, more releases
00:57:32 <Adamant> performance problems being fixed
00:59:22 <yitz> mlesniak: good project leadership
01:00:15 <mlesniak> Ah, ok, thanks
01:02:10 <tessier> mlesniak: Bad publicity? How so?
01:02:24 <tessier> I've heard of House but never known anyone who actually booted it up. I really like the idea though.
01:03:39 <tessier> It would seem that any OS has got to have some sort of Linux compatibility so that it can take advantage of all of the drivers and GNU userland etc.
01:04:15 <tessier> And then start migrating things to Haskell as resources allow. But with so much C knowledge out there and so little Haskell knowledge that's going to be hard.
01:04:49 <Twey> I agree.
01:05:05 <Twey> But hey, I'd join the project.
01:07:12 <mapreduce> The GNU stuff is portable, an OS needn't be Linux-based to have that.
01:10:05 <yitz> I think you need some small amount infrastructure to support LInux binaries, but if you're near-POSIX it shouldn't be too bad. I remember that the BSDs had to do some work to get there.
01:10:54 <yitz> House has a way to go before they get to that though.
01:20:09 <thoughtpolice> Lemmih: ping?
01:23:08 <Lemmih> thoughtpolice: Yes?
01:32:19 <thoughtpolice> Lemmih: ok, I've gotten lhc to build against data.derive instead of drift
01:34:05 <thoughtpolice> Lemmih: I had to write a derivation for Data.Derive, but it works and I've uploaded it to hackage.
01:34:16 <thoughtpolice> (derive-0.1.4)
01:34:29 <thoughtpolice> Lemmih: the problem is, an exception is being thrown now when I try to compile base
01:35:04 <Lemmih> Oh? That shouldn't happen.
01:36:16 <Lemmih> thoughtpolice: Which exception is it?
01:36:18 <thoughtpolice> Lemmih: http://hpaste.org/12312
01:37:34 <pumpkin_> dons: did some pretty haskell code generate this? http://galois.com/~dons/images/chart.png
01:37:56 <mbz> @pl case x of { 'z' -> "zz"; '.' -> "zd"; _ -> [x]; }
01:37:56 <lambdabot> (line 1, column 11):
01:37:57 <lambdabot> unexpected "{"
01:37:57 <lambdabot> expecting variable, "(", operator or end of input
01:38:03 <mbz> err
01:38:19 <vegai> pumpkin_: looks like the output of that one haskell graphing library
01:38:21 <mbz> how do I convert this code to a pl one?
01:38:22 <vegai> what was it again...
01:38:28 <pumpkin_> :o
01:39:17 <vegai> fgl perhaps
01:39:30 <vegai> no.
01:39:31 <pumpkin_> nah, that's for graph theory graphs
01:39:52 <vegai> yeah.
01:40:40 <vegai> meh, I cannot remember it now
01:41:29 <Lemmih> thoughtpolice: Why would using Data.Derive change the generated code in any way?
01:41:44 <vegai> ah!
01:41:46 <vegai> pumpkin_: http://dockerz.net/twd/HaskellCharts
01:41:52 <lambdabot> Title: HaskellCharts - twd
01:41:57 <pumpkin_> thanks! :) looks nice
01:42:42 <yitz> @pl if x == 'z' then "zz' else if x == '.' then "zd" else [x]
01:42:42 <lambdabot> (line 1, column 48):
01:42:42 <lambdabot> unexpected end of input
01:42:42 <lambdabot> expecting variable, "(", operator or "else"
01:43:14 <yitz> @pl if x == 'z' then "zz' else (if x == '.' then "zd" else [x])
01:43:14 <lambdabot> (line 1, column 49):
01:43:14 <lambdabot> unexpected end of input
01:43:14 <lambdabot> expecting variable, "(", operator or "else"
01:43:37 <yitz> @pl if x == 'z' then "zz" else if x == '.' then "zd" else [x]
01:43:37 <lambdabot> if' (x == 'z') "zz" (if' (x == '.') "zd" [x])
01:43:52 <yitz> @pl \x -> if x == 'z' then "zz" else if x == '.' then "zd" else [x]
01:43:52 <lambdabot> ap (flip if' "zz" . ('z' ==)) (ap (flip if' "zd" . ('.' ==)) return)
01:44:00 <yitz> ahhh
01:44:38 <pumpkin_> :o
01:45:56 <pumpkin_> how can you prove the output of @pl is exactly equivalent to the input? I guess by providing a path of simple transformations from the input to the output, and proving each transformation to not affect behavior?
01:46:19 <quicksilver> yes. You'd prove each step.
01:46:31 <quicksilver> you'd find it impossible, actually.
01:46:35 <quicksilver> because @pl is broken ;)
01:46:41 <pumpkin_> how so?
01:46:57 <quicksilver> I can't remember.
01:47:02 <quicksilver> A couple of edge-cases in its parser.
01:47:14 <yitz> it seems to work usually
01:47:28 <thoughtpolice> Lemmih: no idea; do you want a copy of the patch that does all the changes to look at it?
01:48:07 <quicksilver> yes, the edge cases don't come up very often in practie
01:48:45 <Lemmih> thoughtpolice: Yeah.
01:49:38 <pumpkin_> one thing I've been wondering that is rather hard to search for, is what is this _|_ thing I see used all the time?
01:50:58 <Saizan> it's called bottom, since it's the least element in the lattice of values using the definedness preorder
01:51:18 <Saizan> it stands for a non-terminating computation or an excpetion
01:51:22 <pumpkin_> ah
01:51:29 <Saizan> e.g. undefined = error "undefined"
01:51:34 <thoughtpolice> Lemmih: k, just a sec
01:51:41 <pumpkin_> is it an actual symbol I can type into ghci? cause when I try it it says there's a syntax error
01:51:51 <pumpkin_> or is it more of an illustrative thing when talking about functions
01:52:32 <Saizan> the latter
01:52:38 <pumpkin_> ah ok
01:54:06 <yitz> > undefined
01:54:08 <quicksilver> pumpkin_: it's an attempt at an ascii representation of the mathematical bottom symbol
01:54:08 <lambdabot>   * Exception: Prelude.undefined
01:54:18 <quicksilver> pumpkin_: which is an upside-down simple sans-serif 'T'
01:54:26 <pumpkin_> yeah, I've seen that :)
01:54:40 <yitz> pumpkin_: undefined is what we often use
01:55:07 <yitz> @google denotational semantics
01:55:09 <lambdabot> http://en.wikipedia.org/wiki/Denotational_semantics
01:55:10 <lambdabot> Title: Denotational semantics - Wikipedia, the free encyclopedia
01:55:13 <Saizan> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
01:55:35 <Peaker> does Reactive have an (IO a -> Behavior a) legacy adapter?
01:56:48 <quicksilver> possibly
01:56:54 <thoughtpolice> Lemmih: sent
01:56:59 <quicksilver> depends how you expect that to work.
01:57:23 <quicksilver> there isn't an obvious way to express an IO a as a 'Reactive (FunTime a)'
01:57:41 <Peaker> quicksilver: I basically want something like: keysPressed :: UI -> Behavior (Key -> Bool)
01:58:12 <quicksilver> Right. That would be a bad idea.
01:58:17 <quicksilver> how often would it call it?
01:58:27 <quicksilver> ("it" == the underlying IO a)
01:58:43 <Peaker> quicksilver: I think I want to have an explicit iterations/sec for my game, so I limit the number of movements that can be made with the keyboard
01:58:59 <Peaker> quicksilver: if I use the keyPress event, the game is as easy as your typematic rate
01:58:59 <quicksilver> I doubt you want to let that pollute your Keys interface thouhg.
01:59:16 <Peaker> quicksilver: oh, I don't, I was hoping the Behavior is only called whenever it is sampled
01:59:49 <Peaker> I was also wondering if it is blasphemous to have explicit iterations in an FRP game
01:59:55 <BeelsebobWork> Peaker: what I suggest you do is you create an atTimes [0,repeatRate..]
02:00:14 <BeelsebobWork> and then I'm sure I've seen david taking the occurances from one event and putting them into the times of another
02:00:17 <BeelsebobWork> it should be possible
02:00:27 <BeelsebobWork> to delay until the nearest occurance of that event
02:00:34 <Peaker> BeelsebobWork: Yeah, I have that, I wanted an   Event (Key -> Bool)   from sampling_ that event with Behavior (Key -> Bool)
02:00:58 <BeelsebobWork> and, yes, it is blaspheamous to want itterations in an FRP game -- but it's not blasphemous to want an event that occurs regularly
02:01:23 <Peaker> BeelsebobWork: well, in the event that occurs regularly, I check the keyboard keys to make the moves
02:01:37 <thoughtpolice> Lemmih: I think I might have found the problem actually
02:01:50 <thoughtpolice> Lemmih: yeah I did
02:01:54 <hnr07> Trying to work my way through "An Introduction to Functional Programming Systems Using Haskell", but I've run into a snag very early in the process
02:02:03 <hnr07> on the top of page 14 (you can see it at http://books.google.com/books?id=OPFoJZeI8MEC&pg=PA14), the book suggests the following syntax
02:02:04 <lambdabot> Title: An Introduction to Functional ... - Google Book Search
02:02:13 <hnr07> http://hpaste.org/12314#a0
02:02:17 <hnr07> however, ghci (6.8.2, from Debian 'testing') chokes on that input with the syntax error shown at the paste
02:02:21 <BeelsebobWork> yep, that makes sense, so you'd have (NoKey `stepper` keyboardInput) `sample` keyRepeat
02:02:21 <Peaker> BeelsebobWork: it is easily possible to revert integral/etc back to explicit state change in such an event translation, so its less FRP'ish
02:02:23 <BeelsebobWork> does that make sense?
02:02:38 <BeelsebobWork> well, you could write an event 'integral'
02:02:48 <hnr07> Is the book wrong, or am I just not reading it correctly, or...?
02:02:52 <Peaker> BeelsebobWork: what's keyRepeat?
02:03:03 <BeelsebobWork> it's atTimes [0,repeatRate..]
02:03:22 <thoughtpolice> Lemmih: I accidentally deleted a line that ran the src/DerivingDrift/ code over the module so it didn't generate instances for a datatype using a 'deriving' clause
02:03:29 <Peaker> BeelsebobWork: oh, that's probably gameIteration or such, it dictates more things about the game progress (and also necessary for the network game to be in sync)
02:03:33 <quicksilver> Peaker: a behaviour which was only called when it was sampled sounds a bit unsound.
02:03:35 <thoughtpolice> Lemmih: so I'll take that out of the patch, rebuild and test and then push the patch?
02:03:50 <yitz> hnr07: that's not meant to be typed that way into ghci
02:04:01 <BeelsebobWork> quicksilver: no, that makes sense -- as long as you're really explicit about wanting to sample it at certain event points
02:04:04 <yitz> hnr07: they mean to write it into a source file that way
02:04:13 <quicksilver> BeelsebobWork: then I'd call it an event, personally.
02:04:20 <yitz> hnr07: ghci doesn't accept multi-line input
02:04:21 <quicksilver> BeelsebobWork: (and sample it at those event points)
02:04:29 <quicksilver> that seems more "honest" abotu what you're doing.
02:04:33 <BeelsebobWork> quicksilver: for example, you might want to have a character have a "smooth" motion through a world
02:04:39 <BeelsebobWork> and sample that at a screenrefresh rate
02:04:43 <BeelsebobWork> and at a network transmit rate
02:04:45 <BeelsebobWork> etc
02:04:46 <hnr07> yitz: I see - they strongly implied in the book that this was being typed into the interpreter. I'll give that a shot.
02:04:46 <quicksilver> sure. I do that.
02:04:59 <quicksilver> it doesn't involve any Behaviours formed out of an IO a which is called when sampeld :)
02:05:01 <Lemmih> thoughtpolice: Or you could push the patch you have now and fix the mistake in a new one.
02:05:09 <BeelsebobWork> oh, I see, no, that makes no sense
02:05:11 <yitz> > let pi = 3.141592653589793; r = 5.76 in 4 * pi * r * r
02:05:12 <lambdabot>   416.9220176949629
02:05:27 <Peaker> quicksilver: but (Key -> Bool) is not an event, it always exists
02:05:30 <BeelsebobWork> the IOs should be being driven by something else
02:05:34 <Lemmih> thoughtpolice: That way I won't have to unpull (:
02:05:43 <hnr07> yitz: So what is the correct way to define multiple bindings in a given "let" in ghci?
02:05:45 <yitz> hnr07: note the semicolons to separate the let decl. when put onto a single line. other than that, it works the same way
02:06:16 <Peaker> BeelsebobWork: if I don't have explicit iterations to control the progress of the game, how would I have, for example, network sync between various instances later?
02:06:21 <quicksilver> Peaker: Yes. I would build a behaviour (Key -> Bool)
02:06:31 <quicksilver> Peaker: it's just, I would not build it the way you suggested
02:06:40 <BeelsebobWork> Peaker: the network sync would be an event, which is used to sample a behavior of the game state
02:06:42 <quicksilver> by using semanticallyUnsoundSample :: IO a -> Behaviour a
02:06:54 <Peaker> quicksilver: why waste building that function on key events, when it only matters when its sampled?
02:07:03 <yitz> hnr07: (only one semicolon in this case)
02:07:11 <hnr07> yitz: Thanks, I'll try that as well, since putting that syntax in a file and running "ghc myfile.hs" gave me the same parse error
02:07:14 * quicksilver shrugs
02:07:17 <BeelsebobWork> Peaker: incidentally -- are you the guy who wrote tetris?
02:07:21 <Peaker> BeelsebobWork: nope
02:07:26 <BeelsebobWork> hmm, okay
02:07:33 <BeelsebobWork> I thought I might be tying people together there
02:07:37 <thoughtpolice> Lemmih: oi, I already unrecorded that patch and re-recorded it :x
02:07:44 <Peaker> BeelsebobWork: wchoggs wrote tetris
02:07:49 <BeelsebobWork> ah, okay
02:07:58 <yitz> hnr07: it needs to be myfile.lhs because the '>' on each line makes it "literate haskell" syntax
02:08:08 <Peaker> BeelsebobWork: I am trying to rewrite a Python game I wrote, as well as a P2P network game engine here.. the "network sync" cannot be an event, I'm not sure what you mean
02:08:12 <quicksilver> Peaker: because it strikes me as a more elegant way to model it shrug :)
02:08:25 <BeelsebobWork> Peaker: why can't "network sync" be an event?
02:08:26 <quicksilver> Peaker: certainly Behaviour (Key -> Bool) is fine.
02:08:30 <quicksilver> that behaviour clearly exists.
02:08:50 <quicksilver> it might be it satisfies the side conditions you need to make that sampling method sound.
02:08:57 <Lemmih> thoughtpolice: Oh well. I'll survive (:
02:09:11 <quicksilver> (something like "sampling rate doesn't affect results" would be the side condition)
02:09:12 <yitz> hnr07: it looks like they're using some other interpreter, not ghci
02:09:40 <C-Keen> where can I find a guide on phantom types?
02:09:42 <Peaker> quicksilver: yeah, I'd expect that precondition from an IO a -> Behavior a   legacy adapter
02:10:09 <hnr07> yitz: Yeah, I thought the same thing, but I was under the impression that Haskell was a pretty tightly specified language, so didn't understand how that could create such wide variation
02:10:28 <quicksilver> Peaker: my point is, it's not a simple adapter, because it has a side condition
02:10:32 <Peaker> BeelsebobWork: the network model is one where each player's keyboard events are translated into actions, that are explicitly executed a few iterations later, to give time to the network packets to arrive. Until any action is acked, it is re-sent in each UDP packet
02:10:33 <quicksilver> Peaker: that's all it was, really.
02:10:33 <hnr07> yitz: ghc doesn't seem to like that syntax in myfile.lhs either
02:10:40 <quicksilver> just pointing out it's not safe in general.
02:10:46 <quicksilver> the IO a has to satisfy particular properties.
02:11:12 <Peaker> quicksilver: yeah, I see, but the legacy adapters are already unsafe in general, probably (allow some abuse, in their IO things)
02:11:15 <hackage> Uploaded to hackage: derive 0.1.4
02:12:00 <yitz> hnr07: in a file - get rid of the '?' at the end
02:12:57 <yitz> hnr07: haskell is tightly specified - at least the "Haskell 98" standard that all current implementations are based upon.
02:13:07 <yitz> hnr07: but that is for source files.
02:13:26 <hnr07> yitz: in a .lhs file, I get "a.lhs:2:10: parse error on input `='"
02:13:43 <thoughtpolice> Lemmih: ok, I've pushed the patch, so now we don't need derive at all, and Setup.hs doesn't have to be compiled since we can use a default Setup.hs
02:13:50 <thoughtpolice> er s/derive/DrIFT/
02:14:07 <Twey> hnr07: Paste it :)
02:14:09 <Twey> @paste
02:14:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:14:21 <hnr07> Twey: http://hpaste.org/12314
02:14:24 <yitz> hnr07: but there are variations in how the various interactive interpreters work.
02:14:30 <Lemmih> thoughtpolice: src/DerivingDrift/ doesn't use the drift binary?
02:15:04 <hnr07> yitz: I can appreciate that :) Just trying to close the gap between what they're telling me and what will work - hugs doesn't care for that input, either
02:15:23 <yitz> hugs and ghci are very similar.
02:15:29 <thoughtpolice> Lemmih: no, afaics it's actually used to derive instances of things (like Show and Eq) for code the compiler parses
02:15:57 <Twey> hnr07: Remove the question mark from the end of that line
02:15:59 <Lemmih> thoughtpolice: ok, excellent. This should make testing easier as well.
02:16:23 <hnr07> Twey: http://hpaste.org/12314#a1
02:16:28 <thoughtpolice> Lemmih: so it's actually a part of drift, built into lhc - i thought it wouldn't be necessary, but when I removed that import (only one module uses DerivingDrift.Drift) and changed the code, that what was caused that error
02:16:38 <hnr07> Twey: a.lhs:2:10: parse error on input `='
02:16:38 <Twey> hnr07: It's common to start the lines with '> ' rather than just '>', too, to distinguish the starting '>' symbol from the actual line of code :)
02:16:54 <BeelsebobWork> Peaker: I don't see how that stops "network send" being an event
02:17:07 <thoughtpolice> Lemmih: it err'd because it then just ignored all 'deriving' clauses since I took that out
02:17:11 <hnr07> Twey: So the second line would be '>[space][tab]'?
02:17:25 <yitz> hnr07: http://hpaste.org/12314#a2
02:17:37 <yitz> hnr07: no tabs!
02:17:40 <quicksilver> Peaker: rule of thumb : 'Event' is anything which happens at discrete times.
02:17:50 <Peaker> BeelsebobWork: you send the unack'd actions every iteration, and sample received actions from everyone else every iteration
02:17:51 <quicksilver> Peaker: discard all your other prejudices about what an Event might be.
02:18:09 <quicksilver> Events can be internal or external, generated or calculated, cause or effect
02:18:14 <thoughtpolice> Lemmih: yeah, this will make it easier to test, and having a plain Setup.hs is far easier to manage
02:18:15 <BeelsebobWork> Peaker: stop thinking in terms of itterations
02:18:22 <Peaker> okay
02:18:22 <hnr07> yitz: No? Without a tab, it gave me an error about indentation...
02:18:40 <yitz> hnr07: use spaces, and make sure it lines up.
02:18:45 <hnr07> OK
02:18:46 <Twey> hnr07: http://hpaste.org/12314#a3
02:18:50 <Peaker> BeelsebobWork: but I want it to be in sync with the time that keys are sampled, what should I call the event in which both happen?
02:18:52 <BeelsebobWork> you have a network send event, you have a network recieve event, the latter needs to be merged into a behavior of the game state somehow, at some pount
02:18:54 <BeelsebobWork> point*
02:19:01 <yitz> hnr07: if you go down the road of tabs, it will lead you to grief.
02:19:08 <hnr07> yitz: your suggestion works - so it's the need to declare "main" that I was missing, I guess? What would that be, a "module"?
02:19:08 <BeelsebobWork> I don't know -- that's your code style issue
02:19:18 <BeelsebobWork> I'd call it allInputs or something like that
02:19:19 <yitz> hnr07: configure your editor not to use any tabs for indentation
02:19:30 <BeelsebobWork> allInputs = keyboardInput `mappend` networkInput
02:19:31 <Twey> hnr07: Incidentally, pi is defined in the prelude
02:19:33 <Twey> > pi
02:19:35 <lambdabot>   3.141592653589793
02:19:41 <thoughtpolice> Lemmih: I'm also thinking of changing lib/base to lib/lhcbase, adding a dummy Setup.hs and uploading lhcbase to hackage
02:19:52 <thoughtpolice> Lemmih: so then people can 'cabal install lhc; cabal install lhc-base'
02:19:54 <hnr07> Twey: Yes, they made that point in the book, but told me to overwrite it for purposes of demonstration
02:19:54 <Peaker> BeelsebobWork: then I use allInputs `sample` (atTimes [...])
02:20:25 <Saizan> thoughtpolice: btw, which version of binary did you use in the tests at http://thoughtpolice.stringsandints.com/code/lhc-tests/hello-world/ ? binary < 0.4.4 has poor performance on ghc-6.10.1
02:20:31 <BeelsebobWork> not sure -- you'd need to do something clever to get the delaying behavior you want, but yes something like that
02:20:35 <lambdabot> Title: Index of /code/lhc-tests/hello-world, http://tinyurl.com/5jplab
02:20:46 <BeelsebobWork> I think really what you want is a Reactive
02:20:46 <thoughtpolice> Saizan: binary 0.4.4
02:20:49 <hnr07> Twey: your pastebin gives the same error - a.lhs:2:9: parse error on input `='
02:20:53 <Lemmih> thoughtpolice: That would make it problematic to install packages that depend on 'base'.
02:20:53 <BeelsebobWork> which is a discretely changing value
02:21:03 <BeelsebobWork> so it may be worth poking conal to actually expose Reactives
02:21:06 <Peaker> BeelsebobWork: any idea how to write   sample :: Event a -> Event b -> Event (a, b)   (times dictated by the latter event)
02:21:09 <hnr07> Twey: yitz's code works, I'm just not sure what that 'main =' is doing there in his example
02:21:17 <Twey> I misplaced a space
02:21:23 <Peaker> BeelsebobWork: I guess it should actually be snapshot
02:21:31 <hnr07> Twey: Yeah, I had to fix the indentation error :)
02:21:34 <thoughtpolice> Lemmih: hm, any ideas on that?
02:21:34 <Peaker> BeelsebobWork: so I just translate the event into a behavior and use snapshot
02:21:41 <BeelsebobWork> Peaker: at the moment I'd hack it with something along the lines of creating a behavior with stepper, and then snapshot it
02:21:47 <Twey> hnr07: 'main' is the entrypoint to your program.
02:21:52 <BeelsebobWork> but you'd have to be careful about composing the behavior so you didn't lose info
02:21:56 <Twey> Every program should have one, unless it's a library.
02:22:00 <hnr07> Those are easy to fix, though - this other is more of a conceptual hole that I have to fill.
02:22:12 <Peaker> BeelsebobWork: lose info?
02:22:57 <hnr07> Twey: That helps - I guess I'll just assume there's a missing ' main = ' in all the examples until I get around to learning how entrypoints and libraries work in Haskell
02:23:01 <Lemmih> thoughtpolice: Uploading 'base' might not break things. Cabal-install should ignore it when not compiling with lhc, I think.
02:23:02 <hnr07> yitz, Twey: Thanks
02:23:37 <yitz> C-Keen: what do you want to know about phantom types? ask here.
02:24:01 <thoughtpolice> Lemmih: also what should we do with the configure.ac/Makefile.am stuff lying around?
02:24:35 <C-Keen> yitz: I don't understand how it works in general
02:25:30 <hnr07> Twey, yitz: Know of Haskell book likely to give me less grief?
02:25:30 <Twey> hnr07: The same way they do in any language :)
02:25:51 <Twey> When your program is run, the Main.main function is evaluated.
02:26:02 <hnr07> I'm waiting for my copy of "Real World Haskell", but this was in the public library :)
02:26:05 <Twey> hnr07: I recommend http://book.realworldhaskell.org/read/
02:26:10 <lambdabot> Title: Real World Haskell
02:26:11 <thoughtpolice> Lemmih: with jhc the makefiles build the stuff in data/rts into RawFiles; for my compiler I just let cabal generate a 'Paths_*' module, and did something like 'lhc_rts = (unsafePerformIO getHomeDirectory) </> ".lhc" </> "rts" </> "lhc_rts.c" '
02:26:23 <Twey> Ah, right :)  RWH is available online, while you're waiting.
02:26:30 <hnr07> I had no idea
02:26:31 <hnr07> Thanks!
02:27:09 <thoughtpolice> Lemmih: er, more like lhc_rts = unsafePerformIO readFile $ (unsafePerformIO getHomeDirectory) </> ".lhc" </> "rts" </> "lhc_rts.c"
02:27:34 <hnr07> Twey: I'm more used to languages like Python and Perl, where the "main" is rather - err, "implied". :)
02:27:36 <Lemmih> thoughtpolice: Right.
02:27:52 <thoughtpolice> Lemmih: think that would be an easier way? I can patch that in right fast
02:28:58 <Lemmih> thoughtpolice: Sounds good.
02:29:01 <yitz> @go learn yourself a haskell
02:29:03 <lambdabot> http://weblog.jamisbuck.org/2005/11/4/amaze-yourself-with-haskell
02:29:04 <lambdabot> Title: the { buckblogs :here }: aMAZE yourself with Haskell
02:29:13 <lilac> @go learn you a haskell for great good
02:29:14 <yitz> no
02:29:22 <lambdabot> http://learnyouahaskell.com/
02:29:22 <lambdabot> Title: Learn You a Haskell for Great Good!
02:29:38 <yitz> hnr07: ^ that's it
02:29:39 <Taejo> is there a page somewhere that describes the working of ST?
02:30:01 <hnr07> heh - "learn you a Haskell"
02:30:17 <Lemmih> thoughtpolice: We need a script for regenerated the rts and the PrimitiveOperators.hs file, btw.
02:30:23 <Twey> hnr07: That doesn't make much sense in Haskell
02:31:19 <BeelsebobWork> wow, OCaml guys really feel threatened by Haskell don't they?
02:31:23 <hnr07> Twey: Well, and that'll probably be a really good thing for me to learn
02:31:47 <yitz> C-Keen: I've seen the term "phantom types" used in several different ways
02:32:01 <quicksilver> BeelsebobWork: some people probably do. Don't make the mistake of false generalisation though :)
02:32:08 <BeelsebobWork> true
02:32:23 <quicksilver> There is plenty I admire about ocaml.
02:32:25 <BeelsebobWork> I just seem to be seeing more and more often "militant" comments on any Haskell blog
02:32:29 * quicksilver nods
02:32:40 <BeelsebobWork> along the lines of "hey, don't use Haskell, it's rubbish, OCaml is way better"
02:32:42 <Peaker> quicksilver: I don't know OCaml so that sounds interesting, things about OCaml that are not in Haskell?
02:32:47 <quicksilver> relatively small numbers of people can make a lot of noise.
02:32:51 <quicksilver> (just look at dons ;P )
02:33:00 <BeelsebobWork> hehe
02:33:02 <BeelsebobWork> true
02:33:11 <Peaker> quicksilver: can you describe some things you admire about OCaml that are not in Haskell?
02:33:17 <quicksilver> Peaker: functors/signatures
02:33:26 <yitz> C-Keen: in general, it's when you include something in a type expression only to manipulate how it type-checks or type-infers, but you don't actually use that parameter in expressions of that type.
02:33:31 <quicksilver> Peaker: ocaml4p (pluggable fronted)
02:33:47 <quicksilver> Peaker: meta-ocaml
02:33:55 <quicksilver> Peaker: quality of native codegen
02:33:55 <Peaker> quicksilver: what are OCaml functors/signatures?  and how does ocaml4p differ from TH?
02:34:26 <quicksilver> functors/signatures are a higher-order module system.
02:34:37 <pumpkin_> quality of native codegen? I thought ghc was pretty much as good as ocaml now in terms of generated code
02:34:43 <pumpkin_> oh, maybe not size of generated code
02:34:48 <quicksilver> ocaml4p is a much lighter-weight way to add arbitrary syntax.
02:34:57 <quicksilver> pumpkin_: not really, no.
02:35:16 <quicksilver> to be fair, it's doing a different job.
02:35:23 <pumpkin_> how so?
02:35:24 <hnr07> Twey, yitz: Again, thank you both for the patience. I'm sure you'll see a lot more of me, but for now it's way past my bedtime. I can go to sleep with the hope that some of this Haskell will cook into my cells during sleep. Thanks again.
02:35:31 <quicksilver> efficient codegen for a lazy language is quite different from efficent codegen for a strict language.
02:35:40 <yitz> C-Keen: one example is in http://www.haskell.org/haskellwiki/Phantom_type
02:35:42 <lambdabot> Title: Phantom type - HaskellWiki
02:35:47 <Twey> hnr07: Well, Haskell programs are evaluated when required, not as parsed
02:35:54 <Twey> hnr07: OK :)  Sleep tight!
02:36:02 <Twey> Don't let the Pythons bite :)
02:36:06 <yitz> C-Keen: another (simpler) example is the function Data.Bits.bitSize
02:36:09 <hnr07> heh :)
02:36:32 <yitz> hnr07: np
02:36:35 <hnr07> Twey: No more than neccesary to hold down the day job long enough to pitch Haskell as an alternative ;)
02:36:48 <Twey> Heheh
02:37:02 <Twey> So few Haskell jobs
02:37:13 <Twey> I've been judging job sites based on how many Haskell jobs they've got
02:37:16 <Lemmih> thoughtpolice: I feel a bit guilty for not getting any results while you commit so much good work. (o:
02:37:21 <Twey> The most I've found is three
02:38:23 <yitz> Twey: Haskell has only recently become a language that is useful in real life.
02:38:33 <ttomm> It's useful in real life?
02:38:35 <Twey> Yes, but still
02:38:50 <Twey> You'd think there'd be a fair few adventurous startups
02:39:06 <quicksilver> Twey: maybe they don't use job sites?
02:39:09 <yitz> ttomm: sure. there are even games in Haskell. :)
02:39:16 <C-Keen> yitz: thanks
02:39:20 <Twey> quicksilver: Perhaps
02:39:28 <Twey> ttomm: Of course
02:44:51 <Lemmih> dcoutts: Will cabal-install ignore packages that aren't buildable with the selected implementation?
02:44:54 <yitz> Twey: it wasn't long ago when you couldn't hope to find any Haskell jobs on a general job board - the community was small enough that everything was word of mouth.
02:45:18 <ttomm> Started learning it in Spetember at University. Don't get me wrong, I find it really fun attempting to do things with it, but it just seems a bit... out-of-the-box to me.
02:45:34 <Peaker> what's (const x <$>) called?
02:45:44 <ttomm> Like building a house out of used teabags or something, which would no doubt be very well insulated.
02:45:51 <yitz> Twey: the fact that you find them there now is sign that Haskell has moved up a league.
02:45:57 <thoughtpolice> Lemmih: ;]
02:46:03 <Peaker> A @hoogle (fmap . const) finding the right operator would be awesome :)
02:46:53 <yitz> ttomm: Haskell is definitely out-of-the-box.
02:47:56 <yitz> Peaker: it's called x
02:48:15 <BeelsebobWork> Peaker: <$
02:48:21 <Peaker> BeelsebobWork: thanks
02:48:26 <Peaker> @type (<$)
02:48:27 <yitz> ah. sorry.
02:48:27 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
02:49:30 <Saizan> @hoogle (Functor f) => a -> f b -> f a
02:49:31 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
02:49:31 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
02:49:31 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
02:50:01 <thoughtpolice> Lemmih: ok, all of the files in data/ are now specified as 'data-files' in the .cabal file, and RawFiles.hs has been rewritten to just use unsafePerformIO + readFile, so now we can edit the RTS in ./data/rts and when we reinstall the compiler will pick up the updated rts
02:52:07 <Peaker> BeelsebobWork: hey, can you help me understand:  forall v t. (VectorSpace v, t ~ Scalar v, Num t) => t -> Event t -> Reactive v -> Reactive v  ?    t0 newT r are the arg names, what do they mean?
02:52:31 <BeelsebobWork> what's the function name?
02:52:37 <Peaker> BeelsebobWork: integral
02:52:45 <Peaker> BeelsebobWork: I want an integral, but this function signature confuses me
02:52:54 <BeelsebobWork> oh, t0 is the constant offset of your integral
02:53:04 <BeelsebobWork> newT is an event to sample the reactive at
02:53:12 <BeelsebobWork> (this is euler integration)
02:53:18 <BeelsebobWork> r is the reactive to integrate
02:53:37 <Peaker> BeelsebobWork: What's the "t" type, I'd expect it to be the "v" type, and the event-to-sample to be Event ()  ?
02:53:59 <BeelsebobWork> yeh, I expected that at first hang on while I remember why that's no good
02:54:28 * BeelsebobWork struggles
02:54:30 <thoughtpolice> Lemmih: on my system, base now takes about 1:24s to install
02:54:33 <Peaker> BeelsebobWork: also, conal told me that the Reactive type is not exported (only Behavior), so how is integral, with this type, exported?
02:54:37 <BeelsebobWork> there is a good reason for that, but I don't remember why
02:54:59 <BeelsebobWork> Peaker: good question -- look at integral on behavior instead
02:55:05 <BeelsebobWork> I'm not sure why that's exported at all
02:55:23 <Peaker> BeelsebobWork: oh I was possibly looking at an internal module
02:55:28 <Peaker> BeelsebobWork: Event () -> Behavior v -> Behavior v      is much clearer! :-)
02:55:29 <Lemmih> thoughtpolice: Oh? That's quite fast. Did you do something to make it faster?
02:55:38 <BeelsebobWork> Peaker: good good :)
02:56:35 <Lemmih> thoughtpolice: I clock in at 1:51 with a 3Ghz AMD.
02:56:54 <BeelsebobWork> what's that you're installing?
02:57:05 <BeelsebobWork> oh, nvm, wrong channel
02:57:06 <BeelsebobWork> >.<
02:57:57 <Peaker> what do anygma do, btw?
02:58:00 <Twey> ttomm: It's quite unusual, yes.  But it's unusual in ways that have great practical value.
02:58:20 <Twey> For example, see xmonad — it has basically all the features of, say, dwm, with about a tenth of the code
02:59:05 <idnar> are "foldl' (&&) True" and "foldl' (||) False" already defined somewhere?
02:59:07 <BeelsebobWork> Peaker: we're making tools for creating (procedural) digital content
02:59:22 <Twey> idnar: 'all' and 'any'
02:59:36 <idnar> oh right, I made a typo just now
02:59:41 <Peaker> BeelsebobWork: digital content as in Web content, with the awful web "technologies"?
02:59:53 <Peaker> BeelsebobWork: (are you wrapping the awful web techs, that is?)
03:00:02 <BeelsebobWork> Peaker: no, digital content as in 3D games, movie graphics, real time TV graphics
03:00:04 <BeelsebobWork> that kinda stuff
03:00:11 <Peaker> BeelsebobWork: ah, cool
03:01:27 <Twey> > any [False, True, False, False]
03:01:28 <lambdabot>   Couldn't match expected type `a -> Bool'
03:01:37 <Twey> Hph
03:01:43 <Twey> Hmph
03:01:46 <Twey> > any id [False, True, False, False]
03:01:47 <lambdabot>   True
03:01:57 <Twey> OK, 'all id' and 'any id'
03:02:04 <Peaker> @src and
03:02:05 <lambdabot> and   =  foldr (&&) True
03:02:09 <Peaker> @src all
03:02:09 <lambdabot> all p =  and . map p
03:02:19 <Twey> Oh
03:02:21 <Peaker> @src any
03:02:21 <lambdabot> any p =  or . map p
03:02:22 <Twey> @src any
03:02:22 <lambdabot> any p =  or . map p
03:02:26 <Twey> Oho
03:02:28 <quicksilver> BeelsebobWork: s/procedural/functional/ ;)
03:02:30 <Twey> 'and' and 'or'!
03:02:44 <BeelsebobWork> quicksilver: nah, functional is just a means to an end
03:02:50 <BeelsebobWork> (a good means though)
03:03:19 <BeelsebobWork> procedural content as in "content that the computer makes up procedurally when you run the program", not as in "step by step"
03:04:22 <quicksilver> BeelsebobWork: it was a joke/pun.
03:04:28 <BeelsebobWork> ah, fair enough
03:04:35 <BeelsebobWork> sorry, hard to tell over IRC sometimes
03:04:45 <quicksilver> BeelsebobWork: although I renamed my 'procedural texture' library to 'functional texture' because the pun seems appropriate.
03:05:08 <quicksilver> BeelsebobWork: a video is after all a function Time -> 2DGraphics
03:05:20 <quicksilver> (and my textures were a function X -> Y -> Color)
03:05:53 <Peaker> are there Applicative Transformers?
03:05:56 <yitz> idnar: so you see "and" and "or" are almost, but not quite, the same as what you asked for.
03:06:03 <Peaker> Or does that not make sense?
03:06:17 <yitz> idnar: they are right folds, so they are lazy short-circuiting
03:06:42 <yitz> idnar: but they'll blow the stack on a large input list, unlike what you wrote.
03:06:56 <quicksilver> Peaker: Applicatives compose direction
03:07:00 <quicksilver> Peaker: no need to transform.
03:07:04 <yitz> or the heap or something.
03:07:07 <quicksilver> Peaker: s/direction/directly/
03:07:15 <thoughtpolice> Lemmih: no, I didn't do anything; this is a 2.2gHz core2
03:07:31 <mlesniak> I have a small syntactic problem (probably with spaces and where-clauses). Can someone take a quick look a thttp://hpaste.org/12315
03:07:39 <idnar> @src or
03:07:40 <lambdabot> or    =  foldr (||) False
03:07:49 <Peaker> quicksilver: I want many of my functions to be inside multiple reader applicatives, I am wondering about an idiom that lets me avoid repeating the (fmap.fmap) and such
03:08:32 <quicksilver> mlesniak: you can't use a where clause there.
03:08:52 <quicksilver> mlesniak: at newState = initState to your existing multiline let.
03:08:56 <quicksilver> s/at/add/
03:09:00 <quicksilver> Peaker: yeah, you can just compose them.
03:09:07 <quicksilver> Peaker: it's syntactically ugly though.
03:09:19 <mlesniak> quicksilver, oh, ok, that explains a lot, thanks!
03:09:31 <Peaker> quicksilver: at least for the types, I can have:  type GameReader  a = R.Event () -> GLUTA.UI -> a
03:09:32 <quicksilver> mlesniak: where clauses attach to definitions, not expressions.
03:09:34 <Saizan> or use Oleg's deep functor! ;)
03:09:44 <quicksilver> Peaker: Yeah, I'm familiar with the problem you describe.
03:09:51 <quicksilver> Peaker: I don't have a brilliant answer for you.
03:10:00 <Peaker> quicksilver: ok, thanks
03:10:04 <quicksilver> Look at how Behaviour is defined as the composition of two functors
03:10:15 <Peaker> I wonder if passing a game-tick source to all my functions is fine
03:10:16 <quicksilver> but the ':.' is a pain syntactically.
03:10:48 <thoughtpolice> Lemmih: ok the latest changes that change RawFiles.hs to read the RTS off disk have been pushed
03:10:51 <yitz> mlesniak: where refers back to the function def itself - it only sees the parameters of the function (and there aren't any), it doesn't see the defn. body
03:11:44 <mlesniak> Thanks, yitz
03:11:49 <yitz> mlesniak: so your indentation of where is misleading, it should be indented only two spaces
03:14:29 <Peaker> BeelsebobWork: I am torn between using integrals (which require sync'd time across a network) and using (accumE 0 ..) on a snapshot according to the ticks event source. I think I'll go with the latter because it can work over a network
03:15:22 <Peaker> is it awful to accumE 0 ((+) <$> (ticks `snapshot_` b))  instead of integral?
03:16:41 <pumpkin_> what's the E in accumE?
03:17:12 <Peaker> pumpkin_: event
03:17:55 <BeelsebobWork> Peaker: I don't see that as particularly horrible, no
03:18:41 <Peaker> how do I know which library provides "Graphics.Rendering.OpenGL.GL.CoordTrans" ?
03:19:04 <Taejo> Peaker: hoogle?
03:19:19 <Peaker> Taejo: hoogle only indexes the stdlib and whatever specific libs I told it
03:19:30 <Taejo> oh dear
03:19:53 <Taejo> Peaker: in that case, google
03:20:03 <Taejo> the answer is the OpenGL package
03:20:07 <pumpkin_> HOpenGL
03:20:11 <dolio> @seen roconnor
03:20:11 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 5h 10m 32s ago.
03:20:30 <Peaker> Taejo: I think there's a ghc-pkg way to do it too
03:20:51 <Peaker> OpenGL's vectors don't seem to be Nums, I wonder if they can be nicely manipulated/added
03:20:59 <quicksilver> Peaker: nope.
03:21:08 <quicksilver> Peaker: you can write your own instances or combinators for them.
03:21:11 <Peaker> quicksilver: who has nice Vector2's?
03:21:24 <quicksilver> the vectorspace library that fieldtrip uses, I believe.
03:21:30 <Taejo> Peaker: what is the meaning of v1*v2?
03:21:36 <Peaker> FieldTrip's vector2 is OpenGL's, though
03:21:44 <Peaker> Taejo: I don't know, I didn't say it had to be a Num instance :-)
03:21:44 <quicksilver> but it gives it a num instance
03:21:50 <quicksilver> or I thought it did.
03:21:54 <quicksilver> some combinators at least?
03:22:02 <Peaker> quicksilver: No instance for (Num (FT.Vector2 Direction))
03:22:07 <pumpkin_> Taejo: dot product or cross product?
03:22:20 <Taejo> pumpkin_: well, dot product has the wrong type
03:22:25 <Peaker> quicksilver: it gives it a Functor/Applicative intance
03:22:35 <pumpkin_> Taejo: wrong?
03:22:46 <pumpkin_> it gives a number :P
03:22:47 <Taejo> dot :: Vector -> Vector -> Scalar
03:22:53 <pumpkin_> yeah
03:23:02 <quicksilver> Taejo: probably instance Num Vector2 where (*) = error "don't be stupid"
03:23:04 <Taejo> (*) :: Num n => n -> n -> n
03:23:09 <pumpkin_> aha, didn't know that :)
03:23:12 <quicksilver> Taejo: it's just a convenience to get + and -
03:23:19 <Taejo> quicksilver: yeah, fair enough
03:23:20 <pumpkin_> I guess it needs to be the cross product then?
03:23:22 <quicksilver> although you could potentially do cross product on 3-vectors
03:23:38 <quicksilver> personally I don't (ab)use the Num instancee like this though
03:23:42 <quicksilver> I write my own combinators
03:23:47 <Peaker> @type (<$>>)
03:23:48 <lambdabot> Not in scope: `<$>>'
03:23:53 <quicksilver> btu I can understand why you'd want to.
03:24:08 <Lemmih> thoughtpolice: Neat. I'll head to bed now. See you later.
03:25:07 <Peaker> quicksilver: well, I use liftA2 (+)  for vector addition then
03:26:16 <quicksilver> or <,(+),>
03:26:19 <quicksilver> the arkanoid combinator.
03:26:36 <quicksilver> rather  <.(+).>
03:26:39 <pumpkin_> do people ever try to make smiley faces out of those combinations?
03:26:43 <quicksilver> often
03:26:45 <BeelsebobWork> they possibly look a little better
03:26:56 <BeelsebobWork> I used <^ and ^> because they look a little "lift" like
03:26:59 <quicksilver> ah, thanks.
03:27:07 <quicksilver> got no memory. did too much Perl as a kid.
03:27:14 <pumpkin_> <^_^> is invalid, I assume?
03:27:31 <Taejo> pumpkin_: _ isn't allowed infix, AFAIR
03:27:36 <quicksilver> although vectors are a kind of special-case and I don't mind giving them their own combinators
03:27:41 <pumpkin_> yeah :/, and I'd need parens around it too wouldn't I?
03:27:51 <BeelsebobWork> pumpkin_: yep
03:27:52 <quicksilver> (things like scalar premultiplication and so on)
03:28:05 <Taejo> pumpkin_: depends where you use it
03:28:11 <BeelsebobWork> actually, no
03:28:12 <BeelsebobWork> spaces
03:28:16 <pumpkin_> Taejo: for that smiley face
03:28:23 <BeelsebobWork> <^ _ ^> -- this would be liftA2 _
03:28:45 <BeelsebobWork> or rather x <^ _ ^> y would be liftA2 _ x y
03:28:46 <pumpkin_> assuming _ is allowed
03:28:50 <BeelsebobWork> yep
03:28:50 <Saizan> > let (<^_^>) = "foo" in (<^_^>)
03:28:51 <lambdabot>   <no location info>: parse error on input `)'
03:29:00 <BeelsebobWork> pumpkin_: the point is that _ is a prefix operator
03:29:03 <BeelsebobWork> so no parens are needed
03:29:06 <pumpkin_> ah
03:29:25 <Saizan> BeelsebobWork: is it?
03:29:30 <BeelsebobWork> let _ = (+) in [1,2] <^ _ ^> [3,4]
03:29:31 <Saizan> let _ = 1 in _
03:29:36 <Saizan> > let _ = 1 in _
03:29:37 <lambdabot>   Pattern syntax in expression context: _
03:29:38 <BeelsebobWork> > let _ = (+) in [1,2] <^ _ ^> [3,4]
03:29:39 <lambdabot>   Not in scope: `<^'Pattern syntax in expression context: _Not in scope: `^>'
03:29:45 <quicksilver> _ is a special pattern
03:29:45 <BeelsebobWork> oh, it's not allowed as a whole name, lame :(
03:29:57 <quicksilver> > let f _ = 1 in f "Hi"
03:29:58 <lambdabot>   1
03:30:01 <pumpkin_> yeah, I figured it would be reserved for pattern matching thingy
03:30:05 <BeelsebobWork> @let a <^ f = f <$> a
03:30:06 <lambdabot>  Defined.
03:30:15 <BeelsebobWork> @let f ^> a = f <*> a
03:30:16 <lambdabot>  Defined.
03:30:49 <BeelsebobWork> > let _l_ = (+) [1,2] <^ _l_ ^> [3,4] -- so cruel
03:30:50 <lambdabot>   <no location info>: parse error on input `;'
03:31:02 <BeelsebobWork> > let _l_ = (+) in [1,2] <^ _l_ ^> [3,4] -- so cruel
03:31:03 <lambdabot>   [4,5,5,6]
03:31:06 <BeelsebobWork> :DDD
03:31:14 <quicksilver> BeelsebobWork: do you do anything to the precedence of <^ ^> ?
03:31:26 * quicksilver supposes he'd like them to have low precedence.
03:31:30 <BeelsebobWork> quicksilver: oh, that's a point, they should be infixl 3 shouldn't they
03:31:35 <BeelsebobWork> or somewhere around there
03:31:37 <pumpkin_> <^.^> might be cute
03:31:46 <BeelsebobWork> that one's infix, so it needs parens
03:31:53 <quicksilver> BeelsebobWork: does it work with two in a row?
03:31:54 <pumpkin_> > (+2) <^ . ^> (*3)
03:31:55 <lambdabot>   <no location info>: parse error on input `.'
03:32:01 <pumpkin_> > (+2) <^ (.) ^> (*3)
03:32:02 <lambdabot>       Overlapping instances for Show ((c -> c) -> c -> c)
03:32:02 <lambdabot>        arising from...
03:32:08 <quicksilver> BeelsebobWork: "a <^(+)^> b <^(+)^> c"
03:32:11 <pumpkin_> boo I don't want to add those parens
03:32:14 <pumpkin_> they ruin my smiley
03:32:16 <BeelsebobWork> hmm, not sure
03:32:21 <quicksilver> BeelsebobWork: off-hand I'm not sure how I'd expect that to parse.
03:32:28 <quicksilver> infix precedence is nasty.
03:32:28 <BeelsebobWork> ditto
03:32:33 <quicksilver> would be nice if it did work.
03:32:45 <BeelsebobWork> > let _l_ = (+) in [1,2] <^ _l_ ^> [3,4] <^ _|_ ^> [5,6]
03:32:46 <lambdabot>   <no location info>: parse error on input `|'
03:32:50 <yitz> Lemmih: I want to try out haskore. just did cabal install haskore. now what?
03:32:55 <BeelsebobWork> > let _l_ = (+) in [1,2] <^ _l_ ^> [3,4] <^ _l_ ^> [5,6]
03:32:56 <lambdabot>   [9,10,10,11,10,11,11,12]
03:33:08 <pumpkin_> think I can let __ be something?
03:33:17 <BeelsebobWork> > let __ = (+) in [1,2] <^ __ ^> [3,4] <^ __ ^> [5,6]
03:33:19 <lambdabot>   [9,10,10,11,10,11,11,12]
03:33:23 <BeelsebobWork> yse, yes you can :)
03:33:26 <pumpkin_> ooh
03:33:30 <pumpkin_> yay, a functional smiley!
03:33:33 <pumpkin_> pardon the lame pun
03:33:41 <BeelsebobWork> well, we had the robotic monkey years ago
03:33:44 <BeelsebobWork> (:[])
03:33:51 <pumpkin_> lol
03:34:01 <BeelsebobWork> now we have applicative pig and small girl too
03:34:08 <yitz> @type ((.).(.))
03:34:09 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:34:11 <BeelsebobWork> <^(++)^> -- applicative pig
03:34:15 <pumpkin_> lol
03:34:34 <BeelsebobWork> quicksilver: does infixl 3 sound about right to you?
03:34:39 <BeelsebobWork> I should really add that to the module
03:34:42 <pumpkin_> <^(oo)^> would that work? or are alpha chars not allowed for infix ops?
03:34:47 <BeelsebobWork> no
03:34:49 <BeelsebobWork> only prefix
03:34:53 <pumpkin_> boo
03:34:54 <yitz> use ..
03:34:56 <BeelsebobWork> but <^ oo ^> works
03:35:04 <pumpkin_> but then you lose the piggyness of it
03:35:07 <pumpkin_> it looks likea flying pig
03:35:08 <BeelsebobWork> you do a bit
03:35:19 <Saizan> you can wrap it in parens anyway
03:35:36 <BeelsebobWork> > let (°°) = (+) in [1,2] <^(°°)^> [3,4]
03:35:38 <lambdabot>   [4,5,5,6]
03:35:40 <BeelsebobWork> :D
03:35:41 <BeelsebobWork> genious
03:35:54 <Saizan> > let oo = (+) in [1,2] <^(oo)^> [3,4]
03:35:55 <lambdabot>   [4,5,5,6]
03:36:27 <BeelsebobWork> > let (••) = (+) in [1,2] <^(••)^> [3,4]
03:36:28 <lambdabot>   <no location info>: lexical error at character '\8226'
03:36:29 <yitz> @type (<^>
03:36:30 <lambdabot> parse error (possibly incorrect indentation)
03:36:31 <BeelsebobWork> awww :(
03:36:32 <yitz> @type (<^)
03:36:34 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
03:36:53 <pumpkin_> stupid irc client
03:36:55 <pumpkin_> wow :P
03:36:57 <pumpkin_> !
03:36:59 <pumpkin_> ultimate pig
03:37:04 <pumpkin_> unicode chars would be awesome
03:37:12 <yitz> @type (^>)
03:37:13 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:37:15 <pumpkin_> we could use combining marks to add small eyes for the pig
03:37:24 <Peaker> @hoogle (a -> b) -> (a,a) -> (b,b)
03:37:24 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
03:37:24 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
03:37:24 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
03:37:38 <Clockwork> Hey, I want the following: calling a function x with the argument a, I want before a is used in x, it be used in another function y, is where needed?
03:37:39 <Saizan> you can use unicode symbols and punctuation
03:37:54 <pumpkin_> not with lambdabot though?
03:38:23 <yitz> @type (***)
03:38:25 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:38:48 <yitz> @type join (***)
03:38:48 <Saizan> uhm, you should be able to, unless someone has reintroduced that bug
03:38:49 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
03:39:01 <yitz> Peaker: ^
03:39:14 <Peaker> yitz: thanks
03:39:39 <Saizan> Clockwork: what do you mean with before?
03:40:16 <Clockwork> something like func_x a = .... I want it to be func_x (func_y a) = ...
03:40:16 <yitz> Clockwork: x . y
03:40:32 <Taejo> join (***) f = f &&& f ?
03:40:48 <yitz> @type (&&&)
03:40:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:41:06 <Taejo> :t ?f &&& ?f
03:41:08 <lambdabot> forall (a :: * -> * -> *) b c'. (?f::a b c', Arrow a) => a b (c', c')
03:41:17 <Saizan> Clockwork: you've to write it like func_x b = let a = func_y b in ... or use where in the same way, yeah
03:41:18 <Taejo> oh, nvm
03:41:30 <Taejo> f *** f
03:41:37 <Taejo> but of course those are the same
03:42:13 <BeelsebobWork> quicksilver: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/InfixApplicative -- now with added infixl indicators :)
03:42:14 <lambdabot> Title: HackageDB: InfixApplicative-1.0.1, http://tinyurl.com/553fov
03:42:23 <yitz> @type \f -> first f &&& second f
03:42:25 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) ((c, b), (b, c))
03:42:50 <Saizan> Clockwork: in ghc-6.10 with ViewPatterns you can write func_x (func_y -> a) = ..., but it's just a syntactical extension
03:43:12 <Clockwork> oh ok :)=
03:44:34 <thoughtpolice> Lemmih: ping?
03:45:03 <Peaker> Okay, my little game thing is behaving totally strange!
03:45:20 <Peaker> very jerky! and no keyboard events are actually coming in
03:45:29 <quicksilver> BeelsebobWork: good stuff :)
03:45:54 <quicksilver> BeelsebobWork: I wonder why hackage hasn't auto-generated the haddock?
03:47:01 <Clockwork> How can I use wildcards _ in guards?
03:47:22 <opqdonut> err how would you want to do that?
03:47:48 <Clockwork> how or why?
03:47:54 <Saizan> in guards you've to give an expression of type Bool not a pattern, unless you're using PatternGuards
03:48:10 <Clockwork> PatternGuards?
03:48:31 <Saizan> another GHC extension :)
03:49:00 <Saizan> however, maybe you can give us an example of what you want to do?
03:50:26 <Clockwork> mhh, difficult :) ... I want to test a self-defined integer data type if it's a > b
03:50:56 <opqdonut> well why don't you have a custom > predicate?
03:51:03 <opqdonut> or even implement Ord for it
03:51:10 <opqdonut> or are you checking an Ord implementation?
03:51:24 <opqdonut> /implementing
03:55:54 <vegai> the couchdb bindings for instance say that it "encapsulates the IO monad, a persistent HTTP connnection to a CouchDB database and enough information to re-open the connection if it is closed."
03:56:30 <vegai> is there anything magical about this? Should perhaps all TCP servers use the same technique?
03:57:02 <vegai> s/all/some/
03:58:12 <vegai> instance (IO a) => (MyMonad a)   -- just like this?
03:58:33 <quicksilver> that instance doesn't make sense.
03:58:45 <quicksilver> but the general idea of building up a custom monad layered over IO makes plenty of sense, yes.
03:58:54 <quicksilver> lots of other libraries work that way.
03:59:09 * vegai reads about the instance syntax again
04:00:57 <vegai> class (IO a) => MyMonad a?
04:01:39 <vegai> no, IO's not a class.
04:01:39 <Saizan> vegai: what are you trying to express?
04:01:51 <vegai> Saizan: a custom monad that encapsulates IO
04:02:24 <Saizan> then you make your monad an instance of MonadIO, you want to allow any IO
04:02:28 <Saizan> ?type liftIO
04:02:29 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
04:03:17 <Beelsebob> quicksilver: it talkes a little time for it to regen it
04:03:20 <Beelsebob> it's on a timer
04:03:24 <Saizan> the actual definition of the monad is usually given as a transformer
04:03:42 <quicksilver> Beelsebob: ah OK
04:11:15 <hackage> Uploaded to hackage: hprotoc 1.0.1
04:11:15 <hackage> Uploaded to hackage: protocol-buffers-descriptor 1.0.1
04:11:15 <hackage> Uploaded to hackage: protocol-buffers 1.0.1
04:11:15 <hackage> Uploaded to hackage: InfixApplicative 1.0.1
04:14:09 <shapr> hackage bot should also give the user name.
04:42:22 <Peaker> does   eventEither :: R.Event a -> R.Event b -> R.Event (Either a b)   exist? Hoogle thinks not
04:42:57 * shapr boings cheerfully
04:43:00 <shapr> jiihaa!
04:43:02 <Peaker> trivial, but still..
04:43:06 <Beelsebob> fmap Left x `mappend` fmap Right y?
04:43:22 <Peaker> Beelsebob: yeah
04:43:29 <Peaker> Beelsebob: I also use: eventEither_ x y = () <$ eventEither x y
04:44:03 <Beelsebob> () <$ (x `mappend` y)?
04:45:10 <Beelsebob> or mappend `on` (0 <$)
04:45:11 <quicksilver> () <$ x `mappend` () <$ y
04:45:22 <quicksilver> you need to force the types.
04:45:29 <Beelsebob> oh, yeh, good point
04:45:38 <Beelsebob> yours is more general
04:45:51 <Peaker> yeah, eventEither_ wastefully makes an intermediate Either, but I don't think it matters?
04:46:05 <Peaker> (laziness and all?)
04:46:07 <Beelsebob> Peaker: quicksilver's is of type Event a -> Event b -> Event ()
04:46:15 <Peaker> Beelsebob: my eventEither_ is too
04:46:20 <Beelsebob> oh, neither it is
04:46:23 <Beelsebob> mine is Event a -> Event a -> Event () though
04:46:49 <Peaker> eventEither_ x y = () <$ eventEither x y  -- so it just modifies the returntype of (Event a -> Event b -> Event (Either a b))
04:46:59 <Beelsebob> yeh
04:47:09 <Beelsebob> I'd still rather use quicksilver's definition though
04:47:39 <Peaker> Does the intermediate either have a cost, though?
04:47:46 <quicksilver> Peaker: laziness is not deforestation
04:47:49 <Beelsebob> yes
04:48:00 <quicksilver> you might hope GHC can remove the intermediate structure entirely
04:48:04 <quicksilver> but I suspect it will not.
04:48:17 <Peaker> quicksilver: The intermediate structure is just a thunk that never runs, isn't it?
04:48:18 <quicksilver> you can definitely hope that a future version might be able to ;)
04:48:26 <gio123> does somebody knows software to reduce size of scaned pdf document?
04:48:51 <quicksilver> gio123: if you keep asking questions which are nothing to do with haskell, you will be removed from the channel.
04:49:18 <gio123> ok
04:49:26 <gio123> sorry
04:49:26 <quicksilver> Peaker: well it's still a closure which gets "rippled through"
04:49:38 <quicksilver> Peaker: even if the 'Left' constructor never actually gets acuated
04:49:38 <Peaker> quicksilver: what are the costs of such a closure?
04:49:39 <quicksilver> gio123: np.
04:49:53 <quicksilver> Peaker: a pointer deref and a jump, I think
04:49:58 <quicksilver> not very high.
04:50:08 <Beelsebob> it doesn't even need to deref does it?
04:50:12 <Peaker> quicksilver: those are the costs if it does get run, aren't they?
04:50:15 <Beelsebob> it's just replacing the whole structure
04:50:50 <quicksilver> Beelsebob: I was talking about the one that goes through Either
04:50:59 <quicksilver> Peaker: yes
04:51:08 <Beelsebob> yeh, I know -- but it never actually evaluates the Left
04:51:10 <Peaker> why is it "Data".Monoid vs. "Control".Applicative?
04:51:12 <Beelsebob> so it doesn't do the deref and jump
04:51:27 <Beelsebob> Peaker: because Control is a silly library tree
04:51:36 <Beelsebob> all the things in there are about Data
04:51:38 <Peaker> ah
04:51:52 <Beelsebob> but there's a kind of intuitive division which people seem to use
04:51:56 <Beelsebob> I'm not sure it's well defined at all
04:52:08 <Peaker> how do I know the infix precedence of `mappend` ?
04:52:09 <quicksilver> Data.Monoid is the odd one
04:52:23 <quicksilver> Data.Foo is normally a module which defines a 'data' type.
04:52:45 <Peaker> (<$) is infixl 4.. What's `mappend` ?
04:52:52 <Beelsebob> Peaker: IIRC prefix functions are always lowest precidence when used infix
04:52:57 <Beelsebob> let's find out...
04:53:09 <Beelsebob> > 2 + 5 `elem` [6,7,8]
04:53:10 <lambdabot>   True
04:53:16 <Peaker> @type \x y -> () <$ x `mappend` () <$ y
04:53:17 <lambdabot>     Couldn't match expected type `f b' against inferred type `()'
04:53:17 <lambdabot>     In the second argument of `(<$)', namely `x `mappend` ()'
04:53:17 <lambdabot>     In the first argument of `(<$)', namely `() <$ x `mappend` ()'
04:53:28 <Peaker> Beelsebob: I think you can defined the infix precedence of some arbitrary `func`
04:53:34 <Beelsebob> you can?
04:53:34 <Beelsebob> oh
04:53:35 <quicksilver> I think Peaker is right.
04:53:39 <Peaker> @type \x y -> (() <$ x) `mappend` (() <$ y)
04:53:40 <lambdabot> forall (f :: * -> *) b b1. (Monoid (f ()), Functor f) => f b -> f b1 -> f ()
04:53:42 <quicksilver> but, I don't believe they have, for mappend.
04:53:43 <Beelsebob> blimeh, that confuses my mental model
04:53:45 <quicksilver> so it has the default precedence.
04:53:48 <cjs> So, if I want to both read messages from a socket, and generate a message every 10 ms regardless of whether anything's come in on the socket or not, what's a nice way to do this in ghc?
04:54:08 <Peaker> quicksilver: so the default precedence must be higher than <$ which is infixl 4
04:54:18 <Peaker> quicksilver: it binds stronger, it seems
04:54:22 <Beelsebob> cjs: create a behavior modified by the event coming in the socket, and snapshot it every 10ms
04:54:24 <quicksilver> Peaker: hmm. maybe default was 5.
04:54:34 <Zao> Have a TChan, stick messages from the socket into it and pass the same TChan to a thread that just has a sleep and stuffs things into the chan.
04:54:45 * Beelsebob goes to work
04:55:13 <Twey> What exactly does a TChan do that a Chan doesn't?
04:55:18 <Twey> Selection?
04:55:24 <Twey> orElse and the like?
04:55:40 <quicksilver> "Any operator lacking a fixity declaration is assumed to be infixl 9"
04:55:46 <quicksilver> Peaker: there must be an explicit choice
04:55:56 <quicksilver> Peaker: it's probaly '5' by analogy with ++
04:56:02 <Peaker> quicksilver, Beelsebob: I defined: traceId prefix x = trace (prefix ++ (show x)) x       and I am trying to show my behavior sampling via:  traceIf <$> someBehavior    -- should that work?
04:56:07 <Peaker> s/traceIf/traceId
04:56:09 <Zao> Twey: Chans are IO-based while TChan are STM?
04:56:10 <quicksilver> Twey: consistent reading from two channels at once
04:56:24 <quicksilver> Twey: (and one channel and one tvar, and all the other permutations)
04:57:08 <quicksilver> Peaker: 3 parameters? 2 parameters?
04:57:23 <Peaker> quicksilver: oops,  traceId "prefix" <$> someBehavior
04:57:51 <quicksilver> I did something like that
04:57:53 <quicksilver> (it worked)
04:58:28 <Peaker> I don't use the behavior's content/value so it doesn't work, oy
04:58:34 <quicksilver> well yes.
04:58:35 <cjs> Beelsebob: er....is that going to work if I'd like to deal with messages coming in in less than a millisecond after I receive them?
04:58:41 <quicksilver> all you're doing is moinitoring evaluations
04:58:49 <Peaker> yeah
04:58:53 <quicksilver> if you don't evaluate anything...
04:59:14 <Peaker> is there any way to trace the behavior sampling itself, rather than the value being sampled?
04:59:19 <quicksilver> cjs: putting reactive to one side, have one thread listening on the socket and a second thread using thread-delay
04:59:40 <quicksilver> cjs: be aware that the GHC RTS doesn't make strong guarantees about how long threadDelay lasts for though.
05:01:04 <cjs> Yeah, that's what I was kinda reckoning. Then have them both shove messages down a channel, and let the thread on the other end just block on that?
05:01:21 <quicksilver> that is certainly one sensible approach.
05:01:38 <Twey> quicksilver: Aha
05:01:43 <cjs> So long as threadDelay is no worse than the standard OS sleep primitives, I'm not worried about that. This isn't real-time, it just needs to be reasonably quick to respond.
05:02:08 <quicksilver> yes. It shouldn't be worse.
05:02:35 <cjs> Probably better, during moments there's heavy activity on the socket.
05:02:49 <cjs> (Assuming I don't develop another space leak and drive myself into swap again. :-))
05:03:31 <Peaker> is there any way to debug a Behavior/Event by just having an IO () that prints its values/samples?
05:04:17 <cjs> How about System.Timeout?
05:04:27 <Peaker> e.g:     debugNextEvent :: Event a -> IO a      or debugPrintEvent :: Event a -> IO ()  ?
05:05:09 <cjs> That would be easier, in my case. Does it work well, I wonder? I'm not calling any FFI stuff.
05:05:55 <cjs> Oh, unless Data.Binary is....
05:06:11 <Peaker> I wish I knew how to debug my broken Reactive thing :(
05:07:00 <Peaker> oh I have utext!
05:07:11 <cjs> Gotta run; leave me a message with lambdabot if anybody has any thoughts.
05:14:40 <quicksilver> Peaker: my reactive protoframework is supposed to allow you to attach a Event (IO ()) which you want to be always executed by the main event pump
05:14:51 <quicksilver> Peaker: I would imagine Reactive has something similar but I don't know where to look
05:17:00 <Peaker> quicksilver: ok, thanks
05:17:55 * byorgey waves good morning
05:21:58 * mlesniak looks at his clock and waves back, irritated ;)
05:22:01 <ka> Hi, could somebody please explain what an operator section is?  (Not sure if that is the right name, they often look like this: (*2) )
05:22:43 <quicksilver> ka: it's a partially applied operator
05:22:49 <quicksilver> ka: the right-hand-argument is already chosen
05:22:56 <quicksilver> it's waiting for a left-hand-one.
05:23:00 <quicksilver> (and yes, section is the right name)
05:23:05 <quicksilver> > (*2) 5
05:23:06 <lambdabot>   10
05:23:14 <ka> I see.. thank you
05:23:21 <ka> > (2*) 5 -- just testing
05:23:22 <lambdabot>   10
05:23:26 <ka> Wow :)
05:23:36 <kuribas> Does anyone know of a language for numerical computations like octave, but in a more functional style?
05:23:53 <byorgey> ka: of course, (2*) and (*2) are the same since * is commutative, but in general they might not be the same.
05:24:00 <byorgey> > (5/) 2
05:24:02 <lambdabot>   2.5
05:24:06 <byorgey> > (/5) 2
05:24:07 <lambdabot>   0.4
05:24:15 <ka> byorgey: I was just checking that the section would be parsed to allow either a left or right argument
05:24:19 <byorgey> sure
05:24:37 <camio> > (1-) 1
05:24:38 <lambdabot>   0
05:24:41 <camio> > (-1) 1
05:24:42 <lambdabot>       No instance for (Num (t -> a))
05:24:43 <lambdabot>        arising from a use of `negate' at...
05:24:46 <camio> :)
05:24:53 <BeelsebobWork> ka: you can also do this with prefix functions used in infix...
05:24:53 <BeelsebobWork> > (`elem` [5,7,9]) 5
05:24:54 <byorgey> argh, horrible syntax corner case! =P
05:24:54 <lambdabot>   True
05:25:22 <byorgey> camio: there's a reason I used / and not - ...  ;)
05:25:29 <BeelsebobWork> heh
05:25:42 <BeelsebobWork> > (`subtract` 5) 10
05:25:43 <lambdabot>   -5
05:25:45 <ka> I see functions like this:  functionName :: (Int -> Int) -> [Int]     functionName = map otherFunction
05:25:50 <ka> Is this partial application?
05:26:05 <BeelsebobWork> ka: yes
05:26:09 <BeelsebobWork> map expects 2 arguments
05:26:16 <BeelsebobWork> a function, and a list
05:26:22 <BeelsebobWork> there it's given only the function
05:26:28 <BeelsebobWork> (and hence returns a function from list to list)
05:26:51 <BeelsebobWork> > let f = map (+2) in f [1,2,3] -- two instances of partial application
05:26:52 <lambdabot>   [3,4,5]
05:27:08 <BeelsebobWork> @type map (+2)
05:27:09 <lambdabot> forall a. (Num a) => [a] -> [a]
05:28:02 <Peaker> I think <$> should be infixr, not infixl
05:28:10 <Peaker> (it composes very similarly to . or $ )
05:28:11 <lilac> > subtract 10 5
05:28:13 <lambdabot>   -5
05:28:24 <lilac> hmm. i guess that's not meant for infix?
05:28:46 <ka> BeelsebobWork: sorry, I've not seen that particular syntax before: what is the 'in' and why is f repeated?
05:28:49 <SamB_XP> Peaker: um, isn't it $ that should be the other way ?
05:29:39 <BeelsebobWork> ka: let ... in ... is a general pattern for creating a function or constant for local use
05:30:00 <BeelsebobWork> let f x = x + 5 in f 10 -- this creates a function called f, which may only be used within the "in" section
05:30:15 <BeelsebobWork> (and is applied to 10 in this case)
05:30:17 <BONUS> why would you want $ to be infixl?
05:30:24 <BeelsebobWork> > let f x = x + 5 in f 10
05:30:26 <lambdabot>   15
05:30:47 <SamB_XP> BONUS: ever tried using $! with a multi-paramter function ?
05:31:07 <BONUS> haha, no
05:31:09 <BONUS> i see
05:31:31 <BONUS> i guess some people like doing f $ g $ x
05:31:42 <BONUS> but those people shouldnt be doing that
05:31:45 <SamB_XP> (obviously, $ and $! should have the same fixity and precedence ;-)
05:31:58 <BeelsebobWork> they can do it if they like BONUS... it just may backfire on them when they want to refactor
05:32:22 <SamB_XP> Beelsebob: or when we fix the fixity of $ and $! ;-P
05:32:35 <lilac> it depends what they want to refactor though; it's easier to pull out g $ x and harder to pull out f . g
05:32:36 <BeelsebobWork> no, I like the fixity of $
05:33:01 <SamB_XP> Beelsebob: I guess you don't use $! either ?
05:33:26 <BeelsebobWork> nope, I don't
05:33:45 <SamB_XP> well, try it sometime and maybe you'll see what I mean ;-P
05:34:05 <SamB_XP> (that is, on some non-last parameter ;-P)
05:36:01 <BONUS> maybe $! should be renamed to something else?
05:36:16 <BONUS> because people mainly use $ because of its low fixity and right associativity
05:36:26 <int-e> nah, the name is sensible.
05:36:26 <BONUS> but $! is used mostly for strict application
05:36:27 <SamB_XP> BONUS: low precedence
05:36:42 <int-e> 'like $ but strict in the following argument'
05:37:02 <SamB_XP> yes, the name is sensible
05:37:06 <Axman6> SamB_XP: what's wrong with $ ?
05:37:08 <SamB_XP> but it isn't very useful as-is
05:37:11 * int-e agrees that the associativity is not optimal though
05:37:23 <SamB_XP> I'd like to be able to write this:
05:37:29 <SamB_XP> f $! x $ y
05:37:33 <SamB_XP> but instead must write this
05:37:45 <SamB_XP> (f $! x) y
05:37:50 <int-e> Axman6: try ... f $ 1 $! 3 $ 4 -- this would apply the second argument of f strictly if the associativity were reversed.
05:38:10 <SamB_XP> and it gets worse the more $!s you want in a call
05:38:11 <Peaker> glut seems to be reporting key up events before each keydown in the typematic repeat :-(
05:38:24 <quicksilver> yup.
05:38:34 <quicksilver> glut is pretty weird w.r.t keyrepeat
05:38:38 <Peaker> SamB_XP: Ok, <$> composes more like (.) than like $ then :)
05:38:52 <Peaker> quicksilver: so I can't tell when its pressed continuously?
05:39:21 <quicksilver> Peaker: it kind of inherits the kind-of broken xlib event model in this respect.
05:39:29 <Peaker> SamB_XP: I think in almost every instance I used <$>, I needed infixr
05:39:29 <SamB_XP> isn't it good for it to report key-up events before each keydown in an auto-repeat ?
05:39:44 <int-e> Peaker: <$> is left associative. (.) is right associative. so are ($) and ($!).
05:39:44 <Peaker> SamB_XP: nope, if you want that, why are you looking at key-up at all?
05:39:50 <Axman6> so what's $!'s fixity and stuff now?
05:39:59 <Peaker> int-e: yeah, I am trying to understand why <$> is left associative, I think it should be right
05:40:08 <Peaker> maybe I need to define my own fmap that is r-assoc
05:40:10 <int-e> > (+) <$> [1..3] <*> [2..5]
05:40:12 <lambdabot>   [3,4,5,6,4,5,6,7,5,6,7,8]
05:40:14 <SamB_XP> well ... it might confuse programs to have unbalanced key-up/key-down, mightn't it ?
05:40:23 <quicksilver> at one level of abstraction, you shouldn't be able to distinguish between a key repeat and a repeated key
05:40:27 <Peaker> int-e: that can be done with precedence differences?
05:40:31 <quicksilver> e.g. a word-processor shuoldnot distinguish.
05:40:48 <SamB_XP> yeah
05:40:51 <quicksilver> that's the level of abstraction that APi is defined at.
05:40:58 <int-e> Peaker: you may be right, I don't think I've ever used more than one <$> at once
05:41:00 <quicksilver> Annoying if it's not the right one for you (games)
05:41:10 <quicksilver> <$> is true associative
05:41:20 <Peaker> quicksilver: "true associative"?
05:41:29 <SamB_XP> you'd think they'd have realized which kind of app is most commonly using GL
05:41:31 <quicksilver> f <$> (a <$> b) = (f <$> a) <$> b
05:41:39 <quicksilver> SamB_XP: indeed ;)
05:41:53 <quicksilver> SamB_XP: it probably inherit from some SGI api, I suspect ;)
05:42:00 <int-e> @type ?f <$> (?a <$> ?b)
05:42:01 <lambdabot> forall a b a1 (f :: * -> *). (Functor f, ?b::f a1, ?a::a1 -> a, ?f::a -> b) => f b
05:42:09 <SamB_XP> what, SGI's emacs used GL ?
05:42:46 <int-e> oh wait, that's the (<$>) = fmap = (.) idea.
05:43:04 <quicksilver> int-e: yes. The interesting observation about that is that (.) remains associative
05:43:22 <quicksilver> of course, any <$> except the rightmost is necessarily a reader-fmap
05:43:26 <quicksilver> (if you read from the left)
05:43:38 <quicksilver> (if you read from the right, they're all <$> in the right-hand-side function)
05:44:14 <quicksilver> naturality of functiosn makes them equivalent
05:44:17 <quicksilver> functors.
05:44:26 <SamB_XP> oh, doesn't it matter which way (<$>) associates anyway ?
05:44:37 <SamB_XP> makes sense I guess
05:44:46 <quicksilver> yes. It ends up getting instantiated at different types
05:44:51 <quicksilver> but giving the same result.
05:44:59 <quicksilver> taht's a pretty weird kind of associativity.
05:45:18 <SamB_XP> not really
05:45:33 <SamB_XP> (.) is the same way after all ;-P
05:46:17 <quicksilver> that's just polymorphism
05:46:20 <int-e> fmap a . fmap b = fmap (a . b) means (<$>) is associative.
05:46:24 <int-e> nice :)
05:46:24 <idnar> @type ?f <$> (?a <$> ?b)
05:46:25 <quicksilver> this is adhoc polymorphism
05:46:25 <lambdabot> forall a b a1 (f :: * -> *). (Functor f, ?b::f a1, ?a::a1 -> a, ?f::a -> b) => f b
05:46:34 <quicksilver> which feels slightly weirder.
05:46:54 <idnar> @type (?f <$> ?a) <$> ?b
05:46:55 <lambdabot> forall a b a1 (f :: * -> *). (Functor f, ?b::f a1, ?a::a1 -> a, ?f::a -> b) => f b
05:46:59 <SamB_XP> quicksilver: true
05:47:08 <SamB_XP> it's probably a bit harder to prove ...
05:47:28 <idnar> heh
05:47:35 <int-e> fmap a (fmap b c) = fmap (a . b) c. a <$> (b <$> c) = (a . b) <$> c. Now note that a . b = a <$> b.
06:04:42 <earthy> hm. dedekind cuts are 150 years old. yay for real numbers. :)
06:05:48 <quicksilver> the real numbers go back earlier than that, don't they?
06:05:56 <quicksilver> it's just attempts to formalise them were not successful
06:08:47 <om-nom-nominolo> @pl \arg1 arg2 -> (m1 arg1 arg2 x >>= \r -> m2 r arg1 arg2)
06:08:47 <lambdabot> ap (ap . ((>>=) .) . flip flip x . m1) (flip . flip m2)
06:09:15 <om-nom-nominolo> @pl \arg1 arg2 -> (m1 x arg1 arg2 >>= \r -> m2 r arg1 arg2)
06:09:15 <lambdabot> ap (ap . ((>>=) .) . m1 x) (flip . flip m2)
06:09:49 <om-nom-nominolo> @src (>>=) ((->)r)
06:09:49 <lambdabot> Source not found. Do you think like you type?
06:10:41 <byorgey> looks like nominolo has the munchies?
06:16:11 <yitz> dedekind cuts are older than cauchy sequences?
06:19:02 <yitz> no of course not, cauchy lived a generation before dedekind
06:19:33 <Twey> Feh
06:19:43 <Twey> Web-dev newbies *grumble*
06:19:47 <Twey> 'I have to send secure data through network which resides on image.'
06:21:35 <earthy> http://www-groups.dcs.st-and.ac.uk/~history/HistTopics/Real_numbers_2.html
06:24:34 <Fallen_Demon> >help
06:25:16 <Fallen_Demon> > 1+2+3
06:25:17 <lambdabot>   6
06:25:26 <Fallen_Demon> > help
06:25:27 <lambdabot>   Not in scope: `help'
06:25:37 <Fallen_Demon> > list
06:25:38 <lambdabot>   Not in scope: `list'
06:26:27 <yitz> earthy: an interesting history
06:26:48 <yitz> earthy: so cauchy didn't realize that he had a definition of the reals
06:27:28 <yitz> earthy: of course - those who considered arbitrary decimal fractions hundreds of years earlier also had a definition and didn't realize it.
06:27:46 <Fallen_Demon> I feel dirty :(
06:28:00 <byorgey> @help
06:28:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:28:03 <Fallen_Demon> I'm using a 3-symbol look ahead to read a mathematical expression
06:28:13 <rog_> @pl \ d -> return (I.getcon d :: Double)
06:28:13 <lambdabot> return . (:: Double) . I.getcon
06:28:23 <rog_> that's a syntax error, isn't it?
06:28:28 <byorgey> rog_: indeed
06:28:40 <byorgey> I guess @pl doesn't know about type annotations
06:28:48 <rog_> so it seems
06:29:15 <rog_> *is* there a nice way of expressing that, point-free?
06:29:23 <yitz> @pl \x -> x :: Int
06:29:23 <lambdabot> (:: Int)
06:29:41 <byorgey> > (::Int) 3
06:29:43 <lambdabot>   <no location info>: parse error on input `::'
06:29:44 <Clockwork> Hey, I want to code a bracket test, for instance { [ ( ) ] } = true and (()) = true, but [ ( ] ) = false, any ideas? :)
06:30:14 <byorgey> rog_: sure, but you'd have to put a type annotation on getcon instead of  getcon d
06:30:15 <yitz> Clockwork: what have you got so far?
06:30:35 <byorgey> like  return . (I.getcon :: foo -> Double)   (whatever foo is supposed to be)
06:30:45 <rog_> byorgey: of course
06:31:07 <quicksilver> rog_: define "asDouble :: Double -> Double; asDouble = id"
06:31:11 <Clockwork> yitz: http://hpaste.org/12319
06:31:21 <quicksilver> rog_: then return . asDouble . I.getcon
06:31:36 <Clockwork> I tried to solve it with pattern matching and then check the integer
06:31:48 <Clockwork> but this is very little for the start
06:32:08 <yitz> Clockwork: how about 1 and -1 instead of 1 and 2?
06:32:49 <rog_> quicksilver: maybe that's what (:: Double) should parse as...
06:32:57 <Clockwork> oh nice, true :)
06:33:40 <yitz> Clockwork: then, after you fill out the rest of the details, your final answer can be: testBool = (== 0) . test
06:33:48 <rog_> i.e. (:: Type) turns into (id :: Type -> Type)
06:33:53 <rog_> hmm. or maybe not.
06:34:28 <Fallen_Demon> "The Computer Misuse Act has also been changed to make it an offence to make, adapt, supply or offer to supply any article which is "likely to be used to commit, or to assist in the commission of, [a hacking or unauthorised modification or DoS] offence". It is also an offence to supply an article "believing that it is likely" to be used to commit such an offence."
06:34:44 <pythonist> I'd like to include an Exception-based error control mechanism in my code, with custom exceptions. What's the best way to do it?
06:34:50 <Clockwork> so I have to check the following char of xs, but there are other cases is it possible to use double guards?
06:34:55 <pythonist> I'd stick to Control.Exception...
06:35:01 <Fallen_Demon> That law is stopping a guy on another channel I frequent from distributing his dissertation
06:36:20 <quicksilver> pythonist: the best way is likely to be ErrorT
06:37:26 <byorgey> Clockwork: just use &&
06:37:37 <byorgey> and you can do nested pattern-matching
06:37:39 <pythonist> quicksilver: Why not Control.Exception?
06:37:50 <quicksilver> pythonist: because IO exceptions are necessarily clunky.
06:37:55 <Clockwork> any example?
06:38:06 <quicksilver> an exception monad like ErrorT is usable from pure code as well as IO
06:38:09 <byorgey> so you could do something like   test (x:y:xs) | x == '(' && y == '%' = ...
06:38:17 <byorgey> Clockwork: is that what you were asking?
06:38:51 <Clockwork> yeah
06:38:55 <Clockwork> that's good! thanks
06:38:58 <pythonist> quicksilver: I've never used exception so far, and I've read that there are so many options in haskell... so I'm a bit confused and don't want to go wrong...
06:39:18 <quicksilver> pythonist: There are indeed many options. I have given you my opinion, no doubt others will differ :)
06:39:29 * yitz agrees with quicksilver 
06:39:35 <quicksilver> I prefer the ErrorT approach because it can be used equally well in pure code as IO code
06:39:42 <pythonist> quicksilver: of course :D
06:40:02 <quicksilver> I recall a round up of the choices somewhere (on the wiki perhaps?)
06:40:11 <quicksilver> but I don't recall it being insightful
06:40:13 <quicksilver> just descriptive.
06:40:16 <pythonist> quicksilver: What about dynamic exceptions?
06:40:27 <pythonist> quicksilver: It was a blog article...
06:40:29 <byorgey> I should point out that if you do want to use exceptions, ghc 6.10.1 includes a new extensible exception framework.
06:40:38 <pythonist> quicksilver: something like "8 ways to reporting errors in Haskell"...
06:40:38 <quicksilver> well if you're going to use exception, you certainly want to use dynamic ones, or the 6.10 extensible ones
06:40:42 <byorgey> with that said, I also agree with quicksilver =)
06:40:47 <quicksilver> \o/
06:41:09 <pythonist> quicksilver: extensible ones? Any pointer?
06:41:40 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
06:41:42 <lambdabot> Title: Control.Exception, http://tinyurl.com/sqmlj
06:41:46 <quicksilver> but the proper docs are in the paper
06:41:49 <quicksilver> (linked from that page)
06:42:15 <plogYy> anyone knows whether the haskell wikibook is available for download in PDF or not?
06:44:16 <ka> I'm reading a book and it's saying something about in a comparison you'd have to use x ==Bool y, rather than just x == y
06:44:24 <ka> Why is this?  When I put that through hugs it generated an error..
06:44:35 <ka> (This is with boolean values)
06:46:20 <quicksilver> sounds like it's just trying to make a point
06:46:26 <quicksilver> ==Bool is not haskell syntax
06:46:36 <quicksilver> but they're probably pointing out that (==) is not a single function
06:46:44 <quicksilver> but a type-indexed family of functions
06:47:25 <Clockwork> byorgey: I tried your pattern matching, but there is  the case I have just one element, for instance "("
06:47:36 <Clockwork> then the compiler complain about the x:y:xs
06:47:47 <sw17ch> your pattern match fails
06:48:06 <sw17ch> (which, if i read farther back, is what you alrady said)
06:48:41 <Clockwork> oh I excluded it with test [_] = False , wildcards ftw :)
06:49:00 <lispy> dons: it was commercial fortran...but sometimes I feel like I wrote cobol
06:53:02 <andre_away> Hi folks..... Somebody could help me, please?
06:53:30 <andre_> Hi folks..... Somebody could help me, please?
06:53:34 <andre_> Please, I would like a help in haskell programming, because I have with following question:
06:53:35 <andre_> I need to create a list of strings, like as a graph.
06:53:38 <sw17ch> andre_, what's your question
06:53:45 <andre_> See:
06:54:08 <andre_> I have this list
06:54:09 <andre_> nitiaList = [ ("BSB,"SSA"),
06:54:11 <andre_>                    ("CNF","SSA"),
06:54:12 <andre_>                    ("CNF","GIG"),
06:54:14 <andre_>                    ("CNF","GRU"),
06:54:15 <andre_>                    ("GIG","CNF"),
06:54:17 <andre_>                    ("GIG","GRU"),
06:54:18 <andre_>                    ("GRU","BSB"),
06:54:20 <andre_>                    ("GRU","GIG"),
06:54:21 <andre_>                    ("GRU","CNF"),
06:54:23 <andre_>                    ("SSA","CNF") ]
06:54:27 <sw17ch> andre_, woaw woa wao
06:54:31 <sw17ch> hpaste.org/new
06:54:37 <andre_> With this list above, I need to create a function that returns a path with max number of links:
06:54:39 <andre_> example:
06:54:45 <sw17ch> andre_, paste it
06:54:49 <sw17ch> but not on the channel
06:54:56 <sw17ch> @where hpaste
06:54:56 <lambdabot> http://hpaste.org/
06:55:12 <andre_> ho ok thanks
06:55:14 <sw17ch> put your code there, and then give hte link to the channel
06:55:45 <int-e> what happened to the hpaste announcer anyway?
06:56:08 <lispy> int-e: it was indicted with cheney
06:56:21 <lispy> I think I misspelled that horribly
06:56:36 <lispy> oh maybe not
06:56:50 <andre_> HELP => http://hpaste.org/12320
06:56:52 <sw17ch> no, you're fine
06:57:25 <sw17ch> andre_, I assume this is homework :P
06:57:56 <lispy> sure looks like homework
06:58:42 <int-e> what about BSB -> SSA -> CNF -> SSA -> CNF -> ...?
06:59:30 <sw17ch> I've found that representing a descreet value as a string is something I rarely do in Haskell any more...
06:59:39 <andre_> sorry, I'm a haskell begginer
06:59:40 <sw17ch> That would quickly become a data type with a read/show instance
06:59:46 <lispy> sw17ch: right
06:59:53 <sw17ch> andre_, it's alright, we all were at some point
07:00:04 <sw17ch> andre_, how would you do this problem in C?
07:00:21 <lispy> or java...
07:00:38 <andre_> maybe with array pointers
07:00:55 * sw17ch is honestly a little rough on his graph theory...
07:01:14 <sw17ch> andre_, but what you have ther is a list of edges, correct?
07:01:19 <andre_> yes with graph
07:01:44 <sw17ch> and you're looking for the list of edges which comprise the longest span in the graph?
07:02:00 <plogYy> anyone has the haskell wikibook in pdf?
07:02:27 <sw17ch> andre_, also, is this a directed graph?
07:02:34 <sw17ch> or a bigraph
07:02:57 <andre_> yes, it's edges
07:03:10 <sw17ch> andre_, but, are they directional edges?
07:03:18 <andre_> but I have that to do using list
07:03:33 <sw17ch> well, i'm going to assume they are directional...
07:03:53 <andre_> yes, are directional
07:04:50 <sw17ch> andre_, what algorithm would you use to solve this problem?
07:05:39 * lispy mumbles about adjacency maps
07:05:45 <andre_> this is issue, I don't know what use!
07:05:57 <lispy> :t lookup
07:05:58 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
07:06:18 <sw17ch> andre_, you want the 'lookup' function lispy just mentioned
07:06:23 <Clockwork> Is there a function for bool->string ?
07:06:36 <mapreduce> > show true
07:06:37 <lambdabot>   Not in scope: `true'
07:06:38 <Clockwork> prelude-function
07:06:41 <mapreduce> > show True
07:06:41 <lispy> > lookup "BSB" [("BSB", "SSA")]
07:06:43 <lambdabot>   "True"
07:06:43 <lambdabot>   Just "SSA"
07:06:51 <mapreduce> Yes, there is a function for bool->string
07:07:04 <lispy> ?hoogle Bool -> String
07:07:04 <lambdabot> Data.Fixed showFixed :: HasResolution a => Bool -> Fixed a -> String
07:07:04 <lambdabot> Distribution.Text display :: Text a => a -> String
07:07:04 <lambdabot> Prelude show :: Show a => a -> String
07:07:14 <Clockwork> > 5+5
07:07:15 <lambdabot>   10
07:07:24 <Clockwork> > let a = 1
07:07:25 <lambdabot>   <no location info>: parse error on input `;'
07:07:35 <mapreduce> > let a = 1 in 2 + a
07:07:36 <lambdabot>   3
07:07:39 <lispy> sw17ch: I think lookup will do the wrong thing
07:07:50 <int-e> > [b | (a, b) <- [("BSB", "SSA"), ("BSB", "???")], a == "BSB"]
07:07:52 <lambdabot>   ["SSA","???"]
07:07:57 <lispy> > lookup "BSB" [("BSB", "SSA"), ("BSB", "hah, you'll never find me here"]
07:07:58 <lambdabot>   <no location info>: parse error on input `]'
07:08:02 <Clockwork> > cycle [1,2,3]
07:08:03 <lispy> > lookup "BSB" [("BSB", "SSA"), ("BSB", "hah, you'll never find me here")]
07:08:04 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
07:08:04 <lambdabot>   Just "SSA"
07:08:14 <int-e> love list comprehension. ;)
07:08:22 <sw17ch> lispy, yeah, you're right
07:08:45 <sw17ch> andre_, do you have to use those strings?
07:08:48 <int-e> @hoogle [(a,c)] -> a -> [c]
07:08:49 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
07:08:49 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
07:08:49 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
07:08:53 <sw17ch> or can you encode them as something else
07:08:59 <int-e> lambdabot: I'll take that as a no.
07:09:04 <sw17ch> (not that i should be getting this deep with a noobie)
07:09:09 <andre_> yes, I do.
07:09:16 <sw17ch> alright
07:10:37 <Clockwork> > cycle [1..]
07:10:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:10:40 <hugo__> im having problems with happs
07:10:47 <hugo__> http://hpaste.org/12321
07:10:47 <lispy> this code looks like it will be used in an interative deeping search
07:10:51 <lispy> deepening*
07:10:52 <hugo__> can someone help me please ?
07:11:04 <lispy> halp with happs!
07:11:21 <lispy> hugo__: try ghc --make Main.hs
07:11:35 <lispy> hugo__: better yet, use something like cabal
07:12:07 <lispy> ?src cycle
07:12:07 <lambdabot> cycle [] = undefined
07:12:08 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
07:12:14 <lispy> > cycle []
07:12:15 <lambdabot>   * Exception: Prelude.cycle: empty list
07:12:27 * lispy ponders the meaning of "cycle []"
07:15:15 * sw17ch tries to remember the graph theory section from his algorithms course
07:15:30 <sw17ch> especially since i need to do a lot of this later...
07:16:16 <lispy> sw17ch: it doesn't really strike me as a graph theory intense problem (tho, I could be wrong asI'm not an expert)
07:16:33 <lispy> it seems like you just list the different path options up to the given length
07:16:40 <sw17ch> lispy: i just can't remember if this is one of those OMG HARD problems or a slightly tedious one
07:16:46 <Clockwork> Is it possible to use double guards? a guard nested into a guard?
07:17:02 <lispy> Clockwork: what would it look like?
07:17:22 <Clockwork> | |
07:18:57 <andre_> yep lipsy, (it seems like you just list the different path options up to the given length)
07:19:48 <lispy> > let f n | n > 0 = 10 | n < 0 = -10 | otherwise = 100 in f 1000
07:19:50 <lambdabot>   10
07:19:51 <lispy> Clockwork: like that?
07:20:01 <Clockwork> yep
07:20:07 <lispy> Clockwork: though usually peopel put each new | on a line by iteslf
07:20:15 <lispy> f n | n > 0 = 10
07:20:22 <lispy>    | n < 0 = -10
07:20:24 <lispy> that sort of thing
07:20:33 <Clockwork> ok
07:20:34 <lispy> (not quite lined up in my example though)
07:21:06 <quicksilver> sw17ch: well it's pretty hard, yes.
07:21:19 <quicksilver> sw17ch: it's O(number of paths), and of course you need to check cycles
07:21:20 <sw17ch> quicksilver, it's not NP though, is it?
07:21:43 <sw17ch> i'm fairly sure it's still in polynomial time, right?
07:21:50 <quicksilver> NP for general graphs, I think
07:22:06 <quicksilver> "number of paths" is pretty huge for sufficiently well connected general graphs.
07:22:20 <lispy> quicksilver: but, this case, the path length is bounded
07:22:31 <quicksilver> in all concrete cases path length is bounded ;)
07:22:31 <sw17ch> dang... i was starting to think you'd have to check each edge multiple times... but yeah, you do need to check each combination here, don't you
07:24:25 <lispy> I think hackage needs to be rebooted
07:24:36 <lispy> It's waaaaaaaaay slow to load pages
07:24:56 <sw17ch> agreed
07:25:20 <quicksilver> run this algorithm on the complete graph N
07:25:28 <quicksilver> and you check all "n!" paths, I think
07:25:32 <quicksilver> so that,s NP.
07:26:23 <BeelsebobWork> quicksilver: http://www.cs.kent.ac.uk/people/rpg/tatd2/tetris.png <-- anygma's tetris variant is getting fairly silly now
07:26:34 <sw17ch> andre_, have you talked about NP problems in your class yet?
07:26:39 <BeelsebobWork> the rotation flows downwards matrix stylee
07:27:20 <quicksilver> BeelsebobWork: heehee ;)
07:27:29 <quicksilver> BeelsebobWork: that's almost a motivation to download GHC 6.10
07:27:33 <BeelsebobWork> it's actually pretty nasty to play
07:27:34 <andre_> sw17ch, no.
07:27:38 <BeelsebobWork> quicksilver: :D
07:29:11 <gwern> BeelsebobWork: why is it nasty? it looks pretty cool
07:29:26 <BeelsebobWork> gwern: not nasty in terms of unpleasurable
07:29:31 <BeelsebobWork> but nasty in terms of fucks with your mind
07:29:41 <BeelsebobWork> it gets really hard to line up pieces
07:29:43 * gwern doesn't follow. it's tetis
07:29:56 <BeelsebobWork> the rotation makes your brain see vertical lines where there are none
07:30:02 <BeelsebobWork> so it gets hard to get pieces above each other
07:30:45 <BeelsebobWork> quicksilver: one thing this experiment did expose is the need for a Monad instance for Behavior
07:31:06 <BeelsebobWork> camio had said you and conal had been talking about some difficulties with it -- don't suppose you could elaporate?
07:31:26 * sw17ch has a meeting, back later
07:33:02 <quicksilver> BeelsebobWork: well, the implementation of Behaviour explicitly knows the 'discontinuities'
07:33:08 <quicksilver> BeelsebobWork: that is, the Reactive parts
07:33:12 <quicksilver> that join together the FunTime parts.
07:33:30 <BeelsebobWork> uhhuh
07:33:34 <quicksilver> BeelsebobWork: when you have Behaviour^2 you have Reactive :. FunTime :. Reactive :. FunTime
07:33:41 <Peaker> Reactive is buggy!
07:33:46 <quicksilver> you want to express that in the form Reactive :. FunTime
07:33:49 <quicksilver> Peaker: go file a bug.
07:34:09 <quicksilver> BeelsebobWork: unfortunately there is no easy way to 'pull' that second reactive through the first funtime.
07:34:19 <BeelsebobWork> hmm, there isn't?
07:34:23 <quicksilver> you have a continuously changing Reactive
07:34:32 <BeelsebobWork> oh, I see
07:34:32 <BeelsebobWork> yes
07:34:34 <quicksilver> at every instant in time (FunTime) it may be totally different.
07:34:37 <quicksilver> it's a pain.
07:34:42 <BeelsebobWork> yeh, that is
07:34:53 <quicksilver> I mean, actually it *won't* be of that form
07:34:54 <BeelsebobWork> it's also however a pain to not have a Monad instance for Behavior
07:35:03 <quicksilver> it can't be if it was built up using the given combinators
07:35:08 <quicksilver> hence, it's a normal-form type problem.
07:35:32 <quicksilver> Reactive :. FunTime :. Reactive :. FunTime is actually a more expressive type than we want
07:35:42 <quicksilver> (and more expressive than we can get, if we just use the exported combinators)
07:36:03 <BeelsebobWork> :/
07:37:15 <BeelsebobWork> how annoying
07:37:24 <BeelsebobWork> because it actually kinda ruins composability of behaviors
07:37:27 <quicksilver> yup.
07:37:38 <quicksilver> if you included explicit Linear + Quadratic Behaviours
07:37:45 <quicksilver> then you could solve it explicitly for them
07:37:52 <quicksilver> sorry, FunTimes, I mean
07:37:56 <quicksilver> more special cases like 'K a'
07:38:28 <BeelsebobWork> you can't create a "spinning taurus" Behavior Geometry3, and a Behavior GameState, and for each tile in the GameState, grab the appropriate spinning taurus
07:38:50 <BeelsebobWork> I had to hack my own TimeT -> Geometry3
07:38:57 <Peaker> quicksilver: I am getting a super-weird symptom, its hard to report a bug
07:39:13 <BeelsebobWork> Peaker: what is the super-wierd symptom
07:39:21 <BeelsebobWork> (based on that description I'm betting on the "join" bug)
07:39:29 <Peaker> BeelsebobWork: firstly, my  atTimes [0,gap..]  ticker seems to tick at very non-regular intervals
07:39:35 <BeelsebobWork> yep
07:39:39 <BeelsebobWork> that'll be the "join" bug
07:39:45 <Peaker> BeelsebobWork: any plans to fix that?
07:39:54 <BeelsebobWork> yeh, I believe conal is pretty close to a fix on that one
07:40:09 <BeelsebobWork> it's one of the most important to fix
07:40:19 <BeelsebobWork> that and the space leak if you don't consume an event you create
07:40:42 <Peaker> BeelsebobWork: secondly, I am translating keyboard events to (a->a) functions and applying them, and after pressing some keys, the func-event-source based on those keys seems to continue firing irrelevant results / duplications from keys pressed earlier indefinitely
07:41:13 <BeelsebobWork> that sounds a bit like it could be a "join" bug too
07:41:22 <quicksilver> BeelsebobWork: you can work explicitly with the Reactives and solve some particular cases.
07:41:35 <BeelsebobWork> yeh, but Reactives aren't exported
07:42:47 <mlesniak> Anyone know a better way than http://hpaste.org/12323 to write a simple praefix sum (I'm thinking about something using folds...?)
07:43:16 <quicksilver> BeelsebobWork: and rightly not. except. well. for problems like this :)
07:43:19 <BeelsebobWork> mlesniak: looks like a scanl to me
07:43:23 <BeelsebobWork> quicksilver: yeh
07:43:42 <mlesniak> Beelsebob, ah thanks, never heard about it, will take a look at hoogle
07:43:56 <quicksilver> BeelsebobWork: perhaps you could explain this torus example on the list and see if anyone has any insights.
07:44:01 <BeelsebobWork> > scanl1 (+) [1,9,6,4,8,3,4]
07:44:02 <lambdabot>   [1,10,16,20,28,31,35]
07:44:09 <quicksilver> BeelsebobWork: I'm pretty sure you meant torus, although a spinning taurus would also be cool.
07:44:13 <BeelsebobWork> quicksilver: that's a good plan
07:44:17 <mib_k04v3w> i wrote a spellchecker that validates words taken from a text file , then placed in a binary tree, the thing is, it is rediculously slow, can u guys help me
07:44:18 <RayNbow> mlesniak: scan is a different name for prexis sum :)
07:44:22 <RayNbow> *prefix
07:44:29 <BeelsebobWork> quicksilver: no, it's explicitly the fact that it's a Behavior that's the problem
07:44:36 <BeelsebobWork> if it's just Geometry it's no problem at all
07:44:42 <ka> How may one implement a variadic function in Haskell?
07:45:06 <quicksilver> ka: (a) don't. (b) see Printf.
07:45:07 <mlesniak> RayNbow, :) Yes, I see it. Much more elegang using scanl. /me should take a much more closer look at the Prelude!
07:45:22 <RayNbow> ka: http://www.reddit.com/r/haskell/comments/7f6in/functions_with_the_variable_number_of_variously/
07:45:24 <lambdabot> Title: Functions with the variable number (of variously typed) arguments : haskell, http://tinyurl.com/6hffv7
07:46:43 <mib_k04v3w> anything i can do to optimise?
07:47:27 <mib_k04v3w> http://mibbit.com/pb/tUykPc
07:47:32 <lambdabot> Title: Mibbit: PasteBin
07:47:33 <mib_k04v3w> ^^^^
07:47:54 <mib_k04v3w> spellchecker, please look guys
07:48:03 <mib_k04v3w> need to make it faster
07:48:22 <mib_k04v3w> NB: dictionary contains all the words in the dictionary
07:49:57 <quicksilver> mib_k04v3w: no way of telling, really.
07:50:17 <quicksilver> mib_k04v3w: you don't show us the definition of dictionary or isIn
07:50:25 <quicksilver> if I have to guess, I guess your tree is unbalaned.
07:51:39 <lilac> quicksilver: re. path enumeration. it's trivially NP-hard and not in NP (since the result grows exponentially with the input size)
07:52:19 <quicksilver> lilac: right. That's what I was waddling towards, with my limited understanding of combinatorics ;)
07:52:36 <mib_k04v3w> http://mibbit.com/pb/PGf8yH
07:52:37 <lambdabot> Title: Mibbit: PasteBin
07:52:42 <mib_k04v3w> here is the definition
07:52:50 <quicksilver> lilac: but there are presumably better algorithms than greedy enumeration anyway
07:52:58 <ski_> @seen ddarius
07:52:59 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah, #haskell-overflow and #haskell-soc 9h 47m 38s ago, and .
07:53:00 <BeelsebobWork> mib_k04v3w: looks a lot like you need to use ByteStrings
07:53:09 <quicksilver> mib_k04v3w: you make no attempt to balance your tree
07:53:21 <quicksilver> mib_k04v3w: since your input data is ordered you will get one very ugly one-sided tree
07:53:48 <quicksilver> BeelsebobWork: ByteStrings are not a big win over short strings in CPU time. Obviously they save memory.
07:53:51 <mib_k04v3w> how do i go about balancing tree
07:53:56 <lilac> quicksilver: certainly. the only hard part is avoiding cycles, though; the rest is straightforward.
07:54:08 <quicksilver> mib_k04v3w: read about it on the internet ;)
07:54:13 <quicksilver> there are many famous algorithms.
07:54:24 <ski_> @ask ddarius Do you have any reference for bra-ket notation in relation to regular languages and expressions ? (istr you've mentioned it before)
07:54:25 <lambdabot> Consider it noted.
07:54:28 <quicksilver> red-black and AVL are the two most wellknown, perhaps.
07:54:52 <andre_> ok folks, if will somebody have any solution, please post it in http://hpaste.org/12320 because I have to leave this channel now, but I will see this link later, Thanks for everything, you are very nice.
07:55:12 <BeelsebobWork> quicksilver: yeh, but if you're dragging a lot of them in, as he is, they'll save a lot of allocation time
07:55:24 <andre_> or if prefer send me an email: andre.panm@gmail.com
07:55:27 <BeelsebobWork> for me, they saved me a *huge* amount of CPU time, just due to that
07:56:07 <andre_> thank you.
08:03:27 <Peaker> BeelsebobWork: ASAP, I'll create a minimal program to restore the second bug, any idea when the join bug is going to get fixed?
08:05:26 <camio> Peaker: No one knows for sure exactly what the problem is yet.
08:06:14 <Peaker> camio: I think a simple  accumB on atTimes already triggers it
08:06:21 <gwern> if they did, I suppose it wouldn't be a field of research :)
08:07:06 * camio shudders
08:12:17 <Peaker> camio: oh, actually it doesn't. I need to figure out what does trigger it, its not quite clear, the differences seem unrelated, but apparently they are
08:12:24 * Peaker has to brb
08:13:05 <idnar> mmm, I need to read about zippers again
08:19:09 <quicksilver> Reactive r teh n00 Zippers!
08:26:59 <hugo__> has anyone used this: http://clojure.org/ ?
08:27:01 <lambdabot> Title: Clojure » home
08:27:10 <hugo__> its a lisp dialect that works on top of the java vm
08:28:14 <lilac> > let next x = map fst $ filter ((==x).snd) andreData; find y path x | x == y = [x:path] | otherwise = next x >>= \n -> guard (n `notElem` path) >> find y (x:path) n in find "BSB" [] "GRU"
08:28:15 <lambdabot>   [["BSB","SSA","CNF","GRU"],["BSB","SSA","CNF","GIG","GRU"]]
08:33:14 <hugo__> in happs anyone knows how do i match the "/" directory ?
08:33:24 <hugo__> i tried the dir "/", but it doesn't match
08:37:54 <orgthingy> so i dont know this haskell thing
08:38:00 <orgthingy> but is it scripting or programming language?
08:38:06 <orgthingy> compiled, i mean? or just like python ?
08:38:41 <quicksilver> it's compiled.
08:38:49 <quicksilver> although interpreters exist
08:39:00 <quicksilver> but mostly, people use the interpreters just for playing/testing/experimenting
08:39:03 <quicksilver> and compile for 'real work'
08:39:42 <orgthingy> portable code, right?
08:39:48 <orgthingy> can be compiled on all OSs
08:40:15 <RayNbow> it depends on your definition of "all"
08:40:38 <quicksilver> orgthingy: the standard library is portable
08:40:48 <quicksilver> orgthingy: and known to run on POSIX oses as well as windows and OSX
08:40:55 <orgthingy> all = UNIX/UNIX-like and windows
08:41:01 <orgthingy> OSX = posix OS
08:41:03 <quicksilver> orgthingy: of course, if you bind to C, you can build non-portable libraries which then won't work.
08:41:05 <orgthingy> ah, cool
08:41:16 <hugo__> happs insists on outputing error messages along with this: fd:8: hClose: resource vanished (Broken pipe)  :( : (
08:41:22 <hugo__> anyone knows why ?
08:42:13 <ToRA|MSR> hugo__ are you piping the error messages into something like head or less?
08:42:44 <gigo> hi
08:42:47 <hugo__> ToRA|MSR: what ? no... im just runing the executable on the command prompt
08:43:18 <roconnor> ahhh, the rate of hackage uploads is doubling every week!!
08:43:19 <gigo> i have downloaded ghc6. now please tell me the best book or tutorial to learn haskell
08:43:27 <roconnor> we are screwed!
08:43:29 <gwern> @where real
08:43:29 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
08:43:31 <gwern> @where wikibook
08:43:32 <lambdabot> http://en.wikibooks.org/wiki/Haskell
08:43:38 <gwern> gigo: ^^
08:43:40 <ToRA|MSR> hugo__: oh ok, sorry, no idea then.  i usually see that error (or variants of it) when piping stuff into a program that closes the stdout / stderr early
08:43:54 <gigo> @where book
08:43:54 <lambdabot> I know nothing about book.
08:44:00 <gigo> @where you
08:44:00 <lambdabot> I know nothing about you.
08:44:08 <gigo> ok. thanks gwern
08:45:36 <int-e> @where you
08:45:36 <lambdabot> You're right here.
08:45:56 <ToRA|MSR> hugo__: though if it's on fd 8 i guess it's not stdin/stdout/stderr - so maybe it's a socket that's getting closed early by a client?
08:46:04 <rwbarton> Shouldn't it be "I'm right here."?
08:46:04 <gigo> shouldn't it be @where you - i'm right here. @where i - You're right here.
08:46:10 <hugo__> here: http://hpaste.org/12324
08:46:12 <hugo__> i need help
08:46:13 <hugo__> :(
08:46:31 <hugo__> or ill have to switch to apache and php :P
08:46:48 <gwern> gigo: a good point
08:46:56 <quicksilver> hugo__: threads are no use.
08:46:58 <gwern> @where+ you I'm right here, silly.
08:46:59 <lambdabot> It is stored.
08:47:00 <quicksilver> hugo__: try the happs mailing ilst.
08:47:16 <gwern> @where+ i You're right here with me. Where else?
08:47:17 <lambdabot> Nice!
08:47:25 <gwern> @where I
08:47:25 <lambdabot> You're right here with me. Where else?
08:47:30 <gwern> @where you
08:47:31 <lambdabot> I'm right here, silly.
08:47:34 <gwern> @flush
08:47:46 <hugo__> quicksilver: threads ?
08:48:00 <quicksilver> threats.
08:48:03 * quicksilver can't type.
08:48:04 <hugo__> oh
08:48:18 <hugo__> it wasn't a threat
08:48:35 <hugo__> im considering, since happs as only given me headaches :/
08:49:00 <quicksilver> happs is complex and different.
08:49:04 <quicksilver> I can't help you because I've never used it.
08:49:12 <quicksilver> however there are a community of people who can.
08:49:20 <rwbarton> speaking of threads, I wonder if the problem is that there's a thread spawned which listens on the socket, which gets closed when the main thread gets interrupted with ctrl-c or something.
08:49:22 <quicksilver> if lemmih isn't here then you may find the mailing list better.
08:49:42 <gwern> mailing list may be better because the conversation would get archived
08:49:50 <hugo__> okey
08:49:53 <hugo__> thanks :)
08:49:57 <leviathan> Has anyone expirience with fgl?
08:52:29 <conal> Peaker: ping
09:03:12 <leviathan> I have a runtime exception when calling mkGraph function of fgl. Can any one help?
09:09:35 <gigo> in this http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html there are comments links and people are scolding the authors. why?
09:09:41 <lambdabot> Title: Why functional programming? Why Haskell?, http://tinyurl.com/6lmwfu
09:09:44 <gigo> why is comments allowed here?
09:12:05 <gwern> gigo: why not?
09:12:26 <lispy> I wonder how hard it would be to modify Haskell so that you can pass types in addition to values
09:13:11 <lispy> so that when people do thiings like foo (undefined :: SomeType) = ..., it can just become foo SomeType = ..., but maybe with some extra synta to say I mean the type and not just a data constructor that happens to have the same name
09:13:23 <gwern> gigo: all of RWH is commentable; there are thousands of reader comments on't. the authors say the comment greatly assisted the book
09:13:41 <gigo> ok
09:13:41 <lispy> (this tends to really only come up when you want to say which type class dictionary you want to work with)
09:13:55 <Giraffe> it's an interesting model
09:14:05 <Giraffe> comments = reviews and constructive criticism...for free
09:14:50 <gwern> Giraffe: yup. but the commenters are also being rewarded here
09:15:22 <gwern> both in the sense that RWH is good for haskellers (network effects) and inasmuch as part of the implied deal is that commenters get the book online for free
09:15:42 <Giraffe> gwern, yep
09:17:55 <int-e> lispy: you can do that (awkwardly though) with a newtype. newtype Foo a b = Foo b; then, instead of foo :: a -> b (a being a dummy parameter), use foo :: Foo a b. You can write conversion functions between Foo a b and a -> b for convenience.
09:18:42 <int-e> lispy: using a newtype ensures that there's no runtime overhead, which I believe is the main reason for wanting to pass types
09:19:13 <gigo> is hashkell called the purest functional language?
09:20:06 <ddarius> No
09:20:07 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
09:21:01 <lispy> int-e: the main reason I know of to pass a type is to tell the compiler which instance of a type class you want.  I don't see how a newtype solves that problem.
09:21:45 <ddarius> @seen ski_
09:21:45 <lambdabot> ski_ is in #haskell.hr, ##logic and #haskell. I last heard ski_ speak 1h 27m 20s ago.
09:21:50 <int-e> lispy: I guess the newtype could have a prettier name. newtype a :->: b = Simply b
09:25:22 <camio> @seen conal
09:25:23 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 32m 54s ago.
09:25:38 <conal> camio: hi
09:25:46 <int-e> lispy: http://hpaste.org/12325
09:26:10 <camio> Hi Conal, I was looking at FRP.Reactive.GLUT.Adapter
09:26:19 <camio> It says:          mousePos = (0.0,0.0) `stepper` mousePosE
09:26:33 <camio> I'm thinking that should be mousePos = _|_ `stepper` mousePosE
09:26:39 <camio> With a decent error message.
09:27:08 <conal> camio: i think that error would get triggered often.
09:27:26 <conal> camio: note the comment: "-- TODO: let the initial mouse position be its actual position"
09:27:34 <int-e> lispy: oh. data DD l r = MK_DD l r
09:27:54 <camio> conal: I agree with that, except I'd say let the time 0 mouse position be its actual position.
09:28:07 <camio> conal: And before time 0 let it be _|_.
09:28:17 <vincenz> conal: Hey
09:28:22 <conal> camio: oh, sure.
09:28:22 <vincenz> conal: small question about your unamb opst
09:28:24 <conal> vincenz: hi!
09:28:29 <conal> vincenz: fire
09:28:44 <vincenz> conal: The BlockedOnDeadMVar handler is only for the case that a race is called inside anothe rrace, right?
09:28:48 <vincenz> s/rr/r
09:29:03 <conal> vincenz: yeah
09:29:09 <camio> conal: Otherwise we're assuming that the mouse was always there in the past and that makes little sense to me.
09:29:23 <conal> camio: yep.  agreed.
09:29:44 <camio> conal: Thanks. I'll make a patch.
09:29:49 <conal> camio: btw, i expect this sort of thing to get ironed out in the new model i'm working on.
09:29:54 <conal> camio: that'd be great.  thx!
09:30:02 * conal loves patches
09:30:06 <lilac> conal: i wonder whether unsafeUnamb :: a -> b -> IO (Either a b) would be more useful?
09:30:20 <dons> haskell subreddit, for those who didn't know about it. http://www.reddit.com/r/programming/comments/7fd52/the_haskell_subreddit_is_on/
09:30:35 <lambdabot> Title: The Haskell subreddit is on! : programming, http://tinyurl.com/62fs26
09:30:45 <lilac> s/unsafeUnamb/amb/g
09:30:55 <vincenz> conal: Thanks
09:31:30 <int-e> lispy: if you want more complete code, see here. http://int-e.home.tlink.de/haskell/Impl.hs
09:32:05 <lilac> ambOr a b = unsafePerformIO $ amb a b >>= \c -> case c of Left True -> True; Right True -> True; Left False -> b; Right False -> a
09:33:16 <conal> lilac: nice idea (Either).  i think you can easily define it in terms of amb.
09:33:34 <lispy> int-e: this is based on the configurations thing that Oleg did right?
09:33:55 <lilac> conal: yeah, i just realised that :) myAmb a b = amb (Left a) (Right b)
09:34:01 <gigo> does haskell have functions like nchoosek(n, k)?
09:34:05 <int-e> lispy: not intentionally, but perhaps subconsciously.
09:34:05 <conal> lilac: :)
09:34:26 <lilac> and amb a b = either id id $ myAmb a b
09:34:31 <conal> gigo: haskell has *lots* of libraries, so probably.
09:34:41 <lilac> modulo fmap
09:34:47 <dons> gigo: you'd have to explain what nchoosek does
09:34:52 <conal> lilac: yeah
09:35:01 <Deewiant> dons: binomial coefficient
09:35:04 <gigo> dons: combinations, how many ways to select k items from n objects?
09:35:11 <conal> lilac: amb = (fmap.fmap) (either id id) myAmb
09:35:30 <dons> check on hackage.haskell.org
09:36:26 <int-e> lispy: The newtype idea was driven by desire of performance -- the compiler will reevaluate the dummy argument functions because it doesn't know that the argument is unused. It will happily treat the newtype version as a constant and only evaluate the (big, in my use case) number once.
09:37:08 <lilac> conal: amb = fmap fmap fmap (either id id) myAmb
09:37:32 <conal> lilac: that too!
09:38:02 <int-e> lispy: the 'GHC' version that the code alludes to is this, btw: http://hpaste.org/12325#a1 ... a dirty hack, but a useful one.
09:39:17 * lilac wonders how many different functors can usefully be combined into an expression consisting entirely of fmaps
09:41:40 <int-e> > fmap `fmap` fmap `fmap` fmap `fmap` fmap
09:41:41 <lambdabot>       Overlapping instances for Show
09:41:42 <lambdabot>                                  ((a -> ...
09:41:49 <int-e> @type fmap `fmap` fmap `fmap` fmap `fmap` fmap
09:41:50 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
09:42:13 <lispy> int-e: okay, I only glanced at your code but it seems that you reify values into types and back in that code?
09:42:23 <int-e> lispy: yes.
09:42:33 <conal> lilac: do you know you can make arbitrary composition strings of fmap, first, and second ?  also (liftA2.liftA2.liftA2) etc.  and they all have simple & direct readings.  and work with arrows, by generalizing fmap.  Done in the DeepArrow lib.
09:42:36 <lispy> int-e: and that's the same thing oleg does in the configurations paper.  he even generalizes it to storables :)
09:42:42 <int-e> lispy: (I think I use 'reflect' and 'reify' in the opposite sense of Oleg's convention)
09:43:02 <int-e> lispy: well, the GHC trick generalises to arbitrary types. so there ;)
09:43:10 <lispy> int-e: oh cool
09:43:17 <lispy> int-e: so then what is the run-time hit?
09:43:26 <lispy> int-e: and is this GHC technique documented in a paper?
09:43:38 <int-e> lispy: none. it's an unsafeCoerce, which is a no-op at runtime.
09:43:42 <int-e> lispy: none that I've written
09:43:55 <ka> What is 'forall'?  ghc seemed to think that was inexisted
09:44:00 <ka> inexistent*
09:44:15 <Deewiant> > (fmap `fmap` fmap `fmap` fmap) (+1) [Nothing, Just [1,2,3]]
09:44:16 <lambdabot>   [Nothing,Just [2,3,4]]
09:44:42 <lispy> int-e: okay, because in my thesis I was going to talk about how the configurations technique would be unsuitable for us because it adds run-time overhead...but then I your technique could be suitable :)  I have no way to reference it though
09:44:49 <int-e> ka: it's a keyword enabled by higher rank types. (-XRank2Types, -XRankNTypes)
09:45:24 <Deewiant> also by ScopedTypeVariables and others
09:45:33 <lispy> the type error for forall when the extension is turn off is terriblely confusing or at least it was last time I checked
09:45:59 <Deewiant> Well, it just thinks it's another type variable like 'a'.
09:46:12 <ddarius> Deewiant: It'd better.
09:46:13 <Deewiant> I think there was a ticket about this recently, though.
09:46:58 <Deewiant> GHC HEAD might suggest -XRank2Types now.
09:47:44 <lispy> int-e: we use existential types because we need a fresh stream of typs and we need sane type signatures but our sequences have type indexed elements and those indicies line up.
09:48:19 <lispy> int-e: so I had the idea, after reading oleg's paper that when we start a sequence we could reify the output of say, monad unique, instead of using an existential
09:48:35 <lispy> int-e: then type equality might be more precise for us
09:49:00 <lispy> int-e: as is, it's very pessimistic and requires this hackish short of run-time test that can easily be abused
09:49:33 <Aser> hello. got a function aF which generates a filepath based on user's input (should be run 1x in application(type IO String)) then i got 4 other functions which are called x times while programm is run. they should all write something into the generated path. how can i give every function (it's not shure which of them will run how often based on user's interaction) the path to use?
09:49:43 <lispy> int-e: am I making any sense? ;)
09:51:03 <lispy> Aser: in general you'd pass that path to each function that needs it.  This can be made more automatic by using a Reader monad
09:51:37 <lispy> Deewiant: oh good, i might have opened that ticket :)
09:51:57 <ToRA|MSR> Deewiant: just checked, head suggests RankNTypes
09:52:18 <lispy> Aser: there is a hackish way to provide mutable global variables, but purists recommend against it
09:52:56 <Aser> how to pass it to every function? can't save it into an "global" var as if i'd do imperative.
09:52:58 <lispy> Aser: the hack requires telling the compiler not to inline the definition and it also requires the use of an unsafe function, unsafePerformIO
09:53:21 <lispy> Aser: you pass it just like any formal parameter :)
09:53:26 <int-e> lispy: well, for those dynamic checks you'll be carrying the unique values around, either as part of a type class instance or as a value.
09:54:07 <lispy> int-e: my idea for the equality check was to reflect the type back to a value and then perform some check
09:54:09 <int-e> lispy: so I'm not sure which overhead you're avoiding by jumping those hoops
09:54:42 <Jedai> Aser: What's the problem ? do { path <- aF; f1 path; f2 path; f3 path; f4 path } or something like that
09:54:47 <int-e> lispy: but it certainly sounds doable
09:55:06 <lispy> int-e: I wish we could talk in person, this is getting hard to explain (my idea)
09:55:37 <Jedai> Aser: or mapM_ ($ path) [f1, f2, f3, f4}
09:55:59 <lispy> int-e: I was somehow thinking, maybe incorrectly, that this technique could be used to reduce our dependence on existential types.  By using existential types we can only have teh type system reason about the relationships between our types instead of also what the types are representing
09:56:13 <Jedai> Aser: Or a Reader monad if you really want to make the passage of the path implicit
09:57:23 <lispy> int-e: take for example the creation of one of these values from a parser.  Right now the parser returns phantoms that represent the indexes
09:57:50 <lispy> int-e: but, our data model makes it possible to assign a value to those.  We just don't because it's never been useful before.
09:58:14 <lispy> int-e: so I thought using the configurations techinque we could assign a unique number to each index
09:58:27 <int-e> lispy: IIRC you were representing a sort of functions (patches), Patch a b being a patch from a and b, with some apply :: Repos a -> Patch a b -> Repos b. Now if you have unrelated Patches Patch a b and Patch c d, you want to be able to tell the type checker that b and c (say) are actually the same.
09:58:29 <lispy> int-e: I do think this has the potential for overhead?
09:58:52 <lispy> int-e: you have a good memory :)
09:59:42 <lispy> int-e: well, yeah with our current existential based approach the types b and c might not be equal, but maybe they can safely be sequenced
10:00:12 <int-e> lispy: To do that, you need to carry some sort of identification in the Patch type. So you'll end up with data Patch a b = Patch uniqA uniqB ... without configurations and with Patch a b where Patch :: (PatchId a, PatchId b) => ... -> Patch a b
10:00:34 <lispy> int-e: this could happen if you have 2 copies of the same patch sequence and you deconstruct them in parallel (imagine a zip) the existentials would never be the same on parellel elements even though we know they could be
10:01:13 <lispy> (maybe I should say should be)
10:01:23 <lispy> identification?
10:01:25 <int-e> lispy: on the implementation level there's little difference between the two - the PatchId class dictionary will contain the Patch id (as the very minimum) and that will be packed inside the Patch value.
10:02:03 <lispy> int-e: well, hmm...I thought a b would be integers that are reified as types
10:02:26 <lispy> int-e: I'm not sure Im' following you
10:02:55 <lispy> int-e: so the PatchId is the type class that lets me reflect the type back into a value?
10:02:57 <int-e> lispy: well, you can't extract the integer from the type without a type class. that's what PatchId is.
10:03:25 <lispy> right, okay.  That does make sense to me.
10:03:41 <lispy> so our type signatures all necessarily become larger
10:04:01 <lispy> and the only time we incurr overhead is when convert between value/type ?
10:04:08 <int-e> lispy: but the point I'm trying to make is that the two types, data Patch a b = Patch Uniq Uniq ... and  Patch :: (PatchId a, PatchId b) => ... -> Patch a b  are essentially the same - they contain the same data, you just access it differently
10:04:12 <lispy> and possibly the dicitonary passing I guess
10:04:49 <lispy> int-e: data Patch a b = Patch Uniq Uniq -- here Uniq is?
10:04:58 <int-e> lispy: Uniq is the integer
10:05:18 <lispy> Oh I see what you're saying.
10:05:49 <lispy> int-e: well, right now Uniq and Uniq are phantoms so we don't even have that bit of overhead
10:06:28 <lispy> data Patch a b = Hunk <no mention of a b> | Rename <again no mention of a b>
10:06:43 <lispy> But, I can see that the overhead is then very little
10:07:14 <lispy> int-e: so then what about the cost of reflection?  and I'm understanding it that the ints 1 and 5, say, have different types once we reify them as types?
10:07:51 <lispy> int-e: I have so many questions :)  Thanks for helping me
10:07:58 <int-e> lispy: the number is turned into a class dictionary. (the types don't exist at runtime. at least not in ghc - jhc is a different beast.)
10:09:24 <lispy> int-e: okay.  So we'd still need much of our existing existential approach.  But what we would gain is a safer run-time comparison of these types
10:10:07 <int-e> lispy: right. the question I'd ask, do you gain anything by using a class dictionary instead of storing the uniq values directly?
10:10:16 <lispy> one that is both harder to use maliciously (I know this because I've already sketch making our phantoms use a type class) and also harder for the progammer to accidentally use incorrectly
10:10:23 <Aser> confuse :( let's say: fu = do a <- getLine; return a  as datapath. now main calls f1 and f2 which need the path as parameter. how can i do this without calling fu more then one time the easiest way?
10:10:46 <lispy> int-e: okay, that does need consideration.  off the top of my head...no benefit.
10:11:16 <hackage> Uploaded to hackage: HXQ 0.11.0
10:11:24 <byorgey> Aser: just do something like   main = do datapath <- fu; f1 datapath; f2 datapath
10:11:26 <int-e> lispy: The reason I ask is that without the unsafeCoerce trick, there's some overhead of constructing the dictionary. And I'm not sure I should be advocating that trick - in principle GHC could change the precise implementation of class dictionaries any time and break it.
10:11:38 <lispy> int-e: well, with the type based approach we can use more clever encodings than int and still incurr the same cost?
10:11:53 <int-e> lispy: and all that trouble would be avoided if you just store the uniqs directly.
10:11:56 <Aser> head --> table. thanks
10:11:57 <byorgey> Aser: that will only call 'fu' once, and store the result in the name 'datapath'
10:12:05 <byorgey> hehe =)
10:12:11 <saml> > hahaha where hahaha = hahaha
10:12:18 <kowey> is it reasonable for me to expect to be able to do: createDirectoryIfMissing False "foo" a lot of times, simultaneously, in parallel?
10:12:26 <lambdabot>   thread killed
10:12:31 <kowey> (I get AlreadyExists errors)
10:12:51 <lispy> int-e: thank you very much for the food for thought
10:12:55 <byorgey> kowey: for the same "foo" ?
10:13:00 <kowey> byorgey: yes
10:13:07 <byorgey> yikes
10:13:18 <byorgey> sounds like fun times with race conditions to me =)
10:13:19 <kowey> my guess is that somewhere between the already-exists check and the directory creation ... :-)
10:13:32 <byorgey> exactly.
10:13:33 <lispy> int-e: I think I have my answer and that is, doing this would only make sense as an incremental refinement.  And it comes with a lot of baggage so we could simulate it without the fancy type hackery
10:13:49 * kowey resigns himself to catching the exception
10:14:35 <StoneToad> you can't do some kind of locking?
10:14:37 <saml> > if you_are_happy then "thread killed" else "thread not killed" where you_are_happy = you_are_happy
10:14:42 <byorgey> kowey: catching the exception doesn't sound like a horrible solution.  Presumably the directory creation itself is atomic, so you won't get a corrupted filesystem or anything
10:14:52 <lambdabot>   thread killed
10:15:39 <lispy> kowey: is this happening in darcs?
10:15:45 <kowey> lispy: no, work-work
10:15:50 <lispy> kowey: ah
10:16:01 <kowey> i've got a test harness in the form a makefile that runs a haskell script a whole bunch of times
10:16:06 <kowey> and it breaks on make -j
10:16:09 <kowey> sigh :-)
10:16:37 <lispy> ah
10:18:33 <int-e> Btw I'm confused by the 'reify' and 'reflect' usage, in the context of configuration. For me, the configuration (say, a number) is the concrete entity, while the type is completely intangible - merely a reflection. For some reason, the convention is the opposite. Why?
10:18:37 <Deewiant> kowey: I think that's a bug/feature request worth reporting: the whole operation /should/ be atomic IMO
10:19:44 <lispy> int-e: reify, when I looked it up, means to give something a representation
10:19:55 <lispy> int-e: that's how understood it nayway
10:20:01 <lispy> int-e: i forget which way oleg uses it
10:20:21 <int-e> lispy: WordNet reify, v : consider an abstract concept to be real
10:20:30 <lispy> int-e: but i could see believe either terminology, reifying a value as a type or vice versa
10:20:32 <int-e> huh. WordNet *says*
10:20:58 <stein> .
10:21:00 <lispy> int-e: so you would argue that reify should be for turning the type into a value?
10:21:12 <lispy> int-e: and reflect is to put the value into a type?
10:21:55 <lispy> dictionary.com: to convert into or regard as a concrete thing: to reify a concept.
10:22:04 <int-e> lispy: personally, yes. But I think Oleg uses the verbs the other way. I'm trying to understand why. (Actually both the configuration and the type are abstract so the choice is somewhat arbitrary.)
10:22:09 <lispy> int-e: in that regard, I can see why reify should be for type -> value
10:23:00 <lispy> int-e: I've come to think of types as a value in the type system...I know this because I'm continually being corrected by people in my writing :)
10:23:18 <lispy> int-e: I'll talk about the values that a type variable takes on and it confuses people :)
10:23:20 <LexStein> n00b question
10:23:33 <saml> n00b answer
10:23:51 <int-e> lispy: Heh, I can imagine that happening to me.
10:23:52 <saml> n00b waiting
10:23:56 <LexStein> why can't i say: main = map (\x -> putStrLn x) ["hello", "world"]
10:24:09 <idnar> try mapM_
10:24:17 <saml> LexStein: you probably need mapM_
10:24:24 <idnar> your map there returns a list of IO actions
10:24:25 <Deewiant> the short answer to 'why' is 'monads'
10:24:29 <saml> because type of putStrLn is weird
10:24:30 <idnar> whereas main needs to be a single IO action
10:24:47 <idnar> also, (\x -> putStrLn x) is just putStrLn
10:24:51 <lispy> :t map (\x -> putStrLn x) ["hello", "world"]
10:24:52 <lambdabot> [IO ()]
10:24:52 <saml> > mapM_ (\x -> putStrLn x ) ["hello", "world"]
10:24:54 <lambdabot>   * Exception: "<IO ()>"
10:24:58 <LexStein> that works
10:25:02 <lispy> :t sequence (map (\x -> putStrLn x) ["hello", "world"])
10:25:03 <lambdabot> IO [()]
10:25:07 <saml> > map (\x -> x) ["hello", "world"]
10:25:08 <lambdabot>   ["hello","world"]
10:25:14 <lispy> ?src mapM
10:25:15 <lambdabot> mapM f as = sequence (map f as)
10:25:21 <lispy> oh what do you know :)
10:25:25 <idnar> @src mapM_
10:25:25 <Deewiant> ?src mapM_
10:25:25 <lambdabot> mapM_ f as = sequence_ (map f as)
10:25:25 <lambdabot> mapM_ f as = sequence_ (map f as)
10:25:28 <idnar> heh
10:25:58 <kowey> Deewiant and byorgey, thanks! http://hackage.haskell.org/trac/ghc/ticket/2808 (and catching the error seems to help)
10:25:59 <lispy> the _ versions are nice because for IO () they are more efficient
10:25:59 <lambdabot> Title: #2808 (createDirectoryIfMissing should be atomic) - GHC - Trac
10:26:03 <LexStein> thanks
10:28:09 <saml> > let _ = _ in _
10:28:11 <lambdabot>   Pattern syntax in expression context: _Pattern syntax in expression context...
10:30:01 <lispy> which is a product type again?
10:30:17 <lispy> data Prod a = A | B ?
10:30:23 <lispy> that's sum right?
10:30:27 <dcoutts_> lispy: yep
10:30:29 <dcoutts_> that's a sum
10:30:47 <lispy> so then data Sum = A | B; data Prod = P A B ?
10:30:53 <dcoutts_> yep
10:30:54 <int-e> product type = tuple or record.
10:31:19 <lispy> this paper says, [a] ~= (ismorphic) 1 + a * [a]
10:31:20 <kowey> lispy: my trick is remembering the O'Caml syntax for the type of tuples (a * b)
10:31:35 <lispy> kowey: ah
10:31:40 * lispy forgets Ocaml :)
10:31:46 <dcoutts_> lispy: yes
10:31:51 <int-e> lispy: the 1 is the empty list, and a * [a] is a cons,
10:31:55 <lispy> instance Ord Ocaml -- oh wait, dons already pointed out this doesn't owrk
10:32:06 <lispy> yeah 1 == unit == ()
10:32:09 <int-e> lispy: where 'is' = 'represents'
10:32:11 <lispy> or actually []
10:32:21 <lispy> int-e: right, isomorphic to ~=
10:32:26 <Peaker> conal: pong
10:33:15 <dcoutts_> lispy: data ListFunctor a x = Nil | Cons a x  and then the list is the fix point of that
10:33:30 <Plouj> man, YAHT has gonne really incomprehensible after the half-way point
10:34:08 <conal> Peaker: hi.  nm.  answered my own question.
10:34:22 <osfameron> Plouj: yeah, i found that
10:34:33 <Plouj> I read "In order to declare a type to be an instance of a class, you need to provide an instance declaration for it" in the Instance Declarations section of http://en.wikibooks.org/wiki/Haskell/YAHT/Language_advanced and I ask myself "what is a class? What does it mean to be an instance of a class? Why would anyone want to declare a type to be an instance of a class?
10:34:46 <lispy> dcoutts_: I'm still waiting for the "Learn you a catageory" tutorial ;)
10:34:56 <dcoutts_> lispy: there's a nice section on this in my thesis :-)
10:35:07 <BrokenClockwork> Hey, sorry - it's me again with the bracket test issue, maybe someone could look over what I've wrote so far, or give me a better approach: http://hpaste.org/12328 (Task, Questions, Approach)
10:35:31 <lispy> dcoutts_: cool, what is your thesis about?  I don't think your name has come up much in my recent searches on related work...I did see the stream fussion paper though
10:35:38 <dcoutts_> lispy: it explains why foldr and unfoldr look the way they do, given the shape of the list functor
10:35:55 <lispy> links?
10:36:17 <dcoutts_> lispy: it's on stream fusion, but the theory section talks about data types as greatest and least fix points
10:36:49 <lispy> oh okay
10:41:19 <BrokenClockwork> well, any ideas to test a string of brackets if it's okay? for instance (( )) or  [ ( ] )
10:41:30 <vixey> Don't ask me :)
10:41:40 <vixey> what ski suggested yesterday was a good way
10:41:43 <BrokenClockwork> I tried pattern matching x:y:xs with various possibilities, but there was often one to two cases not covered
10:41:50 <BrokenClockwork> the datat type idea?
10:42:11 <vixey> yeah use skis [Bracket] as the 'Situation'
10:42:13 <BrokenClockwork> sorry I had no access to history, this idea jsut ran through my head, but I could not remember
10:43:25 <twanvl> BrokenClockwork: how about passing the integer with the level of nesting as an argument, instead of returning it
10:43:54 <jttoivon> qls
10:44:22 <BrokenClockwork> I tried this too, but it seems liekr eally dirty code ^^
10:44:32 <BrokenClockwork> besides it did not work out for me
10:44:58 <vixey> twanvl (that's what I suggested at first but it can't work for this problem)
10:45:09 <BrokenClockwork> [bracket] the type of bracket, what do you mean with skis and 'Situation', Situation as in bool true/false? or maybe I should read again over "alegbraic data types intro" vixey?
10:45:17 <twanvl> vixey: why not?
10:45:21 <BrokenClockwork> before asking any further?
10:45:54 <vixey> twanvl, multiple types of bracket () {} and []
10:47:08 <camio> conal: Do you have an idea when the (fmap.fmap) blog post will be complete?
10:47:38 <BrokenClockwork> so should I read "algebraic data types intro" of "Learn You A Haskell" :D
10:47:54 <vixey> BrokenClockwork, I think he defined data Bracket = Round | Curly | Square
10:48:15 <vixey> BrokenClockwork, and that makes [Bracket] a stack of kinds of parenthesis
10:48:23 <BrokenClockwork> oh
10:48:34 <Jedai> BrokenClockwork: That seems pretty straightforward to do with a stack of Bracket...
10:48:46 <vixey> so when you hop over a '(' you add on a Round, when you hop over a '}' you pop off a _Curly_
10:48:49 <BrokenClockwork> that really sounds nice
10:49:17 <vixey> :t foldl
10:49:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:50:00 <vixey> foldl :: (Situation -> Char -> Situation) -> Situation -> String -> Situation
10:50:54 <vixey> so you might use type Situation = Maybe [Bracket] ,, or Either ErrorMessage [Bracket]
10:51:46 <BrokenClockwork> maybe Bracket or ErrorMessage is for a not closed bracket type?
10:52:22 <vixey> say you are wrapped up in a whole bunch of ((((((((('s and then a } comes along
10:52:49 <vixey> the next situation can't be "((((((((" because it wasn't a ')' that you came across
10:52:59 <BrokenClockwork> yes
10:54:11 <BrokenClockwork> that would be a break condition for imperative loop programming, but in haskell i guess it's a guard
10:55:40 <int-e> @type foldM :: (s -> a -> Maybe s) -> s -> [a] -> Maybe s
10:55:41 <lambdabot> forall s a. (s -> a -> Maybe s) -> s -> [a] -> Maybe s
10:55:51 <LexStein> n00b alert
10:56:00 <dons> byorgey: note the FP jobs posted today
10:56:01 <lispy> how is parametric polymorphism in a type different than a type-indexed type?
10:56:16 <dons> lispy: it has the same behaviour at all types?
10:56:56 <Jedai> BrokenClockwork: I suggest you just try to write in a direct recursive style
10:57:05 <leimy> This FRP stuff is pretty neat
10:57:24 <lispy> dons: hmm...so a type indexed type has a different structure depending on the index type?
10:57:27 <Jedai> BrokenClockwork: It's just a matter of a few lines this way
10:58:23 <LexStein> i can't find an atoi() analog in Haskell
10:58:31 <LexStein> is there something Int -> String ?
10:58:39 <leimy> LexStein: show
10:58:43 <maltem> @type show
10:58:44 <lambdabot> forall a. (Show a) => a -> String
10:58:45 <profmakx> atoi is inverse
10:58:48 <leimy> LexStein: "show 4"
10:58:56 <LexStein> beautiful!
10:58:56 <profmakx> > read "4" :: Integer
10:58:57 <leimy> or
10:58:58 <lambdabot>   4
10:58:58 <LexStein> thank you
10:59:07 <leimy> You wanted itoa or atoi? :-)
10:59:14 <roconnor> > digitToInt '4'
10:59:15 <lambdabot>   4
10:59:52 <maltem> btw what's the 'a' in 'atoi'?
11:00:09 <Zao> asciiz
11:00:24 <Zao> Zero-terminated text.
11:01:02 <Deewiant> alpha as in alphabet or alphanumeric, I think
11:01:25 <leimy> ASCII
11:01:33 <maltem> hm right
11:01:44 <mauke> it's definitely not ascii
11:02:06 <roconnor> > digitToInt 'f'
11:02:07 <leimy> no it definitely is ascii
11:02:07 <lambdabot>   15
11:02:10 <leimy> see the man page
11:02:28 <mauke> I don't care what your man page says, atoi is a standard C function, and standard C doesn't care about ASCII
11:03:15 <mauke> % man atoi | grep ascii || echo fail
11:03:15 <mauke> fail
11:03:28 <roconnor> grep -i ?
11:03:29 <leimy> lol
11:03:31 <leimy> try ASCII
11:03:52 <mauke> % man atoi | grep -i ascii || echo fail
11:03:52 <mauke> fail
11:03:56 <roconnor> $ man atoi | grep -i ascii || echo fail
11:03:56 <roconnor> No manual entry for atoi
11:03:56 <roconnor> fail
11:04:02 <roconnor> :D
11:04:25 <dons> ?users
11:04:26 <lambdabot> Maximum users seen in #haskell: 558, currently: 549 (98.4%), active: 30 (5.5%)
11:04:31 <dons> are we there yet?
11:05:16 <BrokenClockwork> vixey: Sorry, I did not understand your type maybe[bracket] or ErrorMessage[bracket] idea not :(
11:05:35 <Rapiere> I'm not on idlerpg ?
11:05:55 <daf> dons: soon, soon
11:06:02 <lament> #haskell, the world's biggest idlerpg server
11:06:30 <roconnor> dons: if the hackage upload rate keeps doubling every week we will have 4 million billion hackage packages by this time next year.
11:07:18 <BrokenClockwork> before I define [Bracket] he does not know that this shall be a stack of Bracket?
11:07:20 <dons> roconnor: heh
11:07:34 <dons> roconnor: i think this might be a local spike due to ghc release 6.10
11:07:37 <gwern> roconnor: and yet, not a single good mail client
11:07:42 <dons> the general trend is a bit slower
11:07:57 <dons> roconnor: http://haskell.org/haskellwiki/Hackage_statistics
11:07:59 <lambdabot> Title: Hackage statistics - HaskellWiki
11:08:09 <dons> roconnor: if you want to tidy up those stats, or do some projections, i can get you data
11:08:20 <Rapiere> cabal-install is really a great tool, is there a plan to make it installed by default with GHC ?
11:08:27 <roconnor> I do, but I should write my thesis. :(
11:09:32 <gwern> Rapiere: yes
11:09:48 <gwern> or part of the haskell platform, 'smuch the same thing
11:10:02 <Rapiere> neat, that would greatly help to work with haskell as a beginner
11:11:51 <FunctorSalad> should be easy, since cabal-install comes with an automatic bootstrap.sh script already
11:12:29 <lispy> gwern: you could reimplement Sup in haskell
11:12:46 <lispy> gwern: I've heard the ruby implementation has a tendency to corrupt things like the search index
11:13:02 <gwern> hilarious
11:13:28 <lilac> > let b (x:xs) (y:ys) | [x,y] `elem` ["()","{}","[]"] = b xs ys; b xs (y:ys) = b (y:xs) ys; b xs [] = null xs in b [] "(([{}{}[]]())(()[]))"
11:13:30 <lambdabot>   True
11:13:32 <FunctorSalad> has anyone here used the AERN package?
11:14:06 <FunctorSalad> I find the class interface hard to understand :(
11:15:48 * lilac wonders whether that's nicely expressible as a fold
11:17:41 <BrokenClockwork> when I define my own data type, how can I create the stack-type of it?
11:18:01 <BrokenClockwork> for instance data MyData = A | B | C
11:18:07 <BrokenClockwork> so I want [MyData]
11:18:16 <daf> yes
11:18:35 <FunctorSalad> do you mean something different than a list by 'stack'?
11:18:40 <Jedai> BrokenClockwork: The stack is just a normal list...
11:18:48 <BrokenClockwork> sorry I mean a list
11:18:58 <FunctorSalad> then [MyData] is it :)
11:19:09 <dons> well, lists serve as useful stacks
11:19:16 <dons> :t []
11:19:18 <lambdabot> forall a. [a]
11:19:24 <Jedai> BrokenClockwork:  The syntax is the list syntax : [ A, A, B, C ]
11:19:26 <dons> haskell lists are polymorphic in the elements stored in the list
11:19:33 <dons> so you can replace the type 'a' with any concrete type, like MyData
11:19:34 <vixey> BrokenClockwork: What about the Maybe [Bracket] is not clear?
11:19:39 <dons> yielding a [MyData] type
11:20:54 <BrokenClockwork> I don't know, for what I need this Maybe [Bracket] -type or how to define it
11:21:11 <lilac> > case True of x | x -> "true"; _ -> "false"
11:21:12 <lambdabot>   "true"
11:21:16 <BrokenClockwork> type [Bracket] = [(Yes,No)] dunno ... *confused*
11:21:28 <vixey> type Situation = Maybe [Bracket]
11:21:35 <vixey> foldl :: (Situation -> Char -> Situation) -> Situation -> String -> Situation
11:21:38 <BrokenClockwork> og that's the actualy code?
11:21:42 <vixey> yes :)
11:21:56 <BrokenClockwork> oh lord, sorry, I thought I have to code my own Maybe-Fucntion or sth.
11:22:06 <vixey> Maybe is already defined in haskell
11:22:15 <vixey> And it is,  Nothing or Just (something)
11:22:23 <int-e> lilac: well it's a foldl. But case expressions in lambdas are awkward, so I'd still define an extra function for the worker.
11:22:52 <lilac> > null . foldl (\s y -> case s of x:xs | [x,y] `elem` ["()","[]","{}"] -> xs; _ -> y:s) [] $ "(([[]]))"
11:22:54 <lambdabot>   True
11:23:02 <lilac> case + guard for the win
11:23:33 <lilac> int-e: yeah, a worker function would make it clearer, but that's not my aim :)
11:24:09 <vixey> > null . foldl (\s y -> case s of x:xs | [x,y] `elem` ["()","[]","{}"] -> xs; _ -> y:s) [] $ "(([[[[))"
11:24:10 <lambdabot>   False
11:24:12 <BrokenClockwork> lilac, are you from my study path from FU Berlin?
11:24:22 <int-e> lilac: it's also shorter. let f (x:xs) y | [x,y] `elem` ["()","{}","[]"] = xs; f xs y = y:xs in null . foldl f [] $ "(([[]]))"
11:24:34 <FunctorSalad> what's wrong with clarity? ;)
11:24:37 <vixey> wo I don't understand how that works a all
11:24:39 <vixey> lol
11:24:58 * int-e likes the `elem` ["()","{}","[]"] idea very much.
11:25:06 <vixey> :t elem
11:25:07 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:25:13 <dolio> lilac: That's pretty sexy.
11:25:15 <lilac> int-e: yep, i'd just noticed it's shorter :)
11:25:47 <lilac> BrokenClockwork: no, i'm just golfing this for the fun of it :)
11:26:12 <BrokenClockwork> but how comes you are working also on a bracket test?
11:26:17 <BrokenClockwork> is this by accident? ^^
11:26:28 <vixey> > null . foldl (\(x:xs) y -> case () of () | [x,y] `elem` ["()","[]","{}"] -> xs; _ -> y:s) [] $ "(([[]]))"
11:26:29 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Expr'
11:26:30 <lilac> dolio: thanks :) it could be more efficient (early bailout) but other than that, i like the algo
11:27:06 <lilac> BrokenClockwork: no, i'm working on a bracket test because you suggested it :)
11:27:18 <vixey> > null . foldl (\s y -> case s of x:xs | [x,y] `elem` ["()","[]","{}"] -> xs; _ -> y:s) [] $ "(()[[]]))"
11:27:19 <lambdabot>   False
11:27:25 <vixey> > null . foldl (\s y -> case s of x:xs | [x,y] `elem` ["()","[]","{}"] -> xs; _ -> y:s) [] $ "(()[[]]())"
11:27:26 <lambdabot>   True
11:27:36 <BrokenClockwork> oh... :S
11:28:03 <vixey> so how does it work?
11:28:17 <lilac> vixey: it repeatedly removes empty paired brackets
11:28:38 <dolio> vixey: s is the stack. The first case pops a matching bracket off the stack. The second pushes stuff on.
11:29:09 <lilac> vixey: basically its a single pass with a list zipper
11:29:17 <vixey> but if s is the stack and y is a single character, where is the string?
11:29:20 <solussd> hello- what is the best way to take an array (built with 'array') and output strings of length 'dimension'. (printing a 2d grid of a 1d array of dimension 'dimensions' ) ?
11:29:28 <vixey> ohh I see
11:30:16 <vixey> > null . foldl (\s y -> case s of x:xs | [x,y] `elem` ["()","[]","{}"] -> xs; _ -> y:s) [] $ "([)]"
11:30:17 <lambdabot>   False
11:30:24 <BrokenClockwork> that's really crazy stuff *sigh* ^^
11:30:35 <vixey> no I don't see :)
11:32:01 <dons> solussd: using a list comprehension?
11:32:20 <solussd> using whatever will work. :)
11:33:25 <lilac> > let w l | take 2 l `elem` [")(","][","}{"] = drop 2 l | otherwise = l in null . foldl (\a b -> w (b:a)) [] $ "()"
11:33:26 <lambdabot>   True
11:33:40 <lilac> @pl \a b -> w (b:a)
11:33:40 <lambdabot> (w .) . flip (:)
11:33:44 <lilac> :( too long
11:33:57 <FunctorSalad> ISTR someone here said that that haskell ADTs are more like cofree algebras than free algebras, due to lazyness?
11:34:13 <FunctorSalad> anyone have a link on that handy?
11:34:16 <dons> mm
11:34:19 <dolio> You mean coalgebras?
11:34:24 <FunctorSalad> yes
11:34:29 <FunctorSalad> cofree coalgebras :)
11:34:37 <dolio> Haskell ADTs are actually both algebras and coalgebras.
11:34:41 <lilac> coffee? where?!
11:35:02 <solussd> how do i print each element in a list?
11:35:10 <lilac> mapM_ print
11:35:29 <aconbere> so I'm just learning, and struggling a little with IO, in particular I have a CSV file I'm interested in parsing and turning into a list of a particular type. And I have it parsing and converting to the type and acting on that stuff, but I feel constrained by the requirement to return type IO
11:35:55 <pumpkin_> you should unsafePerformIO it out ;)
11:35:55 <aconbere> I'm wondering how one might go about passing non-IO types out of a function that interacts with IO
11:36:00 * pumpkin_ watches himself get shot by everyone in the room
11:36:11 <lilac> aconbere: it's sensible to write a top-level driver which reads the file, calls a worker and print the result, where the worker is of type String -> [type]
11:36:35 <pumpkin_> aconbere: the reason they do that is that the pure functional-ness of it is tainted by the non-functional nature of reading from a file
11:36:43 <aconbere> pumpkin_: I understand that
11:36:47 <lilac> do { contents <- readFile filename; print $ parseCSVAndGetResult contents }
11:36:51 <dolio> @go tutorial coalgebras coinduction
11:36:55 <FunctorSalad> as lilac said :)
11:36:56 <lambdabot> http://citeseer.ist.psu.edu/jacobs97tutorial.html
11:37:00 <pumpkin_> so people normally do as much as they possibly can functionally, and then call those pure functional things from their tainted IO area
11:37:01 <FunctorSalad> thanks dolio
11:37:12 <pumpkin_> :P
11:37:20 <aconbere> but at some point I have native data types, and I would rather just be able to start working on them in that way, forgetting that I might have touched this inpure IO stuff :P
11:37:40 <pumpkin_> you must never forget!
11:37:41 <FunctorSalad> aconbere: parseCSVAndGetResult needn't know about IO
11:37:46 <aconbere> lilac: I'm not sure I understand what it means to "write a top level driver that calls a worker"
11:38:29 <dons> a function that calls another function, after marshalling data, the 2nd function does the majority of work
11:39:06 <lilac> aconbere: start by reading the file. take the output and pass that to a pure (no IO in the return type) function which does most of the work
11:39:32 <lilac> aconbere: see my example above ("do { contents <- ...")
11:40:07 <lilac> there, parseCSVAndGetResult :: String -> a, for some a of your choice (with a Show instance)
11:40:08 <aconbere> hmmm, doesn't that make acting abstractly on that resultant data extremely difficult?
11:40:20 <dons> aconbere: ?
11:40:22 <pumpkin_> aconbere: nope?
11:40:28 <dons> abstractly?
11:40:38 <lilac> aconbere: the only limitation is that you can't then do IO in your 'parse...' function (because it's pure)
11:41:00 <pumpkin_> aconbere: do as much of your work as possible on "abstract" data (just a string that you don't read in externally)
11:41:14 <pumpkin_> and then finally call that from the "concrete" reader
11:41:18 <vixey> zipper?
11:41:18 <aconbere> I mean... it means that inorder to act on it, I have to write either write a higher-order function that takes my functions to pass in, or hard code the work I want to do on that data?
11:41:31 <vixey> I changed this sthing out long and I still don't get it :(
11:41:43 <aconbere> pumpkin_: right, I just don't want to do the work... right there. I want to do the work once I have a list of data I know about :)
11:41:56 <dolio> vixey: The bracket matcher?
11:42:08 <pumpkin_> aconbere: and you'll only know what work you need to do once you have the data? :P
11:42:12 <pumpkin_> surely you can describe that in an algorithm
11:42:13 <lilac> vixey: i'm walking along a list like so:  (xs, y:ys) -> (y:xs, ys)
11:42:23 <pumpkin_> aconbere: or is the algorithm interactive?
11:42:35 <aconbere> pumpkin_: it's more... me exploring a dataset
11:42:50 <pumpkin_> so it's interactive?
11:42:57 <solussd> lilac: can I get it to print without the quotes around the output? like printStr, but with a newline after each item?
11:42:59 <vixey> ok
11:43:04 <aconbere> so it's a pain to add in things like "length" to print out from the impure function so I can figure out how long a list is that we already know is all native datatypes
11:43:36 <lilac> solussd: i'm guessing your elements are Strings?
11:43:42 <solussd> lilac: yes
11:43:43 <Giraffe> for anybody who's worked with HDBC: does prepare automatically escape the query to prevent SQL injection attacks?
11:43:44 <vixey> yes
11:43:46 <Giraffe> i can't figure it out
11:43:49 <FunctorSalad> aconbere: in ghci? just write "myPureStuff ... `liftM` dataTrappedInIOMonad"
11:44:04 <lilac> solussd: in that case, how about "print (concat myListOfStuff)"
11:44:11 <vixey> Giraffe, all I know is that the compiler doesn't typecheck code inside strings
11:44:18 <lilac> solussd: ah, newline after each (sorry)
11:44:44 <Giraffe> vixey, it's not the compiler i'm concerned about, it's Database.HDBC.prepare
11:44:48 <lilac> solussd: do you want a newline on the end too?
11:45:02 <solussd> :lilac preferably, yes.
11:45:36 <BrokenClockwork> so Maybe a can be "Nothing" or "Just a" as in "only one a" ?
11:45:43 <lilac> solussd: either "mapM_ putStrLn yourStuff" or "putStrLn (intersperse '\n' yourStuff)"
11:45:54 <Giraffe> BrokenClockwork, sorta
11:46:02 <pumpkin_> BrokenClockwork: a could be a list though
11:46:04 <pumpkin_> or anything else
11:46:04 <solussd> lilac: thanks
11:46:23 <BrokenClockwork> so, how do I add something to this type?
11:46:28 <lilac> solussd: the first one simply calls putStrLn for each element. the second concatenates the strings with newlines between, then writes that out.
11:46:33 <vixey> ooh I see how it works now
11:46:40 <solussd> lilac: works great!
11:46:42 <lilac> solussd: i'd be inclined to prefer the second form, since more if it is pure
11:46:49 <int-e> > null . foldl (\s y -> if y:take 1 s `elem` [")(","}{","]["] then tail s else y:s) [] $ "(([[]]))"
11:46:50 <lambdabot>   True
11:46:58 <daf> BrokenClockwork: add something to?
11:47:15 <solussd> lilac: ill use kthe second one, since i dont understand mapM_
11:47:15 <pumpkin_> BrokenClockwork: you mean like pull out the a from the Just and do something to it?
11:47:21 <lilac> > let w (x:xs) y | [x,y] `elem` ["()","[]","{}"] = xs; w s y = y:s in null . foldl w [] $ "()"
11:47:22 <lambdabot>   True
11:47:35 <vixey> solussd, mapM_ f is just sequence_ . map f
11:47:38 <lilac> int-e: that's one character longer i'm afraid
11:48:21 <BrokenClockwork> well I have data Bracket = Round | Curly | Square and type Situation = Maybe [Bracket] ... so, now I want it to let it be Situation [Circle, Square]
11:48:31 <BrokenClockwork> in the beginning it is empty []
11:48:45 <lilac> int-e: you can get away with only doing one (:) with (\s y -> let s' = y:s in if take 2 s' `elem` ... then tail s else s') -- but that's longer still :(
11:49:16 <saml> > 1 `elem` 1
11:49:17 <lambdabot>       No instance for (Num [t])
11:49:18 <lambdabot>        arising from the literal `1' at <inter...
11:49:21 <vixey> if you have got any closing brackets on the stack _nothing_ will pop them off
11:49:34 <lilac> BrokenClockwork: why do you have the 'Maybe' in Situation?
11:49:35 <pumpkin_> BrokenClockwork: liftM (*2) (Just 4) will give Just 8?
11:49:53 <lilac> vixey: that's right. closing brackets => already not possible to all match
11:50:05 <pumpkin_> BrokenClockwork: is that the kind of thing you're looking for? you can also pattern match on the contents of the Just
11:50:09 <vixey> lilac, my way uses Nothing instead of stack with a closing paren on it
11:50:09 <BrokenClockwork> because vixey suggest it me
11:50:40 <lilac> vixey: fair enough. i'm going for brevity not efficiency :)
11:50:58 * vixey is going for doesn't-take-her-20-mins-to-figure-out more than efficiency
11:51:10 <vixey> also I think yours is as efficient as mine
11:51:17 <vixey> (i.e. mine doesn't shortcut)
11:51:24 <lilac> ah, ok then :)
11:51:35 <vixey> unless some sort of monadic foldl was written
11:51:44 <BrokenClockwork> well I have no idea how to use Maybe yet, also I've looked up http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
11:51:46 <lambdabot> Title: Data.Maybe, http://tinyurl.com/629vte
11:51:56 <vixey> BrokenClockwork, you just pattern match on it
11:52:17 <BrokenClockwork> I only know pattern matching on lists
11:52:19 <vixey> like  foo (Maybe (Round:stack)) ')' = Just stack
11:52:44 <Jedai> vixey: foo (Just ..) = rather no ?
11:53:17 <blazzy> When I get run time pattern matching errors I feel like I'm using a dynamically typed language.
11:53:43 <saml> blazzy: why?
11:53:48 <lament> all functions should be total!
11:53:49 <saml> ah run time
11:53:50 <Jedai> blazzy: Are you aware that GHC can tell you when your pattern don't cover all cases ?
11:54:18 <blazzy> Jedai: no I was not.
11:54:34 <vixey> total is sound and complete -- you want everything to be complete but soundness (termiation) shouldn't be a requirement in haskell
11:54:35 <Jedai> blazzy: It's one of the warnings (included in -Wall)
11:55:19 <daf> BrokenClockwork: if you have a list of something, you can prepend an item with :
11:55:23 <blazzy> Jedai: Sweet. Thank you.
11:55:31 <Jedai> blazzy: There's also a tool called Catch that's even more powerful
11:55:42 <daf> BrokenClockwork: and you usually take things off using a pattern match
11:55:45 <saml> -Wall -Werror
11:56:02 <jsn> blazzy: you can add it to your ".ghci" with     :set -Wall    so whenever you load your code, it will check that stuff
11:56:33 <Jedai> It can determine if in some situation your pattern cover all possibilities though they don't cover all the value of a type
11:56:45 <lilac> > let s x | take 2 x `elem` ["()","{}","[]"] = drop 2 x; s (x:y) = x:s y in or . fmap null $ iterate s "()"
11:56:47 <lambdabot>   True
11:56:49 <jsn> Jedai: interesting
11:56:59 <jsn> Jedai: where is it?
11:57:01 <vixey> lilac, I see how it works now but how it related to a zipper?
11:57:21 <Jedai> jsn: It's a tool by Neil Mitchell look on his home page
11:57:32 <mauke> @where catch
11:57:32 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
11:59:23 <lilac> vixey: well, a list zipper is just a structure (a,b) such that the original list is reverse a ++ x ++ b
11:59:42 <lilac> vixey: and that's the same thing i'm doing here, more or less
12:00:02 <vixey> hm...
12:00:10 <lilac> it's just a way of traversing a list which makes it cheap to move backwards as well as forwards
12:00:34 <roconnor> reverse a ++ [x] ++ b
12:00:48 <lilac> typo :)
12:00:54 <vixey> That's a really cool way to look at it
12:01:09 * lilac out
12:01:24 <vixey> where is there more examples of zippers over other things than just a list?
12:02:02 <roconnor> vixey: http://en.wikibooks.org/wiki/Haskell/Zippers
12:02:09 <mattam> vixey: Conor's paper on differentiating data structures
12:02:21 <roconnor> Conor's paper tells you how to make a zipper for any recursive datatype
12:02:27 <mattam> Hi guys.
12:03:06 <roconnor> but don't get zippers and derivatives confused.
12:03:06 <vixey> hi
12:03:15 <roconnor> they are very similar but different
12:03:24 <mattam> Yes. The paper explains it.
12:03:36 * roconnor was confused for a long time
12:03:47 <bwr> hi, how do i get the current time in haskell?
12:03:47 * vixey I am confused
12:03:56 <vixey> @localtim
12:03:57 <lambdabot> Maybe you meant: localtime localtime-reply
12:04:21 <mauke> bwr: I'd look at Data.Time.*
12:04:28 <bwr> yea, i have, but maybe i'm stupid
12:04:45 <mauke> what are you going to do with the time?
12:05:15 <bwr> i want to add a random amount of time to it and print it out in ISO8601 format
12:05:29 <roconnor> bwr: local time, UTC, universal time. :)
12:05:36 <mauke> what's that?
12:05:37 <roconnor> er or
12:05:38 <BrokenClockwork> Why should I use Maybe if I could use Bool?
12:05:46 <roconnor> bwr: local time, UTC, or universal time. :)
12:05:57 <bwr> roconnor: what do you mean?
12:06:03 <bwr> oh
12:06:06 <bwr> that's a question
12:06:09 <bwr> UTC
12:06:21 <roconnor> excellent choice
12:06:35 <roconnor> getCurrentTime :: IO UTCTime
12:06:36 <roconnor> Get the current UTC time from the system clock.
12:06:44 <roconnor> from Data.Time.Clock
12:06:46 <vixey> BrokenClockwork, Bool doesn't hold a Situation
12:06:54 <BrokenClockwork> woops, sorry
12:07:00 <BrokenClockwork> doesn't hold?
12:07:08 <bwr> oh so i bet you have to do :: UTCTime when i use getCurrentTime?
12:07:16 <bwr> i actually tried that one
12:07:25 <bwr> but i just did time <- getCurrentTime
12:07:32 <roconnor> that should be fine
12:07:44 <roconnor> I just gave the type to prove to you you were getting universal time.
12:08:10 <BrokenClockwork> maybe I should look for an example with Maybe before I try it on my brackt test, because I did not understand its intention yet
12:08:56 <daf> BrokenClockwork: how were you thinking you might use Bool?
12:10:02 <BrokenClockwork> I could create a list of three bools [True, True, True] and opening a )-Bracket it would turn [False,True,True]
12:10:22 <vixey> does the list always have 3 items in it?
12:10:32 <BrokenClockwork> no
12:10:39 <BrokenClockwork> not when I have (( ))
12:10:40 <BrokenClockwork> damn
12:11:02 <bwr> i am getting crazy stuff like:
12:11:11 <bwr> $ ghc calgen.hs -o calgen
12:11:11 <bwr> calgen.o: In function `rRW_info':
12:11:12 <bwr> (.text+0x46): undefined reference to `timezm1zi1zi2zi0_DataziTimeziFormat_formatTime_closure'
12:11:15 <bwr> and so on
12:11:23 <mauke> bwr: ghc --make calgen.hs
12:11:26 <bwr> ah
12:11:37 <bwr> much thanks
12:11:39 <mauke> (or '-package time', but that takes too long to type)
12:11:54 <mauke> preflex: zdec timezm1zi1zi2zi0_DataziTimeziFormat_formatTime_closure
12:11:54 <preflex>  time-1.1.2.0_Data.Time.Format_formatTime_closure
12:12:01 <pythonist> Where's System.Log.Logger for ghc 6.10?
12:12:12 <mauke> in case you're interested in the demangled symbol name :-)
12:12:16 <BrokenClockwork> so I have the type Situation = Maybe [Bracket] which says what? Nothing | Just [Bracket] what does it stand for? empty | filled ?
12:13:18 <roconnor> preflex is the most useful bot ever!
12:13:31 <bwr> lol
12:13:32 <int-e> > let ps = [] : [x:p ++ y:q | (p,q) <- scanl (flip (:)) [] ps >>= zip ps, [x,y] <- ["()","{}","[]"]] in ps
12:13:33 <lambdabot>   ["","()","{}","[]","()()","{}()","[]()","(())","{()}","[()]","(){}","{}{}",...
12:14:02 <mauke> preflex: zenc ["","()","{}","[]","()()","{}()","[]()","(())","{()}","[()]","(){}","{}{}",...
12:14:02 <preflex>  ZMz22Uz22Uz2cUz22UZLZRz22Uz2cUz22Uz7bUz7dUz22Uz2cUz22UZMZNz22Uz2cUz22UZLZRZLZRz22Uz2cUz22Uz7bUz7dUZLZRz22Uz2cUz22UZMZNZLZRz22Uz2cUz22UZLZLZRZRz22Uz2cUz22Uz7bUZLZRz7dUz22Uz2cUz22UZMZLZRZNz22Uz2cUz22UZLZRz7bUz7dUz22Uz2cUz22Uz7bUz7dUz7bUz7dUz22Uz2cUzizizi
12:14:05 <mauke> tee hee
12:14:19 <int-e> ouch.
12:14:30 <idnar> heh
12:14:51 <vixey> BrokenClockwork, Nothing means there was already a bracket mismatch
12:15:05 <jsn> how did that happen?
12:15:39 <vixey> Just []  --'('--> Just [Round] --'['--> Just [Square,Round] --'}'--> Nothing --']'--> Nothing
12:16:12 <jsn> oh
12:16:15 <vixey> if you write the function (---->) then foldl (--->) (Just []) runs through the text with it
12:16:26 <jsn> preflex: zenc 1
12:16:26 <preflex>  1
12:16:32 <jsn> preflex: zenc []
12:16:32 <preflex>  ZMZN
12:16:49 <BrokenClockwork> oh thanks alot, I think I am just before to udnerstand it ^^
12:17:00 <mauke> AWESOME IDEA
12:17:16 <mauke> use the FFI to call ghc-compiled functions in haskell libraries
12:18:14 <bwr> so uh, how do i add minutes to UTCTime
12:18:21 <int-e> preflex: zdec parseczm2zi1zi0zi1_TextziParserCombinatorsziParsecziPrim_zdf2_closure
12:18:21 <preflex>  parsec-2.1.0.1_Text.ParserCombinators.Parsec.Prim_$f2_closure
12:20:42 <CE> Hi
12:21:07 <dons> hello CE
12:21:20 <CE> I am desperatly trying to implement Eq for a simple tree structure
12:21:31 <CE> but I only get:  Cannot justify constraints in instance member binding
12:21:44 <CE> could somebody please have a short look at: http://pastebin.com/m1e671df7
12:21:55 <CE> any idea what's wrong?
12:22:07 <vixey> CE, change the deriving Show into deriving (Eq, Show)
12:22:33 <mauke> bwr: addUTCTime 60
12:22:37 <dons> CE, are you  using GHC, btw? Sounds like a hugs error?
12:22:46 <vixey> CE, (==) (Node2 a b t1 t2) (Node2 c d u1 u2) = (a == c) && (b == d) would be better written as Node2 a b t1 t2 == Node2 c d u1 u2 = a == c && b == d
12:22:48 <CE> yes, its hugs
12:23:05 <dons> probably a good idea to upgrade to a more modern haskell system. ghc's the only serious game in town now.
12:23:08 <dons> haskell.org/ghc
12:23:11 <CE> hmm, we learned it that way in university
12:23:13 <daf> CE: surely you need an Eq constraint for b as well
12:23:28 <dons> sigh. i wish people would stop teaching haskell with hugs. it's a toy. :/
12:23:33 <CE> yes, already thought that - however we _have_ to  use hughs
12:23:36 <dons> bah
12:23:37 <CE> yes it is
12:23:42 <int-e> hum
12:24:04 <dons> ghci's more comprehensive, has better error messages, is faster, and gives you the option of optimised native code.
12:24:07 <int-e> > head $ inits undefined
12:24:09 <lambdabot>   * Exception: Prelude.undefined
12:24:20 <int-e> > head $ inits []
12:24:21 <lambdabot>   []
12:24:25 <dons> i wonder if i should write a page on why lectuurers should stop using hugs.
12:24:31 <int-e> @src inits
12:24:31 <lambdabot> inits []     =  [[]]
12:24:31 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
12:24:41 <dibblego> dons, I was thinking exactly that :)
12:24:59 <daf> I'm guessing it's just a matter of habit
12:25:03 <dons> yes.
12:25:10 * int-e adds inits to the set of list functions that are stricter than necessary
12:25:11 <dons> they've taught hugs since 1995, so they'll keep doing so
12:25:18 <dons> int-e: yes, this is known
12:25:27 <dons> see the list fusion lib for a properly lazy implementation.
12:25:36 <CE> so you mean "instance (Eq a b) => Eq (HTree a b) where"
12:25:39 <CE> ?
12:25:41 <ski_>  
12:25:42 <lambdabot> ski_: You have 1 new message. '/msg lambdabot @messages' to read it.
12:25:50 <dons> Eq a , Eq b => Eq (Tree a b)
12:25:54 <ski_> @messages
12:25:54 <lambdabot> ddarius said 3h 4m 14s ago: It was Pseudonym who brought it up and I believe he does have references.
12:25:57 <pumpkin_> they use ghc at my college
12:26:16 <CE> pumpkin_: you're really lucky ;)
12:26:19 <dons> pumpkin_: yes. oxford, UNSW, PSU, Penn, Stanford etc. all do.
12:26:21 <dons> Chalmers.
12:26:27 <dons> its the out of the way places still using hugs, iirc
12:26:45 <int-e> dons: same for tails, I guess?
12:26:52 <dons> don't recall, but perhaps
12:27:01 <dons> int-e: there's notes in the source code for the stream-fusion lib
12:27:14 <dons> it was revealed with StrictCheck
12:27:14 <CE> so how do I add an eq statement for b as well?
12:27:16 <Deewiant> > tails []
12:27:17 <lambdabot>   [[]]
12:27:51 <andyjgill> KU also uses ghc, and teaches Haskell.
12:27:53 <dons> instance (Eq a, Eq b) => Eq (Tree a b) where ...
12:27:56 <dons> KU!
12:27:57 <vixey> CE, Are you somehow against deriving Eq?
12:28:01 <dons> all the serious places are using GHC.
12:28:22 <luite_> hm, UU uses Helium I think
12:28:23 <SamB> well, my school is still using MSVC++, so ...
12:28:31 <dons> UU do their own thing, as usual :)
12:28:36 <CE> as far as I know not, thats the reason why I am trying to implement it myself
12:28:39 <dons> they've got a stripped down teaching thing, so that's fine.
12:28:56 <pumpkin_> UU?
12:29:02 <dolio> Utrecht?
12:29:04 <luite_> yes
12:29:18 <dons> they also use ghc in latter years
12:29:29 <pumpkin_> a subset of haskell :o
12:29:31 <dolio> KU is Kansas?
12:29:36 <luite_> yes, the master courses are with ghc
12:29:37 <CE> :-/
12:29:38 <vixey> CE, If you derive it it gets written for you automatically
12:29:56 <vixey> CE, if you just write the program but don't put the type annotation it will figure out the type for you
12:30:01 <Deewiant> vixey: it's homework
12:30:02 <CE> well, but it would compare things I would not like to have evaluated
12:30:20 <CE> yes, its homework
12:30:42 <CE> but we have to use type annotations
12:30:46 <CE> hmm
12:31:09 <vixey> CE, that's silly but anyway if you leave it out you can just ask the compiler to tell you it
12:31:17 <vixey> (then paste it back into the code)
12:31:24 <CE> ah good idea, thanks :)
12:33:51 <int-e> dons: FWIW, stream-fusion uses the standard list implementation for inits and tails. (they're listed as todos).
12:36:38 <ivan_> hi, is it easy to build a data dependency graph from c code in haskell, maybe with bnfc?
12:36:49 <skorpan> yes, terribly simple!
12:37:00 <vixey> no
12:37:14 <lispy> ?faq is it easy to build a data dependency graph from c code in haskell, maybe with bnfc?
12:37:14 <lambdabot> The answer is: Yes! Haskell can do that.
12:38:29 <ivan_> ?faq is skorpan gay?
12:38:29 <lambdabot> The answer is: Yes! Haskell can do that.
12:38:37 <ivan_> lol
12:38:39 <SamB> ?faq can I be God ?
12:38:39 <lambdabot> The answer is: Yes! Haskell can do that.
12:39:34 <ivan_> ?faq is it possible to implement artificial intelligence in haskell?
12:39:34 <lambdabot> The answer is: Yes! Haskell can do that.
12:39:42 <leimy> So I think I need to combine IO with ContT and maybe StateT at the top layer, because it seems the ContT should wrap up the IO.
12:39:57 <leimy> how does one determine the right choice when figuring out Monad transformers?
12:40:05 <mauke> @kind ContT
12:40:06 <lambdabot> * -> (* -> *) -> * -> *
12:40:24 <mauke> @unmtl StateT s (ContT c IO) a
12:40:25 <lambdabot> s -> (a -> s -> IO c) -> IO c
12:41:38 <lispy> unmtl??
12:41:39 <lispy> whoa
12:41:49 <lispy> ?help unmtl
12:41:49 <lambdabot> unroll mtl monads
12:41:55 <lispy> unroll?
12:41:59 <lispy> in what way?
12:42:06 <BrokenClockwork> to my mind the Lambda calculus is the world together in its inmost folds. ^^
12:42:22 <mauke> lispy: inline and remove newtype wrappers
12:42:40 <Deewiant> @unmtl ListT m a
12:42:40 <lambdabot> m [a]
12:49:06 <BrokenClockwork> vixey: well, maybe you good look on the code I've done sof ar and if it's the approach you wanted to tell me: http://hpaste.org/12331
12:50:04 <BrokenClockwork> you told me to fold (function) on (Just [] ) but that doesn't any sense to me yet, shouldn't it be foldl (function) <String> ?
12:50:05 <vixey> change it to
12:50:11 <vixey> check '(' =
12:50:12 <vixey> check ')' =
12:50:18 <vixey> instead of check x | x == '(' ...
12:50:30 <pumpkin_> also, you won't be able to fold with that check will you?
12:50:35 <BrokenClockwork> oh so no guards, but exceptions or whatever to call it
12:50:38 <vixey> (check x) in the foldl should just be check
12:51:08 <vixey> (and needs another paremeter)
12:51:28 <pumpkin_> how is that check a -> b -> a?
12:51:30 <vixey> if <something> then True else False = <something>
12:52:50 <Cale> BrokenClockwork: Pattern matching :)
12:53:09 <BrokenClockwork> check xyeah thought on this, but didn't get it yet
12:53:10 <Cale> But hang on...
12:53:25 <Cale> That doesn't make any sense, given the type you've given check
12:53:31 <Cale> check is supposed to take a String
12:53:39 <Cale> but '(' is not a String, it's a Char
12:54:17 <Cale> What's the overall goal of this code?
12:54:28 <BrokenClockwork> check a  string of brackets
12:54:42 <Cale> To make sure that they're matched correctly?
12:54:45 <vixey> What you have there is on the right track
12:54:46 <BrokenClockwork> (()) = true  { ( } ) = false
12:55:10 <BrokenClockwork> brackettest (x:xs) is the new input
12:57:01 <LexStein> n00b alert
12:57:03 <Cale> The idea should be to maintain a stack of opened brackets (which is most easily represented using a simple list). When you hit an open bracket, you add it to the top of the stack (beginning of the list), and when you hit a close bracket, you check that the top of the stack is the matching opener, and remove it.
12:57:54 <Cale> Of course, the current stack and remainder of the string will be parameters to your recursive function. You could write it as a fold, but I'm not sure that's the most natural thing to do right off.
12:58:38 <LexStein> import Data
12:58:39 <LexStein> x = new Data.HashTable (==) (Data.hashInt)
12:58:44 <LexStein> GHC: Failed to load interface for `Data':
12:58:54 <Cale> LexStein: Data is not a module
12:59:04 <LexStein> ah ha
12:59:06 <Cale> LexStein: Also, Data.HashTable sucks and you shouldn't use it.
12:59:16 <LexStein> alternate recommendation?
12:59:19 <Cale> Data.Map
12:59:58 <orbitz> this is a naive question, but is there a good document that goes ove rteh differences btween a typeclass and a class in teh OO sense?
13:00:14 <Feuerbach> orbitz: yes, there was one on Haskell wiki
13:00:16 <LexStein> ok, thanks. i will try Data.map
13:00:21 <orbitz> Feuerbach: oh tahnks
13:00:33 <Feuerbach> orbitz: http://www.haskell.org/haskellwiki/OOP_vs_type_classes
13:00:36 <lambdabot> Title: OOP vs type classes - HaskellWiki
13:01:03 <BrokenClockwork> my problem is: check '(' = Just [Round] ... I don't know how I can add Round on this stack
13:01:17 <orbitz> Feuerbach: tahnsk a lot
13:01:17 <vixey> BrokenClockwork, (like I said a second ago needs another parameter)
13:01:42 <Cale> LexStein: Data.Map has the advantage that its interface doesn't involve IO, and is implemented internally with a binary balanced tree, which means that it doesn't have such severe size limitations.
13:02:09 <LexStein> that's quite practical
13:02:21 <ziman> Cale, what's so sucky about Data.HashTable (except being in IO)?
13:02:23 <BrokenClockwork> sth. like check '(' (Just []) = Just [Round]
13:02:57 <vixey> instead of [] you want the whole rest of the stack
13:03:02 <ziman> i've heard it's not that excellent but nothing specific yet
13:03:04 <Cale> ziman: It doesn't scale as well, and fails to be faster for sizes where it still works.
13:03:16 <vixey> and are the parameters in the right order?
13:03:25 <ziman> i see, thanks.
13:04:53 <Cale> Though, it might be a bit better now, I'm basing this judgement on tests that were done a couple of GHC versions ago.
13:05:07 <Cale> Still, the IO interface makes it fairly impractical most of the time.
13:07:51 <LexStein> the problem with Data,map is that it doesn't seem to allow insertion
13:08:08 <mauke> haha, what
13:08:14 <LexStein> and is possibly "pure" which I'm sure is beatiful and elegant
13:08:22 <mauke> :t Data.Map.insert
13:08:23 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
13:09:12 <SamB> LexStein: actually that's good for performance too
13:09:24 <LexStein> performance is not important here
13:09:34 <LexStein> i prefer to be dirty
13:09:38 <LexStein> than pure
13:09:43 <mauke> then why are you using haskell? :-)
13:09:46 <SamB> um, why Haskell then?
13:09:58 <SamB> and damnit mauke why are you faster than me ?
13:09:58 <LexStein> because i want to write small code
13:10:06 <mauke> LexStein: have you considered perl?
13:10:11 <EmielRegis> 'For "eqList :: (Eq a) => [a] -> [a] -> Bool" types of all elements in list must be the same, and types of both arguments must be the same too - there is only one dictionary and it know how to handle variables of only one concrete type'
13:10:15 <EmielRegis> i so hate that
13:10:19 <LexStein> i like type safety
13:10:32 <LexStein> but i don't care about "purity"
13:10:40 <LexStein> it's for religious nuts
13:11:04 <SamB> why do you say that ?
13:11:04 <Elly> use SML then :P
13:11:05 <mauke> EmielRegis: what's wrong with it?
13:11:33 <LexStein> i have for years, but the SML compilers are in rough shape
13:11:35 <EmielRegis> mauke, that you cant define a standard overloaded operator for two different types of argument
13:11:41 <EmielRegis> like scalar multiplication for example
13:11:43 <vixey> hey Elly
13:11:47 <Elly> mlton does an okay job
13:11:49 <Elly> hello vixey!
13:11:52 <EmielRegis> you can always use auxiliary functions to do that
13:11:52 <vixey> :)
13:11:58 <mauke> oh, that
13:12:00 <EmielRegis> but id prefer way of dealing with it in instance.
13:12:06 <vixey> LexStien, sounds like a troll
13:12:11 <SamB> LexStein: why do you think it's just about religion ?
13:12:12 <LexStein> yawn
13:12:18 * roconnor thinks purity is only for people who want to modify code.
13:12:22 <vixey> LexStien, but probably cut it out
13:12:57 <mib_myb37czq> hey guys o/
13:13:04 <EmielRegis> i think the greatest thing about purity is the ease of garbage collecting
13:13:06 <Elly> hi?
13:13:15 <mib_myb37czq> would someone be able to help me with this advb exercise please
13:13:20 <EmielRegis> on other hand, I think GC is in general a futile way of dealing with memory...
13:13:20 <Elly> EmielRegis: also it makes it a lot easier to reason about code
13:13:29 <mib_myb37czq> http://hpaste.org/12333
13:13:30 <Elly> EmielRegis: er, as opposed to...?
13:13:39 <SamB> EmielRegis: I always thought it was not having to wonder "now what could be changing this value?"
13:13:43 <EmielRegis> explicit memory allocationa nd deallocation
13:13:47 <EmielRegis> like in C++
13:13:52 <EmielRegis> its so much better imho
13:13:56 <Elly> EmielRegis: have you ever tried that in a higher-order language?
13:14:03 <vixey> EmielRegis, hm.. how does it mak GC easy? You still have cyclic data and polymorphism...
13:14:05 <EmielRegis> tried what?
13:14:07 <SamB> EmielRegis: well, Java has GC too
13:14:12 <Elly> explicit allocation
13:14:13 <vixey> EmielRegis, (two things which make GC difficult)
13:14:20 <EmielRegis> vixey, because the variables inside a function are not used outside it
13:14:36 <vixey> EmielRegis, you seen Bakers stuff about linear lisp?
13:14:41 <Elly> e.g., if you have: f :: a -> b and g :: b -> c, and you do map (f . g) something, who is responsible for cleaning up the intermediate result?
13:14:41 <EmielRegis> Elly, no I didnt, but i dont know any othe rhigher-order language than haskell
13:14:49 <EmielRegis> vixey, no, i dont code lisp ;)
13:14:50 <LexStein> vixey, sounds like a troll
13:14:52 <SamB> vixey: well, at least you don't have to constantly worry about writing pointers to new objects into old generations ;-P
13:15:03 <mauke> pretty much all languages except for C and C++ are higher order
13:15:03 <daf> I generally find that compilers and interpreters are much better at managing my memory than I am
13:15:07 <vixey> EmielRegis, check it out, it's really cool. sort of sounds like what you were saying
13:15:10 <SamB> but that's more of an implementation detail than a programmer concern
13:15:16 <Elly> mib_myb37czq: do you have a more specific question?
13:15:23 <EmielRegis> Elly, but the thing about pure functions make it really difficult for certain algorithms
13:15:29 <EmielRegis> that could use global variables effectively
13:15:30 <vixey> SamB: yeah just saying, I don't see why GC for haskell would be easier than ocaml for example
13:15:34 <EmielRegis> like a framebuffer
13:15:38 <mib_myb37czq> tbh im not to sure what to do or start
13:15:44 <mib_myb37czq> its really confused me
13:15:46 <vixey> (ocaml having mutation being the important difference)
13:15:46 <mauke> EmielRegis: why does a framebuffer have to be global?
13:15:46 <EmielRegis> which is generally too slow to be implemented with immutable haskell vars..
13:16:01 <EmielRegis> mauke, for example, if you want to have postprocessing one ach pixel
13:16:01 <Elly> EmielRegis: "pure functions make it really difficult to do an impure thing"?
13:16:04 <EmielRegis> that also affects other pixels
13:16:14 <EmielRegis> indeed Elly :D
13:16:17 <mauke> EmielRegis: so?
13:16:21 <Elly> I for one am stunned to hear that
13:16:38 <Elly> mib_myb37czq: okay, well, what does that expression type at the bottom mean in words?
13:16:49 <EmielRegis> mauke, as an example I wrote a HDR postprocessor for my raytracer
13:16:54 <SamB> vixey: well, I expect it isn't much easier -- and certainly it's no reason for choosing Haskell. I mean, it's only really relevant when you already decided you need a Haskell implementation ...
13:17:08 <mib_myb37czq> Its the test module to check that my module works
13:17:14 <roconnor> I won't argue that pure functions are more difficult, but there is no known algorithm that can be implement in a strict language with assignement side effects that cannot be implemented in a pure lazy language with the same azymotptic complexity.
13:17:18 <Elly> mib_myb37czq: no, the type declaration
13:17:21 <EmielRegis> not only it took ages to find a good algorithm *using data.map*, but also it became apparent that GC doesnt really handle combining a lot of data.maps together
13:17:28 <EmielRegis> which results in huge memory usage
13:17:29 <Elly> roconnor: asymptotic, by the way
13:17:32 <roconnor> @spell azymotpic
13:17:37 <roconnor> right
13:17:48 <SamB> lol
13:17:50 <mauke> EmielRegis: couldn't you use an array?
13:17:53 <roconnor> asymptotic
13:17:58 <EmielRegis> in C i could
13:18:07 <EmielRegis> but arrays are immutable in haskell arent they?
13:18:07 <mauke> EmielRegis: why not in haskell?
13:18:11 <mauke> wrong
13:18:15 <SamB> EmielRegis: have you profiled ?
13:18:18 <EmielRegis> well, I saw a mutable one but couldnt really figure out how to tackle them
13:18:22 <roconnor> STArrays are mutiable
13:18:22 <EmielRegis> samb, i did
13:18:25 <EmielRegis> nothign unusual then
13:18:31 <daf> I had memory usage problems with Data.Map recently
13:18:31 <EmielRegis> I tried to ensure strictness
13:18:32 <roconnor> IOArrays are mutable
13:18:32 <EmielRegis> and shit
13:18:34 <SamB> EmielRegis: have you profiled by type ?
13:18:35 <EmielRegis> didnt work either
13:18:40 <daf> but it turned out that I had a space leak in my code
13:18:45 <daf> and then it used hardly any
13:18:52 <roconnor> DiffArrays are pratically mutable
13:18:53 <EmielRegis> samb, it was all Data.Map's fault
13:18:57 <EmielRegis> I even rewrote my render function
13:19:07 <SamB> EmielRegis: are you sure you weren't just being too lazy ?
13:19:08 <EmielRegis> to check whats the mem usage of using list of pixels vs data map of it
13:19:13 <mib_myb37czq> elly im not too sure what you mean, i was given that last part to test if my code works
13:19:15 <SamB> there is a thing as too much laziness, you know
13:19:18 <EmielRegis> with strict foldl1'
13:19:27 <LexStein> vixey: Prelude> let d = Data.map.fromList []
13:19:36 <daf> SamB: I had a hard time even when profiling by type
13:19:41 <SamB> daf: yeah
13:19:43 <Elly> mib_myb37czq: the "data Expr" line? that's not a test case
13:19:48 <Elly> data Expr = ...
13:19:49 <LexStein> vixey: Failed to load interface for `Data':
13:19:51 <Deewiant> LexStein: capital m: Data.Map
13:19:51 <EmielRegis> and it became apparent that lazy lists use no more than 5 megs, while lazy data.map uses 40x more, unlazy ones using more than my ram+swap (they crashed)
13:20:03 <LexStein> vixey: GHCi
13:20:03 <daf> SamB: in the end, adding one ! fixed it, but finding out where to put it was a pain :)
13:20:04 <EmielRegis> i also compared
13:20:10 <EmielRegis> with fromList
13:20:12 <SamB> daf: typical
13:20:16 <LexStein> ah :)
13:20:19 <EmielRegis> and it was very very big too
13:20:23 <daf> (it was a foldl over a very long list)
13:20:29 <SamB> better tools for that would definately be useful
13:20:38 <vixey> LexStein, please do not do that
13:20:43 <daf> SamB: in GHC we trust
13:20:51 <LexStein> works fine, thanks
13:21:32 <EmielRegis> mauke, so how to use mutable arrays for purpose of framebuffer?
13:21:47 <SamB> EmielRegis: what type of renderer are you making anyway ?
13:21:48 <EmielRegis> I mean, how do they handle changing its members, etc.
13:21:51 <mauke> well, you'd probably want an unboxed array
13:21:59 <EmielRegis> samb, simple raytracer
13:22:07 <SamB> so why do you need to update the array ?
13:22:10 <EmielRegis> with reflection, refraction, antialising etc
13:22:15 <EmielRegis> because i wanted HDR
13:22:19 <SamB> hmm ?
13:22:24 <EmielRegis> and to get hdr you need to blur the pixels
13:22:36 <SamB> hmm ?
13:22:39 <EmielRegis> so each pixel in a data.map had effect on all its sorrounding pixels
13:22:44 <EmielRegis> blur and bleed actually
13:22:55 <SamB> um, wouldn't it make more sense to build a new image ?
13:23:03 <EmielRegis> http://images.gamedev.net/columns/hardcore/hdrrendering/Image2-HDRprocess.jpg
13:23:04 <EmielRegis> like this
13:23:07 <lambdabot> http://tinyurl.com/6xajpf
13:23:14 <EmielRegis> what new image?
13:23:31 <SamB> well, rather than trying to update the original image into the blurred one ...
13:23:46 <EmielRegis> I had too images
13:23:48 <EmielRegis> the original one
13:23:50 <EmielRegis> and then the HDR one
13:23:55 <EmielRegis> which were then superimposed
13:24:01 <SamB> superimposed ?
13:24:05 <EmielRegis> combined
13:24:22 <EmielRegis> with Map.union
13:24:24 <daf> EmielRegis: one map entry per pixel?
13:24:29 <EmielRegis> yes
13:24:38 <EmielRegis> I created them using Map.singleton
13:24:43 <EmielRegis> then union'd together
13:24:44 <daf> that doesn't seem like it would work well for large images
13:24:47 <mauke> oh wow
13:24:49 <SamB> It would make way more sense to use UArrays for this
13:24:57 <daf> definitely
13:25:00 <EmielRegis> oh it did
13:25:09 <EmielRegis> do arrays handle memory better?
13:25:22 <daf> it's the "unboxed" part that makes the difference
13:25:25 <mauke> did you really need so many singletons?
13:25:25 <SamB> arrays are just the right type for this
13:25:40 <EmielRegis> mauke, well, each pixel had to be a different entry
13:25:45 <SamB> and, well, unboxing is just the sensible way to go
13:25:48 <mauke> ?
13:26:17 <SamB> since it saves, what, 75% or more?
13:26:18 <daf> EmielRegis: I think mauke is saying that you didn't need to create lots of individual maps
13:26:22 <EmielRegis> I needed to have a singleton for each pixel
13:26:29 <EmielRegis> and then more singletons for each HDR pixel
13:26:29 <mauke> EmielRegis: why?
13:26:38 <EmielRegis> why why?
13:26:39 <EmielRegis> lol
13:26:44 <mauke> how does that even make sense?
13:26:51 <daf> you want one map in the end
13:26:54 <SamB> (how many words is an Int in i386?)
13:26:59 <EmielRegis> Map (Int,Int) (Colour)
13:27:01 <EmielRegis> that was my structure
13:27:02 <daf> why not just create one map and add pixels to it?
13:27:04 <EmielRegis> x,y and colkour
13:27:14 <SamB> daf: or use fromList ;-)
13:27:20 <daf> right
13:27:24 <mauke> EmielRegis: why create multiple maps?
13:27:27 <sjanssen> SamB: 8 bytes, I think (one tag, one is the actual unboxed Int)
13:27:30 <SamB> is there a zipWith for arrays ?
13:27:46 <EmielRegis> how is it different from creating one map empty map and adding entries to it?
13:27:52 <sjanssen> SamB: and if its stored in a Map, you've got to count the space used for the pointer to the Int too
13:27:53 <SamB> oh, in that case it might only be a 66% savings depending on what generation the Ints are in ...
13:27:56 <EmielRegis> besides that you have to pass the map as argument for each another function
13:28:02 <Deewiant> 8 bytes on a 64-bit machine
13:28:09 <SamB> sjanssen: I was comparing UArray against Array
13:28:12 <Deewiant> 4 bytes otherwise
13:28:17 <daf> EmielRegis: you don't have to allocate and free one map for each pixel
13:28:21 <daf> EmielRegis: less memory traffic
13:28:22 <sjanssen> Deewiant: you're not counting GHC overhead
13:28:29 <sjanssen> we're talking about Int, not "int"
13:28:31 <Deewiant> Ah, boxed Ints
13:28:52 <Deewiant> I just automatically think of the unboxed representation :-)
13:28:53 <sjanssen> SamB: UArray is array tag + n*wordsize
13:28:56 <SamB> the unboxed thing is Int#
13:29:03 <SamB> sjanssen: I'm aware ;-P
13:29:19 <sjanssen> SamB: Array is array tag + n*wordsize + 2*n*wordsize
13:29:38 <Deewiant> SamB: In my experience usually when people want the size of an Int they actually want the size of an Int# :-)
13:29:45 <SamB> sjanssen: wait, uh, isn't there like some other fields appart from the heap object pointed to by the Array# ?
13:29:49 <EmielRegis> hmm
13:29:56 <EmielRegis> ill try rewriting my code with UArray
13:30:14 <SamB> Deewiant: well, the "words" in my query might have been a good hint ;-)
13:30:22 <sjanssen> SamB: yeah, array size and index fields.  But UArray and Array have the same extra fields
13:30:26 <sjanssen> @src Array
13:30:26 <lambdabot> Source not found. It can only be attributed to human error.
13:30:30 <SamB> sjanssen: true
13:30:35 <EmielRegis> but its still immutable so I would have to pass the array to every instanc eof pixel change and then create another one with given entry and return new array
13:30:37 <EmielRegis> is that right?
13:30:46 <Deewiant> SamB: Maybe, maybe not. ;-)
13:30:50 <sjanssen> data Array i e = GHC.Arr.Array !i !i !Int (GHC.Prim.Array# e)
13:30:57 <SamB> anyway, I was going for a ballpark, which allows me to exclude all fixed fields anyway ;-)
13:31:14 <SamB> I mean, that only occur once for the entire array
13:31:25 <sjanssen> SamB: we end up with 3*n vs. n
13:31:47 <SamB> assuming the Ints are in the nursery, at any rate
13:31:56 <sjanssen> why does that matter?
13:32:07 <SamB> well, don't they get a size header if they aren't ?
13:32:18 <SamB> (or was that the other way round ?)
13:32:37 <sjanssen> I thought they always had a header?
13:35:31 <sjanssen> SamB: looking at the GHC commentary, I think we missed some things
13:36:21 <sjanssen> notably the info table pointer
13:36:32 <daf> EmielRegis: yes
13:36:46 <SamB> sjanssen: oh, well, does it even get a tag though ?
13:37:01 <EmielRegis> wouldnt it be easy to use STUArray for my case?
13:37:05 <daf> EmielRegis: though I think the compiler can optimise that quite aggressively
13:37:07 <SamB> er, or isn't that part of the info table?
13:37:25 <EmielRegis> at least for HDR pixels (which affect each other near them), while main array can stay U
13:37:38 <EmielRegis> then I could have some way of combining them?
13:37:39 <sjanssen> SamB: it's in the info table, yes
13:38:00 <sjanssen> but the info table is an indirection
13:38:29 <mib_myb37czq> could anyone help me, i am really confused on this exercise http://hpaste.org/12333
13:38:45 <dons> ?users
13:38:46 <lambdabot> Maximum users seen in #haskell: 558, currently: 554 (99.3%), active: 20 (3.6%)
13:39:13 <daf> dons: you are an addict
13:39:32 <dons> totally addicted to types.
13:39:34 <EmielRegis> mib_myb37czq, which part you dont understand? :)
13:39:34 <Nafai> Hi dons!
13:39:39 <SamB> dons: that isn't a type
13:39:41 <EmielRegis> you should probably be using pattern matches
13:39:45 <SamB> that is a bad statistic
13:39:46 <daf> what happened to "avoid success at all costs"? :)
13:39:53 <Cale> mib_myb37czq: What's confusing?
13:40:09 <dons> daf, bad idea.
13:40:20 <mib_myb37czq> i am so confused on where to start
13:40:22 <EmielRegis> btw, I was wondering - does haskell pass arguments by reference or value? I suppose its the former
13:40:26 <SamB> dons: but success is such a drag!
13:40:29 <mauke> EmielRegis: what's the difference?
13:40:32 <Botje> EmielRegis: it passes them by need.
13:40:34 <dons> :)
13:40:40 <EmielRegis> mauke, speed mainly
13:40:43 <sbahra> #haskell has more users than ##C, yet again.
13:40:44 <mauke> EmielRegis: wrong
13:40:47 <sbahra> By a good number this time.
13:40:48 <dons> sbahra: woot
13:40:49 <Cale> mib_myb37czq: Well, start by creating Expr.hs and ExprOps.hs, and placing the provided code and signatures in them :)
13:40:50 <EmielRegis> bullcrap
13:40:57 <dons> the 21st century officially beings *NOW*
13:40:58 <sbahra> 526 - 553
13:41:00 <dons> begins!!
13:41:01 <sbahra> dons, haha
13:41:03 <EmielRegis> passing a complex ADT by reference is way faster than copying it all
13:41:04 <daf> EmielRegis: it does neither
13:41:06 <mauke> EmielRegis: Haskell has no speed
13:41:13 <EmielRegis> O_o
13:41:16 <orbitz> #haskell tends to be the most talkative of every channel i'm in
13:41:16 <dons> it has the speed you will of it.
13:41:20 <mauke> EmielRegis: also, Haskell does not copy values, ever
13:41:25 <sjanssen> EmielRegis: it depends on the type passed, and how hard the optimizer is working
13:41:25 <mib_myb37czq> cale ive done that, been messing around with it for days now now lol
13:41:30 <Botje> EmielRegis: when would you pass by reference instead of value?
13:41:41 <ski_> daf : possibly got abandoned at about the time of "How to turn Failure into a List of Successes" (Wadler, who else ?)
13:41:44 <sjanssen> EmielRegis: for example, Ints that are used in the function are often unboxed and passed by value
13:41:44 <SamB> what is this reference/value distinction ?
13:41:45 <Cale> mib_myb37czq: Okay, and you've imported Expr from ExprOps, of course :)
13:41:48 <EmielRegis> Botje, always when having objects larger than 32bits
13:41:52 <daf> ski_: ha
13:41:52 <Nafai> dons: So your suggest last night of making a GHCI wrapper in Cairo and fanciness has me intrigued
13:42:08 <Botje> EmielRegis: okay. but there's another reason to pass stuff by reference.
13:42:10 <dons> Nafai: yes, i think it would be both a) awesome. b) easy
13:42:18 <EmielRegis> sjanssen, yea, i guess thats fine for 32bit data types, but for larger its qute inconvienient
13:42:22 <dons> Nafai: so good cost/benefit payoff
13:42:28 <EmielRegis> Botje, and that is?
13:42:34 <Botje> EmielRegis: modifying values :)
13:42:37 <EmielRegis> you mean immutable/mutalbe data?
13:42:44 <EmielRegis> ah ye
13:42:51 <Botje> since haskell does not have mutable references, there's no need for a call by value / call by reference distinction
13:42:52 <Cale> mib_myb37czq: For simplify, your goal should be to come up with a handful of rules which are going to be applied repeatedly at every place in the Expr until no rule applies.
13:42:56 <dons> EmielRegis: since Haskell's guaranteed to be pure-- values will never mutate -- we can by default share maximally
13:42:59 <Botje> so haskell always passes "by reference"
13:43:01 <Nafai> dons: So do you have something you can point me to for the ghci side of things?
13:43:06 <Botje> but even that's not quite true
13:43:12 <dons> Nafai: in what sense?
13:43:15 <Botje> haskell passes "by need", as people call it
13:43:16 <orbitz> EmielRegis: are you asking about the implementation details here or if haskell has a pass by value/reference concept?
13:43:16 <EmielRegis> what about mutable arrays?
13:43:20 <dons> i guess the most robust way would be a ghc-api binding
13:43:25 <Botje> EmielRegis: show me one :p
13:43:27 <EmielRegis> orbitz, concept rather
13:43:36 <dons> EmielRegis: right. in monadic contexts, you have precise choices about the semantics
13:43:36 <EmielRegis> Botje, http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-ST.html
13:43:38 <lambdabot> Title: Data.Array.ST, http://tinyurl.com/6xt7am
13:43:39 <EmielRegis> STUArray
13:43:46 <dons> via reference , by default, with mutable structures.
13:43:47 <Botje> that's in the ST monad
13:43:48 <Cale> EmielRegis: Mutable arrays are passed by reference to reference. ;)
13:43:52 <Nafai> dons: I guess just how to use the ghci to do the "repl"
13:43:55 <dons> for unboxed values, by value
13:43:57 <EmielRegis> well, monads are immutable by definition arent they?
13:43:57 <Botje> the ST monad is a no-mans-land as it is :)
13:43:58 <Nafai> dons: ghc-api, that is
13:44:06 <SamB> EmielRegis: the distinction only makes sense for mutable objects
13:44:12 <Cale> EmielRegis: Monads are type constructors, so mutability isn't even a question.
13:44:16 <mib_myb37czq> cale thanks for that, im gonna give it a little go, do you mind if i ask you questions?
13:44:25 <dons> Nafai: yes, so working out how to call the interpreter from ghc-api is the first
13:44:28 <dons> step
13:44:33 <dons> unless you want to use System.Process to talk to ghci
13:44:35 <Cale> mib_myb37czq: Not at all, and if I'm not around, feel free to ask the channel.
13:44:40 <SamB> and, well, those are always dealt with using references ...
13:44:49 <Nafai> I think the ghc-api method seems to be the "better" way
13:44:50 <EmielRegis> ah
13:45:07 <dons> Nafai: more robust, certainly
13:45:13 <dons> though we have to implement more.
13:45:49 <dons> Nafai: i'd be interested in working on thi
13:45:54 <dons> s. if someone can get it started.
13:46:06 <Nafai> Me too
13:46:26 <Nafai> It's a good intersection of my interests
13:46:30 <Nafai> GUIs and development tools
13:46:32 <dons> mm
13:46:50 <daf> EmielRegis: I guess you can say: semantically, it passes by value, sort of, but it is often compiled to code that doesn't copy
13:47:39 <Nafai> Well, GUIs, development tools, and compilers/interpreters
13:47:40 <EmielRegis> ok so for my example, if i have a recursive function that finds colour of each pixel in a row and then goes to next collumn, would creating an empty UArray of size of all pixels, and then 'adding' colours incermentally to it and passing the changed array to next pixel be the way of doing it?
13:47:44 <dons> you could never observe if it is value or reference, is the point.
13:48:37 <sjanssen> EmielRegis: updating a UArray should always be avoided if possible
13:48:48 <sjanssen> EmielRegis: can you create a list of pixels and create the array all at once?
13:49:29 <Nafai> dons: This would be a fun thing to hack on over my Thanksgiving break
13:49:51 <Giraffe> EmielRegis, are you implying you'd like to somehow have mutable data? D:
13:49:55 <Nafai> I could at least get started with the Cairo portion
13:50:22 <dons> Nafai: good idea.
13:50:23 <EmielRegis> sjanssen, I could, but then id suffer from huge memory usage again...
13:50:38 <EmielRegis> as atm the render function is lazy, as it writes to the output file line by line
13:50:39 <sjanssen> EmielRegis: why?  Just construct the list lazily
13:51:03 <EmielRegis> well, it is constructed lazily. but if i had to put it all in once in the array it would have to be strict no?
13:51:59 <EmielRegis> besides, I need to actually change the array because of the bleeding of HDR pixels (they access pixels behind and after them)
13:52:23 <erikc> hrm, is there a regex for lazy bytestrings?
13:52:28 <EmielRegis> I guess I could create many arrays and them blend them together in some way, but I dont think that would be memory efficient anyway
13:52:30 <sjanssen> ah, now I understand
13:52:45 <daf> Nafai: what are you working on?
13:52:46 <sjanssen> EmielRegis: maybe you want to use mutable arrays, like STUArray, perhaps
13:53:08 <EmielRegis> I was asking that before :P
13:53:15 <sinelaw> @seen Peaker
13:53:15 <lambdabot> Peaker is in #haskell. I last heard Peaker speak 3h 20m 48s ago.
13:53:19 <EmielRegis> sjanssen, would they work fast enough for this?
13:53:21 <sinelaw> @seen PeakerWork
13:53:22 <lambdabot> PeakerWork is in #haskell-blah and #haskell. I last heard PeakerWork speak 1d 7h 32m 9s ago.
13:53:30 <sjanssen> EmielRegis: STUArray is fast, yes
13:53:37 <mib_myb37czq> cale: Ive typed up my modules and made them clear, also did the import too and it works ok.
13:54:13 <EmielRegis> allrite, I should probably try it then
14:06:59 <Nafai> daf: Making a graphical REPL for Haskell
14:07:18 <daf> Nafai: interesting
14:07:23 <daf> Nafai: where does Cairo come in?
14:08:15 <Nafai> The fancy GUI rendering
14:08:20 <Nafai> It was actually dons' idea :)
14:08:46 <erikc> wow, amazing, got 1 gig of text being parsed with bytestring lazy and pcre now...in 142 lines of haskell... <3 <3 <3
14:08:58 <dons> Nafai: i could sketch some goals on the wiki page if you like.
14:09:11 <dons> erikc: should be easy :)
14:09:14 <dons> erikc: and fast!
14:09:23 <dons> erikc: I parsed 1T originally to test lazy bytestrings
14:09:23 <wjt> Nafai: that sounds like fun!
14:09:26 <dons> 1T / 6 hours.
14:09:37 <Nafai> dons: Yeah, that would be nice
14:10:21 <erikc> awesome, yea, i was using posix regex and strict bytestrings on my small test case, then tried the actual data and was despairing, then change 2 packages and it eats it up now
14:10:21 <saml> how would you generate ['a', 'b', 'c', 'd', ... 'aa', 'ab', 'ac', ... 'aaa', 'aab', ..] ?
14:10:47 <vixey> > [1..]
14:10:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:11:02 <saml> vixey: smart
14:11:07 <vixey> > map (flip replicate ['a'..'z']) [1..]
14:11:08 <saml> > read [1..]
14:11:08 <lambdabot>   [["abcdefghijklmnopqrstuvwxyz"],["abcdefghijklmnopqrstuvwxyz","abcdefghijkl...
14:11:09 <lambdabot>       No instance for (Num Char)
14:11:10 <lambdabot>        arising from the literal `1' at <inte...
14:11:15 <vixey> > map (sequence . flip replicate ['a'..'z']) [1..]
14:11:17 <lambdabot>   [["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","...
14:11:30 <Winterstream> I'm really confused as to what
14:11:31 <Winterstream> newtype StateT s m a = StateT { runStateT :: (s -> m (a,s)) }
14:11:31 <Winterstream> means...
14:11:34 <vixey> >sequence . flip replicate ['a'..'z'] =<< [1..]
14:11:40 <vixey> > sequence . flip replicate ['a'..'c'] =<< [1..]
14:11:41 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
14:11:47 <Winterstream> I see that runStateT is used with two parameters
14:12:13 <saml> lol i asked this question in ##PHP and it's hilarious
14:12:40 <Giraffe> saml, elaborate
14:12:42 <leimy> Winterstream: one for the function one for the initial state right? :-)
14:13:00 <roconnor> > liftM sequence ((liftM liftM liftM join) liftM (flip replicate ['a'..'c']) [1..])
14:13:01 <lambdabot>   Couldn't match expected type `m a' against inferred type `Char'
14:13:05 <Saizan> Winterstream: it's the same as newtype StateT s m a = StateT (s -> m (a,s)); runStateT (StateT f) = f
14:13:13 <Giraffe> roconnor, o god why
14:13:15 <Giraffe> oh*
14:13:17 <roconnor> damn
14:13:20 <Beelsebob> roconnor: *shudder*
14:13:28 <Winterstream> leimy: now I'm really confused :)
14:13:31 <Giraffe> stop that
14:13:39 <Winterstream> Why does the sintax work like that?
14:13:58 <pumpkin_> lol
14:14:00 <pumpkin_> what does that do?
14:14:02 <pumpkin_> what should it do?
14:14:03 <leimy> Winterstream: the "runState" thing is a little irritating, but it's really the data syntax :-)
14:14:12 <roconnor> I must have made a mistake with one of the liftMs
14:14:14 <leimy> at least that's what bugged me
14:14:23 <saml> @src replicate
14:14:24 <lambdabot> replicate n x = take n (repeat x)
14:14:25 <Stephan202> Winterstream: arguments to a constructor can be named, so that this name becomes a function that given the apropriate type, returns that argument
14:14:39 <Stephan202> (is that clear... I'm not sure :P)
14:14:43 <saml> i think it's similar to number base where digits are "abcde.."
14:15:40 <leimy> Winterstream: is it less confusing if you realize that the function runStateT is returning a function?
14:15:53 <roconnor> > (liftM liftM liftM join) liftM (liftM sequence (flip replicate ['a'..'c'])) [1..]
14:15:54 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
14:16:06 <dons> roconnor: huh
14:16:06 <roconnor> there we go
14:16:09 <vixey> WTF
14:16:12 <pumpkin> oh wow :P
14:16:14 <leimy> roconnor: generating all the combinations?
14:16:15 <Beelsebob> it's the fmap . fmap . fmap thing
14:16:17 <Beelsebob> only with liftM
14:16:21 <vixey> :t liftM liftM liftM join
14:16:22 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) (m2 :: * -> *) a. (Monad m2, Monad m1, Monad m) => m (m1 (m2 (m2 a))) -> m (m1 (m2 a))
14:16:24 <Beelsebob> and using liftM as (.)
14:16:26 <Beelsebob> and fmap
14:16:27 <Zao> Can't you just use showIntAtBase?
14:16:41 <roconnor> > (liftM liftM liftM liftM join liftM) (liftM sequence (flip replicate ['a'..'c'])) [1..]
14:16:42 <lambdabot>   Couldn't match expected type `Int' against inferred type `[[Char]]'
14:16:46 <roconnor> ah well
14:17:05 <Stephan202> @src showIntAtBase
14:17:05 <lambdabot> Source not found. Where did you learn to type?
14:17:06 <roconnor> oops that was dumb
14:17:07 <Modius> There is a massive investment in mastery of (say) Macros and dynamic language programming, and probably an equivalent investment in best-of-breed static typing and pure functional.  Seem to be fewer people with both, was wondering if anyone know of an article written by a master of both comparing these different techniques against coding projects of varying size/complexity/scope and team makeup. . . . .
14:17:26 <dons> Modius: macros vs static typing?
14:17:40 <roconnor> I discovered that (liftM liftM liftM join) liftM  is bind.
14:17:44 <saml> Zao: exactly
14:17:47 <dons> roconnor: huh
14:17:52 <dons> roconnor: you are evil.
14:17:59 <roconnor> @type (liftM liftM liftM join) liftM
14:18:00 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
14:18:01 <saml> > showIntAtBase "abcdefghijklmnopqrstuvwxuz" 353522
14:18:02 <lambdabot>       Overlapping instances for Show ([Char] -> String -> String)
14:18:02 <lambdabot>        aris...
14:18:14 <Modius> dons:  I know it sounds weird.  Macros are badass world changing blah blah, and any expert in them understands.  I imagine it's ditto for a haskell master.  I'd like to see what someone who is a master of both (and can't dismiss either) has to say about where each helps in software dev.
14:18:28 <Beelsebob> @type (fmap . (fmap join))
14:18:29 <vixey> why would you use showIntAtBase that doesn't make sense?
14:18:30 <lambdabot> forall a (f :: * -> *) (m :: * -> *) a1. (Monad m, Functor f) => (a -> m (m a1)) -> f a -> f (m a1)
14:18:37 <Beelsebob> not quite
14:18:48 <Giraffe> Modius, i honestly think it depends on both--i like them for different projects
14:18:58 <saml> > map showIntAtBase "abc" [1..]
14:19:00 <lambdabot>   Couldn't match expected type `[t1] -> t'
14:19:03 <vixey> Modius, Nobody in here fits that criteria?
14:19:05 <roconnor> @type (fmap . fmap) joing
14:19:06 <lambdabot> Not in scope: `joing'
14:19:07 <Modius> Giraffe:  Go   write that article :)
14:19:09 <roconnor> @type (fmap . fmap) join
14:19:10 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (m :: * -> *) a. (Monad m, Functor f1, Functor f) => f (f1 (m (m a))) -> f (f1 (m a))
14:19:24 <roconnor> hmm
14:19:38 <Giraffe> Modius, i'm merely a little college freshman, hardly an "expert" by any means :P
14:19:38 <dons> Modius: i'm not sure how they overlap?
14:19:47 <Giraffe> dons, they don't--that's the issue
14:19:49 <Modius> dons:  I'm not claiming they overlap
14:20:08 <leimy> So if they don't overlap...
14:20:12 <leimy> how to compare?
14:20:16 <leimy> apple to orange?
14:20:16 <dons> then how do we compare them..
14:20:22 * leimy ^5's dons
14:20:31 <dons> there are statically typed languages with macros, after all..
14:20:46 <Giraffe> i think Modius is asking more: LISP or haskell
14:20:49 <Elly> wait, there are?
14:20:50 <Giraffe> i could be wrong
14:20:50 <Elly> dons: do want
14:20:55 <leimy> Lisp vs Haskell is easy
14:20:56 <Modius> Compare against a standard of large project development:  "Feature X helped me up to mid-size project; but feature Y was better with 50 people on the team" blah blah
14:21:02 <leimy> implement lisp in Haskell is your answer :-)
14:21:02 <dons> Template Haskell for example.
14:21:05 <Modius> Giraffe: By macros I mean CL not lower substitutes
14:21:13 <Giraffe> Modius, right
14:21:22 <leimy> Ah
14:21:24 <vixey> Modius, wadler writes about this I think.......
14:21:25 <dons> Modius: oh, well, there's a gazillion large projects using static typing, no?
14:21:28 <Modius> I probably sound borderline language trolling but I ain't - just hard to find someone an expert in both.
14:21:31 <vixey> Modius, unless it was someone else
14:21:34 <leimy> one could compare the capabilities of Haskell to create a EDSL vs Macros in lisp.
14:21:36 <Modius> dons:  I don't count Java projects :)
14:26:54 <jsn> Modius: i think it's very hard to do the comparison
14:27:05 <Modius> jsn:  I don't doubt it
14:27:14 <leimy> Is that not what the computer language shoot out stuff does anyway?
14:27:24 <jsn> i also think it's pretty hard to find someone who has the expertise you are talking about
14:27:32 <leimy> makes dubious comparisons based on varying implementations of languages and implementations of solutions? :-)
14:27:40 <MyCatVerbs> leimy: but only in very well defined, quantifiable ways.
14:27:43 <vixey> jsn, I don't, I bet many people in here have much experience with both
14:27:44 <Modius> jsn:  It'd come down to seat-of-pants feel.  And yeah, it HAS been hard to find.
14:27:50 <MyCatVerbs> leimy: and even then, thye got problems. :)
14:27:53 <leimy> yes
14:27:57 <jsn> my boss has a lot of experience with CL and has expressed a lot of frustration with macros in Haskell
14:28:26 <mapreduce> Modius: Macros in lisp are mainly used to add laziness, afaik.
14:28:38 <leimy> macros in Haskell?
14:28:38 <jsn> i get the impression, though, that macros are pretty common in CL
14:28:42 <vixey> mapreduce, no I don't observe that
14:29:04 <jsn> whereas i rarely use macros
14:29:07 <mapreduce> While there are still lots of uses for macros outside that, it helps that Haskell has that out of the box.
14:29:12 <lament> yes
14:29:19 <mapreduce> jsn: You rarely use macros in CL?
14:29:23 <lament> it's not that macros are used to add laziness
14:29:27 <jsn> mapreduce: no, in haskell
14:29:33 <Modius> macros in CL get their effectiveness due to the language they're transforming as much as  anything else.  But I'm not here to talk about CL, just see if someone has explored these uber-powerful and radically different tools against software production from a position of knowledge.
14:29:38 <lament> it's that laziness eliminates the need for some macros
14:29:42 <vixey> macros are lazy evaluation though
14:29:50 <vixey> Oleg wrote about it...
14:30:02 <MyCatVerbs> vixey: they're necessary to create syntactic forms that don't necessarily evaluate all their arguments.
14:30:02 <vixey> you can do zipWith (+) fibs (tail fibs) with it
14:30:18 <vixey> (using DEFMACRO)
14:30:20 <MyCatVerbs> vixey: and you can implement a lazy language in CL macros.
14:30:21 <jsn> Modius: yeah, i am not really coming from a position of knowledge about CL macros
14:30:21 <lament> macros allow lazy evaluation
14:30:24 <Modius> I can take the discussion elsewhere; but this is a gross simplification of macros.
14:30:28 <lament> but they allow a bunch of other things too
14:30:34 <vixey> MyCatVerbs, no I'm saying taht it _already is a lazy language_
14:30:35 <Modius> And their purpose
14:30:59 <jsn> Modius: maybe you can provide an example, we can talk about how we would accomplish such-and-such thing in Haskell
14:31:03 <MyCatVerbs> vixey: oO
14:31:06 <Modius> I'll stfu now - I have downloaded a wadler seminar/speech, hopefully he has something to say.
14:31:08 <jsn> Modius: i have done this with my boss a few times
14:31:09 <vixey> MyCatVerbs, it's on Olegs site
14:31:19 <leimy> Macros in Lisp let you create things the language doesn't normally allow.
14:31:25 <vixey> except he uses scheme intstead of CL for some reason
14:31:30 <vixey> but I tied it with DEFMACRO work fine
14:31:31 <Giraffe> jsn, i don't think that's the main point...
14:31:34 <vixey> works*
14:31:34 <Modius> jsn: Turing-completeness, I'm sure for any little toy example we can get analogues; I wanted experience on larger software project.
14:31:42 <jsn> Giraffe: hmm?
14:31:43 <leimy> loop is a good example of a sublanguage in lisp that annoys and helps various people :-)
14:32:02 <Modius> jsn:  And you're damn lucky to work somewhere where the bi***ing is haskell vs CL instead of C#2 vs C#3 :(
14:32:12 <Elly> heh :P
14:32:17 <jsn> Modius: yeah i am
14:32:21 <LexStein> the nice thing about haskell is that after you go through all the pain of getting the thing to compile, it's probably a correct program
14:32:28 <Elly> I was at green hills over the summer and a lot of the bitching was about how much we collectively wanted to rewrite everything in haskell
14:32:29 <Giraffe> well figuring out how you can implement feature x in haskell is all well and good for haskell, but i don't know if that's what Modius is looking for
14:32:30 <LexStein> n00b comment
14:32:34 <jsn> LexStein: right
14:32:38 <vixey> Modius, what is it you actually wanted to know again?
14:32:44 <Modius> Lexstein:  Of course - I wanted to see someone quantify that vs large software without the guards.
14:32:51 <lament> Modius: dude, C#3 totally rocks :)
14:33:51 <leimy> LINQ!
14:34:03 <Giraffe> Modius, PM?
14:34:04 <Modius> vixey:  Person who is a master of CL macros and haskell give a spiel about the pros and cons in varying large/complex project situations, or in varying team sizes.
14:34:28 <leimy> I think if you code in lisp or haskell you're likely a team of 1 :-)
14:34:32 <leimy> so there you go.
14:34:33 <leimy> :-)
14:34:49 <vixey> Modius, oh right,  why would that be an interesting comparison?
14:34:55 <dons> Modius: don't use macros in large projects. use the language itself.
14:35:04 <jsn> Modius: if you can't get that information, then what?
14:35:41 <Saya> any good tutorial on state? ugh ... im having difficulties even making a counter that gets incremented every time you press a button :(
14:35:43 <Modius> I may have explained wrong - I just want a person who's an expert in both say how it turned out in large project
14:36:13 <vixey> Modius, Very well
14:36:15 <vixey> :)
14:36:22 <dons> Modius: i don't think there's such a person here.
14:36:29 <jsn> Saya: you have looked at State monad?
14:36:37 <BrokenClockwork> vixey: sorry, I could not continue the code... I made it so far: http://hpaste.org/12334 (problem: actually the ??? error ???, because should it be Just [] or Nothing?=
14:37:17 <Botje> Char -> -> Situation -> Situation?
14:37:28 <pumpkin> BrokenClockwork: you can replace any instance of if x then True else False with just x
14:37:32 <Saya> thats what im doing :)
14:37:52 <BrokenClockwork> oh, true :)
14:38:10 <pumpkin> BrokenClockwork: the fold is wonky, the x is in the wrong place
14:38:17 <jsn> Saya: and you've looked at Reactive stuff, like Phooey, maybe (since you have buttons)?
14:38:35 <jsn> this is the best EOL/EOF/strip combinator i have ever written
14:38:36 <jsn> http://hpaste.org/12335
14:38:46 <Botje> BrokenClockwork: why not have a successful computation end with Just [] ?
14:38:54 <Saya> im talking about buttons as an example i really want to get this ! but reactive is interesting too
14:38:59 <Botje> Nothing is traditionally used to say "something bad happened"
14:39:08 <BrokenClockwork> yeah that's my new code, wait I will update it, just a sec
14:39:20 <pumpkin> BrokenClockwork: why do you need a maybe? you're really just representing a stack with a list, and pushing to it when you see an open, and popping when you see a close
14:39:56 <BrokenClockwork> don't know yet, vixey suggested that as an approach for implementation
14:40:04 <Modius> Hopefully one day I can "be that guy".  I asked here as if such an article existed you would know about it - thanks!
14:40:06 <daf> BrokenClockwork: by the way: "if x then True else False" is the same as "x"
14:40:08 <BrokenClockwork> isn't maybe an approach for stack?
14:40:17 <vixey> Modius, There's a survey like I said before
14:40:29 <vixey> I can't remember who wrote it though..
14:40:30 <Botje> a list is an approach for a stack
14:40:35 <jsn> Modius: maybe let us know what you find out?
14:40:50 <Botje> Maybe just represents if the computation is still valid or not
14:41:41 <Saya> i get how to get / put into a state  when  in the state monad but say i want to do a counter and im   in the IO monad  ... i do something like "i <- liftM $ State (\_ -> return  0)" to get a coutner initialized to 0?
14:42:12 <Botje> Saya: you'd generally use StateT Int IO
14:42:15 <mauke> no, more like i <- newIORef 0
14:42:19 <Botje> or that.
14:42:28 <mauke> State doesn't give you multiple state variables
14:42:30 <Saya> yeah but say i want to store a whole lot more than an int
14:42:42 <BrokenClockwork> so should I stick to the Maybe-Idea or just try to simulate a stack with list?
14:43:00 <BrokenClockwork> http://hpaste.org/12336 so far
14:43:02 <pumpkin> I don't see what the maybe is buying you here, but maybe I haven't thought it through enough
14:43:12 <pumpkin> you still have that weird double arrow :P
14:43:24 <Botje> BrokenClockwork: what you just pasted is good
14:43:27 <BrokenClockwork> deleted ^^
14:43:30 <Botje> but please put spaces between Just and []
14:43:33 <Botje> it's a pain to read :)
14:43:53 <BrokenClockwork> true
14:44:55 <Saya> Like if i want to have a "mines" game and i have to store a grid with a state for each cell (thats what im trying to do for a starter). but an int is a good start :p
14:45:29 <pumpkin> BrokenClockwork: I don't see how you're adding to the stack with that check function though
14:45:37 <BrokenClockwork> I neither
14:45:57 <pumpkin> it seems like it only ever contains Nothing, Just [], or Just [Round]
14:46:13 <BrokenClockwork> yeah
14:46:17 <BrokenClockwork> hmpf
14:47:01 <pumpkin> it seems t ome like you'd want the second case to be Just (Round:rest) = Just rest
14:47:11 <pumpkin> which would essentially pop a round off the list
14:47:29 <BrokenClockwork> do you advice me to implement it without Maybe?
14:47:45 <BrokenClockwork> because I can't think into it right now :S
14:47:51 <Botje> BrokenClockwork: no, the maybe is fine. but your system can't handle multiple parens atm
14:47:54 <pumpkin> nah, the maybe looks like it'll tell you if it's broken
14:48:06 <p_l> ... is there somewhere a guide how to translate a Haskell program from main :: Dialogue to main :: IO () ?
14:48:16 <Botje> BrokenClockwork: you need to make your function work with arbitrary stack values instead of [] and [Round]
14:48:31 <Botje> so something like check '(' (Just xs) = Just (Round:xs)
14:48:47 <vixey> call it stack instead of xs
14:48:53 <dolio> Dialogue? How old is this program?
14:48:57 <Botje> and you need an extra case for when your stack is nothing
14:49:17 <BrokenClockwork> ah pattern matching again, man someone need to hammer this into my head :)
14:49:19 <mauke> oh, is that like [Input] -> [Output]?
14:49:23 <luqui> p_l, what is Dialogue?  from a library?
14:49:33 <pumpkin> BrokenClockwork: I annotated what I think you need, but didn't test it
14:49:52 <p_l> luqui: type Dialogue = [Response] -> [Request]
14:49:55 <BrokenClockwork> yeah sure ;)
14:49:56 <p_l> luqui: Ancient Haskell ;-0
14:49:58 <p_l> *;-)
14:50:00 <luqui> ahh
14:50:07 <pumpkin> BrokenClockwork: you can see the annotation if you reload the paste
14:50:24 <luqui> p_l, I think Dialogue is more expressive than IO, so there is no general way
14:50:31 <p_l> hmm
14:50:40 <luqui> p_l, by which I mean you could have request n depend on response n+1, which is absurd of course
14:51:02 <p_l> well, if the examples in the book are not too reliant on I/O it will be fine, I think
14:51:29 <dolio> If request n depends on response n+1, your program won't work.
14:52:05 <p_l> the latest code in the book is from 1995
14:52:06 <dolio> Presumably, at least.
14:52:31 <MyCatVerbs> dolio: which just means that Dialogue allows incoherent programs that IO wouldn't.
14:52:42 <luqui> dolio, except for the times when it will :-).   but yeah, IO prevents such absurdity.  I was just commenting on the unlikelihood of an algorithm to translate between the two.
14:52:49 <dolio> Yeah. I'm not sure if that counts as more expressive or not.
14:53:01 <pumpkin> it would be super expressive to depend on the future
14:53:08 <pumpkin> I'd like to make decisions based on the future
14:53:30 <MyCatVerbs> dolio: I think it does, if you squint at it just right.
14:54:00 <luqui> with mfix you can, as long as your decisions don't affect the future in certain ways.
14:55:00 <MyCatVerbs> dolio: you can't convert Dialogue to IO, because you can't predict the whether the Dialogue in question will ever prematurely consume a value. But you can translate IO a into (RealWorld -> (RealWorld, a)), and I think you could straightforwardly transform that into Dialogue.
14:55:13 <pumpkin> BrokenClockwork: does it work?
14:55:27 <Botje> i think BrokenClockwork is silently leaping with joy
14:55:46 <pumpkin> lo
14:55:46 <pumpkin> l
14:55:47 <MyCatVerbs> dolio: perhaps you could define a correctness-performing transformation from Dialogue to IO, though.
14:55:52 <pumpkin> it doesn't work, I just tried it
14:55:53 <p_l> ... /stream-based/ I/O model. This will take some time to understand...
14:56:08 <dolio> Well, you can probably just do 'newtype IO a = IO Dialogue' more or less.
14:56:29 <dolio> Or, if not that, then something similar.
14:56:49 <BrokenClockwork> no not yet :)
14:56:53 <luqui> execStateT (mdo { put (1:x); x <- get; return () }) []
14:56:56 <luqui> > execStateT (mdo { put (1:x); x <- get; return () }) []
14:56:57 <BrokenClockwork> I have to solve another problem
14:56:57 <lambdabot>       No instance for (Show (m [a]))
14:56:58 <lambdabot>        arising from a use of `show' at <...
14:57:05 <luqui> > execState (mdo { put (1:x); x <- get; return () }) []
14:57:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:57:24 <luqui> good reading from the future :-)
14:57:37 <BrokenClockwork> but I am very greatful for your advice, but the compiler is complaining about ..... brackettest x = ( foldl check x (Just [] ) ) == Just[]
14:57:46 <pumpkin> yeah, cause it's wrong :P
14:57:46 <vixey> less ()'s
14:57:53 <vixey> brackettest x = foldl check x (Just [] ) == Just[]
14:57:55 <p_l> main ~(Str jobs:Str techs:_) = [ReadFile "Job.data", ReadFile "Tech.data", AppendChan stdout output] -- that doesn't look like anything I had seen in Haskell....
14:58:13 <pumpkin> the check x needs to be just check
14:58:15 <tibbe_> anyone got any performance numbers on Data Parallel Haskell yet?
14:58:23 <erikc> im gonna go out on a limb and assume there are no elf/dwarf binary parsing libraries for haskell yet
14:58:30 <BrokenClockwork> but where does he take the string now?
14:58:54 <Botje> BrokenClockwork: flip the Just [] and x arguments
15:00:00 <pumpkin> BrokenClockwork: I annotated it again
15:00:01 <pumpkin> http://hpaste.org/12336#a2
15:00:25 <pumpkin> seems to work
15:00:54 <pumpkin> except if you start with a closing paren, you don't have a pattern to match with
15:01:21 <vixey> pumpkind, check (Just []) ')' = Nothing
15:01:47 <pumpkin> oh, jsut need to reorder
15:02:05 <pumpkin> oh wait, no
15:02:34 <pumpkin> hmm
15:04:39 <pumpkin> there we go, was missing the nothing case
15:04:47 <pumpkin> BrokenClockwork: make sense?
15:05:11 <jsn> what is the difference between sepBy, sepEndBy and endBy ?
15:05:36 <BrokenClockwork> yeah it does
15:05:50 <pumpkin> BrokenClockwork: now you can quite trivially write more patterns for the other bracket shapes, I think
15:05:58 <BrokenClockwork> also when I feel dirty, because someone else made my work, but fair enough as I have go to bed soon :S
15:06:04 <BrokenClockwork> yeah
15:06:08 <pumpkin> BrokenClockwork: aw, I'm sorry
15:06:13 <flonk> vixey: youwant a tough one to bite?
15:06:44 <BrokenClockwork> not your fault you were a big gelp, I think it would have taken me 3 others hours of explaining before getting it myself
15:07:32 <pumpkin> BrokenClockwork: anyway, you still need to add the other parentheses, which is a good test of understanding :)
15:07:42 <BrokenClockwork> yeah, that's true :)
15:07:44 <vixey> flonk, no idea what that means but go for it
15:08:13 <vixey> flonk, (wish you would stop changing nickname)
15:11:16 <hackage> Uploaded to hackage: hcheat 2008.11.25
15:12:10 <pumpkin> shouldn't hackage say "Uploaded to me: x"?
15:13:55 <idnar> heh
15:15:12 <wjt>  ! hackage NOM NOM NOM (:[ {- hcheat -} ])
15:15:23 <andun> why does last [1..] use so much memory? shouldn't it garbage collect everything on its way?
15:16:01 <idnar> @src last
15:16:01 <lambdabot> last [x]    = x
15:16:02 <lambdabot> last (_:xs) = last xs
15:16:02 <lambdabot> last []     = undefined
15:16:12 <idnar> hmm
15:16:31 <andun> i tried from ghci and with -O2 in a real program
15:16:33 <mauke> well, it's definitely not going to run in constant memory
15:16:49 <vixey> andun, try it ocaml or scheme? :)
15:16:57 <andun> :-P
15:17:22 <mauke> (define (f x) (f (+ 1 x))) (f 1)
15:17:36 <mauke> I bet this will also eat your memory
15:17:39 <ddarius> andun: If you did print [1..] in either GHCi or a compiled program it should use constant (live) memory.  Of course, it won't reclaim the dead memory until garbage collection so you will use a large constant amount of memory.
15:18:12 <andun> ddarius: it used 8G and froze my computer
15:18:19 <ddarius> If you just write [1..] in GHCi, or write something like list = [1..] in a compiled program then it won't be able to release the memory.
15:18:35 <sbahra> b4taylor, :)
15:18:43 <b4taylor> lol
15:19:02 <pumpkin> andun: what should last [1..] return? or you just expect it to run forever but not eat up memory?
15:19:21 <sbahra> b4taylor, once it compiles...
15:19:22 <ddarius> Oh wait, last [1..] is going to take a ton of memory.
15:19:25 <sbahra> b4taylor, mind tarring it up?
15:19:26 <andun> pumpkin: the last one, yes
15:19:32 <idnar> ddarius: why is that?
15:19:37 <sbahra> b4taylor, I could probably use that result on my box
15:19:47 <b4taylor> sbahra: It's not done yet/
15:19:49 <sbahra> b4taylor, before doing make clean
15:19:59 <b4taylor> 50 / 54
15:20:03 <b4taylor> Oh, sure.
15:21:21 <ddarius> idnar: It only needs one cell of the list, but it needs a thunk (that can't be reclaimed) per cell for each number.  Even if it forced the numbers as it went, the numbers grow in size unboundedly.
15:21:46 <b4taylor> building cabal now
15:22:11 <idnar> ddarius: well, make it [1,1..] so the numbers don't grow
15:22:42 <idnar> why can't the thunk be reclaimed?
15:22:44 <jsn> why is there so little documentation in Parsec?
15:23:13 <b4taylor> idnar: Is this in ghci?
15:23:29 <vixey> jsn, you saw the manual?
15:23:47 <jsn> i mean, in the docs on haskell.org
15:23:47 <ddarius> idnar: The thunk is succ (succ (succ (succ ... 1))).  It can't be reclaimed because it doesn't know it's never going to need it.  The next one points at the previous one.
15:24:07 <ddarius> And [1,1..] doesn't help in this case, but will if you force the elements as you go along.
15:24:13 <BrokenClockwork> pumpkin: it's working now for the other types, and yes it was a good excercise
15:24:14 <jsn> practically none of it has haddock
15:24:18 <idnar> b4taylor: the same thing happpens in ghci as in a compiled program
15:24:25 <pumpkin> BrokenClockwork: yay
15:24:26 <idnar> ddarius: oh, right, I see
15:24:37 <ddarius> @hackage parsec
15:24:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
15:24:50 <cjb> ddarius: is it possible to rewrite it such that it knows it won't need the earlier thunks?
15:25:24 <ddarius> cjb: Sure. last' _ = fix id
15:25:44 <b4taylor> Whoa.
15:25:45 <idnar> heh
15:25:47 <rwbarton> I think (hope) that 6.10 fixed a bug where the Enum instance of Integer wasn't strict like the Report specified
15:25:54 <b4taylor> Don't do: last $! [1..]
15:25:55 <jsn> vixey: where is the manual?
15:26:10 <ddarius> b4taylor: That's not any different than last [1..]
15:26:13 <vixey> @go daan parsec
15:26:17 <b4taylor> ddarius: Indeed.
15:26:18 <lambdabot> http://legacy.cs.uu.nl/daan/parsec.html
15:26:19 <lambdabot> Title: Parsec
15:26:32 <b4taylor> ddarius: I'm just glad I killed the process fast enough...
15:26:34 <jsn> aha
15:26:54 <jsn> it's under 'Text.Parsec' not 'Text.ParserCombinators'
15:26:59 <idnar> b4taylor: set some ulimits :P
15:27:06 <b4taylor> idnar: Indeed :p
15:27:07 <vixey> jsn, yeah I know that sucks they changed that for some reason
15:27:09 <b4taylor> I just wanted to try.
15:27:23 <b4taylor> I thought it would try to recalaim the memory.
15:27:24 <idnar> b4taylor: don't run this in a shell: :(){:|:&};:
15:27:25 <b4taylor> I guess not.
15:27:27 <vixey> jsn, basically that doc is still good though (apart from small changes)
15:27:56 <vixey> b4taylor, I tried to find a way to set a stack limit or something so it wouldn't matter if you did this .. but no luck
15:28:47 <idnar> vixey: ulimit -v?
15:28:55 <b4taylor> sbahra: I'm heading home, but the stuff is still compiling.
15:29:10 <Fallen_Demon> Does anyone know where I can get some stuff on how to get started on a Haskell/PosgreSQL module?
15:29:19 <b4taylor> sbahra: Oh, I'm stopping at the grocery store so it'll be an hour before I'm back on IRC.
15:29:28 <pumpkin> Fallen_Demon: I think there already is one
15:29:42 <Fallen_Demon> Yeah, HDBC
15:29:56 <Fallen_Demon> But I want to get my hands on some resources to use it
15:30:02 <b4taylor> and hsql
15:30:03 <Fallen_Demon> I have no idea where to start :(
15:30:12 <Fallen_Demon> HSQL is outdated, I think
15:30:25 <pumpkin> there was another one too iirc
15:30:48 <pumpkin> takusen
15:31:08 <sbahra> @where rwh
15:31:08 <lambdabot> is http://www.realworldhaskell.org/blog/
15:31:11 <sbahra> Fallen_Demon, go there.
15:31:19 <sbahra> Fallen_Demon, there is a chapter covering this.
15:31:37 <sbahra> Where "this" is HDBC.
15:31:45 <dons> Fallen_Demon: RWH has a chapter on RWH.
15:31:46 <pumpkin> takusen looks nice but apparently doesn't build on 6.10
15:31:48 <dons> on HDBC.
15:31:55 <dons> pumpkin: it does, but with a tweak.
15:32:00 <pumpkin> ah
15:32:14 <dons> hdbc is easier
15:32:25 <sbahra> dons, is HaskellDB any good?
15:32:32 <andun> so... any easy oneliners in haskell to use 100% cpu without eating too much memory? :)
15:32:35 <dons> haven't used it.
15:32:43 <dons> andun: hmm. main = main ?
15:32:43 <sbahra> Was my next question :)
15:32:55 <b4taylor> sbahra: It failed on libm.so.2
15:32:57 <Fallen_Demon> sbahra, thanks :)
15:33:03 <andun> dons: yeah, ufcourse :)
15:33:37 * b4taylor leaves work.
15:34:32 <andun> dons: hmm.. actually no. it detects the loop and sleeps instead
15:34:49 <dons> andun: well, try it in ghci
15:35:01 <dons> andun: or use, main = f () where f () = f ()
15:35:02 <pumpkin> oh my, don't
15:35:03 <pumpkin> :P
15:35:12 <andun> let f=f in f hangs, but it doesn't use much cpu
15:35:13 <pumpkin> my macbook air became almost unresponsive
15:35:14 <pumpkin> the whole thing
15:35:22 <pumpkin> when I tried it in ghci
15:35:30 <pumpkin> I managed to kill it before it killed me
15:35:32 <dons> hehe
15:35:33 <dons> yes.
15:35:45 <mauke> > fix error
15:35:46 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
15:35:56 <Elly> heh :P
15:35:59 <dons> that doesn't fix your errors, contrary to popular opinion.
15:36:04 <dons> if anything, it makes them worse.
15:36:05 <pumpkin> @src fix
15:36:05 <lambdabot> fix f = let x = f x in x
15:36:16 <pumpkin> :o
15:36:23 <pumpkin> :t fix
15:36:25 <lambdabot> forall a. (a -> a) -> a
15:37:04 <pumpkin> what is it used for?
15:37:09 <pumpkin> seems kinda silly
15:37:11 <mauke> recursion
15:37:34 <mauke> > fix (\self n -> if n < 2 then 1 else n * self (n - 1)) 5
15:37:35 <lambdabot>   120
15:37:43 <mauke> > fix (42 :)
15:37:43 <dons> pumpkin: its the recursion combinator.
15:37:44 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
15:37:52 <pumpkin> :o
15:38:14 <dons> like we have for other sorts of loops, so for basic recursion.
15:38:26 <mauke> recursion in a box
15:38:44 <pumpkin> I see, I see
15:39:13 <mauke> > fmap fix return ()
15:39:14 <lambdabot>   ()
15:39:36 <Elly> hm
15:39:49 <Elly> how does fix ever terminate?
15:40:00 <Elly> oh, I see, it takes an initial value
15:40:01 <mauke> laziness
15:40:06 <thoughtpolice> Elly: it doesn't in a call-by-value language
15:40:11 <pumpkin> is there a lambdabot command to show the generated core code?
15:40:11 <dons> > take 10 (fix (1:))
15:40:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
15:40:18 * Elly is an SML programmer :P
15:40:21 <thoughtpolice> Elly: there's a combinator analagous to Y for strict functions
15:40:25 <dons> sorry, Elly, my condolences.
15:40:29 <luqui> Elly, fix's initial value is _|_
15:40:31 <ddarius> > fix (1:) -- no initial parameter
15:40:33 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:40:33 <Elly> dons: I happen to rather like some bits of SML
15:40:38 <Elly> like structures and signatures
15:40:46 <dons> yup. sure.
15:40:49 <Elly> I don't know how to do signatures in haskell :(
15:40:49 <thoughtpolice> pumpkin: no, core is typically pretty huge - 'cabal install ghc-core' :]
15:40:53 <dons> its like haskell's father.
15:41:00 <dons> Elly: via type classes
15:41:05 <thoughtpolice> functors are cool. :]
15:41:10 <Elly> is there an example around?
15:41:14 <Elly> yes, functors *are* cool
15:41:21 * thoughtpolice has been reading okasaki lately and he uses them quite a bit
15:41:22 <dons> there are papers on the topic.
15:41:35 <Elly> I'm also not a fan of file-as-module for some reason
15:42:21 <thoughtpolice> afaics, whether or not haskell's record and module system are 'right' is still very much an open question
15:42:24 <ddarius> Elly: Yep.  It makes modules too heavy-weight so people don't use them as much as they should.
15:42:34 <ddarius> thoughtpolice: No it isn't.
15:43:04 <ddarius> thoughtpolice: Everyone knows that Haskell's record and module systems could be better.  The original design was very conservative.
15:43:27 <mauke> Elly: let rec fix f = f (fun x -> fix f x)  (* works in OCaml *)
15:43:56 <dons> so much syntax
15:44:00 <Elly> mauke: I suspect you could write it in SML too, but you'd need to thunk it
15:44:12 <mauke> what
15:44:25 <ddarius> Elly: You can write exactly what mauke wrote in SML.
15:44:30 <mauke> isn't OCaml basically SML with different syntax?
15:44:30 <Elly> oh, wait
15:44:39 <Elly> I should read, then comprehend, THEN type
15:44:47 <vixey> 'works'??
15:44:48 <dolio> @type \f -> last $ iterate f (\_ -> undefined)
15:44:49 <lambdabot> forall t a. ((t -> a) -> t -> a) -> t -> a
15:44:58 <vixey> I think you can't program with it
15:45:07 <mauke> vixey: I wrote factorial with it
15:45:10 <vixey> oh
15:45:14 <vixey> how come it terminates?
15:45:52 <mauke> because the lambda protects the inner call to fix
15:52:02 <lispy> I think the type of fix is interesting when you think about the curry-howard
15:52:06 <lispy> :t fix
15:52:07 <lambdabot> forall a. (a -> a) -> a
15:52:32 <vixey> ? why
15:52:37 <lispy> it says, give me a proof that a implies a, and I'll give you a proof of a
15:52:49 <mauke> fix id
15:52:53 <lispy> :t fix id
15:52:54 <lambdabot> forall a. a
15:53:02 <rwbarton> :t undefined
15:53:03 <lambdabot> forall a. a
15:53:06 <lispy> > fix id
15:53:08 <lambdabot>   * Exception: stack overflow
15:53:09 <olsner> lispy: hmm, so is that a valid proof in logic?
15:53:18 <vixey> olsner, which logic?
15:53:18 <vixey> a
15:53:33 * olsner incidentally tried to google for hurry-coward
15:53:44 <lispy> olsner: fix only seems to be as sound as the argument that you fix :)
15:54:02 <pumpkin> does anyone know what's going on with those probability monads? it seemed like a neat idea but haven't seen much about them since the original blog posts
15:54:15 <lispy> olsner: but  your question is precisely why I think it's interesting
15:54:21 <olsner> vixey: how should I know? :)
15:54:34 <lispy> fix seems to be absurd in the logics that are intuitive to me
15:54:42 <vixey> olsner, I think the question only makes sense with respect to a specific logic
15:54:49 <rwbarton> Proofs correspond to total terms, not things like fix id
15:55:00 <lispy> pumpkin: what probability monads?  these ones? http://ir.library.oregonstate.edu/dspace/bitstream/1957/696/1/mythesis.pdf
15:55:05 <lambdabot> Title: cache:http://ir.library.oregonstate.edu/dspace/bitstream/1957/696/1/mythesis.pdf ..., http://tinyurl.com/63jlzo
15:56:08 <dolio> Fix proves anything.
15:56:15 <lispy> pumpkin: that thesis has a shorter version that showed up at a conference but I don't know which
15:56:25 <pumpkin> lispy: nah, the ones mentioned on http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions and subsequent posts, and the ProbabilityMonads package in hackage (which seems to have been abandoned given build failures on 6.8 and 6.10?)
15:56:26 <ddarius> dolio: Not by itself, but forall a. a -> a is usually an axiom or admissable.
15:56:27 <lambdabot> Title: Refactoring probability distributions, part 1: PerhapsT, http://tinyurl.com/ythywo
15:56:34 <dolio> But, of course, undefined already does, too.
15:56:34 <rwbarton> "Theorem 1.  The statement P is true.  Proof: Apply Theorem 1."
15:56:37 <ddarius> lispy: fix simply makes the logic incensistent.
15:57:08 <lispy> ddarius: I'm rubbing off on you
15:57:11 <ddarius> lispy: If you add fix as a constant to an otherwise typical logic, than fix id is indeed a valid proof.
15:57:34 <lispy> pumpkin: ah, the first thing I see when I look at the blog post is a reference to the work in the link I sent you
15:57:38 <ddarius> lispy: Luckily, I still have a good long while before I'm as bad as you.
15:58:15 * ddarius remembers that he was planning on eating duck like a week ago.
15:58:52 <pumpkin> lispy: oh yeah :) but I was mostly asking about the hackage package, which seems derived from the extensions on top of that work by eric kidd
15:58:58 <lispy> ddarius: what do you mean by adding fix as a constant?
15:59:31 <vixey> axiom
15:59:33 <dolio> lispy: If your logic is otherwise consistent, you certainly can't prove fix by other means.
15:59:36 <ddarius> lispy: Take a normal logic, like classical propositional logic, and assert (a -> a) -> a as an axiom.
16:01:14 <lispy> Suppose we stick to a consistent subset of haskell.  You're saying we can't define fix?
16:02:41 <sbahra> ddarius, what does that do? (a -> a) -> a is a theorem.
16:02:47 <flonk> vixey: what is your job?
16:03:09 <sbahra> Ah.
16:03:12 <sbahra> ddarius, nevermind :)
16:03:17 * lispy thinks that vixey is really the result of vixen getting a new sentience module ;)
16:04:01 <dons> hehe
16:04:15 <lament> @vixen what is your job?
16:04:15 <lambdabot> I work and go to school
16:04:24 <lispy> ?djinn (a -> a) -> a
16:04:24 <lambdabot> -- f cannot be realized.
16:04:29 <sbahra> yup
16:04:34 <mauke> @vixey hello
16:04:35 <lambdabot> hiya
16:04:39 <lament> haha
16:04:53 <lispy> ?vixey Wanna prove some free theorems later?
16:04:53 <lambdabot> let me answer that later, okay?
16:04:58 <lispy> :(
16:05:10 <mauke> @shapr lispy
16:05:11 * lambdabot is overcome by a sudden desire to hurt lispy
16:05:24 <lament> @shapr
16:05:24 * lambdabot loves , so no slapping
16:05:28 <lispy> ddarius: is the failure of djinn to find f an example of your assertion that fix can't be proven in a consistent logic?
16:05:56 <lament> :t fix
16:05:57 <lambdabot> forall a. (a -> a) -> a
16:06:45 <lament> @src fix
16:06:45 <lambdabot> fix f = let x = f x in x
16:07:03 <lament> oh
16:07:07 <lament> of course it's inconsistent
16:07:07 <MyCatVerbs> lispy: thinking about it, Djinn would be unusable if it *could* find fix, because then it could just answer every possible query you pose of it with "fix id".
16:07:12 <lispy> if fix represents absurdity in logic but it is computable in general computability, then what does that say about logic and computability?
16:07:34 <MyCatVerbs> lispy: fix isn't necessarily computable, though.
16:07:34 <profmakx> lispy is making my head spin
16:07:45 <lament> fix can fail to terminate
16:08:02 <lament> so it's not much of a "proof"
16:08:04 <lispy> Okay, so it can be computed sometimes?
16:08:09 <lament> proofs are supposed to be finite!
16:08:36 <lament> lispy: yes, sometimes (a -> a) -> a is provable :)
16:08:43 <profmakx> undecidable things can be decided sometimes
16:08:51 <lament> for some values of a -> a...
16:08:56 <profmakx> thats the point of the "in general" part
16:08:57 <lispy> I still think it's interesting to consider fix in the framework of logic vs. computation.  Even if fix is sometimes bottom.
16:09:14 <lament> it seems very natural that you can't use bottom in a proof.
16:09:20 <lament> otherwise it's very easy to prove things.
16:09:32 <lispy> lament: fair enough
16:09:34 <MyCatVerbs> lispy: you need to decide an undecidable type system to be able to decide which functions will terminate when passed to fix. :)
16:09:44 <lament> eg the goldbach conjecture. Just examine all numbers.
16:10:05 <sbahra> @shapr shapr
16:10:06 <lambdabot> Come on, let's all slap shapr
16:10:13 <lispy> well, we know that the golbach conjecture is true practically speaking anyway :)
16:10:18 <MyCatVerbs> No. We like shapr.
16:10:39 <lispy> it's been tried for insanely large numbers and the bigger the numbers get the easier a solution becomes :)
16:11:30 <lispy> I wonder if you could prove golbach's conjecture by using an algorithm plus some other properties to  prove that the solution will exist for all naturals
16:11:56 <cjb> lispy: you should get right on that ;-)
16:12:00 <lament> er, proving that the solution will exist for all naturals would prove it, yes. :)
16:12:28 <lispy> lament: specically, I wonder if people have really tried the approach of proving via algorithm instead of proving via number theoretic properties
16:13:14 <lispy> I realize that the lines between computer science and mathematics would blur in that application, but I just wonedr if approaching it from a different point of view would lead to a proof
16:13:31 <sbahra> You should try it!
16:13:32 <lispy> it's one of those things that just _must_ be true...we just like the evidence
16:13:33 <mauke> http://blog.plover.com/math/lolbach.html
16:13:40 <lambdabot> Title: The Universe of Discourse : Variations on the Goldbach conjecture
16:14:09 <lament> also... what kind of bizarre logic system would allow (a -> a) -> a
16:14:19 <lament> a -> a is always true!
16:14:45 <dolio> The Haskell kind.
16:14:56 <lispy> Yeah, H-M allows it apparently
16:15:22 <lament> in other words, H-M allows all possible types
16:15:41 <rwbarton> Recursion allows it
16:15:46 <lispy> lament: really?  even without allow impredictavity?
16:15:52 <lament> i mean
16:15:53 <lament> (a -> a) -> a  => a
16:16:15 <lament> if it can be expressed as a H-M type, you can have a function of that type
16:16:17 <lament> which makes sense
16:16:31 <lament> would be pointless if you couldn't
16:16:41 <lispy> but, in haskell if you use (a -> a) -> a, by the means I can think of, then a turns out to bottom
16:16:58 <sbahra> lispy, what do you mean, "to bottom"?
16:17:03 <lament> lispy: sometimes
16:17:08 <lispy> > fix id -- sbahra
16:17:09 <lambdabot>   * Exception: stack overflow
16:17:36 <lispy> > fix (const undefined)
16:17:37 <lament> lispy: it bottoms, which would be fatal in a proof but just fine in software
16:17:38 <lambdabot>   * Exception: Prelude.undefined
16:18:20 <lispy> lament: you're not going to define nullity as undefined and claimed to have solved the problem of deciding undecidability are you?
16:18:36 <sbahra> haha
16:18:41 <lament> heh
16:19:17 <lament> lispy: that works, except when it still fails to terminate
16:19:55 <sbahra> > fix (+ 1)
16:20:10 <lambdabot>   thread killed
16:26:13 <ZhanweiZ> hello
16:31:01 <roconnor> > fix (0 `par`)
16:31:03 <lambdabot>   * Exception: stack overflow
16:31:19 <roconnor> > fix (`par` 0)
16:31:20 <lambdabot>   0
16:31:36 <roconnor> > fix (`pseq` 0)
16:31:37 <lambdabot>   * Exception: stack overflow
16:32:31 <lispy> lament: sorry, interrupted by $day_job
16:33:07 <lispy> lament: if fix means we can represent any type in the type system, I'm not convinced
16:34:13 <lament> @djinn a -> a
16:34:14 <lambdabot> f a = a
16:34:26 <lament> lispy: (a -> a) -> a means "everything is true"
16:34:58 <roconnor> means "everything is provable"
16:35:04 <lament> er, right
16:35:07 <lament> it's realizable
16:35:16 <lament> not simply true
16:35:28 <roconnor> best to leave truth out of mathematics :)
16:35:41 <lament> (a -> a) -> is equivalent to a
16:35:45 <lament> so a is realizable
16:35:49 <lament> so any type is realizable
16:36:19 <lament> :t fix id
16:36:20 <lambdabot> forall a. a
16:36:36 <lispy> lament: I think any type is realizable but there is an implicit universe
16:37:09 <FunctorSalad> roconnor: false ;)
16:37:13 <FunctorSalad> just kidding
16:37:16 <lispy> lament: there are places that higher rank polymorphism is not allowed in haskell types right?
16:37:16 <roconnor> ;)
16:37:48 <lispy> lament: due to predicativity/impredicativity (I forget which is which at the moment)
16:38:24 <lament> ok, that's an external restriction
16:38:38 <lament> but if we pretend it's not there, then fix id still gives a value of that type :)
16:39:19 <lispy> lament: in the same way that 'undefined' does?
16:39:23 * BMeph wonders if there's a European-style vanity plate on a car that reads: fmap fmap `fmap` fmap fmap...
16:39:28 <lament> lispy: yes...
16:39:29 <lispy> :t (fix id, undefined)
16:39:30 <lambdabot> forall a a1. (a, a1)
16:39:36 <lispy> > [fix id, undefined]
16:39:38 <lambdabot>   [* Exception: stack overflow
16:39:43 <lispy> :t [fix id, undefined]
16:39:44 <lambdabot> forall a. [a]
16:39:49 <lament> lispy: what else did you expect?
16:40:07 <lament> if you could actually prove every statement, we'd be kinda screwed
16:40:08 <FunctorSalad> (Void -> Void) -> Void looks pretty impossible already without undefined
16:40:09 <lispy> lament: I didn't expect something else, I just wanted to see it :)
16:40:40 <lispy> lament: now wait a sec.  Agda is based on the idea that if you can say it in agda then then you have to prove it right?
16:40:43 <dolio> Exception: <<loop>>?
16:40:58 <lispy> ?djinn (Void -> Void) -> Void
16:40:58 <lambdabot> -- f cannot be realized.
16:41:07 <Elly> ?djinn (a -> b)
16:41:08 <lambdabot> -- f cannot be realized.
16:41:13 <lament> lispy: i don't know agda but from what i've heard, yes
16:41:18 <lispy> lament: I guess you mean, all statements, not just correct statements
16:41:24 <lament> lispy: i.e. everything has to terminate
16:41:45 <lament> a "proof" is just a program that terminates...
16:41:58 <lispy> lament: any terminating program?
16:42:10 <lispy> throwing an exception is not termination if it goes uncaught right?
16:42:32 <FunctorSalad> pNpProof = error "solved :)"
16:42:32 <roconnor> not any terminating program.  Just the provably terminating.
16:42:37 <dolio> Agda doesn't have error.
16:42:43 <lispy> I agree that programs which terminate can be proofs, but are all terminating programs proofs?
16:43:09 <lispy> "programs be proofs"?
16:43:35 <lament> lispy: yes, by curry-howard isomorphism which djinn is based on
16:43:46 * roconnor thinks that all terminating programs are proofs in _some_ proof system, but not necessarily proofs in Agda.
16:43:54 <lament> lispy: http://en.wikipedia.org/wiki/Curry-Howard_Isomorphism
16:43:58 <gwern> @djinn foo :: (a,b) -> a
16:43:59 <lambdabot> Cannot parse command
16:44:05 <gwern> @djinn (a,b) -> a
16:44:05 <lambdabot> f (a, _) = a
16:44:09 <gwern> zom!
16:44:10 <lispy> lament: yeah, I've been looking at that page.  :)
16:44:39 <lispy> lament: It's still weird to me that a terminating program is a proof of its type
16:44:43 <roconnor> Agda cannot implement an Agda interpreter.
16:44:53 <lament> lispy: it's such a ridiculously beautiful result :)
16:44:59 <lispy> lament: not impossible weird, but the implications are profound
16:45:00 <roconnor> even though (we think) an Agda interpreter is terminating.
16:45:03 <Elly> yay currey-howard!
16:45:04 <lament> for sure
16:45:38 <lament> lispy: but it makes sense if you think about it... for what else is a proof?
16:45:53 <lament> it's a sequence of steps converting one sentence to another
16:45:55 <lispy> roconnor: but if we restricted the agda interpreter to say, 10000000 interactions  per session it could be implented it itself, right?  also, agda doesn't have co-data and co-recursion?
16:46:01 <lament> s/sentence/statement
16:46:16 <dolio> Agda does have codata.
16:46:16 <lispy> lament: oh hrm.  Yeah.
16:46:17 <lament> a finite sequence of steps, too
16:47:03 <roconnor> lispy: any program restricted to 10000000 interactions terminates trivally.
16:47:14 <lispy> roconnor: I've heard that at least in principle we should be able to bound algorithms in dependently typed languages by the asymptotic bound if we're having trouble implementing them in a proovably terminating way
16:48:08 <roconnor> lispy: sure, you can always do that.
16:48:11 <lispy> roconnor: but, even if we can't do that.  We could in principle (maybe agda doesn't support it) implement an non-ending interactive session via co-recursion
16:48:32 <dolio> Technically, Agda doesn't enforce termination conditions, it just has a checker that flags bad stuff in a brigh color, so you could write an agda interpreter in agda.
16:48:48 <lispy> roconnor: At least in the paper I read about total functional programming the author made that seem like a good idea
16:48:49 <dolio> Bright color, even.
16:48:55 <roconnor> lispy: yes, you can represent general recursion using the "non-termination" monad built using streams.
16:49:21 <lament> what stops it from not terminating?
16:49:38 <lament> also can agda do io?
16:49:50 <lispy> roconnor: well, the point of having corecurrsion instead of general recursion is that you are avoiding (a -> a) -> a, since fix is general recursion
16:50:00 <Saizan> yeah it has a ffi with haskell
16:50:24 <roconnor> lament: co-recurive data doesn't expand indefinately.
16:50:25 <lament> can agda somehow work on streams?
16:50:55 <lament> roconnor: why not?
16:51:17 <roconnor> lispy: right, you can define fix in the nontermination monad.  (a -> NT a) -> NT a.
16:51:17 <lament> the length of lists is part of the type?
16:51:18 <lispy> roconnor: the author aruged that we should explore supporting structural recursion and guarded recursion as substitutes to general recursion in the belief that useful programs do one or the other but that truely general recursion probably doesn't lead to meaningful programs
16:51:22 <roconnor> @type mfix
16:51:23 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
16:51:45 <Saizan> with corecursion you've to prove that you're going to produce another "constructor" in finite steps, afaiu
16:51:55 <roconnor> lament: all co-data doesn't expand indefinitely in order to preserve decidable type-checking.
16:52:06 <roconnor> it is only expanded on an as needed basis.
16:52:20 <roconnor> You cannot pull an a out of an NT a
16:52:22 <lament> is it done by keeping the size of data structures in the type?
16:52:36 <lispy> Saizan: right and the simplest way to do that is to use 'guarded recursion' which is analogous to structural recursion.  You only recurse after, say, applying a data constructor so you know you've produce a bit of somthing
16:53:02 <roconnor> lament: I don't know how Agda does it.  Typically corecursion isn't iota-reduced unless inside a case statement.
16:53:22 <dolio> Codata shouldn't be expanded at all.
16:53:39 <Saizan> lispy: yeah, finite steps meaning 0 steps there
16:53:49 <lament> haskell's infinite lists are an example of corecursion, yes?
16:54:01 <roconnor> lispy: well, general recursion leads to meaningful programs in the NT monad.
16:54:10 <lispy> lament: codata anyway
16:54:47 <roconnor> lament: ys
16:54:48 <roconnor> yes
16:55:45 <roconnor> unsafeGeneralRecursion :: NT a -> a
16:55:58 <lispy> This paper I'm reading had an interesting thing they refer to as a CPS transformation
16:56:24 <EvilTerran> Continuation Passing Style!
16:56:35 <lispy> They wanted something with signature e -> (exists a. a), but they noted that Haskell implements existentials via universals
16:56:52 <lispy> So, they rewrote it like this, e -> (forall a. a -> w) -> w
16:57:12 <Saizan> heh
16:57:31 <lispy> Now if we say that e in both types is distracting, we can rewrite it to (exists a. a) becomes (forall a. a -> w) -> w
16:57:37 <Saizan> that's the "naked" version fo data Any = forall a. Any a
16:57:45 <lispy> Now, that is kinda like fix, but it's a bit different
16:57:52 <EvilTerran> huh... slightly unusual use of CPS
16:58:04 <lispy> Saizan: yeah, taht was the point in this paper.  The author didn't want to use Exists
16:58:08 <roconnor> same way (a, b)  is the same as (a -> b -> w) -> w
16:58:21 <roconnor> @djinn (a, b) -> (a -> b -> w) -> w
16:58:21 <lambdabot> f (a, b) c = c a b
16:58:32 <lispy> ?djinn (a -> b) -> b
16:58:32 <lambdabot> -- f cannot be realized.
16:58:33 <roconnor> er
16:58:34 <EvilTerran> ?. pl djinn (a, b) -> (a -> b -> w) -> w
16:58:34 <lambdabot> f = uncurry (flip . flip id)
16:58:46 <roconnor> (a,b) is the same as (forall w. (a -> b -> w) -> w)
16:58:59 <roconnor> I don't think djinn will like going the otherway
16:59:02 <lament> does djinn understand foralls?
16:59:06 <EvilTerran> no
16:59:08 <lament> ah
16:59:16 <roconnor> (forall w. (a -> b -> w) -> w) -> (a,b)
16:59:20 <roconnor> @djinn (forall w. (a -> b -> w) -> w) -> (a,b)
16:59:20 <lambdabot> -- f cannot be realized.
16:59:27 <lispy> > id :: (forall a. a -> w)
16:59:28 <lambdabot>   Not in scope: type variable `w'
16:59:30 <lament> @djinn (forall a. a -> w) -> w
16:59:31 <lambdabot> -- f cannot be realized.
16:59:31 <roconnor> let me help you out
16:59:33 <EvilTerran> that would do horrible things to the complexity (if not decidability) of the problem
16:59:42 <lispy> > id :: (forall w. (forall a. a -> w))
16:59:43 <lambdabot>   Couldn't match expected type `w1' against inferred type `a1'
16:59:51 <MyCatVerbs> Are rank-n types actually undecidable, or just really expensive?
16:59:52 <roconnor> @djinn (a -> b -> (a,b)) -> (a,b)) -> (a,b)
16:59:53 <lambdabot> Cannot parse command
16:59:58 <roconnor> @djinn ((a -> b -> (a,b)) -> (a,b)) -> (a,b)
16:59:58 <lambdabot> f a =
16:59:58 <lambdabot>     (case a (\ b c -> (b, c)) of
16:59:58 <lambdabot>      (d, _) -> d,
16:59:58 <lambdabot>      case a (\ e f -> (e, f)) of
16:59:58 <lambdabot>      (_, g) -> g)
17:00:03 <lispy> So what does (forall a. a -> w) -> w, mean in logic?
17:00:27 <roconnor> w is unbound
17:00:33 <sbahra> \forall{a}[(a -> w) -> w]
17:00:48 <dolio> If all propositions imply w, then w is true.
17:00:49 <lispy> MyCatVerbs: Hmm...I thought that ghc has a way to do rank-n without being predicative and thus is decidable, but I didn't finish the paper I was reading on that...and I may just be completely wrong :)
17:00:57 <FunctorSalad> you can plugin a = True, no?
17:01:02 <EvilTerran> sbahra, isn't it explicitly \forall{a}[a -> w] -> w ?
17:01:20 <FunctorSalad> for maximum strength
17:01:22 <dolio> (Or provable, if you prefer.)
17:01:23 <lispy> forall w. (forall a. a -> w) -> w
17:01:38 <roconnor> dolio: heh, I restraind myself from pointing that out :)
17:01:39 <sbahra> EvilTerran, equivalent, w is unbound.
17:02:02 <dolio> :)
17:02:03 <lispy> dolio: so then, in some sense, (forall a. a -> w) -> w is dual to fix?
17:02:06 <MyCatVerbs> I suppose it would mean that w is true iff there exists any other true statement, and since we can always make up (w -> w) (since we know w must be defined), it's just saying that w is true.
17:02:44 <lispy> :t undefined :: forall w. (forall a. a -> w) -> w
17:02:45 <lambdabot> forall w. (forall a. a -> w) -> w
17:02:57 <lispy> :t const :: forall w. (forall a. a -> w) -> w
17:02:58 <lambdabot>     Occurs check: cannot construct the infinite type:
17:02:58 <lambdabot>       w = b -> forall a. a -> w
17:03:04 <dolio> lispy: I'm not really sure what you mean by that.
17:03:06 <lispy> What is a function with that type :)
17:03:31 <FunctorSalad> I was wrong, it is contravariant twice, so you should use a = False
17:03:32 <lament> \x -> x foo   -- where foo is anything?
17:03:33 <Saizan> lispy: that is just using the fact that Exists a == Not (Forall a. Not a)
17:03:34 <EvilTerran> sbahra, that's odd, i don't think the types are equivalent
17:03:42 <lispy> dolio: well, we went from having any proof of (a -> a) proving a, to needing that all proofs of (forall a. a -> w) proving w?
17:03:44 <EvilTerran> sbahra, because of the contravariance of -> in its first parameter
17:03:45 <dolio> lispy: (a -> a) -> a says that if a proposition 'a' can prove 'a', then that fact proves 'a'.
17:03:51 <sbahra> EvilTerran, I'm thinking of first order logic
17:04:29 <EvilTerran> sbahra, sure, but it still seems odd that they'd be equivalent when the respective types are non-equivalent
17:04:30 <yuuki> Is there a channel or a meeting place for people to talk about logic?
17:04:32 <sbahra> EvilTerran, in FoL, \forall{a}[a -> w] is equivalent to \forall{a}[a] -> w.
17:04:42 <yuuki> I'm interested specifically in linear logic
17:04:58 <FunctorSalad> yuuki: #logic
17:05:01 <sbahra> EvilTerran, yes
17:05:03 <dolio> lispy: (forall a. a -> w) -> w says that if any proposition 'a' proves 'w', then that fact proves 'w'. And as someone noted, True, the trivially provable proposition is one such 'a', so if we can prove w with it, then clearly we can prove w.
17:05:32 <EvilTerran> dolio, shouldn't that be "all propositions 'a'"?
17:05:38 <lament> @djinn (True -> w) -> w
17:05:38 <lambdabot> Error: Undefined type True
17:05:41 <lament> er
17:05:48 <lament> how do you use djinn again :)
17:05:52 <dolio> Sure. I guess 'any' is kind of overloaded.
17:05:54 <rwbarton> :t \f -> f () :: forall w. (forall a. a -> w) -> w
17:05:55 <lambdabot>     Cannot match a monotype with `() -> (forall a. a -> w) -> w'
17:05:55 <lambdabot>     Probable cause: `f' is applied to too many arguments
17:05:55 <lambdabot>     In the expression: f () :: forall w. (forall a. a -> w) -> w
17:05:56 <sbahra> @djinn (a -> b)
17:05:56 <lambdabot> -- f cannot be realized.
17:06:06 <dolio> @djinn (() -> w) -> w
17:06:06 <lambdabot> f a = a ()
17:06:12 <lispy> dolio: I'm struggling with the subtle difference between the two.  But, I think the difference is what does the first proposition prove?  Does it prove itself or does it prove something besides itself, right?
17:06:16 <EvilTerran> :t (\f -> f ()) :: forall w. (forall a. a -> w) -> w
17:06:17 <lament> dolio: aha, that's it
17:06:17 <lambdabot> forall w. (forall a. a -> w) -> w
17:06:20 <FunctorSalad> given f : (forall a. a -> w) -> w, I can always feed it the unique function from Void to w, and get a w, no?
17:06:29 <sbahra> dolio, cool
17:06:32 <FunctorSalad> so it is equivalent to w, logically anyway
17:07:21 <lispy> EvilTerran: cool
17:07:22 <FunctorSalad> hmm. think I moved out the 'forall' there
17:07:36 <lispy> > (\f -> f ()) id
17:07:38 <lambdabot>   ()
17:07:39 <Saizan> FunctorSalad: void :: forall w. Void -> w
17:07:45 <lispy> ;t (\f -> f ()) id
17:07:48 <lispy> :t (\f -> f ()) id
17:07:50 <lambdabot> ()
17:07:59 <lispy> :t (\f -> f ()) const
17:08:01 <lambdabot> forall b. b -> ()
17:08:17 <lispy> :t (\f -> f ())
17:08:18 <lambdabot> forall t. (() -> t) -> t
17:08:19 <FunctorSalad> Saizan: yes
17:08:44 <lispy> :t ((\f -> f ()) :: forall w. (forall a. a -> w) -> w) const
17:08:45 <lambdabot>     Inferred type is less polymorphic than expected
17:08:45 <lambdabot>       Quantified type variable `a' escapes
17:08:45 <lambdabot>     In the first argument of `((\ f -> f ()) ::
17:08:50 <lispy> ah ha
17:08:53 <lispy> :t ((\f -> f ()) :: forall w. (forall a. a -> w) -> w) id
17:08:54 <lambdabot>     Inferred type is less polymorphic than expected
17:08:55 <lambdabot>       Quantified type variable `a' escapes
17:08:55 <lambdabot>     In the first argument of `((\ f -> f ()) ::
17:09:15 <rwbarton> ((\f -> f ()) :: forall w. (forall a. a -> w) -> w) (const 3)
17:09:20 <rwbarton> > ((\f -> f ()) :: forall w. (forall a. a -> w) -> w) (const 3)
17:09:21 <lambdabot>   3
17:09:40 <lispy> :t ((\f -> f ()) :: forall w. (forall a. a -> w) -> w) (const 3)
17:09:41 <lambdabot> forall w. (Num w) => w
17:09:54 <sbahra> voodoo
17:10:18 <lispy> Curry-Howard is amazing
17:10:23 <lispy> I just want to say that...
17:11:22 <dolio> lispy: Do you get the difference now? I zoned out for a moment.
17:11:46 <lispy> dolio: Did you see my response?
17:11:52 <dolio> Yeah.
17:12:09 <lispy> dolio: so the difference is about the proposing proving itself vs. proving something other than itself?
17:12:19 <lispy> proposition*(
17:12:47 <dolio> lispy: If you think in terms of logic then '(P -> P) -> P' says given a proof that P proves itself, then you can get a proof of P itself. Which is weird.
17:12:58 <Elly> and not true
17:13:15 <dolio> '(forall Q. Q -> P) -> P' says that if anything at all proves P, then you can get a proof of P.
17:13:20 <Elly> under intuitionistic logic, \infer{C}{\bottom} for any C, so \infer{\bottom}{\bottom}
17:13:32 <Elly> which makes your system unsound
17:13:39 <dolio> Which is easy, since there's at least something in your logic that is provable, presumably.
17:13:46 <lispy> dolio: I thought that was the difference.  OK. thanks.
17:13:52 <dolio> So you just feed that in to get the proof of P.
17:14:18 <Fallen_Demon> Break herpesBot please :)
17:14:21 <lispy> intutionistic logic is said, in-two-shun-istic ?
17:14:29 <lament> haha
17:14:32 <Elly> lispy: in-two-ish-un-istic
17:14:42 <lament> lispy: it's also written intuitionistic
17:15:15 <lament> from the word tuition, because that's how professors get money to work on it
17:15:29 <gwern> @seen roconnor
17:15:29 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 13m 50s ago.
17:15:30 <lispy> heh
17:15:44 <Fallen_Demon> !math (4*3)/3+90*6
17:15:46 <gwern> roconnor: ping
17:15:46 <herpesBot> Fallen_Demon: 544
17:15:51 <lispy> I would have to practice that a bit
17:15:59 <roconnor> here
17:16:22 <gwern> roconnor: I forget, who marks packages obsolete/deprecated/hidden on hackage? was it you or dcoutts_?
17:16:25 <lispy> in-two-ish-un is hard for me, that "un" is "unnatural" to hit after in-two-ish
17:16:34 <Fallen_Demon> !math 4*3/4+9+8*3
17:16:36 <herpesBot> Fallen_Demon: 33
17:16:43 <lispy> gwern: dcoutts_ referred me to someone eles when I asked him
17:16:48 <lispy> gwern: so must be roconnor
17:16:55 <dolio> lispy: And you can kind of see how it's an eliminator for exists P. P, which says (I think) "I have a proof of something", so what can you do with it besides feed it to something that takes any proof at all, and returns another proof of something.
17:16:59 <roconnor> gwern: not me.  I have nothing to do with hackage.
17:17:09 <gwern> indeed? hm...
17:17:21 <roconnor> I got a hackage account a few weeks ago :)
17:17:27 <roconnor> now I can upload
17:17:31 <lispy> dolio: good observation
17:17:34 <Fallen_Demon> !help
17:17:42 <roconnor> @help
17:17:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:17:46 <lispy> gwern: i'll check my email
17:17:50 <gwern> @seen dcoutts_
17:17:50 <lambdabot> dcoutts_ is in #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts_ speak 6h 41m 33s ago.
17:17:56 <gwern> @seen dcoutts
17:17:57 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 1d 1h 7m 19s ago.
17:18:06 <Saizan> gwern: are you thinking of Ross Paterson?
17:18:13 <gwern> Saizan: ah, maybe that was it
17:18:23 <Fallen_Demon> roconnor, herpesBot is !help :)
17:18:31 <lispy> gwern: darn, he must have told me over irc
17:18:33 <gwern> ross paterson, roconnor, they would seem to have gotten con-fused in my mind
17:18:45 <gwern> Saizan: who's paterson here?
17:18:59 <Saizan> i'm not sure if he's here at all
17:19:15 <gwern> drat. I'll just leave a message for duncan then
17:19:35 <Saizan> you can contact him by mail
17:19:53 <Fallen_Demon> !quit
17:20:01 <Fallen_Demon> Oops :(
17:20:09 <Fallen_Demon> Should have pm'd it
17:20:14 <Saizan> hah
17:20:14 <gwern> Saizan: well, I don't remember for sure who handles marking packages obsolete/deprecated on hackage, so rather than email them both...
17:20:35 <Fallen_Demon> herpesBot at least looks at the name of the person telling it to quit
17:20:41 <gwern> @tell dcoutts_ Now that darcs is officially cabalized and stuff, there's no need for my darcs-cabalized to be listed on the main page. could you or ross mark it hidden or whatever?
17:20:41 <lambdabot> Consider it noted.
17:21:06 <lispy> gwern: so, I asked him too :)
17:21:08 <Fallen_Demon> !help
17:21:26 * lispy thinks he should be going home
17:21:54 <gwern> lispy: sure, but I was the uploader/maintainer, I'm the one whose permission is needed I suspect
17:22:25 <lispy> gwern: we were all hoping you'd agree I suspect :)
17:22:56 <gwern> I have no real reason not to. in the long run, I won
17:38:36 <Raevel> oh sad, aptitude says i can't install cabal since my ghc version is too recent
17:47:17 <lispy> Raevel: in that case you may already have cabal?
17:47:25 <lispy> Raevel: or do you mean cabal-install?
17:49:16 <Raevel> lispy: i'm not sure what the difference is, but i think i have neither
17:50:12 <lispy> Raevel: so cabal is a library and cabal-install is an application that makes it easy to use that library from the command line and it acts as a package manager for hackage
17:50:20 <Raevel> ah
17:50:31 <lispy> Raevel: check for cabal with ghc-pkg list | grep -i cabal
17:50:40 <gwern> http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html <-- curious. I'm not in the acknowledgments. I wonder how that happened?
17:50:42 <lambdabot> Title: Why functional programming? Why Haskell?, http://tinyurl.com/6lmwfu
17:50:57 <lispy> Raevel: I recommend getting cabal-install, it's very handy
17:51:26 <roconnor> cabal-install saved my marriage!
17:51:33 <gwern> 'Finally, we wish to thank those readers who submitted over 800 comments anonymously.  One comment' 'Anonymous  2008-09-01  You're welcome'
17:51:37 <Raevel> oh, so i do have cabal then, i did a locate cabal w/o the -i flag :*/
17:53:15 <andyjgill> Can anyone point me to an (Appel) Tiger parser and AST written in Haskell (before I go off and write one)?
17:53:50 <lispy> andyjgill: sorry, a parser for what?
17:54:07 <andyjgill> Tiger, the language from Appel's compiler book.
17:54:10 <sebaseba> andyjgill: I believe the Parsec site has those
17:54:18 <andyjgill> Ahh. Good.
17:54:20 <lispy> andyjgill: ah, no, I don't have one
17:55:01 <lispy> gwern: if it makes you feel better, I only even submitted comments anonymously
17:55:07 <lispy> gwern: so I'm not mentioned either
17:56:10 <lispy> So the Haskell type equivalent of java's Object is an existential type?
17:56:19 <lispy> or is it a universal?
17:56:26 <andyjgill> Ahh! The tiger hackage package - obviously really.
17:57:35 <lispy> Does my question not make sense because in Haskell we lack subtyping?
17:57:37 <gwern> lispy: well, maybe I did anonymous too. but I could've sworn I attached my nick to my comments
17:57:40 <gwern> oh well
17:58:02 <Raevel> oh my connection is acting up
17:58:31 <lispy> Raevel: no one said anything directly to you since you spoke last, I think
17:58:32 <Saizan> lispy: more like existential disregarding the methods of Object and the fact that upcasting is not implicit
17:58:48 <Raevel> thanks!
17:59:15 <lispy> Saizan: upcasting meaning converting to the actual instance type?
17:59:36 <lispy> Saizan: er I mean, up is away from object and towards the real tye
17:59:49 <Saizan> lispy: no, up is towards Object
17:59:52 <lispy> as in upcasting is casting down the heiarchy :)
17:59:55 <lispy> ah
17:59:57 <lispy> okay,
18:00:37 <Saizan> downcasting is getting back the "real" type
18:01:03 <lispy> Saizan: if Object is closer to existential than universal, I think it demonstrates how insane the original java collection classes are given that java is meant to be type safe
18:01:24 <Saizan> yeah.
18:01:31 <MyCatVerbs> lispy: Java? Typesafe? You what? :)
18:01:44 <lispy> MyCatVerbs: I accidentally the whole collection class :(
18:01:51 <Saizan> you needed to downcast all the time to get something out of those collections
18:02:17 <Saizan> which in haskell would be the same as using Dynamic, which is an existential with a Typeable context
18:02:34 <dibblego> that is still the case in some circumstances
18:03:25 <shapr> Wait what? Let's all slap shapr?
18:03:29 <lispy> Saizan: okay.  I have yet to use Data.Typeable but I see it a fair bit in papers.  Pretty much any time someone starts using existentials they also tend to bring out typeale
18:03:41 <lispy> ?shapr shapr
18:03:41 * lambdabot beats up shapr
18:03:42 <gwern> C accidentally the whole null pointer!
18:03:55 <shapr> I'm obviously a term of endearment.
18:04:14 <Saizan> ?type cast
18:04:16 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
18:04:22 <thoughtpolice> i accidentally the whole buffer!
18:04:26 <shapr> Oh great, now I've been type cast?
18:05:12 <thoughtpolice> or should that be 'i accidentally the whole buffe- ... sh-3.2$ ' ?
18:05:22 <lispy> thoughtpolice: lol
18:05:45 * lispy just now stopped laughing
18:06:40 <Saizan> lispy: existentials + typeable like in extensible-exceptions? i don't recall other papers with this
18:06:41 <lispy> oh hey
18:06:49 <lispy> we were talking about interpreters in agda right? http://www.iis.sinica.edu.tw/~scm/2008/typed-lambda-calculus-interprete/
18:06:54 <lambdabot> Title: Typed λ Calculus Interpreter in Agda | for the few of us., http://tinyurl.com/4ed4nf
18:07:23 <lispy> Saizan: I 've looked at so many papers in the last week and I'm lazy to check my notes...but I thought I saw it in a couple
18:08:06 <Raevel> yay, i finally got to the bottom of the dependency tree
18:08:15 <Raevel> (trying to compile lambdabot)
18:08:19 <lispy> Raevel: oh cool
18:08:34 <lispy> treat lambdabot with love and respect and she'll make it worth you time
18:08:42 <lispy> ?vixen won't ya girl?
18:08:42 <lambdabot> no
18:08:44 <gwern> Raevel: what ghc? I am reasonably sure it doesn't work yet for 6.10
18:08:58 <lispy> Raevel: heh, then again, maybe lambdabot is just a pain :)
18:09:09 <MyCatVerbs> Hah! Best vixen answer yet.
18:09:17 <Raevel> gwern: phew, 6.8.2
18:09:40 <gwern> oh, that should work fine then
18:09:46 <sbahra> ?vixen won't ya girl?
18:09:46 <lambdabot> nevermind about that
18:09:57 <gwern> I compiled lambdabot just a few days ago on 6.8.2
18:09:59 <lispy> ?vixey are you really vixey in disguise?
18:09:59 <lambdabot> i'm really real
18:10:10 <gwern> Raevel: but stay away from the most recent haskell-src-exts package! it breaks lb
18:10:17 <roconnor> lol
18:10:21 <Raevel> :*/
18:10:26 <Raevel> whats haskell-src-exts?
18:10:46 <lispy> Raevel: a library for parsing haskell and doing stuff with it
18:10:47 <gwern> Raevel: it's a package which parses and breaks down haskell expressions. it changed api in the latest
18:11:07 <gwern> > 1 + 1 -- before lambdabot dares evaluate this as haskell, it needs to do some analysis using haskell-src-exts
18:11:08 <lambdabot>   2
18:11:14 <Raevel> "i'ts a package which parses and breaks down" is what i read
18:11:21 <lispy> ha
18:11:31 <lispy> it's like the ford of parsers
18:11:55 <cjs> So why is it these days that I sometimes do and sometimes don't get source links from Haddock when I arrive via Hoogle?
18:11:56 <gwern> lispy: lauhg if you will, but the news reports I see say ford is going to be the last one standing of the Big Three
18:12:21 <Saizan> otherwise you can just edit mueval and hack out the need for haskell-src-exts, like #haskell's lambdabot does :)
18:12:45 <gwern> Saizan: no, it's not mueval that uses haskell-src-exts, it's one of the lb plugins
18:12:49 <gwern> Plugin.Eval, iirc
18:13:02 <Saizan> gwern: not for @run
18:13:29 <gwern> just saying what I remember from a failed compile
18:13:56 <lispy> gwern: that's because they are finally up to the same quality standard as toyota now
18:14:02 <centrinia> Are there any good Haskell Quasiquoting documents besides [Mainland 2007] ?
18:14:14 <dibblego> > let safe x = let (a, b) = splitAt 4 x;(c, d) = splitAt (length b - 4) b in a ++ (const 'x' <$> c) ++ d in safe "1234567890abcdefgh" -- can this be written nicer?
18:14:15 <lambdabot>   "1234xxxxxxxxxxefgh"
18:15:03 <lispy> centrinia: documents?  I'm not sure, but some people here are using it a lot...if you found one of them they have lots of examples I bet
18:15:20 <centrinia> Thanks.
18:15:31 <lispy> ?seen mmorrow
18:15:31 <lambdabot> Last time I saw mmorrow was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books,
18:15:31 <lambdabot>  #haskell-hac07, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #
18:15:31 <lambdabot> haskell.se, #haskell_ru, #jhc, #jtiger, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 1m 9d 11h 49m 18s ago, and .
18:15:51 <dolio> lispy: Note, that interpreter doesn't contain something like 'normalize : Term t -> Term t' written in Agda.
18:16:10 <shapr> @users
18:16:10 <lambdabot> Maximum users seen in #haskell: 558, currently: 493 (88.4%), active: 16 (3.2%)
18:16:16 <lispy> dolio: I haven't made it that far, but what is the implication of that ommision?
18:16:33 <dolio> lispy: Although it does have 'eval : Term t -> t' which I guess demonstrates that the language defined is strongly normalizing.
18:16:34 <lispy> shapr: we were over 500 again this morning
18:17:29 <Raevel> i am now the proud owner of cabal-install
18:17:33 <dolio> lispy: It doesn't evaluate a term in the language into a normal form in the same language, like you'd usually want out of an interpreter.
18:18:02 <dolio> lispy: Instead it turns it into an equivalent term in the meta-language which is what ends up normalising the result term.
18:18:33 <centrinia> dibblego, do you just want a function that is idempotent on the first and last 4 characters of a string and replaces the rest with 'x' ?
18:18:36 <cjs> Ah, I see; the 6.8.3 docs have source links, but the "latest" don't.
18:18:46 <dibblego> centrinia, correct
18:19:12 <gwern> Raevel: you should be able to cabal-install lambdabot?
18:19:33 <Raevel> i tried, and it says:
18:19:38 <Raevel> cabal: cannot configure haskell-src-exts-0.4.3.1. It requires base >=4
18:19:38 <Raevel> There is no available version of base that satisfies >=4
18:19:43 <Raevel> what does it mean?
18:20:56 <lispy> Raevel: base-4 ships with ghc-6.10
18:21:04 <lispy> Raevel: since you have 6.8.x you have base-3
18:21:09 <gwern> ah, that measn cabal-install is trying to install the latest version of haskell-src-exts - the oneI warned you against
18:21:54 <gwern> you will need t o insome way specify that you want an older haskell-src-exts; quite reasonably cabal-install trys to install the latest
18:22:03 <Raevel> i see
18:22:03 <Saizan> no..
18:22:30 <Saizan> cabal-intall would install one that doesn't require base-4
18:22:47 <Saizan> if it doesn't it's a bug
18:23:04 <Raevel> Saizan: then it's a bug as far as i can tell
18:23:13 <Saizan> unless you've untarred the package yourself
18:23:27 <Raevel> haskell-src-exts? no i haven't
18:23:47 <Saizan> Raevel: which comand did you run?
18:23:47 <dolio> lispy: Anyhow, it means you haven't exactly constructed an interpreter in Agda, at least not one like you'd usually write in, say, Haskell.
18:23:53 <dolio> Not that I've been able to do better. :)
18:24:01 <Raevel> Saizan: cabal install haskell-src-exts
18:25:17 <cjs> Is there some way to get hoogle to link to the 6.8.3 docs instead of the latest?
18:25:57 <centrinia> > let { replace_at f x = [if f i then \y -> x else id | i <- [0..]]; safe x = map (uncurry ($)) $ zip (replace_at (\i -> (i >= 4) && (length x) - i > 4) 'x') x } in safe "1234567890abcdefgh"
18:25:58 <lambdabot>   "1234xxxxxxxxxxefgh"
18:26:02 <centrinia> There.
18:26:09 <centrinia> Much uglier. :)
18:26:35 <dibblego> centrinia, I figured another way (thoguh I am actually using Scala)
18:27:18 <lispy> prototype in haskell and then implement in scala?
18:27:28 <dibblego> lispy, I do it a lot
18:28:08 <Saizan> Raevel: it looks like a bug then, in the meantime you can get awat with "cabal install haskell-src-exts-0.3.9"
18:28:38 <Raevel> Saizan: ok! thank you very much
18:28:41 <Saizan> Raevel: what does cabal --version says?
18:28:46 <lispy> dibblego: the one time I wrote an application I did that too.  That's a big reason why I kept using Haskell :)
18:29:05 <lispy> dibblego: that and the version of scala I had had some weird bugs as i've discussed with you in the past
18:29:22 <Raevel> Saizan: 0.6.0
18:29:59 <Saizan> Raevel: thanks
18:30:11 <Raevel> oh, it didn't manage to install haskell-src-exts-0.3.9 either, it required happy version >=1.17 but couldn't find it
18:30:16 <dibblego> > let safe s = foldr (\(c, i) r -> (if i < 4 || i >= length s - 4 then c else 'x') : r) [] (zip s [0..]) in safe "1234567890abcdefgh"
18:30:17 <lambdabot>   "1234xxxxxxxxxxefgh"
18:30:22 <Raevel> same issue?
18:30:48 <centrinia> > let { safe x = map (\(i,c) -> if (i < 4) || (((length x) - i) <= 4) then c else 'x') (zip [0..] x) } in safe "1234567890abcdefgh"
18:30:49 <lambdabot>   "1234xxxxxxxxxxefgh"
18:30:51 <thoughtpolice> Raevel: first do 'cabal update; cabal install happy' and then do 'cabal install haskell-src-exts'
18:31:12 <thoughtpolice> Raevel: note, you might have to copy the 'happy' executable from ~/.cabal/bin/happy to somewhere in your $PATH
18:32:36 <gwern> > ["aardvark".."zebra"]
18:32:37 <lambdabot>       No instance for (Enum [Char])
18:32:37 <lambdabot>        arising from the arithmetic sequen...
18:33:01 <Raevel> thoughtpolice: unfortunately that didn't seem to solve it
18:33:44 <Saizan> Raevel: which error did you get?
18:33:57 <dibblego> gah yes, it's a map
18:34:10 <Raevel> Saizan: cabal: happy version >=1.17 is required but it could not be found.
18:34:46 <gwern> > 'a' : "foobar"
18:34:48 <lambdabot>   "afoobar"
18:34:48 <Raevel> how can i check which version of happy is installed?
18:35:01 <gwern> happy --version?
18:35:09 <gwern> that'll also check if it's in $PATH...
18:35:21 <Raevel> 1.18.2, and it's in $PATH
18:35:57 <gwern> huh. did you know the second hit for Real World Haskell on Amazon, is Stephenson's _Anathem_?
18:36:18 <gwern> (no reviews yet)
18:36:42 <Saizan> Raevel: cabal install --with-happy=`which happy` haskell-src-exts-0.3.9 ?
18:37:47 <Raevel> wait for it
18:38:11 <Raevel> great success! thanks
18:38:27 <gwern> (man, o'reilly got some nice blurbs for RWH - SPJ, Pierce, and Sweeney)
18:39:19 <Raevel> now on to lambdabot
18:40:04 <x6d65> Has anyone ever had need for an operator with a type like (a -> b) -> (a -> b -> c) -> a -> c, which lets you "fork" one argument into two for another function?
18:40:10 <Axman6> hooray for free access to Safari book online
18:40:45 <Saizan> ?type flip ap
18:40:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m (a -> b) -> m b
18:41:05 <Saizan> ?type flip ap :: (a -> b) -> (a -> b -> c) -> a -> c
18:41:06 <lambdabot> forall a b c. (a -> b) -> (a -> b -> c) -> a -> c
18:41:11 <Axman6> with ((->) a) == m there?
18:41:17 <Saizan> Axman6: right
18:41:22 <Axman6> whoot :)
18:41:39 <Axman6> would a -
18:41:43 <Axman6> uh
18:41:50 <Saizan> x6d65: that's the S combinator from the SKI calculus btw, but flipped
18:41:56 <Axman6> a -> b -> c be a monad of the form m (m c)?
18:42:16 <Saizan> no, but (a -> a -> c) can
18:42:28 <Saizan> > join (*) 4
18:42:29 <lambdabot>   16
18:42:33 <Axman6> ah yes
18:42:44 <Axman6> :y join (*)
18:42:48 <Axman6> :t join (*)
18:42:49 <lambdabot> forall a. (Num a) => a -> a
18:42:59 <Saizan> also, monadic function/value rather than monad
18:43:05 <Saizan> the monad is the 'm'
18:43:45 <Raevel> oh great, i had to to the --with-happy trick for haskell-src as well, but now lambdabot compiled!
18:45:28 <Saizan> Raevel: where do you have the happy binary, btw? ~/.cabal/bin ?
18:45:41 <Raevel> yessir
18:47:41 <x6d65> Saizan: I see. It seems like J's "trains" (where I first saw the idea) are at least partially based on the SKI calculus.
18:49:07 <Saizan> x6d65: never used J, but given that J is the name of another such combinator i'd expect so :)
18:49:59 <b4taylor> I don't suppose anyone knows what space is for gtk2hs |> Key { eventModifier = [], eventKeyName = "KP_Space"}
18:50:42 <b4taylor> Oh snap. Search fail.
18:50:47 <b4taylor> lowercase s on Space
18:51:32 <x6d65> Saizan: It seems like the S combinator would be a handy one to have in the Prelude.
18:53:13 <Saizan> x6d65: ap or (<*>) when used with the ((->) r) monad/applicative are exactly that
18:53:23 <Saizan> x6d65: like pure/return are the K combinator
18:53:55 <dibblego> let s = (<*>)
18:55:33 <juhp> do most hackage packages have a README file or not?
18:55:56 <b4taylor> juhp: What's there to read?
18:56:04 <juhp> heh
18:56:07 <b4taylor> I'd saw most of the good ones do.
18:56:13 <b4taylor> s/saw/say/
18:56:17 <juhp> okay
18:56:23 <juhp> thanks
18:59:34 <pumpkin_> what is $f4?
18:59:57 <dibblego> a type of motorcycle produced by Honda
19:00:45 <x6d65> Saizan: Thanks for the clarification.
19:00:53 <pumpkin_> oh, I see
19:00:56 <pumpkin_> nevermind
19:11:17 <hackage> Uploaded to hackage: HAppSHelpers 0.2
19:11:17 <hackage> Uploaded to hackage: RSA 1.0.2
19:11:17 <hackage> Uploaded to hackage: reactive-fieldtrip 0.0.4
19:11:17 <hackage> Uploaded to hackage: dimensional 0.7.3
19:11:41 <Saizan> ?hackage HAppSHelpers
19:11:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HAppSHelpers
19:12:31 <harblcat> So I have an IO function that returns a bit of data, and now I'd like to have a list of that data that is infinite. I seem to be having difficulty...
19:12:55 <dibblego> harblcat, you mean repeat the list data forever?
19:13:01 <centrinia> harblcat, try this list: [1..]
19:13:12 <dibblego> harblcat, perhaps you want the cycle function?
19:13:17 <dibblego> > cycle [1,2,3]
19:13:18 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
19:13:30 <centrinia> > [1..]
19:13:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:13:49 <lament> harblcat: i'm guessing you want sequence
19:13:57 <lament> :t sequence
19:13:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:14:22 <dibblego> any other guesses?
19:14:27 <Saizan> sequence won't give an interesting result for infinite input
19:14:43 <centrinia> > sequence [[s..] | s <- [1..]]
19:14:46 <lambdabot>   * Exception: stack overflow
19:14:50 <centrinia> Wow.
19:14:54 <centrinia> Sorry. :(
19:15:26 <centrinia> >  'I' : "'m still alive!"
19:15:28 <lambdabot>   "I'm still alive!"
19:16:40 <harblcat> Well, I have a function that takes a number, compares that to a random number between 0 and 1, and returns True if n is greater, false otherwise. I want to take that and make it infinite.
19:17:14 <harblcat> Basically a [Bool] with a certain probability.
19:17:23 <harblcat> If that is understandable.
19:17:37 <rwbarton> You don't want to use IO for that.
19:17:54 <rwbarton> Well, that's not really very clear
19:18:03 <harblcat> There is another way to work with random numbers?
19:18:27 <rwbarton> :t newStdGen
19:18:27 <harblcat> System.Random works, but is difficult to understand, sometimes.
19:18:28 <lambdabot> IO StdGen
19:18:44 <harblcat> I have that down, rwbarton.
19:19:01 <centrinia> :t random
19:19:02 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
19:19:05 <rwbarton> Yeah, so use newStdGen and then write a recursive function using random.
19:19:26 <harblcat> Well, let's see...
19:19:32 <Saizan> > randomRs (0,1) (mkStdGen 42)
19:19:33 <lambdabot>   [1,1,1,0,0,1,0,1,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,...
19:19:46 <rwbarton> Oh, randoms already exists for this
19:20:00 <Saizan> > randomRs (0,1) (mkStdGen 42) :: [Double]
19:20:02 <lambdabot>   [0.11040701265689151,0.8453984927258916,0.30778213446209723,0.7813880826070...
19:20:20 <rwbarton> do gen <- newStdGen; return $ map (> prob) $ randomRs (0, 1)
19:20:34 <rwbarton> s/(0, 1)/(0, 1) gen/
19:20:35 <centrinia> Uh, what is prob?
19:20:44 <rwbarton> prob is the argument to the function
19:21:05 <rwbarton> I guess it should be < prob.
19:25:13 <harblcat> http://hpaste.org/12342#a0
19:25:22 <harblcat> Maybe it will be clearer.
19:25:34 <rwbarton> harblcat: What I meant by my first comment is that you shouldn't have each random number generation be a distinct IO action, because you can't sequence infinitely many actions together and then do something else.
19:25:55 <harblcat> Even using something like take?
19:26:08 <harblcat> I only need so many at once, so...
19:26:18 <rwbarton> So, in fact you can do this using unsafeInterleaveIO.
19:26:30 <harblcat> They are able to do it with randoms, aren't they?
19:26:47 <harblcat> Just :'sing random together.
19:27:21 <rwbarton> Let's assume you don't want to use unsafeInterleaveIO
19:27:43 <rwbarton> You've wrapped up each generation of a single random number into an IO action
19:28:03 <rwbarton> and later you want to only perform those IO actions whose results are demanded by your computation
19:28:24 <rwbarton> This means you can't predict what order the IO will occur in, which isn't how the IO monad works.
19:28:31 <harblcat> Well, actually I am using each random number to compare and get a result from that, but I only need so many.
19:28:39 <rwbarton> Right.
19:28:42 <rwbarton> Instead, you can do this
19:28:57 <rwbarton> Once you get a generator from newStdGen, you can use it to generate an infinite list of random numbers using randoms
19:29:03 <rwbarton> That's a pure computation, not one that involves IO at all
19:29:05 <rwbarton> :t randoms
19:29:06 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
19:30:15 <harblcat> > take 15 (randoms newStdGen)
19:30:16 <lambdabot>       No instance for (RandomGen (IO StdGen))
19:30:17 <lambdabot>        arising from a use of `r...
19:30:28 <harblcat> Ah..
19:30:33 <rwbarton> You won't be able to do IO in lambdabot
19:30:49 <Cale> You can get a StdGen using mkStdGen though
19:31:03 <Cale> > take 15 (randoms (mkStdGen 42)) :: [Integer]
19:31:05 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
19:31:20 <harblcat> Ah.
19:31:29 <Cale> I wonder what probability distribution Integer uses.
19:31:41 <Cale> Clearly can't be uniform ;)
19:31:58 <rwbarton> So here you can write getVotes :: Float -> IO [Bool]; getVotes f = do gen <- newStdGen; return $ map (> r) $ randoms gen
19:32:25 <rwbarton> I've copied your use of f and r from your paste, I suppose it's probably not what you want :)
19:33:23 <rwbarton> As Cale says we can get a RandomGen in lambdabot using mkStdGen
19:33:39 <rwbarton> > take 20 $ map (> 0.9) $ randoms (mkStdGen 5283)
19:33:40 <lambdabot>   [False,False,False,False,False,True,True,False,False,False,False,False,Fals...
19:34:17 <Raevel_> i'm trying to get lambdabot to join a channel on connect, but it doesn't seem to listen to my .online.rc, could someone please help me out?
19:35:13 <Cale> Raevel_: your ~/.lambdabot/online.rc rather?
19:36:04 <Raevel_> i named it ~/.online.rc, does it matter?
19:36:32 <harblcat> Ah.
19:36:37 <harblcat> Thank you!
19:36:43 <Raevel_> it manages to connect, so it can read the file at least
19:36:50 <Cale> oh
19:37:00 <Cale> Yeah, it shouldn't matter
19:37:20 <Cale> You're doing something like
19:37:25 <Cale> join freenode:#foo
19:37:31 <Cale> ?
19:37:32 <Raevel_> yep yep
19:37:34 <Raevel_> http://pastie.caboo.se/paste/323194
19:39:05 <Cale> hmm
19:39:11 <jml> you know it just occurred to me
19:39:49 <Cale> Raevel_: hmm, that looks correct to me
19:39:59 <Raevel_> it seems to be a quakenet issue
19:40:07 <Raevel_> it worked on another network
19:40:07 <Cale> Raevel_: Is it possible that you'd have to get it to identify before joining that channel?
19:41:06 <Cale> It'd be something like:  msg quakenet:nickserv identify <password>
19:41:07 <Raevel_> hmmm, are you talking nickserv identification? in that case it doesn't have to
19:41:12 <Cale> Okay.
19:41:16 <Raevel_> quakenet doesn't even have nickserv
19:41:19 <Cale> ah
19:41:38 <Cale> I can't think of why it wouldn't join.
19:41:49 <Cale> jml: What?
19:42:08 <Raevel_> does it usually wait for the 001 message before it sends the join?
19:43:06 <jml> if Haskell really wanted to avoid success at all costs, it should have been a Lisp variant.
19:43:14 <Cale> jml: heh
19:43:53 <Cale> jml: Isn't the equational alignment-dependent syntax strange enough?
19:43:56 <Raevel> okay, another question, does lambdabot use nickserv to identify admins?
19:44:10 <Cale> Raevel: no, it's fundamentally insecure
19:44:22 <Raevel> haha, okay
19:44:23 <Cale> at least, last time I checked
20:04:06 <mrd> jml: it does pay homage to lisp in the Report
20:05:15 <maxote> joed
20:05:26 <joed> maxote: yes?
20:05:43 <maxote> why have you banned me on 3java?
20:05:45 <maxote> why have you banned me on #java?
20:07:09 <joed> You've spent about 3 hours providing anecdotes, useless advice, factually wrong advice, ignored repeated requests to shut the hell up and managed to confuse the last 60 minutes of GUI questions into tooling, other than than you are doing great?
20:07:47 <lament> I've been doing those things for years and nobody banned me...
20:07:52 <lament> admittedly it wasn't in #java
20:07:58 <joed> True that.
20:09:20 <joed> Not that I'm also usually quiet in this channel as I poke in, learn, get confused, code sick and vomit, then come back and so on, but I do manage to keep my hamburger trap shut.
20:09:30 <joed> Note, *
20:10:24 * joed apologises for wasting Haskell time on Java irc politics.
20:10:48 <dibblego> has anyone said anything meaningful in ##java recently?
20:10:52 <maxote> joed, have i said all these words that you were saying me?
20:11:04 <joed> dibblego: Nope. Was a long time since.
20:11:20 <dibblego> joed, just checkin thanks
20:11:32 <joed> maxote: Point in case, I accused you of being a waste of time, not words.
20:11:55 <dons> maxote: wrong channel
20:11:57 <maxote> joed, it was my waste of time, not yours
20:12:00 <dons> joed: somewhere else guys.
20:12:02 --- mode: ChanServ set +o dons
20:12:07 * joed nods.
20:12:20 <cjb> maxote: wasting time is O(N) on participants, see
20:12:48 <maxote> and i should stay there, it's O(N+1)
20:13:16 <dons> maxote: here to learn about haskell?
20:13:41 <maxote> it's quietly now
20:13:45 <Raevel> okay, now i managed to auth to lambdabot after not managing to read the sample config correctly for a while :-P But when i try to run the eval command i only get "Terminated." as response, anyone have a clue on what I need to do to get it working?
20:14:02 <sjanssen> Raevel: do you have mueval installed?
20:14:10 <Raevel> i'm guessing no
20:14:34 <sjanssen> Raevel: that is what lambdabot uses to evaluate Haskell code
20:14:35 <Raevel> nope, compiling
20:17:03 <Raevel> okay now i'm missing Data.Number.Symbolic
20:17:44 <sjanssen> @hackage creal
20:17:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/creal
20:17:50 <sjanssen> err, sorry
20:17:52 <sjanssen> @hackage numbers
20:17:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
20:19:40 <Raevel> oh it's in cabal...
20:22:45 <Raevel> as was Control.Monad.Logic
20:23:16 <Raevel> and it works! thanks alot sjanssen
20:23:29 <Saizan> yeah, cabal-install fetches the packages from hackage.haskell.org
20:23:56 <Raevel> does cabal-install usually fetch dependencies as well?
20:24:07 <Saizan> yes
20:24:24 <Raevel> okay, i've had bad luck with that then i guess :-)
20:25:02 <Saizan> but lambdabot is a bit strange since it has "runtime" dependencies, not only compile-time ones
20:25:21 <Raevel> aha
20:26:15 <Aviator> can i do incremental parsing with parsec?
20:26:19 <roconnor> I should write evil-cabal-install that installs trapdoors from r6.ca
20:26:21 <Aviator> since haskell is lazy...
20:26:58 <Saizan> roconnor: you just have to make the normal cabal-install use your evil repository
20:27:10 <roconnor> oh
20:27:12 <roconnor> bah
20:27:14 <roconnor> too easy
20:27:23 <roconnor> won't bother
20:27:53 <sjanssen> it'd be fun to write a proxy hackage that transparently inserts malicious code into packages
20:28:22 <roconnor> well
20:28:32 <roconnor> I suppose basically anyone can upload to hackage
20:28:39 <roconnor> so making that more secure won't really help.
20:28:52 <roconnor> IO beware
20:28:58 * Lemmih adds sjanssen's name to the watch list.
20:29:02 <shapr> Aviator: The most recent Monad.Reader issue has something about incremental parsing. Isn't that where jyp's Yi article went?
20:29:03 <dons> sjanssen: that wouldn't be fun.
20:29:05 <dons> sopt
20:29:07 <dons> stop!!
20:29:08 --- mode: ChanServ set -o dons
20:29:37 <Aviator> yes, i read that
20:29:55 <shapr> Aviator: What do you think?
20:29:55 <roconnor> dons: heh
20:30:05 <sjanssen> dons: it's just motivation for someone to work on proper code signing :)
20:30:12 --- mode: ChanServ set +o dons
20:30:16 <dons> yes.
20:30:19 <Saizan> parsec is not designed to do incremental parsing, since it has to check if the whole parse succeded before giving any result
20:30:19 <Aviator> seems that yi is off for making another parsing library
20:30:23 --- mode: ChanServ set -o dons
20:30:30 <dons> why did chanserv try to reop me...
20:30:30 <shapr> Aviator: Do you think there's a better approach?
20:30:39 --- mode: ChanServ set +o dons
20:30:41 * shapr grins suspiciously
20:30:47 <roconnor> sjanssen: actually, maybe it would be better to disallow packages from building agaist IO?
20:30:49 * dons blames shapr
20:30:57 <roconnor> sjanssen: is that possible?  is IO a package?
20:30:58 <shapr> Rightfully so :-)
20:30:58 * dons kicks shapr. mwhaha the power!
20:31:04 <shapr> aiee!
20:31:14 <dons> too many vowels.
20:31:16 <sjanssen> roconnor: IO is not a package
20:31:21 <dons> that's a kicking offense
20:31:36 <dons> oh, io as an optional package
20:31:39 <dons> mmm. that's a fun idea.
20:31:42 --- mode: ChanServ set -o dons
20:32:13 <roconnor> where is IO right now?
20:32:15 <dons> only non-termination as an effect
20:32:16 <roconnor> in base?
20:32:16 <sjanssen> roconnor: you also have to ban GHC.*, FFI, unsafePerformIO, etc.
20:32:34 <roconnor> GHC.*?
20:32:38 <dons> wouldn't it be grand if base had no FFI and no IO. just data and pure functions
20:32:44 <roconnor> FFI is already not allowed without flags
20:32:45 <sjanssen> roconnor: GHC.Exts has all sorts of nasty stuff
20:33:05 <roconnor> dons: why not?
20:33:06 <ddarius> sjanssen: So all hackage needs to do is digitally sign each tarball (assuming we trust hackage).
20:33:18 <dons> yes, why not!
20:33:31 <roconnor> ddarius: hackage has no trustworthyness.  So there is little point signing it at this time.
20:33:37 <glguy> hackage could only accept packages that were digitally signed (gpg) by a key that is authorized to sign for that library
20:33:59 <sjanssen> ddarius: yes, that'd be a start.  It'd be nice to have some sort of trust mechanism for authors and uploaders too
20:34:03 <roconnor> ddarius: it doesn't technically hurt, other than a false sense of security.
20:34:19 <ddarius> roconnor: Can anyone other than the package authors (and people they allow) modify their package?
20:34:34 <sjanssen> ddarius: yes, anyone can upload a package by any name
20:34:38 <roconnor> ddarius: I assume so.  But I don't know.
20:34:56 <dons> so we just need to get the hackage darcs repo, implement signed packages. make them the default. and off we go
20:34:58 <sjanssen> an unauthorized upload has happened before with the unix lib
20:35:08 <ddarius> sjanssen: Okay, then roconnor's mostly right.
20:35:29 <roconnor> but lets not solve the social problem, let's solve the techinical problem!
20:35:38 * roconnor stares down IO
20:36:14 <sjanssen> roconnor: how many packages don't use IO at all?
20:36:14 <roconnor> grrr
20:36:16 <dons> roconnor: would be interesting to talk to Igloo about breaking IO out of base
20:36:25 <roconnor> sjanssen: I don't know
20:36:28 <dons> providing a restricted pure base.
20:36:32 <dons> then target that.
20:36:39 <dons> well, just wrap base hiding bad modules
20:36:44 <roconnor> sjanssen: I bid 60%-70%
20:36:58 <dons> so you could: build-depends: pure-haskell
20:37:04 <roconnor> but maybe I am naive
20:37:05 <dons> just to get types and data.
20:37:16 * sjanssen notes that Prelude exports IO functions
20:37:19 <roconnor> dons:  no no the otherway
20:37:24 <dons> i know the otherway.
20:37:26 <roconnor> dons: you have to mention IO to get IO.
20:37:27 <dons> but that's more work
20:37:40 <roconnor> ya
20:37:41 <roconnor> I guess
20:37:44 <dons> you could at least write a package that imports base, and reexports only safe things
20:37:47 <Cale> Isn't the only real problem unsafePerformIO?
20:37:58 <roconnor> hmm
20:38:00 <dons> well, all the things lambdabot rules out
20:38:04 <sjanssen> Cale: and the dozen other things like it
20:38:13 <Cale> Well, yeah, there's unsafeIOtoST as well.
20:38:13 <shapr> Yeah, even TH can get you interesting places.
20:38:16 <dons> so the 'trusted core' should be the pure part, with only non-termination and out-of-memory as effects
20:38:18 <shapr> unsafeCoerce?
20:38:22 <dons> maybe total functions only
20:38:25 <Cale> ah, and that
20:38:29 <sjanssen> unsafe array reads and writes, unsafeCoerce, everything in Foreign ...
20:38:35 <dons> all the things lambdabot had to rule out
20:38:35 <shapr> ddarius came up with a long list of things that would break out of lambdabot's cage.
20:38:35 <roconnor> dons: *L*
20:38:43 <glguy> only having total functions doesn't really buy much
20:38:50 <glguy> since you can easily write your own partial ones
20:38:51 <dons> probably we'd write base that way if we had to do it over
20:38:53 <Cale> I think there should be a way for libraries to mark functions as unsafe, and then that would require special flags to compile modules which use them.
20:38:54 <dons> layer effects.
20:39:03 <dejones> How can I convert a Word16 to an Integer?  :/
20:39:04 <Elly> Cale: like scheme's (unsafe!)?
20:39:06 <sjanssen> Cale: yeah, I think that is a more useful approach
20:39:10 <dejones> fromInteger doesn't seem to be working...
20:39:12 <dons> dejones: fromIntegral
20:39:12 <roconnor> dejones: fromIntegral
20:39:14 <dons> as for all types
20:39:18 <roconnor> @stereo
20:39:18 <lambdabot> Unknown command, try @list
20:39:19 <Riastradh> Elly, PLT Scheme's, not Scheme's.
20:39:21 <dejones> ack, fromIntegral doesn't seem to be working.
20:39:24 <dons> glguy: yes, that's interesting.
20:39:25 <Elly> Riastradh: er, yeah
20:39:29 <dons> glguy: so you'd use Catch to rule out your own
20:39:36 <roconnor> dejones: add a type annotation
20:39:39 <dons> and 'import Trusted.Haskell' for libs
20:39:41 <dejones> dons, roconnor: hmm, I haven't had any luck with fromIntegral.
20:39:46 <dejones> roconnor: such as?
20:39:53 <roconnor> fromIntegral x :: Integer
20:39:55 <dons> > fromIntegral (1 :: Word16) :: Integer
20:39:57 <lambdabot>   1
20:40:04 <dejones> roconnor, dons: ty.
20:40:15 <Cale> Also, it might be a good default to make unsafeness hereditary.
20:40:42 <Cale> (but allow a pragma to assert that the usage is safe)
20:41:03 <sjanssen> Cale: yes, I think so.  Also add some sort of trust concept -- so I can say that I trust the author's of bytestring to use unsafe features
20:42:00 <shapr> Package signing sounds simpler.
20:42:03 <shapr> apt-style
20:42:20 <sjanssen> I think package granularity is too large
20:42:41 <shapr> It's working for debian (mostly).
20:43:02 <sjanssen> take base for example.  For pragmatic reasons it has lots of safe functions right next to unsafe ones
20:43:12 <sjanssen> shapr: we're trying to solve a different problem, though
20:43:15 <shapr> ah
20:43:25 <zloog> :t uncurry
20:43:26 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
20:43:59 <sjanssen> Debian solves "does this package come from a trusted person", we want to solve "can this code access unsafe features"
20:44:08 <shapr> Yeah, I see.
20:44:37 <Cale> Right, you might want to allow partly-unsafe (marked as unsafe) features from one module but not open up everything.
20:45:10 <Cale> I can imagine something like the oeis module's use of unsafePerformIO to do a lookup over the network as such a case.
20:45:41 * sjanssen thinks that use of unsafePerformIO is evil
20:46:19 <Cale> Well, it is fairly evil and should probably be marked as unsafe, but compared to, say, unsafeCoerce, it's quite safe.
20:46:30 <sjanssen> yes
20:46:42 <Raevel> lambdabot is great for brainwashing people with haskell code over the net
20:46:42 <sjanssen> it only breaks referential transparency, it won't cause a segfault
20:47:29 <shapr> @users
20:47:29 <lambdabot> Maximum users seen in #haskell: 558, currently: 494 (88.5%), active: 21 (4.3%)
20:48:00 <sbahra> BAH
20:48:01 <sbahra> @users
20:48:02 <lambdabot> Maximum users seen in #haskell: 558, currently: 494 (88.5%), active: 22 (4.5%)
20:48:10 <shapr> ?
20:48:10 <Cale> (and it only breaks referential transparency as far as the OEIS database changes)
20:48:33 <Saizan> (or your connection dies)
20:48:43 <sjanssen> Cale: or you trip on your ethernet cord
20:48:46 <Cale> hehe
20:48:53 <Cale> Yes, I suppose there is that.
20:49:35 <Cale> But you can at least imagine a referentially-transparent equivalent to it (in fact, perhaps that ought to exist)
20:50:09 <sjanssen> Cale: how?  Cache the downloaded data?
20:50:52 <Cale> Download the whole database and do something like use TH to generate code to do a lookup in it.
20:51:22 <Cale> (so the function is fixed at the time you compile the oeis module)
20:55:00 <Cale> (or just generate the definition of some data structure to store it, of course)
20:58:28 <Saizan> a function that change behaviour between builds is not really ref. transparent, imo
20:58:51 <Cale> I think it is.
20:59:08 <Cale> After all, between builds, you could have simply edited the source code.
21:01:39 <Saizan> in that case i'd consider it another function, in fact if i want to reason about its use in older code i'd have to check how it behaves wrt the original
21:01:41 <sjanssen> Cale: it is referentially transparent, but not very good manners I think
21:02:06 <sjanssen> Cale: from a support perspective, you not only need to ask for the version of the package used, you have to ask for the date it was built!
21:02:30 <Saizan> i guess it depends on how you define the semantics of that particular function
21:05:16 <solrize> i thought there was a way to make unsafeCoerce given unsafePerformIO
21:05:50 <sjanssen> solrize: yes, use unsafePerformIO and an IORef
21:06:12 <solrize> also there's a way with data.typeable
21:06:13 <FunctorSalad> meh. so I tried scrapping the type constructor and implementing composition like this instead: "class Compose a b where type C a b :: * ; (.) :: a -> b -> C a b"
21:07:11 <FunctorSalad> the problem is that now I get huge context, because I can't tell haskell properties like transitivity of composeability
21:07:21 <FunctorSalad> any workaround?
21:08:09 <Saizan> an example of an instance?
21:08:45 <FunctorSalad> Saizan: instance Compose (b -> c) (a -> b) where type C (b -> c) (a ->b) = a -> c ; (.) g f x = g (f x)
21:09:35 <FunctorSalad> the advantage is that these "categories" needn't be indexed over all types, as with the current Category class
21:11:03 <FunctorSalad> at least I get familiar with all the language extensions by trying to implement category theory ;)
21:11:17 <hackage> Uploaded to hackage: reactive 0.9.3
21:11:38 <Cale> solrize: Yeah, writing instances of Typeable shouldn't be allowed.
21:11:59 <Cale> (It would be safe if only derived instances were allowed)
21:12:07 <solrize> hmm
21:12:26 <mriou> hi, I have a pretty newbish question concerning the following snippet: http://pastie.org/323225
21:12:31 <lambdabot> Title: #323225 - Pastie
21:12:33 <solrize> hey tell me something.  how are types like Int# handled in the language?  special hair in the backend that's not visible anywhere else?
21:12:47 <solrize> mriou looking
21:12:50 <Cale> solrize: Well, in GHC, they have a special kind.
21:12:56 <mriou> it seems that it could be optimized, the instance definitions are really redundant
21:13:07 <Cale> I'm looking too, but my connection is crap at the moment.
21:13:15 <Cale> ah, okay
21:13:16 <solrize> you can't use "deriving Eq" ?
21:13:27 <mriou> for some reason, no
21:13:34 <Cale> Yeah, those are effectively the derived instances.
21:13:48 <Saizan> FunctorSalad: my 2 cents: with fundeps you could write class Compose a b c | a b -> c, a c -> b, b c -> a where ... which should give more information to the type checker
21:13:50 <Cale> Except that the Ord instance you gave isn't a total ordering like that.
21:14:35 <Cale> (The derived one compares lexicographically, based on the order of the constructors in the declaration.)
21:14:41 <solrize> > fromIntegral (37 :: Int#)
21:14:42 <lambdabot>   Not in scope: type constructor or class `Int#'
21:15:10 <mriou> mmh that's a lot of problems in a single snippet :)
21:15:39 <mriou> why my definition isn't a total ordering?
21:15:41 <Cale> solrize: That wouldn't be allowed. There would be a kind error.
21:16:03 <solrize> so how do you get an Int# back up to the normal type system?
21:16:04 <Cale> mriou: How does WyString "Hello" compare with WyInt 45
21:16:05 <Cale> ?
21:16:29 <mriou> ah got it, they don't compare
21:16:30 <Cale> solrize: By applying the I# constructor to it, usually.
21:16:43 <solrize> :k I#
21:16:44 <lambdabot> Not in scope: type constructor or class `I#'
21:16:53 <solrize> hmm
21:16:57 <Cale> mriou: So you've only specified a partial ordering, but Ord instances are supposed to be total.
21:17:23 <Cale> :t GHC.Types.I#
21:17:24 <lambdabot> Couldn't find qualified module.
21:17:36 <Cale> solrize: Right... well, do that in GHCi ;)
21:17:38 <mriou> ok so in addition to those I should have something for say "compare (WyString s) _" ?
21:17:55 <solrize> Prelude> :m GHC.Types
21:17:55 <solrize> Could not find module `GHC.Types':
21:18:04 <Cale> mriou: The easiest thing would be to change deriving Show to deriving (Show, Eq, Ord)
21:18:10 <Saizan> GHC.Exts?
21:18:30 <Saizan> ?ty GHC.Exts.I#
21:18:31 <Cale> GHC.Prim is what I :m+'d
21:18:31 <lambdabot> GHC.Prim.Int# -> Int
21:18:42 <solrize> aha
21:18:43 <solrize> tx
21:18:48 <mriou> cale: ok, will do that
21:18:54 <mriou> cale: thanks
21:19:01 <FunctorSalad> Saizan: I though that was basically equivalent. I still couldn't formulate implications like transitivity, I think
21:19:56 <Cale> mriou: The code which it writes for you first compares them by constructor order, and then if those match compares the first fields, and so on if those match
21:20:13 <solrize> what i'm wondering is whether it's reasonable to write a compiler as a haskell DSL, embedding haskell's type system in the target language terms, but being able to tell for code generation purposes when something was really a native int etc.
21:20:35 <Cale> mriou: So all WyStrings will be less than WyInts, the way you have it.
21:20:42 <Saizan> FunctorSalad: yours is equivalent to class Compose a b c | a b -> c where, but yeah things like transitivity are out of reach
21:20:43 <mriou> cale: so how can I change the default comparison to not allow WyInt < WyString say
21:20:45 <FunctorSalad> Saizan: though your version has more fundeps (c a -> b and c b -> a), which aren't there with assoc. types
21:20:56 <Cale> mriou: By reordering the cases in the data declaration.
21:21:34 <mriou> cale: I don't want to change the order, I want to make comparison of those produce an error
21:21:40 <Cale> mriou: This rarely matters, but if you want to store NativeType values in a Data.Set or use them as keys for a Data.Map, the fact that they're totally ordered is important.
21:22:00 <FunctorSalad> the definition of a category is so simple in ZFC... is there some deeper reason that I fail again and again trying to do it with types? ;)
21:22:04 <mriou> mmh heterogeneous maps yeah
21:22:31 <Cale> FunctorSalad: hmm
21:23:16 <Saizan> how do you define it in ZFC? a monoid?
21:23:28 <mriou> so is there a way to make comparison of two different NativeType illegal?
21:23:34 <FunctorSalad> one could argue that sometimes composeability is undecidable, but I can't think of any real example where composeability is not trivial
21:23:42 <Cale> Actually, it's a bit tricky to do it properly in ZFC. The definition should involve proper classes.
21:23:57 <FunctorSalad> or even better Grothendieck universes ;)
21:23:58 <Cale> (at least if you want a category of sets)
21:24:05 <FunctorSalad> (then you can do more than one layer)
21:24:40 <FunctorSalad> Saizan: a "set" of objects and a "set" of arrows with operations domain, codomain, id, composition such that ...
21:25:12 <mriou> cale: ok, I'll keep it this way for a start then, thanks a lot for the help
21:25:25 <Cale> mriou: Well, you can just write the instances that you wrote, but they'll not be so useful with things that assume Eq and Ord instances are total.
21:25:34 <Cale> (which is almost everything)
21:25:36 <FunctorSalad> with composition only being defined on { g,f | dom g = cod f }
21:26:06 <Cale> mriou: Another way would be to write typed comparison operations which check that they have the same constructor, and then use the derived comparison.
21:26:37 <FunctorSalad> one problem is that if you implement morphisms as values and objects as types, then dom and cod go from values to types
21:27:04 <mriou> cale: good option, I might do that instead
21:27:56 <Saizan> FunctorSalad: class Category u (~>) where (.) :: (IsIn a u, IsIn b u, IsIn c u) => a ~> b -> b ~> c -> a ~> c
21:27:57 <mriou> cale: and so there's no better way to check that two constructors are equal other than matching on each of them?
21:28:22 <mriou> s/equal/identical/
21:28:49 <FunctorSalad> Saizan: yes, that branch of development is stuck due to a ghc panic though ;))
21:28:52 <Cale> mriou: not that I'm aware of. I suppose you could derive Data and Typeable, and use toConstr
21:29:16 <Saizan> FunctorSalad: where u stands for universe, so you can write things like data OrdUniverse; instance Ord a => IsIn a OrdUniverse
21:29:20 <Cale> mriou:  sameConstr x y = toConstr x == toConstr y
21:29:27 <Saizan> FunctorSalad: ah, really?
21:29:34 <FunctorSalad> Saizan: since one wants to use an associated type inside IsIn, like in the rmonad package
21:30:23 <mriou> cale: that's nicer, thanks
21:30:26 <FunctorSalad> Saizan: I think as you just wrote, the Category instance declaration won't know about Ord. that's what rmonad works around
21:31:49 <FunctorSalad> I could be wrong there
21:32:26 <Saizan> FunctorSalad: no, you're right, it won't give you the Ord context
21:32:38 <Saizan> i forgot about that problem..
21:32:40 <mriou> mriou: thanks a lot for all the help cale
21:32:47 <Cale> mriou: No problem
21:33:02 <Saizan> FunctorSalad: so rmonad doesn't work either anymore?
21:33:43 <FunctorSalad> Saizan: rmonad builds for me
21:33:57 <Cale> I think the next big research language should have support for more than one category of types.
21:34:04 <FunctorSalad> :)
21:34:33 <FunctorSalad> Saizan: I'm not sure what exactly causes the panic in my code (but already submitted it to ghc trac)
21:34:37 <Cale> Explicit support for categories would be quite nice.
21:35:19 <solrize> does int# being a separate kind count as that?
21:35:25 <solrize> i mean as having more than one category
21:37:11 <Cale> solrize: mm... I suppose sort of, but it pales in comparison to what I'm actually thinking of.
21:37:17 <Saizan> yeah, but you need the ability to define custom kinds and kind polymorphism
21:37:42 <solrize> cale, yeah
21:37:46 <Saizan> so you can have a KindOrd KindEq etc..
21:38:42 <Saizan> and write somethink like class Category (c :: k -> k -> *) where ...
21:38:46 <FunctorSalad> Types,Kinds,Sorts, what comes then? :)
21:39:13 <FunctorSalad> Ilks?
21:39:13 <ddarius> Type and kind are sorts.
21:39:30 <Saizan> i'd probably want "subkinding" in this situation
21:39:36 <FunctorSalad> ddarius: is that standardized?
21:40:22 <ddarius> It's mathematical terminology, none of it is standardized, but it is reasonbly common (in my experience) to use sort as the general term.
21:40:22 <FunctorSalad> I think I've seen those words used in various ways
21:40:27 <solrize> ilks, i gotta remember that ;)
21:41:12 <ddarius> Anyway,
21:41:21 * ddarius recommends worrying about the value level first.
21:41:26 <solrize> would you say sorts are in the metalanguage, i.e. you can't quantify over them or across them
21:42:05 <Cale> Another way to phrase this problem is that our type system has no support for pullbacks. If it did, you wouldn't have a problem.
21:42:15 <FunctorSalad> Cale: exactly
21:42:23 <Saizan> pullbacks?
21:42:39 <FunctorSalad> Set of composeable arrows = Pullback (dom,cod)
21:43:09 <solrize> what would you use that for?
21:43:14 <ddarius> Values of a pullback type would need to include proofs that they belong.
21:43:57 <solrize> and could you possibly do type inference with a thing like that in the langauge?
21:44:31 <FunctorSalad> Saizan: it's the category theory generalization of this construct: if you have f: A -> X and g: B -> X, then pullback(f,g) = { (a,b) in A*B such that f a = g b }
21:44:55 <roconnor> what does = mean?
21:45:07 <Cale> roconnor: equal to
21:45:14 <FunctorSalad> it comes for free in ZFC ;)
21:45:15 <roconnor> hmm
21:45:29 <roconnor> stupid set theory
21:45:34 <FunctorSalad> otherwise I think you usually assume that the arrow set comes equipped with equality
21:45:39 <Cale> roconnor: What's wrong?
21:45:50 <FunctorSalad> otherwise you couldn't have commutative diagrams...
21:45:57 <Cale> roconnor: It's not like there's anything here which doesn't typecheck.
21:46:25 <roconnor> Cale: you need (Eq X) =>
21:46:26 <solrize> but that pullback is defined in terms of a value equality
21:46:30 <roconnor> otherwise = is undefined
21:46:41 <FunctorSalad> solrize: yes. that's why we have no easy solution for it currently
21:47:14 <Cale> Well, you do.
21:47:15 <roconnor> forcing the use of value equality strikes me as very restrictive, but I don't know CT.
21:47:20 <FunctorSalad> ddarius: *nod*. not sure whether this is possible without going all the way to dependent types
21:47:39 <adu> I was wondering if there was anything like language-c that represents scripting languages...
21:47:49 <Cale> roconnor: You can't state the category axioms without using equality of arrows.
21:48:15 <Cale> What does (f . g) . h = f . (g . h) mean if you can't compare arrows?
21:48:33 <roconnor> which is why mapping CT into haskell is so hard.
21:48:39 <roconnor> we always leave = implicit
21:48:41 <roconnor> and vague
21:49:01 <Cale> adu: "Scripting languages"?
21:49:15 <FunctorSalad> roconnor: in haskell or in CT?
21:49:24 <roconnor> in haskell
21:49:32 <adu> Cale: ya, like Language.Ruby for parsing or manipulating ruby expressions in Haskell
21:49:39 <Cale> adu: I doubt it.
21:49:53 <Cale> adu: I'm sure there are people who would like it if you wrote something like that.
21:49:57 <FunctorSalad> roconnor: hmm, I don't understand... for general types we have no '=', for Eq it isn't implicit
21:50:15 <rwbarton> adu: if your scripting language happens to be perl 6 :)
21:50:21 <adu> Cale: well, I'm actually thinking of writing a binding to parrot, so I don't have to...
21:50:21 <Cale> Of course, we have equality in the semantic domain.
21:50:42 <roconnor> FunctorSalad: think of the monad laws
21:50:52 <adu> rwbarton: oh ya... :)
21:51:02 <FunctorSalad> roconnor: :) good point
21:51:48 <roconnor> We actually do pretty well for not having = defined
21:52:00 <roconnor> but I found that pull back definition frightening.
21:52:08 <roconnor> It seemed to really depend on =
21:52:11 <Saizan> in this case we'd want equality of types not of values, however
21:52:12 <roconnor> but I could be wrong.
21:52:19 <roconnor> oh
21:52:31 <roconnor> huh?
21:52:37 <Cale> I think the reason we can do well enough without = directly is that there is an = which is actually behind the scenes :)
21:52:49 <FunctorSalad> Saizan: hmm? the f,g,a,b are values
21:52:56 <Cale> (we can compare things once we take their semantics)
21:53:10 <roconnor> Cale: right, we usually have an equality "in mind"
21:53:25 <roconnor> which the compiler doesn't really need to know about to type check.
21:53:38 <roconnor> but does the compiler need to know to do pullbacks?
21:53:45 <Cale> Probably.
21:53:52 * roconnor nods
21:54:05 <roconnor> @quote McKinna
21:54:05 <lambdabot> No quotes match. I've seen penguins that can type better than that.
21:54:10 <Saizan> FunctorSalad: well dom and cod go from arrows to objects, no? but objects are types here
21:54:11 <roconnor> *sigh*
21:55:04 <roconnor> @quote divides
21:55:04 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
21:55:08 <Saizan> also, they just need the type of the arrows to work, not the values
21:55:10 <roconnor> there we go
21:55:20 <FunctorSalad> Saizan: oh, right. doesn't seem to make it any easier though
21:55:36 <roconnor> He said that in response to talking about various definition of equalities in proof assistents.
21:55:44 <roconnor> People think equality is trivial
21:56:03 <Cale> I want a language where I can write something like  Category = MonadIn (Span Set)  ;)
21:56:07 <roconnor> but is is probably the largest difference between proof assistent's logics.
21:56:18 <orbitz> is it posisble to automagically convert the do notation to the >>/>>= notation like an expand-macro type thing?
21:56:25 <FunctorSalad> Saizan: if we have the typechecker knowing about values then it doesn't really matter whether objects are types or values, I guess
21:56:27 <roconnor> or at least largest practical difference?
21:56:34 <Cale> @undo do {v <- x; return v}
21:56:34 <lambdabot> x >>= \ v -> return v
21:56:44 <FunctorSalad> (the only purpose of the objects is to serve as tokens for defining composeability)
21:56:45 <Cale> @redo x >>= \ v -> return v
21:56:45 <lambdabot> do { v <- x; return v}
21:56:47 <orbitz> is that just apr tof lambdabot or ghci?
21:56:53 <Cale> lambdabot
21:57:13 <Cale> do-notation is defined in terms of >>=
21:57:22 <roconnor> @undo mdo {x <- return y; y <- return x; return ()}
21:57:22 <lambdabot>  Parse error at "<-" (column 8)
21:57:29 <roconnor> aww
21:57:34 <sjanssen> roconnor: Language.Haskell doesn't support mdo
21:57:38 <Cale> by a totally mechanical recursive translation
21:58:17 <FunctorSalad> Saizan: yes, if the domain and codomain only depend on the type of the arrow, then we wouldn't need such drastic extensions I guess
21:58:44 <orbitz> what is mdo?
21:59:01 <FunctorSalad> mapM for bash :)
21:59:01 <Saizan> orbitz: look at ghc flags reference in the manual, there should be something like -ddump-desugared
21:59:04 <roconnor> orbitz: an extension that supports recursive do.
21:59:08 <FunctorSalad> oops.
21:59:20 <orbitz> Saizan: thanks
21:59:22 <FunctorSalad> there's a package 'mdo' too, which is what I described ;)
21:59:56 <FunctorSalad> (more like mapM_ for IO monad)
22:00:01 <orbitz> hrm
22:00:18 <orbitz> what about a haskell repalcemetn fo rbash?
22:00:35 <roconnor> > runState (mdo {put y; z <- get; put 5; y <- get; return z}) 0
22:00:37 <lambdabot>   (5,5)
22:00:44 <roconnor> > runState (mdo {put y; z <- get; put 5; y <- get; put 7; return z}) 0
22:00:45 <lambdabot>   (5,7)
22:01:03 <FunctorSalad> orbitz: thought about that too, but would it be practical without porting a great amount of commands?
22:01:21 <orbitz> FunctorSalad: like what?
22:01:22 <sbahra> FunctorSalad, why do you have to port them?
22:01:35 <sbahra> FunctorSalad, it's not like most commands are built into sh.
22:01:37 <FunctorSalad> maybe have a tool that generates haskell types from the --help output? ;)
22:01:46 <orbitz> hah
22:01:49 <orbitz> now that' sjust fantasy!
22:01:49 <sbahra> "hah"
22:02:31 <sbahra> FunctorSalad, head, tail, sort, etc...
22:02:33 <FunctorSalad> sbahra: they aren't, but if you have to do 'exec (printf "curl --foo=%s --bar=%s ..." ...)' then not much is won :)
22:02:38 <orbitz> sbahra: i'll "hah" you
22:02:45 <sbahra> How would that be handled? (since those commands exist)
22:03:06 <FunctorSalad> sbahra: it would only be useful if all the common tools were translated into proper haskell types
22:03:08 <sbahra> FunctorSalad, why not just "curl"?
22:03:20 <FunctorSalad> the parameters are the issue here
22:03:22 <solrize> haskell shell:  curl --foo=37 blech.html :: Webpage
22:03:27 <orbitz> FunctorSalad: i was thinking mor e along the lines of addin ga layer to liek ghci where you can use haskell as a scripting lagnauge but still just run rpgorams like in bash
22:03:30 <orbitz> FunctorSalad: no idea how it would work
22:03:33 <solrize> tail -30 file.txt :: [Line]
22:04:43 <FunctorSalad> solrize: how does it infer the filenames?
22:04:55 <FunctorSalad> (that they are filenames, I mean)
22:05:07 <solrize> heh yeah
22:05:17 <Elly> Command :: [String] -> [String]
22:05:19 <Elly> is a good start
22:05:22 <solrize> http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons   this was good
22:05:25 <lambdabot> Title: Haskell hacking, http://tinyurl.com/ywdjsr
22:05:42 <FunctorSalad> Elly: we pretty much have that with System.Process.readProcess
22:05:52 <Elly> it's not quite as catchy as `foo` though :P
22:06:06 <FunctorSalad> (readProcess command args stdin :: IO String)
22:06:17 <Saizan> a typed shell would be awesome with enough syntactic sugar
22:06:20 <FunctorSalad> where stdin is just a string too
22:06:54 <sbahra> That would be nice.
22:07:34 <Saizan> where you get the typedness by defining thin wrappers around readProcess, probably borrowing from conal's tangible values
22:07:35 <sbahra> But just the compositionality of Haskell (even without nice typing) is useful.
22:07:52 <Elly> yeah
22:07:55 <Elly> '.' would be nice
22:08:14 <sbahra> Everything can be a ByteString.
22:08:16 <sbahra> :-P
22:08:36 <FunctorSalad> at leasts [ByteString] to end the quoting nightmare
22:09:30 * roconnor remembers reading about a typed filesystem for Clean
22:09:38 <roconnor> executables were functions
22:09:51 <Saizan> Clean also has a shell
22:09:53 <roconnor> er in Clean, rather than for Clean
22:10:06 <roconnor> ah whatever
22:10:10 <roconnor> stupid prepositions
22:11:17 <hackage> Uploaded to hackage: ParserFunction 0.0.2
22:11:20 <Saizan> @source Data.Dynamic
22:11:20 <lambdabot> http://darcs.haskell.org/packages/base/Data/Dynamic.hs
22:15:37 <solrize> wow, smerdlykov (sp?) is writing a book about programming in coq
22:15:43 <solrize> http://adam.chlipala.net/cpdt/
22:15:44 <lambdabot> Title: Certified Programming with Dependent Types
22:15:48 <solrize> it looks interesting
22:23:26 <ski_> solrize : Smerdyakov
22:25:44 <lament> @smerdyakov
22:25:44 <lambdabot> Unknown command, try @list
22:25:49 <lament> @quote smerdyakov
22:25:49 <lambdabot> No quotes match. There are some things that I just don't know.
22:29:17 * ski_ only finds one haskell quote for Smerdyakov ..
22:32:19 <ski_> <Grog`> http://www.cse.unsw.edu.au/~cs1011/assignment/assign1/index.html
22:32:24 <ski_> <Smerdyakov> This isn't a homework answer service.
22:32:30 <ski_> <Grog`> is it a kind service
22:32:37 <ski_> <Smerdyakov> Yeah, the answer is "drop the class if you're too dumb to do that problem," directed to whoever is in the class.
22:33:21 <erikc> o snap
22:36:35 <dons> this is why we don't see smerdy around here much.
22:36:38 <dons> well. ever.
22:36:58 <dons> for great smerdy quotes, check the #ocaml log. he and palomer get to grump it out daily.
22:37:55 <Twey> Haha
22:38:05 <dons> 10:33:35 <paul424> ehh I am stuck with some imperative feauters of the ocaml
22:38:13 <dons> 10:35:57 <Smerdyakov> Your code is written poorly.  There is no reason to use refs here.
22:38:14 <joe_b> :t ($+$)
22:38:15 <lambdabot> Doc -> Doc -> Doc
22:38:16 <dons> 10:36:05 <Smerdyakov> You should also never use loops in OCaml
22:38:23 <dons> not so bad, but that's the most recent. i didn't look hard.
22:38:38 <joe_b> :t <+>
22:38:39 <lambdabot> parse error on input `<+>'
22:38:44 <joe_b> :t (<+>)
22:38:45 <lambdabot>     Ambiguous occurrence `<+>'
22:38:45 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:3:0-33
22:38:45 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:54:0-46
22:38:52 <dons> smerdy> Learning OCaml should be trivial if you are a true Haskell expert.
22:38:54 <dons> that's interesting
22:39:11 <pumpkin_> anyone in here worked with conditional random fields by any chance?
22:39:23 <pumpkin_> does it go both ways?
22:39:44 * pumpkin_ loves putting orderings on languages
22:39:45 <roconnor> dons: source?
22:41:55 <roconnor> ah tunes
22:42:57 <ski_> ?
22:43:11 <ski_> .. oh
22:43:38 <ski_> (presumably <http://tunes.org/~nef/logs/ocaml>, for the interested)
22:46:07 <Raevel> so if you say something stupid you will be a laughing stock indefinitely thanks to the logs?
22:47:10 <ski_> maybe in theory
22:47:33 <Raevel> good thing i stopped using ocaml!
22:47:46 <Saizan> this channel is also logged :)
22:47:50 <Raevel> :-(
22:48:27 <erikc> im looking forward to a future where political careers are ruined by internet chat log scandals
22:48:35 <flux> well, there's really nothing you can do to prevent logging, aside from banning everyone from the channel
22:48:41 <flux> so you better expect it :)
22:49:09 <pumpkin> lucky this channel is so friendly!
22:49:12 <flux> (I log too, although only for my personal use)
22:49:18 <pumpkin> and full of people who won't use your logs against you! ;)
22:49:19 <Raevel> i vote for banning everyone
22:49:20 <Saizan> well, publicly logged is a bit different
22:50:20 <sjanssen> dons: I would imagine the opposite is true as well
22:50:35 <sjanssen> (an OCaml expert should have no trouble with Haskell)
22:52:41 <sjanssen> @palomer :)
22:52:41 <lambdabot> Learning vim is pointless
22:52:44 <Saizan> i bet he/she'd get a lazy accumulator stack overflow at least once :)
22:53:30 <sjanssen> Saizan: sure, but it shouldn't be hard for them to get the hang of laziness
22:54:01 <sjanssen> I imagine a Haskell refugee would get at least one stack overflow because OCaml isn't lazy enough :)
22:54:23 <dons> non-termination anyway
22:54:52 <Saizan> and i guess they can start from functors for typeclasses
22:56:12 <Nafai> dons: Looking forward to that wiki page with ideas for the GUI ghci interface
22:59:11 <solrize> i think you can treat ocaml as something like python with types
22:59:24 <solrize> not really possible with haskell
22:59:34 <sjanssen> huh?
23:00:10 <solrize> e.g. you can do io from anywhere in an ocaml program
23:00:56 <solrize> rather than having a monadic i/o layer at the outermost level
23:01:02 <solrize> and somehow getting values up to it while the program runs
23:01:18 <vegai> weeeeellllll, it has quite many differences to python
23:01:28 <vegai> how about "Haskell without purity and ugly syntax"? :P
23:01:34 <solrize> heh, yeah :)
23:01:39 <Saizan> uhm, yeah, i'm a bit scared of going back to a language with unrestricted mutation/IO
23:01:55 <geezusfreeek> i think i would do alright with ocaml. i would be afraid of everything i do, fearing unnecessary side-effects, and be overly careful
23:02:19 <solrize> disciple looks interesting, haskell with effects typing
23:02:25 <Saizan> since it's so much easier to understand what's going on when the effects are in the types
23:03:34 <solrize> could be
23:04:10 <geezusfreeek> reddit has had a couple submissions on call-by-push-value recently which i am finding interesting. never heard of it before. i'm not entirely convinced a call-by-push-value language would give me much more control over my programs than i already have though
23:04:11 <jtraub> Hi!
23:04:14 <solrize> i find myself putting more haskell code in IO than really looks right, just in order to be able to log what the program is doing
23:04:25 <solrize> hello jtraub
23:04:33 <solrize> push-value?
23:04:43 <Saizan> solrize: Writer?
23:04:48 <roconnor> use a writer monad
23:04:52 <solrize> hmm
23:05:16 <solrize> ok i will read about that, i didn't understand it when i looked at it several months ago but may have better luck now
23:05:28 <geezusfreeek> solrize: i'm not sure where the name comes from, but the basic idea is that thunks are explicitly created and evaluated and are considered as different types from values
23:05:58 <solrize> geezusfreeek you mean the writer monad?
23:06:07 <geezusfreeek> solrize: call-by-push-value
23:06:09 <solrize> oh
23:06:15 <solrize> ic
23:06:49 <solrize> if you mean like it's usually done in scheme, that's pretty ugly :)
23:07:27 <geezusfreeek> i thought scheme was strict?
23:08:02 <sjanssen> geezusfreeek: are call-by-push-value languages strict?
23:08:23 <geezusfreeek> no, they supposedly supercede strictness and laziness
23:08:23 <Saizan> it uses (\() -> x) to simulate laziness
23:08:30 <sjanssen> what does "const () undefined" return?
23:08:34 <solrize> yes, scheme is strict but has a force/delay syntax sugar for making thunks
23:08:57 <Saizan> geezusfreeek: do you have a good reference on this?
23:09:21 <lament> i wouldn't exactly call force/delay sugar
23:09:37 <geezusfreeek> saizan: from a quick google earlier today, not sure how great it compares to other references: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1152
23:09:38 <lambdabot> Title: Call-by-Push-Value: A Subsuming Paradigm - CiteSeerX
23:09:55 <geezusfreeek> s/supercedes/subsumes/ ;)
23:12:03 <Saizan> thanks :)
23:13:08 <geezusfreeek> i'd say the main contribution isn't the evaluation (it seems to be just strict with explicit thunks), but the typing (thunks are not considered to be the same as values)
23:13:21 <geezusfreeek> but i haven't read much of it yet
23:13:50 <geezusfreeek> anyway, time for bed
23:13:55 <solrize> "They'll probably cite Paul Graham too ... Sure, he wrote a shopping cart in Lisp. That shopping cart was also the first thing that got rewritten when Yahoo took over."
23:20:59 <sbahra> What was the URL to the page containing the list of packages included with various ghc releases?
23:24:32 <solrize> jjj
23:24:36 <solrize> oops sorry
23:25:02 <mauke> 3j  "optimized
23:25:12 <solrize> heh
23:25:47 <cjs> Well, Graham picked the wrong language for it, that was the problem.
23:26:05 <cjs> He wrote it in LISP, instead of a half-specified, half-working LISP interpreter written in C.
23:26:14 <solrize> haha
23:51:18 <olsner> how can I see what's changed in e.g. array between 6.8.2 and 6.10.1?
