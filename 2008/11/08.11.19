00:05:31 <lispy> :t (%)
00:05:32 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
00:05:41 <lispy> ?index (%)
00:05:41 <lambdabot> Data.Ratio
00:05:46 <lispy> oh
00:05:51 <lispy> I thought that was in the prelude
00:06:10 <pumpkin> > 5 % 6
00:06:12 <lambdabot>   5%6
00:06:18 <lispy> > 25 % 100
00:06:19 <lambdabot>   1%4
00:06:30 <lispy> > toRational (0/0)
00:06:31 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
00:06:36 <lispy> :t toRational
00:06:37 <lambdabot> forall a. (Real a) => a -> Rational
00:06:56 <lispy> ?hoogle Rational
00:06:56 <lambdabot> Prelude type Rational = Ratio Integer
00:06:56 <lambdabot> Data.Ratio type Rational = Ratio Integer
00:06:56 <lambdabot> Text.PrettyPrint.HughesPJ rational :: Rational -> Doc
00:07:07 <pumpkin> wow, that seems bad for 0/0 to act like that :P
00:07:09 <pumpkin> 0%0
00:07:11 <pumpkin> >0%0
00:07:21 <lispy> > toRational (0/0) :: Ratio Int
00:07:22 <lambdabot>   Couldn't match expected type `Int' against inferred type `Integer'
00:07:32 <lispy> > (toRational (0/0)) :: Ratio Int
00:07:35 <lambdabot>   Couldn't match expected type `Int' against inferred type `Integer'
00:07:46 <lispy> > (toRatio (0/0)) :: Ratio Int
00:07:46 <lambdabot>   Not in scope: `toRatio'
00:09:56 <lispy> > 0/0 :: CReal
00:10:11 <lambdabot>   thread killed
00:12:05 <ski_> geezusfreeek : looks like a variant of raising a natural transformation `id -> f' to the power of a natural number `id = id^n -> f^n'
00:12:46 <ski_> not sure if there's a name
00:13:25 <geezusfreeek> ski_: thanks
00:14:04 <ski_> (there should be a canonical choice of constructing that natural transformation, by naturality)
00:15:09 <ski_> generally `forall a. f a -> g a' is the type of a natural transformation (assuming `f',`g' are functors)
00:15:42 <geezusfreeek> oh i see
00:15:45 <ski_> .. is the type in haskell of a natural transformation `f --> g' .. i meant to say
00:16:51 <ski_> (the `parametric' in `parametric polymorphism' translates to `natural' in `natural transformation')
00:26:26 <geezusfreeek> oh yuck, i had to make it a lot more complicated to get what i really wanted
00:26:57 <geezusfreeek> (forall a b. b -> f a b) -> z -> f c (f d z) ... (forall a b. b -> f a b) -> z -> f c (f d (f e z)) ... etc.
00:27:23 <geezusfreeek> now i'm not really sure if it's worth all this
00:28:53 <dmwit_> yowie
00:28:57 <dmwit_> What's that for?
00:29:27 <geezusfreeek> and the big finale: (forall a b. b -> f a b) -> z -> f c (f d (f e (f g (f h (f i (f j (f k (f l z))))))))
00:29:43 <dmwit_> Is dis sum Peano numerals?
00:30:37 <pumpkin> oh my
00:30:39 <geezusfreeek> dmwit_: some hackery with repeated applications of Right, ultimately to make some way to pattern match on Events and come out with a n-tuple of Events based on what matched
00:30:59 <geezusfreeek> well, repeated applications of Right in this instance anyway
00:31:36 <dmwit_> ah!
00:31:50 <geezusfreeek> what i'm really wanting is something like n-tuples, but a sum type instead of a product type
00:32:01 <geezusfreeek> but something generic, not a specific data type
00:32:01 <dmwit_> right
00:33:05 <geezusfreeek> and obviously i was wanting something like myFunc4 Right x to give me Right (Right (Right (Right x)))
00:33:11 * dmwit_ suggests just using data Tagged a = Tagged Int a
00:33:18 <geezusfreeek> i think the myFunc abstraction got out of hand though
00:33:43 <geezusfreeek> yeah i guess i could just do that :P
00:34:03 <geezusfreeek> now i'm trying to think back where i started and why i wanted it this way
00:34:12 <dmwit_> Although that requires that all the possible things have the same type, which your solution doesn't.
00:34:26 <geezusfreeek> oh, yes, that was it :)
00:34:54 <dmwit_> But, man, what do you actually need open sum types for?
00:35:23 * dmwit_ now suggests Data.Dynamic
00:35:46 <dmwit_> data Tagged a = Tagged Int Dynamic -- ;-)
00:35:50 <geezusfreeek> i'm trying to come up with an elegant way to construct functions of type Event a -> (Event b, Event c, Event d, Event e, ...)
00:35:56 <dmwit_> s/ a / /
00:36:10 <geezusfreeek> and i wanted it to look a lot like pattern matching
00:36:18 <dmwit_> geezusfreeek: Oh, have you looked at the Arrow class?
00:36:32 <dmwit_> They have all kinds of nice functions for making tuple-based "scopes".
00:36:48 <dmwit_> Declare yourself an instance for Event (if you can), and you might get what you're looking for for free.
00:36:50 <geezusfreeek> hmm... i guess i could see what i can do with that
00:37:02 <dmwit_> (There's also lots of nice functions for making either-based multiplexing.)
00:37:29 <geezusfreeek> well, it's a monad, so i trivially have a kleisli arrow
00:38:00 <dmwit_> Okay!
00:38:04 * dmwit_ -> bed
00:38:06 <dmwit_> Good luck!
00:39:30 <dmwit_> geezusfreeek: Oh yeah, and before I go, you should also look at the "proc/do" notation for arrows.  It deals with constructing and destructing these tuple-scopes at the right times to make your life more convenient.
00:39:44 <geezusfreeek> i have used arrows befor
00:39:45 <geezusfreeek> e
00:39:49 <geezusfreeek> but thanks
00:39:52 <dmwit_> Ah, okay.
00:39:58 <dmwit_> Sorry for underestimating you, then. =)
00:40:07 <geezusfreeek> salright ;)
00:41:17 <geezusfreeek> unfortunately i don't think the abstraction i really want is hidden in there
00:41:25 <geezusfreeek> i'll keep searching
00:42:54 * ski_ wonders what a tuple of events has to do with variant types ..
00:46:06 <geezusfreeek> ski_: i was planning on writing trivial conversions from custom sum types (say, data Foo = A a | B b | C c) to nested eithers to pass into functions like (Event (Either a (Either b c)) -> (Event a, Event b, Event c)
00:46:31 <geezusfreeek> ski_: so i could easily write functions like (Event Foo -> (Event a, Event b, Event c)) without too much extra boilerplate
00:47:02 <geezusfreeek> the conversion to sum types would have been done using pattern matching and this function i was working on that i called "myFunc"
00:47:09 <geezusfreeek> *earlier
00:50:10 <ski_> split :: Event (Either a b) -> (Event a,Event b)
00:50:13 <ski_> fmap split . split :: Event (Either a (Either b c)) -> (Event a,(Event b,Event c))
00:50:39 <ski_> hm
01:04:49 <quicksilver> geezusfreeek: once or twice I've pondered a more lightweight syntax for anonymous sums
01:04:56 <quicksilver> (Int|Char|Int|Int), say
01:06:25 <quicksilver> the "picklers" paper discusses conversion between generic and specific sum/product types
01:06:30 <quicksilver> at least tangentially
01:07:21 <dolio> What would injection look like?
01:07:31 <dolio> (|'c'||)?
01:07:32 <quicksilver> (||3|)
01:07:33 <quicksilver> yeah
01:08:05 <quicksilver> (||3|) :: Num c => (a|b|c|d)
01:08:08 <quicksilver> etc.
01:08:18 <dolio> Yeah.
01:09:44 <ski_> mirror (a|b) = (b|a)
01:10:07 <ski_> distr (a,(b|c)) = ((a,b)|(a,c))
01:10:13 <ski_> et.c.
01:11:07 <quicksilver> ski_: well unfortunately, no.
01:11:16 <ski_> how so ?
01:11:21 <quicksilver> mirrior (a|) = (|a); mirrion (|b) = (b|)
01:11:28 <quicksilver> it would still be two cases
01:11:39 <quicksilver> the typoes are a special wednesday freebie.
01:11:46 * ski_ likes his ambiguous patterns and expressions
01:12:12 <quicksilver> being able to specify multiple cases in one go like that is certainly interesting but I'm not sure how it would work ;)
01:12:24 <ski_> also
01:12:33 <kinghajj> Does anyone know where I can find the video "Type-driven testing in Haskell"? foomongers.org.uk is down.
01:13:27 <ski_> (actually, i'll refrain from showing that example for the moment .. 'til i've found saner concrete syntax)
01:14:03 <mgdtgd> does anyone know why Prelude.product is not strict?
01:14:19 <ski_> `(*)' is not required to be strict
01:14:42 <mgdtgd> but I can't think of an example where the non-strictness would help me
01:15:08 <mgdtgd> if there are any bottoms in the list product would still be bottom
01:15:34 <ski_> product [Zero,fix Succ]
01:15:40 <dmwit_> I believe product and sum are non-strict because they predate foldl'.
01:15:50 <dmwit_> (indeed, I believe they predate seq!)
01:16:04 <dmwit_> ?index seq
01:16:05 <lambdabot> Prelude, Control.Parallel
01:16:14 <dolio> They don't predate seq. But they do predate foldl'.
01:16:24 <quicksilver> mgdtgd: in practice the strictness analyser does a good job on sum and product
01:16:26 <quicksilver> AFAIK.
01:16:40 <dolio> Inasmuch as the report has the former but not the latter in it.
01:16:50 <mgdtgd> ghci doesn't do any strictness analysis then?
01:16:53 <quicksilver> no.
01:17:01 <quicksilver> strictness analysis only on compilation with -O
01:17:01 <dmwit_> dolio: H98 was not the first Haskell. ;-)
01:17:16 <dmwit_> But if you say they don't predate seq, I believe you.
01:17:25 <quicksilver> none of the prelude definitions use seq as far as I recall?
01:18:14 <ski_> (ceterum autem censeo, `seq'inem esse delendam)
01:18:21 <dmwit_> quicksilver: ($!)
01:18:32 <mgdtgd> how about hugs? it's just an interpreter afaik.
01:19:06 <dolio> dmwit_: Well, if you're revising the library standard, simply keeping sum/product the same because they predated seq in some previous library standard isn't very compelling.
01:19:32 <dmwit_> dolio: That is certainly a valid point.
01:20:58 <quicksilver> mgdtgd: I don't believe hugs does any strictness analysis.
01:21:26 <quicksilver> win 20
01:21:54 <rwbarton> mgdtgd: hugs certainly doesn't seem to be doing strictness analysis in my simple test (foldl (+) 0 [1..1000000])
01:23:16 <mgdtgd> strictness analysis is a feature I'd like to see in ghci
01:23:19 <dmwit_> lose 5
01:23:44 <mgdtgd> often enough it makes the difference between "works in constante space" and "doesn't work at all"
01:24:01 <Peaker> I'd like ghci to let me do data declarations, instances, and everything else I can do "in a file"
01:24:08 <mgdtgd> the latter case is quite confusing for new users
01:24:53 <mgdtgd> peaker: yes, that would be nice
01:25:20 <Peaker> strictness analysis, being a heuristic, is a bit "magical", and can easily break unpredictably when the user changes stuff
01:26:01 <mgdtgd> you could add some special commands ":special" ":endspecial". between those everything would be treated like it's read from a file
01:26:12 * dmwit_ points at :{ and :}
01:26:26 <pumpkin> smiley faces!
01:26:41 <Badger> :[]:
01:27:36 <quicksilver> mgdtgd: it is a question of debate whether it's ever right to rely on such optimisations
01:27:43 <quicksilver> since they're static and hence inherently fragile.
01:27:55 <mgdtgd> quicksilver: that's true
01:28:02 <ski_> :l <<-EOF
01:28:05 <quicksilver> makes me slightly uneasy about some of ByteString, too.
01:28:21 <quicksilver> static optimisations are not compositional.
01:29:28 <Peaker> also, why is there no way to "eval" code (in the form of a string or parsed strings as code objects) something like:   (eval :: forall a. Code -> a) ? (Where the eval caller has to "choose" the type and the code has to deliver that exact type)
01:31:28 <mgdtgd> Peaker: isn't that possible
01:31:49 <quicksilver> Peaker: there is.
01:31:53 <quicksilver> next question?
01:32:06 <mgdtgd> peaker: http://haskell.org/haskellwiki/GHC/As_a_library
01:32:07 <lambdabot> Title: GHC/As a library - HaskellWiki
01:32:32 <mgdtgd> I believe
01:32:59 <quicksilver> ghc-api or hs-plugins or plugins or mueval
01:33:06 <quicksilver> (some of those are based on others of those)
01:39:59 <Peaker> quicksilver: hmm, something as *simple* as that would be nice :-)
01:40:24 <Peaker> Oops, I also forgot to enclose a in a Maybe or something (Code a -> Maybe a)
01:40:52 <ski_> oh, `Code a' .. that's a different things
01:41:08 <quicksilver> Code a would indeed be different.
01:41:15 <quicksilver> not what Peaker said first time.
01:41:22 <Peaker> yes, I messed up again :(
01:41:31 <quicksilver> Peaker: embedding an entire compiler in your app certianly isn't simple ;)
01:41:33 <Peaker> (eval :: forall a. Code -> Maybe a)
01:41:44 <quicksilver> Code a would be interesting.
01:41:47 <ski_> look at MetaML or MetaOCaml to get an idea of one way this can be done
01:41:50 <quicksilver> suggests a typed parser
01:41:52 <quicksilver> (quite possible)
01:42:06 <ToRA|MSR> "Code -> Maybe a" couldn't work as there's no way to reify the type a at runtime
01:42:11 <ski_> (the `Code a' variant, i.e.)
01:42:13 <ToRA|MSR> you probably want Typeable a => Code -> Maybe a
01:42:23 <Peaker> ToRA|MSR: Compiler magic :)
01:42:41 <quicksilver> I was assuming the Typeable constraint, yes.
01:43:39 <Peaker> @type cast
01:43:40 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
01:43:56 <ToRA|MSR> Peaker: it'd have to be very deep dark magic ;)
01:44:32 <Peaker> Well, the compiler can (and does) create values of non-Typeable types normally (e.g via normal data constructors) why not create them in eval?
01:44:55 <ToRA|MSR> Peaker: it's a question of whether it can tell that the type it has created is the type you want
01:44:56 <Peaker> but I guess a Typeable constraint is reasonable as anything can easily be Typeable
01:45:01 <rwbarton> It's more the Maybe that's the problem...
01:45:03 <ski_> Peaker : presumably you wanted to match the final type of the expression against the user-supplied type `a', nay ?
01:45:09 <quicksilver> Typeable is the only mechanism for the first stage of compilation (compiling the outer code) can communicate which type it wants to the inner code.
01:45:20 <Peaker> ski_: yeah
01:45:31 <ski_> that would probably require `Typable'
01:45:42 <Peaker> okay, are there generally things that are not Typeable?
01:46:01 <quicksilver> 'first-class polymorphic' things
01:46:14 <quicksilver> because haskell doesn't really have first class polymorphism.
01:46:18 <quicksilver> well, it sort-of doesn't.
01:46:32 <Peaker> what does "first-class polymorphic" mean, any example?
01:46:44 <quicksilver> the true type of "id"
01:46:52 <quicksilver> as distinct from any particular instances of it
01:47:02 <Peaker> Stuff without any context restrictions?
01:47:02 <quicksilver> you can pass id :: Char -> Char to a function
01:47:08 <quicksilver> and you can pass id :: Int -> Int to a function
01:47:14 <quicksilver> but you can't pass "the real id"
01:47:19 <quicksilver> which has type forall a . a -> a
01:47:21 <ski_>   eval :: Code -> Maybe (forall a. a -> a)  -- this instance
01:47:22 <quicksilver> to a function
01:47:26 <quicksilver> (in haskell 98)
01:47:43 <quicksilver> GHC adds some extensions to permit higher ranks and impredicativity
01:47:51 <quicksilver> but it doesn't add anything corresponding to Typable
01:47:58 <quicksilver> to allow their types to be reified.
01:49:31 <Peaker> ok, with -XRankNTypes I can?
01:49:50 <Peaker> oh, so types with forall qualifiers cannot be typeable?
01:50:35 <Peaker> s/forall/existential
01:51:36 <quicksilver> you were right the first time
01:51:37 <quicksilver> (forall)
01:51:47 <quicksilver> in a sense, it's only the nested foralls you can't Typeable
01:52:02 <quicksilver> in another sense, you can't really Typeable top level ones either but that turns out not to matter.
01:52:06 <quicksilver> ski_: did I get all that right?
01:52:54 <Peaker> How does lambdabot do plugins? Can they be installed after lambdabot? Do they just supply something Typeable?
01:52:55 * ski_ attempts recalling the actual methods of `Typable'
01:53:00 <Peaker> @src Typeable
01:53:01 <lambdabot> Source not found. Just try something else.
01:53:23 <quicksilver> Peaker: I think lambdabot's plugins are expected to be there at compile time.
01:53:29 <quicksilver> but I'm not sure, I've never looked at the code.
01:53:41 <quicksilver> you certainly *can* do run-time plugin loading with hs-plugins
01:53:50 <quicksilver> in fact, that's the motivation behind it, hence the name ;P
01:54:00 <Peaker> People associate static typing with inability to extend a system's code at runtime, and its time to break that association :)
01:54:11 * Peaker will look
01:54:16 <quicksilver> it's harder to extend at runtime in a static system, certainly.
01:54:21 <quicksilver> but GHC specifically permits it
01:54:28 <quicksilver> You can see GHCi loading modules at runtime
01:54:31 <quicksilver> after all...
01:54:47 <quicksilver> you just need to make sure you have a type system on your interface boundaries
01:54:56 <quicksilver> (and that means you trust the object files not to lie about their interfaces)
01:55:45 <Peaker> well, if I get source files and type-check them, I don't need to trust?
01:55:53 <ski_> `Showable' in `data  = forall x. Show x => S x' is `Typable' .. but raw quantified types ("polytypes") are not
01:56:05 <thoughtpolice> peaker: i've done the plugin thing several times; I wrote an IRC bot that could reboot/handle multiple servers and had extensible plugins that it could reload at runtime and nothing would go bad
01:56:10 <quicksilver> Peaker: correct.
01:56:28 <quicksilver> Peaker: (you just need to trust your type-checker! ;)
01:56:29 <Peaker> thoughtpolice: cool! is that very difficult?
01:56:32 * ski_ ponders whether that is right
01:56:50 <ski_> (quicksilver : i think you did)
01:56:54 <thoughtpolice> peaker: it was one of my first 'big' haskell projects; the code is pretty awful and somewhat tangled from what I remember, but it might still work
01:56:59 <thoughtpolice> you do need hs-plugins
01:57:11 <thoughtpolice> peaker: if you don't go the hs-plugins route you have another option, which is the GHC API
01:57:36 <Peaker> hs-plugins seems to have: eval :: Typeable a => String -> [Import] -> IO (Maybe a)
01:57:37 <Taejo> @hoogle Either a b-> Bool
01:57:38 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
01:57:38 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
01:57:38 <lambdabot> Distribution.ReadE ReadE :: String -> Either ErrorMsg a -> ReadE a
01:57:46 <Peaker> why is it in IO?
01:58:00 <thoughtpolice> but that's kind of difficult; you can load code into your program and use 'compileExpr' which returns an HValue to the result, but you must unsafeCoerce# it to use it - this works, but it's unsafe. otoh, you can use 'dynCompileExpr' but that uses Data.Dynamic, and it requires whatever expression is compiled to be of a monomorphic type
01:58:14 <thoughtpolice> peaker: because it creates a file, uses GHC to compile it and then loads it and gets the result
01:58:49 <ski_> Taejo : `isLeft',`isRight' ?
01:59:06 <Peaker> Taejo: either (const True) (const False)
01:59:15 * ski_ str a mailing-list post about lack of those ..
01:59:16 <Taejo> ski_: thank you
01:59:29 <Taejo> oh, they don't exist?
01:59:42 <thoughtpolice> Peaker: here's the old code - http://code.haskell.org/infinity/src/
01:59:43 <lambdabot> Title: Index of /infinity/src
01:59:47 <Peaker> Taejo: the folder (either) can do that as described above, just specify what to do with each case
01:59:50 <ski_> maybe they do in recent versions of libraries, not sure
02:00:01 <Peaker> thoughtpolice: Is there any inherent reason for it not to be completely pure?
02:00:04 <thoughtpolice> peaker: I eventually ended up rewriting that bot *again* and it was much, much better and could still do the plugin and reload thing if you have hs-plugins installed
02:00:09 <Peaker> thoughtpolice: or just implementation details?
02:00:11 <Taejo> Peaker: yeah, I know. I'd have thought isLeft was common enough
02:00:35 <quicksilver> Taejo: Bool is code smell.
02:00:41 <thoughtpolice> peaker: it could probably, but yeah the eval in hs-plugins just goes the easy route; take your expression, wrap a module skeleton around it, emit to file, compile and load object
02:00:49 <Peaker> Taejo: well, whatever you're going to do with that Bool, could probably be done with a Monad, MonadPlus or Monoid instances
02:01:18 <Peaker> thoughtpolice: yeah, but it would go a long way to allow "Dynamic programs" to be easy to write if it were pure
02:01:32 <Taejo> quicksilver: I parse a whole a bunch of files with Parsec, and I want to see if any of them have parse errors. what's wrong with "if any isLeft modules"?
02:01:46 <Peaker> thoughtpolice: also, why do you have to unsafeCoerce or use Dynamic, and not use static types and type checking?
02:02:09 <quicksilver> Taejo: nothing. Code smell is subjective and subtle. Bool in haskell almost often suggests a better way.
02:02:17 <ski_> <http://www.haskell.org/pipermail/libraries/2006-October/006098.html> Add partitionEithers, lefts, rights to Data.Either
02:02:18 <lambdabot> http://www.haskell.org/pipermail/libraries/2006-October/006098.html>
02:02:21 <Peaker> quicksilver: almost often ;)
02:03:22 <quicksilver> Taejo: in this case, you may use msum
02:03:31 <rwbarton> Taejo: you could use  case sequence_ modules of ....
02:03:44 <Taejo> hmm, ok
02:03:45 <quicksilver> erm, sorry, sequence_
02:03:49 <quicksilver> rwbarton is right :)
02:03:52 <Taejo> I find that less readable
02:04:01 <quicksilver> that's fair enough.
02:04:17 <rwbarton> It's more natural when you want the results of the parses as well.
02:04:30 <rwbarton> (Which you usually do, if you care about whether they parse.)
02:04:39 <Taejo> oh, that's a good point
02:04:42 <Taejo> :t sequence_
02:04:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
02:04:47 <Taejo> :t sequence
02:04:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:04:50 <thoughtpolice> Peaker: because you load the code into memory using the GHC API, so you must use the API to get back things from what it knows, e.g. returning a function
02:05:45 <thoughtpolice> peaker: but i'm not all that sure, I'm thinking it's difficult. the unsafeCoerce# case is in fact really workable - using dynCompileExpr *really* sucks because you're restricted to monotypes, and it's just damn annoying in practice
02:06:02 <Taejo> @src Either (>>)
02:06:02 <lambdabot> Source not found.
02:06:03 <Peaker> thoughtpolice: Well, if you start with Dynamic, you can go to a static type via a "cast" in a Maybe or such, right?
02:06:07 <Taejo> @src Either >>
02:06:07 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:06:08 <Taejo> @src Either >>=
02:06:08 <lambdabot> Source not found.
02:06:17 <Taejo> @src >>= Either
02:06:17 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:06:35 <Taejo> does sequencing in Either take the leftmost error?
02:06:50 <rwbarton> Yes
02:06:53 <quicksilver> Taejo: yup.
02:06:53 <Peaker> thoughtpolice: What about this "eval :: Typeable a => String -> [Import] -> IO (Maybe a)"  in hs-plugins?   It seems to return any typeable a you choose
02:07:16 <quicksilver> Taejo: it also doesn't waste time doing the parsing work after the first error
02:07:21 <quicksilver> which may or may not be a good thing.
02:07:29 <thoughtpolice> peaker: well the thing is say you've loaded a file into memory using the GHC API, and then do something like v <- dynCompileExpr "func1" - the function returns a Dynamic, but it will fail if 'func1' is of a polymorphic type
02:07:47 <thoughtpolice> (when I say 'the function returns a Dynamic' I mean dynCompileExpr, fyi)
02:08:06 <Peaker> thoughtpolice: oh, ok.  I am still wondering why not just to use that "eval" function that seems safe and flexible?
02:08:14 <thoughtpolice> hs-plugins goes deep directly into the GHC RTS
02:08:24 <thoughtpolice> the loading facility directly interfaces to the RTS linker code
02:08:32 <Peaker> quicksilver: the "any" one would also be lazy, wouldn't it?
02:08:40 <thoughtpolice> and it makes some guarantees the RTS doesn't
02:09:26 <quicksilver> Peaker: yes.
02:09:44 <thoughtpolice> e.g. if you use hs-plugins load and load an object file twice, nothing bad happens because it makes loading idempotent, but the actual RTS doesn't do that sort of check, so when the RTS loads object code, if you load the same object twice it doesn't care and it errs with conflicting symbol defs.
02:11:00 <Peaker> thoughtpolice: ok, I'll toy with it when I get some time, it'd be nice if it were as easy as it is in say, Python, to just get some stringy code to run
02:11:05 <ski_> (btw, Taejo might not want to implement `Error' on her/his "left" type ..)
02:11:11 <thoughtpolice> peaker: in the case of unsafeCoerce, you can do 'h <- compileExpr "func1" and then 'let (func 1 :: Show a => a -> b -> Int ...) = unsafeCoerce# h' and it'll work
02:11:25 <thoughtpolice> you just must be sure that 'func1' is actually of that type ;]
02:11:44 <Peaker> thoughtpolice: otherwise, seg fault?
02:12:16 <thoughtpolice> (in some cases you can guarantee this, e.g. yi 0.2 used this technique to boot itself up, since it knows for a fact the 'yiMain' function in the yi-0.2 library has that exact type)
02:12:29 <ski_> @src Either (>>=)
02:12:29 <lambdabot> Left  l >>= _ = Left l
02:12:29 <lambdabot> Right r >>= k = k r
02:12:32 <thoughtpolice> peaker: probably
02:12:39 <Peaker> I'd like a subset of Haskell that is completely "safe" (no seg faults, memory overwrites of stuff you don't have a reference to, etc), as a security platform..
02:14:23 <thoughtpolice> peaker: personally, I think it would be awesome if hs-plugins style functionality could be built directly into GHC, since it could probably now be built right on top of the API. then you can use the GHC API when you really need it, but you get a nice, easy plugins interface when you need it :]
02:14:28 <thoughtpolice> really hs-plugins is terrifically useful
02:15:19 <thoughtpolice> having something akin to it come stock with GHC so you can write dynamic applications *easily* out of the box would be great (hs-plugins does have a nice API)
02:15:21 <Peaker> I think getting anything to be dynamically loadable warrants the most horrible kinds of magic, too
02:16:01 <thoughtpolice> I believe ocaml 3.11 now has that feature; you can write native plugins and link them in at runtime
02:17:18 <quicksilver> safe haskell would also be nice: it's never been a priority of the GHC development.
02:18:36 <Peaker> and language-level security is far better than OS-level security, too
02:18:59 <Peaker> (has much better granularity, and should have much less of a performance hit)
02:19:38 <quicksilver> yes, well language-level security in haskell is in some sense fairly easy.
02:19:42 <quicksilver> it's just not been done.
02:19:50 <quicksilver> (excluding resource DOS, which is hard)
02:21:05 <arw> Peaker: yes, but language level security is not a substitute for OS-level security. you will always need the latter, even if its implemented by the former.
02:21:40 <Peaker> arw: yeah, I want my OS and my language-runtime to be the same :)
02:22:33 <thoughtpolice> speaking of safety I have been doing a bit of research into code proofing lately. very cool stuff. I have also decided to try learning ATS since it seems like something practical and it has dependent types.
02:22:37 <Peaker> (multiple languages can share the same runtime, as in .NET)
02:22:40 <arw> forth did that. its often used in some firmware stuff (what intel boxes call bios).
02:22:46 <thoughtpolice> i should probably read more of this coq tutorial...
02:23:48 <Peaker> thoughtpolice: code proof is awesome, but even type safety is enough to get far better security than we have today
02:23:57 <Peaker> (without dependent types)
02:25:37 <arw> depends. the runtimes that claim some kind of security have to do additional checks on the bytecode level because some evil person might have injected bytecode that circumvents some of the limits the type system of your language has set.
02:26:21 <arw> so in practice you only get to use 1 language, which is the bytecode, anything on top of it is just syntactic sugar, security-wise.
02:26:53 <Peaker> arw: in that sense, we x86 users have only had 1 language all along, the x86 machine code ;)
02:27:22 <Peaker> arw: also, your language just doesn't need to allow "injecting" byte code (or any way to convert a byte string to be an executable object)
02:27:34 <quicksilver> arw: sometimes you can hope to devise a relatively simple (easy to check) byte code invariant.
02:27:37 <thoughtpolice> peaker: sure. static typing in haskell helps an amazing amount, especially coming from e.g. a C background
02:28:07 <thoughtpolice> peaker: I just think dependent types are pretty awesome, and ATS actually looks like a language that has them and is *realistic* to write code in (it has an excellent C interface for that)
02:28:50 <arw> Peaker: your language doesn't need to allow that, but in practice you want to be able to distribute, save and execute binary programs in your OS.
02:29:43 <Peaker> arw: yeah, you can allow creating new executable bytecode, but only via a type-checking interface
02:30:12 <quicksilver> thoughtpolice: indeed, ATS can inline C
02:30:36 <quicksilver> Peaker: but you want people to be able to download code from the internet
02:30:40 <quicksilver> compile new code themselves
02:30:43 <quicksilver> compile new compilers!
02:30:44 <quicksilver> etc.
02:31:38 <ski_> boot-strap security holes into compilers!
02:31:43 <Peaker> quicksilver: yeah, they can compile new code. To compile a new compiler, though, they could use the special "executable bytecode creation" capability.. that capability should be well kept and only used to create new compilers or use trusted machine-code libraries
02:32:27 <Peaker> that cap is normally only given to the trusted compilers themselves, but the user can keep that cap safe-guarded somewhere (and be careful not to hand it to any code!)
02:32:58 <quicksilver> Peaker: fair enough.
02:33:16 <quicksilver> I certainly agree that's a workable approach.
02:33:23 <arw> the problem goes deeper than that. what if some user finds a way to put an unsafe binary on his harddisk?
02:33:27 <Taejo> is there a convenient why to define a function of type [Either a b] -> Either [a] [b], which accumulates all the Lefts if there are any, otherwise all the Rights
02:33:46 <quicksilver> arw: you have to protect the capability to mark a file as being executable.
02:33:49 <quicksilver> etc.
02:34:04 <Peaker> arw: if you've got physical access...
02:34:04 <quicksilver> Taejo: I thought you might ask that.
02:34:18 <quicksilver> Taejo: there is a nice example of an Error Applicative in the applicative paper
02:34:21 <arw> Peaker: hm, right.
02:34:25 <quicksilver> Taejo: which combines lefts (if there are any)
02:34:41 <ski_> quicksilver
02:34:42 <quicksilver> that may not be a practical solution, though.
02:34:59 <ski_>  : combines with `sequence' for `Applicative's ?
02:35:00 <Taejo> quicksilver: it's easy enough to write the fold myself
02:35:02 <thoughtpolice> quicksilver: yeah it's dandy handy - I wrote the beginnings of an ncurses interface just yesterday easy as pie. :] it would truthfully be a way more useful language *today* if there were just a few simple wrappers around e.g. pthreads and whatnot (and that would help remove code duplication among e.g. shootout entries, they use pthreads with inline C because there's no lib)
02:35:19 * quicksilver nods
02:35:29 <thoughtpolice> quicksilver: but yeah I'm a fan of simple lightweight FFIs, and ATS fits the bill for that.
02:35:34 <ski_> how would that work ?
02:35:57 <quicksilver> ski_: the error applicative runs all the computations and collects all the errors (if any) or all the results (if none)
02:36:08 <thoughtpolice> quicksilver: now if ATS could just compile down to say, ISO C... ;]
02:36:20 <ski_> oh .. right `Monoid' probably ..
02:36:24 <MyCatVerbs> > let { eitherWays [] = ([],[]); eitherways ((Left a):rest) = let (ls,rs) = eitherways rest in (a:ls,rs); eitherways ((Right a):rest) = let (ls,rs) = eitherways rest in (ls,a:rs); } in eitherways [Left 1,Right 2,Left 3, Left ,
02:36:25 <lambdabot>   <no location info>: parse error on input `;'
02:36:30 <quicksilver> f <*> x = case (f,x) of (Left e,Left e') -> Left (e++e'); etc
02:36:31 <MyCatVerbs> > let { eitherWays [] = ([],[]); eitherways ((Left a):rest) = let (ls,rs) = eitherways rest in (a:ls,rs); eitherways ((Right a):rest) = let (ls,rs) = eitherways rest in (ls,a:rs); } in eitherways [Left 1,Right 2,Left 3, Left 4, Right 5]
02:36:33 <lambdabot>   ([1,3,4* Exception: /tmp/4619494428248234203:71:83-227: Non-exhaustive patt...
02:36:58 <MyCatVerbs> Non exhaustive patterns in what? *blinkblink*
02:38:39 <MyCatVerbs> > let { eitherways [] = ([],[]); eitherways ((Left a):rest) = let (ls,rs) = eitherways rest in (a:ls,rs); eitherways ((Right a):rest) = let (ls,rs) = eitherways rest in (ls,a:rs); } in eitherways [Left 1,Right 2,Left 3, Left 4, Right 5]
02:38:41 <lambdabot>   ([1,3,4],[2,5])
02:38:51 <MyCatVerbs> Case sensitivity foils me again. ^^
02:40:06 <Peaker> You'd want the Either [] []   to accumulate lefts, and if no lefts at all, accumulate all the rights?
02:40:12 <quicksilver> yes.
02:40:25 <quicksilver> behave like sequence *except* collecct all the lefts instead of the first
02:40:36 <quicksilver> this is in fact sequenceA for a different Applicative
02:40:39 <quicksilver> (the one I just sketched)
02:41:42 <Peaker> but how do you combine lefts? If you take an [Either l r] and convert it to an Either [l] [r] then (Either l) and (Either [l]) cannot be the same Applicative
02:41:54 <Peaker> oh, its already a list in yours
02:41:58 <quicksilver> it's already a list
02:42:08 <quicksilver> probably it's Monoid m => Either m
02:42:10 <quicksilver> in practice
02:42:17 <quicksilver> lists was simpler for illustration.
02:42:21 <Peaker> yeah, generalizations ftw
02:43:07 <Peaker> unamb fails to compile: Module `Control.Exception' does not export `BlockedOnDeadMVar(..)'
02:43:21 <Peaker> (ghc 6.10.1)
02:43:42 <quicksilver> check the repo version of reactive, that works with 6.10
02:43:58 <quicksilver> they either switched to Control.OldException or used the new API
02:44:00 <quicksilver> I dunno which
02:44:09 * ski_ has several times wanted to collect "all errors available" in type checking and the like
02:44:40 <quicksilver> ski_: then the error applicative is the one for you :)
02:44:41 <ski_> (i.e. all errors not dependent on earlier errors .. so on parallel paths)
02:44:59 * quicksilver recommends re-reading the applicative paper
02:45:03 <quicksilver> once a year or so :)
02:45:23 * ski_ is not sure he's read the whole
02:45:35 <dolio> It's full of good stuff.
02:45:40 <ski_> *nod*
02:45:40 <Peaker> quicksilver: I don't understand - reactive has its own unamb or has solved the same problem similarly?
02:45:58 <quicksilver> Peaker: what you're seeing is an API change to exceptions in 6.10
02:46:02 <dolio> I think the epigram 2 repository has a bunch of extra stuff on top of it in a folder named "idiomatica" or something of the sort, too.
02:46:10 <quicksilver> Peaker: since reactive compiles with 6.10 they must have fixed it.
02:46:14 <dolio> That they never got around to publishing.
02:46:16 <Peaker> quicksilver: I think I used to compile unamb OK just until a few days ago
02:46:23 <Peaker> (with 6.10)
02:46:30 * quicksilver doesn't know then.
02:46:37 <quicksilver> mabe you changed your cabal dependencies
02:46:44 <quicksilver> and now you're using new base = new exceptions API
02:46:47 <quicksilver> or vice versa.
02:47:13 <dolio> Oh, my bad, it's just Idiomatica.lhs in a folder named Higgledy.
02:47:32 * Twey chuckles.
02:47:42 <Twey> module Idiomatica.Higgledy where...
02:47:50 <Peaker> quicksilver: the .cabal file said "base", I changed to "base >= 4" and it works now
02:47:51 <Twey> Or vice versa.
02:48:00 <thoughtpolice> reactive might as well use the new API
02:48:08 <thoughtpolice> it depends on vector-space which is ghc 6.9+ only
02:48:32 <Peaker> does ghc use the old Linux scheme of odd-dev-branch/even-stable-branch?
02:48:52 <thoughtpolice> yeah
02:49:19 <thoughtpolice> 6.10 is the current STABLE, 6.11 is HEAD, and 6.10.1 is the first release of the 6.10 branch
02:49:25 <Peaker> I think Linux abandoned it (since they now have branches for unstable development)
02:49:30 <quicksilver> Peaker: good.
02:50:57 <dolio> "newtype Zero = Zero {naughty :: forall a. a}"
02:52:42 <Peaker> I've only now noticd that field trip does seem to have light sources.. though those aren't defined in the scene itself?
02:52:50 <ski_> (: dolio
02:52:52 <Taejo> :t mapM_
02:52:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:53:10 <dolio> ski_: Conor McBride always picks fun names.
02:54:04 <quicksilver> not mention silly presentation themes
02:54:11 <quicksilver> conor++ # geek humour maestro
02:55:11 <Taejo> cannot match expected type String against inferred type HashFollowedBySomething in the second argument of (++), namely, `# geek humour maestro'
02:55:19 * ski_ mumbles "Wadler"
02:56:26 <ToRA|MSR> Taejo: actually i'd expect that to give a parse error for having two infixes next to each other...
02:56:36 <Taejo> ToRA|MSR: probably
03:01:55 <ddvlad> > (read "S") :: Char
03:01:56 <lambdabot>   * Exception: Prelude.read: no parse
03:02:26 <ddvlad> why the do we have Read Char?
03:02:33 <ddvlad> what am i missing?
03:02:41 <ToRA|MSR> > (read "'S'") :: Char
03:02:42 <lambdabot>   'S'
03:02:52 <ddvlad> whoa :P
03:02:58 <ddvlad> that was pretty unexpected
03:03:07 <ToRA|MSR> read parses what show outputs
03:03:11 <ToRA|MSR> > show 'S'
03:03:11 <Connochaetes> hello channel.
03:03:12 <lambdabot>   "'S'"
03:03:23 <ddvlad> thanks ToRA|MSR :)
03:03:26 <ToRA|MSR> np
03:03:43 <Connochaetes> I'm a self-taught newbie and I'm looking for a peer review of a short function.
03:04:27 <ski_> @hpaste
03:04:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:05:30 <Connochaetes> it's to add digits of a number at even and odd places, respectively, as a part of the EAN13 barcode checksum algorithm.
03:11:02 <hackage> Uploaded to hackage: storable-complex 0.2
03:11:11 <jedbrown> What is the Cabal flag to determine if Data.Generics is in base?
03:11:50 <rog_> i thought that ghci 6.10 was supposed to do utf-8 at the command-line. it doesn't seem to. any ideas on how to get it to do so?
03:16:08 <Twey> Connochaetes: The pastebin link was given to you for a reason :)
03:16:56 <Connochaetes> didn't i paste it?
03:17:12 <Connochaetes> terribly sorry :(
03:17:47 <Connochaetes> http://hpaste.org/12196
03:22:02 <rog_> is there any reason why defining this might be a bad idea? instance forall a b. (Typeable a, Typeable b) => Show ((->) a b) where show _ = "fn :: " ++ show (typeOf (undefined :: a -> b))
03:22:15 <SubStack> wow, moving that bit of code from List to Array worked the first time
03:22:42 <vixey> is that recursive rog_?
03:22:44 <rog_> it means that i can automatically derive Show instances for structures that happen to contain a function.
03:22:54 <rog_> vixey: no, i don't think so.
03:23:20 <vixey> it looks like it'll print "fn :: fn :: fn :: ..." to me
03:24:09 <rog_> vixey: i don't think so, because it's show typeOf, not show x
03:24:18 <vixey> oh right
03:24:43 <rog_> i.e. 'cos we can't print the body of a function, we just print its type.
03:25:04 <vixey> why do you write ((->) a b) instead of (a -> b)?
03:25:21 <ToRA|MSR> rog_: it will always succeed, so if you want to show to crash when the function is actually undefined then you might want to make it strict in the argument
03:25:27 <SubStack> wow, didn't even realize that was a function
03:25:33 <rog_> vixey: momentary lapse of reason
03:26:06 <ToRA|MSR> rog: so it doesn't really gain you anything that you didn't know from looking at the structures type (unless you're dealing with existential contexts...)
03:26:50 <solrize> @pl let fac n = if n==0 then 1 else n*fac(n-1)
03:26:50 <lambdabot> (line 1, column 43):
03:26:50 <lambdabot> unexpected end of input
03:26:50 <lambdabot> expecting variable, "(", operator, "*", "/", "`quot`", "`rem`", "`div`", "`mod`", ":%", "%", ";" or "in"
03:26:52 <quicksilver> rog_: well the reason not to do it, is that's not what Show is for.
03:26:59 <Twey> Connochaetes: Nothing too terrible, presuming it works
03:27:02 <solrize> @pl let fac n = if n==0 then 1 else n*fac(n-1) in fac
03:27:02 <lambdabot> fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1))
03:27:04 <quicksilver> rog_: however it can be convenient in certain debugging circs, definitely
03:27:14 <Connochaetes> Twey: it does.
03:27:17 <solrize> :t if'
03:27:18 <lambdabot> Not in scope: `if''
03:27:23 <rog_> ToRA|MSR: that's a reasonable point. i realise it doesn't give anything that i don't get from looking at the structure's type, but it means that i can automatically derive show when i happen to have a function in there.
03:27:49 <vixey> @pl let facorial n = product (enumFromTo 1 n)
03:27:49 <lambdabot> (line 1, column 42):
03:27:49 <lambdabot> unexpected end of input
03:27:49 <lambdabot> expecting variable, "(", operator, ";" or "in"
03:27:54 <ToRA|MSR> rog_: nod
03:27:55 <vixey> @pl facorial n = product (enumFromTo 1 n)
03:27:56 <lambdabot> facorial = product . enumFromTo 1
03:28:20 <Twey> Connochaetes: Looks good to me, then :)  The definition of mod' = flip mod and div' = flip div is a bit unorthodox, though
03:28:32 <wjt> > id
03:28:33 <lambdabot>       Overlapping instances for Show (a -> a)
03:28:33 <lambdabot>        arising from a use of `s...
03:28:34 <vixey> mod' is in the library
03:28:39 <Twey> Connochaetes: The ' suffix is usually reserved for strict versions of functions, in module scope
03:28:45 <ToRA|MSR> rog_ in which case make it strict so at least you get error checks when doing debugging
03:28:50 <vixey> :t mod'
03:28:51 <lambdabot> forall a. (Real a) => a -> a -> a
03:29:06 <vixey> it's not ' for strict
03:29:34 <Twey> Connochaetes: I'd be tempted to do it something like this: http://hpaste.org/12196#a1
03:29:55 <rog_> quicksilver: show is for producing a Read-able string, right? but if you can't produce such a thing (e.g. for a function), it's still useful to be able to produce some kind of textual represenation of a structure. i suppose that's what you mean by "convenient for debugging".
03:29:58 <Twey> Generalising is good
03:30:10 <Twey> But yours doesn't have any huge flaws
03:30:32 <quicksilver> rog_: show is for producing a string which is both Read-able and copy-paste-able into haskell source.
03:30:54 <quicksilver> rog_: certainly some kind of structural repr can be useful even in the absence of that
03:31:06 <Connochaetes> Twey: I'm quite impressed with your solution... I wouldn't see it on that level of generalisation.
03:31:12 * quicksilver wishes GHC could derive 'DebugStr' or somthing
03:31:26 <Connochaetes> Twey: of course, I was deep in the EAN13 :)
03:31:38 <Twey> So, instance Show Domino where show (Domino 6 6) = [:::|:::] is bad, then?  O:)
03:31:39 <rog_> quicksilver: is there any other standard way of extracting another structural representation?
03:31:43 <Twey> Er, plus quotes.
03:31:47 <vixey> > foldr (\x ys -> ys*10 + x) 0 [6,9,8,6,5,7]
03:31:48 <lambdabot>   756896
03:31:50 <vixey> > unfoldr (\n -> case n of 0 -> Nothing ; _ -> Just (swap (divMod n 10))) 756896
03:31:52 <lambdabot>   [6,9,8,6,5,7]
03:32:09 <Twey> vixey with the folds <3
03:32:25 <Twey> vixey: You always remind me of that xkcd comic
03:32:33 <Twey> 'Everybody stand back!  I know folds!'
03:32:36 <vixey> Twey, 🁡 :p
03:32:48 <vixey> (DOMINO TILE HORIZONTAL-06-06)
03:32:55 <Twey> Hahaha, nice!
03:33:40 <Twey> Connochaetes: Well, vixey's given us a better implementation of 'digits' :-P
03:34:09 <Connochaetes> :)
03:34:17 <Twey> digits base = reverse . unfoldr (\n -> case n of 0 -> Nothing ; _ -> Just (swap (divMod n base)))
03:34:19 <Connochaetes> Twey: oh, and odds and evens blow my mind.
03:34:38 <Twey> Connochaetes: Well, evens is pretty simple.
03:34:50 <Twey> Read it as 'odds, but starting from the second element' :-P
03:34:58 <Connochaetes> Twey: it's all simple when you see it on screen, but coming up with it...
03:35:10 <Twey> You'll get used to it
03:35:17 <Twey> You just need to get into the functional mindset
03:35:36 <Twey> And I just need to get a bit further into it to produce vixey-style folds :-P
03:35:57 <Connochaetes> I'm not even touching those for the time being :P
03:36:11 <Twey> Oh, you'll need to import Data.List to use unfoldr
03:36:23 <vixey> Connochaetes, Why not?
03:36:34 <jedbrown> How can my foo.cabal check whether syb is in base?  The obvious flag sybInBase is not set correctly with Cabal 1.6 and GHC 6.10.1.
03:37:02 <Connochaetes> vixey: well, not really - I'm just joking about being a haskell newbie.
03:37:16 <Connochaetes> everything needs head wrapping around :)
03:38:32 <Twey> Connochaetes: If you've got a bit of time on your hands, I strongly recommend SICP for learning to think in different styles :)
03:39:08 <vixey> yeah SICP is really good
03:39:14 <Connochaetes> Twey: I'm working through The Craft of Functional Programming at the moment. What do you make of that book?
03:39:35 <Twey> To tell you the truth, I got bored with it
03:39:38 <Twey> Heh
03:40:15 <Connochaetes> i've heard a lot of good things about SICP.
03:40:19 <Connochaetes> i'll give it a go.
03:40:28 <papermachine> SICP is a great book; I can't get past ch 3 though :(
03:40:42 <yitz> let digits = map (`mod` 10) . takeWhile (>0) . iterate (`div` 10) in digits 28374682
03:40:48 <yitz> > let digits = map (`mod` 10) . takeWhile (>0) . iterate (`div` 10) in digits 28374682
03:40:49 <lambdabot>   [2,8,6,4,7,3,8,2]
03:41:00 <yitz> (that's the classic definition)
03:41:10 <Twey> To learn programming in general (real programming, from first principles) I recommend SICP.  If it's just Haskell you want, Real-World Haskell is very good and available online, but you should make a note to go through SICP at some point in the future.
03:41:14 <Twey> yitz: Oh, nice.
03:41:25 <papermachine> > let digits = show in digits 28374682
03:41:27 <lambdabot>   "28374682"
03:41:28 <vixey> :k ErrorT
03:41:30 <lambdabot> * -> (* -> *) -> * -> *
03:41:44 <vixey> what classic ?
03:41:59 * Twey frowns.
03:42:04 <vixey> > let digits = map (`mod` 10) . takeWhile (>0) . iterate (`div` 10) in digits 280374682
03:42:06 <lambdabot>   [2,8,6,4,7,3,0,8,2]
03:42:16 <Connochaetes> Twey: I'm trying to learn what you call "real" programming. I don't want to end up a copy/paster.
03:42:20 <Twey> Ah, yes
03:42:30 <Twey> Connochaetes: *nod*
03:42:31 <vixey> @go The Story of Mel
03:42:37 <Twey> Heh
03:42:37 <idnar> > let digits = map digitToInt . show in digits 280374682
03:42:37 <lambdabot> http://www.pbm.com/~lindahl/mel.html
03:42:37 <lambdabot> Title: The story of Mel
03:42:38 <lambdabot>   [2,8,0,3,7,4,6,8,2]
03:42:40 <Twey> Mel, the Real Programmer
03:42:51 <Connochaetes> I'm earning my daily bread in Ruby and I don't think I'm bad... just this kind of work can deaden your brain.
03:43:05 <Twey> Connochaetes: *nod* You have to keep it interesting.  :)
03:43:06 <Connochaetes> Not trying to start a religious argument, of course :)
03:43:11 <yitz> vixey: don't know who first invented it, but I suspect it's been around since the early days of functional programming.
03:43:38 <Twey> But hark!
03:43:50 <Connochaetes> vixey: LOL
03:43:51 <Twey> > let digits = map (`mod` 10) . takeWhile (>0) . iterate (`div` 10) in digits 28030000
03:43:52 <lambdabot>   [0,0,0,0,3,0,8,2]
03:44:02 <Twey> It does work.  :-\
03:44:12 * Twey puzzles at it for a bit.
03:44:34 <vixey> > let digits = takeWhile (>0) . map (`mod` 10) . iterate (`div` 10) in digits 28030000
03:44:35 <lambdabot>   []
03:44:37 <vixey> that confused me too :p
03:45:09 <Twey> > iterate (`div` 10) 28030000
03:45:10 <lambdabot>   [28030000,2803000,280300,28030,2803,280,28,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
03:46:05 <Twey> > map (`mod` 10) $ iterate (`div` 10) 28030000
03:46:06 <lambdabot>   [0,0,0,0,3,0,8,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
03:46:12 <vixey> :k State
03:46:13 <lambdabot> * -> * -> *
03:46:14 <Twey> Oh!
03:46:17 <Twey> Oh!
03:46:20 <Twey> I understand it now.  :)
03:46:35 <Twey> Yes, that's obvious.  Silly me.  Heh
03:47:13 <vixey> ughhhhh
03:47:16 <Twey> digits base = map (`mod` 10) . takeWhile (> 0) . iterate (`div` base)
03:47:19 <Twey> Connochaetes
03:47:29 <vixey> you can't partially apply type synonyms
03:47:38 <vixey> even if you could partially apply what they synonymize
03:47:46 <yitz> Twey: mod base
03:47:50 * Twey nods.
03:47:53 * vixey has to eta reduce :(
03:47:53 <vixey> a
03:47:57 <Twey> Oops, yes
03:48:00 <Twey> digits base = map (`mod` base) . takeWhile (> 0) . iterate (`div` base)
03:48:09 <Twey> Knew there was a reason why I wasn't doing that point-free.
03:48:11 <Connochaetes> ok...
03:48:26 <Connochaetes> i was playing with your example.
03:48:36 <vixey> I think I count that as point free Twey
03:48:42 <yitz> @pl digits base = map (`mod` base) . takeWhile (> 0) . iterate (`div` base)
03:48:42 <lambdabot> digits = ap ((.) . map . flip mod) ((takeWhile (> 0) .) . iterate . flip div)
03:48:47 <Connochaetes> you need a case for evens being passed [], too.
03:48:47 <Twey> vixey: It has a point :-P
03:48:47 <yitz> yuck
03:48:52 <Twey> It gets fugly without it.
03:49:00 <vixey> yeah but it,,,... yeah exactly
03:49:01 <Twey> Connochaetes: Oh, yes, indeed
03:49:15 <Connochaetes> Twey: but yeah, it was hugely instructive.
03:49:29 <Twey> Connochaetes: Or you can use tailDef [] from the Safe package
03:49:54 <Twey> I like Safe, it's handy.
03:50:11 <Connochaetes> don't think I've ever imported it :)
03:50:44 <Twey> Connochaetes: It's not standard
03:50:50 <Twey> You have to get it from Hackage
03:51:01 <vixey> hum..... do I want ErrorT atthe midle or right on the outside
03:51:02 <thoughtpolice> yeah safe is a dandy library
03:51:34 <vixey> where does everyone else put ErrorT?
03:51:52 <Twey> Depends
03:52:00 <quicksilver> depends whethere you want the errors to rollback state effects or not
03:52:01 <quicksilver> etc.
03:52:11 * Twey nods.
03:52:50 <quicksilver> ErrorT State :: you get a final state even if an error occurs
03:53:03 <quicksilver> StateT Error :: there is only a final state if there is no error.
03:53:49 <vixey> :k Error
03:53:50 <yitz> ErrorT [] -- you get a list of values and errors
03:53:51 <lambdabot> Class `Error' used as a type
03:54:07 <yitz> ListTDoneRight Error -- you get either a list or an error
03:54:19 <Twey> Heh
03:54:33 <vixey> @instances Monad
03:54:34 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:55:09 <yitz> uh yeah, oops, it's ListTDoneRight Either
03:55:48 <swiert> ToRA|MSR: Will you be coming to Nottingham on Friday?
04:08:19 <vixey> it's really silly htat I have to change my  type FooT a b c = .... b c, into  type FooT a = ...
04:10:37 <vixey> what do you call things that are in a context?
04:10:46 <vixey> not 'contextands' :/
04:11:57 <Zao> contextual entities?
04:12:10 <Zao> contextees? :P
04:12:23 <vixey> oh Entity is good I guess
04:29:48 <Fallen_Demon> Hi guys
04:32:06 <BONUS> hi
04:32:22 <byorgey> hi there Fallen_Demon
04:32:58 <Fallen_Demon> Can anyone tell me where to start when building an expression tree?
04:33:23 <Fallen_Demon> I have a tokenised list, but I'm confused as to where to go next...
04:35:04 <vixey> Fallen_Demon, going form "1 + 3" into Add (Number 1) (Number 3)?
04:35:20 <ski_> @hoogle (a -> (b,c)) -> (b -> c -> d) -> d
04:35:20 <lambdabot> No results found
04:35:26 <ski_> bah!
04:35:52 <vixey> [NumToken 1, OpToken "+", NumToken 3] into Add (Number 1) (Number 3)?**
04:35:52 <Fallen_Demon> I have a list which goes "3+1" to "NUM 3 ADD NUM 1"
04:36:24 <vixey> yoneda . cnurry ?
04:36:28 <vixey> :?
04:36:40 <byorgey> surely you mean [NUM 3, ADD, NUM 1] ?
04:36:43 <vixey> @djinn (a -> (b,c)) -> (b -> c -> d) -> d
04:36:43 <lambdabot> -- f cannot be realized.
04:36:56 <Fallen_Demon> yeah, of course I do :)
04:37:02 <ski_> hrm .. possibly i want an `a' somewhere
04:37:05 <ski_> @hoogle (a -> (b,c)) -> (b -> c -> d) -> (a -> d)
04:37:06 <lambdabot> No results found
04:37:15 <vixey> Fallen_Demon, map Left
04:37:16 <Fallen_Demon> Sorry, I forgot I'm using haskell :P
04:37:23 <ski_> @type flip ((.) . uncurry)
04:37:24 <lambdabot> forall a a1 b c. (a -> (a1, b)) -> (a1 -> b -> c) -> a -> c
04:37:31 <vixey> [Left (NUM 3), Left ADD, Left (NUM 1)]
04:37:42 <ski_> @djinn (a -> (b,c)) -> (b -> c -> d) -> (a -> d)
04:37:42 <lambdabot> f a b c =
04:37:42 <lambdabot>     case a c of
04:37:42 <lambdabot>     (d, e) -> b d e
04:37:46 <vixey> then you can repeadetly split it on the weakest binding operator
04:38:08 <vixey> [Left (NUM 3)] & Left ADD & [Left (NUM 1)] -- is what you glom in this case
04:38:16 <byorgey> how does  map Left help?
04:38:17 <vixey> so you do it recursively to each tree
04:38:48 <vixey> [Right (Number 3)] & Left ADD & [Right (Number 1)] -- they both have length 1 but might not have before doing hte recursion
04:39:13 <vixey> then you can connect them up with tha Add operator
04:39:30 <vixey> [Right (Add (Number 3) (Number 1))] is what you'd get
04:39:36 <ski_> `Either' for bottom-up parsing ?
04:39:55 <vixey> this way makes it pretty easy to support various fixities and associativities (like unary pre/postfix ops)
04:40:12 <vixey> Either because otherwise the typechecker complains
04:40:33 <vixey> You can also just use buildExpressionParser from Parsec
04:40:50 * ski_ has an idea to use composable continuations to handle precedence and associativity,fixity
04:40:55 <Fallen_Demon> mmm, parsing and languages wasn't my strong point in my verification course this year :(
04:41:03 <vixey> slightly boring that way http://www.rosettacode.org/wiki/Arithmetic_Evaluator#Haskell
04:41:07 <lambdabot> Title: Arithmetic Evaluator - Rosetta Code
04:41:48 <vixey> ski will you describe it? :)
04:43:45 <vixey> byorgey, actually yeah you can also not use Either, that works too -- it's less like the prolog code I wrote yonks ago though
04:44:06 <ski_> vixey : possibly some day when i've worked it out in detail
04:44:14 <vixey> ski_, ok
04:45:39 <ski_> (it's basically currently a hunch, plus some attempts i made at it, quite a while ago)
04:48:49 <ski_> (.. would `withPair' be an acceptable name ?)
04:49:33 <vixey> for what?
04:49:37 <swiert> @seen nominolo
04:49:37 <lambdabot> nominolo is in #haskell-soc, #ghc and #haskell. I last heard nominolo speak 11h 56m 18s ago.
04:49:47 <ski_> @djinn (b,c) -> (b -> c -> d) -> d
04:49:48 <lambdabot> f (a, b) c = c a b
04:50:02 <vixey> :t uncurry
04:50:03 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:50:06 <vixey> :t curry
04:50:08 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
04:50:19 <vixey> :t flip uncurry
04:50:20 <lambdabot> forall a b c. (a, b) -> (a -> b -> c) -> c
04:50:28 <ski_> ah :)
04:50:41 <vixey> :t flip curry
04:50:50 <lambdabot> forall a b c. a -> ((a, b) -> c) -> b -> c
04:51:00 <quicksilver> :t curry . flip $ uncurry
04:51:01 <lambdabot> forall a b c. a -> b -> (a -> b -> c) -> c
04:51:08 <vixey> @src (,)
04:51:08 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:51:14 <vixey> data (p,q) = (p,q)
04:51:28 <vixey> pair (&) (p,q) = p & q
04:51:39 <vixey> :t let pair (&) (p,q) = p & q in pair
04:51:40 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t1) -> t2
04:51:46 <vixey> call it riap
04:51:52 <Philonous1> The pascal version looks funny. Like a mountain panorama
04:52:19 <vixey> Philonous1, yeah I have no idea wtf any of the other programs on that page are doing
04:52:40 <vixey> and in the discussion someone is complaining about ASTs being a waste of resources
04:53:13 <EvilTerran> resources are an implementation detail :P
04:53:34 <EvilTerran> @. pl djinn (b,c) -> (b -> c -> d) -> d
04:53:34 <lambdabot> f = uncurry (flip . flip id)
04:53:47 <vixey> :t uncurry (flip . flip id
04:53:48 <lambdabot> parse error (possibly incorrect indentation)
04:53:48 <vixey> :t uncurry (flip . flip id)
04:53:50 <lambdabot> forall b c a. (a, b) -> (a -> b -> c) -> c
04:53:55 <ski_> (.. grepping or regexping repeatedly through strings would be better ?)
04:53:57 <vixey> @free uncurry
04:53:58 <lambdabot> (forall x. h . k x = p (f x) . g) => h . uncurry k = uncurry p . $map_Pair f g
04:54:09 <vixey> ski_, haha
04:55:30 * ski_ wonders whether lex/1,lex/2 could be fitted into DCG ..
05:00:39 <yitz> @check \x y -> (,) x y == curry id x y
05:00:40 <lambdabot>   "OK, passed 500 tests."
05:00:52 <yitz> @type curry id
05:00:53 <lambdabot> forall a b. a -> b -> (a, b)
05:01:07 <vixey> @type either id
05:01:09 <lambdabot> forall a b. (b -> a) -> Either a b -> a
05:01:13 <vixey> @type maybe id
05:01:14 <lambdabot> forall a a1. (a1 -> a -> a) -> Maybe a1 -> a -> a
05:03:46 <ski_> @let cograph = (`either` id)
05:03:47 <lambdabot>  Defined.
05:04:30 <yitz> @type cograph
05:04:31 <lambdabot> forall a b. (a -> b) -> Either a b -> b
05:07:55 * rog_ *still* hasn't found a satisfactory way to debug haskell programs, particularly when there are lots of existentials around.
05:09:54 <quicksilver> rog: my main technique is to work on the model/data part of my program in ghci
05:10:00 <quicksilver> and develop tests/counterexamples as I go
05:10:41 <rog_> quicksilver: my current problem is that i'm not building from scratch - i've just refactored a large part of the code.
05:10:54 <rog_> quicksilver: so i'm not really sure what's going on inside anymore...
05:11:25 <vixey> why don't you start from scratch
05:11:27 <rog_> quicksilver: and then i get an exception, and it's so hard to find out the context in which it was raised!
05:12:08 <quicksilver> what kind of exception?
05:12:12 * quicksilver never uses exceptions.
05:12:22 <quicksilver> of course, I'm lying as always.
05:12:31 <rog_> vixey: 'cos it's 1300 lines of code...
05:12:39 <vixey> that's nothing :)
05:12:40 <quicksilver> I very rarely use exceptions and when I do, each one can only be raised in one place
05:12:45 <Connochaetes> rog_: are they at least meaningful exceptions?
05:12:47 <quicksilver> so there is no doubt about where it is raised.
05:12:56 <vixey> just start again it will be shorter next time around too
05:13:23 <rog_> Connochaetes: yes, they are. and i know exactly where they're raised. but not what called that function.
05:13:47 <Connochaetes> or do they handle with the ever-helpful "an error occured"?
05:13:54 <rog_> vixey: there's lots of code that really doesn't need to change! i've just broken some invariants somewhere.
05:14:19 <vixey> it sounds to me like dodgy code
05:14:39 <rog_> the main difficulty is that i'm using dynamics all over the place and if i get the structure wrong, i get a runtime type error.
05:14:58 <vixey> yikes.....
05:15:40 <rog_> i think i should probably have done it with template haskell, but i balked at learning yet another complicated thing...
05:15:53 <vixey> what is this program?
05:16:19 <quicksilver> hmm.
05:16:44 <quicksilver> "* rog_ *still* hasn't found a satisfactory way to debug haskell programs"... <-- well if you're using Dynamic, it's going to be much worse than a traditional haskell program.
05:16:52 <quicksilver> although I stand by my initial answer, actually.
05:17:03 <quicksilver> build up counterexamples in ghci gradually until you meet the bug.
05:17:09 <quicksilver> is what works best for me
05:17:35 <rog_> vixey: here's a description of one aspect of the problem: http://hpaste.org/12197#a0
05:18:59 <rog_> quicksilver: that is what i'm doing. it just seems very like stabbing in the dark, compared to "there's my stack trace, that was the context, oh yes i shouldn't be doing that there"
05:19:20 <vixey> this is mad
05:19:42 <Twey> Quite
05:19:43 <vixey> why don't you define a data that describes if something is precise or not? and skip all the TH Dynamic HList
05:19:44 <rog_> vixey: in what way?
05:20:03 <quicksilver> rog_: I agree that sometimes a stack trace + all local vars would make it simpler.
05:20:12 <quicksilver> I also believe there is a type-safe solution to rog's domain
05:20:17 <vixey> From your description I don't see why any of the tools like TH Dynamic or HList would be useful
05:20:28 <quicksilver> but I've spent a little while trying to help him build one, and never found something he was happy worked.
05:20:37 <quicksilver> and I didn't have time to keep working on it ;)
05:20:42 <quicksilver> it is a fairly subtle problem.
05:21:25 <rog_> vixey: it would be easy if there was only one variable. but there are many. and there's no easy way of running an algorithm over many fields in a record at once.
05:21:39 <rog_> oleg thought i'd be best off using TH
05:22:30 <vixey> lots of variables with different types?
05:22:43 <rog_> vixey: yes.
05:23:01 <vixey> so use Either ty1 (Either ty2 (... ())))
05:23:18 <ski_> s/()/Void/
05:23:27 <vixey> oh . yeah
05:23:29 <rog_> vixey: totally arbitrary types too, like [State0 -> Time -> (State0, Record)]
05:23:30 <vixey> that is a good idea
05:24:33 <rog_> vixey: that's similar to HList's approach.
05:24:46 <vixey> it's not actually similar
05:25:02 <vixey> HList is like (ty1, (ty2, ( ..., ()))0
05:25:18 <vixey> I'm saying to use a list of sums
05:25:23 <rog_> oh, i see.
05:25:39 <vixey> You can sort of place it between dynamic and Hlist
05:25:43 <rog_> but... don't i get exactly the same problems there?
05:25:47 <vixey> No
05:26:37 <rog_> if i'm expecting one variable to be of a particular kind, and i actually get another, then i've still got a runtime error
05:26:58 <vixey> use Error monad and throwError
05:27:13 <vixey> if you throw an error in a monad you know exactly from where it came
05:28:28 <rog_> but wouldn't that mean i'd have to structure my entire program monadically?
05:29:17 <pythonist> Can anyone tell me how to get rid of the warning? http://haskell.pastebin.com/m72ab64f3
05:29:54 <ski_> remove `_   -> "Unknown"'
05:29:56 <quicksilver> pythonist: you can't. There isn't a possible _ case because Foo is the only case.
05:31:14 <pythonist> quicksilver,ski: mmmmhh.... I understand...
05:31:34 <rog_> ... if i have put everything in a monad, i may as well not use haskell!
05:31:38 <rog_> s/have/have to/
05:31:57 <pythonist> quicksilver,ski: In fact, this is a toy case of a bigger application involving exception handling...
05:32:03 <quicksilver> rog_: rubbish.
05:32:26 <pythonist> quicksilver,ski: In that case, it makes sense to add a _ case, but now I have a clue...
05:32:32 <Twey> pythonist: Well, when you add the other constructors to SomeData, the warning will vanish.
05:32:37 <quicksilver> rog_: (a) you don't have to structure your whole program monadically just because a few functions use monadic combinators
05:32:56 <quicksilver> (b) having to use some monadic combinators doesn't mean you may as well not use haskell.
05:33:19 <pythonist> Twey: I just rtied that...
05:33:27 <pythonist> s/rtied/tried
05:33:52 <rog_> quicksilver: ... but if those functions are buried deep in the program, then everything needs to be defined in terms of the monad.
05:33:54 <Twey> pythonist: If it's `data SomeData = Foo | Bar`, there'll be no warning
05:34:07 <ski_> (c) using a specific monad guarantees you're not using effects not expressible in that monad
05:34:16 <quicksilver> rog_: that's just not true.
05:34:47 <rog_> quicksilver: well, everything that calls something that calls one of those functions, anyway.
05:34:51 <quicksilver> nope.
05:34:58 <rog_> nope?
05:35:08 <quicksilver> deeply buried code can directly extract the Left and Right from something which was built in the Either monad
05:35:11 <quicksilver> (for example)
05:35:18 <quicksilver> then code outside that point is no longer in the Either monad.
05:35:55 <rog_> quicksilver: ok, i understand that. but can i do that for the Error monad?
05:36:02 <quicksilver> the Error monad is the Either monad.
05:36:28 <quicksilver> the Error monad is just a way to apply useful monadic combinators (like sequence_ and mapM) to things which have Either type.
05:37:05 <quicksilver> these things are indepently useful and if someone hadn't spotted they were instances of a common pattern, they'd probably have a name of their own.
05:37:41 <quicksilver> analogously, concatMap is an indepently useful function, which just happens to be >>= for lsits.
05:37:47 <rog_> oh, i skim read. i though the Error monad was about catching exceptions.
05:37:53 <rog_> s/though/thought/
05:38:01 <quicksilver> however, this doesn't mean that one use of a list deep inside a program somehow "pollute" everything.
05:38:08 <quicksilver> at a high level, it is.
05:38:14 <quicksilver> but it's not about catching *haskell* exceptions
05:38:21 <quicksilver> in the sense of Control.Exception
05:38:23 <Igloo> Can anyone tell me which version of gmake is normally installed on a recent version of FreeBSD, NetBSD etc please?
05:38:25 <quicksilver> it's an alternative to exceptions.
05:38:28 <ski_> the `ErrorT e m' monad is a way to make sure you have to provide instance of `Error e' whether you like it or not
05:38:51 <quicksilver> the Error monad is a much more convenient than exceptions in pure code.
05:39:05 * quicksilver lacks grammar but hopes the meaning came through.
05:39:25 <heinsel> i dont understand hwo to declare typeclasses, and this book is a bit confusing when talking about it
05:39:38 <heinsel> do i declare it like: function :: Int -> Int
05:39:44 <heinsel> or what?
05:39:57 <rog_> i still don't really see how this helps. if i'm expecting (Left a) but some previous mistake has meant that i have in fact got (Right b), how can the Error monad help me to find the source of the problem?
05:40:02 <slarba_> class Foo a where function :: .. -> ..
05:40:47 <Connochaetes> heinsel: for example: class Foo where show = showFoo
05:40:47 <heinsel> slarba_, what?
05:40:54 <Connochaetes> heinsel: for example: class Show Foo where show = showFoo
05:41:04 <Connochaetes> (my mistake)
05:41:06 <slarba_> Connochaetes: that's an instance
05:41:13 <heinsel> still-not-following
05:41:17 <Connochaetes> oh, right
05:41:21 <quicksilver> rog_: I wasn't entirely following your discussion with vixey, I just wished to debunk the idea that using a monad in a haskell somehow pollutes the whole program.
05:41:28 <heinsel> function types need 'class'
05:41:31 <heinsel> ?
05:41:32 <slarba_> heinsel: try :info Eq in ghci
05:41:41 <ski_> heinsel : mayhaps you intended to ask about how to declare an instance to a type class ? or perchance how to declare a type signature, requiring some type variables to be in certain type classes ?
05:41:51 <quicksilver> rog_: generally you wish to attach appropriate location info to the error somehow, I agre.
05:41:57 <slarba_> heinsel: you get the Eq typeclass how it's declared
05:42:09 <slarba_> for example
05:42:15 <heinsel> i mean
05:42:16 <heinsel> # addThree :: Int -> Int -> Int -> Int
05:42:16 <heinsel> # addThree x y z = x + y + z
05:42:16 * quicksilver wonders if heinsel is really asking about typeclases, or abotu functions.
05:42:18 <heinsel> something like that
05:42:22 <quicksilver> heinsel: that's a function.
05:42:26 <quicksilver> (not a typeclass)
05:42:26 <Connochaetes> yeah, i got thr impression you were asking about instancing a class.
05:42:33 <ski_> heinsel : like `addThree :: Num a => a -> a -> a -> a' ?
05:42:37 <vixey> rog_: ".. if i have put everything in a monad, i may as well not use haskell!" -- woud lisp or java or whatever be easier? if yes you know what to do...
05:42:37 <heinsel> yea
05:42:39 <Connochaetes> *the
05:42:48 <heinsel> cus i can't do that in ghci without getting erros
05:42:54 <slarba_> ski_: that's a polymorphic function, not a typeclass ;)
05:43:00 <Connochaetes> or do you mean type variables?
05:43:05 <Connochaetes> addThree (Num a) => a -> a-> a-> a
05:43:06 <heinsel> omg
05:43:16 <heinsel> yeah, i know thats what happens when i enter :t addThree
05:43:21 <heinsel> but
05:43:21 <heinsel> ugh
05:43:27 <rog_> quicksilver: ok. yes, i was fully aware that not all monads are polluting. but many can be.
05:43:27 <ski_> slarba_ : oh, yes i know .. (but heinsel possibly didn't know the right term to ask about ..)
05:43:28 <Twey> heinsel: You can't define things in GHCi
05:43:36 <heinsel> ah
05:43:36 <slarba_> ski_: ah
05:43:41 <heinsel> Twey, kk
05:43:53 <Connochaetes> heinsel, i think i'm following you.
05:43:57 <Twey> (you can create functions with 'let', though)
05:43:59 <heinsel> ok cool
05:44:04 <heinsel> twey:
05:44:08 <Connochaetes> you want your own class to put in prototypes?
05:44:14 <heinsel> so it would be let blah :: Int -> Int ?
05:44:27 <heinsel> and in ghc it would be 'blah :: Int -> Int' ?
05:44:29 <Twey> heinsel: That's just a function type
05:44:41 <quicksilver> rog_: only IO is polluting.
05:44:45 <heinsel> oh but is that how it works
05:44:49 <heinsel> making function types
05:44:50 <quicksilver> rog_: and even that is less polluting than you probably imagine.
05:44:50 <Twey> You have to define the actual function as well
05:44:56 <heinsel> before or after?
05:45:00 <Twey> For classes, you want just the function type, yes
05:45:05 <Twey> But you can't define that in GHCi
05:45:09 <ski_> heinsel : e.g. `sum :: Num a => [a] -> a' means that for any numeric type `a', `sum' takes a list of values of type `a', and returns a value of type `a' (presumably the sum)
05:45:15 <vixey> rog_: wtf... lol
05:45:16 <Twey> Order doesn't matter
05:45:25 <vixey> rog_: You are ok with dynamic and Hlist but not monads?
05:45:26 <heinsel> sec
05:45:54 <rog_> quicksilver: surely other monads can be polluting, if the exporting module doesn't export a extraction function?
05:46:09 <rog_> vixey: "ok" is maybe a bit strong...
05:46:28 <quicksilver> rog_: monads without some kind of extraction function aren't very useful. IO is only an exception because the RTS magically knows how to extract IO.
05:46:40 <quicksilver> (STM is a submonad of IO so that's another case)
05:46:50 <ski_> heinsel : generally, it is preferred to define things in a source file .. however, if you insist on defining a value (with type signature) in GHCi, try `let blah :: Num a => a -> a; blah x = x*x'
05:47:07 <rog_> vixey: i'm ok with monads to an extent, but still haven't got my head around monad transformers.
05:47:22 <Twey> heinsel: But you can only define functions and values that way, not classes or types.
05:47:25 <heinsel> why do i need =>
05:47:29 <heinsel> i thought i only needed ->
05:47:38 <heinsel> kinda confused about this
05:47:40 <heinsel> test.hs:1:0: The function `main' is not defined in module `Main'
05:47:42 <heinsel> uhm
05:47:43 <Twey> foo => bar means 'bar where foo'
05:47:58 <heinsel> ok
05:48:03 <arw> a -> a is a function that takes a and returns a
05:48:05 <byorgey> heinsel: class constraints come before the =>.
05:48:09 <Twey> 'Num a => a -> a' means 'from type a to type a, where a is a Num instance'
05:48:14 <arw> the => gives additional constraints.
05:48:19 <ski_> heinsel : `=>' is used here to separate the meat of the type (to the right) from the constraints (to the left) .. here the constraint is `Num a' which claims that `a' must be a numeric type for the function to work
05:48:43 <heinsel> ffs
05:48:54 <heinsel> sec
05:49:03 <ski_> @type length
05:49:04 <lambdabot> forall a. [a] -> Int
05:49:10 <ski_> @type sum
05:49:11 <lambdabot> forall a. (Num a) => [a] -> a
05:49:17 <Twey> heinsel: After writing your declarations into a file, you can play around with it in GHCi by loading it: :l <file>.hs
05:49:27 <heinsel> k
05:49:31 <ski_> (ignore the `forall a.' .. that's GHC being non-H98 for you)
05:50:35 <byorgey> ski_: eh? I think lambdabot just has some extra options turned on.  GHC doesn't do that by default.
05:51:21 <ski_> oh .. you may be right
05:51:24 <ski_> i stand corrected
05:51:56 <heinsel> test.hs:1:0: The function `main' is not defined in module `Main'
05:52:08 <heinsel> on "blah :: Num a => a -> a; blah x = x*x" inside ghc + editor
05:52:10 <heinsel> wtf
05:52:36 <ski_> heinsel : did you try `ghci' ? (not `ghc' !)
05:52:47 <heinsel> sec
05:53:33 <heinsel> it works in ghci
05:53:38 <heinsel> but i dont know how to do it in ghc
05:53:43 <heinsel> i removed the 'let'
05:53:48 <heinsel> still not workin
05:54:52 <heinsel> i put "blah :: Num a => a -> a; blah x = x * x" in my editor and used ghc but its not working
05:54:54 <heinsel> gives me an error
05:54:57 <heinsel> test.hs:1:0: The function `main' is not defined in module `Main'
05:55:10 <heinsel> so im guessign i need to define a main somewhere ;\
05:55:22 <quicksilver> ghc compiles programs with a main function, yes
05:55:24 <quicksilver> you might want to try
05:55:27 <quicksilver> main = print blah
05:55:33 <Twey> If you try to compile a full application with ghc, you will need an entrypoint function main :: IO ()
05:55:34 <quicksilver> rm
05:55:39 <quicksilver> main = print (blah 4)
05:55:47 <quicksilver> (I forgot to give blah an argument)
05:55:48 <Twey> But what you almost certainly want to do is load the file into GHCi
05:56:01 <heinsel> yeah, im just trying to understand it all
05:56:08 <heinsel> if i want to do main = *
05:56:09 <Twey> In which case you do not need the entrypoint function.
05:56:16 <heinsel> why do i need to do print blah or IO () etc
05:56:34 <heinsel> in c i can just do int main()
05:56:39 <heinsel> can't i just do main here instead?
05:56:39 <Twey> heinsel: Because your program needs to do something
05:56:42 <heinsel> oh
05:56:46 <rog_> vixey: with your Either scheme, how would you define ways of initialising/extracting values, other than (Right (Right (Right (Left foo)))) which seems somewhat fragile? TH?
05:56:49 <heinsel> so if its a general main
05:56:51 <heinsel> what do i put
05:56:56 <BONUS> well
05:56:58 <heinsel> say this program did a lot of other stuff
05:56:59 <BONUS> what do you want your program to do?
05:57:17 <heinsel> just x*x print x back to user
05:57:19 <ski_> `ghc -c test.hs' for just compiling a module `test' not needing `main'
05:57:36 <BONUS> uh do you want it to prompt the user for the x?
05:57:44 <BONUS> and print back x*x
05:57:45 <BONUS> or what
05:58:01 <heinsel> yea
05:58:15 <heinsel> does main = * does * have to be a print or something.
05:58:18 <heinsel> or can it just be anything
05:58:37 <BONUS> it cant just be anything, it has to be an input/output job
05:59:17 <Twey> main = getLine >>= print . (\x -> x * x) . read
05:59:23 <Twey> For example.
05:59:31 <quicksilver> main = do x <- readLn; print (blah x)
05:59:40 <heinsel> you're just digging my grave for me
05:59:44 <heinsel> im asking
05:59:46 <heinsel> here
05:59:48 <heinsel> now
05:59:51 <heinsel> that main = whatever
05:59:58 <heinsel> main has to be an i/o job, right Boney
06:00:01 <heinsel> BONUS
06:00:10 <heinsel> ok so, it can be IO () ?
06:00:14 <BONUS> yup
06:00:20 <heinsel> like say, im writing a program that has many different jobs
06:00:26 <heinsel> what would i put
06:00:56 <heinsel> test.hs:1:7: Not in scope: data constructor `IO'
06:01:22 <BONUS> thats a very general question, depends really on what you want your program to do
06:01:34 <heinsel> ah k
06:01:45 <BONUS> anyway, you can't write main = IO ()
06:01:48 <BONUS> IO () is a type
06:02:10 <BONUS> but you can do main = do {x <- getLine; print (x ++ "!!!")}
06:02:11 <BONUS> or something like that
06:02:18 <BONUS> which will prompt for a line and then yell it back
06:02:28 <heinsel> mm.
06:02:28 <heinsel> cool
06:02:59 <BeelsebobWork> main = interact (+!!!) -- ?
06:03:21 <Twey> main = interact (++ "!!!") -- !
06:03:22 <heinsel> huh?
06:03:43 <BeelsebobWork> interact :: (String -> String) -> IO () -- it takes a function for mapping input to output, and runs it
06:03:44 <BeelsebobWork> lazily
06:03:46 <BONUS> i think he'd grasp it better at start if he just used do blocks instead of interact and >>= and stuff
06:03:56 <BeelsebobWork> I doubt that
06:04:15 <BONUS> well not grasp, just uh, get the program to do what he wants
06:04:22 <heinsel> :\
06:04:32 <BeelsebobWork> it's easy to get a program to do what you want with interact
06:04:34 <heinsel> what des interact (++ "!!!") -- !
06:04:35 <heinsel> mean
06:04:52 <BeelsebobWork> heinsel: it means, take the input, append "!!!" after it, and give that as output
06:04:55 <Twey> heinsel: (++ "!!!") is equivalent to \x -> x ++ "!!!"
06:05:08 <Axman6> @hoogle interact
06:05:08 <lambdabot> Prelude interact :: (String -> String) -> IO ()
06:05:08 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
06:05:08 <lambdabot> System.IO interact :: (String -> String) -> IO ()
06:05:09 <ski_> > (++ "!!!") "hello there"
06:05:10 <lambdabot>   "hello there!!!"
06:05:33 <heinsel> k i think i need to just read the book properly
06:05:47 <BONUS> yeah it's best to just dive into the tutorials first
06:05:51 <BONUS> and go along with them
06:06:06 <BONUS> because functional programming is very different from your standard C/Java programming pattern
06:06:15 <ski_> > "hello there" ++ "!!!"  -- in case you were wondering
06:06:15 <Axman6> hmm, interact (++ "!") just echos for me
06:06:16 <lambdabot>   "hello there!!!"
06:06:31 <BeelsebobWork> Axman6: until you press ctrl-d
06:06:42 <BeelsebobWork> (it needs the whole input before it can append the !)
06:07:15 <ski_> interact (onLines (++ "!!!"))
06:07:22 <BeelsebobWork> indeed
06:07:35 <int-e> interact (unlines . map (++ "!") . lines)
06:08:18 <lilac> where onLines f = unlines . map f . lines
06:08:33 <ski_> (ty conal)
06:08:42 <lilac> i love the way i can write stuff in pseudo-english and have haskell understand what i mean :)
06:08:46 <BONUS> i dont think you can achieve main = getLine >>= print . (++ "!!!") with interact
06:09:12 <Axman6> @src interact
06:09:12 <lambdabot> interact f = do s <- getContents; putStr (f s)
06:09:39 <Twey> :(
06:09:52 <ski_> BONUS : how about `interact ((++ "!!!") . head . lines)' ?
06:09:54 <lilac> BONUS: main = interact ((++"!!!") . head . lines)
06:10:08 * ski_ smiles
06:10:11 <Twey> interact f = getContents >>= putStr . f
06:10:23 <BONUS> haha
06:10:23 * Twey has come to dislike do notation
06:10:24 <BONUS> touche
06:10:34 <lilac> good ol' lazy IO
06:10:41 <ski_> Twey : please, with `(=<<)' or `(>.>)'
06:10:45 <BeelsebobWork> people are very keen to say that interact is horribly limited and that it can't do anything useful
06:10:57 <Twey> Haha, what on Earth is (>.>)?
06:10:59 <BeelsebobWork> in reality it can do pretty much everything you ever wanted in a terminal app
06:11:06 <Twey> Oh, monadic combinators
06:11:06 <ski_> (>.>) = flip (.)
06:11:13 <BeelsebobWork> lol
06:11:15 <BONUS> ^_^
06:11:15 <Twey> Huh.
06:11:18 <Axman6> so it's pipe?
06:11:18 <BeelsebobWork> so that's why it looks shifty at you
06:11:22 <Twey> (>.>) === (>>>) then
06:11:23 <ski_> (aka `(>>>)' now that arrows are around ..)
06:11:29 <BONUS> yeah
06:11:29 <lilac> BeelsebobWork: i quite like the idea of a pure terminal app :: String -> String :)
06:11:29 <Twey> Heh
06:11:33 <Axman6> f.g = g|f = g >.> f?
06:11:42 <heinsel> mm why doesnt this work: Prelude> let blah :: Num a => a -> a -> a; blah a = a * a * a
06:12:06 <lilac> heinsel: blah only takes one 'a', not two
06:12:09 <Twey> f >>> putStr =<< getContents
06:12:13 <lilac> blah :: Num a => a -> a
06:12:13 <Axman6> heinsel: because that type signature doesn't match
06:12:15 <Twey> Looks odd
06:12:22 <ski_> Twey : argh
06:12:26 <rog_> ski_: lovely demonstration a pure function having side effects; the joys of unsafeInterleaveIO, i guess.
06:12:27 <lilac> Twey: *shudder*
06:12:31 <BeelsebobWork> lilac: exactly -- it's a much nicer type than IO ()
06:12:40 <rog_> s/ a / of a /
06:12:41 <Twey> Heh
06:12:43 <ski_> Twey : try to stay with *one* order .. not mix them
06:12:50 * Twey chuckles.
06:12:52 <Twey> No kidding
06:13:11 <BONUS> eh, i hate using >>> for functions if you're not using it with *** and &&& and the other arrow functions
06:13:21 <ski_> rog_ : no side-effects .. just effects :)
06:13:23 <BONUS> good old . is fine for me
06:13:55 <rog_> ski_: could've fooled me.
06:14:19 * ski_ grumbles something about using `(>.>)' long before this newfangled "Arrow" stuff appeared
06:14:19 <heinsel> sorry
06:14:21 <heinsel> mm why doesnt this work: Prelude> let blah :: Num a => a -> a -> a; blah a = a * a * a
06:14:27 <lilac> does it annoy anyone else that the 'default' direction of information flow for arrows and monads (left to right) is the opposite of that for functions?
06:15:06 <BONUS> try let blah :: Num a => a -> a; blah a = a * a * a
06:15:06 <ski_> (rog_ : why failure ?)
06:15:43 <heinsel> BONUS: why 'Num a -> a" instead?
06:15:50 <Connochaetes> (thanks for help once again... catch you all later)
06:15:53 <Twey> heinsel: Because you've got an extra argument
06:15:57 <ski_> heinsel : also try `let blah :: Num a => a -> a; blah x = x * x * x', if that makes things clearer for you
06:16:01 <lilac> actually, i think arrows are fixed in 6.10 with (.) being moved to Category ?
06:16:03 <Axman6> heinsel: well, it takes a number, and returns a number right?
06:16:09 <heinsel> ya..
06:16:22 <heinsel> ah
06:16:29 <Twey> heinsel: The type on the left is that of the final value
06:16:38 <Twey> heinsel: Everything before that is a parameter
06:16:45 <heinsel> Axman6, well it takes 3 numbers and multiplies them
06:16:50 <byorgey> ski_: and now that you've gotten used to (>>>), it's just been moved to Control.Category =)
06:16:50 <Axman6> :t let blah x = x*x*x in blah
06:16:51 <lambdabot> forall a. (Num a) => a -> a
06:16:53 <heinsel> Twey: yea
06:16:54 <Axman6> no it doesn't
06:16:58 <heinsel> oh
06:17:00 <lilac> heinsel: it takes one number and cubes it
06:17:16 <Axman6> it takes one number, and cubes it... damn it lilac, pulled a BeelsebobWork on me!
06:17:18 <rog_> ski_: ?
06:17:20 <lilac> equivalently blah a = a ^ 3
06:17:27 <Twey> So a -> a -> a can be thought of, superficially, as 'takes two as and returns an a'
06:17:29 <BeelsebobWork> hahahaha
06:17:30 <heinsel> :t let blah x = a * b * c in blah
06:17:31 <lambdabot> forall t. t -> Expr
06:17:32 <lilac> Axman6: i call it pulling a ski_ :)
06:17:37 <heinsel> uhm
06:17:37 <heinsel> k
06:17:47 <Twey> equivalently blah = (^3)
06:17:49 <Twey> >.>
06:17:51 <ski_> byorgey : and not a second too early
06:17:58 <byorgey> ski_: indeed =)
06:18:07 <heinsel> bah ill just read this book and stop borhering you lol
06:18:17 <Axman6> heinsel: do you understand how the x in blah x, and x*x*x relate?
06:18:17 <heinsel> thanks
06:18:24 <ski_> rog_ : re "could've fooled me" .. what did you think i was trying to fool you with ?
06:18:25 <BONUS> hehe np but its good to follow a tutorial to get the basics
06:18:29 <BONUS> btw which book are you reading
06:18:30 <lilac> byorgey: not just moved, but moved, renamed and flipped, no? :)
06:18:38 <heinsel> Axman6: yeah, but i dont understand how blah x = a * b * c is the same
06:18:40 <Axman6> you should follow BONUS' tutorial
06:18:44 <heinsel> because there are three diff values
06:18:45 <Axman6> heinsel: it's not
06:18:47 <heinsel> a b and c
06:18:48 <heinsel> so
06:18:49 <BONUS> :]
06:18:49 <rog_> ski_: that there were no side effects
06:18:59 <heinsel> im reading the pic book
06:19:00 <Axman6> >let blah x = a*b*c in blah 20
06:19:05 <idnar> heinsel: I think you mean "blah a b c = a * b * c"?
06:19:07 <Axman6> > let blah x = a*b*c in blah 20
06:19:08 <lambdabot>   a * b * c
06:19:18 <heinsel> 20?
06:19:19 <Axman6> > let blah x = x*x*x in blah 20
06:19:20 <lambdabot>   8000
06:19:23 <rog_> ski_: ... though i see we're spared within-program side-effects because interact closes the file handle
06:19:24 <heinsel> oh
06:19:34 <heinsel> :t let blah x = a*b*c in blah 20
06:19:35 <lambdabot> Expr
06:19:36 <byorgey> lilac: oh, indeed!
06:19:40 <byorgey> I must have missed that =)
06:19:42 <heinsel> uff
06:19:47 <ski_> rog_ : i wasn't kidding
06:19:49 <Axman6> heinsel: don't worry about that
06:19:50 <byorgey> lilac: it does still export >>> though
06:19:54 <idnar> heinsel: a, b, and c are bound to some weird stuff in the bot
06:20:00 <heinsel> i feel too dumb for this lol
06:20:02 <idnar> :t let blah x = i * j * k in blah 2
06:20:03 <lambdabot> Expr
06:20:06 <BONUS> no no no
06:20:06 <idnar> grr
06:20:12 <BONUS> its rly easy
06:20:16 <idnar> :t let blah x = foo * bar * baz in blah 20
06:20:17 <lambdabot> Not in scope: `foo'
06:20:17 <lambdabot> Not in scope: `bar'
06:20:17 <lambdabot> Not in scope: `baz'
06:20:20 <BONUS> just follow a tutorial or read a few of them and you'll be fine
06:20:21 <idnar> that's what I wanted :P
06:20:30 <heinsel> nod
06:20:45 <byorgey> heinsel: how many days have you been learning Haskell?
06:20:49 <lilac> byorgey: i'm left wishing for =<< or <=< to be made the 'primary' composition for Monads
06:20:50 <heinsel> about 3
06:20:53 <heinsel> maybe 4
06:20:58 <Axman6> heinsel: have you done much maths with functions? like f(x) = x^2+2*x+3?
06:21:11 <heinsel> Axman6: not really
06:21:24 <Axman6> ok, well, do you see what's going on there?
06:21:29 <byorgey> heinsel: ok, you have to try for at least 2 or 3 weeks before you are allowed to make judgments about whether you are too dumb.  which you most assuredly aren't. =)
06:21:31 <BONUS> speaking of tutorials ... i've been forcing myself to continue writing the I/O chapter but i just cant seem to stick to it because i think I/O is the most boring part of haskell
06:21:37 <ski_> (rog_ : of course, it's all about POV, so ..)
06:21:46 <heinsel> not really, without () i cant tell which is first in order
06:21:52 <Axman6> you put in an x, and get back a value according to what's on the right of the =
06:22:06 <byorgey> lilac: <=< would be fantastic.
06:22:10 <heinsel> yeah i understand that part
06:22:17 <BONUS> yeah anyway, i gave up learning haskell 2 times because it was just too strange before i finally got it
06:22:21 <byorgey> lilac: then the monad laws are just the category laws.
06:22:22 <BONUS> and then i wrote that picture book :]
06:22:38 <heinsel> BONUS, how many years you know haskell?
06:22:39 <Axman6> BONUS: luckily, i was 'forced' to learn it for uni, and loved it :)
06:22:53 <BONUS> heinsel: i picked up haskell in april
06:22:57 <heinsel> ooh
06:23:03 <BONUS> around there yeah
06:23:18 <heinsel> kk
06:23:22 <heinsel> ok so
06:23:35 <byorgey> heinsel: keep at it, Haskell is so different from other languages that it can take a while to get used to.
06:23:41 <heinsel> let blah x = Num a => a * b * c is wrong/right?
06:23:51 <ski_> not correct
06:23:51 <heinsel> byorgey: i failed other langs too ;\
06:23:53 <Twey> It's easy and fun once you break through, though.
06:24:03 <BONUS> it's not wrong if a, b and c are defined somewhere else though
06:24:04 <byorgey> that frustrated feeling that you are just not getting it is the feeling of your brain expanding =)
06:24:04 <Twey> heinsel: Very wrong :)
06:24:09 <heinsel> wait
06:24:11 <heinsel> sorry
06:24:21 <ski_> use `blah :: Num a => ...' when you want to tell the type
06:24:23 <heinsel> let blah :: Num a => blah x = a * b * c
06:24:27 <ski_> er
06:24:28 <heinsel> right?
06:24:32 <BONUS> @remember frustrated <byorgey> that frustrated feeling that you are just not getting it is the feeling of your brain expanding =)
06:24:32 <lambdabot> Good to know.
06:24:35 <BONUS> haha
06:25:01 <Axman6> heinsel: no
06:25:06 <heinsel> BONUS, i keep getting that feeling without becoming wiser :\
06:25:24 <ski_> heinsel : you need two parts .. one like `blah :: ...' that will probably be something like `Num a => ...' in your case
06:25:27 <BONUS> heinsel: for starters, just forget the type thing, just do: Prelude> let blah x = x*x*x
06:25:31 <BONUS> Prelude> blah 3
06:25:32 <Axman6> > let blah :: Num a => a -> a; blah x = x*x*x in blah 15
06:25:32 <BONUS> 9
06:25:33 <lambdabot>   3375
06:25:38 <ski_> heinsel : the other part is the definition, like `blah x = ...'
06:25:51 <heinsel> ya
06:26:15 <ski_> the type part with `::' can most often just be skipped, and the implementation will figure it out for you
06:26:26 <Axman6> heinsel: yeah, like BONUS said, you don't need to worry about saying what type a function is, haskell is smart enough to figure it out for you
06:26:33 <heinsel> so the definition for a function that would take three diff numbers and multiply them together would be: let blah :: Num a => a; blah a = b * c ?
06:26:45 <heinsel> yeah, but i dont want to walk away from this etierh
06:26:49 <BONUS> let blah x y z = x * y * z
06:26:49 <lilac> @type let blah a b c = a * b * c in blah
06:26:50 <lambdabot> forall a. (Num a) => a -> a -> a -> a
06:27:15 <C-Keen> >:t tails
06:27:15 <Axman6> :t map (+2)
06:27:16 <lambdabot> forall a. (Num a) => [a] -> [a]
06:27:18 <BONUS> think of it like if oyu have a python function: def blah(x, y, z) { return x * y * z }
06:27:30 <C-Keen> :t tails
06:27:31 <lambdabot> forall a. [a] -> [[a]]
06:27:36 <rog_> ski_: it does seem a bit strange that  'interact (\x -> seq (head (tail x)) (head x))' and 'interact (head . lines)' behave differently.
06:28:12 <ski_> @type interact (\x -> seq (head (tail x)) (head x))
06:28:13 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Char'
06:28:13 <lambdabot>     In the expression: seq (head (tail x)) (head x)
06:28:13 <lambdabot>     In the first argument of `interact', namely
06:28:15 <rog_> ski_: ... and if you *could* string two interacts back-to-back, you could observe the effects within a single haskell program
06:28:26 <lilac> heinsel: which other programming language(s) do you know?
06:28:44 <BONUS> as you can see, one of the best parts of Haskell is #haskell
06:28:52 <rog_> ski_: sorry, i meant: interact ((\x -> seq (head (tail x)) (head x)) . lines)
06:28:52 <heinsel> lilac: i spent 4 years learning c but never quite got it. and asm for about two but never quite got it either
06:28:56 <heinsel> i think i get this: Prelude> let blah :: Num a => a -> a; blah a = a * a
06:28:56 <heinsel> Prelude> let blah :: Num a => a -> a; blah a = a * a * a
06:28:56 <heinsel> Prelude> let blah :: Num a => a -> a; blah a = a * a * a * a
06:29:04 <ski_> (rog_ : and i'm not sure about your latter claim ..)
06:29:05 <C-Keen> BONUS: this is really true
06:29:11 <heinsel> doesn't matter whats at the right hand side
06:29:12 <heinsel> right?
06:29:14 <Twey> heinsel: That's the way to do it!
06:29:24 <byorgey> heinsel: as long as it has the right type, sure
06:29:24 <heinsel> ok but now
06:29:25 <ski_> (where "i'm not sure" means "i don't believe")
06:29:30 <Axman6> heinsel: the last bit after the -> is the type it returns
06:29:31 <C-Keen> @remember haskell BONUS> as you can see, one of the best parts of Haskell is #haskell
06:29:31 <lambdabot> I will never forget.
06:29:31 <Twey> It does kind of matter, because it changes what your function does :-P
06:29:42 <Axman6> like, take the even function
06:29:45 <Axman6> :t even
06:29:46 <lambdabot> forall a. (Integral a) => a -> Bool
06:29:53 <bastl> Hello. I want to have a string representation of the _type_ of an expression. Like ":t exp" in the interpreter. How do i get that in my own program?
06:30:16 <heinsel> Prelude> let blah :: Num a => a -> b -> c -> d; blah a = a * b * c * d
06:30:18 <Axman6> takes an Integer, and returns a Bool saying whether it's even or not
06:30:20 <lilac> heinsel: ok, so 'blah x y z = x*y*z' is like 'int blah(int x, int y, int z) { return x * y * z; }' (only the Haskell one works over more types)
06:30:23 <Axman6> > even 6
06:30:26 <lambdabot>   True
06:30:37 <heinsel> lilac, understand that a bit more
06:30:41 <lilac> heinsel: and 'blah x = x * x * x' is like 'int blah(int x) { return x * x * x; }'
06:30:46 <bastl> :t :t
06:30:47 <lambdabot> parse error on input `:'
06:30:48 <Twey> bastl: See Data.Typeable
06:30:48 <heinsel> yeah get that
06:30:51 <bastl> hmm
06:31:34 <byorgey> bastl: use  show . typeOf
06:31:40 <Axman6> :t (:t)
06:31:41 <lambdabot>     Ambiguous occurrence `t'
06:31:41 <lambdabot>     It could refer to either `L.t', defined at <local>:17:0
06:31:41 <lambdabot>                           or `SimpleReflect.t', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:72:0-32
06:31:42 <rog_> ski_: it seems evident to me: if i'm reading a file with two sequential interacts, and the first interact reads an extra line, then the behaviour of my program is different due to the behaviour of the "pure" function, because the second interact won't get that line.
06:31:44 <Twey> The :t is a special interpreter feature, you can't use it in a program
06:31:56 <lilac> heinsel: the "blah :: ..." bit is used to tell Haskell the type, so it's like the "int blah(int,int,int)" in C.
06:32:00 <Twey> > show $ typeOf 3
06:32:01 <lambdabot>   "Integer"
06:32:06 <bastl> hehe just tried to fool lambdabot ...
06:32:08 <heinsel> so k.
06:32:13 <heinsel> now something else
06:32:23 <heinsel> let blah x y z = x * y * z
06:32:25 <Twey> bastl: It'll work for anything that implements Typeable
06:32:29 <heinsel> can i do f = blah?
06:32:36 <byorgey> heinsel: sure
06:32:36 <Axman6> yep :)
06:32:37 <heinsel> so when i call f, its the values passed?
06:32:40 <Twey> > show $ typeOf (*)
06:32:41 <lambdabot>   "Integer -> Integer -> Integer"
06:32:42 <heinsel> like blah 10 20 30
06:32:46 <heinsel> f = blah
06:32:48 <heinsel> only that instance
06:32:49 <lilac> heinsel: yes
06:32:53 <bastl> and my own types, e.g. those in a generated parser?
06:33:08 <Axman6> heinsel: that's a pretty large step you just took btw :)
06:33:08 <rog_> Twey: i'm surprised (*) is Typeable in that context
06:33:08 <heinsel> Prelude> let blah x y z = x * y * z
06:33:08 <heinsel> Prelude> d = blah 10 20 30
06:33:08 <heinsel> <interactive>:1:2: parse error on input `='
06:33:09 <Twey> bastl: If you give them Typeable instances, then yes
06:33:19 <heinsel> ohoh
06:33:21 <Twey> rog_: Defaulting
06:33:22 <heinsel> let d = ...
06:33:23 <heinsel> dur
06:33:33 <lilac> heinsel: yes, ghci is implicitly in a 'do' block
06:33:47 <Zao> > let f = (+) in f 42 3
06:33:49 <lambdabot>   45
06:33:59 <byorgey> bastl: you don't even have to write the Typeable instances yourself, you can say 'deriving (Typeable)' if you use the -XDeriveDataTypeable flag
06:34:25 <Axman6> :t typeOf
06:34:26 <lambdabot> forall a. (Typeable a) => a -> TypeRep
06:34:44 <heinsel> well thanks guys
06:34:51 <bastl> Twey: I have _a lot_ of types and would like to have it automatically, since the types are generated from a grammar. But ill play around with yopur suggestions a bit. thanks
06:34:57 <heinsel> i feel like im not really getting anything and becoming dumber but meh
06:35:00 <heinsel> :)
06:35:54 <lilac> feeling dumber is a necessary part of learning haskell. it generates the headroom you need in order to feel a lot smarter when you start to 'get' it
06:37:07 <ski_> rog_ : i interpret "string two interacts back-to-back" as redirecting `stdout' from one `interact' action to `stdin' for the other one  .. i don't see how this would allow one to observe anything more than just composing the underlying string transformers
06:38:38 <PeakerWork> I am teaching my friend Haskell, and he tried to pattern match functions to get their result (reader-monad-wise), that's an interesting idea :)
06:39:51 <Twey> PeakerWork: What do you mean?
06:39:58 <ski_> PeakerWork : yes .. especially non-trivial examples are fun
06:40:21 <saml> i copied and pasted opengl example file and compiled it and ran it. and i see a sphere!!!! yay
06:40:54 <PeakerWork> something like:  f (->x) = (x*2)         would convert to:       f g x = (g x)*2
06:40:58 <ski_>   pair :: (a -> b) -> (a -> c) -> (a -> (b,c))
06:40:59 <ski_>   pair (\a -> b) (\a -> c) a = (b,c)
06:41:00 <ski_> e.g.
06:41:27 <ski_> PeakerWork : your example would be `f (\x -> y) x = y*2'
06:41:58 <ski_> (indicentally, `y' here is a variable dependent on `x' in the sense of math analysis notation)
06:42:08 <orbitz> wild
06:42:08 <PeakerWork> ski_: yeah, cool :-)
06:42:23 <ski_> also
06:43:16 <ski_>   callCC :: ((a -> b) -> a) -> a
06:43:17 <ski_>   callCC (\(\a1 -> _) -> a0) = a0@a1
06:43:26 <ski_> (but this is crazy talk)
06:44:46 <ski_> (you may prefer `pair (\a -> b) (\a -> c) = \a -> (b,c)', alternatively)
06:45:59 <rog_> ski_: i interpreted it as "do interact f1; interact f2" which actually gives an illegal operation exception
06:46:24 <PeakerWork> ski_: I don't understand what a0@a1 is supposed to mean
06:46:29 <ski_> oh .. right that's another thing
06:46:34 <BeelsebobWork> does -auto-all put watchpoints on local function defs?
06:46:50 <ski_> PeakerWork : return `a0' alternativelt `a1' depending on whichever is available
06:47:18 <PeakerWork> ski_: maybe its more clear if you use the result function notation of the latter pair you showed
06:47:34 <ski_> PeakerWork : `callCC (\k -> 42) = 42',`callCC (\k -> 42 * k 17) = 17'
06:48:01 <ski_> (maybe i ought to mention that `callCC' is not a pure funtion ..)
06:48:46 <ski_> (PeakerWork : for `callCC' i don't think that's possible, since the result isn't known to be of function type)
06:49:37 <PeakerWork> well, I don't use ContT myself, I don't remember what callCC here would be doing
06:50:15 <titto> hi, I need to convert a lazy bytestring to a strict one, is B.pack . L.unpack the only way of doing it? it does not seem very efficient. Or maybe there is some "fusion" magic that makes the intermediate list disappear?
06:50:30 <ski_> rog_ : were you thinking of the two `interacts' operating on the *same* input and output ? .. or on subsequent ditto ?
06:51:19 <ski_> PeakerWork : here it would capture the current continuation (the return spot of the function call), and offer the body to possibly shortcut return to that spot, if it feels like
06:51:20 <rog_> ski_: yes, the same input and output. same as if you ran the same main twice in succession.
06:51:34 <ski_> rog_ : ok, subsequent ditto, then
06:51:45 <rog_> ski_: ditto?
06:52:13 <ski_> "That which was stated before, the aforesaid, the above, the same."
06:52:32 <ski_> (here "input and output")
06:52:40 <rog_> ski_: ok, sure. i thought you were talking about some haskell function!
06:52:50 <ski_> that's an idea ..
06:53:05 <ski_> we could rename `it' to `ditto'
06:53:30 <Twey> But then you can't say 5 * it
06:53:35 <Twey> :)
06:54:02 <ski_> @let it = ditto
06:54:03 <lambdabot>  <local>:18:5: Not in scope: `ditto'
06:54:36 <Badger> dittodittodittodittoditto
06:54:39 <quicksilver> titto: fromChunks
06:55:01 <quicksilver> hmm, is that what I meant?
06:55:05 <rog_> while we're on ghci stuff, is there a way to arrange things such that :load doesn't do anything if it fails?
06:55:05 <ski_> PeakerWork : anyway, don't bother about the `callCC' thing if you don't feel like .. it's evil anyway
06:55:17 <quicksilver> rog_: no. extremely annoying, isn't it?
06:55:25 <rog_> quicksilver: yes!
06:55:32 <ski_> > fix $ \it -> concat ["d",it,"to"]
06:55:34 <lambdabot>   "dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd...
06:55:40 <rog_> quicksilver: it really should be a no-op
06:55:53 <Badger> @src fix
06:55:53 <lambdabot> fix f = let x = f x in x
06:56:12 <PeakerWork> ski_: Except for proving the power of the monadic approach, I am not sure what ContT is useful for ;)
06:56:15 <ski_> fix f = x  where  x = f x  -- alternative style
06:56:24 <rog_> quicksilver: currently, i just have two instances of ghci running, one with the last "working" instance loaded, and the other for attempting loads. but this is cumbersome.
06:56:53 <quicksilver> titto: toChunks converts lazy to list of strict
06:56:56 <ski_> PeakerWork : i've used it for making coroutines .. also it can be useful to make certain monadic operations more efficient
06:57:08 <quicksilver> titto: then you can concat it
06:57:30 <ski_> (.. and for writing sudoku solutions using composable continuations)
06:58:48 <PeakerWork> ski_: more efficient? how so? why not just represent the continuation as a normal function?
06:59:07 <ski_> the continuation in `ContT' *is* a normal function
06:59:21 <ski_> (it's just hidden)
06:59:26 <quicksilver> rog_: yeah. I've been tempted to do that on occasion.
06:59:33 <quicksilver> rog_: file a bug against ghc. I'll vote for it.
07:00:13 <jedbrown> Is anyone else concerned that sizeOf (1 :: CLDouble) is 8?
07:02:20 <rog_> quicksilver: from 6.8.3 source:
07:02:22 <rog_>   -- NOTE: we used to do the dependency anal first, so that if it
07:02:23 <rog_>   -- fails we didn't throw away the current set of modules.  This would
07:02:23 <rog_>   -- require some re-working of the GHC interface, so we'll leave it
07:02:23 <rog_>   -- as a ToDo for now.
07:02:33 <ski_> PeakerWork : consider `(..((Nothing >>= f) >>= g)..) >>= k' .. what will happen (barring some cunning deforestation) ?
07:02:33 <rog_> so i guess it's already on the list
07:03:54 <titto> quicksilver: then a lazy list is just a 'concatenation' of strict ones?
07:04:42 <quicksilver> titto: a lazy bytestring is, pretty much, a lazy list of strict bytestrings.
07:05:35 <titto> I see, so fromChunks does not need to perform any conversion and will be more efficient.
07:05:38 <quicksilver> jedbrown: IEEE doubles are 8-byte, is that surprising?
07:05:49 <quicksilver> titto: yeah. Well it just has to convert the 'spine'
07:05:53 <quicksilver> but that's relatively cheap.
07:05:55 <jedbrown> quicksilver: long double
07:06:13 <Axman6> long double?
07:06:21 <Badger> long double is long.
07:06:59 <jedbrown> They are 16 bytes on i386 and x86_64.  Though all those extra bits may not be meaningful, depending on the implementation.
07:07:24 <quicksilver> jedbrown: *blush* I thought that L was a typo.
07:07:33 <quicksilver> I didn't even know we had a "CLDouble" type.
07:08:37 <jedbrown> No worries.  Clearly they have never been used.  I'll file a bug report.
07:09:22 <quicksilver> jedbrown: that only means the storable instance is broken, which doesn't necessarily mean the FFI bindings are broken.
07:09:26 <quicksilver> although it might.
07:11:02 <hackage> Uploaded to hackage: fft 0.1.2
07:11:02 <hackage> Uploaded to hackage: carray 0.1.3
07:11:02 <hackage> Uploaded to hackage: haskell-src-exts 0.4.3
07:11:02 <hackage> Uploaded to hackage: hsx 0.4.6
07:11:15 <Badger> hmmm, new exts
07:12:18 <PeakerWork> ski_: assuming some smart compiler optimizations or not? :)
07:12:45 <ski_> PeakerWork : assuming not (which was what i intended by "barring some cunning deforestation")
07:12:48 <PeakerWork> ski_: it might have to go through some vtable calling to propagate each Nothing
07:13:23 <ski_> (you can here ignore that `(>>=)' is overloaded over `Monad' .. it's not relevant)
07:15:04 <Axman6> where do you look to see the size of types on your machine? i remember there was a standard header file somewhere
07:16:03 <C-Keen> Axman6: /usr/include/sys/types.h on my system
07:16:13 <Axman6> types.h, that;'s the one
07:17:24 <Axman6> heh, wow, the one of OS X still has a NeXT copyright in it
07:17:38 <PeakerWork> wouldn't it be nice if a   newtype Blah = Bleh Blut     existed,  that if the expected type is Blah, and what you have is Blut, it would automatically pack it, and vice versa?
07:18:01 <Deewiant> also called 'type'
07:18:17 <PeakerWork> Deewiant: but I want different instances
07:18:25 <Deewiant> and how would it know which one to use
07:18:34 <PeakerWork> Deewiant: it knows the right type
07:18:59 <PeakerWork> Deewiant: it just has the wrong value for that type
07:19:26 <PeakerWork> Deewiant: instead of spitting out "Expected type Blah, inferred Blut", it would convert that silently
07:20:02 <Deewiant> hmm... I'm sure that breaks somehow unexpectedly in some case, I just can't think of one now :-)
07:20:11 <dejones> Is there a way to do type casting like in C but in Haskell?
07:20:18 <profmakx> O.o
07:20:31 <ski_> @type cast
07:20:32 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
07:20:37 <ski_> that one ?
07:21:02 <dejones> ski_: I think that will do it, thanks.
07:21:03 <dejones> :)
07:21:05 <Axman6> dejones: our lecturer yelled at us when we asked that
07:21:25 <dan_> @hoogle parsec
07:21:26 <lambdabot> package parsec
07:21:26 <lambdabot> module Text.Parsec
07:21:26 <lambdabot> module Text.ParserCombinators.Parsec
07:21:34 <ski_> (dejones : note that you'll get `Nothing' whenever the actual types `a' and `b' are not the same)
07:22:01 <dejones> ski_, Axman6: Well, I need it for reading a binary file.  I gotta read a bunch of Word8's then combine them as a String.
07:22:14 <ski_> dejones : also .. depending on the task, there might well be a better way to do it
07:22:18 <profmakx> @src cast
07:22:18 <lambdabot> Source not found. Take a stress pill and think things over.
07:22:23 <dejones> ski_: any suggestion?
07:22:27 <Axman6> dejones: there are better ways to do it, i'm sure
07:22:36 <dejones> Axman6: Probably so.  :)
07:22:43 <dejones> I just don't know how, heh.
07:22:46 <Axman6> like, (chr.fromIntegral)
07:22:56 <Axman6> :t chr
07:22:57 <lambdabot> Int -> Char
07:23:07 <Axman6> :t (chr.fromIntegral)
07:23:07 <lambdabot> forall a. (Integral a) => a -> Char
07:23:14 <ski_> dejones : you need to decide on some way to interpret the raw data in the `[Word8]' as `[Char]' .. i.e. choose an encoding to use
07:23:15 <dejones> Axman6: Oh.  :)
07:23:21 <Axman6> > (chr.fromIntegral) (63 :: Word8)
07:23:22 <lambdabot>   '?'
07:23:45 <RayNbow> http://changelog.complete.org/archives/814-real-world-haskell-update : "but we’re estimating arrival in bookstores the week of December 8" <-- hmm, that's not in time for Sinterklaas (= Dutch holiday, http://en.wikipedia.org/wiki/Sinterklaas ) :p
07:23:46 <Axman6> whoot!
07:23:47 <lambdabot> Title: Real World Haskell Update | The Changelog, http://tinyurl.com/55nk9d
07:23:47 * Axman6 wins
07:23:55 <dejones> Axman6: Thanks!
07:23:57 <Deewiant> > Data.ByteString.Internal.w2c 63
07:23:58 <lambdabot>   /tmp/4649449205450407252:70:44:
07:23:58 <lambdabot>      Not in scope: `Data.ByteString.Interna...
07:24:08 <PeakerWork> Deewiant: maybe it can replace the data constructor of newtypes in general, just use explicit type specifications to convert
07:24:22 <Axman6> > BS.w2c 63
07:24:23 <lambdabot>       Failed to load interface for `BS':
07:24:23 <lambdabot>        Use -v to see a list of the f...
07:24:25 <dejones> ski_: I have a length and I need to read the binary file by Word8 length number of times.
07:24:38 <ski_> > (chr . fromIntegral) (2^100)
07:24:39 <lambdabot>   '\NUL'
07:24:45 <dejones> lol
07:24:59 <Axman6> > maxBound :: Char
07:25:01 <lambdabot>   '\1114111'
07:26:12 <dejones> ski_, Axman6: Ooops.. I messed up.  I can read the data as Char, haha.
07:26:20 <dejones> instead of Word8
07:26:21 <dejones> :)
07:26:28 <Axman6> yup
07:27:09 <ski_> RayNbow : <http://clean.cs.ru.nl/About_Clean/Platform_Games/body_platform_games.htm> Sinterklaas
07:27:14 <lambdabot> http://clean.cs.ru.nl/About_Clean/Platform_Games/body_platform_games.htm>
07:29:55 <RayNbow> ski_: O_O
07:30:06 <ski_> (all purely functional)
07:31:42 <PeakerWork> So, does anyone remember why "newtype" needs a data-constructor, rather than doing automatic conversions based on type specifications only?
07:32:50 <ski_> how to make an abstract type otherwise ?
07:33:00 <ski_> (not using `data')
07:33:30 <PeakerWork> ski_: newtype would have type-like syntax, but would not inherit the instances
07:34:12 <PeakerWork> it would apply normal type inference, and use the type it inferred, and when you wanted to use the newtype instead, you'd explicitly convert the type
07:34:26 <ski_> (also see <http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html>)
07:34:26 <lambdabot> http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html>
07:35:01 <Twey> ski_: Eww
07:35:25 <Twey> WRT a game engine built into Object I/O
07:35:38 * Badger Hugs Twey 
07:36:16 * Twey waves at baaba.
07:36:18 <Twey> Badger, even.
07:36:45 <earthy> oh, yeah, that game engine is a few years old already
07:36:56 <earthy> cool master's thesis, that
07:37:04 <ski_> PeakerWork : the constructor and deconstructor is how you explicitly convert the type
07:37:10 <ski_> (Twey : why ?)
07:37:12 <Twey> And it's Windows-only, too
07:37:22 <earthy> Twey: based on DirectX
07:37:51 <Twey> ski_: Feature creep much?
07:37:51 <PeakerWork> ski_: why not convert the type with :: ? that way if the inference does it for me I don't have to do it
07:37:59 <Twey> It should be in a separate library
07:38:16 <PeakerWork> ski_: for example:   newtype MyFunc a b = (a->b)          ;       instance Functor MyFunc where fmap = (.)        -- no need to wrap/unwrap
07:39:05 <ski_> PeakerWork : consider `foo :: [String] -> [FoldedCaseOrderedString]; foo = map (map barf . sort . map gulp)'
07:39:29 <ski_> Twey : ok
07:40:42 <ski_> (PeakerWork : i.e., over which variant of the string type should the sorting be done ?)
07:40:57 <PeakerWork> ski_: what's the type of gulp?
07:41:06 <PeakerWork> oh wait that's not relevant ;)
07:41:59 <ski_> probably it would be better to replace `map gulp' with `gulp_' of type `String -> String' and mutatis mutandis for `barf'
07:42:25 <PeakerWork> ski_: well, what type would it infer for the result if you didn't specify FoldedCaseOrderedString?
07:42:58 <ski_> probably `[FoldedCaseOrderedString]' since `barf_ :: FoldedCaseOrderedString -> FoldedCaseOrderedString'
07:47:59 <PeakerWork> ski_: well, I guess it should yell that it is ambiguous then
07:48:51 <ski_> *nod*
07:49:27 <ski_> (i'm not saying your idea wouldn't work, btw .. but it would need some elaboration)
07:50:03 <Saizan> it looks a bit fragile
07:50:50 <ski_> (obviously i'm not saying your idea would work, either ..)
08:05:00 <Axman6> > read "0x7fc00000" :: Integer
08:05:01 <lambdabot>   2143289344
08:05:27 <Axman6> > showIntAtBase 2 (head.show) 2143289344
08:05:28 <lambdabot>       Overlapping instances for Show (String -> String)
08:05:28 <lambdabot>        arising from a...
08:05:39 <Axman6> :t showIntAtBase
08:05:40 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
08:06:01 <Axman6> > showIntAtBase 2 (head.show) (2143289344 :: Integer)
08:06:02 <lambdabot>       Overlapping instances for Show (String -> String)
08:06:02 <lambdabot>        arising from a...
08:06:11 <Axman6> > showIntAtBase 2 (head.show) (2143289344 :: Integer) ""
08:06:12 <lambdabot>   "1111111110000000000000000000000"
08:06:33 <Axman6> i should make that a function somewhere
08:06:42 <Axman6> @hoogle hex
08:06:42 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
08:06:42 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
08:06:42 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
08:06:49 <Axman6> @hoogle hex2
08:06:50 <lambdabot> No results found
08:06:50 <Lemmih> > showIntAtBase 2 (intToDigit) 1023432 ""
08:06:51 <lambdabot>   "11111001110111001000"
08:07:14 <Axman6> > showIntAtBase 2 (head.show) (2143289344 :: Integer) "b"
08:07:15 <lambdabot>   "1111111110000000000000000000000b"
08:07:27 <ski_> @let shows2String = ($ "")
08:07:29 <lambdabot>  Defined.
08:07:35 <nominolo|msr> @seen swiert
08:07:35 <lambdabot> I saw swiert leaving #haskell 52m 10s ago, and .
08:08:25 <conal> PeakerWork: ping
08:08:32 <Axman6> > 0x7fc00000 :: Integer
08:08:33 <lambdabot>   2143289344
08:08:38 <Axman6> handeh
08:08:47 <PeakerWork> conal: hey
08:09:05 <conal> PeakerWork: just saw your earlier remarks about unamb not compiling.
08:09:20 <PeakerWork> conal: I added a >=4 to the base in the .cabal file
08:09:23 <PeakerWork> conal: and it worked then
08:09:49 <conal> PeakerWork: thanks a bunch.  i'll release a new version with that fix.  i just changed the implementation to use that BlockedOnDeadMVar exception.
08:10:06 <conal> didn't realize it depended on base >= 4.
08:11:51 <PeakerWork> conal: sure
08:12:38 <conal> i guess i made unamb less old-compiler-friendly without realizing it.  oh well.
08:15:01 <conal> did base 4 start with ghc 6.10?
08:15:07 <byorgey> making things less old-compiler-friendly without realizing it is a really easy thing to do, unless you have automated tests set up to compile things with older compilers.
08:15:11 <byorgey> conal: yup
08:15:18 <conal> byorgey: thx
08:17:21 <leimy> Ok, monad transformers are pretty sweet.
08:17:27 <leimy> I think I'm finally getting the hang of these things
08:18:03 <leimy> dons IRC bot example is pretty good for beginners to get the hang of this stuff I think.
08:18:23 <leimy> In All About Monads, the firewall thing is a little complicated for people to want to read through.
08:18:25 <leimy> I think.
08:20:06 <geezusfreeek_> ski_: sorry i left so abruptly last night. my power went out, so i just went to bed
08:21:52 <PeakerWork> leimy: I think they're pretty clumsy to declare, but reasonable to use :)
08:22:02 <leimy> Hmm?
08:22:13 <leimy> well yeah.
08:22:24 <ski_> geezusfreeek_ : np
08:22:26 <leimy> I mean I started writing my own monad to combine a couple of ideas togeter
08:22:34 <leimy> then I realized I could just use StateT
08:22:39 <leimy> and life got easier :-)
08:22:45 <PeakerWork> leimy: I define something like:  type BlahT m a = ReaderT (StateT m) a ; and then I define lifters for each level
08:23:02 <leimy> oh see in my case I knew I wanted IO
08:23:32 <leimy> so I had: type Blah a = StateT StateType IO a
08:23:49 <leimy> and it's working nicely
08:24:27 <leimy> I now wonder if I wanted to add logging behaviors via Writer, how would I do that after I'm done writing the code without re-writing stuff, or making my own Monad.
08:25:07 <leimy> can I chain Monad Transformers?
08:25:13 <leimy> like change it from IO to WriterT IO?
08:25:20 <Saizan> yeah.
08:25:29 <ski_>   type Blah a = StateT StateType (WriterT Barfage IO) a
08:25:41 <leimy> but now does liftIO work still
08:25:46 <leimy> or do I have to lift and lift again?
08:25:52 <ski_> you don't
08:26:15 <Saizan> liftIO will work because of the MonadIO instances
08:26:21 <leimy> Oh right!
08:26:27 <leimy> WriterT can be liftIO'd too
08:26:32 <leimy> so it should be alright
08:26:44 <leimy> cool
08:26:44 <ski_> but it might be better to not use `set',`get',`tell',`censor',et.c. directly .. instead abstracting them into wrappers in terms of your domain
08:26:54 <leimy> yeah
08:27:23 <leimy> I can see where that'd be clearer
08:27:56 <saml> http://etherpad.com/1T45PxjLVg come here. let me teach you programming
08:28:29 <dan_> hey channel
08:28:37 <papermachine> > atan 1.0 1.0
08:28:37 <dan_> are there good docs for parsec yet?
08:28:38 <lambdabot>       No instance for (Floating (t -> a))
08:28:38 <lambdabot>        arising from a use of `atan'...
08:28:43 <ski_> (also, if you'd ever want to have things like `StateT s0 (BorkT (StateT s1 Meep)) a', you can't use `set',`get' anyway
08:28:46 <ski_> )
08:28:49 <papermachine> :t atan
08:28:51 <dan_> like, parser newbs
08:28:56 <dan_> for like
08:28:57 <dan_> etc
08:28:58 <lambdabot> forall a. (Floating a) => a -> a
08:29:11 <papermachine> > atan2 1.0 0.0
08:29:12 <lambdabot>   1.5707963267948966
08:30:02 <dmwit__> dan_: I always found the Parsec docs quite readable; do you have any specific questions?
08:32:30 * Botje wants a BorkT
08:33:13 <ski_> BorkT (BorkT (BorkT (ChefT (SwedishT Alt)))) a
08:33:27 * vixey snickers
08:33:40 * Botje meeps
08:33:40 <ski_> (hm, maybe we need monad transformer transformers .. ?)
08:33:44 <dan_> dmwit__, yes i want to learn how to write parsers :)
08:33:48 <PeakerWork> leimy: if you leave the "m" parameterized instead of "IO" then you can compose your transformer with WriterT for logging later
08:33:53 <PeakerWork> leimy: and have it remain modular
08:34:03 <ski_> (.. `ThriceTT BorkT ...', i.e.)
08:34:03 <leimy> True
08:34:15 <dan_> dmwit__, i have a project i cobbled together to parse expressions into my data type, but i want to refine it
08:34:17 <leimy> I should consider that.
08:34:25 <dan_> and i don't really have an understanding of what parsec is doing
08:35:02 <leimy> PeakerWork: however does that really buy me much?  I mean, it's a type synonym that I'd change vs every function signature?
08:35:20 <PeakerWork> @type second
08:35:21 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
08:35:49 <ski_> (leimy : it might be safer to use a `newtype' ..)
08:35:50 <PeakerWork> @type fmap :: (a -> b) -> (k, a) -> (k, b)
08:35:51 <lambdabot> forall a b k. (a -> b) -> (k, a) -> (k, b)
08:36:10 <PeakerWork> @type second :: (a -> b) -> (k, a) -> (k, b)
08:36:14 <lambdabot> forall a b k. (a -> b) -> (k, a) -> (k, b)
08:36:21 <ski_> @type [second,fmap]
08:36:22 <lambdabot> forall b c d. [(b -> c) -> (d, b) -> (d, c)]
08:36:46 <PeakerWork> is there a strictness difference between fmap and second?
08:36:50 <dmwit__> dan_: Well, are you hip to the Monad jive?
08:37:03 <ski_> PeakerWork : there oughtn't be
08:37:15 <PeakerWork> http://netsuperbrain.com/blog/posts/analysis-of-lazy-stream-programs/ claims there is
08:37:18 <lambdabot> Title: Less Sugar/More Meat » Blog Archive » Analysis of lazy-stream programs., http://tinyurl.com/5j5y3a
08:37:51 <ski_> > (id `fmap` undefined :: ((),())) `seq` ()
08:37:53 <lambdabot>   * Exception: Prelude.undefined
08:37:53 <ski_> > (id `second` undefined :: ((),())) `seq` ()
08:37:54 <lambdabot>   ()
08:38:33 <ski_> PeakerWork : but apparently there is .. someone didn't use lazy patterns when writing `instance Functor ((,) a)'
08:38:41 <dan_> dmwit__, mostly
08:38:41 <ski_> @src (,) fmap
08:38:42 <lambdabot> fmap f (x,y) = (x, f y)
08:38:48 <dan_> dmwit__, somewhat
08:38:51 <dan_> dmwit__, sort of.......
08:38:52 <ski_> @src (->) second
08:38:53 <lambdabot> second f = id *** f
08:38:55 <dan_> :)
08:38:59 <ski_> @src (->) (**)
08:39:00 <lambdabot> Source not found. Where did you learn to type?
08:39:00 <ski_> @src (->) (***)
08:39:01 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
08:39:13 <dan_> i learned to type in 8th grade :<
08:39:44 <ski_> (lambdabot : fyi, at home)
08:39:48 <dmwit__> dan_: =D
08:40:11 <dmwit__> dan_: Well, so Parsec is a monad for which the side effect of (>>=) involves parsing a bit of an input stream.
08:40:24 <dan_> right sure
08:40:42 <dmwit> dan_: So, "char 'a'", for example, is a parser which consumes an 'a' from your input stream and just returns it.
08:41:01 <dmwit> dan_: The other interesting primitive is (<|>).
08:41:18 * ski_ ponders
08:41:30 <dan_> thats the OR for parsers right?
08:41:46 <PeakerWork> ski_: Yeah, so it ought to be an irrefutable pattern, I guess
08:41:49 <dmwit> dan: What this one does is it tries its first argument; if the stream's first character doesn't match any of the things that the first argument can start a parse with, it uses the second parser.
08:41:54 <PeakerWork> ski_: in the Functor
08:41:59 <ski_> PeakerWork : that's what i'm pondering now
08:41:59 <dmwit> dan_: So, yeah, an OR parser combinator.
08:42:12 <dmwit> dan_: From those and return, you can get quite sophisticated things.
08:42:13 <ski_> PeakerWork : we'd like `fmap id = id' to hold .. does it ?
08:42:17 <dan_> you can chain them together yes?
08:42:26 <dmwit> dan: Yup, so for example:
08:43:04 <dmwit> (char 'a' >> return 32) <|> (char 'b' >> return 66) <|> (char '/' >> return 9001)
08:43:10 <ski_> PeakerWork : afaics, if we strictly insist on `fmap id = id' even on partial elements, then that `fmap' is right (and the proposed variant wrong)
08:43:21 <ski_> (otherwise it doesn't matter)
08:43:43 <dan_> hmm
08:43:49 <dmwit> dan_: This parser can accept the language {"a", "b", "/"} and spits out the language {32,66,9001}.
08:43:53 <dan_> and if nothing parses, it throws an error?
08:43:57 <PeakerWork> ski_: why does making fmap lazy on the tuple if the function doesn't use it make fmap id not id?
08:44:03 <dan_> right sure
08:44:10 <dmwit> dan_: Exactly.
08:44:48 <dan_> hmm
08:44:48 <dan_> well
08:44:59 <dan_> i think i've just found a shortcut around my problem
08:45:09 <dan_> i've got this theorem prover i'm trying to polish
08:45:14 * ski_ tries to recall the `Arrow' laws for `second' and `(***)'
08:45:32 <dan_> and to represent T or F i was just using T or F
08:45:46 <dan_> problem is, i use literal upper case characters for ground types in my expression
08:45:55 <dan_> so it's really not different than P Q R S etc
08:46:04 <dan_> i wanted to add TRUE and FALSE to my grammar
08:46:31 <dan_> but i was at a loss on how to parse "TRUEvP" as opposed to "TvP"
08:46:54 <ski_> PeakerWork : from `fmap id = id' we derive `fmap id undefined = id undefined = undefined', so `seq (fmap id undefined) () = seq undefined () = undefined'
08:46:58 <PeakerWork> TvP = Terran vs Protosss
08:47:07 <dmwit> dan_: char 'T' >> (string "RUE" <|> empty)
08:47:20 <dmwit> dan_: But you should really use a tokenizer instead, it will help immensely with this kind of thing.
08:47:41 <dmwit> dan_: This sort of maximal-munch rule is well understood in that domain.
08:48:24 <ski_> PeakerWork : using the alternative implementation `fmap f ~(x,y) = (x,f y)' we get `seq (fmap id undefined) () = seq (fst undefined,id (snd undefined)) () = seq (undefined,undefined) () = ()'
08:48:57 <dan_> you mean distinguishing between TRUE and the letters T R U E?
08:49:11 <PeakerWork> ski_: ah. Strictness considerations make me sad :)
08:49:20 <PeakerWork> ski_: its so nuanced
08:49:30 <ski_> PeakerWork : of course, it may be that we can blame `seq' for this :)
08:50:08 <vixey> me too
08:50:16 <ski_> (ceterum autem censeo, `seq'inem esse delendam)
08:52:21 <ski_> (PeakerWork : alternatively, we could say that the laws should hold for total elements, but not necessarily always for partial ones)
08:52:21 <vixey> @let ignore = flip const
08:52:22 <lambdabot>  Defined.
08:52:54 <ski_> (the `Nontermination' monad is the sole side-effect in haskell)
08:54:01 <vixey> so, I have this newtype Scope t = Scope t
08:54:08 <vixey> just.. stole the idea from a paper I read
08:54:22 <PeakerWork> ski_: yeah, this only refines so it should be ok?
08:54:23 <vixey> sometimes I have a function of :: T -> T
08:54:33 <PeakerWork> ski_: It only makes some undefineds defined, that direction is fine, isn't it?
08:54:39 <vixey> how would you given turn (T -> T) -> (Scope T -> Scope T)?
08:54:55 <vixey> should I make it a Functor?
08:55:11 <Saizan> why not?
08:55:31 <ski_> PeakerWork : depends .. in some reasoning that is bad too, since it may mean that a "working" program on some implementation (& some optimizations enabled), might not terminate for another combination thereof
08:57:22 <PeakerWork> ski_: this case is not based on optimizations though, but use of a less strict (fmap id) rather than id
08:57:39 <vixey> what about (T -> m T) -> (Scope T -> m (Scope T))?
08:58:15 <Saizan> Traversable
08:58:49 <ski_> a puzzle : consider `factiorial = fix $ \fact n -> if n == 0 then 1 else n * fact (n-1)' .. can you write a variant of `fix' that will produce a `Tree (a,b)' of input- (`a') output- (`b') pairs of the recursive calls ?
08:59:35 <skorpan> sorry, i don't do fixed-point combinators
09:00:05 <ski_> (and if not, can you make a "small, nice" change to the `\fact n -> ...' to make this work ?)
09:00:31 <ski_> (btw, i tentatively dubbed this "poor man's debug")
09:02:10 <ski_> vixey : `forall k a. k a -> k (Scope a)' might be useful, in one approach
09:02:30 <PeakerWork> ski_: oh but if (fmap id /= id) because it is less strict, then you cannot rewrite (fmap id) to id
09:02:39 <PeakerWork> ski_: which disallows optimizations :-(
09:03:12 <ski_> (for reference : `data Tree a = Leaf | Node a (Forest a); type Forest a = [Tree a]' ignoring some record labels)
09:03:33 <ski_> PeakerWork : aye
09:04:59 <PeakerWork> ski_: we need to get rid of turing completeness :(
09:05:19 <ski_> (or maybe just `seq' ..)
09:05:39 <PeakerWork> is there a difference between seq a b        and case a of _ -> b ?
09:05:41 <ski_> (hm .. no, i don't think that would be enough for your situation there)
09:05:49 <dmwit> PeakerWork: Yes.
09:05:57 <dmwit> PeakerWork: The first evaluates a one step before returning b.
09:05:59 <vixey> you want strong normalization?
09:06:02 <dmwit> PeakerWork: The second does not.
09:06:11 <PeakerWork> dmwit: oh right, now I remember
09:06:20 <PeakerWork> to implement seq with case, I have to know which data constructor I'd use
09:06:25 <PeakerWork> and unpack that
09:06:46 <PeakerWork> and if its a function I can probably not do it at all
09:07:10 <ski_> function types are not `data' types
09:07:21 * Saizan patterns matches on \x.
09:07:23 <vixey> ski_, blasphemy!
09:07:45 <ski_> vixey : well, if i say they're roughly `codata' ?
09:08:10 <ski_> Saizan : nice :) (but it's still not a constructor)
09:08:14 <ski_> (where, btw ?)
09:09:12 <vixey> aha........
09:10:25 <Saizan> ski_: i'm just reading a paper on higher-order unification :)
09:10:29 <ski_> (Saizan : or did you not mean what PeakerWork mentioned a bit earlier ?)
09:10:38 <ski_> ah, ok
09:10:59 <ski_> (not the same, but cool too)
09:11:03 <hackage> Uploaded to hackage: unamb 0.1.1
09:12:58 <Saizan> i've seen (->) only given or defined with \Pi
09:14:06 <Saizan> but you should be able to define it more concretely?
09:15:29 <ski_> <ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/examples/prelude/exp.ch> defines `exp' as a `codata'
09:18:45 <ski_> compare with <ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/examples/misc/proc.ch> which roughly corresponds to `newtype Proc a b = P (a -> (b,Proc a b))' in haskell
09:19:46 <ski_> the latter can also be compared to `data Proc a b = forall x. P x ((x,a) -> (x,b))' ..
09:20:27 <ski_> .. which leads one to compare the former with `data Exp a b = forall x. E x ((x,a) -> b)'
09:20:42 <Saizan> what's the difference between (->) and (=>)?
09:21:00 <Riastradh> A world.
09:21:20 <ski_> (.. or maybe something more like `data a -> b = forall x. Closure x ((x,a) #-> b)' where `(#->)' would be a type constructor of "global" functions)
09:21:34 <leimy> Riastradh: howdy
09:21:39 <leimy> Riastradh: long time no see :-)
09:22:12 <ski_> Saizan : `=>' is used in Charity to construct exponential-like type
09:22:32 <Riastradh> Hi.  I'm about to vanish.
09:22:41 <Riastradh> *poof*
09:22:41 <leimy> Riastradh: ah well...
09:23:00 <Riastradh> (Apologies for the interjection; I really ought to stop doing that.)
09:24:10 <ski_> in `data C -> proc(A, B) = pr: C -> A => B * C', this means that `pr' is a projection (deconstruction) morphism of type `proc(A,B)  ->  A => B * proc(A,B)' which in practice means that you'll basically get a morphism `A * proc(A,B)  ->  B * proc(A,B)'
09:25:24 <Saizan> ah, i see
09:26:55 <Saizan> and => acts like a lambda in values
09:27:58 <ski_> (`pr' is also used for constructing points in `proc(A,B)' .. you do that by constructing a morphism `A * C  -> B * C', i.e. here `C  ->  A => B * C', for any `C' you like, and applying `pr' on that, you get a point in `proc(A,B)')
09:29:01 <ski_> (s/applying `pr'/applying `pr =>'/)
09:29:05 <ski_> *nod*
09:29:55 <ski_> (just clarifying : `->' here is the morphism arrow)
09:30:40 * quicksilver repeats his campagin for colours in #haskell
09:30:52 <quicksilver> to distinguish ski_'s morphism arrow
09:31:19 <ski_> well, rather Charity's than mine, per se
09:31:49 <ski_> (i usually use `>->' or maybe `-->')
09:32:53 <ski_> @where charity
09:32:53 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
09:33:21 * Saizan one day will appreciate the difference between morphisms and exponential objects, too
09:33:54 <ski_> mayhaps the day you appreciate the difference between morphisms and coexponential objects ?
09:36:06 <vixey> * is for kinds
09:36:14 <vixey> what's a good ascii symbol for a diffrent kind
09:36:29 <ski_> which kind ?
09:37:01 <vixey> Propr
09:37:02 <vixey> Prop
09:37:06 <dmwit> [] can work
09:37:09 <dmwit> (for box)
09:37:28 <ski_> (wouldn't `* :: []', then ?)
09:38:53 <quicksilver> * is the kind of concrete types
09:39:02 <quicksilver> GHC uses # and ? for other kinds
09:39:09 <Deewiant> What's #?
09:39:15 <quicksilver> they're to do with boxing
09:39:17 <ski_> (.. and `??' and `(#)')
09:39:21 <Deewiant> ah, doh
09:39:27 <Deewiant> # is unboxed, ? is either
09:39:39 <ski_> @kind GHC.Base.Int#
09:39:40 <lambdabot> #
09:39:41 <Deewiant> For some reason I thought ? was unboxed and was confused about # :-)
09:39:43 <ski_> @kind (->)
09:39:44 <lambdabot> ?? -> ? -> *
09:39:45 <idnar> what the heck is ..?
09:40:06 <Deewiant> it's an ellipsis
09:40:17 <ski_> `?' is the lub of `#' and `*'
09:40:21 <idnar> oh
09:40:38 <idnar> it's missing a dot ;P
09:40:41 <ski_> er
09:40:48 <ski_> `?' is the lub of `??' and `*'
09:41:06 <ski_> hmhm
09:44:14 <vixey> omg Im so confused
09:44:38 <vixey> I tried to make this typechecker annotate the syntax with types instead of just returning a type
09:44:44 <vixey> *broke everything*=
09:44:56 <leimy> ™
09:45:18 <erikc> gg
09:46:13 <quicksilver> vixey: OMG I COMPLETE THE TYPE SYSTEM
09:46:19 <quicksilver> vixey: OMG I COMPLETELY THE TYPE SYSTEM
09:46:21 <quicksilver> rather.
09:46:30 <quicksilver> quicksilver-- # can't even meme without typos
09:46:31 <vixey> lol
09:48:30 <Cale> I ACCIDENTALLY THE WHOLE TYPE SYSTEM
09:49:24 <Saizan> strongly typed memes?
09:50:18 <ski_> just to make clear, i managed to confuse the subkinding above, and to avoid attempting to butcher up it again, i'll just refer to <http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/simplCore/SimplCore.lhs> which hopefully is still relevant
09:50:19 <lambdabot> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/simplCore/SimplCore.lhs>
09:51:35 <ski_> (also note that, iirc, there should also be a `!' kind in ghc ..)
09:53:14 <Saizan> there was a lattice of kinds on the trac wiki too
09:53:47 * vixey manages to sort of trick it into giving the right answers
09:53:54 <vixey> now I have no idea if it is actually working or not
09:56:27 <dons> ?users
09:56:27 <lambdabot> Maximum users seen in #haskell: 550, currently: 518 (94.2%), active: 19 (3.7%)
09:57:10 <mwc> anybody here who can admin darcs.haskell.org? It seems a permission problem keeps me from accessing http://darcs.haskell.org/ext-excep/*
09:57:28 <mwc> or just Examples.hs actually :(
09:58:55 <ski_> (`GHC.Base.MVar# :: * -> * -> !' in at least one version)
10:03:14 <ski_> (oh .. forgot to mention, search for e.g. `kind inference' to see the nice lattice in the above page)
10:04:00 <mux_> does bjorn bringert IRC here?
10:05:31 <ski_> sometimes
10:05:39 <Cale> Hmm, it seems like hsx would turn into a nice application of quasiquoting.
10:06:01 <mux_> I was willing to share my patches that make cgi & fastcgi build with GHC 6.10 and the new Control.Exception module
10:06:27 <vegai> they already build with base=3, though
10:06:33 <ski_> (last identified 10 days ago)
10:06:37 <vegai> mux_: that's great, though
10:06:37 <mux_> the new exception framework is great but it's terribly not backwards compatible
10:06:38 <Cale> bjorn@bringert.net
10:07:05 <Cale> (apparently)
10:07:17 <mux_> Cale: I was hoping to speak to him in order to decide how to best change the code - the way I did it for now would just break GHC < 6.10 :-)
10:07:28 <Cale> ah
10:08:10 <mux_> plus the changes require scoped type variables
10:08:20 <mux_> of course I could do without them, but it's a lot less convenient
10:11:03 <hackage> Uploaded to hackage: mediawiki 0.2.2
10:11:30 <Badger> o_O
10:11:34 <Badger> haskell mediawiki, eh
10:12:28 <yav> mux_: i think that it may be dons who is maintaining fast-cgi nowadays
10:12:37 * mux_ pokes dons 
10:12:52 <mux_> oh I'll have to go anyways, we'll see that another time
10:13:02 * mux_ unpokes dons 
10:13:13 <yav> ok, dons should be here shortly though, i'll let him know
10:13:19 <mux_> thank you!
10:18:00 <Surma1> hey guys. I have a list of a few thousand prime numbers. I don't want to pass that array through all my function calls, but I also don't want to recalculate the list everytime. is there such a think in haskell like a global static variable (I know, there aren't even variables, but you know what I mean)
10:18:27 <saml> Surma1: lists aren't arrays
10:18:48 <saml> let's say  i have primes = [all primes ]
10:18:48 <Surma1> sorry, meant to say list
10:19:10 <saml> then you write a function      f  (prime:rest_of_primes) = ...
10:19:33 <vixey> Surmal, yes just put primes = <calculate all primes>
10:19:40 <saml> Surma1: oh i see the problem
10:19:59 <Surma1> I don't know, how many primes I have, I just know, that throughout the program, that list won't change
10:20:09 <Saizan> ski_: is this a good solution to the puzzle?:) http://hpaste.org/12201
10:20:14 <Surma1> might be all primes to 1000, might be 10k
10:20:23 <saml> Surma1: i bet graph reduction will smartly not calculate same prime over and over again
10:20:28 <vixey> Surmal, the list can be infinite
10:20:41 <tromp> whats product of all primes under 256?
10:20:54 <mux_> make sure the list of primes is top-level and it should be fairly sure to assume it won't be recalculated
10:20:58 <saml> how do I generate a list of all primes?
10:21:15 <Surma1> @tromp: 780214019 ;)
10:21:15 <lambdabot> Unknown command, try @list
10:21:26 <Surma1> saml: I did it with the sieve of erastosthenes
10:21:35 <mux_> > product . takeWhile (<256) . nubBy (\x y -> gcd x y > 1) $ [1..]
10:21:36 <lambdabot>   642663309179086448723306352281067133108801865916092081142447586808981503678...
10:21:43 <tromp> that looks more like it
10:21:47 <saml> >  [2,3,5,7..]
10:21:47 <mux_> humpf
10:21:49 <lambdabot>   <no location info>: parse error on input `..'
10:21:54 <ddarius> [2..]
10:21:58 <saml> > [2,3,5,7,..]
10:21:59 <lambdabot>   <no location info>: parse error on input `..'
10:22:23 <Saizan> > 2:[3,5..]
10:22:23 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
10:22:40 <mux_> > nubBy (\x y -> gcd x y > 1) [2..]
10:22:41 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:22:47 <ski_> Saizan : that's starting to look like something .. however, now the `f' argument may perform effects .. stop that
10:22:53 <saml> haskell should be able to figure out common number sequences and provide the sequence for me
10:23:00 <mux_> it does :-)
10:23:06 <mux_> @oeis 2,3,5,7
10:23:10 <lambdabot>  The prime numbers.
10:23:10 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:23:18 <mux_> see Math.OEIS
10:23:19 <saml> > [2,3,5,7..] it should recognize that i meant the list of all primes
10:23:20 <lambdabot>   <no location info>: parse error on input `..'
10:23:28 <Surma1> so, uhm... what are you saying regarding my problem? whenever I call my function ,it recalculates everything
10:23:41 <mux_> saml: with that module, you could indeed write extendSequence [2,3,5,7,9] and get all primes
10:23:45 <vixey> > takeWhile (< 256) (extendSequence [2,3,5,7])
10:23:47 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:24:52 <saml> Surma1: i don't think you can prevent that. i might be wrong
10:25:08 <tromp> :t log
10:25:08 <lambdabot> forall a. (Floating a) => a -> a
10:25:09 <saml> different calls to your function will start everything over
10:25:18 <ski_> (Saizan : also, i absolve thee from using abominations like `instance (Num b,Monoid w) => Num (Writer w b)', you don't need that for qualifying)
10:25:23 * vegai blinks slowly at extendSequence
10:25:25 <vixey> Surmal, what
10:25:39 <tromp> let pr256= product $  takeWhile (< 256) (extendSequence [2,3,5,7])
10:25:47 <tromp> @let pr256= product $  takeWhile (< 256) (extendSequence [2,3,5,7])
10:25:48 <lambdabot>  Defined.
10:25:55 <tromp> > pr256
10:25:57 <lambdabot>   642663309179086448723306352281067133108801865916092081142447586808981503678...
10:26:08 <tromp> > log pr256 / log 2
10:26:09 <lambdabot>       No instance for (Floating Integer)
10:26:09 <lambdabot>        arising from a use of `log' a...
10:26:22 <vixey> @let -XNoMonomorphismRestriction
10:26:23 <lambdabot>   Parse error
10:26:27 <vixey> @set -XNoMonomorphismRestriction
10:26:28 <lambdabot>   Parse error
10:26:33 <mux_> > log (fromIntegral pr256) / log 2
10:26:35 <lambdabot>   334.8768725973697
10:27:45 <ski_> (Saizan : but nice thinking .. i hadn't thought of that)
10:28:54 <idnar> mux_: I would hope that extendSequence [2,3,5,7,9] wouldn't give you all primes
10:29:09 <idnar> :)
10:30:54 <yitz> > extendSequence [2,3,5,7,9]
10:30:55 <_pizza_> hopefully not with 9 in it
10:30:56 <lambdabot>   [2,3,5,7,9,12,15,18,22,26,30,35,40,45,51,57,63,70,77,84,92,100,108,117,126,...
10:31:10 <mux_> heh yeah :)
10:31:17 <idnar> @oeis 23579
10:31:18 <lambdabot>  Number of partitions of n with designated summands.
10:31:18 <lambdabot>  [1,1,3,5,10,15,28,41,69,102,160,231,352,498,732,1027,1470,2031,2856,3896,538...
10:31:19 <idnar> oops
10:31:27 <mux_> plus it would be a massive DDoS for OEIS if it was actually returning whole lists
10:31:27 <idnar> @oeis 2,3,5,7,9
10:31:28 <lambdabot>  Expansion of x/((1 - x)^2*(1 - x^3)).
10:31:28 <lambdabot>  [0,1,2,3,5,7,9,12,15,18,22,26,30,35,40,45,51,57,63,70,77,84,92,100,108,117,1...
10:31:45 <idnar> oh, naturally
10:32:51 <ski_> Saizan : what you say ?
10:32:55 <Saizan> ski_: fix' :: Num b => (forall m. (Monad m, Num (m b)) => (a -> m b) -> a -> m b) -> a -> Writer [Tree (a, b)] b ?
10:33:25 <yitz> does extendSequence have the whole database built in, or does it use the web site?
10:33:32 <Saizan> or we could inline the liftMn and drop the Num context
10:33:40 <ski_> Saizan : omitting the `Num (m b)' requirement, that's basically what i arrived at, yes :)
10:33:50 <ski_> (.. and the `Num b' one)
10:34:16 <Cale> @oeis 2,3,4,5,7,9
10:34:17 <lambdabot>  Padovan sequence: a(n) = a(n-2) + a(n-3).
10:34:17 <lambdabot>  [1,0,0,1,0,1,1,1,2,2,3,4,5,7,9,12,16,21,28,37,49,65,86,114,151,200,265,351,4...
10:34:34 <Cale> @oeis 2,3,4,5,7,9,11,13
10:34:35 <lambdabot>  Numbers of the form p^(2^k) where p is prime and k >= 0.
10:34:35 <lambdabot>  [2,3,4,5,7,9,11,13,16,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,...
10:34:49 <jedbrown> yitz: It's a pure function that uses the network
10:34:50 <ski_> so, like `traceFix $ \factM n -> if n == 0 then return 0 else liftM (n *) (factM (n-1))' ..
10:35:14 <yitz> urgh
10:35:22 <Cale> @oeis 2,3,4,5,7,8,9
10:35:23 <lambdabot>  Prime powers.
10:35:23 <lambdabot>  [1,2,3,4,5,7,8,9,11,13,16,17,19,23,25,27,29,31,32,37,41,43,47,49,53,59,61,64...
10:35:28 <EmielRegis> is there a way to apply map to second argument of function?
10:35:38 <ski_> Saizan : not too bad puzzle, aye ?
10:35:52 <Saizan> ski_: nice one indeed  :)
10:35:53 <EmielRegis> like, I got a function  foo :: a -> b -> c -> d
10:35:59 <EmielRegis> and i wanna do map on b only
10:36:08 <Cale> EmielRegis: map (flip foo) ?
10:36:27 <EmielRegis> flip?
10:36:29 <EmielRegis> @hoogle flip
10:36:30 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
10:36:30 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
10:36:30 <lambdabot> package Flippi
10:36:31 <Cale> :t flip
10:36:32 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
10:36:39 <EmielRegis> O_o
10:36:41 <ski_> (i didn't mention `Writer' in my type, instead returning a pair at top-level .. but that's just details)
10:36:42 <EmielRegis> nice shit
10:36:44 <EmielRegis> thanks
10:37:08 <yitz> Flipp1?
10:37:20 <EmielRegis> what about 4 argument functions?
10:37:21 <Saizan> (i'd often like a naked Writer monad)
10:37:29 <EmielRegis> specifically Map.insertWith
10:37:32 <Cale> EmielRegis: Use lambda.
10:37:44 <EmielRegis> map (insertWith (++) (\(a,b) -> a) (\(a,b) -> b) gridMap) keyValuePairs
10:37:50 <EmielRegis> that would work?
10:37:59 <ski_> (Saizan : should i annotate with my version ?)
10:38:14 <Cale> EmielRegis: uhh...
10:38:19 <Cale> no
10:38:21 <ski_> (Saizan : or maybe you'd like to give your refinement first ..)
10:38:22 <EmielRegis> lol
10:38:54 <EmielRegis> ah i know now
10:38:59 <erikc> heh, its a bummer that the tree version of real world haskell from amazon.ca is $15 cheaper than the digital version
10:39:02 <Cale> You want all the results of inserting each key/value pair separately into the map?
10:39:05 <Saizan> ski_: isn't it just runWriter at the end?
10:39:19 <EmielRegis> (\(a,b) -> insertWith (++) a b gridMap) right?
10:39:21 <yitz> EmielRegis: map (\(a, b) -> insertWith (++) a b gridMap) keyValuePairs
10:39:26 <EmielRegis> aight
10:39:36 <Cale> (Like the first result will be the gridMap with the first key/value pair added, and the second will be gridMap with the second one added (but not the first), and so on?
10:39:49 <EmielRegis> well no
10:39:49 <ski_> Saizan : yes .. i just meant for posterity
10:39:52 <EmielRegis> id like all of them added
10:40:00 <Cale> Oh, then you don't want map
10:40:17 <Cale> Remember that insertWith doesn't mutate the original map
10:40:19 <yitz> EmielRegis: but you probably want insertWith', otherwise you'd get a stack overflow if keyValuePairs is big
10:40:20 <Saizan> ski_: ah, yeah, go ahead :)
10:40:27 <EmielRegis> ah
10:40:41 <EmielRegis> i should recurse then and pass the new map?
10:40:45 <Cale> yitz: You wouldn't in this case, but possibly in his real case
10:40:48 <EmielRegis> or is there a function that mutates the original map?
10:40:51 <Cale> EmielRegis: You want a fold.
10:40:53 <ski_> (a moment, i don't have access to the original so i'll just reconstruct it)
10:41:07 <EmielRegis> ah
10:41:08 <EmielRegis> indeed I do
10:41:52 <Cale> EmielRegis: Specifically, you probably want something like foldl' (\m (x,y) -> insertWith (++) x y m) gridMap keyValuePairs
10:42:01 <yitz> Cale: ah, right. you only need it for the fold. Though it doesn't hurt to be in the habit.
10:42:12 <Cale> (or maybe insertWith')
10:43:20 <Cale> I'm not sure exactly how much benefit forcing each (++) by one step will be though.
10:43:38 <EmielRegis> well, I want to store a list of objects for each key
10:43:53 <Cale> Right, I got that from the type :)
10:44:02 <EmielRegis> :P
10:44:36 <FunctorSalad_> any way to put commutativity properties to use with rewrite {-# RULES #-}?
10:45:22 <FunctorSalad_> I'm also not sure which direction homomorphism properties should go (like fmap (a . b)  = fmap a . fmap b)
10:45:35 <Cale> FunctorSalad_: The other way, usually.
10:45:59 <vixey> why even have a rule for that?
10:46:05 <Cale> FunctorSalad_: (you want to avoid going over the structure multiple times)
10:46:09 <dons> http://www.reddit.com/r/programming/comments/7edzm/turbinado_an_easy_to_use_web_framework_written_in/
10:46:10 <FunctorSalad_> vixey: don't know, actually :)
10:46:11 <lambdabot> Title: Turbinado: an easy to use web framework written in Haskell : programming, http://tinyurl.com/5a2xdd
10:46:13 <dons> woo
10:46:18 <dons> double woo:
10:46:19 <dons> http://www.reddit.com/r/programming/comments/7ee84/real_world_haskell_why_online_book_development/
10:46:21 <lambdabot> Title: Real World Haskell: Why Online Book Development Works: 7,500 comments from 800 r ..., http://tinyurl.com/5sayal
10:46:43 <EmielRegis> dons, there doesn't seem to be anything here
10:47:26 <Cale> EmielRegis: hm?
10:47:30 <FunctorSalad_> Cale: with lists both ways seem to avoid intermediate lists, but I suppose your point holds for other structures
10:47:34 <dons> heh
10:47:39 <EmielRegis> it says its empty
10:47:43 <EmielRegis> (the link you supploed)
10:47:53 <Cale> FunctorSalad_: hm? map (f . g) xs avoids an intermediate list.
10:48:07 <FunctorSalad_> but map f . map g also, no?
10:48:11 <Cale> FunctorSalad_: No.
10:48:25 <Cale> FunctorSalad_: Though, laziness means that things can be GC'd quickly anyway.
10:48:29 <dons> EmielRegis: click on the title
10:48:48 <EmielRegis> ah ye
10:48:57 <FunctorSalad_> Cale: ah, ok. that's what I was thinking of. so the intermediate list is never actually materialised ;)
10:49:33 <Cale> FunctorSalad_: Well, provided that the garbage collector runs often enough. The cells get allocated though, which still costs time.
10:50:04 <FunctorSalad_> with commutativity we're out of luck I suppose? ;)
10:50:20 <Cale> In which case?
10:50:34 <FunctorSalad_> in this case it's natural transformations
10:50:35 <Cale> It's usually hard to decide which commutation is better.
10:50:53 <Cale> Though if one allows you to apply more RULES, that can be good.
10:51:03 <FunctorSalad_> I don't see how to make a useful rule out of the naturality square
10:51:37 <FunctorSalad_> (type inference actually makes that square look like: nat . fmap = fmap . nat :))
10:51:52 <FunctorSalad_> nat . fmap f = fmap f  . nat
10:52:35 <FunctorSalad_> where nat :: forall a. functor1 a -> functor2 a
10:52:35 <Cale> FunctorSalad_: right, one way isn't really preferable over the other usually.
10:52:42 <FunctorSalad_> yes
10:53:10 <Cale> Unless, for instance, you're following that operation with  fmap g
10:53:26 <Cale> In which case, you'd want to push the fmaps together and then fuse them
10:53:40 <Cale> But I don't think RULES are clever enough for that kind of trickery.
10:53:43 <FunctorSalad_> it would need a smarter rewriter that tries out all the permutations
10:54:37 <FunctorSalad_> but I guess that leads to undecidability quickly
10:54:52 <FunctorSalad_> (arbitrary simplicifcations)
10:55:10 <Cale> Well, and which simplifications are better than others is hard.
10:55:15 <FunctorSalad_> I mean, not for commutativity, but if you allowed other things backwards
10:55:18 <vixey> what's undecideable is if  (f . g) . h is better than f . (g . h)
10:55:38 <Cale> hmm
10:55:41 <vixey> or permutations or whatever
10:55:51 <Cale> I'm pretty sure that f . (g . h) is always better.
10:56:16 <FunctorSalad_> vixey: in that case you can try all the possibilities, no? I mean rules that make things longer would not work
10:56:36 <Cale> But yeah, is f . g better than g . f when they're equal? That's hard to tell.
10:56:41 <sbahra> Cale, makes sense that f . (g . h) is better.
10:56:41 <vixey> What I mean is if you check all possibilities you still don't know what is better
10:56:55 <FunctorSalad_> it is better if it allows further simplification
10:57:13 <FunctorSalad_> why is f . (g . h) better?
10:57:24 <Cale> (f . g) . h needs to evaluate both (.)'s before it can allow f to start working.
10:57:29 <Cale> f . (g . h) doesn't.
10:57:31 <lilac> Cale: consider "f", "g" and "h" to be matrix multiplication
10:57:43 <lilac> then the better one depends on the size of the matrices
10:58:03 <FunctorSalad_> Cale: ok, I was forgetting that the functions can be applied to sth ;)
10:58:13 <gwern> what about f . g . h $ ? How does that work?
10:58:26 <Cale> gwern: f . g . h = f . (g . h)
10:58:44 <FunctorSalad_> . is associative so it doesn't matter for the semantics
10:58:53 <FunctorSalad_> just for performance
10:58:54 <gwern> but isn't that as equivalent as (f . g) . h?
10:59:00 <FunctorSalad_> yes
10:59:07 <gwern> I don't really understand how the compiler could treat them different
10:59:12 <vixey> (f . g) . h = f . (g . h) is the reason we write f . g . h
10:59:13 <lilac> Cale: actually forget that, i can't think of an implementation where it makes a difference :)
10:59:22 <Cale> gwern: It's semantically equivalent, but performance wise it's slightly different.
10:59:47 <gwern> so the GHC Core will actually be different depending on how I place parens?
11:00:08 <Cale> So it goes:  (f . (g . h)) $ x -> (f . (g . h)) x -> f ((g . h) x)
11:00:25 <Cale> (at which point f is evaluated)
11:00:32 <Cale> Whereas...
11:01:03 <Cale> ((f . g) . h) $ x -> ((f . g) . h) x -> (f . g) (h x) -> f (g (h x))
11:01:10 <Cale> at which point f is evaluated
11:01:20 <Cale> Count the arrows ;)
11:01:45 <Cale> If, for whatever reason, f doesn't end up using its parameter, the first is better.
11:02:00 <lilac> surely the (.)s happen at compile time anyway?
11:02:03 <Cale> no.
11:02:09 <Cale> Well, maybe they could.
11:02:15 <Cale> (.) might be inlined.
11:02:32 <lilac> i'd find it slightly embarrassing for ghc if it wasn't.
11:02:46 <vixey> inline zipWith (.)
11:02:49 <Cale> I'm certain there are cases where you can't get any benefit from inlining it.
11:03:16 <lilac> vixey: sure, but that's not the case we're discussing.
11:05:19 <Cale> > foldr (.) id (map const [1..]) 0
11:05:21 <lambdabot>   1
11:05:24 <Cale> > foldl (.) id (map const [1..]) 0
11:05:41 <Cale> Of course, that's going to fail for another reason...
11:05:48 <Cale> > foldl (.) id (map const [1..10000]) 0
11:06:18 <Cale> But for example, that one is going to need to evaluate 10000 (.)'s before it can give a result
11:07:13 <Cale> (on top of the cost of foldling through the list)
11:07:25 <lambdabot>   thread killed
11:07:35 <lambdabot>   1
11:09:13 * FunctorSalad_ finally got type families ;)
11:10:10 <FunctorSalad_> the analogy (parametric polymorphism : ad-hoc polym.) (type constructor : type family) makes it pretty clear. maybe it should be on top
11:10:32 <FunctorSalad_> at first I thought "types indexed by types are just type constructors, no?"
11:11:12 <EmielRegis> are there bitwise operators in haskell?
11:11:16 <Saizan> well, values indexed by values are not just data-constructors
11:11:18 <Cale> Data.Bits
11:11:43 <Cale> FunctorSalad_: What do type families have to do with ad hoc polymorphism?
11:13:11 <FunctorSalad_> Cale: that all the parameter types are handled differently (via instance declarations), not uniformly
11:13:38 <FunctorSalad_> Saizan: then I probably didn't understand "indexed by"
11:13:41 <EmielRegis> danke
11:14:13 <Saizan> FunctorSalad_: or maybe i'm stretching it :)
11:15:00 <FunctorSalad_> "values indexed by values" would be functions for me ;)
11:16:26 <bd> Why would I get "Not in scope: 'digitToInt' " in gch 6.10?
11:16:35 <vixey> @hoogle digitToInt
11:16:35 <lambdabot> Data.Char digitToInt :: Char -> Int
11:16:43 <vixey> maybe you didn't import Data.Char
11:16:56 <bd> oh, i thought it was a prelude function
11:17:21 <bd> is it not?
11:17:56 <Saizan> :t Prelude.digitToInt
11:17:58 <lambdabot> Not in scope: `Prelude.digitToInt'
11:18:27 <Cale> FunctorSalad: hmm, I'm not sure it's quite the same thing as ad-hoc polymorphism.
11:18:45 <Cale> FunctorSalad: You do define functionality separately for each member of the family.
11:18:52 <bd> apparently i'm using an old list of prelude functions, what's a good recent one?
11:19:04 <Cale> FunctorSalad: But it seems more closely related to typeclass polymorphism.
11:19:04 <vixey> ghci
11:19:08 <vixey> bd
11:19:24 <vixey> Prelude.<tab>
11:19:25 <Cale> (which is a variation of parametric polymorphism, and not really ad-hoc polymorphism)
11:19:45 <idnar> bd?
11:19:49 <bd> yea
11:19:55 <idnar> oh.
11:20:09 <idnar> for some reason I thought "bd" was meant to be a command there
11:20:12 <FunctorSalad> Cale: ok, I thought type classes were a kind of ad-hoc p.
11:20:23 <bd> could be i suppose
11:20:25 <idnar> anyhow, I guess there's also http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
11:20:28 <lambdabot> Title: Prelude, http://tinyurl.com/y4wexy
11:20:42 <Cale> FunctorSalad: The original paper on them confused everyone by mentioning ad-hoc polymorphism, but it really deserves a new name.
11:21:07 <bd> @lambdabot thanks
11:21:07 <lambdabot> Unknown command, try @list
11:21:25 <FunctorSalad> Cale: I see. I'm just an amateur of PLT ;)
11:21:26 <Cale> FunctorSalad: Normally, in ad-hoc polymorphism, just using ad-hoc-polymorphic functions doesn't let you define new ad-hoc-polymorphic functions which work for all the types that those functions work for.
11:21:43 <Cale> Consider things like  sort :: (Ord a) => [a] -> [a]
11:21:51 <Cale> which is not a member of the Ord class
11:21:57 <Cale> er, method
11:22:30 <FunctorSalad> yes, that feels like a mix... it is treating a uniformly if you consider < a black box, I suppose
11:23:13 <the_unmaker> erm
11:23:24 <bd> @list
11:23:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:23:28 <the_unmaker> anyone got a website up? using haskell for dynamic?
11:23:35 <the_unmaker> html?
11:23:58 <Cale> the_unmaker: Didn't I point you at a bunch of resources yesterday?
11:24:34 <FunctorSalad> Cale: so could one say that sort is parametrically polymorphic, but in a universe where everything has (<)?
11:25:19 <Cale> FunctorSalad: Yeah, sort of... I think of it as restricted parametric polymorphism.
11:25:49 <Cale> Perhaps guarded or bounded would be another decent word there.
11:26:28 <Cale> The type variable 'a' isn't quantified over all types, but just those which are instances of the typeclass.
11:27:27 <Lemmih> the_unmaker: I'm running gitit. Not much content on it, though.
11:29:47 <ski_> Saizan : ok <http://hpaste.org/12201#a2>
11:31:34 <leimy> ski_:  you using some kind of fixed point combinator to weave in tracing?
11:33:01 <ski_> leimy : that's the idea, yes
11:33:13 <leimy> I've got some stuff that does that in Python
11:33:27 <leimy> Also in Scheme, and Groovy :-)
11:34:46 <ski_> i've seen something a bit similar in Scheme .. though i think that one relied on mutating the top-level binding of the recursive function
11:35:26 <gwern> Lemmih: how is gitit working for you?
11:36:00 <leimy> ski_: yeah it's not as nice
11:36:14 <Lemmih> gwern: It works very well. Here's the instance: http://lhc.seize.it/
11:36:25 <lambdabot> Title: Wiki - Front Page
11:37:01 * ski_ irritably wonders where the trailing spaces came from ..
11:38:07 * gwern groans. are you really calling it the large hadron compiler?
11:38:40 <Lemmih> gwern: It's just a template. Hopefully I won't have to fork it at all.
11:39:26 <gwern> no, I mean I thought Lemmih's Haskell Compiler was a better name
11:39:44 <Lemmih> Well, it's not really mine (:
11:40:02 <gwern> Lemmih: how does gitit work with a webserver? the instruction seems kind of vague
11:40:05 <gwern> ' 3.  Start a web server on port 5001.
11:40:44 <Lemmih> gwern: I use lighttpd to redirect lhc.seize.it:80 -> localhost:5001
11:40:58 <gwern> hm
11:41:14 <gwern> it's cool that it would seem to really support editing the wiki via git tho
11:41:16 <Lemmih> gwern: I'm also running a hackage server on seize.it.
11:42:06 * gwern mulls over Git.hs. is this doing anything darcs couldn't?
11:43:25 <Lemmih> I looked at replacing it but gave up.
11:44:51 <gwern> doesn't look too bad, but obviously all the sha hashes would probably have to be replaced by patch names for darcs
11:45:07 <ski_> hm .. is there any default licence applpying to hpaste pastes ?
11:45:43 <gwern> well, presumably there's an implied license to hpaste to let it redistribute original and derived works
11:46:35 <Lemmih> gwern: I'll buy you a beer at the next hackathon if you replace it with darcs. (:
11:47:04 <ski_> (i just would like to make sure people should not hesitate cannibalizing that code, should anyone find it useful)
11:48:07 <gwern> where it only equals hpaste, not everyone else
11:48:17 <gwern> (in much the same way usenet posts have an implied license)
11:48:47 <gwern> Lemmih: but what's in it for me? I don't like beer nor do I go to hackathons :)
11:48:57 <ski_> ok
11:49:09 <ski_> (*sigh* licencing is a headache)
11:49:48 <gwern> ski_: indeed. IP in general is messed up. it's an area quite as complex as many in programming
11:50:13 <gwern> (but on the plus side, IP is also more general than just programming, so spending a few weeks reading up on it is not wasted time)
11:57:54 <mapreduce> And then you get to argue about it in
11:57:58 <mapreduce> IRC channels.
11:59:46 <gwern> mapreduce: well I'd say it's more valuable as you can't participate in places like wikipedia or OSS communities without a basic understanding
12:00:08 <FunctorSalad> how would one extend Control.Category.Category such that forall a b. (Eq (cat a b)) is required?
12:00:21 <gwern> (if you don't, you're apt to do things like upload fair use images & get frustrated when they're deleted, or copy in articles from elsewhere and get banned)
12:00:31 <FunctorSalad> I can't put the forall in the class context
12:00:32 <mapreduce> Sure.  (I probably wouldn't have posted that line if it hadn't been for the accidental return key press)
12:00:55 <FunctorSalad> actually, nevermind, that's a stupid idea
12:01:16 <FunctorSalad> (categories have equality but not necessarily decidable equality)
12:03:09 <olsner> @ty (%)
12:03:10 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
12:13:06 <byorgey> FunctorSalad: in general I think you would need to make an Eq2 class
12:13:23 <byorgey> class Eq2 c where eq2 :: c a b -> c a b -> Bool
12:15:45 <the_unmaker> whats better in haskell compared to lisp os forth or smalltalk?
12:15:57 <vixey> folds
12:16:02 <the_unmaker> This type thing seesm a pain at first glance
12:16:04 <Deewiant> purity
12:16:21 <vixey> really?
12:16:34 <the_unmaker> I didn't read that much ..
12:16:51 <the_unmaker> seems liek some people are really excited about haskell tho
12:16:54 <snhmib> deriving (..) is really neat imo
12:17:31 <camior> the_unmaker: I've that if my program type checks, it is likely correct. I don't run into runtime errors as much in haskell mostly due to the type system.
12:17:41 <camior> s/that/found that
12:18:05 <the_unmaker> hm
12:18:22 <the_unmaker> so what ind of app do you build in haskell?
12:18:29 <the_unmaker> kind? sofar?
12:20:48 <FunctorSalad> vixey: folds? :o
12:21:06 <vixey> yeah
12:21:10 <FunctorSalad> the_unmaker: the type thing is what's better :)
12:21:30 <badsheepy> i have kindof come to view haskell as an essential stepping stone towards the one true language which noones made yet :o
12:21:50 <byorgey> the_unmaker: any kind.  see this thread: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/47491
12:21:52 <lambdabot> Title: Gmane Loom
12:22:05 <FunctorSalad> byorgey: hmm I thought so (that it's impossible to do directly)
12:22:23 <byorgey> vixey: what do you mean? can't you do folds in any language?
12:22:35 <the_unmaker> I thought common lisp was the true language
12:22:37 <FunctorSalad> I thought folds were one of the big headaches ;)
12:23:00 <FunctorSalad> I've usually been able to avoid them by using something more specific
12:23:01 <mapreduce> the_unmaker: Types are more than a pain, if you think in types then Haskell will help you.  If you don't, Haskell will force you to.
12:23:09 <vixey> They are better in a typed language with pattern matching (none of the languages listed fit that)
12:23:21 <mapreduce> the_unmaker: The true language does not have #'
12:23:51 <byorgey> good point, pattern matching is another nice thing about Haskell
12:24:21 <the_unmaker> web is about pattern matching I heard, most of web servign that is......so haskell might be great for web stuff............yay!!!
12:24:32 <byorgey> but saying that Haskell is better because of folds is like saying that a nice sports car is better because of races =)
12:24:43 <camior> the_unmaker: anygma.com is making some revolutionary tools for artists using haskell.
12:25:02 <the_unmaker> how about on unix, can haskell be more fun than i dunno python or perl?
12:25:09 <the_unmaker> i dont know either....
12:25:40 <earthy> yes, it can.
12:25:40 <mapreduce> @faq can Haskell be more fun than Python or Perl?
12:25:41 <lambdabot> The answer is: Yes! Haskell can do that.
12:25:42 <byorgey> the_unmaker: sure, Haskell works great on unix.
12:25:46 <camior> the_unmaker: Haskell is more fun than every programming language except dependant types it seems.
12:26:04 <the_unmaker> dependant ypes?
12:26:16 <the_unmaker> whats dependant types?
12:26:23 <mapreduce> @go dependent typing wikipedia
12:26:25 <byorgey> the_unmaker: don't worry about that, it's a feature of some more advanced languages
12:26:26 <lambdabot> http://en.wikipedia.org/wiki/Type_system
12:26:26 <lambdabot> Title: Type system - Wikipedia, the free encyclopedia
12:26:38 <camior> the_unmaker: You have to know haskell first before you can understand what that means. I haven't delved into it yet.
12:26:41 <earthy> um. dependent types are a peculiar form of machismo
12:26:44 <byorgey> the_unmaker: if you don't know anything about type systems then it won't make sense to you yet =)
12:27:03 <earthy> camior: not true. you can learn dependent types without learning haskell
12:27:04 <FunctorSalad> I forgot, what was the solution to the "long typeclass heirarchy" dilemma?
12:27:09 <earthy> (I did)
12:27:20 <camior> earthy: cool! How did you do that?
12:27:23 <earthy> dependent types predate haskell
12:27:27 <the_unmaker> I can sorta with my small brain say, ok if types tell haskell whats its dealing with, and haskell can buidl rules on howto compute what its dealing with, then things can be fast and correcT?
12:27:35 <earthy> camior: I learned typed lambda calculus...
12:27:41 <earthy> and coq
12:27:48 <earthy> in 1996 or so
12:27:49 <FunctorSalad> like, if you have "Magma g => Semigroup g => Monoid g => Group g => Abeliangroup g => ...."
12:28:02 <mapreduce> A dependent type that might appeal to someone not versed in the literature might be an array index that is statically checked so needs no runtime checking.
12:28:07 <FunctorSalad> the problem is that a user that wants just a group has to deal with all that other stuff that most won't be interested in
12:28:08 <earthy> the_unmaker: yup.
12:28:24 <FunctorSalad> I thought there was some trick
12:28:33 <camior> earthy: I was unaware that coq was an old thing. luqui also likes coq. Maybe I should start with that instead of Epigram.
12:28:33 <Deewiant> FunctorSalad: what do you mean by 'has to deal with'?
12:28:41 <orbitz> the_unmaker: check out real world haskell book (free online) if you want o see haskell ways of doing some sysems programming type stuff you would do in python
12:28:47 <FunctorSalad> Deewiant: has to declare instances for them all before he can declare a group
12:28:53 <the_unmaker> ok
12:28:53 <Deewiant> ah, right, hmm
12:28:56 <the_unmaker> thanks gents
12:29:02 <Deewiant> FunctorSalad: just don't make it a hierarchy like that? ;-)
12:29:09 <byorgey> FunctorSalad: there are various proposals for dealing with that, but no nice way around it atm
12:30:22 <earthy> camior: coq started in 1984
12:30:22 <FunctorSalad> Deewiant: I'd prefer starting with Group g and doing "instance Group g => Semigroup g", but that requires IncoherentInstances
12:30:37 <ski_> (FunctorSalad : <http://repetae.net/recent/out/supertyping.html> <http://repetae.net/recent/out/classalias.html> .. maybe some more)
12:30:37 <FunctorSalad> I'm considering accepting IncoherentInstances as the lesser evil
12:30:39 <byorgey> FunctorSalad: that wouldn't do what you want anyway
12:31:02 <byorgey> FunctorSalad: instance Group g => Semigroup g  says that everything is a Semigroup, and must be a Group also
12:31:19 <byorgey> in particular, it *doesn't* say that 'only things which are Groups are Semigroups'
12:31:34 <camior> earthy: Wow! I was 3 years old.
12:31:47 <Deewiant> byorgey: does anything say that?
12:31:59 <byorgey> Deewiant: not currently.
12:32:14 <Deewiant> but in the future?
12:32:16 <FunctorSalad> byorgey: but wouldn't it kinda work with IncoherentInstances on? ;)
12:32:18 <Deewiant> or not even planned
12:32:21 <FunctorSalad> ski_: thanks
12:32:23 <Deewiant> or proposed, whatever
12:32:41 <ski_> (byorgey : i thought `instance Group g => Semigroup g' said that anything which is a group is also a semigroup ..)
12:32:44 <byorgey> some of the proposals describe a way to say, e.g. 'if you have an instance of Group you can build an instance of Semigroup from it in this way: (definition of Semigroup methods in terms of Group methods)"
12:32:54 <saml1> test
12:32:57 <byorgey> but you can't do that currently.
12:33:04 <earthy> camior: I had just touched my first computer. :)
12:33:05 <Deewiant> Shame. :-/
12:33:14 <byorgey> ski_: no, instance selection looks only at the thing to the right of the =>
12:33:26 <byorgey> and then the stuff to the left of the => gets added as another constraint
12:33:29 <earthy> (starting an interest that could almost be called a love that hasn't worn off yet :))
12:33:37 <byorgey> it's rather unintuitive.
12:33:38 <FunctorSalad> byorgey: yeah, but I think it backtracks if the left side doesn't work out
12:33:49 <byorgey> FunctorSalad: That's exactly the point, it doesn't.
12:33:50 <FunctorSalad> byorgey: with IncoherentI. and UndecidableI. on
12:34:03 <ski_> byorgey : er, you're right .. i had forgotten about those ugly details
12:34:19 <FunctorSalad> byorgey: I could have sworn I saw backtracking in a trace :) maybe was sth else
12:34:30 <byorgey> FunctorSalad: I'm... not 100% sure, but pretty sure.
12:35:35 * kaol smirks at haddock's build dep "ghc >= 6.8.2 && < 6.13"
12:35:43 <FunctorSalad> hehe
12:36:04 <byorgey> hah, nice =)
12:36:21 <byorgey> it is already planned that ghc 6.13 will break haddock?
12:36:36 <Deewiant> and that 6.12 won't
12:36:48 <byorgey> issue 1973: break haddock  milestone: 6.13
12:36:59 <FunctorSalad> :)
12:37:02 <opqdonut> we
12:37:17 <opqdonut> we'll just skip to .13 when it breaks
12:37:31 <opqdonut> and do point-releases for .12 until that
12:37:34 <FunctorSalad> like washing machines are claimed to do? ;)
12:37:37 <FunctorSalad> or what was it
12:37:47 <byorgey> washing machines??
12:37:52 <opqdonut> ?
12:37:52 <camior> earthy: :)
12:38:04 <FunctorSalad> byorgey: maybe it's an urban legend, but supposedly some items are designed to break after a time
12:38:15 <byorgey> hah, I wouldn't be surprised
12:38:39 <Deewiant> well, things are designed to live for a certain period and it's just 'luck' if it lives longer
12:39:55 <FunctorSalad> 3-year expiry dates on salt are another good one
12:41:35 <FunctorSalad> err, back to topic ;)
12:41:48 <Gabbie> Random time to reattach screen O.o
12:44:40 <ski_> byorgey : could you clarify how this entails "everything is a Semigroup, and must be a Group also" ? .. i'm not seeing it
12:45:05 <_pizza_> FunctorSalad: http://en.wikipedia.org/wiki/Planned_obsolescence
12:45:06 <lambdabot> Title: Planned obsolescence - Wikipedia, the free encyclopedia
12:45:32 <Heooo> What does term "leftmost outer redex" mean? Reduction expression? So eg \xt.(fsd (sdf) (sdf)), Is the leftmost outer redex fsd, f or some process?
12:46:03 <Deewiant> ski_: instance Foo a means that all types are Foo. instance Bar a => Foo a adds the "must be a Bar also" constraint.
12:47:16 <ski_> "Assume that the type variables in the instance type (T u1 ... uk) satisfy the constraints in the instance context cx'." afaiu, this means that *given* that `Bar a' holds, `Foo a' should hold (provided some extra things under this assumption)
12:50:51 <byorgey> ski_: I guess I didn't word that very well.  the problem is that "instance Group g => Semigroup g" overlaps with any other Semigroup instances you might care to write
12:50:52 <ski_> Heooo : if `fsd',`sdf' are variables, then there is no redex in that expression
12:51:13 <ski_> byorgey : that i fully agree with
12:51:14 <byorgey> so maybe using overlapping/incoherent instances sort of works.
12:51:52 <byorgey> but it doesn't work very well in practice, I think.
12:52:10 <FunctorSalad> byorgey: from the undecidable instances doc: "Termination is ensured by having a fixed-depth recursion stack. If you exceed the stack depth you get a sort of backtrace, and the opportunity to increase the stack depth with -fcontext-stack=N. "
12:52:47 <byorgey> ski_: perhaps how I should have worded that is, "everything *may* be a Semigroup, and if you use something as a Semigroup, then it had better be a Group also."
12:53:04 <byorgey> but this is bad if you want Semigroups which are not Groups.
12:53:05 <FunctorSalad> yes it will overlap, but how often do you give a type one addition as a group and a different addition as a semigroup?
12:53:16 <Heooo> ski_: Yes, it is what I thougth. So does it means this: eq (\c.fd) (\df.dfds) (\f.sdfdf), so you beta-reduce the second EXP to first with the meaning of "reduce first leftmost outer redex" ?!
12:53:21 <Riastradh> So, how come we don't have named type class instances?
12:53:47 * byorgey goes to read about overlapping instances again
12:53:47 <Heooo> ski_: in short, it is about expressions
12:54:12 <Heooo> redex I mean
12:54:26 <Heooo> redex = reduction expression ?
12:54:33 <Heooo> or something else?
12:54:50 <vixey> Heooo, you don't have a definition of redex?
12:55:04 <FunctorSalad> byorgey: not sure whether that quote implies backtracking though, or whether it will just do DFS and fail upon first stack overflow
12:55:10 <ski_> "reductible expression", istr
12:55:22 <Riastradh> `Reducible', without the `t'.
12:55:23 <ski_> (possibly "reducible")
12:55:44 <byorgey> FunctorSalad: yes, I think that's what it does.  the only control you have over which of several possible instances it picks at each step is that it will pick the one which is 'most specific'.
12:56:34 <byorgey> so in this case if you wanted to make a specific data type an instance of Semigroup, that would be ok, since it would pick that instance instead of the more general 'instance Group g => Semigroup g'.
12:56:52 <Heooo> vixey: I know it is something to be reduced but since you can express everything with functions in lambda calculus, I easily think everything as redex
12:57:05 <vixey> Heooo, you shouldget a formal definition of redex
12:57:19 <byorgey> but if you also wanted something else like 'instance AntiAdjointMorphismIso g => Semigroup g', you're out of luck.
12:58:25 <Heooo> vixey: I found this in google: "Something to be reduced according to the rules of a formal system" but it is a bit vague to me. You do not know formal system precisely
12:58:42 <Heooo> with this definition
12:58:55 <vixey> Heooo, you need sytax and reduction rule definition of lambda calculus
12:59:28 <ski_> Heooo : `(\c.fd) (\df.dfds) (\f.sdfdf)' would usually be taken to mean `((\c.fd) (\df.dfds)) (\f.sdfdf)' .. here the left-most outer-most redex is `(\c.fd) (\df.dfds)' (which reduces to `fd')
13:00:12 <Heooo> ski_: what about outermost redex in the example?
13:01:00 <Heooo> this (\f.sdfdf) ?
13:01:19 <Heooo> or the whole expression?
13:01:58 <Heooo> my key point here is that you need to expressions to reduce
13:02:04 <Heooo> *two
13:03:07 <ski_> Heooo : i'm not sure whether there is a concept "outermost redex" defined, separate from "leftmost outermost redex" .. perchance you could provide a definition ?
13:05:05 <FunctorSalad> byorgey: I made an example; this one works with the instance declarations sorted either way http://hpaste.org/12208
13:05:29 <FunctorSalad> (instead of trying the recursive rule and failing)
13:05:43 <FunctorSalad> maybe that is because we have a most specific instance here
13:10:26 <Heooo> ski_: is there a reduction called "aplication order reduction" or similar?
13:11:44 <vixey> Heooo, if x ==> x' means x evaluates to x',  applicative order (\u v w -> M u v w) x y z => (\u v w -> M u v w) x' y' z' => M x' y' z', but with lazy evalution, (\u v w -> M u v w) x y z ==> M x y z
13:11:46 <ski_> Heooo : yes (aka "leftmost innermost")
13:12:39 <ski_> (Heooo : maybe <http://en.wikipedia.org/wiki/Evaluation_strategy> is of some small use .. i haven't read it closely)
13:14:32 <ski_> Riastradh : iirc, it was not agreed upon that having it would be a good idea. (specifically, istr something about possible interactions with coherence in instance selection)
13:14:51 <Riastradh> Interactions with coherence in instance selection?
13:15:31 <vixey> any 'strongly normalizing' logic programming language is suitable as a replacement for typeclass dispatch?
13:15:52 <Saizan> Riastradh: things like building a Map k with an instance of Ord k and manipulating it with another, or worse for Storable
13:16:55 <Riastradh> Actually, that's not quite what I meant by `named type class instances', for which I ought to have used a better term.
13:17:12 <Riastradh> Perhaps `named, parametrized type class instantiators' would be better.
13:17:18 <Riastradh> (What a mouthful!)
13:18:20 <Heooo> vixey: thx, I think you mentioned a key word I was looking for.
13:18:53 <Heooo> ski_: and I found more on the site. Thx!
13:19:05 <ski_> would you be able to supply an instance created with such an instantiator to e.g. `sum :: Num a => [a] -> a' ?
13:19:35 <Riastradh> For example, one can always instantiate Arrow in terms of a Monad instance.  But perhaps that's not the arrow structure you want.  One would therefore want to define a Kleisli arrow instantiator, which, when given a type with a Monad instance, would instantiate Arrow for that type.
13:20:34 <FunctorSalad> isn't an *incoherent* overlap rare enough that one could make it a runtime error or warning?
13:21:08 <FunctorSalad> incoherent as in semantically different implementations of the method
13:22:32 <ski_> would you be able to supply an instance created with such an instantiator, when making an standard instance of e.g. `Arrow'
13:22:36 <ski_> ?
13:23:30 <FunctorSalad> then there's also numerical priorities like in coq
13:23:49 <Riastradh> ski_, I'm not quite sure I understand.  If one has named type class instances, then one could pass named type class instances to named type class instantiators.  Otherwise, one would pass only type constructors to the instantiators.
13:26:23 <Saizan> so this Kleisli instantiatior will do what newtype Kleisli m a b = .. do now without the need to wrap/unwrap?
13:26:50 <ski_> Riastradh : i was asking about where you would possibly use a named type class instance, except as for constructing yet more named type class instances
13:27:05 <Riastradh> Hmm.  Here's a slightly more concrete example.  Suppose we want to have multiple representations of complex numbers, such as rectangular and polar representations.  If we have a Complex type class, on which we have functions make_rectangular, make_polar, real_part, imag_part, angle, magnitude, &c., then we have two obvious choices from which to instantiate Num.
13:28:20 <Riastradh> For rectangular complex representations, we'd prefer to write multiplication in terms of sums, differences, and products of the real and imaginary components.  For polar representations, we'd prefer to multiply magnitudes and sum angles.
13:29:27 <Riastradh> However, Haskell has no way to name the instantiation of Num from a Complex instance using rectangular operations, as distinct from the instantiation of Num from a Complex instance using polar operations.
13:29:51 <Riastradh> Each type class can have only one default instantiator, which is what is written within the type class's definition.
13:30:34 <ski_> are you referring to the default definitions that one can provide ?
13:30:38 <Riastradh> Yes.
13:35:56 <ski_> i'm not sure i understand how this would work out in this example
13:36:12 <ski_> are you considering a type class
13:36:21 <ski_>   class Num a => Complex a
13:36:23 <ski_>     where
13:36:25 <vixey> Riastradh, is that not impelementable in chamelion?
13:36:25 <Riastradh> No.
13:36:34 <ski_>     ..type signatures and default definitions..
13:36:42 <Riastradh> Suppose I have:  class Complex a where ...
13:37:02 <ski_> but you'd like to provide more than one "canonical" instantiator ?
13:37:20 <Riastradh> I'd like to write:  instantiator Complex a => RectComplexNum a : Num a where a + b = make_rectangular (real_part a + real_part b) (imag_part a + imag_part b); ...
13:38:15 <Riastradh> ...and similarly for PolarComplexNum.  Then for any type with an instance of Complex, I'd like to be able to instantiate Num for that type either with rectangular arithmetic or with polar arithmetic, by naming which one I want.
13:40:49 <Saizan> a bit like "deriving" then
13:41:13 <Riastradh> There is a connection to `deriving', I suppose.
13:43:07 <ski_> ok
13:45:10 <ski_> (by "instantiate Num" do you mean just create a (possibly named) type class instance, or also providing that one as a "blessed" one, as if having written `instance Num Eisensteinian where ...' explicitly ?)
13:45:56 <FunctorSalad> byorgey: hmm, ghc immediately aborts if there are two instance declarations with the same right side. that would limit the possibilities even if the search worked as it should
13:46:14 <Riastradh> ski_, sorry, I don't know what the difference is.
13:46:59 <Riastradh> ski_, I'd expect that `instantiate PolarComplexNum PolarMumbleType' would have the same effect as `instance Num PolarComplexType where a * b = make_polar (magnitude a * magnitude b) (normalize_angle (angle a + angle b)); ...'.
13:47:07 <ski_> the first would create a value (or something similar) that could at will be passed to functions and used in local contexts
13:47:28 <Riastradh> Ah.  No, named type class instances, as I said, are different from, and independent of, named type class instantiators.
13:47:39 <Riastradh> (Personally I want both -- but they're independent concerns.)
13:47:58 <dons> ?users
13:47:58 <lambdabot> Maximum users seen in #haskell: 550, currently: 537 (97.6%), active: 12 (2.2%)
13:48:07 <vixey> Have you looked at Chamelion?
13:48:10 <Riastradh> (In fact, named type class instances would justify the `data (Ord k) => Map k v = ...' notation.)
13:48:13 <ski_> (it wasn't clear to me whether "instantiate)
13:48:37 <FunctorSalad> btw, what about the wrapping solution? instance Group a => Semigroup (SGFromGroup a)
13:48:39 <FunctorSalad> ?
13:48:40 <ski_> (.." meant an operation yielding an instance or an instantiator)
13:48:54 <FunctorSalad> it's ugly but if nothing else works...
13:50:52 <gwern> holy cow
13:51:04 <gwern> highlighting-kate produces a dist/ containing *1.2* gigs of files
13:51:11 <dons> hehe
13:51:23 <dons> gwern: did you check out the mediawiki bindigns?
13:51:37 <gwern> no wonder it took several hours to compile X_X
13:51:43 <gwern> dons: I did. very interesting
13:52:16 <gwern> I wonder at all these people I've never heard of who upload a single enormous package to hackage and that's it
13:52:44 <dons> http://www.reddit.com/r/programming/comments/7eg0g/the_monadreader_issue_12_physics_engines_in/ <--
13:52:44 <gwern> (are they doing large things because haskell is so much more usable in the last few years, or have they always been there?)
13:52:49 <dons> gwern: heh. sigbjorn?
13:52:51 <lambdabot> http://tinyurl.com/6nhwtx
13:52:55 <dons> you should know who he is :)
13:53:15 <gwern> dons: well, if sigbjorn is not a good example what abotu the gitit fellow?
13:53:17 <dons> gwern: http://www.galois.com/~sof/
13:53:21 <lambdabot> Title: sof's home page
13:53:23 <gwern> I should?
13:53:25 <dons> oh, john macfarlane?
13:53:31 <gwern> yes
13:53:32 <dons> you should know him from pandoc
13:53:37 * gwern is not good with names
13:54:12 <dons> siggy's one of the most talented hackers i've ever known.
13:55:06 <dons> gwern: yeah, i think though we're seeing large things because a) usable b) documented
13:55:10 <dons> so its easier to build big things now.
13:58:11 <uncommons> I just upgraded Haddock from version 2.0.0.0 to 2.4.1 and now I'm getting this error:
13:58:13 <uncommons> haddock: internal Haddock or GHC error: No libdir found
13:58:21 <uncommons> Any ideas how to fix it?
13:58:28 <gwern> dons: why did he write a mediawiki binding anyway?
13:59:05 <dons> he's a bit of a mediawiki expert these days.
13:59:58 <gwern> clearly; is he running some wikis then?
14:00:33 <dons> i think he's spent a lot of time looking at wiki architectures.
14:00:52 <uncommons> GHC 6.8.2, OS X 10.4
14:01:05 <dons> uncommons: hmm. no.
14:01:10 <dons> uncommons: ask dcoutts_, he's the cabal exprt
14:01:52 <gwern> uncommons: well, it's a GHC API error; libdir is a parameter to set up a compiler session, so ghc knows where to look for the available libraries
14:02:19 <uncommons> Maybe a problem when I built Haddock?
14:02:26 <gwern> uncommons: I would guess maybe that haddock just doesn't work with an 'old' ghc like that
14:02:36 <EmielRegis> is there a way of passing a static object to functions run in 'par'?
14:03:59 <uncommons> gwern: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haddock-2.4.1 says it works with GHC >= 6.8.2
14:04:01 <lambdabot> Title: HackageDB: haddock-2.4.1, http://tinyurl.com/59dlsv
14:04:15 <gwern> ...except I'm running 6.8.2 and that haddock version just installed fine
14:04:15 <gwern> hm
14:04:19 <ski_> (Riastradh : would you care to elaborate on your comment regarding `data (Ord k) => Map k v = ...' ?)
14:04:48 <gwern> ok, second guess: macs often have path problems, and your ghc is confused. solution: I've no idea. maybe upgrade?
14:06:47 <uncommons> gwern: You could be right :(  Maybe time to build 6.10.1...
14:06:54 <Riastradh> ski_, as Saizan mentioned, if one operates on a Map with two different instances of Ord, one is bound to lose.
14:07:06 <gwern> I hear there are mac packages or whatever of 6.10. how bad could it be?
14:07:12 <Riastradh> ski_, associating the instance of Ord with which the Map was created would preclude this.
14:08:05 <Riastradh> On the other hand, I'm sure there are other cases where the use of two different instances of a common type class on common data is intended.  Since I must vanish now, I have no time to conjure any examples.
14:09:13 <ski_> (i don't see how to associate a specific instance with the type `Map k v' ..)
14:09:14 <uncommons> gwern: I can't remember how I installed it last time.  I think I had to build it all from source, took a while.  I think the binary package is only for Leopard.
14:09:31 <ski_> Riastradh : ok
14:10:00 <Riastradh> ski_, writing `data (Ord k) => Map k v = ...' would imply that each value of type Map can have only a single instance of Ord k associated with it, and each operation on said maps would use that instance.
14:10:04 * Riastradh vanishes now.
14:11:35 <jkramar> @(\((a,b),(c,d))->((a,c),(b,d)))
14:11:36 <lambdabot> Unknown command, try @list
14:11:47 <jkramar> @pl (\((a,b),(c,d))->((a,c),(b,d)))
14:11:51 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
14:11:51 <lambdabot> optimization suspended, use @pl-resume to continue.
14:12:05 <jkramar> @pl-resume
14:12:07 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
14:13:02 <jkramar> @unpl uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
14:13:12 <lambdabot> uncurry (uncurry (\ ab f -> (\ p x -> ((,)) (((,)) ab (fst p)) (((,)) f x)) >>= \ ag -> snd >>= \ af -> return (ag af)))
14:13:54 <jkramar> @pl (\((a,b),(c,d))->(a-c,(b,d)))
14:13:54 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (-)))
14:14:02 <ski_> (i would hope to interpret the `(Ord k) => Map k v' as saying that provided that `Ord k', the type `Map k v' is meaningful. but perhaps that would not be a useful interpretation here .. however i'm not sure about associating instances with values .. what would happen with a `zipWith :: (Maybe a -> Maybe b -> c) -> (Map k a -> Map k b -> Map k c)' operation ?)
14:15:11 <jkramar> @pl (\(a,b) (c,d)->(a-c,(b,d)))
14:15:12 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (-))
14:15:12 * ski_ leaves the topic for the while
14:15:52 <idnar> ski_: wouldn't that have to be zipWith :: (Ord k) => (Maybe a -> Maybe b -> c) -> (Map k a -> Map k b -> Map k c)
14:16:21 <dfrey|work> Is there a built-in function that will split a list at a given element?  eg:  split ',' "this,is,a,list" -> ["this", "is", "a", "list"]
14:16:22 <ski_> (idnar : quite possibly .. i'm a bit tired atm)
14:16:35 <ddarius> dfrey|work: Yes.  It's called splitAt
14:16:41 <ddarius> Er, nevermind.
14:17:12 <ddarius> dfrey|work: It's easy to write one with span/break.
14:17:15 <ddarius> @src lines
14:17:15 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:17:25 <vixey> @src unlins
14:17:26 <lambdabot> Source not found. Wrong!  You cheating scum!
14:17:31 <ski_> (idnar : or possibly the `Ord k' was meant to be implied/provided by the map values in question, thus not needing such explicit qualification)
14:17:35 <ddarius> Look at the source of lines and adjust as appropriate, or you could use the regex libraries.
14:17:58 <ski_> (idnar : c.f the "dreaded `Monad Set'" issue)
14:18:33 <ski_> @src unlines
14:18:34 <lambdabot> unlines = concatMap (++ "\n")
14:33:47 * Asztal prods Asztal_, Asztal__, and Asztal____
14:35:54 <dmwit> Asztal: /msg NickServ ghost Asztal_
14:36:03 <dmwit> (etc.)
14:36:14 <dmwit> Oh, I see you already know how to do that trick.
14:36:17 <dmwit> never mind
14:36:20 <te> im a newb, and im confused
14:36:51 <te> GHCI> f x = case x of
14:37:10 <te>         { 0 -> 1 ; 1 -> 5 ; 2 -> 2 ; _ -> 1 }
14:37:15 <dmwit> First mistake: functions must be defined with "let" in ghci.
14:37:16 <te> ERROR - Syntax error in input (unexpected `=')
14:37:35 <te> yeah see i knew that, but the example code doesn't use let, which is friggen stupid for a tutorial
14:37:40 <mauke> Second mistake: that's a hugs error
14:37:42 <dmwit> Second mistake: To do multiline in GHCi, you have to prefix it with a ":{" line and end it with a ":}" line.
14:38:01 <te> thanks dmwit
14:38:03 <te> mauke: nice catch
14:38:05 <te> ;)
14:38:07 <mauke> te: the example code is real haskell, not something you type in the repl
14:38:07 <dfrey|work> ddarius: Thanks, I wrote it using break.  That was my original idea, but I thought there might be a built in function to do it already.
14:38:37 <te> mauke: i get the same error if i compile
14:38:48 <mauke> then something else is wrong
14:39:14 <mauke> works here
14:39:20 <te> main =
14:39:20 <te>         f x = case x of
14:39:20 <te>                 { 0 -> 1 ; 1 -> 5 ; 2 -> 2 ; _ -> 1 }
14:39:32 <mauke> remove 'main ='
14:39:43 <te> then it tells me it's not in scope main
14:39:54 <mauke> yes
14:39:59 <Botje> te: no, it says there's no main function defined
14:40:05 <Botje> to compile it you have to have a main function
14:40:16 <mauke> Botje: not if you use -c
14:40:36 <Botje> oh
14:41:11 <te> thanks for holding my hand, this is going to take some time :\
14:41:47 <mauke> te: I recommend putting f into a file, then loading that file into ghci
14:44:21 <te> mauke: good advice
14:44:31 <te> mauke: if i wanted to put i t all in the file, how is it structured?
14:44:43 <mauke> what do you mean?
14:44:51 <te> i put the definition before my main, and then call it in my main, but it's out of scope, so i put it in my main, and it fails with a parse error on '=`
14:45:02 <te> does that mean i need to use `let` inside main
14:45:06 <mauke> it shouldn't be out of scope in main
14:45:32 <Botje> te: order doesn't matter
14:45:49 <mauke> also, you don't need a main to load the file in ghci
14:48:14 <te> mauke: thanks for your help, ill be back later to bother you :)
14:48:25 <mauke> yay :-)
14:49:14 <vixey> te, f 0 = 1
14:49:17 <vixey> te, f 1 = 5
14:49:20 <vixey> te, ...
14:49:56 <mauke> redundant use of f
15:04:31 <EmielRegis> is there a way of declaring a function static?
15:04:42 <EmielRegis> so it acts as a read-only variable and is calculated only once?
15:04:49 <mauke> that's not what static means
15:05:00 <lament> EmielRegis: They're all static.
15:05:03 <EmielRegis> well ok, lemme rephrase
15:05:09 <EmielRegis> not static but global
15:05:11 <mauke> how about you use a variable
15:05:20 <mauke> they're read-only and are calculated only once
15:05:28 <lament> mauke: including functions
15:05:40 <lament> EmielRegis: x = 4 -- this seems to do what you want
15:05:52 <dolio> Are we talking about some language that isn't Haskell?
15:05:58 <EmielRegis> mauke, how to declare them?
15:06:13 <mauke> var = value
15:06:23 <EmielRegis> ye but thats just a function that has no input
15:06:24 <EmielRegis> isnt it
15:06:46 <dons> are we talking about Haskell, EmielRegis ?
15:06:50 <EmielRegis> yes
15:06:50 <mauke> EmielRegis: no
15:06:56 <dons> everyone's confused, since haskell is a pure language...
15:07:05 <mauke> every function takes one argument and returns one value
15:07:09 <mauke> no argument, no function
15:07:12 <lament> EmielRegis: sure, it's a function that has no input
15:07:19 <Pseudonym> All variables only have one value.
15:07:23 <lament> EmielRegis: there's no problem whatsoever with thinking about it that way
15:07:28 <Pseudonym> Which is calculated only once.
15:07:31 <Pseudonym> (To a first approximation.)
15:07:38 <lament> and it's calculated at most once :)
15:07:41 <mauke> lament: except "function" is now meaningless
15:07:45 <lament> mauke: oh, absolutely
15:07:48 <lament> but so is "variable"
15:07:51 <dolio> (Except when it's type-class polymorphic.)
15:07:52 <vixey> EmielRegis, every function is static in haskell
15:07:53 <lament> yet you were using that term freely
15:08:06 <mauke> variable as opposed to constant
15:08:10 <lament> x = 4 -- would you seriously call x a variable? Why?
15:08:21 <mauke> I would, because it starts with a lowercase letter
15:08:23 <lament> it's a constant function of zero arguments :)
15:08:47 <lament> mauke: f x = x * 2 -- x is a variable
15:08:50 <mauke> yes
15:08:52 <EmielRegis> well, nested functions are sure not global ;)
15:09:09 <mauke> f is also a variable
15:09:09 <EmielRegis> bgColor = black
15:09:19 <lament> mauke: you can call f a variable
15:09:22 <EmielRegis> would that be final?
15:09:23 <lament> i don't really object
15:09:30 <EmielRegis> as in, calculated only once
15:09:31 <lament> but it makes the word 'variable' meaningless
15:09:32 <EmielRegis> for every call to it?
15:09:40 <mauke> EmielRegis: you can't call it; it's not a function
15:09:46 <EmielRegis> well, use
15:09:48 <EmielRegis> not call then
15:09:49 <mauke> lament: no, because we also have constructors
15:09:56 <mauke> lament: and values
15:10:13 <lament> so f is a name
15:10:18 <lament> it's certainly a name
15:10:30 <mauke> yes
15:10:49 <Saizan> Maybe is also a name
15:10:56 <EmielRegis> lol what a discussion]
15:11:02 <Saizan> but not a variable
15:11:04 <hackage> Uploaded to hackage: xosd 0.2
15:11:04 <hackage> Uploaded to hackage: funcmp 1.2
15:11:13 <lament> EmielRegis: you started it
15:11:16 <EmielRegis> i know
15:11:18 <EmielRegis> lemme ask other way
15:11:27 <lament> EmielRegis: no better way to start a nomenclature flamewar than by mentioning "static"
15:11:27 <EmielRegis> given objects, which is a list of variable
15:11:28 <Saizan> EmielRegis: however yes, if you define foo = "foo", that string will be built only once
15:11:31 <EmielRegis> would this be constant lights = filter (\f -> isLight f) objects
15:11:37 <EmielRegis> and calculated only once
15:11:40 <EmielRegis> ?
15:11:47 <mauke> (\f -> isLight f) better written as isLight
15:11:49 <Saizan> yes.
15:11:53 <lament> EmielRegis: to a first approximation, everything in haskell is constant and calculated only once.
15:11:55 <EmielRegis> lol mauke true
15:11:56 <EmielRegis> i fail
15:12:00 <vixey> EmielRegis, I can show you an example of calculating a sequence of numbers that might help
15:13:52 <EmielRegis> ok
15:13:57 <vixey> so consider,
15:14:08 <vixey> fib 0 = 0
15:14:11 <vixey> fib 1 = 1
15:14:20 <vixey> fib n = fib (n-1) + fib (n-2)
15:14:30 <Pseudonym> Woo, Fibonacci numbers!  Excellent example!
15:14:38 <vixey> EmielRegis, if you do fib 30 or something large it will take a really long time to calculate
15:14:38 <dons> heh
15:14:43 <Pseudonym> People don't use them enough.
15:14:48 <dons> Pseudonym: i find it both practical, and persuasive.
15:14:58 <Pseudonym> :-)
15:15:05 * ddarius spices things up: gib 0 = 1; gib 1 = 3; gib n = gib (n-1) + gib (n-2)
15:15:14 <vixey> EmielRegis, so one way to fix this is to give a toplevel definition of 'fibs' and then make some alterations,
15:15:17 <mapreduce> Is there a practical use for fibonacci numbers?
15:15:19 <vixey> fibs = map fib [0..]
15:15:20 <Pseudonym> Aren't they the Lucas numbers?
15:15:30 <vixey> fib' n = fibs !! n
15:15:30 <Pseudonym> mapreduce: Look up Fibonacci heaps.
15:15:31 <ddarius> mapreduce: Yes.
15:15:33 <vixey> fib 0 = 0
15:15:38 <vixey> fib 1 = 1
15:15:40 <dons> Igloo: joey hess is learning haskell..
15:15:43 <vixey> fib n = fib' (n-1) + fib' (n-2)
15:15:59 <Pseudonym> But to be honest, their main use in computer science is that they often show up in algorithm analysis.
15:16:00 <vixey> EmielRegis, now if you try this second version of the thing out,  fib 30 will take almost no time at all
15:16:02 <Igloo> He has been for a while, off and on at least
15:16:09 <dons> yeah. http://kitenet.net/~joey/blog/entry/a_year_of_haskell___40__not_really__41__/
15:16:12 <Pseudonym> For example, they're an extreme case in Huffman coding.
15:16:19 <lambdabot> Title: a year of haskell (not really), http://tinyurl.com/6haan9
15:16:21 <vixey> EmielRegis, (Do you observe this in ghci or something by testing?)
15:16:25 <dons> Igloo: maybe we need to hook him  up with some help
15:16:27 <FunctorSalad> IIRC fibs are also teh worst case for avl trees
15:16:40 <vixey> EmielRegis, (once you actually saw it happen, I can try to explain why)
15:16:42 <EmielRegis> hmm
15:16:49 <EmielRegis> ah
15:16:51 <EmielRegis> i can see now
15:17:04 <EmielRegis> it builds a list of all fibs in the first call
15:17:11 <vixey> yeah you got it
15:17:12 <EmielRegis> or not
15:17:15 <EmielRegis> its lazy after all
15:17:16 <vixey> that's exactly right
15:17:23 <Pseudonym> FunctorSalad: You may well be right there.
15:17:25 <EmielRegis> so it doesnt until the exact number is called
15:17:25 <vixey> the big list of 'fibs' is not recomputed
15:17:26 <EmielRegis> right?
15:17:35 <mapreduce> > let ones = 1 : ones in ones
15:17:36 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:17:44 <vixey> It only comptes how much of the list of fibonacci numbers that is needed
15:17:46 * ski_ wonders how `gib' is related to `Lucas' ..
15:17:58 <EmielRegis> ah ye
15:17:58 <mapreduce> That one[pun] helped me with lazy lists.
15:18:21 <mauke> mapreduce: you can do that in a strict language
15:18:21 <vixey> I like the zipWith (+) fibs (tail fibs) in lisp macros
15:18:22 <FunctorSalad> ski_: fib + 1 char? ;)
15:18:23 <EmielRegis> so with successing computations of higher fibonacci, it only evaluates next parts of the list?
15:18:28 <FunctorSalad> with least significant first
15:18:32 <vixey> EmielRegis, yes
15:18:34 <EmielRegis> ok
15:18:41 <vixey> EmielRegis, it has all the previous work around already to reuse
15:18:41 <mapreduce> mauke: Yes.  I first saw it in Scheme, and I've written it in C# and Java.
15:19:02 <mauke> struct node ones = {1, &ones};  /* old school */
15:19:15 <mapreduce> Heh.
15:19:57 <FunctorSalad> EmielRegis: the haskell wiki has a page with faster than linear fib implementations though
15:20:12 <FunctorSalad> that's probably besides the point, but just saying
15:20:19 <vixey> EmielRegis, This happens everywhere too, for example  square x + square x vs let xx = square x in xx + xx
15:20:30 <dmwit> Faster than linear?
15:20:35 * dmwit has severe doubts
15:20:45 <FunctorSalad> dmwit: faster than linear in n :)
15:20:47 <vixey> EmielRegis, the top level definition of fibs = ... is like a let (toplevel is like a big mutually recursive let)
15:20:49 <FunctorSalad> not in length(show n)
15:20:55 <EmielRegis> k
15:21:06 <FunctorSalad> recursion with memoizing is O(n), no?
15:22:35 <dmwit> FunctorSalad: Even using the matrix exponentiation trick doesn't get you better than O(n), I thought.
15:23:19 <ddarius> You can calculate any single fib in O(log n) time (assuming constant time addition)
15:24:09 <vixey> you can calculate every fib in O(1)
15:24:16 <vixey> you juts need to know the previous tow :P
15:24:26 <dmwit> ddarius: okey dokey
15:24:40 <ddarius> vixey: I can calculate it in O(0), I just need to already have it.
15:24:45 <vixey> ever better!
15:24:52 <mauke> you can calculate every fib in O(1), you just need O(1) arithmetic with infinite precision
15:24:57 <jaj> vixey: you can't calculate it in O(1) if you have the previous one
15:25:09 <tessier_> ddarius: memoize it
15:25:13 <jaj> you need the one before that one, too
15:25:26 <mauke> jaj: that's what he said
15:26:15 <EmielRegis> hmm
15:26:40 <FunctorSalad> dmwit: matrix exponentiation is O(log(n))
15:26:43 <jaj> mauke: assuming you want to calculate fib(n), then you need fib(n-1) and fib(n-2). if you only have fib(n-1), how can you find out fib(n-2) in O(1)?
15:26:47 <vixey> I got to think of something that uses factoral
15:26:49 <ddarius> I guess the actual running time is something like O(log n log log n)
15:26:50 <FunctorSalad> as I said, if n is the arg to fib, not its length
15:26:50 <EmielRegis> is hdr basically adjusting colour of all pixels to the brightest ones?
15:27:11 <ddarius> EmielRegis: No.
15:27:17 <FunctorSalad> ddarius: if you're not considering the arithmetic operations constant, I assume
15:27:42 <mauke> jaj: why are you asking me this?
15:27:50 <Pseudonym> vixey: I've used factorial to compute accurate probability distributions for constructing compression algorithms.
15:27:56 <dons> "Haskell and C are probably the only good programming
15:27:56 <dons> languages that exist. everything else is so faddy. nothing beats good C
15:27:57 <dons> code. and Haskell code is almost always good by definition."
15:28:03 <dons> cute.
15:28:07 <EmielRegis> hehe
15:28:09 <mauke> jaj: (also, I divide by 0.5 + sqrt 1.25)
15:28:10 <FunctorSalad> author?
15:28:16 <dons> http://foursquare.nfshost.com/dablog/?p=358
15:28:22 <vixey> >  0.5 + sqrt 1.25
15:28:25 <lambdabot>   1.618033988749895
15:28:27 <lambdabot> Title: the light » Blog Archive » what linux kernel do you run?
15:28:29 <EmielRegis> ddarius, would you care to elaborate how would exact algorithm look then? :)
15:28:47 <FunctorSalad> EmielRegis: the trick is square-and-multiply
15:29:11 <Pseudonym> Good heavens.  Nothing beats good C code by what metric, exactly?
15:29:26 <geezusfreeek> > let fib n = ((((1 + sqrt 5) / 2) ** n) - (((1 - sqrt 5) / 2) ** n))/sqrt 5 in map fib [1..]
15:29:27 <ddarius> Pseudonym: By the faddiness metric.
15:29:27 <lambdabot>   [1.0,1.0,2.0,3.0000000000000004,5.000000000000001,8.000000000000002,13.0000...
15:29:28 <FunctorSalad> A^n = (A^(n/2))^2 for n even, A^(n-1)*A otherwise
15:29:32 <mapreduce> Speed, probably.
15:29:34 * mwc wishes for tuple sections, ie, (,True,) :: a -> b -> (a,Bool,b)
15:29:38 <EmielRegis> and readability Pseudonym
15:29:39 <EmielRegis> :P
15:29:39 <dons> yeah, Pseudonym loves that kind of talk.
15:29:43 <Pseudonym> geezusfreeek: That's still O(log n).
15:29:49 <Pseudonym> Yeah, I do. :-)
15:30:00 <Pseudonym> C is hardly readable, and it's not as fast as people think.
15:30:01 <geezusfreeek> Pseudonym, what operations are we counting?
15:30:08 <FunctorSalad> EmielRegis: since at most half of the n will be odd during the recursion, you only recurse O(log(n)) times
15:30:10 <Pseudonym> ?src (**)
15:30:10 <lambdabot> Source not found. My mind is going. I can feel it.
15:30:16 <geezusfreeek> i missed much of the conversation
15:30:25 <Pseudonym> :t (**)
15:30:26 <lambdabot> forall a. (Floating a) => a -> a -> a
15:30:30 <Pseudonym> Ah, right.
15:30:31 <dons> http://www.reddit.com/r/programming/comments/7egn9/boosting_software_transactional_memory_martin/ <-- inneresting
15:30:33 <lambdabot> Title: Boosting software transactional memory: Martin Sulzmann's blog : programming, http://tinyurl.com/5eantq
15:30:37 <Pseudonym> (^^) is O(log n)
15:30:46 <EmielRegis> FunctorSalad, wha do you refer to?
15:30:47 <Pseudonym> The thing is, your version overflows.
15:30:52 <geezusfreeek> Pseudonym, yes
15:31:02 <ddarius> :: CReal
15:31:08 <FunctorSalad> EmielRegis: to your question to ddarius ;)
15:31:15 <geezusfreeek> > let fib n = ((((1 + sqrt 5) / 2) ** n) - (((1 - sqrt 5) / 2) ** n))/sqrt 5 in map fib [1..] :: [CReal]
15:31:16 <lambdabot>   [* Exception: log of negative number
15:31:50 <EmielRegis> FunctorSalad, well Im not exactly interested in speed, rather the actual algorithm :D
15:32:06 <idnar> log??
15:32:19 <geezusfreeek> i guess in the implementation of CReal
15:32:38 <mapreduce> > sqrt (-2) :: CReal
15:32:38 <vixey> > log (-1)
15:32:41 <lambdabot>   NaN
15:32:42 <FunctorSalad> geezusfreeek: the matrix version only needs integers, should be faster I think
15:32:49 <vixey> > sqrt (-2) :: Complex CReal
15:32:51 <lambdabot>   0.0 :+ 1.4142135623730950488016887242096980785697
15:32:53 <lambdabot>   thread killed
15:33:09 <ziman> > log (-1) :: Complex CReal
15:33:10 <lambdabot>   0.0 :+ 3.1415926535897932384626433832795028841972
15:33:17 <geezusfreeek> > let fib n = ((((1 + sqrt 5) / 2) ** n) - (((1 - sqrt 5) / 2) ** n))/sqrt 5 in map fib [1..] :: [Complex CReal]
15:33:19 <lambdabot>       No instance for (Enum (Complex CReal))
15:33:19 <lambdabot>        arising from the arithmet...
15:33:23 <geezusfreeek> heh
15:33:31 <FunctorSalad> EmielRegis: I described how to exponentiate the matrix quickly, I assumed reduction to the matrix exponentation was already discussed
15:33:43 <vixey> use diagonalization
15:35:30 <jkramar> FunctorSalad: assuming arithmetic on Integers to take constant time is strange. fib n has on the order of n digits, so by definition you can't compute it in less than linear time
15:35:41 <jkramar> you can't even output it in less than linear time
15:35:53 <jkramar> all you can do in logtime is approximate with floats
15:36:12 <jkramar> but that's just floating-point exponentiation anyways
15:38:42 <FunctorSalad> jkramar: good point
15:38:45 <EmielRegis> http://images.gamedev.net/columns/hardcore/hdrrendering/Image2-HDRprocess.jpg <-- would anyone know why downsampling?
15:38:57 <lambdabot> http://tinyurl.com/6xajpf
15:39:05 <FunctorSalad> it'd only be log n if you somehow keep the length of the integers constant
15:39:07 <ddarius> EmielRegis: It's blurring.
15:39:23 <jkramar> for instance if you're computing mod something
15:39:23 <EmielRegis> ah
15:40:10 <EmielRegis> so would downsampling by two mean that each two pixels are averaged to one?
15:40:18 <ddarius> EmielRegis: The Tone Map operator is the part that reduces the dynamic range.  There is no single tone map operator.  The are many different kinds for different uses.
15:41:34 <jkramar> FunctorSalad: I guess it would actually take nlogn time with FFT-multiplication
15:41:54 <vixey> jkramar, what's FFT-multiplication?
15:42:43 <Pseudonym> vixey: You know that multiplication of large integers isn't constant-time, right?
15:42:53 <Pseudonym> The naive algorithm is O(mn).
15:43:04 <ddarius> s/large/arbitrarily large
15:43:10 <vixey> yes
15:43:26 <Pseudonym> vixey: FFT multiplication is a faster algorithm for large integers.
15:43:34 <Pseudonym> O(n log n) if the two numbers are of comparable size.
15:43:57 <Pseudonym> Example.
15:44:07 <Pseudonym> > foldl' (*) 1 [1..1000000] `seq` ()
15:44:23 <lambdabot>   thread killed
15:44:24 <jkramar> whee, Haskell Integers, which are implemented by GMP, use FFT for multiplication when the numbers get big enough
15:44:30 <Pseudonym> That takes a long time.
15:44:32 <Pseudonym> Too long, in fact.
15:45:07 <vixey> this algorithm gives the exactly correct answer/
15:45:08 <vixey> ?
15:45:09 <neurogeek> hello guys.. anyone care to point me to a pretty-print library in haskell?
15:45:11 <Pseudonym> > let { p x 0 = 1; p x 1 = x; p x 2 = x*(x+1); p x n = let n2 = n `div` 2 in p x n2 * p (x+n2) (n-n2) } in p 1 1000000
15:45:16 <Pseudonym> vixey: Yes.
15:45:22 <vixey> and how does it work?
15:45:26 <lambdabot>   thread killed
15:45:29 <geezusfreeek> > foldl' (*) 1 [1..1000000] :: Integer
15:45:29 <Pseudonym> Hmm.
15:45:40 <Pseudonym> > let { p x 0 = 1; p x 1 = x; p x 2 = x*(x+1); p x n = let n2 = n `div` 2 in p x n2 * p (x+n2) (n-n2) } in p 1 100000
15:45:44 <lambdabot>   thread killed
15:45:46 <lambdabot>   282422940796034787429342157802453551847749492609122485057891808654297795090...
15:45:48 <Pseudonym> OK.
15:45:56 <jkramar> AFAIK, anyway... re: GMP-Haskell
15:46:10 <geezusfreeek> > foldl' (*) 1 [1..100000] :: Int
15:46:14 <lambdabot>   0
15:46:17 <geezusfreeek> heh
15:46:19 <Pseudonym> The point being that the reason why the second one returns an answer and the first one doesn't is because the latter multiplies integers of similar magnitude.
15:46:26 <Pseudonym> And hence the FFT algorithm kicks in.
15:46:33 <Pseudonym> vixey: Well, the general idea is this.
15:46:45 <FunctorSalad> vixey: essentially, by using the fact that convolution is just pointwise multiplication in the fourier transform
15:46:53 <FunctorSalad> (being very vague)
15:48:02 <FunctorSalad> the convolution being multiplication of polynomials here (you can write the numbers as polynomials)
15:48:52 <Saizan> neurogeek: http://haskell.org/ghc/docs/latest/html/libraries/pretty/Text-PrettyPrint-HughesPJ.html
15:48:55 <lambdabot> Title: Text.PrettyPrint.HughesPJ, http://tinyurl.com/yv4loq
15:49:24 <Pseudonym> OK, suppose you're multiplying (a1 m - a0) (b1 m + b0)
15:49:32 <Pseudonym> For reasons that will become clear soon.
15:49:52 <Pseudonym> Erm... no, that's not quite it.
15:50:19 <mauke> Lost in Transformation
15:50:30 <FunctorSalad> vixey: sorry if I'm not making any sense, was presuming the fourier transform
15:51:32 <neurogeek> thanks Saizan, do you know some place I can read on how to use it?
15:51:56 <Pseudonym> Right.  THe idea is that you can think of a number as a polynomial in some base.
15:52:09 <Pseudonym> an b^n + ... + a1 b + a0
15:52:19 <Pseudonym> b is the radix of the representation.
15:52:29 <Pseudonym> So it might be 2^32 on a 32-bit machine, for example.
15:52:58 <vixey> alright
15:53:13 <Pseudonym> Now, supose that you've got two numbers of comparable magnitude.
15:53:43 <Pseudonym> (a1 m^2n + a0) and (b1 m^2n + b0)
15:54:33 <Pseudonym> THen if 2c is invertible, you can do multiplication in remainder arithmetic.
15:54:39 <vixey> aha
15:54:53 <Pseudonym> First, mod (m^n - c), then mod (m^n + c).
15:55:00 <Pseudonym> And you can reconstruct the product from those two.
15:55:43 <Pseudonym> You can also apply this recursively, except that you need a nontrivial root of unity to do that.
15:56:28 <Pseudonym> You can do that with complex numbers, but GMP uses fancy number theory by finding a root of unity in modular arithmetic.
15:57:03 <Pseudonym> vixey: Sorry, that probably wasn't that helpful, but there's the general idea.
15:57:12 <vixey> no that is
15:57:23 <vixey> I probably will read about it tommorow
15:57:36 <vixey> bye :)
15:57:40 <Pseudonym> ?go bernstein "multidigit multiplication for mathematicians"
15:57:42 <FunctorSalad> cya
15:57:43 <lambdabot> http://cr.yp.to/arith.html
15:57:48 <Pseudonym> Cya.
16:05:27 <desertfox050> hi, im having a little trouble with higher order functions. can you help?
16:05:41 <mauke> depends on the problem
16:05:49 <desertfox050> its to do with sorting
16:06:44 <desertfox050> i have an assignment to sort through a list, and ive to output just the one value
16:07:12 <desertfox050> does haskell do that automatically, or do i have to tell it to output only the one?
16:07:18 <mauke> which one?
16:08:14 <desertfox050> its a list of results from a constituency, and ive to output the number of votes from the winner
16:08:23 <ddarius> main = dwim
16:08:53 <mauke> can I see sample input?
16:09:02 <Lemmih> desertfox050: See 'maximumBy'.
16:09:46 <desertfox050> the sample input would be the name of the party, and the number of votes that they recieved
16:10:05 * dmwit agrees with Lemmih
16:10:09 <mauke> then the solution is flip const
16:10:18 <mauke> > flip const "party" 42
16:10:20 <lambdabot>   42
16:10:23 <jkramar> :)
16:10:26 <desertfox050> ive already got decl :: ConResult -> ConResult
16:10:27 <desertfox050> decl [] = []
16:10:27 <desertfox050> dec1 xs = msortBy test xs
16:10:27 <desertfox050>  where
16:10:27 <desertfox050>    test(Party,Int) = Int
16:10:33 <desertfox050> to sort them into order
16:10:42 <mauke> why sort them?
16:10:54 <desertfox050> thats the first part of the question
16:10:59 <mauke> what question?
16:11:02 <dmwit> :t sortBy
16:11:04 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
16:11:19 <desertfox050> then ive to output the values of the first and second place parties
16:11:59 <dmwit> desertfox050: Well, what have you tried so far?
16:12:15 <jkramar> mauke: his homework question.
16:12:22 <desertfox050> im stumped so far
16:12:40 <desertfox050> im just trying to get it to output one value, instead of the whole list
16:12:52 <dmwit> desertfox050: Perhaps it would be helpful for you to write the type of the function first.
16:12:56 <Lemmih> desertfox050: Have you managed to sort the list?
16:12:59 <desertfox050> and i thought you guys would know if i had to tell haskell to do it
16:13:02 * ddarius watches a movie.
16:13:15 <mauke> is this your first programming language?
16:13:46 <desertfox050> im doing java as well, and i did truebasic at school
16:14:12 <desertfox050> its confusing me doing the two at the one time, becuase they are so different
16:14:56 <desertfox050> lemmih:ive got the sorting part down, its just this part thats confusing
16:15:16 <mauke> :t take 2
16:15:18 <lambdabot> forall a. [a] -> [a]
16:15:24 <Lemmih> desertfox050: So the item you want is the last element of the list?
16:15:38 <desertfox050> yeah, the int
16:15:56 <desertfox050> for the first and second entries
16:15:57 <Lemmih> desertfox050: 'last' can give you the last element.
16:16:17 <desertfox050> right, ill try that, you guys have been a big help!
16:16:40 <travisbrady> would anyone mind giving me some pointers with this http://hpaste.org/12210 ?
16:17:54 <explicitjelly> is there something like hoogle for SML?
16:18:12 <EmielRegis> can you have a Data.Map with a tuple for its key?
16:18:18 <mauke> EmielRegis: yes
16:18:28 <EmielRegis> how do you define its output?
16:18:35 <EmielRegis> (Map.Map (Int,Int) ColourT)
16:18:37 <EmielRegis> doesnt work :(
16:19:22 <mauke> > let a = [0 .. 4] in map (\x -> map (x -) a) a
16:19:23 <lambdabot>   [[0,-1,-2,-3,-4],[1,0,-1,-2,-3],[2,1,0,-1,-2],[3,2,1,0,-1],[4,3,2,1,0]]
16:19:26 <travisbrady> EmielRegis: i thought of that, but i also want to know how to do this just to know
16:19:28 <Lemmih> travisbrady: [[ (x-y) | y <- [1..5]] | x <- [1..5]] ?
16:19:33 <mauke> is this how it's supposed to work?
16:20:07 <travisbrady> mauke: yes, looks like it
16:20:26 <Lemmih> EmielRegis: Why doesn't it work?
16:20:37 <travisbrady> > [[ (x-y) | y <- [1..5]] | x <- [1..5]]
16:20:39 <lambdabot>   [[0,-1,-2,-3,-4],[1,0,-1,-2,-3],[2,1,0,-1,-2],[3,2,1,0,-1],[4,3,2,1,0]]
16:20:57 <mauke> @undo [[ (x-y) | y <- [1..5]] | x <- [1..5]]
16:20:57 <lambdabot> concatMap (\ x -> [concatMap (\ y -> [(x - y)]) [1 .. 5]]) [1 .. 5]
16:21:11 <EmielRegis> well
16:21:22 <EmielRegis> i got a subroutine, which accepts same type of map
16:21:30 <EmielRegis> and it doesnt accept Map.empty for some reason
16:21:45 <Lemmih> EmielRegis: Why not?
16:21:55 <mauke> your description is confusing; show actual errors and code
16:22:03 <Lemmih> (It's an error message I'm looking for)
16:22:53 <pumpkin> is there a good, established graph library for haskell?
16:23:30 <pumpkin> something that supports arbitrary node types, edge labels, traversal algorithms, and such?
16:25:25 <EmielRegis> ok nvm, it was wrong parenthesis placement ;)
16:25:42 <Axman6> wait, list comprehensions are dos?
16:25:55 <Axman6> that sentence felt terrible -_-
16:25:57 <travisbrady> @undo [(x, y) | x <- [1..5], y <- [1..5]]
16:25:58 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [1 .. 5]) [1 .. 5]
16:26:02 <mauke> ms dos
16:26:35 <mauke> > do { x <- [1..5]; do { y <- [1 .. 5]; return (x-y) } }
16:26:36 <lambdabot>   [0,-1,-2,-3,-4,1,0,-1,-2,-3,2,1,0,-1,-2,3,2,1,0,-1,4,3,2,1,0]
16:26:50 <mauke> > do { x <- [1..5]; return $ do { y <- [1 .. 5]; return (x-y) } }
16:26:51 <lambdabot>   [[0,-1,-2,-3,-4],[1,0,-1,-2,-3],[2,1,0,-1,-2],[3,2,1,0,-1],[4,3,2,1,0]]
16:37:00 <Plouj> @pl func4 l = map (\y -> y+2)
16:37:00 <lambdabot> func4 = const (map (2 +))
16:37:11 <Plouj> @pl func4 l = map (\y -> y+2) (filter (\z -> z `elem` [1..10]) (5:l))
16:37:11 <lambdabot> func4 = map (2 +) . filter (`elem` [1..10]) . (5 :)
16:37:18 <Plouj> wow, neat
16:37:22 <Plouj> I mean, literally
16:37:33 <Plouj> @pl func2 = (. map). (.) . filter
16:37:33 <lambdabot> func2 = (. map) . (.) . filter
16:37:48 <Plouj> @pl func2 f g l = filter f (map g l)
16:37:48 <lambdabot> func2 = (. map) . (.) . filter
16:37:53 <ivanm> @unpl map (2 +) . filter (`elem` [1..10]) . (5 :)
16:37:53 <lambdabot> (\ f -> map (\ a -> 2 + a) (filter (\ b -> elem b ([1 .. 10])) (5 : f)))
16:38:02 <Plouj> @pl func1 x l = map (\y -> y*x) l
16:38:02 <lambdabot> func1 = map . (*)
16:39:02 <leimy> ugh
16:39:09 <leimy> sometimes I wish I could escape IO :-)
16:39:31 <geezusfreeek> you can
16:39:50 <Lemmih> geezusfreeek: Shh.
16:40:04 <leimy> heh
16:40:32 <ivanm> unsafely, of course
16:40:46 <geezusfreeek> evil can still be controlled
16:40:47 <leimy> right
16:40:52 <leimy> It's already IO
16:40:57 <leimy> it's already fairly unsafe :-)
16:41:25 <Riastradh> You can escape IO...and face the nasally demonic consequences.
16:41:32 <leimy> heh
16:41:45 <mauke> I escape IO with >>=
16:41:54 <leimy> mauke: you're the devil!
16:41:58 <ivanm> Riastradh: nasally?
16:42:02 <Riastradh> (Undefined behaviour gives demons nose colds.  They really hate when their sinuses get stuffy and their voices cease to boom as heavily.)
16:42:14 <ivanm> O...K... then...
16:42:20 <geezusfreeek> the only times i ever want to escape IO anymore are when i'm doing something that is already nasty as it is
16:42:21 * ivanm passes Riastradh a hanky
16:42:37 <Riastradh> ivanm, a joke on nasal demons, which are the canonical consequence of undefined behavioour -- demons flying out of one's nose.
16:42:38 <mauke> ivanm: http://everything2.com/e2node/nasal%2520demons
16:42:43 <lambdabot> Title: nasal demons@Everything2.com
16:43:14 <ivanm> oh, OK
16:43:24 <leimy> unsafePerformIO
16:44:10 <mauke> wat = return . unsafePerformIO
16:44:25 <geezusfreeek> Repeat after me: "unsafePerformIO is not a design technique."
16:45:25 <leimy> My program is going to end up living in IO anyway at this point I suppose
16:45:29 <leimy> it's all interactive and whatnot.
16:45:36 <geezusfreeek> leimy, what is it you are doing?
16:45:41 <leimy> something evil
16:45:54 <geezusfreeek> io-ridden programs may be good candidates for frp
16:46:00 <leimy> hmmm
16:46:08 <Riastradh> Doing hash, leimy?
16:46:08 <leimy> well actually FRP may make sense, but I'm not aware of it's glory
16:46:17 * Riastradh thwaps.
16:46:19 <leimy> Riastradh: not at the moment
16:46:34 <leimy> I'm actually trying to write an interactive bowling score card
16:46:41 <leimy> and the rules for bowling suck ass :-)
16:47:04 <leimy> I've got a function using Continuations that bails out early if you get strikes in the not 10th frame :-)
16:47:08 <ivanm> I seem to recall seeing a (ten-pin) bowling scoring programme...
16:47:12 <leimy> there is one
16:47:15 <leimy> for the whole 10 pins
16:47:18 <leimy> but I want live updates
16:47:19 <ivanm> ahhh
16:47:19 <leimy> :-)
16:47:32 <leimy> the 10 pin one is pretty impressive :-)
16:47:47 <geezusfreeek> yeah, that does sound like a good candidate for frp i think
16:48:11 <geezusfreeek> you could just have each cell be an event that automatically updates as other cells are filled, like a spreadsheet
16:48:27 <leimy> I was originally imagining some kind of finite state machine for frame scoring, where I'd build a new closure and pass it in.
16:48:35 <leimy> but then types bit me in the ass
16:48:36 <leimy> :-)
16:49:12 <leimy> I wrote a function (pair of functions) that can produce a frame of bowling
16:49:33 <leimy> and it takes an integer parameter for the frame number so it can handle the 10th frame.
16:49:57 <leimy> Strikes are like exceptions
16:50:11 <leimy> for all frames but the 10th
16:50:32 <leimy> I've probably been thinking about it too long...
16:58:08 <eu-prleu-peupeu> hello Hppl
17:03:01 <the_unmaker> thinking is never good
17:03:34 <leimy> nope
17:29:50 <mcnster> q: is Array or IArray more space efficient than Lists?
17:30:28 <Axman6> they're designed for different things i believe
17:30:33 <Lemmih> mcnster: Yes.
17:31:14 <mcnster> Lemmih, ok.  further is Array or IArray more space efficient?
17:31:30 <Lemmih> mcnster: What?
17:32:30 <Riastradh> `Between Array and IArray, which is more space efficient?', perhaps.
17:32:42 <Lemmih> mcnster: IArray is a class.
17:33:13 <mcnster> Lemmih, whups :) i'm reading the docs in a text browser... didn't realize that
17:33:38 <Lemmih> mcnster: UArray is more efficient than Array.
17:34:21 <mcnster> lemmih, i will look at Array and UArray then.  thanks much :)
17:59:54 * gwern despairs of ever getting gitit to work. I can't handle these multi-hour linkings!
18:00:51 <Lemmih> What platform are you on?
18:01:34 <gwern> x86_64, 6.8.2, 4 gigs of ram
18:01:39 <gwern> intrepid ubuntu
18:02:49 <Lemmih> gwern: Weird, I'm on the same hardware and linking only takes seconds.
18:03:08 <gwern> are you using the highlighting-kate stuff?
18:03:28 <Lemmih> Yeah.
18:03:47 <the_unmaker> is there a haskell editor yet?
18:03:54 <the_unmaker> like hask-macs?
18:04:00 <Axman6> yi
18:04:04 <gwern> I see the linker ld taking up to 80% of ram in top, and many hours
18:04:07 <gwern> or leksah
18:04:23 <gwern> Lemmih: same ghc?
18:04:33 <Lemmih> gwern: Nah, ghc-6.10 here.
18:05:14 <gwern> perhaps that is it
18:06:31 <gwern> my kingdom for 6.10 debs!
18:06:37 <neurogeek> Hi.. can somebody please point me to a howto on using pretty print (HughesPJ)? please!!
18:07:54 <the_unmaker> yi looks like non gui eh?
18:08:08 <gwern> it has cocoa nad gtk guis
18:08:30 <the_unmaker> http://haskell.org/sitewiki/images/a/a5/Screenshot0.png this looks all fancy
18:08:50 <Lemmih> neurogeek: The haddock documentation isn't good enough?
18:09:37 <gwern> I've heard leksah is nice
18:10:42 <neurogeek> Lemmih, im a total n00b to haskell.. I was hoping for examples
18:11:18 <Lemmih> neurogeek: I suggest playing around with the library in GHCi.
18:11:42 <neurogeek> thanks Lemmih
18:12:25 <gwern> :( leksah fails cabal-install
18:13:03 <gwern> ick. obscure type class errors
18:18:11 <dmwit> This is awesome!
18:18:22 <dmwit> Pop in the ArchLinux LiveCD, and my options are (paraphrased):
18:18:22 <FunctorSalad> hmm... the class heirarchy problem again: could we implement superclass defaulting with TH?
18:18:24 <dmwit> 1. Linux
18:18:30 <dmwit> 2. Linux (legacy IDE)
18:18:34 <dmwit> 3. Space Invaders!!!
18:19:00 <FunctorSalad> aptitude has minesweeper though
18:19:03 <Axman6> arch ftw
18:19:11 <Axman6> the only distro i will tollerate
18:19:41 <dmwit> AND IT'S ASCIIGRAPHICS
18:19:44 <dmwit> awesome
18:20:45 <p_l> FunctorSalad: And Excel has a flight simulator, so what? :P
18:24:26 <dmwit> Hey, OOCalc has StarWars.
18:26:56 <Saizan> FunctorSalad: like $(instanceSemiGroupGivenGroup ''MyType) ?
18:28:19 <FunctorSalad> Saizan: yes
18:28:43 <FunctorSalad> or wait
18:28:52 <Saizan> in that case yes
18:29:25 <FunctorSalad> more like $(instanceGroup ''MyType mult inv neut)
18:29:41 <FunctorSalad> which expands to a Semigroup instance and a Group instance
18:29:48 <FunctorSalad> with Semigroup being a superclass of Group
18:31:27 <Saizan> it looks less modular, however you can do it if you quote mult, inv and neut
18:32:11 <FunctorSalad> Saizan: it is supposed to solve the problem that if the user wants to declare a Group, he doesn't have to know about semigroups and monoids
18:32:28 <FunctorSalad> in this case we have class SemiGroup g => Monoid g, and so on
18:32:53 <Saizan> ah, i see
18:33:35 <FunctorSalad> so wrapping a group into a SemiGroupFromGroup is avoided
18:34:25 <Saizan> my first macro would have avoided that too, letting you define the Group instance separately
18:34:55 <Saizan> but it requires one more line to declare that you want the SemiGroup instance
18:35:23 <FunctorSalad> the Group class doesn't have a multiplication though
18:35:50 <FunctorSalad> so the Group instance would not contain all three operations as the user would expect
18:36:36 <FunctorSalad> (the multiplication is a method of Semigroup)
18:37:36 <Saizan> ah, i hadn't thought of that
18:39:12 <FunctorSalad> it could even be abstracted to $(superInstance ''Group ''MyType 'mult 'inv 'neut), but I'm not that good at TH ;)
18:39:33 <FunctorSalad> (with superInstance analyzing the class hierarchy automatically)
18:41:52 <FunctorSalad> the manual (instanceGroup) variant would be okay and much simpler, I guess
18:42:19 <gwern> how close to -Wall is '-fwarn-unused-imports -fwarn-missing-fields -fwarn-incomplete-patterns'?
18:43:21 <Saizan> how would you map arguments to class methods with superInstance?
18:47:04 <FunctorSalad> Saizan: something like $(superInstance [| instance Group A where mult = ..., inv = ..., ... |]) ?
18:47:23 <FunctorSalad> which is split up over the superclasses then
18:47:51 <FunctorSalad> if that syntax is even valid
18:48:31 <Saizan> yeah, that would work
18:49:30 <Saizan> actually, it looks like the best solution to the "class hierarchy problem" that i've seen proposed :)
18:49:58 <FunctorSalad> cool. maybe I should post it to cafe or so then
18:52:13 <Saizan> uhm, well, we still need a way to specify things like (<*>) = ap
18:53:09 <Axman6> :t ap
18:53:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:53:15 <Saizan> , [d| instance Monad Maybe where (<*>) = ap |] -- is it checked?
18:53:21 <lunabot>  luna: parse error (possibly incorrect indentation)
18:53:34 <Axman6> > ap Nothing (Just 2)
18:53:35 <lambdabot>   Nothing
18:53:35 <Saizan> , [d| instance Monad Maybe where { (<*>) = ap } |] -- is it checked?
18:53:37 <lunabot>  luna: parse error (possibly incorrect indentation)
18:53:41 <Axman6> ah, i see
18:53:49 <Saizan> , [d| instance Monad Maybe where { (<*>) = ap } |]
18:53:51 <lunabot>  luna: `<*>' is not a (visible) method of class `GHC.Base.Monad'
18:54:02 <Saizan> FunctorSalad: won't work :\
18:54:23 <Saizan> i thought TH was more permissive
18:55:36 <FunctorSalad> Saizan: I see
18:56:53 <Saizan> , [d| { bar = undefined; foo = undefined } |]
18:56:57 <lunabot>  ValD (VarP bar) (NormalB (VarE undefined)) []
18:56:57 <lunabot>  ValD (VarP foo) (NormalB (VarE undefined)) []
18:57:06 <FunctorSalad> ah
18:57:47 <Saizan> so something like $(superInstance ''Group ''A [d| mult = ..., inv = ..., ... |])
18:57:57 <FunctorSalad> yes
18:59:04 <FunctorSalad> not sure whether it's worth it compared to $(instanceGroup ...) though
18:59:22 <Axman6> ha, i was about to say someone should ban that guy, seems the staffers got to him first
18:59:27 <FunctorSalad> (going by KISS)
18:59:30 <Plareplane> when can guards be used?  after every pattern match?
19:00:12 <monochrom> haskell is fun
19:00:46 <Lemmih> monochrom: You got cut off after "fun".
19:00:58 <dolio> , [d| instance Monad Maybe where { return = Just ; Nothing >>= f = Nothing ; Just a >>= f = f a } |]
19:00:59 <lunabot>  luna: `return' is not a (visible) method of class `GHC.Base.Monad'
19:01:02 <monochrom> haskell is funny
19:01:18 <shapr> and fun
19:01:20 <dolio> Functional.
19:01:30 <shapr> lambdabot: @botsnack
19:01:30 <lambdabot> :)
19:01:32 <dolio> , [d| instance Monad Maybe where { GHC.Base.return = Just ; Nothing >>= f = Nothing ; Just a >>= f = f a } |]
19:01:33 <lunabot>  luna: Qualified name in function definition: GHC.Base.return
19:01:38 <dolio> Hmm.
19:03:43 <dolio> Color me confused.
19:04:17 * shapr colors outside dolio's lines
19:04:39 <FunctorSalad> it import Monad from GHC.Base but return from Control.Monad?
19:04:39 <dolio> @nixon
19:04:39 <lambdabot> I can take it. The tougher it gets, the cooler I get.
19:04:43 <Saizan> , src ''Monad
19:04:48 <FunctorSalad> *imports
19:04:52 <lunabot>  class Monad m where
19:04:52 <lunabot>          (>>=) :: forall b a . m a -> (a -> m b) -> m b
19:04:52 <lunabot>          (>>) :: forall b a . m a -> m b -> m b
19:05:30 <dolio> I popped open ghci, and I get "`show' is not a (visible) method of class `Show'".
19:05:42 <dolio> Which it is, I'm pretty sure. :)
19:06:06 <FunctorSalad> remember, we need to break haddock soon. maybe that's how they did it?
19:06:27 <wagle> dolio, how did you do that?
19:06:38 <dolio> Do what?
19:06:53 <wagle> get it to emit that error message?
19:07:12 <gwern> very well
19:07:20 <dolio> I typed in [d| instance Show Int where show _ = "" |]
19:07:45 <FunctorSalad> (don't remember if you were around, dolio... was just joking about haddock having ghc < 6.13 as a dependency ;))
19:08:35 <Saizan> dolio: which version?
19:08:54 <dolio> Well, it already depends on a potentially volatile GHC-only library. :)
19:08:59 <dolio> Saizan: 6.10.1.
19:09:09 <dons> hehe, http://www.reddit.com/r/programming/comments/7ehr3/trying_to_learn_f_without_knowing_haskell_is_like/
19:09:15 <lambdabot> Title: "Trying to learn F# without knowing Haskell is like trying to learn VB without k ..., http://tinyurl.com/68pn49
19:09:35 <Saizan> dolio: i get duplicate instance declaration with that code
19:09:40 <wagle> this is a 6.10.1 thing?  (6.8.3 here)
19:09:45 <dolio> Same thing happens in 6.8.3, though.
19:10:25 <wagle> i typed [d| instance Show Int where show _ = "" |] into ghci, and it said <interactive>:1:4: parse error on input `instance'
19:10:37 <BMeph> Wouldn't you have to seriously hack the compiler to get QQs in 6.8.3? :)
19:10:45 <wagle> i was going to declare myself too dense, but..
19:11:11 <Saizan> BMeph: [d| |] is not QQs
19:11:40 <dolio> wagle: Did you start it with -XTemplateHaskell?
19:11:45 <wagle> get trying to jump in and follow..  did you give ghci some option?
19:12:18 <wagle> ok..  got it.
19:12:30 <wagle> i knew the [| stuff looked familier
19:12:38 <wagle> thanks
19:12:44 <dolio> No problem.
19:13:09 <shapr> With 6.8.2 it just says "Duplicate instance declarations"
19:13:54 <dolio> Huh. Weird. I wouldn't expect something like that to change with a 0.0.1 version bump.
19:14:15 <shapr> I started ghci, didd :set -XTemplateHaskell and then [d| instance Show Int where show  _ = "" |]
19:15:26 <lispy> what is an efficient adjacency based representation of a graph in Haskell?
19:15:45 <lispy> Oh, my highest degree is 4
19:16:15 <sjanssen> Map Node [Node], perhaps?
19:16:25 <lispy> data Graph a = Empty | V { value :: a, north :: Graph a, south :: Graph a, east :: Graph a, west :: Graph a} -- but now how will I seralize this if the graph has cycles?
19:16:29 <dmwit> Yeah, probably.  Especially for such a sparse graph.
19:17:03 <dons> lispy: persistent, or effectiful in a monad?
19:17:04 <dmwit> type Graph a = Map Node (a, [Node])
19:17:28 <sjanssen> lispy: is the value unique for each element?
19:17:56 <sjanssen> ie. is it a key or some such?
19:17:57 <lispy> dons: I think eithere of those is fine.  I may want to update it once in a while, but I think I can do the updates in a State monad and be fine
19:17:58 <Saizan> dolio: oh, on 6.10.1 a fresh ghci gives `show' is not a (visible) method of class `Show', but if i load a module (even empty) i get duplicate instance declarations
19:18:15 <lispy> sjanssen: no, values can be repeated
19:18:33 <dons> lispy: using ST + STUArrays would be nice if you wrapped it up as say, a 'G' monad
19:18:48 <sjanssen> Arrays sounds like overkill here
19:18:52 <lispy> dons: storing it as an adjacency matrix?
19:19:07 <lispy> I think the matrix version would be very sparse
19:19:08 <dons> yeah. using a standard graph reprepresntation
19:19:20 <lispy> because I have at most degree 4
19:19:38 <dolio> Saizan: You mean if you write some module Foo and load it? I loaded Data.List and it didn't seem to change anything.
19:19:57 <lispy> dmwit: in your example, type Graph a = Map Node (a, [Node]), is Node really type Node = Int, ?
19:20:00 <sjanssen> type Graph a = Map Node (a, Node, Node, Node, Node) -- this is what I'd use, lispy
19:20:06 <dmwit> lispy: Sure.
19:20:22 <dolio> Saizan: I see. 'ghci -XTemplateHaskell Foo.hs' gives me the behavior you describe.
19:20:31 <sjanssen> lispy: you'll need to lable your nodes if you want to detect cycles
19:20:32 <lispy> dmwit: That was poorly phrased on my part...what I meant was, the Node is a unique name?
19:20:39 <Saizan> dolio: yeah, something interpreted
19:20:43 <dmwit> lispy: definitely
19:21:06 <dolio> Weird stuff.
19:21:06 <lispy> data Node = Empty | Id Int -- this could work
19:21:15 <dmwit> lispy: The value of type Node need not have any relationship at all to the value at the node in the graph, if that makes sense.
19:21:27 <lispy> dmwit: gotcha
19:21:30 <dolio> Saizan: Oh, i guess loading a module loads base and such, which is probably what does it.
19:21:49 <Saizan> dolio: yeah
19:21:50 <dolio> Loading an interpreted one, that is.
19:21:55 <sjanssen> lispy: actually, I think you want to stick with type Node = Int
19:21:59 <lispy> sjanssen: I'd rather not have to detect cycles but I do know one efficient algo for it...
19:22:03 <mwc> Anybody know anything about creating custom parsec Stream instances? I'm a little unclear on the wording of the second requirement, 'A Stream instance is responsible for maintaining the "position within the stream" in the stream state s. This is trivial unless you are using the monad in a non-trivial way.' Does this mean that do { Just (a,_) <- uncons s; Just (b, _) <- uncons s; a == b} is always equivalent to return true?
19:22:07 <dmwit> lispy: I've used this structure successfully for some NFA/DFA/transducer stuff, it's pretty easy to deal with.
19:22:13 <mwc> (neglecting the Nothing cases of course)
19:22:14 <lispy> sjanssen: well, some nodes have degree < 4
19:22:30 <sjanssen> type MNode = Maybe Node; type Graph a = Map Node (a, MNode, MNode, MNode, MNode)
19:22:30 <lispy> sjanssen: so then I'd modify your last suggestion to be Maybe Node ?
19:22:34 <sjanssen> lispy: yeah
19:23:10 <Saizan> you could use System.Mem.StableName to cheat and get something like pointer equality
19:23:23 <sjanssen> Saizan: ewww
19:23:54 <DrSyzygy> !shae
19:24:03 <ski_> (`..; guard (a == b)')
19:24:05 <lispy> sjanssen: and serializing that last time should just be toList on the Map...not bad
19:24:14 <DrSyzygy> Hmmm. How did you call for shae again?
19:24:17 <lispy> last type*
19:24:18 <dmwit> ?get-shapr
19:24:19 <lambdabot> shapr!!
19:24:25 <DrSyzygy> That's how. Thanks.
19:24:30 <monochrom> ...
19:24:53 <sjanssen> lispy: you can also just serialize the Map
19:24:54 <DrSyzygy> monochrom: Didn't you know? shapr has his own ordering service built into lambdabot.
19:24:58 <lispy> This makes me wonder, do we have an STMap ?
19:25:04 <Pseudonym> ?get-dmwit
19:25:04 <lambdabot> Unknown command, try @list
19:25:07 <lispy> we have STArray...
19:25:10 <Pseudonym> That should be generic.
19:25:17 <monochrom> Yeah but it's a round-about way of doing a simple thing.
19:25:24 <dmwit> Pseudonym: Here I am!
19:25:27 <DrSyzygy> Pseudonym: It's much cooler to have it shapr specific.
19:25:30 <lispy> sjanssen: oh?  it has a Show instance or something?
19:25:33 <sjanssen> lispy: no, just use STRef Map (or better yet, use State if you can)
19:25:41 <sjanssen> lispy: sure, Map has a Show instance
19:25:55 <sjanssen> and a Binary instance
19:26:06 <sjanssen> any serialization library should have an instance for Map
19:26:23 <lispy> sjanssen: in my case I'll most likely be using State and not ST, but I just wondered about an STMap that lets you update the individual mappings.  Not something I need no.
19:26:30 <Pseudonym> DrSyzygy: Perhaps, but I'm thinking of utility.
19:26:36 <Pseudonym> I guess a dons one would be useful.
19:26:56 <sjanssen> @get-ops
19:26:56 <lambdabot> Unknown command, try @list
19:27:01 <sjanssen> @where ops
19:27:01 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
19:27:13 <dolio> Heh, that'll be appreciated.
19:27:21 * lispy kicks sjanssen 
19:27:28 <lispy> ;)
19:28:29 <Cale> You can also get a list of ops from chanserv
19:28:52 <allbery_b> meep?
19:29:04 <sjanssen> allbery_b: sorry
19:29:15 * sjanssen shouldn't have done that
19:29:15 <te> hello folks
19:29:23 <dmwit> Hiya, te!
19:29:49 <te> dmwit: !
19:30:00 <te> the first three letters of your nick happen to be my initials
19:30:36 <Axman6> Dave Matthews Wins?
19:31:20 <neurogeek> Lemmih, thanks a lot, I know how to use HughesPJ now :D
19:31:28 <gnut> hello
19:31:37 <gnut> has anyone tried ghc on a PS3?
19:31:49 <Lemmih> neurogeek: Yay (:
19:31:51 <dmwit> te: What a coincidence, they're my initials too! ;-)
19:32:28 <lispy> Lemmih: any news on the jhc hackage effort?
19:32:36 <gnut> I tried to build ghc 6.10.1 on solaris x86, and it worked.
19:33:03 <gnut> I tried to build 6.10.1 with extralibs on solaris x86, and it didn't work. something about no GNUmakefile found when it was working on dph-prim-seq
19:34:08 <Lemmih> lispy: I still haven't heard from John. There's still quite a lot of work to be done before lhc will play well with cabal-install.
19:35:23 <lispy> Lemmih: Random idea...if you're having trouble getting cabal to do stuff, you could steal code from franchise and contribute it to cabal they have compatible licenses
19:35:41 <Lemmih> lispy: Franchise?
19:35:56 <lispy> Lemmih: the anti-cabal effort that both droundy and John think is better
19:36:28 <lispy> Lemmih:  http://groups.google.com/group/franchise-haskell
19:36:29 <lambdabot> Title: franchise | Google Groups
19:37:00 <lispy> Lemmih: heh, what do you know, John has been looking into franchise: http://groups.google.com/group/franchise-haskell/browse_thread/thread/f05fd3aee5777095
19:37:01 <lambdabot> Title: jhc and franchise? - franchise | Google Groups, http://tinyurl.com/63ka22
19:39:11 <lispy> Lemmih: duncan has acknowldged that some of the features of franchise would be useful and welcome in Cabal.  If someone ported those things, then there would be even less reason for the community to be developing two different build systems.
19:40:06 <gwern> I dunno if we could really call franchise part of the community yet
19:40:08 <Lemmih> lispy: I don't need anything that complicated.
19:40:22 <gwern> I don't think it's even be mentioned anywhere besides the darcs lists
19:40:34 <dmwit> I didn't even know about franchise.
19:40:37 <lispy> gwern: no but I do worry that it could catch on for the kinds of applications that cabal struggles with.
19:40:52 <dmwit> Does any project use it as their build system?
19:41:24 <lispy> gwern: and honestly, I just wish franchise would disappear or become just a replementation in haskell of configure.  But having it be yet another build/distribution system seems like such a waste.
19:41:32 <lispy> dmwit: franchise uses franchise
19:41:42 <dmwit> Well, right.
19:42:07 <lispy> the franchise group lists, franchise, Shsh and darcs, but darcs no longer uses franchise
19:42:08 <Lemmih> Franchise exclude you from hackage and cabal-install, no?
19:42:51 <lispy> Lemmih: hackage no, as it can generate a .cabal file, cabal-install not really because you could name the franchise file Franchise.hs instead of Setup.hs
19:43:07 <lispy> Lemmih: but the auto generted .cabal file probably won't work correctly
19:43:08 <roconnor> sweet a new issue of The.Monad.Reader!
19:43:13 <roconnor> topic anyone?
19:43:17 <roconnor> @where-ops
19:43:17 <lambdabot> Unknown command, try @list
19:43:29 <ddarius> Foiled by a hyphen.
19:43:59 <ddarius> lispy allegedly is an op
19:44:13 <dmwit> roconnor: Has it hit haskkit yet?  If not, it needs to... ;-)
19:44:23 <lispy> Lemmih: IMO the useful bits of franchise is that it might make building C bits easier and it might make it easier to make your .cabal file.  The rest of it seems like misplaced effort
19:44:29 <roconnor> waht is haskkit?
19:44:34 <dmwit> haskell.reddit.com
19:44:35 <lispy> roconnor: what do you want the topic to say?
19:44:39 <roconnor> oh right
19:44:42 <gwern> roconnor can haskkit?
19:44:46 <DrSyzygy> There is a haskkit??
19:45:05 <lispy> ?where+ haskkit http://haskell.reddit.com
19:45:05 <lambdabot> It is stored.
19:45:18 <roconnor> lispy: something about TRM Issue 12 and a link to either http://www.haskell.org/sitewiki/images/f/f0/TMR-Issue12.pdf or http://www.haskell.org/haskellwiki/The_Monad.Reader?issue12
19:45:20 <lambdabot> Title: cache:http://www.haskell.org/sitewiki/images/f/f0/TMR-Issue12.pdf - Google Searc ...
19:45:50 <roconnor> dmwit: I found out about the issue from haskkit
19:45:51 <ddarius> David and John want to take over the entire Haskell toolchain.
19:46:02 <ddarius> Vertical monopoly is where it is at.
19:46:07 <lispy> chanserv is ignoring me...hmm
19:46:15 <dmwit> Well, I for one support our new vertical overlords.
19:46:37 --- mode: ChanServ set +o lispy
19:46:51 <lispy> ?list
19:46:51 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:46:57 <gwern> ddarius: my god. first the revision control, then the compiler, then the build system - where does it stop?
19:47:11 <roconnor> where is my HIDE?
19:47:18 <dmwit> Yeah!
19:47:22 <lispy> ?topic-cons http://www.haskell.org/haskellwiki/The_Monad.Reader?issue12
19:47:22 <dmwit> Shim!
19:47:22 <lambdabot> I do not know the channel http://www.haskell.org/haskellwiki/The_Monad.Reader?issue12
19:47:23 <gwern> could they be conspiring with the authors of House/HoP?
19:47:27 <dmwit> Yi!
19:47:30 <dmwit> Leksah!
19:47:31 <lispy> ?topic-cons #haskell http://www.haskell.org/haskellwiki/The_Monad.Reader?issue12
19:47:51 <DrSyzygy> Läxa
19:48:04 <Lemmih> lispy: I just got a response from John.
19:48:12 <lispy> I may be a channel op, but Idon't thnk lambdabot will let me cons
19:48:30 <gwern> well, dish
19:48:30 <ddarius> lambdabot doesn't decide
19:48:38 --- topic: set to '["TMR #12 http://www.haskell.org/haskellwiki/The_Monad.Reader?issue12", "GHC 6.10 is out! - http://twurl.cc/6wr", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by lispy
19:48:43 <gwern> ?topic-cons http://www.haskell.org/haskellwiki/The_Monad.Reader?issue12
19:48:43 <lambdabot> I do not know the channel http://www.haskell.org/haskellwiki/The_Monad.Reader?issue12
19:48:51 <gwern> ?topic-cons haskell http://www.haskell.org/haskellwiki/The_Monad.Reader?issue12
19:48:51 <lambdabot> I do not know the channel haskell
19:48:59 <gwern> fine, be that way
19:49:05 <lispy> roconnor: look good?
19:49:09 <ddarius> gwern: lambdabot doesn't have permissions
19:49:18 <lispy> roconnor: I'll de-op if you lke it :)
19:49:36 <lispy> Lemmih: yeah?
19:49:42 --- mode: ChanServ set +o lispy
19:49:48 <lispy> er
19:50:07 <Axman6> heh
19:50:11 --- mode: ChanServ set -o lispy
19:50:15 <ddarius> lispy is trying to stack smash the op bit
19:50:22 <lispy> :)
19:50:43 <Lemmih> lispy: I'll have to fork jhc. He's extremely opposed to cabal.
19:51:01 <gwern> Lemmih: so your patches were summarily rejected?
19:51:04 <lispy> Lemmih: Are you sure?
19:51:15 <lispy> Lemmih: there is no middle ground?
19:51:19 <Axman6> bah
19:51:33 <Axman6> why does he not like cabal?
19:52:03 <gwern> Axman6: philosophical differences
19:52:06 <Lemmih> gwern, lispy: He seems pretty definite. I'll try to jiggle him some more.
19:52:26 <gwern> any entertaining rhetoric?
19:52:28 <Axman6> Lemmih: you up to merging any changes he makes?
19:52:29 <roconnor> lispy: looks good
19:53:05 <roconnor> Lemmih: forking is good!
19:53:14 * roconnor <3 forks
19:53:23 <sjanssen> roconnor: why?
19:53:24 <Lemmih> Axman6: Oh yes, absolutely. As long as he doesn't just rollback my patches (:
19:53:44 <Axman6> Lemmih: well, i meant merging his patches into yours
19:53:48 <roconnor> sjanssen: I think choice is usually a good thing
19:53:52 <roconnor> not always, but usually
19:55:27 <roconnor> Certainly consensus is better than forking
19:55:32 <lispy> My view is that the pressure that a potential fork creates is good, but that most forks are poorly executed
19:55:49 <lispy> and when you do fork, try to do it so that you can share patches
19:55:56 <roconnor> but often forking is better than compormise, when the cost of forking is low.
19:56:04 <lispy> eventually, if your fork is better, it could become HEAD again
19:56:33 <roconnor> dvcs seem to do a great job at lowering the cost of forking
19:56:52 <sjanssen> roconnor: VCS only lowers the superficial costs of forking
19:57:08 <sjanssen> you still have to build a community around the forked project
19:57:22 <monochrom> steal, don't build.
19:57:29 <gwern> sjanssen: don't bother. I had this exact same argument with roconnor last night
19:57:47 <gwern> right down to your observation that dvcs helps with the technical aspects of the fork but not the social
19:58:15 <Saizan> does JHC have a "community" ?
19:58:16 <monochrom> sheldon's psychohistory has it all worked out.  *duck*
19:58:24 <roconnor> :)
19:58:29 <sjanssen> monochrom: that sounds more like a junta than a fork :)
19:58:51 <gwern> monochrom: I think it was seldon, no h
19:58:53 <sjanssen> Saizan: presumably it has hackers that work on the project
19:59:10 <monochrom> oops
19:59:15 <roconnor> I understand sjanssen and gwern's view.  I don't agree that the social costs are that high, but I could be wrong, and do take your views under consideration.
19:59:41 <gwern> monochrom: see https://secure.wikimedia.org/wikipedia/en/wiki/Hari_Seldon :)
19:59:43 <roconnor> meaning I'll be on the lookout to see if social costs of forking is higher than I thought.
20:00:01 <dmwit> 2^20
20:00:02 <roconnor> Too bad we don't have a lot of examples of dvcs forking to learn from.
20:00:04 <dmwit> > 2^20
20:00:05 <lambdabot>   1048576
20:00:59 <roconnor> I actually more fear that dvcs, as they are now, don't lower the technical bar as much as they need to.
20:01:07 <dmwit> > 2^17
20:01:09 <lambdabot>   131072
20:01:20 <Lemmih> Saizan: There hasn't been any jhc development for months.
20:02:49 <Saizan> so i guess a cabalization and some commentary or devel roadmap could create a community
20:03:25 <lispy> Lemmih: have you read "Producing Open Source Software" ? It's available on the web and has very good advice
20:03:27 <Lemmih> Saizan: The ability to compile other packages than 'base' might also help.
20:03:46 <lispy> Lemmih: http://producingoss.com/en/index.html
20:03:51 <lambdabot> Title: Producing Open Source Software
20:04:05 <lispy> Lemmih: it has advice on how/when to create a fork, how to grow the community, etc.
20:04:37 <monochrom> Advice #34: make babies to grow a community
20:05:00 <lispy> monochrom: heh, Heffalump has been doing that for us in #darcs :)
20:05:39 <monochrom> Nice. Then Advices #0-#33 will be on how to get someone to make babies with you.
20:06:32 <lispy> I need this baby in a month, quick bring me 9 women!
20:07:01 * lispy waits for the symbol crash
20:07:43 <Pseudonym> The impossible just happened!
20:07:56 <lispy> Not again!
20:08:00 <Pseudonym> Actually, that's a symbol _table_ crash.
20:08:06 <lispy> My brain just exploded!
20:08:11 <lispy> heh
20:08:12 <pumpkin> :o
20:08:37 <lispy> We should make a lolcats fork of ghc so that all the error messages match lolcats sayings
20:08:47 <lispy> "I can has rigid types?"
20:09:14 <lispy> "Invisible pattern match!"  <-- happens when you don't cover all the pattern cases
20:09:29 <Pseudonym> http://arcanux.org/lambdacats/impossible.jpg
20:09:50 <lispy> "Your syntax has a flavor" <-- happens when you use a syntax extension but forget to turn it on
20:10:07 <lispy> Pseudonym: yeath, that's one of the better lambdacats
20:10:14 <Pseudonym> Types.  Ur doin it rong,
20:11:20 <pumpkin> we need a <adj x> <noun y> is <adj x> somewhere
20:11:27 * Axman6 read that as 'ur doin it ron', and immediately thought of ron jeremy
20:12:08 <monochrom> rigid type is rigid
20:12:27 <pumpkin> rijid?
20:12:54 <lispy> monomorphism restriction is moromorphic
20:12:57 <monochrom> inexhaustive pattern matching is inexhaustive
20:13:01 <pumpkin> lol
20:13:10 <pumpkin> gotta have cute misspellings too though
20:13:25 <Axman6> inhaxorstabl
20:13:26 <dons> "as long as the community stays strong ... I'll continue to follow it [haskell]"
20:13:31 <dons> shapr: ^^
20:13:34 <Pseudonym> ur type errors. let me show u them
20:13:42 <lispy> dons: heh, where did you find that?
20:13:43 <monochrom> yeah, I can't do cute misspellings, but I can avail "adj noun is adj" examples.
20:13:45 <dons> on reddit.
20:13:52 <Axman6> Pseudonym: aka: ur typing sux
20:13:54 <Axman6> ?
20:14:02 <lispy> dons: I seem to recall hearing that from shapr in the past
20:14:03 <dons> Pseudonym: i was wondering if we hooked up the type checker to an electric shock pain mechanism, would we make less type errors
20:14:07 <dons> and just learn to produce better code
20:14:29 <Axman6> purity through pain, sound good to me
20:14:33 <monochrom> For the love of God, hook up the theorem prover instead!
20:14:47 <Pseudonym> I don't see the point of that.  The reason why we have type checking is precisely so we don't have to worry about stuff like that.
20:14:53 <lispy> if you try to use 'deriving' but the instance can't be created, "Hai, I made ur instance but I eated it"
20:15:01 <Pseudonym> *BZZZT*  How dare you rely on me to find your bugs for you!
20:15:02 <monochrom> hahahahha
20:15:44 <lispy> Yeah, I would love to see thet extended haskell type checker work finished
20:15:50 <lispy> or static checking work I guess
20:16:04 <lispy> The one that can use the theorem prover with proof pragmas
20:16:21 <dolio> ndm expressed interest in extending catch to do that.
20:16:28 <dolio> Just dip into your trust fund and give him a grant. :)
20:16:39 <lispy> My work on darcs has showed me the value of being able to disable the prover at times.  Say when shipping the code.
20:17:23 <lispy> let's face it, there are times when formal methods are in the way of "real work"
20:17:50 <dmwit> static electricity checking
20:18:18 <dons> heh
20:18:21 <dons> dmwit: awesome.
20:18:39 <dons> lispy: yes, i think that's a very interesting experience report for you to write.
20:18:47 <dons> icfp or haskell workshop experience report next year?
20:18:56 <dons> "proof engineering in darcs: an experience report"
20:18:59 <lispy> that would be cool with me :)
20:19:00 <dons> something like that would be killer.
20:19:19 <lispy> dons: the feedback from the talk I gave has made me restructure my thesis :)
20:19:23 <dons> woo!
20:19:30 <monochrom> a suitable formal method cannot be in the way. an unsuitable formal method is in the way.
20:19:39 <lispy> I found out, people don't care much about the data model we use, but the approach and how it pans out is interesting to people
20:19:57 <monochrom> it is the same conventional wisdom as "FP is slow".
20:20:09 <dons> heh. you should hit people when they say that.
20:20:16 <gwern> (Immah charging mah provar? Ur module has OVER 9000!!! syntax errarz)
20:20:23 <pumpkin> lol
20:20:36 <lispy> dons: there is your place to hook up the shock collar, "FP is slow! *BZZZZT* I mean...FP rocks!"
20:20:36 <Axman6> "yeah, how do you like dem functions huh? DIDN'T EVEN SEE IT COMING!"
20:20:57 <dons> right. people need to learn
20:21:14 <dons> we can beat people up with rwh until the confess
20:21:16 <pumpkin> how does haskell compare to ocaml?
20:21:17 <gwern> 'Type error: function foo expects 5 arguments, you provided OVER 9000!!! arguments'
20:21:23 <gwern> pumpkin: favorably
20:21:32 <dons> pumpkin: instance Ord OCaml, oh wait. hang on. OCaml can't do that.
20:21:35 <Axman6> pumpkin: quite a lot faster from what i remember
20:21:45 <pumpkin> Axman6: haskell being the faster one?
20:21:50 <Axman6> yes
20:21:58 <pumpkin> cause the syntax looked kinda similar at first glance
20:22:01 <pumpkin> but I didn't go looking too closely
20:22:02 <Axman6> it's nearer C speeds than OCaml i believe
20:22:03 <Pseudonym> I get annoyed by the "C is fast" meme, too.
20:22:12 <Pseudonym> C actually isn't as fast as people think.
20:22:19 <Pseudonym> Its performance degrades over time as it's maintained.
20:22:21 <lispy> pumpkin: Ocaml is fine if you don't miss ad-hoc polymorphism, infinite data structures, insane parallesim and minor things like that
20:22:26 <Axman6> Pseudonym: it can be fast, but does't mean it will be
20:22:32 <Pseudonym> Anything can be fast.
20:22:35 <pumpkin> well
20:22:37 <geezusfreeek> ocaml historically has been faster than ghc, but i am pretty sure that has changed now
20:22:40 <Pseudonym> Well, kinda.
20:22:42 <pumpkin> it puts very little cruft between you and processor
20:22:43 <dons> we're in the multicore world. if you can't do futures or stm, then the game is over.
20:22:47 <geezusfreeek> err, *generated faster executables
20:23:00 <pumpkin> lispy: I see :)
20:23:06 <Axman6> dons: just wish STM was faster sometimes :\
20:23:11 <Pseudonym> C programs are harder to maintain, so their performance is harder to _keep_ fast.
20:23:19 <pumpkin> lispy: how does parallelism in haskell work? can it implicitly parallelize things?
20:23:20 <dons> if you need low level performance, use MVars , Axman6
20:23:21 <Axman6> that reminds me, i though of a way to maybe speed that thing up... hmm
20:23:24 <Cale> dons: Nested data parallelism? :)
20:23:32 <Axman6> dons: i'm using both actually
20:23:33 <dons> without hardware support, STM is a high level construct for getting correctness and robustness
20:23:37 <Pseudonym> Mind you, it's worse with assembler.
20:23:38 <gwern> http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=ghc&lang2=ocaml
20:23:40 <lambdabot> Title: Haskell GHC benchmarks | Ubuntu : Intel® Q6600® Computer Language Benchmarks G ..., http://tinyurl.com/698byw
20:23:42 <dons> if you have time, dive down and program lower level synchronisation
20:23:44 <Pseudonym> You can never modify just one line of assembler.
20:23:48 <Pseudonym> Usually.
20:24:09 <lispy> pumpkin: implicitly?  Not sure.  But, it can do it explicitly quite well and has primitives for pessmistic and optimistic synchronization the latter being nice and composable
20:24:09 <Pseudonym> And if you do, it may change enough assumptions that you need to reallocate most of your registers.
20:24:17 <dolio> OCaml has better code generation on some platforms currently, no? Of course, people are working on that area of GHC now.
20:24:37 <Pseudonym> The point being that the supposed performance advantage of low-level programming is very brittle.
20:25:23 <pumpkin> lispy: it seems (naively) that in a pure function language like haskell, it could know to take a map function and distribute it across multiple threads, but I dunno
20:25:34 <dons> pumpkin: right. the problem is too much parallelism
20:25:35 <geezusfreeek> pumpkin: parMap :)
20:25:39 <gwern> overhead is the issue
20:25:39 <dons> more than our current cores can handle.
20:25:41 <geezusfreeek> :t parMap
20:25:43 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
20:25:46 <dons> you actually need to /reduce/ the amount of parallelism
20:25:52 <dons> to larger chunks, since our current hardware is limited.
20:25:53 <lispy> pumpkin: yes, but I don't know how much support we have for it.  There is the 'par' stuff
20:25:59 <pumpkin> ah, I see
20:26:02 <dons> so we have parallel strategies for constraining the granularity
20:26:13 <Giraffe> does anybody have any experience with HDBC?
20:26:17 <Giraffe> particularly involving SQLite
20:26:17 <pumpkin> @src parMap
20:26:18 <lambdabot> Source not found. stty: unknown mode: doofus
20:26:26 <dons> see my supercomputing 08 talk about this, http://galois.com/~dons/slides/dons-galois-sc08.pdf
20:26:31 <lambdabot> Title: cache:http://galois.com/~dons/slides/dons-galois-sc08.pdf - Google Search
20:26:40 <pumpkin> thanks dons
20:26:42 <pumpkin> and others :)
20:26:48 <Axman6> how odd... my program runs quite a bit faster when i don't use `time`
20:26:48 <lispy> dons: speaking of which...do you know roughly when the next talk will be?
20:26:56 <dons> the next galois tech talk?
20:27:00 <lispy> dons: I missed the last one, but I would like to go to more :)
20:27:08 <lispy> yeah
20:27:10 <dons> i think next week. there's a non-public one this week.
20:27:37 <dons> i also want to give a 6.10 new features talk in early jan
20:27:41 <pumpkin> OMG dons is a false prophet
20:27:44 <lispy> We should also start planning for the first pdx hackathon of '09.
20:27:54 <dons> pumpkin: ?
20:27:57 <dons> lispy: yeah
20:28:04 <dons> january. then get ready for utrecht
20:28:17 <Axman6> yeah... the way i'm using STM is not goot for parallelism -_-
20:28:22 <Axman6> good*
20:28:26 <lispy> what's going on in utrecht or when is utrecht?
20:28:31 <dons> hackathon
20:28:31 <pumpkin> dons: http://www.jesus-is-savior.com/Wolves/don_stewart.htm
20:28:36 <lambdabot> Title: Don Stewart EXPOSED!
20:28:39 <dons> oh, that's a different one.
20:28:42 <dons> there's a few.
20:28:43 <pumpkin> I know :P
20:28:47 <pumpkin> was just being silly
20:28:48 <dons> its a common scottish name
20:29:03 <lispy> dons: I won't be at the hackathon in utrecht I expect...
20:29:09 <Pseudonym> There's another Andrew Bromage in the world, and he's a drummer in England whose parents own a pub.
20:29:15 <sjanssen> @remember dons nstance Ord OCaml, oh wait. hang on. OCaml can't do that.
20:29:15 <lambdabot> I will never forget.
20:29:15 <dmwit> ?remember lispy <dons> january. then get ready for utrecht <lispy> when is utrecht?
20:29:16 <lambdabot> Nice!
20:29:19 <Pseudonym> No false prophets for me.
20:29:21 <sjanssen> dons: hilarious
20:29:32 <dons> hehe
20:29:33 <lispy> dons: what conference is that with?  I mean, i would expect it to be with ICFP?
20:29:41 <dons> oh, its just independent
20:30:05 <dons> btw, supercomputing 09 is in portland next year
20:30:11 <dons> i really recommend this rather amazing conference.
20:30:21 <dons> and hopefully we'll have an expanded haskell presence next year too
20:30:26 <Axman6> is MVar creation costly?
20:30:33 <dons> pretty cheap
20:30:38 <dons> what are you comparing it to?
20:30:40 <lispy> I should tell my boss that I need to go to learn about ways we can apply supercomputing to traffic sims :)
20:30:51 <Axman6> dons: well, i was considering making a lot of them
20:30:55 <dons> *everyone* should read sulzmann and simon marlow's new paper on the comparative cost of parallelism abstractions
20:31:08 <dons> hands up if you've read it?
20:31:14 <Axman6> dons: i'll get my girlfriend on it right away!
20:31:16 * lispy looks shifty
20:31:20 <dons> ...
20:31:25 <dons> come on now. don't be shy.
20:31:40 * Twey blinks.
20:31:41 <dons> ok. here it is: read it: http://www.haskell.org/~simonmar/papers/concurrent-data.pdf
20:31:42 <lambdabot> Title: Comparing the performance of concurrent linked-list implementations in Haskell
20:31:43 <Twey> Haha
20:31:43 <lispy> I was ... um going to read it... but TMR just came out...yeah tha's it
20:31:50 <dons> heh
20:32:37 <dons> probably the best comparison of the current costs for these abstractions we have.
20:33:00 <dons> also, who's read simonpj's and satnam singh's parallel haskell tutorial?
20:33:16 <dons> also *strongly* recommended if you want to use than 2nd, 3rd or 4th core.
20:33:23 <dons> http://research.microsoft.com/~simonpj/papers/parallel/index.htm
20:33:24 <lambdabot> Title: Parallel Haskell
20:33:29 <dons> both very new
20:33:31 <Axman6> dons: i think i read some of it, lots of typos
20:33:38 <dons> "A Tutorial on Parallel and Concurrent Programming in Haskell "
20:34:01 <lispy> To be honest, there is so much good stuff going on in Haskell right now that is *hard* to stay current
20:34:13 <solrize> i've read part of it, it's great
20:34:16 <dons> it is pretty crazy, yes, lispy.
20:34:24 <dons> i try to do daily summaries of important stuff via the haskell subreddit
20:34:30 <dons> the 3 or 4 key things i think happened each day
20:34:38 <lispy> good idea
20:34:44 * Twey hasn't
20:34:57 <lispy> dons: do you keeps note then?
20:35:07 <monochrom> 3 key things happen each day! That's crazy.
20:35:10 <dons> i use rss
20:35:15 <dons> each day something good happens
20:35:26 <lispy> HWN is good too
20:35:29 <Twey> Ooh, yay
20:35:39 <dons> http://www.reddit.com/r/haskell/
20:35:40 <lambdabot> Title: Haskell
20:35:46 <Twey> I've been looking for one of these
20:35:47 <lispy> ?where haskkit
20:35:47 <lambdabot> http://haskell.reddit.com
20:35:50 <dons> i.e. martin sulzmann has a blog
20:35:56 <dons> he's posting about "boosting" stm.
20:36:07 <Korollary> I bet each day something good happens in every branch of CS.
20:36:15 <lispy> dons: as in C++'s boost?
20:36:19 <dons> nah
20:36:36 <sjanssen> what sort of boost, then? :)
20:36:43 <dons> http://sulzmann.blogspot.com/2008/11/transactional-boosting.html
20:36:43 <monochrom> English boost.
20:36:43 <lispy> Korollary: are you saying that Haskell is now a branch of CS?
20:36:43 <lambdabot> Title: Martin Sulzmann's Blog: Transactional boosting
20:36:44 <sjanssen> like a rocket?
20:36:59 <dons> "This post is about software transactional memory (STM) and how to retain its benefits (composability) while trying to minimize its drawbacks (poor performance due to false conflicts)."
20:37:02 <solrize> CS is a branch of Haskell
20:37:13 <dons> so what happened today?
20:37:15 <Korollary> lispy: of course not
20:37:28 <dons> we saw a new web framework, turbinado
20:37:30 <dons> darcs was released.
20:37:37 <dons> rwh release date announced
20:37:41 <dons> TMR released
20:37:42 <Axman6> haskkit: dons dons dons dons dons dons dons someone else dons dons dons...
20:37:47 <Axman6> not that thats a bad thing :)
20:38:03 <dons> i encourage anyone who finds interesting things going to to drop it by the haskell subreddit
20:38:32 <dons> and martin sulzmann continued his interesting research blog
20:38:42 <dons> so a busy day
20:38:48 <solrize> http://www.cs.chalmers.se/~patrikj/poly/afp98/  i really like this, i'm trying to read it
20:38:56 <lambdabot> Title: Generic Programming - An Introduction
20:38:59 <Axman6> this, plus haskell could be awesome... http://www.parallax.com/tabid/407/Default.aspx
20:39:03 <lambdabot> Title: Propeller General Information
20:39:06 <lispy> dons: was the darcs release today?  I thought that was yesterday...oh maybe  it was very late in the night though
20:40:35 <dons> hay, jdh was trolling the ATS lists now.
20:40:46 <dons> he has no shame.
20:41:26 <dons> lispy: i wonder if we should do a multicore + haskell grassroots tutorial in portland
20:41:29 <dons> that'd be fun.
20:41:54 <lispy> jdh = harrop?
20:42:00 * badkins picked up "Progamming in Haskell" this afternoon and can't put it down!
20:42:03 <dolio> Was he? What did he have to say?
20:42:08 <dons> badkins: woo!
20:42:21 <dons> http://sourceforge.net/mailarchive/forum.php?thread_name=200811180819.50136.jon%40ffconsultancy.com&forum_name=ats-lang-users
20:42:21 <badkins> yeah, only a few hours with the language and I'm *loving* it :)
20:42:27 <dons> yay badkins. welcome!
20:42:31 <badkins> thx :)
20:42:37 <lispy> dons: yeah, that would be fun, but I know next to nothing about haskell and parallel computing...or at least I've never actually used STM
20:42:50 <Giraffe> i love haskell, but getting uesd to doing the IO/purity thing is a bit of a challenge
20:42:52 <lispy> dons: it would be a neat way to learn
20:42:54 <Giraffe> not a discouraging one, though!
20:43:07 <badkins> I finally stopped the endless analysis and reading trying to determine which language to learn and figured I could've learned one by now :)
20:43:36 <dons> Giraffe: its important if you want to program you multicore.
20:43:42 <dons> so may as well learn now, rather than later.
20:44:08 <Giraffe> dons, hmm?
20:44:13 <Giraffe> oh, no, i mean i'm still rather new to haskell
20:44:34 <dons> purity is important for effective parallel programming
20:44:40 <Axman6> Giraffe: yeah, it's a bit of a bitch to understand at first, but eventually something clicks, and it just makes sense
20:44:43 <dons> so if you learn how to deal with it, that'll help you program such systems
20:44:50 <Giraffe> oh, i understand purity
20:45:03 <Axman6> at least for me it did. t'was a silent click too, so i couldn't tell you what i learnt -_-
20:45:22 <dublpaws>  it feels like the programs are inside out to me.
20:45:49 <dons> dublpaws: oh, that's interesting. could you elaborate?
20:46:19 <badkins> coming from Ruby (most recently), I see more power & more speed with the main drawback of lacking something like Rails, but I'd prefer to start with a solid language and develop the libs/frameworks if necessary. A few years back, Rails didn't even exist.
20:46:19 <Giraffe> what i mean is more along the lines of like...if i have a function (for example, System.Directory.getPermissions) that returns an IO *something*, how do i work with that
20:46:23 <dublpaws> lets see. it'll take a second to formulate something coherent.
20:46:26 <Axman6> functions put things into you!
20:46:39 <Giraffe> make a function using do that has a type like IO String -> IO (), so it works with the IO monad?
20:46:42 <dons> badkins: you could try getting up to speed with one of the haskell web frameworks. a new one was announced today, in fact.
20:47:04 <Axman6> Giraffe: you use something that has the form String -> IO ()
20:47:14 <geezusfreeek> :t liftM
20:47:14 <badkins> yeah, I plan on doing just that, but I'm surmising that I *might* have to develop something myself, or with a small group
20:47:15 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:47:37 <Axman6> then, do { perms <- getPermissions; f perms } -- f :: String -> IO ()
20:47:38 <solrize> "inside out" => all i/o is normally done at the outermost level of the program
20:47:48 <geezusfreeek> Giraffe: you can use functions like liftM or (>>=) to "extract" IO values and use in functions that take pure values
20:48:00 <Giraffe> ah, right, liftM
20:48:02 <Giraffe> i forgot about that!
20:48:07 <lament> solrize: ha, that makes sense
20:48:13 <lament> it does turns programs inside out
20:48:16 <lament> *turn
20:48:18 <badkins> for being a dynamic guy for the last few years, I find the type system a thing of beauty :)
20:48:22 <dublpaws> solrize: yeah that's it exactly.
20:48:28 * badkins will stop gushing now and get back to the book ...
20:48:35 <Giraffe> i understand it conceptually
20:48:35 <Axman6> badkins: you're not alone
20:48:40 <Giraffe> the implementation is just what's hanging me up
20:48:44 <Giraffe> but not for much longer!
20:48:55 <Axman6> Giraffe: want to learn more about monads?
20:49:02 <Giraffe> also if you're all at least a bit curious...the main project i'm using to learn this is an e-book managing app
20:49:05 <Giraffe> (open source of course)
20:49:18 <Giraffe> Axman6, i understand monads in theory
20:49:25 <Twey> dons: The parallel tutorial seems to have a lot of errors :-\
20:49:33 <Axman6> well, want to know more about the implimentation?
20:49:34 <Giraffe> i mean it seems like the most logical thing to do in haskell
20:49:39 <Giraffe> sure!
20:50:02 <Axman6> http://blog.tmorris.net/20-intermediate-haskell-exercises/ work through those, and it might help a lot, helped me a hell of a lot
20:50:07 <lambdabot> Title: λ Tony’s blog λ » Blog Archive » 20 Intermediate Haskell Exercises
20:50:13 <geezusfreeek> oh yeah good suggestion
20:50:13 <Axman6> with help from Cale
20:51:16 <lispy> ?quote shapr cpu
20:51:17 <lambdabot> shapr says: I put down my cell cpu :-( now I can't find it. miniaturization has its downsides
20:51:26 <Giraffe> Axman6, interesting, but what exactly am i supposed to be doing?
20:51:41 <geezusfreeek> Giraffe: replace the error "todo" stuff with code
20:51:43 <Axman6> Giraffe: replacing the error "blah" stuff with the implimentations
20:52:01 * shapr laughs
20:52:05 <shapr> It's not in any of my pockets..
20:52:14 <Giraffe> ooh, i see
20:52:15 <Axman6> shapr: swallow it?
20:52:18 <b\6> is there a ghc 6.10.x deb hiding out somewhere?
20:52:30 <BMeph> shapr: But shapr... your pockets have pockets... ;p
20:52:34 <shapr> I doubt it, but I did have a sandwich since I extracted it.
20:53:01 <Axman6> Giraffe: so for instance, i think Furry [] is just map
20:53:15 <Axman6> that;s an easy one to get you started
20:53:15 <dons> Twey: i think simon and satnam would appreciate corrections, btw.
20:53:22 <Axman6> :t fmap
20:53:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:53:32 <Axman6> @src [] fmap
20:53:32 <lambdabot> fmap = map
20:53:37 <Axman6> hoorah
20:54:18 <Giraffe> Axman6, gotcha
20:54:44 <trie> Can someone shed light on what the GHCI options "+RTS -xm<addr> -RTS" does and what to set addr to?
20:54:56 <ivanm> Axman6: have you joined the marines or something?
20:55:03 <dons> shapr: you would love supercomputing 08.
20:55:12 <Axman6> we have marines?
20:55:14 <dons> shapr: we'll have to get you to portland for sc09.
20:55:15 <BMeph> How come more types don't have an analog to ':'? :)
20:55:17 <ivanm> Axman6: nope
20:55:23 <Axman6> why do you ask?
20:55:40 <ivanm> Axman6: "hoorah" <-- isn't that the stereotypical US marine cry?
20:55:56 <shapr> dons: Good idea. Today's Cell cpu adventure: http://picasaweb.google.com/shae.erisson/CellCPUIndecentlyExposed#
20:55:56 <Axman6> i thought it was hoo-ah or something
20:55:57 <lambdabot> Title: Picasa Web Albums - shapr - Cell CPU inde..., http://tinyurl.com/5vcf48
20:56:00 <Pseudonym> ivanm: Stereotypical US marines cry?
20:56:13 <Axman6> but, said more like you were punched in the stomach
20:56:18 <dons> shapr: wow
20:56:25 <solrize> hoo-yah or something like that
20:56:25 <ivanm> Axman6: ahhh, could be
20:56:45 <BMeph> ivanm: Try "Ohh-RAH!" :)
20:56:46 <Axman6> hoorah is much more british upper class imo :P
20:56:50 <BMeph> er, *"Ooh-RAH!"
20:56:56 <ivanm> BMeph: whatever
20:56:58 <ivanm> ;-)
20:57:02 <Giraffe> oh wow
20:57:06 * ivanm isn't a yank let alone a marine
20:57:12 <Giraffe> i didn't see the type signature for furry
20:57:14 <BMeph> ivanm: Just like Russians do... ;)
20:57:16 <Korollary> Hooah is very army,iirc.
20:57:17 <Giraffe> that was why it was all confusing :P
20:57:17 <solrize> hoo-ya
20:57:28 <solrize> Instructor Walston stealthed in (Can stealth be a verb?) and we answered "HOO-YA, INSTRUCTOR WALSTON" to Balaywa Blackman's (our team leader for the day) "INSTRUCTOR WALSTON!"
20:57:32 <ivanm> BMeph: hmmm?
20:57:35 <Axman6> Giraffe: if you have issues with it, just ask here. but make sure you mention you don't want the answers ;)
20:58:03 <Giraffe> well naturally
20:58:08 <dons> did anyone see that post on the darcs list from the russian navy research lab guys?
20:58:09 <Giraffe> but it makes a lot more sense now that i know what i'm looking at
20:58:14 <shapr> dons: no?
20:58:19 <Axman6> Giraffe: heh, indeed :)
20:58:20 <dons> who'd been using darcs for the past few years, and were talking about how they loved it
20:58:23 <dons> but it was time to move on.
20:58:25 <Giraffe> also, you guys are awesome, fyi
20:58:33 <ivanm> dons: seem to recall something about it
20:58:40 <Axman6> Giraffe: some will be quite easy, some, like the State stuff may fuck with your brain
20:59:03 <Giraffe> s'all good
20:59:16 <Axman6> i should get ready
20:59:23 <Giraffe> Axman6, the reason i'm doing this is because one of my best friends requested an application to catalog his e-books
20:59:28 <Axman6> supposed to be packing, but not sure what else i need...
20:59:31 <Giraffe> in his words, an "iTunes for e-books"
20:59:42 <Axman6> Giraffe: gui?
20:59:50 <Giraffe> most likely
20:59:52 <BMeph> ivanm: Russians say "???", where your typical "yank" would say "Yay". :)
21:00:05 <Cale> BMeph: encoding fail
21:00:11 <Axman6> indeed
21:00:16 <BMeph> Huh? "???"... :\
21:00:17 <Giraffe> i'm going to be making a command line interface first which will communicate with a SQLite (or something) database
21:00:28 <Axman6> BMeph: was that supposed to be "???"?
21:00:32 <Cale> BMeph: We're getting "???"
21:00:48 <Giraffe> and then once that's done, i'll set up a GUI using gtk2hs, or something else
21:01:18 <monochrom> Use UTF-8
21:01:28 <BMeph> Aye, I saw it. Now I just gotta figure out how to do those Unicode tricks like the rest of you cool kids... ;)
21:01:44 <monochrom> use the character palette
21:01:50 <Giraffe> i'd like it to be portable between windows and linux, if at all possible
21:01:52 <BMeph> monochrom: Sorry, my native encoding is WTF-8. ;p
21:02:04 <Axman6> heh
21:02:06 <monochrom> haha
21:02:20 <Giraffe> Axman6, where ya headed?
21:02:30 <orbitz> Axman6: so is the idea of those just to get the thing to compile?
21:02:37 <Giraffe> orbitz, not quite
21:02:39 <Axman6> down the coast for the weekend with my girlfriend and a couple of friends
21:03:00 <Axman6> orbitz: they should compile already, but they're not correct
21:03:09 <Giraffe> get it to work so that it works with [], Maybe, etc.
21:03:17 <orbitz> Axman6: well right, i mean withotu the error's
21:03:38 <Axman6> basically
21:04:00 <Giraffe> instance Fluffy [] where furry f g = map f g
21:04:07 <Giraffe> so is that all i need there...?
21:04:08 <Axman6> orbitz: it's reimplementing Functor, Manad and some others i think for various types
21:04:10 <Giraffe> or am i missing something horrible
21:04:17 <Axman6> Giraffe: nope, that's fine :)
21:04:21 <Axman6> @src [] fmap
21:04:22 <lambdabot> fmap = map
21:04:22 <Giraffe> awesome!
21:04:34 <Giraffe> use fmap?
21:04:39 <Axman6> no
21:04:41 <orbitz> i think he jus tments
21:04:41 <Giraffe> oh, ok
21:04:41 <BMeph> "Ура"
21:04:44 <Axman6> you're implementing fmap
21:04:47 <BMeph> "Ура!"
21:04:48 <orbitz> furry = map
21:04:48 <orbitz> curryign will handle teh rest
21:05:01 <Giraffe> orbitz, ah
21:05:02 <orbitz> or am i off?
21:05:06 <Axman6> nothing to do with currying afaik...
21:05:13 <Axman6> it's just pointfree
21:05:24 <orbitz> ok
21:05:32 <Twey> BMeph: You meant "ура"?
21:05:37 <Axman6> @pl furry f g = map f g
21:05:37 <lambdabot> furry = map
21:05:52 <lament> ypa
21:06:05 <Twey> Which we get due to currying
21:06:23 <Twey> Point-free is just an application of currying.
21:06:44 <orbitz> thanks Twey
21:07:28 <Twey> Axman6: Do you see how that's only possible because of currying?
21:07:32 <Giraffe>   furry f (Maybe x) = Just (f x)
21:07:32 <Giraffe>   furry _ Nothing   = Nothing
21:07:39 <Giraffe> so is that for Maybe or am i off?
21:07:40 <Twey> Maybe 'furry f = map f' is a little more obvious
21:07:51 <BMeph> Twey: No, I meant the capital at the start of the word. :)
21:07:54 <Axman6> Twey: i don't fully understand currying
21:08:04 <Giraffe> Axman6, currying is pretty easy to get
21:08:10 <Giraffe> or rather, it's pretty simple
21:08:18 <Axman6> Giraffe: Maybe isn't a constructor, so you can't pattern match on it
21:08:24 <Giraffe> er...whoops
21:08:28 <BMeph> Axman6: Don't be chicken about... oh, wait, that sounds kinda good! ;)
21:08:28 <Giraffe> i meant to do (Just x)
21:08:33 <Axman6> well, i get that curry and uncurry do
21:08:47 <Axman6> BMeph: eh?
21:08:50 <Giraffe> Axman6, think of it this way
21:09:05 <Giraffe> if you have f :: a -> b -> b
21:09:14 <Giraffe> what you have is not a function of two parameters with types a and b
21:09:31 <lispy> f :: a -> (b -> b) == f :: a -> b -> b
21:09:32 <Giraffe> but rather one function which takes an a, and then returns a function that takes a b
21:09:36 <Twey> BMeph: Psht :-P  Ура then
21:09:42 <Giraffe> lispy, that doesn't explain it to someone who doesn't get it
21:09:50 <Axman6> nah i get it
21:09:50 <lispy> oh sorry!
21:09:53 <Axman6> :)
21:09:58 <Giraffe> er, that sounded harsh
21:10:14 <Axman6> just didn't know that was currying :)
21:10:18 <Giraffe> oh, yep
21:10:19 <Twey> The functions 'curry' and 'uncurry' aren't really relevant
21:10:28 <Giraffe> so you just didn't know the word for it :P
21:11:08 <Axman6> aye. i knew about the curry and uncurry functions
21:11:17 <lispy> Axman6: we can go further and make this all complicated by saying that the function arrow is right assosciative
21:11:31 <Axman6> oh yes, please do
21:11:39 <Axman6> i'll just be packing... >_>
21:11:51 <Twey> Axman6: As opposed to tupled functions, which take a single tuple with all their arguments and therefore have to take all their arguments at once (common in C, Java, &c.)
21:12:14 <Twey> The functions `curry` and `uncurry` convert between those
21:12:47 <Saizan> eta-reduction works in both forms, though
21:12:55 <monochrom> The question was, "I have function map that takes whatever number of parameters. Can I define a similar function g by just writing g=map, and what is this language feature called, since it's absent from other languages?"  The answer is: "Yes you can, it's called 'common sense' or 'why not'. If other languages don't let you do it, they are in the wrong."
21:12:55 <lispy> this is also related to lexical closures
21:13:09 <solrize> @seen batterseapower
21:13:09 <lambdabot> I haven't seen batterseapower.
21:14:20 <Axman6> Twey: yeah, i see how currying is more general than that now.
21:14:23 <lispy> I've always thought the types of currry and uncurry look superficially backwards from what they do
21:14:30 <Giraffe> :t liftM
21:14:31 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:14:38 <Axman6> solrize: you don't mean britishseapower do you?
21:15:03 <lispy> :t curry
21:15:04 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
21:15:13 <solrize> axman6 possible i guess.
21:15:20 <Saizan> why? (a -> b -> c) is the curried form, no?
21:15:20 <solrize> @seen britishseapower
21:15:20 <lambdabot> I haven't seen britishseapower.
21:15:35 <Axman6> @seen BritishSeapower
21:15:35 <lambdabot> I haven't seen BritishSeapower.
21:15:45 <lispy> :t zip
21:15:46 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:16:35 <Giraffe> @seen BritishSeaPower
21:16:35 <lambdabot> I haven't seen BritishSeaPower.
21:16:48 <solrize> i think the bot is case insensitive
21:16:54 <Giraffe> it is, i was just being a jerk
21:17:02 <Axman6> bah, i've seen him in #macosx a number of times
21:17:12 <lispy> , seen BritishSeaPower
21:17:13 <lunabot>  luna: Not in scope: `seen'
21:17:38 <lispy> oh is preflex not here?
21:18:05 <BMeph> @seen worse_lispy_puns
21:18:05 <lambdabot> I haven't seen worse_lispy_puns.
21:18:09 <solrize> what's this about a new haskell web framework?  is there going to be a python-like situation where there's N different ones to choose from?
21:18:10 <BMeph> :)
21:18:38 <lispy> BMeph: heh
21:18:43 <monochrom> No. There will be N+1 to choose from.
21:18:45 <Nafai> Does it have any documentation yet?
21:19:05 <BMeph> http://turbinado.org/
21:19:06 <lispy> monochrom: we should probably avoid n+k patterns
21:19:15 <monochrom> hah...
21:19:19 <BMeph> solrize: ^
21:20:22 <solrize> yeah i'm looking at the page bmeph, thanks
21:20:49 <solrize> does turbinado claim to be faster than happs?
21:21:41 <solrize> it says it's like rails but i dunno what rails is like
21:22:02 <Korollary> Let's ask zedshaw
21:22:21 <solrize> github is wedged
21:22:34 * lispy thinks we need darcshub
21:22:48 <lispy> I was looking at github, I like the diff threads they have.
21:22:59 <lispy> WHere people can comment on your changes
21:23:13 <solrize> hyena sounds real interesting
21:23:59 <solrize> what is happening with happs?  did it never catch on?
21:23:59 <Axman6> Korollary: is he the guy with the 'zed's fucken awesome' blog? or whatever it was
21:24:08 <Korollary> Axman6: I think so.
21:24:55 <Axman6> i love that blogs layout. just makes you want to punch someone!
21:27:16 <solrize> i was looking for batterseapower since he's one of the authors of the new monad reader article about ghc plug-ins
21:31:50 <mbz> hiya
21:32:34 <lispy> mbz: oh hai
21:33:03 <mbz> hi lispy
21:36:05 * dolio needs to buy more memory to run Agda.
21:36:16 <solrize> oh noes
21:37:09 <dolio> After about 10 minutes of working on a module of any moderate size, it starts eating about 60% of my memory.
21:37:22 <dolio> Increasing every time I have it check the module.
21:37:26 <dons> worth reporting to them
21:37:37 <Giraffe> is there any way to use >>= in conjunction with do?
21:37:41 <dolio> 2 gigs isn't enough. :)
21:37:42 <Giraffe> or do i have to use liftM?
21:38:07 <solrize> giraffe what are you trying to do?
21:38:23 <Giraffe> solrize, get the permissions from a directory, parse the permissions, then print the results
21:38:46 <Giraffe> i.e. "<dir> is NOT readable." or "<dir2> is readable."
21:39:06 <dons> sjanssen: i released the (final?) high level bindings to xosd
21:39:06 <solrize> so you want something like do { x <- permissions dirname; print (isReadable x) }
21:39:14 <solrize> whatever those funcs are
21:39:16 <dons> super simple now to create on screen transparent text
21:39:27 <Giraffe> solrize, right, but in that situation...
21:39:32 <ddarius> do blocks are just expressions.  Statements syntactically include expressions as well.
21:39:38 <dons> sjanssen: basically, runXOSD [attr1, attr2] $ display text actions if any
21:39:51 <Giraffe> well, for x <- getPermissions dir, does that mean x will have the type IO Permissions or just Permissions?
21:40:10 <solrize> just Permissions
21:40:14 <Giraffe> oh!
21:40:15 <Giraffe> excellent
21:40:17 <ddarius> @undo do x <- permissions dirname; print (isReadable x)
21:40:17 <lambdabot> permissions dirname >>= \ x -> print (isReadable x)
21:40:22 <solrize> <- pulls a value out of the monad
21:40:24 <dons> anyone tried the xosd bindings?
21:40:30 <Giraffe> solrize, thanks much :D
21:40:40 <pumpkin> is a tree uniquely defined by the order in which a DFS searches it?
21:40:40 <solrize> so that you can put it into another function, that puts it back into the monad
21:40:49 <pumpkin> or a BFS
21:41:29 <solrize> i.e.   do { x <- getPermissions dir; print x }  is the same as (getPermissions dir >>= (\x -> print x))
21:41:44 <solrize> i explicitly wrote the \x to show how <- makes a lambda binding
21:41:45 <Axman6> @pl f x = print (isReadable x)
21:41:45 <lambdabot> f = print . isReadable
21:41:57 <solrize> you'd normally write (getPermissions dir >>= print)
21:42:23 <ddarius> pumpkin: No.
21:42:24 <Axman6> :t getPermissions
21:42:25 <solrize> axman6 the idea is that isReadable x is an IO Bool or something like that
21:42:25 <lambdabot> Not in scope: `getPermissions'
21:42:32 <Giraffe> :t System.Directory.getPermissions
21:42:33 <lambdabot> FilePath -> IO System.Directory.Permissions
21:42:53 <solrize> you have to bind it to a pure value that you can then print
21:43:06 <ddarius> pumpkin: Or at least I think the answer to your question is "No."  I'm not quite sure what information you are expecting to start with.
21:43:28 <pumpkin> I'm trying to think... this is actually a trie
21:43:32 <pumpkin> so it's a bit more constrained
21:43:37 <ddarius> pumpkin: Certainly you can't take a list and the fact that it is a DF or BF traversal of the tree to uniquely rebuild the tree.
21:43:52 <pumpkin> yeah, hmm
21:44:00 <pumpkin> I'm trying to build a DAWG from a trie
21:44:15 <pumpkin> and trying to find the common suffixes quickly
21:44:23 <Giraffe> solrize, i know i'd normally do (getPermissions dir >>= print), but i want to parse it in a more user-friendly way
21:44:39 <solrize> yeah
21:45:03 <Giraffe> so what if i did parsePerms $ dirName dirPerms
21:45:05 <Giraffe> er...
21:45:11 <Giraffe> print $ parsePerms ...
21:45:16 <Axman6> Giraffe: how's that monads thing going?
21:45:28 <Giraffe> Axman6, working on that and a little exercise i made for myself in IO
21:45:37 <Axman6> good good
21:45:57 <Giraffe> what is ((->) t) though?
21:46:31 <monochrom> If you look at "t -> p" and say "I want to parameterize over p", that's ((->) t)
21:46:40 <Giraffe> monochrom, that's what i was thinking
21:46:57 <monochrom> Just like "Maybe p" and you parameterize over p.
21:47:23 <BMeph> dons: I'm still working on xkcd bindings... ;)
21:48:20 <solrize> giraffe, i don't know the types of those functions but yeah, if dirName is a pure function then you shoudl be able to do something like that
21:48:31 <Giraffe> solrize, yeah
21:48:49 <Axman6> Giraffe: a lot of people have said they'd like to be able to write that as (t ->)
21:50:22 <Axman6> that one confused me a bit, but the implimentation was annoyingly simple
21:51:19 <Twey> How can one extract t from that?  :-\
21:51:32 <Axman6> Twey: ?
21:52:05 <poliquin> I'm a Haskell newbie .. I've been trying to get a program using monads working for 3 days .. If I 'hpaste' it could some kind soul give me a hint what to do next?
21:52:05 <Axman6> oh, ha, i remember how that one works now
21:52:06 <Twey> For that matter, what's the constructor for ((->) t)?
21:52:19 <solrize> poliquin sure
21:52:24 <Twey> poliquin: Of course, go ahead
21:52:26 <Axman6> poliquin: sure, someone will help you
21:52:27 <poliquin> Thanks ..
21:53:18 <poliquin> I just pasted it .. It said it was supposed to 'announce' .. guess not
21:53:36 <Twey> It announces it on the main page, not the channel
21:53:36 <Axman6> furry :: (a -> b) -> (((->) t) a) -> (((->) t) b), or :: (a -> b) -> (t -> a) -> (t -> b)
21:53:36 <solrize> the announce hasn't been working lately.  what's the url?
21:54:00 <poliquin> http://hpaste.org/12211
21:54:47 <poliquin> I got some simple monads working and I thought I was ready for something 'real' ..
21:55:22 <solrize> poliquin, that looks sort of like the state monad
21:55:37 <newsham> ?seen conal
21:55:38 <lambdabot> I saw conal leaving #haskell and #ghc 17m 28s ago, and .
21:55:53 <poliquin> I'm trying to pass thru a list of random numbers .. in the state
21:56:01 <solrize> is the idea that you want newtype ListR a = ListR { runListR :: ([Int] -> ListTup a) } so you can get the value out of it?
21:56:12 <Giraffe> uhh...two other questions
21:56:38 <Giraffe> how come when i do print $ "some stuff" ++ "\n" ++ "other stuff", it doesn't parse the newline characters?
21:56:59 <Giraffe> or more accurately, how can i tack the newline character on?
21:57:07 <solrize> > "some stuff" ++ "\n" ++ "other stuff"
21:57:08 <lambdabot>   "some stuff\nother stuff"
21:57:10 <poliquin> I generate a list of random numbers and I want to get them 'deep' into
21:57:12 <Twey> Giraffe: print = putStr . show
21:57:15 <solrize> > print $ "some stuff" ++ "\n" ++ "other stuff"
21:57:16 <lambdabot>   * Exception: "<IO ()>"
21:57:22 <Twey> > show "foo\nbar"
21:57:23 <lambdabot>   "\"foo\\nbar\""
21:57:28 <poliquin> the model (i.e. at the Port update level) ..
21:57:30 <solrize> giraffe, putStrLn
21:57:36 <newsham> hmm.. is the bot wedged?
21:57:39 <Giraffe> solrize, i want it to be pure if possible
21:57:42 <newsham> ahh there he is
21:57:50 <Giraffe> > print $ "some stuff" : '\n' : "other stuff?"
21:57:51 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
21:57:52 <Twey> Giraffe: print isn't pure
21:58:01 <Giraffe> Twey, i know, but the string it takes in is, isn't it?
21:58:16 <solrize> :t (:)
21:58:16 <Twey> As is the string for putStr and putStrLn
21:58:17 <lambdabot> forall a. a -> [a] -> [a]
21:58:25 <Giraffe> right
21:58:34 <solrize> (:) takes a value and a list in that order
21:58:44 <Twey> @src print
21:58:44 <lambdabot> print x = putStrLn (show x)
21:58:47 <solrize> "some stuff" : '\n'          would be a list then a value
21:59:00 <Twey> Giraffe: You need to get rid of that 'show', so what you want is putStrLn
21:59:03 <Giraffe> but what i want to do is parse the permissions of a directory, then print the whole result, as opposed to parsing each one
21:59:33 <Giraffe> and then printing THAT result
21:59:40 <Twey> Try using show manually.
21:59:57 <Giraffe> i don't need show though, i already have a (Permissions -> String) function set up
22:00:01 <Twey> putStrLn (show x) >> putStrLn (show y)
22:00:09 <Twey> Then use that instead
22:00:17 <Twey> What's the problem?
22:00:31 <Giraffe> i want to embed newlines into a string is all
22:00:44 <Twey> You did that in the first place
22:01:01 <Twey> It's just that show (and thus print) escapes them
22:01:10 <Giraffe> oh :(
22:01:17 <Giraffe> so putStrLn is what i should be using?
22:01:30 <Twey> putStrLn is like print but without the escaping, yes.
22:01:33 <arw> Giraffe: just take a list of strings and do unlines on it.
22:01:44 <solrize> poliquin i don't understand what your monad is doing (that's ok, i'm no expert) but it sounds like your question is how to get the values out of the monad after you've run it
22:01:44 <newsham> > unlines $ words "testing 1 2 3"
22:01:46 <lambdabot>   "testing\n1\n2\n3\n"
22:02:12 <Giraffe> there we go!
22:02:34 <Twey> Note that lambdabot does an implicit show.
22:02:42 <poliquin> solrize, Yep .. Normally you can use >>= but it needs two arguments
22:02:56 <solrize> poliquin do you know how the state monad works?
22:03:05 <mbz> is there any embeddable haskell interpreter?
22:03:08 <poliquin> solrize, There's nothing in the updatePs routine to 'bite' against
22:03:14 <Giraffe> mbz, how do you mean?
22:03:31 <dons> http://www.facebook.com/photo.php?pid=1523037&l=49ee4&id=660195979  "there is no more sequential programming". nice theme from supercomputing 08
22:03:34 <lambdabot> Title: Incompatible Browser | Facebook, http://tinyurl.com/6yem9n
22:03:37 <dons> hehe
22:03:43 <poliquin> solrize, Basically I understand it but putting it into practice has been difficult
22:04:13 * Twey searches AUR.
22:05:05 <mbz> something like a python interpreter or lua
22:05:05 <Twey> Ah, here we go
22:05:07 <Twey> mbz: Try 'hint'
22:05:20 <solrize> poliquin the idea is that you put a function inside the monad constructor that gets the value out
22:05:32 <solrize> @src State
22:05:32 <lambdabot> Source not found. I am sorry.
22:05:41 <solrize> @src Control.Monad.State
22:05:41 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:05:45 <Twey> http://aur.archlinux.org/packages/haskell-hint/
22:05:46 <lambdabot> Title: Index of /packages/haskell-hint
22:05:59 <Twey> http://www.reddit.com/r/programming/comments/2lvpm/hint_embed_a_haskell_interpreter_in_your_program/
22:06:00 <lambdabot> Title: hint: embed a Haskell interpreter in your program : programming, http://tinyurl.com/5oxuc4
22:06:18 <mbz> thanks
22:06:44 <solrize> i'm trying to find an example
22:07:47 <poliquin> solrize, Ok .. 'rns' is the random number list .. so I really want ..  (updatePs ps ((Port pid rentries destid (genActive (head rns))) : newPs))
22:08:28 <poliquin> solrize, So I just need to 'invent' a function to pull it out ?
22:09:01 <solrize> yeah, you'd use the record syntax for that, and you'd wrap the whole operation in a call to that function
22:09:02 <solrize> http://book.realworldhaskell.org/read/monads.html#id643643
22:09:07 <lambdabot> Title: Chapter 14. Monads
22:10:29 <poliquin> solrize, I've read that (and 47 other Monad articles) which helped a lot but I was still stuck
22:11:04 <hackage> Uploaded to hackage: lub 0.0.3
22:11:04 <hackage> Uploaded to hackage: lub 0.0.2
22:11:04 <hackage> Uploaded to hackage: unamb 0.1.2
22:11:18 <solrize> lemme stare at your code a little harder
22:11:29 <poliquin> solrize, Ok, .. so I should do something like .. (func to pull it out) >>= \rns (updatePs ....) ?
22:11:57 <solrize> you wouldn't use >>= there
22:12:04 <solrize> the func pulls out a non-monadified version of the value
22:12:20 <solrize> i found implementing the state monad from scratch on my own to be a very useful exercise
22:12:25 <solrize> just starting from its type signature
22:13:44 <poliquin> solrize, Ok .. That makes sense .. and yes I should probably rewrite ListR from scratch ..
22:14:19 <poliquin> solrize, I'm determined to understand monads (but I think Quantum Mechanics must be easier).
22:15:13 <poliquin> solrize, Thanks very much for the help .. You've given me a bit of hope :-)
22:15:14 <dons> no, qm is *much* harder.
22:15:22 <dons> monads are simple. they're surprising, that's all
22:15:28 <dons> check the monad chapter in RWH.
22:16:07 <solrize> poliquin, dons is right, monads are sort of like the epsilon-delta definition of limits in calculus, it takes head scratching for a while to grok it but then it makes perfect sense
22:16:13 <solrize> unlike qm which stays confusing forever :)
22:16:41 <poliquin> dons, Thanks .. Oh well .. no QM for awhile ..
22:16:48 <lament> monads, after all, are simply a human invention
22:17:01 <poliquin> I'm waiting for my Eureka! moment :-)
22:17:18 <dons> you get to define the ; operator
22:17:21 <dons> how's that?
22:17:26 <poliquin> Thanks again dons and solrize .. for the help!
22:17:36 <dons> we live to serve and apply
22:17:36 <Twey> δυ/δx?  :-P
22:19:03 <dons> "Learning Haskell was very different experience than learning Perl, in that I could not “cut-n-paste”
22:19:06 <dons> code from the web to perform a specific task as readily as I could with Perl"
22:19:09 <dons> <-- hmm. we should do something about that.
22:19:14 <dons> it should be much *easier*
22:19:25 <dons> module imports?
22:19:28 <dons> use them.
22:20:22 <sjanssen> we probably don't have many tutorials that take that approach with Haskell
22:20:33 <solrize> i think haskell is inherently less cut-and-pasteable because the type system is so much more precise
22:20:35 <mdxi> if you're cut and pasting perl from the web these days, you're almost certainly doing it wrong :)
22:20:45 <solrize> you can't just slap stuff together in haskell and expect it to type check
22:20:50 <solrize> unlike perl
22:21:13 <sjanssen> dons: does the author of the quote say whether the experience as a whole was better or worse?
22:21:27 <solrize> is that audreyt?
22:22:04 <arw> haskell is also much more concise, often you just need to find the name of a function like 'map', instead of c&p-ing a complete foreach(...){...}
22:22:06 <Cale> solrize: You can if you make sure that it typechecks as you do it ;)
22:22:18 <sjanssen> solrize: yeah, with Perl you might use the scientific method to learn -- a series of experimental edits while noting the results
22:22:45 <sjanssen> most edits in Haskell don't even get past the type checker :)
22:22:52 <dons> sjanssen: different. thinks haskell is good.
22:23:06 <lament> haskell without the type checker would be more amenable to the scientific method approach
22:23:15 <dons> solrize: it should be more composable, making "CPS" programming safer.
22:23:43 <dons> but maybe that's the issue: composition
22:23:48 <dons> not correctness
22:23:52 <solrize> hmm
22:24:00 <dons> just the ability to stick a fragment of perl in a body of code and have it do some random thing
22:24:02 <Twey> Cutting-and-pasting is the antithesis of composability
22:24:03 <dons> correct or not
22:24:08 <dons> but won't get past the  type checker in haskell
22:24:14 <dons> making haskell look less c'n'p-able
22:24:18 <solrize> yeah
22:24:24 <solrize> that's the issue
22:24:29 <dons> though it should be far /safer/ to get code off the web in haskell
22:24:30 <Twey> You can always copy-and-paste whole functions
22:24:37 <lispy> making CPS safer? there are papers about using GADTs and whatnot to do type safe CPS
22:24:37 <sjanssen> Twey: no, pasting is the antithesis of re-use -- those aren't necessarily the same thing
22:25:04 <solrize> lament haskell without the type checker would basically be lisp
22:27:53 <lispy> dons: did you see that all the darcs sprint stuff is now fully in darcs and so it's safe to be hacking on it again (safe meaning, you don't have to dance around what's in and what's not in)
22:31:00 <Lemmih> When will darcs be on hackage, btw?
22:31:17 <lispy> Lemmih: oh, we could upload it now atually
22:31:17 <dons> woo. ok. great, lispy!
22:31:23 <dons> yeah. great idea!
22:31:25 <lispy> Lemmih: we have Setup.hs and darcs.cabal now
22:31:28 <dons> do the releases on hackage simultaneously
22:31:42 <sjanssen> that would be really handy
22:31:55 <lispy> I'll coordinate with kowey just to make sure I upload the right thing, but I'll try to do that today
22:32:02 * sjanssen would certainly run later versions of darcs if "cabal install darcs" worked
22:32:05 <dons> yeah
22:32:29 * Lemmih seconds that.
22:32:33 <sjanssen> right now I'm on
22:32:47 <sjanssen> "2.0.2 (+ 283 patches)", which is probably ancient
22:33:07 <Lemmih> I'm at 1.0.9
22:33:35 <lispy> 1.0.9 is deathly ancient, and 2.0.2 has known bugs
22:33:52 <sjanssen> lispy: were the bugs fixed within 283 patches?
22:33:53 <lispy> 1.0.9 is thankfully stable though
22:34:18 <lispy> sjanssen: my memor is not good enough to answer that :)
22:34:21 <lispy> memory*
22:34:35 <sjanssen> lispy: I wasn't really expecting an answer
22:34:44 <lispy> sjanssen: 2.1.2 was *just* released though
22:35:14 <lispy> so you can trade known bugs for unknown ones once I upload to hackage :)
22:35:40 <sjanssen> at least the unknown bugs can potentially help somebody
22:36:21 <lispy> hmm...the page for darcs-cabalized needs to be changed
22:36:34 <lispy> it's no longer David's Advanced ...
22:36:48 <lispy> he renamed it Darcs Advanced ...
22:36:49 <sjanssen> lispy: what is it?
22:37:04 <lispy> he never really liked how vain it was
22:37:05 <sjanssen> yet another recursive acronym, naturally
22:37:08 <lispy> so I'm glad he changed it
22:37:54 <lispy> actually, the darcs-cabalized entry should be removed
22:38:12 <lispy> we should just have 'darcs' now since it will be an officially sanctioned package
22:38:24 <lispy> "This is an unofficial package of Darcs, using Cabal; problems with it may well be the fault of the packager and not the Darcs project."
23:06:16 <poliquin> solrize, Got it running ! Thanks for the help and encouragement
23:06:31 <poliquin> solrize, here's the code fragment http://hpaste.org/12212
23:07:00 <poliquin> dons, Thanks for the help .. The simulator is working .. http://hpaste.org/12212
23:07:35 <solrize> nice, i think you could write updatePs as a do-block ?
23:08:03 <poliquin> solrize, true .. but I was trying to 'go basic' (pardon the pun) so I could understand it better
23:08:10 <solrize> heh
23:10:01 <badkins> Someone mentioned that a number of things have been announced recently (in particular a web server/framework). Besides #haskell and comp.lang.haskell, what are some good sources to stay plugged in to recent developments?
23:10:39 <SubStack> http://www.reddit.com/r/haskell
23:10:40 <lambdabot> Title: Haskell
23:10:45 <badkins> thx
23:11:10 <solrize> badkins, http://sequence.complete.org
23:11:11 <lambdabot> Title: The Haskell Sequence | News about Haskell
23:11:25 <badkins> cool
23:12:00 <badkins> anything with rss is great :)
23:13:06 <Twey> Ooh, a better Haskell Web framework
23:14:51 <badkins> better? doesn't look like much is there yet
23:16:28 <Twey> Well it's that or hAppS >.>
23:17:28 <badkins> it's just, "get a hash of params, munge them, hit the db, munge the result, poof", right?
23:17:30 <badkins> :)
23:17:50 <Twey> Heh
23:17:57 <Twey> It's that munging that's the issue :-P
23:18:05 <Twey> And making the API nice, of course.
23:18:14 <pumpkin> :t topsort
23:18:15 <lambdabot> Not in scope: `topsort'
23:18:33 <badkins> sure, but if Mongrel can be written in Ruby/C, it can't be *that* hard to develop something similar in Haskell
23:18:48 * badkins says after buying a book and spending a few hours reading about Haskell :)
23:19:02 <Twey> It isn't
23:19:17 <Twey> It just hasn't been done yet :-P
23:19:30 <badkins> I've been developing Ruby/Rails apps for several years and I'm looking forward to working with Haskell for web apps.
23:19:31 <Twey> Making it nice can be tricky
23:19:33 <arw> usually you want a whole lot more than that. like automagic sessions, templates, forms and validation (which should be something really cool in haskell, considering the type system)...
23:19:48 <badkins> Rails is so much about state mutations though, so it'll be a while before I become idiomatic instead of idiotic.
23:20:28 * Twey nods.
23:20:38 <badkins> I'm looking forward to the possibility of massive refactoring w/o having to hope that the unit tests catch everything :)
23:21:58 <arw> hm. like the "CheckedFirstName" always beeing good and checked because the type system says so, without the intern putting something stupid in there every other full moon :)
23:24:34 <quicksilver> badkins: also http://planet.haskell.org
23:24:35 <lambdabot> Title: Planet Haskell
23:24:47 <dons> i just mentioned the haskell reddit on -cafe@.
23:24:53 <quicksilver> badkins: although like most planets, it contains quite "offtopic" stories sometimes
23:24:57 <dons> i wonder if its important enough to link to on haskell.org yet?
23:25:48 <quicksilver> badkins: there is not only HAppS, there is also WASH
23:25:55 <quicksilver> and at least one other IIRC
23:25:59 <vegai> and cgi/fastcgi
23:26:00 <quicksilver> (I've not used any of them though)
23:26:11 <quicksilver> cgi/fastcgi isn't a framework, though. That's just a protocol.
23:26:12 <dons> is wash on hackage?
23:26:17 <dons> gwern ^^ ?
23:26:31 <dons> kibro is a framework on top of fastcgi/cgi
23:26:46 <quicksilver> badkins: as far as I know the only thing as mature as rails/catalyst/django is happs, though.
23:27:17 <Twey> hAppS is the only 'serious' framework
23:27:26 <Twey> But... unfortunately, it's quite poor.
23:27:37 <dons> even current happs releases?
23:27:43 <Lemmih> It is misunderstood.
23:27:45 <quicksilver> I don't think 'poor' is remotely appropriate for happs.
23:28:05 <dons> Lemmih: yes. we need to do better branding within the community.
23:28:06 <quicksilver> it is sophisticated, has some remarkable design choices, and is poorly documented.
23:28:14 <dons> all the work on tutorials, and gitit , and the new hackage have helped
23:28:29 <dons> where's the happs blog :)
23:28:34 <dons> with snippets and news
23:28:41 <dons> Lemmih: you could blog some of your activities :)
23:28:48 <jeffz`> HAppS is still beta though
23:29:06 <dons> it's in use at deutsche bank.
23:29:29 <Twey> quicksilver: 'Remarkable' in the sense of 'WTF-able'?
23:29:34 <dons> and hpaste has been running happily for almost 2 years now.
23:29:37 <jeffz`> it hasn't had a released tagged as stable is what I mean though
23:29:43 <dons> so i think we're in serious territory
23:29:58 <dons> Lemmih: is it in stable release now?
23:30:39 <Lemmih> dons: No, I'm afraid not. Further API changes are planned.
23:30:45 <quicksilver> Twey: only in the same sense that an aeroplane is "WTF" if you've never soon one before.
23:30:54 <quicksilver> s/soon/seen/
23:31:13 <dons> Lemmih: will these design decisions be documented on the happs blog? the one that will be syndicated to planet haskell?
23:31:13 <Twey> quicksilver: Like 'we're not going to include a template engine because you should be doing everything with JavaScript'?
23:31:25 <Lemmih> dons: There's a happs blog?
23:31:26 <dons> but haskell's got half a dozen templating systems now.
23:31:29 <Twey> Who needs accessibility anyway!
23:31:35 <dons> Lemmih: there *should* be a happs blog :)
23:31:39 <pumpkin> is there a typesafe sql-thingy in haskell?
23:31:44 <pumpkin> I'm so eloquent, wow
23:31:47 <dons> pumpkin: yeah, a couple.
23:32:01 <dons> haskelldb, takusen. some other thingies that give different safety properties.
23:32:02 <badkins> quicksilver: thx for the links & info
23:32:03 <quicksilver> pumpkin: haskelldb and takusen are along those lines aren't they?
23:32:05 <dons> nothing perfect, imo.
23:32:16 <dons> galois has used takusen on several occasions though
23:32:27 <Lemmih> Twey: HAppS doesn't include a template engine for the same reasons ghc doesn't include tetris.
23:32:28 <dons> i think deutsche bank has used it for something too.
23:32:40 <dons> Lemmih: hehe. right!
23:32:48 <dons> just like we use the xhtml or html libs *with* happs
23:32:54 <dons> so you would use your favourite templating engine
23:33:11 <pumpkin> is there a haskell html generator and a javascript generator? :P
23:33:14 <dons> happs supports using whatever system you want. pick one on hackage.
23:33:17 <dons> pumpkin: several.
23:33:21 <pumpkin> wow
23:33:26 <Twey> Lemmih: No, no, it's because they expect you to do everything with Javascript and XHR
23:33:26 <Lemmih> pumpkin: HSP is quite nice.
23:33:27 <dons> pumpkin: hackage.haskell.org, familiarise yourself :)
23:33:31 <Twey> Lemmih: It said so.
23:33:40 <pumpkin> so I can actually use strings only for things that should be strings
23:33:48 <pumpkin> that's nice
23:34:07 <dons> pumpkin: there's *lots* of web stuff for haskell.
23:34:11 <dons> it was super hot for the last year or two.
23:34:24 <Lemmih> Twey: That's one option. It may have been worded poorly.
23:34:25 <dons> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Web
23:34:30 <lambdabot> Title: HackageDB: packages by category
23:36:26 <Twey> Lemmih: No, it said almost precisely that.  They do seem to have removed it now, though.
23:36:48 <dons> Twey: "they" == Lemmih?
23:37:06 <Twey> Possibly
23:37:11 <Twey> Are you the sole author?
23:37:36 <dons> well, it has at times been a several man team
23:41:34 <Lemmih> I'm the main author.
23:41:37 <Lemmih> Not that I hold the copyright, though.
23:41:37 * Lemmih heads to bed.
23:42:25 <dons> night Lemmih
23:42:32 <dons> we'll take over the world tomorrow.
23:42:36 <dons> remind me.
23:44:39 <dons> night all.
23:51:01 <lispy> heh
23:57:00 <Twey> 'What'll we do tonight dons?!' 'The same thing we do every night, Lemmih... TRY TO TAKE OVER THE WORLD!'
23:57:13 <dolio> @brain
23:57:13 <lambdabot> Uh, I think so, Brain, but balancing a family and a career ... ooh, it's all too much for me.
23:57:31 <Twey> Hahaha
