00:20:41 <jsn> is there a way to use indentation in GHCi?
00:20:45 <jsn> i think i heard it was added
00:20:51 <jsn> recently
00:22:15 <Baughn> jsn: http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-stmts
00:22:27 <lambdabot> Title: 3.4.�Interactive evaluation at the prompt, http://tinyurl.com/6j5p63
00:22:49 <Baughn> jsn: Not that it's a good idea. You still should reload a file of definitions for anything complex.
00:23:40 <jsn> well, i can put this stuff in the file...
00:25:38 <jsn> Baughn: i'm putting it in a GHCi file
00:26:07 <Baughn> jsn: What exactly is a ghci file?
00:26:13 <jsn> .ghci
00:26:29 <Baughn> Umh. I meant a .hs file
00:26:55 <jsn> Baughn: you can't get a workable debug environment that way, though
00:27:05 <BeelsebobWork> hmm... something tells me my normal calculations are err... wrong http://www.cs.kent.ac.uk/people/rpg/tatd2/normals.png
00:27:24 <jsn> i need a bunch of unexported definitions available, for example
00:27:50 <Baughn> BeelsebobWork: Is it /supposed/ to be skewed and upside down?
00:28:18 <BeelsebobWork> Baughn: it's okay -- it's spinning around -- what's wrong is that every single surface has got some uhh... interesting... normal vectors
00:30:36 <profmakx> can you paste the code that computes the normal vectors?
00:31:07 <profmakx> your normal vectors seem to be dependent on the shape you put them on
00:31:08 <BeelsebobWork> http://hpaste.org/11777
00:31:23 <Baughn> jsn: Actually, you can have ghci ignore the export declaration of a .hs file just fine
00:31:24 <BeelsebobWork> it works for smoothing groups though, so I'm thinking I have an off by one indexing into the normal buffer
00:31:32 <Baughn> jsn: http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-scope
00:31:33 <lambdabot> Title: 3.4.�Interactive evaluation at the prompt, http://tinyurl.com/6j5p63
00:31:41 <jsn> Baughn: well, i am debugging module A
00:31:56 <jsn> and i need a bunch of definitions to do it
00:32:08 <jsn> those definitions rely on unexported things
00:32:28 <jsn> so that second file is not a valid haskell file and can not be loaded
00:33:08 <Baughn> Why don't you stick the debugging definitions inside A?
00:33:18 <jsn> because that is wrong?
00:33:25 * Baughn disagrees
00:33:32 <jsn> why would i touch a source file for that?
00:33:59 <Baughn> So you can keep a proper API?
00:34:01 <jsn> maybe i want to get my debug info back some day, too -- i keep it in a place clearly marked as such
00:34:07 <jsn> what?
00:34:18 <jsn> what does the debug info have to do with the API?
00:34:25 <Baughn> Using /unexported/ definitions is wrong
00:34:41 <jsn> not when you are debugging them!
00:35:01 <jsn> i just need to use them to make a bunch of intermediate stuff
00:35:04 <Baughn> How about just temporarily removing the export statement while you're working on it?
00:35:30 <jsn> Baughn: well, why do that when i can use a .ghci file?
00:36:12 <Baughn> jsn: You started off by complaining about the limits of that?
00:36:17 <jsn> no
00:36:21 <jsn> i said, that is great
00:36:43 <jsn> because i can use a    .ghci    file to create boilerplate with unexported definitions
00:36:52 <jsn> unlike a    .hs    file
00:37:20 <profmakx> BeelsebobWork, i am still to sleepy, i cant spot a mistake right now
00:37:23 * Baughn wonders how the great old ones would do it
00:37:33 <BeelsebobWork> profmakx: in all honesty, I doubt the error is in that code
00:37:44 <jsn> Baughn: not use some silly language with a module system?
00:37:46 <BeelsebobWork> because as I say, it works for smoothing groups
00:37:57 <BeelsebobWork> just not for unsmoothed surfaces
00:38:02 <Baughn> jsn: I was referring to dons and his kin. :P
00:38:02 <sjanssen> I would use CPP.  #ifdef DEBUG export everything
00:38:26 <sjanssen> if DEBUG is not defined, export the usual stuff
00:38:47 <jsn> bleah
00:39:03 <sjanssen> the solution seems more sane than scripting GHCI
00:39:15 <jsn> using separate files is always better
00:39:17 <sjanssen> it gives you actual valid Haskell code to work with
00:39:37 <jsn> i don't want that -- i just want some interactive definitions
00:39:41 <sjanssen> jsn: yes, with the CPP method you'd still stick your tests in a separate module
00:40:23 <jsn> so how do i load it in GHCi, then?
00:40:36 <sjanssen> ghci -cpp -DDEBUG Module.hs
00:41:02 <jsn> sjanssen: okay, well
00:41:18 <jsn> so far, i can not see what that buys me, over a scriptable GHCi
00:41:26 <jsn> it involves more "source files"
00:41:35 <jsn> that are hiding in with the real source
00:41:42 <sjanssen> jsn: support for the full range of Haskell, including indentation?
00:41:47 <jsn> it involves more complicated command line
00:42:07 <jsn> sjanssen: well, that is a good point
00:42:13 <jsn> the indentation is sweet
00:42:28 <sjanssen> jsn: the test stuff doesn't have to be "hiding in with the real source"
00:42:35 <jsn> however, it is desirable to script ghci for other reasons
00:42:51 <sjanssen> you can put the test module in an entirely different directory if you want
00:43:06 <jsn> for example, to make sure i have a whole bunch of different modules in scope when i am doing my spelunking
00:43:47 <sjanssen> that is the sort of thing scripting ghci might be useful for
00:44:14 <sjanssen> but I wouldn't put many function definitions in a .ghci, it just isn't sane
00:44:15 <jsn> so since i'm going to do it anyways, might as well put all my debug boilerplate in there as well
00:44:26 <jsn> sjanssen: uh, well
00:44:31 <sjanssen> jsn: what exactly is "debug boilerplate"?
00:44:44 <jsn> making a bunch of intermediate values
00:44:50 <jsn> and seeing what they look like
00:45:33 <jsn> and also, to have them available for feeding to the unexported functions to find out, for example, why they mysteriously crash
00:45:40 <profmakx> hm
00:46:16 <jsn> which is what i was doing just now, and then this conversation happened
00:46:33 <jsn> so now at least, i can recover all my boilerplate when the interpreter bails
00:54:26 <jsn> so, i seem not to understand    runInteractiveProcess    very well
00:54:38 <jsn> when i run it with arguments, it just fails
00:55:42 <sjanssen> jsn: which arguments?
00:56:01 <jsn> sjanssen: the "command line" arguments
00:57:16 <sjanssen> jsn: we'd need more information to know what you're having trouble with
00:57:26 <jsn> aye
00:57:32 <jsn> i am trying to collect it
01:05:17 <ketil> Good morning!  Printf appears to be slow - what's the fastest way to print out something like "%s\t%d\t%s\t%1.2f"
01:06:34 * ketil 's program currently spends 20 minutes of its running time just printf'ing - it's a big data set. :-)
01:08:47 <jsn> http://hpaste.org/11778
01:09:12 <jsn> the one that crashes is at top, the one that works, below
01:09:31 <jsn> i'm using bytestrings for all input and output
01:09:35 <jsn> lazy bytestrings
01:09:55 <sjanssen> putStr $ intercalate "\t" [s1, show d, s2, showFFloat (Just 2)] -- like this, ketil?
01:10:25 <ketil> will it be faster than the printf?  I have my doubts...
01:10:41 <ketil> sjanssen, ...but if you think so, I can give it a whirl.
01:10:53 <sjanssen> ketil: well, it won't have to interpret a format string every single time
01:11:20 <sjanssen> ketil: and if intercalate is slow, use concat instead
01:11:33 <ketil> Okay.  BRB.
01:12:00 <sjanssen> jsn: probably just some buffering stuff
01:12:20 <jsn> ah
01:12:31 <jsn> so, do i use hFlush?
01:12:47 <jsn> why does the presence of command line arguments affect it?
01:13:16 <sjanssen> jsn: it is probably the "-l" argument in particular that causes the problem
01:13:56 <ketil> @hoogle showFFloat
01:13:57 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
01:14:10 <ketil> ...but where?
01:14:16 <jsn> sjanssen: well, if i use invalid arguments, there is also a crash
01:14:23 <sjanssen> "waitForProcess p; hGetContents o" is potentially dangerous, and can cause deadlock
01:14:40 <ketil> sjanssen, where can I find showFFloat?
01:14:42 <jsn> would deadlock result in a crash, though?
01:14:44 <sjanssen> jsn: might be SIGPIPE due to the pipes filling
01:14:53 <sjanssen> ketil: hoogle prefixes the module name, Numeric
01:15:13 <sjanssen> jsn: the default handler for SIGPIPE will call exit(), yes
01:17:47 <ketil> sjanssen, yay!  That was a bit faster - 30%, maybe.
01:18:23 <sjanssen> ketil: how big are the strings you're printing?
01:18:54 <ketil> sjanssen, each of them is just a line, but I'm printing about 130K*168 of them.
01:19:14 <ketil> sjanssen, I'll try bytestrings - some of my raw data are bytestrings anyway, which I now unpack.
01:19:30 <ketil> ....which seems like a waste :-)
01:19:47 <sjanssen> ketil: yes, it is a pretty massive waste
01:19:57 <ketil> heh.
01:23:30 <jsn> interesting, any invalid options cause GHCi to just quit
01:23:44 <jsn> even if i don't read back the ouput
01:24:12 <jsn> oh, i should check to see if i is open, i guess
01:24:35 <sjanssen> jsn: stderr is probably filling
01:24:57 <sjanssen> wc's stderr, to be specific
01:25:26 <jsn> sjanssen: oh, so then what?
01:25:37 <jsn> do i have to use    forkIO    or something?
01:26:18 <jsn> i don't actually understand what it means for a pipe to fill
01:26:26 <jsn> i assume they just got bigger
01:26:36 <sjanssen> they don't
01:26:45 <jsn> so, they have some size limit?
01:26:49 <sjanssen> right
01:27:14 <jsn> well, the size of the error output would be on the order of 80 bytes
01:27:20 <jsn> that is enough?
01:27:34 <sjanssen> nah, that should be small enough
01:27:51 <jsn> but, let's say it wasn't
01:27:56 <sjanssen> you might try running this in GHC proper, rather than ghci
01:28:05 <jsn> then i have to let the error out, now and again?
01:28:52 <sjanssen> the proper way to do this is to forkIO two threads to read stdin and stderr, and waitForProcess in your main thread
01:29:01 <jsn> ah
01:29:02 <jsn> okay
01:29:10 <jsn> sjanssen: thank your for explaining
01:29:16 <jsn> s/your/you/
01:29:26 <sjanssen> and always use the -threaded option when working with processes
01:29:31 <jsn> ah
01:29:39 <jsn> this is with the RTS?
01:29:42 <sjanssen> jsn: oh, I bet your problem is simpler than we think
01:29:54 <jsn> +RTS -threaded -RTS
01:29:59 <jsn> sjanssen: is it?
01:30:07 <jsn> how simple?
01:30:07 <sjanssen> jsn: wc won't read any input when bad flags are given
01:30:12 <jsn> right
01:30:16 <sjanssen> so your program is blocking trying to do output
01:30:21 <jsn> aha
01:30:28 <sjanssen> I'm guessing your ByteString is fairly large?
01:30:31 <unenough> argh, learning haskell has caused me to try to write haskellian in python
01:30:37 <jsn> no, just four bytes
01:31:07 <sjanssen> jsn: -threaded is a compile/link option (it is the default with ghci)
01:31:17 <jsn> sjanssen: oh, good
01:32:00 <jsn> in cabal, do i have to put it in    ghc-options   or can it go somewhere else?
01:32:05 <unenough> f.g  x = f(g(x))?
01:32:10 <unenough> or g(f(x)) ?
01:32:26 <jsn> unenough: the first one
01:32:26 <czShadoW> @src (.)
01:32:27 <lambdabot> (f . g) x = f (g x)
01:32:32 <unenough> ah thanks
01:32:35 <sjanssen> unenough: neither
01:32:39 <dcoutts> jsn: ghc-options
01:32:42 <unenough> yeah, missing paren's
01:32:48 <sjanssen> f . g x = f . (g x)
01:32:53 <unenough> :)
01:33:05 <ketil> @hoogle Double -> ByteString
01:33:06 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
01:33:06 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
01:33:06 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
01:33:20 <ketil> ...uh, not quite.
01:35:03 <BeelsebobWork> profmakx: not quite what I thought -- I was building my normal buffer backwards -- so the 3,000,000,000th polygon was getting the 1st polygon's normals, etc
01:35:14 <profmakx> ouch
01:35:20 <jsn> sjanssen: when compiled, it doesn't crash
01:35:28 <jsn> just in the interpreter
01:35:34 <BeelsebobWork> profmakx: now to wait a while and see if it renders the big model right
01:35:50 <BeelsebobWork> it takes about 40 minutes to load it -- having said that -- maya just crashes with an out-of-memory error
01:35:53 <profmakx> BeelsebobWork, what kind of program are you developing there?
01:35:54 <BeelsebobWork> so I'm winning there :)
01:35:59 <BeelsebobWork> profmakx: the obj library atm
01:37:11 <profmakx> BeelsebobWork: 40 minutes to load would be quite a stretch for my patience :)
01:37:25 <BeelsebobWork> profmakx: yeh, but this is kinda a killer model
01:37:28 <BeelsebobWork> 3 million polygons
01:37:34 <BeelsebobWork> it actually does kill maya
01:37:37 <BeelsebobWork> after about 20 minutes
01:37:51 <BeelsebobWork> and this is maya's native format
01:38:02 <ketil> I refuse to believe there's no function to format numeric data to bytestrings.  But I can't find any?!
01:38:29 <jsn> ketil: look at Data.BInary?
01:38:32 <BeelsebobWork> ketil: sure there is -- put
01:38:52 <ketil> Ah, right.
01:38:58 <ketil> Or 'encode'.
01:38:59 <jsn> sjanssen: you're right about waitForProcess
01:39:26 <jsn> sjanssen: with    tee    , for example, it totally got stuck
01:40:00 <sjanssen> ketil: binary won't give you a human readable format, though
01:40:05 <BeelsebobWork> profmakx: also, lots of optimisation still to come, and for models which maya does load, I can already get them loaded faster
01:40:16 <ketil> Ah, right, that should be 'ah, wrong'
01:40:33 <ketil> I want - roughly - pack . show
01:40:39 <profmakx> BeelsebobWork: very goof
01:40:41 <ketil> which I can use, but then it's too slow.
01:40:42 <profmakx> -f+d
01:42:55 <sjanssen> ketil: bind to C?
01:43:01 <sjanssen> ketil: or avoid packing?
01:47:06 <ketil> sjanssen, HAH!  Hand rolled a formatting function, and cut the time down by 60% again.
01:51:33 <ketil> ....but now we run out of memory.  Oh well, back to debugging.  At least we run out of memory *fast*. :-/
02:00:15 <ketil> hm.. turns out using strict bytestrings for output isn't always an advantage... switched to lazy.
02:01:08 <slash0r> Why does this declaration of custom datatypes not work? http://hpaste.org/11779 The problem is the definition of Shape which is supposed to be either a triangle, box or circle
02:01:13 <ketil> 20225352 lines printed in about a minute.  yay me!
02:03:08 <ketil> (Or mostly "yay sjanssen" and "yay bytestring".  Thanks guy and lib!)
02:09:16 <quicksilver> slash0r: you need a constructor in the Shape
02:09:17 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
02:09:26 <quicksilver> slash0r: well, actually, 3 constructors
02:09:39 <quicksilver> data Shape = T Triangle | B Box | C Circle
02:09:43 <quicksilver> @messages
02:09:44 <lambdabot> mmorrow said 13h 44m 30s ago: (in case you miss my /msg) i just updated the javascript QQ for 6.10. the js-qq repo, the modified WebBits repo, and a random sample of the quoter's use are in this dir:
02:09:44 <lambdabot>  http://moonpatio.com/repos/js-qq/ . each darcs repo contains haddock docs as well. :)
02:13:58 <slash0r> quicksilver, what are T, B and C then? Constructures?
02:14:28 <RayNbow> http://www.haskell.org/ghc/docs/latest/html/libraries/ <-- hmm, updated docs... but they're missing source code links :p
02:14:28 <quicksilver> slash0r: yes.
02:14:29 <lambdabot> Title: Haskell Hierarchical Libraries
02:14:38 <quicksilver> slash0r: otherwise you can't tell which is which.
02:14:58 <quicksilver> slash0r: the syntax of the language needs a way to distinguish the cases, that's what the constructor is for.
02:15:19 <quicksilver> It's common, although potentially confusing, to re-use type names as constructor names.
02:17:48 <slash0r> ah I think I get it now, thank you very muc, quicksilver
02:21:24 <rog> is there a standard type for a tuple with members of the same type? e.g. data Vec a = Vec a a. i've just been caught out by the fact that fmap show (5, 6) = (5, "6"). duh.
02:23:12 <quicksilver> rog: no.
02:23:38 <quicksilver> indeed such things are not only Functor but Applicative too
02:24:41 <rog> i still haven't got my head around Applicative
02:24:47 <rog> let alone Arrows
02:25:09 <rog> i suppose it comes of not having found a need for it yet
02:25:36 <rog> 'cos functors and monads are fine, and they don't at first glance appear any less complicated
02:26:32 <quicksilver> well the instance of applicative for Vec is nice and easy to understand
02:26:42 <quicksilver> just pointwise application
02:26:51 <quicksilver> i.e. you can apply a Vec of functions to a Vec of results
02:27:11 <BONUS> Applicative is pretty cool for avoiding functions with numbers at the end :]
02:27:13 <quicksilver> rog: in that respect it's probably a nice simple Applicative to get started on ;)
02:28:05 <quicksilver> instance Applicative Vec where { pure x = Vec x x; (Vec f g) <*> (Vec x y) = (Vec (f x) (g y)) }
02:28:45 <Axman6> BONUS: you around?
02:28:47 <BONUS> > fmap (*) (Just 39) <*> Just 23
02:28:49 <lambdabot>   Just 897
02:28:50 <BONUS> yeah i just woke up
02:29:04 <BONUS> whats up
02:29:41 <Axman6> i was teachoing my girlfriend some haskell using your tutorial, and being an arts student, she noticed a grammarical error :O
02:29:47 <Axman6> teaching*
02:29:55 <BONUS> hahah awesome
02:30:03 <BONUS> which grammarical error is that
02:30:04 <quicksilver> well there is a grammatical error in the title :P
02:30:06 <BONUS> did she tell you
02:30:06 <BONUS> haha
02:30:12 <quicksilver> I'm assuming that's deliberate ;)
02:30:16 <Axman6> "But when we call it like that, there may be some confusion as to which numbers is doing the division and which one is being divided." s/numbers/number
02:30:22 <BONUS> i really have to fix that error in the title on of these days :]
02:30:27 <BONUS> and in the domain name
02:30:35 <opqdonut> which is your tutorial?
02:30:37 <rog> > fmap (*) Nothing <*> Just 34
02:30:38 <lambdabot>   Nothing
02:30:39 <opqdonut> +one
02:30:41 <BONUS> ah, excellent, i'll fix that right away
02:30:44 <BONUS> @where LYAH
02:30:44 <lambdabot> www.learnyouahaskell.com
02:30:47 <BONUS> ^
02:30:51 <opqdonut> :D
02:31:09 <Badger> :D
02:32:26 <Axman6> btw, your tutorial makes for some extremely cute concentration faces :P
02:32:54 <BONUS> haha awesome, glad to be of service
02:32:58 <opqdonut> :D
02:32:59 <Axman6> oh, and the topic isn't a valid list here in #haskell!
02:33:04 <opqdonut> Axman6: pics please ;)
02:33:09 <Axman6> ["GHC 6.10 is out!" http://twurl.cc/6wr, "The Haskell programming language"...
02:33:10 <lambdabot> Title: [Haskell] ANNOUNCE: GHC version 6.10.1
02:33:23 <Axman6> opqdonut: i shall get some sometime
02:33:34 <rog> ok, i think i get it now. finally. thanks.
02:33:35 <Axman6> i'll find a devious way to use the iSight in my MBP
02:36:33 <yitz> Axman6: right! it should be: ["GHC 6.10 is out!" - http://twurl.cc/6wr, "The Haskell programming language"...
02:36:34 <lambdabot> Title: [Haskell] ANNOUNCE: GHC version 6.10.1
02:36:49 <Axman6> - http://twurl.cc/6wr is not a string!
02:36:50 <lambdabot> Title: [Haskell] ANNOUNCE: GHC version 6.10.1
02:37:10 <Axman6> > ["GHC 6.10 is out!" - http://twurl.cc/6wr, "The Haskell programming  language"]
02:37:11 <lambdabot>       precedence parsing error
02:37:12 <lambdabot>          cannot mix `(://)' [infixl 9] and `(....
02:37:12 <lambdabot> Title: [Haskell] ANNOUNCE: GHC version 6.10.1
02:37:24 <yitz> Axman6: right, its 4 variables and a number, separated by operators
02:37:25 <Axman6> > ["GHC 6.10 is out!" http://twurl.cc/6wr, "The Haskell programming  language"]
02:37:25 <IsoPallo_> Hmm... Do I have a reason to upgrade my ghc from 6.8 to 6.10?
02:37:26 <lambdabot>       precedence parsing error
02:37:26 <lambdabot>          cannot mix `(://)' [infixl 9] and `(....
02:37:27 <lambdabot> Title: [Haskell] ANNOUNCE: GHC version 6.10.1
02:37:48 <yitz> you need some fixity declarations
02:38:49 --- mode: ChanServ set +o quicksilver
02:38:51 --- topic: set to '["GHC 6.10 is out! - http://twurl.cc/6wr", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by quicksilver
02:38:57 --- mode: quicksilver set -o quicksilver
02:39:02 <IsoPallo_> Will you people start writing incompatible libraries again as with 6.2?
02:39:03 <Axman6> thankyou quicksilver
02:39:07 <quicksilver> Axman6, yitz : better? :)
02:39:13 <Axman6> much :)
02:39:26 <yitz> quicksilver: aw, boring to lex
02:40:07 <yitz> IsoPallo_: it shouldn't be as bad. maybe a little. each time an improvement.
02:45:58 <IsoPallo_> I see there are some language extensions again...
02:48:22 <yitz> IsoPallo_: not too many this time.
02:48:39 <yitz> associated types should actually work now.
02:49:15 <yitz> you can now use SQL in list comprehensions, which is pretty controversial.
02:49:44 <yitz> some attempts to make improvements to record syntax, we'll see if it helps.
02:49:59 <TSC> Is there an easy way to fix this when trying to install ghc-core via cabal: Module `System.Process' does not export `ReadProcess'
02:50:00 <yitz> let's see, what else...
02:50:18 <TSC> (readProcess, not ReadProcess)
03:11:31 <Axman6> hmm, i think that Data.Set needs a nice HOpenGL display interface ...
03:12:08 <Axman6> showTree doesn't cut it
03:15:32 <rog> has anyone here used MonadRandom? how am i supposed to use evalRand when the Rand constructor isn't exported?
03:16:36 <EvilTerran> evalRand :: (RandomGen g) => Rand g a -> g -> a
03:17:09 <EvilTerran> you don't need the constructor to use that; you need the type, but that *is* exported
03:18:41 <rog> ah yes, thanks, i'd just worked out  i was being stupid. i'd put the arguments in the wrong order and then got confused.
03:19:48 <profmakx> i just parsed "evilRand"
03:21:09 <mapreduce> Me too.
03:22:08 <nominolo|msr> every monad needs an evil function
03:22:19 <quicksilver> evilPerformIO
03:22:23 <quicksilver> immoralInterleaveIO
03:22:31 <quicksilver> thirdcircleofhellInlineIO
03:22:43 <therp> why doesn't cabal automatically invoke GHC with -main-is Foobar when .cabal contains Main-Is: Foobar.hs?
03:22:51 <Axman6> preemptivelyPerformIOTwice
03:23:02 <ivanm> quicksilver: how does evilPerformIO differ from unsafePerformIo?
03:23:09 <nominolo|msr> we just found a bug in GHC's GC that was a missing line 666
03:23:13 <ivanm> the former also sacrifices a virgin to the dark lord of the pit?
03:23:14 <Axman6> ivanm: doesn't do what its told
03:23:19 <ivanm> Axman6: ahhh
03:23:20 <nominolo|msr> (of course it moved in between edits)
03:23:24 <ivanm> it _always_ launches missiles?
03:23:27 <Axman6> yes
03:24:10 <Axman6> unsafePerformIO f = f >> return (), evilPerformIO _ = unsafeLaunchMissiles >> return ()
03:24:11 <nominolo|msr> therp: pretty sure it does
03:24:25 <nominolo|msr> well, with -main-is Foobar.hs
03:24:36 <nominolo|msr> i think -main-is expects a filename
03:24:39 <ivanm> Axman6: well, that's not right...
03:24:48 <ivanm> since your defs remain in the IO monad...
03:24:52 <ivanm> @src unsafePerformIO
03:24:52 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
03:25:05 <nominolo|msr> @src lazy
03:25:05 <lambdabot> Source not found.
03:25:06 <ivanm> realWorld? it actually uses the realWorld? :o
03:25:11 <Axman6> i don't care what the actual def is :P
03:25:15 <ivanm> wow, ghc is capable of exiting the matrix... >_>
03:25:21 <ivanm> Axman6: heh
03:25:37 <Axman6> :t lazy
03:25:38 <lambdabot> Not in scope: `lazy'
03:25:43 <Axman6> bah!
03:25:44 <nominolo|msr> ivanm: it uses it to create a dependency
03:25:54 <nominolo|msr> ivanm: so that IO actions are sequenced
03:26:06 <quicksilver> it's not haskell.
03:26:15 <quicksilver> it's a special purpose GHC language
03:26:19 <quicksilver> which *looks* a lot like haskell.
03:26:30 <quicksilver> but has operational semantics such that IO works.
03:26:38 <nominolo|msr> it's GHC Haskell
03:26:39 <ivanm> quicksilver: what, realWorld?
03:26:45 <therp> nominolo|msr: ./Setup.lhs build -v doesn't list any
03:26:57 <ivanm> I never said it was haskell, just ghc...
03:26:58 <quicksilver> ivanm: yes, realWord# and the case, and "lazy"
03:27:10 <quicksilver> I didn't say you did say it was.
03:27:14 <quicksilver> I was just making an observation.
03:27:18 <quicksilver> not contradicting anyone.
03:27:19 <therp> nominolo|msr: and -main-is requires a Module name iirc
03:27:20 <ivanm> *nod*
03:27:24 <ivanm> my apologies then
03:28:18 <nominolo|msr> therp: oh, right.  could be that it doesn't use it because it wouldn't work with other implementations
03:28:20 <therp> nominolo|msr: ah could also be a function http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#options-linker
03:28:32 <lambdabot> Title: 5.10.�Options related to a particular phase, http://tinyurl.com/smq5n
03:29:07 <nominolo|msr> i guess you could cheat (non-portably) by using ghc-options:
03:29:32 <therp> nominolo|msr: well, cabal knows that it's using GHC, so it should use it properly. also it doesn't work without the flag (unless Main-Is: Main.hs)
03:29:51 <therp> nominolo|msr: that's what I did.. and I don't mind.
03:30:18 <nominolo|msr> therp: no, other compilers cannot emulate this functionality, so it's inherently non-portable
03:30:45 <nominolo|msr> you could only use that function/module as Main.main if you were on GHC
03:31:18 <nominolo|msr> cabal tries hard not to tie itself too closely a particular implementation
03:32:11 <nominolo|msr> therp: Main-is: Foo.hs works if foo starts with "module Main where" ..
03:34:22 <therp> nominolo|msr: but shouldn't Foo.hs start with module Foo where?
03:35:27 <Axman6> anyone willing to help me debug a very odd error i'm having with some STM/Concurrent stuff? the code is http://hpaste.org/11780 . and when i run ./STMtree 75 42, i get a result, but when i run ./STMtree 75 45, i get Nothing
03:36:02 <Axman6> which makes no sense, since any tree created to a greater depth should contain all the same elements
03:36:47 <Axman6> 'putStrLn $ showTree' sh should probably be commented out
03:36:47 <nominolo|msr> therp: only if it is imported by other modules
03:40:06 <Axman6> hmm, i just realised what i'm doing here is fundamentally flawed slightly
03:41:47 <Axman6> and that would be why my program's going wrong! whoot
04:11:24 <jeffz> http://hpaste.org/11782 - anyone know why this might be happening? trying to use FTGL but I get linker errors
04:14:18 <quicksilver> jeffz: looks like your ftgl is broken
04:14:21 <quicksilver> wrong link flags or something
04:14:23 <quicksilver> :(
04:21:55 <ketil> Another Data.Binary questions - it seems that my binary parser consumes increasing amounts of memory as it moves along.  I thought parsing (i.e. get'ting of individual pieces of data) would be strict.  Anything in particular that would hang onto the input?  GetByte(s|Sting) maybe?
04:22:52 <jeffz> quicksilver: hmm, yes, seems the one that ships with Ubuntu 8.04 is too old
04:22:57 <jeffz> quicksilver: thanks
04:24:15 <quicksilver> ketil: only if you hang onto the result, as far as I know
04:24:19 <quicksilver> (directly or indirectly etc)
04:25:11 <ketil> quicksilver, hmm.. I do hang on to it.  Maybe if I just add a bang to that member of the data structure?
04:25:41 <ketil> (which would keep the chunk around, but not the subsequent chunks, like an unevaluated member would)
04:26:02 <ketil> Or I could just use copy as well.
04:26:40 <quicksilver> well presumably you hang onto it because you want it
04:26:47 <quicksilver> but then don't be surprised if memory increases :P
04:27:39 <quicksilver> you could certainly make sure you force it before you store it
04:28:12 <Guest62243> hi guys, I'm kinda stuck on the first of 99 problems for haskell - create a function to extract the last element of a list. I want to write: myLast = foldr (\a b -> b) <something that stands for any type>
04:29:12 <Guest62243> what should I use? Is there some elements like Java's "null"?
04:31:00 <Philonous1> >foldr (flip cons) [] [1,2,3,4,5]
04:31:09 <Philonous1> > foldr (flip cons) [] [1,2,3,4,5]
04:31:10 <lambdabot>   Not in scope: `cons'
04:31:22 <Philonous1> > foldr (flip const) [] [1,2,3,4,5]
04:31:23 <lambdabot>   []
04:31:34 <profmakx> > head . reverse [ 1,2,3,4,5 ]
04:31:35 <lambdabot>   Couldn't match expected type `a -> [a1]'
04:32:42 <Philonous1> > foldl (flip cons) [] [1,2,3,4,5]
04:32:43 <lambdabot>   Not in scope: `cons'
04:32:47 <Philonous1> > foldl (flip const) [] [1,2,3,4,5]
04:32:48 <lambdabot>       No instance for (Num [a])
04:32:48 <lambdabot>        arising from the literal `1' at <inter...
04:32:58 <profmakx> > (head . reverse) [ 1,2,3,4,5 ]
04:33:00 <lambdabot>   5
04:33:23 <Guest62243> well I would like to fold the list
04:34:09 <Philonous1> > foldl (flip const) undefined [1,2,3,4,5]
04:34:10 <lambdabot>   5
04:34:19 <Philonous1> Aha
04:34:22 <Guest62243> wow
04:34:31 <Guest62243> thanks a million!
04:34:41 <profmakx> i like mine better ;)
04:34:48 <Philonous1> Guest62243: Problem is, undefined is the only member of _every_ type
04:34:52 <Guest62243> :t undefined
04:34:52 <lambdabot> forall a. a
04:34:54 <shapr> After my overnight build everything attempt, ghc-pkg -l|wc -l gives me 152.
04:35:31 <profmakx> you sure have a load of packages there shapr :)
04:35:49 <Guest62243> Philonous1: is it a problem?
04:36:06 <Philonous1> Kind of. I wouldn't use undefined in a real programme
04:36:29 <shapr> profmakx: Yeah, lots of new toys to play with!
04:37:18 <Guest62243> Philonous1: I guess it would scare me to read undefined in some code I wrote 3 months ago :D
04:37:37 <Axman6> me too
04:37:56 <Philonous1> I think it is there to make expressions type-check that wouldn't otherwise. Like when you are building the skeleton for your programme and just don't want to care right now about some function
04:37:57 <Philonous1> Exactly
04:38:09 <Saizan_> you never used phatom parameters i guess? ;)
04:38:14 <Saizan_> "phantom"
04:38:28 <Guest62243> Saizan_: no, what are they?
04:38:43 <Guest62243> Philonous1: I see
04:39:04 <Philonous1> > undefined
04:39:06 <lambdabot>   * Exception: Prelude.undefined
04:39:15 <Axman6> @src undefined
04:39:16 <lambdabot> undefined =  error "Prelude.undefined"
04:39:37 <Saizan_> Guest62243: they are used when you've to "pass" types to a function but you don't have any corresponding value
04:40:04 <Axman6> @src []
04:40:04 <lambdabot> data [] a = [] | a : [a]
04:40:18 <Saizan_> ?type sizeOf
04:40:19 <lambdabot> Not in scope: `sizeOf'
04:40:26 <ski> Philonous1 : now do `last' with `foldr'
04:40:27 <Saizan_> ?hoogle sizeOf
04:40:27 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
04:40:27 <lambdabot> System.Posix.Internals sizeof_stat :: Int
04:40:35 <Guest62243> Saizan_: are they like prolog's _ ?
04:40:57 <znutar_> @src error
04:40:58 <lambdabot> error s = throw (ErrorCall s)
04:41:10 <ski> Guest62243 : not exactly, but sometimes they can fill a similar role
04:41:12 <Axman6> @src throw
04:41:12 <lambdabot> throw exception = raise# exception
04:41:22 <Axman6> @src raise#
04:41:22 <lambdabot> Source not found. Wrong!  You cheating scum!
04:41:29 <Axman6> damn, caught me!
04:41:50 <znutar_> I was hoping for turtles all the way down
04:42:13 <Saizan_> Guest62243: e.g sizeOf :: Storable a => a -> Int, sizeOf takes a value that never inspect just so that the typechecker can determine which instance of Storable it must use
04:42:18 <ski> Guest62243 : in prolog, if you pass `_', then the predicate may unify that with anything it likes, and everything is fine with that .. but if the function you pass `undefined' to in haskell ever tries to evaluate it, you'll get an run-time abortion/error (or exception, in GHC)
04:43:09 <Guest62243> i see
04:43:33 <Badger> @src raise
04:43:33 <lambdabot> Source not found. There are some things that I just don't know.
04:43:34 <ski> Guest62243 : however, `_' as used on the left-hand side of defining equations in haskell are similar to `_' in Prolog (in "the other use of it")
04:43:37 <ski> @src head
04:43:37 <lambdabot> head (x:_) = x
04:43:37 <lambdabot> head []    = undefined
04:43:53 <ski> head([X|_],X).
04:44:23 <Guest62243> so I can't use it on the right hand side of a definition
04:44:50 <ski> (so the `_' here in Prolog is used in the head and not passed to a predicate in the body, that is similar to the use in Haskell just above)
04:44:55 <ski> exactly
04:45:16 <twb> Igloo: ping.
04:45:39 <twb> Igloo: what is your status re your Debian Haskell packages in general, and haskell-quickcheck specifically?
04:46:03 <ski> (some implementations may have an extension where you can use `_' in the definiens, but iirc it meant something else)
04:48:39 <ski> > fromJust (foldr (\x m -> m `mplus` Just x) Nothing (words "dum de dum"))
04:48:40 <lambdabot>   "dum"
04:48:57 <Guest62243> ok, thanks for the explanation. Back to the original question, how would you solve it
04:49:00 <Guest62243> argh
04:49:43 <Axman6> Guest62243: what's the issue?
04:49:54 <ski> `Nothing' there is like java's `null', in some sense .. i.e. you can use it in some situations where you'd use `null'
04:50:17 <ski> > fromJust (foldr (\x m -> m `mplus` Just x) Nothing (words ""))
04:50:18 <lambdabot>   "* Exception: Maybe.fromJust: Nothing
04:51:14 <Guest62243> Axman6: how can you find the last element of a list with a fold? I want to write something like: foldr (\a b -> b)  <some element subtype of any type like Java's null>
04:52:11 * Axman6 prefers last
04:52:32 <Saizan_> Guest62243: well, the most similar is undefined
04:52:38 <Guest62243> ski: what does mplus do?
04:52:49 <Axman6> @src Maybe mplus
04:52:50 <lambdabot> Nothing `mplus` ys = ys
04:52:50 <lambdabot> xs      `mplus` ys = xs
04:52:59 <Axman6> @src [] mplus
04:52:59 <lambdabot> mplus = (++)
04:53:02 <ski> ty
04:53:10 <Axman6> @src Either mplus
04:53:10 <lambdabot> Left _ `mplus` n = n
04:53:10 <lambdabot> m      `mplus` _ = m
04:53:20 <ski> Saizan_ : depends, i say
04:53:24 <Guest62243> thx
04:54:16 <ski> Guest62243 : i did one variant above (i first though Philonous1 was the one asking about how to do it with `foldr', not the OP, i.e. you)
04:54:59 <Philonous1> > foldr (\a k b -> k((flip const) b a)) id [1,2,3,4,5,6,7,8] undefined -- last in terms of foldr without Maybe
04:55:00 <lambdabot>   8
04:55:56 <Guest62243> I guess foldl was the right fold :D
04:56:13 <Guest62243> erm.. right = correct
04:56:15 <Igloo> twb: Not sure. I'm trying to get people to adopt them
04:57:34 <Guest62243> ok thanks a million guys, I will mull over your asnwers
04:58:00 * SamB_XP_ is a bit sad to find out that Michael Crichton did NOT die because he wrote a novel so scary it scared him to death, but from cancer instead
04:58:57 <Philonous> Guest62243: You can, btw. write every foldl as a foldr: foldl' f b0 as = foldr (\a k b -> k (f b a)) id as b0
04:59:25 <twb> Igloo: you should mark the packages as orphaned if you don't have time to look after them
04:59:42 <twb> "reportbug wnpp" and follow the prompts.
05:00:05 <SamB_XP_> Igloo: yeah, it's easier to get people to adopt packages that are in the orphanage
05:00:25 <SamB_XP_> or the SPCP, at least
05:00:32 <SamB_XP_> possibly even the RSPCP
05:00:43 <twb> More to the point, if I run wnpp-alert, it will not automatically tell me that haskell-quickcheck is orphaned -- I need to talk to humans to notice
05:01:05 <Guest62243> Philonous: I didn't know that
05:01:48 <SamB_XP_> how come nobody asks me what RSPCP stands for? does everyone already know ?
05:01:56 <twb> SamB_XP_: I just didn't care
05:02:05 <BeelsebobWork> nor me
05:02:07 <Philonous> Who cares about debin ;)
05:02:14 <Philonous> debian*
05:02:17 <twb> I care about Debian.
05:02:23 <SamB_XP_> Philonous: well, probably people who can spell
05:02:44 <SamB_XP_> anyway, RSPCP stands for Royal Society for the Prevention of Cruelty to Packages
05:03:05 <twb> I rule my packages with an iron fist
05:03:24 <SamB_XP_> twb: the RSPCP might not be happy with you
05:03:26 <twb> http://qa.debian.org/developer.php?package=darcs
05:04:19 <ski> > foldr (\a k b -> k a) id [1,2,3,4,5,6,7,8] undefined  -- Philonous
05:04:20 <lambdabot>   8
05:04:25 <twb> SamB_XP_: anyway, which monarch blessed your society?
05:04:59 <SamB_XP_> twb: I figured it was a UK/canada/australia
05:05:07 <SamB_XP_> thing
05:06:11 <twb> If an organization has "Royal" in its name, it basically means the King (or lately, the Queen) has said of it "yo dog, that shit be crackin'"
05:06:38 <Philonous> ski: yes, (flip const) b a is of course b, I didn't see that, thanks.
05:06:40 <twb> You don't get it automatically just for existing
05:06:50 <Philonous> a even
05:07:10 <Gabbie> 'lately'
05:07:14 <twb> Philonous: hedging your bets, eh?
05:07:23 <ski> > foldr (flip const) id [1,2,3,4,5,6,7,8] undefined
05:07:24 <lambdabot>   * Exception: Prelude.undefined
05:07:30 <ski> nay
05:08:40 <ski> > foldr (flip ((const . ) . id)) id [1,2,3,4,5,6,7,8] undefined
05:08:41 <lambdabot>   8
05:09:32 <Philonous> @pl \a k b -> k a
05:09:32 <lambdabot> (const .) . flip id
05:10:04 <Axman6> @src foldr
05:10:05 <lambdabot> foldr f z []     = z
05:10:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:21:50 <ben_h> hi all
05:21:55 <byorgey> hi ben_h
05:22:19 <ben_h> i'm wondering how to have ghc fork multiple compiles at once when invoked with --make (to take advantage of both my cores).
05:22:36 <ben_h> i couldn't find it in the help output - looking at the docs now.
05:23:15 <quicksilver> ben_h: you can't.
05:23:19 <quicksilver> (as far as I know)
05:23:20 <ben_h> oh :)
05:23:28 * ben_h likes an easy answer
05:23:46 <byorgey> that would be pretty cool though.
05:23:51 <ben_h> i assumed it would be easily parallelised since it's functional. or is ghc not implemented in haskell?
05:23:52 <quicksilver> use your other core by flashing a stupid flash game whilst waiting for compilation to complete
05:23:57 <quicksilver> more efficient.
05:23:59 <byorgey> hehe
05:24:01 <ben_h> :)
05:24:30 <byorgey> ben_h: ghc is indeed implemented in Haskell.
05:24:36 <quicksilver> parallelising the compilation of independent files would indeed be easy in principle
05:25:00 <quicksilver> doing some useful parallelisation of compilation within a particular file would be a different proposition.
05:25:07 <ben_h> yeah
05:25:31 <ben_h> i was thinking of it per-file, a la `make -jN`
05:25:51 * sw17ch has wanted what ben_h wants for a while.
05:26:06 <quicksilver> ben_h: http://hackage.haskell.org/trac/ghc/ticket/910
05:26:13 <lambdabot> Title: #910 (--make should have a -j flag for parallel building) - GHC - Trac
05:26:14 <quicksilver> jaffacake actually wrote it, once.
05:26:21 <quicksilver> but apparently didn't quite finish it off.
05:26:46 <ben_h> nice
05:26:51 <twb> quicksilver: ooh, sign me up for that ticket
05:26:55 <quicksilver> ;)
05:27:00 <quicksilver> sign yourself up, twb :P
05:27:04 <ben_h> so cabal is a package manager / builder hybrid?
05:27:06 <twb> It's blocking adoption of --make in Darcs.
05:27:09 <quicksilver> adding a CC is the recognised way of 'voting' for a ticket.
05:27:25 <quicksilver> (in the ghc trac)
05:27:27 <twb> quicksilver: that means learning to use the fucking trac web UI :-(
05:27:36 <quicksilver> it's not that painful, honestly
05:27:41 <twb> It is for me
05:28:02 <twb> I don't use a GUI browser so basically I'm treated like a second-class citizen
05:28:14 <therp> given a number between 0 and 255, how would I always print a two-digit hex number?
05:28:26 <quicksilver> twb: you makes your choices, you experiences the consequences.
05:28:28 * ben_h rocks -C to check out the C ghc generates
05:28:33 <ben_h> this is going to be epic.
05:28:51 <quicksilver> twb: I'm not going to criticise your choice :)
05:28:53 <yitz> > showHex 23 ""
05:28:54 <lambdabot>   "17"
05:29:00 <yitz> > showHex 235 ""
05:29:02 <lambdabot>   "eb"
05:29:05 <yitz> > showHex 2 ""
05:29:06 <lambdabot>   "2"
05:29:14 <yitz> oops. well...
05:29:16 <quicksilver> ben_h: well there is more than one part of the cabal ecosystem
05:29:25 <ben_h> > showHex 23 "what is this string for"
05:29:26 <lambdabot>   "17what is this string for"
05:29:27 <therp> yitz: yeah, I manually check the length of the result of showHex, but that's ugly
05:29:32 <ben_h> hmm
05:29:39 <quicksilver> ben_h: Cabal is a system for specifying dependencies of packages
05:29:45 <ben_h> ah ok
05:29:56 <ben_h> analogous to rubygems?
05:29:58 <quicksilver> ben_h: it is also a standard way of compiling pcorrectly specified projects
05:30:06 <twb> quicksilver: actually the real problem here is that I need to create and write down username and password details for every trac instance
05:30:10 <quicksilver> ben_h: it isn't, really, a package manager at all.
05:30:20 <byorgey> > printf "%2x" 2
05:30:20 <ben_h> quicksilver: mm
05:30:21 <lambdabot>   Add a type signature
05:30:24 <quicksilver> twb: I thought you could add a CC using a simple email address without using a trac UID
05:30:25 <byorgey> > printf "%2x" 2 :: String
05:30:26 <lambdabot>   " 2"
05:30:28 <quicksilver> twb: but I'm not sure.
05:30:29 <ski> > showString "0x" . showHex 23 . showString " = " . shows 23 $ ""
05:30:30 <lambdabot>   "0x17 = 23"
05:30:32 <byorgey> > printf "%02x" 2 :: String
05:30:34 <lambdabot>   "02"
05:30:37 <byorgey> therp ^^^
05:30:38 <twb> quicksilver: hmm, maybe you can.
05:30:39 <quicksilver> ben_h: the package management is actually simply part of GHC
05:30:41 <ben_h> imo ghc is a more appropriate place for the -j option than cabal.
05:30:47 <therp> byorgey: woot. thanks
05:30:50 <p_l> It would be nice if some Cabal packages didn't depend on bash
05:30:51 <quicksilver> ben_h: (ghc-pkg -l )
05:30:55 <ben_h> quicksilver: i noticed that before. that's really neat
05:30:58 <byorgey> printf does come in handy now and then =)
05:31:03 <twb> quicksilver: last time I checked you couldn't report a bug by email, without adding a bunch of nonstandard plugins into trac.
05:31:05 <yitz> > last . init . tails . ('0':) . showHex 2 ""
05:31:06 <lambdabot>   Couldn't match expected type `a -> [Char]'
05:31:12 <yitz> > last . init . tails . ('0':) $ showHex 2 ""
05:31:13 <lambdabot>   "2"
05:31:13 <quicksilver> ben_h: some parts of cabal provide interfaces to the underlying GHC package manager
05:31:20 <quicksilver> twb: yes, you definitely can't report bugs that way
05:31:24 <yitz> > last . init . init . tails . ('0':) $ showHex 2 ""
05:31:25 <lambdabot>   "02"
05:31:25 <quicksilver> twb: but I believe you can add ccs
05:31:28 <yitz> ha!
05:31:30 <therp> yitz: that's also a good trick :)
05:31:32 * twb hugs debbugs, roundup and rt.
05:31:40 <ben_h> quicksilver: am I right in saying that there's no need for anything like a Makefile, because ghc automatically just builds all the depended files for yoU?
05:31:43 <quicksilver> twb: on the GHC trac in particular, you can always report bugs as Guest/Guest
05:31:46 <quicksilver> ben_h: yes.
05:31:50 <quicksilver> ben_h: in the simple case.
05:31:58 <ben_h> so cool
05:31:59 <twb> quicksilver: heh, cool
05:32:00 <quicksilver> twb: precisely because creating accounts is annoying.
05:32:02 * byorgey stares at yitz's code
05:32:09 <yitz> hehe
05:32:25 <twb> But now: bedtime.
05:32:29 <twb> Honest.
05:32:34 <ben_h> oh wow. just did a ghc package install
05:32:36 * ben_h is impressed
05:32:37 <twb> Not like the bedtimes half and one hour ago
05:33:08 <ski>   showHex :: Integral a => a -> ShowS
05:33:16 <ski>   showString :: String -> ShowS
05:33:22 <byorgey> night twb
05:33:26 <ski>   shows :: Show a => a -> ShowS
05:33:30 <ski> @src ShowS
05:33:30 <lambdabot> type ShowS = String -> String
05:33:40 <ski> @src ReadS
05:33:40 <lambdabot> Source not found.
05:34:11 <ski>   type ReadS a = String -> [(a,String)]
05:34:22 <ski>   reads :: Read a => ReadS a
05:34:30 <ski>   showParen :: Bool -> ShowS -> ShowS
05:34:44 <p_l> Is anyone here programming in Haskell on Windows?
05:34:45 <ski>   readParen :: Bool -> ReadS a -> ReadS a
05:34:47 <ski> et.c.
05:37:05 <yitz> > let zeroFill n = reverse . take n . reverse . (repeat '0' ++) in zeroFill 2 . showHex 10 $ ""
05:37:11 <ben_h> i just installed cabal as per the README, finishing with `sudo ./Setup install`. that succeeded, but `cabal` isn't in my path and doesn't appear to be in the /usr/local/lib/Cabal-x.x.x tree.
05:37:14 <lambdabot>   mueval: Prelude.read: no parse
05:37:15 <ben_h> where's it hiding? :)
05:38:04 <yitz> > let zeroFill n = reverse . take n . (++ (reverse '0') . reverse .  in zeroFill 2 . showHex 10 $ ""
05:38:07 <lambdabot>   <no location info>: parse error on input `in'
05:38:08 <Heooo> IS there some latex tool to write Haskell and lambda calculus?
05:38:09 <quicksilver> ben_h: did you install "cabal" or "cabal-install"
05:38:16 <quicksilver> ben_h: it sounds like the former, to me.
05:38:21 <ben_h> so it was
05:38:41 <yitz> > let zeroFill n = reverse . take n . (++ (reverse '0') . reverse  in zeroFill 2 . showHex 10 $ ""
05:38:42 <lambdabot>   <no location info>: parse error on input `in'
05:38:42 <ben_h> ahh so cabal is the lib, and cabal-install is the commandline frontend?
05:38:49 <quicksilver> ben_h: right.
05:38:54 <Elly> Heooo: you could use LaTeX for that!
05:39:02 <ben_h> cool
05:39:04 <quicksilver> ben_h: rather more than that.
05:39:05 <Elly> you don't need any special tools really
05:39:09 <Heooo> Elly: some online tool for latex?
05:39:10 <yitz> > let zeroFill n = reverse . take n . (++ (reverse '0')) . reverse  in zeroFill 2 . showHex 10 $ ""
05:39:11 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
05:39:15 <quicksilver> ben_h: cabal-install knows how to fetch stuff from hackage via HTTP
05:39:24 <quicksilver> ben_h: and it knows how to check dependencies and fetch them too
05:39:29 <Elly> Heooo: online tool for LaTeX...?
05:39:37 <yitz> > let zeroFill n = reverse . take n . (++ (repeat '0')) . reverse  in zeroFill 2 . showHex 10 $ ""
05:39:39 <lambdabot>   "0a"
05:39:45 <Elly> Heooo: LaTeX is a program which you run locally which takes LaTeX source and generates other formats
05:40:04 <xhanjian> anyone knows why the getCh block for '\n' in ghc?
05:40:05 <Elly> Heooo: I don't know of any online LaTeX compilers, but you don't need one...there are ports for pretty much everything
05:40:07 <yitz> I obviously haven't been getting enough sleep.
05:40:18 <xhanjian> getCh defined here: http://www.cs.nott.ac.uk/~gmh/calculator.lhs
05:40:26 <Heooo> Elly: Yes, I once encountered an online latex tool.
05:40:36 <Elly> by "tool" you mean compiler, right?
05:40:41 <Elly> or do you mean something else?
05:41:37 * p_l would actually like to see a TeX "compiler"
05:41:45 <Heooo> Elly: Dunno. I think you know better than me in ubuntu. (I can do latex in mac but I do not have it now.)
05:41:54 <C-Keen> p_l: a tex compiler compiler?
05:42:13 <Elly> p_l: well...you could consider the 'latex' program itself to be a compiler, since it takes a source format (latex) and generates an object format (dvi)
05:42:13 <C-Keen> is tex turing complete?
05:42:19 <twb> Yes.
05:42:26 <C-Keen> well then
05:42:29 <p_l> C-Keen: AFAIK no one got crazy enough to compile tex source to different form, but it is turing complete
05:42:30 <twb> Especially since luatex
05:42:45 <Elly> p_l: the latex program itself compiles tex to a different form :P namely dvi
05:42:48 <twb> p_l: well, it has been done for postscript
05:43:36 <p_l> hmmm.... TeX -> DVI could be called a compilation process, yes, as DVI is based on a vm design....
05:43:50 <quicksilver> however DVI is not turing complete.
05:44:05 <quicksilver> so the output of TeX is not executable code in the normal sense
05:44:11 <quicksilver> so it's not a compiler in the normal sense.
05:44:20 <ski> (so maybe `presentation' or `rendering' is more appropriate than `compiling', here ?)
05:44:24 <yitz> @type hSetBuffering
05:44:26 <lambdabot> Not in scope: `hSetBuffering'
05:44:36 <ski> @hoogle hSetBuffering
05:44:36 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
05:44:40 <p_l> quicksilver: machines are not turing complete, as far as the definition goes. And DVI should be considered a command stream for a "DVI" machine
05:45:11 <yitz> xhanjian: so you need to add to run the line "hSetBuffering stdin NoBuffering".
05:45:25 <p_l> though I don't think DVI would qualify as "universal turing machine"
05:46:18 <xhanjian> yitz: thanks I'll try
05:46:25 <twb> Different DVI files could denote success/failure results of a machine, though
05:46:59 <Elly> in any case, compilers don't definitionally have to target a turing-complete language
05:47:22 <twb> +1
05:48:33 <quicksilver> p_l: most machines are turing complete under standard fudges.
05:48:45 <Elly> which fudges are these?
05:48:50 <quicksilver> Elly: definitionally, perhsaps not. But it is certainly a useful guideline.
05:49:00 <quicksilver> ignoring finiteness of memory
05:49:11 <yitz> can't you compile TeX to Postscript?
05:49:41 <ben_h> oh man, the install conventions are really nice
05:50:00 <ben_h> this just all feels really solid.
05:50:58 <twb> ben_h: that's due to the load-bearing lemmas
05:51:05 <ben_h> lol
05:51:32 <quicksilver> yitz: not directly no.
05:51:38 <quicksilver> yitz: the DVI can be converted to postcript.
05:52:03 <p_l> btw - has anyone managed to setup a development environment on win32 without MinGW/Cygwin?
05:52:24 <yitz> does it count as a compiler if only the intermediate language is not turing complete? :)
05:52:40 <Elly> no, of course not :P
05:53:29 <quicksilver> TeX can't generate an interesting fragement of postscript.
05:53:47 <quicksilver> In particular, the fragment of postscript generated by TeX (in this indirect way) is not a turing complete fragment.
05:53:52 <Elly> on the other hand, gcc can't generate an interesting fragment of machine code without going through as :P
05:54:29 <yitz> it can if you let me write my own dvi to ps converter.
05:54:35 <p_l> quicksilver: When you generate Postscript from DVI output, it would probably require quite an AI engine to create interesting Postscript
05:55:15 <quicksilver> yitz: well yes, that's true.
05:55:26 <yitz> dvitops doesn't preserve fonts? it's pre-rerasterized?
05:55:37 <yitz> pre-rasterized
05:55:45 <Elly> I do not think so
05:55:50 <Elly> the resulting postscript files are quite small
05:56:01 <Elly> they could be compressed bitmaps I guess
05:56:03 <Elly> but I'd be surprised
05:56:22 <yitz> so, if the text is coming through, it wouldn't take AI. it would require evil interpretation of document content though.
05:56:45 <quicksilver> traditionally, dvi contained bitmap fonts.
05:56:56 <p_l> yitz: DVI is more like something that a postscript engine would create
05:57:01 <Elly> this dvi file I am looking at right now has actual strings in it
05:57:10 <quicksilver> however people didn't like that so there are hacks to redirect the bitmap fonts to postscript fonts
05:57:18 <quicksilver> s/contained/referred to/
05:57:19 <quicksilver> nod
05:57:24 <quicksilver> but the actual text is there, yes.
05:58:58 <quicksilver> it's a great shame, too, because metafont was a far superior technology to postscript fonts.
05:59:01 <quicksilver> Ah well.
05:59:28 <p_l> quicksilver: metapost could be hacked to produce postscript fonts I think...
06:00:47 <pozic> quicksilver: Metapost is not documented that well.
06:01:22 <pozic> quicksilver: and most importantly, has no tool support, AFAIK.
06:02:12 <quicksilver> p_l: no, it couldn't.
06:02:23 <quicksilver> p_l: it is not possible to create postscript fonts from metafont
06:02:30 <quicksilver> (without forfeiting the entire point of metafont)
06:02:37 <quicksilver> it's just an incompatible model.
06:02:50 <quicksilver> PS has 'simple resolution independence'. It's a vector graphic model.
06:03:18 <quicksilver> MF is a programming language which generates fonts at a chosen resolution (which you can alter).
06:03:35 <quicksilver> if used skillfully it has the advantages that TT/PS world calls 'hinting'
06:04:01 <quicksilver> getting good looking glyphs where the number of pixels is small relative to the width of the lines.
06:04:03 <p_l> quicksilver: metapost however added PS output to metafont
06:04:29 <quicksilver> yes but that's irrelevant
06:04:36 <p_l> if at least you could get proper hinting from that, it would be nice
06:04:42 <quicksilver> (you already could get PS output from metafont, by going via DVI)
06:04:56 <quicksilver> that doesn't give you the ability to make PS fonts from MF fonts
06:05:07 <quicksilver> except by choosing a fixed resolution.
06:05:14 <quicksilver> Which was always possible - but that defeats the point.
06:05:58 <p_l> quicksilver: I mean that Metapost produces postscript directly, not by going rounds with dvitops
06:07:36 <pozic> I find that I pass parameters to functions that should just have been in a lexical scope, because of the "lines should not be longer than X chars"-mantra (and the lack of editor support). Do you recognize this problem?
06:08:54 <quicksilver> p_l: but that doesn't solve the problem.
06:09:05 <quicksilver> p_l: however the PS is generated you still don't get resolution independent fonts.
06:09:16 <quicksilver> p_l: so the whole point of metafont is wasted.
06:09:23 <Saizan_> pozic: tried using "where"?
06:09:49 <quicksilver> pozic: why don't you just break the expression over several lines?
06:11:07 <p_l> quicksilver: Well, I didn't try making fonts with metapost, but AFAIK it allowed you to write "resolution independent" postscript. But I agree that a lot of precision would be lost
06:11:26 <pozic> One reason not to place functions in a lower lexical environment is that they cannot be tested from the toplevel.
06:11:58 <quicksilver> p_l: it doesn't.
06:12:00 <pozic> ghci should be able to do that. It would probably stop me from doing that in most cases.
06:12:05 <quicksilver> p_l: you are missing the whole point of metafont.
06:12:20 <quicksilver> p_l: metafont's kind of resolution independence is not expressible in postscript.
06:12:27 <quicksilver> but I am getting boring, and this is off topic.
06:12:33 <p_l> right
06:12:52 * p_l goes back trying to setup GHC on win32
06:12:54 <ben_h> could someone give me a hand here? not sure where I'm going wrong. or rather, I can see the problem, but not the solution. http://gist.github.com/22588
06:12:55 <lambdabot> Title: gist: 22588 — GitHub
06:13:10 <ben_h> ghc reports a type mismatch calling rightTriangles from main
06:13:12 <quicksilver> pozic: that is definitely a reason, bu tthat's not what you said.
06:13:33 <quicksilver> pozic: "passing parameters to functions because lines should not be longer than X chars" --- this problem I do not recognise
06:13:38 <pozic> quicksilver: right, that's not what I said. I said it wrong.
06:13:55 <quicksilver> pozic: "passing parameters to functions because I want to be able to test functions independently in ghci" -- yes, I recognise this one ;)
06:14:23 <quicksilver> I agree it would be nice if ghci could step into lexical contexts
06:14:29 <quicksilver> although there is also quickcheck, too.
06:14:47 <jeffz> ben_h: the type error usually explains the problem
06:14:47 <pozic> quicksilver: hmm?
06:15:21 <quicksilver> ben_h: I see nothign wrong with that code, can you paste the error?
06:15:26 <quicksilver> of course, it is a surprising thing to write
06:15:30 <quicksilver> main is normally of type IO ()
06:15:34 <quicksilver> and that is a strange use of do
06:15:40 <quicksilver> but it should be legal haskell
06:15:57 <quicksilver> with main :: [(Integer,Integer,Integer)]
06:17:02 <ben_h> quicksilver: updated the gist
06:17:03 <pozic> quicksilver: it might should be legal Haskell 98, but it isn't.
06:17:43 <ben_h> quicksilver: the do is there because 'main = rightTriangles' didn't work. should have removed that :)
06:18:43 <pozic> Try loading a module with main = 1. You will fail.
06:18:59 <ben_h> yeah
06:19:06 <ben_h> i understand why that's the case
06:19:23 <ben_h> but then i don't see how to progress from this point :)
06:19:53 <pozic> ben_h: depends on what you want. Try print rightTriangles
06:20:03 <pozic> ben_h: main = print rightTriangles
06:20:12 <ben_h> ah, right
06:22:02 <quicksilver> pozic: well it might not be a legal h98 complete program (complete program must provide main)
06:22:08 <quicksilver> pozic: but surely it's a legal h98 module?
06:22:18 <quicksilver> module doesn't need to provide main, and has no restriction on the type of main?
06:23:13 <quicksilver> ah. "module Foo where {main =1}" is fine
06:23:25 <quicksilver> ah. "module main where {main =1}" is not
06:23:28 <quicksilver> stupid h98.
06:23:39 <quicksilver> s/module main/module Main/
06:25:03 * ben_h just looked at the output of `ghc -C rightTriangles.hs`
06:25:11 <ben_h> that code melted my face off.
06:25:32 <yitz> ah. "module Main where {instance Num (IO ()); main =1}" is fine
06:27:04 <pozic> yitz: yes, it is.
06:27:38 <quicksilver> ben_h: note that normally people don't use GHC's C generator these days.
06:28:04 <ben_h> quicksilver: i thought it was part of the compilation?
06:28:10 <pozic> ben_h: it was.
06:28:16 <ben_h> or does it go haskell -> machine code now?
06:28:44 <pozic> ben_h: it goes via Java Bytecode first ;)
06:29:08 <yitz> pozic !
06:29:50 <quicksilver> ben_h: people generally use the native code generator.
06:30:03 <quicksilver> even when people generalled use the C code generator it wasn't really C.
06:30:08 <ben_h> yeah
06:30:16 <quicksilver> it was something which looked like C, which tricked gcc into producing something which looked like assembly
06:30:20 <quicksilver> which was then post-processed.
06:30:26 <ben_h> it's an autogenerated haskell VM of sorts isn't it?
06:30:29 <quicksilver> by a perl script!
06:30:33 <ben_h> lol
06:30:40 <p_l> C--
06:30:43 * quicksilver shrugs
06:30:48 <quicksilver> what's a VM?
06:30:50 <ben_h> pozic: really?
06:30:52 <quicksilver> (this is a deep question)
06:30:53 <ben_h> virtual machine
06:30:55 <yitz> And the perl script was known as: The Evil Mangler
06:30:56 <ben_h> oh lol
06:30:58 <quicksilver> yes I know what it stands for.
06:30:59 <ben_h> sorry. stupid answer
06:31:12 <quicksilver> the GHC code produces somethign designed to be linked against the RTS
06:31:22 <quicksilver> so it's relying on some kinds of runtime support
06:31:30 <ben_h> RTS?
06:31:33 <quicksilver> garbage collection, haskell threads, that kind of thing
06:31:36 <quicksilver> run-time system
06:31:41 <ben_h> right
06:31:43 <quicksilver> so, in that respect, it's "like" a VM
06:31:45 <quicksilver> however...
06:31:50 <ben_h> (see i don't know the acronyms :) )
06:31:53 <quicksilver> it's not generating opcodes in some special language
06:31:57 <quicksilver> which get interpreted at runtime
06:32:11 <ben_h> hmm
06:32:11 <quicksilver> it's producing honest to goodness x86 machine code
06:32:21 <yitz> ben_h: we still use mostly TLAs, we haven't gotten to ETLAs yet.
06:32:23 <ben_h> it sounds like a vm where the code and machine run at the same level.
06:32:26 <quicksilver> so, overall I would say "No, it's not a haskell VM, it's native code"
06:32:35 <ben_h> as opposed to a traditional one where the code is running _on_ the machine
06:32:37 <quicksilver> native code with runtime support, sure: but even C has that.
06:32:42 <ben_h> yeah
06:32:58 <pozic> quicksilver: what's the dump assembly command?
06:33:01 <yitz> in windows you have rt_whatever.dll
06:33:21 <quicksilver> I don't remember. It should be in the manual.
06:35:05 <pozic> -ddump-asm
06:36:11 <pozic> Why can't ghc preserve names of the source code in the assembly code?
06:36:13 <Guest52947> @src foldr
06:36:13 <lambdabot> foldr f z []     = z
06:36:13 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:36:17 <Guest52947> @src foldl
06:36:17 <lambdabot> foldl f z []     = z
06:36:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:37:53 <ttmrichter> I'm having a few problems building ghc-6.10.1.  Is there anybody around familiar with the process who could help me get this going?
06:38:34 <Lemmih> ttmrichter: What seems to be the problem?
06:38:48 <quicksilver> pozic: it generates many more names
06:39:03 <quicksilver> pozic: but sometimes it feels like it could do a better job of preserving yes
06:39:03 <ttmrichter> Lemmih: it's crapping out in mid-build while trying to build base-4.0.0.0.
06:39:14 <pozic> quicksilver: but not the input name in the example of ben_h.
06:40:30 <pozic> -ddump-parsed for ghc-6.8.2 doesn't return anything remotely looking like a parse tree.
06:41:21 <u_quark> > version
06:41:22 <lambdabot>   Not in scope: `version'
06:41:34 <pozic> It's more like a pretty printed version of the input code.
06:41:42 <u_quark> : version
06:41:47 <Lemmih> pozic: That's exactly what it is.
06:42:07 <u_quark> :version
06:42:23 <C-Keen> > :version
06:42:24 <u_quark> :|
06:42:24 <lambdabot>   <no location info>: parse error on input `:'
06:42:33 <C-Keen> hm
06:42:45 <pozic> "Dump parse tree" means for me "Dump a tree", not "dump a pretty printed parse tree".
06:43:11 <pozic> I understand what the purpose is of it, but it should be named differently.
06:43:46 <Lemmih> I doubt anyone care enough to change it.
06:46:43 <ttmrichter> Lemmih: On closer inspection there seems to be a GNUMakefile missing that's making make throw a hissy fit.
06:47:21 <ttmrichter> I'm restarting from scratch entirely in case I did something dunderheaded.
06:49:42 <Lemmih> ttmrichter: Good idea. Tiny mistakes can make the system go haywire.
06:50:39 <ttmrichter> Lemmih: I'm not seeing happy messages all over the place here.  Like this one: "Configuring installPackage-1.0...
06:50:39 <ttmrichter> Warning: This package indirectly depends on multiple versions of the same
06:50:39 <ttmrichter> package. This is highly likely to cause a compile failure.
06:50:39 <ttmrichter> package process-1.0.0.1 requires filepath-1.1.0.0
06:50:39 <ttmrichter> package directory-1.0.0.1 requires filepath-1.1.0.0
06:50:41 <ttmrichter> package Cabal-1.6.0.1 requires filepath-1.1.0.1
06:50:43 <ttmrichter> "
06:51:00 <tux91> can anybody give a link to a good article that describes functional programming?
06:51:26 <ttmrichter> tux91: how about a whole book?  The "Real World Haskell" book online has some good chapters on the subject.
06:51:55 <tux91> ttmrichter: well, i don't think i have time for a whole book right now
06:52:07 <ttmrichter> Just read the relevant chapters, then.  ;)
06:52:36 <tux91> ttmrichter: so that's a free online book?
06:52:51 <ttmrichter> It's the official site for the upcoming O'Reily book.
06:53:07 <ttmrichter> And it contains the entire beta text under the CC license set.
06:53:26 <jeffz> tux91: http://www.cs.nott.ac.uk/~gmh/faq.html might be a good
06:53:27 <lambdabot> Title: FAQ for comp.lang.functional
06:53:40 <mdmkolbe> Is there some way to automatically derive Storable instances for FFI marshaling?  Or maybe is there some tool to make it easier?  (I'm already using hsc2hs, but even then writing Storable instances for a dozen structs is a lot of redudant work.)
06:53:43 <ttmrichter> http://book.realworldhaskell.org
06:54:15 <tux91> ttmrichter: jeffz: lambdabot: thank you
06:54:53 <tomh> mm seems down
06:55:50 <jeffz> tux91: see also http://haskell.org/haskellwiki/Functional_programming
06:55:51 <lambdabot> Title: Functional programming - HaskellWiki
06:56:30 <ttmrichter> Now why did lambdabot give both of your URLs titles, etc. and mine it ignored?
06:56:35 * ttmrichter is feeling put out now.  :(
06:57:41 <yitz> @tell ttmrichter lambdabot likes you
06:57:43 <lambdabot> Consider it noted.
06:59:06 <jeffz> ttmrichter: if the site is unreachable there is nothing to print
06:59:25 <ttmrichter> Oh?  It's down?
06:59:25 <lambdabot> ttmrichter: You have 1 new message. '/msg lambdabot @messages' to read it.
07:01:27 <ttmrichter> Now that is very odd.  The main page is accessible, but the link to the book is dead.
07:03:16 <jeffersonheard> I'm using Data.Array.MArray.getElems on a GdkPixbuf object, and it's never returning...  The size of the object should be 2048x2048x3 Word8s.  Has anyone used the MArray interface with pixbufGetPixels, like it says?
07:03:37 <quicksilver> dcoutts_: ping?
07:03:56 <pozic> jeffersonheard: never could be just a really long time.
07:04:34 <pozic> jeffersonheard: I have used getElems and it has worked a few billion times.
07:05:14 <pozic> jeffersonheard: have you tried it with something smaller?
07:07:25 <jeffersonheard> I'd hope it's not a really long time.
07:07:51 <dcoutts_> quicksilver: pong
07:07:53 <jeffersonheard> I haven't tried it with something smaller yet, no.  I'm adapting my map-viewing app to OpenGL
07:08:15 <jeffersonheard> and it uses GdkPixbuf to put together the imaging
07:08:33 <jeffersonheard> so I was hoping to draw the pixels out of the pixbuf into a texture
07:08:47 <jeffersonheard> using getElems.  The textures are 2k*2k*RGB
07:09:24 <jeffersonheard> Incidentally, I'm actually working on a subpixbuf (from newSubPixBuf) that works on 1/9th of the image
07:10:49 <quicksilver> dcoutts_: see jeffersonheard
07:11:01 <quicksilver> dcoutts_: bug with getElems in pixbugGetPixels?
07:11:27 <dcoutts_> quicksilver: sorry, not now, get the details and file a report
07:11:31 <ben_h> as a little experiment i just benchmarked that rightTriangle code I pasted before, and hacked it up in C and ruby and benchmarked them for comparison.
07:11:33 <jeffersonheard> here's the code I'm using:  http://hpaste.org/11787
07:11:38 <ben_h> c 0.238s; haskell 24.9s; ruby1.9 35.085s; ruby1.8 8m17.488s
07:12:19 <ben_h> c 31loc; haskell 1loc; ruby 15loc
07:12:20 <jeffersonheard> dcoutts_: I doubt it's a bug so much as I'm doing something screwy.  If nothing else, I'll revert to using readArray
07:12:37 <ben_h> haskell 2loc*
07:12:59 <pozic> ben_h: can you post the code?
07:13:11 <jeffersonheard> Trying to get this app done in time to demo at Supercomputing 08, next week
07:13:14 <Peaker> what's the equivalent of a Pythonic array slice?
07:13:19 <ben_h> sure
07:13:38 <pozic> jeffersonheard: what's your super computer?
07:14:28 <jeffersonheard> pozic, we have several.  Most notable are Okracoke and Kittyhawk.
07:14:45 <pozic> jeffersonheard: I am supposed to understand that?
07:14:57 <jeffersonheard> Not kittyhawk...  Topsail.  They're both on the top 500 list
07:15:38 <dmwit> Peaker: ixmap
07:15:42 <jeffersonheard> Not sure where.  Ok. is an IBM BlueGene, and Kittyhawk is an AMD Athlon thingie.  I'm not a supercomputing person myself
07:15:58 <Peaker> dmwit: thanks
07:16:23 <pozic> jeffersonheard: but your code will run on it?
07:17:07 <jeffersonheard> Not on the BlueGene, but yes on the Athlon.   Really, though, this is a frontend app using multitouch technology to show off the models and such we compute on those computers
07:17:53 <sm> morning all.. is there a bug in http://hackage.haskell.org/cgi-bin/hackage-scripts/package/feed ? it doesn't seem to honour utf8 encoding. Is there a darcs repo for this ?
07:17:59 <lambdabot> Title: HackageDB: feed-0.3.4
07:18:01 <pozic> jeffersonheard: interesting
07:18:22 <jeffersonheard> As soon as I'm done with it, I'll release all the bits as open source... there's quite a lot of good stuff in there, from basic control flow stuff to an interface to a gesture recognition library
07:18:45 <jeffersonheard> but I've been so rushed getting it out I haven't had time to clean it up and create Haddock for all of it
07:19:18 <ttmrichter> Lemmih: OK, with a complete start from scratch the 6.10.1 build is still crapping out at exactly the same spot with exactly the same error.  Should I hpaste the relevant portion of the copious output?
07:19:19 <pozic> jeffersonheard: screenshots do more for a libary than documentation at first, I think.
07:19:36 <maltem> Hm... so I installed ghc 6.10, but it didn't build editline because it didn't find libedit it in its non-standard location. So I built editline manually, but now do I have to do anything special to get ghci to work properly?
07:20:01 <ben_h> rightTriangles code:
07:20:05 <ben_h> c: http://gist.github.com/22608
07:20:05 <ben_h> haskell: http://gist.github.com/22588
07:20:05 <ben_h> ruby: http://gist.github.com/22610
07:20:10 <lambdabot> Title: gist: 22608 — GitHub
07:20:10 <lambdabot> Title: gist: 22610 — GitHub
07:20:10 <lambdabot> Title: gist: 22588 — GitHub
07:20:14 <ben_h> (i just optimised the ruby one a bit)
07:21:09 <dmwit> ben_h: Looks pretty good.
07:21:13 <tux91> Does anybody know of a place to read "Real World Haskell"? The official site seems to be overloaded
07:21:15 <pozic> ben_h: those programs solve different problems.
07:21:22 <thoughtpolice> ttmrichter: what's the error the build gives you?
07:21:30 <ben_h> pozic: sure
07:21:46 <ben_h> pozic: they're just the first way i thought of implementing that in each language
07:21:54 <pozic> ben_h: a C program doing the same thing as the Haskell program would do more work as the current C program.
07:21:57 <pozic> ben_h: ok
07:22:13 <pozic> ben_h: still, the difference is quite large.
07:22:21 <ttmrichter> thoughtpolice: I'm putting it up on hpaste.  Hold on a sec....
07:22:31 <dmwit> pozic: What are you talking about?
07:22:37 <ben_h> pozic: yeah the C one is a bit useless. i was thinking mainly about the iterating - it would need at least some struct or other to hold the triangles.
07:22:55 <ttmrichter> OK, that was a bust.  Trying again, this time slicing out the damnable noise from configure scripts.
07:22:57 <pozic> ben_h: also, you inlined the call to ^2 in the C version.
07:23:12 <ben_h> so i did
07:23:20 <pozic> ben_h: IIRC, GHC doesn't do that (quite stupid of GHC).
07:23:33 <ben_h> ah yeah
07:23:38 <ben_h> infix ^ function
07:24:18 <dmwit> Oh, I see, we're arguing because ben_h made Haskell look slow.
07:24:18 <tux91> nobody?
07:24:32 <nominolo|msr> @seen heffalump
07:24:32 <lambdabot> heffalump is in #darcs. I last heard heffalump speak 9h 10m 14s ago.
07:24:36 <dmwit> tux91: Maybe you should buy the book. ;-)
07:24:36 <pozic> dmwit: no, I am not arguing.
07:25:06 <tux91> dmwit: I would prefer to look at it first and see if it's worth bying
07:25:12 <ben_h> dmwit: i reckon it did alright - that's my first haskell program, and it's incomparably more readable than the other two :)
07:25:13 <ttmrichter> thoughtpolice: http://hpaste.org/11789
07:25:23 <ben_h> or rather
07:25:26 <ben_h> it's not my program.
07:25:42 <ben_h> first bit of haskell code i've toyed with
07:26:05 <dmwit> ben_h: I think the advantage of Haskell is definitely readability/writability.  When it comes time that speed matters, you can get that too, but of course at the cost of some readability.
07:26:13 <Peaker> ghc 6.10 lost throwDyn, what did it become?
07:26:15 <ben_h> yeah
07:26:46 <quicksilver> Peaker: extensible exceptions.
07:26:48 <ben_h> dmwit: well, i'm a ruby 1.8 user at present, so that should tell you a bit about my stance on performance ;)
07:26:52 <quicksilver> Peaker: see the new Control.Exception
07:26:54 <dmwit> =)
07:27:05 <Peaker> quicksilver: so its not just a rename... Thanks
07:27:08 <quicksilver> Peaker: (it's just called 'throw')
07:27:27 <pozic> ben_h: and your Haskell program works on Integers, not Ints.
07:27:34 <thoughtpolice> currently there's really no docs about extensible exceptions in the Control.Exception module
07:27:41 <thoughtpolice> which is noted in the ghc bugtracker
07:27:46 <pozic> ben_h: also, the C program is possibly completely inlined.
07:27:48 <dmwit> pozic: Oh, great point.
07:27:55 <quicksilver> thoughtpolice: there is the paper :)
07:27:58 <pozic> dmwit: are you joking?
07:28:04 <dmwit> pozic: no
07:28:07 <thoughtpolice> quicksilver: yes
07:28:09 <pozic> dmwit: ok, sorry.
07:28:13 <thoughtpolice> i was going to say that's the best place to look :]
07:28:13 <dmwit> pozic: The difference between Int and Integer is amazingly big.
07:28:14 <ben_h> i don't think it can be completely inlined
07:28:21 <ben_h> oh
07:28:24 <pozic> ben_h: yes, there is no input.
07:28:27 <ben_h> the two functions into the loop?
07:28:30 <thoughtpolice> Peaker: see "An extensible dynamically-typed hierarchy of extensions"
07:28:30 <ben_h> yeah
07:28:33 <pozic> ben_h: yes
07:28:39 <ben_h> yep i'd bet it is.
07:28:50 <Peaker> thoughtpolice: The mess it was in before, it can only be better now ;)
07:29:09 <thoughtpolice> Peaker: i like the new exception handling a lot.
07:29:38 <pozic> ben_h: see? It's not easy to compare programs :)
07:29:58 <quicksilver> SomeException is just a special case of Dynamic (isn't it?)
07:30:25 <quicksilver> throwing in a Show constraint, and forcing you to explicitly choose which types get allowed.
07:30:29 <dmwit> ben_h: So, I guess the summary is: for speed, try the (x^2) -> (x*x) transform, give an [(Int, Int, Int)] type annotation to rightTriangles, and compile with optimizations turned on.  (I threw in the last one for good measure. ;-)
07:31:12 <pozic> ben_h: I see you do print the '[' chars. So, the programs do have the same output.
07:31:23 <ben_h> yeah
07:31:36 <pozic> ben_h: so, then it's only the points dmwit said.
07:32:11 <ben_h> what's the syntax for that annotation?
07:32:22 <dmwit> rightTriangles :: [(Int, Int, Int)]
07:32:33 <tux91> ok so "Real World Haskell" won't work for me, is there a similar online book/tutorial on a functional language (I don't care if it's haskell or not)?
07:32:56 <dmwit> tux91: Well, there's LYAH, YAHT, and the Gentle Intro for Haskell.
07:33:05 <dmwit> tux91: There's also SICP for scheme, which is real nice.
07:33:29 <ben_h> :O
07:33:34 <dmwit> tux91: ?where should know about all but SICP
07:33:58 <ben_h> converting n^2 to n*n gave an 8-fold speed increase
07:34:05 <tux91> dmwit: what do you mean?
07:35:20 <dmwit> tux91: What wasn't clear?
07:35:20 <Peaker> where can I find an example of an instance of Exception? I don't understand how to define fromException
07:35:20 <Cale> tux91: Why won't it work?
07:35:20 <Cale> @where sicp
07:35:20 <lambdabot> http://mitpress.mit.edu/sicp/
07:35:20 <tux91> Cale: the site is overloaded and i just can't get to it
07:35:20 <Cale> It knows about sicp too ;)
07:35:20 <dmwit> Oh, hey, great!
07:35:20 <Cale> tux91: oh...
07:35:21 <Cale> tux91: that's interesting. I wonder why that would be...
07:35:32 <tux91> dmwit: ?where should know about all but SICP. that. i'm sorry english is not my native language
07:35:40 <tux91> dmwit: is it worth reading?
07:36:02 <dmwit> tux91: Oh.  I meant you can find the four things I suggested by querying lambdabot:
07:36:05 <dmwit> ?where LYAH
07:36:05 <lambdabot> www.learnyouahaskell.com
07:36:09 <dmwit> ?where YAHT
07:36:09 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
07:36:10 <dmwit> etc.
07:36:13 <ttmrichter> SICP is one of the best books for just learning how to understand computation ever written, tux91.
07:36:25 <ttmrichter> But it is a book.  You said you had no time for a full book.
07:36:40 <drdo`> ther are also the SICP video lectures available online
07:36:50 <tux91> ttmrichter: as long as i don't need to buy it it's ok))
07:36:52 <Peaker> Lemmih: you're the SDL guy right?  It seems the hackage SDL still has some Ints in place of CInts
07:37:02 <tux91> dmwit: ok thank you
07:37:10 <Cale> The SICP video lectures are a lot of fun
07:37:29 <ben_h> haskell original: 24sec; s/^/*: 3.83esec; Int annotations: 2.797sec
07:37:38 <ben_h> that's awesome.
07:37:50 <ben_h> 3.833sec*
07:38:18 <dmwit> ben_h: Yep, Integer is a nice default for showing off things like 2^100, but it can be pretty slow. =)
07:38:22 <Lemmih> Peaker: Bloody hell.
07:38:44 <Peaker> Lemmih: I guess grep Int should find all of those...
07:38:55 <pozic> ben_h: you should now get the 500 from getArgs in all versions.
07:38:55 <ben_h> dmwit: :)
07:39:10 <pozic> ben_h: i.e. as input.
07:39:38 <ben_h> yeah
07:40:00 <thoughtpolice> Peaker: again check the paper by JaffaCake (the extensible exceptions one) - it's real easy to grok and has a ton of examples
07:40:03 <Cale> Int is usually a premature optimisation, and one which often damages correctness, but it is a decent optimisation when you're really sure that you'll only be working with small numbers.
07:40:08 <dmwit> Although I guess Integer was only costing 30% extra over Int.
07:40:52 <dmwit> That's not so bad.
07:40:52 * dmwit just realized that the real win was switching from (x^2) to (x*x)
07:40:54 <dmwit> That seems like an easy REWRITE rule for GHC to stick in.
07:40:54 <ben_h> dmwit: i tried Int annotations without the s/^/* and it had negligible impact.
07:40:56 <Cale> Integer uses machine ints to store small numbers, but still has to do overflow checking.
07:40:58 <ben_h> 24sec -> 23.8sec
07:41:11 <dmwit> right
07:41:12 <Cale> yeah, that makes sense
07:41:30 <dmwit> So, I wonder if GHC does some transform like that for small exponents when optimizations are on?
07:41:33 <ben_h> strange, it seemed to have a larger effect with s/^/* in place
07:41:57 <Cale> Note that in x^2, the 2 is probably an Integer as well.
07:42:05 <ben_h> ah yeah
07:42:08 <sm> why would I get errors like    Couldn't match expected type `Feed' against inferred type `feed-0.3.4:Text.Feed.Types.Feed' after upgrading feed ?
07:42:15 <dmwit> :t (^)
07:42:17 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:42:21 <dmwit> Cale: But that's true in both cases, right?
07:42:22 <ben_h> but if x is annotated Int, then 2 will be coerced to an Int?
07:42:28 <dmwit> No, it shouldn't be.
07:42:29 <Cale> ben_h: no
07:42:30 <sm> pretty sure I've purged all old versions of the package, and dependers
07:42:32 <maltem> sm: different versions linked against each other
07:43:14 <maltem> sm: try and make out any packages that depend on feed, and update those too
07:43:20 <Cale> hmm...
07:43:41 <sm> thanks maltem, sounds like I'm on the right track.. maybe I missed one
07:43:49 <Cale> I wonder if some barrage of optimisations could help things like x^2 and x^5 etc. by allowing for partial evaluation.
07:44:07 <sm> should cabal install have noticed this ?
07:44:18 <Cale> Really, the problem is not that the expansion x^2 -> x*x is done by a procedure at runtime, it's that it's done over and over again.
07:44:32 <ben_h> mm
07:44:56 <Cale> (for different values of x)
07:44:56 <maltem> sm: cabal should give a warning on the code where you get that error
07:45:01 <ben_h> i don't know if it's feasible, but i like the idea of that stuff being cached
07:45:38 <dmwit> Cale: I guess the only issue is with odd Integral instances (Expr, say).
07:45:51 <dmwit> Cale: The compiler has surprisingly few guarantees about what 2 means, I think.
07:46:02 <sm> ghc warns about the code, but cabal didn't warn of anything when I upgraded feed
07:46:51 <jeffersonheard> do MArray's unsafeRead and unsafeWrite still exist?
07:47:10 <pozic> jeffersonheard: AFAIK, yes.
07:47:24 <jeffersonheard> pozic, not in scope if I import MArray
07:47:34 <ben_h> i really should be sleeping
07:47:38 <Saizan_> sm: if you used cabal-install when compiling the package where you're using feed it should have noticed
07:47:45 <ben_h> thanks all for the help and interesting chat.
07:47:45 <ben_h> ttyl
07:48:11 <sm> I'm using just from a hs script, not compiled
07:48:30 <Saizan_> then you probably just have to clean some old .hi files
07:48:55 <pozic> jeffersonheard: :m+ Data.Array.Base
07:49:24 <jeffersonheard> ah.
07:49:25 <jeffersonheard> thanks
07:49:39 <sm> I'm not sure where they could be.. I have none in working dir, I purged all feed versions from ~/.cabal/{packages,lib}
07:49:59 <sm> for p in `ghc-pkg list --simple-output`; do ghc-pkg describe $p; done |egrep '^(depends|name):'  shows me the only depender is download-curl, I think I purged that but let's try again
07:50:51 <Cale> dons: hey, book.realworldhaskell.org seems overloaded :) We can hope this means your book is growing in popularity.
07:51:29 <thoughtpolice> ttmrichter: hm i'm not at all sure about that build err, ask in #ghc
07:51:52 <Saizan_> sm: you could see from where the symbols that are giving those errors are exported
07:52:00 <ttmrichter> thoughtpolice: Ah.  Didn't realize there was a GHC-specific channel.  Thanks for the pointer.
07:52:07 <Saizan_> sm: so you know which modules/packages conflict
07:53:07 <pozic> Cale: I can access it just fine.
07:53:48 <Cale> It seems really slow for me.
07:54:06 <Cale> actually, it's a bit better now
07:54:28 <Haihua> > 3 + 2
07:54:31 <pozic> Cale: hmm, I was just lucky a few minutes ago :P
07:54:31 <lambdabot>   5
08:01:29 <sm> why is this failing ? ghci> import Text.Feed.Types
08:01:29 <sm> module main:Text.Feed.Types is not loaded
08:01:46 <dons> http://www.reddit.com/r/programming/comments/7brog/haskell_now_ships_with_type_families_heres_a_2/
08:01:48 <lambdabot> Title: Haskell now ships with "type families". Here's a 2 minute intro. : programming, http://tinyurl.com/5fdpw9
08:01:52 <dmwit> :m +
08:02:00 <dmwit> sm: Maybe use that instead of import?
08:02:06 <thoughtpolice> sm: you're probably in the src code directory, aren't you?
08:02:38 <thoughtpolice> sm: if you're in ./, and ghci knows of a module 'Foo.Blah' and in that directory there is a module './Foo/Blah.hs', ghci will get confused like that.
08:02:53 <Haihua> anyone know a real website built by Haskell?
08:02:57 <sm> ohh, I had a local copy of Text/* I was trying to hack
08:03:04 <Saizan_> you need :load then
08:04:13 <thoughtpolice> dons: type families ftw!
08:04:38 <sm> finally, error resolved.. I had not hit all three of purge feed packages, purge download-curl, purge local copy. Thanks all
08:05:18 <sm> the original problem seems unresolved by 0.3.4 alas.. utf-8 feed still seems mis-interpreted, even though I see new utf-8 code
08:05:36 <sm> but now I can dig deeper
08:12:06 <Lan> someone experienced in Haskel web programming? such as to write a forum in Haskell
08:13:27 <DukeDave> Hello team, is anyone here going to London Hug tonight?
08:15:07 <Peaker> what's "return" for the (,) monad?
08:16:20 <Cale> Peaker: You mean (,) w  where w is a monoid?
08:16:30 <Cale> return x = (mempty, x)
08:16:33 <sm> damn.. discouraged. Haskell libs not quite cutting it for this job ..
08:16:33 <Peaker> Cale: yeah, thanks
08:17:09 <Lemmih> sm: What job?
08:17:25 <sm> fetching a feed containing utf8 content ?
08:17:37 <Cale> What kind of feed?
08:17:42 <DukeDave> Cale what does "(,) w  where w is a monoid?" mean? :)
08:17:52 <Lemmih> sm: Why is that a problem?
08:17:55 <DukeDave> Is this something I'm not supposed to understand
08:18:18 <Cale> DukeDave: Well, first of all, it would be good to explain what a monoid is
08:18:23 <sm> eg: curl http://leftrightandcenter.vox.com/library/posts/rss.xml |grep 'about him' - includes a utf-8 encoded apostrophe. The same thing fetched with download-curl gets mangled. I think.
08:18:44 <Rory> is there a semi-easy way to convert a strng into a list of char's
08:18:45 <pozic> sm: what makes you think it gets mangled?
08:19:04 <Lemmih> Rory: A string /is/ a list of chars.
08:19:07 <pozic> sm: a value is not the same as a printed value.
08:19:13 <Rory> mmm
08:19:18 <Cale> DukeDave: A monoid is a type together with a binary operation (in the libraries called mappend, but I'd prefer if it was called ++), which is associative, and has an identity element (mempty, but I'd rather it was called zero)
08:19:18 <Rory> ok 8-)
08:19:42 <pozic> sm: utf8-string can output "weird characters".
08:19:46 <sm> yes indeed, but I'm having trouble debugging, and sad that it didn't just work like the other 99% of this did (modulo figuring out apis)
08:19:47 <Cale> DukeDave: Examples of monoids include lists under appending
08:20:08 <Cale> DukeDave: and integers under addition (with 0 as the identity), or multiplication (with 1 as the identity)
08:20:12 <sm> tracing the data shows \226\128\153
08:20:32 <Cale> DukeDave: Also, functions from a type to itself under composition.
08:20:33 <pozic> sm: the tracing uses the built-in way to display strings.
08:20:46 <pozic> sm: that doesn't interpret it like utf8-strings.
08:21:04 <sm> ok, good to know
08:21:08 <Cale> DukeDave: If w is a monoid, then the type constructor (,) w (which is how we write the partial application of the pair type to w), is a monad.
08:21:32 <DukeDave> Cale: Damn I was with you up to the last part :)
08:21:38 * DukeDave processes 
08:21:51 <Cale> DukeDave: okay, well...
08:21:53 <Cale> :k (,)
08:21:54 <lambdabot> * -> * -> *
08:21:57 <Cale> :k (,) Integer
08:21:58 <lambdabot> * -> *
08:22:00 <sw17ch> @type (,) 5
08:22:00 <Cale> :k (,) Integer String
08:22:01 <lambdabot> forall t b. (Num t) => b -> (t, b)
08:22:01 <lambdabot> *
08:22:06 <pozic> sm: so define mytrace str value = unsafePerformIO(do putStrLn(the one from utf8-string) str; return value)
08:22:12 <sw17ch> @type (,) (5 :: Int)
08:22:13 <lambdabot> forall b. b -> (Int, b)
08:22:21 <sw17ch> @type flip (,) (5 :: Int)
08:22:22 <lambdabot> forall a. a -> (a, Int)
08:22:26 <Cale> :t (3,4) :: (,) Int Int
08:22:27 <lambdabot> (Int, Int)
08:22:33 <sm> perhaps the problem is in feed. Those bytes get encoded as html entities somehow or other
08:22:38 * sm tries
08:22:50 <cantor> could anyone help me with my code please: http://pastebin.com/m7d2d39f1 , i always get the input back, e.g. small2 n and on the display appear n
08:22:51 <Cale> sw17ch: That's partial application at the value level rather than the type level :)
08:23:16 <DukeDave> Yikes, why do I always start freaking out when see (* ->*)   That's called kinds ?
08:23:23 <Cale> DukeDave: Right.
08:23:37 <Cale> DukeDave: Things at the type-level which have kind * are just ordinary types
08:23:47 <sw17ch> Cale: yes... yes... i know....
08:23:47 <DukeDave> Okay cool
08:23:52 <Cale> DukeDave: Things with kind * -> * are type constructors
08:23:53 <sw17ch> @type (,) (undefined :: Int)
08:23:54 <lambdabot> forall b. b -> (Int, b)
08:23:56 <Cale> :k Maybe
08:23:57 <lambdabot> * -> *
08:24:02 <Cale> :k []
08:24:03 <lambdabot> * -> *
08:24:06 <Cale> :k IO
08:24:07 <lambdabot> * -> *
08:24:10 <sw17ch> :k map
08:24:11 <lambdabot> Not in scope: type variable `map'
08:24:16 <DukeDave> Ahaa, that makes sense
08:24:17 <sw17ch> oh, duh...
08:24:27 <Cale> Monads always have kind * -> *
08:24:28 * sw17ch crawls into a corner to hide from Cale
08:24:43 <Cale> :k State s
08:24:44 <lambdabot> Not in scope: type variable `s'
08:24:51 <Cale> :k State Integer
08:24:52 <lambdabot> * -> *
08:25:03 <jekor`> I know how to lift the IO monad into the CGI monad, but it is possible to do the reverse? I want to use handleSqlError :: IO a -> IO a but on a function in the CGI monad (CGI CGIResult -> CGI CGIResult).
08:25:08 <Cale> :k (,)
08:25:09 <lambdabot> * -> * -> *
08:25:11 <Cale> :k (,) Integer
08:25:12 <lambdabot> * -> *
08:25:26 <Cale> So (,) Integer, or in general, (,) w  has the right kind to be a monad.
08:25:40 <yitz> cantor: what is divi supposed to do?
08:25:42 <Cale> But you of course need a sensible way to define bind and return.
08:26:01 <DukeDave> Yikes
08:26:10 <Cale> jekor`: I believe there's some way to "run" the CGI monad which gives you an IO action
08:26:21 <jekor`> Cale: Thanks, I'll look for that.
08:27:01 <jekor`> I think that's used at the beginning of the program. I'll experiment.
08:27:02 <DukeDave> Cale: Okay, so when you said "If w is a monoid, then the type constructor (,) w  [is a] monad"... What makes w a monoid as opposed to just any type?
08:27:04 <jekor`> (runCGI)
08:27:26 <quicksilver> DukeDave: I don't claim that fact is obvious.
08:27:37 <quicksilver> DukeDave: it's to do with the way we choose to make (,) w into a monad
08:27:38 <Cale> DukeDave: Well, okay, we want w to be a monoid because we're going to use the monoid operations to define the monad operations.
08:28:06 <Cale> First of all, let's note that (,) w is a Functor.
08:28:16 <Cale> With  fmap f (w,x) = (w,f x)
08:28:34 <cantor> yitz: i should divide m with 20...11
08:28:39 <Cale> Now we just need to be able to define  return  and  join.
08:29:04 <Cale> return x = ...
08:29:16 <Cale> well, we can stick x in the second part of the pair...
08:29:19 <Cale> return x = (...,x)
08:29:26 <Cale> But what do we put in the first part?
08:29:46 <yitz> cantor: when you use z as the name of the parameter to divi, that masks the z you defined at global scope. So the global z is ignored within divi.
08:29:49 <Cale> Well, we know (by assumption) that w is a monoid, so we have an identity, and we can use that.
08:29:51 <DukeDave> Erm, we declare that the type system is broken? :|
08:29:54 <Cale> return x = (mempty,x)
08:29:56 <DukeDave> Ah yes
08:30:10 <DukeDave> Man that's clever
08:30:18 <Cale> Next we have join...
08:30:25 <Cale> join (w1,(w2,x)) = ...
08:30:35 <yitz> cantor: inside divi, z represents the value that was passed into the function.
08:30:48 <pcc1> can anyone explain this: http://hpaste.org/11793
08:31:01 <yitz> cantor: so divi doesn't do at all what you wanted it to, if you think about it.
08:31:01 <cantor> yitz: i simply want m `mod`20..11
08:31:17 <Cale> Well... we can again stick x in the second part. We have a number of ways to handle the first part of the result though. But given that w is a monoid, the obvious thing to do is to use the monoid operation to combine w1 and w2
08:31:25 <yitz> cantor: you want a list of those?
08:31:32 <Cale> join (w1,(w2,x)) = (mappend w1 w2, x)
08:32:04 <cantor> yitz: i want a number m with can be divided by 20...11
08:32:08 <Cale> Of course, we still have to check that this really does give us a monad.
08:32:29 <yitz> cantor: divided by the numbers 20,19..11 ?
08:32:35 <Peaker> where would I place a strictness annotation to convert a Lazy state monad to a strict one?
08:32:38 <idnar> > ([1],[2]) >>= liftM (+)
08:32:39 <lambdabot>   Couldn't match expected type `[t]'
08:32:40 <cantor> yitz:exact
08:32:42 <Cale> But you'll find, if you try to prove it, that the monad laws of left and right unit follow directly from the left and right unit laws for the monoid.
08:32:47 <idnar> er
08:32:53 <dmwit> pcc1: yes
08:33:00 <idnar> whoops
08:33:01 <Cale> And that the associative law for the monad follows from the associative law for the monoid.
08:33:16 <dmwit> pcc1: In your class declaration, the type "f :: (Show v, Eq v) => t -> v" means:
08:33:37 <dmwit> pcc1: Given any type that is an instance of both Show and Eq, f can produce a value of that type.
08:33:56 <pcc1> yes, that would explain it
08:34:30 <yitz> cantor: ok, got it. so somewhere in your code, you'll have to use the mod function 10 different times. It's going to have to repeat somehow.
08:34:46 <pcc1> hm, so I need existential types here
08:35:09 <dmwit> pcc1: You could add some parameters to your type class.
08:35:27 <dmwit> pcc1: class (Show v, Eq v) => C t v where f :: t -> v
08:35:49 <yitz> cantor: how about if you use mod in divi instead of in small2?
08:35:52 <cantor> yitz: i have tried something like if m `mod` 20 ==0 && m mod 19 ==0 etc but it didnt really work
08:36:13 <yitz> cantor: why not? what happened?
08:36:25 <dmwit> pcc1: I'm not totally sure if that will work.  And even if it does, you'll probably want a fundep; something like class ... C t v | t -> v where ...
08:36:32 <pcc1> yes, that would also work.  I was trying to avoid non-haskell98
08:36:32 <cantor> yitz: i got always 0 as a result
08:37:00 <dmwit> pcc1: And your H98 solution is existential types? =P
08:37:24 <pcc1> no, that was my other, non-h98 solution
08:37:40 <yitz> cantor: the problem must have been somewhere else, that should work.
08:38:09 <cantor> yitz: i will try it one more time
08:38:13 <yitz> > let m = 380 in m `mod` 20 ==0 && m mod 19 ==0
08:38:14 <lambdabot>       No instance for (Integral ((a -> a -> a) -> t -> a1))
08:38:14 <lambdabot>        arising fr...
08:38:37 <yitz> > let m = 380 in m `mod` 20 ==0 && m `mod` 19 ==0
08:38:38 <lambdabot>   True
08:38:41 <DukeDave> Cale: Thanks for the heads up; am just doing the paper work :)
08:38:47 <yitz> > let m = 381 in m `mod` 20 ==0 && m `mod` 19 ==0
08:38:48 <lambdabot>   False
08:38:59 <yitz> cantor: see?
08:39:14 <cantor> yitz:jap
08:40:37 <yitz> > let m = 105 in and [m `mod` x == 0 | x <- [3,5,7]]
08:40:38 <lambdabot>   True
08:40:47 <yitz> > let m = 104 in and [m `mod` x == 0 | x <- [3,5,7]]
08:40:48 <lambdabot>   False
08:44:22 <halcyon10> hi, has someone already played a bit with the DPH-functionality in 6.10? i'm a bit unsure which modules i have to import to use the [::] for example
08:44:42 <DukeDave> One more: In this statement "Functor ((,) a)"    what does "(,) a" mean? Taken from here: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AFunctor
08:44:44 <lambdabot> Title: Prelude, http://tinyurl.com/ovjef
08:44:59 <quicksilver> DukeDave: (,) a is a partially applied type constructor
08:45:12 <quicksilver> DukeDave: "(,) a b" is a funny way of writing (a,b)
08:45:13 <DukeDave> Gah, I knew that
08:45:16 <RayNbow> :t (,) 3
08:45:17 <lambdabot> forall t b. (Num t) => b -> (t, b)
08:45:24 <quicksilver> RayNbow: well, DukeDave is in a type context
08:45:27 <quicksilver> not a value context.
08:45:32 <RayNbow> oh right
08:45:44 <quicksilver> (haskell's punning of tuple value syntax and tuple type syntax is occasinlally confusing)
08:46:30 <dons> types /= values. deal with it :)
08:47:02 <Cale> DukeDave: hehe, I thought I'd just explained that to you :)
08:47:13 <DukeDave> Cale: You did, I'm just being silly
08:47:28 <DukeDave> My trouble is understanding Functor ((,) a)
08:47:40 <RayNbow> Functor (a,)
08:47:42 <DukeDave> And fitting it with fmap ::  (a -> b) -> f a -> f b
08:47:50 <cantor> yitz: i have something ugly like this: http://pastebin.com/m7c29e995 , which should work but it doesnt
08:48:05 <RayNbow> type Tuple a b = (a,b)
08:48:14 <RayNbow> Functor (Tuple a)
08:48:30 <cantor> yitz: as response i always get 0
08:49:07 <DukeDave> It's these partially applied types I think are upsetting me, by virtue of lack of experience
08:49:16 <ToRA|MSR> instance (Functor ((,) x)) where morally fmap :: (a -> b) -> ((,) x a) -> ((,) x b)
08:49:24 <RayNbow> fmap :: (b->c) -> (Tuple a) b -> (Tuple a) c
08:49:42 <yitz> cantor: well, 0 is divisible by all of those numbers. The next number is really really big.
08:50:09 <cantor> yitz: who can i avoid this?
08:50:47 <yitz> cantor: maybe you misunderstood the statement of the problem?
08:51:22 <cantor> yitz:http://projecteuler.net/index.php?section=problems&id=5
08:51:23 <lambdabot> Title: Problem 5 - Project Euler
08:51:33 <quicksilver> DukeDave: fmap :: (a -> b) -> (w,a) -> (w,b)
08:51:35 <quicksilver> DukeDave: in this case
08:51:57 <yitz> > 11*13*17*19*16*9*5*7
08:51:58 <lambdabot>   232792560
08:52:37 <DukeDave> quicksilver: Then why not fmap ((+) 2) ('a', 4) :: (Char, Int)
08:52:51 <DukeDave> > fmap ((+) 2) ('a', 4) :: (Char, Int)
08:52:53 <lambdabot>   ('a',6)
08:52:56 <DukeDave> Whaty
08:53:01 <quicksilver> DukeDave: why not indeed? ;)
08:53:02 <DukeDave> But
08:53:15 <DukeDave> That's what's been upsetting me
08:53:21 <DukeDave> In my ghci:        No instance for (Functor ((,) Char))
08:53:21 <DukeDave>       arising from a use of `fmap' at <interactive>:1:0-20
08:53:27 <yitz> cantor: ah, project euler. that's fun!
08:53:38 <cantor> yitz: indeed
08:53:48 <quicksilver> DukeDave: import Control.Monad.Instances
08:54:05 <DukeDave> Ha, fail
08:54:12 <RayNbow> @src fail
08:54:13 <lambdabot> fail s      = error s
08:54:35 <DukeDave> I wish I'd known that
08:54:38 <DukeDave> Okay, I'm happy now :D
08:54:39 <pcc1> if I define a custom implementation for a typeclass is it possible to reference what the default implementation would be if I had used "deriving"?
08:54:40 <DukeDave> Thanks all
08:54:57 <quicksilver> DukeDave: the functor and monad instances for (,) and (->) are not available by default because they can lead to weird error messages
08:55:10 <yitz> cantor: so for that problem, first think about what the prime factorization of that number must look like. Then you'll see you don't really need to do programming to solve it. :)
08:55:11 <quicksilver> I'm not sure I entirely agree with the reason, but that is the reason.
08:55:18 <yitz> cantor: got to go for now.
08:55:19 <DukeDave> Ahaa
09:02:53 <thoughtpolice> pcc1: no, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=453#a453
09:05:22 <quicksilver> pcc1: by wrapping it in a newtype and accessing the underlying derived version
09:05:30 <quicksilver> pcc1: so, not exactly convenient, but possible.
09:17:07 <evident> hello everybody
09:17:51 <evident> http://www.mibbit.com/pb/rXVroA
09:17:53 <lambdabot> Title: Mibbit: PasteBin
09:18:04 <evident> I am having some problems using predicates
09:18:26 <evident> I wrote a little function (which is not doing anything yet) but i get an error when loading:
09:18:46 <evident> http://www.mibbit.com/pb/mmLhfx
09:18:47 <lambdabot> Title: Mibbit: PasteBin
09:19:08 <evident> what I want to end up doing:
09:19:22 <quicksilver> evident: your problem is that your type signature says it will work on all types "a"
09:19:30 <quicksilver> evident: but the definition you give uses numbers
09:19:34 <quicksilver> ([5,4,3])
09:19:40 <evident> give the function a predicate and a list and it will sort it... good ones to the left, bad ones to the right
09:19:45 <quicksilver> so it can't work for any type. Only number types.
09:20:02 <evident> so how can I change that?
09:20:47 <evident> partition :: (a -> Bool) -> [a] -> ([a],[a])
09:20:58 <evident> is the type signature i HAVE to use
09:21:04 <evident> it's given by the professor
09:21:54 <evident> Or can i define that my function only works with number types besides in the type signature?
09:22:03 <quicksilver> your signature is correct.
09:22:04 <Deewiant> you can replace 'a' with 'Int' while you develop/test and then change it back later... or change your default definition of [5,4,3] etc. to something which doesn't restrict the type
09:22:15 <quicksilver> it makes sense with the explanation you gave.
09:22:24 <quicksilver> but you can't use [5,4,3] with that signature.
09:22:38 <evident> not?
09:22:41 <quicksilver> as you said, your function isn't doing anything yet ;)
09:22:47 <quicksilver> but [5,4,3] does not have type [a]
09:23:50 <evident> well then, if i want to work with a list of Numbers (i.e: Int) my signature is wrong, isn't it?
09:24:06 <quicksilver> no.
09:24:16 <quicksilver> your signature says your function will work for any type
09:24:17 <evident> the example our prof made:
09:24:17 <evident> partition (<=3) [88,3,1,2,99] liefert ([3,1,2],[88,99])
09:24:19 <quicksilver> (including Ints)
09:24:26 <evident> "liefert" means "returns"
09:24:27 <quicksilver> since it will work for ANY type, including Ints
09:24:27 <evident> :)
09:24:31 <quicksilver> but also including Chars
09:24:33 <quicksilver> and Strings
09:24:39 <quicksilver> and Hamsters and Elephants and...
09:24:49 <quicksilver> ...since all of that, you can't use Ints as part of the definition.
09:24:56 <Deewiant> yes, remember the Hamsters, they're important
09:24:57 <evident> well and I cant compare Hamsters with a predicate, right?
09:25:05 <quicksilver> because if you use Ints as part of the definition, then it will ONLY work for Ints
09:25:06 <Ferdirand> sure you can
09:25:08 <quicksilver> that's not what you want
09:25:19 <quicksilver> you want it to work for ANY type, INCLUDING Ints
09:25:20 <Ferdirand> the signature says (a -> Bool)
09:25:22 <quicksilver> rather than ONLY ints
09:25:31 <evident> ok i get that
09:25:57 <evident> but I still dont know how i can fix the error...
09:26:39 <evident> the ([5,4,3],[9,3,6]) was just for example so the function doesnt return an error
09:26:48 <evident> or is the error I get caused by: ([5,4,3],[9,3,6])?
09:26:58 <quicksilver> yes
09:27:03 <evident> ahhhh
09:27:03 <quicksilver> the error is caused by [5,4,3]
09:27:10 <quicksilver> because you said the function would work for ANY type
09:27:15 <quicksilver> and then you gave one specific type
09:27:20 <quicksilver> which is not any type.
09:27:31 <evident> ahh right...
09:28:08 <evident> got it
09:28:32 <conal> OT: what version of latex do people like on linux?
09:29:12 <evident> thanks...
09:29:28 <evident> partition' pred (x:xs) = ((x:xs),(x:xs))
09:29:39 <evident> --> is general... so i dont get an error
09:29:45 <Deewiant> yep
09:29:48 <evident> now i only have to implement what i actually wanted to do
09:29:53 <evident> thanks for your help!
09:29:54 <evident> :)
09:29:56 <quicksilver> conal: I have always used tetex
09:30:02 <quicksilver> evident: yeah, that has the right type
09:30:04 <DukeDave> conal: Yeah tetex also
09:30:08 <quicksilver> evident: so would (xs,xs), and so on.
09:30:13 <mc__> whats wrong with "map (ord) "1234""
09:30:19 <Deewiant> TeX Live supercedes TeTeX
09:30:20 <evident> yeah
09:30:21 <evident> :)
09:30:29 <quicksilver> > map ord "1234"
09:30:30 <lambdabot>   [49,50,51,52]
09:30:35 <quicksilver> mc__: nothing is wrong.
09:30:37 <quicksilver> it works fine :)
09:30:41 <mc__> strange
09:30:45 <DukeDave> Ah actually yes, I think my latest one was TeX Live
09:30:51 <Deewiant> mc__: are you missing an import, mayhaps?
09:30:55 <mc__> over here it results in a parser error
09:31:04 <mc__> nope i have import Data.Char
09:31:17 <Deewiant> the problem probably isn't that, then
09:31:36 <quicksilver> mc__: probably you indented something wrongly
09:31:37 <mc__> very strange
09:31:38 <Deewiant> if the error comes from that line, it could be indentation
09:31:51 <mc__> my whole program is only 2 lines
09:31:56 <mc__> the import and that line
09:32:02 <Deewiant> well that's a problem :-)
09:32:14 <conal> thx for the tex advice.  i'll grab texlive.
09:32:14 <quicksilver> mc__: that's not a program.
09:32:19 <mc__> oh, lol
09:32:20 <quicksilver> mc__: that's an expression.
09:32:24 <mc__> sorry, nvm, brainfuck
09:32:39 <quicksilver> myfavouritevariablenameishamster = map ord "1234"
09:32:41 <Deewiant> [>+++++<-].
09:33:00 <Deewiant> ?help bf
09:33:01 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
09:33:05 <Deewiant> I spy a typo
09:41:23 <mathijs> Hi all, I'm trying to figure out why foldr can work on infinite lists and foldl can't, I've read 4 descriptions and all try to make it clear some other way. I understand this has to do with laziness but I can't figure it out.
09:42:07 <Baughn> > foldr f x [a,b,c]
09:42:09 <lambdabot>   f a (f b (f c x))
09:42:10 <Baughn> > foldl f x [a,b,c]
09:42:12 <lambdabot>   f (f (f x a) b) c
09:42:27 <Baughn> mathijs: Lazy evaluation = Outside-in evaluation, okay?
09:42:30 <mathijs> why would 1 + ( 2 + ( 3 + ( 4 + ( 5 + 0)))) evaluate the first part immediately? the parentheses would forbid this I would think
09:42:45 <Baughn> It wouldn't
09:43:14 <mathijs> so it can evaluate 1 + ( 2 + (.... to 3 + (... ?
09:43:42 <Baughn> Nope
09:43:47 <Baughn> But that's because it's +
09:44:08 <Baughn> + produces *one* result, that can't be reduced to simpler parts that can be individually evaluated
09:44:16 <Baughn> You need to replace it with a function like, say, :
09:44:23 <Baughn> > foldr (:) 0 [1..]
09:44:25 <lambdabot>       No instance for (Num [a])
09:44:25 <lambdabot>        arising from the literal `0' at <inter...
09:44:32 <Deewiant> [] not 0
09:44:37 <Baughn> > foldr (:) [] [1..]
09:44:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:44:40 <Baughn> ..right
09:45:14 <Baughn> mathijs: With (:), it /can/ finish the first part of the evaluation - basically passing back the first argument to : - before it even looks at its second argument
09:45:37 <mathijs> ok, so with + it won't work on infinite lists either? I just tried to reason about it using + (I thought it would be easiest to understand)
09:45:38 <Baughn> Which is good, since the second argument is infinite and wouldn't finish.. well, except that that second argument is itself constructed by repeated calls to :, that work the same way
09:45:48 <Baughn> mathijs: + would be sum, right? ;)
09:45:52 <mathijs> Baughn: tnx, and besides :, any other functions/operators that work?
09:46:26 <Baughn> mathijs: Any that are lazy. Um, for a rule of thumb...
09:46:49 <Baughn> mathijs: If you're folding to a small structure (like a single number), foldr won't work and foldl' will be efficient, being tail-recursive
09:47:23 <Baughn> mathijs: If you're folding to a big one that can be made from several parts, foldr will be able to give you the first part before the rest, foldl' can still only give you the whole thing at once, since it's tail-recursive
09:47:24 <mathijs> yeah that's the strict version right? I read that. I understand it too.
09:47:36 <Baughn> There's basically no reason to use foldl, ever
09:47:42 <Baughn> foldl' is okay
09:47:59 <Baughn> But the cases where you'd pick foldl over foldr are when the combining function is itself strict, so..
09:48:16 <mathijs> ah, ok... I get it... so foldr for big results on (infinite) lists, foldl' on everything else?
09:48:49 <Baughn> foldr is for complex results (that are constructed lazily) on any lists. foldl' is for simple/atomic, strictly produced results
09:48:53 <quicksilver> foldr for lists which can be produced "as you go along"
09:49:15 <quicksilver> foldl' for results (list or not) which are not ready "until it's all done"
09:49:18 <Baughn> The lazy/strict is the real issue, but there's no way to produce an atomic value lazily - it's either there or not
09:49:37 <Baughn> Which does not mean that non-atomic/complex/big ones are necessarily lazy
09:49:39 <mathijs> ok I get it (for now) thanks for clearing this up
09:51:24 * Baughn never quite feels satisfied with these explanations. I understand it, I think, but explaining it...
09:57:05 <pizza__> anyone get the "timer_create: invalid argument" problem with ghc? i can run ghci ok but cannot compile and run native code; i'm running debian with ghc6.8 and i've been struggling all morning with different versions of ghc, tried source, etc, nothing works. any clues?
09:57:06 <Philonous> The advantage of foldl' over foldr is that it doesn't have to build the thunks?
10:00:12 <Baughn> Philonous: Yes
10:00:22 <Beelsebob> well, it does
10:00:24 <Baughn> Philonous: The advantage of foldr over foldl, meanwhile, is that it does build the thunks
10:00:27 <Beelsebob> but it immediately destroys them
10:00:38 <Baughn> It all depends on whether you want the thunks or not
10:06:29 <Philonous> Ok, so the reason that foldr os favourable above foldl is that laze evaluation turns around the evaluation order. The first function that needs to be computed is the last one that gets forced, and since the "leftmost" operation computer by foldr is the last one to be computed, lazy evalutaion makes sure it might be the only one to ever be forced. Tricky :>
10:07:54 <Baughn> Indeed
10:08:08 <Baughn> If that was all it wouldn't be so bad, but of course haskell /mixes/ lazy and strict evaluation. :P
10:08:58 <IsoPallo_> Tricky evaluation :)
10:09:40 <IsoPallo_> But thanks, I always wondered why it was foldr I was supposed to use...
10:10:29 <Beelsebob> Philonous: the other advantage is that foldr needs to build a stack as it traverses the list forwards, and then colapse it on the way back.  foldl is tail recursive, and can be compiled into a loop
10:10:38 <bd_> the problem with foldl is the laziness is /completely useless/
10:10:45 <bd_> and just results in a huge stack once you force it
10:10:54 <Cale> I don't like thinking in terms of thunks if I don't have to. It's easier just to think about expressions, and how they're reduced.
10:10:55 <bd_> well
10:11:00 <bd_> /almost/ completely useless :)
10:11:14 <Cale> Not completely. It can be useful once you reach the end of the list.
10:12:03 <bd_> Cale: if the function is strict on the accumulator, which they often are unless they're just a data constructor or something, then when you force any of it you end up with a huge tower of evaluation to perform :|
10:12:25 <Cale> Well, yes.
10:12:31 <bd_> > sum [1..1000000] :: Integer
10:12:34 <lambdabot>   * Exception: stack overflow
10:12:37 <bd_> like that :|
10:12:56 <bd_> @src sum
10:12:57 <lambdabot> sum = foldl (+) 0
10:13:13 <bd_> really foldl' and foldl ought to be swapped :)
10:13:17 <Cale> The most common ones to need are foldr and foldl'
10:13:27 <Cale> But I don't think foldl and foldl' should be swapped.
10:14:17 <ddarius> IsoPallo_: There are a couple of pages on the wiki that explain these things.
10:14:25 <bd_> well, at the very least things like sum ought to be fixed :)
10:14:45 <bd_> > foldl' (+) 0 [1..1000000] :: Integer
10:14:47 <Cale> The idea behind foldl' not being in the Prelude is that the hope was that strictness analysis would catch most cases where you actually need a strict left fold.
10:14:47 <lambdabot>   500000500000
10:15:28 <ddarius> Cale: Can you provide a reference for that rationale?
10:15:30 <bd_> I see your point, but it doesn't seem to work too well...? At least in this case
10:15:35 <Cale> and you'll note that in cases like this, it actually does
10:15:49 <Cale> If you compile with optimisations, foldl' is unnecessary here.
10:16:00 <Cale> (at least in GHC)
10:16:08 <bd_> I suppose, but that means we have a function which is partial if and only if optimizations are off :)
10:16:21 <bd_> a very simple function at that
10:16:39 <Cale> ddarius: I can't recall who said that. It might have been Simon... someone from the Haskell committee.
10:16:57 <Cale> bd_: The real problem is that the stack is artificially bounded.
10:17:25 <ddarius> Cale: Using an extra O(n) factor of space is the real problem.
10:17:38 <Cale> ddarius: Well, that's what optimisations are for :)
10:17:58 <bd_> Surely the built-in libraries at least shouldn't change their semantics that dramatically when you change optimization :)
10:18:00 <ddarius> I prefer not relying on optimizations for asymptotic improvements.
10:18:11 <Cale> The semantics issue is the real problem.
10:18:22 <Cale> That you get _|_ unexpectedly when optimisations are off.
10:18:23 <ddarius> There's nothing semantically wrong there.
10:18:29 <bd_> How many 'real problems' did we go through in the last 10-20 lines? :)
10:18:47 <Baughn> The real problem is that the optimizer isn'T smart enough
10:18:54 <ddarius> You can get _|_ "unexpectedly" any time because we don't actually have Turing machines.
10:18:57 <Cale> Baughn: It *is* smart enough.
10:19:05 <Cale> Baughn: But you have to turn it on.
10:19:09 <Baughn> Cale: Only for very simple cases
10:19:22 <Baughn> Also, should we really need to turn on the optimizer to make the Prelude work right?
10:19:25 <Cale> Well, at least for this case.
10:19:41 <Cale> Things would work correctly if the stack was allowed to grow arbitrarily.
10:19:52 <ddarius> No, it would just take longer before you got a stack overflow.
10:20:10 <Cale> ddarius: Well, sure, there's a finite amount of memory available in most machines ;)
10:20:14 <Baughn> You'd get a machine crash instead of a stack overflow
10:20:24 <Cale> But it would take far larger examples to produce problems.
10:20:27 <ddarius> Cale: Indeed.  So there is no semantic issue here.
10:20:30 <Baughn> I've got -M512m in GHRTC for a reason. :/
10:20:48 <ddarius> (or at least no more than normal)
10:20:58 <bd_> Cale: However, sum [1..n] should be computable in O(lg(n)) space
10:21:12 <Cale> bd_: Right, which is why you want to compile with -O2 all the time.
10:21:15 <bd_> this change from O(lg(n)) to O(n) just by changing optimization is unexpected
10:21:23 <bd_> okay, so make that the default for ghci ;)
10:21:24 <Cale> I don't see it as unexpected.
10:21:45 <Cale> Optimisations can and should affect the asymptotic complexity of programs.
10:21:56 <bd_> Cale: But these changes should stop at a library boundrary
10:21:57 <Cale> (in a beneficial way, at least)
10:22:07 <Cale> bd_: Why?
10:22:13 <bd_> that is, the library API should guarentee certain time and space bounds - regardless of optimization level of the caller
10:22:25 <Cale> I don't think that's possible in general.
10:22:32 <bd_> where practical, in that cast
10:22:33 <bd_> case*
10:22:39 <BrokenClockwork> http://hpaste.org/11799 , not in scope with "insert". What's the matter, I found insert @Hoogle
10:22:43 <bd_> where it won't be unexpected :)
10:22:48 <Baughn> Isn't this only a problem because it inlines (thus recompiling) sum even with -O0?
10:22:53 <Cale> You can do much better if you allow cross module optimisation.
10:23:01 <bd_> I mean, we're seeing an implementation detail (sum using foldl instead of foldl') being exposed in a very violent way
10:23:21 <bd_> which, IMO, is something to be avoided
10:23:24 <Cale> bd_: sum is polymorphic, and sometimes you really do want the lazier foldl
10:23:27 <Baughn> Cross-module inlining should be an optimization, and thus not happen when optimizations are off
10:23:35 <bd_> Cale: for example?
10:23:38 <Cale> bd_: Depending on the type of number involved.
10:24:02 <bd_> Cale: Doesn't that mean we're optimizing for the uncommon case? :)
10:24:09 <Cale> Well, I'll admit that you're more likely to want sum = foldr (+) 0
10:24:16 <Cale> in the cases that it matters
10:24:27 <Cale> (like summing powerseries)
10:24:29 <bd_> Cale: you mean foldl', for O(lg(n)) space
10:24:34 <Cale> bd_: no.
10:24:37 <bd_> oh?
10:24:50 <Cale> bd_: I mean summing numbers which have infinite structure.
10:24:56 <bd_> oh
10:25:38 <Cale> Like naturals, power series, or various representations of computable reals.
10:25:39 <ddarius> In my opinion, it is extremely rare to want foldl and in that rare cases where it is what you want it certainly wouldn't hurt to be explicit about it.
10:25:39 <bd_> as a practical matter, I think most uses of sum are with ordinary numeric builtins, however, and the implementation should reflect that. If optimizations /do/ change semantics, this should only happen in the uncommon cases
10:25:58 <Cale> It's possible that we want more optimisations turned on by default.
10:26:10 <Cale> bd_: Optimisations are not changing semantics here.
10:26:31 <bd_> Cale: They are on a machine with bounded space
10:26:44 <Cale> Yes.
10:26:45 <bd_> which encompasses all computing devices we can actually build
10:27:12 <Cale> But the problem could be masked to a large extent by not putting such strict arbitrary limits on stack space, for one.
10:27:24 <bd_> so, as a practical matter, I don't think it matters that the behavior on a theoretical infinite space machine are unchanged
10:27:44 <bd_> to an extent, yes, but I still feel that such radical changes in performance should not occur
10:27:45 <ddarius> Cale: All that does is delay the hard failure, and turn a hard failure into a soft failure.
10:28:08 <ddarius> "masking errors" is not something I'm keen on
10:28:34 <Cale> ddarius: Well, it would turn the crash into just using a bit more space.
10:28:56 <Cale> Well, applying strictness analysis would obviously be the best thing here.
10:28:57 <bd_> Cale: How much is 'a bit more', though?
10:29:09 <Cale> bd_: Linear space to hold the expressions you're building.
10:29:22 <bd_> Which is quite a lot really :)
10:29:27 <ddarius> Strictness analysis is an inherently unreliable optimization and, pragmatically, is completely unstandardized.
10:29:41 <ddarius> Cale: That's v. potentially constant space.
10:30:12 <bd_> what it boils down to is Haskell doesn't guarentee that sum will execute using any reasonable space bound, which is just plain silly when it can do so in a deterministic way
10:30:15 <ddarius> That's unacceptable in more ways than one.
10:31:01 <Saizan_> so, how is sum defined in Haskell' ?
10:31:56 <bd_> hmm, afk a bit (appointment somewhere at 2)
10:32:03 <Cale> bd_: What should happen is sum should be specialised for various common types so as to be stricter.
10:32:12 <Cale> yep, I'm off too.
10:32:18 <Samy> sum'
10:38:19 <u_quark> can i select the hackage lib version i want to install from cabal-install ?
10:38:50 <Saizan_> cabal install foo-1.2.3
10:39:02 <u_quark> ahaa tnx
10:40:22 <u_quark> haskell-src-exts doesn't compile :(
10:40:40 <Samy> Does Simon Marlow IRC?
10:40:47 <ddarius> Yes.
10:41:08 <Samy> ddarius, what nickname does he usually go by?
10:41:14 <Beelsebob> jaffacake
10:41:27 <u_quark> at least 0.3.9
10:41:30 <Samy> Aha.
10:41:34 <Samy> Thanks
10:41:38 <mauke> preflex: . who:SimonMarlow
10:41:38 <preflex>  JaffaCake
10:42:02 <BONUS_> i was surprised to see graham hutton here the other day
10:42:06 <BONUS_> didnt know he frequented this channel
10:42:08 <ddarius> mauke: What's the . for?
10:42:22 <mauke> to retrieve factoids
10:43:22 <rog> i've got a little algorithmic puzzle, at http://hpaste.org/11800. i'm wondering if it's possible to write the combs function in constant space (i.e. to avoid sorting the entire list of combinations). any ideas?
10:43:33 <vixey> :(
10:43:58 <vixey> I really hate that name combs
10:44:06 <vixey> your function does not produce combs
10:44:12 <rog> the basic idea is that i've got a set of variables, each with a set of possible states and associated probability.
10:44:17 <vixey> the module has a great name
10:44:22 <rog> vixey: i agree, actually.
10:44:44 <rog> vixey: sometimes thinking of a good name takes more time than writing the code.
10:44:52 <vixey> rog, absolutely
10:45:28 <rog> i wish to produce a set of combinations of variable states, ordered greatest total probability first.
10:45:47 <vixey> ok so see this: [[(Double, a)]] -> [(Double, [a])]
10:45:57 <vixey> The first thing I would suggest is to create a type for it
10:46:18 <vixey> type Something maybe taking a as a paremeter = [[(Double, a)]] -- along those lines anyway
10:46:19 <rog> vixey: i've done that, actually. data Prob a = Prob Double a
10:46:49 <rog> so the type then is [[Prob a]] -> [Prob [a]]
10:47:04 <vixey> ok
10:47:28 <rog> but the question is how to pick off the highest probability states one by one.
10:48:46 <Pistos> BONUS: I'm reading through your tutorial... good work.  :)
10:48:51 <Pistos> <-- non-haskellist
10:48:55 <Pistos> [for now]
10:52:27 <rog> i'm sure it must fall into a known class of problem.
10:52:41 <rog> i just can't work out if it's solvable.
10:52:56 <Saizan_> rog: btw, combs' is sequence in the WriterT (Product Double) [] monad, not that it necessarily helps with your problem :)
10:53:13 <vixey> m
10:53:23 <vixey> can't you sort a list in constant space though?
10:53:54 <rog> vixey: the problem is that if the number of combinations is large (e.g. 2^50) you can't generate the list at all.
10:56:19 <rog> i hadn't seen Product before. nor was i familiar with WriterT. fantastic.
10:56:34 <Saizan_> rog: if you sort the inner lists in decresing order first, then the combination resulting from picking the first elements of each should have the highest probability, no?
10:57:39 <rog> Saizan_: i've been trying to convince myself of something similar.
10:58:53 <hukolele_> is it possible in Parsec to get the string to be parsed and transform it? i want to deal with all combinations of upper/lower case characters in the same way, so for example get all the chars of the input stream and uppercase all of them
10:59:19 <hukolele_> or i should to generate all the posibble combinations of identifiers?
10:59:21 <vixey> hukolele_: yeah you can do that
10:59:44 <byorgey> hukolele_: can't just just uppercase the input before you give it to Parsec?
10:59:45 <vixey> hukolele_: I guess there's a parser combinator like   string "Foo" which matches the string "Foo"?
11:00:05 <vixey> hukolele_: why not write one called insensitiveString which takes a string and matches any case of it
11:00:34 <hukolele_> yeah but how can i get access to the input stream?
11:01:24 <byorgey> hukolele_: I'm not sure what you're asking.  The input stream has to come from somewhere, and you have to explicitly call 'parse' on it.  So, before calling 'parse' on it, convert it to uppercase.
11:01:26 <hukolele_> byorgey, i dont want to upper case all the stream because it only makes sense when appears some special identifiers
11:01:31 <byorgey> oh, I see.
11:01:43 <byorgey> well, then vixey's suggestion is a good one.
11:01:51 <mdmkolbe> Is there Ptr varient for untyped pointers (e.g. void*)? (I haven't been able to find one so far, but maybe I just missed it.)  (I'm translating an FFI from a caddr_t object.)
11:02:02 <rog> Saizan_: if fact, no. counter-example: combs' [[Prob 0.5 "1", Prob 0.35 "2"], [Prob 0.7 "1x", Prob 0.3 "2x"]]
11:02:14 <sdfvdvf> anyone here using openVision?
11:02:27 <sdfvdvf> (computer vision stuff for haskell)
11:02:33 <byorgey> chari c = try (char (toUpper c)) <|> char (toLower c)
11:03:00 <vixey>  nice!
11:03:05 <hukolele_> oh, quite simple, thx...
11:03:06 <byorgey> stringI s = sequence $ mapM chari s
11:03:15 <hukolele_> beautiful!
11:03:17 <sdfvdvf> i have tried to install it on both windows and ubuntu but _> FAIL
11:03:18 <vixey> stringy =
11:03:19 <rog> Saizan_: 0.5 * 0.3 < 0.35 * 0.7
11:03:59 <byorgey> hehe, yes, I like 'stringy' better =)
11:04:20 <byorgey> oh, wait, you don't even need the 'try'
11:04:34 <byorgey> just  chari c = char (toUpper c) <|> char (toLower c)
11:04:51 <byorgey> you only need 'try' when the first option might consume some input before failing
11:05:00 <byorgey> and you want it to backtrack.
11:05:25 <hukolele_> i know, thx for the advice
11:05:51 <jeffersonheard> here's a fun one...  I know ahead of time that I need a certain amount of memory on the stack, so I did a +RTS -K512m -RTS, and that causes the program to fall into an infinite loop
11:05:54 <jeffersonheard> or a nearly infinite one
11:06:06 <jeffersonheard> whereas if I run it without the RTS options, I don't have the problem
11:06:20 <jeffersonheard> but the program is slower as it starts up
11:06:22 <byorgey> ...!
11:07:00 <sw17ch> jeffersonheard, that's scary
11:07:04 <jeffersonheard> yep.
11:07:17 <Saizan_> rog: yeah but 0.5*0.7, resulting by picking the first element of each is greater than those
11:08:17 <jeffersonheard> strange place that it does so, too.  right in the middle of an OpenGL call.
11:08:19 <byorgey> jeffersonheard: hm, have you fed the memory elves recently?
11:08:28 <jeffersonheard> 16GB of silicon, yep
11:08:31 <byorgey> sometimes when they're hungry they get sort of cranky
11:08:36 <jeffersonheard> heh
11:09:14 <jeffersonheard> the problem was worse when I used the threaded RTS. calling GTKs initGL with -threaded linked caused the whole thing to just bork up
11:09:25 <jeffersonheard> now, single threaded and it works
11:09:28 <byorgey> jeffersonheard: what version of GHC is this?
11:09:35 <jeffersonheard> 6.8.3 :_
11:09:37 <jeffersonheard> :)
11:11:26 <jeffersonheard> I've got 8 cores, and I'd love to flip these pixbufs vertically using forkIO before loading them into textures, but that seems not to work
11:11:51 <jeffersonheard> Something simpler, like GLUT next time, I think.   and DevIL
11:13:01 <rog> Saizan_: picking the first largest is easy. it's just getting the next ones that i haven't quite got yet...
11:14:06 <jeffersonheard> It's really my own fault for trying to get too many things working together at once
11:14:32 <Beelsebob> jeffersonheard: OpenGL can't be run on anything other than the main thread on most OSes
11:14:53 <jeffersonheard> Oh I realize that, Beelsebob.  Very careful to only run in on the main thread
11:15:18 <jeffersonheard> was dealing with GdkPixbufs on multiple threads, compiling the results into buffers, and then going back to the main thread to do texturing and such
11:16:13 <dons> http://www.reddit.com/r/haskell/comments/7bt49/par_just_got_significantly_cheaper_more/
11:16:15 <lambdabot> Title: `par` just got significantly cheaper. More parallelism for GHC! : haskell, http://tinyurl.com/5r23m8
11:16:16 <dons> woot
11:16:31 <jeffersonheard> dons: that is awesome!
11:16:51 <jeffersonheard> This will go into GHC 6.10 in the final release?
11:17:09 <dons> not sure. bug JaffaCake
11:17:20 <Beelsebob> I thought 6.10 was already out?
11:17:27 <byorgey> it is!
11:17:27 <Beelsebob> wasn't 6.10.1 released on tuesday?
11:17:39 <dons> the question is whether such a thing merges to stable
11:18:14 <jeffersonheard> Must have missed that.  It's been a busy week
11:18:39 <eu-prleu-peupeu> hello magic people from haskell
11:19:17 <Peaker> How do I convert a lazy bytestring to a normal bytestring?
11:19:21 <MyCatVerbs> We're not really magic. It's just the background music and the exotic semantics that give that impression.
11:19:36 <lilac> :D
11:19:38 <MyCatVerbs> Peaker: toChunks
11:19:51 <Peaker> MyCatVerbs: thanks
11:20:16 <Peaker> MyCatVerbs: B.concat . B.toChunks ?
11:20:20 <MyCatVerbs> Peaker: and fromChunks. Convert a lazy bytestring to a lazy list of strict ones, and vice versa.
11:20:25 <MyCatVerbs> Peaker: aye.
11:20:28 <Peaker> ah, thanks
11:20:53 <eu-prleu-peupeu> check it out: http://lambda-the-ultimate.org/node/3084
11:20:54 <lambdabot> Title: Type Checking with Open Type Functions | Lambda the Ultimate
11:21:00 <eu-prleu-peupeu> can anyone explain me the implications of this ?
11:21:58 <rog> Saizan_: i'm starting to convince myself that it's not possible. but an approximate solution would still be useful...
11:24:15 <thoughtpolice> eu-prleu-peupeu: it means there is now a solid basis for typechecking with type families, meaning they're less experimental and more genuinely useful
11:24:20 <thoughtpolice> eu-prleu-peupeu: and they are very nice, btw
11:25:32 <eu-prleu-peupeu> i dont understand types stuff
11:26:15 <MyCatVerbs> eu-prleu-peupeu: A lot of the time, you come to an understanding of the more complicated type system features at about the same time as you find yourself needing one of them.
11:26:20 <thoughtpolice> eu-prleu-peupeu: they basically give you functions at the type level.
11:27:51 <thoughtpolice> eu-prleu-peupeu: and with them you can encode some useful properties, e.g. http://thoughtpolice.stringsandints.com/code/haskell/misc/type-vectors.hs <- uses type families to encode length properties into the type of a vector itself.
11:27:57 <lambdabot> http://tinyurl.com/66ppjz
11:28:15 <dons> woot, btw, http://www.reddit.com/r/programming/comments/7bt7j/haskells_fine_grained_parallelism_just_got_even/
11:28:18 <lambdabot> Title: Haskell's fine grained parallelism just got even cheaper! : programming, http://tinyurl.com/5ar69a
11:28:18 <dons> for the masses.
11:28:21 <thoughtpolice> eu-prleu-peupeu: and what that code means is that you can't e.g. compare two vectors of different length - their types would not match so at compile time we know something is wrong
11:28:55 <eu-prleu-peupeu> thoughtpolice, yes i had that problem once
11:29:08 <eu-prleu-peupeu> precisely with vectors and matrices
11:29:28 <shepheb> that's great, dons!
11:29:30 <thoughtpolice> eu-prleu-peupeu: in practice they are useful, and with ghc 6.10 they really work and aren't just experimental.
11:29:35 <eu-prleu-peupeu> i used type classes to solve it
11:29:39 * shepheb sighs and starts the GHC 6.12 countdown
11:29:43 <eu-prleu-peupeu> so i had a Vector type class
11:29:45 <thoughtpolice> eu-prleu-peupeu: you can encode a lot of interesting properties, and you don't need functional dependencies either
11:30:12 <thoughtpolice> imo ATs > fundeps, much easier to grok.
11:30:22 <eu-prleu-peupeu> i would really like to expand on that ideas, ill read the paper and try to understand it
11:31:17 <thoughtpolice> eu-prleu-peupeu: you shouldn't really need to read the entire paper, it's about the typing rules and how to typecheck in the presence of type families
11:31:30 <thoughtpolice> eu-prleu-peupeu: look here - http://haskell.org/haskellwiki/GHC/Indexed_types
11:31:33 <thoughtpolice> lots of examples and info
11:31:35 <lambdabot> Title: GHC/Type families - HaskellWiki
11:31:49 <dsfsddfsfdfsd> ANYONE USING OPENVISION?
11:31:58 <eu-prleu-peupeu> thanks :D
11:32:17 <eu-prleu-peupeu> dsfsddfsfdfsd: what is open vision ?
11:32:19 <sw17ch> how much of GHC is straight C codE?
11:32:28 <whoppix> Did i got that right, that my haskell compiler will automatically parallelize tasks, like complex equations, where the result is not needed immediately, without any intervention from the programmer?
11:32:37 <thoughtpolice> whoppix: no
11:32:45 <MyCatVerbs> whoppix: no.
11:32:50 <thoughtpolice> sw17ch: RTS is like 50kLOC iirc
11:33:12 <dsfsddfsfdfsd> open vision is a computer vision/image analysis package for/in haskell
11:33:14 <jeffersonheard> dons: does that patch mean that parMap is finally useful?
11:33:17 <sw17ch> thoughtpolice, is RTS the only place you find C code?
11:33:27 <thoughtpolice> sw17ch: might not be, but i'd think that's the bulk of it
11:33:29 <MyCatVerbs> whoppix: but it's almost trivial to put in the annotations to have tasks parallelized.
11:33:37 <sw17ch> thoughtpolice, good enough for me
11:33:37 <thoughtpolice> sw17ch: i'd say run something like http://cloc.sf.net over it
11:33:43 <lambdabot> Title: CLOC -- Count Lines of Code
11:33:54 <sw17ch> hmmm
11:33:55 <sw17ch> cool tool
11:33:55 <Corun> Line of Code = Awesomeness of program
11:34:02 <Corun> Just so you know.
11:34:16 <MyCatVerbs> whoppix: and they're guaranteed - no matter how crazy your usage of them might be - to never ever cause your code to actually go wrong.
11:34:30 <thoughtpolice> whoppix: i don't know where people get that idea; with GHC you can add some basic annotations that will result in parallelization, but automagic parallelization? no, that's a pretty damn hard problem in the general case.
11:34:55 <whoppix> MyCatVerbs, hm, but shouldn't it be technically possible to calculate a deferred expression in a secondary thread, while the main thread is going on?
11:35:14 <thoughtpolice> whoppix: the problem is determining what expressions are even worth making parallel in the first place
11:35:30 <whoppix> hm, yeah, i see how that could be a problem.
11:35:32 <MyCatVerbs> whoppix: yes, and that's pretty much precisely what you do. Working out which are worth doing that for automatically isn't feasible.
11:35:52 <thoughtpolice> whoppix: if the compiler inserts a bunch of code to make things parallel, and like 50% of that goes to expressions which aren't even worth parallelising because they're so short, you're just costing yourself time
11:35:56 <whoppix> perhaps some JIT-alike runtime analysis system could figure out stuff like that.
11:36:03 <IsoPallo_> Hmm... Doing that at program level would be nice :)
11:36:26 <IsoPallo_> "Error: This program isn't worth compiling"
11:36:39 <MyCatVerbs> whoppix: so you end up with the serial version being: foo x = bar (expensivethingA x) (expensivethingB x), and the parallel version being: foo x = let B = expensivethingB x in B `par` foo (expensivethingA x) B
11:37:02 <MyCatVerbs> whoppix: (roughly, assuming that in that case, bar takes some time munching on its first parameter before it looks at the second one at all).
11:37:03 <thoughtpolice> whoppix: purity just means that you can evaluate stuff in parallel and it's guaranteed not to change the semantics of your program, but it doesn't lead to automatic parallelisation, although you can get close with things like 'par' and now data parallel haskell
11:37:46 <thoughtpolice> whoppix: but there is research on the front, using profiling information from executables to guide further compiler optimizations
11:37:51 <MyCatVerbs> whoppix: the nicest bit is that we can guarantee that, no matter how badly you use `par`, while you might accidentally slow your program down, you won't ever actually make it become incorrect with par alone.
11:37:56 <thoughtpolice> whoppix: google "Feedback directed implicit parallelism"
11:38:18 <sw17ch> @remember IsoPallo "Error: This program isn't worth compiling"
11:38:19 <lambdabot> I will remember.
11:38:55 <whoppix> hm, well, sounds like a good thing, if you could realize something like that automatically for frequently re-run parallelizeable expressions
11:40:24 <whoppix> and perhaps wasting a few cycles isn't so drastic anymore nowaday, since the trend goes to multiple core CPUs, so perhaps one would need to make some real world tests if the benefits outweight the demerits
11:40:53 <MyCatVerbs> whoppix: nah, actually this is all doomed anyway.
11:41:08 <whoppix> how so?
11:41:12 <MyCatVerbs> whoppix: the memory bottleneck is going to destroy everything else and all of this work on SMP parallelism will turn out to have been a waste of time.
11:41:47 <MyCatVerbs> whoppix: we'll all eventually be forced towards explicit message-passing in the end.
11:41:48 <whoppix> MyCatVerbs, how is the memory bottleneck an issue? I mean, if it is should depend on what you are doing, and with what algorithm.
11:42:14 <whoppix> perhaps some tasks take up little memory, but a lot of cpu, and are parallelizeable
11:42:41 <MyCatVerbs> whoppix: because desktop CPUs are *already* bound by memory bandwidth. Putting more processors on the same memory bus is, er, optimistic at best.
11:43:00 <MyCatVerbs> whoppix: but then I *would* say that; the guy who built the Transputer is one of my lecturers. =D
11:43:42 <whoppix> MyCatVerbs, hmm, we need to make the buses faster! :)
11:44:07 <rog> MyCatVerbs: it's funny, but back when inmos transputers were actually competitive cpu-wise, people were saying that even then, i recall.
11:44:09 <MyCatVerbs> whoppix: that's a nice thought. How wide and how expensive are you willing for you motherboard to become?
11:44:46 <MyCatVerbs> whoppix: not to mention, how large are you willing for the latency in between your bulk memory and your processors to become in relation to the processors' cycle time? :)
11:44:59 <sw17ch> whoppix, Intel tried to do that... in the end, it doesn't matter how fast your bus is
11:45:33 <MyCatVerbs> rog: yeah, and then the whole superscalar microcomputer thing came up, IIRC. :)
11:45:39 <ushdf> give me one of those
11:45:43 <whoppix> MyCatVerbs, shouldn't the latency go down, if you make the bus faster? (sorry, im not exactly a hardware expert, or something...)
11:45:45 <rog> MyCatVerbs: it's funny - we moved from a platform built around 64ish independent transputers to a single 486... and it's taken until around now for things to move back (somewhat)
11:45:58 <ushdf> wider, not faster
11:46:11 <ushdf> latency remains the same, right?
11:46:19 <whoppix> thats what i would think
11:46:39 <sw17ch> whoppix, what do you do to the bus when you have more cores?
11:46:40 <MyCatVerbs> sw17ch: What definition of "fast" are you referring to there? You might be conflating latency and throughput, both of which matter and both of which are a pain in the unmentionables to improve.
11:46:51 <vininim> catMaybes <3
11:46:59 <MyCatVerbs> vininim: agreed. ^^
11:47:06 <whoppix> sw17ch, distribute the bus' capacity between the cores, i guess?
11:47:10 <sw17ch> MyCatVerbs, this is my point :) it doesn't matter your definition of fast, eventually, it won't be fast any more
11:47:26 <sw17ch> whoppix, but then all your cores slow down linearly with the number of cores you add
11:47:38 <MyCatVerbs> sw17ch: yes it does. You can trade off latency for throughput or vice versa...
11:48:21 <whoppix> sw17ch, if that is so, why do people make computers with more and more cores? I've somewhere heard prognoses about normal desktop computers having 10-100 cores in a decade or so.
11:48:24 <vininim> @pl \ x -> catMaybes [f x, g x]
11:48:25 <lambdabot> catMaybes . liftM2 (:) f (return . g)
11:48:42 <MyCatVerbs> whoppix: the latency is bounded below by a number of things - distances for one thing, and the amount of time taken to address any particular word, for another.
11:48:44 <sw17ch> whoppix, i'm just trying to make the point that just making the bus faster doesn't fix anything
11:48:49 <vininim> ... ok
11:49:45 <whoppix> sw17ch, ah, well, i guess a cpu with a hundred cores sounds fancier and sells better, than a cpu with 1 or two cores :)
11:49:48 <MyCatVerbs> whoppix: uhuh. And a few years back, you were hearing projections about 4GHz+ CPUs with Pentium-4-length-or-longer pipelines coming out of Intel. :)
11:50:19 <whoppix> MyCatVerbs, aren't modern cpus basically stuck at 2-3GHz?
11:50:22 <sw17ch> MyCatVerbs, Pentium 4 pipelines make me cry
11:50:38 <MyCatVerbs> whoppix: at roughly the same time, you might even have heard nice things about extremely wide VLIW processing coming from roughly the same company.
11:50:40 <sw17ch> "wait, a branch prediction miss costs you HOW MANY CYCLES???"
11:51:29 <MyCatVerbs> sw17ch: if a customer ever tells me they need some piece of software optimized for the P4's ideosyncracies, I'm probably going to tell them to just bite the bullet and buy -real- computers already. :)
11:51:47 <whoppix> MyCatVerbs, nope, didn't heard about. But then again, I don't know a lot about hardware, although, cpu design sounds like quite an interesting thing, really.
11:51:54 <MyCatVerbs> *idiosyncrasies.
11:52:18 <sw17ch> whoppix, it's fun... but quite overwhelming
11:52:27 * MyCatVerbs nods at sw17ch.
11:52:39 <whoppix> i can imagine that.
11:52:52 <whoppix> or, well, maybe i can't
11:52:58 <whoppix> anyway, i see your point. :)
11:53:17 <sw17ch> talking about assembly and instruction set architectures is nice and all.... but then you deal with branch prediction, pipelining, then you have issues with sending data back down your pipeline (outside of registers!!) to make sure you can keep your insanely long pipeline full.....
11:53:26 <vininim> @pl return x >>= \ x -> catMaybes [f x, g x]
11:53:27 <lambdabot> catMaybes [f x, g x]
11:53:35 <vininim> lambdabot++
11:53:42 <MyCatVerbs> It's a pretty wide field. It's pretty cool. It's also somewhat tainted with bullcrap, from people who're more interested in selling whatever crap their engineers put out this month than making good chips, but that's only really a problem if you read marketroid spiel. :)
11:53:42 <sw17ch> and then you talk about caching, and multiplication algorithms, and register coloring algorithms....
11:53:45 <vininim> vininim--
11:54:14 <nornagon> vininim: itym, lambdabot <- lambdabot + 1
11:54:30 <MyCatVerbs> sw17ch: the last was a compiler issue, the last but one a logic design detail which is I think pretty much solved, provided you don't mind throwing many, many transistors at the problem. :)
11:54:41 <nornagon> or perhaps modify (+1) lambdabot
11:55:08 <vininim> sounds like a great idea for the karma system
11:55:44 <nornagon> i forgot about that.
11:55:56 <sw17ch> MyCatVerbs, i remember one that wasn't necessarily in the compiler
11:56:33 <thoughtpolice> yeah register allocation is its own beast entirely.
11:56:38 <sw17ch> I can't remember the name, but it is responsible for assigning adding units and multiplication units to work in parallel, and uses a register coloring algorithm to emulate having an infinite number of them
11:56:40 <MyCatVerbs> sw17ch: oh, you mean associating real registers to architectural registers?
11:56:43 <sw17ch> again, lots of transistors
11:56:55 <thoughtpolice> oh
11:56:59 <sw17ch> MyCatVerbs, I wish i could think of the algorithm name, starts with a T
11:57:53 <MyCatVerbs> sw17ch: I have no idea. Sounds cool, though.
11:58:50 * sw17ch misses his architectures course
12:02:01 <EmielRegis> if i have a function
12:02:05 <EmielRegis> that retuns a char
12:02:16 <EmielRegis> can I return a '' if there is no char to be returned?
12:02:23 <EmielRegis> because im getting compiler errors on tht
12:02:31 <EmielRegis> | otherwise = ''
12:02:46 <MyCatVerbs> No. '' is not a character.
12:02:52 <Badger> []?
12:02:56 <int-e> EmielRegis: no you can't. You can change the return type to Maybe Char though, and return Just 'c' (c being the character in question) or Nothing
12:03:05 <Badger> huh.
12:03:08 <MyCatVerbs> Presumably what you actually wanted to write was a function that returned Maybe Char?
12:03:18 <EmielRegis> no not really...
12:03:31 <camio> EmielRegis: What does your function do?
12:03:35 <EmielRegis> writing a function that removes non-alphabetic characters
12:03:38 <MyCatVerbs> Then if there is a character to be returned, it returns Just c, otherwise it returns None.
12:03:40 <EmielRegis> using map on a string
12:03:49 <Badger> what does ['a'..] keep printing after it reaches z?
12:03:50 <MyCatVerbs> You can't do that. You need to use filter.
12:03:52 <EmielRegis> but im not allowed to use Maybe
12:03:52 <int-e> EmielRegis: you can't. you can use concatMap (and Badger's idea)
12:03:53 <mauke> EmielRegis: try filter instead of map
12:03:56 <int-e> or filter
12:03:59 <EmielRegis> wait sorry
12:04:01 <EmielRegis> i meant filter
12:04:06 <mauke> > ['a' ..]
12:04:07 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
12:04:07 <int-e> or ... map and catMaybes
12:04:16 <int-e> ah, so many options.
12:04:19 <Badger> unicode?
12:04:21 <EmielRegis> oh wait
12:04:23 <EmielRegis> im stupid
12:04:23 <MyCatVerbs> Badger: it goes with through the whole of the Unicode code point space above 'a'. :)
12:04:25 <EmielRegis> soryr i got it :P
12:04:30 <Badger> ah :)
12:04:52 <int-e> > length ['\0'..]
12:04:57 <RayNbow> > drop 10000 $ ['a' ..]
12:04:57 <lambdabot>   1114112
12:04:59 <mauke> as seen in ##c++: <simpletext> can you help me understand templates  <MisterN> simpletext: yeah if you understand monads
12:04:59 <lambdabot>   "\10097\10098\10099\10100\10101\10102\10103\10104\10105\10106\10107\10108\1...
12:05:59 <int-e> So what does MisterN think monads are?
12:06:27 <vixey> the MisterN-howard isomorphism
12:06:57 <Badger> > beef `elem` ['a'..]
12:06:58 <lambdabot>   Not in scope: `beef'
12:07:06 <rog> if anyone was interested in my probable combinations problem, i've put some results at http://hpaste.org/11800#a2 which convince me, at any rate, that the problem isn't simple. higher probability combinations don't necessarily contain the highest probability state. i'm wondering how good it's possible to get.
12:07:08 <mauke> preflex: seen beef
12:07:08 <preflex>  beef was last seen on ##c++ 29 days, 12 hours, 31 minutes and 8 seconds ago, saying: All I know is, I have boobs and a penis... so I'm all good.
12:07:08 <whoppix> I found templates quite easy to understand, if you imagine visually that the compiler will at compile time replace all of the nasty Ts and Us by actual types.
12:07:09 <Badger> > 'beef' `elem` ['a'..]
12:07:10 <lambdabot>   <no location info>:
12:07:10 <lambdabot>      lexical error in string/character literal at chara...
12:08:43 <Badger> :<
12:08:50 <vininim> @where enumerate
12:08:51 <lambdabot> I know nothing about enumerate.
12:08:53 <Deewiant> > "beef" `elem` ['a'..]
12:08:54 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
12:09:05 <Badger> ah.
12:09:43 <vininim> @where enumFrom
12:09:44 <ttt--> hi, do most packages on hackage work with ghc 6.10.1?
12:09:44 <lambdabot> I know nothing about enumfrom.
12:09:50 <vininim> @src enumFrom
12:09:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:10:00 <Badger> heh
12:10:04 <vixey> enumFrom n = [n..]
12:10:13 * Badger wants a lambdabot
12:10:21 <Badger> if only it compiled
12:11:07 <mrd> enumFrom n = iterate succ n
12:11:51 <Peaker> BeelsebobWork: are you here?
12:11:59 <Badger> > let enumFrom n = iterate succ n
12:12:00 <lambdabot>   <no location info>: parse error on input `;'
12:12:03 <lilac> Badger: GHC6.10.1 woes?
12:12:15 <Beelsebob> Peaker: nope
12:12:19 <Badger> lilac: it's 6.8, actually
12:12:20 <Peaker> Beelsebob: :-)
12:12:23 <Beelsebob> :P
12:12:24 <nha_> can someone give me some advice? I have an FFI'd library that uses a lot of internal state and i want some way to mark code to show that it changes state. Whats the best way to achieve this? Use a dummy monad ontop of IO?
12:12:50 <lilac> Badger: this gets it compiling on 6.10.1; might help: http://metafoo.co.uk/downloads/lambdabot-ghc-6.10.1.diff
12:12:51 <Badger> but its configure tells me gcc can't create executables. :P
12:12:57 <Badger> oh?
12:13:14 <Peaker> Beelsebob: I was wondering if Phooey is capable of expressing a UI consisting of 2 integer-editing widgets, a and b, such that b presents (a*2), bidirectionally.  i.e: you can change a OR b and it will propagate in either direction
12:13:20 <vixey> does anyone want to comment on my language?
12:13:21 <lilac> Badger: but i've not seen that problem, so i suspect your issue is something else.
12:13:24 <vixey> it's like < 100 lines of haskell
12:13:34 <Badger> lilac: most likely :(
12:13:41 <Badger> but thank you for the link.
12:13:42 <Beelsebob> Peaker: no clue -- I haven't played with phooey at all
12:13:52 <vixey> (including example)
12:14:13 <Peaker> Beelsebob: Hmm, can Reactive represent bidirectional dependence between two changing values?
12:14:15 <lilac> vixey: where?
12:15:03 <vixey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=330
12:15:03 <vixey> I'm mostly wondering if the set of primitives is good
12:15:19 <vixey> (Var Lam App Con Cas, and I suppose I must add Fix)
12:15:30 <Beelsebob> Peaker: good question -- I guess it would need something along the lines of val1 = userEdit `mappend` val2; val2 = userEdit `mappend` val1 :: Reactive -- but I can't immediately see how to break the infinite cycle there -- perhaps tag values in the reactive as having come from the other
12:16:10 <Peaker> Beelsebob: perhaps identify that it is "stable" (no change actually occured)
12:16:19 <Beelsebob> that too
12:18:32 <rog> vixey: what are you aiming towards?
12:20:03 <Eelis> is there some specific reason why there is no MonadFix instance for Parsec parsers?
12:21:18 <vixey> some kind of target to have evaluation for various kinds of (lazy) language -- but of sensible efficiency as well as being able to prove termination of some smaller programs
12:21:43 <vixey> so lazy lambda calculus with tagged vectors and case on them seems a good place to go
12:22:10 <vixey> but, is it, maybe I overlook something?
12:22:37 <rog> vixey: trivial point: why Cas, not Case?
12:22:51 <mauke> creat()
12:23:01 <MyCatVerbs> rog: so that they're all three characers.
12:23:06 <MyCatVerbs> *characters, even.
12:23:12 <rog> mauke: the one thing BWK regretted...
12:23:21 <conal> Peaker: offhand, i don't know how to represent bidirectional constraints in FRP.  maybe there's an encoding.  one could combine frp with a constraint solver as in TBAG (http://conal.net/tbag/), in which the constraint solver (deltablue first and then skyblue) manipulated functions of time.
12:23:24 <vixey> MyCatVerbs, you're giving away secrets!
12:23:50 <dsfsddfsfdfsd> thoughtpolice: u work at that site? with the vmware images ?
12:24:08 <rog> i guess i don't care so much about number of characters as i use a proportionally spaced font...
12:24:08 <MyCatVerbs> vixey: only 'cuz you're announcing them.
12:24:47 <whoppix> @where fst
12:24:47 <lambdabot> I know nothing about fst.
12:24:53 <mauke> @index fst
12:24:53 <lambdabot> Data.Tuple, Prelude
12:25:03 <conal> Peaker: FRP came from TBAG + functional reactivity.  i originally intended a multidirectional system but still haven't gotten around to it (13 years later).
12:25:07 <whoppix> thanks, mauke
12:25:13 <int-e> rog: http://hpaste.org/11800#a3
12:25:47 <vixey> hehehe
12:25:54 <vixey> http://conal.net/tbag/imgs/CubeWatcher.gif
12:27:05 <conal> vixey: that one has a video also: http://conal.net/tbag/video/eagle.mpg
12:27:12 * rog goes and looks
12:27:26 <conal> crude graphics (1994)
12:28:13 <Beelsebob> conal: did you get Peaker's question about reactive and two editable values that depend on each other?
12:28:23 <Beelsebob> I answered it as best I could, but I wonder if you have better insight
12:28:32 <conal> one cool aspect of TBAG was that apps could be used in a multi-user, distributed setting with no extra coding effort.
12:28:47 <Beelsebob> oh, wait
12:28:51 <Beelsebob> that's what you were answering >.<
12:28:57 <whoppix> conal, very cute.
12:29:00 <conal> Beelsebob: yeah, thanks.
12:29:04 <conal> whoppix: thx.  :)
12:29:32 <conal> graphics/animation & functional programming are made for each other.
12:29:42 <jeffersonheard> conal, no kidding
12:30:45 <jeffersonheard> conal, is there some tutorial on Reactive available, and getting it working with GTK/OpenGL?
12:30:48 <conal> (functional as in pure/IO-free)
12:31:56 <Peaker> conal: thanks! I'll look at that.  I think Beelsebob's solution of two reactive values defined in terms of each other could work, though, no? What does the constraint solver add?
12:31:58 <conal> jeffersonheard: not yet.  sry.  there's an adapter for GLUT+OpenGL (reactive-glut) and a higher level one (reactive-fieldtrip).
12:32:21 <rog> int-e: looks beautiful. thanks enormously. i'll have to consider it for a while :-)
12:33:13 <jeffersonheard> conal: Yeah -- the reactive-glut will be interesting for my next project.  I've also finished integrating touchlib and a gesture recognition library with Gtk/GLUT.  Will release details and software as soon as Supercomputing is over with
12:33:14 <conal> Peaker: i don't know what Beelsebob's idea might look like.  i'd start with the semantic model as always.
12:33:51 <conal> jeffersonheard: great.  are you doing the graphics part functionally or imperatively?
12:34:39 <jeffersonheard> the touchlib/gesture stuff is imperative right now, but if I understood how Reactive worked better, then I'd be happy to do it functionally
12:34:39 <perlinpinpin> Do you know OCAML ?
12:34:54 <perlinpinpin> yeah i'm a heretic to ask that's here ;)
12:35:12 <conal> jeffersonheard: sounds good.  and what about the graphics (functional or imperative)?
12:35:32 <jeffersonheard> conal: the main constraint right now is that gestures are received over a socket, so that the gesture engine can run over another machine
12:35:57 <jeffersonheard> graphics are all functional until I get to the point of actual rendering.  One imperative rendering function for the mapping stuff I'm doing right now.
12:36:24 <conal> jeffersonheard: neat.
12:36:27 <jeffersonheard> right now, I've faked an R-Tree, but I need a real in-memory functional R-Tree at some point to get this in production order
12:36:41 <jeffersonheard> not the gestures, but the applicaiton I'm working on that uses them
12:36:51 <Badger> argh what.
12:36:52 <Badger> Linking dist/build/happy/happy ...
12:37:06 <Badger> Configuring haskell-src-exts-0.3.9...
12:37:06 <Badger> cabal: happy version >=1.17 is required but it could not be found.
12:37:07 <conal> jeffersonheard: what's an R-Tree?
12:37:27 <jeffersonheard> An n-dimensional search tree for region queries.
12:37:34 <jeffersonheard> They use them in GIS systems
12:37:53 <whoppix> MyCatVerbs, hm, come to think of it, if the main problem with implicit parallelism is that you don't know if you need the result of an expression, shouldn't it be a pretty straightforward thing to implement into a language that uses eager evaluation schemes?
12:37:54 <conal> jeffersonheard: thx.  i'll check it out.
12:38:20 <jeffersonheard> I've faked one with four maps, which serves my purpose, but breaks with certain kinds of more advanced queries
12:38:20 <dsfsddfsfdfsd> NOONE USING OPENVISION?
12:42:05 <mofmog> Scala is fully functional right?
12:42:12 <sw17ch> I got a volunteer to help take care of Scurry (my VPN) on Darwin!
12:42:14 <sw17ch> yay!
12:42:30 <Cale> mofmog: Depends on what you mean by 'fully functional'?
12:43:19 <conal> Peaker: in other words, i'd look at multi-directionality from in terms of the model of functions-of-time.  If it can be understood in those terms, then I'd want to implement it.  If it can't, then any implementation would be an abstraction leak.
12:43:47 <mofmog> Cale: as much as haskell is
12:43:53 <rog> int-e: that foldr merge idiom is quite something. i like.
12:44:10 <Cale> mofmog: It's not purely functional in the sense that Haskell is.
12:44:15 <jeffersonheard> mofmog: if you're asking if scala is pure-functional, I believe the answer is no
12:44:24 <lilac> vixey: why do you redefine (!!)?
12:44:44 <lilac> changing the Int to (Num a) => a?
12:45:11 <mofmog> I attended a talk about some guy researching how to do hardware transactional technology which what seemed to be some hybrid between normal cpus and fpga technology
12:45:34 <mofmog> he talked about making DSLs for it in Scala or something
12:45:46 <jeffersonheard> is there actually a diff between ; and >> inside of do?
12:46:00 <vixey> yes
12:46:01 <mofmog> And i was wondering that if you had ref. transparency, would any of this be necessary
12:47:08 <jeffersonheard> oh wait, vixey, I figured out the difference
12:47:18 <whoppix> MyCatVerbs, never mind my previous statement, it made absolutely no sense - If you use eager evaluation, parallelization is pointless.
12:47:18 <vixey> ok
12:47:37 <whoppix> or rather, not possible in this way.
12:49:14 <dsfsddfsfdfsd> anyone know clojure? does haskell has the possibility to manipulate refs(or pointers)?
12:49:24 <vixey> dfssfsfifsidifs: yes
12:49:44 <Beelsebob> whoppix: why not -- you could evaluate all parameters in parallel, and then call by value
12:50:10 <dsfsddfsfdfsd> vixey: how?
12:50:30 <whoppix> Beelsebob, hm, that would be possible, but then you would need to join threads together all the time, i wonder if you would actually get a big benefit out of that.
12:51:22 <Beelsebob> whoppix: depends how large the computations of the parameters were -- but there's nothing in eager evaluation that blocks parallelisation
12:51:32 <Beelsebob> what blocks it is lack of referential transparency
12:51:40 <Beelsebob> (or doesn't block it in haskell's case)
12:52:08 <Beelsebob> whoppix: of note in fact, erlang, which is specifically designed to do parallelism, is also eager
12:52:39 <whoppix> Beelsebob, sounds interesting, does erlang have some form of implicit parallelization?
12:53:28 <Beelsebob> whoppix: as far as I know, no compilers do implicit parallelisation atm, simply because no one has solved the problem of how to guarentee that work blocks are big enough to make the parallelisation worth while
12:53:57 <whoppix> I see. perhaps in some far future... :)
12:54:14 <Beelsebob> (note, implicit parallelisation isn't something that needs language support -- by definition)
12:54:21 <Beelsebob> it's instead something that needs compiler support
12:55:25 <waern> ivanm: ping
12:55:34 <dolio> , let f s (State { runState }) = runState s in f 5 get
12:55:34 <Snark> uh... No instance for (Monad (Either String)) !?
12:55:40 <lunabot>  luna: Illegal use of punning for field `runState'
12:55:45 <whoppix> yes, but i suppose it works best with functional languages, and perhaps not so well with procedural languages
12:55:58 <whoppix> or am I mistaken
12:56:03 <dolio> Snark: Do you have Control.Monad.Error imported?
12:56:23 <Beelsebob> whoppix: absolutely -- as I said, what breaks it totally is the lack of refferential transparency
12:56:27 <Snark> dolio, it seems not :-/
12:56:40 <Beelsebob> implicit parallelism is very easy to implement in pure functional languages
12:56:56 <Beelsebob> what's hard, is implicit parallelism that's actually more efficient than no parallelism
12:57:12 <Snark> ah, now it fails on linking
12:57:15 <rog> int-e: thanks again. you might be interested to know that was a real world problem that had been dismissed as infeasible to solve by the researcher behind me... (still, it's an engineering dept not comp sci, what do you expect?)
12:58:18 <rog> int-e: PS i am not worthy :-)
12:59:06 <Snark> sigh... -package mtl was needed
12:59:45 <Beelsebob> Snark: sounds a lot like you want to write a .cabal file
13:00:15 <MyCatVerbs> whoppix: actually we do implicit parallelization all the time.
13:00:46 <whoppix> MyCatVerbs, what do you mean?
13:00:49 <MyCatVerbs> whoppix: albeit not in anyone's compiler. Instead, it's done in the CPU. "Instruction-level parallelism", yo. :)
13:01:01 <Beelsebob> hehe, that's true
13:01:31 <whoppix> MyCatVerbs, yeah, ive heard about that.
13:01:43 <MyCatVerbs> whoppix: it's what superscalar CPUs all do.
13:01:52 <Beelsebob> it's what modern x86 CPUs do
13:02:03 <whoppix> MyCatVerbs, so.. what exactly are superscalar CPUs, and do i need one? :P
13:02:07 <jkr_> http://github.com/jkramer/haskell/tree/master/brainfuck.hs \o/
13:02:08 <lambdabot> Title: brainfuck.hs at master from jkramer's haskell — GitHub
13:02:17 <Snark> Beelsebob, uh... I'm a beginner and that sounds like pain
13:02:33 <MyCatVerbs> Beelsebob: er, it's kind of built in to the definition of "superscalar". At least I'm not aware of any superscalar chips that don't make use of implicit ILP.
13:02:55 <Beelsebob> jkr_: nice -- this is my version of it http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CPBrainfuck
13:02:57 <lambdabot> Title: HackageDB: CPBrainfuck-1.0, http://tinyurl.com/5lq6va
13:03:05 <Stinger> http://hpaste.org/11803 Is this roughly sensible for a graph structure (I know the algorithm for building is not particularly clever:P)
13:03:56 <Stinger> seems to blow up in space if I traverse it a lot though, tested through my highly accurate method of watching the processor list in windows
13:03:58 <Beelsebob> Stinger: you *probably* want to have a Data.Map of ID to node, and a Data.Map of ID to ID for edges
13:04:24 <Stinger> do these recursive structures not work terribly well?
13:04:30 <Beelsebob> not for graphs, no
13:04:34 <Beelsebob> for trees, yes
13:04:45 <Beelsebob> your space blow up is probably caused by a lack of sharing
13:04:45 <jkr_> Beelsebob: Looks like yours is also ook-compatible :)
13:04:53 <Beelsebob> jkr_: :D
13:05:07 <Stinger> how do you encourage sharing :P
13:05:43 <Beelsebob> Stinger: well, it's fairly hard to do in that case (possibly impossible, though I couldn't prove it) -- you'd have to somehow tell that you were trying to point at the same node again
13:06:42 <Beelsebob> Stinger: you could always use the Data.Graph module ;)
13:06:43 <Stinger> would forcing evaluation of the system list (cause it searches the list to build the neighbour list) possibly help or am I way off?
13:07:04 <Stinger> you don't learn anything if you dont reinvent the wheel ;)
13:07:26 <Beelsebob> hehe, true
13:07:46 <Beelsebob> the problem with evaluating the system list is that after n jumps you may get back to the first system
13:07:51 <MyCatVerbs> Stinger: but you have to either make it round or understand the fact that your implementation is triangular.
13:07:51 <Beelsebob> but not realise that it's the first system
13:08:00 <Beelsebob> and then recursively generate the whole graph again
13:08:08 <Beelsebob> and so on ad nausium
13:09:18 <jkr_> Is there a function in the standard libs for changing one element in a list?
13:09:22 <Stinger> seq on a list wont evaluate any of the list elements will it
13:09:41 <FunctorSalad_> from roughly what string length on is it worthwhile to use ByteString?
13:10:19 <RayNbow> Stinger: you could foldl1 seq though
13:10:55 <RayNbow> but even that wouldn't necessarily fully evaluate the list
13:11:11 <Stinger> no but it should do top level structure right?
13:11:12 <twanvl> jkr_: given its index? no, it is not often that you need to do that
13:12:34 <Didro> WHY
13:12:48 <RayNbow> Stinger: yes (provided that the "foldl1 seq" thunk gets evaluated)
13:13:01 <FunctorSalad_> (or is ByteString generally superior to String?)
13:13:08 <Stinger> hehe yeah, my brain hurts :(
13:13:27 <Stinger> is there a way of forcing evaluation of things?
13:13:29 <RayNbow> > let x = foldl1 seq [1..] in 0  -- for example, here the list [1..] is not evaluated at all ;)
13:13:30 <lambdabot>   0
13:13:35 <Stinger> in the IO monad perhaps?
13:14:34 <RayNbow> Stinger: I don't know any generic way of forcing evaluation... maybe other #haskellers know of one
13:14:38 <RayNbow> what are you trying to do?
13:15:00 <Stinger> make a recursive graph structure that doesnt blow up in space :)
13:15:22 <vixey> There is a monad thing
13:15:39 <vixey> in Control.Concurrent, which has a typeclass that can normalize
13:15:40 <twanvl> look at Control.Parallel.Strategies.NFData
13:15:49 <vixey> sort of like, weird thing to want to do
13:15:57 <vixey> I mean ocaml is over there -->
13:16:01 <Cale> seq is how you force evaluation
13:16:10 <Cale> But it's not going to help with that
13:16:18 <bos> seq, pseq, !, rnf - take your pick
13:16:19 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
13:16:30 <RayNbow> http://web.comlab.ox.ac.uk/people/Duncan.Coutts/papers/recursive_data_structures_in_haskell.pdf <-- maybe this might be of help, Stinger?
13:16:42 <lambdabot> Title: cache:http://web.comlab.ox.ac.uk/people/Duncan.Coutts/papers/recursive_data_stru ..., http://tinyurl.com/5zoq9h
13:16:44 <Stinger> yeah I read that before I came here
13:16:52 <bos> Stinger: the chapter on parallelism in real world haskell talks about this, too
13:17:10 <Didro> Hello All, Could smbd point me out, why ghc can't derive types in such case:
13:17:10 <Didro> f::a->a
13:17:10 <Didro> f 1.0  =1.0
13:17:22 <Stinger> hmm I will be getting that book as soon as our dollar returns to not crap :(
13:17:24 <Cale> Tying knots is great for some things, but produces things which are very hard to manipulate without ending up with something infinite.
13:17:39 <bos> Didro: 1.0 does not have the type a
13:17:56 <Cale> Didro: If you write f 1.0 = 1.0, that means that f must take a Fractional parameter, and produce a Fractional result.
13:17:56 <bos> Didro: it has the type (Fractional a) => a
13:18:11 <RayNbow> :t 1.0
13:18:11 <Cale> (and they may not even be the same type)
13:18:12 <lambdabot> forall t. (Fractional t) => t
13:18:19 <Cale> :t let f 1.0 = 1.0 in f
13:18:20 <lambdabot> forall t t1. (Fractional t1, Fractional t) => t -> t1
13:18:35 <vixey> nice slides RayNBow
13:18:38 <Didro> thank you all
13:18:58 <vixey> the last one is kind of sad though
13:19:11 <RayNbow> vixey: you should thank dcoutts :p
13:19:17 <vixey> hey GHC should have a -lazy flag
13:19:22 <vixey> then we could be sure about stuf
13:19:28 <vixey> -XLazy
13:19:50 <ziman> what's the difference between non-strict and lazy?
13:20:04 * RayNbow proposes -XPleaseDoNotBlowUpMyPageFile
13:20:32 <vixey> ziman, I think you don't have the sharing guarantee unless it's lazy, e.g. let double x = x + x in double (sqrt 2) might calculate sqrt 2 twice
13:20:58 <Cale> ziman: non-strict semantics refers to termination behaviour and results
13:21:10 <Cale> ziman: lazy evaluation is a mechanism for implementing non-strict semantics
13:21:22 <pao> Hi all :-)
13:21:33 <pao> What does "projection" means?
13:21:53 <Zao> pao: Depends on context.
13:21:54 <vixey> pao, if something casts a shadow, that is the projection of the thing that cast it
13:21:54 <Cale> pao: Depends on context. Usually a function such that p . p = p
13:21:58 <pao> I've seen used alongside "predicate"... which I know....
13:22:09 <IsoPallo_> pao: projezione :)
13:22:18 <Beelsebob> jkr_: hmm, no idea why I'd got my interpret function doing IO -- I just uploaded a nicer version :)
13:22:25 <Cale> pao: Oh, if you have a product type, then there are projections on to each of the components.
13:22:26 <vixey> pao, so (a,b) can cast a shadow along two dimensions, fst and snd project out each one
13:22:36 <IsoPallo_> pao: By the way, ben tornato.
13:22:42 <Cale> pao: for example (\(x,y) -> x) and (\(x,y) -> y) for the pair type.
13:22:45 <mmorrow> does anyone know the rationale for dropping opengl from the extralibs in 6.10?
13:22:50 <pao> IsoPallo_:  :-)
13:23:27 <Beelsebob> mmorrow: it was unneccessary to most people, and took up a lot of space probably -- it's still easily accessable from hackage
13:23:29 <mmorrow> i'm looking for a note about it in various places but haven't found mention of it yet..
13:23:29 <pao> Cale: give me some time to read ;-)
13:23:38 <Beelsebob> remember, everything's moving towards the haskell platform mmorrow
13:23:48 <mmorrow> Beelsebob: ah, i see
13:23:55 <olsner> yeah, probably since it's easily installable through cabal/hackage
13:24:32 <olsner> but does ghc include cabal-install yet?
13:24:37 <pao> Cale:  "The IOError type is abstract; the standard only
13:24:38 <pao> specifies a selection of predicates and projections over it"
13:24:46 <mmorrow> olsner: i'm not sure
13:25:10 <pao> Cale: ... I think in that context projections means :: IOError -> IOError, right?
13:25:52 <sam___> Is  here any free var: \x y. y y (x \x. x y) x?
13:25:55 * RayNbow tries to cabal install opengl...
13:26:10 <RayNbow> checking build system type... i686-pc-cygwin <-- wait... why cygwin? :p
13:26:16 <dsfsddfsfdfsd> programming == mathematics
13:26:26 <dsfsddfsfdfsd> haskell == mathematics ?
13:26:27 <sam___> I am not sure is the x a free variable at the end of the statement
13:26:48 <pao> vixey: Zao: thanks for your answers :-)
13:26:48 <earthy> dsfsddfsfdfsd: almost
13:26:52 <Beelsebob> dsfsddfsfdfsd: Haskell is as close to maths as programming gets I guess
13:27:01 <earthy> um. assembly is maths
13:27:22 <Beelsebob> earthy: yeh, "but not as we know it, jim"
13:27:28 <Beelsebob> i.e. it's not traditional maths
13:27:40 <mmorrow> RayNbow: let me know how the install goes :)
13:27:42 <earthy> actually, as we very much know it. look at turing's seminal paper on computable numbers
13:27:51 <dsfsddfsfdfsd> earthy: do you know a good assembly tutorial? because what i have found have been incredibly bad at explaing the very simple stuff. like awalkthorugh of hello world would be great
13:27:54 <earthy> that was pure math. ;)
13:28:12 <Beelsebob> earthy: sure, turing talked about it, but did people frome 56 BC?
13:28:24 <RayNbow> mmorrow: well, I still have the pre-release version of GHC 6.10... it now says it's done installing...
13:28:30 <RayNbow> do you have any OpenGL test code? :p
13:28:31 <earthy> nope. but did people from 56 bc talk about categories?
13:28:54 <Beelsebob> earthy: fair point -- but Haskell is a lot closer to the maths of 56 BC than ASM is
13:28:59 <mmorrow> RayNbow: cool. no not personally, but i can find some i think..
13:29:06 <vixey> programming isn't mathematics
13:29:21 <vixey> of course you can use mathematics to know what program to write
13:29:24 <Cale> pao: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Error.html#3 would be the projections that it's talking about, I think
13:29:26 <lambdabot> Title: System.IO.Error, http://tinyurl.com/5suzuk
13:29:27 <earthy> what's more, much of the symbolic math that we are used to these days (which haskell *is* close to) didn't exist until what was it, the 1600's
13:29:37 <vixey> dfsfsfdfdfsss: but they are very distinct
13:29:42 <sam___> vixey: Do you know is here any free variable: \x y. y y (x \x. x y) x?
13:29:54 <vixey> sam__: Do you have a definition of free variable though?
13:30:14 <Beelsebob> sam___: a free variable is one not captured by any binding
13:30:21 <Beelsebob> both x and y are bound in the very outer lambda
13:30:26 <Beelsebob> so no... no free variables there
13:30:32 <pao> Cale: thanks
13:30:33 <Cale> vixey: I don't know, if you look at it the right way, Haskell programmers are logicians who are finding interesting proofs of theorems in an inconsistent intuitionist logic.
13:30:38 <vixey> Beelsebob: (looking for a formal definition)
13:30:42 <sam___> Beelsebob: Thanks!
13:30:55 <RayNbow> mmorrow: I'm missing GLUT bindings... going to install those first :p
13:31:02 <sam___> vixey: I am not sure do I know the formal def
13:31:32 <Cale> Ordinary mathematics uses classical logic, hopes to be consistent, and has a much greater focus on the theorems than the proofs.
13:31:37 <vixey> sam__: it's defined by recursion over the term, you haven't it? FreeVars(app(m,n)) = FreeVars(m) `union` FreeVars(n) type stuff?
13:31:49 <mmorrow> RayNbow: here's some code that i saved from someone's hpaste a few months ago: http://hpaste.org/11805
13:32:10 <mmorrow> it worked for me at the time, so i think should work now
13:32:11 <sam___> vixey: That is interesting.
13:32:20 <Cale> In Haskell on the other hand, we know that every theorem (type) has at least one proof (program), specifically, undefined, and so we focus a lot more on the content of the proofs.
13:32:27 <Beelsebob> vixey: presumably you wanted a set of variables bound in the current scope somewhere in that
13:32:33 <vixey> Cale, it seems like people who like programming are get proof theory much more naturally
13:32:40 <sam___> If there is no free var is it possible to do a beta reduction with the outer most x here \x y. y y (x \x. x y) x?
13:32:42 * earthy nods
13:32:53 <vixey> i.e. there is no way in hell I'd understand any of that stuff if I hadn't had programming experience :))
13:33:04 <RayNbow> mmorrow: did it work in ghci?
13:33:06 <mmorrow> RayNbow: the filename i put it in is bwstatic.hs, so that may have been the title
13:33:09 <RayNbow> or did you compile it first? :p
13:33:22 <RayNbow> running from GHCi results in a crash :p
13:33:24 <Beelsebob> sam___: no -- there's no application to beta-reduce
13:33:26 <Cale> I view computer science (which is an awful name for it), as a branch of mathematics.
13:33:26 <mmorrow> RayNbow: um, i compiled it but it may work in ghci. i don't think i tried
13:33:30 <sam___> Could somebody give me two alpha equivalent forms with this: \x y. y y (x \x. x y) x?
13:33:36 <sam___> Beelsebob: thanks!
13:33:39 <earthy> and people who like programming are easier persuaded to understand the reasons behind constructivist (or intuitionistic) logic
13:33:46 <mmorrow> RayNbow: what if you do first:
13:33:50 <mmorrow> :set -fobject-code
13:33:51 <mmorrow> ?
13:34:09 <RayNbow> same crash
13:34:14 <RayNbow> and I can't compile the code
13:34:27 <mmorrow> here's another one http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=76
13:34:36 * RayNbow saw several screens full of linking errors
13:34:47 <mmorrow> gah
13:34:48 <pao> Cale: "In linear algebra, a linear transformation that remains unchanged if applied twice (p(u) = p(p(u))), in other words, an idempotent operator" that is the meaning of projection in that context... right?
13:35:01 <Cale> pao: yes
13:35:09 <vixey> Cale, most of the computing you see is horribly imprecise and vauge, you know design patterns and object oriented programming -- nonsense, it feels like an insult to mathematics to call them the same thing
13:35:15 <mmorrow> RayNbow: oh, maybe you need the opengl C libs?
13:35:26 <mmorrow> (or newer ones?)
13:35:26 <sam___> Is there any alpha equivalent forms for this: \x y. y y (x \x. x y) x ?
13:35:36 <vixey> sam__: loads
13:35:50 <vixey> sam__: Do you not have any formal definition of alpha equivalence? :p
13:35:59 <RayNbow> mmorrow: I have no idea
13:36:00 <sam___> vixey: Could you give an example
13:36:01 <vininim> hey
13:36:07 <Cale> vixey: Well, CS is relatively new. We can forgive it. :)
13:36:10 <RayNbow> main = do {(progname, _) <- getArgsAndInitialize ;  createWindow "Hello World" ;  mainLoop }  -- even a simple example like this doesn't work :p
13:36:37 <vininim> I have x :: IO [(Integer, Tabuleiro)], how am I supposed to do something like x >>= take 4
13:36:39 <Cale> pao: You can think of such a linear operator as picking out some of the information about a given vector.
13:36:47 <mmorrow> RayNbow: ooh, nasty. if that gives linker errors, it's probably a problem with the C libs.
13:37:05 <Beelsebob> sam___: one such alpha equivalent form is (\z . \x y. y y (x \x. x y) x) _|_
13:37:06 <mmorrow> i've never done opengl on windows or in haskell, so i'm probably of no use
13:37:09 <Botje> vininim: x >>= return . take 4
13:37:20 <pao> Cale: a projection ... that is :-)
13:37:25 <Cale> pao: Yes.
13:37:27 <sam___> Beelsebob: thanks!
13:37:30 <vixey> Beelsebob: that's beta equivalent
13:37:37 <vixey> (not alpha equiv.)
13:37:39 <Beelsebob> am I getting mixed up
13:37:39 <vininim> Botje: thanks! (And I just found it out, it seems that speeling it in irc helps by itself =P)
13:37:43 <Beelsebob> oh, duh, so it is
13:37:45 <Beelsebob> >.<
13:37:46 <earthy> alpha equivalency is 'up to renaming'
13:37:49 <Botje> yeah
13:37:50 <sam___> vixey: are you sure?
13:37:50 <rwbarton_> vininim: or  fmap (take 4) x,  or many other options
13:37:57 <Beelsebob> sam___: no, he's right
13:38:03 <vixey> sam__: Well since you haven't any formal definitions.. it's your word against mine
13:38:04 <RayNbow> mmorrow: I think OpenGL used to work in GHC 6.8.x under Windows...
13:38:23 <pao> Cale: the semantics of ioeSetHandle seems intuitively different from a "projection" ... they set info, the don't extract info
13:38:23 <Beelsebob> sam___: an alpha equiv of your expr might look like \z y. y y (z \x. x y) z
13:38:29 <vixey> sam__: They are all actualy very simple, recursion over the syntax
13:38:43 <sam___> vixey: Is this alpha eq \x y. y y (x \b. b y) x?
13:38:54 <sam___> Beelsebob: Thanks!
13:39:00 <Beelsebob> sam___: yes, your one is alpha eq too
13:39:05 <vixey> sam__: We could answer that yes or no using a definition of alpha equiv..,
13:39:20 <sam___> true vixey
13:39:26 <Beelsebob> alpha equivalence says "you can rename a variable in a lambda bindings, and all the variables it binds, and it'll still be the same term"
13:39:34 <vixey> sam__: for example  AlphaEquiv(app(m,n),app(m',n')) = AlphaEquiv(m,m') /\ AlphaEquiv(n,n')
13:39:38 <pao> Cale: for sure a projection return the same type as the input... and that is the case for ioeSetHandle (e.g.)
13:39:52 <vixey> sam__: but you need a rule of variables, application and lambda
13:39:54 <Cale> pao: I was referring to the "get" operations.
13:40:54 <whoppix> "real world haskell" is a pretty nice book.
13:40:57 <sam___> vixey: Have you some reference material?
13:41:16 <Cale> pao: For any projection operator (let's say for simplicity on a finite dimensional vector space), you can decompose the whole space into the direct sum of its range and its null space, which means that every vector x can be written as u + v where P(u) = u, and P(v) = 0
13:41:32 <vixey> sam__, yeah, Lectures on the Curry-Howard Isomorphism covers all this formally and goes on to lots of other cool stuff
13:41:35 <pao> Cale: hmmm ... in that case the meaning should be "The product of some objects has a canonical projection morphism to each factor."
13:41:51 <pao> Cale: in that IOError is a product
13:41:59 <Cale> pao: This is perhaps the intuition behind the more abstract definition of a projection on a product.
13:42:14 <pao> Cale: ok, that's clear
13:42:47 <sam___> vixey: :) Is on the web?
13:43:15 <vixey> sam___: I've only seen it in a library
13:43:20 <jeffersonheard> grr.  everything works now, except genObjectNames always returns a list of zeroes instead of texture objects
13:43:32 <sam___> excellent
13:43:33 <vininim> mmm any tips on constructing infinite IO [List] ?
13:43:37 <sam___> material
13:43:54 <vixey> :t return [1..] :: IO [Integer]
13:43:55 <lambdabot> IO [Integer]
13:43:55 <pao> Cale: über helpful as usual :-)
13:44:40 <vininim> vixey: :D
13:44:56 <pao> whoppix: ... a little bit too verbose... but a good book
13:45:10 <whoppix> pao, thats ok, im pretty new to functional programming.
13:45:23 <pao> whoppix: me too ;-)
13:45:26 <FunctorSalad> afaik 'projection' has two slightly different meanings... the projections to some factor -or- a map f : a -> a such that f . f = f
13:45:37 * rwbarton_ agrees with FunctorSalad 
13:45:47 <FunctorSalad> the second can be turned into the first by restricting the codomain to the range
13:45:59 <vininim> :t return . head
13:46:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m a
13:46:37 <pao> FunctorSalad: I didn't get the second :-)
13:47:02 <FunctorSalad> pao: the notation or the motivation?
13:47:04 <vininim> :t flip (>>=) head
13:47:05 <lambdabot> forall (m :: * -> *) b. (Monad m) => m [m b] -> m b
13:47:36 <vixey> :t join
13:47:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:48:07 <pao> I completely undestood your first statement (map f : a -> a such that f . f = f)
13:48:21 <pao> FunctorSalad: not the second one (codomain)
13:48:38 <pao> FunctorSalad: I think I miss some basic terminology here (codomain)
13:49:35 <pao> FunctorSalad: let me see if I get it....
13:49:51 <Cale> pao: If A and B are sets, then a function f: A -> B is a triple (A,B,G) where G is a set of pairs (a,b) such that for each a in A, there is exactly one b in B for which (a,b) is in G. In this case, A is called the domain of f and B is called the codomain.
13:50:01 <FunctorSalad> pao: then I misunderstood... I mean that if you have some set A and f : A -> A such that f.f = f, then you can define g : A -> image f that does the same thing as f
13:50:12 <Cale> The range of f is the set of b in B for which there is some a in A for which (a,b) is in G.
13:50:32 <Cale> When (a,b) is in G, we write f(a) = b
13:51:33 <FunctorSalad> pao: it's a bit of a formality, nothing deep ;)
13:51:44 <pao> Cale: got it
13:52:17 <pao> FunctorSalad: ... I'm really missing some more formal background :-)
13:52:31 <Cale> If for every b in B, there is at least one a in A for which f(a) = b, we call f surjective (or onto). If there is at most one a in A for which f(a) = b, we call f injective (or one-to-one).
13:52:37 <bos> yay early comments on the book: http://www.realworldhaskell.org/blog/2008/11/06/some-early-reviews/
13:52:43 <lambdabot> Title: Real World Haskell » Blog Archive » Some early reviews, http://tinyurl.com/5vq75p
13:53:17 <pao> Cale: are these definitions in the realm of Category Theory?
13:53:31 <Cale> pao: I'd think of them as early set theory definitions myself.
13:53:41 <Deewiant> bos: nice!
13:53:46 <MyCatVerbs> pao: no, those are basic set theory. :)
13:53:48 <FunctorSalad> category theory reformulates them in a point-free way
13:53:58 <pao> FunctorSalad: :-)
13:54:07 <MyCatVerbs> pao: I can tell because they don't make my head hurt very much. ;P
13:54:19 <vixey> the generalized element idea from category theory is very elegant
13:54:37 <vixey> that's what made me realize you can do f $ x as (f . const x) ()
13:54:37 <pao> MyCatVerbs: ... with respect to Cathegory Theory... I guess ;-)
13:55:33 <FunctorSalad> vixey: yeah, that would solve the eternal question whether to write "f $ g x" or "f.g $ x" ;)
13:55:45 <Cale> We could just write f g x
13:55:47 <Cale> :)
13:55:49 <vixey> (f . g . const x) ()
13:55:50 <FunctorSalad> indeed
13:56:02 <Deewiant> (f . g $ const x ())
13:56:04 <Deewiant> ;-)
13:56:33 <vixey> (.) has such good properties, may as well use it everywhere
13:56:54 <MyCatVerbs> pao: "my brain hurts" -> "ah right, must be cat theory, or group theory, or abstract algebra, or numerical analysis, or multivariable calculus, or..." :)
13:56:59 <vixey> hmm
13:57:09 <pao> MyCatVerbs: ;-)
13:57:14 <vixey> :t do ?f;?g
13:57:15 <lambdabot> forall t (t1 :: * -> *) t2. (?g::t1 t2, ?f::t1 t, Monad t1) => t1 t2
13:57:17 <vixey> :t do ?f;?g;?h
13:57:18 <lambdabot> forall t (t1 :: * -> *) t2 t3. (?h::t1 t2, ?g::t1 t3, ?f::t1 t, Monad t1) => t1 t2
13:57:32 <olsner> Cale: heh, still working on that Caleskell dialect I see
13:57:47 <vixey> you can't really hijack do notation to write  g . f  as  do f;g  I gues
13:58:01 <olsner> btw, why are my unsafeRead IOUArray access being bounds-checked?
13:58:24 <MyCatVerbs> olsner: how can you tell? Are you supplying wrong indices on purpose? :L)
13:58:27 <MyCatVerbs> *:)
13:58:34 <olsner> MyCatVerbs: ghc-core :)
14:00:18 <MyCatVerbs> olsner: git. :)
14:00:59 <MyCatVerbs> olsner: well, you *could* throw all the IOUArrays away and just use Ptrs to the C types instead. :)
14:02:08 <olsner> argh, C code is actually better written in C
14:02:22 <MyCatVerbs> olsner: go figure. :/
14:02:23 <vixey> olsner, yeah, for pretty much any language
14:02:35 <vixey> i.e. haskell in java doesn't really work well
14:03:51 <ski> (Cale : in Charity it's `f g x', iirc)
14:04:31 * vininim feels nasty with unsafeInterleaveIO
14:04:33 <vixey> does anyone know why charity is implemented in C?
14:04:46 <vixey> this seemed quite odd to me
14:05:25 <ski> probably because they felt they needed a low-level implementation, with control over resources
14:05:34 <jsn> Cale: you know, i ultimately, agree with you that it would be desirable to have a kind of quasi-quotation that respected indentation
14:05:43 <MyCatVerbs> vixey: Haskell in Lisp works just fine, except for the fact that you have to be more careful.
14:06:06 <mathijs> While reading tutorials/books about haskell, I noticed (almost) all 'core functionality' like Prelude functions and datatypes like lists, bools and so on can be explained / rewritten in haskell. Now, ruby has rubinius, python has pypy, both are implementations of the language (interpreter/compiler) in itself. Does haskell have such an implementation?
14:06:10 <Heooo> If every variable are bound, are there many different types of cases where you can eta-reduce but not beta reduce?
14:06:20 <jeffersonheard> anyone know why this always returns invalid texture objects?  http://hpaste.org/11807
14:06:23 <vixey> omg. ...
14:06:34 <vixey> Heooo, I guess you're in the same class as sam__ ? and that other guy?
14:06:38 <jeffersonheard> Using Graphics.UI.Gtk.OpenGL
14:06:44 <vixey> and like.. your teacher has NFI what he is talking about? :)
14:06:55 <ski> jsn : i don't see what quasi-quotation has to do with indentation ?
14:07:23 <vixey> mathjis, GHC
14:07:41 <mathijs> vixey: is ghc itself pure haskell???
14:07:53 <vixey> mathjis, nah it uses IO monad and so on
14:08:03 <ski> (`IO' is pure :)
14:08:13 <jsn> ski: the terminator could just be an outdent
14:08:27 <mathijs> ok let me rephrase that... is it exclusively written in haskell? :)
14:08:28 <jsn> mathijs: there is some C in it
14:08:36 <jsn> mathijs: like in the RTS
14:08:39 <ski> jsn : ah .. nice .. are you thinking for TH or what ?
14:08:42 <MyCatVerbs> mathijs: the compiler is written almost entirely in Haskell. Much of the runtime is written in C, with a little bit in a scary thing called C--. :)
14:08:49 <jsn> ski: no, just for QQ
14:08:57 <mathijs> C-- ? :)
14:09:01 <jsn> like, for here documents, or embedding sed or something
14:09:35 <vininim> mmmmm how unsafe is unsafeInterleaveIO wrt to Data.HashTable?
14:09:38 <MyCatVerbs> mathijs: it's a language vaguely like C, but with a lot of things made explicit that C handles explicitly for you.
14:09:41 <mathijs> but that's impressive, and the c parts are just for bootstrapping purposes I guess?
14:09:53 <jsn> mathijs: well, not just
14:10:02 <ski> jsn : so you want a quasi-quotation for expression string interpolation ?
14:10:12 <jsn> ski: hmmm?
14:10:13 <MyCatVerbs> mathijs: no, the C parts are (mostly) for the virtual machine that Haskell programs are executed in.
14:10:18 <vixey> you could replace the whole RTS with a .hs file that prints out that C code
14:10:25 <vixey> then it would be 100% haskell
14:10:28 <MyCatVerbs> mathijs: at one point, the usual route for compilation was to output C code to gcc, and have that emit machine code, but that backend's being replaced now.
14:10:41 <jsn> ski: please say in different language
14:10:41 <RayNbow> #google C minus minus
14:10:46 <RayNbow> @google C minus minus
14:10:47 <ski> jsn : you mentioned QC .. how/where would you use quasi-quotation there ?
14:10:58 * RayNbow pokes lambdabot
14:10:59 <mathijs> MyCatVerbs: ok, so the goal is to be fully self-contained?
14:11:00 <ddarius> http://cminusminus.org
14:11:00 <jsn> QC?
14:11:03 <lambdabot> Plugin `search' failed with: thread killed
14:11:07 <jsn> QQ is quasi-quotation
14:11:19 <MyCatVerbs> mathijs: the best bit is that, because gcc wasn't able (by itself) to make certain optimizations that Haskell kinda really really needs, there's an extra stage in there - a Perl script, nicknamed "the mangler", which ran over the assembly code that gcc outputs. :)
14:11:27 <ski> jsn : what type would the quasi-quotation expression (or is it declaration ?) have ? .. what type should the unquoted expressions inside it have ?
14:11:35 <jsn> ski: ah
14:11:48 <mathijs> MyCatVerbs: sounds kind of messy?
14:11:48 <jsn> it depends on the parser
14:11:48 <pao> suggested reading: An Extensible Dynamically-Typed Hierarchy of Exceptions - SM
14:11:49 <ddarius> mathijs: No, the goal is performance.
14:11:52 <Heooo> vixey: The question seems just too simple. I cannot see where the question is aiming at. Of course, you cannot beta-reduce expressions like (\x . ex) as there is no free variable. Just too simple question to ask :] It was supposed to be hard but perhaps they are fooling us lolz
14:11:54 <ddarius> (and simplicity)
14:11:54 <ski> jsn : .. oh ! i was thinking `QC' meant `QuickCheck' ! :)
14:12:17 <MyCatVerbs> mathijs: yes, it was. Hence it's getting replaced with a backend written entirely in Haskell.
14:12:23 <mathijs> ddarius: well of course, but in the end haskell might be a better compiler than gcc
14:12:29 <vixey> pao, dynamically typed :/
14:12:31 <MyCatVerbs> mathijs: which has the benefit of being much, much faster than that old mess.
14:12:56 <vixey> pao, is this more interesting than the stuff ocaml just got recently?
14:13:12 <pao> vixey: can't tell you :-)
14:13:19 <MyCatVerbs> mathijs: the native backend has existed for a while now, but isn't really very good at optimization. Or rather, wasn't. It's being improved lots now. :)
14:13:21 <mathijs> just like rubinius is already able to run some ruby code faster than ruby written in c. just small bits for now, but in the end it might end up faster.
14:13:34 <ski> mathijs : it's not called the "Evil Mangler" for nothing !
14:13:55 <vixey> It's great, it uses REGEX to perform TCO on assembly code
14:14:08 <ddarius> mathijs: I don't understand why you said "but" in your first response to me.
14:14:22 <vixey> who needs higher order unification when you can use regex ??
14:15:01 <ddarius> Who needs Haskell when you can use Perl !!
14:15:17 <quicksilver> who needs perl when you can use TeX !!
14:15:27 <vixey> well I was referring to lambda prolog
14:15:36 <ystael> who needs TeX when you can write raw terms of the untyped lambda calculus ??
14:15:45 <ski> L-lambda unification ftw !
14:15:55 <SamB> ystael: wait, I thought we were going in order of increasing horror
14:16:05 <mathijs> ddarius: I meant that if the goal is performance, c isn't the only way to reach the goal, the 'but' was just to point out that haskell itself might outperform c some day for compilation stuff
14:16:23 <ystael> SamB: we are.  that's why I said _untyped_. :D
14:16:31 <MyCatVerbs> mathijs: outperform in what sense?
14:16:37 <SamB> ystael: that still doesn't sound more horrible
14:16:57 <ski> ystael : please some time try using the SKI-combinators (or better, one of the `X' variants)
14:17:10 <ddarius> mathijs: In actually performing the compilation, then it already does (insofar as it's much faster than the old way.)  The performance of the output was what I was referring to.
14:17:11 <Heooo> vixey: are there different flavours in "higher order unification" similarly as in regex? Regex is just too broad concepts with all its flavours.
14:17:35 <MyCatVerbs> mathijs: there's already a Haskell backend for the Glasgow Haskell Compiler that runs quicker than the C+Perl+oh gods mess.
14:17:37 <vixey> Heooo, I've seen two equivalent presentations of it but neither of them made any sense
14:18:17 <MyCatVerbs> mathijs: as for producing better code, well, it's going that way. But that's not so much a property of the language that the backends are written in so much as a property of the backends themselves.
14:18:17 <mathijs> MyCatVerbs: like you said, the generated assembly that gcc creates isn't as optimized as we would like. I guess writing optimization routines in C might just become too complicated at a certain stage and writing the compiler in a more high-level language (like haskell) might yield better results
14:18:17 <vixey> ddarius, ohh.. I found some new syntax for linear logic -- much more sensible than girards one
14:18:18 <ski> Heooo : well, there's L-lambda
14:18:29 <ddarius> Heooo: There are various restricted versions of HOU, but HOU refers to a specific thing.
14:18:57 <MyCatVerbs> mathijs: that isn't really the blocking factor. gcc had for a long time a really, really terrible design.
14:19:08 <Heooo> ski: ddarius very interesting :P Perhaps, I will change to them if they are more mathematical :D
14:19:09 <ddarius> mathijs: The issue is C compilers are written to compile C.
14:19:25 <ski> Heooo : change to them from *what* ?
14:19:29 <ddarius> Heooo: Higher order unification is undecidable.
14:19:35 <ddarius> (hence restricted subsets)
14:20:07 <ski> vixey : where ?
14:20:50 <vixey> in a book
14:20:52 <vixey> iummm
14:20:57 <mathijs> well I'm impressed to hear that GHC is mostly haskell and aiming for even more.
14:21:02 <vixey> something like Lectures on Linear Logic, I think
14:21:11 <MyCatVerbs> mathijs: there already exist C-family compilers which produces better microcode than gcc. LLVM is written in either C++ or C (can't remember which), and I believe icc is written in one of the C family.
14:21:21 <vixey> very good book actually
14:21:22 <ski> vixey : Troelstra ?
14:21:23 <Heooo> ski: good question. Perhaps, I should have written "to enrich my text processing skills" Regex is ok but I like to learn more :]
14:21:28 <MyCatVerbs> s/produces/produce/, sorry.
14:21:36 <ddarius> vixey: What does the notation look like?
14:21:52 <Heooo> ddarius: What do you mean by "undecidable"?
14:21:59 <vixey> yes I think t hat is the one ski,
14:22:20 <vixey> ddarius, I can't remember it all but it emphases all the duals much better than girards notation
14:22:40 <MyCatVerbs> Heooo: "undecidable" means that trying to solve the problem will sometimes cause you to go into an infinite loop.
14:22:55 <vixey> since everything has a dual
14:22:58 <vixey> (in linear)
14:23:11 <mmorrow> mathijs: -fasm enables the asm codegen which is written in haskell
14:23:25 <MyCatVerbs> Heooo: you can't tell for any given input whether it will or won't without risking going into an infinite loop, either.
14:23:26 <ski> Heooo : higher-order unification is more for processing structured data (trees) than for processing strings .. but possibly often you can change the strings you work on into trees and then use HOU on them
14:23:47 <ski> (or restricted subsets of HOU ..)
14:23:55 <mathijs> MyCatVerbs: I would think that functional languages are very suitable for writing compilers since in the end it's just transforming data. So maybe a c(--|++) compiler written in haskell might even produce better code than c compilers written just to compile c
14:24:04 <vixey> ddarius, I might have found it ..
14:24:14 <ski> vixey : ty, our library has that one, i've browsed it a little
14:24:40 <MyCatVerbs> mathijs: ever tried it? IMO, a lot of the graph manipulation you end up doing is easier in mutable-state languages.
14:24:55 <vixey> ski, It was fun reading the cut elimination proof -- I noticed that cut elimination can be beta reduction.. :)
14:24:58 <ddarius> mmorrow: -fasm is the default for most architectures since 6.8 or 6.6.
14:25:12 <vixey> ski, which is how, I think curry-howard was discovered
14:25:12 <MyCatVerbs> ddarius: it was 6.8.
14:25:12 <mmorrow> ddarius: indeed
14:25:21 <vixey> (except not wrt. linear logic of course)
14:25:37 <Heooo> MyCatVerbs: You are referring to "Halting Problem"?! There was an excellent podcast in "In our time" about Halting problem + Gdel. Highly recommended!
14:25:43 <ski> (vixey : mhm, didn't know that)
14:25:53 <mathijs> MyCatVerbs: maybe easier, but that doesn't have to yield better results
14:25:53 <velco> mathijs: whatever transformations a Haskell written compiler can perform, I doubt identical transformations can;t be done with C/C++/Java
14:25:56 <velco> etc
14:26:13 <mmorrow> they can be done in brainfuck as well
14:26:17 <MyCatVerbs> Heooo: the Halting Problem is undecidable, yes.
14:26:18 <vixey> velco, sometimes it is just not practical since these languages are so horrendous to use
14:26:24 <ski> (hm .. Curry-Howard-Lambek .. istr recall someone else also having been lumped in with Curry-Howard .. who ?)
14:26:33 <ski> (and for what ?)
14:26:41 <ddarius> Lawvere
14:26:41 <vixey> ski, oh it may also be called BHK
14:26:45 <Peaker> conal: Sorry, was afk.  I think they sure can be seen as functions of time, though the model might not be two values expressed in terms of each other, but probably two values that are both expressed in terms of the events arrived on either of the UI inputs
14:26:49 <ski> danke shoen
14:26:54 <vixey> brouwer heyting kolomorgov (I think?)
14:26:55 <ddarius> BHK is related.
14:26:57 <mathijs> velco: true, but when reasoning about which transformation, and comparing multiple choices and stuff it might do better, but that's just a wild guess
14:27:08 <ddarius> That's the BHK interpretation of intuitionistic logic.
14:28:08 <mathijs> anyway... One thing that isn't clear to me... this RTS... it's like a vm right? can I compare it to python (which uses bytecode) and ruby 1.9? and java and .net?
14:28:19 <Heooo> ski: Thx for your great clarification about HOU! It sounds very interesting. How is Haskell and HOU related?
14:28:26 <ddarius> mathijs: The RTS is like libc
14:28:36 <MyCatVerbs> mathijs: the RTS is a VM. No, not really.
14:28:51 <mathijs> ah, so it's just a library, not some run-time system?
14:28:55 <ski> (so if Lambek is for Categorial Logic and CCCs, what aspect would Lawvere represent ? more or less the same ?)
14:29:04 <MyCatVerbs> mathijs: it *is* a run-time system, that's in the name. :)
14:29:11 <ddarius> ski: Yes.  CCCs are more Lawvere I believe.
14:29:16 <Heooo> MyCatVerbs: Are there other problems that are undecidedly and non-reducible to Halting problem?
14:29:19 <ski> ic
14:29:36 <FunctorSalad> hmm... cabal installing something high in the tech tree, while on a pristine install, fills up all my memory and dies :(
14:29:40 <MyCatVerbs> Heooo: I honestly don't know. If you find out, please tell me?
14:29:46 <FunctorSalad> upon resolving dependencies
14:29:51 <conal> Peaker: might work.  hopefully could be packaged up in a reusable way.
14:29:52 <mathijs> MyCatVerbs: ok, so what's the difference between libc and the RTS ?
14:30:08 <FunctorSalad> Heooo: every non-trivial problem about the function computer by a program ;)
14:30:15 <FunctorSalad> (that's Rice's theorem)
14:30:20 <velco> isn't RTS more like libgcc ?
14:30:20 <FunctorSalad> *computer
14:30:21 <FunctorSalad> *computed
14:31:03 <FunctorSalad> ski: Lawvere also did synthetic differential geometry among other stuff
14:31:07 <mmorrow> mathijs: the (critical parts of) ghc rts is written in C--, which ghc then parses, merges with the rest of the program (ghc translates haskell to C-- as the last step as well), then generates asm from that C--
14:31:25 <mathijs> well in any case... if it's just a library of functions that can be called, and not interpreter/vm-like, why isn't it just some .so or .dll thingy?
14:31:41 <ski> FunctorSalad : he did ? .. i've read Kock a bit, and str there were others ..
14:31:41 <mmorrow> ghc :: .hs -> HsSyn -> CoreSyn -> StgSyn -> Cmm -> .s
14:31:42 <MyCatVerbs> mathijs: argh, this is getting tangled. The RTS handles garbage collection, non-blocking IO, threading, etc,  and fires off "main".
14:31:47 <SamB> mathijs: well GHC doesn't really support .so does it ?
14:31:58 <Peaker> conal: Do you think it would be possible to implement Phooey such that the UI type is generic enough that it can be ran not only via  runInWx :: UI a -> IO a, but also runInCLI, runInSDL/etc, or is there something about building UI values that must put them in a specific implementation?
14:32:04 <Heooo> MyCatVerbs: I think these problems can be reduced to Russel paradox. Gdel's incompleteness theorem used just decoding to make this linguistic paradox in mathematics. As far as I know, halting problems and such are variants of Gdel's theorems.
14:32:11 <MyCatVerbs> mathijs: it's more like a VM than a library, but it's not having to do the work of an interpreter.
14:32:30 <Heooo> MyCatVerbs: the word "reduce" may be now a bit misleading
14:32:31 <RayNbow> @faq Can Haskell solve HALT_TM in its kind system?
14:32:32 <lambdabot> The answer is: Yes! Haskell can do that.
14:32:50 <FunctorSalad> ski: istr that one of his goals was to find a simpler (categorical) foundation for physics
14:32:53 <MyCatVerbs> @faq Can Haskell kill puppies in linear time?
14:32:53 <lambdabot> The answer is: Yes! Haskell can do that.
14:32:54 <FunctorSalad> but not sure
14:32:56 <SamB> mathijs: also windows kinda requires the entry point to be in the .exe doesn't it ?
14:33:08 <ski> FunctorSalad : istr reading somesuch, yea
14:33:09 <mathijs> ok, so if I compile a program using ghc, it basically gives me RTS with my application 'plugged in'?
14:33:09 <Heooo> MyCatVerbs: I mean that it has its roots but I have to investigate the issue to know more .]
14:33:24 <Badger> @faq Can Haskell Save My Marriage?
14:33:24 <lambdabot> The answer is: Yes! Haskell can do that.
14:33:51 <Zao> Righter :)
14:33:52 <FunctorSalad> @faq even in the type system?
14:33:52 <lambdabot> The answer is: Yes! Haskell can do that.
14:33:57 <Zao> Err, wrong chan.
14:34:21 <whoppix> I'm off to catch some sleep, thanks to everyone who helped me. :)
14:34:31 <conal> Peaker: Probably so.  And if not Phooey, then TV, which is higher level.
14:34:32 <mathijs> so in a way RTS is 'the executable' and the application is just a library that gets loaded and from which 'main' gets invoked?
14:34:34 <mmorrow> mathijs: more or less
14:34:55 <RayNbow> @faq Can Haskell make us just as awesome as SPJ?
14:34:55 <lambdabot> The answer is: Yes! Haskell can do that.
14:35:20 <Heooo> MyCatVerbs: I referred to Gdel's numbers by decoding
14:35:25 <mmorrow> mathijs: here's the wrapper than every haskell .hs with a main is started from darcs.haskell.org/ghc/rts/Main.c
14:35:30 <Peaker> conal: I tried implementing Phooey to get more comfortable with FRP, but I found it was far harder than I thought :)
14:36:06 <conal> Peaker: it's probably worth writing up.  thx for the reminder.
14:36:40 <mmorrow> mathijs: here's the .cmm that does the actual evaluation of closures (one of the most critical parts of a haskell prog) http://darcs.haskell.org/ghc/rts/Apply.cmm
14:36:59 <mmorrow> exceptions: http://darcs.haskell.org/ghc/rts/Exception.cmm
14:37:13 <mmorrow> primops: http://darcs.haskell.org/ghc/rts/PrimOps.cmm
14:37:37 <FunctorSalad> maybe my cabal compiled with 6.8.3 has problems with 6.10?
14:38:13 <FunctorSalad> it just memory leaks until the oomkilller comes while resolving dependencies
14:38:15 <dibblego> Heooo, do you happen to have the mp3 for "In Our Time"?
14:38:35 <ddarius> ski: I believe Lawvere started SDG off, but others really fleshed it out.
14:38:41 <mmorrow> mathijs: the lib 'rts' is all the C code you see in that directory
14:38:56 <mmorrow> mathijs: (i believe for the most part)
14:39:42 <mathijs> mmorrow: interresting, I'm not gonna read it all though, but it gives some impression / overview on how everything works together.
14:39:45 <mmorrow> libHSrts*
14:39:59 <vixey> ddarius, ah found it.. (~,~) (*,+) (1,0) (meet,join) (top,bot) (forall,exists) (!,?) are duals
14:40:18 <mmorrow> mathijs: this documents it all http://hackage.haskell.org/trac/ghc/wiki/Commentary
14:40:20 <lambdabot> Title: Commentary - GHC - Trac
14:40:25 <mmorrow> the rts in particular:
14:40:34 <mmorrow> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts
14:40:36 <lambdabot> Title: Commentary/Rts - GHC - Trac
14:40:52 <Saizan_> FunctorSalad: there was a bug that's fixed in 0.6
14:41:18 <jkr_> How can I catch an EOF, e.g. when using getChar?
14:41:25 <mmorrow> hIsEOF
14:41:28 <Saizan_> FunctorSalad: so you should download the newtarball and use the bootstrap.sh script
14:41:29 <mmorrow> hIsEOF stdin
14:41:39 <jkr_> Nice, thank you
14:41:43 <mmorrow> np
14:41:45 <ski> (ddarius : ok)
14:41:56 <mathijs> mmorrow: is there some work underway to split out parts of it? I mean if the binary ghc creates is able to load the rts from some system library, it would make binaries a lot smaller right? not that space is an issue these days, but still hello world is quite big
14:42:04 <FunctorSalad> Saizan_: I will, thx
14:42:46 <vixey> ddarius, so do you still plan to release a linear logic language? :)
14:42:58 <mmorrow> mathijs: shared library support is currently being worked on and i believe is functional to some degree in 6.10 (but whether it's useable for production stuff at the moment i'm not sure)
14:43:07 <mofmog> So apparently the codified grammar of Sanskrit is turing complete
14:43:25 <Nafai> mofmog: Wow
14:43:29 <mofmog> Or i should say, the rules used to describe Sanskrit, in Sanskrit is turing complete
14:43:36 <mofmog> So in other words, McCarthy basically ripped off Sanskrit
14:43:40 <Nafai> I wouldn't imagine you could say that about a Human natural language
14:43:57 <mofmog> well it's not really a natural language
14:43:58 <mathijs> mmorrow: nice, I'll have a look
14:44:00 <vixey> mofmog: is there a proof of this ?
14:44:06 <ski> vixey : that sound similar to my variant notation, additive : 0,+,1,* ; multiplicative : bot,(+),top,(*),-o ; negation : ~ ; quantifiers : exists,forall ; exponentials : ?,!
14:44:11 <vixey> mofmog: or at least some more formal argument for it
14:44:13 <mofmog> Well, let me qualify the statement
14:44:29 <vixey> ski, you made your own notation? :D
14:44:35 <mofmog> Sanskrit has two stages associated with it: Vedic Sanskrit which the Vedas were of course written in and Classical Sanskrit
14:44:36 <Heooo> dibblego: Yes, sec on my ipod :]
14:44:41 <vixey> ski, it looks the same, yes
14:44:46 <dibblego> Heooo, great thanks - all links seem to have disappeared
14:45:12 <mofmog> Classical Sanskrit is differentiated from Vedic in that it has a codified set of grammar set down by the grammarian Panini
14:45:36 <mofmog> The grammar is in effect built off of rules, transformations, meta rules, recursion etc
14:45:55 <ski> (vixey : more or less, when first learning about, i didn't recall exactly which symbol was which, so i reconstructed it the way i thought it was. later i noticed Girard had used other notation, not fitting so well with duality)
14:46:06 <ski> (s/about/about linear logic/)
14:46:46 <jkr_> Is there a way to NOT write if/then/else on one single line?
14:46:52 <mofmog> The crazy thing is that people would memorize the rules in the form of code words.
14:46:54 <ski>   if foo
14:46:58 <ski>     then bar
14:47:02 <ski>     else baz
14:47:09 <jkr_> Ah
14:47:10 <mofmog> http://www.haryana-online.com/Culture/sanskrit_literature.htm
14:47:12 <lambdabot> Title: Sanskrit Literature - Kalidasa - Vedas - Mahabharat - Ramayana - Haryana Online  ...
14:47:18 <mofmog> Panini and Ashtadhyayi
14:47:22 <eck_> just wondering, does anyone know of any PPAs with ghc 6.10 packaged for the latest ubuntu release?
14:47:27 <ski> (or indent `then' and `else' less than `if' if you want, that also works)
14:47:28 <FunctorSalad> mofmog: that totally gets my anandamide flowing :)
14:47:29 <jkr_> Works, thank you :)
14:47:39 <vixey> @let bool true false True = true ; bool true false False = false
14:47:40 <lambdabot>  Defined.
14:47:41 <ski>   blah = if foo
14:47:43 <ski>     then ...
14:47:47 <ski>    else ...
14:47:52 <vixey> jkr, bool is another way
14:48:07 <FunctorSalad> ('The name is taken from the Sanskrit word ananda, which means "bliss, delight", and amide.')
14:48:26 <Pseudonym> @let true = \t f -> t
14:48:27 <ski> @src Bool
14:48:28 <lambdabot>  Defined.
14:48:28 <lambdabot> data Bool = False | True deriving (Eq, Ord)
14:48:32 <Pseudonym> @let false = \t f -> f
14:48:33 <lambdabot>  Defined.
14:48:50 <vixey> :t bool true false
14:48:53 <lambdabot> forall t1. Bool -> t1 -> t1 -> t1
14:49:50 <ski> vixey : however, i think Girard more or less borrowed many of his symbols from Stab and Lin
14:50:11 <ski> (`bool' ought to take arguments in the other order, no ?)
14:50:13 <vixey> ski, oh ? from a specific text(s)?
14:50:25 <Heooo> dibblego: Enjoy! http://www.bbc.co.uk/radio4/history/inourtime/inourtime_20081009.shtml
14:50:27 <lambdabot> Title: BBC - Radio 4 In Our Time - Gödel's Incompleteness Theorems, http://tinyurl.com/3nmrvr
14:50:48 <Heooo> dibblego: Gdel rocks :]
14:50:54 <ski> vixey : i mean `(*)' being tensor product of some spaces,`(*)' being direct sum
14:50:59 <dibblego> Heooo, I only find a link to a .ram file on that page
14:51:06 <ski> (dunno about text)
14:51:12 <ddarius> Heooo: Goedel was insane.
14:51:14 <vixey> ok
14:51:15 <ski> er
14:51:42 <Pseudonym> Sanity is overrated.
14:51:44 <ski> (s/`(*)' being direct sum/`(+)' being direct sum/)
14:51:47 <ddarius> Pseudonym: Indeed.
14:52:15 <FunctorSalad> how was he insane?
14:52:25 <Heooo> dibblego: Do you have iTunes? I downloaded my file through iTunes in mac.
14:52:34 <vixey> paranoia
14:52:34 <dibblego> Heooo, I'll just use the .ram file thanks
14:52:45 <mofmog> is that the famous mathematicians who went insane docu?
14:52:46 <Heooo> dibblego: np
14:53:20 <ski> Cantor also became mentally ill
14:53:39 <vixey> grothendeick disappeared
14:53:50 <vixey> (after a breakdown ?)
14:54:12 <Pseudonym> Goedel was convinced that he was incomplete and inconsistent.
14:54:21 <mofmog> I wonder what would have happened if someone went back in time and brought turing back to the present, and then he could go back in time to tell godel all about uncomputability and then godel could go back in time and tell cantor about incompleteness!
14:54:21 <Pseudonym> Which made him unsound.
14:54:23 <FunctorSalad> Pseudonym: seriously?
14:54:27 <FunctorSalad> (first)
14:55:08 <FunctorSalad> mofmog: huh? I'm pretty sure Gödel knew about uncomputability
14:55:09 <ddarius> FunctorSalad: Goedel died because he refused to eat because he believed someone was trying to poison him.
14:55:38 <FunctorSalad> oh.
14:56:09 <vixey> Chaitin says Godel was a lisp hacker :p
14:56:32 <vixey> in some online essay by him, I thought that was an amusing comment
15:01:27 <ddarius> bos: That's a really good review by Pierce.
15:01:46 <bos> ddarius: yes, makes me happy
15:10:06 <jkr_> How do I make a datatype show'able? Is it enought to implement show :: MyType?
15:10:22 <ddarius> You make an instance of Show.
15:10:36 <ddarius> You can derive one if you don't particularly care what the output looks like.
15:10:37 <vixey> you can do it two ways
15:11:52 <jkr_> Sweet, just deriving (Show) does it :)
15:12:02 <jkr_> I thought I had to do something myself
15:14:48 <b_jonas> is there a way to make ghci append readline history to a file when it exits and load it when it starts?
15:15:26 <Saizan_> in 6.10 it should do that by default
15:16:12 <b_jonas> oh, great
15:16:19 <b_jonas> I guess I'll install it then
15:16:43 <b_jonas> I'm asking because I've seen at least one software that can do that but it's not the default setting
15:17:39 <Saizan_> the problem with 6.10's ghci is that editline is not so great
15:17:52 <ziman> what's wrong with editline?
15:18:04 <b_jonas> wait, do we already have 6.10.1 out?
15:18:20 <b_jonas> strange
15:18:24 <Saizan_> yes, official release
15:18:34 <b_jonas> I'll download that instead
15:18:47 <Saizan_> ziman: here the delete key doesn't work, and it can't cope with multibyte characters
15:18:50 <b_jonas> I like gnu readline, it has lots of cool features, it works reliably, and it's customizable
15:19:25 <b_jonas> I especially like the ^O and the ^X^E key combos which other readline-like packages don't offer
15:20:18 <ziman> oh
15:20:18 <b_jonas> (^O executes the line and preloads the next line in history at the next prompt, so you can run more than one lines sequentially from the history possibly editing them easily)
15:20:30 <b_jonas> (and ^X^E invokes an external editor)
15:20:51 <b_jonas> and I think I've never seen readline crash
15:21:02 <Botje> b_jonas++ # teaching me new tricks
15:21:40 <b_jonas> the third important one is ^[# which comments a line and executes it (the program has to set the comment prefix right of course)
15:22:48 <b_jonas> the only problem I have with readline is that on lines that are longer than the whole screen it displays things wrong
15:22:50 <Saizan_> were those working in ghci?
15:22:57 <b_jonas> Saizan_: dunno, let me check
15:23:15 <b_jonas> ^[# doesn't: it inserts a #
15:23:29 <b_jonas> but you might be able to override it program-wise in inputrc, I don't know
15:23:43 <b_jonas> ^O doesn't work for some reason
15:23:54 <b_jonas> nor does ^X^E
15:23:55 <b_jonas> strange
15:24:31 <b_jonas> maybe it uses wrong bindings or something
15:24:58 <mmorrow> totally, editline completely negates the ability of ghci to handle unicode input
15:25:07 <mmorrow> delete doesn't work either
15:25:16 * mmorrow bitches some more :)
15:25:18 * Saizan_ has rebuilt it using readline
15:25:29 <b_jonas> Saizan_: you can do that?
15:25:32 <b_jonas> maybe I should try
15:25:33 <nathanic> can editline use vi-mode?
15:25:36 <mmorrow> Saizan_: nice! i've been meaning to do that but never got around to it
15:25:44 <b_jonas> Saizan_: does history saving work that way too?
15:25:50 <mmorrow> Saizan_: do you have a patch anywhere? :)
15:26:29 <Saizan_> b_jonas: i commented out the history saving since the readline bindings don't expose similar functions to the ones used with editline
15:26:50 <b_jonas> I see
15:26:51 <b_jonas> pity
15:26:57 <mmorrow> ooh, sucky. the history is the single thing about editline i really liked
15:27:16 <mmorrow> hmm, maybe a small wrapper'd do it?
15:27:19 <vixey> I think we really need to replace terminals
15:27:29 <Saizan_> well, i didn't investigate much, so there's probably a way
15:27:40 <vixey> I don't know what with.. web browsers can be a good GUI I guess
15:27:44 <b_jonas> yeah, let's just write a wrapper that feeds program's standard input from readline
15:27:52 <mmorrow> Saizan_: so were you changes localized to InteractiveUI?
15:27:52 <vixey> so can Emacs but then you have to program in elisp instead of haskell
15:28:00 <mmorrow> *your
15:28:13 <vixey> b_jonas, was thinking more like proof general type thing
15:28:25 <Saizan_> mmorrow: and the build system, i can run diff to make a patch against the tarball i guess
15:28:28 <b_jonas> vixey: sorry?
15:28:29 <mmorrow> vixey: Yi ftw
15:28:33 <b_jonas> proof general type? what's that
15:28:42 <mmorrow> Saizan_: that would be awesome :)
15:29:06 <vixey> b_jonas, like, talking to the ghci state via a protocal -- and having some GUI (like a web browser, or emacs, or anything) present it
15:29:11 * Saizan_ downloads a fresh tarball
15:29:27 <vixey> instead of the protocol = the human interface
15:29:28 <vixey> this is exactly why it sucks
15:29:36 <b_jonas> vixey: dunno
15:29:38 <mmorrow> vixey: totally. that's kinda what i'm thinking of trying to do with neutron+luna
15:29:56 <mmorrow> but i'm not sure exactly the particulars yet
15:30:05 <vixey> mmorrow, neutron is totally suited to it I think, annoying I have no code to show but I was playing with this
15:30:24 <Saizan_> what is neutron?
15:30:28 <mmorrow> vixey: i think so too. i'm excited about the posibilities
15:30:45 <b_jonas> vixey: actually J sort of does that: the interpreter core has a simple repl but what it reads input from and writes output to can be different in the three interfaces (console, java, windows)
15:30:50 <vixey> mmorrow, execept webbrowsers are pretty suboptimal.. but it's a very good place to test stuff
15:31:02 <mmorrow> Saizan_: a mini httpd i wrote. it's pretty minimal/limited at the moment but i'm planning on adding to it over the next week
15:31:05 <vixey> b_jonas, *nod* it is tried and tested
15:31:06 <mmorrow> a link:
15:31:15 <b_jonas> also that protocol is documented (sort of) so you can write your own interface
15:31:20 <b_jonas> which is how the irc bot works
15:31:35 <b_jonas> but a few particulars with j make this really hard to use
15:31:39 <b_jonas> require some workarounds
15:31:44 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/neutron.hs.html
15:31:49 <lambdabot> Title: Haskell Code by HsColour
15:31:57 <b_jonas> also, Mathematica works like that I think
15:32:04 <b_jonas> though not exactly like that
15:32:27 <b_jonas> one thing you should note is that if you want tab completion to work, that complicates the protocol
15:32:31 <mmorrow> vixey: yeah, webbrowsers are def suboptimal. i'm thinking they could be good for information display though
15:33:06 <vixey> mmorrow, I'm not sure if webbrowers will get better or we need to implement something like TCL except.. good
15:33:40 <b_jonas> however, I also like to work from command line starting the interpreter each time from no state
15:33:42 <mmorrow> especially coupled with something like this: http://www.obviously.com/tech_tips/slow_load_technique
15:33:44 <lambdabot> Title: The Slow Load Technique/Reverse AJAX - Simulating Content Push in a Standard Web ...
15:33:47 <b_jonas> that's how I write perl one-liners
15:33:49 <b_jonas> no repl needed
15:35:08 <b_jonas> ghc -e seems a bit slow for this kind of thing though: ghc -e 'putStrLn "hi"' takes 0.17 sec on my fast machine
15:35:15 <mmorrow> so in that page, s/Nuclear power plant cooling status/current data decls, functions, etc/
15:35:18 <b_jonas> I wonder why. does it compile optimizingly or something?
15:36:11 <b_jonas> (this is on linux, not windows)
15:36:15 <b_jonas> why's it so slow?
15:36:26 <mmorrow> it appears to be compiling to bytecode
15:36:43 <mmorrow> i'm sure of this because in compiled code,
15:36:46 <mmorrow> fix id
15:36:51 <mmorrow> runs forever in constant space
15:36:54 <mmorrow> but in bytecode
15:36:57 <mmorrow> , fix id
15:36:59 <mmorrow> > fix id
15:36:59 <lunabot>  luna: out of memory (requested 2097152 bytes)
15:37:01 <lambdabot>   * Exception: stack overflow
15:37:14 <b_jonas> heh
15:37:22 <mmorrow> and i just tried
15:37:27 <vixey> tail recursion ftw!
15:37:28 <b_jonas> couldn't that depend on optimizations as well though?
15:37:30 <SamB> which one of those uses constant space ?
15:37:30 <mmorrow> $ ghc -e 'let fix f = let x = f x in x in fix id'
15:37:30 <mmorrow> Stack space overflow: current size 8388608 bytes.
15:37:37 <mmorrow> fix id
15:37:43 <mmorrow> is const space in compiled code
15:37:54 <SamB> both of them seem to overflow some sort of space ;-)
15:37:55 <mmorrow> bytecode handles tail calls as well
15:38:05 <mmorrow> there's some optimization step though that's left out i thikn
15:38:11 <Lemmih> b_jonas: No one has yet cared enough to make it fast. There are some fairly simple changes that would make it a fair bit faster.
15:38:14 <mmorrow> i've been trying to figure out which for a while now
15:38:24 <vixey> I saw a really interesting definition of tail calls and TCO
15:38:50 <mmorrow> Lemmih: ooh, do you know of what these are in particular/where to start looking?
15:38:54 <b_jonas> Lemmih: is that because no-one's using it from shell command line like I want to, or because everyone is on windows where it's not possible to make this kind of thing fast anyway?
15:39:24 <SamB> b_jonas: no
15:39:33 <Lemmih> mmorrow: There was something about parsing the package list being less than optimal.
15:39:39 <SamB> it's not because of either of those things
15:39:45 <mmorrow> hmm
15:40:21 <b_jonas> maybe 6.10.1 is faster
15:40:30 <mmorrow> luna is using 6.10
15:40:43 <mmorrow> and i just did $ ghc -e 'let fix f = let x = f x in x in fix id' with 6.10 as well
15:40:53 <mmorrow> same ole bytecode
15:41:42 <Lemmih> ghc-6.10.1 is slightly slower than ghc-6.8.3 on my box.
15:42:52 <b_jonas> I see
15:43:16 <b_jonas> I mean, gcc has been sped up a lot during major version 3, especially for gcc code
15:43:17 <ddarius> "Slice and comma categories" woo!
15:43:46 <b_jonas> it still seems strange that it's this slow when not optimizing
15:43:55 <b_jonas> I mean, if I run it with -O2 it has the reason to be slow
15:44:58 <vixey> comma categories :/
15:45:00 <vixey> I never heard of these
15:46:38 <dons> Lemmih: for what kind of benchmark?
15:46:48 <Lemmih> b_jonas: It's reading the package and interface files that is slow. The code generation is quite fast.
15:47:02 <dons> b_jonas: oh, you mean ghci?
15:47:04 <Lemmih> dons: ghc -e '()'.
15:47:11 <b_jonas> dons: no, ghc -e
15:47:13 <dons> hehe. yes. it loads a package index. and that index is getting bigger.
15:47:22 <dons> b_jonas: same dealy
15:47:24 <Lemmih> b_jonas: 'ghc -e' /is/ ghci.
15:47:30 <b_jonas> yeah
15:47:42 <dons> so that's /purely/ the cost of loading code and package specs
15:49:14 <FunctorSalad> can I just declare 'instance IsString ByteString where fromString = read' for ByteString literals?
15:49:36 <FunctorSalad> (instead of installing the newest bytestring)
15:50:10 <rwbarton_> shouldn't it be fromString = pack?
15:52:07 <FunctorSalad> rwbarton_: no idea. fromString should be String -> a
15:52:08 <dons> FunctorSalad: just use the new bytestring
15:52:17 <dons> its been out for a year with IsString support
15:52:32 <b_jonas> isn't bytestring in the ghc-extralibs?
15:52:38 <FunctorSalad> dons: ghc 6.10 comes with the old version though
15:52:42 <dons> no.
15:52:48 <dons> it comes with the new version.
15:53:21 <dons> Prelude Data.ByteString.Char8 Data.String> :info IsString
15:53:21 <dons> class IsString a where fromString :: String -> a -- Defined in Data.String
15:53:21 <dons> instance IsString [Char] -- Defined in Data.String
15:53:21 <dons> instance IsString ByteString -- Defined in Data.ByteString.Char8
15:53:57 <FunctorSalad> dons: true, I relied on the release notes :) http://haskell.org/ghc/docs/6.10.1/html/users_guide/release-6-10-1.html
15:54:13 <dons> ah ha
15:54:17 <dons> it is indeed wrong.
15:57:37 <dax> good morning
15:58:39 <dax> i've got a Problem: http://paste.pocoo.org/show/90424
15:58:56 <dax> the second function never ends
15:59:19 <dax> and i don't have any clue why..
16:01:03 <Cale> dax: I'll take a look
16:02:18 <dax> thx :)
16:03:13 <b_jonas> dax: where do you define inorderiter' (Nil:ns) ?
16:03:20 <b_jonas> isn't it missing a definition for that?
16:05:03 <dax> b_jonas: i check for Nil in the function body with case-ofs
16:05:45 <rwbarton_> dax: is there a reason you can't just write  inorderIter Nil = []; inorderIter (Tree l a r) = inorderIter l ++ [a] ++ inorderIter r?
16:05:53 <Cale> The queue seems to be growing without bound.
16:06:00 <b_jonas> oh, you check for nul children, but not for whole nul thing
16:06:17 <Cale> rwbarton_: Of course, that's worst case quadratic, but there's an easy translation to make it linear.
16:06:23 <rwbarton_> Cale: Right.
16:06:25 <BMeph> dax: What does 'left' do? :)
16:06:30 <dax> rwbarton_: yep. It's homework ;)
16:06:42 <b_jonas> it might not be relevant, but this declaration '(<<) = enq' without a type is strange too
16:06:50 <bbs> anyone really good with c in here
16:06:53 <bbs> i know this is haskell :)
16:07:03 <b_jonas> but if the compiler accepts it
16:07:07 <b_jonas> it's probably right
16:07:13 <dax> left is the left leaf, coming from the deq call
16:07:29 <b_jonas> bbs: ##c is usually fast and helpful
16:07:39 <dax> b_jonas: (<<) = enq because enq is defined a line above
16:07:44 <bbs> ok
16:07:52 <Lemmih> bbs: I tried it once but I kept getting this weird type error called segmentation fault.
16:07:54 <roconnor> > (\x -> 4*x*(1-x)) (exp(-1))
16:08:05 <roconnor> @bot
16:08:06 <bbs> Lemmih: for what?
16:08:08 <bbs> xmas.c
16:08:32 <lambdabot> :)
16:08:33 <lambdabot>   0.9301766317393185
16:08:48 <Lemmih> bbs: My attempt at humour has failed, apparently.
16:09:10 <BMeph> dax: but in the inorderIter' that's a sub-function(?) of your second function, what node is it supposed to be using?
16:09:24 <Cale> dax: I'm not sure I understand the idea behind this algorithm...
16:09:31 <juhp> is there a good debian repo for haskell?
16:09:32 <ddarius> roconnor: ?
16:09:43 <juhp> like with up to date packages?
16:09:45 <BMeph> Lemmih: Humor fault (core dumped).
16:10:06 <b_jonas> wait, bbs: where does inorderIter even extract the children of a Node ?
16:10:23 <dax> Cale: this is the same: http://paste.pocoo.org/show/90425
16:10:36 <b_jonas> ah, '((Node left x right), queue') = deq queue'
16:10:40 <b_jonas> this code is complicated
16:11:16 <Cale> dax: Heh. I'm not sure that's any clearer. Is the goal just to do an inorder traversal, or do you specifically need to do it using this Queue type?
16:11:20 <BMeph> dax: Ooh, sorry, didn't see the where of the where of the where... ;p
16:11:58 <dax> Cale: i need to do the traversal interatively
16:12:25 <yitz> bewhere the where of the where of the where
16:12:27 <dax> and the first function and the python version are working
16:12:46 <Cale> inorder :: Tree a -> [a]
16:12:46 <Cale> inorder t = inorder' t []
16:12:46 <Cale>   where inorder' Nil          = id
16:12:46 <Cale>         inorder' (Node l x r) = inorder' l . (x:) . inorder' r
16:12:56 <dax> but the function using the queue type is broken
16:12:56 <Cale> is how I would normally write this.
16:12:58 <rwbarton_> dax: "interactively"?
16:13:09 <Cale> rwbarton_: iteratively
16:13:28 <dax> yep
16:13:29 <BMeph> It's both! :)
16:13:30 <rwbarton_> Ah, they both have edit distance 1 :)
16:13:42 <b_jonas> Cale: wrong type
16:13:52 * BMeph like "iteractively"
16:13:55 <b_jonas> Cale: that is, wrong type declaration for inorder if you write it that way
16:13:56 <Cale> b_jonas: how so?
16:14:01 <BMeph> s/like/likes/
16:14:05 <b_jonas> Cale: oh, it has where too
16:14:12 <b_jonas> so inorder' is the one that gives a function
16:14:13 <b_jonas> and you call it
16:14:14 <mmorrow> dax: if you want to do it interactively, you'll need a zipper on the tree
16:14:14 <b_jonas> sorry
16:14:20 <Saizan> "where" strikes again
16:15:10 <Cale> okay, well, with that out of the way, let's describe the idea of this iterative algorithm in English and then encode that :)
16:15:11 <dax> mmorrow: the problem is: why does my algo break if i use tho queue?
16:15:12 <b_jonas> yeah, it's late
16:15:30 <dax> *the
16:15:35 <BMeph> inorder' :: Tree a -> [a] -> [a]
16:15:39 <mmorrow> dax: i'm not sure, i haven't seen the code :)
16:16:04 <mmorrow> dax: here's one zipper implem option: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rosezipper
16:16:06 <lambdabot> Title: HackageDB: rosezipper-0.1, http://tinyurl.com/6bhut6
16:16:17 <dancor> i have a bunch of process ids and my own process id.  how do i take the ones out of the bunch that are in the same process group as me?
16:16:18 <Cale> BMeph: yep
16:16:29 <dancor> i don't see anything in System.Posix.Process
16:16:53 <BMeph> Cale: Sweet! I got something right today!
16:17:03 <Cale> BMeph: Have you seen that trick before?
16:17:47 * BMeph checks off one more thing from his "Things to do this month" list
16:18:20 <Cale> I really like it a lot. The idea is that if instead of working with lists, you work with functions that prefix their parameter with some additional elements, then composition becomes like concatenation.
16:18:35 <Cale> But concatenation is in general an O(n) operation, while composition is constant time.
16:18:40 <BMeph> Cale: What, worker-wrapper? Yeah, Andy J Gill is a zealous proselytizer... :)
16:19:39 <BMeph> Cale: That's the same thing they use in DList. I recognized it from that, as well. :)
16:20:01 <dancor> i guess i can use `ps`
16:20:11 <Cale> Hmm, I suppose it is a special case of worker/wrapper.
16:20:22 <dax> ok, the algo is the following: set up a queue with the root node, then, as long as the queue is not empty: if we got up last time, save the value and, if the right side is not Nil, queue this one. If we not got up the last time: If the left leaf is Nil: Save the value and queue the right leaf if it is not Nil. If left is not Nil: queue left
16:20:48 <dax> oh, forgot one.
16:20:55 <Cale> up?
16:21:14 <sbahra> The algorithm description is very imperative ;-p
16:21:27 <dax> ok, the algo is the following: set up a queue with the root node, then, as long as the queue is not empty: if we got up last time, save the value and, if the right side is not Nil, queue this one. If we not got up the last time: If the left leaf is Nil: Save the value and queue the right leaf if it is not Nil or, if it is Nil: Save that we get up. If left is not Nil: queue left
16:21:29 <_MaK_> Cale: tell me  if i'm wrong but isn't the tail recursive brake the laziness?
16:22:05 <Cale> _MaK_: hm? Tail recursion and laziness often don't mix very nicely.
16:22:15 <rwbarton_> dax: your algorithm is getting cut off around "If left is not Nil: queue left"
16:22:21 <Cale> _MaK_: But I'm unsure about what you mean.
16:23:26 <Cale> _MaK_: You have to be careful, if a function is tail recursive, that its parameters are evaluated before it makes the call to itself, or else you can end up building large expressions in the accumulating parameters which don't get evaluated until they are very large.
16:23:31 <BMeph> dax: I'd say the main issue you have is that lists work like stacks, not queues. :)
16:24:17 <Cale> BMeph: I would say his main problem is that his implementation doesn't terminate ;)
16:24:45 <dax> hah. i reproduced it!
16:24:51 <rwbarton_> I hope the purpose of this exercise is to illustrate that arbitrarily restricting yourself from using a class of algorithms is insane
16:25:19 <dax> the harmful code: http://paste.pocoo.org/show/90427
16:25:21 <Cale> We could replace this slow Queue with something like a Data.Sequence
16:25:42 <rwbarton_> Cale: this Queue should be faster than a Data.Sequence, if it's used single-threadedly, no?
16:25:45 <dax> the change is in the where clause
16:25:50 <Cale> rwbarton_: should it?
16:26:06 <dax> My Problem is purely academic ;)
16:26:07 <rwbarton_> Cale: yeah, each element gets processed only three times in its lifetime
16:26:49 <rwbarton_> Cale: Oh, I guess Data.Sequence should be constant time as well, but it's hard to imagine the constant being smaller
16:26:50 <Cale> rwbarton_: Oh, I suppose the amortised time of reverse isn't so bad.
16:26:51 <b_jonas> I built ghc-5.10.1, now how do I run the test suite? make test doesn't work
16:27:40 <Cale> rwbarton_: My usual instinct is: reverse => replace lists with something else
16:32:49 * RayNbow is amazed by http://groups.google.com/group/fa.haskell/msg/6a63dc4540f0486d
16:32:52 <lambdabot> Title: Multi-line string literals are both easy /and/ elegant in Haskell - fa.haskell | ...
16:35:03 <Cale> dax: aha... I translated the algorithm a little so that it was generative rather than tail-recursive
16:35:11 <Cale> dax: and I'm seeing an infinite list of 1's :)
16:35:40 <Cale> dax: http://paste.pocoo.org/show/90429/
16:36:20 <Cale> dax: This is equivalent, it just returns results immediately rather than accumulating them in a list to be reversed at the end.
16:36:23 <dax> i got the error...somehow
16:36:51 <dax> the queue worked unexpected
16:37:47 <mmorrow> RayNbow: -XQuasiQuotes FWT!! :)
16:37:53 <mmorrow> *FTW!!
16:37:59 <RayNbow> mmorrow: ^_^
16:38:12 <RayNbow> TH is still on my ToLearn list though :p
16:38:17 <dax> thx cale
16:38:33 <b_jonas> but with the call/cc monad or haskell concurrency available, why would you ever need to manually translate something to return early and cps?
16:38:37 <mmorrow> RayNbow: it's definitely worth the effort.
16:38:47 * Cale transforms the code some more in order to understand it better.
16:39:22 <RayNbow> mmorrow: yeah, but I kept postponing it because it wasn't available in a stable GHC release :p
16:39:31 <b_jonas> can anyone answer my question about ghc btw?
16:40:08 <RayNbow> Cale: the second argument of inorderIter' indicates the direction of the traversal?
16:40:10 <mmorrow> RayNbow: heh. now that 6.10 is out, i guess you're out of excuses ;)
16:40:22 <Cale> RayNbow: Seems that way.
16:41:15 <RayNbow> mmorrow: I need to install the final version of 6.10 this weekend though (currently using a pre-release of 6.10)
16:41:36 <b_jonas> RayNbow: 6.10.1 is out now as well, you might install that instead
16:42:22 * mmorrow just build a 6.10.1
16:42:28 <Saizan> b_jonas: did you download the separate testsuite package?
16:42:32 <RayNbow> Cale: your code somehow reminded me of the paper "Visitor Combination and Traversal Control" (even though it's about patterns in Java)
16:42:41 <b_jonas> Saizan: yes, and unpacked it too
16:42:45 <Axman6> i get errors trying to build 6.10.1 :(
16:42:48 <Cale> RayNbow: It's actually just a slightly transformed version of dax's code.
16:43:03 <mmorrow> Axman6: related to Control.(Old)Exception?
16:43:11 <Axman6> something about mv GNUMakefile GNUMakefile.tmp failes, no such file or directory
16:43:22 <mmorrow> hmm, i dunno
16:43:22 <Cale> RayNbow: I don't presently understand it properly, I'm transforming it into something which makes sense to me :)
16:43:22 <Axman6> mv: rename GNUmakefile to GNUmakefile.tmp: No such file or directory
16:43:40 <b_jonas> ah, there's a testsuite/README
16:43:42 <mmorrow> are you building from a fresh tarball?
16:43:48 <mmorrow> (@Axman6)
16:43:48 <Axman6> yeah
16:44:07 <mmorrow> weird. on what os and with which ghc version?
16:44:12 <RayNbow> Cale: ah, right :)
16:44:22 <Axman6> OS X, compiling using 6.8.3
16:44:42 <dax> Cale: this is weird: http://paste.pocoo.org/show/90431
16:44:49 <dax> f3 works.
16:44:50 <mmorrow> hmm, i'm on linux and built with 6.10.0. maybe some osx people can help
16:45:31 <Cale> dax: I just realised the flaw
16:45:36 <Cale>         rightQueue = case right of
16:45:36 <Cale>             Nil -> ns'
16:45:36 <Cale>             _   -> right:ns'
16:45:43 <Axman6> make[1]: *** No targets specified and no makefile found.  Stop.
16:45:43 <Axman6> make: *** [make.library.dph/dph-prim-seq] Error 2
16:45:49 <Cale> Note the Nil case (this now works correctly)
16:45:53 <Axman6> that's there too
16:46:08 <Cale> It should not be ns, because that results in the exact same call to inorderIter'
16:46:25 <mmorrow> Axman6: maybe mention this in #ghc.
16:46:33 <Axman6> sure
16:46:48 <Cale> For instance, say,   inorderIter' [Node Nil 1 Nil, Node (Node Nil 1 Nil) 2 Nil] False
16:46:48 * RayNbow is going to get some sleep, 'night all :)
16:46:53 <mmorrow> night
16:47:43 <Cale> We see that not up is true, and left is nil, so we're outputting 1, and calling inorderIter' rightQueue True
16:48:28 <dax> Argh.
16:49:12 <Cale> But if rightQueue = ns, then this means we're making the same call to inorderIter', just with the up flag set, which means we'll output 1 again, and then call the exact same thing but with the up flag unset
16:49:17 <Cale> and we're in an infinite loop
16:49:38 <Cale> So you have to remove that tree from the queue (stack?) when you generate the element.
16:50:25 <Cale> http://paste.pocoo.org/show/90434/ -- so this now works.
16:50:25 <dax> argh. its a stack, not a queue. i im so stupid >.<
16:51:13 <Cale> The code is still rather hard for me to understand though. :)
16:51:52 <Cale> I suppose it basically makes sense...
16:53:33 <dax> i am just a haskell beginner, so my style is...umm...bad.
16:54:30 <Cale> It can be very hard to translate imperative algorithms directly and have them also be readable.
16:57:16 <u_quark> is there a man page for cabal(-install) ?
16:57:33 <dcoutts> u_quark: no, but there's a Cabal user guide on the Cabal website
16:57:35 <Cale> u_quark: well, try running cabal --help
16:57:44 <dcoutts> u_quark: and yes, cabal --help is pretty useful
16:57:45 <u_quark> yes ok tnx
16:57:55 <u_quark> yes yes I know
16:58:17 <u_quark> i just wonted, if there was one, to install it :)
16:58:40 <bbs> heheh
16:58:47 <bbs> Cale: you know that class i'm in
16:58:55 <bbs> the teacher gave us an obfuscated c program
16:58:57 <Cale> bbs: yeah?
16:59:04 <bbs> and said if we could solve the provlem we would get an "a"
16:59:07 <Cale> hehe :)
16:59:14 <bbs> it was 1 space
16:59:20 <bbs> and i don't think hes going to give me an a
16:59:39 <dax> http://paste.pocoo.org/show/90436
16:59:54 <dax> This works perfectly.
17:00:04 <dax> perfect i mean
17:00:19 <dax> (<<) is push
17:00:19 <dmwit> Perfectly is correct.
17:00:34 <dax> thx :)
17:01:16 <FunctorSalad> if I do 'createProcess x >> return ()', is it guaranteed that the process is actually run?
17:01:17 <dmwit> That seems like an awfully complicated way to get an inorder traversal.
17:01:39 <FunctorSalad> (not sure what lazyness does here)
17:01:55 <dax> is there another iterative algo?
17:02:01 <Axman6> FunctorSalad: i thought it did. thought it was kinda like `seq`
17:02:05 <dmwit> dax: Does it need to be iterative?
17:02:15 <dax> yes
17:02:22 <dmwit> uh
17:02:24 <dmwit> Why?
17:02:31 <dax> Homework
17:02:31 <Axman6> dax: what are you trying to do?
17:02:54 * dmwit notes that the pasted version is not iterative, either
17:02:56 <FunctorSalad> Axman6: I hope :)
17:03:17 * ddarius stumbles across homothety again.
17:03:22 <BMeph> thinks that dax does what the voices in his head^W^W^W^W^Wteacher says to do... ;)
17:03:32 <dax> dmwit: it is tail recursive, which is interative
17:03:35 <FunctorSalad> maybe I have to do waitForProcess if I want it to block until it's finished
17:04:21 <dax> my prof thinks, recursive solutions are too hard to understand...
17:04:57 <Axman6> your professor's an idiot
17:05:02 <BMeph> Recursion is hard! Let's go shopping! ;p
17:05:08 <dax> dmwit: you are right, sry
17:05:08 <dmwit> The recursive solution is much shorter and clearer.
17:05:25 <Axman6> even the definition of recursion is easy! Recursion: see Recursion.
17:05:36 <_MaK_> lol
17:05:40 <dax> but performs badly in our language of choice.
17:05:44 <dax> Java.
17:06:09 <dmwit> inOrder (Node left x right) = inOrder left ++ [x] ++ inOrder right -- much easier to understand
17:06:28 <dmwit> Easier to modify into preOrder and postOrder, too; just permute the guys on the right.
17:06:48 <dibblego> Java; causing brain damage to professors and others alike for 15 years now
17:07:02 <dmwit> dax: Recursion performs badly in Java?
17:07:14 <dmwit> dax: Are you sure?  Double sure?
17:07:16 <Axman6> i don't see why it would
17:07:23 <rwbarton_> You can also write a much clearer "iterative" version using a stack of tasks rather than a queue
17:07:40 <dibblego> some JVMs - specifically Sun - do not implement TCO
17:07:53 <dmwit> dibblego: This is not tail recursive, anyway.
17:07:55 <Axman6> TCO?
17:08:17 <dax> http://paste.pocoo.org/show/90437 now its tail rec.
17:08:54 <mmorrow> , let inorder = let go (Node x []) k =  k [x] ; go (Node x [l,r]) k = go l (\xs -> xs ++ [x] ++ go r k) in flip go id in inorder (Node 1 [Node 2 [Node 3 [],Node 4[]],Node 5 [Node 6 [],Node 7[]]])
17:08:54 <mmorrow> [3,2,4,1,6,5,7]
17:08:56 <lunabot>  [3,2,4,1,6,5,7]
17:08:57 <mmorrow> grr
17:09:05 <mmorrow> oh n/m
17:09:12 <mmorrow> , let inorder = let go (Node x []) k =  k [x] ; go (Node x [l,r]) k = go l (\xs -> xs ++ [x] ++ go r k) in flip go id in inorder (Node 1 [Node 2 [Node 3 [],Node 4[]],Node 5 [Node 6 [],Node 7[]]])
17:09:14 <lunabot>  [3,2,4,1,6,5,7]
17:09:54 <dax> dmwit: we must find an iterative one, thats the task
17:10:05 <mmorrow> (that uses Node a [Tree a] for binary trees, so assumes a Node is either [] or [Tree a,Tree a]
17:10:08 <mmorrow> )
17:10:27 <mmorrow> *assumes a subForest is ...
17:10:28 <dax> i use recursion all the time if it is not explicitly forbidden
17:10:45 <mmorrow> but all iteration in haskell is done with recursion
17:10:50 <mmorrow> even lists
17:11:04 <dax> but TC -> Iterative
17:11:19 <mmorrow> ?
17:11:31 <mmorrow> what's TC?
17:11:36 <dax> tail recursion is iterative
17:11:39 <dmwit_> If you allow yourself a stack (list), *all* recursion can be mechanically turned into tail-call recursion.
17:11:45 <rwbarton_> but instead you're builing this queue of things to handle
17:11:47 <ben_h> hi folks
17:11:50 <mmorrow> dax: oh. it's a transformation
17:11:57 <rwbarton_> how is it better to manage it yourself rather than let the compiler do it?
17:12:01 <dmwit_> exactly
17:12:03 <mmorrow> since iterative and recursive are equivalent
17:12:11 <dmwit_> ben_h: Hiya!
17:13:13 <Axman6> is it even possible to tail recursively get the elements in a binary tree into an ordered list?
17:13:23 <mmorrow> and all iteration can be turned into the equivalent recursive def
17:14:06 <mmorrow> Axman6: sure
17:14:16 <mmorrow> err, what do you mean "ordered list"?
17:14:19 <dax> Axman6: all is possible. But not nice ;)
17:14:25 <Axman6> i mean, you have to go down all the branches, and you end up with multiple end points
17:14:36 <mmorrow> Axman6: like this:
17:15:27 * roconnor imagines you'd have to use continuations
17:15:49 <Axman6> mmorrow: well, like i think you had before, inOrder (Node x left right) = inOrder left ++ [x] ++ inOrder right
17:16:26 <rwbarton_> f [] = []; f (Right x : ts) = x : f ts; f (Left Empty : ts) = f ts; f (Left (Tree l x r) : ts) = f (Left l : Right x : Left r : ts)
17:16:27 <dax> so good night and thanks for the help
17:16:59 <rwbarton_> that's an easy "iterative" solution
17:17:15 <rwbarton_> just the straightforward translation of the recursive solution using a stack
17:17:18 <roconnor> f (Right x : ts) = x : f ts   isn't tail recursive.
17:17:24 <roconnor> is it?
17:17:41 <rwbarton_> It is by my secret definition.  But you know how to make it tail recursive by other definitions.
17:17:44 <ddarius> It isn't.
17:17:56 <dax> you need another stack...
17:19:05 <ddarius> One neat way to do it without stack is with pointer reversing.
17:21:03 <dax> gn8
17:22:17 <Axman6> urgh! frigging crap ISP
17:23:05 <Axman6> mmorrow: sorry, i missed everything said after 12:14 #haskell: < mmorrow> Axman6: like this:
17:24:47 <paczesiowa> http://tunes.org/~nef/logs/haskell/
17:24:50 <lambdabot> Title: Index of /~nef/logs/haskell
17:26:06 <Axman6> ok, there was nothing... and i did manage to say stuff apparently
17:26:30 <roconnor> Axman6: we are all awaiting mmorrow too
17:27:01 * Axman6 senses a momentus day in #haskell history awaits the reply of mmorrow 
17:28:05 <gwern> to mmorrow, to mmorrow, mmorrow just a chan away!
17:28:11 <dons> uh oh. wow.
17:28:11 <gwern> *mmorrow's
17:28:39 <roconnor> yes mmorrow can!
17:29:16 <ddarius> mmorrow got stuck in an infinite loop.  Someone will have to go reset him.-
17:29:39 <dolio> Someone should rewrite him in a total language.
17:29:59 <ddarius> dolio: That would make it rather difficult for him to be a programmer.
17:30:09 <dolio> Heh.
17:30:59 <Axman6> urgh, how do i check the type of \\ in ghci, for Data.Map? i have three occurrances of \\
17:31:21 <Axman6>  :t Data.Map.(\\), .\\ don't work
17:31:55 <gwern> Prelude Data.Map> :t (Data.Map.\\)
17:31:56 <gwern> (Data.Map.\\) :: (Ord k) => Map k a -> Map k b -> Map k a
17:31:58 <ddarius> :t (Data.Map.\\\\)
17:31:59 <lambdabot> Not in scope: `Data.Map.\\\\'
17:32:02 <ddarius> :t (Data.Map.\\)
17:32:03 <lambdabot> forall k a b. (Ord k) => M.Map k a -> M.Map k b -> M.Map k a
17:32:04 <Axman6> ah ha
17:32:14 <ddarius> :t (\\)
17:32:16 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
17:32:29 <ddarius> @src (\\)
17:32:30 <lambdabot> (\\) = foldl (flip delete)
17:32:30 <kpreid> Axman6: in general, you put the name qualification right against the name, even if it's infix
17:32:36 <kpreid> > 1 Prelude.+ 2
17:32:38 <lambdabot>   3
17:32:45 <ddarius> Hmm, I guess they fixed it or I can't find the right plugin.
17:32:50 <ddarius> @hoogle (\\)
17:32:51 <lambdabot> Data.IntMap (\\) :: IntMap a -> IntMap b -> IntMap a
17:32:51 <lambdabot> Data.IntSet (\\) :: IntSet -> IntSet -> IntSet
17:32:51 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
17:33:55 <jdrake> Does anyone have packages for ghc6.10 for debian? I always keep my stuff within the debian packaging system where possible, and so far I have been able to do that for ghc too.
17:34:55 <adu> hi
17:34:58 <gwern> jdrake: I haven't heard of any. the official debian/ubuntu packagers are slow as molasses, so I don't expect to see any any time soon
17:35:08 * gwern would settle for packages of 6.8.3 at this point
17:35:41 <adu> jdrake: I have given up on sticking to one package system
17:36:23 <adu> I find the most portable package system is ./configure ; make ; make install
17:36:49 <gwern> I abandoned my principles the day I compiled cabal-install
17:37:37 <adu> gwern: what's wrong with source?
17:37:41 <jdrake> adu, which makes it difficult as hell to remove
17:38:07 <adu> jdrake: thats what stow/graft is for
17:38:25 <jdrake> adu, I am listening. What is that.
17:38:39 <gwern> adu: it increases the administration burden on me
17:39:05 <adu> jdrake: they're symlink systems
17:39:14 <jdrake> adu, that is evil
17:39:24 <BrokenClockwork> when using recursion, what's first runned, the innermost bracket or the outermost bracket?
17:39:41 <jdrake> Perhaps I should ask - what does 6.10 give me that 6.8.3 doesn't?
17:39:51 <Botje> build failures!
17:39:51 <gwern> http://www.catonmat.net/blog/wp-content/uploads/2008/11/edsger-dijkstra-quick-and-dirty.jpg <-- if only djikstra had been a FPer
17:39:54 <jdrake> I am a beginner.
17:39:56 <adu> jdrake: they let you installs to /usr/local/something/ghc-6.10 and then symlink to /usr/local
17:39:57 <lambdabot> http://tinyurl.com/654gu6
17:39:58 <dmwit_> jdrake: Check out GoboLinux' FS hierarchy, it makes deinstallation of make install'd stuff absolutely dreamy.
17:39:59 <BrokenClockwork> min 3 (min 5 ( min [1] = 1 )))
17:40:21 <adu> jdrake: what is evil about the freedom to remove software?
17:40:22 <jdrake> dmwit_, EEEEK, GoboLinux is pure evil in the land of the pure.
17:40:39 <dmwit_> jdrake: I don't like you any more.
17:41:00 <Botje> BrokenClockwork: the innermost expression should be evaluated first
17:41:04 <jdrake> dmwit_, may the shower of dpkg rein
17:41:13 <BrokenClockwork> ok
17:41:14 <Botje> but only if the whole expression is evaluated
17:41:33 <BrokenClockwork> woops
17:41:35 <BrokenClockwork> yeah sure
17:41:59 <Botje> > let stuff = (min [0..], 52) in snd stuff
17:42:00 <lambdabot>   52
17:42:04 <ddarius> Evaluation always precedes left-most outer-most first.
17:42:39 <Botje> oh right
17:42:40 <Botje> blah :(
17:43:03 <ddarius> s/precedes/proceeds/
17:43:17 <ddarius> Damn near-homophones
17:43:30 <adu> jdrake: did you know that .rpm is part of LSB but .deb is not?
17:43:42 <shapr> adu: sucks
17:44:01 <adu> shapr: hi!
17:44:10 <shapr> hiya!
17:44:12 <shapr> How's code?
17:44:16 <adu> shapr how are you?
17:44:21 <adu> shapr: good!
17:44:24 <shapr> Life is exciting!
17:44:25 <ddarius> But really, you can rarely tell what order is actually used.
17:44:42 <jdrake> adu, it wouldn't surprise me - redhat and novell have more money :p
17:44:51 * dons mentions that the haskell reddit is active, http://www.reddit.com/r/haskell/ 
17:44:53 <lambdabot> Title: Haskell
17:45:14 <Nafai> Hey shapr!
17:45:30 <dolio> dons: They finally chased you out of general programming? :)
17:45:31 <adu> shapr: I'm working on diff stuff
17:45:34 <dons> dolio: hehaha
17:45:37 <dons> yes :(
17:45:45 <shapr> adu: Like, writing your own diff program?
17:45:47 <shapr> hiya Nafai!
17:45:49 <dons> well, we can actually make this super focused.
17:45:54 <adu> shapr: well, yes and no
17:46:06 <adu> shapr: half-darcs half-owndiff
17:46:24 <dolio> Perhaps it's for the best. I always had to spend a lot of time downvoting/hiding a lot of crap on the general one.
17:46:29 <dons> yeah
17:46:40 <dons> i think big general things still go to proggit (maybe one a day)
17:47:28 <adu> proggit?
17:47:40 <eck> i posted this to #xmonad but i'm going to try here also in case someone can help me... i built xmobar from cabal (using cabal-install) with ghc 6.10 and I'm getting this error when I try to run it: http://pastebin.com/m1264763b . Is anyone familiar with this issue?
17:47:45 <dmwit_> adu: programming.reddit.com
17:47:56 <dmwit_> eck: That's not a Haskell issue, it's an X issue, I think.
17:48:05 <adu> jdrake: but anyways, I <3 Debian, so it makes me sad too...
17:48:49 <jdrake> adu, I like dpkg enough that I wouldn't mind figuring out how to make the packages properly. The problem I had was the test suite failed because some prototype ghc file didn't exist. But that was 2 days ago.
17:48:59 <adu> you know all we need to do is have ECMA standardize .deb, then ISO will be like, well, we might as well...
17:49:17 <eck> that doesn't help me much :-)
18:14:05 <u_quark> haskell-src-exts doesn't build :(
18:16:07 <alc> using cabal install?
18:17:24 <u_quark> yeap...
18:17:26 <alc> i recall that it depends on happy which depends on itself
18:17:47 <u_quark> lol no i have build and installed happy
18:17:56 <alc> heh
18:18:01 <alc> no idea then
18:18:07 <alc> last time i manually installed happy
18:18:11 <dibblego> > 318 * 75
18:18:18 <lambdabot>   23850
18:19:03 <u_quark> happy was installed smoothly with cabal-install
18:19:36 <u_quark> Language/Haskell/Exts/Syntax.hs:102:7: Could not find module `Data.Data':
18:30:04 <u_quark> lambdabot doesn;t compile either :|
18:37:09 * BrokenClockwork kicks lambdabot
18:39:46 <ushdf> > my love
18:39:47 <lambdabot>   Not in scope: `my'Not in scope: `love'
18:40:11 <ushdf> oh, the cruel emotionless heuristic of utility
18:40:28 <Pseudonym> > enemy_submarine
18:40:29 <lambdabot>   Not in scope: `enemy_submarine'
18:42:24 <Nafai> Pseudonym: Haha
18:42:25 <u_quark> yes it may be emotionless ... but it still is cute :)
18:42:30 <Nafai> Took me a second, but I got it
18:42:54 * u_quark hugs lambdabot
18:43:23 * Raynes_ Group hugs lambdabot and u_quark.
18:44:17 <u_quark> :P
18:45:15 <mmorrow> Axman6: sorry, i had to run to a haircut (i swear ;)
18:45:45 <Pseudonym> I'd swear too if I had that haircut.
18:45:50 <mmorrow> , let dfs = let go [] k = k [] ; go (Node x ts : fs) k = go ts (\xs -> x : xs ++ go fs k) in flip go id in dfs [Node 1 [Node 2 [Node 3 [],Node 4[]],Node 5 [Node 6 [],Node 7[]]]]
18:45:52 <lunabot>  [3,4,2,6,7,5,1]
18:46:13 <ushdf> KALEIDOSCOPE!!!!
18:46:19 * ushdf turns on the disco
18:46:24 <ushdf> theque
18:46:25 <mmorrow> that's Data.Tree.flatten but for forests
18:46:35 <mmorrow> (that not the implem of flatten though)
18:46:39 <ushdf> agent orange?
18:46:48 <mmorrow> Pseudonym: heh
18:48:27 <u_quark> i think all problems are caused because 6.10.1 is shipped with 2 versions of base ... why is that ?
18:48:49 <mmorrow> "extensible exceptions"
18:52:17 <nejucomo> Hello, I've run into a limitation of the type system which I do not understand.
18:52:40 <nejucomo> I want to say:  instance (OtherClass a) => SomeClass a where ...
18:52:59 <nejucomo> -but I have to enable some ghc flag, and then my program fails to run.
18:53:05 <nejucomo> The issue is I can't see the ambiguity.
18:53:41 <nejucomo> I'm trying to say: "for every instance of OtherClass, there is an instance of SomeClass defined like this..."
18:53:55 <mmorrow> what is your desired ..
18:54:01 <mmorrow> yeah, i thought that too at first
18:54:09 <mmorrow> it doesn't mean that though
18:54:14 <nejucomo> Oh.
18:54:17 <mmorrow> it means:
18:55:18 <mmorrow> "every type a is an instance of SomeClass, with the below implem. also, a must be an instance of OtherClass)
18:55:22 <mmorrow> s/)/"/
18:55:32 <nejucomo> Oh.  I see.
18:55:56 <nejucomo> Suppose OtherClass defines only one function of type "a -> Int" where a is one of the class variables.
18:56:31 <mmorrow> ok
18:56:32 <nejucomo> Wait, replace "OtherClass" with "SomeClass" in that statement.
18:56:36 <mmorrow> ok
18:57:01 <nejucomo> And lets say that function is called someClassFunc.
18:57:09 <mmorrow> ok
18:57:32 <nejucomo> Can I say: instance SomeClass a where\n   someClassFunc :: (OtherClass a) => a -> Int
18:57:32 <nejucomo> ?
18:57:59 <nejucomo> Can I add those predicate restriction clauses to a function instance definition?
18:58:33 <mmorrow> i think you can, but i'm not sure what the consequences would be. i'd try it though and see.
18:58:46 <nejucomo> Alright.
18:58:56 <mmorrow> hmm, it may reject that also, i'm not sure.
18:59:05 <nejucomo> I'm glad you didn't ask "what are you trying to do" which is a common question in language channels.  ;-)
18:59:13 <nejucomo> (Because what I'm trying to do is wacky...)
18:59:18 <dmwit_> What are you trying to do?
18:59:20 <dmwit_> ;-)
18:59:30 <nejucomo> hehe...  Um...  Ok, here's my goal:
19:00:15 <nejucomo> I've defined a data type, T, and a class C with one function, asT, with type a -> T
19:00:26 <nejucomo> Now I have many instances of C.
19:00:43 <mmorrow> ok
19:00:44 <nejucomo> Finally, I want to make a function (whose type I haven't yet figured out how to express...)
19:01:07 <nejucomo> whose first argument is a function (whose type I can't yet express), and whose second argument is [T]
19:01:21 <nejucomo> And the return of my higher order function is Maybe T
19:01:58 <dmwit_> And the semantics of this function?
19:02:07 <nejucomo> And the return value is Just the value of converting all the T to the correct types for the target functions arguments, then applying the function to those arguments.
19:02:24 <nejucomo> Oh wait, sorry, class C also has "fromT :: T -> Maybe a"
19:02:27 <dmwit_> Have you seen Data.Dynamic?
19:02:37 <nejucomo> Yes, but I haven't determined how it would work yet.
19:03:14 <EvilTerran> nejucomo, why not work with values of T instead of values of instances of C?
19:03:15 <nejucomo> Wait, maybe I should go back and check it out.
19:03:30 <FunctorSalad> odd, now I have the inverse problem of the one I asked about some time ago. createProcess/waitForProcess works in ghci, but with ghc the child process just goes to sleep
19:04:26 <nejucomo> EvilTerran, I really want to say: You can call "magicApply f [dynamicThingies]" with great flexibility in what f is, such that the author of f never even knew about these types.
19:04:39 <EvilTerran> i see
19:04:49 <nejucomo> So, for example:  magicApply (+) [TInt 3, TInt 4]
19:04:57 <FunctorSalad> I'm writing a lazy bytestring to the child process's stdin via hPut, if that matters
19:04:58 <nejucomo> Which should result in: Just (TInt 7)
19:05:14 <mmorrow> nejucomo: one problem i see is that you can only work with /one/ instance of C if you want to do (e.g.) fmap fromT (ts :: [T])
19:05:30 <mmorrow> (since lists can't hold more than one type ...)
19:05:35 * nejucomo looks up fmap
19:05:45 * nejucomo is still a haskell acolyte.
19:06:04 <mmorrow> so to do what you're trying to do, you'd probably need to use an existential type something like
19:06:14 <mmorrow> fmap for lists === map
19:06:25 <mmorrow> , map (*2) [1..4]
19:06:27 <lunabot>  [2,4,6,8]
19:06:28 <mmorrow> , fmap (*2) [1..4]
19:06:30 <lunabot>  [2,4,6,8]
19:06:36 <mmorrow> , fmap (*2) (Just 42)
19:06:38 <lunabot>  Just 84
19:06:40 <EvilTerran> nejucomo, a thought: lists can have any number of elements at runtime, but functions take a fixed number of parameters
19:07:10 * dmwit_ points briefly at printf
19:07:14 <mmorrow> newtype AnyC = forall a. C a => AnyC a
19:07:20 <nejucomo> This is why I ran into the strange type class issue.
19:07:22 <EvilTerran> dmwit_, i mean at runtime
19:07:51 <mmorrow> but then you'd need to add a method to C that maps 'a' to a /single/ type for every type 'a' instance of C
19:08:02 <mmorrow> to be able to recover anything from an AnyC
19:08:07 <nejucomo> I tried to express: "There are two instances of CrazyClass: one for all instances of C and one for (a -> b) where a and b are each instances of C.
19:08:53 <nejucomo> No, wait, I've confused myself...  Lemme look up the code.
19:08:56 <mmorrow> i think that's either not straightforward or impossible, i'm not sure which
19:09:01 <dolio> That's a losing battle.
19:09:08 <dolio> Type classes aren't designed to do that.
19:10:05 <nejucomo> Actually it seemed like it might work if I defined explicit instances for CrazyClass instead of relying on my "translation class" C.
19:10:16 <nejucomo> I'll try that for a few types and see if I'm crazy or just instane.
19:10:20 <nejucomo> s/instane/insane/
19:10:44 <mmorrow> yeah, that should work i think
19:11:28 <mmorrow> the "losing battle" is do instance CrazyClass <every-type-other-than-<insert-type>> where ...
19:11:39 <mmorrow> *is _trying to_ do ...
19:12:21 <mmorrow> (or something similar to that)
19:12:32 <nejucomo> I'm still not quite sure why something like that doesn't work.
19:12:52 <mmorrow> because type classes weren't designed to be able to handle that
19:12:59 <mmorrow> so they can't
19:13:02 <nejucomo> I think it's because the type checker cannot represent: "there can never be an instance of C for (a -> b)"
19:13:02 <mmorrow> :(
19:13:17 <nejucomo> (For any a and b.)
19:13:39 * nejucomo still isn't sure what "forall" or "*" mean in type and/or predicate annotations mean.
19:14:56 <bd_> * is the kind of a type (where kinds are types of types)
19:15:03 <mmorrow> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#existential-quantification
19:15:11 <bd_> so (* -> *) is a type function, taking a type and returning a type. eg, IO, or Maybe.
19:15:35 <ben_h> completely off topic but this made my day: http://www.27bslash6.com/overdue.html
19:16:10 <mmorrow> ben_h: hehe
19:16:38 <lambdabot> Title: I'll spend the money on drugs instead
19:16:38 <lambdabot> Title: 8.4.�Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
19:16:59 <EvilTerran> http://okmij.org/ftp/Haskell/typecast.html#is-function-type
19:19:57 <lambdabot> Title: Type improvement constraint
19:23:16 <paczesiowa> are type families more powerful than fundeps?
19:27:12 <roconnor> cabal-install++
19:29:12 <Cale> paczesiowa: My understanding is that generally they are not.
19:31:49 <EvilTerran> paczesiowa, iirc, neither contains the other
19:32:03 <mmorrow> well, type families are independent of classes of course
19:32:15 <mmorrow> so can be used anywhere
19:32:24 <Cale> mmorrow: hm?
19:32:42 <mmorrow> type family Foo a (b :: (* -> *) -> *)
19:32:49 <mmorrow> instance Foo ...
19:33:09 <EvilTerran> mmorrow, many uses of type families with no classes can be represented as a MPTC with no methods, thought
19:33:13 <EvilTerran> *though
19:33:16 <Cale> I don't understand what you mean about "used anywhere"?
19:33:21 <mmorrow> foo :: (Foo a b ~ Int) -> ....
19:33:34 <EvilTerran> mmorrow, that should be =>, not ->
19:33:46 <mmorrow> what i meant is "type families don't require the class mechanism"
19:33:56 <mmorrow> yeah, s/->/=>/
19:34:13 <mmorrow> whereas fundeps are tied to the class mechanism
19:34:55 <mmorrow> i'm not claiming this adds or detracts anything though, just that it is the case
19:35:14 <EvilTerran> i'd consider your example analagous to
19:35:28 <mmorrow> i read an interesting comment relating fundeps to type families in a particular case
19:35:30 * mmorrow finds it
19:35:44 <Cale> It seems to me that there ought to be a translation from TFs without equality predicates to FDs which is pretty simple.
19:35:46 <EvilTerran> class Foo a (b :: (* -> *) -> *) fooAB | a b -> fooAB
19:35:48 <dolio> I thought one of the early type families papers said they could do everything fundeps can do, with sufficiently ugly encodings. But someone here recently said they recanted that.
19:36:01 <EvilTerran> and then "foo :: Foo a b Int => ..."
19:36:01 <dolio> But I haven't seen an example fundep that can't be done.
19:37:38 <dolio> And I seem to recall them saying back in the day that there were things type families could do that fundeps can't, but I think the only example I ever saw was "you can use families without classes", and I'm not sure that's a significant distinction.
19:37:54 <Cale> The real reason that they're doing the type families stuff, from what I understand, is that while they are more restrictive, the interactions of type families with GADTs seems easier to comprehend.
19:38:30 <dolio> Well, they do interact, at least. :)
19:39:04 <mmorrow> the implem for type families also is much more straightforward and error prone that the fundeps one as well
19:39:24 <mmorrow> (or so this paper says http://research.microsoft.com/~simonpj/papers/assoc-types/ifl2007.pdf)
19:39:27 <lambdabot> Title: Towards Open Type Functions for Haskell, http://tinyurl.com/2q9hfq
19:39:36 <mmorrow> this is the comment i was thinking of:
19:39:39 <dolio> I've never studied fundeps in depth, but I get the impression that the semantics were never very well defined, whereas type families might be better in that area.
19:39:42 <mmorrow>     In general, we can replace an n-ary type function with an (n + 1)-ary type
19:39:42 <mmorrow> class, with a functional dependency from the n first arguments to the last one.
19:40:42 <mmorrow> pg 15 gives "3 possible reasons for preffering type functions"
19:41:02 <roconnor> @hoogle random
19:41:03 <lambdabot> package random
19:41:03 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
19:41:03 <lambdabot> module System.Random
19:41:09 <mmorrow> 2 is: Type functions have their uses outside of type classes. Similar encodings with functional dependencies are rather bloated.
19:41:09 <Cale> http://video.google.com/videoplay?docid=-4399280499170944001
19:41:10 <lambdabot> Title: Mark Jones: Language and Program Design for Functional Dependencies
19:41:32 <mmorrow> and 3: While functional dependencies have been around for quite a while now, it seems type checking for them is still rather ill-understood. In contrast, our
19:41:32 <mmorrow> prototype implementation of type functions type checks has no problems with GHC’s open bugs related to functional dependencies.
19:41:57 <mmorrow> that's what sold me
19:42:10 <mmorrow> (the combo of both of those)
19:42:21 <roconnor> @hoogle randomGen
19:42:21 <lambdabot> System.Random class RandomGen g
19:42:31 <Cale> (annoyingly, the sound on that video quickly goes out of sync, and has rough spots)
19:42:32 <roconnor> @src RandomGen
19:42:32 <lambdabot> class RandomGen g where
19:42:32 <lambdabot>    next     :: g -> (Int, g)
19:42:32 <lambdabot>    split    :: g -> (g, g)
19:42:32 <lambdabot>    genRange :: g -> (Int,Int)
19:43:09 <roconnor> @hoogle StdGen
19:43:09 <lambdabot> System.Random data StdGen
19:43:09 <lambdabot> System.Random getStdGen :: IO StdGen
19:43:09 <lambdabot> System.Random mkStdGen :: Int -> StdGen
19:43:09 <mmorrow> oops, i meant:
19:43:15 <mmorrow> the implem for type families also is much more straightforward and LESS error prone that the fundeps one as well
19:44:41 <dolio> Of course, if they ever get total type families done, that will do something that fundeps don't do well, I think.
19:44:51 <mmorrow> totally.
19:45:51 <mmorrow> dolio: i remember wanting total families came up a while ago in some paste you (or i?) made. do you remember what that was about?
19:45:53 <u_quark> I get a "Could not find module `Data.Data': it is a member of package base, which is hidden" while compiling haskell-src-exts
19:46:10 <mmorrow> u_quark: add "syb" to the build-depends:
19:46:16 <mmorrow> (in the .cabal file)
19:46:20 <dolio> mmorrow: Type-level multiplication, I think.
19:46:36 <mmorrow> ohh yeah, exactly.
19:46:47 <mmorrow> err, i think that was it..
19:47:33 <dolio> Technically, type families can do some stuff that require undecidable instances for classes/fundeps, which is nice.
19:47:54 * lispy needs to learn about type fams
19:48:38 * lispy also wants to explore Oleg's comment about doing dependent typing with TH
19:49:20 <dolio> Heh.
19:49:25 <mmorrow> lispy: yeah, TH has some interesting possible uses
19:49:28 <dmwit_> http://nattermorphisms.blogspot.com/2008/10/2-minute-intro-to-associated-types-type.html
19:49:30 <lambdabot> Title: Nattermorphisms: 2 Minute intro to Associated Types / Type Families, http://tinyurl.com/6gcwyx
19:49:48 <dolio> Maybe you can translate that into some dependent typing with C++.
19:50:04 <lispy> dmwit_: 2 minutes, do you have something shorter that I have time for?? ;)
19:50:23 <u_quark> mmorrow: the same... and I have syb in my packages I think
19:50:33 <mmorrow> , $(let lookDependentTypes n = tupE (fmap lift . replicate n $ 0) in lookDependentTypes 12)
19:50:34 <lunabot>  luna: Ambiguous type variable `a' in the constraints:
19:50:36 <mmorrow> heh
19:50:43 <mmorrow> , $(let lookDependentTypes n = tupE (fmap lift . replicate n $ (0::Int)) in lookDependentTypes 12)
19:50:46 <lunabot>  (0,0,0,0,0,0,0,0,0,0,0,0)
19:51:12 <mmorrow> "kinda"
19:51:48 <mmorrow> u_quark: one sec, i just built it yesterday. i'll see what i had to change in the .cabal..
19:52:11 <dolio> It's depending typing with a very hard divide between compile time and run time values.
19:52:27 <dolio> But then, I suppose that's all you get with Dependent ML.
19:52:56 <roconnor> > showHex 1768970355 ""
19:52:57 <lambdabot>   "69705873"
19:54:28 <mmorrow> u_quark: the darcs version just built without errors for me on ghc-6.10.1
19:54:29 <mmorrow> darcs get http://code.haskell.org/HSP/haskell-src-exts
19:54:30 <lambdabot> Title: Index of /HSP/haskell-src-exts
19:54:48 <mmorrow> which ghc and haskell-src-exts version are you using/trying?
19:55:20 <mmorrow> dolio: are you refering to "MetaML"?
19:56:00 <dolio> No. DML.
19:56:09 <mmorrow> because i've read the crucial distinction between that (MetaML) and TH is that in MetaML the expression rep is typed, so you still can't write printf with it
19:56:10 <mmorrow> ah
19:56:20 <dolio> Apparently it got absorbed by ATS.
19:56:22 <mmorrow> i've never heard of DML. i've gotta check it out
19:56:25 <mmorrow> ah
19:56:57 <u_quark> ghc 6.10.1 and haskell-src-exts from hackage (0.3.9) - I will try the darcs repo
19:58:42 <mmorrow> (to clarify: the MetaML exp rep is typed in the sense that a meta expression has type "Exp t", where "t" is the type of the expression it represents, rather than an arbitrary type of the programmers chossing a la GADTs or something)
19:59:45 <dolio> Huh.
20:00:01 <dolio> Well, DML was a kind of restricted dependent type system over ML.
20:00:25 <mmorrow> "Huh" to which part? the "arbitrary ... a la GADTs .." or the "\"Exp t\" where t"?
20:00:26 <dolio> It may have been limited to, say, integers.
20:00:58 <dolio> I think the idea was that it was erasible to regular ML, but you could do all the dependent type checking beforehand to get the extra guarantees.
20:00:59 <mmorrow> (i'm talking about MetaML also, in case there was some confusion)
20:01:17 <mmorrow> i don't know anything about DML (yet)
20:01:18 <mofmog1> what ht eheck happened there
20:01:40 <Cale> mofmog1: what?
20:01:57 <dolio> net split.
20:02:08 <mmorrow> mofmog1: just split as well
20:02:16 <mmorrow> *mofmog1 just split as well
20:02:21 <Cale> he's not here anymore...
20:02:26 <dolio> mmorrow: MetaML sounds more like a template haskell kind if thing?
20:02:34 <mmorrow> dolio: exactly
20:03:16 <u_quark> mmorrow: same thing with darcs version (0.3.8) ...
20:03:22 <dolio> Yeah, that's not what DML is like.
20:03:24 <mmorrow> i don't think it has very much to do with DML
20:03:38 <mmorrow> yeah
20:03:51 <u_quark> something i not right with the base package
20:03:54 <dolio> DML is like... you can write the type of vectors indexed by their length and such.
20:04:08 <mmorrow> u_quark: weird. can you hpaste the output of runhaskell Setup.lhs configure && runhaskell Setup.lhs build ?
20:04:28 <mmorrow> dolio: cool
20:04:28 <dolio> (Which you can technically do in GHC, too, but whatever. :))
20:04:39 <mmorrow> "technically"
20:05:34 <dolio> Well, you have to work up a bunch of type-level natural stuff.
20:05:53 <dolio> Instead of just having types depend on values.
20:06:28 <mmorrow> i've totally gotta suck it up and figure out how to cabalify cayenne.
20:07:01 <gwern> mmorrow: is its build process so weird?
20:07:29 <mmorrow> gwern: ooh, perfect person to chime in. ok, so here's the trouble i'm having (this'll take a sec to write):
20:07:35 <gwern> oh dear
20:07:38 <mmorrow> heh
20:08:54 <u_quark> mmorrow: it works! The problem was because i used cabal install
20:12:18 <mmorrow> so the build process is: (1) compile the compiler. (2) use the just-built-compiler to build it's libs (written in cayenne). (3) then install everything in a location that the cayenne Main knows about.     so, the part i can't figure out is how to install all the libs/support files since these are contained in a /directory tree/ rather than them being just a list of files that i can have cabal install for me. so i need some way of maki
20:12:18 <mmorrow> ng directories/etc. of course, i could do this manually from Setup.lhs, but i'm not sure how to figure out the eventual install dir from inside Setup.lhs (i can figure this out from inside cayenne Main using Cayenne_paths).
20:12:27 <mmorrow> u_quark: awesome!
20:13:25 <mmorrow> i think i'm just going to scrap everything, and start over using Distribution.Make and the original cayenne Makefiles.
20:13:50 <mmorrow> *BUT* if i do that, then it'll install in a location that cabal doesn't know about
20:13:54 <gwern> mmorrow: hm. offhand, it looks like I would make the compiler a package; make the lib depend on the compiler; although I don't follow your directory tree problem
20:13:56 <roconnor> > showHex 1768970355 ""
20:13:58 <lambdabot>   "69705873"
20:13:58 <sjanssen> mmorrow: use Paths_programname.getDataDir?
20:14:14 <mmorrow> sjanssen: but i need that info in Setup.lhs
20:14:18 <roconnor> > fromIntegral (0x89705873) :: Int
20:14:19 <lambdabot>   2305841267
20:14:23 <gwern> sjanssen: I was thinking that, but he said the makefiles would mess things up I thnk
20:14:24 <mmorrow> gwern: that's exactly what i did
20:14:53 <roconnor> > fromIntegral (0xFF705873) :: Int
20:14:54 <lambdabot>   4285552755
20:14:57 <mmorrow> but the compiler binary needs to know the default location of all the libs (i'm gonna put them in dataDir)
20:15:09 <roconnor> oh
20:15:15 <roconnor> lambdabot is 64 bit
20:15:20 <sjanssen> mmorrow: the compiler binary can get those easily with the Paths module
20:15:21 <roconnor> > fromIntegral (0x89705873) :: Int32
20:15:23 <lambdabot>   -1989126029
20:15:35 <sjanssen> mmorrow: the tricky part is accessing that informating from Setup.hs
20:15:40 <mmorrow> yes!
20:15:50 <mmorrow> and i need that because
20:16:16 <roconnor> > fromIntegral (0x89705873) :: Int32 `rotate` 32
20:16:17 <lambdabot>   Only unit numeric type pattern is valid
20:16:18 <sjanssen> datadir    = "/home/sjanssen/share/xmonad-0.8" -- is a sample string, shouldn't be too difficult to yank the path out of the file?
20:16:24 <roconnor> > (fromIntegral (0x89705873) :: Int32) `rotate` 32
20:16:26 <lambdabot>   -1989126029
20:16:27 <mmorrow> i need to do the "copy" stage via a hook since i need to create the correct directory tree structure for the libs that the compiler expects
20:16:38 <roconnor> > (fromIntegral (0x89705873) :: Int32) `rotate` 16
20:16:40 <lambdabot>   1483966832
20:17:01 <sjanssen> mmorrow: I would hope that Cabal gives a programmatic way to get datadir
20:17:28 <mmorrow> me too. i'm sure it's there somewhere (i hope), but i can't seem to find it.
20:17:29 <dons> it does.
20:17:35 <dons> i hope...
20:17:36 <mmorrow> dons: excellent
20:17:37 <mmorrow> heh
20:17:50 <dons> bindir, libdir, datadir, libexecdir :: FilePath
20:17:50 <dons> bindir     = "/home/dons/.cabal/bin"
20:17:50 <dons> libdir     = "/home/dons/.cabal/lib/xmonad-0.8/ghc-6.10.0.20081007"
20:17:50 <dons> datadir    = "/home/dons/.cabal/share/xmonad-0.8"
20:17:50 <dons> libexecdir = "/home/dons/.cabal/libexec"
20:17:55 <dons> module Paths_xmonad (
20:17:58 <sjanssen> dons: from Setup.hs
20:18:01 <mmorrow> totally. but c
20:18:02 <mmorrow> yeah
20:18:05 <mmorrow> from Setup.hs
20:18:14 <mmorrow> tis the crux
20:18:17 <dons> dcoutts_: ^^
20:18:29 <roconnor> @type foldr
20:18:30 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:18:45 <dons> pretty type
20:19:08 <roconnor> > bits (fromIntegral (0x89705873) :: Int32)
20:19:09 <lambdabot>   Not in scope: `bits'
20:19:16 <roconnor> @hoogle bits
20:19:17 <lambdabot> module Data.Bits
20:19:17 <lambdabot> Data.Bits class Num a => Bits a
20:19:17 <lambdabot> package bitset
20:19:40 <sjanssen> unwords . drop 2 . words . head . filter (isPrefixOf "datadir") . lines -- munge the text, mmorrow?
20:19:50 <roconnor> > bitSize (fromIntegral (0x89705873) :: Int32)
20:19:52 <lambdabot>   32
20:19:56 <roconnor> > bitSize (fromIntegral (0x89705873))
20:19:57 <lambdabot>   Add a type signature
20:20:04 <roconnor> > bitSize 0x89705873
20:20:05 <lambdabot>   Add a type signature
20:20:17 <roconnor> > bitSize (0x89705873 :: Integer)
20:20:19 <lambdabot>   * Exception: Data.Bits.bitSize(Integer)
20:20:24 <roconnor> > bitSize (0x89705873 :: Int)
20:20:25 <lambdabot>   64
20:20:32 <mmorrow> sjanssen: ooh, that may work. (so you're saying once the copy stage comes around, Cayenne_paths.hs will exist in dist/... ?)
20:21:00 <sjanssen> mmorrow: I believe it is generated in the build step
20:21:00 <mmorrow> if that's true, then that's works for me.
20:21:06 <mmorrow> nice.
20:21:10 <sjanssen> mmorrow: but there really must be a better way
20:21:21 <mmorrow> totally.
20:22:47 <mmorrow> i asked dcoutts at one point about this, but at the time i wasn't able to phrase exactly what i needed correctly. so he didn't (nor did i) understand what i really meant.
20:25:06 <sjanssen> I don't really know Cabal, but is there a way to get an InstallDirs structure? http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Simple-InstallDirs.html#v%3Adatadir
20:25:07 <nolraiWest> is there a way to change b -> [(r,b)] into somthing that will pass the state for me I.e. in a state monad, but still preseve the list action?
20:25:09 <lambdabot> Title: Distribution.Simple.InstallDirs, http://tinyurl.com/5rzg7q
20:25:59 <Cale> nolraiWest: Perhaps you're thinking of the  StateT b []  monad.
20:26:23 <Cale> @unmtl StateT b [] r
20:26:24 <lambdabot> b -> [(r, b)]
20:26:49 <mmorrow> sjanssen: i was using happy.cabal as a model, since it needs to install some support files. so, apparently how this is done is you give cabal a list of the files you want installed, and it does it. /but/, there doesn't seem to be a way to install files /and/ directories, just a list of files
20:27:14 <mmorrow> (and i need to reproduce the expected libs directory tree exactly)
20:27:22 <sjanssen> mmorrow: I wonder if Cabal will automatically build the directory tree?
20:27:38 <mmorrow> but it only takes a [FilePath]
20:27:48 <mmorrow> ooh, i see. maybe..
20:27:55 <nolraiWest> I'm using a library function of that type,(b -> [(r,b)]) is there a way to change it to StateT b [] r?
20:28:00 <mmorrow> hmm, i didn't think of that.
20:28:08 <Cale> nolraiWest: You could apply the StateT data constructor.
20:28:16 <nolraiWest> ahh
20:28:38 <mmorrow> sjanssen: ok. so i'll try that first, and if it doesn't work will resort to parsing Cayenne_path.hs directly.
20:29:29 <Cale> > let select [] = []; select (x:xs) = (x,xs):[(y,x:ys) | (y,ys) <- select xs] in evalStateT (replicateM 3 (StateT select)) [1,2,3]
20:29:30 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
20:30:23 <Cale> nolraiWest: Which library function, btw?
20:31:00 <mmorrow> hmm, i can't remember but that [FilePath] may be refering to the /src/ filepaths rather than the /relative to the destination/ filepaths
20:31:21 <mmorrow> but whatever. worst case, i can parse Cayenne_paths.hs.
20:41:19 <mmorrow> ooh, i think i can get around parsing ..._paths by using TH in cayenne.hs and doing in some splice:  runIO (writeFile "ThisIsForSetupDotHs.txt" =<< getDataDir)
20:41:48 <mmorrow> (and use location :: Q Loc to put that written file somewhere convenient for Setup.hs)
20:42:13 <lispy> mmorrow: but is there a problem you don't use TH for :)
20:42:23 <mmorrow> nope. ;)
20:42:31 <mmorrow> hehe
20:44:41 <nolraiWest> @hoogle [a] -> [([a],[a])]
20:45:09 <nicky> Hi
20:45:21 <dibblego> hello nicky
20:45:23 <nolraiWest> @t 1
20:45:41 <nicky> What is the difference between bah = func1 . func2  -- and -- bah = func1 func2 ?
20:45:58 <dibblego> bah = func1 . func2 -- function composition
20:46:03 <dibblego> bah = func1 func2 -- function application
20:46:16 <dibblego> func1 . func2 is the same as \x -> func1 (func2 x)
20:46:23 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
20:46:23 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
20:46:23 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
20:46:23 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
20:46:28 <dibblego> func1 func2 just passes func2 as an argument to func1
20:47:33 <nicky> dibblego: hmm, ok.  Can't quite think of a practical use
20:47:43 <dibblego> nicky, of what exactly?
20:47:57 <nicky> using a function composition
20:49:13 <mmorrow> main = print . length . lines =<< getContents
20:49:53 <mmorrow> main = putStr . unlines . zipWith (\n l -> show n ++ ":" ++ l) [0..]  . lines =<< getContents
20:49:53 <dons> heh. nicky :)
20:50:05 <dons> in a functional language, function composition is the main way to get things done.
20:50:23 <dons> the same way that | is used to build useful shell programs, piecewise
20:51:23 <u_quark> now lambdabot fails again Plugin/Compose.hs:14:21: Module `GHC.IOBase' does not export `Exception(NoMethodError)'
20:52:02 <dons> base < 4
20:53:15 <u_quark> lets see
20:56:04 <adityam> @pl (rows r, cols r)
20:56:05 <lambdabot> (rows r, cols r)
20:56:17 <adityam> @pl size r  = (rows r, cols r)
20:56:17 <lambdabot> size = liftM2 (,) rows cols
20:56:30 <u_quark> nop ... same story again
20:58:38 <adityam> @pl check a = all (map f a)
20:58:38 <lambdabot> check = all . map f
20:58:54 <mmorrow> u_quark: just comment out that import in the offending source file
20:59:03 <u_quark> lol
20:59:15 <mmorrow> (not "import GHC.IOBase", but the `Exception(NoMethodError)')
20:59:20 <mmorrow> i'm dead serious :)
21:01:30 <mmorrow> (and repeat commenting stuff out until it works)
21:02:14 <u_quark> i always thought lines of code were important ... mmorrow you myth buster!
21:02:14 <mmorrow> also, this is my current hack to be able to use base-4 with packages that import Control.Exception (*only* do this if you're using base-4):
21:02:32 <mmorrow> for i in `find . | grep -vE "_darcs" | grep -E "\.hs"`;do cat $i | sed -r 's/Control.Exception/Control.OldException/g' > a; mv -f a $i; done
21:03:00 <mmorrow> of course i'm not responsible if you computer explodes, etc from that :)
21:03:45 <mmorrow> someone told me there's a sed switch to edit the files in-place instead of using the temp a file, but either way'll work
21:03:56 <dmwit_> undefined behavior, nose fairies, etc.
21:04:38 <dmwit_> mmorrow: There's also "sponge".
21:04:46 <mmorrow> bob squarepant?
21:04:48 <mmorrow> s
21:04:51 <dmwit_> Nope.
21:04:57 <mmorrow> dangit!
21:05:01 <mmorrow> what is sponge?
21:05:06 <dmwit_> It's a handy tool that takes care of making and destroying temp files for you in just such an occasion.
21:05:16 <dmwit_> ?go moreutils
21:05:19 <mmorrow> oh nice. i'll have to check it out
21:05:27 <lambdabot> http://joey.kitenet.net/code/moreutils/
21:05:27 <lambdabot> Title: moreutils
21:05:38 <mmorrow> @botsnack
21:05:38 <lambdabot> :)
21:05:50 <mmorrow> @dmwitsnack
21:05:50 <lambdabot> Unknown command, try @list
21:05:53 <mmorrow> :)
21:05:54 <dmwit_> =)
21:11:11 <u_quark> yeaaaaa it worked ! (at least it compiled) tnx mmorrow
21:11:58 <mmorrow> u_quark: woohoo!
21:12:54 <nolraiWest> > let f = do {s <- get; just rest <- stripPrefix "aa" s; set rest;} in (runState f "aab", runState f "b")
21:12:55 <lambdabot>   <no location info>: Parse error in pattern
21:13:13 <nolraiWest> hmm
21:13:24 <mmorrow> just
21:13:30 <nolraiWest> > let f = do {s <- get; Just rest <- stripPrefix "aa" s; set rest;} in (runState f "aab", runState f "b")
21:13:31 <lambdabot>   Not in scope: `set'
21:13:36 <mmorrow> heh
21:13:51 <mmorrow> too much monadLib for you?
21:14:00 <nolraiWest> doh
21:14:02 <nolraiWest> yes
21:14:04 <mmorrow> hehe
21:14:15 <nolraiWest> > let f = do {s <- get; Just rest <- stripPrefix "aa" s; put rest;} in (runState f "aab", runState f "b")
21:14:16 <lambdabot>   Couldn't match expected type `[Char]'
21:14:52 <nolraiWest> > let f = do {s <- get; Just rest <- stripPrefix "aa" s; put rest;} in f
21:14:53 <lambdabot>   Couldn't match expected type `[Char]'
21:14:56 <mmorrow> hmm
21:15:10 <mmorrow> @type stripPrefix
21:15:11 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
21:15:36 <mmorrow> oh
21:15:55 <mmorrow> > let f = do {s <- get; let Just rest = stripPrefix "aa" s; put rest;} in (runState f "aab", runState f "b")
21:15:56 <lambdabot>   <no location info>: parse error on input `;'
21:16:17 <mmorrow> > let f = do {s <- get; let Just rest = stripPrefix "aa" s; put rest} in (runState f "aab", runState f "b")
21:16:18 <lambdabot>   <no location info>: parse error on input `}'
21:16:38 <mmorrow> > let f = (do s <- get; let Just rest = stripPrefix "aa" s; put rest) in (runState f "aab", runState f "b")
21:16:39 <lambdabot>   <no location info>: parse error on input `)'
21:16:42 <mmorrow> grerrr
21:17:13 <nolraiWest> Its hard to remember the not light syntax sometimes.
21:17:44 <mmorrow> yeah
21:17:53 * heatsink thinks it would suit lambdabot's personality to begin making sarcastic remarks on the third consecutive type error.
21:18:08 <heatsink> or parse error.
21:18:47 <mmorrow> "Prelude.NiceTryIdiot:):)"
21:19:09 <dmwit_> do { s <- get; let { Just rest = stripPrefix "aa" s }; put rest }
21:19:09 <mmorrow> "Prelude.OooohAlmostJUStKidding!:):)"
21:19:25 <mmorrow> ohhh
21:19:39 <mmorrow> once you start the no-layout, you can't stop
21:19:39 <dmwit_> You can probably omit the curly braces from the do (but not the let).
21:20:04 <dmwit_> mmorrow: right
21:20:10 <mmorrow> good to know
21:20:37 <heatsink> Are malloc and free combatible with libc malloc and free?
21:20:43 <nolraiWest> > let f = do {s <- get; let {Just rest = stripPrefix "aa" s}; set rest;} in (runState f "aab", runState f "b")
21:20:44 <lambdabot>   Not in scope: `set'
21:20:51 <nolraiWest> > let f = do {s <- get; let {Just rest = stripPrefix "aa" s}; put rest;} in (runState f "aab", runState f "b")
21:20:52 <lambdabot>   (((),"b"),((),"* Exception: /tmp/229847896312535905:71:59-88: Irrefutable p...
21:21:20 <nolraiWest> hm I think thats what i want.
21:23:20 <mmorrow> > let f = do {s <- get; let {rest = maybe [] id $ stripPrefix "aa" s}; put rest;} in (runState f "aab", runState f "b")
21:23:21 <lambdabot>   (((),"b"),((),""))
21:26:22 <nolraiWest> > let f = do {s <- get; Just rest = fromMaybe (fail "failing") $ stripPrefix "aa" s}; put rest;} in (runState f "aab", runState f "b")
21:26:23 <lambdabot>   <no location info>: parse error on input `='
21:26:28 <mmorrow> heatsink: like as in can you call free in C on a mallocBytes malloc'ed ptr?
21:26:38 <heatsink> mmorrow, yeah
21:26:39 <mmorrow> (i dunno, but am curious what you mean)
21:26:47 <nolraiWest> > let f = do {s <- get; Just rest <- fromMaybe (fail "failing") $ stripPrefix "aa" s}; put rest;} in (runState f "aab", runState f "b")
21:26:47 <lambdabot>   <no location info>:
21:26:47 <lambdabot>      The last statement in a 'do' construct must be an ...
21:26:52 <heatsink> That's what I'm wondering.
21:27:05 <nolraiWest> > let f = do {s <- get; Just rest <- fromMaybe (fail "failing") $ stripPrefix "aa" s; put rest;} in (runState f "aab", runState f "b")
21:27:06 <lambdabot>   Couldn't match expected type `Char' against inferred type `Maybe a'
21:27:18 <mmorrow> heatsink: i guess you could look at the code for mallocBytes/etc, but i'd probably just wrap malloc/free via the FFI
21:27:21 <mmorrow> to be sure
21:27:26 <nolraiWest> > let f = do {s <- get; rest <- fromMaybe (fail "failing") $ stripPrefix "aa" s; put rest;} in (runState f "aab", runState f "b")
21:27:27 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
21:27:47 <nolraiWest> > let f = do {s <- get; rest <- maybe (fail "failing") return $ stripPrefix "aa" s; put rest;} in (runState f "aab", runState f "b")
21:27:48 <lambdabot>   (((),"b"),((),"* Exception: failing
21:28:06 <nolraiWest> ok cool
21:28:33 <heatsink> mmorrow: oh.  Good idea.
21:29:10 <mmorrow> i just recently wrapped read,write,open,close if those would be helpful too :
21:29:14 <mmorrow> @hackage c-io
21:29:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/c-io
21:31:01 <heatsink> Hmm.  What do you use low-level IO for?
21:31:38 <dmwit_> For shitting, shilly!
21:32:15 <nolraiWest> "lift mzero" is "mzero" right?
21:32:33 <dmwit_> Not necessarily.
21:32:34 <mmorrow> there's this NewerCGI.hs and FastCGI.hs on oleg's site that uses read/write like this, and i wrapped them after seeing that and then realizing no direct wrappers for read/write exist (suprisingly)
21:32:47 <dmwit_> nolraiWest: Your transformer might not even be an instance of MonadPlus.
21:33:19 <mmorrow> @go oleg haskell NewerCGI.hs
21:33:21 <nolraiWest> err. hmm then I guess lift mzero it is.
21:33:22 <lambdabot> http://okmij.org/ftp/Haskell/NewerCGI.hs
21:33:33 <shapr> @seen roconnor
21:33:33 <lambdabot> roconnor is in #haskell. I don't know when roconnor last spoke.
21:33:34 <mmorrow> @go oleg haskell FastCGI.hs
21:33:35 <shapr> bah
21:33:36 <lambdabot> http://okmij.org/ftp/Haskell/
21:33:36 <lambdabot> Title: Haskell Programming: Miscellanea
21:34:41 <roconnor> @get-shapr
21:34:42 <lambdabot> shapr!!
21:35:49 <mmorrow> heatsink: well, there's stuff in System.Posix.IO, but they all use String...
21:36:08 <mmorrow> and
21:36:19 <mmorrow> newtype Fd = Fd Int32
21:36:43 <pumpkin_> how does newtype differ from data?
21:36:56 <mmorrow> newtype doesn't exist at runtime
21:36:58 <shapr> roconnor: Hey, I saw your name in a recent issue of ... something...
21:37:15 <roconnor> TPHOLs?
21:37:35 <mmorrow> err, i think it's actually  Fd = Fd CInt
21:37:45 <shapr> roconnor: It was an online issue of something dealing with theorem provers.
21:37:46 <heatsink> String is something around which working is definitely worth.
21:38:00 <dmwit_> pumpkin_: newtype may only have one constructor
21:38:01 <mmorrow> indeedy
21:38:02 <roconnor> shapr: was it written in Dutch?
21:38:12 <machrider> what's the simplest way to create a list of integers 1..1000?
21:38:20 <mauke> > [1 .. 1000]
21:38:21 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:38:29 <shapr> Nah, it was a special issue of something (ACM?) that dealt entirely with proof assistants / automated theorem provers.
21:38:33 <machrider> haha, thanks mauke
21:38:33 <dmwit_> pumpkin_: This means that the compiler can strip this constructor at runtime; however, stripping the constructor means that newtypes deal with bottom differently than data does.
21:38:44 <pumpkin_> ah
21:39:02 <mmorrow> oh yeah, that too.
21:39:34 <shapr> roconnor: Now I can't remember what it was... they mentioned trying to find the largest number of proofs done in various provers.
21:39:36 <dmwit_> pumpkin_: Try newtype A = A Bool; data B = B Bool.  Then in ghci:
21:39:51 <shapr> roconnor: In any case, one of the proofs you did was mentioned.
21:40:07 <roconnor> oh
21:40:14 <shapr> roconnor: Does this come as a complete surprise to you?
21:40:15 <roconnor> I haven't read whatever it was
21:40:23 <dmwit_> hum
21:40:27 <roconnor> No.  I wrote something for Freek
21:40:32 * dmwit_ tries to think of a way to expose it
21:40:33 <dmwit_> ah!
21:40:35 <mauke> A undefined `seq` ()
21:40:36 <roconnor> that sounds something like what you are saying
21:40:36 <mauke> B undefined `seq` ()
21:40:39 <dmwit_> (A undefined) `seq` 3
21:40:40 <dmwit_> yeah
21:40:46 <shapr> roconnor: Nah, this was ACM or something equally spiffy.
21:40:50 <mauke> case undefined of A _ -> ()
21:40:52 <mauke> case undefined of B _ -> ()
21:40:54 <mmorrow> dmwit_: newtype A = A !Bool
21:41:06 <dmwit_> mauke: Those won't behave differently, will they?
21:41:07 <mmorrow> data B = B !Bool
21:41:09 <dmwit_> ah
21:41:11 <mauke> TIAS
21:41:12 <dmwit_> They will, huh.
21:41:20 <roconnor> shapr: I mean Freek Wiedijk would be one of the authors of whatever article you read
21:41:32 <dmwit_> In that one, the newtype behaves better than the data. =P
21:41:33 <shapr> oh
21:42:05 <dmwit_> mmorrow: Still different, check out mauke's second example.
21:42:09 <mmorrow> hmm
21:42:09 <mmorrow> ah
21:42:25 <dmwit_> The compiler gets to assume the newtype has the correct constructor. =)
21:42:37 <mauke> A simply doesn't exist at runtime
21:42:49 <mauke> so A undefined `seq` ... becomes undefined `seq` ...
21:43:00 <shapr> roconnor: If I discover it, I'll send you an url.
21:43:02 <mauke> and case undefined of A _ -> ... becomes case undefined of _ -> ...
21:43:11 <mmorrow> ahh
21:43:31 <dmwit_> newtype is too cute for its own good, I think.
21:46:03 <dons> virtual data1
21:46:25 <dons> guaranteed erasure is useful, imo
21:46:49 * mmorrow likes it too
21:46:51 <dmwit_> Yes.  It plays an important role.
21:47:31 <dons> it'd be cool to extend it to guarantee erasure of the 'virtual' data produced during stream fusion, for example
21:47:54 <dons> we turn code into data constructors, and rely on interesting optimisatoins like SpecConstr to turn them back into code
21:49:13 <dons> what would people find most useful from the haskell subreddit? http://www.reddit.com/r/haskell/
21:49:14 <lambdabot> Title: Haskell
21:49:24 <dons> anything new about haskell that turns up on the web?
22:40:56 <Taejo> @undo do {x <- x'; y' <- y; return (P x y)}
22:40:56 <lambdabot> x' >>= \ x -> y >>= \ y' -> return (P x y)
22:41:06 <Taejo> @undo do {x <- x'; y' <- y; return (P x' y')}
22:41:06 <lambdabot> x' >>= \ x -> y >>= \ y' -> return (P x' y')
22:41:15 <Taejo> @pl x' >>= \ x -> y >>= \ y' -> return (P x' y')
22:41:15 <lambdabot> x' >> P x' `fmap` y
22:41:40 <Taejo> @pl x' >>= \ x -> y >>= \ y' -> return (P x y)
22:41:40 <lambdabot> (y >>=) . const . return . flip P y =<< x'
22:41:58 <Taejo> ack
22:42:21 <Taejo> @undo do {x' <- x; y' <- y; return (P x y)}
22:42:21 <lambdabot> x >>= \ x' -> y >>= \ y' -> return (P x y)
22:42:28 <Taejo> @pl x >>= \ x' -> y >>= \ y' -> return (P x y)
22:42:29 <lambdabot> x >> (y >> return (P x y))
22:42:45 <Taejo> @pl x >>= \ x' -> y >>= \ y' -> return (P x' y')
22:42:45 <lambdabot> (`fmap` y) . P =<< x
22:47:11 <pumpkin_> oh my
22:48:47 <Beelsebob> Taejo: are you looking for P <$> x <*> y?
22:49:22 <Taejo> Beelsebob: I believe I am
22:50:07 <Taejo> Beelsebob: but I actually realised that my problem is more complicated than that, so I'm going to leave it unsolved for now, and just blog about what I've got :)
22:53:03 <Beelsebob> hf :)
23:07:30 <sandbox> is there a sort for lazy bytestring?
23:08:44 <lispy> ?hoogle sort
23:08:45 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
23:08:45 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
23:08:45 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
23:11:21 <sjanssen> sandbox: I don't think so
23:12:21 <pumpkin_> how does one sort something lazily?
23:12:36 <pumpkin_> with repeated order statistics? that doesn't sound much more efficient?
23:12:37 <cads__> hello
23:13:19 <Taejo> hi cads_
23:14:10 <cads__> hey I've got a question... what are some concurrency models that use neither shared memory and locking, nor software transactional memory?
23:14:31 <Taejo> cads_: message passing
23:14:38 <Axman6> @src [] (>)
23:14:39 <lambdabot> Source not found. Sorry.
23:14:42 <Axman6> rawr
23:14:50 <Taejo> @src [] compare
23:14:50 <lambdabot> Source not found. My pet ferret can type better than you!
23:15:18 <Axman6> ok, why is this True? [3,2,1] > [2,10,100]
23:15:30 <pumpkin_> lexicographic ordering?
23:15:34 <Taejo> Axman6: because 3 > 2
23:15:47 <Taejo> yes, the ordering is lexicographical
23:16:31 <Axman6> yes1 i get it now!
23:16:36 <Axman6> :)
23:17:46 <Axman6> that is quite funky, never knew you could do that
23:17:55 <Axman6> anyway, back to teaching my gf haskell :)
23:18:42 <BeelsebobWork> Axman6: it's mostly to facilitate being able to order strings
23:18:53 <Axman6> yeah
23:18:54 <BeelsebobWork> > "jam" > "ham"
23:18:56 <lambdabot>   True
23:19:13 <BeelsebobWork> plus, there aren't many other ways to define it
23:19:39 <BeelsebobWork> the only other intuitive way I can think of doing it is compare = compare `on` sum
23:19:48 <BeelsebobWork> but that requires Num a
23:20:15 <lispy> > [3,2,1] > [2,10,100]
23:20:16 <lambdabot>   True
23:20:20 <lispy> huh
23:20:35 <pumpkin_> what's wrong?
23:22:32 <Taejo> lispy: why is that surprising?
23:22:38 <Axman6> lispy: 3 > 2, so it's true, like BeelsebobWork's example, "jam" > "ham" = True, "jam" > "Jon" = False
23:23:08 <Axman6> uh, jon
23:23:33 <ski> TraceFix> traceFix (\fib n -> if n < 2 then return n else liftM2 (+) (fib (n-1)) (fib (n-2))) 4
23:23:36 <ski> Node (4,3) [Node (3,2) [Node (2,1) [Node (1,1) [],Node (0,0) []],Node (1,1) []],Node (2,1) [Node (1,1) [],Node (0,0) []]]
23:23:41 <scook0> > "jam" > "Jon"
23:23:43 <lambdabot>   True
23:23:49 <scook0> :)
23:23:49 <ski> (any comments ?)
23:24:00 <lispy> > [3, undefined, 1] > [2, 10, 100]
23:24:02 <lambdabot>   True
23:24:32 <BeelsebobWork> > [2, undefined, 1] > [2,10,100]
23:24:34 <lambdabot>   * Exception: Prelude.undefined
23:24:39 <BeelsebobWork> > [1, undefined, 1] > [2,10,100]
23:24:40 <lambdabot>   False
23:25:03 <Taejo> is there a name for the function that you pass to a fold (iterator? folder?) and I don't mean "f" or "go"
23:25:30 <lispy> iteratee?
23:25:32 <ski> `phi' has been used for the argument to catamorphisms
23:25:42 <BeelsebobWork> Taejo: I'd be tempted to call it the accumulator -- but that is kinda reserved for other things
23:25:49 <lispy> reduction?
23:26:07 <ski> lispy : rather `reductor', then ?
23:26:24 <lispy> Reductor sounds like a comic book character
23:26:30 <ski> (:
23:26:31 <Taejo> Beelsebob: isn't the accumulator the other argument?
23:26:38 <BeelsebobWork> Taejo: that's the zero value
23:26:59 <Taejo> well, the zero value is the initial value of what I call the accumulator
23:27:01 <BeelsebobWork> actually, it never made sense to me to call a plain value (or anything in FP for that matter) an accumulator
23:27:06 <BeelsebobWork> it's a verb -- to accumulate
23:27:15 <BeelsebobWork> you don't do anything in FP
23:27:18 <Taejo> I believe the docs for foldl' agree with me
23:27:20 <BeelsebobWork> so why use verbs
23:27:26 <ski> the accumulator is the thread of states, each of which is a value
23:28:01 <BeelsebobWork> sounds like a very operational way of thinking about it
23:28:07 <cads__> Taejo, ah yeah... duh, even. I wonder why there is such effort being put into transactional memory. True it seems to be more space efficient than message passing, but doesn't MP scale better?
23:28:10 <Taejo> the docs for ByteString.foldl' say "'foldl\'' is like foldl, but strict in the accumulator. However, for ByteStrings, all left folds are strict in the accumulator. "
23:28:54 <ski> Taejo : yes .. however i wouldn't interpret that as the function argument being called `accumulator'
23:29:19 <Taejo> ski: I'm blogging about folds, so I need to name both these things
23:29:27 <Taejo> reductor is ok
23:30:07 <ski> (i would possibly expand "strict in the accumulator" as, "the given function is strict in that of its argument which is passed each accumulator state")
23:30:24 <ski> (s/argument/arguments/)
23:32:54 <lispy> so what do you call the f in unfolder?
23:33:00 <lispy> expander?
23:33:13 <lispy> :t unfolder
23:33:14 <lambdabot> Not in scope: `unfolder'
23:33:17 <lispy> :t unfoldr
23:33:18 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
23:33:26 <Taejo> lispy: builder?
23:33:30 <ski> maybe `generator'
23:33:36 <ski> or possibly that, yes
23:33:45 * ski isn't sure
23:34:02 <kosmikus> coalgebra ;)
23:34:56 <ski> yes .. but i take Taejo is after something more operationally-sounding
23:35:19 <Taejo> ski: it just needs a name
23:35:27 <Taejo> but which one is the coalgebra?
23:35:39 <kosmikus> the "b -> Maybe (a, b)"
23:35:48 <Taejo> and if you could explain why it is a coalgebra, that would be awesome
23:37:09 <lispy> sigfpe's blog is a good thing to turn to
23:37:55 <ski> (if we rewrite like `foldr  ::  (a -> r -> r) -> r -> ([a] -> r)  ~  ((a,r) -> r) -> r -> ([a] -> r)  ~  (Maybe (a,r) -> r) -> ([a] -> r)', then the `Maybe (a,r) -> r' is the algebra in `foldr' .. so in terms of the original, in `foldr cons nil xs', here `cons' and `nil' together form the algebra)
23:38:57 <kosmikus> in short: list can be seen as fixed points of a functor, and the list functor happens to be isomorphic to /\ x -> Maybe (a, x)
23:39:00 <ski> (you may insert a step `  ~  ((a,r) -> r,r) -> ([a] -> r)' before the last step, if you like)
23:39:18 <kosmikus> given a functor F, a function of type F r -> r is called algebra and a function of type r -> F r is called coalgebra
23:39:34 <Taejo> kosmikus, ski: ok
23:39:54 <ski> foldr :: Functor f => (f r -> r) -> (Fix f -> r)  -- really `cata'
23:40:01 <Taejo> kosmikus: how does that relate to algebras in the sense I know (i.e. \Omega-algebras)
23:40:10 <ski> unfoldr :: Functor f => (s -> f s) -> (s -> Fix f)  -- really `ana'
23:40:31 <ski> newtype Fix f = In {out :: f (Fix f)}
23:41:11 <Taejo> @ty (first f) . (second g)
23:41:12 <lambdabot> forall c b c1 d. (SimpleReflect.FromExpr c1, Show b, SimpleReflect.FromExpr c, Show d) => (d, b) -> (c, c1)
23:42:04 <ski> note how `(s -> f s) -> (s -> Fix f)' matches the type of `unfoldr'`(b -> Maybe (a, b)) -> (b -> [a])', if you say `b = s',`f s = Maybe (a,s)',`Fix f ~= [a]'
23:42:05 <kosmikus> Taejo: I'm not quite sure what an \Omega-algebra is. \Omega being a signature? As in "universal algebra"? Or something else?
23:42:48 <Taejo> kosmikus: ya \Omega is the signature. I believe it is "as in universal algebra"
23:42:50 <ushdf> i made the cross to xmonad
23:42:53 <ushdf> i like it :D
23:43:27 <ski> (naming concepts using a certain parameter name is silly ..)
23:43:38 <kosmikus> Taejo: that is indeed quite related.
23:45:12 <kosmikus> Taejo: for that, I still find "Generic Programming - An Introduction" by Backhouse, Jansson, Jeuring, and Meertens a good reference
23:45:15 <ski> Taejo : in the case of the algebra `reductor :: Maybe (a, r) -> r', as i said above, this is the same as two operations `cons :: a -> r -> r',`nil :: r' .. these are the operations in your signature, where `r' is the carrier .. there are no laws, however
23:45:42 <ski> (Taejo : hence this has been called "anarchic (co)algebras")
23:46:58 <ski> Taejo : compare with the Monoid algebra, which has two operations `mempty :: r',`mappend :: r -> r -> r' (`r' being the carrier), and which also should satisfy three laws
23:47:28 <Taejo> ski: in the algebra all operations have type a^n -> a (I probably haven't seen the theory in its full generality: it was really a course on ring theory, but taught by a category theorist)
23:47:37 <Taejo> *in the algebra I've seen
23:48:15 * Taejo looks forward to his category theory course next year
23:49:36 <ski> Taejo : ok .. here `r^2 -> r' is isomorphic to `r -> r -> r' in haskell curried style .. however, i had `a -> r -> r' where `a' was not a carrier .. compare with vector space(s) `r' over a field `a', there you have an operation `scaleLeft :: a -> r -> r'
23:50:03 <ski> (also, obviously `r^0 -> r' is iso to plain `r' as in `nil :: r')
23:50:09 <Taejo> ski: ok, I see.
23:50:18 <Taejo> it was the `a' that worried me
23:51:08 <ski> in this case, the `a' is an "external" set (or object), that can occur on the argument side in the signatures
23:51:18 <Taejo> ok
23:51:26 <ski> however, it is also possible to have an algebra which has several carriers
23:51:32 <Taejo> sure
23:51:49 <Taejo> thanks ski
23:51:57 <ski> so you'd have `r0' and `r1', and some operations may yield `r0' and others may yield `r1'
23:53:32 <ski> another direction for generalization is to generalize from `r^n -> r' to `p(r) -> r', where `p' is a polynom
23:53:56 <ski> (similarly for polynoms in several variables/carriers)
23:54:31 <ski> so, e.g. `Maybe (a,r) -> r' can be written as `(1 + a * r^1) -> r'
23:56:17 <ski> (well, maybe i shouldn't say "generalization" here, because one can split a `p(r) -> r' operation into one for each term in the polynom, each of form `a_n * r^n -> r' ..)
23:57:08 <BeelsebobWork> compiling with -prof -auto-all and running with +RTS -p should generate a .prof file, right?
23:58:16 <omy> anybody has an idea on how to prove this with algebra?      lnx^x-lny^x-x+y>=0
23:58:48 <omy> i know it's true as long as x and y are both > 0 .... but I would like to prove it.
23:59:21 <TSC> BeelsebobWork: Should do
23:59:31 <BeelsebobWork> :/
23:59:51 <omy> ln(x^x)-ln(y^x)-x+y >= 0
23:59:57 <ski> omy : does "lnx^x" mean `ln (x^x)' ?
