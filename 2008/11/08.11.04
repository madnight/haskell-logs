00:09:53 <cnwdup> I want to make my type an instance of Typeable, but looking at the code there
00:10:14 <cnwdup> 's no instance declaration for Typeable. Only INSTANCE_TYPEABLEN(foo,bar,str). Where's that defined?
00:12:22 <rwbarton> You probably want to derive the instance
00:13:45 <dreixel> rewrite rules don't seem to work for me. what did I get wrong in http://hpaste.org/11722 ?
00:14:08 <rwbarton> are you compiling with optimizations?
00:15:16 <dreixel> ah.
00:15:23 <dreixel> well I thought I was
00:15:27 <dreixel> but obviously I wasn't
00:15:34 <dreixel> since it now works
00:16:29 <dons> -frewrite-rules won't hurt either
00:19:17 <dreixel> but it doesn't work?
00:19:25 <dreixel> apparently I have to explicitely use -fglasgow-exts
00:20:08 <dreixel> if I replace -fglasgow-exts by -frewrite-rules then the rule doesn't fire anymore
00:24:09 <L3v1> hi, here i am again.
00:24:57 <L3v1> i have a piece of code at http://hpaste.org/11719#a2 , errors in it.
00:26:01 <dons> dreixel: you'll need -O either way, unless you're using ghc 6.10
00:26:27 <L3v1> the Q is how to write the instance DataString DevParam ?
00:26:58 <edwardk> L3v1 thats because it can't figure out if it should use the Instruct a => DataString a or the DataString DevParam instance directly. you _could_ cheat and use AllowOverlappingInstances but its generally bad form
00:27:10 <dreixel> dons: I'm in 6.8.3. With -O, it'll work with -fglasgow-exts, but not with -frewrite-rules
00:28:19 <rwbarton> L3v1: right, this is why I said you couldn't have any other instances of DataString
00:28:31 <edwardk> a 'better' option in a lot of ways would be to write methods like dataStrInstruct and strDataInstruct and then direct users of the Instruct class that they can safely make an instance of DataString out of those methods. If you want to enforce that they implement DataString then change Instruct's class
00:28:53 <edwardk> so that DataString is a superclass of Instruct, then the user will have to at least think about the issue
00:28:54 <rwbarton> or, maybe make DataString a superclass of Instruct
00:30:15 <ibid> dons: want to handle the newest request - for practice?
00:30:23 <dobblego> does anyone use Haskell for a personal budget?
00:32:53 <L3v1> so, what does a superclass seems like, is there an example ?
00:33:56 <edwardk> l3v1: one last thing, if you really need to have every Instruct form an instance of DevParam with those arguments another option is to make a newtype newtype InstructionDataString a = InstructionDataString a and make THAT an instance of DataString when a is an instance of Instruct, then you have no ambiguity
00:34:07 <edwardk> l3v1: well, class DataString a => Instruct a where ...
00:34:39 <edwardk> l3v1: that doesn't solve your instance, you'd still have to move the instance methods out and make them into combinators that you can later use to build the instance from for each Instruct.
00:37:18 <edwardk> personally i tend to go for the 'provide a bunch of methods and force the user to implement the superclass' approach rather than the newtype approach because the former puts the burden on extenders of a library while the latter places it on users of the library.
00:37:30 <dons> ibid: done
00:37:41 <dons> ibid: didn't see your response till after i did it, but looks like all is well.
00:38:02 <dons> dobblego: only for calculator stuff. i've seen blogs with fancier things though
00:38:03 * L3v1 slaps L3v1 around a bit with a large trout
00:39:32 <ibid> dons: if you're always that fast, you're going to be doing it all alone - even if i'm fast, i'm not *that* fast :)
00:39:53 <ibid> the second "if" ought to be "when"
00:41:07 <dons> hehe
00:41:18 <dons> probably i will be fast when it is the only thing to do before going to bed.
00:41:20 <dons> night all!
00:42:04 <L3v1> eh, thanks alot, i copy out what you told me for further understanding.
00:48:45 <rwbarton> Hmm, no @-patterns in instance declarations :(
00:50:58 <edwardk> rwbarton: hrmm. maybe make a class Identity a b | a -> b, b -> a; instance Identity a a then use that in the instance head?
00:51:32 <edwardk> er that probably breaks
00:51:45 <rwbarton> yeah, no closed classes
00:51:50 <rwbarton> oh
00:51:54 <rwbarton> well, I'll try it
00:51:56 <edwardk> type family?
00:52:43 <rwbarton> It didn't let me avoid overlapping instances, which was my goal
00:52:56 <edwardk> i presume you are looking for something like instance (x@(Foo a)) or something?
00:53:12 <rwbarton> Right, and there's a class constraint on Foo a
00:54:02 <aeolist> life just rules :) i got my first haskell assignment.... oh the tears!
00:54:30 <rwbarton> It's OK, it's hardly more complicated than x@(Foo a) and I'm just playing around with type-level computation for no reason. :)
00:54:48 <rwbarton> http://hpaste.org/11724
00:55:05 <dobblego> dons, what have you seen on blogs exactly?
00:55:34 <edwardk> ah
00:55:34 <rwbarton> obviously this code would benefit from someone skilled in the ways of type families.
00:55:53 <edwardk> did you see my old typed binary/hex library?
00:56:32 <rwbarton> is it like the type-level package?  type-level integers with various operations
00:56:43 <edwardk> http://comonad.com/haskell/type-int/
00:56:48 <lambdabot> Title: Index of /haskell/type-int
00:56:59 <edwardk> type level arbitrary precision 2s and 16s complement integers
00:57:40 <edwardk> it was the first thing i wrote using a lot of typeclasses
00:58:21 <edwardk> i'm sure folks have come along and made something a lot nicer since
00:59:17 <rwbarton> I saw Stage1, Stage2, Stage3, and I shuddered in anticipation :)
00:59:20 <edwardk> the hex stuff there does take forever to compile though. template haskell generates ~20,000 instances or something
00:59:24 <edwardk> hah
01:00:13 <edwardk> they had to be in separate files because i couldn't use the stuff i was generating in template haskell in the same file ;)
01:00:27 <rwbarton> Yeah, I figured
01:00:36 <edwardk> http://comonad.com/haskell/type-int/src/Data/Type/Binary/Internals.hs is really a lot easier to read than the stuff in Data.Type.Hex
01:00:38 <lambdabot> http://tinyurl.com/59od3d
01:00:56 <edwardk> if you read that like a crip sheet and generalize from 2s complement to 16s complement the hex stuff makes sense
01:01:04 <edwardk> without the binary stuff the hex stuff is nigh illegible.
01:01:09 <rwbarton> I used the type-level package to write this: http://hpaste.org/11720
01:01:38 <edwardk> ah nice
01:03:02 <edwardk> last time i tried something like that i gave in and used the cc shan/oleg trick
01:03:35 <profmakx> hm. rwbarton, now for finite fields! ;)
01:04:20 <edwardk> wow, mathematicians will name and systematize anything: http://en.wikipedia.org/wiki/Greedoid
01:04:21 <lambdabot> Title: Greedoid - Wikipedia, the free encyclopedia
01:06:09 <rwbarton> well, the type-level package is by oleg et al., so it may be the same trick
01:06:41 <edwardk> nah they had that configuration pearl thing
01:06:55 <profmakx> uh
01:07:21 <edwardk> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
01:07:24 <lambdabot> Title: Functional Pearl: Implicit Configurations
01:24:00 <BeelsebobWork> is ghc 6.8.2 sufficient to build the current 6.11.head, or would I need to update to at least 6.8.3?
01:24:34 <Lemmih> BeelsebobWork: ghc-6.8.2 should be fine.
01:24:40 <BeelsebobWork> win :)
01:24:55 <BeelsebobWork> I was dreading having to compile it twice in this VM
01:25:04 <BeelsebobWork> (stupid VM that's not client SMP aware)
01:26:20 <Sadache> I am doing a calendar with haskell and i need to persist a ZonedDate but seems there is no Read or Data instances defined for it, is that true?
01:26:42 <quicksilver> @instances-importing Data.Time.Clock Read
01:26:44 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
01:26:49 <quicksilver> hmm that didn't work.
01:27:47 <Sadache> and in case there are no defined instances by default, what can i do to be able to persist a ZonedDate?
01:28:12 <quicksilver> Sadache: what is ZonedDate?
01:28:21 <quicksilver> @index ZonedDate
01:28:22 <lambdabot> bzzt
01:28:33 <Sadache> sorry i meant ZonedTime
01:28:52 <quicksilver> ah
01:29:06 <quicksilver> I think there is a read instance for ZonedTime in Data.Time.Format
01:29:24 <Sadache> but not a Data instance
01:29:35 <Sadache> I found the Read instance I guess, but not the Data
01:30:12 <quicksilver> Data doesn't have much to do with persistance
01:30:17 <quicksilver> it's for generic traversal
01:30:31 <dobblego> -ence
01:30:39 <quicksilver> thanks :P
01:30:44 <dobblego> np ;)
01:31:20 <Sadache> I am using Happs.State and it requires Data to be implemented
01:33:32 <Sadache> it requires Typeable as well
01:33:50 <Sadache> is there any other Date type that implements those?
01:36:25 <ToRA|MSR> can't you use standalone deriving to generate a data instance, given all it's constructors are exported?
01:36:33 <quicksilver> Sadache: I'm surprised those types don't have instances but you can derive them automatically.
01:36:53 <Lemmih> Sadache: HAppS.State doesn't require Data.
01:38:42 <Sadache> ToRA|MSR: I didn't know a standalone deriving exists
01:39:08 <Sadache> Lemmih: ok thanks, the sample I used had it so i thought it is required
01:39:54 <ToRA|MSR> Sadache: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
01:39:56 <lambdabot> Title: 8.5.ï¿½Extensions to the "deriving" mechanism, http://tinyurl.com/2ts9ot
01:40:08 <Lemmih> Sadache: HAppS only tries to use Data for generic serialization if you don't supply a Serialize instance yourself.
01:42:40 <Sadache> Lemmih: so is it ok if i only use the template then for generating the serialize instance without having Data instance defined?
01:50:33 <aeolist> excuse my ignorance, but how can i import a local .hs file? cant come up with the right string for google... i think i got the export part right
01:51:17 <quicksilver> aeolist: "import ModuleName"
01:51:49 <aeolist> yeah but i mean, import probably searches in some standard path for standard modules, i just want to import my own stuff
01:51:55 <aeolist> how is it going to detect it
01:52:04 <stbuehler> hi. i have a problem with "happy" - it either writes nothing or only 8192 bytes (debian lenny)
01:52:04 <quicksilver> and the file should define a module called ModuleName
01:52:15 <quicksilver> aeolist: well the simplest thing is to put it in the same directory.
01:52:25 <aeolist> it searches there by default?
01:53:08 <quicksilver> yes.
01:53:25 <quicksilver> or in Foo/Bar/Baz.hs relative to current directory
01:53:30 <quicksilver> for module Foo.Bar.Baz
01:53:37 <aeolist> ok i get it... thank you
01:55:12 <quicksilver> aeolist: if you want a library shared between different projects
01:55:20 <quicksilver> aeolist: then you should install it "properly" as a GHC package.
01:55:28 <quicksilver> aeolist: cabal is the simplest way to arrange that.
01:55:40 <aeolist> nah, i nowhere near that :) but thanks
01:57:07 <aeolist> ghc --make filename.hs, missed that as well
02:00:28 <Sadache> ToRA|MSR: Not all data constructors are exported, I could derive most instances except for Pico
02:00:42 <ToRA|MSR> ah ok
02:00:52 <Sadache> http://www.mibbit.com/pb/alItiC
02:00:57 <lambdabot> Title: Mibbit: PasteBin
02:01:06 <stbuehler> happy gaves me the "error": "happy: lhs"
02:04:09 <Sadache> is there any other Date type that i can use and persist for a calendar application under Happs?
02:04:11 <hugo__> good morning haskell brotherhood
02:06:07 <quicksilver> Sadache: you can use the read instance
02:06:12 <quicksilver> and just persist it via a string
02:06:14 <quicksilver> sucky, but easy
02:08:24 <quicksilver> it's probably best considered a bug if anything in the standard lib doesn't have Data/Typeable instances.
02:08:30 <quicksilver> (where it's possible for it to do so)
02:12:55 <Sadache> quicksilver: thanks I ll try to do that
02:17:21 <mib_vbwfto> hi there .. i want to run a haskell file with "runhaskell test.hs" .. the script basically only contains one line "main = sum [n | n<-[1..1000], n `mod` 5 == 0 || n `mod` 3 == 0]" but it produces an error "No instance for (Integral (IO ())) arising from a use of `mod' at 1.hs:1:7-23" .. what am i doing wrong?
02:17:47 <Lemmih> mib_vbwfto: 'main' has to be of type 'IO ()'.
02:18:35 <Lemmih> mib_vbwfto: Try: ghc -e 'main' test.hs
02:19:01 <Sadache> Lemmih: Do you have a link to documentation of Happs code? I couldn't find it and i am searching for the definition of the serialize class
02:19:48 <mib_vbwfto> Lemmih: same problem .. if I run the line on ghci, all works fine
02:20:22 <Lemmih> mib_vbwfto: Try adding 'print $' before the 'sum'.
02:20:40 <Lemmih> Sadache: http://hackage.haskell.org/packages/archive/HAppS-Data/0.9.2.1/doc/html/HAppS-Data-Serialize.html
02:20:46 <lambdabot> Title: HAppS.Data.Serialize, http://tinyurl.com/6m74fd
02:20:54 <Sadache> thanks
02:22:11 <mib_vbwfto> Lemmih: that worked .. I needed to put the sum expression in braces, too .. thanks
02:27:36 <Stinger> @ty unsafePerformIO
02:27:37 <lambdabot> Not in scope: `unsafePerformIO'
02:30:50 <Lemmih> @type System.IO.Unsafe.unsafePerformIO
02:30:51 <lambdabot> forall a. IO a -> a
02:32:27 <titusg> I have a recurring problem with cabal and deps -- cabal claims QuickCheck isn't installed but ghc-pkg says it is
02:32:55 <dcoutts> titusg: is it confusion over --global vs --user installs?
02:33:22 <titusg> could be -- qc is install in ~/.cabal
02:33:34 <titusg> but I am running as a user anyway
02:33:53 <dcoutts> titusg: so you're building something by running rugnhc Setup configure are you? and it's not finding QC?
02:34:23 <titusg> yes (I've tried that and cabal with install in the package dir)
02:34:29 <dcoutts> titusg: use either 'cabal configure' or use 'rugnhc Setup configure --user'
02:34:48 <dcoutts> the older rugnhc Setup method defaults to --global installs by default
02:35:06 <titusg> thanks, trying now
02:35:35 <dcoutts> titusg: since you've got the 'cabal' program, there is no need to runghc Setup
02:36:52 <titusg> cabal configure, no problem. cabal install, a compilation error -- Not in scope: `quickCheck'
02:37:00 <titusg> the package is agda2
02:37:16 <Sadache> quicksilver: I am sorry, but I can not figure out how to implement Serialize using Read, it involved Contained Get and i am not sure how to use this
02:37:18 <dcoutts> titusg: that's a compile error in the package
02:37:51 <dcoutts> titusg: so not the same as the previous configuration problem.
02:37:56 <titusg> I installed it elsewhere yesterday
02:38:19 <titusg> and the previous problem was about missing qc so I presumed they were connected
02:38:33 <dcoutts> titusg: I suspect however that agda2 expects a different version of QC than the one you installed
02:38:48 <dcoutts> which really is a bug in agda2 for not specifying it properly
02:38:52 <titusg> so the deps are wrong?
02:39:27 <dcoutts> titusg: right, there are two major versions of QC, 1 and 2 so you probably the other one
02:40:37 <titusg> I have 2.1.0.1, installed by cabal just now as a dep
02:42:27 <jsn> dcoutts: this is haskell QC running, but being compiled by AGDA?
02:42:40 <jsn> s/ running//
02:42:42 <dcoutts> titusg: ok, try cabal install 'quickcheck < 2'
02:43:07 <dcoutts> jsn: not afaik, I thought it was just building agda
02:43:31 <jsn> oh, AGDA is written in haskell?
02:43:58 <dcoutts> jsn: yes
02:44:13 <jsn> ah
02:45:11 <titusg> dcoutts: that's installed 1.2.0, and I have the same error. The .cabal says QC > =2 & < 3
02:45:26 <dcoutts> titusg: oh, hmm, so it does need >= 2
02:45:46 <dcoutts> titusg: then it's a bug in agda, ask the devs about it
02:47:23 <titusg> dcoutts: thanks I will.
02:47:58 <dcoutts> titusg: sorry about the QC1, that was a red herring
02:48:04 * dcoutts was guessing
02:49:24 <titusg> worth a try :-)
03:03:06 <Sadache> can someone here help me implement an instance of Serialize for Happs.State for type ZonedTime using Read ?
03:04:10 <Wechner> hello everyone
03:05:51 <unenough> BONUS, what web framework/server are you using for the tutorial?
03:06:05 <Lemmih> Sadache: I can.
03:06:19 <Lemmih> Sadache: We can talk in #happs.
03:06:20 <Wechner> I have a question regarding numeric types in Haskell ... how do I create one? :) I think I have to write instances of Bounden, Num, etc. for it .... but my problem is the data constructor ... I don't know where to start there
03:11:18 <Sadache> Lemmih: ok
03:15:46 <Wechner> hm, does noone know an answer? ... the problem I have is that I want to create a datatype whose values are between 0 and 23 for example
03:17:50 <TSC> Wechner: Your data type could be a wrapper around an Int
03:18:08 <Wechner> yeah, that's where I am at the moment
03:18:35 <TSC> You could, of course, say "data LittleNumber = Zero | One | Two | Three ..."
03:18:38 <TSC> But I wouldn't (:
03:18:49 <Wechner> I have http://hpaste.org/11726
03:19:24 <Wechner> I wouldn't do it that way, too ;)
03:19:41 <TSC> You probably want a function "makeHour :: Integer -> Hour" which checks the bounds of the input
03:19:50 <Wechner> ok
03:19:51 <Wechner> yeah
03:19:54 <TSC> And you use that instead of the "Hour" data constructor
03:19:58 <Wechner> that's an idea :)
03:20:05 <Wechner> TSC: thanks :)
03:20:19 <TSC> No worries
03:33:51 <BeelsebobWork> :/
03:34:08 <BeelsebobWork> how does one go about recovering their Hackage password -- I sent an email a couple of days ago, but haven't got a response
03:39:26 <quicksilver> Sadache: actually I just meant stuff a String in your happs state
03:39:30 <quicksilver> Sadache: and use read/show maually
03:39:42 <quicksilver> I bet you could also write a serialise instance but I've not tried that
03:40:56 <Sadache> quicksilver: yeah, Lemmih helped doing that at #Happs
03:41:09 <Sadache> thanks quicksilver  for your help
03:44:02 <Narcissus> hai welp
03:44:21 <Narcissus> welp, have you done the plusThree thing
03:44:31 <welp> nope
03:44:38 <Narcissus> Which parts have you done, if any
03:47:11 <welp> uuum
03:47:16 <welp> i'm up to the plusthree thing
04:03:47 <kazimir> hey guys!
04:04:12 <Botje> ha!
04:04:14 <Botje> hai!
04:04:43 <kazimir> anyone tried to do a polynomial long divison in haskell?
04:04:51 * EvilTerran mumbles about coffee
04:05:08 <EvilTerran> kazimir, probably not, but it sounds like it'd be fairly straightforward
04:05:41 <kazimir> i cant get an idea of doing this in haskell
04:05:56 <ketil> From the Data.Binary docs: encodeFile :: Binary a => FilePath -> a -> IO ()
04:05:56 <ketil> Lazily serialise a value to a file
04:06:13 * ketil thinks "Lazily" is misplaced.  No?
04:07:00 <EvilTerran> kazimir, well, the distinguishing feature of any one polynomial is its coefficients, which is a list of numbers
04:07:22 <Botje> ketil: maybe the data isn't written until you read the file ;)
04:07:26 <kazimir> yeah...the polynomials are lists
04:07:57 <EvilTerran> "list of numbers" in haskell-speak being [Int]. or [Integer], [Rational], [Float], ...
04:08:17 <kazimir> they are [int] lists
04:08:22 <EvilTerran> that makes sense
04:08:28 <EvilTerran> which end is which?@
04:08:43 <kazimir> i already made function for adding, subtracting and multiplicating
04:09:30 <EvilTerran> ah, but you're stuck on division?
04:09:38 <kazimir> yeppa
04:10:21 <kazimir> the problem is working with the rest of the division
04:10:30 <kazimir> not sure about what to do with it
04:11:00 * EvilTerran can't get his head round the problem this early in the morning, either =/
04:12:52 <EvilTerran> http://en.wikipedia.org/wiki/Polynomial_long_division <- for reference
04:12:53 <lambdabot> Title: Polynomial long division - Wikipedia, the free encyclopedia
04:13:28 <araujo> morning
04:14:27 <EvilTerran> http://mathworld.wolfram.com/SyntheticDivision.html <- kazimir, this presents another (manual) algorithm that may be worth looking at for ideas
04:14:32 <lambdabot> Title: Synthetic Division -- from Wolfram MathWorld
04:14:51 <kazimir> okay...i'll take a look
04:14:59 <kazimir> thank you for link
04:16:30 <EvilTerran> although it would require you to factor the one you were dividing by into linear factors (x + a)(x + b)(...)
04:17:10 <kazimir> yeah i see
04:17:24 <EvilTerran> unless that's all the dividing you want to do anyway
04:17:26 <kazimir> never thought about synthetic division
04:19:45 <TuBzZz> I've searched on google for quite some time, but havent found anything to my liking: I'm looking for a ground-up haskell tutorial and was wondering if anyone could point me in the direction of one they've found particularly good.
04:20:02 <jeffz> TuBzZz: have you seen http://learnyouahaskell.com/
04:20:11 <lambdabot> Title: Learn You a Haskell for Great Good!
04:20:13 <kazimir> thats my fav too
04:20:29 <TuBzZz> I haven't, no. I'll take a look - thanks :)
04:21:41 <kazimir> I also like Haskell Tutorial for C programmers (because i am)
04:21:42 <kazimir> http://www.haskell.org/~pairwise/intro/intro.html
04:21:43 <lambdabot> Title: Haskell for C Programmers
04:22:33 <TuBzZz> learnyouahaskell.com seems to be just the sort of thing I was looking for really
04:22:39 <TuBzZz> Thanks =)
04:48:56 <Axman6> TuBzZz: be sure to thank BONUS_ then
05:03:32 <byorgey> @unmtl StateT Char (ReaderT Int Maybe)
05:03:33 <lambdabot> err: `StateT Char (ReaderT Int Maybe)' is not applied to enough arguments, giving `/\A. Char -> Int -> Maybe (A, Char)'
05:03:38 <byorgey> @unmtl StateT Char (ReaderT Int Maybe) a
05:03:38 <lambdabot> Char -> Int -> Maybe (a, Char)
05:06:07 <byorgey> @unmtl (MaybeT (StateT Char (Reader Int))) a
05:06:08 <lambdabot> Char -> Int -> (Maybe a, Char)
05:11:13 <byorgey> is MaybeT in a package on hackage somewhere?  or is it only on the wiki?
05:13:46 * byorgey entices people to answer his question with promises of tax cuts and chocolate
05:14:24 <pozic> byorgey: it is
05:14:41 <byorgey> tax cuts for pozic!
05:15:24 <byorgey> heh, I guess I should have been more specific in my question =)
05:17:21 <Saizan> ?hackage MaybeT
05:17:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT
05:17:48 <BeelsebobWork> Has anyone ever met this error? http://hpaste.org/11728
05:18:20 <BeelsebobWork> (trying to get OpenGL working on a random linux machine)
05:18:50 <byorgey> oh! the package is called MaybeT.  duh. =)
05:18:52 <int-e> BeelsebobWork: root has a different ghc than you do?
05:19:26 <BeelsebobWork> oh interesting -- no
05:19:31 <BeelsebobWork> but if I sudo rather than su, they do
05:20:51 <BeelsebobWork> oddly, sudo which ghc gives /usr/bin/ghc, su gives /usr/local/bin/ghc, but sudo echo $PATH gives /usr/local/bin on the front :/
05:21:10 <BeelsebobWork> oh, but $PATH will get expanded in the shell, not sudoed
05:21:15 <Igloo> $PATH is expanded by your shell, before sudo runs
05:22:00 <BeelsebobWork> so what differs between running sudo and su?  I could just log in as root and install it... but it would be rather nicer to fix it
05:23:09 <SamB_XP_> Beelsebob: I might suggest specifying the GHC version explicitly
05:24:08 <BeelsebobWork> that works -- but it still doesn't fix the heart of the problem
05:24:18 <BeelsebobWork> does anyone know what sudo does differently?  Does it not actually do a proper log in?
05:27:03 <dmwit> sudo does not actually log in.
05:27:09 <JaffaCake> sudo -i
05:27:25 <dmwit> It does some rather questionable stuff, too: like keeping $HOME at the user's location.
05:28:59 <SamB_XP_> sudo is supposed to just run the program with privileges, isn't it ?
05:29:23 <BeelsebobWork> it's strang though -- both my $PATH and root's $PATH has /usr/local/bin first
05:29:34 <BeelsebobWork> I don't quite get where it's picking up /usr/bin from
05:30:50 <int-e> (man sudoers, env_reset) "If sudo was compiled with the SECURE_PATH option, its value will be used for the PATH environment variable. This flag is on by default."
05:31:18 <BeelsebobWork> hmm, okay
05:31:21 <BeelsebobWork> cheers muchly
05:32:04 * int-e suddenly feels much better about not using sudo ;-)
05:32:10 <BeelsebobWork> hehe
05:32:22 <BeelsebobWork> sudo works very nicely on OS X -- but it appears it's default setup is rather dumb
05:32:50 <BeelsebobWork> it's actually a security bonus on OS X -- root has no password with which you can access the account.  So any attacker needs to guess both username and password
05:32:51 <Adamant> BeelsebobWork: ?
05:33:17 <Adamant> right, and you can get a root shell from sudo easily if you need it
05:33:26 <BeelsebobWork> indeed
05:33:34 <BeelsebobWork> sudo su - if you really need it
05:34:10 <SamB_XP_> you know what I was rather amazed to discover ?
05:34:50 <BeelsebobWork> hmm?
05:35:48 <SamB_XP_> that the Windows XP disc won't let you open the recovery thingamajig unless you can remember the Administrator password ... doesn't matter if you can remember the password to some other account with administrative rights or not!
05:36:27 <BeelsebobWork> haha, awesome
05:37:14 <SamB_XP_> I eventually had to just use safe mode to delete the rootkit that had infested my system ...
05:38:07 <SamB_XP_> (man I wished I had a less busybodyish livecd which could write NTFS ...)
05:39:07 * BeelsebobWork suddenly feels so much better about using OS X
05:55:50 <maltem_> I was going to bootstrap ghc on a cluster account, starting with cross-compiling ghc 6.6.1. But it uses System.Directory.Internals, which has been abandoned in favor of filepath. What would be the wisest thing to do now?
06:39:38 <therp> I just recognized that I have never seen type classes in data declarations.. data Foo = Bar (SomeClass n => n)
06:41:31 <therp> I try to think of reason why this shouldn't be possible
06:43:07 <maltem_> therp: This is possible with the existential types extension
06:43:55 <quicksilver> well what therp has written is a universal, not an existential.
06:44:09 <quicksilver> that's possible with RankNTypes and possibly impredicativity
06:44:16 <quicksilver> but it might not be very useful.
06:45:28 <therp> what's so hard that?
06:46:10 <maltem_> quicksilver: so this isn't data Foo = forall a. SomeClass a => Bar a ?
06:46:13 <jimstutt> vegai: hi, dons said you might be able to tell me the current status of ghc-6.10.1 on x86 archlinux?
06:46:27 <quicksilver> maltem_: no, that's different.
06:46:33 <quicksilver> that has the forall outside the Bar
06:46:34 <pozic> I have a list comprehension that returns the right answer (+ some garbage), but it examines too many combinations. The problem is that I don't see how I can write a list comprehension that uses extra information generated during the list comprehension process.
06:46:39 <quicksilver> which makes it existential not universal.
06:47:00 <quicksilver> therp: nothing is hard about either option.
06:47:20 <quicksilver> although they both lie in slightly more capable type systems than h98
06:47:45 <maltem_> quicksilver: hm, then what does universal mean? That n can be treated like any type in SomeClass?
06:48:43 <ski> `data Foo = Bar (forall n. SomeClass n => n)' would be the "universal datatype"
06:48:58 <quicksilver> :t 5
06:49:00 <lambdabot> forall t. (Num t) => t
06:49:03 <quicksilver> maltem_: that's universal
06:49:09 <quicksilver> maltem_: 5 is "all numbers"
06:49:12 <maltem_> ah, of course
06:49:13 <ski> `data Foo = Bar (SomeClass n => n)' has `n' as free typevariable, and is not allowed
06:49:17 <maltem_> right
06:49:31 <quicksilver> ski: well, I was taking the liberty of assuming a forall to the left of the SomeClass
06:49:40 <quicksilver> ski: since that seems the most likely thing for that to mean.
06:50:03 <quicksilver> by analogy with "x :: SomeClass n => n"
06:50:24 <quicksilver> but yes, to be precise it's better to show where the forall is
06:50:29 <quicksilver> and, thus, you get the two options.
06:52:15 <ski> well, actually it appears ghci allows `data Foo = Bar (SomeClass n => n)', (adding a `forall n.' around the argument type)
06:53:23 <ski> (i'm not sure i like it, though .. what about if we want to support local `data' declarations inside a value definition, having an outer type variable in scope ?
06:53:37 <ski>  foo :: forall a. [a] -> ...
06:53:51 <ski>   foo (x : xs :: [a]) = ...
06:53:55 <ski>    where
06:54:17 <ski>     data Foo = Bar (SomeClass a => ..a..)
06:54:18 <ski> )
06:55:36 <ski> (not sure if the `SomeClass a =>' on an already bound tyvar would make much practical sense here .. so maybe just keep the `..a..')
06:56:54 * ski has on occasion wanted exactly this kind of local type definition ..
06:59:00 <ski> therp : i suppose one possibly use case for `data Foo = Bar (forall n. SomeClass n => n)' would be passing around "class" dictionaries .. i.e. like with classes, but you can have several of them per type, and you have to pass them around explicitly
06:59:10 <ski> namely
06:59:52 <ski> hm
07:00:10 <ski> right
07:00:42 <ski>   class FunctorFunctor t
07:00:46 <ski>     where
07:00:49 <cnwdup> How can I make a an instance of Typeable? I only found C-like commands for that in the Source.   Wheree can I read about thm?
07:01:22 <ski>     tmap :: forall f g a. (Functor f,Functor g) => (forall x. f x -> g x) -> (t f a -> t g a)
07:01:36 <ski> would induce a corresponding dictionary type
07:02:01 <ski>   data FunctorFunctorDict t = FFD {tmap :: forall f g a. (Functor f,Functor g) => (forall x. f x -> g x) -> (t f a -> t g a)}
07:02:18 <cnwdup> Let's start over with fewer typing errors: How can I make a type an instance of Typeable? I only found C-like commands in the source. Where can I read about them?
07:02:27 <ski> cnwdup : did you try `deriving Typable' on the type declaration (if you defined it yourself) ?
07:02:57 <igel> cnwdup: use {-# LANGUAGE DeriveDataTypeble #-} and "deriving Typeable"
07:03:02 <cnwdup> Nope, didn't. I'll try.
07:03:08 <igel> it works^^ :)
07:03:20 <igel> except if you use it in type families
07:03:30 <igel> which brings me to my question:
07:03:42 <igel> how can i derive typeable in a type family?
07:03:48 <igel> instance Family a where
07:03:58 <cnwdup> Ah. Thanks. So are typeables directly supported by ghc or is it supported due to the C-like commands in the Typeable source file?
07:03:59 <igel>   data Foo = Foo deriving Typeable
07:04:03 <igel> does not work :(
07:04:32 <igel> but it *does* work with other classes, Show for instance
07:04:49 <ski> (are you sure you shouldn't have `a' as argument to `Foo', there ? .. probably doesn't help, though)
07:04:49 <igel> cnwdup: i don't know
07:05:02 <igel> ski: yes, i alway forget that
07:05:08 <wjt> igel: {-# LANGUAGE DeriveDataTypeable #-}
07:05:12 <igel> but this is not the reason why it doesn't work
07:05:15 <quicksilver> cnwdup: typeable is derictly supported by ghc
07:05:16 <igel> wjt: i've got that
07:05:37 <ski> possibly ghc has simply not implemented `Typable'-deriving in type families (yet)
07:05:53 <igel> is it part of ghc-6.10?
07:05:55 <cnwdup> quicksilver: ok
07:05:56 <quicksilver> well it probably needs ot be Typeable1, at least
07:07:24 <ski> what should a `TypableX' class on types of kind `(* -> *) -> *' be called ?
07:07:38 <quicksilver> Typeable1.1
07:07:39 <quicksilver> ;)
07:07:42 <ski> (or would it maybe not make sense ?)
07:07:53 <quicksilver> I don't really know what makes sense here.
07:08:12 <quicksilver> I have a rather weak intuition for Typeable + higher kinds
07:08:18 <ski> i think it would be nice if we could make the kind a parameter of the class .. or something similar
07:08:32 <ski>   class Typable k (a :: k)
07:08:48 <ski> (.. but how to express the methods, then ?)
07:09:37 <ski> (`instance Typable * Int',`instance Typable (* -> *) Maybe',`instance Typable ((* -> *) -> *) Fix', et.c.)
07:10:16 <quicksilver> ski: as GHC gets more expressive kinds, which are apparently in the pipeline
07:10:24 <quicksilver> ski: they're going to have to solve the typeable problem again
07:10:30 <quicksilver> perhaps there is a better way.
07:12:24 <ski> hm .. examples of more kinds of kinds ?
07:12:45 <ToRA|MSR> http://hackage.haskell.org/trac/ghc/wiki/PolymorphicKinds
07:12:49 <ski> ty
07:12:51 <ToRA|MSR> and links if you want examples and thoughts
07:12:53 <lambdabot> Title: PolymorphicKinds - GHC - Trac
07:13:00 <ToRA|MSR> actually the link to kind system is probably more relevant
07:13:44 <ToRA|MSR> i was going to try and do this, but alas i don't think i'll have time - so it's there for others to mull on...
07:14:47 <quicksilver> ToRA|MSR: what are you doing in fact?
07:14:59 <ski> hm .. should one be able to `newtype' at types of kind other than `*' ?
07:15:26 <lilac> ski: i believe so
07:15:58 <ToRA|MSR> quicksilver: adding localised stack traces
07:16:06 <ski> Flip :: forall_kind k0 k1 k2. (k1 -> k0 -> k2) -> (k0 -> k1 -> k2)
07:16:33 <ski> newtype Flip f t0 t1 = MkFlip {unFlip :: f t1 t0}
07:16:38 <ski> :t Flip
07:16:39 <lambdabot> Not in scope: data constructor `Flip'
07:16:40 <ski> :t MkFlip
07:16:41 <quicksilver> ToRA|MSR: ah well that sounds useful too :)
07:16:41 <lambdabot> Not in scope: data constructor `MkFlip'
07:16:45 <ski> (rather)
07:17:23 <ski>   MkFlip :: .. (f t1 t0 -> f t0 t1)  -- roughly
07:17:34 <ski> but that `->' is not at `*' level
07:18:02 <ski> maybe `->' should be polymorphic at a kind `k' .. or at least some overloading
07:18:41 <quicksilver> who will kind the kinding constructors
07:19:07 <ski> "sorts (which classify kinds)"
07:19:38 <ski> i had a wacky idea awhile ago
07:19:43 <jimstutt> @seen vegai
07:19:43 <lambdabot> vegai is in #haskell, #haskell-blah and #arch-haskell. I last heard vegai speak 4h 40m 53s ago.
07:19:56 <ski>   newtype k (Flip f t0 t1) = MkFlip {unFlip :: k (f t1 t0)}
07:21:08 <ski>   MkFlip :: forall_kind k0 k1 k2. forall (k :: k2 -> *) (f :: k1 -> k0 -> k2) (t0 :: k0) (t1 :: k1). k (f t1 t0) -> k (Flip f t0 t1)
07:21:24 <ski>   unFlip :: forall_kind k0 k1 k2. forall (k :: k2 -> *) (f :: k1 -> k0 -> k2) (t0 :: k0) (t1 :: k1). k (Flip f t0 t1) -> k (f t1 t0)
07:22:17 <ski> this would have the strange effect of being able to `case' on an expression, matching on constructor not for the toplevel type constructor of the type
07:22:43 <ski>   case blah :: [Flip f t0 t1] of
07:22:52 <ski>     MkFlip x -> x
07:22:57 <quicksilver> ski: sounds like the quick path to brane asplosion to me.
07:23:00 <ski>   :: [f t1 t0]
07:23:51 <ski> (obviously this would not work for `data' .. it only works for `newtype' because there constructors are erased til run-time)
07:24:49 <ski> also possibly annoying is only being able to unwrap the `Flip' in `[Flip f t0 t1]' but not in `[[Flip f t0 t1]]' .. to do the latter, you'd have to do something like
07:25:42 <ski> (actually, i'll not sketch the code for this, since it's a bit work)
07:25:47 <Saizan> so the outer "type" doesn't correspond to the outer constructor?
07:27:05 <ski> but, you'd first have to convert `[[Flip f t0 t1]]' into `Compose [] [] (Flip f t0 t1)' .. *then* you'd match away the `MkFlip' constructor, getting `Compose [] [] (f t1 t0)', and the you remove the `Compose' again to get `[[f t1 t0]]'
07:27:25 <ski> Saizan : which out type ?
07:27:32 <ski> s/out/outer/
07:27:55 <ski> ah
07:27:57 <quicksilver> I think there is already a syntac problem just with Compose
07:27:58 <Saizan> [] here
07:28:01 <quicksilver> I use it sometimes
07:28:12 <ski> Saizan : well, that's a definition problem
07:28:13 <quicksilver> (something like newtype Compose f g a = O (f (g a))
07:28:24 <quicksilver> and it's nice in theory, and nice because of derived instances
07:28:27 <Saizan> ski: i guess
07:28:27 <quicksilver> but it's ugly ugly to use.
07:28:30 <ski> what is the "outer" (data) constructor ?
07:28:35 <ski> in fact
07:29:22 <ski>   case Just blah :: Maybe (Flip f t0 t1) of
07:29:28 <ski>     MkFlip x -> x
07:29:37 <ski>   :: Maybe (f t1 t0)
07:29:58 <ski> quicksilver : yes ?
07:30:30 <Saizan> that looks like black magic..
07:30:43 <ski> Saizan : so you see, in a sense `MkFlip' is a virtual constructor .. can be added and removed at will at some places, not necessarily matching each other in "pairs"
07:31:34 <ski> matching on `MkFlip' here unwraps the `Flip f t0 t1' in
07:31:39 <ski> a context
07:32:08 <quicksilver> ski: well you just get Os all over the place
07:32:17 <quicksilver> ski: and they don't feel very intuitive.
07:32:27 <ski> (that is restricted to be of form `\alpha -> t alpha' here .. so `\alpha -> Maybe (Maybe alpha)' is not ok)
07:32:32 <quicksilver> it's only really comfortable for hte instances you can pull through the O
07:32:57 <ski> quicksilver : i'm not sure exactly what you mean
07:33:15 <ski> (i know of problems with it .. i just don't know if you're referring to those or not)
07:33:52 <quicksilver> ski: I think I just find the order you have to unwrap things with 'case' feels unintuitive
07:33:59 <quicksilver> case foo of O(Foo(Bar(x)))
07:34:23 <ski> (also, i forgot to mention that we really want some restriction on how `k' is used in the definition of `Flip' above ..)
07:34:44 <ski> quicksilver> :t foo
07:35:11 <ski>   foo :: Compose Foo Bar blah -- ?
07:35:20 * quicksilver nods
07:36:15 <ski> (s/definition of/kind of type definition exemplified by/)
07:37:41 <ski> but anyway, sometimes it's like you have to explicitly associate and massage the type of the expression around by constructing and deconstructing with various restructuring combinators (of which `Flip' and `Compose' are just two)
07:37:53 <ski> which might not always be so pleasant
07:37:59 <quicksilver> yes.
07:38:17 <quicksilver> in particular, the constructors are isomorphisms
07:38:25 <quicksilver> so it's annoying when they are syntactically heavy
07:38:31 <quicksilver> since they're semantically obvious.
07:38:35 <ski> but, i think this at least solves the problem of wanting the type expression in the body of the definition to have kind `*'
07:38:50 <ski> (not needing to consider "lifted" `->' as previous above)
07:39:04 <ski> quicksilver : aye
07:39:46 <ski> (though use has to watch out for introducing turing-completeness in any automatic implicit rewriter of types)
07:42:44 * ski wonders why `_' and `undefined' is used at <PolymorphicKinds>, instead of having a constructor `P :: forall_kind k. forall (a :: k). Proxy a' on which to match and pass
07:43:11 <Saizan> x :: [Flip f t0 t1], y = head x :: Flip f t0 t1, now i can't pattern match on MkFlip there, but i could "case Just y of MkFlip z -> z :: Maybe (f t1 t0)" ?
07:43:29 <ski> yes
07:43:34 <ski> you could even
07:43:38 <ski>   case Just y of
07:44:00 <ski>     MkFlip (Just z) -> z :: f t1 t0
07:44:16 <ski> (though it would probably be better to use `Identity' in this instance)
07:44:59 <pozic> I want to take elements from a list until and including the condition is true. What's the best function to use for that?
07:45:41 <Hunner> pozic: how about takeWhile
07:45:43 <lilac> presumably Flip here is a type rather than a newtype?
07:45:45 <ski> @botsmack
07:46:05 <ski> lilac : no ! that wouldn't work operationally at all
07:46:28 <lambdabot> :)
07:46:33 * Saizan wonders how Flip works at the value level anyway
07:46:48 <ski> (lilac : hm .. by `type' i took you meant `data'-type .. did you mean type synonym)
07:47:04 <lilac> ski: yes, type synonym
07:47:07 <ski> Saizan : it's a `newtype', same as other such
07:47:22 <lilac> 'Just y' is not a Flip f t0 t1 if Flip is a newtype
07:47:23 <ski> > span (< 5) [0..9]
07:47:25 <lambdabot>   ([0,1,2,3,4],[5,6,7,8,9])
07:47:26 <pozic> f p xs  = let (a,b) = span (not p) xs  in a ++ (if null b then [] else [head b])
07:47:49 <pozic> So, I was looking for f, basically.
07:47:59 <lilac> ski: unless you're proposing some kind of newtype implicit conversion?
07:48:18 <ski> lilac : but `Just y' is a `k (Flip f t0 t1)' for some `k' !
07:48:24 <pozic> Hunner: you didn't note the including part of the specification.
07:48:27 <ski> <ski>   newtype k (Flip f t0 t1) = MkFlip {unFlip :: k (f t1 t0)}
07:48:44 <ski> note that `MkFlip' is really a constructor of `k (Flip f t0 t1)'
07:49:15 <ski> (that type is declared isomorphic to `k (f t1 t0)', for every `k')
07:49:35 <ski> (just to make clear, `k' there is a type, not a kind ..)
07:49:36 <lilac> i see now. that's mind-bending, but i like it
07:49:48 <ski> of course
07:50:36 <ski>   newtype k Foo = F ([k Int])
07:50:42 <ski> should not be allowed
07:51:23 <Hunner> pozic: if your list is Ord then can you just use (<= cond) and it will be up to and including?
07:51:33 <yrlnry> Why should that not be allowed?
07:51:34 <ski> (that would allow trying to match a value in any type of form `t0 t1' to a list constructor .. not nice)
07:52:04 <ski>   case Just blah :: Maybe Foo of
07:52:33 <ski>     F (x:xs) -> (x,xs) :: (Maybe Int,[Maybe Int])
07:53:02 <pozic> Hunner: it's not Ord, but never mind, I will just extend my utilities library.
07:53:03 <ski> treating a `Just ...' as a `... : ...' at run-time should not be allowed
07:54:09 <lilac> ski: so you require 'newtype k (t1) = Constructor k (t2)' where t1 and t2 don't mention k?
07:54:10 <pozic> I developed something for the first time from a slow specification with list-comprehensions to something fast. I never thought that worked for a real problem, even though some papers claimed that it did.
07:54:16 <ski> (lilac : so, no implicit conversion, no)
07:54:38 <pozic> As a bonus, the code is trivial to understand and to see that it is correct.
07:54:43 <ski> (lilac : itym add another paren pair ..)
07:54:55 <lilac> yes :)
07:55:09 <ski> lilac : that would be a safe conservative approximation .. but i'm thinking we can maybe do better
07:55:22 <lilac> so the rule is, the outer tycon needs to remain outside (in order to not break polymorphism)
07:56:24 <ski> consider again
07:56:45 <ski>    newtype c (Flip f t0 t1) = MkFlip {unFlip :: c (f t1 t0)}   -- renamed `k' to `c' to avoid confusion with kinds
07:56:50 <ski> what does this mean ?
07:57:20 <ski> it means some types are isomorphic, with given isomorphism
07:57:38 <lilac> specifically, c (Flip f t0 t1) can be constructed and pattern matched with MkFlip
07:57:49 <ski> but, this is actually defining a family of pairs of types to be isomorphic, at the same type
07:57:52 <ski> just as
07:57:56 <lilac> and c (f t1 t0) can be constructed with unFlip
07:58:02 <pozic> ski: newtype c (Flip f t0 t1) is new syntax?
07:58:09 <ski>   newtype MaybeMaybe a = MM (Maybe (Maybe a))
07:58:14 <lilac> pozic: thought experiment
07:58:45 <ski> is saying `MaybeMaybe a' is iso to `Maybe (Maybe a)', *for*each*type* `a' (of kind `*')
07:59:02 <ski> pozic : yes, in our minds
07:59:18 <ski> so, for flip, we really are saying something like
07:59:40 <ski>   forall_kind (k0 :: **) (k1 :: **) (k2 :: **).
08:00:17 <lilac> ski: would it be possible to have a value :: Flip f t0 t1 ?
08:00:19 <ski>     forall (c :: k2 -> *) (f :: k1 -> k0 -> k2) (t0 :: k0) (t1 :: k1).
08:00:20 <lilac> or is that not a type?
08:00:57 <ski>       MkFlip :: c (f t1 t0) -> c (Flip f t0 t1)
08:01:10 <ski>       unFlip :: c (Flip f t0 t1) -> c (f t1 t0)
08:01:35 <ski>       MkFlip (unFlip y) = y
08:01:41 <ski>       unFlip (MkFlip x) = x
08:02:11 <ski> lilac : you can sure have a value of type `Flip f t0 t1', yes
08:03:15 * ski tries to remember what tentative conclusion he arrived at that awhile ago ..
08:04:21 <ski> right
08:04:34 <ski> note that `k0' is *polymorphic* over this definition
08:04:57 <ski> s/k0/k2/ i mean actually
08:05:16 <ski> `k2' being the result kind of `f' and `Flip'
08:05:25 <ski> so, in
08:05:34 <ski>   newtype k Foo = F ([k Int])
08:05:52 <lilac> ok, so two questions: 1) can you give an example of using it, and 2) is it useful?
08:05:57 <ski> this requirement is not satisfied
08:06:05 <Stinger> @index if'
08:06:06 <lambdabot> bzzt
08:06:26 <ski> because the argument kind of `[]' is `*', so it can't match a polymorphic/rigid kind variable `k2'
08:06:44 <Stinger> bah whats that short form helper fn for if?
08:07:23 * ski ponders
08:07:33 <lilac> Stinger: if' is a @pl thing, not a real function
08:07:53 <ski> lilac : `it' being this whole extension idea ?
08:08:07 <Stinger> oh, hmm
08:08:07 <lilac> if' True t _ = t; if' False _ e = e
08:08:16 <lilac> or if' b t e = if b then t else e
08:08:33 <lilac> ski: yes.
08:08:52 <lilac> @pl if b then t else e
08:08:53 <lambdabot> if' b t e
08:10:21 <ski> lilac : well, i haven't really pondered very much about practical use, yet :) (i started by wanting a polymorphic `Flip') .. it might be i had some tree-structuring example when i was thinking about this, but i can't remember the details now (i have some scribbles on some paper somewhere .. i could try to find it, i suppose ..)
08:10:44 <ski> lilac : as for useful, ..
08:10:56 <ski> well, actually, i had one use i was thinking of
08:11:14 <ski> consider you're defining some new type
08:11:58 <ski> in the implementation you want to use `newtype', but that's more or less an implementation detail .. in any case, representation is not exported, only the type constructor itself
08:12:20 <ski> (well, actually, i don't think we need this restricton on export ..)
08:12:28 <ski> so, say stacks
08:12:37 <ski>   newtype Stack a = S [a]
08:13:04 <ski> we have O(0) conversion between the abstract type and the representation type
08:13:08 <ski> but say we have
08:13:16 <ski>   xs :: [Stack a]
08:13:26 <ski> now we suddely has to `map' the conversion
08:13:54 <ski> getting O(n) (`n' length of the list), where we moreally should have O(0) (or at least O(1))
08:14:54 <ski> using the above idea, we could convert the stacks to lists without having to traverse down (and copy) to the elements whose representation view should be changed
08:16:36 <ski> if you have more complex types, like `Maybe (m (Stack a)) -> (Stack a,Stack a -> m ())' (for some `m')
08:16:50 <ski> you'd define a temporary `newtype' like
08:17:41 <ski>   newtype Temp m a here = MkT {unT :: Maybe (m here) -> (here,Stack a -> m ())}
08:17:56 <ski> marking the places you want to "convert" with the `here' above'
08:18:00 <ski> then use
08:18:05 <leimy> I've started trying to tackle what I think is a tricky problem due to my Haskell green-ness
08:18:30 <leimy> I have been trying to figure out the appropriate data types to use for capturing Bowling scores
08:18:35 <ski>   case MkT (blah :: Maybe (m here) -> (here,Stack a -> m ())) :: Temp m a (Stack a) of
08:19:04 <leimy> there's interesting rules on Bowling to make this a bit trickier than it seems at first.
08:19:11 <leimy> at least to me :-)
08:19:12 <ski>     MkS (MkT x) -> x :: Maybe (m [a]) -> ([a],Stack a -> m ())
08:19:15 <ski> where we have
08:19:31 <ski>   newtype k (Stack a) = S (k [a])
08:19:40 <ski> (s/S /MkS /)
08:20:08 <ski> lilac : you see ?
08:21:46 <ski> lilac : in any case, yes it is tedious to explicitly create temporary types, and it is annoying that one can't make then local to a definition, with some ambient non-local type variables in scope (so you wouldn't have to add them as parameters to the temporary type)
08:22:03 <ski> quite possibly, one can do something better
08:22:39 <ski> this was an experiment in exploring the `newtype k (...) = ...' idea
08:26:09 <ski> (actually, it occured to me above that you might want to allow curried `k', like `newtype k (MyMonadTransformer s m) a = MkS (k (StateT (s,Foo) (Cont Bottom) m) a)')
08:26:52 <ski> (that way you could "replace" `MyMonadTransformer s m' subexpressions not being of the `MyMonadTransformer s m a' form)
08:27:24 * ski idly wonders if he's only talking to himself, now
08:27:38 <edwardk> ski: not entirely
08:27:46 * dmwit_ is listening
08:27:55 <ski> evening, edwardk :)
08:28:13 <edwardk> ski: how goes?
08:28:55 <ski> (s/(Cont Bottom) m/(ContT Bottom m)/ actually)
08:29:18 <ski> more or less ok, i suppose
08:31:20 <lilac> ski: i'm listening too, and hoping repeated reading will help :)
08:33:52 <edwardk> ski: so if i get this straight you're basically proposing a kind of destructuring newtype to help write near arbitrary type functions?
08:35:14 <ski> (one specific occasion where i've wanted to "nestedly" replace newtypes is in defining monads and monad-transformers and the like .. say you have `forall a b. (..a..) -> (a -> (..b..)) -> (..b..)' where each `x |-> ..x..' is the same type function, and you've newtyped this into a type `M' so you want to get `M a -> (a -> M b) -> M b' .. but *without* having to type boring boiler-plate code to "focus" down to the places where 
08:35:33 <edwardk> er wait, no i apparently misunderstood
08:35:40 <ski> edwardk : depends on what you mean by "near arbitrary type functions" :D
08:37:22 <ski> lilac : probably i'm not explaining all the subtleties (and surely i've not found all yet .. just explored this a bit) very well .. i hope you at least get some rough idea of the what it's about
08:37:23 <edwardk> I was parsing your newtype syntax a different way. I was reading newtype Foo (Bar x) = Foo x      like it was a type family with a single definition, but that on ereading further back differs from your interpretation
08:37:43 <Saizan> you got truncated on "down to the places where"
08:37:59 <ski> down to the places where to replace, and *without* the corresponding run-time overhead of this ... here `newtype'-deriving can help a lot, as an alternative solution .. hmhm)
08:39:49 <ski> (re, `newtype'-deriving .. that would only work in the specific case of wanting to "reuse" class instances with the minimum of work .. not for general value definition)
08:40:17 <edwardk> so basically you're looking for language support for scrap your boilerplate ;)
08:40:42 <ski> (not as in `SYB', no)
08:41:43 <ski> (two other related things would be the "restricted type-synonyms" of HuGS, and abstractly exporting a type-synonym in the MLs)
08:42:53 <ski> (but in some cases i think i'd prefer being able to export a way to locally identify the abstract type with the representation .. hmm)
08:44:45 <ski> (.. consider if `newtype Foo = F Bar' would automatically yield a value of type `Equal Foo Bar' .. then you could pass that value to places where you match on its constructor `Refl', thereby informing the type-system that two *concrete* types `Foo',`Bar' are to be considered in a specific context .. this could maybe be a nice idea ?)
08:45:37 <Baughn> "<p_l> Basically I want to have a  single "Tree" which could be updated from different places, with listeners getting  notified when their "view" of the tree has changed" <-- I suggested using reactive, but I haven't actually used it myself yet. He'll probably be in here later.. still, does that make sense?
08:46:51 * ski continues mumbling on in the corner for awhile, occasionally glancing wildly around
08:48:31 <Saizan> (like in System Fc?)
08:49:24 <Saizan> no, there you've to apply the coercions, iirc
08:50:54 <Baughn> ski: So, if I haven't misunderstood too horribly.. for "newtype Foo = Foo Int", "map Foo bar" is basically "map id bar" at the machine level, and you want that to be compiled to just "bar"?
08:52:42 <Baughn> ski: Are you sure it isn't already, with -O? ;)
08:52:48 <ski> Saizan : (checking System Fc on ghc wiki) yes, i think that last comment was actually me thinking one could use that coercion idea together with my thing
08:53:08 <ski> Baughn : it may well be in that specific case .. but generally ?
08:53:36 <Baughn> ski: It should be easy
08:53:50 <Baughn> The language always knows if it's a newtype, after all
08:54:18 <ski> it would have to recognize that `map' with an O(0) operation should be O(0), no ?
08:54:37 <Baughn> It'd mostly just have to recognize that map id = id
08:54:52 <ski> (say `maqTree' .. how does it know that `mapTree' is a functor map ?)
08:55:25 <Baughn> Mm, that would be a bit more complex
08:55:34 <ski> maybe it could store such inferred information in compiled interface files, for use with separate compilation
08:55:40 <Baughn> It does
08:55:51 <Baughn> I don't believe this is actually a performance concern in real programs, but there's also RULES
08:55:54 <ski> (when i said `map' above, i really meant a functor map for any functor)
08:56:25 <Baughn> The problem is, of course, that fmap for some functor can do more work than just what the function you pass to it does
08:56:35 <Baughn> It'd be bad style, but not illegal
08:56:42 <ski> you are probably quite right that it would not in usual circumstances be a performance problem
08:57:10 <Baughn> And when it is, we have a cheap (and dirty) way of making the compiler smarter. Still..
08:57:11 <ski> (maybe it would be better to have language-generated maps .. and catas ?)
08:58:17 <ski> my investigation was really an exercise in seeing how far this idea could be pushed, and whether any interesting side-ideas or realizations would fall out of it
08:58:24 <Baughn> The compiler could at least determine that some higher-order function creates a new structure that is identical to the old one except where it passes it through the supplied function.. for simple cases
08:59:23 <ski> (/me can think of more complicated cases)
09:00:06 <Saizan> deforestation applies to all datatypes, right?
09:00:42 <quicksilver> in GHC? I don't believe so.
09:00:48 <quicksilver> unless you mean SpecConstr
09:00:54 <quicksilver> which is only a very very simple case of deforestation.
09:01:43 <ski> (s/maq/map/ .. apparently i'm tired)
09:02:29 * ski haf'ta leave
09:08:22 <dons> Saizan: hmm?
09:09:00 <dcoutts> g'morning dons, going out to vote today? :-)
09:09:19 <teratorn> could someone explain the rational behind not having a 'Bool' typeclass? My brain is used to being able to use arbitrary values where a boolean is expected.
09:09:43 <teratorn> but in Haskell this doesn't work the way I'm used to, and I'm just wondering how it came to be like this
09:09:48 <quicksilver> teratorn: is it really that hard to type "if foo /= 0 then" ?
09:09:57 <quicksilver> because it's certainly much clearer IMO
09:10:04 <dcoutts> teratorn: simplicity probably
09:10:07 <quicksilver> and it's only 5 chars extra including spaces :)
09:10:28 <dcoutts> teratorn: having a bool type class would be useful for BDDs though
09:10:40 <Deewiant> and you can save two chars by leaving out the spaces
09:10:40 <dcoutts> but we typically do not like to use implicit casting
09:10:43 <teratorn> quicksilver: well you can take that mindset too far, I think... e.g. O'Caml has different operators that deal with comparing and adding ints vs. floats
09:10:59 <teratorn> so, having different operators is "more clear" in some way
09:11:04 <teratorn> because you can infer the type in place
09:11:17 <dcoutts> teratorn: there's some distinction between implicit casting and class-based polymorphism
09:11:53 <quicksilver> well presumably "if" the operator you would overload here
09:12:10 <quicksilver> ... "if" is the operator ...
09:12:13 <quicksilver> I mean ;)
09:12:21 <teratorn> dcoutts: BDDs?
09:13:00 <dcoutts> binary decision diagrams, used in modelling and verifying digital circuits
09:13:34 <dcoutts> quicksilver: right, a Boolean type class with the logical operators, and 'if' would use it too
09:13:43 * quicksilver nods
09:14:24 <dcoutts> eg Intel's functional programming language 'FL' has that
09:14:41 <dcoutts> though not with quite so much typing discipline
09:14:50 <teratorn> is it possible to "extend" or replace the built-in functions/types to support a Bool typeclass? something like "extension methods" in C#? I know it would be a bad idea to actually do it, but I'm just wondering how flexible haskell is...
09:15:07 <quicksilver> you can replace everything except "if"
09:15:12 <quicksilver> "if" happens to be a keyword.
09:15:19 <quicksilver> (if that bugs you, don't use it :P )
09:15:26 <teratorn> I see
09:15:38 <teratorn> nasty keywords :)
09:15:48 <quicksilver> you can define your own && and || and so on, no problem there.
09:15:53 <ToRA|MSR> guards?
09:15:55 <quicksilver> of course, that wouldn't make modules use them
09:16:02 <quicksilver> scope is lexical not dynamic
09:16:33 <teratorn> quicksilver: yeah that's the key part of the question... "extending" the existing functions so that everything uses the extended version
09:17:46 <Saizan> no, they should have defined to use a typeclass in the first place
09:18:32 <Saizan> "have been"
09:27:40 <ketil> Hm.. with Data.Binary, I need to find next offset that's aligned on an 8-byte boundary.
09:27:45 <ketil> Any idea?
09:28:38 <wjt> ketil: i did this by wrapping the Binary monads with a StateT to track the current position and added an alignTo action
09:29:14 <ketil> wjt: Okay.  No shortcuts, then :-/
09:30:05 <quicksilver> I think the problem is that it's sane to "nest" Puts
09:30:09 <jeffersonheard> once I get a (PixbufData i e) object, what functions can I use to read it?
09:30:27 <quicksilver> and if you "nest" Puts then the current Put doesn't know what its offset was
09:30:31 <quicksilver> or where you want to align to
09:30:33 <jeffersonheard> I need to poke the contents into a Ptr Word8
09:31:00 <_pizza_> newbie here. ghci foo.hs where foo.hs = "import Array\n array (0,1) [(0,"QQQ")] ! 0" produces a parse error while the fully-qualified equivalent using Array.{array,!} works when typed in; why?
09:32:09 <quicksilver> jeffersonheard: as I recall, the only access to a Pixbuf is via its MArray instance.
09:32:22 <quicksilver> pizza: because that's not a program.
09:32:25 <quicksilver> pizza: it's an expression.
09:32:34 <quicksilver> pizza: (plus an import statement)
09:33:16 <quicksilver> try, e.g. "import Array\n myfavouritevariablename = array (0,1) [(0,"QQQ")] ! 0
09:33:28 <_pizza_> ok
09:33:40 <jeffersonheard> So would this (http://hpaste.org/11731) then be the most efficient way of doing it, quicksilver?
09:34:21 <_pizza_> quicksilver: i see; i assumed a "final" assignment wouldn't be necessary, thanks
09:34:47 <kowey> Riastradh suspects that he is the only person on the planet that wants to run GHC on NetBSD/macppc
09:34:52 <quicksilver> jeffersonheard: well it might be faster to use 'getElems' which gives you all of them at once.
09:34:52 <kowey> anybody want to challenge that?
09:35:04 <quicksilver> kowey: no, I think Riastradh is almost certainly right ;)
09:35:17 <quicksilver> jeffersonheard: it would certainly be more pleasant code.
09:35:20 * kowey chuckles
09:35:27 <quicksilver> jeffersonheard: withArray + getElems
09:35:45 <jeffersonheard> quicksilver: I didn't see that one.  SHould be able to use pokeArray
09:35:50 <jeffersonheard> + getElems
09:36:02 <kowey> tsk... worth a shot... that and people on playstation 3s are two examples of darcs being hurt by it's choice of Haskell :-D
09:36:21 <kowey> (of course, we are helped in many ways by our choice of Haskell, so we're not complaining too loudly)
09:36:55 <Riastradh> This is an example more of where GHC's monstrous complexity hurts Haskell than of anything else...
09:37:03 <quicksilver> kowey: yeah but the solution ot that problem is for GHC for work on more platforms.
09:37:14 <quicksilver> GHC certainly works on OSX/macppc
09:37:20 <yebyen> ghc is monstrously complex
09:37:24 <quicksilver> so presumably it's not unfeasible for it to work on BSD/macppc
09:37:37 <jeffersonheard> quicksilver: look better? pixbufGetPixels pbuf >>= A.getElems pdata >>= pokeArray pbuf >>= GL.PixelData GL.RGB GL.UnsignedByte
09:37:38 <kowey> ok, why does GHC not work on more platforms? or rather, how can we mitigate the effects of this monstrous complexity?
09:37:44 <quicksilver> jeffersonheard: yes.
09:37:49 <jeffersonheard> I think so too
09:38:03 <quicksilver> (assuming it type checks ;P )
09:38:07 <yebyen> does anyone know about "pretty-1.0.0.0, which is hidden"
09:38:22 <quicksilver> probalby means it's a missing dependency of that package you are trying to compile
09:38:30 <kowey> how can I as a darcs hacker with little ability to do much non-darcs work make progress on people running darcs on PlayStation 3?
09:38:47 <quicksilver> which in turn probably means that package was set up for an older version of ghc.
09:39:04 <quicksilver> kowey: I would like to answer that question, but I do not myself know the answre.
09:39:21 <dcoutts> yebyen: http://haskell.org/haskellwiki/Cabal/FAQ
09:39:21 <quicksilver> does a unregisteristed ghc 6.4 compile on PS3?
09:39:22 <lambdabot> Title: Cabal/FAQ - HaskellWiki
09:39:35 <cnwdup> @src map
09:39:46 <lambdabot> map _ []     = []
09:39:46 <lambdabot> map f (x:xs) = f x : map f xs
09:39:53 <quicksilver> http://hackage.haskell.org/trac/ghc/wiki/SonyPS3
09:39:59 <lambdabot> Title: SonyPS3 - GHC - Trac
09:40:17 <yebyen> dcoutts: quicksilver: here's the thing, it doesn't seem to use cabal
09:40:20 <cnwdup> > map (toDyn . fromDyn) [toDyn "String", toDyn 42]
09:40:23 <lambdabot>   Add a type signature
09:40:26 <yebyen> oh wait
09:40:28 <yebyen> i'm stupid
09:40:41 <dcoutts> yebyen: where "it" = ???
09:40:43 <cnwdup> > (map (toDyn . fromDyn) [toDyn "String", toDyn 42]) :: [Dynamic]
09:40:44 <kowey> hmm, the user in question is running on Fedora (on PS3)
09:40:45 <lambdabot>   Add a type signature
09:40:56 <cnwdup> To what? :-D
09:41:04 <cnwdup> > (map (toDyn . fromDyn) [toDyn "String", toDyn (42::Int)]) :: [Dynamic]
09:41:05 <lambdabot>   Add a type signature
09:41:09 <quicksilver> cnwdup: you need a type signature inbetween fromDyn and toDyn, in principle
09:41:18 <quicksilver> cnwdup: otherwise how does it know which fromDyn to use?
09:41:25 <cnwdup> Ah, right.
09:41:36 <kowey> perhaps it would be good somehow to encourage people porting GHC to obscure hardware platforms to do the work in a way that makes it more independent of favourite OS?
09:41:50 <quicksilver> :t fromDyn
09:41:51 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
09:41:52 <yebyen> dcoutts: that was the confusion... i'm trying to compile hikij, which uses a makefile.  but actually, i need dbdirect which comes from haskelldb
09:41:54 <kowey> (and thanks for the attempts at answering that question!)
09:42:07 <yebyen> dcoutts: and so, cabal install haskelldb is what's generating the error message
09:42:15 <quicksilver> > map (toDyn . (fromDyn :: Dynamic -> String)) [toDyn "String", toDyn 42]
09:42:16 <lambdabot>   Couldn't match expected type `String'
09:42:24 <cnwdup> map (show . fromDyn) [toDyn "String", toDyn 42]
09:42:30 <cnwdup> > map (show . fromDyn) [toDyn "String", toDyn 42]
09:42:31 <lambdabot>       Overlapping instances for Show (a -> a)
09:42:31 <lambdabot>        arising from a use of `s...
09:42:32 <teratorn> if GHC can target C, then I wonder why it's hard to compile for obscure platforms
09:42:39 <quicksilver> teratorn: GHC can't target C.
09:42:41 <quicksilver> (that's why)
09:42:43 <dcoutts> yebyen: right, so you either need to update haskelldb to ghc-6.8 or use ghc-6.6
09:42:53 <teratorn> huh, I thought I read it somewhere
09:42:55 <quicksilver> kowey: in fact, I think the problems are actually not major.
09:43:10 <quicksilver> kowey: they're just a bit fiddly. The link I pasted showed that fedora got ghc on PS3...
09:43:21 <dcoutts> quicksilver: unregisterised ghc builds use fairly ordinary C
09:43:27 <quicksilver> dcoutts: but they don't work :)
09:43:37 <dcoutts> quicksilver: why?
09:43:37 <quicksilver> teratorn: it's supposed to be able to but it's a bit broken.
09:43:40 <kowey> oh indeed! the complaint was that the ghc package available on fedora wasn't working
09:43:40 <quicksilver> dcoutts: don't ask me.
09:43:53 <quicksilver> I believe they last worked properly in 6.4
09:43:59 <kowey> b0rked would the be user's word of choice
09:44:00 <dcoutts> that's nonsense
09:44:13 <dcoutts> I use an unregisterised build of ghc-6.8 on sparc
09:44:18 <yebyen> dcoutts: you mean, update haskelldb package in cabal... i think i'll compile ghc-6.6, and go figure out where to vote
09:44:35 <quicksilver> dcoutts: really?
09:44:35 <quicksilver> hmph.
09:44:42 <dcoutts> quicksilver: all of debian's builds except on x86, x86-64 and ppc are unregisterised
09:44:52 <dcoutts> and there's about 5 of those iirc
09:44:59 <quicksilver> dcoutts: whenever anyone asks about porting to a new architecture, they are always told they can't, because unregisterised builds are broken.
09:45:02 <quicksilver> why are they told that, then?
09:45:03 <dcoutts> alpha, hppa, mips, arm, something else
09:45:11 <dcoutts> quicksilver: who says that, where?
09:45:19 <thoughtpolice> dcoutts: on the ghc wiki porting page: "Versions supported: between 6.0.1 and 6.6.2"
09:45:24 <dcoutts> quicksilver: no, that's HC bootstraping
09:45:58 <dcoutts> which is quite a different thing, but yes is needed for porting to a new arch
09:46:12 <quicksilver> ah.
09:46:16 <thoughtpolice> oh, so you already had ghc binaries for the sparc box already and just built unregistered?
09:46:19 <quicksilver> I apologise for spreading misinformation.
09:46:24 <quicksilver> dcoutts: but why are they not the same thing?
09:46:25 <dcoutts> thoughtpolice: right
09:46:33 <quicksilver> dcoutts: if an unregisterised build is standard C
09:46:38 <quicksilver> why can it not be used for bootstrapping?
09:46:54 <Riastradh> dcoutts, so suppose I have no PowerPC machines except for this one running NetBSD.  What would it entail to get GHC to run on this platform?
09:46:54 <dcoutts> quicksilver: because it's also cross-compilation you're doing
09:47:35 <quicksilver> Riastradh: does netbsd/ppc have a binary compatibility layer for linux/ppc ?
09:47:42 <thoughtpolice> Riastradh: http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
09:47:45 <lambdabot> Title: Building/Porting - GHC - Trac
09:47:48 <quicksilver> Riastradh: could you start with the debian binary and work from that?
09:47:51 <Riastradh> quicksilver, in theory, yes, but I think it has bitrotten over the years.
09:47:52 <dcoutts> Riastradh: and you're saying that nobody has ever got ghc working on that platform ever before?
09:47:57 <Riastradh> dcoutts, I doubt it.
09:48:05 <Riastradh> dcoutts, I doubt whether anyone has ever tried.
09:48:05 <thoughtpolice> if you already have a binary of ghc for ppc netbsd (something like 6.0 or 6.2) then you can build an unregistered one like dcoutts
09:48:24 <dcoutts> Riastradh: then you should port ghc-6.4.2 or something and use that to build a modern ghc version, like 6.8.2
09:48:45 <quicksilver> dcoutts: so the unregistered builds encode architecture dependent things in the C it produces?
09:48:52 <dcoutts> Riastradh: but yes, obviously if there's any old binary version around then use that
09:48:59 <dcoutts> quicksilver: yes
09:49:04 <quicksilver> ah.
09:49:05 * quicksilver nods
09:49:12 <quicksilver> is better informed for next time this question comes up.
09:49:23 <dcoutts> quicksilver: since often the Haskell source has arch dependent things, since it uses hsc2hs
09:49:48 <dcoutts> and uses platform-dependent cpp
09:50:09 <Riastradh> (Bear in mind that I don't actually have time to do much porting work.  So this is probably not going to happen.)
09:52:00 <quicksilver> kowey: to summarise, then, the problems aren't really *big*. It's not that GHC is totally broken w.r.t other archs.
09:52:15 <quicksilver> kowey: it's just that it's not a very welltrodden path and there aren't many people to help you if you get stuck, in here.
09:52:22 <quicksilver> kowey: glasgow-haskell-users is a very helpful mailing list though
09:52:23 <kowey> nod
09:52:29 <kowey> many thanks!
09:52:41 <kowey> so in the future, if this comes up in #darcs
09:52:53 <kowey> I shall point them to glasgow-haskell-users (after the usual google)
09:54:32 <maltem_> Since people are talking bootstrapping now, I'll repeat an old question: I was going to bootstrap ghc on a cluster account, starting with cross-compiling ghc 6.6.1. But it uses System.Directory.Internals, which has been abandoned in favor of filepath. What would be the wisest thing to do now?
09:55:13 <maltem_> Should I install ghc 6.6 on my machine first? ...
10:00:10 <dons> maltem_: what machine?
10:03:11 <dcoutts> maltem_: I'd be surprised if you really had to bootstrap anything
10:03:30 <dcoutts> unless you're working with fairly exotic hardware
10:11:15 <yebyen> dcoutts: should I expect cabal to work at all with ghc-6.6?
10:11:35 <dcoutts> yebyen: yes, the latest release should work with ghc-6.4+
10:11:50 <yebyen> dcoutts: <interactive>: /home/hpaste/.cabal/lib/Cabal-1.4.0.2/ghc-6.6.1/HSCabal-1.4.0.2.o: unknown symbol `__DISCARD__'
10:12:01 <dcoutts> yebyen: your ghc is borked
10:12:22 <yebyen> i just used the binary distribution...
10:12:24 <dcoutts> yebyen: your version of ghc is probably incompatible with the version of gcc you're using
10:12:27 <yebyen> aha
10:12:29 <maltem_> dons, dcoutts: No exotic hardware at all, but I have nothing more than user privileges on the cluster
10:12:53 <dcoutts> maltem_: so install a bindist, they can be installed in $HOME
10:13:19 <dcoutts> yebyen: or compile with -fasm or without -O
10:13:25 <yebyen> dcoutts: i had to downgrade my gcc when I tried compiling ghc 6.8.3, i'm using 3.4.6
10:13:43 <maltem_> dcoutts: I tried a .tar.gz from the ghc site, but it's compiled against a different glibc version than what's on the server
10:13:46 <dcoutts> yebyen: what arch btw?
10:13:51 <yebyen> dcoutts: x86_64
10:13:54 <yebyen> amd64
10:13:59 <dcoutts> maltem_: try and older one, eg 6.8.2
10:14:20 <maltem_> hmm I'll have a look
10:14:43 <dcoutts> yebyen: ok, try -fasm if you're using ghc-6.6.x, that avoids going -fvia-C and the incompatibility with gcc
10:15:58 * dcoutts notes that Igloo just released ghc-6.10.1
10:16:48 * dcoutts wonders if kolmodin will beat dons to announcing support on gentoo vs arch
10:16:59 <dcoutts> kolmodin: go! go! go!
10:17:03 <yebyen> dcoutts: -fasm is that a flag for configure?
10:17:09 <Igloo> Is arch a source dist?
10:17:34 <dcoutts> yebyen: yes, runghc Setup.hs configure --ghc-options=-fasm
10:17:42 <dcoutts> Igloo: mostly binary
10:18:03 <yebyen> dcoutts: whoa i thought we were compiling ghc...
10:18:38 <dcoutts> yebyen: ah, then it's somewhere in the mk/build.mk, HC_SRC_OPTS or something, check mk/build.mk.example
10:18:51 <dons> ghc 6.10!!
10:19:14 <dcoutts> dons: keep up! It's been out for 7 minutes already ;-)
10:20:15 <dons> i was on it :)
10:20:26 * dcoutts expects to see it announced on reddit shortly
10:20:31 <dons> yes....
10:21:00 <RayNbow> ...and I just recently installed 6.10.0.20081007 :p
10:22:07 <dons> http://www.reddit.com/r/programming/comments/7bav8/ghc_610_released_type_families_data_parallelism/
10:22:10 <lambdabot> Title: GHC 6.10 released! Type families, data parallelism, parallel garbage collector!  ..., http://tinyurl.com/5ra23k
10:22:11 <dons> woo!!
10:22:32 <dons> well done ghc team
10:23:32 <maltem_> dcoutts: wow, it was as easy as that! thank you for keeping me from the hassle of bootstrapping :)
10:23:43 <dcoutts> maltem_: great
10:23:44 <dons> i hadn't realised the parallel GC snuck in.
10:23:53 * jmelesky is excited about the generalized list comprehensions
10:24:57 <RayNbow> http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/syntax-extns.html#generalised-list-comprehensions <-- awesome :)
10:24:59 <lambdabot> Title: 8.3.ï¿½Syntactic extensions, http://tinyurl.com/5fwzgd
10:25:18 * maltem_ goes on to 6.10 and will welcome any hints to prepared parallel tests/benchmarks/coolness
10:26:18 <BONUS_> awesome
10:26:54 <jmelesky> ooh, pattern guards
10:28:23 <dons> view patterns
10:28:37 <dons> i tried to summarise here, http://www.reddit.com/r/programming/comments/7bav8/ghc_610_released_type_families_data_parallelism/
10:28:40 <lambdabot> Title: GHC 6.10 released! Type families, data parallelism, parallel garbage collector!  ..., http://tinyurl.com/5ra23k
10:28:52 <jmelesky> sorry, "ooh, pattern guards got neater"
10:28:52 <luite_> ah cool, new toys :)
10:29:23 <RayNbow> dons: got any more info on the DPH part in the new GHC?
10:29:49 <RayNbow> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell <-- is this still up to date?
10:29:51 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
10:32:04 <BONUS_> view patterns own
10:35:26 <thoughtpolice> view patterns are a nice little extension
10:35:33 <thoughtpolice> RayNbow: i've done a couple of experiments
10:36:00 <maltem_> wait, ghc doesn't support building with gcc 4? surprising
10:36:09 <Igloo> Where does it say that?
10:36:20 <dons> maltem_: !?
10:36:37 <Beelsebob> maltem_: worksforme
10:37:20 <maltem_> configure: error: Need at least gcc version 2.0 (3.4+ recommended) -- this is with gcc 4.1.2 in scope
10:37:34 <maltem_> but I'll try the other gcc4's available first
10:38:43 <thoughtpolice> it should support 4.1 fine. the only recent problem I can really remember is that the 6.6 branch couldn't build with gcc 4.2, but i'm about to try to configure...
10:39:01 <thoughtpolice> (and yeah, that was like a year ago or something)
10:39:05 <dons> doesn't the mac only come with gcc 4.x ?
10:39:07 <Igloo> maltem_: What does gcc --version say? And what platform are you on?
10:39:17 <dons> maltem_: its false, in fact, i'm using only gcc 4.3.2
10:39:36 <maltem_> Igloo: firstly, if I switch to gcc 4.2.4 then it works
10:39:59 <thoughtpolice> dons: yeah xcode comes with an apple version of gcc 4.0
10:40:04 <thoughtpolice> you can get a build of 4.2 as well
10:40:12 <maltem_> the one where configure bails is this: gcc (GCC) 4.1.2 20070626 (Red Hat 4.1.2-14)
10:40:17 <Beelsebob> thoughtpolice: latest XCode comes with 4.2 as well
10:40:26 <thoughtpolice> beelsebob: 3.1?
10:40:30 <Igloo> maltem_: Oh, sorry, what does this say?  gcc -v 2>&1 | grep 'version '
10:40:40 <Beelsebob> http://images.stage6.com/channel_images/refuselife/46b04019063ef.jpg
10:40:42 <lambdabot> http://tinyurl.com/2z7v66
10:40:44 <Beelsebob> thoughtpolice: 3.1.1 IIRC
10:40:59 <thoughtpolice> beelsebob: ah cool
10:41:20 <maltem_> Igloo: gcc version 4.1.2 20070626 (Red Hat 4.1.2-14)
10:41:33 <maltem_> (not much difference to notice really ;-)
10:41:37 <thoughtpolice> beelsebob: yay didn't know, installing :]
10:41:44 <Beelsebob> :)
10:41:53 <Beelsebob> thoughtpolice: IIRC it's a ticky box in the optional installs
10:42:46 * dons wonders why the ghc release isn't showing up on reddit yet.
10:43:04 <jimstutt> dons: it just did eight minutes ago in uk.
10:43:10 * shapr boings
10:43:35 <dons> ok. so you can see it on programming.reddit ?
10:43:38 <thoughtpolice> beelsebob: well i'm having to download it
10:43:46 <Igloo> maltem_: OK, I can't see why that wouldn't work
10:43:47 <dons> ah yes.
10:43:52 <thoughtpolice> appshare can't upgrade it since you have to logon to apple ADC
10:44:04 <thoughtpolice> er, appfresh :]
10:45:22 <maltem_> Igloo: yeah mysterious. Perhaps a corrupted gcc install on the cluster, I don't really care that much to track this down
10:45:59 <Beelsebob> thoughtpolice: yeh, it's a pita that
10:50:40 <shapr> hei esap!
10:50:48 <esap> Hei
10:50:59 <esap> What's up?
10:51:08 <shapr> Hardware toys..
10:51:14 <shapr> What about you?
10:51:30 <esap> well, haven't got anything done :-)
10:51:54 <esap> so not much
10:52:08 <esap> shapr: what kind of HW toys?
10:52:16 <shapr> ibm bladeserver with dual cell blades
10:52:45 <shapr> I'll have to build ghc 6.10 myself, I bet...
10:53:27 <esap> anything interesting new there?
10:53:36 * esap goes for the docs
10:53:37 <shapr> 6.10 has lots of cool stuff!
10:54:42 <dons> mega cool.
10:54:51 <pozic> I have xs (containing a list of indices), an array named arr, and I want to find the first index for which the sum of the elements is greater than a value y. It should work for infinite lists. It's a foldl with an early exit, AFAIK. Since foldl with an early exit is not in the standard library. What's the standard way to solve this?
10:54:55 <dons> get out there and spread the word.
10:54:57 * esap just hit the deprecated flags list :-)
10:55:39 <Cale> pozic: first get hold of the list of sums
10:55:45 --- mode: ChanServ set +o dons
10:55:48 --- topic: set to '["GHC 6.10 is out!" http://twurl.cc/6wr, "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
10:56:08 <Cale> pozic: and then use dropWhile and head
10:56:18 --- mode: ChanServ set -o dons
10:56:51 <pozic> Cale: the list of sums is a foldr, right?
10:57:17 <mofmog> I think i'll learn haskell faster and better if i have to actually learn it
10:57:18 <mofmog> OR ELSE
10:57:35 <mofmog> I'm having trouble coming up with a suitable OR ELSE
10:57:35 <pozic> Cale: or a scanl.
10:58:13 <pozic> Cale: a scanl1, even
10:58:32 <lament> mofmog: learn it or we kill you
10:58:52 <Cale> pozic: yeah, scanl (+) 0
11:00:15 <mofmog> > scanl (+) 0 [1,2,3,4]
11:00:17 <lambdabot>   [0,1,3,6,10]
11:00:20 <pozic> Cale:  scanl (\index running_sum -> arr ! index Prelude.+ running_sum) 0 list
11:00:29 <pozic> Cale: that's what I had
11:00:36 <mofmog> > scanl (*) 1 [1,2,3,4,3,2,1]
11:00:38 <lambdabot>   [1,1,2,6,24,72,144,144]
11:01:02 <mofmog> > scanl (+) 1 [1,2,3,4,3,2,1]
11:01:04 <lambdabot>   [1,2,4,7,11,14,16,17]
11:01:05 <Cale> pozic: separate the indexing
11:01:08 <dons> shapr: i'm watching a talk about the design of a secure os kernel using indexed/dependent types.
11:01:10 <Cale> pozic: you can do it with map
11:01:19 <shapr> dons: cool!
11:01:24 <Cale> pozic: scanl (+) 0 (map (arr!) list)
11:01:41 <rwbarton> @hoogle IArray a e => a i e -> [e]
11:01:42 <lambdabot> Data.Array.Base elems :: (IArray a e, Ix i) => a i e -> [e]
11:01:42 <lambdabot> Data.Array.IArray elems :: (IArray a e, Ix i) => a i e -> [e]
11:01:42 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
11:03:14 <Cale> Interesting that GHC for libedit0 is a full 3 megabytes larger than GHC built for libedit2 :)
11:03:14 <pozic> Cale: how do you mean, "separate the indexing"?
11:03:31 <Cale> pozic: Don't do it in the function you pass to scanl
11:03:51 <Cale> pozic: map (arr !) listOfIndices
11:03:56 <pozic> Cale: oh, right, that is possible. I did understand you, just didn't see what you meant.
11:04:52 <pozic> Cale: aka, elems
11:04:53 <dolio> Oh man, 6.10 is out.
11:05:07 <pozic> Cale: never mind
11:05:24 <Igloo> Cale: The compression factor seems quite random
11:05:30 <rwbarton> pozic: Sorry, I thought at first you wanted all the elements of the array.
11:06:15 <Igloo> I don't know if that's what's going on there, though
11:07:46 <pozic> rwbarton: that's why I said never mind, since I was wrong.
11:08:20 <pozic> So, I had to CHANGE it ;)
11:08:48 * pozic hopes someone got the subtle joke. 
11:09:18 <BONUS_> i wrote in SPJ at my voting place
11:09:23 <BONUS_> SPJ/Philip Wadler 08
11:09:41 <Cale> BONUS_: Really?
11:09:47 <dons> BONUS_: haha
11:09:48 <BONUS_> haha no
11:09:51 <BONUS_> im not even american
11:09:53 <Cale> ah
11:09:59 <BONUS_> it would be fun though
11:10:08 <dons> BONUS++ is most dada-ist haskeller
11:10:16 <BONUS_> lol
11:10:22 <dons> i've seen your twitter page :)
11:10:24 <cnwdup> > map (show . toDyn) [toDyn "foobar", toDyn 42, toDyn ("foo", 12)]
11:10:25 <lambdabot>   ["<<Dynamic>>","<<Dynamic>>","<<Dynamic>>"]
11:10:33 <BONUS_> ah yeah, my little thought repository
11:10:41 <cnwdup> > map (show . fromJust . fromDynamic) [toDyn "foobar", toDyn 42, toDyn ("foo", 12)]
11:10:43 <lambdabot>   ["* Exception: Maybe.fromJust: Nothing
11:11:23 <cnwdup> Would this be working? Can I apply a function to a unwrapped dynamic value of which I don't really know the type but know it's an instance of a certain class?
11:11:53 <rwbarton> You can do it using existential types.  Not sure about Data.Dynamic, probably not.
11:12:18 <Cale> With Data.Dynamic, you have to unwrap it first, and you'll get Nothing if you try to unwrap the wrong type.
11:12:35 <cnwdup> But (Show a) => a isn't really a wrong type. ^^
11:12:51 <rwbarton> The only way it could work is if toDyn knew somehow to wrap up the class dictionary as well.
11:12:54 <Cale> If all you know about the type is that it's an instance of Show, why not just store a String?
11:13:23 <dons> happy ghc day everyone.
11:13:24 <Saizan> cnwdup: you can only unwrap a Dynamic to a monomorphic type
11:13:33 <cnwdup> cale: It's not actually the case. I was just -- aparently oversimplyfing -- my problem.
11:13:38 <Cale> ah, okay
11:13:47 <Cale> So you *probably* want an existential.
11:13:53 <esap> Cale: That works for Show, but what about other interfaces?
11:14:00 <Cale> But there are always ways to avoid using existentials.
11:14:05 <rwbarton> Or wrap the class dictionary manually yourself
11:14:17 <Cale> You can always store a record of functions pre-applied to your value.
11:14:27 <rwbarton> although, that probably doesn't make sense in general.  Yeah, you can do what Cale said though.
11:14:31 <Cale> (all the functions of the appropriate interface)
11:14:53 <ddarius> Cale: In theory (maybe)
11:14:55 <cnwdup> Mh, that might be worth a thought. Thanks.
11:15:07 <Cale> ddarius: okay, *almost* always :)
11:15:21 <Cale> Of course it really depends on the interface you're looking for.
11:15:25 <rwbarton> Cale didn't say anything about completeness.
11:15:30 <esap> Cale: Hmm. If you could automatically turn a dictionary into a record of functions, that could be useful
11:15:50 <ddarius> rwbarton: [13:13] <Cale> But there are always ways to avoid using existentials.
11:16:04 <rwbarton> Ah, I thought you were referring to the more recent always
11:16:31 <Cale> Well, actually, we can be sure that there are always ways to avoid using existentials, but *good* ways are another thing. :)
11:18:16 * Cale does a cabal install cabal-install after installing GHC 6.10.1 :)
11:21:04 * Cale wonders if there are any libraries on hackage yet with lots of fun quasiquoters :)
11:22:00 <RayNbow> "There are now flags -fdph-seq and -fdph-par for selecting which DPH backend to use" <-- so... using DPH syntax and the -fdph-par flag now results in parallel code being generated?
11:22:02 <rwbarton> @hackage regexqq
11:22:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regexqq
11:24:37 <luite_> as anything changed for ghc 6.10 in the last few days? I downloaded/compiled the latest snapshot last saturday
11:24:53 <dons> i'd use the tarball release.
11:25:01 <dons> RayNbow: yeah
11:26:23 <geezusfreeek> does DPH have the vectorization stage working now, or is it just going to have to wait until 6.10.1 or something?
11:26:32 <dons> big new music library, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hamusic-0.1.1
11:26:34 <lambdabot> Title: HackageDB: hamusic-0.1.1, http://tinyurl.com/652kao
11:26:38 <dons> geezusfreeek: the vectorizer is in.
11:26:44 <geezusfreeek> dons: sweet! that's great news
11:26:46 <Cale> hmm, my delete key no longer works in ghci 6.10
11:26:56 <Cale> It now produces a beep and a ~
11:27:09 <Cale> backspace is fine though
11:27:19 <dons> editline vs readline
11:27:38 <Cale> yeah
11:27:47 <Cale> So is that an editline bug
11:27:48 <Cale> ?
11:28:11 <Cale> I wonder...
11:28:21 <RayNbow> @src subsequences
11:28:22 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:28:25 <dons> difference?
11:28:28 <RayNbow> lambdabot needs an upgrade :p
11:28:57 <mdmkolbe> Where is the version numbering recomendation for hackage?
11:29:32 <dons> haskell.org's getting slower..
11:29:46 <dons> mdmkolbe: http://haskell.org/haskellwiki/Package_versioning_policy
11:29:49 <lambdabot> Title: Package versioning policy - HaskellWiki
11:29:52 <Cale> hmm, the hierarchical libraries documentation seems not to be updated yet
11:29:57 <mdmkolbe> thx
11:30:04 * RayNbow wonders when the new source files will be available on hackage...
11:30:14 <dons> Igloo: ^^
11:30:20 <dons> RayNbow: new source files?
11:30:36 <Igloo> Which hierarchical libraries documentation?
11:30:57 <Cale> er, or maybe it is...
11:31:02 <RayNbow> dons: the source of Data.List on hackage doesn't contain the definition for subsequences yet
11:31:04 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
11:31:08 <lambdabot> Title: Haskell Hierarchical Libraries
11:31:10 <dons> tim sheard is great. "here's some proof objects, with extra baloney on top"
11:31:15 <Cale> says base-3.0.2.0
11:31:17 <omg911> i'm stuck on a problem... i need the IO monad inside of Data.Map.unionWith for my combine function, is there some hack around it?
11:31:54 <dons> omg911: wtf?
11:32:04 <RayNbow> dons: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html <-- currently outdated
11:32:04 <dons> don't do IO inside your union function
11:32:06 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/392kwb
11:32:36 <omg911> dons: i need to randomly choose which map to take an element from
11:32:48 <dons> use a random gen then.
11:32:55 <dons> Cale: omg911 needs help.
11:33:00 <Cale> dons: I see :)
11:33:16 <Cale> Yeah... that's hard to do using unionWith
11:33:23 <Igloo> Cale: Thanks, updated
11:33:31 <dons> omg911: its ok, you can thread an infinite stream of choice through , and write a custom unionWith that dispatches based on a coin toss
11:33:38 <dons> its a cool function, but its a new function.
11:33:50 <int-e> omg911: hmm, so use intersectionWith (,)  to collect the pairs, then do the choice in IO, and then piece the result together from there?
11:34:01 <int-e> "the pairs" -> "the common pairs"
11:34:19 <dons> kolmodin++ haha beat us to the announce
11:34:53 <omg911> int-e: hmmm that's an interesting idea but doesn't that change the type of map?
11:35:15 <int-e> @type M.intersectionWith (,)
11:35:16 <lambdabot> forall a b k. (Ord k) => M.Map k a -> M.Map k b -> M.Map k (a, b)
11:35:54 <int-e> omg911: as long as the result map has the correct type, do you care?
11:35:59 <omg911> @type M.unionWith (,)
11:36:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, a)
11:36:00 <lambdabot>       Expected type: a -> a -> a
11:36:00 <lambdabot>       Inferred type: a -> a -> (a, a)
11:36:20 <mdmkolbe> I've lost my wiki account, the http://hackage.haskell.org/trac/hackage/wiki/CabalInstall page should probably be updated to reflect version 0.6.0
11:36:23 <lambdabot> Title: CabalInstall - Hackage - Trac
11:36:32 <mdmkolbe> (at least in the quick installation section)
11:36:35 <omg911> int-e: what i'm saying is With functino is only called when there is element of same key
11:36:40 <rwbarton> omg911: another option is to toAscList both the Maps and handle the union logic yourself
11:37:04 <int-e> omg911: intersectionWith is different, because it doesn't have to deal with the cases where an element exists only in one of the source maps.
11:37:14 <dons> ?userrrs
11:37:15 <lambdabot> Maximum users seen in #haskell: 536, currently: 523 (97.6%), active: 24 (4.6%)
11:37:40 <Cale> int-e: Of course, he'll need the symmetric difference after that, but that's easy enough too :)
11:38:57 <rwbarton> or, traverse pickOneAtRandom $ unionWith (++) (map return map1) (map return map2)
11:39:25 <Cale> rwbarton: Oh, that's a nice idea.
11:39:49 <vixey> :t map return
11:39:50 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> [m a]
11:39:57 <int-e> urgh, return for (:[])
11:40:05 <vixey> @hoogle [a] -> [m a]
11:40:05 <lambdabot> Data.List inits :: [a] -> [[a]]
11:40:05 <lambdabot> Data.List tails :: [a] -> [[a]]
11:40:05 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
11:40:07 <rwbarton> s/map/fmap/ or s/map/Data.Map.map/
11:40:23 <vixey> :t fmap Data.Map.map
11:40:25 <lambdabot> forall a b k (f :: * -> *). (Functor f) => f (a -> b) -> f (M.Map k a -> M.Map k b)
11:40:35 <int-e> Cale: you don't really need it - a biased union will work nicely.
11:40:47 <Cale> int-e: ah, okay
11:41:20 <dons> well-typed's summary http://blog.well-typed.com/2008/11/ghc-6101-released/
11:41:22 <lambdabot> Title: blog.well-typed.com Â» Blog Archive Â» GHC 6.10.1 released!
11:42:11 <omg911> rwbarton: thxs i'll give that a try
11:42:42 <Cale> map f [] = []
11:42:42 <Cale> map f (x : map f -> xs) = f x : xs
11:43:01 <vixey> Is there already a name for map return?
11:43:53 <Cale> hmm
11:43:58 <Cale> that actually doesn't work for some reason
11:44:36 <dobblego> cojoin perhaps?
11:44:37 <rwbarton> Error: line 2: this code is too confusing
11:44:51 <Cale> oh, for some reason it needs extra parens
11:45:08 <vixey> does htat really work? lol
11:45:09 <Cale> and then it complains about pattern matches being overlapped for some stupid reason :P
11:45:12 <Cale> mymap f [] = []
11:45:13 <Cale> mymap f (x : (mymap f -> xs)) = f x : xs
11:45:23 <rwbarton> Yeah, I reported what is probably the same bug.
11:45:24 <Cale> that works, but complains about overlapping patterns
11:45:53 <vixey> , let map _ [] = [] ; map f (f -> y : map f -> ys) = y : ys it map (+1) [2,3,42,2]
11:46:00 <lunabot>  luna: parse error on input `->'
11:46:10 <vixey> , let map _ [] = [] ; map f ((f -> y) : (map f -> ys)) = y : ys it map (+1) [2,3,42,2]
11:46:11 <lunabot>  luna: parse error on input `)'
11:46:16 <rwbarton> http://hackage.haskell.org/trac/ghc/ticket/2395
11:46:18 <lambdabot> Title: #2395 ("Pattern match(es) are overlapped" warning with a single view pattern (gh ...
11:46:35 <ketil> I know I should know this, but what is the canonical way to cut out a chunk of a lazy bytestring as a strict bytestring?
11:46:40 <Cale> , let map _ [] = [] ; map f ((f -> y) : (map f -> ys)) = y : ys in map (+1) [2,3,42,2]
11:46:42 <lunabot>  [3,4,43,3]
11:47:32 <dolio> Nice.
11:47:33 <vixey> I don't see what the difference is
11:47:42 <dolio> vixey: You said 'it' instead of 'in'.
11:47:52 <pozic> Challenge/puzzle: write the value (replicate 1000 1) using less than 3 letters (but you may use other characters).
11:48:23 <rwbarton> easy: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,{- ... -}]
11:48:43 <pozic> rwbarton: ok, without doing that. :)
11:48:54 <mrd> > [1..1000] >> 1
11:48:55 <lambdabot>       No instance for (Num [b])
11:48:55 <lambdabot>        arising from the literal `1' at <inter...
11:49:14 <rwbarton> > [1..1000] >> [1]
11:49:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:49:23 <ketil> > [ 1 | x <- [1..1000]]
11:49:26 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:50:04 <skorpan> > replicate 1000 1
11:50:04 <pozic> ok, so much for the challenge ;)
11:50:06 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:50:07 <ketil> > length $ filter isAlpha $ "[ 1 | x <- [1..1000]]"
11:50:09 <lambdabot>   1
11:50:11 <skorpan> am i doin it rite
11:50:27 <pozic> skorpan: no, but rwbarton and ketil did.
11:50:31 <ketil> rwbarton is slightly better...
11:50:36 <dobblego> > [1..1000] >> [1]
11:50:37 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:50:41 <ketil> > [ 1 | _ <- [1..1000]]
11:50:43 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:50:50 <ketil> > length $ filter isAlpha $ "[ 1 | _ <- [1..1000]]"
11:50:52 <lambdabot>   0
11:51:00 <skorpan> [1..1000]
11:51:03 <ketil> > it
11:51:04 <lambdabot>   Not in scope: `it'
11:51:06 <skorpan> how about that
11:51:13 <skorpan> am i doin it rite
11:51:19 <mrd> > map (\_ -> 1) [1..1000]
11:51:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:51:32 <mrd> oh, < 3
11:51:33 <rwbarton> > (\_ -> 1) <$> [1..1000]
11:51:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:51:36 <mrd> yea
11:51:52 <ketil> Who needs letters anyway? :-)
11:52:02 <mrd> or (\_ -> 1) . [1..1000] with an appropriately defined .
11:52:08 <mrd> > (\_ -> 1) . [1..1000]
11:52:09 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
11:52:18 <mrd> I guess Cale's changes got reverted
11:52:25 <ketil> (.) = map ?
11:52:32 <mrd> (.) = fmap
11:52:59 <Cale> mrd: I might be able to put that back soon enough, if the GHC API and hint are properly supporting qualified imports.
11:53:06 <RayNbow> > [\_ -> 1] <*> [1..1000]  -- variation on rwbarton... now without parentheses :p
11:53:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:53:13 <_pizza_> i have a function: slots :: Int -> Array Int [a] ; how do i declare a datatype with a member of the same type as slot's return type?
11:53:44 <dobblego> data Foo a = Foo (Array Int [a])
11:54:49 <mdmkolbe> @seen dons
11:54:50 <lambdabot> dons is in #haskell, #xmonad, #darcs, #ghc and #arch-haskell. I last heard dons speak 13m 30s ago.
11:55:07 <_pizza_> dobblego: i see, i didn't specify the first 'a'; thanks
11:56:07 <Baughn> pizza: It's a parameter, just like any other function. Though this function is from type to type, not value to value
11:56:56 <_pizza_> i see, still trying to wrap my head around Haskell's types ;)
11:57:42 <dons> mdmkolbe:
11:58:27 <Baughn> _pizza_: Haskell consists of at least three major languages that can't be reduced to each other: The IO monad, pure haskell, and the type system
11:58:44 <Baughn> Though some persist in attempting to reduce pure haskell to the type system..
11:59:49 <RayNbow> Baughn: what's the next step... giving Haskell a Turing complete kind system? :p
11:59:57 <Baughn> RayNbow: Yes.
12:00:14 <_pizza_> when i want to construct a value of type 'Foo a' i provide Foo <some type>?
12:00:22 <Baughn> No
12:00:35 <Baughn> When you want to construct a type of type Foo a, you provide Foo <some type>
12:00:36 <mdmkolbe> dons: all I got was "mdmkolbe: "
12:01:01 <Baughn> pizza: Your problem here is that Foo is punned. You're using it both for the type constructor and the value constructor, so..
12:01:15 <Baughn> pizza: "data Foo a = Voom a" is easier to talk about
12:02:02 <Baughn> pizza: In this case, Foo is a type constructor and Foo <some type> is another valid type. Voom is a data constructor, and Voom <any value> is a valid value of type Foo <type of the value you passed to Voom, whatever that ends up being>
12:02:21 <Baughn> pizza: Also it has a car analogy.
12:02:39 <_pizza_> i think i actually understand what you said
12:02:43 <rwbarton> In this particular example you can think of Voom as a function Voom :: Array Int [a] -> Foo a
12:03:48 <_pizza_> ok i see that
12:03:50 <Baughn> pizza: Oh, and Foo is a type constructor of kind * -> *. Foo a is a type of kind *, for some validly typed value of a.
12:04:08 <Baughn> pizza: Types are dynamically kinded, actually. ^_^
12:04:17 <Baughn> Well, almost
12:04:36 <mathijs> BONUS_ : are you online?
12:05:06 <Baughn> pizza: It would be more correct to claim that there are only two kinds: The kind a -> a, where a is a kind, and the kind *, which is any concrete type
12:05:17 <Baughn> pizza: ...feel free to ignore me now
12:05:36 <Baughn> RayNbow: See, that's what I mean. We _need_ a more complete kind system.
12:05:43 <_pizza_> not at all, i appreciate the information
12:05:47 <rwbarton> I occasionally wish I could create my own kinds.  Maybe this has something to do with total type families?
12:06:01 <vixey> why would you make a new kind?
12:06:07 <vixey> Are you doing type level programming or not?
12:06:22 <Baughn> pizza: In that case, feel free to type :kind Int, :kind Maybe and :kind Either on a ghci prompt
12:06:22 <vixey> actually my second question was meaningless
12:06:23 <rwbarton> That is, I would like to write in Mercury rather than Prolog.
12:06:25 <rwbarton> :)
12:06:33 <Baughn> pizza: Or :kind Either Int
12:06:55 <rwbarton> vixey: Yes (when I want new kinds, anyways)
12:08:55 <RayNbow> Baughn: I can't think of examples though where we need a better kind system... (but my type/kind skills are not mature yet :p)
12:10:00 <rwbarton> RayNbow: consider programs like http://hpaste.org/11724.  I'd like to know that I never mix up type-level integers and booleans.
12:10:06 <Baughn> RayNbow: For type-level programming, of course. You don't want the compiler to mix up integers and strings
12:10:16 <Baughn> RayNbow: And later we'll want kind-level programming
12:10:28 <vixey> rwbarton, I bet that program would be neater in Agda or Coq
12:10:29 <Baughn> RayNbow: Really, what we need is an infinite (lazy) tower of sorts
12:10:44 <rwbarton> vixey: I'm sure it would be
12:11:28 <Baughn> RayNbow: Kinds of some sort would be useful if we ever want to do type-level programming with anything but unary, anyhow
12:11:38 <rwbarton> vixey: type families would help too, I'm not used to programming in this "relational" style
12:11:41 <Lemmih> Is anyone else having trouble with editline in ghc-6.10.1?
12:11:47 * Baughn collapses from the punnage
12:11:55 <_pizza_> i don't understand the meaning of * vs. * -> *
12:12:09 <mauke> it's like () vs. () -> ()
12:12:10 <rwbarton> _pizza_: How is Integer different from Maybe?
12:12:23 <Baughn> pizza: * is a concrete type, such as Int. * -> * is a type constructor that, if given one type, will return a concrete type.
12:12:38 <Baughn> pizza:  * -> * -> * is, obviously, one of two parameters, such as Either
12:12:55 <Baughn> pizza: Just be happy it doesn't say BaseType -> ExceptionType or some such
12:13:07 * Baughn isn't. ;_;
12:13:20 <vixey> :j Maybe
12:13:23 <vixey> :j Maybe
12:13:25 <vixey> :k Maybe
12:13:26 <lambdabot> * -> *
12:13:31 <vixey> :k Maybe Int
12:13:32 <lambdabot> *
12:13:35 <vixey> :t Just True
12:13:36 <lambdabot> Maybe Bool
12:14:12 <_pizza_> so kind * are value that can be expressed literally in source code and * -> * are ones that require a constructor in order to produce a concrete type
12:15:03 <vixey> no
12:15:09 <rwbarton> A kind is something that is a property of a type constructor.
12:15:18 <vixey> if you have a value in haskell, its  type will always have kind *
12:15:40 <rwbarton> Integer and Maybe are both type constructors.  But Integer is already a type, while Maybe requires an argument (which must be a type) to form a type Maybe a.
12:15:46 <vixey> all the rest of the kind system is just typechecking stuff
12:16:13 <Baughn> pizza: * -> * is a type constructor
12:16:20 <vixey> Baughn, no it's not ..
12:16:27 <Baughn> Well, okay, it's the kind of one
12:16:36 <_pizza_> rwbarton: ok
12:16:36 <Baughn> *it's kind of one
12:16:52 <Baughn> ..I need to stop discussing this, or I'm going to kill myself
12:17:02 <Cale> Baughn: you shouldn't have made that correction ;)
12:17:22 <Baughn> Cale: I couldn't resist. Watt have I done?
12:17:52 <mauke> ohm y god
12:18:17 <Cale> * -> *  is the kind of some type constructor, but it's not a type constructor even approximately :)
12:20:31 <rwbarton> I want to make a 2-category out of this stuff, whose objects are kinds and whose morphisms are type constructors
12:20:37 <rwbarton> does anyone know how to do that?
12:22:41 <rwbarton> Ordinary types live somewhere among the morphisms and 2-morphisms between them are values
12:23:12 <_pizza_> must the members of a compound type be extracted by name via @ pattern-matching in each method that accesses them? types have no named-members, a la i.e. C's struct?
12:23:33 <vixey> myProjection (Foo _ _ x _ _ _) = x
12:23:43 <vixey> now you can use myProjection instead of pattern matching
12:24:31 <rwbarton> _pizza_: you can also declare your type using record syntax, which defines projections for you, as well as some other stuff
12:25:02 <_pizza_> ok thanks, i'll look into it
12:26:35 <Baughn> pizza: GHC 6.10 has a bunch of extensions that make this easier, both with and without naming
12:29:07 <kolmodin> dons: I'm pleased too ;)
12:31:23 <kolmodin> now we need to see if the packages in portage and the overlay work with ghc-6.10
12:31:38 <kolmodin> dons: have you got a plan to test arch's massive amount of packages?
12:42:00 <Baughn> @index liftIO
12:42:00 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:49:25 <Baughn> I find myself wanting the ability to abort IO actions and do something else instead, /without/ wrapping the entire rest of the computation in an if. From within a function would be nice too, but not necessary.. well, I guess I basically want a tiny little continuation thingy
12:49:54 <Baughn> Should I use the tiny little monad I've been writing for that, or is there something in the standard library already? I know there is on hackage, but not an option right now.
12:54:46 <Lemmih> Baughn: The else branch doesn't have to have a different indentation.
12:56:28 <Baughn> Lemmih: I want to say 'foo = print "foo"; bar = print "bar"; bam = do foo; cutout (print "baz"); do bam; print "nope"' and have it not print "nope"
12:57:15 <Baughn> ..with lots of liftIOs in appropriate places
12:57:23 <Lemmih> Baughn: http://hpaste.org/11734
12:57:26 <Baughn> Or better yet, without them, but that doesn'T seem likely
12:57:55 <Baughn> Lemmih: Note how the cutout isn't in the same function that prints nope
12:58:58 <rwbarton> Sounds about like Either e IO, although it's a little hard to read that code without braces
12:59:50 <vixey> :t if False then return () else ?f
12:59:50 <lambdabot> forall (m :: * -> *). (?f::m (), Monad m) => m ()
13:00:10 * Baughn just feels like abusing monads, actually. He's never had a real chance to use them before.
13:00:29 * Botje sets greenpeace on Baughn 
13:01:02 <rwbarton> where by Either e IO I mean EitherT e IO
13:01:20 <rwbarton> which is actually called ErrorT e IO
13:09:43 <jberryman> this is the sort of problem I've run into before but keep forgetting how to deal with: I want a function that searches a binary tree for an item and returns Just the new tree with the new item attached, or Nothing if the item is already present in the tree
13:10:19 <jberryman> I'm going through the tree recursively and by the time I get down to where I can find the item, it's too late to return Nothing
13:10:23 <Cale> jberryman: Er, you mean inserts a new item into a binary tree?
13:11:01 <cjb> Cale: unless it's already there.
13:11:01 <rwbarton> I would start with the recursive function that calls error when the item is already present, and change the recursive step from something like:
13:11:30 <Cale> jberryman: It's never too late. Your recursive call is going to give Nothing, which you'll propagate.
13:11:34 <rwbarton> Tree t1 (insert x t2) to fmap (\t -> Tree t1 t) (insert x t2)
13:14:39 <jberryman> interesting, thanks.
13:15:21 <jberryman> Cale: I think I know what you mean, but I would have to work it out. so using the Maybe monad?
13:15:34 <Cale> jberryman: Or a case expression.
13:17:10 <Cale> It'll look like:
13:17:21 <Cale> insert x (Branch y l r) =
13:17:25 <Cale>   case compare x y of
13:17:31 <Cale>     EQ -> Nothing
13:17:40 <Cale>     LT -> case insert x l of
13:17:49 <Cale>             Nothing -> Nothing
13:17:50 <vixey> insert x (Branch (compare x -> EQ) l r) = ... -- eek.....
13:18:02 <Cale>             Just l' -> Just (Branch y l' r)
13:18:09 <Cale> etc.
13:19:04 <Cale> jberryman: Makes sense?
13:19:23 <Cale> jberryman: the base case will be something like   insert x Tip = Just (Branch x Tip Tip)
13:21:35 <sbahra> Anyone here use FreeBSD?
13:21:37 <Cale> jberryman: of course, once you see that case expression, it's easy to see that that's  fmap (\l' -> Branch y l' r) (insert x l)
13:21:41 <Zao> sbahra: Occasionally.
13:24:58 <Cale> okay, this is going to piss me off... does anyone know how to get the delete key working in GHCi 6.10?
13:25:31 <lispy> (\l' -> Branch y l' r) <$> (insert x l)
13:25:37 <Cale> jberryman: The Maybe monad is quite handy for actually using this insert to build up a tree.
13:25:41 <Cale> *Main Control.Monad> foldM (flip insert) Tip [4,3,2,5,7]
13:25:41 <Cale> Just (Branch 4 (Branch 3 (Branch 2 Tip Tip) Tip) (Branch 5 Tip (Branch 7 Tip Tip)))
13:27:23 <dons> Cale: more info. what distro, what version of editline?
13:27:39 <Cale> Ubuntu, version 2
13:27:48 <Cale> I can get an exact version, hang on.
13:27:54 <dons> make a ghc bug report.
13:28:03 <dons> works for me, fwiw
13:28:09 <Lemmih> Doesn't work for me.
13:28:17 <Cale> libedit.so.2.11
13:28:25 <lispy> dons: do you happen to know how I can get a copy of 6.10 that installs without installing any previous version?
13:28:30 <Lemmih> Can't even get the arrows to work. GHCi is pretty useless.
13:28:30 <Cale> delete produces a beep and a ~
13:28:31 <lispy> dons: this is oxs
13:28:34 <lispy> er osx*
13:28:42 <dons> lispy: wait fro the .dmg things to appear
13:28:49 * lispy waits
13:28:49 <dons> Lemmih, Cale: bug report to Igloo
13:28:52 <lispy> how about now? ;)
13:29:34 <lispy> I'm going to email someone actually
13:29:37 <mathijs> I have a question about the famous haskell quicksort example, it uses the given list (xs) twice, once for filtering < x, and once for >= x, this is both in the haskellwiki (using filter) and in other versions (that use list comprehension). does this mean the list is processed twice? can't this be done in one sweep? ruby and prototype(js) have a 'partition' for that. Anything like it in haskell?
13:29:52 <Cale> mathijs: yes, partition :)
13:29:55 <Cale> :t partition
13:29:56 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:30:09 <Cale> It's in Data.List
13:30:19 <mathijs> ah, so I guess ruby/prototype borrowed it from haskell :)
13:31:03 <Axman6> i wouldn't say it was borrowed from anywhere, it's probably taught in algorithms courses
13:31:26 <Igloo> lispy: What's wrong with the installer on the download page?
13:31:32 <Lemmih> Keep in mind: partition f xs = (takeWhile f xs, takeWhile (not.f) xs)
13:31:52 <Axman6> Lemmih: it's usually not written that way for quicksort
13:31:57 <rwbarton> @src partition
13:31:57 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
13:31:58 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
13:31:58 <lambdabot>                               | otherwise = (ts, x:fs)
13:32:02 <vixey> observationally that's fine but there's no reason it should have that computational behavior
13:32:02 <Cale> > partition (< 5) [1,7,4,8,2,3,10,5]
13:32:04 <lambdabot>   ([1,4,2,3],[7,8,10,5])
13:32:16 <Cale> Lemmih: not true!
13:32:36 <Axman6> another version produces the equal list too
13:32:42 <Lemmih> Cale: Hm, I guess not.
13:32:59 <lispy> Igloo: Well, with the RC1 install it uninstalled my copy of 6.8.3.  Because of this, I haven't tried the 6.10.1 installer.  I fear it may do the same.
13:33:12 <Cale> Igloo: Did you see my bug report there?
13:33:32 <mathijs> those @src's in lambdabot, can I find those in Prelude's sources?
13:33:52 <Igloo> lispy: Ah, right. You said "without installing any previous version" above, which is why I got confused  :-)
13:34:01 <rwbarton> mathijs: You can find them in the ghc source, if that's what you mean
13:34:05 <lispy> mathijs: I've heard the lambdabot ?src definitions are special to lambdabot to be illustrative, not necessarily what is used by say GHC
13:34:13 <Cale> mathijs: Well sort of. The ones in lambdabot are not necessarily the actual source.
13:34:17 <rwbarton> mathijs: You can also find them through hoogle
13:34:24 <lispy> Igloo: oh, maybe I meant uninstalling, sorry for any typos :)
13:34:35 <Cale> mathijs: Sometimes they're simplified or idealised versions of the real thing
13:34:50 <Igloo> I don't know how to make them installable at the same time. Apparently it's supposed to work, but it doesn't.
13:35:01 <lispy> Igloo: I may need to build from source to get what I want.  I guess that's fine.  I just need to know what I have to do :)
13:35:15 <Baughn> @src sort
13:35:16 <lambdabot> sort = sortBy compare
13:35:19 <Baughn> @src sortBy
13:35:19 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
13:35:25 <mathijs> Cale: hoogle states it uses filter, so my guess would be that it's inefficient, but it is probably implemented better
13:35:30 <Baughn> mathijs: Such as this one. Well, it's /technically/ correct..
13:35:33 <lispy> Igloo: for example, I don't know how I ended up with 6.6.1 and 6.8.3.  I like it, but I don't recall how i installed 6.6.1
13:35:43 <Igloo> Cale: If you've filed a bug in trac then I'll see it at some point
13:35:52 <Cale> Igloo: oh, I didn't.
13:36:09 <Cale> Igloo: The delete key doesn't work in ghci 6.10.1 for me.
13:36:35 <rwbarton> mathijs: Here hoogle is just describing the semantics of the function, not its actual implementation.
13:36:43 <Cale> Igloo: I'm using libedit 2.11.  Pressing delete gives me a beep and inserts a '~'
13:37:12 <Cale> http://bugs.mysql.com/bug.php?id=294
13:37:13 <lambdabot> Title: MySQL Bugs: #294: Delete key doesn't work in MySQL 4.1.0 Command Line Client
13:37:15 <rwbarton> mathijs: If you go here: http://haskell.org/ghc/docs/6.8.3/html/libraries/base/Data-List.html#v:partition you can click on Source and see the actual source.
13:37:17 <lambdabot> Title: Data.List, http://tinyurl.com/64n23t
13:37:20 <Cale> seems to be a similar bug in MySQL
13:37:32 <Cale> They fixed it by reverting to using libreadline.
13:38:05 <mathijs> rwbarton: cool, tnx
13:38:34 <mathijs> rwbarton: any reason the source link isn't on hoogle?
13:39:01 <rwbarton> mathijs: it seems they updated hoogle for ghc 6.10.1, but there aren't source links in the new haddocks.
13:39:13 <rwbarton> mathijs: I just changed /latest/ to /6.8.3/ in the URL to get the old working version.
13:39:36 <mathijs> rwbarton: ah, nice trick to know, thanks
13:40:54 <mathijs> looking at the version at the top of the document (4.0.0.0 vs 3.0.2.0) I figure ghc 6.10.1 is gonna be a big change?
13:42:11 <rwbarton> I think it's just a few modules in base that aren't backwards compatible
13:43:01 <Cale> It is a fairly big change anyway.
13:43:30 <jkr> Does Haskell have some kind of documentation system, like perldoc?
13:43:54 <Axman6> haddoc?
13:43:55 <Cale> jkr: Haddock
13:43:59 <jkr> I have installed a few packages with cabal and I'm looking for the documentation
13:44:03 <jkr> Ah
13:44:15 <rwbarton> By default the documentation was probably not built.
13:44:33 <rwbarton> I added the line 'documentation: True
13:44:39 <rwbarton> ' to my ~/.cabal/config
13:44:45 <Cale> jkr: You can usually find the haddock documentation linked from the hackage website, which is usually more convenient.
13:44:53 <Axman6> cabal has a haddock command too
13:45:01 <Cale> (but sometimes it doesn't build)
13:45:25 <rwbarton> and with that option cabal installs haddocks into ~/.cabal/share/doc
13:45:30 <bbs> can someone help me clean up a program?
13:45:34 <bbs> its done now
13:45:35 <jkr> Do I have to rebuild the installed packages to get the documentation?
13:45:36 <bbs> its just ugly
13:45:36 <rwbarton> Yeah, I did it for the 30% of the time the haddocks are missing from hackage for some reason.
13:45:47 <jkr> After adding "documentation: True", I mean
13:46:09 <bbs> Cale: ? :)
13:46:17 <bbs> unless you are pissed at me for being stupid yesterday
13:46:21 <rwbarton> jkr: I think so.  cabal install foo --reinstall, perhaps.
13:46:31 <jkr> Ok, I'll try that
13:46:34 <jkr> Thanks
13:46:48 <sbahra> Is there any reason why I should not make a FreeBSD cabal port?
13:46:49 <Cale> bbs: I'm not :) I'll have a look, but better yet, hpaste it and everyone can pick at things :)
13:46:58 <sbahra> That is, a FreeBSD port for Cabal.
13:47:06 <sbahra> Should I wait for "the haskell platform"?
13:50:22 <jkr> Hrm, how do I run hadock? "haddock $PACKAGENAME"?
13:51:35 <bbs> Cale: i'll put it up
13:51:36 <jkr> For example, I have a few .html files a xml.haddock file in ~/.cabal/share/doc/xml-1.2.3.../
13:51:41 <bbs> but i'll be away for a bit
13:51:43 <Cale> jkr: perhaps   cabal haddock packagename
13:51:43 <jkr> How do I look at it?
13:51:45 <bbs> so maybe i should just wait until later
13:51:50 <rwbarton> jkr: with a web browser :)
13:51:55 <jkr> Hehe
13:52:43 <jkr> Ah, now I see :)
13:52:57 <jkr> haddock is a documentation generator, not a viewer
13:52:59 <bbs> Cale: its like my precious right now
13:53:06 <jkr> I thought it was something like perldoc
13:53:06 <bbs> even though its a piece of garbage
13:53:53 <jsn> @seen Peaker
13:53:53 <lambdabot> I saw Peaker leaving #haskell and #haskell-blah 12h 7m 49s ago, and .
13:55:19 <yebyen> anybody using hikij?  or another wiki that you like, written in haskell
13:55:26 <yebyen> with some javascript maybe
13:56:17 <yebyen> i'm doing the hail mary dance this week maybe I pass a class or two... I'd much rather pass haskell than c# :o
13:56:43 <bbs> yebyen: i would say thats a good thing :)
13:58:52 <yebyen> bbs: yeah, passing classes is good!
13:58:57 <yebyen> i should have my degree in two weeks
13:59:00 <yebyen> but it's not looking good :(
13:59:14 <yebyen> coffee's on, anyway
14:02:51 <mathijs> can someone give an example of a nested where-clause in a function?
14:03:52 <mauke> > let f x = y where y = g x where g = id in f "what"
14:03:53 <lambdabot>   "what"
14:04:54 <Axman6> might be a little clearer if it were written on multiple lines
14:05:11 <mathijs> mauke: tnx, but I'm struggling with layout I think, the second 'where', should it be indented more than the first?
14:05:17 <mauke> > let {f x = y where {y = g x where {g = id}}} in f "what"
14:05:18 <lambdabot>   "what"
14:06:19 <mauke> mathijs: the second where should be indented more than the 'y'
14:07:20 <mathijs> mauke: it then complains about something not in scope
14:07:45 <mauke> define "something"
14:07:57 <mathijs> http://hpaste.org/11735
14:08:23 <mauke> smaller only exists in biggerSorted
14:08:33 <unenough> BONUS_, i asked which web framework you use for learnyouahaskell but i didn't receive the answer, if there was one
14:08:36 <mauke> you don't want a nested 'where' there
14:09:21 <mathijs> so I can't do a nested where whose scope spans the other?
14:09:42 <mauke> what's the point of nesting if it spills into its containing scope?
14:10:02 <mauke> just remove the second 'where'
14:10:15 <mathijs> mauke: that's a good point :)  just playing around with syntax
14:10:23 <vixey> mathijs, where is like let, but goes afterwards
14:10:29 <mathijs> mauke: it works then, I had it that way before
14:10:42 <mauke> hmm, or put smallerSorted/biggerSorted in the same binding group
14:10:43 <vixey> mathijs, so you can have   [] where a = b; c = d; ..., and let a = b; c = d in []
14:10:52 <Cale> What do you people think? Should the -> view pattern arrow bind tighter than infix data constructors?
14:10:52 <rwbarton> The usual use for a nested where is to bring a variable bound by a function pattern into scope.
14:10:59 <Cale> It currently binds more weakly.
14:10:59 <vixey> mathijs, likewise,  [] where _ where _ vs let _ in let _ is []
14:11:05 <mathijs> vixey: no differences? I read something about let being an expression and where isn't ?
14:11:11 <mauke> ... where (smallerSorted, biggerSorted) = (quicksort smaller, quicksort bigger) where (smaller, bigger) = ...
14:11:16 <sandbox> so I'm trying to determine if two words, who's lengths differ by one, differ by only one character without unpacking the bytestrings
14:11:42 <sandbox> so I'm thinking zipWith but it's kinda ugly
14:11:49 <Cale> (I think it should bind tighter)
14:12:27 <mathijs> mauke: cool, that's even tighter
14:12:29 <rwbarton> mathijs: yes, that's true: let attaches to expressions, while where attaches to declarations
14:12:48 <vixey> it's not really the point I was making though
14:12:58 <rwbarton> mauke: that second where can (should?) still be replaced by ;
14:13:33 <Baughn> sandbox: Well, you could compute a hash on them with foldl' and compare the hashes, but..
14:13:42 <Baughn> Something tells me that'd be even uglier. Not to mention slower.
14:14:45 <Baughn> sandbox: zipWithAccum it is.
14:15:41 <sandbox> Is that new in bytestring?
14:15:48 <Baughn> sandbox: (That is if you absolutely must have max performance, and don't trust the optimizer. Otherwise all . zipWith (==) doesn't sound so bad.
14:15:55 <Baughn> sandbox: No, it's an exercise for the reader
14:16:00 <sandbox> okay, thanks
14:16:08 <mathijs> rwbarton: it works with that second 'where', replacing it by ; will make smaller and bigger be exposed to the containing function I guess?
14:16:49 <sandbox> operating on several hundred thousand items so performance is a bit important
14:17:00 <rwbarton> mathijs: yes, that's true.  Not sure how much it matters.
14:17:06 <mathijs> while with the second 'where' smaller and bigger are only available to smallerSorted and biggerSorted
14:17:17 <rwbarton> sandbox: you have two strings and you want to know whether the longer one is formed by inserting a single character in the shorter?
14:17:26 <Baughn> sandbox: I'd still try all . zipWith (==) first. The optimizer is smart.
14:17:33 <vixey> is there no like
14:17:37 <vixey> finite state machine MONAD
14:17:40 <sandbox> correct rwbarton
14:17:49 <rwbarton> anywhere in the middle, right?
14:17:50 <mathijs> rwbarton: it doesn't, I'm just trying to grasp the little differences, since I find there's many ways to do the same thing
14:17:51 <sandbox> given w and w' w' is a permutation of w + 1 character
14:17:57 <Baughn> sandbox: Oh, hang on.. I thought it was just adding one to the end..
14:17:57 <sandbox> or an endpoint
14:18:00 <rwbarton> oh, a permutation?
14:18:04 <Baughn> sandbox: Come to think of it, isPrefixOf would fix that
14:18:31 <vixey> sandbox, easiest way I think of is turning them into multisets
14:19:03 <Baughn> sandbox: First you'd have to figure out what the new element is, right? A counting sort would be best for that
14:19:13 <Baughn> Or, well, a counting
14:19:35 <sandbox> vixey: would the conversion be reasonably efficient?
14:19:53 <sandbox> still fairly new to haskell so my stuff is probably kinda slow
14:21:03 <sandbox> map length (group w)?j
14:21:06 <Baughn> sandbox: After you know what element is knew (if only one is), you can walk through both strings while comparing, and if the comparison fails because that element was inserted /there/, switch to a mode where no more are allowed to fail. Otherwise, if it isn't, they weren't formed that way.
14:21:09 <mathijs> by the way, does anyone know if BONUS_ is going to setup a paypal-thingy for 'learnyouahaskell.com' ? I'm really enjoying his tutorial.
14:21:25 <Baughn> sandbox: Though of course that only works when the difference is exactly one element, but it should be rather blazingly fast
14:21:43 <sandbox> but the walking part, I can only think of zipWith
14:21:46 <sandbox> am I being stupid?
14:21:54 <rwbarton> sandbox: I'm still not sure whether we can rearrange the letters of the shorter word
14:21:57 <vixey> sandbox, efficient -- not really
14:21:59 <vixey> sandbox, efficient -- not really
14:22:09 <Baughn> sandbox: You can walk them by finding their length, and then explicitly indexing. Bytstrings have O(1) access time.
14:22:18 <rwbarton> sandbox: what is the output of   f (B.pack "abcd") (B.pack "decab")
14:22:19 <sandbox> ah
14:23:01 <sandbox> f abcde abcd = f decab abcd
14:23:12 <rwbarton> OK
14:23:39 <Baughn> @instances Foldable
14:23:40 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
14:23:45 <rwbarton> Hmm, the best thing would be if there was a forM_ on ByteStrings, and to use STUArray
14:23:46 <Baughn> @instances-importing Data.FOldable Foldable
14:23:47 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
14:23:55 <Baughn> @instances-importing Data.Foldable Foldable
14:23:56 <lambdabot> Maybe, []
14:24:06 <Baughn> @instances-importing Data.ByteString Foldable
14:24:07 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
14:24:17 <Baughn> Hmmph
14:24:31 <sandbox> maybe just get pointers?
14:24:33 <rwbarton> There can't be, because ByteString is not a Functor
14:24:36 <Baughn> Actually, wouldn'T the best thing be if bytestring instanced Foldable?
14:24:43 <Baughn> ;_;
14:24:53 <Baughn> It could be that too, though
14:25:12 <unenough> how does haskell do with serialization/persistence?
14:25:18 <int-e> Baughn: it can't.
14:25:23 <unenough> does it involve Suffering?
14:25:29 <Baughn> unenough: Not so much, these days
14:25:40 <Baughn> unenough: deriving(Show,Read) is good enough for simple, playful stuff
14:25:48 <Baughn> unenough: For more complex things there's Binary
14:26:01 <rwbarton> I guess you can use either foldl or foldr with the (>>=) from ST s
14:26:02 <Baughn> @src Functor
14:26:02 <lambdabot> class  Functor f  where
14:26:02 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:26:07 <Baughn> int-e: ..oh
14:26:18 <Baughn> unenough: And if the wire description isn't fixed, you can even derive Binary
14:26:49 <unenough> what's Binary?
14:27:12 <Baughn> unenough: Meanwhile, I'm thinking about writing a package that lets you write both the serializer and deserializer for Binary in one go, as a sort of logic-programming thing
14:27:23 <Baughn> unenough: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
14:27:31 <lambdabot> Title: HackageDB: binary-0.4.3.1
14:28:42 <sandbox> suppose indexing will work, thanks again
14:28:58 <Baughn> int-e: Why does Foldable require Functor, anyway?
14:29:58 <rwbarton> sandbox: I think the fastest method will be something along the lines of http://hpaste.org/11737, possible using foldl instead of foldr
14:30:07 <rwbarton> *possibly
14:30:16 <Baughn> @src Foldable
14:30:16 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:30:58 <dfrey|work> I am looking at parMap as a way to easily parallelize some computation.  I found that it wasn't any faster to use parMap over map.  See http://hpaste.org/11736
14:31:04 <sandbox> great, thanks
14:31:15 <vixey> dfrey|work, I've found this too
14:31:44 <vixey> dfrey|work, Actually I don't think I've seen any haskell that runs better parallelized than not
14:31:58 <dfrey|work> That's kind of sad
14:32:13 <vixey> dfrey|work, more sad is how pH is nothing like the book
14:32:34 <lilac> > let numInsertions (x:xs) (y:ys) | x == y = numInsertions xs ys | otherwise = (1+) <$> numInsertions (x:xs) ys; numInsertions [] ys = Just $ length ys; numInsertions xs [] = Nothing; numInsertionsSorted xs ys = numInsertions (sort xs) (sort ys)  in numInsertionsSorted "hello" "welcome to haskell"
14:32:34 <dfrey|work> pH?
14:32:35 <lambdabot>   Just 13
14:32:46 * Baughn has seen *plenty* of haskell that runs better parallelized, and normally manages near-linear speedups
14:32:57 <sandbox> data nested parallel should produce fast code
14:33:29 <pozic> What's the expected speedup for ghc-6.8.2 between -O2 and -O0?
14:33:45 <mauke> AWESOME
14:33:53 <Baughn> None at all
14:34:17 <dfrey|work> Baughn: Have you written any?  The code that I just pasted seems so embarrassingly parallelizable that I think I must have done something wrong.
14:34:22 <pozic> Baughn: ?
14:34:35 <sbahra> mauke, haha
14:34:38 <Baughn> pozic: It varies, a whole lot, so it's impossible to say
14:35:07 <Baughn> dfrey|work: Quite a bit. Let's see if I can't figure out this one..
14:35:25 <pozic> Baughn: take the average of that when someone asks a question like that.
14:35:41 <Baughn> pozic: Eh. Three, four times?
14:35:42 <rwbarton> dfrey|work: you've compiled it with -threaded and run it with +RTS -N2 or whatever?
14:36:05 <rwbarton> dfrey|work: Oh, didn't see at the bottom.
14:36:15 <dfrey|work> rwbarton: Yes.  The exact options at at the bottom of the paste here: http://hpaste.org/11736
14:36:22 <olsner> dfrey|work: run with +RTS -sstderr and see if you're spending a lot of time GC:ing
14:36:44 <Baughn> dfrey|work: I think the problem here is bad chunking
14:36:45 <zloog_> Is there a way to define a datatype as being a range of Ints?
14:36:48 <unenough> What sort of structure is this (monad? functor? applicative?) A flowchart that includes: Start, End, Decision, Fork, Join and Action nodes connected by directed edges. the chart can not change after construction.
14:36:56 <Baughn> dfrey|work: *Most* of the primes are really easy to test as.. well, not being prime
14:37:08 <Baughn> dfrey|work: So most of the work ends up being done by very few threads
14:37:14 <vixey> unenough: what's the actual data declaration?
14:37:23 <pozic> dfrey|work: Baughn's near linear is non-sense for number of cores >=8.
14:37:25 <unenough> vixey, it's in python currently :)
14:37:35 <Baughn> pozic: Well, I don't have an eight-core machine
14:37:46 <dolio> dfrey|work: Half of your sample is divisible by 2, so you potentially spark a thread to do a trivial amount of work.
14:37:54 <vixey> unenough: in haskell
14:37:59 <dfrey|work> olsner: only 1.2% in GC
14:38:25 <Baughn> dfrey|work: For me, it runs in 11 seconds with one thread and 7 seconds with two
14:38:31 <unenough> vixey, i'm trying to think how i would do this in haskell
14:38:34 <Botje> unenough: it's a functor over the nodes, at least
14:38:41 <Botje> unenough: have you looked at Data.Graph?
14:38:42 <Baughn> dfrey|work: Which is about what I'd expect from something like this. The output only pauses twice..
14:38:52 <unenough> Botje, looking
14:38:52 <dfrey|work> Baughn: Interesting.  It was 10 seconds in both cases for me
14:38:53 <rwbarton> dfrey|work: works for me.  10s -> 7s with two processors.
14:38:55 <pozic> Botje: did you?
14:39:08 <sbahra> haha
14:39:08 <rwbarton> dfrey|work: You didn't build the version with parMap commented out, did you?  (That's what I did at first)
14:39:09 <vixey> data Flowchart {parameters} = Constructor {Types} | ...
14:39:11 <Botje> pozic: i've written some code using it, yes
14:39:12 <Baughn> dfrey|work: It's actually back up to 11 with four threads
14:39:16 <ziman> dfrey|work, just to be sure, did you compile the program with ghc -threaded and the run it with +RTS -N2 ?
14:39:18 <Baughn> That's.. pathological
14:39:31 <Baughn> (Well, I only actually have two cores, but still)
14:39:34 <pozic> Botje: let me guess, you graphs had less than 10000 vertices?
14:39:45 <Botje> yes :p
14:39:46 <dfrey|work> ziman: -N4
14:39:55 <pozic> Botje: :)
14:40:00 <rwbarton> For me it goes up to 8 seconds with -N4.  (But I only have 2 cores.)
14:40:12 <unenough> pozic, what happens after 10000 vertices?
14:40:26 <pozic> unenough: you and your machine have died.
14:40:33 <rwbarton> pozic: I thought that was Data.Graph.Inductive.
14:40:34 <sbahra> pozic, why?
14:40:37 <unenough> untrue
14:41:00 <rwbarton> Or Data.Graph.FGL or whatever it's called
14:41:06 <dfrey|work> wait, I might have been looking at the wrong numbers...
14:41:10 <unenough> i'm still here. but is there an alternative? and what's the reason? (in my case the graphs are < 50 nodes probably so no fear)
14:41:28 <vixey> unenough: like this:  data Flowchart {parameters} = Constructor {Types} | ...
14:41:52 <lilac> dfrey|work: map: 5.5s. parMap -N1: 6.2s. parMap -N2: 4.5s.
14:41:53 <pozic> rwbarton: oh, right, Data.Graph specifically not, but Inductive, yes. I thought that one was meant.
14:41:59 <unenough> vixey, ok, but how to connect nodes, etc?
14:42:06 <vixey> unenough: what
14:42:19 <sbahra> unenough, I would suggest a haskell book.
14:42:26 <sbahra> @RWH
14:42:26 <unenough> yeah, ok. sorry :)
14:42:26 <pozic> They are in the same hierarchy and Data.Graph doesn't have a lot of functionality.
14:42:26 <lambdabot> Unknown command, try @list
14:42:29 <sbahra> fucker
14:42:37 <sbahra> Sorry, not directed to you. :-P
14:42:46 <ziman> 9.8s to 9.2s on two cores here.
14:42:50 <sbahra> unenough, "Real World Haskell"
14:43:07 <pozic> unenough: still, you will probably end up writing your own graph representation.
14:43:09 <ziman> (map+nonthreaded -> 9.8s, parMap + -N2 -> 9.2s)
14:43:10 <vixey> unenough: If you don't know how you will represent this thing in haskell, then it's probably too early to think about whether it's a functor or monad or whatever
14:43:39 <unenough> vixey, probably true. it was a premature question, i'll put it on hold.
14:43:40 <rwbarton> My results are map+nonthreaded -> 8.8s, parMap + -N2 -> 7s using the more sensible methodology of ziman.
14:44:12 <unenough> sbahra, thanks for the tip, looks great
14:44:26 <sbahra> There is also "Learn Me a Haskell", iirc
14:44:31 <sbahra> Which is a nice introduction
14:44:44 <jkr> Learn YOU A Haskell ;)
14:44:47 <grul> learn you a haskell* :))
14:45:05 <jkr> Great intro, but the really interesting stuff (IO, ...) is still under construction
14:45:05 <mdmkolbe> is there a better way to write this? with (0 :: Float) (\a -> with (0 :: Float) (\b -> with (0 :: CInt) (\c -> with (0 :: Float) (\d -> body_expr)))
14:45:06 <unenough> sbahra, yes i'm going through that one now :) it's fun
14:45:25 <vixey> mdmkolbe: what if you dro all the type annotations?
14:45:34 <vixey> mdmkolbe: what if you drop*
14:45:42 <Baughn> dfrey|work: http://hpaste.org/11736#a1 <-- Here, this variant shows how much work each thread has to do
14:45:54 <Baughn> dfrey|work: I think you'll now understand why this is a bad way to use parMap. ;)
14:46:03 <mdmkolbe> vixey: I will do that, they were just for clarity in the example
14:46:16 <vixey> mdmkolbe: oh I see, so they aren't essential
14:46:21 <mdmkolbe> I'm mostly anoyed by the repeated "with" calls
14:46:43 <Baughn> dfrey|work: Well, there's basically only two primes that have any significant work, so it's not surprising that the parallelization maxes out at two threads
14:46:46 <yitz> @type with
14:46:46 <vixey> mdmkolbe: so it looks like a type error
14:46:47 <lambdabot> Not in scope: `with'
14:47:05 <vixey> mdmkolbe: sice Float isn't an arrow
14:47:16 <Baughn> dfrey|work: (How many cores do you have?)
14:47:21 <mdmkolbe> @type with
14:47:22 <lambdabot> Not in scope: `with'
14:47:35 <mdmkolbe> @type Foreign.Marshal.Utils.with
14:47:36 <rwbarton> Baughn: It's not a bad way per se, it's just that there's less parallelism in this algorithm than there seems to be at first glance.
14:47:36 <lambdabot> forall a b. (Foreign.Storable.Storable a) => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
14:47:43 <yitz> ah
14:48:19 <Baughn> That was rather my point, yep. ;)
14:48:21 <yitz> Didn't Cale discover that these things work out nicely in the Cont monad?
14:48:33 <Baughn> @index Cont
14:48:33 <lambdabot> Control.Monad.Cont, Control.Monad.Cont
14:48:45 <dolio> rwbarton: Is it not using both cores fully?
14:49:14 <rwbarton> Baughn: dolio: right.  It would be better if 50 were, like, 500.
14:49:30 <rwbarton> As it is there's one big computation, one smaller computation, and 48 tiny computations
14:49:47 <Baughn> rwbarton: I'm surprised that increasing the thread count beyond 2 slows it down this much, though
14:50:04 <unenough> every paragraph in that book seems to have at least 9 comments
14:50:18 <rwbarton> Baughn: Yeah, that's kind of strange, you'd think the running time would be dominated by the cost of that big computation.
14:50:31 <dfrey|work> Baughn: It makes sense now.  The problem was a combination of me choosing a problem that wasn't as parallelizable as I thought and looking at the wrong number from the output generated by the -s flag
14:51:19 <Baughn> rwbarton: ..with -N8 it never finishes
14:52:02 <Baughn> dfrey|work: There's a much more efficient primality test in the Crypto library, by the way
14:52:12 <lilac> dfrey: upping it to 'take 1000' i get 135% CPU usage. not great, but...
14:52:39 <dfrey|work> Baughn: This isn't a real problem I'm trying to solve.  I was just looking for a quick way to test parallelism
14:53:30 <Baughn> dfrey|work: Haskell has a way of ruining quick parallelism tests, I've found
14:53:52 <jkr> How do I use abstract data types in Haskell? For example, I want to use the feed libraries parseFeedString, which returns a "Feed", which can be (I guess) a RSSFeed, RDFFeed, XMLFeed and so on
14:54:06 <jkr> How can I write a function that can handle all of them?
14:54:12 <Baughn> dfrey|work: The /last/ lack of parallelism query I saw had someone running the same algorithm on two nearly identical lists. Well, ghc had figured that out, and merged the jobs.. it was just as fast on one core as on two, then. :P
14:54:32 <vixey> jkr, well I guess there are 3 main ways..
14:54:39 <dolio> Oh, I see. By not parallelizable you mean that for the 'embarassingly parallel' pieces, most contain no work.
14:54:44 <vixey> jkr, you can use a variable, to handle every case at once
14:54:55 <vixey> jkr, or you could pattern match on each case, to do every case
14:54:58 <dolio> (Compared to the others.)
14:55:14 <vixey> jkr, or you could maybe bbuild it up using primitive funcctions efined in the library or from typeclasses
14:55:14 <dfrey|work> When I changed the problem to take 50 odd numbers, the results are:  -N4: 7,43s  -N3: 7.84s, -N2: 10.92s, -N1: 17.18s, map instead of parMap (without -threaded): 15.11s
14:55:14 <dfrey|work> Baughn: hehe
14:55:40 <Baughn> dfrey|work: The overhead for parMap is quite large. Try with 5000
14:56:05 <Baughn> dfrey|work: ..no wait, that won't help
14:56:12 <Baughn> dfrey|work: Try with 5000 and parMapChunk. ;)
14:56:13 <ziman> Baughn, it was me http://hpaste.org/11335
14:56:14 <jkr> vixey: Can't I just work with the "Feed" type? The functions declared in the library seem to be pretty generic
14:56:18 <jkr> At least their names
14:56:28 <vixey> jkr, yeah that's one of the ways I meant
14:56:30 <Baughn> dfrey|work: *parListChunk
14:56:57 <Baughn> ziman: Ah yes
14:57:25 <jkr> To be more specific: I have a function of type :: URI -> Feed, which fetches the feed and returns the result of parseFeedString (which is also a "Feed")
14:57:28 <bbs> hello -- can people help me?
14:57:36 <bbs> i need to refine a program
14:57:44 <jkr> However, I'm getting this: Not in scope: type constructor or class `Feed'
14:57:48 <bbs> Cale: are you still present?
14:57:56 <bbs> jkr: code?
14:58:09 <bbs> jkr: i may be able to help you with this
14:58:09 <Baughn> dfrey|work: It's not entirely obvious why adding threads makes this so much slower, but I bet it has something to do with your frankly insane allocation rate
14:58:10 <vixey> jkr, oh just leave out the type annotation
14:58:12 <lilac> jkr: import Text.Feed.Types (Feed)
14:58:20 <jkr> Ah, right
14:58:25 <bbs> jkr: :)
14:58:30 <jkr> Hehe, just found it myself :)
14:58:31 <lilac> Baughn: it's the same speed at -N2 as -N8 for me
14:58:46 <jkr> Is there a way to do something like "import Text.Feed.*"?
14:58:52 <bbs> jkr: icky haskell
14:58:56 <Baughn> lilac: Or perhaps something to do with ghc 6.10?
14:59:00 <bbs> jkr: oops i mean jaa
14:59:07 <jkr> :)
14:59:08 <bbs> s/jaa/java
14:59:17 <bbs> jkr: why not just Text.Feed :)
14:59:20 <lilac> Baughn: could be; i'm on 6.8.2
14:59:20 <dolio> Baughn: Yeah. Having 8 threads computing the primes up to N-million probably isn't healthy.
14:59:27 <jkr> I tried
14:59:27 <dfrey|work> Baughn: What do you mean by "insane allocation rate"?
14:59:30 <bbs> jkr: and
14:59:37 <lilac> bbs: afaics there is no Text.Feed :(
14:59:41 <jkr> Could not find module `Text.Feed'
14:59:48 <Baughn> dfrey|work: Nine gigabytes allocated for this amount of work? That's just not healthy.
14:59:50 <bbs> lilac: oh icky
15:00:00 <bbs> lilac: i was thinking it might be like Data.Bits
15:00:01 <Baughn> dfrey|work: Especially since it should be able to run with basically no allocations. ;)
15:00:07 <bbs> jkr: just use the one lilac said abovce
15:00:09 <dfrey|work> Baughn: ahh
15:00:10 <Baughn> dfrey|work: Also...
15:00:17 <Baughn> dfrey|work: I upped the prime test count to 5,000
15:00:19 <jkr> Ok :) I just tried to be lazy :)
15:00:27 <Baughn> dfrey|work: Then I used parListChunk with 500-sized chunks
15:00:42 <Baughn> dfrey|work: Then I forgot to recompile
15:01:06 <dfrey|work> and it was just as fast as before!  :)
15:01:38 <bbs> p/me sighs
15:01:41 <Baughn> dfrey|work: Yes. :P
15:01:51 <bbs> anyone good with parsers
15:01:55 <bbs> and interpreters
15:02:17 <bbs> vixey: do you remember the problems i was showing you yesterday?
15:02:21 <dfrey|work> Baughn: Can you paste that version.
15:02:46 <Baughn> dfrey|work: Just as soon as it compils
15:04:31 <dfrey|work> Baughn: Is the idea with parListChunk that it breaks the problem down into a number of pieces that you specify rather than a thread for each list element?
15:05:00 <Baughn> dfrey|work: Well, almost. It breaks it down into N pieces per spark (not exactly thread)
15:05:05 * lilac only gets 5GB allocated; feels cheated
15:05:35 <Baughn> dfrey|work: You could do yours, but you'd have to know the size of the list first. Besides, this way uses less memory, especially if you combine with the buffer thingy
15:05:41 <Baughn> dfrey|work: http://hpaste.org/11738
15:05:50 <vixey> bbs, yeah
15:06:00 <bbs> vixey: can you help me clean up a working one
15:06:12 <vixey> bbs, maybe
15:06:18 <Baughn> dfrey|work: Er, but 5000 may have been a bit much. It's taking its time.
15:08:21 <Baughn> dfrey|work: parBuffer really would be the best option here, since it's printing them sequentially
15:08:42 <Baughn> I'm not sure if you could do that and still do chunking without actually splitting up and recombining the list, though
15:11:23 <jdrake> I am preparing a new ghc under debian's package system, is there a way to get ghc to recompile all installed modules under the new ghc?
15:11:25 <Baughn> dfrey|work: ...right, done. Productivity's down a bit, but it wound up using ~195% of my cores.
15:11:38 <Baughn> That is, 97.5% of my total capacity
15:11:48 <dons> better than 50%
15:11:55 <Baughn> Indeed. :P
15:13:16 <sbahra> dons, earlier I asked if there was any reason I should not create a FreeBSD package for cabal-install (and add it to ports). Do you know of any? Should I wait for "the haskell platform"?
15:13:53 <dons> i know of no reason. please create one.
15:14:21 <vixey> bbs, what about it ?
15:14:54 <sbahra> dons, cool
15:15:03 <bbs> vixey: i have a whole new post
15:15:06 * sbahra has been adding all the dependencies to pors whenever he has had time
15:15:30 <bbs> parser : Your paste can be seen here: http://zlin.dk/p/?MzgzNWMw
15:15:43 <bbs> abstract syntax : Your paste can be seen here: http://zlin.dk/p/?MDBlMGFl
15:15:54 <bbs> interpreter: Your paste can be seen here: http://zlin.dk/p/?ODE0Y2Iw
15:15:58 <bbs> the interpreter needs the most work
15:16:00 <bbs> its a POS
15:16:10 <vixey> (I a) == (I b) = a==b
15:16:12 <vixey> you can rewrite as
15:16:17 <vixey> I a == I b = a==b
15:16:25 <vixey> since it's an infix operator
15:17:19 <vixey> do you remember what I said about using functions instead of strings? why not do that first
15:17:44 <Axman6> :t forever x = x >> forever x
15:17:45 <lambdabot> parse error on input `='
15:17:51 <Axman6> :t forever x = x >> forever x in forever
15:17:52 <lambdabot> parse error on input `='
15:17:57 <Axman6> rawr
15:18:00 <Axman6> @let forever x = x >> forever x
15:18:00 <lambdabot>  <local>:3:17:
15:18:00 <lambdabot>      Ambiguous occurrence `forever'
15:18:00 <lambdabot>      It could refer to eit...
15:18:05 <Axman6> :t forever
15:18:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
15:18:10 <Axman6> rawr
15:18:12 <bbs> vixey: no i don't
15:18:18 <bbs> vixey: can you help me in overflow
15:18:20 <bbs> its so noisy in here
15:18:30 <vixey> no
15:18:41 <vixey> lets just talk louder than everyone else :p
15:18:46 <Axman6> doesn't seem that noisy in here to me...
15:18:51 <Axman6> apart from all my noise
15:18:52 <Baughn> :t let forever x = x >> forever x in x
15:18:53 <lambdabot> Expr
15:18:57 <Baughn> Axman6: That's how you do it.
15:19:06 <Axman6> cheers, knew i was close
15:19:07 <Baughn> Axman6: ..Even if it /does/ go horribly wrong.
15:19:14 <bbs> vixey: no i don't remember
15:19:26 <Baughn> :t let forever x = x >> forever x in (x :: Monad a => a -> a) -- Now it just validates
15:19:27 <lambdabot>     `a' is not applied to enough type arguments
15:19:27 <lambdabot>     Expected kind `??', but `a' has kind `* -> *'
15:19:27 <lambdabot>     In the type `a -> a'
15:19:40 <vixey> bbs, every line like this:
15:19:41 <vixey> #
15:19:41 <vixey> evaluate (RelOp "=" aexp1 aexp2) state dec =
15:19:41 <vixey> #
15:19:42 <vixey> if ((execute aexp1 state dec ) == (execute aexp2 state dec )) then True else False
15:19:48 <Baughn> ..um, yeah.
15:19:59 <vixey> can be changed to something else, should be in yesterdays logs
15:20:27 <Axman6> Baughn: i was testing, because ghci tells me that forever's type is Monad m => m a -> m b
15:20:55 <Baughn> Axman6: LB likes to default to Expr, however
15:21:42 <Axman6> :t let forever x = x >> forever x in forever
15:21:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:21:43 <jkr> What does the return type of "simpleHTTP :: Request -> IO (Result Response)" mean? Is it a tuple containing a Result and a Response?
15:21:52 <vixey> it's not a tuple jkr
15:21:56 <ddarius> :t fix . (>>)
15:21:56 <bbs> vixey: you mean like
15:21:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:21:59 <bbs> evaluate (RelOp "=" aexp1 aexp2) state = if ((execute aexp1 state) == (execute aexp2 state)) then True else False
15:22:02 <bbs> evaluate (RelOp (*~*) aexp1 aexp2) state = (execute aexp1 state) *~* (execute aexp2 state)
15:22:08 <vixey> bbs, yeah exactly
15:22:09 <Axman6> jkr: it's a result containing a response
15:22:14 <vixey> bbs, not using strings is a really big improvement
15:22:19 <Baughn> Axman6: Aheh. Right, my mistake.
15:22:28 <bbs> where s/*~*/=
15:22:31 <bbs> vixey: right?
15:22:35 <vixey> no
15:22:38 <vixey> it's actualy *~*
15:22:43 <bbs> for what?
15:22:46 <bbs> for all of them oO
15:23:11 <vixey> yeah this _one_ equation does every single case
15:23:18 <bbs> for RelOps?
15:23:21 <vixey> because *~* can be any relational function
15:23:26 <vixey> does that make sense?
15:23:34 <bbs> yep
15:23:36 <bbs> neat
15:23:37 <Axman6> i'm having a play with STM at the moment, going well so far... but now i'm off to celebrate my birthday with my girlfriend :) (by her getting her braces removed...)
15:23:46 <jkr> Then what is a Result? Where can I find it's definition and how do I get the response out of it? :)
15:23:46 <vixey> you have to change the ADT a bit to put a functional in there instead of a string though
15:23:57 <vixey> & if you wanted to do a case analysis, you might do something like
15:24:26 <vixey> data Functional = Functional RelationalTag (Integer -> INteger -> Bool)
15:24:28 <vixey> or whatever it is
15:24:31 <mdmkolbe> @hoogle Ptr a -> Int -> IO [a]
15:24:32 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
15:24:32 <lambdabot> Prelude replicate :: Int -> a -> [a]
15:24:32 <lambdabot> Data.List replicate :: Int -> a -> [a]
15:24:47 <bbs> vixey: oO
15:24:51 <bbs> did you look at my AS?
15:25:11 <bbs> vixey: i don't think you understand how basic my understanding of haskell is
15:25:13 <jkr> :t Result isn't known in ghci and is not a constructor from Network.HTTP
15:25:14 <lambdabot> parse error on input `in'
15:25:31 <vixey> bbs, if you didn't understand something I said just ask
15:25:44 <bbs> vixey: i don't get your data Functional part
15:26:07 <bbs> i mean I was given most of the other stuff just not the interpreter
15:26:20 <bbs> vixey: will I have to change the parser too?
15:26:28 <bbs> i mean thats not going to fly for him most likely
15:27:33 <monochrom> ghc 6.10 has generalized list comprehension. What is generalized list comprehension? Does it mean monad comprehension, finally? :)
15:28:05 <Baughn> monochrom: Nope, it means horrible sql-like syntax
15:28:07 <eu-prleu-peupeu> hello haskellers
15:28:28 * monochrom has a heart attack
15:28:31 <eu-prleu-peupeu> just haskell it
15:28:38 * monochrom 's brain explodes
15:28:40 <Saizan> SELECT x,y FROM list WHERE ..
15:28:43 <vixey> l o l
15:28:54 <eu-prleu-peupeu> monochrom: clearly your brain was not coded in haskell
15:29:03 <Baughn> monochrom: "8.3.8. Generalised (SQL-Like) List Comprehensions"
15:29:14 <vixey> @remember <eu-prleu-peupeu> just haskell it
15:29:15 <lambdabot> Okay.
15:29:40 <Baughn> monochrom: "output + [(the dept, sum salary) | (name, dept, salary) <- emplyees, then group by dept, then sortWith by (sum salary), then take 5]
15:29:44 <eu-prleu-peupeu> yay my 1st lambdabot quote :D \o/
15:29:46 <monochrom> Someone should @remember this for the next HWN.  That my brain explodes when told "generalized list comprehension" means SQL.
15:29:48 <Baughn> monochrom: Does this make you happy?
15:29:54 <Saizan> monochrom: http://research.microsoft.com/~simonpj/papers/list-comp/index.htm
15:29:55 <lambdabot> Title: Comprehensive Comprehensions
15:29:59 <Axman6> eu-prleu-peupeu: better than mine :(
15:30:06 <Axman6> @quote axman6
15:30:06 <lambdabot> No quotes match. Sorry.
15:30:10 <Axman6> @quote Axman6
15:30:10 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
15:30:12 <Baughn> monochrom: Er, that'S supposed to be "output -"
15:30:12 <Axman6> bah
15:30:15 <Baughn> monochrom: Er, that'S supposed to be "output ="
15:32:49 <eu-prleu-peupeu> is there any webhosting i can get with happs ?
15:34:26 <yitz> @go happs hosting
15:34:29 <lambdabot> http://profile.myspace.com/index.cfm?fuseaction=user.viewprofile&friendid=180659254
15:34:29 <lambdabot> Title: MySpace.com - turi(happs) - 29 - Male - east los angeles, California - www.myspa ...
15:34:36 <Axman6> heh
15:34:47 <Saizan> it's not like happs requires anything on the server
15:34:47 <jkr> The Result simpleHTTP returns is not by change a Test.QuickCheck.Result?
15:34:52 <Axman6> anyone know how efficient searches and inserts in Data.Set are?
15:35:02 <jkr> And if so, how do I get Response out of it?
15:35:03 <Saizan> just the ability to run an executable
15:35:06 <Axman6> jkr: i doubt it, it'll be all happs stuff
15:35:12 <eu-prleu-peupeu> Saizan: and listen on a given port, right ?
15:35:21 <jkr> What's happs?
15:35:22 <Saizan> eu-prleu-peupeu: right
15:35:31 <Axman6> oh, maybe it's not happs
15:35:44 <Axman6> anyway, look at the simpleHTTP source/haddock
15:35:54 <jkr> Ok
15:35:56 <eu-prleu-peupeu> ill send an email to a webhosting company asking for it, and darcs also
15:37:43 <jkr> Isn't there a way to make :type be more specific about types and namespaces?
15:37:54 <Axman6> what do you mean?
15:38:22 <Saizan> jkr: you can use :info to see where a datatype comes from
15:38:37 <eu-prleu-peupeu> it will be my main contribution to the haskell comunity: anoying the sys admins of webhosting companies, until haskell is accepted as a de facto standard :)
15:38:58 <jkr> Ah, thanks
15:45:45 <bbs> vixey: ?
15:45:51 <bbs> i'm still confused :/
15:45:57 <bbs> i've been playing with it and now it just fails
15:46:40 <BMeph_> So, does that mean that 'equating' has been put in the libs? :)
15:47:07 <BMeph_> (Concerning the whole SQL-like comprehension abomination...)
15:47:15 <bbs> vixey: can you explain to me a functional?
15:48:40 <vixey> bbs, it stores a function like (==) or (>) or anything, and also a tag like Equals or LessThan
15:51:19 <mdmkolbe> Is there a way in the module syntax to say we want to export everything except one particular constructor or function?
15:52:10 <mmorrow> not really, but you could have a wrapper module that imports that module hiding that one constructor/function then reexports the modules
15:52:14 <mmorrow> s/s//
15:52:34 <mmorrow> *... the module.
15:52:37 <geezusfreeek> ew
15:53:13 <mmorrow> lunabot does that to zap runIO from template-haskell and lift from Control.Monad.*
15:53:33 <mmorrow> s/lift/liftIO/
15:53:44 <vixey> oh that's clever
15:53:46 <mdmkolbe> yeah, but even in that case the constructor would still be visible by importing the right sub-module
15:53:54 <mmorrow> indeed
15:54:06 <vixey> you can also make an interface datatype
15:54:07 * mdmkolbe adds another reason for first class modules to haskell
15:54:14 <vixey> I've seen this a couple times in ocaml but never in haskell
15:54:42 <mmorrow> vixey: what do you have in mind for this datatype?
15:55:00 <vixey> just like a restricted version of the other type
15:55:12 <mmorrow> ohh, i see
15:55:14 <vixey> and you only export that and a tool to freeze it into the real type
15:55:24 <mmorrow> cool
15:55:28 <vixey> (and views to thaw the toplevel construction)
15:55:28 <vixey> =
15:55:38 <Peaker> anyone knows off-hand how to disable line buffering on stdin?
15:55:39 <mmorrow> hmm
15:55:39 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
15:55:49 <vixey> :t hSetLineBuffering
15:55:50 <lambdabot> Not in scope: `hSetLineBuffering'
15:55:59 <vixey> :t hSetBuffering
15:55:59 <mmorrow> @type hSetBuffering
15:56:00 <lambdabot> Not in scope: `hSetBuffering'
15:56:00 <lambdabot> Not in scope: `hSetBuffering'
15:56:10 <mmorrow> hSetBuffering stdin NoBuffering
15:56:15 <Peaker> thanks!
15:59:04 <Peaker> Has anyone here connected/integrated Reactive/Deus with an imperative platform?
15:59:48 <mmorrow> , flip runState (0,1) (replicateM 10 [$mc|[m | (m,n) <- get, () <- put (n,m+n)]|])
15:59:53 <lunabot>  ([0,1,1,2,3,5,8,13,21,34],(55,89))
16:04:02 <b_jonas> um
16:04:07 <b_jonas> , mc
16:04:09 <lunabot>  luna: No instance for (GHC.Show.Show
16:04:55 <b_jonas> what's mc?
16:05:15 <b_jonas> oh wait, that's template haskell
16:05:28 <mmorrow> it's a QuasiQuoter
16:05:34 <b_jonas> I tried to read it as a list comprehension and it totally didn't make sense that way
16:05:35 <mmorrow> , src ''QuasiQuoter
16:05:39 <lunabot>  data QuasiQuoter = QuasiQuoter {quoteExp :: (String -> Q Exp),
16:05:39 <lunabot>                                  quotePat :: (String -> Q Pat)}
16:05:47 <b_jonas> $mc can't even work for slices have to be parenthisized
16:05:59 <mmorrow> it parses the monad comprehension and translates it to a do-block
16:06:17 <gwern> argh, ghc 6.10 has been released
16:06:19 <mdmkolbe> How do I make a cabal package build "in-place" so that I can just "ghci" and ":m Foo" on it directly from the directory I've unpacked it?
16:06:30 <b_jonas> gwern: stable already?
16:06:41 <b_jonas> I've recently installed 6.8.3
16:06:49 <b_jonas> and there's already a new one
16:06:50 <gwern> now we get to enjoy a few months of people trying to support 6.8 and 6.10 simultaneously
16:06:56 <eu-prleu-peupeu> is ghc 6.10.1 worth it ?
16:06:56 <gwern> and ubuntu is still on 6.8.2!
16:06:59 <mmorrow> , ppDoc `fmap` (quoteExp mc) "[m |(m,n) <- get, () <- put (n,m+n)]|]"
16:07:04 <lunabot>  luna: parse error on input `|]'
16:07:07 <mmorrow> , ppDoc `fmap` (quoteExp mc) "[m |(m,n) <- get, () <- put (n,m+n)]"
16:07:12 <lunabot>  do (m_0, n_1) <- get
16:07:12 <lunabot>     () <- put (n_1, m_0 + n_1)
16:07:12 <lunabot>     return m_0
16:07:15 <b_jonas> gwern: do they adapt to 6.10 so fast?
16:07:19 <eu-prleu-peupeu> can i contribute to the ghc project ?
16:07:19 <mdmkolbe> eu-prleu-peupeu: it has DPH and type functions doesn't it?
16:07:25 <gwern> I wonder whether they fixed the `infix` bug?
16:07:35 <b_jonas> gwern: I thought for a few months we'll still have people trying to support 6.8 and 6.6 simulatnously
16:07:52 <b_jonas> gwern: which infix bug?
16:07:56 <gwern> b_jonas: no, I'm grousing that ubuntu/debian are so slow on packaging that they haven't caught up to the *previous* stable yet
16:08:13 <b_jonas> gwern: but 6.8.3 is new
16:08:17 <b_jonas> gwern: really new
16:08:18 <gwern> b_jonas: xmonadcontrib ran into a problem with (5 `seconds`) not compiling, where seconds is :: Int -> Int
16:08:40 <gwern> 6.8.3 has been out for what feels like months, hasn't it?
16:08:41 <mdmkolbe> eu-prleu-peupeu: contributions are always welcome.  see http://hackage.haskell.org/trac/ghc/wiki/GettingStarted to get started
16:08:43 <lambdabot> Title: GettingStarted - GHC - Trac
16:09:10 <gwern> and then I'm going to have to update all the packages I use and am responsible for, probably :(
16:09:24 <eu-prleu-peupeu> i dont know how to contribute, but i guess i should...
16:09:25 <BMeph_> Doesn't Ibex have 6.8.3?
16:09:45 <jeffz> eu-prleu-peupeu: you can contribute by simply writing software in Haskell
16:09:53 <b_jonas> eu-prleu-peupeu: maybe download the new version, try to install it, and report any test failures and other bugs you find?
16:10:04 <gwern> I'I'm on Intrepid, and I think I'm up to date, and it's still 6.8.2
16:10:18 <eu-prleu-peupeu> okey
16:10:22 <mdmkolbe> eu-prleu-peupeu: the hackage site hackage.haskell.org always has a need for new good libraries for Haskell
16:10:37 <eu-prleu-peupeu> okey, ill work on it
16:10:47 <eu-prleu-peupeu> not quite directly related to ghc, but it will do
16:10:48 <mdmkolbe> eu-prleu-peupeu: that way you don't have to be a compiler expert to help out
16:11:03 <eu-prleu-peupeu> i have read the dragon book :P
16:11:17 <bbs> meh
16:11:20 <bbs> i's lost
16:11:29 <bbs> anyone can explain to me the data Functional
16:11:45 <mmorrow> eu-prleu-peupeu: just start reading the ghc code
16:11:59 <ddarius> bbs: There are probably books/tutorials you should be reading...
16:12:46 * gwern accidentally an entire monad tutorial!
16:12:54 <bbs> ddarius: can you point me in the direction?
16:14:58 <bbs> ddarius: vixey was explaining it to me
16:15:02 <bbs> and then left :)
16:15:12 <bbs> i finished the program i just want to make it better!
16:15:22 <roconnor> mm, view patterns
16:15:46 <ddarius> bbs: One of the benefits of books is that they don't go eat dinner.
16:15:48 <mmorrow> , mdo 0:xs <- xs ; return xs
16:15:50 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = [t]
16:15:59 <mmorrow> oops
16:16:00 <bbs> ddarius: ok well where can i find this ?
16:16:04 <bbs> thats all i want to know
16:16:07 <bbs> i'll read i just can't find it
16:16:14 <mmorrow> anybody have any interesting mdo one-liners?
16:16:35 <eu-prleu-peupeu> bye, sleeppy time
16:16:51 <gwern> mmorrow: I have a bunch in mueval's test script? :)
16:17:00 <mmorrow> hmm
16:17:02 * mmorrow looks
16:17:04 <ddarius> bbs: There is an entire section on haskell.org.  Go to haskell.org and click "Learning Haskell" under the "Learning" section.
16:17:15 <ddarius> Or "Books and Tutorials" under that section.
16:17:20 <bbs> ddarius: does it discuss the "Functional" data
16:17:23 <bbs> :t Functional
16:17:24 <lambdabot> Not in scope: data constructor `Functional'
16:17:44 <gwern> @hoogle Functional
16:17:45 <lambdabot> Distribution.Extension FunctionalDependencies :: Extension
16:17:45 <lambdabot> Language.Haskell.Extension FunctionalDependencies :: Extension
16:17:59 <ddarius> I don't know what you mean by "the 'Functional' data"
16:18:38 <b_jonas> mmorrow: no, I don't even understand how that whole monadfix stuff works
16:18:46 <mmorrow> gwern: um, tests.sh?
16:18:49 <mmorrow> i don't see any
16:18:51 <b_jonas> is it good for anything really?
16:19:02 <gwern> mmorrow: there are tons of one-liners in tests.sh!
16:19:04 <ddarius> b_jonas: Yes!
16:19:07 <gwern> the entire thing is one-liners
16:19:17 <mmorrow> gwern: heh. /mdo/ one-liners :)
16:19:32 <mmorrow> , mdo return 0
16:19:33 <lunabot>  luna: No instance for (GHC.Show.Show (t1 t))
16:19:38 <mmorrow> , mdo return 0 :: Maybe Int
16:19:39 <lunabot>  Just 0
16:19:46 <gwern> oh. well, if you find a mdo one-liner which works in mueval, be sure to show me
16:19:58 <mmorrow> will do
16:21:38 <mmorrow> , mdo y <- x:xs; x <- repeat 0; return y
16:21:40 <lunabot>  luna: Not in scope: `xs'
16:22:00 <mmorrow> , mdo y <- x:undefined; x <- repeat 0; return y
16:22:03 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:22:46 <b_jonas> @src [] mfix
16:22:46 <lambdabot> mfix f = case fix (f . head) of
16:22:46 <lambdabot>            []    -> []
16:22:46 <lambdabot>            (x:_) -> x : mfix (tail . f)
16:22:53 <b_jonas> @undo mdo y <- x:undefined; x <- repeat 0; return y
16:22:53 <lambdabot>  Parse error at "<-" (column 7)
16:23:02 <b_jonas> @unmdo mdo y <- x:undefined; x <- repeat 0; return y
16:23:02 <lambdabot>  Parse error at "<-" (column 7)
16:23:08 <b_jonas> ,undo mdo y <- x:undefined; x <- repeat 0; return y
16:23:10 <lunabot>  luna: parse error on input `mdo'
16:23:18 <b_jonas> lunabot, undo mdo y <- x:undefined; x <- repeat 0; return y
16:24:12 <mmorrow> , fix (0:)
16:24:14 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:24:15 <mmorrow> , fix (0:)
16:24:16 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:24:34 <jkr> Is there "isNothing" function or something similar?
16:24:37 <jkr> +a
16:24:50 <dolio> @type isNothing
16:24:51 <lambdabot> forall a. Maybe a -> Bool
16:25:00 <mmorrow> , fix (0:)
16:25:03 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:25:05 <b_jonas> it's in Data.Maybe
16:25:10 <b_jonas> => jkr
16:25:16 <jkr> Cool, thank you
16:25:23 <ddarius> Usually it's better to write your code so that you don't need isFoo functions.
16:25:56 <Peaker> I am trying to re-implement Phooey as an educational exercise.  Phooey implement the UI type via a big monad transformer including reader,state,IO.   This means that the UI type is already specific to the GUI it builds.
16:26:27 <Peaker> I want the UI type to have all the information required to have various run functions of the signature UI a -> IO a  -- such that you can take the same UI value and use a command-line or SDL-based GUI over it
16:26:53 <Peaker> But I can't figure out a way for the (UI a) type to encompass this information in a generic enough way, that still has some static type
16:28:05 <Peaker> I guess I'll start with something specific to cli, then see how/if I can generalize it
16:31:48 <bbs> ddarius: i still don't see this data type
16:31:56 <bbs> honestly if you know where it is why won't you just tell me :/
16:32:08 <ddarius> bbs: I already said, I don't know what you even mean.
16:34:18 <bbs> ah
16:34:23 <bbs> well that changes everything
16:34:29 <bbs> :)
16:34:32 <Peaker> bbs: can you re-ask your question in full?
16:34:35 <bbs> sry i misunderstood you
16:34:40 <bbs> i was told earlier
16:34:53 <bbs> that i can use a function like *~* for relative operators
16:35:05 <bbs> instead of using strings like "<"
16:35:07 <bbs> in an interpreter program
16:36:31 <mdmkolbe> > f . x . y $ z :: Expr
16:36:33 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `Expr'
16:36:54 <bbs> but it was depended upon a data type :data Functional = Functional RelationalTag (Integer -> INteger -> Bool)
16:36:57 <bbs> something like that
16:36:59 <mdmkolbe> :t \f x y z -> f . x . y $z
16:37:00 <lambdabot> forall c b c1 a. (c1 -> c) -> (b -> c1) -> (a -> b) -> a -> c
16:38:00 <ddarius> vixey earlier gave you a definition of a data type called "Functional".  It's not something that you look up, it was an example.  If you were more familiar with Haskell, you'd probably have understood what she was trying to say, hence my recommendation to read a book.
16:38:31 <mdmkolbe> What is the best way to get from Int to CInt?
16:38:48 <ddarius> mdmkolbe: What is the answer to such questions always?
16:39:05 <mdmkolbe> ?
16:39:11 <ddarius> @quote fromIntegral
16:39:11 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:40:11 <mdmkolbe> ddarius: nice quote (and nice function)
16:40:16 <ddarius> > fromIntegral (3 :: Int) :: CInt
16:40:17 <lambdabot>   Not in scope: type constructor or class `CInt'
16:40:21 <ddarius> figures
16:45:25 <pastorn> anyone here given a stab at robocode?
16:46:09 <jkr> Can I reuse names of Maybe values in cases? Like: foo <- something \ case foo of \ Nothing -> ... \ Just foo -> ...
16:46:25 <pastorn> a guy in ##java mentioned it and it seems really cool, though writing haskell for it might not be the easiest task...
16:46:39 <jkr> Or should/must I give the alternativen in the case expression another name?
16:47:27 <pastorn> jkr: no, when you do x <- someMaybeValue, assume that if someMaybeValue :: Maybe a then x :: a
16:47:51 <Pseudonym> @pl \(ks,v) -> (tail ks,v)
16:47:51 <lambdabot> first tail
16:48:03 <pastorn> jkr: instead use let mx = someMaybeValue in case mx of ...
16:49:06 <pastorn> jkr: what you wrote will work if you have something :: Maybe (Maybe a)
16:49:35 <BMeph_> pastorn: Sorry, I only Stab Westward... ;p
16:49:38 <pastorn> though the "Just foo" line will probably not typecheck
16:50:00 <pastorn> BMeph_: sorry, don't get that :/
16:50:15 * pastorn may be stupid, or just unindulged
16:50:24 <BMeph_> pastorn: You've never heard of Stabbing Westward?
16:50:32 <pastorn> nope
16:51:45 * BMeph_ weeps for the Death of Culture...
16:53:22 <pastorn> BMeph_: nawww.... but so you've never coded for RoboCode?
16:53:43 <BMeph_> pastorn: ..."never heard of it." :)
16:54:15 <pastorn> it seems kinda awesome, you take a magic bytecode file (compiled from java) and your own robots bytecode and then let them battle
16:54:39 <pastorn> it's a 3d world so you need to be clever with everything you do
16:55:05 <pastorn> though they don't have any haskell -> robocodemagicsfileformat thingy yet
16:55:40 <pastorn> http://robocode.sourceforge.net/
16:55:41 <lambdabot> Title: Robocode Home
16:56:34 <p_l> robocode?
16:56:56 <p_l> I think we have something like that at university, need to check :D
16:57:06 <mdmkolbe> @hoogle (a -> b) -> m [a] -> m [b]
16:57:06 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
16:57:06 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
16:57:06 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
16:57:29 <pastorn> @type liftM2
16:57:30 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:57:35 <pastorn> @type liftM
16:57:36 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:57:42 <pastorn> @type liftM map
16:57:43 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m ([a] -> [b])
16:57:47 <pastorn> shit
16:57:54 <Saizan> pastorn: so you'd have to generate java bytecode from haskell?
16:58:02 <mdmkolbe> @type liftM (map toInteger)
16:58:03 <lambdabot> forall a (m :: * -> *). (Monad m, Integral a) => m [a] -> m [Integer]
16:58:26 <pastorn> Saizan: nah, i think more likely you'd have to generate the robocode bytecode format
16:58:46 <pastorn> though they _MIGHT_ use the java bytecode as a file format, not sure...
16:59:06 <Saizan> heh, that was my question more or less :)
16:59:24 <mib_qpx931> wrote a function in list comprehension and i want to convert it to high order anyhelp please
16:59:30 <mib_qpx931> here's the function
16:59:31 <mib_qpx931> findall (a,b,n) =  [x | x <- [1..n], is_div x a, is_div x b]
16:59:48 <pastorn> yeah, it seems that everything is java libs...
17:00:00 <pastorn> http://robocode.sourceforge.net/docs/robocode/
17:00:01 <lambdabot> Title: Robocode 1.6.1 API
17:00:07 <mib_qpx931> any aid??
17:00:10 <pastorn> though there's always ffi
17:00:15 <mib_qpx931> findall (a,b,n) =  [x | x <- [1..n], is_div x a, is_div x b]
17:00:18 <mib_qpx931> ??
17:00:28 <mib_qpx931> converting it to high order
17:00:50 <pastorn> mib_qpx931: you probably want to use filter
17:01:03 <monochrom> filter (`is_div` a) something
17:01:17 <p_l> pastorn: Unfortunately lately it seems that everything with a hint of academics in it is in Java...
17:01:41 <mib_qpx931> yeah how???
17:01:51 <pastorn> findall a b n = filter (flip is_div b) . filter (flip is_div a) $ [1..n]
17:01:53 <mib_qpx931> i tried doing that
17:02:13 <monochrom> It's better than no academic work goes into Java.
17:02:25 <BMeph_> ...and what happened, mib_qpx931? :)
17:02:38 <mib_qpx931> wrong results
17:02:42 <mib_qpx931> > flip?
17:02:43 <lambdabot>   <no location info>: parse error on input `;'
17:02:49 <monochrom> Truth or Dare!
17:02:52 <pastorn> @type flip
17:02:53 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
17:02:58 <p_l> monochrom: But that doesn't mean that I don't want to cry from despair when I see the example exam from last year
17:03:01 <mib_qpx931> > @source flip
17:03:02 <lambdabot>   <no location info>: parse error on input `@'
17:03:16 <mib_qpx931> @source flip
17:03:17 <lambdabot> flip not available
17:03:33 <pastorn> mib_qpx931: i had to use flip since your is_div had the varying argument last, so i needed to change the order of wich they were applied to the function
17:03:40 <mib_qpx931> is there a easier way to do this without use a flip
17:03:58 <monochrom> pastorn's code is right. wrong results come from your error.
17:04:01 <pastorn> let isDiv x y = is_div y x in ...
17:04:11 <mib_qpx931> couldn't have used fold
17:04:14 <mib_qpx931> ??
17:04:31 <pastorn> then you can just write filter (isDiv a) . filter (isDiv b)
17:05:15 <pastorn> mib_qpx931: paste what you want to do and the definition of is_div so we can see the idea. paste here
17:05:18 <pastorn> @paste
17:05:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:06:00 <pastorn> mib_qpx931: (what you want to do == some input and its intended output)
17:10:50 <mib_qpx931> http://hpaste.org/11740
17:11:00 <mib_qpx931> pastron just posted it
17:12:26 <jkr> Good night everyone, thanks for all the help
17:17:31 <pastorn> mib_qpx931: there, annotated
17:17:34 <pastorn> and it works
17:17:43 <pastorn> intersect is in Data.List
17:18:56 <jdrake> Is there any reason why it might not be a good idea to upgrade to 6.10?
17:20:03 <pastorn> mib_qpx931: is that ok?
17:21:45 <mib_qpx931> yeah, that's cool
17:22:51 <pastorn> you should look at the definition of filter to see why i defined isDiv
17:23:17 <pastorn> mib_qpx931: use @src functionName here and lambdabot will tell you :)
17:23:40 <p_l> question: is the Visual Haskell developed anymore? The webpage states it works on Visual Studio 2003 & 2005, however I'd like to have an integrated environment with 2008...
17:25:56 <monochrom> They're working on a time machine to fly you back to 2005. Elegant, general solution to all software incompatibility problems.
17:26:35 <p_l> not really ;-)
17:27:13 <pastorn> p_l: i think there was something on this years summer of code
17:27:30 <pastorn> p_l: you should ask google about google :p
17:27:33 <monochrom> "I just found this 'The 7th Guest' CD under my grandpa's bed."  "It worked under DOS 6 in 1995."  "OK, I'll be right there!"
17:28:01 <mib_qpx931> @src intersect
17:28:02 <lambdabot> intersect = intersectBy (==)
17:28:34 <mib_qpx931> the intersect works like zipWith (==) right???
17:28:44 <andrewsw> @src intersectBy
17:28:45 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
17:29:12 <mib_qpx931> @src zipWith
17:29:13 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
17:29:13 <lambdabot> zipWith _ _      _      = []
17:29:49 <gaze> If I wanted a function to construct a binary tree from a list of values and not use any mutable data structures, would the tree have to be recreated for each cycle of moving through the list of values?
17:29:50 <p_l> pastorn: it has "not-accepted" as status
17:30:00 <pastorn> mib_qpx931: no, with zipWith element 0 in the left list is checked against element 0 in the right
17:30:16 <andrewsw> mib_qpx931: no, zipWIth would give you pairwise comparison.
17:30:20 <Beelsebob> gaze: you would have to write an insert function of some sort
17:30:24 <pastorn> with intersectBy each element in the left list is checked against every element in the right list
17:30:31 <Beelsebob> which would rewrite a small amount of the tree
17:30:52 <mmorrow> has anyone used vnc over satellite internet enough to know if the lag is enough to make you crazy?
17:30:54 <andrewsw> literally the intersection of two lists
17:31:07 <andrewsw> (for (==))
17:31:29 <mmorrow> (just read that 1.2 seconds is the best-case latency)
17:31:37 <mmorrow> ((speed of light and all that))
17:31:56 <andrewsw> mmorrow: vnc latency over lan makes me crazy
17:32:24 <mmorrow> andrewsw: heh, true but i can deal with that. i mean crazy crazy.
17:32:32 <andrewsw> lol
17:32:47 <mmorrow> like /me smashes my computer and then regrets it crazy
17:32:47 * andrewsw checks that he's in #haskell
17:33:21 <monochrom> i need whelp in haskell?????
17:33:27 <mmorrow> 1.2 seconds does seems like a lot
17:33:30 <bbs> http://zlin.dk/p/?ZTY4NWU4
17:33:33 <monochrom> (now you're sure you're in #haskell)
17:33:34 <mdmkolbe> should a module containing all the event declarations of a system (i.e. event_x = Event 3, event_y = Event 4) be named Event or Events?  (Answers with authoritative examples from other packages are encouraged)
17:33:36 <lambdabot> Title: K-nopaste
17:33:36 <bbs> ^^^ i keep cleaning this up
17:33:41 <bbs> its my interpreter
17:33:46 <bbs> can someone make anymore suggestions
17:33:50 <mmorrow> , fix ((0:) . scanl (+) 1)
17:33:50 <bbs> i would be very appreciative
17:33:52 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
17:34:14 <monochrom> lunabot is a haskell lunatic?
17:34:24 <mmorrow> , fix (\k m n -> m : k n (m+n)) 0 1
17:34:26 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
17:34:36 <andrewsw> mmorrow: I think it would be hair pulling type of crazy. even ssh would suck at that latency.
17:34:42 <mmorrow> monochrom: from the moon too! :)
17:34:50 <monochrom> The moon?!!
17:34:58 <mmorrow> andrewsw: grrr. you're probably right.
17:35:12 <mmorrow> moonpatio.com:8080
17:35:18 <mmorrow> ;)
17:35:22 <andrewsw> (my joke was that the first crazy of two is implied by being in #haskell)
17:35:32 <monochrom> OK, not satellite internet and the moon...
17:35:37 <andrewsw> and so crazy^2 is not so far away.
17:35:38 <mmorrow> andrewsw: ahh, heh
17:36:05 <p_l> ... I can attest to it that when the ping reaches 3.4 seconds, even telnet makes you want to pull the hair out. Then you get used to not seeing what you write (and you don't have any more hair to pull)
17:36:11 <monochrom> "yeah I got generous help from the Chinese sending my computer to the moon"...
17:36:19 <mmorrow> monochrom: haha, that'd be sweet to have a box on teh moon, but that latency would make you crazy^3
17:36:32 <andrewsw> how many remember out-typing their 300 baud modem?
17:37:11 <p_l> I frequently out-typed my "modern" link
17:37:35 <p_l> minimal latency for GPRS is around 800 ms ;_;
17:38:02 <monochrom> "nasa also offered to bring another computer of mine to the sun, but I don't want to be crazy^500, it's like 8 minutes lag"
17:38:40 <mmorrow> the speed of light is /such/ a pain in the ass
17:38:53 <pastorn> monochrom: make it your lifes mission to alter c
17:39:13 * mmorrow approves
17:39:31 <pastorn> if you could speed up c then you'd shorten the lag :)
17:39:39 <kpreid> I heard there's a project for internet protocols (to use instead of TCP) designed to allow for long lightspeed delays
17:39:57 <mmorrow> heh, 16 minutes just to find out that you puter has been incinerated
17:40:31 <pastorn> kpreid: i've heard about that... seems cool, but the task is daunting
17:40:54 <andrewsw> it plays havoc on the aviary transport as well.
17:42:06 <mdmkolbe> @index unsafePerformIO
17:42:06 <lambdabot> System.IO.Unsafe, Foreign
17:43:51 <pastorn> mdmkolbe: are you going to do nasty stuff?
17:45:15 <mdmkolbe> pastorn: yes, but I've already signed the liability release forms ;-)
17:45:36 <pastorn> http://arcanux.org/lambdacats/unsafeperformio.jpg
17:45:52 <pastorn> mdmkolbe: YOU'RE BEING WATCHED!!
17:45:55 <mmorrow> unsafecoerce.com
17:46:29 * mdmkolbe calls upon the foreign function interface deamon to ward off the ceiling cats
17:46:29 <monochrom> bizzare!
17:46:32 <mofmog1> how would one represent random variables in Haskell
17:46:56 <jeffz> what is a random variable?
17:46:57 <monochrom> with the probability monad. I forgot who wrote the papers.
17:47:04 <mofmog1> i was htinking a monad
17:47:13 <mofmog1> would it really be a monad or just a use of State?
17:47:24 <mofmog1> i dont know if State would be the right one...
17:47:27 <mmorrow> could be either
17:47:51 <mmorrow> newtype RandM a = RandM (IO a)
17:47:59 <mmorrow> or
17:48:07 <mmorrow> newtype ... not with IO ...
17:48:07 <pastorn> mofmog1: you have a module System.Random
17:48:28 <mmorrow> with access to IO you could use mutable vars
17:48:32 <pastorn> @type mkStdGen
17:48:33 <lambdabot> Int -> StdGen
17:48:40 <pastorn> @type newStdGen
17:48:41 <lambdabot> IO StdGen
17:48:44 <pastorn> there it is
17:48:50 <mmorrow> @type randomIO
17:48:51 <lambdabot> forall a. (Random a) => IO a
17:48:53 <mofmog1> Random variable as in E[X] = blahblahl or Var[nAvg] = E[Avg]/n
17:49:10 <mofmog1> Expectation, variance, probability mask
17:49:18 <mmorrow> mofmog1: what would be it's desired operational behavior?
17:49:23 <mdmkolbe> mofmog1: what pastorn posted was actually a gensym generator not a random number generator, but the idea is definiately the same
17:49:46 <mofmog1> i don't need a random number generator
17:50:03 <pastorn> mofmog1: you want to analyze statistics, right?
17:50:08 <mofmog1> yeah iguess
17:50:41 <pastorn> then just write functions as you would normally?
17:51:02 <pastorn> using some scan or fold for doing sums :)
17:51:35 <mofmog1> I wan't to be able to say "expectation x" for example- so I'd have to know the outcomes of the variable and the PMFs
17:51:40 <mofmog1> want
17:51:42 <mdmkolbe> mofmog1: random variables (in the statistics sence) are not values, so you're going to have to play some heavy tricks to get it to work.  There has been some work on respresenting integrations of functions in Haskell so you might have a look at that to see if the ideas can be ported across. (only reference I can think of is Yampa which integrates over continuous signals, but I'm sure there are better ones)
17:51:59 <mofmog1> exactly, that's why i asked
17:52:02 <mdmkolbe> mofmog1: there's probably a paper or two to be written in solving the problem you describe
17:53:09 <mofmog1> i was thinking you'd have to define each variable as an instance of the RandomVariable class- and then you'd have constructors for each outcome and over each outcome you'd have to define PMFs
17:53:40 <mofmog1> then from that, expectation is somehow computed automagically
17:53:42 <mofmog1> *shrug*
17:54:00 <Pseudonym> unsafeDoMagic
17:54:03 <mmorrow> a random variable as you want it probably would be a RandGen, which if you actually want to be random has to be seeded via IO
17:54:11 <mmorrow> yeah, unsafeDoMagic
17:54:22 <mmorrow> unsafePerformIO newRandGen
17:54:38 <mmorrow> or something if you want to not use IO
17:54:48 <mdmkolbe> mmorrow: that would be a random number generator wouldn't it?  that's now that mofmog1 is after
17:55:13 <mmorrow> i still don't understand the desired behavior of a "random variable" here
17:55:15 <mofmog1> how would i go from there to defining X = {1, 2} P(X=1) = .5 P(X=2) = .5 and thus if you did E[X] you get 1.5
17:55:23 <mofmog1> X is a random variable
17:56:05 <mmorrow> oh, you'd probably just work that out the same way you would with a pencil?
17:56:10 <mofmog1> then you should be able to do Var x which would yield E $ square $ (x - E x)
17:56:17 <mdmkolbe> mmorrow: a random variable is a lot like the variable of integration in an integral (except were taking averages and expectations instead of integrals)
17:56:52 <mofmog1> i'd like to be able to define the variable in terms of its outcomes and the probability of eac outcome and thus be able to compute variance and expectation
17:57:49 <mmorrow> mofmog1: what would be a line of haskell using such a thing and assuming it works magically exactly how you envision it?
17:58:03 <mofmog1> for example, let's say you have a predefined random variable
17:58:10 <mofmog1> call it x
17:58:21 <mofmog1> if i did "expectation x" it should spit out for example 4
17:58:35 <mofmog1> if i did "variance x" it should spit out say, 3.5
17:58:37 <mmorrow> how would you define x in haskell though (assuming magic)
17:58:42 <mmorrow> ?
17:58:49 <mofmog1> well that's the difficulty isn't it?
17:58:55 <mmorrow> yes
17:59:06 <BMeph_> Use loeb! :)
17:59:06 <mofmog1> i guess you could define it as a list of outcomes and a list of probabilities of each outcome
17:59:12 <mmorrow> but i think i understand the problem now
17:59:18 <mofmog1> ({0,1,2}, {.4,.6})
17:59:26 <mofmog1> perhaps that could work
17:59:37 <pastorn> make x :: StocVar and then do something quick-checky to evaluate
18:00:00 <mmorrow> [(OutCome a, Prob)]
18:00:33 <pastorn> meaning that you have some function/functions that takes a function with one or many StocVars as input
18:01:04 <mmorrow> the function `frequency' from QuickCheck takes a "distribution" and returns a Gen that sample randomly from it
18:01:09 <pastorn> the way i'd want to use something like that would be > expectedOutCome (f :: StocVar -> Double)
18:01:22 <mmorrow> @type frequency
18:01:23 <lambdabot> forall a. [(Int, Gen a)] -> Gen a
18:01:29 <mofmog1> hmm, no that might not work when you try to define variance in the normal way, using a list that is
18:02:05 <mofmog1> i guess i'd like to define variance like "variance = exp $ square $ x - exp x
18:02:16 <mmorrow> isn't a random variable the same thing as a distribution
18:02:16 <mmorrow> ?
18:02:30 <monochrom> Heh, random variables are not random! or variable!
18:02:44 <mmorrow> nor is a distribution
18:02:56 <monochrom> A random variable is a function from the sample space to a number set.
18:03:15 <mmorrow> yeah, which is what a probability distribution is as well i believe
18:03:45 <pastorn> type StocVar = [Samples] -> [Num a]
18:04:43 <mmorrow> why not just:
18:04:57 <mmorrow> type StocVar = Sample -> Num a
18:05:49 <mofmog1> well isn't it a function from a sample space?
18:05:55 <mofmog1> er
18:06:13 <mofmog1> it's like an integral
18:06:16 <mofmog1> heh
18:06:28 <mmorrow> integrals are maps of functions
18:07:02 <mmorrow> linear maps of vector spaces (where the vectors here are functions)
18:07:12 <heatsink> Do you mean, the integral operator maps functions to functions?
18:07:18 <mmorrow> exactly
18:08:09 <mmorrow> yeah, i mean "the" integral is ...
18:08:14 <pastorn> type StocVar = (Num a, Num a) -> Num a
18:08:32 <pastorn> there, now it spans a space...
18:08:56 <mofmog1> i'm sorry i probably don't know enough math but are you making it span an interval?
18:09:50 <pastorn> now, that is for the actual implementation
18:10:07 <pastorn> (lo,hi) -> whateverthisis
18:11:15 <mofmog1> i'm thinking it should somehow be monadic because you need to say that X+Y is a new r.v.
18:11:26 * bbs sighs
18:11:37 <mofmog1> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
18:11:44 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
18:11:56 <mofmog1> this seems to have already done what i mostly want
18:13:13 <pastorn> mofmog1: do you know the rs and rss are in randomR and randomRS?
18:13:19 <pastorn> what are they short for?
18:13:34 * pastorn studied statistics in swedish...
18:15:54 <pastorn> @type either
18:15:56 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:19:59 <nicky> What is the difference between ** and ^ (meant to be exponentiation)?
18:20:09 <ddarius> :t (**)
18:20:09 <lambdabot> forall a. (Floating a) => a -> a -> a
18:20:11 <ddarius> :t (^)
18:20:12 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
18:20:14 <ddarius> :t (^^)
18:20:15 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
18:20:28 <mmorrow> heatsink: have you looked into/done anything more with http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=341 ?
18:20:48 <mmorrow> that's an interesting strategy
18:21:45 <mmorrow> i guess what i'm wondering is, is that something ghc should be able to do on its own? or is that a special case of a situation that's impossible for ghc to handle in the general case?
18:21:59 <nicky> ddarius: which would I use if I wanted to do 3.12 to the power of 5.10, for instance?  Find that a little complicated
18:22:23 <ddarius> nicky: The only one that would type.
18:22:27 <heatsink> It requires analyzing the constructors of the data type, which is probably something GHC shouldn't do.  It can produce unexpected behavior if you were, say, to add a new constructor.
18:22:53 <heatsink> Unexpected because code suddenly wouldn't type check.
18:22:55 <nicky> ddarius: not sure what you mean
18:23:01 <mmorrow> hmm, that's true
18:23:47 <ddarius> nicky: If you write 3.12 # 5.10 for # = to each of (^), (^^), and (**), only one of them won't give you a type error.
18:24:09 <nicky> ** ?
18:24:29 <ddarius> nicky: Try it and find out.
18:24:36 <ddarius> (If it isn't obvious.)
18:24:48 <heatsink> The evidenceOfEq function works okay for what I'm doing.
18:25:16 <nicky> ddarius: looks like that's the one
18:25:39 * mmorrow adds that to his bag of GADT tricks
18:26:55 <mmorrow> oh whoa, i just noticed thoughpolice's followup paste..
18:26:59 * mmorrow reads
18:27:21 * geezusfreeek builds 6.10.1
18:27:30 <mmorrow> oh oops, that's another thread altogether..
18:28:30 <wy> hello
18:28:38 <heatsink> wy hello thar
18:36:30 <gwern> @hoogle [a] -> [(a,a)]
18:36:30 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
18:36:30 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
18:36:30 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
18:37:06 <gwern> hum
18:37:24 <gwern> any ideas on how to turn [a, b, c, d] into [(a,b), (c,d)]?
18:38:04 <heatsink> @hoogle [a] -> ([a], [a])
18:38:05 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
18:38:05 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
18:38:05 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
18:38:27 <gwern> no no, I want a list of tuples, not a tuple of lists :)
18:38:52 <Pseudonym> > break (const True) [1,2,3,4]
18:38:53 <lambdabot>   ([],[1,2,3,4])
18:39:04 <heatsink> > let {pairs (a:b:xs) = (a,b):xs; pairs [] = []} in pairs [1,2,3,4,5,6]
18:39:06 <lambdabot>       Occurs check: cannot construct the infinite type: t = (t, t)
18:39:06 <lambdabot>        Exp...
18:39:11 <heatsink> > let {pairs (a:b:xs) = (a,b):pairs xs; pairs [] = []} in pairs [1,2,3,4,5,6]
18:39:12 <lambdabot>   [(1,2),(3,4),(5,6)]
18:39:37 <gwern> heatsink: I ask because I have an intuition there's some arrow function which could do it, but I can't think what
18:40:04 <Pseudonym> I don't see how there could be.
18:40:08 <Pseudonym> Not for a general Arrow.
18:48:56 <geezusfreeek> > let pairs = map snd . filter (even . fst) . zip [0..] . (zip <*> tail) in pairs [1,2,3,4,5,6]
18:48:58 <lambdabot>   [(1,2),(3,4),(5,6)]
18:50:18 <mmorrow> > list
18:50:19 <lambdabot>       Overlapping instances for Show
18:50:19 <lambdabot>                                  (t -> (...
18:50:39 <geezusfreeek> :t list
18:50:40 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
18:51:31 <geezusfreeek> @src list
18:51:31 <lambdabot> Source not found. :(
18:51:40 <geezusfreeek> what is list?
18:52:16 <mmorrow> , fix (\k xs -> list [] (\y ys -> list [] (\z zs -> (y,z) : k zs) ys) xs) [0..]
18:52:18 <lunabot>  luna: Not in scope: `list'
18:52:20 <geezusfreeek> defined in irc i guess?
18:52:21 <mmorrow> > fix (\k xs -> list [] (\y ys -> list [] (\z zs -> (y,z) : k zs) ys) xs) [0..]
18:52:22 <lambdabot>   [(0,1),(2,3),(4,5),(6,7),(8,9),(10,11),(12,13),(14,15),(16,17),(18,19),(20,...
18:52:31 <mmorrow> list?
18:52:46 <geezusfreeek> @hoogle list
18:52:46 <lambdabot> module Control.Monad.List
18:52:46 <lambdabot> module Data.List
18:52:46 <lambdabot> package list-extras
18:53:02 <geezusfreeek> i just have never seen that function before
18:53:08 <mmorrow> list nil _    [] = nil ; list _ cons (x:xs) = cons x xs
18:53:18 <mmorrow> yeah, i defined it yesterday
18:53:30 <geezusfreeek> ah, yeah that's what i was asking
18:53:33 <mmorrow> imho it's a glaring omission :)
18:53:39 <mmorrow> as is
18:53:46 <mmorrow> bool false _ False = false ; bool _  true  True = true
18:54:08 <mmorrow> @type (maybe,either)
18:54:09 <lambdabot> forall b a a1 c b1. (b -> (a -> b) -> Maybe a -> b, (a1 -> c) -> (b1 -> c) -> Either a1 b1 -> c)
18:54:20 <Botje> mmorrow: that's just flip flip if' :P
18:54:32 <mmorrow> ok :)
18:54:48 <Botje> but if' isn't standard either, so carry on
18:54:52 <mmorrow> hehe
18:55:24 <geezusfreeek> mmorrow: doesn't list look a lot like a fold to you?
18:55:31 <mmorrow> exactly!
18:55:31 <geezusfreeek> :t foldr
18:55:33 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:55:46 <mmorrow> it's a different fold though
18:55:47 <geezusfreeek> am i missing the point?
18:55:52 <geezusfreeek> :t list
18:55:53 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
18:56:19 <mmorrow> @type maybe
18:56:21 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:56:22 <mmorrow> @type either
18:56:23 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:56:33 <geezusfreeek> :t foldl
18:56:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:56:45 <geezusfreeek> oh, i see
18:57:37 <mmorrow> > fold
18:57:37 <lambdabot>   Not in scope: `fold'
18:58:13 <mmorrow> @let fold cont f s = list (cont s) (\x xs -> f s x xs (\s xs -> fold cont f s xs))
18:58:14 <lambdabot>  Defined.
18:58:23 <mmorrow> foldl f = fold id (\z x xs k -> k (f z x) xs)
18:58:28 <mmorrow> foldr f = fold id (\z x xs k -> f x (k z xs))
18:58:32 <ddarius> It's not a fold.
18:58:44 <mmorrow> mapAccumL f s = fold id (\(s,ys) x xs k -> let (s', y) = f s x in k (s', y:ys) xs) (s,[])
18:59:15 <mmorrow> mapAccumR f s = fold id (\(s,ys) x xs k -> let (s', ys) = k (s,ys) xs ; (s'', y) = f s' x in k (s'', y:ys) []) (s,[])
18:59:22 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=413
18:59:30 <geezusfreeek> it's a hocuspocusmorphism (i don't know the terminology well enough yet)
19:00:23 <mmorrow> Saizan said that "fold" is paramorphism, but i'm currently brushing up on the defs of the various *morphisms
19:00:54 <ddarius> It's a trivial instance of a paramorphism.
19:01:16 <ddarius> You could also write it as a fold, but then you can write paramorphisms as folds too.
19:01:25 <mmorrow> bfs = fold (\(as,fs) -> reverse as : if null fs then [] else bfs fs) (\(as,fs) (Node a xs) ys go -> go (a:as,xs++fs) ys) ([],[]) :: Forest a -> [[a]]
19:01:45 <mmorrow> it's most interesting when the first arg to fold isn't id
19:01:54 <mmorrow> like it is for fold{r,l}, etc
19:02:06 <ddarius> (Um, note that my original comment was referring to 'list')
19:02:49 <mmorrow> ddarius: i figured :), and was just speaking in general
19:03:02 <mmorrow> this one's cool too:
19:03:06 <mmorrow> @type mutual
19:03:07 <lambdabot> forall t2 t1 t3 t. (t2 -> (t1 -> t3) -> t) -> (t1 -> (t2 -> t) -> t3) -> t2 -> t
19:03:10 <mmorrow> ugh
19:03:15 <ddarius> mmorrow: I wasn't very clear about that and hadn't noted the definition of 'fold' which I wasn't referring to at any point.
19:03:18 <mmorrow> mutual :: (a -> (b -> s) -> r) -> (b -> (a -> r) -> s) -> a -> r
19:04:45 <mmorrow> mutual f g a = f a (\b -> mutual g f b)
19:04:49 <mmorrow> then:
19:05:04 <nicky> Which is best:  2.13 ^ 2   or 2.13 ** 2 ?
19:05:07 <mmorrow> unfoldr f = mutual (\a k -> (k . f) a) (\m k -> maybe [] (\(b,a) -> b : k a) m)
19:05:13 <nicky> Both seem to work fine, but I found that the ** was causing an obscure bug
19:05:33 <monochrom> 2.13 ^ 2 is best
19:05:38 <dmwit__> nicky: They're good for different things.
19:05:42 <dmwit__> whoa, two _
19:05:51 <nicky> dmwit__: I'm talking for the specific expression
19:06:11 <dmwit> nicky: It still depends.
19:06:21 <dmwit> 2.13 is not as monomorphic as you might think. =)
19:06:26 <dmwit> (Neither is 2, for that matter.)
19:06:35 <nicky> Hmm, could you elaborate?
19:06:38 <geezusfreeek> :t 2.13
19:06:39 <lambdabot> forall t. (Fractional t) => t
19:07:01 <geezusfreeek> :t (^)
19:07:03 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
19:07:05 <geezusfreeek> :t (**)
19:07:06 <lambdabot> forall a. (Floating a) => a -> a -> a
19:08:40 <mmorrow> i wonder what the conflict in the parser is for a '!' after a '\':
19:08:44 <gwern> mmorrow: so no cool mdos?
19:08:50 <mmorrow> , (\!a -> a) 42
19:08:52 <lunabot>  luna: parse error on input `->'
19:08:53 <mmorrow> , (\ !a -> a) 42
19:08:55 <lunabot>  42
19:09:02 <mmorrow> gwern: heh, not yet
19:16:26 <mmorrow> @src (^)
19:16:26 <lambdabot> x ^ 0            =  1
19:16:26 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
19:16:26 <lambdabot>   where f _ 0 y = y
19:16:26 <lambdabot>         f x n y = g x n
19:16:26 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
19:16:28 <lambdabot>                       | otherwise = f x (n-1) (x*y)
19:16:30 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
19:16:37 <mmorrow> @src (**)
19:16:37 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:16:44 <mmorrow> @src Int (**)
19:16:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:17:16 <mmorrow> , src '(**)
19:17:21 <lunabot>  luna: `(**)' is not in scope at a reify
19:17:24 <mmorrow> hmm
19:17:36 <mmorrow> programmer error
19:18:13 <mmorrow> heh, "Int" for (**)
19:18:22 <mmorrow> @src Double (**)
19:18:23 <lambdabot> Source not found. Where did you learn to type?
19:18:27 <mmorrow> hmm
19:18:39 <mmorrow> @src Floating
19:18:39 <lambdabot> class  (Fractional a) => Floating a  where
19:18:39 <lambdabot>     pi                                                      :: a
19:18:39 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
19:18:39 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
19:18:39 <lambdabot>     (**), logBase                                           :: a -> a -> a
19:18:50 <mmorrow> @src Double Floating
19:18:50 <lambdabot> Source not found. That's something I cannot allow to happen.
19:18:55 <mmorrow> grr
19:41:04 <gwern> > [1] !! 0
19:41:05 <lambdabot>   1
19:49:03 <L3v1> what's the name, eh, hadoc??
19:49:45 <monochrom> haddock
19:49:55 <L3v1> o, thx.
19:51:55 <dmwit> > let infixl 8 !!; (!!) = (Prelude.!!); infixl 9 !; (!) = flip const; canItBeTrue = ["No, it's a lie!!", "It's totally true!!11!1"]; (?!) = (!!11!1) in (canItBeTrue?!)
19:51:57 <lambdabot>   "It's totally true!!11!1"
19:52:36 <dmwit> My favorite part is (?!) = (!!11!1)
19:53:57 <mmorrow> zmomg you can do fixity decls in let
19:54:22 <mmorrow> , let infixl 8 !! in ()
19:54:24 <lunabot>  luna: The fixity declaration for `!!' lacks an accompanying binding
19:54:39 <mmorrow> , let infixl 8 !! ; (!!) = undefined in ()
19:54:41 <lunabot>  ()
19:54:44 <mmorrow> heh
19:55:08 <monochrom> nice
19:55:11 <dmwit> I wouldn't have had to if (!!) didn't have such high precedence.
19:55:21 <mmorrow> , src 'FixityD
19:55:22 <lunabot>  luna: Not in scope: data constructor `FixityD'
19:55:30 <mmorrow> , src 'FixityS
19:55:32 <lunabot>  luna: Not in scope: data constructor `FixityS'
19:55:33 <dmwit> Or if we were allowed arbitrarily high precedence values. ;-)
19:55:34 <mmorrow> oh right
19:55:44 <mmorrow> TH doesn't have fixity decls in its AST
19:57:42 <gwern> hm. is one allowed to call getContents twice?
19:58:12 <gwern> I was thinking of letting the user input two large sections of text, with newlines and stuff, terminated by EOF
19:58:26 <dmwit> Yes, it's allowed, but it will throw an exception.
19:58:27 <gwern> so it'd go 'key <- getContents; text <- getCOntents'
19:58:46 <gwern> what?
19:58:57 <dmwit> where allowed = compile
19:59:44 <gwern> ah. so my strategy is unworkable.
19:59:50 <gwern> unles... I catch te exception!
20:00:09 <dmwit> That won't get you very far. =P
20:00:10 <mmorrow> getContents essentially "half" closes the Handle
20:00:17 <dmwit> You might be able to reopen the handle.
20:00:18 <mmorrow> so it's as good as dead
20:00:29 <dmwit> But I doubt it, as I've never heard of such a thing.
20:01:19 <monochrom> Precedences should be allowed to be general CPOs. We should be allowed to say "this operator's precedence is the limit of the precedences of the following other operators..."
20:01:24 <dmwit> gwern: The standard sort of thing here is to allow two filenames to be passed on the command line, one of which might be '-', in which case you read that one from stdin.
20:01:54 <dmwit> monochrom: My preferred CPO is the reals.
20:02:02 <gwern> dmwit: well, I'm using haskell as pseudo-code for a java program, and I remember opening files as very painful in java
20:02:25 <monochrom> I want epsilon^epsilon.
20:02:46 <gwern> so I was hoping to avoid any file stuff
20:02:48 <mofmog> HOLY SHIT BARACK WON
20:02:52 <mofmog> (sorry for the offtopic)
20:03:01 <dmwit> Hey, I have just the thing!
20:03:06 <dmwit> > let infixl 8 !!; (!!) = (Prelude.!!); infixl 9 !; (!) = flip const; canItBeTrue = ["No, it's a lie!!", "It's totally true!!11!1"]; (?!) = (!!11!1) in (canItBeTrue?!)
20:03:08 <lambdabot>   "It's totally true!!11!1"
20:03:17 <gwern> O RLY
20:03:30 <kilimanjaro> i hope that's a macro or something
20:04:03 <dmwit> kilimanjaro: which thing?
20:04:12 <dmwit> mofmog: Also: really?
20:04:42 <kilimanjaro> dmwit, the haskell code you replied with, it was just a very quick reply
20:04:58 <dmwit> kilimanjaro: Ah, I actually cooked it up a bit earlier, yeah. =)
20:05:08 <monochrom> dmwit: You should make one for "holy shit barack won!!11!1" :)
20:05:42 <dmwit> > let infixl 8 !!; (!!) = (Prelude.!!); infixl 9 !; (!) = flip const; holyShitBarackWon = ["No, it's a lie!!", "It's totally true!!11!1"]; (?!) = (!!11!1) in (holyShitBarackWon!!11!1)
20:05:43 <lambdabot>   "It's totally true!!11!1"
20:05:54 <dmwit> Done and done, good sir!
20:06:07 <dmwit> It must be true, people are rioting in the streets.
20:06:07 <monochrom> Haha
20:06:32 <dmwit> ...AND shooting off their guns.
20:06:36 <dmwit> I love living in a city.
20:06:39 <mmorrow> nothing like a good ol' riot to celebrate
20:07:32 <mmorrow> "whoa mannn, lets go flip some cars... then light em on FIRE!!"
20:07:39 <mmorrow> "great idea!!"
20:07:43 <ivanm> *sigh* yet again, yanks are inflicting their excuse for a political system on the world
20:07:55 <mofmog> I thought all you euros wanted obama
20:08:10 * ivanm is not a Euro, thank you very much
20:08:27 <mofmog> canadian?
20:08:32 <kilimanjaro> australia
20:08:38 <ivanm> kilimanjaro is right
20:08:40 <mofmog> close enough
20:08:46 <dmwit> Canada and Europe: the only two countries that matter.
20:08:48 <ivanm> (well, I'm Australian, not the entire country)
20:08:52 <kilimanjaro> dmwit, haha
20:08:54 <ivanm> dmwit: Europe isn't a country...
20:09:01 <ivanm> mofmog: I beg to differ
20:09:09 <kilimanjaro> ivanm, i think you have a bad sense of humor
20:09:16 <ivanm> AFAICT, we're the only country that weathered the financial crisis the yanks cooked up
20:09:25 <ivanm> kilimanjaro: oh? in what way?
20:09:37 <kilimanjaro> ivanm, dmwit was clearly making a joke
20:09:45 <mofmog> "ed" as if it were past tense
20:09:52 <Pseudonym> Actually, the next interesting race is to see if the Democrats end up filibuster-proof.
20:10:00 <ivanm> mofmog: OK, we're still weathering it
20:10:01 <dmwit> We're good chefs.
20:10:02 <Pseudonym> That will be interesting.
20:10:17 <ivanm> dmwit: what type of cuisine is your speciality then? ;-)
20:10:29 <dmwit> DISASTER
20:10:41 <ivanm> heh
20:10:48 <monochrom> I am a Canadian dollar.
20:10:57 <monochrom> I am a Canadian dollar. You are a Euro.
20:11:01 <dmwit> I am the Queen of France!
20:11:02 * ivanm can't seem to find any cookery books dealing with disaster
20:11:12 <dmwit> ivanm: trade secret
20:11:14 <monochrom> (Halloween costume?)
20:11:22 <ivanm> dmwit: heh
20:11:34 <Pseudonym> I am Spartacus!
20:11:45 <monochrom> I am a monad.
20:11:53 <ivanm> Pseudonym: oh? shouldn't you be dead then?
20:12:14 <monochrom> "Don't cry for me, MonadReader"
20:12:16 <ivanm> monochrom: the Monochromatic Monad?
20:12:17 <ivanm> ;-)
20:12:33 <ivanm> you turn colour images into grayscale?
20:12:34 <mmorrow> teh monochromad
20:12:56 <mmorrow> or monochronad?
20:13:07 <dmwit> monogonad
20:13:15 <dmwit> He lost one in a basketball accident.
20:14:09 <monochrom> "Don't cry for me, MonadReader"
20:14:58 <ivanm> monochrom: yes, you've already sung that line
20:15:07 <ivanm> how's the rest of the song go?
20:16:19 <sclv> "You know I never `ask`ed you"
20:16:34 <dmwit> ivanm: The rest of us have been filling in on the vocals.
20:16:45 <ivanm> ahhh
20:18:41 <sclv> All through transformers / and stacked existentials / I kept my promise / don't make me keep `lifting`
20:23:07 <ikegami__> I watched the release notes for GHC version 6.10.1
20:23:52 <ikegami__> I think it has a problem that the change that GHCi uses editline instead of readline
20:24:03 <ikegami__> because editline does not support UTF-8
20:24:13 <ikegami__> http://www.thrysoee.dk/editline/
20:24:15 <lambdabot> Title: Editline Library (libedit) - Port of NetBSD Command Line Editor Library
20:24:28 <ikegami__> "At the moment libedit does not support UTF-8"
20:25:05 <ikegami__> therefore now ghci in GHC 6.10.1 may not support UTF-8
20:25:28 <bos> ghci will use readline if editline isn't present
20:26:49 <vegai> bos: is that true for 6.10 too? I'm not sure
20:26:58 <bos> yes
20:27:00 <mmorrow> bos: um, i was told explicitly that wasn't the case?
20:27:02 <roconnor> @hoogle comapring
20:27:02 <lambdabot> No results found
20:27:06 <roconnor> @hoogle comparing
20:27:07 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:27:07 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:27:28 <bos> mmorrow: it seems to. maybe my reading of the code is wrong.
20:27:39 <roconnor> @type comparing `on` fst
20:27:40 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
20:27:40 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
20:27:40 <lambdabot>     In the first argument of `on', namely `comparing'
20:27:42 <vegai> bos: super sure? :) When I was building the RCs, there seemed to be no command editing if I didn't have libedit already
20:27:43 <mmorrow> bos: hmm
20:27:50 * mmorrow looks around
20:28:23 <roconnor> @type comparing fst
20:28:24 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
20:29:42 <mmorrow> bos: i was told editline'
20:29:59 <mmorrow> s hard-coded in now since http://moonpatio.com/docs/ghc/src/InteractiveUI.html imports it
20:30:00 <lambdabot> Title: ghci/InteractiveUI.hs
20:30:12 <mmorrow> but i think it should be possible to
20:30:33 <mmorrow> s/import System.Console.Editline.Readline/import System.Console.Readline/
20:30:37 <mmorrow> (maybe)
20:30:57 <mmorrow> i've actually thought about doing that
20:32:49 <mmorrow> speaking of editline, has anyone figured out how to get 'delete' to actually work in ghci?
20:33:10 <mmorrow> (instead of printing a '~')
20:35:14 <jimstutt> morrow: Igloo et al were chatting about this earlier.
20:35:54 <mmorrow> jimstutt: cool, Igloo is who told me that. is he/them thinking of making readline available as an option again?
20:36:03 <mmorrow> (or they were chatting about delete?)
20:38:58 * mmorrow searches for said chatting
20:44:29 <mmorrow> preflex: seen Igloo
20:44:29 <preflex>  Igloo was last seen on #haskell 7 hours, 8 minutes and 46 seconds ago, saying: Cale: If you've filed a bug in trac then I'll see it at some point
21:48:06 <Modius_> Question about GHC - can a GHC built executable embed a compiler and somehow create code at runtime that's available to the rest of the app?
21:48:35 <juhp> bos: yay
21:48:42 <kilimanjaro> Modius_, you might be interested in http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
21:48:45 <lambdabot> Title: Plugging Haskell In
21:49:54 <bos> juhp: :)
21:50:25 <bos> i'm rebuilding 6.10.1 now
21:51:09 <juhp> bos: yes
21:51:25 <Modius_> kilimanjaro:  Without trying to read the whole thing, wrt GHC is this a "yes" or a "no"?
21:51:33 <sbahra> ...
21:52:23 <sbahra> Modius_, yes, all you need to read is the abstract, 1 paragraph.
22:06:18 <Modius_> Thanks, all.  Read a post about the new GHC build, for some reason my mind wandered into musings about a GHC-based equivalent of .Net's "DLR" :)
22:17:08 <mmorrow> http://www1.cs.columbia.edu/~sedwards/apple2fpga/
22:17:09 <lambdabot> Title: Apple2fpga: Reconstructing an Apple II+ on an FPGA
22:17:27 <Japsu> ooooh
22:17:37 <Japsu> YAY!
22:17:42 <Japsu> I have that exact hardware!!!
22:17:43 <Japsu> \o/
22:18:27 <mmorrow> cool
22:18:38 <mmorrow> i was just looking at http://www.altera.com/education/univ/materials/boards/unv-de2-board.html
22:18:43 <lambdabot> Title: DE2 Development and Education Board, http://tinyurl.com/obrxn
22:18:55 <Japsu> yeah, that's a cool board
22:18:55 <mmorrow> oh, did you mean the fpga board or the II+?
22:19:03 <Japsu> the fpga board ;)
22:19:06 <mmorrow> heh
22:19:14 <mmorrow> nice, i was just considering getting one
22:21:00 <juhp> wonder if gtk2hs builds on ghc-6.10.1
22:21:53 <mmorrow> here's a similar one too http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&CategoryNo=39&No=226#order
22:21:57 <mmorrow> hmm
22:22:03 <lambdabot> http://tinyurl.com/5s3klm
22:23:09 <mmorrow> ooh, here's a good picture http://www.terasic.com.tw/attachment/archive/226/image/Layout_800.jpg
22:23:12 <lambdabot> http://tinyurl.com/5tr57q
22:42:56 <mmorrow> preflex: seen adu
22:42:56 <preflex>  adu was last seen on #haskell-blah 1 day, 2 hours, 48 minutes and 13 seconds ago, saying: lispy: another problem is that there is no notation for (x,())
22:46:54 <lispy> no notation for (x,())!
22:47:01 <lispy> but then what is (x,()) if we don't have notation for it
22:47:06 <lispy> how can you tell me about it over irc??
22:47:12 * lispy looks bewildered
22:49:21 <mmorrow> lispy: don't let preflex get into yer head, he's all about the mind games
22:50:14 <mmorrow> it's so loud in here i can barely hear myself think
22:51:14 <mmorrow> lambdabot needs a @predator that spits out classic one-liners from the movie predator
22:51:19 <mmorrow> @nixon
22:51:20 <lambdabot> I'm glad I'm not Brezhnev. Being the Russian leader in the Kremlin. You never know if someone's tape recording what you say.
22:51:27 <mmorrow>  @predator
22:51:34 <mmorrow> I ain't got time to bleed.
22:51:42 <mmorrow>  @predator
22:51:51 <mmorrow> Get to the choppa!!@
22:52:54 <dolio> Dillon! You son of a bitch!
22:52:59 <mmorrow> heh
22:53:11 * mmorrow collects said list
22:53:35 <mmorrow> Son of a bitch is dug in like an Alabama tick.
22:53:58 <mmorrow> You're ghostin' us, motherfucker. I don't care who you are back in the world, you give away our position one more time, I'll bleed ya, real quiet. Leave ya here. Got that?
22:58:58 <mmorrow> If it bleeds, we can kill it.
23:03:57 <Adamant> I can't believe #haskell has een the awesomeness of Predator, but I am glad it did
23:07:37 <mmorrow> done
23:07:38 <mmorrow> http://moonpatio.com/PREDATOR.txt
23:08:11 <mmorrow> if someone know how to add a @predator to lambdabot, do eet!!
23:09:04 <mmorrow> also, that list may have some glaring omissions..
23:09:16 <mmorrow> this made the lol:
23:09:17 <mmorrow> Come on... Come on! Do it! Do it! Come on. Come on! Kill me! I'm here! Kill me! I'm here! Kill me! Come on! Kill me! I'm here! Come on! Do it now! Kill me!
23:09:39 <mmorrow> @nixon
23:09:39 <lambdabot> People react to fear, not love; they don't teach that in Sunday School, but it's true.
23:10:08 * ivanm thinks @bush would be better than @nixon
23:10:20 <ivanm> we've got a whole fortune file full of bush-isms available to us! ;-)
23:10:59 <mmorrow> no way, nixon quotes are cuttingly true and honest.
23:11:22 <mmorrow>  @bush would be something different entirely
23:11:49 <mmorrow> but there's no reason there can't be @nixon /and/ @bush ;)
23:14:42 <lament> @nixon
23:14:42 <lambdabot> If you think the United States has stood still, who built the largest shopping center in the world?
23:16:48 <mmorrow> @nixon
23:16:49 <lambdabot> A man who has never lost himself in a cause bigger than himself has missed one of life's mountaintop experiences. Only in losing himself does he find himself. Only then does he discover all the
23:16:49 <lambdabot> latent strengths he never knew he had and which otherwise would have remained dormant.
23:17:25 <mauke> @noxin
23:17:26 <lambdabot> Maybe you meant: join nixon
23:17:44 <mmorrow> @nixon
23:17:44 <lambdabot> The second point is that coming out--coming back and saying that black Americans aren't as good as black Africans--most of them , basically, are just out of the trees.  Now, let's face it, they are.
23:18:07 <mmorrow> @nixon
23:18:07 <lambdabot> Americans admire a people who can scratch a desert and produce a garden. The Israelis have shown qualities that Americans identify with: guts, patriotism, idealism, a passion for freedom. I have
23:18:08 <lambdabot> seen it. I know. I believe that.
23:18:33 <mmorrow> I'mmmmmm not a croook!
23:19:14 <ivanm> mmorrow: you're not? *phew*
23:19:35 <mmorrow> but what if i'm a liar too??
23:19:46 <ivanm> uh-oh...
23:19:53 <mmorrow> :)
23:19:54 * ivanm hooks mmorrow up to a polygraph
23:19:58 <mauke> liar = not liar
23:19:59 <ivanm> WHAT... is your name?
23:20:05 <mmorrow> nixon
23:20:10 <ivanm> WHAT... is your quest?
23:20:18 <mmorrow> global domination
23:20:25 <ivanm> WHAT... is your favourite colour?
23:20:31 <mmorrow> the color of blood
23:20:32 <mauke> http://banjo.macrochan.org/source/S/F/SFKDOLGW52FRBAINWXM4YBDWTXUBGZ7M.gif
23:20:37 <lambdabot> http://tinyurl.com/5pp5ta
23:20:45 <ivanm> hmmmm..... you pass, you're obviously not a liar! \o/
23:20:46 <ivanm> ;-)
23:20:49 <mmorrow> hah
23:20:55 <mmorrow> woohoo
23:21:21 <mmorrow> mauke: lol
23:21:40 <mauke> RI-CHARD NI-XON
23:21:43 <ivanm> mauke: /me doesn't get it
23:21:48 <ivanm> oh, is that nixon?
