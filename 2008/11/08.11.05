00:23:44 <dreixel> what kind of changes are allowed when uploading a package with the same version number to Hackage?
00:45:14 <jsn_> dreixel: i think that is not possible
00:45:50 <dreixel> jsn_: at all? I had the idea you could change a few fields in the .cabal file
00:47:47 <sjanssen> jsn: it may actually be possible
00:47:57 <jsn> sjanssen: oh?
00:47:59 <sjanssen> it was possible a while ago, but they've talked about changing that
00:48:12 <jsn> sjanssen: i personally think it is evil
00:48:28 <jsn> just increment the number a little bit
00:48:29 <sjanssen> jsn: oh yes, it is
00:48:48 <jsn> i don't want to come back tomorrow and get the "same" package and it is actually different
00:49:00 <jsn> package versions should be write once
00:49:13 <jsn> but please, let us _delete_ or at least deprecate pacakges
01:15:50 <jinjing> @bot
01:15:50 <lambdabot> :)
01:46:35 <nha_> did someone just kill the HOpenGL api ghc docs
01:54:34 <jkr> Hello
01:54:48 <araujo> hi
01:55:04 <jkr> What database library would you recommend for Haskell?
01:55:14 <jkr> Or, which one does work at all? :)
01:55:39 <jkr> I had a look at hackage and tried to install hsql and haskelldb, but both fail because of hidden dependencies or something.
01:55:51 <thoughtpolice> jkr: there is the simple sqlite binding which is pretty straight forward
01:56:05 <araujo> jkr, hsql?
01:56:19 <thoughtpolice> jkr: you may also like 'takusen' but it is /pretty far/ removed from most other database interfaces
01:56:45 <jkr> Isn't there a more generic database interface like Perls DBI with pluggable database drivers?
01:56:59 <jkr> I thought haskelldb was such a thing, but well it doesn't install.
01:57:22 <thoughtpolice> jkr: takusen has some backends to oracle and postgres iirc, not sure what else
01:57:26 <thoughtpolice> tbh I've never used haskelldb itself
01:58:10 <jkr> So there is not THE database library in Haskell, you just choose what you like best at the moment / for a specific task?
01:59:04 <quicksilver> I've not used any of them, but as an innocent spectator it seems that there not yet "THE" library.
01:59:10 <thoughtpolice> yeah
01:59:12 <quicksilver> you don't seem to have mentioned HDBC yet.
01:59:16 <quicksilver> that has a following.
01:59:18 <hesselink> jkr: HDBC says it's modelled on Perl DBI
01:59:19 <thoughtpolice> i haven't seen any 'killer db interfaces'
02:01:03 <thoughtpolice> jkr: personally though I like the takusen approach a lot; it statically ensures resources are freed properly and predictably *at compile time* (so you don't leak closed handles to the DB, for example.)
02:01:11 <jkr> HDBC depends on haskelldb, which fails to install. :(
02:02:01 <jkr> haskelldb wants old-time (for System.Time), which is "hidden", whatever that means
02:02:04 <thoughtpolice> the approach it takes to do that is nice and reapplicable. currently supports Oracle, pgsql, sqlite and odbc
02:02:43 <jkr> thoughtpolice: Can I exchange database drivers transparently with Takusen?
02:02:58 <thoughtpolice> jkr: not sure, i haven't fiddled with it *too* much
02:03:37 <wjt> r
02:04:52 <hesselink> jkr: I see no dependency in HDBC on HaskellDB
02:05:07 <hesselink> I just did "cabal install HDBC" on ghc 6.8 and it worked
02:06:07 <jkr> Oh
02:06:20 <jkr> Sorry, I did cabal install haskelldb-hdb :)
02:06:22 <jkr> +c
02:06:31 <hesselink> heh
02:06:32 <jkr> Didn't see a HDBC library on hackage
02:06:51 <jkr> Ah right, now i see it ;)
02:07:15 <jkr> Ok, thanks so far, I think I'll have a look at HDBC and Takusen and then decide
02:07:19 <jkr> See you later
02:36:33 <Baughn> @undo do put 5; a <- get; return a
02:36:33 <lambdabot> put 5 >> get >>= \ a -> return a
02:38:32 <FlightOfStairs> hello
02:39:07 <FlightOfStairs> i'm learning haskell at uni - have a little trouble with a function I'm writing
02:39:09 <FlightOfStairs> http://pastebin.com/d4347062e
02:39:44 <FlightOfStairs> i get 'Occurs check: cannot construct the infinite type: x = [x] When generalising the type(s) for `insertions''
02:39:44 <TSC> I think the example in the comment is wrong
02:39:52 <FlightOfStairs> oh?
02:40:00 <TSC> The second one should be acb, right?
02:40:11 <FlightOfStairs> oh
02:40:13 <FlightOfStairs> yea
02:40:23 <FlightOfStairs> typo probably
02:40:31 <FlightOfStairs> any idea where i'm going wrong?
02:40:45 <TSC> On first glance it looks like the right approach
02:41:13 <Axman6> heh, i love my girlfriend, she left a code in my birthday card: [40,73,76,79,86,69,89,79,85,41]
02:41:20 <rwbarton> Your recursive step has the form [a] : b, you mean either a : b or [a] ++ b
02:41:23 <Axman6> it wasn't a list, but still
02:41:57 <Hunner> HB Axman6
02:42:07 <Axman6> thanks :)
02:42:09 <FlightOfStairs> oh
02:42:11 <FlightOfStairs> got it
02:42:18 <FlightOfStairs> i'd tried ++ before
02:42:25 <FlightOfStairs> but must have made some other change since then
02:42:30 <FlightOfStairs> thanks for the help :)
02:42:36 <ziman> Axman6, nice! :)
02:42:56 <TSC> I'd fix it by changing the brackets around c:x:xs instead of ++
02:43:01 <Axman6> :)
02:43:43 <Baughn> @src State
02:43:43 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:43:46 <FlightOfStairs> insertions c (x : xs) = [c : x : xs] ++ map (x :) (insertions c xs) - that's it sorted
02:43:49 <Baughn> @type runState
02:43:50 <lambdabot> forall s a. State s a -> s -> (a, s)
02:45:23 <Axman6> hmm, somehow i think the explanations of State would have been more clear to me if i'd known about record syntax before hand
02:48:04 <Baughn> Hm. I never realized before trying to implement it that get and put are practically the same thing
02:49:20 <PeakerWork> Baughn: Isn't it: get = \s -> (s,s)  and put = \x _ -> (x, ()) ?
02:49:20 <lambdabot> PeakerWork: You have 1 new message. '/msg lambdabot @messages' to read it.
02:50:02 <Baughn> PeakerWork: I've got it as put x = S (const ((),x)), but I suppose that's the same thing
02:50:14 <Baughn> PeakerWork: The idea isn't to look it up,though. It's to reinvent it. ;)
02:50:34 <PeakerWork> Baughn: I didn't look it up, I reinvented it just now ;-)
02:50:42 <PeakerWork> Baughn: Well, I did look it up back when I was learning what monads were...
02:51:09 <Baughn> Yeah. Now I'm learning how to implement them, which requires a peculiar twist of though
02:51:12 <Baughn> *thought
02:51:30 <Baughn> ..though it's pretty easy when you realize that a State is a function from the start state to the end state and return value
02:51:41 <quicksilver> right.
02:51:53 <quicksilver> "State" is just a combinator library for building functions.
02:51:58 <Baughn> First I spent twenty minutes trying to do "data State = State
02:52:03 <Baughn> First I spent twenty minutes trying to do "data State a = State a". :P
02:52:17 <Baughn> With "| Putter a | Getter" thrown in for insane measure
02:53:14 <PeakerWork> Baughn: I'm explaining everything that I learn to some of my friends, forcing me to re-think it and fully understand it...
02:53:32 <Baughn> PeakerWork: I noticed. :P
02:53:54 <PeakerWork> Yesterday I tried implementing Phooey over quicksilver's Reactive thing, but it just confused me.. :)
02:54:19 <quicksilver> I thought Phooey was arrow based instead of Reactive based?
02:54:24 * quicksilver is ignorant though.
02:54:26 <PeakerWork> quicksilver: nope, its also conal's
02:54:31 <PeakerWork> quicksilver: based on Reactive
02:54:35 <PeakerWork> quicksilver: and its pretty awesome, IMO :-)
02:54:40 <PeakerWork> http://www.haskell.org/haskellwiki/Phooey
02:54:42 <lambdabot> Title: Phooey - HaskellWiki
02:55:43 <Axman6> PeakerWork: have you gon through http://blog.tmorris.net/20-intermediate-haskell-exercises/ ? (not sure if that's below your level or not)
02:55:45 <lambdabot> Title: λ Tony’s blog λ » Blog Archive » 20 Intermediate Haskell Exercises
02:56:44 <Axman6> gone*
02:57:38 <PeakerWork> Axman6: I think I have, I'm pretty comfortable with Monad/Applicative/Functor and most of their instances, as well as Monad transformers. I think I can implement most of them (Except ContT maybe, but I am not sure why it is useful, besides being neat :-)
02:58:22 <PeakerWork> Axman6: With the Phooey thing, I tried creating something more general than conal's that can put different front-ends on the same UI
02:58:50 <Axman6> right... well you're out of my league, so good luck with that :P
02:59:30 <PeakerWork> Is ContT actually used?  Its great to be able to say "Our language can implement continuations in a library", but other than that? :)
02:59:54 <Deewiant> I use it for early returning from an IO-heavy function once in a while
03:01:23 <PeakerWork> Deewiant: but you can just place the continuation in a separate function and call/not-call that?
03:01:32 <rwbarton> I have some code that uses it in a very complicated way, and is almost certainly not correct.
03:01:46 <PeakerWork> someone here called it the goto's of FP
03:02:48 <Deewiant> PeakerWork: I'm sure I could if I actually understood how continuations worked ;-) callCC seemed simplest and it works
03:03:14 <PeakerWork> Deewiant: by continuation I just meant the rest of your function that you want to skip...
03:03:47 <Deewiant> PeakerWork: when there's more than one such point it's a bit painful
03:04:13 <mr_H> good morning
03:10:38 <Axman6> can i have a type constructor as the last line in a do construct? like do {l <- inst x items; r <- inst y items; Node i l r}?
03:11:23 <Deewiant> > do { x <- Just 1; Just x }
03:11:25 <lambdabot>   Just 1
03:11:58 <Axman6> i'm trying to use STM to create a tree with unique elements, so i need to check if the elements are in it already
03:12:49 <rwbarton> It looks like you mean  return $ Node i l r
03:13:35 <Deewiant> unless the type of Node i l r is a monad
03:14:05 <Axman6> well i tried to make it a monad, but i couldn't figure it out.
03:14:25 <Axman6> instance Monad (Tree a) where return x = Node x Leaf Leaf (>>=) = flip mapT
03:14:46 <Axman6> there are new lines, and indents after each definition
03:15:50 <quicksilver> this is not relevant
03:16:07 <quicksilver> whether they are a monad or not you don't want them as the last line in your do block
03:16:14 <quicksilver> because that do block is supposed to be of the STM monad
03:16:19 <quicksilver> (or at least, that's what you said)
03:16:20 <quicksilver> not Tree.
03:16:56 <Axman6> can i show you the code? might help clear things up
03:17:22 <mr_H> hello
03:17:59 <mr_H> im passing this function to parse the results of a curl, is it possible to pass it a "identity" function ?
03:18:02 <mr_H> is there such a function ?
03:18:42 <Axman6> http://hpaste.org/11746#a1
03:21:19 <BONUS> mr_H: id
03:21:20 <BONUS> ?
03:21:23 <BONUS> > id 4
03:21:24 <lambdabot>   4
03:23:10 <Lemmih> Axman6: You need more return's.
03:23:27 <Axman6> Lemmih: i probably do, but i need to get the monad instance working first :)
03:24:16 <Axman6> @src Maybe (>>=)
03:24:16 <lambdabot> (Just x) >>= k      = k x
03:24:16 <lambdabot> Nothing  >>= _      = Nothing
03:24:30 <BeelsebobWork> when is a strictness annotation "unexpected"?
03:24:50 <Lemmih> Axman6: Shouldn't bind be 'flip concatMapT'?
03:24:52 <ski> Axman6 : try defining `join' for your monad
03:25:14 <Axman6> i really only need return :(
03:25:27 <Axman6> ghci doesn't like the line: instance Monad (Tree a) where
03:25:28 <ski> then define `(>>=)' in terms of it and your `mapT' .. (or define it directly, with a similar pattern as `join')
03:27:47 <Lemmih> Axman6: Use 'instance Monad Tree' instead.
03:28:01 <Axman6> yeah, i did, that works better
03:30:36 <Axman6> should x >>= return == id?
03:31:04 <BONUS> (>>= return) = id
03:31:16 <Axman6> ok, good
03:31:25 <PeakerWork> x >>= return  ===  x
03:31:25 <Axman6> well my definition holds for that
03:33:30 <quicksilver> Axman6: any "container" type should be a monad as long as you can think of a consistent way of flattening nesting
03:33:40 <quicksilver> (which is a nother way of saying "as long as you can write join")
03:34:15 <Axman6> rawr, this isn't going to work how i had hoped :(
03:34:20 <pozic> (Monad m) => m a -> m a /= a -> a, so definitely not ===, but when m is the identity monad, then yes.
03:36:11 <mr_H> is there any haskell module to generate excell files ?
03:36:55 <ski> Axman6 : how are you defining `mapT'
03:37:19 <Axman6> it's not important, i have the monad instance defined now, and it doesn't use mapT
03:37:25 <ski> (more specifically, what is its type ? .. i was assuming `forall a b. (a -> b) -> (Tree a -> Tree b)', but now i'm not sure)
03:37:28 <PeakerWork> there seem to be a bunch of Haskell CSV parsers, but no generators..   It could be nice if parsers/builders were two sides of the same coin, in all these frameworks
03:37:31 <Axman6> my problem is with mkTree now
03:37:44 <quicksilver> PeakerWork: it would indeed be nice. something I think about form time to time.
03:37:51 <quicksilver> PeakerWork: not trivial to get it right.
03:38:15 <PeakerWork> quicksilver: pickler combinators seem to be hard, yeah.. I've written some in Python, but am not sure how to write on in Haskell
03:38:21 <PeakerWork> s/on/one
03:38:35 <ski> Axman6 : so you have provided a working definition of `(>>=)' ?
03:38:40 <Axman6> yeah
03:39:01 <Axman6> (Node x l r) >>= f = let Node x' _ _ = f x in Node x' (l >>= f) (r >>= f); Leaf >>= _ = Leaf
03:41:10 <ski> i don't think that's correct
03:41:11 <quicksilver> that doesn't look right
03:41:28 <quicksilver> > [] >>= (\x -> [1,2,x,4,5])
03:41:46 <lambdabot>   []
03:41:48 <ski> it should just be a structural copy, in the `Node' caswe
03:41:53 <ski> s/w//
03:42:02 <Axman6> huh?
03:42:26 <Axman6> probably needs a case in there, right...
03:42:49 <ski> hmm
03:43:06 <Axman6>     (Node x l r) >>= f = case f x of
03:43:06 <Axman6>                         Leaf -> Leaf
03:43:07 <Axman6>                         Node x' _ _ -> Node x' (l >>= f) (r >>= f)
03:43:10 <Axman6> better?
03:43:11 <ski> actually, i'm not sure one can write a `join' for this tree typw
03:43:15 <ski> s/w/e/
03:43:20 <Ferdirand> is this a monad ? or a functor ?
03:43:40 <Axman6> it's a tree, and that's all i care about -_-
03:43:54 <ski> Axman6 : no, that's still throwing away things
03:44:45 <Ferdirand> i fail to understand how a monad makes sense for a tree that store values in the intermediate nodes
03:44:52 <mmorrow> suppose you forkProcess an IO (), the subsequently signalProcess sigKILL it. is there any way to get rid of the zombie that creates?
03:44:57 <ski> Ferdirand : yes
03:44:59 <Ferdirand> if you have labels on the leaves only, sure, but...
03:45:06 <mmorrow> 27458 pts/1    00:00:06 ghc <defunct>
03:46:16 <PeakerWork> mmorrow: I think the parent process has to waitpid on it.  Alternatively, you can double-fork so that init becomes its parent, and init waitpids on all its children periodically
03:46:47 <PeakerWork> mmorrow: (double-forking and then having the intermediate child die immediately and the parent immediately wait on it)
03:46:55 <pozic> Did anyone successfully build gtk2hs with --enable-profiling including all the bindings?
03:47:11 <mmorrow> PeakerWork: cool. i'll give that a go.
03:47:25 <ski> Axman6 : also, since `condInsert' gives an `IO'-action, you should have `mkTree' give an `IO'-action too (or at least some monad that builds on top of `IO') .. maybe this is your problem ?
03:47:32 <pozic> In particular the gnomevfs bindings are broken.
03:48:04 <ski> Axman6 : iow, maybe you want to wrap the `Node ...' result in `mkTree' in `return'
03:48:24 <Axman6> ski: maybe, but what type would it be, IO?
03:48:33 <ski> `it' being ?
03:48:51 <Axman6> the return type of the function i guess
03:48:57 <Axman6> hmm, i have an idea
03:49:24 <ski> yes if you call an `IO'-action, you need to have `IO' somewhere in the result type
03:50:01 <ski> (so probably, in your case, trying `instance Monad Tree' was a red herring)
03:50:50 <Axman6> yeah
03:52:06 <ketil> Data.Binary: how can I easiest read an array of Int16s?
03:52:27 <Axman6> ketil: 'read' how?
03:52:37 <BeelsebobWork> Is it possible to profile code that uses the FFI?
03:52:47 <ketil> Axman6, uh, I mean "get".
03:52:48 <Axman6> hmm, wait, never used Data.Binary. never mind me
03:52:54 <BeelsebobWork> I get a link error with -lHSffi_p
03:53:27 <quicksilver> BeelsebobWork: that sounds odd. I would have expected that to be possible. I've never tried it though.
03:53:42 <Lemmih> Beelsebob: Using ghc-6.10.1?
03:54:05 <Axman6> ok, this is what i have now: http://hpaste.org/11748
03:54:08 <Lemmih> ketil: get :: Get [Int16] ?
03:54:10 <BeelsebobWork> 6.11.head from a couple of days back Lemmih
03:54:14 <BeelsebobWork> so something close to 6.10.1
03:56:12 <Axman6> @src IO (>>=)
03:56:13 <lambdabot> m >>= k     = bindIO m k
03:57:01 <ketil> Lemmih, but I have a known number of them.
03:57:16 <Lemmih> ketil: replicateM n get :: Get [Int16] ?
03:57:16 <MyCatVerbs>  /away lecture
03:57:26 <MyCatVerbs> Whoops, sorry.
03:57:28 <ketil> Lemmih, yes of course.  Sigh.  Thanks.
03:57:40 <BeelsebobWork> Lemmih: do I need to do something special while building ghc to get the profiling library?
03:58:53 <Lemmih> BeelsebobWork: I think you need to go bug Igloo. It sounds like an issue with the new libffi code.
03:59:02 <BeelsebobWork> hmm, okay
04:03:05 <Axman6> could someone check out http://hpaste.org/11748 and perhaps give some more pointers as to what's wrong with it?
04:03:42 <Axman6> what's wrong with mkTree*
04:03:46 <Lemmih> Axman6: 'return Leaf' in the first definition of 'mkTree'.
04:04:02 <Axman6> doesn't work when i don't have the either :\
04:04:20 <Axman6> Couldn't match expected type `Tree t'
04:04:20 <Axman6>            against inferred type `IO Bool'
04:04:20 <Axman6>     In a stmt of a 'do' expression: l <- condInsert f' items
04:05:37 <pozic> Axman6: condInsert returns an IO action, the Leaf returned in equation one returns a Tree.
04:06:00 <pozic> Axman6: adding return to Leaf should fix something, I think.
04:06:26 <Lemmih> Axman6: It compiles fine for me.
04:06:27 <Axman6> left <- if l then mkTree f g f' (n-1) items else return Leaf -- yes?
04:06:40 <pozic> Axman6: replace Leaf with return Leaf.
04:07:03 <Axman6> so... return return Leaf? :S
04:08:01 <Lemmih> Axman6: Are you looking at the first line of mkTree?
04:08:07 <pozic> Axman6: do you understand why it's wrong?
04:08:14 <Axman6> no, i don't
04:08:34 <pozic> Axman6: A Leaf is a Tree, but it is not a computation that returns a Tree.
04:08:37 <Axman6> it seems fine to me.
04:08:58 <pozic> Axman6: in the second equation you describe a computation that returns a Tree.
04:09:09 <pozic> Axman6: In Haskell the types need to match.
04:09:11 <Axman6> r <- condInsert g' items?
04:09:32 <pozic> Axman6: they don't, so the compiler complains.
04:09:47 <Axman6> how don't they, i have no idea which part of the code you're talking about
04:09:56 <pozic> Axman6: mkTree _ _ _ 0 _ = Leaf
04:10:10 <Axman6> oh! ha, thankyou. sorry
04:10:12 <pozic> Axman6: that is a Tree, not an m Tree.
04:10:24 * Axman6 hugs pozic 
04:10:33 <Axman6> i'd just assumed that was fine
04:10:44 <pozic> Axman6: the error messages are mostly good, imho, that is, if you can read them.
04:11:19 <pozic> It's the same with "inferred type" vs "expected type". Most newbies confuse those.
04:11:36 <thoughtpolice> i've generally found the error messages ghc emits to be readable
04:11:54 <pozic> thoughtpolice: yes, me too.
04:12:02 <thoughtpolice> normally if I can't understand exactly what it's saying, i can look at where its err'ing and determine something from the types and fix from there
04:13:19 <pozic> Do minor releases have compatible .hi files?
04:13:38 <yitz> thoughtpolice: I find ghc error messages readable now, but I remember them seeming to be written in Ancient Martian when I first started.
04:14:44 <mmorrow> PeakerWork: ahh, i just found out how to collect the dead with System.Posix.Process. i just have to
04:14:45 <mmorrow> getProcessStatus True True pid
04:15:02 <mmorrow> to remove the
04:15:03 <mmorrow> 28728 pts/1    00:00:05 ghc <defunct>
04:16:04 <dmwit> Bring outcher deaaaad!  *BONG*
04:16:53 <PeakerWork> mmorrow: yeah, but you have to do it asynchronously after it dies.. Double-forking lets you do it immediately on the immediate child and not worry about the grand-child
04:17:02 <PeakerWork> mmorrow: (or synchronously wait for it to die)
04:18:34 <mmorrow> PeakerWork: the only think with that is, i need to be able to explicitly kill the grandchild from the main thread since it may never terminate and i want to time-it-out, and if i kill the child then i have no way of knowing the grandchild's pid
04:19:07 <PeakerWork> mmorrow: the child can return it, but if you have a time-out anyhow, then you probably don't mind having to async-wait for it
04:19:24 <mmorrow> yeah, i think i'm gonna try the async-wait
04:19:40 <mmorrow> but i'm not sure how to have the child return it
04:19:50 <mmorrow> ooh, maybe with its ExitCode
04:20:11 <PeakerWork> unix sucks ;)
04:20:16 <mmorrow> heh
04:20:30 <mmorrow> i don't even want to imagine having to do this on windows...
04:20:58 <mmorrow> the renegade process would probably just crash the entire os
04:21:32 <mmorrow> (i'm trying to make a sandbox for dynamically compiled then evaled haskell code)
04:22:18 <dmwit> The child could send you back a message in a couple of ways, I guess.
04:22:24 <dmwit> Something like DBUS is one option.
04:22:31 <dmwit> Shared memory is another.
04:22:31 <mmorrow> yeah, but i don't want to to any IPC or some such
04:22:48 <mmorrow> hmm, maybe shared memory
04:23:05 <mmorrow> (i'll have to learn how that works first though..)
04:23:06 <dmwit> I'm not sure what Haskell's interface to shared memory looks like, though.
04:23:12 <mmorrow> how lightweight is shm?
04:23:27 <dmwit> In C, it's about as lightweight as malloc.
04:23:37 <mmorrow> sweet. FFI wrapper here i come
04:23:49 <dmwit> Look for it in the libs first, it might be there. =)
04:23:59 <mmorrow> hmm, i don't think i've seen it
04:24:09 <mmorrow> i spoke too soon
04:24:15 <mmorrow> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-SharedMem.html
04:24:17 <lambdabot> Title: System.Posix.SharedMem, http://tinyurl.com/6ctt8f
04:24:45 <mmorrow> perfect
04:27:11 <Axman6> is there any easy way to make this run bot branched in parallel? http://hpaste.org/11748#a1
04:27:57 <Axman6> both branches*
04:29:38 <xenoblitz> guys i have a bug in the code @ http://hpaste.org/11749 ... any idea what could be wrong?
04:30:12 <Lemmih> Axman6: Try using newMVar, forkIO and takeMVar.
04:30:22 <quicksilver> xenoblitz: wheres scope over all guards.
04:30:33 <quicksilver> xenoblitz: so you just need that where clause once, after the secon dguard.
04:30:53 <quicksilver> (but it doesn't work cos its different each time
04:30:58 <quicksilver> you'll have to do it a different way)
04:31:20 <xenoblitz> quicksilver: thanks... using lets maybe?
04:31:21 <yitz> quicksilver: I think you need some wd40 for your space key today.
04:32:05 <quicksilver> yitz: probaly more a question of needing caffeine for my finger-controlling-neurons
04:32:08 <quicksilver> but you could be right.
04:32:16 <Lemmih> Axman6: Why are you using a TVar, btw? You're not taking advantage of its transactional guarantees.
04:32:18 <dmwit> xenoblitz: Or you could just name them something more descriptive than xs1/xs2.
04:32:28 <yitz> they have wd40 with caffeine?
04:32:28 <Axman6> Lemmih: i'm not?
04:33:01 <dmwit> xenoblitz: Even better would be to write a function that calls countGatesRecurr twice, then pass it a different starting list in the two guards.
04:33:12 <dmwit> (DRY)
04:33:27 <Axman6> and i don't get how forkIO would help, since i can't seem to get anything back from it unless it use another (few hundred) T?MVars
04:33:30 <vixey> xenoblitz: yeah what dmwit said, naming of everything could be better
04:33:31 <Axman6> /*
04:33:50 <vixey> xenoblitz: for example, I don't have a clue what this function does.. but with better names it would probably be really clear
04:34:12 <xenoblitz> dmwit, vixey: thanks for your suggestions, but its the convention my lecturer uses... so... bear with me plz
04:34:12 <Lemmih> Axman6: Nope. Things can be inserted into the set between 'atomRead' and 'appToVar'.
04:34:34 <vixey> xenoblitz: You don't have to follow his conventions
04:35:14 <Axman6> Lemmih: how would i change that, to begin with?
04:35:45 <pozic> Text/Printf/Mauke.hs:16:7:
04:35:45 <pozic>     Could not find module `Data.Default':
04:35:45 <pozic>       Perhaps you haven't installed the profiling libraries for package data-default-0.2?
04:36:24 <Lemmih> Axman6: condInsert el var = atomically $ do s <- readTVar var; if member s then return False else writeTVar var (insert s el) >> return True
04:36:41 <pozic> Why does this happen? I have in my cabal config that it should build profiling libraries for all packages.
04:36:44 <xenoblitz> ok but ... how can I solve the problem?
04:36:52 <Lemmih> Axman6: The 'readTVar' and 'writeTVar' must be in the same STM block.
04:37:14 <dmwit> xenoblitz: I've suggested two ways already.  Unless you've posed a different problem in the minute or so that I was offline.
04:37:39 <vixey> xenoblitz: start by giving everything better names
04:37:46 <Axman6> Lemmih: so atomRead won't do the same thing, even though it's the same code?
04:38:06 <xenoblitz> dmwit, vixey: thanks
04:38:41 <Lemmih> Axman6: 'atomRead' and 'appToVar' are atomic but 'condInsert' is not.
04:38:44 <timbod> Hi - I'm using cabal-install 0.6.0 ... will it build haddock docs for me?
04:38:54 <Axman6> ok, fair enough
04:39:39 <ketil> I now get a stack overflow with my Data.Binary parsing code.  Any good way to debug this from within ghci?  (I don't have an executable yet, just library code)
04:39:45 <pozic> 'bytestring-lexing-0.2' is cached.
04:39:45 <pozic> Configuring bytestring-lexing-0.2...
04:39:45 <pozic> Preprocessing library bytestring-lexing-0.2...
04:39:45 <pozic> alex.bin: /usr/local/lib/alex-2.0.1/AlexWrapper-strict-bytestring: openFile: does not exist (No such file or directory)
04:39:57 <yitz> xenoblitz: composeGates w w' = countGates w . countGates w'
04:40:11 <yitz> *Recurr
04:40:11 <pozic> Why does everything break so soon?
04:41:01 <yitz> oh, xenoblitz is gone. got insulted I think.
04:42:09 <pozic> Right, the log even says the build failed: http://hackage.haskell.org/packages/archive/bytestring-lexing/0.2/logs/failure/ghc-6.8
04:42:10 <lambdabot> http://tinyurl.com/5v5xk6
04:42:21 <pozic> Why can one even download the package if it doesn't build?
04:43:02 <ivanm> pozic: just because it failed there doesn't mean it will fail everywhere
04:43:20 <ivanm> quite often, it's due to the environment: lack of a local tool installed (for FFI stuff), etc.
04:43:25 <pozic> ivanm: that property should hold, otherwise the package system is broken.
04:43:33 <ivanm> pozic: no
04:43:41 <pozic> ivanm: cabal was meant to encode dependencies.
04:43:41 <ivanm> it only holds if the sole dependencies are those in hackage
04:44:08 <ivanm> pozic: cabal can't encode a dependency on zlib-the-program, which zlib-the-haskell-library depends on
04:44:14 <ivanm> that's a system-wide problem
04:44:26 <ivanm> hence why *nix distros have custom installers for packages
04:44:58 <ivanm> pozic: also, atm it's not possible to depend on gtk2hs in cabal, because gtk2hs isn't cabalised (well, you can't do so using cabal-install say)
04:45:42 <pozic> ivanm: so, what's the solution to these concrete problems I have?
04:45:55 <ivanm> which concrete problems?
04:45:58 * ivanm came in late :s
04:46:13 <pozic> ivanm: I want printf-mauke-0.3 with debugging libraries.
04:46:36 <ivanm> and it won't build for you?
04:46:41 <pozic> ivanm: and I want  bytestring-lexing-0.2 with debugging libraries.
04:46:46 <pozic> ivanm: no, they don't.
04:47:05 <Lemmih> Email the maintainer?
04:47:10 <Saizan> profiling you mean?
04:47:17 <ivanm> pozic: this is the other problem with cabal/hackage: you state that your lib foo depends on bar > x.y ... but when bar gets upgraded to x.z, then foo no longer builds from it
04:47:37 <ivanm> it's a bit hard to encode that dependency AFAIK when you don't know what future releases of bar might do
04:47:45 <pozic> Perhaps you haven't installed the profiling libraries for package data-default-0.2?
04:47:54 <ivanm> and hackage is a _static_ archive: you can't go fix mistakes in old versions
04:48:12 <ivanm> pozic: ummm.... you're the one wanting to do so, so why ask us? ;-)
04:48:27 <pozic> Saizan: yes
04:49:03 <PeakerWork> Easiest way to hex-dump a buffer?
04:49:26 <Lemmih> PeakerWork: Pipe to hexdump?
04:49:52 <ketil> There is nothing inherently strict about replicateM or forM, right?
04:50:06 <dmwit> ?src replicateM
04:50:07 <lambdabot> replicateM n x = sequence (replicate n x)
04:50:11 <dmwit> (no)
04:50:13 <quicksilver> ketil: nope.
04:50:15 <Lemmih> pozic: cabal install --reinstall -p data-default?
04:50:31 <quicksilver> but it is a property of sequence that it carries out all the side effects before returning the list
04:50:34 <vixey> I can't think of any monad that replicateM isn't strick in ...
04:50:37 <quicksilver> in a rather loose sense of "before"
04:50:49 <therp> what does it mean for package if they are in (curly) brackets in the output of ghc-pkg list? hidden?
04:50:51 <quicksilver> this is not strictness
04:50:57 <Lemmih> vixey: Get.
04:50:58 <quicksilver> although its related, of course.
04:51:00 <dmwit> vixey: You can get elements of a replicateM-generated list lazily.
04:51:01 <pozic> Lemmih: unrecognized option `--reinstall'
04:51:06 <quicksilver> it's more like "side-effect-strict"
04:51:10 <Lemmih> pozic: cabal install cabal-install.
04:51:20 <dmwit> > replicateM 300 [1..]
04:51:21 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:51:23 <ivanm> therp: dependency issues IIRC
04:51:29 <ivanm> or else hidden...
04:51:33 <ivanm> compare with ghc-pkg check
04:52:06 <ketil> This is the Get monad.  I'm reading a data structure, basically  data Foo = Foo Header [Data]
04:52:18 <Saizan> pozic: you may need to refresh the index with "cabal update" too
04:52:21 <ketil> if the list of Data is too long, I get a stack overflow.
04:52:53 <PeakerWork> Lemmih: surely encoding to a hex string shouldn't require being in IO :)
04:53:18 <dmwit> ketil: You might want to consider forcing intermediate parts of the list as you go.
04:53:42 <dmwit> ketil: The times I've gotten stack overflows were when I had deeply-nested thunks.
04:53:56 <pozic> cabal: Error: some packages failed to install:
04:53:57 <pozic> cabal-install-0.6.0 depends on network-2.1.0.0 which failed to install.
04:53:57 <pozic> HTTP-3001.0.4 depends on network-2.1.0.0 which failed to install.
04:53:57 <pozic> network-2.1.0.0 failed during the building phase. The exception was:
04:53:57 <pozic> exit: ExitFailure 1
04:54:00 <ketil> dmwit, not sure I see how.
04:54:06 <vixey> does cabal install put stuff on hackage?
04:54:11 <vixey> I mean download off hackage
04:54:49 <dmwit> ketil: I'm not certain what I'm describing can be done simply with replicateM.  It will probably make sense to write your own version of it.
04:54:53 <ivanm> vixey: yes
04:54:57 <ivanm> and it puts stuff on hackage as well
04:55:04 <ivanm> cabal-install == hackage? :p
04:55:12 <ketil> What's puzzling to me is that I can't force the Header either.  It's at the start of the input, and I should be able to extract it without even touching the [Data] part.  Or so I thought.
04:55:22 <pozic> Hmm, it's again because the profiling libraries of the deps aren't build.
04:58:20 <yitz> ketil: have tried something like data Foo = Foo !Header [Data] ?
04:58:36 <ketil> yitz, no.  But I can.
04:59:07 <Lemmih> PeakerWork: There's also Numeric.showHex.
04:59:15 <ketil> No difference.
04:59:31 <PeakerWork> Lemmih: thanks!
04:59:32 <yitz> ketil: I think that's the kind of thing that dmwit has in mind.
04:59:47 <Saizan> so, the Binary instance for lists uses replicateM n get, where n is the length of the string
05:00:18 <ketil> It SOs even if I don't return the [Data] (replace with undefined).  I need to also comment out the 'get'ting of it.
05:00:37 <Saizan> heh
05:00:52 <Saizan> it seems the Get monad is not sufficiently lazy for your purpouses
05:01:11 <Saizan> (not sure if it could be)
05:03:30 <ketil> Saizan, surely it is possible to read an almost infinte list?
05:04:27 <Saizan> it's hard to write an almost infinite list since it writes down the length first
05:05:08 <Saizan> you may roll your own serializing functions instead of using the Binary instance
05:05:20 <Saizan> still using the Get and Put monads
05:05:56 <Snark> hi
05:06:04 <ketil> Oh, wait.  Is it because it needs to count in order to report a possible error?!
05:06:14 <Snark> is there a haskell equivalent of gettext ?
05:06:51 <Saizan> ketil: no, it doesn't check for errors
05:07:09 <ketil> I did a quick test: instance Binary Foo where get = do { x <- replicateM almost_infinity get; return Foo x } -- and that breaks, too.
05:07:22 <ketil> This sucks - how can I fix it?
05:07:39 <vixey> I think replicateM is the problem
05:07:46 <vixey> it's too non-non-strict.
05:08:01 <pozic> What do I need to get bytestring-lexing to build?
05:09:03 <Lemmih> pozic: What version of ghc do you have?
05:09:44 <Lemmih> pozic: Hm, the package seems to be broken. Go poke dons.
05:09:52 <vixey> ketil, you could try unrolling the replicateM loop
05:10:03 <yitz> Snark: hmm, interesting. in a quick browse through hackage I didn't find anything.
05:10:12 <vixey> get = getN almostInfinity where getN = ...
05:10:14 <pozic> Lemmih: 6.8.2-7 from Debian.
05:10:44 <Lemmih> pozic: You need alex-2.3.
05:10:51 <vixey> that way you don't have this huge list of 'get' around, but you'll still have huge things flying around
05:10:56 <Lemmih> pozic: Alex can be installed with 'cabal install alex'.
05:11:15 <yitz> Snark: could be because each of the GUI libraries provides a binding to its own gettext, and that's where you would normally need it.
05:11:16 <vixey> (so expect it to still break on large enough inputs)
05:11:21 <pozic> Lemmih: oh, that's nice.
05:13:24 <Saizan> ?src replicateM
05:13:24 <lambdabot> replicateM n x = sequence (replicate n x)
05:13:36 <Axman6> @src sequence
05:13:36 <lambdabot> sequence []     = return []
05:13:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:13:36 <lambdabot> --OR
05:13:36 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
05:14:11 <Axman6> oh, heh, i remember trying to write that
05:14:35 <pozic> Lemmih: so the package is only missing a dependency on alex.
05:14:43 <Saizan> ketil: btw, are you compiling with -O2 ?
05:14:45 <pozic> Lemmih: (because it works now)
05:14:50 <Lemmih> pozic: It seems so. Go poke dons.
05:15:50 <thoughtpolice> you can't specify a dependency on executables with cabal yet
05:16:03 <Lemmih> thoughtpolice: Sure you can. (:
05:17:15 <Lemmih> thoughtpolice: You can as along as the executables are cabalized, me thinks.
05:17:28 <SamB_XP_> Lemmih: how so ?
05:18:06 <thoughtpolice> Lemmih: well build-depends just checks the ghc-pkg info for what's needed, cabal doesn't check its own data to see if it's necessary afaik
05:18:41 <thoughtpolice> (and ghc-pkg doesn't keep track of executables)
05:19:17 <Lemmih> Hm, I guess they're still working on that, then.
05:19:38 <Lemmih> I was fairly certain cabal-install could doit.
05:19:49 <Saizan> there's a build-tools fields iirc
05:19:59 <Saizan> not sure what it does though
05:23:10 <yitz> ketil: just a reminder, before you blame the Data.Binary stuff, did you make sure that you didn't use foldl somewhere by mistake, or some such?
05:24:04 <Lemmih> Hm, cabal-install can find the versions of the local build tools and it can install new tools from hackage. But for some reason it can't do it automatically.
05:24:15 <tchakkazulu> Say, is the delete key in GHCi broken for anyone else?
05:24:53 <Axman6> i heard dons mentioning something about that the other day tchakkazulu
05:24:54 <tchakkazulu> (running 6.10.1 on Fedora 8)
05:25:09 <Axman6> i was surprised to learn dons even used the delete key... ever :o
05:25:35 <tchakkazulu> Hmm, okay.
05:25:52 * tchakkazulu gets used to using backspace for a while.
05:26:36 <Saizan> it also prints the escapes on screen, and this seems to break emacs haskell-mode
05:26:50 <luite> same problem here on ubuntu, with a 6.10 snapshot from last week, but even my backspace and arrow keys don't work
05:27:18 * yitz got used to it on the MacBook, where delete requires holding down the fn key
05:27:35 <vegai> you're missing libedit, probabyl
05:28:31 <Axman6> when was 6.10.1 released?
05:28:47 <Axman6> because, it may be yet another nice birthday present for me
05:28:49 <luite> hm, I do have libedit, but I might have forgotten to install the development package
05:28:52 <tchakkazulu> Yesterday, as far as I know.
05:29:27 <Axman6> 4th apparently
05:31:26 <tchakkazulu> Ditto for PgUp and PgDn. And Insert. Home and End work correctly.
05:32:02 <tchakkazulu> Devel package, good call.
05:32:18 <tchakkazulu> Though I think you only need it when compiling GHC from source.
05:33:55 <luite> I did, but I have to recompile the final version anyway
05:34:18 <Saizan> non-ascii letters seem broken too
05:35:20 <luite> when will it be possible to cabal install ghc? :)
05:36:00 <jimstutt> pacman -Q libedit-devel
05:36:03 <ivanm> luite: probably never
05:36:08 <jimstutt> oops
05:36:25 <ivanm> since how then do you install ghc on a system without cabal?
05:36:34 <luite> I mean to upgrade
05:36:35 <ivanm> also, it still has perl and C code in it, and thus requires gcc
05:36:45 <ivanm> cabal can't call gcc AFAIK
05:36:57 <Lemmih> ivanm: c-sources?
05:37:39 <ivanm> Lemmih: then again, what do I know :p
05:37:59 <tchakkazulu> Non-ASCII symbols even go wrong when they're defined in a file, and then tabcompleted :-/
05:38:25 <tchakkazulu> Well, they show up as their escaped character, but then trying to use functions with them results in "lexical error (UTF-8 decoding error)"
05:39:01 <askdksdl> object-orientation is how people really think. what do you say to that?
05:40:21 <Lemmih> askdksdl: Poor people. Let's get them some help.
05:41:07 <askdksdl> map brain_update poor_people
05:42:11 <luite> you need mapM if the brain update may have side effects ;)
05:51:16 <vixey> there is someth interesting stuff about curry-howard and so on http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8784
05:54:13 <RayNbow> vixey: that link isn't working
05:54:45 <vixey> oh that's a shame
05:54:59 <vixey> it is the right link and it was working a moment ago
05:55:16 <RayNbow> vixey: what's the title of the paper?
05:55:25 <vixey> citeseer will hopefully un-break soon
06:01:58 <mmorrow> PeakerWork, dmwit: here's the sandbox so far: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=445#a445
06:02:42 <mmorrow> it works nicely, although i have no way to talk to the forked proc as of yet
06:03:30 <mmorrow> i'm not 100% sure if all those block/unblock calls are arranged in the best way...
06:10:24 <ketil> Saizan: (sorry bout the delay, just came back) - no, this is in the interpreter.  I don't have an executable just yet.
06:10:45 <ketil> yitz: yes, I'm sure - the toy example is like four lines of code :-)
06:13:49 <ketil> Saizan, I compiled the .hs file with -c, and reloaded it into the interpreter.  It still blows the stack, but much faster now :-)
06:14:09 <Saizan> that's something :)
06:20:39 <earthy> oh... just now noticed I got a new GHC release for my birthday
06:20:44 <earthy> 'yaay'! :)
06:26:09 <Snark> hmmm... Either isn't a monad :-/
06:27:18 <Saizan> Snark: "Either e" is, there's an instance defined in Control.Monad.Error
06:27:27 <Saizan> even if it requires e to be an instance of Error
06:27:59 <RayNbow> vixey: the CiteSeer link is working again :)
06:27:59 <Snark> Saizan, ah, that's probably what I'm missing
06:28:31 <Snark> file:///usr/share/doc/ghc6-doc/libraries/index.html doesn't show Control.Monad.Error :-(
06:28:57 <mdmkolbe> Is there a recomended or prefered order for clauses in a .cabal file?
06:29:52 <Snark> http://haskell.org/ghc/docs/latest/html/libraries/ has Control.Monad.Error !
06:29:57 <lambdabot> Title: Haskell Hierarchical Libraries
06:30:11 <earthy> snark: but it isn't in base 4
06:30:27 <earthy> it is in package mtl
06:30:35 <earthy> and you might not have that installed.
06:30:40 <p_l> ... okay, what is the recommended way to make cabal-install work with proxy?
06:33:12 <Saizan> ketil: how big is your almost_infinity? and what are the elements of the list? i'm trying with (replicateM 10000000 (get :: Get Int)) and it seems to work in constant space
06:33:38 <Snark> earthy, what?
06:34:32 <earthy> snark: ghc-pkg list
06:34:40 <earthy> then see if mtl is one of the packages shown
06:35:04 <ulkot> can i do a statement that changes the value of somehting?
06:35:16 <ulkot> like : let a = [1..10]
06:35:19 <earthy> ulkot: no
06:35:26 <ulkot> then mapM (^2) a
06:35:27 <earthy> ulkot: however, you can maintain state
06:35:27 <ketil> Saizan: List is 120389 elements
06:35:30 <ulkot> and a changes?
06:35:44 <earthy> ulkot: impossible
06:35:44 <ketil> Saizan, (see my message to -cafe)
06:35:56 <Saizan> ketil: 'k
06:36:36 <Snark> earthy, I didn't know about that command...
06:36:54 <earthy> now you do. :)
06:36:57 <ulkot> @src mapM
06:36:57 <lambdabot> mapM f as = sequence (map f as)
06:37:18 <earthy> > let a = [1..10] in mapM (^2) a
06:37:19 <lambdabot>       No instance for (Show (m [b]))
06:37:19 <lambdabot>        arising from a use of `show' at <...
06:37:45 <Snark> earthy, and what is this "mtl" package you mentioned ?
06:37:45 <earthy> > let a = [1..10] in map (^2) a
06:37:46 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
06:37:59 <earthy> snark: the mtl package is the package containing Control.Monad.Error
06:38:27 <earthy> if you don't see it listed in the output of ghc-pkg list  your ghc doesn't have that package installed, and therefore no Control.Monad.Error
06:38:52 <earthy> (mtl is short for Monad Template Library)
06:39:01 <Snark> ah, I installed another -doc package, and now I have what I need
06:39:56 <ulkot> can someone give an example of sequence-use?
06:41:49 <earthy> > mapM (\x -> if even x then Nothing else Just x) [1..10]
06:41:52 <lambdabot>   Nothing
06:42:06 <earthy> > mapM (\x -> if even x then Nothing else Just x) . filter (\x -> not even x) $ [1..10]
06:42:06 <benkant> yo
06:42:07 <lambdabot>   Couldn't match expected type `Bool'
06:42:15 <benkant> i heard this is a good channel to be in
06:42:18 <earthy> > mapM (\x -> if even x then Nothing else Just x) . filter (\x -> not . even $  x) $ [1..10]
06:42:19 <lambdabot>   Just [1,3,5,7,9]
06:42:23 <benkant> know what i'm sayin?
06:42:27 <earthy> ulkot: this helps?
06:42:37 <ulkot> earthy: yes, thanks
06:47:28 <dmwit> ulkot: re: can I have a variable that changes?
06:47:47 <dmwit> ulkot: The answer is no, but you can have a variable that has a pointer in it, and you can change what is behind the pointer.
06:48:00 <dmwit> ulkot: But it is strongly recommended that you try to learn how to program without these.
06:48:35 <dmwit> ulkot: When the time comes that this is required, it will be for some reason like having to interface with some external library or so.
06:48:47 <dmwit> s/will be/will likely be/
06:49:07 <Saizan> ketil: the culprit is probably decodeFile
06:49:24 <ketil> Saizan, mf?
06:50:02 <ketil> Saizan ('mf' as in 'huh', only while drinking coffee.)
06:50:10 <ketil> @src decodeFile
06:50:11 <lambdabot> Source not found. Where did you learn to type?
06:50:13 <Saizan> http://hackage.haskell.org/packages/archive/binary/0.4.3.1/doc/html/src/Data-Binary.html#decodeFile
06:50:19 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6pefdq
06:51:05 <ketil> Ah, the isEmpty thing, right?
06:51:13 <lilac> ulkot: there are certain algorithms which are hard to implement without the illusion of mutable state. for those, the ST monad is helpful. but it's recommended to try to find an algorithm with no mutable state first
06:51:39 <Saizan> ketil: yeah
06:52:28 <ulkot> lilac: the illusion of mutable state? so you claim that the world does not have state but that ist just something we image to simplify things?
06:53:07 <Saizan> ketil: i get the space leak too with decodeFile, but not with decode
06:53:41 <ketil> Saizan, man you're an angel!
06:54:02 <ketil> It works: lenght rds => 120389
06:54:05 <ketil> whee
06:54:21 * ketil jumps and dances, spilling coffee all over his laptop.
06:55:01 <ketil> The -- ahem -- interesting part here is that isEmpty would have failed anyway - there's some junk at the end of the file which I don't decode.
06:55:03 <ketil> :-)
06:55:38 <Saizan> heh :)
06:56:46 <rog> what rules is an instance of Eq required to follow? is it required that, for instance (x == y && y == z)  implies (x == z) ?
06:56:53 <Saizan> it should be clearer in the docs maybe, even if it's there in the last line
06:57:24 <Saizan> rog: it's supposed to be an equivalence relation, yes
06:57:32 <rog> (i'm wondering about creating an enum type with a wildcard...)
06:58:06 <quicksilver> rog: it should be observable equivalence.
06:58:34 <rog> is that requirement documented somewhere? or is it just supposed to be obviously implicit?
06:58:41 <quicksilver> rog: if "x == y" then for all expressible functions or actions f, "f x" should be observably equivalent to "f y"
06:58:57 <quicksilver> I think this requirement is merely quicksilver's opinion, to be honest.
06:59:12 <quicksilver> you can decide if that's worth anything to you.
06:59:52 <rog> it means a great deal to me :-)
07:00:08 <rog> ... but i'd still prefer something in the documentation!
07:00:33 <quicksilver> it only matters insofar as you use other functions which expect an Eq argument
07:00:36 <quicksilver> there aren't many of those
07:00:44 <quicksilver> but you might write some of your own.
07:00:52 * Saizan thought it was specified in the report, but apparently not
07:00:53 <quicksilver> I have some generic caching functions I wrote which use Eq.
07:01:33 <rog> thanks for the input.
07:02:01 <quicksilver> :t elem
07:02:04 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:02:10 <quicksilver> rog: that's an example of an Eq function.
07:02:15 <quicksilver> you might use the behaviour of that as a guide.
07:02:29 <quicksilver> If you had a list of things, what would you want "elem" to do, with your data type?
07:02:52 <BeelsebobWork> will turning on --enable-library-profiling also turn on -auto-all for the profiling compile?
07:02:54 <Saizan> or group
07:03:37 <rog> quicksilver: that one's easy, as it doesn't require (x == y && y == z) ==> (x == z)
07:03:38 <Saizan> BeelsebobWork: i don't think so but you can check with -v
07:04:35 <quicksilver> rog: well, I disagree
07:04:39 <quicksilver> rog: that influences it.
07:04:57 <quicksilver> rog: what do you want elem x [... a list containing y ..] to do?
07:05:12 <quicksilver> similarly elem x [...a list containing z...]
07:05:16 <quicksilver> and do you feel that's inconsistent
07:05:36 <quicksilver> (my feeling is this would be strange behaviour if your instance isn't transitive)
07:06:19 <rog> thinking about it, i think i'd just be better using an explicit match operator.
07:06:31 <BeelsebobWork> Saizan: hmm, it isn't -- I don't see any way in the configure options to specify extra arguments for ghc -- do you know if it's possible?
07:07:21 <rog> that way the asymmetricality is obvious.
07:07:29 <Saizan> BeelsebobWork: --PROG-option/--PROG-options should work for any PROG cabal calls
07:09:08 <rog> (and it's easier to define, too)
07:14:15 <vixey> RayNBow ah good
07:17:49 <cnwdup> What do I have to do to post to the haskell-cafe mailing list?
07:18:35 <quicksilver> subscribe to it.
07:18:39 <Saizan> http://www.haskell.org/haskellwiki/Mailing_lists
07:18:40 <lambdabot> Title: Mailing lists - HaskellWiki
07:18:44 <quicksilver> then send an email to haskell-cafe@haskell.org
07:19:02 <cnwdup> quicksilver: I did that. *g* Currently reading through the wiki again.
07:19:22 <camio> I noticed that ghc 6.10.1 changed containers to use Maybe instead of arbitrary monads for things like Data.Map.lookup. Does anyone know why?
07:19:58 <camio> cnwdup: Did you click the link to "activate" the account?
07:20:34 <cnwdup> camio: I am receiving mails from others writing to haskell-cafe. It that's an indication. I think I did activate the account.
07:20:38 <pozic> camio: according to the libraries protocol, there should have been a discussion about that on the libraries mailing list.
07:20:47 <BMeph> camio: Because the function works in a way that is all-but isomorphic to the Maybe type, and had no "extra" functionality by making the type signature more vague... err "general." :)
07:20:53 <dmwit> cnwdup: Is your From: header the same as the address you signed up on?
07:21:07 <dmwit> cnwdup: Some smtp servers rewrite your headers For Your Convenience (e.g. gmail).
07:21:33 <luite> I'm trying to buld 6.10.1 (using 6.8.2), but it stops with this error: haddock: Could not find module `Distribution.Package':   Use -v to see a list of the files searched for.  make[2]: *** [doc.stage.2] Error 1
07:21:38 <luite> what's wrong?
07:21:53 <camio> BMeph: Thanks for the explination.
07:22:04 <quicksilver> @quote initial
07:22:10 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
07:22:14 <cnwdup> dmwit: I've sent the mail to haskell-cafe@haskell.org. Do I have to add certain things to the email or the subject line? Like the [Haskell-cafe] prefix or something?
07:22:28 <quicksilver> camio: the above quote, which was in the discussion, was what decided it for me.
07:22:30 <dmwit> cnwdup: No.
07:22:41 <Badger> tsk tsk, dons. Your list is broken. :P
07:22:44 <dmwit> cnwdup: But you do have to send the email from an address that is subscribed to the list.
07:22:59 <dmwit> cnwdup: I'm just trying to suggest that doing that is no as easy as you might thing it is.
07:23:14 <EvilRanter> quicksilver, the idea being that any element of the initial doodad would be liftable to an arbitrary doodad?
07:23:15 <dmwit> s/no /not /;s/thing/think/
07:23:22 <dmwit> EvilRanter: right
07:23:23 <camio> quicksilver: I don't understand it exactly. What does it mean by initial?
07:23:33 <cnwdup> dmwit: Unfortunately I don't have the email with the activation link anymore.
07:23:34 <dmwit> EvilRanter: Basically, that's the meaning of initial.
07:23:37 <EvilTerran> camio, "simplest possible"
07:23:44 <EvilTerran> pretty much
07:23:44 <rog> where is quotRem documented? i've found only the signature in the standard prelude, but no explanation....
07:24:00 <dmwit> rog: It's (quot &&& rem).
07:24:14 <camio> Ah, so the idea is someone else could write a :: Monad m => Maybe a -> m a. Got it.
07:24:15 <dmwit> So look at the docs for quot and rem, respectively, I guess?
07:24:27 <rog> dmwit: but quot and rem both seem to be defined in terms of quotRem!
07:24:30 <EvilTerran> camio, unfortunately, owing to the presence of "fail", yes
07:24:37 <dmwit> camio: Surely that would have to be (MonadPlus m) => to be sensical.
07:24:49 <dmwit> rog: Oh, heh. =P
07:25:02 <dmwit> rog: The docs talk about them that way, too?
07:25:05 <dmwit> ?docs quot
07:25:06 <lambdabot> quot not available
07:25:26 <EvilTerran> camio, another example would be returning [a] instead of (MonadPlus m => m a)
07:25:55 <dmwit> > (-3) `quotRem` 4 -- rog
07:25:55 <rog> is the difference between quotRem and divMod just in the behaviour w.r.t. negative numbers?
07:25:57 <lambdabot>   (0,-3)
07:26:00 <EvilTerran> ?type msum . map return -- lift from initial to arbitrary
07:26:01 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
07:26:03 <dmwit> > (-3) `divMod` 4
07:26:05 <lambdabot>   (-1,1)
07:26:08 <EvilTerran> rog, yes
07:26:13 <dmwit> rog: yes
07:26:20 <camio> cool
07:26:50 * Badger wonders what kind of bot lambda is
07:26:57 <EvilTerran> ?version
07:26:57 <lambdabot> lambdabot 4.2.1
07:26:57 <lambdabot> darcs get http://code.haskell.org/lambdabot
07:27:03 * rog wishes that it was actually *documented* somewhere
07:27:07 <Badger> oic
07:27:09 <Badger> thankyou
07:27:16 <EvilTerran> rog, have you checked the report?
07:27:37 <rog> EvilTerran: yes. well, at least google and the function index aren't any help.
07:27:41 <saml> > ghcVersion
07:27:42 <lambdabot>   Not in scope: `ghcVersion'
07:27:57 <rog> EvilTerran: (but i haven't scanned the whole thing manually)
07:28:05 <md22> hello everyone
07:28:09 <EvilTerran> http://haskell.org/onlinereport/basic.html#numbers
07:28:10 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
07:28:12 <saml> hi md22
07:28:23 <md22> what type of apps is haskell used to make
07:28:33 <EvilTerran> more specifically, http://haskell.org/onlinereport/basic.html#arithmetic-operators
07:28:34 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
07:28:36 <saml> md22: serious games
07:28:53 <EvilTerran> "`quot` is integer division truncated toward zero, while the result of `div` is truncated toward negative infinity. The quotRem class method takes a dividend and a divisor as arguments and returns a (quotient, remainder) pair; divMod is defined similarly"
07:28:53 <pozic> Imho, it would have been better if they changed part of the type from Monad to MonadPLus.
07:28:57 <rog> EvilTerran: ah. thanks. it'd be helpful if the function index pointed towards that!
07:29:03 <saml> md22: http://www.haskell.org/haskellwiki/Applications_and_libraries
07:29:05 <lambdabot> Title: Applications and libraries - HaskellWiki
07:29:26 <md22> thanks saml
07:30:09 <saml> @YES WE CAN
07:30:09 <lambdabot> Unknown command, try @list
07:30:23 <Badger> <_<
07:30:28 <cnwdup> dmwit: haskell-cafe-request@haskell.org sent me the confirmation link, but it's also telling me to send emails to haskell-cafe@haskell.org. But my messages are objected. Any suggestions?
07:30:42 <dmwit> cnwdup: *blink*
07:30:59 <dmwit> cnwdup: I'm talking about the email address *you* send mail from, not the email address Haskell-cafe sends mail from.
07:31:21 <cnwdup> dmwit: Now I get it. Thanks. :-D
07:32:53 <bbs> hey how can i simplify this line
07:32:55 <bbs> beval (BOp "and" bexp1 bexp2) state  dec = if(beval bexp1 state dec ) then ( if(beval bexp2 state dec ) then True else False ) else False
07:33:48 <Saizan> ?type (&&)
07:34:14 <Saizan> @bot
07:34:36 <Saizan> bbs: you can use (&&) which is the haskell and operator
07:34:43 <vixey> bbs, I guess you don't want any suggestions from me
07:35:31 <lambdabot> Bool -> Bool -> Bool
07:35:32 <lambdabot> :)
07:35:47 <bbs> vixey: why wouldn't I?
07:35:58 <camio> bbs: What's the dec thing?
07:36:08 <bbs> handles declarations
07:36:13 <bbs> its a lookup
07:37:01 <camio> I would do a 'where ev a = beval a state dec' to remove some of the redundancy.
07:38:01 <camio> Then it could be '= (ev bexp1) && (ev bexp2)'
07:38:17 <mc__> how can I cast an Int into a Float?
07:38:33 <dmwit> :t fromIntegral
07:38:35 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:39:02 <mc__> thank you
07:43:00 <tero-_> hm. there's no sign of OpenGL api in ghc's latest standard library documentation page
07:43:10 <tero-_> has it been removed from the latest version?
07:43:28 <bbs> camio: you used and
07:43:39 <bbs> how do the ifs thens and elses handle that in haskel
07:44:02 <quicksilver> tero-_: which packe?
07:44:04 <quicksilver> page?
07:44:10 <camio> In my expression above, it took out the if then elses entirely.
07:44:14 <tero-_> quicksilver: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
07:44:14 <lambdabot> Title: Haskell Hierarchical Libraries
07:44:17 <tero-_> I used to find it there
07:44:59 <quicksilver> tero-_: hmm. I don't know what the significance of it not being there is.
07:45:03 <quicksilver> interesting point.
07:45:12 <jeffersonheard> almost got this...  does there exist a castToGLDrawingArea anwhere, and relatedly, can you use Glade with Graphics.UI.Gtk.OpenGL.GLDrawingArea ?
07:45:20 <bbs> does :
07:45:22 <bbs> beval (BOp "or" bexp1 bexp2) state dec = if(ev bexp1) && (ev bexpr2) then True else false where ev a = beval a state dec
07:45:28 <bbs> that work for
07:45:34 <bbs> beval (BOp "or" bexp1 bexp2) state dec = if(beval bexp1 state dec) then True else ( if(beval bexp2 state dec) then True else False )
07:45:35 <tero-_> quicksilver: ..that is, it should be there, right?
07:45:49 <vixey> bbs, if you use:  (BOp (Functional Op (||)) bexp1 bexp2) ...
07:45:50 <quicksilver> tero-_: looks like the way that page is now built it only includes the core libs
07:46:00 <vixey> bbs, oops (BOp (Functional Or** (||)) bexp1 bexp2) ...
07:46:03 <quicksilver> tero-_: there is quite a lot missing relative to the old version of that page.
07:46:19 <quicksilver> hmm.
07:46:20 <tero-_> quicksilver: okay, I see. gotta keep looking
07:46:22 <quicksilver> but parse is there.
07:46:25 <quicksilver> parsec.
07:46:26 <vixey> bbs, then you can write   beval (BOp (Functional _ (*~*)) bexp1 bexp2) = beval bexp1 *~* beval bexp2
07:46:27 <quicksilver> I don' tunderstand.
07:46:35 <vixey> bbs, the _ means it covers every case
07:47:08 <bbs> (BOp (Functional Or** (||)) bexp1 bexp2)
07:47:13 <bbs> that doesn't exists in my AS
07:47:18 <bbs> and i honestly don't know how to make it
07:47:32 <vixey> bbs, I showed you how to make it yesterday, using   data Functional = ...
07:47:50 <jeffersonheard> tero_: there was some discussion of this.  It will not be part of the core GHC, but make up an ancillary library package, whose name I've forgotten
07:47:53 <jeffersonheard> it's still available
07:48:12 <jeffersonheard> discussion was on the maling list, and everyone's been assured OpenGL support will not be slowing nor going away
07:48:36 <Deewiant> yes, OpenGL is still available on hackage, just not distributed with GHC
07:48:54 <quicksilver> jeffersonheard: but parsec is also not part of core GHC
07:48:59 <tero-_> jeffersonheard: okay. that's reassuring
07:49:03 <bbs> vixey: it just didn't work for me
07:49:03 <quicksilver> jeffersonheard: so this is arbitrary and inconsistent
07:49:08 <bbs> i'm too new to haskell right now
07:49:08 <quicksilver> (and different from what it was before)
07:49:14 <tero-_> jeffersonheard: do you happen to know about the fate of the documentation?
07:49:30 <Deewiant> quicksilver: rather, it was arbitrary before and now they're trying to bring it down to a minimal set, AIUI
07:49:34 <vixey> bbs, no you aren't too new. If something isn't working you can always fix it
07:49:54 <vixey> bbs, you are also welcome to ask questions here about stuff like that if you get stuck
07:50:31 <jeffersonheard> tero_ : http://www.haskell.org/haskellwiki/Opengl
07:50:32 <lambdabot> Title: OpenGL - HaskellWiki
07:51:04 <camio> bbs, try using hpaste.org to post your code. It may allow us to help you better perhaps.
07:51:09 <tero-_> "the API docs for the OpenGL binding" still points to the ghc's library documentation
07:51:55 <bbs> vixey: you said : data Functional = Functional RelationalTag (Integer -> INteger -> Bool)
07:51:56 <jeffersonheard> in the HOpenGL mailing list and I think eventually Haskell Cafe, this message: Fw: patch applied (ghc): Remove the OpenGL family of libraries fromextralibs
07:51:58 <jeffersonheard> explains everything
07:52:12 <bbs> data Functional = Functional RelationalTag (IR -> IR -> Bool)
07:52:21 <bbs> should be an IR so it can store Ints and Reals
07:52:27 <bbs> and then
07:52:30 <bbs> RelationalTag
07:52:37 <bbs> how does *~* know it
07:53:03 <bbs> vixey: ^
07:53:14 <vixey> bbs, if you have to support Integer and Boolean and so on depending on the constructor, thats where a GADT makes this trivial
07:54:55 <bbs> vixey: so you are saying i have to make the different cases in that file
07:55:20 <vixey> bbs, There's two things I suggest which are independent
07:55:35 <vixey> bbs, first is that using strings there is a terrible idea and you should change the AST so that it doesn't
07:55:48 <vixey> bbs, the second is that you can cover every single case in one go
07:55:58 <luite> how can I prevent the docs from being built, when compiling ghc 6.10.1? for some reason it gives an error when building the documentation and then stops
07:56:27 <camio> bbs: What's your purpose in writing this program? To learn more about haskell? For a project?
07:57:54 <bbs> camio: yea a project
07:57:59 <bbs> but now i'm just cleaning it up
07:58:02 <bbs> i had it working
07:58:09 <bbs> but i knew it was a shotty dob
07:58:11 <bbs> job
07:58:12 <mc__> May someone please explain that type error to me? I just dont get it. http://haskell.pastebin.com/m160a0baa
07:59:24 <bbs> vixey: ok i'll try to work on it
07:59:26 <dmwit_> mc__: You're applying the value (filter (not . sieveHelper x) (x:xs)) to the function call (sieve xs).
07:59:29 <bbs> i'm not sure if i still get what you mean :)
07:59:37 <dmwit_> mc__: (Actually not quite, but the problem is the same.)
08:00:03 <mc__> I see, so I just need to add parensß
08:00:09 <dmwit_> No.
08:00:10 <vixey> bbs, I'm not very good at explaining this but if you try out some things and see what happens you will probably converge toward something good
08:00:18 <dmwit_> mc__: What you have written will not work.
08:00:35 <mc__> What is wrong with it?
08:01:27 <mc__> oh, sorry nvm
08:01:27 <mc__> I think I got it now
08:01:27 <mc__> I forgot for a moment that values are immutable :)
08:01:55 <dmwit__> mc__: You have two values on the right-hand side: (filter ...) and (sieve xs).  How do you want to combine them?  Answer that question, and you will have the answer to how to make it work.
08:02:13 <vixey> mc__, Is this for finding prime numbers?
08:02:33 <mc__> vixey: yes
08:03:14 <mc__> dmwit__:  I think i already got it           | x < length xs = sieve (filter (not . sieveHelper x) (x:xs))
08:03:33 <dmwit> That looks better.
08:03:40 <mc__> it compiles, though there is till something wrong with the algorithm, but that does not belong here I think :)
08:03:43 <dmwit> I don't know if it's right, but it has a chance of type-checking. =)
08:05:14 <vixey> mc__, I can show you my different approach if you'd like
08:05:37 <mc__> vixey: of course
08:05:46 <mc__> mine is working now but rather inefficient I guess
08:06:09 <mc__> http://haskell.pastebin.com/m6e00b68a
08:08:16 <vixey> mc__, I think my way is quite efficient, http://hpaste.org/11668#a3
08:09:11 <mc__> vixey: but also quite complicated :)
08:09:55 * vixey thought it was extremely simple actually
08:10:55 <lopz> hukolele: :p
08:12:32 <mc__> vixey: well maybe it's just me, I do not really understand it. but I'm a newbie so thats probably my fault :)
08:13:51 <vixey> mc__, so consider, prime n = factors n == [n]  this says just that 'n is prime iff the factors of n are n alone'
08:14:12 <vixey> mc__, does that make sense so far, I mean without taking into account the definition of 'factors'
08:14:21 <mc__> yes it does
08:14:33 <vixey> so then the primes are defined: primes = 2 : filter prime [3, 5..]
08:14:47 <vixey> it' just 2 and then every odd number that is prime
08:15:35 <vixey> the bit that's slightly tricky is divisors I guess,  it finds the first divisor of 'i' is the list (x:xs)  (or returns i if it wants to give up)
08:16:02 <vixey> but with that in mind, you can see that factors just factorizes a number into prime divisors
08:17:09 <vixey> so it's efficient because there is a lot of sharing, the list of primes is reused often
08:17:24 <mc__> I see
08:19:05 <mc__> vixey: but what does group5 do?
08:19:19 <vixey> I have no idea, that's not part of my code
08:20:21 <vixey> anything before {-# LANGUAGE ViewPatterns #-} is irrelevant
08:20:54 <mc__> oh arlight :)
08:30:21 <RayNbow> vixey, http://hpaste.org/11668#a4
08:31:38 <vixey> that's much neater :)
08:32:44 <rog> quite often i find myself wanting to compile and test little functions in a module with some other broken stuff that i'm putting off for later. is there some way of telling ghci to "compile everything you can and just ignore the rest"?
08:33:35 <unenough> sound like a bad idea?
08:33:35 <unenough> *sounds
08:33:35 <Cale> Any opinions on the binding strength of -> in view patterns?
08:34:02 <Cale> rog: comment out the broken portions.
08:34:52 <rog> Cale: that's what i've been doing. it's just very easy to lose track...
08:34:57 <Cale> rog: I often find myself doing that. It might be nice to have a program that did it automatically, looking for a minimal set of declarations to comment out in order for the module to compile.
08:35:37 <Cale> But I try to only be working on one function at a time.
08:35:52 <Cale> So that it's always that one function which needs commenting out.
08:36:07 <Botje> rog: i set stuff to undefined
08:36:15 <Cale> Yes, that's a good trick as well.
08:36:42 <rog> Cale: the situation i'm in is that i'm transforming a load of code. so i need to get everything changed before anything'll work.
08:36:53 <RayNbow> Cale: I haven't used view patterns yet (probably because I find them a bit hard to read at the moment)
08:36:57 <Cale> rog: In that case, the type errors tend to be very helpful.
08:37:26 <Cale> RayNbow: f -> x  means that applying f to the thing in this spot gives a value which should be called x.
08:37:42 <Cale> (at least, that's how I think of it)
08:37:44 <rog> Cale: yeah, the type errors are invaluable. but when i'm writing little adjunct helper functions, i'd like to test them before carrying on with the whole problem.
08:37:57 <Cale> mm, yeah
08:38:20 <rog> Cale: that way i can use them to test hypotheses interactively.
08:38:26 <RayNbow> Cale: I know... yet I my reading speed drops tremendously when I encounter a view pattern :p
08:38:55 <Cale> RayNbow: I just find it slightly annoying that for instance,  map f (f -> x : map f -> xs) = x : xs  doesn't work.
08:39:04 <Cale> You have to write:
08:39:13 <Cale> map f ((f -> x) : (map f -> xs)) = x : xs  doesn't work.
08:39:30 <Cale> er
08:39:34 <Cale> - doesn't work ;)
08:39:50 <RayNbow> copy/paste is the source of all evil :p
08:39:53 <Cale> (I edited the line above and didn't remove that ;)
08:40:12 <Ferdirand>    
08:41:04 <Cale> Maybe the extra parens are a good thing, I'm not sure. It seems tedious to me to have to write them. It feels to me like -> should bind more tightly than any infix data constructor.
08:41:29 <RayNbow> map f (x:xs) = f : map f xs  -- I prefer this definition though :p
08:41:29 <Cale> I submitted a bug regarding this to the GHC trac.
08:41:35 <Cale> f x
08:41:39 <RayNbow> err, right :)
08:41:44 <idnar> view patterns?
08:41:48 <ziman> how about tail^2 (tail -> x : xs) = xs ?
08:42:03 <hkBst> @ 2 =/ 3
08:42:07 <ziman> tail^2 (tail -> (x : xs)) = xs
08:42:10 <ziman> would this work?
08:42:11 <Cale> I kind of like the idea of writing recursive functions in this way though.
08:42:14 <quicksilver> Cale: it feels to me like it should bind more loosely than any infix constructor.
08:42:18 <Cale> It's an interesting style.
08:42:22 <quicksilver> ;)
08:42:27 <Cale> quicksilver: That's what it currently does.
08:42:39 * quicksilver nods
08:42:44 <quicksilver> well you asked for opinions.
08:42:50 <Cale> quicksilver: right. :)
08:42:55 <Cale> quicksilver: Why do you think that?
08:43:00 <quicksilver> because I think of it as part of 'pattern syntax' which is 'outside' the 'expression' syntax
08:43:10 <hkBst> I thought Haskell used =/ or =\ for unequal to.
08:43:10 <quicksilver> in the same way that '@' binds more loosely
08:43:16 <Cale> hkBst: /=
08:43:21 <hkBst> :) thanks
08:43:38 <RayNbow> @let a != b = a /= b
08:43:40 <lambdabot>  Defined.
08:43:42 <Cale> hkBst: It's also how we write xor for Bool values ;)
08:43:44 <RayNbow> > 3 != 4
08:43:46 <lambdabot>   True
08:44:10 <Cale> quicksilver: hmm..
08:44:44 <Cale> quicksilver: It's just that I'm already used to writing parens around patterns like (x:xs)
08:45:10 * quicksilver nods
08:45:15 <Cale> quicksilver: So it wouldn't come as any shock to have to write them around the right hand side of -> when I wanted to match a nonempty list.
08:45:25 <quicksilver> yes, I do see that argument.
08:46:37 <Cale> Also, I think I got used to the view pattern syntax from the Wiki page and it implicitly makes use of this tight binding in a number of places.
08:46:47 <Cale> idnar: I should point you there...
08:46:51 <Cale> @where ViewPatterns
08:46:52 <lambdabot> I know nothing about viewpatterns.
08:47:11 <Cale> idnar: http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
08:47:15 <lambdabot> Title: ViewPatterns - GHC - Trac
08:48:40 <Cale> idnar: It's a cool new feature available in 6.10
08:48:46 <Modius> I saw a post about additions to GHC - that included language changes - within the haskell world, what is the prevailing spec, and how does this relate to GHC?  Is the prevailing Haskell "whatever GHC has", or is there a spec and GHC contains experimental features?
08:48:57 <vixey> my biggest concern about views is still being unsure if  f (g -> A) = ...; f (g -> B) = ...; evaluates g of the same parameter twice
08:49:01 <Cale> Modius: The spec is Haskell 98
08:49:01 <rog> Cale: i wasn't sure to start with, but i think the "already used to writing parens" argument is convincing for me.
08:49:17 <Cale> Modius: GHC and Hugs are always way ahead of the spec.
08:49:49 <idnar> oh awesome
08:50:13 <Cale> vixey: I think it would be silly if it did, but yes, it's a concern :)
08:50:56 <Modius> Does the spec generally follow GHC?  Does HUGs keep up with GHC (I mean the language additions, not the performance stuff)?
08:51:00 <mc__> What is wrong with this?: sqrt ( length "foo")
08:51:24 <vixey> > sqrt ( length "foo")
08:51:24 <RayNbow> :t sqrt
08:51:25 <lambdabot>       No instance for (Floating Int)
08:51:25 <lambdabot>        arising from a use of `sqrt' at <...
08:51:25 <lambdabot> forall a. (Floating a) => a -> a
08:51:26 <rog> Cale: one consideration though: you'll always need at least two sets of parentheses if you're using an infix constructor.
08:51:33 <RayNbow> :t length
08:51:34 <lambdabot> forall a. [a] -> Int
08:51:44 <vixey> it's length/haskell type systems fautl
08:51:46 <rog> Cale: ... which perhaps isn't ideal
08:51:52 <Cale> rog: right.
08:52:12 <Cale> mc__: length has a stupid type
08:52:12 <RayNbow> > (sqrt . fromIntegral . length) "foo"
08:52:14 <lambdabot>   1.7320508075688772
08:52:19 <Cale> mc__: So you have to apply fromIntegral
08:52:32 <Cale> mc__: Or use Data.List.genericLength
08:53:26 <mc__> does genericLength perform worse than length?
08:53:31 <Cale> Modius: GHC is at present the compiler with the most development support.
08:53:40 <RayNbow> sqrt is a pain in the ass for a lot of beginners... I've seen many students fall in battle trying to tame the sqrt beast :p
08:54:09 <Cale> mc__: Naively it should perform worse, but this is not necessarily the case. GHC has long had enough compiler magic to make it perform exactly as well in the case that you really want an Int
08:54:53 <mc__> but I do not really want an Int when using sqrt, do I?
08:54:54 <Cale> Modius: So if there are new features, chances are that GHC implements them as extensions.
08:55:05 <vixey> you can't always merge it into
08:55:12 <vixey> f x = case g x of ...
08:55:16 <Cale> mc__: Right, so you have to convert.
08:55:22 <vixey> because f might be a typeclass
08:55:25 <vixey> I mean g
08:55:38 <Cale> vixey: hm?
08:55:42 <jmelesky> Modius: the first post-Haskell-98 standard is under development as Haskell'
08:56:54 <Cale> But Haskell' is from the perspective of a Haskell *user* somewhat boring, because its intention is largely to specify features which already exist and are documented in the GHC User's Guide and various papers.
08:57:17 <Cale> But of course, it's great for authors and people who want a stable foundation to build on.
08:57:26 <timemage> that ' is going to make it a pain to search for.   is this read haskell prime?
08:57:31 <Cale> Yes.
08:57:41 <jmelesky> timeimage: the wiki is: http://hackage.haskell.org/trac/haskell-prime/
08:57:42 <lambdabot> Title: Haskell Prime - Trac
08:57:44 <Cale> The Haskell' name is provisional.
08:57:56 <vixey> like,
08:57:59 <Guest1868> @go haskell'
08:58:01 <Cale> It will probably be named Haskell 1.6 or something when it's done.
08:58:02 <lambdabot> http://www.haskell.org/
08:58:02 <lambdabot> Title: Haskell - HaskellWiki
08:58:03 <vixey> f (fromIntegral -> 3) = True
08:58:04 <jmelesky> Cale: you're right, of course. but Modius was asking about standards
08:58:08 <Cale> Yeah
08:58:09 <vixey> f (fromIntegral -> 3.45) = False
08:58:29 <vixey> should it be allowed or a type error or what
08:58:46 <vixey> f (fromIntegral -> (3 :: Integer)) = True -- maybe I should make sure these type are different
08:58:59 <Cale> vixey: ah, I see what you mean. I think that should coerce the 3 to have Fractional type, and then be defaulted to Double, myself.
08:59:14 <vixey> Cale, sorry something like
08:59:16 <Cale> vixey: hmm, or else be left generic
08:59:18 <vixey> f (foo -> "bar") = ...
08:59:23 <vixey> f (foo -> Quux) = ...
08:59:33 * Baughn is a bit annoyed at having to write fromIntegral all over the place when manipulating octets, too...
08:59:40 <Baughn> Everything insists on returning Int. ;_;
08:59:53 <vixey> if foo has a different return type because of typeclasses it is a recomputation problem
09:00:01 <Cale> I despise Int.
09:00:03 <vixey> if foo has a different return type due to GADT, then it is ok
09:00:07 <jmelesky> it would be nice if Haskell' were considering more recent language features, but that's hard to do with such an actively developed compiler family. we'd run the risk of ending up with the Common Lisp spec
09:00:12 <vixey> I despise lack of subtyping :/
09:00:15 <Cale> Int should not even be in the Prelude, from my perspective.
09:00:27 <vixey> and even worse my inability to implement it
09:00:32 <vixey> (in typeclasses)
09:00:41 <idnar> couldn't Integers that are small enough to be Ints have the same representation internally, so that you'd get the same performance most of the time?
09:00:44 <Cale> It's a correctness-breaking premature optimisation, and doesn't deserve to be the default type for anything.
09:00:49 <Baughn> jmelesky: Right. I do /not/ want sql-like list comprehensions in haskell'..
09:00:57 <vixey> jmelesky, and a very good specification it is ..
09:00:59 <Cale> idnar: They already do, to as close an approximation as possible.
09:01:09 <Baughn> vixey: All eight hundred pages of it
09:01:22 <idnar> Cale: oh, okay, I thought the performance gap was larger
09:01:32 <idnar> not that I've ever benchmarked it, though
09:01:35 <Cale> idnar: But using Integer requires you to do checks for integer overflow which is where the performance drop comes from.
09:01:44 <idnar> oh! of course
09:01:48 <jmelesky> vixey: and a stagnant one, too, in large part due to its length and density
09:01:50 <luite> sorry for asking again, but how can I compile ghc 6.10.1 without the documentation? the problme is that make fails on the documentation and cannot continue
09:02:03 <idnar> still, yeah, it's not something that should be around by default
09:02:06 <Baughn> luite: Do nothing. It compiles without the documentation by default.
09:02:13 <jmelesky> Baughn: really? i'm pretty keen on that comprehension feature
09:02:18 <vixey> jmelesky, thankfully it's a digital document not a fishtank
09:02:19 <Cale> luite: Why are you compiling it yourself?
09:02:33 <p_l> jmelesky: I think it's more stagnant cause no-one is willing to do anything about the spec (no one with enough resources)
09:02:34 <Baughn> jmelesky: It might have some interesting ideas, but the syntax makes me recoil in horror
09:02:37 <Cale> luite: Are you going to provide a binary for a new platform?
09:02:43 <vixey> since ideas don't go mouldy, it's not a problem
09:02:44 <Baughn> jmelesky: I'd rather have generalized monad comprehensions, anyhow
09:03:12 <Cale> luite: Or are you hacking on it? :)
09:03:14 <luite> Baughn: hmm, it stops with some haddock error, and I only used a --prefix in the configure
09:03:15 <Baughn> jmelesky: (Yes yes, issues aplenty there. It could use [| or some such.
09:03:21 <jmelesky> p_l: well, yeah, but the high resource requirement is in large part due to the size and complexity of the spec (compare, say the RxRS process for Scheme)
09:03:30 <Baughn> luite: You haven't touched mk/build.mk?
09:03:39 <mc__> vixey: just out of curiosity, how long does it take your solution to generate 10 000 primes? and on what hardware are you on? (I cant test your version because my ghc seems to be too old)
09:03:50 <vixey> mc__, dunno someone would have to time it
09:03:52 <jmelesky> Baughn: didn't an earlier Haskell have generalized monad cmoprehensions?
09:03:55 <p_l> jmelesky: With Scheme you could probably only add features... I mean, wasn't the original spec below 30 pages?
09:03:55 <Cale> Baughn: I've often wondered how it might look to combine the two extensions in a compatible way.
09:04:05 <vixey> mc__, you can replace the view pattern with a case expression
09:04:07 <luite> Cale: no, not yet at least ;) so I guess I can also use a binary, but I still think I should be able to compile it :)
09:04:12 <Cale> jmelesky: Yes, and they were foolishly removed.
09:04:18 <Baughn> jmelesky: Yeah, but that implementation turned out to be a bad idea due to mixing it up with the syntax for creating lists
09:04:37 <Baughn> jmelesky: Though I don't particularily agree with removing it, still
09:04:39 <luite> Baughn: no, just ran ./configure --prefix=/my/custom/install/location and then make
09:04:47 <Cale> luite: Compiling GHC yourself is a tremendous waste of cycles if you're not going to be hacking on it.
09:04:51 <luite> Baughn: I did add extralibs though
09:04:52 <BMeph_> I don't understand how bad the performance issue is for the SQL-like comp, w/o compiler support. Does anyone here know?
09:05:05 <jmelesky> p_l: yeah, the spec was and is tiny, especially compared to its big brother Common Lisp (the old joke was that the Scheme spec was smaller than the *index* for the CL spec)
09:05:05 <Baughn> Cale: Or you're on OS X, where it's the only way to get one that works properly.
09:05:31 <yitz> Baughn: well those of us on Tiger, or ppc, or both.
09:05:32 <luite> Cale: probably, but the extra heat from my laptop is great when you have cold hands ;)
09:05:35 <Cale> Baughn: Well... presumably one of the OSX devs is going to have a proper package out soon enough :)
09:05:48 <p_l> jmelesky: Though I have to say, 99% of complains about CL spec I hear from people hacking on CL, is about things that aren't there
09:05:56 <Baughn> yitz: Or leopard
09:05:57 <vixey> http://www.dur.ac.uk/CARG/plastic.html -- yeah... but where is the bloody download .. :/
09:06:08 <lambdabot> Title: The PLASTIC Proof Assistant
09:06:08 <Cale> luite: Okay, but when the inevitable heat death of the universe arrives, I'm blaming you.
09:06:11 <Baughn> yitz: The binary package seems to depend on port, which I don't use
09:06:25 <Cale> :)
09:06:39 <yitz> Cale: a pre-built never materialized for 6.8 on tiger, even for intel
09:06:41 <jmelesky> p_l: oh, i agree. CL was standardized before we had any idea what useful TCP/IP libraries looked like, for example
09:06:42 <Baughn> luite: That's wrong on several levels. First off it *shouldn't* be building the documentation, but besides that.. ghc includes a copy of haddock to use
09:06:44 <luite> Cale: yeah I guess I should apologize in advance for that
09:06:52 <yitz> Baughn: manuel's leopard pkg has problems?
09:07:16 <Baughn> yitz: At least the 6.8.3 version did. I'd try the 6.10.1, but I don't want to risk messing things up now that they're working.
09:07:49 <yitz> At least on Mac OS X you can build it using a port.
09:07:51 <luite> Baughn: this is the error message (only some newlines removed): haddock: Could not find module `Distribution.Package':   Use -v to see a list of the files searched for.  make[2]: *** [doc.stage.2] Error 1
09:07:55 <Baughn> yitz: Last I tried it, the ghc binary it installs has dependencies on a library in /opt (which doesn't exist, of course), and haddock won't link to its documentation. Assuming it has any.
09:08:05 <Baughn> luite: What version of ghc do you have installed?
09:08:09 <luite> 6.8.2
09:08:27 <Baughn> luite: Umh. Well, it's failing to find something in cabal..
09:08:29 <p_l> jmelesky: Also, CL lacks one "main" (like CPython, MS version of .NET, Sun's JVM) or "leading" implementation (like GHC). Also, it's age means people think there weren't any changes
09:08:30 <yitz> Baughn: if that happens you should tell manuel, he'll fix it. I think it's important.
09:08:44 <Baughn> luite: That's probably a bug, but you could try installing the newest version of cabal, globally, first
09:09:01 <p_l> jmelesky: While among "general public" Haskell is quite a new word (makes convincing people using GHC much easier)
09:09:24 <yitz> Manuel tried really hard to get his build to create a tiger pkg, we worked together on it, but in the end he wasn't successful :( It appears that for 6.10 he isn't even trying, but I'll drop him a line.
09:09:34 <Baughn> p_l: Haskell being better than CL for most purposes also helps, I assure you. ;)
09:10:13 <p_l> Baughn: I won't argue with you, not because I agree, but because I don't want to flame. And I like them both :D
09:10:25 <jmelesky> p_l: i agree, i'm just wary that GHC will, in pursuit of a more useful Haskell, become the new, unstandardized standard, rendering other Haskells unused
09:10:33 * Snark just realizes foldl (>>=) will do what he wants to
09:10:39 <Snark> that language is amazing
09:10:41 <yitz> I think a more serious issue is that there never was a binary of 6.8 that worked on production servers, like Debian stable.
09:10:48 <vixey> :t foldl (>>=)
09:10:49 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
09:10:50 <jmelesky> p_l: oh, come on, we haven't had a nice CL vs Haskell holy war in a while
09:11:04 <Badger> ooh
09:11:08 <Badger> holy wars
09:11:09 <ziman> :t sequence_
09:11:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
09:11:10 <yitz> If there is to be any impression that Haskell is a serious language for real work, that is a basic requirement.
09:11:11 <mmorrow> @type foldr (>>=)
09:11:12 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
09:11:12 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
09:11:12 <lambdabot>     In the first argument of `foldr', namely `(>>=)'
09:11:18 <p_l> jmelesky: I'm not going to. If I want to flame, I'm going after PHP or Java coders :>
09:11:18 <mmorrow> @type foldr (=<<)
09:11:19 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
09:11:19 <vixey> :t foldr (=<<)
09:11:20 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
09:11:24 <ziman> hm.
09:11:25 <sbahra> yitz, what do you mean?
09:11:31 <Baughn> yitz: Why would you want a compiler on a production server?
09:11:33 <vixey> :t foldr (=<<) (return ()
09:11:34 <vixey> :t foldr (=<<) (return ())
09:11:35 <lambdabot> parse error (possibly incorrect indentation)
09:11:35 <lambdabot> forall (m :: * -> *). (Monad m) => [() -> m ()] -> m ()
09:11:45 <luite> Baughn: ok, I'll try that
09:11:47 <yitz> Baughn: so that you can produce binaries that run on it.
09:11:54 <p_l> Baughn: Stable test & preparation environments
09:11:55 <jmelesky> p_l: why spend time on the easy targets?
09:11:58 <sbahra> yitz, it works fine here.
09:12:04 <p_l> jmelesky: Sadism
09:12:08 <yitz> sbahra: where is here?
09:12:18 <sbahra> FreeBSD centrino.freebsd.local 8.0-CURRENT FreeBSD 8.0-CURRENT #0: Fri Sep 19 18:17:45 EDT 2008     root@centrino.freebsd.local:/usr/obj/usr/src/sys/CENTRINO  i386
09:12:22 <Baughn> p_l: I had no problems installing my own copy of ghc on debian stable, though
09:12:31 <yitz> sbahra: ah, cool.
09:12:33 <sbahra> I also have 6.8.3 on another box.
09:12:34 <p_l> jmelesky: As well as anger for being forced to use Java in uni
09:12:35 <Baughn> Sure it isn't packaged, but that's not really haskell's problem?
09:12:41 <sbahra> That is used "in production", I guess.
09:13:10 <jmelesky> p_l: Java barely existed when i was in school, so it was C++ or Object Pascal for me
09:13:18 <p_l> Baughn: I don't know. I dropped Debian before I heard any more of haskell other than "this one weird package"
09:13:26 <yitz> But I think Debian stable is important.
09:13:59 <yitz> Baughn: it isn't packaged, and the generic binary does work. the only way is to build from scratch.
09:14:00 <Baughn> yitz: It may be impossible to support. Haskell moves fast; debian.. doesn't.
09:14:16 <pizza_> newbie here. trying to learn haskell by writing a hastable (i knoew Data.HashTable exists). i'm not sure if my code even ultimately works, but i'm getting a strange inconsistency where one call to (f x) complains about the type of x, but the exact same call on the next line compiles fine. http://hpaste.org/11754#a2
09:14:23 <Baughn> When they won't package anything newer than two years, and most haskell programs probably won't work with 6.8 soon enough, what can you do?
09:14:35 <yitz> Baughn: no problem to support. If I can compile it, why can't there be a backport, or at least a binary download?
09:14:43 <Cale> jmelesky: While this is true to an extent (a lot of things only work using GHC with extensions), the extensions are in most cases very well documented, and it's silly to try to standardise things which haven't been implemented and tried.
09:14:47 <Baughn> yitz: Oh, there could be /that/. I've got one
09:15:09 <yitz> Baughn: right, and that's correct policy. Debian stable rocks for a production environment.
09:15:14 <p_l> Baughn: I think it's not that hard to support Debian stable. Of course unless you use some libraries that clash with what is included in Debian stable
09:15:33 <Cale> pizza_: okay I'll have a look. I should also point out though that Data.HashTable is garbage and you should never ever use it.
09:15:43 <p_l> on the other hand, sid is dancing on blade's edge
09:15:46 <Baughn> p_l: That does make the download a bit larger, but it's not too hard if you install in /opt/ghc
09:15:51 <Cale> pizza_: Data.Map is pure, much faster, and scales better.
09:16:01 <jmelesky> Cale: yeah, i guess i just wish that the development effort either was entirely towards GHC, or more evenly spread out over the different compilers
09:16:05 <Cale> (and doesn't involve hashing)
09:16:18 <Baughn> Cale: It is? They are?
09:16:30 <Cale> Baughn: yes.
09:16:33 <Baughn> Cale: I had a program speed up ten-fold by using data.hashtable.. :/
09:16:38 <Cale> Baughn: really?
09:16:43 <yitz> pizza_: go with Data.Map.
09:16:53 <Baughn> Cale: Well, admittedly my first attempt at using data.map was pretty lame
09:16:58 <Baughn> Cale: I got stack overflows
09:17:08 <yitz> Baughn: insertWith'
09:17:12 <pizza_> Cale, yitz: noted; but this is purely a learning exercise
09:17:30 <Cale> Baughn: Don Stewart did some tests a while back and was unable to find conditions under which Data.Map performed significantly worse, and Data.HashTable was too size-limited to reach a point where hashing was a better option.
09:17:39 <Cale> pizza_: Right, I understand :)
09:17:41 <jpcooper> is Data.map.lookup implemented in standard Haskell 98? I'm wondering how it manages to do the returning of polymorphic monadic values
09:17:53 <Baughn> yitz: Unfortunately I really needed alter
09:18:00 <Cale> jpcooper: yes, also, it doesn't have that type anymore. It's really Maybe
09:18:07 <Baughn> yitz: Or at least I told myself I did, and it /was/ easier
09:18:09 <Cale> jpcooper: It was using fail before.
09:18:35 <jpcooper> Cale, okay. So is fail implemented in standard Haskell?
09:18:37 <luite> :t fail
09:18:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
09:18:50 <Cale> jpcooper: Yes, it's one of the greatest mistakes in the Haskell 98 standard.
09:18:53 <quicksilver> jpcooper: fail is a method. So monads have to supply it.
09:19:07 <Baughn> jpcooper: Don't worry, ghc 6.10 fixes it
09:19:09 <quicksilver> jpcooper: so this overloaded return is using the basic mechanism of haskell typeclasses.
09:19:16 <luite> ah it does get a String
09:19:16 <jpcooper> okay
09:19:23 <Baughn> lookup :: Ord k => k -> Map k a -> Maybe a
09:19:42 <jpcooper> does anyone know when Haskell' is planned to be finished?
09:19:47 <mmorrow> > 0
09:19:51 <mmorrow> @bot
09:20:05 <lambdabot> :)
09:20:06 <Baughn> jpcooper: Well, they're currently trying to revive it
09:20:12 <lambdabot>   0
09:20:20 <Baughn> > tick
09:20:21 <lambdabot>   Not in scope: `tick'
09:20:27 <mmorrow> > foldl' (\m c -> Map.insertWith (+) c 1 m) Map.empty (take 10000 . randomRs ('a','f') . mkStdGen $ 87384)
09:20:28 <lambdabot>   fromList [('a',1649),('b',1602),('c',1681),('d',1649),('e',1706),('f',1713)]
09:20:29 <Baughn> ..the lag
09:20:45 <vixey> I still don't get haskell' it seems totally pointless
09:20:54 <Cale> pizza_: Okay...
09:20:59 <sbahra> vixey, why?
09:21:06 <vixey> can't GHC just produce formal specs for each extension
09:21:12 <Baughn> vixey: Fills the same role as haskell-base, but for extensions, yes
09:21:12 <sbahra> haha
09:21:14 <Cale> pizza_: The problem is not with elems slots, it's with where you're trying to use that value
09:21:23 <Baughn> vixey: But yes, I'd prefer some sort of RFC-style process
09:21:34 <Cale> pizza_: htlookup wants a list of HTKeyvals
09:21:41 <vixey> Baughn, me too, "haskell'" is way too .. pretentious or somethin
09:21:46 <mmorrow> Baughn: Request For Compilation?
09:22:02 <jpcooper> vixey, why is it pretentious?
09:22:02 <Baughn> mmorrow: Comment. And let's mean that.
09:22:02 <vixey> if they actually wanted to change the language, like.. fix the broken bits, haskell' would be an ok name
09:22:10 <Cale> pizza_: Er, d'oh, I thought I understood this properly, but you have multiple things called slots ;)
09:22:24 <Baughn> Haskell' seems more like haskell++, the way it is now..
09:22:24 <Cale> pizza_: Okay, so what's the type of this array called slots here?
09:22:25 * Baughn hides
09:22:28 <mmorrow> Baughn: ahh. ;)
09:22:58 <idnar> Haskell Enhancement Proposal
09:23:07 <Cale> pizza_: whoa...
09:23:25 <Cale> pizza_: Are you sure you want slots to be defined using recursion?
09:24:08 <mc__> vixey:  I dont now if you care but I benchmarked your version against mine and your's takes  about 0.02 seconds longer to generate the first 10001 primes on my machine.  so 0.04 on average against 0.06 on average.
09:24:48 <vixey> mc__, oh so yours was more efficient?
09:24:50 <pizza_> Cale: no, i just couldn't figure out another way of doing it. keep in mind this is the first non-trivial haskell i've ever written, so i'm sure i'm doing things wrong.
09:25:20 <mc__> vixey: not the original one, I optimised it a bit further
09:25:30 <mc__> do you want to see it?
09:25:35 <vixey> yes
09:25:48 <Cale> pizza_: okay
09:26:06 <Cale> pizza_: if you write something like  x = ... x ...  in Haskell, it means that x is defined in terms of itself.
09:26:18 <mc__> http://haskell.pastebin.com/m8d937ff
09:26:18 <BMeph_> pizza_: "elems :: (IArray a e, Ix i) => a i e -> [e]" says that if slots is 'Array Int [HTKeyval]', elems slots is [[HTKeyval]].
09:26:24 <Cale> pizza_: So I'm guessing that you don't really want to call this thing slots
09:26:25 <prof_nimnul> Haskell Community Process, just like http://en.wikipedia.org/wiki/Java_Community_Process
09:26:26 <lambdabot> Title: Java Community Process - Wikipedia, the free encyclopedia
09:26:36 <Cale> BMeph_: Note that there are many things here called slots
09:27:10 <Cale> There's the top-level function slots, part of the parameter to htset which is being pattern matched as slots, and the definition in the let which is called slots
09:27:11 <pizza_> BMeph_: yes, that's what i want
09:27:19 <BMeph_> Cale: Oh, yes, I noticed it - and cringed. I think that's the specific problem with the bombing out line pizza_ has, though. :)
09:27:26 <vixey> mc__, oh interesting, I would have expected mine to be faster
09:27:27 <Cale> pizza_: So you should try not to overuse names like that ;)
09:27:41 <mc__> vixey: me too
09:27:59 <Cale> pizza_: The definition in the let will totally shadow the pattern matched 'slots', making it inaccessible, even inside the let.
09:28:11 <BMeph_> pizza_: but htlookup only wants a [HTKeyval], not [[HTKeyval]].
09:28:21 <Cale> pizza_: So at present, that definition of slots is recursive
09:28:42 <Cale> pizza_: Whereas you probably intended to define a new variable  slots'  in terms of slots.
09:28:58 <mc__> but main is a bit unfair because you have to guess a suitable value for s first
09:29:09 <mc__> s/main/mine
09:29:28 <vixey> what's s?
09:29:45 <pizza_> Cale: ok, i see, i will modify the names to be different
09:29:52 <pizza_> BMeph_: ok
09:30:09 <mc__> s is the last number I generate
09:30:32 <mc__> I generate numbers from 2 to s and then I remove all non primes
09:31:06 <vixey> why not let s be infinity?
09:31:13 <vixey> how does it help?
09:31:33 <mc__> with s set to infinity the algorihm will never compute any number
09:31:40 <vixey> yes it will
09:31:47 <mc__> no
09:32:01 <mc__> because it loops while x < sqrt(s)
09:32:02 <vixey> It wil
09:32:05 <vixey> I just tried it and it works
09:32:10 <mc__> really?
09:32:21 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
09:32:22 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:32:28 <Cale> mc__: ^^ have a look
09:32:31 <vixey> numberPool = [2..]
09:32:32 <pizza_> BMeph_: but my understanding is that the error is complaining about the parameter to 'elems', not the result of (elems ...) that is then passed to htlookup
09:32:45 <vixey> sieve (x:xs)= x : sieve (filter (not . sieveHelper x) (xs))
09:33:03 <vixey> see you only need that one case, that's the one that always happens when you have s = infinity
09:33:11 <vixey> s --> infinity I guess I should say
09:33:13 <Cale> mc__: Of course, that's not quite the same, but the point is that the first part of the result of sieve doesn't rely on the rest of the list, only on its first element.
09:34:04 <Cale> mc__: So the result of sieve is available immediately: it's a list whose head is the first element of the parameter to sieve, and whose tail is a recursive call to sieve.
09:35:27 <mc__> infinity is not in scope for me
09:35:32 <mc__> > infinity
09:35:33 <lambdabot>   * Exception: stack overflow
09:35:41 <Cale> mc__: Right. He really means to just remove s altogether.
09:35:56 <BMeph_> pizza_: It's a mix. htlookup is expecting a list of HTKeyvals, but the array you give elems winds up giving htlookup a list of [HTKeyval] - which is what the error is saying. :)
09:36:09 <vixey> :/
09:36:24 <Cale> mc__: So that numberPool = [2..], and  sieve (x:xs) = x : sieve (filter (not . sieveHelper x) (xs)), unconditionally.
09:36:27 <BMeph_> s/HTKeyvals/type HTKeyval/
09:36:34 <mc__> I see
09:36:41 <vixey> @remember <mc__> infinity <lambdabot>   * Exception: stack overflow
09:36:41 <lambdabot> Good to know.
09:36:59 <Cale> I wonder why that's a stack overflow...
09:37:05 <Cale> Someone must have defined infinity :)
09:37:13 <Cale> @undefine
09:37:17 <Cale> > infinity
09:37:18 <lambdabot>   * Exception: stack overflow
09:37:20 <Cale> huh.
09:37:25 <Cale> :t infinity
09:37:27 <lambdabot> Natural
09:37:32 <Cale> Natural, eh?
09:37:44 <vixey> > O
09:37:45 <lambdabot>   Not in scope: data constructor `O'
09:37:47 <vixey> > Zero
09:37:47 <lambdabot>   Not in scope: data constructor `Zero'
09:37:48 <vixey> > Z
09:37:49 <lambdabot>   Not in scope: data constructor `Z'
09:37:52 <vixey> > I
09:37:53 <lambdabot>   Not in scope: data constructor `I'
09:37:55 <Cale> aha
09:38:06 <Cale> > 5 < infinity
09:38:08 <lambdabot>   True
09:38:09 <mc__> with S set to infinity it takes MUCH longer
09:38:30 <mc__> 3  seconds compared to 0.04
09:38:36 <Cale> infinity is from Data.Number.Natural.
09:38:43 <vixey> mc__, but it gives the same answer in both cases?
09:38:52 <vixey> > infinity + infinity > infinity
09:39:00 <vixey> > infinity + 1 > infinity
09:39:02 <mc__> vixey: yes
09:39:07 <lambdabot>   thread killed
09:39:11 <vixey> mc__, why is that?
09:39:15 <lambdabot>   thread killed
09:39:17 <vixey> I don't understand it
09:39:18 <Cale> mc__: yes, it will be faster with a bound on s.
09:39:25 <vixey> Cale, whY ?
09:39:27 <mc__> but why?
09:39:33 <jmelesky> vixey, stop killing lambdabot
09:39:40 <vixey> I thought with lazyness it doesn't make a difference
09:39:43 <Cale> vixey: It skips testing for factors larger than the square root of s
09:40:17 <vixey> I don't see what you mea
09:40:54 <mc__> vixey: this is what he means  x  <  truncate ((sqrt . fromIntegral) s)
09:40:54 <Cale> vixey: By the time it's reached teh 10001st element of the list, the unbounded sieve is testing each new element for divisibility by 10001 numbers.
09:41:31 <Cale> vixey: By contrast, the bounded version only tests at most up to the square root of 120000
09:41:38 <Cale> > sqrt 120000
09:41:40 <lambdabot>   346.41016151377545
09:41:52 <vixey> Oh right, I understand it now
09:41:53 <Cale> (and only the primes up to that limit)
09:42:03 <Cale> You can make the unbounded version faster though.
09:42:08 <mc__> how?
09:42:09 <vixey> I can pull that trick in my code too :)
09:42:36 <vixey> is there a way to compute that bound?
09:42:43 <mc__> vixey: probably your version will be faster than, but it wuld be interesting to know for sure
09:43:29 <sbahra> > infinity
09:43:31 <lambdabot>   * Exception: stack overflow
09:43:34 <mc__> vixey: there is a law of prime distribution
09:43:40 <sbahra> @src infinity
09:43:40 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:43:42 <vixey> mc__, your version looks faster than mine without the bound
09:43:44 <Cale> > let primes = sieve [2..]; sieve (x:xs) = x : sieve [y | y <- xs, all (\p -> y `mod` p /= 0) (takeWhile (\p -> p^2 < y) primes)] in primes
09:43:50 <lambdabot>   [2,3,4,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83...
09:43:54 <Cale> like that
09:44:22 <mc__> Cale: may you explain that code?
09:44:47 <Cale> mc__: sure
09:44:54 <idnar> @type let primes = sieve [2..]; sieve (x:xs) = x : sieve [y | y <- xs, all (\p -> y `mod` p /= 0) (takeWhile (\p -> p^2 < y) primes)] in primes
09:44:56 <lambdabot> forall a. (Integral a) => [a]
09:45:28 <Cale> mc__: In fact, let me make it more readable first.
09:45:39 <vixey> awww I got beaten :p
09:45:39 <mc__> alright
09:45:50 <vixey> I wonder if I can make my method better
09:45:58 * idnar finds his code
09:46:18 <idnar> primes = 2 : filter isPrime' [3, 5..]
09:46:19 <idnar>     where isPrime' n = all (not . (`divides` n)) (takeWhile (\p -> p * p <= n) primes)
09:46:36 <Saizan> ?hoogle divides
09:46:37 <lambdabot> No results found
09:46:38 <idnar> I probably stole that off a wiki somewhere, though
09:46:43 <idnar> oh, divides m n = n `mod` m == 0
09:46:54 <idnar> I use that elsewhere, so I refactored it out
09:47:04 <Cale> > let admissible n p = p*p < n; divides n p = n `mod` p = 0; primes = sieve [2..]; sieve (x:xs) = x : sieve [y | y <- xs, all (not . divides y) (takeWhile (admissible y) primes)] in primes
09:47:05 <lambdabot>   <no location info>: parse error on input `='
09:47:21 <Cale> > let admissible n p = p*p < n; divides n p = n `mod` p == 0; primes = sieve [2..]; sieve (x:xs) = x : sieve [y | y <- xs, all (not . divides y) (takeWhile (admissible y) primes)] in primes
09:47:25 <lambdabot>   [2,3,4,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83...
09:47:28 <Cale> okay
09:47:40 <idnar> 4 isn't prime
09:47:44 <Cale> er...
09:47:54 <idnar> you want <= I think
09:47:59 <Cale> > let admissible n p = p*p <= n; divides n p = n `mod` p == 0; primes = sieve [2..]; sieve (x:xs) = x : sieve [y | y <- xs, all (not . divides y) (takeWhile (admissible y) primes)] in primes
09:48:02 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:48:04 <Cale> right, yes
09:48:10 <Cale> (thanks)
09:48:33 <Cale> So we'll say that a prime p is admissible for n if p*p is less than or equal to n.
09:48:42 <idnar> skipping even numbers up front gives you a bit more speed, although it does complicate things more
09:48:55 <sbahra> :t (<=)
09:48:56 <lambdabot> forall a. (Ord a) => a -> a -> Bool
09:49:01 <sbahra> oh
09:49:02 <sbahra> <=
09:49:03 <sbahra> haha
09:49:05 <Cale> > let admissible n p = p*p <= n; divides n p = n `mod` p == 0; primes = sieve (2:[3,5..]); sieve (x:xs) = x : sieve [y | y <- xs, all (not . divides y) (takeWhile (admissible y) primes)] in primes
09:49:08 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:49:12 * sbahra is being dyslexic 
09:49:16 <Cale> Not that much more complexity.
09:49:17 <pizza_> what is the standard method for profiling code and/or comparing versions (of prime number sieves for example)?
09:49:18 <Cale> Okay.
09:49:18 <idnar> sbahra: smileyface operator!
09:49:39 <Cale> So we're saying that the primes are the result of sieving [2..]
09:49:46 <Cale> or (2:[3,5..])
09:50:04 <PeakerWork> sbahra: You remind me of the bash quote:  How do you do that reversed "d" there?
09:50:07 <Cale> and what does sieve do?
09:50:13 <PeakerWork> sbahra: (Referring to "b", ofcourse)
09:51:09 <jmelesky> Cale: removes non-primes, of course
09:51:13 <Cale> The result of sieving the list (x:xs) is the list starting with x, whose tail is the list of y chosen from xs where no prime which is admissible for y divides y.
09:51:47 <Cale> The primes which are admissible for y are those which are less than or equal to its square root.
09:51:54 <mc__> Cale: but that method is still a lot slower than the bound one
09:52:45 <Cale> mc__: Hmm, it might be made faster by not computing the square of all those primes.
09:53:38 <mc__> I think the best method were to compute the bound, that way the algorithm could generate any prime and still be very fast
09:54:06 <Cale> yeah
09:57:41 <Cale> It's important to note that these aren't really the sieve of Eratosthenes.
09:58:22 <idnar> that would be something like
09:58:23 <idnar> > sieve (p:xs) = p : sieve [x|x <- xs, x `mod` p > 0]
09:58:25 <lambdabot>   <no location info>: parse error on input `='
09:58:26 <idnar> er
09:58:27 <Cale> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf contains a nice discussion of this and other prime generating algorithms, including a genuine sieve which is asymptotically and practically much better than these.
09:58:29 <lambdabot> Title: The Genuine Sieve of Eratosthenes
09:58:36 <idnar> > let sieve (p:xs) = p : sieve [x|x <- xs, x `mod` p > 0] in sieve [2..]
09:58:38 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:58:39 <PeakerWork> what is the O() of ByteString concat?
09:58:49 <idnar> or wouldn't that count?
09:59:15 <idnar> ah.
09:59:19 <idnar> guess I should read that paper, then
09:59:28 <Cale> idnar: No, while it looks a bit like the sieve of Eratosthenes, it's secretly doing trial division.
09:59:33 <idnar> oh wait
09:59:38 <idnar> I copied and pasted the wrong code
09:59:41 <Cale> (of course, not that secretly)
09:59:44 <sbahra> Peaker, O(n) I would imagine, depending on number of chunks in a lazy bytestring.
09:59:49 <sbahra> Peaker, but that is a wild guess.
10:00:03 <sbahra> PeakerWork, why not read the sourcecode?
10:00:21 <PeakerWork> sbahra: Its not pure Haskell, I think, and I thought people had a quick answer...
10:00:48 <PeakerWork> I'm trying again to create a pickler combinator, and I am not yet focused on performance, but I used the ShowS with normal Strings, and now I see that ShowS does not work well with a Monad instance..
10:01:05 <Cale> The real sieve of Eratosthenes uses O(n log log n) operations to find all the primes up to n.
10:01:32 <PeakerWork> come on, O(log (log n)) == O(1) :-)
10:01:53 <Cale> Whereas these ones take O(n^2/(2 (log n)^2))
10:02:02 <idnar> hmm
10:02:08 <Saizan> PeakerWork: seen Data.Binary.Put ?
10:02:13 <idnar> I thought I had some code around here that was different
10:02:19 <idnar> I can't remember how it worked, though
10:02:46 <PeakerWork> Saizan: Oh yeah, last time someone wrote a combinator attempt it was using that...
10:02:58 <idnar> it was similar to the recursive sieve, except it filtered the multiples out of the rest of the list instead of doing division, or something
10:03:00 <PeakerWork> Saizan: I'll try using that
10:03:46 <idnar> oh, here
10:03:52 <idnar> it's the same code he presents in the Epilogue
10:03:54 <BMeph_> idnar, Cale: Isn't oleg's version a real SoE? :)
10:04:06 <Cale> BMeph_: Which one is that?
10:04:20 <Cale> BMeph_: Melissa O'Neill's version is real :)
10:04:29 <yitz> Cale: I remember that thread on the Cafe. The algorithms and their complexities are very interesting. But I don't buy the "not really the Sieve of Eratosthenes" claim.
10:04:52 <Cale> yitz: Well, the asymptotic complexity is vastly different.
10:04:57 <yitz> They really *are* the Sieve. Some of them, anyway.
10:05:33 <mc__> by the way, removing all odd numbers upfront reduces the average runtime from 0.04 to 0.015, amazing
10:05:35 <PeakerWork> Put is kind of a silly monad, isn't it?
10:05:36 <yitz> Cale: yes, there are differences in those algorithms.
10:05:41 <BMeph_> yitz: No, most of them "really are" naive sieves, but they aren't the SoE algorithm. :)
10:05:44 <idnar> http://hpaste.org/11758
10:05:46 <idnar> that one
10:06:03 <yitz> Cale: But I don't think that's exactly how Eratosthenes thought of it.
10:06:04 <PeakerWork> Put does not really do anything interesting with the value inside it.. W.R.T the value, it is the Identity Monad?
10:06:11 <Cale> Of course, the sieve of Eratosthenes might not be considered an algorithm, but a whole class of algorithms, and a general idea for finding primes. But doing trial division for all numbers less than the square root of n seems to miss the point.
10:06:14 <idnar> mc__: naively, that sounds about right
10:06:34 <idnar> you're doing a quarter of the work, or something
10:06:42 <Cale> (or even all primes less than the square root of n)
10:06:56 <Saizan> PeakerWork: what do you mean by "value inside it"?
10:07:09 <mc__> Cale: why does it seem to miss the point to you?
10:07:22 <PeakerWork> Saizan: PutM is the monad, Put is (PutM ()) -- so PutM is always used with () as a value
10:07:44 <BMeph_> I'm now not sure, but I think http://hpaste.org/11759 is the one I got from oleg's site.
10:07:58 <Saizan> PeakerWork: ah, yeah, you're only interested in the side-effects in the end
10:08:10 <PeakerWork> Saizan: yeah, it seems like it shouldn't really be a monad
10:08:22 <PeakerWork> Saizan: but something else that only has something like (>>)
10:08:27 <PeakerWork> Saizan: Monoid?
10:08:27 <idnar> PeakerWork: why? it seems similar to the IO monad or the ST monad
10:08:43 <PeakerWork> idnar: IO/ST have meaning to the (>>=) operation,  there's no use for >>= in Put
10:09:07 <PeakerWork> Saizan: I think Put should be a Monoid, instead of a Monad..
10:09:13 <bbs> woohoo
10:09:17 <bbs> Cale: helpzz
10:09:19 <bbs> :)
10:09:31 <PeakerWork> idnar: because there's no side-effect that has a result in Put
10:09:37 <mc__> BMeph_: that version is extremely slow
10:09:44 <mc__> BMeph_: 16 seconds
10:10:08 <idnar> PeakerWork: I suppose
10:10:08 <BMeph_> Read about it here - http://okmij.org/ftp/Algorithms.html#Eratosthenes-sieve
10:10:08 <PeakerWork> all the n-tuple instances make me sad. 2-tuples ftw
10:10:09 <lambdabot> Title: Algorithms and Data Structures
10:10:30 <bbs> http://zlin.dk/p/?ZDQ0Yjc0
10:10:36 <lambdabot> Title: K-nopaste
10:10:37 <bbs> http://zlin.dk/p/?NzY4YzFj
10:10:38 <lambdabot> Title: K-nopaste
10:10:42 <bbs> http://zlin.dk/p/?ZTE2YzVi
10:10:43 <lambdabot> Title: K-nopaste
10:10:45 <BMeph_> mc__: It's meant to be illustrative; read the blurb at the link. :)
10:10:59 <mc__> oh, alright
10:11:28 <idnar> eek, my browser is going insane
10:11:33 <bbs> i get a huge error at the last one
10:11:35 <bbs> line 93
10:11:43 <BMeph_> mc__: Specifically: " The Haskell implementation is not meant to be efficient -- rather, it is meant to be purely functional, insightful, minimalist, and generalizable to other number sieves, e.g., `lucky numbers'."
10:12:30 <mc__> BMeph_: I think all but the last requirement apply to my solution nearly as well
10:12:50 <idnar> mc__: can you try http://hpaste.org/11758 ? I'm interested to see how that compares
10:12:51 <Saizan> PeakerWork: yeah right, it's like the Writer monad witout anything like "listen", maybe the only use of the Monad instance is to layer transformers over it
10:13:10 <mc__> idnar:  of couse
10:13:33 <Cale> mc__: try http://hpaste.org/11760
10:13:46 <idnar> algorithm spam!
10:14:27 <Cale> It'll be an order of magnitude faster than anything mentioned rather quickly.
10:14:59 <PeakerWork> Saizan: Hmm, I think it should be a Monoid, and there should be an adapter like a Kleisli arrow, from a Monoid into a Monad without "get" side effects - so that Monoids in general can be used inside transformers
10:15:04 <BMeph_> Cale; That's from Melissa's paper (the one before the PQ impl), right? :)
10:15:05 <mc__> idnar: it takes 0.1 - 0.12 seconds
10:15:07 <bbs> Cale: http://zlin.dk/p/?ZTE2YzVi
10:15:08 <lambdabot> Title: K-nopaste
10:15:10 <bbs> line 93 fails
10:15:14 <bbs> :/ and idk why
10:15:16 <PeakerWork> Saizan: Having a specific adapter for Put is not very nice..
10:15:37 <idnar> Cale: according to the paper, mine is faster for "all pratical values of n"
10:16:14 <idnar> ("mine" -- I copied the implementation straight out of the paper)
10:16:24 <mc__> Cale:  I cant compile yours
10:16:31 <Cale> mc__: --make
10:16:36 <Saizan> PeakerWork: what you're describing is the Writer Monad/Applicative i think, PutM is a specialization of that using a strict field and more INLINE pragmas
10:16:55 <jeffersonheard> anyone know how to add an item to an interface after I've loaded it from a Glade XML?
10:16:55 <Cale> idnar: Faster than trial division.
10:16:59 <mc__> Cale: why ist that necessary?
10:17:11 <Cale> mc__: Because it uses Data.Map which is in the containers package.
10:17:19 <mc__> Cale: it is not faster 0.2 - 0.22 seconds
10:17:20 <jeffersonheard> I answered my own question earlier -- Glade cannot handle a Graphics.UI.Gtk.OpenGL.GLDrawingArea
10:17:22 <PeakerWork> Saizan: where's the Put monoid then?
10:17:32 <PeakerWork> Saizan: it seems like only an empty-monad is exported
10:17:32 <Cale> mc__: Try a larger number of primes?
10:17:43 <mc__> isnt 10001 quite large?
10:17:55 <Saizan> PeakerWork: hidden: http://hackage.haskell.org/packages/archive/binary/0.4.3.1/doc/html/src/Data-Binary-Builder.html
10:18:01 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/636ecq
10:18:05 <BMeph_> idnar: Which paper?
10:18:21 <idnar> BMeph_: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
10:18:23 <lambdabot> Title: The Genuine Sieve of Eratosthenes
10:18:28 <idnar> mc__: try a million, at least
10:18:48 * Saizan wonders if rewriting Put code using directly the monoid would improve performance
10:18:50 <mc__> bah, thenn I'll have to adjust my bound xD
10:18:55 <idnar> heh
10:19:06 <idnar> I've forgetten what you were using this for
10:19:12 <idnar> finding the nth prime?
10:19:36 <Cale> mc__: Oh, and make sure you're compiling with -O2
10:19:44 <PeakerWork> Saizan: I think they probably put it in an empty monad not for the transformer-ability, but for "symmetry" with the Get monad
10:19:46 <mc__> yeah I compiled everything with O2
10:19:50 <PeakerWork> Saizan: (my guess)
10:20:55 <bbs> Cale: i got it allz by myself
10:21:49 <Cale> hmm
10:22:15 <PeakerWork> why does Put expose "flush" (which chunks the resulting bytestring)?  Do the chunks have any effect except performance?
10:22:34 <bbs> Cale: that error i was complaining about aboce
10:22:37 <Cale> bbs: Okay :)
10:23:11 <bbs> Cale: but could you help me cut the fat out of one statement?
10:23:26 <bbs> it works
10:23:35 <bbs> its just a pain
10:23:41 <Cale> bbs: okay
10:23:43 <bbs> vixey: i used a lookup function instead of your data type
10:23:56 <bbs> http://zlin.dk/p/?ZTE2YzVi
10:23:59 <bbs> Cale: ^
10:24:00 <lambdabot> Title: K-nopaste
10:24:05 <Cale> mc__: okay, that's interesting.
10:25:07 <albdogo> does anyone know a good article about monads and arrows¿
10:25:34 <PeakerWork> @where Monads promiscuous
10:25:34 <lambdabot> http://www.haskell.org/all_about_monads/html/
10:25:40 <PeakerWork> ok, not that
10:25:58 <PeakerWork> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
10:26:02 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous, http://tinyurl.com/6evopg
10:26:11 <PeakerWork> albdogo: that's the usual reference
10:26:16 <PeakerWork> (I find it hard to read, though)
10:26:20 <bbs> Cale: i also had to write runp1 because runp was throwing errors
10:26:49 <Cale> bbs: That's not one statement ;)
10:26:54 <lilac> ISTR i found that 'idioms are oblivious' paper profoundly unhelpful :)
10:27:12 <albdogo> That article es too much difficult for me
10:27:19 <albdogo> an introduction or something like that?
10:27:36 <Cale> albdogo: Don't study monads and arrows at the same time.
10:27:46 <Cale> albdogo: Do you understand monads already?
10:27:54 <lilac> monad tutorials are everywhere (read at least 3). for arrows, try this: http://www.haskell.org/arrows/
10:28:00 <lambdabot> Title: Arrows: A General Interface to Computation
10:28:06 <Cale> albdogo: I would start with them, since they're generally more useful and probably easier to grasp than arrows.
10:28:11 <PeakerWork> runPut returns Data.ByteString.Lazy.Internal.ByteString -- are you supposed to import Internal modules?
10:28:41 <mathijs> Hi all, while I'm just learning haskell, I know it's not a good plan to start toying with the FFI and stuff, but I have a ruby project that involves heavy parsing (using ruby's parsec port) and which I did in a functional way (pure functions). This project has to start cooperating with a .net app (as in, has to be available as .dll like thing) while this is possible, I would rather try porting it to haskell (so I can learn in company-time). What
10:28:42 <Cale> albdogo: If you want, I can give a live tutorial on monads, or point you at various references.
10:29:05 <Cale> mathijs: Cut off at "company-time). Wha"
10:29:15 <lilac> albdogo: once you understand arrows and monads separately, it's interesting to start thinking about kleisli arrows of monads and the like, but i wouldn't want to start there
10:29:21 <mathijs> What are haskells possibilities on .net? I googled a bit but I couldn't find anything concrete.
10:29:53 <jmelesky> mathijs: i think the haskell possibilities on .net right now are F#
10:29:55 <Cale> mathijs: There was some work put into a .NET backend for GHC a while back, but it was abandoned.
10:29:57 <PeakerWork> mathijs: Surely you can just communicate with .NET apps via sockets/etc
10:29:59 <albdogo> I understand the list monad
10:29:59 <jmelesky> which isn't haskell
10:30:10 <mathijs> It doesn't have to be a .net executable or anything, native win32 dll is good enough, and the data passed back and forth is mostly strings
10:30:15 <albdogo> but id ont understand for example the state one
10:30:22 <vixey> @src State
10:30:22 <lambdabot> Source not found. Wrong!  You cheating scum!
10:30:40 <Cale> mathijs: I'm not certain if it's possible to produce native Win32 DLLs with GHC either.
10:30:46 <mathijs> PeakerWork: That's an option too, still deciding/exploring
10:31:02 <Cale> mathijs: If it is, it probably involves writing a C wrapper around a Haskell library using the FFI.
10:31:03 <pozic> I defined (.) = fmap, but according to the profile it spends 15% of the time in that function. Isn't that a bit odd, considering that it should be a no-op?
10:31:18 <vixey> pozic, why on earth would it be a noop
10:31:22 <maltem> PeakerWork: that "Internal" type should just be a plain old ByteString
10:31:37 <Cale> albdogo: Okay...
10:31:48 <PeakerWork> maltem: Oh.. Its ByteString.Lazy.ByteString, yeah, thanks
10:31:57 <mathijs> Cale: that's an option, but in that case a socket or other communication thingy might be just as good and would give me network-ability
10:32:02 <Cale> albdogo: Come to #haskell-overflow and I'll give you a hand with the state monad. :)
10:32:35 <pozic> vixey: what work does it do?
10:32:46 <Cale> mathijs: Right. It would probably be easier to write a program entirely in Haskell which just communicates over the network with other applications :)
10:33:05 <idnar> is fmap listed in the profile?
10:33:13 <pozic> idnar: no
10:33:28 <bbs> Cale: all i wnat is the Assign one
10:33:36 <bbs> the one we were talking about before
10:33:38 <bbs> its SUPER ugly
10:33:43 <mathijs> Anyway, the .net possibilities for haskell sound about the same (or worse) as ruby. So I'm affraid I won't be able to convince my boss to port to haskell on that point.
10:33:46 <idnar> then I suspect all of the work done in fmap is being put on (.)'s bill, so to speak
10:34:35 <Cale> bbs: oh, I see that.
10:34:45 <Cale> bbs: You use a lot of if/then/else rather than pattern matching...
10:34:54 <mathijs> Cale: and for network communication... what's a good strategy for haskell? just pass strings around? or is haskell good at xml? or soap (ugh)?
10:35:10 <teratorn> someone should really implement AMP in Haskell...
10:35:16 <vixey> what's AMP
10:35:27 <teratorn> a simple wire protocol for making remote "calls"
10:35:34 <pozic> idnar: could be, still it's way more than I expected.
10:35:36 <maxote> why not RPC?
10:35:45 <teratorn> maxote: is that a thing?
10:36:03 <maxote> RPC = Remote Procedure Call
10:36:07 <Cale> bbs: Maybe try using more let/case...
10:36:07 <pozic> Isn't the Buzzword Bingo name for that a Message Queue?
10:36:23 <pozic> Or a "messaging system"?
10:36:26 <teratorn> vixey: http://twistedmatrix.com/trac/browser/trunk/twisted/protocols/amp.py
10:36:30 <lambdabot> Title: /trunk/twisted/protocols/amp.py – Twisted, http://tinyurl.com/yv4r9k
10:36:43 <teratorn> vixey: It has been ported to quite a few other languages, also
10:36:49 <Cale> mathijs: I haven't done a lot of network stuff in Haskell, but there are XML libraries if you really need it, as well as things like JSON.
10:37:16 <teratorn> maxote: it's just an acronym.. we were talking about concrete protocols...
10:37:26 <Cale> mathijs: It probably depends more on what's convenient on the other end.
10:40:46 <bbs> anyone know how to use fmt in here
10:41:03 <Baughn> Which one?
10:41:19 <mathijs> Cale: tnx, I might look into those then, json sounds like a nice solution (more lightweight than xml). 'the other end' is mostly a database (with lots of triggers and stuff). My app is a 'db schema converter', it receives sql queries by applications that have a concrete db-need (for example blogposts and comments), and converts those to one or more sql statements for this .net app. That .net app has a very very generic db structure (basically ob
10:41:26 <mathijs> cut off again? :)
10:41:34 <Cale> mathijs: yes.
10:41:36 <Cale> (basically o
10:41:37 <Baughn> Basically ob.
10:41:39 <mathijs> That .net app has a very very generic db structure (basically objects and links between them). 1 sql query might result in multiple new ones. So I will be passing the .net app those queries, and receive results which I can then combine/parse/filter or issue new queries with.
10:42:48 <mathijs> so the .net app does the talking to the db, but has to send result-sets back to me, I'm not sure what format will be suitable for that (via the network)
10:43:11 <mathijs> maybe just a string with some column markers
10:44:10 <jmelesky> mathijs: or a JSON list of lists
10:44:45 <mc__> Cale: sorry I was afk, what is interesting?
10:44:58 <mathijs> possibly, but can json handle most types? (numbers, strings, blobs maybe)
10:45:33 <mathijs> forget that question, I can go base64 on blobs
10:45:51 <jmelesky> strings, numbers, bools, lists/arrays, and dictionary-type dealies, i believe
10:46:50 <mathijs> ok, so that might do it, just a pure haskell app, communicating through a socket/tcp with .net passing json back and forth
10:47:33 <saml> mathijs: that way you're essentially doing perl or shell scripting where everything is string
10:47:53 <BMeph_> mathijs: There's also a spin-off to JSON to do objects, and the links between them... ;)
10:48:31 <Cale> mc__: The performance. I'm not sure exactly why the bounded one is faster then.
10:49:33 <mathijs> BMeph_: well I will only receive sql resultsets (rows, columns) from the .net app, so those aren't really objects.
10:49:38 <mc__> because it only needs to check factors smaller than the square root of the bound
10:50:55 <mathijs> probably the .net app can deliver those sets as tuples too, tuples as string I mean, which I can read into a tuple again.
10:50:59 <jmelesky> mathijs: saml has a point -- one of the strengths of Haskell is its flexible type system, so you could (probably pretty easily) define something stricter than JSON that serializes to a binary format
10:52:29 <mathijs> jmelesky: true, but the .net app will have to convert the output to that format too, and this .net company I have to work with is using VB, so I think I should go easy on them :)
10:52:42 <ttt--> how can i do "data Foo = Bar" in ghci?
10:53:08 <jmelesky> mathijs: which raises the other question: does VB have a useable JSON library?
10:53:49 <mathijs> jmelesky: probably not, bu what about my suggestion for using tuple-string? since the data is a sql-query result, its a list of same-length tuples.
10:54:36 <mathijs> asking them to put parentheses around each row, separate the columns by commas, and put " around strings is not too much to ask.
10:55:12 <jmelesky> mathijs: yeah, you should be able to whip up a list-of-tuple-strings parser pretty quickly
10:55:36 <mathijs> and I do know in advance what the type of each column is gonna be, so I can just use read on the string and use :: (String, Int, Char)
10:56:24 <arussel> is there a way to get "real world haskell" in pdf or epub ?
10:56:32 <jmelesky> in that case, yeah, easy
10:57:04 <jmelesky> arussel: print the web pages to pdf
10:57:05 <mathijs> jmelesky: and if I encounter blob-types (don't know if they are there), I can use base64 for those.
10:57:25 <jmelesky> arussel: i don't think the book's reached publication yet
10:58:04 <arussel> jmelesky: ok, thanks
11:00:00 <mathijs> ah... one last question... How's haskell's UTF8 support? I mean if I'm gonna be passing strings back and forth I have to make sure foreign characters won't screw up.
11:04:43 <Saizan> mathijs: there's utf8-string and other packages on hackage
11:05:15 <dons> mathijs: works out of the box. use utf8-string for IO functions, and Char and String types internally
11:05:26 <mathijs> nice
11:05:32 <sjanssen> dons: "works out of the box" is hardly true
11:05:49 <jpcooper> does anyone know how to solve Opera's not following links to function descriptions in the haskell documentation? Maybe it's down to the code not being standard?
11:06:02 <dons> sjanssen: well, Char and String are out of the box ready
11:06:02 <sjanssen> utf8-string doesn't come with GHC, and the default IO routines don't use UTF-8
11:06:04 <maltem> mathijs: the standard IO functions are bad at UTF8, so be sure to use IO functions from utf8-string or bytestring
11:06:08 <sjanssen> dons: true
11:06:24 <dons> you just plug in your decode/encode IO layer. cabal install utf8-string
11:06:28 <dons> 'nuf said.
11:06:49 <sjanssen> we really need to fix System.IO
11:07:38 <sbahra> System.IO.ByteString
11:08:15 <sjanssen> sbahra: that isn't a solution to the encoding problem
11:08:32 <sbahra> No, it isn't.
11:08:45 <maltem> Disk I/O on that uni cluster sucks... compiling ghc 6.10 takes hours :(
11:11:22 <mathijs> can I pass types to a function? as in a 'parse' function which I pass a string and a type and it returns me the result in that type?
11:11:53 <mrd> > read "1" :: Int
11:11:54 <lambdabot>   1
11:11:59 <maltem> mathijs: you cannot, but you have parametric polymorphism
11:12:08 <Saizan> you can't pass types, but you can have functions overloaded on the return type, like read
11:12:09 <mrd> type-classes you mean
11:12:11 <Saizan> ?type read
11:12:12 <lambdabot> forall a. (Read a) => String -> a
11:12:17 <mathijs> mrd: in that case Int isn't passed in
11:12:41 <Saizan> > read "1" :: Bool
11:12:42 <lambdabot>   * Exception: Prelude.read: no parse
11:12:50 <mrd> mathijs: right. you can't pass it in as a value.  but you can give it an explicit type.
11:12:52 <sbahra> > read "True" :: Bool
11:12:53 <lambdabot>   True
11:13:16 <mrd> mathijs: remember, types don't exist after compilation/typechecking
11:13:31 * mrd is not getting into Typeable
11:14:22 <mathijs> well, it's for this sql-result-parsing. I know in advance what type all results are gonna be, but not as in 'at compile time', but for every sql query I pass to the db, I know in advance what type result will be there, will I be able to pass that along to the function that will parse the result when it gets in?
11:14:23 <roconnor> > read "True" `asTypeOf` True
11:14:25 <lambdabot>   True
11:14:33 <roconnor> > read "True" `asTypeOf` False
11:14:35 <lambdabot>   True
11:15:32 <mrd> for example if you had a default value, you could use what roconnor suggested
11:16:43 <roconnor> mathijs: as long as you can create a term of the right type, you can use asTypeOf
11:16:44 <mrd> the simplest answer for you is probably to create a disjoint union datatype SqlResult
11:16:56 <mdmkolbe> I've got to run in a bit, but I wasted to ask if there is a hackage specific mailing list or a good place to get feedback on preparing or developing a cabal package to be released on hackage.
11:17:00 <mathijs> mrd: yes but that still has False written in code, I can't pass it as 'variable'.
11:17:18 <mrd> mathijs: let x = False in read "True" `asTypeOf` x
11:17:22 <mrd> > let x = False in read "True" `asTypeOf` x
11:17:23 <lambdabot>   True
11:17:28 <mrd> asTypeOf is a function
11:17:42 <roconnor> @src asTypeOf
11:17:43 <lambdabot> asTypeOf = const
11:18:24 <mrd> anyway then you can write  function, parse :: String -> SqlResult
11:18:27 <Saizan> mdmkolbe: the most suited seem cabal-devel or haskell-cafe
11:18:38 <mrd> and the results will be tagged with a constructor like SqlInt, SqlString
11:18:51 <mrd> it's not the coolest solution, but it's pretty basic
11:18:56 <mathijs> mrd: well that SqlResult is gonna have different types (per column) depending on the query that was performed.
11:19:08 <mrd> mathijs: right, that's what a union type is about
11:19:21 <mathijs> ah, I think I understand
11:19:35 <mrd> datatype SqlResult = SqlInt Int | SqlString String
11:19:49 <mathijs> ok, I get it
11:20:00 <mathijs> and the result will be [SqlType]
11:20:04 <mdmkolbe> Saizan: thx, I hadn't thought of cabal-devel so I'll be sure to check it out
11:20:13 <mathijs> or even [[SqlType]]
11:20:14 <mrd> [SqlResult] yea, or whatever you call it, is a list of results
11:20:30 <mathijs> ok, get it
11:20:31 <mrd> [SqlInt 1, SqlString "hi"]
11:20:48 <mathijs> yeah, and a list of those (one per result)
11:20:55 <mathijs> (db row)
11:21:17 <mrd> then when your program wants to analyze the results, you perform case analysis on the SqlResult and handle it appropriately
11:21:24 <mathijs> ok, I think I can get that done
11:21:43 <mrd> great
11:22:58 <mathijs> well, not really analyze the result, but I can pass the parse function the result (as string) and the expected array of sqltypes (per column) as in parse "('c', 3.5)" [SqlChar, SqlFloat]
11:23:37 <mrd> no
11:23:43 <mathijs> (provided I get the results back in that Show-like format)
11:23:51 <mrd> not like I've outlined anyhow
11:24:05 <Heooo> Are these equivalent: "\x. x \y. x" ?
11:24:30 <mrd> Heooo: \x.x vs \y.x ? no
11:24:45 <mathijs> mrd: well, if I want to analyze the result, I won't be able to know if 3 is meant to be Int or Float
11:25:01 <mathijs> so I have to pass that along to the parse function
11:25:03 <mathijs> right?
11:25:09 <mrd> mathijs: on the other hand, you could just write something to convert it after the read
11:25:18 <wchogg> @seen conal
11:25:19 <lambdabot> I saw conal leaving #haskell and #ghc 1h 39m 31s ago, and .
11:26:00 <mathijs> mrd: yeah, that's what I'm after, but I need a way to tell the parse function how to convert it.
11:26:28 <Saizan> mathijs: you can pass it a [String -> SqlResult]
11:26:37 <mathijs> It won't be able to magically determine that by itself because of the 3 (int/float) problem.
11:26:40 <Saizan> or whatever you use instead of String
11:26:51 <mrd> saizan has a good idea
11:27:33 <Saizan> where the elements of [String -> SqlResult] are the specific parts of the parser for the various formats
11:29:08 <mathijs> hrm... so those String -> SqlResult will be functions that parse the result the way I want? as in sqlToInt s = read s :: Int
11:29:40 <mathijs> and then use parse "long result string" [sqlToInt, sqlToString, sqlToDate]
11:29:40 <urza> hello niggers
11:29:57 <camior> urza: ?
11:30:25 <sam__> If all vars are bounded, which \ -statements are such that you cannot reduce them by beta-reduction but you can only with eeta -reduction? Do you know any examples?
11:33:51 <vixey> sam__: what
11:34:27 <vixey> sam__: typed?
11:34:38 <Saizan> mathijs: right
11:34:48 <sam__> vixey: I have a problem to find a formula which cannot be reduced by beta-reduction but it can be reduced by eeta-reduction
11:35:02 <vixey> sam__: so look at the rules for eta reduction
11:35:04 <Heooo> mrd: sorry I meant these: "\x. x \y. x" and "(\x. x) (\y. x)". Are they equivalent?
11:35:11 <vixey> sam__: can that term be beta reduced?
11:35:24 <sam__> vixey: exactly
11:35:39 <vixey> :t \x -> x \y -> x
11:35:40 <lambdabot> parse error on input `\'
11:35:40 <roconnor> Heooo: \x . x \y . x == \x . (x (\y . x))
11:35:49 <vixey> :t \x -> x (\y -> x)
11:35:50 <lambdabot>     Occurs check: cannot construct the infinite type:
11:35:50 <lambdabot>       t = (t2 -> t) -> t1
11:35:50 <lambdabot>     Probable cause: `x' is applied to too many arguments
11:36:01 <vixey> :t (\x -> x) (\y -> x)
11:36:01 <lambdabot> forall t. t -> Expr
11:36:10 <vixey> ERROR, unbound variable x
11:36:18 <vixey> lambdabot--
11:36:21 <Heooo> roconnor: Thanks for clarification!
11:36:47 <vixey> Heooo, you are aware that's not haskell?
11:37:18 <Badger> heh
11:37:53 <sam__> vixey: What do you mean with ":t" ?
11:37:57 <mathijs> Saizan: ok that sounds nice. I'll try it that way. It's quite hard for me to get using the type system like it should. I'm a bit spoiled/rotted by ruby's metaprogramming stuff (passing Classes around, eval'ing stuff)
11:38:09 <vixey> sam__: Asking lambdabot what the type of that term is
11:38:32 <sam__> lambdabot: :t
11:38:42 <vixey> :t True
11:38:42 <lambdabot> Bool
11:38:45 <vixey> :t not . not
11:38:45 <lambdabot> Bool -> Bool
11:38:55 <Badger> :t omgwtf
11:38:56 <lambdabot> Not in scope: `omgwtf'
11:39:02 <Badger> precisely.
11:39:26 <Saizan> mathijs: i imagine, it's quite different here and there's not really a way to translate between the two systems nicely
11:39:27 <RayNbow> > omgwtf
11:39:28 <lambdabot>   Yes, Haskell's that awesome!
11:39:35 <sam__> vixey:  lambdabot did not answered to the question: it just says that "omgwtf"
11:39:35 <Badger> Lo
11:39:37 <Badger> :o
11:39:48 <vixey> sam__, lol ..
11:40:03 <RayNbow> :t omgwtf
11:40:04 <vixey> @remember <sam__> vixey:  lambdabot did not answered to the question: it just says that "omgwtf"
11:40:04 <lambdabot> I will remember.
11:40:04 <lambdabot> forall a. Sym a
11:40:07 <Badger> :t Maybe
11:40:08 <lambdabot> Not in scope: data constructor `Maybe'
11:40:13 <Badger> d'oh
11:40:22 <RayNbow> :t Just
11:40:25 * Badger has no lambdabot-fu
11:40:25 <lambdabot> forall a. a -> Maybe a
11:40:26 <RayNbow> :k Maybe
11:40:28 <lambdabot> * -> *
11:40:31 <vixey> :k Mu
11:40:32 <lambdabot> (* -> *) -> *
11:40:47 * Badger should probably learn some haskell 
11:41:07 <vixey> Badger, sounds fun :p
11:41:08 <Badger> I just wish somebody would port ogre to it. :P
11:41:17 <sam__> lambdabot: what is :t?
11:41:33 <RayNbow> sam__: lambdabot is a bot
11:41:52 <vixey> Badger, writing bindings to pretty boring (been there in the past) you may be able to automate most of it though, if you end up wanting to do it yoursel/f
11:42:03 <sam__> RayNbow: Yes, I see. But I do not know how can I ask Qs from that bot
11:42:05 <mathijs> Saizan: well I came to haskell because I (by myself) was using functional-like techniques a lot in ruby, passing lambda's and using 'pure' functions without by-products. I only later discovered this style that I liked was called 'functional programming' and that there were whole languages for it. So I grasp most concepts pretty easily since they feel natural/clean to me. The only thing that is alien to me is the type system, I couldn't emulate o
11:42:06 <Badger> vixey: indeed?
11:42:08 <sbahra> Hi Badger.
11:42:13 <Badger> hello sbahra
11:42:15 <sbahra> Badger, you should write bindings to uname.
11:42:28 <ziman> > let (✕)=replicate in cycle (4✕"badger " ++ 2✕"mushroom ")
11:42:29 <lambdabot>   ["badger ","badger ","badger ","badger ","mushroom ","mushroom ","badger ",...
11:42:32 <Badger> sbahra: I would, but I don't know Haskell.
11:42:32 <ziman> :)
11:42:36 <jmelesky> mathijs: cut off again "I couldn't emulate"
11:42:47 <mathijs> or find a pattern for that in ruby
11:42:48 * Badger whacks ziman with a dolphin.
11:42:48 <vixey> :t (✕)
11:42:49 <lambdabot> Not in scope: `'
11:42:55 <vixey> > 3 ✕ "foo"
11:42:56 <lambdabot>   Not in scope: `✕'
11:43:00 <vixey> :/
11:43:03 <Badger> heh
11:43:11 <sbahra> vixey, let (✕)=replicate
11:43:20 <RayNbow> @let (✕)=replicate
11:43:21 <lambdabot>  Defined.
11:43:23 <mathijs> jmelesky: tnx, maybe I should configure my irc-client to split those up or something :)
11:43:26 <sbahra> > 4 `replicate` "Badger"
11:43:28 <lambdabot>   ["Badger","Badger","Badger","Badger"]
11:43:36 <RayNbow> :t (✕)
11:43:38 <lambdabot> forall a. Int -> a -> [a]
11:43:54 <jmelesky> mathijs: yeah, typeful programming is hard to approach from an untyped background. but it is darn useful.
11:43:54 <sbahra> 4✕2
11:43:57 <sbahra> > 4✕2
11:43:58 <lambdabot>   [2,2,2,2]
11:43:59 <Badger> :t ጷ
11:43:59 <lambdabot> lexical error at character '\4919'
11:44:07 <sbahra> > sum $ 4✕2
11:44:07 <lambdabot>   8
11:44:11 <jpcooper> Badger, what is that character?
11:44:13 <sbahra> > sum $ 8✕8
11:44:14 <lambdabot>   64
11:44:21 <Badger> jpcooper: unicode 1337 :P
11:44:27 <sam__> vixey: Lambdab. says to mean that ":t" means that "forall a. Int -> a -> [a]" Is that right?
11:44:49 <vixey> sam__, try ":t True" and ":t \x -> x"
11:45:07 <sam__> lambdabot: :t True" and ":t \x -> x
11:45:16 <RayNbow> sam__: without lambdabot
11:45:24 <RayNbow> :t True
11:45:24 <vixey> sam__, only each bit in quotes
11:45:25 <lambdabot> Bool
11:45:30 <Badger> :t \x -> x
11:45:31 <lambdabot> forall t. t -> t
11:45:50 <mathijs> jmelesky: well, I get the feeling it IS very good, I just think it's strange that types themselves aren't objects/values that can be passed around too.
11:46:10 <Badger> the topic's Haskell is broken. :(
11:46:13 <sam__> lambdabot ":t True" and ":t \x -> x"
11:46:27 <vixey> mathjis, why would you pass them around?
11:46:45 <jmelesky> mathijs: well, they can be passed around, but not to functions. you can pass them to type constructors to create more complex types
11:46:56 <sam__> lambdabot: ':t True' and ':t \x -> x'
11:47:16 <mathijs> vixey: don't know, as in my earlier question, to tell a parse function stuff about how to parse a string, but the solution given was a lot nicer.
11:47:54 <jmelesky> vixey: one common case is hooks and callbacks, particularly for UI tasks
11:48:10 <vixey> jmesesky, what ??
11:49:06 <sam__> vixey:  Is there some question limit on lambda bot? It does not answer to my Qs anymore.
11:49:13 <jmelesky> vixey: oh, wait, i brain farted and was thinking functions, not types
11:49:19 <sbahra> Types are not passed around in those cases though.
11:49:20 <Badger> :t Just
11:49:21 <lambdabot> forall a. a -> Maybe a
11:49:25 <sbahra> nod
11:49:38 <vixey> sam__: You are doing it wrong
11:49:50 <vixey> sam__: try: ":t True"
11:50:07 <sam__> lambdabot: ":t True"
11:50:11 <vixey> sam__: There is no limit
11:50:15 <mathijs> without the lambdabot:
11:50:18 <mathijs> just
11:50:19 <vixey> sam__: no.. just ":t True"
11:50:22 <mathijs> :t True
11:50:23 <lambdabot> Bool
11:50:32 <sam__> lambdabot: :t True
11:50:38 <sam__> :t True
11:50:39 <lambdabot> Bool
11:50:42 <vixey> yes!
11:50:47 * mathijs applouds
11:50:50 * Badger headdesks
11:51:01 <vixey> :))
11:51:02 <jmelesky> mathijs: is that louder than applauding?
11:51:02 <sam__> Did you notice that It says to me bool?
11:51:10 <vixey> yes I noticed that
11:51:11 <mathijs> jmelesky: hahaha
11:51:24 <vixey> sam__: You can ask about any haskell code -- :t map not
11:51:27 <mathijs> no, just non-mastery of english on my side :P
11:51:27 <BMeph_> sam__: Did you notice that she says back to you, "Bool"? :)
11:52:13 <sam__> vixey: Does bool mean boolean here?
11:52:19 <vixey> yes
11:52:35 <sam__> :t False
11:52:36 <lambdabot> Bool
11:52:41 <jmelesky> mathijs: didn't realize you weren't a native speaker, which presumably speaks well about your fluency
11:53:01 <sam__> :t false
11:53:02 <lambdabot> Not in scope: `false'
11:53:11 <dobblego> > "false" == "False"
11:53:12 <Badger> Caps!
11:53:12 <lambdabot>   False
11:53:12 <sam__> :t eeta
11:53:13 <vixey> sam__: It must be False
11:53:13 <mathijs> how about replicate 4000 "I'm annoying" ?
11:53:13 <lambdabot> Not in scope: `eeta'
11:53:26 <sam__> Yes, I agree with you
11:53:28 <Badger> :t x
11:53:30 <lambdabot> Expr
11:53:30 <Badger> er
11:53:34 <sam__> :t x
11:53:35 <lambdabot> Expr
11:53:43 <sam__> :t beta
11:53:44 <lambdabot> Not in scope: `beta'
11:53:45 <vixey> this 'x' stuff shouldn't be in :t tmo
11:53:47 <vixey> imo
11:53:49 <sam__> :a alpha
11:53:56 <sam__> :t alpha
11:53:57 <Badger> :t ✕
11:53:57 <lambdabot> Not in scope: `alpha'
11:53:58 <lambdabot> parse error on input `'
11:54:08 <sam__> :t reduced
11:54:08 <lambdabot> Not in scope: `reduced'
11:54:11 <Badger> ah, so the brackets are mandatory
11:54:17 <jmelesky> :t \x -> x * x
11:54:18 <lambdabot> forall a. (Num a) => a -> a
11:54:39 <Badger> > 4 ✕ 4
11:54:39 <lambdabot>   [4,4,4,4]
11:54:43 <sam__> :t \x -> x (\y -> x)
11:54:44 <lambdabot>     Occurs check: cannot construct the infinite type:
11:54:44 <lambdabot>       t = (t2 -> t) -> t1
11:54:44 <lambdabot>     Probable cause: `x' is applied to too many arguments
11:54:52 <Peaker> :t x
11:54:54 <lambdabot> Expr
11:55:08 <Peaker> :t ✕
11:55:09 <mathijs> [1..]
11:55:10 <lambdabot> parse error on input `'
11:55:11 <sam__> :t \a(\x.x \a.x)y
11:55:13 <lambdabot> parse error on input `.'
11:55:21 <Badger> mathijs: heh
11:55:38 <sam__> :t (λx y. x (x y)) (λa b. a (a b)) (λc d e. d)
11:55:39 <lambdabot> Not in scope: `x'
11:55:39 <lambdabot> Not in scope: `a'
11:55:39 <lambdabot> Not in scope: `c'
11:55:40 <Badger> I wonder if you can feed that to her
11:55:58 <sam__> Just tried :)
11:56:02 <vixey> :t (\x y -> x (x y)) (\a b -> a (a b)) (\c d e -> d)
11:56:03 <lambdabot> forall t t1. (t -> t1 -> t) -> t -> t1 -> t
11:56:06 <vixey> sam__: It works ^
11:56:15 <vixey> you just have to use \ instead of lambda and -> instead of .
11:56:17 <sam__> :)
11:57:16 <Badger> :t \a
11:57:18 <lambdabot> parse error (possibly incorrect indentation)
11:57:56 <Peaker> Are ByteStrings mutable? If not, why does   copy :: ByteString -> ByteString   exist?
11:57:56 <sam__> vixey: Is the formula which lambdab gave you reduced form?
11:58:20 <vixey> sam__: No, it's the type inferred by hindly milner algorithm
11:58:26 <bbs> does xcode has a haskell extention?
11:58:27 <yitz> :t (✕)
11:58:28 <lambdabot> forall a. Int -> a -> [a]
11:58:30 <rwbarton> sam__: It's not a formula at all
11:58:44 <pozic> Why does the Haskell community recommend a separation of generate and select, while the compilers are not smart enough to see that some generated values will never be selected?
11:58:52 <sam__> rwbarton: statement?
11:59:01 <rwbarton> sam__: it's a type like vixey said
11:59:01 <jmelesky> bbs: i think there are a couple, but last i checked they were all stagnant
11:59:20 <sam__> rwbarton: ok. A type. Thanks for clarification
11:59:28 <bbs> jmelesky: meh ok
11:59:29 <bbs> thx
11:59:35 <Peaker> pozic: maybe optional strictness is easier than optional laziness
11:59:55 <sam__> :t \x -> x (\y -> x)
11:59:56 <lambdabot>     Occurs check: cannot construct the infinite type:
11:59:56 <lambdabot>       t = (t2 -> t) -> t1
11:59:56 <lambdabot>     Probable cause: `x' is applied to too many arguments
12:00:23 <dolio> Peaker: Did you read the documentation for that function?
12:00:30 <rwbarton> sam__: as you've discovered :) not every term in the untyped lambda calculus can be given a type
12:00:41 <Peaker> dolio: I now have, silly me ;)
12:00:45 <dolio> :)
12:01:00 <Peaker> ByteStrings are riddles with implementation details..
12:01:04 <Peaker> riddled, that is
12:01:19 <jmelesky> rwbarton: can't be given a type, or can't have a type inferred?
12:01:30 <mc__> I discovered something strange: "filter even [1,3..n]" is faster than "[1,3..n]" and "filter even [2..n]"
12:01:40 <rwbarton> jmelesky: Can't be given a type (without allowing recursive/infinite types).
12:01:51 <Peaker> what's a good way to build a ByteString one Word8 at a time? unfoldr?
12:01:58 <jmelesky> rwbarton: cool. thanks for the clarification.
12:02:20 <mc__> does that make any sense to anyone?
12:02:35 <roconnor> pozic: what is the altenative you are suggesting?
12:03:03 <roconnor> pozic: typically you cant know you don't want to generated something until you generated it and test it.
12:03:19 <dolio> Peaker: Probably, if your function is expressible that way.
12:03:52 <Peaker> dolio: It feels like unfold in general is sort of clumsy.. Haven't used it much yet, though
12:03:58 <dolio> Using unfoldr is likely to have fusion kick in (if possible) to never actually allocate a bytestring at all.
12:04:07 <vixey> Peaker: no it's not clumsy at all
12:04:12 <rwbarton> jmelesky: In fact the simply typed lambda calculus is strongly normalizing--all terms reduce to a value--so in a sense it's quite a small "subset" of the untyped lambda calculus
12:04:16 <vixey> (at least when it makes sense)
12:04:27 <Peaker> dolio: cool
12:04:53 <vixey> rwbarton, do you know any fun proofs of that? I think I've come across 3
12:05:16 <rwbarton> vixey: No
12:05:21 <Peaker> vixey: Ok, I'll give it a shot, and see how it ends up
12:05:36 <vixey> Peaker, I mostly only use unfoldr when I am inverting a foldr though
12:05:47 <vixey> Peaker, It probably _is_ awkward if you don't have a fold in mind
12:06:32 <Peaker> vixey: I want to translate a number to a little-endian ByteString of arbitrary size (Put has functions for some fixed sizes only). I guess I'll just do it in Put
12:06:48 <dolio> Just think in terms of coalgebra homomorphisms and it'll all become clear.
12:07:17 <pozic> roconnor: If I push some conditions downwards (e.g. never generate some lists), I know it will be faster. Since compilers that can do this will forever be too slow, there's little point of developing it in this way.
12:07:20 <vixey> yeah :p
12:07:25 <Peaker> dolio: are you kidding? :)
12:07:35 <rwbarton> pozic: program in assembly language.  problem solved.
12:07:49 <dolio> Well, a little. Coalgebras are where unfoldr comes from.
12:08:03 <Peaker> pozic: when you get nicer and more abstract denotational semantics, you often get more fuzzy operational semantics
12:08:17 <vixey> Peaker: not true.
12:08:29 <roconnor> pozic: I don't understand.  with laziness you will never generate those list if you never demand them.
12:08:42 <Peaker> vixey: why not? There's a lot of freedom about how to implement the semantics
12:09:15 <vixey> There is no correlation like that
12:09:21 <Peaker> vixey: Does Haskell98 for example, explicitly state that "let" behaves like it does in ghc? (caching results)
12:10:00 <dolio> I believe the report does not mandate sharing.
12:10:10 <dolio> So you could implement it as call-by-name.
12:10:24 <Peaker> aren't these fuzzy operational semantics?
12:11:33 <dolio> In fact, people have experimented with even odder operational semantics than that.
12:12:02 <dolio> Someone was once doing 'optimisitic evaluation' or something like that, where you start evaluating things eagerly, but stop after a while if it takes too long.
12:12:13 <therp> is there any reasonable Haskell environment out there?
12:12:27 <therp> haskell-mode for emacs doesn't seem to make any progress
12:12:33 <vixey> what is a haskell environment?
12:12:54 <dolio> I get by with haskell-mode pretty well (with an alternate indentation mode).
12:12:57 <therp> vixey: if you know slime for common lisp, that's pretty much what I have in mind
12:13:03 <dolio> I seem to recall getting by with vim pretty well, too.
12:13:10 <vixey> ok, I don't see slime every working for haskell
12:13:15 <vixey> ever*
12:14:02 <pozic> roconnor: the programs demands it, but only because the compiler doesn't have the logical abilities to see that some values don't ever need to be generated.
12:14:33 <therp> vixey: why not? at least getting to the definition of stuff should be useful and implementable
12:15:02 <therp> has anyone tried shim? superior haskell interaction mode?
12:15:05 <Peaker> pozic: I think you're not referring to generation, but to the thunk buildup prior to generation?
12:15:06 <vixey> oh you could do that
12:15:12 <vixey> that would be pretty useful
12:15:57 <mathijs> therp: haskell-mode has the imenu-menubar-index thingy for getting to the definition of things, I can't get that to load with emacs startup though so I have to manually activate it
12:16:17 <roconnor> pozic: that doesn't make any sense to me.
12:16:39 <therp> mathijs: can you give me a reference for that?
12:16:46 <roconnor> pozic: how can your program eman it it never needs to be generated
12:16:54 <roconnor> demand it
12:17:13 <pozic> roconnor: algebraic identities
12:17:27 <roconnor> ah
12:17:31 <mathijs> therp: I don't know if it's correct or anything, just got it from someone in here... put this in your .emacs:
12:17:33 <roconnor> use RULES pragmas
12:17:38 <mathijs> (add-hook 'haskell-mode-hook (lambda () (haskell-indentation-mode) (imenu-add-menubar-index) (define-key haskell-mode-map (kbd "A-r") 'inferior-haskell-load-file)
12:17:41 <mathijs> ))
12:18:24 <mathijs> then when in haskell-mode do alt-x menu-add-menubar-index
12:18:53 <mathijs> then your imenu has indexes for variables and definitions... I don't know why I have to do that manually, but it works
12:19:22 <therp> mathijs: I was rather thinking of something that works across source files and even packages
12:19:46 <therp> unless there is some magic in there I can't see, I think that this imenu thing won't provide me with that
12:20:19 <mathijs> therp: I don't think there is
12:21:34 <mmorrow> preflex: seen quicksilver
12:21:34 <preflex>  quicksilver was last seen on #haskell 3 hours, 2 minutes and 24 seconds ago, saying: jpcooper: so this overloaded return is using the basic mechanism of haskell typeclasses.
12:26:35 <mmorrow> i just updated my javascript QuasiQuoter for 6.10 and put the darcs repo in this dir, along with a darcs repo for a slightly modified WebBits package and a misc sample of the quoter being used
12:26:42 <mmorrow> http://moonpatio.com/repos/js-qq/
12:26:47 <lambdabot> Title: Index of /repos/js-qq
12:26:51 <mmorrow> both darcs repos have haddock docs too
12:27:00 <mmorrow> and here's the sample: http://moonpatio.com/repos/js-qq/WebUi.hs.html
12:27:01 <lambdabot> Title: Haskell code
12:27:46 <whoppix> hello people. I'm relatively new to haskell, and i would like to know what the term "binding to a variable" means - Is it just the same as asserting a value to a variable, or is there a subtle difference? (example: foobar <- getLine)
12:28:21 <Cale> whoppix: foobar <- getLine  just means to run the action getLine, and call its result foobar
12:28:50 <Cale> whoppix: Note that this is somewhat different from an assignment statement in an imperative language.
12:28:51 <whoppix> hm, ok.
12:29:00 <whoppix> Cale, how exactly so?
12:29:10 <mauke> there's no box
12:29:23 <Cale> whoppix: An assignment statement in an imperative language means to replace the value stored in a given mutable cell with a different value.
12:29:50 <whoppix> ok, i see.
12:29:59 <Cale> For example, in something like x := getLine in our imaginary imperative language, x is the name of a box which contains a value
12:30:05 <BONUS> here, we run the action and sort of put a nametag on its result
12:30:10 <Cale> and we run getLine, and replace the value in that box with a new one
12:31:06 <whoppix> i see, i see. Thanks a bunch.
12:31:19 <rwbarton> "binding to a variable" can also mean a binding made by let or where, like  let x = 3 in {- x is bound to 3 here -} x * x
12:31:55 <Cale> In Haskell, variables are always the names of values, and not the names of mutable cells which in turn hold values. (Except when the value is itself a mutable cell, but that's just confusing :)
12:32:06 <mauke> in perl, 'my $x;' creates a new mutable cell and binds the name '$x' to it
12:32:30 <whoppix> ok, so i guess variables "declared" with "let" are not mutable either?
12:32:36 <Cale> whoppix: right.
12:32:43 <BONUS> so yeah, don't think of it as a box, think of it as slapping a sticker with a name on it
12:32:43 <mauke> variables are just named constants
12:32:55 <earthy> whoa, mauke, algol68 flashback there
12:32:59 <BONUS> you can slap several stickers on a value but you can't take them off
12:33:00 <Cale> Not always... think about the variables which are the parameters of functions.
12:33:01 <jpcooper> well they're not really variables
12:33:10 <Cale> They are really variables!
12:33:25 <Cale> f x = x + 1
12:33:28 <jpcooper> can they vary?
12:33:36 <Cale> Here, x will vary over the course of the program.
12:33:51 <Cale> Because f might be called many times with different values for x
12:34:01 <jpcooper> I would have called that a parameter
12:34:14 <Cale> But it is a variable.
12:34:18 <jpcooper> okay
12:34:24 <Cale> (as well as being the parameter to the function f)
12:34:57 <Cale> Moreover, the values of variables defined in let or where can depend on the values of parameters to a function.
12:35:03 <Cale> So they can vary as well.
12:35:12 <whoppix> Do you guys think "a gentle introduction to haskell" is a good start?
12:35:15 <Cale> It's just that they remain the same so long as they are in scope.
12:35:25 <Cale> whoppix: It's anything but gentle.
12:35:31 <whoppix> I don't have a lot of functional programming experience, but i think i grasped some of the basics now.
12:35:32 <Vq^> whoppix: it probably isn't
12:35:46 <mauke> a "gentle" introduction to haskell
12:35:47 <Cale> whoppix: It's not bad if you're already familiar with say, ML.
12:35:56 <whoppix> I'm not :)
12:36:07 <Vq^> whoppix: then there are better tutorials
12:36:13 <Cale> whoppix: Try BONUS's new tutorial:
12:36:16 <Cale> @where LYAH
12:36:16 <lambdabot> www.learnyouahaskell.com
12:36:26 <RayNbow> whoppix, http://arcanux.org/lambdacats/gentle-intro.jpg
12:36:44 <vixey> hhe
12:36:54 <whoppix> hehe
12:37:01 <whoppix> Cale, I like the artworks.
12:37:02 <Cale> There's also Real World Haskell which is a complete book available online.
12:37:06 <Cale> I do too :)
12:37:12 <Cale> @where rwh
12:37:13 <lambdabot> is http://www.realworldhaskell.org/blog/
12:37:16 <Cale> @where rwh-book
12:37:16 <lambdabot> I know nothing about rwh-book.
12:37:23 <Cale> @where realworldhaskell
12:37:24 <lambdabot> http://www.realworldhaskell.org/
12:37:27 <Cale> blah
12:37:37 <Cale> http://www.realworldhaskell.org/read/
12:37:42 <jeffersonheard> Cale: it's just /book
12:37:49 <jeffersonheard> I thought
12:37:53 <jeffersonheard> n/m
12:38:05 <whoppix> Ok, well, thanks a bunch, i'll starting by working through that tutorial.
12:38:09 <Cale> http://book.realworldhaskell.org/read/
12:38:10 <lambdabot> Title: Real World Haskell
12:38:13 <Cale> finally :)
12:38:17 <mauke> preflex: . rwh
12:38:17 <preflex>  factoid not found
12:38:24 <mauke> preflex: store rwh http://book.realworldhaskell.org/
12:38:24 <lambdabot> Title: Real World Haskell
12:38:43 <Cale> whoppix: There's also the wikibook and "Yet Another Haskell Tutorial"
12:38:53 <whoppix> oh, nice, that book is even for free.
12:38:57 <Cale> whoppix: yeah
12:39:26 <Cale> whoppix: If you're looking for a nice paper book, Graham Hutton's book is really nice for beginners.
12:39:50 <whoppix> nah, reading on my laptop is just fine.
12:40:18 <Vq^> then i would recomend beginning with "learn you a haskell"
12:40:25 <jpcooper> would you really?
12:40:53 <jpcooper> I don't understand why a Haskell tutorial has to be written in such an asinine way
12:40:57 <whoppix> now ill just need some better IDE.
12:41:13 <jpcooper> I mean wasn't the first time with Ruby enough?
12:41:20 <Vq^> jpcooper: it doesn't
12:41:34 <mauke> what's asinine about it?
12:41:49 <Vq^> if the wikibook was more complete i'd probably recomend it
12:41:53 <jpcooper> it seems like a step too far to show that yes ,Haskell can be used by "normal" people
12:42:01 <Vq^> but learnyouahaskell is actually quite good
12:42:03 <jpcooper> mauke, have you looked at the bloody thing?
12:42:07 <mauke> yes
12:42:17 <jpcooper> even the title suggests its content
12:42:24 <mauke> no, it doesn't
12:42:26 <jpcooper> or lack of
12:42:44 <mauke> the only silly part of the tutorial is its title
12:43:06 <Vq^> yeah, the tutorial in itself is quite serious
12:43:19 <mmorrow> i just changed the js-qq license LGPL -> BSD3 since there isn't any WebBits code in it anymore
12:43:48 <mmorrow> (fyi :)
12:44:24 <osfameron> the title learnyouahaskell does seem to channel the pretentious guide to ruby.  I was relieved it looks like it's actually about haskell
12:45:16 <jpcooper> right
12:45:59 <jpcooper> pardon my rant, then
12:46:20 <mauke> so ... have YOU looked at the bloody thing?
12:46:38 <Peaker> jpcooper: its more fun to read that way
12:46:41 <jpcooper> yes, I had a quick look
12:46:44 <Vq^> mauke: maybe he has looked on the pretty pictures :o)
12:47:05 <jpcooper> I stopped when I saw that Kermit the Frog was claimed to be a list comprehension
12:47:29 <unenough> jpcooper, I liked that
12:47:31 <jpcooper> what a corruption of a childhood figure!
12:47:32 <Vq^> well, i wont argue that the pictures are a bit silly
12:47:53 <jpcooper> I mean, I'll never be able to watch Kermit in the same way
12:48:01 <Peaker> jpcooper: the pictures make the text feel less "monotonic" and the whole thing more fun
12:48:10 <jeffersonheard> nono.  you will never comprehend Kermit in the same way
12:48:20 <dolio> You should watch Kermit sing Hurt. :)
12:48:45 <Valodim_> ..what the hell
12:48:48 <mauke> S = { 2·x | x ∈ N, x ≤ 10 } balances that impression somewhat
12:49:01 <Valodim_> now that is.. a fresh take on things
12:50:29 <Gabbie> I like learnyouahaskell.
12:50:33 <mauke> does anyone know what the |N symbol is called in unicode?
12:50:54 <jpcooper> mauke, the natural numbers one?
12:50:59 <mauke> yeah
12:51:06 <osfameron> dolio: best cover ever!
12:51:17 <dolio> :)
12:51:21 <Valodim_> ℕ that one?
12:51:38 <mauke> DOUBLE-STRUCK CAPITAL N, thanks!
12:51:39 <jpcooper> http://tlt.its.psu.edu/suggestions/international/bylanguage/mathchart.html
12:51:39 <Valodim_> wait did it show that? I don't know my irc font doesn't have it :P
12:51:45 <lambdabot> Title: Math Unicode Entities, http://tinyurl.com/6zmll5
12:51:53 <mauke> Valodim_: yes
12:52:20 <mauke> ℵƒ′
12:52:22 <mauke> awesome
12:52:42 <vixey> 𝕃𝕆𝕃
12:53:11 <mauke> U+2135 (e2 84 b5): ALEF SYMBOL [ℵ]; U+0192 (c6 92): LATIN SMALL LETTER F WITH HOOK [ƒ]; U+2032 (e2 80 b2): PRIME [′]
12:53:33 <Peaker> א
12:53:41 <Peaker> Are these 2 different aleph's?
12:53:46 <mauke> U+05D0 (d7 90): HEBREW LETTER ALEF [א]
12:53:53 <mauke> apparently
12:54:02 <osfameron> I want something like dmenu for entering unicode characters!
12:54:35 <mauke> I have an irssi script to get unicode characters by name
12:54:35 <jpcooper> it's funny that the "RIGHT TRIANGLE" character comes up as a Chinese character for me
12:54:42 <jpcooper> at least on that page
12:55:11 <mauke> unfortunately it requires a core patch to work
12:55:19 <osfameron> mauke: I'd like it generically for terminal (i.e. instead of having to remember compose incantations)
12:55:30 <mauke> hmm, yeah
12:55:39 <Peaker> are any other Hebrew letters except Aleph used in math?
12:55:50 <lucca> ò_ó
12:57:42 <Valodim_> "Maximum Awesome", now that is a great chapter title :)
12:58:39 <rwbarton> Peaker: I think set theorists sometimes use Beth and occasionally Gimel too
12:58:43 <lekro> Peaker: Beth is used to denote the cardinality of the power set, i.e. Beth_{n+1} := 2^{Beth_n}
12:59:01 <lekro> and Beth_0 = Aleph_0 IIRC
12:59:11 <Peaker> ah, cool
12:59:15 <vixey> I though Beth_0 and Aleph_0 were different
12:59:54 <dons> ?users
12:59:55 <lambdabot> Maximum users seen in #haskell: 536, currently: 528 (98.5%), active: 33 (6.3%)
13:04:45 <mmorrow> , "ℕ"
13:04:55 <lunabot>  "\8469"
13:04:55 <mmorrow> , utf8enc "ℕ"
13:04:57 <lunabot>  "\226\132\149"
13:06:16 <mmorrow> , toUTF8 (take 10 ['ℵ'..])
13:06:18 <lunabot>  ℵℶℷℸℹ℺℻ℼℽℾ
13:06:23 <Badger> heh
13:06:25 <mmorrow> bah
13:07:00 <yitz> , "ℵ"
13:07:03 <lunabot>  "\8501"
13:07:07 <mmorrow> , toUTF8 (take 10 ['א'..])
13:07:09 <lunabot>  אבגדהוזחטי
13:07:12 <mmorrow> heh
13:07:19 <mmorrow> it's right to left
13:07:29 <mmorrow> , toUTF8 (take 20 ['א'..])
13:07:31 <lunabot>  אבגדהוזחטיךכלםמןנסעף
13:07:35 <yitz> mmorrow - depends on rtl support of your irc client
13:07:41 <mmorrow> how many other people
13:07:42 <mmorrow> ah
13:07:54 <mmorrow> i'm using xchat
13:08:04 <yitz> but the unicode of ℵ is supposed to be 0x05d0
13:08:13 <yitz> > 0x5d0
13:08:15 <lambdabot>   1488
13:08:21 <mmorrow> , '\1488'
13:08:22 <lunabot>  '\1488'
13:08:30 <mmorrow> , toUTF8 "\1488"
13:08:32 <lunabot>  א
13:08:43 <mmorrow> there are two alephs
13:08:52 <SamB> only two?
13:08:53 <SamB> that's pathetic
13:08:53 <mmorrow> , toUTF8 "\1488ℵ"
13:08:55 <lunabot>  אℵ
13:09:03 <SamB> there are a gazillion Rs, aren't there ?
13:09:07 <mmorrow> well, at least two ;)
13:11:43 <vixey> , map toUTF8 "\0332"
13:11:46 <lunabot>  luna: Couldn't match expected type `[GHC.Types.Char]'
13:11:59 <vixey> , toUTF8 [\0332..]
13:12:00 <lunabot>  luna: parse error on input `..'
13:12:20 <vixey> , (toUTF8 .  map chr . const [0332..]) ()
13:12:25 <lunabot>  luna: Prelude.chr: bad argument
13:12:25 <mmorrow> , toUTF8 ['♔'..'♟']
13:12:26 <lunabot>  ♔♕♖♗♘♙♚♛♜♝♞♟
13:12:43 <mmorrow> , chr 332
13:12:45 <lunabot>  '\332'
13:13:01 <vixey> mmorrow, I just hooked AI up to mychess game in neutron the other day but iI overwrote it with an  OS instal :/
13:13:27 <mmorrow> cool... and not so cool :)
13:13:35 <mmorrow> vixey,
13:13:46 <mmorrow> what sort of AI?
13:13:55 <vixey> just some chess player I found online
13:14:25 <mmorrow> nice, i can't wait until i can play
13:14:35 <vixey> ;/
13:14:41 <vixey> I don't want to rewrite it all
13:15:09 <mmorrow> i'm gonna be adding some stuff to neutron over the next week, i'll put a repo up
13:15:10 <vixey> even though it was only about a page long
13:15:14 <mmorrow> heh
13:15:15 <vixey> oh gool
13:15:19 <vixey> good*
13:17:18 <yitz> , toUTF8 "abcd"
13:17:20 <lunabot>  abcd
13:17:21 <mmorrow> i want to s/String/ByteString/, make a simple+clean interface to just (eg) pass in a function in ghci/wherever and be able to interact via a browser, and integrate some luna eval i'm-not-quite-sure-how-yet into it too
13:17:36 <yitz> , toUTF8 "> 42"
13:17:38 <lunabot>  > 42
13:17:45 <mmorrow> , utf8enc "> 42"
13:17:47 <lunabot>  "> 42"
13:17:55 <vixey> oh that would great
13:17:57 <mmorrow> , utf8enc "> 4\7283"
13:17:59 <yitz> good work mmorrow
13:17:59 <lunabot>  "> 4\225\177\179"
13:18:07 <mmorrow> :)
13:18:47 <dolio> What is toUTF8? Some kind of pretty printer combinator?
13:18:57 <mmorrow> it just does
13:19:03 <mmorrow> newtype UTF8 = UTF8 String
13:19:05 <yitz> lunabot toUTF8 "abcd"
13:19:05 <mmorrow> then
13:19:07 <dolio> Ah.
13:19:19 <mmorrow> instance Show UTF8 where show (UTF8 s) = s
13:19:25 <vixey> hey dolio, you know how data types are defined categorically .. is there an analogue for dependent types?
13:19:27 <dolio> Okay.
13:19:41 <nha_> what can i use to copy mem from two Ptrs?
13:19:48 <dolio> vixey: I've got some papers on that, but I've never managed to get through them.
13:20:00 <dons> nha_: memcpy ?
13:20:12 <nha_> do i have to ffi it?
13:20:24 <dons> there are functions in Foreign.* to do this
13:20:28 <nha_> thanks
13:20:31 <dons> or look at Data.ByteString for a good interface
13:20:59 <jsn> wow, it's surprising to me that Data.Binary serializes a ByteString with a type tag
13:21:00 <mmorrow> copyBytes :: forall a. Ptr a -> Ptr a -> Int -> IO ()
13:21:00 <mmorrow>         -- Defined in Foreign.Marshal.Utils
13:21:13 <mmorrow> moveBytes :: forall a. Ptr a -> Ptr a -> Int -> IO ()
13:21:22 <nha_> nice haha
13:21:39 <vixey> dolio, so what should I look up?
13:21:52 <dolio> vixey: Look for stuff by Peter Dybjer, I guess. Internal Type Theory is one I have.
13:22:45 <dolio> But some of that stuff jumps right into 'categories with families' which kind of gets explained by families of sets and stuff, which I don't have a lot of experience with.
13:22:56 <rwbarton> vixey: I saw a paper that represented a family of types indexed by a type B as a map A -> B
13:23:32 <rwbarton> vixey: for an value b of type B, the corresponding type A_b is the fiber of A over b (all the elements of A that get sent to b)
13:23:34 <vixey> rwbarton, huh ? the arrow shouldn't be the other way around?
13:23:40 <rwbarton> vixey: no
13:24:11 <rwbarton> vixey: this is sometimes called the Grothendieck construction, but really it's just like a bundle
13:24:53 <dolio> Yeah. Fibred category theory is another thing I've seen, but I've only found it in an introduction to some larger work that ddarius pointed someone to a while ago.
13:24:55 <mmorrow> rwbarton: link?
13:25:16 <vixey> oh
13:25:20 <rwbarton> mmorrow: Sorry, this is just from memory, but it might have been that same paper dolio mentioned (the title sounds familiar)
13:25:21 <vixey> Grothendieck keeps coming up in this stuff it's really interesting
13:25:45 * mmorrow searches
13:26:08 <dolio> http://lambda-the-ultimate.org/node/1299
13:26:15 <lambdabot> Title: Type theory question... | Lambda the Ultimate
13:26:20 <dolio> See the link to the prospectus he gives there.
13:26:55 <dolio> But if you want the book, you have to order it from the publisher.
13:27:19 <mmorrow> this looks neat http://www.cs.man.ac.uk/~david/categories/book/book.pdf
13:27:29 <lambdabot> Title: Computational Category Theory
13:29:26 <mmorrow> this one looks /really/ interesting, but i guess it's not finished yet (i don't see a link to the paper)  http://portal.acm.org/citation.cfm?id=1340804
13:29:35 <lambdabot> Title: Towards Formalizing Categorical Models of Type Theory in Type Theory
13:29:51 <dolio> I have that paper.
13:30:15 <dolio> It's, like, a followup to that other paper, Internal Type Theory.
13:31:22 <vixey> I'm trying to understand where these universes come up (it seems like you can't define them in type theory without induction recursion)
13:32:09 <mmorrow> dolio: you have it? where'd you get it from?
13:32:26 <dolio> Probably from Peter Dybjer's homepage.
13:33:05 <mmorrow> hah, i didn't even notice the author
13:34:20 <rwbarton> mmorrow: FWIW, the paper I had read was this one: http://arxiv.org/abs/0709.0248
13:34:21 <mmorrow> http://www.cs.chalmers.se/~peterd/papers/Bremen2007.pdf
13:34:38 <rwbarton> Non-topologists will probably be as mystified by the homotopy theory as I was by the type theory
13:34:40 <vixey> http://www.cs.chalmers.se/~peterd/papers/inductive.html
13:34:40 <lambdabot> Title: cache:http://www.cs.chalmers.se/~peterd/papers/Bremen2007.pdf - Google Search
13:34:47 <mmorrow> rwbarton: sweet, thanks
13:34:49 <jeffersonheard> grar.  it's been too flustering a day.  lot going on here...  I need a function lambda such that lambda 3 3 -> [(0,3),(0,2),(0,1),(0,0),(1,3)...(3,3)]...  efficient, because this is used in an inner loop
13:35:15 * SamB wonders what package provides -lGL
13:35:33 <b_jonas> did you find a useful mdo one-liner?
13:35:52 <b_jonas> I think that was what you discussed last night (apart from ghc 5.10 stable release)
13:36:00 <rwbarton> SamB: apt-file search libGL.so suggests... there are several :)
13:36:25 <SamB> which package provides apt-file ?
13:36:27 <rwbarton> SamB: I'm guessing you want libgl1-mesa-dev though.
13:36:33 <b_jonas> wait, this channel is logged, I'll look it up
13:36:35 <rwbarton> SamB: apt-file
13:37:28 <vixey> , [$i|  (,) [0..3] [0..3] |]
13:37:35 <jeffersonheard> SamB, libGL will be provided by your video card drivers, most likely
13:37:37 <lunabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),...
13:37:48 <jeffersonheard> installing the nvidia driver (assuming that's what you have) should give you a usable GL
13:37:51 <vixey> , [$i| (,) [0..3] (reverse [0..3]) |]
13:37:56 <lunabot>  [(0,3),(0,2),(0,1),(0,0),(1,3),(1,2),(1,1),(1,0),(2,3),(2,2),(2,1),(2,0),...
13:38:03 <SamB> jeffersonheard: I want the thing that makes ld happy, not the actual library ;-)
13:38:27 <b_jonas> what's that?
13:38:43 <vixey> $i ?
13:38:51 <vixey> b_jonas, are you asking about $i?
13:39:07 <b_jonas> yeah
13:39:08 <dolio> , let zipWith f ((f -> g) : (zipWith f -> h)) ((g -> c) : (h -> cs)) = c : cs in zipWith (+) [1..5] [6..10]
13:39:11 <lunabot>  luna: <interactive>:1:54-124: Non-exhaustive patterns in function zipWith
13:39:27 <vixey> b_jonas, it's idiom brackets.. it changes f x y z into f <$> x <*> y <*> z
13:39:50 <dolio> , let zipWith f ((f -> g) : (zipWith f -> h)) ((g -> c) : (h -> cs)) = c : cs ; zipWith _ _ = [] in zipWith (+) [1..5] [6..10]
13:39:52 <lunabot>  luna: Equations for `zipWith' have different numbers of arguments
13:39:59 <dolio> , let zipWith f ((f -> g) : (zipWith f -> h)) ((g -> c) : (h -> cs)) = c : cs ; zipWith _ _ _ = [] in zipWith (+) [1..5] [6..10]
13:40:00 <b_jonas> thanks
13:40:01 <lunabot>  [7,9,11,13,15]
13:40:07 <dolio> Woo!
13:40:08 <rwbarton> dolio: ow ow ow
13:40:22 <b_jonas> can't that be done with a function, like something4 f x y z ?
13:40:25 <lucca> , toUTF8 $ ['\x20d0'..'\x20ef'] ++ "o"
13:40:27 <lunabot>  ⃒⃓⃘⃙⃚⃐⃑⃔⃕⃖⃗⃛⃜⃝⃞⃟⃠⃡⃢⃣⃤⃥⃦⃪⃫⃨⃬⃭⃮⃯⃧⃩o
13:40:35 <jeffersonheard> SamB, what kind of linker error are you getting?
13:40:44 <vixey> , let zipWith f yoo@((f -> g) : (zipWith f -> h)) ((g -> c) : (h -> cs)) = yoo ; zipWith _ _ _ = [] in zipWith (+) [1..5] [6..10]
13:40:45 <b_jonas> do you need the template only so it can have any number of expressions?
13:40:46 <lunabot>  [1,2,3,4,5]
13:40:52 <jeffersonheard> you may just have to put a -L/usr/lib/... at the end of your ghc
13:40:59 <SamB> /usr/bin/ld: cannot find -lGL
13:41:03 <vixey> hmmm
13:41:14 <SamB> I never said I was using GHC ...
13:41:20 <vixey> , let q xs@(reverse -> sx) = (sx,xs) in q "foo"
13:41:22 <lunabot>  ("oof","foo")
13:41:25 <vixey> does that make sense?
13:41:32 <vixey> I don't know if that's the right behavior or not
13:41:32 <jeffersonheard> SamB.  ahh.  I assume, because I always use GHC
13:41:57 <vixey> I suppose it's more useful
13:42:04 <SamB> but I figured that didn't make much difference in the answer to the question ;-)
13:43:21 <b_jonas> wow, these are strange syntaxes
13:43:40 <b_jonas> that view pattern, and all this stuff
13:44:56 <saml> on windows ghc, how can I change defcault C:\Program Files\Haskell folder?
13:44:56 <dolio> View patterns let you explode people's brains in entirely new ways!
13:45:13 <saml> vista chokes for permission security enterprise usability awesomeness
13:45:43 * SamB wonders if he should install an nvidia -dev package
13:45:52 <saml> do I have to manually --datadir= ?
13:45:56 <saml> for every project?
13:46:03 <vixey> , let either left right (Left (left -> x)) = x in either
13:46:06 <lunabot>  luna: No instance for (GHC.Show.Show
13:46:24 <vixey> , type [| let either left right (Left (left -> x)) = x in either |]
13:46:25 <lunabot>  luna: parse error on input `type'
13:46:35 <b_jonas> dolio: just wait till we put random types to Num with a really unintuitive (==) operation just so we can use numeric patterns on it as a shortcut to some conditional pattern
13:46:53 <dolio> :)
13:48:30 <b_jonas> I wish haskell patterns just wouldn't pretend that numbers (and characters) are algebraic data. They don't do that for functions.
13:48:53 <rwbarton> Characters aren't algebraic data?
13:49:09 <b_jonas> rwbarton: with 2^32 constructors?
13:49:15 <vixey> deep in the GHC source tree you will find  data Integer = 0 | 1 | 2 | 3 | ...
13:49:16 <rwbarton> Sure, why not?
13:49:23 <mauke> b_jonas: 2^21
13:49:36 <SamB> vixey: you silly jokester!
13:49:41 <vixey> :p
13:49:50 <rwbarton> b_jonas: I definitely see your point about numbers though
13:50:03 <vixey> I don't
13:50:22 <vixey> if 4 isn't a constructor
13:50:27 <vixey> what is 4 made of?
13:50:31 <vixey> it's not S S S S O
13:50:38 <rwbarton> 4 is a weird pattern
13:50:41 <mauke> is it made of lulz?
13:50:42 <rwbarton> it matches anything that == 4
13:50:52 <SamB> vixey: it is made of implementation details!
13:50:53 <vixey> mauke, that is possible, yes
13:50:56 <rwbarton> that's why Num has an Eq superclass
13:51:15 <b_jonas> vixey: think about functions. \x -> x isn't just an algebraic constructor either
13:51:25 <vixey> I do agree that numbers in haskell are awful
13:51:35 <vixey> (even though nobody actually said that)
13:51:36 <dolio> Functions are coalgebraic, sort of.
13:51:51 <vixey> b_jonas, nothing I said should apply to functions
13:51:54 <b_jonas> but of course the numeric matching is sometimes convenient, because numbers occurr so frequently, only it doesn't seem pure
13:52:18 <vixey> what would be nice is allowing things like
13:52:21 <mauke> Eq shouldn't be a superclass of Num, therefore numeric patterns have to go
13:52:22 <vixey> foo = Just True
13:52:27 <vixey> f foo = "just true!"
13:52:33 <vixey> f _ = "not just .."
13:52:49 <SamB> mauke: I don't follow
13:52:51 <vixey> then we could just pretend that deep in GHC source tree there is a file with  1000 = 999+1
13:53:04 <SamB> mauke: we could just have numeric patterns require both Num and Eq for the type in question ...
13:53:04 <b_jonas> vixey: dunno
13:53:07 <vixey> but,,,,, nobody is going to add that feature
13:53:22 <rwbarton> vixey: that way lies madness, though--adding a new identifier far away can totally change the meaning of your program
13:53:29 <b_jonas> vixey: consider how numeric pattern matching has to call (==)
13:53:30 <mauke> SamB: this sounds acceptable
13:53:38 <rwbarton> vixey: unless you create a new syntax for it, then it's OK.
13:53:49 <vixey> rwbarton, oh .. that is true, I didn't think of that :[
13:54:14 <b_jonas> vixey: if it means fromInteger and (==), both of which you can overload, I can't just imagine it as a simple constructor matching
13:54:15 <SamB> vixey: how did you not ?
13:54:34 <SamB> vixey: though I often want to do that sort of thing
13:54:44 <rwbarton> This is why the constructor/variable namespacing with capitalization is so important
13:54:48 <vixey> SamB, I never mentioned this idea before :p
13:54:55 <vixey> SamB, so nobody told me it was bad
13:55:04 <b_jonas> what if we had guards you could add anywhere in a pattern?
13:55:13 <SamB> I mean, I often want to match against a non-constructor constant
13:55:33 <SamB> vixey: what ? you didn't think about it on your own before ?
13:55:34 <vixey> well we can now do,
13:55:39 <vixey> f ((== foo) -> True) = ...
13:55:46 <b_jonas> like, for example, (foo | bar) would match anything foo matches if bar (which can depend on all variables bound by the pattern foo) evaluates to true
13:56:31 <SamB> b_jonas: would that actually give us anything new ?
13:56:47 <b_jonas> SamB: no, it's just syntactic sugar
13:57:20 <b_jonas> probably not so useful if we have to keep all the pattern and related syntax from haskell
14:00:34 <mmorrow> rwbarton: wow, that paper is very helpful for translating type theory notation into notation i'm more familiar with
14:02:24 * mmorrow 's eyes gloss over the second he sees a |-
14:02:44 <mmorrow> no longer
14:02:45 <lament> it's just a bottom on the side
14:03:57 <mmorrow> but how do we know it's not a top on the side?? or even a right on the opposite side!?
14:04:23 <mmorrow> :)
14:04:35 <lament> there's a right?
14:05:06 <mmorrow> sounds good to me
14:05:38 <mmorrow> there's clearly no lefts though
14:05:42 <lament> what's top?
14:06:00 <mmorrow> the opposite of bottom?
14:06:11 <mmorrow> s/opposite/dual/
14:06:37 <dolio> ⊤
14:06:49 <mmorrow> , "⊤"
14:06:51 <lunabot>  "\8868"
14:07:15 <mmorrow> @let top = "⊤"
14:07:15 <lambdabot>  Defined.
14:07:20 <dolio> ⊤⊢⊣⊥
14:07:24 <mmorrow> nice
14:07:46 <mmorrow> @let everyWhichWay = "⊤⊢⊣⊥"
14:07:46 <lambdabot>  Defined.
14:08:05 <Badger> :t top
14:08:06 <lambdabot> [Char]
14:08:10 <dolio> > everyWhichWay !! 2
14:08:11 <lambdabot>   '\8867'
14:08:11 <b_jonas> ~|~ and _|_
14:08:21 <Badger> :t everyWhichWay
14:08:22 <lambdabot> [Char]
14:08:26 <mauke> ⊣⊢ ＋
14:08:35 <mmorrow> i think lambdabot can do what toUTF8 does with Doc
14:08:51 <mmorrow> but lunabot and lambdabot must be doing something diff, since that doesn't work with lunabot
14:08:59 <mmorrow> > text everyWhichWay
14:09:00 <lambdabot>   ⊤⊢⊣⊥
14:09:10 <mmorrow> , text "⊤⊢⊣⊥"
14:09:11 <lunabot>  Ģå
14:09:15 <mmorrow> , toUTF8 "⊤⊢⊣⊥"
14:09:17 <lunabot>  ⊤⊢⊣⊥
14:09:41 <vixey> I get so lost reading these papers
14:09:52 <mmorrow> , text (utf8enc "⊤⊢⊣⊥")
14:09:54 <lunabot>  ⊤⊢⊣⊥
14:09:58 <Badger> > 2 * 2
14:09:59 <mmorrow> ooh, mystery solved
14:10:00 <lambdabot>   4
14:10:20 <Badger> > 2 * top
14:10:21 <lambdabot>       No instance for (Num [Char])
14:10:21 <lambdabot>        arising from the literal `2' at <in...
14:10:27 <Badger> boom
14:10:57 <mmorrow> > let (*) = flip (!!) in 2 * top
14:10:59 <lambdabot>   * Exception: Prelude.(!!): index too large
14:11:12 <mmorrow> um
14:11:17 <mmorrow> > top
14:11:19 <lambdabot>   "\8868"
14:11:22 <mmorrow> oh
14:11:27 <mmorrow> > let (*) = flip (!!) in 2 * everyWhichWay
14:11:34 <lambdabot>   '\8867'
14:11:40 <Badger> @version
14:11:43 <lambdabot> lambdabot 4.2.1
14:11:43 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:14:57 <BONUS> kleisli arrows + monad transformers
14:14:58 <BONUS> hmm
14:14:59 <BONUS> sounds interesting
14:15:14 <BONUS> anyone used this combination yet?
14:16:39 <Saizan> they seem orthogonal to me
14:17:08 <BONUS> hm
14:17:48 <Gabbie> BONUS, get a move on a write about monads in your lovely tutorial.
14:18:02 <BONUS> hahaha
14:18:12 <BONUS> oh my, the dreaded monad chapter
14:18:54 <Badger> eek, monads
14:19:10 <BONUS> im a bit busy with work, uni and fallout 3 but even still, LYAH is coming along slowly but steadily
14:19:18 <Gabbie> :)
14:19:34 <Gabbie> What Uni? I'm nosey.
14:19:34 <Badger> BONUS: skip ahead :P
14:19:38 <vixey> is there any really short haskell parser I can pull apart?
14:19:49 <BONUS> haha. university of ljubljana, slovenia :]
14:19:57 <vixey> not even haskell just somehting with lambda and type annotations
14:20:25 <Gabbie> :)
14:20:42 <BONUS> im really afraid of writing about monads haha, cause im kind of afraid of people telling me: hey your site is great, but the part about monads sucks, i still dont get them
14:20:49 <gwern> did BONUS accidentally a entire monad tutorial?
14:20:59 <BONUS> cause people seem to be having a hard time getting them haha
14:21:03 <BONUS> haha not yet
14:21:08 <mauke> just ignore monads :-)
14:21:09 <b_jonas> gwern: lol
14:21:21 <vixey> yeah totally skip monads :p
14:21:23 <dibblego> BONUS, who cares if others admit their puzzlement?
14:21:24 <BONUS> i accidentally the whole book
14:21:31 <whoppix_> One thing i'm wondering about.. why does "compare 2.0 2.00000000000000001" yield EQ?
14:21:35 <BONUS> hmm yeah
14:21:43 <Jaak> > 2.00000000000000001
14:21:44 <lambdabot>   2.0
14:21:47 <gwern> sounds like the usual floating point madness
14:21:49 <mauke> > compare 2.0 2.00000000000000001
14:21:50 <vixey> whoppix: they are roughly equal, computers aren't exact about things
14:21:50 <lambdabot>   EQ
14:21:55 <mc__> whoppix_: decima numbers cant be represently exactly binary
14:21:56 <mauke> > compare 2.0 (2.00000000000000001 :: Rational)
14:21:57 <BONUS> i just want to offer a kind of different perspective on them and stick with the tone of the book being noob friendly
14:21:58 <lambdabot>   LT
14:22:09 <BONUS> so im going to have to think very hard about how to approach writing about monads
14:22:11 <mauke> preflex: calc '2 2.00000000000000001
14:22:11 <preflex>  10
14:22:18 <mauke> preflex: calc '2 2.000000000000001
14:22:18 <preflex>  10
14:22:19 <vixey> mc__: [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1] :)
14:22:23 <mauke> not enough precision
14:22:28 <ushdf> join #chakra
14:22:30 <whoppix_> hm, ok.
14:22:35 <ushdf> do it!!!!!
14:22:46 <whoppix_> i don't want to.
14:22:48 <mauke> preflex: calc '2 2.000000000001
14:22:48 <preflex>  10.000000000000000000000000000000000000000100011001
14:22:51 <mc__> vixey: hehe, well, they cant be stored exactly with a single word :)
14:22:52 <mauke> ah, there we go
14:22:58 <Gabbie> BONUS, gl with that. :)
14:22:58 <ushdf> what are you, not a team player?
14:23:04 <BONUS> hehe thx
14:23:19 <BONUS> im thinking of making little flash animations
14:23:48 <Gabbie> lol
14:24:08 <BONUS> animating >>= in various monads, etc
14:24:17 <b_jonas> heh
14:24:41 <dibblego> BONUS, do it!
14:24:43 <b_jonas> BONUS: so you use crocodiles for lambda calculus and some other kind of animal for monads?
14:24:54 <mauke> s/flash/gif/
14:25:01 <BONUS> haha
14:25:12 <b_jonas> or birds maybe
14:28:20 <mauke> > zipWith max "alaska" "canada"
14:28:21 <lambdabot>   "clnska"
14:28:41 <SamB> the annoying thing about crocodiles is that you need the alpha rule :-(
14:29:05 <awarrington> are there any alternatives to monad transformers being studied? it seems like monad transformers have a couple of downsides
14:29:52 <BONUS> im quite fond of them myself. which downsides?
14:30:03 <vixey> awarrington, some post on fplunch
14:31:14 <awarrington> BONUS: transformers dont' really scale well to a large number of monads (the amount of code you have to write increases with each monad afaik, please correct me if i'm wrong)
14:31:24 <awarrington> if you are sticking to what is defined in the haskell standard, then it's ok
14:31:32 <BONUS> yeah i guess thats true
14:31:33 <vixey> awarrington, that's wrong
14:31:33 <awarrington> tho the fact that order matters is kind of annoying
14:31:41 <BONUS> hm
14:31:51 <b_jonas> but the order must matter
14:31:59 <rwbarton> the fact that order matters is great!
14:32:01 <BONUS> order mattering is the whole point
14:32:03 <BONUS> yeah
14:32:10 <awarrington> :o
14:32:10 <Badger> hm
14:32:11 <SamB> well, if you have a lot of MonadFoo classes you do need to write instances for each for each transformer you want to preserve them across, yes ...
14:32:13 <b_jonas> a maybe state and a state maybe is quite different: one preserves state when an exception is thrown, the other doesn't
14:32:23 <Badger> I need cabal-install in order to run any cabal command?
14:32:30 <BONUS> the biggest downside i see is writing a lot of instances
14:32:31 <SamB> quite impractical, really ...
14:32:35 <BONUS> and lifting can be annoying
14:32:47 <mauke> Badger: yes, the 'cabal' program is part of the cabal-install package
14:33:12 <awarrington> ok i suppose i have to understand things a little deeper to see the importance of ordering...i understand why they need it tho...must not be thinking hard enough hehe
14:33:16 <Badger> right, thanks
14:33:26 <awarrington> but ya the biggest thing with transformers is the scaling issue
14:33:29 <b_jonas> SamB: actually I think you can do it with O(n*log(n)) instances for n transformers instead of O(n^2) rules as STM does
14:33:50 <SamB> b_jonas: what the ???
14:33:51 <rwbarton> awarrington: the nice thing about monad transformers is the generality
14:34:42 <rwbarton> awarrington: you generally wouldn't want to stack a "large number" of general monad transformers
14:34:46 <BONUS> for instance, in a MaybeT [] a, you get a [Maybe a], whereas in a ListT Maybe a you get a Maybe [a]
14:35:12 <rwbarton> awarrington: you might want to stack a lot of StateTs, though.  so I think there's room for alternatives that deal with special cases better.
14:35:37 <grahamhutton> for info, there is a new approach to monad transformers being developed that avoids the problem of lifting operations: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=111
14:35:41 <b_jonas> SamB: well, firstly you just parition your transformers to two halves, left and right, then make a class MonadLeft that has all the right transformers as instances and you make a general instance so all MonadLeft are MonadFoo for each foo being a left transformer
14:35:50 <lambdabot> Title: FP Lunch » Blog Archive » Modular Monad Transformers
14:35:51 <b_jonas> SamB: then you apply this recursively
14:36:00 <BONUS> i usually see uses for stacking a StateT with list to get a sort of non-deterministic state and/or StateT with Either a for errors
14:36:01 <b_jonas> SamB: I think it gets only O(n*log(n)) this way
14:36:20 <BONUS> grahamhutton: hmm, interesting, will give that a read
14:36:25 <SamB> b_jonas: that doesn't seem any more practical than the other way
14:36:25 <grahamhutton>  not much info there for now, but there is a paper in preparation (by Mauro Jaskelioff) -- it's very nice stuff!
14:36:35 <b_jonas> SamB: yeah, I wouldn't recommend it in practice
14:36:36 <awarrington> that's pretty awesome
14:36:52 <b_jonas> SamB: it gets quite complicated because there are lots of special cases where you have to break the pattern
14:36:53 <SamB> the real impracticality of the thing is when you use MonadFoo and MonadBar from completely independant sources ...
14:37:03 <SamB> with BazT from a third independant source ...
14:37:18 <b_jonas> yeah
14:37:37 <b_jonas> and the transformers and classes often don't correspond one-to-one
14:38:00 <b_jonas> and I suspect that the number of such exceptions is O(n) which would break this solution
14:38:31 <b_jonas> though it wouldn't completely break it
14:38:55 <b_jonas> only make it really hard to follow by a human, to the point that it's not worth to do it unless you're doing hundreds of monad transformers
14:39:15 <awarrington> haha
14:39:36 <sjanssen> I think the "first class monads" approach might be useful here
14:40:02 <SamB> sjanssen: how does that work ?
14:40:16 <sjanssen> skip the transformers alltogether, and have TH generate a type and class instances for a given monad stack
14:40:43 <awarrington> i dunno if a human mind could conceive of a structure so complex that it requires hundreds of monad transformers
14:41:06 <mauke> replicateM 100 IdentityT
14:41:07 <vixey> awarrington, just put a billion StateT in a stac
14:41:14 <BONUS> i dont know, some people here in #haskell are pretty smart
14:41:20 <awarrington> lol
14:41:44 <b_jonas> by the way, has anyone written a library that has a State' and a MonadState' which are a renamed copy of State and MonadState so you can have two different states at different places of the monad stack that don't conflict?
14:42:03 <SamB> mauke: are you doing something screwy like using the reader monad at the type level ?
14:42:10 <mauke> yes :(
14:42:18 <SamB> lol
14:42:36 <b_jonas> that first class monad thing does sound scary indeed
14:42:50 <SamB> I'm pretty sure that isn't allowed in Haskell -- maybe in Coq though ?
14:43:08 <vixey> yeah I think dolio did that in Agda
14:43:21 <vixey> but it did iirc make essential use of dependent types
14:43:49 <sjanssen> b_jonas: I think it is a neat idea
14:44:10 <sjanssen> b_jonas: it's just a DSL for all the monad transformer stack boilerplate
14:46:02 <sjanssen> cabal install cabal-install # is funny
14:48:01 <ushdf> no
14:48:07 <ushdf> cabal install cabal-install # is cabal-install
14:49:49 <b_jonas> sjanssen: have you written it yet?
14:50:08 <SamB> hmm, apparantly the problem is that my nvidia glx implementation has a diversion on /usr/lib/libGL.so ...
14:50:20 <dibblego> apparently
14:50:21 <b_jonas> sjanssen: or some smaller part that demonstrates the idea I mean
14:50:25 <SamB> and the nvidia dev package seems to have a symlink to the filename
14:50:27 <b_jonas> not a full general library
14:50:30 <SamB> +wrong
14:50:32 <SamB> wrong filename
14:50:38 <nha_> did OGL break with ghc 6.10?
14:51:32 <b_jonas> what does forM do?
14:51:40 <b_jonas> is it the same as flip mapM ?
14:51:41 <sjanssen> b_jonas: it isn't my idea, it was a paper at Haskell Symposium
14:51:50 <b_jonas> @src forM
14:51:51 <lambdabot> forM = flip mapM
14:51:59 <sjanssen> b_jonas: they've also released some code on hackage called MonadLab
14:52:01 <ushdf> > 3+3
14:52:02 <lambdabot>   6
14:52:25 <b_jonas> ok
14:52:29 <b_jonas> sjanssen: thanks
14:52:54 <Philonous> Is gtk2hs 0.9.13 known to work with ghc 6.8.3? It gives me a type error in svgcairo/Graphics/Rendering/Cairo/SVG.chs
14:54:19 <b_jonas> @src forever
14:54:20 <lambdabot> Source not found. My brain just exploded
14:54:28 <b_jonas> @src Control.Monad.forever
14:54:29 <lambdabot> Source not found. I feel much better now.
14:54:47 <BONUS> forever m = m >> forever m
14:54:48 <BONUS> imho
14:55:04 <b_jonas> but it has a strange type for that
14:55:08 <b_jonas> @type forever
14:55:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
14:55:32 <b_jonas> that should be of type m a -> m Void, shouldn't it?
14:55:40 <mauke> m a -> m b
14:55:49 <b_jonas> mauke: maybe
14:56:11 <BONUS> in the libs it says forever has a type of Monad m => m a -> m b
14:56:13 <BONUS> which makes more sense
14:56:36 <Saya> Hey, is there a module to include to have applicative parsec or do i have to make the applicative instance myself?
14:56:43 <b_jonas> the ghc-6.8.3 docs on my machine say m a -> m () too
14:56:56 <mauke> m a -> (forall b. m b)
14:57:08 <b_jonas> eek
14:57:11 <BONUS> maybe it changed in 6.10
14:57:19 <nathanic> it's in the changelist for 6.10
14:57:20 <sjanssen> BONUS: it did change in 6.10
14:57:22 <scottutd> Can someone link me to an explanation of infinite types (and in particular what "Occurs check: cannot construct the infinite type" means)?
14:57:24 <b_jonas> it did change?
14:57:31 <b_jonas> you mean without renaming the function?
14:57:37 <sjanssen> b_jonas: yes
14:57:41 <b_jonas> couldn't that cause incompatibilities?
14:57:44 <sjanssen> yes
14:57:44 <BONUS> yes
14:57:49 <nathanic> http://haskell.org/ghc/docs/6.10.1/html/users_guide/release-6-10-1.html
14:57:50 <BONUS> thats the beauty of haskell
14:57:50 <dibblego> scottutd, it usually means you have supplied an incorrect amount of arguments
14:57:51 <b_jonas> oh well
14:57:53 <lambdabot> Title: 1.4.�Release notes for version 6.10.1, http://tinyurl.com/688r8a
14:58:04 <b_jonas> thanks for the info
14:58:10 <mauke> scottutd: an infinite type is a type that uses itself
14:58:11 <BONUS> its a research language basically, so it has the freedom to make incompatible changes
14:58:14 <sjanssen> b_jonas: but not many in practice, since () unifies with a
14:58:24 <RayNbow> :t \x -> x x
14:58:26 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
14:58:26 <lambdabot>     Probable cause: `x' is applied to too many arguments
14:58:26 <lambdabot>     In the expression: x x
14:58:27 <mauke> scottutd: like a@(a -> a) if that was valid syntax :-)
14:58:33 <b_jonas> sjanssen: yeah, I guess so
14:58:42 <BONUS> say you do \a -> a:a
14:58:47 * rwbarton tried to interpret that as a view pattern
14:58:52 <b_jonas> and you probably get a clear error message when it does change something
14:58:55 <BONUS> the type inference engine sees that a has to both be an element of a list and a list
14:59:03 <rwbarton> , let f a@(a -> a) = a in f
14:59:04 <BONUS> of the same type
14:59:05 <lunabot>  luna: Conflicting definitions for `a'
14:59:16 <BONUS> hence the circularity
14:59:37 <mauke> \a -> a:a :: a -> a@[a]
14:59:48 <p_l> is the info gathered from ./configure used in the haskell part of HOpenGL?
14:59:53 <Saya> A little question : is there a parsec module to include to have applicative parsec or do i have to make the applicative instance myself?
15:00:36 <scottutd> here's the snippet if someone would take a look: http://hpaste.org/11767
15:00:50 <RayNbow> scottutd: in case of BONUS' example, try unifying a :: a and a :: [a]
15:01:02 <RayNbow> a = [a]  -- i.e., solve this equation
15:01:04 <vixey> cool
15:01:21 <RayNbow> a = [[a]]   -- substitution
15:01:29 <mauke> scottutd: looks like you're using something both as a set and a set element
15:01:30 <vixey> scottutd, in practical terms, it means that you have made a mistake
15:01:33 <RayNbow> a = [[[[a]]]]   -- substitution again
15:01:44 <BONUS> soon, we run out of brackets
15:01:56 <RayNbow> a = [[[[[[[[a]]]]]]]]   -- another substitution... :p
15:02:09 <mauke> > repeat '[' ++ "a" ++ repeat ']'
15:02:10 <lambdabot>   "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...
15:02:27 <RayNbow> > length $ repeat '[' ++ "a" ++ repeat ']'
15:02:43 <lambdabot>   thread killed
15:02:45 <scottutd> trying to crash lambdabot? :P
15:03:57 <b_jonas> BONUS: not if we recycle them: http://xkcd.com/297/
15:03:59 <lambdabot> Title: xkcd - A Webcomic - Lisp Cycles
15:04:08 <BONUS> haha
15:05:02 <p_l> I always liked the quote about parentheses :D
15:05:24 <RayNbow> scottutd: no, I'm not trying... there's no point in trying it anyway :p
15:05:48 <mauke> scottutd: ndelta looks wrong
15:06:19 <scottutd> mauke: yeah, just fixed it to case on the Maybe a, but that doesn't help with the type problem
15:06:47 <mauke> expected type: Set s -> Maybe a -> Set (Set s)
15:07:02 <mauke> inferred type: s -> a -> Set s
15:07:29 <scottutd> mauke: er, I defined it as s -> Maybe a -> Set s
15:07:54 <mauke> ok, after the Maybe fix: s -> Maybe a -> Set s
15:07:59 <scottutd> mauke: so "ndelta = \s a -> case a of Just b -> Set.singleton (delta s b) \ Nothing -> Set.empty" should fix that
15:07:59 * p_l is looking and looking, but can't find any reason for HOpenGL to use autoconf
15:08:15 <mauke> but it's still required to be Set s -> Maybe a -> Set (Set s)
15:08:52 <scottutd> mauke: oh, right... because the "s" for the NFA is Set s
15:08:59 <mauke> yeah
15:09:07 <scottutd> mauke: thanks a bunch
15:09:28 * SamB wonders where his $EMAIL env var is set
15:11:21 <nha_> anyone that uses hOpenGL around?
15:12:47 <scottutd> is putting type classes into a datatype declaration good/bad practice? ie. Type a = (Ord a) => ....
15:12:50 <jkr> Good evening
15:13:09 <b_jonas> scottutd: compared to what?
15:13:11 <rwbarton> scottutd: it's generally considered bad practice
15:13:28 <rwbarton> scottutd: oh, with 'type'... I'm less sure
15:13:29 <jpcooper> rwbarton, why should that be?
15:13:35 <b_jonas> oh, you mean in a type synonym like type A = (Ord a) => ...
15:13:37 <jkr> I have a newbie question again. :)
15:13:38 <b_jonas> is that even allowed?
15:13:40 <scottutd> rwbarton: no, with data
15:13:43 <rwbarton> I was thinking of data Foo a = (Ord a) => ...
15:13:47 <jpcooper> is it not analogous to creating a subset of a given type-class?
15:14:06 <jkr> When I have an IO function and I use it's return value in another function, does that 2nd function have to be IO to?
15:14:10 <jkr> *too
15:14:16 <rwbarton> scottutd: mostly because it doesn't do anything useful.
15:14:24 <b_jonas> jkr: no
15:14:24 <scottutd> rwbarton: that's what I'd like to do, since the functionality associated with my data type requires it
15:14:36 <jkr> I'm binding the result with foo <- ioFunc, so it requires a "do"
15:14:44 <b_jonas> jkr: yes
15:14:49 <scottutd> rwbarton: the type system ends up wanting the Ord context
15:14:56 <b_jonas> jkr: the resulting function you get from the composition will be an IO one
15:15:04 <b_jonas> jkr: but the second one you call in it doesn't have to be
15:15:08 <jkr> When I do something with foo then and return it, it looks like the 3rd function needs to bind the result with <- again
15:15:10 <b_jonas> loosely speaking
15:16:48 <jkr> For example: getHomeFile file = do home <- getEnv "HOME" \ return (home ++ "/" ++ file)
15:16:56 <scottutd> 	rwbarton: the type system ends up wanting the Ord context
15:17:02 <jkr> getHomeFile must be IO as far as I understand
15:17:11 <jkr> But what about the function calling getHomeFile?
15:17:18 <rwbarton> scottutd: (sorry about that) Even if you put that context on your data constructor, you also have to put it on your functions which use that type.
15:17:27 <jkr> Do I need to bind the result with myFile <- getHomeFile "blah" again?
15:17:41 <mauke> jkr: yes
15:17:48 <scottutd> rwbarton: Oh, so there is no point. Fair enough. Thanks.
15:18:00 <jkr> So it does never stop? :)
15:18:08 <rwbarton> scottutd: Right.  Common practice is to put the class context on exactly those functions which need it.  See Data.Map for example
15:18:09 <mauke> jkr: but that function already exists in the libraries
15:18:22 <jkr> Well, it's just an example :)
15:18:23 <mauke> jkr: it stops if you never actually execute that IO action :-)
15:18:33 <jkr> Hehe
15:18:42 <mauke> jkr: otherwise it's going to end up as part of the big IO action called main
15:18:53 <nha_> anytime you want to evalute the result of an IO action the parent function gets stuck in IO
15:18:57 <jkr> So if I do IO _anywhere_ in my app, main must be IO too?
15:19:04 <jkr> Ah, right :)
15:19:21 <rwbarton> jkr: main is required to be IO anyways.  That's what lets you do IO in your program.
15:19:24 <mauke> main must be IO, regardless of what you do
15:19:29 <nha_> but you arent obligated to use the IO action at any given point
15:19:34 <mauke> it's called by the runtime
15:19:36 <nha_> you can queue the result of the action to be used later etc
15:20:40 <jkr> is there a way to call an IO function like a "normal" function?
15:21:01 <mauke> nooıɯɹoɟɹǝdǝɟɐsun 'sǝʎ
15:21:10 <rwbarton> No, because an IO function is not a normal function.  A normal function cannot do IO. :)
15:21:11 <jkr> Like, building on the example above: let foo = (getHomeFile "something") ++ "another/thing"
15:21:29 <nha_> unsafePerformIO etc
15:21:32 <TSC> jkr: An "IO function" is a normal function; it just returns the type IO a
15:21:32 <nha_> but you need to know what youre doing
15:21:32 <jkr> Hrhr, ok
15:21:45 <mauke> jkr: laziness is going to bite you there
15:22:05 <mauke> you never know when getHomeFile will be called, or how often
15:22:13 <vixey> jkr, like :   liftM2 (++) (getHomeFile "something") (return "another/thing")
15:22:19 <vixey> :t liftM2 (++) (getHomeFile "something") (return "another/thing")
15:22:21 <lambdabot> Not in scope: `getHomeFile'
15:22:22 <vixey> :t liftM2 (++) (?getHomeFile "something") (return "another/thing")
15:22:23 <lambdabot> forall (m :: * -> *). (Monad m, ?getHomeFile::[Char] -> m [Char]) => m [Char]
15:22:24 <Philonous> Oh, the freebsd port of gtk2hs appears to be broken -.-
15:22:35 <vixey> :t (++) <$> (?getHomeFile "something") <*> (return "another/thing")
15:22:36 <lambdabot> forall (f :: * -> *). (Monad f, Applicative f, ?getHomeFile::[Char] -> f [Char]) => f [Char]
15:22:49 <b_jonas> or just liftM (++ "another/thing") (getHomeFile "something")
15:22:53 <rwbarton> foo <- (++ "another/thing") <$> getHomeFile "something
15:22:56 <ziman> :t foldl (>>=)
15:22:57 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
15:23:06 <ziman> @hoogle (Monad m) => m b -> [b -> m b] -> m b
15:23:07 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:23:07 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:23:07 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:23:17 <jkr> Yup, makes sense to me now :)
15:23:20 <vixey> jkr, no clue why nha is suggesting usafePerformIO though, that's not what you us ehere
15:23:23 <jkr> Thanks for explaining
15:23:42 <b_jonas> or if you prefer pointful, do { home <- getHomeFile "something"; return (home ++ "something) }
15:24:05 <vixey> @let (++^) = liftM2 (++)
15:24:06 <lambdabot>  <local>:5:8:
15:24:07 <lambdabot>      Ambiguous type variable `m' in the constraint:
15:24:07 <lambdabot>        `Mon...
15:24:18 <vixey> @let (x++^y) = liftM2 (++) x y
15:24:18 <lambdabot>   Parse error in pattern:
15:24:24 <vixey> @let x ++^ y = liftM2 (++) x y
15:24:26 <lambdabot>  Defined.
15:24:36 <vixey> :t ?getHomeFile "something" ++^ return "another/thing"
15:24:37 <lambdabot> forall (m :: * -> *). (Monad m, ?getHomeFile::[Char] -> m [Char]) => m [Char]
15:25:14 <b_jonas> vixey: is that with (++) meaning the list concat or one of its generalizations some people want to call (++) ?
15:25:26 <vixey> :t ?getHomeFile "something" `mappend` return "another/thing"
15:25:27 <lambdabot> forall (m :: * -> *). (Monoid (m [Char]), Monad m, ?getHomeFile::[Char] -> m [Char]) => m [Char]
15:25:40 <vixey> ah nice b_jonas, that is even better
15:25:46 <vixey> @let (+++) = mappend
15:25:47 <lambdabot>  <local>:6:8:
15:25:48 <lambdabot>      Ambiguous type variable `a' in the constraint:
15:25:48 <lambdabot>        `Mon...
15:26:03 <vixey> @let monomorphism +++ restruction = mappend monomorphism restriction
15:26:04 <lambdabot>  <local>:6:52: Not in scope: `restriction'
15:26:09 <vixey> ..... ahhhhh
15:26:13 <vixey> this thing sucks
15:26:21 <b_jonas> somehow I don't think that defn with mappend would work
15:26:28 <mdmkolbe> is there any difference between "runhaskell Setup.hs {configure,build,clean,install,etc.}" and "cabal {configure,build,clean,install,etc.}"?
15:26:36 <vixey> m [Char] isn't a monoid ?
15:26:46 <b_jonas> vixey: restruction
15:26:54 <vixey> b_jonas: ?
15:27:07 <b_jonas> vixey: restr*u*ction on the lhs, restr*i*ction on the rhs
15:27:11 <b_jonas> that's why it throws it back
15:27:27 <vixey> yeah I know
15:27:40 <vixey> I should have to type out    monomorphism restriction   each time I want to define a function though..
15:27:51 <vixey> I mean I *shouldn't*
15:28:05 <b_jonas> you can just add an explicit type sig
15:28:11 <b_jonas> that makes your code cleaner
15:28:40 <vixey> I am not interested in cleaner if it means I have to put type annotations in my code
15:29:03 <b_jonas> I use some type annotations for learning because they make type error messages better
15:29:18 <vixey> (doesn't the monomorphism restriction exist to allow people to write _less_ annotations though?)
15:29:41 <BONUS> i think type declarations are nice documentation etc.
15:29:53 <vixey> oh they are definitely good in documentation
15:29:53 <rwbarton> Does anyone know of an EDSL (monad?) that can be used to generate SAT instances?
15:30:06 <vixey> I find them obtrusive in source code though
15:30:16 <rwbarton> Kind of like the [] monad, except instead of simple backtracking search, I want to represent the problem as a SAT instance so I can give it to a SAT solver
15:33:36 <mdmkolbe> Anyone got input on how to write this better? http://hpaste.org/11769
15:36:28 <rwbarton> mdmkolbe: maybe you can just call papi_library_init before the papi_num_hwctrs call here.
15:37:14 <jsn> mdmkolbe: fmap and liftM are basically the same thing, and fmap is more general, so...   http://hpaste.org/11769#a1
15:37:36 <mdmkolbe> @type fmap
15:37:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:37:41 <mdmkolbe> @type liftM
15:37:43 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:38:02 <mdmkolbe> @index fmap
15:38:03 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:38:43 <b_jonas> jsn: but . is shorter
15:38:46 <b_jonas> anyway, good night
15:39:39 <jsn> b_jonas: you need more code to use that, though:
15:40:12 <jsn> i don't think we're going to see    (.) = <$>    for awhile yet
15:40:33 <rwbarton> (.) = fmap is evil.
15:40:36 <rwbarton> There.  I said it.  :)
15:40:44 <jsn> rwbarton: why is it evil?
15:40:51 <BONUS> less readable i suppose
15:40:55 <rwbarton> because it violates say-what-you-mean
15:40:57 <mdmkolbe> @type (.)
15:41:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:41:11 <mdmkolbe> huh? how does (.) = fmap?
15:41:23 <rwbarton> > fmap (*10) (+2) 4
15:41:26 <lambdabot>   60
15:41:31 <TSC> fmap in the reader monad, I believe
15:41:39 <jsn> mdmkolbe: it turns out that making a function is a functor
15:41:56 <jsn> mdmkolbe: so you can use functor map to perform composition of functions
15:42:17 <mdmkolbe> jsn: so (.) => fmap, but not fmap => (.)
15:42:36 <rwbarton> mdmkolbe: I don't know what "=>" means
15:42:40 <jsn> so    (.)    and    liftM    specializations of    fmap    yeah
15:42:45 <jkr> Ok, yet another question. :) What's the usual practice for the stop condition of recursive IO functions?
15:42:55 <rwbarton> (.) :: (b -> c) -> (a -> b) -> a -> c; (.) = fmap is a valid definition.
15:42:55 <mdmkolbe> where "=>" means "may always be replaced by"
15:43:09 <jsn> jkr: how would that be any different from the base case of a normal recursive function?
15:43:20 <rwbarton> I never see people going around saying we should all write fmap instead of map. :)
15:43:28 <jkr> For example, when I want to print a list of strings: printList strings = do putStrLn (head strings) \ printList (tail strings)
15:43:35 <jsn> rwbarton: well, i do that
15:43:39 <jkr> And then: printList [] = ... what comes here?
15:44:04 <jkr> It should do nothing and just return, but how do I do that?
15:44:13 <jsn> jkr: return ()
15:44:19 <jkr> Ah
15:44:21 <jkr> Easy :)
15:44:49 <jsn> rwbarton: but not consistently
15:45:16 <rwbarton> Using map and fmap inconsisntely is much less evil IMHO.
15:45:26 <rwbarton> s/inconsistently/interchangeably/
15:46:37 <jsn> rwbarton: i think if we just used     (.)    for all the places where we _could_ use    fmap    , it would make code shorter and simpler overall
15:46:53 <jsn> i think it is misleading when we have a lot of different names for the same thing
15:47:16 <jsn> though it does raise the bar for newcomers
15:47:32 <nha_> jkr: mapM_ putStrLn [string1,string2]
15:47:39 <jsn> admittedly, right now, i could just use    <$>    for all that stuff
15:48:32 <jsn> which also serves as a kind of warning -- "this code is for badasses"
15:49:06 <jsn> but i don't know how you can program haskell for very long without realizing that it's really all     fmap
15:49:19 <jsn> so i don't see what's so bad about it, on balance
15:49:30 <rwbarton> the only problem with always using the most general operation is that the reader of your code then has to figure out what instance you're actually using
15:50:11 <rwbarton> also, there can be more than one way to generalize something like (.).  Why not (.) = (<<<)?
15:50:14 <jsn> rwbarton: granted -- and sometimes even the compiler has to have help, i guess
15:50:46 <rwbarton> When I use (.), I have (<<<) in mind about 99% of the time and (<$>) in mind about 1% of the time
15:51:16 <Igloo> :q
15:52:24 <jsn> well, can (<<<) take a bunch of other use cases, as well?
15:54:07 <rwbarton> Well, not in practice, because most Arrow instances are newtypes
15:54:14 <jkr> Great, my first seg fault in Haskell :)
15:54:33 <jsn> ah
15:54:42 <rwbarton> but conceptually, (<<<) is also composition of Kleisli arrows
15:54:45 <rwbarton> :t (<=<)
15:54:47 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
15:54:55 <jsn> yes, but...
15:55:27 <dolio> Ultimately, you can write a system of type classes that unifies (<<<) and fmap.
15:55:30 <dolio> But it's ugly.
15:55:41 <jsn> dolio: how is it ugly?
15:55:49 <jkr> Does anyone here use HDBC.Sqlite3 (successfully)?
15:55:52 <dolio> Even a purely Category (<<<) (Arrow is easier, I think).
15:56:37 <jsn> well, say we just turned    (.)    into     fmap     i don't think it would hurt anyone, and i don't think it would have any opportunity cost
15:57:10 <dolio> jsn: You have to redo Functor as not just covariant endo-functors, but full on functors to potentially different categories (all of which have objects in the haskell type system, though).
15:57:35 <jsn> dolio: why is that?
15:57:50 <jsn> dolio: oh, you mean, to unify them
15:57:53 <rwbarton> class Functor (~>) (~~>) f where fmap :: (a ~> b) -> (a ~~> b);
15:58:00 <dolio> Because then (.) can be specialized to categorical composition.
15:58:43 <jsn> and that could be awesome or it could basically mean, we have found a way to write Perl in Haskell
15:59:17 <jsn> but at least in Haskell, we can use the type system to iron things out, so that is why i am advocating it
16:00:22 <jsn> i also would really like to have C++    <<    but let's not bring that up now :)
16:02:00 <rwbarton> I guess one reason (.) and fmap are different concepts to me is that fmap f g treats f and g asymmetrically.
16:02:02 <ushdf> i want functional php
16:02:11 <ushdf> really good functional php
16:02:15 <ushdf> what's perl 6 going to be like
16:02:21 <sbahra> ushdf, have you looked at hsp?
16:02:37 <ushdf> yeah
16:03:54 <ushdf> i read in this book that decryption programs would eventually identify different word types and semantic qualifications
16:04:07 <ushdf> that made my day
16:04:24 <ushdf> because it means i'ma be rich
16:04:31 <ushdf> rich!!
16:04:59 <ushdf> anyway, hsp is nice
16:05:04 <ushdf> i'll have to try it when i have a chance
16:06:03 <jsn> rwbarton: i don't understand "symmetrically" in this case
16:07:15 <dolio> jsn: http://hpaste.org/11770
16:08:31 <gwern> ushdf: well, there are text (de)compressors that use neural networks with some understanding of english to acheive greater compression ratios...
16:09:42 <p_l> Except that we are still far from really understanding english... and it's one of the simplest languages, also from AI point of view
16:09:49 <jsn> ah, okay
16:10:26 <jsn> dolio: you are just demoing what it takes to have a unified fmap and (<<<), right? nothing to do with rwbarton's remark?
16:10:28 <dolio> jsn: The problem is, I'm not sure functors modeled like that aren't a pain in the ass to use in practice. :)
16:11:07 <jsn> rwbarton: i believe    fmap f g    is just the same as     f . g     at, least with the instance defined in base
16:11:09 <dolio> Yes. The main argument (that I can see) for not turning (.) into fmap is that conceptually, it's closer to (<<<).
16:11:15 <rwbarton> Imagine you have a category C and f : Y -> Z, g : X -> Y morphisms of C (you can take C = Hask and X, Y, Z to be types a, b, c)
16:11:39 <dolio> If you model functors that way, it can be both.
16:11:40 <rwbarton> The functor here is X -> -, it takes C to Set
16:11:42 <jsn> okay, imagining....
16:11:59 <rwbarton> I'll call that functor U or something
16:12:06 <rwbarton> so g is an element of U Y
16:12:15 <rwbarton> and f is a morphism in C
16:12:39 <rwbarton> and U f is a map of sets U Y -> U Z, and it's given by composition.
16:13:18 <tristes_tigres> Greetings all ! congratulations on the great news, eagerly awaited by all people of good will !
16:13:27 <rwbarton> but f and g play different roles here, I left f alone but I had to do all this work to g to get it into a framework where I can apply Uf to it.
16:13:33 <tristes_tigres> I mean, of course, the release of GHC 6.10.1
16:13:53 <sbahra> huh?
16:14:05 <sbahra> ah
16:14:07 <sbahra> Great
16:14:14 <tristes_tigres> not some scurrilous pol beating even more scurrilous one
16:14:43 <ushdf> people use AI for the most boring things
16:14:47 <sbahra> Hrm.
16:14:52 <ushdf> why develop a best first backtracking algorithm
16:14:54 <ushdf> and then use it to solve
16:14:55 <rwbarton> jsn: Maybe it's more obvious to say that a and c are treated asymmetrically.
16:14:57 <ushdf> the 8 queens problem
16:15:16 <ushdf> cure tuberculosis or something
16:15:27 <jsn> rwbarton: oh, i got pulled away by a coworker, just a minute
16:17:30 <p_l> ushdf: Cause we use chess to research search algorithms
16:18:22 <p_l> You have a pretty big solution space, and you know a range of outputs you want. Now find the way to it
16:18:33 <jkr> Good night
16:18:38 <ushdf> but why are we devoting our attention to chess
16:18:38 * p_l is not sure he used correct terminology
16:18:47 <lament> because go is less popular
16:18:49 <p_l> ushdf: Cause it's quite simple
16:18:57 <p_l> Go requires a completely different approach
16:19:01 * ushdf sighs
16:19:15 <Corun> Oooh
16:19:18 <Corun> I heard talk about Go
16:19:28 * Corun plays komoku
16:19:32 <sbahra> some nice changes to ghci
16:19:36 <Corun> Your move, #haskell.
16:19:43 <sbahra> not printing bind results, for one :-p
16:19:44 <p_l> The algorithms that are cracked during work on chess are then used in various other fields
16:19:44 <lament> kakari!
16:20:15 <Corun> HOSHI.
16:20:19 <Corun> Er, I mean, tengen.
16:20:21 <Corun> Sorry ;-)
16:20:50 <lament> sansan! (under your komoku)
16:21:02 <ushdf> humanity is screwed anyway
16:21:07 <ushdf> they still think HIV causes AIDS, for god's sake
16:21:29 <jsn> rwbarton: so, when you say they are treated asymmetrically, i guess i don't see what the actual problem with that is
16:21:40 <p_l> ushdf: care to elaborate?
16:21:40 <rwbarton> jsn: It just doesn't map onto my concept of (.).
16:21:50 <ushdf> ok
16:22:04 <ushdf> immunodeficiency will increase the prevalence of any virus
16:22:08 <ushdf> and they haven't proven the causation
16:22:10 <jsn> if i follow your discussion above, you are saying, that fmap forces you to think about composition in a weird way
16:22:19 <ushdf> barely even the correlation
16:22:26 <tristes_tigres> actually, AIDS is caused by the Microsoft software
16:22:26 <rwbarton> jsn: It also suggests flip cofmap as an alternate generalization of (.) :)
16:22:35 <jsn> rwbarton: oh?
16:22:40 <lament> ushdf: yes, they have.
16:22:42 <sbahra> ushdf, "most people with HIV end up developing AIDS"
16:22:48 <ushdf> that's the thing
16:22:51 <ushdf> they're treated with drugs like AZT
16:22:54 <jsn> so there are actually quit a few options
16:22:54 <ushdf> retrovirals
16:22:58 <ushdf> and then protease inhibitors
16:23:12 <ushdf> AZT was too toxic to even be used as a drug for chemotherapy, it actually causes the symptoms of AIDS
16:23:20 <rwbarton> jsn: well, cofmap doesn't seem to come up very often in haskell for whatever reason.
16:23:20 <jsn> rwbarton:    (.)    could be any one of these more general things
16:23:43 * EmielRegis gnite
16:24:05 <jsn> rwbarton: well, i am not looking for some kind of totalitarian approach to this stuff
16:24:35 <jsn> rwbarton: i'd just rather that i have a short name for something i do all the time
16:25:05 <p_l> ushdf: I'm no biologist/medicine specialist, but AFAIK the connection between HIV and AIDS is only that HIV uses human immunology system as it's environment. If the white (cells? I don't know english terminology) are used to produce more of the virus instead of defending organism, that's pretty plain immunodeficiency cause for me
16:25:06 <rwbarton> jsn: yeah, me too.  I use <$> all the time.
16:25:14 <rwbarton> jsn: it helps that you rarely have more than <$> per line.
16:25:23 <jsn> rwbarton: heh
16:25:30 <ushdf> that's the thing though
16:25:35 <jsn> what an ugly operator, though :)
16:25:46 <ushdf> HIV attaches to 1/1000 T-cells per cell cycle
16:25:58 <ushdf> while they regenerate at a rate of 0.5%
16:26:04 <jsn> the single character operators should be the most magical
16:26:10 <p_l> ushdf: But isn't the rate of growth pretty fast anyway?
16:26:21 <rwbarton> jsn: hmm, I wonder whether there's a unicode character SMALL LOWERED STAR :)
16:26:33 <ushdf> which rate of growth
16:26:59 <jsn> rwbarton: i look forward to the day when we can type all those things easily
16:27:20 <jsn> in the meantime, i am stuck with ASCII :)
16:27:33 <lament> (for those interested in why ushdf is wrong: http://en.wikipedia.org/wiki/AIDS_denialism )
16:27:35 <lambdabot> Title: AIDS denialism - Wikipedia, the free encyclopedia
16:27:44 <ushdf> "denialism"
16:27:52 <p_l> ushdf: 'white' cells are kept at a constant level by our organism (it gets bad if it goes over or under), while HIV is not restricted by such thing
16:27:57 <dolio> Emacs has some relatively easy ways for typing the stuff.
16:28:00 <ushdf> The causative role of HIV in the development of AIDS has been established and is the subject of scientific consensus.[1][2]
16:28:11 <dolio> If you consider memorizing a lot of LaTeX codes easy.
16:28:12 <ushdf> oh, alright
16:28:14 <ushdf> thanks wiki
16:28:19 <ushdf> that's reassuring
16:28:27 <jsn> dolio: well, i'm not sure there would be broad adoption of it in that case :)
16:28:40 <p_l> ushdf: OTOH, we found people immune to HIV :)
16:28:43 <dolio> :) SCIM can do it too!
16:28:45 <jsn> also, i am a member of the church of vim
16:28:52 <ushdf> taht's true, we did
16:28:55 <jsn> and work on macintosh
16:29:07 <ushdf> in fact i'm quite sure that it exists naturally in everybody
16:29:08 <dolio> Although SCIM makes things crash a lot in my experience.
16:29:13 <jsn> heh
16:29:32 <jsn> i used it for some time, i never had any trouble
16:29:42 <jsn> but then i got a mac
16:29:53 <BMeph> jsn: Wouldn'
16:29:54 <ushdf> i'm reading through that wiki article
16:29:56 <dolio> Well, it's been several months since I tried it.
16:29:58 <ushdf> it's extraordinarily poorly argued
16:30:09 <ushdf> Since AIDS is now defined partially by the presence of HIV, Duesberg claims it is impossible by definition to offer evidence that AIDS doesn't require HIV. However, the first definitions of AIDS mentioned no cause and the first AIDS diagnoses were made before HIV was discovered.
16:30:24 <jsn> BMeph: what?
16:30:28 <Riastradh> (Is this discussion really appropriate for #haskell?)
16:30:30 <p_l> ushdf: Well, not exactly... however, it's speculated that North Europe was struck by similar virus long ago. Those who weren't apropriate hosts for virii multiplication survived, while the rest died with the virus
16:30:31 <ushdf> 10 points to whoever figures out the fallacy first
16:30:49 <jsn> p_l: can you folks move to #haskell-blah ?
16:30:51 <BMeph> Let's try again - jsn: isn't flip cofmap (>>>), not (<<<), i.e., flip (.)?
16:30:54 <jsn> ushdf: please?
16:31:01 <shapr> @seen dpiponi
16:31:01 <lambdabot> Last time I saw dpiponi was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
16:31:02 <lambdabot> haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr and #haskell.it 2m 10d 1h 48m 34s ago, and .
16:31:03 <p_l> jsn: Sorry, got carried over
16:31:04 <ushdf> fine
16:31:34 <jsn> no problem -- i've needed to be reminded as well
16:31:38 <Riastradh> (Also, the plural of `virus' is `viruses', added in English to what was in Latin a mass noun lacking a plural.)
16:32:38 <jsn> > :t flip cofmap (+1) show
16:32:39 <lambdabot>   <no location info>: parse error on input `:'
16:32:51 <jsn> :t flip cofmap (+1) show
16:32:52 <lambdabot> Not in scope: `cofmap'
16:32:58 <jsn> zounds
16:34:10 <rwbarton> category-extras calls it contramap
16:34:14 <jsn> i suppose i can be satisfied with    <$>
16:34:49 <jsn> i don't want to end up with a bunch of idiosyncratic code with     .     all over the place, confusing everyone
16:36:12 <jsn> (that code would be the first Haskell submission to the DalyWTF)
16:36:21 <jsn> anyways, i'm going shopping
16:41:50 <BMeph> Am I too picky, or should there be a smaller, 'base' version of category-extras? I find that there's a LOT of stuff in there... :)
16:51:03 <FunctorSalad_> hmm... does a MonadTrans t not have (m a -> m b) -> t m a -> t m b in general?
16:52:34 <rwbarton> :t lift
16:52:36 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
16:54:07 <FunctorSalad_> that doesn't quite do it, does it?
16:54:12 <rwbarton> No, I don't think so
16:54:21 <FunctorSalad_> since I can't "unwrap" the t m a
16:55:02 <mdmkolbe> Am I doing this marshalling of a C struct to Haskell wrong?  It seems like a lot more boiler plate than there should be. http://hpaste.org/11771
17:02:24 <idnar> [1,2] <^(+)^> [2,3]
17:02:25 <idnar> ohhhhh boy
17:02:45 <idnar> looks like a spaceshit or something
17:03:05 <lament> the cthulhu operator
17:03:11 <idnar> err, *spaceship
17:03:19 <idnar> I like cthulhu operator better, though
17:03:42 <BMeph> lament: Ever read "Forge of the Elders" by L Neil Smith? :)
17:03:52 <lament> no
17:04:03 <BMeph> (Sorry for the -blah, every one.)
17:06:15 <BMeph> lament: Ah, pity.
17:09:43 <BMeph> Has anyone else had any problems building time 1.1.2.2 or is it just me? :)
17:15:54 <sm> hey all
17:16:09 <mdmkolbe> hi
17:16:20 <sm> what's the most php-like haskell web framework ? as in edit .hs files, see changes immediately.. and uses rdbms as primary storage
17:17:06 <qwr> run cgi with yhc or hugs? ;)
17:17:10 <sbahra> I would guess hsp.
17:17:33 <johnnowak> for god sakes, what's the least php-like haskell web framework?
17:18:06 <dons> happs?
17:18:13 <dons> that's very unlike php
17:18:29 <dons> the most php like. mm. something with one of the templating engines?
17:18:43 <sbahra> dons, that e-mail you sent about porte, is it automated?
17:18:49 <dons> sbahra: no :)
17:18:55 <dons> its a personal request :)
17:19:10 <sbahra> Yes, I'll be fixing it.
17:19:29 <sbahra> But I was just wondering if you guys have some sort of tinderbox for QAT, similar to FreeBSD ports.
17:19:54 <sm> thanks. I ask because I am maintaining a large legacy php app. I can't touch it without wanting to start over in haskell, which is just not going to happen... unless, it can be done with identical development cost characteristics for the client
17:19:57 <sbahra> dons, does cabal support the notion of patch levels in versioning?
17:20:13 <dcoutts> sbahra: by convention, yes
17:20:23 <sm> I haven't explained that very well.. best effort just now..
17:20:25 <sbahra> dcoutts, 0.0.1-p2, for example.
17:20:43 <dcoutts> sbahra: you can choose to use the package version policy which gives some meaning to the version digits
17:21:03 * sbahra checks out the new exception interface
17:21:17 <sbahra> dcoutts, ok.
17:21:32 <dcoutts> sbahra: it uses 4 places, the first two are for incompatible api changes, the third is for compatible api additions, the last is for patches / fixes etc that do not change apis
17:21:46 <dcoutts> sbahra: so your example would be 0.0.1.2
17:21:58 <sbahra> Aha.
17:22:09 <sbahra> Very coherent. :)
17:24:06 <sm> maybe I should be thinking about generating php code from haskell models
17:24:10 <dcoutts> sbahra: I'm glad it's comprehensible :-) for future reference, it's documented on the wiki "Package versioning policy"
17:24:26 <mdmkolbe> Any help on making this easier to code?  http://hpaste.org/11771 (I'm going to have to do the same for half a dozen structs, so savings would be nice.)
17:24:58 <sbahra> dcoutts, ok.
17:25:08 * sbahra hasn't had time to comprehensively browse through documentation
17:25:29 <dcoutts> sbahra: nobody reads docs, especially not before they know they need them :-)
17:35:18 <ivanm> dcoutts: well, of course... if you don't need them, why read them?
17:35:19 <ivanm> *duh*
17:35:25 <ivanm> ;-)
17:40:42 <sbahra> Because sometimes you don't know you need them :)
17:41:43 * ddarius was the kind of kid that read the game manual before playing the game.
17:44:01 <sbahra> dons, should satisfy you now, I think :-P
17:52:27 <ivanm> ddarius: yeah, me too
17:54:07 <Philonous> Is darcs cabalized?
17:56:12 <thoughtpolice> Philonous: strictly speaking no, but there are some build-system change things going on now that entail using cabal to a degree (and another haskell build system, franchise.)
17:56:43 <dcoutts> it's all a lot of fun :-)
17:57:53 <Philonous> Ah thanks
17:58:37 <ushdf> http://www.change.gov/
17:59:13 <pumpkin_> o'bama at work?
17:59:23 <mlh> or not (yet)
17:59:39 <pumpkin_> only a select few can change
17:59:55 <mlh> I get a 404 on hope.gov though :-)
18:01:00 <ushdf> pumpkin_ got it ;)
18:16:10 <juhp> what's up with http://darcs.haskell.org/darcsweb/ ?
18:16:11 <lambdabot> Title: darcs - Repositories
18:17:07 <juhp> http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=Cabal;a=summary => IOError: [Errno 2] No such file or directory: '/tmp/darcsweb-cache/.29ff20e554ba5b8bea78d0107a710726cc78ec4e-29044'
18:46:36 <mdmkolbe> Does this varient of "ap" already exist?  http://hpaste.org/11773  (I had to (re)invent it on my own for an application I'm writting, but if it already exists I would prefer to use that)
18:47:23 <rwbarton> It's liftM2 ap
18:47:36 <lispy> ?hoogle (x -> m (a -> b)) -> (x -> m a) -> (x -> m b)
18:47:36 <lambdabot> No results found
18:47:52 <lispy> :t liftM2 ap
18:47:53 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Monad m) => m1 (m (a -> b)) -> m1 (m a) -> m1 (m b)
18:48:59 <mdmkolbe> umm, the type of liftM2 ap is diferent
18:49:19 <lispy> I think m1 = ((->) r)
18:49:33 <rwbarton> :t liftM2 ap :: Monad m => (x -> m (a -> b)) -> (x -> m a) -> (x -> m b)
18:49:34 <lambdabot> forall x (m :: * -> *) a b. (Monad m) => (x -> m (a -> b)) -> (x -> m a) -> x -> m b
18:50:07 <lispy> it's sneaky because no one thinks about instance Monad ((->) r), usually
18:50:11 <mdmkolbe> heh, ok, yeah
18:50:44 <mdmkolbe> but I'll have to bind that to a name right, b/c haskell doesn't allow arbitrary expressions in ``
18:52:51 <gwern> indeed. it's always annoyed me that I can't do 'f `bar 4` g', I have to bind a new name for bar 4 if I want it infix
18:54:06 <rwbarton> mdmkolbe: this foo would be shorter if you just wrote  foo x = return Foo `ap` peakByteOff x 0 `ap` peakByteOff x 4  :)
18:55:27 <paczesiowa> isn't that Foo <$> peakByteOff x 0 <*> peakByteOff x 4 ?
18:55:34 <mdmkolbe> rwbarton: yes, except that Foo actually has 10 arguments instead of just 2 and I'm actually using #{peak} instead of "flip peakByte"
18:55:37 <rwbarton> Yes
18:55:52 <mdmkolbe> @type <$>
18:55:53 <lambdabot> parse error on input `<$>'
18:55:53 <rwbarton> mdmkolbe: ah, ok
18:56:00 <mdmkolbe> @type (<*>)
18:56:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:56:26 <paczesiowa> :t (<$>)
18:56:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:03:31 <mdmkolbe> @hoogle (a -> m b) -> (b -> m c) -> a -> m c
19:03:32 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:03:32 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
19:03:32 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
19:05:15 <ushdf> yeah, iw anted the apple to fall out of the garbage bag
19:05:21 <ushdf> thanks a bunch, non-intelligent trash can
19:05:30 <ushdf> have you guys figured otu a way to eliminate waste yet
19:05:31 <pumpkin> does hoogle rely on the type variables you choose?
19:05:53 <pumpkin> @hoogle (b -> m c) -> (b -> m d) -> b -> m d
19:05:54 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:05:54 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
19:05:54 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
19:06:05 <pumpkin> o.O
19:06:35 <ttmrichter> Is it possible to compile Haddock 2.0.0.0 with GHC 6.8.3 or has there been an incompatible change that needs to be modified?
19:10:06 <ttmrichter> This is what I'm getting when I try: http://hpaste.org/11774#a0
19:12:49 <sw17ch> ping dons
19:14:06 <thoughtpolice> ttmrichter: there were some API changes iirc; try this tarball instead - http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haddock-2.4.0
19:14:07 <lambdabot> Title: HackageDB: haddock-2.4.0, http://tinyurl.com/5saf72
19:14:19 <thoughtpolice> ttmrichter: also if you install ghc 6.10, it comes with haddock now by default
19:14:22 <thoughtpolice> (which is good)
19:14:55 * sw17ch wonders if any distros have 6.10 yet
19:15:27 <ttmrichter> thoughtpolice: I just noticed the 6.10 notice and am downloading as we speak.  :)  Given that Haddock comes with it out of the box, I'll be forgoing the link you proffered. Thank you for the response, though.  It's good to know that 6.10 will be more fun tinker-time.  :D
19:15:49 * ttmrichter eyes the Real World Haskell site.  "Now if only the book were to get released...."  ;)
19:16:25 <thoughtpolice> 6.10 = win
19:16:40 <thoughtpolice> data parallelism, type families, oh my!
19:16:41 <thoughtpolice> ;)
19:17:17 <sw17ch> thoughtpolice, any word on how long the new code generator will be?
19:17:51 <paczesiowa> sw17ch: gentoo has 6.10 in official overlay
19:17:57 <thoughtpolice> sw17ch: changes should hit HEAD soon hopefully
19:18:13 <sw17ch> paczesiowa, argh... i've been resisting the overlay
19:18:23 <paczesiowa> sw17ch: why?
19:18:41 <sw17ch> i don't like overlays in gentoo for some reason... it's probably more dogmatic than practical
19:18:45 <thoughtpolice> sw17ch: by the time john wanted to merge with HEAD before 6.10, it was too close to the release already and there were a bunch of bugs he said he needed to iron out in his code
19:19:03 <thoughtpolice> but yeah once they hit HEAD i'll be updating and checking some initial stuff for sure
19:19:04 <sw17ch> mmm... alright\
19:19:08 <paczesiowa> sw17ch: haskell is different than most overlays, most packages are autogenerated from hackage
19:19:32 <sw17ch> huh, interesting
19:19:35 <sw17ch> (to both)
19:20:01 <thoughtpolice> maybe GHC can get to jhc-like speeds? :]
19:20:11 <sw17ch> hehe
19:20:20 <sw17ch> i've never cared about compiler speed
19:20:29 <sw17ch> if it takes an hour to compile, but it's faster code in the end... yay!
19:20:30 <paczesiowa> yeah
19:20:40 <thoughtpolice> hehe
19:20:40 <juhp> ttmrichter: fedora has a patch to build haddock-2.0.0.0 with ghc683 fwiw
19:20:43 <sw17ch> (as long as i have a slow-but-works compile option)
19:20:45 <thoughtpolice> i remember on my old archlinux box
19:20:52 <thoughtpolice> jhc compiling hello world == 22 minutes
19:21:00 <sw17ch> holy crap
19:21:19 <sw17ch> oh hey, general question
19:21:35 <sw17ch> are there any thoughts on a way to pull the ioctl call into haskell?
19:21:36 <juhp> is there an array package that builds with 6.10.1?
19:21:51 <paczesiowa> on my old laptop that has 192 mb of ram, linking cabal Setup.hs which needs like 400mb of ram takes about a day and a half. beat that!
19:21:53 <sw17ch> int ioctl(int d, int request, ...);
19:21:54 <thoughtpolice> sw17ch: hm apparently I un-installed jhc, but I remember on one of the nobench programs, ghc's generated code took like 3 seconds, jhc's generated code took about one *tenth* of a second
19:21:57 <thoughtpolice> which is win :]
19:22:08 <sw17ch> good gosh...
19:22:35 <thoughtpolice> yeah it's some savage compiler optimization
19:22:55 <thoughtpolice> john said he noticed on some benchmarks with very tight-loops jhc made code 3-7x faster
19:23:14 <sw17ch> yeesh
19:23:20 <thoughtpolice> http://repetae.net/dw/darcsweb.cgi?r=jhc;a=headblob;f=/docs/jhc-vs-ghc-assembly.txt
19:23:21 <paczesiowa> jhc supports common extensions?
19:23:24 <sw17ch> and how hard is it to merge John's optimizations in with GHC?
19:23:25 <lambdabot> Title: darcs - jhc, http://tinyurl.com/6zwe9k
19:23:30 <thoughtpolice> sw17ch: read that
19:23:38 <thoughtpolice> it states some of them can probably be backported to GHC
19:23:47 <thoughtpolice> paczesiowa: jhc doesn't support a lot of stuff
19:23:55 <thoughtpolice> it'll choke pretty easily
19:24:29 <paczesiowa> what? no undecidable-instances? how the hell am I supposed to code without it?
19:24:32 <thoughtpolice> sw17ch: that C code jhc generates for factorial is very beautiful imo :]
19:25:06 <sw17ch> I just want a haskell that can target ARM architectures
19:25:12 <sw17ch> i would seriously throw a party
19:25:20 <sw17ch> and you'd all be invited, and i'd buy a keg
19:25:22 <thoughtpolice> jhc has the benefit of ISO C output
19:25:25 <thoughtpolice> which is nice
19:25:28 <sw17ch> and... well, it would be such a happy occasion
19:25:38 <BMeph> thoughtpolice: I'm getting another problem with haddock 2.4: http://hpaste.org/11774#a1
19:26:08 <thoughtpolice> sw17ch: one of my plans with my haskell compiler that may-never-ever-be-released is that it should be easy to get haskell to places it has never gone before, like cellphones and whatnot :]
19:26:18 <BMeph> s/2.4/2.4.0/ -- to be precise
19:26:36 <sw17ch> thoughtpolice, you have no idea how much i want to run haskell at work
19:26:39 <thoughtpolice> BMeph: what ghc? 6.8 or 6.10?
19:26:44 <BMeph> thoughtpolice: Android, maybe? ;)
19:26:56 <thoughtpolice> BMeph: because the problem looks like the new extensible-exceptions changes
19:26:57 <BMeph> And, 6.10.1
19:27:12 <sw17ch> If I could convince some one to put effort toward ARM architectures and M68K, I would be so happy
19:27:14 <juhp> haddock-2.4 didn't cabal-install for me either
19:27:16 <thoughtpolice> BMeph: yeah, I tried to cabal install haddock earlier and it didn't work
19:27:28 <thoughtpolice> so I'm just sticking with 2.3 from the 6.10 sources
19:27:29 * sw17ch wishes some one would hand him a job just to figure those architectures out
19:27:34 <Axman6> does anything use m68k?
19:27:41 <sw17ch> Axman6, I do :)
19:27:47 <Axman6> what for?
19:27:53 <sw17ch> ColdFire chips in embedded environments
19:28:00 <Axman6> righto
19:28:01 <sw17ch> there's pretty sweet
19:28:08 <sw17ch> but ARM is the big one...
19:28:12 <sw17ch> </rant about arm>
19:28:26 <thoughtpolice> sw17ch: my project steals a lot of ideas from jhc tbh like ISO C output, but i've got more interesting things up my sleeve based on some books on FP I've been reading from the library...
19:28:27 <sw17ch> So, back to my earlier question... ioctl
19:28:29 <sw17ch> any one?
19:28:40 <Axman6> i was working on someone's ARM emulator written in haskell recently, need to submit it to hackage sometime
19:28:51 <sw17ch> orly?
19:28:53 <sw17ch> hmmm
19:28:54 <sw17ch> :)
19:29:01 <thoughtpolice> namely mobile code
19:29:03 <pumpkin> ooh ARM emulator in haskell :o
19:29:10 <thoughtpolice> but that is a can of worms that will take a while
19:29:11 <thoughtpolice> i think
19:29:12 <thoughtpolice> :]
19:29:17 <Axman6> it was very basic
19:29:21 <sw17ch> thoughtpolice, as in mobile devices? or it crawls around
19:29:22 <Axman6> s/was/is
19:29:35 <sw17ch> but is it the whole ARM instruction set?
19:29:40 <sw17ch> with MMU/etc?
19:29:41 <Axman6> but, it could benefit from some external help i'm sure :)
19:29:45 <Axman6> no
19:29:48 <sw17ch> ah
19:30:01 <thoughtpolice> sw17ch: i.e. receiving code from the network, i.e. 'mobile applications'
19:30:34 <BMeph> I wonder how tough it would be to integrate Android and GHC... >:)
19:30:44 <thoughtpolice> it's an idea I got from a paper on an intermediate-language (like STG core or GRIN) that is more low-level and hands itself to do thinks like dynamic linking and things like that
19:30:48 <sw17ch> thoughtpolice, if this was a less intellectual and imaginative IRC room, i'd be sure what you're talking about, but it still seems like magic
19:31:33 <sw17ch> so, are you talking about injecting code from a network into a live application? or are you just thinking downloadable apps for iphone/g1
19:31:39 <thoughtpolice> sw17ch: think distributed applications
19:31:45 <sw17ch> thoughtpolice, ah, thanks
19:31:58 <thoughtpolice> sw17ch: yeah the backend is interesting but I need to read more
19:32:18 <thoughtpolice> and think about how it will overall integrate with my other compiler backend which is in fact GRIN like jhc
19:32:47 <sw17ch> where was i just reading about GRIN, Haskell, and LLVM...
19:32:48 <sw17ch> hmmm
19:33:35 <thoughtpolice> I also have other ideas - GRIN is strict and things like the heap points-to analysis are actually control-flow analysis, and grin in certain ways resembles SSA (variables are only assigned once and case statements are the only way to 'join' paths of execution) - so I was thinking maybe it was worth researching taking GRIN and emitting e.g. LLVM
19:33:41 <thoughtpolice> but it's all up in the air
19:33:41 <sw17ch> <broken record>so, ioctl?</broken record>
19:34:08 <thoughtpolice> would be an interesting experiment nonetheless
19:34:31 <sw17ch> thoughtpolice, actually, that's basically the path of the slide deck i was reading... but i can't find it
19:34:43 <sw17ch> so, unless it was your slide deck :P
19:34:48 <thoughtpolice> nope :]
19:35:58 <sw17ch> thoughtpolice, man, i'm going to keep looking, this was so close to what you're talking about (if i'm understanding it right)
19:36:19 <thoughtpolice> also if grin can be treated similarly to SSA, then that opens up the possibility of doing things like e.g. chordal register allocation (S. hack thesis) for a native-code generation backend (instead of C or something)
19:36:28 <thoughtpolice> but it's all up in the air
19:37:08 <thoughtpolice> (expect a release of this awesome compiler potentially never.)
19:39:18 <sw17ch> thoughtpolice, well, in the mean time, you could help me write my VPN :)
19:40:05 <thoughtpolice> sw17ch: oh, re. ioctl, is it varargs? if so, that's not supported by the FFI :[
19:40:19 <thoughtpolice> you must use fixed-length wrappers
19:40:21 <sw17ch> thoughtpolice, i know :) which is why my VPN has C code still
19:40:23 <thoughtpolice> and then import those
19:40:40 <sw17ch> i don't think i can get away from it... but it would be nice
19:40:42 <thoughtpolice> and 6.10 also apparently really breaks that even though it wasn't ever supported anyway
19:42:24 <sw17ch> breaks the varargs stuff?
19:44:20 <thoughtpolice> yeah
19:44:35 <dons> youuu can call varargs stuff at a differen type each time
19:44:39 <thoughtpolice> http://haskell.org/ghc/docs/6.10.1/html/users_guide/release-6-10-1.html
19:44:41 <lambdabot> Title: 1.4.�Release notes for version 6.10.1, http://tinyurl.com/688r8a
19:44:41 <Axman6> @src Set
19:44:42 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:44:43 <thoughtpolice> see the 'FFI changes' part
19:44:45 <Axman6> @src Set a
19:44:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:45:01 <sw17ch> dons: i thought i had done that once before
19:45:44 <sw17ch> thoughtpolice, yep, looks like 6.10 kills varargs dead
19:50:25 <Axman6> are MVars blocking?
19:50:31 <sw17ch> yes
19:50:34 <Axman6> ok, good
19:50:39 <byorgey> is there a monadic version of unfoldr hiding anywhere?
19:50:49 <byorgey> @type unfoldr
19:50:50 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:51:20 <byorgey> i.e. I want  Monad m => (b -> m (Maybe (a,b))) -> b -> m [a]
19:51:32 <byorgey> I'm guessing I'll just have to write it myself
19:52:47 <sw17ch> that's not something djinn could do, is it?
19:53:02 <gwern> d'oh. so I carefully and lovingly worked out a haskell script on paper completely, and when I type it in, it compiles and works the first time
19:53:09 <thoughtpolice> no, it can't handle type-class polymorphism (i.e. ad-hoc)
19:53:11 <gwern> except I got the spec wrong
19:53:13 <gwern> -_-
19:53:53 <thoughtpolice> in general djinn can only deal with actual parametric polymorphic types, i.e. a -> a
19:54:40 <byorgey> gwern: hehe, doh
19:54:47 <gwern> it was a nice script. I even got it into 'interact' form :(
19:55:04 <byorgey> I think djinn also can't do lists
19:56:08 <gwern> on a side note, 'interact' is so cool. I look forward to the day we can use that style in more than just commandline text filter script stuff
19:56:32 <gwern> (interact is, I understand, an example of FRP)
19:57:01 <conal> gwern: see TV for a generalization of interact.
19:57:02 <conal> @wiki TV
19:57:03 <lambdabot> http://www.haskell.org/haskellwiki/TV
19:57:37 <ivanm> conal: what does television have to do with interacting? acting, yes... but interacting? I thought TV _prevented_ people form interacting...
19:57:38 <ivanm> ;-)
19:57:40 <conal> hm.  i don't know how interact and frp might relate.
19:57:43 <gwern> conal: no no, I'll wait until you or someone else goes on -cafe and says 'by gum, we got it with this frp library. its performant, it has a nice api, etc.'
19:57:47 <sw17ch> dons: I'm hoping to stick scurry in hackage tomorrow
19:58:00 <ivanm> sw17ch: what's scurry?
19:58:13 <sw17ch> ivanm: P2P VPN concept in haskell
19:58:17 <thoughtpolice> sw17ch: did you ever get it working on OS X? if not i might be able to help
19:58:32 <ivanm> sw17ch: ooohhhh...
19:58:34 <sw17ch> thoughtpolice, well, i'm looking for windows and OSX champions actually...
19:58:53 <sw17ch> i'm trying to figure out the damn tun/tap driver in windows... but there's like a billion flavors, and none of them are packaged individually
19:59:05 <sw17ch> no, that's not true
19:59:11 <sw17ch> TAP-Win32
19:59:33 <sw17ch> is the driver i'm planning on using, and i've been looking over the code Qemu uses to talk to tap drivers, along with tinc's code and openvpn's code
19:59:56 <sw17ch> but you need to mess around with the windows registry... and you need to know something about the windows registry...
20:00:03 <sw17ch> and i'm entirely lost
20:00:47 <conal> gwern: TV isn't about FRP (at least in my thinking).  it's a sort of deconstruction and generalization of interact.  it's composable interfaces.
20:02:07 <sw17ch> so, thoughtpolice, i'd love the help :)
20:02:22 <thoughtpolice> sw17ch: i'll look into it :]
20:02:48 <sw17ch> it should only involve adding a help-osx.c file to my sources... here: http://code.google.com/p/scurry/source/browse/#svn/trunk/src/C
20:02:49 <lambdabot> Title: scurry - Google Code
20:03:03 <sw17ch> i figure, the interface involves 2 functions
20:03:07 <gwern> http://hpaste.org/11775 <-- code thoughts?
20:03:15 <sw17ch> and it's basically unique code for each platform
20:03:28 <gwern> conal: oh noes, now I'm confused. I was thinking of FRP as 'interact for everybody!'
20:03:28 <sw17ch> so, i'm having cabal decide which file to pull in based on the OS
20:05:33 <conal> gwern: FRP is a compositional theory/library of dynamic/time-varying values.  a functional alternative to state for thinking about change.
20:06:22 <conal> i think of interact as a way of slapping a (crude) user interface on top of an otherwise pure/composable function.
20:06:29 <gwern> conal: I am a Bear of Very Little Brain, and Large Words hurt my Head :)
20:07:21 <sjanssen> gwern: http://hpaste.org/11775#a1
20:07:24 <conal> gwern: np.  FRP helps you talk about stuff that changes over time.
20:08:03 <Cale> conal: Have you seen MonadPrompt by the way? It would be interesting to see what you make of it. :)
20:08:25 <Cale> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.1/doc/html/src/Control-Monad-Prompt.html
20:08:27 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5zzxue
20:08:52 <gwern> sjanssen: ah, I see. you modify the list and return it, instead of constructing a new one
20:09:19 * gwern has yet to learn when to use const
20:09:33 <dibblego> gwern, in place of \_ ->
20:09:42 <dolio> Never. \_-> is shorter. :)
20:09:53 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=247 has the State monad example fleshed out a little more.
20:09:54 <sjanssen> gwern: well, no lists are ever modified in Haskell
20:10:14 <conal> Cale: no, i hadn't.  it looks sequential & discrete.
20:10:15 <gwern> although I'm not sure intercalate is worth it, as it doesn't shorten it much and adds an import
20:10:19 <gwern> @hoogle intercalate
20:10:19 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
20:10:19 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
20:10:19 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
20:10:27 <sjanssen> gwern: yeah, that change is less clear
20:10:52 <pumpkin> @src intercalate
20:10:52 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
20:11:31 <Cale> conal: The neat thing about it is that the computations in this monad are abstractly specified by the given GADT and only given semantics by the run function.
20:11:58 <sw17ch> thoughtpolice, I added a page detailing the usage information: http://code.google.com/p/scurry/wiki/Usage?ts=1225944690&updated=Usage
20:12:00 <lambdabot> Title: Usage - scurry - Google Code - How to use Scurry, http://tinyurl.com/63acco
20:12:18 <Cale> (the primitive computations)
20:12:22 <sjanssen> gwern: [((erase a), b), (a,b)] ++ [(a, (erase b)), (a,b)] feels like duplication
20:13:10 <gwern> it is
20:13:38 <gwern> but the trouble is that I need the unmodified a,b pair so I can use it as the answer
20:14:06 <gwern> and if I wanted tabify to have the answer state in a sense, it would mess up the map
20:15:53 <sjanssen> [f erase (a, b) | f <- [first, flip const, second, flip const]] -- less duplication, more code
20:17:09 <x6d65> Is it impossible to match against a partially-applied constructor?
20:17:34 <sjanssen> x6d65: yes
20:17:45 <sjanssen> directly, anyway
20:18:21 <sjanssen> you could saturate it with dummy arguments and inspect the result, but that isn't exactly the same thing
20:18:37 <x6d65> I have (for example) a constructor (Foo Int Int), and I'd like to match on, say, (Foo 5).
20:18:54 <sjanssen> x6d65: pattern matching on functions is not allowed
20:19:14 <x6d65> I suppose that makes pretty good sense.
20:19:47 <x6d65> In this case, I think it's fine to fill it with dummy data.
20:19:59 <x6d65> Although it feels a little dirty.
20:21:27 <Axman6> concurrency ftw: fromfLriosmtL i[s0t, 1[,02,,13,,24,,38,,41,8,16,32,64]
20:24:22 <Cale> conal: A nice thing about it is that you can use it to define, for instance, how a game is played, and then implement separate run functions to handle a real player (in terms of IO), and an AI player (in terms of pure computations)
20:25:57 <conal> Cale: nice.
20:26:24 <conal> Cale: i like that abstraction.  just not the sequential & effectful style.
20:30:28 * juhp is building ghc-6.10.1 with shared libs on linux
20:45:08 <dons> sw17ch: i'm not sure it can kill varargs dead. there's bindings to varargs thingies in the base library..
20:45:32 <dons> btw peoples, can i recommend the haskell subreddit, friendly and full of relevant content, http://www.reddit.com/r/haskell
20:45:34 <lambdabot> Title: Haskell
20:45:37 * dons is a convert
20:46:43 <dolio> Hey dons. Have you done any thinking about memcpy in uvector?
20:47:57 <dons> i need to get back into uvector hacking
20:48:10 <dolio> Yeah. I've been slacking myself.
20:48:10 <dons> it was my big project for the year, but somehow work and books got in the way
20:56:52 <shapr> dons: Is there any good way to take advantage of the Cell cpu from Haskell?
21:01:20 <dons> from speaking to other people, the question is: is there any good way to take advantage of the Cell cpu.
21:01:22 <juhp> Invalid repository:  http://code.haskell.org/yi
21:01:29 <lambdabot> Title: Index of /yi
21:01:30 <dons> hey juhp
21:01:35 <shapr> hiya juhp
21:01:43 <juhp> hi guys!
21:01:44 <dons> shapr: there was a paper at ICFP about trying to run erlang on the cell
21:01:51 <dons> they decided on C++ in the end, and it was still damn hard
21:01:59 <dons> makes gpgpus look simple
21:02:16 <shapr> Know keywords for the title?
21:03:22 <dons> mm. thinking ...
21:04:36 <juhp>   -rwxr-xr-x  1 petersen petersen  6308314 2008-11-06 14:23 libHSbase-4.0.0.0-ghc6.10.1.so
21:04:46 <juhp> hmm I like this
21:05:27 * shapr tries "for x in `cabal list|grep -e '^ \*'|cut -d '*' -f 2`; do cabal install $x; done;
21:05:37 <dons> shapr: http://www.icfpconference.org/icfp2008/accepted/10.html
21:05:42 <lambdabot> Title: ICFP 2008 - Experience Report: Erlang in Acoustic Ray Tracing
21:05:58 <dons> the experience was: "Attempts to use Erlang on the IBM Cell BE microprocessor were frustrated by Erlang's memory footprint. "
21:06:46 <shapr> Um, where's the paper itself?
21:06:56 * shapr googles
21:07:09 <dons> might have to write to the authors
21:07:20 * shapr grumbles
21:07:24 <dons> btw, i found it be looking at galois' tweet feed, http://twitter.com/galoisinc?page=7
21:07:25 <lambdabot> Title: Twitter / galoisinc
21:07:41 <shapr> smart!
21:12:33 <BMeph> http://homepage.cs.uri.edu/faculty/hamel/pubs/icfp08.pdf
21:12:35 <lambdabot> Title: Experience Report: Erlang in Acoustic Ray Tracing
21:12:43 <dons> good work , BMeph
21:12:53 <dons> uri.edu, is that real? :)
21:14:59 <obamapoo> OK Obamallamas.......be prepared for the massive urban chimpouts, the concession for KFC in the white house cafeteria, and for America to get Nigggerfuxated in general!!!!!
21:15:20 <BMeph> dons: Univ. of Rhode Island; why wouldn't it exist?
21:15:23 --- mode: ChanServ set +o dons
21:15:25 --- mode: ChanServ set +o dons
21:15:27 --- mode: dons set +b *!*=48cf149f@gateway/web/ajax/mibbit.com/x-c4f9cb213b39ce17
21:15:27 --- kick: obamapoo was kicked by dons (dons)
21:15:48 <EvilTerran> dons++
21:15:56 <dons> BMeph: 'uri' sounds like a fake uri
21:15:59 --- mode: ChanServ set -o dons
21:16:04 <Pseudonym> It's good not being the most populous channel.
21:16:08 <Pseudonym> We get a warning.
21:16:11 <richcollins> Im trying to follow the directions for installation here: http://www.haskell.org/ghc/download_ghc_6_10_1.html#x86_64linux
21:16:12 <lambdabot> Title: GHC: Download version 6.10.1
21:16:17 <BMeph> dons: Better send a letter to Providence, then... :)
21:16:32 <richcollins> I got the error /usr/bin/strip: /usr/local/lib/ghc-6.10.1/ghc-pkg: File format not recognized
21:16:35 <dons> mm
21:16:43 <dons> richcollins: are you on x86_64?
21:16:46 <richcollins> yeah
21:17:03 <dons> what does uname -msr  say?
21:17:35 <richcollins> Linux 2.6.16.29-xen x86_64
21:18:04 <dons> mm.
21:18:17 <dons> ask in #ghc, Igloo might be able to help
21:19:40 <richcollins> ok thanks
21:21:34 <juhp> richcollins: if you want an rpm you could try the ghc build for fedora
21:21:55 <richcollins> I don't really care about having a package
21:22:00 <richcollins> I just wanted to install a binary
21:23:20 <dons> i'm not sure what's going on. there've been no other reports.
21:24:43 <richcollins> hrm
21:26:24 <twb> In Python, it's typical to define a function at the bottom of a module so that you can invoke the module as a script, and it will run some example code or unit tests.
21:26:32 <twb> Is this possible with Haskell?
21:26:58 <mofmog> main
21:27:12 <mofmog> er
21:27:51 <twb> mofmog: AFAICT that doesn't work if you have a "module Foo where" at the top
21:28:08 <twb> Except for the special case where Foo = Main, which isn't what you get in proper modules.
21:28:26 <dons> twb: yeah. just define your quickcheck properties and run those from a ghci wrapper
21:28:33 <dons> there's lots of other ways to do this too
21:28:38 <rwbarton_> twb: Not even with ghc -main-is=... or whatever
21:28:42 <rwbarton_> twb: ?
21:28:44 <dons> ther'es even a quickcheck binary that runs anything in the file with 'prop_' prefix
21:28:56 <dons> its all fairly straight forward
21:29:15 <twb> dons: well actually the "main" function I wanted to write is one that just turns stdin into a string, applies the module's main function to it, then either exits or prints an error and exits.
21:29:25 <twb> rwbarton_: hmm, I didn't test that
21:30:40 <dons> main-is also works. Main.runthisinstead
21:41:14 <alc> can we change lambdabot's commandPrefixes at runtime?
21:41:22 <juhp> hmm 6.10.1 seems to break quite a few libs...
21:41:32 <juhp> as usual
21:43:30 <richcollins> I installed ghc using apt, but it doesn't appear to have module Network.URI  How do I install it?
21:44:57 <Cale> apt-get install libghc6-network-dev ?
21:45:02 <twb> apt-get install- damn, you beat me
21:45:37 <richcollins> ah ok thanks
21:46:30 <Cale> richcollins: If you're planning to do a lot of Haskell development though, eventually you're going to want to install cabal-install, which you can get from hackage here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
21:46:36 <lambdabot> Title: HackageDB: cabal-install-0.6.0, http://tinyurl.com/2sj7lw
21:46:54 <richcollins> Cale: I'm installing it so I can install darcs - but thanks for the advice :-)
21:47:06 <Cale> ah :)
21:51:39 <twb> richcollins: hi, I'm the Debian darcs maintainer!
21:51:44 <twb> richcollins: what seems to be the trouble?
21:52:15 <richcollins> twb: darcs 1.09 is the most recent version according to aptitude
21:52:19 <richcollins> Do you have a 2.1 out?
21:52:34 <twb> richcollins: what version of Debian are you running, Etch?
21:53:04 <richcollins> twb: I don't remember - can you remind me how to check?
21:53:27 <twb> richcollins: let's take this to #darcs
21:53:32 <richcollins> k
22:01:43 <twb> hayoo doesn't work in emacs-w3m :-(
22:02:50 <dolio> It seems pretty ajaxy.
22:03:32 <twb> I don't have a problem with people using js to make FF users happier
22:03:43 <twb> But I wish they wouldn't make the app completly break without js
22:14:32 <twb> How can I test if a Char is whitespace or punctuation?
22:14:52 <twb> I'm trying to approximate this perl expression:
22:14:53 <twb> $word =~ s/(^\')|[^\w\xc0-\xd6\xd8-\xf6\xf8-\xff\'-]+|(\'\z)//g;
22:15:27 <shapr> For Haskell fun while you sleep, try this: for x in `cabal list|grep -e '^ \*'|cut -d '*' -f 2`; do cabal install $x; done;
22:15:29 <twb> i.e. delete from the string anything that's not a letter, modulo some exceptions.
22:16:53 <twb> shapr: I would do: map cabal install -- `cabal list | awk '/^  \* / {print $2}'`
22:17:04 <dibblego> @type (||) <$> isSpace <*> (`elem` [','..'/']) -- punctuation list
22:17:05 <lambdabot> Char -> Bool
22:17:42 <Draconx> @type isPunctuation
22:17:43 <lambdabot> Char -> Bool
22:17:50 <dibblego> oooh
22:17:55 <dibblego> @type (||) <$> isSpace <*> isPunctuation
22:17:57 <lambdabot> Char -> Bool
22:18:00 <twb> dibblego: ah, of course.
22:18:17 <dibblego> @src isPunctuation
22:18:18 <lambdabot> Source not found. Are you on drugs?
22:18:56 <twb> Odd, isPunctuation is listed in Data.Char.
22:19:13 <dibblego> Even, lambdabot is retarded
22:20:58 <Cale> The @src plugin just reads from its own database of source for various functions.
22:26:28 <twb> Hmm.
22:26:45 <twb> Filtering by isLetter:
22:26:50 <twb> $ ghc --make Spelling && ./Spelling <<<"Good mörning, Harlold (א₀)!"
22:26:50 <twb> GoodmrningHarlold
22:27:13 <twb> WTF, is it treating my input as a byte stream instead of UTF-8?
22:27:26 <twb> (Using `interact`)
22:27:54 <_dolio> What ghc version?
22:27:58 <twb> 6.8
22:28:15 <_dolio> Yeah, it doesn't do unicode I/O.
22:28:20 <twb> Ugh.
22:28:30 <_dolio> In 6.10 they finally fixed it to do locale-based I/O.
22:28:41 <twb> I suppose I'll just test with ASCII for now, though it pains me to do so
22:28:49 <_dolio> The utf8-string package on hackage might have a UTF8-aware interact.
22:30:07 <rwbarton_> Did they really?  I know that was in the plan at some point, but I didn't see it in the release notes
22:30:23 <dolio> I guess it doesn't, but it's easy enough to write it in terms of their getContents and putStr.
22:30:51 <dolio> I certainly thought it was on the list...
22:32:00 <rwbarton_> Oh, I didn't look at the full release notes
22:32:48 <dolio> Oh, crap, I can't test in ghci, because editline doesn't do unicode...
22:34:14 <glguy> dolio, actually, I haven't pushed the version of utf8-string with interact
22:34:38 <dolio> echo 'Good mörning, Harlold (א₀)!' | ghc -e "interact id" ==> Good mörning, Harlold (א₀)!
22:34:42 <glguy> but: interactUT8 f = interact (encodeString . f . decodeString) is easy to write using utf8-string...
22:35:16 <dolio> So, it looks like it's in.
22:35:32 <glguy> dolio, that doesn't tell you anything
22:35:45 <glguy> just that the utf8 bytes weren't mangled by id
22:35:50 <dolio> Oh, right.
22:35:58 <glguy> try asking the length
22:35:58 <rwbarton_> Use something like length
22:35:59 <glguy> of the input
22:36:14 <twb> This looks to be a rough approximation of the perl expression:
22:36:15 <twb> map (xfilter isLetter) . words . map toLower
22:37:02 <dolio> 32. That looks wrong.
22:37:22 <rwbarton_> the release notes don't contain the string "utf"
22:39:41 <dolio> Yeah, I compiled a program that prints that string and it's wrong.
22:39:46 <dolio> So I guess that didn't go in.
22:40:54 <dolio> (ghc -e appears to not be a good test for that, since it uses the same bugged input to read in the program (and thus string).)
22:41:27 <dolio> Or, however it handles command line arguments.
22:41:38 <twb> In what module of the utf8-string package is interactUTF8?
22:41:56 <Beelsebob_> it isn't
22:42:02 <Beelsebob_> glguy: said its easy to write
22:42:10 <Beelsebob_> encodeString and decodeString are in UTF8
22:42:20 <glguy> I'll add "interact" now...
22:42:32 <glguy> save everyone else the hassle
22:43:21 * Beelsebob_ loves interact -- it's like reactive, only no one had quite figured out how it should do things in general yet
22:45:08 <mmorrow> that's an interesting statement
22:47:09 <twb> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
22:47:10 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
22:47:10 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
22:47:10 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
22:47:21 <twb> Thought so
22:47:40 <twb> :t zip
22:47:41 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
22:50:16 <nha_> how hard would it be to get a simple 1 line patch added to the official hOpenGL binding?
22:50:54 * glguy uploaded utf8-string-0.3.3 , now with more interact ;)
23:00:26 <dmwit> nha_: I guess you should ask the HOpenGL maintainer that. =)
23:02:57 <nha_> yea i got the impression that he wasnt actively maintaining it though
23:03:20 <twb> Waah, my code passes type checking, but still doesn't work
23:04:15 <dolio> Unpossible!
23:05:27 <twb> http://hpaste.org/11776
23:06:11 <twb> My second test also returns []
23:06:44 <twb> I suppose it could be because "foo" == "foo" does an object comparison instead of a "deep" comparison, but AFAIK Haskell always does the latter.
23:10:05 <twb> Aha, the problem is that zip doesn't do what I thought it does
23:10:40 <twb> @zip [1,2,3] [5,7,11]
23:10:40 <lambdabot> Maybe you meant: bid id map
23:11:00 <ski> > [1,2,3] `zip` [5,7,11]
23:11:02 <lambdabot>   [(1,5),(2,7),(3,11)]
23:11:24 <rwbarton_> This reverse $ foldl check [] stuff is written very oddly
23:11:27 <twb> I want to compare every word in the input against every mistake in the blacklist
23:11:34 <twb> rwbarton_: it's my Scheme background :-(
23:11:35 <ski> > concat (zipWith (\x y -> [x,y]) [1,2,3] [5,7,11])
23:11:36 <lambdabot>   [1,5,2,7,3,11]
23:11:55 <ski> oh
23:11:57 <rwbarton_> twb: isn't it just a filter?
23:12:19 <rwbarton_> twb: Anyways, you don't want zip, like you realized.
23:12:31 <ski> > return (,) `ap` [1,2,3] `ap` [5,7,11]
23:12:32 <lambdabot>   [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:12:43 <ski> (or `liftM2')
23:12:54 <dmwit> yeah
23:12:54 <ski> but here probably `filter' on the whole list suffices
23:13:30 <rwbarton_> twb: What do you mean "My second test also returns []"?
23:13:41 <roconnor> (,) <$> [1,2,3]<*>[5,7,11]
23:13:44 <roconnor> > (,) <$> [1,2,3]<*>[5,7,11]
23:13:45 <lambdabot>   [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:13:47 <twb> ∀ m in Mistakes · ∀ w in Words · if fst m = w, collect m □
23:14:00 <twb> roconnor: spellCheck "Acess!  I need ACCESS!" == [("acess", "access")]
23:14:08 * ski doesn't like `<$>',`<*>' ..
23:14:25 <ski> s/roconnor/rwbarton_/
23:14:33 <twb> so-rry
23:14:37 <rwbarton_> twb: [ m | w <- ws, m <- blacklist, fst m == w ]
23:15:01 <rwbarton_> twb: that's the output I get, isn't that what you want?
23:15:05 <twb> rwbarton_: won't that map over ms and ws together?
23:15:13 <ski> twb : no
23:15:20 <rwbarton_> twb: it's like a nested loop if you like
23:15:31 <twb> rwbarton_: oops, my test is conveniently working
23:15:44 <ski> twb : multiple generators in list comprehensions will be combined in every possibly way (not parallel)
23:15:45 <twb> rwbarton_: try spellCheck "Access!  I need ACESS!"
23:15:53 <rwbarton_> Right, that won't work.
23:15:54 <twb> ski: OK, thanks
23:15:55 <mmorrow> , [$i| (,) [1,2,3] [5,7,11] |]
23:16:10 <lunabot>  [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:16:15 <dmwit> NDP?
23:16:18 <ski> > [(x,y) | x <- [1,2,3] , y <- [5,7,11]]
23:16:19 <lambdabot>   [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:16:38 <ski> > [(x,y) | x <- [1,2,3] | y <- [5,7,11]]  -- parallel list comprehension extension
23:16:39 <lambdabot>   [(1,5),(2,7),(3,11)]
23:16:48 <dmwit> clever!
23:17:05 <mmorrow> , [(x,y) | x <- [1,2,3] | y <- [5,7,11]]
23:17:07 <lunabot>  [(1,5),(2,7),(3,11)]
23:17:16 <ski> dmwit : ?
23:17:17 <dmwit> ski: Ah, it's an extension.
23:17:47 <dmwit> ski: I thought that somehow desugared to some list monad code that magically did a parallel comprehension, but I see now that it has to be explicitly supported.
23:18:12 <ski> > do x <- [1,2,3]; y <- [5,7,11]
23:18:12 <lambdabot>   <no location info>:
23:18:12 <lambdabot>      The last statement in a 'do' construct must be an ...
23:18:24 <ski> > do x <- [1,2,3]; y <- [5,7,11]; return (x,y)  -- too fast
23:18:25 <lambdabot>   [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:19:09 <dmwit> > liftM2 (,) [1..3] [5,7,11]
23:19:10 <lambdabot>   [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:20:12 <mmorrow> , (`id` [1..3]) . fmap . (,) =<< [5,7,11]
23:20:14 <lunabot>  [(5,1),(5,2),(5,3),(7,1),(7,2),(7,3),(11,1),(11,2),(11,3)]
23:20:33 <mmorrow> , (`id` [5,7,11]) . fmap . (,) =<< [1..3]
23:20:35 <lunabot>  [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:20:36 <mmorrow> ;)
23:20:39 <ski> > pure (,) <*> [1,2,3] <*> [5,7,11]  where pure = Control.Applicative.pure
23:20:40 <lambdabot>   [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:20:41 <ski> > getZipList (pure (,) <*> ZipList [1,2,3] <*> ZipList [5,7,11])  where pure = Control.Applicative.pure
23:20:42 <lambdabot>   [(1,5),(2,7),(3,11)]
23:20:54 <ski> (was what i meant to say)
23:21:28 <mmorrow> , zipWith (fmap . (,)) [5,7,11] (repeat [1..3])
23:21:30 <lunabot>  [[(5,1),(5,2),(5,3)],[(7,1),(7,2),(7,3)],[(11,1),(11,2),(11,3)]]
23:21:36 <mmorrow> , id =<< zipWith (fmap . (,)) [5,7,11] (repeat [1..3])
23:21:38 <lunabot>  [(5,1),(5,2),(5,3),(7,1),(7,2),(7,3),(11,1),(11,2),(11,3)]
23:23:30 <mmorrow> @src join
23:23:31 <lambdabot> join x =  x >>= id
23:23:45 <mmorrow> , join [[]]
23:23:47 <lunabot>  []
23:24:03 <mmorrow> (parenthetical remark)
23:29:36 <ski> (parenthetical response)
23:30:43 <mmorrow> (this is not a parenthetical pipe)
23:32:10 <mmorrow> (ceci n`est pas une parenthetical pipe)
23:32:33 * mmorrow goes to sleep
23:33:29 <ski> ceci n`est pas une pipe, pas du tout
23:37:52 <ski> > (join . map getZipList . getZipList) (pure (fmap . (,)) <*> ZipList [1,2,3] <*> pure (ZipList [5,7,11]))  where pure = Control.Applicative.pure
23:37:53 <lambdabot>   [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:38:36 <dmwit> yuck
23:39:17 <ski> ?
23:44:01 <Taejo> @undo [(x, y) | x <- [1,2,3], y <- [5, 7, 11]]
23:44:02 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [5, 7, 11]) [1, 2, 3]
23:44:11 <Taejo> @pl concatMap (\ x -> concatMap (\ y -> [(x, y)]) [5, 7, 11]) [1, 2, 3]
23:44:12 <lambdabot> ([5, 7, 11] >>=) . flip flip [] . ((:) .) . (,) =<< [1, 2, 3]
23:45:40 <Taejo> > concatMap (\ x -> concatMap (return . (x,)) [5, 7, 11]) [1, 2, 3]
23:45:42 <lambdabot>   <no location info>: parse error on input `)'
23:48:52 <ski> > concatMap (\ x -> concatMap (return . (,) x) [5, 7, 11]) [1, 2, 3]
23:48:53 <lambdabot>   [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:49:16 <Taejo> oh d'oh
23:49:16 <ski> (no tuple sections):
23:49:22 <Taejo> yeah
23:49:46 <Taejo> @pl \ x -> concatMap (return . (,) x)
23:49:47 <lambdabot> fmap . (,)
23:50:08 <Taejo> @pl (\ x -> concatMap (return . (,) x) [5, 7, 11])
23:50:09 <lambdabot> (`fmap` [5, 7, 11]) . (,)
23:50:33 <Taejo> > concatMap ((`fmap` [5, 7, 11]) . (,)) [1, 2, 3]
23:50:34 <lambdabot>   [(1,5),(1,7),(1,11),(2,5),(2,7),(2,11),(3,5),(3,7),(3,11)]
23:50:51 <Taejo> much better
23:54:02 <Taejo> @src fmap []
23:54:02 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:54:07 <Taejo> @src [] fmap
23:54:08 <lambdabot> fmap = map
23:55:47 <Nafai> Hi sm
23:58:40 <adu> hi
