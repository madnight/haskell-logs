00:01:52 <askentasken> solved it
00:01:56 <askentasken> can i do case-else?
00:05:46 <Korollary> Yes
00:06:10 <Cale> askentasken: btw, the usual way to indent if-then-else in Haskell is like:
00:06:12 <Cale> if foo
00:06:14 <Cale>    then bar
00:06:17 <Cale>    else quux
00:08:18 <Cale> '(fst move, snd move)' is generally the same as 'move' (except when move is undefined)
00:08:50 <Cale> But if you're going to be using the first and second part separately, pattern matching is a better plan
00:11:52 <mmorrow> ) Date()
00:11:53 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
00:11:53 <lunabotjs>  Sun Nov 16 2008 01:42:38 GMT-0600 (CST)
00:11:54 <askentasken> cant i do if with no else-branch?
00:12:58 <mmorrow> @seen dolio
00:12:58 <lambdabot> dolio is in #ghc, #haskell-blah and #haskell. I don't know when dolio last spoke.
00:13:05 <mmorrow> preflex: seen dolio
00:13:05 <preflex>  dolio was last seen on #haskell 5 hours, 17 minutes and 17 seconds ago, saying: > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6],[7,8,9]]
00:13:47 <mmorrow> , foldr (zipWith (:)) (repeat []) $ [[1,2,3],[4,5,6]]++repeat[7,8,9]
00:13:55 <lunabot>  Stack space overflow: current size 8388608 bytes.
00:13:55 <lunabot>  Use `+RTS -Ksize' to increase it.
00:14:15 <mmorrow> > foldr (zipWith (:)) (repeat []) $ [[1,2,3],[4,5,6]]++repeat[7,8,9]
00:14:17 <lambdabot>   * Exception: stack overflow
00:15:40 <askentasken> and an else cant have sevral staments?
00:15:48 <askentasken> why does this langauge have to make things so hard?
00:16:01 <askentasken> branching simple game-logic is a huge PITA
00:16:22 <sciolizer_> askentasken: if you don't need an else branch, use "when"
00:16:59 <askentasken> but i do
00:17:03 <askentasken> but i need to to much
00:18:04 <sciolizer_> Large if/else chains can usually be replaced with some kind of dispatch (pattern matching or type class instances)
00:18:13 <sciolizer_> But if you really need to chain, that is also possible.
00:18:33 <sciolizer_> > if 1 == 2 then "weird" else if 7 == 8 then "still weird" else "much better"
00:18:35 <lambdabot>   "much better"
00:18:47 <dibblego> I am guessing askentasken's misguided complaint relates to imperative languages that permit if(c) p else {q; r; }
00:19:06 <sciolizer_> ah
00:19:08 <dibblego> i.e. do-notation
00:19:37 <askentasken> can i do if x then do several thinsg else do sveral othert hings?
00:19:53 <dibblego> askentasken, yes, in the IO monad
00:20:10 <sciolizer_> askentasken: "when c $ do { q; r; }" will get you half of it
00:20:32 <sciolizer_> @hoogle Bool -> IO a -> IO a -> IO a
00:20:32 <lambdabot> Foreign.C.Error throwErrnoIf :: a -> Bool -> String -> IO a -> IO a
00:20:32 <lambdabot> Control.Exception catchJust :: Exception -> Maybe b -> IO a -> b -> IO a -> IO a
00:20:32 <lambdabot> Foreign.C.Error throwErrnoIfRetryMayBlock :: a -> Bool -> String -> IO a -> IO b -> IO a
00:21:40 <lispy> :t \a mb mc -> if b then mb else mc :: Bool -> IO a -> IO a -> IO a
00:21:40 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Expr'
00:21:40 <lambdabot>     In the predicate expression: b
00:21:40 <lambdabot>     In the expression:
00:21:49 <lispy> :t \a mb mc -> if a then mb else mc :: Bool -> IO a -> IO a -> IO a
00:21:50 <lambdabot>     Inferred type is less polymorphic than expected
00:21:50 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
00:21:50 <lambdabot>         mc :: Bool -> IO a -> IO a -> IO a (bound at <interactive>:1:6)
00:22:07 <lispy> oh kay...
00:22:25 <mmorrow> @let let skim ys zs ([]:xss) = skim ys zs xss; skim ys zs ([x]:xss) = skim (x:ys) zs xss; skim ys zs ((x:xs):xss) = skim (x:ys) (xs:zs) xss; skim ys zs [] = (reverse ys, reverse zs)
00:22:25 <lambdabot>   Parse error
00:22:29 <mmorrow> @let skim ys zs ([]:xss) = skim ys zs xss; skim ys zs ([x]:xss) = skim (x:ys) zs xss; skim ys zs ((x:xs):xss) = skim (x:ys) (xs:zs) xss; skim ys zs [] = (reverse ys, reverse zs)
00:22:30 <lambdabot>  Defined.
00:22:47 <lispy> :t (\a mb mc -> if a then mb else mc) :: Bool -> IO a -> IO a -> IO a
00:22:48 <lambdabot> forall a. Bool -> IO a -> IO a -> IO a
00:23:17 <sciolizer_> lispy: for a moment I thought you had stumbled on dependent typing
00:23:22 <dibblego> @pl \a mb mc -> if a then mb else mc -- if'
00:23:22 <lambdabot> if'
00:23:50 <lispy> sciolizer_: how so?
00:24:06 <lispy> askentasken: ^^ you can use if that way
00:24:09 <sciolizer_> \a ... -> .... :: .... IO a ...
00:24:23 <sciolizer_> Quantified type variable 'a' is mentioned in the environment
00:24:31 <sciolizer_> :)
00:24:33 <lispy> ah
00:24:43 <lispy> :t \a -> return a :: IO a
00:24:44 <lambdabot>     Inferred type is less polymorphic than expected
00:24:44 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
00:24:44 <lambdabot>         a :: a (bound at <interactive>:1:1)
00:25:01 <mmorrow> > let diag _ [] = []; diag q (xs:xss) = uncurry (:) . fmap (flip diag xss) . skim [] [] $ (q++[xs]) in diag [] ([[1,2,3],[4,5,6]]++repeat[7,8,9])
00:25:02 <lambdabot>   [[1],[2,4],[3,5,7],[6,8,7],[9,8,7],[9,8,7],[9,8,7],[9,8,7],[9,8,7],[9,8,7],...
00:25:12 <sciolizer_> :t \b -> return b :: IO b
00:25:13 <lambdabot>     Inferred type is less polymorphic than expected
00:25:13 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
00:25:13 <lambdabot>         b :: b (bound at <interactive>:1:1)
00:25:34 <sciolizer_> Well, it doesn't appear to be variable capture in lambdabot's context. :)
00:25:42 <lispy> sciolizer_: actually, I finally groked a lot of what oleg does the other day.  I realized that he does dependent typing in Haskell...but not by lifting values into the type system...instead he implement values in the type system and uses those.
00:26:16 <lispy> go read HList and think about it for a while if you don't buy it :)
00:26:35 <sciolizer_> lispy: ok :)
00:26:43 <mmorrow> @let diag = let go _ [] = []; go q (xs:xss) = uncurry (:) . fmap (flip go xss) . skim [] [] $ q++[xs] in go []
00:26:44 <lambdabot>  Defined.
00:26:51 <mmorrow> , diag (repeat [0..])
00:26:53 <lunabot>  luna: Not in scope: `diag'
00:26:53 <mmorrow> > diag (repeat [0..])
00:26:54 <lambdabot>   [[0],[1,0],[2,1,0],[3,2,1,0],[4,3,2,1,0],[5,4,3,2,1,0],[6,5,4,3,2,1,0],[7,6...
00:26:55 <lispy> data True; data False; class Boolean a where; instance Boolean True; instance Boolean False;
00:27:05 <lispy> sciolizer_: now you have True/False in the type system :)
00:27:18 <mmorrow> > tails [0..]
00:27:19 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
00:27:25 <sciolizer_> lispy: the first thing of his that ever blew me away was his vectored merge sort
00:27:29 <mmorrow> > iterate tails [0..]
00:27:30 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
00:27:30 <lambdabot>        Expect...
00:27:34 <mmorrow> > iterate tail [0..]
00:27:35 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
00:27:49 <sciolizer_> lispy: probably would have been easier to understand if I started with something simpler :)
00:27:52 <mmorrow> > diag (tails [0..])
00:27:53 <lambdabot>   [[0],[1,1],[2,2,2],[3,3,3,3],[4,4,4,4,4],[5,5,5,5,5,5],[6,6,6,6,6,6,6],[7,7...
00:28:04 <jeffwheeler> > repeat [0..]
00:28:05 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
00:28:09 <lispy> sciolizer_: heh, I'm not familiar with that, but I'm sure it's impressive
00:28:26 <jeffwheeler> That's neat; (the diag trick).
00:28:42 <mmorrow> diag uses the same method that you use to show that Q is countable
00:29:16 <mmorrow> (but instead of making pairs, it makes lists, so a slight variation on the Q thing)
00:30:52 <askentasken> hmm, i need to chain together some dos
00:31:17 <askentasken> like playerMove - checkWinner - computerMove - checkWinner and if there is a winner then abort
00:31:43 <lispy> if you're using a lot of dos you might try unix...
00:31:54 <sjanssen> har har har
00:32:29 <sciolizer_> If going unix is too much for you, circumcision is a nice compromise.
00:32:30 * mmorrow commonly wishes for a way to express the drum-thing-after-a-joke (ba dum ching or something) in text
00:33:02 <lispy> sorry, I couldn't figure out what 'dos' means other than MS Dos...so you get my lame joke :)
00:33:14 <askentasken> do
00:33:19 <sciolizer_> askentasken: those functions sound like they could be pure. They don't sound like functions that need side effects.
00:33:24 <askentasken> in plural do's ?
00:33:38 <askentasken> scio: i do some printing in them
00:33:48 <sciolizer_> askentasken: oh ok
00:34:10 <sciolizer_> askentasken: you can chain dos by calling them from inside another do.
00:34:21 <sciolizer_> askentasken: or use the bind operators (>>) and (>>=)
00:34:45 <adu> I did it!
00:35:15 * lispy thinks swik exists entirely to fool unsuspecting googlers and then display nothing useful
00:35:23 <lispy> adu: ?
00:35:32 <mmorrow> @nixon
00:35:32 <lambdabot> I am not a crook.
00:35:36 <mmorrow> hehe
00:35:39 <jeffwheeler> lispy: it's true
00:35:40 <adu> I wrote a general diff
00:36:17 <askentasken> how can i pass on values with >> ?
00:36:19 <adu> it should work for both lines or characters or both :)
00:36:29 <mmorrow> askentasken: use >>=
00:36:34 <mmorrow> @src (>>)
00:36:34 <lambdabot> m >> k      = m >>= \_ -> k
00:37:00 <adu> @src diff
00:37:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:37:06 <askentasken> gameLogic bs = do
00:37:06 <askentasken>   print bs
00:37:06 <askentasken>   playerMove bs >>= hasWinner bs >>= gameLogic bs
00:37:13 <mmorrow> (>>) exists for exactly the situation when you /don't/ want to pass a value
00:37:13 <askentasken> does that work?
00:37:24 <askentasken> no
00:37:24 * Beelsebob wonders why >> isn't written as m >>= const k
00:37:52 <mmorrow> if the types are as follows it'd work:
00:37:53 <sciolizer> askentasken: playerMove bs >>= hasWinner >>= gameLogic, perhaps?
00:38:12 <adu> asken: what's bs?
00:38:14 <mmorrow> playerMove :: (Show a) => a -> IO b
00:38:25 <mmorrow> hasWinner :: b -> IO c
00:38:33 <mmorrow> oops
00:38:40 <mmorrow> hasWinner :: a -> b -> IO c
00:38:50 <mmorrow> gameLogic :: a -> c -> IO d
00:38:56 <Beelsebob> why would any of playerMoves, hasWinner and gameLogic be monadic?
00:38:57 <mmorrow> so then
00:39:00 <Beelsebob> let alone IO
00:39:13 <mmorrow> gameLogic :: a -> IO d
00:39:24 <adu> mmorrow: thats beter
00:39:53 <sciolizer> Beelsebob: output
00:39:53 <mmorrow> oh, heh, i didn't catch the fact that gameLogic was calling itself until after you said that
00:40:06 <Beelsebob> sciolizer: yeh -- and why does your gameLogic output anything?
00:40:14 <Beelsebob> why does checking if there's a winner output anything?
00:40:16 <mmorrow> was treating the recursive call as some other function
00:40:27 <askentasken> Beelsebob: Because i print the boardin payerMove, hasWinner isnt though
00:40:36 <askentasken> cnt i chain a pure function with a moand?
00:40:46 <Beelsebob> askentasken: so why not change your program, so that playerMove merely returns a board state
00:40:47 <mmorrow> oh wait, yeah so gameLogic wouldn't typecheck then
00:41:01 <Beelsebob> then you can restrict IO to a specific printing function
00:41:10 <Beelsebob> and get on with being nice and purely functional
00:41:18 <askentasken> http://hpaste.org/12084 <- my uly program
00:41:59 <askentasken> well id still need input
00:42:09 <adu> lispy: now that I have honed my LCS skills, I'm confident I could integrated into Darcs by next week :)
00:42:26 <askentasken> basically gameLogic flow would be : impure -> pure -> impure -> pure etc
00:42:32 <mmorrow> adu: have you checked out sclv's Diff package?
00:42:37 <adu> lispy: oh, did I show you my Darcs graph?
00:43:30 <adu> mmorrow: nope, just lcs-0.2 and darcs/src/Lcs
00:44:27 <mmorrow> adu: oh cool, so a diff algo then i guess
00:44:36 <askentasken> aqnd randMove has to be monadic right?
00:44:57 <mmorrow> (Diff implems the algo diff(1) uses)
00:45:18 <adu> mmorrow: also, if you wanted to check out my algo, here it is: http://hpaste.org/12085
00:45:32 <mmorrow> sweet :)
00:45:49 <lispy> adu: nice
00:46:13 <adu> its short and slow :)
00:48:40 <sciolizer> asken: I annotated a version that compiles.
00:49:45 <ddarius> mmorrow: http://en.wikipedia.org/wiki/Sting_(percussion)
00:49:47 <askentasken> ok i have it now but how can i break out from a monad if a if is true?
00:50:44 <Saul_> I've been having problems with cabal-install since I installed 6.10
00:50:50 <adu> and I chose (Diff Int [a] [a]) as the output, because this is very similar to the output darcs uses in getChanges
00:51:19 <adu> which iirc, is something like (Int, [PackedString], [PackedString])
00:51:57 <mmorrow> here's my progress on implementing http://www.cs.uu.nl/research/techreps/repo/CS-2004/2004-052.pdf
00:52:01 <lambdabot> Title: The Lazy Virtual Machine specification
00:52:05 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=486#a486
00:52:16 <adu> askentasken: theres always throw & catch
00:52:27 <mmorrow> this is not aimed at being a "performance" impem just yet..
00:52:56 <Saul_> It just stays at "Resolving dependencies..." and it seems to take an extreme amount of processing power (up to the point that I can hardly switch programs and my music won't even play anymore)
00:53:10 <Saul_> Does anyone know what's wrong?
00:53:29 <adu> askentasken: but generally, if you want to do lots of testing, do something like ioFunc = do if x then return () else do something ; if y then return() else do soethingElse...
00:53:40 <mmorrow> ddarius: haha, nice.
00:54:00 <jeffz> Saul_: is it using a lot of memory too?  I've seen that happen once or twice
00:54:09 <Saul_> I'll check
00:54:13 <sciolizer> hpaste announce is not working?
00:54:23 <adu> askentasken: it does mess with indentation a little bit, but that shouldn't be a problem...
00:54:27 <sciolizer> asken: check again, but it's just what adu was saying
00:54:32 <mmorrow> that bot met a bitter end
00:54:50 <ddarius> mm_freak: If I'm any indication, most people will understand "rimshot" but will not understand "sting"
00:54:57 <sciolizer> so, bots are replace-able, right?
00:55:13 <mmorrow> heh, good point
00:55:22 <sciolizer> :)
00:56:49 <Saul_> jeffz: It does, at first only my first core shoots to a 100%, then the second slowly but surely follows, taking the memory with it
00:57:06 <Saul_> jeffz: And there is no noticable increase in network usage
00:57:10 <lispy> Saul_: sonuds like a bug in the dependency solver?
00:57:35 <Saul_> lispy: Could be
00:58:04 <Saul_> lispy: I don't have any locally installed packages, and install globally, might that be the cause?
00:58:27 <lispy> Saul_: they have to usea constrain solver, but I would have figured it doesn't run into O(2^n) cases in practice
00:58:55 <lispy> Saul_: I don't know if where the packages install makes a difference, sorry
00:59:18 <jeffz> Saul_: you should probably check to see if someone has filed a bug report for the issue http://hackage.haskell.org/trac/hackage/wiki
00:59:20 <lambdabot> Title: Hackage - Trac
00:59:22 <adu> i'm so excited :)
00:59:32 <Saul_> lispy: Well if I try to install locally it just gives an error message saying that there is a bug they need to work out for that to work first
01:00:02 <lispy> adu: congrats :)
01:00:21 <Saul_> jeffz: I'll do that
01:00:45 <askentasken> whwre is when?
01:00:54 <jeffz> I'm still hovering on 6.8 otherwise I would
01:00:57 <sciolizer> @hoogle when
01:00:57 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
01:01:15 <adu> lispy: not only did I figure out the diff stuff, but I made some huge progress at work on Fri :)
01:01:38 <lispy> adu: very nice
01:02:08 <lispy> "-- only nushio is responsible to the unreadability of these codes."
01:02:16 <lispy> that comment ships with the monadius source :)
01:03:15 <luqui> @index when
01:03:15 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
01:04:07 <askentasken> blarf! cant i just exitFromMonadForever ?
01:04:18 <askentasken> when cond $ exitFunction
01:04:27 <lispy> :t fail
01:04:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
01:04:29 <askentasken> exitFunction = do $ print winner
01:04:50 <askentasken> i cant break otu of the gameLogic-loop
01:06:02 <sciolizer> asken: I don't understand. It's only a loop if you call gameLogic, which is only being done in the else block. In the then block, return IS the end of the loop, and execution which resume at whoever called gameLogic.
01:06:29 <sciolizer> ^which resume^resumes
01:07:02 <askentasken> well i have to loop
01:07:07 <askentasken> in game logic to get new moves
01:07:13 <askentasken> but if someone wins i want to quit
01:07:19 <askentasken> so i call a functionc alled atEnd
01:07:28 <askentasken> but after atEnd is done im back in gameLogic
01:07:34 <askentasken> i never want to go backl
01:09:11 <lispy> you could, call fail, you could throw an exception, you could use the continuation monad...but probably you just need to restructure your looping so that it checks if the game is over
01:11:02 <adu> lispy: oh, and about that darcs graph stuff...
01:11:12 <adu> lispy: http://tetration.itgo.com/img/darcs-graph.png
01:12:38 <lispy> adu: cool
01:12:57 <lispy> adu: it's late in my timezone.  Happy hacking!  I'm going to sleep :)
01:13:03 <adu> ok
01:15:55 <askentasken> well fail and error works but is obv not a nice way to do it
01:18:20 <sciolizer> asken: main = gameLogic board >>= atEnd
01:19:04 <askentasken> Couldn't match expected type `()' against inferred type `[Char]'
01:19:18 <sciolizer> What's the type of atEnd?
01:20:32 <askentasken> http://hpaste.org/12086
01:22:55 <sciolizer> askentasken: return in Haskell is not like return in other languages.
01:23:16 <sciolizer> askentasken: when will always execute the next statement in the do block (unless you fail or raise an exception)
01:23:27 <sciolizer> askentasken: you want to use if...then...else
01:24:14 <askentasken> but else cant take several statements
01:24:22 <sciolizer> use else do
01:27:55 * ksf suddenly blissfully remembers all his Haskell problems disappearing while reading http://book.realworldhaskell.org/read/
01:27:55 <lambdabot> Title: Real World Haskell
01:29:16 * sciolizer wonders if the phrase "stanamically typed" existed before Oleg.
01:29:33 <askentasken> http://hpaste.org/12087
01:30:20 <askentasken> there it is, not finished entirely(when all squares are filled you cant move). computer plays by random. but anyway it works. very inelegant program though, makes me want to throw up
01:30:34 <askentasken> and seems veyr big
01:30:38 <Rapiere> yes, real world haskell is a really great programming book
01:30:57 <sciolizer> asken: There are probably improvements that could made to it to shorten it up, but I'm happy you got it working.
01:31:59 <askentasken> scio: thanks for your help
01:32:23 <sciolizer> asken: yw
01:51:43 <Peaker> http://squing.blogspot.com/2008/11/beautiful-folding.html is nice, but is there no way to somehow guarantee a bunch of naive folds on the same list will be optimized into a single fold?
01:51:44 <lambdabot> Title: The Most Fuun You Can Have: Beautiful folding
01:52:08 <Peaker> (without having to explicitly combine them)
01:53:48 <Peaker> oh "GHC doesn't allow rules of this form, presumably for efficiency and simplicity in the compiler. So unfortunately, we can't go back to writing pretty-but-naive code, but with these combinators at our disposal, we are at least saved from writing *ugly* code. "
01:56:21 <Twey> What's an easy way to group a list to a certain number?  e.g. grp 3 [1, 2, 3, 4, 5, 6, 7] ===> [[1, 2, 3], [4, 5, 6], [7]]
01:57:00 <ddarius> Twey: Download some library where this is already implemented.
01:57:19 <Twey> ddarius: Eh?
01:57:30 <Twey> A whole library?  I'm thinking this is probably a one-liner...
01:57:45 <ddarius> Twey: It's not in the standard libraries and the simplest way to implement it is a (simple) recursive function.
01:57:53 <Twey> If there isn't a standard function for it already
01:57:58 <Twey> Ah, OK, thanks.
01:58:39 <Twey> :t splitAt
01:58:40 <lambdabot> forall a. Int -> [a] -> ([a], [a])
01:58:47 <Twey> Hmm.
02:00:05 <ddarius> > let chunk n = takeWhile (not . null) . unfoldr (Just . splitAt n) in chunk 3 [1..7]
02:00:06 <lambdabot>   [[1,2,3],[4,5,6],[7]]
02:00:11 <ddarius> But that's ugly.
02:00:30 <qebab> > let chunks xs n = [ take n $ drop i xs | i <- [0,n..(length xs) ] ] in chunks [1..10] 3
02:00:31 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
02:00:33 <Twey> What's the Just got to do with it?
02:00:37 <qebab> does this work?
02:00:48 <Deewiant> > let f n = map (take n) . takeWhile (not.null) . iterate (drop n) in f 3 [0..10]
02:00:49 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10]]
02:00:55 <Twey> It does, aye, thanks :)
02:00:57 <ddarius> qebab: Yours is even uglier.
02:00:58 <Peaker> it seems that strictness annotations cause some code duplication (define the exact same things, with/without annotation)
02:01:09 <Peaker> is it not possible to perhaps pass compile-time type parameters that control strictness?
02:01:11 <ddarius> As is Deewiant's.
02:01:23 <ddarius> The simple recursive definition is nicer.
02:01:32 <qebab> probably
02:02:09 <Deewiant> > let f _ [] = []; f n xs = let (as,bs) = splitAt n xs in as : f n bs in f 3 [0..10]
02:02:10 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10]]
02:02:14 <Deewiant> That one?
02:02:25 <ddarius> Deewiant: Yes.
02:03:04 <Peaker> Conal's post http://conal.net/blog/posts/enhancing-a-zip/  seems to be duplicating type declarations for minor strictness differences
02:03:04 <vegai> can the functional Array handle frequent updating without giving bad performance?
02:03:09 <lambdabot> Title: Conal Elliott Â» Enhancing a Zip
02:03:33 <vegai> hmm, I suppose I could just benchmark it and not bother you guys :P
02:03:38 <Deewiant> > let f _ [] = []; f n xs = uncurry (((>>>) >>> (>>>) (>>>)) (:) (f n)) (splitAt n xs) in f 3 [0..10]
02:03:40 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10]]
02:03:55 <ddarius> vegai: The standard Array type has O(n) update.
02:03:57 <Twey> Bwahahaha
02:03:58 <sjanssen> vegai: updates are O(n)
02:04:05 <vegai> ok, so that's a no.
02:04:23 <ddarius> vegai: Well if you update almost all the elements each time, it's fine.
02:04:36 <vegai> I'm thinking of a grid that could potentially be huge
02:04:55 <vegai> something to represent things like the world map in Civilization
02:05:09 <vegai> or playing area in a game like Angband
02:05:28 <vegai> where elements are mutated frequently
02:05:56 <Peaker> vegai: generally, if you want to use a functional data structure, its likely better to use some sort of tree
02:06:09 <Twey> > let chunk n = chunk' [] where chunk' acc [] = acc; chunk' acc xs = chunk' (acc ++ [take n xs]) (drop n xs) in chunk 3 [1, 2, 3, 4, 5]
02:06:10 <lambdabot>   [[1,2,3],[4,5]]
02:06:17 <Twey> Hey, it works.
02:06:18 <sciolizer> vegai: I would have thought the map would be relatively static, and only the overlay of characters would change frequently.
02:06:25 <twb> dcoutts_: cabal doesn't love me.
02:06:39 <ddarius> Twey: That one is worse that qebab's.
02:06:40 <Deewiant> Twey: building that accumulator is O(n^2)
02:06:56 <vegai> sciolizer: actually I'm thinking of Dwarf Fortress and Dungeon Keeper -like setting
02:06:57 <Twey> Ow :(
02:07:00 <twb> If I change "regex-compat == 0.71.* || == 0.91.*," to  "regex-compat == 0.71.* || == 0.91.* || == 0.92.*,", cabal configure fails with a parse error.
02:07:03 <vegai> where the map changes all the time
02:07:14 <Twey> Well, I could do...
02:07:20 <Peaker> vegai: A Data.Map.Map positioning the characters is probably a useful representation..
02:07:21 <endusr> Twey: how long have you and haskell been together?
02:07:39 <Twey> > let chunk n = reverse $ chunk' [] where chunk' acc [] = acc; chunk' acc xs = chunk' (take n xs : acc) (drop n xs) in chunk 3 [1, 2, 3, 4, 5]
02:07:40 <lambdabot>   Couldn't match expected type `[a]'
02:07:53 <Twey> ... or not
02:07:58 <Twey> endusr: It's been a turbulent affair, but about a year now.  :)
02:08:06 <ddarius> Twey: That one's better (when fixed), but still bad.
02:08:11 <sciolizer> vegai: DiffArrays are efficient, but they trap you in the IO monad.
02:08:37 <sciolizer> vegai: efficient as in constant time update
02:08:45 <Deewiant> DiffArrays are neither efficient nor IO :-P
02:08:50 <Deewiant> I think you mean IOArrays
02:08:52 <Twey> I see, yes, Deewiant's is much prettier.
02:09:00 <sciolizer> oh ok
02:09:15 <sciolizer> yes you're right
02:09:16 <Peaker> > let chunk n = reverse $ chunk' [] where chunk' acc [] = acc; chunk' acc xs = chunk' (take n xs ++ acc) (drop n xs) in chunk 3 [1, 2, 3, 4, 5]
02:09:17 <lambdabot>   Couldn't match expected type `[a]'
02:09:50 <vegai> sciolizer: might be that I cannot escape that
02:10:21 <vegai> DiffArray looks promising, though.
02:10:27 <ddarius> vegai: How many "players" would the game support?
02:10:31 <vegai> s/though//
02:10:37 <ddarius> (or whatever it is)
02:10:52 <vegai> ddarius: I would like to limit that number as little as possible
02:11:03 <Deewiant> vegai: DiffArray is O(n) where n is the number of updates you've performed... and in practice it's usually slower than a plain Array
02:11:13 <vegai> and even with just one player, there'd be numerous AIs roaming and changing the world all the time
02:11:23 <vegai> ok, so how about MArray?
02:11:35 <ddarius> Deewiant: Not than a plain Array and only when accessing old copies.
02:11:41 <twb> vegai: is someone making a roguelike?
02:11:45 <Corun> M, ARR! Ay?
02:11:48 <ddarius> Deewiant: It's slower than a Map or IntMap is what I hear.
02:11:50 <Deewiant> ddarius: I've heard it's slower than a plain Array in practice
02:11:52 <Peaker> Cool, DiffArray seems like a great alternative to uniqueness types in general!
02:11:56 <vegai> twb: have you heard of Dwarf Fortress or Dungeon Keeper?
02:11:57 <Deewiant> but yeah, IntMAp is even better
02:12:08 <twb> vegai: nope
02:12:28 <twb> vegai: I was asking what you were talking about, because I'm too lazy to read the scrollback
02:12:29 <ddarius> vegai: If I were you, I might seriously consider a quadtree-like structure.  (Though, I'd probably still use a mutable one.)
02:12:35 <askentasken> im having a weird error in my TicTacToe, it should be there for computerMove, ie when the board is full it goes into infinite recursion. but why does it do that for playerMove, it dosnt print Move to row, i t just sist there which s weird
02:12:44 <Peaker> Uniqueness types give you speed when you use something uniquely.  A keep-diff-for-old approach gives you the same benefit as uniqueness types, but you can use the older one too if you really want
02:12:51 <askentasken> how can i easily debug in haskell since i cant do print anywhere?
02:13:03 <Peaker> I wonder if the keep-old-diff approach is generalizable somehow
02:13:10 <sciolizer> askentasken: Debug.Trace
02:13:43 <Corun> If it compiles, then it's correct ;-)
02:14:12 <substack> @pl (\n -> (n, [1..floor $ sqrt n]))
02:14:12 <lambdabot> ap (,) (enumFromTo 1 . floor . sqrt)
02:14:29 <Peaker> Except for DiffArray, are there other data structures that are like that?
02:14:42 <Peaker> It seems like an awesome idea, I don't know how I didn't think of it! :-)
02:15:10 <ddarius> Not in any Haskell libraries I'm aware of, however it's the typical way of making a data structure persistent.
02:15:14 <Peaker> so much nicer than uniqueness types...
02:15:20 <vegai> Deewiant: IntMap is better than MArray or DiffArray?
02:15:38 <ddarius> Peaker: Uniqueness types do something rather different.
02:15:48 <jmg> Peaker: there are lot's more, just look for persistent functional datastructures
02:15:48 <Peaker> ddarius: They mutate in place because they prove you won't use the old copy
02:16:00 <ddarius> Peaker: Yes, so they correspond to a normal mutable array.
02:16:02 <Deewiant> vegai: better than DiffArray, certainly. MArray is just a class with instances for IOArray and STArray, right? They're the plain mutable arrays equivalent to those in imperative languages
02:16:20 <Peaker> ddarius: here we mutate in place but keep around a diff for old copy if that's still referred to.. So you get the benefits of both worlds, at a small price
02:16:29 <Deewiant> vegai: if you don't need persistence then you probably want the MArrays
02:16:33 <twb> Corun: Torvalds once said something like that.  Do you wanna be lumped in the same category as him?
02:16:56 <Deewiant> vegai: an IntMap may or may not be good enough for your performance needs. Try it out.
02:17:06 <vegai> yap...
02:17:27 <vegai> persistent data structures would fit well a situation where lots of different threads access the data?
02:17:34 <Corun> Oooh ouch twb.
02:17:46 <vegai> twb: I would.
02:17:51 <ddarius> vegai: It makes it harder for you to screw up.
02:17:59 <Corun> With linus-face, seriously?
02:18:11 <Corun> (For want of a better name for him ;-) )
02:18:16 <vegai> uh-oh. Battery running out
02:18:25 <Peaker> ddarius: The in-place mutation probably costs you twice as much, which is a cheap price to pay for not having to have uniqueness. Also, if the compiler can prove uniqueness, its just as good.  Surely DiffArray and the likes are the kind of DS that languages with uniqueness types should be using, so if you want to remove uniqueness qualifier, you can..
02:18:27 <ddarius> vegai: However, you may end up with a lot of contention at the root of a tree-like structure.
02:18:29 <vegai> ok, thanks for the help. I'll have to look into all that stuff
02:19:15 <askentasken> i found the error
02:19:54 <twb> askentasken: doesn't matter, there's always another one
02:20:01 <ddarius> Peaker: The whole point of a diff array would be that there is no need to ever have the uniqueness qualifier.  There's not much sense in comparing them (or comparing them in any way different from comparing to mutable arrays)
02:20:13 <Peaker> > let chunk n = reverse . chunk' [] where chunk' acc [] = acc; chunk' acc xs = chunk' (take n xs : acc) (drop n xs) in chunk 3 [1, 2, 3, 4, 5]
02:20:14 <lambdabot>   [[1,2,3],[4,5]]
02:20:50 <Peaker> ddarius: well, having the qualifier lets you not copy the overwritten data at all
02:21:38 <ddarius> Peaker: That doesn't make DiffArrays nicer than uniqueness types, that simply makes uniqueness types nicer (in general)
02:22:10 <Peaker> ddarius: if you used a uniqueness-type, but now you suddenly have a new requirement, and can no longer have uniqueness, do you have to refactor everything to use a different data structure?
02:22:36 <ddarius> Peaker: It depends on the structure you were originally using.
02:22:51 <Deewiant> > let chunk n = ($[]) . chunk' id where chunk' acc [] = acc; chunk' acc xs = chunk' (acc.(take n xs:)) (drop n xs) in chunk 3 [1,2,3,4,5]
02:22:53 <lambdabot>   [[1,2,3],[4,5]]
02:23:04 <Peaker> IOW, does Clean, as an example, have both uniqueness types and DiffArray-like types?
02:23:23 <ddarius> Peaker: I don't know if it does in the standard libraries, but you could implement them.
02:23:28 <Peaker> also, surely it is better to use DiffArray than a functional copied array in virtually all circumstances..
02:23:52 <Peaker> s/surely/my guess is that
02:24:34 <madara> hi learning haskell :)
02:24:53 <madara> > take 1000 (cycle "haskell lol")
02:24:54 <lambdabot>   "haskell lolhaskell lolhaskell lolhaskell lolhaskell lolhaskell lolhaskell ...
02:24:59 <madara> :)
02:25:02 <Twey> Is there a sort of reverse of &&&, that takes two inputs and merges them into one?
02:25:15 <madara> > take 1000 (cycle "haskell lol ")
02:25:16 <lambdabot>   "haskell lol haskell lol haskell lol haskell lol haskell lol haskell lol ha...
02:25:17 <Deewiant> Twey: uncurry? :-P
02:25:33 <Twey> ... oh *chuckles*
02:25:33 <madara> > take 1000 (repeat "haskell lol ")
02:25:34 <lambdabot>   ["haskell lol ","haskell lol ","haskell lol ","haskell lol ","haskell lol "...
02:25:55 <Twey> Some quality Haskell-learning got done there!
02:26:01 <substack> and how
02:26:12 <Peaker> heh
02:26:27 <ddarius> Twey: Uh, any binary function would do what you want.
02:26:59 <Twey> ddarius: The two inputs as a tuple, obviously.  :)
02:27:12 <Twey> (pardon me, I don't have my thinking cap on at the moment)
02:28:19 <Twey> Anyway, that ended up as: chunk n xs = uncurry (:) $ second (chunks n) (splitAt n xs)
02:28:31 <Twey> Any major flaws?
02:28:46 <Twey> (apart from the missing base-case, yes, it does exist)
02:29:21 <Peaker> chunks?
02:29:31 <Twey> Er, chunk
02:29:46 <Twey> Heh, different names in the interpreter and the file :)
02:30:02 <ddarius> Twey: That's just a rewriting of Deewiant's second example.
02:30:08 * Twey nods.
02:30:26 <Peaker> > let chunk n = uncurry (:) . second (chunk n) . splitAt n in chunk 3 [1..10]
02:30:28 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
02:30:47 <Twey> Peaker: Base case :)
02:31:14 <Peaker> > let chunk n = takeWhile (not . null) . uncurry (:) . second (chunk n) . splitAt n in chunk 3 [1..10]
02:31:15 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
02:31:18 <Twey> Yes, but Deewiant's second example scared the crap out of me
02:31:32 <Peaker> higher-order funcs ftw. gj Twey. :-)
02:31:33 <ddarius> Twey: And your version scares you less?
02:31:44 <Twey> It contains the expression ((>>>) >>> (>>>) (>>>)), for crying out loud
02:31:48 <Peaker> It used to be so mind-boggling to read Points Free. Now its so much easier!
02:31:49 <Twey> It does
02:32:03 <Twey> Quite considerably :-P
02:32:19 <Peaker> it does make me read right-to-left though, that sucks :P
02:32:26 <ddarius> Twey: [04:02] <Deewiant> > let f _ [] = []; f n xs = let (as,bs) = splitAt n xs in as : f n bs in f 3 [0..10]
02:32:30 <Twey> Peaker: You get used to it :-P
02:32:34 <ddarius> That's Deewiant's second example.
02:32:35 <Peaker> I think maybe Haskell needs (f a) to mean apply the func "a" to the arg "f" !
02:32:37 <Deewiant> Twey: Use flip . ((.) .) if you don't like arrows ;-)
02:32:38 <Twey> Oh, that one.  Yes.
02:32:47 <Twey> I do like arrows!
02:32:55 <Twey> Just... not that many of them, all together :-P
02:33:00 <Deewiant> ((>>>) >>> (>>>) (>>>)) is my jokingly-preferred way of writing \f g x y -> f x (g y)
02:33:10 <Twey> Oooh.
02:33:35 <ddarius> Peaker: Your recursive variation is very inefficient.
02:33:37 <Twey> It's a little mind-bending trying to follow it through this early/late in the morning.
02:33:39 <Deewiant> mostly because I @pl'ized it in my head as I was going to sleep and got that (well, a bunch of "flip (.)"s originally but anyhoo)
02:33:52 <Peaker> ddarius: why?
02:33:57 <Peaker> > let chunk n =  splitAt n >>> second (chunk n) >>> uncurry (:) >>> takeWhile (not . null) in chunk 3 [1..10]
02:33:58 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
02:34:34 <Peaker> ddarius: you mean the point-ful or points-free one?
02:34:37 <ddarius> Peaker: You traverse the list each time through the loop taking O(n^2) time.
02:34:41 <Twey> I don't like the takeWhile (not . null) in that one
02:34:48 <Peaker> Twey: why?
02:34:50 * Twey nods.
02:35:03 <Twey> Because ^
02:35:16 <Peaker> ddarius: the points-free one traverses the list each time?
02:35:24 <Twey> Also, it's conceptually nasty when there's an easier way
02:35:38 <ddarius> Peaker: The last two versions you've written have that problem.
02:35:44 <Peaker> ddarius: because of the takeWhile?
02:35:49 <ddarius> Yes.
02:36:27 <Peaker> ddarius: why? not.null should only take O(1), and takeWhile should takes an O(N) computation and result in an O(N) computation if its given an O(1) func
02:36:46 <ddarius> Yes, and that's being done N/n times for fixed n.
02:37:11 <Peaker> oh, because I didn't put it out of the recursion, I see. Oops
02:37:25 <askentasken> great someone did matlab package. then haskell could get serious for a lot of stuff
02:37:34 <ddarius> If you pull the takeWhile out of the loop you'll get one of the one-liner (one case) versions that were originally suggested.
02:37:58 <Peaker> > let chunk n = chunk' n >>> takeWhile (not . null) ; chunk' n = splitAt n >>> second (chunk' n) >>> uncurry (:) in chunk 3 [1..10]
02:37:59 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
02:38:07 <Peaker> I am not sure I saw the original suggestions
02:38:45 <ddarius> The nicest one using takeWhile (not . null) is takeWhile (not . null) . unfoldr (Just . splitAt n)
02:38:57 <ddarius> But the takeWhile is ugly.
02:38:59 <Peaker> ah, you said its ugly, but I find it nice. Except I am pretty new to unfoldr
02:39:17 <ddarius> It can be gotten rid of by moving the check into the unfoldr, but that makes it look quite a bit uglier.
02:39:25 <twb> Why does Darcs' "cabal build" find quickcheck in ~/.cabal, but ./configure can't?
02:39:27 <Deewiant> I'm partial to the iterate version.
02:39:55 <Peaker> Why does the unfoldr func return a Maybe, where Nothing and Just represent [] and (:) ?
02:40:04 <twb> Hmm, perhaps because I haven't actually installed it yet.
02:40:06 <ddarius> > unfoldr (\xs -> case xs of [] -> Nothing; Just (splitAt n xs)) [1..10]
02:40:07 <lambdabot>   <no location info>: Parse error in pattern
02:40:15 <ddarius> > unfoldr (\xs -> case xs of [] -> Nothing; _ -> Just (splitAt n xs)) [1..10]
02:40:16 <lambdabot>   Couldn't match expected type `Int' against inferred type `Expr'
02:40:26 <ddarius> > unfoldr (\xs -> case xs of [] -> Nothing; _ -> Just (splitAt 3 xs)) [1..10]
02:40:27 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
02:40:41 <Peaker> @hoogle [a] -> Maybe a
02:40:41 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
02:40:41 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
02:40:41 <lambdabot> Prelude head :: [a] -> a
02:41:07 <Peaker> > let chunk n = unfoldr (listToMaybe . splitAt n) in chunk [1..10]
02:41:08 <lambdabot>   Couldn't match expected type `[a]'
02:41:39 <Peaker> > let chunk n = unfoldr ((Just &&& listToMaybe) . splitAt n) in chunk [1..10]
02:41:40 <lambdabot>   Couldn't match expected type `[a]'
02:41:49 <Peaker> @type (Just &&& listToMaybe)
02:41:50 <lambdabot> forall a. [a] -> (Maybe [a], Maybe a)
02:42:00 <Peaker> oy :)
02:42:40 <ddarius> > unfoldr (\xs -> fmap (splitAt 3 xs) $ listToMaybe xs) [1..10]
02:42:40 <lambdabot>   Couldn't match expected type `a -> b'
02:42:53 <ddarius> > unfoldr (\xs -> fmap (const$ splitAt 3 xs) $ listToMaybe xs) [1..10]
02:42:55 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
02:43:13 <ddarius> @hoogle uncons
02:43:13 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
02:43:13 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
02:43:13 <lambdabot> Data.ByteString.Lazy uncons :: ByteString -> Maybe (Word8, ByteString)
02:43:18 <ddarius> @hoogle+
02:43:18 <lambdabot> Text.Parsec.Prim uncons :: Stream s m t => s -> m (Maybe (t, s))
02:43:18 <lambdabot> Data.ByteString.Lazy.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
02:48:40 <Deewiant> Now I remember why I like the iterate version: it's about 25% faster than the others
03:04:33 <Twey> Is it possible to disable the implicit prelude for GHCi?
03:04:44 <Twey> -fno-implicit-prelude doesn't seem to work
03:04:54 <Twey> (it still loads the prelude anyway)
03:06:57 * Peaker still tries to find a nice PL way to get rid of the takeWhile
03:25:29 <EvilTerran> > unfoldr (guard.not.null <^(>>)^> return.splitAt 3) [0..10]
03:25:30 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10]]
03:25:33 <askentasken> I am going back to doing Prolog again. How do I create an "entity" or container for a bunch of stuff? like i sketeched it up in Python where I have 3 classes: PrologRuntime, Fact, Rule. i add facts and rules to the runtime and then have some methods to inference.
03:25:33 <askentasken> how would you do that in Haskell? data Runtime = Runtime Facts [Fact] Rules [Rule]?
03:25:50 <EvilTerran> Peaker, huzzah?
03:31:49 <Deewiant> The fastest appears to be the straightforward recursive definition, but using take/drop instead of splitAt
03:32:11 <Deewiant> At least when n << length xs
03:37:45 <EvilTerran> how unintuitive that the clearest would appear to be the fastest
03:38:47 <PeakerWork> @type (<^(>>)^>)
03:38:48 <lambdabot> parse error on input `)'
03:38:53 <PeakerWork> @type (<^)
03:38:57 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
03:39:05 <PeakerWork> @type (^>)
03:39:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:40:09 <Deewiant> @type \f g -> f<^(>>)^>g
03:40:11 <lambdabot> forall (f :: * -> *) (m :: * -> *) a b. (Applicative f, Monad m) => f (m a) -> f (m b) -> f (m b)
03:41:07 <askentasken> how would you do that in Haskell? data Runtime = Runtime Facts [Fact] Rules [Rule]?
03:41:12 <askentasken> I am going back to doing Prolog again. How do I create an "entity" or container for a bunch of stuff? like i sketeched it up in Python where I have 3 classes: PrologRuntime, Fact, Rule. i add facts and rules to the runtime and then have some methods to inference.
03:43:21 <EvilTerran> askentasken, don't repeat yourself; if we don't say anything, it's because we have no suggestions, not because we didn't notice you
03:44:00 <EvilTerran> maybe if no-one's said anything in an hour, it might be worth bringing it up again, but definitely not when everyone can still see the last time you asked at the top of their screen
03:45:02 <jpcooper> EvilTerran, got out of bed the wrong way?
03:46:32 <C-Keen> EvilTerran: hey he switched lines :)
03:46:33 <therp> jpcooper: EvilTerran's remarks are totally reasonable.
03:46:45 <EvilTerran> jpcooper, if everyone repeated themselves when no-one replied immediately, the channel would be rendered full of echoes
03:47:09 <jpcooper> hey, I thought this place was renowned for its surround-sound replies
03:47:48 <jpcooper> therp, my point was that it could have been said in a more courteous way
03:48:20 <EvilTerran> jpcooper, in any online discussion group i've been in, repeating yourself when no-one replies is considered rude
03:49:05 <jpcooper> I know
03:49:10 <EvilTerran> be it IRC, forum, etc
03:50:27 <jpcooper> so would yeah rather that #haskell turns into #lisp?
03:50:32 <jpcooper> you*
03:50:35 <EvilTerran> ... what does that even mean?
03:50:59 <jpcooper> I presume that you're quite aware of the difference in atmosphere between the two
03:51:02 <EvilTerran> nope
03:51:09 <EvilTerran> you presume i've ever been in #lisp
03:51:12 <C-Keen> is this dicussion helpful?
03:52:03 <jpcooper> EvilTerran, if you did something bad when you were a kid, were you most likely to discontinue it if you were shouted at, or if you were explained nicely the reasons?
03:52:20 <EvilTerran> jpcooper, i did explain the reasons
03:52:42 <jpcooper> you explained them in an aggressive manner totally out of proportion with what was done
03:53:17 <EvilTerran> ah, i see what's happened
03:53:25 <EvilTerran> you've mis-read my tone. the internet's like that.
03:53:31 <jpcooper> haha
03:53:54 <Deewiant> Hence, use copious amounts of emoticons :-)
03:54:52 <EvilTerran> yeah, i guess the responsibility of making sure the tone of what i'm saying is clear falls on me
03:55:01 <jpcooper> right well I'm not going to argue about this. I think you know how what you first said was meant to be received
03:55:33 <smtms> that's what happens on Sundays - people have time
03:55:38 <C-Keen> heh
03:56:03 <EvilTerran> i know how it was meant to be recieved, and i get the distinct impression it wasn't recieved that way
03:56:12 <jpcooper> right okay
03:56:22 <EvilTerran> er, *received
03:57:41 <EvilTerran> i can see how it might've been interpreted as crabby rather than purely advisory. it's difficult to phrase these things right.
03:57:45 <C-Keen> thank you haskell people for providing cabal!
03:57:56 * EvilTerran considers making a standard (but polite) "don't repeat yourself!" for future reference
04:03:10 <therp> EvilTerran: just add "please" :)
04:04:08 <EvilTerran> therp, heh, yeah, i'm sure i meant to put one in. i think i planned to tack it on to the end when i started typing, but thought i had already put it at the beginning by the time i got to the end :P
04:04:46 <therp> Sunday, the day of exciting Haskell topics :)
04:07:06 <EvilTerran> it's sunday morning; everyone's still too hung over for haskell :P
04:09:38 <luite> yeah
04:09:50 <luite> although it's sunday afternoon here :P
04:11:23 * RayNbow just finished lunch :p
04:11:38 <RayNbow> too bad I didn't have curry for lunch :p
04:12:05 <jpcooper> curry's common in Holland?
04:12:23 <RayNbow> not really :p
04:12:23 <jpcooper> I never found a curry take-away in The Hague
04:12:58 <RayNbow> but you can make curry yourself (or let some other family member make it :p)
04:13:06 <jpcooper> yes, that's what I did
04:14:08 <jpcooper> oh right finally I get the joke
04:16:12 <luite> does anyone know some good examples for the gnuplot package?
04:16:24 <ivanm> luite: as in the gnuplot package on hackage?
04:16:39 <luite> yes
04:16:51 * ivanm ended up hacking together his own interface based on it
04:17:11 <ivanm> http://dpaste.com/91120/
04:18:53 <luite> ah thanks
04:21:14 <ivanm> I've got some other examples if you want them, that's just the last lot I did
04:21:34 <ivanm> (I did customised access functions for each separate assignment I needed plots for
04:21:50 <ivanm> luite: note that if you're only doing 2D plots, the charts library produces superior results IMHO
04:21:55 <Twey> Sounded reasonable to me, FWIW
04:22:10 <Twey> Er, on the repetition discussion, sorry, I was scrolled up
04:22:14 <ivanm> heh
04:23:26 <luite> ivanm: ah, I'll check that out first then
04:23:57 <ivanm> no worries
04:25:20 <ivanm> luite: I've got some sample wrapper functions for charts as well if you want them
04:26:24 <EvilTerran> Twey, eh, i was a bit crabbit, i was in the middle of my first coffee of the day when i typed that. not so much "got up on the wrong side of bed" as "my brain was yet to get out of bed" :P
04:27:27 <luite> ivanm: the interface looks already quite simple to me. the problem is that I need to be able to install it first, it cannot find gtk and cairo
04:27:39 <RayNbow> being in #haskell is bad for one's reading skills... I start to mix up coffee and cofree when reading stuff :p
04:28:14 <RayNbow> (even though I have no idea yet what cofree is exactly)
04:29:41 <Twey> Haha
04:30:15 <luite> hm, why isn't gtk2hs not available on hackage?
04:31:05 <mmorrow> > fix (\k n -> list [] (\x -> uncurry (:) . fmap (k n) . splitAt n . (x:))) 4 [0..17]
04:31:06 <lambdabot>   [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17]]
04:31:31 <mmorrow> > fix (\k n xs -> case splitAt n xs of ([],_) -> []; (ys,zs) -> ys : k n zs) 4 [0..17]
04:31:31 <lambdabot>   [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17]]
04:32:36 <Deewiant> ?ty list
04:32:37 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
04:34:13 <mmorrow>  @let list n _ [] = n; list _ c (x:xs) = c x xs
04:34:53 <mmorrow> that would be better though for that above use if it was let list n _ [] = n; list _ c xs = c xs   though
04:35:45 <mmorrow> @let nonull n _ [] = n; nonull _ c xs = c xs
04:35:45 <lambdabot>  Defined.
04:36:04 <mmorrow> > fix (\k n -> nonull [] (uncurry (:) . fmap (k n) . splitAt n)) 4 [0..17]
04:36:05 <lambdabot>   [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17]]
04:38:27 * mmorrow adds nonull to his utils module
04:40:04 <olsner> oh, what a noob I am... I forgot newtype-deriving existed so I went about to write instance of Monad* for my monad transformar
04:40:25 <quicksilver> well it's a good exercise ;P
04:40:41 <olsner> yeah, I guess it was
04:40:47 <Raevel_> olsner: !!
04:41:43 <olsner> Raevel_: zomg it's you!
04:41:48 <Raevel_> you bet
04:42:00 <Raevel_> #ocaml was no fun
04:52:17 <PeakerWork> What's the Zip class referred to by conal's latest blog entries?
05:04:50 <luite> do I need some darcs version to build gtk2hs with ghc 6.10.1? tools/c2hs/base/general/Binary.hs:73:27: Module `Control.Exception' does not export `throwDyn'  Module `Control.Exception' does not export `throwDyn'
05:06:13 <ivanm> luite: yes
05:06:17 <Deewiant> luite: just replace Control.Exception with Control.OldException everywhere
05:06:21 * ivanm forgot about that
05:06:27 <Deewiant> new darcs versions may have done this for you
05:06:30 <Deewiant> I don't know
05:06:38 <ivanm> Deewiant: oh? is that the only change?
05:06:44 <Deewiant> no, it's not the only change
05:07:09 <Deewiant> there's an instance declaration somewhere for which a patch exists at least on the sourceforge forums
05:07:10 <jkr> When a function expects a lambda and I have ready-to-use function, how do I give that function to the other function?
05:07:12 <luite> I'll try the darcs version first, hope it doesn't break :)
05:07:16 <Deewiant> and there may be something else as well, I forget
05:07:21 <jkr> Do I have to wrap it into a (\ ...) expression?
05:07:39 <jkr> Or is there a shorter way?
05:08:27 <jkr> For example, I have to function foo, do I have to write: map (\e -> foo e) someList?
05:08:31 <vixey> jkr,  like  'map reverse' or what?
05:08:31 <luite> noe
05:08:35 <luite> jkr: just foo
05:08:40 <jkr> Or can I just write "map foo someList"
05:08:42 <vixey> jkr, oh yeah \e -> foo e is fine, but \e -> foo e = foo
05:08:43 <luite> jkr: yes
05:09:56 <jkr> Doesn't seem to work the short way
05:10:10 <vixey> jkr, why not
05:10:35 <jkr> When I write map foo someList, I get the error couldn't match expected type listItem against inferred item [listItem], for function foo
05:10:49 <olsner> mmorrow: oh, I think I found a use for nonull myself just now... or at least (nonull f id)
05:11:01 <jkr> D'oh
05:11:04 <olsner> maybe there's some more specific function for that special case though
05:11:16 <jkr> Forget about it, it was something else :)
05:11:20 <jkr> My fault
05:12:15 <mmorrow> olsner: i do "maybe f id" all the time
05:12:34 <Deewiant> mmorrow: fromMaybe
05:12:40 <mmorrow> @index fromMaybe
05:12:40 <lambdabot> Data.Maybe
05:12:44 <mmorrow> @index maybe
05:12:44 <lambdabot> Data.Maybe, Prelude
05:12:46 <olsner> @ty fromMaybe
05:12:47 <lambdabot> forall a. a -> Maybe a -> a
05:12:48 <vixey> I prefer maybe f id
05:12:50 <mmorrow> Prelude baby
05:12:59 <Deewiant> that import too much trouble? :-P
05:13:01 <Philonous> @hoogle m ( a->b) -> m a -> m b
05:13:01 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
05:13:01 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
05:13:01 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
05:13:17 <vixey> hey mmorow
05:13:20 <mmorrow> that and i find always using "maybe" to be more consistent
05:13:23 <mmorrow> (in my mind)
05:13:26 <vixey> I stil didn't build luna yet :/
05:13:27 <mmorrow> hey vixey
05:13:35 <vixey> will though
05:13:38 <mmorrow> vixey: aww
05:13:39 <mmorrow> cool
05:14:12 <mmorrow> just build/get a 6.10.1
05:14:28 <mmorrow> otherwise you'll surely have to hack around to account for ghc-api changes
05:14:56 <mmorrow> the binary dist'd work if building one'd be too much pain
05:21:46 <askentasken> what was that 3d visualisation module called
05:21:54 <askentasken> with the tours rings and all?
05:26:13 <Philonous> Fieldtrip?
05:27:12 <askentasken> ah yes
05:27:36 <FunctorSalad> is there some pun in that name I don't get? :)
05:27:47 <kynky> lol
05:28:32 <mmorrow> vixey: i'm implementing (a first go at) that "lazy virtual machine": http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=486#a487
05:28:44 <mmorrow> http://www.cs.uu.nl/research/techreps/repo/CS-2004/2004-052.pdf
05:28:46 <lambdabot> Title: The Lazy Virtual Machine specification
05:28:56 <jkr> Is there something like static variables in Haskell?
05:29:17 <mmorrow> i've got enough of the instruction set done to actually play around with simple progs
05:29:36 <olsner> jkr: function-local mutable persistent state?
05:29:46 <jkr> I'd like to provide a function that returns a database handle, but it should not connect to a database on every call, but only the first time and then remember the handle internally
05:29:50 <jkr> olsner: Exactly
05:31:10 <EvilTerran> am i right in thinking your function's an IO action?
05:31:14 <jkr> Yup
05:31:16 <kpreid> jkr: don't do that. don't use unsafePerformIO to do that.
05:31:19 <kpreid> :)
05:31:24 <olsner> if you do type MyConnectionHandle = IORef RealConnectionHandle, you can make some other helper functions to create a lazy connection handle and a connect-or-get function
05:31:26 <Twey> jkr: You want an IORef
05:31:27 <Twey> And it should be explicit.
05:31:31 <vixey> oh that's cool
05:31:43 <Twey> vixey: Hm?
05:32:17 <jkr> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html <-- this thing?
05:32:19 <lambdabot> Title: Data.IORef, http://tinyurl.com/y44crg
05:33:37 <olsner> actually probably IORef (Maybe ConnectionHandle) since IORef's can't be empty
05:33:37 <Twey> jkr: 's the one
05:36:10 <jkr> Hmm, haskell package docs could really need some usage examples
05:36:56 <FunctorSalad> sometimes an example is included in the haddock
05:37:03 <olsner> hmm.... this is weird... when I compile my program I get <<loop>> and it aborts, but when I run in ghci, it just stalls without even using any CPU
05:37:14 <FunctorSalad> there might also be one on the wiki
05:37:28 <vixey> olsner, that's not that weird
05:37:56 <vixey> actually not sure how it could use 0 CPU
05:37:59 <vixey> I guess it's a bit weird
05:38:03 <FunctorSalad> :)
05:38:08 <olsner> vixey: what is it then? if it isn't weird? :P
05:38:15 <trofi> > let x = x in x
05:38:30 <lambdabot>   thread killed
05:38:47 <Deewiant> olsner: if it used CPU it wouldn't be weird
05:39:18 <Deewiant> that just means that the compiler was able to be clever and simplify something to the point where it can detect a <<loop>>
05:40:09 <askentasken> meh i changed to 6.10.1, now how do i reconfigure cabal the easiest way?
05:40:16 <askentasken> using windows
05:40:28 <EvilTerran> using no CPU would make me think it's deadlocking somehow... that wouldn't make sense unles vixey's using some kinda concurrency, though
05:40:32 <askentasken> and is 6.10 an apt-get on ubuntu?
05:40:44 <Deewiant> EvilTerran: it wouldn't say <<loop>> then, would it?
05:40:56 <EvilTerran> mmm... true
05:41:12 <olsner> EvilTerran: it's me not vixey :) and no, there is no concurrency involved
05:41:17 <EvilTerran> oh right
05:44:54 <mmorrow> olsner: can you paste the code that makes ghci do that?
05:45:59 <olsner> hmm... 20k code in 6 files, and I don't know which part of it is failing
05:46:07 <mmorrow> ah, dang
05:48:35 <askentasken> meh i changed to 6.10.1, now how do i reconfigure cabal the easiest way?
05:50:44 <dancor> @hoogle foldlAndModList :: (a -> b -> (a, b)) -> a -> [b] -> (a, [b])
05:50:45 <lambdabot> No results found
05:51:02 <dancor> @hoogle (a -> b -> (a, b)) -> a -> [b] -> (a, [b])
05:51:03 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:51:03 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:51:03 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])
05:51:07 <Deewiant> ?ty mapAccumL
05:51:08 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:51:13 <Deewiant> too slow
05:52:11 <dancor> when hoogle get it, it's a beautiful thing
05:53:19 <vixey> crazy proof in haskell
05:53:29 <vixey> http://www.cs.kuleuven.be/%7Etoms/Research/papers/plpv2009_draft.pdf
05:53:32 <lambdabot> Title: cache:http://www.cs.kuleuven.be/%7Etoms/Research/papers/plpv2009_draft.pdf - Goo ..., http://tinyurl.com/57mszr
05:53:35 <dancor> i'm glad i guessed the right placement of the the accum param..
05:53:36 <vixey> is this crazy or ?
05:55:42 <olsner> askentasken: I think I have the same problem as you :)
05:57:25 <askentasken> but cabal is in ghc-6.10 already, but i need the cabal-install binary or something? i deleted ghc-6.8.3 but cabal still works
05:57:37 <askentasken> hmm
05:57:39 <askentasken> wait
06:00:43 <vixey> Anyone read this paper?
06:01:13 <askentasken> so i ahve c:/ghc/ghc-6.10.1/ and C:/Program Files/Haskell and i used to have C:/ghc-6.8.3. so cabal installs into C:/program files/haskell
06:01:30 <ski_> vixey : looks fun
06:01:31 <askentasken> but 6.10.1 doesnt seem to look there, how do i make it do that?
06:01:38 <askentasken> i dont remeber how i isntalled cabal
06:02:08 <mmorrow> vixey: this is cool:
06:02:10 <mmorrow> data Eqv s t where Eqv :: (s ~ t) => Eqv s t
06:02:36 <ski_> why not just `data Eqv :: * -> * -> * where Eqv :: Eqv s s' ?
06:03:10 <ski_> (vixey : the inference system for `~' looks a bit similar to some ideas of mine)
06:03:10 <mmorrow> i think the (s ~ t) adds something essential
06:03:16 <ski_> being ?
06:03:49 <mmorrow> you can defined whether s ~ t with type family instances
06:04:07 <ski_> come again ?
06:04:13 <Deewiant> askentasken: executables there will still work since they're just normal executables, but libraries won't since they're installed versioned to your compiler, e.g. program files\haskell\cabal-1.6.0.0\ghc-6.8.3
06:05:06 <mmorrow> type family F a      type family G b         type family instance F a = Bool       type instance G Int = a
06:05:08 <askentasken> ah yes i see i only have ghc-6.8.3 there, how do i add 6.10.1?
06:05:20 <Deewiant> askentasken: reinstall the library with the new compiler.
06:05:30 <askentasken> which library?
06:05:35 <Deewiant> whichever library you want.
06:05:40 <askentasken> yes but how
06:05:41 <mmorrow> F (G Int) ~ F Bool
06:05:47 <askentasken> how do i reinstall cabal
06:05:47 <Deewiant> the same way you installed them before.
06:05:55 <ski_> mmorrow : is `type instance G Int = a' really valid ?
06:05:58 <askentasken> so i can do in msys cabal install
06:06:03 <mmorrow> heh, i'm not sure ;)
06:06:08 <ski_> it seems overlapping
06:06:09 <mmorrow> but i went out on a limb
06:06:11 <askentasken> isnt that cabal-install tied to 6.8.3
06:06:14 <mmorrow> i'm gonna check
06:06:20 <Deewiant> I'm not 100% sure if cabal-install will realize you're on a new compiler or not
06:06:25 <Deewiant> if not, reinstall cabal-install first.
06:06:33 <ski_> shouldn't `G blah' be a deterministic (or at least semi-...) type expression ?
06:07:02 <vixey> hmmm
06:07:03 <mmorrow> ski: but either way, the ~ restrict the two types to be such that they are equivalent modulo currently in-scope type instances
06:07:08 <ski_> (or are you claiming it's the *same* `a' in the two instances ?)
06:07:13 <vixey> I don't know what it is about
06:07:44 <ski_> mmorrow : i would expect `~' to just be a funny syntax for `=' between types, in constraints
06:07:48 <mmorrow> ski_: different a
06:07:52 <ski_> (ok)
06:08:24 <ski_> (vixey : the paper ?)
06:09:19 <askentasken> hmm it installed with 6.10
06:09:23 * dancor used hunit and it immediately paid off the next line of code i wrote (using infixl instead of infixr)
06:09:33 <askentasken> but hen using ghci in emacs i dont seem to be able to use it
06:09:39 <askentasken> Could not find module `Actor.ActorLinearSearch':
06:09:39 <askentasken>       Use -v to see a list of the files searched for.
06:09:45 <vixey> doing proofs in System F
06:09:54 <ski_> (`G Int = a' reads to me like `foo 0 = x' i.e. for every `x' here .. so it'd only work if the type of `x' had at most one value .. mutatis mutandis for the type `a')
06:10:08 <dancor> is there a hunit testimonial page i can tumblr on
06:10:09 <vixey> seems so awkward
06:10:37 <ski_> vixey : are you talking about equality proofs ? or proofs in general ?
06:10:43 <vixey> in general
06:10:54 <ski_> ok
06:11:24 <olsner> hmm, cabal-install 0.6 loops and uses all my memory on the "Resolving dependencies" step
06:12:54 <waern_> olsner: it's reported bug
06:16:23 <askentasken> why cant cabal check all dependencies FIST? it goes on forver just to fail at the end wtf
06:16:30 <askentasken> FieldTrip-0.2.1 depends on GLUT-2.1.1.2 which failed to install.
06:16:36 <jkr> Are there alternative ways in Haskell to create string literals (besides "")?
06:16:44 <jkr> Like qq|string| in Perl
06:16:54 <EvilTerran> not in h98, unfortunately
06:17:03 <kpreid> jkr: ['a','b','c']
06:17:06 <jkr> Hehe
06:17:19 <EvilTerran> well, aside from list notation (and hence also 'a':'b':'c':[])
06:17:28 <jkr> What do you do when you want to make a string with lots of " in it?
06:17:39 <EvilTerran> suffer leaning toothpick syndrome
06:17:50 <Stephan202> haha
06:18:09 <Deewiant> map (\x -> if x == 'z' then '"' else x) and use 'z' instead
06:18:22 <jkr> Hrhr
06:18:23 <askentasken> configure: error: no GLUT header found, so this package cannot be built
06:18:27 <jkr> Not a bad idea, actually
06:18:29 <askentasken> so how do I get a GLUT header?
06:18:50 <EvilTerran> jkr, also, ghc6.10 has quasiquoting, which could be used for that
06:19:12 <EvilTerran> [$qq| ... |]
06:19:36 <daf> askentasken: Cabal only knows about Haskell dependencies
06:19:40 <EvilTerran> which also has the advantage of being dealt with at compile-time
06:19:44 <daf> askentasken: it doesn't know about C libraries
06:19:53 <olsner> waern: hmm, so basically the workaround is to not use 0.6.0 or wait for 0.6.1?
06:20:15 <waern> olsner: I don't know, I just saw some trac ticket that brought up the issue
06:20:24 <Deewiant> olsner: works for me with 0.6.0 and 1.6.0.0
06:20:31 <Deewiant> maybe you have cabal 1.4?
06:20:41 <daf> askentasken: what sort of system do you have?
06:20:49 <olsner> I'm using the Cabal that came with 6.10.1
06:21:06 <olsner> 1.6.0.1 iirc
06:21:52 <Deewiant> that's odd
06:21:55 <EvilTerran> qq = QuasiQuoter (litE . stringL) (litP . stringL)
06:22:00 <kynky> i have cabal 1.6.0.1 installed with ghc 6.10.1 , but thats under gentoo
06:22:33 <askentasken> daf: windows
06:22:34 <Deewiant> olsner: the cabal ticket is #349 and it was fixed long before 6.10.1 came out, I'm on 6.10.0.20081007 myself
06:22:48 <askentasken> but i have ubuntu too
06:23:03 <askentasken> but how do i get the GLUT-header?
06:23:15 <olsner> maybe I'm seeing the same as this guy then http://hackage.haskell.org/trac/hackage/ticket/407
06:23:19 <lambdabot> Title: #407 (Installing new packages takes forever) - Hackage - Trac
06:23:22 <askentasken> and can i apt-get ghc-6.10 on ubuntu? apt-get ghc gets 6.8.2 i think
06:23:23 <PeakerWork> askentasken: in Ubuntu, to get headers, you get the package with "-dev" in its name
06:23:43 <PeakerWork> askentasken: I don't think so, I removed all the ghc stuff in Ubuntu, and installed ghc-6.10.1 manually from the binaries at haskell.org
06:25:27 <luite> askentasken: there is no official package, but you can build 6.10 yourself, in your home directory, you can keep 6.8.2 installed if you want (you need it to build 6.10.1)
06:27:00 <luite> askentasken: just make sure that you have your own ghc directory in your $PATH before the default ubuntu ghc
06:33:22 <daf> askentasken: if you have Ubuntu, you just need to install libghc6-glut-dev and you have Haskell GLUT bindings
06:33:31 <daf> I don't know about Windows
06:33:43 <daf> oh, you want 6.10?
06:33:47 <luite> but you will have the 6.8.2 version then
06:34:10 <daf> any particular reason why you want 6.10?
06:35:02 <Philonous> Do I understand it correctly that a GADT is basically a typed type?
06:35:42 <Philonous> Or rather a type with explicitly typed constructors
06:35:42 <mmorrow> ski_, vixey: this is interesting, although i'm not sure exactly what it's really saying to me yet http://hpaste.org/12088
06:35:51 <PeakerWork> you don't need 6.8 to build 6.10.1, you can install it from binaries
06:35:59 <olsner> oh, wtf... bash had apparently cached the inode number of cabal-install 0.5.1 after I had removed it and replaced it with 0.6.0, so I was using my ghc-6.8.2 version linked against cabal 1.4
06:36:01 <PeakerWork> I think ghc comes with a precompiled C ghc for bootstrapping anyway
06:36:13 <luite> PeakerWork: you still need it to build it, you just don't need to build it ;)
06:36:15 <olsner> works perfectly after hash -r
06:36:26 <kynky> yeah i had to bootstrap it under gentoo
06:36:52 <PeakerWork> Philonous: yeah, a type with explicitly typed constructors
06:37:04 <PeakerWork> Philonous: I think that's the whole thing, and it allows some interesting flexibility
06:37:43 <PeakerWork> Philonous: for example, you can: data Blah a b where B :: Blah Int String ; C :: a -> Blah a a
06:38:33 <askentasken> how do i reload emacs? when i install with cabal form msys i cant immediately import the lib, i have to restart emacs. how can i reload emacs?
06:39:15 <askentasken> daf: i want o test FieldTrip which requires 6.10
06:40:11 <andun> do haskell have a sleep function? i can't find it :/
06:40:17 <Philonous> PeakerWork: Thanks. I'm just reading a paper about GADTs and I wasn't quite sure I understood there introductory example right.
06:40:49 <olsner> hmm, what happened to Control.Arrow.pure in base-4?
06:40:49 <vegai> andun: threadDelay, perhaps?
06:40:59 <luite> askentasken: do you need to restart the whole emacs? you can probably just kill the ghci buffer and reload your code
06:41:02 <EvilTerran> olsner, it was clashing with Control.Applicative.pure, so they took it out
06:41:06 <andun> vegai: thanks
06:41:23 <olsner> and now it's 'arr' I should use instead?
06:41:26 <EvilTerran> yeah
06:41:56 <EvilTerran> Philonous, the point of this being that a constructor can then be polymorphic in types that don't appear in their return type
06:42:47 <EvilTerran> "data Foo where Bar :: SomeClass a => a -> Foo; Baz :: a -> (a -> String) -> (a -> Bool) -> Foo" etcetc
06:42:52 <askentasken> why does it take forever to download 6.10 binaries?
06:43:10 <luite> askentasken: it takes more than forever to build them from source ;)
06:43:56 <Botje> i'm doing so right now, actually
06:43:59 <askentasken> ah yes, kill ghci and reload it works
06:44:14 <Botje> makin' me some .debs
06:45:06 <jkr> Does anyone know what this means? "(SQL error: SqlError {seState = "", seNativeError = 5, seErrorMsg = "In HDBC step, unexpected result from sqlite3_step"})"
06:46:48 <kpreid> it means you need better error reporting
06:48:52 <askentasken> anyone installed hmatrix on windows?
06:49:12 <askentasken> anyone know where to get the GLUT header and how to install it?
06:51:12 <Zao> askentasken: Through your distros package system?
06:52:01 <jkr> kpreid: That's not from me, it's from HDBC/SQLite
06:53:13 <jkr> That's what HDBC prints when I use handleSqlError
06:53:23 <luite> askentasken: if it needs a specific header and you know the file name, you can do apt-file search filename, to search for packages containing that file (you may need to install apt-file and run apt-file update first)
06:53:37 <trhj1> @pl \a -> [a]
06:53:38 <lambdabot> return
06:56:48 <ski_> mmorrow : it seems to be `Tri' is just permuting the tuple type .. `F',`G',`H' seems extraneous
06:57:12 <ski_> /s/be/me/)
07:01:10 <blarfo> on windows?
07:01:11 <ski_> @. kindly type map.map
07:01:11 <lambdabot> Plugin `compose' failed with: Unknown command: "kindly"
07:01:44 <blarfo> does cabal come with ghc on ubuntu?
07:02:35 <luite> blarfo: if you mean cabal-install, no
07:03:37 <blarfo> how do i install it then?
07:04:09 <trofi> ,help
07:04:14 <lunabot>  luna: Not in scope: `help'
07:04:18 <luite> you can download it from hackage and run the bootstrap script
07:04:31 <aeolist> in lazy evaluation, if i need to calculate the same function with the same argument for a second time, are the results cached from the first time and thus second call is optimized and way faster?
07:04:37 <aeolist> (did i make any sense?)
07:04:51 <trofi> , $( [| 1 |] )
07:04:55 <lunabot>  1
07:05:07 <alexey_r> Hi all!
07:05:56 <ski_> alexey_r : no
07:06:04 <trofi> can i look at lunabot source? :]
07:06:29 <ski_> um
07:06:37 <blarfo> aeolist: thats memoization not laziness i think, not sure what the answer is though
07:06:41 <Raevel_> aeolist: yes that makes sense, and it could be optimized in some cases, but i'm not sure how it's handled in haskell
07:06:44 * ski_ replaces alexey_r with an aeolist
07:07:11 <aeolist> blarfo: that is true
07:07:29 <skorpan> does anyone know of a latex package which makes writing lambda calculus slightly easier?
07:07:33 <aeolist> so the ultimate question is... are pure functions' results cached?
07:07:40 <ski_> aeolist : so, typically, such would not be done automatically by plain laziness
07:07:44 <Saizan_> aeolist: no, you need to explicitly share it, like let shared = f x in <use shared multiple times>
07:07:44 <alexey_r> ski_: Ok, won't do that in the future.
07:07:51 <skorpan> currently i'm using {equation}, which forces me to use a whole bunch of tilde signs to make it readable
07:07:52 <aeolist> i asked the same thing a few days ago, but it seems i didnt get the answer
07:08:07 <lilac> aeolist: a variable defined in a let will only be evaluated once for each time the let is evaluated, typically. this isn't guaranteed by the language spec, but is typically what ghc does.
07:08:41 <ski_> alexey_r : nono, no problem with you greeting the channel .. it just so happened that my irc client then thought to expand "a" to your nick instead of the intended one ..
07:08:42 <lilac> aeolist: but a function called twice with the same argument typically will be evaluated multiple times. again, no guarantees
07:09:31 <blarfo> no GLUT-guru here?
07:09:33 <alexey_r> ski: Ok.
07:09:36 <aeolist> ok, i understand that something defined in let will be evaluated only the first time it's needed, and will be kept in memory for probable future uses
07:09:45 <Saizan_> aeolist: we have some nice idioms that exploit laziness to implement memoization however
07:09:49 <blarfo> i need GLUT-header for windows, where the f*** do i get it?
07:10:00 <aeolist> Saizan_: teach me
07:10:17 <Saizan_> aeolist: it will kept in memory as long as something has a reference to it
07:11:12 <ski_> > map fib [2,3,5,7]  where  fib n = fibs !! n;  fibs = [if n < 2 then n else fib (n-2) + fib (n-1) | n <- [0..]]
07:11:13 <lambdabot>   [1,2,5,13]
07:11:24 <lilac> aeolist: to memoize a function from naturals, we might represent it as a lazy list instead
07:11:31 <ski_> aeolist : that's an example of a memoized `fib'
07:11:32 <aeolist> aha
07:11:41 <trofi> , a = [| $a |]
07:11:42 <lunabot>  luna: parse error on input `='
07:11:47 <Saizan_> or a lazy array: http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
07:11:51 <lambdabot> Title: Gmane -- Mail To News And Back Again
07:11:54 <mikv> @src takeWhile
07:11:54 <lambdabot> takeWhile _ []                 =  []
07:11:54 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
07:11:54 <lambdabot>                    | otherwise =  []
07:12:01 <trofi> , let a = [| $a |] in a
07:12:06 <lunabot>  luna: out of memory (requested 2097152 bytes)
07:12:08 <Saizan_> which gives you O(1) random access
07:12:25 <alexey_r> I am trying to use SYB.WithClass and I don't understand something.
07:12:28 <ski_> lazy arrays are great for encoding some dynamic programming algorithms in a state-free way :)
07:12:34 <aeolist> i understand
07:13:10 <alexey_r> I am trying to update Scrap Your Nameplate for the current GHC and SYB.
07:14:10 <alexey_r> So I've got it to compile and work in GHCi, but not to compile to native code.
07:14:26 <Saizan_> which errors are you getting?
07:14:37 <luite> alexey_r: --make ? ;)
07:14:46 <blarfo> blarfo-angry-frustration!
07:15:00 <alexey_r> Of course I am using --make.
07:15:01 <ski_> > map fib [2,3,5,7]  where  fib = memoOnNaturals $ \n -> if n < 2 then n else fib (n-2) + fib (n-1);  memoOnNaturals f = (map f [0..] !!)
07:15:03 <lambdabot>   [1,2,5,13]
07:15:12 <blarfo> so
07:15:20 <blarfo> where do i find GLUTamentski?
07:15:48 <ski_> (you can easily make it into an alternative `fix' combinator .. exercise for the reader :)
07:17:00 <ski_> (another (harder ?) exercise for the reader : make a `fix' variant that will build a trace tree of inputs and outputs at each recursive call ..)
07:17:03 <Philonous> is ((->)a) the same as (typelambda b . a->b ) ?
07:17:12 <ski_> yes
07:17:14 <alexey_r> If I have $(derive [''Name]) in NominalBase, as in the 0.2 version, I get errors like
07:17:14 <alexey_r>  
07:17:14 <alexey_r> C:\Users\Alexey\AppData\Local\Temp\/ghc6380_0/ghc6380_0.s:2578: Error: symbol `_PolyLam_zdgfromName_info' is already defined
07:17:14 <alexey_r>  
07:17:14 <alexey_r> and similar for toName_closure, etc.
07:17:50 <ski_> Philonous : typically written `(a ->)' when GHC (or other implementations, no discrimination intended) isn't looking
07:18:28 <Saizan_> alexey_r: tried removing .hi files?
07:18:29 <ski_> (s/at each/of each/)
07:18:32 <alexey_r> From looking at http://hackage.haskell.org/packages/archive/syb-with-class/0.4/doc/html/Data-Generics-SYB-WithClass-Derive.html it seems that derive is only supposed to be used for imported modules.
07:18:34 <lambdabot> Title: Data.Generics.SYB.WithClass.Derive, http://tinyurl.com/6r8llo
07:18:45 <alexey_r> Saizan_: Yes.
07:19:35 <u_quark1> hey fredy7 ;)
07:20:16 <alexey_r> I removed $(derive [''Name]) from NominalBase and it compiles now, as do NominalSubst and NominalAbs. Then I run into trouble with PolyLam.
07:20:17 <fredy7> hey
07:21:09 <alexey_r> If I don't have a derive there, I get errors about undefined instances.
07:21:46 <alexey_r> If I put $(derive [''Name,''Abs]), I still get errors about undefined instances.
07:21:58 <alexey_r> For Type.
07:22:05 <Philonous> ski_: Is (a ->) a type?
07:22:20 <Philonous> And if yes what value would have this type
07:22:40 <trofi> , let { x = 1; y = $( VarE "x" ) }  in y
07:22:42 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
07:22:54 <mikv> Can i use "where" with guards?
07:23:08 <alexey_r> If I add ''Type to the list, then I get the same assembler errors again.
07:23:12 <mikv> something like
07:23:22 <mikv> | p x = ... ... ++[x]
07:23:34 <mikv> | p2 x = ... ... ++ [x]
07:23:36 <alexey_r> So that's my situation at the moment.
07:23:38 <mikv> where x = ...
07:23:40 <mikv> ?
07:23:57 <lilac> mikv: yes, you can do that.
07:24:00 <ski_> Philonous : `(a ->)' would be a type expression, of kind `* -> *' (assuming `a :: *'), so this is not a value-type, so it can't have values
07:24:13 <mikv> lilac, i want to use where for all guards
07:24:15 <ski_> @kind (->) Int
07:24:16 <lambdabot> ? -> *
07:24:24 <mikv> i have the same construction in all guards :-)
07:24:38 <ski_> (the `?' there is just GHC being a bit more generous, with subkinding and all)
07:25:13 <lilac> > let something like | even x = [1] ++ [x] | odd x = [2] ++ [x] where x = like + 1 in something 12
07:25:15 <lambdabot>   [2,13]
07:25:34 <ski_> *poof*
07:25:44 <lilac> mikv: ^^ the where scopes over all guards. this is the main difference between let and where
07:25:46 <mikv> lilac, thanks
07:26:32 <blarfo> blarfodonka!!!!!!!!!!!!!!!!!!!!!!!!!!
07:26:42 <blarfo> i need GLUT, surely osmeone must have installed it on windows-donka!?
07:28:40 <Saizan_> blarfo: apparently not, if you need it for an haskell libraries you might ask on haskell-cafe (otherwise it will be quite OT)
07:29:05 <trofi> am i alone seeing this when try to use hsc2hs from ghc-6.10.1? http://rafb.net/p/R0QjHy91.html
07:29:05 <lambdabot> Title: Nopaste - stdin
07:29:09 <Saizan_> the haskell-cafe@haskell.org mailing list, i mean
07:31:20 <Deewiant> blarfo: it's not rocket science: download the headers, put em in mingw/include, download the libraries, put em in mingw/lib. Download glut32.dll and place it wherever you like in your PATH, I prefer mingw/bin myself.
07:31:23 <Saizan_> trofi: do you have HsFFI.h under `which ghc`/../lib/include ?
07:32:12 <blarfo> Deewiant: but where is GLUT? i cant fidn them on the google-internets
07:32:33 <trofi> Saizan_: not there
07:33:04 <Deewiant> blarfo: http://www.google.com/search?q=glut%20mingw - top link.
07:33:05 <lambdabot> Title: glut mingw - Google Search
07:33:06 <trofi> dev-lang/ghc-6.10.1 (/usr/lib/ghc-6.10.1/include/HsFFI.h)
07:33:31 <trhj1> @hoogle a -> [a] -> [a]
07:33:31 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:33:31 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
07:33:31 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
07:33:33 <Saizan_> uhm yeah, my path was not quite right
07:33:47 <trofi> Saizan_: ghc is a script AFAIR
07:34:36 <trofi> when i supply -I/usr/lib/ghc-6.10.1/include/ to hsc2hs all works, but it looks odd
07:40:03 <p_l> blarfo: abandon all hope, those who try to use GHC on windows ...
07:41:04 <olsner> p_l: not so bad if you use binary distributions
07:41:43 <p_l> olsner: except that there is no package system with binaries of anything *outside* vanilla GHC
07:41:53 <olsner> cabal install :)
07:42:01 <vixey> aeolist, f 3 + f 3 may compute f 3 twice but let r = f 3 in r + r may only compute f 3 once
07:42:02 <olsner> and gtk2hs comes with an actual installer
07:42:30 <p_l> olsner: That's what I tried. It doesn't really work for Windows environments, not because of itself, but because of the packages
07:42:30 <aeolist> vixey: ah :) true true, now that you mention it i think i read it on haskell history.pdf somewhere
07:42:43 <jkr> Does anyone know how to get more debugging information from HDBC than with handleSql/catchSql/handleSqlError?
07:43:55 <olsner> that'll always be the problem with windows until someone builds an aggregate installer of ghc, *everything* on hackage and a haskell IDE
07:44:18 <olsner> since that's the kind of software "packages" windows is made to run
07:44:35 <p_l> olsner: change that to "rewrite build scripts for packages so that they support windows without including a POSIX layer"
07:44:43 <trofi> jkr: http://book.realworldhaskell.org/read/using-databases.html might help
07:44:48 <lambdabot> Title: Chapter 21. Using Databases
07:44:54 <blarfo> blarfmonkadonka
07:45:10 <blarfo> i try it on ubuntu instead
07:45:50 <Deewiant> programming on windows in a non-MS language requires a degree of tenaciousness
07:45:50 <p_l> olsner: If I could force GHC to work together with my Windows SDK6.1, without having to play with various stuff from MinGW and MSYS, using only windows libraries, I'd be overjoyed
07:46:04 <dancor> why doesn't ghc like: f = g h, f :: a -> a -> b, g :: (a -> b) -> (b -> c) -> a -> c
07:46:07 <p_l> Deewiant: Not always
07:46:35 <vixey> :t let f = f :: a -> a -> b ; g = g :: (a -> b) -> (b -> c) -> a -> c in g h
07:46:36 <lambdabot>     Inferred type is less polymorphic than expected
07:46:36 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
07:46:36 <lambdabot>         f :: a -> a -> b (bound at <interactive>:1:4)
07:46:45 <Deewiant> dancor: what's h
07:46:49 <Deewiant> p_l: Do tell
07:46:49 <EvilTerran> ?type (?f :: a -> a -> b) (?g :: (a -> b) -> (b -> c) -> a -> c) ?h
07:46:50 <lambdabot>     Could not deduce (?f::a -> a -> b) from the context ()
07:46:50 <lambdabot>       arising from a use of implicit parameter `?f'
07:46:50 <lambdabot>                    at <interactive>:1:1-2
07:47:09 <p_l> Deewiant: The biggest problem is installing new libs
07:47:17 <dancor> when i write out the unification i get h :: (a -> b) -> a
07:47:19 <EvilTerran> hmph
07:47:26 <vixey> dancor, what are f and g?
07:47:37 <vixey> dancor, or is this just a made up puzzle
07:47:42 <p_l> Deewiant: But that might be worked out using an equivalent of pkg-config
07:47:44 <dancor> it's a made up puzzle
07:47:47 <Deewiant> p_l: Yep, and you'll usually need them eventually. Or you're tenacious in another way and rewrite them all yourself. ;-)
07:48:25 <Saizan_> p_l: there is one?
07:48:25 <mmorrow> , let x = 1 in $(dyn "x")
07:48:28 <lunabot>  1
07:48:47 <mmorrow> , let x = 1 in $(varE . mkName $ "x")
07:48:49 <lunabot>  1
07:48:54 <p_l> Saizan_: MS Build includes a library reference mechanism
07:49:00 <EvilTerran> , src 'dyn
07:49:10 <lunabot>  dyn :: String -> Q Exp
07:49:21 <EvilTerran> , dyn "x"
07:49:24 <lunabot>  VarE x
07:49:24 <p_l> If it doesn't support enough stuff it might be modified to support classic libs
07:49:25 <mmorrow> dyn = varE . mkName
07:49:49 <mmorrow> i added instances of Show in lunabot for ExpQ, TypeQ, etc ... that aren't standard
07:49:59 <mmorrow> so to see that in ghci you'd do:
07:50:04 <mmorrow> runQ (dyn "x")
07:50:12 <mmorrow> , src 'runQ
07:50:17 <lunabot>  runQ :: forall m a . Quasi m => (Q a) -> m a
07:50:21 <mmorrow> unQ is also handy:
07:50:37 <mmorrow> unQ :: Q a -> a; unQ = unsafePerformIO . runQ
07:50:50 <mikv> @src (==)
07:50:50 <lambdabot> x == y = not (x /= y)
07:50:57 <mikv> @src (/=)
07:50:57 <lambdabot> x /= y = not (x == y)
07:51:03 <mmorrow> but since that implies the IO instance of Quasi, you can't do e.g. reify in IO
07:51:04 <vixey> Philonous: puzzle if you're bored or want to tinker, write a variadic function using GADTs (no typeclasses)
07:51:07 <trofi> :t (==)
07:51:08 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:52:05 <trofi> mmorrow: can i look at lunabot source somewhere?
07:52:28 <mmorrow> ski_: so are you saying that the (t ~ s) constraint in the GADT is extraneous?
07:53:20 <pk_> do you think I can take the C code generated by ghc and compile it for a small Âµcontroler ?
07:54:01 <mmorrow> trofi: sure. i have a somewhat cleaned-up version of the luna(bot) code + some other bits of the ghc-api that i pulled out temporarily so i could lightly modify to be more convenient: http://moonpatio.com/repos/luna/
07:54:06 <lambdabot> Title: Index of /repos/luna
07:54:11 <Badger> mmorrow: !
07:54:13 <mmorrow> that repo build on 6.10.1 (only)
07:54:28 <mmorrow> Badger: ?
07:54:29 <Badger> excellent :D
07:54:34 <mmorrow> hehe :)
07:54:44 <Badger> I was hoping to get your source, thankyou :P
07:54:45 <trofi> mmorrow: thanks! planning put it on hackage?
07:55:12 <mmorrow> trofi: i want to for sure. i've got a few more things i need to merge into that repo, then i'm gonna upload
07:55:40 <dancor> :t let g = g :: (a -> b) -> (b -> c) -> a -> c ; h = h :: (a -> b) -> a in g h
07:55:41 <lambdabot>     Inferred type is less polymorphic than expected
07:55:41 <lambdabot>       Quantified type variable `c' is mentioned in the environment:
07:55:41 <lambdabot>         g :: (a -> b) -> (b -> c) -> a -> c (bound at <interactive>:1:4)
07:55:54 <mmorrow> in the tools directory there's a repl that should be easily customizable/hackable
07:56:12 <trofi> great! :]
07:56:25 <Saizan_> :t let g :: (a -> b) -> (b -> c) -> a -> c ;g = undefined; h :: (a -> b) -> a; h = undefined in g h
07:56:25 <lambdabot> forall a b c. (a -> c) -> (a -> b) -> c
07:56:53 <Deewiant> ?ty let f h = flip (.) h in f
07:56:54 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
07:57:58 <dancor> it forces b = c, but then you get something of the form a -> a -> b
07:58:04 <Saizan_> mmorrow: btw, loadModuleTopLevelScope should set hscTarget = HscNothing, ghc shouldn't output the files then
07:58:07 <Deewiant> ?ty let g = flip (.); h :: a -> b; h = undefined in g h
07:58:08 <lambdabot> forall a b c. (b -> c) -> a -> c
07:58:18 <dancor> i guess ghc doesn't like the forcing-b=c part
07:58:29 <mmorrow> ooh, so the haskell-src-exts dep os only for the Luna.TH.* part, which isn't essential for the eval part, and haskell-src-exts recently got changed somewhat, so don't use the newest version (i'm gonna fix this too)
07:58:46 <mikv> E.g. i have Just 'a'
07:58:53 <mikv> How can i convert it to Char?
07:58:54 <mmorrow> Saizan_: awesome. is that the only difference?
07:59:26 <trofi> :t fromJust
07:59:26 <lambdabot> forall a. Maybe a -> a
07:59:37 <Saizan_> mmorrow: heh, i'm not sure, i've just seen this in haddock's sources
07:59:51 <mmorrow> but if all else fails, the modules under Luna.TH.* can be removed from the exposed-modules: part of the .cabal without causing problems for the rest
08:00:18 <gwern> I have a question. has anyone devised a map-like datastructure in which overriding a key to point to a new value would be a compile-time error?
08:00:19 <Dybber> Hi, I'm having trouble installing cabal-install. I'm trying to use the bootstrap script, but it fails. I (among others) get this error: /usr/bin/ld: cannot find -lgmp
08:00:37 <mmorrow> Saizan_: interesting. i'd be happy to get rid of the hack that's currently being used to control the files ;)
08:01:19 <dancor> Dybber: you need to install libgmp  http://gmplib.org/
08:01:28 <EvilTerran> gwern, er, well, it'd be more record-like than map-like, seeing as the "used keys" would probably have to be expressed in the type
08:01:31 <lambdabot> Title: The GNU MP Bignum Library
08:01:31 <trofi> many ambiguos occurences durin build
08:01:50 <mmorrow> trofi: uhoh, for what?
08:02:09 <mmorrow> (are you talking about luna?)
08:02:10 <dancor> i think it's the libgmp3-dev package in debian, e.g.
08:02:11 <gwern> EvilTerran: hm. so this has been done before?
08:02:44 <EvilTerran> gwern, well, extensible records have been done, and i imagine it'd be possible to adapt one to act in the way you suggest
08:02:59 <trofi> mmorrow: yes. will paste now
08:03:05 <trofi> mmorrow: http://rafb.net/p/Gz932U56.html
08:03:05 <lambdabot> Title: Nopaste - stdin
08:03:13 <mmorrow> trofi: if so, and you installed the haskell-src-exts hackage pkg in the last few days, it's prob on account of the changes there
08:03:14 <EvilTerran> but your keys would be fixed at compile-time
08:03:19 * mmorrow looks
08:03:36 <Dybber> dancor: thanks, that worked!
08:03:52 <mmorrow> yeah, that's haskell-src-exts. i'll put up a tarball of a version known to work
08:04:20 <gwern> EvilTerran: guess I'd better go look up research papers on extensible records then
08:04:23 <mmorrow> or you could just install an earlier version from hackage
08:04:27 <luite> ah, got the same problem building lambdabot
08:04:28 <trofi> can i put constraint into .cabal file to build it w'old ver?
08:04:30 <luite> yesterday
08:05:00 <quix> Is there a shortcut which gets this to work: let (x,y) = [1,2].  I know it works with a tuple on the right, and I know I can index with !!.  I'm looking for a one-liner, if it exists.
08:05:02 <EvilTerran> ?where hlist
08:05:03 <lambdabot> http://homepages.cwi.nl/~ralf/HList
08:05:25 <EvilTerran> gwern, Oleg's done things like that, in HList and related papers
08:05:28 <dancor> @pl \ [x, y] -> (x, y)
08:05:28 <lambdabot> (line 1, column 3):
08:05:28 <lambdabot> unexpected "["
08:05:28 <lambdabot> expecting pattern
08:05:34 <gwern> noooo
08:05:35 <dancor> heh
08:05:38 <EvilTerran> quix, why are you trying to do that?
08:05:46 <gwern> oleg's stuff is as useless to me as calculus to a monkey
08:06:14 <quix> EvilTerran: because I have an array of four things, and I want put names on the elements.
08:06:24 <sclv> ?pl \ xs -> (head xs, last xs)
08:06:24 <lambdabot> liftM2 (,) head last
08:06:24 <luite> mmorrow: how do I specify which version is used, when both are installed?
08:06:39 <mmorrow> trofi: http://moonpatio.com/repos/haskell-src-exts/
08:06:39 <EvilTerran> quix, ah, ok
08:06:39 <lambdabot> Title: Index of /repos/haskell-src-exts
08:06:42 <sclv> > liftM2 (,) head last $ [1,2]
08:06:43 <lambdabot>   (1,2)
08:06:44 <EvilTerran> > let [x,y] = [1,2] in x+y
08:06:46 <lambdabot>   3
08:06:54 <mmorrow> luite: i'm gonna put a constraint in the .cabal. one sec.
08:07:06 <Surma> hey guys. I'm new, I have a problem, and I honestly don't know what to google for. I have the following comparison: ``d > sqrt(n)'' in my programm (n being int). Of course that yields errors, but I don't know how to fix them. Help Please?
08:07:07 <EvilTerran> quix, you can pattern-match on lists too :)
08:07:21 <EvilTerran> Surma, "d^2 > n"
08:07:24 <Deewiant> liftM2 (,) = (&&&)
08:08:03 <PeakerWork> Deewiant: an applicative instance is probably more likely than an arrow instance (liftA2)
08:08:12 <vixey> quix, let [x,y] = [1,]2
08:08:24 <vixey> Surma, d*d > n
08:08:34 <sclv> gwern: one could maybe do it with existentials as used in the state monad?
08:08:50 <Deewiant> PeakerWork: I was thinking of the common case of functions
08:08:51 <sclv> open type witnesses and all -- though its sort of awkward
08:09:04 <Surma> EvilTerran: vixey: -.- could have thought of that, yeah
08:09:15 <mmorrow> luite, trofi, Badger: ok, i just added a constraint on the version of haskell-src-exts to the .cabal, so repull if needed
08:09:22 <Surma> EvilTerran: vixey: still, what *would* be the solution, if I couldn't do that
08:09:28 <sclv> s/state/sts/
08:09:33 <EvilTerran> Surma, the other possibility would be to faff around with floor, ceiling, round, etc
08:09:40 <EvilTerran> and fromInteger/fromIntegral to go the other way
08:09:42 <vixey> Surma, Haskells number setup is broken beyond repair
08:09:54 <sclv> vixey I utterly disagree!
08:09:58 <EvilTerran> but why do that when it'll be slower, less clear, *and* less accurate? :P
08:10:10 <gwern> sclv: could template haskell help? at compile-time analyze a list-being-turned-into-a-map for duplicate entries and abort compilation if there are?
08:10:25 <EvilTerran> vixey, i happen to think sqrt being a pain to use when you're dealing with integers is an excellent idea
08:10:26 <Surma> EvilTerran: I definitely will choose your way, it's just curiosity
08:10:37 <sclv> gwern, only if you had a "freeze" function though...
08:10:52 <quix> EvilTerran and vixey -- thanks, I had thought I tried let [x,y] that, but it works after all.
08:11:12 <vixey> quix, you had round brackets earlier
08:11:14 <sclv> so you have yr. th which compiles to a safe map description, but the map it produces doesn't export any functions to add new keys.
08:11:42 <vixey> sclv, well it's beyond _my_ ability to repair it
08:11:50 <gwern> sclv: the usecase is xmonad; all the keys are specified at compile-time
08:12:07 <gwern> keys here being a pun on both keyboard keys and Map keys :)
08:12:49 <sclv> vixey -- what don't you like about numbers in haskell?
08:13:09 <sclv> outside of the typeclass requiring too much and not being granular enough?
08:13:31 <mmorrow> gwern: i think you could use template-haskell for that somehow. otoh i'm not sure exactly the particulars, but the idea would be to have a function insertQ :: key -> ExpQ, where the ExpQ will end up being of type (value -> Map -> Map), and hide the regular insert functions, then the only way to insert into a Map would be to use insertQ which needs a real literal value at compile time
08:13:55 <mmorrow> by otoh i meant "off the top of my head", not "on the other hand" ;)
08:14:36 <gwern> hm. sounds reasonable
08:14:51 <mmorrow> insertQ key = [|M.insert key|]
08:15:18 <trofi> length (keys xs) /= length $ nub (keys xs)
08:15:20 <mmorrow> actually, that's way easy :) (note, that using key like that means it needs to be an instance of Lift)
08:15:30 <EvilTerran> gwern, must the keys be specified at compile-time?
08:15:36 <Saizan_> that's almost like using an indexed (or was it parametrized?) state monad with keys at the type level
08:15:41 <mmorrow> trofi: did you get it built?
08:15:44 <EvilTerran> why not let them change at run-time?
08:15:48 <gwern> EvilTerran: I think so. I'm not familiar with any xmonad extensions which let you rebind keys on the fly
08:15:50 <trofi> mmorrow: yes, thanks! :]
08:15:55 <mmorrow> cool :)
08:17:02 <luite> mmorrow: oh sorry I was talking about lambdabot, which has the same problem. but where can I find the luna repository? :)
08:17:23 <trofi> luite: http://moonpatio.com/repos/luna/
08:17:25 <lambdabot> Title: Index of /repos/luna
08:17:27 <mmorrow> luite: ah.. http://moonpatio.com/repos/luna/
08:17:28 <lambdabot> Title: Index of /repos/luna
08:17:33 <luite> tnx both ;)
08:17:37 <mikv> Can somebody help
08:17:38 <trofi> @help where
08:17:38 <lambdabot> where <key>. Return element associated with key
08:17:41 <mmorrow> it needs exactly 6.10.1
08:17:44 <mikv> to find you whats wrong with my code
08:17:48 <C-Keen> what's the difference between the two?
08:17:50 <mikv> i've posted it to hpaste
08:17:52 <mikv> http://hpaste.org/12090
08:17:57 <mmorrow> (due to ghc-api volatility)
08:18:05 <trofi> how to populate lambdabot with where? :]
08:18:16 <EvilTerran> ?where+ luna http://moonpatio.com/repos/luna/
08:18:17 <lambdabot> Okay.
08:18:30 <trofi> thnx
08:18:31 <vixey> mikv, I'd suggest you take a totally different approach to this
08:18:32 <EvilTerran> ?where+ lunabot http://moonpatio.com/repos/luna/
08:18:32 <lambdabot> Done.
08:18:37 <quix> In my very first Haskell program I ran into what I later discovered was the monomorphism restriction.  Real World Haskell states, "Because the monomorphism restriction is unwanted and unloved, it will almost certainly be dropped from the next revision of the Haskell standard."  But there's no indication of this on the wiki entry.
08:18:47 <mikv> vixey, ?? Can you suggest different approach?
08:18:59 <vixey> mikv, yeah
08:19:21 <vixey> mikv, you can change data HTree  = Leaf Char | Branch (HTree) (HTree) a little
08:19:33 <mmorrow> i also have a super simple js eval via spidermonkey jsapi  at: http://moonpatio.com/repos/mm-js/
08:19:34 <lambdabot> Title: Index of /repos/mm-js
08:19:35 <vixey> mikv, data HTree a = Leaf a | Branch (HTree a) (HTree a)
08:19:56 <olsner> quix: I think the "next revision" of the haskell standard has a release date arbitrarily far into the future
08:20:02 <vixey> mikv, that way the type in the leaves can be different, so your original HTree is now HTree Char
08:20:02 <mmorrow> ) (function(x){return(x*2)})(42)
08:20:02 <lunabotjs>  84
08:20:07 <mmorrow> ) Date()
08:20:08 <lunabotjs>  Sun Nov 16 2008 09:50:52 GMT-0600 (CST)
08:20:19 <gwern> @src Data.Map.fromList
08:20:19 <lambdabot> Source not found. My mind is going. I can feel it.
08:20:22 <EvilTerran> mmorrow, oh, nice
08:20:24 <gwern> @src fromList
08:20:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:20:32 <Botje> yay
08:20:39 * Botje has managed to make a debian package of ghc 6.10
08:20:41 <vixey> mikv, There's a very very useful function on HTree that you can write almost everything else in terms of
08:20:43 <idnar> why does the monomorphism restriction exist?
08:20:45 <gwern> Botje: excellent
08:20:50 <Botje> now to find a victim to test it on
08:20:55 <dancor> mikv: fyi the immediate problem seems to be that you did hDecodeReal (restOfBs tree) instead of hDecodeReal restOfBs tree in hDecodeReal
08:20:56 <mikv> vixey, i am listening to you carefully
08:21:05 <Deewiant> idnar: the Haskell 98 committee was scared of polymorphism
08:21:05 <vixey> mikv:
08:21:12 <vixey> foldHuff leaf branch = Ï
08:21:17 <vixey>  where Ï (Leaf o) = leaf o
08:21:18 <vixey>        Ï (Branch left right) = branch (Ï left) (Ï right)
08:21:32 <mmorrow> ) map = function(f,xs){var ys=new Array(xs.length); for(var i=0;i<ys.length;i++) ys[i]=f(xs[i]); return(ys)}; map(function(x){return(x*2)},[0,1,2,3,4,5,6,7,8,9])
08:21:32 <lunabotjs>  0,2,4,6,8,10,12,14,16,18
08:21:42 <EvilTerran> ... why phi?
08:21:54 <Botje> EvilTerran: it looks a bit like a tree :)
08:21:57 <idnar> haha
08:22:02 <mikv> vixey, your suggestion was right. Issue was resolved
08:22:26 <mikv> vixey, Interesting, but what this generalization will give me?
08:22:37 <vixey> mikv, so the type is foldHuff :: (a -> z) -> (z -> z -> z) -> HTree a -> z,  it replaces every constructor 'Leaf' with leaf and 'Branch' with the function branch
08:22:42 <mikv> vixey, definition of this datastructure was in my assignment
08:22:57 <mikv> vixey, but i am interested in
08:23:01 <vixey> mikv, with that function you can write pretty much every useful operation on HTree
08:23:13 * EvilTerran has only seen one particularly good excuse for using a greek letter; rho for Ïtations
08:23:18 <EvilTerran> :P
08:23:25 <vixey> mikv, depthFirstTraversal = foldHuff return (++),  member e = foldHuff (== e) (||), ... etc
08:23:29 <Deewiant> idnar: consider: the monomorphism restriction, renaming 'map' to 'fmap', renaming '++' to 'mplus', possibly other stuff, that came between haskell 1.4 and 98.
08:23:41 <idnar> Deewiant: yeah, okay
08:23:51 <vixey> mikv, but to solve your encoding problem, you really want to write a function  codify :: HTree a -> HTree (Path,a)
08:23:53 <quix> I thought phi was used because that equation represents the isomorphism property.  phi is often used for that in group theory.
08:23:55 <vixey> where Path = [Bit]
08:23:59 <idnar> Deewiant: I thought there might be something more specific than The Great Polymorphism Scare
08:24:02 <vixey> oops
08:24:06 <vixey> Path = [Direction]
08:24:07 <EvilTerran> Deewiant, they should get oleg on board for the next one
08:24:09 <gwern> phooey, no source links in hoogle
08:24:10 <Botje> EvilTerran: theta is commonly used in type inferencers too :)
08:24:11 <vixey> data Direction = Left | Right
08:24:18 <Deewiant> EvilTerran: that's taking it a bit too far. :-P
08:24:22 <EvilTerran> Oleg isn't scared of polymorphism, polymorphism is scared of Oleg!
08:24:27 <Deewiant> Haha
08:24:30 <Botje> :)
08:24:36 <Deewiant> @remember EvilTerran Oleg isn't scared of polymorphism, polymorphism is scared of Oleg!
08:24:37 <lambdabot> Good to know.
08:24:44 <ziman> hehe :)
08:24:51 <EvilTerran> :)
08:24:58 <Deewiant> As a general rule I don't like functions where the type signature is over twice as long as the implementation
08:25:12 <luite> mmorrow: thanks, works :)
08:25:15 <mikv> vixey, hmm. i didn't understand how foldHuff works
08:25:31 <EvilTerran> Deewiant, what about when the type sig *is* the implementation, and the value's irrelevant? :P
08:25:34 <luite> mmorrow: it does give a warning about indirectly depending on different versions of the same module, but that's ok, right?
08:25:45 <mikv> vixey, what is \phi?
08:25:51 <Deewiant> EvilTerran: I think that sort of implies that the sig is quite a bit longer. :-P
08:25:58 <jkr> Why are haskell binaries so huge, btw?
08:26:07 <newsham> conal's blog should be called "things that will blow your mind"
08:26:25 <vixey> mikv, ok so ,,  return 1 = [1]
08:26:28 <EvilTerran> jkr, there's a fixed cost from statically linking the ghc runtime
08:26:31 <Deewiant> jkr: Tonnes of useless C debugging info. "strip -s" brings them down quite a bit. After that, it's mostly the GHC RTS.
08:26:38 <luite> jkr: to compensate for the small source ;) (or maybe because of the rts that's linked)
08:26:41 <jkr> I just wrote a simple program that fetches an RSS feed and writes the items to a database, and the binary is 1,6M
08:26:47 <gwern> jkr: because no one uses JHC, is why
08:26:48 <jkr> (stripped)
08:27:00 <Deewiant> jkr: And yes, there's the fact that dynamic linking is not used.
08:27:02 <EvilTerran> the RTS never gets any bigger, though, so it's not that much of a problem for big programs
08:27:13 <mmorrow> luite: cool. hmm, it's probably ok. (you mean cabal says that and it has to do with base4 and base3, right?)
08:27:16 <vixey> mikv, for an example,  foldHuff return (++) (Branch (Leaf T) (Branch (Leaf F) (Leaf T))), every Leaf is replaced with 'return' and every 'Branch' is replaced with (++),  so you get ((return T) ++ ((return F) ++ (return T))) = [T,F,T]
08:27:20 <Deewiant> Every library is another 500 K or more.
08:27:38 <mmorrow> luite: if that's the case, then you're fine.
08:27:52 <vixey> mikv, and for checking a particular object is in the tree, you can use foldHuff (== whatImLookingFor) (||), makes sense?
08:27:53 <jkr> Can I disable static linking?
08:27:57 * mmorrow hasn't crashed on account of it (yet...)
08:28:22 <mikv> vixey, ok. I understand now
08:28:27 <idnar> Huff?
08:28:30 <gwern> jkr: no not really
08:28:38 <mikv> vixey, but i am confused with \phi in your declaration.
08:28:55 <gwern> > let x = [1..10, 10, 10] in nub x == x
08:28:56 <lambdabot>   <no location info>: parse error on input `,'
08:28:56 <luite> mmorrow: it doesn't specify the package: Configuring luna-0.1.0...\nWarning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure.
08:28:57 <mikv> vixey, i hope it will be covered in our next lections :-)
08:28:58 <Deewiant> jkr: There's very limited support for it, so not really.
08:29:03 <vixey> mikv, what about it?
08:29:06 <Deewiant> AIUI it's being worked on.
08:29:09 <luite> mmorrow: but it compiles and runs fine
08:29:16 <gwern> > let x = [1..10, 10, 10] in (nub x == x)
08:29:17 <lambdabot>   <no location info>: parse error on input `,'
08:29:18 <jkr> Hrm, there's a -dynamic option, but it doesn't seem to find the libs to link
08:29:19 <Philonous> The idea behind variadic functions is to give them a polymorphic return type (either a or b->a) ?
08:29:21 <mmorrow> luite: ah, yeah you're good :)
08:29:22 <gwern> hm.
08:29:30 <vixey> Philonous, no
08:29:33 <EvilTerran> mikv, don't worry about \phi, it's just a name; like "f" is
08:29:47 <gwern> > [1..10, 10, 10]
08:29:48 <lambdabot>   <no location info>: parse error on input `,'
08:29:57 <gwern> huh. we're not allowed to do that?
08:29:59 <EvilTerran> > let Ï = (,) in Ï 1 2
08:30:00 <lambdabot>   (1,2)
08:30:06 <trofi> mmorrow: how do you export luna to irc? :]
08:30:06 <EvilTerran> > let f = (,) in f 1 2
08:30:07 <PeakerWork> gwern: I think the format has to be: [<first>[,<second>]..<last>]
08:30:08 <lambdabot>   (1,2)
08:30:10 <gwern> no, it fails in ghci as well
08:30:14 <dancor> > [1..10,2]
08:30:15 <lambdabot>   <no location info>: parse error on input `,'
08:30:25 <PeakerWork> > [1..10] ++ [2]
08:30:25 <mikv> EvilTerran, i am trying to understand where \phi was defined
08:30:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,2]
08:30:27 <EvilTerran> PeakerWork, you need []s around "last" too
08:30:31 <gwern> > let x = [1..10] ++ [10, 10] in (nub x == x)
08:30:32 <lambdabot>   False
08:30:35 <mmorrow> trofi: i have a really hackish bot shell i'm using. i'll put that up...
08:30:40 <PeakerWork> EvilTerran: ah, right
08:30:40 <idnar> >[..10]
08:30:42 <mikv> EvilTerran, because it wasn't mentioned in where section
08:30:42 <idnar> > [..10]
08:30:43 <lambdabot>   <no location info>: parse error on input `..'
08:30:44 <idnar> aww
08:30:50 <EvilTerran> mikv, it's defined in the "where" clause
08:31:28 <mikv> EvilTerran, hmm.... AAA
08:31:36 <dancor> > reverse $ map (10 -) [0..]
08:31:43 <mikv> EvilTerran, it was defined with help of pattern matching
08:31:47 <mikv> EvilTerran, right?
08:31:54 <lambdabot>   mueval: Prelude.read: no parse
08:31:57 <dancor> is that what you were expecting idnar
08:31:58 <gwern> mmorrow: I've been thinking about your TH sugestion, and while I see how it guarantees us a static fully-defined Map at compile-time, I don't see how one would get the no-dupes condition - the insert operators would still overwrite previious versions
08:31:58 <PeakerWork> > reverse . reverse $ [0..]
08:32:04 <Philonous> I meant one idea to implement them
08:32:09 <lambdabot>   mueval: Prelude.read: no parse
08:32:19 <EvilTerran> mikv, yes, its definition in the where-clause is defining it with pattern-matching on its parameter
08:32:21 <PeakerWork> > reverse $ reverse $ [0..]
08:32:35 <lambdabot>   mueval: Prelude.read: no parse
08:32:39 <gwern> reverse . reverse [1..] won't terminate anyway
08:32:45 <trofi> , putStrLn "asd"
08:32:45 <dancor> @src reverse
08:32:46 <lambdabot> reverse = foldl (flip (:)) []
08:32:47 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
08:32:54 <mmorrow> trofi: well, there's the bot.hs, then there's a module that sets rlimits maps stdin -> eval -> stdout which isn't completely trivial
08:33:00 <vixey> that's a stupid definition
08:33:03 <mmorrow> *sets rlimits _and_ maps ...
08:33:11 <vixey> reverse = flip revappend []
08:33:23 <gwern> PeakerWork: I think that's what you are seeing there - the timelimit is killing mueval
08:33:25 <mmorrow> gwern: ah, i missed the part about no dups
08:33:32 <mikv> EvilTerran, ok. thanks..
08:33:35 <idnar> dancor: no, I was expecting an infinite list starting at -infinity and ending at 10 ;)
08:33:39 <vixey> It's completely non-obvious where foldl (flip (:)) came from
08:33:49 <idnar> (I use the word "expecting" loosely)
08:33:50 <dancor> idnar: yeah that's what i did :)
08:33:51 <mmorrow> gwern: you could always do something like:
08:33:52 <gwern> vixey: well, you could lobby ghc to add a rewrite rule that 'reverse . reverse = id'
08:34:04 <vixey> I don't care about that gwern
08:34:08 <idnar> dancor: oh, I see
08:34:10 <idnar> dancor: misread
08:34:11 <vixey> I don't like this foldl (flip (:)) []
08:34:17 <PeakerWork> gwern: I wonder if its using the rewrite rule for reverse.reverse
08:34:29 <gwern> PeakerWork: mueval you mean? very unlikely
08:34:34 <Deewiant> > foldl (flip f) z [a,b,c,d,e]
08:34:35 <lambdabot>   f e (f d (f c (f b (f a z))))
08:34:39 <gwern> I'm not sure the ghc api even turns on rewrite rules
08:35:03 <gwern> and I would be even more surprised if there were a rule for reverse . reverse. not many people write or care about rewrite rules
08:35:49 <mmorrow> insertQ key val m = [| M.insert key (maybe val (\x -> fail ("dup!!@: "++show x)) (M.lookup key val m)) m|]
08:36:08 <mmorrow> that needs Map to be an instance of Lift though (which is doable)
08:36:08 * EvilTerran quite likes reverse = ($[]) . foldr (\x f xs -> f (x:xs)) id
08:36:14 <gwern> hm.
08:36:22 <vixey> data List a = Forward [a] | Backwards [a]
08:36:29 <vixey> reverse (Forward xs) = Backward xs
08:36:30 <Deewiant> ?pl \x f xs -> f (x:xs)
08:36:30 <lambdabot> flip (.) . (:)
08:36:41 <Deewiant> ?ty (:) >>> (>>>)
08:36:42 <lambdabot> forall a d. a -> ([a] -> d) -> [a] -> d
08:36:47 <EvilTerran> vixey, no fair changing the data representation to render the operation trivial! that's cheating! :P
08:37:01 <mmorrow> gwern: that also brings /everything/ related to the map into the $(.....here.....)
08:37:17 <Deewiant> vixey: okay, now define head :: List a -> a. :-)
08:37:25 <lilac> data List = []; reverse [] = []
08:37:39 <EvilTerran> lilac, s/data/type/?
08:37:41 <Deewiant> _ : [] = []
08:37:57 <mmorrow> gwern: which may be problematic
08:37:58 <trofi> , $( [| unsafeTerformIO $ putStrLn "asd" |] )
08:38:00 <lunabot>  luna: Not in scope: `unsafeTerformIO'
08:38:05 <trofi> , $( [| unsafePerformIO $ putStrLn "asd" |] )
08:38:05 <Deewiant> unsafeTerraformIO
08:38:07 <lunabot>  luna: Not in scope: `unsafePerformIO'
08:38:13 <gwern> :t fail
08:38:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
08:38:16 <EvilTerran> somehow
08:38:23 <olsner> hmm, how can I combine setInput and setPosition into something properly saving and restoring source positions in included files?
08:38:29 <EvilTerran> unsafePerformIO being not in scope doesn't really surprise me
08:38:31 <lilac> EvilTerran: no, my constructor is called [] :)
08:38:45 <olsner> (parsec)
08:38:55 <PeakerWork> How bad would it really be to generalize functions to Foldable, instead of being on lists, and then have an infinite list type that doesn't have operations like reverse?
08:38:59 <foo-nix> twanvl: can I pm you for a conversation on soco.
08:39:00 <foo-nix> ?
08:39:20 <PeakerWork> s/Foldable/various instances of list
08:39:26 <gwern> mmorrow: actually, I was thinking that maybe a simpler approach would be to operate on the original list being turned into a map; that is, 'verifyQ list = [|if nub list \= list then fail "Duplicate keys" else list|]; keymap = $([(q, spawn "foo"), (r, spawn "bar")])'
08:39:54 <luite> where has Data.Generics gone in base 4?
08:40:10 <Deewiant> luite: the syb package.
08:40:25 <gwern> mmorrow: although that doesn't quite typecheck it seems
08:40:59 <luite> Deewiant: ah thanks
08:41:23 <gwern> @hoogle ExprQ -> a
08:41:23 <lambdabot> Warning: Unknown type ExprQ
08:41:23 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:41:23 <lambdabot> Prelude id :: a -> a
08:41:25 <Deewiant> luite: there's also Data.Data in base, which is something like it.
08:41:28 <trofi> , $( fail "oh\noh" )
08:41:30 <lunabot>  luna: oh
08:41:48 <gwern> trofi: pardon?
08:42:16 <trofi> gwern: what've i done?
08:42:32 <gwern> trofi: presumably borked your compile
08:43:08 <gwern> I would look stuff up the TH docs but my webconnection is slower than molasses in january right now X_X
08:43:16 * gwern suspects my connection has been throttled
08:44:45 <gwern> ack, I forgot about the same-module restriction
08:44:47 <gwern> man I hate that
08:45:05 <mmorrow> trofi: i actually have to fix up the bot and sandboxed evaluator since lunabot's using an older version of luna and it doesn't map to the newer one very trivially
08:45:30 <mmorrow> i'm gonna do that shortly though, since i've been meaning to anyways. i'll let you know
08:45:38 <trofi> ok :]
08:46:03 <gwern> trofi: I see your point now. I forgot to use verifyQ in the $()
08:46:49 <mmorrow> gwern: hmm, that looks like a better idea for sure.
08:47:54 <gwern> but it doesn't seem to work... hm
08:48:11 <gwern> 'error' should kill the TH and the compilation shouldn't it?
08:48:23 <mmorrow> ooh, well you'll have to call verifyQ on the list in a module /separate/ from the one you splice it into with $(....), but that's not that big a deal
08:48:29 <mmorrow> yes
08:48:38 <mmorrow> fail "asdf" errors the build out
08:49:06 <mmorrow> there's a better way to trigger an error, but i haven't used that enough to give advice on how to do it
08:49:11 <hukolele> help!, how can i get elements from a list until 2 adyacent equals?
08:49:17 <gwern> mmorrow: well, currently I define 'verifyQ in Tmp.hs, and inside xmonad.hs, I call 'keymap = $( verifyQ ['q', 'r', 'q', 'r'] ), and I compile xmonad.hs
08:49:36 <hukolele> > iterate (/2) [1..]
08:49:37 <mmorrow> ah yeah, i remember now.
08:49:37 <lambdabot>       No instance for (Fractional [t])
08:49:37 <lambdabot>        arising from a use of `/' at <i...
08:49:38 <mmorrow>   qReport :: Bool -> String -> m ()
08:49:49 <gwern> @hoogle qReport
08:49:50 <lambdabot> Language.Haskell.TH.Syntax qReport :: Quasi m => Bool -> String -> m ()
08:49:52 <mmorrow> the Bool is for specifying whether this is a fatal error or not
08:50:09 <hukolele> > iterate (/2) 1
08:50:11 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
08:50:24 * mmorrow always just uses fail, but is ashamed of himself
08:51:34 <mmorrow> gwern: nice, that looks like it'll be pretty smooth to get that working then
08:52:31 <hukolele> for example how can i get the first element that satisfies is less than 0,1 than the precedence, i .e. |x(n)-x(n-1)| < 0.1
08:52:38 <hukolele> in a list
08:53:04 <gwern> dammit it's not working
08:53:12 <mmorrow> what's the error?
08:54:05 <gwern> well, either it compiles fine, and produces a binary even when I hand verifyQ a bad list
08:54:06 <abbe> hi all, I'm having an issue with indentation of my code, can anyone help me figure out the issue ?
08:54:13 <gwern> or it gives me a cryptic TH type mismatch
08:54:32 <mmorrow> gwern: hmm, i'll paste an example of killing compilation
08:54:47 <gwern> http://hpaste.org/12094
08:55:05 * abbe has pasted his code at http://hpaste.org/12093?lines=true
08:55:05 <gwern> if I supply a type sig for verifyQ, it's 'verifyQ :: (Lift a) => [a] -> Language.Haskell.TH.Lib.ExpQ' and the first error
08:55:13 <gwern> comment out the type sig, and the error is the latter
08:55:52 <Botje> abbe: you forgot the "else" part of your if-then-else
08:55:54 <abbe> the error is mentioned in a comment in the paste
08:55:54 <geezusfreeek> abbe: you need an else for that if
08:56:22 <abbe> Botje, geezusfreeek: so that is an indentation issue, hmm...?
08:56:42 <geezusfreeek> abbe: it is a parse issue, and the compiler suggests that it _may_ be an indentation issue
08:57:00 <Deewiant> the compiler could really be nicer about parse errors than "there is an error"
08:57:12 <geezusfreeek> agreed
08:57:24 <abbe> geezusfreeek: what parsing issue, I tried adding else, but error is still there.
08:57:40 <geezusfreeek> abbe: "else return ()" ?
08:57:44 <geezusfreeek> or something similar?
08:57:48 <abbe> geezusfreeek: yes
08:57:51 <geezusfreeek> paste it
08:58:15 <geezusfreeek> the else will need to be aligned with "then"
08:58:42 <gwern> mmorrow: a side note - the     Couldn't match expected type `Char' against inferred type `()'
08:58:47 <gwern> occurs with a valid list
08:58:55 <gwern> something is wrong with my definition of verifyQ
08:59:01 <gwern> 'verifyQ :: (Lift a) => [a] -> Language.Haskell.TH.Lib.ExpQ
08:59:02 <gwern> verifyQ list = [|if nub list /= list then qReport True "Duplicate keys" else list|]'
08:59:54 <geezusfreeek> abbe: like http://hpaste.org/12093#a1
09:00:03 <gwern> the problem is, if I use 'fail' or 'error' instead of qreport, then it always succeeds
09:00:14 <geezusfreeek> @src when
09:00:14 <lambdabot> when p s = if p then s else return ()
09:00:25 <geezusfreeek> ^ might be useful to you
09:01:39 <mmorrow> gwern: http://hpaste.org/12095
09:01:48 <C-Keen> hm, I want to find the longest in/prefix of a list that appears more than once in the list, is  there a function in Base that does this?
09:02:17 <abbe> geezusfreeek: http://hpaste.org/12093#a2, same code as yours but still the same error
09:02:18 <EvilTerran> ... it strikes me as a bit too unusual a desire to appear in the base...
09:02:24 * gwern tries using just 'report'
09:02:32 <EvilTerran> but, as this is haskell and you're talking about lists, it's probably pretty easy
09:02:54 <C-Keen> EvilTerran: how would you look for that?
09:03:31 <gwern> @hoogle listE
09:03:32 <lambdabot> Language.Haskell.TH listE :: [ExpQ] -> ExpQ
09:03:32 <lambdabot> Language.Haskell.TH.Lib listE :: [ExpQ] -> ExpQ
09:03:32 <lambdabot> Language.Haskell.TH ListE :: [Exp] -> Exp
09:03:33 <mmorrow> gwern: so the essential thing is that you have to make sure you're doing the computation /at compile-time/, and not just returning the quoted expression which does the test
09:03:36 <abbe> geezusfreeek: and it says when is not in scope, should I define it.
09:03:47 <geezusfreeek> abbe: ah, do notation doesn't like if-then-else, so you have to indent the then and else here. sorry http://hpaste.org/12093#a3
09:04:02 <geezusfreeek> and that does make sense as a parse error, i think
09:04:14 <EvilTerran> C-Keen, well, you could start by getting all the prefixes, longest first:
09:04:23 <EvilTerran> > Data.List.inits "abracadabra"
09:04:25 <lambdabot>   ["","a","ab","abr","abra","abrac","abraca","abracad","abracada","abracadab"...
09:04:26 <gwern> mmorrow: why do we need to lift each item in the list into ExpQ and then do a join on the [ExpQ]? ExpQ [a] doesn't work?
09:04:34 <Deewiant> EvilTerran: didn't he want infixes
09:04:35 <EvilTerran> well, that's shortest first, unfortunately
09:04:39 <C-Keen> EvilTerran: more like tails
09:04:42 <gwern> we could not just do 'lift xs'?
09:04:51 <EvilTerran> Deewiant, he wanted "in/prefixes"; i'm not sure what that means
09:04:54 <mmorrow> gwern: i just did that because i'm not sure if there's an instance (Lift a) => List [a]
09:05:01 <C-Keen> > Data.List.tails "1234"
09:05:02 <lambdabot>   ["1234","234","34","4",""]
09:05:06 <Deewiant> EvilTerran: I took it as "infixes/prefixes" which means "infixes"
09:05:06 <mmorrow> but if there is, then you can just do lift xs
09:05:19 <mmorrow> (or just write such an instance with listE)
09:05:24 <gwern> seems to be
09:05:27 <mmorrow> nice
09:05:45 <EvilTerran> > concatMap tails . inits $ "abcd"
09:05:47 <lambdabot>   ["","a","","ab","b","","abc","bc","c","","abcd","bcd","cd","d",""]
09:05:50 <C-Keen> Deewiant: EvilTerran yeah infixes are needed
09:06:04 <EvilTerran> C-Keen, ah, so the longest substring that appears more than once?
09:06:10 <abbe> geezusfreeek: thanks, that works :)
09:06:11 <C-Keen> EvilTerran: yes
09:06:36 <gwern> ok now it seems to be working fine
09:06:41 <mmorrow> awesome
09:06:43 <gwern> time to turn it into something usable in a xmonad.hs
09:06:44 <Deewiant> This is the longest common substring problem where both strings are the same, no?
09:06:51 <abbe> geezusfreeek: a question, if use braces instead of indentation, do I still get similar error
09:07:00 <EvilTerran> this reduces to "longest prefix that appears again later", as you could map over the tails of the list
09:07:06 <abbe> s/use/I use/ s/or$/or ?/
09:07:20 <EvilTerran> which reduces to "longest prefix that is also a suffix", as you could map over the inits
09:07:25 <abbe> s/do/will/
09:07:34 <gwern> > map fst [(1,2), (3,4)]
09:07:35 <lambdabot>   [1,3]
09:08:23 <C-Keen> EvilTerran: hm...
09:08:25 <EvilTerran> Deewiant, not quite, longestCommonSubstring s s = s
09:08:46 <EvilTerran> C-Keen, actually, ignore that last one, that makes it needlessly more complicated
09:09:42 <EvilTerran> C-Keen, but "longest prefix that appears again later" can be reduced to "longest common prefix of these two strings" via use of tails again
09:09:49 <quix_> http://hpaste.org/12092  I want to write this function more concisely with a fold-like function.  I could set up tuples which accumulate what I need, but there must be a cleaner way.
09:11:07 <geezusfreeek> abbe: probably not, but i hardly ever use braces so i can't be sure
09:11:23 <gwern> gah
09:11:30 <Peaker> abbe: why use braces?
09:11:32 <geezusfreeek> abbe: in this case using "when" is probably cleaner anyway
09:11:34 <gwern> 'verifyAndTurnIntoMap xs = $( uniqueListQ $ map fst xs )' seems to be impossible
09:11:45 <abbe> geezusfreeek: yes, when sounds LISPy ;)
09:12:05 <abbe> Peaker: haskell indentation is confusing
09:12:35 <Peaker> abbe: its very very free, you can do almost anything you like..
09:12:40 <Peaker> abbe: so choose a non-confusing layout
09:12:47 <mmorrow> gwern: as written, that is. but if you're only ever calling that on statically-known values xs, then you can do it with a slight modification
09:13:12 <abbe> Peaker: is there a simple guide to haskell indentation, you're aware of ?
09:13:31 <mmorrow> doing exactly that isn't even possible with dependent types, since there's no way of being able to verify at typechecking time that xs is actually unique
09:13:49 <mmorrow> (assuming you're erasing types)
09:14:01 <Peaker> abbe: nope, I generally align the next line to the expression its continuing, or 2 spaces inner than the "do" its within
09:14:26 <mmorrow> even then, if it isn't unique you'd have to signal an error, which is the same as using Maybe, which is the same as writing a haskell function to do that
09:15:47 <mikv> Suppose i have
09:15:54 <mikv> list like [('a',"00"),('b',"01"),('c',"10"),('d',"11")]
09:16:00 <mmorrow> i've recently realized that template-haskell gives you what dependent types give you, albeit by means of computing /on/ the language /in/ the language, rather than computing /in/ in the language
09:16:10 <abbe> Peaker: okay
09:16:15 <mikv> what is ithe best way to find element with a specificfirst element?
09:16:46 <Asztal> > lookup 'a' [('a',"00"),('b',"01"),('c',"10"),('d',"11")]
09:16:47 <lambdabot>   Just "00"
09:16:54 <mmorrow> (bear in mind that my knowledge of dependent types is limited, so i don't know if the first part of that statement is correct)
09:17:02 <luite> @src lookup
09:17:03 <lambdabot> lookup _key []          =  Nothing
09:17:03 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
09:17:03 <lambdabot>                         | otherwise = lookup key xys
09:17:27 <mikv> Asztal, thanks. I discovered it with hoogle few secs ago
09:17:44 <mikv> > lookup 'f' [('a',"00"),('b',"01"),('c',"10"),('d',"11")]
09:17:45 <lambdabot>   Nothing
09:17:48 <mikv> Cool
09:18:19 <mmorrow> @type (flip lookup)
09:18:20 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> Maybe b
09:18:31 <geezusfreeek> abbe: my general rule of thumb is to only really worry about alignment inside do-blocks, in which case i make sure that the only lines aligned with the do block are supposed to be (would be preceded by semicolons when using brace notation), otherwise it should be further indented
09:18:38 <mikv> @src ($)
09:18:39 <lambdabot> f $ x = f x
09:18:43 <Deewiant> ($) = id
09:18:44 <mmorrow> @type \default -> maybe default id . flip lookup
09:18:45 <lambdabot> parse error on input `default'
09:18:51 <Deewiant> O_o
09:18:53 <mmorrow> @type \dflt -> maybe dflt id . flip lookup
09:18:54 <lambdabot>     Couldn't match expected type `Maybe a'
09:18:54 <lambdabot>            against inferred type `a1 -> Maybe b'
09:18:54 <lambdabot>     Probable cause: `flip' is applied to too few arguments
09:18:58 <Deewiant> what's 'default'
09:19:03 <gwern> oh good grief
09:19:10 <gwern> this stage restriction of TH is impossible
09:19:12 <mmorrow> @type \dflt xs x -> maybe dflt id (lookup x xs)
09:19:12 <lambdabot> forall a a1. (Eq a1) => a -> [(a1, a)] -> a1 -> a
09:19:18 <Deewiant> @ty \dflt -> (maybe dflt id .) . flip lookup
09:19:19 <lambdabot> forall a b. (Eq a) => b -> [(a, b)] -> a -> b
09:19:27 <gwern> I can't use *anything* defined in xmonad.hs inside a TH $()?
09:19:35 <abbe> geezusfreeek: okay, thanks.
09:20:05 <mmorrow> @type (maybe [] id . flip lookup [(0,[1,2]),(1,[1]),(2,[0,1])])
09:20:06 <lambdabot> forall a a1. (Num a, Num a1) => a1 -> [a]
09:20:14 <Peaker> @hoogle (Bool, a) -> Maybe a
09:20:15 <lambdabot> Prelude snd :: (a, b) -> b
09:20:15 <lambdabot> Data.Tuple snd :: (a, b) -> b
09:20:15 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
09:21:16 <mmorrow> @type \x k -> maybe [] k (lookup x [(0,[1,2]),(1,[1]),(2,[0,1])])
09:21:17 <lambdabot> forall a a1 t. (Num t, Num a1) => a1 -> ([t] -> [a]) -> [a]
09:21:30 <mmorrow> @type \x k -> maybe (k []) k (lookup x [(0,[1,2]),(1,[1]),(2,[0,1])])
09:21:31 <lambdabot> forall a b a1. (Num a, Num a1) => a1 -> ([a] -> b) -> b
09:21:43 <Peaker> lookup should be a foldr :)
09:21:59 <mmorrow> foldr traverses the entire list
09:22:47 <Peaker> its lazy, what if you return something that doesn't use its right-hand arg?
09:22:59 <Peaker> > foldr (const 1) 1 [1..]
09:23:00 <lambdabot>       No instance for (Num (b -> b))
09:23:00 <lambdabot>        arising from the literal `1' at <...
09:23:10 <Peaker> @type foldr
09:23:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:23:24 <Deewiant> > foldr const 1 [1..]
09:23:25 <lambdabot>   1
09:23:29 <mmorrow> , it'll work with const, but not for lookup
09:23:31 <lunabot>  luna: Not in scope: `it'll'
09:23:32 <mmorrow> it'll work with const, but not for lookup
09:23:34 <mmorrow> heh
09:23:35 <Deewiant> > foldr1 const [1..]
09:23:36 <lambdabot>   1
09:23:50 <Peaker> mmorrow: why?
09:24:04 <mmorrow> i'm not so sure actually...
09:24:06 <Peaker> mmorrow: if it matches, it doesn't "look" at the rhs, so it won't continue the foldr
09:24:15 <gwern> arggh... I need Lift instances for GHC.Word.Word64, Foreign.C.Types.CUInt, and (X ()))???
09:24:17 <mmorrow> because it works to short-circuit and and or
09:24:31 <EvilTerran> ?src lookup
09:24:31 <mmorrow> which is essentiall looking up False and True
09:24:31 <lambdabot> lookup _key []          =  Nothing
09:24:31 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
09:24:32 <lambdabot>                         | otherwise = lookup key xys
09:24:50 <mmorrow> but it doesn't work for (*) when you come across a 0
09:24:56 <mmorrow> and you try to bail
09:25:34 <Peaker> > let lookup key = mconcat . foldr (\((k,v):rest) -> if k==key then Just v else rest) Nothing in lookup 1 [(1,2),(3,4)]
09:25:35 <lambdabot>   Couldn't match expected type `b -> b'
09:25:45 <mmorrow> yeah, it won't work
09:25:54 <Peaker> mmorrow: well, (*) could be made lazy for the 0 case
09:26:05 <Peaker> (lazy on its left-hand arg)
09:26:05 <mmorrow> it can't
09:26:10 <Peaker> why?
09:26:13 <mmorrow> it'll blow the stack
09:26:24 <Peaker> why?
09:26:35 <EvilTerran> product could be made lazy
09:26:46 <mmorrow> > foldr (*) 1 [1..100000]
09:26:48 <EvilTerran> but also strict enough to not blow the stack. fnord.
09:27:01 <lambdabot>   thread killed
09:27:02 <mmorrow> > foldl' (*) 1 [1..100000]
09:27:16 <mmorrow> > foldr (*) 1 [1..10000]
09:27:16 <lambdabot>   282422940796034787429342157802453551847749492609122485057891808654297795090...
09:27:18 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
09:27:20 <Deewiant> 100000! is pretty big
09:27:22 <mmorrow> > foldl' (*) 1 [1..100000]
09:27:24 <MyCatVerbs> EvilTerran: strict in its left argument always, strict in its right hand iff the left is not zero?
09:27:30 <mmorrow> gah, history fail
09:27:32 <gwern> mmorrow: I appreciate your help with TH, but I think I'm going to mark this down as a failed experiment. between the needed lift instances and the import restriction, I don't think the TH approach can be made useful for xmonad.hss
09:27:35 <lambdabot>   282422940796034787429342157802453551847749492609122485057891808654297795090...
09:27:53 <EvilTerran> MyCatVerbs, exactly, but still keeping the running total as a strict accumulating parameter
09:27:53 <MyCatVerbs> EvilTerran: I have a feeling the strictness analyser would want to murder you in your sleep for springing that kind of trap on it. :)
09:28:02 <mmorrow> neither foldl, foldl', nor foldr are acceptable for product i've found out
09:28:13 <Peaker> mmorrow: strictness analysis ftw :-)   also, there could be a *!
09:28:17 <Deewiant> 100000! has a sweet 456573 digits
09:28:18 <mmorrow> you need a paramorphism instead of a catamorphism
09:28:34 <Peaker> Deewiant: can you compute, in your head, how many 0's it ends with?
09:28:49 <Deewiant> In my head? Not quickly :-)
09:29:13 <Peaker> Deewiant: what about 100! :)
09:29:29 <Asztal> 12?
09:29:32 <Peaker> nope
09:29:36 <EvilTerran> 20?
09:29:39 <Deewiant> 24
09:29:40 <Deewiant> ?
09:29:41 <darrint> Anyone know where to find/make the gtk2hs file extract-docs.xsl?
09:29:42 <Peaker> yep, 24
09:29:50 <Asztal> oh, 5 and 2?
09:29:51 <Peaker> Deewiant: how'd you decide that?
09:29:56 * EvilTerran tries to work out where his reasoning error was
09:30:08 <EvilTerran> in "every multiple of 5 should add one zero"
09:30:22 <EvilTerran> ... ah, powers of 5 add more than one zero
09:30:26 <mmorrow> @let foldC _ !a  [] = a; foldC f !a (b:bs) = f a b bs (\a bs -> foldC f a bs)
09:30:26 <lambdabot>   Parse error in pattern: HsVar (UnQual (HsIdent "foldC"))
09:30:27 <Peaker> EvilTerran: yep :)
09:30:29 <mmorrow> @let foldC _ a  [] = a; foldC f !a (b:bs) = f a b bs (\a bs -> foldC f a bs)
09:30:30 <lambdabot>   Parse error in pattern: HsVar (UnQual (HsIdent "foldC"))
09:30:32 <EvilTerran> drat
09:30:36 <mmorrow> @let foldC _ a  [] = a; foldC f a (b:bs) = f a b bs (\a bs -> foldC f a bs)
09:30:37 <lambdabot>  Defined.
09:30:47 <Peaker> EvilTerran: you did so much better than some Berkeley/Stanford PHD's heh :)
09:30:53 <mmorrow> @let product' = foldC (\a b bs k -> if b==0 then 0 else k (a*b) bs) 1
09:30:54 <lambdabot>  Defined.
09:31:19 <mmorrow> > product' ([1..100]++[0]++[1..100000000000])
09:31:20 <lambdabot>   0
09:31:26 <Peaker> my friend used this as an interview question, and some award winning students from Berkeley and Stanford failed to get to the 20 answer..
09:31:38 <Peaker> (the half-right answer most people go through)
09:32:05 <Peaker> so he has developed a big contempt for universities, and their degrees
09:32:16 <EvilTerran> i think it may've come up in a maths olympiad or something
09:32:36 <Peaker> though most people take minutes, not 3 seconds like #haskell :P
09:32:43 <Asztal> I guess I kind of cheated by counting multiples of 10 and adding the 2 from 100
09:33:00 <Asztal> but the stealthy 5*2s escaped me
09:33:01 <mmorrow> @type let lookup' = foldC (\a (b,x) bs k -> if a==b then Just x else case bs of [] -> Nothing; _ -> k a bs) in lookup'
09:33:02 <lambdabot> forall t. (Eq t) => Maybe t -> [(Maybe t, t)] -> Maybe t
09:33:09 <Peaker> Asztal: the 2's are not relevant, because the "bottleneck" are the 5's, there are less of them
09:33:23 <Peaker> Asztal: 5*2*5*2*5*2  *2*2*2*2 (the last 2's don't do anything..)
09:33:24 <Deewiant> I just counted multiples of 5 and doubled for multiples of 25
09:33:26 <mikv> Right now i use a lot of brackets in my function
09:33:37 <Peaker> Deewiant: that was the quickest I've ever seen anyone answer that question, congrats :)
09:33:38 <mmorrow> oh
09:33:47 <Deewiant> I wasn't at all sure if I was right, though
09:33:49 <mikv> Can you point me to the doc with proper explanation of ($) and (.)
09:33:51 <Deewiant> It was more of an intuition
09:33:53 <mmorrow> > list
09:33:53 <lambdabot>       Overlapping instances for Show
09:33:53 <lambdabot>                                  (t -> (...
09:34:03 <mikv> i saw that this function are often used to remove brackets
09:34:12 <Peaker> mikv: ($) is, (.) is used for other things
09:34:27 <Deewiant> Peaker: so what about 100000! then ;-)
09:34:31 <Peaker> Deewiant: that's hard :)
09:34:58 <Peaker> Deewiant: you need to find log5(100000), count how many times each of the powers of 5 appears in there, arg :)
09:35:05 <mmorrow> @type let foldy cont f s = list (cont s) (\x xs -> f s x xs (\s xs -> foldy cont f s xs)) in foldy
09:35:06 <lambdabot> forall t t1 t11. (t -> t1) -> (t -> t11 -> [t11] -> (t -> [t11] -> t1) -> t1) -> t -> [t11] -> t1
09:35:15 <mmorrow> @let foldy cont f s = list (cont s) (\x xs -> f s x xs (\s xs -> foldy cont f s xs))
09:35:16 <lambdabot>  Defined.
09:35:22 <mikv> Peaker, huh :-) I was my guess
09:35:42 <Peaker> > length . takeWhile (=='0') . reverse . show . foldr (*) 1 $ 100
09:35:43 <mikv> Peaker, are there good docs on this topic in Haskell community
09:35:44 <mikv> ?
09:35:44 <lambdabot>       No instance for (Num [a])
09:35:44 <lambdabot>        arising from the literal `100' at <int...
09:35:51 <Peaker> > foldr (*) 1 $ 100
09:35:52 <lambdabot>       No instance for (Num [a])
09:35:52 <lambdabot>        arising from the literal `100' at <int...
09:35:59 <Peaker> > foldr (*) 1 $ [1..100]
09:36:00 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
09:36:00 <Deewiant> Peaker: 24999, if I got it right with Mathematica
09:36:10 <Peaker> > length . takeWhile (=='0') . reverse . show . foldr (*) 1 $ [1..100]
09:36:11 <lambdabot>   24
09:36:14 <Deewiant> (just copy-pasting from the answer and counting)
09:36:18 <Peaker> > length . takeWhile (=='0') . reverse . show . foldr (*) 1 $ [1..100000]
09:36:21 <mikv> > let testdot = (+) . (*2)
09:36:22 <Deewiant> err
09:36:22 <lambdabot>   <no location info>: parse error on input `;'
09:36:24 <Deewiant> Peaker: don't use foldr
09:36:27 <Deewiant> Peaker: use foldl'
09:36:33 <Peaker> > length . takeWhile (=='0') . reverse . show . foldl' (*) 1 $ [1..100000]
09:36:33 <lambdabot>   thread killed
09:36:48 <lambdabot>   24999
09:36:51 <Deewiant> yay
09:36:58 <mmorrow> @type let lookup' = foldy (const Nothing) (\a (b,x) bs k -> if a==b then Just x else k a bs) in lookup'
09:36:59 <Peaker> > length . takeWhile (=='0') . reverse . show . foldl' (*) 1 $ [1..10000]
09:37:00 <lambdabot> forall t2 a. (Eq t2) => t2 -> [(t2, a)] -> Maybe a
09:37:01 <Deewiant> well, not like I expected Mathematica to be wrong :-P
09:37:02 <lambdabot>   2499
09:37:05 <Peaker> hehe, nice pattern!
09:37:06 <mmorrow> @let lookup' = foldy (const Nothing) (\a (b,x) bs k -> if a==b then Just x else k a bs) in lookup'
09:37:06 <lambdabot>   Parse error
09:37:08 <Deewiant> O_o
09:37:11 <mmorrow> @let lookup' = foldy (const Nothing) (\a (b,x) bs k -> if a==b then Just x else k a bs)
09:37:12 <lambdabot>  <local>:7:53:
09:37:12 <lambdabot>      Ambiguous type variable `t' in the constraint:
09:37:12 <lambdabot>        `Eq...
09:37:16 <mmorrow> grr
09:37:29 <mmorrow> @let lookup' x xs = foldy (const Nothing) (\a (b,x) bs k -> if a==b then Just x else k a bs) x xs
09:37:29 <lambdabot>  Defined.
09:38:02 <mmorrow> > lookup 21 (zip [0..] ['a'..'z'])
09:38:03 <lambdabot>   Just 'v'
09:38:05 <mmorrow> > lookup' 21 (zip [0..] ['a'..'z'])
09:38:06 <lambdabot>   Just 'v'
09:38:17 <Peaker> > let zeroCount = length . takeWhile (=='0') . reverse . show . foldl' (*) 1 . enumFromTo 1 in zeroCount 100
09:38:22 <Deewiant> @oeis 2,24,249,2499,24999
09:38:26 <lambdabot>   24
09:38:28 <lambdabot>  Sequence not found.
09:38:31 <Deewiant> meh
09:38:31 <mmorrow> Peaker: that "foldy" function is great: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=413
09:38:41 <Deewiant> ackkk
09:38:46 <mmorrow> foldl f = foldy id (\z x xs k -> k (f z x) xs)
09:38:47 <Deewiant> GHC is using 600 megs of memory on that :-P
09:38:49 <Peaker> > let zeroCount = length . takeWhile (=='0') . reverse . show . foldl' (*) 1 . enumFromTo 1 in take 6 $ map zeroCount (iterate (*10) 1)
09:38:57 <lambdabot>   [0,2,24,249,2499,24999]
09:38:59 <mmorrow> foldr f = foldy id (\z x xs k -> f x (k z xs))
09:39:06 <Peaker> nice ;)
09:39:25 <mmorrow> heh
09:39:59 <Deewiant> argh, now everything is swapping
09:40:03 <Deewiant> I shouldn't have run that in GHCi :-P
09:40:06 <EvilTerran> > sum . takeWhile (>0) . map (length . takeWhile (<= 100000)) $ [[x^n | x <- [5,10..]] | n <- [1..]]
09:40:08 <lambdabot>   20079
09:42:08 <mikv> What does ($) do?
09:42:14 <mikv> I saw its defintion
09:42:18 <mmorrow> @let bfs :: [Forest a] -> [[a]] = foldy (\(as,fs) -> reverse as : if null fs then [] else bfs fs) (\(as,fs) (Node a xs) ys go -> go (a:as,xs++fs) ys) ([],[])
09:42:18 <lambdabot>   Parse error
09:42:23 <Deewiant> > (+1) $ (*2) $ 5
09:42:25 <lambdabot>   11
09:42:25 <mmorrow> @let bfs :: [Forest a] -> [[a]]; bfs = foldy (\(as,fs) -> reverse as : if null fs then [] else bfs fs) (\(as,fs) (Node a xs) ys go -> go (a:as,xs++fs) ys) ([],[])
09:42:26 <lambdabot>  Couldn't match expected type `Forest a'
09:42:31 <mikv> @src ($)
09:42:31 <lambdabot> f $ x = f x
09:42:34 <mmorrow> @let bfs :: Forest a -> [[a]]; bfs = foldy (\(as,fs) -> reverse as : if null fs then [] else bfs fs) (\(as,fs) (Node a xs) ys go -> go (a:as,xs++fs) ys) ([],[])
09:42:34 <lambdabot>  Defined.
09:42:59 <Deewiant> mikv: it's just function application, with a primary use in avoiding parentheses: f $ g x y instead of f (g x y)
09:43:07 <EvilTerran> mikv, it "does" nothing, but it's really low fixity, so it can be used to group things in some circumstances instead of having to use (...)s
09:43:29 <Deewiant> Some people would prefer f . g x $ y in that example.
09:43:41 <mmorrow> > bfs [Node 0 [Node 1 [Node 2 [], Node 3 []], Node 4 []], Node 5 [Node 6 [Node 7 [], Node 8 []], Node 9 []]]
09:43:42 <lambdabot>   [[0,5],[6,9,1,4],[2,3,7,8]]
09:44:46 <mikv> ok. (+1) ((*2) 5) we can write (+1) $ (*2) $ 5
09:44:49 <Deewiant> > map levels [Node 0 [Node 1 [Node 2 [], Node 3 []], Node 4 []], Node 5 [Node 6 [Node 7 [], Node 8 []], Node 9 []]]
09:44:50 <lambdabot>   [[[0],[1,4],[2,3]],[[5],[6,9],[7,8]]]
09:44:54 <mikv> but if we will skip brackets
09:45:08 <mmorrow> levels can't handle to Forests ;)
09:45:27 <mikv> (+1) (*2) 5, Haskell will think about it as (((+1) (*2)) 5)
09:45:29 <mikv> Am i right?
09:45:39 <vincenz_> yes
09:45:44 <vincenz_> Which is illtyped
09:45:44 <Deewiant> mmorrow: But if we join the elements together somehow we can define it more easily with levels, I think
09:45:55 <Deewiant> ?ty (+1) (*2)
09:45:56 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> a
09:46:03 <Deewiant> Perfectly well typed ;-)
09:46:14 <vincenz> Do you know a valid definition of numbers represented as (a->a) ?
09:46:26 <mmorrow> > foldr (zipWith (++)) (repeat []) . fmap levels $ [Node 0 [Node 1 [Node 2 [], Node 3 []], Node 4 []], Node 5 [Node 6 [Node 7 [], Node 8 []], Node 9 []]]
09:46:27 <lambdabot>   [[0,5],[1,4,6,9],[2,3,7,8]]
09:46:36 <Deewiant> Nice :-)
09:46:40 <vincenz> And notices how the 2 is of type 'a' while the 1 is of type 'a -> a' in that equation
09:46:41 <mmorrow> but then that'll fail if the trees aren't the same shape
09:46:45 <baaba> church encoding? :P
09:46:57 <mmorrow> since the zip will chop off some stuff
09:47:46 <Deewiant> vincenz: Sure, f + g = \x -> f x + g x etc. It can be done in such a way that it even makes a degree of sense. :-)
09:47:59 <mmorrow> the actual code in Data.Tree for levels actually artificially limits it to a tree
09:48:03 <vincenz> Deewiant: just know that the 1 and 2 in that expression are of different types
09:48:14 <mmorrow> levels t = map (map rootLabel) $
09:48:14 <mmorrow> 		takeWhile (not . null) $
09:48:14 <mmorrow> 		iterate (concatMap subForest) [t]
09:48:25 <Deewiant> vincenz: yeah, "fromIntegral" is a bit tricky. ;-)
09:48:55 <dolio> fromIntegral = const . fromIntegral
09:48:55 <vincenz> :t (+1) (*2) (+3) (*4)
09:48:56 <lambdabot> forall a. (Num a, Num (a -> a), Num ((a -> a) -> a -> a), Num (((a -> a) -> a -> a) -> (a -> a) -> a -> a)) => a -> a
09:49:10 <mmorrow> @type let levels' = (fmap . fmap) rootLabel . takeWhile (not . null) . iterate (subForest =<<) in levels'
09:49:11 <lambdabot> forall a. [Tree a] -> [[a]]
09:49:19 <mmorrow> @let levels' = (fmap . fmap) rootLabel . takeWhile (not . null) . iterate (subForest =<<)
09:49:20 <lambdabot>  Defined.
09:49:30 <mmorrow> > levels' [Node 0 [Node 1 [Node 2 [], Node 3 []], Node 4 []], Node 5 [Node 6 [Node 7 [], Node 8 []], Node 9 []]]
09:49:31 <lambdabot>   [[0,5],[1,4,6,9],[2,3,7,8]]
09:49:36 <mmorrow> > bfs [Node 0 [Node 1 [Node 2 [], Node 3 []], Node 4 []], Node 5 [Node 6 [Node 7 [], Node 8 []], Node 9 []]]
09:49:37 <lambdabot>   [[0,5],[6,9,1,4],[2,3,7,8]]
09:50:37 <mmorrow> (that code also relies on the rootLabel and subForest accessors)
09:50:58 <vincenz> :t (+1) (*2) (+3) (*4) 1 2 3 4
09:50:59 <lambdabot> forall t t1 t2 t3. (Num t3, Num t2, Num t1, Num (t1 -> t2 -> t3 -> t), Num ((t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t), Num (((t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t) -> (t1 -> t2 -> t3 -> t)
09:50:59 <lambdabot>  -> t1 -> t2 -> t3 -> t), Num ((((t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t) -> (t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t) -> ((t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t) -> (t1 -> t2 -> t3 ->
09:50:59 <lambdabot>  t) -> t1 -> t2 -> t3 -> t)) => t
09:51:03 <mmorrow> heh
09:51:05 <vincenz> > (+1) (*2) (+3) (*4) 1 2 3 4
09:51:06 <lambdabot>       No instance for (Num
09:51:06 <lambdabot>                         ((((t -> t1 -> t2 -> a) ->...
09:52:14 <mmorrow> @djinn (Num t3, Num t2, Num t1, Num (t1 -> t2 -> t3 -> t), Num ((t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t), Num (((t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t) -> (t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t), Num ((((t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t) -> (t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t) -> ((t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t) -> (t1 -> t2 -> t3 ->t) -> t1 -> t2 -> t3 -> t)) => t
09:52:15 <lambdabot> Error: Class not found: Num
09:53:02 <mmorrow> > zipWith ($) [(+1),(*2),(+3),(*4)] [1,2,3,4]
09:53:03 <lambdabot>   [2,4,6,16]
10:00:28 <mmorrow> dolio: hey, i just realized (one of the?) methods to get "dependent typed" with TH after translating the cayenne printf function, but i'm not sure what an example of a function you could write in a dependently-typed language that you could NOT write with template-haskell. can you think of one?
10:00:32 <mmorrow> here's the printf code:
10:00:49 <mmorrow> http://hpaste.org/12081
10:01:06 <mmorrow> *"dependent typeS"
10:01:44 <mmorrow> dolio: oh yeah, adding Data.Sequence now...
10:03:26 <mmorrow> so the "method" is the build up a type sig for an expression based on the input val, then return a
10:03:30 <mmorrow> , src 'SigE
10:03:35 <lunabot>  luna: Ambiguous occurrence `Exp'
10:03:40 <mmorrow> (or some variation thereof)
10:03:41 <mmorrow> wuh
10:05:06 <dmwit> mmorrow: I believe there's a beautiful theorem about dependent types that says that if you can type the program, then erasing the types to non-dependency leaves you with a well typed program in a non-dependently-typed language.
10:05:11 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
10:05:36 <dmwit> It's a bit more specific about the pairings between which languages this works, but if you're talking about a type-erasure transformation, I wouldn't be at all surprised that it works.
10:05:39 <dmwit> ?messages
10:05:40 <lambdabot> ivanm said 5h 49m 25s ago: well, seeing as how I rm'd my old yeganesh cache cos it had stuff mixed up in there from an old install... :s
10:06:12 <dmwit> bummer
10:06:47 <vixey> dmwit, it's not terribly beautiful but yeah, evaluation is just the same an untyped lambda calculus
10:06:54 <mmorrow> dmwit: totally (i don't know the theorem, but re: type erasure). this makes me think that TH gives you dependent types
10:07:05 <vixey> TH doesn't give you dependent types
10:07:20 <dmwit> mmorrow: Well, as always, the tricky bit is type-checking in the source language, not transforming to the target language. ;-)
10:07:21 <mmorrow> ok, what's your counterexample?
10:08:02 <mmorrow> (i'm trying to figure out what one is, if one exists)
10:08:44 <mmorrow> what's a function you cannot write with template-haskell + haskell that you /can/ write in a dependently typed lang?
10:08:52 <vixey> I think you could pick pretty much any dependently typed program - proof that 'add' is symmetric for example
10:09:06 <lilac> dependent types don't allow you to write programs, they prevent you from writing programs :)
10:09:17 <mmorrow> vixey: do you have a link for such a program so i can attempt a translation?
10:09:18 <vixey> lilac, where did you read that?
10:09:31 <dmwit> mmorrow: It's the other way, I think; there's functions you can write with TH that are forbidden by a dependently-typed language.
10:09:42 <mmorrow> dmwit: heh, nice.
10:09:45 <lilac> vixey: on my screen, just after i typed it
10:10:34 <dmwit> This is the whole point of type systems: prevent the creation of "bad" programs, for some definition of bad.
10:10:48 <dmwit> (re: lilac's claim)
10:10:54 <mmorrow> lilac: i agree to the extent you can write functions whose type depends on their input value at all
10:11:55 <mmorrow> but without that ability, like in haskell, that seems to be a moot point
10:12:22 <mmorrow> i need to read more about dependent types
10:12:44 <vixey> mmorrow, http://www.cs.nott.ac.uk/~nad/repos/lib/Data/Nat/Properties.agda
10:13:01 <mmorrow> vixey: sweet, game on :)
10:13:17 <vixey> only +-comm
10:14:14 <mmorrow> cool
10:14:56 <gwern> I just wish template haskell didnt' feel so halfbaked
10:15:07 <gwern> the module restriction is particularly otiose
10:15:38 * mmorrow suddenly realizes he has to learn agda so he can understand what this is even saying
10:16:15 <dmwit> ?wn otiose
10:16:16 <lambdabot> *** "otiose" wn "WordNet (r) 2.0"
10:16:16 <lambdabot> otiose
10:16:16 <lambdabot>      adj 1: serving no useful purpose; having no excuse for being;
10:16:16 <lambdabot>             "otiose lines in a play"; "advice is wasted words"
10:16:16 <lambdabot>             [syn: {pointless}, {superfluous}, {wasted}]
10:16:19 <lambdabot> [9 @more lines]
10:17:05 <adu> mmorrow: have you been in here all night?!?
10:17:09 <mmorrow> vixey: is this a plain identifier "+-identity"? or does the "+-" prefix mean something
10:17:13 <gwern> one day I hope to render English an impenetrable barrier to communication, instead of having to fall back on category theory
10:17:26 <mmorrow> adu: a bit here, a bit there
10:17:42 <idnar> gwern: planning to join forces with Calvin?
10:18:09 * adu <3 deptypes
10:18:19 <dmwit> mmorrow: My guess is it's an identifier that proves that + is commutative.
10:18:23 <mmorrow> vixey: ok, n/m i see
10:18:25 <gwern> idnar: he is the master of us all
10:18:47 <edwardk> gwern: yeah the module restriction on TH is incredibly frustrating
10:18:57 <mmorrow> dmwit: i just realized the pattern is to prefix stuff with <sym>-something
10:19:12 <gwern> edwardk: when I realized what the module restriction really meant, I gave up on using TH with xmonad
10:19:19 <edwardk> fair enough
10:19:35 <adu> mmorrow: my problem is I  downloaded agda, but I have no idea what to do with it...
10:19:42 <idnar> damn, I can't find a link to that strip
10:19:45 <edwardk> i toughed it out through 3 stages to do type level 16s complement hexadecimal then i stopped using TH for pretty much anything ;)
10:20:01 <gwern> ouch
10:20:10 <mmorrow> gwern, edwardk: yeah, it is inconvenient, but thankfully getting around it is only a matter of figuring out how rather than an impossibility
10:20:12 <edwardk> because i realized there was no way the resulting code could be maintainable
10:20:14 <gwern> maybe ghc 8 will fix the module thing
10:20:24 <edwardk> doubtful
10:20:31 <adu> gwern: what do you mean "impenetrable barrier"?
10:20:31 <edwardk> i don't think TH is on anyone's radar
10:20:40 <gwern> adu: insuperable
10:20:46 <adu> gwern: do you mean it sucks?
10:20:57 <mmorrow> edwark: i think it is
10:20:59 <vixey> mmorrow, I'll make a simpler example
10:21:03 <gwern> mmorrow: no, see, for xmonad.hs purposes it has to be user-friendly. it can't require the user to split out the keymap to another file or pass in each and every local definition as a parameter
10:21:19 <mmorrow> vixey: that one's ok, but if you've got a simpler one...
10:21:37 <mmorrow> vixey: the pain is that i'll have to find "byDef", etc...
10:21:56 <gwern> adu: no - well, yes, it does suck. it's pretty hard to understand, it's made even more hard to understand because of no-ghci, real errors are obscured by fiddling with putting stuff in modules...
10:22:03 <gwern> etc etc
10:22:11 <mmorrow> gwern: well, you'd have to come up with a way around that :)
10:22:26 <edwardk> gwern: yeah i can see that
10:22:46 <edwardk> i admit i stick to a fairly vanilla xmonad profile myself
10:22:50 <mmorrow> vixey: be back in a few
10:23:22 <adu> gwern: but I believe that category theory is an impenetrable barrier to communication... so I'm still lost as to what you meant... how does that have to do with ghci?
10:23:24 <gwern> edwardk: bascially, because of the common 'modMask = modmask' idiom, no one could use the TH approach
10:23:38 <gwern> adu: you can't load a TH-using module into ghci
10:23:50 <gwern> how can you check that you're using it correctly?
10:23:54 <adu> gwern: what does that have to do with English?
10:24:50 <gwern> adu: that was a different conversation; it was a response to dmwit having to look up the definition of 'otiose'
10:25:18 <gwern> combined with an allusion to calvin & hobbes, with a parthian shot at the impenetrability of many discussions of category theory
10:25:27 <Deewiant> ?wn parthian
10:25:29 <lambdabot> *** "Parthian" wn "WordNet (r) 2.0"
10:25:29 <lambdabot> Parthian
10:25:29 <lambdabot>      adj 1: pertaining to Parthia or its people or language or culture;
10:25:29 <lambdabot>             "Parthian archeology"
10:25:29 <lambdabot>      2: delivered at the moment of parting as if in flight or
10:25:30 <lambdabot> [4 @more lines]
10:25:38 <gwern> -_-
10:25:40 <Deewiant> ;-)
10:26:06 <edwardk> bah, that was dmwit just being otiose ;)
10:26:18 <dmwit> hey!
10:26:23 <dmwit> I resemble that remark.
10:26:23 <gwern> obtuse, more belike
10:26:37 <edwardk> eschew obfuscation
10:27:08 <Deewiant> eschew obfuscation, espouse elucidation
10:27:17 <gwern> bolster brevity?
10:27:20 <edwardk> more like gwern being abstruse ;)
10:27:23 <gwern> consort with concision?
10:27:33 <dmwit> mmmm, eschews are my favorite nut
10:27:35 <gwern> (write with wittiness)
10:28:48 <dmwit> hahaha
10:28:57 <dmwit> http://img99.imageshack.us/img99/9887/1226847579208wz2.jpg
10:29:07 <dmwit> This will not make a lot of sense to many of you.
10:30:09 <skorpan> lol
10:30:13 <EvilTerran> hehe
10:30:16 <skorpan> made a lot of sense to me
10:31:03 <skorpan> for those who don't get it, this is the "original" one: http://pici.se/pictures/zOZYDANGP.jpg
10:31:18 <Deewiant> In promulgating your esoteric cogitations and articulating your superficial sentimentalities or amicable philosophical observations, beware of platitudinous ponderosities.
10:31:37 <BONUS> ahahaha
10:31:42 <dmwit> skorpan: Oh $DEITY, that makes me laugh every single time.
10:31:52 <dmwit> I try to hold it in, but it just bursts out.
10:32:06 <edwardk> dmwit: null pointer exception
10:32:29 <mmorrow> vixey: ok
10:32:34 <skorpan> i think $DEITY is an undecidable problem... *agnostic*
10:32:42 <gwern> Deewiant: a lamentable lucubration for soi-disant pansophists like me
10:32:56 <dmwit> if [ -z $ATHEIST ]; then; DEITY=man; fi
10:33:08 <edwardk> skorpan: then i suppose it is best to not try to evaluate that thunk
10:33:20 <vixey> mmorrow, http://rafb.net/p/43Q9W991.html
10:33:21 <lambdabot> Title: Nopaste - No description
10:33:26 <skorpan> exactly what is a thunk?
10:33:38 <skorpan> i've seen it in lambda calculus sometimes, but never really understood it.
10:33:41 <Saizan_> gwern: what do you mean by "you cannot load a TH using module in ghci"?
10:34:05 <vixey> lilac, is there something specific you wanted to program but couldn't ?
10:34:15 <edwardk> skorpan: in general, the idea is that its just a lazy calculation that when you ask it to, will generate an answer or return bottom.
10:34:46 <skorpan> kind of like a Maybe?
10:34:47 <lilac> vixey: how about a program which crashes by reading off the end of an array where indexes are checked via dependent typing?
10:34:49 <edwardk> skorpan: unfortunately there are about a good 3-4 other definitions for a thunk or thunking that have absolutely nothing to do with that idea, but the definition above fits with the notion used in Haskell.
10:34:54 <skorpan> with Nothing as "bottom"
10:35:03 <vixey> lilac, I don't understand
10:35:07 <dmwit> with non-termination as bottom
10:35:07 <edwardk> skorpan: well, you don't have the ability to tell if you got a bottom.
10:35:16 <SethTisue> my usual definition of thunk is a function with no arguments
10:35:19 <SethTisue> (lambda () ...)
10:35:19 <skorpan> strange...
10:35:27 <edwardk> skorpan: pretty much anything you write in haskell winds up as a thunk.
10:35:32 <SethTisue> but in Haskell there's no such thing
10:35:33 <skorpan> SethTisue: that makes a lot of sense at the moment
10:35:47 <edwardk> SethTisue: yeah that is the way you have to express it in a strict language anyway.
10:35:47 <lilac> vixey: dependent typing exists, amongst other reasons, to statically prove certain behaviours can't occur. it does this by preventing certain classes of programs from being written.
10:35:53 <skorpan> but isn't it rather: \_ -> x ?
10:35:55 <lilac> or at least from being well-typed
10:36:09 <edwardk> skorpan: thunk about the last list: foo = [1..]    -- obviously you didn't evaluate the entire list by giving it a name
10:36:12 <dmwit> skorpan: Sort of, but with no arguments. ;-)
10:36:24 <skorpan> dmwit: that makes no sense to me
10:36:28 <vixey> oh so you were just joking?
10:36:31 <edwardk> skorpan: so its a thunk, that when asked evaluates out to 1:[2..]
10:36:36 <edwardk> where [2..] is another thunk
10:36:36 <SethTisue> \_ -> x is a function that takes an argument but ignores it, right?
10:36:44 <skorpan> SethTisue: yes
10:36:54 <edwardk> (technically the 1 there is also a thunk until evaluated, but you get the general idea
10:36:56 <dmwit> skorpan: Suppose I write: "primes = [infinite list of primes]"; how many arguments does the "primes" function have?
10:36:57 <skorpan> it's actually "const x" i think
10:37:07 <skorpan> dmwit: none, right...
10:37:25 <SethTisue> I wouldn't call primes a function at all
10:37:32 <SethTisue> any more than x is a function when if I write let x = 3
10:37:39 <dmwit> skorpan: Right; but it hasn't yet calculated the whole list of primes.  So it's a "function" with no arguments that returns a list of primes.
10:37:40 <lilac> vixey: not exactly. i meant, dependent types prevent you from writing certain classes of broken programs (and certain types of correct but hard-to-prove-correct programs).
10:37:49 <dmwit> ...but only when called, and not before =)
10:37:54 <edwardk> in haskell the extra () argument is superfluous. (it actually is less useful because () isn't really a unit, since it has 2 values () and bottom.)
10:37:56 <skorpan> strange stuff these are.
10:38:22 <edwardk> seth: thats why i didn't define a thunk as a function. ;)
10:38:37 <Deewiant> You can make "data Unit;" though
10:38:46 <EvilTerran> "newtype Foo = Foo Foo" <- single-valued type with no _|_s
10:39:06 <Philonous> Variable binding isn't the same as a zero-argument function, is it?
10:39:08 <edwardk> deewiant sure.
10:39:21 <EvilTerran> (i think)
10:39:30 <edwardk> Philonous: in a sufficiently lazy setting, sure it is
10:39:30 <Saizan_> EvilTerran: fix Foo == _|_, surely?
10:39:39 <EvilTerran> they're equivalent, yes
10:39:54 <EvilTerran> however, you can never cause an exception or non-termination by forcing a value of type Foo
10:40:12 <Saizan_> what happens with seq?
10:40:12 <EvilTerran> as removing the constructor doesn't force anything
10:40:22 <edwardk> seq does bad things to the type system ;)
10:40:30 <edwardk> but its harmless w.r.t Foo
10:40:43 <edwardk> er
10:40:46 <Saizan_> so fix Foo `seq` () == ()?
10:40:59 * adu <3 foo
10:41:05 <SethTisue> edwardk: I understand. in a Haskell context I would never talk about thunks though, I would just say "it's evaluated lazily". talking about thunks might be a good way to explain lazy evaluation to someone who already knows about thunks from strict languages, though.
10:41:07 <vixey> what about slowFix f = f (slowFix f) ?
10:41:09 <edwardk> rather it'll evaluate to bottom, but thats because the only inhabitant of Foo is bottom, no?
10:41:23 <vixey> slowFix Foo `seq` () ?
10:41:39 <Deewiant> EvilTerran: What about "Foo undefined"?
10:41:44 <EvilTerran> > (\(Sum _) -> ()) undefined
10:41:46 <lambdabot>   ()
10:42:25 <EvilTerran> Deewiant, the thing is, in a newtype, pattern-matching the constructor doesn't actually cause any evaluation to happen
10:42:26 <Saizan_> @let newtype Foo = Foo Foo
10:42:26 <lambdabot>  Invalid declaration
10:42:31 <edwardk> seth: i guess its more of an implementation perspective. if you think about haskell as a thin veneer over a spineless tagless g-machine or something, then thinking of unevaluated quantities as the thunks they reside in memory as seems more natural.
10:42:37 <Deewiant> EvilTerran: ah, good point, newtype
10:42:48 <EvilTerran> so, seq aside at least, all values are the same but apparently non-_|_
10:43:07 <SethTisue> edwardk: agreed
10:43:22 <EvilTerran> > Sum undefined `seq` ()
10:43:23 <lambdabot>   * Exception: Prelude.undefined
10:43:52 <lilac> are recursive NewTypes legal?
10:44:21 <Saizan_> sure
10:44:27 <dmwit> lilac: TIAS
10:44:28 <mmorrow> gwern: what about this? http://hpaste.org/12097
10:44:33 <EvilTerran> ?src Mu
10:44:33 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
10:44:37 <EvilTerran> there's one
10:44:47 <mmorrow> that seems fairly easy to use/user friendly to me
10:45:07 <edwardk> lilac: ghc doesn't complain
10:45:17 <osfameron> is there a readable introduction to tying the knot?  (Where the haskellwiki example is not sufficiently readable)
10:45:25 <mmorrow> vixey: perfect, thanks
10:45:53 <lilac> neat, even 'newtype Foo = Foo Foo deriving Show' works :)
10:46:15 <EvilTerran> lilac, show undefined = cycle "Foo ("?
10:46:22 <lilac> pretty much
10:46:24 <EvilTerran> er, "show _ = ..."
10:47:30 <lilac> brilliant...  undefined :: Foo == fix Foo
10:47:30 <blarfo> what does TChan stand for?
10:47:44 <EvilTerran> ?hoogle TChan
10:47:45 <lambdabot> module Control.Concurrent.STM.TChan
10:47:45 <lambdabot> Control.Concurrent.STM.TChan data TChan a
10:47:45 <lambdabot> Control.Concurrent.STM.TChan dupTChan :: TChan a -> STM (TChan a)
10:47:55 <EvilTerran> ah, that'll be "transactional channel"
10:48:17 <edwardk> its a japanese term of endearment for someone named T
10:49:34 <Deewiant> For Mr. T, in fact.
10:49:43 <Deewiant> Everybody calls him TChan in Japan
10:49:56 <vincenz> I pity the foo' that uses a term of endearment for Mr T.
10:51:45 <EvilTerran> ... wouldn't that be T-kun?
10:52:21 <Deewiant> More likely, yes.
10:52:48 <EvilTerran> or T-san
10:52:49 <Deewiant> But hey, Schwarzenegger in Shuwa-chan.
10:53:44 <Deewiant> s/in/is/
10:53:45 <edwardk> unless the person was being overly cutesy about it. witness p-chan, tama-chan and a ton of male "chan"'s in anime history ;)
10:53:57 <blarfo> what do you think of the actor-librarY+
10:54:51 * edwardk tries really hard not to make a joke about preferring IMDB in response to blarfo's query.
10:55:38 * EvilTerran was about to tie it in with us talking about mr t and schwartzenegger
10:55:39 * edwardk tries to straighten up and become serious again.
10:55:58 * edwardk fails.
10:57:44 <dolio> @yow!
10:57:44 <lambdabot> Are you still an ALCOHOLIC?
11:00:42 <dmwit> mu!
11:00:54 <edwardk> nu!
11:01:02 <vincenz> eta
11:01:02 <Deewiant> un!
11:01:07 <dmwit> e^x, dy/dx!
11:01:13 <Deewiant> fix!
11:01:17 <vincenz> dmwit: that reminds me of that joke :)
11:01:26 <dmwit> It's supposed to. ;-)
11:01:45 <vincenz> "I'm e^x, noone can differnetiate me to 0" "Hello, I am d/d/y"
11:02:15 <dmwit> Oh, that one.
11:02:34 <profmakx> infinitely many mathematicians walk into a bar, the first one orders a beer, the second half a beer, the third one a quarter and so on. "Stupid mathematicians" says the barkeeper and pours two beers.
11:02:39 <profmakx> nuhaha
11:02:42 <profmakx> sorry
11:02:56 <vincenz> Is that even valid in constructive mathematics?
11:03:03 <vixey> sure
11:03:27 <profmakx> geometric series
11:03:29 <vixey> there is no choice in lim n->infinity
11:03:32 <profmakx> i guess they are valid
11:03:35 <vincenz> I know the geometric series
11:03:41 <vincenz> I'm not sure it holds in constructive mathematisc
11:03:44 <edwardk> sure just take any finite prefix on the series of mathematicians, and the barkeep only wastes an arbitrary small epsilon of beer before closing time.
11:03:57 <vincenz> edwardk: can you prove it becomes 2 tho?
11:04:16 <profmakx> what exactly is considered "constructive mathematics"?
11:04:26 <profmakx> only finitary constructions?
11:04:30 <vincenz> The mathematics where a \/ ~a === True does not hold
11:04:42 <vincenz> Nor does a === ~~a
11:04:55 <vixey> hmmm
11:05:06 <vixey> can't you have choice in a constructive math? if yo uadd in CWCC
11:05:12 <vixey> I thougt it was more, proofs are computational objects
11:05:22 <dmwit_> Luckily, we still get to have ~a === ~~~a
11:05:26 <vixey> maybe this is the difference between constructivism and intuitionism
11:05:28 <vincenz> dmwit: do you?
11:05:29 <Elly> in constructive logic, a proof of a thing is the construction of the thing
11:05:36 <dmwit_> vincenz: yep
11:05:42 <dmwit_> vincenz: I don't remember why, though.
11:06:01 <vincenz> no proof of a === no proof that (no proof of a is provable)
11:06:09 <vincenz> no proof of a === no proof that (no proof of a is not provable)
11:06:15 <dmwit_> ?djinn (a -> Void) -> (((a -> Void) -> Void) -> Void)
11:06:15 <lambdabot> f a b = void (b a)
11:06:18 <Elly> dmwit_: you also have ~~a === ~~~~a, amusingly
11:06:24 <dolio> @djinn Not (Not (Not a)) -> Not a
11:06:24 <lambdabot> f a b = void (a (\ c -> c b))
11:06:25 <Elly> but not the base case :P
11:06:50 <profmakx> seems strange
11:06:51 <blarfo> http://www.prairienet.org/~dsb/t3/hsui.htm
11:06:52 <lambdabot> Title: Dan Bensen: Tic-Tac-Toe
11:06:55 <dmwit_> vincenz: There you have it, both directions of the proof.
11:07:04 <vixey> such bad code
11:07:04 <dolio> @djinn a -> Not (Not a)
11:07:04 <lambdabot> f a b = b a
11:07:08 <edwardk> the problem with constructive mathematics has there is the assertion that every sequence that has an upper bound has a least upper bound breaks down, that 2 is _an_ upper bound shouldn't be a problem. its the completeness property that has a problem constructively
11:07:11 <blarfo> i thought my version was verbose but this donkey is verbosing it up bigtime
11:07:16 <dolio> a => ~~a is fine, just not the reverse.
11:07:25 <Elly> dolio: yep
11:07:29 <dmwit_> ?djinn Not (Not a) -> a
11:07:29 <lambdabot> -- f cannot be realized.
11:07:33 <dmwit_> great!
11:07:42 <vixey> blarfo, agreed
11:07:49 <Elly> mmm, delicious type system
11:07:59 <profmakx> this is actually very interesting
11:08:07 <vincenz> dmwit_: What is Not
11:08:12 <vincenz> data Not a;
11:08:12 <profmakx> learned something from a stupid maths joke
11:08:16 <dmwit_> vincenz: Not a = a -> Void
11:08:28 <dmwit_> vincenz: data Void;
11:08:29 <vincenz> ok
11:08:34 <edwardk> you can emit a perfectly valid constructive proof that no matter whan natural number you provide me with i can show that the series to that point is bounded above by 2
11:08:53 <vincenz> Is it true that in constructive mathematics, real numbers are coutnable?
11:08:55 <Elly> edwardk: I do not think you can do transfinite proofs in constructive logic...
11:09:08 <vixey> Where is the transfinite bit?
11:09:18 <Elly> vincenz: the only real numbers you can have are the computable ones
11:09:24 <Elly> and IIRC computable reals are countable
11:09:25 <vincenz> Elly: What is the proof of that?
11:09:29 <DustyDingo> hm, is there a function, which can perform a function on a variable n times recursivley?
11:09:47 <vincenz> Elly: All computer programs are enumerable, since they're built from an enumerable set, and all inputs are enumerable since time is linear and idscrete?
11:09:49 <dmwit_> vincenz: The list of valid programs is countable. QED
11:09:49 <vixey> DustyDingo: foldNatural
11:09:49 <Peaker> DustyDingo: you can use (iterate ...)!!
11:09:57 <vincenz> dmwit_: how does that take into account inputs?
11:10:00 <Peaker> @type foldNatural
11:10:02 <lambdabot> Not in scope: `foldNatural'
11:10:06 <Elly> vincenz: definition of constructibility... if it's not computable, it's not provable
11:10:12 <dmwit_> vincenz: By folding the input into the source, I believe.
11:10:42 <vincenz> dmwit_: seems like a hack
11:10:45 <vixey> @let foldNatural 0 zero succ = zero ; foldNatural n zero succ = succ (foldNatural (n-1) zero succ)
11:10:47 <lambdabot>  Defined.
11:10:49 <dmwit_> All of mathematics is a hack.
11:10:55 <hackage> Uploaded to hackage: ffeed 0.2
11:10:56 <Deewiant> :-D
11:11:02 <vixey> > foldNatural 7 "foobar" reverse
11:11:04 <lambdabot>   "raboof"
11:11:06 <Elly> I would argue that classical logic (as opposed to constructive) is a hack
11:11:16 <vixey> @go ZFC is a Hack
11:11:20 <Elly> with a giant "trust me on this one" wrapped around the ~(~a) => a
11:11:21 <lambdabot> http://linkinghub.elsevier.com/retrieve/pii/S1570868305000765
11:11:21 <lambdabot> Title: ScienceDirect - Journal of Applied Logic : Is ZF a hack? : : Comparing the compl ...
11:11:42 <duaneb> 'lo?
11:11:43 <DustyDingo> Peaker: so: last (take n (iterate f list)) ?
11:11:43 <edwardk> elly: i didn't assert that 2 was the least upper bound, merely that it was an upper bound. to prove that it is an upper bound i merely have to quantify over the naturals and provide a proof that holds for each. i'm not appealing to an infinite sequence of decisions to construct 2. i know it a priori.
11:11:50 <duaneb> could someone help me with this nasty bug?
11:11:58 <DustyDingo> or is there a better way to do this?
11:12:06 <dmwit_> duaneb: No!
11:12:10 <Elly> edwardk: hm...
11:12:16 <Peaker> DustyDingo: (iterate f initial list)!!n, yeah, or  last (take n) ... instead of !! yeah
11:12:16 <vixey> DustyDingo, I think my way is better
11:12:19 <duaneb> I have gmp installed in /opt/local, yet when compiling something (llvm's haskell bindings), it can't find it
11:12:21 <dmwit_> duaneb: Definitely don't paste any source to hpaste.org, and especially not a description of the problem! ;-)
11:12:25 <duaneb> I've set INCLUDE_PATH and LIBRARY_PATH
11:12:35 <dmwit_> Ah, a more insidious problem.
11:12:40 <duaneb> yes :/
11:12:42 <Elly> you probably should not paste the source of gmp to hpaste
11:12:43 <duaneb> ghc hates me, I think
11:12:55 <dmwit_> Elly: hpaste cuts at 5K anyway ;-)
11:13:42 <dmwit_> I believe there are serious problems with linking Haskell things against gmp.
11:13:49 <dmwit_> Thanks very much to the internals of Integer.
11:13:56 <duaneb> oh :/
11:14:19 <dmwit_> I do not know how the LLVM bindings deal with that...
11:15:13 <dmwit_> Oh, are the bindings written by bos?
11:15:24 <dmwit_> He hangs out here sometimes, you might want to ping and/or ?message him.
11:16:00 <blarfo> how do i do continuatin-passing? with >>= ?
11:16:11 <dmwit_> ?src Cont
11:16:12 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
11:16:16 <vixey> blarfo, I just do it like  f x y z k = k (...)
11:16:29 <dmwit_> blarfo: And yes, (Cont r) is an instance of Monad.
11:18:14 <DustyDingo> hm, is x%y right for modulo? doesn't seem so
11:18:24 <vixey> :t (%)
11:18:26 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
11:18:31 <Peaker> @type mod
11:18:32 <lambdabot> forall a. (Integral a) => a -> a -> a
11:18:43 <Peaker> > 19 `mod` 4
11:18:43 <DustyDingo> ah, ok
11:18:44 <lambdabot>   3
11:19:35 <DustyDingo> why `s?
11:19:44 <vixey> > 19 mod 4
11:19:45 <lambdabot>       No instance for (Num ((a -> a -> a) -> t -> a1))
11:19:45 <lambdabot>        arising from th...
11:20:35 <DustyDingo> ah, i can do this for any function to get infix notation instead of postfix?
11:20:42 <vixey> yes
11:20:43 <DustyDingo> or prefix
11:20:48 <DustyDingo> nice
11:21:05 <AYI> hey
11:21:09 <vixey> hi
11:21:12 <AYI> i dont know anything about haskell
11:21:26 <AYI> but i wanrt a simple thing that
11:21:34 <AYI> learns haskell to me a little bit
11:21:47 <AYI> at least i need to learn its syntax
11:21:51 <vixey> AYI, this tutorial is fun
11:21:54 <vixey> @where LYAH
11:21:55 <lambdabot> www.learnyouahaskell.com
11:22:03 * formalist was just peaking in to see what is going on.
11:22:06 <endusr> A picture book.
11:22:08 <vixey> & does not assume any knowledge
11:22:12 <AYI> thank you
11:22:15 <formalist> later ;)
11:22:52 <endusr> vixey: In the first chapter it expects experience
11:23:13 <AYI> hey
11:23:19 <AYI> i am using debian
11:23:26 <endusr> That's nice.
11:23:28 <vixey> endusr: "I bet that even if you don't have any significant programming experience, a smart chap like you will be able to follow along and learn Haskell. "
11:23:29 <AYI> can youu suggest any tutoriall
11:23:30 <AYI> or
11:23:37 <AYI> haskell-mode for emacs
11:23:43 <endusr> vixey: And before that?
11:23:44 <AYI> is good for writing haskell
11:23:50 <vixey> endusr, sooo not really having a clue what you meant
11:24:03 <vixey> endusr, anyway can't be bothered to argue about this
11:24:24 <endusr> What does it say before that?
11:25:18 <endusr> "This tutorial is aimed at people who have experience in imperative programming languages (C, C++, Java, Python â¦) but haven't programmed in a functional language before (Haskell, ML, OCaml â¦)."
11:25:30 <endusr> We're not arguing, I'm telling you you're wrong.
11:26:19 <endusr> The book doesn't assume any knowledge, but is aimed at those with prior experience.
11:26:32 <Lemmih> endusr: Experience with imperative languages is good but no experience with imperative languages is better.
11:26:37 <dmwit_> AYI: Yes, I think there's a major mode for Haskell in emacs.
11:26:43 * dmwit_ doesn't use emacs
11:26:55 <AYI> hmm
11:27:02 <AYI> dmwit_,  what do you suggest
11:27:11 <AYI> actually i dont like emacs
11:27:12 <vixey> I think haskell-mode sucks but I use it anyway
11:27:25 <AYI> haskell-mode sucks
11:27:27 <dmwit_> AYI: Well, I like vim, but it doesn't really "support" Haskell in any way.
11:27:33 <AYI> what about hugs
11:27:35 <dmwit_> syntax-highlighting
11:27:40 <vixey> hugs isn't an editor though
11:27:42 <dmwit_> Hugs... isn't really an editor.
11:27:45 <AYI> yes
11:27:47 <AYI> i know
11:27:59 <AYI> but you write hugs in terminal
11:28:07 <dmwit_> If you're asking which compiler/interpreter to use, GHC is sort of the overlord right now.
11:28:08 <vixey> I use ghci
11:28:09 <AYI> special window open likke ediyor
11:28:21 <AYI> ghci
11:28:32 <vegai> haskell-mode sucks? I think it's pretty good
11:28:33 <AYI> actually i am asking suitable editor
11:28:41 <AYI> like drscheme like eclipse like anjuta
11:29:08 <AYI> i am searching an editor that makes haskell programming easy
11:29:36 <dmwit_> AYI: Haskell programming is easy without a special editor. ;-)
11:29:36 <vegai> a heckler would say that there's no such in this world
11:29:45 <dmwit_> No, but really, there's not really a great solution right now.
11:29:55 <AYI> i dont know any idea about haskell programming
11:29:57 <endusr> Lemmih: I agree. I was giving a correction.
11:30:01 <AYI> Couldn't find any package matching "ghci".  However, the following
11:30:01 <AYI> packages contain "ghci" in their description:
11:30:01 <AYI>   haskell-mode
11:30:08 <dmwit_> There's some progress; yi and leksah could be nice some day.
11:30:14 <dmwit_> AYI: ghci comes with GHC.
11:30:29 <AYI> aptitude install GHC
11:30:30 <AYI> ?
11:30:54 <dmwit_> The package is called ghc6 here.
11:31:10 <AYI> yes ghc
11:31:24 <AYI> five package in there
11:31:47 <AYI> ghc ghc-prof ghc6 ghc6-doc ghc6-prof
11:32:55 <EmielRegis> is there any advantage of using let/in over where?
11:33:10 <dmwit_> EmielRegis: let/in can be used in an expression.
11:33:18 <dmwit_> > 3 + (let x = 5 in x)
11:33:19 <lambdabot>   8
11:33:32 <EmielRegis> yes i know
11:33:36 <EmielRegis> but you could use where there too...
11:33:42 <EmielRegis> I mean usage in function
11:33:47 <dmwit_> > 3 + (x where x = 5) -- hmm, really?
11:33:48 <lambdabot>   <no location info>: parse error on input `where'
11:34:02 <EmielRegis> and advantages other than encapsulation of the variables in the expression only
11:34:07 <dmwit_> No, expression-ness is a real difference between let and where.
11:34:15 <dmwit_> Other than that; no particular reason
11:34:17 <EmielRegis> ah
11:34:19 <EmielRegis> ok thanks
11:34:21 <dolio> > 3 + x where x = 5
11:34:22 <lambdabot>   8
11:34:32 <dmwit_> dolio: of course
11:34:39 <dolio> :)
11:34:41 <dmwit_> dolio: But that kind of floating isn't always so convenient:
11:34:48 <dmwit_> > [3, let x = 5 in x, 8]
11:34:50 <lambdabot>   [3,5,8]
11:34:59 <dolio> That's just a fluke of how mueval works.
11:35:07 <dmwit_> right
11:36:48 <dmwit_> EmielRegis: Anyway, the practical upshot is that where can be a bit inconvenient inside do blocks.
11:37:33 <dmwit_> Because things bound in the do block are not necessarily bound in the where block.
11:37:33 <sutats> dmwit_: If you don't mind reading more of my code, could you suggest more improvements / condensing to http://hpaste.org/12017#a8 ?
11:38:38 <gio123> does somebody knows pdf reader which has very small size?
11:40:01 <dmwit_> sutats: if (foo) then False else True -> not (foo)
11:40:06 <dmwit_> gio123: xpdf
11:40:30 <gio123> for windows?
11:40:31 <dmwit_> sutats: main looks like an error, too.
11:40:38 <dmwit_> gio123: foxit
11:41:19 <dmwit_> sutats: If you're willing to switch from breadth-first to depth-first, (rest ++ partial) will be faster than (partial ++ rest).
11:41:32 <sutats> dmwit_: Error, how?
11:41:34 <dmwit_> (++) is O(n) in the length n of its first argument.
11:41:47 <sutats> dmwit_: Yeah, the algorithm doesn't matter much to me.
11:41:48 <telexicon> bytestrings++
11:41:52 <dmwit_> sutats: It ends in a binding statement; the compiler should complain.
11:42:02 <dmwit_> sutats: Either that or hpaste cut off the rest of your program.
11:42:47 <sutats> dmwit_: I have a print line after that that I left out my mistake.
11:43:26 <dmwit_> sutats: Maybe after a while, switching to the list monad would be a good way to express solveMaze; other than that, I find this code readable.
11:43:34 * dmwit_ -> work
11:43:39 <dmwit_> Catch you later!
11:43:46 <sutats> dmwit_: Thanks for your help.
11:44:39 <EmielRegis> dmwit_, roger, thanks
11:45:46 <gwern> mmorrow: what is that th stuff in your last paste?
11:46:27 <gwern> Saizan_: what I meant was that I can define a module containg just th functions just fine and typecheck in ghci, but the moment I import that module a into module b, and try to load module b into ghci it fails
11:49:28 <bbs> damn
11:49:31 <bbs> dmwit left :)
11:49:32 <mauke> I want to open a window and draw pixels and lines in it. what package should I use?
11:49:50 <bbs> mauke: oh crap there was a good one posted the other day
11:49:58 <bbs> like graphics?
11:50:08 <bbs> pictures and other stuff too right?
11:50:17 <mauke> just pixels and lines
11:50:31 <bbs> oh this was more manimpulation of pictures and stuff
11:51:40 <bbs> http://dpaste.com/91193/
11:51:46 <bbs> can someone help me make this prettier
11:51:53 <bbs> i know its doing work over the built in functions
11:52:07 <gio123> does somebody knows pdf reader which has very small size?
11:52:08 <bbs> but we are trying to show the difference between eager and lazy eval
11:52:21 <gio123> does somebody knows free pdf reader which has very small size?
11:52:27 <mauke> (() -> Seq a) is basically the same as Seq a
11:53:36 <Botje> gio123: i guess google knows.
11:53:45 <Botje> buf if i'd have to guess: foxit reader
11:54:04 <luite> hm, n00b question, how do I fix this: http://hpaste.org/12102
11:54:35 <vixey> luite, in order to acheive what?
11:54:51 <dolio> luite: Ord q => s -> q means it can produce any q as long as it's in Ord.
11:54:55 <gwern> mmorrow: I mean, obviously it has a nicer error message as it pinpoints the offending entry, but that was a relatively minor issue
11:55:01 <bbs> mauke: yea :/ i know
11:55:08 <bbs> i already complained about that
11:55:17 <gwern> my favorite small pdf reader is 'pdf2text | less'
11:55:28 <gwern> doesn't work so hot for scanned pdfs, but for textual pdfs is great
11:55:39 <luite> dolio: yes, I know. but the 'id' can produce Int, which is an instance of Ord, why isn't that ok?
11:56:01 <dolio> Because it's producing one instance of Ord, not any.
11:56:22 <EvilTerran> > (Nothing :: Maybe a) :: Maybe ()
11:56:23 <lambdabot>   Nothing
11:56:26 <EvilTerran> > (Nothing :: Maybe ()) :: Maybe a
11:56:27 <lambdabot>   Couldn't match expected type `a' against inferred type `()'
12:00:24 <luite> dolio: hm, I just want to have some class Test, that defines a method to get things that I can compare (so that I can sort them), but don't care what exactly it produces. Should I use class (Eq s, Ord q) => Test s q in this case?
12:01:00 <dolio> There are a few options.
12:01:16 <dolio> Well, actually, one won't work.
12:01:35 <Peaker> luite: what are you doing (zoom out)
12:01:51 <dolio> The actual type of your function rather than essentially 's -> (forall q. Ord q => q)' which is what you have...
12:02:01 <dolio> Is 's -> (exists q. Ord q => q)'.
12:02:27 <dolio> Then you could use id, since it's returning 'some' value whose type is in Ord.
12:03:06 <dolio> But then you can't make two and compare them, because there's no type guarantee that if you have two (exists q. Ord q => q), that the particular q is the same.
12:03:18 <dolio> So, yeah, you need a multi-parameter type class of some variety.
12:03:37 <luite> ah thanks, that made it much clearer
12:03:58 <EvilTerran> any particular reason you can't have "q" be, say, "s -> Ordering"?
12:05:03 <dolio> Yeah, well, there's that, too, but then I don't see what the difference between Ord is. :)
12:05:17 <mm_freak_> is there any way to get the version number from the cabal file?
12:05:19 <EvilTerran> ie, instead of returning a value of some abstract ordered type, you could return a function that compared said value to its parameter and returned the result#
12:05:36 <dolio> If it's Ord q => s -> q, then you could theoretically have two different s that produce the same q, and compare them.
12:06:45 <EvilTerran> you'd need more than an Ord constraint for that, surely?
12:08:01 <sutats> Someone suggested that I use the List monad for my solveMaze function in http://hpaste.org/12017#a8 . Could someone help me implement that?
12:08:16 <luite> EvilTerran: hm, don't know how I would use that for sorting
12:09:01 <EvilTerran> luite, sorry, i can't actually persuade your paste to load in my browser for some reason, so i can't really provide any useful input
12:09:12 <EvilTerran> i was just making meandering observations based on what i could infer
12:09:29 <luite> EvilTerran: it's just a toy sample without code that uses it
12:09:57 <dolio> EvilTerran: Maybe I didn't understand you. I was saying that if you have 'foo :: s -> (s -> Ordering)' then foo is presumably analogous to compare for s.
12:10:22 <EvilTerran> dolio, yes, exactly
12:10:44 <Peaker> @type compare
12:10:46 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
12:10:50 <EvilTerran> but, if you had foo :: s -> (exists a. Ord a => a), you wouldn't be able to compare two different results
12:11:08 <EvilTerran> and, if you had foo :: s -> (forall a. Ord a => a), you'd have no way of constructing values
12:11:26 <Peaker> (of interest)
12:11:28 <EvilTerran> hence, you need a typeclass that supports construction and use of values
12:11:38 <EvilTerran> while Ord just covers use
12:12:00 <dolio> Yeah.
12:14:14 <Peaker> http://hackage.haskell.org/packages/archive/reactive/0.8.3/doc/html/FRP-Reactive-Behavior.html#v%3AmonoidB saids monoidB is Monoid a => Event a -> Behavior a   while my local reactive library says: Monoid a => Event (Behavior a) -> Behavior a
12:14:16 <lambdabot> Title: FRP.Reactive.Behavior, http://tinyurl.com/62y5vu
12:14:25 <Peaker> I don't understand what   Monoid a => Event (Behavior a) -> Behavior a     could mean
12:15:08 <dolio> Starts with mempty.
12:15:18 <dolio> At each event, you use mappend to combine the existing and event one.
12:15:42 <Peaker> that makes sense for   Monoid a => Event a -> Reactive a  (and you can of course r2b that)
12:15:50 <Peaker> but I don't understand why the event values are behaviors
12:16:08 <dolio> Oh, yeah. That is a bit weird.
12:16:23 <luite> Peaker: oh sorry I ignored your question. I want to be able use a property to sort, but I don't really care what type of value it is, and it is possibly expensive to calculate, so I want to be able to store the calculated Ord values for later use
12:17:37 <EvilTerran> luite, pick some convenient ordered type, then, and newtype-encapsulate it if you want something apparently abstract
12:17:54 <Peaker> oh, it mappends the behaviors themselves
12:17:56 <EvilTerran> data Ordered = Before Ordered | Middle | After Ordered deriving (Eq, Ord) is a useful one
12:18:31 <Peaker> it would make more sense, IMO, to use:  monoidB :: Monoid a => Event a -> Reactive a     and then use:  (join . monoidB) if you have a Behavior in there
12:18:36 <EvilTerran> as there's an unlimited supply of distinct values between any two non-equal values in that type
12:19:05 <mauke> preflex: seen dcoutts_
12:19:05 <preflex>  dcoutts_ was last seen on #haskell 10 days, 5 hours, 7 minutes and 38 seconds ago, saying: quicksilver: sorry, not now, get the details and file a report
12:19:10 <mauke> preflex: seen dcoutts
12:19:11 <preflex>  dcoutts was last seen on #haskell 1 day, 23 hours, 2 minutes and 34 seconds ago, saying: conal: me neither :-)
12:23:08 <luite> EvilTerran: I'm not sure if I could use that representation
12:24:59 <Cale> EvilTerran: Yay, dyadic rationals!
12:26:41 <luite> if I'd have something that would produce a Double, it's not really a great type to convert to
12:28:54 <waern> Igloo: is there a way to get trac.haskell.org to send email notifications yet?
12:29:21 <Igloo> waern: You can set it to send e-mail in conf/trac.ini. See camp's for an example
12:29:37 <waern> Igloo: ah, ok. Thanks
12:30:06 <EvilTerran> luite, what about Rational?
12:31:42 <luite> EvilTerran: the problem is that I don't (want to) know the type in advance, it may return some complex type that is an instance of Ord. I think I'll just go for the multi-parameter typeclass now and think about other possible options later
12:31:42 <EvilTerran> Cale, well, seeing as they're countable and dense on themselves, i guess you could define an isomorphism to the rationals... i can't think of a particularly natural one, though
12:32:33 <EvilTerran> Cale, that does give me the thought of doing something in the style of Conway's Surreal numbers, though
12:32:48 <Cale> yeah
12:33:06 * EvilTerran notes that his internet connection is, bizarrely, refusing to load web pages even though everything else still works
12:33:16 <Cale> I think it's exactly the surreal numbers which are born on days prior to omega.
12:33:29 <vixey> foldOrdered ((1/) . (1+) . (1/)) 1 ((1 +) . (1 /))
12:33:29 <Cale> (which are, iirc, the dyadic rationals)
12:34:14 <EvilTerran> ... as usual in these cases, getting web pages with the telnet client still works, even though both FF and IE fail
12:34:40 <vininim> EvilTerran: same happening here
12:35:11 <EvilTerran> i think this usually results in me having to restart my computer
12:35:16 <EvilTerran> oh well
12:35:28 <EvilTerran> yay windows!
12:35:44 <mauke> crap. gtk2hs doesn't build.
12:36:15 <Beelsebob> EvilTerran: it usually results in me buying a mac >.<
12:37:01 <EvilTerran> unfortunately for me, i like being able to play games on my computer
12:37:24 <mauke> wake me up when there's an easy to use graphics library for haskell :/
12:37:50 <vixey> mauke, (sorry to disturb you.. what graphics?)
12:38:11 <mauke> pixels. in a window.
12:38:20 <vixey> I used GLUT it's pretty easy
12:38:21 <Beelsebob> mauke: uh, OpenGL, Cairo, FieldTrip...
12:38:26 * adu <3 pixle
12:38:33 <mauke> how exactly is OpenGL easy to use?
12:38:48 <adu> mauke: it is if you know how to use it
12:38:55 <Beelsebob> I find it fairly easy to use -- it isn't in any way functional though, which is why you use fieldtrip instead
12:38:57 <mauke> adu: :/
12:38:57 <adu> vixey: need help?
12:39:00 * ddarius has used OpenGL and a GTK pixbuf for this.
12:39:08 <vixey> not coding anything atm
12:39:22 <adu> who needed OpenGL help?
12:39:30 * adu <3 OpenGL
12:39:42 <Beelsebob> </ /3 OpenGL
12:39:48 <Beelsebob> hopefully OpenCL will fix that up
12:39:48 <adu> :(
12:39:59 <adu> openCL is not about graphics tho
12:40:03 <Beelsebob> sure it is
12:40:07 <adu> no it isn't
12:40:08 <Beelsebob> it's about doing computation on a GPU
12:40:17 <Beelsebob> including computations that write to frame buffers
12:40:18 <mauke> ddarius: how do I get a GTK pixbuf?
12:40:18 <adu> right, which has nothing to do with graphics
12:40:25 <Beelsebob> and read from vertex object buffers
12:40:40 <Beelsebob> adu: since when is graphics not just computation?
12:41:03 <adu> graphics is about style
12:41:08 <adu> and finesse
12:41:10 <ddarius> mauke: You make a new one and then you make a new image from it.  pixbufNew
12:41:16 <mauke> WHAT LIBRARY
12:41:25 <Beelsebob> adu: doesn't make it any less computation on a GPU
12:41:41 <Beelsebob> adu: OpenCL was specifically designed to allow you to write graphics programs in it
12:41:50 <adu> oh ok
12:41:52 <Beelsebob> it's just more general than GL, by quite a long way
12:41:57 <ddarius> mauke: With gtk2hs
12:42:06 <mauke> <mauke> crap. gtk2hs doesn't build.
12:43:49 <ddarius> mauke: Why doesn't it build?
12:44:06 <mauke> unclear
12:44:16 <mauke>     Warning: -fffi is deprecated: use -XForeignFunctionInterface or pragma {-# LANGUAGE ForeignFunctionInterface#-} instead
12:44:19 <mauke> package.conf.inplace: openBinaryFile: does not exist (No such file or directory)
12:44:22 <mauke> make[1]: *** [glib/System/Glib.o] Error 1
12:45:01 * adu <3 LANGUAGE pragma
12:47:39 <trofi> @where ghc-git
12:47:39 <lambdabot> I know nothing about ghc-git.
12:48:15 <ddarius> mauke: That sounds like either the paths are messed up or package.conf.inplace was never made.  Also, why not use a binary package?
12:48:28 <mauke> because that requires 6.8.3
12:52:12 <mauke> ddarius: hmm, almost compiles with ghc-6.8.3
12:52:19 <mauke> ddarius: now I get gtk/Graphics/UI/Gtk.hs.pp:222:0:
12:52:19 <mauke>     Failed to load interface for `Graphics.UI.Gtk.General.General':
12:52:19 <mauke>       Use -v to see a list of the files searched for.
12:54:38 <mauke> where can I get a binary package?
12:55:35 <Beelsebob> darcs get http://darcs.haskell.org/packages/binary
12:55:43 <Peaker> if every arrow has a simple transformation into an applicative, and every applicative has a simple transformation into an arrow, does that mean we can make do with Applicatives to do everything arrows do?
12:55:45 <Beelsebob> oops, no http://darcs.haskell.org/binary/
12:55:46 <lambdabot> Title: Index of /binary
12:55:59 <Beelsebob> or just use cabal/hackage
12:56:23 <dolio> Peaker: Arrow ==> Applicative ==> Arrow doesn't necessarily give you back the same arrow.
12:56:27 * mauke refrains from throwing insults at Beelsebob 
12:56:29 <wjt> i'm assuming mauke meant a binary package of gtk2hs
12:56:29 <dolio> (I think.)
12:57:07 <idnar> wouldn't Arrow ==> Applicative be lossy?
12:57:29 <dolio> Right.
12:57:43 <Peaker> lossy in what way?
12:57:44 <idnar> the main point of Arrow seems to be that it has less powerful operations
12:57:59 <idnar> when you translate to Applicative, you lose those specialisations
12:58:18 <Peaker> concrete example of loss?
12:58:30 <idnar> but, uhm, can you really transform *every* arrow into an applicative?
12:58:35 <dolio> I don't have one of those.
12:58:41 <Peaker> someone here said you could, I think
12:58:48 <idnar> I would have thought some arrows would be too weak to transform
12:59:24 <dolio> Peaker: However, if you read that Wadler paper from not too long ago, he shows that applicatives are isomorphic (or some such) to arrows where A ~> B ~~ () ~> (A -> B).
12:59:38 <Peaker> I think arrows carry more structure, so you might lose that (the framework implementing them would have less optimization hints to work with)
12:59:46 <chowmeined> has anyone tried running haskell on a seaforth machine?
13:00:08 <chowmeined> seemed like the whole stream processing concept would go nicely with infinite lists and laziness
13:00:12 <dolio> So, if that's not the case, then when you go from Arrow => Applicative, you're changing something.
13:00:12 <vininim> gosh
13:00:39 <Peaker> dolio: what do you mean "if that's not the case"?
13:01:07 <dolio> Peaker: If, for whatever arrow you originally have, A ~> B is not isomorphic to () ~> (A -> B).
13:01:28 <ddarius> mauke: http://www.haskell.org/gtk2hs/download/  If you haven't gotten already.
13:01:29 <lambdabot> Title: Gtk2Hs Â» Download
13:01:38 <idnar> I don't see how you'd transform a basic arrow into an applicative
13:01:41 <idnar> but maybe I'm just missing something
13:02:26 <dolio> Because when you go Arrow => Applicative => Arrow, the arrow you get back will follow that law.
13:02:29 <Peaker> I need to toy more with arrows.  I understand functor/applicative/monad very well now, but arrows I've barely used
13:02:29 <mauke> ddarius: none of those apply
13:03:03 <idnar> if it's an ArrowApply, then you get a Monad out, so obviously you can get an Applicative too
13:03:28 <dolio> idnar: You get an applicative by partially applying the arrow.
13:03:42 <dolio> It's a generalization of the reader monad.
13:04:05 <idnar> dolio: how do you implement <*>?
13:04:15 <dolio> Let's see...
13:04:25 <mauke> ddarius: and the archlinux link is broken
13:04:39 <idnar> actually, how do you implement pure?
13:05:32 <dolio> f (a -> b) -> f a -> f b ==> r ~> (a -> b) -> (r ~> a) -> (r ~> b), a -> f a ==> a -> (r ~> a)
13:05:49 <dolio> @type arr const
13:05:50 <lambdabot> forall b b1 (a :: * -> * -> *). (Arrow a) => a b (b1 -> b)
13:06:31 <idnar> ~> is the arrow?
13:06:33 <dolio> @type arr . const
13:06:33 <lambdabot> forall b (a :: * -> * -> *) a1. (Arrow a) => a1 -> a b a1
13:06:35 <dolio> Yeah.
13:06:44 <dolio> There, arr . const is pure.
13:07:15 <idnar> mmph, Control.Arrow doesn't have any interesting arrow instances
13:07:20 <idnar> @instances Arrow
13:07:20 <lambdabot> (->), Kleisli m
13:07:43 <EvilTerran> unfortunately, there don't seem to *be* that many motivating instances
13:07:52 <idnar> EvilTerran: indeed
13:07:59 <EvilTerran> the best i've seen is FRP, and that's big and complicated in its own right
13:08:20 <dolio> @type \f g -> f &&& g
13:08:21 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:08:38 <dolio> @type \f g -> f &&& g >>> arr (uncurry id)
13:08:38 <lambdabot> forall (a :: * -> * -> *) b c' c. (Arrow a) => a b (c' -> c) -> a b c' -> a b c
13:08:42 <BONUS> its still a nice concept :]
13:08:45 <dolio> There's <*>
13:09:03 <idnar> uhm so, (a ~>) is the applicative then?
13:09:10 <dolio> Yes.
13:09:20 <BONUS> how come no one's made something with parallelizing and arrows
13:09:26 <BONUS> seems pretty natural for that
13:09:37 <idnar> hmm
13:10:00 <dolio> Just an applicative, though. Not a monad (which would require ArrowApply).
13:10:26 <idnar> @type (<*>)
13:10:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:10:36 <idnar> I guess that works, then
13:10:55 <hackage> Uploaded to hackage: extensible-exceptions 0.1.1.0
13:12:12 <lispy> BONUS: I know wery wittle about arrows, but what you sounds like it has promise :)
13:12:25 <lispy> "what you said..."
13:12:31 * lispy fails at typing
13:12:36 <BONUS> hehe yeah, but i'm sure there's some big obstacle or something
13:12:40 <BONUS> cause otherwise someone would have already made that
13:13:26 <idnar> > let pure' = arr . const; f <*!> g = f &&& g >>> arr (uncurry id) in pure (,) <*!> (+1) <*!> (*2) $ 10
13:13:26 <lambdabot>       Ambiguous occurrence `pure'
13:13:26 <lambdabot>      It could refer to either `Control.Appl...
13:13:31 <idnar> > let pure' = arr . const; f <*!> g = f &&& g >>> arr (uncurry id) in pure' (,) <*!> (+1) <*!> (*2) $ 10
13:13:32 <lambdabot>   (11,20)
13:13:32 <BONUS> it would be cool though for f &&& g >>> h to be something that takes an input and then paralelly runs two functions on that input and once they're both done, passes it on to h
13:15:01 <idnar> uhm, how the heck do I read "A ~> B ~~ () ~> (A -> B)" or "() ~> (A -> B)"?
13:15:15 <BONUS> from left to right
13:15:17 <BONUS> :]
13:15:21 <idnar> har har
13:15:29 <BONUS> honestly: idk
13:15:37 <dolio> An arrow from A to B is isomorphic to an arrow from () to a pure function from A to B.
13:15:40 <idnar> IDK, my BFF Haskell
13:16:29 <dolio> It's like, for A ~> B in general, the effect that happens can look at what A was...
13:16:53 <mauke> oh, the gtk2hs error is actually:   Cannot find a definition for `FileSelection' in the header file.
13:17:11 <dolio> Whereas for applicatives, and arrows that are equivalent, the effect is just attached to a pure function, and doesn't get to look at the A.
13:17:17 <dolio> I think that's right, at least.
13:18:48 <luite> when using :load in ghci i get this error:  Use -v to see a list of the files searched for.  but how do I actually use the -v? ':load -v file' does not work
13:20:41 <luite> uh, that is not the error of course, the error is that it cannot load some module
13:22:34 <RayNbow> luite: try :m ?
13:22:40 <EmielRegis> how is powf function called in haskell>?
13:23:11 <lispy> > 2.3 ** pi
13:23:12 <lambdabot>   13.68993897587242
13:23:15 <lispy> EmielRegis: like that?
13:23:23 <RayNbow> :t (^)
13:23:24 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:23:24 <lispy> I forget what powf does :)
13:23:26 <RayNbow> :t (**)
13:23:27 <lambdabot> forall a. (Floating a) => a -> a -> a
13:23:39 <trofi> :t (^^)
13:23:40 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:23:44 <EmielRegis> > 2.0 ^ 4
13:23:45 <lambdabot>   16.0
13:23:50 <EmielRegis> > 2.0 ** 4
13:23:51 <mauke> > 2 ^ 4
13:23:52 <lambdabot>   16.0
13:23:52 <lambdabot>   16
13:23:56 <EmielRegis> ah
13:23:57 <EmielRegis> danke
13:24:08 <luite> RayNbow: that gives me exactly the same suggestion, but again no help on how to actually use it
13:24:10 <olsner> > 2.0 :: Int
13:24:11 <lambdabot>       No instance for (Fractional Int)
13:24:11 <lambdabot>        arising from the literal `2.0' ...
13:24:14 <mauke> > 1 `shiftL` 4
13:24:15 <lambdabot>   Add a type signature
13:24:17 <mauke> > 1 `shiftL` 4 :: Integer
13:24:18 <lambdabot>   16
13:24:29 <RayNbow> luite: which module do you need?
13:24:55 <lispy> :t [(^), (**)]
13:24:56 <lambdabot> forall a. (Integral a, Floating a) => [a -> a -> a]
13:27:32 <luite> RayNbow: ah, found it, you have to start ghci with the -v option. The suggestion in the error output is not clear on that, imho
13:27:48 * RayNbow coughs :p
13:27:52 <luite> :P
13:28:07 <RayNbow> gee, I wonder how you figured that out ;)
13:28:26 <Peaker> > a ^ 5
13:28:27 <lambdabot>   a * a * (a * a) * a
13:28:43 <Peaker> > a ** 5
13:28:44 <lambdabot>   a**5
13:29:03 <Peaker> @type shiftL
13:29:04 <lambdabot> forall a. (Bits a) => a -> Int -> a
13:29:06 <vixey> > 5**5
13:29:07 <lambdabot>   3125.0
13:29:16 <Peaker> @src Bits
13:29:16 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:46:25 <Cale> http://www.toothpastefordinner.com/111508/reinventr-two-point-oh.gif :)
13:47:02 <RayNbow> http://www.reddit.com/r/programming/comments/7dpk2/dan_bensen_tictactoe/
13:47:04 <lambdabot> Title: Dan Bensen: Tic-Tac-Toe : programming, http://tinyurl.com/5dhlns
13:47:09 <RayNbow> "Haskell is hard to learn, and debugging recursive code can be unpleasant." <-- what? :p
13:48:15 <Cale> heh, who knows
13:49:38 <bbs> wheeee
13:49:43 <dolio> I imagine debugging recursive code is unpleasant if you do it by tracing execution and such.
13:49:43 <bbs> its a bbs
13:50:34 * Cale remembers the days of dialing local BBSes with his modem. :)
13:51:06 * bbs was not born
13:51:08 <bbs> probably
13:51:11 <vixey> obv. haskell sucks becuase you have to use recursion
13:51:13 <vixey> :p
13:51:35 <BONUS> lol
13:51:37 <BONUS> debugging haskell
13:51:39 <BONUS> that's a new one
13:51:50 <vixey> @quote defeat
13:51:51 <lambdabot> No quotes match. I feel much better now.
13:52:06 <RayNbow> bbs: how old are you?
13:52:16 <bbs> 20
13:52:19 <RayNbow> hmm
13:52:33 <bbs> Cale: you up for some fun
13:52:53 * RayNbow is 23...
13:53:09 <RayNbow> but I have heard of BBSes when I was young... I just didn't have a modem :p
13:53:17 * ddarius has dialed into BBSes.
13:53:22 <Cale> I think people are frustrated by debugging Haskell because the techniques they're used to using for finding bugs, ones which are designed to deal with cases where you have lots of mutable state, don't work so well in Haskell.
13:53:54 <Peaker> Cale: How can you debug Haskell? I'm also frustrated by the lack of interactive debuggers
13:53:55 * RayNbow first had to go to his uncle's place if he wanted to surf on the internet in the 90s
13:54:09 * CosmicRay ran a BBS
13:54:15 <chowmeined> why would you use an interactive debugger for haskell?
13:54:17 <Riastradh> That's not true, Cale.  Mutable state is notoriously hard to debug as well.  Non-strict evaluation is what impedes the mindset of traditional breakpointing and stack-inspecting debuggers.
13:54:25 <ddarius> CosmicRay: Don't you run a gopher site?
13:54:33 <CosmicRay> ddarius: why yes I do :-)
13:54:36 <chowmeined> i mean
13:54:41 <Cale> Riastradh: well, yes, those methods rely on strict evaluation
13:54:44 <RayNbow> in the late 90s I got "free" internet (dial back connection to a corporate network :p)
13:54:52 <chowmeined> sequential execution is an implementation detail
13:54:55 <chowmeined> you dont want to look at that
13:55:22 <Peaker> an FRP Haskell tic tac toe could probably be significantly shorter
13:55:42 <vixey> does that including implementing FRP?
13:55:57 <CosmicRay> ddarius: in fact, one of my earliest Internet access options was, of all things, a public television station that had a gopher client
13:56:02 <Cale> I mostly debug Haskell code by ensuring that definitions are small and simple, and then working out which one is not doing what it should be.
13:56:04 <Peaker> chowmeined: because executing a program takes a long time, so interactivity lets me see more things without recompiling and rerunning the whole thing
13:56:27 <Peaker> chowmeined: an interactive debugger is not necessarily a "sequential execution" thing
13:56:36 <CosmicRay> some grant-funded service run by KCPT in Kansas City that provided access on a toll-free number to certain people that lived in an area without local access
13:56:40 <Peaker> Cale: how do you work that out? You just wrote 2 pages of code, and you get some bottom somewhere
13:56:56 <CosmicRay> Peaker: hunit or quickcheck?
13:56:58 <Peaker> vixey: FRP is a library, like any other
13:56:58 <chowmeined> well, the majority of the code is pure functions
13:57:09 <ddarius> Peaker: There shouldn't be too many places where you get bottom, so that should cut it down a lot.
13:57:12 <Cale> Peaker: Well, I try not to write 2 pages of code without looking at what I've done, for one.
13:57:13 <Peaker> CosmicRay: sure, if you want to write unit tests
13:57:18 <vixey> still dunno if you are counting the library or not
13:57:26 <CosmicRay> Peaker: do note that quickcheck is not unit testing
13:57:28 <Peaker> Cale: you've looked at it, but you missed some typo, perhaps the use of blah instead of blah'
13:57:36 <EvilTerran> Peaker, i'd be tempted to see what Catch made of it, too
13:58:00 <chowmeined> so then it wont compile
13:58:09 <Peaker> EvilTerran, Cale: I think it makes more sense to run it, and be able to "dig in" to the errors/results and see what is the expression that led to them, and how it was computed
13:58:10 <Cale> Peaker: But if I have the bug isolated to 2 pages of code, then I'd probably start by testing each of the definitions, and looking for one which doesn't work.
13:58:25 <chowmeined> or if it does compile, depending on the subsequent behavior, you should be able to find the deviation from expected data flow
13:58:27 <Peaker> Cale: that will take much longer than an interactive debugging session
13:58:33 <Cale> (QuickCheck maybe)
13:58:35 <Philippa> Peaker: no, FRP is a concept with multiple libraries implementing it in various ways
13:58:38 <Peaker> Cale: at least for many people (e.g me)
13:58:56 <chowmeined> wait
13:58:57 <CosmicRay> Peaker: it is a shift in mindset, for sure.  though I found interactive debuggers to be of little use in other languages, too
13:58:57 <Peaker> Philippa: yeah, s/FRP/Reactive (in all my above statements)
13:58:59 <chowmeined> whats ghci then?
13:58:59 <Cale> But usually I have a pretty good idea of what the code is doing, and which parts I'm less certain about.
13:59:06 <EvilTerran> Peaker, but you need only do it once, and then you can quickly run your code against it whenever you make any modifications
13:59:08 <Peaker> CosmicRay: I find them very useful in other languages
13:59:15 <CosmicRay> Peaker: I mean, really only in C was it ever of that much use to me, and there because you have weird things happening with pointers and whatnot
13:59:17 <Cale> Often I'll just try and prove (in my head) that the code is correct.
13:59:29 <CosmicRay> I don't think I ever used an interactive debugger for python, and honestly I don't even know if it has one these days.
13:59:29 <vixey> My favorite way is still to make things so simple that bugs are difficult to _not_ notice
13:59:32 <Cale> The place where I get stuck is usually where the bug is :)
13:59:33 <Peaker> Cale: I've hit typo-bugs in Haskell, and its always hurt me a lot more than it should
13:59:35 * EvilTerran runs proofs in his head sometimes, too
13:59:47 <Peaker> Cale: You're referring to thought-bugs, I'm referring to silly typos
13:59:51 <CosmicRay> Peaker: yes I have too.
13:59:56 <CosmicRay> Peaker: quickcheck can help there
14:00:00 <gwern> I dunno, haskell catches typos very well for me
14:00:04 <CosmicRay> it will give you specific cases that you can run through
14:00:05 <roconnor> > showHex (fromEnum '#') ""
14:00:07 <lambdabot>   "23"
14:00:09 <chowmeined> most of the code i end up writing is a ton of tiny functions
14:00:10 <Peaker> CosmicRay: so you suggest accompanying each function with a quickcheck?
14:00:22 <CosmicRay> Peaker: not a bad idea.  there are some that do exactly that.
14:00:29 <Cale> Peaker: Well, looking over the code carefully will catch those too.
14:00:39 * vixey usually implements other people proofs :p
14:00:44 <CosmicRay> though sometimes it gets to the point of absurdity, where your test is pretty much the same code as the function
14:00:48 <Peaker> Cale: That takes longer than diving in with a debugger
14:00:54 <Cale> I'm not sure that it does.
14:00:57 <Peaker> Cale: and exerts *much* more mental effort
14:01:10 <CosmicRay> also there are many, many situations where a debugger doesn't work well.
14:01:11 <chowmeined> but tests are more than one time use
14:01:15 <CosmicRay> try debugging anything multithreaded.
14:01:21 <CosmicRay> or something that forks off worker processes
14:01:24 <Cale> Especially for recursive functions, a debugger does exactly the opposite of what you want.
14:01:33 <CosmicRay> or something that is timing-sensitive
14:01:37 <Peaker> I think many (and surely me) have a quota on the amount of mental effort I can exert in a day, and I don't want to waste it carefully re-reading my code 3 times because I'm missing a typo '
14:01:37 <CosmicRay> or has a GUI
14:01:55 <Peaker> Cale: I agree that maybe a debugger ought to function differently than an imperative "step/next" debugger
14:02:09 <Peaker> Cale: but an interactive expression evaluation visualizer can definitely be of help
14:02:09 <Cale> Traditional debuggers don't know how to apply induction properly to skip over digging into code which should already work.
14:02:11 <chowmeined> hey
14:02:14 <chowmeined> how about this
14:02:39 <Cale> Peaker: I agree on that.
14:02:42 <chowmeined> have the debugger build a visual execution path
14:02:47 <Cale> Peaker: Something like HOPS for Haskell would be great.
14:03:04 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/
14:03:05 <Peaker> CosmicRay: debugging multi-threaded stuff is hard, in most other languages that was one of the reasons I preferred to avoid multithreading. In Haskell I feel I don't have enough experience to form an opinion
14:03:05 <lambdabot> Title: HOPS
14:03:09 <chowmeined> with different levels of depth, so first level would only show highest level functions etc
14:03:18 <Adamant> didn't someone create a really good Haskell debugger as a student project?
14:03:25 <chowmeined> and then you could see the variables at any point, and change them needed and see how it changes the path
14:03:26 <Cale> HOPS is very close to how I think about Haskell code already.
14:03:30 <roconnor> hmm, maybe I should donate to freenode.
14:03:43 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
14:03:44 <lambdabot> Title: HOPS - Animations
14:03:57 <tomh> data Bool = True | False would be valid haskell right?
14:04:04 <ddarius> @src Bool
14:04:04 <lambdabot> data Bool = False | True deriving (Eq, Ord)
14:04:07 <vixey> tomh, yes
14:04:24 <tomh> any idea why my ghci might throw an input parse error on "data" ?
14:04:35 <Cale> tomh: Because GHCi wants an expression and not a declaration
14:04:40 <vixey> maybe the stuff before it
14:04:41 <gwern> you can define data in ghci?
14:04:43 <vixey> oh...
14:04:44 <Cale> tomh: Put your declarations into a file and load it.
14:04:49 <vixey> thought it was in a file :/
14:04:58 <tomh> ok
14:05:17 <nha_> is there a way to get haddock 2.3 to work with FFI functions that do not return in the IO monad
14:05:26 <EmielRegis> hmm
14:05:34 <EmielRegis> any of you familiar with 3d graphics? :p
14:05:34 <Peaker> is hops downloadable?
14:05:43 <EmielRegis> im wondering how to write a HDR renderer in haskell
14:05:48 <Peaker> EmielRegis: HDR?
14:06:04 <Daniel_H> EmielRegis - I'm familiar with the art side, less so the coding side.
14:06:06 <ddarius> EmielRegis: The HDR aspect is orthogonal.
14:06:11 <vixey> EmielRegis, is HDR just post processing?
14:06:18 <EmielRegis> yes
14:06:20 <EmielRegis> i belive it is
14:06:20 <nha_> yea in video games
14:06:32 <ddarius> vixey: Not quite, but it doesn't really change the implementation of a renderer.
14:06:32 <EmielRegis> peaker, high dynami range
14:06:50 <chowmeined> how would you use quickcheck to test something like parsec code?
14:07:04 <EmielRegis> <ddarius> EmielRegis: The HDR aspect is orthogonal.
14:07:05 <EmielRegis> ??
14:07:07 <vixey> chowmeined, I wouldn't use quickcheck for that
14:07:19 <chowmeined> vixey, what would you use?
14:07:34 <EmielRegis> from what I know, HDR involves 'merging' pixels colour with pixels around it
14:07:46 <ddarius> EmielRegis: Whether a 3D graphics renderer is HDR or not doesn't really effect much.
14:07:50 <chowmeined> vixey, i mean, i can supply a list of sample inputs, and expected parse results
14:08:08 <chowmeined> i just want X to check automatically if they match
14:08:10 <Peaker> Cale: HOPS seems to be a demo GIF and some papers, I can't find any download link :)
14:08:10 <Daniel_H> EmielRegis, HDR and Bloom are seperate effects, but Bloom requires a HDR setup.
14:08:17 <vixey> chowmeined, you could, you also generate lots of ASTs and check that pretting printing them and parsing that gives you back what you started with
14:08:25 <Cale> Peaker: Not that I'm aware of... send an email to Dr. Kahl about it though and he'll probably be able to send you a copy.
14:08:42 <chowmeined> vixey, thats true
14:08:45 <Cale> (I'd like him to make it downloadable too :)
14:09:45 <ddarius> EmielRegis: The actual bloom effect (in real life) has to do with the fact that cameras/eyes have finite apertures and thus doesn't effect light propagation.
14:09:48 <yitz> Cale: isn't mcmasters the place where stuff is IP encumbered, because they're doing medical apps etc?
14:09:50 <Peaker> Cale: sounds like 1993 :)
14:09:54 <Daniel_H> HDR is a setup which light sources greater than 1/1/1 and an effect which adjusts the screen to the optimum contrast. Bloom is when the specularity of a pixel exceeds 1/1/1 (Because the light source can be higher than 1/1/1 - say the pixel reflects 80% of a 2/2/2 light) so it "bleeds" into the pixels around it.
14:10:06 <Daniel_H> *which = with
14:10:16 <Cale> yitz: I'm not sure.
14:11:56 <Cale> Peaker: The nice thing about having a way to visualise graph reduction is that it makes space behaviour obvious.
14:12:04 <Cale> More than any other aspect.
14:12:16 <EmielRegis> ah
14:13:08 <sutats> Someone suggested that I use the List monad for my solveMaze function in http://hpaste.org/12017#a8 . Could someone help me implement that?
14:13:12 <nha_> why does haddock type check the return type of FFI stuff heh
14:13:32 <nha_> older versions diddnt
14:13:33 <vixey> sutats, directions = [N,W,S,E]
14:13:59 <chowmeined> how can you have an FFI function not return in the IO monad?
14:14:22 <Daniel_H> bbl
14:14:23 <Cale> chowmeined: If you give it a non-IO type, it'll be unsafePerformIO'd automatically.
14:14:45 <nha_> chowmeined: yea
14:14:51 <chowmeined> ew
14:14:53 <nha_> has to be an alias of IO
14:15:02 <Cale> sutats: Sure, I can help...
14:15:02 <sutats> vixey: Where would that go?
14:15:06 <Cale> sutats: one moment :)
14:15:13 <sutats> Cale: Thanks.
14:16:17 <Cale> sutats: In the list monad, v <- x, where x is a list, selects v in all possible ways from the list x.
14:16:58 <Cale> sutats: guard p, where p is a boolean will cause backtracking when p is False (effectively cutting off that branch of the computation)
14:17:22 <Surma> Hey guys, I got 2 integers a and b, why wont a/b yield me a double-result? (at least the ghci says so)
14:17:25 <sutats> Cale: Essentially my recurse line condition?
14:17:41 <Cale> Yes, effectively.
14:17:47 <BONUS> try fromIntegral a / fromIntegral b
14:17:51 <Surma> k thx
14:18:01 <Cale> Surma: Because we don't automatically convert numeric types in Haskell.
14:18:11 <vixey> Surma, what about % instead of /
14:18:16 <Cale> Surma: / only works with types of numbers which are fractional.
14:18:21 <Cale> vixey: % ?
14:18:26 <EvilTerran> ?type (%)
14:18:27 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
14:18:35 <Cale> I suppose that's doable.
14:18:45 <EvilTerran> takes two integer values, returns a fractional value
14:19:42 <Surma> % not in scope?!
14:20:00 <EvilTerran> oh, sorry, it's in Data.Ratio
14:20:27 <sutats> Cale: How many v <- x do I need?
14:20:30 <vixey> sustats, you can think of,
14:20:36 <vixey> do step <- directions ; ...
14:20:39 <EvilTerran> sutats, "import Data.Ratio" at the top at your file will get it in scope
14:20:45 <vixey> as 'step' choose the correct direction to go in
14:20:49 <Surma> thx
14:20:58 <EvilTerran> (well, below any "module ... where" decleration you may have)
14:21:15 <tomh> do imports need to occur before module definition?
14:21:22 <vixey> so once you got that, you just   path <- solve the rest of the maze
14:21:26 <vixey> and return (step : path)
14:21:42 <EvilTerran> tomh, between the "where" of "module Foo (<exports>) where" and the definitions of the module, i believe
14:21:59 <vixey> sustats, (But you have to keep track of the squares you were in already so you don't get into a infinite loop)
14:22:00 <sutats> vixey: With direction being a list of all the directions, right?
14:22:01 <tomh> ok
14:22:06 <vixey> sutats, yes
14:22:10 <vixey> sutats, just as I defined earliel
14:22:44 <sutats> vixey: Hm, let me try implementing that.
14:22:54 <mikezackles> Does anyone know why ghc 6.10 would hang when running "runhaskell Setup configure"?  (I'm trying to compile the Cabal package).  It seems like ghc is eating all the memory on this machine (only 256MB).
14:23:52 <ibid> have you tried compiling Setup first?
14:25:00 <Cale> sutats: http://hpaste.org/12106
14:26:01 <sutats> Cale: Wow, that's amazingly simple compared to what I had.
14:26:11 <mikezackles> ibid: Sorry, how do I do so?
14:26:41 <mikezackles> ibid: (No, I haven't)
14:26:58 <ibid> mikezackles: ghc -o setup --make Setup.hs ?
14:27:04 <ibid> mikezackles: then run ./setup configure
14:27:27 <ibid> (may not solve your problem, but it is worth trying)
14:28:12 <mikezackles> ibid: seems to be getting further than it did before.
14:29:40 <sutats> Cale: Just for clarification, it should be solve :: Maze -> Coordinate -> Coordinate -> Path, and not [Path], right?
14:30:40 <sutats> ?index guard
14:30:40 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:30:42 <Cale> sutats: no, it must be a list of paths
14:31:06 <mikezackles> ibid: Thanks, that worked.  Good lesson to learn.
14:31:28 <vixey> easy way out
14:31:33 <vixey> don't write a type annotation :p
14:31:46 <Cale> sutats: Because there might not be a solution, so that list will be empty if there isn't.
14:31:52 <sutats> vixey: Haha, yeah.
14:31:59 <Cale> sutats: and there might be more than one solution, in which case the list will list them all.
14:32:01 <jaj> hmm, doesn't ghc-6.10.1 require libgmp anymore?
14:32:02 <lambdabot> jaj: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:32:02 <sutats> Cale: But Path is [Coordinate]
14:32:06 <Cale> sutats: Yes.
14:32:15 <Cale> sutats: That doesn't matter :)
14:32:16 <vixey> sutats, this code is in list monad
14:32:23 <vixey> if you want a Path as a result
14:32:28 <Cale> sutats: So [Path] is [[Coordinate]]
14:32:34 <sutats> Oh, I see what you mean now.
14:32:37 <vixey> the function is    a -> b -> [Path] -- Path in the list monad
14:32:49 <sutats> And the set of paths may be empty.
14:32:53 <vixey> so in a different function that is in the list monad,, you can do
14:33:03 <vixey> solution <- solveMaze foo bar ; ...
14:33:08 <vixey> and you have got a solution
14:33:54 <sutats> vixey: Hm, that's pretty neat.
14:34:29 <sutats> Cale: So, I'll have a list of all possible solutions, essentially. From there, I can pick any. Is that pretty much right?
14:34:49 <Cale> right
14:35:04 <Cale> sutats: If you only take the head of the list, that's the depth first solution.
14:35:51 <FunctorSalad> why isn't there a typeclass for String-like types like the bytestrings? naive question
14:36:09 <sutats> Cale: Wow, that's rather convenient. Only problem now is that it seems not to work. It's stack overflowing when it wasn't before.
14:36:12 <vixey> @src listToMaybe
14:36:13 <lambdabot> listToMaybe []        =  Nothing
14:36:13 <lambdabot> listToMaybe (a:_)     =  Just a
14:36:18 <olsner> because String was already a type before bytestrings were invented?
14:36:19 <ibid> mikezackles: cool
14:36:54 <FunctorSalad> olsner: I thought things were commonly reworked here in hask ;)
14:37:14 <sjanssen> FunctorSalad: because development takes the path of least resistance, and it is easier to clone the API of Data.List than to come up with a proper abstraction
14:38:01 <FunctorSalad> sjanssen: ah. I thought that maybe there was some fundamental problem
14:38:06 <ddarius> One could use the interfaces in Edison.
14:38:40 <ddarius> Or one could make their own interface.
14:38:45 <FunctorSalad> couldn't String become an existential type for the "StringLike" typeclass?
14:39:01 <sjanssen> ddarius: you can't actually, because the sequence class in Edison has the wrong kind
14:39:11 <FunctorSalad> so it'd be nearly a drop-in replacement
14:39:23 <sjanssen> FunctorSalad: types that are in Haskell '98 are generally not changed
14:39:49 <sjanssen> FunctorSalad: all sorts of programs would break if "type String = [Char]" wasn't true
14:40:05 <lispy> I would like to point out yet another place where having polymorphic kinds would be useful
14:40:05 <ddarius> "all sorts" == "almost all of them"
14:40:28 <sjanssen> ddarius: agreed
14:40:29 <vixey> lispy, that sounds insane (and interesting), Do you have a list of these?
14:40:43 <FunctorSalad> ddarius: why so many, if StringLike supported all the common ways that Strings are used?
14:40:55 <ddarius> FunctorSalad: Strings are commonly pattern matched.
14:41:07 <lispy> vixey: sadly no, but Tim Sheard did a proposal for a language like Haskell but with polymorphic kinds and GADTs...he called it Sigma, iirc
14:41:23 <FunctorSalad> ddarius: didn't know that
14:41:33 <sjanssen> FunctorSalad: we also often use list manipulation functions on String (map, takeWhile, etc.), these would have to be generalized too
14:41:33 <lispy> vixey: my bad, Omega, not Sigma
14:41:34 <vixey> are you sure it has _polymorphic_ kinds?
14:41:40 <ddarius> Or generic list functions are applied to them that wouldn't be very useful in a StringLike class.
14:42:06 <lispy> vixey: well, it has extensible kinds
14:42:17 <lispy> vixey: http://web.cecs.pdx.edu/~sheard/papers/GADT+ExtKinds.ps
14:42:18 <vixey> is that the same thing?
14:43:07 <lispy> vixey: heh, read the paper and tell me where I'm wrong :)
14:43:30 <vixey> I've read it and I don't eralyl know what polymorphic kinds are
14:43:41 <FunctorSalad> ok, granted... there has to be some better way than littering 'pack' and 'unpack' everywhere though ;)
14:43:42 <vixey> I am wondering what it is
14:43:56 <ddarius> Polymorphic kinds would be just like polymorphic types, just at the kind level.
14:44:05 <FunctorSalad> (that was @ ddarius , sjanssen )
14:44:09 <Pillager37> how do you stop this..
14:44:15 <Pillager37> let a = cylce "a"
14:44:17 <Pillager37> last a
14:44:20 <lispy> vixey: well, when I've needed it before, what I needed was a way to work with mulitple kinds from the same type signature
14:44:31 <FunctorSalad> Pillager37: Ctrl-C? ;)
14:44:38 <ddarius> FunctorSalad: Rewrite the libraries to operate on abstractions rather than concrete data structures.
14:44:38 <Pillager37> doesnt work
14:44:51 <sjanssen> FunctorSalad: if you're frequently packing and unpacking with ByteString, you're doing something wrong
14:45:08 <sjanssen> FunctorSalad: those are the most expensive operations
14:45:10 <vixey> Do you have like, polymorphically recursive types?
14:45:17 <p_l> Pillager37: SIGKILL
14:45:51 <ddarius> A polymorphically recursive type would be insane.
14:46:05 <vixey> yeah
14:46:06 <vixey> :)
14:46:07 <FunctorSalad> sjanssen: I tried to use ByteString for everything (even short strings) so I can hide the Prelude functions and don't need to qualify the BS functions
14:46:25 <lispy> vixey: I think the other thing that would have worked for me in the past was to have type level paramter plumbing...that is, I don't think I need type level lambdas, but I would like to be able to pass type variables to the right places without having to create a new named type everytime...(so I want anonymous types heh)
14:46:29 <FunctorSalad> sjanssen: but now I need to pack/unpack when using any libraries that use String
14:47:18 <ddarius> lispy: There is a paper that proposes to add some restricted type lambdas to Haskell that would avoid undecidability but allow many of the types of things people want to do with type lambdas.
14:47:23 <ddarius> E.g. flip arguments.
14:47:23 <lispy> vixey: really it comes down to this: When you're simulating dependent programming in haskell, you realize that the type system is not really designed for programming :)
14:47:37 <FunctorSalad> I guess ByteString should only be used where necessary...
14:47:37 <sjanssen> FunctorSalad: don't use those libraries :)
14:47:43 <vixey> why not program in a dependently typed language then?
14:47:44 <lispy> ddarius: oh, I should be citing that, do you know the name or anything?
14:47:48 <sjanssen> FunctorSalad: yes, ByteString should only be used when necessary
14:48:07 <vixey> are you writing a paper on this?
14:48:14 <sjanssen> FunctorSalad: and if you're going from ByteString to String frequently, you're not getting any of the benefits of ByteString
14:48:43 <lispy> vixey: I'm writing my thesis and the cruxt is about using haskell's type system as a proof-assistant-lite
14:49:03 <vixey> cool idea
14:49:07 <FunctorSalad> would you use ByteString for URIs already? :)
14:49:08 <lispy> vixey: we applied some cool stuff to darcs, and now I have to figure out how to explain, justify and compare it to the work of others :)
14:49:08 <vixey> lispy, I realy want to read that ..
14:49:15 <FunctorSalad> for a program processing many of them
14:49:28 <vixey> lispy, did you seem toms thing?
14:49:41 <lispy> vixey: maybe not, what thing?
14:49:50 <vixey> http://www.cs.kuleuven.be/%7Etoms/Research/papers/plpv2009_draft.pdf
14:49:53 <lambdabot> Title: cache:http://www.cs.kuleuven.be/%7Etoms/Research/papers/plpv2009_draft.pdf - Goo ..., http://tinyurl.com/57mszr
14:50:14 <sutats> :t (/=)
14:50:14 <lambdabot> forall a. (Eq a) => a -> a -> Bool
14:50:42 <lispy> vixey: oh this looks related already...but this isn't published yet?
14:51:05 <sjanssen> FunctorSalad: I'd probably use String first, especially if you're interfacing with a library that uses String
14:51:36 <FunctorSalad> sjanssen: *nod*, all libraries I've seen use String for them
14:52:02 <sjanssen> FunctorSalad: URIs are likely to be small enough that String is okay
14:52:40 <lispy> vixey: in our case, we wanted to use Haskell + existing extensions, we wanted static proofs of certain invariants, and we didn't want to have to resort to dependent programming etc
14:53:10 <lispy> vixey: so we came up with a way to use GADTs + existentials to encode our stuff and then we applied it in a real-world setting
14:55:31 <vixey> btw do you have some formal argument about why these proofs are believable ?
14:55:45 <lispy> which proofs?
14:55:52 <vixey> the ones you have written
14:56:02 <vixey> I mean just the technique in general I guess
14:56:13 <lispy> Hmmm
14:56:20 <vixey> it would be very cool to see some argument that these proofs are reliable
14:56:44 <lispy> So, there is the proving that the semantics do something useful (proving our datamodel)
14:57:05 <lispy> and I guess you asking about proving that the type checker gives us a proof?
14:57:24 <vixey> yes
14:57:46 <lispy> I'll ask my advisor about that
14:58:06 <lispy> So, I had been banking on the type checker's ability to do "logic" as being sufficient
14:58:10 <vixey> like in Luos thesis there is a lot devoted to explaining why this stuff is a logical system, which one, what is the logical meaning of language constructs and proofs and so on
14:58:16 <lispy> I mean, the techniques we use exist already in the literature
14:59:02 <lispy> It's a good point, and if I were a PhD student I'm sure this would be required
14:59:18 <lispy> Hence why I think I should bring this up with my advisor...
15:00:16 <lispy> my contribution is more of the variety, we applied this research to a real-world application, it helped X much, and we think it was worth the effort [see benefits], kthx
15:00:42 <sutats> vixey: In the list monad version that Cale posted (http://hpaste.org/12106), I don't see a termination for when end == here. Why is that?
15:01:38 <vixey> sutats, so .. if you're at the exit
15:01:47 <vixey> you want to  return []
15:02:02 <vixey> so you could just have like, on the line before
15:02:03 <vixey> solve maze end here =
15:02:05 <vixey> add
15:02:11 <vixey> solve maze end here | end == here = return []
15:02:25 <sutats> vixey: Ah, that's why it wasn't terminating.
15:02:38 <vixey> lispy, will it get posted online at some point? (something I can bookmark? :) )
15:03:05 <lispy> vixey: yeah, after I defend it will go to my uni's library and I tihnk I can host it off my own webserver too
15:03:24 <lispy> vixey: and maybe we can get a shorter version accepted at ICFP next year
15:03:44 <lispy> vixey: (my uni's library has free access to theses on the web)
15:03:59 <sutats> vixey: Hm...I needed that part, but it's still overflowing the stack when it shouldn't.
15:04:08 <vixey> don't want short versions :p
15:04:28 <vixey> sutats, did you do the thing I said you should do to make it not infinite loop?
15:04:40 <vixey> sutats, (the other one)
15:05:00 <sutats> vixey: I may have missed that. Mind reposting what you said?
15:05:17 <Pillager37> http://learnyouahaskell.com/types-and-typeclasses
15:05:21 <vixey> sutats, if I got North now, and I must not be allowed to go South next
15:05:22 <lambdabot> Title: Learn You a Haskell for Great Good! - Types and Typeclasses
15:05:23 <lispy> vixey: thanks for the enthusiasm, I'm going to go back to writing :)
15:05:24 <ddarius> lispy: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.7505
15:05:25 <lambdabot> Title: Type classes with more higher-order polymorphism - CiteSeerX
15:05:40 <lispy> ddarius: nice timing, thanks :)
15:06:05 <Pillager37> im trying to learn me a haskell
15:06:26 <sutats> vixey: Hm, I forgot about that problem.
15:07:00 <Cale> sutats: yeah, I left out the base case there
15:07:18 <sutats> vixey: How can I restrict the next to everything except for the opposite?
15:07:22 <Cale> (it was just a sketch, I didn't actually run it or anything ;)
15:07:46 <sutats> Cale: Yeah, vixey helped me fill that in. I'm still running into the issue of North followed by South and infinitely looping.
15:07:49 <Pillager37> momma says monads are private
15:07:49 <vixey> sutats, I'll let you figure it out :p
15:07:53 <Cale> sutats: Oh, one way is to modify the maze as you go
15:08:05 <Cale> sutats: Another is to maintain a Set of visited locations.
15:08:16 <Cale> sutats: and guard to ensure that next is not in that set
15:09:06 <sutats> Cale: Hm...this solution doesn't seem that much simpler than what I had before.
15:09:21 <Pillager37> http://learnyouahaskell.com/brain.png thinking recursively
15:09:36 <Philonous> I'm wondering what - in a GADT "Abc x where AbcInt :: x -> Abc Int" - the value AbcInt "hello world!" actually is. I can't pattern match over that and I'm kind of confused about how this looks like internally
15:10:01 <vixey> you can pattern match it
15:10:04 <Cale> Philonous: You can...
15:10:14 <vixey> so you actually have to put type annotations with GADTs
15:10:21 <vixey> at least as far as I can tell you do
15:10:26 <vixey> but anyway, you could write
15:10:34 <vixey> getX :: AbcInt x -> x
15:10:37 <lispy> Philonous: the type of the GADT looks very general, but the constructors of the GADT constrain which types x can take on in practice
15:10:41 <vixey> oops
15:10:44 <vixey> getX :: Abc x -> x
15:10:48 <vixey> getX (AbcInt x) = x
15:10:55 <hackage> Uploaded to hackage: unix 2.3.1.0
15:10:55 <hackage> Uploaded to hackage: template-haskell 2.3.0.0
15:10:55 <hackage> Uploaded to hackage: random 1.0.0.1
15:10:55 <hackage> Uploaded to hackage: pretty 1.0.1.0
15:10:55 <hackage> Uploaded to hackage: packedstring 0.1.0.1
15:11:00 <vixey> oh sorry that's complete rcap
15:11:07 <Pillager37> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
15:11:13 <vixey> thath would only work if you have  AbcInt :: x -> Abc x
15:12:19 <Cale> Pillager37: Try to keep things appropriate here ;)
15:12:28 <sutats> Cale: So I can make a [Coordinate], and guard with (elem ...)?
15:12:30 <Pillager37> Cale, http://learnyouahaskell.com/higher-order-functions
15:12:30 <lambdabot> Title: Learn You a Haskell for Great Good! - Higher Order Functions
15:12:33 <Pillager37> lol
15:12:46 <Pillager37> the guy who made that is insane
15:12:52 <Cale> Pillager37: It's BONUS
15:13:02 <Cale> (he's right here ;)
15:13:04 <Pillager37> aka gayballs
15:13:14 <jml> it's a pretty good tute
15:13:16 <Cale> Hm?
15:13:24 <jml> Cale: are you the author?
15:13:30 <mikezackles> Is there any way to limit the amount of memory ghc uses while compiling?
15:13:35 <skorpan> i think that's what haskell needs right now... some chunky bacon.
15:13:39 <Cale> jml: No, I just said the author is BONUS.
15:14:09 <Pillager37> reminds me of this   http://poignantguide.net/ruby/chapter-1.html
15:14:11 <jml> Cale: oh sorry, I thought you were using some sort of 90s surfer slang to praise the tute :)
15:14:17 <lambdabot> Title: whyâs (poignant) guide to ruby :: 1. About this Book
15:14:40 <Cale> jml: hehe, okay :)
15:15:13 <Pillager37> what kind of things can haskell be used for
15:15:25 <Cale> Pillager37: What kind of things can C++ be used for?
15:15:45 <Pillager37> no haskell
15:15:47 <vixey> Pillager37: generating fibonacci numbers and calculating factorial
15:15:52 <Cale> Pillager37: It's a general purpose programming language. You can use it for anything that you can use any programming language for.
15:15:53 <Pillager37> vixey, lol
15:16:05 * yitz anticipates that the FAQ will be invoked any second now
15:16:08 <Philonous> @faq Can Haskell iron my shirts?
15:16:08 <lambdabot> The answer is: Yes! Haskell can do that.
15:16:16 <lispy> Pillager37: http://www.haskell.org/pipermail/haskell-cafe/2008-November/050611.html
15:16:17 <lambdabot> Title: [Haskell-cafe] What is Haskell used for?, http://tinyurl.com/6astld
15:17:09 <fynn> (it would be more useful if the error messages were more informative)
15:17:12 <Cale> Pillager37: In industry, its main areas of popularity right now are in financial modelling and military applications involving cryptography and security.
15:17:14 <Pillager37> how can i find the underlying connection between fibonacci, pi, and the golden mean/ratio
15:17:27 <fynn> Pillager37: #math ?
15:17:32 <idnar> where does unsafeCoerce# come from?
15:17:36 <yitz> @go fibonacci
15:17:39 <lambdabot> http://en.wikipedia.org/wiki/Fibonacci_number
15:17:39 <lambdabot> Title: Fibonacci number - Wikipedia, the free encyclopedia
15:18:04 <Cale> Pillager37: As far as I know the golden ratio and pi are not directly connected. The ratio of adjacent Fibonacci numbers tends to the Golden ratio though.
15:18:16 <idnar> oh, GHC.Exts
15:18:19 <Pillager37> oh i mean primes
15:18:22 <idnar> also, ghci doesn't seem to like that name very much
15:18:25 <Pillager37> not pi
15:18:38 <Cale> Primes? Not in any sensible way either.
15:19:10 <vixey> > exp (sqrt (-pi*pi) :: Complex)
15:19:11 <lambdabot>       `Complex' is not applied to enough type arguments
15:19:11 <lambdabot>      Expected kind `?...
15:19:15 <lispy> Pillager37: I answer your question in that email thread I linked to.
15:19:17 <vixey> > exp (sqrt (-pi*pi) :: Complex Rational)
15:19:18 <lambdabot>       No instance for (RealFloat (Ratio Integer))
15:19:18 <lambdabot>        arising from a use o...
15:19:25 <vixey> > exp (sqrt (-pi*pi) :: Complex CReal)
15:19:27 <lambdabot>   (-1.0) :+ 0.0
15:19:36 <Cale> Though there are conditions on when Fibonacci numbers will happen to be prime.
15:19:37 <lispy> Pillager37: by looking at hackage we can see what people use Haskell for without speculating
15:19:41 <idnar> e^(pi)(i) + 1 = 0
15:19:48 <vixey> > e^(pi)(i) + 1 = 0
15:19:50 <lambdabot>   <no location info>: parse error on input `='
15:19:58 <Pillager37> whats the longest haskell program
15:20:33 <Cale> Pillager37: If F_n is prime, then n must be as well.
15:20:43 <lispy> > "module LongHaskell where a = [" + fix show
15:20:43 <lambdabot>       No instance for (Num [Char])
15:20:43 <lambdabot>        arising from a use of `+' at <inter...
15:20:47 <lispy> > "module LongHaskell where a = [" ++ fix show
15:20:48 <lambdabot>   "module LongHaskell where a = [\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\...
15:20:52 <Cale> > exp (0 :+ pi) + 1
15:20:54 <lambdabot>   0.0 :+ 1.2246467991473532e-16
15:21:04 <lispy> Pillager37: that's a very long haskell program I just wrote...
15:21:06 <Cale> IEEE floating point fail :)
15:21:34 <idnar> @type (:+)
15:21:35 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
15:21:42 <vixey> lol
15:21:42 <Cale> Pillager37: GHC is a fairly large Haskell program.
15:21:48 <lispy> Pillager37: the longest one I know of is BlueSpec (a hardware description language)
15:21:51 <Pillager37> do any people hack haskell just because they are nerds
15:21:52 <luite> hm, the error is quite large
15:22:03 <Cale> Pillager37: I do.
15:22:08 <Botje> i believe Pillager37 is unsuccessfully trying to troll
15:22:09 <Pillager37> so what do you use it for
15:22:09 * lispy now assums that Pillager37 is in fact a troll or a troll bot
15:22:12 <Botje> poor Pillager37.
15:22:34 <sclv> how do I shot trolling?
15:22:47 <vixey> nerds is my favorite sweet
15:22:49 <Pillager37> Cale, so what do you use it for
15:22:52 <yitz> Pillager37: haskell is mainly used to generate interesting discussion on #haskell, and to feed lambdabot.
15:22:52 <mm_freak_> mhâ¦  isn't there any way to retrieve the version field from the cabal file, so i can display the program version number without having to repeat it in the code?
15:22:54 <lispy> What is the longest troll?
15:22:55 <Cale> Pillager37: I use Haskell mostly to play around with mathematical ideas, and to help me think about approaches to programming in general.
15:23:05 <vixey> @wiki Nerds (Candy)
15:23:05 <lambdabot> http://www.haskell.org/haskellwiki/Nerds_(Candy)
15:23:11 <Cale> Pillager37: In the past, I've used it for more practical things.
15:23:14 <TomMD> ... and some people use it to earn a living
15:23:15 <CosmicRay> I solve business problems in haskell.
15:23:25 <TomMD> I use haskell to give meaning to life.
15:23:28 <Pillager37> Cale, i see, are you a math major...tell me about the practical things or link me to your site plz
15:23:34 <Cale> Pillager37: I wrote a pipeline scheduler for PPC assembly in Haskell, as part of a compiler for a signal processing language.
15:23:47 <Pseudonym> Haskell _is_ life.
15:23:51 <Pseudonym> Or, at least, it add life.
15:23:57 <Pseudonym> Also things go better with Haskell.
15:24:02 <Cale> (and Altivec)
15:24:11 <lispy> Haskell cured my male pattern baldness
15:24:11 <CosmicRay> Pillager37: I wrote a podcast downloader, a gopher spider, a media indexer, a database interface, etc. in haskell.
15:24:29 <Pillager37> CosmicRay, do you share your source?
15:24:31 <CosmicRay> lispy: will ghc 6.12 cure female-pattern baldness?
15:24:39 <TomMD> And SPJ wrote Haskell in Haskell.
15:24:41 <Cale> Pillager37: Though I think they ended up replacing it with a different scheduler in the end, that project is still ongoing. It's called Coconut.
15:24:46 <sclv> pillager: dude, seriously, just go to hackage
15:24:47 <CosmicRay> Pillager37: of course.  http://software.complete.org/
15:24:57 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
15:25:00 <Cale> ^^ Hackage.
15:25:02 <lambdabot> Title: HackageDB: packages by category
15:25:04 <lispy> And I heard that the researchers who used stem cell treatment recently to cure AIDS in one patient used Haskell.  Therefore Haskell cures AIDS (okay, I made that up, they did cure AIDS but they didn't use Haskell afaik)
15:25:15 <CosmicRay> Pillager37: also what Cale said.  all my stuff is on Hackage too, along with plent others
15:25:25 <Pseudonym> lispy: BUt I think your point is proven nonetheless.
15:25:28 <lispy> CosmicRay: we can hope
15:26:03 <Cale> There are too many packages on Hackage already :)
15:26:29 <TomMD> Cale: I agree - we need a 'sub-packages' page and the larger 'meta-packages' should be the entry point.
15:26:41 <yitz> Cale: there can never be too many packages on hackage. But they do need to be organized better.
15:26:44 <Cale> TomMD: I just mean from the standpoint that I'll never learn them all.
15:26:45 <lispy> Pseudonym: I should check
15:26:52 <lispy> ?FAQ can Haskell cure the AIDS?
15:26:52 <lambdabot> Unknown command, try @list
15:27:01 <mm_freak_> yitz: there canâ¦  if you have 100 packages doing (effectively) the same, that would suck
15:27:05 <lispy> ?faq can Haskell cure the AIDS?
15:27:05 <lambdabot> The answer is: Yes! Haskell can do that.
15:27:15 <lispy> Pseudonym: I guess it depends on how you ask...
15:27:26 <Cale> I'm not as interested in using Haskell to solve actual problems as I am interested in using it as a tool to learn about programming.
15:27:48 <Pseudonym> Cale is the amateur version of Dijkstra.
15:27:50 <Cale> Therefore, every library I don't end up studying is a library I could do without ;)
15:27:57 <Pseudonym> Theoretical programmer.
15:28:03 <mm_freak_> Cale: do you think that other languages are more appropriate, or is it just that you don't encounter many problems that require a general purpose language?
15:28:03 <CosmicRay> Cale: I'm interested in both.  in fact, I find it difficult to do either of those without simultaneously doing the other.
15:28:22 <Philonous> Could it be that I can simulate existential types with GADTs?
15:28:24 <Cale> mm_freak_: hm?
15:28:30 <yitz> mm_freak_: to select among packages, you need projects like the Library project. (and then meta-Library projects, etc., if there are too many of those)
15:28:33 <vixey> Philonous, yeah
15:28:36 <Cale> mm_freak_: It's not that I'm solving real world problems in some other language.
15:28:46 <Cale> mm_freak_: It's just that I'm not solving real world problems. :)
15:28:50 <lispy> Philonous: data Foo a where Foo :: x -> Foo a
15:28:55 <mm_freak_> Cale: ok =)
15:28:55 <Cale> If I did, I would use Haskell of course :)
15:28:56 <lispy> Philonous: x is existential
15:29:02 <bbs> can someone explain this to me line by line -- i found it else where and want to understand the semantics
15:29:06 <bbs> gr2 = map (uncurry (/)) . iterate (\(x,y)->(y,y+x)) $ (0,1)
15:29:07 <yitz> but hackage is a place for people to publish anything they think might be useful to someone - even near-dupes.
15:29:23 <sclv> Cale: while yr. getting bombarded with questions, what makes haskell better for thinking about programming than e.g. agda or epigram?
15:29:31 * skorpan is really looking forward to the LYAH tutorial on monads
15:29:38 <Philonous> lispy: Don't I need to add a type constraint on x to make it existential?
15:29:43 <Cale> sclv: Oh, it's not specifically better for thinking about programming than those.
15:29:46 <sclv> Since most mathematics types tend to go the other way.
15:29:49 <Philonous> In the constructor, that is
15:29:51 <Pillager37> i dont know
15:30:00 <necroforest> the best language for thinking about programming is QBASIC
15:30:00 <yitz> skorpan: you mean LYAHFGG?
15:30:01 <sclv> i.e. to think those condition better thinking than haskell.
15:30:04 <Pillager37> haskell kinda WEIRD
15:30:13 <skorpan> yitz: that one indeed
15:30:14 <sclv> just kinda?
15:30:14 <mm_freak_> bbs: take (0,1), apply 'iterate (\(x,y)->(y,y+x))' to it, which generates the list of pairs of subsequent fibonacci numbers
15:30:25 <mm_freak_> then apply:  map (uncurry (/))
15:30:34 <mm_freak_> i.e. take the quotient of those pairs
15:30:52 <bbs> mm_freak_: thx
15:31:01 <Cale> sclv: Agda and Epigram are wonderful languages to think about programming with. But their type systems are a bit *too* strong for me. I prefer the majority of types to be inferrable.
15:31:11 <bbs> mm_freak_: another question
15:31:23 <bbs> this makes the golden ratio's inverse
15:31:53 <bbs> however when i swap the (0,1) -- to (1,0) -- it doesn't give me the inverse
15:31:55 <bbs> why is that?
15:31:57 <Philonous> Ah, never mind
15:32:01 <Cale> Pillager37: It wouldn't be worth learning if it was the same as other languages.
15:32:22 <mm_freak_> bbs: because the first thing you'd do is to calculate 1/0, which fails =)
15:32:31 <Cale> (Weird is good)
15:32:43 <sclv> I guess Haskell : Agda :: Python : Java
15:33:03 <vixey> what/
15:33:05 <sclv> (less safety, more ability to experiment)
15:33:07 <vixey> No I don't think so
15:33:10 <vixey> at all
15:33:14 <skorpan> agda blew my brain up, i will never try that again
15:33:17 <mm_freak_> bbs: but if you drop the first element of the resulting list, you'd end up with just the same list
15:33:20 <vixey> You can experiment with Agda
15:33:29 <vixey> It is actually a ridiculous argument that types get in the way
15:33:31 <Pillager37> Cale, and i thought ruby was weird
15:33:31 <GNU\caust1c> is it correct to say that a constructor for a datatype is a function?
15:33:40 <vixey> (they o not)
15:33:46 <mm_freak_> if you want to calculate the inverse, you'll have to flip (/) first:  map (uncurry $ flip (/))
15:33:53 <lispy> GNU\caust1c: yeah
15:33:58 <sclv> writing a monad transform in agda is hard though, yeah?
15:34:08 <GNU\caust1c> ok, thanks
15:34:28 <sclv> so if you want to play with difft. sorts of mathematical ideas and not worry about bottom and other things, then its easier in haskell?
15:34:47 <sclv> (monad transformers just being one example of things where the formalization process is sort of painful)
15:34:54 <Pillager37> http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=ghc&lang2=icpp
15:34:56 <lambdabot> Title: mandelbrot Haskell GHC program | Gentoo : IntelÂ® PentiumÂ® 4 Computer Language  ..., http://tinyurl.com/58xxzc
15:35:20 <mm_freak_> bbs: a cleaner solution than flipping would be to use the 'recip' function:  map (reciprocal . uncurry (/))
15:35:30 <mm_freak_> but this will be slowerâ¦  so use that only if speed is of concern
15:35:57 <mm_freak_> and in either case, you'll have to drop the first element, because it will be 1/0
15:36:13 <bbs> mm_freak_: what lib is that in
15:36:15 <bbs> Data.List?
15:36:18 <endusr> Hrm, so in list comprehension/predicate filtering, the right-hand side is evaluated first, before the second-hand side?
15:36:26 <mm_freak_> bbs: Prelude
15:36:53 <bbs> jtDONEproject3.hs:57:11: Not in scope: `reciprocal'
15:36:56 <DustyDingo> hm, i want to write some tests for module i created something like hugs in batch mode,... any ideas how to do that?
15:36:58 <bbs> mm_freak_: ^
15:37:02 <mm_freak_> bbs: recip, sorry
15:37:07 <bbs> DustyDingo: why aren't you frisky dingo
15:37:09 <yitz> endusr: the stuff to the left of the bar is last. everything else left to right.
15:37:47 <bbs> mm_freak_: shibby
15:37:47 <bbs> thx
15:37:58 <bbs> mm_freak_: whats the $
15:38:07 <mm_freak_> function application, as always =)
15:38:10 <sutats> :t (//)
15:38:11 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
15:38:11 <bbs> figured
15:38:12 <bbs> thx
15:38:17 <bbs> :t $
15:38:18 <lambdabot> parse error on input `$'
15:38:20 <bbs> lol
15:38:25 <sutats> bbs: :t ($)
15:38:26 <bbs> :t (\)
15:38:28 <lambdabot> parse error on input `)'
15:38:30 <mm_freak_> f . g . h . i $ x = (f . g . h . i) x
15:38:33 <endusr> yitz: Ah, okay. And '/=' == '!=' here too?
15:38:37 <bbs> :t ($)
15:38:38 <lambdabot> forall a b. (a -> b) -> a -> b
15:38:40 <bbs> yea
15:38:46 <bbs> neat
15:38:58 <mm_freak_> f $ x = f x
15:38:59 <yitz> endusr: yeah, the predicates can be any expression returning a Bool.
15:39:03 <Pillager37> well you freaks scared off another girl
15:39:13 <mm_freak_> but it's most useful, if you have a bunch of functions composited
15:39:43 <endusr> yitz: Thanks.
15:39:46 <bbs> mm_freak_: you mean like
15:39:59 <bbs> a . b . c . g . e $ someshit
15:40:09 <mm_freak_> yeah
15:40:18 <bbs> kk
15:40:24 <bbs> mm_freak_: is that mm for akpm mm patchset?
15:40:24 <bbs> jw
15:40:56 <mm_freak_> worst: a (b (c (g (e someshit)))), better: a $ b $ c $ g $ e someshit, even better:  a . b . c . g . e $ someshit
15:41:00 <lispy> ?index Text.XML.Light
15:41:00 <lambdabot> bzzt
15:41:02 <mm_freak_> no =)
15:41:03 <lispy> hmm
15:41:14 <mm_freak_> 'mm' has no meaning really
15:41:15 <bbs> mm_freak_: k =) and thx for your attention i appreciate it
15:41:25 <bbs> its just like
15:41:28 <bbs> pillsbury
15:41:30 <bbs> mmm mmm good
15:42:18 <mm_freak_> you're welcome
15:43:13 <bbs> heh
15:43:19 <bbs> mm_freak_: want to see the whole thing
15:43:23 <bbs> i'm proud of it
15:43:28 <lispy> anyone know what provides Text.XML.Light?
15:43:42 <ddarius> Holy crap.  This person is actually going through the Euclidean construction of ring structure on a line.
15:43:46 <mm_freak_> bbs: if you want to share it, and it's not big, paste it =)
15:43:47 <lispy> xml I guess
15:43:53 <profmakx> lispy  xml
15:43:55 <profmakx> yep
15:43:59 <lispy> thanks
15:44:01 <mm_freak_> if it's big (and useful), turn it into a package and upload it to hackage =)
15:44:27 <bbs> hell no its now
15:44:29 <bbs> not
15:44:36 <bbs> its the most useless project ever
15:44:40 <bbs> showing why haskell is lazay
15:44:43 <bbs> http://hpaste.org/12114
15:44:44 <bbs> lol
15:44:50 <bbs> i wish it were
15:45:20 <Cale> See, if you were writing this in a strict language like O'Caml or something, this trick with functions would be meaningful.
15:45:29 <mm_freak_> bbs: i recommend adding type signaturesâ¦  it makes code much cleaner and clearer
15:45:44 <Cale> In Haskell, the value returned by applying functions to () is still going to be a thunk anyway.
15:45:54 <endusr> does lambdabot have multi-channel capabilities?
15:45:55 <yitz> it also makes error messages cleaner and clearer
15:46:07 <Cale> So functions from () are kind of silly.
15:46:33 <Cale> bbs: 1 isn't prime.
15:46:34 <Pseudonym> No, they're points.
15:46:44 <bbs> mm_freak_: kk
15:46:54 <bbs> Cale: :D
15:46:57 <sclv> awww... I hearts the hamming
15:46:57 <Pseudonym> Functions from () are very useful!
15:46:57 <bbs> shhhhhhhhhh
15:47:11 <mm_freak_> bbs: i don't understand your Seq type
15:47:14 <bbs> just because 1 is a whore
15:47:18 <bbs> i just wated to add him in
15:47:23 <mm_freak_> should it be a strict Seq?
15:48:03 <sclv> Streaming hamming -- great algorithm, or THE GREATEST algorithm?
15:48:05 <Cale> Elements which are invertible are not allowed to be prime.
15:48:22 <yitz> @seen lambdabot
15:48:22 <lambdabot> Yes, I'm here. I'm in #macosxdev, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
15:48:22 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #
15:48:22 <lambdabot> dreamlinux-es, #darcs, #concatenative, #arch-haskell, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
15:48:31 <Cale> I think the Euclidean algorithm is up there for greatest algorithm.
15:48:38 <yitz> endusr: that answer your question?
15:48:42 <Pseudonym> BTW, if it helps, one other reason why 1 isn't prime is because otherwise, you'd have to allow the trivial field.
15:48:48 <mm_freak_> bbs: btw, you should unlearn that 'f(x)' notation =)
15:48:55 <mm_freak_> we're curry fans here
15:48:58 <mm_freak_> f x
15:49:05 <sutats> How do you make (Int, Int) into [(Int, Int)] with just that one element?
15:49:17 <Cale> sutats: In the list monad, return
15:49:18 <byorgey> sutats: with the robot monkey operator!  (:[])
15:49:22 <fynn> why is lambdabot in so many channels?
15:49:23 <Cale> sutats: Or (:[])
15:49:30 <sclv> I want a sexy algorithms wall calendar
15:49:31 <Pseudonym> fynn: She's very social.
15:49:33 <Cale> fynn: Because people request it to join them.
15:49:34 <mm_freak_> or by simply putting it in []
15:49:42 <sutats> byorgey: Thought so, but that didn't seem to do the trick for me.
15:49:45 <Pseudonym> @vixen You're social, right?
15:49:45 <lambdabot> yup, right on
15:49:48 <Pseudonym> See?
15:49:49 <mm_freak_> makeSingletonList x = [x]
15:49:54 <byorgey> > (:[]) (4,5)
15:49:55 <lambdabot>   [(4,5)]
15:50:03 <Pseudonym> mm_freak: That's traditionally been called "box".
15:50:13 <bbs> Cale: 2,3,4,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67
15:50:13 <Twey> makeSingletonList = return
15:50:17 <bbs> why the hell is 4 there now
15:50:17 <bbs> lol
15:50:19 <mm_freak_> Pseudonym: that long name should be sarcastic
15:50:20 * bbs sighs
15:50:28 <Twey> Heh
15:50:29 <mm_freak_> Twey: nope, that's too general to be called *List =)
15:50:34 <Pseudonym> But yes, return and the robot ninja monkey operator are more usual.
15:50:35 <sutats> byorgey: Yeah, I must be doing something else wrong.
15:50:48 <Cale> bbs: Not checking the square root as a factor?
15:50:50 <Twey> *Fine*
15:51:03 <Twey> makeSingletonList :: a -> [a]; makeSingletonList = return
15:51:05 <sclv> oh now its a ninja too?
15:51:08 <bbs> Cale: nah -- its in there
15:51:10 <Twey> :-P
15:51:10 <bbs> i'm just using it wrong
15:51:10 <mm_freak_> bbs: http://hpaste.org/10892
15:51:11 <bbs> hmm
15:51:14 <sutats> Cale: http://hpaste.org/12106#a1 is my attempt at trying to replace already visited nodes with another type. Can you critique and possible clean up/fix the code?
15:51:17 <mm_freak_> see the 'primes' and 'isPrime' function
15:51:31 <sw17ch> Is there any way to have type classes accept types with multiple kinds?
15:51:39 <sw17ch> or different kinds
15:51:47 <Cale> bbs: btw,  and . map f = all f
15:51:53 <sw17ch> and/or make instances of multiple kinds
15:51:57 <bbs> Cale: ?
15:52:04 <mm_freak_> Cale: yeah, i already corrected it in my local code
15:52:18 <mm_freak_> the paste is old
15:52:22 <Cale> Oh, duh, that's mm_freak_'s code ;)
15:53:03 <Cale> sutats: what is this line for? maze // (here, Solution):[]
15:53:42 <Cale> sutats: I suspect that doesn't do anything close to what you want it to.
15:53:44 <bbs> Cale: can i call 0 prime
15:53:45 <bbs> lol
15:53:47 * bbs hopes so
15:53:47 <Cale> bbs: no.
15:53:51 <bbs> damnit
15:53:56 <sutats> Cale: The intention there was to change the visited node to a Solution node, so validLocation won't choose it again. It's probably wrong.
15:53:59 <Cale> bbs: 0 and units are not allowed to be prime.
15:54:01 <bbs> well then wtf am i supposed to do
15:54:23 <Cale> sutats: You pass the original maze on to the recursive call still though.
15:54:28 <jdrake_> Can anyone give any perspective on the haskell frame (bottom left): http://curtis.lassam.net/comics/programmers.png
15:54:38 <Cale> sutats: I would change it to a Wall myself.
15:54:43 <mm_freak_> btwâ¦  consider a function 'f', which has a probabilistic result, but which is very unlikely (like one out of 2^128) to give a wrong result, and which may never return a wrong result, depending on some unproven mathematical theorem (like the miller-rabin primality test), would you put this function in IO?
15:55:02 <sclv> ?quote sigfpe prime
15:55:02 <lambdabot> sigfpe says: It's like deciding that the prime numbers bigger than 20 are interesting for some reason, and then choosing to name them "the primes".
15:55:10 <Cale> jdrake_: I suspect the joke is that there aren't any.
15:55:27 <sutats> Cale: Okay, I might make it a Wall, but how do I take care of that change actually taking effect for future calls?
15:55:32 <BONUS> mm_freak: sure!
15:55:34 <ivan> haskell programmers are ninjas
15:55:43 <jdrake_> Cale, hmm, I missed that :p
15:55:45 <Cale> sutats: Pass the modified maze to the recursive call to solve
15:56:01 <Cale> sutats: The original maze still exists. Values in Haskell are immutable.
15:56:02 <mm_freak_> BONUS: that makes the function inconvenientâ¦  i think, i'll write two versions
15:56:06 <mm_freak_> isPrime and unsafeIsPrime
15:56:32 <Cale> mm_freak_: I would make it take a StdGen as a parameter.
15:56:39 <jdrake_> But maybe its because I see 505 people in here and that is comparable to any other major programming language :p
15:56:44 <Cale> mm_freak_: Or put it in the Rand monad.
15:56:52 <sutats> Cale: Hm, so do I create a new array and pass that somehow?
15:57:04 <baaba> mm_freak_, it's still a pure function though?
15:57:04 <Cale> mm_freak_: Alternately, I would create a fixed StdGen and pass that in.
15:57:07 <Twey> jdrake_: Common misconception.  :)
15:57:08 <sclv> zero is like the anti-prime! its evenly divisible by everything *except* itself
15:57:12 <ivan> jdrake_: it means everyone is tired of their non-haskell programming language
15:57:14 <BONUS> if the chance is that small, the programmer using that has a better chance of being hit by lightning
15:57:26 <baaba> even if the answer is wrong why would world state be relevant?
15:57:26 <lilac> jdrake_: the difference is, a very high proportion of the people who know haskell are probably in this channel
15:57:39 <mm_freak_> Cale: hmmâ¦  the Rand idea is good
15:57:40 <lilac> (compared to other languages)
15:57:43 <sclv> lilac: you'd be surprised
15:57:44 <Cale> A prime p in a commutative ring R is a nonzero, nonunit element of R such that whenever p | ab then p | a or p | b.
15:57:49 <mm_freak_> baaba: it's 'almost pure'
15:58:03 <yitz> mm_freak_: why should miller-rabin be in IO?
15:58:11 <mm_freak_> in that it practically returns the right result, but may fail with a very low probability
15:58:16 <mm_freak_> yitz: because it's probablistic
15:58:16 <Twey> It's completely pure
15:58:20 <baaba> mm_freak_, yeah but it's still a pure function
15:58:33 <Twey> mm_freak_: That's got nothing to do with the state of the world, though
15:58:35 <baaba> mm_freak_, for any input x you will get the same result each time
15:58:37 <ivan> i think you have a greater chance of a double bit flip in your ECC memory than your 1/2^128
15:58:41 <mm_freak_> yeah, sure, if you pass a random number generator, then it's pure
15:58:42 <Twey> It's based entirely on inputs.
15:58:43 <baaba> whether it's "right" or "wrong"
15:58:43 <Cale> It's a completely pure algorithm which depends on the initial random seed, and the number of iterations of refinement.
15:58:54 <sclv> it should be in a probability monad!
15:58:56 <yitz> mm_freak_: it never fails. It always returns the same result. It's not the function's fault that you're not sure how to interpret the result.
15:58:57 <mm_freak_> but the impure version would be :: Integer -> Bool
15:59:11 <sclv> that keeps track of the accumulated probability of being totally wrong.
15:59:11 <lilac> ivan: that's assuming you /have/ ECC memory :)
15:59:26 <Twey> That's not impure
15:59:31 <mm_freak_> yitz: we don't know whether it always returns the correct result, because the generalized riemann hypothesis is unproven
15:59:32 <Cale> mm_freak_: Of course, the impure version also gets an initial random generator state from somewhere...
15:59:41 <Cale> mm_freak_: It's just a matter of where it gets it from.
16:00:09 <mm_freak_> Cale: the impure version could use an impure generator (like /dev/urandom), unless the generator itself uses something like unsafeInterleaveIO
16:00:29 <yitz> mm_freak_: it always returns the *same* result. so it's pure. whether or not that is the right answer doesn't affect whether it is pure.
16:00:38 <Cale> mm_freak_: right.
16:00:53 <mm_freak_> yitz: only if the generator is always the same
16:00:56 <Cale> mm_freak_: I think newStdGen should use /dev/random to get a seed.
16:01:07 <Cale> (and getStdGen should get bent)
16:01:41 <EmielRegis> can you use pthreads in haskell?
16:01:46 <mm_freak_> yeah, and there should be a cryptographically secure PRNG somewhereâ¦  even Crypto doesn't currently provide one
16:01:50 <Cale> EmielRegis: Why would you want to?
16:01:58 <EmielRegis> I'd like to thread my raytracer
16:01:58 <mm_freak_> EmielRegis: use concurrency
16:02:00 <Cale> EmielRegis: You can use forkOS
16:02:06 <Cale> EmielRegis: But forkIO is nicer.
16:02:10 <EmielRegis> and pthreads are surely the fastest thread library for linux
16:02:15 <EmielRegis> whats that?
16:02:16 <BONUS> really though. why hasnt anyone made a parallelism instance of arrows in haskell?
16:02:26 <Cale> EmielRegis: pthreads are slower than Haskell threads almost certainly.
16:02:31 <EmielRegis> does it create real threads? (as in, kernel-mode ones)
16:03:05 <Cale> forkOS makes OS threads. It's not necessary to use it unless you're doing FFI stuff and you need to ensure that a bunch of calls all come from the same OS thread.
16:03:06 <mm_freak_> EmielRegis: it does create real threads, if you use the threaded RTS (compile in GHC with -threaded), and you specify the number of threads it should use (see -RTS -N)
16:03:18 <Twey> EmielRegis: It does where appropriate
16:03:30 <EmielRegis> uhm
16:03:31 <Cale> forkIO makes Haskell threads, which are scheduled N:M onto real threads at runtime./
16:03:43 <EmielRegis> so there is no possiblity of dynamically allocating threads according to number of CPUs?
16:03:52 <sutats> Cale: I think I'm lost, but here's my attempt at what you meant: http://hpaste.org/12106#a2 .
16:03:56 <mm_freak_> EmielRegis: http://www.haskell.org/haskellwiki/GHC/Concurrency
16:03:58 <lambdabot> Title: GHC/Concurrency - HaskellWiki
16:04:08 <Cale> sutats: see path <- solve maze end next
16:04:11 <Twey> EmielRegis: -threaded does that for you
16:04:24 <Cale> sutats: that "maze" is the same "maze" as you passed to the function
16:04:32 <mm_freak_> and you'll get very convenient inter-thread communication for free =)
16:04:35 <sutats> Cale: Right, I changed that in my annotated version.
16:04:37 <yitz> Cale: you mean /dev/urandom. yeah, it should, when available.
16:04:39 <Cale> sutats: If you want it to be different, then put a different value in that spot :)
16:04:41 <EmielRegis> Cale, N:M...? how is that possible, if linux kernel has 1:1 model since 2.6 (nptl library)
16:04:48 <Cale> sutats: yeah
16:04:48 <EmielRegis> unless you mean running on unix?
16:04:50 <Axman6> Cale: if you were using one thread to write stuff to disk, would it be a good idea to forkOS that? or is forkIO fine
16:04:55 <ivanm> what's the point of having an electronic version of RWH available for purchase? or is this because there's no downloadable copy of the entire book?
16:05:07 <sutats> Cale: But I'm not sure if I did it correctly (actually, I'm sure it's wrong, since it doesn't compile).
16:05:11 <Cale> EmielRegis: Haskell threads are handled by the GHC runtime.
16:05:18 <Cale> EmielRegis: Which contains an N:M scheduler.
16:05:22 <Adamant> jdrake: Perl programmers are wrong and so are Haskell programmers. not sure what you should use for Perl, but for Haskell you should just have a picture of the Simons
16:05:33 <Adamant> and Oleg
16:05:34 <Twey> EmielRegis: Because not all of them become OS threads.
16:05:43 <Cale> Axman6: I would use forkIO
16:05:46 <Twey> Haha
16:05:47 <mm_freak_> EmielRegis: if you have 16 haskell threads and 2 CPUs, then 2 threads are running in parallel, so statistically 8 haskell threads share a single CPU
16:05:53 <Axman6> righto :)
16:05:53 <yitz> And StdGen should be updated to something more modern.
16:05:55 <Pseudonym> For Haskell, you should have the axioms of intuitionistic logic.
16:05:58 <Cale> In fact, I would never use forkOS unless absolutely forced to.
16:06:01 <Pseudonym> And gaze upon them periodically.
16:06:13 <mm_freak_> EmielRegis: and there is no problem with creating more threads than there are CPUs, because the runtime takes care of the scheduling
16:06:44 <EmielRegis> hmm
16:06:53 <Cale> Also, the number of OS threads to create to run Haskell code on is set by the RTS -N option.
16:07:04 <mm_freak_> in fact, it's perfectly acceptable and the right thing in haskell to write a server program, which creates one or more threads for each client
16:07:04 <lilac> Adamant: i thought the perl programmers one was quite apt. a guy with great power being the master of a mountain of spaghetti :)
16:07:05 <EmielRegis> so GHC has its own thread pool which then is translated into Kernel threads?
16:07:06 <Cale> (so that's practically the number of CPUs to use)
16:07:10 <Cale> EmielRegis: yes.
16:07:13 <EmielRegis> ah
16:07:34 <mm_freak_> EmielRegis: haskell's thread pool is more intelligent in factâ¦  it does IO scheduling properly
16:07:36 <EmielRegis> i guess thats not the fastest method but oh well ;)
16:07:36 <Cale> EmielRegis: You can use multithreaded Haskell code with only a single OS thread.
16:07:49 <Cale> EmielRegis: It's very fast in practice.
16:07:53 <Adamant> lilac: ah, I thought it was a meteoroid, not spaghetti
16:07:58 <Adamant> in that case it is apt
16:08:20 <Cale> EmielRegis: Haskell tends to do very well in concurrency benchmarks.
16:08:30 <EmielRegis> ah
16:08:56 <Twey> *Very* well
16:08:59 <EmielRegis> well, I read that generall N:M models dont go very well unless they are coded very complexly like in solaris kernel
16:09:03 <Cale> EmielRegis: It's also worth noting that not only does GHC support concurrency (and plenty of nice abstractions for that, such as STM), but pure parallelism as well.
16:09:08 <mm_freak_> EmielRegis: if you have pure operations, which don't use IO, it's best to create as many haskell threads as there are CPUsâ¦  this will give you pthreads-like performance
16:09:12 <EmielRegis> but seems thats not the case ehre ;)
16:09:43 <Twey> AFAIK, Haskell is currently on the top of the Alioth concurrency benchmarks.
16:09:55 <Cale> If your computation is not concurrent, but parallel, use Control.Parallel.Strategies and/or the new Data Parallel Haskell stuff.
16:10:55 <hackage> Uploaded to hackage: augur 2008.11.17
16:10:55 <hackage> Uploaded to hackage: classify 2008.11.17
16:11:30 <sw17ch> rver irc.esper.net
16:11:42 <sw17ch> whoops
16:11:50 <Cale> Concurrency being the thing where you have multiple code pointers and the results are nondeterministic based on the order in which threads are scheduled (and not necessarily parallel, but possibly so), pure parallel being that you have deterministic results, but you want to compute more than one thing at once.
16:12:28 <EmielRegis> ah
16:12:43 <EmielRegis> im writing a raytracer, so I guess the latter is appropriate
16:13:25 <geezusfreeek> i tend to think of concurrency as parallel "more threads of control at once" and parallelism as "more data at once through one control path"
16:13:59 <Cale> Data Parallel Haskell might be very very nice for that, but it's very new, and possibly a bit underdocumented.
16:14:10 <Cale> (I'm not sure how well it's working as of yet.)
16:14:11 <geezusfreeek> it is definitely underdocumented ;)
16:14:18 <geezusfreeek> seems to work well for me
16:14:18 <EmielRegis> k
16:14:19 <EmielRegis> btw
16:14:28 <Cale> Otherwise, there's a primitive called par
16:14:29 <EmielRegis> is there a way to fight lazy evaluation in some way?
16:14:30 <EmielRegis> as in
16:14:39 <Cale> Oh, hehe, yes, there is :)
16:14:40 <geezusfreeek> DON'T FIGHT IT
16:14:44 <EmielRegis> i have a recursive code which converts my colours to string
16:14:47 <EmielRegis> and then writes to file
16:14:48 <Cale> (if you really need to)
16:14:51 <mm_freak_> i recently noticed that haskell's concurrency is very much leaned towards the Ï calculus
16:14:59 <EmielRegis> and so I see that the file is being written to in parts
16:15:11 <Cale> mm_freak_: Well, it satisfies reasonably nice algebraic properties...
16:15:25 <EmielRegis> and this is not very IO effective now, is it
16:15:48 <Cale> EmielRegis: hmm... writeFile and so on are strict.
16:15:55 <EvilTerran> sounds like buffering
16:16:02 <EmielRegis> oh
16:16:10 <EmielRegis> actually, it seems ive been using hPutStr before
16:16:16 <EmielRegis> and now with writeFile it doent do it anymore
16:16:17 <EmielRegis> ;)
16:16:20 <EvilTerran> ?hoogle setbuffering
16:16:20 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
16:16:25 <Cale> Yeah, and Handles are usually block buffered.
16:16:26 <EvilTerran> ?hoogle BufferMode
16:16:26 <lambdabot> System.IO data BufferMode
16:16:46 <Cale> So if you don't want that, you can turn it off with hSetBuffering as EvilTerran points out :)
16:16:57 <ddarius> mm_freak_: I wouldn't say Haskell's concurrency mechanisms lean toward the pi calculus.  Certainly not much more than most languages.
16:17:08 <Cale> You can't write a file lazily, because the OS doesn't have any notion of a thunk.
16:17:24 <Cale> (or an expression left to be evaluated)
16:17:31 <Cale> It would be very interesting if it did ;)
16:17:45 <Cale> You could have infinite files which were computed as you read them :)
16:17:57 <Cale> (and not just the ones in /dev
16:17:58 <Cale> )
16:17:59 <lunabotjs>  jseval: <stdin>: hGetLine: end of file
16:18:04 <Cale> haha
16:18:54 <yitz> /dev/zero
16:18:56 <Cale> EmielRegis: But as for fighting laziness (which is not what you're doing here), evaluating the expression seq x y causes x to be evaluated before the result of evaluating y is returned.
16:18:59 <sw17ch> Is there a way to make a type class and then have instances of differently-kinded parameters?
16:19:06 <mm_freak_> Cale: hmmâ¦  let's write an experimental FUSE filesystem =)
16:19:06 <EmielRegis> k
16:19:13 <mm_freak_> but i guess that wouldn't work as easily
16:19:16 <sw17ch> instance Foo (a,b) where ... instance Foo (a,b,c) where ...
16:19:50 <Cale> EmielRegis: And, for parallelism,  par x y  causes x to be put on a queue of things to be evaluated on some available processor thread if there's time available, before resulting in y.
16:19:54 <EvilTerran> sw17ch, all those types have kind "*"
16:20:04 <sw17ch> EvilTerran, ah... i was afraid of that :(
16:20:05 <EvilTerran> but to answer your question, no, as haskell has no kind polymorphism
16:20:12 <mm_freak_> sw17ch: if the class doesn't place any assumption on the kind, yes
16:20:15 <EvilTerran> why do you want to do this?
16:20:18 <idnar> @src unsafeCoerce
16:20:18 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:20:47 <EvilTerran> mm_freak_, i think it defaults to * if it's got no methods, and, if it's got methods, it can be inferred from that
16:20:50 <mm_freak_> EvilTerran: are you sure?  i think, i've seen kind variables
16:20:54 <sw17ch> EvilTerran: i'm trying to make a framework to setup TChan's between communicating threads automatically
16:21:05 <sw17ch> EvilTerran, Each thread has n input chans and n output chans
16:21:11 <Cale> EmielRegis: So, for example, in the recursive case of the naive fibonacci algorithm, you could write  fib n = x `par` y `seq` x + y where x = fib (n-1); y = fib (n-2)
16:21:22 <EvilTerran> sw17ch, of different typeS?
16:21:24 <sw17ch> EvilTerran, My thought was that i could define three operations on each n-tuple
16:21:41 <Cale> EmielRegis: (But that won't actually be very fast, because you'd really want to cut off the parallelism at a certain size.)
16:21:42 <sw17ch> EvilTerran, The TChan's would be of a specific type
16:21:53 <EvilTerran> in which case, why not have a list of TChans?
16:22:33 <sw17ch> EvilTerran, I wanted the compiler to typecheck the number of channels each thread has in/out
16:22:35 <Cale> EmielRegis: and of course, it's not as fast as doing it sequentially, in any case.
16:22:43 <EvilTerran> sw17ch, ahh, i see...
16:22:47 <Cale> EmielRegis: But you get the idea :)
16:22:57 <sw17ch> EvilTerran, http://hpaste.org/12115
16:23:04 <EvilTerran> sw17ch, well, the way that's normally done is more working from the "lists" end of that range of functionality than from the "tuples" end
16:23:04 <sw17ch> at the bottom, i have a function called runNeedle commented out
16:23:06 <Cale> (maybe with enough processors available, it could compete for a while)
16:23:40 <EmielRegis> aye
16:23:41 <EmielRegis> thanks
16:23:55 <Cale> mm_freak_: I would settle for a way to serialise any Haskell value without evaluating it.
16:24:16 <sw17ch> EvilTerran, The type signature for the "f" parameter is f :: (TChan a, .., TChan an) -> (TChan b, .., TChan bn)
16:24:38 <EvilTerran> sw17ch, for instance, if you're happy to use GADTs, "data Zero; data Succ n; data Vector n a where { Nil :: Vector Zero a; Cons :: a -> Vector n a -> Vector (Succ n) a
16:24:42 <Cale> mm_freak_: Another thing which would be really nice would be a way to turn an arbitrary IO action into an executable for the given platform.
16:24:55 <mm_freak_> Cale: you'd need to store code in the filesystem, or at least references to code
16:25:01 <daf> Cale: reminds me of the various mad process freezers that were floating around
16:25:03 <EvilTerran> ..." provides lists of n elements of type a, n fixed at compile-time
16:25:14 <Cale> mm_freak_: Well, just in the file :)
16:25:32 <daf> (that did things like stop processes, serialise their state, and let you move them to different machines and restart them)
16:25:42 <Cale> mm_freak_: Or, for that other idea involving lazy files, sure, you'd have to store code in the filesystem.
16:25:45 <mm_freak_> Cale: partially executable files =)
16:26:03 <EvilTerran> ?hackage Vec
16:26:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Vec
16:26:05 <mm_freak_> the idea is very interesting, indeed
16:26:08 <sw17ch> EvilTerran, hmmm...
16:26:11 <EvilTerran> sw17ch, have a look at that
16:26:15 <sw17ch> I haven't worked with GADT's before
16:26:19 <mm_freak_> but i think, nobody would use it productively
16:26:59 <Cale> mm_freak_: Another thing about filesystem design which has bothered me for a long time is the way that directories can have subfiles but no data, and files can have data, but no subfiles.
16:27:19 <chrisdone> Tip of the Day: In haskell, `readFile' means read a file into a string. In PHP, `readfile' means print it.
16:27:19 <Cale> mm_freak_: I would prefer there be no distinction. Why not allow data and subfiles in any node?
16:27:46 <mm_freak_> Cale: NTFS allows part of this sort of thing
16:27:58 <idnar> Cale: some filesystems do allow that, don't they?
16:28:03 <Cale> idnar: yeah
16:28:03 <yitz> Cale: that's the model in IMAP
16:28:10 <Cale> idnar: But not the ones which anyone uses.
16:28:17 <idnar> heh
16:28:36 <idnar> it's the web model anyway, I guess
16:28:41 <Cale> and I've never figured out how to actually get it working.
16:28:42 <mm_freak_> Cale: i think, quite a few people use NTFS =)
16:28:47 <idnar> but that assumption is encoded in so many places now, that it's a problem
16:28:58 <EvilTerran> i heard the FS that OSX uses supports that kinda thing now
16:28:59 <Cale> mm_freak_: How do I create a subfile of a file in NTFS?
16:29:08 <mm_freak_> through a bunch of APIs
16:29:14 <Cale> oh, see, that's boring.
16:29:21 <Cale> I want it to be user accessible.
16:29:22 <p_l> Cale: <path_to_file>:<subfile>
16:29:25 <EvilTerran> you can do it on the command-line too... let me check how it's done
16:29:29 <EvilTerran> ah, colon, that was it
16:29:31 <mm_freak_> wellâ¦  we're too late to incorporate that into existing operating systemsâ¦  they assume that a directory is a distinct structure
16:29:49 <Cale> Can't we create new versions of existing OSes?
16:29:49 <mm_freak_> we'd need to rewrite almost the whole coreutils and stuff
16:29:59 <sutats> How difficult would it be to actually implement an OS like this?
16:30:02 <p_l> mm_freak_: Because all hell breaks loose if you try to do this and still use filesystem and path abstraction
16:30:20 <mm_freak_> and the distinction between files and directories also has some advantagesâ¦  it's impossible to confuse the two
16:30:43 <mm_freak_> it makes things clearer
16:30:46 <Eelis> i fail to see the point
16:30:54 <Cale> mm... I'm not sure that it does.
16:30:57 <EvilTerran> tbh, the distinction between leaves and branches makes sense to me
16:30:58 <p_l> Basically, if you want more complexity, screw the filesystem model and go for "everything is a db"
16:31:15 <EvilTerran> "leaves have data, branches have more nodes"
16:31:27 <mm_freak_> Cale: for most people it does, and i think this is not related to habits
16:31:46 <p_l> the power of "filesystem as a graph, files as a stream of bytes" comes from it's simplicity
16:31:49 <mm_freak_> EvilTerran: good point
16:32:02 <EvilTerran> "files have data, folders have more nodes"
16:32:08 <Cale> It would, for example, be nice to have a document (like say an HTML document) whose embedded data (images etc.) were stored as subfiles of it.
16:32:35 <mm_freak_> or a directory with an index file and a bunch of other files
16:32:50 <Cale> It seems wrong for a hard-to-explain reason in cases like this to create a directory and place the document alongside the associated data.
16:32:52 <p_l> Cale: html_parser_fs <path-to-html-file> <mount point>
16:33:06 <inimino> Cale: Reiser4 had that
16:33:22 <Cale> inimino: Yes, I never got it to work.
16:33:26 <mm_freak_> Cale: which advantages would that have?
16:33:36 <p_l> Cale: It breaks certain assumptions
16:33:45 <mm_freak_> for example, how would you send such a file?
16:33:56 <p_l> Reiser4 to be exact breaks POSIX API
16:33:57 <Cale> mm_freak_: Well, since the file effectively contains the data that it needs, you don't accidentally separate them.
16:34:04 <inimino> though I prefer to take things in the other direction and have directories that only contain either directories or files
16:34:23 <Cale> mm_freak_: You send everything. Of course, programs need to be aware of it.
16:34:29 <mm_freak_> Cale: that applies to a directory with the HTML file and all auxilliary files, too
16:34:39 <EvilTerran> i've seen that done by just bundling the HTML and the aux files in a MIME file
16:34:48 <Cale> mm_freak_: Right, but programs are not aware in that case.
16:34:59 <Cale> (generally)
16:34:59 <p_l> Cale: That makes for a greater complexity in programs and greater chance for bugs
16:35:14 <mm_freak_> Cale: only because you can 'cd' into a directory
16:35:26 <mm_freak_> but that would require us to 'cd' into files
16:35:34 <Cale> p_l: The hope is that APIs are made available to, say, serialise a directory along with its data and all contents.
16:35:35 <mm_freak_> i think, it would make things even more confusing
16:35:51 <inimino> mm_freak_: there would be no "files" or "directories", just nodes
16:36:03 <Cale> right.
16:36:07 <mm_freak_> inimino: that's what i called 'files'
16:36:14 <p_l> Cale: That's called a packer, man 1 tar for example :P
16:36:19 <Cale> The distintion between file and directory would be how you want to think about it.
16:36:22 <Cale> p_l: Absolutely.
16:36:24 <inimino> and a trailing slash can be used to distinguish when necessary
16:36:29 <Cale> p_l: So programs could use that.
16:36:42 <p_l> Cale: What happens when you read a directory in a Unix system? :)
16:36:50 <Cale> p_l: and once bugs are eliminated from the packer, that's not a problem anymore
16:36:55 <Cale> p_l: hm?
16:36:57 <mm_freak_> Cale: i think, your problem isn't really related to filesystems, but rather to handling references between files
16:37:08 <mm_freak_> informal references, i mean
16:37:10 <p_l> Cale: Just checking :)
16:37:45 <FunctorSalad> how about archives? ;)
16:37:51 <mm_freak_> it would work, of course, but i really don't think it would make things any easier or cleaner
16:38:05 <p_l> *quiz* What do you get when you read a directory on Unix system? :)
16:38:15 <mm_freak_> p_l: an error =)
16:38:22 <p_l> mm_freak_: WRONG
16:38:23 <inimino> p_l: that depends on the OS :-)
16:38:25 <FunctorSalad> this 4096 byte thing? ;)
16:38:29 <p_l> inimino: Unix system
16:38:37 <p_l> FunctorSalad: WRONG
16:38:45 <idnar> you get the directory contents :P
16:38:46 <inimino> p_l: Unix contains multitudes
16:38:49 <FunctorSalad> :'-(
16:38:53 <mm_freak_> p_l: Nothing?
16:39:02 <endusr> True or False.
16:39:12 <p_l> internal fs structure describing the directory
16:39:13 <mm_freak_> Left err
16:39:26 <p_l> directories *are* files
16:39:29 <mm_freak_> hmm, makes sense
16:39:57 <p_l> it's just that in order not to make mess with different filesystems you get special api for listing their contents
16:40:11 <idnar> it's pretty hard to get stuff to read that data, though
16:40:23 <idnar> instead of getting EISDIR
16:40:31 <inimino> idnar: right
16:40:36 <endusr> p_l: So, when reading a directory, it doesn't return true or false?
16:40:41 <Cale> Another idea would be to have nodes which were typed values.
16:40:42 <p_l> it also sometimes makes some filesystem drivers barf when you make a read() call on a dir, but it's an error on the part of driver writer
16:40:52 <inimino> on Solaris you can cat them
16:40:58 <mm_freak_> Cale: this is the state of things
16:40:58 <idnar> you can't call read(2) on a directory, for example
16:41:05 <inimino> on Linux you can't
16:41:17 <p_l> Cause Linux is like a ball of mud
16:41:24 <Cale> mm_freak_: I mean, allow any algebraic type, say.
16:41:26 <endusr> p_l: So, when reading a directory, it doesn't return true or false?
16:41:35 <Cale> mm_freak_: Along with some primitive types.
16:41:42 <idnar> p_l: "it"?
16:41:44 <idnar> err
16:41:46 <idnar> endusr: "it"?
16:41:48 <mm_freak_> Cale: that would require each filesystem driver to be a haskell interpreter =)
16:41:50 <FunctorSalad> it does return when reading a directory
16:41:53 <Cale> mm_freak_: Sure.
16:41:56 <Cale> mm_freak_: Why not? :)
16:41:58 <Philonous> In some sort of database filesystem you could have files associated to other files and just query them
16:42:00 <mm_freak_> hehe
16:42:02 <p_l> endusr: on unix system a correct implementation would return the contents of the directory files
16:42:07 <p_l> *file
16:42:09 <inimino> well, there's little value in reading them if you can't rely on any particular representation, I'd say it's a cleaner design to hide the filesystem-dependent internals
16:42:10 <Cale> mm_freak_: I would love to be able to store a function in a file.
16:42:25 <EvilTerran> Cale, i think we all would
16:42:35 <inimino> Cale: you can do it with FUSE
16:42:38 <EvilTerran> or send one over the network
16:42:39 <Cale> mm_freak_: If I pass the wrong parameters to a program, I should get a type error ;)
16:42:43 <mm_freak_> Cale: you know how quickly the haskell community growsâ¦  people wouldn't use the filesystemâ¦  not because it's bad, but rather because they don't understand it =)
16:42:46 <p_l> inimino: The thing is, that it gives you power for free
16:43:02 <endusr> p_l: The contents, or the number of items successfully read?
16:43:16 <mm_freak_> Cale: then you wouldn't need the notion of files at all, just values ;)
16:43:24 <p_l> endusr: The on-disk structure describing filenames and references
16:43:27 <inimino> p_l: power, but not for free. we already have portable syscalls for directory manipulation
16:43:27 <Cale> mm_freak_: Right. The filesystem is a value.
16:43:28 <mm_freak_> filesystem :: [File]
16:43:38 <FunctorSalad> do we really need to change the filesystem? you can build whatever on top of it
16:43:51 <mm_freak_> data File = Directory [File] | File String | â¦
16:44:00 <Cale> FunctorSalad: But if what you build is another filesystem, then something is wrong.
16:44:00 <p_l> inimino: They are interface to a library that interprets those contents
16:44:02 <endusr> p_l: I see.
16:44:20 <Cale> FunctorSalad: It would be nice to figure out what the right thing to do actually is, and do that.
16:44:39 <FunctorSalad> Cale: I would think of the inferior filesystem as an abstraction layer like in networking
16:45:12 <p_l> Anyway, this little question was to point why making files suddenly act like dirs as in ReiserFSv4 is a bad idea
16:45:18 <inimino> p_l: sure, but by that token you could just poke bits around in /dev/physical_device
16:45:22 <FunctorSalad> but disclaimer: I have no idea what common filesystems actually do under the hood
16:45:40 <p_l> inimino: And you can
16:45:45 <Cale> I would also like to see a more useful /proc directory. It would be really cool if every program which used a particular GUI library, say, exposed all the GUI's functionality through the filesystem.
16:45:50 <p_l> inimino: After all, that's what Unix power was about
16:45:54 <kynky>   i thought in linux everything was a file :()
16:45:56 <p_l> Cale: Play with Plan9
16:46:04 <Cale> p_l: I've seen Plan 9.
16:46:10 <p_l> kynky: Unfortunately they forgot about it
16:46:23 <p_l> as well as 99% of Unix developers
16:46:43 <FunctorSalad> Cale: kde kinda has that, it's called dcop
16:46:53 <Cale> FunctorSalad: Yes.
16:46:56 <p_l> Cale: It's exactly what you asked for :)
16:47:07 <p_l> dcop is nowhere near having a GUI fs
16:47:08 <Elly> kynky: it was until the BSD guys got their hands on it
16:47:10 <endusr> p_l: 'UNIX developers', isn't UNIX just a specification/standard, now?
16:47:24 <kynky> posix
16:47:25 <Cale> FunctorSalad: The fact that desktop environments each have to implement their own incompatible versions of this is a problem.
16:47:26 <FunctorSalad> Cale: (except it's not through the FS, but command line)
16:47:33 <p_l> endusr: I meant people who wrote new implementations which then were the base for standards
16:47:40 <inimino> endusr: Unix is a tradition :-)
16:47:47 <FunctorSalad> Cale: yes, it would be nice if it was more general
16:47:53 <endusr> inimino: Really?
16:48:05 <endusr> p_l: Ah, and is Linux SuS compliant?
16:48:06 <inimino> endusr: some of us think so, yeah
16:48:16 <p_l> endusr: It never got certified
16:48:28 <p_l> endusr: and no one is trying to get it
16:48:28 <endusr> p_l: And BSD?
16:48:29 <Cale> There should be APIs to allow any running program to expose functionality dynamically and have it appear as part of the filesystem.
16:48:34 <mm_freak_> i still wasn't able to figure a way to retrieve the version number of a package from its cabal file
16:48:44 <endusr> I hope not.
16:48:45 <Elly> Cale: plan 9 :P
16:48:50 <inimino> Cale: that would be FUSE
16:48:50 <kynky> Cale isnt that what posix was for ?
16:48:57 <endusr> Elly: One word.
16:49:03 <Elly> endusr: 9P?
16:49:03 <inimino> (or plan9, but FUSE is here)
16:49:06 <EmielRegis> hmm
16:49:11 <EmielRegis> how to get system time in haskell?
16:49:26 <p_l> endusr: It's Unix, but it's not exactly SUS
16:49:37 <Cale> EmielRegis: System.Time.getClockTime ?
16:49:38 <p_l> After all, it's older than first POSIX spec
16:49:45 <EmielRegis> danke
16:49:47 <inimino> Cale: the other idea is that that's what Web services are, we've just replaced the filesystem with HTTP
16:49:54 <endusr> p_l: Being as it does not comform to the Single UNIX Specification, it is not a UNIX.
16:49:57 <Cale> inimino: yeah.
16:50:26 <endusr> I think the term they use is 'UNIX-Like'.
16:50:26 <p_l> endusr: "Officially". Except for trademark lawyers, no one will probably dare to claim that :>
16:50:49 <endusr> You seem not to understand.
16:51:00 <FunctorSalad> inimino: and spaces with a barrage of angled brackets (j/k :))
16:51:06 <endusr> Officially or otherwise, Linux and the variants of BSD are not UNIXes.
16:51:13 <p_l> endusr: What do refer is the UNIX trademark
16:51:20 <p_l> *you do refer to
16:51:21 <endusr> They are a family of 'UNIX-Like' systems.
16:51:35 <inimino> FunctorSalad: you can keep XML ;-)
16:51:36 <kynky> solaris is a flavour of unix ?
16:51:49 <endusr> kynky: Yes.
16:52:01 <inimino> endusr: all of which is Unix :-)
16:52:06 <p_l> endusr: Tru64 passed POSIX conformation tests and it's a BSD
16:52:08 <p_l> :P
16:52:11 <endusr> kynky: It conforms to the SUS, thus it is a UNIX.
16:52:18 <Adamant> there are genetic Unixes, standard-meeting Unixes, and Unix-inspired systems
16:52:24 <kynky> thought so
16:52:36 <endusr> p_l: And?
16:52:49 <kynky> like linux was unix inspired but written from scratch
16:52:53 <p_l> endusr: AFAIK the thing is that UNIX is a trademark, and to get allowed to use it you need to pass official certification of conformance
16:52:54 <tux91> what's a function that returns everything except the last element of a list?
16:52:56 <Adamant> genetic Unix = most of your code is in some way from the original Unix, standard-meeting = SUS, Unix-inspired = Linux
16:52:57 <endusr> Adamant: Are these terms in the nominal texts?
16:53:06 <endusr> kynky: Thus, 'UNIX-Like'.
16:53:12 <Adamant> endusr: no, I think ESR invented them
16:53:19 <Adamant> or something like them
16:53:22 <Adamant> but they make sense
16:53:31 <p_l> endusr: So there are systems which are SUS-compliant, but no one in their right mind would call them UNIX
16:53:33 <endusr> Adamant: I don't recognise esr.
16:53:43 <Adamant> Eric S. Raymond
16:53:48 <endusr> I recogise the standard.
16:53:51 <kynky> well you have to pay to be a unix i thought
16:53:56 <endusr> p_l: Like?
16:53:57 <kynky> as well as conform
16:54:03 <p_l> endusr: MVS
16:54:19 <inimino> tux91: init
16:54:26 <p_l> If Java is 900 pound gorilla, this is 9000 pound whale
16:54:30 <endusr> p_l: What is MVS?
16:54:31 <tux91> inimino: thx
16:54:59 <p_l> endusr: It's also known as OS/390 and z/OS
16:55:16 <p_l> probably the only OS older than Unix that is still in use
16:55:18 <endusr> Ah, yes z/OS is a UNIX.
16:55:27 <Adamant> Netcraft confirms - mainframes are dying
16:55:34 <p_l> endusr: This way Windows is UNIX too
16:55:42 <kynky> lol
16:55:47 <inimino> endusr: I recognize the community, and I don't think recognize that the trademark lawyers or their clients own "Unix"
16:55:52 <endusr> It conforms to the SUS, afaik.
16:55:52 <p_l> AFAIK they stopped short of certification
16:55:56 <inimino> s/think //
16:56:10 <Adamant> neither Windows or z/OS is fully SUS compliant IIRC
16:56:11 <endusr> p_l: z/OS conforms to the specification, Windows does not even attempt to be.
16:56:27 <inimino> but this is probably getting a bit off-topic for #haskell
16:56:45 <p_l> Adamant: z/OS passed certification
16:56:48 <kynky> not even fuly posix compliant i thought, hence cygwin needed for some stuff
16:56:52 <endusr> Adamant: I'm not entirely certain about how extesnive their complaince is (z/OS); but they're compliant nevertheless.
16:57:01 <Adamant> did not know that
16:57:08 <endusr> Because they possess the SUSv3 specification/certification.
16:57:19 <p_l> kynky: That's because NT doesn't ship with full POSIX subsystem
16:57:28 <inimino> kynky: Windows has an add-on, it's quite a pain
16:57:41 <kynky> unix services for windows
16:57:46 <inimino> right
16:57:47 <p_l> Up to some point the base libs were included though
16:58:00 <endusr> Windows should be debunked and placed in sewage systems.
16:58:07 <p_l> also MS compilers have /POSIX switch
16:58:47 <kynky> not to hard for them todo an apple and rip off bsd, and stick their gui layer on top, and do compatability with older windows products i thioought
16:59:01 <p_l> The problem is that Windows tried too hard to be compatible with older stuff
16:59:19 <lispy> what are the reasons to not use System.IO.bracket?
16:59:27 <kynky> should of emulated it in a container
16:59:28 <lispy> is there some more general bracket?
16:59:41 <Saizan_> ?type System.IO.bracket
16:59:42 <lambdabot> Not in scope: `System.IO.bracket'
16:59:50 <Saizan_> ?type Control.Exception.bracket
16:59:51 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:59:53 <p_l> Often they ended having to make weird changes to support some shitty app
17:00:03 <endusr> kynky: There are a couple of things other than the Mac OS X gui, that is seperate from a 'bsd ripoff'.
17:00:03 <endusr> Mach/XNU isn't part of the 4.4BSD subsystem, afaik.
17:00:09 <heatsink> *cough* simcity
17:00:15 <kynky> endusr, darwin
17:00:20 <kynky> yeah
17:00:27 <EmielRegis> does Data.Time have show function defined?
17:00:31 <lispy> Is it one of those things here you should be using Control.Exception.bracket?
17:00:34 <EmielRegis> or any other way to render it to string?
17:01:12 <kynky> but i would say bsd was the basis
17:01:29 <inimino> EmielRegis: there's Data.Time.Format
17:01:29 <Saizan_> lispy: i don't see a System.IO.bracket
17:01:45 <lispy> Saizan_: yeah, me either
17:01:55 <lispy> so, I wonder what this person is talking about...
17:02:24 <Saizan_> thread on -cafe?
17:03:12 <lispy> Saizan_: on darcs-users
17:03:46 <lispy> hoogle.org is NOT what I expected
17:03:48 <lispy> ?where hoogle
17:03:48 <lambdabot> http://haskell.org/hoogle
17:04:02 <Cale> ahaha
17:04:24 <Cale> On the math reddit there's a self post asking "Does proof by contradiction imply that a constructive proof must exist?"
17:04:33 <Cale> and someone replied: "Obviously not, or else someone would have made use of that fact to get the constructivists to shut the hell up. :-)"
17:04:54 <Saizan_> :D
17:05:15 <endusr> What's the missing number: 0,1,1,2,3,5,8,13,-,34,55
17:05:24 <heatsink> 21?
17:05:32 <endusr> Ah, I think I see it.
17:05:37 <Cale> @oeis 0,1,1,2,3,5,8,13
17:05:38 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
17:05:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:05:40 <PsiOmega> Looks like Fibonacci
17:05:48 <endusr> No, 34 -- I think.
17:06:01 <necroforest> you have 34..
17:06:11 <endusr> Eh.
17:06:27 <endusr> It was off the top of my head.
17:06:38 <Cale> @oeis 0
17:06:39 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
17:06:39 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:06:41 <Cale> heh
17:06:48 <endusr> I seemed to think '55' was '35' for some reason.
17:06:48 <EvilTerran> Cale, i look forward to someone finding a non-constructive proof of P=NP
17:06:57 <EvilTerran> all the complexity theorists' heads would explode
17:07:00 <Cale> EvilTerran: That would be awesome
17:07:04 <heatsink> :)
17:07:05 <Cale> I would love it
17:07:25 <EvilTerran> it's, if anything, more likely than a constructive one, too
17:08:00 <Cale> Another thing which would be pretty fun is if P = NP, but the best possible polynomial time algorithm is O(n^G) or something.
17:08:07 <Cale> (where G is Graham's number)
17:08:07 <EvilTerran> although i'm not holding my breath for either :P
17:08:17 <ikkebr> @oeis 0 !! 50
17:08:18 <lambdabot>  Triangle of coefficients of Chebyshev's T(n,x) polynomials (powers of x in i...
17:08:18 <lambdabot>  [1,0,1,1,0,2,0,3,0,4,1,0,8,0,8,0,5,0,20,0,16,1,0,18,0,48,0,32,0,7,0,56,0,112...
17:08:46 <Cale> @oeis 0,50
17:08:46 <lambdabot>  Triangle of coefficients of Chebyshev's T(n,x) polynomials (powers of x in i...
17:08:46 <lambdabot>  [1,0,1,1,0,2,0,3,0,4,1,0,8,0,8,0,5,0,20,0,16,1,0,18,0,48,0,32,0,7,0,56,0,112...
17:09:00 <Cale> (there must be a 50 further down)
17:09:13 <necroforest> IIRC from my algorithms class, the leading hypothesis (or at least one with a large following) is that P vs. NP is independent of ZFC
17:09:14 <EvilTerran> > ([0,50]...)
17:09:15 <lambdabot>   Not in scope: `...'
17:09:59 <EvilTerran> necroforest, we've only gone as far as "as yet unknown" in our computational complexity lectures
17:10:07 <FunctorSalad> necroforest: IIRC in that survey paper "no" was most popular
17:10:10 <EvilTerran> but that's an interesting possibility
17:10:55 <hackage> Uploaded to hackage: GLFW-OGL 0.0
17:10:55 <hackage> Uploaded to hackage: OGL 0.0.0
17:11:04 <FunctorSalad> what are chebyshev's polynomials for again? optimal numerical integration?
17:11:06 <necroforest> FunctorSalad, isn't that survey pretty old?
17:11:18 <Cale> Here's a good problem: Given any function f: R -> N (from the reals to the naturals), must there exist x,y,z,w, real numbers such that f(x)=f(y)=f(z)=f(w) and x+y = z+w ?
17:11:20 * EvilTerran gets to envisaging people having to talk about "ZFCP"
17:11:30 <necroforest> lol
17:11:35 <FunctorSalad> necroforest: yes, maybe the times have changed
17:11:35 <necroforest> P=NP by assumption
17:11:42 <EvilTerran> exactly :)
17:11:44 <FunctorSalad> back then pluto was still a planet, after all
17:11:44 <Cale> This problem is independent of ZFC :)
17:11:58 <EvilTerran> and similarly "ZFC-not-P", like "ZF-not-C"
17:12:06 <Cale> (I'll be nice and let you know that up front ;)
17:12:38 <Cale> oh, x,y,z,w must be distinct, of course ;)
17:12:50 * EvilTerran really doesn't like real numbers
17:13:01 <EmielRegis> can anyone tell em whats wrong with this one? (:
17:13:01 <EmielRegis> http://hpaste.org/12117
17:13:10 <necroforest> how do you prove that it's independent of ZFC?
17:13:18 <Cale> EvilTerran: Do you like infinite binary strings better?
17:13:20 <FunctorSalad> EvilTerran: it's not required to be continuous, so it really has nothing to do with R
17:13:30 <endusr> Night.
17:13:31 <Cale> (that will do just as well)
17:13:32 <EvilTerran> Cale, no, not really
17:13:34 <FunctorSalad> just 2^aleph0
17:13:48 <Cale> Or sets of naturals.
17:13:56 <heatsink> Is that question about the difference between the sizes of the reals and naturals?
17:14:02 <heatsink> sets
17:14:03 <Cale> heatsink: yes
17:14:09 <Saizan_> EmielRegis: what you've is parsed as ((printf "Render time: %c") timeDiffToString) (diffClockTime startTime getCPUTime)
17:14:10 <Cale> It's equivalent to the negation of CH.
17:14:20 <FunctorSalad> Cale: :O
17:14:25 <EvilTerran> sets of naturals seems like it'd be tidier than all the incredibly confusing blather about limits i've run across at uni
17:14:29 <Cale> That is, if there must be such a choice of x,y,z,w, then CH is false.
17:14:35 <FunctorSalad> that's suprising. thought it was just going to be infinite pigeonhole principle
17:14:40 * EvilTerran is a discrete maths kinda guy
17:14:43 <EmielRegis> Saizan_, with proper parenthesis it doesnt work eithe
17:14:44 <EmielRegis> r
17:14:54 <EmielRegis> it says that last statement in do block must be an expression...
17:15:23 <endusr> EvilTerran: I wasn't ever really good with math, discrete/finite or otherwise.
17:15:39 <heatsink> EmielRegis, if you use curly braces, then you have to separate statements with semicolon
17:15:42 <Saizan_> EmielRegis: if you're disabling layout you need ';' at the end of each line
17:15:45 <necroforest> CH?
17:15:47 <endusr> I guess I'm able to write a program that circumvents my inability to add 1 to 1.
17:15:55 <EvilTerran> necroforest, the Continuum Hypothesis
17:15:56 <Cale> EvilTerran: My friend who is doing categorical abstract homotopy theory uses the word 'ordinal' to mean 'finite ordinal' which throws me off :)
17:15:57 <necroforest> Ah
17:16:21 <endusr> If you understand 1 + 1 you're halfway there.
17:16:22 <Cale> "So what happens at a limit ordinal."  "Oh, right, I mean finite..."
17:16:27 <endusr> Shame C doesn't.
17:16:32 <EmielRegis> ah thanks
17:16:36 <FunctorSalad> sure, he probably uses the simplicial kitten all the time
17:16:49 <EvilTerran> i really suck at calculus and analysis and whatnot, but i find abstract algebra and whatnot comes almost naturally to me
17:16:51 <idnar> the...what?
17:16:52 <Cale> necroforest: CH says that there's no cardinality in between that of the naturals and the reals.
17:16:52 <EvilTerran> relatively, at least
17:17:14 <Cale> It implies that there's a well ordering of the reals such that for any real number, the set of reals less than that one is a countable set.
17:17:15 <FunctorSalad> idnar: kitten = small category ;)
17:17:17 <necroforest> Cale, i know, i just don't use the abbrev. 'CH' much
17:17:21 <EvilTerran> this means that my uni course was actually *easier* for me in 2nd year than 1st because they let me stop doing continuous maths
17:17:22 <necroforest> :)
17:17:29 <idnar> FunctorSalad: seriously?
17:17:40 <FunctorSalad> idnar: not officially I think
17:17:56 <Cale> (because R is in bijection with omega_1, the smallest uncountable ordinal)
17:17:57 <EvilTerran> FunctorSalad, that's a clever term for it
17:17:57 <idnar> okay
17:18:01 <idnar> that's still pretty awesome, though
17:18:35 <EvilTerran> it's no weirder than "clique" from graph theory
17:18:45 <FunctorSalad> EvilTerran: disclaimer: it's from one of my profs :)
17:19:05 <fynn> what's the name of the mathematical operation sums up the natural numbers from i to j?
17:19:08 <Cale> So, in the last little while, I've come to the opinion that maybe CH should be false, though in practice, I've more often wanted it to be true.
17:19:17 <necroforest> i'll see your clique and raise you a chirplet :P
17:19:27 <EvilTerran> WIDGETS AND DONGLES
17:19:31 <EvilTerran> (...sorry)
17:19:47 <ikkebr> any good content about finding shortest paths in weighted, direct graphs in haskell ?
17:19:57 <Cale> fynn: It's called (1/2) (i - i^2 + j + j^2)
17:20:05 <p_l> ikkebr: between two known points?
17:20:18 <fynn> Cale: that's a funny name
17:20:19 <Cale> fynn: Or do you mean summation?
17:20:30 <Cale> fynn: sum over k = i to j of k
17:20:31 <fynn> Cale: yeah, I need the sum of them
17:20:39 <kynky> travelling salesman ?
17:20:44 <ikkebr> p_l yes
17:20:48 <Cale> You'd typeset it using a big Sigma.
17:20:49 <p_l> ikkebr: or finding all possible paths that satisfy certain reqs?
17:20:53 <p_l> ikkebr: A*
17:20:55 <ikkebr> i have the whole graph
17:21:00 <fynn> Cale: there must be some mathematical shortcut for 1 + 2 + 3 + 4 + ... + n
17:21:06 <ikkebr> and i need the shortest path between two edges
17:21:18 <Cale> fynn: Depends on what you mean by 'shortcut'.
17:21:21 <ikkebr> doing it using a non-functional language is pretty easy
17:21:37 <fynn> Cale: "calculation faster than simply summing them up".
17:21:42 <p_l> ikkebr: I don't know if there's a ready-made implementation, but try writing an A*
17:21:45 <idnar> fynn: (n/2)(n+1)
17:21:49 <ikkebr> just need some floyd-warshall or djikstra
17:22:01 <ikkebr> wonder how to do that in a functional way
17:22:01 <Cale> fynn: Okay, then n (n+1)/2
17:22:02 <fynn> idnar, Cale: thanks, that's what I meant.
17:22:11 <kynky> summation of x for all x 1 to n, which is subscript and superscript on right of crazy  e ?
17:22:18 <_dolio> Cale: It implies that (the countable < thing)? That's pretty odd.
17:22:21 <idnar> Cale's previous formula derives fairly obviously from that one
17:22:34 <Cale> _dolio: Well, you know what ordinals are?
17:22:43 <EvilTerran> fynn, going from 1 to n is triangular numbers
17:22:44 <p_l> ikkebr: A* is enough, djikstra after all is a special case of it (because it was designed for mathematical research, not practical use)
17:22:51 <dolio> Yeah.
17:23:10 <EvilTerran> fynn, so i guess summing [i..n] instead of [1..n] would be, er, trapezoids?
17:23:24 <fynn> EvilTerran: I have no idea what you're talking about.
17:23:40 <fynn> I haven't been in #haskell for long enough, probably.
17:23:41 <EvilTerran> <fynn> what's the name of the mathematical operation sums up the natural numbers from i to j?
17:23:50 <dibblego> @google Triangular Numbers
17:23:52 <lambdabot> http://en.wikipedia.org/wiki/Triangular_number
17:23:52 <lambdabot> Title: Triangular number - Wikipedia, the free encyclopedia
17:23:56 <fynn> EvilTerran: yeah, I was really looking for a calculation shortcut.
17:23:59 <dibblego> fynn, ^^
17:24:03 <fynn> dibblego: thanks.
17:24:04 <Cale> dolio: Because there's no cardinality between countable and uncountable, and the ordinals occur in order of cardinality, there must be a least ordinal with the cardinality of the reals, and all the ordinals less than it are countable.
17:24:05 <EvilTerran> ah, yes, in that case, what Cale said. yeah.
17:24:06 <dibblego> (n(n+1))/2
17:24:18 <fynn> yeah, how come everyone here knows it?
17:24:26 <dibblego> > let triangular n = n * (n+1) / 2 in triangular 5
17:24:28 <lambdabot>   15.0
17:24:33 <fynn> are you all math doctors just like /. says?
17:24:35 <dolio> Cale: Ah. Interesting.
17:24:38 <FunctorSalad> it's a common anecdote about gauss
17:24:38 <Cale> fynn: I learned it in grade 8 or something.
17:24:40 <dibblego> fynn, it's in most mathematical texts
17:24:46 <EvilTerran> fynn, i can't speak for everyone else, but i was told it at secondary school
17:24:56 <fynn> your eduction system must be better than mine :(
17:25:07 <Twey> Triangular numbers?  I was taught them in *primary* school :-P
17:25:13 <dibblego> > let triangular n = n * (n+1) `div` 2 in triangular 10
17:25:14 <lambdabot>   55
17:25:14 <EvilTerran> dibblego, while that initially sounds like a gross overgeneralisation, the more i think about it the more accurate it seems :)
17:25:21 <fynn> wait, I bet someone was told them in kindergarten.
17:25:27 <dibblego> EvilTerran, :)
17:25:28 <dolio> Cale: Thinking about it for a couple minutes, it doesn't seem quite so odd.
17:25:38 <strattg> fynn: that's how these things usually go, yes
17:25:40 <FunctorSalad> Twey: I was thought in *crawling* school
17:25:40 <p_l> ikkebr: http://www.haskell.org/haskellwiki/Haskell_Quiz/Astar <--- this looks like what you are looking for (you'll need to adapt it of course)
17:25:41 <lambdabot> Title: Haskell Quiz/Astar - HaskellWiki
17:25:43 <dibblego> fynn, I invented that shortcut myself accidentally, then read about it
17:25:48 <fynn> in fact, there's probably someone here who _is_ in kindergarten, and kicks my ass in both math and haskell.
17:26:01 <Cale> dolio: So the bijection between omega_1 and R puts each real in correspondence with a countable ordinal, and the elements of that countable ordinal (the ordinals less than it), correspond to the reals less than that one.
17:26:03 <fynn> this channel does wonders to one's self esteem.
17:26:05 <Twey> FunctorSalad: Well I was born with the knowledge fully-formed!
17:26:06 <Twey> fynn: I'm a high-school drop-out.  :)
17:26:11 <Cale> (and there are countably many of those)
17:26:20 <ikkebr> thanks p_l
17:26:24 <dibblego> fynn, draw triangular numbers on paper, then make a square out of two of those triangle
17:26:25 * Twey wears this badge with pride.
17:26:48 <EvilTerran> dibblego, if i'd invented that myself, i'd be going round comparing myself to gauss :P
17:27:00 <fynn> dibblego: should be interesting, thanks.
17:27:08 <dibblego> EvilTerran, isn't it intuitive that there is a shortcut?
17:27:14 <dibblego> fynn,
17:27:19 <dibblego> consider the 4th triangular
17:27:20 <dibblego> *
17:27:20 <dibblego> **
17:27:20 <dibblego> ***
17:27:20 <dibblego> ****
17:27:21 <EvilTerran> well, depending on how old i was at the time
17:27:22 <tessier> So I'm up to Chapter 3 of the online version of Real World Haskell which I have been eagerly awaiting since it was first announced months ago
17:27:29 <Cale> You still get a nice bijection like this with the negation of CH, but rather than all the ordinals being countable, they just have cardinality less than R.
17:27:37 <Twey> 'tis half a square.
17:27:41 <tessier> So far so good. I now now know about Haskell than I ever did before. I know what a value constructor is! Yeay!
17:27:43 <EvilTerran> seeing as gauss was meant to have discovered that in school, iirc
17:27:48 <tessier> more about
17:27:59 <Twey> tessier: Hehe, congratulations!  :-P
17:28:10 <dibblego> EvilTerran, I invent lots of things but I've never been original :)
17:28:12 <Cale> (so there will be some reals such that the set of reals less than them is not countable, but none of them will have c-many elements less than them.
17:28:24 <tessier> If things keep up this way I'll definitely be buying the dead tree version
17:28:57 * p_l would buy Real World Haskell if he wasn't piss poor student
17:29:01 <dolio> Cale: Oh, yeah. I suppose from that perspective, there's nothing especially odd about the CH version.
17:29:24 <dolio> Cale: It's just the countably many is the only option.
17:29:28 <Cale> right
17:29:31 <FunctorSalad> Cale: isn't it easy to make up a well-ordering s.t. c-many are less than one, given the AC?
17:29:47 <Cale> FunctorSalad: Yes, it's just that this method avoids that.
17:30:31 <Cale> FunctorSalad: You pick the smallest ordinal which is in bijection with the reals, and use that well-ordering.
17:30:54 <fynn> woohoo, that shortcut just helped me cut my algo's running time by a factor of 200
17:30:58 <tessier> p_l: There's always the online version at book.realworldhaskell.org/read
17:31:15 <fynn> two orders of magnitude babbbby
17:31:42 <ikkebr> is there any haskell built-in function to check for the minimum value in a list?
17:32:03 <dolio> > logBase 10 200 -- orders of magnitude
17:32:04 <lambdabot>   2.301029995663981
17:32:09 <p_l> tessier: I'm currently preparing it for easier reading :-)
17:32:23 <Twey> > min [1, 2, 4, 5, 0, 3]
17:32:24 <lambdabot>       Overlapping instances for Show ([t] -> [t])
17:32:24 <lambdabot>        arising from a use o...
17:32:27 <FunctorSalad> Cale: think I understood it the wrong direction... the hard think is proving that there is a well-order such that there *isn't* a number with c-many smaller ones
17:32:33 <FunctorSalad> *hard thing
17:32:35 <fynn> Twey: you need to use apply somehow
17:32:40 <Twey> Bah
17:32:40 <Twey> :t min
17:32:41 <lambdabot> forall a. (Ord a) => a -> a -> a
17:32:43 <Cale> FunctorSalad: right.
17:32:49 <Twey> Oh, that's no good
17:32:58 <Twey> > foldr min [1, 2, 4, 5, 0, 3]
17:32:59 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
17:32:59 <lambdabot>        arising from a use...
17:33:18 <Twey> Tsk
17:33:19 <arw> hi.
17:33:21 <Philonous> > minimum [3,4,5,1,6]
17:33:21 <lambdabot>   1
17:33:30 <Twey> > foldr1 min [1, 2, 4, 5, 0, 3]
17:33:31 <lambdabot>   0
17:33:32 <ikkebr> thanks Philonous
17:33:32 <Twey> Ah, minimum.  That's it.
17:33:47 <Twey> I knew it was in there somewhere :-P
17:33:49 <fynn> Twey: what's the problem with foldr?
17:34:04 <Twey> fynn: It needs an initial element
17:34:15 <Twey> foldr1 takes the initial element from the start of the list.
17:34:50 <Twey> foldr1 f [a, b, c, d] === foldr f a [b, c, d]
17:35:39 <dolio> > foldr1 f [a, b, c, d]
17:35:40 <lambdabot>   f a (f b (f c d))
17:36:11 <Twey> > foldr f a [b, c, d]
17:36:12 <lambdabot>   f b (f c (f d a))
17:36:18 <Twey> Hum.
17:36:20 <dolio> foldr1 f [a, b, c, d] = foldr1 f d [a, b, c]
17:36:23 <Twey> Maybe not quite the same.
17:36:33 <Twey> foldr**
17:36:38 <dolio> Right.
17:36:39 <Twey> Aye, seems so.
17:36:41 <endusr> Eh, night.
17:36:47 <Twey> 'night endusr :)
17:36:47 <dolio> @src foldr1
17:36:47 <lambdabot> foldr1 _ [x]    = x
17:36:47 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
17:36:47 <lambdabot> foldr1 _ []     = undefined
17:36:56 <Twey> I still get mixed up between foldr and foldl.
17:38:17 <lispy> Twey: yeah me too
17:38:50 <fynn> Twey: ah.
17:39:00 <Twey> Those little sites, foldr.com and foldl.com, are a blessing :)
17:39:56 <FunctorSalad> maybe it's because the list monad isn't quite sure whether it wants to be the free monoid or not? ;)
17:40:17 <FunctorSalad> (as in having associativity of the f involved in fold as a rule)
17:42:55 <arw> i've got some small piece of code to get some statistics about a large textfile (6MB i think)
17:43:08 <arw> http://pbot.rmdir.de/eeca6c794f60caf363d48262e8e6818d <- thats the code
17:43:39 <arw> problem is, it dies because of a stack overflow... http://pbot.rmdir.de/8c05213597dc1f5c312a5303da0ae1bf
17:43:58 <heatsink> @src maximum
17:43:58 <lambdabot> maximum [] = undefined
17:43:58 <lambdabot> maximum xs = foldl1 max xs
17:44:17 <arw> shouldn't the compiler be able to remove all the recursions?
17:44:20 <dolio> Wow. Import GHC.Float, eh? :)
17:44:36 <EmielRegis> lol
17:44:44 * FunctorSalad actually ran into maximum [] today
17:44:57 <dolio> fromIntegral can be used instead of int2Float.
17:45:07 <dolio> And doesn't require low-level GHC libraries.
17:45:09 <FunctorSalad> Ord should require a least element ;)
17:45:17 <FunctorSalad> (not really)
17:45:28 <arw> dolio: well, yes. first quick&dirty thing i found somewhere, you are right, this is ugly :)
17:47:04 <sbahra> Hi.
17:47:09 <dolio> > sum . map (fromIntegral :: Int -> Float) $ [1..100000]
17:47:11 <lambdabot>   4.9999903e9
17:47:16 <dolio> > sum . map (fromIntegral :: Int -> Float) $ [1..1000000]
17:47:17 <lambdabot>   * Exception: stack overflow
17:47:28 <sbahra> Shared object "libXext.so.6" not found
17:47:32 <FunctorSalad> by the way, for 'fold f' with f a monoid homo, ghc might have more freedom for optimization
17:47:34 <sbahra> etc...when using cabal-install.
17:47:35 <Plouj> hi
17:47:37 <dolio> arw: Your overflow may be caused by something like that. It's hard to say.
17:47:46 <sbahra> Is there a way to specify library paths, easily?
17:47:47 <Plouj> can someone briefly explain to me the difference between function application and function composition?
17:47:55 <FunctorSalad> (it could divide the list whereever it wants)
17:48:01 <heatsink> sbahra, -L/path/to/directory
17:48:04 <sbahra> For example, in this case they are in /usr/pkg.
17:48:10 <sbahra> heatsink, yes...
17:48:13 <FunctorSalad> (just a random idea ;))
17:48:21 <sbahra> heatsink, how do I pass that with cabal-install?
17:48:25 <Saizan_> arw: are you compiling with -O2?
17:48:34 <heatsink> oh.  I haven't used cabal.
17:48:41 <arw> Saizan_: -O3
17:49:04 <heatsink> > sum [1..1000000]
17:49:06 <lambdabot>   * Exception: stack overflow
17:49:13 <Saizan_> arw: uhm, try foldl' (+) 0 instead of sum
17:49:14 <heatsink> Why would sum cause a stack overflow?
17:49:22 <Saizan_> ?src sum
17:49:22 <lambdabot> sum = foldl (+) 0
17:49:22 <sbahra> @src sum
17:49:22 <lambdabot> sum = foldl (+) 0
17:49:37 <heatsink> Weird that it's not strict.
17:49:52 <arw> foldl' forces evaluation?
17:49:52 <lispy> strict isn't something you can just do as a general thing
17:49:57 <lispy> it can change semantics
17:50:04 <sbahra> "abal may also need to find object files that need to be statically linked. Again, a future Cabal release will allow you to specify these during the configure state with switches, but for now try adding extra-lib-dirs: "C:\\Program Files\\My External Library\\lib" or similar. "
17:50:07 <sbahra> :-(
17:50:14 <Saizan_> arw: yes, it forces the evaluation of each intermediate value before recursing
17:50:23 <dolio> heatsink: foldl' isn't in the H98 report, and sum is in the Prelude.
17:50:30 <mm_freak_> Plouj: think of a function as a machine with a input conveyor and an output conveyorâ¦  then function application puts a value onto the input conveyor, while function composition connects the output conveyor of a function to the input conveyor of another
17:50:32 <sbahra> Any ideas on how to make this a "general" option or something so I don't have to manually deal with every single cabal package?
17:51:00 <Cale> I feel that for things as simple as left folds and sum, we ought to be able to rely on strictness analysis to get it right, but it seems that we still can't.
17:51:08 <mm_freak_> 'f . g' connects the output conveyor of g to the input conveyor of f
17:51:15 <lispy> sbahra: you should email the cabal mailing list.  I'm sure if you're interested in working on cabal that Duncan will be quite happy to help you get started :)
17:51:41 <sbahra> lispy, not interested
17:51:52 <sbahra> I'll be happy to work on other things though :-P
17:52:11 <lispy> sbahra: ah, I thought you just said you wanted to fix cabal.
17:52:18 <sbahra> lispy, why?
17:52:18 * lispy misunderstood
17:52:25 <sbahra> It's fine, we can still be friends.
17:52:29 <lispy> hehe
17:52:32 <lispy> you said:
17:52:32 <FunctorSalad> how could you ever not have to fully evaluate a sum, but parts of it?
17:52:36 <lispy> 17:48 <sbahra> Any ideas on how to make this a "general" option or something so  I don't have to manually deal with every single cabal package?
17:52:53 <Cale> Plouj: The difference between function application and function composition is that function application takes a function of type (a -> b) and a value of type a, and produces a value of type b, whereas function composition takes two functions, one of type b -> c and one of type a -> b and gives another function (of type a -> c)
17:52:53 <lispy> sbahra: that was the part where I thought you wanted to fix something in cabal...and that you were asking for help getting started
17:52:53 <sw17ch> i want function-local data declarations
17:53:03 <lispy> sw17ch: where?
17:53:07 <lispy> sw17ch: Oh
17:53:10 <dolio> FunctorSalad: Lazy naturals, but then you want foldr.
17:53:21 <lispy> sw17ch: like being able to do 'data Foo = ...' instead a where clause?
17:53:25 <Saizan_> sbahra: you can pass that flag with --with-ghc-options=-optL-something, i think
17:53:30 <sw17ch> lispy: inside a where clause
17:53:32 <Plouj> Cale: that makes it more clear :)
17:53:33 <sw17ch> not instaed of
17:53:36 <sbahra> Saizan_, let's see
17:53:47 <Saizan_> sbahra: i'm not sure on the exact flag name
17:53:50 <lispy> sw17ch: oh right, I think I meant to type 'inside of'
17:53:55 <Twey> sw17ch: But why?  :-P
17:53:58 <Plouj> thanks
17:54:07 <Twey> You couldn't do anything with the generated data type
17:54:15 <sw17ch> Twey: i need a very short throw-away alternative data type that's only used to pass something around
17:54:15 <luite> is using Test.QuickCheck.Gen a good way for regular (non-testing) calculations that require some random numbers, or is there some better/alternative/preferred way?
17:54:20 <lispy> sw17ch: You could have on module per function :)
17:54:28 <sw17ch> lispy, hmm... i'm aware :)
17:54:44 <Cale> Plouj: If it was the case that only function types had any values, we could use the functions () -> a to be the 'values of type a', and then function composition and function application would be the same thing.
17:54:48 <lispy> sw17ch: but a more serious proposal.  tuples or HList
17:55:01 <sw17ch> lispy, I want a "select" call (unix system call) that works on a list/tuple of TChanS/MVarS
17:55:02 <FunctorSalad> foldl.com is down :(
17:55:26 <luite> should I use MonadRandom instead?
17:55:33 <Cale> Plouj: Of course, it's not the case, and that's a little inconvenient in general.
17:55:38 <sw17ch> lispy, and i have a way to do it cleanly if i was allowed such niceties
17:55:43 <jeffz> foldm.com had a good comic strip
17:56:04 <sw17ch> lispy, but as it stands... i suppose i could just make that into a library and not export any of the nasty constructors
17:56:13 <lispy> sw17ch: HList is a heavy solution, but it would probably do what you want nicely
17:56:24 <sw17ch> @where HList
17:56:24 <lambdabot> http://homepages.cwi.nl/~ralf/HList
17:56:29 <FunctorSalad> jeffz: just text ads for me
17:56:33 <EvilTerran> ?hackage Vec
17:56:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Vec
17:56:35 <jeffz> FunctorSalad: the domain expired
17:56:40 <EvilTerran> might do what you want, too, depending
17:56:40 <lispy> sw17ch: think of HList as first class records
17:56:51 <sbahra> Saizan_, --extra-lib-dirs
17:56:55 <FunctorSalad> jeffz: misread "has" for "had"
17:56:58 <sbahra> hopefully
17:57:17 <sw17ch> lispy: I'm not sure how HList's solve the problem of implementing a select call
17:57:20 <EvilTerran> seeing as you can have heterogeneous "vectors" in Vec
17:57:34 <Plouj> ok, that's a bit more confusing, Cale
17:57:37 <sw17ch> EvilTerran, i think i'm leaning toward the vectors for a different solution
17:58:13 <lispy> sw17ch: maybe I don't fully grasp the problem, but HList solves the aspect where you want to locally define a container for the values and have it's type reflect the structure of the contents
17:58:33 <sw17ch> lispy: ohhh...
17:58:35 <sw17ch> yes, i see now
17:58:37 <sw17ch> hehe
17:58:44 <sw17ch> lispy: do you know the unix select call?
17:58:45 <lispy> sw17ch: but yeah, I think most people that interface with system calls use newtype to make a Haskell type that corresponds to (well holds a value of) the C type and makes it distinct
17:58:53 <arw> ah, using sum' = foldl' (+) 0 helps, but only together with -O3.
17:59:03 <lispy> sw17ch: more or less I know about select yeah.  I know what it does and that it takes a list of fds
17:59:16 <dolio> -O3 is the same as -O2, by the way.
17:59:29 <sw17ch> lispy: here's what i want --> select :: [MVar a] -> (Int,a)
17:59:45 <lispy> sw17ch: what is the Int?
17:59:55 <sw17ch> the index of the MVar returned
17:59:57 <lispy> sw17ch: and why does it only return one a?
18:00:15 <lispy> let me look at the manpage real quick
18:00:19 <arw> why don't the map-functions i use eat up the stack, too?
18:00:26 <sw17ch> lispy: perhaps this is a little more clear --> select :: [TChan a] -> (Int,a)
18:00:38 <sw17ch> lispy: (idx,val)
18:01:22 <lispy> sw17ch: shouldn't select return a list?
18:01:35 <lispy> sw17ch: according to the man page it can return multiple fd
18:01:43 <sw17ch> lispy: ah, in that case, yes
18:02:06 <sw17ch> though in this case, it's more a way of unifying several into one
18:02:36 <lispy> sw17ch: I'm not sure exactly what API you want...but it seems to me that the haskellish way to use it is to have your select wrapper return a list of the TChan that are ready instead of their indexes
18:03:07 <sw17ch> lispy, yeah
18:03:22 <sw17ch> lispy, my thought was to return the value on the front of the TChan along with the index it came from
18:03:27 <lispy> select :: [TChan a] -> IO [TChan a]
18:03:32 <sw17ch> it's more Haskelly
18:03:48 <lispy> oh
18:03:55 <lispy> So your version will do the read?
18:03:56 <sw17ch> lispy, in my opinion :)
18:04:00 <sw17ch> yesh
18:04:11 <sjanssen> select :: [TChan a] -> STM [TChan a] -- is more Haskelly
18:04:26 <sw17ch> sjanssen, i defer to you :)
18:04:36 <sjanssen> though returning the value makes sense too
18:05:03 <sjanssen> another thread might be reading from the TChan, so there is a race condition
18:05:11 <lispy> automaticaly returning the value sounds like it runs the risk of being to 'eager' in a lazy language :)
18:05:21 <sw17ch> lispy, hmmm.... good point
18:05:31 <sjanssen> lispy: STM and IO are not lazy
18:06:23 <sw17ch> also, there doesn't seem to be a waitUntilSomethingIsThereButDoNotGetIt function for TChan
18:06:28 <lispy> sjanssen: sure, my concern is just that if this is a general library function that it probably does too much work upfront.  I mean, you don't *always* read from a chan just because it's ready
18:06:36 <sbahra> welp, that didn't work
18:07:05 <Twey> HList seems pretty awesome.
18:07:18 <sjanssen> sw17ch: you can unGetTChan
18:07:29 <sw17ch> sjanssen, yes, i did see that
18:07:54 <lispy> Twey: yes although, I feel like HList has more value as a pedigocial tool than it does as a real thing people use
18:08:11 <sw17ch> (readTChan chan) . unGetTChan
18:08:20 <sw17ch> bah
18:08:21 <lispy> Twey: most of the time there is a similar but conceputually much easier thing you can use
18:08:29 <sw17ch> (readTChan chan) . (unGetTChan chan)
18:08:35 <sw17ch> and i still have that backward
18:09:03 <lispy> ?pl \chan -> (readTCHan chan) . (unGetTChan chan) -- thinking with the Reader ((->) r) instance
18:09:03 <lambdabot> liftM2 (.) readTCHan unGetTChan
18:09:40 <sjanssen> also, I don't think there is a way to get a list of "ready" TChans
18:09:40 <heatsink> Can I make ghci load a .a library?
18:09:44 <lispy> :t readTChan `liftM2 (.)` unGetTChan
18:09:45 <lambdabot> parse error on input `('
18:10:40 <sjanssen> foldr orElse retry . map readTChan -- this is what I would use
18:11:08 <sjanssen> you might even call "foldr orElse retry" select, it seems like a very useful function
18:11:36 <lispy> it strikes me as the STM equivalent of a busy loop :)
18:11:46 <sjanssen> lispy: it isn't, GHC is smart
18:12:05 <lispy> s-m-r-t i mean s-m-r-r-t
18:12:18 <ivanm> all hail our glasgowian overlords! ;-)
18:12:26 <sjanssen> it will only retry the transactions when one of the chans has been written to
18:12:26 * lispy hopes that GHC is smarter than Homer
18:12:28 <ivanm> sjanssen: as in maxwell smart? :p
18:12:54 <lispy> sjanssen: than is cool that it does that
18:12:59 <sw17ch> is there a paper on FRP somewhere?
18:13:12 <Twey> ivanm: That's 'Glaswegian' :-P
18:13:39 <ivanm> Twey: *sigh* yet again the english language fails in standardising how it works :(
18:13:47 <Twey> 'cause it's Scottish
18:14:02 <MarcWeber> What does cabal-bin do?
18:14:07 <ivanm> I know Glasgow is in Scotland... but they speak English, don't they?
18:14:10 <ivanm> MarcWeber: it's deprecated
18:14:14 <ivanm> cabal-install has replaced it
18:14:31 <Twey> Yes, but the name is Scottish, as, I think, is the etymology for 'Glaswegian'
18:14:36 <MarcWeber> ivanm: make install from the ghc binary dist tries to run it.. But its not there (haddock directory)
18:15:44 <Saizan_> MarcWeber: it's something built by ghc's build system
18:16:03 <Adamant> ivanm: it's like complaining algorithm isn't very regular English, when it's a English mutation of an Arabic word
18:16:04 <ivanm> MarcWeber: ahhh, I was thinking of some cabal-bin package on hackage
18:16:16 <ivanm> Twey: yeah, I know...
18:16:22 <ivanm> but blaming the poms is more fun ;-)
18:16:34 <keseldude> > toRational (0/0)
18:16:35 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
18:16:39 <Adamant> ivanm: Aussie?
18:16:52 <lispy> keseldude: hrm
18:16:56 <ivanm> Adamant: yup
18:17:03 <roconnor> close enough
18:17:08 <lispy> > toRational (0^0)
18:17:09 <lambdabot>   1%1
18:17:17 <Twey> ivanm: Haha :-P
18:17:25 <Twey> ivanm: Aussie eh?  :-P
18:17:43 <ivanm> Twey: as I just said ;-)
18:17:52 * jeffz gives Twey a shifty look
18:17:55 <ivanm> (well, replied in the affirmative to Adamant, anyway)
18:17:56 <MarcWeber> Saizan_, ivanm thanks. Still digging around to find out why its not build
18:18:03 <Adamant> gotcha
18:18:55 <Twey> ivanm: Oh aye :-P  Didn't see, I was looking into the etymology of 'Glasgow'
18:19:19 <Twey> Apparently it's Brythonic in origin, which is interesting because Scottish Gaelic is Goidelic...
18:19:39 <Adamant> well, we all know
18:19:46 <Adamant> if it's not Scottish, it's crap
18:19:54 <Twey> Haha
18:19:55 * lispy wonders at what point people will study the etymology of computer languages
18:20:00 <ivanm> Adamant: you're a scotsman then I take it?
18:20:10 <Adamant> ivanm: hell no
18:20:14 <ivanm> lispy: need to have used them for at least a few hundred years
18:20:20 <ivanm> ;)\
18:20:20 <Adamant> just a fan of SNL
18:20:24 <ivanm> ahhh
18:20:40 <lispy> ivanm: We have been...at least in dog years we have been :)
18:21:01 <Twey> When was lambda calculus invented again?  :-P
18:21:04 <Adamant> lispy: people are already sort-of studying them
18:21:20 <Adamant> in the general study of programming languages
18:21:22 <lispy> Twey: about the same time as the turing machine, right?
18:21:37 <EmielRegis> question: how would I define a data type connecting Enum and Float?
18:21:40 <EmielRegis> like
18:21:42 <Twey> Long before, I think
18:21:44 <ddarius> Twey: 1920's or 30's
18:21:47 <ivanm> Adamant: which SNL? http://en.wikipedia.org/wiki/SNL_(disambiguation)
18:21:50 <Adamant> like 30's
18:21:52 <Adamant> for LC
18:21:55 <ddarius> Twey: No, it was about the same time.
18:22:01 <EmielRegis> data Hit = MISS | HIT Float deriving (Enum)
18:22:01 <Twey> Oh really?  Huh.
18:22:12 <Adamant> but it wasn't recognized as being generally applicable at the time
18:22:27 <sjanssen> sw17ch: http://hpaste.org/12118#a1
18:22:28 <lispy> ?instances Enum
18:22:28 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
18:22:42 <Adamant> only after Turing did the TM and proved it general
18:22:50 <lispy> EmielRegis: you may have to define the instance manually
18:23:04 <Adamant> ivanm: Saturday Night Live, US comedy show
18:23:08 <lispy> AlanTuring++
18:23:12 <EmielRegis> hm
18:23:25 <sw17ch> sjanssen, oh duh, retry :)
18:23:30 <sw17ch> thanks!
18:23:32 <sw17ch> sjanssen++
18:23:34 <Administrador> Tired of black people and their simian-like behavior?  Join us at http://www.niggermania.com and http://www.chimpout.com and join forces in the epic battle of HUMANS vs NIGGGERS.  We are not White Supremacists, but an alliance of Whites, Asians, and Hispanics (non-negroids).  Paid for by Chimpout.com. .............................................................Interested in a job in internet marketing?  Contact Guil
18:23:34 <Administrador> lermo Rodriguez at recluta@telvista.com.mx and reference the Experimental Internet Marketing Project.
18:23:39 <lispy> EmielRegis: I mean, what do you want this to be equal to? [MISS ..] ?
18:23:42 --- mode: ChanServ set +o sjanssen
18:23:44 <lambdabot> Title: Niggermania | Nigger Jokes, Facts, and Racist Humor
18:23:48 --- mode: sjanssen set +b *!*=Administ@*.160.160.13.cable.dyn.cableonline.com.mx
18:23:48 --- kick: Administrador was kicked by sjanssen (sjanssen)
18:24:03 --- mode: ChanServ set -o sjanssen
18:24:05 <ivanm> sjanssen: awww, you kicked him before I could @slap him :(
18:24:11 <Twey> Heh
18:24:28 <lispy> thanks, I was trying to lookup the commands again
18:24:36 * lispy is way to slow
18:24:48 <EmielRegis> lispy, basically I want to have a hit datatype for my raytracer
18:24:48 <SamB> ivan: and how does that stop you ?
18:24:56 <ivanm> SamB: he's not here to see it!
18:24:57 <EmielRegis> that would return Miss or Hit + distance
18:25:00 <EmielRegis> depending on raytrace
18:25:09 <sjanssen>  /msg ChanServ op #haskell\n /kickban jerk
18:25:25 <Twey> @slap Administrador
18:25:25 * lambdabot slaps Administrador
18:25:26 <ivanm> wow.... took that guy 7 minutes to make that comment from when he joined the channel...
18:25:28 <lispy> EmielRegis: oh I see.  so your data type is isomorphic (meaning, has the same structure) as Maybe Float
18:25:35 <ivanm> Twey: yeah, but there's no fun in it anymore :(
18:25:36 <EmielRegis> yes
18:25:53 <Twey> ivanm: Just a sort of grim vindication?  :-P
18:25:58 <ivanm> heh
18:25:59 <SamB> maybe he's trying to avoid some kind of anti-spammer heuristics ?
18:26:00 <ivanm> sjanssen: hmmm.... is there any way of informing the freenode devs about that character so he could be banned permanently?
18:26:06 <lispy> > [Nothing ..] :: Maybe Float
18:26:07 <lambdabot>   Couldn't match expected type `Maybe Float'
18:26:15 <sjanssen> ivanm: probably, but I'm not sure how
18:26:20 <SamB> ivan: um, devsi s not the term
18:26:21 <ivanm> *nod*
18:26:28 <lispy> EmielRegis: but anyway, why is Enum important for you?
18:26:43 <EmielRegis> no particular importance
18:26:46 <EmielRegis> just looks good
18:26:48 <EmielRegis> :P
18:26:50 <jeffz> ivam, unless the ircop sees it themselves, they're usually hesitant to do anything
18:26:51 <ivanm> Adamant: oh, about SNL, sure you don't mean this meaning: http://en.wikipedia.org/wiki/Soviet_Union_national_ice_hockey_team
18:26:51 <ivanm> ;-)
18:26:58 <lambdabot> http://tinyurl.com/6e8gs3
18:27:03 <EmielRegis> notice I also have 3rd hit type - INOBJ
18:27:09 <EmielRegis> thats why i wouldnt like to use Bool
18:27:21 <Adamant> I'm not Canadian enough to appreciate hockey
18:27:41 <lispy> EmielRegis: having your own type is a good idea.  Relateding it to Maybe was just a menta crutch for me to understand it
18:27:51 <ivanm> Adamant: I just saw that on the disambiguation page, and figured it'd be the most useless meaning of SNL there ;-)
18:27:51 <Twey> ivanm: You can go and report them in #freenode
18:27:56 <ivanm> Twey: *nod*
18:28:05 <bbs> quick question
18:28:10 <ivanm> Twey: IMHO, sjanssen kicked him, so he can report him ;-)
18:28:14 <bbs> actually i should paste it first
18:28:22 <Twey> 022423 -!-  channels : ##politics #rubyonrails #mysql #archlinux ##c #Django #perl ##c++ ##php ##linux #debian #gentoo
18:28:26 <Twey> Heh
18:28:29 <Twey> Oh, gone now.
18:28:35 <Twey> Must've done spamming.
18:28:49 <DustyDingo> is there a convention, how i refer to a function from a module?
18:29:00 <DustyDingo> like Prelude.isEqual?
18:29:03 <bbs> http://hpaste.org/12119
18:29:05 <ivanm> Twey: I wonder why he figured geeks would care...
18:29:11 <bbs> how can i better define primes?
18:29:13 <bbs> like
18:29:14 <ivanm> DustyDingo: that's one way of doing it
18:29:18 <sjanssen> DustyDingo: Modulename.functionname
18:29:34 <ivanm> or else you can just import the module, in which case you just do isEqual
18:29:43 <ivanm> (note that the Prelude is implicitly imported)
18:29:55 <Twey> ivanm: *shakes head*
18:30:03 <Twey> Looks familiar somehow
18:30:15 <Twey> I think this one might have spammed here before
18:30:20 <ivanm> hmmm....
18:30:30 <lispy> Twey: the message looks the same one I saw here recently
18:30:39 <sjanssen> Twey: we've certainly seen similar messages
18:30:41 * lispy shrugs
18:30:58 <EmielRegis> lispy, my point was that would it be a real peformance gain to return Hit datatype with MISS and HIT Float rather than returning (Hit,Float) with 0.0 for misses?
18:30:59 <DustyDingo> ah, i actually didn't asked for how to use it without importing,... just how to refer to it, when i write normal text, thats why i ment "convention" ;)
18:31:08 <DustyDingo> but thats ok than,...
18:31:37 <Philonous> bbs: You can't make a lazy language more lazy by creating explicit thunks.
18:32:58 <lispy> EmielRegis: I can't tell.  (,) comes with interesting performance consequences, so do custom data types.  It's not at all clear to me how to navigate the trade offs until you have working code that you can benchmark
18:33:42 <Philonous> bbs: I mean those lambdas \() -> ... aren't really necessary
18:34:08 <bbs> Philonous: i know
18:34:10 <bbs> but they are in this case
18:34:14 <Twey> Who was it who wanted to use XSLT as a templating system?  EvilTerran?
18:34:16 <bbs> because haskell is already lazy
18:34:23 <bbs> Philonous: its just an assignemtn
18:34:30 <bbs> my question is how to make primes work that way
18:34:32 <Philonous> Ok then
18:34:34 <bbs> i know how to make it work normmally
18:34:39 <Twey> bbs: Eh?
18:34:44 <lispy> EmielRegis: My experience has shown that when developing with Haskell it pays to be fully expressive in your types, get a working programming, then worry about optimizing.  Usually by that point you're ahead of schedule and you can use the extra time to figure out how to improve your algorithms and often the low level details of optimization just don't matter.
18:34:46 <bbs> Twey: see post
18:34:53 <bbs> did you see my .hs?
18:34:54 <Twey> They're *unnecessary* because Haskell is already lazy
18:35:05 <Twey> Yes
18:35:06 <bbs> Twey: the assignment is showing laziness
18:35:08 <EmielRegis> fair enough
18:35:19 <bbs> however stupid that may be ; i'll agree
18:35:19 <Twey> (\() -> x) () â¡ x
18:35:22 <bbs> but it wasn't my choice
18:35:28 <bbs> Twey: ?
18:35:29 <Twey> You're not showing laziness :-P
18:35:37 <Twey> It's just redundancy
18:35:50 <bbs> Twey: i've done the assignment right
18:35:56 <lispy> > take 10 $ fix show -- this is showing some laziness
18:35:57 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\"
18:35:59 <bbs> can we please not argue this -- i just wnat to discuss how to do this
18:36:08 <SamB> Twey: I guess the teacher doesn't understand the assignment ?
18:36:18 <Twey> *shakes head*
18:36:20 <Twey> SamB: Seems so
18:36:38 <lispy> SamB: Oh, good, I thought we would have this discussion without any smartass comments.  But I see you're here now ;)
18:36:46 <bbs> i don't get why you guys are making fun of me for no reason
18:36:51 <ivanm> lispy: are you the teacher? :o
18:36:53 <Twey> bbs: We aren't
18:37:09 <ivanm> bbs: they're not... they _have_ a reason :p
18:37:19 <Twey> And we weren't making fun
18:37:31 <lispy> ivanm: depends on if you're going to give me a professor's salary or not ;)
18:37:33 <Twey> Just pointing out why it's, well, pointless :-\
18:37:38 <ivanm> lispy: heh
18:37:42 <Philonous> :t (:::)
18:37:42 <lambdabot> Not in scope: data constructor `:::'
18:37:50 <ivanm> @hoogle :::
18:37:50 <lambdabot> Parse error:
18:37:50 <lambdabot>   --count=20 :::
18:37:50 <lambdabot>              ^
18:37:53 <Twey> Like SamB says, it sounds like your teacher doesn't really understand the assignment they've set
18:37:55 <ivanm> :o
18:37:59 <lispy> No no, pointless code is like this, take 10 . map foo bar
18:38:02 <ivanm> @hoogle (:::)
18:38:02 <lambdabot> Warning: Unknown type :::
18:38:02 <lambdabot> Prelude undefined :: a
18:38:02 <lambdabot> Data.Array.Base arrEleBottom :: a
18:38:14 <Twey> lambdabot: That's point-free :-P
18:38:18 <Twey> Er, lispy
18:38:20 <ivanm> lispy: does that even type-check?
18:38:42 <Twey> :t undefined
18:38:43 <lambdabot> forall a. a
18:38:46 <arw> bbs: lazy sum breaks this program: http://pbot.rmdir.de/eeca6c794f60caf363d48262e8e6818d (just feed a very large textfile into it to see that)
18:38:56 <ivanm> @type \f b -> take 10 . map f b
18:38:57 <lambdabot>     Couldn't match expected type `a -> [a1]'
18:38:57 <lambdabot>            against inferred type `[b]'
18:38:57 <lambdabot>     In the second argument of `(.)', namely `map f b'
18:39:00 <Philonous> bbs: Have you defined (:::) somewhere?
18:39:41 <lispy> oh right my example was poorly typed
18:39:51 <lispy> head . map
18:39:53 <lispy> better?
18:39:56 <lispy> :t head . map
18:39:56 <lambdabot>     Couldn't match expected type `[a]'
18:39:56 <lambdabot>            against inferred type `[a1] -> [b]'
18:39:56 <lambdabot>     Probable cause: `map' is applied to too few arguments
18:39:57 <bbs> Twey: it is pointless :*
18:40:02 <bbs> s/:*/:(
18:40:03 <ivanm> lispy: head . map succ
18:40:04 <lispy> apparently its'n to better
18:40:05 <Twey> ivanm: It's here:
18:40:07 <Twey> data Seq a = Nil  | a ::: (() -> Seq a)
18:40:24 <ivanm> Twey: hmmm? Philonous was the one asking...
18:40:26 <bbs> there is no reason for that
18:40:27 <Twey> And/or Philonous
18:40:30 <bbs> it should just be Seq a
18:40:31 <ivanm> heh
18:40:31 <bbs> i know
18:40:32 <bbs> :/
18:40:44 <Twey> :)
18:40:47 <Philonous> Ah right
18:41:26 <bbs> is there something that defines odds in prelude?
18:41:32 <bbs> so i don't have to write that silly one too
18:41:34 <lispy> :t odd
18:41:35 <lambdabot> forall a. (Integral a) => a -> Bool
18:41:43 <bbs> > take 2 odd
18:41:44 <lambdabot>   Couldn't match expected type `[a]'
18:41:48 <bbs> > take 20 odd
18:41:50 <lambdabot>   Couldn't match expected type `[a]'
18:41:52 <bbs> fu lambdabot
18:42:02 <lispy> > filter odd [1..]
18:42:03 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
18:42:06 <SamB> bbs: how about you write it correctly and show that it works fine?
18:42:10 <Twey> odds (x:_:xs) = x : odds xs; odds _ = []
18:42:18 <SamB> actually, the other way will have worst space behaviour ...
18:42:23 <SamB> s/worst/worse/
18:42:33 <schoenfinkel> > [1,3,5..]
18:42:34 <lambdabot>   <no location info>: parse error on input `..'
18:42:39 <Twey> > let odds (x:_:xs) = x : odds xs; odds _ = [] in odds [1..10]
18:42:40 <lambdabot>   [1,3,5,7,9]
18:42:46 <Saizan_> > [1,3..]
18:42:47 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
18:42:50 <schoenfinkel> right
18:43:29 <bbs> i'll get it
18:44:14 <SamB> well, could
18:44:14 <bbs> SamB: i'm no pro
18:44:18 <bbs> i'm new to haskell
18:44:19 <SamB> depending on optimization
18:44:31 <SamB> well, your teachers seem to be newer ;-P
18:44:59 <Twey> Heh, aye
18:45:16 <Twey> It looks like they think Haskell is strict...
18:45:19 <lispy> we should put a ban on teaching Haskell
18:45:33 <Twey> lispy: No, just an exam you have to pass first
18:45:40 <SamB> yeah, certification
18:45:47 <ivanm> Twey: maybe they're actually using a strict variant of haskell, and getting the students to make it lazy again?
18:45:56 <SamB> and acreditation
18:45:59 <Philonous> bbs: http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell) This is a pretty decent implementation of the primes, and it appears you have most of what you need to translate it to your implementation
18:46:02 <lambdabot> Title: Sieve of Eratosthenes (Haskell - LiteratePrograms
18:46:10 <Twey> ivanm: A strict version of Haskell isn't really Haskell :-P
18:46:16 <ivanm> Twey: yeah, I know
18:46:21 <Saizan_> maybe they just think that you'll understand lazy eval better by emulating it..
18:46:27 <ivanm> but I did say _variant_
18:46:30 <Saizan_> but doing so in haskell is a bit silly
18:46:33 <lispy> A strict variant of haskell?  oh you mean ML ? ;)
18:46:33 <ivanm> more likely, they had the curriculum in some other language (e.g. following SICP), and then changed language?
18:46:37 <ivanm> lispy: lol
18:46:50 <Twey> P'raps
18:47:19 <daf> hmm
18:47:33 <daf> is there a better way to do a section on (-) than e.g. (flip (-) 1)
18:47:36 <Saizan_> http://r6.ca/blog/20081116T213644Z.html <-- great post, btw :)
18:47:37 <lambdabot> Title: Haskell Lesson
18:47:43 <lispy> daf: subtract
18:47:44 <ivanm> daf: subtract
18:47:55 <lispy> ?quote fugue
18:47:55 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
18:48:01 <ivanm> heh
18:48:11 <ivanm> this is opposed to the stereo quotes?
18:48:16 <daf> ah
18:48:22 <SamB> @quote stereo
18:48:22 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
18:48:24 <SamB> @quote stereo
18:48:25 <lambdabot> greeting says: Welcome to #haskell where your questions are answered in glorious stereo!
18:48:33 <sclv> I hate the - thing. Every time I want negate it gives me subtract and every time I give subtract it gives me negate.
18:48:36 <ivanm> SamB: yeah, that one
18:48:43 <sclv> want subtract that is.
18:48:52 <daf> yeah, it's disappointing
18:49:03 <SamB> sclv: well, just remember that you can't take the section of - that you want
18:49:15 <schoenfinkel> This attack on the teahers seems wrong, doesn't it?  why shouldn't they use haskell as the underlying language for exhibiting lots of distinctions, people write Haskell interpreters in Haskell, for example, why not ML too, and so forth?
18:49:25 <ivanm> sclv: unfortunately, most keyboards (and AFAIK, most encodings) fail to differentiate between the subtraction and negation characters
18:49:34 <SamB> schoenfinkel: uh, what?
18:49:47 <ivanm> schoenfinkel: AFAICT, the attack was on the teacher forcing them to implement laziness in a lazy language
18:49:52 <schoenfinkel> I couldn't follow the problem he was supposed to sove
18:49:55 <schoenfinkel> quite
18:49:57 <SamB> if they are actually teaching Haskell, they probably ought to have learned it first
18:50:06 <DustyDingo> ok, strange question
18:50:07 <SamB> if they aren't, they should have told their students that
18:50:21 <lispy> DustyDingo: strange answer
18:50:29 <schoenfinkel> Suppose Haskell was the only programming language there had ever been
18:50:32 <ivanm> DustyDingo: nonexistent question?
18:50:40 <DustyDingo> i have a batch file for hugs, where i want to print the command i enter
18:50:43 <schoenfinkel> I might want to give people the idea of strict evaluation
18:50:45 <DustyDingo> and then execute it
18:50:49 <ivanm> schoenfinkel: yes
18:50:57 <bbs> Philonous: awesome.
18:50:58 <DustyDingo> so i tried for e.g.: putStrLn " isPic (bpic 1) "  >>  isPic (bpic 1)
18:51:03 <schoenfinkel> So I do something complicated that shows strict v. lazy
18:51:04 <Spark> the students should be smart enough to do a stupid coursework
18:51:05 <ivanm> but you don't re-write strict eval in a strict language
18:51:09 <ivanm> it just does it
18:51:10 <schoenfinkel> that's the problem he was put
18:51:15 <substack> you could use perl6 ;)
18:51:22 <DustyDingo> but the problem is, that doesn't work for all functions
18:51:30 <schoenfinkel> Yeah, but they're learning everything in Haskell
18:51:41 <DustyDingo> it works for those, which return IO(), but not for any other
18:51:59 <ivanm> schoenfinkel: when you learnt C/Java/whatever, did you learn strict evaluation by defining strict evaluation in that language?
18:52:13 <ivanm> DustyDingo: because that's all it works for ;-)
18:52:15 <Saizan_> DustyDingo: for pure ones you want to wrap them in something like "print"
18:52:16 <schoenfinkel> No you could only learn it
18:52:23 <schoenfinkel> by learning strict v. lazy
18:52:37 <schoenfinkel> that is, by developing the opposition, neither would be in the form given by the language
18:52:43 <ivanm> schoenfinkel: so why should you learn lazy evaluation by defining lazy evaluation in a lazy language?
18:52:58 <arw> almost. there are cases, where java and c are lazy.
18:53:07 <SamB> schoenfinkel: I don't understand you ...
18:53:09 <arw> like foo() || bar()
18:53:19 <schoenfinkel> No, he's learning it by learning strict versus lazy; and by developing the two different things in one language
18:53:24 <schoenfinkel> It happens that it is lazy
18:53:34 <ivanm> arw: and there are cases where haskell is strict (though you usually have to be explicit about it)
18:53:39 <DustyDingo> Saizan_: ahm that could work
18:53:46 <substack> is short circuiting even in the c standard?
18:53:50 <te> Could someone let me know where I can find the stm library?  I'm on ubuntu and I'm hunting through packages and don't see it.
18:53:54 <lispy> substack: of course
18:53:54 <schoenfinkel> I take it that that would be forbidden, then the problem would be trivial
18:53:54 <te> Am I missing something here?
18:53:54 <SamB> schoenfinkel: that ... does NOT make sense
18:54:00 * substack couldn't remember
18:54:05 <ivanm> te: it comes with GHC
18:54:07 <substack> lots of c just kind of happened
18:54:09 <ivanm> if you have a new enough GHC, that is
18:54:12 <bbs> Philonous: hehe i have that
18:54:19 <ivanm> or else you can get it off hackage
18:54:19 <te> ivanm: hm, im running 6.8.2-2
18:54:21 <bbs> it just has to be done in this rediculous format
18:54:25 <ivanm> that should have it AFAIK
18:54:33 <te> yeah, it's asking for it still
18:54:34 <te> :\
18:54:34 <ivanm> te: try this: ghc-pkg list
18:54:38 * Twey twitches.
18:54:39 <Philonous> Maybe it is not completely unreasonable to show how to simulate lazyness for it would definitly take longer to introduce ML for that purpose. But it is at least strange
18:54:52 <DustyDingo> Saizan_: need to autogenerate homework report with make ;)
18:55:01 <te> ivanm: no stm
18:55:04 <lispy> The main place that C is lazy isn't && and || though.  It's the place between sequence poits.
18:55:04 <Saizan_> wasn't stm in base?
18:55:07 <SamB> Philonous: they could have just done it in scheme ;-P
18:55:07 <lispy> points*
18:55:13 <ivanm> te: in that case, you can probably install it off hackage
18:55:15 <substack> just say, "look: head [1..]. magic!"
18:55:23 <te> ivanm: i've never done this before
18:55:29 <te> is that just a website?
18:55:32 <ivanm> yes
18:55:34 <ivanm> @hackage stm
18:55:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stm
18:55:52 <Philonous> My Prof would surely have done it in Java...
18:55:52 <DustyDingo> Saizan_: the horrible thing is, in the end i write more bash than haskell :)
18:55:55 <ivanm> te: it will probably be easier if there are ubuntu packages for cabal-install available
18:55:58 <substack> proof by magic!
18:56:08 <te> ivanm: i'll look quic
18:56:10 <te> quick
18:56:16 <Saizan_> te: libghc6-stm-dev probably
18:56:22 <SamB> DustyDingo: the solution is to switch to zsh
18:56:25 <te> Saizan_: no dice
18:56:33 <DustyDingo> SamB: propably
18:56:34 <SamB> then you won't need to write bash anymore ;-P
18:56:35 * Twey chuckles.
18:56:37 <te> ivanm: haskell-devscripts?
18:56:42 * te tries it
18:56:45 <ivanm> te: no idea ;-)
18:56:52 <ivanm> use the package Saizan_ told you
18:57:15 * ivanm can't understand the stupid package layout used in distros like debian, ubuntu, fedora, etc.
18:57:19 <te> it doesn't exist ivanm
18:57:24 <Philonous> bbs: Btw. 0 is not a prime
18:57:25 <substack> http://www.mdarwin.ca/humour/proofs-from-ta.phtml
18:57:27 <lambdabot> Title: Proofs Your T.A. Never Showed You
18:57:32 <lispy> ivanm: stupid in which ways?
18:57:54 <ivanm> lispy: the whole appending "-dev" to packages
18:58:07 <SamB> ivan: what makes that stupid ?
18:58:09 <ivanm> and calling it libghc6-stm rather than stm (or haskell-stm)
18:58:21 <SamB> ivanm: it only works for GHC though
18:58:26 <te> ivanm: okay i grabbed it off hackage
18:58:28 <ivanm> SamB: because that's not the actual name of that library?
18:58:31 <te> im in the dir, what should i run?
18:58:33 <te> to install this lib
18:58:39 <ivan> ivanm: sorry to ruin your tab completion stuff
18:58:58 <ivanm> ivan: so you should be!
18:59:04 <ivanm> not to mention stealing the nick I wanted! ;-)
18:59:11 <ivan> i've stolen this one back at least 3 times
18:59:43 <lispy> ivanm: I do agree that the way debian packages GHC is suboptimal. But, I'm told they have good reason for splicing it up into bits.
18:59:44 <ivanm> well, it was taken when I started using IRC a few years ago, so I appended the initial of my surname
18:59:57 <SamB> ivanm: the package doesn't contain the Haskell package in an abstract sense
19:00:30 <ivanm> lispy: I might be biased, but I prefer USE flags to "let's rebuild it numerous multiple times with different compile options and give each build a different but similar package name" :s
19:00:33 <Saizan_> te: runghc Setup configure; runghc Setup build; sudo runghc Setup install
19:00:36 <ivanm> SamB: in what way?
19:00:37 <lispy> I stopped using the debian packaged GHC and a lot of my grievances went away.  Imagine that.
19:00:46 <SamB> it contains the highly-GHC-version-specific .o and .hi files
19:00:48 <ivanm> lispy: lol
19:00:54 <ivanm> SamB: ahhhhh
19:01:03 <ivanm> source-based package management ftw! ;-)
19:01:29 <lispy> source-based package management for the oh wait...just a second, it's going to take another hour to build this...
19:01:44 <ivanm> heh
19:01:54 <Plouj> @pl \x y -> x y
19:01:54 <lambdabot> id
19:02:02 <ivanm> haskell packages (with the exception of gtk2hs) build rather quickly
19:02:16 <lispy> ivanm: ghc is another very notable exception to that
19:02:18 <mm_freak_> i don't have a windows system to test hereâ¦  when installing GHC at C:\GHC, where do i find GHCi?
19:02:19 <Plouj> @pl \f g _> filter f . map g
19:02:19 <lambdabot> (line 1, column 7):
19:02:19 <lambdabot> unexpected ">"
19:02:19 <lambdabot> expecting pattern or "->"
19:02:22 <DustyDingo> hm, putStr(show(foo)) does exactly what i want
19:02:24 <Plouj> @pl \f g -> filter f . map g
19:02:24 <lambdabot> (. map) . (.) . filter
19:02:34 <lispy> ivanm: I haven't built it from source recently, but on my last mac it took 10+ hours
19:02:36 <Saizan_> haskell binaries just take ages to link on my machine
19:02:38 <Plouj> @pl (. map) . (.) . filter
19:02:38 <lambdabot> (. map) . (.) . filter
19:02:42 <SamB> ivanm: your package manager would still need to know what implementation to build it for
19:02:44 <SamB> if any
19:02:51 <DustyDingo> but is there a show, which would also work for IO()?
19:02:57 <Plouj> @pl \f g l -> filter f (map g l)
19:02:57 <lambdabot> (. map) . (.) . filter
19:03:10 <ivanm> SamB: just rebuild all haskell libs after upgrading ghc *shrug*
19:03:19 <lispy> > show (return () :: IO ())
19:03:19 <mm_freak_> DustyDingo: print
19:03:20 <lambdabot>   "* Exception: "<IO ()>"
19:03:23 <ivanm> lispy: true
19:03:29 <DustyDingo> mm_freak_: print adds a newline
19:03:36 <DustyDingo> and print can't print IO afaik
19:03:43 <Twey> DustyDingo: show does work for IO ()
19:03:45 <ivanm> takes about 30 minutes here though
19:03:46 <mm_freak_> DustyDingo: then noâ¦  and IO actions can't be printed
19:03:47 <ivanm> \o/
19:03:52 <Plouj> that's so convoluted...
19:04:29 <Plouj> what I learned today is that I don't point-free functions
19:04:56 <ivanm> Plouj: generally, you don't _entirely_ point-free your functions
19:05:01 <Saizan_> ?type \f g -> filter f . map g
19:05:01 <lambdabot> forall a b. (b -> Bool) -> (a -> b) -> [a] -> [b]
19:05:09 <DustyDingo> any good idea, how to do that?
19:05:09 <Twey> What you *should* have learnt today is that you should only point-free your functions if they look nicer point-free. :)
19:05:10 <ivanm> @pl \g l -> filter f (map g l)
19:05:10 <lambdabot> (filter f .) . map
19:05:13 <ivanm> @pl \l -> filter f (map g l)
19:05:13 <lambdabot> filter f . map g
19:05:19 <Twey> DustyDingo: What do you actually want to do?
19:05:23 <ivanm> Plouj: ^^ pick the variant that suits you best
19:05:27 <DustyDingo> for e.g. can i write a generic function, which can tes the type?
19:05:36 <DustyDingo> like, for IO() do this for any other do that
19:05:40 <ivanm> DustyDingo: not really....
19:05:51 <ivanm> there is typable stuff, but it's not that easy to use
19:05:52 <Twey> What type would that have?
19:05:57 <Saizan_> DustyDingo: you can make an instance of Show for IO
19:06:08 <ivanm> and you then lose one of the main benefits of Haskell: static typing picking up compile-time errors
19:06:29 <DustyDingo> Saizan_: that gets overloaded if defined in the same module?
19:06:32 * ivanm still remembers spending ages trying to track down a bug that resulted from the wrong % item in a printf string :s
19:06:42 <Saizan_> DustyDingo: it will look like instance Show (IO ()) where show _ = "IO ()"
19:07:02 <Saizan_> DustyDingo: typeclasses is how haskell does overloading
19:07:09 <schoenfinkel>   Union College CSc 370. Programming Languages (Fall, Hemmendinger). An introduction to issues in programming language design and implementation. Major programming language paradigms: functional, logic, and object-oriented, and their use. Prerequisites: CSc 150(140) and Math 197.  Math 436. (170) Topology (Not offered 2007-08). Topological spaces, connectedness, compactness, continuous mappings and homeomorphisms. Prereq
19:07:13 <DustyDingo> Saizan_: ok
19:07:37 <ivanm> schoenfinkel: any particular reason for the subject selection spam? ;-)
19:07:41 <heatsink> Speaking of which, I learned recently that Concepts are how C++ does typeclasses.
19:07:50 <Saizan_> ..except Show (IO ()) is not h98, but Show (IO a) is
19:07:53 <Plouj> @pl f l = l ++ map f l
19:07:53 <lambdabot> f = fix (ap (++) . map)
19:07:59 <Plouj> @pl \f l -> l ++ map f l
19:08:00 <lambdabot> ap (++) . map
19:08:00 <schoenfinkel> this is the course, Im trying to figure out if they could be as stupid as you guys were making out
19:08:00 <cads> schoenfinkel, sounds like a fun little introductory course
19:08:03 <schoenfinkel> yeah
19:08:35 <ivanm> schoenfinkel: they're making bbs implement laziness in a lazy language
19:08:38 <schoenfinkel> my point above wasnt too clear.  Surely the following problem make sense... it wasnt the one put to them ....
19:08:39 <ivanm> I still call that crazy
19:08:42 <Twey> schoenfinkel: Never underestimate potential stupidity of people.
19:08:57 <ivanm> @remember Twey Never underestimate potential stupidity of people.
19:08:57 <lambdabot> I will remember.
19:08:59 <schoenfinkel> here is a specification of a miniature lazy language..... write an interpreter
19:09:11 <schoenfinkel> here is a spec of a miniature strict one, write an interpreter
19:09:14 <ivanm> schoenfinkel: but from what bbs was saying, that wasn't it at all
19:09:15 <schoenfinkel> does that make sense
19:09:20 <ivanm> he had to implement laziness in Haskell
19:09:22 <schoenfinkel> no that wasnt it, as i said
19:09:25 <Plouj> well, the general problem is that I don't get how to remove "points" from functions and what points are
19:09:35 <Plouj> anyone have a good link to a tutorial that can help me?
19:09:42 <schoenfinkel> thats true, but I think he just wasn't communicating what the problem was
19:09:43 <Twey> Well, no, it's not just 'implementing laziness in Haskell'
19:09:46 <ivanm> Plouj: points == input parameters (roughly)
19:09:49 <ivanm> Twey: it wasn't?
19:09:52 <Twey> It's more a case of 'trying to force Haskell to be lazy'
19:09:55 * ivanm must have missed that bit
19:09:58 <Saizan_> Plouj: the points are the formal parameters
19:10:02 <ivanm> Plouj: the pointfree wiki page
19:10:21 <Philonous_> Plouj: Think math there. "The function f at point x is ...".
19:10:48 <mm_freak_> Plouj: if you have a function "subtractOne" and "square", then you can write the function "f x = (x-1)^2" as "f = square . subtractOne"
19:11:21 <mm_freak_> haskell allows you to write "square" as "(^2)" and "subtractOne" as "subtact 1":  f = (^2) . subtract 1
19:11:37 <ddarius> > let f = join (*) . subtract 1 in f x
19:11:39 <lambdabot>   (x - 1) * (x - 1)
19:11:45 <Philonous_> Poinless style is just like unix pipes reversed. You feed the output of one function into the input of the next function
19:11:53 <ddarius> > let f = (^2) . subtract 1 in f x
19:11:54 <lambdabot>   (x - 1) * (x - 1)
19:11:59 <ddarius> Doh
19:12:33 <ddarius> Philonous_: There's nothing special about composition or composition in that order.
19:12:44 <Twey> What're the rules for (-) again?
19:12:50 <ddarius> > let f = subtract 1 >>> (^2) in f x
19:12:51 <lambdabot>   (x - 1) * (x - 1)
19:12:53 <Twey> When is it negate, and when is it subtract?
19:12:57 <mm_freak_> Plouj: that's the first step in describing things in terms of what they are, instead of what they do to their input =)
19:13:05 <Twey> Hooray for arrows!
19:13:29 <twb> Lately I've been having problems with GHC 6.8 segfaulting when compiling Darcs' HashedIO.hs.  Could the "segfault" actually be the kernel OOM-killing the process, or out of space on /tmp (which is a ramdisk)?
19:13:37 <arw> Plouj: "pointed": f x = sin x, point-free: f = sin. the first tells you what f does to x. the latter tells you what transformation f is.
19:13:50 <cads> hey, you guys know of a semantic network type database that'd let you define functions like 'is a name of an animal', which would be able to sort natural strings according to their linguistic content?
19:13:54 <Plouj> ok, cool
19:14:05 <mm_freak_> in fact there is even a 'pure' approach to this, which is called 'function-level programming'
19:14:15 <Twey> cads: That's one of the goals of the Semantic Web, I believe
19:14:16 <mm_freak_> 'pure' in that it doesn't even know about points
19:14:45 <Philonous_> ddarius: I'm not following
19:15:37 <ddarius> Philonous_: Pointless style is not just like unix pipes reversed.
19:16:20 <cads> Twey, can that be used in fun little projects? I want to use it to separate pictures called "cute kitten" and "herd of zebras" from the rest of the pictures in my pictures folder :D
19:16:31 <Philonous_> Right. I actually meant functional composition. Never mind.
19:16:42 <Twey> It's a little bigger than that :-P
19:16:57 <Twey> You could maybe try LogicT or, hey, Prolog or Curry
19:17:06 <arw> unix pipes compare to function composition. like print . head . sort compares to sort | head -n 1 | cat
19:18:10 <Twey> Arrows are more direct, because the order is the same :)
19:18:16 <Twey> sort >>> head >>> print
19:18:27 <arw> twb: the oomkiller logs to dmesg, so you should look there.
19:19:28 <arw> twb: but SIGSEGV ist not the signal used there, so probably its something else, like full /tmp and poor handling of that.
19:21:30 <arw> on intel segv is also the signal you get for an alignment error (which can occur only in sse and mmx instructions). does ghc use those instruction sets?
19:21:38 <cads> Twey, I think my AI book uses logic programming for natural language processing. I'll see what it says. And wow, the semantic web actually sounds a little scary
19:22:42 <pizza__> good luck with that
19:22:49 <twb> arw: I just thought maybe GHC was misdiagnosing and misreporting the real problem
19:23:26 <arw> twb: no. segv is a signal the operating system sends you after you have caused a page fault for unmapped memory.
19:23:36 <twb> arw: I know what a segv is.
19:23:56 <twb> arw: as I say, I thought maybe GHC was lying because it was hitting an error *it* didn't understand.
19:24:12 <twb> e.g. an unexpected exit status from gcc or ld
19:24:26 <twb> But dmesg indicates it really is a segfault:
19:24:27 <twb> [16890.794686] ghc-6.8.2[13604]: segfault at 40400000 ip 40197cac sp bfd0fcbc error 4 in libc-2.7.so[40120000+155000]
19:24:28 <twb> [17294.244494] ghc-6.8.2[16151]: segfault at 40400000 ip 40197cac sp bf85c7fc error 4 in libc-2.7.so[40120000+155000]
19:25:12 <r0oter_> exit
19:25:12 <r0oter_> \exit
19:25:12 <r0oter_> \quit
19:25:20 <arw> reporting something else as a segfault would be really strange, because that would require using the appropriate signal handler for something else.
19:25:34 <twb> arw: it was just a wild guess
19:25:48 <twb> Since I'm just sitting here twiddling my thumbs running darcs trackdown
19:32:11 * twb wants http://bugs.darcs.net/issue1208
19:32:16 <lambdabot> Title: Issue 1208: wish: darcs trackdown --bisect - Darcs bug tracker
19:32:26 <topo> is haskell a new version of lisp?
19:32:58 <SethTisue> YES
19:33:04 <Saizan_> more like a new version of ML
19:33:14 <ivanm> Saizan_: is it?
19:33:21 <heatsink> yup
19:33:47 <heatsink> it's in the family of languages derived from ML, which was originally written for writing strategies for theorem provers.
19:33:55 <topo> what ML?>
19:34:03 <twb> heatsink: I thought ML was written to write compilers
19:34:15 <topo> but is there any relation between haskell and lisp
19:34:20 <Saizan_> topo: haskell is quite different from LISP since it's purely functional and typed
19:34:29 <twb> Well, ISTR early ML implementations were written in Lisp.
19:34:42 <topo> ummmh
19:34:58 <Saizan_> topo: LISP is also seen as a functional language
19:35:00 <twb> Saizan_: Lisp supports FP and strict, static typing.
19:35:16 <twb> They are just "opt in"
19:35:21 <Saizan_> yeah
19:35:31 <Saizan_> lisp support pretty much everything :)
19:35:35 <topo> http://www.lisperati.com/fringedc.html
19:35:36 <lambdabot> Title: FringeDC- Users Of Fringe Programming Languages in the Washington DC Metro Area
19:35:46 <twb> In practice most Common Lisp seems to be object-oriented
19:35:50 <ivanm> Saizan_: hmmm.... is there any paradigm that lisp _doesn't_ support?
19:35:50 <Saizan_> the difference is in how the language is actually used
19:36:15 <lispy> Lisp is a programmable programming language for sure
19:36:16 <twb> Saizan_: btw, it's "Lisp" not "LISP" unless you're talking about historical dialects.
19:36:33 <lispy> But, static typing is a bit much...even with the inference than the CMU people came up with, it's not that great compared to Haskell.
19:36:34 <Saizan_> twb: thanks
19:37:00 <twb> lispy: inference is orthogonal to static typing
19:37:09 <twb> lispy: I'm speaking of (declare (type))
19:37:26 <Saizan_> yeah, inference is what makes static typing nice :)
19:37:31 <twb> Agreed.
19:37:38 <topo> haskell and lisp are in the space
19:37:44 <topo> like a alian language
19:37:50 <topo> alien
19:37:53 <twb> Although CL's ability to define types like "the integers between 2 and 14, inclusive" is sexy
19:38:30 <lispy> twb: may be orthogonal but in practice no one uses the type annotations so you need the inference if you want any usefulness from the few annotations that due appear
19:38:35 <ivanm> twb: :o
19:38:40 <topo> which is better? haskell or lisp?
19:38:45 <lispy> topo: yup
19:38:55 <lispy> topo: both is better
19:38:56 <ivanm> though if you really wanted to, couldn't you do the same with a custom instance of bounded?
19:39:04 <ivanm> lispy: s/is/are/
19:39:05 <ivanm> ;-)
19:39:11 <lispy> topo: but I caution you because both are worse too :(
19:39:17 <FunctorSalad> twb: sounds like dependent types
19:39:25 <topo> worse? in which sense?
19:39:47 <lispy> topo: well, you see both are better and both are worse.
19:39:54 <lispy> topo: clearly you should use either.
19:40:08 <heatsink> :)
19:40:08 <ivanm> topo: depending on what you want to do, one language might have some reason for being better than the other
19:40:20 <topo> i been experimenting with common lisp
19:40:21 <topo> i like a lot
19:40:31 <topo> i just wanna know which things can i do with haskell
19:40:39 <topo> do you think should i learn haskell?
19:40:48 <topo> or common lisp is enought?
19:40:51 <schoenfinkel> aren't you guys supposed to tell him that it will bring him closer to the mind of God?
19:41:10 <topo> is god a haskell programmer?
19:41:14 <twb> lispy: granted
19:41:17 <topo> i thought he was a lisp programmer
19:41:24 <schoenfinkel> Of course very lazy
19:41:24 <SethTisue> god is lazy, that's for sure
19:41:29 <ivanm> topo: who hacks things together in perl ;-)
19:41:31 <schoenfinkel> I beat you
19:41:33 <twb> lispy: although technically that's only an implementation issue, and can be fixed
19:41:35 <lispy> topo: I started with CL, spent a good amount of time in #lisp and I have moved here as a more or less permanent fixture if that is any indication
19:41:39 <topo> and the world is some kind of genetic programming simulation
19:41:40 <SethTisue> not on my screen :-)
19:41:59 <twb> #haskell has more people than #lisp and #scheme combined
19:42:12 <topo> why is that?
19:42:16 <FunctorSalad> all the cool kids are doing it
19:42:19 <FunctorSalad> =)
19:42:24 <topo> is it more comercial haskell?
19:42:27 <topo> more easy?
19:42:36 <SethTisue> no. no
19:42:36 <twb> topo: that depends on a lot of things
19:42:51 <twb> topo: have you already been mistrained to prefer OO?
19:43:02 <lispy> topo: experience varies, but I found that #haskell is an exceptionally intelligent place to converse with very friendly denizens.  #lisp simply couldn't compete.
19:43:07 <topo> ummmhh
19:43:09 <FunctorSalad> topo: we are just better at making people "change their mind" about leaving (kidding)
19:43:18 <twb> lispy: haha
19:43:42 <schoenfinkel> I don't know, i think bbs has left
19:43:43 <twb> lispy: that's because #haskell is both #lisp (people who are trying to work) and #scheme (people who are trying to teach/learn)
19:45:03 <topo> can you evolve code in haskell as common lisp?
19:45:18 <ivanm> topo: "evolve"? as in it writes itself?
19:45:29 <schoenfinkel> by natural selection?
19:45:35 <quix> my connection went bad -- did someone respond to my (length [1,2])/2 question?
19:45:36 <lispy> topo: yes, and I find it's actually easier in Haskell because the type system helps keepr refactorings honest
19:45:59 <lispy> topo: you can use ghci, for example, to experiment
19:46:04 <SethTisue> by "evolve" in Lisp, i assume you mean "you can change something in the code and it will still compile, but not work"
19:46:11 <topo> in common lisp programs are trees and you have access to those trees so its very good for recombining programs, selection, crossover and mutation of programms
19:46:24 <lispy> topo: also, I find that ghci encourages the healthy habbit of flushing all the old definitions from memory when you reload...this has saved me considerable time
19:46:47 <topo> very easy to evolve programs
19:46:48 <lispy> topo: oh, in that regard, I'm not sure ... try liskell perhaps?
19:46:51 <lispy> ?where liskell
19:46:52 <lambdabot> http://clemens.endorphin.org/liskell
19:47:01 <SethTisue> the big Lisp thing that's missing in Haskell is macros
19:47:09 <FunctorSalad> SethTisue: TH?
19:47:25 <topo> liskell?
19:47:25 <topo> haha
19:47:31 <lispy> FunctorSalad: to simulate lisp macros you'd really need TH + haskell-src-exts
19:47:51 <lispy> FunctorSalad: then you've got yourself some macrology :)
19:47:55 <FunctorSalad> lispy: sorry I don't know the latter :(
19:47:59 <topo> lispy whats ghci?
19:48:12 <lispy> topo: ghc interactive mode, it's a REPL
19:48:19 <topo> ah ok
19:48:25 <lispy> FunctorSalad: a haskell parser
19:48:35 <topo> so you can do "on the fly programming" in haskell too?
19:48:37 <topo> as lisp?
19:48:38 <schoenfinkel> hugs is easier to download, if you want to fiddle with an interpreter
19:48:39 <lispy> FunctorSalad: my point was just that, with only TH you still don't have access to enough of the syntax tree...
19:49:06 <lispy> topo: someone made a library for that called hs-plugins.  You can dynamically load haskell code.  See lambdabot for more details
19:49:09 <lispy> ?version
19:49:09 <lambdabot> lambdabot 4.2.1
19:49:09 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:49:38 <FunctorSalad> lispy: you don't have access at all or the *Q data structures are to inconvenient?
19:49:43 <FunctorSalad> *too
19:50:23 <lispy> FunctorSalad: I forget.  In my case, I wanted to load a file, transform it's ast and splice it into a different module.  I used Language.Haskell and it worked like a charm
19:50:39 <SethTisue> I'll take a look at TH, thanks. but I assume most Haskell programmers don't use it
19:51:09 <lispy> SethTisue: right.  It's kinda heavy weight and there exist some platforms that it doesn't work on...on of the BSDs but I don't recall which
19:51:11 <FunctorSalad> SethTisue: it's relatively new. one nice application is Text.Printf.TH :)
19:51:31 <FunctorSalad> it parses the format string at compile-time, so no more printf runtime errors
19:51:58 <lispy> TH allows some forms of dependent typing
19:54:01 <FunctorSalad> lispy: you used Language.Haskell.Syntax rather than Language.Haskell.TH.Syntax?
19:54:37 <FunctorSalad> (btw, why this apparent duplication?)
19:56:06 <ivanm> FunctorSalad: you mean L.H.Syntax vs L.H.TH.Syntax?
19:56:36 <lispy> FunctorSalad: i did this back in the 6.4 days
19:57:05 <FunctorSalad> ivanm: I don't see the difference
19:57:15 <lispy> FunctorSalad: I couldn't find much documentation so I made a lot of it up...used unsafePerformIO where runIO would have worked, etc
19:57:45 <necroforest> Can a newtype take parameters? like newtype Foo a = (a, Int)
19:58:00 <heatsink> necroforest, yes, although that's not a valid newtype.
19:58:04 <necroforest> Or would it be better to use data Foo a = (a, Int)
19:58:23 <heatsink> newtype Foo a = Foo (a, int)
19:58:25 <ivanm> that won't work
19:58:38 <ivanm> type Foo a = (a,Int) -- this is valid
19:59:17 <necroforest> ah
19:59:17 <necroforest> thanks
20:00:15 <lispy> I recommend not using 'type' though.  It tends to obfuscate things more than it tends to help
20:00:26 <necroforest> If you want to use a type class like Eq would the syntax be 'type (Eq a) = (a, Int)'
20:00:49 <necroforest> ah, well I'm writing vector functions... so i was going to have type Vector t = (t, t)
20:01:15 <necroforest> would 'data Vector t = Vector (t, t)' be better?
20:01:32 <lispy> I would prefer, data Vector2 t = Vector2 t t
20:01:49 <ivanm> though newtype would work with the tuple
20:02:05 <necroforest> right
20:02:20 <lispy> newtype Vector t = V (t, t) -- okay, I can buy that if you really want tuples
20:02:21 <ivanm> necroforest: if you want to specify that only Eq types are allowed, there's an extension for that IIRC
20:02:32 <necroforest> ah ok
20:02:51 <ivanm> however, you're usually better off having the Eq requirement when you actually use the data structure
20:03:00 <ivanm> rather than restricting the data structure itself
20:03:17 <lispy> Yeah, it's now considered poor style to put the constraint on the data type
20:03:28 <lispy> People tried it and found it to be lackluster
20:03:34 <FunctorSalad> data Vector2 v where Vector2 :: (Eq v) => v -> v -> Vector2 v -- ?
20:03:34 <topo> lispy
20:03:37 <topo> do you know lisp?
20:03:40 <ivanm> necroforest: though in this case, not using the tuple is probably better: if you're using a constructor, why use a sub-constructor?
20:04:11 <necroforest> ivan, you're correct
20:04:14 <lispy> topo: I used to, but it's now been something like 4 years since I used it daily
20:04:19 <FunctorSalad> (maybe that can be written without gadt syntax though)
20:04:23 <topo> ah ok
20:04:43 <ivanm> lispy: though obviously you were a huge fan of lisp at one point ;-)
20:05:08 <lispy> FunctorSalad: yeah that's totally valid and works exactly like you'd want except that when someone hands you a Vector2, you don't know that v has an Eq istance until you look at the data constructor
20:05:13 <topo> lispy why you stop using lisp?
20:05:23 <lispy> topo: Haskell :)
20:05:35 <topo> do you like more haskell than lisp?
20:05:36 <lispy> topo: strong static typing is the main reason
20:05:55 <topo> whats wrong with dynamic typing?
20:05:58 <FunctorSalad> lispy: so the idea is that you need Eq v in the context of the other functions anyway, so you might as well leave it out from the data declaration?
20:06:41 <lispy> topo: run-time failure with no warning.  I'm lazy so I'll take all the bug removal help I can get
20:07:04 <lispy> FunctorSalad: I'm not following you.
20:07:14 <ivanm> lispy: and since you're lazy, you want a language that supports your personality defects and turns them into positives? ;-)
20:07:23 <ivanm> FunctorSalad: explicit > implicit
20:07:47 <lispy> FunctorSalad: when you have a GADT like Vector2 v, and you look at it from the type you know nothing about v.  It's not until you do a 'case' on the data constructor that you find out what's inside, and that goes for type class instances too.
20:07:53 <topo> ummmh
20:07:56 <lispy> FunctorSalad: the haskell type checker doesn't look at values
20:08:10 <lispy> ivanm: yeah, I think so
20:08:21 <topo> run-time failure with no warning, how static typing avoids that?
20:08:36 <FunctorSalad> lispy: ok, that's how I understood it too
20:08:42 <ivanm> topo: well, does it make sense to have String + Bool?
20:08:48 <lispy> topo: hang on, I'll get the slides to talk I gave recently
20:08:59 <ivanm> static typing can tell you at compile time that that doesn't make sense
20:09:04 <topo> ummmm
20:09:06 <lispy> topo: http://www.galois.com/~dons/slides/08-10-dagit.pdf
20:09:11 <lambdabot> Title: cache:http://www.galois.com/~dons/slides/08-10-dagit.pdf - Google Search
20:09:20 <ivanm> whereas with dynamic typing, that issue mightn't arise until a while into your complex computation and mean you've wasted hours of work
20:10:08 <topo> dynamic typing is in run time and static typing is at compile time?
20:10:11 <topo> thats the difference?
20:10:35 <ivanm> pretty much
20:10:43 <topo> static typing sounds more safe, but i suppose you pay a price for that
20:10:50 <ivanm> what's the link for that typing discussion that categorises them all
20:10:53 <topo> you lose "live coding" power
20:11:08 <ivanm> topo: there is a slight amount of flexibility in some cases
20:11:09 <lispy> topo: not really
20:11:23 <topo> i think that not good for agent congnitive systems or evolutive computing
20:11:24 <lispy> topo: and dynamic typing is very costly at run-time
20:11:28 <ivanm> but haskell's static typing > C's/Java's static typing
20:11:29 <topo> neither genetic programming
20:11:36 <topo> or on the fly manipulation of code
20:11:57 <ivanm> all hail polymorphism! ;-)
20:12:16 <topo> i think im gonna stay with common lisp
20:12:19 <topo> :P
20:12:34 <jeffz> topo, you could implement common lisp in haskell
20:12:59 <topo> for what? i think its a better idea to implement haskell in common lisp with macros
20:13:05 <jeffz> go for it.
20:13:15 <topo> so you can have haskell with common lisp power
20:13:29 <topo> i dont like static typing
20:13:34 <topo> im exploring the other side
20:13:38 <ivanm> *shrug* suit yourself
20:13:53 <gio123> topo: common lisp is cool
20:14:02 <topo> yes, i love it
20:14:05 <topo> :P
20:14:12 <ivanm> topo: http://www.pphsg.org/cdsmith/types.html
20:14:15 <gio123> topo: I too
20:14:18 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
20:14:27 <lispy> CL is fine, but it's not current with the state of the art.
20:14:58 <thoughtpolice> i think clojure looks cool
20:15:03 <thoughtpolice> but i'm pretty into static typing at this point
20:15:59 <topo> clojure is that lisp that run on virtual java machines isnt it?
20:16:17 <mmorrow> topo: just use unsafeCoerce. if your prog's correct you won't segfault ;)
20:16:22 <ivanm> topo: yeah
20:16:48 <thoughtpolice> topo: yes
20:17:31 <FunctorSalad> night :)
20:17:36 <topo> which is the difference between clojure and common lisp?
20:17:37 <topo> nite
20:17:59 <ivanm> topo: they're different languages ;-)
20:18:10 <heatsink> newtype Lisp = Nil | Cons Dynamic Dynamic
20:18:12 <topo> i just download
20:18:16 <heatsink> err
20:18:18 <topo> but i dont know how to run it
20:18:19 <heatsink> data Lisp = Nil | Cons Dynamic Dynamic
20:18:25 <topo> theres just a .jar
20:18:31 <thoughtpolice> topo: for real though, static typing can help you a lot. a well-typed program does not "go wrong", and being able to encode properties like e.g. handles cannot leak (so you cannot operate on a closed handle) in your types is great
20:18:31 <jeffz> topo: maybe you should ask in the clojure channel if you need help
20:18:32 <topo> but nothing happens when i try it
20:18:35 <topo> :P
20:18:41 <ivanm> topo: it runs on the jvm
20:18:55 <ivanm> you should probably ask on #clojure for more info ;-)
20:19:26 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"eval \\\"42\\\"\"") :: Integer
20:19:38 <tessier> p_l: What do you mean by "preparing it for easier reading"? PDF'ing it or something?
20:19:44 <lunabot>  42
20:19:48 <thoughtpolice> topo: there are more extreme cases of type safety, such as session types, which basically give you statically verified communication channels.
20:19:50 <topo> thoughtpolice it depends of what you want to do , sometimes there are more important things that  "go wrong"
20:20:01 <topo> for me it doesnt mind too much
20:20:28 <lispy> topo: if you read the slides i linked to you, you'd see some of the stuff you can 'make compile time safe' by using the type system
20:21:12 <lispy> topo: those slides are about the darcs version control system and how we made the internal code safer by using more of the type system
20:21:16 <topo> cool thanks
20:21:30 <mm_freak_> @pl \xs -> head xs : xs
20:21:30 <lambdabot> (:) =<< head
20:21:31 <mmorrow> , [toDyn "asdf", toDyn (show::Dynamic->String), toDyn [Left (), Right (7::Int)]]
20:21:32 <lispy> (and it works)
20:21:33 <lunabot>  [<<[Char]>>,<<Dynamic -> [Char]>>,<<[Either () Int]>>]
20:21:34 <topo> im downloading
20:21:38 <thoughtpolice> topo: sure, you can still hit a segfault, but the type system prevents a large class of errors and generally my programs do not fail at runtime (things like ffi bindings are a different can of worms) - types can prove a lot of things
20:22:04 <lispy> valid programs correspond to valid logics ;)
20:22:25 <topo> ummmh
20:22:55 <lispy> topo: http://en.wikipedia.org/wiki/Curry-Howard_correspondence
20:22:56 <lambdabot> Title: Curry-Howard correspondence - Wikipedia, the free encyclopedia
20:23:01 <mmorrow> topo: what is the expected behavior if you do (+ "asdfdsa" (* () 9)) ?
20:23:29 <mmorrow> that error handling has to be implemented somewhere
20:23:32 <topo> i think static typing is not good for self modying code or stuff like that, i dont mind to much if the programs fail
20:23:33 <lispy> topo: http://web.cecs.pdx.edu/~sheard/papers/PutCurryHoward2WorkFinalVersion.ps
20:23:35 <lambdabot> http://tinyurl.com/5ejvhl
20:23:43 <mmorrow> you can implement error handling in haskell easily
20:24:03 <thoughtpolice> let it be known: I have yet to move from haskell because I have yet to see a language that offers A) the same community, B) as flexible a type system, C) as many intellectually stimulating goodies.
20:24:07 <topo> self modifying code at run time
20:24:25 <topo> which is amazing
20:24:26 <topo> :P
20:24:28 <lispy> thoughtpolice: I do say you hit the nail on the head with that one good sir.
20:24:32 <thoughtpolice> in what instances do you /really/ need self modifying code?
20:24:33 <scodil> topo: you can probably do that with existential types
20:24:37 <mmorrow> topo: haskell does that easy. you can modify the machine code if you like: check out harpy
20:24:51 <topo> haha
20:25:02 <mmorrow> topo: here's a harpy example: http://code.haskell.org/~morrow/code/haskell/misc/fib.html
20:25:11 <jeffz> harpy's no good for x86-64 though :|
20:25:15 <topo> ok thanks
20:25:26 <mmorrow> here's a manual exec of a list of bytes: http://code.haskell.org/~morrow/code/haskell/misc/Call.html
20:25:32 <mmorrow> hello world!
20:25:36 <thoughtpolice> if there were alternative harpy backends for different architectures, that would be super greatness :]
20:26:08 <topo> wierd sintaxis has haskell
20:26:33 <mmorrow> thoughtpolice: totally
20:26:44 <topo> never saw something like that
20:26:49 <topo> is it concurrent?
20:26:51 <thoughtpolice> mmorrow: then you could use it to basically build a JIT compiler
20:27:12 <mmorrow> thoughtpolice: yeah, that'd be sweetness
20:27:25 <mmorrow> hmm
20:27:42 <necroforest> ok.. I have the following code: (+) (Vector x1 y1) (Vector x2 y2) = Vector (x1+x2) (y1+y2)
20:27:44 <thoughtpolice> mmorrow: one of the things I was thinking of recently was what if you had a haskell compiler that used harpy to execute the haskell code its given, and in the code generate calls back into haskell functions in the compiler, effectively writing your RTS for the compiler in haskell?
20:28:06 <necroforest> GHC says that (+) is "ambiguous".. but shouldn't it be valid since i'm defining it on different datatypes than in Prelude?
20:28:09 <thoughtpolice> it would be a neat experiment, I guess.
20:28:27 <scodil> necroforest: you have to make a Num instance for Vector
20:29:36 <necroforest> bah.. I don't think I can since (*) would be (*) :: Vector t -> Vector t -> t
20:29:48 <necroforest> (*) expects (*) :: a -> a -> a
20:29:50 <thoughtpolice> mmorrow: look here for an idea of what I mean - http://thoughtpolice.stringsandints.com/code/haskell/misc/harpy.hs
20:29:50 <mmorrow> thoughtpolice: that sounds very cool. yeah, i've been reading up on bytecode/VMs for haskell-like langs + linking stuff recently. i think really interesting stuff could be done if you can somehow manage to get the whole pipeline under control of haskell code.
20:29:51 <lambdabot> http://tinyurl.com/56xcz2
20:30:18 <heatsink> necroforest, you could use the vector-space library, which defines appropriate type classes for vectors.
20:30:34 <necroforest> heatsink, i'm trying to figure out how to do this on my own though :P
20:30:43 <necroforest> this is more for learning than for being practical
20:30:48 <heatsink> oh
20:30:52 <scodil> necroforest: yeah that's a bummer. you can just make (*) be an error and force yourself not to use it, or just make it component-wise. Or make a different class for vector spaces, or use one of the ones on hackage
20:30:57 <mmorrow> thoughtpolice: rad
20:31:07 <heatsink> Well, you can always define a different operator name like (^+^)
20:31:34 <thoughtpolice> mmorrow: yeah, the harpy gen'd code can just call back into haskell code for its RTS-like operations
20:31:36 <necroforest> If it was 3-space i'd just make (*) the cross product
20:33:01 <arw> does haskell support utf-8 operators?
20:33:13 <lispy> arw: ghc does
20:33:20 <lispy> I think anyway
20:33:33 <arw> then you could just use the "real" cross-product operator and be done with it :>
20:35:29 <mmorrow> thoughtpolice: interesting. have you seen http://www.cs.york.ac.uk/fp/darcs/ELF ? i think that + not /too/ much effort could produce a pure haskell linker
20:35:48 <bbs> anyone have a good classical music stream?
20:35:51 <bbs> its bed time :D
20:35:53 <mmorrow> (linker+loader)
20:37:06 <thoughtpolice> arw: http://thoughtpolice.stringsandints.com/code/haskell/misc/utf8-ident-test.hs.html
20:37:08 <mmorrow> foreign import ccall unsafe "sys/mman.h mmap" c_mmap :: .... :)
20:37:08 <lambdabot> Title: utf8-ident-test.hs, http://tinyurl.com/63wwfj
20:37:09 <thoughtpolice> it does :]
20:37:25 <mmorrow> PROT_EXEC
20:37:45 <arw> thoughtpolice: does that need any special compiler switches?
20:37:56 <thoughtpolice> arw: no
20:38:04 <scodil> thoughtpolice: better than that, you can use utf arrows for function types
20:38:10 <scodil> with a flag
20:38:51 <mmorrow> , let (â) = elem in 1 â [0..]
20:38:54 <lunabot>  True
20:39:15 <Twey> Isn't that in the Unicode prelude?
20:39:24 <mmorrow> i'd hope :)
20:40:13 <thoughtpolice> mmorrow: where is lunabot's source?
20:40:40 <lispy> can you use printf with lazy bytestrings?
20:40:49 <lispy> if so, what is the character you pass to printf?
20:41:37 <mmorrow> http://moonpatio.com/repos/luna/
20:41:40 <mmorrow> i've gotta fix up the bot.hs and it'd evaluator for the newest luna code, but all the evaluator is is
20:41:42 <lambdabot> Title: Index of /repos/luna
20:41:45 <arw> strange, i get strange, i get stats.hs:5:0: parse error on input `'
20:41:53 <mmorrow> System.Posix.Resource cpu+mem rlimits
20:42:01 <arw> for U+2211 as a function name (sum, aka â)
20:42:01 <mmorrow> and Luna.Eval.eval
20:42:05 <mmorrow> and that's it :)
20:42:24 <mmorrow> you could write it in about 20 lines
20:42:29 <arw> .oO( strange, i typed that before...)
20:42:46 <scodil> > f x y = 2*x+y :: Num a â a â a â a
20:42:47 <lambdabot>   <no location info>: parse error on input `='
20:42:47 <mmorrow> then throw your most hackish bot code on that et voila
20:42:57 <idnar> > let â = sum in â [1..10]
20:42:58 <lambdabot>   <no location info>: parse error on input `â'
20:42:58 <scodil> > \ x y -> 2*x+y :: Num a â a â a â a
20:43:00 <lambdabot>       Inferred type is less polymorphic than expected
20:43:00 <lambdabot>        Quantified type ...
20:43:15 <idnar> > let Ï = sum in Ï [1..10]
20:43:16 <lambdabot>   55
20:43:29 <mmorrow> > let (â) = sum in (â) [1..10]
20:43:30 <lambdabot>   55
20:43:35 <idnar> I guess it recognises uppercase sigma as uppercase
20:44:02 <mmorrow> i think that one's a diff sigma than the uppercase letter
20:44:06 <Twey> Because it is
20:44:07 <arw> thats not uppercase sigma, thats the sum-operator from the mathematical operator page.
20:44:13 <mmorrow> yeah
20:44:14 <Twey> Oh
20:44:27 <Twey> Î£â
20:44:29 <Twey> That's horrible :(
20:44:31 <idnar> well...
20:44:43 <idnar> hmm
20:44:58 <idnar> > let Î£ = sum in Î£ [1..10]
20:44:59 <lambdabot>   Not in scope: data constructor `Î£'Not in scope: data constructor `Î£'
20:45:00 <Twey> I know, I know, c'est la Unicode
20:45:11 <idnar> okay, I was still right, just for the wrong reasons :P
20:45:17 <Twey> > let Ï = sum in Ï [1 .. 10]
20:45:18 <lambdabot>   55
20:45:26 <mmorrow> idnar: love when that happens
20:45:49 <idnar> > let (â) = sum in â [1..10]
20:45:49 <lambdabot>   <no location info>: parse error on input `â'
20:45:52 <Twey> The mathematicians should adapt their notation to make it easier for we Haskellers.
20:45:54 <idnar> > let (â) = sum in (â) [1..10]
20:45:55 <lambdabot>   55
20:45:58 <idnar> tee hee
20:46:18 <idnar> unicode has such ridiculous characters
20:46:27 <scodil> Is that a steaming pile? I can't find that key on my keyboard
20:46:27 <mmorrow> > text . take 10 $ ['â'..]
20:46:28 <lambdabot>   ââââââââââ
20:46:35 <idnar> I mean, sure, UMBRELLA, whatever. but UMBRELLA WITH RAINDROPS? seriously?
20:46:42 <Twey> Hahaha
20:46:58 <idnar> sorry, RAIN DROPS (with the space)
20:47:29 <Twey> Hahaha, idnar
20:47:35 <scodil> yeah, "unbrella with raindrops" is a completely different glyph
20:47:41 <idnar> HOT SPRINGS: â¨
20:48:15 <arw> do you get UMBRELLA WITH RAINDROPS from COMPOSING UMBRELLA and RAINDROPS after normalization?
20:48:33 <idnar> WHITE SUN WITH RAYS: â¼
20:49:02 <Twey> COMPOSING UMBRELLA?
20:49:11 <Twey> There's a COMPOSING UMBRELLA?  :-P
20:49:26 <scodil> BLACKHOLE SUN: âº
20:49:29 <arw> i hope not.
20:49:50 <Twey> WTF.
20:49:59 <Lemmih> amz: Amen, brother.
20:50:00 <Twey> I wouldn't be surprised.
20:50:11 <Twey> Heh, aye
20:51:14 <pumpkin> idnar: that's clearly a bowl of ramen
20:52:01 <idnar> haha
20:54:52 <heatsink> I'm sure if you compose HOT SPRINGS it with the right character, you can get the Java logo.
20:55:10 <arw> there is HOT BEVERAGE somewhere...
20:55:31 <tessier> So I'm reading RWH http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html and every function ends with "deriving (Show)" and it seems they never mention what that means. It's like they hope we won't notice or something.
20:55:37 <lambdabot> Title: Chapter 3. Defining Types, Streamlining Functions, http://tinyurl.com/67rtex
20:55:57 <Pseudonym> tessier: Have you got to type classes yet?
20:56:03 <ivanm> tessier: it means that as far as possible, haskell will determine the "smart" way of printing that data structure
20:56:06 <idnar> arw: â
20:56:08 <Pseudonym> Yes.
20:56:18 <Pseudonym> It means that "show", or printing on the command line, works.
20:56:20 <Pseudonym> For example:
20:56:23 <arw> idnar: my font doesn't have that one.
20:56:26 <Pseudonym> > 1:2:3:[]
20:56:27 <lambdabot>   [1,2,3]
20:56:37 <tessier> Pseudonym: Ah.
20:56:40 <Pseudonym> That list is turned into a string for printing by the "show" function.
20:56:53 <tessier> Almost sounds like inheritance.
20:57:03 <Pseudonym> Almost!
20:57:14 <Pseudonym> You'll get to the relevant chapter soon enough...
20:57:15 <idnar> arw: aww
20:57:22 <idnar> arw: http://www.fileformat.info/info/unicode/char/2615/hot_beverage.svg
20:57:24 <lambdabot> http://tinyurl.com/5pmc38
20:57:42 <arw> ah, k.
20:57:47 <heatsink> I'm not sure if it's worth explaining to people that type classes are like concepts, because I don't know if C++ programmers can be expected to know what a "concept" is.
20:58:08 <lispy> Pseudonym: how's it going?
20:58:22 <arw> "type classes are like interfaces"?
20:58:29 <Pseudonym> lispy: OK.  Looking forward to a couple of weeks of unemployment.
20:58:33 <Pseudonym> You?
20:58:34 <lispy> Pseudonym: do you write about your data modeling adventures on your blog?  If so, what is the url again?
20:58:50 <lispy> Pseudonym: yeah, I'm looking forward to a vacation, but I can't take one right now :(
20:59:01 <idnar> âoâ
20:59:02 <Pseudonym> lispy: No, I don't.  But it's http://andrew.bromage.org/blog/ FWIW
20:59:06 <lambdabot> Title: The BWAIN
20:59:24 <Pseudonym> Oh, a vacation would be nice, but realistically, I wouldn't be able to afford it.
21:00:12 <lispy> Pseudonym: for me, vacation == not having to come into work
21:00:28 <Pseudonym> For me, vacation also entails not having to take the kids to school.
21:00:29 <lispy> Pseudonym: even if I just stay at home with a bag of cheetos I would feel better after a week :)
21:00:41 <Pseudonym> Or get them ready for it in the morning.
21:02:23 <lispy> haha (Fortran has the notion of a type, but it defaults to floating-point numbers. It has been said that in Fortran, God is REAL unless explicitly declared INTEGER.)  <-- nice
21:03:00 <Pseudonym> ?go "god is real unless" fortran
21:03:02 <lambdabot> http://en.wikiquote.org/wiki/Programming
21:03:02 <lambdabot> Title: Programming - Wikiquote
21:03:03 <twb> lispy: it defaults to floating point except for names starting with i, j, k or l, IIRC
21:03:05 <Pseudonym> There you go.
21:03:07 <arw> that is not entirely true.
21:03:33 * lispy has used Fortran enough to get the joke though
21:03:42 <Pseudonym> But GOD would be REAL.
21:04:01 <arw> one-letter variables are integer from I to N, the rest is real...
21:07:42 <bbs> night
21:36:39 <xenoterracide> I'd think this would be in :? but... how do I quit ghci
21:36:49 <heatsink> :quit
21:37:04 <xenoterracide> ah thanks... I see it is there must have scrolled past it
21:37:08 <heatsink> or Ctrl-D
21:37:29 <Axman6> or just :q
21:37:42 <heatsink> Don't stick your tongue out at me.
21:37:55 <Axman6> :|
21:39:24 <xenoterracide> heh
21:39:36 <xenoterracide> I think that would be licking his nose
21:39:41 <xenoterracide> :P
21:40:36 <Axman6> mmmm
21:40:39 <heatsink> oh yeah, sorry.
21:40:49 <Axman6> :B
21:58:51 <Axman6> > foldl (flip (:)) [a,b,d] :: Expr
21:58:52 <lambdabot>   Couldn't match expected type `Expr'
21:59:02 <Axman6> > foldl (flip (:)) [a,b,d] :: [Expr]
21:59:03 <lambdabot>   Couldn't match expected type `[Expr]'
21:59:11 <Axman6> :t foldl (flip (:)) [a,b,d]
21:59:13 <lambdabot> [Expr] -> [Expr]
21:59:25 <Axman6> > foldl (flip (:)) x [a,b,d] :: [Expr]
21:59:26 <lambdabot>   Couldn't match expected type `[b]' against inferred type `Expr'
21:59:30 <Axman6> > foldl (flip (:)) x [a,b,d] :: Expr
21:59:31 <lambdabot>   Couldn't match expected type `[b]' against inferred type `Expr'
21:59:34 <Axman6> bah
22:01:51 <geezusfreeek> oh so awesome http://xkcd.com/505/
22:01:52 <lambdabot> Title: xkcd - A Webcomic - A Bunch of Rocks
22:10:56 <hackage> Uploaded to hackage: ffeed 0.3
22:31:50 <ski_> mmorrow : in `data Eqv s t where Eqv :: s ~ t => Eqv s t', i think it *ought* to be representable as `data Eqv :: * -> * -> * where Eqv :: Eqv s s'
22:32:44 <ski_> mmorrow : whether that is actually the case, i don't know. maybe there's some (serious or not) reason why it can't be done in this system
22:33:49 <ski_> mmorrow : generally, if you're asking whether i think some kind of constraint of the form `s ~ t' would be needed, i think the answer would be yes
22:34:38 <ski_> (mmorrow : the syntax `s = t' would look nicer, though)
22:39:22 <Bitrot> Hi all.
22:39:34 <Bitrot> Can anyone help me with a simple type theory question?
22:40:30 <arw> perhaps, perhaps not.
22:40:48 <Bitrot> Well, let's give it  shot: Why aren't type variables considered a "top type"?
22:40:48 <arw> we can answer that question only if you first ask the other question.
22:41:26 <Bitrot> (I was just checking if anyone was awake)
22:41:36 <arw> i'm awake, but clueless.
22:41:46 <Bitrot> Oh well.
22:43:06 <Bitrot> In case anyone else is around....if I have a function \x.x, any value is a valid argument. So, to me, the type of x seems to fulfill the requirement of Top (ie, any value can inhabit the type). I can't find anything online where type variables are used in this way so I'm wondering what I'm missing.
22:44:06 <Axman6> bleh, i wish more docs about ideas in haskell talked more about the uses and how to use things, than the theory behind them, leaving you with knowledge without knowing how to use it
22:45:53 <dolio> Top, in a type system that allowed it, would be something like (exists a. a).
22:46:17 <novas0x2a> Axman6: this is pretty good: http://book.realworldhaskell.org/read/
22:46:22 <lambdabot> Title: Real World Haskell
22:46:31 <arw> yep, i like that, too.
22:46:33 <dolio> If you want to emulate that with universals, it's (forall a. a -> r) -> r or something of the sort.
22:46:51 <dolio> Scratch that, (forall a. (a -> r) -> r)
22:47:07 <arw> really something useful after all the "theory behind monads, part XVII"
22:47:25 <Axman6> novas0x2a: i'm not looking for somewhere to learn haskell, i'm talking about when people blog about things in haskell. i was reading conal's stuff about memotries, and it was interesting, but i was left having no idea how i was supposed to use it
22:47:43 <Bitrot> Dolio 1) I don't really get how existential types work (sorry) and 2) How does a function type capture all possible values? I don't see how something like "3" fits in there.
22:48:00 <mmorrow> ski_: i agree
22:49:02 <dolio> Bitrot: (foo :: exists a. a) means, essentially, there is some type a such that a is the type of foo.
22:49:13 <dolio> So, clearly, that works for any value.
22:49:16 <mmorrow> oh, i only saw you're last line in my window..
22:50:48 <Bitrot> OK, vaguely get it. Can you help me see the equivalence to your second example?
22:50:56 <mmorrow> ski_: yeah, i'm not sure either. but this has made me want to look into ~ + GADTs
22:51:03 <dolio> Yeah, I'm thinking whether or not I got it wrong at the moment. :)
22:51:56 <dolio> Bitrot: The main idea is that you can encode data as the eliminator for that data, and the eliminator for an existential is a universal.
22:52:07 <Bitrot> Hmmm...if I had  a function f :: exists a. a -> a, how does that differ from the identity function (id :: forall a. a -> a)?
22:52:13 <ski_> Bitrot : a problem with interpreting type variables as a `Top' type is that if you e.g. pass a value of type `Int' to `\x. x', then using `Int' for the `Top' argument type here wouldn't be *independent* on how to interpret the result type
22:52:42 * ski_ hands dolio a `forall r. '
22:52:45 <mmorrow> Bitrot: with you're f, it has a /particular/ type, but you're just not sure which
22:52:56 <mmorrow> s/you're/your/
22:53:12 <mmorrow> but with id :: forall a. a -> a
22:53:23 <mmorrow> a can be /any/ type
22:53:28 <mmorrow> 'a' can ...
22:54:10 <Axman6> mmorrow: you're was correct
22:54:21 <mmorrow> heh, i meant the first you're
22:54:23 <Axman6> oh, the first one, m
22:54:26 <Axman6> m'bad
22:54:41 <mmorrow> i noticed that too after the fact (that there were two) ;)
22:54:41 <dolio> Okay, it is: forall r. (forall a. a -> r) -> r
22:54:43 <ski_> Bitrot : the implementor of a value of type `exists a. a -> a' may choose `a' to be any type s/he wishes .. a *user* however, will not be able to choose at all, but instead have to be able to handle whatever type `a' the implementor actually used
22:55:28 <Axman6> :t id (f :: a -> b)
22:55:29 <lambdabot>     Could not deduce (SimpleReflect.FromExpr b, Show a)
22:55:29 <lambdabot>       from the context ()
22:55:29 <lambdabot>       arising from a use of `f' at <interactive>:1:4
22:55:29 <Bitrot> Mmmm OK. I think I understand...or atleast feel the stirrings of understanding somewhere in my head.
22:55:33 <ski_> Bitrot : for the type `forall a. a -> a' it's sortof the reverse : the implementor must be able to handle any type `a' at all, while the user may choose `a' to be any type s/he wishes
22:56:13 <dolio> Bitrot: Anyhow, the idea is that if you have (exists x. x) then the only thing you can do is hand it to a function that, forall a, returns an r, and get back the r.
22:56:33 <mmorrow> forall and exists are duals just like products and sums are duals just like object oriented and functional are duals just like ...
22:56:46 <dolio> Because (exists x. x) has some particular unknown type, so to eliminate it, you need a function that accepts all types.
22:57:07 <ski_> Bitrot : a distinguishing thing between type variables in general, and `Top' (or `Bot', ..) is that each occurance of the same type variable must stand for the same type, whenever we actually replace the type variable with a type (in the case of `forall' .. for `exists' we'd replace the type with a type variable)
22:57:20 <Bitrot> OK, I sort of get it. (except for that last bit by morrow). However, could you have a function (exists a. a->a) by itself (without some hidden type you're unaware of)?
22:57:58 <ski_> Bitrot : by definition, such a function would hide some type
22:59:25 <Bitrot> Can anyone give me an example of such a function?
22:59:31 <mmorrow> Bitrot: sure, but you'd have to use unsafeCoerce to get such a function
22:59:50 <ski_> mmorrow : why ?
22:59:57 <mmorrow> unsafeCoerce ((\x -> x+1) :: Int -> Int))
23:00:06 <dolio> (\x -> x + 1) :: exists a. a -> a
23:00:15 <mmorrow> ski_, dolio: yeah, oops
23:00:37 <ski_> ignoring that no haskell implementation i know of allow `f :: exists. a -> a' one should be able to do roughly like dolio showed
23:00:56 <mmorrow> but exists a. a -> a could be implemented
23:01:02 <mmorrow> there's no inherent obstacle
23:01:05 <ski_> (s/exists/exist a/)
23:01:10 <Bitrot> OK, so what if you call it with a non-integer? Is that left as undefined runtime behavior?
23:01:10 <dolio> Sure.
23:01:27 <ski_> you can't call it with a non-integer
23:01:31 <Bitrot> Well
23:01:36 <Bitrot> Something not Num a => a
23:01:37 <ski_> you can't call it with an integer either
23:01:48 <dolio> With GHC you can make a type 'data EFun = forall x. EF (x -> x)' and do 'foo :: EFun ; foo = EF ((\x -> x + 1) :: Int -> Int)'
23:02:18 <Bitrot> _ski: So, can you call it at all?
23:02:31 <ski_> the type `exists a. a -> a' hides whatever type `a' the implementor used
23:03:00 <ski_> Bitrot : not that example, no (well, you could call it with `undefined', but i don't count that)
23:03:20 <ski_> but take this example instead
23:03:53 <ski_> f :: exists a. [a] -> ([a],String)
23:04:02 <ski_> you could call that with the empty list
23:04:06 <ski_> also, consider
23:04:29 <mmorrow> and "newtype" which are used to get at infinite types are just a controlled way to use unsafeCoerce (where in this case, it's just called "coerce")
23:04:51 <ski_>   foo :: forall a. exists x. (x,a -> x -> x,x -> Maybe (a,x))
23:04:56 <ski_> e.g. implementable as
23:05:00 <mmorrow> y f = let z x = f (unsafeCoerce x x) ; {-# NOINLINE z #-} in z z
23:05:05 <mmorrow> y :: (a -> b) -> b
23:05:22 <mmorrow> but as far as i can tell, you can't actually get at that "b" with haskell's type system
23:05:30 <ski_>   foo = ([],(:),\xs0 -> case xs0 of [] -> Nothing; x:xs -> Just (x,xs))
23:05:37 <ski_> also implementable as
23:05:39 <mmorrow> ie, you are limited to (a -> a) -> a, which is fix's type
23:05:53 <ski_>   foo = ([],\x xs -> xs ++ [x],\xs0 -> case xs0 of [] -> Nothing; x:xs -> Just (x,xs))
23:06:08 <lispy> > fix fix
23:06:09 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
23:06:09 <lambdabot>      Proba...
23:06:18 <lispy> But, I want infinite types!
23:06:22 <ski_> the first `foo' would implement an abstract data-type "Stack", the second "Queue"
23:06:33 <ski_> lispy : ocaml -rectypes
23:06:43 <mmorrow> lispy: they're easy partay with newtype ;)
23:06:53 * lispy was not serious
23:07:03 * mmorrow nods
23:07:42 <lispy> > fix (const True)
23:07:44 <lambdabot>   True
23:07:54 <lispy> It's still a little weird to me that it terminates
23:07:58 <ski_> Bitrot : the point with `foo' being that even though it doesn't tell you what type `x' is, it gives you a way to obtain an initial value of that type (here the empty "Stack"/"Queue" implemented as the empty lise), and some operations that are guarranteed to work on values of this hidden type
23:07:58 <lispy> ?src fix
23:07:58 <lambdabot> fix f = let x = f x in x
23:08:23 <lispy> fix (const True) = let x = (const True) x in x
23:08:43 <lispy> > let x = (const True) x in x
23:08:44 <lambdabot>   True
23:08:53 <Bitrot> OK, had to re-read a good number of times, but I finally get it.
23:09:22 <Bitrot> So it's useful if you use an internal representation (like the list used for stack/queue implementation) that's only known within your function.
23:09:57 <ski_> (mmorrow : i assume you're aware of `U' aka `Santa' .. ?)
23:10:14 <mmorrow> ski_: i'm not sure. what is it?
23:10:19 <lispy> let x = (const True) x in x => let x = (const True) x in (const True) x => (const True) ((const True) x) ...
23:10:30 <ski_> newtype Santa a = S (Santa a -> a)
23:11:05 <mmorrow> heh, i think i've tried that one before
23:11:13 <Twey> @pl \x -> let x = \y -> y in y
23:11:14 <lambdabot> const y
23:11:20 <mmorrow> ooh, just got a new ghc(i) error message
23:11:22 <ski_> (using that, you can use Church's (or Turing's if you prefer) fix-point combinator to define `fix')
23:11:26 <mmorrow> Trace/breakpoint trap
23:11:33 <mmorrow> ghci> (unsafeCoerce (42::Int) :: Int -> Int) (42::Int)
23:11:33 <mmorrow> Trace/breakpoint trap
23:11:35 * Twey blinks.
23:11:45 <Bitrot> OK, thank you all for the help. I'll let my brain digest for the night.
23:11:46 <Twey> @pl \x -> let x = \y -> y in x
23:11:47 <lambdabot> const id
23:11:52 <Twey> It's goood.
23:12:41 <ski_> @pl \x -> x (let x = \y -> y x in x)
23:12:41 <lambdabot> ($ join id)
23:13:10 <lispy> oh reader ((->) r), how I love thee
23:14:07 <mmorrow> haha, i must've stumbled randomly upon a way to execute some instruction to get that "Trace/breakpoint trap", since it appears to be unreapeatable (only segfaults)
23:14:19 <ski_> what shall i compare thee to? an environment that is always there for you, if you care for it?
23:35:08 <Taejo> read "1." :: Double
23:35:14 <Taejo> > read "1." :: Double
23:35:15 <lambdabot>   * Exception: Prelude.read: no parse
23:35:18 <Taejo> > read ".2" :: Double
23:35:19 <lambdabot>   * Exception: Prelude.read: no parse
23:39:47 <Magicloud> Hi, could someone tell how to make `ghc --make` put the .hi and .o files into /tmp?
23:41:02 <quicksilver> Magicloud: did you try the fine manual?
23:41:12 <quicksilver> 5.6.2 Output files
23:41:17 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#output-files
23:41:19 <lambdabot> Title: 5.6.ï¿½Filenames and separate compilation, http://tinyurl.com/yyunf2
23:42:51 <Magicloud> So .hs and .o is not intermedia temp files? I tried -tmpdir which does not work.
23:48:46 <sjanssen> Magicloud: no, they're not temp files
