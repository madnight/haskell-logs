00:03:57 <Axman6> noZone: project euler?
00:04:44 <sjanssen> Taejo: what is the purpose of the third parameter to F?
00:05:31 <noZone> I actually don't remember where I found that one... just poking around after digging up stuff on combinadics.
00:06:11 <Taejo> sjanssen: it is the "post-processor" -- we need it to combine different folds (and it seems essential for to make Fold a a functor)
00:08:36 <sjanssen> Taejo: it doesn't seem clean
00:09:06 <Taejo> sjanssen: how do you combine two folds into one if you don't allow a combining function?
00:09:46 <sjanssen> Taejo: data Fold b a = forall a. F !(a -> b -> a) !a -- seems better to me
00:10:02 <Axman6> >[x | a <-[1..9], b <-[0..9], c <-[0..9], d <-[0..9], let x = (1000*a + 100*b + 10*c +  d), x*4 == (1000*d + 100*c + 10*b + a)]
00:10:10 <sjanssen> then combine :: Fold b a -> Fold b c -> Fold b (P a c)
00:10:14 <Axman6> > [x | a <-[1..9], b <-[0..9], c <-[0..9], d <-[0..9], let x = (1000*a + 100*b + 10*c +  d), x*4 == (1000*d + 100*c + 10*b + a)]
00:10:15 <lambdabot>   [2178]
00:10:18 <Taejo> sjanssen: that's what I had at first, but it didn't seem to work so well
00:10:50 <Taejo> sjanssen: if you can develop something like meanF using that definition, I'd be interested
00:12:17 <dancor> what's the right way to do this in HSH: runIO $ ("tar", ["cvf", "-"] ++ srcs) -|- cd dest -|- ("tar", ["xfp", "-"])
00:12:40 <dancor> that is, is there a good way to make cd act as a command..
00:13:06 <dancor> i'm trying to HSH-ify: tar cvf - "${@:1:$# - 1}" | (cd "${!#}"; tar xfp -)
00:20:02 <yitz> dancor: in sh you're opening a subshell to do that. don't know how in HSH tho.
00:39:18 <RayNbow> nice...
00:39:34 <RayNbow> "cabal install cabal-install" works :)
00:42:41 <Baughn> RayNbow: Now tell me how to do that without cabal-install installed. :P
00:42:46 <vegai> [vegai@louhikko lambdabot]$ /usr/local/bin/mueval
00:42:46 <vegai> mueval: NotAllowed "Could not find module `Data.Number.BigFloat':\n  Use -v to see a list of the files searched for."
00:42:47 <Baughn> But yeah, nice
00:42:57 <vegai> hmm
00:42:59 <vegai> @hoogle BigFloat
00:42:59 <lambdabot> No results found
00:43:07 <vegai> what *is* that thing?
00:43:24 <vegai> mm, is it numbers?
00:43:55 <C-Keen> @hoogle Data.Numbers.BigFloat
00:43:55 <lambdabot> No results found
00:43:56 <vegai> ah, yes. Mueval should list that as its deps
00:44:20 <vegai> gwern: Are you around?
00:44:54 <vegai> @tell gwern mueval should have numbers as a dependency
00:44:54 <lambdabot> Consider it noted.
00:46:46 <RayNbow> Baughn: if you don't have cabal-install, you need to download the source first and compile it
00:47:56 <vegai> and lambdabot depends on arrows and logict if you want to use Eval
00:47:56 <Baughn> RayNbow: See, that's just not right. With our knot-tying abilities, we should be able to make a cabal-install that does all its work by calling itself, thus reducing it to zero size and making it possible to install by saying "touch cabal-install".
00:48:18 <RayNbow> :p
00:50:46 <f4lcon> mornin
00:54:01 <Jaak> ghc-6.10 fails to build with "Relocating ghc from /usr to workdir failed"
01:01:05 <Jaak> demmit
01:03:46 <RayNbow> hmm
01:04:02 <RayNbow> can't get OGL/GLUT to work in GHC 6.10
01:04:19 <Baughn> WorksForMe(tm)
01:04:28 <RayNbow> under Windows?
01:04:37 <Baughn> Well, no..
01:05:15 <Jaak> ah, okay. works with ghcbootstrap
01:06:40 <Baughn> RayNbow: What's your error?
01:06:47 <RayNbow> http://www.nabble.com/OpenGL%2BGLUTwith-ghc-6.10---td20041955.html <-- ah, so I'm not the only one :p
01:06:54 <lambdabot> Title: Nabble - Haskell - Libraries - OpenGL+GLUTwith ghc-6.10 ?, http://tinyurl.com/5mgzwm
01:06:59 <RayNbow> well, with 6.10.1... several screens of link errors :p
01:07:17 <Baughn> RayNbow: Care to give one example?
01:07:22 <Beelsebob> RayNbow: conal was getting that error
01:07:26 <Beelsebob> he's fixed it now
01:07:29 <Beelsebob> but I'm not sure how
01:07:32 <Baughn> Eh, meh. OpenGL on windows is fundamentally broken anyhow.
01:07:35 <Beelsebob> if you see him -- ask him!
01:07:40 <Baughn> At least, if you want anything newer than opengl 1.1 it is
01:08:18 <Beelsebob> but then... OpenGL is fundamentally broken anyway -- roll on SIGGRAPH asia and OpenCL being released
01:08:25 <Baughn> ..
01:08:40 <Baughn> Bringing up OpenCL makes about as much sense as bringing up OpenAL, though
01:09:12 <Beelsebob> not at all -- OpenCL is specifically designed so that you *can* do graphics with it, and indeed, so that it's better for graphics than GL
01:09:29 <Baughn> ..unless you happen to want to use fixed functionality
01:09:33 <Beelsebob> Tim sweeny is already saying when it comes out he'll switch back to writing "software" rendererers
01:09:38 <Beelsebob> that just happen to run on the graphics card
01:09:59 <Beelsebob> yeh, but 99% of 3D graphics developers *don't* want the fixed functionality
01:10:06 <Baughn> We'll still need something like OpenGL, just so it's possible to write applications without having deep knowledge of rendering
01:10:08 <Beelsebob> they have hundreds of hacks to get different functionality
01:10:17 <Beelsebob> true dat
01:10:18 <Taejo> sjanssen: how's the two-field Fold coming?
01:10:34 <Baughn> And for backwards-compatibility, the "something" probably will /be/ opengl
01:10:55 <Beelsebob> yeh -- at a guess, that's the reason why OpenGL 3 changed next-to-nothing
01:11:05 <Baughn> Then there's the little detail that opencl won't be supported on windows
01:11:15 <Beelsebob> they saw OpenCL and went "hey, GL can be a legacy thing for all these CAD/CAM guys, and everyone else can have CL"
01:11:21 <Beelsebob> sure it will
01:11:23 <Beelsebob> but not by MS
01:11:34 <Beelsebob> nVidia and ATi have already announced their intention to write drivers for it
01:11:47 <Beelsebob> but hey -- OpenGL isn't supported on windows either, is it
01:11:54 <Baughn> Beelsebob: I'm not sure that's what happened with opengl 3. But actually, opengl3 isn't as bad as people claim.
01:12:07 <xhanjian> @src filter
01:12:08 <lambdabot> filter _ []     = []
01:12:08 <lambdabot> filter p (x:xs)
01:12:08 <lambdabot>     | p x       = x : filter p xs
01:12:08 <lambdabot>     | otherwise = filter p xs
01:12:10 <Beelsebob> Baughn: yes it is -- it was *meant* to be an enormous overhall
01:12:11 <xhanjian> @src map
01:12:12 <lambdabot> map _ []     = []
01:12:12 <lambdabot> map f (x:xs) = f x : map f xs
01:12:17 <Beelsebob> that pushed everything towards generic computation
01:12:22 <Beelsebob> and cleaned it all up nicely
01:12:29 <Beelsebob> it turned out to be a minor version bump
01:12:31 <RayNbow> hmm, hpaste gives an error...
01:12:34 <Baughn> Well, yes it is. Microsoft does bundle an opengl 1.1 software renderer, that also works as a handy entry-point for the hardware renderers
01:13:09 <Baughn> Thus why applications don't need one code path per gpu. (Oh, wait... hope opencl fixes this)
01:13:12 <RayNbow> http://raynbow.pastebin.com/f9396768 <-- pick any link error you like, Baughn :p
01:13:19 <velco> OpenGL supposrt in Doze nowdays is provided by ATI and NVidia drivers, perhaps Intel too
01:13:27 <Beelsebob> yeh
01:13:34 <Beelsebob> MS hasn't supported OpenGL for *years*
01:13:41 <Baughn> RayNbow: Aha!
01:14:09 <Baughn> RayNbow: ..you did install the opengl sdk from your gpu manufacturer, right?
01:14:19 <RayNbow> SDK?
01:14:30 <Baughn> You know. Headers and such.
01:14:33 <quicksilver> but opencl has nothing to do with graphics at all, specifically
01:14:35 <velco> glut is separate
01:14:47 <Baughn> velco: THat paste has both glut and gl errors
01:14:55 <quicksilver> sure you can write graphics graphics code in opencl, but you can write graphics code in C too
01:14:56 <velco> need to get gluit from somewhere else, maybe from OpenGLUT
01:14:59 <Beelsebob> quicksilver: not specifically -- but I'm gonna bet heavily that all the game makers move over to one of it, or DirectX's competing thing
01:15:26 <Beelsebob> quicksilver: yeh, the point is that the games devs *want* to write in C, but it can't be compiled to hardware rendering -- OpenCL will let them do that
01:15:47 <quicksilver> well, we'll see. It's not obvious to me.
01:15:59 <RayNbow> Baughn: not sure if I have, but where do I have to put those headers? During cabal install I saw cygwin was being mentioned... (does that mean it uses gcc from my cygwin installation?)
01:16:04 <Baughn> Beelsebob: They also *want* to write single-threaded code. OPengl is geared towards this; cl isn't.
01:16:06 <Beelsebob> Tim Sweeny's already made it very clear that he wants to go back to writing "software" renderers
01:16:06 <quicksilver> personally I'd rather get texture interpolation for free etc
01:16:17 <velco> CUDA allows you to write on C and exec on GPU, not sure whether for rendering though
01:16:26 <Beelsebob> velco: no, not for rendering
01:16:36 <Beelsebob> that's the major difference between CUDA and OpenCL
01:16:53 <Baughn> Beelsebob: Hmm? Some of nvidia's examples do render
01:16:55 <Beelsebob> OpenCL gives access to the framebuffer, and vertex buffers etc
01:17:05 <Badger> openCl? o_O
01:17:18 <Badger> oh
01:17:22 <Beelsebob> Baughn: oh? last time I saw it it was explicitly for doing computation, and then grabbing it back
01:18:04 <jeffz> RayNbow: fyi, glut works fine for me with the 6.10.1 stable release on windows, just followed this http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/#more-136
01:18:07 <lambdabot> Title: Less Sugar/More Meat » Blog Archive » freeglut + Windows + HOpenGL + HGLUT, http://tinyurl.com/5ualsl
01:18:32 <Beelsebob> Baughn: also, where did you get the idea that they want to write single threaded code -- last I saw, *lots* of the big game devs were giving presentations at places like SIGGRAPH about how to massively-parallelise game engines
01:19:08 <RayNbow> jeffz: ah, I never used freeglut
01:19:13 <RayNbow> I'll try that guide
01:22:59 <idnar> hmm, MonadZip
01:25:03 <RayNbow> hmm
01:25:08 * RayNbow is going to update mingw
01:26:34 <quicksilver> Beelsebob: I think Baughn's point is that developers don't want ot have cope with the nightmares of thread synchronisation in a complex C++ application
01:26:42 <quicksilver> I think that's true.
01:26:49 <quicksilver> and Tim Sweeney != everyone.
01:26:59 <quicksilver> Tim Sweeney has his own personal vision and probably the talent to push it through
01:27:02 <Beelsebob> yeh, but I don't think they do have to -- after all, graphics programming is easily parallelised
01:27:05 <Beelsebob> it's data parallel
02:03:35 <RayNbow> jeffz: hmm, no link errors now... the test program also works from ghci...
02:04:44 <RayNbow> but the compiled version doesn't...
02:14:55 <f4lcon> anyone know how I can concat 2 Maybe Strings ?
02:15:13 <Deewiant> liftM2 (++)
02:15:43 <C-Keen> :t catMaybes
02:15:43 <lambdabot> forall a. [Maybe a] -> [a]
02:15:52 <Beelsebob> x <^(++)^> y
02:16:10 <Beelsebob> yay for the InfixApplicative package
02:16:14 <Taejo> <^(++)^> looks like a piggy smiley or something
02:16:14 <f4lcon> cheers
02:16:32 <Beelsebob> f4lcon: you'll need to get the InfixApplicative package for my suggestion to work
02:16:57 <f4lcon> i'll try the other two since this is beginner work atm :P
02:20:54 <Beelsebob> Taejo: I finally figured out how you saw the pig :D
02:21:26 <Taejo> lol
02:22:19 <ivanm> anyone see harrop's latest blog post?
02:22:28 <quicksilver> UNICODE 2F39 PIGS SNOUT
02:22:31 <dolio> He has a blog?
02:22:35 <ivanm> dolio:
02:22:39 <ivanm> *dolio: yup
02:22:43 <ivanm> http://flyingfrogblog.blogspot.com/2008/11/sales-of-f-books.html
02:22:44 <lambdabot> Title: The Flying Frog Blog: Sales of F# books
02:22:45 <dolio> Wow.
02:22:54 <ivanm> he claims F# is the most popular language around :o
02:23:08 <Zao> s/popular/initially hyped/
02:23:41 <Zao> All I've seen of it is the "omg look, we have units on our numbers, see, I can do forward euler!".
02:23:45 <ivanm> Zao: it comes from him claiming that more F# books are bought per month or something than for any other language
02:23:48 <Beelsebob> quicksilver: ⼹?
02:24:49 <Zao> ivanm: _functional_ language.
02:25:04 <ivanm> Zao: no, he claims more than _any_ language
02:25:08 <ivanm> including C
02:25:18 <ivanm> and as such it's more popular
02:25:46 <dolio> He does list C there.
02:25:54 <quicksilver> just like banks buy back their shares, flying frog buy back their books
02:26:01 <quicksilver> it's a way of expressing confidence in themselves
02:26:27 <dolio> I seriously doubt F# is more popular than Lisp, as well.
02:26:34 <dolio> Or Scheme.
02:26:41 <Zao> Insanity.
02:27:03 <Kerris4> Excluding ChanServ, there are four guys in #fsharp right now :(
02:27:34 <ivanm> Kerris4: heh
02:27:39 <dolio> I don't know about Haskell, but most people seem to learn Haskell without buying any books about it.
02:27:41 <Kerris4> I get more help with F# from #ocaml
02:27:49 <ivanm> how many of them have the surname "harrop"? ;-)
02:28:53 <Kerris4> ivanm: I don't think there's anyone besides me in that channel that's connecting from the UK :\
02:28:57 <velco> since when anyone pays any attention to what Harrops says ?
02:28:58 <profmakx> oh noes
02:29:02 <profmakx> harrop again!
02:29:37 <dolio> He can be pretty entertaining.
02:29:44 <dolio> @quote JonHarrop
02:29:44 <lambdabot> JonHarrop says: I lurk on the Haskell Cafe mailing list and eager evaluation is often the solution to reliability or performance problems: laziness is unpredictable.
02:29:54 <Kerris4> LOL
02:29:59 <dolio> @quote JonHarrop
02:29:59 <lambdabot> JonHarrop says: Is someone at Google using a lazy language?
02:29:59 <profmakx> as long as you dont let him annoy you, yes he can!
02:30:04 <dolio> @quote JonHarrop
02:30:04 <lambdabot> JonHarrop says: Absolutely, but you don't want laziness everywhere all the time because it means you can't write fast code.
02:30:06 <RayNbow> @karma jeffz
02:30:07 <lambdabot> jeffz has a karma of 0
02:30:09 <RayNbow> jeffz++
02:30:10 <Kerris4> His books/tutorials/libraries are somewhat decent if pricey, I didn't know he had such an interesting personality. :)
02:31:17 <dolio> @quote randomly fiddling
02:31:17 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
02:31:26 <dolio> @quote randomly.fiddling
02:31:27 <lambdabot> dolio says: Although I'd be interested to see a book that advises the reader to 'optimize by randomly fiddling until the current version of GHC happens to reduce [their code] in an asymptotically
02:31:27 <lambdabot> more efficient way.' :)
02:31:37 <dolio> Heh.
02:35:11 <ivanm> dolio: what's the context of that quote?
02:35:34 <dolio> We were talking about Harrop writing a 'Haskell for Scientists' book, I believe.
02:36:05 <ivanm> ahhhh
02:36:14 <dolio> @quote JonHarrop randomly.fiddling
02:36:14 <lambdabot> JonHarrop says: In Haskell, programmers write declaratively and often optimize by randomly fiddling until the current version of GHC happens to reduce it in an asymptotically more efficient way.
02:36:19 <dolio> That was the one I was looking for.
02:36:21 <ivanm> I notice that most of his claims that his books are more popular is because they're more expensive
02:36:26 <ivanm> and thus create more profit
02:36:58 <osfameron> it's not entirely unreasonable
02:37:15 <osfameron> though I guess that books about more niche languages will tend to be more expensive
02:37:35 <ivanm> osfameron: oh? I would have thought popularity ~ volume sold
02:38:42 <osfameron> ivanm: yes, but someone who might buy a book for 10 USD/GBP/whatever, might be put off by a book costing 30.  So there is a "put your money where your mouth is" factor too
02:38:50 <ivanm> true
02:38:50 <osfameron> s/is/might be/
02:39:30 <nominolo|msr> MarcWeber: ping
02:40:58 <nominolo|msr> er
02:41:02 <nominolo|msr> MarcWeber: pong
02:41:56 <dolio> I bet F# doesn't fare as well against C in his most-popular-debian-packages-written-in-said-language metric. :)
02:47:27 <quicksilver> dolio: well the great thing about metrics is you can choose which one to use ;)
02:47:46 <dolio> Yes. Whichever proves your point best today. :)
02:49:34 <Botje> number of prime numbers in the source code!
02:50:47 <RayNbow> how about using kg as a nice metric? :p
02:51:48 <RayNbow> (measured by first printing your source code and then weigh it :p)
02:52:44 <ivanm> dolio: lol
02:53:33 <Ferdirand> how about weighting the trees that had to be cut to make the paper ?
02:53:34 <nominolo|msr> including comments?
02:53:54 <ivanm> Ferdirand: but that depends on the type of paper used
02:54:34 <ivanm> besides, it ignores those books that stay on bookstore shelves before ten years at full price (despite newer versions being cheaper) and never bought because they're so out of date that they're useless
02:54:37 <Ferdirand> exactly. suddently you gain an advantage over those cheap other businesses that use recycled paper, haha !
02:54:54 <ivanm> heh
02:55:08 <ivanm> Ferdirand: so big fonts, thick paper, etc. are _better_ now? ;-)
02:55:45 <velco> and cololrful illustrations, don't forget !
02:56:35 <dolio> But if you use big fonts, your file will take up more space on disk, so it's a tradeoff.
03:03:59 <Botje> pfft. disk is cheap.
03:04:04 <Botje> think of the profits!
03:06:12 <ivanm> Botje: exactly!
03:06:40 <ivanm> besides, specifying "12pt" in your documentclass statement in LaTeX doesn't take up all _that much_ extra disk space ;-)
03:28:54 <lispy> ah jon harrop
03:29:25 <lispy> And this week's Troll award goes to .... *drum roll* Jon Harrop!
03:31:50 <nominolo|msr> again?
03:32:52 <dolio> This week just started.
03:32:54 <dolio> Hold your horses.
03:33:24 <earthy> oh, come on, Jon Harrop...
03:33:29 <earthy> who's gonna beat that...
03:33:56 <dolio> I don't know. Xah Lee might come up with something.
03:34:35 <vegai> can I find out what you're talking about without generating Jon ad traffic? :)
03:35:32 <dolio> Apparently he posted a new article to comp.lang.functional just after midnight, in fact (just looked).
03:36:46 <dolio> "Dear Pascal Bourguignon moron," good opening line.
03:40:00 <nominolo|msr> dolio: well, Pascal isn't the nicest fellow, either ;)
03:40:13 <dolio> No argument there.
03:40:39 * nominolo|msr remembers old comp.lang.lisp times...
03:51:39 <Botje> it's all fun and games until somebody gets tetanus from the bloody parens
03:54:37 <quicksilver> Botje ++
03:58:56 * nominolo|msr likes parens
03:59:24 <nominolo|msr> though, prefixed arithmetic looks still weird
03:59:30 <nominolo|msr> (/ 3 2)
03:59:48 <nominolo|msr> and dynamic typing seems fragile now
04:04:38 <ksf> I'd like to have a way to type [1..] so that it can't be passed into stuff like fold, list and map but into take.
04:05:05 <ksf> That is, I'm trying to figure out the largest subset of Haskell that isn't turing-complete.
04:05:20 <nominolo|msr> ksf: use agda
04:05:34 <ksf> ignore that listing of functions, it's wrong.
04:05:55 <nominolo|msr> ksf: but you could use newtyping to distinguish streams from lists
04:06:30 <ksf> so far, i found epigram and charity, but i'm actually less interested in implementations than in messing with my mental reasoning.
04:07:39 <ksf> take is allowed, fold maybe forbidden if it tests for [], map is forbidden and i guess i meant to write zip when writing list, which is also forbidden.
04:08:43 <nominolo|msr> ksf: Take a look at Agda, it's relly very Haskell-like
04:09:05 <nominolo|msr> it's also implemented in Haskell, so it builds with Cabal
04:09:37 <quicksilver> ksf: I think you want the largest subset which is total, don't you?
04:09:56 <quicksilver> largest subset which is not turing complete is probably not independently interesting.
04:10:30 <quicksilver> in particular, it's not well defined because the union of two turing incomplete subsets need not be turing incomplete.
04:11:05 <ksf> quicksilver, that's my main problem.
04:11:33 <Beelsebob> quicksilver: that doesn't exclude there being a largest one though
04:11:38 <Beelsebob> it just makes it hard to find
04:12:43 <ksf> quicksilver, i'm looking for a dicidable subset.
04:13:12 <earthy> hm. pity I don't have my lecture notes on recursion theory around
04:13:27 <earthy> there was something in there 'bout this.
04:19:17 <quicksilver> Beelsebob: it kind of does.
04:19:26 <quicksilver> Beelsebob: when comparing infinite sets which have the same cardinality
04:19:41 <quicksilver> Beelsebob: the only sense of 'largest' which is meaningful is the one based on unions.
04:19:59 <Beelsebob> that makes sense, yes -- but with the added constraints
04:20:25 <quicksilver> ksf: have you read turner's paper?
04:20:36 <ksf> I guess not.
04:20:55 <ksf> do you have a link?
04:21:12 <quicksilver> http://www.jucs.org/jucs_10_7/total_functional_programming
04:21:16 <quicksilver> I think that's the most recent one
04:21:18 <lambdabot> Title: (D. A. Turner) Total Functional Programming
04:21:25 <quicksilver> it's something he's written on, on and off, for 20 years
04:22:52 <RayNbow> sum $ mergeByR compare (const (:)) (:) (:) [] [3,6..999] [5,10..999]   -- Project Euler, Problem 1... a bit overkill version :D
04:23:25 <PeakerWork> is Huffman usually very close to approximating the actual probabilities to powers of 2?  For example: If the text has 'a' 40% of the time, and 'b' 60% of the time, Huffman is going to have to use 50/50 which is wasteful...
04:23:44 <PeakerWork> > logBase 2 0.4
04:23:45 <lambdabot>   -1.3219280948873622
04:23:50 <ksf> it isn't.
04:23:53 <PeakerWork> (1 bit for either symbol, where it should be 1.3 bits)
04:24:21 <ksf> you should have something like 0 for a, 10 for b.
04:24:37 <PeakerWork> ksf: then you get 50% instead of 60%, and 25% instead of 40%
04:24:44 <PeakerWork> ksf: and if you only have these two symbols, then you get 50% and 50%
04:25:28 <PeakerWork> Because I discussed this with a friend, and we thought that maybe Huffman could try to change the word sizes (pair stuff up, etc) until it approximates powers of 2 better
04:26:14 <PeakerWork> if 'a' and 'b' are 60% and 40%,  maybe 'aa' and 'ab' and 'baa' and 'bbb' fill up the tree in nice comfy powers-of-2 positions
04:27:22 <ksf> in aa, a is 100%, in ab, both are 50%, and in baa b is 33.333... and a 66.666666
04:27:52 <PeakerWork> ksf: the probability of "aa" cannot be derived from the probability of "a" and "b", because you have the actual text in which you know how many times that appears exactly
04:28:07 <PeakerWork> (you know if all the "a"s are clumped together or not)
04:28:13 <hugo_> Axman6: you there ?
04:28:33 <PeakerWork> ksf: so you can try various combinations of sequences until you get something closer to 2^(-x)
04:28:35 <ksf> you cannot derive any probabilty before having gone through all the input.
04:28:38 <Axman6> sorta...
04:28:47 <PeakerWork> ksf: the encoder can go through all the input
04:28:58 <hugo_> Axman6: do you remember how did you solve this: http://hpaste.org/10732 ? im having the same problem
04:29:36 <Axman6> i think it involved not using SearchPath
04:29:49 <Axman6> just install all the libraries you need
04:29:53 <PeakerWork> ksf: and the whole Huffman tree can be transmitted separately
04:29:57 <Axman6> /packages
04:30:04 <hugo_> hmm ok
04:30:25 <hugo_> using darcs manually ?
04:30:33 <PeakerWork> in real world Huffman cases, though, maybe the approximations are good enough though
04:30:39 <PeakerWork> so I don't know if its a significant improvement
04:31:10 <Axman6> or cabal install
04:31:30 <ksf> imperatively speaking, you first go through your input to figure out the frequency of all symbols in your alphabet (and thereby also figure out its size), then sort those into a list and construct a binary tree on top of them such that at each step, the lowest frequency has the shortest path to the root node.
04:32:16 <ksf> if you want to approximate, though, you should take larger alphabets as examples.
04:32:38 <ksf> ...and sufficiently large input.
04:33:10 <hugo_> Axman6: thanks
04:33:39 <ksf> it's approximating ld(n), actually, not 2^n.
04:33:40 <Axman6> np
04:34:46 <ski> ksf : you could make an huffman tree incrementally, emitting current bit strings for each symbol, updating the tree as more symbols are seen
04:34:48 <PeakerWork> ksf: well, currently I think they choose an arbitrary alphabet (like 8-bit chunks). I'm suggesting choosing the alphabet such that you get frequencies that fit better into Huffman
04:36:06 <ksf> I doubt that's decidable.
04:37:08 <PeakerWork> ksf: maybe its not in P, I don't know, but why would it not be decidable?
04:37:20 <PeakerWork> ksf: I'm of course talking about compression of a finite string
04:37:27 <ksf> mere intuition.
04:37:46 <ksf> ski, that's what more sophisticated packers do.
04:38:21 <ski> ok (i imagined they might)
04:38:45 <ksf> actually, in my mind it closely resembles the travelling salesman.
04:39:19 <Ferdirand> incremental huffman tree ?
04:39:30 <Ferdirand> reminds of Tunstall coding
04:40:48 <PeakerWork> Adaptive Huffman Tree is cool (modify the tree to account for changes in the "remaining symbols"
04:41:43 <PeakerWork> if the string has "aaaaaabbbbbb", then the histogram may start as ('a',6),('b',6), after decoding "aaaaaa" the histogram that remains is ('b',6).  so that means you need 0 bits for each of the symbols, so you don't encode them at all
04:42:13 <ksf> It'll be a bugger to divide the input into optimal chunks so that they differ maximally in frequency of their symbols.
04:42:49 <ski> `"aabcacbbb"' would encode to `[Sym 'a',Code [],Sym 'b',Sym 'c',Code [False],Code [True,True],Code [True,False],Code [True,False],Code [False]]' or something similar
04:43:04 <dancor> i need to algorithmically split some midi files at over-some-length periods of silence.  hackage has 'midi' and 'hcodecs' which both seem to do the job, is one better for this
04:43:38 <ski> PeakerWork : oh, that's like the reverse of what i was thinking of .. would that have any advantages ?
04:44:13 <ksf> Peaker, that's algorithmic coding.
04:44:14 <PeakerWork> ski: I think if you're encoding a finite string, and not an infinite stream, then building the whole Huffman tree ahead of time is probably better
04:44:15 <ski> PeakerWork : sorry, ignore what i said .. i read "decoding" as "encoding"
04:44:39 <PeakerWork> ksf: what, changing the encoding as you progress to match the remaining string?
04:45:17 <ski> PeakerWork : well, if you're encoding a pipe or socket on the fly ..
04:45:17 <ksf> http://en.wikipedia.org/wiki/Arithmetic_coding
04:45:19 <lambdabot> Title: Arithmetic coding - Wikipedia, the free encyclopedia
04:45:28 <PeakerWork> ski: sure, it has its uses
04:45:36 <ksf> making the decoder a function of its input.
04:46:35 <ksf> see especially its relation to huffman coding.
04:47:38 <ski> "arithmetic coding encodes the entire message into a single number, a fraction n where (0.0  n < 1.0)"
04:47:54 <ski> (s//=</)
04:48:05 <heavensrevenge> hello
04:48:22 <ski> afternoon
04:48:24 <heavensrevenge> just wondering, how dou now have haskell print the result of a computation?
04:48:30 <heavensrevenge> *not
04:48:39 <ksf> heavensrevenge, Mu.
04:48:47 <heavensrevenge> since a big part of a big computation seems to be displaying the results...
04:49:02 <ksf> http://en.wikipedia.org/wiki/Mu_(negative)
04:49:46 <heavensrevenge> ok then, uhm.. any examples in a piece of code i can see?
04:51:02 <ksf> @where mu
04:51:02 <lambdabot> I know nothing about mu.
04:51:08 <ksf> thought so...
04:51:29 <ksf> @where+ mu http://en.wikipedia.org/wiki/Mu_(negative)
04:51:29 <lambdabot> It is forever etched in my memory.
04:52:04 <ksf> in ghci, each and everything is printed automagically.
04:52:12 <ksf> in a file, you gotta use some io to do that.
04:52:17 <SamB> heavensrevenge: why would you compute something if you didn't want to use it ?
04:52:51 <ksf> SamB, even worse, how can you without using it?
04:52:57 <ski> heavensrevenge : assuming GHCi, you may want to try `:set -fno-print-bind-result'
04:53:08 <ski> and then use `foo <- getLine' or similar
04:53:36 <ski> (or `_ <- getLine' if you don'w want to bind the result to a variable)
04:53:40 <heavensrevenge> ill give it a try
04:53:48 <ski> (here `getLine' is whatever action you want to perform)
04:54:53 <heavensrevenge> well ok, theres no practical applicatin of why i want to do this
04:55:16 <heavensrevenge> just to see how holng the real computation is with a (100^100)^(100^100)
04:55:42 <ski> heavensrevenge : hm .. if you by any chance *didn't* mean executing `IO'-actions, but just entering expressions without printing the result, you could use `let foo = 2 + 2'
04:55:43 <heavensrevenge> and it just takes forever to print the result and i cant judge system time
04:56:03 <heavensrevenge> well id like to compute it, but not display it lol
04:56:07 <Saizan> heavensrevenge: you shouldn't profile from inside ghci
04:56:16 <heavensrevenge> im not, ill compile it
04:56:20 <ksf> @where+ mu http://www.catb.org/jargon/html/M/mu.html
04:56:20 <lambdabot> It is stored.
04:56:23 <SamB> heavensrevenge: you could check to see if it is equal to 0 ;-)
04:56:24 <ksf> @where mu
04:56:25 <lambdabot> http://www.catb.org/jargon/html/M/mu.html
04:56:43 <ski> heavensrevenge : if you're not talking about GHCi, then what i said is irrelevant
04:56:54 <heavensrevenge> this mu thing isnt really helping tho
04:57:03 <Saizan> heavensrevenge: ok, then you can use `seq` to force the evaluation of something
04:57:13 <SamB> heavensrevenge: mu isn't all that helpful, no
04:57:16 <ski> heavensrevenge : also, an expression will not be executed if you don't demand/force it ..
04:57:16 <SamB> it is a non-answer!
04:57:21 <heavensrevenge> i most likely am also asking a completely useless question
04:57:24 <SamB> an explicit one
04:57:32 <heavensrevenge> but i just want to make the box hot, know the time, and not print the result
04:57:39 <Saizan> heavensrevenge: like main = print $ ((100^100)^(100^100)) `seq` ()
04:57:50 <heavensrevenge> to me its a simple explination, its just for language testing...
04:57:51 <SamB> well, mu does sort of indicate that there is a problem with the question, yes ;-)
04:58:45 <ksf> heavensrevenge, main = print $ ((100^100)^(100^100)) == 0
04:58:47 <ski> is `0/0' greater than, equal to, or less than zero ?
04:59:14 <ksf> ski: depends on what the domains of / are.
04:59:38 <ksf> for positive numbers, infinity, for negative numbers, minus infitity, for all numbers, both at the same time.
04:59:39 <ski> ksf : rational numbers, here
05:00:11 <ksf> I lack the math to properly name the codomains.
05:00:29 <ski> (if it's not obvious, this was an attempt at a question which ought to be (non-)answered with "mu")
05:00:48 <ksf> look at both limits 1->0 and -1->0 and you'll see why.
05:01:53 <ksf> 1/n where n -> 0 resp n -> -0, that is.
05:03:15 <ski> (well, the question didn't ask about `1/0')
05:04:27 <heavensrevenge> oh cool :)
05:04:31 <heavensrevenge> main = print $ ((100^100)^(100^100)) == 0 seems to work well
05:05:05 <heavensrevenge> just so then i can compute sumthing, but also to not print .... a couple 100 thousand lines of text asa result
05:05:16 <ksf> I'd say greater, but I never really analysed the case.
05:05:27 <ksf> if it's defined, 0/0=1.
05:05:42 <ski> how come ?
05:05:56 <heavensrevenge> im not much quite worried about the statements philosophical correctness :P
05:06:02 <ksf> forall n. n/n = 1
05:06:16 <heavensrevenge> just need ways to show a guy at school mython sucks and should start teaching haskell as a language
05:06:23 <ksf> depends on your favourite definition of ring, of course, and what else you want to do with it.
05:06:31 <ski> do you agree that `n * o = m' should be equivalent to `n = m / o' ?
05:06:33 <heavensrevenge> but for me being the advocate im not too strong of one but i do luv haskell :)
05:07:09 <heavensrevenge> bah
05:07:23 <heavensrevenge> but doesnt that not work always??
05:07:26 <ksf> ski, now you're going to undust some crouching corner cases, aren't you?
05:07:33 <heavensrevenge> main = print $ ((100^100)^(100^100)) == 0
05:07:51 <heavensrevenge> wount that just say false the moment the left side /= 0?
05:07:59 <heavensrevenge> from the lazy eval thing?
05:08:00 <Axman6> when o == 0!
05:08:08 <ksf> nah ^ is strict in both arguments.
05:08:33 <Axman6> > ((100^100)^(100^100)) == 0
05:08:37 <ski> well, i'm just saying that is we accept that equivalence, then `0 / 0 = 1' is the same as `0 = 1 * 0' .. but note that `0 = 2 * 0' also holds, so going backwards we arrive at `0 / 0 = 2', and thus `1 = 2'
05:08:43 <ksf> the darn thing is that infitity * 0 = anything you want.
05:08:50 <heavensrevenge> its not taking enough computation time to compute that # in my logic tho...
05:08:51 <ksf> as both are limits.
05:08:53 <Saizan> heavensrevenge: it has to evaluate both numbers completely, since an Integer is an atomic value with no subparts that can be left unevaluated
05:08:53 <byorgey> heavensrevenge: only if you are using a lazy numeric type.
05:08:56 <lambdabot>   thread killed
05:08:56 <heavensrevenge> also doesnt need much memory
05:09:36 <heavensrevenge> lol honestly this seems complex when it should be super simple...
05:09:55 <heavensrevenge> isnt there a function i can pass the result to that WONT let the result be printed on screen?
05:10:28 <Saizan> heavensrevenge: like i said before: main = print $ ((100^100)^(100^100)) `seq` (), that will print () on screen
05:10:30 <heavensrevenge> like main = notPrint . ((100^100)^(100^100))
05:10:48 <ski> (imo, the solution is to not allow `0 / 0' as determining a single value .. iow, it is a side-effectful expression)
05:10:58 <ksf> you can't point a finger at 0 as you can't point a finger at infinity. it's got as much existence on the number plane as pi in reality.
05:11:15 <Saizan> heavensrevenge: or you can use main = do return $! (100^100)^(100^100); return ()
05:11:34 <ksf> ski, it just has it's codomain esape its domain.
05:11:52 <ksf> like sqrt(-1)
05:12:01 <heavensrevenge> yea but i just dont want the result to print BUT to compute
05:12:09 <heavensrevenge> like using ghci
05:12:26 <Saizan> it will compute
05:12:34 <heavensrevenge> ok ill try it out
05:12:59 <ksf> uhhhmmmm... could it be that ghci eagerly computes that at compile time?
05:13:05 <ksf> s/ghci/ghc
05:13:11 <Saizan> no
05:14:04 <ski> ksf : well, `1 / 0' could be maybe argued to yield a value outside the codomain .. but the problem with `0 / 0' is that there are too many (i.e. more than one) possibly results, *in* the domain, that one could expect
05:14:41 <ksf> therefore, 0/0 is the set of all numbers?
05:14:48 <ski> no
05:15:16 <ski> `x / y' should be a number .. it shouldn't magically be a set of numbers whenever `x' and `y' happens to be zero
05:17:02 <ksf> why's that? 1/2 also yields a set of numbers of size one.
05:17:26 <opqdonut> x / y is a shorthand for x*y^-1
05:17:33 <opqdonut> if y^-1 doesn't exists, neither does x/y
05:17:47 <ski> then what does `{1/2}' ? a set of exactly one set of exactly one number ?
05:18:03 <ski> s/?/yield ?/
05:18:15 <ksf> yes?
05:18:57 <ski> so you want every expression at all to yield a set .. e.g. `1' would not be the number one, but a singleton set containing that number, is that right ?
05:19:32 <ksf> If I don't have to prove {1} == 1 to you, yes.
05:19:36 <heavensrevenge> thanks guys, i believe main = print $ ((100^100)^(*)) `seq` () worked just fine
05:19:49 <ski> `{1} = 1' is false, imo
05:20:25 <ksf> I'm just pointing at certain nesting problems multiple return values give raise to.
05:21:12 <ski> ok, then i've failed to notice which problems you were pointing at
05:21:39 <ksf> formal ones, nothing that can't be solved.
05:21:59 <ski> imo, it seems much simpler to actually let `1' denote the number one itself (whatever it really "is" .. doesn't matter)
05:22:29 <quicksilver> "1" certainly needs to be something different from "{1}"
05:22:38 <quicksilver> to be more precise
05:22:49 <quicksilver> in *general* "x" needs to be something different from "{x}"
05:22:55 <ski> yes (but i think ksf agrees to that)
05:22:55 <Saizan> otherwise we're wasting brackets
05:22:59 <ksf> well I never said that the set of results is a standard mathematical set.
05:23:05 <quicksilver> it's just about OK for them to coincide in specific cases
05:23:18 <quicksilver> if you want to study interesting non-standard set theories
05:24:43 <ksf> I never specifically liked sets, anyway, too much structure without any content.
05:24:43 <ski> ksf : would you care to explicate which problems you were intending to point at ?
05:24:52 <dolio> Well-founded sets are for hookers and fat people.
05:24:56 <ski> (ksf : that i can agree with)
05:25:39 <ksf> well if / returns a set, it also has to accept a set, resulting in an infinite type.
05:25:56 <ksf> but that's really not important.
05:25:59 <ski> (dolio : a bit bluntly stated, but roughly yes)
05:26:56 <litb> hello all
05:27:04 <litb> i'm trying to reverse a list using [ a!!x | x <- [(length a - 1) .. 0] ]
05:27:11 <litb> i know there is reverse. just playing
05:27:24 <ksf> damn you! I wanted be the first one to say
05:27:24 <Saizan> > [5..0]
05:27:26 <ksf> :t reverse
05:27:27 <litb> but actually, it doesn't work like i want
05:27:29 <lambdabot> forall a. [a] -> [a]
05:27:29 <lambdabot>   []
05:27:33 <litb> -.-
05:27:34 <Saizan> > [5,4..0]
05:27:35 <lambdabot>   [5,4,3,2,1,0]
05:27:36 <quicksilver> litb: you need to give the second index too
05:27:41 <litb> oh
05:27:41 <opqdonut> or use
05:27:43 <quicksilver> default increment is (+1)
05:27:50 <ski> (ksf : a way to state my "solution" is to let `/' return number, only sometimes it is not specified which of several (all correct) numbers you get)
05:27:54 <dolio> Wow. That may be even more inefficient than the standard inefficient reverse. :)
05:27:56 <litb> that's going to be painful then :)
05:29:46 <ksf> ski, i'm more in favour of having it really return _all_ numbers, if any of them is a valid answer. but the point is kinda moot.
05:30:24 <ski> ksf : well, in sense that's what my idea does .. in another, it doesn't  (yes i know that probably sounds confused :)
05:31:14 <ksf> Ergo: How many results does division have? Mu!
05:31:37 * quicksilver doesn't really see what's wrong with saying that (0/0) is undefined.
05:31:53 * lispy agrees with quicksilver
05:31:55 <dolio> 0/0 is nullity.
05:31:56 <ski> ksf : if we're talking about division over the rationals, then it ought to have `|Q' results
05:31:59 <dolio> What are you guys arguing about?
05:32:01 <lispy> dolio: oh not
05:32:04 <ksf> quicksilver, bottom is bad, mkey?
05:32:06 <lispy> dolio: er oh no...not nulity
05:32:22 <ski> quicksilver : nothing wrong with that .. we're just considering something more permissive
05:32:37 <ski> (: lispy
05:33:14 * lispy recalls reading some wikipedia article by a nutbag that claimed to solve the division by 0 problem with nullity...ugh.
05:33:24 <ksf> in fact,
05:33:26 <ksf> > 0/0
05:33:28 <lambdabot>   NaN
05:33:36 <ksf> it escapes its codomain.
05:33:36 <quicksilver> "James Anderson", lispy
05:33:47 <quicksilver> http://cale.yi.org/index.php/Open_letter_to_James_Anderson
05:33:53 <lambdabot> Title: Open letter to James Anderson - CaleWiki
05:34:05 <dolio> lispy: You won't be so high and mighty when I'm using my perspex machine to solve the halting problem.
05:34:18 <opqdonut> nullity
05:34:20 <opqdonut> argh
05:34:26 <litb> is there some way one can say the increment is -1 without repeating the previous one ?
05:34:29 <ski> ksf : yes, according to IEEE 754
05:34:37 <ksf> dolio, I use to slam my foot on the break to do that.
05:34:56 <ksf> If that's a koan, I don't get it.
05:35:07 <ski> @hoogle fromStepTo
05:35:08 <lambdabot> No results found
05:35:11 <litb> maybe by doing  .. 1, 0  at the end or so?
05:35:12 <ski> bah
05:35:13 <lispy> dolio: haha
05:35:29 <litb> oh right that was it
05:36:35 <ski> dolio : hah, my might BSS machine will crush your machine like a bug
05:36:57 <Axman6> bullshit surprise?
05:37:01 <ski> almost
05:37:08 <ski> Blum-Shub-Smale
05:37:23 <ski> (Ia Ia Shub-Niggurath !)
05:37:27 <Axman6> that is unusually hard to say
05:37:38 <opqdonut> ski: :D
05:38:14 <ksf> quicksilver, codata seems to be the concept I'm looking for, but all those bastards in here keep me from reading the paper.
05:38:29 <Philonous1> > [x,x-1..0] where x = 10 -- litb
05:38:30 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
05:38:38 <lispy> ski: are you quoting Quake?
05:38:46 <ski> ksf : concept you're looking for, wrt *what* ?
05:39:07 <dolio> I don't see what codata has to do with 0/0.
05:39:08 <Axman6> > length [ ()| x <- ['a'..'z'], y <- [x..'z'], z <- [y..'z]]
05:39:09 <lambdabot>   <no location info>:
05:39:09 <lambdabot>      lexical error in string/character literal at chara...
05:39:18 <Axman6> > length [ ()| x <- ['a'..'z'], y <- [x..'z'], z <- [y..'z']]
05:39:19 <lispy> ksf: just go read sigfpe's blog...it will help you understand it faster than a paper :)
05:39:19 <lambdabot>   3276
05:39:25 <ski> (lispy : well, i was quoting the same source that Quake probably did)
05:39:25 <lispy> ?quote sigfpe.learned
05:39:25 <dolio> Aside from the infinite list of answers it produces being codata.
05:39:25 <lambdabot> No quotes match. Wrong!  You cheating scum!
05:39:31 <Axman6> that was... a lot quicker than i thought it would be
05:39:36 <ksf> considering turing-completeness as evil and restricting its usage to whenever I really must use it.
05:40:03 <Philonous1> ksf: Which paper is that?
05:40:08 <quicksilver> Philonous1: turner's
05:40:17 <ksf> I'm trying to completely beat operational semantics out of my head before reproaching c++
05:40:18 <quicksilver> which is a fairly good review of the topic as far as I recall
05:40:21 <lispy> ski: there was a full length movie made in the quake engine to explain the backstory by an independent 3rd party group and they used that phrase a lot...something like, Seal of Neharah or some such
05:40:28 <ksf> http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf
05:40:32 <ski> (ksf : <http://www.jucs.org/jucs_10_7/total_functional_programming> ?)
05:40:32 <lambdabot> Title: cache:http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751 ..., http://tinyurl.com/2fcfrr
05:40:42 <Philonous1> Thanks a bomb :)
05:40:50 <dolio> Does Turner get into codata much? I thought he just kind of mentions it in passing.
05:40:55 <opqdonut> lispy: it's from edgar allan poe, popularisized by the illuminatus trilogy
05:41:10 <lispy> opqdonut: ah ha
05:41:14 <opqdonut> all this cthulhu and shub-niggurath stuff
05:41:36 <ksf> ski, yes, that's a human-computed redirect.
05:42:01 * ksf thinks iddqd is a deamon.
05:42:05 <ski> (.. "Powered by Humans")
05:42:17 * lispy sings, life is a monad ... and I'm gonna fmap it all night long...
05:42:59 <Axman6> lispy: just gave me a good idea for the name of a haskell project: hawt... now i just need a project for it...
05:43:50 <ski> Haskell AWT
05:43:51 <ksf> @freshname
05:43:51 <lambdabot> Haa
05:44:00 <opqdonut> haskell WAT
05:44:03 <opqdonut> :P
05:44:27 <ski> ksf : well ?
05:44:34 <opqdonut> @freshname
05:44:34 <lambdabot> Hab
05:44:35 <ksf> gonna be a long time 'till we reach hawt.
05:44:35 <Axman6> ski: where AWT = ...?
05:44:45 <lispy> AWT is the java gui toolkit
05:44:47 * Axman6 is already there
05:44:49 <quicksilver> Abstract Wickedness Toolkit
05:44:52 <Axman6> oh... ew
05:44:56 <litb> i'm sorry
05:45:03 <litb> has been so many times since my last haskell jorney
05:45:03 <quicksilver> HAWT, for all your hawt abstract wickedness!
05:45:05 <opqdonut> quicksilver: ITYM Absurd Wickedness Toolkit
05:45:10 <ski> Axman6 : sorry, yes `Abstract Window Toolkit'
05:45:12 <litb> Prelude> let b (a:x) = (b x) ++ [a]
05:45:12 <litb> Prelude> let b [] = []
05:45:13 <quicksilver> hmm. Perhaps that.
05:45:19 <litb> how is that non exhaustive?
05:45:30 <ksf> litb, yes.
05:45:40 <litb> seems to handle everything
05:45:47 <quicksilver> litb: well it's two separate definitions
05:45:52 <ksf> you just redefined b instead of specifying a second case.
05:45:52 <quicksilver> the second one shadowed the first.
05:45:53 <litb> either the list is empty, or the list is not empty (a:[])
05:45:55 <litb> oh
05:46:00 <quicksilver> put them together with ;
05:46:05 <litb> i see
05:46:07 <ski> litb : you want one single definition, not two subsequent over-shadowing ones
05:46:08 <quicksilver> let b (a:x) = (b x) ++ [a] ;  b [] = []
05:46:22 <Axman6> HAWT: Haskell Amazing Word Tricks, a string manipulation library
05:46:24 <ski> Prelude let b (a:x) = b x ++ [a]; b [] = []
05:46:45 <ksf> @karma+ ghci-multiline-input
05:46:46 <lambdabot> ghci-multiline-input's karma raised to 1.
05:46:56 <litb> thanks :)
05:47:29 <Axman6> @let b (a:xs) = (b xs) ++ [a]; b [] = []
05:47:30 <lambdabot>  <local>:1:12:
05:47:30 <lambdabot>      Ambiguous occurrence `b'
05:47:30 <lambdabot>      It could refer to either `L...
05:47:34 <lispy> Haskell Ascending Word Trie
05:47:50 <Axman6> @let bah (a:xs) = (b xs) ++ [a]; bah [] = []
05:47:51 <lambdabot>  Couldn't match expected type `[t] -> [a]'
05:47:55 <Axman6> @let bah (a:xs) = (bah xs) ++ [a]; bah [] = []
05:47:56 <lambdabot>  Defined.
05:48:08 <Axman6> > bah "fine then, see if i care!"
05:48:09 <lambdabot>   "!erac i fi ees ,neht enif"
05:48:19 <ski> Haskell After Work T... ?
05:48:25 <lispy> Testing?
05:48:36 <lispy> Training?
05:48:41 <litb> lol
05:48:41 <Axman6> Haskell Awesome Wow Testing
05:48:55 <Axman6> it's testing, on steroids!
05:49:09 <lispy> Haskell Amazing Web Tags
05:49:22 <ski> Haskellers Are Worrying Toomuch
05:49:25 <C-Keen> what happens in haskell when you have a case statement and nothing matches?
05:49:29 <Axman6> Haskell Amazing Web Tuner
05:49:34 <lispy> C-Keen: exception
05:49:37 <ski> C-Keen : pattern-match failure
05:49:41 <ski> > head []
05:49:42 <lambdabot>   * Exception: Prelude.head: empty list
05:49:44 <C-Keen> figures
05:49:44 <ski> @src head
05:49:44 <lambdabot> head (x:_) = x
05:49:44 <lambdabot> head []    = undefined
05:49:49 <ski> er
05:49:53 <lispy> > let foo = case 1 of 2 -> Just 2 in foo
05:49:54 <lambdabot>   * Exception: /tmp/8359523776069686618:71:54-74: Non-exhaustive patterns in ...
05:49:56 <ksf> Haskell appetising wombat toasts
05:49:57 <ski> > head []  where  head (x:_) = x
05:49:58 <lambdabot>   * Exception: /tmp/6202008624271999833:71:48-61: Non-exhaustive patterns in ...
05:50:15 <Axman6> > case (Just 1) of Nothing -> "whoot"
05:50:16 <lambdabot>   "* Exception: /tmp/5900022237966928766:71:36-70: Non-exhaustive patterns in...
05:50:23 <ski> > (\[] -> ()) [0]
05:50:25 <lambdabot>   * Exception: /tmp/3661662093549586754:71:37-45: Non-exhaustive patterns in ...
05:50:35 <ski> > let [] = [0] in ()
05:50:37 <lambdabot>   ()
05:50:45 <Axman6> heh
05:50:53 <ski> > let [] = [0] in []
05:50:53 <lispy> Haskell's Affirmative Web Toolkit
05:50:54 <lambdabot>   []
05:51:35 <nominolo|msr> > (\~[] -> ()) [0]
05:51:37 <lambdabot>   <no location info>: parse error on input `->'
05:51:48 <Axman6> i'm liking this web idea... could make one of those apps that strips CSS files and such of useless extras
05:51:50 <litb> no "where" in lambdas? :/
05:51:51 <ksf> Haskell's Arrow Web Toolkit?
05:52:02 <ski> litb : no `where' on any expressions
05:52:04 <lispy> Axman6: yeah, that'd be hawt
05:52:08 <litb> "haha" == (\x -> xi x where xi (y:my) = (xi my) ++ [y]; xi [] = []) "haha"
05:52:09 <litb> -.-
05:52:11 <nominolo|msr> > (\(~[]) -> ()) [0]
05:52:12 <lambdabot>   ()
05:52:48 <Axman6> > bah "lol"
05:52:49 <lambdabot>   "lol"
05:52:57 <Axman6> zomg, it werks!
05:53:01 <litb> @src lol
05:53:01 <lambdabot> Source not found. Maybe if you used more than just two fingers...
05:53:06 <litb> @src bah
05:53:06 <lambdabot> Source not found. Where did you learn to type?
05:53:07 <litb> -.-
05:53:10 <ski> How Are We Today ?
05:53:16 <lispy> oh, @src should be extended to know about ?let
05:53:20 <Axman6> we're HAWT!
05:53:31 <Axman6> lispy: indeed, that'd be handeh
05:53:43 <lispy> Haskell Android Web toolkit (it's for Google's new phone)
05:53:48 <Axman6> maybe even HAWT
05:53:53 <Axman6> ew
05:53:55 <litb> great works
05:53:57 <litb> :p
05:54:06 <Axman6> lispy: hear about their latest bug?
05:54:14 <lispy> Axman6: aye, the reboot thing?
05:54:21 <Axman6> it's worse than that
05:54:37 <lispy> Axman6: the root shell right?
05:54:41 <Axman6> yeah
05:54:57 <lispy> So doen't share your phone until the patch comes out :)
05:55:08 <ksf> Haskell's applicative web toolkit
05:55:28 <ksf> applicable to any problem...
05:55:34 <Axman6> Haskell Abstract Wow Tree
05:55:55 <lispy> Haskell Antique Wiki Text
05:56:22 <litb> http://stackoverflow.com/questions/52002/how-to-check-if-the-given-string-is-palindrome?answer=277727#277727  <- look in the haskell way :p
05:56:23 <lispy> Okay, back to serious work
05:56:28 <lambdabot> Title: How to check if the given string is palindrome? - Stack Overflow, http://tinyurl.com/5zf7qc
05:57:53 <Axman6> where seriousWork = sleep
05:57:56 <Axman6> night all
05:57:59 <lispy> night
05:58:08 <opqdonut> lispy: lol, why has he redefined reverse
05:58:33 <Axman6> opqdonut: me?
05:58:38 <litb> opqdonut: because another guy already gave an example using reverse
05:58:41 <opqdonut> ah
05:58:54 <litb> he would blame be copying his neat code :p
05:58:57 <dolio> > ap (==) reverse "noon"
05:58:58 <lambdabot>   True
05:59:02 <opqdonut> and i meant to say "litb : "
05:59:23 <litb> lol dolio nice too
05:59:48 <Axman6> dolio: damn, i'd just started thinking along those lines. wouldn't have thought of ap though
05:59:58 <Axman6> still not sure where it can be used
06:00:11 <dolio> Clearly you haven't been reading the output of @pl enough.
06:00:12 <litb> i wonder how i can make my example point-free
06:00:29 <Axman6> dolio: i try to avoid it where possible
06:00:37 <lispy> litb: just ask lambdabot
06:00:40 <litb> i've done this now: let haha = ((a ==) . (let xi (y:my) = (xi my) ++ [y]; xi [] = [] in \x -> xi x))
06:00:42 <lispy> ?pl \x y -> x + y
06:00:42 <lambdabot> (+)
06:00:51 <litb> but it wants the string to times of course -.-
06:01:23 <opqdonut> use ap
06:01:26 <opqdonut> like dolio did
06:01:37 <litb> hold on im looking it up
06:01:38 <Axman6> @pl bah
06:01:38 <lambdabot> bah
06:01:40 <litb> @src ap
06:01:40 <lambdabot> ap = liftM2 id
06:01:41 <Axman6> dang
06:01:43 <lispy> ?pl xi (y:my) = (xi my) ++ [y]
06:01:44 <lambdabot> xi = fix ((`ap` tail) . (. head) . (. return) . flip . ((++) .))
06:01:49 <litb> @src liftM2
06:01:49 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:01:56 <litb> oh noes those monads again :p
06:02:05 <Saizan> xi = foldl (flip (:)) []
06:02:25 <lispy> Saizan: right, good call
06:02:25 <wjt> so in ((->) a)    ap f foo bar -> \x -> f (foo x) (bar x)   ?
06:02:51 <Axman6> anyway, sleep time. o/
06:02:53 <Saizan> wjt: ap f g = \x -> f x (g x)
06:03:03 <lispy> > ap (-) (+1) (*2) 3
06:03:04 <lambdabot>       No instance for (Num (a -> a))
06:03:04 <lambdabot>        arising from a use of `-' at <int...
06:03:17 <wjt> oh, s
06:03:21 <Saizan> yeah
06:03:26 <litb> i remember it uses the r -> monad
06:03:28 <litb> but that's all :p
06:03:39 <lispy> > ap (-) (+1) 3
06:03:41 <lambdabot>   -1
06:04:09 <PeakerWork> why is ((->) a) used instead of (a->) ?
06:04:09 <ski> > join ((==) . reverse) . filter isAlpha . map toLower $ "Rats live on no evil star."
06:04:11 <lambdabot>   True
06:04:13 <lispy> ?check \x -> ap (-) (+1) x == (-1)
06:04:14 <lambdabot>   "OK, passed 500 tests."
06:04:18 <PeakerWork> (that syntax is confusing)
06:04:28 <lispy> PeakerWork: because (a->) just isn't valid
06:04:30 <Saizan> ?djinn (r -> a -> b) -> (r -> a) -> (r -> b)
06:04:30 <lambdabot> f a b c = a c (b c)
06:04:33 <ski> PeakerWork : only because there is no sections of operators in the type-level
06:04:44 <opqdonut> mhmm
06:04:50 <PeakerWork> ski: Bummer
06:07:08 <ski> (Was it a rat I saw ?)
06:09:01 <ski> @scheck join ((==) . reverse)
06:09:02 <lambdabot>   "OK, passed 500 tests."
06:09:20 <PeakerWork> What's "scheck"?
06:09:25 <ski> smallcheck
06:09:51 <dolio> @pl join (f . g)
06:09:51 <lambdabot> f =<< g
06:10:34 <ski> @scheck join ((==) . (+1))
06:10:35 <lambdabot>   "Falsifiable, after 0 tests:\n2\n"
06:10:47 <dolio> @pl join (flip f . g)
06:10:47 <lambdabot> flip f =<< g
06:14:49 <dolio> @pl join ((. f) . g)
06:14:49 <lambdabot> g `ap` f
06:15:12 <lispy> ?pl return f `ap` g
06:15:13 <lambdabot> f `fmap` g
06:15:20 <lispy> ?pl return f `ap` g `ap` h
06:15:20 <lambdabot> liftM2 f g h
06:18:32 <ksf> ski, we might want to type / as (Rat a, Rat b | b /= 0) => a -> b -> a
06:19:03 <lispy> ksf: wouldn't that be a dependent type?
06:19:09 <jpcooper> how can I get sqrt to give me complex numbers?
06:19:13 <jpcooper> :t sqrt
06:19:14 <lambdabot> forall a. (Floating a) => a -> a
06:19:22 <ksf> I JUST INVENTED DEPENDENT TYPES!
06:19:23 <ddarius> > sqrt (-1) :: Complex Double
06:19:24 <lambdabot>   (-0.0) :+ 1.0
06:19:26 <ksf> WORSHIP ME!
06:19:44 <lispy> > sqrt (-1) :: CReal
06:19:59 <lambdabot>   thread killed
06:20:03 <lispy> wtf?
06:20:11 <lispy> > sqrt 2 :: CReal
06:20:13 <lambdabot>   1.4142135623730950488016887242096980785697
06:20:14 <ksf> :t sqrt
06:20:15 <lambdabot> forall a. (Floating a) => a -> a
06:20:19 <lispy> > sqrt (-1) :: CReal
06:20:24 <ksf> no complexes around there.
06:20:34 <lambdabot>   thread killed
06:20:35 <lispy> So, why is CReal _|_ on sqrt -1
06:20:51 <roconnor> what should it be?
06:20:58 <lispy> i
06:21:07 <ksf> because sqrt(-1) = i and i nelem Floating
06:21:19 <roconnor> > sqrt (-1) :: Complex CReal
06:21:22 <lambdabot>   0.0 :+ 1.0
06:21:30 <lispy> Oh, what is the C then?
06:21:36 <lispy> I thought C for ComplexReal or something
06:21:38 <ddarius> Computable
06:21:45 <lispy> ha!
06:21:53 <lispy> (my next guess was continuous)
06:22:49 <lispy> > sqrt (-1) :: Double
06:22:52 <lambdabot>   NaN
06:23:03 <lispy> At least that terminates
06:24:38 <Lemmih> dcoutts: I've updated hackage-server.
06:24:53 <jpcooper> thanks ddarius
06:26:37 <ksf> "In the same spirit any built in operations must be total. This will involve a
06:26:37 <ksf> some non-standard decisions - for example we will have
06:26:37 <ksf> 0 / 0 = 0"
06:27:03 <lispy> > 0 / 0 :: CReal
06:27:18 <lambdabot>   thread killed
06:27:30 * lispy is not convinced!
06:30:33 <PeakerWork> ksf: that sounds crazy...
06:31:59 <ksf> http://www.jucs.org/jucs_10_7/total_functional_programming
06:32:01 <lambdabot> Title: (D. A. Turner) Total Functional Programming
06:33:56 <ddarius> lispy: Continuous would also work.  continuous = computable (given a suitable topology)
06:34:46 <lispy> ddarius: I wouldn't know how to prove that, but that was my intuition
06:35:26 <lispy> ddarius: like how continuous on the integers means something different even though the definition of continuous is unmodified
06:38:25 <dolio> 0/0 = 0 is probably the biggest mistake in the paper.
06:38:40 <dolio> Since it seems to cause lots of people to go "this guy is nuts."
06:39:23 <dolio> And there are less obviously bad ways to handle that case, although they're harder to explain in one line.
06:42:38 <ddarius> Incidentally, what would discontinuous reals be?
06:42:46 <quicksilver> dolio: turner's paper?
06:42:54 <dolio> quicksilver: Yeah.
06:42:58 <dcoutts> Lemmih: oh great
06:43:58 <quicksilver> anyone who thinks turner is nuts needs to do a little boning up ;)
06:44:06 <dolio> :)
06:46:02 <Lemmih> dcoutts: I'm not sure how to proceed. Do you have time to tell me what to do?
06:46:16 <dcoutts> Lemmih: for the serving .tar file contents?
06:48:15 <quicksilver> ddarius: but the topology which makes computable, continuous, is very different from the topology which is normally used in the definition of real.
06:48:20 <quicksilver> (in the analysis sense)
06:48:36 <Lemmih> dcoutts: Serving .tar files I can do. I was thinking about the haddock documentation.
06:48:42 <dcoutts> Lemmih: so I guess there's three parts, a type to represent a tar file index, basically a map of file names to offsets in the tarball. Then we need a function for reading such an index from the tar file. Lastly a ServerPart for serving the tar contents given the index and a BlobId of the uncompressed .tar file.
06:48:45 <dcoutts> Lemmih: ah ok,
06:49:18 <dcoutts> Lemmih: then we will add the ability to PUT a .tar.gz bundle of haddock docs for each package
06:52:42 <rog> @pl \ tot mv -> mv >>= \v -> return $ tot ^+^ v
06:52:42 <lambdabot> fmap . (^+^)
06:52:57 <rog> i love the way @pl can untangle my tangled mind...
06:53:01 <roconnor> OpenGL does gamma correction before display?
06:53:05 <roconnor> ... it must
06:55:07 <roconnor> @tell conal Oops, I think OpenGL requires colour data in a linear colour space.  I need to export another function for you to use my lib.
06:55:08 <lambdabot> Consider it noted.
06:55:31 <Lemmih> dcoutts: Like: /packages/hackage-server-0.1/documentation/doc/html/hackage-server/index.html?
06:56:19 <dcoutts> Lemmih: right, though perhaps we don't need such a long url
06:56:49 <dcoutts> Lemmih: I guess it'll depend on the structure we expect inside the doc tarball, if necessary we can add a shortcut
06:56:51 <Lemmih> dcoutts: Should we drop the 'doc/html/hackage-server/' part?
06:57:04 <dcoutts> Lemmih: let's worry about that later
06:59:30 <roconnor> > sqrt 0 :: CReal
06:59:34 <lambdabot>   0.0
07:00:10 <roconnor> > sqrt (-(10^(-20))) :: CReal
07:00:12 <lambdabot>   * Exception: Negative exponent
07:00:20 <roconnor> > sqrt (-(10^^(-20))) :: CReal
07:00:36 <lambdabot>   thread killed
07:00:42 <roconnor> > sqrt (-(10^^(-100))) :: CReal
07:00:44 <lambdabot>   0.0
07:01:49 <roconnor> > showCReal 100 (sqrt (-(10^^(-100))))
07:02:04 <lambdabot>   thread killed
07:03:13 <Raul> hello everybody
07:04:12 <Raul> i need some help with my haskell code
07:04:47 <BONUS> just ask :)
07:06:14 <Raul> http://hpaste.org/11919
07:06:46 <Raynes> Thats the catchphrase "Don't ask to ask just ask"
07:07:02 <Raul> theres an parse error in line 18:29
07:07:37 <Raul> and i dont know why and what it means
07:07:46 <BONUS> the show' functions
07:07:51 <BONUS> i mean equations
07:07:55 <BONUS> should be aligned with the first one
07:08:22 <Raul> ah...i see
07:08:30 <Raul> its an problem with my editor
07:08:36 <BONUS> i see you have sort of mixed tabs and spaces yeah
07:08:45 <BONUS> just set your editor to use spaces instead of tabs
07:08:55 <Raul> thanks
07:08:58 <BONUS> np
07:09:00 <Raul> that was easy ;)
07:09:03 <BONUS> hehe
07:12:42 <Raynes> EclipseFP TAB's by default.
07:12:57 <Raynes> If you install it and don't know to set it to spaces your in for a bit of trouble.
07:13:42 <BONUS> in vim you just do :set expandtab
07:20:08 <Raul> ah, get it...here its "Insert Spaces for Tabs"
07:22:44 <ziman> what's the difference between data and codata? the definition in the `total FP' paper is: "data List a = Nil | Cons a (List a)" and "codata Colist a = Conil | a <> Colist a"
07:22:48 * matthew-_ has spent the last 5 minutes "being glad" that haddock can now generate docs for the sessions library: http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
07:22:49 <ziman> i fail to see the difference.
07:22:54 <lambdabot> Title: Control.Concurrent.Session, http://tinyurl.com/5mxxz6
07:23:07 <saml> @hoogle codata
07:23:08 <lambdabot> No results found
07:23:13 <Saizan> ziman: the difference is on the kind of recursion you're allowed to use on it
07:23:43 <saml> http://sigfpe.blogspot.com/2007/07/data-and-codata.html
07:23:44 <Saizan> ziman: and corecursion is explained shortly after
07:23:44 <lambdabot> Title: A Neighborhood of Infinity: Data and Codata
07:24:53 <ziman> so the actual `form' or `shape' of data is the same as that of codata?
07:25:25 <ziman> saml, thank you for the link
07:26:10 <saml> ziman: thank you for thank you
07:26:49 <Saizan> matthew-_: time for syntactic sugar in types?
07:27:09 <matthew-_> Saizan: I think just giving haddock more clue about layout would be a good thing
07:27:17 <matthew-_> currently it's easier to read in the source
07:27:18 <quicksilver> ziman: "List"s will always be finite, because they will always be constructed by a very restriced form of recursion
07:27:31 <matthew-_> compare http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session-Interleaving.html#t%3AFork with http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/src/Control-Concurrent-Session-Interleaving.html#Fork
07:27:32 <lambdabot> Title: Control.Concurrent.Session.Interleaving, http://tinyurl.com/55bhzr
07:28:25 <paczesiowa> doesn't that "|" in codata mean "and" instead of "|" in data meaning "or" ? so we have two destructors instead of constructors?
07:31:41 <dolio> I'm not sure I see how one is and and the other or.
07:34:42 <RayNbow> did I miss the conversation about nullity? :p
07:35:50 <lispy> RayNbow: let me recap
07:35:56 <lispy> Nullity avoids 0/0
07:35:59 <dolio> The "|" in both cases essentially comes from the functor.
07:35:59 <lispy> Nullity sucks!
07:36:14 <lispy> <link to intelligent rant on why nullity is not that special>
07:36:14 <RayNbow> 0/0 = %
07:36:18 <RayNbow> problem solved! :p
07:36:42 <dolio> In data, you're listing ways to put things together, in codata, you're listing things you might see when you take things apart.
07:36:59 <lispy> I think the main reason to find Nullity offensive is the marketing approach taken by the creator.
07:37:06 <Saizan> so they are both "or"
07:37:28 <EmielRegis> @src Vector
07:37:28 <lambdabot> Source not found. That's something I cannot allow to happen.
07:38:17 <b_jonas> which module has a random state monad or monad transformer?
07:38:31 <paczesiowa> dolio: from what I understood (only heard talks about it, I actually never used anything "co"), to create data you choose one constructor and "do" it, but to create codata you have to provide all destructors, is this correct?
07:39:43 <Saizan> paczesiowa: i think you're referring to a slightly different way to formalize codata
07:39:55 <RayNbow> lispy: I really don't see how nullity avoids 0/0... the inventor must be smoking some crack :p
07:40:02 <RayNbow> *must have been
07:41:44 <Saizan> paczesiowa: in that context an infinite (Stream a) would have two destructors: next :: Stream a -> Stream a, value :: Stream a -> a
07:42:19 <Saizan> paczesiowa: and then any (Stream a) must be able to "respond" to both
07:42:20 <dolio> paczesiowa: Well, I guess that may be. Creating codata isn't really analogous to creating data.
07:42:55 <dolio> Creating codata is dual to destroying data.
07:43:09 <dolio> And creating data is dual to destroying codata, more or less.
07:43:16 <paczesiowa> anyway, is it coscary
07:43:23 <paczesiowa> *it is
07:43:28 <Mzzz> A question here. We can implement $! with seq, but we can also implement seq with $!, why do we select seq, but not $!, as the primitive?
07:43:44 <EmielRegis> hmm
07:43:54 <EmielRegis> can you use data in defining other data?
07:44:10 <EmielRegis> or itmust use basic types only?
07:44:25 <dolio> But when you write something like 'codata Colist a = Conil | Cocons a (Colist a)' in agda, what you're listing is the observations you can make, more or less.
07:44:30 <Saizan> while with codata Stream a = Nil | Cons a (Stream a) we're actually defining data StreamView a = Nil | Cons a (Stream a), and a single destructor view :: Stream a -> StreamView a
07:44:59 <dolio> Or, what you might see when you make an observation, that is (it'll either be a Conil or a Cocons).
07:45:12 <Lemmih> Mzzz: seq is simpler.
07:45:20 <paczesiowa> cocons:D
07:45:42 <paczesiowa> "co" prefix makes everything funny
07:45:43 <dolio> seq x y = const y $! x
07:46:29 <osfameron> copaczesiowa: yeah, it does!
07:46:37 <Mzzz> Lemmih: You mean easier to implement?
07:47:44 <b_jonas> paczesiowa: you mean like the ", except in bed" or the " ass-" thingy in xkcd?
07:49:09 <xhanjian> @src Monad IO
07:49:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:49:21 <b_jonas> paczesiowa: http://xkcd.com/425/ and http://xkcd.com/37/ resp
07:49:23 <lambdabot> Title: xkcd - A Webcomic - Fortune Cookies
07:49:24 <paczesiowa> I'm not xkcd fanatic, I find only few of the strips funny, so I don't know what are you talking about
07:49:46 <b_jonas> @src IO
07:49:47 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
07:52:27 <Lemmih> Mzzz: It is conceptually simpler.
07:54:16 <b_jonas> Lemmih: wouldn't \x -> seq x () be even more simpler conceptually? you can also implement seq from that, by casing on the unit
07:54:19 <Mzzz> Lemmih: I think that depends on the intended use. Or may be it is just a matter of taste.
07:56:30 <Lemmih> b_jonas: The unit is unnecessary. It can be simplified away.
07:57:09 <Mzzz> b_jonas:  \x -> seq x () is simpler, but it can not combine things, and thus nearly useless.
07:57:52 <Lemmih> Mzzz: It is objectively the simplest. 'y depends on x' is the shortest rule that satisfies all the requirements.
07:59:36 <b_jonas> Mzzz: I think it can. from sequnit = \x -> seq x (); you can define seq as seq x y = case sequnit x { () -> y }
07:59:45 <b_jonas> missing an of
08:00:30 <ksf> @karma+ tab-is-not-a-valid-token
08:00:31 <lambdabot> tab-is-not-a-valid-token's karma raised to 1.
08:00:44 <Mzzz> Lemmih: I don't think seq says anything about dependence, but just ordering.
08:01:24 <ksf> tabs aren't meant to be used at the start of a line.
08:02:11 <ksf> they're just a poor-man's formatting function.
08:05:17 <Mzzz> b_jonas: Yes, you are right.
08:14:47 <pythonist> Any hslogger expert?
08:15:55 <Lemmih> pythonist: Ask your question and you'll find out.
08:16:09 <pythonist> Why my messages get printed twice? --> http://haskell.pastebin.com/m274a7d97
08:18:45 <camio> pythonist: What exactly is your output?
08:19:50 <pythonist> camio: http://haskell.pastebin.com/m43a7ac3f
08:20:07 <pythonist> camio: without the setHandlers, I get:
08:20:42 <pythonist> Cant't open directory.
08:20:42 <pythonist> [Blog/DEBUG] Cant't open directory.
08:21:02 <pythonist> camio: See, the message gets printed twice.
08:23:02 <Lemmih> pythonist: try 'setHandlers' instead of 'addHandler'.
08:23:25 <pythonist> Lemmih: I did. THe result is the same.
08:23:38 <pythonist> Lemmih: I argue that the root logger is still logging.
08:23:55 <pythonist> Lemmih: but I don't know how to reset its handlers.
08:25:15 <pythonist> Lemmih: If I do, I get: http://haskell.pastebin.com/m43a7ac3f
08:25:56 <camio> pythonist: You get an error message?
08:26:29 <Lemmih> pythonist: Did you try 'setHandlers [h]' ?
08:27:47 <pythonist> Lemmih: http://haskell.pastebin.com/m52d79c76
08:28:09 <pythonist> camio: That's what I get in both cases.
08:28:30 <pythonist> camio: If I try to reset root logger's handlers I get http://haskell.pastebin.com/m43a7ac3f
08:28:38 <pythonist> I'm stuck.
08:30:29 <camio> you want it only to output the [Blog/DEBUG] style line?
08:30:38 <pythonist> yes
08:32:42 <camio> Is the printf generating the other style line?
08:33:26 <pythonist> camio: oh my God...
08:33:33 <camio> ;)
08:33:41 <pythonist> camio: :D
08:34:14 <pythonist> camio: wait, I'm checking it out...
08:34:27 <sander___> would it be hard to implement something like this: http://www.hypernation.net/wiki/DownloadRgreylist in Haskell?
08:34:28 <lambdabot> Title: DownloadRgreylist – rGreylister
08:35:25 <camio> sander___: Only if you have to learn haskell first.
08:35:54 <sander___> lol
08:36:00 <sander___> I know a little bit of Haskell
08:36:11 <pythonist> camio: No. It doesn't work. http://haskell.pastebin.com/m5095003d
08:38:00 <camio> pythonist: I'm stumped.
08:38:21 <pythonist> camio: Me too.
08:40:02 <pythonist> camio: Possibly the solution is this snippet: http://haskell.pastebin.com/m43a7ac3f
08:40:34 <pythonist> camio: but I don't know how to add a proper type signature to [] to make the type checker happy.
08:46:03 <skorpan> could someone tell me what the heck "S K K" means in lambda calculus?
08:46:44 <Philonous> Is there a way to import a module both qualified and unqualified?, i.e. I want to use most of it's functions unqualified and only those which conflict with another module with a abbreviated qualified name
08:47:27 <skorpan> nvm
08:47:46 <pythonist> camio: I've found the trick.
08:48:05 <b_jonas> skorpan: I think it's identity
08:48:26 <pythonist> camio: Basically you can't simply discard the rootLogger because it has to be there.
08:48:33 <maltem> skorpan: I think it's const
08:48:38 <Philonous> skorpan: SKK is in the SKI calculus, not lambda calculus (which are semantically equivalent though). S K K reduces to I
08:48:51 <maltem> damn
08:48:52 <pythonist> camio: I simply replaced the standard handlers with mine in the root logger and now it works fine.
08:49:55 <pythonist> camio,Lemmih: http://haskell.pastebin.com/m409660b9
08:50:12 <pythonist> camio,Lemmih: Thank you.
08:50:50 <maltem> skorpan: S K K = \x. K x (K x) = \x. x   -- really looks like identity now
08:51:11 <camio> pythonist: cool!
08:57:18 <EmielRegis> hmm
08:57:29 <EmielRegis> if I have data Vec_t = Vec_t (Float,Float,Float) deriving (Eq, Show)--x y z
08:57:45 <EmielRegis> how can I obtain the x y and z variables?
09:00:13 <EvilTerran> EmielRegis, by pattern matching
09:00:25 <EmielRegis> :S
09:00:30 <EvilTerran> "foo :: Vec_t -> ...; foo (Vec_t (x,y,z)) = ..."
09:00:46 <EmielRegis> ah
09:00:48 <EmielRegis> thank you
09:00:59 <EvilTerran> btw, note that you could write an equivalent type without the tuple, as constructors can have multiple parameters
09:01:14 <EvilTerran> "data VecT = VecT Float Float Float deriving (Eq,Show)"
09:01:36 <EvilTerran> (or Vec_t if you prefer, but the convention in haskell is to use CamelCase rather than underscores)
09:01:52 <Corun> CamelCase ftw
09:02:07 <EmielRegis> mhm k
09:02:42 <EvilTerran> if you were to write "data VecT = VecT { vecX, vecY, vecZ :: Float }", that would mean the same thing as "data VecT = VecT Float Float Float"...
09:02:51 <PeakerWork> why not parameterize the Float?
09:02:55 <EvilTerran> ... but also introduce functions  vecX, vecY, vecZ :: VecT -> Float
09:03:19 <EvilTerran> and it'd also allow you to, say, pattern-match only the y by saying "foo VecT{vecY = y} = ..."
09:03:46 <Lemmih> dcoutts: Is uploading documentation a PUT or a POST?
09:04:22 <EmielRegis> oh
09:04:23 <EmielRegis> cool
09:04:25 <EmielRegis> thanks
09:05:46 <EvilTerran> EmielRegis, and you could also then construct values similarly, as in "VecT{vecX = 1, vecZ = 3, vecY = 2}" (the order doesn't matter)
09:07:31 <skorpan> hur går det anders^^
09:08:40 <whoppix> Hey guys, a little question.. I've been learning haskell for a few days now, and until now all examples I have seen have been recursive, none iterative. Does Haskell support iterative constructs at all, and is iteration a commonly used technique in Haskell? I guess it's not so easy to use iteration with only constants, but one could still iterate over lists, i suppose...
09:08:49 <EvilTerran> EmielRegis, the record syntax is defined in full in http://haskell.org/onlinereport/exps.html#field-ops and http://haskell.org/onlinereport/decls.html#field-labels
09:08:51 <lambdabot> Title: The Haskell 98 Report: Expressions
09:09:09 <ksf> whoppix, mu.
09:09:12 <ksf> @where mu
09:09:13 <lambdabot> http://www.catb.org/jargon/html/M/mu.html
09:09:18 <EmielRegis> ok i got it working EvilTerran, danke
09:09:21 <EvilTerran> :)
09:10:06 <whoppix> ksf, please tell me which of my assumptions are incorrect.
09:10:16 <ksf> http://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration
09:10:18 <lambdabot> Title: Recursion (computer science) - Wikipedia, the free encyclopedia, http://tinyurl.com/2toc7v
09:10:23 <EvilTerran> whoppix, iteration is equivalent to a special case of recursion (namely tail recursion), so we don't need it
09:10:52 <EvilTerran> so there is no built-in iteration in haskell, although some constructs do give a good impression of iteration
09:11:17 <Saizan> whoppix: instead of control-flow constructs like for-loops we simply use higher order functions, which are defined using recursion
09:11:19 <anders^^> skorpan: jobbar inte med det nu
09:11:38 <skorpan> nänä
09:12:14 <whoppix> Ok, I see. I think i will read some more about recursion & tail recursion, until now I haven't really used recursion a lot, in the procedural programming languages I used.
09:12:16 <EvilTerran> > [(x-y) / x | x <- [1..], y <- [1..x]] :: [Rational] -- looks like two nested loops, de-sugars to recursion
09:12:17 <lambdabot>   [0%1,1%2,0%1,2%3,1%3,0%1,3%4,1%2,1%4,0%1,4%5,3%5,2%5,1%5,0%1,5%6,2%3,1%2,1%...
09:12:30 <whoppix> Thanks a bunch for giving me the Links.
09:12:43 * EvilTerran notes he didn't quite write the one he was intending to, but you still get the idea
09:12:55 <gio123> does somebody has the paper:L. Kari, On language equations with invertible operations, Theoret.
09:12:56 <gio123> Comput. Sci. 132 (1994), 129-150.
09:13:03 <sw17ch> are ForeignPtrS allocated on the Haskell heap?
09:14:05 <matthew-_> is hsc2hs still a good thing to use when interfacing with C?
09:14:43 <matthew-_> I would guess it would depend on how complex the C interface is, right?
09:15:09 <sw17ch> matthew-_, yeah, if it's a small interface, then writing it by hand is usually sufficient...
09:15:17 <sw17ch> if it's huge, then you'll want something like hsc2hs to help you
09:15:38 <ksf> whoppix, http://library.readscheme.org/servlets/cite.ss?pattern=Ste-77
09:15:46 <ksf> @where tail-recursion
09:15:47 <lambdabot> I know nothing about tail-recursion.
09:15:56 <ksf> @where+ tail-recursion http://library.readscheme.org/servlets/cite.ss?pattern=Ste-77
09:15:57 <lambdabot> Done.
09:16:16 <EvilTerran> gio123, i can try to grab it via my uni VPN
09:16:26 <mmorrow> sw17ch: i believe they're alloced in the haskell heap but aren't moved by the gc
09:16:57 <mmorrow> and they get finalized when no more haskell refs to them exist
09:16:59 <sw17ch> mmorrow, are there any things that allocate memory outside of the haskell heap?
09:17:08 <mmorrow> mallocBytes does i believe
09:17:11 <whoppix> ksf, thanks. I've always had some problems putting my mind in the recursive kind of thinking scheme, whenever i make up algorithms they are iterative. I guess i will need to do some training, to embrace the model of recursive thinking,.
09:17:15 <mmorrow> Ptr a
09:17:30 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-ForeignPtr.html#v%3AmallocForeignPtr
09:17:32 <lambdabot> Title: Foreign.ForeignPtr, http://tinyurl.com/y67cak
09:17:33 <mmorrow> Foreign.Marshal.Alloc
09:17:46 <mmorrow> .{malloc{Bytes},free}
09:17:57 <gio123> EvilTerran: thank you very much!
09:18:34 <mmorrow> sw17ch: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=425
09:19:08 <mmorrow> almost as fast as cat
09:19:12 <ksf> whoppix, all praise goes to steele for ignoring other computer scientists.
09:19:39 <ksf> He could have invented the famous linus-quote "Everyone who disagrees with me is an idiot"
09:20:08 <mmorrow> (in that paste, i'm not sure if the -threaded +N2 is really helping there or not since i'm not forking)
09:21:12 <dcoutts> Lemmih: I'd make it a PUT
09:24:20 <Lemmih> dcoutts: You don't happen to know how to put with wget, do you?
09:24:40 <sw17ch> mmorrow, thanks
09:24:46 <mmorrow> dcoutts: hey. i was wondering how to go about finding out the dataDir from *_paths inside Setup.hs. well, what i really want to do is to reproduce exactly a (non-flat) dir tree in the dataDir.
09:24:50 <mmorrow> sw17ch: np
09:24:53 <sw17ch> I'm just trying to keep all my allocations in the Haskell heap so the GC can be smarter
09:24:55 <dcoutts> Lemmih: I think it's possible with curl
09:26:26 <ksf> whoppix, if you're feeling really, really adventurous today you might want to read up on continuations, too.
09:26:36 <dcoutts> Lemmih: curl --upload-file file url
09:27:12 <whoppix> ksf, I once started reading on those, but i kinda lost the tread. But I'll make a note for later reading; today I'm a bit busy, unfortunately.
09:27:29 <sw17ch> is there a way to make an "invisible" storable instance?
09:27:38 <sw17ch> such that peek/poke *can't* be implemented?
09:27:46 <sw17ch> so you only get size/alignment
09:27:54 <dcoutts> mmorrow: I'm not sure what you mean by non-flat exactly, but given the local build info you can use absoluteInstallDirs
09:28:08 <ksf> whoppix, don't worry, if continuations don't confuse you you don't understand them.
09:29:17 <whoppix> ksf, haha, ok
09:29:51 <Philonous> What is the vector space class called again?
09:30:38 <Philonous> nvm
09:31:23 <quicksilver> sw17ch: peek = error "NONONO. NO CAN HAZ PEEK"
09:31:29 <mmorrow> dcoutts: hmm. i see. by "non-flat" i mean "create subdirectories therein". i phrase it that way since from looking at happy's happy.cabal it seems to pass a [FilePath] to cabal in one of the copy hooks in order to get its data files copied over into the dataDir. i tried to go the same route, but got stuck on how exactly i could create directories using this same method. (this is probably not the way i should be approaching this, but t
09:31:30 <mmorrow> his is where i'm coming from).
09:31:52 <ddarius> If you are familiar with assembly, continuations are completely straightforward.
09:32:01 <sw17ch> quicksilver, you realize that's exactly how i'm going to implement it, right?
09:32:15 <ddarius> Alternatively, think in terms of CPS and it's reasonably straightforward.
09:33:21 <rog> what's a nice way of implemening this: Monad m => [(a, m a)] -> m [(a, a)]
09:33:41 <mmorrow> dcoutts: this also isn't perfectly fresh in my mind, so i can't recall exact particulars. i need to take another look at it and get back to you. thx :)
09:33:54 <dcoutts> mmorrow: if a datafile is  "foo/bar.dat" then it'll be copied from $buildtop/foo/bar.dat to $datadir/foo/bar.dat
09:34:15 <dcoutts> mmorrow: and target dirs will be created as necessary
09:34:18 <quicksilver> sw17ch: I should hope so to! :)
09:34:33 <mmorrow> dcoutts: sweet. this is perfect. for some reason i just assumed that that wouldn't happen.
09:34:41 <mmorrow> (dunno why :)
09:35:15 <dcoutts> mmorrow: it pretty much has to work that way since you can specify datafiles with subdirs in the .cabal file itself
09:36:28 <mmorrow> ah, true. i think it just so happened that happy doesn't have any subdirs. i guess that was what made me think there was this limitation.
09:41:28 <Lemmih> dcoutts: It works (:
09:41:34 <dcoutts> Lemmih: yay!
09:42:00 <dcoutts> Lemmih: tell me more, was it completely straightforward ?
09:42:15 <dcoutts> and particularly interesting or nice bits?
09:42:18 <dcoutts> and/any
09:43:11 <Lemmih> dcoutts: Fairly straightforward.
09:43:18 <dcoutts> great
09:43:50 <Lemmih> Serving the contents of a tarball was very simple with Tar.read/GZip.decompress/HTTP.mimeTypes.
09:44:09 <Lemmih> I added the documentation state as a separate component.
09:44:15 <dcoutts> ah yes, mime types
09:44:42 <dcoutts> Lemmih: ok, that might make it a bit more modular, I should investigate using that style
09:44:55 <dcoutts> Lemmih: I've been trying to make the whole thing a bit more modular
09:45:10 <dcoutts> and the state is one of the hardest bits
09:46:51 <Lemmih> I'm not yet doing any authorization or error handling. I'll push when I get that done.
09:49:10 <Lemmih> dcoutts: What format should we require?
09:49:36 <dcoutts> Lemmih: what kind of format do you mean?
09:50:24 <Lemmih> dcoutts: Where in the tarball should index.html be located.
09:51:20 <dcoutts> Lemmih: ah, probably we want a format like pkgname-version/index.html
09:52:36 <dcoutts> Lemmih: so that if you downloaded the whole tarball it'd be in a reasonable form
09:52:46 <Lemmih> Right.
10:00:14 * byorgey bakes a pumpkinlambda pie
10:01:34 <askentasken> where is state?
10:01:44 <Saizan> ?hoogle ptrequality
10:01:44 <lambdabot> No results found
10:01:51 <byorgey> askentasken: state is all around you.
10:01:55 <Saizan> ?hoogle PtrEquality
10:01:56 <lambdabot> No results found
10:02:06 <byorgey> askentasken: could you be more specific? =)
10:02:49 <askentasken> the monad state
10:02:58 <EvilTerran> Control.Monad.State
10:03:28 <askentasken> if i import control.Monad do i get .State to then?
10:03:48 <byorgey> nope, you have to import Control.Monad.State too.
10:06:00 <Saizan> was unsafePtrEquality the right name? and where is it exported from?
10:06:45 <EvilTerran> ?hoogle Equality
10:06:45 <lambdabot> No results found
10:10:40 <hackage> Uploaded to hackage: hsndfile 0.3.2
10:11:51 <Saizan> ?hackage numbers
10:11:51 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
10:15:01 <mmorrow> @type reallyUnsafePtrEquality
10:15:02 <lambdabot> Not in scope: `reallyUnsafePtrEquality'
10:16:54 <mmorrow> @type reallyUnsafePtrEquality#
10:16:55 <lambdabot> Not in scope: `reallyUnsafePtrEquality#'
10:17:10 <b_jonas> is there a reason why Maybe does not have an Ix instance? how about Either?
10:17:14 <mmorrow> GHC.Prim.reallyUnsafePtrEquality#
10:17:22 <ddarius> Eq
10:17:54 <mmorrow> @kind Maybe
10:17:56 <lambdabot> * -> *
10:18:23 <mmorrow> @kind Either
10:18:24 <lambdabot> * -> * -> *
10:18:39 <b_jonas> yeah, but I'm thinking of instance (Ix a) => Ix (Maybe a)
10:18:56 <b_jonas> just like its Ord instance
10:19:27 <mmorrow> i guess because it'd be easy enough to write, but if that was standard would impose that instance on all Maybe a 's
10:19:29 <EvilTerran> b_jonas, i'm not sure how the Either instance would work
10:19:52 <b_jonas> EvilTerran: hmm, yeah
10:19:58 <b_jonas> you can't specify a range for both cases
10:20:10 <b_jonas> and that applies to Maybe too
10:20:23 <mmorrow> @src Ix
10:20:24 <lambdabot> class (Ord a) => Ix a where
10:20:24 <lambdabot>     range           :: (a,a) -> [a]
10:20:24 <lambdabot>     index           :: (a,a) -> a -> Int
10:20:24 <lambdabot>     inRange         :: (a,a) -> a -> Bool
10:20:24 <lambdabot>     rangeSize       :: (a,a) -> Int
10:20:27 <askentasken> Im throwing out my old design and tyring again. Im implementing Prolog in Haskell and I have trouble even getting going.
10:20:29 <askentasken> http://hpaste.org/11920
10:20:40 <b_jonas> when you take the bound (Nothing, x) you don't have a lower bound for the Just case
10:20:56 <b_jonas> askentasken: vixey was talking about that just yesterday I think
10:20:58 <mmorrow> it'd make the most sense to map that to 0
10:21:06 <mmorrow> (anything with Nothing)
10:21:09 <askentasken> cant i have a Clause with 2 diff constructor using diff arguments
10:21:17 <b_jonas> mmorrow: which 0?
10:21:22 <mmorrow> 0::Int
10:22:04 <mmorrow> index would be problematic though i guess
10:22:23 <b_jonas> yeah, it was a stupid question I guess
10:22:23 <mmorrow> i don't see any "canonical" way to define that
10:22:40 <mmorrow> interesting i thought :)
10:24:42 <mmorrow> hmm, actually
10:24:55 <mmorrow> , index (1,2) (0::Int)
10:25:02 <lunabot>  luna: Couldn't match expected type `Control.Comonad.Pointer.Pointer i a'
10:25:06 <EvilTerran> !
10:25:09 <mmorrow> heh
10:25:11 <mmorrow> > index (1,2) (0::Int)
10:25:13 <lambdabot>   * Exception: Ix{Int}.index: Index (0) out of range ((1,2))
10:25:35 <Saizan> askentasken: those paramters simply aren't in scope
10:25:39 <mmorrow> oh, if the standard practive is to just throw an Exception (yuk), then Maybe seems doable
10:26:01 <mmorrow> *practice
10:26:32 <mmorrow> , src ''Pointer
10:26:43 <lunabot>  data Pointer i a = Pointer {index :: i, array :: (Array i a)}
10:26:58 <mmorrow> , src ''Comonad
10:27:03 <ksf> coisomorphic bioptmisation is coefficent.
10:27:03 <lunabot>  class (Copointed w) => Comonad w where
10:27:03 <lunabot>          duplicate :: forall a . w a -> w (w a)
10:27:03 <lunabot>          extend :: forall b a . (w a -> b) -> w a -> w b
10:27:05 <ksf> scnr
10:28:00 <mmorrow> , src ''Copointed
10:28:06 <lunabot>  class (Functor f) => Copointed f where
10:28:06 <lunabot>          extract :: forall a . f a -> a
10:29:07 <mmorrow> i like Mutual
10:29:13 <mmorrow> , src ''Mutual
10:29:17 <lunabot>  newtype Mutual p m n a = Mutual {runMutual :: (m (p a
10:29:17 <lunabot>                                                      (Mutual p n m a)))}
10:29:40 <askentasken> is it true that a dynamic langauge would make it easier to define Prolog
10:29:51 <mmorrow> let mutual f g a = f a (\b -> mutual g f b)
10:29:56 <ksf> @faq
10:29:57 <lambdabot> The answer is: Yes! Haskell can do that.
10:30:05 <ksf> :t Dyn
10:30:07 <lambdabot> Not in scope: data constructor `Dyn'
10:30:13 <ksf> grrr.
10:30:20 <ksf> I constantly forget package names.
10:30:24 <mmorrow> , eval "eval \"eval 42\""
10:30:28 <lunabot>  <<Dynamic>>
10:30:52 <mmorrow> , (fromDynamic . fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"eval 42\"") :: Integer
10:30:54 <lunabot>  luna: Couldn't match expected type `GHC.Integer.Internals.Integer'
10:31:10 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"eval 42\"") :: Integer
10:31:14 <lunabot>  luna: No instance for (GHC.Num.Num GHC.Base.String)
10:31:18 <mmorrow> gr
10:31:41 <mmorrow> , (fromJust . fromDynamic) (eval "eval \"eval 42\"")
10:31:45 <lunabot>  luna: Maybe.fromJust: Nothing
10:31:51 <mmorrow> , (fromJust . fromDynamic) (eval "eval \"eval 42\"") :: Dynamic
10:31:55 <lunabot>  luna: No instance for (GHC.Num.Num GHC.Base.String)
10:32:01 <mmorrow> wtf
10:32:03 <b_jonas> mmorrow: don't you need a level of fromDynamic inside the quotes too?
10:32:03 <mmorrow> ohhh
10:32:17 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"eval \\\"42\\\"\"") :: Integer
10:32:19 <mmorrow> heh
10:32:22 <lunabot>  42
10:32:36 <mmorrow> forgot to make the 42 a String
10:32:55 <pumpkin_> I asked this yesterday, but maybe someone can answer today: does anyone happen to know whether there's a name for the formal class of languages recognizable by extended (with backreferences) regexps?
10:33:25 <ksf> http://en.wikipedia.org/wiki/Automata_theory
10:33:27 <lambdabot> Title: Automata theory - Wikipedia, the free encyclopedia
10:33:30 <ksf> see bottom of that page
10:33:49 <pumpkin_> what about it?
10:34:20 <ksf> choose the one you like.
10:34:36 <pumpkin_> o.O
10:35:49 <IsoPallo_> o.O
10:36:41 <IsoPallo_> I think that would not be regular language anymore, but would it still be context-free?
10:37:15 <IsoPallo_> In Chromsky (or how is it spelled?) hierarchy that is.
10:37:17 <pumpkin_> ksf: maybe I wasn't clear... I know that "pure" regular expressions recognize the regular languages, but backreferences allow an "Extended regular expression" to catch matching parentheses (a typical context-free language example) and even squares, which aren't context-free
10:37:40 <pumpkin_> so I was wondering if the class of languages recognizable by these extended regular expressions is named, and is anything less than context-sensitive
10:38:24 <Saizan> using backreferences looks context-sensitive to me
10:38:37 <pumpkin_> but I know they can't recognize all context-sensitive languages
10:38:48 <pumpkin_> so I'd imagine they fall somewhere in between
10:39:01 <pumpkin_> and I was wondering if some formal study had been done into exactly where they fall, and so on
10:39:35 <IsoPallo_> http://en.wikipedia.org/wiki/Mildly_context-sensitive_language
10:39:37 <lambdabot> Title: Mildly context-sensitive language - Wikipedia, the free encyclopedia
10:39:38 <IsoPallo_> Maybe.
10:40:19 <IsoPallo_> If it's written in wikipedia it must be scientific.
10:40:29 <ksf> It might be that extended regexes just don't allow all features they could for the class they're in.
10:40:30 <pumpkin_> I was looking at the two classes between context-free and context-sensitive in that wikipedia box
10:40:39 <MarcWeber> nominolo|msr: ping
10:40:57 <ksf> as in the difference of syntax and required automaton
10:41:16 <pumpkin_> hmm, maybe
10:41:55 <pumpkin_> ah well, I'll keep looking around
10:45:42 <MarcWeber> waern: Any questions?
10:46:10 <waern> MarcWeber: sorry, haven't tried it yet
10:48:54 <nominolo|msr> MarcWeber: pong
10:49:42 <nominolo|msr> MarcWeber: so what's it you're trying to add to shim?
10:50:58 <MarcWeber> Support to compile cabal files in the distDirTemp places assigned by cabal. Selecting for which target you are writing currently (CPP options could differ)
10:51:31 <MarcWeber> If this all works a lot of different type based queries such as find all functions which can return a Tree etc. But that's no priority.
10:51:46 <MarcWeber> I already have added camelCase completion
10:52:13 <nominolo|msr> MarcWeber: so i'm working on this one http://code.google.com/p/scion-lib/
10:52:15 <lambdabot> Title: scion-lib - Google Code
10:52:41 <nominolo|msr> the idea is very similar to shim
10:52:47 <MarcWeber> nominolo|msr: And of course thereby supporting different distDirs at the same time
10:53:03 <MarcWeber> Let me have a look at it now..
10:53:46 <nominolo|msr> MarcWeber: i'm planning to integrate more from Shim and Visual Haskell and ghci and vim-mode
10:54:19 <nominolo|msr> the goal is to have all those features available for a haskell front-end, but also to have a way to communicate with other frontends
10:54:38 <nominolo|msr> for testing, i use an emacs front-end, but i try not to tie it very closely
10:55:05 <MarcWeber> nominolo|msr: I already have written a vi data type parser / serializer. Maybe that's of interest for you then
10:55:32 <nominolo|msr> well, i'm not writing the vim frontend myself
10:55:51 <MarcWeber> Maybe you want to add a comment somwhere. :-)
10:55:56 <nominolo|msr> (i have no knowledge of vim scripting and i use vim rarely)
10:55:58 <MarcWeber> What does the CallGraph0.hs do?
10:56:24 <MarcWeber> nominolo|msr: it's easy: Either String, Dict, Int, list or (recently as well: ) float.
10:56:26 <nominolo|msr> it's probably broken, atm, it was a start to have per-function dependency analysis
10:56:35 <dons> ?users
10:56:35 <lambdabot> Maximum users seen in #haskell: 559, currently: 530 (94.8%), active: 18 (3.4%)
10:56:50 <MarcWeber> nominolo|msr: So eg let's see which functions are used by function x?
10:57:11 <MarcWeber> nominolo|msr: Is there some documentation?
10:57:13 <nominolo|msr> yes, and the other way round, but that requires a lot more work
10:57:26 <nominolo|msr> Not much, I'm currently working on it
10:57:39 <MarcWeber> So what does GetImports.hs do?
10:57:44 <jsn> i have a program that is getting stuck when it tries to pass more than about 136K to another process on standard in
10:57:49 <nominolo|msr> module dependency graph
10:57:54 <MarcWeber> nominolo|msr: And why do you have a different main for all?
10:58:03 <jsn> i'm using lazy bytestrings
10:58:08 <nominolo|msr> MarcWeber: those are *examples*
10:58:12 <jsn> any idea what the problem could be?
10:58:19 <nominolo|msr> the real library is in src/
10:58:36 <MarcWeber> jsn: Can you copy paste the piece of code? Maybe the buffer is full. Try reading from stdin in a separate thread?
11:00:04 <MarcWeber> nominolo|msr: Does the ThingAtPoint.hs still work with ghc-6.10?
11:00:21 <nominolo|msr> as i said, the examples are probably broken
11:00:34 <MarcWeber> nominolo|msr: The code I have (from shim) definitely is
11:00:35 <nominolo|msr> the library is developed with 6.11
11:00:40 <jsn> MarcWeber: well, hmm
11:00:56 <nominolo|msr> MarcWeber: waern updated the Shim/VS code inside yi
11:00:59 <jsn> MarcWeber: so the other process is not emptying the buffer quickly enough?
11:01:20 <nominolo|msr> i'll integrate it into Scion in a bit
11:01:30 <MarcWeber> nominolo|msr: I've talked to him and as I understood him it doesn't compile yet
11:01:42 <noecksit> could someone help me setup gtk2hs on windows, i am not getting the path environmental variable right for some reason
11:01:46 <nominolo|msr> well, then i'll get it to compile first
11:02:06 <nominolo|msr> i'm currently working on error message highlighting
11:02:17 <waern> MarcWeber: it compiles and works. The haddock feature is still a bit buggy though
11:02:18 <nominolo|msr> next step is background compilation for the current module
11:02:28 <noecksit> ghc is recognized through the command prompt, but when the installer starts up, it can't find it
11:02:35 <MarcWeber> nominolo|msr: Sure.
11:02:44 <dcoutts> noecksit: do you start the installer from the command prompt?
11:03:19 <MarcWeber> jsn: Have a look at my answer and the reply of David Roundy here: http://www.haskell.org/pipermail/haskell-cafe/2008-November/050090.html
11:03:22 <lambdabot> Title: [Haskell-cafe] Can't figure out source of race condition when using System.Proce ..., http://tinyurl.com/5e99kq
11:03:35 <dcoutts> noecksit: perhaps you've got a special command environment for ghc that sets up the environment vars specially and they're not set globally
11:05:07 <MarcWeber> nominolo|msr: You have error handling! Great
11:05:18 <jsn> MarcWeber: http://hpaste.org/11922
11:05:24 <jsn> MarcWeber: okay, thank you
11:05:32 <nominolo|msr> MarcWeber: anyway, just wanted to let you that this is a serious effort, so please consider contributing
11:05:48 <nominolo|msr> MarcWeber: Moving over Shim features is also welcome
11:06:04 <MarcWeber> nominolo|msr: Let me finish skimming the project
11:06:07 <nominolo|msr> sorry, got to go now
11:07:13 <noecksit> dcoutts: oh ok, i just have the bin folder in the path, maybe i need to have some other folder in the path
11:07:15 <MarcWeber> nominolo|msr: Thanks for the link!
11:07:16 <MarcWeber> cu
11:07:56 <dcoutts> noecksit: so did you launch the installer from that command shell and it failed to find ghc?
11:08:13 <dcoutts> noecksit: if you can type ghc in that shell then running the installer from that shell should also work
11:08:36 <MarcWeber> jsn Can you try using this:      c <- hGetContents o; waitForProcess p; return c
11:08:42 <noecksit> dcoutts: no, i clicked on it through the windows explorer, let me try going with the cli
11:08:54 <jsn> MarcWeber: sure, i'll try that
11:09:09 <dcoutts> noecksit: my suspicion was that your cli and explorer were using different %PATH%s
11:09:18 <Cale> http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx :)
11:09:21 <lambdabot> Title: cgibbard comments on Monoids? In my programming language?, http://tinyurl.com/5e63ad
11:11:03 <vixey> Cale, hm.. http://lambda-the-ultimate.org/node/3093
11:11:07 <lambdabot> Title: Extensible tuples? | Lambda the Ultimate
11:12:01 <jsn> Cale: it is too bad that math encounters so much resistance from programmers
11:12:24 <vixey> jsn, we should start a movement, like the pythagoreans!
11:12:42 <jsn> vixey: +1 for punning
11:12:48 <noecksit> dcoutts: yeah that worked, silly me, maybe i need to restart the computer or something, thanks
11:12:52 <dons> jsn: what, "thinking"? :)
11:13:01 <jsn> heh
11:13:22 <dcoutts> noecksit: or it might be a bug in the ghc installer, to not tell explorer to update its path
11:13:29 <vixey> hm.. I can't figure out my own pun :(
11:13:48 <jsn> vixey: oh, i thought it had something to do with Python, as well
11:14:33 <Cale> vixey: interesting
11:14:42 <Cale> jsn: Yeah, it really is too bad.
11:14:47 <vixey> http://en.wikipedia.org/wiki/Monad_(symbol)
11:15:39 <Cale> Computer science is a branch of mathematics, and I think the sooner we all recognise that, the better off we'll be. :)
11:15:51 <dons> yay, my new 350G ghc build disk arrived :)
11:16:04 <dons> building all of hackage n ways won't destroy my laptop any more
11:16:49 <unenough> dons, the law states it will now become n^2 ways, which WILL destroy your laptopt
11:16:57 <dons> this is true.
11:17:04 <unenough> (the law that every effort grows to fill the resources that were allocated to it)
11:17:09 <dons> ghc expands to fill available ram and disk
11:18:42 <dons> woot woot, http://www.reddit.com/r/programming/comments/7cijd/fieldtrip_purely_functional_realtime_3d_graphics/
11:18:44 <lambdabot> Title: FieldTrip: Purely functional real-time 3D graphics using reactive programming :  ..., http://tinyurl.com/5qveng
11:20:08 <unenough> dons, no example code?
11:21:10 <deeflex> hey I have a .txt and wonder if it's possible to direct the output from that file to my haskell program? like 'Main>func < test.txt'
11:21:37 <mauke> :-|
11:21:46 <dons> sure
11:21:50 <Cale> deeflex: uh, you'd have to do that from the shell, or use readFile
11:22:05 <deeflex> oh not from hugs?
11:22:31 <dons> deeflex: print . func =<< readFile "foo.txt"
11:22:38 <Cale> deeflex: Well, hijacking your own process's stdin is technically possible, but doing it is hackish, and platform dependent.
11:23:12 <Cale> deeflex: But perhaps that's not what you actually mean.
11:23:20 <noZone> Is GHC itself able to perform its various duties in parallel (i.e. employing multiple cores or processors), or is it single threaded?
11:23:25 <Cale> If you just want to read the file and get a String which you can work with, that's easy :)
11:23:39 <Cale> noZone: SMP support in GHC is excellent
11:23:59 <Cale> noZone: We have a number of parallelism and concurrency abstractions available.
11:24:07 <mauke> Cale: does ghc use them?
11:24:14 <Cale> and a threaded runtime, with a parallel garbage collector
11:24:18 <deeflex> Cale: now my  program translates a string
11:24:18 <noZone> So the compiler compiles in parallel where possible?
11:24:29 <Cale> Oh, *compiling* in parallel.
11:24:50 <Cale> I'm not sure. The garbage collection would be, at least.
11:24:52 <deeflex> and my .txt is like 100 lines of words to be translated and I want to direct the output from that file to my program.
11:25:13 <dons> deeflex: your program should read from sttdin.
11:25:28 <dons> getContents >>= print. foo
11:25:32 <Cale> deeflex: Okay,   do x <- readFile "myFile"; print (myFunction x)
11:26:12 <Cale> deeflex: Or if you want to read from stdin, use getContents in place of readFile "myFile"
11:26:22 <RLa> what are considered to be free variables in an expression?
11:26:38 <deeflex> nah not working
11:26:38 <Cale> RLa: ones which are not bound by surrounding lambdas or let expression
11:26:39 <Cale> s
11:26:57 <Cale> (or case expressions via pattern matching)
11:27:03 <dons> conal: so next, we need the source code example for producing that torus... :)
11:27:04 <RLa> hm
11:27:05 <vixey> RLa, FV(x) = {x}; FV(m n) = FV(m) union FV(n); FV(\x -> b) = FV(b) \ {x}
11:27:15 <RLa> uh, vixey
11:27:16 <mauke> RLa: undefined variables
11:27:19 <deeflex> Cale: gtg now.. thx for the help anyway
11:27:21 <Cale> RLa: For instance, (\x -> (\y -> x y z))
11:27:23 <deeflex> beback later
11:27:25 <Cale> RLa: z is free.
11:27:30 <RLa> i see
11:27:41 <Cale> RLa: and in (\x -> (\y -> x y z)) x
11:27:50 <Cale> The first x is bound, and the second one is free.
11:28:15 <Cale> (the one at the end of the expression is free, that is)
11:28:25 <vixey> RLa,  using Cales example,  FV(\x -> (\y -> x y z)) = (({x} union {y} union {z}) \ {y}) \ {z} = {x,y,z} \ {y,z} = {z}
11:28:49 <noZone> My thought was: compiler builders are faced with decisions concerning what optimizations to support, and some of those may be decided by time constraints (i.e. if the compiler is too slow maybe nobody is happy with it), but if it could take advantage of multiple cores/processors....
11:29:27 <Cale> noZone: Well, usually optimisations have to be somewhat serialised, since the output of one is the input of the next.
11:29:45 <Cale> noZone: But there is a lot of parallelism available there
11:29:58 <Cale> In terms of compiling separate declaration groups in parallel.
11:30:07 <Cale> (or even just separate modules)
11:30:19 <noZone> yes
11:31:00 <RLa> f = g <- is g free variable?
11:31:07 <Cale> RLa: yes.
11:31:30 <Cale> RLa: But that's not an expression, it's a declaration...
11:32:13 <Cale> RLa: of course, in any Haskell program, eventually every variable needs to be bound somewhere.
11:32:26 <RLa> let f = g, g = 2 in f <- here it is not free?
11:32:37 <RLa> ok, thanks
11:33:03 <Cale> So it depends on exactly which subexpression you're looking at which variables are free and which are bound
11:33:11 <Saizan> as a whole that's a closed term
11:33:29 <Saizan> which means that it has no free variables
11:33:31 <Cale> Anything which is free in an expression needs to be bound by some external definition or lambda binding.
11:34:27 <askentasken> cant i define a lambda in a data?
11:34:36 <askentasken> i mena data Law = Law head body
11:34:54 <askentasken> then let l = Law "sibling" (some-lambda)
11:35:17 <dons> hey lads, i'm giving a talk on using haskell to program multicores in texas next week, http://sites.google.com/site/sc08mcoregap/Home
11:35:31 <dons> haskell for bridging the multicore programming gap
11:35:47 <ttt--_> dons, the example in fieldtrip needs Graphics.FieldTrip.Glut. Is that available somewhere?
11:36:23 <ttt--_> or maybe i'm doing something wrong
11:36:27 <dons> ttt--_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reactive-glut-0.0.4 ?
11:36:33 <lambdabot> Title: HackageDB: reactive-glut-0.0.4, http://tinyurl.com/5m6cnf
11:36:40 <dons> mm. no.
11:36:53 <dons> check with conal
11:39:09 <ttt--_> it's not that important, i just wanted to see the pretty torus :)
11:39:22 <jsn> does cabal enable language extensions, or merely allow them?
11:39:28 <Cale> askentasken: Absolutely, if the data needs a function there.
11:39:41 <jsn> is all my code compiled with template haskell if i put it in the cabal file?
11:39:44 <dcoutts> jsn: at the moment it enables them but it should just allow them really
11:40:05 <Cale> I'm not sure what the difference betweeen enabling and allowing is here...
11:40:07 <dons> jsn: 1?
11:40:17 <luite> what kind of data structure should I use for a dynamic programming algorithm in a graph, where I calculate a set of values for each node, which depend on values in other nodes, etc. Each value should only be calculated once. I started with an algorithm with some STUArray which stores the already calculated values, so that they will not be recalculated. but it surely must be possible to do this in pure code, right?
11:40:23 <dons> Cale: whether you disallow them if they're in pragmas
11:40:37 <jsn> dons: you mean yes?
11:40:51 <Cale> dons: ah
11:41:09 <Saya> Hey all, i need the shortest distance from one vertex to all other vertices on a graph, so it looks like a job for djikstra but i have no idea of how to implement that correctly (ie a tiny bit efficiently) in haskell, how would you do it?  a well 2 graph questions at a time...
11:41:24 <luite> Saya: and even dynamic programming :P
11:41:28 <dons> jsn: you mean, is TH enabled for all modules?
11:41:36 <jsn> dons: yes
11:41:53 <Cale> luite: I would (without further information about the problem) probably represent the graphs using Map V (Set V), where V is the vertex type, together with a Map V L, where L is the appropriate label type.
11:41:56 <Saya> luite: yep indeed :)
11:42:19 <Cale> Saya: Same goes for you :)
11:42:37 <Cale> Data.Map and Data.Set are glorious for efficient pure code.
11:43:03 <askentasken> Cale how do i make it show-able then?
11:43:10 <jsn> MarcWeber: okay, waitForProcess seems ti make it get stuck more easily
11:43:15 <askentasken> i can define it, that worked, but hwne i ro l
11:43:24 <Saya> thx alot, i saw there was an IntMap since i have ids for vertices i guess i could use that
11:43:27 <askentasken> write the var-name i get: No instance for (Show (Integer -> Integer))
11:43:27 <askentasken>       arising from a use of `print' at <interactive>:1:0
11:43:28 <Cale> askentasken: Well, you have to define your own show instance. Functions aren't showable.
11:43:47 <askentasken> ok any tutorial for that?
11:44:01 <MarcWeber> jsn: What exit code does your child process have?
11:44:21 <Cale> askentasken:  instance Show MyType where
11:44:30 <Saizan> luite: maybe you can use a self-recursively defined pure Array?
11:44:32 <luite> Cale: so I'd 'manually' update the labels for a node in the V L map, when I calculate some value? and when I need that value, I first check the map?
11:44:32 <Cale> askentasken:      show x = ...
11:44:48 <Cale> luite: Yeah.
11:45:12 <Cale> luite: You can use findWithDefault there.
11:45:22 <luite> Saizan: do you have an example of that?
11:45:22 <Cale> luite: hmm, actually...
11:45:28 <askentasken> Cale , but am i definaing a how for al functions or just specific functions?
11:45:36 <askentasken> i want to add functions int he repl
11:45:38 <Cale> askentasken: For all functions.
11:45:47 <askentasken> kind of dynamically
11:45:51 <luite> Saizan: I wanted to do something like that, but I have no idea how
11:46:00 <Cale> askentasken: You can't tell the difference between functions without applying them to parameters.
11:46:01 <ttfh_> are && and || lazy?
11:46:08 <Cale> ttfh_: yes.
11:46:16 <Cale> @src (&&)
11:46:17 <lambdabot> True  && x = x
11:46:17 <lambdabot> False && _ = False
11:46:18 <lament> it would be really weird if they weren't
11:46:44 <Saizan> luite: http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
11:46:45 <lambdabot> Title: Gmane -- Mail To News And Back Again
11:46:50 <ttfh_> i suppose
11:47:15 <luite> Saizan: thanks
11:47:33 <Cale> I should really get around to writing a graph library.
11:47:41 <conal> dons: put the tori source code on the wiki page?
11:47:41 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:47:46 <askentasken> Cale: i dont get it
11:47:50 <dons> conal: yeah. or at least link to it.
11:47:53 <Cale> askentasken: hm?
11:47:57 <conal> dons: good idea. thx.
11:48:01 <dons> so people can take it, compile it , and get the same picture :)
11:48:07 <luite> I use fgl for the graphs, at the moment
11:48:17 <Cale> askentasken: Well, how do you turn a function (Integer -> Integer) into a String?
11:48:39 <Cale> askentasken: You can be cheap, and just always give the same string, something like "<function>"
11:48:52 <Cale> askentasken: Or you could apply the function to a few values and show the results.
11:48:53 <Saya> luite: what would you use do draw the graph?
11:49:07 <luite> Saya: I don't need to draw the graph :)
11:49:29 <askentasken> show 10
11:49:46 <Cale> askentasken: Or if you don't mind the string being infinite, you could enumerate the Integers, and show the results for 0, 1, -1, 2, -2, ...
11:50:04 <askentasken> but i might want a bool func and sometimes it has 3 arguments,s oemtimes 10
11:50:47 <Cale> askentasken: Well, what do you want it to print?
11:50:57 <jsn> MarcWeber: it doesn't terminate
11:51:07 <askentasken> if i define (\x -> x*x) i want it to rpint Show x
11:51:15 <Cale> hm?
11:51:23 <jsn> MarcWeber: i use ^C to kill it, so it exits with 2
11:51:31 <Cale> askentasken: Which string exactly?
11:51:32 <askentasken>  if i define (\x -> x*x) i want it to print "(\x -> x*x)"
11:51:36 <Cale> Oh, that's impossible.
11:51:44 <askentasken>  if i define (\x -> x==1) i want it to print "(\x -> x==1)"
11:51:47 <askentasken> why?
11:51:58 <Cale> Because the source code is deleted by compilation.
11:52:12 <RayNbow> @karma Cale
11:52:12 <lambdabot> Cale has a karma of 7
11:52:14 <RayNbow> Cale++
11:52:16 <RayNbow> @karma Cale
11:52:16 <lambdabot> Cale has a karma of 8
11:52:19 <askentasken> so can i turn a string into a function?
11:52:29 <Cale> askentasken: Yes, but how do you want to do that?
11:52:30 <RayNbow> Cale: awesome monoid trick you posted on reddit :)
11:52:32 <mauke> yes, with 'const'
11:52:36 <Cale> RayNbow: Thanks!
11:52:39 <askentasken> like i give a string as input tand the program stores the string and transform s it into a function
11:52:45 <Cale> askentasken: which function?
11:52:49 <dons> Cale: do you need ops?
11:52:53 <Cale> askentasken: You want to run a Haskell compiler over it?
11:52:57 <Cale> dons: I have ops...
11:53:00 <Cale> oh
11:53:02 --- mode: Cale set -o Cale
11:53:11 <Cale> Heh, forgot to remove the +o yesterday.
11:54:37 <Cale> askentasken: There are libraries like hint, the GHC API, and hs-plugins for integrating your program with the Haskell compiler/interpreter.
11:54:47 <Cale> I'm not sure if hs-plugins works with the new GHC yet.
11:54:50 <askentasken> i dont know ehehe
11:55:33 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint -- have a look at this and see if it sounds like what you're looking for
11:55:34 <lambdabot> Title: HackageDB: hint-0.2.4.1
11:57:19 <Cale> But really, not the sort of thing which you'd use casually.
12:01:06 <Davbo> Hey vixey, thanks for the help yesterday; got my head around it eventually :-)
12:03:10 <askentasken> Cale: i want to do Prolog in Haskell. or at least basic prolog like facts and rules and inference on them-.
12:03:23 <askentasken> but i hardly know how to start
12:03:31 <Cale> askentasken: as an embedded language, or as an implementation of prolog?
12:03:41 <askentasken> i did some in Python, maybe i should finish that and then translate
12:03:48 <askentasken> Cale: embedded
12:04:02 <askentasken> i was thinking doing both do
12:04:17 <Cale> askentasken: Well, I think it'll actually end up looking rather similar ;)
12:04:18 <askentasken> but basically first i want embedded, a module i can call when i want to do  that type of stuff
12:06:07 <Saizan> ?google Typed Logical Variable in Haskell
12:06:11 <lambdabot> http://citeseer.ist.psu.edu/claessen00typed.html
12:06:12 <Cale> Well, Haskell doesn't (at least without fancy quasiquoting extensions and template haskell) have a way to add new binding forms to the language. So prolog-esque unification variables aren't going to look anything like first-class.
12:06:37 <askentasken> que?
12:07:16 <askentasken> let f = Fact "sibling" "Joe"
12:07:38 <askentasken> wait
12:08:00 <askentasken> let f = Fact "Parent_child" "Anna" "Joe"
12:08:36 <vixey> Davbo, hey cool
12:08:47 <Cale> askentasken: I think a list somewhere there is more likely ;)
12:08:54 <vixey> Davbo, do you have code?
12:09:00 <Cale> askentasken: After all, not all your facts are going to have exactly two parameters.
12:09:07 <jsn> MarcWeber: maybe i need to read some output off every so often?
12:09:07 <Cale> (unless they are...)
12:09:18 <vixey> Saizan, I put up an implementation roughly based on that typed logic variables stuff btw
12:09:45 <Stephan202> Cale: it could be. Think RDF
12:09:45 <Cale> Hey, that is a really cool paper by the way.
12:09:53 <jsn> in short, maybe the external process is filling up its out pipe, and i need to take the pressure off intermittently
12:09:54 <Cale> Stephan202: yes.
12:09:58 <vixey> Cale, which one ?
12:10:13 <Cale> "Typed logical variables in Haskell"
12:10:17 <vixey> ah yes it is
12:10:33 <Davbo> vixey, http://hpaste.org/11926 it's not perfect by any means though
12:10:35 <Cale> So that is actually rather close to what askentasken probably wants.
12:10:36 <MarcWeber> jsn: Sorry, I've been afk
12:10:39 <vixey> Tim Sheard has a realy good one on the same topic
12:10:43 <Cale> I wonder where the Hackage package is? :)
12:10:44 <jsn> ah
12:10:45 <Davbo> vixey, just doing encode / decode stuff now
12:10:49 <vixey> Generic unification via two-level types and parameterized modules
12:11:06 <vixey> (He's the guy that made the Omega language)
12:11:31 <vixey> Davbo, ooh ... great :))
12:12:50 <Cale> I wonder if this could be integrated with LogicT.
12:13:01 <vixey> Cale, I have unification code
12:13:12 <vixey> I didn't get anything on hackage though, problems..
12:13:39 <vixey> LogicT is a great place to put it, you know Reasoned Schemer ?
12:13:45 <vixey> they prototyped it in haskell using LogicT
12:14:37 <conal> okay, now http://haskell.org/haskellwiki/FieldTrip has the code for the tori and a pointer to how to run the animation.
12:14:41 <lambdabot> Title: FieldTrip - HaskellWiki
12:15:02 <conal> i'd love to hear from anyone who tries it out.
12:15:10 <MarcWeber> jsn: Can you try hPutContents?
12:15:32 <MarcWeber> oh it doesn't exist, try closing the handle after having written to it
12:16:22 <eu-prleu-peupeu> hello Hppl
12:16:33 <Cale> conal: I'll give it a shot :)
12:17:06 <eu-prleu-peupeu> i spent my day trying to run the happs tut... still haven't quite figured it out...
12:17:33 <conal> Cale: thx
12:18:23 <Saizan> vixey : Saizan, I put up an implementation roughly based on that typed logic variables stuff btw <- where?
12:18:35 <Cale> conal: If things keep going this well, someday we will have a commercial-quality video game and it will be a single page of Haskell code ;)
12:18:43 <Saizan> was it in the sources of rascalhaskell?
12:18:44 <vixey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62
12:19:01 <conal> Cale: that's the idea!  and not just Haskell code, but *functional* Haskell code.
12:19:07 <vixey> no, but I did replace the stuff in rascal with this as a test and it worked
12:19:22 <vixey> there's a couple examples in my paste that are smaller though
12:20:00 <jsn> MarcWeber: nah, still gets stuck
12:20:54 <Saizan> vixey: one should compose that with a backtracking monad to get something prolog-like, right?
12:20:58 <skorpan> @src const
12:20:58 <lambdabot> const x _ = x
12:21:12 <skorpan> > const 5
12:21:15 <lambdabot>       Overlapping instances for Show (b -> t)
12:21:15 <lambdabot>        arising from a use of `s...
12:21:19 <jsn> i fear i need to actually alternate between writing some bytes and reading some bytes
12:21:22 <skorpan> > (const 5) "hello"
12:21:24 <lambdabot>   5
12:21:43 <vixey> Saizan, I don't think you can really get the feel of Prolog in a monad
12:21:49 <roconnor> conal: are you interested in using Data.Colour?  ... I realize that I need to provide you with a function that isn't yet exported, but that can easily be provided.
12:22:00 <skorpan> @src fix
12:22:01 <lambdabot> fix f = let x = f x in x
12:22:10 <Ikkebr> is there any easy way to access the Nth element of a list?
12:22:18 <Cale> Ikkebr: xs !! n
12:22:24 <vixey> Saizan, but like Cale suggested, you could mix it with LogicT to get a very nice logic language
12:22:26 <Cale> Ikkebr: But beware, it's an O(n) operation
12:22:53 <Cale> Ikkebr: So if you have to do a lot of it, changing your datastructure or your algorithm is advisable.
12:23:19 <askentasken> headexplosion
12:23:25 <Ikkebr> Cale thanks :p
12:23:26 <Cale> vixey: Well, they have that BTT in the paper, I'm thinking that could be replaced by LogicT.
12:23:27 <askentasken> how do i even declare a state?
12:23:55 <askentasken> i want a state that is a lsit hat is my head exploidng all over my screen ina bloody mess
12:24:13 <jsn> askentasken: goodness
12:24:38 <jsn> askentasken: look into reader, writer and state monad for ideas
12:25:11 <MarcWeber> jsn: http://hpaste.org/11922#a1
12:25:42 <conal> roconnor: possibly interested, though ignorant about its benefits, and I'm not sure how much it would take to get the interface that my current simple Color module has.  how about adding a ticket to the FieldTrip trac?
12:26:41 <Cale> conal: very cool stuff :)
12:26:50 <roconnor> conal: the advantage would be cross package colour support :)  Granted you'd be the first package.  I'll add a ticket.
12:27:05 <vixey> what does  textual closure  mean?
12:27:12 <conal> Cale: thx!
12:28:02 <conal> roconnor: it appeals to me to reuse functionality where possible, and color is clearly useful beyond FieldTrip.
12:29:19 <MarcWeber> @tell waern Probably I'll join the scion project
12:29:20 <lambdabot> Consider it noted.
12:30:53 <vixey> oooops...
12:30:54 <roconnor> conal: I could make a patch, but do I need GHC 6.10?
12:31:02 <vixey> previous line says   con-
12:31:03 <vixey> :)
12:34:16 <unenough> weird. dot produces undeterministic output?
12:35:22 <jdrake> Would it be possible to have a constructor like Heading Integer String  where Integer must be within a certain bound?
12:35:33 <Deewiant> no
12:35:42 <vixey> yes
12:35:54 <Deewiant> What you can do is hide the type constructor and instead have a function which makes certain that the input is in a bound
12:35:55 <vixey> You just write it in a comment
12:36:01 <Deewiant> ...
12:36:33 <Deewiant> But there's no way to enforce that, given Heading x y, x will be in a bound
12:36:46 <jdrake> vixey: Why that is how I keep all my C programs type safe too, Comments FTW!
12:37:15 <opqdonut> you could possibly do that with type numerals
12:37:38 <vixey> I am the only one that doesn't express every possible variant and correctness proof in haskell type system ?
12:37:53 <Deewiant> vixey: yes
12:37:54 * vixey don't believe it :p
12:38:21 <jdrake> I am just thinking it is best to not have Heading1 Heading2, etc.
12:38:27 <mauke> > ((==) `on` sort) "lego" "oleg"
12:38:28 <lambdabot>   True
12:38:34 <mauke> coincidence?
12:38:38 <Deewiant> mauke: you just BLEW MY MIND
12:39:03 <lament> oleg is made of legos?
12:39:19 <Deewiant> it's the only logical conclusion!
12:42:50 <byorgey> > ((==) `on` (nub . sort)) "mauke" "aka emu"
12:42:51 <lambdabot>   False
12:43:05 <byorgey> hehe, doh
12:45:17 <vixey> > (const . const True) "" []
12:45:18 <lambdabot>   True
12:46:45 <jdrake> Would char "="; char "=" be the equivalent to count 2 $ char "="  in parsec?
12:46:59 <mopped> Probably not the most appropriate channel - but I was wondering if anyone can recommend an interesting book - doesn't even have to be directly related to haskell, just something interesting and loosely related to computers would be good!
12:46:59 <vixey> how rude! I emailed myself some source code and gmail changed the indentation
12:47:21 <vixey> mopped: absolutely loved The Reasoned Schemer
12:47:31 <vixey> mopped: oh.. and it has got a monad in it at the very end :p
12:47:51 <vixey> (btw it's not about Scheme)
12:48:01 <vixey> :t count
12:48:01 <lambdabot> Not in scope: `count'
12:48:02 <mopped> I've read the little schemer
12:48:09 <mopped> is the seasoned the second one in the series?
12:48:20 <jdrake> Its in Text.ParserCombinators.Parsec.Combinator
12:48:23 <mopped> reasoned, even
12:48:26 <vixey> I've read Seasoned Schemer.. that's where I started learning Scheme
12:48:41 <vixey> yeah it's in the series, coauthored by Oleg and stuff
12:49:03 <mopped> I read the Little Schemer to become more accustomed to recursion before starting Haskell, I take it Reasoned is before Seasoned?
12:49:08 <vixey> Reasoned I mean, I don't think Oleg coauthored in Seasoned schemer
12:49:16 <vixey> no Reasoned is the 3rd
12:49:25 <vixey> but it's not something you read in order
12:49:33 <vixey> i.e. it doesn't follow on from the previous books
12:49:34 <jsn> MarcWeber: is there something conceptually wrong with this?
12:49:35 <jsn> http://hpaste.org/11922#a2
12:50:08 <mopped> What's the difference between the two vixey, just different content covered?
12:50:24 <vixey> mopped, the one I recommend is not about Scheme at all
12:50:46 <jsn> MarcWeber: try it with cat -- it get stuck right away
12:51:05 <byorgey> mopped: have you read "Godel, Escher, Bach"?
12:51:29 <mopped> Nope - i've heard of it before though
12:51:44 <mopped> Reasoned Schemer is about using functional language as logic?
12:51:49 <byorgey> well, that's my suggestion =)
12:52:39 <jsn> mopped: "design concepts in programming languages"
12:52:58 <jsn> i am not finished with it, but like it so far
12:54:08 <mopped> Quite a tome byorgey, have you read the pleasure of counting? A brief look at the wiki seems it might be written in the same style, and I was just wondering if its so :P
12:55:39 <byorgey> I have not read the pleasure of counting, but I did a google search and read the description, and it sounds nothing at all like Godel, Escher, Bach.
12:56:25 <mopped> ok :p
12:56:55 <byorgey> Godel, Escher, Bach is quite unlike anything else I've ever read.
12:57:11 <unenough> byorgey, i've heard that guy published another book recently
12:57:15 <blackdog> is there a standard way of doing interned strings in haskell? Have just realised that i've reimplemented that, but clumsily.
12:57:20 <jdrake> I have tried writing a simple parser that will basically give Heading 5 %s from == %s ==; but it seems to have problems when the '=' after the %s. I want to solve this without using between just yet. Any ideas? http://hpaste.org/11927
12:57:22 <byorgey> probably, he's published many books
12:57:25 <unenough> something called "strange loops" or something
12:57:34 <byorgey> "I am a strange loop"?
12:57:35 <bluestorm> hello, i've a question about a GHC type system oddity
12:57:36 <kaol> composing functions with TH is fun... [| $f . $g |]
12:57:39 <unenough> byorgey, probably
12:57:49 <byorgey> yes, I've not read that one but I'm familiar with it
12:57:51 <vixey> blackdog: other than  data Symbols = Foo | Bar | ..., I don't think so
12:57:55 <Botje> kaol: that looks like perl!
12:58:13 <vixey> hi bluestorm
12:58:24 <bluestorm> let (a, b) = ([], []) in (a==b,a,b)
12:58:26 <unenough> byorgey, i liked his surjective TV :)
12:58:30 <unenough> very insightful
12:58:37 <bluestorm> GHC types that (Eq a) => (Bool, [a], [a])
12:58:39 <Botje> jdrake: parsec doesn't backtrack
12:58:42 <byorgey> surjective TV?
12:58:50 <bluestorm> whereas ocaml and hugs type that (Bool, [a], [b])
12:58:58 <Botje> so your many1 (alphaNum <|> space) gobbles up " Test "
12:59:04 <kaol> unenough: subjunctive, not surjective
12:59:04 <bluestorm> (wich is strange, but makes sense, and is consistent with other examples)
12:59:07 <vixey> bluestorm, that is very odd, I think ocaml and hugs are wrong
12:59:11 <unenough> kaol, yip. woooooops
12:59:11 <Botje> the parser then expects a space but sees an = and rightfully errors
12:59:20 <vixey> bluestorm, Can you show me how to make that happen in ocaml please?
12:59:32 <jdrake> Botje: would the correct method be to use between?
12:59:37 <bluestorm> vixey: # let (a,b)=([],[]) in (a=b,a,b);;
12:59:38 <bluestorm> - : bool * 'a list * 'b list = (true, [], [])
12:59:42 <bluestorm> but this isn't wrong
12:59:52 <jsn> :t (==)
12:59:53 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:59:56 <vixey> bluestorm, oh .. of course, that's right.  ocaml doesn't have the Eq typeclass
12:59:56 <Botje> jdrake: maybe, i don't have any experience with between
12:59:58 <bluestorm> as GHC itself types let a = [] in let b = [] in (a==b,a,b) the same way
13:00:06 <jdrake> Botje: neither do I, but I think I can figure it out :p
13:00:06 <vixey> bluestorm, yeah I get what you mean now, I think hugs is wrong though
13:00:12 <bluestorm> (Bool, [a], [a1])
13:00:25 <jdrake> Actually the parsec docs in ghc don't look very documented.
13:00:31 <vixey> yeah but patters like that bind monomorphically
13:00:34 <vixey> e.g.
13:00:40 <bd> anybody know a good newb tutorial for dph?
13:00:41 <vixey> > let id = \x -> x in (id 3, id True)
13:00:42 <lambdabot>   (3,True)
13:00:44 <vixey> > let (id) = \x -> x in (id 3, id True)
13:00:45 <lambdabot>       No instance for (Num Bool)
13:00:45 <lambdabot>        arising from the literal `3' at <inte...
13:00:47 <vixey> see ?
13:00:50 <blackdog> vixey: hm, not quite what i want - i need to be able to bring in new strings at runtime. potentially a lot of them.
13:00:53 <vixey> this is the same thing happening in your cose
13:00:54 <unenough> byorgey, i meant the subjunctive tv. the one that shows what 'would have happened, if only X'. it's an insight about how we decide to imagine certain possible situations but not others
13:00:56 <vixey> case*
13:01:21 <Botje> jdrake: personally, i wouldn't parse the space and just strip it off s at the end
13:01:24 <bluestorm> vixey: then why would hugs type that differently ?
13:01:31 <vixey> blackdog, oh.... I do actually implement a monad that does that
13:01:43 <vixey> bluestorm, I suppose it's not strictly following the haskell standard
13:01:52 <vixey> bluestorm, not that anyone else does though.. :)
13:01:59 <unenough> like, we say "that game play would have been perfect if he didn't fall" but not "if gravity was a little weaker"
13:02:01 <bluestorm> hm
13:02:08 <blackdog> vixey: is it available?
13:02:14 <vixey> bluestorm, 'wrong' was probably too strong for me to have said
13:02:26 <bluestorm> it still don't understand why GHC types "let a = [] in let b = [] in ..." and "let (a, b) = ([], []) in .." differently
13:02:31 <RayNbow> http://hpaste.org/11928 <-- can anyone tell whether I'm bored or not? :p
13:02:38 <vixey> bluestorm, did you see my example with 'id' earler?
13:02:49 <bluestorm> yes
13:02:53 <bluestorm> but hm
13:02:53 <vixey> so imagine
13:02:56 <jdrake> Botje: I suppose that can work
13:02:57 <vixey> id :: forall a, a -> a
13:02:59 <vixey> vs
13:03:00 <vixey> id :: a -> a
13:03:11 <vixey> if you bind into a pattern like   let a = ... you get the forall
13:03:21 <vixey> if you bind into (a,b) or (a) you actually miss out
13:03:35 <vixey> _then_ the Eq constraint unifies the types
13:03:46 <bluestorm> hm
13:03:53 <vixey> so if you've forall quantified that doesn't affect the final type, if not then you end up with (True,[a],[a])
13:03:58 <bluestorm> i see
13:04:02 <unenough> RayNbow, nice idea
13:04:09 <unenough> (from a haskell newbie)
13:04:12 <unenough> (like me)
13:04:25 <RayNbow> unenough: thanks, but I can't take the credit for the idea ;)
13:04:26 <unenough> argg english is too ambiguous. exit(-1)
13:04:28 <bluestorm> it's quite strange that    let (a) = ... and let a = ... are not equivalent
13:04:33 <vixey> blackdog, http://rascal-haskell.googlecode.com/svn/trunk/Gensym.hs
13:04:40 <vixey> blackdog, I think it's not terribly efficient though
13:04:46 <bluestorm> but i guess there are lazyness differences anyway
13:04:58 <vixey> blackdog, but replacing the list with a map or something would probably improve it loads
13:05:05 <conal> roconnor: (late reply) you probably do need ghc 6.10, since FieldTrip uses vector-space, which relies on fancy type-family support (better even than 6.9's support).
13:05:09 <vixey> bluestorm, no lazyness doesn't come into this at al
13:05:55 <unenough> @src foldr
13:05:56 <lambdabot> foldr f z []     = z
13:05:56 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:06:20 <unenough> that seems like a very specific implementation, no?
13:06:40 <vixey> unenough, it pretty much determines exactly the meaning of foldr
13:06:58 <unenough> vixey, the list catamorphism?
13:07:24 <vixey> sadly you can't write (| f , z |) instead of foldr f z
13:07:47 <unenough> i don't know what that notation would mean
13:07:53 <mrd> not sure if that makes me sad
13:08:02 <jdrake> I now have something that uses 'between open close p' where the return of p is returned by between - so you can do s <- between ...; but now I need a certain number out open and close. Is there a way of doing that?
13:08:26 <mrd> unenough: it's just ASCII art for the syntax presented in a certain paper
13:08:27 <jdrake> Nevermind, it appears I can just rewrite between
13:08:35 <vixey> jdrake like  foo 3 p = between open close . between open close . between open close $ p  ?
13:09:00 <unenough> mrd so the elegy is about not having a nicer syntax? or more than that?
13:09:04 <vixey> mrd, not just one paper uses this notation
13:09:07 <mrd> just syntax
13:09:24 <unenough> ah, i'll free the brain cells then
13:09:36 <vixey> sadly there is so few I know just the one you're referring to
13:09:47 <mrd> @go bananas, envelopes, barbed wire functional programming
13:09:52 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
13:09:56 <jdrake> vixey: http://hpaste.org/11927#a1  Note the count 2 in there, I am going to change that so I can find out how many = there are in a row. BTW, I would like to know if there is a better syntax styling then I used.
13:10:01 <vixey> actually I suggest _not_ reading that banas thing
13:10:12 <vixey> there is a much much better text which contains that as one of the chapters
13:10:18 <vixey> Calculating Compilers
13:10:39 <camio> What does it mean when I can compile & run something fine, but when I ghci it I get a unknown symbol error?
13:11:03 <jdrake> camio: hpaste.org or it didn't happen :p
13:11:29 <camio> jdrake: It is a simple GLUT example program.
13:11:43 <jdrake> camio: can you show us what you are doing in ghci?
13:12:01 <camio> jdrake: runhaskell test
13:12:19 <camio> \HSGLUT-2.1.1.2.o: unknown symbol `__imp__glutGetProcAddress'
13:12:22 <unenough> how can i (using lambdabot or whatever) find out how type X implements class Y
13:12:34 <blackdog> vixey: cool, i'll check it out. pretty sure i need Maps, though - i'm thinking about 60000 distinct symbols
13:12:46 <jdrake> hmm, beyond my experience
13:12:51 <vixey> blackdog, yeah probably just need to change one line or something
13:13:01 <Botje> jdrake: length `liftM` many1 (char '=')
13:13:06 <camio> jdrake: It seems like ghci isn't linked with the .a library. I'm not sure how that works.
13:13:36 <roconnor> conal: I created a trac account but I have no idea how to make a ticket
13:14:20 <conal> roconnor: are you looking at http://trac.haskell.org/fieldtrip/
13:14:23 <lambdabot> Title: fieldtrip - Trac
13:14:23 <conal> roconnor: ?
13:14:29 <RayNbow> camio: which OS?
13:14:44 <roconnor> conal: yep
13:15:08 <conal> roconnor: logged in?
13:15:12 <camio> RayNbow: windows
13:15:13 <roconnor> yep
13:15:21 <conal> roconnor: do you see a "New Ticket" button near the upper right?
13:15:30 <roconnor> nope
13:15:49 <conal> roconnor: oh!  glad to know.  i'll poke around.
13:16:34 <RayNbow> camio: I managed to get OGL+GLUT working today with 6.10.1 thanks to this guide: http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
13:16:38 <lambdabot> Title: Less Sugar/More Meat » Blog Archive » freeglut + Windows + HOpenGL + HGLUT, http://tinyurl.com/5ualsl
13:16:59 <dons> conal: the examples on FieldTrip look great, but are missing module imports.
13:17:23 <snk_kid> RayNbow: i'm writing a blog to do it an even easier way for windows now ;)
13:17:24 <camio> RayNbow: That's for the pointer. I wrote that ;) It looks like it might not be complete.
13:17:28 <Cale> dons: I found there was a module FTest in reactive-fieldtrip already which contained the example code.
13:17:31 <conal> roconnor: hm.  i guess i'll have to learn more about trac.
13:17:34 <dons> ah ok.
13:17:54 <snk_kid> dons: i'm doing the deed we talked about yesterday
13:18:04 <camio> snk_kid: What's the secret to doing it easier?
13:18:15 <conal> dons: Cale, do you still see "FTest.hs"?  I renamed it to Test.hs a few days ago.
13:18:17 <snk_kid> camio: cabal-install :D
13:18:29 <Cale> conal: Did you upload that to hackage?
13:18:38 <dons> Test.hs
13:18:39 <Cale> conal: That's where I get my packages from ;)
13:18:42 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reactive-fieldtrip-0.0.2
13:18:45 <lambdabot> Title: HackageDB: reactive-fieldtrip-0.0.2, http://tinyurl.com/6xscy4
13:18:45 <Cale> ah
13:18:59 <RayNbow> camio: oh... :p
13:19:01 <Cale> that's newer than what cabal install pulled in... I'll update then :)
13:19:04 <jdrake> Botje: nice
13:19:05 <RayNbow> snk_kid: something easier?
13:19:08 <dons> woo!
13:19:10 <conal> Cale: ok
13:19:12 <dons> conal: works lovely
13:19:16 <camio> snk_kid: That'll download and install freeglut too?
13:19:21 <conal> dons: :)
13:19:49 <snk_kid> camio: i doubt it will go that far but i mean get packages in general
13:20:25 <camio> snk_kid: Ah I see. GLUT with freeglut is a bit complicated. I don't think cabal install is quite there yet.
13:20:35 <snk_kid> camio: anyways that blog helped me a little so
13:20:51 <snk_kid> camio: i'm gonna write one on building fraps
13:21:01 <snk_kid> camio: i mean frag
13:21:08 <Saya> just curious, is there a default operator/function that makes a pair out of 2 elements?
13:21:31 <RayNbow> > (,) 1 2
13:21:33 <lambdabot>   (1,2)
13:21:34 <lilac> (,)
13:21:45 <Saya> great thx :)
13:21:53 <pizza__> > (,,) 1 2 3
13:21:54 <lambdabot>   (1,2,3)
13:22:27 <Saya> how bout
13:22:34 <Saya> > (,(,)) 1 2 3
13:22:35 <lambdabot>   <no location info>: parse error on input `('
13:22:56 <mrd> I don't think it supports cross sections
13:23:11 <lilac> @type (((,) .) . (,)) 1,2,3
13:23:12 <lambdabot> parse error on input `,'
13:23:14 <lilac> @type (((,) .) . (,)) 1 2 3
13:23:16 <lambdabot> forall b a a1. (Num b, Num a, Num a1) => ((a1, a), b)
13:23:25 <lilac> @type (((,) .) . (,)) 'a' 'b' 'c'
13:23:27 <lambdabot> ((Char, Char), Char)
13:24:05 <pizza__> > (,) 1 $ (,) 2 3
13:24:10 <lambdabot>   (1,(2,3))
13:24:11 <mrd> good ways to piss off your co-workers
13:24:17 <Saya> > (,) ((,) 2 3)
13:24:20 <lambdabot>       Overlapping instances for Show (b -> ((t, t1), b))
13:24:20 <lambdabot>        arising from ...
13:24:44 <Saya> > (,) 1 ((,) 2 3)
13:24:49 <lambdabot>   (1,(2,3))
13:24:53 <vixey> > (,) "sa" "ya"
13:24:56 <lambdabot>   ("sa","ya")
13:25:06 <pizza__> > (,) ((,) 1 2) 3
13:25:07 <lambdabot>   ((1,2),3)
13:26:24 <unenough> Who can recommend text on category theory?
13:27:34 <andys> I have a weird issue with Parsec that I can't figure out. That said, I am pretty new to Haskell as well
13:27:48 <andys> is it reasonable to ask a question in this channel? Or am I best off using a mailing list?
13:28:49 <vixey> andys, I'm sure it's fine to ask that here
13:28:55 <f4lcon> im trying to concat a Maybe String with a String but I keep getting errors saying it should be a "Maybe a" when Im returning a String. Any ideas? http://hpaste.org/11855#a3 code in question is at the bottom of hCodeAux
13:29:08 <vixey> f4lcon, you can use mappend,
13:29:14 <vixey> > Just "foo" `mappend` Just "bar"
13:29:15 <lambdabot>   Just "foobar"
13:29:19 <vixey> > Nothing `mappend` Just "bar"
13:29:20 <lambdabot>   Just "bar"
13:29:35 <pozic> How can I filter all values with a Foo constructor? filter (== Foo{}) doesn't work. Or do I have to defined p Foo{} = True;p _ = False?
13:29:42 <pozic> define*
13:29:55 <f4lcon> hmm will try that
13:30:00 <vixey> f4lcon, but maybe mappend doesn't quite suit in your case though..
13:30:03 <Deewiant> filter (\f -> case f of Foo{} -> True; _ -> False)
13:30:14 <dons> conal: http://www.youtube.com/watch?v=WNB5V9Z7Obc
13:30:15 <Saya> how would i do (\x y z -> (x,(y,z)) with just operators? (just for the sake of having unreadable code :))
13:30:17 <lambdabot> Title: YouTube - 3D spinning torus: FRP FieldTrip demo
13:30:17 <vixey> f4lcon, but why aren't you using the fold? :)
13:30:22 <Deewiant> @pl \x y z -> (x,(y,z))
13:30:23 <lambdabot> (. (,)) . (.) . (,)
13:30:28 <f4lcon> I found this way to suit my noobish ways xD
13:30:33 <Saya> :o
13:30:39 <andys> I'm trying to write a very basic parser that looks for a lower case letter first, followed by any regular letter
13:30:41 <andys> so I did
13:30:58 <vixey> f4lcon, oh.. I only use folds and so on because they make everything much easier
13:30:59 <byorgey> unenough: what's your mathematical/CS background?
13:31:05 <Deewiant> @pl \x y z -> ((x,y),z)
13:31:06 <lambdabot> ((,) .) . (,)
13:31:06 <andys> atom = do { schar <- lower ; rem <- (many letter) ; return schar : rem; }
13:31:24 <f4lcon> ill probably use them as i learn more haskell but I couldnt get my head around it last night so i decided to stick with this stuff
13:31:26 <conal> dons: i just made http://haskell.org/haskellwiki/FieldTrip more explicit about how to run the example.
13:31:26 <Cale> unenough: I recommend Awodey's text, regardless of your existing background :)
13:31:29 <lambdabot> Title: FieldTrip - HaskellWiki
13:31:42 <vixey> f4lcon, well I can help you to understand it if you like
13:31:44 <andys> and it gives me a type whinge that it's expecting [m Char] rather than [Char]
13:31:51 <Saya> @pl ((,) .) . (,)
13:31:52 <lambdabot> ((,) .) . (,)
13:32:03 <f4lcon> maybe another time but atm I just want to finish this work :P
13:32:12 <unenough> byorgey, i've done stuff like complex analysis, linear algebra / fourier analysis, undergrad level
13:32:14 <dons> conal: very impressed at the performance  just in ghci alone.
13:32:15 <andys> I've been playing with ghci trying to look at types, and it looks like it should be fine. But my Haskell is well, not great
13:32:15 <conal> dons: hey, neat!
13:32:22 <pozic> dons: just not portable, since vector-spaces doesn't work on my system.
13:32:26 <Cale> unenough: It has not much in the way of prerequisites, and contains exposition on some of the most important examples of categories.
13:32:27 <dons> conal: added a link to the video of the demo at the bottom.
13:32:32 <dons> pozic: hm?
13:32:50 <jsn> MarcWeber: i've come up with a small example that illustrates the problem, from end to end
13:32:57 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
13:33:00 <lambdabot> Title: cache:http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon, ..., http://tinyurl.com/4jav6v
13:33:01 <pozic> dons: cabal: Package vector-space-0.4.1 can't be built on this system.
13:33:01 <dons> pozic: vector-spaces looks straight forward. you might need ghc 6.10
13:33:07 <dons> pozic: yes, but why... ?
13:33:10 <pozic> dons: then Cabal should say that.
13:33:19 <dons> pozic:
13:33:19 <vixey> pozic, so fix cabal
13:33:20 <dons>   if impl(ghc < 6.10) {
13:33:20 <dons>     buildable: False
13:33:20 <dons>   }
13:33:27 <dons> pozic: portable. but dependent on new ghc.
13:33:31 <pozic> vixey: or not look at the demo.
13:33:32 <unenough> Cale, woohoo exactly one copy in the library :)
13:33:40 <pozic> vixey: problem solved :)
13:33:43 <dons> pozic: you need ghc 6.10...
13:33:43 <conal> dons: it is awfully fast.  thx for that video link.
13:33:50 <Cale> unenough: There's that PDF there as well.
13:33:53 <dons> conal: yes. i'm amazed at how well ghci holds up.
13:34:26 <conal> dons: of course reactive & FieldTrip are compiled in this case.
13:34:32 <dons> yup
13:34:47 <dons> and thats at full 1600x1200 too
13:34:50 <unenough> Cale, two questions. A. is it interesting? (e.g. surprising results? any results at all?) B. useful/important for understanding haskell (or just 'extra')?
13:34:56 <conal> wowzers
13:35:00 <Saya> @pl \x y z -> (x,(y,z))
13:35:01 <lambdabot> (. (,)) . (.) . (,)
13:35:03 <conal> and too bad the video can't show the actual frame rate.
13:35:05 <dons> note my dual head setup in that screencast
13:35:41 <conal> dons: how did you make the movie?
13:35:54 <dons> using 'recordmydesktop'
13:36:00 <dons> then uploading the .ogv file to youtube
13:36:48 <snk_kid> whats the video about?
13:37:08 <conal> dons: cool.  now that i'm working in linux (blisfully), i get to pick up all these toys from my haskell friends.
13:37:14 <dons> yay :)
13:37:23 <Cale> unenough: It's useful but not important for understanding Haskell. There are a number of interesting results in the book, including the best exposition I've found on Yoneda's lemma (which ought to be called Yoneda's completion theorem), and lots of connections between category theory and mathematical logic.
13:37:50 <RayNbow> Cale: is the pdf's contents equal to the contents of the hardcover book?
13:38:05 <jsn> MarcWeber: http://hpaste.org/11922#a3
13:38:09 <Cale> It should be, but I haven't had a chance to get hold of the hardcover book, so I don't know.
13:38:51 <dons> snk_kid: http://www.reddit.com/r/programming/comments/7cijd/fieldtrip_purely_functional_realtime_3d_graphics/
13:38:53 <lambdabot> Title: FieldTrip: Purely functional real-time 3D graphics using reactive programming :  ..., http://tinyurl.com/5qveng
13:38:54 <unenough> Cale, thanks. i'm hoping it will also help me with haskell and designing languages
13:39:01 * RayNbow prefers reading from paper rather than from screen...
13:39:10 * unenough too
13:39:11 <Cale> I think it may have even come from the original author. I mentioned that I was looking for that book to my friend, and he procured a copy of that PDF. (But it didn't appear in any of my usual places to look for books online)
13:39:26 <RayNbow> but I don't feel like printing 266 pages... nor do I have the money for the book :p
13:39:50 <vixey> unenough: which languages do you want to design?: )
13:39:51 <Cale> http://www.cs.man.ac.uk/~hsimmons/BOOKS/books.html
13:39:58 <snk_kid> dons:  nice :D
13:39:59 <lambdabot> Title: Books
13:40:02 <unenough> vixey, i'm working with Peaker
13:40:02 <Cale> also has some books relevant to functional programmers
13:40:09 <vixey> on what?
13:40:21 <unenough> i thought he told you
13:40:23 <luite> RayNbow: just another reason to buy an eink reader ;)
13:40:28 <dons> conal++ i'm so glad to see this stuff coming to fruition. its been a long path, but looks like its mostly in place now.
13:40:28 <Cale> Lambda calculi, Category theory, and Model theory.
13:40:34 <dons> high level, high perf declarative 3d woo!
13:40:53 <conal> dons: thx. :) and thx for the reddit love, too.
13:41:14 <RayNbow> luite: nah, I actually could afford to buy the book... it's just that I don't want to spend money on books while I have a reading queue :p
13:41:15 <Cale> I'm actually curious about what the performance will be like for more complex scenes :)
13:41:17 <int-e> . o O ( is there a lambdacat pic involving "mewtype"? )
13:41:32 <byorgey> int-e: haha!  there isn't.
13:41:35 <vixey> AWW
13:41:37 <unenough> vixey, it's hard for me to explain :) for now, just learning haskell. later, building a system that includes a programming environment
13:41:44 <Cale> I really hope that it scales well, because I can imagine this being attractive to game developers.
13:41:44 <vixey> most of the model theory stuff is not finished
13:41:49 <luite> RayNbow: that would mean you couldn't spend any money on any book, ever?
13:41:59 <vixey> unenough, ah, excellent
13:42:17 <dons> Cale: i'm excited. if ghci can run high level descriptions like this, there's some room yet just by compiling it.
13:42:37 <dons> Cale: you should start playing with it. The more experience, the better.
13:42:40 <RayNbow> luite: well, I don't mind having a queue... but I don't want the queue to become too large :p
13:42:40 <dons> do some pretty mathy things
13:42:40 <Cale> dons: yeah
13:42:44 <Cale> :)
13:42:52 * RayNbow should continue reading TaPL some time :p
13:42:54 <unenough> a programming environment where the actual code (not text) is constructed on-the-fly as you edit, allowing many neat features that are currently horribly hard to implement, such as refactoring easily, etc...
13:43:04 <unenough> but that's just Step 1 (tm)
13:44:03 <MyCatVerbs> I already have a programming environment where the actual AST is created on the fly as I edit. It's called Liskell. :P
13:44:13 <luite> RayNbow: my queue is always too large, it's a lazy list, as some elements get evaluated, new elements get appended to the end automatically
13:44:24 <MyCatVerbs> There's another surprisingly good one called DrScheme, too.
13:45:19 <vixey> I like paredit for lisp
13:45:21 <unenough> MyCatVerbs, i mean that the code AST exists in memory and the text on the screen is just a 'gui'. is that what you have?
13:45:31 <unenough> or do you compile text?
13:45:32 <vixey> unenough, you use paredit?
13:45:51 <unenough> vixey, nope, googling it now
13:46:02 <RayNbow> http://www.amazon.com/review/RTRDVINF2JXW0/ref=cm_cr_dp_cmt?%5Fencoding=UTF8&ASIN=0198568614&nodeID=283155#wasThisHelpful <-- there's a sigfpe on Amazon talking 'bout Category Theory! :p
13:46:08 <MarcWeber> jsn: So what? Does my example work?
13:46:09 <lambdabot> http://tinyurl.com/649hvg
13:46:10 <unenough> ah, emacs mode
13:46:25 <FunctorSalad_> editline related? "Linking dist/build/haddock/haddock ... /usr/bin/ld: cannot find -ledit"
13:46:33 <MarcWeber> jsn: Why do you have dropped waitForProcess?
13:46:36 <FunctorSalad_> (while trying to install haddock 2.4.1)
13:46:59 <Gabbie> Heh
13:47:02 <Gabbie> haddock
13:47:10 <jsn> MarcWeber: i was advised that it can lead to a race condition
13:47:12 <Gabbie> Haskell has the best names
13:47:18 <FunctorSalad_> :)
13:49:32 <jsn> MarcWeber: also, waitForProcess seems to make the problem show up earlier
13:49:39 <MarcWeber> jsn: Than you should ask them about how to solve the problem cause they do know more than I do
13:49:48 <jsn> okay
13:49:50 <unenough> there's a difference between a fancy text editor and an editor that transforms the executable AST in memory on the fly, where the text is just a view on the screen
13:50:06 <pozic> unenough: it's called TeXMacs.
13:50:06 <MarcWeber> jsn Does it show up in my example as well (even if it does contain a race condition) ?
13:51:15 <unenough> pozic, isn't that specifically for latex?
13:51:42 <roconnor> unenough: nope,  It's made from scratch
13:52:18 <roconnor> when I use TeXmacs always want to rewrite it in Haskell.
13:52:22 <unenough> i don't get it
13:52:30 <unenough> doesn't it edit only tex?
13:52:49 <roconnor> nope it has it's own format
13:53:02 <unenough> what format?
13:53:11 <roconnor> other than the vague ability to export to latex, I think it is totally unrelated to TeX
13:53:22 <roconnor> TeXmacs format
13:53:24 <roconnor> .tm
13:53:46 <unenough> it's a generic AST editor?
13:53:57 <roconnor> hmm
13:54:28 <unenough> doesn't have to be generic, even a specific AST editor of some programming language (not typesetting language...)
13:54:29 <ttfh_> say i want to time the evaluation of a pure value, I want something like timeComp :: a -> IO TimeDiff. In timeDiff i get the current time, then do the computation, then get the time again. How do I force the computation to take place between the other two IO actions without printing it?
13:54:30 <roconnor> possibly  I mean it has buildin tags for chapter, sectoin, tables, etc.
13:55:35 <vixey> ttfh_: I don't think it can be done like that though
13:55:57 <vixey> ttfh_: I used Control.Concurrents rnf thing to time sort algorithms
13:56:14 * roconnor is writing his thesis in TeXmacs at the moment
13:56:43 <jsn> unenough: it edits a weird scheme thing
13:56:57 <unenough> well anyway, the idea is to have the editor understand the meaning of the AST it's building, so that it can do things like show you the type inferred in real-time as you edit, prevent you from ever creating broken (uncompilable) code, do all sorts of lambdabot tricks easily.
13:57:04 <jsn> unenough: they made a special kind of scheme to store TeX
13:57:14 <pozic> roconnor: nice
13:57:21 <unenough> jsn, i think the scheme is an extension language to create plugins for texmacs, no?
13:57:26 <mrd> it's called a structure editor
13:57:31 <jsn> unenough: it is both
13:57:38 <Plareplane> ot: is there a common name for a collection that is ordered and has only distinct elements (compared with set, bag, list)
13:57:46 <jsn> unenough: texmacs format is actually full of parens
13:57:48 <roconnor> pozic: It fills me with hate due to all its little problems
13:57:59 <pozic> roconnor: that too ;)
13:58:05 <vixey> Plareplane: I heard of FreshList
13:58:06 <pozic> roconnor: I used it for several weeks.
13:58:20 <jsn> unenough: i  guess they have an XML format, as well
13:58:34 <roconnor> I think TeXmacs is a great idea, but it has some design flaws.
13:58:40 <unenough> the format is not the issue.. :) the issue is that the editor will understand the programming langauge's semantics as it edits the AST
13:58:42 <ttfh_> vixey: maybe it can't, I get 0 timediffs because the value is evaluated later
13:58:53 <roconnor> hence my urge to rewrite it ;)
13:58:54 <vixey> ttfh_, yeah, that's why I used rnf
13:59:14 <jsn> MarcWeber: thank you for your help, i have posted my question to haskell-cafe
13:59:16 <roconnor> But I hate LaTeX even more, so I use TeXmacs.
13:59:25 <unenough> heh, i tried using texmacs once and it was so slow i ended up learning some latex instead and using plain emacs
14:00:02 <jsn> it's kind of cool that you can plug it in to Matlab and so forth
14:00:14 <dons> conal: note the response to the article is much stronger when there's images and now a video link.
14:00:29 <dons> strongly recommend videos for all demos :)
14:01:00 <unenough> dons: http://www.youtube.com/watch?v=RT87JfTYIvo
14:01:02 <lambdabot> Title: YouTube - GraphUI
14:01:04 <MarcWeber> jsn Can't you just run it and tell me wether it you'll get md5sum missmatch?
14:01:12 <MarcWeber> I'mt interested in it.
14:01:23 <jsn> MarcWeber: okay
14:01:24 <dons> hey nice, unenough
14:01:38 <jsn> MarcWeber: i've got another suggestion to try, as well
14:01:42 <dons> unenough: is it on hackage yet?
14:01:53 <unenough> dons, when it will be rewritten, in haskell, it will be.
14:02:07 <dons> ah, so still in the rewrite stage?
14:02:15 <unenough> it was written in python
14:02:41 <dons> oh, i was getting confused with sarasvati
14:02:42 <roconnor> unenough: re: your video link --- This is UNIX. I know UNIX!
14:02:47 <dons> hehe
14:02:49 <jsn> MarcWeber: allberry_b seems to think i should just fork like crazy -- worth a shot
14:02:57 <vixey> UNIX is written in python ???
14:03:07 <MarcWeber> jsn: If you remember that was my first suggestion.
14:03:07 <jsn> vixey: LOLz
14:03:10 <unenough> dons, using a library that resembles a primitive Reactive
14:03:17 <unenough> roconnor, huh?
14:03:27 <MarcWeber> jsn: But I'll jsut forget about it.
14:03:41 <jsn> MarcWeber: i must have missed that, sorry
14:04:00 <roconnor> unenough: did you ever watch Jurassic Park? ... Am I getting to old?
14:04:15 <sw17ch> roconnor, I caught the reference... :P
14:04:15 <unenough> roconnor, oh ok :) heh yeah
14:04:19 <vixey> ahaha that's where it's from
14:04:30 * vixey over my head until you explain it though
14:04:31 <unenough> it does look like that 'unix'
14:04:38 <allbery_b> jsn: you only need the one, not both sides.  the key point is that you can't write in a big chunk and then read in a big chunk because ifeither input or output is larger than PIPE_BUF (512 bytes in most unixen, but IIRC linux uses the size you're seeing problems with)  it'll deadlock
14:05:09 <unenough> http://code.google.com/p/enough/wiki/Graphui
14:05:10 <lambdabot> Title: Graphui - enough - Google Code - A generic graph editing gui
14:05:14 <allbery_b> your write will be blocked waiting for the subprocess on the other end to read, but it's blocked waiting for you to read from the other pipe
14:05:43 <jsn> unenough: that is neat
14:05:48 <unenough> We made something called Observable, that's I guess like a Reactive value only much less refined. It simply calls a callback when the value changes.
14:06:12 <unenough> so when the graph object changes , the gui updates automatically (and calls dot to re-format it)
14:07:33 <unenough> my first mission in haskell will be to re-implement it using FRP
14:08:31 <ddarius> conal: Is plasmat a function in fieldtrip or a just a definition for that example?  If the former, what's wrong with plasticMaterial?!
14:09:04 <conal> ddarius: it's defined in the test module
14:09:10 * roconnor pulls out his plasmat rifle.
14:09:17 <ddarius> conal: Whew.
14:10:33 <conal> dons: what response are you noticing?
14:11:26 <unenough> Cale, i discovered category theory after writing this: http://code.google.com/p/enough/wiki/DeltaAlgebra and later realizing i'm re-inventing the wheel (in a really crooked way)
14:11:27 <dons> conal: oh, just after linking to the video, we get 10/1 upmods v downmods. while it was 1/1 before hand.
14:11:28 <lambdabot> Title: DeltaAlgebra - enough - Google Code - Formal definitions for deltas
14:12:03 <conal> dons: oh, nice!
14:12:07 <Cale> unenough: :)
14:12:23 <unenough> i tried to invent an algebra of functions with inversion and composition operations
14:12:30 <Cale> unenough: There's also some rather good videos on category theory on YouTube, once you have a few of the basic definitions under your belt.
14:12:48 <dons> conal: the mass media is very results focused. they want to see a demo before they'll read on.
14:13:40 <unenough> hmm is there something in haskell about invertible computations? (or invertible functions)
14:13:52 <dons> there's something.
14:14:12 * roconnor wants a type for bijections too.
14:14:26 <conal> there's the paper "there and back again".
14:14:42 <Cale> http://www.youtube.com/user/TheCatsters
14:14:43 <lambdabot> Title: YouTube - TheCatsters's Channel
14:14:48 <conal> also Data.Bijection in the TypeCompose package
14:15:36 <unenough> Cale, thanks. i'll read the book first :)
14:15:43 <unenough> bookmarked
14:15:46 <roconnor> conal: perfect.  Is TypeCompose H98?
14:16:23 <Cale> unenough: Well, once you get to natural transformations, the videos should start to become accessible.
14:16:48 <conal> roconnor: no.
14:17:08 <roconnor> aww
14:17:19 <roconnor> I want my lib to be portable.
14:17:36 <roconnor> I'll just use a record type :)
14:17:46 <dons> roconnor: portable to what?
14:18:14 <roconnor> dons: hugs, jhc, yhc, or any other haskell compiler that I don't know of.
14:18:42 <dons> just document the extensions you use, and stick to h' compat ones.
14:19:18 <roconnor> Data.Bijection itself looks Haskell 98
14:19:49 <unenough> i don't understand arrows at all, though
14:20:12 <unenough> can't there be a simpler formulation of bijection, at least in some cases?
14:20:30 <roconnor> does this mean Data.Bijection ought to be in it's own package?
14:20:43 <luqui> unenough, data Bijection a b = Bijection (a -> b) (b -> a) ?
14:21:48 <conal> roconnor: Data.Bijection uses an infix type op
14:22:03 <roconnor> oh right
14:22:14 <roconnor> is that not H98?
14:22:38 <conal> roconnor: hm.  i'm not sure.
14:24:09 <roconnor> hmm looks like you are right
14:24:40 <conal> roconnor: too bad.  they're pretty.  i'm also hooked on infix type variables.
14:25:11 <roconnor> ``Unlike data constructors, infix type constructors are not allowed (other than (->)).''
14:25:36 <vixey> such a stupid restriction
14:25:39 <dons> its almost 2009. we can afford a few LANGUAGE pragmas these days.
14:25:46 <dons> H98 is obsolete.
14:25:48 <conal> roconnor: i wonder if there's a sort of conditional compilation trick one can play to get the functionality for h98 but nicer notation for >98.
14:26:10 <vixey> conal, well there's C pre processor
14:26:50 <conal> anyone here experienced with trac?  i don't know why roconnor didn't get permission to create a ticket when he registered on the fieldtrip trac.
14:27:14 <psnively> Gleetings, earthrings.
14:27:14 <roconnor> maybe I can use some sort combination of compile options and preprocessor and type synonyms.
14:27:48 <vixey> screw h98!
14:27:57 <vixey> it's last millenum .
14:27:58 <conal> i removed the create & modify permissions from the "anonymous" user, to preclude geting trac spammed.
14:28:32 <unenough> psnively, A Greener Light Stings
14:28:33 <psnively> conal: Awesome work on Reactive and FieldTrip, and thanks so much for "Simply efficient..."
14:28:47 <conal> psnively: :) :)
14:28:52 <psnively> I have dreams of implementing the concepts from "Simply..." in OCaml. :-D
14:29:06 <psnively> (I know, I'm in the wrong channel.)
14:29:14 <dons> psnively: you need to get where the action (and community) is ;)
14:29:36 <psnively> Hi Don! Yeah, well, with 6.10.1 out, it's pretty seductive, all right. :-D
14:29:38 <conal> psnively: go for it.  the ideas aren't bound to haskell, though laziness seems pretty key.
14:29:41 <luqui> Is there a normal form for types closed under product, coproduct, and mu.
14:29:45 <conal> yay 6.10.1 !
14:29:47 <roconnor> dons: I'll switch when either haskell' is published, or Caleskell is published.
14:29:50 <dons> psnively: hear that? laziness is *key*
14:29:57 <psnively> Yeah. Well, I will no doubt have to use the "lazy" declaration a lot.
14:30:02 <vixey> luqui, what do you mean by normal form?
14:30:08 <unenough> my math teacher always said: if man was not lazy, he wouldn't have invented the wheel.
14:30:11 <psnively> dons: The virtues of a programmer, even... ;-)
14:30:29 <luqui> vixey, eg. a textual representation such that the same type gets the same representation
14:30:30 <psnively> To Larry Wall's point, it would seem.
14:30:59 <conal> turns out there's a #trac channel.  ain't irc wonderful?
14:31:08 <psnively> I do read on proggit that OCaml is dying. ;-)
14:31:38 <dons> it does feel like its heyday was about 5 years ago.
14:31:56 <luqui> it seems like a prefix form with de bruijn indiced would work, but I worry about showing well-kindedness of them
14:31:59 <dons> before the multicores, and before F# stole some of the momentum
14:32:07 <roconnor> dons: the Extensions: field is blank in http://hackage.haskell.org/packages/archive/TypeCompose/0.5.1/TypeCompose.cabal
14:32:09 <lambdabot> http://tinyurl.com/5llklr
14:32:14 <roconnor> should that be filled in?
14:32:17 * roconnor isn't sure
14:32:26 <psnively> If as a testbed for new concepts, that might be so. But with support for shared libraries, Batteries, etc. it's actually starting to feel like: hey, I could use this instead of C++!
14:32:31 <dons> roconnor: if any pragmas are need for individual modeuls, imo they should be in the .cabal too
14:32:55 <dons> psnively: it'll be interesting to see if the batteries guy can unify the tribes of ocaml.
14:32:56 <psnively> It'd be nice to see the parallel GC stuff make it in, yes.
14:33:03 * bos isn't too impressed with larry wall's language design nostrums :-)
14:33:07 <psnively> "Unite the clans!"
14:33:40 <bos> it seems that some ocaml users have replaced the standard library wholesale. i wonder how they'd fit into a batterified world.
14:33:42 <psnively> dons: I'm intensely interested to see where Disciple and YNot go, too.
14:34:07 <psnively> bos: Yeah. It'll be interesting to see how Jane Street Core and Batteries play.
14:34:07 <dons> they're research prototypes, so i don't think DDC at least is going anywhere.
14:34:12 <vixey> psnively, just anything with esoteric type systems :))
14:34:18 <psnively> BTW, bos + dons: Thank you for "Real-World Haskell." :-D
14:34:25 <dons> ?users
14:34:26 <lambdabot> Maximum users seen in #haskell: 559, currently: 531 (95.0%), active: 21 (4.0%)
14:34:26 <bos> psnively: our pleasure
14:34:35 <psnively> vixey: I'm beginning to get Coq, which is kinda scary.
14:34:36 <dons> off to the printers!
14:34:41 <luqui> psnively, yay!
14:34:47 <pumpkin_> psnively: sounds rude
14:34:59 <psnively> pumpkin_: I blame the French.
14:35:04 <vixey> psnively, every time I write haskell I see these pre/post conditions everywhere..
14:35:14 <vixey> (after doing some programs in Coq)
14:35:37 <vixey> but yeah ... It will be cool when the next Ynot is out
14:35:57 <psnively> And I'm playing with Ur/Web. Where does the time go?
14:36:11 <bos> you're a ferment of functional fiddling
14:36:19 <psnively> Ain't that the truth.
14:36:30 <luqui> Yeah, really tempting to write   sort :: forall xs:[a], { ys:[a] | sameelems xs ys /\ sorted ys }
14:36:45 <Lemmih> dcoutts: Should documentation upload be a flag to 'upload' or 'haddock', or should it perhaps be its own command?
14:36:48 <psnively> bos: And the day job's in Python and we use Mercurial. So you've got me coming and going!
14:37:08 <unenough> well, with a super-editor that knows what the code is about, such annotations might be much easier to implement
14:37:23 <bos> psnively: it's a small hackerly world!
14:37:27 <vixey> unenough, you're not extending Yi?
14:37:39 <dcoutts> Lemmih: I wasn't thinking of adding it directly to cabal-install but instead using the same infrastructure for other more specialised hackage clients
14:37:46 <psnively> bos: I give you credit for straddling the dynamic/static worlds without losing your sanity. ;-)
14:37:48 <unenough> vixey, currently just learning haskell :) i'm dreaming aloud
14:38:05 <dcoutts> Lemmih: eg making a hackage-buildbot program that imports cabal-install as a lib
14:38:21 <bos> psnively: :)
14:38:25 <conal> roconnor: i learned some about trac permissions and tweaked them.  would you please refresh (and logout & login if necessary) and see if you can see "New Ticket"?
14:38:26 <Lemmih> dcoutts: Can the buildbots be expected to build documentation?
14:38:27 <bos> psnively: what are you doing in python?
14:38:35 <unenough> vixey, and no. Yi is a text editor, right?
14:38:54 <dcoutts> Lemmih: not random ones on end users machines, but we can set up a dedicated client
14:39:07 <psnively> bos: http://www.virgincharter.com
14:39:11 <Lemmih> dcoutts: Why not get the authors to upload the documentation. We know for sure that they can build the software.
14:39:16 <roconnor> conal: hey, new ticket!
14:39:31 <bos> psnively: wow, specialised!
14:39:41 <dcoutts> Lemmih: I fear it'd be horribly inconsistent, but in principle they should be able to do so
14:39:48 <psnively> We like being on the fringe. :-)
14:39:55 <conal> roconnor: :)  i'm just learning the ropes.
14:40:13 <luqui> I'll ask one more time, since I'm not sure where to look.  Is there a normal form for types (product, coproduct, mu), such that I can tell when two types are the same by syntactic equality?
14:40:14 <dcoutts> Lemmih: but they can already do that just using curl, we do not need special support in cabal-install
14:40:37 <Lemmih> dcoutts: To me it seems natural to upload the documentation together with the release.
14:40:40 <Lemmih> dcoutts: We need a bunch of things to make it play nice with the other documentation.
14:40:46 <vixey> luqui, you can have Mu down at any level?
14:40:56 <luqui> vixey, yeah presumably
14:41:04 <vixey> luqui, huh?
14:41:27 <Lemmih> dcoutts: The documentation files need to link to each other (between libraries).
14:41:32 <vixey> luqui, so do you have an example of isomorphic types where multiplying out the products doesn't give you syntactic equality?
14:41:48 <dcoutts> Lemmih: yes, all the more reason to have it generated by a dedicated client builder
14:42:04 <joey``> Hey, I'm trying to compile some relatively old haskell, but I'm running into a wall as it's trying to import "GHC"
14:42:11 <vixey> luqui, I wonder if that would work, but I'm not sure how it would interact with Mu
14:42:12 <joey``> Anyone know how to get round this?
14:42:18 <psnively> Running into a -Wall?
14:42:22 <Lemmih> dcoutts: It's quite easy to do. It would just be a few lines in cabal-install.
14:42:30 <luqui> vixey, it's actually the free variables that are giving me problems
14:42:32 <dcoutts> Lemmih: that's not the point :-)
14:42:36 <joey``> Failed to load interface for `GHC':"
14:42:43 <joey``> That's the error I'm getting.
14:42:49 <joey``> Something about it being hidden.
14:43:00 <luqui> vixey, so I'll describe it more fully.
14:43:04 <vixey> luqui, can you show me an example (I'm not sure where free variables can come into it)
14:43:08 <vixey> luqui, ah that would be better
14:43:14 <Lemmih> dcoutts: Why should we wait hours after a new release to get the documentation?
14:43:29 <dcoutts> Lemmih: it need not be that slow
14:43:44 <dcoutts> Lemmih: but it'll take a similar time for other metrics
14:44:03 <Lemmih> dcoutts: The author can supply it at once.
14:44:13 <luqui> vixey, I have some type functor T :: * -> * (injective, so it's not a synonym), but I don't know how it's implemented, just some hash of it.  Then I want to compute a hash of Mu x. T x
14:44:24 <dcoutts> Lemmih: I'm not saying we should ban authors uploading docs, just that I don't think we want it to be the standard thing, for reasons like getting the right haddock version, getting the links right etc
14:44:27 <Lemmih> dcoutts: I don't see why there should be a time where we have the code but not the documentation.
14:44:39 <dcoutts> Lemmih: it needs quite a bit of configuration of the environment to get it right
14:44:55 <Lemmih> dcoutts: It does?
14:44:59 <luqui> vixey, so yeah, I'm hashing types, without knowing the implementations of some of the components, just their hashes.
14:45:00 <dcoutts> Lemmih: then lets delay the publishing of the code ;-)
14:45:19 <luqui> (naturally I will have to rehash at every level or something like that)
14:45:33 <vixey> luqui, why is Mu a binder, i.e. why not (Mu T) ?
14:45:46 <dcoutts> Lemmih: just making sure the links work is non-trivial
14:45:50 <Lemmih> dcoutts: This would be so easy and fast: 'cabal upload && cabal upload-documentation'
14:46:01 <luqui> vixey, that makes sense.  How do I represent Mu x. T x y ?
14:46:31 <luqui> would I just make an injective Flip, and say that Flip (Flip T) /= T
14:46:34 <Lemmih> dcoutts: It is very trivial.
14:46:58 <Lemmih> dcoutts: It fails to compile if the links don't work.
14:47:14 <roconnor> conal: I made a ticket! http://trac.haskell.org/fieldtrip/ticket/2
14:47:15 <lambdabot> Title: #2 (Replace Graphics.FieldTrip.Color with Data.Colour.) - fieldtrip - Trac
14:47:27 <unenough> Colour?
14:47:53 <dons> the library.
14:47:53 <psnively> conal: So... when do we see the Quake 3 port to reactive-fieldtrip? :-D
14:47:54 <vixey> I don't understand why you are hashing types
14:48:00 <dcoutts> Lemmih: the docs generated by cabal haddock are not by default suitable since the urls will be to file:///usr/local/share/doc. etc rather than to the other html docs on hackage
14:48:02 <dons> psnively: oh, instead of yampa?
14:48:05 <Lemmih> dcoutts: Haddock will never point to X.Y.Z from package A if such function doesn't exist. And it's very easy to check whether package A has documentation available.
14:48:26 <psnively> dons: Or maybe something more aggressive, if the point is to show off "Simply efficient..."
14:48:32 <Lemmih> dcoutts: Haddock has wonderful flags for changing the urls.
14:48:32 <dons> psnively: the existing port of quake 3 to haskell used frp based on yampa, fwiw.
14:48:37 <luqui> vixey, uh, because... that's what... I'm doing?    I'm building a global distributed object model, so there is one data structure shared throughout the whole world.
14:48:49 <dons> psnively: http://uk.youtube.com/watch?v=0jYdu2u8gAU that one.
14:48:50 <lambdabot> Title: YouTube - Frag - 3D FPS game written in Haskell
14:48:51 <Lemmih> dcoutts: I've tested them. They work. It's just a bother to write them by hand.
14:48:51 <luqui> I don't want each part to have to know about all the types in a substructure of an object it has part of
14:48:52 <psnively> dons: I'd forgotten about that, actually.
14:49:06 <dcoutts> Lemmih: yes, it is obviously possible, I'm just pointing out that the defaults are not right, it needs some fiddling
14:49:08 <dons> we have all the fun in #haskell
14:49:21 <psnively> Oh, Frag. I was hoping for a real port of Q3. Or is Frag a full port?
14:49:24 <Lemmih> dcoutts: Right. Hence my original question.
14:49:24 <dcoutts> Lemmih: and it's better if the .haddock files for different packages are generated by the same haddock version
14:49:29 <Botje> #haskell :: IO [Fun]
14:49:31 <vixey> luqui, must you implement this? This is already done in Oz
14:49:35 <Lemmih> dcoutts: Where should I put the code that does the fiddling.
14:49:37 <dons> its a port of the scenes, but uses its own engine.
14:49:53 <luqui> vixey, well, it's an experiment, so in some sense, yes I must.  but I will look at Oz.
14:50:00 <conal> roconnor: thanks for the ticket.  i don't track detail very well, so i'm glad for the help.
14:50:03 <luqui> I have seen it briefly, but never really dug in
14:50:06 <pumpkin_> what is "Moo" called if I say data Baa = Moo Int | Nothing;
14:50:07 <Lemmih> dcoutts: What? Haddock version?
14:50:09 <pumpkin_> ?
14:50:12 <luqui> can you tell me what I should look for, vixey?
14:50:14 <vixey> luqui, the CTM book covers how it all works in detail
14:50:30 <Saizan> pumpkin_: a data constructor
14:50:31 <roconnor> conal: what do you mean by "don't track detail"?
14:50:37 <psnively> dons: Of course re: engine. And I'd not seen the video, thanks. Good stuff.
14:50:39 <dcoutts> Lemmih: yes, .haddock binary files are not necessarily compatible across haddock versions
14:50:42 <kniu> Where can I find a compiler that "flattens" a whole program into combinators?
14:50:54 <pumpkin_> Saizan: thanks, and "Baa" is a data type (name)?
14:50:55 <dcoutts> Lemmih: as I've said I think into a separate client is the right place
14:50:55 <psnively> kniu: Isn't that GHC?
14:50:57 <dons> kniu: ghc?
14:51:02 <vixey> kniu, I thikn there's one in the Monad.Reader
14:51:05 <kniu> what
14:51:16 <Lemmih> dcoutts: #haskell-overflow?
14:51:24 <luqui> vixey, thanks much.  I'll have a look.
14:51:26 <psnively> Hey, I beat dons! LOL
14:51:29 <jdrake> :t liftM
14:51:30 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:51:30 <Saizan> pumpkin_: just "type" usually
14:51:35 <kniu> I thought ghc implements the STG Machine.
14:51:40 <pumpkin_> Saizan: thanks a lot! :)
14:51:49 <conal> roconnor: i mean i get overwhelmed with trying to remember details.
14:52:07 <vixey> kniu, II was thinking of this one www.haskell.org/sitewiki/images/0/0a/TMR-Issue10.pdf
14:52:07 <psnively> Maybe I'm misunderstanding either your question, or what the Spineless, Tagless G-Machine is.
14:52:13 <conal> roconnor: that's why i work so hard to make things at making things simple
14:52:13 <unenough> what's up with yampa?
14:52:16 <kniu> vixey, thanks.
14:52:17 <roconnor> conal: oh of course.  That's what trac is for :)
14:52:58 <luqui> aw man, mozart doesn't build on amd64.  bleh.
14:53:01 <dons> unenough: arrows are up.
14:53:15 <vixey> luqui, binaries don't work?
14:53:25 <vixey> luqui, in any case the theory is all on paper
14:53:28 <psnively> It doesn't?
14:53:32 <roconnor> conal: heh.  If there is anything I've learned, it's that dealing with colour is not simple :P. That's why I'm writing a lib.
14:53:37 <unenough> dons, yampa was before arrows?
14:53:47 <dons> monads were before arrows
14:53:57 <conal> unenough: yampa is arrowized frp
14:54:17 <conal> unenough: *an arrowized frp
14:54:37 <unenough> ah. and Reactive doesn't use arrows? excuse my newbieness
14:54:57 <Philippa> <dons> psnively: the existing port of quake 3 to haskell used frp based on yampa, fwiw. <- I didn't think it was actually a port of Q3 as opposed to an engine capable of rendering the maps and models?
14:55:07 <Philippa> (there's a /big/ difference between a graphics engine and a game engine)
14:55:27 <psnively> Indeed.
14:55:46 <conal> unenough: exactly.  reactive is more like the original fran in being built on functor & applicative.
14:55:55 <psnively> I struggle with whether to write a scene graph API, e.g. as a stunt, or just bind to, e.g. Horde3D.
14:56:47 <unenough> ok, i have a superficial preference for things that don't use arrows (less to understand)
14:56:50 <psnively> Regardless, I think writing games in C++ is INSANE.
14:56:50 <conal> psnively: scene graph APIs are usually pretty imperative and representational (traversal-oriented).
14:57:08 <dons> Philippa: correct. haskell engine that can read Q3 descriptions and draw them
14:57:16 <psnively> conal: Seems like a good application for a ZIpper, no?
14:57:42 <vixey> frag is a one liner  main = putStrLn "Bus Error"
14:58:05 <dons> vixey: cabal install frag ?
14:58:09 <conal> psnively: if one wants to traverse a data structure, rather than work with meanings.
14:58:11 <vixey> yeah
14:58:18 <dons> kids these days, don't debug their own bugs.
14:58:34 <psnively> conal: You lost me (what a surprise).
14:58:51 <unenough> dons, Yi seems to depend on alex but cabal install yi doesn't know about it (it fails)
14:59:07 <dcoutts> unenough: cabal install alex
14:59:17 <conal> psnively: that's one of my gripes with scene graph APIs: they encourage programmers to think in terms of a *representation* (graph) rather than a meaning (geometry).
15:00:09 <unenough> dcoutts, i know... :}
15:00:12 <psnively> conal: Ah. Yes, I see that FieldTrip is different. Hmmm.
15:00:14 <conal> psnively: also, they usually impose a very stateful semantics -- modification of graphics state during traversal.
15:00:47 <psnively> Well, another reason why a Zipper sounds helpful to me. But I confess to having given the issues no more than about a day's thought.
15:00:54 <dcoutts> unenough: is alex not in your $PATH ?
15:01:14 <unenough> dcoutts, i was just saying that maybe cabal should know that automatically
15:01:44 <psnively> Eh, I have given http://www.hyperfun.org/F-rep.html a tiny bit of thought. But only a tiny bit.
15:01:46 <dcoutts> unenough: it's a known issue that build-tools are not tracked yet
15:01:47 <lambdabot> Title: F-rep Home Page. Shape Modeling and Computer Graphics with Real Functions
15:02:14 <unenough> ok
15:02:54 <psnively> conal: I'd love to develop a map editor using FRP and F-Rep. I just have no clue where to start. :-D
15:03:14 <unenough> Start in the beginning, and when you get to the end, stop.
15:03:31 <psnively> Heh.
15:03:48 <unenough> [Alice in wonderland]
15:04:22 <wchogg> conal:  Quick question about FieldTrip, actually.  Where are the dimensions of your rendering defined?  Things like udisk & sphere are "unit" sized, but how does that translate to the screen?
15:05:21 <conal> wchogg: not in any clearly defined way.  FieldTrip is very much work-in-progress.
15:05:39 <profmakx> can FieldTrip render projections of higher dimensional manifolds?
15:06:09 <wchogg> conal:  How "work in progress"?  Would you prefer if I didn't try to use it yet?
15:07:18 <conal> profmakx: i suspect it can.  the surface type is very simple/general: it's just R^2 -> R^3.  i expect you can make some useful higher-order functions to project your manifolds.  i'd love to the the result.
15:07:39 <conal> wchogg: no -- play all you want.  just a warning.
15:07:59 <profmakx> hm. i will try something out tomorrow
15:08:36 <psnively> It seems like making at least a stab at a 3D modeler should be easier than it is.
15:08:45 <conal> profmakx: s/the the/see the
15:08:51 <psnively> (Maybe because the domain is inherently complex? Ya think?)
15:09:10 <erikc> GUIs are hard
15:09:40 <psnively> I think the underlying data structures and algorithms are hard, in this case.
15:09:41 <Pseudonym> psnively: The thing is, all the good ones rely heavily on meta-information.
15:09:46 <profmakx> i also think 3d modelers should be stabbed *duq*
15:09:48 <psnively> Actually getting OpenGL to render stuff is pretty easy.
15:09:52 <Pseudonym> The data structures and algorithms are actually the easy bit.
15:09:59 <Pseudonym> In the sense that you can grab them off the shelf.
15:10:04 <FunctorSalad_> conal: it's based on manifolds? neat :)
15:10:11 <psnively> Pseudonym: A good point.
15:10:26 <FunctorSalad_> one could bring in all the machinery
15:10:42 <ddarius> It's also pretty hard to evaluate a 3D modeler usefully (or so I would think)
15:10:59 <Pseudonym> That's true.
15:11:10 <Pseudonym> Generally speaking, what people want is flexibility.
15:11:21 <Pseudonym> And that's VERY hard to evaluate.
15:11:45 <Pseudonym> I've been writing a 3D modeller in C++ for about 10 years now.
15:11:50 <vixey> what's wrong with blender? other than needing a 34 button mouse
15:11:58 <psnively> Yes. In fairness, I think of this in a specific context: wanting to write a portable replacement for UnrealEd. ;-)
15:12:06 <Pseudonym> vixey: Have you looked at the Blender code?
15:12:07 <FunctorSalad_> what does 'evaluating a 3d modeller' mean? rendering?
15:12:26 <vixey> no
15:12:27 <luqui> evaluating whether it is good or bad?
15:12:31 <FunctorSalad_> ah
15:16:20 <psnively> It does just seem like we should have a good 3D graphics kernel for exploring various modeling/rendering/animation approaches...
15:16:46 <profmakx> I think that is too general to be usefulk
15:16:48 <psnively> OTOH, maybe that's Inventor/OpenSceneGraph/something else I haven't found.
15:16:51 <psnively> Yeah.
15:16:54 <profmakx> one should first explore ideas
15:17:02 <vixey> something like flash 4 but for 3D
15:17:04 <profmakx> and then abstract from there i guess
15:17:05 <psnively> Right.
15:17:05 <vixey> oh that exists
15:17:49 <bltrout> Would someone be so kind as to help me with an HXT problem I'm having? http://hpaste.org/11929
15:18:43 <bltrout> In short, calling processFile transforms as I expect. processURL, however, does not. The content of the file and the data at url are the same.
15:18:44 <conal> psnively: as i mentioned, most scene graph libs (inventor etc) are heavily stateful.  my hope is that functional programmers would explore a functional style instead.
15:19:05 <psnively> conal: I agree completely. I just don't know quite what that looks like.
15:19:32 <profmakx> it would be most useful _not_ knowing the scenegraph approach ;)
15:19:32 <Pseudonym> conal: There's also the modeller written in Erlang.
15:19:44 <Pseudonym> Which is also inherently stateful.
15:19:56 <conal> profmakx: agreed.  it's a deep rut.
15:20:02 <Pseudonym> But node == thread in Erlang.
15:20:23 <Pseudonym> The thing is, I suspect that 3D modelling is inherently stateful, in the sense that you're modifying a database.
15:20:25 <psnively> So OK, we all grab our copies of Okasaki and meditate? :-D
15:20:31 <vixey> hehe
15:20:31 <psnively> ==Pseudonym
15:20:58 <psnively> All this talk of "But that's stateful!" to me misses the mark, kind of. Is a functional data structure with a Zipper "stateful" or not?
15:21:23 <FunctorSalad_> bltrout: maybe it's related to this dummy "/" root element hxt uses?
15:21:23 <Pseudonym> Computer graphics only really took off in mainstream film/whatever when graphics programmers realised that a collection of data is a database.
15:21:37 <Pseudonym> Not a relational database, of course, but a database nonetheless.
15:21:53 <psnively> Or could be a relational database, SQL notwithstanding. ;-)
15:21:56 <erikc> heh
15:21:58 <conal> i think of modeling as being programming with an unusual UI.  programming is generally a stateful activity, but the resulting programs needn't be.
15:22:01 <Pseudonym> psnively: Erm, no.
15:22:18 <Pseudonym> conal: Well, most high-end 3D modellers actually have a dataflow model internally.
15:22:40 <psnively> Pseudonym: of course it COULD be. It just HASN'T been.
15:22:52 <psnively> (Rightly or wrongly.)
15:22:53 <Pseudonym> You don't really modify, say, a 3D manifold.  Rather, you interpose operations into the pipeline.
15:22:53 <bltrout> FunctorSalad_: If that were the case would not parseFile return an empty result as well?
15:23:11 <conal> Pseudonym: yep.  there are other examples as well of modeling/authoring as being an ad hoc programming language & environment in disguise.
15:23:19 <Pseudonym> Yes.
15:23:23 <vixey> most of 3D modelling is mutating an object?
15:23:32 <vixey> ~~> stateful is a good approach
15:23:36 <Pseudonym> Famously, Pixar's MEnv is essentially a programming language environment.
15:23:36 <psnively> vixey: not necessarily.
15:23:37 <ksf> Coming back to denial of operational semantics in one's reasoning while keeping big-O, I've come to the conclusion that the best and most natural understanding arises by grokking swarm algorithms.
15:23:37 <bltrout> (Incidentally, this is only my second week seriously using Haskell so please forgive anything silly I might say.)
15:23:52 <ksf> s/keeping/keeping awareness of/
15:24:05 <FunctorSalad_> bltrout: mabe one of readDocument / getDocumentContents skips the root node and the other doesn't
15:24:12 <vixey> ksf, operational semantics is great
15:24:13 <vixey> :)
15:24:13 <roconnor> @hoogle (f a,f b) -> f (a,b)
15:24:14 <lambdabot> No results found
15:24:21 <FunctorSalad_> bltrout: just try printing out the name of the root node with both options :)
15:24:23 <ddarius> vixey: conal's point (if I'm not mistaken) is that analogously "most of programming is mutating a source file."  That doesn't mean your code needs to be imperative.
15:24:24 <roconnor> @hoogle f a -> f b -> f (a,b)
15:24:25 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
15:24:25 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
15:24:25 <lambdabot> Language.Haskell.TH strictType :: Q Strict -> TypeQ -> StrictTypeQ
15:24:46 <roconnor> hmm, zip
15:24:58 <conal> ddarius: yes, thx.
15:25:20 <bltrout> FunctorSalad_: How would I do that in and around arrows? I don't understand them yet... I'm just using them.
15:25:23 <conal> the mutation aspect has nothing to do with 3D.  it's just about modeling/authoring/programming
15:25:42 <psnively> vixey: At one point my wife studied 3D modeling and animation (hey, we're an LA couple). Imagine my surprise when she asked me to help her with her homework, and that help consisted primarily of demonstrating, with clay, the relationship among Boolean algebra, Set Theory, and 3D modeling.
15:26:24 <FunctorSalad_> bltrout: I think replacing "getAAWS" with "getName" at the bottom should work
15:26:45 <psnively> aka "
15:26:53 <psnively> Er, "Constructive Solid Geometry."
15:27:06 <FunctorSalad_> bltrout: the special/tricky thing with hxt arrows is that they generally "fan out" one thing to a list of things
15:27:52 <bltrout> FunctorSalad_: Replace at the bottom? I'm sorry, I'm not following.
15:28:06 <ksf> seriously, consider stuff like http://en.wikipedia.org/wiki/Ant_colony_optimization
15:28:07 <FunctorSalad_> bltrout: in processURL and processFile
15:28:08 <lambdabot> Title: Ant colony optimization - Wikipedia, the free encyclopedia
15:28:13 <bltrout> FunctorSalad_: HXT has been a real trip.
15:28:14 <vixey> psnively, oh there's loads of fun to be had in that area :)
15:28:23 <FunctorSalad_> bltrout: *nod*
15:28:34 <ksf> it perfectly maps to the brain, which runs fastest if not constrained but let loose.
15:28:51 <psnively> vixey: Indeed.
15:28:59 <ddarius> psnively: You should look at the F-Rep stuff more.
15:29:09 <Baughn> ksf: Sadly, the brain is a very inefficient system to emulate on a serial computer. :P
15:29:14 <psnively> So at least intuitively, even though I can't get very specific yet, I'm with conal: 3D modeling should be functional.
15:29:23 <bltrout> FunctorSalad_: Replacing getAAWS to getName returns "/" for both functions.
15:29:30 <psnively> ddarius: I will... but it's frustrating that there's such a paucity of code to learn from.
15:29:44 <erikc> i dont really get what you mean by functional
15:29:51 <ksf> well, computers are also very inefficent at emulating brains, so there you go.
15:29:52 <FunctorSalad_> bltrout: ok, then that shouldn't be the problem
15:30:43 <psnively> erikc: Presumably (handwave handwave), that composition of shapes and materials should be implemented by composition of functions. One can imagine a kind of "partial evaluator" for a model so composed that reduces it to some "normal form."
15:30:45 <Baughn> ksf: Only somewhat. A serial system may not be the best for emulating a parallel one, but just try it the other way around..
15:30:58 <FunctorSalad_> bltrout: hmm another difference is that you pass "a_validate" to readFile but not to parseXML
15:31:07 <erikc> ah, ok
15:31:09 <Pseudonym> psnively: I actually agree that 3D model generation is inherently functional.
15:31:10 <ksf> Baughn, you just have to analyse the data dependencies.
15:31:18 <Pseudonym> SOmetimes there are circular dependencies.
15:31:21 <Pseudonym> But yes.
15:31:28 <Baughn> ksf: And when it turns out your algorithm is inherently serial?
15:31:31 <psnively> Yes. So laziness might be key. :-)
15:31:32 <Pseudonym> The problem is that modifying that function efficiently is hard.
15:31:32 <bltrout> FunctorSalad_: Oh, indeed.
15:31:34 <ksf> that's a deadlock.
15:31:46 <Baughn> ksf: That problem is insanely hard. If it wasn't, parallelizing compilers would be easy. ;)
15:31:47 <FunctorSalad_> bltrout: (I meant "readDocument" not "readFile")
15:31:57 <Baughn> ksf: (For "frequently impossible" values of "hard")
15:32:02 <Pseudonym> So the model that you usually use is like a spreadsheet.
15:32:07 <Pseudonym> Spreadsheets are inherently functional, too.
15:32:18 <psnively> Mmmmmmm... dataflow. FRP!
15:32:22 <Pseudonym> But you want to save as much recomputation as you can.
15:32:24 <psnively> And now the circle is complete.
15:32:29 <erikc> heh
15:32:29 <ksf> nah it's rather the decisions (or just a good heuristic) of granularity and optimality that's hard.
15:32:39 <Pseudonym> And also, you want efficient ways to modify the system.
15:32:43 <bltrout> FunctorSalad_: Changing from [] to  [(a_validate,v_0)] in processURL still returns [].
15:32:48 <psnively> Mmmmmmm. Zippers! Maximal sharing!
15:32:49 <ksf> the brain is self-optimizing in that regard.
15:32:53 <psnively> Gotta run.
15:33:12 <Pseudonym> Fare well./
15:33:19 <Pseudonym> Zippers are nice, but they're hard to make concurrent.
15:33:38 <ksf> ...as are swarm algorithms. that's the point for their existence.
15:33:58 <ksf> they don't give you any proof, but darn good results in quite acceptable time.
15:33:59 <Baughn> The brain is good at avoiding the problem. It still can't do many serial algorithms well (like proof verification), and it uses something like a million times the neurons it should for motor control just because it has to avoid loops...
15:34:03 <Daniel_H> Pseudonym They're good for going for a pee when you can't be bother to pull your pants down.
15:34:10 <Pseudonym> I'm not trying to be a naysayer, BTW.  I've spent an obscene amount of time thinking about this.
15:34:45 <Pseudonym> If the geometry database is read-only, such as in a raytracer, then a functional style is almost ideal.
15:34:48 <Baughn> Or rather, avoid any algorithms that would need a request/response to be routed through more than a couple dozen neurons at most before going back out
15:34:50 <ksf> Baughn, yes, but then I don't plan to obey my computer, but have my computer obey me.
15:34:58 <vixey> Baughn, what do you mean proof verification?
15:35:05 <ksf> so he gotta learn to think more like me, not the other way round.
15:35:07 <Pseudonym> If it can be modified, I can't see a neat way around local mutable state.
15:35:09 <vixey> Baughn, like type checking ..?
15:35:22 <Baughn> vixey: Just a random example. Anything that can't easily be done in parallel, the brain is bad at..
15:35:36 <vixey> oh interesting
15:35:43 <ksf> forall practical purposes, fitness equals proof.
15:35:56 <Baughn> Running a couple trillion neurons at 200Hz each will do that
15:35:58 <FunctorSalad_> bltrout: a workaround would be to download the file seperately (say, with the 'download' package) and pass the string to readString
15:35:58 <telexicon> is that why we own at pattern recognition?
15:36:23 <Baughn> telexicon: A similarly powerful serial computer would do that too. No, that's just insane computing power on a problem that /is/ easily parallelizable
15:36:37 <FunctorSalad_> bltrout: does the program say whether it was able to download the url?
15:36:52 <telexicon> Baughn, what else could we use brains for?
15:36:58 <bltrout> FunctorSalad_: It does not say it isn't.
15:37:18 <FunctorSalad_> bltrout: maybe "(a_trace, 4)" or so would say
15:37:20 <ksf> Baughn, I can tell you for sure that the meaning of life isn't looking for one.
15:37:34 <Baughn> ksf: I didn't mean to bring in proofs like that. My point is, the brain's algorithms are often highly suboptimal in a computer - there are often much better algorithms when you *can* do things in serial
15:38:02 <Baughn> Emulating nature only goes so far
15:39:05 <Baughn> vixey: N processors at M Hz each can usually run an algorithm meant for N*2 processors at M/2 Hz pretty easily. The reverse is, of course, not true
15:39:12 <bltrout> FunctorSalad_: No more output than before.
15:39:14 <ksf> well a computer modelled after the brain doesn't subconsciously worry about the floor collapsing while solving a problem.
15:39:30 <ksf> iff the model's good, that is.
15:39:38 <ksf> see marvin.
15:39:55 <Baughn> Marvin. An excellent example of emulating humanity too well. ^^;
15:40:44 <rherrmann> ksf: "all models are wrong, but some are useful" -- George Box
15:41:35 <rherrmann> ksf: as for collapsing datacenter floors, maybe
15:41:45 <FunctorSalad_> bltrout: :( can't think of any more reasons at the moment
15:41:53 <ksf> goal-awareness and finding an optimal solution seem to be mutually-exclusive for these kind of algorithms. too much thick-headedness.
15:42:35 <ksf> rherrmann, we just need to provide the machines with backup tapes to make them stop worrying about it ;)
15:42:43 <luqui> how do I resolve this: cabal: cannot configure HUnit-1.2.0.2. It requires base ==4.*
15:43:07 <dcoutts> luqui: cabal update and use the next release of hunit
15:43:08 <dons> luqui: cabal update, iirc
15:43:11 <bltrout> FunctorSalad_: Well, thank you for your help. I still learned a bit. :)
15:43:19 <ksf> in the ant example, that corresponds to lacking evaporation of traces.
15:43:25 <luqui> dcoutts, ok thanks :-)
15:43:31 <luqui> yay!
15:44:00 <ksf> it also effectively prohibits adaption.
15:44:19 <FunctorSalad_> bltrout: you could use this function to download the file explicitly http://hackage.haskell.org/packages/archive/curl/1.3.3/doc/html/Network-Curl.html#v%3AcurlGetString
15:44:21 <lambdabot> Title: Network.Curl, http://tinyurl.com/63l4po
15:44:37 <FunctorSalad_> bltrout: the curl package should already be installed since it's a dependency of hxt
15:44:57 <bltrout> FunctorSalad_: Thanks.
16:08:31 <joey``> What does the syntax 'Module A (module B, etc... ) where' mean with regard to exports?
16:09:30 <joey``> Does it mean module A essentially exports everything that module B exports as well?
16:09:37 <Cale> joey``: yes, exactly
16:09:41 <joey``> Cale: Thanks.
16:10:40 <hackage> Uploaded to hackage: phonetic-code 0.1
16:10:44 <joey``> Cale: So a statement like "module A (module A, foo, bar) where" is pretty redundant?
16:11:00 <joey``> As in, you could omit the module A export
16:11:52 <Stephan202> joey``: yes
16:12:59 <joey``> Stephan202: Thankyou.
16:15:28 <int-e> joey``: Note that 'module B' only exports the functions that were imported unqualified.  For example, if you have  import Prelude as B (error)  and  import qualified Prelude as B  then  module A (module B) where ...  will export 'error', and nothing else.
16:23:48 * shapr boings
16:23:50 <shapr> yow!
16:24:05 <sbahra> yow
16:24:11 <Pseudonym> Hello to you, too.
16:24:47 <shapr> Ah the learnings I am learning!
16:25:07 <Pseudonym> What learnings are you learning?
16:25:08 <bode> yow
16:26:30 <jberryman> is there or would it be possible to represent infinity in haskell, so that one could compare a (Num a) to infinity, or do: take infity ls, etc.? I guess you would make a new typeclass that encomassed the Num class?
16:26:36 <roconnor> maybe I'll have to download 6.10 so I can "fix" FieldTrip.  ... I have strong opinions. :)
16:26:39 <dons> jberryman: yes.
16:26:43 <Cale> jberryman: yes, as a Nat
16:26:53 <Cale> data Nat = Zero | Succ Nat
16:27:00 <Cale> infinity = Succ infinity
16:27:35 <Cale> take Zero xs = []
16:27:38 <roconnor> I saw a recent lib with an efficent definition of Nat
16:27:46 <Cale> take (Succ n) [] = []
16:27:47 <roconnor> Can compute min x Infinity
16:28:01 <Cale> take (Succ n) (x:xs) = take n xs
16:28:19 <Cale> roconnor: 'fix'?
16:28:50 <roconnor> Cale: remove the x, y, z and orgin biases.
16:29:03 <roconnor> Cale: I tend to fix things by removing functionality. :)
16:29:16 <ddarius> roconnor: Functionality is where the bugs are.
16:29:27 <roconnor> exactly. ddarius understands
16:30:24 <Cale> Well, isn't it already capable of handling arbitrary bases? Or do you want to do projective geometry?
16:31:18 <roconnor> Cale: example, scaling takes three parameters. for scaling along the x y and z axis fixing the origin.
16:31:40 <roconnor> but why are x y and z so special.  why is the origin special?
16:31:43 <roconnor> they aren't
16:31:59 <roconnor> they shouldn't be implicity used
16:32:19 <Cale> Aren't they sort of a convenient default though?
16:32:38 <roconnor> instead scale should take a point (the fixed point) and a vector (direction and amount to scale with respect to).
16:32:42 <Cale> I agree that generalising is good, but you probably want something which *does* work in the standard coordinate system too.
16:32:55 <Cale> (just for convenience)
16:33:00 <roconnor> the user should be ignorat of the standard coordinate system
16:33:03 <Cale> Oh, yes, I agree, that operation ought to exist.
16:33:03 <roconnor> ignorant
16:33:27 <Cale> But I'm not sure that abandoning standard coordinates altogether is a good idea, for practical work.
16:33:34 <roconnor> sure it is
16:33:38 <roconnor> removes bugs
16:33:45 <Cale> hmm
16:33:52 <roconnor> students are always scaling thier figures and they go flying off the screen
16:33:58 <roconnor> and they are like " where is my figures"
16:34:04 <Cale> hehe
16:34:13 <roconnor> but if they were force to pass an fixed point in always
16:34:20 <roconnor> they would pass in the centre of their figure
16:34:23 <roconnor> and they would be happy
16:34:29 <roconnor> and wouldn't whine to the TA.
16:34:34 * roconnor grumbles
16:34:35 <ben_h> mm
16:34:51 <ben_h> it's like looking at a partially standing wave
16:35:03 <ben_h> scaling from outside the body implies movement to people.
16:35:08 <ben_h> but not to the machine
16:35:56 <roconnor> same with rotations.
16:36:03 <ben_h> yeah
16:36:53 <roconnor> I'd specify a fixed point and a vector that gives the rotation axis and whose length is the rotation amount.
16:37:06 <ben_h> that's tidy
16:37:17 <ben_h> length of 1 unit == 1 full rotation?
16:37:28 <Cale> Having a quaternion representation of orientations available would be good too.
16:37:29 <roconnor> oh I wold have used radians
16:37:33 <roconnor> bu that is an even better idea
16:37:56 * ddarius pukes on "axial vectors"
16:38:03 <jberryman> Cale: thanks once again. so any function that might want to deal with infinity would have to be designed with the Nat type in mind? it would be cool if there were a special type in the Num class for infinity, but maybe that mkaes no sense
16:38:03 <roconnor> Technically an oriented line and a rotation amount would be better. But that requires you to have a line datatype
16:38:09 <roconnor> both functions woudl be good.
16:38:22 <ben_h> yeah
16:38:36 <ben_h> a more precise one and a more accessible one that can take just an int
16:38:39 <ben_h> or rather a float
16:39:04 <roconnor> actually fieldtrips rotate function seems to do this correctly.
16:39:25 <roconnor> oh no it doesn't
16:39:33 <roconnor> only rotates about the origin.
16:40:19 <ddarius> Crap.  Now I want to fix it too.
16:40:20 <Cale> I think quaternions are actually my favourite representation, since they compose so nicely.
16:40:35 * ddarius uses bivectors.
16:40:59 <roconnor> ddarius: yes, bivetors would be better for rotations
16:41:10 <ddarius> (well exponents thereof, which works out to quaternions in 3D but also works in other dimensions unchanged)
16:41:24 <roconnor> ddarius: fieldtrip has normal3 for normal vectors
16:41:28 <roconnor> we might be able to use that
16:41:32 <whampyre> what is best book for a beginner that knows no programming?
16:41:41 <whampyre> and is web programming fun in haskell?
16:42:01 <roconnor> both rotation vectors and normal vectors transform covariently (contravariently?)
16:42:05 <Twey_> whampyre: Any good at maths?
16:42:52 <roconnor> ddarius: do you have ghc 6.10 installed?
16:42:56 <ddarius> roconnor: No
16:43:01 <roconnor> damn
16:44:51 <IsoPallo_> Hmh. Is there some beginner friendly introduction to LogicT or some other library that lets me do a little logic programming inside haskell?
16:45:13 <Cale> whampyre: Web programming could be fun in Haskell, but it's perhaps not as fun as it could be yet.
16:45:25 <Cale> whampyre: But people are working on making it more fun.
16:45:53 * ddarius doesn't associate "web programming" and "fun" regardless of language.
16:45:54 <Cale> whampyre: Graham Hutton's book on Haskell is good. I'm not sure how it would be for a *complete* beginner...
16:46:11 <rherrmann> ddarius: agreed
16:46:17 <Cale> whampyre: There's also a nice tutorial written by BONUS here, called "Learn You A Haskell"
16:46:39 <Cale> ddarius: Well, I agree with you there... web "standards" are so backwards and horrible.
16:46:47 <Cale> @where LYAH
16:46:48 <lambdabot> www.learnyouahaskell.com
16:46:53 <ben_h> <3 that site
16:47:20 <ben_h> also this is excellent: http://book.realworldhaskell.org/
16:47:21 <lambdabot> Title: Real World Haskell
16:47:49 <ksf> @where real
16:47:49 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
16:47:58 <Twey> Hahaha
16:48:02 <Twey> Nice
16:48:08 <sbahra> Lice
16:48:25 <Nafai> Awesome
16:48:56 <rherrmann> lol, should we reddit as such ?
16:49:08 * Twey chuckles.
16:49:13 <int-e> all dons' fault
16:49:44 <rherrmann> I'll post it there with this title
16:53:26 <rherrmann> http://www.reddit.com/r/programming/comments/7ckm7/the_comprehensive_xmonad_configuration_syntax/
17:01:45 <whampyre> anyone do a reddit liek site in haskell yet?
17:02:08 <ksf> If you feel like it, I'd like a browser.
17:02:37 <ben_h> i want a pony
17:02:46 <ben_h> in haskell
17:03:12 <ksf> Nah, curry doesn't go well with ponys.
17:03:19 <ben_h> lol
17:03:20 <Pseudonym> In Haskell, every type is inhabited.
17:03:33 <Pseudonym> So while it may be an undefined Pony, it's still a Pony.
17:03:42 <ben_h> like a convent
17:04:17 <dons> rherrmann: hmm?
17:05:09 <rherrmann> dons: viral marketing we could use ;-)
17:05:30 <rherrmann> (10:47:40 PM) lambdabot: http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
17:05:32 <lambdabot> Title: Real World Haskell
17:05:57 <dons> hehe
17:06:38 <rherrmann> spj wouldn't approve it though
17:07:18 <jsn> i think haskell is going to do alright
17:07:45 <jsn> it may never be any bigger than ruby, but that's big enough
17:09:36 <dons> its already bigger than #ruby :)
17:09:42 <ben_h> lol
17:09:49 <pumpkin_> is there a computer science (as in theory) channel anywhere?
17:10:02 <Pseudonym> pumpkin_: Yes, here.
17:10:18 <pumpkin_> hah, I always feel bad for asking general CS questions in here
17:10:30 <Pseudonym> Some stuff is considered on-topic on #math, depending on how theoretical it is.
17:10:34 <dons> ruby-lang, 305. haskell, 483.
17:10:36 <Pseudonym> But really, you can probably ask here.
17:11:36 <jsn> i guess haskell programs are just a lot less visible than ruby programs
17:11:45 <jsn> since ruby programs are usually web apps :)
17:12:09 <dons> slow web apps.
17:12:19 <pumpkin_> mmm speed is overrated
17:12:28 <dons> unless you're twitter.
17:12:38 <jsn> dons: if they are written at all well, they are database bound webapps
17:12:49 <ddarius> My impression, from very little information, is that it was ruby on rails that is/was really popular.
17:13:04 <jsn> dons: you know twitter's mistake was using a database, right?
17:13:04 <dons> i guess being the slowest thing ever is ok then, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
17:13:06 <ddarius> Of course, now every language has its rails-alike so...
17:13:25 <dons> jsn: yeah. you can't turn a cms into a telephony switch without changing the architecture
17:13:38 <wjt> Anyone familiar with (the bindings to) Cairo?  I'm trying to figure out how to render an image just once, and then turn it into an Image widget, but can't find any way to construct Render () -> IO Image
17:13:39 <jsn> dons: they had trouble scaling because rails doesn't like to deal with mutliple databases
17:13:49 <jsn> dons: but using and RDBMS was just dumb
17:13:51 <ben_h> dons: to be fair, 1.9 will smoke that
17:13:55 <jsn> s/and/an/
17:13:57 <ben_h> s/will/does
17:14:02 <dons> ben_h: will it catch python?
17:14:11 <jsn> ddarius: it's pretty hard to do what rails does
17:14:14 <ben_h> dons: in the benchmarks i've done it beats python
17:14:19 <erikc> jsn: what would the alternative to a dbms be for that?
17:14:30 <dons> so only 60x slower than haskell, instead of 100x? ;)
17:14:42 <ben_h> :)
17:15:11 <jsn> erikc: LDAP could work
17:15:13 <ksf> erikc, Data.Map
17:15:23 <jsn> ksf: does not scale
17:15:34 <ksf> depends on implementation.
17:15:35 <jsn> you can't use pure datastructures in a cluster
17:15:50 <jsn> erikc: they could also have used jabber
17:15:54 <erikc> ah, k, not too familiar with LDAP
17:16:05 <jsn> and just kept lots of logs and channels up
17:16:10 <erikc> heh
17:16:10 <Pseudonym> If by "what rails does", you mean making programming look easier than it is, then yes, it's hard to do that.
17:16:18 <jsn> scaling would have been really easy in that
17:16:21 <erikc> i find it hard to believe that an rdbms would fail and jabber would be ok
17:16:39 <jsn> erikc: why?
17:16:57 <ben_h> dons: this is pretty synthetic, but still interesting: http://antoniocangiano.com/2007/11/28/holy-shmoly-ruby-19-smokes-python-away/
17:17:01 <erikc> cause rdbms are ridiculously scalable
17:17:12 <Pseudonym> erikc: They are not.
17:17:16 <jsn> erikc: no, RDBMS are definitely not scalable
17:17:18 <wjt> ben_h: you didn't see dons' response to that post?
17:17:31 <ben_h> wjt: ? no
17:17:36 <wjt> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/29#smoking
17:17:37 <Pseudonym> RDBMSs are often partitionable.
17:17:37 <lambdabot> Title: Haskell hacking
17:17:38 <jsn> erikc: it's very difficult to make relations work across more than one machine
17:17:44 <ben_h> wjt: cheers
17:17:51 <Pseudonym> But it depends on the application.
17:17:54 <loop_> ben_h: heh, calculating fibonacci numbers doesn't seem like a real world benchmark :p
17:18:05 <jsn> Pseudonym: which is the same thing as saying, you can turn them into key-value stores if you need to
17:18:08 <ben_h> loop_: yeah i agree it's very synthetic
17:18:13 <erikc> ah
17:18:23 <ben_h> but it's still useful imo. shows the scale of some of the internal speedups
17:18:26 <jsn> Pseudonym: in other words, you have to dump the "relational" part
17:18:47 <ben_h> wjt: yeah i realise haskell is still a lot faster, my point was just that ruby has made great strides of late.
17:19:08 <Pseudonym> jsn: Yes and no.
17:19:11 <ddarius> Advertising geniuses, them.
17:19:23 <wjt> ben_h: it was just pretty funny that you pointed out to dons a post that he wrote a response to :)
17:19:25 <Pseudonym> In the sense that some normal forms for relational schemas are essentially key-value stores.
17:19:26 <jsn> Pseudonym: if you want to scale a table horizontally, yes
17:19:30 <ben_h> wjt: :)
17:19:41 <ben_h> wjt: dons: those numbers in your post are pretty striking dons
17:19:51 <Pseudonym> Well, key-value-foreign key.
17:19:55 <dons> native code ftw.
17:20:05 <jsn> Pseudonym: you can't actually run those queries, though
17:20:23 <Pseudonym> But by "partitionable", I mean things like... if you have multiple physical locations, the data is often partitioned by location.
17:20:29 <Pseudonym> e.g. a university with multiple campuses
17:20:30 <jsn> sure
17:20:51 <dons> it mean really, there's no contest here. one is a high level language with an optimising native code compiler, python and ruby are bytecode interpreters. there's going to be a couple of magnitudes difference there, before we even get going.
17:21:22 <loop_> ruby 1.8.5 doesn't even have bytecode.. :)
17:21:52 <jsn> but you need a bunch of stuff on top of that to actually run cross cluster queries
17:22:08 <dons> loop_: so its an AST evaluator?
17:22:13 <Pseudonym> dons: Yes and no.
17:22:23 <jsn> run meaningful joins requires you to ship indices all across the cluster, too
17:22:41 <Pseudonym> If you spend most of your time in library calls, it doesn't matter so much if you're bytecode interpreted.
17:22:45 <loop_> dons: yeah
17:23:33 <jsn> erikc: i think my point is, transactions and JOINs are not the shortest path to a multicast messaging application
17:23:43 <jsn> erikc: and that was the problem that twitter had
17:23:50 <jsn> erikc: it wasn't ruby being slow :)
17:23:56 <pumpkin_> we should make a new twitter called hatter
17:24:41 <ben_h> dons: i did some experimentation calculating right triangles with list comprehensions and then wrote a similar method in c and ruby. the haskell ruby difference was about the same as what you got
17:24:43 <roconnor> ddarius: how would you specify reflections?
17:26:46 <jsn> ruby's real value to programmers is "the convenience of perl with less mess"
17:27:01 <erikc> or, a smalltalk with acceptable syntax
17:27:21 <jsn> whereas as haskell's is "the cleanliness of some language you've never even seen with acceptable convenience"
17:27:37 <jsn> "more cleanly than you could possibly imagine!"
17:28:33 <gwern> more clean than Clean?
17:28:46 <dmwit> Can you imagine how clean Clean is?
17:29:08 <gwern> obviously it was not clean enough for us haskellers
17:29:09 <jsn> i learned sed and sh really well after i got into haskell because there was kind of a hole there that i don't think haskell can really fill
17:29:15 <erikc> the haskell implementation of my memory trace analyzer is 100x faster than my ruby implementation, less code too
17:29:33 <ddarius> roconnor: It's just the versor product of a (normal) vector, that vector being the normal of the plane of the "mirror".
17:29:49 <roconnor> ddarius: what does the magnitude mean?
17:29:59 <roconnor> oh right
17:30:01 <roconnor> normal vector
17:30:21 <Philonous> What appears to be the problem when GHC gives me a "Failed to load interface for `System.Glib.UTFString'" ?
17:30:21 <gwern> jsn: I disagree. haskell just needs a good library to do sed and sh stuff far cleaner than they can
17:30:36 <gwern> a bad installation of gtk2hs?
17:30:46 <jsn> gwern: it needs that, and quasi-quotation, which it finally has
17:30:52 <Philonous> Actually I'm trying to compile gtk2hs
17:30:55 <jsn> gwern: i don't doubt that it can do it
17:31:02 <ddarius> roconnor: Actually, for an unnormalized vector, the magnitude should cancel out when doing the versor product.
17:31:07 <ben_h> gwern: i thought glib and gtk were different libs?
17:31:11 <roconnor> ddarius: yep
17:31:24 <roconnor> ddarius: should anisotropic scales take a bivector or a vecotor, or shoudl there be versions taking both?
17:31:33 <gwern> ben_h: all I know is that every time I compile gtk2hs, compilation fails on the glib modules :)
17:31:33 <askentasken> could JAVA have optional typedelcarations and still be static?
17:31:44 <ben_h> gwern: ah :)
17:32:07 <askentasken> or is a static typesystem with optional  declarations only possible in a functional langauge?
17:32:08 <gwern> jsn: if you're doing anything more complicated than aliases, haskell is pure win over sh. seriously, sh is a truly terrible language in many ways
17:32:19 <askentasken> sh == shell?
17:32:22 <ben_h> askentasken: it's possible in other languages.
17:32:24 <jsn> gwern: well, hold on
17:32:31 <gwern> jsn: HSH, for example, makes my scripts vastly cleaner than a sh equivalent
17:32:38 <jsn> gwern: eh
17:32:48 <ben_h> askentasken: not in Java without haxing the JVM hardcore though, i would say.
17:33:14 <snk_kid> done
17:33:16 <snk_kid> http://monadickid.blogspot.com/
17:33:17 <lambdabot> Title: ∃planet ∈U Life∃(planet)
17:33:18 <jsn> gwern: i can agree with you that, with extensions, haskell can be an excellent scripting language
17:33:22 <ddarius> roconnor: Anisotropic scaling doesn't map to a nice GA operation.  It's best represented as a linear transformation.
17:33:26 <askentasken> OK so what are the conditions that must be met to make it possible?
17:33:34 <snk_kid> whoops wrong link
17:33:44 <snk_kid> http://monadickid.blogspot.com/2008/11/haskell-eye-for-windows-guy.html
17:33:54 <roconnor> ddarius: GA operations preserve the inner product?
17:34:05 <gwern> jsn: now, I'm unsure Data.List, say, is a full replacement for sed, but that's largely because I'm unsure of the full scope of sed - I never really learned it beyond the most simple replacement stuff
17:34:38 <loop_> sed is turing-complete :)
17:34:41 <ddarius> roconnor: Isotropic scaling (i.e. multiplying by a constant) doesn't preserve inner products (unless you meant up to scaling)
17:34:53 <roconnor> I guess I mean upto scaling
17:35:19 <jsn> gwern: if we exclude file reading and writing, sed basically is a parser with a little stack you can push lines on to to use as an alternate input source
17:35:30 <roconnor> strange that uniform scaling in 3d had det -1, but in 2d all the operations have positive determinant.
17:35:35 <jsn> (the "hold" buffer, which few people learn)
17:36:44 <jsn> this is straightforward to model in haskell, of course -- and can be treated as pure, even
17:37:22 <gwern> would the stack be done by a state monad? or is it a purely functional data structure?
17:37:30 <jsn> state monad
17:37:33 <jsn> yeah
17:37:55 <jsn> each operation in sed receives the output of a prior operation
17:38:14 <jsn> you can imagine that newline in sed is the same thing as '|' in the shell
17:39:05 <ddarius> roconnor: Personally, I'd represent anisotropic scaling as a linear transformation created from <dimension> numbers.  I would not use a vector, and definitely not a bivector, for it.
17:39:26 <jsn> so    /^foo/ ! d  ;   s/$/ bar/'    reads, delete all lines that have begin not with 'foo', then for all these lines, replace the end with ' bar'
17:39:42 <roconnor> ddarius: nah, you wouldn't do that.  You want it to be coordinate independent.
17:39:55 <jsn> sorry, extraneous quote
17:40:09 <jsn>  /^foo/ ! d  ;  s/$/ bar/
17:41:02 <thedward> ls
17:41:09 <jsn> now try to write a sed script that finds lines with 'quit' anywhere in them, and replaces them with with 'exit'
17:41:16 <ddarius> roconnor: Using a vector in this instance doesn't make things any less coordinate independent, unless you are using it in a clever way that I'm not thinking of.
17:41:26 <roconnor> ddarius: I think I'd use both, but I'd scale by the reciprocol of the magnitude of the bivector.
17:41:42 <jsn> gwern: the shell is a terrible language in many ways
17:41:51 <gwern> and yet, we're stuck with it
17:41:54 <ddarius> roconnor: Really, you want the user to provide the linear transformation.  The linear transformation itself isn't coordinate dependent.
17:41:57 <jsn> gwern: but it makes certain things really convenient
17:42:08 <roconnor> ddarius: possibly. rotate until the vector is pointing along the x axis, scale on the x axis, rotate back.
17:42:42 <jsn> gwern: one of the best things about it is its brevity, because it makes it easy to use interactively
17:42:49 <roconnor> ddarius: the artist doesn't want to give arbitrary linear transformation.  They want to use a specific set of transformations they understand.
17:42:58 <jsn> gwern: i don't think HSH is an acceptable substitute, in consequence
17:43:16 <ddarius> roconnor: I understand that you wouldn't want to have to give a linear transformation in this case.
17:43:59 * jsn turns his mind to the evils of piping between processes
17:44:03 <ddarius> roconnor: (Though I'd say most artists would be quite happy with a coordinate dependent anisotropic scale.  Just let them also be able to choose and change the basis vectors.)
17:44:37 <ddarius> (Actually, if they can arbitrarily change the basis vectors, there's no need for an anisotropic scale, albeit this is just dressing a linear transformation up differently.)
17:44:45 <roconnor> right
17:45:40 <ddarius> roconnor: I'm considering if what's needed might not be a point instead of a vector.
17:46:35 <roconnor> of course, there is also a separte point parameter given the fixed point of the scale, but I assume we both got that.
17:46:38 <ksf> Cale, do you have a zombie mueval on your box?
17:47:24 <mmorrow> oh, speaking of that, i think i might know why the zombies are happening and possibly how to reap them
17:47:38 <ddarius> roconnor: So pass in two points, the origin and the (1,1,1) point  (... )
17:48:07 <gwern> jsn: well, HSH can be short! it has a number of simple reimplementations and operators, so you get lines like 'cat "foo.txt" -|- grep '5' -|- tee "bar.txt" -|- uniq -|- redirect "foobish.txt"' (I write from memory, I forget how you would actually pipe the result to a file in HSH)
17:48:09 <snk_kid> dons: are you there?
17:48:17 <gwern> mmorrow: go on
17:48:28 <mmorrow> so lambdabot's eval uses forkProcess from System.Posix.Process, and i was coding this up using that the other day and getting zombies: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=445
17:49:00 <mmorrow> so how you collect them is you have to call getProcessStatus in them
17:49:01 <roconnor> ddarius: the term (1,1,1) is not coordinate independent
17:49:16 <mmorrow> which is 'waitpid' under the covers
17:49:17 * ksf typed last [1..] and didn't see a <thread killed> on #xmonad
17:49:24 <roconnor> anyhow, I've convinced myself that a vector is the right specification
17:49:32 <gwern> mmorrow: hm
17:49:45 <roconnor> actually
17:49:52 <roconnor> maybe I just unconvinced myself
17:49:53 <gwern> and lb is not using getProcessStatus?
17:50:17 <dons> snk_kid: always.
17:50:30 <roconnor> we need a unit vector and a magnitude.
17:50:37 <mmorrow> gwern: i'm not sure if lb is, but working through the zombies with that "sandbox" code made me think of lambdabot and mueval
17:50:42 <Cale> ksf: On whose box?
17:50:45 <mmorrow> getProcessStatus :: Bool -> Bool -> System.Posix.Types.ProcessID -> IO (Maybe ProcessStatus)
17:50:47 <snk_kid> dons: okay so remember about the lack of info for windows users?
17:50:50 <ddarius> roconnor: Using points doesn't seem too unreasonable.  What this operation does is define the notion of "distance" and distance is a relation between points.
17:50:51 <Cale> ksf: Mine? No, I don't have mueval installed.
17:51:08 <Cale> ksf: I might have a zombie mueval on lispy's box.
17:51:13 <mmorrow> i'm not sure what the second Bool is for, but the first is whether or not you want to block waiting for the proc to exit
17:51:21 <Saizan_> mmorrow: but Plugin.Eval uses popen, which uses runInteractiveProcess and waitForProcess
17:51:23 <gwern> Cale: oh, it's not on your box anymore
17:51:23 <roconnor> ddarius: a unit bivector and a magnitude
17:51:25 <gwern> huh
17:51:41 <mmorrow> Saizan_: hmm, i coulda sworn i saw forkProcess somewhere
17:51:46 * mmorrow looks
17:51:47 <Cale> gwern: lambdabot never ran on my box, except as mbot.
17:51:47 <dons> snk_kid: yes.
17:51:55 <jeffz> snk_kid: fyi http://ghcmutterings.wordpress.com/2008/11/10/bootstrapping-cabal-install/
17:51:58 <lambdabot> Title: Bootstrapping cabal-install « GHC Mutterings
17:52:00 <ddarius> roconnor: Really, what you'd need to do if you want this to be natural and coordinate free is specify three vectors (for 3D) again coming back to a linear transformation.
17:52:04 <gwern> zomg my entire life was built on a lie
17:52:55 <ddarius> roconnor: The only reason anisotropic scaling is efficient is because we favor a certain basis.  If you don't, then a linear transformation is what you're going to get.
17:53:08 <snk_kid> dons: well other that what jeffz just posted i just wrote this http://monadickid.blogspot.com/2008/11/haskell-eye-for-windows-guy.html
17:53:23 <cads> jsn: gah! how _do_ I make sed replace each instance of quit?
17:53:48 <sw17ch> cads: something with a -I and a bunch of {}'s
17:54:37 <snk_kid> jeffz: well i show a bit more than that
17:54:49 <mmorrow> Saizan_, gwern: huh. no calls to forkProcess in lambdabot. maybe i saw forkProcess in plugins..
17:54:50 <roconnor> ddarius: huh, anisotropic scaling isn't efficient, it is simple.
17:55:13 <dons> snk_kid: awesome.
17:55:17 <gwern> mmorrow: I think the issue may be 'popen'
17:55:29 <jeffz> snk_kid: yeah, it's a little easier to read with a white background and it also mentions that the haskell platform should make things easier, which will be cool.
17:55:37 <gwern> mmorrow: which comes from lambdabot-utils, and is imported by the TH expressions each Plugin gets
17:55:37 <ddarius> roconnor: Here's the heart of the matter: how do you simply and naturally specify an orthogonal basis?
17:55:43 <gwern> see Lambdabot.Process
17:56:05 <mmorrow> gwern: hmm, ok. looking..
17:56:07 <dons> snk_kid: http://www.reddit.com/r/haskell/comments/7cky0/how_to_build_and_run_frag_on_windows/
17:56:08 <gwern> popen does use rnInteractiveProcess
17:56:23 <jeffz> heh, I feel like Bill Murray in Ground Hog Day, the number of times I've installed cabal-install by hand.
17:56:23 <jsn> cads:     sed -r 's/quit/exit/g'
17:56:39 <roconnor> ddarius: when doing an anisotropic transformation with two eigenvalues equal to 1, you only need to specify one element of the basis.
17:56:50 <jsn> cads:     sed -r '/quit/  ;  s//exit/g'
17:56:57 <ddarius> roconnor: Indeed.
17:57:19 <snk_kid> jeffz: i will make an edit and refer to that blog entry too
17:57:20 <dons> jeffz: no distro support?
17:57:21 <roconnor> the only question is, should this basis be specified by a vector, or a bivector?
17:57:21 <jsn> oh wait, that's silly
17:57:45 <jeffz> dons, on windows and while testing things in Wine.
17:58:06 <ddarius> roconnor: In my opinion, the question is becoming: is anisotropic scaling a convenient operation.
17:58:17 <roconnor> ddarius: I'm leaning towards a bivector because what you are really specifying is a fixed plane, and a magnitued.
17:58:46 <roconnor> ddarius: yes it is a convenient operation
17:58:49 <jsn> useful for something like     svn st | sed -r '/^\?[[:space:]]+/  ;  s//svn add /' | sh
17:59:06 * ksf blissfully remembers himself typing "emerge cabal-install"
17:59:26 <SamB> ksf: did it WORK ?
17:59:33 <dons> jeffz: so we need .exe's.
17:59:33 <ksf> flawlessly.
17:59:41 <jsn> dons: yes
17:59:56 <jsn> how do we do that in a trustworthy way?
18:00:00 <Saizan_> jeffz: http://haskell.org/~duncan/cabal/cabal.exe
18:00:04 * gwern blissfully types 'cabal upgrade cabal-install'
18:00:07 <dons> jsn: post our own signed exes?
18:00:11 <ksf> I'm merely using cabal-install over portage because of hackage.
18:00:11 <SamB> host them on dons' website
18:00:12 <dons> as duncan would do.
18:00:13 <SamB> ;-P
18:00:18 <ddarius> roconnor: That perspective may work.
18:00:50 <jsn> oh, curses
18:01:11 <jsn> i meant     svn st | sed -r '/^\?[[:space:]]+/ ! d  ;  s//svn add /' | sh
18:01:21 <int-e> jeffz: heh, you could at least write a script to do the job
18:01:25 * ksf won't type "emerge @system @world --deep --newuse --update" right now.
18:01:46 <jsn> ksf: when did the @ get added?
18:01:52 <ksf> portage 2.
18:01:52 <jeffz> int-e: yeah, I know, everytime I've done it I've always thought "this will be the last time"
18:01:56 <mmorrow> gwern, Saizan: ah, i saw the forkProcess i'm thinking of in Yi
18:02:04 <jsn> ksf: interesting
18:02:06 <cads> ksf, why, what's going on in gentoo land?
18:02:11 <ddarius> roconnor: In four dimensions, we have six bivectors but only need four numbers...
18:02:12 <ksf> emerge unmerge doesn't work anymore, either. gotta be --unmerge.
18:02:19 <jsn> ksf: i don't use gentoo at home any more, only for work
18:02:36 <ksf> lotsa slotting, no more revdep-rebuild, the usual ;)
18:02:37 <jsn> ksf: how old are the at-signs?
18:02:42 <gwern> mmorrow: well, that's understandable. both are big glitchy programs understood by only 1 or 2 hackers...
18:02:54 <ksf> portage 2. it's still unstable but works fine.
18:03:03 <ksf> you need it to e.g. emerge kde 4.1.2
18:03:15 <dons> ?users
18:03:16 <lambdabot> Maximum users seen in #haskell: 559, currently: 502 (89.8%), active: 20 (4.0%)
18:03:18 <ddarius> Actually, I think that was a pointless comment.
18:03:32 <Ikkebr> bah
18:03:57 <ksf> also, a lot more automatic block handling.
18:04:00 <jsn> it's good that we don't all speak at once :)
18:04:15 <roconnor> ddarius: well, you need to specify a hyperplane of dimension n-1, whose normal vector is always given by an (n-1) vector.
18:04:15 <jsn> ksf: i'll have to check it out
18:04:19 <int-e> @pl comment
18:04:20 <lambdabot> comment
18:04:25 <roconnor> ddarius: a fixed hyperplane
18:04:29 <ksf> did a world update for the first time in a year and only had to resolve a single block.
18:04:31 <ddarius> roconnor: Ah, yes silly me.
18:04:35 <ksf> which was kinda trivial.
18:04:56 <ddarius> So for 3D you want a bivector, but in general you want a 1-covector.
18:05:03 <Cale> IsoPallo_: There's a paper on LogicT which you might want to read.
18:05:04 <roconnor> ddarius: right
18:05:06 * cads is comfortably swaddled in the soft cloth of debian, but finds source based distributions to be intriguing
18:05:19 <roconnor> ddarius: I don't know if covectors and bi-vectors are the same in 3-D, or just isomorphic.
18:05:39 <Cale> IsoPallo_: http://okmij.org/ftp/papers/LogicT.pdf
18:05:46 <lambdabot> Title: Backtracking, Interleaving, and Terminating Monad Transformers
18:05:46 <ksf> cads, why, do you want to switch from xfree to xorg? ;)
18:05:56 <roconnor> can I edit trac tickets, or only leave comments?
18:05:59 <IsoPallo_> Cale: I'm reading it just now... Just for that I asked if there was something friendlier...
18:06:06 <Cale> IsoPallo_: ah
18:06:20 <Cale> IsoPallo_: Well... that would be a good idea, but I don't know of much.
18:06:37 <gwern> Cale: they're not worth it, unless you want to try a nextgen source distro like NixOS
18:06:44 <gwern> er. I meant cads
18:07:38 <ddarius> roconnor: Okay, so we pass in a (unnormalized) normal vector representing the fixed plane and it's magnitude.
18:08:02 <ddarius> (i.e. the dual of the 1-covector we actually "need")
18:08:17 <Axman6> gwern: do you remember asking me to take a look at conjure to see if i could figure out how to get it to work with larger files?
18:08:26 <gwern> Axman6: yes
18:08:42 <gwern> oh god did something go wrong and now you're missing an eye and a finger???
18:08:55 <gwern> IM SO SORRY I NEVER WOULDVE ASKED IF I'D KNOWN
18:08:56 <Axman6> no, i wore protection
18:08:58 <roconnor> ddarius: yep
18:09:05 <Axman6> 8)
18:09:58 <Axman6> i think the problem may be that mmap takes an int for the size of the region you want to allocate
18:10:17 <Axman6> so, that limits it to 4GB or less on a 32 bit system
18:10:24 <Axman6> i could very easily be wrong though
18:10:38 <gwern> that's pretty much what I thought as well, although I wasn't sure it was the mmap calls
18:10:41 <roconnor> ddarius: I think I listed everything that needs to be done as tickets: http://trac.haskell.org/fieldtrip/report/1
18:10:42 <lambdabot> Title: {1} Active Tickets - fieldtrip - Trac
18:10:54 <ksf> My dear. Gotos have become quite complex nowadays.
18:11:37 <ksf> Oh was reasoning simple back when you couldn't pass them around.
18:11:56 <ddarius> roconnor: Incidentally, "covariantly"
18:12:17 <roconnor> damn it
18:12:22 <roconnor> I never know which is which
18:12:27 <cads> gwern, nixos looks pretty cool
18:12:43 <Axman6> gwern: and since i have avoided learning as much C as i can, i have no idea where to start
18:12:52 <gwern> Axman6: as have I :)
18:13:07 <Axman6> :)
18:13:22 <ddarius> roconnor: I still puke on rotation axis vectors.
18:13:52 <ksf> Axman6, start with man setjmp.
18:14:02 <Axman6> ?
18:14:31 <roconnor> ddarius: ticket 4 is to change it to a normal vector.
18:14:37 <ksf> http://wwwcgi.rdg.ac.uk:8081/cgi-bin/cgiwrap/wsi14/poplog/man/3C/setjmp
18:14:45 <roconnor> which happens to be a bivector in 3D
18:15:13 <ddarius> roconnor: Yeah, I know.  That helps some.
18:15:14 <ksf> It'll be the fastest way to implement bind, that is.
18:15:50 <ddarius> roconnor: But it "just happens to be" in 3D.  For rotations, you really do want a bivector (or rather a rotor specified by a bivector)
18:16:03 <Axman6> ksf: not sure how that helps with giving conjure support for large files...
18:16:20 <gwern> Axman6: I think it was some sort of GOTO related joke
18:16:45 <ksf> Oh, I thought you wanted to know where to start to learn C.
18:16:51 <Axman6> i see... well i prefer to avoid velociraptor attack where possible, so i shall pass
18:17:39 <ksf> It's almost call/cc.
18:17:57 <EvilTerran> it's pretty much (call/cc id), isn't it?
18:18:13 <cads> ksf, the thing I lament about gentoo is the lack of sensible defaults for something like a laptop computer.. I appreciate that debian might be considered in the same category in that regard, and guiltily admit to using ubuntu
18:18:32 <cads> although
18:18:48 <roconnor> ddarius: we well write a GA package.  Maybe we can use some of these new quasi-quote Template stuff?
18:18:55 <roconnor> we will ...
18:18:55 <cads> isn't there sabayon which is gentoo configured as a desktop/workstation?
18:18:57 <ksf> well c doesn't have closures, so you gotta a) not return out of the current stackframe to jump back and b) save your stackpointer and then pass it around.
18:19:24 <ksf> ...or you'll end up executing your emails.
18:20:11 <ksf> what defaults do you need for a laptop computer?
18:20:53 <Twey> NixOS looks very interesting
18:20:56 <ksf> gentoo won't force an x install on you, much less cpufreqd and other such stuff.
18:21:30 <Axman6> gwern: i can't even build conjure atm, there are cabal files, but no Setup.(l)hs
18:21:31 * ddarius suddenly wonders what common GA operations would look like in spherical coordinates...
18:21:44 <gwern> Axman6: well, I doubt you have my patches?
18:21:45 <ksf> mainly because it's not a distribution but a meta-distribution.
18:21:51 <Axman6> probably not
18:22:18 * ksf wants to see debian switching to gentoo
18:23:51 <jsn> cads: yes, sabayon is rather glitzy
18:24:02 <ddarius> roconnor: A 3D GA library would be reasonably easy.
18:24:04 <jsn> cads: comes with submarine games and all kinds of stuff
18:24:43 <gwern> Axman6: easy, just do 'darcs changes|grep gwern'
18:24:47 <roconnor> ddarius: ya but people probably want a 4D lib, and maybe a 5D lib
18:25:05 <Axman6> nothing
18:25:17 <roconnor> ddarius: with those imaginary axes or whatever you call basis vectors with negative lenght
18:25:26 <ddarius> Though even then, what you'd really want to do is be able to use the nice definitions and have those specialize to efficient code and at that point supporting arbitrary dimensions should be a small step.
18:25:48 <ddarius> roconnor: I usually refer to the metric and call it Minkowskian.
18:25:53 <roconnor> ddarius: hence the need for template magic.
18:25:56 <ddarius> Also, adding those adds null vectors.
18:26:05 <roconnor> ddarius: yes. those things.
18:26:10 <jsn> i rather like the idea behind gobolinux -- all your old stuff stays in place if you want it to
18:26:14 <Axman6> gwern: i'll be back soon, need breakfast
18:26:17 <roconnor> mmm, null vectors
18:26:32 <ddarius> roconnor: Quasi-quoting wouldn't be necessary, just normal compile-time meta programming.
18:26:44 <roconnor> ddarius: so template haskell?
18:27:07 <ddarius> Just plain TH should suffice, though writing it is probably not pretty.
18:27:33 <cads> jsn, nethack-gnome got dropped from the ubuntu repositories in 8.10 and for this I am inciting rebellion
18:27:39 <roconnor> well we should probably start with a normal haskell represenation as a spec.
18:27:46 <jsn> cads: hehe
18:27:54 <ddarius> However, having a general partial-evaluate-like-crazy should do.
18:28:09 <ddarius> roconnor: Of course.  That part is almost trivial.  Just finger typing.
18:28:10 <glguy> cads, Ubuntu has always had a limited software repository, no?
18:28:43 <cads> glguy, to the contrary
18:28:58 <cads> it's got most of debian's packages
18:29:09 <jdrake> Q: Why is this channel #haskell instead of ##haskell? I thought that ## was for general channels and # was for specific projects?
18:29:15 <glguy> cads, right, debian is an example of a more inclusive repo
18:29:31 <gwern> really? that seems kind of silly. I don't want to type ##haskell, but #haskell
18:29:33 <jeffz> jdrake: # is for official channels ## is for about channels
18:29:36 <Cale> jdrake: That's only if you believe in lilo
18:29:36 <Ikkebr> ?users
18:29:36 <lambdabot> Maximum users seen in #haskell: 559, currently: 504 (90.2%), active: 22 (4.4%)
18:29:43 <roconnor> ddarius: what is your day job?
18:30:00 <ddarius> roconnor: Programming and killing babies.
18:30:31 <roconnor> ddarius: I was wondering if you were the guy who works for ILM or whatever.
18:30:45 <ddarius> roconnor: Dan, no.
18:30:52 <roconnor> ok
18:31:07 <Pseudonym> roconnor: sigfpe
18:31:16 <roconnor> is that sigfpe?
18:31:24 <Pseudonym> Yes.
18:31:26 <ddarius> Yes, Dan Piponi
18:31:30 <roconnor> I didn't know that
18:33:32 <Pseudonym> However, he's not the only person there interested in Haskell.
18:33:40 <Pseudonym> Also a few people at Pixar are quite interested.
18:34:10 <Pseudonym> Mark VandeWettering shows up here on rare occasions.
18:34:14 <roconnor> Pseudonym: Oh.  I was thinking of someone who wrote a Monad.Reader article.
18:34:26 <roconnor> and Piponi rings a bell
18:34:37 <Pseudonym> Right.
18:34:42 <luqui> how do I read a directory?
18:34:48 <roconnor> I'd be very intrested to know that ILM people are intrested in GA
18:35:17 <roconnor> ddarius: let us make a animation startup \o/
18:35:21 <jsn> luqui:  you have taken a peak at System.Directory ?
18:35:26 <luqui> ah, no
18:35:31 <luqui> duh =P
18:41:56 <roconnor> I suppose we should add CliffordAlgebra to http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vector-space-0.5
18:42:03 <lambdabot> Title: HackageDB: vector-space-0.5, http://tinyurl.com/4q9rd4
18:42:30 * ddarius dislikes the name Clifford Algebra.
18:42:42 <roconnor> ddarius: oh, why?
18:43:29 <ddarius> Clifford called it Geometric Algebra and that name seems very appropriate.  Also, nowadays "Clifford Algebra" scares up notions of QM.
18:44:34 <roconnor> CliffordAlgebra have more operations that Geometric Algebra.
18:45:13 <roconnor> You can add arbitrary elements in a CliffordAlgebra.  Where Geometric Algebra is restricted to (mostly?) blades.
18:49:19 <sw17ch> How do I convert a ByteString from Data.ByteString.Internal to a Data.ByteString.Lazy ?
18:49:37 <sw17ch> and actually, also to Data.ByteString
18:50:09 <jsn> sw17ch: off the top of my head, i think you might have a more serious problem
18:50:20 <sw17ch> jsn: i was thinking i might :)
18:51:16 <jsn> sw17ch: can haz codez plz?
18:52:06 <sw17ch> jsn: i'll try and generalize it...
18:52:14 <sw17ch> let me summarize what i'm trying to do, perhaps that will help
18:52:51 <sw17ch> jsn: i need a CString of length N, but I want this to be represented as a ByteString. I'm using Data.ByteString.Internal.create to make said N-lengthed bytestring
18:53:08 <sw17ch> jsn: then i need to pass the CString representation to a C function to be filled with mystery stuff
18:53:23 <sw17ch> jsn: i'm using unsafeUseAsCString for that
18:53:34 <jsn> interesting
18:53:42 <gio123> does somebody has a paper: J. Karhumaki, I. Petre, Two problems on commutation of languages
18:53:46 <sw17ch> jsn: once the C function returns, i need to hand back a Lazy or Strict bytestring
18:53:51 <sw17ch> preferably lazy
18:53:56 <jsn> if it is not too secret, i can try to sort though the code you have
18:54:16 <sw17ch> well, it's not secret, but it's not ready to check in yet... let me hpaste what i have
18:54:54 <sw17ch> jsn: http://hpaste.org/11931
18:55:06 <sw17ch> jsn: read_tap and write_tap are what i'm dealing with
18:55:37 <sw17ch> jsn: also, this does *not* build
18:55:57 <roconnor> I think the empty space out to be an affine space.
18:56:02 <roconnor> ought
19:01:31 <solrize> http://citeseerx.ist.psu.edu/viewdoc/download;doi=10.1.1.95.9152&rep=rep1&type=pdf
19:01:32 <solrize> related?
19:01:33 <lambdabot> http://tinyurl.com/46jxmx
19:01:44 <solrize> oh crap
19:02:05 <solrize> http://citeseerx.ist.psu.edu/viewdoc/summary;jsessionid=6243EF2BCA8923B7ABD8BB280828FA86?doi=10.1.1.95.9152
19:02:07 <lambdabot> Title: Conway's Problem and the commutation of languages - CiteSeerX, http://tinyurl.com/549voa
19:02:12 <sw17ch> jsn: http://hpaste.org/11931#a1
19:02:15 <sw17ch> i fixed some of my other issues
19:02:22 <sw17ch> still have the bytestrinb problems though
19:03:00 <jsn> sw17ch: reading the sources, it looks like the ByteString in Data.ByteString comes straight from Data.ByteString.Internal
19:03:09 <solrize> http://www.tucs.fi/publications/attachment.php?fname=TR556.ps.gz
19:03:25 <sw17ch> jsn: i was wondering about that... let me see if assuming it's a strict bytestring works
19:07:21 <srush> hey ops
19:07:35 <srush> can someone tell me how to get a list of all fb servers
19:07:47 <srush> I've been using fbhosts, but it seems to out of date
19:07:59 <Axman6> fb?
19:08:25 <srush> sorry I'm an idot
19:08:35 <srush> wrong room
19:09:32 <sw17ch> jsn: i guess i'm getting this wrong :\
19:09:53 <jsn> oh?
19:10:06 <sw17ch> jsn: it seems that the Internal have the same representation as a Strict
19:10:13 <sw17ch> but my usual method to convert fails
19:10:16 <sw17ch> to typecheck
19:10:25 <jsn> sw17ch: why do you need to convert?
19:10:39 <jsn> aren't they the exact same?
19:10:42 <sw17ch> jsn: the internal bytestring to a lazy bytetring
19:10:48 <sw17ch> Data.ByteString.Lazy.fromChunks [ibs]
19:10:48 <jsn> aha
19:10:55 <sw17ch> is what i'm used to doing
19:10:59 <jsn> hmm
19:11:07 <sw17ch> oh, that is it
19:11:17 <sw17ch> i'm just missing where the new error is :)
19:11:21 <jsn> can you really lazify a bytestring after the fact?
19:11:41 <Cale> jsn: You can make a new lazy bytestring with a single chunk
19:11:55 <sw17ch> jsn: yes
19:12:08 <jsn> Cale: but the old one was already evaluated, right? Aren't you stuck with the space usage?
19:12:10 <sw17ch> it's a strict bytestring in disguize :)
19:12:12 <Cale> It's already evaluated of course...
19:12:32 <Cale> A lazy bytestring is essentially just a lazy list of strict bytestrings
19:12:44 <jsn> so this is just for interfaces that accept lazy bytestrings?
19:12:50 <Cale> yes
19:12:53 <jsn> you don't get any actual lazification
19:13:01 <Cale> You can't actually turn it back into an expression...
19:13:10 <jsn> hehe
19:13:33 <novas0x2a> Is there a way to make this snippet shorter and/or more haskelicious? It feels like I missed something: http://hpaste.org/11932
19:15:20 <Cale> novas0x2a: prependNum would be more readable without the points-free-ness I think.
19:16:19 <jsn> novas0x2a: i think it's pretty haskellicious
19:16:54 <sw17ch> jsn: after all that, i just decided to convert the whole program to strict bytestrings
19:16:55 <sw17ch> :)
19:17:00 <Cale> novas0x2a: It's kind of annoying to have to use length... you could go with using reverse instead...
19:21:14 <Axman6> @src join
19:21:14 <lambdabot> join x =  x >>= id
19:27:00 <novas0x2a> sorry, got disconnected right after i asked (but i checked the logs, thanks Cale and jsn)
19:28:57 <sw17ch> @type apply
19:28:58 <lambdabot> Not in scope: `apply'
19:41:33 <luqui> are the standard Data.Binary instances compatible across architectures?
19:41:59 <adu> oooo whats Data.Binary?
19:42:08 <ddarius> luqui: They should be.
19:42:30 <luqui> hmm.. it's just odd seeing string lengths encoded as 64 bit integers
19:43:15 <luqui> adu, Data.Binary is a wonderful pragmatic module without *any* interesting theory  (very unusual for haskell :-)
19:43:29 <luqui> but I do love the niche it fills
19:43:47 <adu> so is it like for bitstructs?
19:44:03 <luqui> adu, it's more like serialization
19:44:08 <dons> luqui: yeah. they're entirely portable.
19:44:11 <luqui> I don't think it directly supports bitops
19:44:17 <luqui> dons, excellent :-)
19:44:23 <ddarius> luqui: From the docs, "encoded data should be portable across machine endianess, word size, or compiler version"
19:44:24 <dons> luqui: Data.Binary does use a continuation encoding and some tricky optimisatoins, fwiw
19:44:27 <gwern> luqui: I'm sure someone will get around to making Data.Binary an implement of bananas and lenses, or something
19:44:35 <Twey> Heh
19:44:50 <adu> luqui: so like ZODB for Haskell...
19:44:51 <dons> it used to be literally a ContT (StateT ...))
19:45:02 <luqui> zodb?
19:45:09 <adu> luqui: its a python thing
19:45:12 <Axman6> s Data.Binary comparable to erlang's serialisation stuff?
19:45:31 <Axman6> is*
19:45:44 <dons> not sure. i know it's about a gazillion times faster than python's serialisation.
19:45:50 <dons> approximately.
19:45:51 <Axman6> heh
19:46:05 <ddarius> +/- 1
19:46:11 <luqui> because of Haskell's attachment to purity, it can't be quite as cool as some serialization interfaces though
19:46:14 <adu> luqui: its a library built such that if you inherit from the classes defined in ZODB, then the instances of those classes are automatically serialized periodically
19:46:20 <luqui> eg. no serializing closures
19:46:30 <Axman6> well, with erlang's stuff, things are sent between nodes in a way they're guaranteed to know how to decode it at the other end
19:46:35 <dons> luqui: oh? well. that's a bit tricky in general. i'm not sure purity is the issue though.
19:46:37 <luqui> adu, ah that's neat
19:46:42 <dons> Axman6: oh, well, that's true.
19:46:49 <ddarius> dons: There are referential transparency issues.
19:46:50 <Twey> adu: 'Periodically' as in on a poll?
19:47:08 <Axman6> i should really be studying for maths and statics :(
19:47:13 <adu> Twey: I dunno, I think its event-based, like if you set a property, then it marks it as dirty
19:47:19 <dons> ddarius: clean can serialise 'em, via its bytecode environment. but its non-trivial
19:47:19 <ddarius> But it is definitely doable.  Clean does it (albeit not super portably if I recall correctly)
19:47:23 <dons> yeah.
19:47:39 <adu> Twey: and it checks every so often to see if the objects have become "dirty"
19:48:14 <adu> http://www.zope.org/Products/StandaloneZODB
19:48:16 <lambdabot> Title: Zope.org - Zope Object Database
19:49:44 <dons> "Declarative 3D has been done, years ago. It didn't take off because people don't like to declare things, they like to build them."
19:49:47 <dons> hehe
19:49:58 <dons> http://www.reddit.com/r/programming/comments/7cijd/fieldtrip_purely_functional_realtime_3d_graphics/c06ao6w
19:50:00 <lambdabot> Title: wuger comments on FieldTrip: Purely functional real-time 3D graphics using react ..., http://tinyurl.com/4a2fqq
19:50:09 <dons> you don't hear that as a justification for impurity very often
19:50:41 * sw17ch gets scared when the program typechecks but it's not correct :(
19:50:53 * Twey nodnods.
19:50:58 <ddarius> sw17ch: Add more types.
19:51:49 <ddarius> sw17ch: I get scared when my programs -compile- and work correctly the first time.
19:51:50 * roconnor sprinkles sugared types around
19:52:00 <sw17ch> ddarius, i'm looking for a way to do that
19:52:09 * sw17ch is doing bad things
19:52:43 <sw17ch> Is there some sort of holy place we can confess our usages of the unsafe functions?
19:52:52 <thoughtpolice> dons: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=469#a469
19:53:17 <sbahra> sw17ch, #haskell-FreeBSD
19:53:24 <int-e> ddarius: how often, when the program doesn't work, do you hit a compiler bug instead of one in your program?
19:53:30 <dons> thoughtpolice: ?
19:53:34 <roconnor> dons: an artist might model by using mutation, but I don't think that is how they animate.
19:53:50 <roconnor> and FRP is about animation
19:53:56 <dons> thoughtpolice: the core is fine.
19:54:04 <dons> roconnor: yes. the internet is full of idiots.
19:54:11 <dons> but mostly, reactionaries.
19:54:53 <ddarius> int-e: Extraordinarily rarely, maybe never.  However, I don't use half-implement type system features in beta versions of GHC.
19:54:58 <dons> its surprising how intolerant of new ideas computer programmers can be. you'd think in an innovative industry, you wouldn't see so many rexflexive negative responses to new ideas.
19:55:09 <Raevel> @hoogle Int -> a -> [a]
19:55:09 <thoughtpolice> dons: output is slow
19:55:09 <lambdabot> Prelude replicate :: Int -> a -> [a]
19:55:09 <lambdabot> Data.List replicate :: Int -> a -> [a]
19:55:09 <lambdabot> Prelude drop :: Int -> [a] -> [a]
19:55:15 <thoughtpolice> dons: takes 12 seconds to compute 1e9
19:55:24 <dons> thoughtpolice: then its whatever gcc (or -fasm) is doing to your code
19:55:31 <dons> the core is perfect.
19:55:35 <ddarius> s/implement/implemented
19:55:36 <dons>                                   $wfold_s1JY :: Double#
19:55:36 <dons>                                                  -> Int#
19:55:36 <dons>                                                  -> Double#
19:55:36 <dons>                                                  -> (# Double#, Int# #)
19:55:51 <dons> thoughtpolice: try adding -fvia-C -optc-O2
19:56:09 <dons> since it is double-based, you'll want to ask gcc to use the fp unit for you, a bit better than ghc can
19:56:33 <Twey> dons: I'm sure you've read http://www.paulgraham.com/avg.html before
19:56:34 <lambdabot> Title: Beating the Averages
19:56:43 <thoughtpolice> dons: the runtime without -fvia-C -optc-O3 is 14 seconds, with it it went down to about 12
19:56:57 <dons> thoughtpolice: what's your gcc version?
19:57:05 <dons> also, try installing ghc-core, so you can view the asm.
19:57:13 <dons> it'll all be in the asm for your arch/gcc version
19:57:14 <thoughtpolice> already did
19:57:18 <thoughtpolice> just a sec
19:58:50 <thoughtpolice> dons: http://thoughtpolice.stringsandints.com/code/haskell/bench/mean_core.html
19:58:56 <lambdabot> http://tinyurl.com/44wstz
19:59:26 <thoughtpolice> also it's gcc-4.0 (apple build)
19:59:33 <dons> oh. apple.
19:59:46 <dons> the compiler that ships on the mac suxors. i've had other reports , and always they're on macosx.
20:00:06 <thoughtpolice> i have a gcc-4.2 apple build
20:00:14 <thoughtpolice> (xcode 3.1.1)
20:00:22 <thoughtpolice> but 'gcc' just goes to gcc-4.0
20:00:42 <dons> thoughtpolice: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=469#a470
20:00:48 <dons> is what you'd be hoping for.
20:00:58 <dons> it seems dependent on the quality of your gcc though.
20:02:35 <gwern> I have a theory that programmer intolerance stems from future shock combined with weariness. by the time anyone has spent the 10 years or so it takes to become expert in any particular thing, the cutting edge has changed like 2 or 3 or more times. at some point, out of sheer self-defense, you need to stop, and the intolerance is a good mental way to enforce that.
20:03:00 <Raevel> @hoogle [[a]] -> [a]
20:03:00 <lambdabot> Prelude concat :: [[a]] -> [a]
20:03:00 <lambdabot> Data.List concat :: [[a]] -> [a]
20:03:00 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
20:03:03 <adu> ya, apple-gcc is wierd
20:03:03 <dons> yeah. way too much invested in the wrong things.
20:03:34 <ddarius> Everything eventually becomes the wrong thing...
20:03:54 <adu> ddarius: unless it becomes the right thing
20:04:17 <Axman6> dons: does what apple needs :)
20:04:23 <gwern> one could write a book of existentialism just on the plight of the programmer as victim of progress
20:04:35 <a> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
20:04:55 <adu> Axman6: well apple needs to not rename standard GNU tools
20:05:03 <a> Why does this not require the line declaring its return type?  And why does having fibs :: [Int] make it not function as expecte?
20:05:43 <Twey> a: Because some of the values are too large for Int to hold
20:05:47 <a> Aha
20:05:52 <Twey> It doesn't require a type because the type can be automatically deduced.
20:06:14 <a> Ooh.  What would the appropriate data type be?
20:06:18 <Raevel> Integer
20:06:27 <Twey> [Integer], probably
20:06:29 <Axman6> adu: such as?
20:06:51 <sbahra> > 9999999999999999999999 :: Int
20:06:52 <lambdabot>   1864712049423024127
20:06:52 <a> I thought Int was the same as Integer! :o
20:06:55 <sbahra> > 9999999999999999999999 :: Integer
20:06:56 <lambdabot>   9999999999999999999999
20:07:01 <a> Thanks
20:07:04 <sbahra> a, integer = arbitrary precision
20:07:05 <Twey> As deduced, it's probably (Num a) => [a]
20:07:25 <Twey> :t [1, 2, 3]
20:07:26 <lambdabot> forall t. (Num t) => [t]
20:07:32 * Twey nods.
20:08:05 <mrd> haskell has some special case defaulting rules for Num
20:08:29 <Twey> :t 9999999999999999999999
20:08:30 <lambdabot> forall t. (Num t) => t
20:09:21 <Axman6> > 9999999999999999999999 :: Double
20:09:22 <adu> Axman6: like gnumake, gnutar, glibtool, glibtoolize, etc
20:09:22 <lambdabot>   1.0e22
20:09:30 <Axman6> > 9999999999999999999999 :: Float
20:09:31 <lambdabot>   1.0e22
20:10:03 <Axman6> adu: isn't make the standard name? and tar? and libtool? ...?
20:10:03 <adu> Axman6: you don't know how many times I tried compiling some opensource software and it said something about how "libtool" wasn't "sane"
20:10:31 <Axman6> never happened to me, and i (used to) compile everything from source just fine
20:10:53 <adu> Axman6: libtool is supposed to be a portable way of building libraries, but on macosx you have to check to see if "glibtool" exists first, because Apple "libtool" is a completely different program
20:11:08 <Axman6> fair enough
20:11:33 <adu> Axman6: thats becasue autoconf coought on pretty early, and now there are checks in (most, but not all) ./configure files to look for "glibtool" first
20:11:35 <sw17ch> i have a ForeignPtr question
20:11:46 <sw17ch> if, for some reason, two ForeignPtr's reference the same Ptr, what bad things could happen?
20:12:45 <adu> Axman6: also, Apple tar didn't accept -z and -j options in the beginning...
20:12:49 <heatsink> I suppose a finalizer could be called twice.
20:13:07 <Axman6> adu: well, it does now
20:13:26 <adu> yes, i think they replaced it with gnutar after enough people complained :)
20:13:30 <Axman6> and being POSIX complient should help with much of this no?
20:13:44 <adu> Axman6: MacOSX is not POSIX compliant
20:13:55 <sw17ch> mallocForeignPtr >>= unsafeForeingPtrToPtr >>= newForeignPtr_
20:13:59 <sw17ch> how bad is that?
20:14:10 <Axman6> yes it is
20:14:12 <sjanssen> sw17ch: terrible
20:14:19 <ddarius> sw17ch: Presumably it could be finalized twice.
20:14:28 <adu> Axman6: since which version?
20:14:31 <sw17ch> i knew i had to put code out there to get a response :)
20:14:32 <Axman6> 10.5
20:14:35 <sjanssen> I'd say it almost certainly will be finalized twice
20:14:42 <sw17ch> sjanssen, and that's assuredly a bad thing
20:14:47 <sjanssen> sw17ch: definitely
20:14:56 <Axman6> part of getting the SUSv3 stuff i believe
20:15:09 <sw17ch> newForeignPtr_ seems to make a ForeignPtr that doesn't have a finalizer associated
20:15:31 <sjanssen> sw17ch: the memory will be freed sometime after unsafeForeignPtrToPtr is called
20:15:32 <sw17ch> sjanssen, if that's the case, would the above line be a little safer?
20:15:44 <sjanssen> sw17ch: no
20:16:08 <sjanssen> sw17ch: do you know C?  This is like using memory after you've used free() on it
20:16:08 <sw17ch> sjanssen, i have to pass a ForeignPtr into a struct, and then "read" it out again later
20:16:51 <sw17ch> sjanssen, i'm writing a C binding through the FFI, and i'm having an issue where i need to poke a ForeignPtr into a struct, and then either ignore that piece on the way out again, or read the ptr
20:17:12 <sw17ch> ignoring on the way out is problematic since the datatype i'm building needs a foreignptr
20:17:15 <heatsink> The usual way to pass Haskell pointers (including ForeignPtrs) to C is using StablePtr
20:17:20 <Axman6> adu: 9999999999999999999999
20:17:22 <Axman6> whoops
20:17:23 <heatsink> *Haskell objects
20:17:26 <adu> lol
20:17:34 <Axman6> http://www.apple.com/macosx/technology/unix.html
20:17:34 <lambdabot> Title: Apple - Mac OS X Leopard - Technology - UNIX
20:18:30 <adu> Axman6: oic, so they don't follow XSI even...
20:18:33 <sw17ch> i'm trying to avoid having to manage the pointer on my own... hence the foreignptr
20:18:34 <sjanssen> sw17ch: what will the C code do with the pointer you've given it?
20:18:40 <Axman6> XSI?
20:18:47 <sw17ch> sjanssen, it's pushing a value into it
20:18:55 <sw17ch> the haskell side doesn't actually need to know what's behind the pointer
20:19:01 <sw17ch> just has to allocate the memory and hold it
20:19:31 <adu> Axman6: the C API is devided into like 20 extensions
20:19:36 <sw17ch> i'm doing some evil hackery: i make a data Thingy = Thingy and i make it an instance of Storable
20:19:55 <sw17ch> this Storable instance only defined alignment and sizeOf
20:20:01 <sw17ch> peek/poke cause errors
20:20:10 <sw17ch> then i have a Ptr Thingy
20:20:26 <adu> Axman6: In fact the C API is entirely optional in SUSv3, the only part required is the utilities. Even some utilities are only required if an extension is supported.
20:20:34 <sw17ch> and a data type that holds a Ptr Thingy
20:20:39 <heatsink> sw17ch, that's common.  I suggest using an empty data decl though.
20:20:48 <sw17ch> the struct itself is passed by reference to the C function
20:20:48 <Axman6> adu: ok, so?
20:20:52 <adu> Axman6: XSI utilities include: alias, fg, bg, df, du, etc
20:20:54 <sw17ch> heatsink, in StablePtr?
20:21:10 <Axman6> adu: well, they're all there
20:21:26 <heatsink> sw17ch, I meant creating a data Foo for the sole purpose of making a Ptr Foo.
20:21:32 <adu> Axman6: there was one I remember being absent, like localedef or mailx
20:21:34 * heatsink is still reading
20:21:43 <sw17ch> heatsink: yeah, i should just use the empty datat decl
20:21:57 <Axman6> adu: they;re both there too
20:23:13 <Axman6> also, googling XSI turns up nothing useful
20:23:23 <sjanssen> sw17ch: so you intend Ptr Thingy to just be an opaque memory area?
20:23:35 <sjanssen> sw17ch: where is the ForeignPtr in this example?
20:23:55 <heatsink> sw17ch, how long does this memory-allocated object live?  Is it just for the one function call?
20:24:42 <adu> Axman6: uucp is also XSI
20:25:01 <Axman6> it's there
20:25:11 <Axman6> Axman$ uu
20:25:11 <Axman6> uuchk     uucico    uuconv    uucp      uudecode  uuencode  uuidgen   uulog     uuname    uupick    uusched   uustat    uuto      uux       uuxqt
20:25:36 <sw17ch> sjanssen, The ForeignPtr is the opaque memory area. It lives inside my outer data type which itself is passed to the C function
20:25:48 <sw17ch> the C function fills in the opaque memory area and another field in the outer struct
20:26:16 <sw17ch> i need the other field, and i need to hold the inner opaque pointer to pass back to the C functions later
20:26:38 <sjanssen> sw17ch: will the C function ever modify the pointer in the struct?
20:26:46 <sw17ch> sjanssen, only once
20:26:50 <Axman6> adu: this seems to have most of what you're tlking about http://www.opengroup.org/austin/papers/single_unix_faq.html
20:26:53 <lambdabot> Title: Single UNIX Specification FAQ
20:27:03 <sjanssen> sw17ch: huh?
20:27:17 <sw17ch> haskell allocates the memory, passes it to the C "create" function, and then i take the pointer and pass it to read/write functions in the C lib later
20:27:35 <heatsink> So far, it seems like a job for withForeignPtr
20:27:38 <sjanssen> sw17ch: but is the *pointer* ever modified?
20:27:39 <sw17ch> sjanssen, this opaque memory is just holding resource descriptors of non-uniform size
20:27:44 <mib_o7ks29> i am trying to implement a spell checker  using binary trees, any advice as to how to approach this?
20:27:57 <sw17ch> sjanssen, not once the C library initializes it the first time
20:28:07 <sw17ch> heatsink, i don't want it freed after it's passed the first time
20:28:27 <heatsink> sw17ch, withForeignPtr won't do that.
20:28:34 <ddarius> mib_o7ks29: Don't use binary trees.
20:28:41 <sw17ch> oh, i guess the "with" made me assume
20:28:59 <sjanssen> sw17ch: there is a difference between overwritting the pointer in the struct and writing to the area pointed to by the pointer.  Which of these things does the C function do?
20:29:26 <sw17ch> sjanssen, the pointer itself never changes, the memory pointed to changes once
20:29:39 <sjanssen> sw17ch: okay
20:29:46 <sjanssen> sw17ch: yeah, you want withForeignPtr
20:30:00 <mib_o7ks29> ddarius it's not a full blown spell checker, just want it to search a string entered if not found with the dictionary module return [(!fnd, "example")]
20:30:05 <sw17ch> sjanssen, ah, yes... look at that, i had implemented that
20:30:15 * sw17ch replaces is implementation of withForeignPtr with the real one
20:30:17 <sjanssen> do x <- mallocForeignPtr; withForeignPtr x create; withForeignPtr x read/write
20:30:53 <sw17ch> sjanssen, one more tricky piece... the create function takes a pointer to a struct which contains the foreign pointer
20:31:00 <sw17ch> the read/write functions only take the foreign ptr
20:31:05 <mib_o7ks29> i also want a autocomplete feature, so i enter auto "wo" and it suppose to return all words that have "wo" , e.g "word", "words" etc
20:31:11 <ddarius> mib_o7ks29: I'm assuming this is homework or some sort of exercise?
20:31:18 <mib_o7ks29> yeah
20:31:24 <adu> Axman6: ok, you win macosx is POSIX compliant, and apparently SUSv3+XSI as well
20:31:36 <Axman6> heh :)
20:31:39 <mib_o7ks29> i just want to know what i need to do and i'll start :)
20:31:48 <adu> Axman6: but I'm on 10.4, so I don't have all of those utils :P
20:31:58 <sjanssen> sw17ch: withForeignPtr x (\p -> do poke p somewheres; c_create somewheres)
20:31:59 <ddarius> mib_o7ks29: What do you think you need to do first?
20:32:08 <Axman6> well, you should upgrade and get all the yummu goodness
20:32:11 <Axman6> yummy*
20:32:13 <Twey> mib_o7ks29: I would order them by Levenshtein distance personally...
20:32:24 <mib_o7ks29> i am suppose to have a dictionary module of 100 mostly used words according to the teach
20:32:38 <Twey> From 'a' or something
20:32:50 <ddarius> Twey: How about an adaptive model (starting with Levenshtein as the initial state, say)
20:32:56 <adu> Axman6: the only thing I'm looking forward to is ZFS support... I could care less about time machine
20:33:05 <Twey> Would work, aye
20:33:19 <Axman6> adu: well, it's very beta in 10.5, should be better in 10.6
20:33:25 <sw17ch> sjanssen, i probably could have thought of that... thanks :)
20:33:28 <Twey> Speaking for a basic spellchecker, though, adaption wouldn't really be necessary
20:33:30 <Axman6> i'm hoping they implement time machine using ZFS
20:33:37 <ddarius> Twey: Of course.
20:33:38 <mib_o7ks29> then i would create the various tree methods such as null tree, depth, flatten... etc...
20:33:39 <ben_h> time machine is brilliant imo
20:33:49 <ddarius> Twey: This is talking about a not-basic spellchecker.
20:33:49 <Axman6> agreed :)
20:33:52 <Axman6> mine's running atm
20:34:21 <noZone> > map (\c -> (if isUpper c then toUpper else toLower) $ fromMaybe c $ lookup (toLower c) $ zip ['a'..'z'] (['n'..'z'] ++ ['a'..'m'])) "Unfxryy chgf gur sha va shapvbany"
20:34:22 <lambdabot>   "Haskell puts the fun in funcional"
20:34:27 <Twey> ddarius: Calculating the Levenshtein distance seems like a fairly fundamental requirement, no?
20:35:06 <Twey> noZone: You're missing a 'e' :-P
20:35:09 <ben_h> time machine is everything good software should be. zero-maintenance, no specific data format, simple interface, etc. i <3 it
20:35:22 <ddarius> Twey: I don't see why though I'm now unclear about what exactly you're talking about.
20:35:27 <noZone> tragic that...
20:35:36 <Twey> > map (\c -> (if isUpper c then toUpper else toLower) $ fromMaybe c $ lookup (toLower c) $ zip ['a'..'z']  (['n'..'z'] ++ ['a'..'m'])) "Unfxryy chgf gur sha va shapevbany"
20:35:37 <ben_h> actually, there's one flaw, that if you use > 1 backup drives you have to manually switch between them.
20:35:38 <lambdabot>   "Haskell puts the fun in funcrional"
20:35:42 <noZone> lol
20:35:46 <Twey> Oh dear, I missed
20:35:57 <Twey> > map (\c -> (if isUpper c then toUpper else toLower) $ fromMaybe c $ lookup (toLower c) $ zip ['a'..'z']  (['n'..'z'] ++ ['a'..'m'])) "Unfxryy chgf gur sha va shapgvbany"
20:35:59 <lambdabot>   "Haskell puts the fun in functional"
20:36:04 <noZone> yay!
20:36:10 <Twey> There we go
20:36:18 <Twey> I'm missing something there, though... I was sure it was 'e'
20:36:32 <Twey> Oh, a couple of off-by-ones.
20:36:47 <heatsink> Shapgvbany is fun to say.
20:37:15 <ddarius> Noone makes an off-by-two error (except perhaps as a combination of off-by-one errors), so we should do away with one.
20:37:23 <Twey> ddarius: To build a basic spellchecker that can handle more than just autocompletion, such as 'wodrs' -> 'words', I think it's necessary to calculate the Levenshtein distance and order the words by that
20:37:30 <adu> > let uncat3 [] = [] ; uncat3 xs = (let (ys, zs) = splitAt 3 xs in ys : uncat3 zs) ; getFrom x y = map (x !!) $ map (fromIntegral . ((\x -> fromIntegral $ foldl (.|.) (0::Word8) (zipWith (\c n -> if c then bit n else (0::Word8)) x [0..2])) :: [Bool] -> Int)) $ reverse . uncat3 . reverse . concat . map (((\x -> map (testBit x) [7,6..0]) :: Word8 -> [Bool]) . fromIntegral . ord) $ y in getFrom " HWdelor" "e\184-\235"
20:37:31 <lambdabot>   "Hello World"
20:37:38 <noZone> Unfxryy... double upside down lambdas in rot13 haskell
20:38:00 <Twey> I was thinking of doing it from a fixed point, but I now see that that's never going to work, because you'd end up with entirely unrelated words grouped.
20:38:24 <Twey> So you could start with length
20:38:35 <Twey> Then calculate Levenshtein dynamically...
20:38:36 <noZone> adu: nice obfuscation!
20:38:43 <adu> noZone: thanks :)
20:39:03 <Twey> adu: Woah!
20:39:30 <roconnor> Cale, ddarius: are co-vectors and bi-vectors really naturally isomorphic in 3-D?  What is the definition of natural again?
20:40:09 <shapr> ChilliX: Have you read Jaewook Shin's papers on superword level parallelism?
20:40:10 <ddarius> roconnor: It depends on how you define covectors.  I admit that I was abusing the term to simply mean the GA dual of vectors.
20:40:22 * sw17ch is scared b/c his code compiled again
20:40:41 <roconnor> ddarius: covectors are linear operators returning a scaler
20:40:48 <ddarius> roconnor: Yes, I know.
20:41:10 <roconnor> um, then how does it depend on how you define covectors?
20:41:40 <noZone> sw17ch: you need to find a language better suited to making broken code so you can feel good about fixing it.
20:41:43 <ddarius> roconnor: Well, I already said that I was not using it in that sense earlier.
20:42:16 <askentasken> is it sinful to have language that both always returns values and does destructive updates?
20:42:20 <roconnor> okay, then I'll ask:  are covectors and bivectors naturally isomorphic in 3-D?
20:42:26 <Twey> So, I'm now working with a large number of functions :: StateT IO (Either RSError RSValue)
20:42:38 <roconnor> (does the term bi-vector imply an inner product?)
20:42:40 <sw17ch> noZone, well, usually this would be fine... but i'm forced to toss pointers around... so it's scary
20:42:48 <sw17ch> and i'm not being as careful as i should with my types
20:43:20 <noZone> sw17ch: Damn the hidden errors! Forge heedlessly ahead!
20:43:21 <ddarius> roconnor: Technically, no, but I'd say yes (because I don't like bivectors sitting around without a full GA).
20:43:37 <ddarius> roconnor: Obviously all that you need for a bivector is an outer product.
20:43:39 <adu> Twey: noZone: if you want to use that obfuscation technique for strings containing more than 8 distinct letters, I suggest you increase uncat3 to uncat4...
20:43:53 <ddarius> roconnor: You end up with Grassman algebras.
20:44:02 <sw17ch> sjanssen, thanks... it's working :)
20:44:02 <roconnor> mm
20:44:21 <noZone> adu: there's dark magics in there...
20:45:15 <Twey> Haha
20:45:18 <sw17ch> noZone, that's how this feels some times..
20:45:22 <ddarius> roconnor: As to your former question, I'm not quite sure what notion of isomorphism to use, or put another way, I'm not sure what "isomorphic" means in that question.
20:45:41 <ajdhs> ?pl \x y -> [x,y]
20:45:41 <lambdabot> (. return) . (:)
20:45:42 <sw17ch> but i think i threw enough "explode badly if this ever happens" lines in, that my lack of type safety will be fixed by immediate crashes of the program... i'll document it as a feature
20:46:45 <roconnor> ddarius: well, they are obviously isomorphic.  All n-d vector spaces over the same field are isomorphic.  The question is if they are naturally isomorphic
20:47:00 <roconnor> ddarius: vectors and covectors are not naturally isomorphic.
20:47:02 <adu> noZone: the idea is very simple, all of the letters are in " HWdelor" and the index of each letter in the output is encoded in 3 bits of "e\184-\235"
20:47:03 <Twey> sw17ch: *wince*
20:47:13 <roconnor> but vectors and co co vectors are naturally isomorphic
20:47:28 <sw17ch> Twey: i promise, i'll make it better
20:47:51 <ChilliX> shapr: nope, why?
20:49:54 <roconnor> ddarius: I don't think vectors and bivectors (in 3-d) are naturally isomorphic even given an inner product.  There are two possible isomorphisms to pick, and neither one is natural IIRC.
20:50:07 <shapr> ChilliX: He does some neat stuff with superword level parallelism via loop unrolling and fusing. I don't really know if it's related NDP, but it could be interesting to you.
20:50:20 <shapr> ChilliX: No guarantees it's worthwhile - http://www.mcs.anl.gov/~jaewook/
20:50:21 <lambdabot> Title: Jaewook Shin
20:50:49 <ddarius> Given a vector, multiplying by the pseudoscalar is a linear transformation that creates a bivector.  Multiplying by the inverse goes back.
20:51:07 <noZone> adu: I'll have to carefully disassemble that beast... I wonder if anyone makes an obfuscation disassembler?
20:51:46 <roconnor> ddarius: right, a pseduoscaler gives the entire space an orientation, and then you have a unique (natural?) isomorphism.
20:51:51 <blackdog> hilliX: was wondering - was there a particular reason to build the mac os version of ghc as 32 bit only?
20:51:55 <sw17ch> well, no memory leaks. that's good :)
20:52:08 <blackdog> shapr: heya man
20:52:18 <roconnor> ddarius: well a non-zero pseudoscaler.
20:52:19 <shapr> blackdog: y0, the old nickname comes back!
20:52:25 <blackdog> yeah, some basti
20:52:28 <blackdog> d keeps stealing it
20:52:31 <shapr> heh
20:52:31 <blackdog> but it's mine now :)
20:52:36 <dons> ?seen seafood
20:52:37 <lambdabot> I saw seafood leaving #ghc and #haskell 8h 19m 54s ago, and .
20:52:42 <shapr> blackdog: Did you register it?
20:52:46 <shapr> If so, you can steal it back.
20:52:58 <dons> ah, like back in the day. let's do some functional programming!
20:53:17 <shapr> w00!
20:53:18 <ddarius> roconnor: Yes, admittedly there are two different pseudoscalars.  However, simply giving a 3D vector space and it's dual orientations does not provide enough for them to be naturally isomorphic (I don't believe)
20:53:33 <ChilliX> shapr: I suspect that by the time we get around to look at SSEish stuff, SSE will have morphed into proper stream processing support anyway...mumble..Larabee...mumble
20:53:41 <dons> shapr: played with fieldtrip? pretty hot today.
20:53:42 <blackdog> shapr: yeah, i did, but it doesn't always seem to work. think i screwed something up
20:53:52 <blackdog> dons: i think sean's up in byron saving the world from peak oil
20:53:55 <ChilliX> blackdog: hey - ahem, no particular reason
20:54:09 <blackdog> pity, otherwise i'd steal him to do soul-destroying perl work
20:54:10 <ChilliX> blackdog: what does 32bit only mean on macos, actually?
20:54:15 <ChilliX> I just type make ;)
20:54:26 <blackdog> ChilliX: well, i wanted 64 bit Ints for IntMap
20:54:27 <shapr> ChilliX: I dunno, maybe.
20:54:29 <blackdog> i'm lazy that way \
20:54:35 <shapr> dons: Looked at it, that's it so far.
20:54:51 <blackdog> but i coul
20:55:03 <dons> playing with it in ghci is a lot of fun. http://www.youtube.com/watch?v=WNB5V9Z7Obc
20:55:03 <blackdog> dn't convince gcc to use 64 bit ints either, so maybe it's my foult
20:55:03 <shapr> dons: I'm more interested in hacking gitit into FLM at the moment, but being distracted by Cell hardware adventures.
20:55:03 <lambdabot> Title: YouTube - 3D spinning torus: FRP FieldTrip demo
20:55:09 <blackdog> fault. crap. i can't type today.
20:55:10 <dons> shapr: that would be /awesome/
20:55:26 <roconnor> ddarius: actually, simply giving the space an inner product is enough for the dual space to be naturally isomorphic ... which suggests that bivectors and covecters are not naturally isomorphic.
20:55:40 <roconnor> damn
20:55:41 <shapr> If I could figure out how to *power* a BladeCenter chassis in my apartment, I'd already have one running.
20:55:45 <roconnor> ddarius: so we need another type?
20:55:47 <blackdog> shapr: you're hacking on gitit? you should talk to pete gammie at some stage, i think he had similar ideas about using darcs to share changes between wikis
20:55:53 <ChilliX> blackdog: you can use 64bit ints in ghc I believe
20:56:04 <dons> ChilliX: we need to get conal to help hook dph up to his reactive-fieldtrip graphics engine
20:56:09 <shapr> Speaking of which, will a PPC ghc build work on the PS3?
20:56:09 <ChilliX> blackdog: just use It64
20:56:11 <blackdog> ChilliX: if you use Int64. I was hoping to get it as the default
20:56:14 <ChilliX> Int64*
20:56:17 <blackdog> yeah
20:56:21 <shapr> I'm having problems building GHC on Cell.
20:56:34 <ddarius> roconnor: Ignore covectors.
20:56:36 <ChilliX> shapr: does the ppc build work at all
20:56:49 <roconnor> ddarius: aren't normal vectors covectors?
20:56:52 <dons> yay, sigbjorn's using hackage now, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/flickr
20:56:57 <lambdabot> Title: HackageDB: flickr-0.2
20:57:13 <blackdog> and people keep telling me that GHC is significantly faster when you compile in 64 bit mode. Might be wrong, plural of anecdote /= data, etcetcetc
20:57:28 <ddarius> roconnor: You can model them that way, or you can model them as dualized (n-1) vectors.
20:57:53 <ddarius> roconnor: I didn't abuse the term completely wontonly.
20:57:54 <ChilliX> blackdog: hmm, maybe because of more registers?
20:58:04 <dons> yeah.  i think so. you get shorter code, better fp code.
20:58:06 <blackdog> ChilliX: yeah, i think that was the reason mentioned
20:58:08 <shapr> ChilliX: The rpm for 6.4.2 from fedora-extras worked fine, but then using that to build 6.8.3 .... the build finished, but the resulting binary has some sort of problems I can't figure out - http://hpaste.org/11906
20:58:10 <Axman6> how do you even use ghc to compile 64-bit?
20:58:18 <dons> Axman6: you just use it.
20:58:20 <ddarius> Freakin' vowels
20:58:22 <sjanssen> blackdog: 64 bit GHC can also be slower because pointers take twice as much memory
20:58:22 <dons> > maxBound :: Int
20:58:23 <lambdabot>   9223372036854775807
20:58:24 <dons> like that.
20:58:29 <ChilliX> blackdog: hmm, that *is* a good point
20:58:31 <Axman6> well it's not 64 bit for me :\
20:58:32 <blackdog> dons: stop rubbing my face in it, dammit :)
20:58:39 <dons> blackdog: yo! got enough bits yet?
20:58:41 <dons> i can lend you some.
20:58:51 <conal> dons, ChilliX: i'd love to put fieldtrip & dph together.
20:58:52 <shapr> hah
20:58:54 <roconnor> ddarius: by dualized (n-1) vectors you mean simply (n-1) vectors?
20:58:55 <blackdog> i hate you so much i may try to get you a job at optus :P
20:59:01 <Axman6> some of my Core 2 Duo's registers are getting cold :(
20:59:01 <dons> blackdog: Prelude> maxBound :: Data.Word.Word
20:59:01 <dons> 18446744073709551615
20:59:06 <dons> have some! lots to go around.
20:59:07 <blackdog> i've already snared pete and pat in my filthy web of lies
20:59:32 <Axman6> blackdog: at least it's not telstra
20:59:34 <ben_h> Axman6: careful, you might get register rot
20:59:40 <conal> dons, ChilliX: i'd love to put fieldtrip & dph together.  or help someone else do it.
20:59:49 <conal> (oops -- sorry for the repeat.)
20:59:50 <dons> yeah. conal have you see the dph-based physics engine?
20:59:55 <sbahra> Axman6, SSE/MMX is really under-utilized :(
21:00:02 <conal> dons: no, i haven't.  is it seeable?
21:00:04 <sw17ch> wow, it's working
21:00:07 <sw17ch> and working well..
21:00:08 <dons> http://haskell.org/haskellwiki/Hpysics
21:00:11 <lambdabot> Title: Hpysics - HaskellWiki
21:00:28 <dons> conal: but needs a graphics guru i think, to work with the dph gurus. but it'd be an awesome demonstration of the multicore arrays work.
21:00:38 <ddarius> roconnor: Kind of.  I would recommend using the actual (n-1) vectors, but the normal vector is a vector, just viewed as the dual of an (n-1) vector. (Of course, you could potentially "forget" that it was representing a dual hence me preferring to use the actual (n-1) vector.)
21:00:47 <Axman6> is there some way to tell ghc to compile to 64 bit? or make ghc 64 bit?
21:00:47 <ChilliX> blackdog: we should have a look at that; I guess we need a some tweaking in the rts and stuff
21:00:50 <conal> dons: sure would.  i'm very interested.
21:01:11 <dons> conal: feurbach's summer of code work, http://www.youtube.com/watch?v=uziCn2SBbxs
21:01:11 <lambdabot> Title: YouTube - Hpysics simulation
21:01:17 <ChilliX> Axioplase_: don't think, there is an existing way to compile it that way except on archs like IA64
21:01:27 <ChilliX> Axman6: I mean
21:01:35 <ChilliX> stupid ichat nick completion
21:01:54 <ChilliX> conal, dons: ok, what is fieldtrip?
21:01:57 <roconnor> ddarius: well, normal vectors are certianly not vectors, because to apply a linear function to them you need to multiply by the transpose of the matrix.
21:01:58 <Axman6> iChat?
21:02:14 * Axman6 didn't think iChat did IRC
21:02:17 <ChilliX> Axman6: argh, colloquy
21:02:17 <luqui> ChilliX, fieldtrip is a purely functional library for building 3D models
21:02:24 <roconnor> ddarius: (or multiply it's components as a (n-1) vector by the matrix)
21:02:26 <Axman6> oh, yes, switch to irssi ;)
21:02:33 <askentasken> is Prolog easily implementable ina functional way? or is it easier in an OO-way?
21:02:35 <sjanssen> Axman6: to get a 64-bit GHC, build GHC on a 64-bit system
21:02:45 <luqui> askentasken, uh...  it does not seem very OO to me
21:02:49 <Axman6> sjanssen: i have a 64 bit system
21:02:49 <ddarius> roconnor: That's the implicit pseudoscalar.
21:03:05 <Axman6> like i said, by Core 2's registers are getting cold
21:03:06 <roconnor> ddarius: where is the pseudoscaler?
21:03:14 <ChilliX> sjanssen: Mac OS X 10.5 is 64 bit, but still ghc runs in 32bit mode, that's what we are talking about
21:03:25 <sjanssen> ChilliX: oh, I didn't know about that
21:03:26 <luqui> askentasken, prolog is in a different paradigm from both of those.  but everything is wonderful when implemented in a functional way (as long as you take a lot of care to do it right!) :-)
21:03:30 <roconnor> ddarius: the transpose?
21:03:31 <ddarius> A normal vector n = BI where B is a bivector (for 3D) representing the plane.
21:03:40 <ChilliX> sjanssen: don't you watch Apple ads ;P
21:03:58 <luqui> askentasken, if you get rid of the side effects, prolog == list monad, more or less.
21:04:11 <ChilliX> luqui: url?
21:04:39 <luqui> ChilliX, http://www.haskell.org/haskellwiki/FieldTrip
21:04:40 <lambdabot> Title: FieldTrip - HaskellWiki
21:04:49 <ChilliX> luqui: ta
21:05:33 <roconnor> ddarius: suppose I have a linear function (outer morphism) f represented by a matrix M. then if n is a normal "vector", computing Mn is wrong and should be a type error.
21:05:39 <dons> fieldtrip + dph + hpysics == awesome thesis project.
21:05:54 <roconnor> however if n is a normal "covector" then computing nM is good
21:05:58 * Axman6 claims it for 4 years time
21:06:12 <roconnor> or if n is a normal "bivector" then computing M(n1)/\M(n2) is also good
21:06:16 <dons> dph + fieldtrip == awesome dph paper
21:06:18 <jdrake> Man, I am the only one that respects the power of monoids in #electronicstech on efnet :-(
21:06:22 <ddarius> roconnor: If instead of n you directly used B, then MB is right and we don't have issues.
21:06:31 <roconnor> ddarius: exactly
21:06:46 <roconnor> do a normal "vector" is not a vector.
21:06:47 <ddarius> roconnor: The upshot is: get rid of normal vectors, use bivectors.
21:06:49 <roconnor> so a
21:07:36 <ddarius> roconnor: Yes, but you can't tell by looking at a normal "vector" that it is not a vector.  Really the problem comes in when you try to get back B from n.
21:08:05 <roconnor> ddarius: you only can't tell because textbooks are dumb.
21:08:19 <roconnor> then should have never drawn a line with a little arrow on it.
21:08:22 <ddarius> roconnor: Agreed (though probably not in the way you like)
21:08:34 <ddarius> roconnor: Yes, they should have drawn a bivector.
21:08:46 <conal> dons: i just replied to the fieldtrip reddit comment about artists & mutable state.  http://www.reddit.com/r/programming/comments/7cijd/fieldtrip_purely_functional_realtime_3d_graphics/c06ao6w
21:08:48 <lambdabot> Title: wuger comments on FieldTrip: Purely functional real-time 3D graphics using react ..., http://tinyurl.com/4a2fqq
21:09:27 <ddarius> roconnor: To simplify further, what jacks up normal vectors is a particular linear transformation: reflection.
21:09:32 <ChilliX> conal: the way I know you, fieldtrip does everything in a nice and pure way => there should be no fundamental problem in using dph with it
21:10:23 <dons> ChilliX: yes, i think that is right. no compromise on elegance and purity. so seems a natural fit.
21:10:25 * luqui well conal's pure and haskell's pure sometimes disagree...
21:10:27 <ChilliX> conal: probably more a problem of scale at the moment; ie, dph code generation is poor for more complex computations right now
21:10:37 <mmorrow> @pl \f a -> (\(b, k) a -> k (a, b)) (f a) a
21:10:37 <lambdabot> (uncurry (flip (.) . flip (,)) =<<)
21:10:40 <conal> dons: i've heard this argument (why mutation is natural or inevitable for authoring) as long as i've been doing functional graphics (since 1990).  a few years ago, it hit me that the problem is thinking of authoring/modeling as running program rather than creating/editing one.  the insight that modeling==programming is what led to Eros.
21:10:40 <hackage> Uploaded to hackage: flickr 0.2.1
21:10:40 <hackage> Uploaded to hackage: flickr 0.2
21:10:40 <hackage> Uploaded to hackage: HStringTemplate 0.4.1
21:10:42 <ddarius> Reflection swaps the two pseudoscalars and thus to undualize n to get back B that n represented you need to use a different duality (differing by a sign)
21:11:07 <conal> ChilliX: i'm happy to start small.
21:11:10 <ddarius> roconnor: That's what I meant by the problem only actually comes in when trying to get B back to n.
21:12:00 <mmorrow> @let eat = (uncurry (flip (.) . flip (,)) =<<) :: (a -> (b, ((a, b) -> r))) -> a -> r
21:12:02 <lambdabot>  Defined.
21:12:04 <roconnor> ddarius: Oh I see.  You are not considering anisotropic scaling.
21:12:28 <roconnor> er, not even considering ...
21:12:37 <roconnor> because it isn't a GA operation
21:13:38 <askentasken> vector-space-0.5 failed during the building phase. The exception was:
21:13:39 <askentasken> exit: ExitFailure 1
21:13:39 <askentasken> saftarn@SAFTARN-PC ~
21:13:39 <askentasken> $
21:13:56 <askentasken> anyone can hint?
21:14:01 <ChilliX> conal: I am pretty snowed under at the moment, but I'd be happy to have a look at what sort of computations you need for fieldtrip and how they'd map to dph in a few weeks (we have the summer break coming up, where things get much quiter)
21:14:02 <mmorrow> @pl \k f (a, b) -> a : k (f a b)
21:14:03 <lambdabot> flip flip snd . (ap .) . flip flip fst . (((.) . liftM2 (.) (:)) .) . (.) . (.)
21:14:07 <dons> askentasken: which version of ghc?
21:14:15 <dons> askentasken: you'll need ghc 6.10.
21:14:26 <dons> (which also has a newer cabal which emits a better error message)
21:14:29 <conal> ChilliX: sounds good.  no hurry on my part.
21:15:03 <mmorrow> @pl \k f (a, b) -> b : k (f a b)
21:15:04 <lambdabot> flip flip snd . (ap .) . flip flip fst . (((.) . (ap (:) .)) .) . (.) . (.)
21:15:15 <ChilliX> conal: just nudge me if you don't hear from me about it in say the first week of dec
21:15:20 <zloog> So if I did something stupid like type repeat Nothing into ghci, how would I get that t stop?
21:15:30 <mmorrow> @let step k f (a, b) = b : k (f a b)
21:15:31 <lambdabot>  Defined.
21:15:40 <dons> conal: another cute idea, take siggy's flickr photo bindings released just now, and use them to animate someone's photos in a nice way. would be a cute demo. :)
21:15:45 <luqui> zloog, control C usually works
21:15:50 <ddarius> roconnor: Anisotropic scaling is symmetric, so for M being a matrix performing anisotropic scaling it is equal to it's transpose so Mn = nM
21:16:01 <zloog> luqui: I'm in emacs also. Will give it a try
21:16:16 <zloog> hrm, that worked
21:16:17 <luqui> zloog, oh, i have no experience with using haskell on that OS.
21:16:19 <zloog> but it didnt last night
21:16:36 <luqui> depending on what you're doing, you might have to mash it a bit...
21:16:45 <zloog> yea
21:16:46 <luqui> at least that happens to me.  I'm not sure why.
21:17:01 <conal> dons: boundless possibilities ...
21:17:49 <roconnor> ddarius: oh, sorry.  inverse transpose?
21:18:25 <roconnor> hmmm
21:18:50 <mmorrow> > let go a = (a+1, step (eat go) (*)) in eat go 1
21:18:51 <lambdabot>   [2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,128649386...
21:18:58 <mmorrow> hmm
21:20:29 <mmorrow> > let go a = (a, step (eat go) (+)) in eat go 1
21:20:30 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
21:21:51 <Twey> ...
21:21:59 <Twey> @src eat
21:22:00 <lambdabot> Source not found. :(
21:22:07 <Twey> What is 'eat'?
21:22:12 <mmorrow> eat f a = let (b, k) = f a in k (a, b)
21:22:22 <mmorrow> or
21:22:30 <mmorrow> @pl \f a -> (\(b, k) a -> k (a, b)) (f a) a
21:22:30 <lambdabot> (uncurry (flip (.) . flip (,)) =<<)
21:22:32 <mmorrow> heh
21:22:35 <shapr> 5ow
21:23:18 <ddarius> roconnor: I don't believe there should be any problem with anisotropic scalings except for ones that include a reflection (i.e. have det < 0)
21:23:34 <Twey> I don't understand
21:23:36 <Twey> How does the list get there?
21:23:43 <mmorrow> oh, that's from step
21:23:52 <mmorrow> step k f (a, b) = b : k (f a b)
21:23:58 <Twey> Oh, right
21:24:14 <mmorrow> step was an afterthought, and i'm not sure if i like it
21:25:04 <mmorrow> well, it's not that "i don't like it", but that i was just trying to do fib and realized i can't do it with step
21:25:59 <mmorrow> but then again, i'm not really aiming for anything here ;)
21:27:13 <roconnor> 0 = x . y = x^T y = x^T M^-1 M y = M^-1^T x . M y
21:27:29 <roconnor> mmorrow: right covectors are transformed by the inverse transpose.
21:27:50 <roconnor> mmorrow: which is interesting
21:27:56 <roconnor> er
21:28:05 <roconnor> mmorrow: sorry, that was for ddarius
21:29:01 <jdrake> Why does Haskell hate me? Couldn't match expected type `Integer' against inferred type `Int'   (7 - a1) is the part it hates
21:29:04 * roconnor reflects some more on bivectors vs covectors.
21:29:51 <luqui> jdrake, you need a fromIntegral somewhere
21:30:18 <luqui> jdrake, 7 - a1 is fine no matter what numeric type a1 is, the problem comes from some larger context
21:30:38 <jdrake> luqui: first question: Do you suspect the 7 or the a1, or the combined total? second question: why
21:30:41 <luqui> but 7 - fromIntegral a1 or fromIntegral (7 - a1) will probably do the trick
21:30:52 <luqui> jdrake, okay, so let's say a1 has type Int
21:30:57 <luqui> then 7 - a1 has type Int also
21:31:04 <luqui> if you're expecting and Integer, there will be a type error
21:31:26 <jdrake> oh that is my own doing
21:31:26 <luqui> this discourse remains true if you interchange the roles of "Int" and "Integer"
21:31:36 <jdrake> My constructor: Heading Integer String
21:31:40 <askentasken> 6.8.3
21:31:52 <jdrake> I can probably change that Integer to something better
21:31:52 <askentasken> dons: aha 6.10
21:32:02 <luqui> jdrake, what is it supposed to represent?
21:32:12 <sw17ch> is there some place that I can lookup the #define's that GHC sets up during the compilation process?
21:32:14 <askentasken> what is flickr, somehting to do witht he site flicker?
21:32:58 <jdrake> luqui: a number, specifically a header number 1 to 5
21:33:31 <luqui> jdrake, Integer is certainly overkill in that case ;-)
21:33:52 <askentasken> no 6.10 for windows?
21:33:53 <jdrake> luqui: I just did what seemed natural, I do not know the differences
21:34:03 <askentasken> can  apt-get 6.10 on ubuntu?
21:34:17 <luqui> jdrake, oh, Int is a 32 bit integer that wraps around, Integer is an arbitrary-precision integer which does things like
21:34:22 <luqui> > 2^897+1
21:34:24 <lambdabot>   105658906227133049270467956983303321303769465207224304425592141805334780511...
21:34:55 <luqui> (technically Int might not be all 32 bits.  I think 28 is all that is required, but most impls go for 32 bits)
21:35:37 <luqui> > 2^897+1 :: Int
21:35:39 <lambdabot>   1
21:36:47 <jdrake> luqui: thank you. Me and my first parser thank you
21:36:56 <luqui> :-)
21:37:21 <Riastradh> 32-bit Ints are difficult to implement efficiently on a 32-bit machine.
21:37:45 <Riastradh> In GHC, Ints have thirty-one bits including sign:
21:37:48 <Riastradh> > 2^31 :: Int
21:37:49 <lambdabot>   2147483648
21:37:52 <jdrake> Hey Riastradh I haven't seen you in ages
21:37:53 <Riastradh> Hmmm.
21:37:59 <Riastradh> > 2^63 :: Int
21:37:59 <luqui> Riastradh, fail!  =P
21:38:00 <lambdabot>   -9223372036854775808
21:38:03 <Riastradh> That's better.
21:38:05 <luqui> oh
21:38:05 <Twey> Heh
21:38:09 <Twey> > maxBound :: Int
21:38:10 <lambdabot>   9223372036854775807
21:38:13 * ddarius looks back over the conversation to see what we were talking about.
21:38:13 <twb> Does cabal know not to re-build a .o if its dependencies are unchanged?
21:38:37 <roconnor> ddarius: when conal applies the linear transformation (2*) to a normal vector, should it grow by a factor of 4 or grow by a factor (1/2) (aka shrink) or something else?
21:38:38 <luqui> wait
21:38:49 <Twey> Hmn, what's that?
21:38:58 <luqui> > (2^64, 2^63) :: (Int,Int)
21:38:59 <lambdabot>   (0,-9223372036854775808)
21:39:05 <luqui> that looks like 64 bits to me
21:39:15 <Riastradh> Yes, luqui.  Presumably lambdabot is running on a 64-bit machine.
21:39:20 <roconnor> > bitSize 0
21:39:21 <lambdabot>   Add a type signature
21:39:22 <luqui> I mean as opposed to 63
21:39:34 <roconnor> > bitSize (0::Int)
21:39:36 <lambdabot>   64
21:39:46 <roconnor> > bitSize (undefined::Int)
21:39:47 <lambdabot>   64
21:39:49 <Riastradh> No, that's sixty-three bits including sign.
21:39:55 <ddarius> roconnor: Let me put it another way.  Using normal vectors as vectors is fine, you just need to make sure you transform the pseudoscalar equivalently.  If you do that, then when you transform back to the bivector you will have all those relevant changes.
21:39:57 <roconnor> > fix bitSize
21:39:57 <luqui> Riastradh, you mean not including sign.
21:39:58 <lambdabot>   64
21:40:10 <luqui> Riastradh, I think we are in violent agreement, just disagreeing about the meaning of "including" :-)
21:40:34 <lucca> > bitSize [0::Int]
21:40:35 <lambdabot>       No instance for (Bits [Int])
21:40:36 <lambdabot>        arising from a use of `bitSize' at ...
21:40:42 <roconnor> ddarius: oh
21:41:00 <idnar> @type bitSize
21:41:00 <roconnor> ddarius: so you use the pseudoscaler to help determine what is outside and what is inside
21:41:01 <lambdabot> forall a. (Bits a) => a -> Int
21:41:12 <Riastradh> > (2^64 :: Integer, 2^63 :: Integer, 2^63 :: Int)
21:41:13 <lambdabot>   (18446744073709551616,9223372036854775808,-9223372036854775808)
21:41:20 <idnar> @type fix
21:41:22 <lambdabot> forall a. (a -> a) -> a
21:41:22 * sw17ch goes to bed
21:41:30 <idnar> oh
21:41:38 <idnar> heh
21:41:40 <Twey> Aye, that's the one
21:41:54 <ddarius> roconnor: Stated this way, there really isn't anything special about reflection except that it is very easy to lose track of orientation (or rather not realize you need to keep track.)
21:41:55 <jdrake> How do you go from a floating to an integral?
21:42:10 <Twey> jdrake: round
21:42:10 <luqui> jdrake, floor, cieling, or round
21:42:17 <ddarius> roconnor: The choice of (normalized) pseudoscalar is the choice of handedness.
21:42:19 <roconnor> ddarius: so, what does this mean for fieldtrip and pseduoscalers?
21:42:20 <lucca> > (2^63-1)::Int
21:42:21 <lambdabot>   9223372036854775807
21:42:25 <Twey> Or ceiling, or floor.
21:42:33 <lucca> definitely using all 64bits for number-and-sign
21:42:37 <Riastradh> I see.
21:42:50 <lucca> it is the spineless Tagless Gmachine, after all, right?
21:42:51 <jdrake> How about an integral to a floating?
21:42:57 <ddarius> roconnor: Nothing that we haven't already said.
21:43:03 <luqui> jdrake, fromIntegral works for that
21:43:17 <luqui> jdrake, fromIntegral converts from an integral type to any numeric type
21:43:35 <roconnor> ddarius: but conal has no pseudoscaler type.
21:44:11 <ddarius> roconnor: One can either have a normal "vector" type distinct from vectors (because it depends implicitly on the pseudoscalar), or you could use bivectors directly which (if you want a normal vector then) would require an explicit use of the pseudoscalar.
21:44:31 <RayNbow> it makes me sad that people think that by replacing the last syllable with "ii" will give you a plural form :/
21:44:35 <ddarius> I prefer the latter.
21:45:01 <roconnor> ddarius: I don't see the difference.
21:45:26 <roconnor> ddarius: probably because I don't understand the first.
21:45:49 <ddarius> roconnor: bivectors are handy for other reasons and they scale to arbitrary dimensions (well not 1 but...)
21:45:54 <luqui> RayNbow, you mean like radii?  is it not so?
21:46:04 <ddarius> roconnor: Normal "vectors" are a hack in 3D.
21:46:11 <roconnor> ddarius: right
21:46:22 <roconnor> ddarius: the first choice isn't a choice.  It is plainly broken
21:46:24 <luqui> just like cross products.  hmm, the two are related :-)
21:46:37 <ddarius> roconnor: The first choice would work, it's just hacky.
21:46:59 <ddarius> and my parens close early in the second alternative.
21:47:01 <RayNbow> luqui: plural of radius is radii
21:47:11 <roconnor> ddarius: so what would the effect of apply a linear trasnformation to a normal "vector" be ... other than wrong?
21:47:11 <ddarius> You only need the pseudoscalar if you want normal vectors.
21:47:15 <RayNbow> but that form is obtained by replacing -us with -i
21:47:25 <luqui> RayNbow, ah
21:47:27 <jdrake> > round $ (log $ fromIntegral (maxBound :: Int)) / (log 2)
21:47:29 <lambdabot>   63
21:47:30 <RayNbow> I just saw someone on reddit typing "torii"
21:47:38 <luqui> ew
21:47:45 <jdrake> My answer for the previous question :p
21:47:55 <ddarius> roconnor: It would be what you said, applying a linear transformation to a normal "vector" would use the rule for transforming normal vectors, not the rule for vectors.
21:47:58 * RayNbow also cringes everytime he sees "virii" and "penii" :X
21:48:13 <roconnor> ddarius: and what would that rule be?
21:48:38 <luqui> lol penii.  never seen that...
21:48:39 <RayNbow> (virus doesn't have a foreign plural form, so it's just viruses... and the correct Latin plural form of penis is penes...)
21:48:52 <RayNbow> luqui: I unfortunately have :p
21:49:02 <luqui> octopodes!
21:49:04 <RayNbow> anyway, got a train to catch, bye all :)
21:54:53 <mib_o7ks29> anyone know where i can get some comprehensive note on binary trees in haskell
21:54:55 * roconnor tries to remember how the dualization operation and contractions work again
21:54:55 <mib_o7ks29> ??
21:54:59 <askentasken> is it good to install in C/ghc/ghc10 instead of C/ghc10
21:55:03 <askentasken> ?
21:55:06 <jdrake> Parser question: http://hpaste.org/11927#a2 I need to make sure a1 and a2 equal and between 1 and 5, but I am not sure how I can throw the error (presumably with <?>) Any ideas? Also, I accept input on how to make this look better.
21:57:41 <conal> roconnor: i just read your tickets on http://trac.haskell.org/fieldtrip/report/1.  great input!  thanks much.  i hope you & others will help me straighten out this kind of thing.
21:57:41 <lambdabot> Title: {1} Active Tickets - fieldtrip - Trac
21:58:27 <necrobious> I am successfully using the zlib bindings, and am now trying to trap any errors that might occur during decompression of the source ByteString. the type sig: decompress :: ByteString -> ByteString does not happen within IO so using catch wont work unless I move the code that uses decompress into IO.  Is there any other way to trap an error from outside IO? Ideally I would like to say: decompress :: ByteString -> Maybe ByteString
22:00:45 <blackdog> ChilliX: (much much later) yes, that would be fantastic
22:05:29 <lucca> > length $ takeWhile (>= 0) [(2^x-1)::Int | x <- [0..]]
22:05:30 <lambdabot>   64
22:07:25 <ddarius> roconnor: Christ I spent a long time running in circles for something obvious.  n = BI, so "f"(n) = f(BI) = f^T^-1(B)f^T^-1(I)
22:08:02 <ddarius> So if we "intended" to actually apply f to B then we need, as you had, to apply f^T^-1 to n.
22:10:35 <ddarius> Actually, I have an error.
22:11:44 <ddarius> f(n) = f(BI) = f^T^-1(B)f^-1(I)
22:12:09 <ddarius> f(n) = f(BI) = f^T^-1(B)f(I) -- final try
22:12:21 <zloog> :t range
22:12:22 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
22:17:44 <jdrake> @src label
22:17:45 <lambdabot> Source not found. I am sorry.
22:59:02 <pumpkin_> anyone here used TAO (the toolkit for advanced optimization)?
23:01:56 <roconnor> ddarius: why isn't f(BI) = f(B)f(I) ?
23:07:31 <roconnor> ddarius: and shouldn't n = B(I^-1) ?
23:11:38 <roconnor> er I guess n = B_| I~
23:17:16 <roconnor> ah f(B _| I~) = f^T^-1(B) _| f(I~)
23:52:42 <mofmog> How did wadler manage to get accent marks on pi
23:52:54 <mofmog> i believe those are the secret of monads
23:52:58 * Twey laughs.
23:53:18 <Twey> The joys of combining diacritics
23:55:30 <Twey> π̉
23:57:04 <fons> hi all
23:59:58 <fons> quick question, I want to cyclically launch a set of process in parallel
