00:01:10 <Axman6> @hoogle permut
00:01:10 <lambdabot> package permutation
00:01:10 <lambdabot> System.Console.GetOpt Permute :: ArgOrder a
00:01:10 <lambdabot> Text.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
00:03:25 <twb> Where is the documentation for the Cabal API, for writing Setup.hs?
00:03:40 <twb> Specifically I want to understand simpleProgram
00:05:52 <Axman6> @hoogle (Bits a) => a -> [Bool]
00:05:53 <lambdabot> Data.Bits isSigned :: Bits a => a -> Bool
00:05:53 <lambdabot> Prelude repeat :: a -> [a]
00:05:53 <lambdabot> Data.List repeat :: a -> [a]
00:06:22 <Axman6> @hoogle base
00:06:23 <lambdabot> package base
00:06:23 <lambdabot> Text.XHtml.Frameset base :: String -> HtmlAttr
00:06:23 <lambdabot> Text.XHtml.Strict base :: String -> HtmlAttr
00:06:31 <Axman6> @hoogle showBase
00:06:31 <lambdabot> No results found
00:06:35 <Axman6> hmm
00:07:17 <Axman6> > showIntAtBase 2 10
00:07:18 <lambdabot>       Overlapping instances for Show (t -> String -> String)
00:07:18 <lambdabot>        arising f...
00:07:34 <Baughn> twb: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html <-- Here, the Distribution hierarchy
00:07:35 <lambdabot> Title: Haskell Hierarchical Libraries
00:07:53 <Twey> :t showIntAtBase
00:07:54 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
00:07:55 <Twey> It takes more arguments.
00:08:01 <Axman6> yes... hmm
00:08:04 <twb> Thanks; I was trying to hoogle for "Distribution"
00:08:07 <BeelsebobWork> Has anyone managed to sort out the ghc-6.10.1 and GLUT issues?
00:08:09 <BeelsebobWork> I'm getting user error (unknown GLUT call glutSetOption, check for freeglut)
00:08:28 <chylli> can someone help me to look for the error ? http://hpaste.org/12159
00:08:34 <Axman6> BeelsebobWork: conal had a fix, not sure if he's done anything with it though
00:08:46 <chylli> I got error : Parse error in patten
00:08:48 <BeelsebobWork> yeh, I know he does -- but he's not gonna be online untl this evening
00:08:50 <Axman6> i used it, but can;t remember what it was. just commenting out a line somewhere
00:08:53 <BeelsebobWork> nor camio, who also does
00:09:48 <jsn> chylli: which line is the error on?
00:10:02 <chylli> jsn: line 11
00:10:10 <chylli> jsn: sorry
00:10:16 <chylli> jsn: this line : packResult r:rs = case r of
00:10:16 <chylli>  
00:11:15 <jsn> chylli: correction is     packResult  (r:rs) = case r of
00:11:26 <chylli> jsn: oh !!!
00:11:32 <chylli> jsn: thanks !!!!
00:20:35 <BeelsebobWork> hmm, given the output of a psudo-random-number generator, it's close to impossible to predict the next value... but, suppose that the seed is not split from the previous random, but instead, is a monotonically increasing value, do we know anything about the output of the random number generataro?
00:20:37 <BeelsebobWork> i assume we do
00:55:36 <askentasken> if i have a data Rock and it is deriving show and i take a string as input, can i convert String -> Rock ?
00:56:11 <Twey> askentasken: No ‚Äî for that you need to derive Read
00:57:43 <askentasken> ok but read "Rock" deosnt work(i have derived read, thats what i mean t write before)
00:58:02 <Twey> It does with the proper type
00:58:09 <Twey> read "Rock" :: Rock
01:01:14 <vegai> STM TChan seems to have quite an overhead vs Chan
01:01:29 <vegai> I did a simple benchmark where 10 threads write to a chan and one reads
01:01:42 <vegai> with TChan, I got about 7700 msg/second
01:01:53 <vegai> with Chan, about 601832 msg/second
01:02:35 <vegai> no silver bullet again :-)
01:05:37 <askentasken> is there not a simple method that takes a list, value and index and returns a new list replacing the old value @ index? like: update [1,2,3] 1 5 -> [1,5,3] ?
01:05:57 <chylli> I has import System.Exit, but still got error : test/test1.hs:9:33: Not in scope: `exitSuccess', why ?
01:06:27 <papermachine> askentasken: update is expensive on lists
01:07:14 <therp> askentasken: probably you like to use arrays?
01:07:30 <askentasken> are Chans all threads? how do i use multiple processes? is the actor library using processes?
01:07:30 <askentasken> ?hoogle [a] -> Int -> a -> [a]
01:07:30 <askentasken> can i dot hat?
01:07:30 <askentasken> papermachine, it is only a 3 -elem list for tictactoe
01:07:30 <askentasken> updateL xs val index = take index xs ++ [val] ++ drop (index+1) xs
01:07:30 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
01:07:30 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
01:07:30 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
01:07:31 <askentasken> is ugly
01:07:41 <askentasken> therp: no
01:07:47 <Twey> askentasken: Arrays are preferable for that sort of operation
01:08:07 <Twey> It's not defined on lists because if you find yourself doing it with a list, you're probably Doing It Wrong¬Æ.
01:08:18 <vegai> askentasken: chans are channels. Essentially FIFO buffers if I understood correctly
01:08:28 <Twey> Yep
01:08:52 <cpfr> hey is anyone fit to answer a parsec question?
01:09:18 <vegai> cpfr: heh.
01:09:25 <cpfr> hey vegai
01:09:49 <cpfr> how are ya
01:10:05 <vegai> well, it's just
01:10:07 <vegai> @users
01:10:07 <lambdabot> Maximum users seen in #haskell: 550, currently: 494 (89.8%), active: 13 (2.6%)
01:10:29 <cpfr> hehe
01:11:09 <vegai> I wonder when I would even need a TChan
01:11:24 <cpfr> http://hpaste.org/12161
01:11:32 <cpfr> im not sure what i am doing wrong
01:12:08 <askentasken> but i hate working with Haskell datstructures, lists are the only ones that are nice to work with. Clojure has immutable functional datatsurctures as well and they are a dream to work with
01:12:11 <vegai> you need a do block on the last line, I think
01:12:24 <vegai> <- can be used only inside one
01:12:31 <therp> askentasken: what are functional data structures?
01:12:33 <askentasken> i tireed Data.Array but it was a pain to work with, i didnt get how to even create one, let alone update one
01:13:00 <therp> askentasken: the "gentle introduction into Haskell" has a section on Arrays
01:13:01 <Twey> :t array
01:13:03 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
01:13:20 <Twey> Not hard
01:14:08 <Twey> array (lowerBound, upperBound) [(key1, element1), (key2, element2), ... (keyN, elementN)]
01:14:23 <vegai> why not just "forall i e. (Ix i) => [(i,e)] -> Array i e"
01:14:41 <vegai> the first parameter seems unneeded
01:14:52 <Twey> Performance, I think
01:15:04 <Twey> > array (1, 3) []
01:15:05 <lambdabot>   array (1,3) [(1,* Exception: (Array.!): undefined array element
01:15:19 <Twey> Must just be performance
01:15:21 <Twey> Plus there's listArray
01:15:24 <Twey> :t listArray
01:15:25 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
01:15:52 <Twey> Specifying the bounds first means it can construct the array, then go through the list and add elements
01:16:16 <Twey> Rather than going through the list to find the minimum and maximum keys, construct the array, then go through it again to add each element
01:16:18 <cpfr> thanks vegai that made the errors go away
01:18:32 <vegai> array (600,600) [(0,0)..]
01:18:41 <vegai> just need to add instance Enum (t, t1) ...
01:19:04 <Twey> That's handy, too
01:19:19 <Twey> (although your syntax in this case is wrong)
01:19:28 <quicksilver> vegai: Enum?
01:19:37 <Twey> (600, 600) means 'from 600 to 600'
01:19:43 <quicksilver> there is an Ix instance for (a,b)
01:19:43 <Twey> I.E. an empty array
01:19:49 <quicksilver> Enum isn't really used for arrays.
01:20:04 <vegai> oh, right
01:20:10 <vegai> quicksilver: but for sequences?
01:20:21 <vegai> the mystical '..' operator
01:20:23 <quicksilver> ah
01:20:27 <quicksilver> yes, that's not going to work
01:20:37 <quicksilver> how would it know when to stop increasing the left index and start the right?
01:20:56 <vegai> oh, I was just thinking of initializing the array with empty elements
01:21:00 <quicksilver> > range ((0,0),(5,5))
01:21:02 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(2...
01:21:03 <vegai> that can probably done a bit easier too?
01:21:11 <quicksilver> range is part of Ix
01:21:23 <vegai> ok
01:23:03 <Twey> > array ((0, 0), (600, 600)) . zip (range ((0, 0), (600, 600))) $ repeat Nothing
01:23:07 <lambdabot>   array ((0,0),(600,600)) [((0,0),Nothing),((0,1),Nothing),((0,2),Nothing),((...
01:23:33 <sjanssen> > listArray ((0, 0), (600, 600)) $ repeat Nothing
01:23:34 <lambdabot>   array ((0,0),(600,600)) [((0,0),Nothing),((0,1),Nothing),((0,2),Nothing),((...
01:23:40 <sjanssen> listArray ftw
01:23:48 <Twey> Easier, aye.  :)
01:23:50 <sjanssen> @src listArray
01:23:50 <lambdabot> Source not found. stty: unknown mode: doofus
01:24:04 <Twey> Haha
01:26:02 <sjanssen> just as well, the listArray source is insanely low level
01:26:46 <Twey> How so?
01:28:12 <sjanssen> Twey: uses unboxed ints, all sorts of low level GHC primitives
01:28:23 <Twey> Ouch
01:28:46 <sjanssen> -- This is inefficient and I'm not sure why:
01:28:47 <sjanssen> -- listArray (l,u) es = unsafeArray (l,u) (zip [0 .. rangeSize (l,u) - 1] es)
01:28:51 <sjanssen> comments from the code
01:29:08 <Twey> Nice :-P
01:31:46 <sjanssen> there are also comments about how listArray doesn't fuse
01:31:52 <sjanssen> interestingly, array does fuse
01:33:45 <quicksilver> sjanssen: it would be very nice to tidy up the low-level stuff, standardise on just a small number of low-level types (e.g. ByteArray# and MutableByteArray#)
01:34:02 <quicksilver> sjanssen: then it would be easier to port to new compilers, they'd just have a couple of things to implement.
01:34:24 <quicksilver> I'd like to know if ByteString still has to use ForeignPtr
01:34:31 <quicksilver> or if ByteArray# would work as well, now.
01:34:46 <askentasken> but how do i update an array?
01:34:46 <askentasken> Data.Array.array (1,9) [(i, 0) | i <- [1..9]]
01:34:46 <askentasken> array (1,9) [(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0)]
01:34:46 <askentasken> now return a new array with (3,0) being (3,1)
01:35:02 <sjanssen> askentasken: Data.Array.\\
01:35:12 <quicksilver> askentasken: Data.Array is immutable, though, so that's building a new array.
01:35:44 <sjanssen> askentasken: note that it is O(n) wrt. the size of the array, you won't want to update arrays frequently
01:36:30 <sjanssen> quicksilver: the compiler would also need to support ST (or use IO for less safety)
01:36:44 <Twey> I guess a mutable array would be more appropriate
01:36:47 <Twey> What is ST?
01:37:01 <sjanssen> @docs Control.Monad.ST
01:37:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
01:37:24 <askentasken> but then it is the same a slist
01:37:24 <askentasken> in Python , xs = [1,2,3], xs[2]=5 is O(1)
01:37:24 <askentasken> so where is mutale array?
01:37:53 <Twey> askentasken: That's because Python lists are actually arrays
01:37:57 <quicksilver> Data.Array.MArray
01:38:02 <sjanssen> Twey: a monad that has references and mutable arrays -- basically IO without access to IO and FFI
01:38:05 <Twey> (so consing can hurt)
01:38:14 <Twey> sjanssen: Oho
01:38:23 <sjanssen> askentasken: probably you want to use Data.Map instead
01:38:30 <sjanssen> arrays are not used very often in Haskell
01:39:28 <askentasken> sigh
01:39:48 <askentasken> Twey: yes but how do i use array for O(1) updating?
01:40:00 <quicksilver> for O(1) updating you use a mutable array.
01:40:04 <quicksilver> but note that O(1) is a lie.
01:40:16 <quicksilver> and Map and Sequence both have O(log n) updating.
01:40:18 <Twey> Isn't Data.Map also O(n) for updates?
01:40:26 <sjanssen> Twey: no
01:40:27 <Twey> Oh, O(log n)
01:40:43 <askentasken> A.\\ doesnt work
01:41:06 <sjanssen> well, it actually is O(n), since O(log n) is a subset of O(n) :)
01:41:27 <quicksilver> http://haskell.org/tutorial/arrays.html
01:41:28 <lambdabot> Title: A Gentle Introduction to Haskell: Arrays
01:41:31 <quicksilver> http://www.haskell.org/haskellwiki/Modern_array_libraries
01:41:34 <lambdabot> Title: Arrays - HaskellWiki
01:41:38 <quicksilver> askentasken: those two links should clear it up.
01:41:49 <quicksilver> there are actually hundreds of array libraries in haskell.
01:42:02 <quicksilver> But I never use any of them, because I never need arrays.
01:42:14 <ivanm> quicksilver: really? I don't recall seeing that many on hackage...
01:42:19 <sjanssen> best advice regarding arrays and Haskell: you probably don't need them
01:42:44 <Axman6> handy for memoisation sometimes
01:43:30 <ivanm> sjanssen: oh? why not?
01:43:42 <askentasken> eh?
01:43:42 <askentasken> then it is all O(N*N) then?
01:43:43 <ivanm> if you're doing index-based calculations, aren't they better than lists?
01:43:51 * earthy has had multiple ocurrencess where using arrays sped up his code *considerably*
01:44:24 <sjanssen> ivanm: numerous reasons: O(1) is overrated, most applications require reasonable fast updates
01:44:28 <earthy> but they can be annoying to work with.
01:44:36 <sjanssen> note I said "probably".  There are occasions where they're useful
01:44:45 <earthy> to wit:  elems $ listArray (1,1) []
01:44:54 <askentasken> the \\ stuff, can someone give example? doesnt work for me
01:45:17 <earthy> now imagine the elems and the listArray to be separated by a lot of code
01:45:19 <sjanssen> > listArray (1, 2) "ab" \\ [(1, 'x')]
01:45:20 <lambdabot>   Couldn't match expected type `[a]'
01:45:31 <sjanssen> > listArray (1, 2) "ab" // [(1, 'x')]
01:45:32 <lambdabot>   array (1,2) [(1,'x'),(2,'b')]
01:45:43 <sjanssen> askentasken: sorry, it's //, not \\
01:45:49 <sjanssen> I always confuse those
01:45:50 <earthy> and then figure out where the error is...
01:45:57 <earthy> > elems $ listArray (1,1) []
01:45:58 <lambdabot>   [* Exception: (Array.!): undefined array element
01:46:06 <earthy> (no ! in sight)
01:46:28 <arw> sjanssen: O(1) is extremely important. its the difference between beeing usable with large datasets and beeing basically broken.
01:46:39 <earthy> arw: exactly
01:46:42 <quicksilver> arw: rubbish.
01:46:44 <sjanssen> arw: did you know there is no such thing as O(1)?
01:46:52 <quicksilver> O(1) and O(log n) are only a constant factor apart.
01:46:55 <quicksilver> because they're the same.
01:47:06 <quicksilver> so actually, it's the constant factor you're measuring.
01:47:16 <arw> quicksilver: log n is not constant.
01:47:17 <quicksilver> C arrays have a very low constant factor (if that's what you're comparing to)
01:47:18 <earthy> well, the size of n changes with arrays from number of elements to length of key
01:47:27 <quicksilver> arw: there is no O(1).
01:47:29 <earthy> this is *very* important.
01:47:32 <quicksilver> arw: all O(1) is actually log(n)
01:47:33 <askentasken> is tillget error
01:47:33 <askentasken> is there no cond in Haskell?
01:47:33 <askentasken> import qualified Data.Array as A
01:47:33 <askentasken> new a val at = A.// a val at
01:47:33 <askentasken> parse error on input `//'
01:47:52 <sjanssen> askentasken: // is an infix operator
01:47:56 <quicksilver> askentasken: // is an infix operator.
01:48:08 <arw> quicksilver: not quite, its much more complicated than that actually.
01:48:08 <askentasken> quick: how do you mean?
01:48:19 <earthy> new a val at = (A.//) a val at
01:48:27 <quicksilver> arw: I don't think it is.
01:48:36 <earthy> but that'd still be wrong
01:48:49 <quicksilver> arw: array access requires O(number of bits) operations to locate the bit of array to access
01:48:53 <quicksilver> number of bits ~ log n
01:48:54 <earthy> as Array.// takes 2 arguments, one of which is a tuple
01:49:02 <arw> quicksilver: there are cache-effects, cost of address calculation, paging, etc. if you take that into account, there is no O(1).
01:49:05 <sjanssen> s/tuple/list of tuples
01:49:22 <earthy> right, in my applications I've never needed updatable arrays
01:49:32 <quicksilver> arw: if you take those into account then O(1) is even worse, yes.
01:49:38 <Twey> new a val at = a A.// [(at, val)]
01:49:38 <quicksilver> arw: even without those it's still O(log n)
01:49:43 <askentasken> you have brd = A.array (1,9) [(i, 0) | i <- [1..9]]
01:49:49 <earthy> (always just generated them using listArray from a list read in and then only needed to access)
01:49:53 <askentasken> how do you update 0 at index 5 to 9 ?
01:50:12 <quicksilver> ivanm: to answer your question from some time ago: Data.Map and Data.Sequence have comparable speed and more convenient interfaces.
01:50:25 <Twey> askentasken: brd A.// [(5, 9)]
01:50:56 <arw> quicksilver: nope. within your constant memory-range of the computer below your desk, there is an upper bound for accessing any bit of memory, even when you take all those nasty effects into account.
01:51:10 <earthy> brd A.// [(n,1) | n <- [5..9]]
01:51:16 <ivanm> quicksilver: I tried switching from array to Map once... the speed was worse :s
01:51:23 <ivanm> haven't touched Sequence though...
01:51:24 <quicksilver> arw: withing the constant memory-range of the computer below my desk EVERYTHING has an upper bound.
01:51:34 <Deewiant> ivanm: did you try IntMap?
01:51:35 <quicksilver> arw: so by that argument, everything is O(constant)
01:51:44 <ivanm> Deewiant: I needed a 2D 'array'
01:51:48 <Deewiant> ah
01:51:51 <ivanm> so IntMap wasn't suitable
01:52:01 <quicksilver> ivanm: yeah, it will be slower.
01:52:07 <Ferdirand> quicksilver: i'd be delighted to hear your reasoning. google won't help me it seems.
01:52:12 <arw> quicksilver: correct. which is the same argument you used to justify O(log n). its bogus, because any address is x bits long, with x beeing constant.
01:52:12 <quicksilver> but the speed is comparable in many applicates and faster in some.
01:52:17 <Twey> ivanm: Switching from Data.Array?
01:52:29 <askentasken> arw: but then ist O(log n) not really logn anyway? so the relation is stillt he same?
01:52:58 <ivanm> Twey: people are proposing that [Int]Map and Sequence are better
01:53:02 <ivanm> but I'm not using arrays atm
01:53:36 <ivanm> my biggest problem with Array is how fugly the interface for updates is
01:53:48 <arw> askentasken: no. for any access to a list or a tree, you basically have log(n) or more array-accesses.
01:53:57 <Twey> 095116 < ivanm> quicksilver: I tried switching from array to Map once... the speed was worse :s
01:54:10 <Twey> ivanm: By 'array', did you mean Data.Array or mutable arrays?
01:54:52 <quicksilver> arw: right; so the point is it is almost impossible to distinguish the complexity classes O(1) and O(log n) in practice.
01:55:05 <arw> quicksilver: wrong. it is easy.
01:55:47 <arw> quicksilver: its only complicated because in the case of arrays there is some special piece of hardware optimized for that case.
01:56:30 <quicksilver> so the difference between O(log n) and O(1) never becomes the reason to choose one structure over another
01:56:33 <flux> quicksilver, wouldn't that reasoning make O(log(n)) actually O(log(log(n))) ?
01:56:36 <ivanm> Twey: UArray
01:56:37 <arw> quicksilver: if your cpu would calculate adresses by manipulating strings of bits you would be right.
01:56:44 <quicksilver> rather the reason becomes their performance in practice.
01:57:06 <quicksilver> and in practice, C-style arrays do have an extremely small constant factor, so that's good.
01:57:10 <flux> in any case, the constant factor for arrays is much less than it is, well, for any other data structure :)
01:57:27 <Twey> Aha
01:57:32 <quicksilver> (although in practice the key reason for that is locality and cache effects. Following pointers inside the cache is cheap)
01:57:33 <sjanssen_> ivanm: UArray has its own special advantages over Data.Map
01:58:12 <sjanssen_> unboxedness pretty much always wins
01:58:50 <quicksilver> flux: depends a little what assumptions you make
01:58:58 <quicksilver> flux: (it would be log n * log n, not log(log n))
01:59:15 <flux> log(x) * log(x) looks funny :)
01:59:32 <flux> (..when including values x < 1.. ;-))
01:59:33 <quicksilver> flux: but note that tree-structures can access data-sets larger than native pointer size
01:59:34 <arw> because thats log(2 x) which is O(log x)
02:00:04 <arw> na. forget that.
02:00:11 <flux> quicksilver, what is there to note? it is exceedingly uncommon to have such large datasets
02:00:19 <quicksilver> no it's not.
02:00:20 * arw goes to get more coffee.
02:00:32 <quicksilver> plenty of people work with > 4G data sets on 32 bit machines
02:00:52 <quicksilver> but if you're even talking about asymptotic complexity, you must be thinking about larger and larger sets
02:00:58 <quicksilver> otherwise it's not asymptotic any more.
02:01:08 <flux> if you go into larger and larger data sets, you want to go into 64 bit anyway
02:01:26 <flux> even I have large data sets, but they stay on the disk :)
02:01:35 <quicksilver> I didn't stay they weren't on the disk.
02:01:50 <quicksilver> they generally are.
02:02:01 <quicksilver> all the computers I own are 32 bit, but they all have bigger than 4G disk drivers
02:02:04 <flux> for on-disk storage you want to use some other data structure than arrays, but I'm not sure how that is relevant here
02:02:17 <quicksilver> it's relevant because we're discussing asymptotics.
02:02:30 <sjanssen> askentasken: what sort of program are you writing that you'd like to use arrays with?
02:02:45 <arw> absolute size is irrelevant if you argue about asymptotic behaviour.
02:02:47 <flux> well, O(log(n)) will not describe in any accurate way that situation
02:03:53 <quicksilver> flux: how not? tree-like on disk structures often have O(log(n)) performance
02:03:56 <quicksilver> B*-trees and so on
02:04:02 <quicksilver> widely used in databases and filesystems
02:05:06 <jsn> how many folks on the channel have actually switched to GHC 6.10 ?
02:05:30 <Deewiant> 1
02:05:34 <Axman6> 1
02:05:44 <flux> quicksilver, so the reason not to use arrays in any application is because b-trees are a good solution for on-disk storage?
02:05:50 * Axman6 assumes there is some summation function running here...
02:06:03 <sjanssen> apparently there is agreement, 1 person has actually switched to GHC 6.10
02:06:14 <jsn> so far, i have not been pleased
02:06:19 <flux> one would hardly use b-trees for in-memory storage (although perhaps it is starting to become a good idea to atleast try..)
02:06:45 <jsn> basically because a lot of little stuff is messed up
02:10:42 <jsn> what is the deal with the editline thing?
02:10:51 <jsn> that seems so gratuitous
02:11:29 <sjanssen> jsn: there are problems with readline's license
02:11:51 <jsn> sjanssen: but they were there a long time ago
02:11:59 <jsn> sjanssen: or they changed the license?
02:12:02 <askentasken> sjanssen: i wrote TicTacToe usin lists, i just find the end results very ugly and big.
02:12:10 <askentasken> like 80 lines of code
02:12:17 <sjanssen> askentasken: for tic-tac-toe, I'd use Data.Map
02:12:56 <sjanssen> askentasken: the lack of a mark state fits very well with Data.Map's sparseness
02:13:24 <sjanssen> jsn: I don't really know the details
02:14:06 <jsn> is there going to be another release, or is this it?
02:14:49 <sjanssen> there have been no indications that this is the last release of GHC ever :)
02:14:49 <Deewiant> jsn: no, that was the ultimate release of GHC. It's optimal, there will never be another. :-P
02:15:13 <jsn> Deewiant: i mean, of 6.10
02:15:46 <Deewiant> probably not
02:15:51 <Deewiant> er
02:15:55 <Deewiant> probably not the last release, that is
02:16:04 <sjanssen> jsn: oh, I'm sure there will be a 6.10.2
02:16:33 <sjanssen> historically, there's always one or two bugfix releases in each series
02:16:40 <jsn> so, how long do we have until we all have to upgrade?
02:16:54 <Deewiant> nobody "has" to upgrade :-P
02:16:58 <arw> "have to upgrade"?
02:17:10 <arw> debian stable still has 6.6.something
02:17:19 <Axman6> jsn: 6.8 made it to 6.8.3 before 6.10 came along
02:18:00 <jsn> arw: well, that is obviously unusable
02:18:23 <arw> never had any problems with it.
02:19:51 <Axman6> jsn: why?
02:20:23 <jsn> Axman6: well, i don't remember any more
02:30:20 <quicksilver> jsn: I am still using 6.6
02:30:25 <quicksilver> it is not remotely unusable.
02:30:31 <quicksilver> it remains eminently usable, in fact.
02:30:40 <quicksilver> Every bit as good a compiler as it was the day it came out ;)
02:30:41 <jsn> quicksilver: oh?
02:31:13 <quicksilver> indeed.
02:32:25 <jsn> quicksilver: well, that is good to know
02:35:54 <mapreduce> > let tautology = tautology in tautology == tautology
02:36:09 <lambdabot>   thread killed
02:51:17 <twb> How do I tell Cabal to print out the description of each flag?
02:53:57 <swiert> cabal --help gives you an overview of commands.
02:54:05 <swiert> cabal build --help gives you a list of flags.
02:56:47 <twb> swiert: that's kind of unintuitive, given that I pass the flags at "cabal configure" time
02:57:09 <twb> Apparently cabal build --help doesn
02:57:15 <twb> Apparently cabal build --help doesn't list flags here.
02:57:33 <twb> Clarification: I'm talking about the flags defined by "flag foo" in foo.cabal
02:57:54 <swiert> twb: ah sorry.
02:58:02 <twb> No problem.  I was unclear.
02:59:30 <swiert> I'm not sure if there's a separate command to do that.
02:59:39 <swiert> I can't find anything at least...
03:10:21 <ertai> does System.IO.Error.catch catches asynchronous exceptions ?
03:13:03 <daf> ertai: what's an asynchronous exception?
03:15:47 <ertai> daf: as in http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
03:15:48 <lambdabot> Title: Control.Exception, http://tinyurl.com/sqmlj
03:16:51 <quicksilver> ertai: System.IO.Error.catch only catches System.IO stuff
03:17:14 <quicksilver> catching everything is kind of deprecated
03:17:25 <quicksilver> are you in 6.8 or 6.10, ertai?
03:17:37 <quicksilver> in 6.8 Control.Exception.catch can catch everything IIRC
03:29:49 <mapreduce> Where can I read about ExpFunctor?  Google is not very helpful so far.
03:30:54 <Deewiant> http://comonad.com/reader/2008/rotten-bananas/ ?
03:31:00 <lambdabot> Title: The Comonad.Reader ¬ª Rotten Bananas
03:31:58 <RayNbow> and that page links to this paper: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.1.7380
03:32:00 <hugo__> hmm
03:32:02 <lambdabot> Title: Bananas in space: Extending fold and unfold to exponential types - CiteSeerX
03:32:07 <hugo__> where can i read about erlang and haskell ?
03:32:22 <hugo__> a comparison of both, and those things
03:33:49 <quicksilver> I've never read an interesting comparison of erlang and haskell
03:34:13 <quicksilver> all the ones I've seen were written by people who were insufficiently expert in one of them to really have an interesting opinion.
03:34:24 <quicksilver> I'd love to read something by someone who actually knew both languages well.
03:34:39 <Ferdirand> i know both not well
03:34:44 <Ferdirand> so my opinion is not biased :)
03:35:04 <hugo__> yes, exactly what im looking for quicksilver
03:35:18 <mapreduce> Erlang's pattern matching is really nice.
03:35:43 <hugo__> i've been to this webdev conference, and erlang showed up quite often on the talks
03:35:52 <hugo__> it made me wonder "why not haskell?" :P
03:36:41 <ski_> @yarr
03:36:43 <lambdabot> I want me grog!
03:37:48 <ski_> > iterate (sin . sqrt) (1/4) !! 3 :: CReal
03:37:55 <lambdabot>   0.7166545133875354668219886981109171614472
03:38:13 <ski_> lambdabot : eh, now you're answering !?
03:38:58 * ski_ still waits for answer in privmsg ..
03:42:14 <mm_freak_>     Could not find module `System.FilePath':
03:42:14 <mm_freak_>       it is hidden (in package Cabal-1.6.0.1)
03:42:18 <ski_> ..
03:42:25 <ski_> > iterate (sin . sqrt) (1/4) !! 4 :: CReal
03:42:28 <mm_freak_> adding "Cabal" to Build-depends doesn't help, any idea?
03:42:40 <lambdabot>   thread killed
03:43:22 <ski_> > showCReal 19 $ iterate (sin . sqrt) (1/4) !! 4
03:43:38 <lambdabot>   thread killed
03:43:40 <Axman6> huh.
03:44:05 <Axman6> > showCReal 20 . sin .sqrt $ 1/4
03:44:08 <lambdabot>   "0.47942553860420300027"
03:44:21 <Axman6> > showCReal 20 . sin .sqrt . sin . sqrt $ 1/4
03:44:24 <lambdabot>   "0.63839066122406130305"
03:44:32 <Axman6> > showCReal 20 . sin .sqrt . sin . sqrt . sin . sqrt $ 1/4
03:44:45 <lambdabot>   "0.71665451338753546682"
03:44:50 <Axman6> > showCReal 20 . sin .sqrt . sin . sqrt . sin . sqrt . sin . sqrt $ 1/4
03:45:05 <lambdabot>   thread killed
03:45:29 <ski_> > showCReal 4 $ iterate (sin . sqrt) (1/4) !! 4
03:45:44 <lambdabot>   thread killed
03:45:51 <Axman6> yeah the thing that killed it takes a long time on my machine
03:47:51 <Axman6> wow, still going...
03:48:42 <mm_freak_> solved:  added 'filepath' instead of 'Cabal' to Build-depends
03:49:22 <quicksilver> Axman6: don't forget lambdabot compiles code
03:49:23 <ski_> i just want `map (showReal d . (iterate (sin . sqrt) (1/4) !!)) [4,5]' possibly for `d' lesser than `40', e.g. `4' would be ok
03:49:39 <quicksilver> Axman6: it may look like ghci but it's much faster.
03:49:49 <quicksilver> (once compile overhead has been passed)
03:49:50 <Axman6> i see
03:49:59 * Axman6 tests compiled version
03:50:42 <twb> I'm looking at a Setup.hs file where buildHook is defined to be a lambda that, as the last thing it does, calls buildHook on simpleUserHooks.
03:51:07 <twb> Now, I need to- wait, no I don't.
03:51:26 <twb> Hmm.
03:57:34 <grom358> hey.. what is the difference been quot and div?
03:58:04 <twb> I imagine that one has a Real domain and the other has an Integer domain, but I'm just extrapolating from other languages
03:58:23 <Axman6> quicksilver: "main = print . showCReal 20 . sin .sqrt . sin . sqrt . sin . sqrt . sin . sqrt $ 1/4"; time ./sin; real	4m10.115s
03:59:11 <monadwr> grom358: Do you own a book?
03:59:19 <ski_> > map (graph (uncurry div &&& uncurry quot)) $ do n <- [16,-16]; d <- [7,-7]; return (n,d)  where  graph f a = (a,f a)
03:59:20 <lambdabot>   [((16,7),(2,2)),((16,-7),(-3,-2)),((-16,7),(-3,-2)),((-16,-7),(2,2))]
03:59:35 <monadwr> grom358: quot implements integer division, discarding remainders.
04:00:07 <monadwr> grom358: div returns how many times the left operand can be divided by the second. n1 `div` n2.
04:00:31 <ski_> both implements integer division, of a sort .. the difference is in how it treats the cases when exactly one of the numerator and the denominator are negative
04:00:52 <grom358> monadwr: no, I just use wikibooks and the real world haskell online book
04:00:58 <Axman6> @src quot
04:00:59 <lambdabot> Source not found. stty: unknown mode: doofus
04:01:01 <Axman6> @src div
04:01:02 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:01:06 <Axman6> @src divMod
04:01:06 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:01:09 <Axman6> rawr
04:01:21 <monadwr> grom358: Please consider getting a book.
04:01:28 <monadwr> grom358: Is haskell your first language?
04:01:46 <grom358> monadwr: no I know c, java, python and php
04:01:47 <ski_> Axman6 : did you get a result for the `CReal' computation ?
04:01:59 <monadwr> ski_: So, what happens when quot evaluates a negative and a non-zero expression?
04:02:00 <Axman6> yeah
04:02:09 <Axman6> but as i said, took 4 minutes
04:02:11 <twb> grom358: ah, so you have some unlearning to do ;-)
04:02:22 <grom358> twb: indeed
04:02:31 <ski_> Axman6 : would you like to share it ?
04:02:34 <monadwr> grom358: How much C/Python do you know?
04:02:43 <monadwr> How long have you been coding, et al.
04:02:46 <Axman6> "0.74900197515027213255"
04:02:56 * ski_ doesn't have `CReal' installed, and don't have time to install it atm ..
04:02:57 <twb> Oops, I meant "range" not "domain" above.
04:03:03 <monadwr> Are you still learning fundamentals, or are you fairly experienced?
04:03:04 <ski_> Axman6 : ty
04:03:07 <grom358> monadwr: been coding for 8 years
04:03:30 <monadwr> grom358: Ah, fairly experienced then -- Functional programming is much like re-learning how to code, from scratch.
04:03:43 <twb> grom358: some people can code their whole lives, and I still have to explain to them why using floating point types to store financial data is Bad Juju
04:03:45 <ski_> (Axman6 : i suppose asking about the `iterate (sin . sqrt) (1/4) !! 5' case would be too much to ask for ?)
04:03:58 <monadwr> Afaik, it helps you write better imperative coding, as well; Please look at: www.learnyouahaskell.com
04:03:59 <grom358> twb: yeah a lot of ppl don't know about that one
04:04:03 <Axman6> ski_: nope, i can run that now. but be prepared for it to be a while
04:04:07 <monadwr> grom358: You may want to also get RWH.
04:04:15 <twb> Yes, indeedy
04:04:24 <twb> RWH is super happy lucky fun win
04:04:44 <monadwr> I just started haskell as well; its good to see that its popularity increases at an unimaginable rate.
04:04:46 <grom358> is the published one much different to the online one?
04:05:13 <monadwr> grom358: I have only lyah.
04:05:21 <twb> grom358: currently, there are differences.  I believe that will change eventually
04:05:21 <monadwr> I have another haskell book I haven't read yet, though.
04:06:16 <grom358> I solved a fair few of the euler problems in haskell now.. Getting more used to it
04:06:26 <Axman6> grom358: how many?
04:06:44 <Axman6> ski_: runnint it now
04:06:48 <Axman6> g*
04:06:48 <grom358> about a dozen odd
04:07:07 * twb plugs his RWH HTML->PDFizer: http://twb.ath.cx/Preferences/.bin/rwh
04:08:00 <monadwr> Axman6: What are your views on LYAH.
04:08:13 <monadwr> I wonder if there's a pdf available, it's still in BETA, however.
04:08:31 <Axman6> not bad from what i have been through with my girlfriend. haven't done much though, it's exams time
04:09:16 <grom358> actually I am starting to find I am reaching for haskell with its map, filter, etc goodness
04:09:17 <monadwr> Exams?
04:10:00 <bpalmer> twb: 404
04:10:16 <twb> bpalmer: WFM
04:10:30 <monadwr> Haskell should've been my very first language.
04:10:33 <twb> bpalmer: did you have a trailing ] on the URL?
04:10:37 <Axman6> monadwr: uni exams
04:10:43 <twb> monadwr: I would've said Scheme, but whatever
04:10:43 <monadwr> Axman6: Ah.
04:10:47 <Axman6> finishing my first year at ANU :)
04:10:57 <nominolo|msr> :t \x -> map (x . ?p1) . lines
04:10:59 <lambdabot> forall b c. (?p1::String -> b) => (b -> c) -> String -> [c]
04:11:03 <monadwr> twb: No, haskell was the very first I looked into, but thought otherwise.
04:11:26 <monadwr> I did look through the various lisps; I'm still planning on looking into clisp/scheme.
04:11:40 <bpalmer> twb: rather, missing character, and dialog box offscreen when it was corrected. wfm now.
04:11:57 <twb> bpalmer: good, good
04:12:24 <twb> bpalmer: it'll probably render as garbage because busybox's httpd doesn't support Content-Type
04:12:40 <twb> bpalmer: you can just fetch it with curl or GET or wget
04:12:59 <grom358> well my day job is PHP.. and its so crap
04:13:14 <twb> grom358: you do not need to tell anyone here that PHP is crap
04:13:21 <osfameron> start writing functional PHP to impress your colleagues
04:13:28 <monadwr> I think he's talking about his job.
04:13:30 <bpalmer> twb: thanks.
04:13:37 <nominolo|msr> :t \x -> map (x ?p0 . ?p1) . lines
04:13:38 <lambdabot> forall t b c. (?p1::String -> b, ?p0::t) => (t -> b -> c) -> String -> [c]
04:13:54 <monadwr> grom358: You should consider freelance-programming.
04:14:28 <monadwr> Or do a torvalds, and write a haskell-based linux-kern.
04:14:45 <twb> There's already one FP kernel
04:14:59 <twb> It has some innocuous name
04:15:08 <monadwr> There is? Interesting.
04:15:14 <quicksilver> house ?
04:15:20 <shapr> yup
04:15:26 <quicksilver> it's somewhat experimental, I believe.
04:15:27 <shapr> aka h0p
04:15:38 <quicksilver> grom358: learning haskell can help you write much better PHP though.
04:15:41 <twb> It's "production quality" in the same sense as Hurd is
04:16:02 <grom358> I still not seeing the functional difference between quot and div
04:16:11 <nominolo|msr> monadwr: clisp is just a particular implementation of Common Lisp
04:16:25 <quicksilver> > (-5) `quot` (2)
04:16:27 <lambdabot>   -2
04:16:31 <quicksilver> > (-5) `div` (2)
04:16:32 <lambdabot>   -3
04:16:38 <quicksilver> grom358: thus.
04:17:08 <monadwr> nominolo|msr: I already knew this.
04:17:23 <shapr> monadwr: You should write a lambdabot plugin!
04:17:35 <monadwr> shapr: What purpose would that serve?
04:17:41 * quicksilver *IS* a lambdabot plugin.
04:17:54 <grom358> quicksilver: oh I found about putting paren around negatives
04:17:58 <grom358> forgot*
04:18:01 <shapr> monadwr: It would be fun, people would be entertained, and you'd learn more Haskell!
04:18:04 <shapr> monadwr: Sounds great, eh?
04:18:09 * ski_ vaguely points to an expression involving `quot' and `div' a bit up
04:18:14 <monadwr> quicksilver: It's my assumption, that one that learns functional languages, such as lisp/haskell, would probably be able to write imperatives at 3 * efficiency.
04:18:30 <monadwr> shapr: I already have my goals.
04:18:33 <shapr> I've written several lambdabot plugins, as well as the very first lambdabot plugin framework.
04:18:42 <shapr> monadwr: ok
04:18:52 <luite> twb: how long should that script take?
04:19:00 <ski_> afternoon, shapr
04:19:02 <twb> luite: twenty or thirty minutes
04:19:05 <shapr> hej ski_!
04:19:10 <shapr> hug gaar?
04:19:20 <monadwr> shapr: What do your plugins do?
04:20:04 <luite> twb: ah it's done now, I thought it hung. there were some 404 errors downloading the rwh site thougn, is that a problem?
04:20:13 <grom358> mmm i see > divMod n d = if signum r == - signum d then (q-1, r+d) else qr where qr@(q,r) = quotRem n d
04:20:16 <twb> luite: that's expected
04:20:16 <quicksilver> grom358: negatives are a dirty wart on haskell.
04:20:20 <quicksilver> grom358: it annoys me :(
04:20:21 <monadwr> I'd take a look at them, if you like.
04:20:23 <twb> luite: it's dons fault, I guess
04:20:29 <shapr> Let's see, I had a notes plugin that used PostgreSQL, a random quote plugin that used fortune, a type plugin that showed the type of code, and several others. It's been several years, I can't remember all of them :-/
04:20:43 <monadwr> You could show them to me if you like.
04:20:46 <shapr> ski_: hur gaar?
04:20:47 <ski_> shapr : vill ber‰kna approximation till `iterate (sin . sqrt) (1/4)' .. men efter den tredje iterationen sÂ blev lambdabot lÂngsam :(
04:21:01 <ski_> (`CReal')
04:21:01 <shapr> tyvarr :-/
04:21:29 <shapr> monadwr: Next time, I have to go to work.
04:21:35 <shapr> monadwr: Nice meeting you though.
04:21:36 <ski_> (.. och min dator har troligen dˆtt :/ )
04:21:52 <shapr> ski_: behover du mer dator?
04:21:53 * twb glares at ski_'s legacy encoding
04:22:03 <ertai> quicksilver: 6.8 but soon in 6.10
04:22:03 * ski_ bows head in shame
04:22:27 <ski_> shapr : fˆrr eller senare, ja
04:22:29 <shapr> ski_: just nu har jag koept en bladeserver... och den aer foer stor.
04:22:34 <mapreduce> I have utf-8 set and saw ski_'s text.
04:22:40 <mapreduce> Is utf-8 legacy?
04:22:49 <twb> mapreduce: you probably have a forgiving INPUT decoder
04:22:59 <monadwr> shapr: Alright.
04:23:01 <mapreduce> gnome-terminal
04:23:02 <shapr> ski_: 8000 watts aer foer stor.
04:23:16 <twb> gnome-terminal isn't doing the decoding; irssi (or whatever) is
04:23:17 * ski_ vet inte so noga
04:23:28 <quicksilver> ertai: well, in 6.8 Control.Exception.catch can catch everything
04:23:35 <twb> mapreduce: yeah, ERC is forgiving by default.
04:23:39 <quicksilver> ertai: and AFAIK it's the correct way to catch asynchronous exceptions.
04:24:05 <mapreduce> twb: When it goes the other way (when I type stuff) is it still erc?
04:24:15 <twb> mapreduce: sure.
04:24:18 <mapreduce> twb: Did you do a /ctcp version?  I didn't see anything.
04:24:26 <twb> mapreduce: I did.
04:24:38 <mapreduce> So why does gnome-terminal have a character encoding setting?
04:24:56 <twb> mapreduce: because it decodes output from applications and encoding input from the keyboard
04:25:08 <twb> mapreduce: but irssi is de/encoding the bytes from IRC
04:25:16 <mapreduce> I see.
04:25:27 <twb> FSVO irssi = ERC
04:25:27 <Axman6> ski_: yes, that thing's still running -_-
04:25:35 * ski_ sighs
04:25:42 <hugo__> ill write my own monads tutorial :)
04:25:51 <Axman6> why would that computation be so costly?
04:25:59 <mapreduce> hugo__: Be sure to base it on some huge analogy.
04:26:03 <ski_> hugo__ : maybe you could instead write a tutorial on how to write monad tutorials ?
04:26:03 <hugo__> it will be called "christianity explained by haskell code"
04:26:05 <mapreduce> Monads are Jumbo Jets or something.
04:26:07 <twb> mapreduce: try sending something like ‚Äò◊ê‚ÇÄ‚Äô
04:26:19 <hugo__> jesus christ is gods monad
04:26:21 <mapreduce> "something like ‚Äò◊ê‚ÇÄ‚Äô"
04:26:23 <twb> No no no, monads are toxic waste inside a space suit
04:26:24 <hugo__> return JC
04:26:25 <hugo__> :P
04:26:32 <twb> mapreduce: yeah, you sent UTF-8
04:26:49 <RayNbow> „ÉÜ„Çπ„Éà <-- test :p
04:27:01 <hugo__> jesus = return god  -- something like this...
04:27:01 <quicksilver> ertai: which async exception were you hoping to catch?
04:27:12 <cjs> ÂàÜ„Åã„Çä„Åæ„Åó„Åü„ÄÇ
04:27:19 <quicksilver> ertai: in 6.8 the best async exception to throw/catch is probably throwDynTo
04:27:26 <mapreduce> RayNbow:
04:27:29 <mapreduce> Â§±Êïó
04:27:58 <twb> Pfft, nihongo is a pushover.
04:28:04 <arw> looks like the paintings i did in kindergarten...
04:29:03 <mapreduce> Mine meant 'fail', in respond to his 'test'.
04:29:14 <mapreduce> s/d/se/
04:29:17 * RayNbow can't read kanji :p
04:30:41 <cjs> So, anybody read the "STM Sucks" article in the latest CACM? I'm getting shit about it on a mailing list where I brought up STM in Haskell.
04:31:15 <grom358> night
04:31:32 <quicksilver> cjs: no. Is it a good article?
04:31:38 <cjs> No, it's absolutely awful.
04:31:59 <quicksilver> how did it get published in CACM then?
04:32:07 <quicksilver> is about it about haskell STM or just STM generally?
04:32:11 * cjs falls over laughing.
04:32:18 <Axman6> ski_: still going...
04:32:34 <cjs> It's about C STM, basically. Nothing to do with Haskell, doesn't even mention it.
04:33:33 <quicksilver> nod
04:33:33 <cjs> (I have only a few months experience with CACM, but I am not impressed with the rigour of most of the articles in it. And their graph-makers, well, how something running with 0 threads gets work done is beyond me.)
04:33:53 <cjs> But of course, because of the ACM's wonderful publication policies, nobody else on the list can read the darn thing.
04:35:23 * ski_ idly wonders whether `show' on`CReal' or `showCReal' can output digits incrementally
04:36:47 <RayNbow> cjs: is the article available on the web if you have an ACM account?
04:37:19 <cjs> Yup: http://portal.acm.org/citation.cfm?doid2=1400214.1400228
04:37:21 <lambdabot> Title: Software transactional memory
04:37:36 <RayNbow> thx :)
04:38:08 <PeakerWork> I hate ACM putting barriers between me and nice PDF's :(
04:39:52 <mapreduce> Me too.
04:39:58 <shapr> me too
04:40:05 <arw> hm, downloading it worked for me. seems like the uni here has subscribed to it.
04:40:24 <mapreduce> I mentioned it on Wadler's blog when he linked to something; he didn't seem to like my doing so. :)
04:41:08 <cjs> Actually, it seems that ACM is allowing a bunch of stuff without logging in right now. Maybe they've got a bug.
04:41:49 <mapreduce> The above link works for me.
04:41:50 <PeakerWork> shhh, dont tell anyone
04:41:57 <Zao> I prefer the ACM over IEEE, with its myriads of sub-subscriptions you need for articles.
04:42:12 <shapr> I prefer The Monad.Reader over ... almost anything.
04:42:15 <Zao> With the ACM, once you're in, everything they host is available.
04:42:35 <cjs> Zao: no, not true at all. Only for the SIGs you are a member of.
04:42:41 <mapreduce> I prefer http://cs.someestablishment.edu/~surname/nicepdf.pdf
04:43:12 <RayNbow> the STM article has a terrible layout for screens...
04:43:18 <cjs> I just checked; it's just these articles. I got a login screen for, e.g., the ICFP Haskell Symposium proceedings.
04:43:35 <cjs> All of the CACM articles have a terrible layout for screens.
04:43:46 <cjs> But I'd better stop bitching about them now; I could go on for ages.
04:43:50 * ski_ .oO(`ACM', the .. "Atomicity, Concurrency Monad" ? .. "Axiom of Choice Monad" ?)
04:44:09 <Axman6> ski_: still going...
04:44:19 * ski_ too
04:45:18 <Zao> cjs: (apart from the articles published by external publishers and merely indexed by the ACM)
04:45:38 <cjs> Association for Computing Machinery. They celebrated the 50th aniversary of LISP by refusing to update their undergraduate curriculum suggestions to include any requirement for exposure to functional programming.
04:46:28 <ski_> (Axman6 : if you get tired of waiting, i suppose e.g. i could skip the last approximation and claim the initial one is to be included .. or bite the bullet and compute a few decimals with a non-guarranteed tolerance method)
04:46:32 <mapreduce> "Lambda" was not a word used in the CS degree that I studied.
04:46:45 <twb> mapreduce: you obviously went to an inferior school :P
04:46:58 <Axman6> ski_: i'll see how it goes. i don't mind waiting
04:47:00 <mapreduce> No, my school was great.
04:47:10 <mapreduce> I went to an inferior University though.
04:47:11 <arw> over here, you even had to learn prolog...
04:47:13 <Axman6> i'll be going to bed in 15 mins though
04:47:31 <ski_> arw : you're lucky !
04:47:43 <arw> and the new revised curriculum includes haskell as the functional language of choice (as opposed to scheme in the years before)
04:47:49 <mapreduce> prolog was in an optional module taught by someone who didn't seem to know it (so I didn't take that module).
04:48:51 * ski_ 's brain should stop thinking up bad puns, unasked for
04:49:11 * RayNbow is sad that Prolog has been removed from his university's bachelor curriculum
04:49:36 <mapreduce> I still don't know Prolog.  Why should I learn it?
04:49:47 <mapreduce> That's an honest question, try not to read tone into it. :)
04:49:53 <opqdonut> it's cool
04:50:05 <ski_> mapreduce : to learn the "other" declarative sub-paradigm
04:50:06 <arw> curiosity. its something really different.
04:50:07 <opqdonut> unification on _values_ instead of types opens ones eyes
04:50:16 <Axman6> my friend was telling me about it, he was using it in one of bhis courses, which hopefully i'll be taking next year
04:51:07 <ski_> (just refrain from using the cut as much as possible, and things will be mostly fine)
04:51:11 * RayNbow didn't quite grok Prolog when he had to use it in his bachelor
04:51:52 <RayNbow> but letting it sink in for a year and trying to pick it up a year later does wonders :p
04:52:14 <Axman6> RayNbow: hoping that will happen with Cocoa/Obj-C for me
04:55:12 <xenoblitz> hi guys, can someone help me explain what the error " Ambiguous type variable `a' in the constraint" means?
04:55:32 <quicksilver> sure, it means that haskell has no way to determine what type to user
04:55:40 <quicksilver> you probably need to give it a hand with an annotation
04:56:19 <quicksilver> "show . read" is the canonical example.
04:56:21 <ertai> quicksilver: I was rather hoping to don't catch them as I would like to be sure that for instance that this safeGetEnv is safe http://hpaste.org/12166#a0
04:56:26 <ski_> (or use a more specific operation that determines it, if possible)
04:56:27 <xenoblitz> quicksilver: hi quicksilver, let me explain my position so maybe it makes more sense
04:56:52 <xenoblitz> quicksilver: I have a type class called of the form AI a
04:56:56 <quicksilver> ertai: you should use a more discriminating catch.
04:57:07 <xenoblitz> quicksilver: remove the called in that last sentence
04:58:03 <xenoblitz> quicksilver: now AI a has just two methods initAI :: a and stepAI :: (Game, a) -> (Move, a)
04:58:45 <xenoblitz> at the beginning of the program I would like to init the AI in an IORef
04:59:10 <xenoblitz> so i do aiVar <- newIORef (initAI)
04:59:17 <quicksilver> ertai: although to be fair I think what you've written is fine.
04:59:19 <xenoblitz> and i get that error
04:59:31 <quicksilver> because I don't know which "a"
04:59:33 <quicksilver> (which AI)
04:59:37 <quicksilver> to allocate an IORef for.
04:59:42 <xenoblitz> ic
04:59:58 <xenoblitz> quicksilver: so basically it can't be done>
05:00:15 <ski_> you must somehow choose which type `a' you want there
05:00:29 <ski_> haskell just complains that it can't read your mind and choose for you
05:00:45 <xenoblitz> yes it does make sense
05:00:50 <ski_> (well, it can choose for you, but possibly you don't want that, here)
05:00:54 <xenoblitz> i am stuck on how to achieve this
05:01:09 <ski_> just pick an `a' such that `AI a' ?
05:01:19 <ski_> or maybe provide a way for the user to choose ?
05:01:41 <PeakerWork> opqdonut: what do you mean by "unification of values" vs types?
05:01:42 <xenoblitz> well I would like my AI to be programmable separately... as long as it fits the type class
05:02:00 <ski_> PeakerWork : logic programming works by unifying values
05:02:12 <ski_> PeakerWork : type inference works by unifying types
05:02:27 <ertai> quicksilver: thanks
05:02:30 <PeakerWork> ski_: oh, ok
05:02:35 <xenoblitz> is there no way?
05:02:53 <ski_> xenoblitz : you could pass a dummy value of `a' to your `do'-code above
05:03:14 <quicksilver> xenoblitz: it may be that you actually want an existential IORef there
05:03:15 <ski_> xenoblitz : we've mentioned several ways .. you must pick a way
05:03:31 <quicksilver> this is quire possible, but will add a little unwrapping and wrapping here and there
05:04:10 <ski_> (PeakerWork : so, at the least, one can get some insight into one by understanding how the other works .. of course there's more to both, though)
05:04:41 <PeakerWork> ski_: I don't "program" with type inference, it just helps me avoid mentioning types. I do program with the value unification when I use Prolog, though, so I find the comparison a bit weird
05:04:54 <quicksilver> it depends if the type is known at compile time
05:05:12 <xenoblitz> ski_: can you give an example of a dummy vale?
05:05:18 <ski_> PeakerWork : sure .. (hence "insight")
05:05:20 <xenoblitz> ski_: * value
05:05:24 <quicksilver> xenoblitz: if the type is known at compile time (although perhaps not by this module, but by some module) then you can arrange for it to work.
05:05:29 <xenoblitz> quicksilver: never used quantifiers before
05:05:44 <quicksilver> if the type is supposed to be flexible until runtime, then you will want that IORef to be an existential type.
05:05:55 <xenoblitz> quicksilver: i do have a module
05:06:02 <xenoblitz> quicksilver: it implements the type class
05:06:22 <ski_> xenoblitz : `frob :: AI a => Maybe a -> Frob', `> frob (Nothing :: Maybe Blub_AI)'
05:06:23 <xenoblitz> quicksilver: so theoretically it is known at compile time
05:06:38 <ski_> xenoblitz : where `frob' would contain your `do'-expression above
05:07:00 <ski_> xenoblitz : and `AI Blub_AI'
05:07:32 <ski_> (the `Maybe' is not necessary .. one can pass `undefined's instead, e.g.)
05:07:49 <quicksilver> xenoblitz: what you said doesn't really follow. Presumably more than one thing implements the type class?
05:07:55 <quicksilver> otherwise, what's the point of the type class?
05:08:38 <xenoblitz> ski_: thanks for the tip :)
05:08:47 <ski_> np
05:08:52 <xenoblitz> quicksilver: imagine you want the game's AI to be programmable
05:09:00 <Axman6> ski_: heh, _still_ going. i'm going to bed, but i can have the answer for you tomorrow if you like :P
05:09:09 <xenoblitz> so that you can load a different module
05:09:11 <ski_> xenoblitz : also, `asTypeOf' may be handy
05:09:46 <quicksilver> xenoblitz: then the type can't possible be known at compile time
05:09:49 <xenoblitz> you just swap the .hs file with the module and recompile
05:09:56 <quicksilver> oh
05:10:02 <quicksilver> well you don't need a type class for that :P
05:10:08 <quicksilver> you just need a module which exports two functions.
05:10:11 <quicksilver> and you swap the modules.
05:10:18 <quicksilver> type classes are not module signatures.
05:10:23 <xenoblitz> I did but i got another error
05:10:24 <ski_> (or i suppose `frob barf = do aiVar <- newIORef (maybe init (error "blah !") barf)')
05:10:27 <xenoblitz> that's why I attempted this
05:10:59 <hackage> Uploaded to hackage: system-uuid 0.0.1
05:11:00 <quicksilver> you will appreciate that "I got another error" is not enough information to help you ;)
05:11:10 <quicksilver> This doesn't sound like a good use of type classes.
05:11:12 <xenoblitz> yes yes
05:11:17 <xenoblitz> i know...
05:11:23 <xenoblitz> i will rewrite it back to before
05:11:24 <quicksilver> Although if you wanted to choose between AIs at run time, that might well be a good use of existentials.
05:11:34 <xenoblitz> and will provide a more concrete error
05:11:37 <quicksilver> equally it might be simpler to just use higher order functions.
05:11:46 <xenoblitz> still, thanks for the clarification
05:12:19 <xenoblitz> quicksilver: no at this point the AI will be known at compile time so I don't think there is the need for that
05:12:33 <xenoblitz> ski_: thanks as well mate
05:12:43 <ski_> @yarr
05:12:43 <lambdabot> Yeh scurvy dog...
05:14:03 <RayNbow> > ping
05:14:04 <lambdabot>   pong
05:16:09 <quicksilver> question: should haskell have module signatures?
05:16:20 <ivanm> quicksilver: what do you mean by that?
05:16:21 <ski_> yes
05:16:25 <quicksilver> that would have provided the "obvious" solution to xenoblitz's question.
05:16:37 <quicksilver> ivanm: xenoblitz wanted compile-time swappable modules
05:16:45 <quicksilver> he was trying to massage a typeclass do to this
05:16:45 <ivanm> hmmmm....
05:16:48 <quicksilver> but it was quite ugly.
05:16:56 <quicksilver> a module signature was what he was actually looking for.
05:17:17 <ivanm> I thought that's what classes were for... :s
05:17:44 * ski_ finds it irritating that it's not correct to provide type signatures in import,export,instance method lists
05:18:43 <quicksilver> ivanm: nope, typeclasses are for overloading, otherwise known as type-based-dispatch
05:19:21 <quicksilver> that's very different, although it overlaps substantially in the special case that a module defines one "main type" and you can use that as a hook to tie the class to.
05:20:14 <ski_>   import Control.Monad
05:20:26 <quicksilver> (...continuing the special case, and all functions the module exports mention that type ... )
05:20:30 <ski_>     ( liftM  -- :: Monad m => (a -> b) -> (m a -> m b)
05:20:34 <ski_>     , ...
05:20:36 <ski_>     )
05:20:36 <quicksilver> (... so it's not a good model .. )
05:20:40 <ski_> et.c
05:20:42 <ski_> .
05:20:49 <quicksilver> ski_: I agree, although that's not really what I was aksing.
05:21:05 <quicksilver> I was pondering actual language support for them beyond type-checking at interface oundaries
05:21:07 <ski_> but it's related
05:21:17 <quicksilver> although type-checking at interface boundaries is certainly part of the puzzle
05:21:17 <quicksilver> yes.
05:21:32 <ski_> yeah, module functors would be cool
05:23:11 <ski_> sometimes it would be quite handy to parameterize a module (or most of it) over a type-variable .. consider the pesky `s's related to `ST'
05:23:30 <xenoblitz> ski_, quicksilver: I rewrote the stuff without the type class ... the error i have is this one:
05:23:33 <xenoblitz>     Couldn't match expected type `a'
05:23:33 <xenoblitz>            against inferred type `Tetris_AI_Implementation.Commands'
05:23:33 <xenoblitz>       `a' is a rigid type variable bound by
05:23:48 <ski_> @hpaste
05:23:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:23:57 <xenoblitz> sorry about that... am using a new irc client
05:24:11 <xenoblitz> i'll hpaste
05:24:21 <ivanm> quicksilver: still can't see why you'd want module sigs (note that I didn't follow xenoblitz' discussion)
05:24:29 <ivanm> sounds a lot like OO to me...
05:24:50 <xenoblitz> http://hpaste.org/12167
05:25:18 <ski_> ivanm : module signatures is probably needed to get module functors (not related to `Functor')
05:25:50 <ski_> xenoblitz : you forgot the relevant code in `Tetris_AI_Implementation.Commands' ..
05:26:19 <cjs> Hey, is anybody able to grab a copy of this? http://portal.acm.org/citation.cfm?id=1366230.1366241&coll=GUIDE&dl=GUIDE&CFID=11034940&CFTOKEN=33542038
05:26:23 <lambdabot> Title: The limits of software transactional memory (STM), http://tinyurl.com/5pwprp
05:26:43 <cjs> The rest of the title is, "Dissecting Haskell STM Applications on a Many-Core Environment."
05:26:51 <xenoblitz> ski_: a sec I'll add it
05:28:06 <brad_larsen> any GHC experts here?
05:28:15 <brad_larsen> I have a question about its optimization...
05:29:01 <brad_larsen> Does GHC ever optimize code (e.g. that uses the ST monad) so that old versions of data are mutated in-place?
05:29:38 <brad_larsen> or does using the ST monad copy the data, and depend on the GC to quickly eat up the old versions?
05:30:31 <cjs> I sort of implicitly asked the same thing about field updates. I'd be fascinated if it could.
05:30:55 <byorgey> I think the whole point of the ST monad is that things are mutated in-place.
05:31:04 <cjs> My understanding is, generally the GC.
05:31:05 <brad_larsen> byorgey: conceptually at least
05:31:11 <geezusfreeek> i would be very disappointed if ST didn't mutate in place
05:31:16 <ski_> "things" being the `STRef s' cells
05:31:24 <brad_larsen> byorgey: but does GHC generate code such that the data is updated in-place, in memory?
05:31:29 <byorgey> brad_larsen: no, I mean operationally.
05:31:31 <byorgey> yes.
05:31:33 <ski_> (et arrays et cetera)
05:31:37 <cjs> byorgey: No. Keep in mind that the do notation is syntatic sugar for bind.
05:31:39 <xenoblitz> ski_, quicksilver: http://hpaste.org/12167#a2
05:31:40 <geezusfreeek> ghc has the capability already. you get mutable arrays...
05:32:01 <byorgey> cjs: I don't see what that has to do with anything?
05:32:04 <cjs> You could get an idea of whether it's possible for your particular code by translating the do notation into bind notation.
05:32:05 <geezusfreeek> which i know are in place
05:32:11 <brad_larsen> but the ST monad in general... which semantically gives you in-place updates
05:32:22 <brad_larsen> are they actually implemented as in-place updates?
05:32:29 <sclv> brad_larsen: yes they are.
05:32:38 <sclv> that's the whole point of the st monad.
05:32:47 <byorgey> cjs: we're only talking about the ST monad, not monads in general.
05:32:51 <ski_> xenoblitz : `initializeAI :: a' claims that `initializeAI' has any type at all .. which is probably not what you want
05:32:59 <sclv> how else could you have unsafeIOToST ?
05:33:04 <quicksilver> it's not an optimisation.
05:33:06 <ski_> xenoblitz : maybe you want `initializeAI :: AI a => a' ..
05:33:06 <cjs> byorgey: Well, I've not done this, so the question is, do you actually drop the reference to the previous data struture?
05:33:12 <quicksilver> some ST stuff is inplace, because its inplace
05:33:18 <quicksilver> there is no reference to the previous structure
05:33:24 <lilac> brad_larsen: i'd imagine that the STRef (ie, pointer) will be updated in place, but the value it points to will be newly-allocated
05:33:25 <quicksilver> what you had was reference to a mutable cell
05:33:36 <brad_larsen> lilac: that's what I'm wondering about
05:33:40 <quicksilver> you still have a reference to a mutable cell
05:33:40 <byorgey> cjs: for field updates, as you mentioned before, no.
05:33:42 <sclv> STRefs are just IORefs with a different type.
05:33:44 <lilac> brad_larsen: there may be other references to the pointee
05:33:58 <xenoblitz> ski_: i removed the AI type class
05:34:00 <quicksilver> the thing that looks mostly like inplace updates is STUArrays
05:34:16 <xenoblitz> quicksilver: I don't think you are talking to me, right?
05:34:30 <ski_> xenoblitz : oh, right .. so maybe `initializeAI :: Commands', then ?
05:34:42 <lilac> brad_larsen: obviously "x = 42; y = do { x' <- newSTRef x; modifySTRef x' (+1) }" does not change x
05:35:04 <xenoblitz> ski_: I don't want to have to change a file each time, just swap modules
05:35:06 <brad_larsen> lilac: yes, of course
05:35:42 <lilac> brad_larsen: further, you'd expect the STRef x' to refer to the same Int as x does
05:35:53 <lilac> brad_larsen: which implies that, in this case, the modification is not in-place
05:35:57 <ski_> xenoblitz : right, and in this file you'll have `initializeAI :: Commands', and in the other you'll have `initializeAI :: Incantations'
05:36:04 <brad_larsen> lilac: I wonder if GHC can identify cases where there is only a single reference (escape analysis?), and then generate code that does in-place updates
05:36:46 <xenoblitz> ski_: yes?
05:36:55 <brad_larsen> i'll ask on haskell-cafe
05:37:05 <ski_> the cell pointed to by "x'" there is mutilated-in-place
05:37:16 <ski_> xenoblitz : so what is the problem ?
05:37:28 <quicksilver> brad_larsen: no, it can't.
05:37:38 <xenoblitz> ski_: there is something I can't understand apparently :(
05:37:46 <quicksilver> brad_larsen: GHC has no optimisations designed to notice single usage and replace with in-place updates.
05:37:55 <lilac> ski_: the x' pointer certainly is. but x' points to the same Int as x, right?
05:38:06 <brad_larsen> quicksilver: thanks, that was my question, that's what I suspected
05:38:21 <quicksilver> brad_larsen: however, ST does provide inplace update
05:38:21 <xenoblitz> ski_: and I am getting the errors in the hpaste :/
05:38:23 <ski_> xenoblitz : saying `initializeAI :: a' is wrong, since `init' doesn't have type `a', for any possible value of `a' (which is what that type signature means)
05:38:29 <quicksilver> brad_larsen: but it's explicit rather than inferred
05:38:53 <lilac> GHC's RTS doesn't reference-count, does it?
05:39:02 <quicksilver> no, it's "real" GC
05:39:03 <ski_> lilac : "x'" doesn't point to an `Int' at all
05:39:27 <brad_larsen> quicksilver: i don't quite understand.  ST conceptually/semantically does in-place updates
05:39:42 <ski_> lilac : it points (through the internal state) to a cell that in turn contains (or "points to") the `Int' in question
05:39:45 <brad_larsen> quicksilver: but the code generated won't actually twiddle the memory
05:39:49 <brad_larsen> quicksilver: right?
05:39:51 <quicksilver> brad_larsen: wrong.
05:40:14 <quicksilver> brad_larsen: the STUArray's "writeArray" really does twiddle memory.
05:40:16 <baaba> ST is magic
05:40:19 <baaba> much like IO
05:40:31 <quicksilver> STUArray is the most "inplace-feeling" of the constructs.
05:40:34 <brad_larsen> quicksilver: but ST in general?
05:40:40 <quicksilver> ST in general isn't magic
05:40:47 <quicksilver> (in contrast to what baaba just said ;)
05:40:59 <lilac> ski_: the first 'points to' isn't really a pointer, though (at least, i'd hope not). i don't disagree that it is operationally one, though.
05:41:05 <baaba> oh, i had the wrong idea then
05:41:06 <quicksilver> it simply exposes an API which permits certain kinds of mutation.
05:41:21 <quicksilver> there are no celver optimisation rules or anything
05:41:28 <quicksilver> but some of the primitives really do do inplace update.
05:41:39 <quicksilver> writeSTRef does inplace update - of a pointer, not a value
05:41:49 <ski_> lilac : to make an analogue on C (*sigh*) consider `{Int x; Int *x_; x_ = &x; ...; Int y = *x_ + 1; x_ = &y; ...}'
05:42:04 <quicksilver> writeArray does inplace update, and in the unboxed array case, that's actually inplace update of a value.
05:42:09 <brad_larsen> quicksilver: ok, that makes sense.
05:42:40 <lilac> ski_: right. here, x is an Int, x' is an Int*, not an Int**. Conceptually, x' is really a name for a slot within the stack which contains a pointer, but it's not a pointer to a pointer.
05:42:57 <ski_> (or better s/*x_ + 1/addInt(*x_,makeInt(1))/ ..)
05:43:17 <brad_larsen> quicksilver: any idea if there are plans to add identification of values w/ single references to GHC, and have it generate code that modifies those values in-place?
05:43:28 <sclv>   no plans for that.
05:43:39 <xenoblitz> ski_, quicksilver: can't seem to get it to work :/
05:43:42 <sclv> that's uniqueness typing. clean does it.
05:43:42 <lilac> better {Int x = 42; Int *x' = &x; x = new Int((+1)(*x))}
05:44:26 <ski_> lilac : so the pointer value contained in the location denoted by `x_' is replaced by another such pointer value
05:45:05 <geezusfreeek> sclv, but it still isn't automatic, is it? don't you still have to tell the clean compiler about it?
05:45:08 <ski_> xenoblitz : have you tried `initializeAI :: Commands' and `enactAI :: Game -> Commands -> (Move, Commands)' yet ?
05:45:17 <brad_larsen> sclv:  one could conceivable have a haskell compiler which does ``uniqueness analysis'' and generates code for in-place updates, w/o explicitly talking about uniqueness
05:45:29 <sclv> clean infers it as i recall, or tries at least...
05:45:33 <xenoblitz> ski_: I don't want it like that
05:45:34 <geezusfreeek> ah
05:45:42 <xenoblitz> skI_: otherwise I'd have to change that module each time
05:45:43 <ski_> xenoblitz : so how do you want it, then ?
05:45:45 <brad_larsen> sclv: but uniqueness typing, i.e. having it show up explicitly in the types, is probably more sensible
05:45:47 <quicksilver> brad_larsen: it's certainly an interesting idea and I'd be surprised if there wasn't at least a paper about it.
05:45:58 <quicksilver> but I'm not aware of any particular current work.
05:46:09 <ski_> xenoblitz : you just have to write differently in each copy of the module .. which i gather you'll do anyway
05:46:35 <brad_larsen> quicksilver: thanks.  Just curious about this.  I'm just a compiler novice ;-)
05:46:53 <Axman6> ski_: wow, this thing's insane. reckon !! 100 would halt before the sun exploded? :P
05:47:23 <ski_> Axman6 : possibly the complexity is very bad ..
05:47:27 <xenoblitz> ski_: I would like that each time I compile I swap the hs file with AI_Implementation with a different one and that's it
05:47:46 <ski_> xenoblitz : what i've suggested would work with that, yes
05:48:35 <ski_> xenoblitz : in one `AI_Implementation.hs' file you have `initializeAI :: Commands', in another you have `initializeAI :: Incantations' .. is there a problem with this ?
05:49:23 <xenoblitz> ski_: yeah :/ because it couples the two modules together
05:49:36 <ski_> lilac : in any case, whether `x_' is a pointer to a pointer or not depends on whether `x' is a pointer or not .. but i don't see how this matters
05:49:47 <ski_> xenoblitz : how so ?
05:50:02 <xenoblitz> imagine like you said... another person uses incantations instead of commands
05:50:10 <ski_> xenoblitz : both has to conform to the same abstract interface, but i guess you already know that
05:50:12 <xenoblitz> that would mean 2 files have to be changed
05:50:18 <ski_> nono
05:50:35 <ski_> write two files, with different implementations of the `AI'
05:50:45 <xenoblitz> yes
05:50:46 <ski_> rename (or symlink) to compile with one
05:50:54 <ski_> rename (or symlink) to compile with the other one
05:51:35 <xenoblitz> i would have to change the AI module as well as swapping the AI_Implementation module... no?
05:51:55 <xenoblitz> would have to change the AI module with incantations instead of commands for example
05:52:05 <ski_> lilac : the point i think was that the thing that was mutilated-in-place was the location that `x_' denoted .. and surely that doesn't affect what value is stored in `x' ?
05:53:25 <ski_> xenoblitz : if your `AI' module mentions the type `Commands', then strictly yes .. but i was mostly inventing `Incantations' to stress that the other module would use a different implementation there-of
05:54:05 <ski_> xenoblitz : if you want to mention the name `Commands' in the `AI' module, then just name `Commands' the same in the two implementation modules (but still implement them not the same)
05:54:07 <lilac> ski_: right, that's what i was saying. i was questioning your "x' doesn't point to an Int at all"
05:54:41 <ski_> lilac : ok .. that's probably confusion over what "point" here means
05:54:55 <ski_> (i should have been clearer, mea maxima culpa)
05:55:07 <xenoblitz> ski_: isn't that what you're suggesting? That is, to change the AI module function types? from a to Commands?... What if the programmer doesn't want to use Commands... and decides to implement his own way not based on my type Move?
05:55:37 <ski_> xenoblitz : `a' is not a concrete type .. you have to pick some concrete type
05:56:14 <ski_> xenoblitz : then the programmer will define `Commands' differently in an alternative ai implementation module
05:56:39 <xenoblitz> ski_: ic... thanks alot for your help
05:56:44 <lilac> ski_: i think it's partly my C background showing through (thinking too much in terms of implementation rather than semantics)
05:56:58 <xenoblitz> ski_: I will swap to Command
05:57:13 <xenoblitz> ski_: I hope I don't end up trying to write a type class again
05:57:33 <ski_> (to be precise, there i used "point" in the sense of a haskell variable denoting a value .. here the value is the reference cell being mutilated)
05:58:42 <ski_> (s/here //)
06:02:10 <ski_> lilac : actually, when i look closer at your C snippet i see you mutilate the "x" location rather than the "x'" location .. my point was about mutilating the "x'" location ..)
06:02:17 <lilac> (i used "points to" to mean "denotes a variable containing the address of")
06:02:34 <lilac> ski_: yeah, my code was buggy; i meant x'
06:03:11 <lilac> (warning: conversion from pointer to integer lacks cast) :)
06:05:04 <Axman6> ski_: 0.76138642764410233189
06:05:04 <Axman6> real	107m14.190s
06:05:26 * ski_ converts pointy-haireds to OO reli^H^H^H^Hanalysis and design
06:05:45 <Axman6> that's !! 5
06:05:59 <ski_> Axman6 : my many thanks
06:06:11 <Axman6> no worries :) what did you need it for anyway?
06:07:14 <ski_> an exercise in analysis .. figured it would be nice to get guarranteed-correct decimals
06:07:25 <Axman6> fair enough
06:07:33 <ski_> (the approximations are but a small part of the exercise)
06:07:41 <Axman6> well, i'm off to sleep, got an exam in less that 10 hours
06:07:46 <Axman6> uh, 8 hours
06:07:54 <ski_> hehe. ok, good luck
06:08:01 <Axman6> cheers :)
06:23:00 <Angie^> hiya got a question please
06:23:25 <BeelsebobWork> don't ask to ask, just ask :)
06:23:59 <Angie^> i didnt ask, to ask
06:24:02 <Angie^> i said i had a question
06:24:05 <Angie^> "let rangle = [(a,b,c] | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^a]"
06:24:17 <Angie^> im wondering what happens here
06:24:21 <Angie^> like
06:24:29 <Angie^> when c is incremented from 1 .. 10
06:24:40 <Angie^> b goes back to 1 upon each increment right?
06:24:45 <byorgey> right
06:25:21 <Angie^> oh
06:25:22 <Angie^> k
06:25:29 <ski_> (just noting .. maybe you intended s/c]/c)/ and possibly also s/c^a/c^2/ ?)
06:25:42 <Angie^> going by the obok
06:25:43 <byorgey> >  [(a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
06:25:44 <lambdabot>   [(3,4,5),(6,8,10)]
06:25:46 <lilac> foreach c from 1 to 10 >>= (foreach b from 1 to c >>= (foreach a from 1 to b >>= (when a^2 + b^2 == c^a >>= produce (a,b,c))))
06:25:47 <Angie^> picture book
06:26:06 <Angie^> mm i dont understand the last part
06:26:08 <Angie^> b^2
06:26:24 <byorgey> Angie^: which part?
06:26:30 <Angie^> oh i kinda think i do but im confused
06:26:36 <byorgey> the a^2 + b^2 == c^2?
06:26:40 <Angie^> ya
06:26:47 <Angie^> like i know thats the pythagoras theorem
06:27:02 <byorgey> since that evaluates to a Bool value (True or False) it only returns an (a,b,c) for values which make that True
06:27:10 <Angie^> but like, say [2,3,4] 3 = b and 4 = a so uhm it doesnt equal to 2
06:27:16 <Angie^> oh
06:27:23 <Angie^> so its only like
06:27:27 <BONUS> yeah, that's a condition
06:27:28 <Angie^> [2,1,1], [3,1,2]
06:27:37 <BONUS> they only go in the final list if they satisfy that condition
06:27:37 <Angie^> [4,2,2]
06:27:39 <Angie^> liekethat?
06:27:45 <Angie^> ah kk
06:27:49 <Angie^> BONUS: i luv ur book
06:27:52 <Angie^> your the best
06:27:55 <BONUS> thanlks :)))
06:28:09 <Angie^> i just kinda wish it was aimed toward beginners a bit
06:28:11 <Angie^> is there a pdf?
06:28:24 <Angie^> im no good with math its taking me awhile to understand it all (tuples)
06:28:24 <luite> book?
06:28:25 <BONUS> hmm, not yet
06:28:31 <Angie^> BONUS: k
06:28:35 <BONUS> but i plan to release it in pdf form
06:28:43 <byorgey> @where learnyouahaskell
06:28:44 <lambdabot> I know nothing about learnyouahaskell.
06:28:45 <BONUS> once i write a few more chapters
06:28:47 <Angie^> when do u want to release the final release
06:28:48 <BONUS> @where LYAH
06:28:48 <lambdabot> www.learnyouahaskell.com
06:28:52 <byorgey> luite: ^^^
06:29:09 <BONUS> when i finish about 4 or 5 more chapters
06:29:11 <luite> ah, will it be published in book form?
06:29:20 <BONUS> dont know about that, i hope so!
06:29:28 <grul> i love book
06:29:32 <BONUS> that's all still up in the air
06:29:35 <BONUS> haha thanks :]
06:29:36 <luite> I'd buy it for the pictures alone :)
06:29:39 <Angie^> i hope this book is good enough as a single soure for learning this
06:29:47 <Angie^> kinda wish socks were init
06:29:49 <Angie^> lol
06:29:54 <BONUS> it's good to combine multiple sources
06:29:57 <Angie^> and exercises
06:30:12 <BONUS> yeah, i'll work on adding exercises for the reader
06:30:17 <Angie^> kk
06:30:59 <Angie^> i just hope im not too stupdi for this everyone says func langs re hard and not for beginners
06:31:07 <xenoblitz> BONUS: am taking a look at the book... looks awesome
06:31:13 <BONUS> :D
06:31:17 <Angie^> i was learning c, but i failed a bit at that because k&r exercises were a bit hard
06:31:29 <BONUS> Angie^: do you know any other programming languages?
06:31:38 <_pizza_> Angie^: you're screwed.
06:31:52 <Angie^> BONUS: i kinda can read c. i finished the first 2-3 chapters of the k&r but not all the exercises
06:31:55 <Angie^> _pizza_: huh
06:31:58 <BONUS> ah
06:32:08 <Angie^> but
06:32:17 <Angie^> i think learinng functional would make me a better c coder?
06:32:20 <Angie^> or waste of time?
06:32:24 <Angie^> for me
06:32:26 <grul> neither
06:32:35 <BONUS> i think it's very hard to translate functional idioms to c
06:32:35 <Angie^> o
06:32:38 <BONUS> but its not a waste of time though
06:32:45 <luite> Angie^: it will make you never want to go back to C ;)
06:32:52 <quicksilver> being good at functional programming  will make you a better C coder though
06:32:56 <_pizza_> it helps you see things in a different way, certainly; and i say that as a C coder
06:33:03 <BONUS> it usually helps to know some other language before doing haskell IMHO
06:33:06 <quicksilver> not quite the same as merely learning it.
06:33:08 <xenoblitz> Angie^: if you know no other language you are probably better off... you just need to know some techniques generic to all paradigms and you are fine
06:33:31 <Angie^> kk
06:33:34 <xenoblitz> ... and what quicksilver said :P
06:33:38 <Angie^> just thought i'd be better at other stuff
06:34:06 <xenoblitz> quicksilver: can I have a minute of your time?
06:34:26 <Angie^> kk back to reading
06:34:31 <Angie^> thanks everyone, BONUS
06:34:36 <BONUS> hehe np :]
06:34:44 <dancor> i was going to use hashString for something but i feel weird about using GHC.Int.Int32
06:34:49 <dancor> what should i be using..
06:34:52 <ben_h> hi all
06:35:02 <byorgey> hi ben_h
06:35:06 <quicksilver> xenoblitz: you can ask here and I'll do my best.
06:35:21 <quicksilver> dancor: import it from Data.Hashtable, maybe?
06:35:21 <ben_h> building ghc on my new macbook :)
06:35:27 <quicksilver> dancor: I think I've done that before.
06:36:00 <dancor> Module `Data.HashTable' does not export `Int32'
06:36:09 <monadwr> Angie^: Haskell may, or may not make you a better programmer, in terms of thinking up algorithms, and data structure design.
06:36:45 <xenoblitz> quicksilver: do you remember that I was trying to have something where I can just swap a module and still don't restrict a programmer to a particular type?
06:36:51 <monadwr> Functional programming is not really the same as imperative programming, thus you'll have two different ideas if you code in both.
06:37:16 <monadwr> ideals*
06:37:53 <monadwr> You wouldn't want to go back to imperative languages :)
06:38:00 <arw> haskell will teach you certain aspects, but there are some things you won't learn from haskell.
06:38:04 <monadwr> But, I'd say, if you want to go through functional ones, learn lisp too.
06:38:08 <_pizza_> functional programming will cause you to be depressed when you're writing in imperative for loops
06:38:08 <arw> depends on what you want to do.
06:38:15 <quicksilver> xenoblitz: I do, yes.
06:38:59 <monadwr> Is Python a functional language? I don't know much about it.
06:39:13 <xenoblitz> quicksilver: I removed the type class but I still can't figure out how I can just swap a module and it works without having to change other code refering to said module... I was hoping using a and type classes could solve my problem
06:39:20 <xenoblitz> quicksilver: any ideas?
06:39:23 <dancor> python itertools has like dropwhile/takewhile
06:39:23 <PeakerWork> monadwr: nope
06:39:35 <quicksilver> xenoblitz: don't use "a", use the name of a Type defined in that module
06:39:37 <dancor> but there aren't real lambdas and lots of otehr things
06:39:45 <quicksilver> what that type actually is will change when you swap the module
06:39:49 <monadwr> Ah.
06:39:50 <quicksilver> but the name will be the same.
06:39:50 <PeakerWork> Python has "generators" which are kind of like lazy lists, and there are a bunch of stuff that can convert lazy lists to other lazy lists lazily
06:40:16 <PeakerWork> does anyone here know boomerang?  Can boomerang be more than bidirectional? Can it define relations between more than 2 entities such that any one can be known from any other?
06:40:43 <flux> I don't think generators can safely be categorized as the same as lazy lists, as you cannot hold a reference to an older instance of one, can you?
06:40:49 <Twey> monadwr: It's multiparadigm, one of which paradigms is functional.
06:41:03 <monadwr> Ah, cool.
06:41:04 <arw> barely functional...
06:41:25 <xenoblitz> quicksilver: i guess its what ski_ suggested... I might be missing something somewhere... I'll try again. thanks once more
06:41:41 <quicksilver> xenoblitz: *nod*
06:41:57 <quicksilver> monadwr: "functional" isn't particularly well defined.
06:42:16 <PeakerWork> I think "functional" means having referential transparency
06:42:32 <PeakerWork> that way it actually means something
06:42:32 <quicksilver> python has functions as first class objects (good) closures (good) obsession with objects (bad) unrestricted side effects (bad)
06:42:51 <monadwr> quicksilver: I'd say it is based around 'space' as opposed to 'time', like imperative languages are.
06:42:53 <quicksilver> PeakerWork: you may think that, but it's not very useful, because that's not what everyone else thinks it means ;)
06:43:19 <quicksilver> lisp and ML are widely named as functional and neither is RT
06:43:21 <PeakerWork> python has no types (bad), late binding (bad), very hookable (good), can easily execute code at runtime (good), has very good interactive environments/debuggers (good)
06:43:27 <xenoblitz> isn't functional what the name implies: focus on mathematical functions?
06:43:35 <monadwr> quicksilver: I was looking at Clang/closures in C.
06:43:38 <PeakerWork> quicksilver: Saying Lisp is "functional" and Python is not is quite meaningless imo
06:43:45 <PeakerWork> quicksilver: both are pretty much the same
06:43:49 <monadwr> quicksilver: RT == Runtime?
06:43:51 <quicksilver> PeakerWork: yeah, I go derailed halfway through my list, I would have added those.
06:43:58 <quicksilver> monadwr: referential transparency
06:44:08 <quicksilver> monadwr: not a strandard abbreviation I was just being lazy.
06:44:12 <monadwr> Ah.
06:44:23 <dancor> do parsec and bytestring play nice together
06:44:29 <gpolo> PeakerWork: when did python lost its types ?
06:44:30 <quicksilver> PeakerWork: I can understand that argument, and nonetheless lisp is known as a functional language.
06:44:38 <dancor> or am i likely to have issues since all the parsec combinators are list based
06:44:42 <quicksilver> PeakerWork: so by following your argument, you might say python is.
06:44:49 <PeakerWork> gpolo: it has "dynamic types" but most people say those aren't "types" at all
06:44:59 <gpolo> PeakerWork: but they are all there
06:45:18 <PeakerWork> gpolo: but "types" are something that expressions have
06:45:35 <gpolo> is that a axiom ?
06:45:40 <quicksilver> static types and dynamic types are almost completely different uses of the word 'type'
06:45:53 <quicksilver> people wishing to continue this discussion should read cdsmith's rant first.
06:46:18 <quicksilver> http://www.pphsg.org/cdsmith/types.html
06:46:29 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
06:46:38 <ski_> (however even the dynamic types presumably have some kind of notion of type in their heads, to be able to write and reason about code)
06:46:58 <quicksilver> "types are something terms have" is indeed an axiom, in some studies of types.
06:47:00 <mapreduce> The untyped lambda calculus has 'dynamic types', because dynamic typing is a non-concept.
06:47:02 <quicksilver> but it's not the only meanin g of type.
06:47:03 <ski_> (s/heads/heads and often comments/)
06:47:31 <PeakerWork> quicksilver: I don't sympathize with the "rejecting correct programs" argument, because I haven't encountered correct programs that get rejected that way
06:47:51 <flux> ski_, but it is arguable if the types are actually in the code, or just in their heads ;)
06:47:56 <PeakerWork> quicksilver: so I am left not understanding any argument at all for dynamic typing
06:47:57 <mapreduce> PeakerWork: if (true) stuff else type error
06:48:19 <PeakerWork> mapreduce: yeah, but I don't see that as "correct", as in "passes my code review" :)
06:48:33 <orbitz> hey ski_, you responded last night to my question about uniqueness types, do you nkow much about them?
06:48:44 <gpolo> quicksilver: I'm taking you are saying I'm wrong, I haven't read that by the way
06:48:52 <mapreduce> I think correct is more about whether errors might occur at runtime than whether it passes your code review.
06:48:58 <gpolo> but why would python have a TypeError exception if it had no types ?
06:49:06 <ski_> (flux : not sure what you mean by "in the code", here)
06:49:09 <mapreduce> gpolo: Because it has *something else* and calls them types.
06:49:14 <gpolo> huh..
06:49:16 <mapreduce> TAPL calls them tags.
06:49:26 <monadwr> Forgive this, but I am new after all; Does haskell interface well, and closely with the kernel?
06:49:35 <ski_> orbitz : not that much .. i've played a little with Clean,Mercury, and read some papers
06:49:39 <orbitz> gpolo: how can java have NullPointerException if it has no pointers?
06:49:44 <flux> ski_, given that you can reason about code and assign types to expressions in your head doesn't mean that from the language's point of view the program actually has types
06:49:47 <ski_> orbitz : did you have some query on them ?
06:49:47 <mapreduce> orbitz: Java has pointers.
06:49:51 <PeakerWork> mapreduce: yes, but why would I want to not reject programs that wouldn't pass code-review?
06:50:03 <xenoblitz> quicksilver, ski_: sorry I am going back to my question... so in this way by having a module which exports initAI, stepAI and the Commands type I have what I need... thanks both of you and especially for your patience
06:50:04 <PeakerWork> mapreduce: how is this attribute of dynamic typing actually an advantage?
06:50:06 <flux> ski_, I could perhaps reason with C code in a monadic way, but that wouldn't mean C has monads
06:50:13 <quicksilver> gpolo: no, I wasn't saying you were wrong.
06:50:13 <orbitz> ski_: usign the example of a file, does one have to explicitly pass teh new file aroudn each time or is it like a monad where it's threaded for you?
06:50:20 <orbitz> mapreduce: not according to the JLS
06:50:23 <mapreduce> PeakerWork: Perhaps some rejected programs would pass code review.
06:50:31 <ski_> orbitz : either
06:50:32 <orbitz> mapreduce: it calls them references, which is just my point
06:50:32 <PeakerWork> mapreduce: Yeah, I haven't seen any
06:50:36 <quicksilver> gpolo: I was saying that these are two different meanings of the word 'type' and cdsmith's little rant explains it eloquently
06:50:44 <quicksilver> gpolo: so I didn't feel like reporducing his argument.
06:50:48 <mapreduce> orbitz: The language spec uses both terms.
06:50:55 <ski_> orbitz : you could pass it around explicitly, but you could also build a monad abstraction to hide it
06:51:01 <orbitz> mapreduce: then you win this round
06:51:01 <PeakerWork> mapreduce: if the type checker finds it too hard to prove it correct, then its probably too hard to see that it is correct, refactor it
06:51:04 <gpolo> quicksilver: I will read it later today
06:51:22 <ski_> orbitz : <http://www.cs.ru.nl/~clean/Download/Download_Libraries/Std_Env/StdFunc/stdfunc.html>
06:51:23 <lambdabot> http://www.cs.ru.nl/~clean/Download/Download_Libraries/Std_Env/StdFunc/stdfunc.html>
06:51:32 <flux> peakerwork, well, it's simple to produce examples of code that don't get pass the type system, but are actually well typed
06:51:38 <mapreduce> orbitz: What it lacks is pointer arithmetic, which somehow seems to have been translated to "Java doesn't have pointers" by many.
06:52:09 <PeakerWork> flux: the question is whether the code is good - or if we ought to rewrite it in a way that's easier to prove
06:52:24 <orbitz> mapreduce: i'm aware of that, my point was simply that different langauge redefine terms in their own way, which is why python can have a TyepError if it doesn't really haev types according to someone in #haskell
06:52:33 <PeakerWork> flux: If we'd ever want to accept such programs, in an environment where people want to be able to read each other's code, and not just execute it
06:52:46 <ski_> flux : granted .. i suppose i was answering more to the question of whether types can be useful in "dynamically typed languages"
06:52:50 <dmead> yo channel
06:52:53 <mapreduce> PeakerWork: If you imagine a language with a poor typesystem, which we'll call "Java", you can probably imagine cases where you want to do things that cannot be typechecked by that language.
06:52:56 <dmead> anyone know if git can read darcs repos?
06:53:17 <orbitz> ski_: does a uniquness type just make the monad easier to write?  i mean, if you already have a monad then isn't the uniqueness type redundant/
06:53:23 <mapreduce> PeakerWork: To someone used to a better typesystem (suppose a Coq user), Haskell's will require workarounds like that sometimes too.
06:53:24 <ski_> (orbitz : or DCG (or state-variables), in the case of Mercury)
06:53:38 <PeakerWork> mapreduce: of course, I am wondering about a good type system
06:53:38 <ski_> orbitz : they serve different concerns
06:53:53 <PeakerWork> mapreduce: what workarounds would be required in Haskell, for example?
06:54:06 <mapreduce> I don't know.  Ask a Coq user. :)
06:54:13 <mapreduce> unsafePerformIO?
06:54:23 <quicksilver> PeakerWork: try writing a proved Ord instance in haskell
06:54:30 <quicksilver> PeakerWork: that is, an Ord instance which knows it is transitive
06:54:32 <flux> I know that Coq's ocaml extraction does make use of ocaml's (a -> b) -function at times
06:54:39 <quicksilver> and carries around a proof of that fact.
06:54:46 <PeakerWork> quicksilver: Haskell is to Coq as Python is to Haskell, being "dynamic" on the things its type system cannot express
06:54:49 <flux> peakerwork, it's unavoidable when you have a more powerful typesystem and you want to express that in a less powerful system, right?
06:55:10 <ski_> orbitz : the uniqueness type ensures the state is not duplicated .. the monad abstracts the explicit plumbing .. it also so happens that if you make the monad abstract, then you don't need to support uniqueness types in the type system to have a safe (in the RT sense) update-in-place
06:55:37 <PeakerWork> Well, I agree that *until* we solve the problem of expressing/inferring the types, we are forced to abandon static types, but once we have solved it - why still be dynamic?
06:56:17 <flux> peakerwork, and when have we problems those problems?-)
06:56:26 <PeakerWork> So Haskell is still "dynamic" in the sense of not having dependent types, because dependent types were not solved yet and will probably never have a practical solution as good as type inference is for non-dependent types
06:56:28 <idnar> orbitz: NullPointerException actually means "null reference exception" :P
06:57:06 <PeakerWork> So if something like good inference is impossible, I see an actual trade-off between a static/dynamic system.  But if inference is a solved problem, then I don't see a tradeoff at all
06:57:25 <PeakerWork> So dependent vs non-dependent types are probably going to remain a trade-off forever
06:58:32 <orbitz> idnar: heh i know, whtat wasn't my piont though
06:58:33 <idnar> @src mapM
06:58:33 <lambdabot> mapM f as = sequence (map f as)
06:58:35 <idnar> @src mapM_
06:58:35 <lambdabot> mapM_ f as = sequence_ (map f as)
06:59:46 <idnar> @src sequence
06:59:46 <lambdabot> sequence []     = return []
06:59:46 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:59:46 <lambdabot> --OR
06:59:46 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:00:01 <idnar> @src sequence_
07:00:01 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:02:14 <monadwr> Does haskell interface well, and closely with the kernel?
07:02:16 <sw17ch> has any one done anything along the lines of creating a Window setup.exe/msi package with cabal?
07:02:41 <frodenius> yo
07:02:48 <monadwr> sw17ch: Do you mean a port of Cabal, to win32?
07:03:16 <quicksilver> monadwr: ask conventionally used, the haskell libraries are platform independent, so they're a long way away from the kernel.
07:03:20 <sw17ch> no, i mean runhaskell Setup msi
07:03:25 <sw17ch> monadwr ^^
07:03:29 <sw17ch> or something alongthose lines
07:03:31 <quicksilver> monadwr: the haskell C FFI lets you bind to anything with a C ABI though
07:03:48 <monadwr> quicksilver: Ah, that's cool.
07:03:54 <sw17ch> actually, that'd be great
07:04:15 <sw17ch> `runhaskell Setup msi` would make a project.msi package in dist/
07:06:29 <geezusfreeek> monadwr: you may find the House project interesting though. they basically ported the whole GHC runtime to work in privileged mode so they could make a kernel in Haskell, as i understand it
07:06:56 <geezusfreeek> although i don't know the reason for you asking that anyway :)
07:07:20 <monadwr> geezusfreeek: That looks cool, I'll take a look later on.
07:08:03 <monadwr> bbiaw.
07:09:26 <dmead> chanelllllllllllllll
07:09:38 <dmead> did Hunit get axed from ghci in the last year?
07:09:59 <ben_h> wow, ghc is a pretty hefty build
07:10:07 <dmead> it's a beast
07:10:08 <ben_h> good stress test for this new hardware
07:10:18 <dmead> my quad core compiles it in about 15 min
07:10:20 <dmead> q6600
07:10:32 <ben_h> what's the clockspeed on the 6600 dmead?
07:10:39 <ben_h> i'm building on a core 2 duo 2.4ghz
07:10:43 <dmead> 2.4ghz
07:10:47 <ben_h> (13" macbook)
07:10:52 <ben_h> ah k
07:10:58 <dmead> i built a workstation with gentoo
07:10:59 <hackage> Uploaded to hackage: wavesurfer 0.0.4
07:10:59 <hackage> Uploaded to hackage: freesound 0.0.2
07:12:02 <ben_h> oh. i don't have -j set in makeopts on this system.
07:12:10 <ben_h> either that or macports isn't using it
07:13:55 <dmead> ah
07:13:58 <dmead> i have -j8 i think
07:14:01 <ben_h> mm
07:14:08 <dmead> or 6
07:14:09 <dmead> i forget
07:14:13 <dmead> over some number and it's all the same
07:14:14 <ben_h> i've always done ncores + 1
07:14:16 <dmead> ah yes
07:14:22 <ben_h> but anything up to ncores * 2 performs about the same in my experience
07:14:28 <dmead> aye
07:14:41 <dmead> 4 way paralellism is 4 way parallelism
07:14:43 <ben_h> not so much on ncores / 2, like this
07:14:43 <ben_h> :)
07:14:49 <dmead> it doesn't matter how much you task switch on them
07:14:50 <dmead> etc etc
07:14:57 <ben_h> to a point yeah
07:15:03 <quicksilver> well that depends if your tasks ever IO block
07:15:05 <ben_h> there comes a point where the overhead gets heavy
07:15:12 <dmead> quicksilver, of course
07:15:16 <quicksilver> if you have a task IO blocked and other waiting only for the CPU
07:15:19 <quicksilver> that > ncores can be useful
07:15:28 <quicksilver> compiling GHC doesn't IO block often
07:15:29 <dmead> aye
07:15:31 <quicksilver> but there might be moments.
07:15:42 <ben_h> just watched torvalds' google talk on git again - great presentation.
07:15:59 <PeakerWork> ben_h: he's a real git though
07:16:02 <ben_h> lol
07:16:11 <ben_h> he really doesn't pull any punches in regards to subversion
07:16:16 <ben_h> "it is _amazing_ how stupid these people are"
07:16:18 <Twey> Haha
07:16:18 <ben_h> lol
07:16:24 <mnislaih> dcoutts_: there ?
07:16:32 <PeakerWork> ben_h: "Anyone who tells you SHA1 is a security feature is an idiot", 5 minutes later he says (not in so many words...) "SHA1 is a great security feature!"
07:16:47 <Twey> Well there you have it, then
07:16:48 <ben_h> lol
07:16:55 <ben_h> i think he meant reliability instead of security there
07:17:06 <ben_h> verifiability rather
07:17:34 <PeakerWork> ben_h: Well, it is SHA1 that allows him to know that nobody tampered with it based on the hash, and that is a security feature, not reliability
07:17:53 <ben_h> i suppose
07:18:05 <ben_h> but it's not security in the way some would interpret it
07:18:23 <PeakerWork> ben_h: if the hash was weak, I could get him a tampered revision that has the same hash
07:18:50 <ben_h> yeah
07:19:08 <ben_h> i wonder how easy it would be to extend the hash if/when computing power makes brute forcing it feasible
07:46:41 <wchogg> conal:  ping
07:47:19 <conal> wchogg: hi
07:49:14 <wchogg> conal:  Hi!  So I had just sent an e-mail to Reactive, but I thought I'd ask bout this in person.  Is there a way to take an infinite list & substitute its elements into an Event?  It seems like there should, since the semantic model of Event is a potentially infinite list of time value pairs.
07:50:17 <conal> wchogg: hm.  off-hand, i can't think of a way, on top of the current api.
07:52:54 <conal> you can define it in terms of the rep -- taking care that its meaning is defined via the semantics.
07:53:07 <conal> i mean via the semantic model for events
07:53:49 <conal> which seems simple in this case
07:54:03 <quicksilver> you can do it using the current api
07:54:09 <conal> oh?
07:54:17 <quicksilver> fmap (head) . accumE (tail)
07:54:19 <quicksilver> or something like that.
07:54:43 <conal> yeah!  something like that.
07:54:54 <quicksilver> that's not really type correct but gives the idea ;)
07:54:57 <FunctorSalad> eh? :-) ghc-6.10.1 requires process ==1.0.1.1 however process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
07:55:02 <conal> yep. neat. :)
07:55:10 <FunctorSalad> ghc is like me
08:00:39 <wchogg> Ah!  You mean like subs xs e = fmap head $ accumE xs $ fmap (const tail) e ?
08:01:29 <quicksilver> wchogg: that sounds like what I mean, yes.
08:01:40 <wchogg> and it type checks!
08:01:49 <quicksilver> I think accumE has its parameters in the wrong order, actually.
08:02:09 <quicksilver> well, maybe it doesn't.
08:02:11 * sw17ch <3 STM
08:02:19 <quicksilver> I know I always have ot look it up, at least.
08:02:35 <wchogg> accumE :: a -> EventG t (a -> a) -> EventG t a
08:02:43 * quicksilver nods
08:03:03 <quicksilver> subs xs e = head <$> accumE xs (const tail <$> e)
08:03:25 <quicksilver> but const tail <$> e is just tail <$ e, right?
08:03:28 <quicksilver> :t (<$)
08:03:29 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
08:03:33 <conal> yeah
08:03:40 <quicksilver> subs xs e = head <$> accumE xs (tail <$ e)
08:03:43 <quicksilver> ta-da!
08:03:45 <conal> pretty
08:03:47 <wchogg> yay!
08:03:58 <conal> now how about a version that also keep's e's data?
08:04:04 <quicksilver> is there a place for fun dioms like that on the wiki?
08:04:15 <quicksilver> ooh, I just coined a new word
08:04:21 <conal> quicksilver: not yet.  someone could add one.
08:04:30 <quicksilver> "fundiom" n. enjoyable functional programming idiom
08:04:38 <conal> :)
08:05:14 <quicksilver> I find myself using accumE a LOT
08:05:23 <wchogg> But under pressure to be more serious, you have to change it to be funpplicativefunctor
08:05:26 <quicksilver> almost everything 'clever' I try to do boils down to accumE
08:05:35 <PeakerWork> doh, hoogle can't find any Reactive stuff with the simple names, only with the "G" names
08:05:53 <quicksilver> it's the primitive way to remember the past, I guess.
08:05:58 <quicksilver> s/the/one of the few/
08:06:09 <conal> quicksilver: yeah, it is.
08:06:13 <PeakerWork> Is there a:  Behavior a -> Event (Behavior a) -> Behavior a ?  (basically a stepper that "joins" the result Reactive (Behavior a)) or alternatively a way to do that join?
08:06:28 <quicksilver> PeakerWork: that's switcher
08:06:30 <quicksilver> (isn't it?)
08:06:37 <wchogg> Yeah, that's swither
08:06:38 <PeakerWork> ah, cool
08:06:39 <wchogg> switcher
08:06:42 <wchogg> geh
08:06:56 * quicksilver is really pleased to see reactive discussion happening here
08:07:06 <quicksilver> there are still of fundioms left to discover
08:07:21 <quicksilver> "The Great Fundiom Rush of '08" "There's fundioms in them thar hills!"
08:07:40 <wchogg> quicksilver:  are you on the reactive list?
08:08:21 <quicksilver> yes
08:08:27 <quicksilver> although I've not said anything yet.
08:08:31 <PeakerWork> wchogg: I am toying with your tetris code :)
08:08:33 * quicksilver is the silent type.
08:08:44 <PeakerWork> wchogg: I am trying to get the first piece to be random too, I think I'll use a switcher with an empty animation at first
08:09:37 <conal> the type of switcher was my first big FRP aha! -- in 1994
08:09:58 <wchogg> PeakerWork:  In the interests of expediency, you could probably just pass in an initial piece as an extra parameter.
08:10:22 <quicksilver> conal: tempus fugit
08:10:34 <PeakerWork> wchogg: yeah, but how do I generate the random piece? I think if you depend on random input you should be in a Reactive/Behavior thingie
08:10:35 <quicksilver> conal: although switcher still stubbornly reminds us about the missing monad instance.
08:10:54 <PeakerWork> wchogg: I guess being in a Reader of that randomness is also Okay, on the other hand, but then you take two random inputs
08:11:00 <hackage> Uploaded to hackage: arff 0.1.0
08:11:03 <PeakerWork> wchogg: randBehavior + randPiece
08:12:08 <wchogg> PeakerWork:  That doesn't seem too bad to me, but I agree it lacks a bit of aesthetics.
08:13:31 <PeakerWork> how do generate a random thing in IO ()?
08:13:39 <wchogg> randomIO
08:14:15 <PeakerWork> @hoogle randomIO
08:14:15 <lambdabot> System.Random randomIO :: Random a => IO a
08:16:32 <conal> i'm also disappointed with the lack of Behavior monad, because the semantics of behaviors is a monad.
08:17:18 <wchogg> conal:  So what's the thing that's the showstopper?
08:17:43 <conal> reactive normal form
08:17:51 <PeakerWork> I think a (Random a => Behavior a) should probably be replaced by something weaker than that (as part the mailing list). Something like withTimeE that adds a random thing to an event
08:18:09 <PeakerWork> s/part/par
08:19:32 <quicksilver> yeah, I'm not entirely happy with (Random a => Behaviour a)
08:19:33 <conal> wchogg: Behavior is a composition of two monads, and i don't know how to make the crucial commutation
08:19:39 <quicksilver> there is something subtly wrong.
08:19:59 <quicksilver> random numbers are generated discretely yet we pretend they can be sampled continuously?
08:20:02 <wchogg> quicksilver:  I think it's a bad idea not necessarily subtly.  I don't know if you saw my posts to the mailing list this morning.
08:20:11 <conal> wchogg: Reactive (Fun t (Reactive (Fun t a))) --?--> Reactive (Reactive (Fun t (Fun t a)))
08:20:13 <quicksilver> in any particular program, of course, we only sample them finitely
08:20:13 <wchogg> quicksilver:  yup!  That's what I realized a bit ago
08:20:19 <PeakerWork> quicksilveR: withRandomE :: Random a => Event b -> Event (a, b) ?
08:20:20 <quicksilver> but it doesn't feel right.
08:20:25 <quicksilver> PeakerWork: that's definitely fine.
08:20:28 <quicksilver> (IMO)
08:20:46 <quicksilver> wchogg: no, I haven't read it yet today. I shuld.
08:20:49 <PeakerWork> That totally hides the pseudo-ness of the random though
08:21:05 <PeakerWork> (You depend on a global seed, rather than explicitly depending on the generator somehow)
08:21:14 <PeakerWork> @hoogle random
08:21:14 <lambdabot> package random
08:21:14 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
08:21:14 <lambdabot> module System.Random
08:21:42 <PeakerWork> I guess maybe: withRandomE :: (Random a, RandomGen g) => g -> Event b -> Event (a, b) ?
08:22:02 <wchogg> PeakerWork:  Yeah, and then a withRandomE_ that drops the original event
08:22:11 <PeakerWork> wchogg: Yeah
08:22:24 <quicksilver> although I hate all these Es and to some extent the _s
08:22:31 <quicksilver> but you can't win em all.
08:22:40 <luite> is there a concatMapM somewhere?
08:22:49 <quicksilver> expressivity is more important than syntactic beauty.
08:22:50 <PeakerWork> quicksilver: the "artificial" division to R and B causes that?
08:23:12 <quicksilver> PeakerWork: the division between E and B is not artificial, though.
08:23:37 <wchogg> conal:  But I thought you had a natural transformation, at, that could take you from t -> a's to Behavior a's.  Can't that be used to push over the Monad structure?
08:24:14 <pcc1> shouldn't an (or some implementation of an) inductive graph be an instance of Data?
08:24:44 <conal> wchogg: i don't follow
08:25:27 * PeakerWork wants to do FRP, but has to work :-(
08:25:38 <wchogg> PeakerWork:  You could get layed off, like I did.
08:25:38 <conal> PeakerWork: too bad :(
08:25:43 <PeakerWork> wchogg: hehe
08:26:07 <conal> wchogg: is that why you have all this time for FRP?  i was wondering.
08:26:21 <quicksilver> wchogg: that's a semantic transformation. There is no doubt that Behaviour is a semantic monad.
08:26:52 <wchogg> conal:  Yeah...I lost my job recently.  I'm taking a little bit of time to work on things that are actually cool while figuring out what to do next.
08:29:10 <wchogg> quicksilver,conal:  I guess my point comes down to this:  is there a natural isomorphism between Behavior  & ((->) t) or is it just one way?  If there's an isomorphism then you should be able to compose natural transformations to get the two required transformations of Behavior Monad, yes?
08:29:13 <Clockwork> Hey, designing my own data type Natural (cloning the natural numbers) how do I define my show-function?
08:29:39 <PeakerWork> wchogg: an FRP-based start up company? :)
08:29:44 <Clockwork> I wrote: shownat Zero = "0" but how do I link it to my data type?
08:30:40 <quicksilver> instance Show Natural where show = shownat
08:30:49 <conal> wchogg: maybe the problem is that the semantic function (at) is not at all practical.
08:30:57 <conal> wchogg: because it's non-incremental.
08:32:05 <wchogg> PeakerWork:  Heh...that'd be fun, but don't think I could pull that off by myself.
08:33:10 <wchogg> conal:  I'm not sure if I know what you mean by non-incremental, I apologize.
08:34:59 <conal> wchogg: i mean that it's not practical to work with behaviors via 'at', because work has to start from scratch each time.
08:35:26 <conal> wchogg: going back the start and moving events toward the given moment
08:35:45 <PeakerWork> conal: what about memoizing previous results so it can work from there?
08:35:58 <PeakerWork> I guess that's a huge space leak
08:36:14 <PeakerWork> unless its a smart memo that discards LRU entries..
08:36:17 <conal> PeakerWork: exactly
08:36:39 <conal> PeakerWork: there's an idea i hadn't considered.
08:37:11 <wchogg> PeakerWork:  How would it take into account a notion of time without contaminating with IO?
08:37:16 <conal> memoizing behaviors is interesting because of its continuous domain.
08:37:38 <PeakerWork> wchogg: time is just an input it can memoize on
08:38:58 <Lemmih> dcoutts_: ping.
08:41:53 <b4taylor> @users
08:41:53 <lambdabot> Maximum users seen in #haskell: 550, currently: 514 (93.5%), active: 15 (2.9%)
08:42:04 <conal> i wonder if there's a nice functional style in which one can do LRU-based caching.
08:42:32 <conal> maybe something like weak references, but with real-valued strength instead of boolean valued
08:42:54 <conal> where the pointer strength decays with time and is refreshed on use.
08:43:33 <conal> and when the space gets freed, it reverts to an unevaluated state
08:43:43 <conal> semantically transparently / functionally
08:44:20 <wchogg> conal:  Are there any hooks to be able to implement a weak reference like that without modifying ghc?
08:44:33 <conal> wchogg: ghc has weak reference.
08:44:43 <conal> thanks to frp.
08:44:43 <b4taylor> I don't suppose hackage has any stats like: "How many packages at their head release built/failed with ghc 6.10"
08:45:18 <conal> @go "stretching the storage manager"
08:45:33 <lambdabot> Plugin `search' failed with: thread killed
08:45:39 <conal> oops
08:45:54 <b4taylor> http://research.microsoft.com/research/pubs/view.aspx?id=566&type=Publication
08:45:55 <b4taylor> ?
08:45:56 <lambdabot> Title: Stretching the Storage Manager: Weak Pointers and Stable Names in Haskell, http://tinyurl.com/6yx99z
08:46:01 <conal> that's it.
08:47:02 <conal> there's a bit of chat on the DataDriven wiki page about garbage collection being biased toward demand-driven evaluation.
08:47:02 <mdmkolbe> are there any haskell impementations out there that have added string literal overloading in the same way that integer literals are overloaded (i.e. 1 really means (fromInteger 1))?
08:47:21 <conal> @wiki DataDriven
08:47:21 <lambdabot> http://www.haskell.org/haskellwiki/DataDriven
08:48:04 <wchogg> mdmkolbe:  I thought GHC had that now, but not sure if it's a default or an option.
08:48:07 <conal> and gc being unfriendly to data-driven architectures.
08:49:00 <conal> mdmkolbe: doing 'ghc --supported-languages' might show something
08:49:18 <conal> yeah.
08:49:23 <conal> OverloadedStrings
08:49:43 <mdmkolbe> cool, thx
08:50:04 <conal> i still want OverloadedIfThenElse
08:50:29 <conal> for behaviors & syntax manipulation
08:54:05 <mdmkolbe> conal: I don't know about if/then/else, but it would definately make sense to extend this to the other literals (i.e. floats and chars)
08:55:24 <conal> i'm for eliminating language ad-hoc-eries, like wired-in Bool-only if-then-else, in general.
08:55:42 <conal> and i've often wanted a more flexible if-then-else
08:56:03 <apsod> how so?
08:56:51 <conal> i often use liftA3 (\ i t e -> if i then t else e)
08:57:07 <quicksilver> mdmkolbe: floats are already overloaded
08:57:12 <quicksilver> > 3.14 :: Rational
08:57:13 <conal> e.g., for behaviors, images, and syntax-manipulators.
08:57:15 <lambdabot>   157%50
08:57:46 <quicksilver> conal: that does have the subtle effect of processing the effect of both clauses though.
08:58:13 <conal> quicksilver: yeah it does.  i often forget, since i program functionally.
08:58:16 <mdmkolbe> quicksilver: I think you mean Fractional which has fromRational, but good point (that only leaves char as the odd man out)
08:58:36 <quicksilver> conal: spare me the straw men ;P
08:58:40 <mdmkolbe> quicksilver: sorry I miss read what you said, we are in agreement
08:58:48 <quicksilver> conal: there's nothing non-function about the Maybe monad.
08:58:54 <quicksilver> non-functional.
08:59:10 <conal> quicksilver: oh.  does Maybe raise issues with that liftA3 ?
08:59:14 <quicksilver> yes.
08:59:32 <quicksilver> a 'Nothing' in the else branch will kill the whole thing
08:59:37 <quicksilver> even if the 'then' branch is the one taken
08:59:52 <conal> oh, thx.
09:00:06 <quicksilver> > let if' =  liftA3 (\ i t e -> if i then t else e) in if' (Just True) (Just 3) (Nothing)
09:00:07 <lambdabot>   Nothing
09:00:08 <mdmkolbe> @type liftA3
09:00:09 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
09:00:27 <quicksilver> conal: applicatives can have all kinds of interesting effects ;)
09:00:46 <quicksilver> conal: programming in the state applicative, you'd find the un-followed branch still had the ability to modify the state.
09:01:03 <quicksilver> conal: of course, that's not a problem if it's what you want, but it's something to think about ;)
09:01:57 <wchogg> quicksilver:  Oh, right, because applicative functors aren't powerful enough to 'choose' an execution path the way monads can.  I remember some comment to that effect.
09:01:59 <conal> quicksilver: yep.  doesn't seem to be a problem for my uses (images, behaviors & syntax)
09:02:33 <conal> s/images, behaviors/functions
09:02:56 <quicksilver> right, it's not a problem for the Reader monad
09:03:16 <quicksilver> and both Images and Behaviours are "like" that
09:03:41 <conal> yeah.  semantically they are functions.
09:03:47 <quicksilver> wchogg: yes. The "path" through the "effects" is static.
09:03:52 <quicksilver> wchogg: it can't depend on the data
09:04:03 <quicksilver> wchogg: monads can choose a path at runtime based on the data.
09:04:14 <quicksilver> "trace" might be a more conventional word
09:04:41 <conal> i'm going to exercise now.  back in a while.
09:06:11 <quicksilver> I wonder if in some circumstances the Behaviour version of if' might do un-necessary work
09:06:15 <quicksilver> I don't think so.
09:07:18 <FunctorSalad> any ideas why ghc suddenly depends on two different versions of process? http://hpaste.org/12171
09:07:39 <FunctorSalad> it wasn't like that yesterday :)
09:12:13 <Lemmih> Sigh, this is silly. "JHC-Options: --noauto" considers the "noauto" to be a comment.
09:13:23 <Lemmih> dcoutts: Ola?
09:17:45 <newsham> anyone know how I can avoid "user error (unknown GLUT call glutSetOption, check for freeglut)" when using reactive-fieldtrip and freeglut?
09:21:21 <Deewiant> newsham: use the version of GLUT they want, i.e. FreeGLUT? :-P
09:21:42 <EvilTerran> Deewiant, he said he was using freeglut
09:21:47 <newsham> i'm using freeglut.
09:22:03 <Deewiant> maybe you think you are but you aren't
09:22:32 <newsham> newsham@lenoxp2$ strings `which glut32.dll`|grep FREEGLUT
09:22:32 <newsham> FREEGLUT
09:23:13 <EvilTerran> ... using a DLL on linux?
09:23:15 <Deewiant> and is the program using that one? Are you linking with the right lib?
09:23:29 <newsham> not using linux at all
09:24:18 <EvilTerran> but... shell syntax...
09:24:24 <Deewiant> cygwin
09:24:50 * EvilTerran screams and runs away
09:25:09 <Deewiant> Don't worry, it's slow, it can't catch you
09:25:21 <quicksilver> newsham: you're not the first person to report it, but I don't know what the answer is I'm afraid.
09:25:29 * EvilTerran makes an alarmed facial expression and walks away calmly
09:38:23 <FunctorSalad> class ArrowIO arr where liftIO :: (b -> IO c) -> arr b c -- ?
09:38:35 <FunctorSalad> (should we have this in the arrows package?)
09:38:43 <FunctorSalad> and ArrowList
09:42:32 <quicksilver> FunctorSalad: probably, yes.
09:43:06 <FunctorSalad> hxt has these so it's not exactly my idea ;)
09:43:25 <quicksilver> ah yes, I thought I'd seen them somwehere;)
09:44:12 <atomb> @seen visq
09:44:12 <lambdabot> I saw visq leaving #haskell-soc and #haskell 2d 22h 41m 43s ago, and .
09:44:24 <Saizan_> HXT's classes tend to have too many methods
09:44:53 <FunctorSalad> Saizan_: agreed. harder to find the right one than to make it from the elementary interface :)
09:45:32 <FunctorSalad> aren't these two special cases of a "KleisliTransformer"?
09:45:49 <FunctorSalad> er, not a transformer
09:46:47 <FunctorSalad> but class ArrowKleisli m arr where liftK :: (b -> m c) -> arr b c
09:47:03 <FunctorSalad> don't know if the extra generality would help or hurt
09:48:00 <FunctorSalad> if m already is a complicated transformed monad, it would get ugly ;)
09:48:24 <Saizan_> @tell jsn i meant like the base4 flag here http://hackage.haskell.org/packages/archive/HAppS-Server/0.9.3.1/HAppS-Server.cabal , but cabal also includes dist/build/autogen/cabal_macros.h
09:48:25 <lambdabot> Consider it noted.
09:49:10 <Gabbie> Does lambdabot just match the nick or does it associate it with a hostmask of know users or soemthing?
09:49:45 <Saizan_> nick
09:50:13 <Gabbie> Thanks.
09:53:11 <Saizan> FunctorSalad: i wonder if you can write an instance of that for arrows that are not monads
09:55:21 <conal> newsham: still there?
09:56:18 <newsham> hi
09:57:12 <FunctorSalad> Saizan: good point, haven't thought about it
09:58:15 <newsham> conal: ?
09:58:22 <conal> newsham: i just added a section "Problems and solutions" to the FieldTrip page, describing the freeglut problem and my temporary solution.
09:58:28 <conal> @wiki FieldTrip
09:58:28 <lambdabot> http://www.haskell.org/haskellwiki/FieldTrip
09:58:48 <newsham> ty. i'll try it out
09:59:22 <conal> it's just a work-around, not a solution.
10:00:20 <FunctorSalad> maybe ArrowList would be more intuitive as ArrowNondeterministic?
10:01:05 <FunctorSalad> 'arr a b' is a computation that can spread out each value of a into any number of b's
10:01:33 <newsham> conal: hmm, but I built with freeglut
10:01:59 <conal> newsham: oh!
10:02:16 <conal> newsham: could be a problem with your GLUT package, then.
10:02:25 <newsham> unless somehow the build got confused and didnt use freeglut.
10:02:33 <conal> newsham: what do you mean by "I built with freeglut"?
10:03:05 <newsham> you sent me the page on how to build and install freeglut.  I followed those instructions, then I rebuilt and reinstalled the haskell bindings packages
10:03:16 <conal> oh.  hm.
10:11:00 <hackage> Uploaded to hackage: mediawiki 0.2.1
10:11:00 <hackage> Uploaded to hackage: mediawiki 0.2
10:16:54 * ksf dreamt tonight of being a halting oracle, knowing the class of all halting problems by looking at all enumerable sequences and comparing them to all sequences.
10:17:03 * ksf fears to be dangerously on-track.
10:17:36 <conal> quicksilver: thanks for straightening me out earlier about Applicative and functional effects.  I see now why to use the monadic conditional instead of the applicative one for things like Maybe, Either, and pair/writer.
10:17:36 <lament> dangerously on-crack?
10:17:49 <ksf> s/halting problems/halting algorithms
10:18:01 <ksf> nah, rather baldrian.
10:23:00 * ksf likes the concept, though, considering infinite structures as total iff they don't contain more than one infinity
10:23:25 <ksf> nope.
10:23:37 <ksf> rather no infinities surrounded by more-defined areas.
10:23:42 <Cale> "more than one infinity"?
10:23:54 <vixey> is there really an important difference between one infinity and two?
10:23:56 <ksf> like it the space between 1 and 2 and 2 and 3.
10:24:25 <ksf> i'm just babbling nonsense about enumerality.
10:24:43 <wchogg> ksf:  Are you talking about some topological sense of an infinite number of points within any open neighborhood?
10:25:06 <vixey> ksf, careful.. you might make sense if you're not careful
10:25:46 <ksf> wchogg, i guess so, but I certainly don't know the definition of open neighborhood.
10:26:50 <ksf> the idea is that x = x is in some sense equivalent to not being able to enumerate a certain sequence, as you can't tell what element comes next.
10:26:57 <ksf> it's so simple it almost hurts.
10:27:52 <lament> all matter and energy is really vibration.
10:28:18 <lament> and we're all parts of the universal consciousness.
10:28:20 <wchogg> lament:  Maybe, but they haven't gotten a good theory with that yet. :-P
10:28:21 <ksf> there's a difference between those three?
10:28:26 <Cale> lament: Everything in the universe is just one note.
10:28:28 <Cale> heh
10:28:32 <newsham> conal: sure enough if I comment out that line in SimpleGL my problem goes away.
10:28:46 <lament> Cale: what about two-note chords?
10:28:52 <newsham> which suggests that somehow (I'm baffled) its not using freeglut
10:29:03 <ksf> chords are notes with a different timbre.
10:29:09 <wchogg> lament:  chords were invented by the Illuminati to hide the true nature of the universe
10:29:14 <ksf> i.e. they include different overtones.
10:29:35 <conal> newsham: yeah.  maybe theres a glut.??? on your system that's getting picked up.  i wonder if there's something missing in those freeglut instructions.
10:29:36 <lament> that's a very bizarre definition of note
10:29:42 <lament> the universe is a note by that definition
10:30:40 <conal> newsham: you're on windows, right?
10:30:40 <ksf> well you can't just define a note as "a sine wave in some appropriate medium at such and such frequency", as honest-to-mathematics sines don't exist in nature.
10:30:44 <newsham> i did notice that c:\ghc\ghc-6.10.1\gcc-lib has its own libglut.a (vs libglut32.a which I copied in during instructions)
10:30:58 <newsham> but i moved that aside and rebuilt everything to be sure
10:31:07 <newsham> yes, this is winxp with 6.8.10
10:31:09 <newsham> err 6.10.1
10:31:10 <conal> newsham: would you look in GLUT.buildinfo.in, in your GLUT package?
10:31:17 * Cale defines a note as an element of L^2(C) for some reason.
10:31:23 <conal> newsham: and see if there's an "extra-libraries" line?
10:31:53 <newsham> no extra-libraries line
10:32:04 <newsham> ld-options:  -lglut32 -lglu32 -lopengl32
10:32:34 <conal> newsham: what's the name of the freeglut dll?
10:32:41 <lament> Cale: is that analytic functions or something?
10:32:52 <ksf> otoh, at some point i had the idea of dividing the observable objective reality from the unobservable objective reality by the existence of a true pi, that is, comparing how close you get to pi by arranging atoms in a circle-like manner and how close you get to pi by "measuring" a force field of an electron or such.
10:32:59 <newsham> the dll is glut32.dll and i copied in libglut32.a to the gcc-libs dir
10:33:07 <Cale> lament: Square integrable functions.
10:33:07 <newsham> (ie. the one being ref'd here)
10:33:11 <lament> ksf: i thought you wanted to just divide the observable objective reality by pi
10:33:15 <lament> at first
10:33:18 <lament> that seems like a cooler idea
10:33:28 <conal> newsham: try adding "extra-libraries: glut32" and rebuliding your GLUT package.
10:33:36 <PeakerWork> is it worth announcing to the mailing list that the Reactive mailing list has a google group made for it?
10:33:41 <conal> newsham: just to be sure: the freeglut lib is called glut32.dll ?
10:33:45 <Cale> lament: The nice thing being that they form a Hilbert space.
10:34:04 <newsham> /home/newsham/freeglut-2.4.0/src/glut32.dll
10:34:08 <vixey> @ksf
10:34:09 <lambdabot> Maybe you meant: ask bf msg
10:34:10 <vixey> @keal
10:34:11 <lambdabot> it is very easy to go off topic
10:34:13 <vixey> @keal
10:34:13 <lambdabot> nsa has all the profiling info you need to come up with the correct survey answers
10:34:27 <conal> PeakerWork: how did the google group come to be?
10:34:34 <conal> PeakerWork: and what's the url?
10:34:38 <ksf> nah i only multiply my thumb with pi.
10:34:45 <ksf> http://dict.leo.org/forum/viewUnsolvedquery.php?idThread=238979&idForum=1&lp=ende&lang=de
10:34:47 <lambdabot> Title: LEO Forum, http://tinyurl.com/6mgdrn
10:34:48 <lament> Cale: what's that have to do with notes?
10:34:49 <PeakerWork> conal: my friend here saw me use gmail to access the group, so he said "Don't be archaic!" and created http://groups.google.com/group/reactive-haskell/
10:34:49 <lambdabot> Title: reactive-haskell | Google Groups
10:35:03 <PeakerWork> conal: its basically a front-end to the mailing list (archives and sends to it)
10:35:17 <conal> PeakerWork: neat!  yes, please let the mailing list know.
10:35:48 <conal> PeakerWork: i wrestled with whether to use the old-fashioned mailman stuff or something prettier like google groups.
10:36:09 <conal> PeakerWork: i've run both google and yahoo groups, and to my surprise, i like yahoo better.
10:36:26 <PeakerWork> conal: Yahoo! are usually so incompetent at.. everything ;)
10:36:40 <arw> old-fashioned mailman? back in my time, mailman was the "get off my lawn you hippies" new stuff and majordomo was old...
10:36:42 <conal> PeakerWork: and google usually so rocking.
10:36:54 <newsham> same error with extra-libraries: glut32
10:37:06 <ksf> yahoo actually replaced lisp written by graham himself with, iirc, perl.
10:37:08 <conal> newsham: oh, urg.
10:37:27 <newsham> I can live with the reactive-glut workaround for now
10:37:33 <PeakerWork> ksf: "Graham himself"? :-)
10:37:35 <lament> ksf: probably a sound idea
10:37:56 <lament> would you trust graham-written lisp code? Especially in graham's absence?
10:38:14 <newsham> conal: if you are interested in more debugging I can help out, but I gotta get back to work.
10:38:27 <PeakerWork> Graham is the guy who said that not having any types/structure is so great because then his 2d points can scale up to any number of dimensions, oh my!
10:38:32 <conal> PeakerWork: is the google/mailman link bidirectional?  do all sends to one show up on the other?
10:38:41 <PeakerWork> conal: that's what my friend says
10:39:01 <conal> newsham: go ahead.  thanks for the report.
10:39:11 <newsham> i can poke around w/ it some more in about 7hrs.
10:39:24 <ksf> http://www.paulgraham.com/avg.html
10:39:26 <conal> PeakerWork: neat.  best of both then.
10:39:27 <ksf> footnote 1.
10:39:29 <lambdabot> Title: Beating the Averages
10:39:39 <lament> stop making fun of PG, it's too easy
10:39:50 <Cale> lament: Not a whole lot directly, but points in an L^2 space (usually L^2(R)) are used to represent states in quantum mechanics (actually, it's the projective version -- nonzero multiples of a vector refer to the same state)
10:40:28 <lament> Cale: ah
10:41:32 <Cale> and L^2 spaces are important to Fourier analysis as well
10:43:18 <C-Keen> Hi there! Is it known here why the ghc port is dysfunctional in FreeBSD 7.x until the release of 7.1?
10:43:34 <lament> Cale: i like to think of notes as things like "F"
10:43:43 <lament> and maybe "Bflat" :)
10:43:49 <Cale> lament: :)
10:44:10 <ksf> lament, you've never tuned an intrument, have you?
10:44:19 <Cale> lament: Of course, in that case, defining a note as a real number frequency is probably not so bad :)
10:44:34 <ksf> ,,, or you'll know that there are a lot more notes than you actually want to have.
10:44:39 <lunabot>  luna: parse error on input `or'
10:44:40 <lament> ksf: sure, an out of tune instrument is not playing any note
10:44:46 <lament> it's playing inbetween notes
10:45:03 <ksf> microtonal music?
10:45:04 <C-Keen> depending on your notation system
10:45:06 <ski_> (rational frequencies ?)
10:45:08 <Cale> Or you could define a note as a probability distribution of frequencies.
10:45:17 <ksf> not defining A as 440 but say 400 hz?
10:45:17 <lament> Cale: not frequency, it's a modular arithmetic thing
10:45:50 <lament> group of order 12
10:46:06 <ksf> ask pythagoras and his comma about rationality of frequency ratios.
10:47:01 <ksf> it's quite insane to even try to map 2^x to a repetitive linear scale
10:47:20 <lament> nevertheless it works quite well in practice
10:47:28 <lament> like many other insane things
10:47:38 <Cale> I've started to think that it's strange to limit ourselves to 12 note scales.
10:47:39 <FunctorSalad> logarithms are insane?
10:47:45 <lament> Cale: be careful
10:47:46 <ksf> not really, all tunings have their disadvantages.
10:47:57 <lament> Cale: insanity lies that way
10:48:07 <lament> FunctorSalad: yes.
10:48:25 <ksf> you need as many scales as you've got notes to get a repetitive mapping.
10:48:36 <Cale> Larger scales allow for some really interesting melodic structures, but chords in them seem harder to work with, but it's probably just lack of experience.
10:48:39 <lament> Cale: alternative temperaments are one of the pet subjects of pseudo-mathy nutjobs
10:48:46 <lament> timecube-style
10:49:04 <FunctorSalad> 12 notes is stupid and evil!!!
10:49:12 <FunctorSalad> ;)
10:49:19 <jpcooper> NEVER
10:49:39 <Cale> I'm not talking about temperaments. I'm talking about starting with an arbitrary set of frequencies as a foundation to build music on.
10:50:08 <jpcooper> Cale, have you seen the fretless guitars?
10:50:12 <Cale> jpcooper: yep
10:50:16 <lament> Cale: the usual tuning approximates the circle of fifths very well
10:50:26 <lament> Cale: the fact that there's 12 notes or whatever is not important;
10:50:34 <Cale> jpcooper: I've even seen a guitar which can switch between fretted/fretless using a lever
10:50:35 <lament> the circle of fifths is
10:50:40 <ksf> ...the important thing is the fifth in every one.
10:51:06 <jpcooper> wow
10:51:27 <ksf> ...which is defined by wave mechanics as the interval closest to an octave.
10:51:44 <wchogg> eh?
10:51:47 <ksf> firing gnuplot up would be a good idea now.
10:52:02 <ziman> well, we're limited by the number of `nice' fractions, like 3/2 or 4/3. I doubt 1/1 + 37/11 would sound nice.
10:52:26 <Cale> ziman: Depends on what you think of as 'nice'.
10:52:35 <wchogg> ziman:  is that just the bias of tradition or is there a hard reason why it wouldn't sound right
10:52:42 <ksf> ...not to forget that the phase difference between two notes plays an important role in the timbre of the resulting chord.
10:52:46 <ski_> lament : You are educated stupid, a cubic creature. Earth rotates 4 Corner Days !
10:52:54 <strattg> lol
10:53:22 <ksf> wchogg, wave mechanics.
10:53:25 <Cale> Dissonance is a bit of an acquired taste, but the more of it that you allow for, the wider the range of options you have for expression.
10:53:47 <ksf> harmony is very, very close related to resonance.
10:54:00 <ksf> it is'nt hard to make a string resonate by playing a fifth.
10:54:56 <ksf> so, in that sense, harmony is a result of the brain's accustomedness to usual physical laws.
10:55:01 <ziman> wchogg, empirically, the intervals expressed by the simplest fractions sound the best and I don't think it's only my experience.
10:55:14 <wchogg> ziman:  Neat, never heard that result before.
10:55:23 <ksf> define "simplest fractions"
10:55:27 <Cale> ksf: But still, you can preserve (at least to an approximation) those symmetries while adding more notes.
10:55:31 <ziman> ratios of small integers
10:55:39 <ksf> Cale, sure.
10:55:50 <ksf> but it's a numerical nightmare.
10:56:41 <Cale> Well, if you want to exactly preserve those ratios, and cyclic symmetry, you already get infinitely many notes :)
10:56:49 <Cale> (in an octave)
10:57:32 <ksf> in reality, though, all frequencies in any octave are enumerable.
10:58:00 <ziman> yes, pythagorean harmony can be tricky. I haven't expermiented much with it, though.
10:58:33 <Cale> Enumerable?
10:58:38 <ksf> http://en.wikipedia.org/wiki/Pythagorean_tuning
10:58:39 <lambdabot> Title: Pythagorean tuning - Wikipedia, the free encyclopedia
10:58:44 <ksf> see "wolf fifth"
10:59:11 <ksf> well a string has a limited number of atoms, and thus a limited number of frequencies.
10:59:35 <arw> not really.
10:59:38 <PeakerWork> does anyone remember how the divide-to-fives O(n) median algorithm works?
11:00:24 <arw> you can theoretically make a single atom vibrate in any frequency.
11:00:52 <arw> the same is true for a string. its only not a standing wave, thus not amplified.
11:01:30 * ksf stands corrected
11:03:48 <ziman> i think string vibration is a really rough approximation (classical mechanics) and taking it to the extent of quantum microworld isn't appropriate, imo.
11:05:18 <awarring> What is a first order polymorphic data type....is that a data type with one free type variable? They use the term in the "Generalizing Generalized Tries" paper, but searching for that term yields that paper as a first result :/
11:06:05 <vixey> maybe it's one that has a first order kind
11:06:11 <vixey> like *, * -> * or * -> * -> *
11:06:31 <vixey> wereas,  a type with kind (* -> *) -> * is second order, is that correct?
11:07:14 <afedorov> vixey: what is that notation describing?
11:07:20 <vixey> the kind of a type
11:07:24 <vixey> sorry
11:07:27 <vixey> the kind of a type constructor
11:08:26 <awarring> http://en.wikibooks.org/wiki/Haskell/Kinds
11:09:20 <mapreduce> :kind List
11:09:36 <vixey> :k []
11:09:38 <lambdabot> * -> *
11:10:14 <mapreduce> :t []
11:10:15 <lambdabot> forall a. [a]
11:10:18 <dolio> vixey: In Agda, do you know what a type like 'foo | bar' means?
11:10:47 <vixey> where
11:10:49 <vixey> ?
11:11:12 <dolio> In the "Context (environment)" display.
11:11:25 <quicksilver> conal: not at all. it's an interesting little quirk which was pointed out to me in this very channel ;)
11:11:28 <dolio> Although, elsewhere, too.
11:11:36 <afedorov> vixey, et al: what is a good theoretical approach to kinds? the wiki seems practical...
11:11:39 <vixey> no I don't really know what you mean
11:12:06 <vixey> afedorov, it's exactly simple types
11:12:26 <vixey> afedorov, (kinds are to types as non polymorphic types are to values)
11:12:49 <ski_> (awarring : possibly s/polymorphic/parameterized/ would be more correct ..)
11:12:52 <vixey> do you eve got it in source code dolio?
11:13:09 <conal> quicksilver: :)
11:13:12 <afedorov> ahum
11:13:14 * afedorov thinks
11:13:54 <ski_> (`forall a. Mayba a' is the type of a polymorphic value, while `Maybe' itself is a parameterized type)
11:14:48 <ski_> (a polymorphic type would be something like `Flip :: forall (k0 :: **) (k1 :: **) (k2 :: **). (k1 -> k0 -> k2) -> (k0 -> k1 -> k2)')
11:15:12 <vixey> what's **?
11:15:18 <ski_> * :: **
11:15:21 <sw17ch> What's the status of GHC on Solaris?
11:15:22 <vixey> ok
11:15:34 <wchogg> conal:  wasn't someone working on an alternative implementation of Reactive at some point?  Who was that?
11:16:56 <afedorov> vixey: do you have an example of a second-order polymorphic type?
11:17:10 <afedorov> something which :t is (* -> *) -> *
11:17:28 <vixey> (* -> *) -> * is a kind not a type
11:17:34 <vixey> you get it with :k not :t
11:17:40 <vixey> :t In
11:17:41 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
11:17:44 <vixey> :k Mu
11:17:48 <lambdabot> (* -> *) -> *
11:17:55 <afedorov> I meant :k, yeah
11:18:10 <conal> wchogg: a few people, including geezusfreeek, ryan ingram, luqui, & quicksilver
11:18:47 <wchogg> conal:  Didn't realize it was such a trendy thing!
11:18:52 <Deewiant> :k ListT
11:18:54 <lambdabot> Not in scope: type constructor or class `ListT'
11:19:03 <Deewiant> meh
11:19:21 <ski_> @kind Control.Monad.List.ListT
11:19:22 <lambdabot> (* -> *) -> * -> *
11:19:28 <quicksilver> afedorov: the depth of the kind is something different from the order of the polymorphism)
11:19:33 <conal> wchogg: i suspect folks were mainly uncomfortable with unamb.
11:19:51 <quicksilver> I am uncomfortable with unamb, however that was not my motivation.
11:20:06 <conal> quicksilver: what else?
11:20:10 <wchogg> quicksilver:  how much do you have implemented?
11:20:14 <quicksilver> my motivation was a desire to understand how I could build up Reactive from small pieces I understood
11:20:25 <quicksilver> rather than take someone else's implementation and use it ;)
11:20:38 <dcoutts> Lemmih: hia :-)
11:20:40 <conal> quicksilver: yep.  i hear that one also.  i'd probably do the same.
11:20:47 <dcoutts> Lemmih: sorry, was working earlier
11:21:05 <quicksilver> I wanted to see if I could alter existing code piecemeal to take some good ideas from Reactive without having to rip all the IO out in one go.
11:22:27 <quicksilver> actually I'm more uncomfortable with using pure blocking values as an implementation technique than unamb, per se.
11:22:28 <Lemmih> dcoutts: cabal-install barks when I try to install base-1.0 (for jhc). Renaming the package to lhc-base bypasses the problem. Is this intentional?
11:22:45 <conal> quicksilver: oh!  i'm curious about that experiment.  i've thought of exploring incremental application of FRP to imperative architectures, but haven't done it.
11:23:03 <dcoutts> Lemmih: I've not been able to test jhc support since I cannot build jhc
11:23:17 <dcoutts> Lemmih: if you've got patches to improve jhc support that'd be great
11:23:18 <quicksilver> wchogg: quite a bit. enough to write a program which displays a 3D scene lets you zoom in and out with keyboard and highlights elements your mouse moves over
11:23:34 <conal> quicksilver: neat
11:23:38 <quicksilver> conal: I'll let you know (experiment not yet complete enough to have interesting results ;)
11:23:46 <wchogg> quicksilver:  So...enough that I could see if you have the same issues with recursive Behavior's?
11:23:51 <dcoutts> Lemmih: what is the error in particular?
11:24:09 <quicksilver> wchogg: I would imagine so, although you might find I'm missing some combinators.
11:24:16 <quicksilver> I've been implementing combinators lazily.
11:24:25 <Lemmih> dcoutts: "cabal: There is no available version of base that satisfies ==1.0"
11:24:38 <wchogg> Hah...only as you need them?
11:24:45 <quicksilver> right
11:24:46 <Lemmih> dcoutts: ^^ I get that while trying to install base-1.0.
11:25:06 <quicksilver> lazily evaluated metaprogramming
11:25:08 <dcoutts> Lemmih: and is base-1.0 actually available on hackage?
11:25:30 <wchogg> quicksilver:  I like that idea.  The entire library is done, you just have evaluated it yet.
11:25:34 <wchogg> *haven't
11:25:37 <Lemmih> dcoutts: I'm installing from a local directory.
11:25:56 <quicksilver> wchogg: not just the library. My entire life's work.
11:26:15 <wchogg> quicksilver:  Wow!  Impressive.
11:26:20 <quicksilver> ;)
11:26:44 <dcoutts> Lemmih: so the local base.cabal says 1.0 and doing "cabal install" fails with that message
11:26:55 <Lemmih> dcoutts: Yep.
11:27:19 <dcoutts> Lemmih: hmm, we may well actually hide base when doing the dep planning to stop cabal-install trying to upgrade it when it is impossible
11:27:41 <dcoutts> Lemmih: so that'll probably be it. If the user really wants to install/upgrade base then I guess we should not hide it.
11:27:56 <dcoutts> Lemmih: which explains why renaming it works
11:28:34 <dcoutts> Lemmih: see hideBasePackage in Distribution/Client/Dependency.hs
11:28:58 <wchogg> quicksilver:  so where can I nab your version of Reactive?
11:30:26 <sw17ch> quicksilver, since you seem to be the go-to guy for reactive... are there good resource to learn *what* it is yet?
11:30:51 <quicksilver> wchogg:
11:30:53 <quicksilver> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=494#a494
11:31:19 <quicksilver> And I said unto my disciples, "Go To! And learn Reactive."
11:31:33 <quicksilver> sw17ch: I recommend conal's paper
11:31:58 <quicksilver> (with, I admit, slightly mixed feelings, because of the way it presents semantics + implementation)
11:32:17 <sw17ch> quicksilver, is it someplace that doesn't require $$ to read?
11:32:36 <quicksilver> yup.
11:32:41 <afedorov> quicksilver: could you explain "the depth of the kind is something different from the order of the polymorphism"
11:32:42 <sw17ch> quicksilver, linky? :D
11:32:48 <afedorov> quicksilver: what is the depth of a kind?
11:32:56 <afedorov> quicksilver: what is the order of the polymorphism?
11:32:57 <quicksilver> http://conal.net/papers/simply-reactive/
11:33:00 <sw17ch> (* -> * -> *) vs (* -> *) ?
11:33:06 <lambdabot> Title: Simply efficient functional reactivity
11:33:13 <sw17ch> quicksilver, thanks!
11:33:17 <quicksilver> afedorov: (* -> *) -> * is a higher kind than *
11:33:24 <afedorov> sw17ch: those are kinds of depth 3 and 2?
11:33:46 <quicksilver> (forall b . (forall a.a) ->  b)
11:33:46 <afedorov> "higher" referring to a bigger depth, or a higher order?
11:33:54 <quicksilver> ^^ that is higher rank polymorphism
11:34:09 <afedorov> gotcha
11:34:15 <quicksilver> higher *order* polymorphism is where you quantify over something other than types
11:34:18 <sw17ch> quicksilver, actually, i ran into this kind problem a while ago
11:34:24 <quicksilver> it's not a commonly used phrase.
11:34:31 <afedorov> and sw17ch's example is a "deeper" kind?
11:34:43 <sw17ch> i wanted to make instances of wider tuples
11:34:45 <quicksilver> I'm not sure what the right word is for kinds.
11:34:48 <sw17ch> or, several different tuples
11:35:06 <sw17ch> instance Foo (a,b) where ... instance Foo (a,b,c) where ...
11:35:08 <sw17ch> etc..
11:35:26 <quicksilver> sw17ch: that's rally just an expressivity problem with haskell's tuples
11:35:37 <quicksilver> namely that they are a family of totally unrelates types
11:35:39 <sw17ch> quicksilver, well, i think my issue was a little funny
11:35:47 <sw17ch> well, no, that's the issue :)
11:35:48 <sw17ch> yes
11:35:51 <quicksilver> rather than being part of some scheme you can quantiy over
11:36:16 <sw17ch> the exact implementation i was hoping for was to make tuples of TChan's
11:36:31 <quicksilver> HList can solve this problems.
11:36:40 <quicksilver> You risk only your sanity.
11:36:44 <sw17ch> instance Foo (a,b) where a' <- newTChan; b' <- newTChan; return (a',b')
11:36:58 <sw17ch> and then the instance for Foo (a,b,c) would be similar
11:37:01 <sw17ch> only three wide instaed of two
11:37:08 <quicksilver> yup, you can do that with HList
11:37:22 <sw17ch> quicksilver, and the width is compile-time checked?
11:37:30 <quicksilver> HList is just nested tuples and a menagerie of type classes to regulat them.
11:37:43 <sw17ch> quicksilver, My sanity means little to me if i can make this work
11:37:47 <Lemmih> dcoutts: I disabled it for jhc. It's probably not the correct solution.
11:37:47 <sw17ch> :D
11:38:16 <quicksilver> sw17ch: The solution I recommend is to send a post to the cafe, cross your fingers, and hope Oleg replies.
11:38:26 <quicksilver> If he does, he'll solve it in HList ;)
11:38:54 <quicksilver> Call it something like 'generic instance of TChan wrapper for tuples of all width'
11:39:07 <quicksilver> i.e. giive it a good subject line.
11:39:26 <sw17ch> quicksilver, heh, i like it :)
11:39:45 <sw17ch> I was trying to implement a chain of communicating threads
11:40:03 <sw17ch> that automatically setup their TChan's for communication and the thread for each step
11:40:22 <sw17ch> and the problem i hit was that i couldn't make instances in the way i was describing
11:40:27 <sw17ch> i'll hit up cafe and see what happens
11:45:11 <dcoutts> Lemmih: no, the correct solution would be for it to not hide it if the user specifically asked to upgrade/install base
11:45:20 <dcoutts> Lemmih: it's not specific to jhc
11:49:20 <conal> quicksilver: "I recommend conal's paper (with, I admit, slightly mixed feelings, because of the way it presents semantics + implementation)".  would you mind elaborating?  for instance, do you mean the fact _that_ the paper presents both, or something about _how_ it does?
11:51:26 <quicksilver> conal: how it does
11:51:40 <quicksilver> conal: you use haskell-notation for the semantics : which is neat.
11:51:55 <quicksilver> conal: but you don't make it clear (to me! at least) that that is really a kind of sleight of hand.
11:52:05 <quicksilver> conal: and it's not the same as the implementation.
11:52:35 <quicksilver> in short: reusing notation = clever. But I think you could be clearer that you are talking about different things.
11:52:39 <conal> quicksilver: oh, okay.  thanks.  you're right that it's not.
11:52:59 <quicksilver> in fact, there are three things discussed in that paper.
11:53:01 <newsham> semantic brackets?
11:53:13 <quicksilver> (1) semantics (2) interface (3) implementation
11:53:27 <quicksilver> the separation between all three could be emboldened a little.
11:53:59 <quicksilver> conal: it would have been more polite for me to submit these comments by email than in a public channel; sorry.
11:54:18 <conal> quicksilver: i don't mind at all.
11:54:32 <conal> quicksilver: and i agree with your remarks.  thanks again.  i appreciate the feedback.
11:54:47 <conal> i do intent to split that paper up into several.  it was too packed.
11:55:29 <conal> that paper is a very condensed distillation of many years of noodling.
11:55:36 <wchogg> conal:  Oh, speaking of your paper I saw that on its page the version is from 11/10/08.  What's changed?  I couldn't tell the difference.
11:55:58 <conal> wchogg: let me look at the darcs log ...
11:56:35 <conal> wchogg: i fixed the definition of 'race'.
11:56:40 <quicksilver> conal: and, actually, I think it's not unreasonable to have a condensed version. Depending on the audience. But a condensed version needs to be careful to be clear about the separation as well as what (if anything) was omitted in the interests of brevity.
11:57:16 <conal> wchogg: it was too clever in the paper and had a subtle race condition.  i learned that one can do a killThread on an already dead thread, which simplified things.
11:57:24 <wchogg> quicksilver:  Two tracks?  One for the FRP newb & one for reference?
11:57:31 <wchogg> conal:  Ah, okay.
11:57:38 <conal> quicksilver: yep.  i agree again.
12:11:30 <mnislaih> dcoutts: ping
12:11:42 <mnislaih> dcoutts: I'm trying to set up a local Hackage repository for use with cabal-install
12:12:15 <mnislaih> any advice on that ? I plan to contribute patches for cabal-install  if I succeed
12:12:39 <chickenMcNygger> hi
12:12:55 <chickenMcNygger> ya know when you eat rump roast, you're eating a cow's butt.
12:13:00 <EvilTerran> ?where ops
12:13:00 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
12:13:15 --- mode: ChanServ set +o Igloo
12:13:31 --- mode: Igloo set +b *!*@70.44.52.171
12:13:35 --- kick: chickenMcNygger was kicked by Igloo (Igloo)
12:13:36 <mnislaih> dcoutts: so far I am generating my own dir structure and index file from a set of tar.gz'd packages. cabal-install consumes my index file happily, but generates the wrong URLs when asked to install one of 'my' packages
12:13:40 <EvilTerran> Igloo++
12:13:43 --- mode: Igloo set -o Igloo
12:13:53 <Igloo> Thanks for the heads-up, EvilTerran
12:14:13 <EvilTerran> i figure that's what ?where ops is for :)
12:14:27 <dcoutts> mnislaih: you may prefer to try the new hackage-server, rather than setting up an apache instance with the cgi hackage-scripts
12:14:30 <Igloo> yup
12:15:00 <dcoutts> mnislaih: to be honest Ive no experience with setting up the existing hackage-scripts, your guess is as good as mine. I've been working on the new hackage-server
12:15:24 <mnislaih> dcoutts: I added cabal-install to generate all the directory infrastructure for me. I am not interested in setting up a full hackage! just a tiny static repository
12:15:41 <mnislaih> I extended* cabal-install with a new command, I meant to write
12:15:52 <dcoutts> mnislaih: ah I see, just a static repo
12:16:19 <mnislaih> is there any other place where configuration is required apart from the config file ?
12:16:41 <dcoutts> mnislaih: cabal-install just reads the ~/.cabal/config
12:17:15 <dcoutts> mnislaih: so how are the urls wrong? how did you configure cabal-install?
12:17:36 <mnislaih> see here http://hpaste.org/12176
12:18:05 <mnislaih> this is the repos line I added to the config file: repos: mnislaih:http://safe-tools.dsic.upv.es/~pepe/packages
12:18:14 <lambdabot> Title: Index of /~pepe/packages
12:18:40 <dcoutts> mnislaih: ah yes, so that url scheme is for the new hackage-server, though even that isn't final.
12:19:31 <mnislaih> ahm ok, I didn't knew about the new hackage server
12:19:59 <mnislaih> I'll change it to stick to the current scheme for this.
12:20:04 <dcoutts> mnislaih: so there's a hack in cabal-install so that it can still download from the existing hackage server
12:20:25 <dcoutts> mnislaih: but the new server uses a more sensible url scheme (and redirects old to new)
12:20:43 <mnislaih> ack ! good thing that I asked
12:23:37 <dcoutts> mnislaih: so what're you trying to do exactly?
12:24:14 <mnislaih> I have a bunch of packages for my uni work and I am bored of installing them manually every time there is a machine change, compiler change, etc.
12:24:35 <mnislaih> (and I'm too embarrassed to upload them to hackage)
12:25:20 <mnislaih> so I'm setting up a static hackage repo with the help of cabal-install to generate the index file and dir structure for me
12:26:18 <dcoutts> mnislaih: I see, that's certainly a use-case we want to support
12:26:28 <dcoutts> mnislaih: sorry the non-default url scheme is messed up atm
12:26:42 <dcoutts> mnislaih: file a bug if you like so we don't forget
12:26:57 <mnislaih> dcoutts: that's fine, I'm working with the head so I should have checked the darcs history
12:28:44 <mnislaih> dcoutts: I'll file a bug to request this feature and upload the patch
12:29:34 <dcoutts> mnislaih: ta
12:43:41 <orionstar>  #flex
12:43:44 <orionstar> mt
12:52:55 <joelr1> good evening
12:54:53 <dons> gwern: http://www.reddit.com/r/haskell/comments/7e70l/a_complete_binding_to_mediawiki_for_haskell/
12:54:59 <lambdabot> Title: A complete binding to MediaWiki for Haskell! : haskell, http://tinyurl.com/6hwkkc
12:56:26 <EmielRegis> > 1/2 - (1/(2*exp(10))
12:56:28 <lambdabot>   <no location info>: parse error on input `;'
12:56:35 <EmielRegis> > 1/2 - (1/(2*exp(10)))
12:56:37 <lambdabot>   0.49997730003511875
12:56:42 <EmielRegis> > 1/2 - (1/(2*exp(100)))
12:56:42 <Vulpyne> Wow, ghc 6.10.1's configure script tries to call ghc-pkg with flags that are no longer supported in ghc 6.10.1.
12:56:43 <lambdabot>   0.5
12:56:58 <EmielRegis> > 2 * (exp 100)
12:57:00 <lambdabot>   5.376234283632271e43
12:57:22 <EmielRegis> > (1 / (2 * (exp 100))) :: Double
12:57:23 <lambdabot>   1.8600379880104178e-44
12:57:36 <EmielRegis> >  (1/2 - (1 / (2 * (exp 100)))) :: Double
12:57:37 <lambdabot>   0.5
12:59:34 <jkramar> I have both the stream-fusion and the stream (i.e. infinite list) package installed, and I'd like to use the latter but when I try to use Data.Stream, ghci complains: Could not find module `Data.Stream': it was found in multiple packages: stream-fusion-0.1.2.1 Stream-0.2.2
12:59:38 <jkramar> any suggestions?
12:59:45 <trofi> > (1/2 - (1 / (2 * (exp 100)))) :: CReal
12:59:46 <lambdabot>   0.5
13:01:23 <Blacker47> hello. I learn haskell and get some trouble with one exercise. I don't get how to work with some self-defined datas: http://hpaste.org/12180
13:01:50 <jkramar> oh sorry, I see there are ghc options mentioned in the manpage to take care of it
13:03:12 <mauke> Blacker47: you're supposed to use pattern matching, not guards
13:03:35 <Blacker47> mauke, that means?
13:03:35 <mauke> apply (Move : xs) (a : as) = ...
13:03:44 <mauke> apply (Change c : xs) (a : as) = ...
13:03:53 <Blacker47> oh.. let try it :-)
13:04:12 <mauke> the '| boolean-expression' thing is called a guard
13:05:32 <trofi> :t guard
13:05:33 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:06:05 <jkramar> or you can use apply (x:xs) (a:as) = case x of Move -> onething; Change c -> otherthing
13:06:32 <Blacker47> mauke, the pattern-method seems to work, thanks :-)
13:09:43 <eu-prleu-peupeu> hello Hppl
13:21:41 <dmead> > reverse . tail . reverse [1..10]
13:21:42 <lambdabot>   Couldn't match expected type `a -> [a1]'
13:21:50 <dmead> > reverse . tail . reverse  $[1..10]
13:21:51 <lambdabot>   [1,2,3,4,5,6,7,8,9]
13:22:35 <vixey> > init $ [1..10]
13:22:36 <lambdabot>   [1,2,3,4,5,6,7,8,9]
13:22:45 <dmead> ty
13:22:52 <dmead> > inits [1..10]
13:22:53 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
13:22:55 <dmead> right
13:24:21 <dmead> > inits [1..3]
13:24:22 <lambdabot>   [[],[1],[1,2],[1,2,3]]
13:26:42 <yitz> @src init
13:26:43 <lambdabot> init [x]    = []
13:26:43 <lambdabot> init (x:xs) = x : init xs
13:26:43 <lambdabot> init []     = undefined
13:28:38 <ddvlad> is there a predefined sort function for (Ord a) => [a] ?
13:28:44 <vixey> who writes = undefined?a
13:28:49 <vixey> :t sort
13:28:50 <lambdabot> forall a. (Ord a) => [a] -> [a]
13:28:57 <trofi> Data.List.sort
13:29:08 <trofi> @hoogle sort
13:29:08 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
13:29:08 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
13:29:08 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
13:29:12 <trofi> @hoogle sortBy
13:29:12 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
13:29:23 <vixey> ...
13:29:39 <yitz> @src inits
13:29:40 <lambdabot> inits []     =  [[]]
13:29:40 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
13:29:55 <yitz> weird. [[]] ++ should be [] :
13:30:18 <Deewiant> it compiles to the same code
13:30:20 <vixey> yitz, what do you mean?
13:30:39 <ddvlad> what the hey... should've looked better, and @hoogle is kinda new to me :)
13:30:54 <yitz> Deewiant: are you sure?
13:31:05 <Deewiant> yitz: yes, I checked it once.
13:31:09 <yitz> even if so, it sure looks funny
13:31:13 <Deewiant> [x] ++ compiles to the same code as x :
13:31:44 <apsod> heh
13:31:58 <vixey> @quote
13:31:58 <lambdabot> LarryWall says: <TimToady> learning Haskell itself is easy--I've done it several times already
13:32:00 <vixey> @quote
13:32:01 <lambdabot> Heffalump says: I need to teach my girlfriend temporal logic. she seems to have problems with the "until" operator.
13:32:04 <vixey> @quote
13:32:04 <lambdabot> <herpesBot> says: I don't what you think maths is, but it aint that
13:32:15 <Deewiant> @ghc
13:32:15 <lambdabot> ghc says: Kinds don't match in type application
13:34:08 <yitz> @. vixen quote
13:34:08 <lambdabot> If something takes a lot of effort to do, it probably ain't worth doing.
13:41:38 <dolio> > snd $ foldr (\e ~(xs, i) -> (e:i, if null xs then [] else e:i)) ([], undefined) [1..10]
13:41:39 <lambdabot>   [1,2,3,4,5,6,7,8,9]
13:42:49 <Deewiant> > snd $ foldr (\e (xs, i) -> (e:i, if null xs then [] else e:i)) ([], undefined) [1..10]
13:42:51 <lambdabot>   [1,2,3,4,5,6,7,8,9]
13:44:11 <dolio> > snd $ foldr (\e ~(b, i) -> (False, if b then [] else e:i)) (True, undefined) [1..10]
13:44:12 <lambdabot>   [1,2,3,4,5,6,7,8,9]
13:44:23 <dolio> > snd $ foldr (\e (xs, i) -> (e:i, if null xs then [] else e:i)) ([], undefined) [1..]
13:44:25 <lambdabot>   * Exception: stack overflow
13:45:55 <dolio> > snd $ foldr (\e ~(b, i) -> (False, if b then [] else e:i)) (True, undefined) [1..]
13:45:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:46:48 <vixey> hm
13:47:08 <vixey> > foldr (\x ys -> ys*10 + x) 0 [6,9,8,6,5,7]
13:47:09 <lambdabot>   756896
13:48:14 <vixey> > unfoldr (\n -> case n of 0 -> Nothing ; _ -> Just (divMod n 10)) 756896
13:48:15 <lambdabot>   [75689,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:48:22 <vixey> :/
13:48:34 <vixey> @let swap (x,y) = (y,x)
13:48:35 <lambdabot>  Defined.
13:48:37 <vixey> > unfoldr (\n -> case n of 0 -> Nothing ; _ -> Just (swap (divMod n 10))) 756896
13:48:38 <lambdabot>   [6,9,8,6,5,7]
13:49:30 <vixey> > foldr (\x ys -> ys*10 + fromIntegral (chr x) / 255) 0 "hello world" / (10 ** length "hello world") :: CReal
13:49:31 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
13:49:44 <vixey> > foldr (\x ys -> ys*10 + fromIntegral (chr x) / 255) 0 "hello world" / (10 ** fromIntegral (length "hello world")) :: CReal
13:49:46 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
13:49:53 <vixey> > foldr (\x ys -> ys*10 + fromIntegral (ord x) / 255) 0 "hello world" / (10 ** fromIntegral (length "hello world")) :: CReal
13:49:54 <lambdabot>   0.0439464090162352941176470588235294117647
13:49:56 <vixey> is that arithmetic coding?
13:50:24 <vixey> just need to sort of, not use CReal
13:50:47 <vixey> bitshift integers instead
13:53:49 <DukeDave> Um, is this, uh, what:   http://www.haskell.org/haskellwiki/Data_declaration_with_constraint
13:53:51 <lambdabot> Title: Data declaration with constraint - HaskellWiki, http://tinyurl.com/6kk77f
13:54:48 <dolio> What about it?
13:56:08 <DukeDave> dolio: Sorry disregard that I got myself confused :)
13:56:56 <Deewiant> Ah, the constraints are on the constructors, that makes sense. I always wondered what it was supposed to do given that it seemed to do nothing :-)
13:57:30 <dolio> GADTs in GHC fix that oversight, by the way.
13:57:49 <DukeDave> Am I missing the point here?
13:57:55 <luite> is there a map data structure in the standard lib or hackage where I can ask 'get the value for the largest key smaller than n' ?
13:58:01 <dolio> data T a where C a => Cons :: a -> T a stores the type class evidence.
13:58:17 <Deewiant> luite: Data.Map
13:58:42 <luite> Deewiant: hm, I looked in the docs, but I couldn't find anything that supports that operation directly
13:58:46 <Deewiant> luite: split on n and then findMax
13:59:04 <luite> Deewiant: wouldn't that cause a complete rebalance of the tree?
13:59:17 <Deewiant> well, the split returns two new trees
13:59:24 <Deewiant> so yes, you can't do it directly
13:59:39 <EmielRegis> > ln( abs(-e^300))
13:59:39 <Deewiant> but of course you can still refer to the old tree :-P
13:59:40 <lambdabot>   Not in scope: `ln'
13:59:45 <EmielRegis> > log( abs(-e^300))
13:59:46 <lambdabot>   log (abs (negate (e * e * (e * e) * (e * e * (e * e)) * (e * e * (e * e) * ...
13:59:50 <Deewiant> unless you want to remove it, in which case it's not optimal
13:59:51 <EmielRegis> ...
13:59:56 <Deewiant> but oh well
13:59:57 <EmielRegis> > log( abs(-exp(300)))
13:59:59 <lambdabot>   300.0
14:00:04 <EmielRegis> im_maciek,
14:00:06 <EmielRegis> :P
14:00:11 <luite> Deewiant: yeah, but it sounds like n log n complexity for something log n
14:00:11 <ziman> wow :)
14:00:20 <ziman> > e^5
14:00:21 <lambdabot>   e * e * (e * e) * e
14:00:24 <ziman> nice :)
14:00:25 <Deewiant> luite: it's not n log n; split is log n
14:00:32 <Deewiant> and so are the other operations
14:00:32 <EmielRegis> e is not eulers number tho ziman
14:00:34 <EmielRegis> > :t e
14:00:35 <lambdabot>   <no location info>: parse error on input `:'
14:00:37 <luite> Deewiant: oh good
14:00:38 <Deewiant> the constant factor is higher
14:00:38 <EmielRegis> uhm
14:00:44 <EmielRegis> exp is e
14:00:48 <Deewiant> luite: at least, I think it's log n. I'm not sure but I think so :-P
14:00:49 <dolio> DukeDave: The problem is 'data C a => T a = Cons a' gives Cons a type of 'C a => a -> T a', but when you destruct a Cons, it doesn't remember that the thing stored in it must always be in the class C like you might want.
14:00:55 <luite> Deewiant: yeah the docs say so
14:00:56 <ziman> EmielRegis, my point was exponentiation by quaring
14:01:03 <ziman> *squaring
14:01:14 <DukeDave> dolio: Crap
14:01:27 * DukeDave reloads class
14:01:37 <dolio> DukeDave: But if you write it as a GADT: 'data T a where Cons :: C a => a -> T a', then that does get remembered.
14:02:04 <luite> Deewiant: didn't see that at first. I'll just use that then. thanks for the suggestion
14:02:13 <dolio> So when you match against a Cons, it provides the evidence that the a is in C, rather than you having to put the constraint on your function.
14:02:26 <Deewiant> luite: you can file a proposal for a direct implementation if you want, it's a reasonable request.
14:02:27 <tibbe> I get "ld: in /private/var/folders/zz/zzzivhrRnAmviuee++0ZSk++dLg/-Tmp-/zlib-0.5.0.0/dist/build/libHSzlib-0.5.0.0.a, archive has no table of contents" when trying to build cabal-install
14:02:58 <DukeDave> dolio: Great! Thanks :D
14:03:08 <tibbe> any idea what the problem could be?
14:03:11 <tibbe> @seen dcoutts
14:03:12 <lambdabot> dcoutts is in #ghc, #haskell, #gentoo-haskell, #haskell-soc and #haskell-overflow. I last heard dcoutts speak 1h 32m 34s ago.
14:03:17 <tibbe> dcoutts: ping
14:05:36 <DukeDave> dolio: Can I shorten this (since it's a newtype style datatype decl):   newtype TFramedTransport where TFramedTransport :: TTransport t => t -> TFramedTransport t
14:06:26 <dolio> I don't think it works for newtypes. And you have to put the parameter there (or an explicit kind annotation).
14:07:52 <dolio> DukeDave: Note, strictly speaking, 'data T a where Cons :: C a => a -> t a' isn't just an 'a', it's a product of an 'a' and a dictionary for 'C a' (in a GHC-like implementation), so it's kind of inelligible for being a newtype.
14:09:09 <DukeDave> dolio: Hmm the expression I gave loads into ghci, you think it'll blow up at runtime?
14:09:25 <dolio> It does?
14:09:30 <DukeDave> Seems to
14:09:50 <DukeDave> I'll finish up the module and ping you when it dies ;)
14:09:56 <dolio> Color me surprised...
14:10:51 <dolio> I definitely get a kind error.
14:11:36 <dolio> And newtype doesn't work either.
14:12:05 <lispy> dolio: would it help to explicitly give the kind in the data declaration?
14:12:10 <lispy> you can do that if you use a GHC extension
14:12:21 <tibbe> dcoutts: I need to manually run ranlib on both of the generated .a files after using the cabal-install bootstrap instructions that were posted on the GHC blog recently. Mac OS X Leopard, Intel
14:12:42 <dolio> lispy: Sure. It's usually a lot easier to just use variables, though.
14:14:29 <DukeDave> dolio: I have -fglasgow-exts is that's.. Cheating?
14:14:42 <vixey> DukeDave, may prefer -X<whatever> to be more specific
14:15:07 <dolio> I like typing in all the extensions explicitly, but it's up to you.
14:15:17 <DukeDave> Ah
14:15:29 <DukeDave> I just wondered if that could cause it to load okay my end?
14:16:17 <dolio> It shouldn't.
14:16:47 <DukeDave> dolio: Yey:     Kind error: `TFramedTransport' is applied to too many type arguments
14:16:55 <DukeDave> I just had some other bugs getting in the way
14:17:00 <DukeDave> So I'm.. Screwed?
14:17:26 <DukeDave> Can I just use records?
14:17:30 <DukeDave> Is that sensible?
14:18:18 <dolio> Why don't you just make it 'data TFramedTransport t where TFramedTransport :: TTransport t => t -> TFramedTransport t'?
14:18:48 <DukeDave> Oh right,
14:18:59 <DukeDave> Yes sorry, the problem was just caused by newtype wasn't it
14:20:13 <dolio> That and the missing t at the top.
14:21:34 <ddarius> Um... that type doesn't seem particularly useful anyway...
14:22:05 <dolio> Yeah, not really.
14:22:32 <dolio> The main use I've seen for such things is to get around class constraints in stuff like Monad methods.
14:22:44 <DukeDave> :|
14:22:50 <DukeDave> I think I've broken it anyway
14:23:18 <DukeDave> Getting an "infinite type" error
14:23:33 <ddarius> dolio: That's not what I'm talking about.
14:23:40 <ddarius> dolio: Think about what the values would be.
14:23:46 <DukeDave> Trying to make TFramedTransport an instance of TTransport
14:25:56 <dolio> ddarius: It's isomorphic to t, except it has proof that t is in TTransport.
14:26:13 <ddarius> dolio: Nope.  Look closer.
14:26:33 <ddarius> Actually, nevermind.
14:26:38 <ddarius> I'm misreading.
14:26:51 <dolio> Were you thinking it was t'?
14:26:57 <ddarius> No.
14:27:10 <ddarius> I just wasn't factoring in the GADT syntax.
14:27:23 <dolio> Oh...
14:29:25 <dolio> Yeah, F t = t -> F t would be a bit of an odd type to want in most cases.
14:29:36 <DukeDave> I want it :)
14:31:02 <dolio> DukeDave: That's essentially t -> t -> t -> t -> ...
14:31:39 <DukeDave> dolio: I guess that semi explains this: http://hpaste.org/12183
14:31:50 <DukeDave> But I don't see why the first function is okay?
14:32:07 <b4taylor> Is there a vim highlighter for Alex files?
14:32:19 <DukeDave> dolio: Thanks by the way :)
14:32:23 <DukeDave> .. For putting up with me
14:32:41 <dolio> It's no problem.
14:33:51 <dolio> DukeDave: Oh.
14:34:06 <dolio> DukeDave: topen transport :: IO t
14:34:17 <dolio> Not IO (TFramedTransport t)
14:34:30 <dolio> So you need to fmap TFramedTransport, for instance.
14:37:03 <DukeDave> dolio: Processing :)
14:37:44 <awarring> how does type polymorphism differ from template programming in C++?
14:38:02 <dolio> Your signature for topen says it takes a t and returns an IO t.
14:38:15 <dolio> But your implementation there takes a TFT t and returns and IO t.
14:38:32 <dolio> Instead of an IO (TFT t)
14:38:41 <DukeDave> dolio: Gotcha :)
14:38:43 <dolio> So re-wrap the t in the constructor.
14:39:25 <dolio> Anyhow, I'm going to disappear for a few minutes. You'll have to redirect all your questions to the extremely friendly ddarius.
14:40:09 <DukeDave> dolio: Cool, I should get home anyway :)
14:40:17 <DukeDave> Thanks very much for your advice
14:40:25 <DukeDave> I'll try and factor fmap into it :)
14:40:30 <yitz> @seen Peaker
14:40:31 <lambdabot> Peaker is in #haskell. I last heard Peaker speak 21h 24m 3s ago.
14:44:18 <yitz> awarring: hmm. I haven't used C++ templates for while. I was hoping someone else would answer.
14:44:30 <ddarius> awarring: C++ templates include, at least rank 1, parametric polymorphism but in such an unstructured way as to void some of the benefits (though templates are considerably more powerful than parametric polymorphism in other ways).
14:44:57 <yitz> awarring: when you use a templated function, you have to specify the type explicity, don't you?
14:46:27 <yitz> or ddarius?
14:46:47 <ddarius> Some stuff can be "inferred"
14:47:01 <ddarius> It's nowhere near as bad as C# or Java in that regard.
14:47:08 <erikc> it just looks ugly as sin
14:47:10 <erikc> :)
14:47:36 <yitz> erikc: I don't think awarring had aesthetics in mind, but OK.
14:48:40 <yitz> how about specifying conditions on the type variable? Is that possible in C++? (didn't use to be)
14:48:46 <erikc> where would i find a good description of rank-1 vs rank-k polymorphism?
14:48:59 <erikc> do template template parameters qualify as rank-2?
14:49:13 <Pseudonym> nept: tan(t) = 2tan(t/2) / (1 - tan^2 (t/2))
14:49:15 <Pseudonym> So no.
14:49:27 <roconnor> liftA2.liftA2
14:49:30 <roconnor> @type liftA2.liftA2
14:49:32 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
14:49:36 <Pseudonym> Uhm.
14:49:49 <sjanssen> yitz: the next version of C++ has "concepts" which is supposed to allow that
14:49:55 <Pseudonym> Still, you now all have a useful identity!
14:50:03 <ddarius> erikc: A rank-2 type would look like: int f(template<typename T> vector<T>);
14:50:56 <ddarius> Pseudonym: Which I will (intentionally) immediately forget because it is a relatively simple consequence of Euler's formula.
14:51:19 <Pseudonym> Actually, the half-angle formulas aren't quite as easy to derive as the others.
14:51:26 <ddarius> I know.
14:52:12 <yitz> @check \t -> tan(t) == 2tan(t/2) / (1 - tan^2 (t/2))
14:52:14 <lambdabot>       No instance for (Floating (a1 -> a1))
14:52:14 <lambdabot>        arising from a use of `tan...
14:52:54 <yitz> @check \t -> tan(t) == 2*tan(t/2) / (1 - (tan(t/2))^2)
14:52:55 <ddarius> Pseudonym speaks in Math 4.0
14:52:55 <lambdabot>   "Falsifiable, after 0 tests:\n1.6666666666666665\n"
14:52:59 <yitz> heh
14:53:28 <Pseudonym> For deriving half-angle formulas, I find this easier to remember:
14:53:41 <Pseudonym> exp(it) = (1 + i tan(t/2)) / (1 - i tan (t/2))
14:54:08 <erikc> ah...so i guess template template parameters do make c++ templates rank-2
14:54:27 <Pseudonym> And the fourth most useful trig identity:
14:54:53 <Pseudonym> Arg[x + iy] = arctan(y/x)
14:54:58 <ddarius> erikc: I'm pretty sure you can't write a function that requires it's argument to be instantiable at any type.
14:54:58 <vixey> yeah
14:55:45 <vixey> (e^itheta + conj e^itheta)/2
14:55:50 <erikc> ddarius: right, not a function, it would have to be a type which implements operator()
14:55:52 <ddarius> Pseudonym: That's not even memorization.  One should just be able to instantaneously do the math for that.
14:56:00 <erikc> not quite the same, but it gets you there
14:56:06 <Pseudonym> > 4 * (arctan (1/2) + arctan(1/5) + arctan(1/8))
14:56:07 <lambdabot>   Not in scope: `arctan'Not in scope: `arctan'Not in scope: `arctan'
14:56:16 <Pseudonym> > 4 * (atan (1/2) + atan(1/5) + atan(1/8))
14:56:17 <lambdabot>   3.141592653589793
14:56:30 <Pseudonym> ddarius: And similarly for Pythagoras' theorem.
14:56:42 <vixey> sin^2 + cos^2 = pythagoras theorem :)
14:56:43 <Pseudonym> But there comes a point where it's just there in your brain.
14:56:43 <yitz> So the bottom line is: The polymorphism itself is available in C++, but the type checker and type inference are far weaker. Correct?
14:56:51 <Pseudonym> vixey: That's exactly what I meant.
14:58:06 <ddarius> yitz: The type checker is, in some senses, far stronger.  There isn't really any type inference, there's some ad-hoc crap for resolving template parameters in some situations.  The polymorphism is there but buried in a pile of mud.
14:58:08 <erikc> the type inferencing is non-existant (you have to hand hold it with typedefs, sorta like associated types?)
14:59:13 <yitz> ddarius: type checker far stronger?
15:00:01 <sjanssen> yitz: C++ templates are Turing-complete
15:01:04 <yitz> From what I remember, C++ error messages in the presence of non-trivial templating are nearly unusable.
15:01:14 <sjanssen> yes, this is true
15:02:03 <Pseudonym> > 2 * atanh (1/5) + 2 * atanh (1/7)
15:02:04 <lambdabot>   0.6931471805599454
15:02:06 <Pseudonym> > log 2
15:02:07 <lambdabot>   0.6931471805599453
15:02:51 <yitz> sjanssen: Turing complete in the sense that the output is whether or not the program type-checks?
15:03:10 <yitz> I though Turing complete there meant in terms of the result of the program.
15:03:28 <Pseudonym> Yes, it can generate a program which just returns a single number, which is the answer.
15:03:29 <yitz> In which case that doesn't demonstrate the strength of the type checker.
15:03:32 <ddarius> yitz: The language of templates in C++ is a pure lazy functional programming language.
15:04:15 <sjanssen> yitz: the first well known demonstration of this was a C++ program that outputs the prime numbers in compiler error messages
15:04:24 <yitz> heh
15:05:18 <yitz> awarring: still around?
15:11:00 <hackage> Uploaded to hackage: LslPlus 0.1.3
15:13:33 <the_unmaker> ok  anyone running haskell webservers and showing them off
15:13:36 <the_unmaker> ?
15:13:54 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/
15:14:13 <Cale> Well, it's a Haskell web application, anyway
15:14:35 <Cale> http://hope.bringert.net/
15:14:41 <lambdabot> Title: Hope - About Hope
15:14:55 <Cale> http://happs.org/
15:15:01 <lambdabot> Title: HAppS ‚Äî The Haskell Application Server
15:16:06 <Cale> http://happstutorial.com/
15:16:12 <lambdabot> Title: Real World HAppS: The Cabalized, Self-Demoing HAppS Tutorial
15:16:20 <Cale> ^^ That one is a HAppS application which is a tutorial for HAppS.
15:17:30 <Cale> http://www.haskell.org/haskellwiki/HAppS_tutorial -- though this tutorial looks more complete
15:17:31 <lambdabot> Title: HAppS tutorial - HaskellWiki
15:18:07 <Cale> Oh, sorry, that's the old version for some reason... http://www.haskell.org/haskellwiki/HAppS_tutorial2
15:18:09 <lambdabot> Title: HAppS tutorial2 - HaskellWiki
15:18:43 <erikc> yitz: map in c++ for vectors: http://paste.lisp.org/display/70681
15:19:13 <Cale> the_unmaker: I can see if I can find you more stuff if you're interested.
15:19:41 <grom358> what's wrong with this: fa :: Int -> Int -> Int
15:19:41 <grom358> fa k p = fromIntegral . floor $ log k / log p
15:19:53 <EvilTerran> ?type log
15:19:53 <lambdabot> forall a. (Floating a) => a -> a
15:19:59 <Cale> log can't be applied to an Int
15:20:01 <EvilTerran> Int isn't Floating
15:20:08 <b4taylor> Indeed.
15:20:23 <dolio> > log a
15:20:24 <lambdabot>   log a
15:20:29 <Cale> The fromIntegral is just in the wrong place
15:20:43 <EvilTerran> > log 10
15:20:44 <Cale> Move it so that it's being applied to the k and p before you take the log.
15:20:46 <dolio> > log (a * 2.0)
15:20:54 <lambdabot>   2.302585092994046
15:20:54 <lambdabot>   log (a * 2.0)
15:21:12 <Cale> > let fa k p = floor (log (fromIntegral k) / log (fromIntegral p))
15:21:13 <lambdabot>   <no location info>: parse error on input `;'
15:21:17 <Cale> > let fa k p = floor (log (fromIntegral k) / log (fromIntegral p)) in fa 5 4
15:21:19 <lambdabot>   1
15:21:32 <Cale> > let fa k p = floor (log (fromIntegral k) / log (fromIntegral p)) in fa 1028 2
15:21:33 <lambdabot>   10
15:21:58 <Cale> :t let fa k p = floor (log (fromIntegral k) / log (fromIntegral p)) in fa
15:21:59 <lambdabot> forall a a1 b. (Integral b, Integral a1, Integral a) => a -> a1 -> b
15:22:25 <grom358> Cale: thanks
15:22:56 <EvilTerran> note that "log" is natural logarithms, btw
15:23:44 <nominolo> @seen swiert
15:23:44 <lambdabot> I saw swiert leaving #haskell 1h 20m 13s ago, and .
15:26:19 <Procyon112> So.. I'm trying to get cabal-install working on Windows (x64, but I don't think that's relevant), and I'm getting "HSfilepath-1.1.0.1: The specified module could not be found.", but it's in the GHC distro.
15:26:49 <Procyon112> What am I doing wrong?
15:35:37 <the_unmaker> wow
15:35:41 <the_unmaker> happs looks cool
15:35:53 <the_unmaker> bad docs heh uh oh how use cool thing if no docs lol
15:36:45 <Peaker> docs are for the weak
15:37:28 <Peaker> yitz: hey, looking for me?
15:38:19 <ddarius> "Another interesting observation about the programs in this paper is that there are /no recursive definitions/ of any kind.  Instead, the code uses higher-order functions from the standard Haskell prelude [...]  This property was noticed only after all of the code had been written, and was never an explicit design goal."
15:39:20 <the_unmaker> lol
15:39:38 <the_unmaker> ddarius: in happs?
15:39:54 <vixey> what paper is that?
15:39:56 <the_unmaker> what is a higher order function?
15:40:05 <vixey> @src foldr
15:40:05 <lambdabot> foldr f z []     = z
15:40:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:40:06 <vixey> this is one
15:40:49 <grom358> I don't get why I am getting type errors in http://pastebin.com/d6963e326
15:41:02 <sjanssen> the_unmaker: higher order functions take functions as input or return functions as output
15:41:43 <sjanssen> @type sqrt
15:41:44 <lambdabot> forall a. (Floating a) => a -> a
15:42:00 <sjanssen> grom358: 'limit' doesn't have the right type
15:43:01 <grom358> sjanssen: I haven't given it a type though
15:43:07 <the_unmaker> hmmm
15:43:43 <sjanssen> grom358: sqrt produces a floating point number; p is an Int; Int is not a floating point number
15:44:04 <sjanssen> grom358: oh, and (<=) can only compare values of the same type
15:45:04 <ddarius> vixey: http://web.cecs.pdx.edu/~mpj/pubs/composing-fractals.html
15:45:07 <lambdabot> Title: Composing Fractals
15:45:23 <the_unmaker> is there a good haskell weight loss program?
15:45:52 <ddarius> the_unmaker: Die like Haskell did and you will quickly lose weight.
15:46:12 <the_unmaker> die?
15:46:14 <grom358> okay.. if I try change limit = floor . sqrt (fromIntegral k) and it still complains about the use of sqrt
15:46:17 <the_unmaker> I want to live!
15:46:51 <sjanssen> grom358: floor . sqrt $ fromIntegral k -- will work
15:47:00 <sjanssen> grom358: you're just using (.) incorrectly
15:47:06 <ddarius> the_unmaker: The I guess that plan is not for you.
15:47:14 <grom358> oh.. i see
15:47:25 <grom358> (floor . sqrt) (from Integral k)
15:47:37 <grom358> which is floor . sqrt $ fromIntegral k
15:47:40 <sjanssen> right
15:47:58 <sjanssen> you wrote floor . (sqrt (fromIntegral k))
15:48:01 <lispy> > floor $ sqrt $ fromIntegral 10
15:48:02 <lambdabot>   3
15:48:31 <lispy> > floor . sqrt . fromIntegral 10
15:48:32 <lambdabot>       Overlapping instances for Show (a -> b)
15:48:32 <lambdabot>        arising from a use of `s...
15:48:32 <grom358> yeah.. my bad
15:48:40 <lispy> > floor . sqrt . fromIntegral $ 10
15:48:41 <lambdabot>   3
15:49:03 <lispy> > floor $ sqrt . fromIntegral $ 10
15:49:04 <lambdabot>   3
15:49:08 <lispy> so many ways to write it!
15:49:27 <lispy> from a staticastical poin of view, I guess it's harder to get it wrong than it is to get it right ;)
15:49:30 <grom358> I think I need to read up on the number types in haskell
15:49:50 <lispy> > floor $ sqrt . fromIntegral $ 10 :: CReal
15:49:51 <lambdabot>       No instance for (Integral CReal)
15:49:51 <lambdabot>        arising from a use of `floor' a...
15:50:10 <lispy> > fromIntegral . floor $ sqrt . fromIntegral $ 10 :: CReal
15:50:11 <lambdabot>   3.0
15:50:40 <grom358> > ?type sqrt
15:50:41 <lambdabot>       Unbound implicit parameter (?type::(a -> a) -> a1)
15:50:41 <lambdabot>        arising from ...
15:50:48 <grom358> > :t sqrt
15:50:49 <lambdabot>   <no location info>: parse error on input `:'
15:51:20 <grom358> ?type sqrt
15:51:20 <lambdabot> forall a. (Floating a) => a -> a
15:51:38 <grom358> okay.. what does (Floating a) => a bit mean?
15:53:42 <sjanssen> grom358: it means 'a' is an instance of the Floating class
15:53:45 <sjanssen> @src Floating
15:53:45 <lambdabot> class  (Fractional a) => Floating a  where
15:53:45 <lambdabot>     pi                                                      :: a
15:53:45 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
15:53:45 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
15:53:45 <lambdabot>     (**), logBase                                           :: a -> a -> a
15:58:07 <ddarius> Holy crap.  Someone actually wants an ORM in Haskell.
15:58:53 <EvilTerran> ORM?
15:59:03 <ddarius> Object Relational Mapping
15:59:06 <sciolizer> Perhaps a TCRM (Type-class relational mapper)?
16:03:23 <Vulpyne> Has anyone gotten HXT working on GHC 6.10.x?
16:03:39 <Vulpyne> Now that >>> isn't part of the Arrow class anymore, seems like it will be a pain.
16:04:24 <Peaker> backwards incompatibilities should probably come with a conversion script (human script in the form of a doc at least)
16:05:25 <sjanssen> Vulpyne: how many Arrow instances does HXT have?
16:06:09 <Vulpyne> I don't know, it uses a lot of arrows though.
16:06:27 <Vulpyne> It's a big scary project that I haven't looked at much, and I'm thinking if I change Arrow to Category in the source, that most likely won't fix it. :)
16:06:44 <sjanssen> you only have to write code for each instance
16:07:03 <Vulpyne> I'm not trying to write code that uses HXT, I'm trying to compile HXT.
16:07:31 <sjanssen> Vulpyne: right, the edits you'll need to make should only be proportional to the number of Arrow instances in the code
16:08:08 <sjanssen> grep 'instance.*Arrow' should be a good start :)
16:08:39 <Vulpyne> 49 instances of it.
16:08:52 <sjanssen> wow
16:08:54 <Vulpyne> Well, some are stuff like ArrowZero or ArrowPlus or ArrowChoice.
16:09:05 <sjanssen> ah, those should be okay
16:09:27 <Vulpyne> Well, changing the offending instance declaration from Arrow to Category didn't help.
16:10:10 <sjanssen> Vulpyne: that isn't what you need to do
16:10:13 <FunctorSalad> sjanssen: it has about 10 instances I think
16:10:32 <sjanssen> you need to add an additional instance for Category, where (.) = whatever (>>>) was in the Arrow instance
16:10:33 <Vulpyne> ">>> is no longer a method of the Arrow class; instead Category is a superclass of Arrow."
16:11:01 <hackage> Uploaded to hackage: lub 0.0.0
16:11:01 <hackage> Uploaded to hackage: unamb 0.1.0
16:11:27 <FunctorSalad> Peaker: I think this should be possible to do mechanically
16:12:00 <FunctorSalad> sjanssen: also id = whatever arr was in the Arrow instance
16:12:05 <FunctorSalad> err no
16:12:14 <FunctorSalad> arr Prelude.id?
16:12:48 <Vulpyne> Ahh, >>> isn't a method of Category either.
16:13:00 <FunctorSalad> (of course that's backwards, but in this case we have arr already)
16:13:14 <FunctorSalad> Vulpyne: it got renamed to (.)
16:13:15 <sjanssen> FunctorSalad: arr id -- will also work, because (->) is an instance of Category
16:13:24 <Vulpyne> Oh.
16:13:40 <FunctorSalad> or wait, actually (<<<) is (.)
16:13:43 <Vulpyne> But there's stuff that actually uses >>> in the code.
16:14:00 <FunctorSalad> isn't (>>>) just a defined function now?
16:14:04 <sjanssen> Vulpyne: that's okay, (>>>) is exported by Control.Category
16:14:59 <Vulpyne> So I could change "    IOSLA f >>> IOSLA g =" in the instance to "    IOSLA g . IOSLA f ="?
16:15:26 <sjanssen> Vulpyne: yes, if you also move the code into a Category instance
16:15:35 <Vulpyne> Yeah, I did.
16:17:35 <Vulpyne> http://hpaste.org/12185 - Didn't work.
16:19:04 <Vulpyne> Apparently people have been able to compile HXT on 6.10.1 though, since I see posts complaining about another issue. Heh.
16:20:59 <sjanssen> Vulpyne: oh, the arguments to (.) are flipped
16:21:04 <FunctorSalad> Vulpyne: are you sure you reversed the order?
16:21:22 <FunctorSalad> it seems to apply f first, but g should be first
16:22:08 <Vulpyne> Wow, I'm dumb. You're right, I forgot to do that.
16:27:48 <Vulpyne> Ugh, this is horrible.
16:30:27 <Vulpyne> Seems to be compiling now.
16:34:21 <EmielRegis> > map show [0..0]
16:34:22 <lambdabot>   ["0"]
16:34:27 <EmielRegis> > map show [0..(-1)]
16:34:28 <lambdabot>   []
16:38:01 <EmielRegis> > map show [0..3]
16:38:03 <lambdabot>   ["0","1","2","3"]
16:42:40 <gwern> 'Notable: GHC's "Expression has type a, expected type a"'
16:43:01 <gwern> http://lambda-the-ultimate.org/node/295http://lambda-the-ultimate.org/node/295
16:43:03 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog, http://tinyurl.com/6a47gx
16:52:17 <bwr> hi
16:52:47 <bwr> so i have a crazy idea that i am trying to get working
16:53:31 <bwr> adobe released their alchemy project today that lets you compile c/c++ code that will work on the flash vm
16:53:47 <bwr> i want to see if i can get haskell working by compiling haskell to c and then compiling it to work on the flash vm
16:53:52 <bwr> does that sound feasible?
16:54:40 <dolio> jhc produces ISO C.
16:54:46 <shepheb> bwr: jhc creates portable C
16:54:52 <dolio> Whether or not it will compile your program is a different matter.
16:55:07 <bwr> well, i don't have a specific program in mind
16:55:10 <bwr> it is just for fun
16:55:36 <bwr> but that sounds like it would work. i think i need to do some foreign function stuff too so haskell can interact with the actionscript objects
16:57:59 <bwr> so ghc won't produce C?
16:58:08 <bwr> or it does, but it isn't portable?
16:58:20 <dolio> It will, but it's probably got gcc-isms and such.
16:58:29 <bwr> that should be fine
16:58:36 <bwr> adobe alchemy is using gcc it seems
16:59:14 <p_l> hmmm... that means that If I got Boehm GC on Flex or port ECL to a different GC, then I'll have the best langs available on the newest platform of the month? :D
17:01:52 <gwern> I was disapointed when I recently benchmarked jhc. I had remembered it as producing smaller binaries and faster code than ghc, but it seems actually only the former is true
17:02:24 <dolio> GHC's been improving steadily.
17:02:35 <dolio> And jhc doesn't seem to have the manpower.
17:03:16 <gwern> http://lambda-the-ultimate.org/node/295#comment-2531 <-- yes, I can see why Duff might be familiar with that error
17:03:17 <lambdabot> Title: Shoot-out: most annoying compiler error message | Lambda the Ultimate
17:03:26 <gwern> dolio: well, the last patch was in april, so I agree
17:04:51 <p_l> gwern: Duff's device is still one of my favourite abuses of language ^___^
17:05:15 <p_l> But it doesn't beat *the* shortest C Quine
17:07:05 <dolio> I've kind of been partial to 'index[array]' in C since I saw it.
17:07:10 <gwern> 'Not only is this my favorite example of a useless error message, it is my only known example, in forty years of programming, of a compile-time error triggered neither by an error in the source code nor in the compiler, but in hardware not part of the system compiling the program.;
17:07:16 <dolio> But that's not really useful except for obfuscation.
17:07:41 <bwr> dolio: what do you mean by index[array]
17:08:09 <p_l> index*(array) would certainly work, but I don't remember index[array]
17:08:15 <dolio> bwr: In C, 'a[b]' is defined as being '*(a + b)' so 'a[b] = *(a + b) = *(b + a) = b[a]'.
17:08:28 <p_l> oh yes
17:08:31 <bwr> oh sweet
17:08:34 <dolio> So you can swap the place of the index and the array and it means the same thing. :)
17:08:42 <bwr> i had no idea
17:08:54 <p_l> but still doesn't beat the shortest quine...
17:08:56 <p_l> ""
17:09:06 <p_l> (that's *0* characters)
17:09:23 <bwr> that compiles?
17:09:43 <p_l> the file was exactly 0 bytes and compiled into an executable file which of course wrote as it's output it's own source, that is, nothing
17:09:53 <dolio> Heh.
17:10:24 <p_l> because of that program, IOCCC introduced *minimal* length
17:11:18 <newsham> hi
17:14:15 <FunctorSalad> dolio: what about the size of the array entries?
17:14:22 <FunctorSalad> is that taken care of by the +?
17:16:36 <p_l> FunctorSalad: change the definition to *(a + b*sizeof(type))
17:16:51 <dolio> FunctorSalad: The type of the pointer takes care of that, doesn't it?
17:17:04 <p_l> dolio: not exactly
17:17:16 <FunctorSalad> p_l: but then it doesn't commute anymore, does it
17:17:25 <dolio> If a is a double*, *(a+1) doesn't give you two halves of different doubles.
17:17:47 <p_l> for index[array] to work, the array has to be composed of elements that are one word in size
17:17:48 <dolio> Or something of the sort.
17:18:22 <Millz> is there a way of using arrays in haskell?
17:18:26 <p_l> it's done automatically only if you use array[index]
17:18:40 <Millz> im having hard time implementing code that was originally written using arrays with linked lists :(
17:19:22 <FunctorSalad> ironically enough, \hat{argument}(function) is used in math too
17:19:39 <FunctorSalad> with the \hat the embedding into the bi-dual
17:21:38 <FunctorSalad> (defined the same way as the array thing)
17:22:42 <dolio> 1[a] works for an array of doubles on gcc. They're more than one word, no?
17:23:02 <FunctorSalad> 64 bit? ;)
17:23:10 <FunctorSalad> or are double 128bit on 64bit cpus?
17:23:25 <dolio> sizeof says 8, so still 64 bit.
17:23:32 <bwr> what about bytes
17:23:38 <bwr> well, char
17:23:39 <dolio> Ah, I guess that's one word...
17:25:11 <dolio> Works for chars, too.
17:25:20 <FunctorSalad> hint: don't do "alias ghc-pkg=ghc-pkg --user" ;)
17:25:31 <dolio> In fact 'printf("%c\n", 1["abc"]);' prints b.
17:25:36 <FunctorSalad> I think that caused the weird failures
17:25:49 <dolio> Which was the original use of the technique I saw.
17:26:44 <bwr> yea, i just tried with a string and it worked just fine
17:26:58 <dolio> Only they used 'index["]...' for extra obfuscation.
17:27:10 <dolio> So it looked like an array indexed by a double quote.
17:27:14 <Millz> so, any help on arrays? :(
17:27:38 <dolio> Look for Data.Array.
17:27:43 <glguy> Millz, you'll want to ask a specific question
17:27:51 <Millz> well
17:27:56 <Millz> i figured ouyt to how to create them
17:28:02 <Millz> however, if i want to change an element in it
17:28:06 <Millz> do I have to create a new array:
17:28:33 <glguy> pure arrays are read-only, and must be copied to change them
17:28:47 <Cale> Millz: yes, with the immutable array type.
17:28:48 <glguy> mutable arrays work in the IO or ST monad
17:29:11 <Cale> Millz: Another option which is often sensible is to use a Data.Map
17:29:23 <Cale> (depending on what kind of data it is)
17:29:29 <Millz> ah
17:29:37 <Millz> well i just want to be able to access it through the  index
17:29:44 <Millz> and be able to put new stuff in it...
17:29:56 <Cale> Sounds a bit like a Data.Map
17:30:01 <FunctorSalad> are updates for Data.Map optimized? (as in "doesn't rebuild the whole tree" ;))
17:30:09 <Cale> FunctorSalad: They're O(log n)
17:30:21 <Cale> (it only rebuilds the path up to the root)
17:30:29 <Millz> ah
17:30:37 <Millz> so Data.Map is a bit like hash table?
17:30:38 <FunctorSalad> Cale: okay, the naive pure version would be O(n log n) I think
17:30:51 <FunctorSalad> Millz: I think it's a tree internally
17:30:51 <Cale> Millz: Binary balanced tree, but yes, in usage.
17:31:15 <Cale> FunctorSalad: Well, you can build the whole tree in O(n log n)...
17:31:41 <FunctorSalad> Cale: nvm, actually I think the naive version only rebuilds the path too (due to pointers)
17:32:05 <FunctorSalad> (update if found, recurse and reconstruct otherwise)
17:32:44 <FunctorSalad> I should think a bit more before writing
17:35:10 <Saizan> it reconstructs anyway
17:35:33 <Millz> k maps look good
17:35:34 <Millz> thanks
17:36:03 <Cale> It's worth noting that binary trees and hashtables are asymptotically equivalent, under the usual assumption that the hash function is good enough, because any hash function which is good enough to assign n elements to distinct buckets must be looking at O(log n) bits of its input, and so must be taking at least O(log n) time to compute.
17:36:45 <FunctorSalad> Saizan: yes, but if we're at some node n and the updatee is to the left, then the right child of n is not (deeply) reconstructed I'd think
17:36:55 <FunctorSalad> so it should be just O(log(n))
17:36:56 <Cale> FunctorSalad: right.
17:37:26 <Saizan> right, but that happens when you're inserting a fresh key too
17:37:27 <Cale> It's just copied, and since it's just a (code) pointer anyway, that takes no time or memory.
17:37:36 <Cale> (well, constant)
17:38:00 <Saizan> (modulo rebalancing)
17:38:30 <Cale> right.
17:41:46 <Millz> ok, another question :p
17:42:02 <Millz> if I have a two calls to same function, inside one iteration
17:42:19 <Millz> does the function get called once if the input doesnt change?
17:42:23 <Millz> or is it called twice?
17:43:02 <roconnor> Millz: in general it will be called twice
17:43:06 <roconnor> in GHC
17:43:19 <Millz> ok
17:43:25 <Millz> so if I do a where assignment
17:43:27 <roconnor> optimization may float expression out
17:43:38 <Millz> and then use this assigment instead of function call
17:43:44 <Millz> that would always be called only once right?
17:44:08 <roconnor> let expressions are shared inside the scope of the in clause
17:44:09 <roconnor> in GHC
17:44:39 <Millz> and are where expressions shared too?
17:44:41 <sw17ch> Just out of curiosity, is there a reason the trailing comma isn't supported for the Record Syntax while it is supported in module exports?
17:44:49 <erikc> roconnor: how often can this be optimized away? i figure there'd be some sort of value numbering pass to take care of this
17:44:53 <sw17ch> and, for that matter, in lists?
17:45:02 <newsham> ?seen conal
17:45:03 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 5h 47m 25s ago.
17:45:11 <conal> newsham: hi
17:45:25 <roconnor> erikc: I'm not sure.  Floating expressions can cause space leaks, so GHC doesn't do it very often.
17:45:52 <roconnor> I'm not sure what circumstances GHC will float out expessions
17:45:55 <newsham> conal: i'm trying to follow the example on the fieldtrip page.  I dont see the Test.hs mentioned (re: plasmat), also the link to the "torus" function seems to be broken
17:46:09 <newsham> and to Graphics.FieldTrip.ParamSurf
17:47:01 * conal looks
17:47:45 <conal> newsham: about Test.hs, what package are you looking in?
17:48:07 <conal> i'll fix the torus link.  thx!
17:48:29 <newsham> I have reactive, reactive-fieldtirp, reactive-glut and fieldtrip in my dir, and I did a recursive search for plasmat
17:48:44 <newsham> it only turned up the wikipage.tw file
17:49:19 <newsham> I have Test.hs in reactive-fieldtrip and reactive-glut but I'm assuming thats not the same one
17:49:20 <conal> newsham: you don't see a reactive-fieldtrip/src/Test.hs ?
17:49:36 <newsham> I do
17:49:53 <conal> oh, hm.  "The picture above comes from an animation in reactive-fieldtrip. Load src/Test.hs, as follows: "
17:50:24 <newsham> but I do see it making toruses (tori?) in that Test.hs
17:50:57 <conal> newsham: "do" or "do not"?
17:50:59 <conal> (see)
17:51:41 <newsham> I do see that Test.hs file.  I dont see "plasmat" in it.  when I try to follow the directions for using Test.hs in ghci it fails.
17:51:58 <gwern> @hoogle SomeException
17:51:58 <lambdabot> No results found
17:52:01 <newsham> here's the error: http://hpaste.org/12186
17:52:10 <gwern> hm. why does mediawiki fail to compile...
17:52:16 <conal> newsham: oh, okay.  i guess there's some skew.  i'll try it myself as written and fix.
17:52:42 <newsham> btw, is it better to try to follow from hackage package or from darcs?
17:52:44 <Saizan> gwern: SomeException is from 6.10's Control.Exception
17:52:48 <newsham> (or does it not matter right now?)
17:53:07 <gwern> Saizan: dagnabbit
17:53:57 <Saizan> gwern: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/extensible-exceptions
17:53:58 <lambdabot> Title: HackageDB: extensible-exceptions-0.1.1.0, http://tinyurl.com/64wjqk
17:55:31 <lispy> gwern: I should gave dagnabbit highlight me...I get called that in RL sometimes :)
17:56:09 <gwern> lispy: I understand the temptation
17:56:51 <gwern> Saizan: so I should edit the mediawiki hs file to import from extensible-exceptions insteaD?
17:58:07 <newsham> hmm.. this Test.hs is what I should be reading.
17:58:30 <lispy> forget the NY Times, we have Test.hs
17:58:35 <lispy> ;)
17:58:46 <Saizan> gwern: Control.Exception.Extensible, yeah
18:01:04 <gwern> man, this mediawiki api is huge
18:01:13 <gwern> I wonder how long he's been working on it that I didn't know about it?
18:01:37 <newsham> ahh, it should be "anim3 (const . spinningG $ torusPair)" not "anim3 (spinningG torusPair)"
18:01:53 <gwern> obviously :)
18:03:17 <conal> newsham: yeah.  i just fixed it and some others.  would you look again at http://haskell.org/haskellwiki/FieldTrip ?
18:03:19 <lambdabot> Title: FieldTrip - HaskellWiki
18:03:57 <conal> just fixed a bad line break in the abstract
18:05:02 <newsham> conal: looks good now.
18:05:11 <conal> newsham: thanks very much!
18:05:18 <gwern> 'I installed GHC 6.10.1 today and expected it to contain the cabal command line
18:05:20 <gwern> utility.  Unfortunately, this was not the case. '
18:05:24 <newsham> oh, you still have the comment about "plasmat" although its not used now
18:05:29 <gwern> <-- cabal continues conquest
18:05:34 <conal> newsham: thx.  i'll fix it now.
18:06:34 <newsham> also I'm confused by two definitions of "torus" here.  one using revolve the other using surfG
18:07:15 <gwern> http://code.haskell.org/hackage-server <-- I didn't know hackage was under darcs. did you?
18:07:16 <lambdabot> Title: Index of /hackage-server
18:07:43 <newsham> ahh, one's from Geometry3 and the other from ParamSurf
18:07:55 <conal> newsham: yeah
18:08:05 <Saizan> gwern: that's the new one written in happs, the current hackage repo is called hackage-scripts
18:09:01 <Millz> urgh, my code just passed the boundary between being ugly, and being an ugly hack :|
18:09:01 <Saizan> http://darcs.haskell.org/hackage-scripts/
18:09:01 <lambdabot> Title: Index of /hackage-scripts
18:09:06 <gwern> argh
18:09:18 * gwern will show you. I'll darcs get them both!
18:10:45 <conal> newsham: please let me know of any other bumps & boo-boos you discover.
18:11:01 <hackage> Uploaded to hackage: lub 0.0.1
18:11:10 <conal> yeah, lub!
18:11:23 <newsham> will do
18:12:34 <gwern> well, I'll be. Marvin Minsky reads Overcoming Bias? http://www.overcomingbias.com/2008/11/logical-or-conn.html
18:12:36 <lambdabot> Title: Overcoming Bias: Logical or Connectionist AI?
18:12:49 <gwern> (actually, for that matter - Marvin Minsky is still alive?)
18:13:16 <p_l> gwern: I think so
18:13:32 <p_l> or at least I haven't heard rumours about him dying
18:16:33 <FunctorSalad> cognitive biases, while interesting, are a questionable argument when selectively applied to your opponents...
18:16:43 <FunctorSalad> oh, OT ;)
18:17:26 <gwern> FunctorSalad: a point robin hanson has iterated and reiterated
18:20:26 <FunctorSalad> gwern: I wasn't accusing the particular site :)
18:21:10 <gwern> no, I mean hanson has a number of interesting articles on the dangers of learning about cognitive biases
18:24:49 <lament> learning about cognitive biases reinforces cognitive biases?
18:28:18 <kpreid> lament: "oh, I know about biases, therefore I must be successfully avoiding them"
18:35:56 <lament> kpreid: oh, but i know about that effect, so i must be successfully avoiding it
18:43:06 <lispy> So in that case, let's stop teaching history
18:43:19 <p_l> BAD IDEA
18:43:35 <lispy> so where do we draw the line?
18:44:05 <p_l> nowhere. Nature does enough for us.
18:44:50 <ddarius> "The main thing we learn from history is that we don't learn from history."
18:45:08 <p_l> by adding a lot of randomness spread over a big population...
18:45:11 <p_l> ddarius: true
18:45:46 <p_l> a specialized, less-OT version: "C++ is history repeated as tragedy. Java is history repeated as farce"
18:45:48 <flippo> My irc client must be broken.  It shows 490 users in #haskell.
18:46:36 <lispy> ?users
18:46:36 <lambdabot> Maximum users seen in #haskell: 550, currently: 492 (89.5%), active: 10 (2.0%)
18:46:49 <lispy> flippo: seems about right
18:47:01 <lispy> hmm...I get 490 also
18:47:08 <flippo> Amazing.  I assumed it added an extra digit.  I haven't joined for a while.
18:47:14 <Axman6> flippo: #haskell is the 12th largest channel on freenode
18:47:27 <flippo> Rivaling ##c.  Astounding.
18:48:04 <flippo> It's good to see merit appreciated.
18:48:46 <ddarius> #haskell was about 40 ish people when I joined.  That was about seven years ago.
18:49:10 <FunctorSalad> let's fit a hyperbola to it
18:49:13 <FunctorSalad> ;)
18:49:25 <p_l> Well, there's a lot of people advocating Haskell
18:49:33 <flippo> (Only if the curvature is forced to be positive.)
18:49:57 <p_l> (and from my newbie-ish pov, GHC did a lot of good for that)
18:50:16 <flippo> I first joined about seven years ago too.  Haven't been too faithful though.  I had good intentions...
18:50:50 * lispy wonders if flippo is somehow a dual to Philippa_ 
18:51:15 <gwern> lispy: nah, that'd be _filippo
18:51:19 <flippo> Phonetically, perhaps.  The gender looks wrong though.
18:52:08 <lament> looks right for a dual
18:52:14 <lament> flippo: hi!
18:52:29 <flippo> lament, I remember you!   You probably aren't a child anymore.
18:52:53 <BMeph> FunctorSalad: Surely you meant: s/hyperbola/hyperbole/ right? ;)
18:53:17 <HairyDude> apologies for that hpaste, I foolishly thought they were announced in #xmonad too
18:53:42 <lament> flippo: i guess i'm not.
18:53:56 <lament> but i don't think i've changed much.
18:53:56 <flippo> Oh dear.   An entire channel devoted to monads seems a bit much.
18:54:22 <flippo> lament, I doubt it.  I recall that we often mistook each other for ourselves... or something like that.
18:54:35 <lispy> flippo: no no, devoted to the Haskell window manager
18:54:50 <lispy> ?where xmonad
18:54:50 <lambdabot> http://xmonad.org/
18:54:53 <pizza> i'm waiting for a Monad movie, and possibly a tv mini-series
18:55:08 <lispy> pizza: in the meantime you can play the video game Monadius
18:55:11 <lispy> ?where monadius
18:55:11 <lambdabot> I know nothing about monadius.
18:55:19 <lispy> cabal install monadius then
18:55:40 <lispy> personally, I'm holding out for the clothing line
18:55:46 <lispy> Monadware
18:56:12 <pizza> this sweater is too complex... 50 zippers and no armholes?!
18:56:16 <lispy> Including a line of formal Functor wear
18:58:56 <gwern> monadius is fun, but shu-thing is the real challenge
18:59:04 <gwern> unfortunately powerups are somewhat broken in monadius
18:59:30 <FunctorSalad> BMeph: http://www.grumer.org/lj_images/razors.gif
18:59:40 <gwern> when you have missiles, double lasers, 4 drones, and so on, you drive the enemies before you as their women lament
18:59:44 <lispy> The most troubling thing for me about monadius was how ... odd the and unidiomatic the source code is and yet how well it plays :)
18:59:47 <FunctorSalad> maybe #haskell growth is similar?
19:00:01 <ddarius> For future reference, if you are going to truncate the display of a list and add an indicator that there is more data, make sure that the display of the rest of the data actually takes more space than the indicator.
19:00:28 <lispy> FunctorSalad: hahaa
19:00:50 <gwern> lispy: well, let's face it. it's not like darcs is totally idiomatic and clear
19:01:00 <gwern> I still think Url.hs is truly messed up code
19:01:10 <lispy> gwern: that's true.  And we're in a campaign to fix that :)
19:01:23 <gwern> and *are* there any opengl haskell games which don't use that IORef style?
19:01:37 <lispy> gwern: it's not the IORefs that I object to
19:01:44 <wchogg> gwern:  stuff based on Reactive?
19:01:45 <lispy> gwern: did you see the comment about "This is BASIC again..."
19:02:01 <gwern> wchogg: there is nothing playable based on Reactive! :)
19:02:09 <lispy> gwern: the way levels are implemented, there is a HUGE case on Int
19:02:20 <lispy> gwern: and at certain time steps things trigger
19:02:28 <wchogg> gwern:  Hey, my Tetris game is playable...it just doesn't count your score yet.
19:02:34 <gwern> lispy: ah, I see what you mean
19:02:48 <gwern> well, it does work?
19:02:58 <lispy> gwern: case time of 1 -> "fire torpedos"; 10 -> "launch ze missiles!"; 13 -> "bugger all!"  <-- that sort of code
19:03:14 <lispy> gwern: yeah the game runs fine, but it's not typical haskell
19:03:20 <gwern> and honestly, how would you write that better? offhand I can't really think of anything except maybe a list of tuples
19:03:35 <gwern> but that wouldn't turn out to be much shorter. more modular
19:03:43 <lispy> Right, so the first step would be to think about making it NOT hard coded
19:03:51 <lispy> you could, for example not use absolute times
19:04:05 <lispy> you could treat as a linked listed on events and triggers
19:04:19 <gwern> why not? it's a forced scroll, so time literally equals distance traveled
19:04:54 <gwern> in the same way you would say 'at 100 meters into the leve, spawn these enemies', you could equivalently say 'at 10 seconds' say if your scroll is set to 10m/s
19:04:58 <lispy> It seems like relative points of distance is the saner approach
19:05:40 <lispy> I admire the simplicity
19:05:56 <lispy> But, I think it's unidiomatic and I think it's a potential maitenance nightmare
19:06:23 <lispy> I don't know enough about reactive to know if that would apply here
19:08:02 <wchogg> gwern:  http://code.haskell.org/~wchogg/Tetris.hs  <- I'll be finishing it up over the weekend, but it's fine as a proof of concept
19:10:36 <FunctorSalad> pizza: will the poor lambdakitten finally be untrapd from IO monad in the series? :( http://arcanux.org/lambdacats/io-monad.jpg
19:11:01 <hackage> Uploaded to hackage: LslPlus 0.1.4
19:12:18 <gwern> 'the exception was: exit: ExitFailure 1'
19:12:29 <gwern> I think dcoutts_ needs to do somthing about these cabal-install errors
19:13:22 <gwern> ah, vector-space needs ghc 6.9
19:13:35 <gwern> wchogg: the code looks impressively short but I can't actually try it out alas
19:13:49 <wchogg> gwern:  Still on 6.8?
19:14:02 <gwern> ubuntu is
19:14:08 <gwern> still haven't seen any 6.10 debs
19:14:16 <wchogg> gwern:  Ah, yeah.
19:16:52 <ddarius> gwern: Install the tar.bz locally?
19:17:11 <gwern> I is afraid of a local ghc
19:17:29 <ddarius> Why?
19:18:25 <gwern> I had bad experience once with various programs and things getting confused about where everything is and what to use
19:20:13 <lispy> gwern: can you show us on this lambda cube where ghc touched you?
19:20:45 <FunctorSalad> gwern: "which" helps
19:20:46 <wchogg> And...lispy gets the award for awkward child molestation joke of the night.  Everyone gim 'im a hand.
19:20:47 * gwern points at the inside of the necker cube. there
19:21:29 <FunctorSalad> /local ghc works for me on debian (though I somehow fubar'ed my cabal now ;))
19:21:41 <gwern> FunctorSalad: that's not helping
19:23:18 * lispy is rather surprised to see gwern using an older release
19:23:52 <gwern> lispy: I use what my distro serves up
19:24:05 <gwern> as much as I'd like to be using 6.10 or even 6.8.3
19:24:08 <ivanm> gwern: use a better distro! ;-)
19:24:21 <gwern> gentoo was too painful in all non-haskell ways
19:24:34 <timotimotimo> gentoo is painful in many other ways...
19:24:44 <lispy> gwern: maybe you should use the distro dons uses, arch?
19:25:04 <gwern> arch doesn't sound much better to me
19:25:14 <lispy> or we should be able to 'cabal install ghc >= 6.10'
19:25:16 <Saizan> arch is very nice coming from ubuntu
19:25:33 <Saizan> but i still use a custom ghc
19:25:54 * Saizan hugs readline
19:25:56 <gwern> ghc in cabal install is a distant dream, lispy. we don't even have gtk2hs in cabal yet
19:25:58 <lispy> IMO for software you actually care about, ghc in this case, it's best to not rely on a package manager
19:26:16 <lispy> gwern: oh, I guess we should switch to franchise then
19:26:22 <gwern> all the problems darcs and gtk2hs have cabalizing, ghc will have in major spades
19:26:55 <gwern> from portability to backwards compatibility, and for ghc backwards compat arguments are serious in a way they weren't for darcs
19:26:56 <lispy> But, ghc does use cabal doesn't it?
19:27:45 <gwern> libraries are cabalized
19:27:51 * ddarius starts reading an interesting sounding paper, "A Synthesizer Based On Square Waves"
19:27:52 <gwern> don't think ghc itself is
19:29:17 <lispy> ah
19:29:42 <Saizan> there's a ghc.cabal.in iirc
19:40:35 <wagle> ddarius, sherwin gooch?
19:40:57 <Saizan> ?hackage MemoTrie
19:40:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MemoTrie
19:45:35 <ddarius> wagle: No
19:47:43 <wagle> sounded like the "Gooch Synthetic Woodwind", but actually not
20:19:01 <roconnor> @losers
20:19:01 <lambdabot> Maximum users seen in #haskell: 550, currently: 486 (88.4%), active: 10 (2.1%)
20:26:57 <luqui> Is there a good way to do a runtime plugin architecture in haskell?
20:27:51 <mjrosenb> i thought dons already had one
20:28:27 <luqui> hs-plugins?  I thought that died...
20:29:08 <luqui> seems to have been revived :-)
20:29:50 <solrize> :t forkIO
20:29:51 <lambdabot> Not in scope: `forkIO'
20:30:02 <solrize> :t Control.Concurrent.forkIO
20:30:03 <lambdabot> IO () -> IO GHC.Conc.ThreadId
20:45:25 <solrize> how far away is GHC Core from runnable code?
20:47:35 <adu> lispy?
20:48:20 <adu> this is what I have so far: http://hpaste.org/12189
20:48:53 <ddarius> I don't think there's a metric on intermediate languages.
20:50:57 <adu> solrize: uhm, i thought it was runnable code
20:51:19 <solrize> well, if i have a core listing and want to run it...
20:57:59 <solrize> adu, what I really want is a programmable debugger, something like   debug :: IO () -> IO Debuggee
20:58:20 <solrize> i.e. you'd hand it an action like you'd give to forkIO
20:58:43 <solrize> and it would let you do things like run the action for 1 cpu second then stop
20:58:55 <solrize> so that the controlling program could examine the runtime state
21:00:31 <solrize> and could do things like force a gc and count the number of closures at each call site
21:08:26 <adu> solrize: wow
21:09:11 <solrize> so i wondered if the most straightforward way to do that was to concoct something that interprets Core
21:09:35 <adu> solrize: or write an interface to gdb
21:09:49 <solrize> i think gdb wouldn't be useful for this
21:09:54 <solrize> too low level
21:09:57 <adu> hmm
21:10:26 <solrize> the main motivation is to locate space leaks
21:10:44 <solrize> which means instrumenting the evaluator and gc
21:11:51 <solrize> or else have something that understands the layout of unevaluated expressions and can traverse them
21:14:07 <lispy> adu: neat
21:14:36 <lispy> adu: is the use of +/- swapped in the vertical diff of the %thrown line?
21:15:03 <lispy> adu: it seems that perhaps here is repeated?
21:17:12 <adu> lispy: ya, its broken
21:17:37 <lispy> adu: ah, well you're very close
21:17:38 <adu> lispy: I implemented it with Darcs' getChanges instead of my diff
21:17:53 <adu> lispy: and I'm still learning how it indexes things...
21:18:32 <adu> also, I think I found a good way of autodetecting when to use the "vertical" diff
21:19:18 * shapr yawns
21:20:44 <adu> lispy: also, someone on darcs-users mentioned "wdiff" but it seems to be word-based, not character-based
21:21:17 <Giraffe> hey, has anybody used gtk2hs on ubuntu here?
21:21:40 <lispy> adu: cool.  re: wdiff, I think Trent was just trying to understand what you're talking about.
21:21:45 <Giraffe> because i'm getting a strange error where when i use ghc to compile hello world, it spits out some ugly errors.  if i use ghci, it works fine
21:21:48 <Giraffe> what's wrong?
21:22:26 <jeffz> Giraffe: you might start by hpasting the errors
21:22:35 <Giraffe> jeffz, will do
21:23:15 <adu> lispy: about the code, I currently have everything under my "only" tree, so I could upload another version of that to hackage, or I could upload to tetration.itgo.com ... what do you think would be best?
21:23:43 <Giraffe> jeffz, http://hpaste.org/12190
21:23:59 <solrize> put --make on the command line
21:24:25 <Giraffe> oh, thanks!
21:24:29 <Giraffe> what does make do?
21:24:46 <solrize> loads those library files that you have undefined references to
21:25:11 <lispy> adu: we have been hosting feature branches at code.haskell.org under /srv/darcs/feature-foo
21:25:35 <adu> lispy: ooo nice
21:26:09 <lispy> adu: I may be slightly wrong on that path, maybe  it's /srv/code/darcs/foo ?  I forget
21:31:13 <adu> lispy: here is some of the code: http://hpaste.org/12189#a2
21:38:49 <roconnor> who here uses HPC
21:39:01 <lispy> I do
21:39:03 <lispy> a little
21:39:17 <roconnor> is it easy to use?
21:39:36 <roconnor> should it be part of how to write a haskell program?
21:40:07 <shapr> roconnor: Does my BladeServer count as Hi Performance Computing?
21:40:08 <pumpkin_> it looks really neat
21:40:14 <shapr> oh wait, haskell program coverage :-/
21:40:15 <pumpkin_> he's talking about program coverage I think
21:40:16 <pumpkin_> :)
21:40:16 <lispy> roconnor: it's pretty easy yet
21:40:26 <lispy> roconnor: yeah*
21:40:34 <adu> solrize: sounds like something you could use
21:40:54 <lispy> roconnor: it's like profiling.  You make a special build, you run it for a bit, then you run htis other program to summarize the data into an html file
21:43:02 <sbahra> @ask mmorrow Are you going to have time?
21:43:03 <lambdabot> Consider it noted.
21:43:12 <sbahra> @ask mmorow Are you going to have time?
21:43:13 <lambdabot> Consider it noted.
21:43:46 <shapr> @ask mmorrow What's he talking about?
21:43:46 <lambdabot> Consider it noted.
21:43:53 * shapr cackles madly
21:44:06 <newsham> ?last hogg
21:44:07 <lambdabot> No module "hogg" loaded
21:44:15 <shapr> ?last .fm
21:44:15 <lambdabot> No module ".fm" loaded
21:44:17 <shapr> hmm
21:44:18 <newsham> ?seen wchogg
21:44:19 <lambdabot> wchogg is in #haskell. I last heard wchogg speak 2h 23m 33s ago.
21:44:20 <shapr> ?last dummy
21:44:21 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you ping wiki oldwiki docs source fptools hackage
21:44:25 <shapr> aha
21:45:01 <adu> ?help shootout
21:45:01 <lambdabot> shootout. The debian language shootout
21:45:58 <sbahra> shapr, MMX/SSE2-driven computational library for Haskell
21:46:05 <sbahra> s/driven/optimized/
21:46:24 <shapr> oh!
21:46:26 <shapr> neato!
21:47:33 <solrize> adu, yeah, that's the idea, i feel clueless about how to spot such problems statically and from everything i can tell, it's difficult
21:51:53 <adu> http://tinyurl.com/haskellisthebest
21:51:55 <lambdabot> Title: Create your own Ranking | Gentoo : Intel¬Æ Pentium¬Æ 4 Computer Language Benchma ...
21:52:57 <ddarius> adu: Can you find a weighting that makes ruby the best?
21:54:25 <Axman6> i doubt ruby beats anything... at anything
21:56:37 <shapr> Axman6: cobol...
21:56:40 <shapr> at speed of development
21:56:54 <Axman6> lol
22:04:52 <adu> ddarius: http://tinyurl.com/rubyisthebest
22:04:54 <lambdabot> Title: Create your own Ranking | Gentoo : Intel¬Æ Pentium¬Æ 4 Computer Language Benchma ...
22:05:54 <adu> Axman6: it was really hard to find something that Ruby did better than Python :/
22:06:20 <shapr> heh
22:07:26 <nybyn> shapr: cobol on cogs is gaining steam
22:07:43 <Twey> Hahaha
22:07:47 <shapr> nybyn: svensk?
22:08:16 <nybyn> shapr: nej.. dansk
22:08:19 <shapr> jaha
22:08:23 <adu> nybyn: r u srsly?
22:08:33 <shapr> I figured your nickname didn't mean "The new village" by accident.
22:08:36 <nybyn> oh yea, nybyn is a town in sweden, huh?
22:08:46 <nybyn> well, nyby is my last name
22:08:49 <shapr> hah
22:08:55 <shapr> Makes sense.
22:09:16 <shapr> dansk in washington?
22:09:19 <shapr> I'm alabamsk.
22:09:22 <adu> someone once thought I was Arab
22:09:24 <nybyn> lol
22:09:36 <shapr> adu: People keep thinking I'm Czech.
22:09:37 <dolio> @oeis 12 6 4 3
22:09:37 <lambdabot>  Triangle read by rows: k-th column (k=0,1,2...) is (1,2,3,...) interspersed ...
22:09:37 <lambdabot>  [1,2,1,3,0,1,4,2,0,1,5,0,0,0,1,6,3,2,0,0,1,7,0,0,0,0,0,1,8,4,0,2,0,0,0,1,9,0...
22:10:21 <nybyn> i was an exchange student over in denmark.. not really dansk i guess
22:10:28 <shapr> nybyn: jaha
22:10:28 <adu> shapr: my great-great-great-grandmother was Czech
22:10:37 <shapr> nybyn: I was an exchange... something in Sweden.
22:10:44 <shapr> Actually, they RMA'd me.
22:10:52 <nybyn> RMA?
22:11:19 <adu> is that like KO
22:11:30 <shapr> "returned materials authorization" like when you ship back hardware.
22:11:52 <shapr> I got GC'd out of Sweden.
22:12:33 <lispy> shapr: finalizers can be a bitch when they decide to execute :(
22:15:19 <mornfall> shapr: Why people think you are Czech?
22:15:46 <mornfall> gio123: I have seen Pol√°k yesterday, on a lecture by prof. Volkov, on synchronising automata.
22:15:53 <mornfall> gio123: So he's alive. :)
22:16:01 <shapr> mornfall: I don't know.
22:16:24 <shapr> They said it's my wide shoulders, thick neck, and calm demeanor.
22:16:29 <shapr> Then I say something, and it's all over.
22:16:42 <gio123> mornfall: hehe
22:16:46 <gio123> mornfall: PM
22:16:52 <gio123> mornfall: see PM
22:16:59 <shapr> Prime Minister?
22:17:12 <mornfall> shapr: ...
22:17:17 <shapr> :-)
22:17:18 <gio123> shapr: yes  Pol√°k  is PM
22:17:21 <gio123> :)
22:17:26 <shapr> hah
22:17:28 <Axman6> shapr: he's on here all the time, you've missed him?
22:17:31 * mornfall happens to be, well, sort-of Czech.
22:17:45 <adu> shapr: so you're not Czech?
22:17:59 <shapr> adu: No, nor am I Swedish, nor Finnish, nor ...
22:18:02 <shapr> I'm from Alabama, USA.
22:18:09 <shapr> currenty living in Boston.
22:18:10 <adu> shapr: oh, heh
22:18:42 <shapr> adu: What did you think?
22:19:03 <adu> shapr: i dunno, that you were from Japan
22:19:09 <mornfall> Heh.
22:19:22 <shapr> Ooh I like that one. That's the best I've heard in weeks.
22:19:37 <mornfall> Someone, quick, write a book... "The question of shapr's origin."
22:19:45 <mornfall> It might be the next bestseller.
22:19:48 <shapr> hah
22:20:02 <shapr> I should write my memoirs... most people don't believe my true stories
22:20:20 <adu> shapr: cuz theres only 3 places with lots of lights, and I eliminated the Americas and Europe, which leaves Japan
22:20:45 <shapr> Lots of lights? Is it so obvious that I am attracted to shiny things?
22:21:12 <adu> shapr: no, its obvious you live in a place like a city, or an urban place...
22:21:30 <adu> which rules out Australia
22:21:37 <mornfall> -->
22:21:51 <shapr> adu: You've been here for several years, yeah?
22:22:03 <shapr> That is, #haskell?
22:22:04 <adu> hmm, i suppose
22:22:24 <shapr> Two years ago I lived in Sweden, seven years before that I was in Finland, maybe that confused you?
22:22:38 <adu> shapr: I don't remember any of that
22:22:56 <shapr> oh
22:24:17 <adu> shapr: maybe my dyslexic brain was thinking of this: http://www.sharp.co.jp/
22:24:19 <lambdabot> Title: ÔøΩVÔøΩÔøΩÔøΩ[ÔøΩvÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ
22:24:36 <shapr> coud be
22:24:44 <shapr> Anyway, maybe you'll remember me now :-)
22:24:50 <shapr> I'm off to sleep, g'nite!
22:24:55 <adu> shapr: night
22:25:44 <rwbarton> Has anyone here used HXT?  How can I get it not to download the DTD when parsing an XML file?
22:27:33 <adu> rwbarton: dunno, but my guess would be to replace the URL with a local path
22:28:49 <rwbarton> adu: I have a local file, it's actually a plist file, and it has a DOCTYPE in it with the plist DTD
22:29:26 <rwbarton> I'd rather not modify the file itself
22:29:38 <rwbarton> (because I also want to use it as a plist file)
22:29:54 <adu> then s/<!DOCTYPE ...>/<!DOCTYPE ... "myfile.dtd">/
22:30:33 <adu> before you pass it to HXT or something
22:31:15 <rwbarton> Yeah, or I could just delete the whole line... I'm pretty sure it's not needed if I don't want to validate the input (though I don't really understand XML)
22:31:35 <adu> rwbarton: theres nothing to understand, its just data
22:32:05 <adu> besides 90% of the world only uses 10% of XML
22:32:09 <rwbarton> Well, what is the DTD for
22:32:31 <adu> rwbarton: for the 10% of the world to be happy
22:32:52 <rwbarton> I think it's only there so that my parser can check whether the file conforms to it, but I'm already assuming it does anyways.
22:32:55 <adu> it is for validation
22:43:52 <geezusfreeek> quicksilver, wchogg: in reference to conversation over eleven hours ago, i'm implementing my frp stuff lazily now also :)
22:44:29 <geezusfreeek> i found an implementation i like and am lazily reimplementing as i go for better testability
22:45:13 <geezusfreeek> happy with it so far. i think i can even get it to stream fuse
22:50:06 <adu> stream fuse?
22:50:11 <adu> i want that
22:50:23 <geezusfreeek> :)
22:50:40 <quicksilver> geezusfreeek: nice
22:50:47 <quicksilver> geezusfreeek: whose implementation do you like?
22:51:16 <geezusfreeek> i meant "found" as in "discovered myself"
22:51:27 <adu> heh
22:51:41 <quicksilver> oho
22:51:58 <quicksilver> I look forward to seeing it evolve
22:52:11 <geezusfreeek> basically just taking inspiration from interact, using unsafeInterleaveIO to make lazy streams of events
22:52:18 <adu> and by "discovered" I mean "stole from Microsoft"
22:53:04 <quicksilver> geezusfreeek: you need some ability to work out whether there is an event coming without blocking, though?
22:53:07 <quicksilver> to implement mappend
22:53:18 <geezusfreeek> quicksilver: i'm just polling
22:53:36 <geezusfreeek> ah, no, it doesn't really work like that
22:54:55 <geezusfreeek> newtype Event a = Event [[a]] ... each inner list is a set of events which happen at the same time, and the next sample period is the beginning of another list
22:55:36 <geezusfreeek> due to the way i'm making things work, mappend is basically a variation on zipWith (++)
22:56:06 <geezusfreeek> i use the empty list to denote a sample which had no events occur
22:56:34 <quicksilver> ah, fixed sampling interval
22:56:44 <geezusfreeek> well, not really
22:57:00 <geezusfreeek> i'm trying to arrange things where it doesn't have to be, anyway
22:57:03 <quicksilver> streams which know what their sampling interval, then?
22:57:14 <geezusfreeek> the two streams do have to sample "at the same time" though
22:57:29 <quicksilver> could take lowest common denominator when merging
22:57:43 <geezusfreeek> which i'm going to do by making the zip function strict
22:58:20 <geezusfreeek> i think i can manage it anyway
23:00:03 <geezusfreeek> my intent is to have a single point of entry for the sampling. it may take a bit more upfront work in the IO monad, but it will keep things much simpler inside
23:00:43 <quicksilver> will you have something like Reactive's Behaviour?
23:00:51 <quicksilver> that is a continuously varying quantity?
23:01:04 <geezusfreeek> likely... we'll see if i have a need
23:03:41 <geezusfreeek> most or all of Reactive should be possible. it will just be a delicate balance of strictness and laziness
23:23:46 * Nafai looks at Turbinado
23:25:49 <dmwit_> Looks like pumpkin got some very effective spam.
23:25:55 <pumpkin> lol
23:26:03 <pumpkin> I was being stupid in #crypto
23:26:34 <dmwit_> That's a dangerous field to be stupid in.
23:26:45 <dmwit_> ;-)
23:26:54 <pumpkin> oh, definitely
23:27:01 <pumpkin> I like living on the edge, though
23:44:22 <lispy> I'm really confused
23:44:29 <lispy> I used cabal install to install MonadRandom
23:44:43 <lispy>   Build-depends: base, MonadRandom
23:44:57 <lispy> Setup.hs: At least the following dependencies are missing:
23:44:57 <lispy> MonadRandom -any
23:45:11 <lispy> and yet it's installed when I look at ghc-pkg list
23:45:18 <lispy> what am I doing wrong?
23:45:25 <dmwit_> user vs global?
23:45:31 <lispy> it's installed in my user
23:46:03 <lispy> does it have to be installed global? if so, why?
23:46:04 <dmwit_> Then you might need to explicitly configure whatever you're configuring as user, yeah?  I guess you already knew that, though.
23:46:32 <lispy> I'm just running runghc Setup.hs configure
23:46:33 <geezusfreeek> i'm making a series of functions with types ((forall a. a -> f a) -> f (f a)), ((forall a. a -> f a) -> f (f (f a))), ((forall a. a -> f a) -> f (f (f (f a)))), and so on, but i'm not sure what to name them. any category theory guys know what i'm after? (and if something like these already exist somewhere?)
23:46:37 <lispy> should I run something different?
23:46:40 <dmwit_> lispy: Yes.
23:46:46 <lispy> ?
23:46:47 <dmwit_> lispy: runghc Setup.hs configure --user
23:46:50 <lispy> why?
23:46:59 <lispy> okay, that's stupid
23:47:03 <lispy> that works
23:47:11 <lispy> but I don't understand it, and it offends me a bit :)
23:47:11 <dmwit_> lispy: Otherwise, it tries to configure for a global install.
23:47:27 <dmwit_> (global is the default for cabal; user is the default for cabal-install.  Weird, huh?)
23:47:52 <lispy> why should the global availability (or not) of the package make a difference?
23:48:00 <lispy> it's available, so use it :)
23:48:14 <dmwit_> lispy: It needs to be available after you install, too.
23:48:16 <lispy> wait, so I'm supposed to be using a different command line?
23:48:26 <lispy> I should be using cabal configure?
23:48:32 <dmwit_> lispy: i.e. another user needs to be able to see MonadRandom to use a package depending on MonadRandom.
23:48:48 <dmwit_> Does this make sense?
23:49:02 <lispy> if I don't need to say, 'runghc Setup.hs blah' and I can just do 'cabal blah' then that's fine.  I'm just trying to figure this out...
23:49:18 <dmwit_> Yes, "cabal install" should Just Work.
23:49:23 <lispy> oh
23:49:30 <lispy> thanks
23:49:30 <dmwit_> It looks for .cabal files for you.
23:49:57 <lispy> so once I have a cabalized project, how do I load it into ghci?
23:50:04 <dmwit_> If it's a hackage package, you don't even need to download anything; "cabal install <packagename>" will fetch it and its dependencies for you. =)
23:50:07 <lispy> or is that a cabal missing feature?
23:50:17 <dmwit_> lispy: err, what?
23:50:24 <dmwit_> Just :m + Module.Name, I guess.
23:50:26 <lispy> dmwit_: yeah, I thoughc cabal-install only worked with hackage
23:50:35 <lispy> Well, I want to load all the modules
23:50:49 <lispy> Iwant to load the whole library like, 'cabal ghci'
23:50:51 <dmwit_> :m + All.Module Names.Go.Here ;-)
23:50:58 <dmwit_> So, no, you can't do that automatically.
23:51:02 <lispy> that's painful :)
23:51:20 <rwbarton> Well, all qualified names are automatically in scope.
23:51:26 <dmwit_> true
23:51:36 <lispy> dmwit_: wel, thank you very much...I didn't realize I should be using 'cabal foo' instead of the older runghc stuff
23:52:17 <lispy> it's less to type and works the way I want, so I can't complain other than about my previous ignorance
23:53:02 <lispy> the cabal user manual is getting out of date
23:53:03 <lispy> http://www.haskell.org/ghc/docs/latest/html/Cabal/index.html
23:53:04 <lambdabot> Title: Common Architecture for Building Applications and Libraries
23:55:53 <geezusfreeek> actually i meant (forall a. a -> f a) -> a -> f (f a)
