00:00:08 <Saizan> well, use fail instead of throwError
00:00:10 <dolio> > throwError (strMsg "foo") >>= print
00:00:11 <lambdabot>   * Exception: "<IO ()>"
00:00:38 <Saizan> (that exception is just a quirk introduced by gwern)
00:00:41 <solrize_> i gotta goto bed, nite all
00:01:11 <dolio> > throwError (strMsg "foo") >>= return 5 :: Either String Int
00:01:12 <lambdabot>       No instance for (Num (Either String Int))
00:01:12 <lambdabot>        arising from the liter...
00:01:30 <dolio> > (throwError (strMsg "foo") >>= return 5) :: Either String Int
00:01:32 <lambdabot>       No instance for (Num (Either String Int))
00:01:32 <lambdabot>        arising from the liter...
00:01:40 <Saizan> dolio: >>
00:01:45 <dolio> Oh, right.
00:01:52 * dolio needs sleep.
00:02:24 <Saizan> ?localtime dolio
00:02:25 <lambdabot> Local time for dolio is Sun Nov 30 03:02:24 2008
00:02:39 <Saizan> heh :)
00:05:50 <kayess__> Can anybody explain what this syntax does in a function: func n list@(x:xs) -- I think it might give me the list in 'list' and also the head/tail in x and xs
00:06:11 <Cale> kayess__: yes
00:06:15 <kayess__> Thanks
00:06:41 <Beelsebob> > f a@(b,c) = (a,b,c) in f (1,2)
00:06:42 <lambdabot>   <no location info>: parse error on input `='
00:06:55 <Beelsebob> > let f a@(b,c) = (a,b,c) in f (1,2)
00:06:57 <lambdabot>   ((1,2),1,2)
00:07:16 <vixey> > let f a@(b,c) = (a,b,c) in f (f (f (f (1,2))))
00:07:17 <lambdabot>   Couldn't match expected type `(t, t1)'
00:07:32 <vixey> > let f a@(b,c) = ((a,b),c) in f (f (f (f (1,2))))
00:07:33 <Beelsebob> > let f a@(b,c) = (a,b) in f (1,2)
00:07:34 <lambdabot>   (((((((((1,2),1),2),((1,2),1)),2),((((1,2),1),2),((1,2),1))),2),((((((1,2),...
00:07:35 <lambdabot>   ((1,2),1)
00:07:43 <Beelsebob> hehe
00:09:19 <vixey> > let f x@(o,m,o) = (x,m,x) in f (f (f (f (f ('#',' ','#')))))
00:09:21 <lambdabot>       Conflicting definitions for `o'
00:09:21 <lambdabot>      In the definition of `f'
00:09:32 <vixey> > let f x@(_,o,_) = (x,o,x) in f (f (f (f (f ('#',' ','#')))))
00:09:34 <lambdabot>   (((((('#',' ','#'),' ',('#',' ','#')),' ',(('#',' ','#'),' ',('#',' ','#'))...
00:10:14 <Beelsebob> for something like that, you really should have used the boobies operator though
00:12:21 <vixey> thought up a nice trick
00:13:43 <cknapp> Morning everyone
00:13:48 <vixey> hi
00:15:10 <vixey> cknapp, you were asking about the depth first thing yeah?
00:15:18 <cknapp> Yeah
00:15:33 <vixey> I thought up a nice way to do it
00:15:38 <ksf> depth first is bottoms on top instead of sipping.
00:15:55 <cknapp> ?
00:16:16 <vixey> standard practice to represent a graph like
00:16:22 <vixey> g 0 = [1,2]
00:16:27 <vixey> g 1 = []
00:16:30 <vixey> g 2 = [0]
00:16:33 <moreqwertythanu> transpose xs = map (\i -> map (\x -> x !! i) xs) [0..length (xs !! 0)-1]
00:16:54 <vixey> so you have a function Node -> [Node]
00:17:15 <vixey> Now if you want the transitive closure,
00:17:25 <vixey> data Graph a = a :-->: [Graph a]
00:17:36 <ksf> hmmm... dict.leo.org translates "auf ex" as "to down", not as "bottoms on top" as I learned it.
00:18:28 <vixey> so you get something like  0 :-->: [1 :--> [], 2 :--> [0 :-->: ...
00:18:32 <vixey> does this make sense?
00:18:43 <cknapp> Vixey: So that representation takes a graph, and gives a new graph with a connected?
00:19:36 <vixey> yeah you can write a function that takes 'g' into a Graph
00:19:42 <moreqwertythanu> ?src transpose
00:19:43 <lambdabot> transpose []             = []
00:19:43 <lambdabot> transpose ([]   : xss)   = transpose xss
00:19:43 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
00:20:03 <vixey> but new you have the same old problem with DFS going loopy when it hits cycles
00:20:09 <vixey> but now*
00:20:42 <vixey> so must next truncate off cycles
00:20:58 <vixey> whole thing ends up about 2 lines of code :)
00:21:50 <cknapp> truncate off cycles... by adding visited vertices to some list(/set/sequence)? Or something more clever?
00:22:29 <ksf> by using befunge and have your code crash into itself
00:22:31 <cknapp> ksf, I just got your pun...  If it was a pun
00:22:36 <ksf> sorry, but i'm in the mood.
00:23:34 <ksf> It's either a pun or koan, depending on perspective.
00:24:03 <vixey> now I have something I can't figure out how to program
00:24:14 <cknapp> It works better as a koan... in English at least: "To down" has multiple interpretations
00:24:36 * ksf imagines a self-modifying n-funge program constructing a deph-first analysis.
00:24:41 <vixey> whenever that happens I think that what I need to do is impossible
00:25:13 <cknapp> whenever what happens? You can't figure out how to program something?
00:25:31 <vixey> yeah
00:25:44 <vixey> It's really frustrating
00:25:45 <cknapp> What are you trying to program?
00:26:27 <ksf> vixey, did you read the fgl paper? It's got a lot of solutions to such stuff.
00:26:41 <vixey> ksf, oh I am not thinking about graphs anymore
00:29:26 <ksf> you could try making sketches and then a paper plane, analysing the flight behaviour for possible solutions.
00:47:21 <jeffwheeler> What can be put in, say, a case/of branch if I don't want anything to happen if it follows that branch? I'm printing something in the Just part, but I don't need to print anything in the Nothing branch.
00:47:45 <jeffwheeler> I could, of course, do something like print "", but that's silly.
00:47:52 <vixey> jeffwheeler, start with the type -- what's the type of that branch?
00:48:06 <jeffwheeler> IO ()
00:48:18 <jeffwheeler> As I said, I'm just printing something in the other branch.
00:48:24 <vixey> ok so now consider every value of type IO (), pick one
00:48:33 <jeffwheeler> ()
00:48:40 <vixey> () is almost IO ()
00:48:45 <jeffwheeler> yeah, I need a return
00:48:47 <jeffwheeler> return ()
00:48:52 <jeffwheeler> or . . . something like that?
00:49:30 <ksf> "Don't underrate Haskell programmers. The ones I know have the kind of minds where if you switched the names to pig latin, they wouldn't skip a beat."
00:49:35 <ksf> http://www.mail-archive.com/boost@lists.boost.org/msg08898.html
00:49:46 <lambdabot> Title: Re: [boost] Re: Interest in FC++?
00:50:26 <Cheery> I try find out how to implement type inference for a language, studying the hindley milner..
00:50:31 <jeffwheeler> vixey: thanks
00:50:51 <vixey> Cheery, Do you already know the unification algorithm?
00:51:00 <cknapp> vixey: what's the base case in the graph representation you gave above?
00:51:05 <Cheery> vixey: yes
00:51:27 <Cheery> vixey: but that's the trivial thing about that
00:51:43 <vixey> Cheery, 1) annotate the syntax tree with fresh type variables
00:51:59 <vixey> Cheery, 2) fold over the structure, applying the type rules by unification as you go
00:53:04 <Cheery> I've been done that too, but there's a problem in it
00:53:26 <vixey> with the algorithm I just described?
00:53:43 <vixey> or (some specific part of) your implementation?
00:53:56 <vixey> cknapp, no need for a base case
00:54:31 <Cheery> vixey: well, it botches down with stuff like this: (a,a)
00:54:38 <Cheery> where a must be same type.
00:55:02 <vixey> Cheery, which?
00:55:19 <Cheery> say you foldr over that structure and first branch returns that a couldn't be solved
00:55:21 <sjanssen> @type aybema
00:55:22 <lambdabot> Not in scope: `aybema'
00:55:24 <sjanssen> ksf: :)
00:55:51 <vixey> Cheery, yeah you wanna use a monad transformer (or Prolog)
00:56:20 * sjanssen wants to import Eludepray
00:56:28 <Cheery> and second branch finds out something, the first branch never gets the updated types
00:58:17 <Cheery> vixey: not going to use haskell or prolog, asked it on channel because you guys at this channel know this stuff
00:58:35 <vixey> what will you use?
00:58:54 <Cheery> python
00:59:09 <vixey> huh.. that sounds even worse choice..
00:59:18 <cknapp> vixey... so to extract the vertex set I need to run a search, right?
00:59:40 <vixey> in Python you don't have built in backtracking, unification, pattern matching on ADTs ...
01:00:32 <pstickne> (or even static typing! O.o)
01:00:50 <moreqwertythanu> how does derving work?n deriving eq means checking each element in order for equality?
01:01:38 <moreqwertythanu> http://stackoverflow.com/questions/327955/does-functional-programming-replace-gof-design-patterns
01:01:44 <lambdabot> Title: Does Functional Programming Replace GoF Design Patterns? - Stack Overflow, http://tinyurl.com/67726b
01:02:27 <ksf> @faq Can I program Haskell in pig-latin?
01:02:28 <lambdabot> The answer is: Yes! Haskell can do that.
01:02:31 <Cheery> vixey: it's tricky, but not impossible.
01:02:32 <ksf> the key is TH.
01:04:27 <vixey> What will you do once you have type inference though?
01:06:52 <moreqwertythanu> http://stackoverflow.com/questions/327955/does-functional-programming-replace-gof-design-patterns
01:06:54 <lambdabot> Title: Does Functional Programming Replace GoF Design Patterns? - Stack Overflow, http://tinyurl.com/67726b
01:07:08 <moreqwertythanu> are monads design patterns?
01:07:18 <vixey> no
01:07:23 <Cheery> vixey: then I continue with using the inference to give hints for the compiler.
01:07:28 <ksf> @faq
01:07:29 <lambdabot> The answer is: Yes! Haskell can do that.
01:07:51 <vixey> Cheery, It sounds horrendously tedious to write a compiler in python compared to haskell or prolog
01:08:38 <ksf> monads are algrebraic properties.
01:09:18 <ksf> moreqwertythanu, http://www.youtube.com/watch?v=9fohXBj2UEI
01:09:19 <lambdabot> Title: YouTube - Monads 1
01:10:14 <Cheery> vixey: haskell is a bit too high over me, and prolog has poor libs
01:10:28 * ksf silently waits for moreqwertythanu's head to explode.
01:10:30 <vixey> Cheery, what do you mean too high?
01:10:53 <cknapp> vixey: How do I extract the vertex set from the representation you gave?
01:11:00 <vixey> (swi prolog has fine libs though..)
01:11:15 <vixey> cknapp, Did you write some code?
01:11:23 <cknapp> I'm trying.
01:11:45 <pumpkin_> why doesn't @src fmap show me anything?
01:11:57 <cknapp> I'll hpaste what I have.
01:12:01 <vixey> pumpkin_, fmap has no single definition
01:12:07 <pumpkin_> oh :)
01:12:36 <Saizan> @src [] fmap
01:12:37 <lambdabot> fmap = map
01:12:41 <pumpkin_> aha
01:12:42 <Saizan> @src Maybe fmap
01:12:43 <lambdabot> fmap _ Nothing       = Nothing
01:12:43 <lambdabot> fmap f (Just a)      = Just (f a)
01:13:06 <pumpkin_> @src State fmap
01:13:06 <lambdabot> Source not found.
01:13:16 <pumpkin_> I fail
01:13:19 <vixey> if you have a something along the lines of  data F a = ... | Q a | ... (F a) ...
01:13:19 <snhmib> @src Functor
01:13:20 <lambdabot> class  Functor f  where
01:13:20 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
01:13:34 <Saizan> pumpkin: the databse is far from "complete"
01:13:39 <pumpkin_> :)
01:13:39 <Cheery> vixey: this far I've failed to use it for any real application
01:13:48 <vixey> it's usually only one sensible definition of (a -> b) -> (F a -> F b)
01:15:36 <Saizan> also, for any monad, fmap f m == m >>= return . f == liftM f m
01:15:51 <dibblego> heh we just had that discussion in #scala
01:16:54 <ksf> FC++ functoids can be called using a special infix syntax (implemented by overloading operator^):
01:16:55 <ksf>    x ^f^ y        // Same as f(x,y).  Example: 3 ^plus^ 2
01:16:57 <ksf> zomg
01:17:51 <cknapp> vixey: what I have. I think I mentioned it obviously won't work. :) http://hpaste.org/12514
01:17:54 <ksf> seems c++ doesn't suck as much if you use it as a extensible compiler.
01:19:39 <vixey> cknapp, style tip is to use  vertices (x:-->: g:rest) found = ...  rather than  vertices graph = let vertices' (x:-->: g:rest) found = ...
01:20:44 <vixey> cknapp, you should have a network around to try things with (like my 'g' above)
01:20:58 <cknapp> the point was to get a vertex set straight from a graph
01:21:10 <vixey> 'Graph' is just a (very useful) tool for computing things based off
01:21:22 <vixey> don't do that.. :)
01:21:32 <cknapp> OK. :)
01:21:37 <vixey> Graph isn't really useful for that
01:21:47 <vixey> I'd go with something like
01:22:04 <vixey> data Cites = Paris | NewYork | ...
01:22:15 <vixey> vertices = [Paris, NewYork, ...]
01:22:45 <vixey> so you don't even need to write a program to calculate vertexSet
01:23:03 <cknapp> ok
01:23:28 <vixey> (if you loaded the Cities and network from a file for example, then 'vertices' could be computed at that time)
01:28:45 <pumpkin_> the if' that @pl outputs, is that just @pl syntax for the normal if?
01:28:48 <pumpkin_> or is it a real function somewhere?
01:29:34 <C-Keen> there's a proposal for a if' on the wiki
01:29:46 <vixey> if' is a function
01:29:55 <pumpkin_> > if' True 1 0
01:29:56 <lambdabot>   Not in scope: `if''
01:30:07 <pumpkin_> hmm
01:30:22 <pumpkin_> @hoogle Bool -> a -> a -> a
01:30:23 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
01:30:23 <lambdabot> Test.HUnit.Text PutText :: String -> Bool -> st -> IO st -> st -> PutText st
01:30:23 <lambdabot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
01:31:43 <blueonyx> hi
01:32:06 <pumpkin_> hi
01:34:20 <cknapp> hi
01:34:41 <blueonyx> ah nice found the function i needed because of its type :)
01:40:39 <C-Keen> @hoogle if'
01:40:39 <lambdabot> No results found
01:43:53 <moreqwertythanu> how do ir eturn infinity?
01:44:45 <pumpkin_> 1/0 ?
01:45:23 <pumpkin_> > map fst . filter ((== 1) . snd) $ zip [1..10] $ cycle [1..3] -- is there an easier way to pick out every third element of the [1..10] list than this?
01:45:24 <lambdabot>   [1,4,7,10]
01:48:24 <pumpkin_>  is there an easier way to pick out every third element of the [1..10] list than that?
01:48:31 <pumpkin_> it seems like there must be
01:49:20 <Peaker> > let everyNth n = map head . iterate (drop n) in everyNth 3 [1..10]
01:49:21 <lambdabot>   [1,4,7,10,* Exception: Prelude.head: empty list
01:49:35 <pumpkin_> ooh
01:49:35 <Peaker> > let everyNth n = map head . takeWhile (not . null) . iterate (drop n) in everyNth 3 [1..10]
01:49:37 <lambdabot>   [1,4,7,10]
01:49:45 <pumpkin_> that's nice
01:49:49 <pumpkin_> thanks :)
01:50:11 <Peaker> sure :)
01:56:22 <vixey> map head . chunks 3
01:56:44 <vixey> a List1 type would be nice actually
01:57:01 <pumpkin_> > chunks 3 [1..10]
01:57:02 <lambdabot>   Not in scope: `chunks'
01:57:24 <moreqwertythanu> insert :: Ord k => k -> a -> Map k a -> Map k a
01:57:33 <pumpkin_> vixey: where does chunks come from?
01:57:43 <moreqwertythanu> nevermind
01:57:43 <pumpkin_> vixey: and what would List1 do differently?
01:58:03 <pumpkin_> @hoogle chunks
01:58:03 <lambdabot> package chunks
01:58:03 <lambdabot> Data.ByteString.Lazy.Internal defaultChunkSize :: Int
01:58:03 <lambdabot> Data.ByteString.Lazy.Internal foldlChunks :: (a -> ByteString -> a) -> a -> ByteString -> a
01:58:15 <vixey> @let chunk n list = let ch' [] _ k = k [] : []; ch' (y:ys) 0 k = k [] : ch' ys (n-1) (y:); ch' (y:ys) (c+1) k = ch' ys c (k . (y:)) in case list of { [] -> [] ; (y:ys) -> ch' ys (n-1) (y:) }
01:58:16 <lambdabot>   Parse error in pattern:
01:59:00 <vixey> @let chunk n list = let ch' [] _ k = k [] : []; ch' (y:ys) 0 k = k [] : ch' ys (n-1) (y:); ch' (y:ys) c k = ch' ys (c-1) (k . (y:)) in case list of { [] -> [] ; (y:ys) -> ch' ys (n-1) (y:) }
01:59:01 <lambdabot>  Defined.
01:59:10 <moreqwertythanu> how do I declare a set?
01:59:18 <moreqwertythanu> or what are sets?
01:59:24 <vixey> List1 would not do anything differently, but it should always have at least one element
01:59:27 <pumpkin_> > chunk 3 [1..10]
01:59:28 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
01:59:31 <moreqwertythanu> i want O(1) unique insert
01:59:35 <mmorrow> @index UArray
01:59:35 <lambdabot> Data.Array.Unboxed
01:59:46 <vixey> then you could write chunk :: Integer -> List a -> List (List1 a)
02:00:02 <pumpkin_> ah
02:00:25 <vixey> lambdabot should learn n+k patterns
02:00:30 <moreqwertythanu> i want to insert O(1) and discard unqire into a list
02:00:31 <pumpkin_> moreqwertythanu: there's Data.Set, but it doesn't have O(1) insert
02:08:55 <pumpkin_> moreqwertythanu: you could use a bloom filter ;) but that's probably not what you want
02:18:00 <pumpkin_> it seems like iterate could be used to make a simple mandelbrot/julia set
02:18:49 <vixey> @go simon composable fractals
02:18:55 <lambdabot> http://www.computer.org/portal/site/computer/index.jsp?pageID=computer_level1_article&TheCat=1075&path=computer/homepage/Mar07&file=webtech.xml&xsl=article.xsl
02:19:00 <pumpkin_> :o
02:19:08 * vixey did not get the hole in 1
02:19:27 <ksf> moreqwertythanu, the only O(1) random insert there is is an array (and you get discard for free)
02:20:20 <ksf> the whole thing breaks down if your data has a wide range and you're not even close to filling up every slot, use a Map then.
02:20:44 <ksf> O(ld n) is fast enough.
02:21:12 <pumpkin_> > (0 :+ 0)
02:21:14 <lambdabot>   0.0 :+ 0.0
02:21:38 * ksf just decided that :+ is the cute nose operator.
02:21:44 <pumpkin_> :)
02:22:32 <pumpkin_> > iterate (\x -> x^2 + (0 :+ 1))
02:22:33 <lambdabot>       Overlapping instances for Show (Complex t -> [Complex t])
02:22:33 <lambdabot>        arisin...
02:22:36 <Twey> What does :+ construct?
02:22:42 <Twey> Complex numbers?
02:22:45 <pumpkin_> yup
02:22:47 <ksf> :t (:+)
02:22:49 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
02:22:49 <Twey> Oho
02:22:50 <pumpkin_> :t iterate (\x -> x^2 + (0 :+ 1))
02:22:52 <lambdabot> forall t. (RealFloat t) => Complex t -> [Complex t]
02:23:44 <pumpkin_> > take 100 . iterate (\x -> x^2 + (0 :+ 1))
02:23:45 <lambdabot>       Overlapping instances for Show (Complex t -> [Complex t])
02:23:45 <lambdabot>        arisin...
02:23:47 <ksf> shouldn't that read (x^2 :+ 1)?
02:23:54 <benny99> if I got a function 'foo (SomeData x) y = ...' how was I able to 'label' (SomeData x) again ? Like 'foo someData y = let (SomeData x) = someData in ...'
02:24:04 <Twey> benny99: s@
02:24:11 <benny99> twb, thanks :)
02:24:13 <vixey> > e ^ (0 :+ pi) :: Complex CReal
02:24:15 <lambdabot>   Couldn't match expected type `Complex CReal'
02:24:16 <pumpkin_> ksf: you square the previous iteration and add the "query point", I think
02:24:21 <Twey> Where s is your label :)
02:24:24 <vixey> > e ** (0 :+ pi) :: Complex CReal
02:24:26 <lambdabot>   Couldn't match expected type `Expr'
02:24:30 <vixey> > exp (0 :+ pi) :: Complex CReal
02:24:32 <lambdabot>   (-1.0) :+ 0.0
02:24:45 <ksf> foo bar@(Foo quux) = ...
02:24:47 <benny99> ok :)
02:25:19 <ksf> pumpkin, i've got no idea at all what your code is about.
02:25:27 <ksf> I'm just simplifying.
02:25:39 <pumpkin_> ksf: trying to define the mandelbrot set :P
02:25:52 <ksf> You're lucky that I didn't just simplify it to _|_ ;)
02:25:55 <pumpkin_> the 0 :+ 1 is a parameter
02:26:03 <pumpkin_> or would be when I was done
02:26:22 <vixey> @let i = sqrt (-1) :: CReal
02:26:23 <lambdabot>  Defined.
02:26:47 <vixey> > exp (i * pi) + 1
02:26:48 <lambdabot>       Ambiguous occurrence `i'
02:26:48 <lambdabot>      It could refer to either `L.i', defined a...
02:26:59 <vixey> > let i = sqrt (-1) :: CReal in  exp (i * pi) + 1
02:27:01 <lambdabot>   * Exception: Ratio.%: zero denominator
02:27:01 <ksf> well the 0 is just the real part, so x + ( 0 :+ 1) is x :+ 1
02:27:09 <vixey> > let i = sqrt (-1) :: Complex CReal in  exp (i * pi) + 1
02:27:11 <lambdabot>   0.0 :+ 0.0
02:27:18 <pumpkin_> ksf: yes, but I was going to replace 0 :+ 1 with c later on :P
02:27:29 <vixey> > let i x = sqrt (-x) :: Complex CReal in  exp (i pi) + 1
02:27:31 <lambdabot>   1.2002935411233737994971791018013445387239 :+ 0.979735932475817367706050763...
02:28:02 <ksf> dreaming of defining the ( ) operator?
02:28:44 <ksf> function application should be overloadable, anyway.
02:32:31 <pumpkin_> @let mandel c = length . takeWhile ((< 2) . magnitude) $ take 100 . iterate (\x -> x^2 + c) $ (0 :+ 0)
02:32:32 <lambdabot>  Defined.
02:32:35 <pumpkin_> whee
02:32:45 <vixey> :t mandel
02:32:47 <lambdabot> forall a. (RealFloat a) => Complex a -> Int
02:32:50 <vixey> > mandel i
02:32:52 <lambdabot>       Ambiguous occurrence `i'
02:32:52 <lambdabot>      It could refer to either `L.i', defined a...
02:32:59 <vixey> > let i = sqrt (-1) :: Complex CReal in madel i
02:33:00 <lambdabot>   Not in scope: `madel'
02:33:01 <vixey> > let i = sqrt (-1) :: Complex CReal in mandel i
02:33:13 <pumpkin_> > mandel (0 :+ 1)
02:33:15 <lambdabot>   100
02:33:16 <lambdabot>   thread killed
02:33:20 <pumpkin_> lol
02:33:25 <vixey> > let i = sqrt (-1) :: Complex CReal in mandel 0
02:33:25 <pumpkin_> I take it that's bad?
02:33:27 <lambdabot>   100
02:33:38 <vixey> I can see what's happening
02:33:47 <pumpkin_> why did it kill the thread?
02:33:48 <vixey> > let i = sqrt (-1) :: Complex CReal in mandel (1 + i)
02:33:50 <lambdabot>   2
02:34:03 <Peaker> @type mande
02:34:05 <lambdabot> Not in scope: `mande'
02:34:06 <Peaker> @type mandel
02:34:08 <lambdabot> forall a. (RealFloat a) => Complex a -> Int
02:34:25 <pumpkin_> it should probably return something normalized from 0 to 1
02:34:27 <vixey> I kind of with you wrote \z -> z^2 + c though :(
02:34:31 <vixey> wish*
02:34:58 <pumpkin_> @let mandel c = (length . takeWhile ((< 2) . magnitude) $ take 100 . iterate (\z -> z^2 + c) $ (0 :+ 0)) / 100.0
02:35:00 <lambdabot>  <local>:12:102:
02:35:00 <Twey> ((^2) . (+c))!  ((^2) . (+c))!
02:35:00 <lambdabot>      No instance for (Fractional Int)
02:35:00 <lambdabot>        arising from th...
02:35:13 <pumpkin_> @let mandel c = (fromIntegral . length . takeWhile ((< 2) . magnitude) $ take 100 . iterate (\z -> z^2 + c) $ (0 :+ 0)) / 100.0
02:35:14 <lambdabot>  <local>:12:117:
02:35:14 <lambdabot>      No instance for (Fractional Int)
02:35:14 <lambdabot>        arising from th...
02:35:17 <pumpkin_> :(
02:35:22 <vixey> @undef
02:35:28 <pumpkin_> @undef mandel
02:35:35 <pumpkin_> @let mandel c = (fromIntegral . length . takeWhile ((< 2) . magnitude) $ take 100 . iterate (\z -> z^2 + c) $ (0 :+ 0)) / 100.0
02:35:36 <lambdabot>  Defined.
02:35:40 <pumpkin_> there :)
02:35:48 <pumpkin_> mandel (1 + i)
02:35:50 <pumpkin_> > mandel (1 + i)
02:35:52 <lambdabot>   Couldn't match expected type `Complex a'
02:35:54 <vixey> > let i = sqrt (-1) :: Complex CReal in mandel (1 + i)
02:35:56 <lambdabot>   2.0e-2
02:36:03 <vixey> > let i = sqrt (-1) :: Complex CReal in mandel i
02:36:18 <lambdabot>   thread killed
02:36:20 <vixey> > let i = sqrt (-1) :: Complex Float in mandel i
02:36:21 <pumpkin_> aw :(
02:36:23 <lambdabot>   1.0
02:36:27 <vixey> :P
02:36:52 <pumpkin_> now just imagine computing it for a nice fullscreen image :P
02:36:54 <vixey> > pi :: Float
02:36:57 <lambdabot>   3.1415927
02:36:57 <vixey> > pi :: CReal
02:37:00 <pumpkin_> with this beautifully efficient algorithm
02:37:00 <lambdabot>   3.1415926535897932384626433832795028841972
02:37:08 <vixey> this is why it wasn't working
02:37:13 <Peaker> @src magnitude
02:37:14 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:37:16 <pumpkin_> yeah
02:37:28 <vixey> Actually there are more interesting algorithms
02:37:43 <vixey> (for approximating mandelbrot)
02:37:44 <pumpkin_> (I was being sarcastic :P)
02:38:00 <Peaker> have you seen xaos?
02:38:41 <pumpkin_> nope, but I bet mine's better!
02:38:51 <ksf> mandelbrots are boring, the real fun begins when you're doing eg. tree geometries and textures.
02:38:53 <pumpkin_> (it looks cool)
02:39:04 <pumpkin_> ksf: way to burst my bubble :P
02:39:40 <vixey> ksf, notso
02:40:26 <Peaker> pumpkin_: the xaos tutorial is pretty awesome
02:40:27 <ksf> then you can do stuff like http://en.wikipedia.org/wiki/.kkrieger
02:40:29 <lambdabot> Title: .kkrieger - Wikipedia, the free encyclopedia
02:40:35 <ksf> which is most impressive.
02:42:09 <pumpkin_> this is a pretty neat plain ol' complex fractal
02:42:10 <pumpkin_> http://en.wikipedia.org/wiki/Image:Burning_Ship_144x.jpg
02:42:29 <pumpkin_> Peaker: cool, I'll take a look
02:53:13 <evident> Hi guys and gals
02:53:35 <vixey> hi
02:53:55 <evident> can anyone help me with working with Trees?
02:54:16 <benny99> hi
02:54:17 <Peaker> which trees?
02:54:18 <vixey> I might be able to
02:54:23 <evident> http://www.mibbit.com/pb/SDyvTB
02:54:24 <lambdabot> Title: Mibbit: PasteBin
02:54:25 <vixey> I have written 2 programs that use trees recently :)
02:54:31 <evident> :)
02:54:40 <evident> well... i think the problem is quite simple
02:54:46 <benny99> I'm just trying to write a function that deletes an element in a tree :/
02:54:52 <Twey> Coconut trees?
02:55:01 <evident> i wrote a function "insertSorted" that inserts an element in a binary tree
02:55:12 <evident> and compares with the Node...
02:55:12 <pumpkin_> I only do oak
02:55:25 <evident> if smaller, go to left Node, bigger, go to right node, if equal, do nothing
02:55:45 <benny99> evident, case compare x n of LT -> ...  ?
02:56:00 <evident> ?
02:56:16 <evident> the problem is with the second function
02:56:26 <pumpkin_> time for bed, or I'll turn into a pumpkin
02:56:32 <evident> i want to insert a list of elements into the sorted tree
02:56:48 <vixey> evident, so you've got already a function with type  a -> TreeOrd a -> TreeOrd a
02:57:00 <vixey> evident, and you want to create from it a function of type  [a] -> TreeOrd a -> TreeOrd a
02:57:06 <evident> the first way (which is now a commentary "--" works, but i wanted to do it with "map"
02:57:07 <benny99> foo (Node x left right) n = case compare x n of ; GT -> doSomething left ; EQ -> doNothing ; LT -> doSomething right <-- ?
02:57:13 <evident> right
02:57:14 <vixey> evident, so an even simpler problem to solve first might be,
02:57:28 <vixey> evident, write a function with type  (a -> b -> b) -> ([a] -> b -> b)
02:57:55 <vixey> evident, just jumps out at me, It looks almost exactly like foldr
02:57:57 <vixey> :t foldr
02:57:59 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:58:10 <evident> yeah that might be possible
02:58:20 <evident> but i have to it for the university...
02:58:26 <evident> it's an exercise
02:58:27 <benny99> evident, (listen to vixey :p)
02:58:28 <vixey> evident, so perhaps you can write insertListSorted = foldr ... insertSorted ...
02:58:58 <vixey> or something like that
02:59:29 <evident> hmm wait a sec pls
03:00:14 <evident> well and I cant solve it with the map function?
03:00:38 <evident> which applies the function "insertSorted" to each element of the list, one by one?
03:00:49 <vixey> evident, seems like you already tried and got a type error with not -- not sure why you'd want to continue down that dead end instead of using a fold
03:00:58 <vixey> with map*
03:01:46 <vixey> evident, (map is a specialization of foldr, and it's too specialized so that it's actually useless for this problem0
03:01:53 <evident> ahh ok
03:02:10 <vixey> evident, if you didn't meet foldr before I can explain what it does if you like
03:02:14 <evident> could you maybe show me how the foldr works? I dont quite get it yet
03:02:18 <vixey> yeah sure :)
03:02:20 <vixey> so. .
03:02:21 <evident> would be great
03:02:21 <evident> :)
03:02:39 <vixey> you know lists, [a,b,c] =  a : b : c : []
03:02:43 <vixey> ?
03:02:50 <evident> yeah
03:03:15 <evident> (one of the first thing we learned) :D
03:03:30 <vixey> the function (foldr (&) o) is like pulling a tablecloth out from a table quickly
03:03:50 <vixey> a : b : c : [] ---> a & b & c & o
03:04:01 <evident> ok
03:04:10 <vixey> it replaces the cons and nil constructors with functions/values you supply
03:04:24 <vixey> > foldr (:) [] [x,y,z]
03:04:25 <lambdabot>   [x,y,z]
03:04:34 <vixey> > foldr (const (+1)) 0 [x,y,z]
03:04:36 <lambdabot>   3
03:04:42 <vixey> > foldr (:) [a,b,c] [x,y,z]
03:04:43 <lambdabot>   [x,y,z,a,b,c]
03:04:53 <vixey> > foldr (+) 0 [x,y,z]
03:04:55 <lambdabot>   x + (y + (z + 0))
03:05:11 <evident> ahh ok
03:05:20 <vixey> > let cons 2 ys = ys ; cons x ys = x : ys in foldr cons [] [3,2,1,2,3]
03:05:21 <lambdabot>   [3,1,3]
03:05:41 <benny99> > foldr (/) 1 [2,3]
03:05:43 <lambdabot>   0.6666666666666666
03:06:56 <evident> well that makes sense to me
03:07:32 <vixey> there is a version of foldr for any data type by the way
03:07:52 <vixey> foldBool true false True = true ; foldBool true false False = false -- an example
03:07:55 <vixey> :t maybe
03:07:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:08:00 <vixey> :t either
03:08:02 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
03:08:03 <vixey> :t foldr
03:08:05 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:08:23 <evident> ok but how can I use the function "insertSorted" insead of those like (+) or (/) ?
03:09:10 <vixey> evident, well since you get foldr, might make a lot more sense reading what I wrote earlier from " so a simpler problem to solve first "
03:09:19 <vixey> (compared to before)
03:09:43 <vixey> if you compare the shape of the type, it's almost exactly right already
03:10:12 <evident> ahhh ok
03:10:43 <benny99> vixey, shouldn't he use foldl ?
03:11:36 <hackage> Uploaded to hackage: HTTP 3001.1.5
03:12:22 <vixey> :t foldl
03:12:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:12:32 <vixey> benny99: no
03:12:44 <vixey> benny99: well.. you could
03:13:01 <benny99> vixey, foldl (\x y -> insert x y) someTree [someElems] ?
03:13:31 <vixey> dunno what you are asking now
03:13:56 <vixey> you can eta-reduce  (\x y -> insert x y)  into just  insert
03:14:14 <Saizan> ?src sortBy
03:14:15 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
03:16:22 <Saizan> foldl might use less stack?
03:16:53 <Saizan> with foldr you've to traverse the whole list of elements to insert before you can look at the first element of the result anyway
03:33:57 <vixey> What is the name of  to e = f -> from f = e ?
03:34:25 <benny99> vixey, ?
03:34:54 <vixey> I hope you're not suggesting I call it "?"
03:35:09 * Twey laughs.
03:35:10 <benny99> vixey, no :p,  I don't get your question
03:35:27 <vegai> I might call that '?' quite easily
03:35:42 <benny99> why not
03:36:06 <Twey> Is it allowed?
03:36:21 <Twey> > let (?) = (+) in 3 ? 5
03:36:23 <lambdabot>   8
03:36:32 <benny99> perfect.
03:36:32 <Twey> Huh, I felt it would be reserved for some reason.
03:37:09 * Twey feels like whimsically naming every operator from now on nothing but ?, ??, ???, &c.
03:38:47 <Raevel> let's!
03:38:54 <benny99> :D
03:39:16 <int-e> > let (|) = (+); (!) = (-) in 3 | (5 ! 2)
03:39:17 <lambdabot>   <no location info>: parse error on input `|'
03:39:47 <int-e> > let (||) = (+); (|!) = (-) in 3 || (5 |! 2)
03:39:49 <lambdabot>   6
03:40:11 <Saizan> Twey: http://www.haskell.org/haskellwiki/Obfuscation
03:40:12 <lambdabot> Title: Obfuscation - HaskellWiki
03:40:20 <int-e> what Saizan said.
03:40:36 <Twey> Heh
03:40:43 <Twey> Woah!
03:40:45 <benny99> :)
03:40:56 <Twey> Heh, I don't remember this one
03:42:52 <blueonyx> how can i adjust the second line in http://hpaste.org/12517 to return a Maybe a?
03:43:26 <blueonyx> so that del either return Nothing if x is not in the list or the list without x otherwise
03:43:33 <vixey> > liftA2 (:) Nothing Nothing
03:43:34 <benny99> > let ($) = (\x -> 0) in ($) 1000 -- is it possible to get the same result with just '1000 $' ? (Result is '0')
03:43:35 <lambdabot>   Nothing
03:43:36 <lambdabot>   0
03:43:41 <vixey> > liftA2 (:) (Just 'f') Nothing
03:43:43 <lambdabot>   Nothing
03:43:46 <vixey> > liftA2 (:) (Just 'f') (Just "oo")
03:43:47 <lambdabot>   Just "foo"
03:44:05 <Twey> blueonyx: Just xs, (Just x') >>= (: (del x xs))
03:44:06 <vixey> > let ($) = (\x -> 0) in (1000$)
03:44:08 <lambdabot>   0
03:44:15 <blueonyx> ui this lifting thingy :(
03:44:21 <Twey> Er, return .
03:44:30 <benny99> vixey, sweet :)
03:44:36 <vixey> blueonyx, why sad face
03:44:39 <Twey> @src liftA2
03:44:40 <lambdabot> liftA2 f a b = f <$> a <*> b
03:44:50 <Twey> @src liftA
03:44:50 <lambdabot> liftA f a = pure f <*> a
03:45:02 <Twey> Bah, they're not really in simple terms :-P
03:45:34 <benny99> @src <$>
03:45:35 <lambdabot> f <$> a = fmap f a
03:45:41 <benny99> @src <*>
03:45:41 <blueonyx> vixey: havent reached this state of haskell knowledge
03:45:41 <lambdabot> Source not found. Take a stress pill and think things over.
03:45:52 <vixey> blueonyx, well it is time!
03:46:29 <blueonyx> yea im on it
03:47:35 <Saizan> blueonyx: in simple terms http://hpaste.org/12517#a1
03:48:31 <blueonyx> oh thanks :)
03:49:50 <vfgf> im doing a new graph library
03:50:18 <vfgf> someone gotta fix the puke that is haskells interface to datastructures
03:50:18 <blueonyx> o yea
03:50:47 <Kerris7> could somebody please tell me the recommended way to install Haskell on OS X, Fink, Macports, or the binary from Haskell.org?
03:51:02 <Kerris7> This was so much simple on Ubuntu :\
03:51:06 <Kerris7> simpler*
03:51:06 <blueonyx> vfgf: how about FGL?
03:52:18 <Saizan> Kerris7: from reading an answer to a similar question here: binary from haskell.org with libedit, libgmp from macports
03:52:39 <Kerris7> thanks Saizan
03:55:12 <Kerris7> strange, my copy of macports doesnt seem to have libgmp available
03:56:52 <Kerris7> I think it's gmp instead of libgmp, could anybody please give me a confirm/deny on that?
03:58:00 <Peaker> @type liftA
03:58:01 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
03:58:06 <Peaker> @type fmap
03:58:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:58:10 <Saizan> Kerris7: sounds right
03:58:16 <Peaker> given all Applicatives are Functors, what's liftA useful for?
03:58:19 <Kerris7> thanks Saizan
03:58:51 <Saizan> Peaker: it's the proof of that claim :)
03:59:21 <Peaker> Saizan: why pollute the namespace though? :)
03:59:46 <Saizan> consistency with liftA2,liftA3 ...
03:59:55 <Peaker> liftM too I guess
04:00:05 <Saizan> yeah
04:02:29 <chrisdone> anyone know of some kind of standalone GHC? I'd like to run GHC scripts on a shared server. I can upload and run x86 binaries, but installing all of GHC's dependancies is probably going to take a long time
04:04:03 <ksf> chrisdone, compile it statically.
04:04:42 <ksf> dunno if it's build system supports that off-the-shelf, though.
04:04:43 <Saizan> or compile what you were going to compile with it statically
04:05:11 <chrisdone> ah, good idea
04:05:54 * ksf just noticed that it's and its work differently from say foos and foo's.
04:07:00 <chrisdone> his, hers, its. it is, it has. many foos, many its
04:07:16 <mmorrow> i just finished some code that uses TH to get the (transitive closure of) the type dependency graph for a given datatype, then write it to .dot for graphviz and the results i find pleasingly pretty:
04:07:19 <mmorrow> http://moonpatio.com/repos/tycondepg/png/Tree.dot.png
04:07:24 <mmorrow> http://moonpatio.com/repos/tycondepg/png/Graph.dot.png
04:07:30 <mmorrow> http://moonpatio.com/repos/tycondepg/png/Type.dot.png
04:07:35 <mmorrow> http://moonpatio.com/repos/tycondepg/png/Pat.dot.png
04:07:48 <mmorrow> the rest in there are starting to get on the huge side..
04:08:20 <mmorrow> (and i ran those .dot's though tred first, which gives you the transitive /reduction/ of a .dot graph)
04:08:35 <mmorrow> tred makes stuff less cluttered
04:08:36 <ksf> exp is cool, though.
04:08:58 <mmorrow> totally
04:09:20 <mmorrow> stuff starts to get interesting when the cycles start appearing..
04:10:23 <ksf> 3d and zoomable would be cool.
04:10:25 <mmorrow> chrisdone: yeah, i managed to get ghc-6.10 built on this hosted webserver i've got, but it wasn't exactly "painless"
04:10:38 <ksf> or even 4d in some way, folding details in and out.
04:10:43 <vixey> mmorrow, did  data Graph a = a :-->: [Graph a]  (modulo isomorphism) show up anywhere in your code?
04:10:58 <mmorrow> ksf: yeah. i'm using this one prog called "gliv" which is an opengl image viewer. it's nice
04:11:10 <ksf> (...)
04:11:29 <mmorrow> vixey: erm, that's Data.Tree i believe
04:11:31 <ksf> gliv can do perspectives?
04:12:09 <mmorrow> hmm, i can zoom and rotate the image smoothly, but i'm not sure exactly how you mean perspectives
04:12:14 <mmorrow> s/i/it/
04:12:27 <vixey> mmorrow, aww I thought I'd invented it, oh well
04:12:33 <mmorrow> vixey: heh
04:12:56 <ksf> well, not using graphviz but doing a 3d view in gl.
04:13:01 <mmorrow> ksf: that'd be way cool if there was some nice graph viewing prog
04:13:09 <mmorrow> yeah, totally. do you know of any?
04:13:11 <vixey> I got a nice one liner for it
04:13:20 <mmorrow> vixey: do tell :)
04:15:01 <ksf> I only know that it's the only way visual programming will ever do anything else but fail.
04:20:34 <Peaker> ksf: what do you mean by "visual programming"?
04:21:05 <Peaker> programming is already visual, it just happens to use a weird/weak visualization medium :-)
04:21:38 <kig> someone port my C# file manager to haskell so that i don't have to tolerate mono's 200 ms startup time :P
04:24:53 <smtms> kig, pre-load your C# file manager when the computer starts
04:26:34 <kig> smtms: yeah. need to figure out a way to put it in the panel
04:28:40 <ksf> well, tracing at full speed would kinda look like a recording of a decent level played by a pro.
04:28:50 <ksf> *descent
04:29:33 <ksf> do you know drscheme and its return-value feature?
04:29:58 <ksf> you hover the mouse over a symbol and arrows describing the way back are displayed.
04:30:19 <ksf> similar from a definition to its usages and from a usage back to the definition.
04:30:31 <ksf> imagine the whole in 3d and with much more steroids.
04:30:48 <mmorrow> "i just finished some code that uses TH to get the (transitive closure of) the type..."
04:30:54 <mmorrow> s/transitive closure/reachable/
04:31:32 <ksf> s/reachable/reachable closure/
04:32:11 <athos> hi
04:32:19 <vixey> hi
04:32:22 <opqdonut> lo
04:46:54 <Aser> hello. is there an easy and short possibility to ask if a list only contains of (any number of) empty lists?
04:47:09 <vixey> :t any null
04:47:10 <lambdabot> forall a. [[a]] -> Bool
04:49:07 <Aser> well this shows if any is null - but i want to know if every element is an empty list - i think the only way is a recursion, right?
04:49:36 <vixey> :t all null
04:49:37 <lambdabot> forall a. [[a]] -> Bool
04:51:58 <Aser> thanks
04:52:27 <Saizan> ?type null . concat
04:52:29 <lambdabot> forall a. [[a]] -> Bool
04:53:11 <vixey> :t (== 0) . sum . map length
04:53:13 <lambdabot> forall a. [[a]] -> Bool
04:55:19 <scanz> hey
05:01:24 <pierre-> hello
05:01:28 <scanz> i have to do a simple project for university
05:01:50 <pierre-> how can i catch "non-exhaustive patterns in lambda" exception?
05:02:21 <Stephan202> pierre-: what do you mean by "catching"?
05:02:26 <Saizan> pierre-: you can use Control.Exception.catch from IO
05:02:48 <Stephan202> ah, like that. sorry :)
05:02:55 <Lemmih> pierre-: Usually you don't want to cause them in the first place.
05:02:56 <lambdabot> Lemmih: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:02:58 <Saizan> pierre-: but it would be best to make the lambda total
05:03:03 <Peaker> is it good practice to signal errors with non-exhaustive pattern matches?
05:03:06 <Twey> @src catch
05:03:06 <lambdabot> catch m k = catchException m handler where handler (IOException err) = k err
05:03:09 <Stephan202> pierre-: you can ask ghc to print a compile warning
05:03:20 <scanz> we  have to write a simple scanner and a parser for a very basic language.. all special characters like brackets and operators have to be replaced by predefined symbols
05:03:22 <Twey> @src Control.Exception.catch
05:03:23 <lambdabot> Source not found.
05:03:52 <scanz> at first i work on the scanner
05:03:54 <Saizan> Peaker: no. pure exceptions should be avoided
05:04:13 <scanz> http://hpaste.org/12519 this source code which has to be scanned
05:04:38 <scanz> http://hpaste.org/12518 this is my scanner
05:04:39 <pierre-> i'm trying to use "handle (\(PatternMatchFail s) -> return ("e", s)) parseCmd" but the exception isn't caught
05:05:38 <pierre-> same result with IOException. Could I just catch anything?
05:05:40 <Saizan> pierre-: you've to make sure the thunk is evaluated before handle returns
05:06:26 <killerstorm> hi. i'm trying to write a function that converts Tree into a tree of tuples like ((1, 2), (3,4)). here's a code: http://hpaste.org/1252 ,haskell complains about infinite type on it. i vaguely understand what's wrong with it, but how do you do such stuff and is it possible at all?
05:06:29 <Saizan> using the evaluate function and adding strictness as needed
05:06:30 <scanz> the problem is that one of the functions removes the first character of all identifiers (Idf)
05:06:32 <pierre-> Saizan, parseCmd is "evaluate $ pureParseCmd" -- is that enough?
05:06:49 <scanz> some ideas?
05:06:53 <killerstorm> oops wrong link. here it is http://hpaste.org/12520
05:07:00 <int-e> pierre-: wouldn't fixing the lambda in question be much simpler in the end?
05:07:30 <Saizan> pierre-: evaluate will only evaluate the outermost constructor, the error is probably deeper
05:07:49 <int-e> @index rnf
05:07:50 <lambdabot> Control.Parallel.Strategies
05:08:18 <pierre-> int-e, yes, but i'm just wondering is it possible to parse this way :-)
05:08:25 <mapreduce> killerstorm: What type do you want tuplify to have?
05:08:27 <vixey> killerstorm, impossble in haskell
05:09:05 <blueonyx> mapreduce on haskell?
05:09:15 <mapreduce> blueonyx: Why not?
05:09:46 <blueonyx> but parallized about many machines?
05:10:06 <mapreduce> I am logged in to 2 right now.
05:10:12 <blueonyx> nah xD
05:11:43 <vixey> killerstorm, http://hpaste.org/12520#a1 oops
05:11:44 <pierre-> killerstorm, you'll need to define "nil" value
05:12:17 <vixey> *Main> tuplify (Branch (Branch (Leaf 1) (Leaf 2)) (Leaf 3))
05:12:17 <vixey> ((1,2),3)
05:12:39 <pierre-> killerstorm, like this: tuplify (Leaf a) = (0,0)
05:12:40 <chrisdone> ooo
05:13:18 <int-e> hmm, tuplify (Lead ((1,2),3))
05:13:22 <int-e> *Leaf
05:13:57 <chrisdone> anyone got a fixed hs-mysql for ghc6.10?
05:17:35 <killerstorm> aha, so this is only possible with extensions as i understand? i didn't thought that problem is so hardcore.
05:18:30 <vixey> killerstorm, the shape of the result type would be computed from the shape of the tree -- so you have to pull some trick in haskell
05:19:29 <killerstorm> ok, i've got it to some extent, thanks
05:19:59 <scanz> question + code --> http://hpaste.org/12522
05:22:09 <mbz> scanz, what should dropUntilSpace do?
05:22:24 <EvilTerran> scanz, i'm thinking "mgpl_scanner (_:str) = scanIdf str" looks a bit odd
05:23:52 <mbz> scanz, dropUntilSpace = dropWhile isSpace
05:24:12 <EvilTerran> mbz, except it's dropWhile (not.isSpace)
05:24:13 <scanz> ah cool.. thats what i nedd
05:24:15 <scanz> i will try
05:24:38 <scanz> yepp,, second one
05:24:39 <EvilTerran> or dropWhile (not.(==' ')), even, seeing as isSpace is more general
05:24:50 <scanz> dropp all chars until its space
05:24:54 <EvilTerran> > filter isSpace [minBound ..]
05:24:56 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
05:25:13 <scanz> then return to the scanner
05:25:26 <chrisdone> EvilTerran: interesting. quite a lot
05:25:49 <chrisdone> > length $ filter isSpace [minBound ..]
05:25:50 <EvilTerran> chrisdone, yeah, i wasn't expecting all those high-unicode ones either
05:25:51 <lambdabot>   24
05:26:05 <Lemmih> scanz: Check out 'break isSpace'.
05:27:28 <Lemmih> > break (==' ') "identi fier"
05:27:30 <lambdabot>   ("identi"," fier")
05:28:32 <Peaker> why isn't "break" generalized to split, like the Pythonic split?
05:28:51 <vixey> ask gwern
05:28:52 <vixey> :D
05:29:05 <Peaker> gwern: you are hereby asked
05:29:27 <Peaker> working with strings in Haskell is not fun :-(
05:29:33 <dancor> isn't that like asking why (++) exists instead of just concat?
05:29:49 <dancor> but 'breaks' was one of the first things i wrote
05:29:56 <vixey> dancor, well backwards
05:30:09 <vixey> Peaker, use Parsec
05:30:10 <dancor> also i made breakMb :: (a -> Bool) -> Maybe ([a], [a])
05:30:14 <Peaker> dancor: I don't mind break existing, but the stdlib should have   join, split, replace, etc
05:30:23 <dancor> Peaker: i agree
05:31:29 <EvilTerran> vixey, that sounds like it might be good advice for scanz, too
05:31:32 <dancor> @let breaks f l = if null b then [a] else (a:breaks f (drop 1 b)) where (a, b) = break f l
05:31:33 <lambdabot>  Defined.
05:31:46 <dancor> > breaks (== ' ') "a b cd e f "
05:31:47 <lambdabot>   ["a","b","cd","e","f",""]
05:32:02 <vixey> EvilTerran, I looked at that paste and I wasn't even sure that it's haskell ...
05:32:07 <EvilTerran> > breaks (== ' ') "  foo  bar  "
05:32:09 <lambdabot>   ["","","foo","","bar","",""]
05:32:36 <EvilTerran> vixey, it isn't, after the line "file which has to be scanned:
05:32:36 <EvilTerran> "
05:33:03 <Peaker> vixey, EvilTerran: I haven't used Parsec, but I don't like the idea of monadic (Turing Complete) parsers for parsing very simple grammars
05:33:21 <dancor> Peaker: but you do get really good error messages
05:33:36 <dancor> and parsec is a joy to use
05:33:46 <chrisdone> Peaker: what about Frisby?
05:33:55 <chrisdone> that's great for simple grammars, and it's fast
05:34:16 <Peaker> chrisdone: Looking...
05:34:29 <idnar> Peaker: from what I can gather, it's hard to agree on semantics
05:34:45 <idnar> Peaker: for example, "split" is also a generalisation of words / lines
05:34:59 <idnar> Peaker: but none of those works quite the same way
05:35:10 <Peaker> chrisdone: Sounds nice, but I'd like to see examples
05:35:14 <chrisdone> kind of crap for big grammars, have to use 'mdo' and it gives huge compile errors in GHC.. like for parsing the Lojban morphology. Parsec was easier but awfully slow
05:35:15 <EvilTerran> > words "foo\n\nbar"
05:35:17 <lambdabot>   ["foo","bar"]
05:35:19 <chrisdone> let me see
05:35:20 <EvilTerran> > lines "foo\n\nbar"
05:35:22 <lambdabot>   ["foo","","bar"]
05:35:23 <vixey> chrisdone, and GHC segfaults hen you try to compile
05:36:00 <chrisdone> EvilTerran: http://repetae.net/computer/frisby/#3
05:36:05 <chrisdone> vixey: haha, yes
05:36:06 <lambdabot> Title: Text.Parsers.Frisby
05:36:27 <EvilTerran> er, what?
05:36:45 <chrisdone> oh, sorry. I meant Peaker
05:37:04 <EvilTerran> "??? a => Functor (PM s a)"?
05:37:42 <Kerris7> ah, got ghc working on my OS X
05:37:57 <Peaker> chrisdone: I forget what mdo was
05:38:13 <Kerris7> I guess it was a good decision to keep another computer around to run Windows and Linux
05:39:18 <chrisdone> Peaker: recursive `do'
05:39:21 <athos> :t (>>=)
05:39:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:40:13 <chrisdone> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#mdo-notation
05:40:15 <lambdabot> Title: 8.3.�Syntactic extensions, http://tinyurl.com/y6v6by
05:40:23 <solrize_> frisby looks interesting, is it fast?
05:41:00 <EvilTerran> , mdo x <- return (1:x); Just x
05:41:02 <chrisdone> so here was something I was working on for the Lojban morphology ages ago in Frisby, http://paste.lisp.org/display/66078,1 and then in Parsec: http://paste.lisp.org/display/66084
05:41:07 <lunabot>  Just [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:41:16 <chrisdone> I had to stop using Frisby because GHC's mdo didn't support any more statements
05:41:38 <chrisdone> solrize_: it's fast, yes
05:42:02 <Peaker> @src mfix
05:42:03 <lambdabot> Source not found. Are you on drugs?
05:42:13 <EvilTerran> ?src MonadFix
05:42:14 <lambdabot> class (Monad m) => MonadFix m where
05:42:14 <lambdabot>     mfix :: (a -> m a) -> m a
05:43:00 <solrize_> cool
05:43:25 * EvilTerran really isn't confident about the semantics of mfix
05:43:58 <EvilTerran> ?instances MonadFix
05:43:59 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:44:06 <EvilTerran> especially as there's an IO instance
05:44:10 <Peaker> chrisdone: why are things wrapped in "newrule"?
05:47:18 <chrisdone> Peaker: newRule takes a `P s a' and produces a `PM s (P s a)', I believe it was the way to restrict compilation of the parser so that you can't create them on the fly inside the parser, like Parsec
05:47:32 <chrisdone> “runPeg :: (forall s . PM s (P s a)) -> String -> a   -- run a PEG grammar. takes the rank-2 argument in order to ensure a rule created in one PM session isn't returned and used in another PEG parser. ”
05:48:13 <EvilTerran> ah, that's a trick like what ST uses
05:48:16 <Peaker> why not replace the monadic interface with arrow/applicative?
05:50:00 <chrisdone> hmm, I don't know
05:50:53 <chrisdone> I'm not sure the creation of the parser is a monadic kind of computation
05:51:19 <Peaker> its not monadic, because you cannot take a Parser result of a parse, and continue to parse with it
05:54:06 <chrisdone> oh, sorry, I was wondering why there was an instance of Monad. 'tis for the recursive do
05:54:32 <chrisdone> how might arrows be used with it?
05:54:44 <idnar> EvilTerran: wouldn't mfix for IO basically just be fix?
05:55:19 <Peaker> @src IO mfix
05:55:20 <lambdabot> mfix = fixIO
05:55:37 <idnar> @src fixIO
05:55:37 <lambdabot> Source not found.
05:55:41 <idnar> aww :P
05:56:46 <EvilTerran> ?type fixIO
05:56:47 <lambdabot> Not in scope: `fixIO'
05:56:51 <EvilTerran> ?hoogle fixIO
05:56:51 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
05:56:55 <idnar> fixIO :: (a -> IO a) -> IO a
05:57:00 <EvilTerran> not quite fix
05:57:16 <EvilTerran> what happens to the side-effects?
05:57:43 <idnar> they get performed "in order"
05:58:04 <scook0> doesn't the function just get a thunk pointing to what its output is going to be?
05:58:13 <Peaker> @package MonadFix
05:58:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadFix
05:58:18 <Peaker> @index MonadFix
05:58:19 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
05:58:30 <scook0> so as long as it doesn't force the thunk, there's no potential for weirdness
05:58:52 <scook0> wish I could remember for certain if that's how it works
05:59:16 <Peaker> I tried "mfix" on   \s -> putStrLn s >> getLine
05:59:20 <Peaker> it failed
05:59:34 <scook0> did it <<loop>>?
05:59:38 <Peaker> yeah
05:59:46 <scook0> yeah, that's what I suspected
05:59:57 <Peaker> what does it do?
06:00:15 <Peaker> oh, I understand
06:00:42 <scook0> the function you're fixing gets access to its own output
06:01:02 <scook0> but if it actually tries to evaluate that thunk, the runtime says "hey that's impossible"
06:01:48 <chrisdone> preflex: be poppavic
06:01:49 <preflex>  I already know you and I can commo, and you MIGHT commo with my sibs - and (trust me) they are far more strange - to ##C
06:01:59 <idnar> mfix $ \_ -> print "foo" just prints foo
06:03:32 <jkff> Hi people. Any category theory gurus here? :) Could anyone tell me the definition of a coherent isomorphism? Unfortunately, Google yields only pages where the concept is used, not defined.
06:03:32 <idnar> mfix :: (a -> m a) -> m a
06:03:34 <idnar> The fixed point of a monadic computation. mfix f executes the action f only once, with the eventual output fed back as the input. Hence f should not be strict, for then mfix f would diverge.
06:03:47 <idnar> hmm
06:06:37 <dancor> does the currently-running lambdabot use ghc 6.10.1?
06:06:47 <dancor> bc i can't get 'hint' to install on 6.10.1
06:08:09 <tomh> is an Applicative also a monad?
06:08:57 <dancor> tomh: all Monad's are Applicative's
06:09:36 <jkff> Ouch.. Even Mac Lane doesn't have definition of coherent isomorphisms :-| Maybe anyone knows of a really good source for definitions in category theory?
06:09:53 <dancor> tomh: Array is an Applicative but not a Monad
06:10:02 <idnar> dancor: no apostrophes, please :(
06:10:25 * EvilTerran suspects fixIO uses unsafeInterleaveIO under the hood
06:10:46 <dancor> idnar: i don"t like commas or frowney faces
06:11:04 <Japsu> @source fixIO
06:11:04 <lambdabot> fixIO not available
06:11:08 <Japsu> @src fixIO
06:11:08 <lambdabot> Source not found.
06:11:16 <Japsu> @src (IO a) mfix
06:11:16 <lambdabot> Source not found. stty: unknown mode: doofus
06:11:22 <Japsu> bah
06:11:23 <chrisdone> "It's so cold that I have to compile ghc to heat the room.", haha
06:11:52 <EvilTerran> Japsu, we've had ?src IO mfix = fixIO already, anyway
06:14:24 <Japsu> oh, right
06:17:10 <chrisdone> @hoogle throwDyn
06:17:10 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
06:17:11 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
06:17:14 <tomh> dancor: ok thanks for the clarification
06:17:16 <athos>  :t liftM
06:17:25 <Peaker> why is the Haskell convention to give names to functions, per-method, per-class-per-instance, instead of just re-using the method name (per-class, per-method) ?
06:17:42 <Peaker> athos: its the same as fmap, but for monads
06:18:52 <athos> :t liftM
06:18:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:18:53 <athos> Peaker: ah ok
06:18:59 <dancor> Peaker: are you asking why you can't have like  data Foo = Foo {boop :: Int} and data Bar = Bar {boop :: Int}  +
06:19:02 <dancor> ?
06:19:27 <dancor> (and instead you would have to do like fooBoop and barBoop)
06:19:43 <dancor> (or separate Modules)
06:20:21 <Peaker> dancor: nope, I'm asking why "fixIO" needs a name, beyond:  mfix :: IO a
06:20:23 <EvilTerran> idnar, Peaker, scook0, Japsu, etc: http://hpaste.org/12523
06:20:34 <Peaker> dancor: or "map", beyond "fmap :: (a -> b) -> [a] -> [b]"
06:20:38 <athos> is [] (in cases of [a]) the return operator for the list monad?
06:20:52 <Peaker> athos: (:[]) is
06:20:59 <athos> ah yes
06:21:06 <Peaker> athos: its also spelled \x -> [x]   which is a bit more readable
06:21:13 <EvilTerran> athos, [] is the empty list; (:[]) is the function for creating a singleton list
06:21:14 <athos> of course :)
06:21:17 <scook0> makes sense
06:21:30 <EvilTerran> i tend to spell it "return", even in non-monadic contexts
06:21:32 <athos> :t (\x -> [x])
06:21:34 <lambdabot> forall t. t -> [t]
06:21:35 <scook0> but (:[]) is too awesome for you not to use it
06:21:35 <EvilTerran> (just to confuse everyone :P)
06:21:47 <athos> :D
06:22:02 <EvilTerran> > (:[ {- OM NOM NOM -} ]) x
06:22:04 <lambdabot>   [x]
06:22:10 <scook0> I use it enough that my brain recognises it as an idiom now
06:22:16 <dancor> Peaker: i think that is usually bc there is a more efficient implementation or the polymorphism is annoying (like runIO for run in HSH)
06:22:21 <scook0> my other fave operator is (.).(.)
06:22:33 <EvilTerran> ah, fmap fmap fmap!
06:22:42 <Peaker> dancor: a more efficient implementation? What do you mean, the exact same implementation will run by either name
06:22:49 <Peaker> dancor: HSH?
06:22:52 <ksf> @src List.return
06:22:53 <lambdabot> Source not found. My pet ferret can type better than you!
06:22:56 <ksf> @src return
06:22:57 <lambdabot> Source not found.
06:22:57 <EvilTerran> @src [] return
06:22:58 <lambdabot> return x    = [x]
06:22:58 <wjt> @src [] return
06:22:59 <lambdabot> return x    = [x]
06:23:00 <Peaker> dancor: if the polymorphism is "annoying", just specify which instance explicitly, in the type
06:23:06 <scook0> yeah, I find that quite amusing
06:23:21 <dancor> Peaker: re efficiency, well i was thinking like mapM_ vs mapM
06:23:22 <EvilTerran> ?type fmap fmap fmap
06:23:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
06:24:07 <Peaker> dancor: but there might be a difference between mapM_ and mapM, whereas  fmap with type-spec and map  should be completely equivalent?
06:24:13 <dancor> Peaker: HSH is a library for shell scripting.  run is polymorphic and often is a nuisance in one-off scripting so runIO is a less polymorphic variant
06:24:43 <dancor> Peaker: for one thing, ghc errors are less clear with fmap than map
06:24:49 * EvilTerran wants "_"s in type sigs
06:24:57 <EvilTerran> > mfix (...) :: IO _
06:24:58 <lambdabot>   <no location info>: parse error on input `_'
06:25:00 <Peaker> what about strictness in type-sigs?
06:25:02 <EvilTerran> heh
06:25:21 <Peaker> EvilTerran: isn't   IO ()    basically that?
06:25:38 <EvilTerran> i'm thinking _ ~~ (exists a. a)
06:25:56 <EvilTerran> "i'm not paying attention to this bit; work it out yourself"
06:26:32 <Peaker> EvilTerran: well, if no class contexts exist, its already pretty much this way, isn't it?
06:26:43 <EvilTerran> to get around either having to specify no type or all of a type
06:26:51 <scook0> partially-inferred types would be nice
06:26:52 <EvilTerran> (being the current arrangement)
06:27:08 <scook0> especially when doing hairy olegian type tricks
06:27:19 <EvilTerran> _ in types would let you only specify the parts the inferrer couldn't work out on its own, and let it do the bits you left as _s
06:27:30 <scook0> I hate being unable to supply type annotations
06:27:37 <Peaker> EvilTerran: oh, that indeed would be cool
06:28:02 <Peaker> EvilTerran: also a way to silence the -Wall wants you to specify all types...  blah :: _    (I explicitly don't specify it)
06:28:11 <athos> [1,2,3,4,5] >>= \a -> Just a
06:28:12 <EvilTerran> indeed :)
06:28:15 <athos> > [1,2,3,4,5] >>= \a -> Just a
06:28:16 <lambdabot>   Couldn't match expected type `[b]' against inferred type `Maybe t'
06:28:28 <athos> > [1,2,3,4,5] >>= \a -> (Just a):[]
06:28:30 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
06:28:48 <Peaker> > [1,2,3,4,5] >>= Just . return
06:28:50 <lambdabot>   Couldn't match expected type `[b]'
06:28:50 <EvilTerran> > Just <$> [1,2,3,4,5]
06:28:52 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
06:28:59 <Peaker> > [1,2,3,4,5] >>= return . Just
06:29:00 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
06:29:10 <scook0> Peaker: being able to silence no-annotation warnings would be particularly handy for TH
06:29:11 <Peaker> @type liftM
06:29:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:29:14 <Peaker> @src liftM
06:29:14 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:29:29 <Peaker> OR: liftM f m1 = m1 >>= (return . f)
06:29:34 <Stephan202> :t (<$>)
06:29:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:29:37 <Kerris7_> Yi hasn't moved towards 6.10?
06:29:41 <scanz> cya
06:29:45 <scook0> I find that when splicing TH into one of my modules, I have to either turn of no-annotation warnings, or spend ages getting TH to generate types
06:29:45 <athos> :D
06:30:00 <Peaker> it would be awesome if common patterns like that (>>= fmap . ..) were recognized by the code editor, which would suggest to you to generalize your code
06:30:12 <Peaker> (to use fmap, for example)
06:30:25 <scook0> a kind of in-line @pl
06:31:23 <Peaker> @pl \f x -> x >>= (fmap . f)
06:31:24 <lambdabot> (=<<) . (fmap .)
06:31:35 <Peaker> @pl \f x -> x >>= (return . f)
06:31:36 <lambdabot> fmap
06:31:38 <Peaker> ah, cool
06:32:10 <scook0> your editor could display big wavy lines under code that is insufficiently pointless
06:32:35 <Peaker> being points free is great, being more general than it currently is is even more awesome
06:32:36 <athos> ah i see, so the type of (>>=) simply means (according to the list example).. give me some list with some values of type, and give me a function that converts something of type a to something of type b and finally puts this into a list again, and then i'll return you the list
06:32:53 <athos> or am i getting something wrong?
06:33:13 <scook0> that's pretty much accurate
06:33:46 <scook0> "give me a funny A, and a thing to turn normal As into funny Bs, and I'll do the plumbing to give you a funny B"
06:33:52 <Kerris7_> could somebody please tell me the preferred way to get darcs working on OS X? is this it: http://exrae.com/darcs-2.1.2-i386-darwin.bz2 ?
06:34:55 <tibbe> hmm, array refuses to install form hackage
06:37:40 <athos> so >>= in terms of lists is just the same as map, isn't it?
06:37:49 <Philonous1> athos: concatMap
06:38:03 <Philonous1> Because after mapping it joins the result
06:38:09 <Philonous1> i.e. it concats it
06:38:24 <Philonous1> Generalls >== is the same as join.fmap
06:38:28 <Philonous1> generally*
06:38:59 <scook0> if by "generally" you mean in the mathematical sense of "always"
06:39:33 <scook0> (denotationally anyway; maybe there are performance differences)
06:40:05 <tomh> when you use deriving Show on a datatype it automatically instanciated it right?
06:40:41 <scook0> the compiler derives an instance of Show for that datatype, yes
06:40:42 <EvilTerran> tomh, yes, the "deriving" mechanism is intended to automate writing various common instances
06:42:00 <tomh> ok
06:42:05 <Stephan202> tomh: yes. note that all arguments to the constructors of tha datatype must be instances of Show
06:42:05 <tomh> any imports required?
06:42:08 <Stephan202> nope
06:42:41 <tomh> ah thanks, that was why the compiler was throwing some errors :)
06:42:54 <Stephan202> (:
06:44:08 <EvilTerran> "data Foo a b = Foo (a -> b) deriving Show" would be cheating :P
06:46:13 <Philonous> athos: You can think of the list monad as of a way to do nondeterministic programming. The "next" function operates on all the previous results and the new results are returned in a single list. Lazy evaluation then even gives you backtracking.
06:47:25 <EvilTerran> without lazy evaluation, it'd be keeping a list of all options at each step
06:49:52 <Kerris7_> uh, maybe getting darcs from macports after installing ghc from a pkg wasn't exactly the best idea :S
06:50:37 <Philonous> Though I think join on lists should then be nub.concat
06:51:00 <Peaker> Philonous: Eq a => context on list monads would make them quite a bit less useful..
06:51:20 <Philonous> Yeah, right.
06:51:40 <Philonous> Maybe this gives rise to another monad
06:53:55 <pfo> I'm having troubles installing cabal-install 0.6.0
06:54:22 <pfo> while bootstrapping i get "HTTP >=3000 && <3002, network >=1 && <3" deps missing
06:55:20 <pfo>  any solution?
06:55:48 <pfo> it's a fresh new install of ghc-6.8.2 and cabal-install-0.6.0
06:57:56 <maxote> what implementations are there similar to the theory of F-system?
07:00:41 --- mode: ChanServ set +b Smerdyakov!*@*
07:00:41 --- kick: Smerdyakov was kicked by ChanServ (Banned: don't*pick*on*newbies)
07:07:03 <twanvl> pfo: you first need to install the HTTP and network packages, these don't come with ghc
07:08:32 <Philonous> HTTP comes with the cabal-install bootstrapper
07:23:46 <hunter123> hi
07:25:13 <hunter123> i have a string like "123" and now i want to calculate with this number.. buts its a string. so i need to convert it to int.. how does it work?
07:25:42 <olsner> > read "123"
07:25:43 <lambdabot>   * Exception: Prelude.read: no parse
07:25:51 <olsner> > read "123" :: Int
07:25:52 <lambdabot>   123
07:25:55 <hunter123> that was easy.. thx
07:27:13 <jethr0_> ?t reads
07:27:14 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:27:20 <jethr0_> @type reads
07:27:22 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:27:40 <jethr0_> > reads "123" :: [(Int, String)]
07:27:42 <lambdabot>   [(123,"")]
07:28:08 <jethr0_> "read" does not fail very gracefully
07:28:25 <hunter123> read "123" works fine
07:28:26 <hunter123> :)
07:28:40 <jethr0_> > read "123a"
07:28:41 <lambdabot>   * Exception: Prelude.read: no parse
07:28:55 <hunter123> uh.. i really got the exception
07:28:57 <hunter123> damn
07:29:03 <jethr0_> it's easier to work with the output of "reads" (as above) than catching the exception
07:29:47 <tomh> hmm what does the <$> exactly do for an applicative?
07:30:07 <Peaker> tomh: (<$>) = fmap
07:30:23 <BONUS> <$> is for functors basically
07:30:33 <BONUS> but since all applicatives are functors, it works on them too
07:30:34 <jethr0_> > (+) <?> (Just 4)
07:30:35 <lambdabot>   Not in scope: `<?>'
07:30:35 <Peaker> tomh: and in Applicatives, fmap is just liftA, which is just   liftA f x = pure f <*> x
07:30:40 <jethr0_> > (+) <$> (Just 4)
07:30:41 <lambdabot>       Overlapping instances for Show (a -> a)
07:30:41 <lambdabot>        arising from a use of `s...
07:30:48 <Peaker> tomh: but you don't need liftA because Applicatives subclass Functors
07:30:55 <BONUS> > (+) <$> (Just 4) <*> (Just 10)
07:30:57 <lambdabot>   Just 14
07:30:58 <tomh> eh ok too much information :P
07:31:12 <jethr0_> i always confuse <*> and <$> ;(
07:31:21 <tomh> what does the <*> do?
07:31:41 <Peaker> tomh: if you consider a value of type ((Applicative f) => f a) to be a "box" containing the "a" value, then fmap on this "box" will generate a new box whose value will be mapped by the function
07:31:44 <Beelsebob> it applies all the things in the applicative on the left to all the things in the applicative on the right
07:31:59 <Beelsebob> > [f, g, h] <*> [x,y,z] :: [Expr]
07:32:01 <lambdabot>   [f x,f y,f z,g x,g y,g z,h x,h y,h z]
07:32:16 <BONUS> consider (+) <$> (Just 3) ... this basically creates a (Just (+3))
07:32:20 <BONUS> and then when you do
07:32:20 <tomh> peaker: so its kinda like the map function?
07:32:30 <BONUS> (Just (+3)) <*> (Just 9)
07:32:32 <Peaker> tomh: fmap = map   on lists, but it is more general than map
07:32:34 <tomh> but for more than just lists
07:32:38 <tomh> ok
07:32:49 <Beelsebob> Peaker: he asked about <*>, not <$>
07:32:49 <Peaker> > fmap (+1) (Just 5)
07:32:50 <BONUS> it puts the (+3) out of the maybe, the 9 out of the maybe and applies the 9 to (+3), wraps it back up into a maybe
07:32:51 <lambdabot>   Just 6
07:33:02 <Peaker> Beelsebob: before, he asked about fmap
07:33:09 <Peaker> > fmap (+1) [1,2,3]
07:33:11 <lambdabot>   [2,3,4]
07:33:17 <pk_> hi
07:33:30 <tomh> and <*> applies everything on everything?
07:33:43 <pk_> I read the wiki about haskell
07:33:48 <tomh> as seen by the [f,g,h] <*> [x,y,z] example
07:33:57 <Peaker> tomh: <*> is an applicative method.. in the list applicative instance, <*> applies each of the left functions to each of the right args, yes
07:33:59 <BONUS> for the list, yeah
07:34:07 <tomh> ok cool
07:34:15 <Peaker> tomh: but different applicative instances may define it differently
07:34:17 <tomh> then i kinda have a clue what im doing now again :p
07:34:25 <athos> re
07:34:25 <tomh> ye ok
07:34:28 <pk_> and I have trouble understanding why fix finds the least fixed point
07:34:29 <Peaker> > Just (+1) <*> Just 5
07:34:30 <lambdabot>   Just 6
07:34:33 <Peaker> > Just (+1) <*> Nothing
07:34:35 <lambdabot>   Nothing
07:34:40 <pk_> it's the least defined part that bugs me
07:34:47 <tomh> ok thanks for the help guys
07:35:24 <jethr0_> does anyone have some pointers for dataflow programming? which are the main free languages and where can I find good introductory tutorials?
07:36:56 <jethr0_> so far I've come across Lucid and Lustre. would those be the languages to look at?
07:42:49 <ksf> the one i've come across is cg.
07:44:45 <jethr0_> have you done any programming in cg?
07:45:11 <ksf> nothing serious.
07:45:46 <ksf> actually, it's more the design of gpus that forces you to program dataflow.
07:46:30 <jethr0_> in what context did you use it? was it for a college course or general interest?
07:46:36 <ksf> general interest.
07:47:44 <ksf> It'd be cool if ghc targeted both cpu and gpu of a machine simultaneously.
07:48:10 <ksf> ah, there's also oz, it's got true data flow.
07:48:11 <jethr0_> true, even better if there were fpgas in every computer that ghc could make use of ;)
07:48:35 <ksf> http://www.mozart-oz.org/
07:48:39 <lambdabot> Title: The Mozart Programming System
07:49:03 <mm_freak_> i don't get how arrows are generalizations of monads…  how would i turn Maybe into an arrow?
07:49:30 <ksf> nah, arrows are a superconcept of monads, not of maybes.
07:49:49 <mm_freak_> ah, ok, makes sense
07:50:01 <ksf> look at it from the perspective that you can do thingies with arrows that make it easy to write maybe.
07:50:39 <mm_freak_> yeah…  i could turn a -> Maybe b into an arrow (a Kleisli arrow, i guess)
07:51:21 <ksf> ...which is a monad.
07:51:40 <mm_freak_> what is a monad?
07:52:05 <papermachine> It's pretty direct: a -> Maybe b and b -> Maybe c compose to a -> Maybe b -> Maybe (Maybe c) -> Maybe c
07:52:18 <ksf> http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=oz&lang2=ghc
07:52:19 <Axman6> ksf: i think there's work being done on dph to make it use GPUs, but i coud be wrong
07:52:20 <ksf> ouch.
07:52:20 <lambdabot> Title: Mozart/Oz benchmarks | Ubuntu : Intel® Q6600® quad-core Computer Language Benc ..., http://tinyurl.com/6xefem
07:53:14 <mm_freak_> papermachine: i'd say, they compose to a -> Maybe c
07:53:29 <jethr0_> speed isn't everything. i'm rather interested in learning a new paradigm for tackling problems
07:53:39 <papermachine> Yeah, I was trying to show how, but then I realized -> has a different meaning in Haskell
07:53:50 <mm_freak_> quite different =)
07:54:06 <jethr0_> and then one can take concepts from languages and integrate them into others (like the concepts of Lucid being integrated into Functional Reactive Programming)
07:54:50 <mm_freak_> btw, is there a good introduction to FRP?
07:55:36 <ksf> http://www.info.ucl.ac.be/~pvr/book.html
07:55:38 <lambdabot> Title: Concepts, Techniques, and Models of Computer Programming
07:57:03 <ksf> page 60
07:57:56 <ksf> if an oz variable is undefined, accesses to it block until it becomes defined.
07:58:28 <ksf> which is quite impressive in a gui.
08:00:43 <ksf> http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.pdf
08:00:46 <lambdabot> Title: The principal programming paradigms
08:04:44 <jethr0_> and there are some good papers on frp in haskell
08:05:38 <ksf> does one of them compare the libraries?
08:06:27 <jethr0_> it's long ago that i read them. can't remember
08:06:40 <lilac> conal's paper on Reactive is fairly accessible
08:06:50 <Peaker> mm_freak_: dolio wrote an FRP tutorial
08:06:56 <lilac> but i'm not sure it serves as a good introduction to FRP as a whole
08:07:03 <Peaker> mm_freak_: http://netsuperbrain.com/blog/posts/introducing-reactive-events/
08:07:07 <lambdabot> Title: Less Sugar/More Meat » Blog Archive » Introducing Reactive: Events
08:07:29 <athos> :t map
08:07:30 <athos> :t concatMap
08:07:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:07:31 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:08:01 <mm_freak_> thanks
08:10:21 <ksf> "you don't really need to know haskell"
08:10:25 <athos> hm, okay, by the type of concatMap it's clear that concatMap is >>= in terms of lists.. but map (\a -> Just a) [1..5] looks to me the same as [1..5] >>= \a -> Just a. so is there any counterexample, where this "equality" of map and >>= is wrong?
08:10:34 <ksf> "now i'm going to throw nasty formulas at you"
08:10:39 <skorpan> @pl map (\b -> branchSubst b li ex) bs
08:10:39 <lambdabot> map (flip (flip branchSubst li) ex) bs
08:10:41 <athos> i mean, by looking at the types it's wrong of course, and it looks like i have to use return explicit for concatMap, and that its implicit at map
08:10:42 <ksf> something doesn't match up.
08:11:44 <athos> ah, i forgot the return at [1..5] >>= \a -> (Just a):[]
08:22:24 <luqui> @src permutations
08:22:25 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:22:30 <luqui> > permutations [1,2,3]
08:22:32 <lambdabot>   Not in scope: `permutations'
08:22:38 <luqui> @src Data.List.permutations
08:22:39 <lambdabot> Source not found. You speak an infinite deal of nothing
08:22:47 <geezusfreeek> > Data.List.permutations [1,2,3]
08:22:48 <luqui> > Data.List.permutations [1,2,3]
08:22:49 <lambdabot>   Not in scope: `Data.List.permutations'
08:22:49 <lambdabot>   Not in scope: `Data.List.permutations'
08:22:52 <luqui> hmmm
08:22:53 <Axman6> @hoogle permute
08:22:54 <lambdabot> Text.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
08:22:54 <lambdabot> Text.ParserCombinators.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
08:22:54 <lambdabot> System.Console.GetOpt Permute :: ArgOrder a
08:23:03 <geezusfreeek> it's in the library documentation on haskell.org...
08:23:10 <Axman6> @hoogle permutat
08:23:11 <lambdabot> package permutation
08:23:46 <geezusfreeek> and it works in ghci for me in 6.10.1
08:24:17 <Axman6> :t oneOf
08:24:19 <lambdabot> Not in scope: `oneOf'
08:24:33 <Axman6> dang, guess someone defined that here
08:25:49 <dmwit> :t Text.ParserCombinators.Parsec.oneOf
08:25:50 <lambdabot> forall st. [Char] -> Text.ParserCombinators.Parsec.Char.CharParser st Char
08:29:18 <cpfr> hey i know  this isnt a haskell question perse but im wondering is there a nice way to a string on whitespace EXCEPT when the whitespace is being quoted
08:29:52 <jethr0_> you accidentally the verb
08:30:02 <dmwit> > lex "foo bar"
08:30:03 <lambdabot>   [("foo"," bar")]
08:30:11 <dmwit> > lex "\"foo bar\""
08:30:12 <lambdabot>   [("\"foo bar\"","")]
08:30:25 <jethr0_> cpfr: it's really a lexing/parsing question
08:30:26 <dmwit> Not that I would call that "nice".
08:30:58 <dmwit> And jethr0_ is right; if you want something maintainable, write yourself a lexer/parser with Parsec.  It's really not that hard.
08:31:21 <cpfr> jethr0_, i know i can do it in parsec and have written something
08:31:25 <cpfr> but it doesnt look beuatiful
08:31:32 <jethr0_> hehe
08:31:54 <dmwit> If your lexical structure just so happens to match Haskell's... then "lex" is the way to go. =P
08:32:48 <cpfr> wow
08:32:56 <cpfr> i didnt even know about lex
08:33:17 <dmwit> The Prelude has some weird ones, that's for sure.
08:33:26 <jethr0_> neither did I. what is its purpose? just splitting on whitespace?
08:33:37 <dmwit> jethr0_: It's a full Haskell lexer!
08:33:44 <jethr0_> like "words"
08:33:46 <jethr0_> cool
08:33:46 <dmwit> welll... H98 anyway
08:34:03 <cpfr> i like words
08:34:09 <cpfr> it just doesnt work in this place
08:34:17 <cpfr> my non-beauty uses words
08:34:30 <dmwit> > lex "(-32)" -- lex also might not work
08:34:31 <lambdabot>   [("(","-32)")]
08:34:33 <quicksilver> s/with Parsec/with a decent parser library/
08:34:44 <cpfr> and then runs a fold over it to concat those strings with quotes
08:34:46 <quicksilver> ReadP and PolyParse are good too.
08:35:15 <jethr0_> quicksilver: *aaww*, you can do proper parsing with parsec, it just makes it easier to cut corners ;)
08:35:26 <quicksilver> I didn't mean to exclude parsec
08:35:30 <quicksilver> I was just expanding.
08:35:48 <quicksilver> I prefer polyparse's approach, but any of them will work.
08:36:16 * jethr0_ is going to quickly have a look at polyparse
08:37:34 <athos> :t permutat
08:37:35 <lambdabot> Not in scope: `permutat'
08:38:50 <Axman6> @instances RandomGen
08:38:50 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
08:38:53 <thoughtpolice> Lemmih++ # lhc regression suite!
08:39:31 <Axman6> @instances Random
08:39:32 <lambdabot> Couldn't find class `Random'. Try @instances-importing
08:40:30 <mmorrow> Parsec--
08:40:32 <mmorrow> ReadP++
08:40:35 <mmorrow> :)
08:42:15 <lilac> @hoogle Bool -> m () -> m ()
08:42:16 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
08:42:16 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
08:42:16 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
08:42:21 <laz0r> hi #haskell, i have some open source binary file format for which i want to write a reader/writer. Is Data.Binary the right thing to look at? Or should look one level lower and use Data.ByteString directly?
08:43:01 <quicksilver> laz0r: Data.Binary.(Get/Put)
08:43:06 <quicksilver> laz0r: but not the Data.Binary.Binary class
08:43:19 <skorpan> @pl \a -> f a 5
08:43:19 <lambdabot> flip f 5
08:43:27 <skorpan> @pl \a b -> f a b 5
08:43:28 <lambdabot> flip flip 5 . f
08:43:40 <skorpan> @pl \a b c d e f g h -> h g f e d c b a
08:43:43 <lambdabot> flip (flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . (flip .) . ((flip .) .)) .) . flip (
08:43:43 <lambdabot> flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id))))))
08:43:43 <lambdabot> optimization suspended, use @pl-resume to continue.
08:43:51 <Axman6> you monster!
08:43:57 <Axman6> @pl-resume
08:43:59 <lambdabot> flip (flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (
08:43:59 <lambdabot> flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))))
08:44:00 <laz0r> quicksilver: ok, thanks, i'll try to get something working with Data.Binary
08:44:01 <Axman6> @pl-resume
08:44:01 <lambdabot> pointless: sorry, nothing to resume.
08:44:05 <skorpan> i was just showing my friend here that you can do everything pointfree
08:44:08 <ksf> laz0r, tokenise with Data.Binary, parse with parsec.
08:44:31 <mmorrow> this is the main reason why ReadP is better than Parsec:
08:44:33 <mmorrow> runParser (string "1234" <|> string "1235") () [] "1235"
08:44:38 <mmorrow> Left (line 1, column 1):
08:44:38 <mmorrow> unexpected "5"
08:44:38 <mmorrow> expecting "1234"
08:44:46 <mmorrow> while with ReadP:
08:44:54 <mmorrow> ghci> :m + Text.ParserCombinators.ReadP
08:44:54 <mmorrow> ghci> (take 1 . readP_to_S (string "1234" +++ string "1235")) "1235"
08:44:54 <mmorrow> [("1235","")]
08:45:06 <mmorrow> (+++) is /commutative/
08:45:13 <mmorrow> whereas (<|>) is not
08:45:14 <Axman6> skorpan: which is also an excellent example of why i try to only ever use pointfree when i have one argument to the function
08:45:23 <skorpan> :)
08:45:39 <mmorrow> ReadP does a breadth-first search and Parsec does a depth-first one
08:45:44 <tomh> in haskell is it possible to use the constructor name as string in a function?
08:46:04 <Axman6> tomh: what do you mean?
08:46:23 <ksf> @faq can haskell stringify identifiers?
08:46:23 <lambdabot> The answer is: Yes! Haskell can do that.
08:46:35 <ksf> try template haskell.
08:46:39 <tomh> like i have a function con2string (Con a) = ConAsString ++ ":" ++ a
08:46:59 <tomh> but i want to have con2string (c a) = c ++ ":" ++ a
08:47:07 <tomh> so i dont have to pattern match on all posible constructors
08:47:20 <tomh> mm ok gonna lookup those templates
08:47:31 <ksf> might very well be overkill, though.
08:47:32 <mmorrow> , let conToString con a = show (con a) in conToString Just 42
08:47:34 <lunabot>  "Just 42"
08:47:36 <mmorrow> ?
08:47:49 <tomh> ksf: its an compiler extension?
08:47:58 <ksf> the last time i did a similar thing i just made a map from constructors to strings.
08:48:02 <mmorrow> , [|Just 42|]
08:48:06 <ksf> it's a language extension, yes.
08:48:06 <lunabot>  AppE (ConE Just) (LitE (IntegerL 42))
08:48:09 <ksf> metaprogramming.
08:48:17 <tomh> ok, not allowed to use those :(
08:48:32 <thoughtpolice> @can haskell accidentally the whole world?
08:48:32 <lambdabot> Maybe you meant: faq map run wn
08:48:36 <thoughtpolice> @faq can haskell accidentally the whole world?
08:48:36 <lambdabot> The answer is: Yes! Haskell can do that.
08:48:52 <Beelsebob> @vixen can haskell accidentally the whole world?
08:48:52 <lambdabot> church is my favourite computer scientist.
08:49:00 <mmorrow> , $(let tup x y = [|($x,$y)|] in foldl tup [|()|] (fmap lift [0..9::Int]))
08:49:02 <lunabot>  (((((((((((),0),1),2),3),4),5),6),7),8),9)
08:49:05 <Beelsebob> @vixen why church, not curry?
08:49:05 <lambdabot> because i said so!
08:49:06 <mmorrow> , $(let tup x y = [|($x,$y)|] in foldr tup [|()|] (fmap lift [0..9::Int]))
08:49:08 <lunabot>  (0,(1,(2,(3,(4,(5,(6,(7,(8,(9,()))))))))))
08:49:12 <tomh> mmorrow: gonna try your method thanks
08:49:40 <mmorrow> tomh: and you can use `read' (or reads to prevent erroring out) on the shown String
08:49:54 <mmorrow> , let conToString con a = show (con a) in read (conToString Just 42) :: Just Int
08:49:56 <lunabot>  luna: Not in scope: type constructor or class `Just'
08:50:00 <mmorrow> , let conToString con a = show (con a) in read (conToString Just 42) :: Maybe Int
08:50:00 <tomh> mm i cant pattern match on a constructor
08:50:03 <lunabot>  Just 42
08:50:06 <dmwit> tomh: What are you trying to do this for?
08:50:08 <athos> i've a question about type classes and their instances. at http://www.haskell.org/tutorial/classes.html there's an example of the type class Eq, where the operation (what's the appropriate word here?) == is "defined" in terms of /=, so x /= y = not (x == y).. but how would one implement it for a given instace, like integer? would i do something like (in the instance) x == y = x `integerEq` y, and x /= y = not (x == y(
08:50:09 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
08:50:14 <athos> or how is that done?
08:50:17 <dmwit> tomh: Can you just use the Show class?
08:50:33 <tomh> dmwit: just trying to safe myself from writing 20 pattern matches
08:50:37 <dmwit> athos: exactly right
08:50:48 <Axman6> athos: you just have to define either (==) or (/=)
08:51:17 <athos> Axman6: you mean in a specific instance?
08:51:21 <ksf> tomh, use a map.
08:51:28 <Axman6> athos: yes
08:51:34 <tomh> how do you mean ksf?
08:51:49 <ksf> Map.fromList[(Foo,"foo"),(Bar,"bar")]
08:51:59 <ksf> and wrap a function around it that accesses it.
08:52:03 <Axman6> athos: since x = y = not (x /= y), if you define (/=), then == is also defined
08:52:17 <mmorrow> and vice-versa
08:52:20 <tomh> but my data is in the form of Con string
08:53:21 <mmorrow> tomh: you'll have to use pattern-matching at some level to distinguish between constructors
08:53:47 <mmorrow> it's "the only way"
08:54:03 <athos> Axman6: hum, yeah, that's kind of "obvious" to me, but how does the compiler resolve this (i mean a dumb, expressive, non optmizing one)? when i just define /= in terms of ==, and i compare two integers, does it look at the definition of /=, and just swaps the right hand side with the left hand side?
08:54:04 <ksf>  con2string c a = (stringFromId c) ++ ":" ++ a
08:54:08 <tomh> i see ok
08:54:08 <ksf> or (c, a)
08:54:48 <Axman6> > show Just
08:54:50 <quicksilver> athos: there are default definitions.
08:54:50 <lambdabot>       Overlapping instances for Show (a -> Maybe a)
08:54:50 <lambdabot>        arising from a use...
08:55:13 <quicksilver> athos: default is "a == b = not (a /= b)" and "a /= b = not (a == b)"
08:55:29 <quicksilver> athos: so, if you define one, there is automatically a working definition for the other
08:55:49 <ksf> ...and if you define neither, you get an endless loop.
08:57:05 <ksf> "replacing" is the right idea, and replacements are pulled, not pushed, _always_.
08:58:53 <athos> i guess my brain is kinda stuck somewhere.. just for crystal clear comprehension: by just defining a == b = not (a /= b), the defintion for a /= b is automatically generated?
08:59:03 <mauke> athos: no
08:59:06 <ksf> it's not generated.
08:59:10 <ksf> it just stays.
09:01:08 <Botje> athos: it's set up so you only have to define one of them.
09:01:48 <dmwit> athos: There is also a definition "a /= b = not (a == b)".
09:01:56 <athos> ah ok!
09:02:00 <athos> thanks :)
09:07:45 * luqui wonders why both == and /= are methods, rather than just ==
09:08:51 <Beelsebob> luqui: perhaps so that you can define /= more efficiently than (not . ) . (==)
09:09:15 <luqui> but it can't be that much more efficient
09:09:24 <luqui> however quickly /= returns True, == can return False
09:09:53 <Beelsebob> true true
09:10:05 <lilac> conal: i've got continuous playback working
09:10:33 <conal> lilac: woot!
09:11:01 <Beelsebob> lilac: continuous playback?
09:11:01 <lilac> but i think i've got a space leak and i don't know how to solve it :(
09:11:34 <conal> lilac: i wonder if it's the known space leak, from unused inputs.
09:11:34 <dmwit> luqui: I think the original rationale was that sometimes one or the other is more convenient to define.
09:11:53 <dmwit> luqui: I'm not sure if they would make the same decisions if they were re-defining the language today. =)
09:12:00 <gwern> @seen Lemmih
09:12:01 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
09:12:28 <lilac> conal: it's my audio source. at least, i can't see how my code can simultaneously be correct and leak-free :(
09:12:53 <conal> lilac: oh, interesting.  i'd like to take a look.
09:13:09 <gwern> @tell Lemmih re http://lhc.seize.it/#development - if you replace the --partial lhc with --lazy lhc then its even clearer that you need darcs 2
09:13:09 <lambdabot> Consider it noted.
09:13:43 <lilac> conal: well, i've uploaded the latest.
09:13:56 <lilac> conal: it's perhaps more likely that my usage of runE is incorrect
09:13:57 <conal> lilac: i'll pull
09:15:31 <lilac> i think i want a Behaviour a -> Event b -> Behaviour a, where the behaviour is truncated at every event. is there a function for that?
09:15:40 <conal> lilac: i'm reading the darcs diffs
09:17:01 <Beelsebob> dmwit: then surely if /= is more convenient, you simply define (==) = (not .) . (/= definition)
09:18:01 <dmwit> Beelsebob: As I said... I'm not sure they would make the same decisions today.
09:18:19 <Beelsebob> ah, fair enough
09:18:43 <conal> lilac: i'm not getting your meaning.
09:19:17 <Peaker> lilac: "truncated" to what value?
09:19:42 <lilac> Peaker: i don't care what the behaviour does before the event
09:19:56 <conal> lilac: do you mean you want some kind of looping?
09:20:34 <lilac> i want to give reactive the permission to throw away the history of the Behaviour from before a certain time
09:21:04 <conal> Beelsebob: or (==) = (fmap.fmap) (/=) as in "semantic editor combinators"  (s/fmap/result/ as desired)
09:22:01 <conal> lilac: oh, yeah.  i think there are operations to do that.  i'll look.  what you're getting into is exactly what i'm working on fixing in general, which got me into the new comonadic direction.
09:23:51 <lilac> conal: a step further back, what i want is that every X seconds, i fill a buffer with the /previous/ X seconds' audio, and queue it to be played next.
09:24:34 <lilac> it needs to be periodic, since otherwise it's too slow, and it needs to be the previous period, since otherwise the audio will block waiting for input which might change what will be played (AIUI)
09:26:08 <conal> lilac: please explain "it needs to be periodic, since otherwise it's too slow"
09:26:53 <lilac> conal: that was the runtime problem -- asking for the time and sleeping 44,100 times per second is not possible on my machine
09:27:27 <lilac> so i need to batch up sampling
09:27:38 <conal> ok.  i get it so far
09:27:57 <conal> oh, that's what you mean by "periodic" -- "batched"
09:28:13 <lilac> yes, sorry, that was rather unclear in retrospect :)
09:28:32 <conal> lilac: np.  i generally expect communication to be iterative.
09:29:39 <conal> now the next part: "it needs to be the previous period, since otherwise the audio will block waiting for input which might change what will be played (AIUI)"
09:30:08 * conal ponders what to ask ...
09:30:17 <lilac> right. suppose i want to make a keyboard program, where the user presses a key and we play that note
09:31:28 <conal> and you worry that you'll miss some input or misinterpret it?
09:31:28 <lilac> if the audio for times [T, T+delta) are determined by keypresses within that interval, then the buffer filling code will need to block
09:31:42 <conal> yep
09:31:55 <lilac> but I need to enqueue that buffer by time T or before
09:31:57 <conal> which would be correct, right?
09:32:40 <conal> oh.  well i don't think you can show/play the output for time t at time t.
09:32:43 <lilac> (otherwise the sound card will run out of audio and stop playing)
09:32:47 <conal> i.e., there will be latency
09:32:49 <lilac> right, no.
09:33:05 <conal> if there's consistent latency, there needn't be gaps
09:33:14 <lilac> so instead, the audio for times [T, T+delta) comes from the Behaviour at times [T-X, T-X+delta)
09:33:21 <conal> i.e., if every output segment is delayed by the same amount.
09:33:28 <lilac> right, so that's my plan.
09:33:38 <conal> hm.  i'm thinking of it a bit differently.
09:33:56 <conal> but maybe it's just language.
09:34:16 <conal> yeah, i think so.  i'd say the output gets delayed by X
09:34:21 <lilac> i'm wondering if i ignore this issue whether the latency will be 'automatically' added by reactive and i don't need to worry
09:34:40 <lilac> the audio /will/ have some latency anyway. that's inevitable
09:35:00 <int-e> is there anything like  unfoldM :: Monad m => (a -> m (Maybe (b, a)) -> a -> m [b] in the standard libs?
09:35:14 <conal> lilac: i think graphics has the same issue.
09:35:45 <conal> lilac: in other words, i think it's a general phenomenon that reactive will deal with consistently
09:36:19 <lilac> right. what will happen if i just ignore it? that is, if i try to pump data for times [T, T+delta) into the buffer at time T?
09:36:26 <lilac> presumably it'll block until T+delta?
09:36:50 <conal> lilac: usually.
09:37:02 <conal> lilac: assuming external input is used.
09:37:07 <lilac> if it's not consistent, then i'm not sure i can safely rely on it
09:37:26 <conal> lilac: i'm unsure also
09:37:44 <conal> the frame buffer is more forgiving than audio queue.
09:38:15 <lilac> true. and the only way to make audio more forgiving is to increase latency :(
09:38:21 <conal> since we give frequency info to the frame buffer and sample data to the audio queue.
09:38:33 <conal> yeah -- increase buffer size.
09:38:42 <conal> increasing latency
09:40:22 <conal> lilac: the purity of Reactive's implementation ought to come in useful.  no information is ever overwritten, so the past is accessible as long as you can reach it.
09:40:51 <hackage> Uploaded to hackage: gitit 0.3.2
09:40:56 <conal> lilac: i'm not sure how the details will work out, but i like how your domain adds a new twist.
09:41:37 <conal> hm, "accessible as long as you can reach it" is a tautology.  i mean you can hang onto it as long as you like.
09:41:58 <conal> it isn't destroyed until no can look anyway (GC)
09:42:26 <lilac> right. but in this case, i /want/ it to be destroyed, or at least, i want to say 'i won't look back beyond this point in time'
09:43:08 <conal> lilac: and that's easy to do.  just as with lists, don't hang onto the beginning.
09:43:31 <lilac> conal: i think what you're saying is i should convert the behaviour to an event sooner
09:43:47 <lilac> that is, do the 44KHz sampling once rather than once per buffer
09:44:24 <tomh> is it possible to see if a list contains a specific instance of a data type?
09:44:26 <conal> lilac: i wasn't trying to make that suggestion.  but maybe it's a good idea.
09:44:32 <mauke> :t elem
09:44:33 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:44:53 <tomh> elem?
09:44:59 <tomh> ok
09:45:22 <tomh> but doesnt that return true for all instances?
09:45:33 <conal> lilac: i'm gradually seeing what you're trying to do here.
09:45:34 <tomh> like i want to check if a list of maybes has one instance of Just a
09:45:40 <dmwit> :t isJust
09:45:41 <lambdabot> forall a. Maybe a -> Bool
09:45:44 <dmwit> :t find
09:45:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:46:06 <tomh> ok i guess i need find, thanks
09:46:07 <tanob> hello guys, im trying to implement a state monad, i implemented it, but i dont get how access the current state... http://hpaste.org/12527
09:46:21 <conal> lilac: i didn't get that type: Behaviour a -> Event b -> Behaviour a
09:46:25 <mmorrow> , any (==0) (repeat 0)
09:46:27 <lunabot>  True
09:46:29 <conal> lilac: and i don't think it's what you really mean.
09:46:30 <lilac> conal: as i see it, the problem is that my adapter holds on to the given behaviour forever, so will keep all its history
09:46:32 <pizza_> i have a list and i want to generate some sort of set with a key -> count mapping, count being the number of times the key appaars in the list. what is the idiomatic way to do this? i've looked at my own binary tree, Data.Hastable, Data.Map and cannot figure out the simplest way.
09:46:43 <conal> lilac: yeah. that's death.
09:46:50 <conal> lilac: as it is for lists.
09:47:10 <mauke> pizza_: it's some sort of fold with Data.Map
09:47:19 <conal> lilac: maybe you want: Behaviour a -> Event b -> Event (Behaviour a)
09:47:38 <mmorrow> , (==1) . sump . fmap (maybe 0 (const 1)) $ [Nothing,Nothing,Just "asdf",Just "4",Nothing]
09:47:39 <conal> where each output is a "truncated" version of the input, as you said.
09:47:40 <lunabot>  luna: Not in scope: `sump'
09:47:44 <mmorrow> , (==1) . sum . fmap (maybe 0 (const 1)) $ [Nothing,Nothing,Just "asdf",Just "4",Nothing]
09:47:45 <pizza_> mauke: ok, i'll try and figure it out
09:47:45 <lunabot>  False
09:47:46 <Botje> tanob: you have to use do syntax
09:47:47 <lilac> conal: yes, that makes much more sense :)
09:48:01 <jkff> pizza_: Or, if you don't want efficiency, map (\x -> (head x,length x)) . group . sort
09:48:04 <lilac> conal: seeing that, it's now clear to me why my type was silly :)
09:48:08 <jkff> However, that's efficient.
09:48:25 <Botje> calcSum = getTransInfo >>= \(ti) -> let x = tix ti; let y = tiy ti; return x + y
09:48:36 <mauke> :t foldl' (\k -> M.insertWith (+) k 1) M.empty
09:48:38 <lambdabot>     Occurs check: cannot construct the infinite type: a = M.Map a a1
09:48:38 <lambdabot>       Expected type: M.Map a a1 -> a
09:48:38 <lambdabot>       Inferred type: M.Map a a1 -> M.Map a a1
09:48:38 <jkff> However, a Data.Map will be more efficient if there are many duplicates.
09:48:39 <conal> lilac: okay.  that function comes up a lot.  and it's what i'm now working on automating. so that people don't have to deal with what you're dealing with.
09:48:57 <mauke> :t foldl' (\m k -> M.insertWith (+) k 1 m) M.empty
09:48:58 <lambdabot> forall b a. (Ord b, Num a) => [b] -> M.Map b a
09:49:02 <Peaker> conal, lilac: in an adapter, wouldn't it make more sense to replace the behavior in-place, than to expose a more complicated type of operational reasons?
09:49:13 <tanob> Botje: let me see if i understand your example
09:49:16 <Peaker> s/of/for
09:49:36 <conal> Peaker: what do you mean "replace the behavior in-place"?
09:49:43 <Botje> tanob: i'll annotate it with your paste if you want
09:49:46 <lilac> Peaker: what would you replace it with?
09:49:54 <lilac> Peaker: in my case, i need the previous 0.1s of Behaviour
09:49:56 <mmorrow> > foldl' (\m x -> Map.insertWith' (+) x 1 m) mempty (take 10000 (randomRs ('a','z') (mkStdGen 836445)))
09:49:57 <lambdabot>   fromList [('a',369),('b',376),('c',347),('d',381),('e',420),('f',394),('g',...
09:50:02 <conal> Peaker: what state gets mutated?
09:50:19 <mmorrow> > foldl' (\m x -> Map.insertWith' (+) x 1 m) mempty (take 100000 (randomRs (0,3::Int) (mkStdGen 836445)))
09:50:21 <lambdabot>   fromList [(0,24896),(1,25033),(2,24988),(3,25083)]
09:50:44 <Peaker> conal: well, if you take a tuple of Behaviors as I saw in lilac's code, perhaps you have an IORef to such a tuple, and you discard the history / old behavior data by replacing the tuple after sampling the behaviors?
09:50:46 <pizza_> thank you for the examples
09:51:01 <conal> Peaker: where?
09:51:10 <Botje> tanob: annotated
09:51:23 <lilac> conal: i think Peaker means the Source type
09:51:27 <Peaker> conal: In the function of type  Sink Blah
09:51:42 <Peaker> lilac: who is "holding on" to the "root" of the behaviors?
09:51:55 <Botje> Is there a Reactive for Retards yet? I'm eager to learn about it :)
09:52:14 <lilac> Peaker: the PlaySource function
09:52:50 <conal> Peaker: lilac could use a recursive loop or combinator instead of an IORef.  i think his problem is that he can't find a function to get these "tails" of behaviors.
09:53:06 <conal> "residuals" i called them in fran
09:53:18 <Peaker> lilac: exactly, yeah, its a   Sample a => Sink (Behavior a)
09:53:32 <Peaker> lilac: in that function, you could be mutating an IORef in place to "move" the behavior "ptr" forward?
09:53:53 <Peaker> conal: yeah, I guess you're right, silly to use IORef there
09:54:12 <conal> Peaker: old (imperative) habits die hard. ;)
09:54:16 <Peaker> conal: :-)
09:54:32 <Peaker> conal: When I am thinking of an IO-typed function, I am still thinking imperatively :)
09:54:49 <SamB_XP_> always ?
09:54:58 <conal> Peaker: cut it out, then!  ;)
09:55:01 <Peaker> conal: so the "tails" of a behavior would be the comonad "extraction"?
09:55:11 <tanob> Botje: thank you a lot, im trying to understand getTransInfo ... do u know  a good resource to understand monads?
09:55:19 <conal> Peaker: yes -- the comonadic "duplicate"
09:55:27 <Peaker> @src Comonad
09:55:27 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:55:32 <conal> that's why i got into comonads.
09:55:35 <Peaker> @hoogle comonad
09:55:35 <lambdabot> No results found
09:55:42 <mmorrow> > let histo n (a,b) seed = Map.map (\m -> fromIntegral m / fromIntegral n :: Double) . foldl' (\m x -> Map.insertWith' (+) x 1 m) mempty . take n . randomRs (a,b) . mkStdGen $ seed in histo 100000 (0,3) 984972
09:55:44 <lambdabot>   fromList [(0,0.24941),(1,0.25275),(2,0.24949),(3,0.24835)]
09:55:49 <conal> then lilac's function is just duplicate & snapshot
09:55:51 <Peaker> conal: is it frequent that monads are also comonads?
09:55:52 <SamB_XP_> tanob: what do you want to understand 'em for ?
09:56:03 <conal> Peaker: i don't know.
09:56:07 <mmorrow> > let histo n (a,b) seed = Map.map (\m -> fromIntegral m / fromIntegral n :: Double) . foldl' (\m x -> Map.insertWith' (+) x 1 m) mempty . take n . randomRs (a,b) . mkStdGen $ seed in histo 100000 ('a','d') 984972
09:56:09 <lambdabot>   fromList [('a',0.24941),('b',0.25275),('c',0.24949),('d',0.24835)]
09:56:12 <SamB_XP_> tanob: if you give up, you may discover that you already had ;-P
09:56:13 <Peaker> list is also a comonad, right?
09:56:23 <Botje> tanob: the best way to learn about monads is simply to use them
09:56:28 <conal> Peaker: not quite
09:56:35 <conal> Peaker: but Stream is
09:56:39 <tanob> hehe
09:56:40 <jkff> A question about free theorems: Is it true that the free theorems are true because all valid Haskell's polymorphic terms of type forall a . F a -> B a are natural transformations between functors F and G in the category of monomorphic types and monomorphic terms of arrow types?
09:56:40 <Botje> bash your head against them enough, and eventually the type errors will go away :)
09:56:52 <Peaker> conal: where Stream is an infinite list?
09:56:58 <conal> yeah
09:57:01 <tanob> i already read 2 or 3 articles from Phil Wadler
09:57:08 <tanob> but state monads get me
09:57:18 <SamB_XP_> tanob: oh, you don't get a particular monad!
09:57:23 <SamB_XP_> that we CAN help with
09:57:34 <Peaker> conal: why is a finite list not a comonad, because you must be able to duplicate/extract a "head/tails" repeatedly, infinitely, according to the comonad laws?
09:57:41 <SamB_XP> what about it don't you get ?
09:57:43 <tanob> i always get stuck, i feel like i didnt get them yet :)
09:57:43 <athos> btw, when does the "type checker" (i mean ghcs/lambdabots :t) return something like a -> b, and when does it return forall a.b. a->b
09:58:01 <jkff> tanob: you can also give a try to http://spbhug.folding-maps.org/wiki/MonadsEn ; it also has a section about the State monad.
09:58:10 <conal> Peaker: i guess that explanation fits.  you can't always take the head of a list.
09:58:12 <SamB_XP> tanob: maybe so, but particulars are worth speaking of ;-)
09:58:14 <mmorrow> > runState (get >>= \(m,n) -> put (n,m+n) >> return m) (0,1)
09:58:14 <oshyshko> How do I tunnel SSH port with Haskell?
09:58:14 <lambdabot> Title: MonadsEn - SPb Haskell User Group
09:58:15 <lambdabot>   (0,(1,1))
09:58:16 <conal> but you can of a stream
09:58:17 <Liskni_si> hey does anyone know what is the most efficient way to turn a lazy bytestring into a newly allocated cstring?
09:58:21 <jethr0_> tanob: what really helped me is understand what the single monads are trying to do and then reimplement them
09:58:22 <Peaker> conal: btw, is ghc smart enough to discard references to arguments your function will no longer be using anymore?
09:58:27 <mmorrow> > runState (replicateM 10 (get >>= \(m,n) -> put (n,m+n) >> return m)) (0,1)
09:58:28 <lambdabot>   ([0,1,1,2,3,5,8,13,21,34],(55,89))
09:58:29 <jkff> athos: never for a non-bottom term.
09:58:33 <jethr0_> (with a little help from "meet the monads" and other resources, that is)
09:59:06 <tanob> jkff: ah yes, i was reading the "all about monads", very nice that we have a "pattern" :)
09:59:06 <conal> Peaker: i think so, conservatively.
09:59:17 <Peaker> conal: nm, I guess it must be or pretty much no pure recursive function could be O(1) memory
09:59:20 <jkff> :type \a -> head []
09:59:21 <conal> Peaker: it's undecidable whether you'll use a value again.
09:59:43 <jkff> > :type \a -> head []
09:59:44 <lambdabot>   <no location info>: parse error on input `:'
09:59:51 <Peaker> conal: well, in the case where its used in some expressions, but not passed to a tail-recursive call
09:59:57 <jkff> @type \a -> head []
09:59:58 <lambdabot> forall t a. t -> a
10:00:05 <jkff> athos: Here you are
10:00:16 <jkff> Or like this
10:00:19 <jkff> @type \a -> undefined
10:00:20 <lambdabot> forall t a. t -> a
10:00:30 <conal> Peaker: i assume so, but i'm not sure.
10:00:35 <Peaker> conal: In theory, the value is still in scope when the recursive call takes place, which would justify my IORef :)
10:00:38 <conal> the #ghc folks might know.
10:00:45 <Peaker> conal: (maybe that's why I had it in mind)
10:01:07 <conal> Peaker: ick.  fix the compiler instead of abandoning semantics.
10:01:21 <Peaker> conal: I'm not saying that was a good idea, just try to reverse engineer my brain's process :)
10:01:29 <conal> oh, okay :)
10:01:36 <Peaker> btw, I take it you haven't yet looked at the Event -> Behavior -> Event -> Behavior bug?
10:01:53 <dmwit> oshyshko: Calling out to ssh would be the simplest, I guess.
10:02:07 <jkff> OK, let us rephrase my question about free theorems somewhat shorter: Is it true that free theorems rely only on the naturalness of Haskell polymorphic functions?
10:02:23 <dmwit> "naturalness"?
10:02:37 <jkff> Yes, on the fact that polymorphic functions are natural transformations
10:02:39 <dmwit> Free theorems rely on parametricity.
10:02:51 <SamB> did you read the paper ?
10:03:15 <Peaker> I believe monads should be taught after functors and applicatives, and as a natural extension of their expressiveness
10:03:16 <jkff> Yes, but I also saw people say things like what I'm saying :)
10:03:28 <conal> Peaker: yes!!
10:03:29 <jkff> And I also saw reference to a paper that discussed relation between parametricity and naturalness
10:03:44 <SamB> certainly functors are easy as pie
10:03:44 <dmwit> Liskni_si: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.0/doc/html/Data-ByteString.html#22
10:03:49 <jkff> Oh: P.J. deBruin, Naturalness of polymorphism
10:03:50 <lambdabot> Title: Data.ByteString, http://tinyurl.com/5uw43o
10:03:58 <jkff> But I can't find the actual paper anywhere.
10:03:58 <SamB> there's nothing mysterious about functors
10:04:24 <conal> there's something mysterious in everything
10:04:26 <SamB> all decent languages have a map, haven't they ?
10:04:29 <oshyshko> dmwit: It is problematic. I am about to write Windows app, thus I can't expect user to have ssh/putty installed.
10:04:42 <Peaker> I taught a few people this way (starting with Functor, Applicative and finishing with Monad) and I think they got it.  You can explain one bit at a time that way, rather than the whole Monad thing at once
10:04:44 <Liskni_si> dmwit: does that work with lazy bs?
10:04:44 <SamB> conal: well, I mean, it can be easily explained in a way that doesn't scare people
10:04:50 <dmwit> oshyshko: Install it as part of your install process, then.
10:04:59 <conal> SamB: i'm with you, there.
10:05:17 <SamB> it doesn't have to sound mysterious
10:05:21 <conal> "You do not really understand something unless you can explain it to your grandmother." - Einstein
10:05:29 <lilac> conal: i've made a test harness which allows controlling the tone with the keyboard, and it blocks forever in the runE filling the buffer :(
10:05:29 <dmwit> Liskni_si: Ah, nope.  But if you're making a C string, that's not lazy, anyway.
10:05:41 <bjorkBSD> conal, and if my grandmother is marie curie?
10:05:48 <Liskni_si> dmwit: yeah, it's not, but lazy bytestrig is what I get out of data.binary
10:05:49 <bjorkBSD> how sexist of that einstein boy.
10:05:52 <SamB> I think I could explain it to my grandmother -- * if she could hear what I said *
10:05:54 <bjorkBSD> i thought he was nice.
10:06:00 <dmwit> Liskni_si: fromChunks . toChunks
10:06:08 <dmwit> Liskni_si: (to convert between lazy/strict)
10:06:12 <conal> bjorkBSD: then pick another grandmother.
10:06:20 <conal> bjorkBSD: yeah, and agist.
10:06:32 <conal> lilac: bummer :(
10:06:37 <jkff> Maybe does anyone over here have a PDF of the paper 'Naturalness of polymorphism'?
10:06:38 <bjorkBSD> hahahah
10:06:38 <SamB> didn't curie die young from radiation poisoning anyway ?
10:07:01 <conal> lilac: might be a Reactive bug.  i get some blocks also.
10:07:03 <SamB> anyway, grandmothers might be more patient than grandfathers ;-)
10:07:11 <Liskni_si> dmwit: if you meant concat . toChunks, then that's what i'm using now and there's some kind of performance problem there (but i don't know what)
10:07:11 <conal> lilac:  sry :(
10:07:37 <bjorkBSD> SamB, she could still have been a grandmother.
10:07:40 <lilac> http://hpaste.org/12528 <-- here's my main (approximately)
10:07:41 <bjorkBSD> she had a nobel winning daughter.
10:08:04 <SamB> bjorkBSD: yes, but did her daughter's daughter learn FP ?
10:08:31 <dmwit> Liskni_si: Time to profile, then. =)
10:08:32 * conal reads the paste ...
10:08:36 <bjorkBSD> she didn't have to. she learnt lambda calculus from church himself!
10:09:09 <bjorkBSD> FP should be logically consistent shouldn't it? afterall it's based on very sound mathematics.
10:09:57 <jkff> No, that means FP should be incomplete, not inconsistent
10:10:13 <jethr0_> hehe
10:10:36 <Peaker> I think openal implementations might suck, playing mp3's via openal really sucks..  Maybe one can make a trivial adapter from ALSA/OSS to openal
10:11:10 <vixey> bjorkBSD, no
10:11:15 <Peaker> lilac: do you know of any trivial openal example that I can test openal with?
10:11:38 <conal> lilac: i like that getContents line.  reading more ...
10:11:43 <bjorkBSD> if you replace incosistency with a nice symbol like _i_
10:11:51 <bjorkBSD> it becomes the axiom of axioms!
10:11:51 <SamB> sound programming is still a black art
10:11:56 <SamB> sadly
10:12:27 <SamB> I fear it is not possible to do right with most Linux drivers ....
10:13:06 <jkff> OK, let me continue my series of unanswered questions :) Anyone have the 'Categories for the working hardware designer'?
10:13:12 <Peaker> conal: I think   \b -> forkIO $ adaptE (print <$> b)      deserves a name, so useful for debugging!
10:13:30 <bjorkBSD> jkff, is it a book?
10:13:52 <Peaker> SamB: well, mplayer -ao openal   works, but sounds worse than the default.  and lilac's openal/alut code doesn't work at all
10:13:54 <jkff> No, it's an article in 'Lecture notes in computer science'
10:13:59 <conal> Peaker: probably a few variations do
10:14:24 <SamB> do you have a Creative card ?
10:14:26 <Peaker> conal: I didn't know about adaptE when I was debugging
10:14:29 <lilac> conal: am i right in recalling that 'import FRP.Reactive' brings in an "instance Functor IO"?
10:14:44 <Heffalump> Does anyone know of any libraries for manipulating predicate formulae?
10:14:45 <jkff> I'm following the most interesting bibliographic references from Wadler's 'Theorems for free' do get some deeper understanding
10:15:13 <conal> lilac: i'm not sure.  i don't understand instances re-exporting.
10:15:15 <luqui> @instance IO
10:15:15 <lambdabot> Maybe you meant: instances instances-importing
10:15:17 <luqui> @instances IO
10:15:18 <lambdabot> Couldn't find class `IO'. Try @instances-importing
10:15:28 <SamB> conal: what's to understand ?
10:15:36 <SamB> it happens every time ...
10:15:37 <luqui> lilac, IO has a functor instance by default
10:15:52 <Peaker> lilac: I have a Functor instance for IO without importing anything
10:15:55 <conal> lilac: Reactive does use the IO functor and and the IO monoid
10:16:13 <Peaker> the   IO ()   monoid, right?
10:16:23 <SamB> jkff:http://citeseerx.ist.psu.edu/showciting;jsessionid=C82040716EE7323BF542D1AABF85E091?cid=2870243
10:16:25 <lambdabot> Title: Categories for the working hardware designer — CiteSeerX citation query, http://tinyurl.com/5rolrv
10:16:28 <SamB> erg.
10:16:32 <conal> oddly, the IO functor is in Control.Monad.Instances
10:16:34 <SamB> why did I say "jkff:"
10:16:47 <SamB> that's what citeseer says about it
10:16:49 <conal> Peaker: yes, IO functor and monoid
10:17:05 <Peaker> conal: I though only   IO ()  was a monoid
10:17:09 <Peaker> thought*
10:17:12 <conal> Peaker: nope.
10:17:33 <Peaker> its:  instance Monoid a => Monoid (IO a)   then ?
10:17:46 <lilac> better not be mempty = fail ...
10:17:46 <SamB> jkff: I expect this lady has it: http://www.cs.chalmers.se/~ms/
10:17:54 <conal> Peaker: think about it.
10:17:59 <lambdabot> Title: Mary Sheeran
10:18:11 <conal> Peaker: oh.  that was a guess.  yes.
10:18:12 <Peaker> I'd expect it to be:  pure = return . pure          mappend = liftM2 mappent
10:18:26 <jkff> SamB: Oh, thanks.
10:18:43 <SamB> jkff: but, I mean, you'd have to email her about it I guess
10:18:49 <lilac> Peaker: or, pure = liftM pure; mappend = liftM2 mappend :)
10:18:52 <SamB> since citeseer hasn't found a .ps or .pdf
10:19:01 <jkff> Well, of course :)
10:19:13 <newboy> hello
10:19:21 <Peaker> lilac: its not an alternative, mine was wrong :-)
10:19:24 <jethr0_> hello newboy
10:19:24 <SamB> you might enjoy some of here other work though
10:19:24 <jkff> However I am considering to spend $25 at springerlink and get the article immediately.
10:19:25 <conal> i get a lot of use out of the IO monoid
10:19:41 <Peaker> conal: I know there's the "side effect monoid"  of just using  (return ()) and (>>),  so I thought that was the one you were referring to
10:19:42 <conal> for one thing, "mempty" is a handy sink
10:20:01 <newboy> jet can  i do a question 4u
10:20:02 <conal> Peaker: it's a special case.
10:20:03 <SamB> jkff: are you that impatiant that you can't see if she is able to post it ?
10:20:07 <Peaker> conal: yeah, indeed
10:20:17 <Peaker> conal: Didn't notice that before, cool :-)
10:20:25 <luite_> is there a standard function like replicateM, that I can use when each result depends on the previous? Monad m => Int -> (a -> m a) -> a -> m [a]  ?
10:20:28 <lilac> conal: i love the composability of mempty :)
10:20:36 <conal> Peaker: i didn't either until i designed the DataDriven library.
10:20:43 <jkff> Well.. You convinced me, I'm not that impatient :)
10:20:52 <conal> lilac: :)
10:20:55 <jkff> (SpringerLink wouldn't thank you :) )
10:21:02 <SamB> jkff: I don't care
10:21:12 <SamB> I don't like them since my school doesn't get that
10:21:12 <Peaker> @hoogle replicate
10:21:12 <lambdabot> Prelude replicate :: Int -> a -> [a]
10:21:13 <lambdabot> Data.ByteString replicate :: Int -> Word8 -> ByteString
10:21:13 <lambdabot> Data.List replicate :: Int -> a -> [a]
10:21:23 <jethr0_> newboy: sure
10:21:28 <Heffalump> @type iterateM
10:21:29 <lambdabot> Not in scope: `iterateM'
10:21:36 <Peaker> surely Applicative has a replicate too? I can't find it
10:21:42 <luite_> Heffalump: yes, it would be a combination of iterate and replicate
10:21:45 <dmwit_> newboy: Feel free to just ask your question.
10:21:46 <SamB> I don't much like ACM either, but at least my school gets a lot of those papers ;-P
10:21:51 <Heffalump> luite_: well, it would just be a take after an iterateM
10:21:56 <Heffalump> but iterateM doesn't seem to exist
10:22:02 <Heffalump> seems like it should :-)
10:22:03 <SamB> it's rather annoying to have to download them at school though
10:22:08 <luite_> Heffalump: that doesn't matter, I've already written my own
10:22:22 <jkff> btw I wonder whether they have the same thing that ACM offers: online access to all articles for a fixed yearly price. After half an hour of crawling their site it seemed to me that this statement is undecidable with the axioms they present.
10:22:28 <luite_> but I'm not sure if that would work with a monad
10:23:20 <Heffalump> luite_: oh, good point, laziness issues
10:23:30 <SamB> jkff: well, if not, that'd explain why my school hasn't got it ;-)
10:23:31 <newboy> ok . im not a programmer. but im trying to build a  web page one
10:23:58 <Peaker> luite_: iterateM f = sequence . iterate (>>= f)  ;  liftM (take n) . iterateM
10:23:59 <SamB> newboy: what does that have to do with Haskell ?
10:23:59 <newboy> i have the domain allready
10:24:07 <jkff> Oh god, I'm reading " . " in newboy's message as function composition.
10:24:15 <SamB> you wanted to learn to program websites in Haskell ?
10:24:28 * jkff leaves for half an hour
10:24:33 <SamB> ... did you want your brain stretched ?
10:24:36 <Peaker> luite_: the initial is an (m a) instead of a, which is actually more general
10:28:25 <Peaker> Heffalump: hmm, you gotta take before you sequence, so the N must be hard-coded into iterateM
10:29:41 <luite_> Peaker: hm, dat doesn't seem to work
10:29:49 <luite_> that
10:30:02 <Peaker> luite_: Yeah, I'm debugging it, its wrong ;)
10:30:14 <luite_> Peaker: the iterateM part works, but that's the part I already got :)
10:30:59 <Peaker> luite_: the iterateM part is also wrong, because: A) it creates an infinite bind-sequence,  B) it seems to feed the wrong value into the next action makers
10:31:23 <luite_> oh I just tested with () values
10:31:41 <Peaker> yeah, I shouldn't be using (>>=f) AND sequence
10:33:06 <luite_> my current iterateM just uses do notation: iterateM f x = do { y <- f x; ys <- iterateM f y; return $ x:ys }
10:33:21 <oshyshko> Is there any SCGI client-side implementation for Haskell?
10:33:49 <Peaker> luite_: also, this is a monadic operation, not an applicative one, so it can't possibly use sequence (which works on applicatives)
10:36:33 <Klaus> Hey folks,  got a little problem here and dont find the information i need :/
10:36:36 <Peaker> luite_: I'm not finding a more elegant solution..
10:37:12 <Peaker> luite_: does that work for you though? What stops the sequencing?
10:37:22 <lilac> conal: reduced testcase: http://hpaste.org/12528#a1
10:37:52 <Botje> perhaps luite_ uses an IORef to store iteration counts *runs*
10:38:08 * conal looks
10:38:14 <luite_> Peaker: the problem is that it doesn't stop, that's why I need a bounded version
10:38:41 <Cale> Peaker: Hm? Every monad is an applicative functor.
10:38:42 <conal> lilac: "fmap mempty" -- nice :)
10:39:04 <lilac> conal: too lazy to write (\_ -> return ()) :)
10:39:18 <Peaker> Cale: Yeah, if something requires Monadic-expressiveness, then it couldn't possibly just be a composition of applicative functions (like sequence)
10:39:29 <Peaker> Cale: (i.e sequenceA exists, so its an applicative-expressiveness function)
10:39:30 <Botje> Klaus: don't be shy, throw it in the group :)
10:39:44 <Klaus> just pasted
10:39:45 <Klaus> http://hpaste.org/12530
10:39:48 <conal> lilac: wonderful!  nice & simple failure.  it'll help me track down the bug.
10:40:03 <Klaus> would be thankfull for any help :)
10:40:18 <luite_> Peaker: seems that I was looking for this iterateM function: http://www.cs.chalmers.se/~bringert/darcs/botsplel/BotSplel.hs
10:40:23 <conal> lilac: i bet fixing the underlying bug will fix Peaker's problem also.
10:40:33 <lilac> conal: i'm pretty confident it's the same thing
10:40:45 <luite_> Peaker: oh wait, almost, it needs to collect a list instead of one value
10:40:52 <hackage> Uploaded to hackage: vcard 0.1.1
10:40:53 <lilac> conal: i wasn't aware that a haskell program could tell those two fragments apart, even
10:41:13 <conal> lilac:  i really appreciate the simplicity of this example.  would you mind adding a trac ticket?  http://trac.haskell.org/reactive/report/1?sort=ticket&asc=1
10:41:14 <lambdabot> Title: {1} Active Tickets - reactive - Trac
10:41:29 <dmwit> :t Test.QuickCheck.choose
10:41:31 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
10:41:36 <Botje> Klaus: you could use the oneof combinator?
10:42:03 <dmwit> Klaus: As a style thing, I'd prefer 'a' and 'z' over '\65' and '\90'.
10:42:04 <Botje> oneof [choose ('a','z'),choose ('A','Z'), return '*']
10:42:11 <dmwit> > ('\90', 'z')
10:42:12 <lambdabot>   ('Z','z')
10:42:26 <dmwit> Or 'A' and 'Z' if that's what they are. =)
10:42:50 <dmwit> :t Test.QuickCheck.oneOf
10:42:50 <Klaus> thx i'll try
10:42:51 <lambdabot> Not in scope: `Test.QuickCheck.oneOf'
10:42:52 <Peaker> conal: I think its need your composable folds :)
10:42:59 <Peaker> conal: s/its need/it needs
10:43:37 <conal> Peaker: oh, wouldn't that be fun.
10:46:21 <Klaus> parse error on input `coarbitrary'
10:46:28 <Klaus> :/
10:46:56 <Klaus> looks like what i was searching for anyway
10:47:24 <Peaker> luite_: I've got a pretty horrible solution :-)
10:47:53 <luite_> Peaker: ooh give ;)
10:48:14 <Peaker> > let iterateM n f is = liftM reverse $ last $ take n $ iterate (\cur -> do { results@(x:_) <- cur ; y <- f x ; return (y:results) }) (do { i <- is ; return [i] } ) in iterateM 2 (\x -> [x,x+1]) (return 1)
10:48:15 <lambdabot>   [[1,1],[1,2]]
10:48:29 <luite_> ok, at least in IO my iterateM never terminates :)
10:48:32 <Peaker> > let iterateM n f is = liftM reverse $ last $ take n $ iterate (\cur -> do { results@(x:_) <- cur ; y <- f x ; return (y:results) }) (do { i <- is ; return [i] } ) in iterateM 3 (\x -> [x,x+1]) (return 1)
10:48:33 <lambdabot>   [[1,1,1],[1,1,2],[1,2,2],[1,2,3]]
10:48:46 <athos> can one say that "one-way monads" are generally/often dealing with side-effects, and "two way monads" (list monad) don't have any side effects?
10:49:08 <Peaker> athos: I never heard the term "one-way" or "two-way" in the context of monads before
10:49:12 <vixey> athos, no
10:50:15 <Peaker> luite_: It could be simplified if you allow for the initial to be a value rather than an action, which would make sense, so:
10:50:36 <Peaker> > let iterateM n f i = liftM reverse $ last $ take n $ iterate (\cur -> do { results@(x:_) <- cur ; y <- f x ; return (y:results) }) (return [i]) in iterateM 3 (\x -> [x,x+1]) 1
10:50:37 <lambdabot>   [[1,1,1],[1,1,2],[1,2,2],[1,2,3]]
10:50:52 <Peaker> @undo do { results@(x:_) <- cur ; y <- f x ; return (y:results) }
10:50:52 <lambdabot> cur >>= \ a -> case a of { results@(x : _) -> f x >>= \ y -> return (y : results); _ -> fail ""}
10:51:12 <luite_> hehe, quite readable ;)
10:51:33 <Peaker> luite_: surely it could be broken down and composed somehow
10:51:58 <Peaker> @undo do { results <- cur ; y <- f x ; return (y:head results) }
10:51:58 <lambdabot> cur >>= \ results -> f x >>= \ y -> return (y : head results)
10:52:20 <lilac> conal: ticket 14
10:52:28 <Peaker> @pl \cur -> cur >>= \ results -> f x >>= \ y -> return (y : head results)
10:52:28 <lambdabot> ((`fmap` f x) . flip (:) . head =<<)
10:52:40 <conal> lilac: thx!
10:53:15 <luite_> hm, I should run @pl and @undo over all my code, to make it more l33t
10:53:21 <Peaker> > let iterateM n f i = liftM reverse $ last $ take n $ iterate ((`liftM` f x) . flip (:) . head =<<) (return [i]) in iterateM 3 (\x -> [x,x+1]) 1
10:53:22 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
10:53:22 <lambdabot>        Expect...
10:55:43 <Peaker> > let iterateM n f i = liftM reverse $ last $ take n $ iterate (ap ((>>=) . f . head) ((return .) . flip (:)) =<<) (return [i]) in iterateM 3 (\x -> [x,x+1]) 1
10:55:44 <lambdabot>   [[1,1,1],[1,1,2],[1,2,2],[1,2,3]]
10:55:57 <Peaker> heh, that's an ouchy PL :)
10:56:45 <athos> Peaker: it's formalism used in all about monads
10:57:12 <Peaker> luite_: so, does that work?
10:57:14 <luite_> Peaker: http://hpaste.org/12531
10:57:31 <luite_> this is what I have now, not very do-free or points free
10:57:32 <athos> one-way monad is something like io monad.. there's acutally no function that can take values out of the monad (its defined similar to that i mean), and two-way monad is list monad.. for example (!!) is a function which takes out the value of the monad
10:57:59 <Peaker> luite_: recursing yourself instead of iterate is probably a good idea here :-)
10:58:17 <luite_> Peaker: yeah I find it slightly more readable this way :)
10:58:22 <luite_> and I don't need reverse
10:58:35 <dolio> @let iterateM n f i = runStateT (replicateM n $ StateT f) i in iterateM 3 (\x -> [x,x+1) 1
10:58:35 <lambdabot>   Parse error
10:58:44 <dolio> > let iterateM n f i = runStateT (replicateM n $ StateT f) i in iterateM 3 (\x -> [x,x+1) 1
10:58:45 <lambdabot>   <no location info>: parse error on input `)'
10:58:51 <dolio> > let iterateM n f i = runStateT (replicateM n $ StateT f) i in iterateM 3 (\x -> [x,x+1]) 1
10:58:52 <lambdabot>       Occurs check: cannot construct the infinite type: s = (a, s)
10:58:52 <lambdabot>        Exp...
10:58:56 <dolio> Bah.
10:59:18 <Botje> athos: uh, (!!) is not related to the monad
10:59:27 <Botje> it's a generic list function
10:59:54 <athos> hm ok
10:59:56 <Cale> I think what athos means is that !! is related to the list monad in particular, which is true.
11:00:01 <dmwit> #define !! >>= -- how to confuse a Haskell programmer
11:00:22 <SamB> dmwit: only if cpp supported Haskell identifiers
11:00:28 <Peaker> you can "extract" the value out of the monadic value.  So I guess "two way monads" are monads where the value of type:  (Monad m => m a) already "has" the "a" inside it
11:00:35 <dmwit> SamB: It's working already, and I haven't even put it in any source yet! ;-)
11:00:57 <SamB> dmwit: what ?
11:01:03 <dmwit> See?
11:01:16 <SamB> oh oh oh
11:01:20 <Cale> What about the empty list though? Any function [a] -> a must be partial.
11:01:22 <Peaker> luite_: you're not handling the negative case, btw
11:01:28 <SamB> well, you are confusing me by claiming that it was working
11:01:36 <Klaus> im still stuck... could someone plz take a look?
11:01:37 <Giraffe> dmwit, are you trying to implement functional behavior in C++?
11:01:37 <Klaus> http://hpaste.org/12532
11:01:37 <SamB> I forgot what it was supposed to DO
11:01:39 <SamB> ;-P
11:01:49 <dmwit> =D
11:01:51 <Klaus> parse error on input `coarbitrary'
11:01:55 <Cale> But indeed, it's less partial than a function IO a -> a
11:02:12 <Cale> (which must be completely undefined0
11:02:13 <dmwit> Klaus: Don't mix spaces and tabs!
11:02:13 <Cale> )
11:02:15 <luite_> Peaker: that's true, it shouldn't be necessary. what would the result be?
11:02:25 <Cale> In fact, don't use tabs at all!
11:02:31 <dmwit> Cale++
11:02:52 <luite_> Peaker: I could use a guard to give it the same result as 0, or undefined?
11:02:54 <dmwit> Haskellers for Making Tabs a Lexical Error!
11:03:01 <Klaus> omg thx
11:03:37 <Cale> Klaus: It should be easy enough to configure your text editor not to leave tab characters in source files.
11:03:48 <mapreduce> s-expressions!
11:03:50 * mapreduce gibbers
11:03:55 <SamB> except Makefiles, of course
11:03:55 <Cale> Most of them have an option for automatically converting them into spaces.
11:04:06 <Cale> Who uses Makefiles? ;)
11:04:17 <SamB> well ... Debian!
11:04:23 <Peaker> > take (-5) [1,2,3]
11:04:24 <lambdabot>   []
11:04:26 <Klaus> k i look it up
11:04:27 <SamB> debian/rules is afiak supposed to be one
11:04:38 <mapreduce> I'd like an option for just matching the indentation of the file I'm editing.
11:04:42 <Peaker> luite_: I'd expect it to just be (return x) ?
11:04:44 <mapreduce> I think I could hack that into emacs.
11:04:48 <luqui> dmwit, that'd be nice.  I have a more lenient solution: make tabs and spaces incomparabl
11:04:49 <luqui> e
11:04:59 <Peaker> luite_: the 0 case should be the same as the negative case
11:04:59 <SamB> mapreduce: what if the file is empty ?
11:05:03 <luite_> Peaker: you mean return [x] ?
11:05:08 <mapreduce> Then go with my preference.
11:05:45 <luqui> dmwit, eg. "\t\t  " > "\t\t" > "\t", but comparing "\t\t" and "\t    " is an error
11:06:09 * dmwit nods
11:06:15 <dmwit> I approve of this message.
11:06:17 <Peaker> luite_: oops, yeah.
11:07:02 <luite_> Peaker: ok, I'll change it, just to be safe :) tnx for the help
11:07:29 <Peaker> luite_: I'm sure there's a nicer way to write this :)
11:08:31 <Cale> luqui: I would prefer the compiler to just choke on tab characters altogether.
11:08:37 <chrisdone> why can't I use 'type' as a variable? ;_;
11:08:46 <Cale> chrisdone: Because it's a keyword.
11:08:57 <luqui> Cale, not opposed :-)
11:09:29 <luite_> Peaker: possibly, but at least the code is quite readable now. I'm just starting to grasp monads, so I don't know any clever solution with 'advanced' functions, or applicative etc
11:09:59 <Cale> I think if there are tab characters in the file, even though they might not immediately be a problem, someone's eventually going to trip on them, supposing that the code needs to be maintained.
11:19:17 <Peaker> maybe someone can think of a way how to make this prettier: http://hpaste.org/12531 ?
11:19:23 <Peaker> @hoogle foldrM
11:19:24 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
11:19:44 <luite_> who's calling my code not pretty ;)
11:19:46 <dmwit> :t foldM
11:19:48 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:19:58 <Peaker> luite_: maybe foldM would do?
11:20:04 <dmwit> :t replicateM
11:20:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
11:20:24 <dmwit> Oh, I see that's not what you've got there.
11:20:36 <thoughtpolice> cool! http://muaddibspace.blogspot.com/2008/06/pure-type-systems-type-checker-in.html
11:20:38 <lambdabot> Title: Muad`Dib: Pure Type Systems type checker in Prolog, http://tinyurl.com/6zcam3
11:20:54 <luite_> dmwit: the difference is that it depends of the result of the previous iteration, so replicate doesn't work. maybe fold does
11:21:05 <luite_> hm, no, fold doesn't either
11:21:06 <dmwit> luite_: Right, I saw it after looking closer, sorry.
11:21:31 <dmwit> I'm not sure what's so bad about the current version.
11:21:35 <dmwit> It looks nice to me.
11:21:43 <luite_> dmwit: Peaker doesn't seem to like it :)
11:22:05 <dmwit> 0 f x -> return [x] -- is a bit odd, but probably defensible
11:22:08 <Peaker> I want a solution that is a composition of higher order stuff, rather than explicit recursion :)
11:22:24 <dmwit> (0 f x -> return [] -- makes more sense to me at first glance)
11:23:47 <Peaker> nah, its not a good case of foldM
11:23:50 <luite_> dmwit: yes, but the problem is the "return $ x:ys" in the other part. the 'problem' is that it returns the original x as the first element, [x, f x, f (f x), ...]
11:24:31 <Peaker> dmwit, luite_: The "n" is really the index, not the count, so its a bit confusing (perhaps due to the name suggesting its the arg to take)
11:24:32 <luite_> dmwit: so it would actually take one more element than the non-monadic: take n $ iterate f x
11:24:51 <luite_> but the first element is the same
11:24:59 <luite_> take 5 $ iterate (+1) 1
11:25:02 <luite_> oops
11:25:03 <luite_> > take 5 $ iterate (+1) 1
11:25:05 <lambdabot>   [1,2,3,4,5]
11:25:20 <dmwit> If there is *always* a first element, and it is *always* the argument... why bother having that part in the monad?
11:25:34 <luite_> hm, good point
11:26:06 <luite_> but then it would be slighly counterintuitive if you compare it to the iterate function
11:26:19 <Peaker> > let iterateTakeM 0 f x = return [x] ; iterateTakeM n f x = do { y <- f x ; ys <- iterateTakeM (n-1) f y ; return $ x:ys } in iterateTakeM 5 (return . (+1)) 1
11:26:20 <lambdabot>       No instance for (Show (m [a]))
11:26:20 <lambdabot>        arising from a use of `show' at <...
11:26:22 <dmwit> I disagree.  Let me annotate...
11:26:32 <Peaker> > let iterateTakeM 0 f x = return [x] ; iterateTakeM n f x = do { y <- f x ; ys <- iterateTakeM (n-1) f y ; return $ x:ys } in iterateTakeM 5 ((:[]) . (+1)) 1
11:26:33 <lambdabot>   [[1,2,3,4,5,6]]
11:27:17 <Liskni_si> oh, I guess I know what was the problem. Data.Binary allocs a 32k long buffer, but since I need only 4 bytes, it's bad
11:27:43 <Liskni_si> now I'll have to figure out how to make an encode method which does not create that long a buffer
11:28:15 <dmwit> luite_: http://hpaste.org/12531#a1
11:28:24 <dmwit> And from here, we might be able to work in mfix explicitly...
11:28:27 <dmwit> :t mfix
11:28:28 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
11:28:31 <duaneb> ok
11:28:39 <dolio> @type \f -> get >>= lift . f
11:28:40 <duaneb> could someone help me clean up this code? http://pasteall.org/3315/haskell
11:28:41 <lambdabot> forall a (m :: * -> *) a1 (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t, MonadState a (t m)) => (a -> m a1) -> t m a1
11:29:20 <duaneb> I'm not sure, for example, how to bybass the ugliness that is extractA
11:29:23 <dejones> Can someone help me with linker errors for gtk2hs?  http://hpaste.org/12533
11:29:53 <dejones> dcoutts, dcoutts_: Not sure if you're around, but I saw you're a project admin for gtk2hs.  I am having linker errors when building a simple window, http://hpaste.org/12533
11:29:59 <luite_> @src mfix
11:29:59 <lambdabot> Source not found. There are some things that I just don't know.
11:30:02 <dolio> We're all too busy golfing a probably useless function.
11:30:03 <dolio> :)
11:30:08 <duaneb> dejones: what os are you on?
11:30:09 <dejones> lol
11:30:10 <Deewiant> @src [] mfix
11:30:10 <lambdabot> mfix f = case fix (f . head) of
11:30:10 <lambdabot>            []    -> []
11:30:10 <lambdabot>            (x:_) -> x : mfix (tail . f)
11:30:18 <dejones> duaneb: Debian linux.
11:30:34 <dejones> duaneb: I installed the lib-dev packages for gtk and glib...
11:30:42 <luite_> @src State mfix
11:30:42 <lambdabot> Source not found. :(
11:31:18 <dmwit> duaneb: Start with this: [('d', (read, "0123456789")), ('o', (extractA . readOct, "01234567")), ...]
11:31:54 <dmwit> duaneb: As for extractA, why not lift it out of the parser?  It doesn't depend on any of the parsed values (except as inputs), so put it at the top level.
11:31:58 <duaneb> dmwit: I dunot understand.... I mean, thanks, but I don't get what you mean :P
11:32:07 <duaneb> dmwit: 'lift'?
11:32:17 <dmwit> duaneb: Okay, one thing at a time.
11:32:21 <duaneb> I'd love to, but I don't know of any other way aside from pattern matching :P
11:32:29 <Klaus> args got disconnected.... got a little question:
11:32:48 <dmwit> duaneb: First: all your cases have the same basic pattern: "liftM (Number . f) (many1 parser)", where "f" and "parser" vary between the lines.
11:32:53 <Klaus> im looking for a function like toUpper which can handle strings
11:33:05 <Cale> map toUpper
11:33:10 <dmwit> duaneb: So abstract that pattern; the code will become much clearer just from that single change.
11:33:18 <Peaker> dmwit: its not really a fixed point
11:33:27 <dmwit> Peaker: All recursion is really a fixed point.
11:33:50 <Peaker> dmwit: I mean, the name would be misleading
11:33:57 <dmwit> duaneb: That's suggestion one.  Suggestion two: don't define "extractA" in parseSpecialBase, define it at the top level.
11:33:58 <duaneb> ok
11:34:01 <luite_> dmwit: ah thanks for the mfix tip, it looks like I can use that
11:34:07 <Peaker> dmwit: you can find the fixed point of the recursion, but the function does not find the fixed point of its argument
11:34:07 <luite_> hopefully ;)
11:34:11 <duaneb> Isn't it kind of... specific? :P
11:34:19 <duaneb> I mean, I do use a similar function later
11:34:52 <dmwit> duaneb: Why bother with Haskell if you aren't going to use its higher-order capabilities? ;-)
11:35:37 <dmwit> And no, I don't think such a function is too specific.
11:35:45 <dmwit> It's very reminiscent of this one, actually:
11:35:45 <duaneb> dmwit: true
11:35:53 <dmwit> :t Numeric.readInt
11:35:54 <Klaus> working ty ;)
11:35:54 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
11:36:08 <dmwit> duaneb: In fact, you might just be able to use readInt for all of them. ;-)
11:36:20 <duaneb> Really, this is just me not wanting to name my functions
11:36:21 <duaneb> hmm
11:36:22 <duaneb> ok
11:36:24 <duaneb> I'll look into it
11:38:26 <dmwit> Peaker: you're right
11:39:36 <Peaker> dmwit: I think you fixed it so that the iterateTakeM name is not so bad
11:40:06 <dolio> > let liftf f = get >>= lift . f ; put' a = StateT (\_ -> return (a,a)) ; iterateM n f i = evalStateT (replicateM n $ liftf f >>= put') in iterateM (\x -> [x,x+1]) 1
11:40:07 <lambdabot>       The lambda expression `\ x -> ...' has one argument,
11:40:07 <lambdabot>      but its type ...
11:40:35 <dolio> > let liftf f = get >>= lift . f ; put' a = StateT (\_ -> return (a,a)) ; iterateM n f = evalStateT (replicateM n $ liftf f >>= put') in iterateM (\x -> [x,x+1]) 1
11:40:36 <lambdabot>       The lambda expression `\ x -> ...' has one argument,
11:40:37 <lambdabot>      but its type ...
11:40:42 <dolio> Geeze
11:40:52 <hackage> Uploaded to hackage: uniplate 1.2.0.3
11:40:52 <hackage> Uploaded to hackage: Hedi 0.1.1
11:41:03 <dolio> > let liftf f = get >>= lift . f ; put' a = StateT (\_ -> return (a,a)) ; iterateM n f = evalStateT (replicateM n $ liftf f >>= put') in iterateM 3 (\x -> [x,x+1]) 1
11:41:05 <lambdabot>   [[1,1,1],[1,1,2],[1,2,2],[1,2,3],[2,2,2],[2,2,3],[2,3,3],[2,3,4]]
11:41:07 <dolio> Still not right.
11:42:03 <dolio> > let liftf f = get >>= lift . f ; put' a = StateT (\_ -> return (a,a)) ; iterateM n f i = liftM (i:) $ evalStateT (replicateM (n-1) $ liftf f >>= put') i in iterateM 3 (\x -> [x,x+1]) 1
11:42:04 <lambdabot>   [[1,1,1],[1,1,2],[1,2,2],[1,2,3]]
11:42:53 <dolio> Finally.
11:43:37 <dmwit> > filter (and . ap (zipWith (<=)) tail) (replicateM 3 [1..3])
11:43:39 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],[1,3,3],[2,2,2],[2,2,3],[2,3,3],[3...
11:44:06 <dmwit> > filter (and . ap (zipWith (\x y -> abs (y - x) < 2)) tail) (replicateM 3 [1..3])
11:44:08 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[1,2,3],[2,1,1],[2,1,2],[2,2,1],[2,2,2],[2...
11:44:14 <dmwit> yuck!
11:44:25 <luite_> hm
11:44:51 <dmwit> > filter (and . ap (zipWith (\x y -> y == x || y == x + 1)) tail) (replicateM 3 [1..3])
11:44:53 <lambdabot>   [[1,1,1],[1,1,2],[1,2,2],[1,2,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]
11:47:47 <duaneb> haha
11:47:48 <duaneb> yes
11:47:52 <duaneb> I'm editing google results
11:48:01 <duaneb> suggested http://www.haskell.org/haskellwiki/Parsec for 'parsec'
11:48:03 <lambdabot> Title: Parsec - HaskellWiki
11:48:03 <duaneb> I feel powerful
11:50:30 <smtms> duaneb, I think Google simply learned enough about you to adjust its suggestions
11:50:53 <duaneb> smtms: no, there's a little link on the bottom where you can add results
11:51:01 <duaneb> if you're logged in
11:51:25 <dmwit> Gah, parsec is the most frustrating thing to search for.
11:51:32 <dmwit> ?go haskell parsec
11:51:45 <lambdabot> http://legacy.cs.uu.nl/daan/parsec.html
11:51:45 <lambdabot> Title: Parsec
11:52:11 <duaneb> I like ghc's docs better :P
11:56:16 <Peaker> duaneb: you can just "upvote" the haskellwiki result instead of typing it in
11:56:41 <duaneb> peaker: it wasn't on the front page and I was too lazy to look for it
11:56:57 <lilac> i've set -fbreak-on-exception in ghci, but :trace <something> followed by Ctrl-C and :history says "Empty history. Perhaps you forgot to use :trace?". what have i done wrong?
11:57:40 <Peaker> duaneb: Ah, it was on the front page for me, I think it was there before you edited it ;-)
11:58:04 <Klaus> http://hpaste.org/12535
11:58:16 <Klaus> still doing a little quickcheck thing
11:58:19 <dmwit> Peaker: He probably just promoted it from "on the front page" to "first hit returned".
11:58:24 <Klaus> i would like to prevent empty strings
11:58:43 <dmwit> augh
11:58:51 <Klaus> found some stuff but im not getting it to work
11:59:06 <chrisdone> mmorrow: ping
11:59:19 <duaneb> dmwit: no, I had to copy and paste :(
11:59:32 <Cale> lilac: I'm never quite sure what causes that. Is it possible that there's a .o file hanging around? (I'm not certain that would cause a problem, but it might.)
11:59:36 <chrisdone> mmorrow: ah, n/m. was going to ask where hpaste2 is. found it
11:59:37 <Peaker> Klaus: you can use:
11:59:46 <dmwit> map return (['a'..'z'] ++ ['A'..'Z'] ++ "*:/")
11:59:52 <Peaker> > map return ['a'..'z'] :: [Char]
11:59:53 <lambdabot>   Couldn't match expected type `Char' against inferred type `m a'
12:00:05 <Klaus> k that looks a little nicer ;)
12:00:20 <lilac> Cale: hmm. not in $PWD...
12:00:27 <dmwit> Also possible:
12:00:49 <dmwit> oneof [choose ('a', 'z'), choose ('A', 'Z'), return '*']
12:01:01 <Klaus> thats not that random
12:01:02 <Cale> lilac: When ghci loads the code, it says something like (Foo.hs, interpreted), right?
12:01:11 <Klaus> i got awful lot * when i use that
12:01:17 <lilac> Cale: i didn't give ghci any code
12:01:18 <dmwit> Klaus: So what?
12:01:32 <Peaker> aren't there instances of Arbitrary for Char/etc?
12:01:41 <lilac> Cale: just started it up and then did a bunch of 'import foo' followed by ':trace <something>'
12:01:47 <Cale> lilac: ah, okay
12:01:53 <dmwit> ?check \c -> c /= '\1414'
12:01:54 <lambdabot>   "OK, passed 500 tests."
12:02:01 <dmwit> Peaker: Seems to be. =)
12:02:05 <Klaus> dmwit your first guess looked fine :)
12:02:32 <Klaus> but what im after is a way to prevent empty strings from being checked
12:02:47 <Cale> lilac: I think it only traces through code which is being interpreted, and I'm not sure it counts things at the level of the expression which you entered directly into ghci.
12:02:53 <Klaus> like 50 % are empty
12:03:00 <luqui> Klaus, \xs -> not (null xs) ==> ...
12:03:00 <dmwit> ?check \c -> not (null c) ==> null c
12:03:01 <luqui> ?
12:03:02 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
12:03:02 <lambdabot>           ...
12:03:30 <dmwit> ?check \c -> not (null c) ==> length (c :: String) > 0
12:03:32 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
12:03:32 <lambdabot>           ...
12:03:37 <Cale> hmm
12:03:40 <mauke> lambdabot: your error messages suck
12:03:43 <dmwit> yeah
12:03:58 <lilac> Cale: ok. it also doesn't break on 'thread blocked indefinitely' when i use ghci myfile.hs
12:04:13 <dmwit> Klaus: Anyway, (==>) is the preferred way to do that, probably.
12:06:10 <Cale> lilac: Can I see the thing you're trying to evaluate?
12:06:52 <lilac> Cale: I'm trying to track down the hang in http://hpaste.org/12528#a1
12:07:19 <nomeata> Hi. I’m hitting a ghc bug when using HAppS, example code is provided in http://groups.google.com/group/HAppS/browse_thread/thread/7a4e890f2c8fccfd (second message)
12:07:21 <lambdabot> Title: 63-tuple bug - HAppS | Google Groups, http://tinyurl.com/5wdvd9
12:07:41 <dons> ?users
12:07:41 <lambdabot> Maximum users seen in #haskell: 555, currently: 542 (97.7%), active: 18 (3.3%)
12:07:53 <Cale> lilac: whoa...
12:07:59 <nomeata> Can someone please check if it still happens with ghc-6.10? And does anyone know a nice work-around? It’s really a show-stopper for my project here.
12:08:24 <lilac> Cale: i'm of the opinion that it's either an unamb bug or a ghc bug
12:08:56 <Cale> lilac: wait, what is this supposed to do?
12:09:06 <Cale> 'fails' and 'works' behave the same way for me.
12:09:09 <lilac> it's supposed to terminate normally
12:09:12 <Cale> (they do nothing)
12:09:21 <Cale> (and hang)
12:09:33 <lilac> for me, 'works' terminates normally, and 'fails' gives "thread blocked indefinitely"
12:10:14 <lilac> Cale: how bizarre. now 'works' fails for me too
12:10:22 * lilac backs out changes to unamb
12:10:37 <Cale> lilac: When compiled, both of them terminate with thread blocked indefinitely.
12:10:48 <Cale> lilac: When I run them in ghci, they just block forever.
12:11:17 <dons> nomeata: we were talking about this yesterday.
12:11:20 <dons> nomeata: ask Lemmih.
12:11:21 <lilac> hmm. perhaps 'works' has never worked, and it's just temporary insanity on my part
12:11:34 <dons> nomeata: seems like the generic serialisation scheme that's yielding huge tuples should be using a custom data type
12:12:17 <nomeata> dons: coudn’t it just use nested tuples?
12:12:19 <lilac> hmm. perhaps 'works' has never worked, and it's just temporary insanity on my part
12:12:24 <Cale> lilac: Well, they're *supposed* to be equivalent.
12:12:38 <lilac> oops, up-enter in wrong window :)
12:12:51 <dons> nomeata: i imagine it could do all sorts of things differently
12:12:56 <lilac> Cale: they're also both supposed to terminate
12:13:06 <nomeata> dons: hmm, ok :-). Can I help somehow?
12:13:18 <dons> nomeata: yes, tell Lemmih (happs maintainer)
12:13:27 <dons> someone else encountered this problem too
12:13:50 <dons> lispy: have you tried gitit yet?
12:13:58 <nomeata> @note Lemmih dons asked me to tell you that someone else encountered that 63-tuple-bug as well :-)
12:13:59 <lambdabot> usage: @vote <poll> <choice>
12:14:13 <Cale> lilac: I'm still shamefully somewhat unfamiliar with the reactive primitives, let me just look up what the definitions of these things are :)
12:14:36 <nomeata> nevermind, I’ll tell him in person when I hit him in IRC
12:14:50 <nomeata> dons: so the bug is still present in ghc-6.10? Is there a bug report I should monitor?
12:14:53 <mauke> preflex: seen Lemmih
12:14:53 <preflex>  Lemmih was last seen on #haskell 6 hours, 47 minutes and 26 seconds ago, saying: > break (==' ') "identi fier"
12:15:24 <dons> nomeata: i don't think the tuple limit is considered a bug
12:15:38 <dons> i think its considered a bug that happs generates ludicrously big tuples, instead of a more efficient data type
12:15:53 <nomeata> dons: exactly, but is it really a HAppS bug?
12:16:03 <nomeata> dons: the example I have is template-haskell-free...
12:16:08 <dons> well, happs shouldn't generate gigantic tuples
12:16:22 <dons> nomeata: but you need to talk to the happs devs
12:16:42 <nomeata> dons: yupp, I will
12:16:49 <nomeata> thx so far
12:17:19 <Peaker> is there any chance haskell-prime will get rid of N-tuples, and have only 2-tuples?
12:17:33 <dmwit> That doesn't seem too likely.
12:17:36 <Peaker> What's the advantage of N-tuples?
12:17:47 <dmwit> back-compat
12:18:01 <dons> they're simple.
12:18:17 <dmwit> low syntactic overhead
12:18:17 <arcatan> what's wrong with N-tuples?
12:18:29 <Peaker> but having just 2-tuples would save all those ugly instances up-to 64-tuples/etc
12:18:41 <dons> but that's a different data type
12:18:45 <Peaker> Look at :info Show
12:18:45 <dons> it has different bottoms
12:18:53 <dolio> They're more efficient than inductive tuples.
12:18:59 <pumpkin-> all this wisdom better bring me great benefit (fftw)
12:19:01 <dmwit> Peaker: Well, that restriction is pretty stupid, I agree.
12:19:03 <pumpkin-> a 63-tuple? :o
12:19:05 <pumpkin-> arcatan: they're hard to work with, I guess?
12:19:23 <Peaker> dons: surely one could build up the right kind of bottoms with just 2-tuple compositions?
12:19:37 <dmwit> Peaker: But I would prefer instances for N-tuples rather than the abolishment of N-tuples. =)
12:19:45 <Peaker> the N-tuple instances pollute my :show queries :-(
12:19:58 <Cale> lilac: Well, atTimes [] never occurs. So isn't the snapshot just going to block the thread forever?
12:20:12 <arcatan> pumpkin-: well, 63-tuples, i think so too
12:20:14 <Cale> er, hmm
12:20:20 <Cale> fmap mempty...
12:20:43 <idnar> Peaker: how would it save the instances?
12:20:46 <Cale> I'm not sure that's going to make things any better :)
12:20:59 <mauke> data a :*: b = a :*: !b
12:21:10 <Peaker> idnar: a single instance for a 2-tuple would work for all the compositions of 2-tuples
12:21:18 <pumpkin-> > mandel (0 :+ 1)
12:21:19 <lambdabot>   1.0
12:21:25 <idnar> Peaker: the instance for (a,a) is not likely to do what you want for (a,(a,a))
12:21:27 <mm_freak> :t (&&&)
12:21:29 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:21:34 <Peaker> idnar: the instance for (a,b), not (a,a)
12:21:44 <lilac> Cale: atTimes [] never occurs, so i should get an event which never occurs, so snapshot should return an event which never occurs, so adaptE should return immediately
12:21:47 <idnar> Peaker: er, yeah, I meant that
12:21:50 <mm_freak> > sin &&& cos $ 3
12:21:52 <lambdabot>   (0.1411200080598672,-0.9899924966004454)
12:21:55 <lilac> Cale: indeed that is what happens if you replace (stepper 0 x) with mempty
12:21:56 <Cale> lilac: Oh? Should it really?
12:22:05 <Peaker> idnar: I think it should
12:22:06 <pumpkin-> :t (***)
12:22:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:22:14 <idnar> Peaker: well, I suppose in some circumstances it would
12:22:20 <dons> its *so* nice having native packages for happs
12:22:25 <dons> makes things like gitit trivial.
12:22:30 <Cale> lilac: Can't there be cases where it wouldn't know whether there's another occurrence or not, and would have to wait forever?
12:22:32 <dons> every distro should be shipping happs.
12:22:40 <Peaker> idnar: If you just want to pair/group-up values, there should be an easy way to do it that gets all the instances.  If you want some specific group-size, you should define a specific type for that, probably
12:22:47 <lilac> Cale: there can be, but atTimes [] isn't one of them
12:22:54 <Cale> hmm, okay
12:23:00 <athos> is it possible to provide a function defined in terms of let with a type signature?
12:23:07 <Peaker> idnar: I am not sure the writer monad should be a simple 2-tuple under such a scheme, for example
12:23:11 <Cale> athos: yes
12:23:13 <athos> (i want to define some function in ghci and would like to specifiy the type of it)
12:23:20 <athos> Cale: how's the syntax?
12:23:29 <Cale> athos: Oh, you probably shouldn't be making definitions in ghci
12:23:30 <mauke> let f :: type; f x = ...
12:23:40 <Cale> athos: But you can write it like mauke shows.
12:23:47 <athos> thank you!
12:23:53 <pumpkin-> is there any way to get at a function in a module that isn't exported, without editing the module's source?
12:24:10 <dmwit> no
12:24:11 <luqui> pumpkin-, no!  and thank god for that
12:24:13 <pumpkin-> :P
12:24:23 <dmwit> athos: :{\nf :: type\nf x = ...\n:}
12:24:51 <lilac> Cale: "adaptE . fmap mempty $ atTimes []" /= _|_, "adaptE . fmap mempty . snapshot (atTimes []) $ mempty" /= _|_
12:24:57 <luqui> dmwit, still need a "let" somewhere
12:25:08 <dmwit> Ah, you're right.
12:25:35 <nomeata> @seen jgm
12:25:35 <lambdabot> I haven't seen jgm.
12:25:42 <lilac> Cale: scratch that second one, i was misrecalling
12:25:49 <nomeata> Is the author of gitit sometimes here, and under what nick name?
12:26:07 <dons> no, he doesn't hang out here.
12:26:25 <dons> but gitit is in arch, http://aur.archlinux.org/packages.php?ID=21349
12:26:36 <lambdabot> Title: AUR (en) - gitit
12:26:38 <dons> you can use the pkgbuild for inspiration, http://aur.archlinux.org/packages/gitit/gitit/PKGBUILD
12:27:01 <dons> this is why having lots of hackage in the distro is good -- people can feel free to add deps, knowing the distros can deal with it.
12:27:02 <lilac> Cale: although it does actually work :)
12:27:20 <dons> but say, on debian now, you'll first have to import a dozen other packages
12:27:26 <dmwit> pacman: The package manager that pretty much does nothing. =D
12:27:27 <dons> so its speculative packaging
12:27:28 <Peaker> @src (->) mempty
12:27:28 <lambdabot> Source not found. Are you on drugs?
12:27:39 <mm_freak> :t (***)
12:27:40 <Peaker> how can mempty be a first arg to fmap?
12:27:41 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:27:46 <dons> dmwit: it does slightly less than cabal-install
12:27:52 <nomeata> dons: Actually, I got a question to his HAppS state (Using getRandom inside an event and whether that might break when re-doing the event log)
12:27:55 <mm_freak> > sin *** cos $ (1,2)
12:27:56 <dmwit> :t fmap mempty
12:27:56 <luqui> Peaker, uh... I don't think there is one
12:27:57 <lambdabot>   (0.8414709848078965,-0.4161468365471424)
12:27:57 <lambdabot> forall a b (f :: * -> *). (Functor f, Monoid b) => f a -> f b
12:28:06 <dons> nomeata: oh, that's interesting!
12:28:07 <nomeata> dons: but I guess I should read the HAppS source first, maybe the answer is there
12:28:28 <dons> sjanssen: i do believe coppin thinks he's using a forum. lolz
12:28:28 <luqui> Peaker, oh, mempty = const mempty
12:28:30 <dmwit> ?instances Monoid
12:28:31 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:28:49 <dmwit> Peaker: The (a -> b) instance of Monoid uses the Monoid instance for b.
12:28:59 <mm_freak> @hoogle a (b,c) d
12:29:00 <lambdabot> No results found
12:29:08 <mm_freak> @hoogle Arrow a => a (b,c) d
12:29:08 <lambdabot> No results found
12:29:11 <dmwit> Peaker: So mempty = const mempty
12:29:20 <dolio> @type mempty :: (Monoid w) => a -> w
12:29:22 <lambdabot> forall a w. (Monoid w) => a -> w
12:29:31 <luqui> mm_freak, looking for something in particular?
12:30:17 <dons> yay http://www.reddit.com/r/programming/comments/7gimt/functional_programming_at_qcon_sf_haskell_for_the/
12:30:23 <lambdabot> Title: Functional Programming at QCON SF: Haskell for the Arts, for EDSLs and Scala : p ..., http://tinyurl.com/6dpsm9
12:30:29 <mm_freak> luqui: yeah, but i'm trying to figure it out on my own
12:30:38 <luqui> mm_freak, k =)
12:30:49 <Cale> lilac: okay, I see that  main = adaptE (fmap mempty (snapshot (atTimes []) time))  works fine.
12:30:49 <solrize_> but that conference already ended!!!!
12:30:55 <mm_freak> > sin *** cos >>> arr (\(x,y) -> x^2 + y^2) $ (1,2)
12:30:55 <duaneb> so
12:31:02 <duaneb> this code http://hpaste.org/12536? compiles without complaint
12:31:04 <duaneb> BUT
12:31:11 <duaneb> it doesn't parse octal number
12:31:11 <solrize_> :t (***)
12:31:14 <duaneb> numbers*
12:31:19 <duaneb> i.e. #o777
12:31:19 <mm_freak> lambdabot: you there?
12:31:29 <solrize_> @seen lambdabot
12:31:30 <solrize_> ;)
12:31:31 <duaneb> it complains that it was expecting #x
12:31:50 <dmwit> duaneb: It only parses hex, in fact.
12:31:59 <lambdabot> Yes, I'm here. I'm in #macosxdev, #haskell-blah, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #
12:31:59 <lambdabot> haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #
12:31:59 <lambdabot> dreamlinux-es, #darcs, #concatenative, #arch-haskell, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
12:32:00 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:32:00 <lambdabot>   0.8812516078417653
12:32:01 <dmwit> duaneb: You need to left-factor your grammar by hand, I'm afraid.
12:32:07 <mm_freak> hah!
12:32:10 <mm_freak> > sin *** cos >>> arr (\(x,y) -> x^2 + y^2) $ (1,1)
12:32:11 <lambdabot>   1.0
12:32:26 <mm_freak> great =)
12:32:41 <dmwit> > sin &&& cos >>> arr (\(x,y) -> x^2 + y^2) $ 1
12:32:42 <lambdabot>   1.0
12:33:38 <duaneb> dmwit: Well, it also parses regular decimal
12:33:39 <duaneb> i.e. '5'
12:34:42 <dmwit> Well, let me say the more correct thing: anything that expects to start with a '#' and comes after readHex in a list of <|>'s will never get run.
12:35:12 <dmwit> The solution is to either stick in "try" in a bunch of places or left-factor your grammar.
12:35:21 <dmwit> I recommend factoring, since it's so dead easy in this case.
12:35:34 <duaneb> hmm
12:35:38 <duaneb> I haven't learned this yet :P
12:35:42 <duaneb> time to research
12:35:48 <dmwit> I just mean use:
12:36:04 <kpreid> @check \t -> ((sin &&& cos) . uncurry (\(x,y) -> x^2 + y^2) ) t - 1 < 0.01
12:36:05 <lambdabot>       No instance for (Num (b -> c))
12:36:05 <lambdabot>        arising from a use of `^' at <int...
12:36:06 <dmwit> (char '#' >> (parseHex <|> parseOct <|> ...)) <|> parseDec
12:36:07 <athos> @hoogle mplus
12:36:08 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
12:36:15 <duaneb> ahh, I see
12:36:20 <mauke> (ax|ay)  ==>  a(x|y)
12:36:30 <duaneb> I thought it would try '#x' and then backtrack to "#o" if it failed
12:36:35 <kpreid> @check \t -> ((sin &&& cos) . (\(x,y) -> x^2 + y^2) ) t - 1 < 0.01
12:36:36 <lambdabot>       No instance for (Fractional (b, b))
12:36:36 <lambdabot>        arising from the literal `1....
12:36:42 <duaneb> I'm too optimistic, I guess
12:36:46 <dmwit> duaneb: "try" -- will transform it into a parser that does exactly that
12:36:53 <dmwit> try parseHex <|> try parseOct <|> ...
12:36:59 <pumpkin-> @src arr
12:36:59 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:37:00 <dmwit> but backtracking is so unnecessary here
12:37:06 <pumpkin-> :t arr
12:37:08 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
12:37:11 <kpreid> @check \t -> ((sin &&& cos) >>> (\(x,y) -> x^2 + y^2) ) t - 1 < 0.01
12:37:12 <lambdabot>   "OK, passed 500 tests."
12:38:22 <dolio> @check sin &&& cos >>> (\(x,y) -> x^2 + y^2) >>> subtract 1 >>> (<0.01)
12:38:27 <athos> > Just s `mplus` Nothing
12:38:34 <lambdabot>   "OK, passed 500 tests."
12:38:34 <lambdabot>   Just s
12:38:37 <Cale> lilac: hmm, the documentation for makeClock says that it makes a clock, given a way to delay actions, but it takes no parameters.
12:38:39 <duaneb> dmwit: well, yes, but this also cleared up another one of my errors with other parsing
12:39:19 <lilac> conal: fixed it! You need "snap mempty _ = mempty"
12:39:45 <luqui> :t (>>>)
12:39:46 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
12:39:49 <athos> hmm.. i just loaded up ghci with some example file, so the maybe monad is available to me, but not `mplus`
12:39:49 <conal> lilac: oh??
12:39:55 <athos> why's it like that?
12:40:10 <lilac> (Event (Future (Max MaxBound, _))) `snap` _ = mempty
12:40:11 <luqui> hmm, no category version?
12:40:15 <athos> lambdabot knows how to do Just s `mplus` Nothing
12:40:19 <conal> lilac: wow.  that's great!
12:40:46 <dmwit> ?index MonadPlus
12:40:46 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:40:49 <Cale> conal: What's up with the documentation for Clock/makeClock? :)
12:40:52 <hackage> Uploaded to hackage: tagsoup-ht 0.2
12:40:52 <hackage> Uploaded to hackage: CouchDB 0.8.1.0
12:40:55 <dmwit> athos: Have you imported one of those modules?
12:41:25 <lilac> conal: that seems to fix the tiny test case, but not resound
12:41:44 <dons> yay couchdb
12:41:58 <conal> lilac: oh.  good for me, but not so good for you.
12:41:59 <dons> we should put all the hackage-based web libs into a page, to say what they're good for
12:42:04 <conal> Cale: ??
12:42:12 <lilac> conal: i guess it's the same problem again further down the line
12:42:16 <dons> json layers, rpc stuff, serialisatoin, database backings, templating, sessions, crypto
12:42:16 <Cale> makeClock :: IO (Clock TimeT)	"Make a clock, given a way to delay actions."
12:42:21 <dons> and the network
12:42:31 <arcatan> dons: that would be nice
12:42:44 <conal> Cale: oh yeah.  doesn't fit.
12:42:47 <dons> yes. mmm "Haskell for the Web", new oreilly book in 2009?
12:42:57 <conal> doc/code skew
12:42:58 <arcatan> :)
12:43:07 <Cale> conal: It seems there's also some code mixed into the documentation for data Clock t
12:43:09 <athos_> ah you guys are right, my bad
12:43:13 <athos_> forgot to import Control.Monad
12:47:49 <FunctorSalad> does one (contrary to the user's guide) need some flag to get infix classes to work? ;)
12:48:25 <pumpkin-> do lhc/jhc sit on top of ghc, or are they completely separate programs?
12:49:00 <Peaker> lilac: doesn't "snap mempty _ = mempty" mean snap = const ?
12:49:29 <dons> pumpkin-: separate
12:50:13 <dolio> The only thing they need ghc for is to compile them (since they can't yet compile themselves).
12:50:15 <FunctorSalad> hmm, maybe :Elem isn't allowed
12:50:24 <FunctorSalad> (for an infix class)
12:50:26 <luqui> Peaker, it was shorthand, not code
12:50:47 <Cale> FunctorSalad: Like other infix operators, they have to be composed of symbol characters.
12:50:47 <luqui> Peaker, stated another way, it's an equation, not a definition
12:50:59 <Cale> FunctorSalad: Wait, infix class?
12:51:12 <Cale> FunctorSalad: I don't think that's doable. There are infix type constructors.
12:51:23 <FunctorSalad> Cale: :) http://haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons
12:51:35 <lambdabot> Title: 8.4.�Extensions to data types and type synonyms, http://tinyurl.com/3czedj
12:51:45 <Cale> FunctorSalad: okay.
12:51:46 <Peaker> luqui: Could be nice if it could be a definition..
12:51:56 <FunctorSalad> Cale: I think you're right, I tried :Elem because `Elem` isn't accepted either
12:53:37 <Cale> FunctorSalad: Try {-# LANGUAGE TypeOperators #-}
12:54:09 <dons> ?users
12:54:09 <lambdabot> Maximum users seen in #haskell: 555, currently: 543 (97.8%), active: 23 (4.2%)
12:56:25 <lilac> conal: the problem returns if you change atTimes [] to atTimes [0]
12:56:45 <dons> conal: have you had any contact with paul hudak on the new grand FRP projects at Yale?
12:56:50 <FunctorSalad> Cale: thans
12:56:53 <FunctorSalad> *thanks
12:56:56 <FunctorSalad> even :)
13:00:33 <lilac> conal: the fundamental problem, i think, is that you can't implement snapshot in terms of PrimReactive.snap, since the latter doesn't stop when its first argument is exhausted
13:06:17 <conal> dons: i've been in touch some with paul for a cacm paper, but i hadn't heard about a yale frp revival.  what have you heard?
13:06:46 <conal> lilac: oh.  hm.  looking...
13:07:33 <conal> lilac: i don't understand the problem with snap -- even with your snap/mempty fix.  mappend discards empty events, and fmap turns an empty to an empty.
13:08:07 <conal> lilac: so that: fmap fa mempty `mappend` fmap fb eb  ==  mempty `mappend` fmap fb eb  ==  fmap fb eb
13:08:50 <lilac> conal: the problem is that (Nothing, b0) `accumE` (fmap fa ea `mappend` fmap fb eb) can't stop until eb is exhausted
13:08:53 <athos> @hoogle maybeTolist
13:08:54 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
13:09:13 <conal> lilac: oh.  yeah.
13:09:16 <lilac> conal: you want (Nothing, b0) `accumE` (fmap fa ea `mappend` fmap fb (eb `untilE` lastE ea)), where lastE = last event with finite time
13:09:29 <lilac> or someting like that, at least
13:09:36 <dons> conal: see paul's "haskell and the arts" slides, http://qconsf.com/sf2008/tracks/show_track.jsp?trackOID=169
13:09:46 <lilac> some kind of unamb trick with the 'last time' is probably required
13:09:47 <lambdabot> Title: Tracks -> Functional and Concurrent Programming Languages Applied
13:11:03 <duaneb> Is there any difference between Int and Integer?
13:11:21 <nomeata> duaneb: Int is smaller
13:11:23 <mauke> duaneb: Int is fixed size
13:11:26 <nomeata> (SCNR)
13:11:32 <dons> > maxBound :: Int
13:11:34 <lambdabot>   9223372036854775807
13:11:34 <dons> > maxBound :: Integer
13:11:35 <lambdabot>       No instance for (Bounded Integer)
13:11:36 <lambdabot>        arising from a use of `maxBoun...
13:11:38 <dons> no maximum!
13:11:42 <mauke> Integer is hueg
13:11:50 <dons> > 10 ^ 100000
13:11:51 <vixey> > infinity
13:11:52 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
13:11:53 <lambdabot>   * Exception: stack overflow
13:11:57 <conal> dons: thx.  i hadn't seen the slides.  paul said he was going to show off my stuff.  apparently he demo'd http://conel.net/pajama during his talk.
13:12:01 <lilac> @src infinity
13:12:02 <lambdabot> Source not found. stty: unknown mode: doofus
13:12:04 <lambdabot> Title: conel.net
13:12:04 <dons> ohhh cool
13:12:10 <vixey> infinity = fix (1+)
13:13:03 <dolio> > infinity > 5
13:13:05 <lambdabot>   True
13:13:12 <mlesniak> Anyone would be so nice to take a quick look at http://hpaste.org/12538. I try to simplify a 4 line-function (not because it's so long but because there must be some more elegant, haskell-ish way)
13:13:24 <conal> lilac: thanks.  i understand my basic mistake now.  after the event is done, the reactive keeps pumping in nothings.
13:13:46 <duaneb> well
13:13:51 <dolio> @check (infinity >)
13:13:52 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
13:13:52 <lambdabot>          ...
13:13:55 <duaneb> the plural of 'dwarf' is 'dwarves'
13:13:59 <dolio> Oh, right.
13:14:03 <mlesniak> duaneb, :D Hehe, thanks
13:14:39 <lilac> conal: looks like
13:14:39 <mauke> didn't Tolkien invent 'dwarves'?
13:14:42 <vixey> @check (infinity >) .  fromInteger
13:14:43 <lambdabot>   "* Exception: Natural: fromInteger
13:15:07 <dolio> Heh.
13:15:12 <dmwit> :t minimum &&& maximum
13:15:13 <lambdabot> forall a. (Ord a) => [a] -> (a, a)
13:15:26 <dolio> @check \x -> x >= 0 ==> infinity > fromInteger x
13:15:27 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
13:15:27 <lambdabot>           ...
13:15:29 <dmwit> Note that this implementation is not very nice to the garbage collector.
13:15:54 <dolio> Hmm...
13:15:57 <conal> lilac: this snapshot def causes another terrible problem as well: it prevents recursive snapshotting from working correctly, which breaks recursive integration and with it most physical examples.
13:16:02 <duaneb> quick check: what's the plural of 'roof'?
13:16:03 <dmwit> (@mlesniak)
13:16:09 <idnar> :t (&&&)
13:16:10 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:16:10 <mlesniak> duaneb, at http://dict.leo.org/ende?lp=ende&p=thMx..&search=Dwarfs the dictionary says the plural is dwarfs... Anyway ;)
13:16:22 <lambdabot> Title: LEO Ergebnisse f�r "Dwarfs"
13:16:22 <mlesniak> duaneb, roofs? ;)
13:16:37 <mauke> [x1, x2, y1, y2] = [ f $ map g garden | f <- [minimum, maximum], g <- [x, y] ]
13:16:47 <duaneb> mlesniak: indeed, you win!
13:16:54 <conal> lilac: Chuan-kai Lin at PSU came up with a replacement, but it creates a space leak.  maybe you'd like to play with the problem.  i can ask Chuan-kai if he minds my sharing our correspondence on the subject.
13:17:01 <duaneb> mlesniak: ...except that the plural of dwarf is dwarves.
13:17:09 <duaneb> Just like the plural of hoof is hooves
13:17:18 <dmwit> :t ap
13:17:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:17:32 <mlesniak> duaneb, then the online dictionary is wrong. damn :) btw: any tip for simplifying the makeFence function? :)
13:17:36 <dmwit> :t ap [minimum, maximum]
13:17:37 <lambdabot> forall a. (Ord a) => [[a]] -> [a]
13:17:50 <idnar> duaneb: I'm pretty sure both "dwarfs" and "dwarves" are acceptable
13:17:57 <conal> lilac: if you fiddle with it instead of me, then i get to keep focused on relative-time, comonadic frp, and i get someone else familiar enough with Reactive to help improve it.
13:18:05 <dmwit> :t sequence [minimum, maximum]
13:18:06 <lambdabot> forall a. (Ord a) => [a] -> [a]
13:18:07 <mauke> @. pl undo [ f $ map g garden | f <- [minimum, maximum], g <- [x, y] ]
13:18:08 <lambdabot> ([x, y] >>=) . flip flip [] . ((:) .) . (. flip map garden) =<< [minimum, maximum]
13:18:09 <idnar> their pronunciations are also interchangeable, like many other -f words
13:18:17 <lilac> conal: i'm not sure i understand the recursive snapshot problem; let me think about it :)
13:18:26 <nomeata> mlesniak: one first simplificatin would be http://hpaste.org/12538#a1 – not sure if it is more elegant though
13:18:26 <vixey> :t flip flip []
13:18:28 <lambdabot> forall a c a1. (a -> [a1] -> c) -> a -> c
13:18:42 <vixey> I'm never going to learn that on
13:18:43 <vixey> I'm never going to learn that one
13:18:45 <nomeata> mlesniak: from there, one could use liftM4 to get rid of the variable names
13:18:55 <dmwit> ?undo [f (map g garden) | f <- [minimum, maximum], g <- [x, y]]
13:18:55 <lambdabot> concatMap (\ f -> concatMap (\ g -> [f (map g garden)]) [x, y]) [minimum, maximum]
13:19:01 <idnar> what on earth
13:19:05 <idnar> @unpl flip flip []
13:19:05 <lambdabot> (\ c f -> c f [])
13:19:11 <idnar> oh
13:19:13 <byorgey> I think the list comprehension is quite nice in this case.
13:19:22 <mlesniak> nomeata, thanks for this hints, now I now where I have to look further!
13:19:39 <byorgey> mlesniak: did you see mauke's nice simplification above?
13:19:48 <byorgey> using a list comprehension
13:20:00 <mlesniak> byorgey, no, thanks for mentioning.
13:20:07 <mlesniak> and thanks, mauke
13:20:24 <pumpkin-> anyone here compute (shannon) entropy in haskell before?
13:20:40 <pumpkin-> I get the feeling my function to do it is monstrously inefficient
13:20:50 <vixey> do you mean  approximate ?
13:20:59 <pumpkin-> hmm?
13:21:13 <vixey> how and what do you compute
13:21:33 <nomeata> mlesniak: version with liftM4 attached. but no further idea :-)
13:21:34 <cjb> pumpkin-: you could take a look at the haskell text compression algorithms
13:22:07 <cjb> they probably calculate information content somewhere
13:22:12 <mlesniak> nomeata, hehe thanks for you effort!
13:23:14 <pumpkin-> vixey: I find the number of occurrences of each symbol, divide by the total number of symbols, and sum the log probabilities, as per the definition (negating at the end)
13:23:28 <vixey> oh that simple
13:23:42 <pumpkin-> it's a pretty simple algorithm :P
13:23:55 <pumpkin-> I'm not trying to compute kolmogorov or anything ;)
13:24:06 <vixey> I guess that is what I was confusing in my head
13:24:22 <nomeata> mlesniak: or maybe just makeFence garden = let xs = map x garden; ys = map y garden in Fence (minimum xs) (maximum ys) (maximum xs) (minimum ys) -- not much smaller, but a bit more readable
13:25:38 <pumpkin-> http://hpaste.org/12539 anything jump out as being terrible in that function? (I'm still a newbie, so I do accept style suggestions too :P)
13:25:41 <mlesniak> nomeata, yes, right, but I trying to learn some of the more advanced concepts, and Monad.Reader is more in the right direction, even tough mauke's solution was quite elegant, too
13:26:18 <pumpkin-> I just realized I don't need the head &&&
13:27:54 <dmwit> seems fine
13:28:10 <dmwit> I might prefer
13:28:18 <dolio> @type let occurs = map snd . toList . fromListWith (+) . map (flip (,) 1) ; probs l = let o = occurs l ; t = sum o in map (/l) o in sum . map log . probs
13:28:19 <lambdabot> Not in scope: `toList'
13:28:19 <lambdabot> Not in scope: `fromListWith'
13:28:21 <dons> ok lads, who wants to beat python at   their own game? http://developers.slashdot.org/article.pl?sid=08/11/30/1722203
13:28:22 <lambdabot> Title: Slashdot | Solving the Knight's Tour Puzzle In 60 Lines of Python
13:28:39 <dmwit> pumpkin-: "probs = map (...) . group . sort" and "negate . sum . map (...) . probs $ xs".
13:28:50 * mlesniak thinks LOCs are a really bad metric
13:28:51 <dolio> @type let occurs = map snd . M.toList . M.fromListWith (+) . map (flip (,) 1) ; probs l = let o = occurs l ; t = sum o in map (/l) o in sum . map log . probs
13:28:51 <lambdabot> forall a. (Ord a, Floating [a]) => [a] -> [a]
13:29:07 <dolio> Hmm, that's wrong.
13:29:33 <dolio> @type let occurs = map snd . M.toList . M.fromListWith (+) . map (flip (,) 1) ; probs l = let o = occurs l ; t = sum o in map (/t) o in sum . map log . probs
13:29:34 <solrize_> what  a lame front page slashdot post
13:29:34 <lambdabot> forall a a1. (Ord a1, Floating a) => [a1] -> a
13:29:53 <dolio> There we go.
13:30:40 <dolio> solrize_: Yeah. Really below slashdot's quality control standard.
13:30:51 <dmwit> To be fair, one of its tags is "yawn".
13:31:03 <sciolizer> from the Python article: "I know, this code has 3 lambdas in 3 successive lines, I've gone a little too far"
13:31:32 <pumpkin-> dmwit: let me think about that for a moment :P
13:31:35 <shapr> Did anybody else get spam via the Facebook Haskell group? Will pay for homework?
13:31:49 <pumpkin-> dolio: let me think about that for a moment too :P
13:31:53 <Ferdirand> hilarious
13:31:54 <dmwit> Oooo, is the pay good?
13:31:55 <dons> yeah, get out and smack some heads
13:32:03 <dmwit> I'm thinking $100,000 or so ought to be a good start.
13:32:05 <Botje> it probably pays better than actual PhD work, too ;)
13:32:07 <Deeem> how can i get a list of all elements of a dataset?
13:32:26 <dmwit> Deeem: What's the type of the dataset?
13:32:38 <Deeem> data Col = A|B|C|D|E|F|G|H
13:32:39 <Deeem>    deriving (Eq, Ord, Enum, Show, Read)
13:32:45 <pumpkin-> :o
13:33:07 <dolio> Derive Bounded.
13:33:14 <dolio> Then do [minBound .. maxBound].
13:33:43 <dmwit> Oh, wow.  If that's the answer, then I *totally* misunderstood the question.
13:34:05 * dolio went out on a limb.
13:34:34 <dons> dolio: want to have a crack at the knight's tour?
13:34:43 <dolio> If it's anything else, I'm not sure we have enough information to answer the question. :)
13:34:48 <dons> i really think there's an opportunity to remind people while the list monad rocks...
13:34:56 <pumpkin-> lol
13:34:58 <dons> and why native code compilers stomp on interpreters ... :)
13:35:10 <dmwit> He's got the wrong representation of a chessboard.
13:35:21 <dmwit> Forget this 8x8 array, I want a 4x4xBool array.
13:35:28 <dmwit> ;-)
13:35:35 <dons> STUArray Bool !
13:35:41 <dons> cache packed bits ftw
13:35:41 <pumpkin-> there should be an active haskell quiz :P i've seen the ruby quiz port page, but not many people seem interested in it
13:35:43 <dmwit> hmph
13:35:51 <dmwit> 4x4xBool doesn't seem big enough, what am I thinking?
13:35:55 <dons> pumpkin-: it was very active a while ago
13:35:58 <mlesniak> pumpkin-, I'd be very interested in this
13:36:00 <pumpkin-> ah
13:36:04 <dolio> Ruby quiz stopped posting new problems to the website.
13:36:16 <pumpkin-> ah
13:36:35 <pumpkin-> it'd be nice to have an automatic evaluation system, in terms of code length, memory allocated when running, and execution time :P
13:37:14 <dolio> dons: I would, but I'm going to eat dinner soon. So someone else should do it.
13:37:17 <Deeem> hm, dunno but "[A..H]" does not work
13:37:34 <dmwit> Deeem: Did you derive Enum?
13:37:44 <dolio> dons: By the way, this is your whenever reminder that I need you to patch uvector for me to release uvector-algorithms. :)
13:37:51 <dmwit> If you did, then [A .. H] should work -- note the spaces.
13:37:51 <hydo> Assuming what I'm reading is correct, and Data.Array is distributed with ghc, is there an env variable that I need to set to get ghc to find it?  I just installed with the osx .pkg and i'm trying to compile the cabal libs.
13:38:04 <dons> dolio: yeah, what did i need to apply?/ the memcpy?
13:38:14 <dons> hydo: ghc-pkg list array
13:38:20 <dons> should show the array library
13:38:30 <Deeem> omg, why there must be spaces? :(
13:38:35 * RayNbow is going to mail a bookshop if they could get RWH in stock...
13:38:37 <defun> is possible to write a native code compiler for python in haskell? If so, how long would it take for an average programmer?
13:38:50 <dmwit> Deeem: Otherwise, it parses as looking for the (.) function in the A module.
13:38:54 <dolio> dons: Yeah. That's the main part (necessary for merge sort). I think there may also be an "unsafeZip" type thing in there for schwartzian transforms.
13:38:55 <dons> defun: of course it is possible.
13:39:01 <mauke> Deeem: because we like readable code
13:39:03 <dmwit> Deeem: Pretty funny, huh? =)
13:39:03 <pumpkin-> whee, I'm almost done generating my fftw wisdom :D
13:39:13 <dolio> dons: It's been a while since I looked at it.
13:39:14 <Deeem> this is damn unreadable :P
13:39:16 <dons> defun: python's not a well defined language, so it depends how much you want to implement
13:39:36 <hydo> dons: thanks for that, I didn't know about ghc-pkg.
13:39:55 <pumpkin-> @hoogle fromListWith
13:39:56 <lambdabot> Data.IntMap fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
13:39:56 <lambdabot> Data.Map fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
13:39:56 <lambdabot> Data.IntMap fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
13:39:57 <dons> but in the past people have implemented ruby, perl, scheme , forth and other compilers in haskell, without mucch troube
13:40:11 <hydo> I've got array-0.2.x, I'm assuming that's what I need.  Is there a conf file or something somewhere that I need to use to point ghc at its installed libs?
13:40:25 <dons> hydo: that's what you need. just add --make to the compile flags
13:40:35 <_JFT_> In the "is it possible" category of question I have a stupid one... Is there a way to test for "identity" of two "object" (not using STRef or IORef) or is there always only equality?
13:41:01 <Philippa> _JFT_: there's no notion of identity to test for
13:41:21 <Philippa> there may not be equality for a given type either, though
13:41:38 <hydo> dons: if you don't mind taking a look, http://img.skitch.com/20081130-re7hqt7nqpppspyxp242ya559c.jpg  It might explain things better.
13:41:50 <hydo> I should have shortened that... :/
13:41:57 <_JFT_> On my way to learning Haskell I was cruising along until I hit a major roadblock (which looks so stupid...) but I can't figure a proper way to represent the splice operation for quad-edges...
13:42:02 <Cale> _JFT_: Variables in Haskell are just names for values, they are not places where values are stored.
13:42:23 <Philippa> _JFT_: the worst case is to provide your own idea of identity
13:42:30 <_JFT_> that's what I thought.. I was wondering if there was some way ...
13:42:32 <Philippa> sometimes there're smarter alternatives
13:42:41 <hydo> oooh... ~/.ghc ... I missed that the first time.  Maybe it's stale from my other attempts at installing.
13:42:55 <duaneb> hmmm
13:43:00 <hydo> Yep.. that was it.  Thanks for the info, dons :)
13:43:03 <_JFT_> if you check this http://www.voronoi.com/wiki/index.php?title=Spatial_Data_Structures
13:43:04 <duaneb> the one thing I dislike about haskell is the !! syntax :P
13:43:05 <lambdabot> Title: Spatial Data Structures - VoroWiki, http://tinyurl.com/65pgf4
13:43:20 <_JFT_> you'll see that the Quad-edge represent a cyclic graph
13:43:35 <_JFT_> I"m stuck on trying to code a "thaw" and a "freeze" operation to operate the splice...
13:43:43 <shapr> dmwit: Nah, it's only 70 pounds
13:43:46 <_JFT_> looks so simple but yet I can't figure a way
13:43:49 <Philippa> duaneb: that's not even syntax, it's just an operator like any other
13:43:54 <_JFT_> (been blocked 2 months on this (shame on me))
13:44:06 <duaneb> Philippa: it's still a part of the lanbguage
13:44:07 <Philippa> _JFT_: yeah, you'll have to keep identity with your graphs if they're cyclic
13:44:23 <_JFT_> Philippa: so I just create a unique label and carry it myself^
13:44:23 <Philippa> duaneb: it's also an extremely rarely used part that you can readily replace
13:44:24 <_JFT_> ?
13:44:24 <mauke> duaneb: it's supposed to be ugly
13:45:01 <Cale> _JFT_: If you're implementing graphs, usually the best way is to explicitly record a Map from vertices to adjacency structures of some type (typically, a set of adjacent vertices, but it looks like your edges here are more interesting)
13:45:03 <defun> dos: thanks
13:45:04 <Philippa> _JFT_: yep - perhaps define your graphs as (Map Id Node, [(Id,Id)]) or something along those lines
13:45:26 <defun> are there any good, free books available on compiler writing that anyone can reccomend?
13:45:28 <Philippa> and yeah, what Cale said. You don't /actually/ want no structure to how you keep the collection of edges :-)
13:45:42 <_JFT_> Cale: the intereste in Quad-edge is that it is storing both the edge and face adjaceny simultaneously so it is fast to go from one to the other
13:45:56 <pumpkin-> does Ord imply Eq?
13:46:16 <shapr> dmwit: http://hpaste.org/12540
13:46:21 <Cale> pumpkin-: yes, if you want to implement an Ord instance, you're forced to implement an Eq instance as well.
13:46:24 <shapr> dmwit: Is that entertaining or what?
13:46:24 <_JFT_> pumpkin-: yes
13:46:39 <pumpkin-> thanks :)
13:46:59 <Philippa> _JFT_: if you get the basic idea of mapping a single-type chunk of imperative heap to Map Id Foo, you can pretty much translate the imperative version
13:47:01 <athos> @hoogle maybeToMonad
13:47:02 <lambdabot> No results found
13:47:07 <athos> ah, i see.
13:47:16 <dmwit> shapr: yow
13:47:22 <dmwit> shapr: A real heart-wrencher. =)
13:48:06 <_JFT_> Philippa: that's what my intuition tells me yet the implementation of a thaw/freeze has been avoiding me :P I didn't try to mark identity myself and that's probably why I failed I'll give it a shot! Thank you guys
13:48:29 <Philippa> yeah, you need identity the whole time
13:48:32 <Cale> _JFT_: I'm not sure what you mean by thaw/freeze
13:48:41 <Philippa> the minute you've lost it, you don't have the right data structure any more because you can't detect cycles
13:49:09 <Cale> Are you trying to turn a tying-the-knot sort of structure into something with explicit references?
13:49:12 <_JFT_> cale: basically I loved the idea of having a IArray "converted" to a MArray using a "thaw" operation and a "freeze" to go from a MArray to a IArray
13:49:29 * mux bought himself a core i7 and is looking forward testing DPH with it
13:49:39 <_JFT_> Cale: I wanted to replicate that interface for quad-edge since only splice need to update and all the rest of the operation are read-only
13:49:44 <Cale> _JFT_: My recommendation would be to stick entirely to immutable structures, but choose them in a smart way :)
13:49:44 <Philippa> right, so implement what we're talking about using arrays and you'll get that?
13:50:17 <Philippa> Cale: to be fair, if your dataset's big enough then log n is a nasty penalty
13:50:26 <Cale> At least, until you're absolutely certain that the logarithmic overhead is too much.
13:50:38 <_JFT_> Cale: I could'nt find a way to deal 100% in immutable for cyclic graph :( is there a way or are you suggesting that I forget about using that structure in Haskell?
13:50:55 <Philippa> _JFT_: the Map setup
13:51:05 <Philippa> basically, you encode mutability. Though Cale'll hate that description :-)
13:51:13 <_JFT_> Philippa:  then I'm out of Quad-edge so I failed...
13:51:14 <Cale> _JFT_: Look at  Map V (Set V), for a digraph.
13:51:15 <SamB> why will cale hate it ?
13:51:23 <SamB> Cale: do you hate it ?
13:51:37 <Cale> I'm not sure that I understand it ;)
13:51:48 <duaneb> I am madly in love with parsec
13:51:49 <Philippa> well, amongst other things it's bad because what you get's still "persistant"
13:51:51 <_JFT_> Cale: how does a digraph helps if my graph is cyclical (sorry if the question is dumb I don't understand :()
13:52:05 <Cale> _JFT_: Digraphs are allowed to have cycles.
13:52:10 <_JFT_> Oh!
13:52:29 <_JFT_> Thank you I'll take a look at that ! :)
13:52:31 <Philippa> the point is that V is "VertexID", or something that may as well be
13:52:33 <Cale> _JFT_: Consider the case where you have two vertices, and their corresponding set consists of the other vertex.
13:52:50 <Philippa> it's as good as a pointer
13:53:15 <Cale> I usually am not too concerned about efficiency, and will actually use something meaningful for my 'V'
13:53:26 <_JFT_> Philippa: actually if I understand correctly it wouldn't work
13:53:40 <_JFT_> look at this http://www.voronoi.com/wiki/index.php?title=Image:Quadedge.png
13:53:42 <SamB> Cale: well, I think most of us like to ...
13:53:42 <lambdabot> Title: Image:Quadedge.png - VoroWiki
13:53:56 <_JFT_> a quad is represented by exactly 3 pointer (data, rotation  and next)
13:54:33 <Philippa> _JFT_: Consider data Heap = Map Int32 Int32...
13:54:34 <_JFT_> simulating cycle between 2 edge isn't enough I need to be able to maintain those 3 pointer together atomically
13:54:46 <Philippa> ...that's not a problem
13:54:50 <_JFT_> Philippa: so simulating pointer?
13:54:54 <Cale> _JFT_: Forget about pointers ;)
13:55:18 <_JFT_> cale: I wish :P but seriously I think this is the first "anti-haskell" data-structure I have met :P
13:55:24 <Philippa> *right*. You've got the equivalent power - you can make arbitrary references within a graph, you can attach whatever data you want to vertices etc etc
13:55:43 <Cale> _JFT_: You have what might as well be a map from quads to triples, consisting of the data, rotation, and next.
13:55:51 <Philippa> Cale: not everyone thinks like that - sometimes it's better to start low level and raise the abstraction level upwards step by step
13:56:06 <_JFT_> Philippa: Ok I think I'm starting to understand what you mean... I'll need to wrap my head a bit better on this one !
13:56:07 <lilac> conal: i think i can make it work, but i need to change the signatures of the snapshot functions to take EventI rather than EventG
13:56:22 <Cale> _JFT_: For each quad in your structure, you want to store those three things, right?
13:56:45 <Cale> _JFT_: So it's a Map from quads to those three things.
13:57:01 <conal> lilac: give it a try that way.  then maybe we can generalize the I away
13:57:03 <_JFT_> Cale: that's a very good idea but then it becomes a table implemented quad-edge which is the first way I did mplement one
13:57:16 <_JFT_> I was trying to implement them in "native" struct...
13:57:22 <Cale> _JFT_: It's better than a table though, it's a Map, which is more efficient.
13:57:23 <Philippa> yeah. What Haskell is teaching you is that it's a case of same difference
13:57:42 <_JFT_> cale: sure but then I have the overhead of the memory management...
13:57:42 <Cale> _JFT_: You can do an update in a Map in log time/space.
13:58:11 <Cale> _JFT_: which is more or less the same as constant time, with some small constant.
13:58:14 <_JFT_> cale: yes, that was my first implementation and I had challenged myself to do a "proper" implementation maybe the first was the proper one lol
13:58:46 <_JFT_> Cale: I meant the allocate/free overhead in term of programmer control not the performance one ;)
13:58:51 <yuuki> @djinn a -> b -> b
13:58:51 <lambdabot> f _ a = a
13:58:59 <Cale> Unless you really had performance issues which were revealed by profiling to be caused by the use of that data structure, I would go that way.
13:59:06 <yuuki> @djinn a -> b -> a -> b
13:59:06 <Cale> oh
13:59:07 <lambdabot> f _ a _ = a
13:59:18 <Cale> Well, it's not hard to add some abstractions around this representation.
13:59:19 <Philippa> _JFT_: generational GC sorta changes the game there
13:59:22 <SamB> _JFT_: pffft, "control"
13:59:25 <Philippa> small allocations are cheap
13:59:31 <yuuki> @djinn a -> b -> a -> a -> b
13:59:32 <lambdabot> f _ a _ _ = a
13:59:36 <Cale> So that when you add new nodes, you update everything that needs to be updated at once.
13:59:43 <Philippa> d'oh, yeah
13:59:53 <_JFT_> Philippa: if I have to "allocate" a triplet "id" in a map and I have to know when it is no longer freed then I have to manage that manually
13:59:59 * Philippa will go away now, she's being distracted somewhat and keeps missing things
14:00:03 <Philippa> _JFT_: yeah, with you
14:00:17 <Philippa> (don't put the triplets in the map until you have to? It's a good starting point)
14:00:33 <_JFT_> Philippa: thanks for the help btw :)
14:00:41 <_JFT_> SamB:  eh eh
14:00:56 <Cale> _JFT_: Uh, the Map is freed when you stop using it, and parts are freed when you stop using them, usually by deleting them from the map, and letting the old map go out of scope.
14:00:59 <SamB> _JFT_: oh ... you mean you'll have garbage ?
14:01:26 <Philippa> Cale: it's the "deleting them from the map" that's bothering _JFT_, I think
14:01:32 <Cale> hmm
14:01:34 <_JFT_> I mean if I'm using map entries to represent node "I" must know when I no longer need them and get rid of them
14:02:09 <_JFT_> basically if I let the GC manage everything I"m fine, when it is no longer referenced it gets freed
14:02:17 <Cale> _JFT_: Couldn't you conceivably always need them again?
14:02:33 <_JFT_> if I manage that using a map I need to know and track if that entry is or not still required and if it should be manually removed from the map
14:02:53 <SamB> _JFT_: why do you keep old stuff in the map ?
14:02:59 <Cale> Won't the data structure always be transitively connected?
14:03:06 <solrize_> http://hpaste.org/12541  i haven't quite figured out how to backtrack with the list monad (knight tour problem)
14:03:12 <_JFT_> cale: not really, it's just that then I need to keep either keep track or run a graph "walk" to know what is dead wood
14:03:23 <_JFT_> cale: not after a splice which disconnect
14:03:31 <SamB> _JFT_: disconnect ?
14:03:36 <_JFT_> cale: in that case I ahve a dead quad-edge that should be GCed
14:03:42 <_JFT_> samb: yes
14:03:54 <_JFT_> http://www.voronoi.com/wiki/index.php?title=Spatial_Data_Structures check the splice
14:04:01 <lambdabot> Title: Spatial Data Structures - VoroWiki, http://tinyurl.com/65pgf4
14:04:16 <Cale> _JFT_: won't there still be a connected face there?
14:04:17 <_JFT_> SamB: basically the splice connect and disconnect quad-edge
14:04:37 <Cale> _JFT_: Perhaps I'm misunderstanding how this works...
14:04:54 <_JFT_> cale: not always, I am using Quad-edge to manipulate mesh where faces gets created and disposed as a result of a change of topology
14:05:13 <_JFT_> Cale: this is working in c++ (which I know hate) and I wanted to get a "cleaner" version working in Haskell
14:05:21 <Cale> In that case, I would just write something to remove an entire connected component from the graph.
14:05:23 <_JFT_> (which I now (not know))
14:05:39 <SamB> I don't see any nodes disappearing
14:05:46 <dancor> Cale: do you run lambdabot on ghc 6.10.1?  i can't get 'hint' to build
14:05:52 <Cale> dancor: I don't.
14:06:07 <Cale> lambdabot is still running on 6.8.3, afaik.
14:06:09 <_JFT_> SamB: not in that exemple if there was only 2 quad then you would :)
14:06:40 <_JFT_> SamB: I dont have a direct link to a good paper with proper intro to quad-edge, seeing the splice algorithm would make it clear
14:07:20 <Cale> _JFT_: You still end up with a face that has both the spliced-apart vertices in a cycle.
14:07:21 <dons> mux: an i7 eh?
14:07:27 <mux> yeah
14:07:34 <dons> what're the specs?
14:07:43 <Cale> _JFT_: or is that not the case?
14:07:49 <_JFT_> cale: no the splice takes care of updating 4 "pointers" to make sure it doesn't happens
14:07:54 <dons> mux: i've been talking to a guy at intel about more haskell support
14:07:58 <dons> so details are good
14:08:19 <Cale> _JFT_: Oh, I suppose if it disconnects the graph, that would be the outer face, so, I'm not sure what happens there.
14:08:21 <mux> dons: it has 4 cores builtin, 8 logical cores with HT, details on the net if you google for core i7
14:08:40 <mux> and finally an integrated memory controller and decent memory bandwidth like AMD cpus
14:08:40 <dons> yeah, the HT stuff.
14:08:52 <solrize_> mux you got a nehelem?
14:08:58 <mux> yup
14:08:59 <_JFT_> cale: here's the splice in CL http://hpaste.org/12542
14:09:01 <dons> mux: is the box online?
14:09:08 <dons> rl is doing the DPH benchmarking now
14:09:11 <mux> I'm irc'ing from it
14:09:18 <mux> it is barely installed for now though
14:09:29 <_JFT_> cale: that should clarify a bit. a quad never exist alone always in group of 4 (hence quad) linked by a rot which is immutable after ward
14:09:33 <dons> if you want to end up in a paper, mail rl@ about the box :)
14:09:44 <Cale> _JFT_: So yeah, I get the idea, but I still think that it's not so hard to write a function which restricts to a specific connected component, or deletes a connected component.
14:09:47 <solrize_> dons i've got an AMD Phenom (4 core version of Athlon) at work that i can probably get you some time on if you want
14:09:51 <_JFT_> cale: the 0 and 2 (are holding vertices) 1 and 3 holding face info
14:10:04 <mux> dons: alright, saw the announcement on reddit, but I just bought it today
14:10:16 <solrize_> nehalem is more interesting i guess :)
14:10:18 <athos> eventually it seems like monads are fucking awesome
14:10:34 <_JFT_> cale: what I tried in the past failed because both quad involved in a splice needs to be updated and each can be referenced by other etc it is a chain reaction :(
14:10:46 <solrize_> athos, yeah, they should have named them that, it's more attention grabbing than "warm fuzzy thing" :)
14:10:53 <athos> 8)
14:11:09 <dons> "fucking awesome combinators" ?
14:11:13 <mauke> class FuckingAwesome a where ...
14:11:16 <dons> sweet
14:11:18 <Cale> _JFT_: hmm...
14:11:19 <dmwit> What's a good infix name for replicate?
14:11:25 <mauke> dmwit: ×
14:11:26 <_JFT_> cale: so I thought a "proper" way was to use stref but then I failed at converting from an immutable graph to a mutable one done in STRef
14:11:28 <dmwit> **?
14:11:35 <dmwit> !
14:11:57 <_JFT_> cale: Philippa gave me a good advice, to track identity, that's where I failed I wasn't able to know if I had converted one or not...
14:12:43 <_JFT_> cale: I figure to convert from Immutable to Mutable I need 2 maps, one to hold the list of the already converted one to just refer to the result and another one which is the "worklist" of quad to convert
14:12:47 <dancor> Cale: do you think the eventual resolution will be fixing hint, or making lambdabot use ghc api directly?
14:12:55 <Cale> dancor: Fixing hint
14:13:12 <_JFT_> cale: (and by the way thank you for helping me solve that one !)
14:15:39 <dons> anyone having a go at the knight's tour 60 line bloatware?
14:15:48 * dmwit  
14:16:01 <dons> dmwit: go go go!
14:16:12 <dmwit> However, keep in mind that the 60-line limit includes a pretty-printer and a command-line parser.
14:16:30 <dmwit> So I don't know if "bloatware" is really so accurate... it's just "usable," I'd say.
14:17:08 <solrize_> dons i started
14:17:10 <solrize_> http://hpaste.org/12541  i haven't quite figured out how to backtrack with the list monad (knight tour problem)
14:17:50 <dons> looking good
14:18:27 <solrize_> it's a start but it's definitely not right ;)
14:18:47 <gwern> dancor: fixing hint should be relatively easy, easier than doing all the functionality in raw ghc api
14:18:54 * dmwit has a solver in twenty lines or so... but the pretty printer is ten lines and counting...
14:19:07 <dmwit> solrize_: I'll race ya! =)
14:19:10 <solrize_> dmwit i was gonna just print the list of coords
14:19:15 <dancor> gwern: yeah, i'm trying to figure out how GHC.Session has changed
14:19:30 <gwern> dancor: oh, ok :)
14:19:43 <gwern> I was just about to look at session myself but I'll be lazy and let you do it
14:19:43 <dancor> tho i also have to figure out how it use to work :)
14:20:16 <dancor> so far i can't find the 6.8.3 doc for GHC.Session
14:22:41 <Philippa> _JFT_: it sounds like you're going to do the memory management by something close to stop-and-copy :-)
14:23:23 <_JFT_> Philippa: that's why I wanted to try some other route that a quad-edge tables or map
14:23:36 <dons> dmwit: solving things in < 1s ?
14:23:50 <gwern> dancor: Session is atype iirc not module
14:23:53 <dmwit> dons: Still working. =)
14:23:54 <_JFT_> Philippa: I'll try to integrate your suggestion about managing identity and it might very well be the little bit I was missing...
14:24:07 <gwern> defined in HscTypes.lhs
14:24:29 <Philippa> *nod*
14:24:36 <Philippa> the fact you're only actually 'copying' references may help, too
14:25:02 <solrize_> http://hpaste.org/12541  improved ?
14:25:17 <_JFT_> Philippa: yes really what I want is an immutable version of the quad (I just want the mutable one to operate splice one it...)
14:26:10 <gwern> eek. this ghc monad stuff scares me
14:26:33 <dancor> well it kind of makes sense, no like accidentally calling newSession twice
14:27:12 <_JFT_> Philippa: , SamB:, Cale: thank you for the help guys! I'm off to write that thaw/freeze using identity!
14:27:15 <dancor> but yes it could have devestating repercussions on the structure of hint..
14:27:20 <gwern> dancor: well, I've mailed gorin a quick note to the effect that 'the proletariat are getting restless'
14:27:27 <dancor> cool
14:34:42 <dmwit> ?index getName
14:34:43 <lambdabot> bzzt
14:34:45 <dmwit> ?index getProgName
14:34:46 <lambdabot> System.Environment
14:37:46 <dmwit> dons: Okay, I implemented his naive version (+ pretty-printer and arguments parser) in 42 lines, and verified his slow times (sub-second 6x6, 6s 7x7, still-running 8x8).
14:39:35 <solrize_> dmwit, paste?
14:39:49 <solrize_> mine is generating answers but they are wrong ;)
14:39:56 <solrize_> http://hpaste.org/12541
14:40:33 <mauke> but is it FAST?!
14:40:49 <dmwit> http://hpaste.org/12543
14:40:54 <hackage> Uploaded to hackage: regexpr 0.5.1
14:41:50 <dmwit> I'm trying to verify his timings now...
14:44:31 <ivanm> dons: still no RWH down under :(
14:44:41 <dmwit> I must have done something wrong.  His code doesn't output what he says it outputs.
14:45:23 <doublec> ivan, my copy made it to sydney before jumping the ditch to auckland
14:45:32 <doublec> where it's currently sitting in customs somewhere I presume
14:46:00 <doublec> odd tracking path. From the US mainland, to honolulu, to sydney, to auckland
14:46:03 <doublec> that's a well travelled book
14:46:47 <Raevel> and now i'm jealous of a book
14:46:58 <ivanm> doublec: :o
14:47:02 <ivanm> who did you order it with?
14:47:09 <ivanm> s/with/from/
14:47:21 <doublec> ivanm, o'reilly. I did the PDF plus book deal
14:47:26 <ivanm> ahhh
14:47:37 <smtms> doublec, so you are reading the PDF now?
14:47:42 <doublec> smtms, yes
14:49:45 <dmwit> solrize_: Have you tested the code on ttsiodras' page?
14:50:33 <solrize_> dmwit nah
14:50:40 <dmwit> It doesn't work here. =P
14:51:52 <solrize_> i'm not sure what you're using data.map for--mine tries plain backtracking but maybe that's wrong?  anyway my mind is fogged so i'm not seeing where i'm messing up.  i'll probably mess with it more later, but i have to run some errands
14:52:24 <dmwit> Mine is plain back-tracking, too.
14:52:53 <dmwit> The Map tells the order that you visit each square.
14:53:02 <dmwit> If it's not in the Map, you haven't gone there yet.
14:53:08 <solrize_> hmm
14:53:25 <dolio> I wrote one, but it's too slow for 9.
14:53:37 <dolio> Even when sorting the successors.
14:53:42 <solrize_> i'm trying to generate a list with the moves in it
14:53:52 <solrize_> actually i guess i want a list of lists ?
14:54:18 <solrize_> i just use an integer as a bitmap saying which squares are visited
14:55:29 <EvilTerran> solrize_, wouldn't it be easier to use a UArray (Int,Int) Bool or something? I vaguely recall that UArray (...) Bool is bit-packed
14:55:45 <solrize_> evilterran maybe so, i'd have to read the docs :)
14:56:11 <solrize_> i only used a couple lines bit twiddling, it wasn't bad and seemed fairly well abstracted by the newtype
14:56:12 <EvilTerran> i may be wrong, mind
14:58:58 <dons> UArray * Bool is bit packed, yes.
14:59:02 <dons> as is STUArray
15:01:01 <solrize_> does the right thing happen when you pass those uarrays around as values, i.e. does it generate more or less the same code as bit twiddling on integers?
15:01:17 <solrize_> of course what i really wanted was unboxed int64..
15:01:38 <dons> yes.
15:01:43 <dons> well, just use Int64
15:04:22 <solrize_> yeah, i left it as Integer to not depend on the <= 8x8 board
15:04:33 <solrize_> Int64 would be unboxed?
15:04:59 <Philippa> most use cases would get unboxed when you turn the optimiser on
15:05:07 <solrize_> ic
15:05:10 <solrize_> cool
15:05:29 <Philippa> also: do you want Int64 or Word64?
15:06:10 <mauke> Nintendo64
15:06:28 <dmwit> Okay, I have a version that runs on 0.06s on a 31x31 board.
15:06:49 <dmwit> You have to take it above 100x100 for it to go above 1s. =)
15:07:03 <dmwit> 46 lines, but no comments...
15:07:05 <dmwit> yet
15:07:31 <solrize_> philippa, really just bits64
15:07:36 <solrize_> so i guess that would be word64
15:09:44 <dolio> dmwit: Nice. Code?
15:09:54 <dmwit> Let me clean it up a bit first.
15:10:01 <dmwit> I'm sure that will expand the line count, too. =)
15:10:56 <sciolizer> http://hpaste.org/12544
15:11:02 <sciolizer> Thought I would jump in on the knight problem fun. :)
15:11:12 <dolio> dmwit: What was your trick?
15:11:24 <dmwit> dolio: I just transcribed the code on the linked page.
15:11:39 <dolio> dmwit: Oh. :)
15:12:15 <solrize_> :t (//)
15:12:17 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
15:13:13 <sciolizer> :t (***)
15:13:14 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:13:55 <dmwit> http://hpaste.org/12545
15:14:02 <dmwit> The only thing I'm not proud of is printBoard.
15:14:20 <dmwit> urk
15:14:26 <dmwit> ?index comparing
15:14:27 <lambdabot> bzzt
15:14:31 <dmwit> boo
15:14:33 <dons> can people announce their solns on the list (and on slashdot? ) when they're done.
15:14:40 <dmwit> :t Data.Function.comparing
15:14:42 <lambdabot> Not in scope: `Data.Function.comparing'
15:14:46 <dmwit> :t Data.Ord.comparing
15:14:48 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
15:14:52 <mauke> @hoogle comparing
15:14:52 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:14:52 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:15:06 <dmwit> dons: The list?
15:15:20 <dons> -cafe@
15:15:30 <dmwit> oh
15:15:39 * dmwit is not subscribed to either slashdot or -cafe
15:17:15 <dmwit> huh
15:17:27 <dmwit> 101 and 103 complete in ~1s, but 102 takes a long long time.
15:17:36 <dmwit> I wonder if there is a knight's tour of a 102-board.
15:20:46 <roconnor> what about 100?
15:20:54 <dmwit> 100 completes way fast
15:21:05 <dmwit> 0.97 user, 1.164 total
15:21:13 <dmwit> (And this is a pretty old machine.)
15:21:50 <Philippa> dmwit: It's not too surprising if there's some spiky difference between odd and even, is it?
15:22:16 <dmwit> Not too surprising, but it's surprising if there's something spiky at 102 but not 98, 100, 104, or 106.
15:22:56 <Philippa> true
15:26:03 <dons> dmwit: so is that a complete solution, that is also shorter and faster than the python one? http://hpaste.org/12545?lines=true
15:26:14 <dmwit> No, let me paste a complete solution.
15:26:18 <dmwit> (It was missing an import.)
15:26:42 <pumpkin-> wow, I was gone for an hour and you've already pwned the python solution :P
15:26:48 <dmwit> dons: http://hpaste.org/12545#a1
15:27:12 <dmwit> dons: Shorter, faster, and doesn't run out of stack space for as big a board as I cared to let finish. =)
15:27:22 <pumpkin-> how about a 1000x1000 board? :D
15:27:35 <gwern> 'I'm a fan of gitit, and its 46 dependencies, that install via
15:27:35 <dons> feel free to mention this on slashdot, dmwit http://slashdot.org/comments.pl?sid=1046193
15:27:36 <gwern> cabal-install.'
15:27:36 <lambdabot> Title: Solving the Knight's Tour Puzzle In 60 Lines of Python
15:27:39 <gwern> hee hee
15:27:45 <dons> gwern: yes.
15:28:17 * gwern hadn't counted. what a wonderfully large number
15:28:44 <dancor> me not getting GHC.Ghc and MonadIO: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=518#a518
15:29:02 <dons> gwern: that's what cabal install --dry-run -v says were selected
15:29:10 <gwern> dancor: er, you might want to give your hint work a rest
15:29:11 <dons> is hschess on hackage?
15:29:18 <dons> would be interesting to use a chess library  ..
15:29:22 <pumpkin-> dmwit: did you use the linear algorithm mentioned in http://mathworld.wolfram.com/KnightsTour.html  ?
15:29:26 <lambdabot> Title: Knight's Tour -- from Wolfram MathWorld
15:29:30 <gwern> dancor: daniel said that he has the conversion almost compltely done, but he hasn't pushed it because a few tests fail
15:29:53 <roconnor> @type maybe
15:29:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:30:07 <dons> dmwit: i needed to import Data.Ord
15:30:18 <dons> and you use lookup at an overloaded type
15:30:21 <dmwit> pumpkin-: No, but I used the naive algorithm suggested there.
15:30:25 <pumpkin-> ah
15:30:30 <dmwit> dons: The annotation has Data.Ord imported.
15:30:33 <dons> instead of isNothing
15:30:45 <dons> ah got it
15:30:50 <dancor> gwern: i guess my question should be answered when i see his implementation
15:31:08 <gwern> dancor: I hope you haven't spent *too* much time hacking up hint...
15:31:17 <dons> dmwit: isNothing works with all ghc's
15:31:18 <dmwit> pumpkin-: Special cases do not appeal to me.
15:31:27 <pumpkin-> yeah, it sounds icky
15:31:27 <dmwit> dons: *nod* I'll change that locally.
15:31:28 <dons> while null depends on the monadic  return of lookup which has been removed
15:31:31 <dancor> gwern: no that's no problem, i just haven't spent enough time understand monad transformers..
15:31:47 <dons> so a typical example would be,
15:31:48 <dons>   $ time ./A 100
15:31:49 <dons> ?
15:31:56 <dmwit> right
15:31:59 <dons> sweet
15:32:04 <gwern> ok. I just know that when I spend an hour or two coding and stuff and i find the author had it done already, but hadn't made it public - it seriously torques me off
15:32:36 <dancor> gwern: i'm still enough of a noob that i consider that good bc i can "check my answer"
15:33:05 <dons> now parallelise it
15:33:31 * gwern reflects on the poorly named ~/.gnupg/
15:34:17 <idnar> @type null
15:34:19 <lambdabot> forall a. [a] -> Bool
15:34:23 <idnar> @type lookup
15:34:25 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:34:40 <idnar> @type isNothing
15:34:41 <lambdabot> forall a. Maybe a -> Bool
15:35:09 <idnar> isn't that just (== Nothing) ?
15:35:32 <mauke> @type (== Nothing)
15:35:34 <lambdabot> forall a. (Eq a) => Maybe a -> Bool
15:35:40 <mauke> observe the difference
15:35:51 <idnar> oh, huh
15:35:58 <idnar> I suppose that makes sense
15:36:37 <pumpkin-> @src isNothing
15:36:37 <lambdabot> isNothing Nothing = True
15:36:37 <lambdabot> isNothing _       = False
15:37:52 <mm_freak_> @pl a -> m b
15:37:53 <lambdabot> (line 1, column 3):
15:37:53 <lambdabot> unexpected ">" or "-"
15:37:53 <lambdabot> expecting variable, "(", operator or end of input
15:38:14 <dons> dmwit: you should put the final version on hackage
15:38:20 <dmwit> uh
15:38:21 <mm_freak_> @pl \m a b -> a -> m b
15:38:22 <lambdabot> (line 1, column 13):
15:38:22 <lambdabot> unexpected ">" or "-"
15:38:22 <lambdabot> expecting variable, "(", operator or end of input
15:38:22 <dmwit> seriously?
15:38:27 <mm_freak_> @pl \m a b -> a + m b
15:38:28 <lambdabot> flip ((.) . (+))
15:38:28 <dmwit> It's like... a toy 1-hour hack.
15:38:58 <dons> sure. but if you put it on hackage, we'll be able to refer to it in tutorials and so on
15:39:04 <dons> put it under 'Games'
15:40:54 <hackage> Uploaded to hackage: infinite-search 0.11
15:41:03 <walski> Hi
15:41:36 <dmwit> hi!
15:41:49 <walski> I've got a value which is "Maybe Char" or something like that. And a function where I need it as a Char and not Maybe Char ;)
15:42:04 <mm_freak_> hmm
15:42:05 <walski> So is there a way to say: give me the Char, otherwise explode?
15:42:12 <mauke> heh
15:42:17 <pumpkin-> walski: fromJust ?
15:42:21 <pumpkin-> or you can pattern match on it
15:42:28 <walski> AHHHH pattern matching again ;)
15:42:32 <pumpkin-> fromJust will explode in a manner suitable for your needs
15:42:33 <mm_freak_> newtype Kl m a b = Kl { runKl :: a -> m b }
15:42:36 <pumpkin-> if it's a Nothing
15:42:38 <mm_freak_> instance Monad m => Arrow (Kl m) where
15:42:38 <mauke> @src fromJust
15:42:39 <lambdabot> fromJust Nothing  = undefined
15:42:39 <lambdabot> fromJust (Just x) = x
15:42:54 <mm_freak_> that runs into the problem:      Could not deduce (Control.Category.Category (Kl m)) from the context (Monad m)
15:42:54 <pumpkin-> forGreatJustice
15:43:09 <mm_freak_> can anyone explain this?
15:43:23 <dmwit> Are you using category-extras.
15:43:27 <mm_freak_> no
15:43:33 <dmwit> Are you using GHC 6.10.
15:43:35 <mm_freak_> i have it installed, but i don't use it
15:43:37 <mm_freak_> yeah
15:44:13 <dmwit> So... my explanation is that 6.10 changed the Arrow hierarchy.
15:44:18 <walski> YEAH! Works great! Thank you guys!
15:44:22 <dmwit> I don't know if that is correct or not. =)
15:44:33 <mm_freak_> it's a pointer at least…  thanks
15:46:24 <mm_freak_> dmwit: indeed
15:46:28 <mm_freak_> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
15:46:36 <pumpkin-> hmm, I can use rnf to force a lazy list to evaluate, is there something similar for a CArray?
15:46:41 <lambdabot> Title: Control.Arrow, http://tinyurl.com/y6yt3s
15:46:51 <dmwit> Unfounded guesses win the day yet again!
15:47:23 <mm_freak_> (>>>) is now defined in terms of category morphisms
15:47:42 <mm_freak_> so you define (.) instead of (>>>)
15:48:00 <dmwit> Wow.
15:48:01 <dmwit> Awesome.
15:48:30 <dmwit> Do you have to import Prelude hiding ((.)) just to use Control.Category??
15:50:08 <mm_freak_> you need to import Category qualified
15:51:01 <mm_freak_> instance Monad m => C.Category (Kl m) where id = Kl $ return . id Kl g . Kl f = Kl (\x -> f x >>= g)
15:51:14 <mm_freak_> mh…  damn smart paste…
15:51:25 <dmwit> I get it.
15:52:18 <mm_freak_> hmm
15:52:51 <mm_freak_> since (->) is a category, it would make sense to import Prelude hiding (.)
15:53:13 <phosphoricx> I'm trying to figure out how to do let expressions using hugs, can someone give me an example? All the ones I've found do not work in hugs.
15:53:23 <mm_freak_> but how do i do that?  just import Prelude hiding ((.))?
15:53:31 <pumpkin-> I hear hugs isn't as good as ghc
15:54:05 <mm_freak_> phosphoricx: GHC allows let expressions in do-style in the interpreter
15:54:16 <dmwit> mm_freak_: You may need -fno-implicit-prelude
15:54:28 <dmwit> phosphoricx: Hmm, can you give an example of something that didn't work?
15:54:47 <phosphoricx> dmwit: let Just x = lookup "bar" [("foo", 1), ("bar", 2), ("baz", 3)]
15:54:48 <dmwit> I just tried "let x = 3 in x" in Hugs and it worked just fine.
15:54:57 <mm_freak_> there would be nothing wrong with hugs disallowing that, so you'd need to give the 'in' clause always
15:55:02 <dmwit> phosphoricx: Ah, yes, Hugs expects full expressions, so you need an "in" clause.
15:55:09 <pumpkin-> dmwit: can you specify an option like that in the source code with that special comment style?
15:55:19 <dmwit> pumpkin-: yes
15:55:27 <pumpkin-> cool
15:55:27 <dmwit> {-# LANGUAGE NoImplicitPrelude #-}
15:55:32 <mm_freak_> dmwit: is there an extension of some kind?
15:55:34 <dmwit> I believe...
15:55:35 <mm_freak_> ah, cool
15:55:38 <phosphoricx> dmwit: thanks, I'll try to figure it out using "let x = 3 in x" now
15:55:40 <mm_freak_> i'll give it a try
15:56:44 <mm_freak_> dmwit: the NoImplicitPrelude works, but somehow the hiding doesn't
15:56:50 <mm_freak_> {-# LANGUAGE Arrows, NoImplicitPrelude #-}
15:56:55 <mm_freak_> import Prelude hiding ((.))
15:57:02 <mm_freak_>     Ambiguous occurrence `id'
15:57:02 <mm_freak_>     It could refer to either `Control.Category.id', imported from Control.Category at test.hs:5:0-22
15:57:05 <pumpkin-> mm_freak_: I think you're getting prelude anyway, so that wouldn't make a difference?
15:57:05 <mm_freak_>                           or `Prelude.id', imported from Prelude at test.hs:8:0-26
15:57:23 <mm_freak_> pumpkin-: the NoImplicitPrelude is to prevent just that
15:57:33 <dmwit> mm_freak_: import Prelude hiding ((.), id) -- obviously ;-)
15:57:37 <pumpkin> mm_freak_: oh, I thought you meant without the noimplicitprelude
15:57:38 <mm_freak_> oh
15:57:40 <mm_freak_> d'oh lol
15:58:17 <mm_freak_> hey, that's actually cool…  Category should be merged into the Prelude
15:58:23 <pumpkin> is ap typically used infix?
15:58:28 <mm_freak_> pumpkin: yeah
15:58:33 <pumpkin> cool
15:58:37 <idnar> :t Control.Category.id
15:58:38 <lambdabot> Couldn't find qualified module.
15:58:44 <mm_freak_> using it prefix would look strange
15:58:45 <yuuki> @djinn (c -> a -> b -> b) -> c -> a -> b -> b
15:58:45 <lambdabot> f a = a
15:59:07 <mm_freak_> idnar: id :: Category c => c a a
15:59:11 <idnar> ah
15:59:35 <dmwit> :t (<*>)
15:59:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:59:49 <dmwit> pumpkin: Lots of people prefer to spell "ap" that way.
16:00:16 <pumpkin> oh I didn't make that connection
16:00:22 <pumpkin> that makes sense though
16:01:32 <mm_freak_> hmm, by Control.Category, Kleisli arrows are categories already, so to use (>>>) with them, you wouldn't need Control.Arrow at all
16:01:48 <mm_freak_> i like the new hierarchy
16:02:03 * dmwit guesses all Monads are Categories, or something is very broken
16:02:09 <idnar> @type (>>>)
16:02:10 <dmwit> No need for a Kleisli wrapper.
16:02:10 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
16:02:35 <mm_freak_> monads can't be categories, since a Category is a * -> * -> *
16:03:27 <mm_freak_> at least in the sense of Control.Category
16:04:04 <mm_freak_> and i failed to express a Kleisli arrow without an explicit wrapper
16:04:09 <dmwit> mm_freak_: Oh, okay.
16:04:39 <mm_freak_> but wait…
16:05:29 <mm_freak_> mh, nope…  you can't turn type synonyms into instances
16:05:37 <mm_freak_> type Kl m a b = a -> m b
16:05:49 <dmwit> H98 restriction, that is
16:06:12 <mm_freak_> ah yeah, there is an extension, too
16:06:16 <mm_freak_> TypeSynonymInstances
16:06:50 <mm_freak_> but still it doesn't work:
16:06:56 <mm_freak_> instance Monad m => Category (Kl m) where
16:07:03 <mm_freak_>     Type synonym `Kl' should have 3 arguments, but has been given 1
16:07:12 <vfgf> how do  declare a daa of cseicfic types?
16:07:27 <vfgf> liek data Edge listofnodes
16:07:34 <vfgf> or Map-of-nodes
16:08:43 <dmwit> data Edge = [Node]
16:08:46 <dmwit> err
16:08:50 <dmwit> data Edge = Edge [Node]
16:08:57 <dmwit> Either that or
16:09:00 <dmwit> type Edge = [Node]
16:09:28 <vfgf> data Edge = Edge (M.fromList ns)
16:09:34 <vfgf> is waht i want
16:09:36 <mm_freak_> @pl \a b -> f a (g b)
16:09:37 <lambdabot> (. g) . f
16:09:56 <dmwit> vfgf: I think you may be confused about what "data" does.
16:10:36 <mm_freak_> is there something like (.) for constructors?
16:10:38 <dmwit> "data" declares a new structured type, similar to (but more powerful than) C's "struct" and Java/C++/C#'s "class".
16:10:46 <dmwit> mm_freak_: Yes, the O type operator.
16:10:52 <dmwit> Oh, for constructors?
16:10:57 <dmwit> (.) works for constructors.
16:11:01 <dmwit> > Just . Just $ 3
16:11:02 <lambdabot>   Just (Just 3)
16:11:05 <mm_freak_> in a type definition
16:11:13 <dmwit> Yeah, then O is your guy.
16:11:14 <vfgf> Javas class is less powerful?
16:11:19 <pumpkin> dolio: you around?
16:11:24 <idnar> mm_freak_: you mean type constructors?
16:11:32 <dolio> Yeah.
16:11:41 <mm_freak_> idnar: yeah
16:11:42 <dmwit> vfgf: If you count inheritance, they're pretty similar.
16:11:49 <vfgf> but i want something contsutor like so i can call Edge with avriable nbr of arguments and have it return a Map
16:11:55 <pumpkin> dolio: I'm trying to figure out that entropy thing you wrote earlier, but it's giving me different results than I expect :o
16:11:56 <dmwit> vfgf: Maybe I should say "cleaner" rather than "more powerful."
16:11:57 <mm_freak_> type Kl m = (`O` m) `O` (->)
16:12:04 <ehird> vfgf: no such thing as varargs in haskell
16:12:06 <dolio> pumpkin: Well, it may not be right. :)
16:12:07 <mm_freak_> test.hs:11:13: parse error on input ``'
16:12:10 <ehird> (pedants: do not point me to oleg :P)
16:12:10 <dmwit> vfgf: That's just a plain old function.
16:12:12 <pumpkin> dolio: oh okay
16:12:14 <mm_freak_> do i have to write it prefix?
16:12:24 <dmwit> edge vs = M.fromList vs
16:12:41 <dmwit> vfgf: Or just "edge = M.fromList", or drop the definition entirely and just use M.fromList.
16:13:17 <mm_freak_> is there a 'flip' for type constructors?
16:13:17 <dmwit> mm_freak_: Probably you just can't partially apply it.
16:13:21 <dmwit> mm_freak_: Not sure, though.
16:13:28 <dmwit> Flip definitely exists, probably in the same module as O.
16:13:34 <mm_freak_> hmm
16:13:44 <mm_freak_> @hoogle Flip
16:13:45 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
16:13:45 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
16:13:45 <lambdabot> package Flippi
16:13:53 <pumpkin> http://hpaste.org/12547 seems to work okay, but it stack overflows (on my machine) for lists larger than 2^18 (I'm trying [1..(2^18)])... anyone know what would cause that?
16:14:06 <idnar> Flippi? heh
16:14:10 <mm_freak_> hehe
16:14:41 <jcpetruzza> hi, is anyone familiar with base-4 exceptions?
16:14:46 <dolio> dmwit: Your solution is way, way faster than mine, and I can't figure out what the difference is. :)
16:14:57 <dmwit> dolio: paste?
16:15:30 <dmwit> dolio: (I didn't do any optimizations, so it's certainly not that...)
16:16:21 <dolio> http://hpaste.org/12546#a1
16:16:42 <dolio> dmwit: Yeah... our solutions are slightly different on 8, but mine doesn't even complete 9. :)
16:16:55 <jcpetruzza> i mean, if you are getting an exception (from library code), but don't know its type, how do you determine it?
16:17:23 <dmwit> dolio: Your "successors" function isn't as smart as mine.
16:17:29 <EvilTerran> dolio, i note you could express "i' > 0 , j' > 0 , i' <= n , j' <= n" as "inRange ((0,0),(n,n)) (i,j')"
16:17:39 <dmwit> EvilTerran: Nice!
16:17:44 <dolio> Ooo, yeah.
16:17:58 <athos> which license does ghci use?
16:18:06 <dmwit> BSD3, I think
16:18:34 * erikc` just used his first <*>
16:18:37 <pumpkin> weird, the stack overflow seems to come from my use of sum
16:18:39 <athos> hmm.. i don't remember all the details but is it then save to use readline?
16:18:41 <erikc`> <3
16:18:43 <pumpkin> @src sum
16:18:44 <lambdabot> sum = foldl (+) 0
16:18:45 <athos> because clisp has to be put under gpl
16:18:49 <athos> because of using readline
16:18:54 <pumpkin> is that normal?
16:18:55 <dmwit> dolio: (Anyway, I think if you change your successors function to take a look at the actual board, you'll have just as fast a solution as I do.)
16:18:56 <dolio> dmwit: Oh! I need to filter the list by filled squares!
16:19:02 <dmwit> right
16:19:07 <dolio> Bah.
16:19:12 <athos> and rms thus said "hey, you use the great gpl'ed readline.. thats derivative work man!"
16:19:21 <EvilTerran> ?type inRange . join (***) (join (,))
16:19:23 <lambdabot> forall a. (Ix a) => (a, a) -> (a, a) -> Bool
16:19:38 <pumpkin> > sum [1..2^20]
16:19:38 <dmwit> athos: Correct.  6.10 now does not use readline =/
16:19:40 <lambdabot>   * Exception: stack overflow
16:19:41 <mm_freak_> the 'pure' function disappeared
16:19:45 <pumpkin> > sum [1..2^18]
16:19:46 <lambdabot>   * Exception: stack overflow
16:19:53 <athos> dmwit: ah ok
16:19:55 <pumpkin> > sum [1..2^15]
16:19:57 <lambdabot>   536887296
16:19:58 <mauke> athos: using readline is fine, the only problem is distributing derivative works
16:20:01 <mm_freak_> there is only 'arr' in GHC 6.10's base library
16:20:04 <idnar> > foldl' (+) 0 [1..2^18]
16:20:05 <lambdabot>   34359869440
16:20:15 <idnar> > foldl' (+) 0 [1..2^20]
16:20:16 <lambdabot>   549756338176
16:20:18 <pumpkin> is there an associated sum' ?:P
16:20:25 <EvilTerran> mm_freak_, yes, it was clashing with Control.Applicative.pure
16:20:29 <erikc`> o...my vi mode is gone from ghci in 6.10 :(
16:20:35 <idnar> I'm not sure why you'd want the version without '
16:20:37 <dolio> dmwit: That was it!
16:20:56 <pumpkin> idnar:
16:20:57 <pumpkin> ?
16:21:52 <idnar> pumpkin: what I mean is, there shouldn't be a sum', sum should just use foldl'
16:22:05 <pumpkin> yeah, makes sense
16:22:16 <vfgf> well there must be a way to have a data Edge that can take ints as inout and give a Map as output right?
16:22:17 <idnar> unless there's something I'm missing
16:22:17 <mm_freak_> ah, ok
16:22:28 <pumpkin> are things like that open to revision in a future version of the ghc prelude, or are they part of a standard?
16:22:47 <EvilTerran> both
16:23:05 <EvilTerran> more the latter
16:23:12 <mauke> erikc`: I've built ghci-6.10 with readline because editline sucks
16:23:26 <luqui_> idnar, the foldl' version of sum clashes with lazy numerals.  not that they're used very much
16:23:32 <idnar> luqui_: ah, of course
16:23:52 <EvilTerran> but there's always haskell' :P
16:23:53 <mm_freak_> compared to do-notation for Monad, the proc/do-notation for Arrow appears extremely smart and complicated to translate
16:23:57 <idnar> sum' it is, I guess ;P
16:23:58 <dmwit> vfgf: No.  That's a function, not a data type.
16:24:02 <vfgf> data Edge [(en, ns)] = Edge [(en, ns)]
16:25:14 <luqui> mm_freak_, the translation of proc notation is similar to the translation of mdo
16:25:21 <luqui> which is a bit more sophisticated
16:25:49 <RayNbow> idnar: what if you have an instance of Num for which you don't want to have a strict sum?
16:26:07 <vfgf> data Edge [(en, ns)] = Edge [(en, ns)]
16:26:10 <mm_freak_> i'll have to have a look at mdo again
16:26:22 <vfgf> so i canr have that in a construtore
16:26:49 <luqui> vfgf, the parameters on the left side of the = are type parameters.
16:27:03 <luqui> vfgf, so: data Edge en ns = Edge [(en,ns)]
16:27:13 <luqui> (depending on what you want, but that's one possibility)
16:27:16 <idnar> RayNbow: yeah, luqui mentioned that, I'd forgotten about that possibility
16:28:02 <idnar> RayNbow: although... wouldn't you want to use foldr for that?
16:28:21 <RayNbow> hmm...
16:28:38 <cknapp> #scheme
16:28:49 <cknapp> fail...
16:29:04 <idnar> @type Z
16:29:05 <lambdabot> Not in scope: data constructor `Z'
16:29:28 <vfgf> luqui: Couldn't match expected type `t1 -> t'
16:29:28 <vfgf>            against inferred type `Edgea en ns'
16:29:38 <vfgf> Edge 4 5
16:29:40 <skorpan> Edgea?
16:29:50 <vfgf> Edgea 4 5
16:29:56 <vfgf> data Edgea en ns = Edgea [(en,ns)]
16:30:22 <luqui> vfgf, yeah, Edgea :: [(en,ns)] -> Edgea en ns.  So the Edgea *function* is expecting a list
16:30:22 <RayNbow> idnar: good question, but I don't have an answer :)
16:30:40 <vfgf> luqui: Couldn't match expected type `t1 -> t'
16:30:49 <idnar> > 1 :: Natural
16:30:50 <lambdabot>   1
16:31:04 <luqui> vfgf, please paste and give more context.
16:31:13 <luqui> vfgf, hpaste.org
16:31:36 <vfgf> No instance for (Show (Edgea t t1))
16:31:36 <idnar> > sum [1..1048576]
16:31:38 <lambdabot>   * Exception: stack overflow
16:31:45 <idnar> > sum ([1..1048576] :: [Natural])
16:31:48 <lambdabot>   * Exception: stack overflow
16:31:56 <idnar> > sum ([1..1048576] :: [Natural]) < 5
16:31:59 <lambdabot>   * Exception: stack overflow
16:32:10 <idnar> > (foldr (+) 0 ([1..1048576] :: [Natural])) < 5
16:32:12 <lambdabot>   * Exception: stack overflow
16:32:20 <idnar> bleh
16:32:39 <skorpan> > 5 > sum([1..1048576] :: [Natural])
16:32:41 <luqui> vfgf, add "deriving (Show)" .   eg. data Edgea en ns = Edgea [(en,ns)] deriving (Show)
16:32:42 <lambdabot>   * Exception: stack overflow
16:32:47 <mm_freak_> is there a shortcut to arr (\x -> (x,x))?
16:33:06 <luqui> arr (join (,)) ?
16:33:10 <luqui> =P
16:33:15 <vfgf> http://hpaste.org/12548
16:33:20 <mm_freak_> that's not really a shortcut =P
16:33:21 <skorpan> > arr (join (,)) 5
16:33:23 <lambdabot>   (5,5)
16:33:29 <dmwit> dup x = (x, x)
16:33:37 <skorpan> > arr (dup 5)
16:33:39 <lambdabot>   Not in scope: `dup'
16:33:41 <skorpan> what the
16:33:49 <skorpan> > let dup x = (x, x) in arr (dup 5)
16:33:50 <lambdabot>   Couldn't match expected type `b -> c'
16:33:54 <dmwit> mm_freak_: Are you familiar with arrow notation?  You can often get around this stuff using it...
16:33:54 <skorpan> oh come on
16:33:55 <mm_freak_> skorpan: rather arr dup 5
16:34:02 <skorpan> > let dup x = (x, x) in arr 5
16:34:04 <lambdabot>       No instance for (Show (a b c))
16:34:04 <lambdabot>        arising from a use of `show' at <...
16:34:07 <skorpan> what am i doing..
16:34:14 <dmwit> > let dup x = (x, x) in arr dup 5
16:34:16 <lambdabot>   (5,5)
16:34:16 <skorpan> it's 1:30 am, let's blame this shit on that
16:34:26 <mm_freak_> dmwit: i know, but i'll try using the combinators…  i'm still not sure whether i understand arrows fully
16:34:34 * dmwit nods
16:34:42 <dmwit> Have you seen Wadler's version of arrows?
16:34:49 <idnar> @type (&&&)
16:34:51 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:34:55 <idnar> @type arr (\x -> (x,x))
16:34:56 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b (b, b)
16:34:57 <vfgf> luqui: http://hpaste.org/12548
16:34:57 <mm_freak_> that guy who wrote the parser?
16:35:00 <dmwit> They really helped me understand them.
16:35:03 <idnar> @type join (&&&)
16:35:04 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
16:35:05 <luqui> vfgf, yes, I saw
16:35:13 <luqui> vfgf, is this homework?
16:35:26 <idnar> wait, what am I doing
16:35:36 * idnar blames skorpan 
16:35:41 <mm_freak_> dmwit: if it's that parser guy, yeah…  i don't have a problem with the general concept
16:35:48 <mm_freak_> i'm just looking for use cases
16:36:00 <mm_freak_> something, where monads aren't enough
16:36:08 <luqui> vfgf, it's fine if it is
16:36:09 <vfgf> luqui: no
16:36:12 <vfgf> i want a better graph lib than the existing ones
16:36:21 <luqui> vfgf, oh
16:36:28 <idnar> mm_freak_: actually, I'd say arrows are for cases where monads are more than enough
16:36:30 <luqui> vfgf, you don't like fgl?
16:36:44 <luqui> (I never really did)
16:36:58 <idnar> mm_freak_: or maybe where monads are too much :P
16:37:04 <pumpkin> can anyone suggest any obvious ways to make my entropy calculation faster?
16:37:19 <EvilTerran> dmwit, was wadler's the one where there were "arrow abstraction" and "arrow application" as seperate primatives?
16:37:22 <mm_freak_> idnar: i don't understand…  monads describe computations with an explicit result type, and arrows add an explicit input type
16:38:00 <idnar> mm_freak_: meh, I'm probably too tired to be coherent
16:38:03 <dmwit> EvilTerran: yes
16:38:37 <luqui> vfgf, so first, I would suggest adding more structure to your Graph type.  eg. data Graph e n = Graph (M.Map Int [e]) (M.Map Int n)
16:38:37 <mm_freak_> like the list monad describes a computation with a non-deterministic result, i could try to write a non-determinism arrow, where the input is non-deterministic, too
16:38:42 <luqui> vfgf, or however you are using it
16:38:45 <idnar> mm_freak_: ArrowApply is basically equivalent to Monad
16:39:11 <idnar> mm_freak_: but not every arrow is "powerful enough" to define an ArrowApply instance
16:39:28 <luqui> mm_freak_, like quantum-arrow!  :-)
16:39:33 <idnar> and in fact, if you can define an ArrowApply instance, you probably might as well just use monadic combinators
16:39:34 <mm_freak_> ah, i get it
16:39:56 <erikc> can you use let's in do notation?
16:40:00 <mm_freak_> luqui: yeah, that's the arrow that brought me to finally learn that stuff =)
16:40:03 <luqui> erikc, yep.
16:40:15 <luqui> erikc, just leave off the "in"
16:40:20 <luqui> mm_freak_, yay :-)
16:40:50 <mm_freak_> couldn't you write a quantum monad?
16:40:54 <hackage> Uploaded to hackage: vector-space 0.5.1
16:41:21 <luqui> mm_freak_, I am not sure.  That was my "project" when I was first learning haskell, and I kept failing.
16:41:29 <luqui> mm_freak_, but I haven't tried since I've become fluent
16:41:39 <mm_freak_> ok
16:41:46 <athos> good night everyone
16:41:53 <mm_freak_> well…  somehow it appears to be natural
16:42:10 <mm_freak_> runQuantum would be observation…  until then, the state is coherent
16:42:18 <vfgf> luqui: ah fgl seems ok, i tired a graph lib in haskell before and hated it. but iwant to make my own anyway to improve my haskell skills
16:42:20 <idnar> schroedinger's arrow
16:42:35 <luqui> mm_freak_, what might be the representation?
16:43:06 <luqui> maybe just amplitudes: Quantum a = [(Complex, a)]
16:43:13 <mm_freak_> luqui: good question…  a list of states and coefficients
16:43:15 <mm_freak_> yeah
16:43:26 <luqui> hmm.  i wonder if anything is lost.
16:44:02 <luqui> oh, the problem is that you can't do inline observation
16:44:06 <luqui> I don't think...
16:44:26 <mm_freak_> you can, but probably that would make entanglement impossible
16:44:47 <doublec> woohoo, my real world haskell copy made it to NZ
16:44:59 <nmrp3> the new indexed types stuff looks fun
16:45:01 <dibblego> doublec, how did you manage that?
16:45:14 <luqui> mm_freak_, entanglement impossible --> not a quantum monad =P
16:45:17 <dolio> dmwit: http://hpaste.org/12546#a2 gets an aswer for 102.
16:45:28 <nmrp3> could it perhaps be tweaked to do things like picking the right option of foldl or foldr to minimize thunks, do you think?
16:45:29 <mm_freak_> luqui: yeah, that's my point =)
16:45:48 <mm_freak_> luqui: have you written that arrow?
16:46:11 <doublec> dibblego, I ordered the book+pdf and the book just arrived
16:46:14 <dmwit> dolio: do something sneaky?
16:46:27 <erikc> http://hpaste.org/12550
16:46:40 <erikc> hrm, i get a 'last statement of do notation must be expression' on this, without or without the 'in'
16:46:55 <dolio> dmwit: Not that I know of. It's the same algorithm, just using an exit continuation to report the answer (and uses STUArrays instead of a Map).
16:46:58 <luqui> mm_freak_, yeah
16:46:59 <mauke> erikc: indentation error
16:47:04 <dmwit> *nod*
16:47:11 <mauke> erikc: 'let' should be aligned with 'e_ident' above
16:47:18 <mm_freak_> luqui: cool, have you tried it with real quantum algorithms like shor or grover?
16:47:20 <dmwit> I figured mutable structures would be the next step for speed
16:47:24 <sciolizer> dons: did you make a wiki page for the Knight's tour problem?
16:47:43 <luqui> mm_freak_, no.  Those require fourier transforms, right?
16:47:51 <mm_freak_> only shor does
16:47:52 <dolio> dmwit: It's over 60 lines, though, much to my shame.
16:47:56 <luqui> mm_freak_, and I don't really know enough about quantum computation to implement that
16:48:15 <erikc> sorry, that was a paste error, it is aligned
16:48:47 <mm_freak_> grover is quite simple…  it's just a search algorithm, which modifies the amplitudes in a smart way, so the searched element is very likely the observation
16:48:51 <erikc> http://hpaste.org/12550#a1
16:48:53 <mm_freak_> it's an O(sqrt n) algorithm
16:48:54 <erikc> is what i have
16:49:47 <luqui> mm_freak_, reading :-)
16:50:34 <dolio> dmwit: It doesn't take significantly longer for 102 than anything around it, though. So I'm not sure why your code is so much longer on that case...
16:50:43 <dmwit> dunno
16:50:48 <litb> hmm
16:50:53 <dolio> (I modified mine into the ST code before remembering to check if it did the same thing)
16:51:28 <vfgf> how do i declare type Node = anytype?
16:51:39 <eu-prleu-peupeu> hey
16:52:06 <pumpkin> http://hpaste.org/12549#a1 isn't telling me much about what in the entropy function is taking the time... is there some way to ask it to?
16:52:14 <eu-prleu-peupeu> im planing on buying a laptop, which do you advise ?
16:52:21 <pumpkin> o.O
16:52:22 <dons> dmwit: interesting how slow the LogicT version is
16:52:39 <mm_freak_> luqui: however, you don't want to run it with large inputs on a classical computer, because it requires an O(n) quantum superposition ;)
16:52:45 <erikc> eu-prleu-peupeu: thinkpad t500
16:52:55 <eu-prleu-peupeu> heheh
16:52:57 <dmwit> dons: Did you check the most recent version?
16:52:59 <dolio> dons: You mean mine? I had the successor function wrong.
16:53:03 <eu-prleu-peupeu> they dont sell anymore :(
16:53:04 <erikc> if you are buying PC, thinkpad is the only way to go
16:53:09 <dmwit> dolio: Post your new one.
16:53:14 <eu-prleu-peupeu> thinkpad doesn't exist
16:53:18 <dons> dolio: oh? the 'wacky continuation version' ?
16:53:21 <erikc> uh, lenovo thinkpad t500 then
16:53:23 <dons> methinks we need a wiki page
16:53:27 <luqui> mm_freak_, do you mean to tell me that simulating a quantum computer on a classical one does not speed anything up!?   :-P
16:53:45 <dolio> dons: I wrote the original LogicT one. It needs a slight tweak to the 'successors' function to work right.
16:53:55 <dons> luqui: sounds impausible ‽
16:54:01 <dons> dolio: ah
16:54:08 <mm_freak_> luqui: no, i mean to tell you that grover is even worse than the classical 'try each element' search ;)
16:54:09 <pumpkin> I've never seen someone use an interrobang before
16:54:22 <luqui> mm_freak_, yeah I expected that.
16:54:28 <dons> anyone tried parallelising it
16:54:52 <dons> dolio: i like the 'wacky continuation version' that runs in 0.1s
16:54:56 * luqui wonders what the best parallel strategy for the knight problem would be.
16:55:07 <vaskaren> type Node can have any type i want, how do i declare that?
16:55:14 <luqui> yeah that's cool.  a bit of cleanup would be nice perhaps...
16:55:26 <mauke> vaskaren: that doesn't make sense
16:55:30 <dmwit> vaskaren: forall a. a
16:55:34 <mm_freak_> vaskaren: type Node = forall a. a
16:55:43 <mauke> the only value of that type is undefined
16:55:45 <dolio> :)
16:55:53 <mm_freak_> hehe
16:55:58 <luqui> I guess it's pretty nice.  the "tour" function confuses me though
16:56:24 <luqui> (only for it's complexity, it's operation is fairly straightforward)
16:56:32 <dons> so dolio's is the fastest i've seen atm.
16:57:08 <vaskaren> mm_freak_:doesnt wrk
16:57:20 <vaskaren> where do i get forall?
16:57:36 <mm_freak_> vaskaren: likely you don't want that "solution" anyway
16:57:37 <dolio> http://hpaste.org/12546#a3 is a fixed logict version. It takes bout 50% more time than the ST/Cont version.
16:58:12 <vaskaren> ok but can yous till say?
16:58:24 <dolio> dmwit: It works on 102, as well. Yours is doing something funky. :)
16:58:25 <mm_freak_> -XExistentialQuantification
16:58:43 <mm_freak_> but you won't be happy with that type
16:58:44 <dmwit> dolio: I refuse to dispute that.
16:58:48 <Gwern-away> dolio: out of curiosity, why not substitute in 'stop' pointlessly?
16:58:53 <Gwern-away> save you a good two lines
16:58:58 <mm_freak_> because it contains no information, so you can't do anything with it, other than building a list of thunks
16:59:11 <luqui> mm_freak_, -XRankNTypes actually, I think
16:59:33 <mm_freak_> luqui: i use -XExistentialQuantification, and it works
17:00:03 <dolio> Gwern-away: Yeah. Some of the functions are artifacts of the various implementations I tried, and I didn't bother to delete them.
17:00:05 <luqui> ok.  I'm not really sure about the various features enabled by those related flags
17:00:12 <Gwern-away> ah
17:00:29 <luqui> vaskaren, you might look into Data.Dynamic.  But more likely you want a strongly typed polymorphic function.  What are you trying to do?
17:03:34 <mm_freak_>     Cannot match a monotype with `forall a. (Num a) => a'
17:03:39 <mm_freak_> map show ([3,4] :: [forall a. Num a => a])
17:07:08 <vaskaren> luqui: i just want a data or type Node that can be of any type
17:07:36 <vaskaren> or it might make more sense to restrict it
17:07:42 <vaskaren> to int/string
17:07:58 <luqui> vaskaren, well that part is easy.  but what are you trying to do, in a larger sense.
17:08:31 <vaskaren> im just experimenting, i might not even need edge or node as a specific type. as i sid im writing a graph lib
17:08:46 <dmwit> vaskaren: Don't declare anything, and just use "node" everywhere in your types instead of "Node". ;-)
17:08:52 <luqui> vaskaren, ah, but your name changed, so I didn't make the connection :-)
17:09:20 <vaskaren> but htat sugly and not pattenrmatchable
17:09:26 <vaskaren> ah ok
17:09:56 <luqui> vaskaren, yeah typically you would parameterize your type on the type of nodes.
17:10:16 <luqui> (or just, as dmwit said, use the polymorphic node type directly)
17:10:40 <vaskaren> how?
17:10:53 <vaskaren> type Node = String | Int doesnt work
17:11:11 <luqui> vaskaren, it does, you just need to give the constructors names.
17:11:38 <luqui> data Node = NodeString String | NodeInt Int, or something
17:11:56 <dmwit> data Node a = Node a
17:12:03 <luqui> but more likely you mean  data Graph n = ..., where n is the node type
17:12:08 <dmwit> right
17:12:20 <vaskaren> but usin data id just use data Node v = Node v
17:13:24 <vaskaren> but then i cant mix node and edge
17:13:33 <vaskaren> data Graph e n = Graph e n
17:13:33 <vaskaren>                  deriving(Eq, Ord, Show)
17:13:35 <vaskaren> i have
17:13:48 <vaskaren> i was just trying to make specificn types and atas for nodes and edges
17:14:46 <vaskaren> addNode (Graph e n) v = Graph e (M.insert v 0 n)
17:14:59 <vaskaren> so i want edges and nodes to be amps
17:15:14 <luqui> maps you mean?
17:16:03 <luqui> so data Graph e n = Graph (something) (M.Map n Int)... i.e. a Graph holds a map of nodes.
17:16:07 <luqui> not just a single node.
17:16:25 <Dylan_> Hi uhm, in my application I have Dim UName As String = 5 but its not working? How to fix?
17:16:44 <dmwit> 1. wrong channel
17:16:45 <luqui> the type of addNode is Graph e (M.Map n Int) -> n -> Graph e (M.Map n Int)
17:16:49 <dmwit> 2. WTF?
17:16:52 <Dylan_> lol
17:16:56 <Dylan_> Trolling irc is fun.
17:17:25 <luqui> dmwit's response was good
17:17:41 <luqui> vaskaren, whereas you probably want it to be Graph e n -> n -> Graph e n.
17:19:48 <olahol> how do i input hex numbers in haskell? \x?
17:20:13 <dmwit> > 0x37
17:20:14 <lambdabot>   55
17:20:20 <olahol> ah
17:20:21 <olahol> thanks
17:20:42 <luqui> > 0o77
17:20:44 <lambdabot>   63
17:20:49 <luqui> > 0o777
17:20:50 <lambdabot>   511
17:21:08 <luqui> > 0o0  -- oh boy, a new face to use!
17:21:10 <lambdabot>   0
17:21:38 <dmwit> > ("_") -- i am a robot
17:21:39 <lambdabot>   "_"
17:21:44 <luqui> > (:[]) 0o0
17:21:45 <lambdabot>   [0]
17:22:00 <dmwit> > (,) 0o0 "_"
17:22:01 <lambdabot>   (0,"_")
17:22:16 <dmwit> > ('v')
17:22:18 <lambdabot>   'v'
17:22:22 * luqui doesn't get (,)
17:22:32 <dmwit> well... it was vaguely symmetric
17:22:35 <dmwit> So I went with it. =P
17:22:38 <luqui> =)
17:23:30 <luqui> > (==) [0o0] (^^)
17:23:31 <lambdabot>   Couldn't match expected type `[t]'
17:23:33 <luqui> oops
17:24:52 <vaskaren> should nodes have an optional param? so it can contain something? like now i have that and default it to 0
17:25:02 <vaskaren> should it have like a cost function
17:25:34 <vaskaren> if i want to model traveling salesman then i have a graph but how do I model the distance from city a to city b?
17:26:45 <dmwit> Is this for exercise, or do you just want to use a graph library?  Because Data.Graph does pretty much everything I've ever needed out of a graph library.
17:26:54 <dmwit> If it's for exercise, then by all means, go ahead.
17:27:01 <dmwit> Weighted graphs are a fun representational challenge. =)
17:29:06 <vaskaren> ok when i treid a haskell grpah lib last time it sucked but mabe i didnt give it enough time and well im a noob anyway so probably i wont make anything better. but iw ant to learn graphs better so what better way than creat e alib? i want to implement dijkstras algorithm and do a simple travelling salesman soler
17:31:30 <mm_freak_> vaskaren: i haven't followed the entire chat, but it looks to me that you come from another language, likely imperative
17:33:13 <Trafalgard> Will you be naming your travelling salesman Willy Loman?
17:33:29 <vaskaren> no, Simon Peyton Jones
17:33:33 <vaskaren> i come from Python
17:33:40 <vaskaren> i travel with dictionary
17:33:53 <idnar> haha
17:34:34 <Philippa> in Haskell, the dictionary travels with you
17:35:49 <pumpkin> lol
17:35:50 <Cale> vaskaren: I recommend representing graphs using Map Vertex (Set Vertex)
17:36:05 <ivanm> vaskaren: there's quite a few graph libs
17:36:06 <Cale> (where Vertex is any appropriate type)
17:36:16 <ivanm> fgl has dijkstras algorithm
17:36:27 <Cale> I wish there was a proper graph library which used this representation.
17:36:51 <ivanm> Cale: no edge labels using that representation
17:36:55 <pumpkin> Cale: wouldn't you want it to be a Map Vertex?
17:36:58 <pumpkin> to get labels
17:37:31 <Cale> ivanm: Map Vertex (Set (Vertex, Label)) then :)
17:37:40 <ivanm> heh
17:37:58 <ivanm> Cale: hmmmm.... how would you get multiple edges in a label-less graph then? ;-)
17:38:12 <Cale> Use Integer labels.
17:38:39 <ivanm> heh
17:38:49 <ivanm> but then it _does_ have edge labels
17:38:53 <SamB> lame lame
17:39:07 <walski> Is it possible to use printf to get the return value as a String?
17:39:10 <ivanm> a MultiSet would probably be better
17:39:11 <Cale> Or I suppose you could switch out Set for Bag or something
17:39:16 <ivanm> yeah
17:39:18 <mauke> walski: yes
17:39:21 <SamB> > printf "Hi!" :: String
17:39:23 <lambdabot>   "Hi!"
17:39:30 <walski> Thanks!
17:39:33 <Cale> walski: yes, printf is polymorphic :)
17:39:48 <vaskaren> Cale: i use that representation kind of
17:39:53 <walski> Great stuff!
17:42:23 <vaskaren> where is set?
17:42:33 <vaskaren> data.set ofc
17:42:47 <dibblego> is there a function that alternately splits a list? e.g. [a,b,c,d,e] -> ([a,c,e], [b,d])
17:46:13 <dmwit> Well, the closest is partition.
17:46:15 <dmwit> You could use:
17:46:30 <dmwit> > partition (even . fst) . zip [0..] $ [w,x,y,z]
17:46:32 <lambdabot>   ([(0,w),(2,y)],[(1,x),(3,z)])
17:46:47 <dmwit> :t map snd . partition (even . fst) . zip [0..]
17:46:48 <lambdabot>     Couldn't match expected type `[(a, b)]'
17:46:48 <lambdabot>            against inferred type `([(a1, b1)], [(a1, b1)])'
17:46:48 <lambdabot>       Expected type: [b1] -> [(a, b)]
17:46:52 <dmwit> oops
17:47:02 <dmwit> :t (map snd *** map snd) . partition (even . fst) . zip [0..]
17:47:03 <lambdabot> forall b. [b] -> ([b], [b])
17:47:24 <loop> *** ?
17:47:36 <dmwit> (f *** g) (x, y) = (f x, g y)
17:47:47 <dmwit> ...and then generalized to Arrows instead of just for functions. =)
17:47:59 <loop> where's that defined
17:48:05 <dmwit> ?index (***)
17:48:06 <lambdabot> Control.Arrow
17:48:15 <dmwit> ?src (***) (->)
17:48:16 <lambdabot> Source not found. I am sorry.
17:48:26 <dmwit> ?src (->) (***)
17:48:27 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
17:48:36 <dmwit> Ah, there's a lazy pattern in there.  Sorry for misleading you. =)
17:49:24 <loop> :-)
17:49:52 <Saizan> > foldr (.) id (zipWith ($) (cycle [first . (:),second . (:)]) [a,b,c,d,e]) ([],[])
17:49:54 <lambdabot>   ([a,c,e],[b,d])
17:50:19 <loop> is there a lambdabot manual somewhere?
17:50:35 <Saizan> @list
17:50:36 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:50:52 <Saizan> not really exhaustive..
17:51:07 <dmwit> You can /msg lambdabot ?help commands once you've found one you're curious about.
17:51:16 <dmwit> for example
17:51:17 <BMeph> Do we have a Data.Bag? :)
17:51:18 <dmwit> ?help run
17:51:19 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
17:51:28 <dmwit> BMeph: I believe we might!
17:51:30 <dmwit> ?where edison
17:51:31 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
17:51:41 <loop> ?help where
17:51:41 <lambdabot> where <key>. Return element associated with key
17:51:59 <dmwit> ?where+ edison http://www.cs.princeton.edu/~rdockins/edison/home/
17:52:00 <lambdabot> Nice!
17:52:01 <loop> umm. that was helpful
17:52:36 <loop> where+ adds a key->value mapping?
17:52:46 <Saizan> yes
17:52:49 <dmwit> Who's got ?flush powers?  I feel like I've corrected this before...
17:53:39 <mauke> @flush
17:53:39 <lambdabot> Not enough privileges
17:54:08 <Trafalgard> > 5*2
17:54:09 <TheHunter> @admin + mauke
17:54:09 <lambdabot>   10
17:54:17 <mauke> @flush
17:54:28 <dmwit> wow
17:54:36 <dmwit> That seems like a pretty obvious hack.
17:54:50 <dmwit> I guess it checks to make sure you're +i or something...?
17:54:54 <mauke> no
17:54:59 <mauke> it's purely nick based
17:55:26 <Elly> that's dumb
17:55:46 * dmwit shudders to realize that this is now memorialized in the #haskell logs
17:55:57 <mauke> meh, I've pointed this out before
17:56:00 <Trafalgard> We can out-dumb that if you like
17:56:15 <dmwit> I like!
17:56:19 <Trafalgard> I'm going through this haskell tutorial
17:56:21 <Trafalgard> "Now try entering 25000. Does itwork?"
17:56:30 <Cale> 2^5000
17:56:33 <Trafalgard> Gee! I wonder!
17:56:45 <dmwit> > 2ˆ5000 -- looks like unicode!
17:56:46 <lambdabot>   <no location info>: lexical error at character '\710'
17:57:09 <mauke> > 2^5000
17:57:10 <lambdabot>   141246703213942603683520966701614733366889617518454111681368808585711816984...
17:57:16 <Trafalgard> aw, it's smart :P
17:57:17 <Cale> Trafalgard: 2^5000 won't work in a lot of languages which don't have support for large integers.
17:57:46 <pumpkin> what is the memory that :set +s outputs? it seems way too huge to be an actual allocation
17:57:51 <Trafalgard> yeah, I tried it in ghci and went "Ooooh! Wait, what's it doing behind the scenes?"
17:58:25 <dmwit> pumpkin: Why?
17:58:37 <Trafalgard> since the number was like 19 lines long
17:58:38 <dmwit> pumpkin: It's probably the total of all allocations... including for thunks.
17:58:39 <Cale> pumpkin: Total allocation. This is a very different number from the largest size in memory.
17:59:08 <Cale> (since it typically includes lots of short-lived objects that are immediately garbage collected)
17:59:15 <dmwit> Last time I profiled something I had allocated 200GB of memory (!) in 30 minutes.
17:59:20 <dmwit> not bad, eh?
17:59:23 <pumpkin> dmwit: wow :P
17:59:43 <pumpkin> so > length [1..100000000] is expected to output almost 4 gigs?
17:59:55 <Cale> pumpkin: Seems reasonable.
18:00:17 <pumpkin> and for > 1 half a meg is reasonable?
18:00:20 <Cale> That is 100 million cons cells, plus the elements.
18:00:46 <pumpkin> cool, okay
18:00:58 <dmwit> pumpkin: I get 500K for [1..2]... but also for [1..50].
18:01:32 <dmwit> Weird, I get different amounts of memory allocated if I do the same thing several times in a row.
18:01:36 <conal> I'd like some help coming up with a name: it's a generalization of sequences to possibly continuous indices.  I represent it as a function and a duration.  i'm writing a blog post, and i'd like something catchier than function-with-duration.
18:02:07 <vaskaren> is their nonlinear algebra? as opposed to linear alebra?
18:02:21 <dmwit> conal: function intervals?
18:02:22 <mm_freak_> dmwit: the garbage collector is unpredictable
18:02:22 <pumpkin> vaskaren: it's just called algebra :P
18:02:35 <SamB> y = x^2
18:02:40 <mm_freak_> dmwit: but i think, you'll get the same value, if you restart ghci each time
18:03:09 <pumpkin> conal: function with a limited domain? :P
18:03:17 <solrize> conal i can't help thinking there's already a name for that in topology
18:03:18 <conal> dmwit: i like "function intervals".  although maybe sounds more general than it is, since the functions all have zero as a domain lower bound.
18:03:54 <dmwit> conal: Well, you can add adjectives all day.
18:03:54 <Saizan> is there a name for a commutative semiring where both multiplication and addition are idempotent?
18:03:59 <dmwit> conal: "bounded function intervals" =)
18:04:31 <walski> How do I cast an Int to a floating point value?
18:04:37 <pumpkin> fromIntegral
18:04:55 <conal> dmwit: i'm trying to *remove* words, while staying fairly descriptive.
18:05:06 <dmwit> right
18:05:22 <Saizan> walski: fromIntegral
18:05:27 <Saizan> ops
18:06:34 <jsn> conal: find a cute animal, name it after that
18:06:42 <pumpkin> lolfunction
18:06:43 <conal> jsn: heh
18:06:45 <conal> maybe i'll call it "function segments" and accept the ambiguity.
18:07:07 <conal> i'm already using "Segment" as a corresponding class name
18:07:10 <jsn> pumpkin: LOLz
18:10:42 <conal> thanks for the help.  "function intervals" got me to "function segments", which i like.
18:15:10 <dons> http://haskell.org/haskellwiki/The_Knights_Tour
18:15:14 <lambdabot> Title: The Knights Tour - HaskellWiki
18:15:22 <dons> dmwit, dolio , feel free to describe your solutions
18:15:26 <dons> and add performance details
18:16:03 <geezusfreeek> anybody ever get this error message? "ghc: could not execute: /usr/local/lib/ghc-6.10.1/./ghc-asm"
18:16:17 <geezusfreeek> i seem to only get it on my powerbook (ppc)
18:16:28 <geezusfreeek> and it seems to have persisted over multiple versions of ghc
18:16:39 <geezusfreeek> and it seems to only happen when compiling the stream-fusion package
18:16:46 <dons> huh
18:16:56 <dons> oh, must be compiling -fvia-C ?
18:17:02 <dons> and you've not got a ppc codegen available!?
18:17:27 <geezusfreeek> like gcc, you mean? i certainly have gcc
18:17:37 <dons> no, ghc's code gen for ppc
18:17:43 <geezusfreeek> oh
18:17:47 <geezusfreeek> i have no idea.
18:17:56 <geezusfreeek> like i said, this has persisted i think since around 6.8.3
18:18:01 <dons> try -ghc-options=-fasm (or whatever the cabal thing is to pass in new compiler flags)
18:18:35 * geezusfreeek looks up the correct flag
18:20:04 <geezusfreeek> dons: by "not available" do you mean you suspect that the ghc-asm executable is not there? because it is in the path it is looking for
18:21:45 <mjrosenb> hrmm, it looks like ghc still doesn't run under ppc64-linux
18:22:42 <geezusfreeek> ugh, i can't find the flag for cabal-install. i'll just get the tarball and set it in the .cabal file myself
18:24:37 <geezusfreeek> dons: no error if i remove -fvia-c from the .cabal
18:24:48 <Gwern-away> does anyone have darcs yi handy?
18:24:49 <dolio> dons: Are you sure my exit continuation version is 10x faster than the best Python code in that article?
18:26:05 <geezusfreeek> dons: even fails on a helloworld test with fvia-c
18:26:13 <stianhj> Gwern-away: http://code.haskell.org/yi
18:26:15 <lambdabot> Title: Index of /yi
18:26:25 <pumpkin> @src second
18:26:26 <lambdabot> Source not found. I am sorry.
18:26:29 <dons> dolio: they report 1s+ while the cont based one was 0.1s here.
18:26:35 <geezusfreeek> so that is certainly it
18:26:35 <dons> so approximating
18:26:44 <dolio> For what size?
18:26:58 <Gwern-away> stianhj: no, I mean installed
18:27:13 <pumpkin> :t second
18:27:14 <Gwern-away> stianhj: I am wondering if M-x insertB is an error for other people as well
18:27:15 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
18:27:31 <Gwern-away> stianhj: I can build yi without too much trouble, my issue is runtime
18:27:39 <pumpkin> > second (+)
18:27:41 <lambdabot>       Overlapping instances for Show ((d, a) -> (d, a -> a))
18:27:41 <lambdabot>        arising f...
18:27:47 * Gwern-away was trying to add replaceString, but yi has a strange M-x setup
18:27:59 <pumpkin> > second (+) ) (1, 2)
18:28:00 <lambdabot>   <no location info>: parse error on input `)'
18:28:02 <stianhj> Gwern-away: as in binary? i don't know.. i'm having some trouble building it myself, more precisely with zlib
18:28:04 <pumpkin> > second (+) (1, 2)
18:28:05 <lambdabot>       Overlapping instances for Show (a -> a)
18:28:05 <lambdabot>        arising from a use of `s...
18:28:22 <geezusfreeek> should i submit a bug report or has somebody preemptively jumped on it already?
18:29:19 <geezusfreeek> or is there some other way i could build ghc to fix it?
18:29:38 <pumpkin> does anyone have a good example of second?
18:29:38 <Gwern-away> @hoogle toDyn
18:29:39 <lambdabot> Data.Dynamic toDyn :: Typeable a => a -> Dynamic
18:30:14 <geezusfreeek> > second (4+) (1, 2)
18:30:16 <lambdabot>   (1,6)
18:30:24 <pumpkin> hmm
18:30:42 <pumpkin> so it keeps fst and applies the function to snd?
18:30:51 <geezusfreeek> pumpkin: right
18:31:04 <pumpkin> > first (1+) (1, 2)
18:31:06 <lambdabot>   (2,2)
18:31:22 <pumpkin> that's handy
18:32:03 <geezusfreeek> @src (->) first
18:32:04 <lambdabot> first f = f *** id
18:32:17 <geezusfreeek> oh duh
18:32:40 <mm_freak_> > sin *** cos $ 2
18:32:42 <lambdabot>       No instance for (Num (b, b'))
18:32:42 <lambdabot>        arising from the literal `2' at <i...
18:32:51 <geezusfreeek> > ((1+) *** (2+)) (1,1)
18:32:51 <mm_freak_> > sin &&& cos $ 2
18:32:52 <lambdabot>   (2,3)
18:32:53 <lambdabot>   (0.9092974268256817,-0.4161468365471424)
18:33:08 <pumpkin> geezusfreeek: wow, I just typed that exact example into lambdabot in pm :P
18:33:14 <mm_freak_> > sin &&& cos >>> arr (\(x,y) -> x^2 + y^2) $ 2
18:33:15 <pumpkin> geezusfreeek: get out of my head
18:33:16 <lambdabot>   1.0
18:33:17 <geezusfreeek> heh
18:33:18 <pumpkin> :P
18:34:05 <mm_freak_> > map (sin &&& cos >>> arr (\(x,y) -> x^2 + y^2)) [1..]
18:34:07 <lambdabot>   [1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0.999...
18:34:22 <mm_freak_> oh yeah…  welcome to the world of rounding errors
18:34:27 <pumpkin> would a CReal help?
18:34:40 <mm_freak_> i don't think so
18:34:43 <geezusfreeek> > map (sin &&& cos >>> arr (\(x,y) -> x^2 + y^2)) [1..] :: [CReal]
18:34:50 <mm_freak_> > map (sin &&& cos >>> arr (\(x,y) -> x^2 + y^2) >>> round) [1..]
18:34:53 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:34:58 <lambdabot>   thread killed
18:35:11 <asdfiest> is case of only for monads?
18:35:14 <mm_freak_> which one was killed?
18:35:16 <mm_freak_> > map (sin &&& cos >>> arr (\(x,y) -> x^2 + y^2) >>> round) [1..]
18:35:18 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:35:20 <mm_freak_> ok =)
18:35:24 <pumpkin> lambdabot should prefix its output with whoever ran the command when there are concurrent commands
18:35:25 <asdfiest> i get Just x or Nothing back and want to pmatch out Just
18:35:27 <geezusfreeek> asdfiest, no, it is for any adt
18:35:41 <asdfiest> nodesOf (Graph e n) v =
18:35:41 <asdfiest>                         case res of Just x  -> x
18:35:41 <asdfiest>                         case res of Nothing -> Nothing
18:35:41 <asdfiest>                                                where res = M.lookup v e
18:35:43 <asdfiest> oops
18:35:58 <pumpkin> asdfiest: there's an easier way to do that
18:36:17 <asdfiest> actually i might not even want to do it
18:36:23 <asdfiest> but anyway whtas the eaier way?
18:36:39 <geezusfreeek> :t Data.Map.lookup
18:36:40 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
18:36:42 <mm_freak_> asdfiest: that case of is not specific to monads, but you're almost crying for them =)
18:36:53 <pumpkin> asdfiest: actually, does that even compile?
18:36:56 <Gwern-away> @hoogle String -> Char
18:36:57 <lambdabot> Prelude read :: Read a => String -> a
18:36:57 <lambdabot> Text.Read read :: Read a => String -> a
18:36:57 <lambdabot> Prelude error :: String -> a
18:37:21 <mm_freak_> if you ever happen to have two cases, one Just -> … and one Nothing -> Nothing, you really want to use the monadic properties of Maybe
18:37:23 <Gwern-away> > read "" :: Char
18:37:25 <lambdabot>   * Exception: Prelude.read: no parse
18:37:42 <pumpkin> asdfiest: it seems that if you're returning a Nothing and an x, that needs to be a Maybe
18:37:51 <geezusfreeek> pumpkin, no it's fine
18:37:54 <Gwern-away> > let foo a = if length foo > 0 then head a else []
18:37:55 <geezusfreeek> look at lookup
18:37:55 <lambdabot>   <no location info>: parse error on input `;'
18:38:02 <Gwern-away> > let foo a = if length foo > 0 then head a else [] in foo ""
18:38:03 <lambdabot>   Couldn't match expected type `[a]' against inferred type `t1 -> t'
18:38:12 <Gwern-away> hm. I need safe head
18:38:22 <Gwern-away> the frustrating thing is that I had this need not long ago as well
18:38:37 <asdfiest> pumpkin:; yes and i win nothing then anyway
18:38:41 <geezusfreeek> pumpkin, sorry no, but x could still be in the maybe monad
18:38:46 <pumpkin> ah ok
18:38:52 <pumpkin> that's what I was wondering :)
18:39:00 <mm_freak_> the code should compile fine, but it's very verbose
18:39:10 <geezusfreeek> asdfiest, i recommend join $ M.lookup v e
18:39:20 <Gwern-away> come to think of it, what is the empty or space character?
18:39:33 <Gwern-away> > '\ '
18:39:34 <lambdabot>   <no location info>:
18:39:35 <lambdabot>      lexical error in string/character literal at chara...
18:39:35 <mm_freak_> yeah, join should do the trick
18:39:36 <asdfiest> join is where?
18:39:43 <mm_freak_> > join $ Just (Just 3)
18:39:45 <lambdabot>   Just 3
18:39:48 <asdfiest> List.join?
18:39:48 <mm_freak_> asdfiest: Control.Monad
18:39:53 <geezusfreeek> :t join
18:39:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:40:07 <geezusfreeek> asdfiest, wait, list?
18:40:14 <pumpkin> join $ Just (Just (Just 3))
18:40:20 <pumpkin> > join $ Just (Just (Just 3))
18:40:21 <lambdabot>   Just (Just 3)
18:40:23 <asdfiest> i cant do join i ghci
18:40:27 <asdfiest> where is join?
18:40:30 <tcleval> what does haskell use for backend on 'parallel haskell'? something like pthread or fork calls?
18:40:31 <geezusfreeek> asdfiest, Control.Monad
18:40:31 <pumpkin> asdfiest: :m + Control.Monad
18:40:54 <hackage> Uploaded to hackage: TypeCompose 0.6.3
18:42:14 <dons> haha http://www.reddit.com/r/programming/comments/7gk4m/solving_the_knights_tour_in_30_lines_of_haskell/
18:42:16 <lambdabot> Title: Solving the Knight's tour in 30 lines of Haskell using the Logic monad : program ..., http://tinyurl.com/54wbsn
18:42:23 <dons> tcleval: no. well. kinda.
18:42:26 <Axman6> whoot, got another HD in comp this semester :D
18:42:40 <hd_> something is wrong with learnyouahaskell.com :(
18:42:42 <Saizan> tcleval: M user-level threads scheduled over N OS-level ones, but no forks, those would mean multiple processes
18:42:45 <Axman6> ... just... but it was all java, so...
18:42:47 <dons> tcleval: the ghc runtime implements lightweight haskell threads  using select or epoll. these are migrated onto OS threads
18:43:02 <mm_freak_> > returnA 3
18:43:03 <lambdabot>   3
18:43:04 <dons> and above that there are sparks, which might get turned into a thread if one is available
18:43:15 <kynky> epoll is linux afaik
18:43:41 <pumpkin> it would be nice if it had some sort of mpi backend for parallelism if you wanted it :)
18:43:41 <kynky> solaris and windows dont have it
18:43:51 <dons> pumpkin: old school distributed haskell used things like that
18:43:57 <dons> but probably not the ideal thing for shared memory
18:44:02 <pumpkin> yeah
18:44:02 <dons> there's a library for user land mpi
18:44:31 <pumpkin> what mechanisms do those massive parallel supercomputers use that keep making the news?
18:44:34 <tcleval> dons , i ask that coz i was thinking if i use something that is "no thread safe" on the ffi level... i mean, some C code that is not thead sabe, if haskell uses threads and dont create new processes i guess i would have to lock parts of the code
18:45:00 <dons> you can make it a 'safe' call
18:45:11 <dons> or otherwise wrap up the call to lock on the haskell side
18:45:16 <mm_freak_> and you can use bounded threads
18:45:23 <tcleval> hummm
18:45:23 <dons> the curl library does this, ensuring there's only one thread accessing resources at a time
18:45:35 <tcleval> that is cool
18:45:39 <kynky> just simple locking then
18:45:42 <dons> you just put an MVar in front of the functions, and sychronise access from haskell land
18:45:45 <dons> makes C thread safe :)
18:45:55 <Axman6> hoorah
18:46:09 <tcleval> dons: lol , so dont have to look back the C side?
18:46:26 <dons> no, you won't have to modify C.
18:46:36 <tcleval> lol that is insane ^^
18:46:49 <Axman6> tcleval: why?
18:47:03 <tcleval> i mean it is so cool that is insane
18:47:17 <Gwern-away> woot, I got insertB and replace-string working
18:47:22 <Gwern-away> crazy Yi data.dynamic stuff
18:49:25 <Gwern-away> (I've run into so many odd corners of haskell in yi; I mean, when was the last time you saw data.dynamic stuff being used?)
18:50:03 <dons> hah
18:50:10 <mmorrow> , eval "42"
18:50:23 <lunabot>  <<Integer>>
18:50:25 <mmorrow> wake up bot
18:50:28 <mmorrow> , eval "42"
18:50:33 <lunabot>  <<Integer>>
18:50:40 <dons> wow, http://blog.clemens.endorphin.org/2008/11/xmonad-gridselect.html
18:50:52 <lambdabot> Title: CFruhwirth's Weblog: XMonad GridSelect
18:51:10 <Gwern-away> dons: gridselect can be very purty
18:52:21 <mmorrow> holy shit, i need to install xmonad again
18:52:25 <Gwern-away> :t ""
18:52:26 <lambdabot> [Char]
18:52:35 <Gwern-away> :t head ""
18:52:37 <lambdabot> Char
18:52:40 <dolio> dons: If we're golfing, I cut 3 lines (and one import) out of the LogicT version. :)
18:52:41 <Gwern-away> > head ""
18:52:43 <lambdabot>   * Exception: Prelude.head: empty list
18:52:47 <Gwern-away> ?
18:53:02 <Gwern-away> I guess there is no empty char then
18:53:05 <litb> what is that gridselect?
18:53:08 <litb> looks nifty
18:53:09 <mmorrow> > take 1 ""
18:53:10 <lambdabot>   ""
18:53:35 <litb> > take 1 []
18:53:36 <lambdabot>   []
18:53:46 <litb> hmm
18:53:56 <litb> isn't a "" an emty [Char] ?
18:54:02 <dmwit> Yes.
18:54:04 <geezusfreeek> :t ""
18:54:05 <lambdabot> [Char]
18:54:07 <dmwit> But [] is not an empty [Char].
18:54:11 <dmwit> It is an empty [()].
18:54:16 <geezusfreeek> :t []
18:54:16 <dons> dolio: cute
18:54:17 <lambdabot> forall a. [a]
18:54:21 <dons> LogicT++
18:54:29 <litb> oh
18:54:40 <litb> if it doesn't know the type, it takes the empty tuple ?
18:54:48 <dmwit> That's defaulting, yup.
18:54:53 <litb> i see
18:55:07 <dmwit> > [mempty]
18:55:08 <lambdabot>   [()]
18:55:16 <dolio> dons: It's really no different than dmwit's solution, though. Except GHC might compile continuation passing better than list code.
18:55:48 <litb> i know mempty is the empty element in the list monad or something like that :p
18:56:05 <litb> mzero is something else i forgot.
18:56:06 <dons> yeeep
18:56:08 <mmorrow> dancor: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=518#a519
18:56:15 <mmorrow> MonadUtils.liftIO
18:56:31 <mmorrow> rather than Control.Monad.Trans.liftIO
18:56:34 <dons> dolio: and it looks tiny, and reddit likes it, http://www.reddit.com/r/programming/comments/7gk4m/solving_the_knights_tour_in_30_lines_of_haskell/
18:56:36 <lambdabot> Title: Solving the Knight's tour in 30 lines of Haskell using the Logic monad : program ..., http://tinyurl.com/54wbsn
18:56:46 <dons> today i also was reminded how poor slashdot is. it's unusable
18:57:05 <mmorrow> dons: what prompted this realization?
18:57:14 <dolio> dons: Actually, it's not appreciably faster than replacing Logic with [] (just checked).
18:57:14 <litb> what's up with it? i heard ppl talking about /. today multiple times
18:57:41 <mmorrow> preflex: seen dancor
18:57:41 <preflex>  dancor was last seen on #haskell 3 hours, 25 minutes and 6 seconds ago, saying: gwern: i'm still enough of a noob that i consider that good bc i can "check my answer"
18:58:04 <mmorrow> @tell dancor MonadUtils.liftIO rather than Control.Monad.Trans.liftIO http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=518#a519
18:58:05 <lambdabot> Consider it noted.
18:58:05 <dons> mmorrow: i haven't visited it in maybe 5 years :) today i tried to add a comment to the stupid python post. not usable
18:58:18 <mmorrow> heh
18:58:21 <dons> dolio: Logic looks like a secret weapon
18:58:33 <mmorrow> licensed to kill
18:58:56 <litb> yeah it's a nerd site anyway
18:59:20 <mmorrow> , [0..] `interleave` [100..]
18:59:22 <lunabot>  [0,100,1,101,2,102,3,103,4,104,5,105,6,106,7,107,8,108,9,109,10,110,11,11...
18:59:25 <gio123> does somebody knows when fall 2009 semester starts?
18:59:46 <pumpkin> gio123: that would depend on the school
19:00:01 <Gwern-away> gio123: presumably activity here drops off as the students do homework
19:00:03 <mmorrow> , foldr interleave [] (fmap (\n->[n..]) [0..])
19:00:07 <lunabot>  [0,1,1,2,2,2,3,3,4,3,5,3,6,4,7,4,8,5,9,4,10,6,11,4,12,7,13,5,14,8,15,5,16...
19:00:27 <dmwit> > interleave [1,2] [0..]
19:00:29 <lambdabot>   [1,0,2,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26...
19:00:38 <dmwit> ?hoogle interleave
19:00:39 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
19:00:39 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
19:00:39 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
19:00:47 <mmorrow> , src 'interleave
19:00:48 <litb> lol the page that python post links to is down -.- slashdotted
19:00:51 <lunabot>  Class op from MonadLogic: interleave :: forall m . MonadLogic m => forall...
19:00:52 <lunabot>                                                                           ...
19:00:53 <gio123> in general? what starts from april?
19:00:57 <mmorrow> , src ''MonadLogic
19:01:03 <lunabot>  class (MonadPlus m) => MonadLogic m where
19:01:03 <lunabot>          msplit :: forall a . m a -> m (Maybe (a, m a))
19:01:03 <lunabot>          interleave :: forall a . m a -> m a -> m a
19:01:11 <dmwit> gio123: late August, early September
19:01:14 <pumpkin> gio123: spring term if you're on a quarter system, not sure about ohters
19:01:41 <mmorrow> dolio: that reminds me, i've got some code so lunabot can do the @type equiv for an arbitrary expression, just have to add it to lunabot
19:01:58 <dolio> Sweet.
19:02:30 <dons> shapr:
19:02:34 <mmorrow> <lunabot>          (>>-) :: forall b a . m a -> (a -> m b) -> m b
19:02:34 <mmorrow> <lunabot>          ifte :: forall b a . m a -> (a -> m b) -> m b -> m b
19:02:34 <mmorrow> <lunabot>          once :: forall a . m a -> m a
19:02:35 <dons> 07:00:41 --- mode: ChanServ set +b Smerdyakov!*@*
19:02:37 <dons> 07:00:41 --- kick: Smerdyakov was kicked by ChanServ (Banned: don't*pick*on*newbies)
19:02:40 <dons> huh.
19:02:46 <dons> our walls and strategems are in place.
19:03:06 <gio123> could somebody pm me what is deference between, spring, summe and fall semester?
19:03:22 <dancor> mmorrow: ah, wow
19:03:22 <lambdabot> dancor: You have 1 new message. '/msg lambdabot @messages' to read it.
19:03:30 <Axman6> dancor: when was that?
19:03:37 <mmorrow> dancor: :)
19:03:39 <Axman6> uh, dons
19:03:58 <stianhj> I'm having some trouble installing the vty package (trying to install vi).. here's the error message I get: http://hpaste.org/12552
19:04:09 <stianhj> that is yi, not vi
19:04:14 <pumpkin> @hoogle heads
19:04:15 <lambdabot> No results found
19:04:20 <pumpkin> @hoogle tails
19:04:20 <lambdabot> Data.ByteString tails :: ByteString -> [ByteString]
19:04:20 <lambdabot> Data.List tails :: [a] -> [[a]]
19:04:20 <lambdabot> Data.ByteString.Char8 tails :: ByteString -> [ByteString]
19:04:29 <dancor> @hoogle inits
19:04:30 <lambdabot> Data.ByteString inits :: ByteString -> [ByteString]
19:04:30 <lambdabot> Data.List inits :: [a] -> [[a]]
19:04:30 <lambdabot> Data.ByteString.Char8 inits :: ByteString -> [ByteString]
19:04:40 <pumpkin> aha :) thanks
19:05:23 <dancor> heads = repeat . head  ;)
19:05:29 <Axman6> @check (\ls -> map head $ tails ls == id ls)
19:05:30 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:05:30 <lambdabot>        Expect...
19:05:42 <Gwern-away> stianhj: you need to compile against base 3 not base 4
19:05:45 <Axman6> @check (\ls -> (map head $ tails ls) == id ls)
19:05:47 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
19:06:05 <Gwern-away> stianhj: add an option like iirc --constraint="cabal < 4"
19:06:10 <Gwern-away> er. *base
19:06:12 <Axman6> > (map head . tails) [1..10]
19:06:13 <dancor> actually  heads = take 1  i guess
19:06:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,* Exception: Prelude.head: empty list
19:06:19 <Axman6> ah yes, ha
19:10:50 * Gwern-away sends in 8 yi patches. maybe one day I'll be able to switch from emacs
19:11:37 <kynky> emacs seems to work best for haskell for me at the mo too
19:11:39 <Axman6> > e^((sqrt (-1)*pi)+1
19:11:41 <lambdabot>   <no location info>: parse error on input `;'
19:11:52 <Axman6> > e^(((sqrt (-1))*pi)+1 :: CReal
19:11:54 <lambdabot>   <no location info>: parse error on input `;'
19:13:18 <ivanm> Axman6: needs another bracket I think
19:13:22 <ivanm> oh, wait, there's no e
19:13:35 <ivanm> > exp(pi*(sqrt (-1))) + 1
19:13:36 <lambdabot>   NaN
19:13:49 <ivanm> > exp(pi*(0 :+ 1)) + 1
19:13:50 <Axman6> > exp (((sqrt (-1))*pi)+1 :: CReal
19:13:50 <lambdabot>   0.0 :+ 1.2246467991473532e-16
19:13:51 <lambdabot>   <no location info>: parse error on input `;'
19:14:03 <Axman6> > exp ((sqrt (-1))*pi)+1 :: CReal
19:14:05 <lambdabot>   * Exception: Ratio.%: zero denominator
19:14:13 <ivanm> Axman6: not (i `in` CReals) ;-)
19:14:21 <Axman6> ah yes
19:14:29 <Axman6> > exp ((sqrt (-1))*pi)+1 :: Complex CReal
19:14:30 <pumpkin> is there a simple "dot product" of two lists function?
19:14:31 <lambdabot>   0.0 :+ 0.0
19:15:00 <Axman6> pumpkin: sum . zipWith (+) is usually how i've seen it done
19:15:15 <pumpkin> you mean *, and then sum?
19:15:28 <Axman6> that one
19:15:29 <Axman6> :P
19:16:45 * pumpkin is trying to write a simple autocorrelation function with applicative
19:17:07 <ivanm> *shudder* I had to implement an autocorrelation function
19:17:11 <ivanm> it was fugly :s
19:17:23 <pumpkin> hmm, doesn't look like it needs to be
19:17:25 <pumpkin> hmm
19:17:47 <pumpkin> I'm going to eventually do it with an FFT, but I just wanted to see how simple I could make it the naive way
19:19:18 <Axman6> pumpkin: the DPH stuff makes doing dot products and such quite interesting. you should check out some of the SPJ videos on it
19:19:31 <stianhj> I'm trying to install the vty package, I've tried with cabal-install, manually downloading it, I've tried --constraint="base < 4" on cabal-install and manually editing the vty.cabal file. And everytime I get this message: http://hpaste.org/12552 Anyone have any tips?
19:19:38 <pumpkin> Axman6: DPH? SPJ?
19:19:50 <Axman6> data parallel haskell, simon peyton jones
19:20:02 <scodil> welcome to the army, son. try to keep up with the acronyms
19:20:02 <pumpkin> ah :)
19:20:10 <dolio> @quote simonjp
19:20:11 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
19:20:13 <dolio> @quote simonpj
19:20:13 <lambdabot> simonpj says: If you put a spoonful of sewage into a vat of wine, what do you have? A vat of sewage.
19:21:12 <Axman6> wow, i'm so dyslexic, tool me 30 seconds to figure what was different between simonjp and simonpj
19:21:18 <kynky> use a sewagemonad on the vat
19:21:35 * Axman6 is actually dyslexic though
19:21:51 <scodil> i think kynky just found a new monad metaphor
19:21:58 <scodil> you should write a tutorial
19:22:09 <kynky> :)
19:22:16 <dolio> Yes. We haven't had enough of those lately.
19:22:17 <Axman6> "Learning monads with poop"
19:23:39 <kynky> should have good analogies for explaining recursion too
19:23:49 <scodil> gross
19:23:54 <Saizan> stianhj: which version of ghc are you using?
19:24:02 <Axman6> kynky: ha
19:24:03 <Elly> wait, is the sewage thing a metaphor for impure programming?
19:24:11 <stianhj> 6.8.2
19:24:17 <stianhj> Saizan: 6.8.2
19:24:52 <Saizan> stianhj: then you want the 3.1.2 version
19:25:57 <stianhj> I'm trying to install yi, and it depends on 3.1.4.. or so it says..
19:26:08 <kynky> Elly, yeah i assume the spj quote was about side-effects
19:26:10 <dons> dolio: congrats. 10 people a minute are viewing your logict post.
19:26:20 <dolio> Wow.
19:26:31 <Axman6> link?
19:26:41 <scodil> yeah link. we can beat 10/min
19:27:01 <dons> 20 people a minute
19:27:16 <dons> http://www.reddit.com/r/programming/comments/7gk4m/solving_the_knights_tour_in_30_lines_of_haskell/
19:27:18 <lambdabot> Title: Solving the Knight's tour in 30 lines of Haskell using the Logic monad : program ..., http://tinyurl.com/54wbsn
19:27:45 <solrize> heh, it shrunk, it was 19 lines a few minutes ago
19:28:06 <dolio> I was thinking, the reason there may not be much of a difference between Logic and [] is that most of the time is spent doing Data.Map stuff. Of course, I haven't really benchmarked Logic.
19:28:13 <Saizan> stianhj: then you've to edit vty's source, replacing imports of Control.Exception with Control.Exception.Extensible from the extensible-exceptions package
19:28:24 <dibblego> @type replicateM
19:28:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
19:28:40 <dibblego> @type replicateM 100 (print "Where is the error?")
19:28:42 <lambdabot> IO [()]
19:28:45 <dibblego> @type replicateM_ 100 (print "Where is the error?")
19:28:46 <lambdabot> IO ()
19:29:00 <dibblego> @type 100 `replicateM` (print "Where is the error?")
19:29:01 <lambdabot> IO [()]
19:29:23 <pumpkin> :t (<$> [] <*> [])
19:29:25 <lambdabot>     The operator `<$>' [infixl 4] of a section
19:29:25 <lambdabot>         must have lower precedence than the operand `(<*>)' [infixl 4]
19:29:25 <lambdabot>         in the section: `(<$> [] <*> [])'
19:31:17 <stianhj> Saizan: I installed vty-3.1.2, and it seems to have worked.. now it complains about some other package instead. Moving forward..
19:35:11 <Axman6> anyway to tell cabal install to stop trying to install process-1.0.1.1?
19:35:31 <pumpkin> whee: http://hpaste.org/12555
19:35:52 <pumpkin> of course, it's n^2, which isn't good
19:35:57 <shapr> dons: When did that happen?
19:36:29 <shapr> dons: Ah I see
19:36:52 <pumpkin> any style suggestions for my autocorrelation function above?
19:37:54 <dolio> zipWith (*) doesn't need parentheses around it.
19:38:13 <pumpkin> oh yeah
19:38:17 <dons> mfp: just lurking?
19:38:23 <solrize> what's the (sum .) .    doing?
19:38:40 <solrize> and the <$>  ?   that's like fmap?
19:39:11 <dolio> Also, foo <$> [a] = [foo a]
19:40:21 <dolio> So that reduces to: ... = sum . zipWith (*) xs <$> shifts
19:40:23 <solrize> :t (<$>)
19:40:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:41:40 <solrize> :t (<*>)
19:41:41 <Axman6> :t fmap
19:41:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:41:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:42:09 <pumpkin> sorry, that'll taeach me to run huge tests in ghci
19:42:17 <pumpkin> that allocate all my memory and make the system unusable
19:43:17 <pumpkin> thanks dolio
19:43:32 <solrize> i still don't understand how that thing parses.  would it be clearer as a listcomp>
19:43:33 <solrize> ?
19:43:42 <pumpkin> hmm, maybe it would
19:43:53 <pumpkin> didn't think of that
19:46:40 <pumpkin> also, do you think it's calling length xs every time I call takeLen, or will it get saved across calls?
19:46:42 <walski> how can I pass some additional parameter to map?
19:46:57 <pumpkin> walski: how do you mean? you can curry the function you pass in
19:47:06 <walski> When I want to map a list with a function but this function does rely on some other data than the list itself
19:47:10 <dolio> pumpkin: I think it's shared.
19:47:33 <pumpkin> walski: just pass in (f otherData) instead of just f, to map
19:47:50 <walski> oh cool! thanks
19:48:11 <pumpkin> if it's not the first parameter it's a little trickier, but not much
19:49:26 <Axman6> walski: or map (\x -> f x otherData) if you need it passes in a different place (or map (flip f otherData))
19:52:35 <Axman6> passed*
19:53:14 <juhp> is haddock documentation ever used/generated for programs (ie not libraries)?
19:53:45 <dibblego> @users
19:53:46 <lambdabot> Maximum users seen in #haskell: 555, currently: 506 (91.2%), active: 19 (3.8%)
19:53:47 <roconnor> @type choose
19:53:48 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
19:54:03 <Axman6> rawr, hmatrix gives me segmentation faults when i run runTests (n>10)
19:56:52 <roconnor> @type stdGen
19:56:54 <lambdabot> Not in scope: `stdGen'
19:56:59 <roconnor> @hoogle Gen
19:57:00 <lambdabot> Test.QuickCheck data Gen a
19:57:00 <lambdabot> Data.Char data GeneralCategory
19:57:00 <lambdabot> Data.Char generalCategory :: Char -> GeneralCategory
19:57:05 <roconnor> @hoogle Gen a -> a
19:57:05 <lambdabot> Prelude id :: a -> a
19:57:05 <lambdabot> Data.Function id :: a -> a
19:57:05 <lambdabot> Test.QuickCheck generate :: Int -> StdGen -> Gen a -> a
19:57:20 <dibblego> hey guys, laught is our latest learner
19:57:34 <dons> welcome, laught
19:57:39 <laught> lol
19:57:40 <laught> hi
19:57:51 <laught> well, you'll have to convince me
19:57:52 <laught> :P
19:58:00 <araujo> laught, you want the red pill or the blue pill?
19:58:10 <pumpkin> lol
19:58:19 <Axman6> laught: if you spend enough time listening to dons, you'll be convinced
19:58:19 <dibblego> ;)
19:58:34 <laught> heh
19:58:36 <laught> like dibblego ?
19:58:37 <laught> :P
19:58:39 <ivanm> Axman6: if only to shut him up? ;-)
19:58:48 <pumpkin> haskell is your only option if you want to survive the post-apocalyptic world of tomorrow
19:59:02 <dons> that's true enough.
19:59:27 <dons> laught: here, check out what we've been talking about today, a 16 line implementation of the knight's tour puzzle, http://haskell.org/haskellwiki/The_Knights_Tour#LogicT_monad
19:59:28 <ivanm> pumpkin: which apocalypse are you referring to?
19:59:28 <lambdabot> Title: The Knights Tour - HaskellWiki
19:59:32 <dons> we like games.
19:59:36 <ivanm> I can think of about 4 that are scheduled for tomorrow
19:59:37 <ivanm> ;-)
19:59:45 <pumpkin> ivanm: one of those, you decide :)
19:59:48 <ivanm> dons: did you see the reddit comment about it?
19:59:50 <ivanm> pumpkin: heh
20:00:03 <Axman6> dons: we don't want to scare him off
20:00:05 <dons> was it someone arguing they could do it in one function, with sufficient libraries?
20:00:21 <dons> that's the usual argument for short solutions.
20:00:29 <pumpkin> then people should be arguing against python in the first place
20:00:31 <dmwit> yup, pretty much
20:00:37 <ivanm> dons: they proposed a new DSL, and then asked if anyone wanted to buy it ;-)
20:00:37 <dons> though doesn't really get at the fact we defined a pseudo-Prolog as a freaking monad in our language.
20:00:41 <dons> ivanm: ah
20:00:43 <pumpkin> and say "find me the shortest solution in arch x's assembly language"
20:00:56 <dons> ah yes
20:02:08 <pumpkin> hpaste never remembers me :(
20:02:17 <dons> it remembers nothing!
20:02:23 <Axman6> hpaste is pretty broken imp
20:02:37 <dons> its a 1.0 feature
20:02:39 <pumpkin> solrize: better? http://hpaste.org/12556
20:02:46 <dons> try hpaste 2.0
20:03:18 <Axman6> any reason hpaste isn't hpaste2.0 yet?
20:03:23 <ivanm> what happened to the hpaste bot, anyway?
20:03:41 <Axman6> yeh, it was really handy
20:03:46 <solrize> pumpkin about the same
20:03:56 <pumpkin> solrize: but I used a list comprehension this time :P
20:04:45 <solrize> :t (sum .)
20:04:47 <lambdabot> forall a a1. (Num a) => (a1 -> [a]) -> a1 -> a
20:04:53 <u_quark> a network Handle is shared between to threads and when I attempt to hPutStrLn to it i get stack overflow - any idea why ?
20:05:18 <pumpkin> solrize: how bout http://hpaste.org/12556#a1 ?
20:05:19 <Axman6> u_quark: hpaste the code
20:05:22 <u_quark> two* threads
20:05:23 <dmwit> u_quark: Sounds like there's some laziness issues.
20:06:14 <solrize> pumpkin, that makes a lot more sense
20:06:19 <pumpkin> yay :)
20:06:59 <roconnor> I wonder when I should or shouldn't reexport modules
20:07:05 <solrize> why isnt dot   (sum . zipwith (*)) ?
20:07:09 <erikc> whats the reason for Data.Binary.Get being only for lazy bytestrings?
20:07:11 <solrize> instead of (sum .)  .
20:07:25 <Axman6> :t (sum . zipWith (*))
20:07:26 <pumpkin> :t sum . zipWith (*)
20:07:28 <lambdabot>     Couldn't match expected type `[a]'
20:07:28 <lambdabot>            against inferred type `[a1] -> [a1]'
20:07:28 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
20:07:28 <lambdabot>     Couldn't match expected type `[a]'
20:07:28 <lambdabot>            against inferred type `[a1] -> [a1]'
20:07:30 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
20:07:33 <pumpkin> :P
20:07:38 <solrize> :t zipWith (*)
20:07:39 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
20:07:42 <pumpkin> :t (sum .) . zipWith (*)
20:07:43 <lambdabot> forall a. (Num a) => [a] -> [a] -> a
20:07:47 <dmwit> solrize: So that two arguments get passed to zipWith.
20:07:55 <solrize> :t sum . (zipWith (*))
20:07:56 <lambdabot>     Couldn't match expected type `[a]'
20:07:56 <lambdabot>            against inferred type `[a1] -> [a1]'
20:07:56 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
20:08:35 <Axman6> pumpkin: you might want to check out hmatrix, is has a lot of this stuff in there, including dot and others (it uses LAPACK and BLAS and suff)
20:08:57 <pumpkin> ah yes, I was just afraid of compiling either of those on my mac
20:09:02 <pumpkin> but I have gsl
20:09:19 <solrize> :t (let dot xs ys = sum [x*y | (x,y)<-zip xs ys] in dot)
20:09:20 <lambdabot> forall b. (Num b) => [b] -> [b] -> b
20:09:26 <Axman6> i just did it again, worked fine (when i didn't use macports for gsl)
20:09:53 <pumpkin> Axman6: so you have fortran on your mac?
20:09:59 <solrize> :t (let dot xs ys = sum (zipWith xs ys) in dot)
20:10:00 <lambdabot>     Couldn't match expected type `[a]'
20:10:00 <lambdabot>            against inferred type `[b] -> [c]'
20:10:00 <lambdabot>     In the first argument of `sum', namely `(zipWith xs ys)'
20:10:01 <Axman6> no...?
20:10:05 <Axman6> why would i?
20:10:07 <solrize> :t (let dot xs ys = sum (zipWith (*) xs ys) in dot)
20:10:08 <lambdabot> forall a. (Num a) => [a] -> [a] -> a
20:10:10 <pumpkin> Axman6: which LAPACK/BLAS did you install?
20:10:20 <Axman6> OS X comes with BLAS and LAPACK
20:10:21 <solrize> i think i'd write  dot that way
20:10:40 <pumpkin> oh yeah
20:10:52 <pumpkin> in the accelerate framework, right
20:10:54 <pumpkin> forgot about that
20:10:55 <Axman6> well optimised versions too i might add
20:11:11 <walski> is there some kind of "unwords" where I can specify the delimiting character?
20:11:14 <dmwit> solrize: That is likely to expand to the same core; at the very least, those two definitions are semantically equivalent, modulo the MR.
20:11:24 <solrize> MR ?
20:11:28 <pumpkin> Axman6: need to do anything special to get it to install? just doing cabal install failed for me
20:11:33 <dons> walski: intersperse ?
20:11:34 <dmwit> walski: intercalate, intersperse
20:11:43 <solrize> yeah, they are equivalent, i just found the pointful version easier to read
20:11:44 <dmwit> solrize: monomorphism restriction
20:11:48 <Axman6> pumpkin: install gsl by hand... what's the error?
20:12:22 <solrize> i wonder if the listcomp can parallelize
20:12:34 <Axman6> solrize: it can, if you use DPH
20:12:47 <Axman6> it's one of the examples often used when showing off DPH
20:12:52 <solrize> cool
20:12:57 <pumpkin> Axman6: oh never mind, it worked fine, I'm stupid (even with the MacPorts GSL, it seems)
20:13:14 <solrize> can dph deal with the pointfree version?
20:13:33 <Axman6> pumpkin: you'll find it can't load the gsl lib from macports, so you should install it yourself
20:13:49 <pumpkin> ah ok
20:13:53 <pumpkin> do these things come with testsuites?
20:13:54 <Axman6> pumpkin: when you try and run Numeric.LinearAlgebra.Tests.runTests it'll whinge
20:14:17 <dolio> @yow! Mailman day!
20:14:17 <lambdabot> NANCY!!  Why is everything RED?!
20:14:18 <Axman6> i get a seg fault when i run runTests with n > 10 though
20:15:04 <dons> dolio: This page has been accessed 1,000 times
20:15:11 <pumpkin> Axman6: :o works fine for me, even > 10
20:15:15 * dolio is famous!
20:15:20 <Axman6> hmm, how odd
20:15:23 <dons> you're an internet sensation.
20:15:37 <pumpkin> what is the parameter to runTests? is it just repetitions?
20:15:47 <erikc> dons:
20:15:56 <erikc> err, whats the reason for Data.Binary.Get being only for lazy bytestrings?
20:16:06 <dons> it's efficient?
20:16:13 <solrize> http://developers.slashdot.org/comments.pl?sid=1046193&cid=25935257
20:16:14 <dons> you can stream it into zlib or other compressors
20:16:15 <lambdabot> Title: Solving the Knight's Tour Puzzle In 60 Lines of Python, http://tinyurl.com/6rsr78
20:16:22 <solrize> prolog :)
20:16:36 <erikc> theres no cost for going from strict -> lazy i assume?
20:16:39 <erikc> with fromChunks
20:17:03 <dons> no, its cheap
20:17:04 * erikc is writing a native haskell ELF library
20:17:12 <dons> oh, you should talkk to sjw@cse.unsw.edu.au
20:17:13 <erikc> k
20:17:19 <dons> he wrote one a couple of years ago for a big project
20:17:44 <pumpkin> erikc: cool, I've started on a MachO library :P we should make a binary format library!
20:17:46 <solrize> http://developers.slashdot.org/comments.pl?sid=1046193&cid=25935403
20:17:48 <solrize> heh
20:17:48 <lambdabot> Title: Solving the Knight's Tour Puzzle In 60 Lines of Python, http://tinyurl.com/6xlmj3
20:17:52 <solrize> perl
20:18:12 <Axman6> pumpkin: what's the MachO library do exactly?
20:18:19 <dons> yeah, someone should mention that haskell stomps on python. slashdot boo
20:18:31 <Saizan> what are the packages with the larger number of dependencies?
20:18:45 <pumpkin> Axman6: not much yet, but it'll read in the MachO and allow you to access information about it in a useful format (eventually for static analysis, is the goal)
20:18:54 <erikc> pumpkin: ooo, i might need that as a frontend for my project :)
20:19:01 <dons> Saizan: gitit?
20:19:04 <pumpkin> Axman6: I've already written a pretty extensive mach-o loader in ruby and wanted to try it in haskell
20:19:16 <Axman6> sounds good
20:19:44 <erikc> elf/macho/pe -> dwarf/pdb -> auto-generated c bindings to object + small runtime == scriptable C
20:19:56 <pumpkin> :)
20:20:01 <erikc> == sanity for erikc
20:22:49 <solrize> As the credit crunch bites, Britons may be turning to sex as a cheap way to pass the time, a charity says.
20:22:55 <solrize> heh
20:24:25 <Taejo> solrize: young people have always known how to solve money
20:24:26 <pumpkin> http://hackage.haskell.org/packages/archive/carray/0.1.3/doc/html/Data-Array-CArray-Base.html#t%3ACArray clames mapCArrayInPlace is a function, but I can't seem to use it
20:24:32 <lambdabot> Title: Data.Array.CArray.Base, http://tinyurl.com/5rjpbg
20:27:02 <pumpkin> maybe I shouldn't use it
20:27:17 <pumpkin> it seems pretty side-effectish
20:28:09 <solrize> can't you do that autocorrelation with an fft or something?
20:28:14 <pumpkin> yup
20:28:17 <pumpkin> that's what I'm trying now :)
20:28:24 <solrize> heh
20:28:25 <pumpkin> just need to get the right CArray types for Math.FFT
20:28:31 <solrize> k
20:28:44 <pumpkin> but I can't find a map function on an Array
20:28:52 <pumpkin> there's ixmap, but that seems only for indices
20:29:15 <mmorrow> @type amap
20:29:16 <lambdabot> Not in scope: `amap'
20:29:21 <mmorrow> , src 'amap
20:29:26 <lunabot>  amap :: forall a e' e i . (IArray a e', IArray a e, Ix i) => (e' ->
20:29:26 <lunabot>                                                                e) ->
20:29:26 <lunabot>                                                               (a i e') -> ...
20:30:18 <pumpkin> hmm, with an apostrophe?
20:30:20 <mmorrow> , src 'VarI
20:30:24 <mmorrow> heh
20:30:25 <lunabot>  data Info = ... | VarI Name Type (Maybe Dec) Fixity | ...
20:30:25 <lunabot>  infixl 9
20:30:37 <pumpkin> @hoogle amap
20:30:38 <lambdabot> Data.Array.Base amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
20:30:38 <lambdabot> Data.Array.IArray amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
20:30:58 <Saizan> pumpkin: why are you specifically using carray?
20:31:03 <mmorrow> , ppDoc . (\(VarI _ (ForallT _ _ t) _ _) ->t) $ $(lift =<< reify 'amap)
20:31:06 <lunabot>  (e'_0 -> e_1) -> (a_2 i_3 e'_0) -> a_2 i_3 e_1
20:31:09 <pumpkin> Saizan: because Math.FFT wants it, it seems
20:31:13 <mmorrow> , ppDoc' . (\(VarI _ (ForallT _ _ t) _ _) ->t) $ $(lift =<< reify 'amap)
20:31:15 <lunabot>  (e' -> e) -> (a i e') -> a i e
20:31:18 <mmorrow> there
20:31:21 <mmorrow> phew
20:31:43 <Saizan> pumpkin: ah, k, i thought you were writing Math.FFT :)
20:31:49 <pumpkin> nah :P
20:31:52 <pumpkin> fftw is plenty fast
20:31:55 <asdfiest> --Graph e n -> n -> Graph e n
20:31:59 <asdfiest> wtf
20:32:00 <dons> reuse, reuse.
20:32:01 <pumpkin> especially after I spent 14 hours computing wisdom for it
20:32:06 <mmorrow> pumpkin: yeah, fftw is /super/ fast
20:32:17 <mmorrow> haha, 14hrs
20:32:20 <dons> pumpkin: so are you using the haskell fftw binding?
20:32:24 <pumpkin> dons: yup
20:32:32 <asdfiest> --Graph e n -> n -> Graph e n, hiw would immodel that? data Grpah = n | Graph?
20:32:41 <mmorrow> pumpkin: yer codez'll be friggin screaming
20:32:47 <pumpkin> mmorrow: yay :D
20:32:54 <dons> pumpkin: awesome. you should blog about it.
20:33:03 <dons> i've not seen any examples of using the fftw binding yet
20:33:03 <Axman6> isn't djbfft supposed to be faster than fftw?
20:33:12 <pumpkin> I'd need a blog first
20:33:16 <mmorrow> @go djbfft
20:33:17 <pumpkin> I'll tweet about it for now :P
20:33:31 <lambdabot> Plugin `search' failed with: thread killed
20:33:34 <mmorrow> > "hai"
20:33:35 <lambdabot>   "hai"
20:33:39 <mmorrow> hmm
20:33:40 <solrize> http://cr.yp.to/djbfft.html
20:33:49 <mmorrow> thx
20:33:52 <solrize> claims to be faster than fftw
20:33:55 <pumpkin> :o
20:33:57 <dons> in all cases?
20:34:00 <pumpkin> but fftw has codelets!
20:34:02 <solrize> well, some
20:34:05 <pumpkin> and is supercute
20:34:13 <dons> "The current version holds most of the speed records for double-precision FFTs on general-purpose computers."
20:34:15 <solrize> djb has a big rant about fft benchmarking
20:34:17 <dons> fair enough.
20:34:32 <Axman6> D. J. Bernstein  is pretty crazy, written some very impressive stuff
20:34:38 <solrize> yeah :)
20:34:42 <dons> "my paper Multidigit multiplication for mathematicians, which presents every known technique for integer multiplication and every known technique for polynomial multiplication"
20:34:54 <dons> anyone what to implement that paper? Cale? dolio? Pseudonym?
20:34:56 <solrize> heh, that's not too far off
20:35:16 <pumpkin> super fast!
20:35:20 <pumpkin> autocorrelation' = elems . dftCR . amap (^2) . dftRC . listToCArray
20:35:47 <dons> cute
20:35:47 <pumpkin> I guess I can get rid of that ugly listToCArray function I wrote
20:35:54 <solrize> http://cr.yp.to/papers.html#m3 	19pp 		refereed 		2001.08.11 [PDF] [more]
20:35:54 <solrize> DJB. ``Multidigit multiplication for mathematicians.'' Accepted to Advances in Applied Mathematics, but withdrawn by author to prevent irreparable mangling by Academic Press.
20:35:59 <solrize> hehe
20:36:11 <Axman6> djcdns is supposed to be very good, and far easier to configure than BIND
20:36:11 <erikc> hah, awesome
20:36:29 <dons> dcoutts_: at least one F# guy has started  using gtk2hs based on the RWH chapter on guis
20:36:40 <Axman6> Law and public policy
20:36:41 <Axman6> Bernstein v. United States
20:37:42 <solrize> yeah, that was an important case that got the crypto export laws mostly fixed, they were totally insane previously
20:38:09 <p_l> solrize: What isn't, in USA, except for Network Neutrality law?
20:38:15 <Axman6> pumpkin: kinda old chips, but: Pentium, Pentium MMX: djbfft 0.76 has been carefully tuned for these chips. It is more than twice as fast as FFTW 2.
20:38:18 <Axman6> Pentium Pro, Pentium II, Pentium III: djbfft 0.76 has been partially tuned for these chips. It is noticeably faster than FFTW 2.
20:38:27 <pumpkin> FFTW3 though, how does it compare to those?
20:38:33 <pumpkin> FFTW is quite different from 2
20:38:37 <pumpkin> *3
20:38:51 <solrize> dunno, i guess djbfft is sort of old these days and predates fftw3
20:38:55 <Axman6> no idea, i don't think hes done much work on djbfft for a while
20:40:23 <pumpkin> on a list of size 2^12, my naive autocorrelation takes 4.48 seconds and my FFT-based one takes 0.05 seconds
20:40:43 <steven_h> quick question: is random number generation really slow in GHC ?
20:40:50 <dmwit> No, why?
20:41:19 <Axman6> pumpkin: heh, nice
20:41:39 <steven_h> I've a simple Haskell program that's much slower than equivalent python, and profiling says it's spending its time generating random numbers
20:41:58 <pumpkin> maybe it's using lists in a way lists aren't meant to be used?
20:42:02 <dolio> steven_h: System.Random is slow.
20:42:10 <dolio> Look for the mersenne twister package on hackage.
20:42:53 <steven_h> http://hpaste.org/12558
20:42:59 <steven_h> dolio: ah, OK
20:46:19 <dons> steven_h: yeah, mersenne-random is maybe 100x -> 500x faster than System.Random , depending on the case.
20:46:34 <steven_h> dons: !
20:46:46 <mmorrow> pumpkin: here's a quick ghci session show list -> carray -> fft -> carray -> list  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=520#a520
20:46:51 <steven_h> dons: that seems pretty extreme!
20:46:57 <mmorrow> ah
20:47:03 <mmorrow> @tell pumpkin here's a quick ghci session show list -> carray -> fft -> carray -> list  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=520#a520
20:47:03 <lambdabot> Consider it noted.
20:47:15 <dons> yes. it is extreme.
20:47:31 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random-pure64
20:47:33 <lambdabot> Title: HackageDB: mersenne-random-pure64-0.2.0.2, http://tinyurl.com/5jfqg7
20:47:33 <mmorrow> System.Random needs an overhaul /bad/
20:47:34 <dons> or
20:47:36 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random
20:47:38 <lambdabot> Title: HackageDB: mersenne-random-0.1.3, http://tinyurl.com/5vuy5g
20:47:49 <dons> mmorrow: we could tweak parts of it, definitely.
20:48:12 <mmorrow> dons: i'd definitely be interested in exploring that
20:48:35 <dons> there's a lot of inefficiencies. it's really just an example of how a pure, splittable supply would work.
20:48:39 <dons> never aimed at being high performance
20:48:43 <mmorrow> there's this also, which is nice and short and pasteable http://www.augustsson.net/Darcs/MT/
20:48:48 <dons> so lots of conversions via Integer, for example.
20:49:26 <mmorrow> dons: hmm, so what's the deal with mersenne and splittable again? (i seem to recall there being some catch)
20:49:41 <dons> you can't split it.
20:49:53 <mmorrow> ah, dang.
20:49:54 <dons> there's only a handful or less of splittable pngs. mt isn't one of them.
20:50:07 <mmorrow> oh, so that's inherent in the algo then i guess
20:50:08 <dons> but hey, split. bah
20:50:11 <mmorrow> heh
20:50:14 <Axman6> anyone looked at http://pastry.se/ before? seems like a very nice paste bin indeed (with diffs of edts etc)
20:50:18 <dons> life goes on.
20:50:24 * mmorrow never uses split
20:50:50 <Axman6> and multiple code blocks
20:51:44 <roconnor> @type Endo
20:51:45 <lambdabot> forall a. (a -> a) -> Endo a
20:51:58 <roconnor> @instance Endo Monoid
20:51:59 <lambdabot> Maybe you meant: instances instances-importing
20:52:12 <roconnor> @src Endo Monoid
20:52:13 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:52:19 <roconnor> @src Monoid Endo
20:52:19 <lambdabot> Source not found. Are you on drugs?
20:52:24 <dons> wow. google's book search is awesome.
20:52:32 <dolio> @src Endo mempty
20:52:33 <lambdabot> Source not found. You speak an infinite deal of nothing
20:52:39 <dons> when you search for some string, and it cites a 100 year old book, highlighting the page the quote is from.
20:52:42 <dons> the future is here.
20:52:45 <Axman6> @src Endo
20:52:46 <lambdabot> Source not found. My pet ferret can type better than you!
20:53:26 <dons> i bet english lit. students must love this book search business
20:53:30 <roconnor> why no source code for http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html ?
20:53:32 <lambdabot> Title: Data.Monoid, http://tinyurl.com/szdxl
20:53:50 <andrewsw> dons: I recently foudn an excellent 160y.o. legal source from google book search. it was awesome.
20:54:03 <dons> yeah. amazing.
21:01:16 <pumpkin_> I think I'll resurrect an old blog and start writing about haskell on it
21:01:18 <pumpkin_> this is too fun to not get the word out
21:01:41 <andrewsw> I think so. They are flying over the pole to spain and then cruising from their, I guess.
21:01:52 <andrewsw> oops, wrong channel
21:04:12 <Axman6> dons: that random packahe of yours looks pretty awesome, good work (as always)
21:04:40 <dons> it came out of frustration with System.Random in a monte carlo simultation project
21:05:04 <dons> i sat on it for a year or so too. should have uploaded it earlier.
21:05:05 <Axman6> heh, i see
21:05:06 <mmorrow> pumpkin_: ah, i'm not sure how your listToCArray function is working, but here's a way to go list->carray fwiw http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=520
21:05:11 <MyCatVerbs> dons: ...how frustrated are we talking here?
21:05:20 <mmorrow> (i sent an @tell to pumpkin)
21:05:26 <dons> well, System.Random is teh slow
21:05:42 <MyCatVerbs> dons: and what was it that annoyed you - the (awfully tiny?) internal state space, or the speed, or what?
21:06:14 <dons> speed
21:07:02 <pumpkin_> mmorrow: my listToCArray is kinda stupid to even make into a separate function: listToCArray xs = listArray (0, length xs - 1) xs
21:07:19 <mmorrow> pumpkin_: heh, that's the exact code i was suggesting :)
21:07:37 <pumpkin_> listArrayZeroBased seems like a better name
21:07:38 <MyCatVerbs> dons: on each generation it does what, one multiplication, one addition and one modulo operation?
21:07:41 <pumpkin_> or something
21:07:52 <mmorrow> err, something like this may be worth it:
21:08:32 <mmorrow> listToCArray xs = let n = length xs - 1 in n `par` listArray (0,n) xs
21:08:34 <MyCatVerbs> dons: or perhaps two moduli. That shouldn't be _fantastically_ slow, despite the modulo operations, unless it's being run on full GMP integers for something?
21:08:47 <pumpkin_> mmorrow: :o what does that do?
21:08:54 <mmorrow> or some way that doesn't require two traversals of the list, since it may be massive
21:09:01 <pumpkin_> ooh
21:09:05 <pumpkin_> I was just wondering about something like that
21:09:16 <pumpkin_> how is it smart enough to make `par` do the right thing there?
21:09:16 <Axman6> dons: your monte carlo example here http://hackage.haskell.org/packages/archive/mersenne-random/0.1.3/doc/html/src/System-Random-Mersenne.html#randoms doesn't compile. it just takes a number from getArgs... and does nothing with it
21:09:18 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5wssll
21:09:32 <mmorrow> i'm not sure if that exact code would actually parallelize it, but it's worth a shot
21:10:07 <mmorrow> pumpkin_: like in this code, it /does/ hugely speed things up:
21:10:46 <mmorrow> mean xs = let n = length xs; s = foldl' (+) 0 xs in n `par` s `pseq` s / n
21:10:47 <dons> Axman6: ?
21:10:51 <dons> -- >         | throws >= lim  =
21:11:12 <Axman6> dons: huh?
21:11:19 <pumpkin_> mmorrow: I'm amazed :P
21:11:19 <dons> it's missing the call to 'go'
21:11:33 <mmorrow> pumpkin_: so was i :)
21:11:38 <Axman6> yeah... i wasn't sure how to add the call in
21:11:42 <mmorrow> s/was/am/
21:12:07 <dons> call it. i'd bet there's an example in the src.
21:12:10 <dons> in the repo
21:12:42 <pumpkin_> @hoogle par
21:12:42 <lambdabot> Control.Parallel par :: a -> b -> b
21:12:42 <lambdabot> Text.XHtml.Frameset paragraph :: Html -> Html
21:12:42 <lambdabot> Text.XHtml.Strict paragraph :: Html -> Html
21:13:02 <pumpkin_> I'll have to look up Control.Parallel some more, looks fascinating
21:13:14 <pumpkin_> so far I've only been using .Strategies to evaluate my lazy lists using rnf
21:14:30 <mmorrow> , let mean xs = let n = length xs; s = foldl' (+) 0 xs in n `par` s `pseq` s / n in mean [0..10000000]
21:14:31 <pumpkin_> what's nicest, listArray0Based, listArrayZeroBased, listToCArray?
21:14:31 <lunabot>  luna: No instance for (GHC.Real.Fractional GHC.Types.Int)
21:14:47 <mmorrow> , let mean xs = let n = length xs; s = foldl' (+) 0 xs in n `par` s `pseq` fromIntegral s / fromIntegral n :: Double in mean [0..10000000]
21:14:52 <lunabot>  luna: out of memory (requested 2097152 bytes)
21:14:55 <pumpkin_> aw
21:14:58 <mmorrow> , let mean xs = let n = length xs; s = foldl' (+) 0 xs in n `par` s `pseq` fromIntegral s / fromIntegral n :: Double in mean [0..100000]
21:15:12 <lunabot>  50000.0
21:15:13 <mmorrow> , let mean xs = let n = length xs; s = foldl' (+) 0 xs in n `par` s `pseq` fromIntegral s / fromIntegral n :: Double in mean [0..1000000]
21:15:15 <lunabot>  500000.0
21:15:31 <mmorrow> , let mean xs = let n = length xs; s = foldl' (+) 0 xs in fromIntegral s / fromIntegral n :: Double in mean [0..1000000]
21:15:34 <lunabot>  500000.0
21:16:04 <mmorrow> gah, well with +RTS -N2 -RTS the mean with par is faster by multiple seconds on massive input lists
21:16:32 <pumpkin_> cool
21:16:37 <pumpkin_> I'll try it in ghci with +s
21:17:22 <mmorrow> hmm, i'm not sure what'll do in ghci..
21:17:29 <pumpkin_> hmm, in ghci it's actually slower :)
21:17:35 <mmorrow> heh
21:17:36 <pumpkin_> but I guess that's because it hasn't optimized anything
21:17:46 <mmorrow> ghc -O2 -threaded --make mean.hs
21:18:01 <mmorrow> then run with  ./mean +RTS -N2 -RTS
21:18:07 <mmorrow> and it'll scream
21:18:10 <pumpkin_> whee
21:18:14 <dons> woot. haskell outranking K&R! http://www.amazon.com/gp/bestsellers/books/3952/ref=pd_zg_hrsr_b_1_4_last
21:18:14 <mmorrow> (if you have >1 core)
21:18:17 <lambdabot> http://tinyurl.com/6efp74
21:18:31 <pumpkin_> yeah, I do
21:18:36 <mmorrow> dons: heh
21:18:37 <johnnowak> dons: very nice
21:18:40 <dons> outranking the python book too. world domination is at hand!
21:18:45 <dons> prepare your lambdas.
21:19:07 <johnnowak> you just bought 50 copies for your family five minutes ago, didn't you
21:19:10 <dons> hehe
21:19:17 <juhp> https://fedoraproject.org/wiki/PackagingDrafts/Haskell for those interested
21:19:19 <lambdabot> Title: PackagingDrafts/Haskell - FedoraProject
21:19:22 <juhp> dons: cool
21:19:52 <Axman6> dons: seems i got onto this haskell thing at a good time
21:19:56 <Axman6> :0
21:19:56 <dons> yay Fedora. yes, saw lots of buzz around the new Fedora bootscreen that has the 'install haskell' box to tick
21:19:58 <Axman6> :)*
21:20:17 <juhp> dons: oh really?  nice :)
21:20:24 <dons> you get to choose between a haskell, java or ruby environment
21:20:31 <dons> we need that on every distro..
21:20:35 <juhp> :-)
21:20:57 <juhp> yeah I added that :)
21:21:16 <mmorrow> [m@ganon ~]$ javac
21:21:16 <mmorrow> bash: javac: command not found
21:21:18 <mmorrow> hehe
21:21:28 <dons> haha
21:21:51 <pumpkin_> mmorrow: if I wanted to define return types for mean, what's a good type that would allow for means of Ints being doubles, and means of complex numbers being complex (or other foreseeable instances of Num(
21:22:04 <dons> a LogicT monad stack for every child this holiday.
21:22:26 <dons> mean :: Num a => [a] -> a ?
21:22:33 <dons> mean :: Num a, Num b => [a] -> b ?
21:22:45 <pumpkin_> the latter is what I have
21:22:47 <dons> i think i just stuck to fast types in stats-fusion package.
21:22:48 <mmorrow> i guess the (/) would constrain you a bit
21:22:52 <dons> yeah
21:22:52 <pumpkin_> yeah
21:23:04 <dons> http://hackage.haskell.org/packages/archive/statistics-fusion/0.1/doc/html/Math-Statistics-Fusion.html#v%3Amean
21:23:05 <lambdabot> Title: Math.Statistics.Fusion, http://tinyurl.com/6x5pt6
21:23:06 <pumpkin_> fractional maybe?
21:23:07 <dons> mean :: UArr Double -> Double
21:23:07 <dons> haha
21:23:30 <mmorrow> sweet
21:23:33 <mmorrow> @type (/)
21:23:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:23:46 <dons> i like code that includes Core output in comments.
21:23:54 <dons> http://hackage.haskell.org/packages/archive/statistics-fusion/0.1/doc/html/src/Math-Statistics-Fusion.html
21:23:56 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5nm3uk
21:25:01 <pumpkin_> mmorrow, dons: so Num a, Fractional b, would that make sense?
21:25:27 <mmorrow> yeah, i think that'll be the most general type you could give it
21:26:00 <roconnor> data TransferFunction a = TransferFunction
21:26:00 <roconnor>                           { transfer :: a -> a
21:26:00 <roconnor>                           , transferInverse :: a -> a
21:26:00 <roconnor>                           , transferGamma :: a }
21:26:07 <roconnor> is it worth making transferGamma strict?
21:26:20 <mmorrow> and you could use {-# SPECIALIZE ... #-} maybe if you desire
21:26:42 <MyCatVerbs> roconnor: how are we supposed to know that? Try it and see. =)
21:27:00 <pumpkin_> hm, don't know much about those pragmas yet
21:27:25 <roconnor> MyCatVerbs: I have no test harness :(
21:27:43 <mmorrow> pumpkin_: check out the ghc manual's section for SPECIALIZE, it's pretty short
21:27:49 <pumpkin_> I wonder if I can parallelize my entropy function easily too
21:28:19 <solrize> borders expects rwh to hit their shelves on december 11
21:28:26 <MyCatVerbs> roconnor: recompile with profiling and see if the amount of time spent in functions that make use of transfer* is significant compared to the rest of your program?
21:28:30 <pumpkin_> oh, I've wondered about that, looks neat mmorrow
21:28:58 <solrize> borders expects rwh to hit their shelves on december 11      <-- dons
21:29:39 <dons> huh. ok.
21:29:54 <dons> i'd have thought it'd get from o'reilly's warehouse faster. wel'll see...
21:30:40 <solrize> they may have to mess around processing it at some central location and then shipping it outwards to individual stores
21:31:02 <dons> we'll see. so far things have been happening ahead of schedule.
21:31:08 <solrize> cool
21:31:11 <dons> amazon's shipping, despite still claiming Dec 5.
21:32:40 <solrize> interesting
21:33:23 <Axman6> wonder when ivanm and i will get ours...
21:35:13 <solrize> it's completely crushing f# for scientists, that's the most important thing :o)
21:35:25 <dons> hehe
21:35:52 <dons> isn't that self published?
21:36:03 <johnnowak> ouch
21:36:58 <solrize> it says wiley-interscience
21:37:12 <dolio> That's cold.
21:37:16 <vaskaren> is f# for sicentists Harrops book? god who buys anything froma  troll?
21:37:17 <dons> oh, wiley.
21:37:25 <dons> his other stuff is self published.
21:37:42 <solrize> the older ocaml version may have been self published, but (sputter sputter) it's from a VERy imPORTant conSULTancy firm
21:37:52 <dons> mainly because he has no friends.
21:38:23 <dibblego> solrize, what is completely crushing it?
21:38:40 <solrize> dibblego, rwh's amazon sales rank
21:38:48 <dibblego> solrize, ah
21:39:00 <dons> i couldn't find jdh's book on amazon. is it available there?
21:39:12 <dons> ah yes. there it is.
21:39:12 <solrize> http://www.amazon.com/F-Scientists-Jon-Harrop/dp/0470242116
21:39:16 * dons kept scrolling.
21:39:35 <Axman6> anyone played with CouchDB before?
21:39:47 <solrize> axman6 i've looked at it a little
21:39:55 <arcatan> anyone played with CouchDB _after_?
21:40:11 <dons> yes. it is crushing
21:40:18 <dons> Axman6: seen the haskell bindings?
21:40:37 <Axman6> dons: i have, i'm installing CouchDB atm so i can play with them :0
21:40:38 <Axman6> :)*
21:40:43 <dons> cool
21:40:55 <hackage> Uploaded to hackage: vty 3.1.6
21:41:01 <Axman6> been trying to think of something i can code for the last few days, and haven't thought of anything
21:41:08 <vaskaren> solrize; urgn dont post tit
21:41:19 <Axman6> then i found CouchDB was written in erlang and was pleased
21:41:27 <solrize> vaskaren oh right, i forgot :)
21:41:31 <solrize> irish ship of the desert :)
21:42:21 <Axman6> "Body": "I decided today that I don't like baseball. I like plankton."
21:42:28 <Axman6> what an odd example
21:42:40 <arcatan> makes sense
21:47:54 <pumpkin_> http://hpaste.org/12559 can anyone see any obvious way to make it faster/better/stronger/cooler? :)
21:48:04 <Axman6> can cabal-install be set to automatically compile with -p -O2?
21:48:51 <jsn> pumpkin_: i do not see an obvious way, no
21:49:29 <dons> Axman6: yeah, in the config file.
21:50:05 <dons> -- library-profiling: False
21:50:12 <dons> -- flags:
21:50:14 <dons> in .cabal/config
21:50:20 <dons> someone write a post about it!
21:50:24 <Axman6> i want profiling, but yeah, thanks
21:52:42 <dons> dolio: you're doubly famous, This page has been accessed 2,000 times
21:52:53 <dolio> @yow!
21:52:54 <lambdabot> An Italian is COMBING his hair in suburban DES MOINES!
21:55:06 <pumpkin_> :o
21:56:03 <shapr> @yow !
21:56:03 <lambdabot> Yow!  I'm imagining a surfer van filled with soy sauce!
21:56:05 <shapr> @users
21:56:05 <lambdabot> Maximum users seen in #haskell: 555, currently: 496 (89.4%), active: 18 (3.6%)
21:56:36 <dolio> pumpkin_: Oh, I wasn't doing x * log_2 x, was I?
21:56:46 <pumpkin_> dolio: can't remember now :)
21:56:55 <dolio> I think I may have been doing ln x.
21:56:57 <pumpkin_> I think not
21:56:59 <dolio> Which is clearly not right. :)
21:57:00 <Axman6> zomg, i hear a cicada! really must be summer time
21:57:02 <shapr> dons: Visting NYC or DC? DC is quite aways from Boston...
21:57:45 <pumpkin_> maybe a comprehension would be clearer than (*) <*> logBase 2
21:59:23 <dolio> @type IM.size
21:59:24 <lambdabot> forall a. IM.IntMap a -> Int
21:59:36 <dons> shapr: all booked out on this trip. but early next year should find time.
21:59:48 <shapr> dons: Sounsd good.
22:00:03 <dolio> pumpkin_: That may be faster than taking the length. I'm not entirely sure.
22:00:21 <pumpkin_> hmm, I was also thinking of parallelizing that length computation like mmorrow did earlier with mean
22:00:24 <dolio> Wait, that's not right anyway.
22:00:38 <pumpkin_> hm?
22:00:45 <dons> well, someone should implement a parallel reduce strategy (steal the parallel scans and folds from DPH)
22:00:52 <dolio> The size of the map isn't the length of the list.
22:00:56 <pumpkin_> oh, true
22:02:09 <bos> dons: there's a simple parallel reduce in this book called RWH
22:02:11 <hd_> noob question: what's the symbol for comments in haskell
22:02:15 <pumpkin_> --
22:02:20 <pumpkin_> or {- -}
22:02:23 <dolio> If you have 'foo x = bar . baz . ... $ x' I'd just peel off the x.
22:02:27 <hd_> thanks
22:02:33 <bos> dons: good book, you should check out the reviews on amazon. you'd like it.
22:02:54 <scodil> what happens when an application of par is hidden behind a thunk? What happens when it's forced, does it spawn a new thread? Or, feed a waiting one? Or does the laziness defeat par?
22:03:05 <dibblego> bos, I just wrote a review that lazy evaluation sucks and we should all use Ocaml er wait no F# now right?
22:03:07 <dons> bos, yeah. i know. i just added some tags relevant to that actually :)
22:03:12 <pumpkin_> dolio: which one? I thought that I couldn't peel it off if I bound the parameter to a name?
22:03:13 <dolio> That's a legitimate case for eliminating a point.
22:03:22 <dons> dibblego: mate. come on. ;)
22:03:24 <bos> dons: ooh, good thinking!
22:03:33 <dolio> Oh, right. Geeze. I need to pay attention. :)
22:03:42 <dons> bos, its interesting what shows up on the different tags. e.g. for 'concurrent programming' or 'parallel programming'
22:04:10 <pumpkin_> dolio: I tried to get rid of it, but couldn't figure out a good way since it's used in multiple places
22:04:27 <dolio> Yeah.
22:08:15 <pumpkin_> there, I think that's a lot clearer: http://hpaste.org/12559#a1
22:08:24 <pumpkin_> with the comprehension rather than the weird <*>
22:08:53 <dolio> Yeah.
22:09:15 <dolio> foldl' (+) 0 doesn't need parentheses.
22:09:24 <dolio> Was sum causing stack overflows or something?
22:09:30 <pumpkin_> yeah :) on large tests
22:09:38 <pumpkin_> and I really don't need it to be non-strict
22:09:40 <dolio> Even when compiled?
22:09:43 <pumpkin_> since it's going to visit them all
22:09:48 <pumpkin_> yeah, I think so
22:10:01 <dolio> Oh well.
22:10:09 <mmorrow> foldl--
22:10:13 <mmorrow> foldl'++
22:10:24 <pumpkin_> why would one write sum with foldl instead of foldl' ?
22:10:32 <pumpkin_> it's not as if you can sum infinite lists anyway
22:10:40 <dolio> foldl' doesn't exist in the report.
22:10:44 <pumpkin_> actually
22:10:54 <pumpkin_> you can sum some infinite lists :o
22:10:59 <pumpkin_> I wonder if there's a neat way to do that :P
22:11:10 <QtPlatyp1s> pumpkin_: No you can only take the limit of partial sums.
22:11:18 <pumpkin_> boo :(
22:11:23 <mmorrow> i think there's some obscure case where you want foldl instead of foldl', but i haven't come across it
22:13:04 <dolio> There are cases where it doesn't matter.
22:13:14 <dolio> Like folding with a constructor.
22:13:41 <dolio> (So, reverse.)
22:13:44 <Axman6> > foldl (const id) [1,2,3]
22:13:46 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
22:13:46 <lambdabot>        arising from a use...
22:13:53 <Axman6> > foldl (const) [1,2,3]
22:13:55 <lambdabot>       Overlapping instances for Show ([b] -> [t])
22:13:55 <lambdabot>        arising from a use o...
22:14:02 <Axman6> > foldl (const id) 0 [1,2,3]
22:14:03 <lambdabot>   3
22:14:19 <Axman6> > foldl (const id) 0 [a,b,c] :: Expr
22:14:21 <lambdabot>   c
22:14:24 <Axman6> bah
22:14:30 <Axman6> > foldl (const f) 0 [a,b,c] :: Expr
22:14:32 <lambdabot>   f c
22:14:43 <Axman6> :t const id
22:14:45 <lambdabot> forall a b. b -> a -> a
22:15:21 <Axman6> > foldl' (const id) 0 [1..]
22:15:23 <Axman6> >_>
22:15:36 <lambdabot>   thread killed
22:15:44 <Axman6> > foldl' (const id) 0 [1..100000000]
22:16:00 <lambdabot>   thread killed
22:16:14 <Axman6> > foldl' (const id) 0 [1..1000000]
22:16:17 <lambdabot>   1000000
22:16:32 <pumpkin_> hmm either my fft autocorrelation is wrong or I'm getting some pretty epic rounding errors on small inputs
22:18:22 <Cheapy> Does anyone here know how to deal with the webpages not loading on LYAH?
22:25:29 <dmwit> Cheapy: Hmm, no.  Which pages are giving you trouble?
22:25:36 <solrize> lyah?
22:25:41 <shapr> lyah!
22:25:45 <mmorrow> lockMask :: KeyMask is capslock, right?
22:25:47 <shapr> The cry of .. what is that?
22:26:26 <pumpkin_> learn you a haskell
22:26:45 <dolio> Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn
22:27:13 <dmwit> mmorrow: I would bet on numlock, myself.
22:27:22 <mmorrow> hmm, ok.
22:27:49 <mmorrow> i want to use caplock as my "myModMask"
22:28:28 <mmorrow> hmm, i think it may be capslock after all
22:28:42 <dmwit> Great!
22:28:42 * mmorrow goes for it
22:29:35 <Cheapy> dmwit: any chapter with more than 1 word in them
22:29:54 <dmwit> WFM
22:29:56 <Cheapy> Fail.
22:30:15 <dmwit> Actually... only Intro works for me.
22:30:17 <dmwit> interesting
22:30:24 <Cheapy> Recursion does to
22:30:30 <dmwit> ?seen BONUS
22:30:30 <lambdabot> I saw BONUS leaving #haskell 10h 6m 34s ago, and .
22:30:48 <dmwit> ?ask BONUS What's up with LYAH?  It seems like most of the chapters are 404'd.
22:30:49 <lambdabot> Consider it noted.
22:30:59 <dmwit> Cheapy: Maybe he got slash-dotted. =)
22:31:21 <Cheapy> slash still has power? ;)
22:31:42 <dmwit> I use that in the broadest possible sense to include reddited, dugg, hackernews'd, etc.
22:31:47 <Cheapy> ahh
22:31:49 <Cheapy> yea
22:32:12 <Cheapy> well probably. odd that only the chapters with more than 1 word in the title break though
22:32:34 <dmwit> Oh, more than one word in the *title*.
22:32:46 <dmwit> This smacks of some kind of -/_ kind of problem.
22:33:44 <dmwit> Although there seems to be separate 404 and "true" 404 pages.
22:42:21 <pumpkin_> hmm, I wonder what's wrong with my fft autocorrelation
22:42:31 <pumpkin_> probably has something to do with the edges
22:48:26 <roconnor> @hoogle inRange
22:48:27 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
22:48:27 <lambdabot> Distribution.Version withinRange :: Version -> VersionRange -> Bool
22:49:10 <roconnor> No instance for (Ix Double)
22:49:14 <roconnor> I guess that is fair
22:49:38 <dolio> Heh.
22:51:07 <dolio> > until (\x -> x/2 == 0) (/2) 1
22:51:09 <lambdabot>   5.0e-324
22:51:33 <dolio> > until (\x -> 1 + x/2 == 1) (/2) 1
22:51:35 <lambdabot>   2.220446049250313e-16
22:52:44 <wagle> i have an 8 gig disk that was overwritten with a new partition table and a new filesystem.  I want to recover the old filesystem as a haskell project..  what should i use to access the file thats a copy of the raw disk?  I'm thinking a memory mapped file of 8 billion bytes..  don't want to copy those bytes around
22:53:07 <pumpkin_> lazy ByteStrings ?
22:53:17 <dibblego> @seen dons
22:53:18 <lambdabot> dons is in #haskell, #xmonad, #darcs, #concatenative, #ghc and #arch-haskell. I last heard dons speak 49m 36s ago.
22:53:32 <pumpkin_> wagle: what fs, out of curiosity?
22:53:34 <dibblego> do we have a canned answer for "Haskell in commercial applications"?
22:53:38 <wagle> ext2
22:53:41 <pumpkin_> ah
22:53:49 <dolio> dibblego: There's something on the wiki.
22:54:02 <pumpkin_> I've done a fair amount of work recovering hfs+, but don't know anything about ext2 :P
22:54:06 <dibblego> dolio, got it ta
22:54:41 <dmwit> There's a library specifically for mmap'ing mutable regions, if you want that; if you want read-only access, lazy bytestrings are the way to go.
22:54:45 <wagle> what i'm hoping is interesting in haskell is piecing the fragments of files together
22:55:13 <wagle> and not trying to make endless copies of all those bytes,
22:55:29 <pumpkin_> will you be attempting to reconstruct the fs in place?
22:55:35 <pumpkin_> or will you just write out what you can find separately?
22:55:57 <wagle> it'd be a read-only file system
22:56:20 <pumpkin_> then I'd go with a ByteString and maybe Data.Binary.Get for reading native ints and stuff
22:57:49 <wagle> as a tangent, you heard of anyone writing FUSE modules in haskell?>
22:58:06 <pumpkin_> http://www.haskell.org/halfs/
22:58:07 <lambdabot> Title: Halfs, A Haskell Filesystem
22:58:15 <wagle> coolio
22:58:20 <pumpkin_> :)
22:58:29 <pumpkin_> also http://darcs.haskell.org/hfuse/
22:58:34 <lambdabot> Title: Index of /hfuse
22:59:12 <pumpkin_> looks like it's relatively simple: http://darcs.haskell.org/hfuse/HelloFS.hs
23:01:05 <dons> dibblego: industry wiki page links to cufp talks
23:01:10 <dons> that's the canned answer i use.
23:01:24 <dibblego> dons, done and dusted and put to bed already :)
23:01:28 <dons> sorted.
23:01:34 <dons> night then.
23:01:38 <dibblego> seeya
23:02:51 <pumpkin_> anyone here done much signal processing in haskell?
23:03:21 <pumpkin_> oh I forgot about the haskell dsp library
23:03:25 <pumpkin_> why am I writing this stuff myself
23:04:14 <solrize> is gmane busted?
23:04:18 <solrize> http://comments.gmane.org/gmane.comp.lang.haskell.cafe/48315 shows me a blank page
23:04:23 <lambdabot> Title: gmane.comp.lang.haskell.cafe
23:04:24 <solrize> as does lots of other gmane urls
23:05:06 <wagle> dons: you have any advice different-than/in-addition-to pumpkin's?
23:05:30 <ksf> how come no paper whatsoever has a date in its title?
23:05:30 <pumpkin_> bah, the haskell dsp lib uses the O(n^2) correlation algo
23:06:02 <pumpkin_> ksf: I've wondered that too... most put it in the filename <firstauthor><year>.pdf or something though
23:06:02 <ksf> there's a dsp lib?
23:06:10 <pumpkin_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dsp
23:06:11 <lambdabot> Title: HackageDB: dsp-0.2.1
23:06:18 <ksf> how should that work, considering there are no real jack bindings?
23:06:19 <wagle> pumpkin_, does isaac show up here any more?
23:06:43 <pumpkin_> ksf: jack?
23:06:49 <pumpkin_> wagle: isaac?
23:06:57 <pumpkin_> (I only started coming here a few days ago)
23:07:06 <wagle> the guy who did halfs..  ah ok
23:07:07 <ksf> http://jackaudio.org/
23:07:11 <lambdabot> Title: JACK | connecting a world of audio
23:07:25 * Twey laughs.
23:07:27 <dmwit> I think there's OpenAL bindings.
23:07:38 <ksf> the only sensible thing to use if you're doing professional audio, and thus the only sensible thing to use if you're doing dsp.
23:07:39 <pumpkin_> ksf: this is pure haskell, it seems
23:07:41 <dmwit> Poke around on Hackage -- there's bound to be a few other libraries that handle sound.
23:07:44 <dmwit> SDL
23:07:45 <dmwit> etc
23:07:50 <ksf> *shudder*
23:08:07 <pumpkin_> ksf: does it deal well with multidimensional input?
23:08:19 <ksf> think virtually no latency and seeking.
23:08:29 <ksf> sound is 2d.
23:08:38 <ksf> or, rather, 1d, depends on pov.
23:08:45 <pumpkin_> signal processing is not just sound though :)
23:08:51 <pumpkin_> I'm talking manyd :P
23:10:37 <ksf> with jack, you can eg. mix your wave tracks in ardour, your midi tracks in rosegarden, postprocess in another prog and synchronize them all at sample resolution using jack.
23:11:08 <pumpkin_> that does sound nice :)
23:11:20 <pumpkin_> but my use case is rather different from an audio engineer's
23:11:36 <ksf> the only thing that's missing in jack's feature set is network support, but the devs just don't like the idea of giving up 0-latency.
23:12:14 <ushdf> jack is nice
23:12:36 <ksf> it's a charm to drop samples to, too.
23:12:41 <ushdf> can't you use some weird ffmpeg black magic to serve from jack
23:13:10 <ksf> you're simply implementing a mapping sampleNumber->amplitude.
23:13:59 <ksf> ...and plug virtual cables into your patchboard jacks.
23:14:33 <ksf> so, basically, jack is doing audio fusion in the background.
23:15:21 <ksf> ...calling a sound generator for sample n, feeding it into an effect for sample n, then putting it somewhere else like a prog that encodes it to disk or directly into an alsa buffer.
23:15:57 <pumpkin_> hmm
23:21:19 <vaskaren> how do i call this: data Graph4 e n = Node4 n (Graph4 e n)
23:21:26 <ksf> http://ardour.org/files/ardour-2.5.png
23:21:31 <ksf> "jack" is on the very right.
23:22:00 <pumpkin_> ksf: I take it you do lots of audio work? :P
23:22:28 <ksf> less than i want to.
23:22:47 <pumpkin_> you a musician?
23:23:09 <ksf> well... i play guitar and listen to bands noone ever heard of, if you mean that.
23:23:18 <pumpkin_> that works :)
23:23:47 <dmwit> That doesn't look like the audacity I remember...
23:23:57 <ksf> i didn't even properly get around to learn keys, although i got myself a really nice keyboard...
23:24:05 <ksf> it's not audiacity.
23:24:14 <dmwit> ardour, eh?
23:24:32 <ksf> audiacity is a hobbyist tool in comparison to ardour.
23:24:53 <ksf> ardour's in the same league as cinelerra.
23:24:53 <vaskaren> how do i call this: data Graph4 e n = Node4 n (Graph4 e n)
23:25:05 <dmwit> Yes, ardour looks much nicer than audacity.
23:25:12 <dmwit> Audacity... is painful.
23:25:15 <dmwit> both to look at and to use
23:25:28 <ksf> both are kinda vi's.
23:25:33 <ksf> ...like blender.
23:25:53 <ksf> written in c, utterly fast, utterly flexible.
23:26:27 <mc__> and utterly odd to use...?
23:26:45 <ksf> very intuitive to use, once you climbed that learning cliff.
23:26:58 <vaskaren> would it be possibl to rewrite haskell to be right assosicateive?
23:27:09 <dmwit> wut.
23:27:16 <ksf> as in "you can spend a couple of days trying to figure out how to do stuff, your going to spend ages with the program, anyway".
23:27:18 <mc__> ksf: everything is simple after you got it :)
23:27:21 <dmwit> vaskaren: You can declare the associativity of any identifier.
23:27:45 <vaskaren> like map (\x -> x*x) [1..10] $ filter (\x -> x < 25) -> 1,4,9,16
23:27:54 <ksf> nope. I don't even need to think how M$ word is used, but never, ever, find anything.
23:28:15 <ksf> *shudder*
23:28:27 <ksf> luckily, the last time i had to use it is about 5 years ago.
23:28:29 <vaskaren> so you could read the order of things done like in OO: file.read().split()
23:28:41 <mc__> ksf: well that is because ms word is extremely complex
23:28:54 <pumpkin_> vaskaren: oh, so you want to invert the meaning of . ?
23:29:13 <dmwit> (.) = flip ($) -- done
23:29:17 <ksf> so is oowriter, but it's _way_ easier to use.
23:29:21 <ksf> ...not to mention tex.
23:29:44 <dmwit> > let (.) = flip ($) in [1..10].map (\x -> x*x).filter (< 25)
23:29:44 <pumpkin_> I do everything in tex now... and marvel at how bad Word's typography is
23:29:45 <lambdabot>   [1,4,9,16]
23:30:24 <wagle> what exactly is a "lazy byte string" compared to  [byte]?
23:30:25 <ksf> that's window's fault, too. freetype has excellent rendering with proper fonts.
23:30:40 <dmwit> wagle: It's a linked list of chunks.
23:30:45 <ksf> @src ByteString
23:30:45 <lambdabot> Source not found. There are some things that I just don't know.
23:30:48 <ksf> @src Bytestring
23:30:48 <mc__> ksf: why tex and not latex?
23:30:49 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:30:56 <ksf> tex in general.
23:30:59 <dmwit> wagle: Chunks are a (pre-determined size) array of bytes.
23:31:11 <dmwit> wagle: i.e. each chunk is contiguous in memory, which makes indexing a bit faster.
23:31:16 <pumpkin_> mc__: I actually use XeTeX, but meant in general :)
23:31:21 <ksf> actually, i'm using texlive.
23:31:59 * dmwit &
23:32:07 <ksf> fg
23:32:19 <ksf> :P
23:32:25 <wagle> can you have a 8 gigabyte chunk and then also view it as a list of 512/1024/etc byte chunks?
23:32:42 <ksf> why would you want to?
23:32:55 <ksf> you can hack the lib to chunk in that size, but it's insane.
23:33:26 <wagle> its an image of a disk, and each subchunk would be a block..  but the blocksize is variable
23:33:39 <ksf> ah.
23:34:13 <ksf> bytestring chucks automatically, you want to chunk your data yourself.
23:34:40 <ksf> bytestring chunks without exposing it, and does'nt care about logical boundaries.
23:35:14 <ksf> it's basically _the_ way to do block-io in haskell
23:35:36 <wagle> thinking this out..  not sure what i want yet..  thinking it out in haskell is interesting challenge
23:35:48 <dons> wagle: i think you're just asking for eager chunks ?
23:35:55 <dons> a la lazy bytestrings?
23:36:10 <dons> cache-sized chunks up close, but a single terabyte of data from afar
23:36:12 <ksf> so its chunk sizes will be of such a size that your cpu's cache won't overflow when they're mmap'ed
23:36:20 <ksf> but i should shut up, as dons is here.
23:37:03 <pumpkin_> :o
23:37:27 * shapr wants to hear the conclusion
23:37:32 <shapr> Can bytestring already do that?
23:38:01 <pumpkin_> it sounds like the chunk representation of a bytestring is a "behind the scenes" thing, and that you're free to chunk it up as you wish on your side of things?
23:38:01 <wagle> i'm still figuring out ext2..  have a 8 gig disk with 3 ext2 partitions overwritten with a single ext2 partition..  not sure where the partitions were nor what their blocksizes were yet..  written a scanner for superblocks in c, but suddenly decided this would be way more interesting as a haskell project
23:38:03 <ksf> what, detecting the cpu's cache size at runtime and adjusting its chunksize?
23:38:19 <ksf> doing runtime-performance analysis and adjusting its chunksize?
23:38:28 <pumpkin_> that's kinda what fftw does
23:38:50 <wagle> so what i think i don't want to do is have multiple copies of that 8g of data sitting in memory/virtual memory
23:39:19 <ksf> you don't need to have the 8g in-ram, at all.
23:39:30 <solrize> depending on what you're doing, i think the controlling factor for chunksize has to be the ratio between disk seek time and transfer speed
23:39:31 <pumpkin_> although it'd be awesomely fast if you did :D
23:39:44 <ksf> ...as long as you pay attention not to have any references left to the start of the string.
23:40:00 <solrize> i.e. if your disk seeks in 8 msec and transfers 50 MB/sec then 400 kB of transfer = 1 seek
23:40:38 <ksf> dons?
23:40:55 <ksf> i bet you can't hack bytestring to adjust chunk sizes at runtime.
23:42:03 <wagle> i think i want to break it up into blocks, then string the blocks together..  the new file system will eat some of its blocksize of the blocks, from the top down, and the missibng files will grow with whatever their blocksize might be.  the first fs actually marks things as unusable, but the fs's being recovered would be ambiguous, providing proposals, or somesuch
23:42:05 <ksf> ...outperforming naively written c block-io code.
23:42:18 <dons> ksf: sure you can
23:42:29 <dons> you can hack the size.
23:42:36 <ksf> imagine a "hello, world!" benchmark using that!
23:43:04 <dons> well. you could certainly run a ./configure time test to set the optimum size
23:43:24 <dons> currently it's statically determined to be half the size of my laptops L2 cache
23:43:31 <wagle> the indexing would use the logical block number, which is a function of the start-of-the-partition, and the blocksize
23:43:33 <dons> and then you can fragment that as you wish. that's just the default
23:43:51 <hd_> how do I make this pattern match work:
23:43:52 <hd_> maxlength [x,y]:zs = if ((length x)>(length y)) then maxlength ([x] ++ zs) else maxlength
23:43:52 <hd_> ([y] ++ zs
23:43:53 <ksf> but the optimum will depend on where the data's read from and written to.
23:43:54 <dons> btw, oleg wrote a solution to the knight's tour, http://www.reddit.com/r/programming/comments/7gk4m/solving_the_knights_tour_in_30_lines_of_haskell/c06lnt9
23:43:56 <lambdabot> Title: dons comments on Solving the Knight's tour in 30 lines of Haskell using the Logi ..., http://tinyurl.com/6b3ug5
23:44:10 <pumpkin_> wagle: I still don't think you'd want to adjust the chunk size to match your logical blocksize... as I said I think the chunk size is a back-end representation thing, but maybe I'm wrong
23:44:26 <pumpkin_> dons: wow, it's a pretty controversial article :P
23:44:31 <pumpkin_> 25 down votes :o
23:45:01 <dons> reddit's like that.
23:45:33 <pumpkin_> who's Dan Doel?
23:45:43 <wagle> pumpkin_, you don't see the chunks, its hidden, so indexing by chunk number wouldnt work anyway?
23:45:49 <dons> dolio
23:45:53 <pumpkin_> ah :)
23:46:02 <dolio> dons: Apparently IntMap is just as fast as STUArray. :)
23:46:42 <dons> noice
23:46:44 <ksf> wagle, exactly.
23:46:58 <olsner> hmm, I might need a monad transformer version if Binary
23:47:03 <olsner> *of
23:47:24 <ksf> you _can_ have a look at, and mess with, the internals, but I'd think thrice before doing that.
23:47:46 <pumpkin_> does thrice have a one-word successor?
23:48:11 <dolio> I wrote a uvector (mutable array) version and it doesn't seem to be any faster than STUArray.
23:48:17 <olsner> dolio: how do you know it isn't "STUArray is just as slow as IntMap :("?
23:48:19 <solrize> http://www.askoxford.com/asktheexperts/faq/aboutwords/once
23:48:22 <dons> dolio: they'd be pretty much the same, i'd think
23:48:26 <lambdabot> Title: AskOxford: What comes after once, twice, thrice?
23:48:37 <ksf> anyway, you can just pass your whole file to eg. a parsec parser and then look at its results.
23:48:49 <wagle> i'm mostly worried about getting multiple copies of those 8 billion bytes..  can I turn the memory mapped image into a backing store for the values?
23:49:03 <ksf> also, i'd recommend doing a say 1k test file to work with while developing.
23:49:05 <dolio> Nice to know that you can get optimal performance with a simple backtracking algorithm and persistant data structures, though.
23:49:10 <dons> wagle: for bytestrings? yes.
23:49:17 <dons> wagle: use the bytestring-mmap package
23:49:28 <dons> there's always a library for what you need.
23:49:43 <pumpkin_> wagle: you can pull a sub-bytestring out of an existing one and it'll do the right thing, I think
23:49:45 <dons> be it solving logic problems, or making backing stores.
23:49:49 <dons> yup
23:49:50 <wagle> heh..  sounds like i need to go figure out bytestrings now..
23:49:57 <dons> http://hackage.haskell.org/packages/archive/bytestring-mmap/0.2.0/doc/html/System-IO-Posix-MMap-Lazy.html
23:49:59 <lambdabot> Title: System.IO.Posix.MMap.Lazy, http://tinyurl.com/yw76y8
23:50:01 <pumpkin_> wagle: also, data.binary.get also interprets bytestrings efficiently
23:50:04 <dons> lazy chunks mmaped individually
23:50:34 <dons> it wouldn't be fair if we had to be pure, but couldn't use that fact to avoid copying.
23:50:37 <dons> just not fair, i tells ya.
23:51:05 <dolio> We need that trie library so that we can use Map (Int,Int) Int and get IntMap (Intmap Int) performance automatically.
23:51:52 <pumpkin_> does the value need to be an int for good performance?
23:52:01 <pumpkin_> it seems like just the key is enough
23:52:27 <solrize> bbl
23:52:31 <ksf> anything enumerable works.
23:52:41 <ksf> (as a key)
23:52:44 <pumpkin_> for a trie?
23:52:47 <ksf> yes.
23:52:53 <wagle> if bytes 3001, 3002, 3003, and 3004 are the 4 bytes of an int32, can i made those four bytes the value of the int32, or does the int32 have its own copy of those 4 bytes?  (also, what do i do about byte order?)
23:52:57 <ksf> you could use eg. 4-character strings.
23:52:59 <pumpkin_> oh I guess you can map it to an integer or something else
23:53:19 <pumpkin_> wagle: Data.Binary.Get :P
23:53:22 <ksf> ...but not variable-length strings, as the trie algo needs to know how many elems fit in between.
23:53:26 <dolio> pumpkin_: The point of the library I'm referring to is to use type families to specialize the data structure to be the optimal one for the type.
23:53:36 <pumpkin_> ah, I see
23:53:38 <dolio> Key type, that is.
23:54:01 <wagle> ok..  i'm off to the fine manual
23:54:03 <pumpkin_> wagle: but I do think that once you read an int (whatever endianness) out of a bytestring, it'll be different memory
23:54:06 <ksf> dolio, type classing Map?
23:54:13 <dolio> Oleg's implementation is faster than mine because He uses IntMap (IntMap Int) instead of Map (Int, Int) Int.
23:54:14 <dons> wagle: ah, Int's we do via copying.
23:54:17 <pumpkin_> wagle: but I don't think you should worry about that
23:54:43 <dons> wagle: seems like you're over-optimising though.
23:54:54 <ski_> hd_ : presumably you intended `maxlength ([x,y] ++ zs) = ...' .. however you can't match on `.. ++ ..', so use `maxlength (x : y : zs) = ...' (also, imo it looks better to use `maxlength (x : zs)' rather than `maxlength ([x] ++ zs)', though that latter will work)
23:54:56 <ksf> wagle, don's wrote nice papers on the whole bytestring/fusion stuff: http://www.cse.unsw.edu.au/~dons/fps.html
23:54:58 <lambdabot> Title: Data.ByteString
23:54:59 <dons> Data.Binary's already crazy fast.
23:55:04 <wagle> dons its an exercise
23:55:07 <ksf> don's??? dons.
23:55:21 <pumpkin_> wagle: still, it's premature :) see what actually needs optimizing first
23:55:32 <dons> wagle: you can use unsafeCoerce# to treat arbitrary memory as other arbitrary memory
23:55:35 <dons> not safe though
23:55:41 <wagle> EEEK..
23:55:57 <dons> so if you want to treat 4 bytes as an /Int#/ you can
23:56:05 <dons> not an Int. that requires the I# constructor.
23:56:06 <ksf> wagle, afraid of void* casts?
23:56:20 <ksf> unions?
23:56:21 <wagle> my object is to do it "right" but not "ugly"
23:57:02 <pumpkin_> ooh, I like *Main> :!mate ./learning.hs
23:57:03 <dolio> ksf: Yeah. 'class MapKey k where data Map k :: * -> * ; ...' Then you can do 'instance MapKey Int where newtype Map Int v = IMap (IntMap v) ; ...' and 'instance (MapKey k1, MapKey k2) => MapKey (k1,k2) where newtype Map (k1,k2) v = PMap (Map k1 (Map k2 v)) ; ...'
23:57:37 <ksf> wagle, you definitely want to do a smaller file to test on, though. Laziness is most likely going to hit the fan more than once while you write your code.
23:57:54 <dolio> Then Map (Int, Int) v becomes IntMap (IntMap v) automatically.
23:58:05 <dolio> And you get free performance.
23:58:09 <wagle> what i'm doing here is seeing if i can do this on a machine i currently possess before I spend a week writing haskell code that I have to convert back to C
23:58:19 <ksf> dolio, go for it and add it to h'.
23:58:36 <ksf> (is Map specced, anyway?)
23:58:47 <dolio> Well, someone was writing such a library for summer of code, but it's not here yet.
23:59:26 <dons> you should contact the mentor, Ashley?
23:59:42 <dons> even half finished stuff is still useful
