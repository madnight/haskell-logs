00:00:13 <mmorrow> the nice thing that'll make it not-that-painful to get comfortable (once the initial learning howtf to make it do anything is over) is that you can make it do whatever you want it to do
00:00:34 <thoughtpolice> yeah
00:03:51 <thoughtpolice> mmorrow: but yeah I've been playing around with it recently and I really am thinking of switching at this point
00:06:02 <thoughtpolice> mmorrow: i figure perhaps hacking up a mode for it or just extending it would be a good taste of what it can do now and how I can extend it later for my own nefarious purposes
00:06:06 <mmorrow> do it
00:07:00 <mmorrow> i just committed to it after this last look over it
00:07:23 <mmorrow> totally, i think hacking it is the perfect/best way to learn how to use it
00:08:13 <mmorrow> well, the best way to learn anything, since hacking on it means not only do you have to understand how to use it, but how it works too
00:08:37 <mmorrow> that's the way i see it at least
00:14:35 * araujo greets around
00:15:40 * sbahra dances around
00:40:52 <telexicon> so a monad
00:41:08 <ivanm> went a-walking?
01:10:17 <unenough> help, My lambdabot fails with 'Terminated' on the most trivial calculations
01:16:31 <unenough> Cale: lambdabot should depend on mueval and happy in the cabal install
01:18:19 <unenough> Cale, and also arrow
01:18:24 <unenough> arrows
01:20:03 <telexicon> a monad does something
01:21:33 <unenough> sorry. when I say "Cale" i mean: whoever maintains lambdabot
01:26:11 <encephalitogenic> http://www.ihateyoujulia.com/?id=5bc1d1661d9c1173c82772dc7af22070
01:26:12 <lambdabot> Title: I HATE YOU JULIA.COM
01:26:14 <halberd> I think that the quality of a computer program should be judged by how "local" it is to make changes to the program's functionality
01:26:43 <halberd> if, any time you must make a change, all your updated code is confined to one small area, then the program's design is good
01:26:53 <unenough> is there some top-level library in cabal that includes Control.Monad, Control.Arrow, Data.Number, etc...
01:26:53 <unenough> ?
01:27:47 <Peaker> unenough: Control.Monad is in stdlib, the others are too, I think
01:27:57 <halberd> on the other hand, if every change to the program involves updating 5 different widely separated pieces of code (like in different files) then the program's design is bad
01:29:01 --- mode: ChanServ set +o dobblego
01:29:04 --- kick: encephalitogenic was kicked by dobblego (dobblego)
01:29:09 --- mode: dobblego set -o dobblego
01:29:19 <Peaker> halberd: yeah, "tight coupling" between remote pieces of code sucks, and almost all good practices are about uncoupling these
01:30:04 <halberd> can you think of good practices that do not involve improving that?
01:30:10 <twb> Is there a way to declare the type of multiple (identically typed) bindings at once?
01:30:17 <twb> e.g. x, y, z :: Integer
01:30:45 <halberd> well, performance improvements, and also descriptive variable naming
01:31:02 <halberd> besides those?
01:33:01 <halberd> perhaps locality of program alterations  is almost the only criterion of good design (and by extension of good programming languages because they allow good design)
01:35:22 <p_l> that's why it's the main design goal for the "core" side of Windows NT7.0 ... someone got mad at the tight coupling
01:37:44 <halberd> I suppose conciseness and code legibility are two other criteria, but those are easier to get approximately right
01:41:52 <jsn> twb: that should work as your wrote it
01:42:17 <twb> jsn: hmm, so I must have made a mistake elsewhere.
01:42:30 * twb goes back to banging on Darcs
01:15:04 <lispy> is this what code looked like before we had do-notation? http://www.informatik.uni-bonn.de/~ralf/software/examples/Hsh.html
01:15:06 <lambdabot> Title: Hsh.hs, http://tinyurl.com/2udchk
02:09:07 <unenough> why doesn't this work
02:09:18 <unenough> > map (++) [[1,2], [3,4]]
02:09:20 <lambdabot>       Overlapping instances for Show ([a] -> [a])
02:09:20 <lambdabot>        arising from a use o...
02:10:22 <Plareplane> what is it supposed to do?
02:10:36 <unenough> [1,2,3,4]
02:10:51 <Plareplane> > concat [[1,2], [3,4]]
02:10:52 <lambdabot>   [1,2,3,4]
02:11:10 <Cale> > foldr (++) [] [[1,2],[3,4]]
02:11:11 <lambdabot>   [1,2,3,4]
02:11:20 <unenough> oh
02:11:25 <dmwit> > map (++[35]) [[1,2],[3,4]]
02:11:26 <unenough> makes sense
02:11:26 <lambdabot>   [[1,2,35],[3,4,35]]
02:11:32 <Peaker> unenough: map (++) on a list will partially apply (++) to its first arg on each element of the list.. You get a list of (item++) elements
02:11:41 <unenough> yea, know i get it
02:11:43 <Cale> unenough: map applies a function to each element of the list... so  map (++) [[1,2],[3,4]] = [(++) [1,2], (++) [3,4]]
02:11:45 <unenough> know=now
02:12:24 <Cale> map (\f -> f [5,6]) [(++) [1,2], (++) [3,4]]
02:12:26 <Cale> > map (\f -> f [5,6]) [(++) [1,2], (++) [3,4]]
02:12:26 <Peaker> > foldr (++) [] [[1,2],[3,4]]
02:12:27 <lambdabot>   [[1,2,5,6],[3,4,5,6]]
02:12:28 <lambdabot>   [1,2,3,4]
02:38:29 <unenough> BONUS, i'm enjoying your tutorial :) thanks
02:38:52 <Ste> yeah, tis ace :-)
02:39:22 <unenough> i love the art too
02:40:23 <LarstiQ> indeed :)
02:43:46 <BONUS> haha
02:43:55 <BONUS> thanks so much! :]
02:44:00 <BONUS> im glad people are liking it
02:45:26 <LarstiQ> let me un-memory dump my notes and send some more corrections
02:45:35 <LarstiQ> unless you fixed those in the meantime, again ;P
02:45:52 <BONUS> haha
02:45:59 <BONUS> im always glad to get some corrections
02:46:43 <LarstiQ> you fixed divideByTen *scrap*
02:46:59 <BONUS> :]
02:47:23 <LarstiQ> BONUS: on higher-order-functions, the sentence "The body of the function pretty simple." is missing an 'is'.
02:47:23 <Axman6> BONUS: i'm thinking of teaching my girlfriend haskell using your tutorial once thi semester's finished :)
02:47:44 <BONUS> LarstiQ: w00t! I'll fix that right away
02:47:57 <BONUS> Axman: haha, awesome. if you get into that, tell me how it goes
02:48:05 <LarstiQ> BONUS: and you use 'convinience' in a couple places, instead of 'convenience'
02:48:14 <unenough> and my wife liked kermit (but that' probably as far as it gets :)
02:48:18 <ivanm> Axman6: and then you're going to try out RWH on your other girlfriend as a scientific test? :p
02:48:33 * LarstiQ already set two friends and a colleague on the tutorial
02:48:39 <Axman6> it was going to be ruby, using Why's poignient(sp?) guide but ruby's boring
02:48:52 <Axman6> ivanm: sure :P
02:49:01 <LarstiQ> BONUS: so, thanks, I really enjoyed the ride :)
02:49:03 <Axman6> and she can teach me legal stuff
02:49:04 <BONUS> LarstiQ: yeah, i think i fixed that. it's one of those things that you just spell wrong for the most of your life
02:49:12 <BONUS> and then you're like "woah, it's not spelled that way?"
02:49:20 * LarstiQ nods
02:49:22 <BONUS> haha, still, more is coming up
02:49:37 <BONUS> planning on spending a few hours today doing writing
02:50:04 <LarstiQ> cool. I'll try do some coding then :)
02:51:40 <BONUS> ah, noticed there were still some occurences of "convinience", fixed them
02:51:44 <BONUS> thank bob for grep
02:52:33 <unenough> I think you should thank Richard Stallman
02:52:48 <BONUS> ah. i'll shoot him a mail
02:54:32 <dmwit> Wait, Richard Stallman is Bob?
02:54:42 <LarstiQ> a well kept secret.
02:54:58 <BONUS> ahahaha
02:55:00 <BONUS> http://www.bbspot.com/News/2008/10/microsoft-xp-vista.html
02:55:05 <BONUS> For the second part of the strategy, Ballmer revealed the Microsoft would be going back to using its position as the dominant operating system maker to their advantage.  "We're going to get aggressive with users who won't upgrade, and I'm going to play a part."
02:55:05 <lambdabot> Title: BBspot - Microsoft Getting Serious About Upgrading Users to Vista
02:55:28 <BONUS> i can just imagine steve ballmer yelling at an old lady to use vista
02:55:37 <BONUS> and then punching her
02:55:55 <LarstiQ> :)
02:58:42 <dmwit> I can see him getting into a "developers developers" sort of rhythm with "The Vista rocks!  The Vista rocks!  The Vista rocks!" or something.
02:59:29 <BONUS> haha
03:00:02 <LarstiQ> underscoring each exclamation with a left jab
03:02:36 * twb wonders when Ballmer became a cult icon
03:02:45 <unenough> never?
03:02:55 <twb> Reminds me of Dagon
03:03:02 <LarstiQ> the god?
03:03:07 <twb> Ya
03:03:20 <twb> The chanting, the evil, the potbelly...
03:03:49 <LarstiQ> ok, the historical, or the Lovecraftian one? :)
03:03:58 <unenough> BONUS, "If want to give your function a type declaration"
03:04:04 <unenough> http://learnyouahaskell.com/types-and-typeclasses
03:04:05 <twb> The lovecraftian one, of course.
03:04:09 <lambdabot> Title: Learn You a Haskell for Great Good! - Types and Typeclasses
03:04:12 <BONUS> cool!
03:04:23 <BONUS> man, i guess some gnomes keep deleting words
03:04:41 <twb> "Learn you a Haskell for Great Good"?  It sounds like something "why the lucky stiff" would write.
03:04:52 <twb> "Maximizing leverage Haskell for Super Lucky Fun Win!"
03:05:06 <dmwit> ugh
03:05:14 <dmwit> Your buzzing.
03:05:17 <dmwit> ...
03:05:19 <dmwit> You're buzzing.
03:05:20 <BONUS> hehe yeah its supposed to make it less scary for noobs
03:05:31 <twb> I'm only here because I'm waiting for texlive to reinstall again
03:05:43 <BONUS> You're are buzzing.
03:05:56 <Baughn> You're bussing? Where?
03:06:34 <mmorrow> bus error?
03:06:46 <twb> I wonder: is it better to teach kids FP first, or after they've spent ten years in industry learning that no, OO isn't a panacea.
03:06:49 <unenough> does haskell have complex numbers?
03:06:59 <Deewiant> > 1 :+ 2
03:07:01 <lambdabot>   1.0 :+ 2.0
03:07:01 <twb> At least in the latter case they're less rowdy
03:07:01 <mmorrow> , 0:+1
03:07:01 <thoughtpolice> @instances Complex
03:07:02 <lambdabot> Couldn't find class `Complex'. Try @instances-importing
03:07:07 <lunabot>  0.0 :+ 1.0
03:07:11 <unenough> k
03:07:13 <unenough> thanks
03:07:19 <thoughtpolice> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Complex.html
03:07:21 <lambdabot> Title: Data.Complex, http://tinyurl.com/5hjbtc
03:07:21 <thoughtpolice> yeah there yo go
03:07:44 <mmorrow> , last $ fft (fmap (:+0) [0..100000])
03:07:46 <lunabot>  luna: Prelude.last: empty list
03:07:50 <mmorrow> grr
03:07:52 <mmorrow> oh
03:08:21 <mmorrow> , last $ fft (fmap (:+0) [0..2^14])
03:08:24 <lunabot>  (-8191.999999955525) :+ (-4.2722829199928194e7)
03:08:28 <mmorrow> , last $ fft (fmap (:+0) [0..2^15])
03:08:30 <lunabot>  (-16383.99999980043) :+ (-1.7089131837050912e8)
03:08:34 <mmorrow> , last $ fft (fmap (:+0) [0..2^16])
03:08:37 <lunabot>  (-32767.999999213338) :+ (-6.835652750528328e8)
03:08:42 <mmorrow> , last $ fft (fmap (:+0) [0..2^24])
03:08:48 <lunabot>  Killed.
03:08:49 <unenough> @index fft
03:08:50 <lambdabot> bzzt
03:08:50 <mmorrow> heh
03:08:56 <mmorrow> @hackage fft
03:08:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fft
03:09:02 <mmorrow> @hackage pure-fft
03:09:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pure-fft
03:09:08 <unenough> what's the diff?
03:09:18 <mmorrow> i didn't mean to type fft at first
03:09:30 <mmorrow> that one's an ffi binding to fftw
03:09:35 <unenough> ah
03:09:44 <mmorrow> pure-fft is about 15 lines of haskell code :)
03:10:31 <mmorrow> http://hackage.haskell.org/packages/archive/pure-fft/0.1.0/doc/html/src/Numeric-FFT.html#fft
03:10:37 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5s8akm
03:10:40 <unenough> how do I list the functions in a package after importing it?
03:10:45 <unenough> can i do that using ghci?
03:10:49 <mmorrow> yeah
03:10:55 <mmorrow> :browse System.IO
03:11:03 <unenough> cool
03:11:24 <dmwit> <pedantic>That's for a module, not a package.</pedantic>
03:11:33 <mmorrow> :info someName
03:11:46 <mmorrow> is probably the best thing since sliced bread
03:12:10 <mmorrow> i would be 1/1000000 th as productive without it
03:12:11 <unenough> well, python's help(someName) is more readable
03:12:18 <unenough> because it contains documentation too
03:12:26 <unenough> that would be useful
03:12:30 <mmorrow> i've heard people say that same thing
03:12:56 <mmorrow> someone should add that to ghci
03:13:20 <unenough> but the docs are not even really written
03:13:26 <mmorrow> the only thing is, i
03:13:29 <mmorrow> yeah
03:13:48 <mmorrow> it's getting the :info from compiled modules from their .hi files
03:13:59 <mmorrow> and those don't contain the docs i don't believe
03:14:11 <unenough> docstrings would be nice
03:14:52 <mmorrow> so that seems like the crux. it'd be easy to actually support displaying the docs, but the current system doesn't retain them, so i dunno the best way to proceed
03:15:27 <mmorrow> unenough: what do you mean exactly by "docstrings"
03:15:28 <mmorrow> ?
03:15:43 <unenough> in python, you do
03:15:47 <unenough> def func(x):
03:15:53 <unenough>     """This is the documentation"""
03:15:57 <unenough>     ...
03:16:09 <unenough> and then, help(func), or func.__doc__ gives you that string
03:16:12 <mmorrow> ah. and then python stores those docs for you somewhere
03:16:15 <unenough> yes
03:16:20 <BONUS> doctests would be cool too
03:16:28 <unenough> yes
03:16:43 <mmorrow> hmm
03:17:00 <BONUS> in python, you can type how an interactive shell session using that function is supposed to look like
03:17:10 <BONUS> and then it can run that and see if it looks the same
03:17:43 <mmorrow> dmwit: heh
03:18:59 <profmakx> documentation for many haskell libs is scarce
03:19:13 <Deewiant> documentation for many libs is nonexistent :-P
03:19:16 <unenough> but do we really want more people to learn haskell ?"
03:19:17 <mmorrow> i just started a paste thread for ghci awesomeness-increasing ideas http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=389#a389
03:19:30 <profmakx> well, examples would do for me
03:19:32 <mmorrow> add all your ideas :)
03:19:40 <BONUS> hehe, cool
03:19:45 <mmorrow> i'll add mine
03:20:38 <jimstutt> hi
03:20:52 <BONUS> Hell-o
03:20:57 <jimstutt> has anyone built ghc-6.10 for archlinux x86
03:21:06 <jimstutt> ?
03:21:41 <profmakx> jimstutt its in aur
03:21:50 <profmakx> (at least dons said something like that)
03:21:58 <mmorrow> jimstutt: you may want to ask dons about archlinux+haskell things
03:21:59 <profmakx> iirc
03:22:03 <Axman6> aru?
03:22:14 <mmorrow> dunno if he's around at the moment though
03:22:23 <thoughtpolice> who's server?
03:22:34 <thoughtpolice> (the moonpatio one?)
03:22:38 <mmorrow> mine
03:22:55 <mmorrow> well, it's hosted
03:23:07 <jkr> Ahoy
03:23:17 <mmorrow> thoughtpolice: (lunabot's running on their box as well ;)
03:23:33 <profmakx> Quote: Planning is also underway for the GHC 6.10 release, and the 6.10 release candidate is in testing.
03:23:55 <thoughtpolice> mmorrow: ah cool. i wonder why hpaste.org hasn't updated to hpaste2 yet...
03:24:07 <mmorrow> hpaste2 is super nice
03:24:17 <jkr> I'm trying to learn Haskell. Is it ok to ask a few newbie questions here?
03:24:19 <mmorrow> note the ability to highlight lines
03:24:28 <Axman6> jkr: this is the best place to ask
03:24:28 <mmorrow> and for everyone to see your highlight
03:24:36 <jkr> Great :)
03:24:37 <mmorrow> oh, and best of all...SEARCH
03:24:43 <jimstutt> :profmakx tnx. dons appears to be working on x68_64 for dph first
03:25:06 <mmorrow> and hpaste2 is just fastcgi + sqlite (with takusen)
03:25:24 <jkr> I'm trying to write a function that takes an integer, reads something from stdin an returns an integer.
03:25:49 <jkr> However I find the 'do' stuff pretty confusing and I don't know the right type definition for such a function
03:26:15 <jkr> Is it possible at all to do that?
03:26:27 <mmorrow> , return 42 :: Maybe Integer
03:26:29 <lunabot>  Just 42
03:26:32 <mmorrow> , return 42 :: [Int]
03:26:34 <lunabot>  [42]
03:26:36 <mmorrow> , return 42 :: IO Double
03:26:38 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO GHC.Types.Double))
03:26:42 <Axman6> can you paste what you think it should be?
03:27:07 <jkr> askNumber :: Int -> Int -> IO ()
03:27:24 <Axman6> so it takes two numbers?
03:27:41 <jkr> No, it takes one and returns one
03:27:50 <Axman6> sounds like you want Int -> IO Int
03:27:54 <Axman6> but i could be wrong
03:28:16 <jkr> Ah right
03:28:23 <Axman6> something like askNum x = do {y <- realLn; return (x+y)}?
03:28:31 <Deewiant> s/real/read/
03:28:36 <jkr> So 'IO Int' means that it's an IO function that returns an integer?
03:28:36 <Axman6> uhm, readLn
03:29:18 <jkr> Axman6: Yup
03:29:40 <jimstutt> \join #archlinux-haskell
03:29:48 <jimstutt> hi
03:29:53 <Axman6> o/
03:30:05 <dmwit> jkr: That's exactly right: IO Int is conceptually a computation (that might do some IO) that returns an Int.
03:30:36 <thoughtpolice> @seen heatsink
03:30:36 <lambdabot> I saw heatsink leaving #haskell 1d 5h 28m 34s ago, and .
03:30:39 <jimstutt> oops, v new to chat
03:30:46 <Axman6> Deewiant: so, what i pasted would actually work?
03:30:59 <dmwit> jkr: It might help you to realize that a value of type "IO Int" is actually a description of an i/o computation that returns an Int.
03:31:03 <Axman6> apart from the typo
03:31:18 <jkr> So IO is just some kind of marker that says a function might do IO, not really a return type?
03:31:22 <maxote> good morning sirs and ladies
03:31:22 <jimstutt> \join #archlinux-haskell
03:31:28 <mauke> jkr: no, it's an actual type
03:31:29 <dmwit> jkr: Right.
03:31:30 <maxote> i'm looking for faster algorithms of reductions of OBDDs with dynamic variable ordering
03:31:35 <Axman6> jimstutt: /join, not \join
03:31:39 <maxote> +50% far from best local minimum is reasonably good for me, the trade-off is the lesser run time.
03:31:43 <jkr> Hehe
03:31:57 <dmwit> jkr: IO is a "type constructor"; it turns pure types into other types.
03:32:11 <mauke> all types are pure
03:32:15 <dmwit> Yes.
03:32:22 <mauke> IO (IO ())
03:32:30 <dmwit> Yes.
03:32:41 <Axman6> would something like f :: a -> IO a; f x = IO x -- be valid?
03:32:48 <dmwit> First-class IO actions are even sometimes useful. =)
03:32:53 <mauke> Axman6: no, IO is not a data constructor
03:33:10 <Axman6> ok, cheers
03:33:55 <Axman6> what about f x = return x then?
03:34:09 <mauke> that works
03:34:22 <Axman6> @src IO return
03:34:22 <lambdabot> return x    = returnIO x
03:34:27 <Axman6> @src IO returnIO
03:34:28 <lambdabot> Source not found. :(
03:34:32 <Axman6> :(
03:34:34 <dmwit> ?src returnIO
03:34:34 <lambdabot> Source not found. Sorry.
03:34:34 <mauke> @src returnIO
03:34:35 <lambdabot> Source not found. It can only be attributed to human error.
03:34:45 <mauke> implementation detail
03:34:57 <mmorrow> here's a haskell repl from 2004 thhhat can do typesyns, datas, newtypes, classes, ... interactively
03:34:58 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=389#a391
03:35:08 <besiria> IO is a phantom type?
03:35:18 <mmorrow> we just need to add this functionality to ghci, since clearly it's possible
03:35:26 <mauke> besiria: implementation detail
03:35:59 <dmwit> Monads cannot be phantom types, I think.
03:36:08 <mmorrow> if anyone has any ideas for ghci, add them here :)   http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=389
03:36:45 <mauke> data Phantom a = Phantom; instance Monad Phantom where return _ = Phantom; _ >>= _ = Phantom
03:36:58 <Axman6> mauke: how do i add something?
03:37:07 <mauke> Axman6: huh?
03:37:14 <Axman6> uh, mmorrow, sorry
03:37:19 <jkr> Ok, another question. The head of a string is a character, so can I do something like: line <- getLine \ case (head line) of \ '1' -> something
03:37:38 <dmwit> mauke: Oh, I thought the return law would prevent that, but I didn't think it through carefully enough.
03:37:42 <mmorrow> Axman6: ?
03:37:52 <mmorrow> oh
03:37:54 <mauke> jkr: yes, but not recommended (fails if line is empty)
03:37:57 <dmwit> jkr: sure
03:38:06 <mmorrow> click "add revision" at the top left
03:38:12 <mauke> jkr: do { line <- getLine; case line of { '1' : _ -> something
03:38:36 <dmwit> jkr: Keep in mind that you will have to write "do" again in each case if you want to have another do block.
03:38:52 <jkr> Ok
03:39:10 <dmwit> You can also use
03:39:28 <dmwit> do { (c:cs) <- getLine; {- do something with cs here -} }
03:39:50 <dmwit> But it will call "fail" in the case of a pattern match, so you might not want to use that.
03:39:50 <jkr> Actually I just want to return a number :)
03:39:56 <jkr> Like: '1' : _ -> 1
03:40:12 <jkr> But it says No instance for (Num (IO Int))
03:40:13 <mauke> jkr: ok; what should happen for other inputs?
03:40:16 <dmwit> :t readLn -- you might like this
03:40:17 <lambdabot> forall a. (Read a) => IO a
03:40:22 <mmorrow> Axman6: heh
03:40:27 <dmwit> jkr: Yep, you need "return 1" instead of "1".
03:40:27 <Axman6> mmorrow: added my 2 cents, not exactly an original idea though...
03:40:32 <jkr> Ah
03:40:36 <dmwit> jkr: (To put the "1" into the monad.)
03:40:36 <mmorrow> atpl++++
03:40:55 <jkr> Yay, it compiled :)
03:41:06 <Axman6> jkr: usually an excellent sign :)
03:42:00 <blackdog> is there an equivalent of the perlish 'split' for ByteStrings?
03:42:12 <blackdog> lines is almost what i want, i just want to pass a different separator
03:42:32 <mauke> AFAIK no, 'split' is famously missing from the libs
03:43:12 <Axman6>  :t split?
03:43:31 <mmorrow> therein lies the disagreement
03:43:52 <mauke> split :: (Eq a) => [a] -> [a] -> [[a]]
03:44:20 <mmorrow> split :: (a -> Bool) -> [a] -> [[a]]
03:44:28 <mauke> that's strtok
03:44:53 * Axman6 likes split and splitWith for those two respectively
03:44:56 <mmorrow> split :: ([a] -> ([a],[a])) -> [a] -> [[a]]
03:45:10 <mauke> that looks generic
03:45:19 <mmorrow> heh
03:45:20 <mauke> how does it terminate?
03:45:48 <dmwit> With a [] in the second place?
03:45:58 <mmorrow> , (\n -> fix (\k xs -> let (ys,zs) = splitAt n xs in ys : k zs)) 4 [0..]
03:45:58 <blackdog> think span is the closest i'm going to get...
03:46:03 <lunabot>  [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23...
03:46:27 <mmorrow> yeah, a [] in the snd
03:47:00 <mmorrow> , (\n -> fix (\k n xs -> let (ys,zs) = splitAt n xs in ys : k (n+1) zs) n) 0 [0..]
03:47:02 <lunabot>  [[],[0],[1,2],[3,4,5],[6,7,8,9],[10,11,12,13,14],[15,16,17,18,19,20],[21,...
03:47:46 <mmorrow> blackdog: you can use span to get it too
03:48:16 <ski> , fix (\k n xs -> let (ys,zs) = splitAt n xs in ys : k (n+1) zs) 0 [0..]
03:48:18 <lunabot>  [[],[0],[1,2],[3,4,5],[6,7,8,9],[10,11,12,13,14],[15,16,17,18,19,20],[21,...
03:49:14 <mmorrow> , let split _ [] = [] ; split p xs = let (ys,zs) = span (not . p) xs in ys : split p (drop 1 zs) in split ((==0) . (`mod`7)) [0..]
03:49:16 <lunabot>  [[],[1,2,3,4,5,6],[8,9,10,11,12,13],[15,16,17,18,19,20],[22,23,24,25,26,2...
03:49:56 <blackdog> hm. bit worried about reading about the bytestring practice of holding onto the whole string behind the scenes - i'm planning to read in a big doc and throw away most of it
03:50:15 <blackdog> suppose i should benchmark first
03:50:36 <dmwit> Lazy bytestrings are nice.
03:51:48 <blackdog> semantically, that's kind of vague. i didn't think they were planning to murder my mother :)
03:52:21 <dmwit> Lazy bytestrings do not hold on to the whole string if you write good consumers.
03:53:24 <blackdog> ah, beautiful. thanks.
03:53:33 <blackdog> ... what's a good consumer?
03:53:44 <mmorrow> your mother's safety on the other hand... :)
03:53:50 <blackdog> i think my consumer might spend all day on the couch eating slim jims, if the rest of my program is anything to go by
03:54:09 <dmwit> A good consumer doesn't keep a reference to something in the middle of the string.
03:54:11 <blackdog> 4 gigs of memory traffic to read in a 5 mb file and do some reasonably simple calculations :/
03:54:17 <blackdog> oh, it'll definitely do that :/
03:54:32 <blackdog> explicit copy, i suppose
03:54:41 <dmwit> Oh, you're just worried about a 5MB document?
03:54:44 * dmwit pshaws
03:54:55 <mmorrow> blackdog: there's also bytestring-mmap
03:55:02 <mmorrow> @hackage bytestring-mmap
03:55:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-mmap
03:55:35 <trhj> , let isprime x = all $ ( 0 /= ) . mod x $ takeWhile (<=sqrt x) primes; primes = 2:3:5: (isprime `filter` [7..]) in primes
03:55:37 <lunabot>  luna: Ambiguous occurrence `all'
03:56:13 <mmorrow> mmap(2) for either strict or lazy bytestrings
03:56:16 <mmorrow> wuh
03:56:22 <mmorrow> , all
03:56:23 <lunabot>  luna: Ambiguous occurrence `all'
03:58:22 <mmorrow> , all
03:58:24 <lunabot>  luna: Ambiguous occurrence `all'
03:58:26 <mmorrow> , all
03:58:28 <lunabot>  luna: Ambiguous occurrence `all'
03:58:29 <mmorrow> gah
03:59:04 <blackdog> dmwit: well, i'm hoping to expand it to bigger corpora
03:59:09 <mmorrow> , all
03:59:10 <lunabot>  luna: No instance for (GHC.Show.Show
03:59:13 <blackdog> the brown corpus is not everything :)
03:59:18 <mmorrow> , let isprime x = all $ ( 0 /= ) . mod x $ takeWhile (<=sqrt x) primes; primes = 2:3:5: (isprime `filter` [7..]) in primes
03:59:19 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = [a]
03:59:23 <jkr> http://github.com/jkramer/haskell/tree/master/coins.hs <-- my first haskell game \o/
03:59:25 <lambdabot> Title: coins.hs at master from jkramer's haskell — GitHub
03:59:46 <mmorrow> , all (==0) (take 1000 . repeat $ 0)
03:59:48 <lunabot>  True
04:00:30 <mmorrow> , let isprime x = all (( 0 /= ) . mod x) $ takeWhile (<=sqrt x) primes; primes = 2:3:5: (isprime `filter` [7..]) in primes
04:00:31 <lunabot>  luna: Ambiguous type variable `a' in the constraints:
04:00:47 <mmorrow> , let isprime x = all (( 0 /= ) . mod x) $ takeWhile (<=sqrt x) primes; primes = (2::Integer):3:5: (isprime `filter` [7..]) in primes
04:00:48 <lunabot>  luna: No instance for (GHC.Float.Floating GHC.Integer.Internals.Integer)
04:01:06 <mmorrow> oh
04:01:12 <blackdog> bah, bytestrings are actually using _more_ memory
04:01:16 <trhj> Weird indeed. I tried different variants of that and got these errors.
04:01:23 <blackdog> *suspects misdoing on blackdog's part*
04:01:41 <mmorrow> , let isprime x = all (( 0 /= ) . mod x) $ takeWhile (<=(floor . sqrt . fromIntegral $ x)) primes; primes = (2::Integer):3:5: (isprime `filter` [7..]) in primes
04:01:43 <lunabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,1...
04:01:46 <mmorrow> yay!
04:01:56 <mmorrow> trhj: :)
04:02:27 <trhj> mmorrow: why it has to be so complicated?
04:03:22 <BONUS> i remember seeing a really elegant example of processing commandline arguments and then dispatching (or printing the help if they don't add up) based on them, anyone know what i'm tolkien about?
04:03:24 <thoughtpolice> blackdog: are you using lazy bytestrings (i.e. import Data.ByteString.Lazy.Char8 or whatever?)
04:03:31 <BONUS> i think it was somewhere on haskell.org or on dons' site
04:03:52 <thoughtpolice> BONUS: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html#2 <-- ?
04:03:56 <lambdabot> Title: System.Console.GetOpt, http://tinyurl.com/y3585u
04:04:14 <BONUS> ah that's kind of what i'm looking for, yeah
04:04:19 <BONUS> although i remember it not using getopt
04:04:22 <BONUS> just system.environment
04:04:38 <BONUS> although that with getopt is really neat too, thanks
04:04:51 <thoughtpolice> i use the second trick in those examples all the time
04:05:28 <mmorrow> trhj: it's true that fromIntegral etc is a pain, but that's a small price to pay for being able to do: (\k -> k $ fmap whatUsedToTakeDays [Just hugePileOfCrap, Just someStuff, Nothing]) deploy
04:05:30 <mmorrow> :)
04:05:36 * mmorrow goes to sleeeep
04:06:27 <blackdog> thoughtpolice: yeah
04:07:12 <ski> , let isprime x = all (( 0 /= ) . mod x) $ takeWhile (<=(floor . sqrt . fromIntegral $ x)) primes; primes = 2: (isprime `filter` [3..]) in primes  -- ..
04:07:13 <lunabot>  luna: parse error (possibly incorrect indentation)
04:07:33 <ski> , let isprime x = all (( 0 /= ) . mod x) $ takeWhile (<=(floor . sqrt . fromIntegral $ x)) primes; primes = 2: (isprime `filter` [3..]) in primes
04:07:35 <lunabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,1...
04:07:44 <mmorrow> lunabot barfs on comment at the end due to my laziness
04:07:47 <ski> (apparently it doesn't like comments ..)
04:09:00 <blackdog> ah, i just suck. duh. bad base case
04:10:10 <thoughtpolice> blackdog: i've come to the conclusion that bytestrings are just plain awesome :]
04:10:24 <thoughtpolice> lazy ones too, even if the are a 'theoretical abomination' (to quote oleg)
04:10:33 <thoughtpolice> s/the/they/
04:12:38 <thoughtpolice> but enumerators are also the sex...
04:15:08 <trhj> can we overload sqrt so it would operate on ints? Like:
04:15:42 <trhj> sqrt = sqrt . fromIntegral
04:16:13 <blackdog> hm, up to 400mb... might not be putting this algorithm on a phone any time soon :)
04:17:21 <blackdog> although i suppose ghc will just use as much memory as you let it
04:18:06 <thoughtpolice> think of it as a stress test of the storage manager/allocator performance and book-keeping, not as a problem with your code :]
04:18:44 <blackdog> well, so long as my code is ok in some platonic sense :)
04:18:47 <thoughtpolice> trhj: you could create a type-class for things like that, but I think it's pretty much universally agreed that Num & co. in the H98 prelude aren't designed very well
04:21:10 <blackdog> hm. don't suppose there's a trivial way to serialise Data.Map structures to disk?
04:21:18 <dmwit> show
04:22:28 <blackdog> i thought the general advice was not to use show for big objects?
04:22:57 <trhj> thoughtpolice: I agree. i heard that  a couple of times
04:24:39 <dmwit> It depends on what you're showing, I guess.
04:25:17 <dmwit> Showing a Map Int Int might lose you a factor of 3 on compression.
04:25:36 <dmwit> More constructor-heavy data types will lose more.
04:25:55 <dmwit> Anyway, there's the Binary class for high-performance marshalling.
04:26:01 <blackdog> yeah, i'm getting a factor of 8
04:26:10 <blackdog> might be enough, though
04:28:44 <twb> For a long string of many lines, is there any reason to say "foo\n" ++ "bar\n" instead of concatMap (++"\n") ["foo","bar"] ?
04:29:05 <twb> I suppose the latter isn't really a significant improvement in readability.
04:35:58 <maltem> Should it be possible to bootstrap ghc without root password (user install)?
04:36:47 <ivanm> I think so
04:37:02 <maltem> ah that's good
04:38:12 <fatalerrorx> sigh..i hate working on a project the day before its due
04:38:36 <fatalerrorx> very long night ahead
04:38:48 <maltem> my uni's multicore cluster could then make for a nice DPH-or-what-parallell-extension-is-currently-en-vogue testbed
04:39:34 <Axman6> fatalerrorx: that's why you don;t do that
04:40:10 <Axman6> maltem: i tried that, my disk quoter was too small :(
04:40:18 <Axman6> quota even
04:40:18 <fatalerrorx> Axman6: no choice i developed rsi
04:42:06 <Axman6> all the more reason to start early and reduce the wear no?
04:42:11 <maltem> Axman6: hm in theory I should have 50G tmp storage :)
04:42:26 <Axman6> hmm, i didn't think of that...
04:42:36 <fatalerrorx> Axman6: i did but had to pause for a while to recover
04:42:52 <maltem> (that's what 'quota' says)
04:43:07 <Axman6> extracting the binaries used too much space, when the tar.gz was still in there
04:44:09 <blackdog> heh. 'caching' the data with Read is waaaaay slower :)
04:54:02 <maltem> oh, I didn't realize they're publishing tar'ed binary snapshots of ghc. Looks like the first option to try
04:54:38 <Axman6> indeed
04:58:23 <blackdog> i've been trying to resist the bloom filters, but it might be time
04:58:32 <blackdog> all the cool kids are using 'em, right?
05:12:30 <jkr> Is there a function for parsing ints from strings in the standard library?
05:13:05 <Peaker> @type read
05:13:06 <lambdabot> forall a. (Read a) => String -> a
05:13:21 <Peaker> @hoogle String -> Int
05:13:21 <lambdabot> Prelude read :: Read a => String -> a
05:13:21 <lambdabot> Text.Read read :: Read a => String -> a
05:13:21 <lambdabot> Prelude error :: String -> a
05:13:38 <Peaker> jkr: hoogle is smart enough to note that Int is a Read instance, so it shows "read" first
05:14:04 <jkr> What is hoogle? :)
05:14:28 <jkr> Ah nice
05:16:05 <Axman6> > read "194836" :: Integer
05:16:06 <lambdabot>   194836
05:16:17 <Axman6> > read "194836afe" :: Integer
05:16:18 <lambdabot>   * Exception: Prelude.read: no parse
05:16:31 <trhj> @pl (\x -> all (( 0 /= ) . mod x) $ takeWhile (<=(floor . sqrt . fromIntegral $ x))
05:16:32 <lambdabot> (line 1, column 80):
05:16:32 <lambdabot> unexpected end of input
05:16:32 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or ")"
05:30:23 <maltem> er... do I somehow have to download libffi seperately for a ghc snapshot to install?
05:31:15 <maltem> the Makefile tries to find libffi*.tar.gz
05:32:46 <maltem> even though libHSffi.a is present in that directory
05:40:38 <chrisdone> maltem: did you run the bootstrap/
05:41:30 * chrisdone checks to see if ghc 6.10 is out yet
05:43:18 <jimstutt> chrisdon: I'm failing to build ghc-6.10.1 from src pkg. make currently fails with unable to load .so/.dll libHScontainers-0.1.0.0
05:44:16 <jimstutt> chrisdone: as above
05:44:48 <maltem> chrisdone: no, this is a binary snapshot
05:45:35 <maltem> chrisdone: I'll just copy the ffi files by hand, I guess
05:50:27 <maltem> bah, no I fail to compile libedit
05:50:48 <trhj1> * 1
05:51:08 <trhj1> just testing connection
05:54:52 <jimstutt> maltem: I have the same problem with libedit not loading libHSarray-01.0.0.so
05:56:03 <jimstutt> maltem: dons has a list of verified packages somewhere but I can't find it at the moment.
05:56:03 <maltem> jimstutt: actually my problem was that libedit on sourceforge is the wrong one :)
05:56:59 <jimstutt> maltem:ah. Have you worked out which the correct one should be?
05:57:26 <maltem> jimstutt: http://www.thrysoee.dk/editline/ is linked from the ghc pages
05:57:29 <lambdabot> Title: Editline Library (libedit) - Port of NetBSD Command Line Editor Library
05:57:55 <Stinger> can you import the same module more than once in Haskell?
05:58:04 <mauke> Stinger: yes
05:58:08 <jimstutt> maltem: tnx
05:58:18 <Stinger> ah so you can do one qualified and one with hiding say
06:01:42 <dcoutts> MarcWeber: install-includes is what you want I think
06:09:25 <trhj1> , all
06:09:33 <lunabot>  luna: No instance for (GHC.Show.Show
06:09:56 <ski> , none
06:09:58 <lunabot>  luna: Not in scope: `none'
06:11:38 <vixey> , maybe
06:11:40 <lunabot>  luna: No instance for (GHC.Show.Show
06:11:48 <EvilTerran> , src 'maybe
06:12:00 <lunabot>  maybe :: forall b a . b -> (a -> b) -> (Maybe a) -> b
06:13:51 <trhj1> @help
06:13:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:13:57 <trhj1> @list
06:13:57 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:16:46 <trhj1> @pl (\x -> x)
06:16:47 <lambdabot> id
06:17:17 <trhj1> @unlambda ````.t.e.s.t
06:17:17 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
06:17:24 <BONUS> @pl (\6 -> 7)
06:17:24 <lambdabot> const 7
06:17:53 <BONUS> @pl (\(x:xs) -> x)
06:17:54 <lambdabot> head
06:19:00 <trhj1> @unpl (^2) . (+3) . (*7) . (/9) $ x
06:19:02 <lambdabot> ((((x / 9) * 7) + 3) ^ 2)
06:19:02 * EvilTerran notes that @pl appears to not care particularly about types
06:19:33 <mauke> @pl \f -> f f
06:19:38 <agcorona> hi
06:20:49 <EvilTerran> @pl (\x -> x x) (\x -> x x)
06:20:49 <EvilTerran> ...
06:20:49 <lambdabot> ap id id (ap id id)
06:20:49 <lambdabot> optimization suspended, use @pl-resume to continue.
06:21:34 <mauke> @bot
06:22:41 <EvilTerran> whups
06:24:03 <mauke> @bot
06:25:35 <trhj1> what's going on?
06:25:37 <lambdabot> :)
06:25:49 <mauke> @pl \f -> f f
06:25:49 <lambdabot> join id
06:26:57 <vixey> @pl join id $ join id
06:26:57 <lambdabot> join id (join id)
06:27:04 <vixey> @pl join id (join id)
06:27:04 <lambdabot> join id (join id)
06:27:36 <pozic> Why doesn't this work?  Data.Sequence.take 5 $ fromList ([1..])
06:27:53 <Deewiant> ?ty Data.Sequence.take
06:27:55 <lambdabot> forall a. Int -> Data.Sequence.Seq a -> Data.Sequence.Seq a
06:27:56 <pozic> Obviously, fromList is not lazy, but why is that?
06:28:22 <Deewiant> fromList -- "O(n). Create a sequence from a finite list of elements."
06:28:42 <mauke> pozic: because it offers O(1) access to the end
06:29:28 <trhj1> @pl (\(q,w,e,r,t,y,u,i,o,p) -> (t,w,u,e,o,p,q,i,r))
06:29:28 <lambdabot> (line 1, column 7):
06:29:47 <lambdabot> unexpected ","
06:29:47 <lambdabot> expecting letter or digit, operator or ")"
06:29:47 <lambdabot> ambiguous use of a non associative operator
06:29:53 <Deewiant> trhj1: @pl can handle pairs but no bigger tuples
06:29:53 <vixey> @pl \ a o e u i d h t n -> t i o u h a h o e
06:29:57 <lambdabot> ((((((const . ((const .) .)) .) .) .) . flip . ((flip . ((flip . (flip .)) .)) .)) .) . join . ((flip . (flip .)) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip flip id . (flip .) . ((flip .) .)
06:30:23 <trhj1> @pl \(q,w,e,r,t,y,u,i,o,p) -> (t,w,u,e,o,p,q,i,r,y)
06:30:31 <lambdabot>  . (((ap .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((flip .) .) . flip . (flip .) . flip (flip . flip id))
06:30:31 <lambdabot> optimization suspended, use @pl-resume to continue.
06:30:31 <lambdabot> (line 1, column 6):
06:30:31 <lambdabot> unexpected ","
06:30:33 <lambdabot> expecting letter or digit, operator or ")"
06:30:33 <pozic> Is foldr on a constructed sequence lazy?
06:30:35 <lambdabot> ambiguous use of a non associative operator
06:30:43 <Peaker> mauke: O(1)? not O(logN)?
06:30:46 <Deewiant> @@ @djinn @type \ a o e u i d h t n -> t i o u h a h o e
06:30:48 <lambdabot>  f a b c d e _ f g _ = g e b d f a f b c
06:30:49 <pozic> Peaker: no
06:31:23 <trhj1> @pl-resume
06:31:29 <lambdabot> ((((((const . ((const .) .)) .) .) .) . flip . ((flip . ((flip . (flip .)) .)) .)) .) . join . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip flip id . ((flip . ((flip . (liftM2 flip .)) .))
06:31:29 <lambdabot> .) . flip (flip . ((flip . ((flip . (flip .) . flip) .)) .) . flip . (flip .) . flip (flip . flip id))
06:31:29 <lambdabot> optimization suspended, use @pl-resume to continue.
06:31:30 <pozic> I.e. is it O(number of inspected elements) as opposed to O(length of sequence)
06:33:44 <trhj1> Deewiant: please explain, then, why did lambdabot handle case where i just permuted values, but not when i removed some?
06:33:44 <blackdog> 65% productivity as reported by -sstderr really isn't very good, hey...
06:33:58 <Deewiant> trhj1: it didn't
06:34:08 <trhj1> @pl \(a,b,c) -> (b,c,a)
06:34:08 <lambdabot> (line 1, column 6):
06:34:08 <lambdabot> unexpected ","
06:34:08 <lambdabot> expecting letter or digit, operator or ")"
06:34:08 <lambdabot> ambiguous use of a non associative operator
06:34:10 <Deewiant> trhj1: it gave you an error
06:34:24 <Deewiant> trhj1: it was just printing the long output from vixey's @pl
06:34:40 <trofi> > hello world
06:34:41 <lambdabot>   Not in scope: `hello'Not in scope: `world'
06:35:03 <trofi> > he he
06:35:05 <lambdabot>   Not in scope: `he'Not in scope: `he'
06:35:07 <pozic> blackdog: that is normal
06:35:24 <trhj1> Deewiant: thx, got it.
06:35:26 <pozic> blackdog: it's the cost of using a garbage collector.
06:35:51 <trhj1> @type \ a o e u i d h t n -> t i o u h a h o e
06:35:52 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8. t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> (t4 -> t1 -> t3 -> t6 -> t -> t6 -> t1 -> t2 -> t8) -> t7 -> t8
06:36:21 <blackdog> pozic: yeah, but 35% of your time spent in GC?
06:36:26 <blackdog> that kinda hurts
06:36:54 <blackdog> are there any good techniques for reducing allocation?
06:37:02 <trhj1> @type \a b c -> b c a
06:37:03 <lambdabot> forall t t1 t2. t -> (t1 -> t -> t2) -> t1 -> t2
06:37:22 <trhj1> @type \a b -> b a
06:37:24 <lambdabot> forall t t1. t -> (t -> t1) -> t1
06:39:08 <byorgey> blackdog: you are using -O2, I assume?
06:40:02 <agcorona> non GC languages also perform GC. When you call New, or Free or Malloc, the allocation library spend a greath deal of time walking troug the blocks of memory
06:40:46 <vixey> agcorona: is that GC though?
06:41:48 <agcorona> it is GC, but not automatic GC
06:41:51 <trhj1> > (a,b,c)
06:41:52 <lambdabot>       Ambiguous occurrence `c'
06:41:52 <lambdabot>      It could refer to either `L.c', defined a...
06:42:07 <Deewiant> @undef
06:42:09 <trhj1> > (1,2,3)
06:42:10 <Deewiant> > (a,b,c)
06:42:10 <lambdabot>   (1,2,3)
06:42:11 <JuanDaugherty> memory mgt != gc
06:42:12 <lambdabot>   (a,b,c)
06:42:18 <blackdog> sure, there's always going to be some overhead in managing memory, whether it's automatic or manual
06:42:26 <blackdog> it just seems high.
06:42:31 <trhj1> ((a,b),c)
06:42:50 <blackdog> byorgey: yeah, using -O2
06:44:43 <Saizan> you could profile to see what's allocating so much and try to reduce that, changing some datastructures maybe
06:45:10 <Saizan> e.g. going from String to ByteString for large data can save a lot of memory
06:45:11 <Deewiant> writing stuff 'manually' instead of elegantly helps, too
06:45:17 <EvilTerran> @pl \(t,(u,(p,(l,e)))) -> (e,(l,(p,(u,t))))
06:45:20 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . (((.) . (flip (,) .) . flip (,)) .) . flip (,)) .) .
06:45:20 <lambdabot> flip (,))
06:45:33 <blackdog> Saizan: yeah, i've switched to ByteStrings and that helps a bit
06:46:23 <blackdog> i think my next step is going to have to be just serialising the data structure i spend all my time building
06:46:50 <blackdog> read/show are horrifically slow for this, so i guess a binary instance is the best bet
06:47:17 <trhj1> > (1,(2,3))
06:47:18 <lambdabot>   (1,(2,3))
06:47:22 <blackdog> Deewiant: it would be hard to accuse this code of being elegant :)
06:47:32 <Deewiant> :-P
06:47:34 <pozic> There is Foldable, where is Scanable?
06:48:05 <vixey> > let (*) = (,) in (1 * 2 * 3 * 4 * 5 * 6)
06:48:06 <lambdabot>   (((((1,2),3),4),5),6)
06:48:16 <trhj1> > ((1,2),3)
06:48:17 <lambdabot>   ((1,2),3)
06:48:25 <maltem> pozic: Traversable, maybe?
06:48:41 <dcoutts> hmm, my zlib announcement email to haskell-cafe seems to have disappeared into the ether
06:48:42 <vixey> > let (*) = (,) in (Nothing * 2 * () * 'x' * "foo" * True)
06:48:43 <lambdabot>   (((((Nothing,2),()),'x'),"foo"),True)
06:49:27 <trhj1> > let 2*2 = 5 in 2*2
06:49:27 <trhj1> > let 2*2 = 5 in 2*2
06:49:28 <lambdabot>   5
06:49:29 <lambdabot>   5
06:50:42 <pozic> maltem: I don't think so.
06:50:45 <trhj1> lambdabot seems to have thought hard whether 2*2 _really_ equals 5, but it had no choice :-)
06:51:37 <vixey> > 2*3 :: Expr
06:51:39 <lambdabot>   2 * 3
06:51:42 <vixey> > 2^3 :: Expr
06:51:43 <lambdabot>   2 * 2 * 2
06:51:51 <vixey> > let 2*2 = 5 in 2^3 :: Expr
06:51:53 <lambdabot>   2 * 2 * 2
06:52:06 <vixey> > let 2 * 2 = 5 in 2^3 :: Expr
06:52:07 <lambdabot>   2 * 2 * 2
06:59:33 <Philonous> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
06:59:34 <lambdabot> ap (. join id) (. join id)
07:00:39 <EvilTerran> pozic, i don't think such a thing is readily available, although there may be something in category-extras
07:02:49 <EvilTerran> pozic, actually, Traversable looks suitable, if you use the State monad
07:10:00 <EvilTerran> gah, there's no instance Applicative (State s)
07:10:07 <EvilTerran> , Node () []
07:10:09 <lunabot>  Node {rootLabel = (), subForest = []}
07:10:20 <EvilTerran> , traverse
07:10:22 <lunabot>  luna: Not in scope: `traverse'
07:10:29 <EvilTerran> , Data.Traversable.traverse
07:10:31 <lunabot>  luna: Not in scope: `Data.Traversable.traverse'
07:10:49 <trhj1> what lunabot can do?
07:10:56 <Deewiant> > Data.Traversable.traverse
07:10:57 <lambdabot>       Overlapping instances for Show ((a -> f b) -> t a -> f (t b))
07:10:57 <lambdabot>        ar...
07:11:24 <EvilTerran> Deewiant, yeah, i've seen that talking to \b in /msg, but i was hoping lunabot had Traversable visible *and* the instance i mentioned
07:11:35 <Deewiant> ?instances Applicative
07:11:36 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
07:12:02 <EvilTerran> however, i think
07:12:27 <EvilTerran> flip runState [] . traverse (\x -> do modify (x:); return (x+1)) $ Node 1 [Node 2 [Node 3 [], Node 4 [Node 5 []]], Node 6 []]
07:12:37 <EvilTerran> say, would do something similar to a scanl
07:13:32 <EvilTerran> ?type scanl
07:13:33 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
07:14:36 <EvilTerran> ?type Data.Traversable.traverse
07:14:37 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
07:15:24 <meoow> hello
07:15:27 <Deewiant> ?ty flip runState [] . Data.Traversable.traverse (\x -> do modify (x:); return (x+1))
07:15:28 <lambdabot> forall a (t :: * -> *). (Num a, Data.Traversable.Traversable t, Applicative (State [a])) => t a -> (t a, [a])
07:16:04 <meoow> short question: does anyone else have trouble with cabal on ubuntu intrepid (zlib: "incompatible version")?
07:16:18 <EvilTerran> ?type \f e xs -> Data.Traversable.traverse (State . f) xs `runState` e
07:16:18 <lambdabot> forall s a a1 (t :: * -> *). (Applicative (State s), Data.Traversable.Traversable t) => (a1 -> s -> (a, s)) -> s -> t a1 -> (t a, s)
07:16:37 <EvilTerran> pozic, there's your scanl ^
07:17:02 <dcoutts> meoow: hmm, what version of the zlib C library have you got?
07:17:05 <EvilTerran> well, mapAccumL, but that's more general
07:17:13 <EvilTerran> ?type mapAccumL
07:17:14 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:17:31 <meoow> dcoutts: 0.9k
07:17:45 <meoow> dcoutts: cabal was compiled with same version
07:19:15 <dcoutts> meoow: that doesn't make any sense, there is no 0.9 version of zlib, the C lib or the binding
07:19:24 <Deewiant> > mapAccumL (\a b -> (f a, g b)) z [a,b,c,d,e] :: (Expr,[Expr])
07:19:25 <lambdabot>   (f (f (f (f (f z)))),[g a,g b,g c,g d,g e])
07:19:30 <dcoutts> meoow: I mean the version of the ubuntu zlib package
07:19:37 <Deewiant> > mapAccumR (\a b -> (f a, g b)) z [a,b,c,d,e] :: (Expr,[Expr])
07:19:38 <lambdabot>   (f (f (f (f (f z)))),[g a,g b,g c,g d,g e])
07:20:13 <luite> meoow: I installed cabal, ghc 6.10 etc a few days ago on intrepid, no problems
07:21:30 <meoow> dcoutts: my mistake. it's version 1.2.3.3.
07:22:01 <meoow> that was the version of another package ;).
07:22:02 <luite> meoow: I installed the zlib1g-dev package
07:22:13 <pozic> EvilTerran: mapAccumL is better, thanks.
07:22:23 <meoow> luite: yes, that's the one i use
07:22:43 <Deewiant> what's the difference between mapAccumL and mapAccumR that doesn't show up in the above
07:22:43 <EvilTerran> pozic, note that i don't think that'll work without you defining "instance Applicative (State s) where pure = return; (<*>) = ap"
07:23:17 <Deewiant> ?instances-importing Control.Applicative Applicative
07:23:18 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
07:23:31 <Deewiant> hmph, no monad instance
07:23:44 <opqdonut> WrappedMonad
07:23:46 <meoow> i'll try to completely recompile everything.
07:23:46 <opqdonut> it's that one
07:23:50 <meoow> thanks anyway.
07:24:15 <Deewiant> opqdonut: good point, thanks
07:25:50 <pozic> Deewiant: I think mapAccumL xs == mapAccumR (reverse xs)
07:26:11 <pozic> Deewiant: ignoring several arguments, of course.
07:26:13 <Deewiant> > mapAccumR (\a b -> (f a, g b)) z [e,d,c,b,a] :: (Expr,[Expr])
07:26:15 <lambdabot>   (f (f (f (f (f z)))),[g e,g d,g c,g b,g a])
07:26:34 <Deewiant> hm
07:26:35 <Deewiant> actually
07:26:44 <Deewiant> > mapAccumR (\a b -> (f a b, g a b)) z [a,b,c,d,e] :: (Expr,[Expr])
07:26:46 <lambdabot>   (f (f (f (f (f z e) d) c) b) a,[g (f (f (f (f z e) d) c) b) a,g (f (f (f z ...
07:26:53 <Deewiant> yeah, that's the difference
07:26:58 <Deewiant> > mapAccumL (\a b -> (f a b, g a b)) z [a,b,c,d,e] :: (Expr,[Expr])
07:26:59 <lambdabot>   (f (f (f (f (f z a) b) c) d) e,[g z a,g (f z a) b,g (f (f z a) b) c,g (f (f...
07:30:32 <byorgey> wow, I had forgotten how long gtk2hs takes to compile =)
07:30:32 <pozic> The type of mapAccumL is a lot better displayed by lambdabot than by ghci here.
07:30:45 <trhj1> @pl (\f a b c d e -> f b c d e a)
07:30:45 <lambdabot> flip . ((flip . ((flip . (flip .)) .)) .)
07:31:03 <Deewiant> byorgey: how long?
07:31:16 <byorgey> I don't know yet, it's still going
07:31:26 <byorgey> it's probably been 10 minutes so far
07:31:28 <Deewiant> heh
07:31:31 <Deewiant> on Windows, it's easily 8 hours
07:31:33 <int-e> @pl (\f a b c d e -> f a (b (c d) e))
07:31:34 <lambdabot> flip flip (.) . (((.) . (.) . (.) . (.)) .)
07:31:44 <Deewiant> on linux, maybe half an hour?
07:31:45 <byorgey> yikes!
07:31:49 <trhj1> int-e: cool!
07:32:56 <trhj1> @pl \u a b c d e f g h -> u $ a $b $ c $ d $ e $ f $ g $ h
07:32:58 <lambdabot> (. ((. ((. ((. ((. ((. (.)) . (.) . (.))) . (.) . (.) . (.))) . (.) . (.) . (.) . (.))) . (.) . (.) . (.) . (.) . (.))) . (.) . (.) . (.) . (.) . (.) . (.))) . (.) . (.) . (.) . (.) . (.) . (.) . (.)
07:33:19 <int-e> pointless indeed :)
07:33:20 <pozic> Deewiant: that's 3 times the kernel. :P
07:33:32 <Deewiant> pozic: well, depends on your machine of course
07:33:44 <Deewiant> and your kernel configuration. :-P
07:34:08 <pozic> Deewiant: and the position of the Moon.
07:34:17 <Deewiant> to a lesser extent, but yes.
07:35:56 <trhj1> @type (1,2,3)
07:35:56 <lambdabot> forall t t1 t2. (Num t2, Num t1, Num t) => (t, t1, t2)
07:36:07 <trhj1> @type (a,b,c)
07:36:08 <lambdabot> (Expr, Expr, Expr)
07:36:16 <byorgey> hooray, gtk2hs finished building!
07:36:20 <trhj1> @type ((a,b,c))
07:36:20 <lambdabot> (Expr, Expr, Expr)
07:36:34 <Deewiant> byorgey: see, that wasn't bad at all :-P
07:36:36 <trhj1> @type ((a,b),c)
07:36:36 <lambdabot> ((Expr, Expr), Expr)
07:36:48 <trhj1> @type (a,(b,c))
07:36:49 <lambdabot> (Expr, (Expr, Expr))
07:37:04 <byorgey> Deewiant: nope, it wasn't =)
07:37:18 <Deewiant> byorgey: now do it on Windows and tell me about it tomorrow ;-)
07:37:43 <byorgey> Deewiant: hehe, no thanks! =)
07:38:46 <trhj1> So, can somebody please tell me whether , (comma) is right-associative, left-associative, or what?
07:39:03 <int-e> , is not an operator
07:39:03 <Deewiant> it's neither, it's magic
07:39:04 <ski> neither
07:39:04 <lunabot>  luna: Not in scope: `is'
07:39:21 <Peaker> which kind of sucks. Who needs triples, quadraples, when we can do well with just tuples? :P
07:39:23 <Deewiant> trhj1: since, as you can see, (a,b,c) is not the same as ((a,b),c) nor (a,(b,c))
07:39:34 <int-e> trhj1: (a,(b,c)), ((a,b),c) and (a,b,c) are three distinct types (or tuples, for that matter.)
07:40:17 <int-e> lunabot: hush.
07:40:55 <ski> ,
07:40:55 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
07:41:04 <Deewiant> >
07:41:59 <ski> >
07:42:21 <ski> hm
07:42:34 <Deewiant> lambda > luna
07:50:42 <trhj1> (,) is magic... hm... *enlightement*  So we can't construct really large tuples. Thanks, got it. btw, i'm lost in all this constructors' syntax: prefix (Maybe a), infix (a,b), surrounding ([a]).. Is there any beyond these  or i can make something like: data MyCoolType a b c d = $%^^ a &*&^%% b &*^$ c @#$%> d '*&
07:51:19 <idnar> trhj1: [a] is "special", you can't define your own ones like that
07:51:25 <Deewiant> Well, we can construct really large tuples
07:51:28 <mauke> (,) is also built into the compiler
07:51:33 <Deewiant> I think GHC's limit was 35?
07:51:42 <Peaker> hmm, I haven't realized the specialness of "surrounding" syntax ebfore
07:51:45 <idnar> (,) and (,,) and (,,,) and so on are also "special"
07:51:47 <Deewiant> That's "really large" if you ask me :-)
07:52:02 <Deewiant> Note that [a] can be written as [] a
07:52:04 <idnar> but you can define any prefix constructors you like, as long as they start with a capital letter
07:52:12 <Deewiant> And (a,b) can be written as (,) a b
07:52:18 <idnar> and you can define any infix constructors you like, as long as they start with : and are an operator
07:53:59 <trhj1> So [a] is desugared to [] a.Thanks.
07:55:36 <sk1> >
07:56:43 <Peaker> I think multi-tuples are against the Haskell spirit.. multi-arg functions reduced to single-arg, why not tuples?
07:57:10 <EvilTerran> i agree
07:57:32 <ddarius> Let's reduce n-tuples to 1-tuples!
07:57:38 <Peaker> heh
07:57:40 <idnar> so (a,b,c) would desugar to (,) ((,) a b) c?
07:57:49 <Deewiant> no, that'd be ((a,b),c)
07:57:58 <Peaker> idnar: either left or right associative, not sure if it matters
07:57:58 <EvilTerran> ddarius, well, function application is a binary operation, so tupling should be likewise, imo
07:57:58 <idnar> no, I mean, in Peaker's fantasy world
07:58:02 <trhj1> Me too. Haskell has many features that are against the spirit of haskell( no kidding)
07:58:06 <Deewiant> oh, right
07:58:15 <Peaker> trhj1: what other features?
07:58:29 <EvilTerran> IMO, (x0,x1,...,xN) should de-sugar to something like (x0 :*: x1 :*: ... :*: xN :*: ()), where data Cons x xs = x :*: !xs
07:58:57 <EvilTerran> (and :*: is infixr)
08:00:17 <trhj1> Peaker: Mm, let me think. (went reading )
08:01:07 <EvilTerran> Peaker, unary (-)?
08:01:52 <Peaker> EvilTerran: well, syntax is a compromise, but (,,) is more than just syntax
08:01:59 <Peaker> it has semantic implications
08:03:09 <EvilTerran> Peaker, well, i *think* my suggestion would maintain semantics for existing programs, owing to the !
08:03:26 <EvilTerran> but would allow all sorts of new arcane trickery with typeclasses and whatnot
08:04:17 <Peaker> EvilTerran: won't instances be different?
08:04:40 <EvilTerran> ah, yes, it'd be the same modulo -XFlexibleInstances
08:05:40 <Peaker> EvilTerran: well, I favor the positive semantic change
08:05:42 <EvilTerran> as (a,b) (a valid h98 instance head) would de-sugar to (a :*: (b :*: ())) (not a valid h98 instance head)
08:05:55 <Peaker> EvilTerran: The unary (-) bugs me a lot less because its a superficial syntactic change
08:06:02 <EvilTerran> indeed
08:06:11 <Peaker> EvilTerran: Using :*: might make it easier to have n-tuple instances of types/etc
08:06:19 <EvilTerran> indeed!
08:06:20 <pozic> dcoutts: are debugging libraries for GTK2hs being automatically build already? ISTR some problems with that.
08:06:54 <EvilTerran> instance (Eq a, Eq as) => Eq (a :*: as) where (x :*: xs) == (y :*: ys) = (x == y) && (xs == ys)
08:07:00 <dcoutts> pozic: ./configure --enable-profiling
08:07:09 <EvilTerran> and then you have an Eq instance for any length of tuple!
08:07:17 <pozic> dcoutts: there was a time that that didn't work, right?
08:07:45 <dcoutts> pozic: right, before the --enable-profiling option was added
08:07:46 <EvilTerran> likewise Ix, Ord, ...
08:08:02 <Peaker> when I first learned Haskell (just months ago) I had a big list of things that bugged me about it.. For each item, a little discussion here usually convinced me that I was wrong and Haskell was right, heh
08:08:08 <pozic> dcoutts: I mean like less than a year ago.
08:08:15 <Peaker> but the tuple thing remains ;)
08:08:21 <dcoutts> pozic: not afaik
08:08:36 <pozic> dcoutts: ok, thanks.
08:08:37 <dcoutts> pozic: I don't recall exactly when the profiling option was added though
08:09:06 <pozic> dcoutts: I can remember that the debugging build failed here, but the real one didn't.
08:11:22 <Peaker> EvilTerran: Does Haskell have an equivalent to "PEP"s ?
08:11:29 <Peaker> EvilTerran: (Python Enhancement Proposal)
08:12:03 <|Mzzz|> I think Haskell could provide something like Lisp's macro, and the sugars can be defined explictly as macros, and we can add user defined sugars too.
08:12:03 <Peaker> Writing a little paper about a proposed feature, explaining the rationale/problem, the solution, and an optional implementation?
08:12:13 <Peaker> |Mzzz|: That's what TH is, I think
08:12:17 <pozic> Peaker: all Haskell papers are about that.
08:12:17 <Peaker> |Mzzz|: (Template Haskell)
08:12:40 <Peaker> pozic: well, PEP's have a convenient uniform format, are numbered, and have status tracking on the web
08:12:40 <pozic> Peaker: every researcher wants to have his record system into Haskell :)
08:12:56 <pozic> Peaker: the GHC wiki is used also
08:13:06 <pozic> Peaker:(for Haskell')
08:13:25 <pozic> Peaker: in case it's just a library, there is a mailing list.
08:13:37 <pozic> Peaker: libraries@haskell.org, IIRC.
08:13:39 <Deewiant> Peaker: in short: "no."
08:13:45 <Peaker> :-)
08:13:48 <idnar> mmph, fundeps still seem like magic to me
08:13:55 <Peaker> idnar: in what way?
08:14:21 <idnar> if you have, say, "class (Monad m) => MonadReader r m | m -> r"
08:14:27 <|Mzzz|> I also think it would be nice to define the Haskell "Core Language" explicitly.
08:14:39 <idnar> that basically reads as "m determines the type of r", right?
08:14:45 <EvilTerran> idnar, exactly
08:15:11 <idnar> so, I don't have a problem using that idea to write fundeps; I just don't understand how the compiler actually figures out what's going on
08:15:53 <idnar> it seems like you should have to tell it *how* m determines the type of r, or something
08:16:00 <EvilTerran> idnar, if the fundep was absent, the compiler might not be able to figure out what type "ask" produces
08:16:03 <EvilTerran> ?type ask
08:16:04 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
08:16:41 <EvilTerran> idnar, ah, you tell it *how* earlier in the instance
08:16:50 <EvilTerran> "instance MonadReader r ((,) r)"
08:17:28 <EvilTerran> tells the compiler that, whenever it sees ((,) r) being used as a MonadReader instance, it can use r as the return-type for ask, effectively
08:17:33 <EvilTerran> ?type local
08:17:34 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
08:17:57 <idnar> oh! *light-bulb*
08:18:50 <ski> the fundep `m -> r' on `MonadReader r m' means that whenever `MonadReader r0 m' and `MonadReader r1 m', then `r0 = r1'
08:18:58 <idnar> that makes more sense, then
08:20:38 <ski> (so even if it hasn't seen an instance for a particular `m' yet, it still knows all related `r' must be the same, cutting down on inferred type variables, thus getting less room for ambiguity)
08:21:45 <idnar> yeah, okay
08:23:43 <ski> (another way to state it is that that fundep means `forall m. unique r. MonadReader r m')
08:24:39 <daf> is there a better way to specify "list of one or more" in a type than to have separate members for the first element and a list of any others?
08:25:04 <dolio> (a,[a])?
08:25:04 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
08:25:38 <daf> dolio: I suppose that's a bit nicer
08:25:44 <pozic> Is there anyone that likes the family-syntax?
08:26:02 <dolio> For what?
08:26:07 <EvilTerran> pozic, i find it painfully verbose
08:26:11 <pozic> EvilTerran: me too
08:26:23 <EvilTerran> particularly associated type families
08:26:27 <dolio> It's way better for type level programming.
08:26:55 <EvilTerran> seeing as you have to name the type both in the instance head and in the type family instantiation
08:27:19 <EvilTerran> and, when i'm using an experimental type-level feature, my types tend to be pretty long anyway, so that just gets annoying :P
08:28:13 <dolio> Yeah, I suppose 'instance Foo (BarBaz) where type Quux (BarBaz) = ...' is a little verbose.
08:28:37 <EvilTerran> the last time i tried to use families, they were horribly buggy, too
08:29:32 <trhj1> Haskell is strictly typed, right? Sometimes I think that in spirit of Haskell, is to be lazily typed.
08:30:43 <EvilTerran> trhj1, so, what, you'd be able to have an ill-typed expression as long as the type of the program as a whole didn't depend on it?
08:31:09 <EvilTerran> const () (\x -> x x) :: () -- kinda thing
08:31:48 <Deewiant> hmm, could that be useful?
08:31:50 <ski> how about `if True then () else (\x -> x x)', then ?
08:32:23 <EvilTerran> ski, that wouldn't pass the typing rule for if, though
08:32:34 <Philonous> Isn't that just dynamic typing?
08:33:03 <Philonous> Oh, I see why not, never mind
08:33:03 <EvilTerran> "y :: A |- const x y :: A", but "p :: Bool; t, f :: A |- if p then t else f :: A"
08:33:04 <ski> EvilTerran : right .. but mayhaps in some kind of more relaxed system ..
08:33:24 <EvilTerran> ski, well, i think that'd require either dependent typing or dynamic typing
08:33:52 <ski> (consider subtyping where we have a subtype of `Bool' only including the `True' value)
08:34:14 <EvilTerran> i'm not convinced my suggestion has any actual merit, it'd be merely a curiosity AFAICT
08:34:20 <dolio> Where do you stop checking, though? If I add a new function, and want to check for typing mistakes, do I have to make sure it's called from main?
08:34:20 <trhj1> Yeah! You'd be able to construct an infinite data type. Consider the problem of creating a pascal's write; function analog, that is, it accepts arguments until it encounters value stop::Stop. Sorry, but i can't type quickly
08:34:49 <EvilTerran> dolio, as i said, good only as a curiosity, not really useful
08:35:02 <EvilTerran> trhj1, you can do something similar to that already
08:35:17 <ski> dolio : yes, obviously nothing would be checked unless it is called from main (or a given expression in the interactor)
08:35:24 <EvilTerran> > printf "%4.2f,%d" 0.1 3 :: String
08:35:25 <lambdabot>   "0.10,3"
08:35:32 <EvilTerran> > printf "%4.2f,%d" 0.1 3 :: IO ()
08:35:33 <lambdabot>   * Exception: "<IO ()>"
08:36:11 <EvilTerran> > printf "%4.2f,%d" 0.1 :: String
08:36:11 <dolio> Seems like that'd lessen some of the benefits of static typing.
08:36:12 <lambdabot>   "0.10,* Exception: Printf.printf: argument list ended prematurely
08:36:17 <trhj1> EvilTerran, can you please point me to info about how it works?
08:36:39 <trhj1> @type printf
08:36:40 <lambdabot> forall r. (PrintfType r) => String -> r
08:36:57 <EvilTerran> trhj1, i don't understand it fully myself, TBH
08:37:13 <ski> (or i suppose one could say that compiling a compilation unit would force the type of all exported values ..)
08:37:33 <vixey> trhj1, how does printf work?
08:37:35 <EvilTerran> ski, that would make sense
08:37:52 <ski> (maybe assuming no inter-module optimization ..)
08:38:04 <EvilTerran> ski, seeing as a compilation unit could be viewed as a record of its exported values
08:38:20 <EvilTerran> its "type" would depend on the type of its exported values
08:38:20 <ddarius> printf is a format string parser created inductively from the type.
08:38:24 <ski> EvilTerran : so it's a strict record, then ?
08:39:07 <EvilTerran> i mean you could typecheck everything exported by asking for the module's type
08:39:27 <vixey> @let stop = []
08:39:28 <lambdabot>  Defined.
08:39:41 <EvilTerran> which would then be worked out lazily, but it'd still have to force the types of the exported values
08:39:49 <vixey> > Left 1 :: Right (Left "foo") :: Left 44 :: Right (Right (Left True)) :: stop
08:39:50 <lambdabot>   <no location info>: parse error on input `"'
08:40:03 <vixey> :t Left 1 : Right (Left "foo") : Left 44 : Right (Right (Left True)) : stop
08:40:04 <lambdabot> forall t b. (Num t) => [Either t (Either [Char] (Either Bool b))]
08:40:18 <vixey> trhj1, regarding, pascal write thing, you can do that
08:42:11 * ski thinks modules-as-records possibly would be at least somewhat non-strict
08:42:28 <ddarius> @google "A Typed Pattern Calculus"
08:42:35 <lambdabot> http://citeseer.ist.psu.edu/kesner96typed.html
08:44:11 <ddarius> @google "The Pattern Calculus"
08:44:14 <lambdabot> http://portal.acm.org/citation.cfm?id=1034775
08:44:14 <lambdabot> Title: The pattern calculus
08:44:26 * dolio mutters about citeseerx.
08:44:34 <roconnor> laziness is awesome.
08:44:49 <roconnor> My little application continues to work even with corrupted data
08:45:00 <roconnor> so long as I don't ask questions that depend on the corrupted data
08:45:59 <alson_> dons: you around?
08:46:25 <mauke> preflex: seen dons
08:46:25 <preflex>  dons was last seen on #xmonad 9 hours, 29 minutes and 55 seconds ago, saying: there's some innovation there not merged in yet
08:46:35 <alson_> scraps
08:46:56 <alson_> anyone know where the darcs repo for plugins is?
08:47:08 <mauke> @where hs-plugins
08:47:08 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
08:47:13 <alson_> yeah.  that's way out of date
08:47:27 <alson_> anyone know where the up-to-date repo for plugins is?
08:47:41 <ski> roconnor : what sort of application ?
08:49:03 <dons> alson_: http://code.haskell.org/~dons/code/hs-plugins
08:49:04 <lambdabot> Title: Index of /~dons/code/hs-plugins
08:49:20 <mauke> wat
08:49:23 <alson_> the repo at code.haskell.org is for Version 1.2.  But Hackage has version 1.3
08:49:45 <alson_> I'd like to submit a patch, but don't want to do it against old code
09:04:39 <trhj1> > let _'freedom' = "slavery" in _'freedom'
09:04:40 <lambdabot>   "slavery"
09:06:12 <trhj1> > let 2 + 2 = 5 in 2 + 2
09:06:13 <lambdabot>   5
09:06:33 <idnar> heh
09:06:53 <Peaker> I guess those are really large values of 2 there
09:07:45 <idnar> or maybe it's just a small value of 5
09:08:03 <Peaker> maybe its a really strong (+)
09:08:11 <Peaker> or a weak (=)
09:08:13 <mauke> > let 5 = 4; 2 + 2 = 5; in 2 + 2
09:08:14 <lambdabot>   5
09:08:15 <vixey> > let 2 + 2 = 5 in 2 + 3
09:08:16 <lambdabot>   * Exception: /tmp/4230511530556149224:70:56-64: Non-exhaustive patterns in ...
09:08:31 <vixey> > let 5 = 4 in 5
09:08:32 <lambdabot>   5
09:08:44 <vixey> > let Nothing = Just () in 5
09:08:45 <lambdabot>   5
09:08:56 <dolio> > let !5 = 4 in 5
09:08:57 <lambdabot>   * Exception: /tmp/8572291521244370752:70:48-53: Non-exhaustive patterns in ...
09:09:29 <mauke> > let (!5) = 4 in 5
09:09:30 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
09:09:33 <vixey> > let Just x = Nothing in x
09:09:34 <lambdabot>   * Exception: /tmp/6129561669159066575:70:36-51: Irrefutable pattern failed ...
09:11:19 <vixey> > let [x] = [] in x
09:11:20 <lambdabot>   * Exception: /tmp/2225618801715640104:70:36-43: Irrefutable pattern failed ...
09:12:55 <Peaker> > let ~[x] = [] in 5
09:12:56 <lambdabot>   5
09:13:00 <Peaker> > let [x] = [] in 5
09:13:01 <lambdabot>   5
09:14:09 <vixey> > let ~~[x] = [] in 5
09:14:09 <lambdabot>   <no location info>: parse error on input `~~'
09:14:59 <int-e> > let ~ ~[x] = [] in 5
09:15:00 <lambdabot>   5
09:15:11 <trhj1> @pl \f a b -> b a
09:15:11 <lambdabot> const (flip id)
09:15:53 <trhj1> @pl \f g a b -> g b a
09:15:53 <lambdabot> const flip
09:16:09 <trhj1> @pl \f g a b c-> g b a c
09:16:09 <lambdabot> const flip
09:16:20 <trhj1> @pl \f g a b c-> g b c a
09:16:20 <lambdabot> const (flip . (flip .))
09:16:40 <Cale> > let ![x] = [] in 5
09:16:41 <lambdabot>   * Exception: /tmp/8790346184442606911:70:40-48: Non-exhaustive patterns in ...
09:16:56 <vixey> > let ~ ~ ~ ~ ~ ~ ~ () = () in ()
09:16:57 <lambdabot>   ()
09:17:10 <Cale> That still throws me, that a let can be replaced with a case :)
09:17:39 <trhj1> @pl \comb f g arg -> f $ g arg
09:17:39 <lambdabot> const (.)
09:17:52 <Cale> I suppose mutual value recursion isn't going to work if there's strictness involved anyway
09:18:30 <vixey> I really dislike the scope rules for the do notation let
09:18:39 <Cale> vixey: Which ones?
09:18:46 <vixey> I write   let x = f x   sometimes and think that my 'f' is broken :(
09:18:50 <ndm> vixey: i often do x <- return $ expression in terms of x
09:18:58 <vixey> you have use x' or <- return $
09:19:20 <Cale> vixey: Oh, it's good that you can write recursive things with let there.
09:19:29 <trhj1> @pl \comp f g h arg -> f $ g $ h arg
09:19:29 <lambdabot> const ((. (.)) . (.) . (.))
09:19:48 <vixey> I've never written a recursive thing like that in do notation but I have got it wrong often
09:19:48 <Cale> But perhaps the error messages could make it clearer that it's a recursive binding.
09:19:59 <trhj1> @unpl const ((. (.)) . (.) . (.))
09:19:59 <lambdabot> (\ _ n t h k -> n (t (h k)))
09:20:59 <Cale> I just try to avoid ever reusing the same variable.
09:21:25 <Cale> It would be nice for shadowing to trigger a compiler error or warning.
09:21:37 <Cale> (optionally, of course)
09:21:49 <vixey> I don't think it's a problem, It's just a mistake I make way too often
09:23:26 <Cale> It would probably be easier to understand an error which said something along the lines of "x is already in use!" in your case, at least.
09:23:46 <ndm> what you actually want is a termination checker
09:23:51 <ndm> not a variable shadow checker
09:23:56 <Cale> ndm: hehe
09:24:03 <trhj1> @pl \x a b c d -> a$b$c$d
09:24:03 <lambdabot> const ((. (.)) . (.) . (.))
09:24:25 <Cale> ndm: Except that's significantly harder, and the actual bug here is that the variable is getting shadowed with a recursive binding.
09:24:53 <trhj1> @pl \a b c d -> a$b$c$d
09:24:53 <lambdabot> (. (.)) . (.) . (.)
09:24:55 <Cale> (but sure, if you can check termination of my programs, I'm not going to complain :)
09:25:00 <ndm> Cale: catching the really dumb cases, a "definately wrong" rather than a "provably terminating" checker is actually pretty easy
09:25:15 <ndm> i.e. instance Ord Foo where ...
09:25:23 <ndm> and probably x = f x
09:25:32 <ndm> if f is strict in x
09:26:24 <Beelsebob> anyone know what can cause the error "Package package-version can't be built on this system." from runhaskell Setup.lhs build?
09:26:35 <eu-prleu-peupeu> hi there
09:26:37 <Cale> Yeah. I still think it would be nice to catch shadowing as well.
09:26:42 <eu-prleu-peupeu> do you guys recommend reading "real world haskell" ?
09:26:48 <Cale> eu-prleu-peupeu: yes :)
09:27:14 <eu-prleu-peupeu> im thinking on buying it... so i can read on my daily commute time between home/work
09:27:17 <ndm> Cale: i use shadowing all the time, its great :)
09:27:29 <ndm> eu-prleu-peupeu: do you know Haskell already?
09:27:34 <eu-prleu-peupeu> yes
09:27:50 <Saizan> Beelsebob: i've seen that arise with Buildable: false in the .cabal file (which could be in an if)
09:27:55 <Cale> ndm: I try to avoid it as much as possible. My brain doesn't handle variables changing their meaning all that well. :)
09:28:05 <ndm> and do you want to learn real worldy stuff, or theoretical stuff?
09:28:16 <ndm> if the answer is theoretical, then Osaki's book is great
09:28:20 <eu-prleu-peupeu> i want both, because i lack both...
09:28:28 <Beelsebob> hmm, that's interesting Saizan -- it is indeed -- but it's if impl(ghc < 6.9)
09:28:30 <Cale> eu-prleu-peupeu: You can view the whole book online to see if it interests you.
09:28:32 <Beelsebob> and I'm on 6.11
09:28:32 <eu-prleu-peupeu> i dont know in depth haskell :(
09:28:39 <Cale> http://book.realworldhaskell.org/read/
09:28:40 <lambdabot> Title: Real World Haskell
09:28:41 <ndm> Cale: mine handles it perfectly - and finds other stuff really hard, which is kind of weird
09:28:49 <eu-prleu-peupeu> okey, ill do a diagonal reading
09:29:04 <dcoutts> Beelsebob: check configure -v, see what ghc it detects and what version it thinks it is
09:29:23 <eu-prleu-peupeu> :)
09:29:40 <eu-prleu-peupeu> what book does okasaki author ?
09:29:58 <ndm> functional data structures
09:30:07 <ndm> i can't remember the title, but is a fun book
09:30:09 <eu-prleu-peupeu> is it also online ?
09:30:16 <Deewiant> purely functional data structures
09:30:19 <Beelsebob> dcoutts: nvm, my path was set up wrong in that terminal >.<
09:30:33 <ndm> don't think so, but his thesis is, which has much of the same material - but not all, and not as well presented in some cases
09:30:36 <Deewiant> eu-prleu-peupeu: a version of it is online as his (master's, I think) thesis
09:30:43 <Deewiant> or doctoral
09:30:44 <eu-prleu-peupeu> what is the name of that good type theory book ?
09:30:45 <Cale> eu-prleu-peupeu: His thesis is online, which his book is an extension of.
09:30:48 <Deewiant> probably doctoral actually
09:30:53 <ndm> types and programming languages
09:30:55 <ndm> pierce
09:31:00 <Deewiant> TAPL
09:31:04 <Cale> Hehe, people are too fast for me :)
09:31:10 <eu-prleu-peupeu> yes, i remember reading it a bit... it was in ML if i remember
09:31:42 <Cale> TaPL is in ML, but the implementation language isn't so central to the book's development.
09:31:43 <ndm> the code was, but most of it is type theory rules :)
09:32:01 <Cale> Though, I really wish that the code didn't abuse exceptions.
09:32:09 <eu-prleu-peupeu> allright
09:32:12 <eu-prleu-peupeu> :)
09:32:16 <solussd> how would i remove duplicate lists from a list of lists if i consider [2,3,1,1] a duplicate of [3,1,2,1] ?
09:32:38 <Deewiant> > nubBy ((==) `on` sort) [[2,3,1,1],[3,1,2,1]]
09:32:40 <lambdabot>   [[2,3,1,1]]
09:33:13 <solussd> where is on defined?
09:33:19 <Deewiant> @index on
09:33:19 <lambdabot> bzzt
09:33:19 <Cale> Data.Function iirc.
09:33:23 <Deewiant> Data.Function, yes.
09:33:26 <solussd> thanks
09:33:30 <Deewiant> ?src on
09:33:31 <lambdabot> (*) `on` f = \x y -> f x * f y
09:33:34 <Beelsebob> solussd: that or create a newtype OrderedList a = [a], and only expose the "insert" function which keeps it ordered
09:33:43 <Cale> Or use Data.Set
09:33:46 <Cale> er
09:33:47 <Beelsebob> no
09:33:54 <Cale> right, that won't work, you want bags :)
09:33:55 <Beelsebob> [1,1,2,3] doesn't look like a set to me
09:34:02 <Beelsebob> yeh, that's the word I was looking for
09:34:16 <Cale> We really should have a Data.Bag in terms of Data.Map
09:34:25 <solussd> bags? is that what you call an unordered list of elements that might have more than one of the same element?
09:34:31 <Deewiant> bag or multiset
09:34:34 <Cale> solussd: yeah, or multiset.
09:34:50 <Deewiant> there is a Data.MultiSet, FWIW
09:34:54 <Cale> Oh?
09:34:56 <Deewiant> @hackage multiset
09:34:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/multiset
09:34:59 <Cale> On Hackage perhaps?
09:35:02 <Cale> ah
09:35:17 <Deewiant> and based on Data.Map, too :-)
09:36:09 <Cale> I wrote (a rather incomplete) Data.Bag in terms of Data.Map when implementing polynomials in multiple indeterminates.
09:37:04 <FunctorSalad> is there a pack already that takes an xml schema and generates haskell types from it?
09:37:26 <daf> http://hpaste.org/11690 -- if I use the other definition of readFoo, it prints "". what's going on?
09:37:43 <daf> (I don't want to just use readFile because then I run out of filehandles)
09:39:20 <yitz> daf: the old lazy IO problem
09:39:33 <Cale> Bags have a really nice monoid instance (disjoint union) which is exactly the monoid you need to get the ring of polynomials in many indeterminates from the monoid ring construction :)
09:39:43 <Cale> I should really put up my monoid ring code on Hackage :)
09:39:43 <daf> yitz: what's that?
09:40:03 <daf> yitz: is the file handle getting closed before the parse is evaluated or something?
09:40:04 <ski> Cale : monoid ring ?
09:40:12 <yitz> daf: that's my guess
09:40:55 <yitz> hGetContents uses unsafeInterleaveIO internally. They don't call it "unsafe" for nothin.
09:41:15 <Peaker> maybe "unsafe" should be a phantom-type-tag that propagates to all the functions somehow?
09:41:20 <ski> (hmpf)
09:41:23 <yitz> Peaker: heh
09:41:26 <vixey> Peaker: that would kind of defeat the purpose
09:41:32 <Peaker> I guess someone can use an unsafe something safely
09:41:39 <mauke> yeah, like getChar :: Unsafe Char!
09:41:56 <FunctorSalad> vixey: unsafeDeUnsafe :: Unsafe a -> a ? ;)
09:42:13 <Cale> ski: Yeah, start with a monoid, and another ring (the integers, or the reals will do), and form a new ring whose elements are functions from the monoid to the ring. Addition is elementwise, and multiplication goes like (f*g)(x) = sum over u,v such that uv = x of f(u)g(v)
09:42:26 <Peaker> hehe
09:42:32 * ski likes the `promise' idea in Mercury more than `unsafe' here
09:43:01 <Cale> Oh, I should probably say "with finite support"
09:43:06 <daf> so I need to force the IO somehow
09:43:17 <ski> Cale : interesting
09:43:23 <Cale> (otherwise you have to worry about convergence)
09:43:31 <Cale> For example, using the additive monoid of the naturals, and any other ring, you get the ring of polynomials.
09:44:24 <yitz> daf: if you force the IO monad, you'll get the whole file in memory at once. is that OK?
09:44:49 <daf> I suppose so
09:44:50 * Cale winces at "force the IO monad"
09:45:06 <daf> is there any middle ground between getting the whole file and none of it at all?
09:45:20 <ushdf> did you know the gnostics worshipped the monad
09:45:25 <Cale> daf: What is the problem here? Are you closing the filehandle too early?
09:45:33 <daf> Cale: apparently
09:45:37 <Cale> ushdf: Different monad, but yeah.
09:45:37 <daf> Cale: did you see the paste?
09:45:44 <vixey> daf, reading half of it? :)))
09:45:53 <Cale> daf: You're using readFile...
09:45:59 <Cale> daf: There shouldn't be a problem.
09:46:03 <daf> Cale: the readFile version works
09:46:08 <daf> Cale: the withFile version doesn't
09:46:18 <Cale> daf: oh, I didn't read that comment at first :)
09:46:40 <Cale> daf: Ah, yes, the problem is that withFile closes the filehandle.
09:46:41 <daf> Cale: I used readFile because I was doing mapM readFoo paths, and the handles weren't getting GC'd, so I was running out of file handles
09:46:57 <daf> er, I used withFile
09:46:58 <Cale> daf: If you use hGetContents, you *mustn't* close the filehandle explicitly.
09:47:18 <daf> and withFile counts, I guess
09:47:21 <Cale> yes.
09:47:37 <daf> I don't see a way of not closing the filehandle explicitly without running out of file handles then
09:47:42 <Cale> So one option is not to use hGetContents.
09:48:09 <Deewiant> daf: well, what you are doing in that mapM is exactly opening (length paths) file handles and leaving them open so that you can read from them lazily
09:48:13 <ski> (Cale : sometime i pondered whether one could make something interesting from a "family of monoids" `F' indexed by a monoid `M', such that given `x,y : M' we have `*_{x,y} : F x * F y -> F (x*y)', also we have `1 : F 1' ..)
09:48:18 <Cale> You could, for instance, use the (strict) ByteString version of hGetContents, which will slurp the whole file into memory.
09:48:21 <Deewiant> or s/lazily/later/ actually
09:48:30 <Deewiant> the fact that you're leaving them open is the lazy part
09:48:41 <daf> mmmm
09:48:56 <Cale> ski: hmm
09:50:05 <Cale> ski: That does look interesting :)
09:50:27 <ski> ok .. so you don't recognize it, then ?
09:50:44 <yitz> Cale: was your bag Ord a => Map a [a] ?
09:51:06 <Cale> yitz: Map a Integer
09:51:06 <daf> Deewiant: well, it seems that readFile is strict in opening the file, but lazy in reading it
09:51:25 <Deewiant> daf: yep, exactly
09:51:30 <daf> otherwise I imagine that I wouldn't have problems with running out of file descriptors
09:51:35 <Deewiant> hmm
09:51:37 <yitz> Cale; ok. because the Ord instance fully determined the element.
09:52:16 <Cale> yitz: Or else the Map won't even work correctly, yeah.
09:52:19 <alson_> @seen dons
09:52:20 <lambdabot> dons is in #haskell, #xmonad, #darcs, #ghc and #arch-haskell. I last heard dons speak 10m 57s ago.
09:52:31 <Deewiant> daf: so if you really don't need those files open, don't open them and just work with 'paths' (or read strictly)
09:52:34 <ski> (Cale : actually, i think i was thinking of a "family of groups" indexed by a group .. but i think one could start with monoids)
09:53:00 <daf> Deewiant: "just work with paths" → what does that imply?
09:53:09 <dons> alson_: ask away
09:53:14 <Deewiant> daf: open on demand, pass a FilePath around.
09:53:54 <alson_> dons: I'd like to send you a patch for hs-plugins, but I can't find a live darcs repo
09:54:02 <Deewiant> daf: it also occurred to me that you might be able to do something scary like use 'lazy . readFile', but I have no idea what that would change, if anything
09:54:06 <Cale> Hey, there's an idea. What if we wrapped an unsafeInterleaveIO around readFile? I wonder if many applications of readFile would work better that way.
09:54:06 <dons> the one on code.haskell.org is the live repo
09:54:11 <dons> unless it has been forked by someone...
09:54:22 <Cale> Heh, seems we're all thinking the same thing :)
09:54:31 <alson_> dons: it's for version 1.2
09:54:39 <alson_> last commit was in April
09:54:47 <alson_> hackage package is August
09:54:52 <Cale> That way, the file wouldn't get opened until the string started to be read.
09:54:53 <Deewiant> daf: or unsafeInterleaveIO, yeah. so it doesn't open anything until later.
09:55:34 <daf> Deewiant: mapM (print . readFoo) still exhausts the fds
09:55:48 <Deewiant> I didn't say 'print'. :-)
09:56:02 <Deewiant> I said 'lazy', and Cale said the more correct 'unsafeInterleaveIO'.
09:56:11 <daf> I'm still trying to understand your "open on demand" idea
09:56:34 <Deewiant> daf: well, what exactly are you doing
09:56:36 <Cale> You could still run out of fds if you used all the strings at once.
09:56:49 <ski> (it might be nice with `readFile' capturing a snapshot of the file at call .. but this is probably nontrivial, requiring support from OS with write-lock, or better, copy-on-write)
09:56:57 <Cale> daf: Try this, just for fun (probably don't actually want to do it this way)
09:57:06 <Cale> daf: import System.IO.Unsafe
09:57:09 <rwbarton> ski: What you were pondering is exactly Applicative.
09:57:15 <yitz> Cale, daf: yes, and that's an inherent limitation of this whole approach
09:57:25 <Cale> daf: and wrap the call to readFile in unsafeInterleaveIO
09:57:30 <daf> given that I'm done with the first string as soon as I've printed it, I don't see why it isn't collected
09:57:34 <ski> rwbarton : re the "family of monoids" ?
09:57:40 <daf> Cale: righto
09:57:53 <rwbarton> ski: Right.  Well, the symbols you wrote down describe Applicative anyways.
09:58:02 <Cale> daf: I'm just curious as to what will happen :)
09:58:07 <ski> rwbarton : hm .. how so ?
09:58:08 <yitz> If you need to read that many files and can't hold some of them in memory, you need to read only some of them and write out an intermediate result.
09:58:19 <yitz> ala sort
09:58:34 <rwbarton> ski: an applicative functor f is one with maps () -> f () and (f x, f y) -> f (x, y) (in haskell notation)
09:58:46 <rwbarton> ski: (this is an alternative description from the one in Control.Applicative)
09:59:08 <daf> Cale: it works
09:59:09 <ski> rwbarton : hm, i think i see what you mean .. however, in `*_{x,y} : F x * F y -> F (x*y)', the `*' in the `F x * F y' and the one in `F (x*y)' are supposed to be quite different things
09:59:12 <rwbarton> ski: so here your monoid M is all haskell types, I guess.
09:59:14 <Cale> daf: cool :)
09:59:36 <daf> Cale: that's useful and disappointing at the same time :)
09:59:40 <Cale> daf: Now it doesn't open the files until you actually use the strings.
09:59:48 <alson_> dons: though the code.haskell.org repo is for Version 1.2 (not Version 1.3), would you like me to send my patch there?
09:59:57 <Cale> daf: I've just made the lazy IO a bit lazier.
09:59:57 <ski> rwbarton : the first being a product of objects in the category in question (i.e. often cartesian product with some extra structure) .. while the latter was multiplication of monoid elements in the monoid `M'
10:00:17 <daf> Cale: nod
10:00:29 <yitz> Cale: all this unsafe stuff sends shivers up my spine. I would write that out manually.
10:00:39 <rwbarton> ski: OK, so Applicative is sort of a special case, the one where M happens to be the monoid of objects in your category, under *
10:00:42 <daf> I don't think I fully understand, still
10:00:52 <ski> rwbarton : so, i think one would need dependent types to express this .. (since `F x' would be at roughly the "same level" as `M')
10:00:54 <dons> alson_: mm. so gwern released a new version and i haven't seen the patches?
10:00:56 <rwbarton> ski: in general you have a "lax monoidal functor" between two monoidal categories
10:01:23 <daf> Cale: the problem with using readFile in the first place was not just that opening was too eager, but that closing was too lazy, no?
10:01:25 <alson_> dons: dunno.  Hackage lists version 1.3; code.has... lists version 1.2
10:01:30 <dons> looking...
10:01:40 <Cale> daf: unsafeInterleaveIO x takes an IO action x, and produces an IO action which when executed returns immediately a value which, when evaluated, will actually cause x to be executed and the result to be produced.
10:02:10 <dons> mmm. no , i uploaded 1.3
10:02:14 <Cale> daf: Yes, the problem here is that we have a bit of an impedance mismatch between lazy and strict IO.
10:02:21 <dons> ah. just haven't pushed.
10:02:23 <dons> alson_: pushing...
10:02:56 <ski> rwbarton : hm, i suppose that could make sense, treating `M' as a category .. but i wanted to treat it as an object
10:03:11 <Cale> daf: We were opening the files strictly, and only reading them lazily, so that if you close the handle, the lazy part of the IO fails altogether, and if you don't, you run out of filehandles, as the strict opens consume them all.
10:03:11 <dons> alson_: ok. done. should be up to date now.
10:03:19 <ski> (rwbarton : `lax' standing for ?)
10:03:27 <alson_> dons: gracias.  I'll add the patch and send it in a few
10:03:58 <Cale> daf: There are two things you can do to fix it. Either read the file strictly, after opening it strictly, or open the files lazily as well.
10:03:59 <rwbarton> ski: of course, in math that is no problem. :)  You're probably right about needing dependent types to do that in a haskell-like language.
10:04:29 <rwbarton> ski: lax as opposed to strong (where the map FX * FY -> F(X*Y) is an isomorphism)
10:04:36 <Cale> daf: We took the latter route, which is just a little more dangerous.
10:04:38 <ski> rwbarton : well, there can still be problems with size (small,locally small categories .. quasi-categories, et.c.)
10:05:13 <ski> rwbarton : so `lax' just is an emphasis that we don't require strength ?
10:05:19 <Cale> daf: For the former, well, I could give you a strictified version of hGetContents, but there's already a very nice one in the Data.ByteString library.
10:05:54 <rwbarton> ski: well, yes, except "strength" has a second meaning in this context as well (I think a map X * FY -> F(X*Y))
10:06:14 <ski> ah, as in monadic strength, yes
10:06:17 <daf> Cale: what I'm struggling with is that I expected (mapM (print . readFoo) ps) to be evaluated like { readFile p1 >>= print; readFile p2 >>= print; ... }
10:06:17 <rwbarton> right
10:06:37 <ski> (obviously "strength" is a bad name)
10:06:49 <orgthingy> how's haskell with vim?
10:06:56 <orgthingy> any nice features/addons that help?
10:07:38 <daf> Cale: whereas instead it seems to be { h1 <- openFile p1; s1 <- hGetContents h1; print s1; h2 <- openFile p2; ...; hClose h1; hClose h2; ... }
10:07:42 <FunctorSalad> 'strong' is a generic name as in 'every strong foo is a weak foo' I think
10:07:47 <orgthingy> Cale is here ^_^
10:07:49 <Cale> daf: hmm
10:07:53 <orgthingy> Cale : hello :D
10:07:58 <Cale> orgthingy: :set expandtab  for one
10:08:01 <ski> (rwbarton : i was thinking of including `M' in this category of such families, or somesuch .. don't remember details)
10:08:11 <ski> (er, including `Mon' i mean)
10:08:19 <Cale> orgthingy: There's a haskell syntax highlighter, which I believe should come with vim anyway
10:08:41 <Cale> daf: hmm
10:08:42 <Deewiant> orgthingy: the one that comes with vim isn't the best one
10:08:51 <Deewiant> there's another on vim.org
10:09:13 <Cale> daf: Well, which version of readFoo are you talking about?
10:09:16 <ski> this one <http://www.vim.org/scripts/script.php?script_id=1968> ?
10:09:22 <orgthingy> thanks ^_^
10:09:34 <Deewiant> no, I don't think it's that one actually
10:09:40 <daf> Cale: parseFoo `fmap` readFile
10:09:49 <Deewiant> orgthingy: http://www.vim.org/scripts/script.php?script_id=2062
10:09:50 <lambdabot> Title: haskell.vim - Syntax file for Haskell : vim online
10:10:01 * ski doesn't use vim, so doesn't know
10:10:13 <Cale> daf: There's also a problem that readFile gives you a string which, when it's GC'd is supposed to close the fd, but it's never 100% certain about when that will be.
10:10:48 <daf> Cale: so it might just be down to GC behaving a little unexpectedly?
10:10:51 <Cale> daf: So maybe some of the filehandles get closed in between there, and others never get closed, and so on... it depends on how often the GC runs...
10:10:54 <Cale> yeah
10:11:04 <Cale> Which is why lazy IO is difficult with many files.
10:11:13 <daf> nod
10:11:15 <FunctorSalad> daf: just jumping into the discussion but if you need more control, you could read the file with hGetChar or hGetLine?
10:11:17 <Cale> It's best applied when you have one big file.
10:11:24 <rwbarton> The file handle should also get closed when you force the [] at the end of the string, right?
10:12:34 <Deewiant> rwbarton: isn't it just marked as 'can be closed' and the GC'll close it when it feels like it
10:12:36 <Cale> rwbarton: Hmm... it's true that ought to be the case.
10:12:52 <daf> I think for now I can just take the hit of making all the reads strict
10:13:12 <Cale> daf: Yes, that's probably the safest thing.
10:13:15 <rwbarton> Deewiant: No, I think the unsafeInterleaveIO'd code sees to it that the file is closed whenever it returns [].
10:13:17 <daf> if that's too memory heavy, I can defer some of the reads later
10:13:28 <daf> much as yitz suggested
10:13:35 <Deewiant> rwbarton: If that's the case, cool
10:13:41 <Deewiant> I'll take your word for it :-)
10:13:47 <Cale> daf: import qualified Data.ByteString.Char8 as BS, and then use BS.hGetContents (and possibly  BS.unpack)
10:14:14 <daf> Cale: right :)
10:14:25 <daf> Cale: I did it with strings initially because I was lazy
10:14:47 <Cale> daf: Yeah, it's unfortunate that I don't have a better answer for you :)
10:14:49 <daf> rwbarton: surely if that's the case, I shouldn't be seeing file exhaustion
10:14:53 <Deewiant> BS.unpack . BS.hGetContents is probably faster than a plain hGetContents
10:15:23 <daf> Cale: shrug. I still feel like I'm winning big by using Haskell in the first place
10:15:27 <daf> Cale: thanks for the help :)
10:15:42 <Cale> daf: This whole lazy vs. strict IO thing still hasn't completely worked itself out. Lazy IO is really convenient for a lot of tasks, but seems to fail in specific areas, and I'm not sure it's necessary that it should.
10:16:10 <Cale> Of course, if it were up to me, there just wouldn't be any limitation on filehandles.
10:16:24 <daf> is this the kind of thing that the left fold enumerators are tryingg to tackle?
10:16:37 <Cale> Maybe, I don't really know a whole lot about those.
10:16:40 <daf> yeah. silly unix.
10:16:52 <Cale> But given that there is a limitation, it seems like something which the runtime system should be keeping track of.
10:16:57 <Deewiant> I honestly wonder why that limitation hasn't been lifted
10:17:13 <Deewiant> Is there an actually good reason for it?
10:17:37 <Cale> (and making sure to, say, force a GC/used-up-filehandle closing when the limit is reached)
10:17:46 <daf> Cale: hmm, that would make sense
10:17:47 <Cale> Deewiant: I can't think of one myself.
10:18:10 <daf> perhaps some concern that a poorly written program can DoS the system
10:18:16 <daf> but surely file handles aren't that expensive
10:18:46 <Deewiant> A poorly written program can DoS the system in a dozen other ways
10:19:01 <Deewiant> If that's a problem, it should be a ulimit setting
10:19:15 <Deewiant> Hmm, I guess it is anyway now that I think of it actually
10:19:26 <Deewiant> But there's another limit on top of that, in any case.
10:19:27 <idnar> yes, it is
10:20:04 <Cale> Do filehandles really use *that* much memory? Can't the memory for the filehandles just be considered part of the process memory?
10:20:24 <idnar> I believe /proc/sys/fs/file-max is the system-wide maximum
10:20:40 <idnar> Cale: I think it's more that they require in-kernel structures backing them
10:20:57 <idnar> which aren't tied to a particular process, since you can pass file handles around
10:21:39 <idnar> I think you can raise the limit arbitrarily, though
10:21:40 <Cale> idnar: Sure, but the kernel could just include those structures as part of its size count for the process.
10:21:43 <daf> so they are like shared memory
10:21:58 <Cale> (whoever opens them gets the blame)
10:22:25 <Cale> and keep the number of such structures otherwise unlimited.
10:23:04 <yitz> Cale: this sounds like to easy an idea to have not been done. If any of our OS people were around, they would probably blast us out of the water.
10:23:13 <yitz> s/to/too/
10:23:41 <Deewiant> yitz: Exactly, and I'd like to know /why/.
10:23:41 <Cale> yitz: I think C programmers think differently from Haskell programmers though. I see a lot of arbitrary limits in programs just because it's easier to do things that way in C.
10:23:54 * yitz nods
10:24:09 <idnar> heh
10:24:11 <Deewiant> It's not even a definable limit when you build the kernel, or is it?
10:24:18 <vixey> and those limits tend to be powers of two because C programmers think in BINARY
10:24:19 <Deewiant> What does it depend on?
10:24:20 <idnar> Deewiant: it's definable at runtime, as far as I know
10:25:06 <idnar> on Linux, anyway
10:25:11 <idnar> echo 1234567 > /proc/sys/fs/file-max
10:25:42 <Deewiant> hmm, but you can't set it to unbounded
10:25:43 <yitz> idnar: I don't suppose that uses gmp.
10:26:04 <idnar> yitz: heh, I'm not sure what the upper limit on that value is
10:26:19 <idnar> possible integer word size or whatever, which is plenty on a 64-bit system
10:26:41 <idnar> but even 2147483648 file handles is a *lot*
10:26:54 <idnar> given that the limit on my system seems to be 151945 by default
10:27:37 <idnar> I think a lot of arbitrary limits happen because, as you say, it's easier to do things that way in C
10:27:44 <idnar> but the excuse given is probably that it's more efficient that way
10:27:57 <Deewiant> of course it is
10:28:01 <vixey> haskell is not without arbitrary limits
10:28:02 <Deewiant> but does it make a difference is the question :-P
10:28:03 <vixey> :t length
10:28:04 <lambdabot> forall a. [a] -> Int
10:28:06 <idnar> the problem is that arguments like that are rarely backed up by benchmarks or some other kind of measured impact
10:28:07 <Deewiant> :t genericLength
10:28:09 <lambdabot> forall b i. (Num i) => [b] -> i
10:28:16 <vixey> no list has a length longer than 255 or whatever
10:28:24 <rwbarton> I think there's typically a pretty low limit on kernel memory space, for reasons I don't know
10:28:28 <idnar> > maxBound :: Int
10:28:29 <lambdabot>   9223372036854775807
10:28:30 <Deewiant> Int is defined to go up to at least 2^29-1, I think
10:28:39 <vixey> whatever.
10:28:39 <rwbarton> and filehandles have to store some data in kernel space
10:28:47 <idnar> is it even possible for a list to be longer than maxBound :: Int?
10:28:55 <mauke> cycle "yes"
10:28:59 <Deewiant> vixey: and, in practice, no list has a length longer than that. ;-)
10:29:16 <idnar> mauke: length applied to that is bottom, so that's fine ;)
10:29:22 <vixey> idnar, I'm saying the _length_ of the list cannot be bigger than that, the defintion of length doesn't fit with our conception of length
10:29:44 <trhj1> Why does Haskell require me to write `f (g a)' or `f $ g a' when it'd be more simple to just write `f g a' ?
10:29:45 <peachi> Hey all. I've installed Hugs using MacPorts on Mac OS X Leopard. Everything's fine but for my homework this week we are given a file that has "import Graphics.HGL" in it, and although it works in the labs I get the following error message from the import:   ERROR "/opt/local/lib/hugs/packages/HGL/Graphics/HGL/Internals/Types.hs" - Can't find imported module "Graphics.X11.Xlib"
10:30:02 <geezusfreeek> trhj1: f g a == (f g) a
10:30:05 <idnar> but I suppose since your list is lazily evaluated, it can be arbitrarily long
10:30:11 <vixey> trhj1, that one program would get simpler, but what about all the others?
10:30:49 <Deewiant> trhj1: much more often one wants 'f g a' to mean just '(f g) a'
10:30:58 <idnar> trhj1: if you could write f g a, then f a b wouldn't work
10:31:03 <ski> trhj1 : how about `foldr (.) id [cos,sin,tan] pi' ?
10:31:28 <Deewiant> trhj1: for instance, '1 + 1' would preferably mean '((+) 1) 1' and not '(+) (1 1)' ;-)
10:31:32 <vixey> @let compose = foldr (.) id
10:31:33 <lambdabot>  Defined.
10:31:54 <idnar> @type sequence [cos,sin,tan]
10:31:56 <lambdabot> forall a. (Floating a) => a -> [a]
10:32:01 <idnar> > sequence [cos,sin,tan] pi
10:32:03 <lambdabot>   [-1.0,1.2246467991473532e-16,-1.2246467991473532e-16]
10:32:04 <ski> (.. or replace `pi' with `pi/2')
10:32:15 <idnar> oh, no
10:33:14 <trhj1> how many args function takes & their types is clear from definition
10:33:27 <daf> peachi: I'd guess you need to install the X11 package
10:33:29 <yitz> random googling yields a folklore heuristic of setting file-max to 64 files/Mb RAM. Don't know why.
10:33:44 <Deewiant> I'm sure somebody can think of an example where 'f a b' and 'f (a b)' both type-check
10:33:44 <ski> trhj1 : even if you would argue that you know the "arity" of functions, there can be cases like the above where the function call actually returns a value that happens to be a function .. how would you write the application of that function to something ?
10:33:49 <rwbarton> trhj1: No, it's not
10:33:49 <Deewiant> (an example which doesn't use undefined)
10:33:50 <daf> peachi: though it's not clear to me that that will work on OS X
10:34:25 <ski> trhj1 : usually one says that `foldr' take 3 arguments (curried) .. how many arguments did i pass to `foldr' above ?
10:34:46 <Peaker> f :: Monad f => f -> Int -> Int  ;  a :: (Int -> Int)   b :: Int       I think that works out
10:34:52 <ski> @type foldr
10:34:53 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:35:01 <Peaker> (not that its very interesting ;)
10:35:10 <ushdf> :t foldr
10:35:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:35:13 <rwbarton> trhj1: Also, it would mean you would need to see the definition of f to know what f g h means
10:35:14 <ushdf> :t foldl
10:35:15 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:35:32 <ski> Peaker : er .. wouldn't `f :: *', there ?
10:35:42 <ushdf> f = g+h
10:35:43 <ushdf> ?
10:35:52 <ushdf> or f = g head plus h head
10:36:07 <trhj1> you're all right. thx
10:36:57 <Peaker> ski: Yeah, oops, I guess "f Int" then
10:37:22 <peachi> daf, thanks, I'll look into installing X11 on OS X
10:38:38 <peachi> hmm, apparently X11 is installed on Leopard by default... ?
10:38:41 <peachi> anyone got any other ideas?
10:39:41 <daf> peachi: "ghc-pkg list" will tell you if it's installed
10:40:11 <rwbarton> peachi: You need both X11 the application, and X11 the haskell library.
10:42:20 <Cale> Deewiant: I'm pretty sure that any such case would use typeclasses though.
10:42:38 <rwbarton> @type (?f ?a ?b, ?f (?a ?b))
10:42:39 <lambdabot> Top level:
10:42:39 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
10:42:39 <lambdabot>       Expected type: t
10:42:49 <Cale> (a case where both f a b and f (a b) typecheck)
10:43:31 <Deewiant> > (id (+1) 1, id ((+1) 1))
10:43:33 <lambdabot>   (2,2)
10:43:49 <Deewiant> but that's uninteresting since they give the same result
10:43:50 <Cale> Heh, I suppose id works.
10:44:19 <Cale> But yeah...
10:44:26 <Cale> id is almost as boring as undefined
10:45:29 <vixey> I think there are some sets of combinators that are trivial.. but you add 'id' and suddenly it's turing complete
10:45:35 <Deewiant> :-)
10:46:23 <Cale> vixey: Is this because they have parameters which can't be filled in unless you have id?
10:46:42 <vixey> I can't remember :(
10:46:55 <vixey> this is my vauge recollection of something from To Mock a Mockingbird
10:47:30 <Cale> ah, those birds are untyped though, so that can't quite be it...
10:47:39 <Deewiant> http://www.angelfire.com/tx4/cus/combinator/birds.html works well without any I's
10:47:44 <lambdabot> Title: Combinator Birds
10:48:00 <Cale> Well, if you have K and S of course you can make I
10:48:32 <Deewiant> and still, it's not used :-)
10:49:27 <Cale> The last column seems overparenthesised.
10:49:49 <Deewiant> Might be machine-generated
10:49:55 * ski blinks
10:50:15 <vixey> hiya shapr
10:50:48 <vixey> Cale, yeah the book is untyped.. every approach I had for these problems was rendered useless because of that :p
10:50:49 <Cale> and the first column seems to be missing terms for W and Q :)
10:51:26 <Cale> (or omega and theta)
10:54:08 <Cale> I just love how audacious freezes completely when one of the songs in its playlist goes missing.
10:58:14 <LegendaryPenguin> im using visual studio 2008, is there a way to say, take every file in the project, all settings, and export it to some other location
10:58:34 <LegendaryPenguin> i ended up adding existing files, and it seems to have simply pointed to their locations, rather than create unique copies
10:58:46 <LegendaryPenguin> oh wrn channel
11:00:30 <alson_> @seen dons
11:00:31 <lambdabot> dons is in #haskell, #xmonad, #darcs, #ghc and #arch-haskell. I last heard dons speak 27s ago.
11:00:41 <alson_> dons: does plugins 1.3 work with GHC 6.8?
11:01:24 <dons> alson_: i believe so
11:02:14 <alson_> dons: i'm getting some weird Cabal 1.4 "symbol missing" when I load a file dynamically.  probably an error on my part (though I'm not sure what changed.  things were working fine before i updated Cabal and Plugins)
11:02:58 <Cale> alson_: Plugins seems incapable of locating things in packages installed as user.
11:03:00 <alson_> dons: this is what I'm getting on a load : " /usr/local/lib/plugins-1.3/ghc-6.8.2/HSplugins-1.3.o: unknown symbol `Cabalzm1zi4zi0zi2_DistributionziInstalledPackageInfo_InstalledPackageInfo_con_info"
11:03:23 <alson_> dons: and "unloadObj: can't find `/usr/local/lib/Cabal-1.4.0.2/ghc-6.8.2/HSCabal-1.4.0.2.o' to unload"
11:03:29 <Cale> (this is one of the problems which seemed to justify the move to using hint/mueval in lambdabot)
11:03:38 <alson_> cale: both are installed in system dirs
11:03:41 <Cale> hmm
11:03:48 <Cale> I'm not sure in that case.
11:04:54 <shapr> hiya vixey !
11:05:15 <Baughn> Cale: Have you gotten \bot to compile on 6.10 yet?
11:05:24 <Cale> Baughn: I haven't tried.
11:05:47 <Baughn> @hoogle pure
11:05:47 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
11:05:47 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
11:05:47 <lambdabot> package pureMD5
11:06:29 <Baughn> package..?
11:06:30 <Cale> Baughn: are there issues?
11:06:32 <Baughn> @hoogle binary
11:06:32 <lambdabot> package binary
11:06:32 <lambdabot> package binary-search
11:06:32 <lambdabot> package binary-strict
11:06:50 <Cale> Baughn: I suspect we might have to wait for hint etc. to get straightened away.
11:06:56 <Baughn> Cale: I don't know yet. Someone renamed Control.Arrow.pure, so I have to fix that package first
11:07:05 <Baughn> (Or rather, fix the arrow package)
11:07:20 <Cale> Is it arr now?
11:07:23 <Baughn> Yes
11:07:37 <Deewiant> arr!
11:07:42 <Deewiant> @arr
11:07:43 <lambdabot> I'll keel haul ya fer that!
11:08:28 <Baughn> Cale: Oh, and there's a bug in the base-3.0.3.0 package, in that it's still renamed
11:11:10 <Baughn> Cale: The fun thing is, it only fails because it's explicitly hiding pure in an import statement
11:11:22 <Cale> hehe
11:11:51 <Baughn> ..hey, wait a minute
11:12:04 <Baughn> Why is the hackage version newer than the darcs version? -_-;
11:13:44 <Baughn> @hoogle (>>>)
11:13:44 <lambdabot> Control.Arrow (>>>) :: Arrow a => a b c -> a c d -> a b d
11:14:15 <mofmog> > arr (\x -> x+2) >>> arr (\x -> x+3)
11:14:16 <lambdabot>       No instance for (Show (a b b))
11:14:16 <lambdabot>        arising from a use of `show' at <...
11:14:43 <Baughn> Cale: ..right. Fixing this would require me to actually /understand/ arrows, as well as apparently category theory
11:14:46 <Baughn> ..later.
11:14:54 <Peaker> When a thread uses a blocking call (that is not on a select'able file descriptor), does the runtime block that entire physical thread?
11:14:56 <Cale> Baughn: What's going on?
11:15:05 <Cale> Baughn: You're noticing the Control.Category split?
11:15:45 <mofmog> > idA 3
11:15:46 <lambdabot>   Not in scope: `idA'
11:15:46 <Cale> Baughn: In the original Control.Arrow, arr and pure were synonyms.
11:15:59 <Cale> Baughn: (just because different papers used different notation)
11:16:02 <Baughn> Cale: Page me when someone writes a tutorial. ;_;
11:16:20 <Cale> I think some people ended up complaining because pure is also used in Control.Applicative, with an incompatible type.
11:16:24 <malcster> can anyone help me with installing happy? I can't appear to install it using cabal-install because it appears to depend on itself, and I'm not sure how to bootstrap it
11:16:44 <Baughn> malcster: You need to preprocess the appropriate files on a computer that already has happy installed
11:16:48 <Baughn> No, I don't understand it either
11:16:49 <alson_> dons: looks as though the issue is that Cabal 1.2.3 and Cabal 1.4.0 are linked in because of dependencies from GHC and from Plugins (respectively)
11:16:52 <Cale> They also recently decided to add a Control.Category... I'm not sure if the composition operation ended up being named (>>>) or (.)
11:16:58 <Baughn> malcster: Hang on a minute
11:17:08 <alson_> dons: looks as though that's causing some run-time confusion
11:17:38 <malcster> i found some mention on a bug tracking list that you can fix this by installing a previous version of happy which doesn't have this circular dependency, but I got a bunch of errors with all the previous versions as well
11:18:08 <Cale> malcster: What OS are you running? Happy might be available as a package for it.
11:18:14 <malcster> mac os x
11:18:17 <Cale> hmm
11:18:20 <malcster> yeah I tried using macports
11:18:22 <malcster> different error there
11:18:37 <malcster> Command output:
11:18:38 <malcster> Setup.lhs:30:43: Not in scope: `buildVerbose'
11:19:09 <alson_> dons: Plugins 1.3 requires Cabal >= 1.4, but it also request GHC >= 6.8.  GHC 6.8 depends on Cabal 1.2.3 (or my Debian package does)
11:19:11 <mofmog> > arr (\x -> x+2) >>> (\x -> x*100) $ 10
11:19:13 <lambdabot>   1200
11:19:18 <Baughn> malcster: http://brage.info/~svein/happy.tar.gz <-- Try this one. I can't guarantee it'll build (doesn't for me, but that may be 6.10 weirdness).
11:19:28 <alson_> dons: request -> requires
11:19:54 <malcster> okay thanks. what do I want to do with that, the manual "runhaskell setup.lhs configure/build/install" thing?
11:20:05 <Cale> It seems pretty unnecessary for a parser generator to depend on itself...
11:20:13 <Baughn> malcster: cabal install
11:20:25 <malcster> okay, i'll give that a shot. thanks.
11:20:32 <Baughn> malcster: Of course you need cabal-install installed first. It comes with a bootstrap script.
11:20:44 <dcoutts> Cale: you're talking about the current happy packages? that's a packaging mistake that'll be corrected
11:20:46 <malcster> i have caball-install
11:20:52 <Cale> dcoutts: oh?
11:21:11 <Cale> dcoutts: Can it be solved by removing the depencency from the .cabal file?
11:21:14 <Peaker> are read/write/etc special-cased to context-switch and register to the reactor, rather than blocking? if so, what happens to Haskell's M:N threading when a thread blocks on something else?
11:21:19 <malcster> that's what i gathered from the bug tracker, but the suggested fix of installing a previous version didn't work
11:21:45 <peachi> if I have the X11 application on Leopard, how do I install the X11 haskell library?
11:21:47 <Baughn> Peaker: All the blocking primitives in GHC call into the reactor/io core
11:21:47 <peachi> is there some command?
11:21:58 <Peaker> Baughn: what about non-fd stuff?
11:21:59 <Baughn> Peaker: FFI calls do not. If there's a risk they'll block, you'll want to use forkOS
11:21:59 <dcoutts> Cale: I don't recall there being such a dep in the .cabal file. I think the person who generated it didn't configure first, so it didn't include the pre-processed files into the tarball.
11:22:05 <Baughn> Peaker: *All*.
11:22:07 <Cale> dcoutts: ah
11:22:09 <malcster> okay the compile is getting further than it did before, this is promising
11:22:13 <Peaker> @type forkOS
11:22:14 <lambdabot> Not in scope: `forkOS'
11:22:20 <Peaker> Baughn: basically fork() ?
11:22:31 <Baughn> Peaker: No, forkOS is pthread_create
11:22:35 <Peaker> Baughn: oh, ok
11:22:38 <Baughn> Peaker: In Control.Concurrent
11:22:42 <dcoutts> Cale: cabal sdist from clean cannot run pre-processors, it warns about it, suggesting that one run configure first.
11:23:06 <Peaker> Baughn: thanks
11:23:08 <alson_> Cale: do you know if a program can link multiple versions of Cabal?  or is it one version per program...
11:23:12 <Baughn> Peaker: Oh, and forkOS creates a bound thread, too. That thread will /only/ run that particular haskell thread, which is useful for libraries wth thread-local state. (opengl!)
11:23:29 <Cale> alson_: My bet would be on one per program.
11:23:31 <dcoutts> alson_: linking multiple versions should be fine
11:23:36 <Cale> oh?
11:23:39 <dcoutts> if it compiles
11:23:46 <dcoutts> then it'll link fine
11:24:02 <Cale> ah, okay
11:24:22 <peachi> anyone?
11:24:23 <Cale> I'm not sure how you'd refer in your Haskell code to different versions of the modules.
11:24:30 <dcoutts> ghci-6.8.2 -package Cabal-1.4.0.2 -package Cabal-1.6.0.1
11:24:32 <dcoutts> works fine
11:24:39 <Cale> peachi: hmm...
11:24:40 <malcster> okay that's made a binary. thanks. it's put it in a local dir, I take it I can just copy that binary to the system dir where cabal normally puts binaries? it's totally self contained?
11:24:52 <dcoutts> though yes, you can only have one in scope at once
11:24:53 <Baughn> malcster: Sorry, it's not at all self-contained
11:25:02 <Cale> peachi: cabal install X11  ?
11:25:16 <Peaker> Baughn: intewesting
11:25:16 <peachi> Cale, I'm getting an error in Hugs that says it can't find Graphics.X11.Xlib
11:25:16 <Baughn> malcster: That is to say, it'll only work for the user that builds it
11:25:20 <malcster> ok. but if I add that directory to my path, and try and install happy with cabal-install again, that should work?
11:25:33 <Baughn> malcster: Alternately, you can use cabal install --global --root-cmd=sudo to get it installed globally
11:25:51 <Baughn> malcster: Well, you /can/ move it around inside your homedir, just so long as only you try to run it
11:25:52 <alson_> dcoutts: yeah.  the build seems to go fine, but when the program tries to "load" (plugins), it barfs with "/usr/local/lib/plugins-1.3/ghc-6.8.2/HSplugins-1.3.o: unknown symbol `Cabalzm1zi4zi0zi2_DistributionziInstalledPackageInfo_InstalledPackageInfo_con_info".
11:26:19 <Baughn> malcster: cabal also has a method to stick symlinks in a directory of your desire, like ~/bin. Read ~/.cabal/config sometime
11:26:20 <dcoutts> alson_: ah, unknown is quite different
11:26:31 <malcster> okay, thanks
11:27:02 <alson_> dcoutts: any further hints on "unknown"?
11:27:24 <Cale> peachi: hmm... I'm not sure what to do about missing hugs packages, since I don't really use hugs. You might try cabal install --hugs X11
11:27:33 <dcoutts> alson_: that's usually when packages have been built inconsistently, eg building and then rebuilding a dependency
11:27:49 <peachi> Cale, sorry where do I type cabal?
11:27:56 <dcoutts> alson_: so I suggest rebuilding plugins from clean
11:28:04 <peachi> Terminal says it is not an app
11:28:07 <Cale> peachi: At the commandline, supposing that you have cabal-install installed.
11:28:12 <Cale> ah
11:28:13 <alson_> dcoutts: I'll try again, but I think I've done that...
11:28:15 <peachi> don't think I do >_<
11:28:16 <peachi> heh
11:28:35 <Cale> peachi: Is it necessary to use hugs?
11:28:57 <Cale> peachi: I have a feeling this process will be simpler with GHC, though we can try it with hugs if needs-be...
11:29:01 <peachi> Cale, I need Graphics.X11 for my homework basically
11:29:23 <peachi> sorry, yeah, we're using Hugs in labs so I kind of want to stick to it
11:29:28 <peachi> although I have heard of GHC
11:31:12 <Cale> dcoutts: Will cabal-install work using hugs, or should it itself be compiled using GHC?
11:31:12 <malcster> Baughn: okay I think I have everything setup properly. many thanks for your help!
11:31:39 <dcoutts> Cale: I recommend building cabal-install with ghc, but using it with hugs should be fine (though it cannot track deps)
11:31:54 <dcoutts> Cale: ie cabal install --hugs X11 should work
11:32:08 <dcoutts> though I do not test much with hugs :-)
11:32:09 <Cale> okay, cool
11:32:38 <dcoutts> Cale: but ndm has reported bugs with hugs occasionally which I've mostly fixed, so I assume he'd tell me if it was totally borked
11:33:40 <Cale> Hmm, I suppose another option is to skip the whole process and try manually installing the X11 package for hugs.
11:34:23 <Cale> peachi: I guess there are two ways we can do this: try manually installing the X11 package for hugs, or install GHC and cabal-install, at which point installing the X11 pacakge becomes a single command.
11:34:36 <Cale> (which hopefully works ;)
11:35:26 <Cale> peachi: If you're interested in using Haskell beyond doing homework exercises, I'd recommend getting GHC and cabal-install anyway :)
11:35:43 <peachi> Cale, how do you install cabal?
11:35:52 <Deewiant> start with GHC
11:35:59 <olsner> cabal install cabal-install :)
11:36:00 <peachi> all I can find is cabal-install, which seems to require cabal in the first place, heh
11:36:05 <peachi> >_<
11:36:10 <Cale> peachi: There's a script which bootstraps it.
11:36:32 <Cale> peachi: http://hackage.haskell.org/packages/archive/cabal-install/0.6.0/cabal-install-0.6.0.tar.gz
11:36:33 <lambdabot> http://tinyurl.com/6gcmrq
11:36:35 <dcoutts> peachi: the Cabal package is the library, the cabal-install package provides the command line tool 'cabal'
11:37:00 <Cale> inside that package, you should find a bootstrap.sh, which when run from the commandline will download and install necessary components to get it up and running.
11:37:23 <peachi> Cale, thanks :)
11:39:21 <peachi> am I just supposed to do ./bootstrap.sh
11:39:21 <peachi> ?
11:39:35 <Raynes> I'm guessing there isnt an option for windows users.
11:39:36 <Cale> yeah
11:39:44 <Cale> Raynes: hm?
11:39:56 <peachi> -bash: ./bootstrap.sh: Permission denied
11:39:59 <Cale> Raynes: oh, for installing cabal-install?
11:40:03 <unenough> I want to write a visual graph editing program in haskell
11:40:05 <Raynes> Yeah.
11:40:06 <peachi> I think I'm an idiot :/
11:40:07 <unenough> A. does one exist already?
11:40:15 <Cale> peachi: oh, hmm,  chmod +x bootstrap.sh  first
11:40:20 <peachi> thanks
11:40:20 <unenough> B. what framework would you suggest? it won't do with 'normal' widgets
11:40:21 <jsn> peachi:    chmod ug+x ./bootstrap.h
11:40:26 <Cale> peachi: It should have preserved permissions, but...
11:40:27 <jsn> oops
11:40:35 <jsn> peachi:    chmod ug+x ./bootstrap.sh
11:40:41 <peachi> thanks guys
11:41:06 <Cale> unenough: There was something written like that for wxHaskell, but I'm not sure how well-maintained it is.
11:41:59 <Cale> unenough: If I was starting out on writing my own, I'd be tempted to use Gtk2Hs and its support for Cairo.
11:42:17 <unenough> hm
11:42:41 <unenough> here, there is this http://www.cs.york.ac.uk/fp/darcs/Blobs/
11:42:43 <lambdabot> Title: Blobs diagram editor
11:43:36 <Cale> Yeah, I think that's what I was thinking of.
11:43:49 <Peaker> maybe it could use "dot" for nicer graph layout algorithms
11:44:01 <Peaker> (its graph layout doesn't seem that great)
11:44:09 <Peaker> lots of arrow cross-over
11:44:53 <unenough> btw, i once tried finding the actual algorithms the use in dot, it's so obfuscated in their papers and even more in the code!
11:45:13 <vixey> the implementation is really awful
11:45:26 <Peaker> vixey: of dot?
11:45:49 <unenough> they would do a great service to humanity if they'd just publish the algorithm , even in pseudocode or whatever
11:46:08 <Peaker> unenough: I'm sure with a bit of effort graphviz can be read
11:46:16 <unenough> a lot of effort
11:46:17 <unenough> the code suck
11:46:18 <unenough> s
11:49:23 <peachi> Cale, there are commands in bootstrap.sh that start with 'runghc', 'ghc', etc.
11:49:31 <peachi> and I'm trying to get cabal for hugs :/
11:49:47 <peachi> cabal-install*
11:51:09 <pejo> I'd like to write about the RTS. Is it "run-time" or "runtime"? :-)
11:51:53 <Cale> peachi: Right, you must install ghc for cabal-install. But cabal-install can install hugs packages.
11:52:02 <peachi> heh, ok
11:52:06 <Cale> peachi: Which is why I said to get GHC first :]
11:52:08 <peachi> I'll just bite the bullet and get ghc :P
11:52:22 <Cale> There's a binary package for Leopard on Intel.
11:52:35 <peachi> Cale, thanks, I'm downloading it now :)
11:54:42 <jsn> pejo: i believe the latter is preferred
11:55:21 <hukolele> im having this error under ghci for windows: Loading package curl-1.3.2.1 ... can't load .so/.DLL for: curl (addDLL: unknown error)
11:55:28 <hukolele> where do ghci search for .dlls?
11:55:46 <Deewiant> hukolele: look at ghc-pkg describe curl, in particular the 'ghci-libraries' field
11:55:50 <Deewiant> and fix it manually using ghc-pkg update
11:56:05 <hukolele> ok, ill try, thx
11:56:06 <Deewiant> just another days developing on windows...
11:56:15 <Deewiant> s/days/day/
11:58:08 <peachi> well I'm off; thanks for all the help, Cale!
12:13:07 <alexsuraci> Would (reverse (1 : 2 : 3 : 4 : [])) be more efficient than [1] ++ [2] ++ [3] ++ [4]?
12:13:15 <alexsuraci> (semi-ridiculous example)
12:13:33 <alexsuraci> er, I meant [4] ++ [3] ++ [2] ++ [1] there
12:13:44 <Deewiant> it would be more efficient if you parenthesize the ++ left-associatively
12:13:59 <Deewiant> if you parenthesize it right-associatively, probably not
12:14:29 <alexsuraci> Like ((([4] ++ [3]) ++ [2]) ++ [1])?
12:14:34 <Deewiant> yeah
12:14:41 <alexsuraci> I wouldn't be able to do that in this situation since I'm dynamically generating the list, though
12:14:43 <Deewiant> that's "definitely" slower
12:14:46 <pejo> Aren't appends of statically known lists transformed away at compile time?
12:14:54 <Deewiant> pejo: I'm assuming they aren't ;-P
12:15:10 <alexsuraci> (I'm practicing by implementing split :P)
12:15:17 <alexsuraci> I'll paste both forms
12:15:18 <Deewiant> alexsuraci: well, you can tell which way it goes from how you're doing it
12:15:18 <dmwit> alexsuraci: Prepend is considerably faster than append, if that's what you're asking.
12:15:18 <vixey> > (reverse (1 : 2 : 3 : 4 : []), [1] ++ [2] ++ [3] ++ [4])
12:15:19 <lambdabot>   ([4,3,2,1],[1,2,3,4])
12:15:38 <vixey> what is split?
12:15:40 <dmwit> alexsuraci: Note that the (++) one you wrote originally could be either a prepend or an append, depending on the associativity of (++) you use.
12:15:47 <Deewiant> alexsuraci: for instance, if you start from [], then append [4], append [3] to that, etc.
12:15:53 <dmwit> (By default, (++) is probably r-assoc, so what you wrote would be fine.)
12:16:11 <dmwit> :t split
12:16:12 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
12:16:22 <dmwit> vixey: It lets you start two "independent" random streams.
12:16:25 <vixey> (asking alexsuraci)
12:16:34 <dmwit> oh
12:16:42 <alexsuraci> http://paste.pocoo.org/show/0KABG7Q0jSib502I5A4H/
12:16:51 <vixey> I'm guessing something to do with lists
12:16:58 <alexsuraci> probably not very efficient at all, I'm just practicing here :P
12:17:01 <alexsuraci> vixey: Yep
12:17:05 <dmwit> :t splitBy -- vixey, maybe this?
12:17:06 <lambdabot> Not in scope: `splitBy'
12:17:09 <dmwit> er
12:17:14 <dmwit> :t span -- ?
12:17:14 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:17:22 <alexsuraci> split ", " "Hello, World!" => ["Hello", "World!"]
12:17:25 <alexsuraci> or any other list
12:17:29 <dmwit> ah
12:17:35 <dmwit> Even more different. =)
12:17:39 <alexsuraci> :P
12:17:49 <vixey> alexsuraci: oh right, you can write this without using reverse at all
12:17:59 <alexsuraci> I've been using other implementations but never understood them, figured I'd try to write one
12:18:16 <vixey> alexsuraci: I mean, you shouldn't need to use ++ or reverse, at all
12:18:35 <alexsuraci> How?
12:18:55 <dmwit> When you find the separator, get the whole rest of the answer from a recursive call, then prepend. =)
12:19:22 <pejo> jsn, (very late) thanks.
12:19:49 <alexsuraci> hm
12:20:14 <alexsuraci> dmwit: You mean call the main function?
12:20:26 <alexsuraci> i.e. call split from split'
12:20:30 <vixey> alexsuraci, You'll probably find some helper functions useful
12:21:41 <dmwit> alexsuraci: Well, without knowing ahead of time how you will "split" the work between split and split', of course I can't answer that.  But the most likely answer is "yes".
12:22:01 <alexsuraci> I'll experiment. ;)
12:28:28 <vixey> :t unfoldr
12:28:29 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:29:04 <vixey> > foldr1 (\x ys -> x ++ ", " ++ ys) ["Hello", "world"]
12:29:05 <lambdabot>   "Hello, world"
12:29:24 <vixey> alexsuraci, (or you can try inverting that using and end up with unfoldr)
12:29:39 <dmwit> > intercalate ", " ["Hello", "world!"]
12:29:39 <alexsuraci> > intercalate ", " ["Hello, World"]
12:29:40 <lambdabot>   "Hello, world!"
12:29:41 <lambdabot>   "Hello, World"
12:29:48 <alexsuraci> ha, beaten :P
12:29:58 <alexsuraci> ...except I typoed.
12:30:04 <vixey> I wouldn't recommend looking at it in terms of intercalate
12:30:13 <dmwit> Yeah, vixey makes a good point.
12:30:49 <dmwit> I'm not sure inverting that particular fold is as easy as it sounds (at the very least, it's not a true inverse), but it is one reasonable approach.
12:34:33 <alexsuraci> hm, is there any sort of haskell benchmarking suite?
12:34:51 <Peaker> @type intercalate
12:34:52 <lambdabot> forall a. [a] -> [[a]] -> [a]
12:35:36 <vixey> actually it should be a left fold
12:35:40 <Deewiant> alexsuraci: 'nofib' at least
12:35:43 <vixey> I think ..
12:36:02 <alexsuraci> Deewiant: Thanks, I'll check it out
12:36:29 <vixey> @src foldr1
12:36:30 <lambdabot> foldr1 _ [x]    = x
12:36:30 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
12:36:30 <lambdabot> foldr1 _ []     = undefined
12:38:07 <vixey> @hoogle unfold
12:38:07 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
12:38:07 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
12:38:07 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
12:42:51 <hukolele> does FFI work inside ghci??
12:43:06 <Cale> hukolele: Well, you can't make declarations, but yes, otherwise.
12:43:22 <Cale> (you have to load a file containing the FFI declarations)
12:43:51 <hukolele> just curiosity but i get an error like this under ghci: Loading package hfann-0.1 ... can't load .so/.DLL for: doublefann (addDLL: unknown error)
12:44:00 <hukolele> but it compiles ok with ghc --make
12:44:21 <Deewiant> hukolele: like I said before, the 'ghci-libraries' field :-)
12:44:42 <Deewiant> what I don't know is why sometimes windows can find the DLL but GHCi can't
12:44:52 <hukolele> i tryed, but it still doesnt works
12:45:05 <Deewiant> does the compiled program run?
12:45:05 <hukolele> and i get that with bindings to haskell
12:45:09 <Deewiant> figure out what DLL it's using
12:45:10 <hukolele> yep
12:45:16 <Deewiant> and then add that to ghci-libraries
12:45:23 <Deewiant> without the .dll and without the directory
12:45:36 <Deewiant> possibly without 'lib' at the beginning, there's a bit of trial and error involved in getting it exactly right
12:55:48 <jsn> can i use GHC-as-library to get the comments from a Haskell file?
12:55:52 <rotw> hi, i've just started learning haskell, and i came across a problem while doing an excercise from the tutorial: http://paste.pocoo.org/show/89925/ hugs and ghci give me a syntax error on line 8, does anyone know why?
12:56:12 <dmwit> nums <- getInput
12:56:20 <BONUS> also, you have to use the do
12:56:25 <dmwit> yep
12:56:31 <BONUS> main = do   hSetBUff...
12:56:41 <rotw> aaahhh
12:56:43 <rotw> thanks :)
12:56:54 <Baughn> jsn: That's for dynamically loading and compiling code, really. What you probably want it Language.Haskell
12:56:54 <BONUS> :]
12:56:56 <dmwit> Also, stdin is line buffered by default (except in ghci).
12:57:06 <Baughn> jsn: (I haven't used it myself, but that's the parser. Or a parser.)
12:57:27 <dmwit> rotw: You might also like readLn.
12:57:29 <dmwit> :t readLn
12:57:29 <lambdabot> forall a. (Read a) => IO a
12:57:43 <rotw> dmwit: hum?
12:58:01 <dmwit> rotw: In getInput, you use (fmap read getLine), which is the same as readLn.
12:58:24 <dmwit> num <- readLn; if num == 0 ...
12:58:46 <rotw> ah, so readLn would make it an integer?
12:58:54 <mauke> anything, really
12:58:58 <Cale> rotw: readLn reads whatever is needed.
12:59:10 <rotw> ok, thanks
12:59:19 <Cale> rotw: If the rest of the program needs a list of integers, say, it will parse a list of integers.
12:59:32 <Cale> (In Haskell syntax)
12:59:47 <Cale> In general, this is made possible by instances of the Read typeclass for various types.
13:00:01 <rotw> ok
13:00:07 <Cale> (which define how various types of things are parsed)
13:02:11 <jsn> Baughn: so it seems that Language.Haskell allows us to take a string to a list of Haskell declarations
13:02:23 <jsn> comments disappear
13:03:15 <Baughn> jsn: If you just want the comments, a parser to extract them would be pretty simple in parsec
13:03:25 <Baughn> Of course, then you'd lose the context. Or just have it textual.
13:04:13 <jsn> Baughn: that's what i've done in the past, yeah
13:04:38 <jsn> Baughn: i just wanted to use a "better way" (Glasgow certified) if there was one
13:04:56 <Baughn> jsn: Sorry. Don't know.
13:05:14 <Baughn> jsn: You might try to look at how haddock works, but I bet it's got its own parser too
13:05:19 <jsn> Baughn: aha
13:05:26 <jsn> Baughn: i'll look at that
13:05:40 <dmwit> > (read "[1,1]", read "[1, 1]") :: ([Int],[Int])
13:05:41 <lambdabot>   ([1,1],[1,1])
13:05:48 * dmwit grunts
13:06:35 <Cale> > read "([1,1],[1,1])" :: ([Int],[Int])
13:06:36 <lambdabot>   ([1,1],[1,1])
13:06:50 <mauke> > read "[1,1]" `asTypeOf` read "[1, 1]" `asTypeOf` [0, 0]
13:06:52 <lambdabot>   [1,1]
13:07:16 <Cale> > read "[1,1]" `asTypeOf` read "bletch" `asTypeOf` [0, 0]
13:07:17 <lambdabot>   [1,1]
13:07:36 <Peaker> @type asTypeOf
13:07:37 <lambdabot> forall a. a -> a -> a
13:07:55 <Peaker> asTypeOf = flip const  ?
13:07:56 <dmwit> asTypeOf = const
13:08:05 <vixey> > asTypeOf 1 2
13:08:05 <lambdabot>   1
13:08:09 <Peaker> oh, ok
13:08:19 <mauke> @src asTypeOf
13:08:19 <lambdabot> asTypeOf = const
13:08:52 <opqdonut> :)
13:08:59 <mauke> uncurry = flip id
13:09:33 <dmwit> Uh, what?
13:09:48 <mauke> it's true in lambda calculus!
13:09:57 <vixey> :t flip id
13:09:58 <lambdabot> forall b c. b -> (b -> c) -> c
13:10:06 <dmwit> heh
13:10:09 <Peaker> @type uncurry
13:10:10 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:10:25 <idnar> @type uncurry `asTypeOf` (flip id)
13:10:27 <lambdabot>     Couldn't match expected type `(a, b)'
13:10:27 <lambdabot>            against inferred type `(a -> b -> c) -> c1'
13:10:27 <lambdabot>       Expected type: (a -> b -> c) -> (a, b) -> c
13:10:29 <idnar> heh
13:11:01 <rotw> ok, i have this now: http://paste.pocoo.org/show/89926/ but it gives me a weird error: "Type error in final generator / *** Term: showFactorials / *** Type [IO b] -> IO [c] / *** Does not match: IO a"
13:11:44 <Cale> rotw: You have num <- head list
13:11:46 <mauke> missing argument
13:12:00 <Cale> rotw: Which means that  head list  had better be an IO action to run
13:12:04 <Cale> rotw: But it's not...
13:12:20 <rotw> Um yeah, but = gives me a syntax error
13:12:28 <Cale> rotw: What you really want is  let num = head list
13:12:37 <Cale> well, actually what you really want is pattern matching
13:13:26 <Cale> showFactorials [] = return ()
13:13:33 <Cale> showFactorials (x:xs) = ...
13:13:53 <rotw> ahhh
13:13:54 <rotw> right
13:14:03 <rotw> sorry, takes getting used to
13:14:30 <Cale> And what you actually actually want is mapM or forM ;)
13:14:34 <mauke> alternatively, showFactorials list = case list of { [] -> return (); x:xs -> ... }
13:14:56 <vixey> showFactors = map (show .  factorial)
13:15:06 <vixey> printFactorials = print . showFactorials
13:15:26 <Cale> like  showFactorials xs = forM xs $ \num -> putStrLn (show num ++ " factorial is " ++ show (factorial num))
13:15:46 <dmwit> mapM_ (print . factorial) -- the quick and dirty version
13:15:56 <Cale> But I'm guessing what hasn't been covered yet :)
13:16:00 <rotw> No :)
13:16:03 <rotw> thanks anyway
13:16:19 <Cale> There are lots of handy control structures in Control.Monad
13:16:36 <Cale> (they're generalised to an arbitrary monad, not just IO, simply because they can be)
13:16:46 <Cale> forM is like a for-each loop
13:16:58 <Cale> forM :: [a] -> (a -> IO b) -> IO [b]
13:17:05 <Deewiant> forM = flip mapM
13:17:33 <Cale> It takes a list, and a function from elements of that list to actions (a loop body), and produces an action which runs the loop, giving a list of the results of each iteration.
13:17:56 <Cale> Well, really it has a more general type:
13:17:58 <rotw> rrrrriiiiiighhttt....
13:18:07 <Cale> forM :: (Monad m) => [a] -> (a -> m b) -> m [b]
13:18:25 <Cale> But you don't have to care about that really, until you learn about other monads.
13:19:17 <Cale> If that went a little quickly, think about what the type of a loop body is in general. It depends on the things being iterated over, and says what to do in terms of that.
13:19:32 <Cale> So a loop body is a function from the things being iterated over to actions.
13:19:44 <Cale> (and that's exactly how we handle it in Haskell)
13:19:58 <rotw> ok
13:20:05 <Cale> The reason that Haskell doesn't have a built-in for loop is that we can write it as a library function :)
13:20:23 <Cale> If you'd like, I can show how it's done :)
13:20:43 <rotw> err... another time, maybe :D
13:20:46 <Cale> okay :)
13:20:50 <rotw> but thanks :)
13:20:59 <Cale> No problem :)
13:26:48 <rotw> sorry to bother you again, but it's still not working: http://paste.pocoo.org/show/89932/ (error message in the comment at the bottom)
13:27:39 <Cale> rotw: right, in the nonempty list case, showFactorials gives an action (the do-block)
13:27:48 <Cale> rotw: In the empty case there, it's giving a list.
13:28:00 <Cale> rotw: So you probably want it to give the action which does nothing.
13:28:05 <Cale> rotw: Which is  return ()
13:28:40 <Cale> return [] will also work, but is slightly less idiomatic.
13:28:57 <Cale> Normally, actions which don't have an interesting result to return produce the empty tuple.
13:29:12 <rotw> ah
13:29:24 <Cale> (if the recursive case added something to the list produced, then you'd want the base case to return an empty list perhaps)
13:30:01 <rotw> wait
13:30:12 <rotw> why do i need return?
13:30:19 <Cale> Because a list is not an action.
13:30:39 <Cale> showFactorials takes a list, and produces an action for printing the factorials of the elements of that list
13:31:34 <Cale> In the recursive case, that action is built up using a do-block from the action for printing the factorial of the head of the list, and the action for printing the factorials of rest of the list
13:31:37 <Cale> the*
13:31:58 <Cale> In the empty case, it still needs to be an action, but the action doesn't need to do anything.
13:32:08 <rotw> all right, so i can't just return something, i need to return an action, to be consistent with showFactorials (x:xs)?
13:32:19 <Cale> right.
13:32:25 <rotw> ok, thanks :)
13:32:32 <Cale> The function 'return' takes a value, and produces the action that does nothing, but returns that value.
13:32:45 <rotw> ok
13:32:46 <Cale> (note that return is *not* a keyword)
13:33:34 <Cale> So it takes some getting used to, but amounts to something rather similar to the imperative programming you might already be familiar with.
13:33:35 <araujo> hello
13:33:39 <Cale> hi!
13:33:42 <araujo> :-)
13:33:44 <rotw> yep
13:34:45 <Cale> We treat actions as values which can be combined into larger actions using do-notation. Eventually, the 'main' of your program is one of these actions, and in some sense, it's the only one which gets run (in a compiled program, anyway)
13:35:17 <Cale> But of course, it's built up from simpler actions.
13:36:34 <Cale> You can pass actions around as normal values, and normal Haskell evaluation won't cause them to accidentally execute. The 'only' way to actually execute an action x is to use something like  v <- x  in a do-block (or x by itself on a line in a do-block).
13:37:00 <Cale> and in turn, that do-block will define another action
13:37:10 <rotw> ok
13:38:39 <rotw> ok, all working fine :) thanks guys, i'm off
13:38:47 <rotw> bye
13:45:55 <Baughn> rdd: There's also unsafePerformIO, which if you run it will surgically replace your feet with rabbits
13:46:50 <Cale> Baughn: rotw is gone :)
13:46:59 <dmwit> That is a great quote, though.
13:47:03 <BONUS> incidentally, im just writing the IO chapter and i made a picture about the dangers of side-effects: http://learnyouahaskell.com/dognap.png
13:47:17 <Cale> hehehe
13:47:30 <dmwit> Be careful!  I have a banana!
13:47:37 <Cale> BONUS: What are you using to draw those? Inkscape?
13:47:46 <BONUS> nah, actually im using Flash :X
13:47:50 <BONUS> i dont like to admit it though
13:47:58 <Raynes> BONUS: I'm reading your book/tutorial as we speak. Nice job so far!
13:48:04 <BONUS> hehe thanks :]
13:48:18 <Baughn> dmwit: http://johnsu.deviantart.com/art/rabbit-feet-98443103 <-- It was inspired by this
13:48:19 <Raynes> It takes a good angle at teaching haskell.
13:48:19 <lambdabot> Title: rabbit feet by *JohnSu on deviantART
13:48:35 <Raynes> Like Whys Poignant guide to ruby, but not as vauge.
13:48:40 <Cale> I've never actually used Flash myself. It seems people are capable of doing rather impressive things with it these days though.
13:48:44 <BONUS> yeah that was my aim
13:48:53 <BONUS> lighthearted but not so wacky and zany and nonsensical
13:49:16 <Raynes> Yeah, Why's guide was good mind you but he got carried away with the stupid stories
13:50:21 <BrokenClockwork> Hey, what do you think, any good ideas to implement a own minimum-function on lists as recursion?
13:50:33 <dmwit> :t minimum
13:50:34 <lambdabot> forall a. (Ord a) => [a] -> a
13:50:43 <Baughn> @src minimum
13:50:43 <lambdabot> minimum [] = undefined
13:50:43 <lambdabot> minimum xs = foldl1 min xs
13:50:49 <BONUS> think about what minimum is
13:50:50 <BrokenClockwork> I looked up how minimum is defined, but it works with foldl1
13:50:52 <dmwit> The easiest code to maintain is the code you never write. ;-)
13:51:04 <Baughn> BrokenClockwork: Remember the principle of substitution?
13:51:06 <Cale> BrokenClockwork: Well, you have a base case which is the list of length 1
13:51:15 <Cale> BrokenClockwork: myMinimum [x] = ...
13:51:30 <BONUS> think of minimum like this: it is the smallest of either the first element of the list or the smallest element in the rest of the list
13:51:46 <BONUS> if there's just one element in the list, we can assume that it's the smallest
13:51:57 <Baughn> Of course, it should be using foldl1'
13:52:10 <vixey> minimum []  = what ?
13:52:10 <BrokenClockwork> but is foldl1 not a recursion itself?
13:52:19 <dmwit> Sure.
13:52:24 <BONUS> vixey: 10 :]
13:52:31 <Baughn> @src foldl1
13:52:32 <lambdabot> foldl1 f (x:xs) = foldl f x xs
13:52:32 <lambdabot> foldl1 _ []     = undefined
13:53:13 <dmwit> :t let boundMaximum = foldl' min maxBound in boundMaximum
13:53:14 <lambdabot> forall a. (Bounded a, Ord a) => [a] -> a
13:53:43 <BrokenClockwork> but calling foldl1 in another function isnt what I wanted, is it? I call fold1 and it does the recursion thing and not my own defined function
13:53:57 <Baughn> BrokenClockwork: So look at how foldl1 is defined
13:54:01 <BONUS> yeah, but you can implement it without foldl
13:54:07 <BrokenClockwork> ok
13:54:12 <dmwit> Now just write an instance Ord a => Bounded (Either a Bool). ;-)
13:54:15 <chrisdone> what package is Data.Map etc. in?
13:54:21 <Baughn> chrisdone: containers
13:54:28 <chrisdone> Baughn: ah, thanks
13:54:39 <BONUS> just try to write this down in haskell: the minimum in the list is either the first element of the list or the minimum in the rest of the list, whichever of those two is smaller
13:54:41 <dmwit> Actually, you don't even need the Ord a constraint.
13:54:42 <Cale> BrokenClockwork: listen to BONUS :)
13:55:45 <BrokenClockwork> ok
13:55:56 <BrokenClockwork> I will to take this advice :)
13:55:58 <chrisdone> so I just ran `cabal install kibro' on a new ghc-6.10 RC install which crashed Linux (I say crashed, my mouse moved sometimes) when trying to resolve dependancies
13:56:38 <chrisdone> should I install the dependancies piece by piece perhaps?
13:56:55 <BONUS> not to toot my own horn but i implementing maximum recursively is explained at length and drawn here: http://localhost/haskelltut/recursion#maximum-awesome
13:56:56 <BONUS> :]
13:56:59 <BONUS> whoops
13:57:00 <BONUS> i mean
13:57:04 <Baughn> chrisdone: What version of cabal-install are you running?
13:57:09 <Baughn> chrisdone: Only the newest works on 6.10
13:57:12 <BONUS> http://learnyouahaskell.com/recursion#maximum-awesome
13:57:15 <lambdabot> Title: Learn You a Haskell for Great Good! - Recursion
13:57:37 <chrisdone> Baughn: ah, that's probably it (it's 0.5.2). shall I get the darcs version?
13:58:01 <Baughn> chrisdone: No, just get the 0.6.0 version and run the bootstrap script
13:58:06 <chrisdone> Baughn: right-o
14:03:48 <chrisdone> Baughn: works good :D
14:04:14 * Baughn wonders if there's a better way than putting "ghc-options: -O2" in ~/.cabal/config
14:04:49 <chrisdone> when one says ":set -O2" in GHCi, does that do anything?
14:05:03 <Baughn> Only if you also say :set -fobject-code
14:05:17 <Baughn> And even then, I think only on actual files you load
14:05:45 <chrisdone> fair enough
14:09:35 <ExplicitCall> did anyone succeed in building HXT with GHC 6.10?  as far as I can see, http://hackage.haskell.org/trac/ghc/ticket/2722 there is some HXT 8.2 out there which can be compiled with GHC 6.10, but I didn't find any repository contaning it
14:09:46 <lambdabot> Title: #2722 (<<loop> when compiling with -O option with ghc-6.10.0.20081019) - GHC - T ...
14:17:57 <mofmog1> hmm haskell mode in emacs seems to not be putting up ghci
14:22:34 <BrokenClockwork> any function to delete list element on position x ?
14:22:50 <dmwit> no
14:22:54 <BrokenClockwork> k
14:26:55 <Baughn> BrokenClockwork: If that is something you do a lot, then you probably don't want a list
14:27:15 <Peaker> I like: "quicksilver: it doesn't entirely help that SQL is a series of broken standards layered over very poor decisions by large corporations"
14:27:23 <BONUS> deleteAt i xs = uncurry (++) . fmap tail . splitAt i $ xs
14:27:25 <BONUS> but yeah
14:27:29 <BrokenClockwork> thought so Baughn :)
14:27:37 <BONUS> peaker is right
14:27:50 <Peaker> quicksilver is right, you mean?
14:28:08 <BONUS> no i mean you, you prolly dont want a list if you do that a lot
14:29:48 <BONUS> @pl (\i xs -> take i xs ++ tail (drop i xs))
14:29:48 <lambdabot> ap (ap . ((++) .) . take) ((tail .) . drop)
14:29:59 <int-e> @users
14:29:59 <lambdabot> Maximum users seen in #haskell: 536, currently: 523 (97.6%), active: 19 (3.6%)
14:30:03 <Peaker> when does @pl use ap?
14:30:26 <vixey> > (\i xs -> take i xs ++ tail (drop i xs)) 3 "!@#$%^&*"
14:30:27 <lambdabot>   "!@#%^&*"
14:30:34 <int-e> @pl \f g x -> f x (g x)
14:30:34 <lambdabot> ap
14:30:38 <BONUS> f `ap` g is \x -> f x (g x)
14:30:38 <BONUS> gah
14:30:39 <BONUS> beaten
14:30:51 <vixey> > (\i xs -> take i xs ++ tail (drop i xs)) 3 "!@#$%^&*" == "!@#$%^&*"
14:30:52 <lambdabot>   False
14:31:31 <Peaker> BONUS, int-e: Puzzling. I need to think about why that is true ;)
14:32:03 <Peaker> oh ok, its clear now ;)
14:32:10 <BrokenClockwork> f [] = [] is an expression, that the function's list is empty and gives out an empty list, what's the expression for a list with just one element?
14:32:20 <BONUS> f [x]
14:32:46 <int-e> f (x:[]) works, too.
14:32:54 <vixey> f [] = [] is an equation
14:33:06 <vixey> the left [] is a pattern, the right [] is an expression
14:33:13 <BrokenClockwork> oh
14:35:24 <BONUS> just to correct myself: using tail in deleteAt is retarded
14:35:42 <BONUS> deleteAt i xs = take i xs ++ drop (i+1) xs is much better
14:35:52 <vixey> :t splitAt
14:35:52 <lambdabot> forall a. Int -> [a] -> ([a], [a])
14:36:04 <vixey> :t uncurry (++) . splitAt ?i
14:36:05 <lambdabot> forall a. (?i::Int) => [a] -> [a]
14:36:11 <vixey> :t uncurry (++) . second tail . splitAt ?i
14:36:12 <BONUS> yeah but you gotta delete one element
14:36:12 <lambdabot> forall a. (?i::Int) => [a] -> [a]
14:36:33 <BONUS> and using tail, it would throw an error on deleteAt 100 "haha"
14:36:39 <BONUS> although i think it should just return "haha"
14:36:45 <vixey> @let snerp i = uncurry (++) . second (drop 1) . splitAt i
14:36:45 <lambdabot>  Defined.
14:36:49 <BrokenClockwork> so here we go, that's my code of the above described problem, though i think it's a very dirty implementation, dunno http://hpaste.org/11693
14:36:52 <vixey> > snerp "!@#$%^" 3
14:36:53 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
14:36:57 <vixey> > snerp 3 "!@#$%^"
14:36:58 <lambdabot>   "!@#%^"
14:37:24 <BONUS> eh, why would you use second and uncurry in such a simple function
14:37:28 <vixey> BrokenClockwork: You should try to write it without using any !! or length
14:37:44 <BrokenClockwork> yeah thought so *sigh* it was the easy way
14:37:55 <dmwit> BONUS: It recovers O(n) work, n the first argument.  But it may be premature optimization.
14:38:09 <vixey> BONUS, I just like writing everything in [nearly] point-free form with lots of (.)
14:38:16 <BONUS> haha
14:38:44 <BONUS> premature optimization is the root of all awesome
14:38:47 <vixey> I found that (.) is really malleable so it's very nice
14:38:57 <BONUS> im a composition junkie too hehe
14:39:11 <BONUS> i love me those dots
14:39:16 <vixey> if you define something as composition then you can invert it easily, you can split it up more, etc etc
14:40:30 <BrokenClockwork> vixey: but how can I compare two list elements without calling two with !! ?
14:40:45 <vixey> BrokenClockwork, the sort of recursion-template could be,
14:40:49 <vixey> foo [] = _
14:40:52 <vixey> foo [x] = _
14:40:59 <vixey> foo (x:y:zs) = _
14:41:06 <BONUS> maybe you should ask yourself why you need to compare two list elements
14:41:09 <vixey> then you can compare x and y
14:41:26 <vixey> dunno what you are writing though
14:42:04 <BrokenClockwork> the minimum function on my own as recursion, without using sorting algorithm, that's the task
14:42:20 <vixey> what's the minimum of [] ?
14:42:32 <BrokenClockwork> Error
14:42:49 <vixey> how do you write Error in haskell?
14:42:59 <BONUS> BrokenClockwork: did you give that link i gave you a read? :)
14:42:59 <BrokenClockwork> I have no idea
14:43:00 <vixey> or is this something you just leave out (that works too)
14:43:09 <BrokenClockwork> you gave me a link??
14:43:26 <BONUS> http://learnyouahaskell.com/recursion#maximum-awesome
14:43:27 <lambdabot> Title: Learn You a Haskell for Great Good! - Recursion
14:43:55 <BrokenClockwork> oh I use this Tutorial since I started with Haskel
14:44:03 <BONUS> oh haha
14:44:16 <BrokenClockwork> but not until there -.-
14:44:31 <BONUS> i think that part contains just what you're looking for
14:45:07 <BrokenClockwork> We leave it out, because our tutors say, we assume friendly input
14:45:28 <BrokenClockwork> ok, then I will take a closer look
14:47:08 <BONUS> i wonder if anyone has implemented parallelization as arrows
14:47:14 <BONUS> always seemed like a nice match to me
14:47:31 <BONUS> to have fanout spawn threads, etc.
14:47:33 <LarstiQ> what ar arrows?
14:48:17 <BONUS> basically a typeclass that describe stuff that takes an input and produces an output
14:48:34 <mapreduce> @src Arrow
14:48:34 <lambdabot> class Arrow a where
14:48:34 <lambdabot>     arr, pure   :: (b -> c) -> a b c
14:48:34 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
14:48:34 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
14:48:34 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
14:48:36 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
14:48:38 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
14:49:01 <BONUS> http://en.wikibooks.org/wiki/Haskell/Understanding_arrows this describes them pretty nicely with pictures
14:49:16 <vixey> BrokenClockwork: yeah that's fine, there's lots of things you want to assume about data that isn't expressed in the types
14:50:52 <jsn> is there a way to use regex options with    =~    or    ==~    ?
14:52:28 <dmwit> no
14:55:23 <jsn> curses
14:58:40 <BrokenClockwork> thx BONUS, now I got it, I didn't know I can define (x:xs) as one input
15:02:35 <tromp> @hoogle second
15:02:36 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
15:02:36 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
15:02:36 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
15:03:14 <jsn> dmwit: i guess there's nothing preventing from writing a    RegexMaker    instance for    (String, CompOpt)
15:08:10 <tromp> :t foldr
15:08:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:12:29 <czShadoW> @users
15:12:29 <lambdabot> Maximum users seen in #haskell: 536, currently: 518 (96.6%), active: 14 (2.7%)
15:16:48 <jsn> hmmm
15:16:57 <jsn> i can not find the instances for RegexMaker
15:18:40 <tromp> :r foldl
15:18:49 <tromp> :t foldl
15:18:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:18:55 <tromp> :t foldl1
15:18:56 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
15:20:07 <Cale> jsn: Hmm... I forget which one that is, but the intention is that you import a module like Text.Regex.Posix
15:23:22 <jsn> Cale: thanks -- i've found a byte string instance in the TDFA module
15:24:30 <telexicon> data Pair a = One a | Two a a; One x >>= f = f (One x); Occurs check: cannot construct the infinite type: a = Pair a
15:24:56 <Cale> telexicon: Try  f x
15:25:05 <Cale> (instead of  f (One x))
15:25:23 <telexicon> f :: (Integral a) => (Pair a) -> (Pair a)
15:25:25 <vixey> telexicon, oh that's interesting
15:25:56 <Cale> telexicon: f :: (a -> Pair b)
15:26:11 <telexicon> then how do I pass a pair?
15:26:22 <Cale> hm?
15:26:34 <vixey> telexicon, it looks like one of these http://lambda-the-ultimate.org/node/1183#comment-12896
15:26:35 <telexicon> if i want to bind multiple values
15:26:46 <lambdabot> Title: The Haskell Programmer's Guide to the IO Monad --- Don't Panic | Lambda the Ulti ...
15:27:06 <dibblego> what is a good example of the state monad to demonstrate to a beginner?
15:27:13 <Cale> Well, perhaps  Two x y >>= f = Two (f x) (f y)
15:27:30 <dmwit> dibblego: Generating random numbers, maybe?
15:27:35 <vixey> will that typecheck :S
15:27:37 <telexicon> Cale, a pair of pairs?
15:28:01 <sjanssen> dibblego: numbering the leaves in a tree is the classic example
15:28:08 <Cale> telexicon: Oh.
15:28:14 <Cale> telexicon: Right, this just isn't a monad.
15:28:14 <dibblego> sjanssen, nice thanks
15:28:29 <telexicon> you cant bind sequence multiple values in a monad?
15:28:34 <Cale> (the Two case isn't recursive like I expected)
15:28:57 <Cale> I'm not sure what you mean...
15:29:04 <sjanssen> dibblego: you can also show off Traversable at the same time
15:29:11 <telexicon> :t (>>=)
15:29:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:29:21 <Cale> telexicon: Let's start from the simpler definition of a monad.
15:29:31 <Cale> telexicon: First we need fmap, which is easy.
15:29:38 <Cale> Then we need return and join
15:29:44 <telexicon> it takes a monad, and binds it to a function which takes a value and returns a monad value
15:29:51 <dibblego> sjanssen, this example? http://haskell.org/wikisnapshot/StateMonad.html
15:29:51 <lambdabot> Title: StateMonad
15:29:52 <telexicon> what if i want two values?
15:29:52 <Cale> If we can define join, then we can define bind
15:30:06 <vixey> telexicon, hello ?
15:30:07 <Cale> join :: Pair (Pair a) -> Pair a
15:30:10 <telexicon> vixey, hi
15:30:14 <vixey> telexicon, there's an example of that in the link I gave you
15:30:18 <Cale> So the question is what should join do?
15:30:22 <sjanssen> dibblego: right
15:30:38 <Cale> We could have something like...
15:30:38 <Cale> join (One x) = One x
15:30:51 <Cale> er
15:30:53 <Cale> join (One x) = x
15:31:28 <telexicon> so it has to be condensed into a single value?
15:31:38 <Cale> Then the question becomes what to do in the Two cases.
15:31:52 <Cale> Inevitably, you'll end up throwing away some values.
15:32:03 <Cale> and it's not clear to me that you'll end up with a monad.
15:32:16 <Cale> (remember you still have to satisfy the laws -- particularly associativity)
15:32:26 <telexicon> vixey, yeah but i cant really read that
15:32:44 <Cale> telexicon: once you have fmap and join, then  x >>= f = join (fmap f x)
15:33:04 <vixey> telexicon, why not
15:33:20 <telexicon> vixey, because it has a bunch of stuff in it
15:33:29 <vixey> that didn't make any sense
15:33:42 <telexicon> i cant isolate the part that i need to understand from the rest of it
15:33:53 <telexicon> because i dont know what i need to know yet (obviously), i cant know which is which
15:34:05 <Cale> telexicon: A monad is a type constructor together with a pair of functions return and (>>=) of appropriate types which satisfy the monad laws.
15:34:14 <telexicon> Cale, yes
15:34:19 <Cale> telexicon: Monads are fairly sparse, not every type constructor is a monad in some way.
15:34:36 <telexicon> thats what it is structurally
15:34:43 <Cale> hm?
15:34:46 <telexicon> but what are they for? what kind of abstraction is it?
15:34:59 <telexicon> ive heard a lot different explanations for what they are for
15:35:40 <Cale> It depends on how you'd like to look at it, really. The most common answer is that monads are an abstraction of types of computation, but that doesn't mean a whole lot on its own.
15:36:23 <BONUS> i like to think of them as computations that can be sequenced
15:36:40 <BONUS> and also i like to think that they act somewhat like boxes
15:36:47 <vixey> I don't have any conception of what a monad is, other than the actual definition
15:36:51 <telexicon> sequencing and containers
15:36:52 <Cale> Actually, we might have a monad with:
15:37:06 <Cale> join (Two (One x) (One y)) = Two x y
15:37:13 <Cale> join (Two (One x) (Two y z)) = Two x y
15:37:21 <Cale> join (Two (Two x y) _) = Two x y
15:37:40 <Cale> That is, if there are more than two, we don't care.
15:37:43 <jsn> telexicon: the monad operation allow you stick a value in the monad, and allow you to run computations on that value in the monad -- monads do not have to have a way to get *out* of the monad
15:37:51 <Cale> But I'm not certain that this will satisfy associativity.
15:37:55 <jsn> s/operation/operations/
15:37:57 <telexicon> yeah they do
15:37:59 <Cale> It will need to be checked.
15:38:27 <telexicon> :t fromJust
15:38:29 <lambdabot> forall a. Maybe a -> a
15:38:33 <Cale> telexicon: In general.
15:38:36 <telexicon> doesn't that get out of the monad?
15:38:41 <Cale> telexicon: Yes.
15:38:41 <jsn> telexicon: they *may* have a way
15:38:47 <telexicon> oh i see
15:38:51 <telexicon> you said have to
15:38:54 <telexicon> they dont have to have a way
15:38:56 <Cale> That terminology makes me wince though.
15:38:57 <jsn> telexicon: but that is structure additional to what makes it a monad
15:38:59 <Cale> "get out of the monad"
15:39:06 <jsn> Cale: fair enough
15:39:21 <shapr> Is there not a HAppS metapackage?
15:39:31 <telexicon> so i guess this means im back to square one
15:39:40 <telexicon> i dont know what monads are
15:39:47 <shapr> they're an abstraction, much like objects
15:39:50 <telexicon> but these last examples destroyed what i thought i knew
15:39:57 <telexicon> that keeps happening
15:40:00 <telexicon> its annoying
15:40:03 <Cale> telexicon: Well... okay.
15:40:19 <Cale> telexicon: Let's look at a big class of examples in general.
15:40:25 <telexicon> i wrote a Maybe
15:40:29 <telexicon> an Identity and a Counter
15:40:35 <telexicon> each of which are monads
15:40:54 <telexicon> and they abstract sequenceable computations
15:41:12 <telexicon> at least, thats how i was thinking of them
15:41:29 <Cale> Pretend that we have some library for representing computations of some type. That is, computations are themselves values. Suppose we have some type constructor T, and values of type (T a) are "computations which if run would produce a value of type a"
15:42:00 <shapr> cabal install happs-tutorial gives dependency errors.
15:42:06 <telexicon> ok
15:42:06 <Cale> Suppose we have a way to produce a 'no-op' computation which 'does nothing' before returning a specific value. Then this is what return should give us.
15:42:34 <Cale> Suppose we also have a way to take one computation, ignore its result and follow it with another computation.
15:42:46 <Cale> Then this is what x >> y should give us.
15:42:52 <Cale> :t (>>)
15:42:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
15:42:56 <telexicon> yes
15:43:03 <shapr> I'd like to request a hackage extension... ability to file bugs for a package.
15:43:18 <Cale> and finally, if we have some way for the following computation to depend on the result of the first, that's what (>>=) is.
15:43:35 <telexicon> yes
15:44:00 <Cale> What's the point? Well, we can write some interesting and very general things in terms of >>= and return
15:44:07 <Cale> They're mostly in Control.Monad
15:44:18 <Cale> but there are some others as well (Data.Traversable for one)
15:44:44 <Cale> and any library of computations which can be properly recognised as a monad gets all these operations for free.
15:44:56 <Cale> They're mostly very control-structure like.
15:45:20 <BONUS> i personally like explaining monads in terms of boxes even though they're not really boxes. but i feel it helps people understand the general concept even though its not entirely "correct"
15:45:31 <skorpan> monads are NOTHING.
15:45:39 <skorpan> they're a lie.
15:45:43 <Cale> Not every library will necessarily be a monad, but enough of them are that it's worthwhile to recognise them.
15:45:44 <Philonous> Given return and bind, how do I construct join again?
15:45:54 <Cale> join x = x >>= id
15:46:04 <telexicon> ugh
15:46:10 <mofmog1> monads are functors with >>= and return defined for it
15:46:14 <mofmog1> ~thatsallitis~
15:46:23 <BONUS> you can also make >>= with join :)
15:46:23 <telexicon> nobody can even agree on what it is
15:46:32 <mofmog1> or i guess it's
15:46:36 <mofmog1> join and fmap and return
15:46:46 <mofmog1> ~buttheyrethesameooooooh~
15:46:56 <Philonous> Cale: Thanks, that's what I thought, but how does that go with the type of bind? id is of type a-> a, not a->m a
15:47:06 <telexicon> ok, so its a computation
15:47:16 <Hunner> Butt hey Ret, he's a meoooooh?
15:47:20 <BONUS> think of it as join x >>= \a -> a
15:47:23 <BONUS> the a is a monad itself
15:47:27 <BONUS> so it returns a monad
15:47:29 <BONUS> and it typechecks
15:47:34 <mofmog1> i think the problem is that people don't really define what "computation" is
15:47:38 <telexicon> yeah
15:47:42 <telexicon> do that, lets define a computation
15:48:01 <BONUS> yeah, i used to think computtation as something that *does* something but its much more general imho
15:48:04 <BONUS> 4 is a computation
15:48:13 <mofmog1> i think the simplest way to explain it is
15:48:22 <BONUS> 4 represents a computation that computed 4
15:48:32 <mofmog1> >>= m a -> (a -> m b) -> m b
15:48:36 <Cale> Philonous: that's a good question... so both the types have to be the same
15:48:44 <BONUS> Just "YEAH" represents a computation that could have failed but didn't, so it produced "YEAH"
15:48:49 <BONUS> Nothing is a computation that failed
15:48:57 <BONUS> [1,2,3,4] is a computation that produced several results
15:48:57 <Cale> Philonous: so a -> m b must be c -> c for some type c
15:49:00 <BONUS> [] is a computation that failed
15:49:01 <BONUS> etc.
15:49:07 <Cale> Philonous: which means that a = m b
15:49:17 <telexicon> mofmog1, yes and
15:49:29 <mofmog1> m = FUNCTOR
15:49:33 <Cale> Philonous: see how that works?
15:49:46 <Philonous> Cale: Give me a minute to figure it out ;)
15:49:53 <telexicon> functor being an object which acts like a function and has state?
15:49:55 <mofmog1> Functor: a structure with a bunch of slots that your put stuff into
15:49:58 <mofmog1> NO
15:50:07 <mofmog1> A functor is a THING with A BUNCH OF HOLES in which you put data
15:50:11 <mofmog1> like a list is a functor
15:50:19 <mofmog1> [THIS IS A HOLE,THIS ISANOTHERHOLE,ANDSOON]
15:50:20 <mofmog1> or
15:50:32 <mofmog1> Just THISISAHOLEPUTSOMETHINGHERE
15:50:39 <tromp> hmm, always have trouble compiling a module not called Main :(
15:50:40 <mofmog1> or for example a tree
15:50:42 <telexicon> ok
15:50:47 <mofmog1> so what >>= does is
15:50:49 <dmwit> mofmog1: And the Reader functor? ;-)
15:50:58 <tromp> i tried ghc --make -main-is PonderThisNov PonderThisNov.hs
15:50:59 <mofmog1> dmwit: dont confuse me!
15:51:05 <dmwit> heh
15:51:09 <mofmog1> anyways
15:51:11 <Cale> dmwit: It's a box indexed by the domain.
15:51:12 <mofmog1> >>= takes a functor
15:51:12 <tromp> and get /usr/lib/ghc-6.8.2/libHSrts.a(Main.o): In function `real_main':(.text+0x12): undefined reference to `__stginit_ZCMain'
15:51:23 <mofmog1> and it lets you run a function on it that returns another functor
15:51:28 <telexicon> ok
15:51:31 <BONUS> i tend to think of a functor as a box with one or more compartments. or zero of them.
15:51:32 <telexicon> im wish you so far
15:51:36 <Philonous> Cale: Oh, actually it's pretty trivial. Thanks.
15:51:38 <telexicon> er with*
15:51:39 <Cale> dmwit: (->) e is a type of box with a hole for each point in e
15:51:45 <dmwit> Cale: right
15:51:49 <mofmog1> ok >>=
15:51:51 <mofmog1> look at its type
15:51:57 <mofmog1> > :t (>>=)
15:51:58 <lambdabot>   <no location info>: parse error on input `:'
15:51:59 <mofmog1> er
15:52:03 <mofmog1> :t (>>=)
15:52:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:52:14 <dmwit> tromp: Is main really PonderThisNov?
15:52:16 <mofmog1> so it takes "m a"
15:52:24 <mofmog1> it takes a functor with something of type a in it
15:52:30 <dmwit> tromp: (I think main-is is not Main-is.)
15:52:39 <mofmog1> then it takes a function that takes something of type a and returns another functor
15:53:00 <mofmog1> so in the end, you get a functor with something of tybe b inside
15:53:08 <dmwit> Exactly right.
15:53:24 <telexicon> ok
15:53:32 <tromp> module PonderThisNov has a main defined
15:54:08 <dmwit> tromp: Then I suggest dropping the -main-is bit.
15:54:09 <telexicon> and so you use this thing
15:54:22 <dmwit> Though I'm a bit rusty on my command-line options.
15:54:23 <telexicon> to create computational structures
15:54:26 <telexicon> ?
15:54:43 <tromp> then i don't get an executable though?!
15:54:55 <tromp> just a .o
15:54:58 <telexicon> each one having a different shape, which makes it do what it does
15:55:04 <telexicon> awesome
15:55:36 <mofmog1> telexicon: the trick is that you can have a functor
15:55:37 <mofmog1> such as tuple
15:55:44 <mofmog1> and then you can put stuff like "state" inside the tuple
15:56:06 <mofmog1> have you read sicp? or have you tried making recursive functions where you keep passing a counter recursively?
15:56:22 <telexicon> accumulators?
15:56:24 <mofmog1> the idea is that each function now returns a tuple, with the state in one part and the real output in the other part
15:56:53 <mofmog1> you know what an iterative process is versus a recursive one?
15:57:15 <telexicon> dazzle me
15:57:24 <mofmog1> ok
15:57:40 <mofmog1> for example, a program that counts adds up numbers from 1 to 10
15:57:41 <Philonous> Monads are like mothers. They clean up the mess you leave behind after you played.
15:57:54 <telexicon> really not helpful, thanks
15:58:12 <BONUS> haha
15:58:20 <mofmog1> let foo counter end = if (counter==end) then 1 else (foo (counter+1) end)
15:58:41 <mofmog1> notice how you keep passing "counter" which is a way of emulating state
15:58:56 <telexicon> yes, i notice
15:59:08 <mofmog1> by using >>= and monads you can hide it away
15:59:15 <telexicon> yup
15:59:28 <telexicon> i used to know how to do that
15:59:31 <mofmog1> ok the problem with explaining monads is that they do a lot more stuff
15:59:48 <mofmog1> another thing that >>= can do is to also act like a shunt
16:00:00 <mofmog1> so think of functors like "boxes"
16:00:08 <BONUS> and they're very general and abstract. telexicon here's a read i'd recommend you give a go once: http://spbhug.folding-maps.org/wiki/MonadsEn
16:00:08 <skorpan> a shunt?
16:00:10 <skorpan> in what context?
16:00:19 <lambdabot> Title: MonadsEn - SPb Haskell User Group
16:00:20 <telexicon> shunting yard
16:00:32 <mofmog1> ok
16:00:37 <mofmog1> think of a monad as a box
16:00:40 <mofmog1> with data inside
16:00:43 <telexicon> BONUS, ok, any reason it will be different from the last 15?
16:00:50 <mofmog1> and think of functions that work over them as little processing centers
16:01:00 <BONUS> telexicon: i can't guarantee it will be different but i really like the approach of this one
16:01:13 <mofmog1> and think of >>= as a sort of a "company policy" on what to do with the data inside the box before it gets processed
16:01:34 <mofmog1> for example, you might have a box full of trash and recyclable materials and it has to go through a bunch of processing plants
16:01:35 <telexicon> do i get a secretary who brings me coffee?
16:01:42 <mofmog1> however, if you ever find NUCLEAR MATERIAL in any of the boxes
16:01:47 <telexicon> yeah
16:01:53 <mofmog1> you send it off to oblivion
16:01:55 <telexicon> you gave it a good try
16:01:57 <telexicon> thanks
16:02:12 <mofmog1> you know, it makes so much sense when you get it sort of
16:03:14 <alson_> @seen dons
16:03:14 <lambdabot> dons is in #haskell, #xmonad, #darcs, #ghc and #arch-haskell. I last heard dons speak 32m 27s ago.
16:03:26 <telexicon> so why cant the little processing center process a monad?
16:03:32 <telexicon> or a tuple,
16:03:36 <alson_> Cale: have you gotten hs-plugins to build with GHC 6.10?
16:03:46 <Cale> alson_: I don't have GHC 6.10
16:03:50 <telexicon> ghc likes to explode into nonsense errors if you do that
16:03:54 <BONUS> hmm
16:03:59 <BONUS> maybe if you think of >>= as "and then"
16:04:04 <Cale> alson_: It wouldn't surprise me at all if there were difficulties though.
16:04:15 <telexicon> ok this is where im at
16:04:21 <mofmog1> telexicon: the processing center CAN take in a monad
16:04:25 <mofmog1> er
16:04:28 <mofmog1> wait no it can't
16:04:28 <mofmog1> ok
16:04:29 <mofmog1> so
16:04:32 <telexicon> data Counter a = Counter Integer a
16:04:42 <alson_> Cale: ah.  I switched to 6.10 because hs-plugins 1.3 wasn't working with 6.8..  I can't get a break..
16:04:56 <telexicon> instance Monad Counter where return = Counter 0; Counter c0 x >>= f = let (Counter c1 y) = f x in Counter (c0+c1+1) y
16:05:07 <mofmog1> ok the reason is
16:05:22 <Cale> alson_: I contributed some patches to hs-plugins a while back, but I don't actually understand it, and it's really more Don's project.
16:05:25 <mofmog1> you want the stuff at the beginning of the chain of >>=s to be composed within the stuff at the end
16:05:32 <telexicon> given a function, csquare x = return (x*x) :: Integer -> Counter Integer
16:05:45 <mofmog1> a >>= b >>= c should give you something like (c (b (a)))
16:05:54 <mofmog1> or c(b(a()))
16:06:33 <telexicon> csquare 5 >>= csquare >>= csquare
16:06:39 <telexicon> its a sequence
16:06:41 <Cale> alson_: (I basically decided that it should be using the GHC API for one thing, the .hi file parsing, and just used type signatures to stumble my way around tearing half the code out of the thing.)
16:06:57 <telexicon> it even has a sequence counter built into it
16:07:29 <Cale> telexicon: that is not a monad, btw
16:07:34 <telexicon> thanks
16:07:36 <Cale> telexicon: It fails the associative law.
16:07:38 <telexicon> you know what.. screw this
16:07:49 <telexicon> im gonna go write an IRC bot and totally ignore monads
16:07:58 <Cale> telexicon: That's a better idea :)
16:08:02 <mofmog1> Cale: it fails?
16:08:06 <Cale> mofmog1: yep
16:08:06 <profmakx> but monads are cool!
16:08:09 <profmakx> and fluffy!
16:08:12 <telexicon> no
16:08:18 <BONUS> if you have (Just 3) >>= \a -> return (a+1) maybe you can read it like this: take what's in the box inside the Maybe and call it a. then increase a by 1 and then pack it up inside a box again
16:08:22 <telexicon> the are either really dull and not amazing at all
16:08:23 <Cale> You can't have a bind where you can detect how many times you've used bind.
16:08:30 <telexicon> or they are a maintenance nightmare
16:08:31 <mofmog1> oh right
16:08:42 <dmwit> telexicon: They are really dull, and not amazing at all.
16:08:50 <Cale> telexicon: They're just a way to classify a *very specific* type of library.
16:09:06 <telexicon> why not generalize it?
16:09:13 <Cale> telexicon: and the best way to understand which type of library is just to use a bunch of examples of them
16:09:24 <telexicon> why not make something that abstracts the concept of a computation and sequencing computations
16:09:36 <dmwit> telexicon: The problem is that everybody conceptualizes them a different way.  (libraries, boxes, computations, parse trees, containers, ...) -- and so there's this myriad of explanations.
16:09:40 <Cale> telexicon: Because generalising further reduces how useful the generic functions are.
16:10:02 <telexicon> ok thats fair
16:10:12 <Cale> Let's have a look a the three monad laws as written in do-notation.
16:10:29 <dmwit> Even worse, since you will eventually understand them differently from everybody else, it's virtually guaranteed that none of the current explanations match what will eventually be your understanding of monads. =P
16:10:32 <Cale> I think its clearest what they mean from a programming perspective that way.
16:10:33 <telexicon> BONUS, i can understand what that does without thinking anything special
16:11:13 <telexicon> it binds the 'value' to the 'function' and 'returns' it
16:11:27 <telexicon> in which, value, function and return are abstractions
16:11:33 <dibblego> http://haskell.org/wikisnapshot/StateMonad.html I think there is a typo, can someone confirm - (Branch left' right' rseed) doesn't look to type-check
16:11:34 <lambdabot> Title: StateMonad
16:11:43 <Philonous> dmwit: whereupon he will feel the urge to write another tutorial to monads that no one else can understand
16:11:50 <dmwit> telexicon: I guess what I'm saying is... try not to get frustrated.  Just use them a lot.
16:11:53 <Cale> 1. do { w <- return v; f w }
16:11:53 <Cale> == do { f v }
16:11:58 <Cale> This is the first monad law.
16:12:06 <telexicon> which is nice
16:12:08 <Cale> It basically tells us that return does nothing.
16:12:10 <dmwit> Philonous: yeah =)  ...and then he'll be surprised when other people complain that they can't understand them. =)
16:12:10 <telexicon> because for Maybe
16:12:15 <Cale> 2. do { v <- x; return v }
16:12:15 <Cale> == do { x }
16:12:26 <Cale> and this is the second, which completes that picture of return
16:12:30 <telexicon> Just 1 >>= \a -> return (a+1) -> Just 2
16:12:41 <telexicon> [1,2,3] >>= \a -> return (a+1) -> [2,3,4]
16:12:58 <Cale> Basically, it says that return produces a no-op which actually does return the value you give it
16:13:24 <Cale> Now let's look at the third, which seems to be the one that everyone misses when they struggle to define a new monad :)
16:13:31 <Cale> 3. do w <- do v <- x
16:13:31 <Cale>               f v
16:13:31 <Cale>       g w
16:13:31 <Cale>  
16:13:31 <Cale> == do v <- x
16:13:31 <Cale>       w <- f v
16:13:33 <Cale>       g w
16:13:41 <Cale> What is this saying?
16:14:18 <Cale> What it amounts to is that we can cut a chunk of lines out of a do-block and define it as a new action, and running that action will be the same as if the lines had been spliced in there.
16:14:34 <Cale> That is, it's the key to refactoring.
16:15:09 <mofmog1> Cale: can you redo #3 i think the indentation is messed up
16:15:16 <dmwit> No, it's right.
16:15:22 <telexicon> it only has 1 do
16:15:22 <Cale> mofmog1: hmm... you need a monospace font.
16:15:43 <dmwit> telexicon: There's two on the left, and one on the right of the ==.
16:16:15 <telexicon> k
16:16:19 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation -- you can also see it here, about halfway down the page
16:16:22 <lambdabot> Title: Monads as computation - HaskellWiki
16:16:32 <telexicon> im going to defer this until tomorrow
16:16:34 <Cale> (in case it's not showing up correctly)
16:16:50 <BONUS> yeah but anyway: just use the monads, don't worry too much about "getting" them
16:16:55 <Philonous> So basically monads are a generalization of sequencing. Like an overloaded semicolon in C++.
16:17:15 <BONUS> once you use them enough, you'll "get" them without knowing you did
16:17:19 <telexicon> i cant use them effectively if i dont understand them
16:17:31 <Cale> I think the particular monad which made things click for me was Parsec.
16:17:32 <telexicon> as shown by my attempt to make a Pair monad
16:17:41 <BONUS> you dont have to use them effectively at first, just use them
16:17:43 <BONUS> :)
16:17:45 <Cale> telexicon: Creating new monads is quite hard.
16:17:52 <qwr> telexicon: http://www.haskell.org/all_about_monads/html/index.html
16:17:53 <lambdabot> Title: All About Monads
16:18:05 <telexicon> no i already read that one
16:18:06 <telexicon> twice
16:18:11 <Cale> telexicon: It's best to use the ones in the libraries first, and get a really good feel for what's possible.
16:18:17 <dibblego> http://haskell.org/wikisnapshot/StateMonad.html there is a typo, but I am unsure what the correction is at (Branch left' right' rseed)
16:18:18 <lambdabot> Title: StateMonad
16:18:22 <BONUS> yeah, creating new monads requires really knowing the rules and knowing how a lot of other ones work
16:18:27 <telexicon> and i read monads as computation
16:18:49 <Cale> Have you tried using parsec at all?
16:18:57 <Cale> (or another parsing monad)
16:19:00 <dmwit> dibblego: probably a ',' after right'
16:19:04 <telexicon> i started to
16:19:08 <Cale> I found that's what really made the idea click in for me.
16:19:11 <telexicon> i dont remember what happened
16:19:22 <dibblego> dmwit, what still would not type-check
16:19:27 <dibblego> oh wait sorry
16:19:53 <BONUS> i dont understand completely how my car works but i can still drive it
16:20:13 <dmwit> dibblego: numberST sure seems pretty wrong, though.
16:20:18 <dibblego> dmwit, it seems odd that lseed is ignored
16:20:29 <dmwit> dibblego: ...it isn't.
16:20:42 <dibblego> hmm right
16:20:54 <telexicon> BONUS, but you're not in the business of engineering motor vehicles
16:21:16 <telexicon> you should probably know how a car works if you're building them
16:21:35 <dmwit> telexicon: Haskellers aren't in the business of creating new monads, either.
16:21:48 <BONUS> most of us, anyway
16:21:48 <dmwit> telexicon: We just reuse the existing ones; that's what they're there for.
16:22:08 <dmwit> Well, there's something like 50 interesting monads -- say 100 for the sake of argument.
16:22:09 <telexicon> sounds like a compromise
16:22:29 <dmwit> Given that the language has existed for 10 years in its current form, with hundreds of people hacking, that's a pretty low creation rate.
16:22:30 <BONUS> so i guess it's good to just trust yourself that you'll understand them eventually after some usage and maybe if you do some reading on them every now and then
16:22:42 <dmwit> telexicon: With monad transformers, it's not a compromise; you can combine the effects of several monads.
16:23:03 <dmwit> telexicon: This is kind of like "creating" a monad, but I don't count it, because you don't have to think very hard about satisfying the monad laws -- the library enforces them.
16:23:07 <qwr> telexicon: it's easier to first use them. you can delay creating them for some later time ;)
16:23:16 <telexicon> well ive used a bunch of them
16:23:21 <telexicon> ok.. 4
16:23:33 <BONUS> have you used State?
16:24:05 <dibblego> dmwit, what seems wrong about numberST? (getNext?)
16:24:45 <telexicon> bye
16:24:46 <dmwit> dibblego: The type, for one thing.  The "return Leaf (a, next)" line, for another.
16:25:11 <dmwit> dibblego: I guess it depends on what ST is.
16:29:02 <mofmog1> Cale: i think the monad laws could be more clear
16:29:11 <Cale> mofmog1: hm?
16:29:15 <Cale> mofmog1: where?
16:29:18 <BONUS> monad rule #1 should be: don't be frustrated about monads, just chill
16:29:19 <mofmog1> x >>= return == x should have the annotation that "x" is the whole monad
16:29:29 <Cale> "the whole monad"?
16:29:31 <Cale> x is not a monad
16:29:38 <mofmog1> Maybe 1 >>= return == Maybe 1
16:29:43 <Cale> x is a computation
16:29:46 <mofmog1> ^^ like that
16:29:48 <mofmog1> whereas
16:30:04 <BONUS> Maybe 1 is kind of misleading imho
16:30:06 <mofmog1> return v >>= f == f v should saying something to the effect of "v" is the thing that would go inside the constructor
16:30:10 <Cale> Maybe 1 ?
16:30:13 <mofmog1> er
16:30:14 <mofmog1> Just 1
16:30:14 <BONUS> cause Maybe ain't a value constructor
16:30:23 <mofmog1> (Just 1) >>= return == Just 1
16:30:24 <mofmog1> i mean
16:30:35 <Cale> But that's specific to the Maybe monad now.
16:30:51 <Cale> Isn't that exactly what the first law says?
16:30:59 <Cale> x >>= return = x for any x.
16:31:03 <mofmog1> well yes
16:31:13 <mofmog1> no second law
16:31:17 <Cale> er, okay
16:31:19 <Cale> second law :)
16:31:21 <mofmog1> in the context it's a little confusing and abstract
16:31:27 <Cale> hmm
16:31:45 <Cale> Well, I translate it into do-notation further down, is that clearer?
16:31:56 <mofmog1> i dont think so
16:31:58 <Cale> hmm
16:32:10 <mofmog1> for example, if someone were to come along and do
16:32:12 <Cale> Would it help to add a lambda?
16:32:12 <mofmog1> 1 >= return
16:32:18 <mofmog1> er 1 >>= return
16:32:22 <Cale> 1 >>= return is a type error of course
16:32:26 <mofmog1> yes exactly
16:32:30 <Cale> ...
16:32:41 <mofmog1> it's confusing as to why there is a type error
16:32:45 <Cale> oh?
16:32:54 <Cale> Because 1 is not of type m a
16:32:55 <int-e> "of course"? Maybe it's just a funny Num instance ...
16:33:04 <Cale> int-e: well, that's true.
16:33:11 <Cale> (but I think beside the point)
16:33:25 <dibblego> dmwit, shouldn't numberST :: Int -> Tree a -> Tree (Int, a) ?
16:33:27 <Cale> But I'm not sure :)
16:33:31 <Cale> Maybe that is the point :)
16:34:37 <int-e> mofmog1: in  return v >>= f  you can not say anything about the type of v. It can even be a monad action, as in  return (return ()) >>= id
16:34:43 <dmwit> dibblego: I don't think so.
16:35:03 <dibblego> dmwit, do you know of an example that is correct and simple?
16:35:12 <dmwit> dibblego: If type ST a = State Int a, and return Leaf (a, next) ---> return (Leaf (a, next)), that definition should work fine.
16:35:33 <dibblego> oh right
16:35:39 <dmwit> dibblego: You also need to define getNext = modify succ.
16:35:41 <dibblego> I see what you mean
16:35:56 <dibblego> where is modify defined?
16:36:03 <dmwit> Control.Monad.State.
16:36:06 <dmwit> But you could also write
16:36:15 <dmwit> getNext = do { x <- get; put (x+1) }
16:36:25 <dmwit> It probably gets compiled to the same Core, even.
16:37:02 <mofmog1> Cale: x <- return a is return a >>= \x -> ??? right?
16:37:12 <Cale> yep
16:37:28 <BONUS> anyone know of any practical usages of Kleisli arrows? im just reading up on them, they seem real neat
16:37:29 <Cale> where ??? is the rest of the do-block
16:37:50 <mofmog1> So how i read the first law is that after you use a >>= on the return, the data inside the functor is taken out and fed to f
16:38:00 <mofmog1> meaning that return is the opposite of bind in a sense
16:38:04 <Cale> hmm
16:38:13 <Cale> In a certain sense, it is.
16:38:18 <mofmog1> that's why >>= return will return what you gave it
16:38:18 <BONUS> yeah
16:38:31 <mofmog1> x >>= return == x because >>= is the same thing as doing ~nothingatall~
16:38:41 <Cale> well,  x >>= return = x, because the law says it is ;)
16:38:43 <mofmog1> it's just a difference of what you can put in
16:38:49 <mofmog1> well i see that as
16:38:54 <mofmog1> you unpackage then you repackage x
16:39:02 <int-e> @src (>=>)
16:39:03 <lambdabot> Source not found. You speak an infinite deal of nothing
16:39:05 <Cale> kind of, sure.
16:39:08 <mofmog1> you unwrap a present, but then you rewrap it
16:39:14 <BONUS> i'd say you unpackage it and then feed it to a function that repackages it
16:39:16 <Cale> In exactly the same way.
16:39:18 <mofmog1> the only condition is that x has to be wrapped int he first place
16:39:28 <mofmog1> well the second law deals with return so you're repackaging it in the same way
16:39:41 <Cale> Note that without the formal law, this kind of language is a bit unclear.
16:39:56 <BONUS> yeah it is, but it helps people understand imho
16:40:09 <mofmog1> well to satsify the first two laws you have to define return and bind in such a way that using one after the other will result in the same thing
16:40:12 <BONUS> i think the best way is to explain it in simple terms to people at first even if its not entirely correct and to the law
16:40:25 <Cale> BONUS: sure.
16:40:27 <BONUS> once they get it, you can formalize it with laws
16:40:37 <Cale> BONUS: But I think putting the laws in front of them is also important :)
16:40:49 <BONUS> definitely
16:40:50 <dibblego> @type modify succ
16:40:51 <lambdabot> forall s (m :: * -> *). (MonadState s m, Enum s) => m ()
16:40:56 <mofmog1> well you also have to give them the intuition
16:41:00 <Cale> After all, with this vague language of unwrapping and rewrapping things, could we have  [1,2,3] >>= return = [3,1,2] ?
16:41:09 <Cale> It's not clear...
16:41:24 <BONUS> hmm
16:41:26 <mofmog1> but lists are ordered so you wouldn't be wrapping it in the correct way
16:41:39 <BONUS> i think of the list as a superposition of the value
16:41:40 <dibblego> dmwit, don't you want getNext :: (MonadState s m, Enum s) => m s ?
16:41:46 <Cale> mofmog1: Right. But only the monad law tells you what the correct way is :)
16:41:52 <BONUS> or like a box in a box in a box ...
16:42:04 <mofmog1> of course, but it deserves more intuition
16:42:18 <mofmog1> i actually think the only way to clearly explain monads is via a video
16:42:33 <mofmog1> sorta like mechanical universe where you can see the data going from one end to another
16:42:34 <BONUS> well a lot of people have learned them via text :)
16:42:42 <dmwit> dibblego: You're right, of course.
16:42:46 <mofmog1> well, it's obviously too abstract to be done effectively
16:42:51 <mofmog1> imho
16:43:01 <mofmog1> people don't say, "OH NO POINTERS ARE HARD!"
16:43:04 <ddarius> BONUS: A Kleisli arrow is just another way of presenting monads.
16:43:17 <mofmog1> they say they're hard to deal with but the concept is easy
16:43:28 <BONUS> yeah, an arrow of a -> m b
16:43:36 <mofmog1> the problem is that monads are defined and presented way too abstractly
16:45:34 <idnar> I think the problem is that everyone has their own mental conceptualization of monads :P
16:45:57 <mofmog1> perhaps they are TOO general
16:46:05 <mofmog1> so it's impossible to explain everything at once
16:46:21 <mofmog1> no, too general is wrong, they are too "all encompassing"
16:46:28 <idnar> on the other hand, maybe the concept just needs to become more widespread
16:46:56 <idnar> I've seen people struggle to understand pointers just as much as I've seen people struggle to understand monads
16:46:57 <mofmog1> the worst is when someone tries to answer what a monad is and starts off with, "a monad is a triple... blabhalhblahb"
16:46:59 <bbs> hey i have a parser
16:46:59 <mofmog1> that just loses everyone
16:47:03 <BONUS> that may be a problem when trying to explain them but it's not a problem with monads generally
16:47:04 <bbs> and a interpreter that i'm working on
16:47:07 <bbs> http://zlin.dk/p/?ZDQ3ODdi
16:47:08 <bbs> parser
16:47:10 <lambdabot> Title: K-nopaste
16:47:17 <bbs> interpreter
16:47:19 <bbs> http://zlin.dk/p/?ZDQ3ODdi
16:47:20 <lambdabot> Title: K-nopaste
16:47:22 <BONUS> thats like saying that the problem with circles is that they are too round
16:47:25 <BONUS> its just what they are
16:47:28 <mofmog1> yes
16:47:41 <wchogg> @seen conal
16:47:41 <lambdabot> I saw conal leaving #haskell 2h 18m 52s ago, and .
16:47:42 <int-e> mofmog1: monads are abstract - they're so abstract that you'll likely get more out of concrete examples for monads, like Maybe, the list monad, the reader and state monads, then transformers ... somewhere inbetween you should "get" the notion that monads are really just about writing some operations in a sequence, with possible dependencies of followup operations on previous operations.
16:48:05 <mofmog1> int-e: exactly that's what it is
16:48:08 <BONUS> well put
16:48:22 <mofmog1> but the confusing part i think is in the whole mechanics of it
16:48:24 <wchogg> Maybe I'm weird, but I thought "All About Monads" was really the last needed monad tutorial.
16:48:35 <mofmog1> perhaps the problem is that they're presented too bottoms up?
16:48:44 <mofmog1> top down might be better?
16:48:58 <heatsink_> They should be presented in limerick form.
16:48:58 <int-e> meet in the middle *g*
16:50:02 <ushdf> *g*?
16:50:09 <ushdf> what the hell's going on in here
16:50:09 <heatsink_> "giggle"
16:50:16 <ushdf> !offtopic
16:50:50 <ushdf> stupid bots
16:51:01 <ushdf> > exception "OFFTOPIC!"
16:51:02 <lambdabot>   Not in scope: `exception'
16:51:04 <int-e> @bot
16:51:04 <lambdabot> :)
16:51:13 <ushdf> aw
16:51:33 <int-e> lambdabot is adorable *g*
16:51:53 <mofmog1> Perhaps the best way of doing it is, say that there is a pattern of composing functions that deal with one data type (eg, lists, Maybe etc) and that this pattern can be generalized into the concept of a monad
16:52:08 <mofmog1> but before saying what the mechanics of a monad is, the patterns should be explained
16:52:24 <Cale> I think probably we don't put enough effort into explaining functional library design.
16:52:32 <mofmog1> perhaps
16:52:33 <Cale> Which is the real thing people struggle with.
16:52:49 <mofmog1> i mean, it's easy enough to explain the IO monad and leave it as magic
16:52:56 <Cale> A lot of monads specifically require using functions as data in ways which non-functional programmers are going to choke on.
16:53:04 <mofmog1> but then when you try to do state people wonder, "wtf do i have to use run state?!"
16:53:47 <BONUS> for a long time i was confused with State because i thought it represented some state
16:53:49 <BONUS> because of the name
16:53:57 <BONUS> whereas it actually represents a state transition
16:54:09 <lispy> yeah
16:54:16 <lispy> a state flow and transition
16:54:28 * ushdf remembers that
16:54:34 <BONUS> a transition from one state to another with a result
16:54:37 <BONUS> kind of like that :)
16:54:52 <mofmog1> i think of it like pipes
16:55:04 <mofmog1> and runstate is sorta like putting stuff in one end
16:55:59 <mofmog1> actually they're all pipes 0_0\
16:56:30 <bbs> Cale: can you hlep me for a moment?
16:56:37 <Cale> bbs: sure
16:56:40 <bbs> i need to get the operational semantics down
16:56:41 <mofmog1> actually, the way i try to motivate it to people at my school (people here know scheme) is that you wanna do a bunch of things but you want to explicitly say that things go first
16:56:43 <bbs> overflow?
16:56:48 <bbs> or here?
16:56:52 <int-e> mofmog1: the pipe image is a bit troublesome for the list monad
16:57:00 <Cale> either
16:57:05 <mofmog1> int-e: then I think of it like a bunch of maps
16:57:07 <mofmog1> but special
16:57:16 <ushdf> http://tinyurl.com/64bbkz
16:57:18 <Philonous> "runstate" sounds to me like something that should be a comonad has been forced into a monad.
16:57:19 <ddarius> Cale: My impression is that people usually can use monads easily (and when they can't it's usually a failure to understand types that is the root cause).  It's making new ones (or rather understanding the implementations) where people really seem to have trouble.
16:57:20 <ushdf> that's my song, i wrote it for #haskell
16:57:21 <ushdf> specifically
16:57:22 <lambdabot> Title: Music Review: Jimi Hendrix - Crash Landing and Midnight Lightning
16:57:27 <ushdf> Cale
16:57:41 <mofmog1> ddarius: yes!
16:57:46 * ushdf throws his chair at the wall
16:57:47 <Cale> ddarius: yes, that's a good point as well
16:57:50 <ushdf> nobody leaves till i say!
16:58:03 <mofmog1> i mean, we can't say taht the current state of tutorials is satisfactory
16:58:07 <Saizan> mofmog1: thinking of monads as sequencing is a bit reductive, they are more a tool to abstract away the glue you need to compose particular functions
16:58:18 <mofmog1> Saizan: well yeah essentially
16:58:31 <ddarius> mofmog: Have you read Wadler's papers?
16:58:32 <mofmog1> but i try to motivate it as sequencing
16:58:38 <int-e> Saizan: the trick is to use the right concept of "sequencing" :)
16:58:41 <mofmog1> i admit, not
16:58:48 <BONUS> reading through implementations of the various monads really helps one understand the common patterns that monads share
16:58:52 <int-e> Saizan: it's really more syntactical in the end than operational.
16:59:03 <ddarius> mofmog: Try "The Essence of Functional Programming" or "Monads for Functional Programming" (I think that latter title is correct)
16:59:11 <ushdf> > map (cos . sin) [1..1000]
16:59:13 <lambdabot>   [0.6663667453928805,0.6143002821164822,0.9900590857598653,0.727035131168812...
16:59:17 <ddarius> BONUS: I wouldn't say so.
16:59:31 <ushdf> > foldr (+) 1 (map (cos . sin) [1..1000])
16:59:32 <BONUS> really? i feel it helped me
16:59:32 <lambdabot>   766.1057288490807
16:59:39 <ddarius> It does help dispel the notion that a monad is one particular instance.
16:59:42 <Saizan> int-e: heh right, i should have specified temporal
17:00:14 <ddarius> BONUS: I'd say the implementations help highlight the possible diversity rather than highlighting the similarity.
17:00:21 <BONUS> hmm
17:00:22 <mofmog1> does there exist a functor for which bind can be defined in two different ways?
17:00:30 <ddarius> Sure.
17:00:41 <mofmog1> for example, with list?
17:00:43 <BONUS> but the similarity is still there, for instance i saw the similarities between Right and Just
17:00:49 <ddarius> You could easily make an example with list.
17:00:51 <BONUS> lol
17:00:56 <mofmog1> because sometimes i think the list monad is a little arbitrary
17:01:06 <mofmog1> or the explanation doesn't say why it isn't
17:01:07 <ddarius> BONUS: That's because Maybe a ~ Either () a
17:01:09 <BONUS> and Left and Nothing
17:01:10 <BONUS> yeah
17:01:15 <BONUS> exactly
17:02:10 <BONUS> also the pattern of getting the value out of the left side of >>= either by pattern matching on the constructor or applying f in ((->) a)
17:03:00 <mofmog1> also there needs to be a big list of what type definitions mean
17:03:04 <BONUS> also how >>= has to eventually construct the same type. i mean you can get that from the laws and tutorials, but seeing it hands on helped me a lot
17:03:06 <mofmog1> for example ((->) a)
17:03:20 <BONUS> a big list?
17:03:26 <BONUS> (->) a is a type constructor, that's it
17:03:33 <lispy> Well, types mean a lot to haskell experts, but they mean much less to beginners
17:03:39 <BONUS> of kind * -> *
17:03:41 <ddarius> lispy: Indeed.
17:03:47 <mofmog1> what -kind- of type constructor
17:03:49 <mofmog1> what does it do
17:03:52 <mofmog1> what does it return
17:04:01 <ddarius> lispy: Developing an appreciation of what types can tell you and do for you is a significant benefit and part of learning Haskell.
17:04:04 <mofmog1> in a tangible "i can work with this" way
17:04:09 <int-e> type constructors return types *g*
17:04:22 <dibblego> what is the name of a binary tree where only the leaves contain data values?
17:04:28 <mofmog1> but what is the (->) type
17:04:32 <halberd> trie?
17:04:33 <ddarius> dibblego: A binary leaf tree.
17:04:33 <BONUS> function
17:04:38 <dibblego> (->) is a type constructor, not a type
17:04:49 <BONUS> (->) a b is the same as writing a -> b
17:04:56 <ddarius> dibblego: There isn't really standard terminology for these things, I don't think.
17:04:59 <mofmog1> yes, thank you
17:05:04 <dibblego> ddarius, ok cheers
17:05:09 <ddarius> :k Maybe
17:05:10 <lambdabot> * -> *
17:05:12 <ddarius> :k (->)
17:05:13 <lambdabot> ?? -> ? -> *
17:05:15 <BONUS> kind of like how (,) a b is (a,b)
17:05:16 <ddarius> :k Either
17:05:17 <lambdabot> * -> * -> *
17:05:19 <Pseudonym> I agree, no standard terminology, but if you want a search tree, consider a 2-3 tree.
17:05:24 <int-e> :k () -> ()
17:05:26 <lambdabot> *
17:05:42 * ddarius matches Pseudonym and raises him a 2-3-4 tree.
17:05:58 <Pseudonym> 2-3-4 trees don't store data only in leaves.
17:06:03 <lispy> Oh, the kind of Either is delightful and gives me an idea
17:06:14 <Pseudonym> 2-3 trees are a degenerate type of B-tree/.
17:06:27 <ddarius> Binary trees are a degenerate type of B tree.
17:06:42 * lispy is degenerate
17:06:43 <Pseudonym> No.  Binary trees don't have the crucial split operation.
17:07:23 <Pseudonym> FWIW, Mercury's equivalent of Data.Map is actually 2-3-4 trees.
17:07:56 * ddarius stops being contrary.
17:08:26 <Pseudonym> Indeed, but I thought I'd mention it because 2-3 and 2-3-4 trees have very little in common, algorithmically speaking.
17:08:34 <Pseudonym> It's quite confusing.
17:08:43 <Pseudonym> Like you said, there's no standard terminology.
17:11:24 <heatsink_> Behold the great monad called List / that yields results with a twist: / For inspection conclusive / of choices exclusive / concat them, if you get my gist.
17:13:47 <lokathor> question, I've got a function, "printPrice :: String -> IO ()", and i get the command line args with getArgs to get a [String], how do i apply printPrice to each argument?
17:13:58 <mauke> mapM_
17:14:02 <lokathor> doesn't Monad have some special form of map for this?
17:14:06 <lokathor> hmm
17:14:28 <lokathor> this type signature looks... strange
17:14:54 <mauke> :t mapM_
17:14:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
17:14:56 <Cale> lokathor: It depends on what you really want the result to be.
17:14:56 <lokathor> so it'd be, mapM_ pricePrint args
17:14:57 <lokathor> ?
17:15:08 <Cale> lokathor: mapM_ is the most likely one :)
17:15:10 <mauke> a = String, m = IO, b = ()
17:15:27 <Cale> lokathor: If you just map printPrice over the list of strings, you'll get a list of actions.
17:15:29 <sclv> ?remember heatsink Behold the great monad called List / that yields results with a twist: / For inspection conclusive / of choices exclusive / concat them, if you get my gist.
17:15:29 <lambdabot> I will never forget.
17:15:31 <byorgey> @seen roconnor
17:15:31 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 8h 30m 29s ago.
17:15:58 <Cale> lokathor: which might be useful sometimes, but probably isn't actually what you want here :)
17:16:01 <byorgey> @ask roconnor are you planning to add support for HSV to the colour library?
17:16:02 <lambdabot> Consider it noted.
17:16:04 <sclv> ?src mapM
17:16:04 <lambdabot> mapM f as = sequence (map f as)
17:16:11 <roconnor> byorgey: I have plans
17:16:12 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
17:16:15 <sclv> mapM is doing that mapping, and then sequencing it.
17:16:24 <sclv> ?ty sequence
17:16:25 <Cale> lokathor: So something has to be done to put those actions together into a single action which you can run to run them all.
17:16:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:16:26 <roconnor> sneaky sneaky plans
17:16:31 <byorgey> hehe, ok =)
17:16:39 <BONUS> hey, anyone know if the MacPorts ghc installation features mtl?
17:16:49 * sclv remembers not to jump ahead of Cale when he's explaining something.
17:16:50 <BONUS> i dont have a mac so i cant try it :X
17:16:52 <lokathor> I each "pricePrint" prints a single line, so i just want it to print one line per argument
17:17:01 <Axman6> BONUS: how would i check?
17:17:03 <roconnor> I'm thinking of releasing a 1.0.0 version with just sRGB today or tomorrow.
17:17:08 <Cale> sclv: :)
17:17:33 <BONUS> Axman6: tbh i dont know, probably by just installing ghc via macports and then trying to import, say, Control.Monad.State or something
17:17:49 <Cale> lokathor: Right. So you want forM or mapM (or one of the versions with the _ after them, since the results of each iteration are not interesting here)
17:18:06 <lokathor> how is forM different from mapM?
17:18:12 <mauke> @src forM
17:18:13 <lambdabot> forM = flip mapM
17:18:16 <Cale> lokathor: The arguments are in the opposite order
17:18:16 <dibblego> lokathor, it's not; it's just flipped
17:18:20 <Axman6> Prelude Data.Number.CReal> :m +Control.Monad.State
17:18:20 <Axman6> Prelude Data.Number.CReal Control.Monad.State>
17:18:24 <Cale> Which makes it more like a for loop.
17:18:24 <lokathor> ah ha
17:18:27 <Axman6> BONUS: seens to work finw
17:18:28 <Axman6> e*
17:18:32 <lokathor> well it appears to work perfectly with mapM_
17:18:34 <lokathor> thanks all
17:18:40 <BONUS> Axman6: awesome, thanks!
17:18:53 <Cale> forM [1..10] $ \x ->
17:19:01 <Cale>   do print x; getLine
17:19:10 <Axman6> no worries :)
17:19:47 <Cale> You can try something like that, and see that it really is like  for x = 1 to 10 do print x; getLine
17:20:21 <juhp> does anyone have a patch for ghc682 to build with gcc43?
17:21:00 <Cale> For 6.8.2 specifically? Does it not build?
17:21:24 <Cale> (that's a couple versions back now, there's 6.8.3, and 6.10 is about to be released)
17:21:51 <Axman6> Cale: any idea how soon?
17:22:05 <maxote> the ghc experts should do ghc stable
17:22:10 <Cale> Axman6: I'd imagine quite soon, given that the current version is a release candidate
17:22:19 <Axman6> excellent
17:22:30 <Axman6> if it's the fifth, i'll be happy. another nice birthday present :)
17:22:32 <Cale> But there are apparently some bugs.
17:22:41 <Cale> (so maybe they're going to fix those)
17:22:42 <maxote> or arrows will go nowhere
17:22:57 <Cale> maxote: hm?
17:31:26 <juhp> Cale: I know there are newer version but would like to be able to build 6.8.2 on Fedora 9
17:31:49 <Cale> juhp: Is there a good reason not to use the generic linux binary?
17:32:06 <Cale> Oh, different gcc? Does it not work for some reason?
17:32:35 <juhp> Cale: ... Fedora packaging :)
17:33:03 <juhp> hmm maybe I could try gcc-3.4 instead
17:37:36 <juhp> hmm wonder why I didn't think of that before
17:45:21 <dmwit> Wow, HWN is readably short this week.
17:45:38 <dmwit> Also, that Nario thing looks pretty good, right up to the end. =P
17:45:55 <dolio> What happens at the end?
17:46:07 <dmwit> Watch it and find out... it's only 30s long or so.
17:46:08 <dmwit> =)
17:46:21 <dmwit> http://uk.youtube.com/watch?v=gVLFGQGRsDw
17:46:21 <lambdabot> Title: YouTube - Making 'Super Nario Bros.' in Haskell
17:46:26 <dmwit> Oh, 2 minutes.
17:47:07 <dolio> Oh. I did watch that. Apparently I've already forgotten what happens at the end, though.
17:48:53 <dolio> Ah, heh.
17:48:54 <dmwit> The list of related videos is pretty questionable.
17:49:13 <juhp> hmm gcc34 didn't help either...
17:49:25 <juhp> stage1/coreSyn/PprCore.o: In function `r3u6_closure':
17:49:26 <juhp> (.data+0x250): multiple definition of `IdInfo_megaSeqIdInfo_closure'
17:50:17 <juhp> so it is not the gcc version as I suspected
17:50:50 <juhp> start to wonder how it ever built...
17:51:34 <juhp> ah wait
17:52:36 <juhp> no
17:54:41 <heatsink> Hey, there's a link to Monadius.  I like its graphical style.
17:54:46 <roconnor> I find this Supper Nario video unbelievable
17:55:01 <roconnor> in that I don't believe it
17:55:08 <dmwit> You will believe it.
17:55:10 <dmwit> Wait for it.
17:55:20 <roconnor> anyone here built it themselves?
17:55:41 <dmwit> There's a repository.  If you don't believe it, why not try it?
17:55:59 <roconnor> I wonder if I have the dependecies
18:00:20 <roconnor> Could not find module `Multimedia.SDL'
18:00:22 <roconnor> ah well
18:00:54 <roconnor> but the existance of a public repository is pretty convincing
18:03:12 <rwbarton> roconnor: if you're talking about nario, apply http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=336
18:04:36 <Dover> hello
18:04:47 <Dover> can i improve this function
18:04:52 <Dover> to get less line code?
18:05:15 <Dover> http://rafb.net/p/WaH19p57.html
18:05:24 <heatsink> If it has more than one line, you can certainly get fewer lines of code.
18:05:51 <dolio> Wow.
18:06:01 <Dover> i think is a shit lol
18:06:15 <Dover> i am learning haskell
18:06:41 <dolio> I'd split it into two functions at least.
18:06:58 <dolio> One for month and one for day.
18:07:15 <heatsink> (mes == ?) && (dia == ?) = (algo que depende solo en 'mes') ++ (algo que depende solo en 'dia') ++ (algo que depende solo en 'ano')
18:07:30 <heatsink> You should split it into one function for month, one for day, and one for year.
18:07:45 <heatsink> Then you can reduce the function to one line
18:08:04 <heatsink> ej8 (dia, mes, ano) = month mes ++ day dia ++ year ano
18:08:33 <Dover> mmm
18:08:36 <Dover> thx a lot guys
18:08:55 <Dover> i though that it was a great shit but didnt know how to do
18:08:57 <heatsink> Also, you have a bug. 22 -> "22nd", not "22th"
18:09:07 <heatsink> 21 -> "21st", not "21th"
18:09:09 <Dover> mm
18:09:11 <Dover> ouch
18:09:14 <sbahra> Is bytestring part of base?
18:09:58 <Dover> and how can repair that bug
18:10:24 <Dover> are ther a fuction to manipulate characters of a string
18:10:26 <Dover> isn it?
18:10:44 <Dover> i dont speak english too well soz :/
18:10:56 <dibblego> yes in Data.List
18:11:21 <Dover> ok guys
18:11:25 <Dover> i will go sleep
18:11:29 <Dover> tomorrow more questions :P
18:11:33 <Dover> thx for your time
18:11:46 <heatsink> np :)
18:11:47 <Dover> i think i will repair this and another function called next_day
18:12:03 <Dover> and made all
18:12:06 <Dover> using guards ^^
18:12:27 <Dover> cya
18:28:44 <dmwit> Yikes!
18:28:50 <dmwit> Any reason not to use Data.Time there?
18:29:34 <dmwit> I know I'm a bit late to the game, but (ej8 = formatTime "some %s go here") seems much more maintainable...
18:30:41 <heatsink> I didn't know there was a library for that.  I think it might have been an exercise.
18:30:58 <dmwit> yeah
18:31:04 <dmwit> I'm hoping so.
19:02:42 <sbahra> lambdabot hasn't rejoined his channels?
19:02:48 <sbahra> s/his/her/
19:07:41 <Cale> oh, it appears it's not registering for some reason
19:07:47 <vesz> Hi, I'm trying to write a function 'twice' that runs a function twice, and I think that I'm supposed to use lambda expressions for it but then again I don't know if that's possible. twice f x = \f x -> f (f x) or should I simply skip the lambda stuff and type twice f x = f (f x)
19:07:59 <Cale> vesz: the latter
19:08:07 <EvilTerran> vesz, both are correct, the latter is considered better style
19:08:20 <Cale> vesz: If you wanted to write it as a lambda, you could write  twice = \f x -> f (f x)
19:08:21 <EvilTerran> er, actually, the first would be "twice = \f x -> f (f x)"
19:08:34 <vesz> Thanks, the thing is, I can't even get the first one to work, is it supposed to work?
19:08:39 <vesz> oh, that might be the reason that it's not working
19:08:52 <Cale> Also, it'll be subject to the monomorphism restriction...
19:09:01 <Cale> which will be annoying
19:09:12 <Cale> (so you may have to add a type signature)
19:09:19 <Cale> (or turn the MR off)
19:09:32 <EvilTerran> vesz, in the first one you wrote, you're telling it that there's two parameters "f" and "x", followed by another two parameters "f" and "x"
19:09:52 <EvilTerran> the first two from the "... = ...", and the second two from the "\ ... -> ..."
19:10:37 <EvilTerran> vesz, also note you could write "twice f = f . f"
19:10:48 <vesz> Cale, I'll try adding a type signature thanks, haven't used haskell in a while and they just bumped an assignment on us in another course 4 years later, and I'm trying to figure it out :)
19:10:57 <vesz> EvilTerran: oh
19:11:13 <EvilTerran> > (f . g) x :: Expr
19:11:14 <lambdabot>   Add a type signature
19:11:14 <vesz> EvilTerran: lets say I wanted trice then
19:11:16 <EvilTerran> ...
19:11:17 <vesz> with fancy "
19:11:24 <rwbarton> Does the MR apply even though there's no type classes involved?
19:11:27 <vesz> f . f" . ?
19:11:32 <EvilTerran> vesz, fancy whatnow?
19:11:46 <vesz> sorry :) bad at expressing myself
19:12:03 <EvilTerran> vesz, the quotemarks (") are just me indicating the separation between bits of haskell and the surrounding text
19:12:11 <EvilTerran> ?src (.)
19:12:11 <lambdabot> (f . g) x = f (g x)
19:12:28 <EvilTerran> nice simple identity there that explains what (.) does in the most direct way possible
19:12:30 <vesz> EvilTerran: aha, sorry made a fool of myself, didn't notice the first one
19:13:00 <Cale> vesz: The monomorphism restriction bit only applies if you write it like  twice = \f x -> f (f x)  though
19:13:20 <EvilTerran> twice f x = (twice f) x = (f . f) x = f (f x)  -- using twice f = f . f
19:13:23 <Cale> If you write it as  twice f x = f (f x)  it'll get the type right.
19:13:41 <vesz> lambdabot: okay, lots of alternatives :)
19:13:47 <Cale> It's just a silly restriction about pattern bindings being monomorphic unless explicitly stated otherwise.
19:14:17 <vesz> Cale, EvilTerran okay I'll try one of those that you gave me, and play around with it a little bit, thanks
19:14:35 <Cale> @flush
19:14:36 <rwbarton> Cale: I don't think the MR applies here
19:14:40 <Cale> rwbarton: Oh?
19:15:00 <rwbarton> Well, it doesn't from my testing.
19:15:32 <dmwit> There's no parametric polymorphism.
19:15:48 <rwbarton> dmwit: do you mean type class polymorphism?
19:15:56 <EvilTerran> dmwit, ... isn't there? there's no ad-hoc polymorphism...
19:16:15 <Cale> Haskell doesn't support ad-hoc polymorphism...
19:16:17 <EvilTerran> ?type let { twice f = f . f } in twice
19:16:18 <lambdabot> forall c. (c -> c) -> c -> c
19:16:32 <dmwit_> What did I miss?
19:16:38 <EvilTerran> Cale, blame my lecturer who referred to classwise polymorphism as ad-hoc
19:16:40 <rwbarton> ad-hoc polymorphism meaning type class polymorphism here
19:17:29 <dmwit> Anyway, the MR definitely only restricts type-class polymorphism.
19:18:00 <rwbarton> dmwit: OK, that was my impression, but I don't remember ever seeing that written down.
19:19:46 <shapr> I have a "Prelude.read: no parse" error somewhere in my code, how do I track it down?
19:20:07 <dmwit> ack "\<read\>" # ;-)
19:20:12 <dmwit> How big is "my code"?
19:20:15 <shapr> um
19:20:28 <shapr> about 2k lines
19:20:32 <shapr> not including imported libs
19:20:39 <shapr> and not including hs-boot files
19:20:51 <dmwit> yummy
19:20:51 <Cale> oh, of course, right.
19:21:02 <Cale> There's no typeclasses here, duh :)
19:21:19 <heatsink> Do you need to narrow it down to a callsite?
19:21:26 <shapr> dmwit: Only 23 uses of read though.. wasn't there a safeRead or something at one point?
19:21:29 <shapr> heatsink: Yeah, would be nice.
19:21:41 <dmwit> shapr: Sure, reads, but it has a different type.
19:21:58 <dmwit> shapr: You could use Debug.Trace in front of all the calls to trace.
19:21:59 <heatsink> I'd write a function traceAndRead :: Read a => String -> String -> a
19:22:03 <dmwit> Name them uniquely, and you're done.
19:22:07 <shapr> Yeah, good point.
19:22:11 <shapr> I'll try that.
19:22:23 <dmwit> s/calls to trace/calls to read/
19:23:05 <Cale> sbahra: We can hope that lambdabot will join all its channels now ;)
19:23:13 <Cale> sbahra: Let me know if it doesn't
19:23:15 <heatsink> @seen lambdabot
19:23:20 <lambdabot> Yes, I'm here. I'm in #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-
19:23:26 <lambdabot> haskell, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
19:24:14 <heatsink> Are there a lot of gentoo users in Uruguay?
19:33:54 <EvilTerran> shapr, you could do something with the CPP, i think; something involving #define read (... __LINE__ ...)
19:38:58 <EvilTerran> shapr, or slightly more tidily with TH's "report" function
19:40:31 <EvilTerran> actually, that wouldn't work. i don't think you can readily get at the line numbers with TH
19:40:38 <EvilTerran> i don't think it'd even make much sense a lot of the time
19:43:29 <vesz> Another question, quite similar to the one I asked a little while ago, yet I can't get it to work. Trying to make a 'church' function that generates a series of calls to the same function http://hpaste.org/11698. That's the best I've come up with, but it only runs the function once, always.
19:44:54 <dmwit> :t iterate
19:44:55 <lambdabot> forall a. (a -> a) -> a -> [a]
19:45:06 <heatsink> shouldn't church n be \f x -> f (church (n - 1) f x) ?
19:46:18 <dmwit> :t let church 0 f x = x; church n f x = f (church (n-1) f x) in church
19:46:18 <lambdabot> forall t t1. (Num t) => t -> (t1 -> t1) -> t1 -> t1
19:46:37 <dmwit> vesz: You're not passing enough things to the sub-call in the second line.
19:46:44 <vesz> heatsink: perhaps,  I'm not very seasoned at this :) how do I make church stop then?
19:47:08 <vesz> dmwit: do I need to pass 'x' as well? but where?
19:47:24 <vesz> since church is stealing the spot :)
19:47:29 <dmwit> Well, I've already written the answer.  But for an explanation...
19:47:44 <dmwit> "church" needs to have a successor function and a zero.
19:47:45 <heatsink> vesz: You make it stop by defining a nonrecursive case for church.  You have done this.
19:47:51 <dmwit> But in your second call, you've given it neither of these.
19:48:03 <dmwit> So "f" is being called on a *function*.
19:48:08 <dmwit> Which most likely isn't what you wanted.
19:48:57 <dmwit> i.e. it will be a lot easier for you at the beginning if you fully saturate your function calls.
19:49:39 <vesz> dmwit: I had some problem creating the zero for the function cause I didn't know how to represent a function that was nothing ( I'm not sure I'm even talking about the thing that you are trying to tell me here thou)
19:50:02 <dmwit> You don't have to create a zero.  It's one of the arguments to church.
19:50:17 <dmwit> i.e. 'x' in the nomenclature of your paste.
19:54:28 <vesz> I'm a tad lost I'm afraid. Isn't every "f" being called with the result from the previous "f"?
19:54:34 <vesz> not with an actual function
19:54:53 <dmwit> In the correct implementation, yes.
19:56:06 <dmwit> vesz: Look at what you've written for "church n":
19:56:12 <dmwit> church n = \f -> f (church (n-1))
19:56:26 <dmwit> So you're calling "f" on a recursive call to "church".
19:56:29 <dmwit> So far so good.
19:56:44 <dmwit> But what is the type of "church (n-1)"?
19:56:56 <dmwit> Forget that.
19:56:57 <vesz> oh wait! I changed that line, but I accidently pasted the old one
19:57:02 <dmwit> Ah!
19:57:04 <dmwit> ok =)
19:57:06 <vesz> church n = (\f x -> f x) church n-1
19:57:09 <vesz> it's like that now
19:57:23 <vesz> which doesn't work either, but I thought it was better :)
19:57:24 <dmwit> hm
19:57:28 <dmwit> Still not so good.
19:57:34 <dmwit> Let's reduce, shall we?
19:57:48 <dmwit> (\f x -> f x) church (n-1) -- I added parens, but you should agree with this change
19:57:59 <vesz> okay, I'll try to keep up with you, I'm not that good at haskell I'm afraid
19:58:03 <vesz> yeah looks fine
19:58:18 <dmwit> (\x -> church x) (n-1) -- substitute "church" for "f"
19:58:32 <dmwit> church (n-1) -- substitute "(n-1)" for "x"
19:58:44 <dmwit> So we're left with
19:58:48 <dmwit> church n = church (n-1)
19:58:52 <dmwit> Not so useful. =)
19:59:08 <vesz> okay, gimme a second to read it a bit more carefully
19:59:13 <dmwit> right
20:00:57 <vesz> yeah, okay I remember now and understand it. Even what it was called :) Alfa-conversion! I think
20:01:06 <dmwit> This is actually beta reduction.
20:01:18 <vesz> oh, I thought that was when you had only 1
20:01:22 <dmwit> Alpha conversion would change (\f x -> f x) to (\g x -> g x).
20:01:32 <vesz> oh, yeah, nevermind I mixed them up
20:01:34 <dmwit> (for example)
20:01:55 <dmwit> They're easy to swap, I think.
20:02:23 <dmwit> The key for me has been associating the meaning with "conversion" and "reduction", respectively, and then getting in the habit of sticking the Greek letter on later. =)
20:02:40 <vesz> :)
20:02:53 <ddarius> "alpha" "alphabet" "renaming"
20:03:11 <vesz> I'll try to come up with something better, bearing this in mind. I think might be back here quite soon thou
20:03:15 <heatsink> Oh, so it does mean something!  What do beta and eta stand for?
20:03:28 <ddarius> heatsink: That's not where it comes from (I'm fairly certain)
20:03:37 <heatsink> hmm.
20:03:43 <ddarius> It's just a potentially useful mnemonic.
20:04:12 <ddarius> clear
20:08:57 <vesz> dmwit: you still there? I'm blank, I can't possibly come up with anything that isn't reduced to something not useful. Care to give some hints?
20:09:17 <dmwit> vesz: Sure!
20:09:22 <dmwit> This is kind of a fun puzzle, no?
20:09:38 <dmwit> vesz: See if you can describe to me in English how to implement the church function.
20:09:48 <dmwit> (Go ahead and assume the base case, since you got that right already anyway.)
20:12:10 <vesz> Well I want to add the function with itself as an argument and then continue doing that until I reach the base case
20:12:38 <dmwit> Okay.
20:13:00 <rwbarton> I feel this would be easier if you put all the arguments on the left side of the =
20:13:07 <rwbarton> church n f x = {- apply f n times to x }
20:13:17 <dmwit> So, here's the standard recursive procedure: let's assume we have a value "v" that's the result of calling "f" (n-1) times to "x".
20:13:24 <dmwit> What would the function look like then?
20:13:39 <dmwit> (I agree with rwbarton, too, let's use that convention.)
20:14:27 <chessguy> good old towers of hanoi :)
20:14:46 <vesz> If we use that convention isn't it church n f x = f (church (n-1) f x)?
20:14:57 <dmwit> vesz: Exactly right!
20:15:03 <dmwit> vesz: So you're done. =)
20:15:22 <vesz> was kinda locked in on doing the lambda thing :) cause I thought it looked nice without having the arguments there
20:15:29 <dmwit> You can do that, too.
20:15:37 <ddarius> church n f = f . church (n - 1) f
20:15:40 <dmwit> church n = \f x -> f (church (n-1) f x) -- equivalent
20:15:58 <chessguy> @pl c n f x = f $ c (n-1) f x)
20:15:58 <lambdabot> (line 1, column 26):
20:15:58 <lambdabot> unexpected ")"
20:15:58 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
20:16:13 <chessguy> @pl c n f x = f $ c (n-1) f x
20:16:13 <lambdabot> c = fix ((ap (.) .) . (. subtract 1))
20:16:22 <dmwit> chessguy: You need a base case.
20:16:35 <chessguy> i wasn't being particularly serious
20:16:39 <dmwit> ?pl c n f x = if n == 0 then x else f $ c (n-1) f x
20:16:39 <lambdabot> c = fix (ap ((.) . ap . if' . (0 ==)) . (ap (.) .) . (. subtract 1))
20:16:46 <dmwit> *There* we go. ;-)
20:17:03 <vesz> dmwit, I thought about putting x somewhere in there like that, but I thought I'd get way to many X's. as I only wanted a single x  -- f (f (f x)) etc
20:17:21 <vesz> dmwit, anyway, thanks alot for your time, appreicated
20:18:10 <dmwit> It's refreshing to see a new person asking about lambda calculus instead of IO. =)
20:18:42 <vesz> :)
20:18:48 <ddarius> Now Church encode a list.
20:19:16 <heatsink> dmwit: :)
20:21:03 <dmwit> > let sum list = list (+) 0; nil f x = x; cons e list f x = f e (list f x) in sum (cons 3 (cons 2 nil))
20:21:04 <lambdabot>   5
20:22:03 <ddarius> dmwit: Not -you-.
20:22:05 <ddarius> Bah.
20:22:11 <ddarius> Now Church encode a Rose tree.
20:22:16 <heatsink> heh
20:22:20 <dmwit> Sure, I know.  I was curious, though.
20:22:44 <dmwit> Church encoding data types is pretty mechanical, once you get it. =)
20:22:54 <ddarius> dmwit: You can Church encode data L = V Int | A L L | L (Int -> L)
20:23:46 <dmwit> Looks like the lambda calculus to me. ;-)
20:25:32 <dons> dcoutts_: yay, janis is using hackage, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bff-0.2
20:25:34 <lambdabot> Title: HackageDB: bff-0.2, http://tinyurl.com/6hh3qo
20:25:43 <dons> and after sulzmann. we're seeing the academic adoption of hackage :)
20:27:06 <twb> cabal2deb isn't listed here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/
20:27:07 <lambdabot> Title: HackageDB: packages by category
20:27:09 <twb> Where is it?
20:28:33 <dons> you should probably mail haskell-cafe@ about the status of debian packaging tools. then igloo, nomeata, stepcut et al can comment.
20:29:07 <sjanssen> there is also a Debian Haskell mailing list
20:29:17 <twb> sjanssen: it's not on gmane anymore :-(
20:29:20 <dons> oh, good.
20:31:37 <dons> inneresting, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ehaskell-0.1
20:31:39 <lambdabot> Title: HackageDB: ehaskell-0.1, http://tinyurl.com/6agmjk
20:31:48 <dons> "You can embed haskell in Text file. You can use in html, haskell source, and so on.
20:31:52 <dons> "
20:32:04 <ivanm> embed Haskell in Haskell? :o
20:32:18 <dons> in text?
20:32:22 <dons> is it a preprocessor?
20:32:31 <ivanm> sounds like it
20:32:43 <ivanm> well, I'd call it a code generator rather than a pre-processor
20:33:01 <ivanm> since it converts <% ... %> to a do-block
20:33:29 <ivanm> so it looks like a way of having embedded haskell snippets... not sure if returns the result in the file though
20:33:44 <ivanm> heh, the homepage is great ;-)
20:34:01 <ivanm> Usage: ehs souce-file [ -o output-file ] <-- that's pretty much the entire page ;-)
20:34:14 <sjanssen> looks like PHP
20:39:33 <twb> *fo
20:40:19 <twb> (Sorry, emacs-w3m, ido, gnus and emacs --daemon are all fighting about how to handle multiple frames :-/)
20:41:23 <Axman6> ivanm: did you get an email from fishpond about RWH?
20:41:34 <ivanm> Axman6: yup
20:41:43 <ivanm> twb: heh
20:41:57 * ivanm _loves_ ido... if only mcomplete loved it as well :(
20:47:48 <dons> 33 new Haskell packages for Arch, http://archhaskell.wordpress.com/2008/11/03/arch-haskell-news-nov-02-2008/
20:47:50 <lambdabot> Title: Arch Haskell News: Nov 02 2008 « Arch Linux and Haskell, http://tinyurl.com/5esjah
20:47:52 <dons> come on debian!
20:49:03 <sjanssen> Debian doesn't want to be on the cutting edge
20:49:26 <dons> i'd be happy if it supported the core properly.
20:49:49 <dons> or had a coherent support plan. what are they trying to support?
20:49:52 <sjanssen> right, it ought to be better
20:52:14 <sjanssen> dons: does Arch handle the diamond dependency problem?
20:52:33 <dons> only in so far as cabal does
20:52:44 <dons> you can break things. which means rebuilding binary stuff
20:53:00 <sjanssen> what happens when I update by X11 package, will it automatically update my xmonad package?
20:53:26 <dons> yeah.
20:53:45 <sjanssen> even if no new xmonad release has been made?
20:53:51 <dons> right.
20:53:57 <dons> this recently happened, actually.
20:54:15 <dons> note arch has both source packages, and binary packages. you can use either. the later do the rebuilds, of course.
20:54:27 <sjanssen> interesting
20:55:27 <dons> its a good binary packaging system, though it doesn't have rich dep constraints like cabal does
20:55:44 <dons> binary systems can be a bit dumber, since everything's "monomorphic" in the current package versions
20:55:53 <sjanssen> how does it figure out that xmonad should be rebuilt?
20:56:15 <dons> it does some topological thing i think.
20:56:18 <sjanssen> are there different sorts of dependencies for ABI preserving and non-preserving updates?
20:56:23 <dons> that's done on the build farm, i don't do it.
20:56:28 <dons> dont' think so.
20:56:39 <dons> just a single global graph that gets rebuilt when bits of it change.
20:57:08 <sjanssen> oh, so a rebuild of the whole thing when libc changes?
20:57:15 <dons> yeah
20:57:23 <bd_> fun
20:57:30 <dons> hey, welcome to binary packaging.
20:57:45 <dons> note users don't need to see that. they just resync and it downloads whatever changed, in binary form.
20:57:47 <bd_> welcome to binary packaging without a sufficiently rich dependency framework :)
20:57:50 <sjanssen> not the most precise choice, but perhaps the most robust
20:58:01 <bd_> if it works, it's fine, I guess.
20:58:05 <dons> right. you could be smarter if you had types :)
20:58:15 <dons> but cross language package systems need to be dumb i think
20:58:19 <dons> since you can't rely on anything
20:58:30 <bd_> I guess the problem is a lot of C libraries aren't very careful about ABI breakage there
20:59:25 <sjanssen> dons: what about with source packages, will Arch still know to rebuild my xmonad?
21:02:29 <twb> "cabal install" doesn't download and build in parallel
21:02:57 <dmwit> patches welcome ;-)
21:02:59 <twb> When I said "cabal install haddock quickcheck" it didn't start downloading haddock until after quickcheck was installed.
21:03:02 <twb> At least, AFAICT.
21:03:07 <sjanssen> twb: yes, that is true
21:03:35 <twb> You should have a --color=auto option like waf :P
21:05:30 <sjanssen> is code.haskell.org down?
21:05:43 <sjanssen> SSH and HTTP seem to hang
21:05:55 <sjanssen> loading now
21:08:05 <twb> Is it flaky enough that my "darcs send cho:/srv/code/darcs/sprint" just now was what was killing it?
21:08:40 <dmwit> One way to find out...
21:08:47 <sjanssen> twb: probably not
21:09:47 <dons> works for me.
21:10:28 <sjanssen> dons: yeah, the hanging was fairly brief
21:10:30 <sjanssen> just a hiccup
21:10:35 <twb> OK, so after "cabal install quickcheck" I am still getting "You need QuickCheck 2 to run the tests" from Darcs' make disttest
21:11:04 <sjanssen> twb: did you install quickcheck 2?
21:11:24 <twb> I just asked for "quickcheck"
21:11:46 <twb> Apparently that installed quickcheck 1.2.0
21:12:32 <twb> cabal install 'quickcheck > 2' seems to DWIM
21:12:43 <twb> I just assumed cabal install would get the newest stable version.
21:13:00 <dons> twb: if quickcheck is already on your system, it won't upgrade if it thinks it already satisfied 'quickcheck'
21:13:18 <twb> dons: strange that it didn't upgrade, but did download and install the same version
21:13:20 <dons> adding constraints is one good way to force newer versions
21:13:21 <dons> or use --reinstall
21:13:32 <twb> Oops, I tell a lie
21:13:39 <dons> oh, that's the defaulting. i think there might be a rule to prefer quickcheck < 2 ?
21:13:48 <dons> since most things work with that, not with qc2.
21:13:50 <twb> I had QC 1.1.0; "cabal install quickecheck" installed 1.2.0 into ~/.cabal
21:14:14 <dons> ok. yes, so that's the <2 constraint in action. there's a couple of other rules (preferring base 3, haxml 1.13)
21:14:27 <dons> these help the majority of things to build, but you can override as you see.
21:14:34 <twb> Bah.
21:14:50 <twb> If packages didn't want quickcheck 2 they should have said so themselves.
21:16:14 <sjanssen> to be fair, the packages were written before quickcheck 2 decided to break things :)
21:21:22 <dons> twb: right. think about what packages specify:  quickcheck, quickcheck > 1 or quickcheck > 1 && < 2, or quickcheck 1.*
21:21:36 <dons> the solver works out a good fit. but its a hard problem :)
21:22:00 <twb> Well sure, but I asked it to just resolve "quickcheck".
21:22:57 <dons> right. so you didn't tell it anything new. it had to pick something. the newest version is usually ok, but in this case, qc 2 is blacklisted as 'breaks a bunch of things'
21:23:07 <dons> packaging is so much fun!!!
21:23:15 <twb> Apparently cabal-debian can't detect that I have both cabal 1.6 and cabal 1.2 installed
21:23:40 <twb> Oh, oops, I think it's just printing all the dependencies
21:24:32 <dons> this is weird, http://jtauber.com/blog/2008/11/01/two_functional_questions/
21:24:38 <lambdabot> Title: James Tauber : Two Fun(ctional) Questions
21:24:46 <dons> surely there's a haskell solution waiting here. a one liner...
21:25:06 <dons> add it to reddit if someone thinks of a good one, http://www.reddit.com/r/programming/comments/7ax9z/two_functional_questions/
21:25:13 <lambdabot> Title: Two Fun(ctional) Questions : programming, http://tinyurl.com/5gp3cx
21:28:10 <dancor> still trying to get python to notice your war against them
21:28:25 <dons> heh
21:28:44 <dons> they can't do lambdas or composition properly, they deserve sand in the face for that :)
21:28:54 <twb> They can't do ANYTHING properly
21:29:35 <twb> And what's worse, they'll tell you that what python does is right, and it's right because that's what python does.
21:30:20 <juhp> hehe
21:30:27 <twb> If you're really lucky you'll find the handful of Python users who know some other language, and they'll say something like "yes, <feature> is wrong and stupid, but mostly Python is quick and dirty for work"
21:30:34 <sjanssen> dons: what the blog wants is dumb
21:30:38 <dancor> this gives partial application in python then?
21:30:44 <sjanssen> "I think what I'm basically looking for is to being able to treat composition and application the same."
21:30:53 <sjanssen> "I want neg(5) == -5 and double(5) == 10 but neg(double) to give me a function that will do both, i.e. neg(double)(5) == -10"
21:31:25 <dons> heh
21:31:29 <dancor> so much for haskell one-liner
21:31:38 <sjanssen> typical fuzzy headed dynamic language thinking
21:31:48 <dons> stuff is all stuff!
21:31:51 <dons> make it do things
21:31:55 <dons> my head hurts
21:32:00 <dons> halp!
21:32:16 <dancor> it would have to use Dynamic or something?
21:32:24 <dancor> unsafeThought
21:32:32 <sjanssen> dancor: or Typeable
21:32:45 <L3v1> hi all.
21:32:54 <dons> seems like type classes might do it.
21:32:55 <twb> http://hpaste.org/11699
21:33:14 <dons> twb: yes?
21:33:18 <dons> At least the following dependencies are missing:
21:33:19 <dons> Cabal >=1.4, time >=1.1
21:33:22 <geezusfreeek> this is the most horrible exercise ever
21:33:29 <geezusfreeek> why... would anybody want this?
21:33:30 <dons> twb: ah, missing --user
21:33:39 <dons> twb: it doesn't look at your user stuff by default.
21:33:52 <twb> Ah.
21:33:53 <dons> twb: or, since you have cabal-install, try 'cabal build'
21:33:57 <dons> instead of runhaskell Blah
21:34:27 <twb> cabal build gives
21:34:27 <twb> Could not find module `System.Unix.Process'
21:34:36 <twb> Sounds like an undocumented build dependency!
21:34:58 <twb> This is why I don't trust naughty upstreams.
21:35:00 <dons> that's the unix library.
21:35:12 <dons> no, the process library?
21:35:16 <dons> System.Unix !?
21:35:31 <twb> It should be System.Posix.Process, perhaps.
21:35:46 <sjanssen> almost certainly
21:35:56 * twb wonders idly if System.Posix supports symlinks, which aren't part of posix.
21:36:04 <sjanssen> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Unixutils
21:36:10 <sjanssen> actually, it is from that
21:36:10 <lambdabot> Title: HackageDB: Unixutils-1.17, http://tinyurl.com/5qj2nz
21:36:40 <dons> curious.
21:36:53 <dons> i wasn't aware of this package.
21:37:09 * dons packages it
21:37:17 <twb> The .cabal file says:
21:37:17 <twb>   if flag(splitBase)
21:37:17 <twb>     Build-depends: base, Cabal >= 1.4, filepath, time >= 1.1, unix, debian >= 3.1, Unixutils, old-locale, process, bytestring, directory, containers, pretty, filepath
21:37:17 <twb>   else
21:37:17 <twb>     Build-depends: base, Cabal >= 1.4, filepath, time >= 1.1, unix
21:37:26 <twb> So it knows to use unixutils, but not on my system.
21:37:47 <dons> right. it ran the solver, and found it could satisfy the latter deps
21:38:03 <dons> but apparently that's not a correct dependency spec.
21:38:29 <sjanssen> inclusion of Unixutils shouldn't be dependent on splitBase, methinks
21:38:53 <dons> right. he's doing somethiiing funny
21:39:29 <sjanssen> the else clause should have base < 3
21:40:25 <dons> yeah
21:45:01 * juhp wonders what base broken heart means
21:45:06 <juhp> .... sorry ;-)
21:47:27 <twb> dons: my confidence in cabal2deb is not rising :P
21:47:40 <twb> Especially since debian/copyright contains completely stupid information.
21:48:00 <dmwit> juhp: I've done that mental double-take so many times now... =)
21:48:32 <twb> dmwit: what kind of silly person writes <3 when they mean ♥?
21:48:50 <dmwit> \heart
21:49:06 <twb> That should be \heartsuit
21:49:32 <dmwit> So it would.
21:49:52 <dmwit> It's mildly frightening that you just knew that off the top of your head.
21:49:58 <twb> I didn't.
21:50:03 <twb> Emacs has a TeX input method.
21:50:19 <twb> i.e. for typing TeX instead of Chinese or Linear A
21:50:33 <dmwit> But... that heart is empty! =/
21:50:57 <juhp> twb: oh cool didn't know that
21:51:06 <sjanssen> twb: what kinds of silly person uses a glyph that refers to a playing cards when they're talking about love?
21:51:32 <twb> ☙ ♡ ♥ ❣ ❤ ❥ ❦ ❧ ⺖ ⺗ ⼼
21:51:50 <jeffz> ◕ ◡ ◕
21:52:12 <sjanssen> ❤ is the right glyph
21:53:17 <twb> src/Distribution/Package/Debian.hs:36:7: Could not find module `System.Directory': it is a member of package directory-1.0.0.0, which is hidden
21:53:21 <twb> WTF?
21:53:54 <sjanssen> hmm, I suppose the black heart suit character does have the alias "valentine" in the Unicode character database
21:54:06 <sjanssen> twb: Cabal is chosing the smallBase plan
21:54:07 <twb> Clearly these build dependencies are well stale
21:54:21 <sjanssen> add base < 3 as I suggested
21:54:41 <sjanssen> in the else clause for splitBase
21:55:01 <twb> Now I get: Setup: At least the following dependencies are missing: debian >=3.1
21:55:15 <sjanssen> better install it
21:55:28 <twb> Oh, I thought it meant Debian Sarge
21:56:20 <twb> Apparently that version is not cabal installable
21:56:58 * roconnor sighs
21:57:09 <roconnor> Colour doesn't belong in Data. does it?
21:57:42 <roconnor> I guess it either belongs in Graphics or at it's own root.
21:59:36 <roconnor> Sound has it's own Root
21:59:41 <roconnor> why not Colour too?
22:00:29 <L3v1> hi, may i use ffi to use enums / structs defined in c ?
22:01:29 <sjanssen> L3v1: the FFI doesn't know about struct directly
22:01:56 <sjanssen> you can use a tool like hsc2hs to help with structs and enums
22:02:36 <L3v1> ok, thanks.
22:06:13 <Pseudonym> roconnor: Colour (or Color) belongs in Data if Time does.
22:06:52 <Pseudonym> I interpret Data as containing anything a) that doesn't logically belong somewhere else, and b) is Plain Old Data.
22:07:12 <roconnor> Pseudonym: ooh, good argument
22:07:43 <Pseudonym> Data containers also seem to have ended up in Data, which also makes sense.
22:08:05 <roconnor> obviously Time doesn't belong in Data either :)
22:08:21 <Pseudonym> BUt it could be argued that aggregated plain old data is also plain old data.
22:08:42 <roconnor> ah right
22:08:48 <roconnor> Char doesn't belong in data
22:08:57 <roconnor> Complex doesn't belong in data
22:09:14 <Pseudonym> I half agree with you on Complex.
22:09:17 <Pseudonym> Or Ratio.
22:09:30 <roconnor> right Ratio doesn't belong in data
22:09:31 <BMeph> I HATE Complex with a passion.
22:09:39 <roconnor> but they are all there
22:09:40 <Pseudonym> But a) they are Plain Old Data, and b) there isn't a good hierarchy for numeric stuff in the standard library.
22:09:43 <roconnor> so I can keep colour there too.
22:09:52 <Pseudonym> I therefore see it as a temporary measure.
22:10:12 <sjanssen> there is a top level Numeric module
22:10:20 <BMeph> "Oh, look, a Complex type, let's make Gaussians with them...CRAP!" :|
22:10:57 <roconnor> Int doesn't belong in Data ... well, not so sure about that.
22:11:29 <Pseudonym> And there's the thing.  If Int belongs in Data, then so does Ratio.
22:11:45 <Pseudonym> I think it'd make more sense to have a Num hierarchy there.
22:12:05 <roconnor> I'd probably prefer to see Int out of Data
22:12:12 <roconnor> but I'd listen to arguments
22:12:27 <roconnor> yet Bool probably can be in Data.
22:12:38 <roconnor> but I'd listen to arguments against it.
22:13:04 <roconnor> I'm pretty sure Bool belongs in Data though.
22:13:29 <Pseudonym> I'm not sure that Monad belongs in Data.
22:13:36 <roconnor> I don't know if IORef belongs in data
22:13:39 <Pseudonym> Because Monad is much more about behaviour than Plain Old Data.
22:13:42 <sjanssen> Pseudonym: Monad is in Control
22:13:49 <Pseudonym> Hmm... right.
22:13:53 <Pseudonym> That makes sense.
22:14:22 <roconnor> I don't even know what Data.Edison is
22:14:36 <sjanssen> I think we could axe Data and Control and not lose anything
22:15:06 <Pseudonym> Well, Control really should be replaced by some variant of Category.Extras.
22:15:29 <Pseudonym> Except instead of Category, it should be named WarmFuzzyThings.
22:15:55 <sjanssen> I'm referring specifically to the names, "Control.Monad" doesn't seem any better than "Monad"
22:16:36 <Pseudonym> Except that Monad and Arrow are logically related somehow and should be under a common thing.
22:16:45 <Pseudonym> Not that Control is a good name for this, necessarily.
22:17:01 <BMeph> I'm pretty sure that Data.Bool ought to have a 'bool' function in it. :)
22:17:22 <sjanssen> BMeph: definitely
22:17:29 <sjanssen> somebody should write a proposal for that
22:18:03 * BMeph thinks vixey's proposed it at least once a week for the past year... ;)
22:18:10 <dmwit> Does anybody have a fuzzy English description of what they think should go in Data?
22:18:18 <sjanssen> BMeph: I mean a formal library proposal
22:18:29 <Pseudonym> What should this "bool" function do?
22:18:35 <geezusfreeek> personally i like the idea of Data. being for data structures
22:18:37 <BMeph> sjanssen: So did I! >;)
22:18:54 <roconnor> dmwit: right, data structure
22:18:57 <geezusfreeek> so things like Monoid, Foldable, etc. are out
22:19:03 <roconnor> I like the trees and queues
22:19:13 <roconnor> tuples
22:19:25 <roconnor> bool is a sort of trivial data structure
22:19:28 <roconnor> unit
22:19:31 <roconnor> lists
22:19:52 <rwbarton> Where should Foldable live?  "TypeClasses"?
22:19:56 * roconnor realizes he isn't giving a fuzzy English desrciption
22:20:18 <roconnor> I could live with Foldable in Data
22:20:24 <Pseudonym> Foldable is a kind of Applicative, isn't it?
22:20:27 <BMeph> roconnor: Surely, bool ~ Maybe unit :)
22:20:35 <roconnor> surely
22:20:57 <roconnor> Maybe ~ Either unit
22:21:01 <roconnor> thus
22:21:03 <roconnor> ...
22:21:10 <rwbarton> Foldable means approximately "has a natural transformation to []"
22:21:21 <roconnor> oh
22:21:27 <sjanssen> "Class of data structures that can be folded to a summary value. "
22:21:27 <roconnor> so it belongs in Data.List?
22:21:33 <roconnor> or under Data.List
22:21:33 <ddarius> rwbarton: That's a bit too "approximately"
22:21:38 <geezusfreeek> i say Foldable, Traversable, Monoid, Monad, Functor, Applicative, etc. should be under the same thing
22:21:47 <geezusfreeek> i like the idea of Category
22:21:51 <Pseudonym> rwbarton: So it sounds like it should be under WarmFuzzyThing.
22:21:56 <geezusfreeek> or something...
22:22:00 <roconnor> geezusfreeek: sounds fair
22:22:07 <geezusfreeek> it's the closest i have seen to what i want anyway
22:24:00 <rwbarton> Pseudonym: WarmFuzzyThings, maybe :)
22:24:16 <Pseudonym> Yes.
22:24:45 <geezusfreeek> that needs a warm fuzzy english description
22:25:29 <dmwit> WarmFuzzy.Monad
22:25:33 <dmwit> WarmFuzzy.Arrow
22:25:37 <dmwit> WarmFuzzy.Traversable
22:26:04 <dmwit> WarmFuzzy.Animal.Kitten
22:26:20 <sjanssen> Abstraction.Monad?
22:26:47 <Pseudonym> Abstraction.GroupAction?
22:26:59 <dmwit> I actually kind of like the name Abstraction, but it doesn't really give me a feel for what would and would not fit under it.
22:27:01 <Pseudonym> Does that make sense, or is that arguably more numeric?
22:27:10 <Pseudonym> I want to say Algebra.
22:27:23 <Pseudonym> But I suspect that's neither Warm nor Fuzzy.
22:30:12 <ddarius> Abstraction.Lambda
23:09:23 <roconnor> > forever Nothing
23:09:25 <lambdabot>   Nothing
23:09:37 <bd_> :t forever
23:09:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
23:13:05 <juhp> finally building ghc-6.8.3 for fedora 9
23:22:26 <ivanm> juhp: what took you so long? :p
23:22:36 <ivanm> (though isn't fedora 10 out?)
23:22:44 <juhp> not yet
23:22:53 <juhp> ivanm: mostly apathy ;-P
23:23:05 <ivanm> hmmm..... that's right, I was trying to use a pre-release liveCD
23:23:47 <juhp> ivanm: it is pretty close to finished now though - builds are frozen for bugfixes only
23:24:55 <juhp> well I would have done it much earlier if I had more time and others hadn't discouraged me from updating it before - in the end we had to since f9 can't build ghc682...
23:28:02 <extasic> hi
23:28:48 <extasic> I need help creating a haskell function and it would be really great if anyone could help me a bit :)
23:29:20 <quicksilver> extasic: just go ahead and ask ;)
23:29:28 <quicksilver> extasic: people don't bother to answer pre-questions l
23:29:30 <quicksilver> ike tht
23:30:45 <extasic> what I need is to create a list of Bool permutations by just using libst abstraction, pattern matching, basic list functions (no map) zip and recursion.
23:31:09 <extasic> I've been given the definition type Assignment = [(String, Bool)]
23:31:51 <extasic> and the function shuld be assignments :: [String] -> [Assignment]
23:33:05 <extasic> so assignments ["A","B"] would result in
23:33:06 <extasic> [[("A",True), ("B",True)], [("A",True), ("B",False)],
23:33:06 <extasic> [("A",False), ("B",True)], [("A",False), ("B",False)]]
23:35:01 <BeelsebobWork> extasic: you may find it easier if you try and generate all possible assignments of "A" only
23:35:01 <extasic> I tried something like assignments (x:xs) = [(x,True)] ++ (assignments xs) ++ [(x,False)] ++ (assignments xs)
23:35:32 <BeelsebobWork> and then try and extend it
23:36:08 <rwbarton> extasic: your code is pretty cloes actually.  I suggest you try to get it working using map
23:36:18 <rwbarton> extasic: (you also need a base case)
23:38:46 <extasic> rwbarton: I'm not allowed to use map - it's not yet introduced
23:39:03 <BeelsebobWork> extasic: write a very similar function then
23:39:05 <extasic> rwabarton: something like assignments [] = []?
23:39:08 <BeelsebobWork> perhaps slightly less general
23:39:16 <BeelsebobWork> extasic: that looks sensible for a base case, yes
23:39:18 <rwbarton> extasic: If I had to use these tools to write this function, I would write map first :)
23:39:24 <BeelsebobWork> but you do need something map-like for this
23:40:03 <Baughn> So you either get to rewrite map, or use explicit recursion
23:40:07 <rwbarton> you can call it prependToEach or something
23:40:11 <extasic> I tried to use list abstractions but that didn't help me much
23:40:22 <Baughn> Rewriting map is absolutely the best idea. Show that you can extract abstractions. Even if it's us doing it. ^^;
23:41:10 <extasic> hmm
23:41:27 <rwbarton> extasic: by the way that base case isn't quite right
23:42:13 <BeelsebobWork> extasic: oh, are you allowed to use list comprehensions?
23:42:26 <extasic> yes
23:42:39 <BeelsebobWork> oh, then you can use the standard pattern to get a map
23:42:46 <BeelsebobWork> [f x | x <- xs]
23:42:57 <BeelsebobWork> now all you need to do is figure out what f is for you
23:42:57 <rwbarton> in fact, you can write the entire right hand side as a list comprehension
23:42:59 <sjanssen> that is probably cheating
23:43:12 <sjanssen> if the goal is to re-write map
23:43:46 <BeelsebobWork> I dunno -- the lecturer may have thought "hmm, why introduce them to HO functions early when I can just give them list comprehensions for a while"
23:43:55 <extasic> I already played around with that, but I still don't even know what that "f" should do
23:44:16 <BeelsebobWork> extasic: suppose you can generate all the permutations for your 'xs'
23:44:26 <extasic> aah, ok
23:44:27 <BeelsebobWork> why do you want the permutations for (x:xs) to look like
23:44:31 <BeelsebobWork> what*
23:44:58 <extasic> so it's nearly the same I had
23:45:06 <extasic> just that mine wasn't working ;)
23:45:24 <BeelsebobWork> yep, yours was very close
23:48:06 <Baughn> http://xkcd.com/499/ <-- The consequences of not using the right monad?
23:48:07 <lambdabot> Title: xkcd - A Webcomic - Scantron
23:48:30 <extasic> hmm, I still don't get what that "f" should do.. should it generate the permutation?
23:48:54 <Baughn> extasic: f is the same function you'd pass to map, if that helps
23:49:07 <BeelsebobWork> extasic: well, suppose you have [[("B", True)], [("B", False)]]
23:49:29 <BeelsebobWork> and you're generating permutations for ("A":"B":[])
23:49:44 <BeelsebobWork> i.e. you've done the work for generating permutations of ("B":[])
23:50:16 <BeelsebobWork> how do you get from that list, to the one that describes all the posibilities for both A and B
23:50:34 <Stinger> can ghci be made to do optimizations in the REPL?
23:51:00 <Baughn> Stinger: Optimizations to files you load, sure
23:51:06 <Baughn> -fobject-code -O2 will do that
23:51:21 <Baughn> Stinger: And if you're not putting your code in files.. you should be. ;)
23:51:35 <Stinger> but I'm laaazy :)
23:51:51 <BeelsebobWork> extasic: I guess another way of putting it -- where can you use that list you've already generated -- where does it occur in the output that you want
23:51:56 <Baughn> Stinger: Install emacs, haskell-mode and bind reload-file to C-r. :P
23:52:02 <Baughn> That's what I do. Works great.
23:52:12 <Stinger> well the main reason I'm asking is I wan't to know how well ghc optimizes infinite recursive data structures
23:52:21 <Stinger> space wise
23:52:42 <Baughn> Lazily.
23:53:25 <Baughn> -O2 has no particular bearing on that - it sometimes strictifies things, but not when it'd make the result works, and infinite data structures generally want as much laziness as they can get their infinite numbers of hands on
23:53:43 <Baughn> *make the result worse
23:54:29 <Stinger> if I have a function that does some work to produce an infinitely recursive data structure, is there a way to force strictness on that work without forcing the entire data structure?
23:54:54 <extasic> Beelsebob: I somehow need to create [("A",True),[B,C]] ++ [("A",False),[B],[C]]
23:55:05 <BeelsebobWork> extasic: well, not quite
23:55:08 <Stinger> like building a graph
23:55:13 <extasic> hmm?
23:55:16 <BeelsebobWork> in that you don't want just one ("A",True)
23:55:35 <BeelsebobWork> you want ("A",True) on the front of *every* one of the permutations
23:55:42 <Baughn> Stinger: To some degree. Appropriate additions of seq should be able to do that.
23:56:24 <Baughn> Just be careful not to force too much
