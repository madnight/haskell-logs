00:00:15 <Trinithis> is to following true: pure f <*> a == f <$> a
00:01:00 <luqui> yep
00:01:03 <Trinithis> cool
00:01:15 <Trinithis> time to tidy my code then
00:02:07 <luqui> hml, the "Intersectable a" part is unnecessary
00:02:33 <luqui> it would mean "Boundary is Intersectable provided a is Intersectable", which is rather nonsensical
00:02:47 <hml> ah; got it
00:02:49 <hml> thanks
00:03:06 <hml> the thing after 'instance' doesn't ahve special syntac, and is just a standard type declaration
00:03:09 <hml> and i didn't realixe that
00:03:41 <luqui> uh... not exactly.  it's typeclass syntax, which looks almost identical to type syntax, but its meaning is different
00:03:58 <luqui> i.e. Ord Int is not a type, it is a "proposition"
00:04:01 <hml> oh
00:11:04 <jamii> I feel like a human macro. My copy and paste fingers are worn down to the bone. Sometimes I wish haskell was lisp
00:11:22 <mauke> .oO( liskell )
00:11:48 <hml> i'm familiar with scheme
00:11:54 <hml> but so far, i havne't found a single pattern in scheme
00:11:59 <hml> that i can't use in haskiell
00:12:06 <hml> what are you doing that requires so much copy/paste?
00:12:16 <jsnx> jamii: how did this happen?
00:13:19 <jamii> http://hpaste.org/9134
00:13:44 <jamii> mauke: What happened to liskell. It doesnt seem to be maintained
00:14:00 <mauke> no idea
00:14:10 <Trinithis> would template haskell be useful for your code?
00:15:03 <jamii> Trinithis: Yes, but Ive always had trouble using it. I think that haskell syntax is just complicated enough that using TH is slower than copy/paste and editing by hand
00:15:28 <Trinithis> But what about mantainablity?
00:15:51 <Trinithis> (and the hidden fun factor)
00:17:12 <jamii> I dont know. Im using TH elsewhere but it really doesnt feel natural. I cant get used to it to the point where I would start using it in normal code. Although this may be the last straw that drives me to master it
00:17:31 <jamii> Ouch
00:17:39 <Trinithis> Zouch!
00:17:44 <jamii> Purge!
00:18:07 <jamii> Im scared...
00:18:24 <Saizan_> i wonder if you should declared those specialized functions at all, rather than exposing some combinators and the general ones
00:21:45 <jamii> They do look very regular dont they. I do need to eventally define all of them for a class interface but it certainly might be clearer if I right a higher order fold
00:21:51 <jamii> hehe - metafold
00:22:44 <jamii> I've inherited ~8000 lines of this stuff
00:22:59 <Trinithis> from who?
00:25:12 <jamii> Mr Hey. It was a prototype so I guess it was all cranked out with emacs macros. Its not bad code, just repetitive.
00:25:45 <Trinithis> Oh, was it originally in a language NOT haskell?
00:26:14 <jamii> No? emacs is pretty good at producing lots of haskell code.
00:35:16 <baaba> @unpl ((.)(.))
00:35:17 <lambdabot> (\ b c e f -> b c (e f))
00:36:06 <baaba> heh, i gotta find places in my code to use that
00:36:31 <Twey> Haha
00:37:14 <yitz> @unpl ((.).(.))
00:37:14 <lambdabot> (\ i b c f -> i (b c f))
00:37:30 <baaba> i guess that's a mole? ;)
00:37:40 <Twey> Hahaha
00:37:50 <Twey> Are these letters picked randomly or what?
00:37:51 <Trinithis> it's a useful function
00:38:00 <Twey> i b c f?
00:38:06 <Trinithis> ((.).(.))
00:38:38 <Trinithis> It's function composition that 'primes' with 2 args rather than 1
00:39:27 <Trinithis> :r
00:39:36 <Trinithis> whoops... not my console
00:39:48 <andun> ?t ((.).(.))
00:39:48 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:40:13 <Trinithis> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
00:40:25 <Trinithis> assuming . is fmap
00:41:00 <Trinithis> :t ((.).(.))
00:41:15 <lambdabot> thread killed
00:44:29 <yitz> @type ((.).(.))
00:44:29 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
00:45:28 <Axman6> wow, boobies have a type
00:49:03 <_zenon_> It's the owl
00:49:06 <_zenon_> is it not?
00:49:22 <Trinithis> ((.)$(.)) == owl
00:51:17 <luqui> the original (.)(.) is an owl in disguise...
00:51:41 <luqui> rewrite an owl to become breasts...
00:51:54 <Trinithis> :t ((.)$(.))
00:51:55 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
00:52:00 <luqui> @pl (\f g x y z -> f (g x y z))
00:52:01 <lambdabot> (.) . (.) . (.)
00:52:23 <luqui> (total recall)
00:52:28 <Trinithis> @unpl ((.)$(.))
00:52:28 <lambdabot> (\ b c e f -> b c (e f))
00:52:38 <Trinithis> @unpl ((.)(.))
00:52:38 <lambdabot> (\ b c e f -> b c (e f))
00:53:36 <Trinithis> didn't realize they were the same
00:53:47 <Trinithis> but it makes sense
00:54:04 <koninkje> Trinithis: ($) is the "explicit function application" operator
00:54:26 <Trinithis> I know. I just didn't think about it, that's all
00:54:31 <koninkje> (it's also the type lifting operator and a few other things depending on how it's used)
00:55:07 <Trinithis> $ is really cool, especially when currying with it
00:56:07 <koninkje> > let exp = (**) in ($2) exp 3
00:56:10 <lambdabot>  8.0
00:56:13 <koninkje> > let exp = (**) in ($2) (exp 3)
00:56:14 <lambdabot>  9.0
00:56:44 <Trinithis> Nifty in front of a case or an if too
00:56:52 <koninkje> @type \a b c d -> ($a) $($b) $($c) d
00:56:52 <lambdabot> forall a b a1 a2. a -> a1 -> a2 -> (a2 -> a1 -> a -> b) -> b
00:57:16 <Trinithis> > ($2) $ if True then (0+) else (1+)
00:57:17 <lambdabot>  2
00:58:10 <cjs> What's the monadic thing one does when one has a sequence of actions, each of which should succeed, in which case you carry on to the next action, or fail, in which case an error message should be logged and the sequence should be aborted?
00:58:40 <koninkje> > let foo a b c d = a + b * c / d in ($1) (foo 2 3) 4
00:58:49 <lambdabot>  2.75
00:58:54 <koninkje> ^ for those who'd like ``s to be able to take arguments
00:58:56 <luqui> cjs, ErrorT?
00:58:58 <Trinithis> Either ?
00:59:43 <Trinithis> is Error a special case of Either?
01:00:23 <idnar> @hoogle Error
01:00:24 <lambdabot> System.IO.Error :: module
01:00:24 <lambdabot> Foreign.Marshal.Error :: module
01:00:24 <lambdabot> Foreign.C.Error :: module
01:00:34 <cjs> Hm. Is there a simple example somewhere?
01:03:47 <luqui> Trinithis, yeah pretty much
01:03:55 <Trinithis> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
01:03:56 <lambdabot> Title: Control.Monad.Error, http://tinyurl.com/2cvgfn
01:04:08 <Trinithis> cjs: bottom of page
01:04:25 <Trinithis> luqui: k
01:04:31 <Trinithis> well im going to bed
01:04:33 <Trinithis> cya
01:05:38 <cjs> Thanks!
01:11:57 <hml> is there a built in func for the following: [a] -> [(Int, a)] .. where the Int's are a sequence of 0, 1, 2, ...
01:12:53 <rwbarton> zip [0..]
01:13:31 <rwbarton> (Well, that's not specifically Int)
01:14:07 <BeelsebobWork> t does however look like you want Data.IntMap, not [(Int,a)]
01:14:10 <BeelsebobWork> it*
01:14:23 <hml> rwbarton: taht willlll do; thanks :-)
01:15:22 <yitz> cjs: the names for the Error monad are a bit confusing. the non-transformer version of ErrorT is Either, while Error is the class of exceptions that get thrown.
01:17:47 <cjs> Ah.
01:24:16 <_Dae_> mornin
01:24:51 <cetin> hi can anyone suggest me a good source of information on the usage of the Data.Graph.Inductive.Graph module with simple examples?
01:32:52 <_zenon_> Mornin _Dae_
01:33:17 <_Dae_> 'sup?  code flowing?
01:35:44 <_zenon_> yeah
01:35:50 <_zenon_> workin' at the slave factory
01:35:58 <_zenon_> nah, can't say that, this summe job is al okay
01:36:00 <_zenon_> all*
01:36:11 <_zenon_> +r
01:36:14 <mapreduce> Hi, I'm looking to implement actors (like Erlang's or Scala's) in Java, but with static checking, so using generics.  As far as I can see, Scala's implementation doesn't really support typed messages, and I can't quite tell whether any Haskell implementation of actors supports typed messages.
01:36:23 <codacola> summe?
01:36:29 <_zenon_> +r
01:36:33 <codacola> ah
01:36:44 <mapreduce> I'm finding it difficult to implement (though trivial untyped), and am looking for clues.
01:36:45 <codacola> youre a student?
01:36:51 <_zenon_> yeah.
01:37:10 <codacola> ah, chances are youve mentioned it and ive forgotten :P
01:37:33 <_zenon_> np
01:37:34 <_zenon_> :)
01:37:47 <codacola> i get to work 50 hours a week again in the summer :D
01:37:57 <codacola> though summer to me is nov - jan
01:37:59 <_zenon_> There are approx > 400 people in this channel \forall t
01:38:15 <_zenon_> codacola, that's a lot of time
01:38:29 <codacola> the hours or the summer?
01:39:03 <_zenon_> hours,
01:39:14 <_zenon_> if you work each week and so forth
01:39:34 <codacola> its what i used to work until 3 weeks ago
01:39:42 <codacola> 50 - 55 (god forbid 60)
01:40:52 <codacola> _zenon_: on my last day of my job my boss came to talk to me, and told him to give him a ring if i want work during the holidays.
01:41:35 <codacola> so itll be good to be able to earn a few thousand between semesters
01:41:36 <_zenon_> That's nice :) Grow that spanning tree!
01:42:15 <codacola> spanning tree?
01:42:55 <_zenon_> your social network.
01:43:27 <codacola> well thatd be a bad way to do it :P
01:43:34 <_zenon_> The larger the better, more people you know, the larger the probability to get an extra job once in a while.
01:43:51 <_zenon_> maybe you prefer a fully connected graph?
01:44:48 <codacola> in anycase, cant wait for the summer. missing teh carrots already
01:45:00 <_zenon_> hehe, are you a carrot-maniac?
01:45:05 <_zenon_> I am more into the watermelons
01:45:17 <_zenon_> of course, eating to much watermelons makes the stomach upset
01:45:30 <codacola> used to work in a carrot factory. carrots everywhere. people always asked if i was sick of carrots for some reason
01:46:17 <_zenon_> hehe
01:46:27 <_zenon_> What did you do in there?
01:47:08 <codacola> many things. mostly folding boxes. during the off season almost literally nothing
01:47:35 <codacola> but im hoping he'll get me to do bunching in the summer months. better pay, better work
01:47:58 <_Dae_> mapreduce: so... what language did you wish to do this in? I'm slightly confused
01:48:43 <_zenon_> foldr?
01:48:46 <_zenon_> or foldl'?
01:48:46 * _Dae_ suspects codacola of being a rabbit
01:48:56 <_Dae_> huh?
01:49:08 <_Dae_> ohh...wait... I get it!
01:49:10 <_zenon_> codacola, I hope you foldl' the boxes
01:49:11 <_zenon_> :)
01:49:11 <mapreduce> _Dae_: Java.
01:49:17 <_Dae_> I see what you did there
01:49:44 <_Dae_> mapreduce: is #haskell the right channel to ask for help in then?? or am I missing something here?
01:50:01 <BeelsebobWork> _Dae_: yes, but you're liable to get cryptic answers from a lot of people
01:50:39 <_Dae_> _zenon_: not quite sure how you'd foldr boxes? Not do the work till the supervisor actually checks?
01:50:44 <jamii> Sometimes I wish GHC would stop being so clever and let me write benchmarks
01:50:48 <mapreduce> _Dae_: I'm looking for inspiration.
01:50:56 <mapreduce> Similar stuff already working.
01:51:00 <BeelsebobWork> jamii: hmm?
01:51:03 <_zenon_> _Dae_, that would be a way :) hahaha
01:51:11 <_zenon_> lazy boxfolding ftw
01:51:13 <_Dae_> mapreduce: actors are (as far as I recall) a part of a java design pattern, right?
01:51:37 <_zenon_> Hum , what's that called in english?   "Ã–gontjÃ¤nare" in swedish ....
01:51:48 <jamii> BeelsebobWork: It keeps optimising away my benchmarks
01:51:58 <jamii> Damn CAFs
01:52:18 <lobo9> #haskell:  Did most of you learn haskell in school or are you self taught?
01:52:20 <Zao> _zenon_: Lip servants?
01:52:32 <mapreduce> _Dae_: No, not at all.
01:52:37 <BeelsebobWork> lobo9: school/self taught cross
01:52:39 <mapreduce> They're how Erlang's concurrency works.
01:52:40 <codacola> im learning it at school at the moment :P
01:52:52 <_zenon_> Zao, would that not be more like.. Eye Servant?
01:53:12 <_zenon_> codacola, to foldr boxes ? :)
01:53:27 <_zenon_> lobo9, School + home
01:53:54 <_Dae_> mapreduce: right... actors like Schala and Erlang you said, ok...  Well, then I guess I won't be much help. Sorry :(
01:54:01 <_zenon_> First contact in my first year, hated it then, but learned to love it after a laboration involving trams.
01:54:02 <_Dae_> lobo9: self taught
01:54:13 <Zao> lobo9: Apart from two courses on ML and programming language theory, all self-taught.
01:54:43 <mapreduce> _Dae_: I haven't seen you here before - are you a Haskell novice?
01:55:29 <_Dae_> mapreduce: depends where you place the line for novice I guess.... I'm still slightly scared of monads, so I guess that must be a yes
01:55:45 <codacola> _zenon_: somehow thats just means. missing my carrots enough as it is :P
01:56:46 <_zenon_> codacola, I must ask. Do you drink carrot juice? It's quite vile.
01:57:19 <_Dae_> _zenon_: it's not too bad, mixed with apple juice
01:58:07 * _zenon_ shivers
01:58:11 <_zenon_> of, I mean
01:58:14 * _zenon_ shivers'
01:58:19 <_zenon_> the strict version
01:58:33 <Axman6> lobo9: found out about it through uni. haven;t had much time for it since though (last semester)
01:58:43 <codacola> never tried carrot juice
01:59:10 <lobo9> Dang, self taught seems pretty impressive to me.
01:59:18 <lobo9> I'd like to learn it because I've heard many good things about it, but feel like I should take a course to learn it.
01:59:27 <_zenon_> @pl sum $ map snd $ fromJust $ head fs
01:59:27 <lambdabot> sum (map snd (fromJust (head fs)))
01:59:30 <codacola> _zenon_: on my last day i got soemone to make a carrot cake, simply because i had never tried it
01:59:46 <_zenon_> did it taste good?
01:59:51 <codacola> yup
01:59:56 <_zenon_> nice
01:59:59 <_zenon_> maybe I should try one
02:00:05 <codacola> you should
02:00:13 <_Dae_> lobo9: it's not too hard if you already know another language
02:00:23 <codacola> make sure its made with nz carrots
02:00:26 <lobo9> Maybe I just fear it would add to another language I don't use, with FORTH and asm
02:00:27 <codacola> best in the world i hear
02:01:27 <lobo9> I dream of many *projects* but all my clients are morons and only know PHP, RoR, ASP. etc..  even perl sounds too fancy to them.
02:01:34 <codacola> ok anyone here an american?
02:01:41 <codacola> got a question that i need an american to answer :P
02:01:47 <lobo9> Yes?
02:01:59 <gabbs> what does +++ do in a parser?
02:02:13 <codacola> when obama was asked "would you meet with...." why was venezuela thrown into the mix with cuba, iran, syria etc?
02:02:23 <therp> gabbs: in Haskell? It's a regular infix operator
02:02:26 <_zenon_> nz carrots ?
02:02:39 <Axman6> to make sure he was awake!
02:02:50 <lobo9> chavez
02:02:55 <Axman6> @src (+++)
02:02:55 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:03:05 <_zenon_> codacola, seems to be some carrot expert :)
02:03:21 <codacola> lobo9: want to expand on just "chavez"?
02:03:39 <lobo9> heh..  its all political.
02:03:41 <codacola> oh
02:03:45 <codacola> i could ask in #politics
02:04:02 <lobo9> chavez is pretty controversial on certain issues
02:04:11 <gabbs> therp, yea - but whats it purpose? is it a switch ?
02:04:15 <lobo9> esp. regarding policies with the us.
02:04:44 <_Dae_> lobo9: well, it's definitely faster to write in than PHP, but .... what do you want to do with haskell?
02:04:51 <therp> gabbs: depends on what you imported. hoogle is your friend http://www.haskell.org/hoogle/?q=%2B%2B%2B
02:04:52 <lambdabot> Title: +++ - Hoogle
02:05:16 <therp> most likely your code refers to Control.Arrow.(+++)
02:05:26 <gabbs> cheers
02:05:27 <BeelsebobWork> given that he said it was a parser I doubt it
02:05:36 <BeelsebobWork> I expect it's Text.ParserCombinators.(+++)
02:05:45 <gabbs> yea, it is ãƒ„
02:05:49 * gabbs reads up on it
02:05:55 <BeelsebobWork> oops, missed a .ReadP.
02:06:18 <therp> gabbs: :) @ your smilie.
02:06:22 <gabbs> Symetrical chouce, nice
02:06:38 <gabbs> heh, its a "souvenir" from a japan trip where everyone used it
02:07:28 <lobo9> _Dae_: I would find a use for it.
02:07:38 <_Dae_> gabbs: figures your japanese souvenir would be digital :p
02:07:47 <BeelsebobWork> heh
02:08:14 * gabbs blushes :P
02:08:54 <codacola> aw, no one in ##politics answered my question :(
02:09:18 <_Dae_> lobo9: well, it's a great language, but if what you do is mainly programming for webservers I don't know if the limited library would be a limitation?
02:10:22 <Axman6> gabbs: that's possibly the smallest souvenir ever
02:11:16 <_Dae_> Axman6: that's one of them "what's highest? the eiffel tower or an lsd trip?"-kind of comparisons, ain't it?
02:11:32 <lobo9> _Dae_ : I dabble in lots of different areas, but mainly I would like to pursue projects in encryption and security
02:11:51 <Axman6> i was thinking about the physical size used to store the bytes
02:12:06 <Axman6> could be as low as 16*45nm
02:12:35 <Axman6> or, 720nm for those who... well for just me
02:13:18 <gabbs> Axman6, its Unicode, so I guess someone might have found an ASCII souvenir, making that the smallest souvenir ever ãƒ„
02:13:21 <dolio> @src Int64
02:13:21 <lambdabot> data Int64 = I64# Int64#
02:14:04 <lobo9> Anyway, I've heard that 'haskell is the future of computer programming', so I figure I should learn it so I can be first to write hello world tutorials in 24 hours for all the publishers.
02:14:05 <Axman6> gabbs: i don't think many people would want an ASCII souvenir though.
02:14:14 <_Dae_> Axman6: I suppose  that would make it smaller than, say, a scantily-clad manga-figurine
02:14:15 <gabbs> true
02:14:37 <Axman6> lobo9: i'd argue that erlang is closer to being the way of the future. but that's debatable
02:14:51 <codacola> i have to wonder what my "tutorial" was marked on. "10/10"
02:14:58 <codacola> there werent 10 thigns to mark
02:15:00 <Axman6> _Dae_: unless it was etched on a CPU... they do such things
02:15:03 <lobo9> hm, interesting
02:15:35 <codacola> if haskell is the future then we're all doomed
02:15:47 <_Dae_> what?
02:15:57 <Axman6> since CPU's can't really get that much faster, so we're getting more cores, and erlang is designed for taking advantage of such things easily
02:16:36 <catface> better than haskell?
02:16:48 <Axman6> better at what?
02:16:49 <_Dae_> Axman6: you're saying that writing 'par' is too hard in haskell?
02:16:56 <_zenon_> Axman6, then there is the whole problem of designing efficient parallell algorithms-
02:16:58 <catface> taking advantage of such things easily
02:17:00 <Axman6> _Dae_: far too hard!
02:17:04 <lobo9> codacola: why's that?
02:17:05 <Axman6> three times harder than !
02:17:23 <codacola> lobo9: was a joke
02:17:40 <lobo9> Oh ok..  I was freaking out for a minute.
02:17:50 <codacola> though oddly my lecturer admitted the other day that haskell ispurely a research tool
02:17:51 <Axman6> _Dae_: thing is, distributed haskell is, afaik, non-existant
02:18:10 <Axman6> codacola: where are you studying?
02:18:25 <codacola> computer science....
02:18:37 <Axman6> where...
02:18:48 <codacola> oh
02:18:49 <codacola> sorry
02:18:57 <_Dae_> Axman6: not true but it is somewhat dead.  But now you've gone from saying that parallel computing is the future, to saying distributed computing is, which I think may be somewhat of an overstatement
02:18:59 <codacola> massey,new zealand
02:19:13 <lobo9> Aw, I wanna go to nz
02:19:18 <gabbs> when I have a: do (1).... do (2)... return X +++ do (3) ....return Y
02:19:22 <lobo9> zorbing
02:19:26 <gabbs> which two do's will be evaluated with +++ ?
02:19:30 <baaba> both are the future
02:19:33 <codacola> why does everyone want to come to nz?
02:19:34 <gabbs> 2 and 3, right?
02:19:50 <Axman6> _Dae_: i didn't say such i thing, i was saying that using more than one core in erlang, be it local or remote is easy, and the same thing as far as the language is concerned
02:19:58 <lobo9> nz has sheet too.  that attracts perverts.
02:20:01 <baaba> i think it'll be very interesting to see more systems like erlang where the lines are blurred
02:20:04 <lobo9> ooops. sheep*
02:20:11 <baaba> between multicore parallellism and multi-computer parallellism
02:20:19 <Axman6> i'm also not trying to say that erlang is better than haskell. i really really miss haskell's type checking :(
02:20:24 <Cale> gabbs: I'm not sure that I understand your example there...
02:20:41 <codacola> every country has sheep....
02:20:42 <gabbs> let me make it with brackets as pseudo code
02:20:47 <lobo9> Axman6: do you know erlang too?
02:20:48 <_Dae_> Axman6: but that was also true for distributed haskell, and could, with relative ease be reimplemented. Also http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=erlang <- those ain't no lightweight threads
02:20:50 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel® Pentium® 4 Computer Language Benchmarks ..., http://tinyurl.com/6rhwtr
02:20:51 <Axman6> codacola: nice. i'm at ANU atm
02:20:58 <Axman6> lobo9: yeah, a bit
02:21:11 <Cale> gabbs: if you want to paste something longer, you could put it on hpaste
02:21:13 <Cale> !paste
02:21:21 <codacola> ah, either you were here yestrerday or someone else at anu was here yesterday
02:21:24 <Cale> http://hpaste.org/new\
02:21:27 <Cale> whoops :)
02:21:29 <Cale> http://hpaste.org/new
02:21:36 <baaba> _Dae_, "could be implemented" is quite different from "has been used in production for decades"
02:21:47 <Axman6> baaba: exactly
02:22:03 <Axman6> thing is, Erlang was designed for it
02:22:17 <_Dae_> baaba: "has been implemented", just not updated to the newest versions of ghc
02:22:38 <Axman6> and comparing to plain erlang isn't really fair, you need HiPE to do a proper comparison
02:23:06 <_Dae_> but that doesn't really change the picture at all?
02:23:33 <Cale> I want to see Data Parallel Haskell extended to do distributed computation in a reasonably smart way.
02:23:34 <Axman6> yeah, but still
02:23:36 <codacola> life isnt fair :P
02:24:09 <_Dae_> Cale: it was.... I'm not sure why development was discontinued
02:24:13 <Cale> (Actually, I'll be happy to see it working for SMP in the next GHC :)
02:24:18 <Cale> _Dae_: oh yeah?
02:24:34 <gabbs> Cale, http://hpaste.org/9135
02:24:46 <Axman6> anyway, i wasn't talking about performance
02:24:51 <gabbs> I am just curious what two do blocks get evaluated in such an example
02:24:57 <_Dae_> Axman6: weren't you?
02:25:00 <Cale> _Dae_: I imagine there are some subtleties to that which make the problem harder than they want to deal with at first.
02:25:11 <Axman6> no
02:25:26 <Cale> gabbs: potentially all of them
02:25:41 <_Dae_> Cale: parallel haskell and distributed haskell was the same thing at first, using same syntax 'n' all.
02:25:43 <Cale> gabbs: I'll add explicit braces for you
02:25:45 <gabbs> hmm, any way to figure it out?
02:26:02 <_Dae_> Axman6: but... what was the smart thing about erlang again then?
02:26:12 <codacola> someone should write a texas holdem game  in haskell
02:26:26 <Axman6> easy concurrent systems
02:26:50 <baaba> supervision hierarchies are a pretty important part that need to work in a unified manner
02:27:16 <_Dae_> Axman6: as opposed to haskell?
02:27:32 <Axman6> yes
02:28:00 <Axman6> i also like it's bit syntax
02:28:15 <Cale> er, actually...
02:28:21 <Cale> I may have that wrong :)
02:28:23 <_Dae_> Right... ok, I get the feeling I need to write more elrang to fully appreciate that arguement
02:28:30 <Cale> (it's indented kind of strangely :)
02:28:32 <_Dae_> *erlang
02:28:42 <Axman6> does haskell have an easy way to take the first three bits of a piece of binary data? (i'm asking because i don't know)
02:29:00 <gabbs> oh, by all means Cale - I may have indented it the wrong way ãƒ„
02:29:08 <gabbs> I am quite new to languages that consider indentation
02:29:11 <dolio> What is a binary piece of data?
02:29:22 <gabbs> well, except some terrible fortran experiments in my youth
02:29:41 <baaba> something you get over the network and need to decode
02:29:50 <Axman6> _Dae_: i haven't used it, but i think it looks something like <R/5, G/6, B/5> to get say a a 16bit RGB value
02:29:52 <baaba> perhaps a media stream
02:29:52 <Cale> http://hpaste.org/9135#a2
02:30:14 <Axman6> baaba: i take it you've read the joe armstrong book?
02:30:19 <baaba> yes :P
02:30:40 <_zenon_> Is there some function    best :: [a] -> (a -> Num) -> a          which returns the element in [a] with the highest value assigned by the function?
02:30:40 <baaba> the bit syntax for a 16-bit RGB value would be: <<R:5, G:6, B:5>> = RGB
02:30:45 <Cale> gabbs: Note that embedded do-blocks inside do-blocks like that can always be collapsed
02:30:47 <Axman6> i was trying not to use examples from the book :P
02:30:59 <_zenon_> or will I just write it myself ?
02:31:00 <Cale> _zenon_: You can use maximumBy
02:31:05 <baaba> it's a valid example though
02:31:08 <_zenon_> Cale, thanks :)
02:31:11 <Cale> _zenon_: maximumBy (comparing f)
02:31:14 <Axman6> baaba: ah right, cheers
02:31:17 <_zenon_> is it in Data.List ?
02:31:21 <Cale> Yeah
02:31:26 <Cale> and comparing is in Data.Ord
02:31:32 <baaba> the erlang binary syntax evolved for easy binary protocol usage
02:31:34 <_zenon_> thanks
02:31:39 <baaba> since erlang was created largely for telecom systems
02:31:51 <baaba> where you most certainly didn't have xml or the like :P
02:32:09 <Axman6> i do like the MPEG stream decoding example, it's a very good example
02:32:35 <baaba> it's very useful for reading and writing binary data in general
02:32:36 <Axman6> since the MPEG frame header is rather difficult in most languages
02:32:38 <baaba> but that's about it
02:34:55 <lobo9> wait. i can't find the joe armstrong book
02:35:10 <lobo9> anyone have a link?
02:35:15 <hml> in list comprehension; can i generate more than one element at a time?
02:35:30 <_Dae_> Right, like  said, I would need to have written more erlang to appreciate that. I guess it would help if I knew what the problem was it was easier to solve in erlang
02:36:20 <taruti> hml: concat [ [e1, e2] | ... ]
02:37:00 <lobo9> ah, its programming erlang.
02:37:10 <FordCortina> is there a way to get the functions in the current module to take precedence over imported functions?
02:37:25 <FordCortina> say im working on module Foo and import module Bar
02:38:02 <FordCortina> how do i get unqualified "empty" in Foo to be Foo.empty and not Bar.empty
02:38:20 <_zenon_> FordCortina, You might wish to look at this http://en.wikibooks.org/wiki/Haskell/Modules
02:39:19 <FordCortina> thanks, but im still confused
02:39:36 <FordCortina> i can use "qualified" with Bar
02:39:52 <FordCortina> but then all the functions in Bar must be qualified right?
02:40:15 <taruti> FordCortina: import Bar hiding(empty); import qualified Bar as B
02:40:28 <FordCortina> ah!
02:40:50 <FordCortina> thanks
02:41:13 <lobo9> has anyone read 'haskell:  the craft of functional programming'
02:41:25 <FordCortina> lobo9: a bit
02:41:59 <lobo9> FordCortina: Is it any good?
02:42:25 <FordCortina> lobo9: its alright, but not very practical
02:42:40 <FordCortina> the coverage on monads can be confusing
02:42:50 <therp> lobo9: I think I have..
02:42:51 <FordCortina> although i suppose the basic treatment of IO is okay
02:43:03 <lobo9> hmm
02:43:08 <therp> lobo9: I found it ok
02:43:30 <Axman6> lobo9: it was our textbook, we basically never used it, but i picked up the language pretty quickly anyway
02:43:43 <Axman6> the green one with some church thing on the front, right?
02:44:02 <lobo9> Yeah it looks like such.
02:44:06 <therp> is there actual anything that "ports" common imperative techniques (while loops, continue in loops, break in loops, switch statements) to Haskell programming patterns?
02:44:08 <FordCortina> yeh
02:44:23 <lobo9> I have a lot of textbooks like that that I never used.
02:44:29 <FordCortina> it has a picture of a guy with a haunched back from writing too much haskell :D
02:44:38 <lobo9> hmm, how about 'The Haskell Road to Logic, Maths and Programming'
02:44:46 <therp> lobo9: I got mine from the library..
02:45:05 <lobo9> haha.. FordCortina: that might justify me buying it.
02:45:15 * _zenon_ is going out for a chiabatta hunt,
02:45:26 <_zenon_> in the deep djungle of cheap foodz
02:45:34 * lobo9 <3 hardcore coders.
02:45:51 <Axman6> "When the LHC is switched on it will operate at an energy of five trillion electron-volts." awesome
02:46:02 <lobo9> Many of my professors have lots of wrist problems from too much coding
02:46:07 <Axman6> although, an elextron volt is 1.6x10^-19 volts...
02:47:10 <Axman6> electron even
02:47:42 <Axman6> http://news.bbc.co.uk/2/hi/science/nature/7512586.stm for anyone interested in the final phases of the LHC
02:47:43 <lambdabot> Title: BBC NEWS | Science/Nature | Cern lab goes 'colder than space'
02:47:47 <lobo9> Axman6 : I love electrons too.
02:49:31 <FordCortina> lobo9: "The Haskell School of Expression" is looks more fun. IMHO It gives you more of a feel for what real haskell programs are like.
02:50:17 <FordCortina> lobo9: I have copy although I havent read the whole thing yet, unlike Thompson's book
02:53:32 <lobo9> hmm, ok thx FordCortina, I'll look into that.
02:54:13 <chylli> how to check whether a file exist ?
02:56:18 <lnxz> chylli, System.Directory.doesFileExist
02:56:25 <chylli> thanks
03:01:07 <JaffaCake> @seen therp
03:01:07 <lambdabot> therp is in #haskell. I last heard therp speak 16m 21s ago.
03:01:47 <JaffaCake> therp: I'm working on polishing shared libraries for 6.10
03:02:12 <JaffaCake> I just discovered a problem with the way we link the RTS
03:07:27 <_zenon_> a geeesh
03:07:30 <_zenon_> the radio just died
03:07:35 <_zenon_> And I have no soundcard in this machine
03:07:40 <_zenon_> => no radio
03:07:43 <_zenon_> I'll have to sing
03:20:21 <_zenon_> @pl (\x -> assign x 1 (jobtype j))
03:20:22 <lambdabot> flip (flip assign 1) (jobtype j)
03:20:26 <_zenon_> nah
03:29:27 <hackage> Uploaded to hackage: nat 0.1
03:33:19 <therp> JaffaCake: pong. my quad core is waiting for its DDR2 ram. I planned to restart hacking on that after I got new hardware (compiling GHC was just too boring).
03:33:31 <therp> JaffaCake: what's the RTS problem?
03:33:37 <JaffaCake> hi therp
03:34:18 <JaffaCake> ok, so the problem is this: when we link the .so for a package, we link against the RTS, so libHSrts-ghc6.9.so is recorded as being needed in base's .so
03:34:36 <JaffaCake> but when linking the program, if we use -threaded, then we need to link a different RTS
03:34:51 <therp> hm.. right
03:34:51 <JaffaCake> so in fact we end up linking two RTS's
03:35:12 <JaffaCake> I think this is causing breakage in GHCi
03:35:15 <therp> a quickfix is LD_LIBRARY_PATH hacks
03:35:40 <JaffaCake> I thought about that, I don't think it's a good solution
03:35:54 <therp> right, that's not pretty
03:36:00 <JaffaCake> we'd need a wrapper for every binary using -threaded
03:36:31 <JaffaCake> so I *think* the right way is just to not link the RTS when linking base.so
03:36:33 <therp> did I commit the wrapper work I've done? I think so.. so the code would be there..
03:36:44 <JaffaCake> yes we have the wrapper
03:36:55 <JaffaCake> although I'm not keen on the wrapper talking to ghc-pkg
03:37:05 <therp> JaffaCake: as base.so references symbols that might not be possible. however we could ELF edit the resulting .so file to kick that dependency out
03:37:16 <therp> s/symbols/RTS symbols/
03:37:32 <JaffaCake> it does seem to work fine to link the .so without the RTS dependency
03:37:41 <therp> huch?
03:37:47 <JaffaCake> however I haven't tested making a binary yet
03:37:53 <therp> ld is not complaining?
03:38:02 <idnar> that should be fine
03:38:04 <JaffaCake> right - a .so with undefined symbols is fine
03:38:17 <idnar> you'll just have a problem if you try to load it into a process without the symbols being available
03:38:25 <SamB> no warnings or anything?
03:38:29 <JaffaCake> no warnings
03:38:41 <therp> I'm not sure. I vaguely remember that this was necessary for some reason..
03:38:50 <SamB> that does not give me a warm fuzzy feeling :-(
03:38:54 <JaffaCake> ld has a flag --allow-shklib-undefined, which is on by default
03:39:07 <idnar> SamB: why?
03:39:22 <idnar> SamB: I'm under the impression this is a fairly widespread use case
03:39:31 <therp> JaffaCake: btw you'd have to kick out the RTS not just for base but in general. but this shouldn't be a problem..
03:39:40 <JaffaCake> yes
03:39:55 <JaffaCake> I've modified ghc to do that, just waiting for it to compile
03:40:06 <therp> so this would be cabal patch filtering the RTS package from the linker invocation? or we could patch ghc itself to filter "-package rts"
03:40:48 <JaffaCake> I'm patching ghc itself to omit the RTS when linking a .so
03:41:22 <JaffaCake>  yes I do vaguely remember you were linking the RTS on purpose... was it something to do with the recrusve dep between base and RTS?
03:41:56 <therp> hm. I think so. windows was the problem IIRC
03:42:22 <JaffaCake> ok, I might not get to Windows for 6.10.1 anyway
03:42:30 <Arnar_> mornin' folks
03:42:49 <therp> but if both import libraries for the regular and for the threaded RTS are compatible in the sense that you could just change the DLL underneath without breaking base.dll that should be ok too
03:43:19 <Arnar_> does anyone know of a defined name for foldr (flip (.)) id ? alternatively, can I ask lambdabot somehow?
03:43:35 <SamB> therp: what do you mean by "okay too"?
03:43:40 <Cale> Arnar_: there isn't one in the libraries
03:43:46 <opqdonut> :t mconcat
03:43:46 <lambdabot> forall a. (Monoid a) => [a] -> a
03:43:59 <opqdonut> ?src mappend (->)
03:43:59 <lambdabot> Source not found. My mind is going. I can feel it.
03:44:05 <Arnar_> Cale: ok.. but it's come up before?
03:44:06 <opqdonut> ?src (->) mappend
03:44:06 <lambdabot> Source not found. :(
03:44:20 <Cale> Arnar_: you could use hoogle/hayoo
03:44:22 <opqdonut> Arnar_: that's just the mconcat for the a->a monoid
03:44:32 <Cale> opqdonut: Endo :)
03:44:32 <Arnar_> Cale: I tried.. but just hoogling foldr (flip (.)) id gives a syntax error
03:44:39 <opqdonut> Cale: ah, Endo
03:44:43 <Cale> Arnar_: put the type
03:44:44 <Arnar_> opqdonut: ah.. right
03:44:44 <opqdonut> ?src Endo mappend
03:44:44 <lambdabot> Source not found. I feel much better now.
03:44:51 <opqdonut> anyways
03:44:53 <Arnar_> :t foldr (flip (.)) id
03:44:57 <Cale> opqdonut: the default instance of Monoid for functions is the lifting instance
03:44:57 <lambdabot> forall a. [a -> a] -> a -> a
03:44:59 <therp> SamB: in the sense that base.dll despited linked against rts_imp.dll would also work when we replace rts.dll with rts-threaded.dll.
03:45:08 <opqdonut> :t mappend [Endo id, Endo (+1)]
03:45:09 <lambdabot> forall a. (Num a) => [Endo a] -> [Endo a]
03:45:18 <opqdonut> :t mconcat [Endo id, Endo (+1)]
03:45:19 <lambdabot> forall a. (Num a) => Endo a
03:45:23 <opqdonut> there
03:45:33 <opqdonut> this flu is really wrecking havoc with my brain
03:45:59 <SamB> therp: don't symbols from DLLs get imported from those *particular* DLLs explicitly ?
03:46:04 <opqdonut> great timing, too. i'm attending the imc math contest next week...
03:46:23 <Cale> opqdonut: but does that get them in the right order?
03:46:24 <Arnar_> Endo == "the a->a monoid" ?
03:46:31 <Cale> Arnar_: yeah
03:46:46 <EvilTerran> mempty = id, mappend = (.)
03:47:21 <SamB> therp: I *suppose* it might be possible to just use the same name internally for both RTS DLLs, but don't see how the .exe would bring it in then ...
03:47:32 <therp> SamB: what do you mean by imported? when linking foo.dll that imports from another.dll, no these symbols are not directly imported, but only the respective import lib. the import lib basically reserves a bunch of memory locations that are patched with addresses of the real symbol when the another.dll is loaded
03:48:23 <SamB> therp: it also says what things are imported, and from what DLL, does it not?
03:48:28 <Arnar> if mappend = (.) - won't that give the right-to-left order?
03:49:17 <SamB> Arnar: why would it?
03:49:25 <therp> SamB: I think so. the linker section that causes the dependency to show up in foo.dll is sucked from another_imp.a
03:49:41 <EvilTerran> if it does, you want Dual (Endo a)
03:49:57 <Arnar> SamB: because f.g x is f (g x)
03:49:58 <SamB> Arnar: the DList package on hackage would seem to indicate otherwise
03:50:05 <Arnar> SamB: ok
03:50:24 <EvilTerran> instance Monoid a => Monoid (Dual a) where mempty = Dual mempty; Dual x `mappend` Dual y = Dual (y `mappend` x)
03:50:41 <Arnar> EvilTerran: right.. "arrows reversed"
03:50:47 <opqdonut> yeah or just reverse the list
03:51:00 <EvilTerran> Endo f `mappend` Endo g = Endo (f . g)
03:51:10 <FordCortina> does Agda2 allow infinite types?
03:51:15 <Arnar> sure.. I'm completely happy with foldr (flip (.)) id .. just curious
03:51:34 <Arnar> how do I 'apply' Endo instances?
03:51:50 <SamB> FordCortina: that area seems ripe for research -- in other words, I haven't seen a decent implementation
03:52:02 <chylli> what is used more often between HaXml and HXT ?
03:52:07 <Arnar> nm, found it
03:53:19 <Arnar> appEndo $ mappend [Endo (+2), Endo (/2)] 6
03:53:23 <Arnar> > appEndo $ mappend [Endo (+2), Endo (/2)] 6
03:53:25 <lambdabot>  Couldn't match expected type `Endo a'
03:54:10 <EvilTerran> > mappend [Endo (+2), Endo (/2)] `appEndo` 6
03:54:11 <lambdabot>  Couldn't match expected type `Endo a'
03:54:19 <Arnar> > appEndo $ mconcat [Endo (+2), Endo (/2)] 6
03:54:20 <lambdabot>  Couldn't match expected type `t -> Endo a'
03:54:22 <EvilTerran> > mconcat [Endo (+2), Endo (/2)] `appEndo` 6
03:54:24 <lambdabot>  5.0
03:54:35 <Arnar> ok, so it is right-to-left
03:54:35 <EvilTerran> > mconcat [Endo (+x), Endo (/y)] `appEndo` z
03:54:36 <lambdabot>  z / y + x
03:55:16 <Twey> chylli: HaXml, I believe
03:55:28 <Twey> I hadn't heard of HXT before today, anyway.
03:55:49 <EvilTerran> > (appEndo . getDual . mconcat . map (Dual.Endo)) [(+x), (/y)] z
03:55:50 <lambdabot>   Not in scope: data constructor `Dual.Endo'
03:55:54 <EvilTerran> > (appEndo . getDual . mconcat . map (Dual . Endo)) [(+x), (/y)] z
03:55:55 <lambdabot>  (z + x) / y
03:56:15 <Arnar> :t getDual
03:56:15 <lambdabot> forall a. Dual a -> a
03:56:41 <EvilTerran> newtype Dual a = Dual { getDual :: a }
03:57:05 <chylli> Twey: has you used it before ? is there some sample?
03:57:28 <Arnar> @instances Dual
03:57:29 <lambdabot> Couldn't find class `Dual'. Try @instances-importing
03:57:40 <Arnar> no?
03:58:05 <Arnar> @index Dual
03:58:05 <lambdabot> bzzt
03:58:18 <dolio> Dual is a type, not a class.
03:58:25 <dolio> Or, Dual a is a type.
03:58:31 <Arnar> dolio: I thought @index worked on types also
03:58:42 <dolio> index barely ever works. :)
03:58:45 <Arnar> :)
03:58:58 <SamB> @hoogle Dual
03:58:58 <lambdabot> Data.Monoid.Dual :: newtype Dual a
03:58:58 <lambdabot> Data.Monoid.Dual :: a -> Dual a
03:58:58 <lambdabot> Data.Monoid.getDual :: Dual a -> a
03:59:43 <Arnar> ah.. I get it now.. sorry, thanks
04:14:37 <nornagon> hmm, i see cairo bindings inside gtk2hs, but no pure cairo bindings...
04:14:46 <nornagon> i want to use cairo for rendering into SDL :)
04:16:08 <nornagon> that might require my own hackery, because the way i'm doing it in C is to create a cairo surface from the pixel buffer SDL gives me...
04:16:10 <SamB> nornagon: but does it actually depend on gtk2hs? it doesn't seem to pull it in here ...
04:16:37 <SamB> er, I mean, it only seems to pull in the "glib" package
04:16:46 <SamB> not the "gtk" package or anything
04:16:58 <_zenon_> I hoogled for   [a] -> [a] -> (a -> a -> Bool) -> [(a,a)]
04:17:05 <nornagon> SamB: hrm, not sure...
04:17:15 <mxc> good evening, someone newbie-ish monad question, is there anything massively wrong with nesting two ReaderT monads?  most of my system needs the more basic reader, but for parts of it, i'd like to have a different reader type, but still access to the simpler reader type
04:17:21 <mxc> make any sense?
04:17:32 <_zenon_> but I can't find such a method, given two lists, and a comparator, both lists equally long, make tuples of all elements matching by function
04:18:55 <SamB> mxc: well, it would be difficult to "ask" the inner one anything ...
04:19:12 <QtPlatypus> _zenon_: Shouldn't that be pritty easy to build up from filter and such like?
04:19:12 <mxc> liftM . ask?
04:19:25 <_zenon_> QtPlatypus, yeah, I'm on it :)
04:19:32 <mxc> oh, wait
04:19:36 <_zenon_> Just wanted to check if the wheel already was invented
04:21:21 <mxc> :t liftM
04:21:22 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:21:32 <dcoutts> nornagon: right, cairo is a separate package from gtk, but it's currently built within the gtk2hs build system
04:21:33 <byorgey> mxc: yeah, there's nothing inherently wrong with nesting ReaderT monads, but as SamB points out you can't have both of them derive MonadReader.
04:21:34 <mxc> :t lift
04:21:35 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
04:21:59 <nornagon> dcoutts: oic :)
04:22:16 <nornagon> how scary :)
04:22:21 <byorgey> mxc: in which case you'd be better off having neither of them derive MonadReader and just use ask1 = lift . lift . ask  and ask2 = lift . ask or whatever
04:22:45 <byorgey> mxc: put personally, instead of having  ReaderT a (ReaderT b ...)  I would just use  ReaderT (a,b) ...
04:23:18 <byorgey> mxc: oh, I see, but most of the time you only want one
04:23:30 <mxc> byorgey, well, the upside of the first thing is that i already have a lot of functions which run in ReaderT b IO
04:23:41 <byorgey> mxc: yes, I see
04:23:52 <mxc> so i could run them in ReaderT a with somehting like runReaderT fxn ask
04:24:18 <byorgey> mxc: yeah, if you build up some convenience functions like that it shouldn't be too bad
04:24:39 <mxc> see you in hell boilerplate code..
04:27:47 <mapreduce> _Dae_: For what it's worth, I got my typed actors running.
04:28:02 <mapreduce> Or rather, I got my running actors typed :)
04:28:23 <_Dae_> mapreduce: heh, ok
04:28:48 <matthew-_> mapreduce: how much do you type?
04:29:10 <matthew-_> i.e. just the type of the actor or do you type the mailbox hetergeneously?
04:29:26 <mapreduce> Both.
04:29:43 <mapreduce> It's in Java, though I'll probably make a Scala implementation later today.
04:30:28 <matthew-_> and you can pattern match remove messages from the mailbox?
04:32:09 <matthew-_> if the mailbox is truely heterogeneous, and you can dynamically remove any message from that mailbox, how do you successfully type it? Or am I missing something here?
04:35:09 <mapreduce> I'm trying to avoid pattern matching.
04:35:38 <mapreduce> If you can read/want to read Java I'll pastebin a working example.
04:46:04 <JaffaCake> therp: omitting the RTS seems to work ok
04:46:22 <JaffaCake> therp: although it hasn't fixed the crash I'm seeing in GHCi
04:47:03 <matthew-_> mapreduce: yeah, I can read java. ;)
04:51:43 <nornagon> dcoutts: is there any way i can build just cairo?
04:55:12 <dcoutts_> nornagon: no, not at the moment. gtk2hs will be converted to build with cabal and at that point it'll be trivial.
04:55:33 <dcoutts_> nornagon: the minimum at the moment is glib, cairo and gtk packages
04:55:40 <pastorn> weee! netsplit
04:55:45 <_zenon_> that's odd
04:56:41 <_zenon_> Still over 400, all is good
04:57:22 <mapreduce> matthew-_: http://pastebin.com/m3289a379 for a naive version.
04:57:35 <nornagon> dcoutts_: rats
04:57:44 <nornagon> dcoutts_: might just bind cairo myself then...
04:58:05 <mapreduce> matthew-_: http://pastebin.com/m68369419 for a version that solves a typing problem with actors sending themselves and back again.
04:58:08 <mapreduce> (infinite types)
04:58:14 <dcoutts_> nornagon: don't do that, if you want to try and build the cairo code separately then do that.
04:58:29 <TSC> Is it possible to get a stack space statistics from GHC (similar to the heap space statistics with -sstderr) ?
04:58:36 <dcoutts_> nornagon: the code is perfectly good, it's just a build system issue.
04:59:01 <nornagon> dcoutts_: *nod*
04:59:18 <nornagon> hrm, how do i turn a .hs.pp into something useful? cpp maybe?
05:00:25 <nornagon> I'll do it manually for now...
05:00:55 <nornagon> on second thoughts, that could be problematic
05:06:45 <dcoutts_> nornagon: just rename to .hs and add {-# LANGUAGE CPP #-} at the top of the file
05:06:56 <dcoutts_> or add extensions: CPP to the .cabal file
05:07:25 <nornagon> aha :)
05:07:50 <nornagon> hrm
05:08:23 <nornagon> *installs c2hs*
05:10:13 <nornagon> beh, now it's complaining about not being able to find a .chi
05:14:57 <mapreduce> matthew-_: My Java code obviously hurt :)
05:17:33 <_zenon_> How do you reproduce that funny feeling you had the first time you saw higher level Haskell code and thought "I really don't understand this" ?
05:17:51 <opqdonut> good question
05:18:10 <opqdonut> probably by digging up a suitable math paper
05:18:50 <magr> _zenon_: try reading some Agda code
05:18:53 <SamB_XP_> _zenon_: is it a bug?
05:18:56 <Zao> The difference is that you will never understand most math papers.
05:19:18 <_zenon_> magr, Agda you say? Okay, I'll try to find some
05:19:30 <_zenon_> SamB_XP_, I don't follow.... bug?
05:19:43 <SamB_XP_> stupid joke
05:20:31 <_zenon_> hm. okay. I missed it.
05:20:32 <_zenon_> sorry
05:21:03 <SamB_XP_> I said it was stupid, you know
05:21:12 <SamB_XP_> that absolves you of any guilt in not getting it
05:21:53 <_zenon_> Ah. Nice.
05:22:00 <_zenon_> Feels better already
05:22:26 <SamB_XP_> hehe
05:25:38 <_zenon_> :i "is it a bug?"
05:25:39 <_zenon_> instance Stupid -- defined in #haskell
05:26:53 <_zenon_> funny ?
05:27:35 <SamB_XP_> is that a ZPTC?
05:27:58 <mauke> heh
05:29:04 <_zenon_> what is ZPTC?
05:29:51 <ToRA> zero parameter type class
05:30:03 <nornagon> dcoutts_: that Cairo.hs.pp is still giving me trouble with #if CAIRO_CHECK_VERSION(1,2,0)
05:30:05 <ToRA> a mythical language construct that doesn't exist
05:30:26 <ToRA> i once thought i had a motivating use case for one
05:30:44 <SamB_XP_> ToRA: ???
05:30:57 <dcoutts_> nornagon: that'll be because the CAIRO_CHECK_VERSION macro is not defined, because you're not including a config header. It's probably easier to just take the conditional out and just require cairo-1.2 or later.
05:31:06 <_zenon_> ahhh....
05:31:08 <nornagon> dcoutts_: *nod*
05:31:26 <dcoutts_> nornagon: you can use in your .cabal file: pkgconfig-depends: cairo >= 1.2
05:31:51 <dcoutts_> nornagon: that will find all the C flags for you and will check with pkg-config that the right version is available
05:32:16 <ToRA> SamB_XP_: you could in theory think of a ZPTC being a normal TC indexed by a module name, thus you can only have one instance per module (and only ever import one module that defines the tc)
05:33:10 <ToRA> iirc my use case was kinda along those lines (it did involve lots of auto-generated code that used a library core)
05:33:18 <Philippa> ToRA: yeah, though that does weird things with coherency - which is why you can't hide instances
05:33:31 <nornagon> dcoutts_: ah :)
05:33:39 <nornagon> beh, cabal doesn't seem to be properly picking up on the .chs files
05:33:59 <dcoutts_> nornagon: you must list all the modules in exposed-modules, or extra-modules
05:34:06 <nornagon> i get Could not find module `Graphics.Rendering.Cairo.Internal.Utilities', because that file happens to be called Graphics/Rendering/Cairo/Internal/Utilities.chs
05:34:06 <dcoutts_> erm other-modules
05:34:09 <nornagon> ah
05:34:10 <nornagon> okay :)
05:34:20 <mapreduce> _zenon_: You reproduce that feeling my explaining it to someone else.
05:34:35 <ToRA> Philippa: but you can existentially wrap them up and pass them into a third module (i think), which can use multiple instances from different places
05:35:00 <dcoutts_> nornagon: the main problem you'll have is this: cabal does not know about dependencies *between* .chs files. So you must list them in dependency order.
05:35:15 * nornagon bets he'll find a circular one
05:35:36 <dcoutts_> nornagon: heh, no, that would not work in the existing build system either
05:35:54 <dcoutts_> nornagon: that might be tricky if you're splitting the modules between exposed- and other-
05:36:19 <dcoutts_> nornagon: so initially just go for exposing them all
05:36:29 * nornagon will add them in the order that the errors show up
05:36:46 <dcoutts_> nornagon: that missing cabal feature is one of the main reasons we've not yet cabalised gtk2hs.
05:37:07 <dcoutts_> you can list them in dep order for cairo since it's not that big, but the gtk package has 100+ modules
05:37:28 <Philippa> ToRA: by that point you may as well just define a record type in one place and record all under the same identifier in others though
05:37:33 <Philippa> *records
05:38:31 <ToRA> Philippa: yup
05:39:29 <nornagon> dcoutts_: the other problem i'll have is where do i find cairo.h
05:39:38 <nornagon> currently i've hardcoded it to be in /usr/include/cairo
05:39:47 <nornagon> but i suspect i'll have to prod pkgconfig with a script or something
05:39:56 <dcoutts_> nornagon: don't do that. Use pkgconfig-depends: cairo >= 1.2
05:40:18 <nornagon> dcoutts_: and that'll find the -I for me?
05:40:32 <dcoutts_> nornagon: then Cabal asks pkg-config for all the flags
05:40:36 <nornagon> ah :)
05:40:49 <nornagon> awesome
05:40:54 <dcoutts_> and it checks that the system has the cairo pkg-config package installed and the right version
05:41:28 <nornagon> oh dear
05:41:34 <nornagon> c2hs errors :D
05:42:00 <nornagon> There is no default marshaller for this combination of Haskell and C type:   Haskell type: Matrix   C type      : (MatrixPtr)
05:42:20 <dcoutts_> nornagon: right, that's the next step. We had to make slight changes because the c2hs used in gtk2hs is an older fork.
05:42:20 <nornagon> this is using other-modules and exposed-modules, not just exposed...
05:42:46 <dcoutts_> nornagon: so a few changes to the .chs code will be necessary
05:42:51 <nornagon> *nod*
05:45:57 <nornagon> there is {#pointer *cairo_matrix_t as MatrixPtr -> Matrix#} in the Matrix module, so... hrm
05:46:42 <nornagon> maybe there's nothing for the other way around
05:46:54 <dcoutts_> nornagon: in the worst case when there is no default marshaler you'll just have to use an explicit marshaler
05:47:50 <nornagon> Matrix is already an instance of Storable
05:50:16 <nornagon> ah, right, c2hs is complaining it doesn't know how to get a Matrix back into C
06:11:44 <vincenz> bogner: issues?
06:11:45 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
06:12:25 <matthew-_> mapreduce: sorry, been in a rehearsal. Forgive me if I'm wrong, but can you put messages of different types in the same mailbox?
06:12:40 <dolio> Man, code.haskell.org is still running Cabal 1.1.6 (or earlier)?
06:13:23 <dcoutts_> dolio: the ghc on code.h.o is debian's ghc 6.6 package
06:13:42 <dolio> Heh.
06:13:53 <dcoutts_> dolio: we don't actually expect people to be building much on there since we don't really have the cpu power or memory.
06:14:26 <dolio> Yeah, I suppose not.
06:15:02 <dcoutts_> of course there's the new T5120 that Sun gave us with more memory and threads than you could shake a stick at
06:15:14 <dcoutts_> dolio: I hope eventually to use that as the community server
06:15:45 <dolio> That'll be nice.
06:16:09 <mfp> dcoutts_: I wouldn't use it to build anything, each of those 8 cores is much slower than a commodity x86 one
06:16:36 <dcoutts_> mfp: but there are loads and loads of them, so yes it depends on a good parallel build system
06:16:49 <cnwdup_> Hello. Can anyone tell me why my Queue (http://hpaste.org/9115) isn't working if it is reading an empty queue? It somehow doesn't wake up when the second thread writes to the queue. http://hpaste.org/9116
06:17:27 <christos> hi, how do I unimport something from ghci?
06:17:27 <mapreduce> matthew-_: No, you cannot put messages of different types in the same mailbox.  This is the whole point. :)
06:17:44 <mapreduce> matthew-_: You can use algebraic types for those times when you want to.
06:17:55 <dolio> christos: :m -
06:18:14 <christos> dolio thanks
06:20:21 <mfp> dcoutts_: even with 64 hardware threads, it's not much faster than some cheap x86 hardware, and you'll have to parallelize very well if you don't want it to be slower :-|
06:20:54 <dcoutts_> mfp: I'm a bit more optimistic than that :-) but we'll have to wait for the benchmarks wont we :-)
06:22:00 <mfp> IIRC it took me 90 minutes to compile ocamlopt on a T2000 (I don't remember how much it takes on a cheap x86_64 box, something like 5 minutes)
06:22:35 <mfp> 90 / 32 =~ 3 minutes, 5 / 2 = 2.5 minutes
06:22:42 <dcoutts_> mfp: because it was completely single threaded and not optimised for sparc?
06:23:22 <mfp> dcoutts: yes, the point is that even if it parallelized perfectly, it'd not be faster than using two x86_64 cores
06:23:26 <dcoutts_> mfp: does ocaml have a native sparc backend?
06:23:27 <bla123> i would think of this machine as an opportunity to test whether our parallelisation really works
06:23:31 <mfp> yes
06:24:01 <bla123> soon, your cheap x86 hardware will have as many cores as this one
06:24:38 <bla123> with 2 cores you might still get away with some cheats, not on 8 though
06:24:39 <mfp> (yes was to "native sparc backend")
06:26:17 <dcoutts_> mfp: oh, it was you who posted the link to ocaml doing well on benchmarks on a T5120 http://wikis.sun.com/display/WideFinder/Results
06:26:31 <mfp> I'm mfp everywhere, yes :)
06:26:34 <dcoutts_> mfp: so it can't be that bad right? :-)
06:26:51 <mfp> the T5120?
06:27:08 <dcoutts_> it's a box with a T2 processor
06:28:20 <Zao> Ooh, a Niagara 2.
06:28:40 <dcoutts_> Zao: right, that's what Sun have donated to us
06:28:51 <mfp> it was a response to "(the T5120) can't be that bad"; I've run some code on the T5120 too
06:29:16 <dcoutts_> mfp: sorry, misunderstanding.
06:29:30 <mfp> ocaml does well compared to others on that platform, but I'm not that impressed by either the T5120 nor the T2000
06:29:55 <mfp> I mean, even reading a file with mmap saturates a HW thread :-/
06:29:56 <Axman6> i think my uni i/was working on getting Sun to give them a T2
06:30:56 <Axman6> or rather, Sun offered one to them
06:30:59 <dcoutts_> mfp: one reason I was interested is because unlike ocaml, haskell tends to use a lot more memory indirections. So should benefit more from the latency hiding of multiplexing lots of threads.
06:31:00 <mfp> I guess the good thing is that the platform forces you to parallelize everything if you want acceptable speed :-)
06:31:42 <mfp> really? I thought GHC optimized many indirections with pointer tagging and such
06:32:04 <dcoutts_> mfp: yeah, but there's still more of them in total.
06:32:24 <mfp> (ocamlopt, OTOH, uses a regular encoding for algebraic types; it doesn't even unbox  type foo = A of int)
06:32:32 <nornagon> buh, all this c2hs stuff is breaking my brain
06:32:33 <dcoutts_> mfp: ocaml does really well at the low level benchmarks, it's got an excellent code gen and good single threaded performance.
06:33:11 <dcoutts_> ghc has a lot of work to do on its code gen to catch up to ocaml
06:33:35 <dolio> Lucky for us, they are.
06:33:40 <dolio> Supposedly, at least.
06:33:47 <dcoutts_> though fortunately that's now getting some attention, there are several projects on the go in that area
06:34:24 <mfp> well, ocamlopt's code gen is deficient compared to e.g. GCC for tight loops because of the 63-bit/31-bit arithmetic, no unboxing, etc., but the overall compilation strategy is sound and gives good perf
06:35:27 <mfp> also, floating point is slower on x86 because it doesn't use the stack effectively; it's about as fast as GCC on x86_64, though
06:37:28 <Maddas> That's fairly impressive. Is MLTon still a contender people talk about, or is SML losing too much ground (in terms of popularity) to O'Caml?
06:37:34 <mfp> dcoutts_: if you can get somebody to write a Wide Finder 2 in Haskell, we'll see how it parallelizes :) (not me because I can't get the same perf out of GHC as with ocamlopt yet)
06:37:51 <dcoutts_> mfp: good point
06:39:12 <dcoutts_> mfp: so are most versions there using multiple processes? most of those languages don't do threads directly right?
06:39:45 <mfp> Maddas: I hear one of the problems with SML is that you have to choose between fast compilation (smlnj) and good perf but slowww compiles (MLton)
06:40:19 <dolio> That's true with Haskell too, as it goes.
06:40:31 <mfp> dcoutts_: the langs running on the JVM are using threads AFAIK (Fan, Scala, Java...), the rest processes
06:40:41 <dcoutts_> right
06:40:44 <dolio> YHC/Hugs is faster than GHC, which generates better code.
06:41:18 <dolio> And JHC may never finish compiling your program, but if it does, it might be fast. :)
06:41:37 <mfp> I've also read there are subtle incompatibilies between SML compilers in spite of the standard; in Haskell you're going to use GHC anyway? (because of the extensions)
06:43:21 <dolio> GHC doesn't seem so terribly slow to me, either. But perhaps I'm too patient.
06:43:54 <dolio> Or maybe my machine is a lot faster than the people who end up caring about that.
06:45:43 <hackage> Uploaded to hackage: bytestring-show 0.1
06:45:43 <hackage> Uploaded to hackage: nat 0.1
06:45:43 <hackage> Uploaded to hackage: bytestring-lexing 0.1.2
06:45:44 <hackage> Uploaded to hackage: iException 0.0.1
06:45:46 <hackage> Uploaded to hackage: AvlTree 3.2
06:45:47 <mfp> Maddas: also, MLton seems to be slower than OCaml for pedestrian code (according to the shootout), the speed gains should come when you have lots of functors, but in the meantime you have to endure really slow builds, which sort of negates the advantages of abstraction relative to devel speed
06:47:27 <Maddas> mfp: Indeed.
06:48:50 <dolio> I'm not sure how good an indicator the shootout is of relative performance of typical code.
06:49:20 <dolio> Except maybe, C.
06:49:32 <mfp> it's not that bad IF the code used there is "typical" ;)
06:49:35 <dolio> And its ilk.
06:51:05 <dolio> Well, the haskell isn't particularly typical in many cases, although it's getting better.
06:51:29 <mfp> the overall scores just give a rough idea; you can use the bms to measure very precise things (allocation speed, FP, ...)
06:51:32 <dolio> I wouldn't be surprised if OCaml were in a similar situation.
06:52:13 <mfp> IMHO the OCaml code from the shootout is more idiomatic than the Haskell entries
06:52:53 <bonobo> hi
06:53:08 <bonobo> can I use HPC to see coverage of my library? How?
06:53:25 <mfp> the GHC entries are becoming more idiomatic by adding the required code to the libs ;)  OTOH the OCaml stdlib is effectively frozen (and the shootout won't use third-party libs IIRC)
06:58:10 <dcoutts_> @tell dons for your bytestring-lexing package, perhaps Text.Read.Lex.ByteString would be better? Or something under Text. See for example bytestring-show-0.1 has Text.Show.ByteString.
06:58:11 <lambdabot> Consider it noted.
07:20:23 <JaffaCake> therp: still there?
07:26:51 * byorgey yodels the ancient call of the lambda-herders
07:26:58 <dmwit> Hello?
07:27:00 <dmwit> yes?
07:27:03 <Axman6> o/
07:27:06 <bwr_> hi
07:27:07 * dmwit looks around dazed
07:27:18 <mauke> nomads. haskell nomads.
07:27:24 <byorgey> ah good, it still works =)
07:27:28 <dmwit> nomads making monads
07:27:31 <Axman6> laaaaaaaaaaaaaaambda
07:27:35 <dolio> mfp:  What were you using for test data for your CSV thing?
07:27:42 <dmwit> nomads, monads, so damn!
07:27:45 <byorgey> it's more like laaaaAAAaaaaaAaAAaAaaAAAmbda
07:28:13 <byorgey> hehe
07:28:16 <byorgey> hi dmwit
07:28:25 <dmwit> Hiya, byorgey!
07:28:26 <osfameron> daemons!
07:28:36 <dmwit> I should really be at work. =P
07:28:40 <Shiruka> nonads, for m ~ n
07:28:46 <byorgey> well, I should really be working
07:28:50 <dmwit> Shiruka: hehe
07:29:51 <byorgey> dmwit: you still in NY?
07:29:59 <dmwit> Yep!
07:30:05 <byorgey> cool, having fun I hope?
07:30:09 <Shiruka> if w is called a double-u, why isn't m called a double-n? ;-)
07:30:12 <dmwit> I got a place in Philly for the fall semester, finally! =D
07:30:20 <byorgey> dmwit: w00t! where is it?
07:30:37 <dmwit> uh... S. 46th
07:30:39 <dmwit> Does that help?
07:30:46 <byorgey> uh... where on S. 46th?
07:31:26 <dmwit> http://maps.google.com/maps?f=q&hl=en&geocode=&q=506+S.46th,Philadelphia,+PA&sll=40.697731,-73.993959&sspn=0.014397,0.008411&ie=UTF8&ll=39.95028,-75.214634&spn=0.014558,0.008411&z=16 right here
07:31:27 <lambdabot> Title: Google Maps, http://tinyurl.com/5kwruo
07:32:30 <byorgey> dmwit: dude, that's 4 blocks from our place =D
07:32:48 <dmwit> Rock!
07:32:56 <byorgey> we are in the 200 block of S. 46th
07:32:57 <dmwit> It's *so* pretty.
07:33:20 <byorgey> indeed, that's a really pretty neighborhood
07:33:26 <byorgey> I remember walking through there
07:34:13 <dmwit> Only downside is that I might have to find another place for the spring semester.
07:34:36 <dmwit> (The landlady is selling, and can't guarantee that the buyer will keep us on or even want to rent at all.)
07:35:08 <byorgey> ah, fair enough
07:35:14 <byorgey> oh well, at least it's something
07:35:18 <cnwdup_> > \a -> return $ a++b/redraw
07:35:22 <lambdabot>   Not in scope: `redraw'
07:35:27 <cnwdup_> > \a -> return $ a++b
07:35:28 <lambdabot>   add an instance declaration for (Monoid Expr)
07:35:32 <Associat0r> lambada exression
07:35:44 <dmwit> That is one lambadass expression!
07:36:05 <dmwit> :t return . (++b)
07:36:06 <lambdabot>     No instance for (Monoid Expr)
07:36:06 <lambdabot>       arising from a use of `++' at <interactive>:1:9-13
07:36:06 <lambdabot>     Possible fix: add an instance declaration for (Monoid Expr)
07:36:14 <cnwdup_> dmwit: Thanks. That's what I wanted to test. (-:
07:36:14 <byorgey> :t \b -> return . (++b)
07:36:14 <baaba> @pl \f x y -> f y x
07:36:14 <lambdabot> flip
07:36:15 <lambdabot> forall (m :: * -> *) m1. (Monoid m1, Monad m) => m1 -> m1 -> m m1
07:36:29 <baaba> @src flip
07:36:29 <lambdabot> flip f x y = f y x
07:36:36 <mauke> > \a -> return $ a++ ?b
07:36:36 <lambdabot>  Parse error at "?b" (column 20)
07:36:49 <dmwit> :t \a -> return $ a++?b
07:36:50 <lambdabot> Not in scope: `++?'
07:36:53 <dmwit> :t \a -> return $ a ++ ?b
07:36:55 <lambdabot> forall (m :: * -> *) m1. (Monoid m1, ?b::m1, Monad m) => m1 -> m m1
07:37:23 <dmwit> ?pl \a -> return $ a++b
07:37:23 <lambdabot> return . (++ b)
07:38:00 <Axman6> ?pl \a -> return $ b++a
07:38:01 <lambdabot> return . (b ++)
07:38:05 <Axman6> heh, ok then
07:38:21 <cnwdup_> What does pl stand for?
07:38:26 <mauke> pointless
07:38:26 <baaba> pointless
07:38:35 <byorgey> note, for anyone who may possibly be confused, (++) is only generalized to Monoids in lambdabot
07:38:43 <byorgey> normally it is just list append, of course.
07:38:55 <dmwit> cnwdup_: "Pointless" is a pun on "point-free", of course.
07:39:00 <byorgey> (lists being free monoids...)
07:39:13 <mauke> free the monoids!
07:39:22 <MyCatVerbs> byorgey: define "free"?
07:39:29 <Japsu> MyCatVerbs: free(3)
07:39:33 <Japsu> ^_______________^
07:39:38 <mauke> free(malloc);
07:39:49 * MyCatVerbs stabs Japsu with a sparrow.
07:40:05 <byorgey> MyCatVerbs: hm, actually, although I sort of understand intuitively what is meant by "free" in this context, I am not sure how to define it.
07:40:28 <Axman6> would there be and difference in performance between ?pl \a -> return $ a++b and return . (++ b) (assuming that both were equiv. and not so trivial)
07:40:39 <Axman6> like, would they produce the same output code?
07:41:17 <dmwit> ?quote premature
07:41:17 <lambdabot> vincenz says: strict evaluation is premature optimization
07:41:31 <dmwit> ?quote premature
07:41:31 <lambdabot> vincenz says: strict evaluation is premature optimization
07:41:43 <byorgey> MyCatVerbs: suppose you have monoid elements a and b.  if you compose them you get ab.  Now there may be some sort of relation that tells you how to reduce that, like ab = c.  If the monoid is 'free' of relations, all you can do is just concatenate elements like ab
07:42:05 <dmwit> Axman6: Well, ?pl makes no guarantees about emitting the same code.  And this would probably emit slightly different code.  But really...
07:42:21 <MyCatVerbs> byorgey: danke.
07:42:22 <Axman6> ok
07:42:32 <byorgey> it's sort of a 'formal' monoid built from elements without having to know anything about the elements themselves or how they relate.
07:42:35 <byorgey> if that makes sense.
07:42:59 <MyCatVerbs> byorgey: It's vaguely confusing because I keep seeing the word "free" used in different contexts. Abstract algebra, for example.
07:43:14 <byorgey> MyCatVerbs: yes, I suspect that is actually the same sense of the word 'free'.
07:43:19 <MyCatVerbs> byorgey: and then there's places where people use "free" to mean "for free". Argh.
07:43:32 <byorgey> there is a much deeper connection which is what I don't know how to define.
07:43:44 <byorgey> for example you can define the 'free category' on a graph
07:44:04 <byorgey> and you can have 'free algebras' and so on
07:44:25 <MyCatVerbs> byorgey: and then occasionally evil people use the term "free" to denote "I get this for free by taking advantage of the definition".
07:44:31 <byorgey> hehe
07:44:40 <byorgey> yes, 'free' is a rather overused word, it's true.
07:44:50 <byorgey> I freely admit.
07:44:51 * MyCatVerbs shakes his fist.
07:44:56 <MyCatVerbs> ...
07:45:03 * MyCatVerbs throws byorgey at byorgey.
07:45:55 <mauke> preflex: quote quicksilver
07:45:56 <preflex>  <quicksilver> learning from other people's mistakes is so web 1.0
07:46:06 <mauke> no, not that one
07:46:06 * byorgey crashes into himself, knocking himself over, causing him to crash into himself and knock himself over, causing him to...
07:46:07 <mauke> preflex: quote quicksilver
07:46:07 <preflex>  <quicksilver> remember, premature evil is the root of all optimisation
07:46:33 <byorgey> _|_
07:46:45 <Twey> Hahaha
07:47:34 <mauke> so if bottom is a value of every type, is top a value of no type?
07:48:26 <Twey> Heh
07:48:39 <Twey> Oooh metaphysical
07:49:39 <byorgey> if top is a value of no type, is it a value?
07:50:12 <dmwit> Is Void a type?
07:50:15 <lilachaze> mauke: arguably, bottom is a type with no strict values, top is a type containing all values
07:50:47 <lilachaze> the top type would be (exists a. a)
07:50:49 <mauke> then why does âŠ¥ always refer to values?
07:51:45 <lilachaze> punning, i guess. bottom values are presumably the elements of the bottom type
07:52:23 <lilachaze> top and bottom are weird terms for values, given that it's the types which form a lattice.
07:53:27 <byorgey> eh? no, it's the values in the semantic domain
08:01:36 <HairyDude> ?hoogle Set (Set a) -> Set a
08:01:46 <lambdabot> No matches, try a more general search
08:02:14 <HairyDude> I guess unions . toList works, but that seems rather horrid
08:02:31 <Toxaris> lilachaze: values are ordered regarding their "definedness", and the "bottom value" is less defined then every other value. there is no "top value" which is more defined then all other values.
08:02:52 <Toxaris> Is there no fold on Set?
08:03:19 <HairyDude> ah yes, it does have a Foldable instance
08:03:29 <Toxaris> Maybe Data.Foldable.fold does the right thing out of the box?
08:03:57 <HairyDude> ooh, I didn't know that even existed :)
08:03:58 <Toxaris> if Set has a Monoid instance with mappend = union
08:04:28 <mauke> > S.fromList "aabbc"
08:04:30 <lambdabot>  fromList "abc"
08:04:33 <HairyDude> @src mappend :: Ord a => Set a -> Set a -> Set a
08:04:33 <lambdabot> Source not found. That's something I cannot allow to happen.
08:04:39 <HairyDude> hm
08:04:52 <byorgey> zit does.
08:04:56 <byorgey> *it
08:05:02 <byorgey> where did that z come from?
08:05:31 <mauke> zomg
08:05:41 <HairyDude> > Set.fromList [1,2,3] `mappend` Set.fromList [1,3,4]
08:05:42 <lambdabot>   Not in scope: `Set.fromList'
08:05:50 <HairyDude> > Data.Set.fromList [1,2,3] `mappend` Data.Set.fromList [1,3,4]
08:05:51 <lambdabot>   Not in scope: `Data.Set.fromList'
08:05:55 <HairyDude> huh
08:06:01 <byorgey> > S.fromList [1,2,3] `mappend` S.fromList [1,3,4]
08:06:05 <lambdabot>  fromList [1,2,3,4]
08:06:09 <Toxaris> > Data.Foldable.fold (S.fromList (map S.fromList ["abc", "def", "ghi"]))
08:06:10 <lambdabot>  fromList "abcdefghi"
08:06:22 <Toxaris> so for sets, join = fold
08:06:26 <lilachaze> Toxaris: so you'd say that [1,2,undefined,undefined] < [1,2,undefined,4] ? is that a useful ordering?
08:06:37 <HairyDude> Toxaris: except that sets don't have a Monad instance :)
08:06:48 <byorgey> because they don't have a Functor instance.
08:06:59 <byorgey> because they require Ord for elements.
08:06:59 <Toxaris> I mean the join you want to have
08:07:00 <HairyDude> because they need an Ord constraint
08:07:08 * Toxaris ignores technical constraints
08:07:10 <byorgey> Toxaris: indeed.
08:08:03 <Toxaris> lilachaze: yes it is. let's say you define a recursive equation and both of these values are fixpoints of your equation.
08:08:19 <Toxaris> lilachaze: then the ordering helps you decide which element you want
08:08:36 <Toxaris> lilachaze: in a strict language, you get the less defined one, in a non-strict language, the more defined
08:09:04 <lilachaze> Toxaris: hmm. but it's a partial order, so the more defined one isn't unique.
08:09:43 <Toxaris> lilachaze: for fixpoint equations you can express in Haskell, it is
08:09:50 <Toxaris> lilachaze: afaik
08:10:06 <lilachaze> neat property, seems intuitively likely to be true :)
08:10:20 <Toxaris> lilachaze: that is, if [1, undefined] and [undefined, 2] are fixpoints, then [1, 2] is a fixpoint too
08:10:27 <Toxaris> lilachaze: and that's the one you want
08:10:39 <HairyDude> 1:2:_|_:_|_:[] < 1:2:_|_:4:[] makes sense
08:10:49 <HairyDude> because _|_ < 4
08:11:04 <lilachaze> Toxaris: but all values are fixed points of id, so there's no unique most defined one there
08:11:29 <Toxaris> lilachaze: and [undefined, undefined] and undefined are fixpoints too, and for some reason I don't understand, the non-Haskell programmers want undefined, even if undefined is not useful for anything :)
08:11:52 <HairyDude> undefined = fix id :)
08:11:55 <HairyDude> (well, almost)
08:11:57 <lilachaze> Toxaris: well, what else can "fix id" sensibly return?
08:12:09 <HairyDude> > fix id
08:12:12 <Toxaris> lilachaze: (fix id) is not the recursive equation defining id
08:12:24 <lambdabot>  thread killed
08:13:02 <Toxaris> lilachaze: actually, id is not recursive, so not exactly a good example
08:13:07 <byorgey> Toxaris: it doesn't really have anything to do with strict vs. non-strict, does it.  'fix' always gives you the least-defined fixed point.
08:13:14 <byorgey> er s/./?/
08:13:31 <yakov> hm.. anybody with ghc683/sles10 configuration? I can't link anything.. ghc can't find gmp library though it does exist in /usr/lib64 and I even tried to pass that path directly with -L/usr/lib64 :/
08:13:49 <Toxaris> byorgey: are we talking about fix?
08:14:12 <Toxaris> byorgey: I think we are talking about the fixpoint in denotational semantics
08:14:56 <byorgey> Toxaris: well, consider e.g.  x = (x - 1)*2
08:15:07 <Toxaris> byorgey: but now that you say that, I may have mixed up least-defined and most-defined
08:15:08 <byorgey> that is a recursive equation which has fixpoints _|_ and 2
08:15:09 <RayNbow> gah... reddit's developers probably did something wrong again... trying to up/downmod a comment results in 100% CPU usage... :X
08:15:27 <byorgey> but you get _|_ no matter whether your language is strict or non-strict.
08:16:30 <lilachaze> Toxaris: ok, so i still don't see why this is a useful ordering.
08:16:49 <Toxaris> lilachaze: because it is used in denotational semantics to define what a program means
08:16:52 <Axman6> @type _|_
08:16:53 <lambdabot> parse error on input `|'
08:16:56 <byorgey> lilachaze: the haskell wikibook has a good discussion of denotational semantics, IIRC
08:17:04 <RayNbow> @type undefined
08:17:05 <lambdabot> forall a. a
08:17:21 <Axman6> what is _|_?
08:17:37 <Toxaris> byorgey: I'm confused
08:18:01 <byorgey> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
08:18:15 <byorgey> Toxaris: maybe I am confused as well, I'm certainly no expert
08:18:44 <byorgey> Axman6: _|_, or "bottom", is the "least defined value", i.e. the undefined value which represents errors or infinite recursion
08:18:57 <Toxaris> I guess this is related to mixing up the "real word" semantics of - and * and their Haskell semantics
08:19:18 * Axman6 makes a datatype that's _|_-1
08:20:57 <Toxaris> byorgey: otoh it sounds sensible that you get the least defined fixpoint in any case, but in Haskell, it is more defined then in a strict language
08:21:51 <byorgey> Toxaris: hm, yes, that sounds reasonable.  because in Haskell, the fixpoint may be more defined, due to non-strictness.
08:22:10 <byorgey> i.e. the same recursive equation might have different fixpoints in strict and non-strict languages.
08:22:36 <byorgey> e.g. consider  x = 1 : x .
08:22:58 <byorgey> er, hm...
08:23:14 <Axman6> > x = 1:x
08:23:15 <lambdabot>  Parse error at "=" (column 3)
08:23:21 <Axman6> > let x = 1:x
08:23:21 <lambdabot>  Parse error at end of input
08:23:21 <byorgey> ah, right.  in a strict language, that has a fixpoint of _|_ .  since 1 : _|_ == _|_ .
08:23:27 <Axman6> > let x = 1:x in x
08:23:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:23:31 <Axman6> handeh
08:23:38 <uccus> more like it
08:23:47 <byorgey> in a non-strict lanugage, however, _|_ is *not* a fixpoint, since 1 : _|_ is not _|_
08:23:47 <uccus> > let x = 1 : x in take 10 x
08:23:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
08:24:00 <Toxaris> byorgey: exactly, that's it
08:24:04 <byorgey> in a non-strict language, the smallest fixpoint is [1,1..]
08:24:11 <Axman6> @type repeat
08:24:11 <lambdabot> forall a. a -> [a]
08:24:25 <Axman6> @src repeat -- is what i meant...
08:24:25 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:24:42 <byorgey> but note that you still do get the *least* fixed point.
08:25:42 <Toxaris> lilachaze: as byorgey said, you always get the least fixed point. and I guess you are correct that sometimes the most defined fixed point is not unique, but it doesn't matter, since the least defined one is
08:27:03 <Toxaris> e.g. consider x = x * x, which has fixed points _|_, -1 and 1
08:27:21 <byorgey> right, the most defined fixed point is not unique since the partial order of definedness has a bottom element but no top element
08:27:25 <byorgey> i.e. it is not a lattice.
08:27:48 <Toxaris> so are there languages with a most-defined fixed point semantics? prolog?
08:28:02 <byorgey> so any two elements have a meet (a most-defined element which is less defined than both) but not necessarily a join (a least-defined element which is more defined than both).
08:28:08 <Toxaris> or datalog?
08:30:44 <byorgey> wow, the haskell wiki page on denotational semantics is even better than I remembered
08:30:52 <byorgey> I should read through it carefully =)
08:31:04 <byorgey> I mean the haskell wikibook page
08:31:09 <HairyDude> ?hoogle (a -> Bool) -> Set a -> Bool
08:31:09 <lambdabot> No matches, try a more general search
08:31:22 <HairyDude> that would be 'any' and 'all'
08:31:36 <HairyDude> also missing
08:32:05 <HairyDude> I can define it using foldr again, but I'd rather just pull it from the library.
08:32:25 <byorgey> hm, yeah, that seems like a rather glaring omission
08:32:51 * HairyDude hates having to reinvent the wheel.
08:33:10 <dolio> @type Data.Foldable.all
08:33:11 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => (a -> Bool) -> t a -> Bool
08:33:51 <byorgey> aha, I didn't know that was in Foldable!
08:34:09 * osfameron releases Sub::Curried to Perl's CPAN
08:34:37 <HairyDude> see, the problem there is that Foldable isn't standard, so I've never bothered to learn what was in it :)
08:34:49 <byorgey> what do you mean, Foldable isn't standard?
08:34:54 <Toxaris> HairyDude: it's standard enough
08:35:57 <HairyDude> not in the report, at least I don't remember it being so
08:36:12 <dolio> It's at least as standard as Data.Set.
08:36:17 <HairyDude> yeah
08:37:16 <childe> Hi. How do I declare the type for non-zero integers?
08:37:38 <HairyDude> suppose there's a shortcoming of hoogle there that it didn't notice that a function of type (a -> Bool) -> Set a -> Bool exists in the form of a Foldable instance.
08:38:15 <byorgey> HairyDude: maybe Hoogle 4 will find it...?
08:38:22 <HairyDude> byorgey: hope so :)
08:38:54 <Toxaris> :t (getAll .) . Data.Foldable.foldMap . (Data.Monoid.All .)
08:38:55 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => (a -> Bool) -> t a -> Bool
08:39:05 <Toxaris> it's so easy, hoogle should really find that
08:39:06 <byorgey> childe: depends why you want to do that.  doing so directly is rather difficult in Haskell and not recommended.
08:39:47 <HairyDude> it's the kind of thing you usually need dependent types for
08:40:03 <Toxaris> data Positive = One | Succ Positive
08:40:13 <byorgey> childe: if you want, you could say  'newtype NonZero = NonZero Integer', then make a smart constructor function that takes an Integer and gives an error if you pass it zero.
08:40:18 <HairyDude> Toxaris: yum, inefficiency
08:40:34 <Toxaris> HairyDude: :)
08:40:54 <Cale> heh, or just interpret NonZero x where x < 1 as meaning x - 1
08:40:56 <byorgey> childe: but of course if you derive instances of Num and so forth for NonZero, you still can't guarantee that you'll never get a zero value (through e.g. subtraction)
08:41:10 <byorgey> Cale: that would be... annoying ;)
08:41:18 <Toxaris> Cale: sounds hard to define the Num instance
08:41:35 <Cale> Toxaris: of course subtraction won't be closed :)
08:41:55 <HairyDude> Toxaris: Agda has a rather nice way of defining natural numbers. you can define a data type like that and use a compiler directive to say "this is a type of natural numbers, here are its constructors" and it uses a more efficient representation.
08:41:57 <childe> byorgey: Thanks. But if I use the constructor to do the check, that would be at runtime, not compile time.
08:42:19 <HairyDude> at least that's what I think the BUILTIN pragma does.
08:42:21 <childe> byorgey: That's not so "static" for a static language.
08:42:44 <dolio> HairyDude: Yeah.
08:42:56 <Toxaris> childe: well, Haskell is not a theorem prover
08:43:17 <Jedai> childe: No language is able to do such a thing at compile time except dependently typed language and that comes with a lot of overhead
08:43:38 <childe> Is that possible to get something like that using TemplateHaskell?
08:44:07 <HairyDude> try programming in a dependently typed language sometime. It's actually quite hard to get things to type check
08:44:11 <Jedai> childe: Like, you need to bring a formal proof that the functions conserve the positive nature of the input for example
08:44:47 <Jedai> childe: If you just want to check the constants you have at compile time sure, if you want something more then no, of course
08:44:48 <Toxaris> childe: I don't think so, since template Haskell is expanded before typechecking afaik, and you want to typecheck with the ADT, but use Integer for code generation
08:44:54 <uccus> why would anyone define an Num instance for these?
08:45:09 <dolio> It isn't very hard to make a type of integers such that you never forget to check for zero on dangerous operations.
08:45:21 <Jedai> uccus: Why not ?
08:45:39 <uccus> because for Num you need to define subtraction, right?
08:45:56 <uccus> that's what the deal is for Num
08:46:27 <dolio> data NonZero ; data Unknown ; newtype Tagged t = Tagged Integer
08:46:28 <Jedai> uccus: Yes, but you can define your subtraction so that 3 - 10 == 1 for example
08:46:39 <Jedai> uccus: or throw an error
08:46:52 <dolio> Then you write 'testZero :: Tagged Unknown -> Maybe (Tagged NonZero)'.
08:47:12 <uccus> hmm throwing an error seems more reasonable but I didn't understand why 3 - 10 == 1 ? :o
08:47:47 <uccus> Oh you mean, like for natural numbers the "natural" subtraction gives zero?
08:47:51 <dolio> And subtraction has type, for instance 'Tagged t -> Tagged u -> Tagged Unknown'.
08:48:02 <Jedai> uccus: Why not ? (Ok that breaks some laws, but I once read a pretty good argument to have a Natural type where 3 - 10 == 0)
08:48:18 <uccus> Jedai: :D
08:48:25 <Jedai> uccus: Right ;-)
08:48:33 <dolio> While division has a type more like 'Tagged t -> Tagged NonZero -> Tagged t'.
08:49:00 <Toxaris> > 3 `div` 10
08:49:01 <lambdabot>  0
08:49:04 <dolio> Although, I suppose you can get zero out of integer division without putting it in.
08:49:26 <dolio> Yeah, so make that Unknown, too.
08:50:09 <dolio> That's not many milli-Olegs.
08:50:11 <Jedai> childe: Anyway why do you want those strictly positive integer in your program ?
08:50:14 <childe> Hmmm...seems we need more mathematical structure types like groups, fields, etc.
08:50:45 <Jedai> childe: There are some MathPrelude around if you want
08:50:50 <childe> Jedai: It's just an example...I wonder how to make types from certain sets in Haskell.
08:50:51 <uccus> childe: basically you need semigroups
08:51:14 <uccus> [and monoid for multiplication]
08:51:19 <MoiraA> hello
08:51:41 <Toxaris> childe: well, Integers without zero is a "bad set" mathemically speaking, too, isn't it? I mean, the zero is missing
08:52:03 <Toxaris> childe: there is not much structure, so you shouldn't hope to be able to instantiate Haskell classes like Num
08:52:32 <Jedai> childe: You want to make types from subsets of the value in other types ? You basically have only two solutions (smart constructor and abstract type or type class hackery and pessimist results))
08:52:36 <childe> Yes, but how about the set of even numbers.
08:53:00 <uccus> same as what Jedai said
08:53:11 <Jedai> Toxaris: Well you can instantiate those structure, but they won't have all the properties you could expect)
08:53:28 <uccus> which basically means you shouldn't
08:53:31 <Toxaris> so they are not really instantiated
08:53:41 <Toxaris> it's just reusing the names
08:54:02 <Toxaris> but typeclasses are not for name reuse (we have a module system), but for *sane* ad-hoc polymorphism
08:54:20 <uccus> I was astonished when the comments revealed the luqui's Omega is not a monad (makes me sad)
08:55:38 <Toxaris> childe: the set of even numbers is easy imho, just use newtype Even = Even Integer, and represent (2 * x) by x
08:55:51 <Jedai> childe: Basically the problem comes when you're trying to use the same operation you had on the superset on your newly named subset, since most of the time they don't preserve the subset and thus you can't use them as total functions.
08:56:58 <Jedai> Toxaris: It's not that evident, for example a newtype isn't sufficient since (*) don't work properly
08:56:59 <Toxaris> childe: unfortunately "fromInteger" will dynamically fail if applied to a odd number in a Even context, but the other operations should be fine imho
08:57:37 <Toxaris> Jedai: ? you mean s/newtype/newtype deriving/ ?
08:58:05 <Jedai> Toxaris: Yeah, right (you need to make your own instance of Num)
08:58:31 <Toxaris> Jedai: what's wrong with instance Num Even where  ...; Even x * Even y = Even (x * y * 2); ...
08:58:42 <Jedai> Ok, I see you already had this, this representation should work well (except (/))
08:58:56 <Toxaris> "had this"?
08:59:01 <uccus> in mind
08:59:04 <Toxaris> oh ok
08:59:13 <Toxaris> yeah I was aware of the problem...
08:59:33 <Jedai> Toxaris: Yep sorry I'm not really a native speaker and I was typing a bit too fast :-(
08:59:57 <Toxaris> Jedai: hehe no problem I was just confused what you mean
09:00:49 <Toxaris> however, it's time to go home, since I'm no longer working anyway
09:01:02 <childe> Torxaris: Thank you (and Jedai) so much. I'll think it over.
09:01:39 <dolio> uccus: It isn't?
09:01:51 <uccus> sorry?
09:01:56 <dolio> Omega.
09:02:14 <uccus> noooo! it doesn't confirm to the monad laws
09:02:19 <uccus> *conform
09:02:36 <dolio> Which one(s) does it violate? I haven't looked at it that closely.
09:03:21 <ski> the associative law, iirc
09:03:40 <rwbarton> what's Omega?
09:03:59 <dolio> Does it have to do with ordering of results?
09:04:15 <ski> rwbarton : a breadth-first angelic non-determinism monad
09:04:17 <uccus> yes
09:04:47 <ski> rwbarton : sorry, s/monad/almost monad/
09:05:12 <uccus> apfelmus said (in blog comments) join . join == join . fmap join with join = diagonal does not hold with list equality (but holds with set equality)
09:05:41 <dolio> Yeah. That's sort of what I would have guessed.
09:06:10 <uccus> which makes it a very good example that sometimes the "almost" structures are OK
09:06:36 <dolio> Yeah. Realistically one probably doesn't care about the order of the results.
09:06:46 <dolio> So it's a monad modulo stuff you don't care about.
09:07:07 <uccus> specially with infinite lists with Luke's promise that it will eventually show up (but he makes no promise when)
09:08:21 <ski> runOmega :: Omega a -> IO [a]  -- would be ok, imo
09:09:02 <ski> (though people might want to substitute `IO' with `NonDet' or something)
09:09:03 <uccus> would runOmega :: Omega a -> Set a do?
09:09:05 <dolio> Seems like we've had this disussion before.
09:09:15 <dolio> Only with Set instead of Omega.
09:09:18 <ski> uccus : yes
09:09:27 <ski> dolio : *nod*
09:09:42 <childe> Hi, another silly question...is there a way to "lift" normal functions so that they can work on quoted data (using Template Haskell)?
09:10:08 <childe> For example, to "lift" the head function so it can work on Q ListE?
09:10:34 <dolio> In that 'toList :: Set a -> [a]' isn't a natural transformation or something like that.
09:11:23 <dolio> Despite being polymorphic, and people saying in general that 'polymorphic functions are natural transformations.'
09:11:56 <ski> well, `Set a' is not an algebraic type
09:12:02 * uccus keeps quite, risky waters
09:12:10 <rwbarton> That has something to do with the Ord a instance you left out, as does the standard discussion in this area
09:12:11 <dolio> Yeah.
09:12:36 <dolio> Right. It's obvious that 'sort :: Ord a => [a] -> [a]' doesn't qualify.
09:12:43 <dolio> I suppose.
09:16:46 <rwbarton> It's a natural transformation on the category of Ord-types and Ord-preserving maps though; is there a general notion of what it means for a map to preserve a type class?
09:42:14 <[1]sh> Hi guys.
09:43:24 <[1]sh> How can I feed an interactive Haskell compiler / interpreter with a sequence of statements?
09:44:02 <dogbite> have you tried feeding ghci by redirecting stdin?
09:44:09 <dogbite> i've never tried that ... just wondering
09:44:19 <[1]sh> dogbite, not yet, I'll try it now
09:44:26 <Philippa> [1]sh: do {...;...}
09:44:40 <Philippa> though the bindings won't scope outside the do block
09:45:04 <dogbite> is the question, how can i take a sequence of statements that i have in a text file, and play them through ghci?
09:45:22 <Twey> dogbite: Copy and paste?
09:45:37 <Philippa> [1]sh: what's your purpose, anyway? Scripting tests?
09:45:39 <dogbite> it's not my question.. just trying to clarify
09:45:49 <Twey> Oh, sorry
09:46:02 <dogbite> Twey: np
09:46:12 <Philippa> I mean, generally I put that sequence of statements in a do block in a function in a module, load the module and run them that way...
09:46:27 <Toxaris> C:\Users\Tillmann Rendel>echo putStrLn "hello [1]sh" | ghci -v0 -w
09:46:27 <Toxaris> hello [1]sh
09:46:51 <[1]sh> Thanks for all the hints!
09:47:13 <[1]sh> dogbite, it works, although only the evaluation results are displayed but not the input statements
09:47:18 <zachk> how do i kill ghci evluation?
09:47:27 <Toxaris> there is also http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint for, well, heavy applications
09:47:28 <lambdabot> Title: HackageDB: hint-0.2.2
09:47:57 <Toxaris> (not that I have used in any way, just realized it exists myself)
09:47:59 <dogbite> [1]sh: hmm.. i'm stumped then.
09:48:29 <Toxaris> [1]sh: stdin is only echoed if coming from a terminal
09:48:46 <Toxaris> [1]sh: but you can make ghci output whatever you want with putStrLn
09:49:54 <[1]sh> Philippa, yes, I'd like to script tests
09:50:09 <MyCatVerbs> dogbite: if you want to evaluate a piece of Haskell straight off, more often you want to use ghc -e instead. e.g. ghc -e "2^16" prints "65536".
09:50:10 <[1]sh> Philippa, just reading "Introduction to Haskell programming" by Bird
09:50:23 <MyCatVerbs> Er, that was meant for [1]sh, not dogbite.
09:50:29 <dogbite> MyCatVerbs: cool
09:50:59 <MyCatVerbs> [1]sh: if you're scripting tests, a trick I've seen for marking students' homework assignments is to use runhaskell.
09:53:31 <MyCatVerbs> [1]sh: they got all the students to write their code as a library, then the testing process would call runhaskell on a file whose contents look like: module Main where \n import Assignment1 \n main = putStrLn (show (homeworkTransform1 "sample data")), etc.
09:56:42 <Toxaris> there is also :cmd
09:58:35 <Toxaris> C:\Users\Tillmann Rendel>echo putStrLn "hello #haskell" > commands
09:58:35 <Toxaris> C:\Users\Tillmann Rendel>echo :cmd readFile "commands" | ghci -v0 -w
09:58:35 <Toxaris> hello #haskell
09:59:32 <xerox> ghc -e 'putStrLn "hello #haskell"'
10:00:13 <tusho> :t foldr (flip (.)) id
10:00:14 <lambdabot> forall a. [a -> a] -> a -> a
10:00:24 <tusho> > foldr (flip (.)) id [succ,succ] 2
10:00:26 <lambdabot>  4
10:00:29 <tusho> ah
10:01:05 <Trollinator> given some x and y, what's the easiest way to make a list containing x y times?
10:01:12 <tusho> :t last . iterate
10:01:13 <lambdabot>     Couldn't match expected type `[a]'
10:01:13 <lambdabot>            against inferred type `a1 -> [a1]'
10:01:13 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
10:01:30 <tusho> :t \x y -> last $ iterate x y
10:01:31 <lambdabot> forall a. (a -> a) -> a -> a
10:01:47 <[1]sh> Toxaris, your last suggestion gives me: <interactive>:1:32: Not in scope: `commands'
10:02:16 <Toxaris> [1]sh: maybe your shell eats the quotes around commands
10:02:25 <Toxaris> [1]sh: ghci should interpret is as a literal string
10:02:28 <Saizan_> > replicate 4 2
10:02:39 <lambdabot>  [2,2,2,2]
10:02:58 <MyCatVerbs> Toxaris: echoing things through ghci is still a frightful hack.
10:03:35 <MyCatVerbs> ghc -e and putting things in files and then executing them with runhaskell are both _much_ nicer.
10:03:53 <Trollinator> Saizan_: thanks.
10:04:02 <Toxaris> MyCatVerbs: I agree :)
10:04:07 <chrisdon1> gweeerrrrrrn
10:04:12 <tusho> Trollinator: replicate
10:04:12 <chrisdon1> @seen gwern
10:04:13 <lambdabot> gwern is in #xmonad, #darcs and #haskell. I last heard gwern speak 16h 45m 36s ago.
10:04:15 <tusho> > replicate "test" 3
10:04:16 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
10:04:18 <tusho> > replicate 3 "test"
10:04:19 <lambdabot>  ["test","test","test"]
10:04:32 <Trollinator> tusho: Saizan_ told me already.
10:04:36 <Trollinator> thanks nonetheless
10:04:36 <ptolomy2> Golly. I've avoided list comprehensions in favor of filter/map/etc, but I recently have found them awesome for things like [(a,b) | [a,b] <- foolist].. in that failed pattern matches get filtered out.
10:04:40 <Toxaris> MyCatVerbs: but echoing things through ghci allows :t etc.
10:05:07 <chrisdon1> ptolomy2: ^___________^
10:05:19 <tusho> chrisdon1: your face...
10:05:23 <tusho> it is unusually large.
10:05:33 <chrisdon1> wait, what happened to my nick?
10:05:40 <Trollinator> ptolomy2: um, that's easy to do without list comprehension
10:05:42 <gwern> chrisdone: yes?
10:05:49 <dogbite> chrisdone: that happened to me once too
10:05:59 <chrisdone> gwern: are you going to make an IRC bot out of mueval? :<
10:06:07 <MyCatVerbs> Toxaris: still fugly.
10:06:20 <gwern> chrisdone: the idea is that one day, it'll happen
10:06:36 <Trollinator> ptolomy2: for example, filter ((==2) . length)
10:06:41 <Nafai> What's mueval?
10:06:43 <Toxaris> MyCatVerbs: Well, I agreed.
10:06:44 <chrisdone> gwern: awesome
10:06:59 <Toxaris> MyCatVerbs: now looking at the GHC API, I have the feeling the sensible alternative is not yet usable
10:07:00 <gwern> chrisdone: the short-term plan is to fix lambdabot by ripping out hs-plugins and replacing it with shell calls to mueval. unfortunately, I still need to figure out how to do the quickcheck and smallcheck stuff
10:07:06 <gwern> chrisdone: I hope to do that this weekend
10:07:37 * gwern is tired of how long this mueval stuff is taking. I expected it to take 2 or 3 weeks, but this has really dragged on
10:07:41 <chrisdone> gwern: sounds great :)
10:07:50 <MyCatVerbs> Toxaris: better option is to write, main = putStrLn . testAssignment $ assignmentFunction, where testAssignment :: (InputYouAskedFor -> OutPutYouWant) -> String.
10:07:55 <chrisdone> nafai: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval
10:07:56 <lambdabot> Title: HackageDB: mueval-0.4.5
10:08:10 * Nafai looks
10:08:18 <MyCatVerbs> Toxaris: then testAssignment looks something like: testAssignment f = f sampledata
10:08:35 <Toxaris> MyCatVerbs: How is that related to "but echoing things through ghci allows :t etc."?
10:08:35 <chrisdone> gwern: why are shell calls necessary, btw? why not just use mueval directly?
10:08:35 <Nafai> Sounds awesome!
10:08:47 <chrisdone> gwern: setting process permissions?
10:09:03 <MyCatVerbs> Toxaris: for assignments, you're probably only interested in the type in as much as making sure the assignment was done correctly.
10:09:18 <gwern> chrisdone: directly?
10:09:28 <MyCatVerbs> Toxaris: this way, firstly you're still enforcing that the student has written a function with a type that *unifies* with whatever type you asked them for, without relying on brittle string comparison.
10:09:43 <chrisdone> gwern: well, if mueval was a library. I kinda thought it was but I realise now it's a program only
10:09:44 <Toxaris> MyCatVerbs: Well, I already agreed that for evaluation, piping things into ghci is not good
10:09:45 <gwern> chrisdone: you mean like as a library? 'import Mueval (evaluate)' or something?
10:09:55 <MyCatVerbs> Toxaris: no point penalising kids for writing myReverse :: [a] -> [a] instead of myReverse :: String -> String, etc.
10:10:02 <chrisdone> gwern: yeah >_>
10:10:15 <Toxaris> MyCatVerbs: still, there may be other uses of piping things into ghci
10:10:42 <ptolomy2> Trollinator: Oh, or sure. It can easily be done elsewise, but for slightly more complicated things, I find it clearer to just have the pattern match than to construct functions to do it.
10:11:05 <PeakerWork> isn't   length >>> (==2)   much nicer than (==2) . length ?
10:11:17 <gwern> chrisdone: I mean, you *could* do that. I always split my stuff into a library/executable. but I figured that an executable would be better as you get process separation. more importantly, I suspect all the calls to 'error' would make it dangerous to incorporate mueval as a library...
10:11:29 <PeakerWork> I find the reversed form of (.) confusing
10:11:31 <chrisdone> gwern: ah good point
10:12:00 <chrisdone> peaker: seems a bit odd that you're not used to it by now?
10:12:12 <PeakerWork> chrisdone: I haven't written that much Haskell code :)
10:12:18 * dolio is pretty used to (.)
10:12:31 <gwern> I am not sure I could do without error; the point of error is that it unconditionally kills the entire program, so the potentially corrupted threads have to no chance to survive (make your time)
10:12:47 <chrisdone> gwern: you know what you doing !
10:12:53 <PeakerWork> I think its important to fix confusing notations -- they add up to quite a barrier of entry/obstacle
10:12:53 <lilachaze> PeakerWork: one thing i've learnt is that haskell requires you to be able to read code in both directions, often in the same expression
10:12:55 <dolio> The only time it bothers me is in something like 'm >>= f . g >>= h'.
10:13:12 <dolio> But, of course, you can write "h =<< f . g =<< m".
10:13:17 <gwern> launch all cabals! for great -install!
10:13:22 <chrisdone> dolio: yeah, I don't know the precedence of that
10:13:33 <dolio> Which also works well with 'a <- h =<< f . g =<< m'.
10:13:51 <MyCatVerbs> Toxaris: s/uses/(ab)\1/, if you'll forgive the PCRE-ism.
10:14:32 <Apocalisp> (.) doesn't seem backwards when you think of it as fmap
10:14:55 <dolio> chrisdone: Well, then, even better is: "f . f' &&& g . g' <<< h *** h'". :)
10:15:08 <lilachaze> dolio: there's still m >>= f (g h).
10:15:20 <dolio> Actually, that's probably backwrds.
10:15:34 <dolio> You'd want to feed the &&& into the ***.
10:15:39 <dolio> Most likely.
10:15:53 <chrisdone> gwern: hey... does mueval support UTF-8?
10:15:56 <MyCatVerbs> dolio: parentheses, please?
10:15:56 <PeakerWork> Apocalisp: I think that the (->) and (,) instances of Functor, Monad, etc are very cute -- and let you write really powerful things really easily. But I think it makes reading harder. I think it would be nicer if all these instances were on newtype's around (->) and (,)
10:16:06 <lilachaze> or in fact just a (b c) . d (e f)
10:16:08 <PeakerWork> Apocalisp: so I don't read (.) as fmap...
10:16:29 <Toxaris> PeakerWork: I find (2 == length x) === (2 ==) . length $ x not that confusing :)
10:16:31 <dolio> MyCatVerbs: It's equivalent to "((f . f') &&& (g . g')) <<< (h *** h')".
10:16:46 <Toxaris> PeakerWork: just ignore the crappy symbols and read it like an expression :)
10:16:50 <dolio> (.) binds tighter than (&&&) and (***), (<<<) is looser.
10:17:22 <PeakerWork> Toxaris: maybe function application should be x length then too :-)
10:17:48 <rwbarton> PeakerWork: you're looking for #forth?
10:17:59 <PeakerWork> Toxaris: it seems that convention for points-free in most of the world is left-to-right, and for points-func-apply is right-to-left, so these worlds collide.  I think we should choose one and stick with it for both points-free and points-ful notation
10:18:10 <MyCatVerbs> dolio: thank you.
10:18:19 * ptolomy2 wonders idlely how (`elem` "ab") compares performance-wise to (\x -> x == 'a' || x == 'b'), and how this relationship changes as the number of elements increases..
10:18:25 <PeakerWork> rwbarton: its just syntax :)
10:18:32 <gwern> chrisdone: no, inasmuch as I use the standard IO functions
10:18:49 <chrisdone> gwern: ah, I see. I might convert it to UTF-8..
10:18:55 <gwern> chrisdone: you often evaluate haskell source code with utf-8-only chars? I don't think I've ever gone beyond ASCII
10:18:57 <rwbarton> PeakerWork: Famous last words. :)
10:19:00 <PeakerWork> Toxaris: Haskell tries to make points-free right-to-left too, like points-ful. But it doesn't go all the way and still offers >>> and >>= and so forth
10:19:47 <mfp> <dolio> mfp:  What were you using for test data for your CSV thing? -> I generated it with this script  http://hpaste.org/9136
10:19:58 <Toxaris> PeakerWork: what you say makes sense. maybe we should write x f to apply f to x
10:20:03 <chrisdone> gwern: well, sometimes I use utf8 operators. and sometimes strings contain non-ASCII characters
10:20:25 <Toxaris> PeakerWork: I mean, ... really write ...
10:20:44 <chrisdone> Prelude> let x â†’ y = y x in 1 â†’ (+1) â†’ (*5)
10:20:45 <chrisdone> 10
10:20:50 <PeakerWork> Toxaris: I'm not following what you mean by "really write"?
10:20:59 <Apocalisp> PeakerWork: It helps more if you think of (f . g) as ((f .) g)
10:21:08 <Toxaris> PeakerWork: as you have jokingly proposed
10:21:37 <PeakerWork> Toxaris: oh, its not really a joke - just had to soften the blow with a smiley. :)
10:21:40 <gwern> chrisdone: well, doing input in utf-8 wouldn't be hard, if you want output, hint may need to be patched
10:22:01 <chrisdone> gwern: oh, really? drag..
10:22:12 <Saizan_> gwern: you use Language.Haskell.* to validate code in mueval?
10:22:13 <PeakerWork> Toxaris: From unix et/al I am really used to points-free left-to-right, which is why I am probably confused about (.)
10:22:29 <chrisdone> oh, brb. have to see a man about a dog
10:22:33 <Toxaris> hehe let (|) = flip (.)
10:22:41 <sal23> hmm...I wrote a fibonnaci function that works when used by itself, but gives negative values at some places when used in another function which is constructing fib list : http://hpaste.org/9137
10:23:05 <gwern> chrisdone: actually, no, I don't think. I messed up and though I was using a helper function defined in hint when I'm not
10:23:25 <sal23> wondering if it is GHC bug on windows....I doubt it though because as a rule of thumb, the bug is more likely in my code than in the compiler
10:23:27 <gwern> Saizan_: hint adds modules into Language.Haskell, if that's what you mean
10:23:54 <Apocalisp> PeakerWork: I think of (f .) as modifying the codomain of its argument.
10:23:54 <rwbarton> sal23: Int only stores 32 bits, and is signed, so eventually it will overflow to a negative number
10:23:58 <Saizan_> sal23: don't use Int if you don't want overflows
10:24:02 <Toxaris> sal23: try Integer?
10:24:11 <sal23> well, makes sense...
10:24:17 <gwern> Apocalisp: :) you really think that's better?
10:24:21 <Apocalisp> yes
10:24:28 <sal23> I suspected overflow but couldn't reproduce it in standalone fib....i guess because it is using Integer
10:24:54 <mfp> rwbarton: 32 or 31? (i.e. is one bit reserved to tag the immediate value?)
10:25:04 <Saizan_> yeah, Integer is the default
10:25:06 <Toxaris> sal23: yep, fib works for all Num, but for Int it produces nonsense
10:25:08 <rwbarton> let's find out
10:25:11 <rwbarton> > maxBound :: Int
10:25:16 <Apocalisp> gwern: It helps when thinking in terms of the types, which one does quite a lot.
10:25:17 <rwbarton> (I was guessing)
10:25:20 <Toxaris> sal23: try fib 46 :: Int
10:25:26 <lambdabot>  thread killed
10:25:37 * rwbarton sighs
10:25:51 <rwbarton> > maxBound :: Int
10:25:53 <lambdabot>  2147483647
10:25:54 <sal23> thanks Saizan and Toxaris
10:26:17 <mfp> so, 32
10:26:20 <mar77a> :t take
10:26:20 <lambdabot> forall a. Int -> [a] -> [a]
10:26:23 <PeakerWork> When is the Functor instance of functions useful? Just for the Reader monad, right? Would it be horrible if we used a Reader newtype for the Reader monad?
10:26:48 <MyCatVerbs> mfp: GHC gives you 32, but the Haskell 98 stardard says "29 or more".
10:26:50 <mar77a> > take ((maxBound :: Int)+1) [1..]
10:26:52 <lambdabot>  []
10:26:55 <Toxaris> PeakerWork: When is it a problem?
10:26:59 <mar77a> gatdamn it
10:27:06 <Saizan_> ?ty liftM2 (+)
10:27:06 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m a1 -> m a1
10:27:16 <mfp> MyCatVerbs: does this mean that GHC specializes all polymorphic functions for Ints?
10:27:24 <Apocalisp> ?type sequence
10:27:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:27:25 <MyCatVerbs> mar77a: what's the issue? That did exactly what you wanted: took (minBound :: Int) elements from [1..]
10:27:30 <Apocalisp> Peakerwork ^^
10:27:41 <PeakerWork> Toxaris: For example, the use of monadic stuff on functions for points-free stuff is confusing.  Functions specific to doing that on functions would be more readable
10:27:48 <mar77a> :t (!!)
10:27:49 <lambdabot> forall a. [a] -> Int -> a
10:28:05 <Toxaris> PeakerWork: that is true for every monad
10:28:10 <MyCatVerbs> mfp: If you mean "when an unspecified integral type is used, does GHC pick Int by default?" then I -think- the answer is yes, but I'm not sure.
10:28:11 <mar77a> > [1..] !! ((maxBound :: Int)+1)
10:28:15 <lambdabot>  Exception: Prelude.(!!): negative index
10:28:35 <dolio> GHC defaults to Integer, not Int.
10:28:36 <mar77a> :t List.(!!)
10:28:37 <lambdabot> Not in scope: data constructor `List'
10:28:38 <MyCatVerbs> > ((maxBound :: Int)+1) == (minBound :: Int)
10:28:39 <lambdabot>  True
10:28:40 <Twey> > maxBound :: Int
10:28:42 <lambdabot>  2147483647
10:28:43 <Saizan_> PeakerWork: once you understand how it works it's no more confusing (which happens to hold for everything)
10:28:44 <MyCatVerbs> dolio: oh, my bad.
10:28:47 <dolio> But that's not really what he was asking.
10:28:49 <Twey> > maxBound :: Integer
10:28:51 <lambdabot>   add an instance declaration for (Bounded Integer)
10:28:51 <lambdabot>     In the expression: ma...
10:28:52 <Toxaris> PeakerWork: why should you hide a generic interface, you can just add a specific one
10:28:57 <PeakerWork> Toxaris: nah -- I think that choosing to use a Haskell function to represent a Reader monad, and not something else, feels arbitrary and not some inherent choice (maybe its the only monad (->) CAN be, but that's not trivial)
10:28:58 <rwbarton> mfp: I think Ints are just boxed in the situation you're thinking of
10:29:18 <mfp> aaah that would explain how it manages to keep 32 bits
10:29:32 <Toxaris> PeakerWork: that's the wrong way around. We don't choose -> to be Reader, we observe that -> is Reader
10:29:45 <mfp> <mfp> <dolio> mfp:  What were you using for test data for your CSV thing? -> I generated it with this script  http://hpaste.org/9136
10:29:52 <Toxaris> PeakerWork: actually, we observe that -> is Functor, and there is only one instance possible imho.
10:29:56 <PeakerWork> Toxaris: because its the only possible instantiation of (->) as a Functor/Monad ?
10:29:59 <MyCatVerbs> mfp: Int is GHC.Base.I# Int#, and Int# is a machine word.
10:30:01 <dolio> mfp: Ah, thanks.
10:30:20 <Toxaris> PeakerWork: I think so, yes.
10:30:32 <MyCatVerbs> mfp: of course, that changes when you use Hugs/YHC/NHC/JHC... instead. ;)
10:30:43 <Apocalisp> PeakerWork: The only one that obeys the Functor/Monad laws. Can you think of another?
10:30:54 <mar77a> so what happens if i have a list with more than  maxBound :: Int elements
10:31:07 <Toxaris> PeakerWork: there are two approaches to multiple possible instances per data type. (1) choose one (2) choose none
10:31:15 <dolio> You run out of memory. :)
10:31:34 <PeakerWork> Apocalisp, Toxaris: I don't think I can - but the fact that its not trivial, IMO, suggests that maybe a: newtype Reader b = Reader { unReader :: (a -> b) }   could help?
10:31:44 <mfp> MyCatVerbs: I guess boxing Ints makes sense if you have a thunk anyway
10:31:49 <MyCatVerbs> mar77a: maxBound :: Int is -typically- half the size of your machine's address space in practice.
10:31:58 <Toxaris> PeakerWork: help with what?
10:32:00 <mar77a> > filter (==(maxBound :: Int)) [1..(maxBound :: Int)]
10:32:12 <Toxaris> PeakerWork: making less perfectly type-correct programs compile? is that a goal?
10:32:12 <PeakerWork> Toxaris: readability
10:32:13 <bd_> dolio: not necessarily - consider foldr (\a b -> (:) $! a b) [] [1..] :: [Integer]
10:32:15 <lambdabot>  thread killed
10:32:21 <MyCatVerbs> mar77a: given that each list element is at least, at a guess, 16 bytes...
10:32:26 <dolio> Yeah yeah. :)
10:32:39 <bd_>  it might take a while
10:32:43 <bd_> but you'll get there :)
10:32:47 <Toxaris> PeakerWork: If you don't like join, define dup :: (a -> a -> b) -> a -> b
10:32:51 <PeakerWork> Toxaris: I think it makes type safety even more rigid, not less so (Because you cannot accidentally give a function where a monad is expected -- you have to explicitly wrap it with a Reader)
10:32:56 <MyCatVerbs> mfp: boxing Ints is necessary *because* they're thunks. Er, something along those lines.
10:32:58 <mar77a> > maxBound :: Int * 16 / 1024
10:32:58 <lambdabot>  Parse error at "*" (column 17)
10:33:04 <Toxaris> PeakerWork: but -> *is* a monad
10:33:05 <mar77a> > (maxBound :: Int) * 16 / 1024
10:33:07 <lambdabot>   add an instance declaration for (Fractional Int)
10:33:07 <lambdabot>     In the expression: (ma...
10:33:11 <Toxaris> PeakerWork: not by chance, but *real*
10:33:16 <bd_> MyCatVerbs: boxing ints is necessary because unboxed values are always strict
10:33:20 <mar77a> > (maxBound :: Int) * 16.0 / 1024.0
10:33:22 <lambdabot>   add an instance declaration for (Fractional Int)
10:33:24 <MyCatVerbs> bd_: thanks.
10:33:28 <Toxaris> PeakerWork: or do you propose the same for []?
10:33:33 <Toxaris> PeakerWork: and Maybe
10:33:37 <MyCatVerbs> bd_: had the intuition, but couldn't work out how to put it succintly.
10:33:39 <PeakerWork> Toxaris: I am merely entertaining the alternative notion where (->) is not a Monad
10:33:40 <bd_> ie, with f :: Int# -> ()   f _ = (), f undefined = undefined
10:33:41 <Toxaris> PeakerWork: and every other data type with a Monad instance?
10:34:06 <Apocalisp> PeakerWork: At the end of the day, types have to line up. If you put a function where a list is expected, somewhere along the line you will get a type mismatch.
10:34:07 <PeakerWork> Toxaris: No, I think its more clear how Maybe is a monad, than how (->) is
10:34:08 <mfp> dolio: it's not really about CSV anymore: the profiler says the three major cost centers are hPrintf and the functions to group elements in a Map
10:34:34 <PeakerWork> Apocalisp: Yeah, but if everything is an instance of all classses, and your code is class-generic, and not specific to types... :)
10:34:40 <Apocalisp> PeakerWork: But it's extremely powerful to be able to write functions once and have them work for both lists AND functions.
10:34:50 <dolio> mfp: Well, I wrote a library to 'show' directly into byte strings, so I wanted a real example to run it on.
10:35:07 <MyCatVerbs> PeakerWork: (->) isn't a Monad, ((->) a) is.
10:35:07 <dolio> Or, "real".
10:35:12 <Toxaris> PeakerWork: so you want to hide things you find hard to understand? this is not BASIC :)
10:35:13 <PeakerWork> Apocalisp: if that is desirable, why not go to the other extreme, and not expose "map" at all - only expose fmap on lists?
10:35:22 <MyCatVerbs> PeakerWork: (quibble, just in case someone reads this and gets confused).
10:35:23 <Apocalisp> Sounds good
10:35:36 <Apocalisp> PeakerWork: In fact, I'd rename map and fmap to (.).
10:35:43 <mfp> dolio: can it format the floats like e.g. "%.2f"?
10:35:51 <Toxaris> > map succ (Just 3)
10:36:06 <lambdabot>  thread killed
10:36:12 <Toxaris> :(
10:36:29 <dolio> mfp: Not with a format string like printf, but yes. It has the showFFloat, showGFloat and showEFloat functions.
10:36:46 <Apocalisp> map succ [3]
10:36:48 <Apocalisp> > map succ [3]
10:36:49 <lambdabot>  [4]
10:36:52 <Apocalisp> whew
10:36:57 <PeakerWork> Toxaris, Apocalisp: So why not go to the other extreme, and except in code that explicitly pattern-matches a list (or any other type), have all code use methods, and not functions?
10:36:59 <Apocalisp> succ . [3]
10:37:03 <Apocalisp> > succ . [3]
10:37:04 <lambdabot>  [4]
10:37:04 <Apocalisp> gah!
10:37:17 <[1]sh> Philippa, you wrote that "generally I put that sequence of statements in a do block in a function in a module, load the module and run them that way...". Sorry, but I can't get it. Please consider the following example: data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun deriving (Eq, Ord, Enum, Show) Now I would like to do something like do{Mon;Mon<Tue} etc. But I get type errors...
10:37:27 <PeakerWork> Toxaris, Apocalisp: You will catch less type errors, perhaps, but the code will suddenly be generic to more cases you haven't thought of
10:37:50 <[1]sh> Sorry, I am a newbie.
10:38:02 <Toxaris> PeakerWork: a type error which is not essential to catch to make the program run (as in: no core dump) is a false positive
10:38:27 <PeakerWork> Toxaris: s/core dump/runtime-exception ?
10:38:36 <Apocalisp> PeakerWork: I see nothing wrong with typing your functions in the most general way.
10:38:38 * rwbarton looks for the interrobang character on his keyboard
10:38:44 <mar77a> Â¿
10:38:56 <mfp> dolio: great, I tried to showFFloat (Just 2) foo . comma . showFFloat (Just 2) bar . ... $ ""  but it wasn't any faster than hPrintf, as expected
10:38:58 <dolio> mfp: It doesn't actually seem to be faster than String, though. Building structures to efficiently generate byte strings is slower than lazily building strings, apparently (although there may be something I've missed). It's faster than showing and then packing into byte strings, though (perhaps not surprisingly).
10:38:59 <hubmike2> hey guys
10:39:00 <PeakerWork> Apocalisp: you're the easy case, you agree a list-specific "map" should not be exposed :)
10:39:05 <Toxaris> PeakerWork: checking things at runtime which are already checked by static typing is a waste of time, so I would expect the ghc runtime to core dump
10:39:24 <mfp> hmmm
10:39:29 <Toxaris> PeakerWork: the keyword is "taglesss representation"
10:39:33 <Toxaris> with less s :)
10:39:37 <hubmike2> any chance someone could answer a quick question for a newbie to haskell
10:39:41 <PeakerWork> Toxaris: heh, that's a bit paradoxical :) (if it core dumps, its no longer a redundant check)
10:39:44 <Toxaris> hubmike2: if someone asks one :)
10:40:03 <Toxaris> PeakerWork: please read my sentence containing core dump again, and note the negation :)
10:40:05 <hubmike2> well ive gt a list of tuples
10:40:13 <mfp> hubmike2: is it about, says, hylomorphisms? ;-P
10:40:17 <Toxaris> PeakerWork: you can *delete* all static checks which are *not* needed to avoid core dumps
10:40:32 <hubmike2> each tuple has artist, songtitle, totalsales
10:41:39 <hubmike2> my input to the function will be the sales list  an input of artist
10:41:51 <hubmike2> and an input of title
10:42:37 <hubmike2> im trying to search the list and finding a tuple that matches both
10:43:18 <Toxaris> hubmike2: sounds like you want to use filter (if you want to get all tuples back) or find (if you want only the first matching one)
10:43:29 <hubmike2> ok
10:43:40 <[1]sh> Anyone?
10:43:51 <dolio> mfp: It may be possible to do better than GHC's float showing code though, for instance (right now, I mainly copied it). It does lots of operations on lists of digits (as Ints), which may not be ultra efficient.
10:44:03 <hubmike2> thx guys
10:44:06 <lilachaze> hubmike2: you can do it with a list comprehension, like this: find songs artist title = [song | song@(songArtist,songTitle,songSales), songArtist == artist, songTitle == title]
10:44:30 <Toxaris> [1]sh: I think Philippa meant something different
10:44:30 <lilachaze> but filter is probably clearest
10:44:57 <Toxaris> [1]sh: then what you want to do
10:45:36 <hackage> Uploaded to hackage: AERN-Real 0.9.5
10:45:58 <rwbarton> [1]sh: so you're just writing a haskell program and you want to try evaluating some expressions to test stuff?
10:46:34 <[1]sh> Toxaris, the following works: myModule.hs containing the data statement, myModule.in containing the input: :l myModule.hs \n Mon \n Mon<Tue, and finally invoking ghci myModule.hs < myModule.in
10:47:11 <Toxaris> [1]sh: there are unit testing frameworks for haskell
10:47:13 <[1]sh> Toxaris, now I would like to do Philippa's trick
10:47:52 <[1]sh> Toxaris, i.e. moving the content of myModule.in into a function defined in myModule.hs
10:47:54 <Apocalisp> heck, lambdabot can do unit testing :)
10:48:11 <Toxaris> [1]sh: test = (Mon, Mon < Tue)
10:48:52 <Apocalisp> @check \x y -> reverse y ++ reverse x == reverse (x ++ y)
10:48:56 <lambdabot>  OK, passed 500 tests.
10:49:10 <Toxaris> [1]sh: or test = and [show Mon = "Mon", Mon < Tue]
10:49:36 <Toxaris> Apocalisp: that is not unit testing (where's the unit?)
10:49:43 <Apocalisp> reverse
10:49:54 <[1]sh> Toxaris, thanks a lot; now I feel really dumb ;-)
10:50:01 <Apocalisp> oh sorry... here's Unit testing:
10:50:04 <lilachaze> @check () == ()
10:50:05 <Apocalisp> @check ()
10:50:05 <lambdabot>  OK, passed 500 tests.
10:50:06 <lambdabot>  Arguments exhausted after 0 tests.
10:50:10 <Toxaris> Apocalisp: :)
10:50:14 <Apocalisp> jinx!!
10:50:15 <Twey> 500 tests?
10:50:26 <Twey> How many tests can you *do* on () == ()?
10:50:34 <Toxaris> @check (== ())
10:50:35 <lambdabot>  OK, passed 500 tests.
10:50:36 <dolio> As many as you want!
10:50:48 <Toxaris> Apocalisp: my version does actually test something!
10:50:58 <Apocalisp> mine's more efficient!
10:51:01 <lilachaze> Toxaris: arguably, it checks the Arbitrary instance
10:51:37 <Toxaris> @check (== True)
10:51:38 <lambdabot>  Falsifiable, after 3 tests: False
10:51:51 <lilachaze> 3 tests?
10:51:53 <Toxaris> lilachaze: see how I can check that () is 1 and Bool not this way?
10:52:06 <Toxaris> lilachaze: quickcheck does random input generation
10:52:10 <lilachaze> Toxaris: you can check that Arbitrary () only ever produces ()
10:52:18 <Apocalisp> the first two were probably () and True
10:52:28 <lilachaze> Toxaris: but I could write an Arbitrary Bool which only produces True
10:52:29 <dolio> @scheck (== True)
10:52:35 <lambdabot>     Failed to load interface for `SmallCheck':
10:52:35 <lambdabot>       Use -v to see a list of ...
10:52:48 <Toxaris> lilachaze: well, with quickcheck, you assume that the Arbitrary works correct for some unspecified meaning of correct
10:53:08 <Toxaris> Apocalisp: no, the first two where both True, () is never tried when generating Bools
10:53:14 <Toxaris> Apocalisp: it would not be type correct, you know
10:53:29 <Apocalisp> I realize that... now.
10:53:39 <heatsink> @check (< 1e10)
10:53:40 <lambdabot>  OK, passed 500 tests.
10:53:42 <rwbarton> @check (/= 172)
10:53:43 <lambdabot>  OK, passed 500 tests.
10:54:24 <Toxaris> lilachaze: more important, passed tests mean nothing, only failed tests carry relevant information
10:54:59 <lilachaze> :) semi-decidability and all that
10:55:13 <Toxaris> Apocalisp: imho the idea of unit testing is to rip a program apart into units which interact with each other, then replace all of them but one with fake units which expose fake behaviour, then test the one remaining unit
10:55:53 <Toxaris> Apocalisp: so reverse is a very nice unit for unit testing, since it doesn't interact with anything, but then you don't really need unit testing, you can do just testing
10:56:43 <Toxaris> @check (!= (172 :: Int))
10:56:43 <lambdabot>   Not in scope: `!='
10:56:47 <Toxaris> @check (\= (172 :: Int))
10:56:48 <lambdabot>   Not in scope: `\='
10:56:52 <Toxaris> @check (/= (172 :: Int))
10:56:53 <lambdabot>  OK, passed 500 tests.
10:57:00 * Toxaris hates inequality operators
10:57:04 <hubmike2> heys guys this was what i was trying to do but obviously it does not work
10:57:06 <hubmike2> http://hpaste.org/9138
10:57:09 <Apocalisp> Toxaris: Gotcha. But you have to, at some point, assume that your test program is correct. I'm assuming, for instance, that (++) works properly.
10:57:17 <Toxaris> lilachaze: this is perfectly decidable by enumerating all Ints
10:57:41 <Toxaris> but you don't replace (++) by a fake unit
10:57:46 <Toxaris> so it is "part" of the reverse unit
10:58:30 <chrisdone> hubmike2: perhaps: artistTitleSearch (s:ss) artist title		| (artist,title,_) == s = s
10:58:41 <heatsink> hubmike2: You can only use _ in patterns.  It means "get a value, then ignore it".
10:58:42 <Apocalisp> I suppose cons is and cons is part of ++
10:58:44 <chrisdone> hubmike2: uh, okay, I was going to edit the line but my IRC client just sent it anyway
10:58:58 <hubmike2> ok
10:59:53 <Apocalisp> Toxaris: I'm not convinced that "unit testing" is a valid concept.
11:00:14 <Toxaris> Apocalisp: I'm not too sure about it's meaning, either, but that is how I understand it
11:00:27 <hubmike2> any ideas?
11:00:46 <Toxaris> Apocalisp: and I don't think it is a good idea to say "unit testing" and mean "testing" and say "unit" just for fun because it sounds like following best practises developed for Java development
11:01:01 <Apocalisp> oh, I agree
11:01:02 <lilachaze> hubmike2: you could write "artistTitleSearch (s@(a,t,_):ss) artist title | a == artist && t == title = s"
11:01:07 <Apocalisp> I was just poking fun, really.
11:01:18 <hubmike2> ok
11:01:23 * Toxaris is dead serious about this. I mean, hey, it is *important*
11:01:24 <lilachaze> hubmike2: but the type of your function is then wrong (it returns a single item, not a list)
11:01:43 <lilachaze> hubmike2: and it will crash if there's no match.
11:01:52 <hubmike2> yeah
11:01:54 <lilachaze> @type find
11:01:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:02:04 <lilachaze> ^^ that function does pretty much what you want
11:02:13 <hubmike2> kl
11:02:17 <hubmike2> ill have a go
11:02:26 <Toxaris> @type find where a = (String, String, String) -- would be nice if that would work
11:02:28 <lambdabot> parse error on input `where'
11:02:50 <lilachaze> > find (\(a,t,_) -> a == "Artist" && t == "Title") [("Foo","Bar","Baz"), ("Artist","Title",123)]
11:02:51 <lambdabot>   add an instance declaration for (Num [Char])
11:02:51 <lambdabot>     In the expression: 123
11:02:51 <lambdabot>    ...
11:03:00 <lilachaze> > find (\(a,t,_) -> a == "Artist" && t == "Title") [("Foo","Bar","Baz"), ("Artist","Title","123")]
11:03:01 <lambdabot>  Just ("Artist","Title","123")
11:03:08 <lilachaze> > find (\(a,t,_) -> a == "Artist" && t == "Title") [("Foo","Bar","Baz"), ("Artist","Other Title","123")]
11:03:09 <lambdabot>  Nothing
11:03:13 <Cale> hubmike2: note that there are tab characters in your paste -- it would be a good idea to configure your editor to convert tabs into spaces automatically
11:03:31 <chrisdone> yeah, I need to do that for my emacs actually
11:03:42 <Cale> hubmike2: (the compiler will treat tabs as aligning to the next 8-space boundary, but it's better to avoid them altogether)
11:03:55 <hubmike2> ok will do
11:03:58 <uccus> do you people use GHCi just as it is or do you use it through emacs?
11:04:16 <olsner> I use it on acid :)
11:04:17 * heatsink uses ghci
11:05:16 <uccus> it's just so painful to use it... without pretty graphics and all
11:05:30 <heatsink> Pretty graphics?
11:06:02 <uccus> meaning... I use it in DOS basically, on a windows machine
11:06:02 <heatsink> In a text editor?
11:06:19 <Toxaris> uccus: me too, the windows console is so crappy
11:06:36 <uccus> it's not so easy cutting and pasting using... for example... mouse dragging or something
11:07:08 <uccus> WinHugs looked way better [didn't use it much though]
11:09:28 <heatsink> TAPL is really short on details on how to do type inference in languages with constructors and pattern matching.  Can #haskell suggest an introduction to type inference with patterns?
11:10:11 <pejo> heatsink, attapl has more stuff on HM iirc. I think the chapter is available on the web somewhere too.
11:10:25 <Toxaris> uccus: well, winhugs features sensible copy&paste, but ghci is features more features
11:10:42 <uccus> Toxaris: that's where the dilemma is
11:10:44 <Toxaris> uccus: I use ghci sometimes in the console, sometimes in jedit
11:11:03 <uccus> hmm... thanks! that's a cool idea!
11:11:25 <pejo> heatsink, the chapter is written by Francois Pottier and Didier Remy. Check their homepages perhaps.
11:12:09 <uccus> I was just wondering if there has been any updates on "Haskell is Not Not ML" front, any news?
11:12:10 <heatsink> pejo: I found the online TOC for attapl.
11:12:58 <heatsink> Some guy called "Remy Pottier" is messing up my google results.
11:13:15 <dons> uccus: in what respect, the common intermediate language?
11:13:20 <uccus> yeah
11:13:29 <dons> i don't think so.
11:13:38 <dolio> http://pauillac.inria.fr/~remy/
11:13:39 <lambdabot> Title: Didier Remy
11:13:39 <uccus> and possibly a VM based solely on continuations
11:13:48 <pejo> heatsink, people like "Typing Haskell in Haskell" too. Mark Jones has a longer version available on his homepage.
11:14:31 <[1]sh> Guys, thanks a lot for your valuable help! Bye.
11:15:39 <thetallguy> anyone familiar with the Gang of Four  Design Patterns?  A friend of mine asked how to implement Unit without state.  Hard to answer since I can't find a good description of Unit.
11:17:38 <heatsink> pejo: Thanks, I got both of them.
11:18:32 <Toxaris> thetallguy: do you know what approximately "Unit" is? I don't recognize the name
11:18:44 <thetallguy> it looks like an infinite loop
11:18:54 <Toxaris> thetallguy: (have read the GOF book in german)
11:19:19 <Apocalisp> I have the gof book right here
11:19:55 <byorgey> http://c2.com/cgi/wiki?CategoryPattern doesn't list 'Unit'
11:19:56 <lambdabot> Title: Category Pattern
11:20:00 <byorgey> maybe 'Singleton'?
11:20:08 <thetallguy> in Java, he described it as  run() { while (!stop()) doTransaction(); }
11:20:28 <Apocalisp> That code looks broken
11:20:28 <thetallguy> byorgey: could be.  Singleton is the one I've heard of.
11:20:43 <byorgey> well, that code that you showed isn't the Singleton pattern
11:20:57 <thetallguy> Apocalisp: I'm pretty sure it is.  I asked him to clarify but I have heard back yet
11:21:06 <Apocalisp> There's no Unit pattern in this book right here. Singleton is probably what he meant. Singleton is also broken.
11:21:21 <thetallguy> Thanks, I guess I'll wait for him to cough up more info
11:21:35 <byorgey> well, if it's broken, then implementing it without state should be a snap ;)
11:21:41 <Toxaris> Apocalisp: whats wrong with that code?
11:21:51 <byorgey> main = error "your c0dez R b0rked"
11:21:59 <thetallguy> I was assuming that maybe someone who knew the GOF stuff would be able to lay out a road map
11:22:13 <thetallguy> byorgey: lol
11:22:15 <Apocalisp> Toxaris: What's the value of stop() ?
11:22:49 <thetallguy> Â  boolean stop = false;
11:22:49 <thetallguy>  Â  stop( final boolean p ) { stop = p }
11:22:49 <Toxaris> Apocalisp: consider {while (!eof()) process(readLine())}
11:23:12 <Toxaris> Apocalisp: which is basically the same
11:23:23 <Toxaris> Apocalisp: and which is perfectly obvious and ok imho
11:23:40 <thetallguy> Yeah, it seemed so unremarkable that I thought I must be missing something
11:24:09 <Apocalisp> Oh yea, I see. I was thinking that was supposed to be threaded.
11:24:10 <dolio> How do you use state without using state?
11:24:27 <rwbarton> Using the State () monad
11:24:34 <dolio> :)
11:24:56 <Apocalisp> thetallguy: So he just wants to write the equivalent of that in Haskell?
11:24:58 <Shiruka> dosomething $ map process listoflines? :-P
11:25:22 <newsham> what's the magic ghc or runtime flags for giving my process multiple OS threads?
11:25:28 <Toxaris> thetallguy: tell your friend that the GoF patterns do not apply to Haskell. they are meant for stateful OO languages, Haskell is neither
11:25:56 * Apocalisp mumbles that the GoF patterns are not applicable to Java either.
11:26:01 <thetallguy> Apocalisp: I'm really not sure.  The message sort of assumes I know what's going on in the rest of his head.
11:26:12 <Toxaris> thetallguy: and then explain how to design an application which processes input until stopped in Haskell
11:26:28 <thetallguy> Frankly, I haven't heard of any good coming of the things.
11:26:52 <thetallguy> What I told him was, get a #haskell account...
11:27:00 <Apocalisp> It's like the sword Grayside. It cannot be used for good.
11:27:02 <Toxaris> :) "account"?
11:27:05 <thetallguy> id
11:27:07 <thetallguy> handle
11:27:10 <Dr_Foo> needs more System.Buzzword.Pattern
11:27:14 <Toxaris> ?
11:27:24 <thetallguy> join
11:27:31 <Apocalisp> BuckFizzFactory.createChocolateHobnob()
11:27:41 <thetallguy> Funny, looks like function definitions.
11:28:03 <Toxaris> i think the "pattern idea" is good
11:28:13 <Apocalisp> sure
11:28:20 <thetallguy> but that's what Haskell does
11:28:23 <Apocalisp> "covariant functor" is a nice pattern
11:28:44 <Toxaris> and we have such things in FP, too, we just don't call them pattern
11:29:17 <Toxaris> in Haskell, we are even often able to express them in the typesystem, which is double cool, of course
11:29:29 <Toxaris> maybe typeclasses should be named pattern for OO compatibility?
11:29:40 <Toxaris> abstract pattern Monad where ...
11:29:51 <Toxaris> pattern instance Monad [] where ...
11:29:57 <Apocalisp> I think maybe Patterns are a poor man's higher kinds
11:30:08 <Toxaris> an untyped mans
11:30:24 <Apocalisp> brother, can you spare a type?
11:30:26 <Dr_Foo> implement that as a dialect of haskell called H#
11:30:40 <Toxaris> maybe I get funding from MSR, that would be cool :)
11:30:46 <heatsink> in ur type system writing ur patternz
11:30:49 <Dr_Foo> if it worked for ocaml...
11:30:55 <thetallguy> Yes.  Thanks guys, the extra illumination revealed that this really is a mud puddle, not a burnt out bulb in my head.  I'll let him take the next step.
11:31:26 <Toxaris> thetallguy: but of course, mutable state is a solution to many problems, just not a good solution imho
11:32:11 <Toxaris> but there are people who are of the complete opposite meaning, saying that mutable state enables abstraction by providing side channels for different parts of a library to communicate
11:32:36 <Toxaris> like the stop and doTransaction functions which magically communicate behind the scenes
11:33:31 <pejo> Toxaris, heh. Reminds me of the computer communication people who don't want to break the abstractions of the TCP/IP stack, but instead build a piece of software that breaks the abstractions on the side of the TCP/IP stack. :-)
11:33:32 <Toxaris> and there are uses of that pattern (lets call it "global variable") in Haskell, too, see the various unsafePerformIO and {-# CRAZY PRAGMA DO NOT TOUCH #-} hacks
11:33:35 <Apocalisp> like core magically manipulates the CPU behind the scenes while we stay in purely abstract Haskell bliss
11:34:56 <Dr_Foo> [jesus@x1-6-00-11-09-e9-c4-e3 sdl]$ file sdl.hs
11:34:56 <Dr_Foo> sdl.hs: ASCII Java program text
11:36:50 <chrisdone> â€œvixey has joined #HASKellâ€
11:37:22 <vixey> @quote
11:37:22 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
11:37:40 <Dr_Foo> @quote qwe1234
11:37:40 <lambdabot> qwe1234 says: lol, 'free university of amsterdam'.
11:39:26 <MyCatVerbs> Apocalisp: now I'm hungry and regretting the lack of biscuits in my abode.
11:39:52 <Dr_Foo> eat a tomato with a pinch of salt and pepper
11:40:03 <Dr_Foo> best snack evar
11:40:08 <Twey> My dear Dr_Foo
11:40:10 <Twey> I love you
11:40:17 <Twey> I'm going to go and eat one of those right now.
11:40:23 * Twey zips.
11:41:24 <MyCatVerbs> pejo: please elaborate? I'm curious as to just what sins have been committed.
11:41:30 <Twey> zipWith cycle [twey] [tomato, salt, pepper]
11:42:14 * Twey twitches.
11:42:31 <MyCatVerbs> Can't match type ([a] -> [a]) against expected type (t -> t1 -> t2) in first argument of zipWith.
11:42:33 <Twey> zip (cycle [twey]) [tomato, salt, pepper]
11:42:43 <Twey> I know, I know
11:42:47 <Apocalisp> > zip (cycle [twey]) [tomato, salt, pepper]
11:42:47 <Twey> I'm hungry.  :)
11:42:51 <lambdabot>   Not in scope: `pepper'
11:42:59 <Dr_Foo> needs more ""
11:43:06 <Apocalisp> > zip (cycle ["twey"]) ["tomato", "salt", "pepper"]
11:43:08 <lambdabot>  [("twey","tomato"),("twey","salt"),("twey","pepper")]
11:43:13 <Apocalisp> whee!
11:43:20 <Twey> Yay
11:43:32 <Dr_Foo> @quote spb
11:43:32 <lambdabot> spb says: [in ##freenode-social] because monads are a nasty hack to get around a language deficiency
11:43:33 <Twey> Anyway
11:43:38 <pejo> MyCatVerbs, their argument is basically "We need more information to cope with wireless networks", which is probably true. You can probably find a bunch of different approaches to the problem if you look on congestion control for wireless networks and similar stuff.
11:43:39 <Twey> Tomato *poik*
11:43:54 <Deewiant> > map ((,) "twey") ["tomato","salt","pepper"]
11:43:55 <lambdabot>  [("twey","tomato"),("twey","salt"),("twey","pepper")]
11:44:34 <Dr_Foo> quit applying functions to food and just eat the damn thing!
11:44:58 <Deewiant> > (drop 3 ["tomato","salt","pepper"], cycle "OM N")
11:44:59 <lambdabot>  ([],"OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM ...
11:45:15 <Dr_Foo> i loled
11:45:32 <Shiruka> zipWith eat ["tomato", "salt", "pepper"] (repeat "twey")
11:45:41 <Shiruka> twey eaten first by a giant tomato, then salt and pepper monsters
11:45:59 <dmead> > [1..]
11:46:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:46:57 <Dr_Foo> eat :: Food a => a -> IO ()
11:48:11 <Shiruka> eatSecretly = unsafePerformIO . eat
11:48:42 <Apocalisp> poo :: Food a, Dude b => a -> b -> IO ()
11:48:46 <vixey> @quote
11:48:47 <lambdabot> DanPiponi says: Writing introductions to monads seems to have developed into an industry
11:49:18 <_zenon_> And still most of them lack the proper amount of examples
11:49:26 <_zenon_> which is sad
11:50:29 <Apocalisp> For those who understand the type of (>>=) no explanation is necessary. For those who don't, no explanation is possible.
11:50:31 <Shiruka> I think their purpose is to crystallize the idea of monads in the mind of the author, not the reader :-P
11:51:03 <_zenon_> Apocalisp, sounds like you have a sad view of teaching. Annyway, I am wipping up a set of examples, using the various monad types
11:51:14 <_zenon_> From easy examples going to increasingly complex
11:51:24 <Apocalisp> I'm kidding! Sheess.
11:51:40 <Shiruka> industrial strength monad tutorial?
11:51:56 <_zenon_> My view of the whole monad learning problem was that the examples themselves where too complexly written, the use of the monads got obfuscated.
11:52:04 <Dr_Foo> Apocalisp: you are? damn, I was just about to agree with you :(
11:52:09 <Twey> Dr_Foo, you are a genius
11:52:09 <_zenon_> Apocalisp, Oh, sorry. Can't know that :)
11:52:13 <Twey> *nibbles*
11:52:52 <_zenon_> Shiruka, I kind of agree
11:53:25 <MyCatVerbs> pejo: huh. So where (ideally) you'd want to be working at the IP level only, it's necessary for them to look into TCP headers too, you mean?
11:53:57 <MyCatVerbs> pejo: and they can't quite bring themselves to do that, so they're doing other, equally sinful but more indirect, things instead?
11:54:26 * _zenon_ goes back to his star trek
11:55:03 <vixey> hello
11:55:05 <MyCatVerbs> _zenon_: before you do that, consider this;
11:55:49 <MyCatVerbs> _zenon_: Star Trek characters, when using computers, often do stupid things like moving data when it'd realistically be perfectly easy to copy it.
11:56:07 <pejo> MyCatVerbs, they want as much information as possible about the medium, to exploit the characteristics of it. (TCP is well known to behave badly on wireless network). Some researchers do other sinful stuff instead.
11:56:16 <heatsink> MyCatVerbs: And they delete programs instead of turning them off!
11:56:23 <MyCatVerbs> heatsink: right, right.
11:56:30 <hubmike2> hey guys i have another slight problem maybe one of you can tell me whats wrong
11:56:31 <zachk> sinful stuff makes money
11:56:33 <Shiruka> MyCatVerbs: you're not supposed to think too clearly when watching star trek
11:56:38 <hubmike2> http://hpaste.org/9139
11:56:45 <_zenon_> MyCatVerbs, what about this: Why the hell don't they EVER copy the Doctor into a secure location in case he "dies"? Full of those knacks.
11:56:47 <vixey> and there's no sound in space anyway!
11:56:55 <_zenon_> Shiruka, true
11:57:06 <_zenon_> vixey, Inside the ship there is :)
11:57:06 <MyCatVerbs> _zenon_: see if you can construct a linear typed system in which it actually makes sense to do so.
11:57:11 <Spark> on the other hand, computers on startrek are as ordinary people would like them to be
11:57:23 <Spark> free from irritating details and complexities that divert from the actual problem
11:57:34 <MyCatVerbs> Shiruka: you mean "mind-reading".
11:57:38 <MyCatVerbs> ...Er.
11:57:43 <Shiruka> signalling damage to the ship by blowing up the keyboards is unbelievably dumb user interface, for instance :-P
11:57:43 <MyCatVerbs> Spark: you mean "mind-reading".
11:57:49 * _zenon_ should think less when watching ST
11:57:50 <Dr_Foo> plus they're far more reliable at making a cup of tea on command than my wife ever was
11:57:51 <zachk> hubmike2: use ghc
11:57:51 <Spark> MyCatVerbs: inference ;)
11:58:10 <Spark> Dr_Foo: that often went wrong though, as i remember :)
11:58:23 <Spark> "tea, earl grey, hot" bzzzzzt "no, not a goat, a cup of tea, please"
11:58:24 <MyCatVerbs> Spark: Star Trek's characters never get the computer telling them that their thoughts are impossible. Proper inference does that. :)
11:58:30 <zachk> hubmike2: http://book.realworldhaskell.org/beta/
11:58:31 <Twey> Spark: :-D
11:58:33 <lambdabot> Title: Real World Haskell
11:58:35 * BMeph thinks that "in the future," pockets will still exist, and even be useful!
11:58:42 <hubmike2> downloading as we speak
11:58:54 <Spark> BMeph: people will just have infinitely many arms
11:59:27 <hubmike2> any ideas on the code though?
11:59:35 <pejo> MyCatVerbs, well, I'm drifting off-topic here, sorry. I don't have any exact pointers, but hopefully you get the idea.
11:59:50 <vixey> hubmike2: You'll need fromJust
12:00:02 <fixnum> when I enter " 6 'div' 2 " in my ghci, I get " <interactive>:1:4: lexical error in string/character literal at character 'i' "
12:00:16 <vixey> fixnum: You should use ``'s not ''`s
12:00:40 <MyCatVerbs> hubmike2: you've defined "Sales" as a list of (Artist,SongTitle,SalesTotal), but, in artistTitleSearch, the find function returns a Maybe (Artist,SongTitle,SalesTotal).
12:00:41 <fixnum> oh, I didn't notice that. thanks vixey
12:00:52 <hubmike2> ok
12:01:36 <Twey> Dr_Foo: Arrgh, put too much salt on this slice *scrunches mouth*
12:01:58 <hubmike2> am i still able to use the find function?
12:02:05 <MyCatVerbs> pejo: you say "about the medium", you mean they're taking advantage of electromagnetic properties of the environment the transcievers are in?
12:02:14 <Dr_Foo> Twey: it only needs the tiniest sprinkle to bring the flavour out by contrasting with the tomato's natural sweetness!
12:02:16 <hubmike2> no way to change the return?
12:02:21 * Twey nodnods.
12:02:30 <MyCatVerbs> hubmike2: perhaps you wanted filter instead of find?
12:02:34 <Twey> Dr_Foo: I found about half a pinch to be adequate
12:02:38 <hubmike2> ok
12:02:57 <Dr_Foo> although now that tomatos are no longer in season i've found that i have to add more salt to make it palatable
12:03:04 <MyCatVerbs> hubmike2: or if that's supposed to return exactly 0 or 1 elements, maybe you want to use maybeToList from Data.Maybe?
12:03:18 * Twey finishes his tomato with satisfaction.
12:03:21 <MyCatVerbs> Dr_Foo: hang on, a whole tomato?
12:03:45 <Dr_Foo> MyCatVerbs: i cut them into eighths
12:03:47 <MyCatVerbs> Just, here's a whole raw tomato. Put some salt on top, bite in? :D
12:03:54 <MyCatVerbs> Ah. That clears that up.
12:04:00 <Twey> Mine ended up in five slices
12:04:26 <Twey> MyCatVerbs: And don't forget the pepper
12:04:31 <Twey> The pepper is important too
12:04:41 <Shiruka> salt on a tomato..? :-O
12:04:44 <hubmike2> no its supposed to return the tuple found
12:04:46 <zachk> hubmike2: hope this helps http://hpaste.org/9139#a1
12:04:54 <Twey> Shiruka: Only a little bit!
12:05:39 <Shiruka> sounds almost like ketchup..
12:05:49 <Twey> No no.
12:05:52 <Twey> Not at all.
12:05:53 <pejo> MyCatVerbs, I meant for a higher level (ZigBee vs 802.11g vs Bluetooth), but there's probably people doing the work you describe as well.
12:06:27 <MyCatVerbs> zachk: that'll still break - the type declaration says it returns a Sales, while the type of 'find' is (a -> Bool) -> [a] -> Maybe a.
12:07:12 <MyCatVerbs> pejo: I'm casting out somewhat randomly because I can't work out what level you're referring to. :)
12:07:28 <MyCatVerbs> pejo: er, obvious question, what OSI level? :)
12:08:05 <MyCatVerbs> Hahaha, best mnemonic evar. For the OSI model, "Please Do Not Take Sales' Peoples' Advice."
12:08:21 <MyCatVerbs> Er, s/s'/s/.
12:09:51 <Benigno> hello! ^_^
12:10:07 <Benigno> I didn't expect so much people
12:10:19 <vixey> hi
12:10:29 <vixey> most of them just read, I guess
12:10:43 <Shiruka> or are AFK..
12:10:55 <Benigno> I see
12:11:08 <Benigno> I am working hard with haskell now
12:11:35 <Benigno> neural networks libraries
12:11:42 <Dr_Foo> haskell is lazy: if you're working hard you're doing it wrong
12:11:43 <Benigno> ^_^
12:11:52 <Benigno> xD
12:11:52 <Dr_Foo> ... sorry guys i'm having a sense of humour failure this week :(
12:12:09 <Shiruka> or the programmer has to work hard because the language is so lazy ;-)
12:12:10 <Benigno> nah Dr_Foo, it's ok
12:12:36 <hubmike2> ok still totally lost with this one http://hpaste.org/9139
12:12:50 <hubmike2> if anyone has a spare minute
12:14:08 <Dr_Foo> either make artistTitleSearch return Maybe Sales or wrap the call to find with fromMaybe
12:14:26 <Dr_Foo> gotta walk the dog, back in 20
12:16:40 <Shiruka> hubmike2: it's basically complaining that find may return Nothing, and you haven't specified what to do in that case
12:16:56 <hubmike2> ok
12:17:34 <hubmike2> sorry i am very new on this lol
12:17:53 <hubmike2> so put a guard against nothing appearing?
12:18:55 <Botje> what do you want to do if the user searches for a song that's not in the db?
12:19:02 <Shiruka> e.g. this way:
12:19:03 <Shiruka> artistTitleSearch:: Sales -> String -> String -> (Artist, SongTitle, SalesTotal)
12:19:07 <Shiruka> artistTitleSearch sales a t = fromJust $ find(\(a,t,_) -> a == "Artist" && t == "Title") sales
12:19:20 <Botje> if you want to fail horribly, use fromJust
12:19:21 <Shiruka> but here you get an exception if the song is not found
12:19:41 <Shiruka> with fromMaybe, you could specify a default value
12:19:44 <gwern> "I am not a Church numeral; I am a free variable!"
12:19:50 <Botje> if you want toleave the decision to the user, put your return type as Maybe Sales
12:19:55 <gwern> @remember OlinShivers "I am not a Church numeral; I am a free variable!"
12:19:55 <lambdabot> Done.
12:20:04 <gwern> @flush
12:20:04 <lambdabot> Not enough privileges
12:20:34 <hubmike2> ok thanks guys
12:20:43 <gwern> bah! fine, we'll see whether lambdabot remembers...
12:21:52 <Botje> @quote
12:21:52 <lambdabot> cjeris says: i have a little perl script that aliases gcc -freduced-suckage to ghc
12:22:27 <vixey> @quote
12:22:28 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
12:22:48 <Botje> @quote xahlee
12:22:49 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
12:22:51 <Botje> boo.
12:23:04 <Botje> i'd expect xahlee to have some more interesting quotes
12:23:31 <vixey> @quone
12:23:31 <lambdabot> GentleIntro says: If k1 and k2 are kinds, then k1->k2 is the kind of types that take a type of kind k1 and return a type of kind k2.
12:23:40 <gwern> Botje: lambdabot is very forgetful
12:25:42 <Botje> @quote
12:25:42 <lambdabot> l33t_h4x0r says: maybe if uve had some professor teach u bullshit in uni yea \n i learned on my own.. k.. i dun give a shit bout terms :p i just code
12:25:46 <Botje> really?
12:26:54 <dolio> @remeber xahlee note to readers: i'm not just interested in functional programing, i'm the world's top expert
12:26:54 <lambdabot> Okay.
12:27:01 <Botje> rofl
12:27:04 <vixey> heh
12:27:32 <Twey> Hehe
12:27:34 <dmhouse> ?help quote
12:27:35 <lambdabot> quote <nick>
12:27:35 <lambdabot> remember <nick> <quote>
12:27:35 <lambdabot> Quote somebody, a random person, or save a memorable quote
12:27:52 <Valodim> @quote lambdabot
12:27:52 <lambdabot> lambdabot says: @quote lambdabot
12:27:56 <gwern> @quote dark
12:27:57 <lambdabot> desrt says: man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
12:27:57 <Valodim> haha
12:28:08 <gwern> @quote dark
12:28:09 <lambdabot> ari says: The problem I have with grues is that although I know that currently, if it is very dark I am likely to be eaten by one... but how can I tell if grue suddenly became benign at, say, the
12:28:09 <lambdabot> year 2010? The evidence I've gathered so far can't support the idea that that *wouldn't* happen.~
12:28:26 <gwern> lol. that's philosophy though, not CS
12:28:37 <gwern> @quote dark
12:28:37 <lambdabot> ari says: The problem I have with grues is that although I know that currently, if it is very dark I am likely to be eaten by one... but how can I tell if grue suddenly became benign at, say, the
12:28:37 <lambdabot> year 2010? The evidence I've gathered so far can't support the idea that that *wouldn't* happen.~
12:28:43 <jpcooper> @hoogle [[a]] -> [a]
12:28:50 <lambdabot> Prelude.concat :: [[a]] -> [a]
12:28:50 <lambdabot> Data.List.concat :: [[a]] -> [a]
12:28:50 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
12:28:59 <zachk> how do i type a smiley face the ASCII one
12:29:00 <vixey> :t join :: [[a]] -> [a]
12:29:03 <lambdabot> forall a. [[a]] -> [a]
12:29:24 <gwern> @remember dark <shapr> for example: "head (filter (\x -> x > 5) [1..])" <shapr> in a strict language, you can't easily play with infinite lists <dark> In a strict language, you would write that as "6" :)
12:29:24 <lambdabot> I will remember.
12:29:56 * robyonrails "Tu devi essere Igor" ... "No, si pronuncia Aigor"
12:30:29 <gwern> @quote dumb
12:30:29 <lambdabot> Pseudonym says: Well, personally, I don't think dumb people should be let near a programming language.
12:30:45 <vixey> @quote
12:30:45 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
12:30:58 <vixey> @seen ddarius
12:30:58 <lambdabot> I haven't seen ddarius.
12:31:18 <gwern> @quote weak
12:31:19 <lambdabot> Adamant says: captchas are a way for some humans to find out their image recognition is worse than an tweaked OCR package
12:31:20 <dmhouse> I liked the one from HWN recently: "<Japsu> segfault cat is watching you unsafeCoerce"
12:31:27 <Japsu> HILIGHT
12:31:33 <Japsu> what
12:31:37 <Japsu> did I make it into HWN?!?
12:31:38 <gwern> @quote weak
12:31:38 <lambdabot> Adamant says: captchas are a way for some humans to find out their image recognition is worse than an tweaked OCR package
12:31:56 <chrisdone> @src concat
12:31:57 <lambdabot> concat = foldr (++) []
12:32:04 <dmhouse> Japsu: http://sequence.complete.org/hwn/20080716
12:32:05 <lambdabot> Title: Haskell Weekly News: July 16, 2008 | The Haskell Sequence
12:32:18 <gwern> @remember shapr < shapr> the snow falls slowly / the lambdas are lifting - / weak head normal form.
12:32:18 <lambdabot> Okay.
12:32:25 <jpcooper> @hoogle Int -> [a] -> [a]
12:32:26 <lambdabot> Prelude.take :: Int -> [a] -> [a]
12:32:26 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
12:32:26 <lambdabot> Data.List.take :: Int -> [a] -> [a]
12:32:26 <Japsu> omfg :D
12:33:05 <jpcooper> is there a function to delete an item at an index?
12:33:14 <Toxaris> jpcooper: no
12:33:16 <gwern> @quote sarah
12:33:16 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
12:33:24 <Toxaris> jpcooper: but you can easily do it with take and drop and ++
12:33:29 <gwern> ...
12:33:31 <gwern> @quote sarah
12:33:32 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
12:33:32 <Deewiant> preferably splitAt
12:33:51 <vixey> removeElementAt
12:33:51 <gwern> @remember sarah "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
12:33:52 <lambdabot> I will never forget.
12:34:06 * gwern notes that sarah peyton jones == SPJ. zOMG it's a conspiracy!
12:34:09 <Japsu> wtf ;D
12:34:12 <jpcooper> Toxaris, will do
12:34:22 <Japsu> what do the rules of go have to do with functional programming ;D
12:34:27 * Japsu 16 kyu
12:34:56 <Toxaris> jpcooper, Deewiant: will splitAt may be optimized, positional access to lists shouldn't occur where optimization matters imho, so it doesn't matter too much
12:34:59 <dmhouse> > let del ix xs = take ix xs ++ drop (ix+1) xs in del 2 [1..5]
12:35:01 <lambdabot>  [1,2,4,5]
12:35:33 <Toxaris> s/will/while
12:35:36 <jpcooper> @source splitAt
12:35:36 <lambdabot> splitAt not available
12:35:45 <gwern> Japsu: hm. good question. aren't captures destructive mutations?
12:35:49 <jpcooper> it doesn't really need to be optimised :)
12:36:24 <jpcooper> is there a function which takes two functions and one argument and applies it to both?
12:36:35 <jpcooper> I mean
12:36:38 <Toxaris> jpcooper: both to it you mean?
12:36:50 <vixey> > ( reverse &&& head ) "yes"
12:36:52 <lambdabot>  ("sey",'y')
12:36:53 <jpcooper> never mind
12:36:57 <Japsu> gwern: heh
12:37:03 <gwern> @quote blackdog
12:37:04 <lambdabot> blackdog says: i think coding in your sleep should trigger an exception
12:37:11 <gwern> @quote blackdog
12:37:12 <lambdabot> blackdog says: My variables aren't varying.
12:37:32 <jpcooper> what I'd like to do is apply the argument to both, and have the result of applying it to the first, be applied to the function applied to the argument
12:37:34 <gwern> @quote blackdog
12:37:35 <lambdabot> blackdog says: My variables aren't varying.
12:37:44 <Toxaris> > let del ix = uncurry (++) . take ix &&& drop (ix + 1) in del 2 [1..5]
12:37:44 <jpcooper> I guess I should always do this by hand
12:37:45 <lambdabot>  Couldn't match expected type `(a, a)' against inferred type `[a1]'
12:37:51 <gwern> @quote blackdog
12:37:52 <lambdabot> blackdog says: I'm not encouraged by the comment "i don't know haskell, but CL is much better", though. it doesn't suggest careful thought and objectivity...
12:37:52 <vixey> > (head . reverse) "this?"
12:37:53 <lambdabot>  '?'
12:37:55 <jpcooper> I remember if there was a function to do this already
12:38:02 <gwern> @quote blackdog
12:38:02 <lambdabot> blackdog says: My variables aren't varying.
12:38:03 <Toxaris> > let del ix = uncurry (++) . (take ix &&& drop (ix + 1)) in del 2 [1..5]
12:38:10 <lambdabot>  [1,2,4,5]
12:38:12 <gwern> (dammit, how many quotes does blackdog have?)
12:38:24 <gwern> @remember blackdog  <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me still
12:38:24 <lambdabot> Done.
12:38:52 <Toxaris> jpcooper: use ap
12:38:59 <jpcooper> @hoogle ap
12:38:59 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
12:38:59 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
12:38:59 <lambdabot> System.IO.appendFile :: FilePath -> String -> IO ()
12:39:08 <jpcooper> okay
12:39:16 <Toxaris> :t ap :: (r -> x -> y) -> (r -> x) -> y
12:39:17 <lambdabot>     Occurs check: cannot construct the infinite type: y = r -> y
12:39:19 <adept> hi. is this me, or there really isn't any freely-available implementation of Kuhn-Munkres algorithm in Haskell?
12:39:22 <gwern> @quote autodidactism
12:39:22 <lambdabot> shapr says: I've tried to teach people autodidactism, but I've realized they have to learn it for themselves.
12:39:49 <Toxaris> :t ap :: (r -> x -> y) -> (r -> x) -> r -> y
12:39:50 <lambdabot> forall r x y. (r -> x -> y) -> (r -> x) -> r -> y
12:39:50 <gwern> @quote autrijus
12:39:50 <lambdabot> autrijus says: Woot. I got Larry Wall started learning Haskell ;)
12:39:57 <jpcooper> whoah, nice
12:40:08 <chrisdone> gwern: what does `autodidactism' mean?
12:40:09 <gwern> @quote autrijus
12:40:09 <lambdabot> autrijus says: Woot. I got Larry Wall started learning Haskell ;)
12:40:19 <gwern> @quote ContT
12:40:20 <lambdabot> No quotes match.
12:40:22 <Toxaris> jpcooper: note that (<*>) = ap
12:40:34 <vixey> @quote cc
12:40:34 <lambdabot> lambdabot says: Occurs check: cannot construct the infinite type: a
12:40:34 <gwern> chrisdone: here's a useful google query: 'define:autodidacticism'
12:40:38 <jpcooper> Toxaris, okay
12:40:38 <Valodim> hahaha
12:40:39 <Toxaris> jpcooper: so you can easily use it infix
12:40:42 * gwern notes that that was an example of autodidacticism
12:40:49 <chrisdone> gwern: yeah, that was the joke..
12:41:03 <gwern> @remember autrijus * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I just don't know what it means.
12:41:04 <lambdabot> It is forever etched in my memory.
12:41:12 <gwern> @quote ContT
12:41:12 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
12:41:12 <lambdabot> just don't know what it means.
12:41:23 <gwern> @remember SyntaxNinja <SyntaxNinja> I think that the compiler authors will fly here from england just to kill me if I did that
12:41:23 <lambdabot> It is stored.
12:41:41 <vixey> did what ?
12:42:17 <Toxaris> gwern is \bot's backup storage device?
12:42:22 <gwern> @quote deprecate
12:42:22 <lambdabot> ghc says: foreign declaration uses deprecated non-standard syntax
12:42:41 <gwern> @quote deprecate
12:42:41 <lambdabot> ghc says: foreign declaration uses deprecated non-standard syntax
12:42:52 * gwern keeps getting accused of being some sort of bot :(
12:43:03 <gwern> you know what, I'll take this to privmsg
12:43:09 <vixey> no gwern
12:43:13 <vixey> I like them
12:43:18 <chrisdone> no gwern, you are the demons
12:43:18 <ski> gwern : #haskell-overflow, maybe ?
12:43:19 <vixey> :(
12:43:38 <Valodim> ahahaha, those Three Virtues of a Programmer are great
12:43:54 <Spark> what are they?
12:43:57 <chrisdone> ski: #haskell-overflow `compare` #haskell-blah
12:44:19 <ski> chrisdone: GT
12:44:42 <gwern> @remember HSP
12:44:42 <lambdabot> Incorrect arguments to quote
12:44:45 <gwern> er.
12:44:47 <gwern> @quote HSP
12:44:47 <lambdabot> shapr says: <shapr> Oleg will do something terrifying like implementing type checking in tcp/ip checksums on the router level through someemergent property of BGP and he'll do it all with HSP!
12:44:47 <bogner1> ghc's -i command line option adds directories to search for imports to the beginning of the search path. Is there a way to add directories to search for imports to the _end_ of the search path?
12:44:52 <jpcooper> Toxaris, length numbers == (length $ nub numbers) <-- how could I use ap to do that?
12:45:13 <jpcooper> noneEqual numbers = length numbers == (length $ nub numbers)
12:45:22 <gwern> @quote ceramic
12:45:22 <lambdabot> blackdog says: <blackdog> kallo, kallay: my gf dragged me along to a ceramics class, and I now have a mug with a lambda on one side and the legend "go away, or i will replace you with a trivial
12:45:22 <lambdabot> lambda expression" on the other.
12:46:17 <chrisdone> @pl \numbers -> length numbers == (length $ nub numbers)
12:46:17 <lambdabot> liftM2 (==) length (length . nub)
12:46:19 <gwern> @quote cows
12:46:19 <lambdabot> JohnMeacham says: <JohnMeacham> That's a lot of cows.
12:46:36 <ski> gwern : where are you refreshing the quotes from ?
12:46:56 <funktio> ap ((==) `on` length) nub numbers
12:47:01 <gwern> ski: http://web.archive.org/web/20070609061216/http://www.haskell.org/hawiki/QuotesPage
12:47:04 <chrisdone> does Î»b have a web page of quotes?
12:47:05 <lambdabot> Title: QuotesPage - The Haskell Wiki, http://tinyurl.com/6qp7fr
12:47:07 <wjt> > ( (==) <*> length <*> (length . nub) ) [1,2,3]
12:47:07 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
12:47:09 <gwern> apparently the old hawiki archives have disapeared off of haskell.org
12:47:14 <wjt> d'oh :(
12:47:20 <ski> gwern : ah :)
12:47:27 <byorgey> liftM2 (==) length (length . nub), or equivalently  (==) `fmap` length `ap` (length . nub)
12:47:46 <byorgey> or equivalently (==) <$> length <*> (length . nub)   -- import Control.Applicative
12:47:48 <Valodim> http://en.wikipedia.org/wiki/Ada_Lovelace
12:47:48 <Valodim> ahaha, I never knew the person considered the "first programmer" was actually a woman
12:47:49 <lambdabot> Title: Ada Lovelace - Wikipedia, the free encyclopedia
12:48:07 <gwern> @quote curses
12:48:07 <lambdabot> dons says: * dons X11s his curses installation
12:48:09 <ski> chrisdone : in the old days, before lambdabot, we kept quotes on a "wiki web page"
12:48:52 <lgreen> Not to be impatient, but could anyone help me with my FFI beginner questions, cf. http://article.gmane.org/gmane.comp.lang.haskell.cafe/42505 ?
12:49:01 <chrisdone> ski: so?
12:49:04 <lambdabot> Title: Gmane -- Mail To News And Back Again
12:49:09 <byorgey> > (==) <$> length <*> (length . nub) $ [1,2,3]
12:49:11 <lambdabot>  True
12:49:13 <byorgey> > (==) <$> length <*> (length . nub) $ [1,2,3,1]
12:49:14 <lambdabot>  False
12:49:28 <jpcooper> where is <$> defined?
12:49:28 <lgreen> I wrote that mail yesterday, but got no replies so far :-(
12:49:32 <dmhouse> > (== [1,2,3]) [1,2,3]
12:49:33 <byorgey> jpcooper: note, this is the ((->) e) (aka Reader) monad
12:49:37 <jpcooper> :t (<$>)
12:49:38 <lambdabot>  True
12:49:40 <dmhouse> > (== [1,2,3]) [1,2,3,1]
12:49:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:49:43 <chrisdone> @hoogle (<$>)
12:49:44 <ski> chrisdone : well .. you asked about the web page of quotes
12:49:45 <byorgey> jpcooper: Control.Applicative.  (<$>) is just a synonym for fmap.
12:49:47 <lambdabot>  False
12:49:51 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
12:49:54 <jpcooper> aah
12:50:06 <chrisdone> ski: I asked about a web page of quotes associated with lambdabot
12:50:37 <byorgey> you could also do   pure (==) <*> length <*> (length . nub)
12:50:47 <ski> oh .. i thought your question was in relation to gwern's link
12:50:48 <byorgey> to 'lift' (==) into the reader monad first before applying it
12:51:22 <gwern> @quote <autrijus>
12:51:22 <lambdabot> <autrijus> says: using Haskell is like having the power of Reason. <autrijus> all bad guys listen to Reason.
12:51:40 <gwern> chrisdone: the lambdabot quotes exist as a darcs-managed gzipped file in the lambdabot repo
12:51:41 <Dr_Foo> @quote qwe1234
12:51:41 <lambdabot> qwe1234 says: a language with type inference isn't more expressive -- because type declarations are redundant, much like 'sigils' in perl.
12:51:42 <jpcooper> what about using liftA2?
12:51:44 <gwern> weird, I know
12:51:51 <chrisdone> gwern: I see
12:52:01 <vixey> :t liftA2 (==)
12:52:01 <lambdabot> forall a (f :: * -> *). (Applicative f, Eq a) => f a -> f a -> f Bool
12:52:06 <byorgey> jpcooper: sure, since we're using Applicative you could use liftA2 instead of liftM2
12:52:16 <jpcooper> okay
12:52:17 <vixey> :t liftM2 (==)
12:52:17 <lambdabot> forall a1 (m :: * -> *). (Monad m, Eq a1) => m a1 -> m a1 -> m Bool
12:52:20 <vixey> basically,
12:52:24 <vixey> you have an 'a' instead of an 'm'
12:52:34 <byorgey> liftAn f x y z...  === f <$> x <*> y <*> z ...
12:52:37 <vixey> although lambdabot wrote it as an f
12:52:40 <gwern> @quote toothpaste
12:52:40 <lambdabot> olliej says: <olliej> java is a great language <olliej> i like to eat toothpaste <olliej> :)
12:52:44 <jpcooper> are all functions monads?
12:52:59 <vixey> @src Reader
12:52:59 <lambdabot> Source not found. I feel much better now.
12:53:01 <Dr_Foo> java programmers are the erotic furries of cs
12:53:02 <vixey> Reader is a monad
12:53:07 <byorgey> jpcooper: well, that question doesn't really make sense the way you have phrased it
12:53:18 <jpcooper> I mean something else
12:53:23 <jpcooper> I just don't know how to say it
12:53:33 <jpcooper> how can a function match the type m a?
12:53:33 <byorgey> jpcooper: the constructor ((->) e), which constructs the type of functions which take a parameter of type e, is a monad for all types e
12:53:46 <byorgey> so ((->) e) is m  in  m a
12:53:56 <byorgey> ((->) e) a === (e -> a)
12:54:02 <jpcooper> aah, okay
12:54:05 <gwern> @quote type-hackery
12:54:05 <lambdabot> shapr says: <shapr> Yeah, it does require more than an oleg of type-hackery. <poetix> oleg's now a unit? <autrijus> is oleg an unit now? <shapr> Yup, a rather large unit of type-hackery too.
12:55:08 <chrisdone> > liftA2 (+) (*5) (+3) 9
12:55:26 <lambdabot>  thread killed
12:55:31 <byorgey> 57
12:55:33 <chrisdone> ;_;
12:57:22 <gwern> @quote <autrijus>
12:57:22 <lambdabot> <autrijus> says: using Haskell is like having the power of Reason. <autrijus> all bad guys listen to Reason.
12:57:23 <gwern> @quote <autrijus>
12:57:23 <lambdabot> <autrijus> says: using Haskell is like having the power of Reason. <autrijus> all bad guys listen to Reason.
12:57:57 <chrisdone> @vixen gwern is up to something
12:57:57 <lambdabot> Do you think you would pass a Turing test?  I have.
12:58:24 <gwern> @quote <autrijus>
12:58:24 <lambdabot> <autrijus> says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
12:58:44 <chrisdone> haha
12:58:48 <vixey> lol
12:59:02 <thaldyron> Can someone tell me why the error handler in function test2 in http://hpaste.org/9142 does not catch the exception?
12:59:46 <gwern> @quote cheating
12:59:47 <lambdabot> Speck says: <Speck> "That's like cheating. It isn't even programming. You just tell it what to do and it does it." -- My friend upon seeing some Haskell code
13:00:46 <thaldyron> already solved, I used throw instead of throwDyn... :)
13:00:53 <bos> dons: ping
13:00:56 <bos> @seen dons
13:00:56 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 47m 28s ago.
13:01:07 <Twey> Hahahah
13:02:59 <MyCatVerbs> bos: Marco!
13:03:53 <gwern> @quote crickets
13:03:54 <lambdabot> SleepDeprivation says: <Speck> Oh my god. Crickets in the basement. <Speck> Hundreds of them.
13:04:16 * Botje giggles
13:04:18 <Botje> @quote
13:04:19 <lambdabot> Itkovian says: my balls are large enough, thank you very much
13:05:13 <vixey> :t let e t = t (\x -> x) (\b -> \x -> e (b x)) (\m n -> e m (e n)) in e
13:05:14 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:05:14 <lambdabot>     Probable cause: `e' is applied to too many arguments
13:05:14 <lambdabot>     In the expression: e m (e n)
13:05:26 <gwern> @quote liftIO
13:05:26 <lambdabot> poetix says: 22:19 < poetix> liftIO makes you larger, and foldR makes you small 22:19 < poetix> And the id that mother gives you, doesn't do anything at all
13:06:12 <gwern> @quote radishes
13:06:13 <lambdabot> poetix says: < poetix_>: In ancient Athens, they used to punish adulterers by forcing radishes up their rectums < boegel>: poetix_: sounds like fun !
13:07:00 <Botje> is there an overview of \bot quotes somewhere?
13:07:30 <gwern> @quote plutonium
13:07:30 <lambdabot> gzl says: <ricebowl> what does >>= do? <basti_> ricebowl: monads are cute pink fuzzy little things. <gzl> with plutonium inside.
13:07:50 <gwern> Botje: as I said, a gzipped darcs-managed file in the lambdabot repo on c.h.o...
13:08:05 <Botje> must've missed that, sorry :)
13:08:11 * Botje looks
13:08:36 <gwern> @quote Korollary
13:08:36 <lambdabot> Korollary says: Google employees suck. [some time later] I bet my search history has been made public right now
13:08:44 <gwern> @quote Korollary
13:08:44 <lambdabot> Korollary says: I enjoy being satan at times
13:08:51 <olsner> do quotes ever make it into that file, or does lambdabot simply regularly get mindwiped?
13:09:24 <olsner> @quote perl
13:09:24 <lambdabot> qwe1234 says: it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
13:09:35 <gwern> olsner: I believe lambdabot can be forced to serialize to disk with '@flush'
13:09:40 <olsner> @quote ghc
13:09:40 <lambdabot> ghc says: Bindings in hs-boot files are not allowed
13:09:41 <gwern> however I have not permissions
13:11:13 <olsner> and it's up to the driver of the bot to occasionally check in new batches of quotes into the repository?
13:11:31 <gwern> olsner: believe so
13:11:32 <gwern> @quote zoom
13:11:32 <lambdabot> dons says: <dons> and you can just zoom in until you see the locations at full res. huh. so this is how I track my enemies
13:12:25 <gwern> @quote Tolkien
13:12:25 <lambdabot> <autrijus> says: TDD is actually Tolkien-Driven Development.
13:13:13 <gwern> @quote thermodynamics
13:13:13 <lambdabot> <JohnMeacham> says: of course any minute now oleg is going to come along and actually express the second law of thermodynamics via functional dependencies as a purely incidental part of improving
13:13:13 <lambdabot> HList syntax or something.
13:13:50 <gwern> @quote cthuluh
13:13:51 <lambdabot> basti says: <basti_> google has kind of a personality <basti_> a little like one the "great elder gods" in the cthuluh myth i think.
13:14:11 <olsner> @quote x86
13:14:11 <lambdabot> No quotes match. You untyped fool!
13:14:15 <olsner> @quote 86
13:14:15 <lambdabot> cjeris says: vincenz: no, on a 286 GHC feels warm, like a little fire you can warm your hands at.  wait, that smells funny.  wait, that was my CPU.
13:14:52 <gwern> @quote Badger
13:14:52 <lambdabot> Philippa says: < ihope> data Badger = Badger Badger Badger | Mushroom < Philippa> Pattern match failure: Snake!
13:15:13 <olsner> lol
13:15:16 <jaj> :)
13:16:19 <gwern> @quote indented
13:16:20 <lambdabot> BlairPHoughton says: "In My Egotistical Opinion, most people's C programs should be indented six feet downward and covered with dirt." -- Blair P. Houghton
13:16:25 <vixey> does there exist a proof of type soundness for haskell?
13:16:53 <vixey> (including data)
13:18:07 <gwern> @quote dave_m
13:18:10 <lambdabot> dave_m says: < Bobstopper> Assuming the universe will eventually die of heat death, counting will cease when that happens. So if you start counting now, you'll probably find the largest number (so
13:18:13 <lambdabot> long as nobody else has found a larger one yet) < Cale> what about faster ways to produce larger numbers? < Bobstopper> not after the heat death you can't :P < dave_m> don't you tell me what I can't
13:18:16 <lambdabot> do after the heat death of the universe
13:19:35 <gwern> @quote sigfpe
13:19:35 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
13:19:35 <lambdabot> thing is.
13:19:55 <gwern> @seen Cale
13:19:55 <lambdabot> Cale is in #haskell, #haskell-overflow, #ghc and #japanese. I last heard Cale speak 2h 16m 13s ago.
13:20:24 <jpcooper> @hoogle (Ord a) => [a] -> a
13:20:26 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
13:20:26 <lambdabot> Prelude.minimum :: Ord a => [a] -> a
13:20:26 <lambdabot> Data.List.maximum :: Ord a => [a] -> a
13:20:34 <gwern> @tell Cale hey, I dumped a bunch of quotes in lambdabot. pls to @flush and push to darcs, k? sos they don be los' like the res'
13:20:34 <lambdabot> Consider it noted.
13:27:58 * shepheb reads the qwe1234 quotes. I hope that was an intentional troll. good lord.
13:29:22 <hubmike2> hey guys is there anyway to edit a tuple if u know its idex?
13:29:34 <hubmike2> any functions that could help me?
13:29:47 <hubmike2> index*
13:29:52 <olsner> heh, qwe1234 says: dynamic typing is *always* a compiler bug.
13:30:18 <hubmike2> well if u know the index for the int your trying to edit
13:30:43 <Twey> hubmike2: 'Edit'?
13:30:47 <Twey> 'Edit'?
13:30:57 <olsner> you mean something like f (a,b,c,d,e) c' = (a,b,c',d,e)?
13:31:35 <hubmike2> well i want to add 1 to a int inside a tuple
13:31:39 <Toxaris> hubmike2: the components of tuples are called, well, components
13:31:47 <hubmike2> lol
13:31:50 <hubmike2> thankyou
13:31:55 <Toxaris> hubmike2: but there is no such function
13:32:01 <hubmike2> ah ok
13:32:05 <shepheb> yes and no
13:32:08 <shepheb> mischan
13:32:24 <Toxaris> hubmike2: there is first and second for pairs aka. two-tuples
13:32:29 <Toxaris> hubmike2: but nothing general
13:32:33 <hubmike2> ok
13:39:11 <Twey> hubmike2: Destructure it
13:40:01 <Twey> oneToThird (a, b, x) = (a, b, x + 1)
13:40:19 <vixey> ommm
13:40:53 <vixey> so "wel typed programs don't go wrong" is just wishful thinking
13:42:43 <therp> vixey: unless the type system is using dependent typing :) (that's not 100% true ..)
13:43:07 <xif> yeah, I've been mostly exercising, and I've already found some cases where it's easy to produce an error
13:43:13 <vixey> by go wrong I meant..
13:43:24 <xif> for example, if you write a function to deal with (x:xs) but not with []
13:43:24 <vixey> data Value a = WRONG | Just a
13:43:35 <vixey> eval :: Program a -> Value a
13:43:41 <xif> you would get a runtime exception.
13:47:20 <Apocalisp> Is there an operation equivalent to shiftL, but for Integers?
13:48:26 <Apocalisp> wondering how you express that arithmetically, anyway
13:48:40 <vixey> @index shiftL
13:48:41 <lambdabot> Data.Bits, Foreign
13:49:25 <vixey> oh
13:49:38 <vixey> so shiftL 0b01101 3 is  0x01101000 ?
13:49:39 <vixey> oops
13:49:44 <vixey> so shiftL 0b01101 3 is  0b01101000 ? *
13:49:59 <Apocalisp> @let shL x y = (x * 2 ^ y)
13:50:08 <lambdabot> Defined.
13:50:09 <Apocalisp> maybe?
13:50:52 <Apocalisp> @check \x y -> shiftL x y == x * 2 ^ y
13:50:53 <lambdabot>  Add a type signature
13:51:07 <Apocalisp> @check \(x::Int) (y::Int) -> shiftL x y == x * 2 ^ y
13:51:07 <lambdabot>  Parse error in pattern at "(y::I..." (column 11)
13:51:25 <vixey> Apocalisp where 0b... means binary
13:52:08 <Apocalisp> @check \x y -> shiftL (x::Int) (y::Int) == x * 2 ^ y
13:52:09 <lambdabot>  Exception: Negative exponent
13:52:39 <Apocalisp> @check \x y -> (x > 0 && y > 0) ==> shiftL (x::Int) (y::Int) == x * 2 ^ y
13:52:40 <lambdabot>  Arguments exhausted after 287 tests.
13:53:11 <olsner> > let shL x y = x * 2^y where (*) = if y > 0 then (*) else (/) in shL 8 -1
13:53:12 <lambdabot>   add an instance declaration for (Num (a -> t))
13:53:35 <Shiruka> ... \bot looks smarter than ghci ...
13:53:58 <byorgey> @type shiftL
13:53:59 <lambdabot> forall a. (Bits a) => a -> Int -> a
13:54:10 <byorgey> Apocalisp: what do you mean, shiftL but for Integers?
13:54:30 <byorgey> Integer is an instance of Bits (I'm pretty sure) so shiftL should work fine on Integers
13:54:44 <byorgey> > shiftL 49 2
13:54:45 <lambdabot>  Add a type signature
13:54:49 <byorgey> > shiftL 49 2 :: Integer
13:54:50 <lambdabot>  196
13:55:20 <olsner> @src Integer shiftL
13:55:20 <lambdabot> Source not found. I am sorry.
13:55:38 <byorgey> or do you mean a shift in base 10?  like  shiftL10 49 2 = 4900 ?
13:55:57 <vixey> @instances Bits
13:55:59 <Shiruka> shiftL works for integers, but the shift amount is int
13:56:02 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
13:56:12 <vixey> @instances-importing Data.Bits Bits
13:56:15 <Shiruka> so no shifting to the left by more than 2^30 bits ;-)
13:56:15 <lambdabot> Int, Integer
13:57:42 <byorgey> haha =)
13:57:53 <Shiruka> Prelude Data.Bits> shiftL (1::Integer) 100
13:57:53 <Shiruka> 1267650600228229401496703205376
13:58:01 <byorgey> > 2^(2^30)
13:58:08 <olsner>    shift x i | i >= 0    = x * 2^i\n     | otherwise = x `div` 2^(-i) -- Data.Bits instance for Integer
13:58:09 <lambdabot> Terminated
13:58:38 <olsner> > shiftL (1::Integer) (2^24)
13:58:42 <lambdabot>  1818585298569738007892771327774990618924859680978940831107811248675816212008...
13:58:52 <olsner> > shiftL (1::Integer) (2^28)
13:59:00 <lambdabot> Terminated
13:59:03 <olsner> > shiftL (1::Integer) (2^26)
13:59:10 <lambdabot> Terminated
13:59:15 <olsner> > shiftL (1::Integer) (2^25)
13:59:25 <lambdabot> Terminated
13:59:34 <hubmike2> anyone gt any idea on increasing a component inside of a tuple but still returning the tuple?
13:59:54 <Shiruka> heh, \bot has strict memory limits
14:00:04 <olsner> > shiftL (1::Integer) (2^24)
14:00:08 <lambdabot>  1818585298569738007892771327774990618924859680978940831107811248675816212008...
14:00:09 <byorgey> hubmike2: sure, take the tuple apart with pattern-matching then put it back together.
14:00:18 <byorgey> e.g. incsnd (a,b) = (a,b+1)
14:00:19 <hubmike2> ok
14:00:39 <byorgey> hubmike2: there are also ways to get fancier if you like
14:00:46 <byorgey> for example using 'second' from Control.Arrow
14:00:51 <byorgey> > second (*4) (1,3)
14:00:54 <lambdabot>  (1,12)
14:00:57 <byorgey> or 'first'
14:01:34 <byorgey> hubmike2: does that help?
14:02:39 <Shiruka> or write incNth with TH ;-)
14:03:09 <byorgey> haha
14:04:09 <hubmike2> ill  hpaste it
14:04:21 <hubmike2> nt working as i thought it would
14:04:45 <byorgey> ok
14:05:13 * BMeph shakes his fist at Apocalisp
14:05:44 <hml> i'm trying to use  harpy; but it loks like I need template haskell: http://www.haskell.org/th/ ... however, how do I install this?
14:05:44 <lambdabot> Title: Template Haskell
14:06:05 * BMeph hopes that GHCi will quit printing out "shiftL (1::Integer) (2^28) sometime in the hour...
14:06:27 <hubmike2> http://hpaste.org/9143
14:06:44 <hubmike2> basically its the addsale function
14:07:25 <mightybyte> Uh oh: "ghc-6.8.2: panic! (the 'impossible' happened)"
14:07:33 <mightybyte> "  (GHC version 6.8.2 for x86_64-unknown-linux):"
14:07:38 <byorgey> hubmike2: well, your type signature says that addSales takes an argument of type Sales
14:07:41 <mightybyte> "        Prelude.head: empty list"
14:07:45 <byorgey> which is a list of tuples
14:08:00 <byorgey> but the definition of addSales pattern-matches on a tuple, not a list
14:08:14 <hubmike2> ok
14:08:18 <BMeph> hubmike2: ... never mind, byorgey said it first. :)
14:08:30 <byorgey> hubmike2: in words, what is addSale supposed to do?
14:08:31 <lilachaze> hubmike2: you might want to add a type for your 3-tuple
14:09:11 <byorgey> well, that's a separate issue
14:09:27 <lilachaze> it'd make specifying the type of addSale much easier :)
14:09:29 <byorgey> hubmike2: I'd say see if you can get it working this way first
14:09:36 <byorgey> well, that's true =)
14:10:08 <byorgey> lilachaze: so you mean something like  data SaleInfo = SI Artist SongTitle SalesTotal ?
14:10:08 <hubmike2> well add sale was just supposed to increment the total sales by 1
14:10:17 <byorgey> hubmike2: the total sales for what?
14:10:32 <byorgey> for a particular song?
14:11:01 <hubmike2> a particular sale that would be inputted
14:11:37 <byorgey> hubmike2: well, it seems to me that you need two things: (1) a function to take a particular song record (3-tuple) and add a sale
14:11:38 <hubmike2> i was going to use a recursive call to find the tuple in the list then take it and increment the salevalue
14:11:53 <hubmike2> yeah
14:12:02 <byorgey> (2) a function which, given a particular song title, will find it in the list and return a new list with another sale recorded for that song
14:12:03 <tromp> @hoogle suffle
14:12:03 <lambdabot> No matches found
14:12:07 <tromp> @hoogle shuffle
14:12:07 <lambdabot> No matches found
14:12:33 <hubmike2> yeah basically exactly what ive been trying to do
14:12:35 <byorgey> hubmike2: ok, so addSale is (1).  the implementation looks fine but the type is incorrect.
14:12:44 <hubmike2> ok
14:13:00 <byorgey> do you see why?
14:13:11 <BMeph> lilachaze: <cough> "Sales" <cough>
14:13:24 <BMeph> Pardon, must be a summer cold... ;)
14:13:28 <hubmike2> lol
14:13:32 <hml> how do I install template haskell?
14:13:46 <byorgey> hml: what platform?
14:14:42 <hml>  byorgey linux x86_64
14:15:26 <byorgey> hml: ok, what distro?  your distro may have a TH package
14:15:48 <Twey> I thought it was built-in to GHC6?
14:15:59 <byorgey> oh, maybe it is...
14:16:13 <hml> oh wait
14:16:17 <byorgey> hml: are you sure it's not already installed?  try typing 'ghc-pkg list' at a prompt and see if TH is listed
14:16:19 <hml> it's -XTemplateHaskell
14:16:26 <hml> maybe that's why i couldn't find installatino instructions online
14:16:29 <Twey> Heheh
14:16:33 <Twey> You silly bananas
14:16:33 <byorgey> hehe, perhaps =)
14:16:35 <Shiruka> BMeph: it should take a while, as (1<<(1<<28)) should have almost 81 megadigits :-)
14:16:38 <Twey> *shakas his head*
14:16:41 <Apocalisp> > shiftL (1::Integer) ((2^24)::Integer)
14:16:45 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
14:16:50 <byorgey> megadigits!
14:16:55 <vixey> oh why I didn't think of it earlier
14:17:36 <Apocalisp> > shiftL (1::Integer) (fromInteger (2::Integer))
14:17:37 <byorgey> > (2^28) * (log 2)/(log 10)
14:17:39 <lambdabot>  4
14:17:39 <lambdabot>  8.08071241557388e7
14:17:48 <Apocalisp> fromInteger it is, then
14:18:44 <Shiruka> byorgey: no fair revealing my deeply secret elementary math formulas :-(
14:19:06 <byorgey> Shiruka: oops, sorry =)
14:19:07 <bran_> does anyone have any examples of cabal scripts that build dependent .x (alex) or .y (happy) files?
14:19:12 <Shiruka> :-)
14:19:49 <hml> Twey byorgey : got it all instlaled and i tworks; thanks
14:20:00 <byorgey> hml: great!
14:20:11 <Twey> hml: Cool :-)
14:20:15 <hml> anyone here familiar3 with Harpy on  x86_64? i've just ran through the tutorial, and the factorial code just seg faults
14:20:51 <jpcooper> head . sortBy (on compare snd) <-- how could I write that in a nicer way?
14:21:19 <Twey> on?
14:21:31 <vixey> compare `on` second
14:21:32 <jpcooper> Data.Function.On
14:21:36 <vixey> comparing second
14:21:44 <jpcooper> can I write it without parens?
14:21:48 <vixey> maximumBy snd
14:21:52 <Twey> @src on
14:21:52 <lambdabot> (*) `on` f = \x y -> f x * f y
14:22:14 <Twey> Oh I see.
14:22:40 <dcoutts_> bran_: yep, all you need to do is list the module in exposed-modules or other-modules
14:23:01 <dcoutts_> bran_: you have to list every module in one of those two fields anyway
14:23:42 <byorgey> @type maximumBy
14:23:42 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
14:23:56 <byorgey> @type maximumBy (comparing snd)
14:23:57 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
14:24:12 <jpcooper> okay, how can I just take the parens away?
14:24:21 <byorgey> maximumBy $ comparing snd
14:24:41 <byorgey> I think with  'head . sortBy (compare `on` snd)' there's no way to write it without parens
14:24:46 <guenni> btw: working on my 1st rl haskell app, it is *so* cool, it actually works :)
14:24:47 <vixey> why do you want to take them away
14:25:05 <byorgey> short of defining your own operators with precedences defined in such a way that you can write that expression without parens ;)
14:25:20 <byorgey> guenni: congrats! =)
14:26:15 <guenni> byorgey: thx
14:28:00 <bran_> dcoutts_: thanks, i'll try that
14:28:33 <dcoutts_> bran_: just remember to always list every module and you'll be fine.
14:34:52 <Benigno> byez
14:34:55 <BMeph> jpcooper, byorgey: If your heart's set on making it look a certain way, you could write your own shows, but I don't think that's the issue. :)
14:35:35 <xci> how should one keep track of visited indexes in haskell when implementing a dfs
14:35:40 <vixey> :t ((*) .) . (2^)
14:35:41 <lambdabot> forall a (f :: * -> *) b. (Integral b, Num (f a), Functor f, Num a) => b -> f (a -> a)
14:35:49 <xci> of course to maintain efficiency
14:35:53 <vixey> xci: depth first search ?
14:35:59 <xci> vixey: exactly
14:36:11 <vixey> xci: what are you traversing?
14:36:17 <vixey> what data structure
14:36:28 <Japsu> Mui. xci
14:36:54 <xci> well, I just thought about coding a dfs as an exercise - some random directed graph
14:36:58 <seliopou> that type is awesome
14:36:58 <xci> Mui. Japsu
14:37:27 <vixey> xci: may it contain cycles?
14:37:34 <BMeph> xci: Do you specifically want the indices, or are you trying to dictate how to do the traversal? :)
14:37:51 * vixey feels like an expert system
14:37:56 <vixey> :S
14:38:06 <byorgey> xci: well, the best way I know of is just to pass a list of visited indices along with your recursive calls
14:38:11 <byorgey> xci: or, better, a Set
14:38:13 <xci> well, basically my problem is that I want to have a replacement for a boolean array that I would use in C
14:38:17 <vixey> "perhaps it's a gas leak in the third cylinder"
14:38:22 <byorgey> then you have to test for membership every time you go to visit a new node
14:38:23 <Japsu> xci: Data.Set
14:38:34 <byorgey> so it adds a factor of O(lg n), which isn't too bad
14:38:39 <BMeph> vixey: Not until you find yourself going, "State the nature of the Haskell emergency," should you feel so. ;)
14:38:39 <byorgey> although it's not optimal of course
14:38:51 <xci> yeah
14:38:51 <vixey> hehe
14:39:22 <Shiruka> BMeph: sounds strangely familiar, but I can't for life of me figure out why..
14:39:39 <BMeph> Shiruka: s/Haskell/medical/ ...
14:39:42 <byorgey> xci: this is a pretty common thing, actually, to have a pure functional implementation of an algorithm add a factor of O(lg n) over an imperative solution.
14:39:54 <xci> well, that is definitely not too bad, though I've always felt a bit uncomfortable with haskell since I am often not able to see the way to implement something in the most efficient way, though otherwise I think haskell is very cool
14:39:57 <byorgey> xci: in many cases, it's not as big of a deal as you'd think.
14:40:26 <Shiruka> ah, star trek again..
14:40:27 <byorgey> xci: and in the case where it really does make a difference, you can use somthing like IORefs, or the ST monad to achieve true mutable data
14:40:34 <xci> but that has been just a barrier in mind for me, but I think it would be time to overcome it
14:40:35 <vixey> the most efficient way isn't usually the goal
14:40:36 <Shiruka> too long since I last watched it :-)
14:40:38 <Japsu> xci: you _can_ make a mutable boolean array in Haskell, too
14:40:43 <Japsu> that's not a wery Haskellish way, though
14:40:45 <BMeph> xci: What I meant to say, is that you don't have to check off indices from a list, to make sure that you get all of the nodes out. :)
14:41:23 <BMeph> Shiruka: "Everything I ever needed to know, I learned from /Star Trek/" ;)
14:41:24 <Japsu> there's Data.Array (IIRC) for arrays with O(1) access
14:41:35 <xci> Japsu: okay :o
14:41:51 <pejo> xci, purely functional data structures by Okasaki is a nice read. If you don't want to buy the book I think his thesis is avialable online for free somewhere.
14:41:51 <vixey> xci, would seing dfs code for data Tree a = Leaf a | Branch (Tree a) (Tree a) help?
14:41:52 <xci> but I think Data.Set will do this time
14:41:53 <byorgey> xci: just to give an example, in the recent ICFP programming competition Cale implemented an A* search algorithm which did exactly this (pass a set of visited indices along with the recursive calls)
14:42:12 <byorgey> xci: but it was quite fast
14:42:26 <Shiruka> there's also IntSet
14:42:41 <byorgey> xci: it did searches on graphs with hundreds of nodes fast enough that we could call it many times a second and it didn't slow anything down.
14:43:24 <Shiruka> (not sure if it's faster than Set in general for ints though, the notable feature was supposed to be fast union IIRC :-)
14:44:02 <xci> byorgey: yeah I know that, but my problem is that I have corrupted my mind with competitive algorithmic coding and I have a problem to code anything that is asymptotically ineffective
14:44:28 <byorgey> xci: I totally understand, I used to think that way too =)
14:44:41 <Shiruka> when thinking of asymptotical complexities for n < 2^32, round O(log(n)) terms to O(1) ;-)
14:44:58 <xci> so I would probably use even set for storing 20 items, because 'linear search is so damn slow'
14:45:01 <byorgey> xci: there's still a place for that, but I have come to realize that it's often overemphasized
14:45:09 <xci> yeah, definitely
14:45:58 <byorgey> so I have trained myself now to just implement the simple, obvious, elegant solution, and only if it is too slow do I start thinking about clever ways to improve the asymptotic complexity
14:46:07 <xci> vixey: that would probably be a nice read too, if you have some link to that code
14:46:08 <byorgey> 85% of the time, my first implementation works just fine
14:46:15 <Shiruka> (only half-kidding - if n is limited by memory size as it is in data structures, then log n is effectively a smallish constant)
14:46:18 <pejo> xci, with very few items the linear search can be faster than a binary search.
14:46:26 <vixey> dfs :: Tree a -> [a]
14:46:28 <xci> pejo: yeah I know :)
14:46:30 <vixey> dfs (Leaf x) = [x]
14:46:36 <Japsu> xci: once you've worked out your own implementation or "died trying", you'll probably want to check Google Scholar on "haskell dfs". I found a paper by by King & Launchbury that touts a linear-time DFS in haskell
14:46:41 <vixey> dfs (Branch l r) = dfs l ++ dfs r
14:47:02 <vixey> xci, looks wrong doesn't it? :)))
14:47:16 <vixey> xci, the key is that haskell is lazy, so this really is a depth first search
14:47:33 <xci> yeah that is cool
14:48:00 <vixey> i.e. find (somePredicate) (dfs t) will only traverse down the first bit of the left branches until it finds the first element
14:48:23 <vixey> you can convert it to CPS and pass state along.. or use a monad to do this manually
14:48:31 <vixey> if you have to book keep with some mutable state
14:48:41 <vixey> s/manually/automatically/
14:49:02 <xci> my problem with haskell is that I find it very cool, I've read relatively much about it to be such a beginner I am, but I have wrote haskell like 150 lines in my life :/
14:49:15 <dons> xci: time to write!
14:49:20 <xci> dons: yeah
14:49:32 <dons> grab something from hackage.haskell.org that you like and use it.
14:49:37 <Shiruka> xci: heh, I also have read a lot about haskell compared to the amount of code I've written in it.. :-)
14:49:57 <dons> time to write!
14:50:12 <Shiruka> I've probably read over half of all papers SPJ has published related to haskell..
14:52:17 <dons> less reading, more writing!
14:52:47 <dons> write a new apache, build a jabber server, build a lambdabot replacement.
14:52:50 <dons> something!
14:52:51 <Shiruka> too many interesting papers! you're also one culprit with your stream fusions and all
14:56:19 <Shiruka> I've been thinking about writing a program that plays Go though
14:56:32 <vixey> cool
14:56:40 <Japsu> yay for programs that play go
14:56:45 <Shiruka> in a "doesn't matter if it's a bit slow as long as the code looks nice" style
14:57:11 <vixey> could I learn to play go reading your code?
14:57:13 <Japsu> slow? like (19^2)! slow? ^___^
14:57:40 <Shiruka> being competitive would probably require a wholly different style (and maybe writing it in C anyway), but as far as I'm concerned that's not really interesting, that would be grunt work instead of fun :-)
14:57:43 <Japsu> > let fac n = product [1 .. n] in fac (19 * 19)
14:57:46 <lambdabot>  1437923258884890654832362511499863354754907538644755876127282765299227795534...
14:58:09 <gwern> @quote sarah
14:58:09 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
14:58:15 <Japsu> ;P
14:58:18 <hml> anyone have harpy working on x86_64?
14:58:32 <vixey> how is go like functional programming?
14:58:35 <Shiruka> vixey: programs suck at go anyway :-)
14:58:54 <vixey> they are a lot better than me at it, I don't even know the rules
14:58:55 * Japsu also sucks at go
14:59:04 * Shiruka is 2 dan
14:59:05 <Japsu> (16 kyu)
14:59:14 * cjb 1 dan
14:59:15 <BMeph> dons Do you know of a good reference for getting a handle on backtracking, and using lists for it? I want to rewrite my work-up of the UD code module, and I feel like I'm missing something obvious.
14:59:25 <gwern> Shiruka: brag why doncha
14:59:31 <vixey> BMeph: what is UD?
14:59:45 <Japsu> seeing the word "backtracking" makes me yell "LIST MONAD!!!"
14:59:51 <BMeph> vixey: UD is uniquely-decodeable
15:00:13 <Japsu> meh
15:00:20 * Japsu needs to write some haskell again some day
15:00:26 <Japsu> it's been a little quiet at that front.
15:00:32 <xci> go AIs are quite interesting
15:00:43 <cjb> s/interesting/awful/
15:00:43 <xci> though we are now writing a chess bot
15:01:28 <Shiruka> interesting as a CS problem
15:01:30 * vixey has a look at this udcode program
15:01:31 <Dr_Foo> holy carp look at the time
15:01:38 <Trinithis> does anyone know if a Haskell Double can hold ANY Javascript number? (Excluding NaN and Infinity)
15:01:39 <Dr_Foo> i still need to iron my waistcoat
15:01:48 <cjb> Shiruka: or perhaps rather an AI problem
15:02:05 <cjb> I guess I don't believe we're going to get computers good at Go just by applying CS algorithms
15:02:06 <Shiruka> especially as the best no longer are of the "using a million hand-crafted rules" form
15:02:21 <Shiruka> (or hand-crafted submodules)
15:02:30 <dons> Trinithis: Double is a machine Double
15:02:36 <dons> Trinithis: what is a JavaScript number?
15:02:41 <Trinithis> 64bit
15:02:44 <xci> hmm, many programmers are familiar with go, but is anyone here chess-oriented?
15:02:49 <dons> an arbitrary precision floating piont value?
15:02:54 <Trinithis> yes
15:02:58 <cjb> xci: most Go players played chess before Go.
15:03:01 <dons> but of fixed size.
15:03:04 <Trinithis> yes
15:03:07 * Shiruka didn't
15:03:09 <dons> so not arbitrary precision :(
15:03:11 <dons> :)
15:03:17 <cjb> well, ok, I did :)
15:03:18 <Trinithis> oh. I misrtead
15:03:23 <Trinithis> it is FIXED
15:03:26 <dons> Trinithis: then yeah, I'd imagine Double is just fine.
15:03:29 <Trinithis> Ok
15:03:31 <dons> > maxBound :: Double
15:03:32 <lambdabot>   add an instance declaration for (Bounded Double)
15:03:32 <lambdabot>     In the expression: max...
15:03:36 <dons> oh right
15:03:52 <Trinithis> To be safe, are there things like DoubleXX?
15:03:52 <cdfh> xci: i play a fair bit of chess, but not Go
15:05:17 <vixey> BMeph, huh this is interesting
15:05:31 <hubmike2> oh dear another question if anyone is still up
15:05:33 <hubmike2> lol
15:05:56 <EvilTerran> go on, then. no need to ask to ask
15:06:39 <hubmike2> if i have a tuple but i have changed its values
15:07:08 <hubmike2> now i want to put it back into a list of tuple where i orginally gt it from
15:07:14 <hubmike2> make sense?
15:07:18 <xci> it has always irritated me how much dedication it takes to get to dan-levels in go compared to something like 2000-level in chess, does anyone have any first-hand experience on this?
15:07:24 <vixey> at the same place where it was taken from?
15:07:36 <cdfh> reconstructing the list is the normal solution, i think
15:07:44 <hubmike2> yeah say ive just 'edited' it
15:08:00 <RayNbow> @seen roconnor
15:08:00 <lambdabot> I saw roconnor leaving #haskell 18h 6m 58s ago, and .
15:10:16 <Shiruka> xci: dunno, I'm a pretty casual player myself.. you get to the dans eventually by just playing :-/ hard to compare as my level in chess is "I remember most of the rules!"
15:12:31 <cjb> yeah, I'm sure I wouldn't have got far if I hadn't been bored in college when I learnt how to play
15:12:45 * cjb barely has time for a game a week on KGS lately
15:14:38 <xci> well, I am 2000+ -level in chess, and after reaching that I started playing go from scratch, and after something like 20 games my rating in KGS is 15 kyu, but I suspect I am quite much worse than that - anyway, I can make no comparing either :<
15:15:15 <cjb> xci: there's a Go proverb:  "lose your first 500 games as quickly as possible"
15:15:40 <cjb> it's really hard to know what to do with the influence of the board without just playing a lot and trying many different styles
15:15:44 <xci> yeah I am aware of those - however, I rather spend my time on coding or sleeping than on board games atm
15:15:49 <cjb> makes sense :)
15:16:00 <Shiruka> :-)
15:17:07 <Shiruka> I'm on vacation myself and haven't done anything useful at all lately
15:17:21 <Shiruka> eating, sleeping, solving Project Euler problems in Haskell
15:20:56 <tusho> hskll
15:23:00 <pejo> tusho, let me help! aouå eiyäö
15:23:22 <tusho> pj: thx. wll pt thm t gd s.
15:24:04 <tusho> ah that's better
15:24:12 <Shiruka> he'll run out very soon that way
15:24:14 <tusho> i am so grateful, pejo. I'll never forget you.
15:24:22 <tusho> crp. th're ll gn.
15:24:30 <tusho> sm mr pls?
15:24:35 <Shiruka> replicate 31415926535 "aouÃ¥eiyÃ¤Ã¶"
15:24:52 <vixey> 31415926536 *
15:25:01 <tusho> *MANY YEARS LATER*
15:25:07 <tusho> mr pls
15:25:34 <Shiruka> oh very well, cycle "aouÃ¥eiyÃ¤Ã¶"
15:25:50 * universe crashes due to INFINITENESS
15:26:33 <EvilTerran> this is a lazy universe!
15:26:57 <tusho> EvilTerran: i wish
15:27:44 <Shiruka> lazy it is, keeping things in superpositioned thunks until forced
15:28:21 <tusho> hm true
15:28:27 <tusho> even so
15:28:30 <tusho> infinite vowels? :P
15:29:02 <Shiruka> no need to buy any vowels :-)
15:30:04 <vixey> hmmm
15:30:10 <vixey> I should stop using zsh and use something else
15:30:14 <vixey> but what?
15:30:18 <tusho> vixey: why
15:30:18 <Shiruka> bash
15:30:20 <tusho> zsh is awesome
15:30:25 <vixey> I've already done bash
15:30:28 <tusho> Shiruka: oh puh-leez
15:30:35 <tusho> vixey: check out fish
15:30:39 <Dr_Foo> < tusho> infinite bowels? :P
15:30:40 <tusho> it's 'different' but nice lookin
15:30:41 <tusho> g
15:30:47 <tusho> Dr_Foo: got that.
15:31:30 <tusho> vixey: http://www.google.co.uk/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.fishshell.org%2F&ei=vQKJSLnzB4mkQe-QndsM&usg=AFQjCNG1_MX572H-qD0-5qOGC5MFM1n57w&sig2=HMJlGEpJJndiPoIqrhSu5A
15:31:32 <lambdabot> Title: fish, http://tinyurl.com/5er3ur
15:31:32 <tusho> err
15:31:33 <tusho> fishshell.org
15:32:02 <tusho> but yeah, it fixes things like spaces in variables and stuff
15:32:08 <dmhouse> Woah, someone did the ICFP contest in TeX.
15:32:49 <tusho> dmhouse: Hello, welcome to 19th ;)
15:33:37 <dmhouse> Yeah, sorry, catching up.
15:33:42 <dmhouse> It's still amazing five days later.
15:33:51 <tusho> *the 19th, I should say
15:35:39 <Shiruka> it was quite amazing indeed
15:35:54 <hubmike2> sorry to bother you all
15:36:02 <Shiruka> hard to imagine anyone willingly using a programming language less suited to general-purpose programming
15:36:10 <hubmike2> but is there anything wrong with this line of code
15:36:11 <Shiruka> except possibly a few who have a fetish for COBOL
15:36:27 <dmhouse> There was a tetris written in sed a few days ago
15:36:36 <dmhouse> *on reddit a few days ago
15:36:52 <hubmike2> recordSale sales a t |artistTitleSearch sales a t /= [] = addlists $ artistTitleSearch sales a t
15:37:21 <hubmike2> maybe i shud hpaste
15:38:48 <Baughn> @pl \n -> case n of 1 -> 2; 2 -> 3; 3 -> 4 -- And so on
15:38:48 <lambdabot> (line 1, column 19):
15:38:48 <lambdabot> unexpected ">" or "-"
15:38:48 <lambdabot> expecting variable, "(", operator or end of input
15:40:11 <Shiruka> something wrong with (+1)?
15:40:34 <Baughn> Nah. I was just hoping there was some simplified syntax for \x -> case x in there.
15:43:56 <olsner> there's a haskellprime proposal for a "case of  ..." syntax sugar for \x -> case x of
15:44:26 <Baughn> It'd be useful
15:45:21 <Trinithis> olsner: do you know what the proposed syntax is?
15:45:57 <olsner> case of Foo -> Bar; Baz -> Quux -- etc
15:46:00 <olsner> iirc
15:46:12 <BMeph> hubmike2: Just FYI, but you could "annotate" your earlier hpaste. :)
16:01:57 <tusho> @. yow vixen
16:01:59 <lambdabot> Couldn't find fortune file
16:02:02 <tusho> :(((((((((
16:05:11 <tusho> @. vixen yow
16:05:11 <lambdabot> Ok
16:05:15 <tusho> ..
16:05:17 <tusho> @. vixen yow
16:05:17 <lambdabot> amuse me please! (and don't ask
16:05:24 <tusho> wonder which way it should be
16:06:56 <tusho> asdasd++
16:07:05 <tusho> ()++
16:07:21 <tusho> (a b)++
16:07:32 <tusho> Hm.
16:07:35 <tusho> That increments b)'s karma.
16:08:30 <sarehuu> better than incrementing a list
16:08:44 <tusho> sarehuu: that should increment 'a b'
16:09:24 <sarehuu> returning 'a c'?
16:10:13 <olsner> @yow
16:10:13 <lambdabot> Couldn't find fortune file
16:11:05 <olsner> @quote
16:11:05 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
16:11:22 <lilachaze> > (\tusho -> tusho++ "more karma") "who wants "
16:11:25 <lambdabot>  "who wants more karma"
16:11:41 <tusho> heh
16:11:43 <tusho> > "tusho++"
16:11:44 <lambdabot>  "tusho++"
16:11:46 <tusho> @karma tusho
16:11:46 <lambdabot> You have a karma of 1
16:11:48 <tusho> > "tusho++"
16:11:49 <lambdabot>  "tusho++"
16:11:52 <tusho> @karma tusho
16:11:52 <lambdabot> You have a karma of 1
16:11:53 <tusho> Aw
16:12:00 <lilachaze> need another bot :)
16:15:03 <phlpp_> :_
16:15:13 <Shiruka> > let (c, lisp) = ("c", "lisp") in c++ lisp
16:15:14 <lambdabot>  "clisp"
16:15:30 <tusho> @karma c
16:15:30 <lambdabot> c has a karma of 0
16:15:39 <mar77a> @karma C
16:15:39 <lambdabot> C has a karma of 0
16:15:40 <tusho> hahaha
16:15:41 <tusho> think about it
16:15:42 <tusho> c--
16:15:44 <tusho> :)
16:15:50 <EvilTerran> @karma c
16:15:50 <lambdabot> c has a karma of 0
16:16:02 <tusho> So have there been any developments on c-- recently? I'm interested guys, is c-- development ongoing?
16:17:11 <dons> win 2
16:18:59 <tusho> dons: lose 7
16:19:02 <tusho> mornington crescent
16:20:35 <pejo> tusho, Norman Ramsey recently updated his homepage
16:20:48 <tusho> pejo: thanks?
16:21:43 <tusho> pejo: and?
16:22:36 <hubmike2> ok guys for some reason hpaste hates me atm
16:22:47 <hubmike2> but whats guy wrong with this code
16:22:49 <hubmike2> http://www.geocities.com/mikehub34/CWFunctions.txt
16:22:55 <cjb> hubmike2: codepad.org
16:23:36 <hubmike2> its there if u lot want to take a look ill use codepad next time
16:23:44 <pejo> tusho, look at the publications on www.cminusminus.org, he shows up fairly frequently there.
16:24:00 <tusho> pejo: fail. look at my messages before that
16:24:00 <tusho> ;)
16:24:06 <tusho> i was abusing lambdabot's karma
16:24:06 <hubmike2> getting some errors from hugs
16:24:35 <hubmike2> any ideas?
16:27:08 <hubmike2> ill put it in codepad if anyone will prefere it
16:28:23 <Shiruka> type annotation of addlists is wrong, SongRecord meant to be the first argument instead?
16:31:30 <BMeph> hubmike2: Not sure if you're aware of it, but the t and a (heh-heh) in your helper functions for find are different from the t and a used in your __Search function arguments.
16:33:19 <Shiruka> ... and a and t aren't even used in addlists
16:33:56 <lilachaze> hubmike2: in recordSale, "[artistTitleSearch sales a t] /= []" will always be true
16:34:22 <BMeph> hubmike2: Yeah, it looks like you started to re-factor/transform addlists, and stopped in the middle of it.
16:35:06 * matthew-_ celebrates now being able to build perf ghc 683 with extra libs in just 22m24.604s
16:35:51 <dons> on what box?
16:35:57 <dons> that's pretty good for a perf build.
16:37:05 <matthew-_> q9450, 4GB
16:38:55 <matthew-_> with make -j4
16:40:42 <matthew-_> which reminds me, is there anyway of making ghc do parallel builds? I'm thinking of with the old dependencies and using make, you could pass -j args, but that seems to have been lost with ghc --make
16:42:41 <Saizan_> matthew-_: after my gsoc project that should be available via cabal
16:43:10 <pejo> Saizan, your gsoc project is to replace ghc --make with a library?
16:43:46 <Saizan_> dependency analysis and incremental builds for Cabal, yep
16:43:52 <Saizan_> +parallel
16:43:56 <matthew-_> cool
16:44:08 <matthew-_> is that being merged in time for 6.10?
16:44:26 <Saizan_> when is 6.10?
16:44:40 <pejo> Around ICFP is the mentioned date.
16:45:06 <matthew-_> anyone know why I would be getting this from cabal update? cabal: Failed to download index 'ErrorMisc "Invalid HTTP code: (5,0,2)"'
16:45:39 <BMeph> hubmike2: It looks like you want to use "maybeToList" instead of "fromJust", among other things. See http://hpaste.org/9143#a2 for my guess at your intent. :)
16:47:19 <Saizan_> so end of september? i wouldn't bet on it, however you can update Cabal indipendently
16:54:53 <hml> s
16:55:20 <sebaseba> @quote
16:55:20 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
16:55:30 <dcoutts> matthew-_: http error 502 hmm.
16:55:41 <dcoutts> 502 Bad Gateway
16:55:41 <dcoutts> The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request.
16:56:12 <dcoutts> matthew-_: is it repeatable? are you going via an http proxy server?
16:56:17 <matthew-_> dcoutts: oh! sorry, it's orange's fault
16:56:24 <matthew-_> they probably think you're serving porn
16:56:28 <dcoutts> hah
16:56:37 <matthew-_> I've forgottern to start up my proxy ;)
16:56:37 <dcoutts> I wonder why they'd think that
16:56:46 <matthew-_> orange do strange things
16:56:50 <dcoutts> clearly
16:57:08 <Shiruka> heh, "choose the right fold" didn't meant what I thought it advocated on first sight ("choose foldr!")
16:57:26 <Shiruka> reminds me of the axiom of choice not being the preferred axiom after all..
16:58:08 <matthew-_> dcoutts: does cabal obey HTTP_PROXY env vars?
16:59:00 <Corun> matthew-_
16:59:03 <Corun> The invasion is near
16:59:07 <Corun> (We start UROP on monday)
16:59:20 <matthew-_> Corun: don't think I'm letting you in my office
16:59:27 <matthew-_> ;)
16:59:28 <Corun> You have a key? ;-)
16:59:39 <matthew-_> Corun: yes
16:59:45 <Corun> Oh
16:59:48 <Corun> Well
17:00:04 <Corun> You're gonna lock it? ;-)
17:00:31 <matthew-_> seriously, where are you meant to be working / who's your supervisor?
17:00:45 <Corun> I'm sure I've told you before
17:00:58 <matthew-_> Corun: I drink. Thus I forget things.
17:00:59 <Corun> With Julie McCann
17:01:16 <Corun> Doing _something_ involving writing C
17:04:50 <hml> how can I convert (*) from Int -> Int -> Int to (Int, Int) -> Int
17:05:02 <dobblego> @type uncurry
17:05:05 <EvilTerran> ?src uncurry
17:05:07 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
17:05:07 <lambdabot> uncurry f p = f (fst p) (snd p)
17:05:13 <dobblego> @type uncurry (*)
17:05:14 <lambdabot> forall a. (Num a) => (a, a) -> a
17:06:13 <matthew-_> woot, cabal clearly does understand HTTP_PROXY env vars
17:11:16 <matthew-_> it really is a shame type checking isn't parallel. My Tests file for sessions still takes nearly 2 mins to type check on this uber new machine
17:16:46 <dons> have you read that parallel STM-based type checker for chameleon?
17:18:56 <matthew-_> nope
17:19:18 <hml> @hoogle permute
17:19:19 <lambdabot> Text.ParserCombinators.Parsec.Perm.permute :: PermParser tok st a -> GenParser tok st a
17:19:19 <lambdabot> System.Console.GetOpt.Permute :: ArgOrder a
17:20:42 <Shiruka> it has types so vast and intricate that slaying them requires hordes of CPUs? :-O
17:35:14 <TEH_REPREGNAT0R> is there a way to import modules when using ghc -e ?
17:35:45 <TEH_REPREGNAT0R> like if i want to do ghc -e 'randomIO >>= print' or similar
17:39:45 <vixey> :m + Control.Monad
17:40:05 <TEH_REPREGNAT0R> vixey but i'm not using ghci..
17:40:17 <vixey> oh sorry I misread
17:41:59 <TEH_REPREGNAT0R> hah
17:42:07 <TEH_REPREGNAT0R> -e ":m + Random" -e "the rest"
17:42:09 <TEH_REPREGNAT0R> thanks!
17:42:43 <nornagon> @seen dcoutts
17:42:43 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 45m 53s ago.
17:42:58 <TEH_REPREGNAT0R> actually, that doesn't appear to work :(
17:43:01 <TEH_REPREGNAT0R> boo
17:43:17 <hubmike2> hey guys
17:43:36 <hubmike2> wonder if u can see where i am going wrong with find
17:43:38 <hubmike2> http://hpaste.org/9145#a1
17:44:33 <hubmike2> any help most welcome :D
17:44:34 <nornagon> newtype Cairo = Cairo (Ptr (Cairo)) -- i really can't get my head around how this is supposed to work :)
17:44:43 <BMeph> hubmike2:  Your tuples are of Ints. "A" is a String. Strings arae not Ints.
17:44:59 <nornagon> (generated from a c2hs incantation: {#pointer *cairo_t as Cairo newtype#}
17:45:53 <hubmike2> ok so change the "A" to an A
17:46:41 <BMeph> hubmike2: Also, you should get out of the habit of using helper functions whose argument components are the same as your top-level function arguments/components.
17:46:57 <hubmike2> but now gt a error saying A is a Undefined data constructor "A"
17:47:10 <hubmike2> ok
17:47:23 <BMeph> They're not the same variable, and you're in danger of confusing folks as to which 'a' you mean. :)
17:47:48 <hubmike2> I actually need to find a string within one of the truple for my work
17:47:58 <kpreid> not only that, they *need* to be different to do what you probably want...
17:48:04 <kpreid> hubmike2: but your tuple is all Ints
17:48:30 <hubmike2> i know i changed them around just to get them to work with something else
17:48:39 <hubmike2> ill show u my actaul code
17:48:46 <kpreid> I would guess you actually want:
17:49:08 <kpreid> artistSearch sales ar = find(\(a,_,_) -> ar == a) sales
17:51:25 <hubmike2> http://hpaste.org/9145#a2
17:51:39 <hubmike2> thats what ive gt so far
17:51:46 <hubmike2> but i cant make it work
17:52:40 <dmwit> s/sales/sb/
17:52:46 <dmwit> :t find
17:52:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:52:53 <Shiruka> kpreid, artistSearch ar = find (\(a,_,_) -> a == ar) would be closer to pointlessness :-)
17:53:04 <hubmike2> lol
17:53:07 <dmwit> hubmike2: Also, the type should be [S] -> String -> S.
17:53:12 <kpreid> Shiruka: one thing at a time!
17:53:22 <kpreid> dmwit: no, S is a list...
17:53:24 <hubmike2> lol
17:53:34 <hubmike2> yeah shudnt b [S]
17:53:36 <dmwit> hubmike2: Then, it should be S -> String -> Sm.
17:53:40 <BMeph> dmwit: S is the list type. :)
17:53:59 <dmwit> hubmike2: Or, leave off the type and see what GHC infers for you. ;-)
17:54:11 <BMeph> S "should' just be defined as [Sm], though. :)
17:54:25 <hubmike2> yes sorry i see that now
17:56:00 <dmwit> BMeph: Yeah, well, S "should" have a more descriptive name. =)
17:56:12 <BMeph> Also, be warned: if find returns Nothing, then fromJust will throw a fit^w exception.
17:56:23 <hubmike2> lol
17:56:34 <BMeph> dmwit: It does, hubmike2's just trying to simplify what he's already written. :)
17:56:36 <hubmike2> very true BMeph
17:57:00 <Shiruka> sometimes I think there is no justice in the world when a pointless definition happens to be longer and harder to understand than an Obviously(TM) less beautiful pointful definition :-<
17:58:45 <kpreid> Shiruka: have you tried a concatenative language?
17:59:02 <hubmike2> im not sure why but its throwing an exc all the time
17:59:11 <Shiruka> hehe, no, but I've seen some forth code somewhere sometime
17:59:23 <BMeph> kpreid: Heh-heh, I was just going to say something about Forth - you stole my thunder! ;p
17:59:25 <kpreid> Shiruka: you should try Factor. they're all about the combinators
17:59:29 <hubmike2> even if the two match
17:59:32 <chrisdon1> or joy
17:59:44 <kpreid> hubmike2: paste a runnable example
17:59:46 <BMeph> ...or even Forth! :)
17:59:47 * vixey is currently obsessing over forth
17:59:48 <nornagon> /usr/bin/ar: creating dist/build/libHScairo-0.9.13.a
17:59:50 <nornagon> woot!
17:59:51 <hubmike2> ok
18:00:01 <nornagon> got cairo building without gtk2hs :D
18:00:07 <kpreid> BMeph: naw, forth is too low-level
18:00:08 <thetallgu1> vixey: inheavensnamewhy?
18:00:18 <nornagon> (albeit with a *lot* of hackery, next thing is to test if it works...)
18:00:43 <BMeph> kpreid: It's as low-level as you want it to be. :)
18:01:04 <BMeph> kpreid: Also, unlike Lisp, it doesn't need macros to make it a useful language... ;)
18:01:16 <dmwit> nornagon: MOST excellent!
18:01:17 <kpreid> BMeph: fine, show me forth libraries implementing type-tagged stack objects, quotations, and GC
18:01:32 <dmwit> nornagon: I've been trying to get Gtk2Hs to work on my machine at work and failing hard...
18:01:41 <dmwit> nornagon: But all I really wanted was Cairo -> PNG.
18:01:59 <chrisdon1> dmwit: heh, I wanted that a couple weeks ago. gave up and just used libgd
18:02:08 <Shiruka> forth isn't a gc:d language? :-O
18:02:14 * BMeph hunts on the 'Net for "OO Forth," while cackling and grinning evilly...
18:02:24 <dmwit> chrisdon1: I ended up ssh'ing into my home computer and copying the PNGs back to work. =P
18:02:33 <chrisdon1> dmwit: haha
18:02:45 <vixey> thetallgu1: It's something totally new (to me)
18:02:45 <dmwit> nornagon: Got an ETA on hackage/a release?
18:05:57 <hubmike2> http://hpaste.org/9145#a3
18:06:04 <hubmike2> finally gt there
18:06:33 <hubmike2> now fetch shud make it return the tuple surely?
18:06:43 <chrisdon1> yeah maybe artistSearch should return Maybe Sm
18:06:45 <vixey> you wrote "A"
18:06:50 <vixey> artistSearch sb a = fromJust $ find(\(a,_,_) -> a == "A") sb
18:06:50 <vixey> here
18:06:53 <vixey> it should not be "A"
18:06:59 <Shiruka> heh, "Factor is used by approximately two dozen people world-wide."
18:07:02 <vixey> artistSearch sb a = fromJust $ find(\(e,_,_) -> a == e) sb
18:07:21 <Shiruka> some reddit-linked article quote about 747 comes to mind ;-)
18:07:56 <vixey> (please try to use better names that 'S' and 'Sm')
18:08:07 <Shiruka> but concatenativeness is certainly different enough to be interesting
18:08:52 <hubmike2> what what shud be changed?
18:08:54 <vixey> Shiruka, I just read this yesterday, http://www.annexia.org/_file/jonesforth.s.txt
18:09:08 <vixey> Shiruka, You might not want to .. but It was very interesting for me
18:09:18 <hubmike2> so confused probally because of the shorthand
18:09:41 <Shiruka> jonesforth.S... forth written in assembler? :-D
18:10:07 <vixey> there's a forth file as well once that .S is over
18:12:34 <Shiruka> I see the idea.. probably won't be reading all of it though
18:12:57 <Shiruka> that one is something I would have much more fun _writing_ than reading ;-)
18:16:29 <Shiruka> I can't agree with the statement that lisp is the ultimate high-level programming language though
18:16:47 <dmwit> hubmike2: hugs or ghc?
18:16:49 <Shiruka> it seems like ultimate hubris to think that we have ultimate anything in a field as relatively young as programming
18:19:17 <BMeph> kpreid: Check the references mentioned in http://www.bradrodriguez.com/papers/oofs.htm
18:19:17 <lambdabot> Title: A Survey of Object-Oriented Forths
18:20:12 <BMeph> Oops, look at the time - gotta go! See you tomorrow!
18:20:12 <gwern> actually, the lisps always struck me as kind verbose and low-level, honestly
18:20:31 <gwern> something about the clumsy syntax and all the tedious list shuffling...
18:20:53 <gwern> which is why I always liked the 'Lambda - the ultimate opcode' papers
18:21:48 <Shiruka> lisps are verbose, but not by as much as you'd think when you actually measure the character count..
18:21:54 <nornagon> dmwit: in a short while :)
18:21:56 <vixey> lisps aren't verbose :/
18:22:07 <nornagon> dmwit: it's working here, but i'm still ironing out a couple issues
18:22:14 <hubmike2> ok guys one last thing b4 i leave u all alone
18:22:18 <hubmike2> http://hpaste.org/9145#a5
18:22:19 <nornagon> but my test program just compiled and ran
18:22:27 <hubmike2> if u wanted to do two
18:22:38 <hubmike2> searches at the same time
18:22:55 <nornagon> I'm not quite sure how to sneak a -DENABLE_CAIRO_PNG_FUNCTIONS in, though...
18:22:57 <Shiruka> vixey: for the things which suit haskell well, haskell code is shorter :-)
18:23:17 <kpreid> hubmike2: that's not all that good an approach
18:23:42 <hubmike2> yeah i know but im at a loss
18:23:53 <kpreid> hubmike2: it would be better to write artist and title *filtering* functions, then compose the two in order to do an artist-and-title search
18:24:06 <hubmike2> ok
18:24:25 <vixey> @w80 verbose
18:24:25 <dmwit> Good idea, kpreid++
18:24:26 <lambdabot> *** "verbose" wn "WordNet (r) 2.0"
18:24:27 <lambdabot> verbose
18:24:27 <lambdabot>      adj : using or containing too many words; "long-winded (or windy)
18:24:27 <lambdabot>            speakers"; "verbose and ineffective instructional
18:24:27 <lambdabot>            methods"; "newspapers of the day printed long wordy
18:24:28 <lambdabot>            editorials"; "proceedings were delayed by wordy
18:24:31 <lambdabot>            disputes" [syn: {long-winded}, {tedious}, {windy}, {wordy}]
18:25:05 <kpreid> artistFilter aq s = filter (\(a,_,_) -> a == aq) s
18:25:17 <kpreid> titleFilter tq s = filter (\(_,t,_) -> t == tq) s
18:25:30 <kpreid> then you can search both like so:
18:25:51 <kpreid> listToMaybe (artistFilter aq (titleFilter tq s)
18:26:32 <kpreid> (btw, using fromJust is a bad idea, since it prohibits the caller from handling failure)
18:26:35 <Shiruka> lisps are very flexible though
18:26:51 <gwern> sure, so is assembler
18:26:59 <gwern> self-modifying code ftw?
18:27:11 <dmwit> fromJust = unsafeRunMaybe
18:27:52 <hubmike2> hmmm
18:29:05 <kpreid> dmwit: hee
18:29:06 <Shiruka> gwern: but you can implement most things with reasonably short lisp code, for assembler most things become quite long
18:30:29 <Shiruka> and with lisp you're allowed to have a weak mind since it has strong typing ;-)
18:30:50 <vixey> lisp is untyped ...
18:31:04 <Tordek> more like optionally tiped
18:31:08 <Tordek> *typed
18:31:33 <mrd> all languages are typed by hand
18:31:42 <dmwit> That's the first I've heard of lisp's type system.
18:31:46 <Shiruka> most real-life lisps have built-in types, it's not pure lambda calculus..
18:31:55 <mrd> dmwit: (declare (type foo blah)) :)
18:32:07 * vixey probably has different definitions of typed/untyped than everyone else
18:32:08 <byorgey> well, there has to be *some* run-time type checking, for example you can't  (+ 3 'a)
18:32:30 <kpreid> Common Lisp has a pretty good type-of-value system (as opposed to type-of-expression...)
18:38:04 <Shiruka> vixey: maybe.. I just used "strong typing" in the sense that you can't e.g. sum ints, chars and lists together and get something back; you get an error at run-time (but that's the dynamic/static typing distinction, not weak/strong)
18:38:37 * vixey casts out dynamic/static/strong/weak/duck/.. and just says typed vs. untyped
18:38:39 <nornagon> dmwit: try http://nornagon.net/cairo-0.9.13.tar.gz
18:39:17 <dcoutts> nornagon: so went ok eh?
18:39:21 <Shiruka> yeah, weak typing isn't exactly popular these days :-)
18:39:55 <nornagon> dcoutts: after a little stabbing, I *think* i got something that possibly works :)
18:39:59 <nornagon> it typechecks and compiles, anyhow.
18:40:04 <vixey> oh it's very very popular
18:40:09 <vixey> C
18:40:09 <vixey> C++
18:40:17 <vixey> programs go wrong all the damn time :/
18:40:35 <nornagon> dcoutts: what's the nice way of sending #defines to compilation? for things like #ifdef ENABLE_CAIRO_PNG_FUNCTIONS
18:40:51 <dcoutts> nornagon: cpp-options: -DENABLE_CAIRO_PNG_FUNCTIONS
18:40:53 <nornagon> currently i have cc-options: -DENABLE_CAIRO_PNG_FUNCTIONS=1
18:40:56 <nornagon> ah :)
18:41:05 <nornagon> good, then.
18:41:06 <dcoutts> nornagon: cc-options are for C :-)
18:41:13 <SamB_XP_> hmm, there's basically four types of languages.
18:41:15 <nornagon> it seemed to work anyway <.<
18:41:18 <dcoutts> cpp is for pre-processing haskell code
18:41:20 <nornagon> *nod*
18:41:22 <nornagon> thanks :)
18:41:24 <Shiruka> vixey: but not so for newer languages such as Java or C#
18:41:32 <SamB_XP_> Languages like Forth, languages like C, languages like Haskell, and languages like Scheme
18:41:54 <Shiruka> although Perl has some disquieting "features" of its own such as legality of "0"+1 etc.. (and I think PHP inherits these)
18:41:59 <SamB_XP_> in terms of type-safety
18:42:17 <Draconx> SamB_XP_, which of those 4 types is prolog?
18:42:30 <vixey> yeah, the categories  typed vs. untyped   and  safe vs. unsafe
18:42:30 <SamB_XP_> Draconx: probably like Scheme
18:42:36 <sarehuu> which is C++?
18:42:36 <vixey> Prolog is safe and untyped
18:42:42 <SamB_XP_> sarehuu: like C
18:42:46 <Zao> sarehuu: C:y.
18:42:53 <vixey> there's a little chart of this in TAPL :p
18:43:06 <SamB_XP_> I haven't got TAPL yet :-(
18:43:19 <Draconx> SamB_XP_, now, where does malbolge fall? :)
18:43:20 <Shiruka> but even Haskell isn't completely safe :-)
18:43:38 <SamB_XP_> Shiruka: true
18:43:42 <vixey> yeah we ignore that for the purpose of categorizing
18:43:44 <Shiruka> doesn't GHC still potentially do shortcut fusion wrong?
18:43:48 <SamB_XP_> it's a bit subjective
18:44:05 <nornagon> dcoutts: hrm, cpp-options doesn't seem to work right. it's not getting passed to c2hs
18:44:23 <SamB_XP_> Shiruka: wrong in what sense?
18:44:41 <dcoutts> nornagon: c2hs is not cpp and wouldn't understand cpp options anyway
18:44:58 <Shiruka> in that the optimized code doesn't evaluate to the same result as unoptimized code
18:45:03 <byorgey> nornagon: I'm testing out your cairo package
18:45:15 <dcoutts> nornagon: was it a .chs.pp file that you started with?
18:45:16 <byorgey> nornagon: are there some things that it doesn't export, relative to the one with gtk2hs?
18:45:19 <nornagon> dcoutts: yeah
18:45:26 <nornagon> .hs.pp possibly
18:45:27 <Shiruka> like described here: http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion
18:45:29 <lambdabot> Title: Correctness of short cut fusion - HaskellWiki, http://tinyurl.com/23j3w3
18:45:36 <nornagon> byorgey: a couple, yeah, due to this #define issue :)
18:45:41 <byorgey> nornagon: ok
18:45:46 <nornagon> mostly the pdf/ps/svg stuff
18:45:47 <byorgey> nornagon: it built and installed fine
18:45:51 <nornagon> byorgey: awesome :)
18:45:52 <byorgey> nornagon: yeah, exactly
18:45:52 <dcoutts> nornagon: which? if it's .hs.pp it's fine, if it's a .chs.pp it's problematic.
18:46:04 * nornagon checks darcs revert
18:46:14 <byorgey> nornagon: I tried building my diagrams library with it and ran into some unexported things like withPDF/PS/SVGSurface
18:46:40 <nornagon> dcoutts: .hs.pp
18:46:46 <byorgey> nornagon: if you fix those things and want me to test again just let me know
18:46:51 <nornagon> byorgey: awesome, will do
18:46:57 <nornagon> i'm about to get them sorted
18:47:01 <byorgey> cool
18:47:29 <nornagon> hmm, my version of cairo doesn't seem to have svg_surface_create, though o.o
18:47:48 <dcoutts> nornagon: but there's also Graphics/Rendering/Cairo/Internal/Surfaces/PNG.chs.pp which contains #ifdef ENABLE_CAIRO_PNG_FUNCTIONS
18:47:58 <nornagon> dcoutts: yep
18:48:09 <nornagon> that's just a .chs now...
18:48:17 <nornagon> because cabal wasn't happy with the .pp
18:48:19 <dcoutts> nornagon: cairo can be built with a number of backends, we can't bind the functions in the backends that were disabled
18:48:41 <nornagon> dcoutts: right, so is there a good way to decide which backends to compile?
18:49:14 <dcoutts> nornagon: yes, that's one of the things that the gtk2hs ./configure script does
18:49:34 <dcoutts> nornagon: so it's a problem. Cabal doesn't grok .chs.pp, however the way it worked before was to run cpp and then c2hs
18:49:43 <nornagon> hmm.
18:50:16 <nornagon> there is a /usr/include/cairo/cairo-features.h, but it seems to be misleading.
18:50:24 <dcoutts> nornagon: how so?
18:50:54 <nornagon> it defines CAIRO_HAS_SVG_SURFACE 1 on my system that doesn't have the SVG support, i think.
18:51:01 <nornagon> oh wait
18:51:01 <dcoutts> nornagon: are you sure about c2hs and the cpp-options btw?
18:51:08 <nornagon> it's in cairo-svg.h, doh :)
18:51:15 <dcoutts> nornagon: the code I'm looking at passes cpp-options to c2hs
18:51:38 <nornagon> i'll check again...
18:51:38 <dcoutts> nornagon: ah! put the define in cc-options too
18:51:41 <SamB_XP_> dcoutts: and you just said c2hs wouldn't understand them!
18:52:08 <dcoutts> SamB_XP_: not directly, but we can pass them through
18:52:45 <nornagon> dcoutts: right, cc-options is where i had them before...
18:52:54 <SamB_XP_> dcoutts: oh, like GCC and linker flags?
18:52:59 <dcoutts> SamB_XP_: right
18:53:30 <dcoutts> nornagon: so weirdly, we pass cpp-options to cpp when pre-processing .hs files, however we extract -D and similar flags from cc-options and pass them to c2hs
18:54:42 <nornagon> dcoutts: o.o
18:55:01 <nornagon> byorgey: http://nornagon.net/cairo-0.9.13-standalone.tar.gz should have PDF/PS/SVG support
18:55:06 <dcoutts> hmm, but the cpp options we pass to c2hs really are for the C header it processes
18:55:37 <nornagon> i should switch to asking cairo-features.h, though
18:55:57 <nornagon> i should get a hackage account, or something.
18:56:25 <dcoutts> nornagon: if you don't mind, I'd rather you didn't upload a cairo package just yet
18:57:03 <byorgey> nornagon: btw, you should add 'build-type: Simple' to the .cabal file
18:57:03 <nornagon> dcoutts: no worries
18:57:10 <nornagon> byorgey: what's that do?
18:57:21 <byorgey> nornagon: prevents newer versions of Cabal from printing a warning ;)
18:57:26 <nornagon> ah :)
18:57:37 <dcoutts> heh
18:57:50 <dcoutts> it's not just to make it shut up you know :-)
18:57:56 <dcoutts> it says so for a reason
18:58:19 <dcoutts> nornagon: so asking cairo-features.h could be tricky
18:58:24 <dcoutts> check what configure.ac does
18:58:25 <nornagon> dcoutts: oh?
18:58:28 <nornagon> hrmm.
18:58:40 <byorgey> nornagon: works great!
18:58:46 <nornagon> byorgey: awesome :)
18:58:52 <byorgey> dcoutts: hehe, I know =)
18:59:22 <dcoutts> it generates a .sh file, runs cpp over it and then executes it :-)
18:59:23 <nornagon> dcoutts: looks like configure.ac just checks cairo-features
18:59:33 <dcoutts> nornagon: yes, that's true
19:00:09 <dcoutts> nornagon: you'll need a custom Setup.hs I fear, which means changing build-type: Custom
19:00:11 <nornagon> o.o that's nuts
19:00:26 <dcoutts> nornagon: it makes sense given that configure is a sh script
19:00:36 <dcoutts> of course you'd not do it exactly the same way
19:00:44 <nornagon> what's wrong with just including cairo-features?!
19:00:57 <dcoutts> nornagon: it's not Haskell code, can't be included
19:01:34 <nornagon> um. that's why we're passing our haskell stuff through c2hs and cpp, right?
19:02:12 <dcoutts> nornagon: it might be more complicated actually so it may work
19:02:32 * nornagon tries it.
19:02:47 <dcoutts> nornagon: in general, if we're running cpp over a .hs file, then any .h we include cannot spit out C code or we'll end up trying to compile a mixed C/haskell code in a .hs file
19:02:57 <dcoutts> now cpp in c2hs is a bit freaky
19:03:13 <dcoutts> it does not work simply by running cpp over the .chs file
19:03:26 <dcoutts> it has a custom lexer which picks out #cpp directives
19:03:44 <moozilla> "Write a function lastButOne, that returns the element before the last." Is it possible to do this without using infix or length?
19:04:06 <byorgey> moozilla: yes, it can be done just with pattern matching
19:04:22 <vixey> head . reverse
19:04:23 <vixey> last . init
19:04:25 <dcoutts> nornagon: seems also that the cairo-features.h file has changed in recent versions and now only contains cpp directives and no C code. But earlier versions did.
19:04:32 <nornagon> dcoutts: oic
19:04:33 <vixey> oh
19:04:38 <vixey> head . tail . reverse
19:04:39 <nornagon> well, i just tried it, and it worked...
19:04:44 <moozilla> ah i never thought about reverse
19:04:48 <moozilla> thanks
19:04:48 <SamB_XP_> dcoutts: maybe for this very reason?
19:05:01 <dcoutts> SamB_XP_: could well be
19:06:13 <dcoutts> SamB_XP_: heh, yes.
19:06:49 <nornagon> dcoutts: eugh, maybe not
19:06:58 <SamB_XP_> I mean, GTK caters to bindings like ... well, I can't think of a good metaphor
19:07:42 <dcoutts> SamB_XP_: so what it does, it generates a .h header file and defines C structs with unique names inside #if directives corresponding to the #ifs in the .chs file. Then when it reads the .h file it discovers which C structs got defined and from that can work out which conditions were true and thus what .hs code to emit.
19:07:46 <dcoutts> devilishly cunning
19:07:49 <nornagon> ah, wait
19:07:58 <nornagon> i have to actually #include cairo-features.h
19:08:04 <nornagon> okay, yes, works as expected
19:08:10 <dcoutts> nornagon: yes. And I now think it should work.
19:08:21 <dcoutts> nornagon: oh, good :-)
19:08:49 <SamB_XP_> dcoutts: what the HELL?
19:08:54 <SamB_XP_> that's insane
19:09:04 <dcoutts> it's genius
19:09:15 <SamB_XP_> they tend to go together ;-)
19:09:52 <dcoutts> SamB_XP_: it adds a "struct C2HS_COND_SENTRY<unique number>;" after each #if or #elif
19:10:07 <nornagon> that's pretty nuts
19:10:23 <dcoutts> and c2hs already knows how to process the .h file and read the C AST
19:10:28 <nornagon> anyway, dcoutts: any reason i shouldn't upload a cairo package?
19:10:38 <dcoutts> so it just checks which structs got defined.
19:10:52 <dcoutts> nornagon: well, yes and no.
19:11:17 <dcoutts> nornagon: we gtk2hs folk maintain that package, we're responsible for supporting it.
19:11:27 <nornagon> *nod*
19:11:29 <dcoutts> people will complain to us if it doesn't work
19:11:52 <dcoutts> and will we get version clashes, and what about darcs tags corresponding to releases etc
19:12:04 <dcoutts> we follow release processes
19:12:08 <nornagon> ah :) how scary.
19:12:18 <dcoutts> and we are eventually planning to get these packages on hackage
19:12:21 <nornagon> sounds like you're "organised" or something equally silly.
19:12:26 <dcoutts> I converted glib to Cabal the other day
19:12:32 <dcoutts> now you've done cairo
19:12:43 <nornagon> :)
19:13:15 <nornagon> incidentally, http://nornagon.net/cairo-0.9.13-standalone.tar.gz now has the cairo-features.h patch
19:13:17 <dcoutts> nornagon: perhaps you can send you patches to the gtk2hs list and we can talk about what to do
19:13:47 <dcoutts> nornagon: btw, pgavin is our new release manager. We should talk to him too. He's also keen to cabalise gtk2hs.
19:14:03 <dcoutts> we've been gradually picking off the items on the TODO list
19:14:30 <dcoutts> so we should talk about whether it makes sense to release some packages now or wait 'til we can do gtk too
19:14:38 <nornagon> oh, the one thing i haven't fixed yet is the dependence on glib for the UTF stuff
19:14:56 <dcoutts> right
19:15:20 <SamB_XP_> what's wrong with a dependence on glib ... ?
19:16:13 <nornagon> SamB_XP_: i don't need it when i write cairo code in C, so why should I need it when I write cairo code in haskell? :)
19:16:29 <SamB_XP_> nornagon: ah
19:16:58 <dcoutts> it's true, it's not strictly necessary
19:17:14 <SamB_XP_> ... only lazily ?
19:17:19 <dcoutts> heh
19:17:37 <nornagon> i wonder if darcs send will work when i don't have an mta set up.
19:17:45 <dcoutts> probably not
19:17:47 <SamB_XP_> nornagon: ... no
19:17:50 <SamB_XP_> it won't
19:18:06 <SamB_XP_> you need a working "sendmail" script
19:18:09 <nornagon> hm
19:18:16 <nornagon> well, apparently i have one.
19:18:22 <nornagon> Successfully sent patch bundle to: Gtk2Hs-devel List <gtk2hs-devel@lists.sourceforge.net>.
19:18:32 <nornagon> unless it's lying.
19:18:40 <b\6> is everything on hackage available via darcs somehow?
19:18:41 <SamB_XP_> nornagon: well, it isn't saying that it got delivered
19:19:05 <nornagon> SamB_XP_: point
19:19:25 <SamB_XP_> it could easily be stuck in your mta's queus, waiting for you to tell your mta what to do with email!
19:19:58 <ahunter2> So here's a question, guys: the list datatype is recursive, but regardless of which constructor you pick, you'll never find more than one list (one recursive call.)
19:20:18 <SamB_XP_> ahunter: eh???
19:20:22 <nornagon> SamB_XP_: huh, it did work, because the mailman sent me a message telling me i wasn't subscribed :)
19:20:30 <ahunter2> Are there other commonly used recursive datatypes, which people actually use recursively, which hold the same property?
19:20:48 <SamB_XP_> nornagon: I guess you either had an mta set up, or some kind of stub sendmail script configured ...
19:20:54 <ahunter2> It seems to me some interesting things could be proved about such things, since in some level, they share a bit of isomorphism with lsits
19:21:09 <dcoutts> yo sioraiocht
19:21:26 <SamB_XP_> ahunter: well, sometimes we use odd "lists"
19:21:56 <SamB_XP_> and for some reason I started to type "and cheese" ...
19:22:07 <dcoutts> data ListWithFail a = Done | Fail String | Next a (ListWithFail a)
19:22:09 <SamB_XP_> (probably because my mom just asked me what I'm eating?)
19:22:31 <SamB_XP_> dcoutts: nice monad
19:22:31 <ahunter2> SamB_XP_: yeah, I'm trying to think of goo dexamples other than, like, Peano numerals
19:22:50 <SamB_XP_> meant to say "and streams"
19:22:56 <SamB_XP_> where I mean
19:23:15 <SamB_XP_> data Stream a where Cons :: a -> Stream a -> Stream a
19:23:18 <ahunter2> I know the stream idea, yeah
19:23:32 <SamB_XP_> (not the one from stream fusion ;-)
19:23:49 <dcoutts> SamB_XP_: or this: data Progress a = Done a | Fail String | Next Log (Progress a)
19:24:10 <ahunter2> dcoutts: is that an example from some actual program?
19:24:26 <dcoutts> ahunter2: yes, both are from a real prog, though not necessarily with those names
19:25:03 <dcoutts> and possibly more or less paramaterised
19:28:13 <Shiruka> btw, does anyone here happen to know if there are any other languages that have (a non-toy implementation with) something similar to GHC:s RULES pragma, or is it a feature unique to Haskell?-)
19:31:58 <rumbleca> Shiruka: is that like a macro?
19:32:30 <Shiruka> an optimization rule
19:32:45 <Shiruka> macro is different in that you call it explicitly
19:32:51 <ahunter2> rumbleca: http://research.microsoft.com/~simonpj/papers/rules.htm
19:32:52 <lambdabot> Title: Simon Peyton Jones: papers
19:33:30 <rumbleca> thanks :)
19:33:40 <ahunter2> np
19:34:27 <dons> Shiruka: i don't know of any other compiler with such a feature.
19:34:28 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:34:36 <dons> i.e. embedded term rewriting as an optimisation technique.
19:34:50 <dons> it would be pretty hard to do outside of a pure language though, i suspect
19:35:01 <dons> since the side conditions would make most transformations useless
19:35:27 <newsham> I need a date/time representation.  the most important operation will probably be comparison over a wide range of dates.  What's the best standard type to use?  UTCTime?
19:35:45 <dons> yeah
19:36:00 <newsham> what's the standard way to go from a date/time to UTCTime?
19:36:26 <Shiruka> true, but you might be able to manage somehow to do something similar.. I'm not aware of any other compiler doing it either, but thought that it might just be ignorance on my part :-)
19:36:43 <dons> it would be cool if we could find some other system. i love rewrite rules.
19:36:48 <dons> they're a library writers dream
19:36:53 <Shiruka> indeed
19:37:31 <SamB_XP_> JHC does it too ... now if only typeclasses would always generate well-typed RULES...
19:40:51 <ahunter2> dons: I'm always curious if in theory most rewrite rules can't be replaced by a sufficiently good inliner
19:41:03 <ahunter2> dons: I mean, I understand how in practice they're super-awesome and nice and easy
19:41:12 <ahunter2> they just seem...slightly warty
19:41:17 <SamB_XP_> ahunter: they can't be
19:41:23 <Shiruka> the point is in teaching the compiler new tricks
19:41:25 <dons> you need an inliner, then a bunch of equivalences to rewrite terms to
19:41:26 <ahunter2> SamB_XP_: not in the general case, no
19:42:08 <ahunter2> I just feel like there are many cases where normal optimizations Should Be Good enough--we just use rewrite rules because it's too hard to make the compiler realize X = Y is a correct transformation
19:42:15 <SamB_XP_> that's like saying "forget the rewrite tactic, unfold is all I need" when doing proofs in Coq ;-P
19:42:37 <Shiruka> in principle you could leave it to the compiler writers to write a compiler that optimizes every possible special case in every library in the world, but it just isn't practical.. I distinctly remember one of SPJ's papers mentioning this (with a reference :-)
19:43:19 <SamB_XP_> in what principle?
19:43:32 <SamB_XP_> clearly, it was NOT a sound principle of economics
19:43:41 <Shiruka> heh :-)
19:43:56 <ahunter2> Economics?  This is academic computer science!
19:44:33 <ahunter2> I mean, seriously, people do rather unnecessary stuff to prove they can *all the time*.  If we always did the academically sensible thing, think of how many things wouldn't exist. :)
19:44:41 <SamB_XP_> well, let's put it this way: the compiler authors would never keep up if the libraries were written at anything faster than a snail's pace ;-P
19:45:26 <SamB_XP_> probably not even then
19:45:36 <SamB_XP_> compilers tend to harbour a LOT of bugs ;-)
19:46:00 <SamB_XP_> (as far as "things that should be optimized but aren't" goes)
19:47:07 <Shiruka> but it's not just at the "this would benefit only one obscure library, so let's not include it" level, it's more like "let's pick the lowest-hanging branches, we'll never get to high branches anyway"
19:47:51 <dons> i guess ghc's pretty far along in terms of the radical, representation and complexity-changing transformations that take place.
19:48:02 <dons> particular for a non-whole program optimising compiler
19:48:06 <Flopper> I'm looking for a clever (perhaps points-free) implementation of "each n xs" where "each 3 [1, 2, 3, 4, 5]" would return [[1, 2, 3
19:48:21 <SamB_XP_> Flopper: huh
19:48:22 <Flopper> ... would return [[1, 2, 3], [4, 5]]
19:48:26 <Shiruka> I didn't really think of it in terms of economics though, even though it should be obvious that it's the correct model :-)
19:48:40 <Flopper> and "each 2 [1..10]" would return [[1, 2], [3, 4], [5, 6] ...]
19:48:54 <nornagon> :t splitAt
19:48:58 <SamB_XP_> oh, I was going to make some joke about the meaning of the unbalanced brackets ;-)
19:49:01 <lambdabot> forall a. Int -> [a] -> ([a], [a])
19:49:21 <Shiruka> dons: it's actually one of the most interesting things to me about haskell
19:49:37 <Shiruka> it seems like haskell is at the forefront of doing something about the abstraction penalty
19:49:44 <SamB_XP_> yes, economics is about the use of limited resources in the presence of unlimited wants ;-)
19:49:48 <Flopper> it's simple with a recursive "each _ [] = []" and  "each n xs = take n xs : each n (drop n xs)" but I'm looking for more elegance :)
19:49:55 <SamB_XP_> clearly the appropriate way to think about it ;-)
19:50:17 <dons> Shiruka: i think purity primarily is the reason. you can be so much more reckless when you don't have to worry about effects.
19:50:31 <SamB_XP_> Shiruka: I thought we were trying to do something about the abstraction bonus
19:52:14 <Flopper> perhaps something with scan... but I can't quite figure it out
19:53:17 <SamB_XP_> dons: yes, compilers are forever trying to minimize the impact of effects on optimization by transforming code into forms with less of them ;-)
19:53:48 <Flopper> or even a one-liner would be nice
19:53:54 <Flopper> (without 'if' ;)
19:54:25 <hubmike2> hey guys
19:54:40 <nornagon> okay, next challenge: get cairo to render into SDL...
19:54:41 <hubmike2> is there any easy way to go from a tuple to a list
19:54:46 <Shiruka> dons: sometimes I worry about what the recklessness does to things using IO (particularly unsafePerformIO), though.. (I should really study a bit how all that is actually implemented)
19:54:49 <catface> > map (take 3) $ iterate (drop 3) [1..1000]
19:54:50 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
19:54:58 <Saizan_> > unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt 2)) [1..10]
19:54:59 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
19:55:19 <Flopper> thanks guys :)
19:55:24 <SamB_XP_> Shiruka: do you suppose that might be why it's called that?
19:55:38 <Shiruka> like parallel evaluation possibly evaluating thunks multiple times and parallel gc duplicating thunks.. presumably this won't wreck any havoc with IORefs or IO actions, but I don't have a clear picture how it all works in the end
19:55:49 <byorgey> hubmike2: you mean like (a,b,c) ---> [a,b,c]?  no, there isn't
19:55:52 <Shiruka> SamB_XP_: well yeah, but it's used a lot in the internals and some libraries
19:55:55 <dcoutts> nornagon: it can render to raw buffers, though note that it uses it's own packages image format. (pre-multiplied alpha)
19:56:10 <SamB_XP_> Shiruka: they had to add a new version of unsafePerformIO that promises not to begin executing multiple times
19:56:11 <byorgey> other than just writing such a conversion function yourself
19:56:12 <dcoutts> packages/packed
19:56:16 <byorgey> tripleToList (a,b,c) = [a,b,c]
19:56:16 <hubmike2> gdgd
19:56:40 <SamB_XP_> (and make the other one always finish each time ;-)
19:56:46 <ahunter2> @ f (a,b) = [a,b]
19:56:53 <nornagon> dcoutts: i've got cairo rendering into SDL in C, the trick will be getting it working in haskell...
19:56:54 <ahunter2> @pl  f (a,b) = [a,b]
19:56:54 <lambdabot> f = uncurry ((. return) . (:))
19:56:55 <hubmike2> my return is a list for one and i need it to be a tuple for the other
19:56:57 <hubmike2> lol
19:57:10 <nornagon> the way i'm doing it in C is creating the SDL surface and then telling cairo to render directly onto it
19:57:24 <nornagon> by asking for surf->pixels
19:57:33 <hubmike2> ok
19:57:48 <dcoutts> nornagon: right, I expect we can do it the same way. You might need to bind an extra surface creation function.
19:58:15 <SamB_XP_> Shiruka: so, one of them runs the action no more than one times, the other simply promises not to abort the action just because another thread finished evaluating the thunk ;-)
19:59:00 <Shiruka> heh, sounds interesting
19:59:00 <byorgey> @seen dmhouse
19:59:01 <lambdabot> I saw dmhouse leaving #haskell-books, #haskell-blah and #haskell 4h 18m 47s ago, and .
19:59:02 <nornagon> dcoutts: plus work out the casting from SDL's "Ptr PixelsData" to Ptr UInt8 or whatever.
19:59:53 <dcoutts> nornagon: we've not bound cairo_image_surface_create_for_data, you probably want that right?
19:59:54 <ahunter2> hah, I just realized something slightly amusing: unlike what I thought, ' is legal anywhere in identifiers (yes?) not just at the end
20:00:00 <nornagon> dcoutts: yep
20:00:01 <ahunter2> I now need to start coding in the Old Tongue
20:00:04 <SamB_XP_> happened because they realized the previous implementation wasn't safe with SMP ;-)
20:00:06 <nornagon> *binds it*
20:00:21 <SamB_XP_> ahunter: anywhere but the beginning, yes
20:00:41 <SamB_XP_> since if you put it at the beginning, it kinda looks like the beginning of a character literal...
20:00:49 <SamB_XP_> > let 'x = 1 in 'x
20:00:49 <lambdabot>  Improperly terminated character constant at "'x" (column 5)
20:00:50 <ahunter2> let ter'angreal =  Dovie'andi >>= muad'drin
20:01:06 <SamB_XP_> (oh good, I was actually right ;-)
20:02:53 <Shiruka> SamB_XP_: the only place where I've used unsafePerformIO myself directly thus far is in implementing a memoizer (AFAIK a rather common case, I think I've even seen an implementation by the simon squad)
20:08:23 <Shiruka> it's somewhat ironic that memoization makes the most sense for pure functions and does not change the purity as seen by the outside, and yet the most generally useful forms of it use unsafePerformIO :-)
20:15:11 <O_4> Hmm, I'm having trouble compiling a haskell app that uses SDL
20:15:39 <O_4> I've installed the SDL package with cabal, but still get a bunch of link errors when I try to compile
20:15:43 <O_4> See http://hpaste.org/9148
20:16:09 <mar77a> if they're link errors
20:16:12 <mar77a> you know what to do!
20:16:30 <O_4> It looks like it can't find both the SDL binding lib or whatever, and libSDL itself
20:16:41 <O_4> Actually, I don't, hence why I'm asking for help :-p
20:17:39 <mar77a> i don't have experience with haskell but with SDL and C you have to pass the following flags to the compiler: -lSDL -SDLmain (on windows i think)
20:17:41 <O_4> Presumably I need to configure ghc (and maybe cabal) so that it knows where to search for objects
20:18:06 <O_4> mar77a: most of the unfound symbols aren't in libSDL
20:18:27 <dcoutts> O_4: what command line did you use?
20:18:36 <Shiruka> you did give --make to ghc, right?
20:18:39 <O_4> ghc path/to/file.hs
20:18:42 <O_4> Nope
20:18:45 <dcoutts> use --make
20:19:01 <dcoutts> otherwise it just tries to link that one .o file
20:19:09 <dcoutts> without all the libs and packages it depends on
20:19:41 <dcoutts> it's like missing out -lSDL and all that, but with --make ghc does auto dep chasing
20:19:43 <O_4> Aha, thanks
20:19:45 <Cale> Perhaps --make ought to be the default
20:19:46 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:20:37 <dcoutts> Cale: we can't break batch mode, but I suspect there's way we can do it
20:21:00 <dcoutts> Cale: eg if the user uses -c then we assume batch mode, otherwise --make mode
20:21:17 <Shiruka> or have --nomake :-)
20:21:42 <Cale> yeah
20:21:58 <O_4> Is --make supposed to produce a binary?  It's still only resulting in an object for me.
20:23:15 <catface> what module do i need if i get "No instance for (Monad ((->) [a])) arising from use of liftM2" ?
20:23:19 <dons> O_4: do you have main defined?
20:23:29 <Cale> catface: Control.Monad.Instances
20:23:32 <dons> catface: Control.Monad.Instances
20:23:36 <dons> crikey.
20:23:53 <catface> thnx
20:25:18 <Cale> O_4: by default (unless you use -main-is) you must have a module called Main (which is the default if there's no module declaration), containing an IO action called main.
20:25:54 <O_4> Ah, I didn't call the module Main
20:26:41 <O_4> Thanks guys, that sorted it mostly out
20:27:16 <O_4> Unfortunately, it's still trying to find a SDL_main, which I seriously doubt is gonna exist.
20:28:03 <O_4> I wonder if this ever actually got tested on OS X...  Does anyone know?
20:38:15 <codacola> if i have type DataBase = [(Int, String, Int)], i can use it as "((barcode1, name1, price1): x)" right?
20:38:45 <byorgey> codacola: sure, then x is the remainder of the list
20:39:09 <byorgey> assuming by 'use' you mean 'pattern match'
20:39:21 <codacola> yeah
20:39:48 <codacola> http://hpaste.org/9149 <- thats the error im getting
20:41:12 <byorgey> codacola: hm, can you paste your code as well?  it's a little hard to tell what's going on just from the error message
20:41:33 <Shiruka> it's type, not newtype, right?
20:42:24 <joed> Grapics? Is there a compile to flash thing?
20:44:09 <codacola> http://hpaste.org/9151
20:44:58 <TSC> The definition of DataBase could be important too
20:45:25 <codacola> type DataBase = [(Int, String, Int)]
20:45:40 <hackage> Uploaded to hackage: haskeline 0.2.1
20:45:46 <codacola> sorry its spread all over the place, and im sure you dont wanna see all 200 lines :P
20:46:10 <byorgey> hm, I can't see anything wrong with it
20:46:25 <byorgey> codacola: are you absolutely sure that you literally have  type DataBase = [(Int, String, Int)] ?
20:46:46 <TSC> And "type Name=String"; "type Price=Int"; "type BarCode=Int" ?
20:47:04 <codacola> well its [(BarCode, Name, Price)], BarCode = Int, Name = String, and Price = Int
20:47:51 <TSC> When you call look, in the otherwise case
20:47:55 <TSC> it should have two arguments
20:48:33 <codacola> so it should
20:48:44 <codacola> thanks, but that was a later error :P
20:48:54 <TSC> Other than that, it compiles for me
20:49:41 <Shiruka> and all the types are defined using "type", not e.g. "newtype" and "data"?
20:50:02 <codacola> http://hpaste.org/9152 <- ok theres the full thing (i think)
20:51:32 <TSC> http://hpaste.org/9151#a1 works for me
20:53:50 <Shiruka> in http://hpaste.org/9152, there's usage of DataBase even though only Database is defined.. and barcode in look's otherwise clause even though only barcode1 and barcode2 are defined
20:53:55 <byorgey> codacola: check Database vs. DataBase
20:54:05 <byorgey> you seem to have two different capitalizations floating around
20:54:57 <codacola> oh heh
20:54:58 <codacola> thanks
20:55:27 <codacola> ah i see why it didnt tell me DataBase is silly. it exists later on for another part
20:55:52 <codacola> had to make a database thingie from scratch for a dvd store, and ive named that one DataBase and theyve named this one Database
20:56:19 <Shiruka> a good way to find problems is to try to reproduce it in a smaller file, so finding the cause is more tractable
20:56:20 <newsham> applicative vs. monad question: put (UTCTime a b) = put a >> put b   and  get = UTCTime <$> get <*> get    should be compatible (ie. same order of evaluation) yes?
20:56:34 <byorgey> codacola: that sounds like a... really poor idea ;)
20:56:52 <byorgey> I'd change DataBase to something else
20:57:19 <codacola> indeed
20:57:29 <codacola> cant. theyve specified the names in the assignment
20:57:29 <byorgey> newsham: yes
20:57:47 <byorgey> codacola: they specified the names Database as well as DataBase ?
20:57:52 <codacola> and from the way shes spoken she doesnt mark based on code, but by how it works
20:58:23 <codacola> yeah, the book uses Database (gotta do 25 exercises from there), and the "long questions" had another database thing which specified DataBase
20:58:26 <codacola> very confusing
20:58:36 <byorgey> wow, that's confusing indeed =(
20:58:45 <Shiruka> use something else first
20:58:52 <Shiruka> then search and replace before returning :-)
20:58:59 <codacola> too late. only got 2 functions left to define
20:59:02 <codacola> and then im all finished
20:59:20 <codacola> kinda, skipped to chapter 6. gotta do the exercises from the first 5 chapters next :|
20:59:59 <newsham> I dont know why Get isn't instance Applicative yet, but its supre nice when it is
21:00:09 <dobblego> Get?
21:00:12 <newsham> get = Constructor <$> get <*> get <*> get <*> get <*> get
21:00:16 <newsham> from Data.Binary
21:00:19 <dobblego> ah
21:00:39 <newsham> so long as all members are already Data.Binary instances
21:01:12 <codacola> i wish vim would open in full screen
21:01:22 <codacola> keeps opening in this tiny window and gotta resize it everytime i edit
21:03:00 <codacola> oh curious, any students here using the msdnaa versions of windows?
21:03:27 <O_4> AA?
21:03:51 <Shiruka> microsoft DNA application? :-O
21:04:00 <codacola> Academic Alliance (MSDNAA)
21:04:18 <O_4> Ah, yeah I have a copy of XP.
21:04:22 <O_4> But I don't use it.
21:04:29 <Shiruka> phew, sounded very scary for a moment
21:04:30 <codacola> are they limited versions at all?
21:04:34 <O_4> Nope.
21:04:45 <O_4> Well, there might be legal limitations
21:04:47 <codacola> i want to replace vista with xp, and the university offered me an msdnaa version of xp or vista...
21:04:55 <O_4> But functionally I don't think there's any difference.
21:05:30 <codacola> alright, the next thing to ponder is "can i install xp", last time i tried to install 2000 i had driver issues (hp wont release any drivers for it)
21:05:37 <codacola> onyl for vista last time i checked
21:06:19 <hml> anyone here got harpy to work on x86_64? when I run the tutorial, it just seg faults
21:07:55 <hml> in the following; the "Float" is hard coded, however suppose I want to have points with Int, Rational, or Complex ... how can I abstract out the Float?
21:07:59 <hml> data Point = Point { x :: Float, y :: Float, z :: Float }
21:08:29 <O_4> data Point a = ... ?
21:09:05 <codacola> curious, http://hpaste.org/9153 <- look alright? i was only told to define the "formatPence" but wanted to make it a bit shorter
21:10:06 <hml> O_4: got it; thanks
21:15:16 <TSC> codacola: It looks reasonable
21:18:05 <codacola> got a little paranoid about this. in my last class there were heaps of restrictions. got this assignment and there were none, just "do this", ended up worrying that certain things (eg list comprehensions) wouldnt be allowed
21:18:25 <TSC> You should ask if you're worried
21:18:42 <TSC> A reasonable person would happily clarify it for you (in my opinion)
21:18:45 <codacola> i did. and she just shurgged and said "i didnt put any restrictions there did i?"
21:19:00 <TSC> That sounds like the green light to me (:
21:19:08 <codacola> then she got worried. had to explain that id already done the long questions and she goes "oh god you must be bored in here"
21:19:56 * codacola found that part amussing
21:20:59 <b\6> :/
21:21:23 <b\6> they are finding your money amusing.
21:21:27 <hml> what is the fastest way to permute a list? i.e. make (x:xs) -> (xs:x) ?
21:21:44 <hml> err, (x:xs) --> xs ++ [x] ... (this seems like it's very slow)
21:22:41 <Shiruka> some shootout benchmark does list permutations (fasta?)
21:22:55 <Shiruka> probably has relatively optimized code.. :-P
21:25:15 <hml> yeah; (x:xs) = xs ++ [x] just looks sbad
21:27:40 <codacola> b\6: not quite, shes offered to give me more work on functional programming, though i just wanted to get ahead in 1 of my classes so ive got more time for the rest
21:28:54 <Trinithis> codacola: do you know about the $ operator or the . operator?
21:30:06 <codacola> the . yes, the $ no
21:30:34 <Trinithis> The most common use for $ is to remove parenthesis
21:31:00 <Trinithis> like in a calculator, most allow you to not put in ) parens at the end of the expression right?
21:31:05 <Trinithis> $ is similar
21:31:16 <Trinithis> f (g (x)) == f $ g $ x
21:32:16 <Trinithis> getPence price = show $ price `mod` 100
21:37:28 <codacola> ah, interesting
21:37:51 <codacola> and no, my calculator always gets shitty at me if i miss a ) :P
21:38:10 <Trinithis> it wont let you do "sin(x" ?
21:38:21 <codacola> lets see
21:38:34 <Trinithis> or rather "sin(0"
21:38:41 <Trinithis> because x is a var
21:38:44 <codacola> seems it does
21:38:52 <codacola> sin(sin x even works
21:39:20 <Trinithis> because it "adds" the correct # of closing parens at the end for you
21:39:36 <codacola> cool, never knew
21:39:45 <Trinithis> So $ is basically the same thing
21:39:54 <codacola> then again i dont know half the features of my calculator :P
21:40:19 <Trinithis> @src ($)
21:40:19 <lambdabot> f $ x = f x
21:40:44 <Trinithis> The magic behind $ is due to its infix declaration
21:41:08 <codacola> only found out about !! yesterday when i was trying to understand teh code behind the "test program" for my assignment
21:41:21 <TSC> I think the key is its low precedence
21:41:30 <Trinithis> infixr 0 $
21:42:06 <Trinithis> You don't really have to worry about $'s definition so long as you understand its use
21:42:24 <codacola> curious, anyone here tried any of the haskell ides made in haskell?
21:42:42 <Trinithis> http://leksah.org/
21:42:43 <lambdabot> Title: Leksah - Haskell IDE in Haskell
21:42:52 <codacola> yeah like that
21:42:55 <Trinithis> I use vim though as a text editor
21:43:04 <jeffwheeler> codacola: not an IDE, but I'm trying Yi; it's really clean, although I'm stuck on its usage
21:43:13 <codacola> ah, at the moment im using winhugs and vim
21:43:22 <jeffwheeler> I really want to love Yi.
21:43:35 <Trinithis> I've never tried Hugs. I only use ghci for interactive mode
21:43:41 <Trinithis> jeff: a link?
21:43:54 <codacola> winhugs is what we use in the labs, so figured i better get used to it
21:44:07 <codacola> though considering installing linux this weekend, so ill want something else
21:44:08 <_zenon_> good mornin'
21:44:12 <jeffwheeler> Trinithis: http://www.haskell.org/haskellwiki/Yi
21:44:13 <lambdabot> Title: Yi - HaskellWiki
21:44:23 <TSC> codacola: Probably just regular hugs then (:
21:44:28 <codacola> morning _zenon_
21:44:30 <_zenon_> jeffwheeler, I never got Yi to build properly =(
21:44:36 <_zenon_> codacola, good morning to you
21:44:48 <jeffwheeler> _zenon_: I have on occasion, but I'm still having problems with it
21:44:49 <codacola> _zenon_: almost finished my first haskell assignment :D
21:45:06 <jeffwheeler> _zenon_: knowing the architecture, it seems _so_ awesome, so I am really excited for its progress
21:45:12 <_zenon_> codacola, Great! :) Keep it up!
21:45:24 <newsham> > (length . B.unpack . encode) "test string"
21:45:35 <_zenon_> jeffwheeler, Yeah :) I have downloaded it 3 times and failed each time, but soon, soon it will work :]
21:45:38 <Trinithis> Out of curiosity: who prefers dark schemes over light schemes for your text environment?
21:45:39 <lambdabot>  thread killed
21:45:41 <hackage> Uploaded to hackage: RJson 0.3.5
21:46:04 <jeffwheeler> Trinithis: I do, most of the time; I think lambdabot can manage polls.
21:46:10 <_zenon_> Trinithis, dark, I'm using gedit with the oblivion scheme
21:46:20 <Trinithis> I like dark
21:46:27 <codacola> _zenon_: sadly my next one will have little to do with haskell, by that stage we're moving onto prolog
21:46:35 <Trinithis> I custom made my haskell scheme
21:46:45 <TSC> Nothing sad about prolog
21:47:07 <jeffwheeler> TextMate has some really great themes; I moved one (light) one into Emacs
21:47:25 <codacola> curious, is it possible to use prolog along with C?
21:47:44 <newsham> Data.Binary encodings of String are pretty large (space wise)
21:47:57 <TSC> I think some prolog systems can call C functions (like in Haskell)
21:48:03 <jeffwheeler> Does anybody know how to pronounce Yi? The wiki page just says "yi" as an explanation. :P
21:48:20 <sarehuu> the way you pronounce Vi
21:48:23 <newsham> (length . unpackBS . encode) $ "Test" --> 12
21:48:44 <jeffwheeler> sarehuu: hm, okay
21:48:56 <codacola> TSC: i was thinking the other way around. calling a prolog fact and having its result returned
21:49:12 <sarehuu> :P.  It probably rhymes with "we"
21:49:14 <TSC> Oh, probably
21:49:15 <codacola> oops, query
21:49:27 <newsham> I guess because I'm on a 64-bit cpu, its storing strlen as 8bytes.
21:49:30 <newsham> *sigh*
21:49:32 <jeffwheeler> That's how I've said it.
21:49:54 <codacola> TSC: i was thinking about how itd be used with hobby robotics.
21:50:59 <codacola> how sad. tried to start an editor argument on the universites forum. no ones bitten :(
21:51:19 <codacola> someone wrote a thread suggesting people should use notepad++ instead oif notepad, i suggested they should use vim
21:51:50 <jeffwheeler> codacola: not Emacs? ;)
21:51:58 <codacola> jeffwheeler: is there an emacs for windows?
21:52:10 <jeffwheeler> codacola: yes, but no need to discuss editor wars here
21:52:49 <codacola> im mostly just using vim for the line numbers at the moment
21:52:53 <codacola> counting 200 lines got annoying
21:53:08 <codacola> error....line 200...."ah crap"
21:55:00 <chrisdon1> use the "go to line number" shortcut?
21:56:21 <Trinithis> This is what my coloring looks like: http://img.photobucket.com/albums/v251/Trinithis/haskell.gif?t=1216961749
21:56:23 <lambdabot> http://tinyurl.com/666ac2
21:59:01 <chrisdon1> tinithis: I would have a dark theme but when I open my browser I am blinded by the whiteness
21:59:02 <jeffwheeler> I can't seem to compile the zlib 0.4.0.4 from Hackage on OS X (Leopard). I'm getting some C errors when I do: http://pastie.org/240810
21:59:03 <lambdabot> Title: #240810 - Pastie
21:59:37 <Trinithis> chrisdon1: lol
21:59:41 <jeffwheeler> Does the zlib in Hackage depend on some original C zlib that it sits on top of?
21:59:57 <codacola> chrisdon1: doesnt exist in notepad, but also enjoying the syntax highlighting of haskell now
22:00:20 <chrisdon1> codacola: it does exist in notepad, try Ctrl-H
22:00:52 <chrisdon1> codacola: â€œHâ€ as in â€œGoâ€ (obviously, right? O_O)
22:00:54 <codacola> thats "replace"
22:01:14 <codacola> yeah, as obvious as v for paste
22:01:16 <chrisdon1> codacola: ah, so it is. â€œHâ€ as in â€œReplaceâ€ then
22:01:50 <jeffwheeler> Recompiling zlib from scratch and installing (just got it from their site) doesn't help at all.
22:01:53 <chrisdon1> codacola: but V is conventient, H isn't
22:02:23 <codacola> kinda
22:03:16 <codacola> only ctrl shortcuts i really use are c v and x, so theyre all convenient for me :P
22:03:19 <chrisdon1> well, I use both hands for press two keys at once to avoid horrible injuries, but apparently it's convenient
22:04:10 <codacola> thats a good question. how common is it for programmers to screwup their hands before their 40s?
22:04:33 <cjb> Don't think it's particularly common.
22:04:52 <hml> @hoogle remove duplicate
22:04:53 <lambdabot> Did you mean: Remove Duplicate
22:04:53 <lambdabot> Prelude.undefined :: a
22:04:53 <lambdabot> Test.QuickCheck.Batch.bottom :: a
22:04:54 <newsham> jeff: what if you runhaskell Setup.hs clean first?
22:05:02 <codacola> didnt stallman damage his so badly he couldnt code anymore?
22:05:07 <hml> @hoogle Remove Duplicate
22:05:08 <lambdabot> No matches, try a more general search
22:05:15 <hml> @hoogle duplicate
22:05:15 <lambdabot> No matches found
22:05:29 <hml> no built in functions for taking a list and removing all duplicates?
22:05:35 <chrisdon1> nub
22:05:43 <chrisdon1> > nub [1,1,1,2,3,3,5]
22:05:47 <lambdabot>  [1,2,3,5]
22:05:47 <codacola> heh something i always found amussing. when i was actually taught how to type i used my fingers completely differently to how i was "meant to"
22:05:52 <geezusfreeek> back and eye problems are much more common i think
22:06:16 <hml> chrisdon1: thanks
22:06:23 <newsham> code: i'm past mid 30s and still going.
22:06:43 <codacola> one example being i never use my pinkies for typing
22:06:46 <newsham> some peole get wrist problems.
22:06:51 <chrisdon1> codacola: that's right. I used to â€œfreestyleâ€, and achieve 90wpm easily, but after 12 hours it starts to give real pains, which is why I used KTouch to learn how to touch type properly
22:07:25 <codacola> ive no idea how fast i type, but yeah, never had to type for that long at once either
22:08:30 <codacola> chrisdon1: how long did it take you to "relearn" to type?
22:08:58 <chrisdon1> codacola: about a week. it's frustrating when trying to talk to people but other than that, it's okay
22:09:46 <chrisdon1> codacola: it also made my wrists and fingers ache because you have to have stronger fingers
22:09:57 <codacola> lately im finding it annoying moving onto a new keyboard, the keys are slightly differently spread out so i keep making typos
22:10:22 <geezusfreeek> i've thought about trying dvorak or colemak or something, but i have to switch around among many computers every day :(
22:10:38 <sarehuu> colemak is fake, dvorak is fun
22:10:47 <codacola> geezus?
22:10:49 <chrisdon1> yeah. I tried dvorak for a week and then went on my friend's computer and couldn't type
22:10:49 <geezusfreeek> colemak is "fake"?
22:10:50 <hml> is // meant to be slow?
22:11:01 <hml> is Data.Array.// meant to be slow? (it says reconstruct the array
22:11:35 <codacola> ah heh, thought you lot were talking about some program :P
22:11:51 <codacola> looks similiar to my old atari keyboard
22:12:34 <codacola> http://brej.org/atari/atari9.jpg <- thats what i had when i was 4 :D
22:12:46 <hml> codacola: wait; you don't use your pinkies for yping ?
22:12:49 <chrisdon1> hml: well, it's O(n)
22:12:51 <sarehuu> hml yes it's slow -- you can't modify arrays in place
22:12:57 <codacola> nope
22:13:09 <_zenon_> ooooh! Time for some lambda coffe!
22:13:10 <codacola> hml: not that i know of
22:13:16 <codacola> nor my  thumbs
22:13:20 <chrisdon1> codacola: learning correct finger positioning would probably make your fingers ache then
22:13:23 <hml> chrisdon1 sarehuu ... hmm, i'm doing this mesh library in haskell ; i really need to  modify arrays in place; what should I do?
22:13:33 <hml> codacola: how do you hit space, and shift key?
22:13:35 * _zenon_ goes for a hot cup o' coffee
22:13:36 <sarehuu> use a version that can be, like IOArray :)
22:13:43 <chrisdon1> hi zenon
22:13:53 <codacola> ill try learnignt he correct way during the holidays and see how it goes :P
22:14:13 <sarehuu> hml: see Data.Array.IO, or maybe Data.Array.ST for STArrays
22:14:24 <codacola> writing by hand is one thing that makes my wrists ache. usualy during an exam
22:14:39 <codacola> i dont write by hand much nowadays, so writing non stop for 3 hours is kinda different
22:15:04 <geezusfreeek> yeah i get cramps writing with pencil or pen in my hands really quickly
22:15:07 <chrisdon1> Russell handwrote some 2,000 words per day in his papers and it was usually the final draft
22:15:47 <chrisdon1> now *that* is clarity of thought
22:16:08 <codacola> thats a lot
22:17:49 <chrisdon1> "From his adolescent years, Russell wrote about 3,000 words a day, with relatively few corrections; his first draft nearly always was his last draft, even on the most complex, technical matters. His previously unpublished work is an immense treasure trove, and scholars are continuing to gain new insights into Russell's thought."
22:17:54 <chrisdon1> <3
22:17:55 <_zenon_> hi chrisdon1 :) Sorry, was out for coffee
22:18:07 <hml> which russel is this?
22:18:13 <chrisdone> Bertrand
22:18:20 <hml> the mathematician?
22:18:27 <chrisdone> yeah
22:18:56 <_zenon_> I read the wikipedia article on Erdos. That was one special man :)
22:20:09 <codacola> oh something ive always been curious about. wasnt sure if this was pure fiction or not. they mentioned someone in startrek having proved something, but the proof couldnt be found among his things. just the theorem and at the end "proven", ring any bells?
22:20:57 <sarehuu> fermat's last theorem?
22:21:22 <trez> classic episode :)
22:22:03 <codacola> thatd be it, thanks
22:24:10 <codacola> cant even remember what that episode was about. just remember the captain explainign that one of his hobbies was to try and prove it
22:24:55 <jberryman> anyone seen the dicumentary on Feinman, called "the pleasure of finding things out"?
22:25:33 <jberryman> um... "documentary". although dickumentary has porno name potential for sure
22:26:05 <_zenon_> codacola, that's humour :) My favourite thing in Voyager is that Captain Janeway is such a clichÃ© , Her "hero" since childhood was Davinci, she always read his works and reproduced them. She got all top marks, etc, etc, etc.
22:26:07 <wkh> is there any way to introspect values that are declared in a file? like, say you create 3 different variables, each of which are instances of a reord.. is there any way you could programmatically find out which ones those are?
22:26:26 <wkh> like, anything similar to how in Prolog you can have propositions or facts declared and then query those
22:26:37 <wkh> without the propositions you declare having to know anything about what you want to do with them
22:26:48 <glguy_> wkh: no
22:27:20 <glguy_> might be something hidden away in the ghc api
22:27:28 <wkh> glguy_: what would be the closest approximation you could do?
22:27:40 <jberryman> ugh, I also spelled Feynman's name wrong.
22:27:50 <glguy_> make a list of the values you'd defined somewhere
22:28:45 <wkh> sad because i love how expressive and composable haskell is
22:28:55 <chrisdone> _zenon_: met up with a friend from college a couple days ago and collaborated on solving this problem of how to algorithmically layout a network diagram with the best visibility. I really enjoyed it. sitting at a cafe with papers and pens and bouncing ideas is so fun
22:29:01 <wkh> you couldn't even work out some kind of bad hack with template haskell?
22:29:27 <_zenon_> chrisdone, ooooo! *envied* sounds great!
22:29:38 <chrisdone> :]
22:29:50 <_zenon_> chrisdone, that's  quality friendship time
22:29:56 <chrisdone> _zenon_: hehe, yep!
22:32:14 <_zenon_> chrisdone, what did you come up with? I have only mentally tried out the idea of such a thing, it involved a penalty measure of # of lines intersecting (calculated with raytracing) and a mixture of genetic a algorithm where the chromosome was the pair of coordinates of all nodes
22:32:35 <_zenon_> of genetic a => of a genetic
22:32:45 <wkh> _zenon_: isn't there prior art here with respect to graph drawing?
22:33:22 <_zenon_> wkh, I only recall someone showing a "social" network built from the IRC logs.
22:33:34 <wkh> http://en.wikipedia.org/wiki/Force-based_layout
22:34:58 <glguy_> we had a script running in this channel that drew the conversation graph
22:35:06 <_zenon_> wkh, Thanks :) Nice link!
22:35:08 <chrisdone> _zenon_: right, we accepted that there are cases where it's impossible to avoid line intersection, but we reduced lines which were on very similar paths by "shuffling" the nodes about
22:35:23 <QtPlatypus> The standard drawing graphs from data is typically dot (aka graphviz)
22:36:21 <codacola> oh something i asked the other day (got no reply), has anyone here used hsdl? (sdl for haskell)
22:36:40 <_zenon_> chrisdone, sound reasonable, like the node switching in TSP problem ?
22:37:28 <chrisdone> _zenon_: how does that work?
22:38:16 <_zenon_> chrisdone, when searching for shorter paths, you may sometimes switch the position of two nodes in the path and see if this reduced the total path length
22:38:27 <chrisdone> _zenon_: ahhh, right!
22:39:17 <chrisdone> _zenon_: that's a good idea
22:39:36 <_zenon_> wkh, chrisdone , this graph layout thing is really interesting! It's also worthwhile to think about what actually defines a visibly pleasing graph
22:39:50 <glguy_> @seen dons
22:39:50 <lambdabot> dons is in #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 2h 16m 14s ago.
22:40:00 <wkh> fyi sipping coffee and tinkering with neat experimental algorithms is more fun than writing boring business apps in ugly languages for mediocre firms
22:41:31 <wkh> also using fancy words and typing wiht a very focused look on your face in a cafe makes you look and sound very smart.
22:41:34 <chrisdone> _zenon_: right! that's what we spent most of our time doing, actually, defining what would be the best looking graph
22:41:40 <O_4> codacola: I just tried using it earlier, though it looks like I way need to do some magic to get it working on OS X.
22:42:11 <chrisdone> wkh: well, we weren't typing. just writing and drawing all over eachother's notes
22:42:53 <_zenon_> What actually tops that is to stand in a lecture room (with an old chalk board) and discuss your algorithms with a piece of white chalk .)
22:43:06 <chrisdone> hehe
22:43:17 <chrisdone> _zenon_: I bought a mini whiteboard. <33
22:43:19 <_zenon_> chrisdone, still, those are the moments that can keep you up all night
22:43:37 <chrisdone> _zenon_: indeed
22:43:56 <_zenon_> chrisdone, Nice! Me and my (soon to be) wife also bought one (quite a while ago), but now it's mostly littered with papers, notes and remember-this and that.
22:44:16 <chrisdone> _zenon_: hehe. congrats
22:44:24 <_zenon_> The main idea was that we would use it for equations etc. :)
22:44:28 <chrisdone> yeah
22:44:31 <_zenon_> thanks.
22:44:57 <chrisdone> speaking of "all night". it's 6:45AM. time for bed
22:45:00 <chrisdone> night chaps
22:45:37 <_zenon_> goodnight
22:50:22 <hml> how can i get rid of the let/in in the followikng:
22:50:23 <hml> main = let ok g = print $ fst $ makeRandomValue g in getStdGen >>= ok
22:51:47 <Korollary> ok = print $ fst $ makeRandomValue
22:51:54 <Korollary> so just put that after >>=
22:52:55 <jeffwheeler> I'm having trouble again with calab-install; I'm still getting "cabal: recv: resource vanished (Connection reset by peer)" when doing "cabal update". I think it might be something with my network setup, because it doesn't work on either my wireless OS X (Leopard) machine, or my Debian machine hard-wired.
22:53:02 <codacola> "given a function f of type Int -> Int  give a recursive defiition of a function of type Int -> Bool which on input n returns true if one or more of the values f0, f1, ...fn is zero and false otherwise
22:53:17 <codacola> does that sound like im meant to define f myself or wriote a function which takes a function f as an argument?
22:53:39 <jeffwheeler> I'm merely connected to a NETGEAR prosumer router which functions perfectly normal all other times.
22:53:55 <jeffwheeler> (I.e., this is the only problem I could be having with it, if that is to blame.)
22:54:19 <chrisdone> _zenon_: before I go, the idea of using a web page with user-driven up/down modding could potentially be useful for genetic algorithms... hmm :) anyway, I'm out :P
22:55:10 <jeffwheeler> Is cabal using plain HTTP on port 80?
22:55:14 <Saizan_> Korollary: s/$/./g
22:55:59 <_zenon_> okay :) See you
22:56:14 <codacola> i have to admit, i hate the look of haskell code once its finished :P
22:56:21 <codacola> its fun to write in, horrible to look back at
22:58:03 <jeffwheeler> I can access the archive page that cabal-install prints out fine within a browser.
23:00:36 <Saizan_> jeffwheeler: cabal upload just uses a POST request
23:01:33 <jeffwheeler> Saizan_: I'm not even doing an upload --- just updating for the first time.
23:01:49 <jeffwheeler> On both my (rather different) machines, it fails with the same error message.
23:01:51 <Saizan_> jeffwheeler: oh, sorry misread
23:02:11 <jeffwheeler> Saizan_: no problem
23:02:29 <hml> :t getStdGen
23:02:31 <lambdabot> IO StdGen
23:02:35 <jeffwheeler> The one thing I find Googling, although I doubt this is right, is not having a user-agent specified
23:04:10 <dons> codacola: why's that?
23:04:19 <dons> not enough { ;; } ?
23:04:31 <codacola> yeah, i miss my {;;}
23:04:33 <dons> glguy_: pong?
23:04:46 <dons> codacola: you could be kinda retro and use explicit layout syntax..
23:04:48 <codacola> http://hpaste.org/9155 <- thats what my file contains so far
23:05:08 <dons> > do { y <- return 2; return 7; } :: Maybe Int
23:05:10 <lambdabot>  Just 7
23:05:25 <m3ga> people, what library has module Language.Haskell.Pretty?
23:05:34 <dons> m3ga: check in hayoo.
23:05:45 <dons> m3ga: http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:05:46 <lambdabot> Title: Hayoo!
23:05:56 <dons> codacola: oh, we can do better here.
23:06:27 <codacola> hm?
23:07:13 <dons> so, for one, you're using too many parens. that's ok, but it looks better with minimal parens
23:07:20 <dons> let me give some examples on the paste.
23:07:45 <dons> and a little more white space can help, and a little less double spacing
23:08:00 <dons> good haskell style looks like modern poetry.
23:08:23 <dons> the use of 'where' can clean up your guards.
23:09:11 <_zenon_> I would love the program language that looks like Haiku
23:09:20 <codacola> curious, do you prefer patern matching over using guards when possible? eg if an input could have 2 possible values, would you use a guard or 2 function definitions?
23:09:47 <dons> i use guards for booleans
23:09:53 <dons> and patterns for more complicated control flow
23:10:36 <codacola> oh something you might be able to help me with. with these "backup cds" that you have to write yourself, do you need the backup partition to use them? eg once ive made them can i remove that partition?
23:10:50 <dons> also, recognising some recursion schemes will help.
23:11:00 <dons> formatLines looks like concatMap to me.
23:11:37 <codacola> yeah i wasnt going to use explicit recursion there, but figured i better go with whats been covered in class
23:11:37 <dons> makeTotal is sum . map snd
23:12:31 <dons> boolToInt a | a == True = 1 | otherwise = 0
23:12:33 <dons> is interesitng.
23:12:39 <dons> codacola: since that's fromEnum
23:12:43 <dons> > fromEnum True
23:12:47 <codacola> ah
23:12:53 <lambdabot>  1
23:12:54 <dons> also, matching for == True is redundant
23:13:10 <dons> so a minimum is  boolToInt True = 1 ; boolToInt _ = 0
23:13:11 <dons> for example
23:13:14 <codacola> some exercise was annoying me. i forget what it was, but it ended up being a simple case of adding the boolean values, so i made up that definition :P
23:13:17 <dons> but its really just fromEnum :)
23:13:59 <dons> addZeros is a fold.
23:14:08 <Saizan_> (== True) === id, anyway
23:14:17 <dons> oh, and unfold
23:14:34 <dons> actually, no, its weird.
23:14:39 <dons> you're using an Int to count down the length of the list
23:14:47 <dons> instead of guarding on the structure of the list?
23:15:07 <dons> ah no! you're dropping n, and padding with 0s
23:15:21 <dons> addZeros x count | count <= 0 = x | otherwise  = addZeros (0:x) (count-1)
23:15:24 <codacola> again dont wanna use a fold just incase. the first mention of fold is in chapter 10, we're only covering the first 7 chapters, no idea what we're covering before the assignments due
23:15:38 <dons> so that's, what, addZeros xs n = repeat n 0 ++ drop n xs
23:15:39 <dons> ?
23:15:50 <codacola> now im confused
23:15:54 <dons> well, doesn't hurt to learn the language :)
23:15:59 <dons> you'll know a few more tricks.
23:16:06 <dons> > drop 3 "haskell"
23:16:12 <lambdabot>  "kell"
23:16:16 <dons> > repeat 3 '#' ++ drop 3 "haskell"
23:16:17 <lambdabot>  Couldn't match expected type `Char -> m'
23:16:18 <codacola> heh no, ive been learning more than i have to. but for now i just wanna use whats we're covering in class
23:16:22 <dons> > replicate 3 '#' ++ drop 3 "haskell"
23:16:23 <lambdabot>  "###kell"
23:16:45 <dons> list things involving lengths are often better done as drops and takes
23:16:48 <dons> > take 3 "haskell"
23:16:49 <lambdabot>  "has"
23:16:58 <wkh> dons, if you wanted to imitate prolog's database facilities in haskell, what would you do?
23:17:07 <wkh> like, stating symbolic facts that are standalone, that can be queried.
23:17:14 <dons> wkh: hmm.
23:17:30 <dons> doing any resolution on the facts, or just looking up key/values?
23:17:36 <dons> you need logic?
23:17:48 <wkh> mostly just using them as a pretty metadata syntax
23:17:51 <wkh> one that's better than XML.
23:18:07 <dons> maybe just Data.Map then?
23:18:12 <wkh> or alternatively, cna you think of a way to supply lots of declarative metadata in haskell that's pretty
23:18:18 <wkh> hm.
23:18:22 <dons> codacola: oh, addColumns is nice.
23:18:29 <dons> codacola: that's zipWith (+)
23:18:38 <dons> > zipWith (+) [1..10] [11..20]
23:18:40 <lambdabot>  [12,14,16,18,20,22,24,26,28,30]
23:18:53 <dons> i.e. the list you get when you pair each element with the (+) operator.
23:20:07 <dons> carry is interesting. is that map (+1) xs ++ [1] ?
23:20:12 <newsham> what does Data.Binary.decode do when the data is malformed (ie. EOF?)
23:20:19 <dons> newsham: error
23:20:40 <wkh> you get nothing. you lose. good day, sir.
23:20:41 <dons> codacola: there's my code review for you, http://hpaste.org/9155#a1
23:21:16 <dons> codacola: basically, a more idiomatic formatting (less parens, better spacing), and the odd higher order function to clean up some of the recursion.
23:22:47 <dons> haskell: new programming for a changing world.
23:23:03 <paolino> :t read <$> getLine
23:23:05 <lambdabot> forall a. (Read a) => IO a
23:24:11 <wkh> dons: from my limited experience in industry, the IT world changes at a snail's pace
23:24:32 <wkh> "this is the way we've always done it so let's pucker our assholes whenever something different comes along"
23:24:52 <codacola> love this idea of keeping all of my assignments on a thumbdrive
23:24:59 <newsham> IO: new World for changing programmers.
23:25:26 <dons> newsham: :)
23:25:38 <dons> codacola: did you have a look over the annotation?
23:25:42 <paolino> if I run read <$> getLine  I have a Ambiguous type error, if I run map read <$> words <$> getLine I have a runtime error
23:26:05 <newsham> x <- read <$> getLine :: IO Int
23:26:23 <paolino> without annotation I mean
23:26:29 <codacola> dons: the next chapter for me to go over (skimmed it earlier on, want to reread it) is higher order functions and folding
23:26:30 <Saizan_> ?ty map read <$> words <$> getLine
23:26:31 <lambdabot> forall a. (Read a) => IO [a]
23:26:38 <newsham> so unambiguate it with annotation
23:27:04 <paolino> I was asking why different errors
23:27:05 <dons> codacola: is this an introductory programming class? or introduction to FP?
23:27:10 <Saizan_> paolino: in the second case you're hitting defaulting, was it in ghci?
23:27:11 <codacola> dons: ill look soon enough, finally finished something thats been bugging me
23:27:19 <paolino> yes
23:27:36 <codacola> its a 2nd year class. the point is to introduce us to "other kinds of programming", eg to get away from imperial programming
23:27:39 <paolino> Saizan_: thanks
23:27:47 <dons> imperial programming :)
23:27:57 <_zenon_> for the empire!
23:28:00 <wkh> being comfortable with explicit recursion is the first step
23:28:04 <_zenon_> crush those filthy lisp rebels!
23:28:21 <wkh> learning shortcuts to rid yourself of what winds up looking like boilerplate is the next step
23:28:23 <dons> yeah, definitely good to know how to recurse over a data structure, instead of a for loop with ints to simulate that.
23:28:36 <dons> so you're on track, codacola
23:28:47 <_zenon_> True imperial programming is best performed in India, sitting on a porch, with a cup 'o afternoon tea
23:29:10 <wkh> dons: do you have any project ideas for intermediate-advanced haskell users?
23:29:46 <dons> wkh: hmm. more networky things, more protocol implementations, more parsers and pretty printers.
23:30:03 <wkh> parsers and pretty printers for what?
23:30:12 <dons> data formats, primarily.
23:30:16 <codacola> ok tahts not the right word, and cnt think of a better word right now but anyways :P assuming i continue on learning about functional programming, is there actually a future in it? or still an academic subject?
23:30:35 <_zenon_> codacola, JaneStCapital
23:30:47 <_zenon_> http://www.janestcapital.com/
23:30:48 <lambdabot> Title: Jane Street Capital, LLC
23:31:03 <dons> codacola: yeah, its growing. mainly as imperative programming runs up against multicore machines.
23:31:08 <wkh> codacola: the latest release of Visual Studio and .NET has elements of functional programming, but OOP languages with an imperative core rule industry
23:31:12 <dons> its hard to program large concurrent systems with mutable state.
23:31:54 <dons> also, you'll be on the cutting edge of new programming styles, rather than boring old java land.
23:32:12 <dons> so if you want to deeply understand programming, FP will help, no matter what you use in the end.
23:32:22 <_zenon_> I agree
23:32:38 <wkh> learning how to implement a program using the least amount of mutable state necessary will make you write better code in java.
23:32:55 <dons> you might be able to write scalable java :)
23:32:57 <matt_estes> I will second that(much better Java code)
23:32:57 <codacola> heh, why use java as an example? :P
23:33:03 <newsham> -- | Make a logger daemon and return a handle to it.
23:33:45 <codacola> dons: and yeah, thats what we were told in the first lecture. itll help change our mindframe for any programming language
23:34:13 <dons> if you really get into typed, purely functional programming, most programming languages will look like toys.
23:34:20 <newsham> oops, sorry
23:34:33 <wkh> dons: you said something about pasers and pretty printers for data formats. what data formats?
23:34:36 <dons> in that you'll be able to understand their workings easily.
23:34:45 <dons> wkh: common ones of interest :)
23:34:47 <codacola> guess i should spend some time using c# again, wont be long before i have a c# assignment
23:34:51 <wkh> dons: any examples?
23:35:04 <dons> hmm. python has a 'config parser' in the core library
23:35:12 <dons> for whatever the standard config format on unix is.
23:35:14 <dons> that's a missing piece.
23:35:37 <dons> as haskell's rather good at translation, more parsers and pprs to enable those translations makes sense.
23:35:43 <dons> Language.C et al are huge pieces here.
23:36:08 <dons> btw, for   those who haven't seen it, this 1975 ibm advert is fun, http://www.squareamerica.com/ib.htm
23:36:09 <lambdabot> Title: IBM Slides
23:36:15 <dons> particularly http://www.squareamerica.com/images5/ib7.jpg
23:36:20 <wkh> Data Base.
23:36:50 <wkh> prescient of them to anticpate boxing and unboxing.
23:37:15 <dons> ONLINE...
23:39:26 <sm> speaking of parsers..
23:39:38 <sm> am I right to think parsec a http://en.wikipedia.org/wiki/Parsing_expression_grammar parser ?
23:39:39 <lambdabot> Title: Parsing expression grammar - Wikipedia, the free encyclopedia
23:41:04 <codacola> dons: do you think learning and using more advanced haskell will simply improve my ability to use the basics, or for the sake of the exam should i stick to just using the basic stuff for now?
23:41:23 <sm> after trying to use parser frameworks in other languages, I truly miss it
23:41:35 <dons> its not a PEG , no, sm. Isn't frisby a PEG parser?
23:41:54 <wkh> codacola: in the short term, focus on what you know will be on your exam
23:42:03 <sm> so it is.. thanks for the pointer
23:43:22 <sm> specifying a parsec parser feels like specifying a PEG, from what I can see
23:43:37 <dons> codacola: i'd encourage you to code in your spare time, by the exam you'll know the whole thing inside out. write lots of programs. the more the better.
23:45:47 <codacola> hate this idea of writing programs on paper for the exma, though unsure how worried they are about exact syntax
23:46:33 <dons> the more real programming, with feedback from the system (i.e. ghci) , the better, i reckon. i can't stress that more. programming is an activity. it's hard to get anywhere on paper
23:47:00 <wkh> most CS TAs are dickheads
23:47:21 <sm> golly.. haskell is so much richer in parsers, I may have to switch back from scheme for this project
23:47:29 <wkh> at my university they asked tons of bullshit pointless questions that had nothing to do with what i majored in CS for, which was to write useful programs that did interesting complicated things
23:47:50 <wkh> buncha pedantic bullshit, all run by blub fucktards
23:47:58 <wkh> bah.
23:48:01 <codacola> heh in my last exam they werent worried about syntax at all. they went so far to say we dont have to memorize all of the classes and functions we'd be using, just to remember the general idea
23:49:24 <codacola> though that was a 101 class, unsure waht they expect from their 2nd year students (in reality im not, still a first year,but took a 2nd year class anyway)
23:49:53 <wkh> codacola: what the course probably won't get across to you is that haskell offers powerful tools for creating domain specific languages. DSLs are a hot topic right now
23:50:00 <wkh> and Ruby does not have a monopoly on them.
23:50:28 <codacola> probably not, ive already covered everything we have to cover for haskell
23:50:29 <Saizan_> sm: parsec is a recursive descent parser so it's similar, the main difference is that (a <|> b) fails if a consume any input before failing, i.e. no unlimited lookahead
23:50:33 <codacola> next topic is prolog
23:50:47 <Saizan_> sm: but you can use (try a) if you want it
23:51:22 <sm> thanks Saizan_ , that helps
23:51:36 <wkh> codacola; they won't have time to talk about how prolog is homoiconic like lisp and allows for all kinds of interesting metaprogramming opportunities. both of those will let you use advanced technologies that are on the rise in a much more informed manner.
23:52:17 <mgdtgd> hello
23:52:22 <wkh> hi
23:52:28 <mgdtgd> I've just copy&pasted some code from the wiki
23:52:35 <mgdtgd> but it doesn't compile
23:52:48 <mgdtgd> from there
23:52:49 <mgdtgd> http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell#Extending_the_CGI_monad_with_monad_transformers
23:52:51 <lambdabot> Title: Practical web programming in Haskell - HaskellWiki, http://tinyurl.com/2n99cj
23:53:16 <mgdtgd> ghci complains about the whole deriving thing
23:53:20 <codacola> wkh: most likely not, but theres no reason i cant study it by myself later on :P
23:53:46 <mgdtgd> Is this an error on my part, or is the code wrong?
23:53:47 <codacola> next semester i get to use assembly :D
23:54:21 <wkh> assembly is good mental preparation if you ever have to write GUI automation scripts.
23:54:41 <wkh> to automate programs with no command-line interface or API/SDK
23:55:17 <codacola> and what exactly is c# good for? (ok yeah i know, but i still prefer c)
23:55:27 <mgdtgd> learning assembly is like learning C only much much worse
23:55:37 <wkh> C# and .net is better than VB6 and COM
23:55:37 <Saizan_> mgdtgd: it's using an extension, put {-# LANGUAGE ExtendedNewtypeDeriving #-} at the top of your file
23:56:05 <wkh> no DLL hell, no byzantine COM complexity.
23:56:48 <prb> Question about Control.Exception.catch â€” does laziness mean that the catch is only effective if the exception is produced within the scope of that function's evaluation?  (Hopefully that makes sense...)
23:57:57 <prb> I ask because it seems like a call to error is bypassing a C.E.catch that should trap it.  (This is in a multithreaded app.)
