00:01:18 <skorpan> Trinithis: parsec?
00:01:24 <skorpan> LBNF/BNFC?
00:01:44 <Trinithis> Im using parsec
00:02:17 <Trinithis> What is lbnf and bnfc?
00:02:43 <skorpan> LBNF is a fort of BNF (Backus-Naur form, IIRC) and BNFC converts LBNF into haskell parsers
00:02:52 <skorpan> automagically!
00:02:59 <Trinithis> A tool?
00:03:03 <skorpan> yes
00:03:08 <skorpan> BNFC stands for BNF converter
00:03:11 <Trinithis> Got a link?
00:03:20 <skorpan> http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/
00:03:23 <lambdabot> Title: The BNF Converter
00:04:14 <Trinithis> I'll have to try this puppy out. Thanks
00:10:26 <ski> halberd : you could try factoring `stepBoard b (x, y)' in the recursive equation of `stepBoard'
00:10:53 <ski> (personally, i'd express several other things differently, as well)
00:12:05 <halberd> thanks ski I did that and it worked, but I'm not sure why
00:12:39 <halberd> why does it matter anyway, shouldn't Haskell be able to factor the repeated sub-expression by itself?
00:13:30 <ski> possibly ghc can do that for you, if you compile with some optimization flag
00:13:42 <ski> generally, it isn't possible, though
00:14:21 <ski> in any case, i'd not have an `\= Nothing' test at all there
00:14:36 <ski> possibly `catMaybes' instead .. or something better
00:14:38 <halberd> I switched it to filter (/= Nothing) outside
00:14:48 <ski> @type catMaybes
00:14:49 <lambdabot> forall a. [Maybe a] -> [a]
00:17:39 <ski>   b <- (filter (validMove (r, c)) [markSquare b ((r, c), i) | i <- b ! (r, c)]),
00:17:43 <ski> can be rewritten as
00:17:58 <ski>   b <- [markSquare b ((r, c), i) | i <- b ! (r, c)],
00:18:07 <ski>   validMove (r, c) b
00:18:41 <ski> and you could remove the list comprehension here, too, if you want
00:19:09 <ski> i'm not sure yet if it's good to have this mix of lists and `Maybe's that you do
00:19:49 <ski> actually, isn't the base case just a special case of the recursive case ?
00:20:10 <halberd> no because greaterMoves returns nothing when you get to (8,8)
00:20:12 <ski> hm ..
00:20:20 <halberd> I mean it returns []
00:20:41 <halberd> so solutions in the recursive case would be [] when you get to (8,8) so you have to handle (8,8) specially
00:21:00 <ski> yes, you're right
00:22:54 <halberd> although actually, the base case could just be "Just b"
00:23:11 <halberd> nah it couldn't because it could fail
00:23:15 <ski> is it intended that in each step, you may skip any number of coords, and continue after those ?
00:24:01 <halberd> you know (8,8) has either 1 or 0 possibility when you get to it so I could simplify that test to not $ null $ b ! (8,8)
00:24:06 <ski> (i don't know .. but i have a feeling one could possibly restructure the base case so that it doesn't have to duplicate code from the recursive case)
00:24:40 <ski> well, how about the skipping .. was it intended ?
00:25:14 <halberd> what do you mean by skipping
00:25:23 <ski>   (x, y) <- greaterMoves (r, c),
00:25:42 <ski> this will get `(x, y)' to be any "greater" coord than `(r, c)'
00:26:00 <halberd> yes
00:26:04 <ski> i wonder if there's a reason not to take just one step forward each time
00:26:13 * ski doesn't remember very much about solving sudoku(?)
00:26:21 <halberd> because the next move ahead might not work so in that case you have to take the move that's 2 ahead
00:26:23 <halberd> and so on
00:26:36 <ski> why might it not work ?
00:26:41 <halberd> hmm
00:26:52 <halberd> yes actually you're right
00:26:58 <ski> if you skip it now, you won't revisit it later
00:26:59 <halberd> greaterMoves is unnecessary
00:27:06 <ski> .. that's why i was wondering
00:27:16 <halberd> because if the next square fails then you know all of the others will fail too
00:27:35 <ski> (that may be .. i have no idea :)
00:29:26 <halberd> well if you know that no matter what you fill in for the next square, you can't solve the puzzle
00:29:34 <halberd> then it doesn't matter what you can fill in for the square 2 ahead
00:29:41 <ski> ok
00:30:09 <paczesiowa> is there a tool for finding dependancies of a given function?
00:30:12 <ski> (so, probably your previous code could get false positives)
00:30:57 <ski> halberd : now, do you see any reason now to just use lists, and no `Maybe' at all (except maybe at the top) ?
00:31:14 <halberd> no it wouldn't the previous code would be fine just a little slower since it's always taking the head of the list
00:31:43 <halberd> it would actually be a lot slower if there's no solution
00:31:47 <halberd> but it wouldn't give a wrong answer
00:31:58 <ski> halberd : i was thinking of cases where there were no solutions .. couldn't possibly your old code claim there was a solution anyway, then (by skipping coords) ?
00:32:06 <ski> hmhm
00:32:37 <halberd> yes you're right
00:32:57 <ski> how about the `Maybe's, now ?
00:33:08 <ski> do you need them ?
00:33:28 <halberd> I need to return a Maybe Board because there might be no solution
00:33:53 <ski> well, you could return a list of solutions .. which could be empty
00:34:19 <halberd> huh I hadn't thought of that, and it wouldn't be inefficient because it would be computed lazily
00:34:21 <ski> but assume you want to return a `Maybe' solution .. then you could still just use lists inside, converting to `Maybe' just at the end
00:34:38 <ski> i think rewriting it like this could make the code clearer
00:34:48 <halberd> but you know it's not really an advantage
00:34:50 <ski> @type listToMaybe
00:34:51 <lambdabot> forall a. [a] -> Maybe a
00:35:05 <ski> why not ?
00:35:15 <halberd> a list is just like a maybe
00:35:35 <halberd> it's either [] which is like Nothing, or (x:xs) which is like Just x except it also has the extra xs
00:35:41 <ski> *nod*
00:35:43 <ski> so ?
00:35:56 <halberd> so I'm not sure it would simplify the code significantly to use a list
00:36:27 <halberd> but it would have the advantage of giving you more than one sol'n if there is one
00:36:45 <ski> it would remove this `if null solutions then Nothing else ...' and `\= Nothing' nonsense
00:37:56 <skorpan> hello
00:38:13 <ski> hej skorpan
00:40:56 <halberd> http://hpaste.org/9168#a1
00:42:26 <ski> `foldr (++) []' is concat .. but
00:42:59 <ski> better to put the `stepBoardList b (nextMove (r,c))' as a generator in the list comprehension
00:45:29 <halberd> what?
00:46:20 <halberd> what do you mean a generator
00:46:40 <halberd> nextMove (r, c) = if c < 8 then (c+1,r) else (0,r+1)
00:46:48 <solrize> @seen dcoutts
00:46:49 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 8h 49m 46s ago.
00:47:58 <ski> halberd : i need to ask one more thing .. the elements of the arrays are lists of numbers .. these represent possible values of the corresponding cell, or what ?
00:48:09 <halberd> yes that's what they represent
00:48:25 <halberd> and the board is solved when every cell has exactly one element in its list
00:49:03 <ski> so, when you come to the last cell, if there's a list of several values there, that means you get one solution for each of those values, right ?
00:49:31 <halberd> you can't get several values if you have come to the last cell because the other cells have crossed them out
00:49:42 <ski> ok, that may be ..
00:49:52 <halberd> if you have come to a cell that means you have already gotten down to just 1 value for every cell before that one
00:50:48 <halberd> and in the case of the last cell, that means that every other cell has been given a value, so the other 8 cells in its row or column have already gotten it down to 1 or fewer
00:51:11 <ski> *nod*
00:52:00 * ski 's making an annotation
00:56:10 <halberd> hmm something's screwy though, there's a bug somewhere
00:57:09 <mjrosenb> is there any program that does the equivalent of @pl?
00:59:32 <solrize> iirc pl is highly complicated but i think it's been released as a program
00:59:57 <mjrosenb> well someone implemented it at least for lambdabot
01:00:31 <ziman> not quite the thing you asked for, but if you don't want to spam here, you can query her
01:01:04 <solrize> no i think pl was implemented as a research project and then someone hooked it up to lambdabot
01:01:23 <mjrosenb> yeah, but once i've switched tabs to irssi, i tend to get distracted for long periods of time
01:01:31 <solrize> http://www.haskell.org/haskellwiki/Pointfree
01:01:32 <lambdabot> Title: Pointfree - HaskellWiki
01:02:06 <hackage> Uploaded to hackage: list-extras 0.2.0
01:02:32 <mjrosenb> also, what's the command that does (what seems like) the opposit of pl?
01:03:40 <solrize> unpl
01:03:54 <ski> halberd : http://hpaste.org/9168#a2
01:04:09 <solrize> "A stand-alone command-line version [of pl] is available at HackageDB (package pointfree). "
01:04:24 <dons> http://www.canonware.com/~ttt/2008/07/treaps-versus-red-black-trees.html is a little scary.
01:04:26 <lambdabot> Title: Transcendental Technical Travails: Treaps versus red-black trees, http://tinyurl.com/5zvdzl
01:04:35 <dons> "It took me about 90 hours to design/implement/test/benchmark left-leaning red-black trees, and less than 10 hours for treaps."
01:05:00 <dons> i think we could be talking about orders of magnitude faster implementations of those structures in haskell
01:05:56 <solrize> i saw a really cute GADT type for red-black trees that guaranteed balance
01:05:57 <mjrosenb> treaps are quite sexy
01:06:22 <mjrosenb> also red black trees LOVE disjunctive patterns
01:07:00 <dons> yeah.
01:07:25 <solrize> @goo treap
01:07:26 <lambdabot> http://en.wikipedia.org/wiki/Treap
01:07:26 <lambdabot> Title: Treap - Wikipedia, the free encyclopedia
01:08:20 <solrize> what's the purpose of a treap?
01:08:47 <solrize> i mean why the random priorities?
01:09:14 <mjrosenb> solrize: to attempt to make sure that the tree is balanced with a constant penalty
01:09:44 <mjrosenb> since heap insertion in constant time
01:10:12 <solrize> oh, it's not a balanced tree
01:10:17 <mjrosenb> it is
01:10:32 <mjrosenb> so if you have a balanced tree with n nodes
01:10:52 <mjrosenb> err
01:10:55 <mjrosenb> wait
01:10:58 <mjrosenb> i misread
01:10:59 <solrize> If priorities are non-random, the tree will usually be unbalanced; this worse theoretical average-case behavior may be outweighed by better expected-case behavior, as the most important items will be near the root.
01:11:00 <solrize> ic
01:11:12 <mjrosenb> yeah
01:11:33 <mjrosenb> it basically makes the worstcase harder to come by
01:13:30 <solrize> hey dons, when is that hackathon and are you still looking for library requests?
01:23:07 <augustss> howdy!
01:28:32 <solrize> hey augustss
01:41:03 <love^_^me>  .join /s hub.starfmradio.org we need new staFf local and glObal Ircop Servers admin  register ur favurite channels plz join us be  part of our admin thanks
01:41:07 <love^_^me>  .join /s hub.starfmradio.org we need new staFf local and glObal Ircop Servers admin  register ur favurite channels plz join us be  part of our admin thanks
01:41:09 <love^_^me>  .join /s hub.starfmradio.org we need new staFf local and glObal Ircop Servers admin  register ur favurite channels plz join us be  part of our admin thanks
01:41:53 <jpcooper> is the current version of haskell-mode still lacking the functionality to indent if statements properly?
01:59:21 <codacola> hello all
02:02:06 <Benigno> hi
02:02:09 <Benigno> ^_^
02:02:22 <codacola> hello
02:02:44 <Benigno> 34ºC >_<
02:02:56 <Benigno> I am melting x_x
02:02:58 <codacola> ??
02:03:01 <codacola> ah
02:03:06 <codacola> its raining here :(
02:03:18 <codacola> been raining for weeks :(
02:03:37 <Benigno> sweet sweet rain
02:03:41 <Benigno> xD
02:03:44 <Benigno> and fresh
02:03:47 <Benigno> xDD
02:05:10 <Benigno> codacola, which is the best Haskell IDE in your opinion?
02:05:28 <codacola> i dunno
02:05:33 <codacola> i havent used any of them
02:05:54 <Benigno> because I use winhugs + scitte, but I think ther must be a better option out there
02:06:07 <Benigno> do you develop in note pad?
02:06:10 <Benigno> xD
02:06:52 <glguy> most people use their favorite text editor, say vim or emac
02:06:53 <glguy> s
02:07:38 <codacola> vim and winhugs for me
02:09:43 <codacola> ugh, downloading ghc + hugs + ghc docs at 8kb/s
02:09:53 <Benigno> do the default emacs colour the texts and such stuff?
02:10:07 <codacola> vim detects haskell nicely
02:10:15 <Benigno> nice
02:10:23 <Benigno> maybe I will try it
02:10:33 <codacola> except i dont like its comment style
02:10:45 <codacola> i type -- then my comment, then when i push enter it puts in another --
02:10:55 <Benigno> O_o
02:11:00 <Benigno> weird xD
02:11:26 <codacola> yeah, given -- is meant to be for a single line comment
02:11:34 <Benigno> how are the comments in order to the haddock to use them?
02:12:02 <Benigno> is there some criteria to use the comments to create the haddock documents?
02:14:01 <codacola> no idea, im still new to haskell
02:20:07 <codacola> yay
02:20:11 <codacola> downloaded 6 files already
02:20:14 <codacola> just 8 to go
02:20:25 <codacola> only 1 hour to go :|
02:20:51 <Benigno> omg
02:21:04 <Benigno> which mirror did you choose?
02:21:15 <Benigno> tsulupust?
02:21:19 <codacola> its my connection. they capped me for downloading too much
02:21:38 <Benigno> ¿?¿?¿?
02:21:49 <codacola> its an nz thing. basicly our isps sucj
02:21:53 <Benigno> your isp sucks
02:22:00 <Benigno> yeah
02:22:00 <Benigno> xD
02:25:32 <agentzh> hi, i'm trying to passing my own state around in HXT's arrows...but i'm wondering how to use Text.XML.HXT.Arrow.XmlIOStateArrow's setUserState and getUserState with arrows running by runX...has anyone here ever played with them?
02:25:38 <agentzh> *to pas
02:25:41 <agentzh> s
02:26:21 <Benigno> xml libraries? No sorry :/
02:26:53 <agentzh> Benigno: Haskell XML Toolkit :)
02:27:15 <Benigno> never tried out
02:27:54 <agentzh> okay...
02:28:42 <agentzh> i couldn't find a getParentNode function in HXL so i'm trying to pass the context myself...
02:30:14 <paczesiowa> agentzh: why not stay on parent level and query children with "containing" ?
02:31:25 <agentzh> paczesiowa: hmm
02:32:09 <agentzh> paczesiowa: actually i want all the ancestors for the nodes that i find so that i can generate xpath string for them
02:33:06 <pozic> There is just one way to do existential types in Haskell, right?
02:35:38 <paczesiowa> agentzh: seems hard. anyway what is the problem with setUserState ?
02:35:56 <agentzh> paczesiowa: just wondering if there's an example for its usage :P
02:36:16 <pozic> And is there a way to quantify one existential variable over multiple data constructors?
02:36:35 <pozic> It all feels a bit like boiler plate...
02:39:40 <erikc> exit
02:44:33 <codacola> is there a way to clear the hugs console?
02:45:44 <pozic> codacola: what do you mean by clear?
02:46:02 <paczesiowa> ctrl-L?
02:48:34 <codacola> like so that theres no text there
02:48:37 <codacola> ah ctrl - l works
02:48:46 <codacola> ah works in general
02:49:31 <pozic> codacola: yes, that even works on the console.
02:49:57 <pozic> codacola: I thought you maybe wanted to clear history, since I assumed you had known about the other thing already.
02:50:13 <codacola> nope, never knew about that
02:50:35 <paczesiowa> agentzh: I think I get it
02:50:47 <codacola> thanks :P
02:50:48 <paczesiowa> agentzh: runX is bad because it sets state to ()
02:50:56 <codacola> i usualy use "clear" to clear the screen
02:51:25 <paczesiowa> agentzh: copy from Text.XML.HXT.Arrow.XmlIOStateArrow function runXIOState
02:51:36 <paczesiowa> agentzh: and use runXIOState (initialState '3') (pure (const '2') >>> setUserState)
02:52:04 <pozic> Why can't GHC derive Show instances for non-H98 types?
02:52:20 <pozic> It's not like there is anything hard about that...
02:53:07 <agentzh> paczesiowa: thanks! looking
02:56:58 <paczesiowa> agentzh: looks like those arrows treat state just like monads (you can only change state for subcomputation), perhaps just like for monads there are parameterized arrows invented by Oleg and called "Arrowish"
02:57:45 * agentzh is still pretty new to monads and arrows.
02:59:32 <agentzh> sigh, runXIOState does not export...
03:00:07 <paczesiowa> yeah, you have to copy it yourself
03:00:33 <paczesiowa> but it doesn't have further unexported dependancies
03:00:59 <agentzh> okay...
03:02:26 <agentzh> yay, it compiles :)
03:02:57 <agentzh> changeUserState seems to be what i need :)
03:03:29 <pozic> Is it hard to use Template Haskell? I would like to generate instances for a class based on all the names of datatypes already defined.
03:04:00 <pozic> The computation is not that hard to describe, but I haven't read good user-stories about TH.
03:04:39 <agentzh> paczesiowa: many thanks :)
03:07:15 <paczesiowa> agentzh: if you succed with those paths in state, pls do share code because it sounds interesting. anywa I think it's going to be very hard and there must be better way in such a huge library as hxt
03:07:59 <agentzh> paczesiowa: okay! :)
03:08:15 * agentzh is finally able to proceed :D
03:10:01 <pozic> Since when is hxt suitable for use?
03:10:12 <pozic> I thought it was really really slow.
03:10:23 <agentzh> pozic: really?
03:10:43 <pozic> pozic: yes, mux did some work with it, but that a few versions ago.
03:11:02 <paczesiowa> agentzh: perhaps if you modify getChildren to add their parent (current node) to list inside state it would work, but you would have to rewrite all the other combinators in terms of new getChildren (in times like this, you wish for simple OO override)
03:11:28 <codacola> hm, reading about haskell types
03:11:30 * agentzh is trying hxt in the hope to speed up his perl and js implementations of the highway algorithm significantly.
03:11:33 <codacola> seems kinda weird somehow
03:11:57 <agentzh> paczesiowa: indeed...
03:12:17 <codacola> instead of having lots of constructors, why not just make a type for each, and then use a class that contains all of those datatypes/
03:13:59 <paczesiowa> codacola: that is OO way and it has dual type of problems, I suggest reading about expression problem (basically we can easily add new functions, OO ppl can add new variants)
03:17:04 <glguy> codacola: it is harder to add methods to a class
03:17:55 <codacola> whys that?
03:18:14 <codacola> paczesiowa: ill remember that and look it up once ive read more about data types :P
03:18:48 <glguy> codacola: because they are defined in a single file, possibly a library you didn't write
03:19:35 <paczesiowa> codacola: if you have types A and B in class C, if you want to add new function, you have to modify class C and both instances of types A and B
03:20:12 <paczesiowa> but you can easily add new type D to class C without modifying A,B or C
03:20:16 <codacola> i guess it does make sense when you go to write a function for 1 con in a datatype, you simply write the function for the others, and if you miss any youll get a pattern matching error, right?
03:20:50 <pozic> Existential types seem to have a lot of overhead in GHC. :(
03:23:00 <codacola> ok, so we use classes when we want a function defined over all of them, and we use data types when we want them all to be the same type, but not always have the same functions defined over them?
03:23:03 <codacola> or am i lost?
03:24:14 <paczesiowa> I'd say we use data type when we know all variants ahead of time (they are easier to work with)
03:24:39 <codacola> ah, and classes allow us to make new ones later on?
03:24:49 <paczesiowa> yes
03:25:03 <pozic> codacola: when you have to know the size of a list of shapes, and you don't want to wrap them, then you can also use classes.
03:25:12 <codacola> ok, forgive me if i seem a little lost for a while
03:26:03 <pozic> codacola: otherwise you need to have a list of WrappedShapes = WrappedCircle Circle|WrappedSquare Square etc.
03:26:13 <codacola> oh thats a good point. if they werent teh same type then you couldnt slap them all into a list together either
03:26:41 <pozic> codacola: either way you are going to get boiler-plate code.
03:26:58 <codacola> ok, does it make sense to have a type, various cons, and then have a class that they all belong to to make sure any future ones implement basic functions?
03:27:22 <pozic> codacola: they are called existential types.
03:27:32 <codacola> ah
03:28:25 <pozic> codacola: data Foo = forall a. (Fooable a) => Fooxor {z::Int, y::a}
03:28:45 <pozic> codacola: if you now have a list of Foo, you can call y on all the elements.
03:28:52 <pozic> codacola: er, wrong
03:29:01 <pozic> codacola: you can call fooable on them
03:29:13 <pozic> codacola: assuming that is a method of the Fooable class.
03:38:49 <DRMacIver> Potentially stupid question: Isn't the implementation of equals in IntMap just "deriving Eq"?
03:38:59 <DRMacIver> Well, I mean, it's not, but isn't it equivalent to it?
03:39:27 <Heffalump> I hope so, do you have reason to think it's not?
03:39:45 <DRMacIver> No. I'm just wondering why they have an explicit implementation of it given that.
03:41:08 <DRMacIver> There doesn't seem to be an obvious efficiency gain from either the explicit implementation of == or the explicit implementation of /= (in particular I don't see why the /= implementation is any better than the default in terms of ==)
03:42:46 <Baughn> DRMacIver: /= can quit comparing at the first mismatch, while == has to read the whole thing
03:43:00 <Baughn> That said, I see no reason not to use the default implementation of ==
03:43:35 <Baughn> ..disregard that. I'm clearly insane today.
03:44:04 <DRMacIver> ok. :)
03:45:35 <DRMacIver> Oh, actually, it's true. Sortof. Their /= implementation does have better shortcutting properties.
03:45:47 <Heffalump> than the == implementation?
03:45:57 <Heffalump> or than the standard deriving Eq one would have?
03:46:21 <DRMacIver> Than the == implementation. I think. Hold on while I try to figure out if Baughn's insanity has spread to me...
03:46:28 <Baughn> Wait a minute
03:46:48 <Baughn> DRMacIver: It's IntMap. A tree containing arbitrary values, each mapped to an int.
03:46:52 <DRMacIver> No. The shortcutting should be the same, I think.
03:46:56 <Baughn> DRMacIver: A /balanced/ tree, right?
03:47:05 <DRMacIver> Baughn: It's not balanced. It's a trie.
03:47:18 <Baughn> DRMacIver: Oh. Well, in that case..
03:47:19 <Heffalump> DRMacIver: do you have a URL to hand with the source?
03:47:26 <DRMacIver> http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-IntMap.html
03:47:27 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6zqy5z
03:48:11 <DRMacIver> Baughn: If it didn't look like the implementation was totally equivalent to deriving Eq I wouldn't be questioning it. :)
03:48:19 <Heffalump> are they normalised?
03:48:28 <DRMacIver> In what sense?
03:48:36 * Heffalump reads the implementation of null and decides so
03:48:41 <Baughn> Well, it's a trie. There should be only one representation
03:48:57 <Baughn> DRMacIver: Maybe it was less identical before?
03:48:59 <Heffalump> wouldn't Bin something something Nil Nil represent the same trie as Nil?
03:49:05 <Baughn> Might want to check darcs' annotation of that function
03:49:12 <DRMacIver> Heffalump: Ah, right. The implementation is designed to avoid that happening.
03:49:22 <Heffalump> DRMacIver: right
03:49:39 <DRMacIver> There's a smart constructor bin which throws away Nil subtres and gets used instead of Bin when either half might be null
03:49:57 <Heffalump> the comparisons are not done in the same order as deriving Eq would
03:50:05 <Heffalump> in particular m1 == m2 happens before p1 == p2
03:50:25 <Heffalump> don't ask me why though :-)
03:50:30 <DRMacIver> Hm.
03:50:45 <DRMacIver> I suppose I can conceieve of that being very fractionally more efficient.
03:50:57 <DRMacIver> But it seems unlikely that it's enough to notice
03:52:20 <DRMacIver> ok. I'll believe that as a reason for not deriving Eq. But why is nequal better than just the standard /= implementation
03:52:58 <Heffalump> saves one operation?
03:53:03 <Heffalump> kind of like manual inlining
03:53:45 <DRMacIver> I suppose
03:54:21 <DRMacIver> This seems like really trivial time shaving to me, but I suppose I'll take it on faith that there's a reason for it. :)
03:54:31 <pozic> How can I call b on a value x of type A like b x data A = forall a. (AClass a)=> A {b::a->Int}?
03:54:38 <Heffalump> I suspect that the real reasons are much less solid.
03:54:51 <Heffalump> but it doesn't seem very important to me :-)
03:55:15 <codacola> oh nice, my book has a chapter on abstract data types in haskell (covers queues, stacks, linked lists and trees)
03:55:16 <DRMacIver> No, it's not important. I was wondering because I'm stealing the code and porting it to another language and wanted to check if I needed to worry about this. :)
03:56:13 <Heffalump> what does the mask do, anyway?
03:56:28 <DRMacIver> Oh, you know, I bet that's why there are manual implementations here
03:56:42 <DRMacIver> The original paper might well have had manual implementations of equality in it
03:56:54 <DRMacIver> The mask is used to make decisions about which half of the trie you need to look in
03:57:05 <DRMacIver> If (x & mask) == 0 you look in the left, otherwise in the right.
04:01:39 <pozic> data A = forall a. (AClass a)=>A {z::a->Int};class AClass a where a_method :: a -> Int;
04:01:42 <pozic> test name@(A{z=f})= f
04:01:58 <pozic> Why doesn't test compile or how do I make it compile?
04:02:15 <codacola> heh, i should do my assignment with data types, could be interesting to see what the lecturer says
04:07:58 <NamelessB> hey all
04:08:42 <codacola> hello
04:09:47 <NamelessB> this is probably the stupidest choice of channel to ask this question in
04:09:47 <NamelessB> but
04:09:52 <NamelessB> is haskell really that great?
04:10:01 <tusho> no, it's awful
04:10:03 <NamelessB> i mean, so far i'm convinced that i want to invest the time in learning.
04:10:05 <tusho> terrible, everyone in here hates haskell
04:10:06 <tusho> ;)
04:10:15 <NamelessB> that's what i assumed :P
04:10:24 <Botje> haskell? urgh. I tried it once and got wrapped up in hyperfluxomonadarrowspears
04:10:31 <tusho> @faq Can haskell be the worst language ever?
04:10:31 <lambdabot> The answer is: Yes! Haskell can do that.
04:10:34 <tusho> See?
04:10:37 <Botje> giggle :)
04:10:59 <Botje> NamelessB: give it a shot, it's not too bad
04:11:25 <NamelessB> mmkay.
04:11:33 <Botje> and by "not too bad"
04:11:40 <Botje> i mean "the greatest thing i've ever coded in" :)
04:11:45 <NamelessB> sweet!
04:11:51 <NamelessB> I'm impressed, so far, by the IRC channel
04:11:52 <RayNbow> NamelessB, how much time do you have to spare? ;)
04:12:25 <NamelessB> had I asked something like that in the cocoa or objc channel i would have been mobbed and lynched
04:12:44 <NamelessB> RayNbow: a few hours a day for a few weeks
04:12:49 <NamelessB> then it'll have to slow to a bit of a trickle
04:12:55 <RayNbow> Haskell tricks you into reading all kind of interesting papers, so you tend to neglect real life duties :p
04:14:01 <Botje> @quote paper
04:14:01 <lambdabot> Korollary says: my brain is fried. I cant read any more STM papers
04:14:05 <Botje> aww
04:14:36 <NamelessB> so it's basically masturbation?
04:15:15 <dibblego> NamelessB, if you've convinced yourself it's worth learning, why don't you just start?
04:15:22 <NamelessB> i am starting ;)
04:15:28 <NamelessB> having a play around with ghci right now
04:15:31 <dibblego> good, we await your questions :)
04:15:41 <NamelessB> jesus christ this is all wrong
04:15:50 <NamelessB> programming irc channels aren't supposed to be like this!
04:15:58 <NamelessB> it should be
04:16:12 <Philippa> you mean: not run by egotistical wankers who k/b you for daring ask if the lang's any good?
04:16:12 <NamelessB> "having a play around with ghci right now"â€¦â€¦"go fuck yourself, noob"
04:16:20 <paczesiowa> we got reddit for that
04:16:25 <dibblego> no chest beating around here
04:16:34 <Botje> except on friday
04:16:41 <Philippa> well, not much and not over the things you'd expect
04:16:42 <Botje> when it's the weekly chest-beat-a-thon
04:16:43 <NamelessB> daaang, i missed it by a day
04:17:11 <codacola> NamelessB: well no ones insulted me yet and ive been asking dumb questions for days :P
04:17:43 <NamelessB> codacola: want me to start for you? just so you don't feel left out?
04:17:58 <codacola> if you like
04:18:10 <RayNbow> lambdabot needs a @insultme command :p
04:18:44 <pozic> codacola: I was wrong btw, you need to wrap it anyway.
04:20:36 <tusho> NamelessB: it's like masturbation that CHANGES THE WORLD
04:20:42 <tusho> !!!!!!!!!!!!!1111!!11eleventyone!111
04:20:53 <pozic> Please ban tusho :)
04:21:14 <tusho> pozic: 11
04:21:20 <tusho> eleven. ty. four.
04:25:54 <NamelessB> okayâ€¦ questiontime!
04:26:00 <NamelessB> how does haskell hold up in the real world?
04:26:05 <codacola> very well
04:26:06 <NamelessB> are there any decent GUI programming APIs?
04:26:07 <codacola> next
04:26:11 <paczesiowa> @google real world haskell
04:26:13 <codacola> dont ask any followup questions
04:26:13 <lambdabot> http://www.realworldhaskell.org/
04:26:13 <lambdabot> Title: Real World Haskell
04:26:43 <codacola> NamelessB: curious, have you programmed in another language?
04:26:50 <NamelessB> indeed I have
04:26:59 <codacola> which?
04:27:16 <NamelessB> i spent a long time using mostly C/C++
04:27:25 <Vq^> NamelessB: i would call gtk2hs decent
04:27:29 <NamelessB> then I decided I wanted to get even deeper and learnt assembly
04:27:39 <codacola> my advise would be forget everything you know before learning haskell :P
04:27:39 <NamelessB> so i tried to write an operating system
04:27:42 <codacola> gets quite confusing
04:27:45 <NamelessB> which pretty much failed
04:27:49 <NamelessB> then i moved onto .NET
04:28:01 <NamelessB> before I discovered cocoa
04:28:07 <NamelessB> which i loved.
04:28:18 <Vq^> NamelessB: seems like you haven't moved around that much then ;)
04:28:21 <quicksilver> of course, you are conflating languages with APIs there.
04:28:29 <NamelessB> *frameworks
04:28:32 <NamelessB> but yes, i am
04:28:36 <TSC> Libraries
04:28:47 <NamelessB> cocoa is generally implicative of objc
04:28:55 <Baughn> Only apple calls them frameworks
04:28:57 <BONUS> is having a StateT s IO a monad transformer ever useful?
04:29:00 <BONUS> i'd imagine not
04:29:07 <quicksilver> sure, very useful
04:29:12 <NamelessB> Baughn: .NET framework.
04:29:13 <Baughn> And I'm quite happy with cocoa being easy enough to use from C - thus also from haskell. ;)
04:29:30 <BONUS> hmm how so? isnt the IO monad just a version of the state monad basically
04:29:42 <NamelessB> well if haskell works out from me, and cocoa is usable with haskell, you've found yourselves a convert.
04:29:47 <TSC> BONUS: Sort of, but even so it is useful
04:29:52 <BONUS> hmm
04:29:58 <Botje> BONUS: yes, but you can use get and put instead of readIORef and writeIORef :)
04:30:04 <BONUS> ah
04:30:17 <pozic> Existentential fields are basically tags, on a constructor that says: there is a class associated with this value that you can all on this, right?
04:30:19 <TSC> It's generally much clearer to use State than IO if all you really want is state
04:30:25 <pozic> say*
04:30:30 <BONUS> aha
04:30:30 <BONUS> kewl
04:30:36 <Baughn> NamelessB: Nobody has written a real binding yet. I've been experimenting with the obj-c runtime api, but only so far as to grab an opengl context for my own use
04:30:47 <BONUS> im tinkering with monad transformers now, they're a really genius idea
04:30:58 <Vq^> NamelessB: sounds promising, just don't start by trying to write GUI programs if you haven't used a functional programming language before
04:31:08 <NamelessB> Baughn: shame. although that sounds like the sort of wacky project i'd throw myself head-first into
04:31:26 <NamelessB> Vq^: yeah, i didn't plan on it. I need to get my head around all this first.
04:31:47 <paczesiowa> State monads carry your state, so you don't have to pass IORefs all the time
04:32:54 <codacola> why cant i define == over "Shape" by using "(==) :: Shape -> Bool"?
04:33:05 <TSC> Shape -> Shape -> Bool
04:33:07 <paczesiowa> :t (==)
04:33:12 <lambdabot> forall a. (Eq a) => a -> a -> Bool
04:33:13 <codacola> oh yeah
04:33:13 <TSC> You need to compare two Shapes
04:33:16 <codacola> sorry
04:33:56 <pozic> Why does everyone have me on ignore?
04:34:00 <BONUS> i dont
04:34:01 <BONUS> :[
04:34:05 <codacola> still doesnt like it "(==) :: Shape -> Shape -> Bool "
04:34:14 <dibblego> did anyone just hear a strange noise?
04:34:25 <codacola> yes, was me
04:34:34 <Baughn> NamelessB: There is a certain impedance mismatch between /objective/-c and haskell, of course
04:34:35 <BONUS> wait what are you trying to do
04:34:40 <BONUS> if oyu have a Shape datatype
04:34:41 <BONUS> just add
04:34:43 <BONUS> deriving (Eq)
04:34:45 <laziest> dibblego: you need to derive from Eq
04:34:53 <paczesiowa> codacola: you can't define that function (it is already defined as method of Eq class)
04:35:04 <pozic> no, no, no...
04:35:04 <codacola> i did
04:35:05 <codacola>                 deriving (Eq, Ord, Show, Read)
04:35:05 <dibblego> laziest, will that cure the noise?
04:35:12 <pozic> He is using existential types..
04:35:17 <NamelessB> Baughn: yeahâ€¦ you mean the imperative vs functional thing?
04:35:18 <BONUS> (==) is defined in a typeclass so if you want to use it for your own datatype, you have to make it an instance of the typeclass
04:35:19 <pozic> So, all the deriving stuff doesn't work...
04:35:27 <pozic> So, he needs to write one himself.
04:35:33 <BONUS> oh then just make an instance
04:35:37 <codacola> now im confused
04:35:46 <BONUS> instance Eq Shape where a == b = ...
04:35:57 <pozic> instance Eq Shape where (==) (Shape ...
04:36:01 <BONUS> you'll probably do somthing like that yeah
04:36:36 <Baughn> NamelessB: Right. Using the api directly should be relatively easy, but supporting overriding functions, inheritance and all that could be.. interesting.
04:36:41 <dibblego> codacola, if you have Shape deriving Eq, then you can use it with ==
04:36:56 <NamelessB> Baughn: yeahâ€¦ i guess
04:37:02 <pozic> dibblego: read the discussion...
04:37:02 <paczesiowa> I don't think you can compare two existential types (how would you compare Square to Circle? )
04:37:05 <NamelessB> what's probably needed is some sort of middle layer, right?
04:37:15 <NamelessB> but then it'd be at the cost of performance
04:37:24 <paczesiowa> maybe some Dynamic hack would work
04:37:26 <dibblego> pozic, I have done just prexactly that?
04:37:44 <pozic> dibblego: _existential_ types.
04:37:55 <pozic> dibblego: try deriving Eq on such types.
04:38:12 <dibblego> pozic, is codacola using existentials?
04:38:19 <pozic> dibblego: yes, I just said so.
04:38:38 <pozic> dibblego: He is using ..
04:39:35 <Baughn> NamelessB: Well, you could do quite a bit with template haskell
04:40:08 <pozic> NamelessB: do not listen to him :) Template Haskell is a mess and has low priority.
04:40:46 <Baughn> NamelessB: And the runtime api /is/ nice. It should be reasonably simple to support just about anything, it's just getting the full performance of static linking (as opposed to at-startup linking) that would be messy
04:40:58 <Baughn> NamelessB: http://developer.apple.com/documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html <-- Here, read
04:41:00 <lambdabot> Title: Objective-C 2.0 Runtime Reference, http://tinyurl.com/6h3chj
04:41:04 * NamelessB looks longingly at gcc and wonders what he's gotten himself into.
04:41:29 <dibblego> NamelessB, start going through YAHT and ask your specific questions as you go
04:41:33 <dibblego> @where yaht
04:41:34 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
04:42:56 <NamelessB> cheers.
04:59:55 <r3m0t> what's the code for (`mod`1000) in Double -> Double
04:59:56 <lambdabot> r3m0t: You have 1 new message. '/msg lambdabot @messages' to read it.
05:04:27 <pozic> r3m0t: be more precise
05:07:00 <r3m0t> :t (`mod`1000)
05:07:09 <lambdabot> forall a. (Integral a) => a -> a
05:07:13 <r3m0t> :t mod
05:07:14 <lambdabot> forall a. (Integral a) => a -> a -> a
05:07:27 <codacola> ok, im guessing its a sign of a bad dentist when shards of a tooth remain after it was meant to be pulled out
05:07:34 <r3m0t> > (`mod`1000) (34523::Double)
05:07:35 <lambdabot>   add an instance declaration for (Integral Double)
05:07:35 <lambdabot>     In the expression: (`...
05:08:32 <mauke> :t uncurry (+) . first (fromInteger . (`mod` 1000)) . properFraction
05:08:33 <lambdabot> forall a. (RealFrac a) => a -> a
05:08:52 <mauke> > uncurry (+) . first (fromInteger . (`mod` 1000)) . properFraction $ 34523.4
05:08:54 <lambdabot>  523.4000000000015
05:12:03 <Saizan_> ?hoogle mod'
05:12:03 <lambdabot> Data.Fixed.mod' :: Real a => a -> a -> a
05:12:03 <lambdabot> Data.Fixed.divMod' :: (Real a, Integral b) => a -> a -> (b, a)
05:12:13 <pozic> Wth is "Illegal use of punning"?
05:17:30 <pozic> Never mind.
05:19:56 <dcoutts> solrize: pong
05:20:50 <r3m0t> thanks Saizan_
05:47:20 * vixey demands  progress f x = let fx = f x in if fx == x then x else progress f fx  be put into the stdlib
05:48:24 <skorpan`> i don't get it
05:48:43 <tusho> @let  progress f x = let fx = f x in if fx == x then x else progress f fx
05:48:48 <lambdabot> Defined.
05:48:51 <vixey> progress f = last . iterate f
05:48:52 <tusho> > progress id 1
05:48:54 <lambdabot>  1
05:49:06 <tusho> vixey: uh
05:49:08 <tusho> that's just fixed point
05:49:17 <tusho> > progress (/ 2) 50
05:49:18 <lambdabot>  0.0
05:49:33 <tusho> > progress (/ 1.9) 50
05:49:34 <lambdabot>  5.0e-324
05:49:41 <tusho> > progress (/ 2.1) 50
05:49:42 <lambdabot>  0.0
05:49:45 <vixey> @hoogle String -> Bool -> m ()
05:49:45 <lambdabot> Language.Haskell.TH.Syntax.qReport :: Quasi m => Bool -> String -> m ()
05:49:49 <ziman> > progress (/1.01) 2
05:49:50 <lambdabot>  2.47e-322
05:49:57 <skorpan`> it iterates the function until the function doesn't make any further "progress"?
05:50:05 <vixey> skorpan`: yes
05:50:08 <skorpan`> then i get it
05:50:18 <vixey> I use it a few times
05:50:25 <vixey> Am I the only one that defines this ?
05:50:54 <skorpan`> i think i made use of it in a boardgame DSL that i developed
05:51:02 <vixey> cool
05:51:08 <vixey> well maybe it should really be in the stdlib ten
05:51:22 <skorpan`> no, now i remember that i didn't
05:51:27 <skorpan`> i could've.
05:51:28 <vixey> what name did you give it ?
05:51:29 <skorpan`> but didn't
05:51:34 <skorpan`> the DSL? "hoard game" :/
05:51:34 <Cale> I've used that a number of times. Sometimes you want a slightly different test for convergence though.
05:51:38 <skorpan`> oh the function!
05:51:42 <skorpan`> uh... i think it was "reach"
05:52:00 <ziman> > let pgs f x = let xs = iterate f x in fst . head . dropWhile (curry (/=)) $ zip xs (tail xs) in pgs (/1.9) 50
05:52:01 <lambdabot>  Couldn't match expected type `Bool'
05:52:01 <vixey> Cale, oh right, yes
05:52:06 <skorpan`> it was used to return a list of possible "next positions" of a given chess piece
05:52:10 <tusho> > progress (join . uncurry (+)) (1,1)
05:52:11 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, (a, a))
05:52:11 <lambdabot>       ...
05:52:23 <vixey> hoard game lol
05:52:24 <Cale> (Especially if you're using floating point numbers or something)
05:52:32 <skorpan`> yeah i know, it was cheesy
05:52:39 <skorpan`> i made the name up when i was finishing up the report
05:52:49 <skorpan`> about two hours before the deadline
05:53:03 <skorpan`> (this was for school)
05:53:14 <vixey> and does this exist already ?  message `should` assertion = if assertion then error message else return ()
05:54:03 <tusho> that reads badly
05:54:18 <tusho> > "list must be non-null" `should` null list
05:54:18 <lambdabot>   Not in scope: `list'
05:54:25 <agentzh> sigh...can't go bottom-up in HXL's dom trees :((
05:54:31 <Saizan_> there's assert, which gives you a source location instead of a message
05:54:41 <agentzh> and can't pass custom info top-down either :(
05:56:17 <agentzh> ï»¿Haskell XML Toolkit sucks
05:56:33 <agentzh> ï»¿despite the fact arrows look beautiful for most common dom traverse tasks...
05:59:23 <Saizan_> processBottomUp :: Tree t => a (t b) (t b) -> a (t b) (t b) ?
06:02:56 <vixey> huh......
06:03:03 <vixey> how come there's no way to clone a stateT
06:03:42 <Zao> Maybe the transformed monad cannot be cloned?
06:03:55 * vixey is going to clone it whether it likes it or not ...
06:03:57 <agentzh> Saizan_: i'll take a look at processBottomUp...
06:03:57 <paczesiowa> agentzh: so you failed? did you try modifying getChildren?
06:04:19 <agentzh> paczesiowa: i was only trying modifying deep...
06:04:37 <agentzh> paczesiowa: still wondering how to modify getChildren...
06:04:47 <agentzh> paczesiowa: it uses arrL ...
06:04:51 <painy> if i have to calculate about 2, 000, 000 points, and draw about 1,500 000 lines
06:04:56 <painy> what is the fastest way to do this
06:05:03 <agentzh> paczesiowa: seems like some deep arrow magic to me ...
06:05:16 <paczesiowa> agentzh: isn't deep defined in terms of getChildren?
06:05:22 <agentzh> paczesiowa: indeed
06:05:45 <agentzh> paczesiowa: so the tree traverse is ready a linear list...
06:06:01 <BONUS> hmmm
06:06:03 <agentzh> paczesiowa: can't determine the parent-son relationship in deep already
06:06:15 <paczesiowa> deep is then recursive, you need to modify one step - getChildren
06:06:21 <agentzh> paczesiowa: yup
06:06:29 <paczesiowa> @src getChildren
06:06:29 <lambdabot> Source not found. You speak an infinite deal of nothing
06:06:29 <Baughn> painy: That has to be about the most hopelessly vague question I've yet heard. Some more detail, please.. /what/ points?
06:06:31 <BONUS> if i have a State a b type declaration and i want to make it more general by using the MonadState class, what would the signature be then?
06:06:46 <agentzh> paczesiowa: getChildren = arrL . T.getChildren
06:06:47 <BONUS> (MonadState s) => s a b doesnt work
06:06:47 <painy> well basicly i have a program that draws trees
06:06:51 <painy> in mirc
06:06:55 <painy> and its hopelessly slow
06:07:00 <painy> so i want to make it in hasklel
06:07:19 <painy> and well... what are the ways i will optimize it
06:07:26 <Baughn> painy: In.. mirc? As in mirc-script?
06:07:30 <Saizan_> BONUS: MonadState a m => m b
06:07:30 <painy> yes
06:07:42 <paczesiowa> @src arrL
06:07:42 <lambdabot> Source not found. My mind is going. I can feel it.
06:07:51 <Saizan_> sorry, that was for Baughn
06:08:00 <Baughn> Saizan_: No it wasn't
06:08:23 <Saizan_> right..
06:08:27 <Baughn> painy: Um. You probably won't /need/ to; that interpreter is amusingly slow to begin with; a simple haskell program doing the same might be a hndred times faster
06:08:39 <Baughn> painy: But of course you couldn't write it the same way. Do you actually know haskell?
06:08:43 <painy> oh okay
06:08:51 <painy> no no i odn't, i'm learning
06:08:58 <painy> c++
06:10:24 <Baughn> painy: Yes. Quite; learning c++ won't help you use haskell at all.
06:11:10 <Baughn> painy: Probably your problem is better suited for haskell than c++ (I couldn't say; you have provided no real information, but the prior points that way), so you might want to prioritize one over the other
06:11:20 <Baughn> Preferably haskell over c++. But then, I /am/ saying this in #haskell. :P
06:11:26 <painy> hehehe okay
06:11:28 <BONUS> Saizan: hmm
06:11:34 <BONUS> so if i have, more specifically a type of
06:11:40 <BONUS> State String String
06:11:44 <painy> is there any free, extensive haskell book on the internet?
06:11:54 <Baughn> Oh yes. Many.
06:11:57 <BONUS> how would you turn that State into a s that's a member of MonadState
06:12:05 <painy> do you know any of the names off by heart
06:12:05 <Baughn> painy: What languages do you already have experience with? Just mircscript?
06:12:11 <painy> juust mirc
06:12:16 <vixey> cool
06:12:23 <painy> and im chapter 4 in "thinking in c++"
06:12:31 <vixey> oh gosh...
06:12:41 <vixey> painy, who is making you learn C++?
06:12:44 <Baughn> pozic: I'd suggest reading http://www.haskell.org/~pairwise/intro/intro.html and http://www.haskell.org/tutorial/
06:12:45 <lambdabot> Title: Haskell for C Programmers
06:12:49 <agentzh> ï»¿Saizan_: processBottomUp cannot help me it seems because i need to find the nodes top-down and them do a bottom-up to calculate their xpath locations :)
06:12:54 <painy> okay thanks Baughn
06:12:58 <agentzh> *then do
06:13:06 <painy> i don't know vixey
06:13:12 <painy> i think the java room on dalnet told me to
06:13:55 <Baughn> painy: From the refined heights of our academic tower, c++ looks like the sort of thing you'd torture small kids, cute animals or prisoners of war with
06:14:17 <skorpan> a.k.a. c++ is shit
06:14:26 <agentzh> the arrow is a beautiful concept except that i can't pass custom arguments to them in a top-down fashion as in ordinary functions (such as parsec's combinators) :(
06:14:37 <painy> ahaha okay thanks
06:14:49 <vixey> :t (get>>=)
06:14:50 <lambdabot> forall (m :: * -> *) a b. (MonadState a m) => (a -> m b) -> m b
06:14:59 <vixey> @hoogle (a -> m b) -> m b
06:15:00 <lambdabot> Data.Function.fix :: (a -> a) -> a
06:15:00 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
06:15:00 <lambdabot> Control.Monad.State.Class.gets :: MonadState s m => (s -> a) -> m a
06:15:17 <Saizan_> BONUS: the generalized type of that is MonadState String m => m String, if you're asking how to promote a value of type State String String to that you can write something like promote m = do s <- get; let (a,s') = runState m s; put s'; return a
06:16:18 <BONUS> yeah
06:16:49 <BONUS> i just noticed i have a function that uses put and get and manipulates the contents with string functions
06:16:53 <BONUS> so i thought why not generalize it
06:17:24 <Saizan_> agentzh: the HXT arrow is an ArrowApply, that means you can do with it all that you can with a monad
06:17:47 <pozic> Baughn: ?
06:17:49 <BONUS> hmm but now it tells me to use -XFlexibleContexts
06:18:36 <Saizan_> BONUS: MonadState is not an haskell98 class
06:18:39 <Baughn> pozic: Mistell
06:19:19 <Saizan_> BONUS: however if you just use put and get there's no need of an explicit conversion from State
06:19:58 <BONUS> hmm
06:20:03 <pozic> "Other things make Haskell code incredibly fast. First, Haskell's laziness adds an extra kick to the speed. " It seems more like a fairy tale.
06:20:33 <vixey> lazyness doesn't make anything fast
06:20:43 <pozic> vixey: that's my point.
06:21:10 <paczesiowa> Saizan_: those ArrowApply thingies can be used with arrow notation?
06:21:21 <mux> it makes it possible to write some beautiful things efficiently, while using the same semantics performance would be disastrous in a strict language
06:22:01 <Saizan_> paczesiowa: yes, there's a special notation "-<<" see the arrow section in the GHC manual
06:22:25 <Baughn> pozic: As mux said. Laziness doesn't make things fast, but it helps you write code that isn't slow
06:23:05 <vixey> Has anybody considered something like
06:23:08 <vixey> type key :--> val = [(key,val)] (k ~~> v) Ïƒ = (k,v):Ïƒ
06:23:17 <vixey> oops
06:23:19 <vixey> that's two lines
06:23:40 <paczesiowa> Saizan_: yeah I read that but I have no idea what does it have in common with hxt
06:24:22 <Saizan_> paczesiowa: what do you mean?
06:26:19 <pozic> Do record-puns only work in the module that defined the data type?
06:26:58 <pozic> Er, I mean the Wildcard extension for records.
06:26:59 <paczesiowa> Saizan_: I don't understand arrows (so I don't really get those examples from arrows notation) but I can kind of use hxt and I was hoping that arrow notation could help understand some things
06:27:54 <vixey> by the way to clone statet you just go ...  get >>= evalStateT <actions in a cloned scope>
06:28:08 <pozic> This one: -XRecordWildCards
06:29:53 <Saizan_> paczesiowa: tried reading a tutorial on them? also the HXT arrow is a bit tricky since it's sort of the arrow equivalent of the list monad
06:30:40 <vixey> > flip replicateM ['A'..'Z'] =<< [1..]
06:30:44 <vixey> is there a better way to write that ?
06:30:55 <lambdabot>  thread killed
06:33:03 <olsner> isn't that pretty good?
06:33:50 <pozic> vixey: you use =<< for something that doesn't need =<<
06:34:01 <pozic> vixey: it is easier to read if you inline =<<.
06:34:35 <olsner> > concatMap (`replicateM` ['A'..'Z']) [1..]
06:34:51 <lambdabot>  thread killed
06:37:59 <jpcooper> could anyone link me to somewhere which describes how to export classes?
06:39:55 <jpcooper> or maybe I just need to give the class name
06:41:53 <vixey> jpcooper, http://www.haskell.org/onlinereport/modules.html
06:41:54 <lambdabot> Title: The Haskell 98 Report: Modules
06:42:09 <jpcooper> thanks
06:42:34 <Cale> jpcooper: To export a class and all its methods, just put  ClassName(..)  in the export list
06:43:00 <jpcooper> aah, thanks
06:43:15 <vixey> @pl putSupply supply = modify (\(store,_) -> (store,supply))
06:43:16 <lambdabot> putSupply = modify . (`ap` snd) . (. fst) . (const .) . flip (,)
06:43:21 <vixey> :S
06:43:46 <Cale> (you can also explicitly list the methods you want to export instead of the two dots, or leave the (..) off altogether to just export the class and not the methods)
06:43:51 <mattam> @pl should be aliased with @obfuscate
06:43:51 <lambdabot> should be aliased with @ obfuscate
06:44:35 <Cale> heh
06:45:11 <Cale> > second (const 5) (1,2)
06:45:14 <lambdabot>  (1,5)
06:45:21 <jpcooper> say I have a constructor of a certain data type. Do I have to export the data type as well?
06:45:34 <Cale> jpcooper: yeah
06:45:53 <Cale> You do that in a similar way to classes
06:46:03 <Cale> DataType(..) to export all the constructors
06:46:54 <Cale> Or you can list the constructors you want exported explicitly (separated by commas), or you can leave the (..) off and export only the type.
06:47:16 <slarba> where's supero for ghc core now that compiler plugins are being developed? :)
06:48:12 <Cale> Ask ndm :)
06:48:13 <Cale> hehe
06:51:16 <vixey> what's the best way to store a database...
06:51:41 <vixey> I don't know if I shoudl use :--> or Map or (->) or .....
06:51:41 <Benigno> in a linux server
06:51:47 <Benigno> xD
06:51:55 * vixey doesn't have one :p
06:52:29 <slarba> any OS capable of disk i/o will do ;)
06:52:44 <vixey> I'm just thinking about like
06:53:02 <vixey> if you want to add something, it goes at the end
06:53:28 <jpcooper> Cale, sorry, I meant that I wrote my own constructor
06:54:08 <Cale> jpcooper: If it's just an ordinary function, you just add it to the list as usual.
06:54:20 <jpcooper> so then I don't need to export the type?
06:54:39 <Cale> You still want to export the type, but maybe not the constructors of the type
06:54:43 <jpcooper> okay
06:54:57 <Cale> (So you'd just list the type name, with no parenthesized section after it)
06:55:06 <jpcooper> yes
06:57:34 <vixey> @src Monad
06:57:34 <lambdabot> class  Monad m  where
06:57:34 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
06:57:34 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
06:57:34 <lambdabot>     return      :: a -> m a
06:57:34 <lambdabot>     fail        :: String -> m a
07:01:21 <vixey> not allowing partial application of type synonyms sucks...
07:02:36 <Heffalump> however it does make type inference decidable..
07:06:22 <ziman> > (fail :: (Int -> Int)) 3
07:06:36 <augustss> yo!
07:06:37 <lambdabot>  thread killed
07:06:42 <Heffalump> 'lo
07:06:51 <Heffalump> aren't you somewhere in the back of beyond?
07:06:52 <vixey> hi
07:06:59 <augustss> I'm in Seoul
07:07:17 <Heffalump> ok, not quite then ;-)
07:07:35 <Heffalump> ISTR South Korea has really fast broadband
07:08:10 <augustss> It's really broadband, but otherwise different from home
07:10:10 <ziman> why does Monad introduce fail? shouldn't that be rather in MonadPlus/MonadFail? i mean, i cannot see an obvious reason for an operation other than return/bind (and (>>) as a convenience) there
07:10:34 <vixey> ziman: I think it's for pattern match failures in do notation
07:10:49 <SamB> no real excuse, obviously
07:11:19 <kryptiskt> ziman, without such warts, haskell would be too perfect
07:11:26 <ziman> :)
07:15:55 <ziman> > (fail "fial" :: (Int -> Int)) 3
07:15:56 <lambdabot>  Exception: fial
07:17:59 <dmhouse> > (fail "fail" :: Int -> Int) undefined
07:18:00 <lambdabot>  Exception: fail
07:18:06 <dmhouse> > fix (fail "fail" :: Int -> Int)
07:18:07 <lambdabot>  Exception: fail
07:18:45 <dmhouse> So fail is an example of a strict function which doesn't evaluate its argument.
07:18:46 <Baughn> > fix (1+)
07:19:02 <lambdabot>  thread killed
07:19:16 <r3m0t> > (+) == (-)
07:19:17 <lambdabot>   add an instance declaration for (Eq (a -> a -> a))
07:19:17 <lambdabot>     In the expression: (...
07:20:08 <Saad_> Is lambdabot compatible with windows?
07:20:09 <dmhouse> > let fact _ 0 = 1; fact rec n = n * rec (n-1) in fix fact 5
07:20:11 <lambdabot>  120
07:20:33 <paczesiowa> agentzh: don't you think that state is "global" for arrow computation and not per result which makes your method impossible?
07:23:08 <paczesiowa> agentzh: but maybe it is possible to modify tree type to contain path of ancestors in every node which would make those arrow thingies work the same but results would contain paths
07:23:45 <Skyp> Hi ;) I have a problem with hugs and HDBC... if I try to print the result of a quickQuery (res <- quickQuery conn "SELECT now()" [] ; print res) Hugs says "Program error: pattern match failure: head []"
07:24:04 <Skyp> The error occurs in the line "print res"... any clues what's wrong here?
07:24:27 <ShockSMX> shouldn't "asdf x = x" be a valid function? why does ghc tell me that the = is invalid input
07:24:39 <dmhouse> ShockSMX: pastebin the entire module
07:24:49 <ShockSMX> that IS the entire module
07:24:52 <paczesiowa> ShockSMX: ghc or ghci?
07:24:55 <ShockSMX> ghci
07:25:01 <paczesiowa> try let asdf x = x
07:25:13 <dmhouse> Imagine stuff you type into ghci is within a do block
07:25:20 <ShockSMX> paczesiowa: would it work without the let in ghc?
07:25:44 <dmhouse> ShockSMX: yes, if your module was "asdf x = x", that would compile fine.
07:26:21 <ShockSMX> dmhouse: alright
07:28:07 <Baughn> ShockSMX: Of course you could pointlessly rewrite it to asdf = id
07:28:31 <Saad_> I guess noone knows the answer :\
07:30:27 <pozic> Saad_: you didn't use Google.
07:31:12 <jpcooper> how do I add a directory to the list of directories that is searched?
07:31:58 <paczesiowa> -L ?
07:32:09 <jpcooper> in .ghci
07:35:31 <jpcooper> oh, with :set
07:38:55 <FordCortina> does "undecidable instances" mean that that functions that use that class as a constraint might take indefinately long to type check? or is it just the instance declaration that is affected?
07:39:15 <vixey> functions that use it
07:39:18 <FordCortina> bummer
07:39:20 <FordCortina> :(
07:44:02 <sjanssen> FordCortina: the non-termination only happens when a function attempts to use one of these non-terminating instances
07:44:47 <FordCortina> sjanssen: i think that whats going to happen
07:46:08 <FordCortina> the undecidable instance is part of a class that forms the typeindices of parsers in a parser combinator library im trying to write
07:46:49 <vixey> FordCortina: if you set it up right, it can always take finite time
07:46:58 <Skyp> Ok, I found the problem... "SELECT now()" results in an empty list, "SELECT now()::date" gives a result... Postgres-Support seems broken with hdbc...
07:47:04 <FordCortina> hehe you dont want to do "a <*> b" and have haskell complain its going to take forever to typecheck
07:47:30 <FordCortina> (a and b are parsers)
07:48:09 <FordCortina> vixey: I reckon its possible. I just wonder how many trade offs im going to have to do :( .
07:48:11 <r3m0t> parser combinator? :S
07:49:49 <r3m0t> does (,) support sections
07:50:01 <vixey> no
07:50:10 <r3m0t> :(
07:50:44 <vixey> > let (&) = (,) in  map (3 &) "xyz"
07:50:48 <lambdabot>  [(3,'x'),(3,'y'),(3,'z')]
07:50:58 <__pao__> programming in haskell is soooo much fun :-)
07:51:08 * __pao__ is enjoying it a lot :-)
07:51:54 <Skyp> programming in haskell is indeed fun, but I didn't manage to program something useful, non-academic in it ;)
07:52:18 <__pao__> Skyp: I am trying...
07:52:33 <__pao__> Skyp: I'm very much a "prototyping/experimental level"
07:53:05 <Skyp> me too ;)
07:53:06 <drguildo> is the definition of when in http://haskell.org/haskellwiki/IO_inside correct?
07:53:08 <lambdabot> Title: IO inside - HaskellWiki
07:53:17 <__pao__> Skyp: but it the experiment go well, I'll think we'll start to use it in our product
07:53:34 <drguildo> i mean would it work
07:53:42 <drguildo> based on his definition of IO as type IO a  =  RealWorld -> (a, RealWorld)
07:55:21 <roconnor> @wiki IO Semantics
07:55:21 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
07:56:28 <roconnor> @src when
07:56:29 <lambdabot> when p s = if p then s else return ()
07:57:23 <drguildo> it seems to be applying an IO to an IO
07:57:29 <drguildo> c.f. "action world"
07:57:51 <drguildo> because of the type definition it looks to me as if world is really of type IO ()
07:57:58 <drguildo> i.e. RealWorld -> ((), RealWorld)
07:58:09 <drguildo> so surely "action world" wouldn't work
07:59:09 <roconnor> drguildo: according to his definiton IO () means RealWorld -> ((),RealWorld)
07:59:28 <roconnor> so the world parameter is bound to the first argument here, ie RealWorld
07:59:38 <roconnor> the result type is ((),RealWorld)
08:00:42 <__pao__> http://hpaste.org/9169
08:00:59 <drguildo> i don't follow
08:01:15 <drguildo> this is how i read it
08:01:18 <__pao__> I've pasted a naive implementation of damerau-levenshtein distance
08:01:23 <__pao__> my question is
08:01:29 <drguildo> we have a function which has 3 parameters
08:01:37 <drguildo> the first is type Bool
08:01:46 <drguildo> second is RealWorld -> ((), RealWorld)
08:01:51 <drguildo> third is RealWorld -> ((), RealWorld)
08:01:55 <roconnor> nope
08:02:02 <roconnor> third is RealWorld
08:02:03 <__pao__> what is the "idomatic" way to peek a future values in a recursive computation?
08:02:13 <roconnor> result type is ((),RealWorld)
08:02:15 <pozic> > fmap (+1) (1,2,3)
08:02:17 <drguildo> but the type definition says world is IO ()
08:02:18 <lambdabot>   add an instance declaration for (Functor ((,,) t t1))
08:02:21 <__pao__> is my implementation "idiomatic enough"?
08:02:35 <roconnor> when :: Bool -> (RealWorld -> ((), RealWorld)) -> RealWorld -> ((), RealWorld)
08:02:43 <pozic> Why doesn't that instance exist?
08:03:48 <roconnor> > fmap (+1) (1,putStrLn)
08:03:49 <lambdabot>        add an instance declaration for (Num (String -> IO ()))
08:03:57 <__pao__> is suspect that "peeking" , opposed to "saving old info" is the way to go...
08:04:04 <roconnor> > fmap (+1) (putStrLn,1)
08:04:04 <drguildo> roconnor, isn't that what i said?
08:04:05 <lambdabot>  (<[Char] -> IO ()>,2)
08:04:05 <__pao__> s/is/I/
08:04:44 <roconnor> drguildo: What do you think the result type of the function is?
08:04:54 <Saizan_> drguildo: no, what you said is like  Bool -> (RealWorld -> ((), RealWorld)) -> RealWorld -> ((), RealWorld) -> Something
08:05:00 <drguildo> roconnor, to me it doesn't have one, so it wouldn't work
08:05:13 <roconnor> drguildo: all functions have a result type
08:05:23 <drguildo> because the 3 types in the definition would be applied to each of the parameters
08:05:48 <drguildo> would be applied/would apply
08:06:20 <roconnor> drguildo: the type synomym for IO is expanded, and world is only bound to one part of that last IO ()
08:07:27 <roconnor> > let {foo :: ShowS; foo x = "blah "++x} in foo "5"
08:07:28 <lambdabot>  "blah 5"
08:07:38 <roconnor> @src ShowS
08:07:39 <lambdabot> type ShowS = String -> String
08:07:46 <jeffwheeler> Is RealWorld a real thing, or just invented for demonstrating IO?
08:07:50 <roconnor> See in this example foo takes one argument, a String
08:08:00 <Saizan_> it's the same as writing when condition action = \world -> ... if that helps
08:08:12 <roconnor> not a ShowS
08:08:14 <jeffwheeler> If it's real, does it actually have any meaning/values?
08:08:32 <roconnor> jeffwheeler: it isn't real.  It is just a stupid hack
08:09:00 <Saizan_> jeffwheeler: it's how GHC cheats to sequentialize IO actions, and it's just a token
08:09:02 <jeffwheeler> roconnor: hmm, okay; so I couldn't write a type signature on my main that included it?
08:09:16 <jeffwheeler> Oh; so I _could_? I'll try it.
08:09:23 <Saizan_> no, you can't
08:09:24 <roconnor> you could if you use GHC internals.
08:09:31 <jeffwheeler> Oh, okay.
08:10:29 <drguildo> i think i don't understand how to read type signatures or something
08:10:53 <Saizan_> drguildo: are you familiar with currying?
08:11:03 <drguildo> Saizan_, i thought i was
08:12:19 <Saizan_> so, when takes a Bool, an IO () and produces an IO (), so it must look like "when bool action = <some other action>"
08:12:25 <jpcooper> if a function is already implemented on a type and that function is the only function needed to satisfy the type as an instance of a class, can one just write: instance Class Type?
08:12:32 <Saizan_> an action is actually a function
08:12:40 <Saizan_> that takes a world as parameter
08:13:03 <Saizan_> so we have: when bool action = \world -> <body>
08:13:12 <Saizan_> drguildo: does it make sense?
08:14:01 <drguildo> but when is defined as "whel bool action world"
08:14:03 <drguildo> *when
08:14:14 <Saizan_> jpcooper: no, you've to write instance Class Type where method = function
08:14:21 <jpcooper> okay
08:14:57 <Saizan_> drguildo: the point is that "when bool action world = <body>" and "when bool action = \world -> <body>" are the same thing
08:16:17 <Saizan_> > let foo x y = x + y; bar x = \y -> x + y; in (foo 1 2,bar 1 2)
08:16:18 <lambdabot>  (3,3)
08:16:32 <Saizan_> ?type let foo x y = x + y in foo
08:16:32 <lambdabot> forall a. (Num a) => a -> a -> a
08:16:49 <Saizan_> ?type let bar x = \y -> x + y; in bar
08:16:50 <lambdabot> forall a. (Num a) => a -> a -> a
08:17:21 <Saizan_> you could say that in haskell there are only 1-argument functions
08:17:41 <cnwdup> How do I make a function work in two monads? I'd like to define a function which works in a StateT ST (ReaderT ENV IO) a and in just the ReaderT ENV IO a monad.
08:18:02 <Saizan_> and we represent an n-ary function as one that takes only one argument and returns an (n-1)-ary function
08:18:46 <Saizan_> cnwdup: so it doesn't touch the state?
08:18:55 <drguildo> Saizan_, i follow you, i'm just trying to apply it to that definition of when
08:18:59 <roconnor> cnwdup: make your function work with the MonadReader class
08:19:14 <sjanssen> cnwdup: give your function the type: (MonadIO m, Reader ENV m) => m a
08:19:14 <vixey> @pl \db Ïƒ body -> (db,Ïƒ) ?- body
08:19:14 <lambdabot> (line 1, column 6):
08:19:14 <lambdabot> unexpected "\131"
08:19:14 <lambdabot> expecting pattern or "->"
08:19:26 <sjanssen> s/Reader/MonadReader
08:19:35 <vixey> @pl \db ugh body -> (db,ugh) ?- body
08:19:35 <lambdabot> ((?-) .) . (,)
08:19:39 <cnwdup> Ok. I'll try that.
08:19:49 <vixey> what a rubbish bot
08:20:02 <roconnor> cnwdup: what sjanssen said, except with MonadReader instead of Reader
08:20:06 <Saizan_> vixey: fix haskell-src :)
08:21:33 <drguildo> Saizan_, so is the last part of a function type definition always the value that's returned? and everything else is somehow bound to the parameters?
08:23:10 <dmhouse> drguildo: a function with type a -> b -> c -> d takes three parameters, of types a b and c, and returns something of type d.
08:23:33 <drguildo> right
08:23:35 <dmhouse> (I probably should have used capital letters there, since types beginning with lowercase letters are taken to be type variables in Haskell.)
08:23:50 <Saizan_> it depends on what you mean by last part and value.. however if you've foo :: A -> B -> C, and you apply it to two arguments (of the right type) what you get is a C
08:24:15 <drguildo> Saizan_, that's what i'm trying to figure out wrt that definition of when
08:24:20 <Saizan_> regardless of A, B, C being functions types or not
08:24:30 <drguildo> i.e. is the last part of it IO () or ((), RealWorld)
08:24:57 <drguildo> and are there potential definitions which could make it either of them
08:24:58 <Saizan_> drguildo:  in that definition of when the RHS is of type ((),RealWorld)
08:25:06 <drguildo> that is, seperate definitions
08:26:38 <drguildo> i guess if i removed the world parameter
08:26:38 <dmhouse> drguildo: basically the reason for this is, if f :: A -> B -> C, this really means f :: A -> (B -> C), i.e., if you give f a value, it returns _another function_, say g :: B -> C. g "knows" the A value that you gave f, and is just waiting for the B value so it can return the C value. When you write f a b, what you really mean is (f a) b, i.e., let g = f a in g b.
08:26:43 <dmhouse> This is a process called Currying.
08:26:50 <drguildo> and in the body just returned action
08:26:57 <drguildo> then it would return IO ()
08:27:00 <dmhouse> (Don't worry if that was too terse an explanation, you can always come back to it when you know a bit more Haskell.)
08:27:50 <drguildo> nope, that makes perfect sense
08:28:06 <Saizan_> drguildo: the point is that it's not only the type of what is on the right side of = that matters, but the overall type
08:28:24 <drguildo> Saizan_, can you elaborate?
08:28:48 <drguildo> i'm not sure what you mean by "overall type"
08:29:17 <drguildo> sorry if i'm being a bit slow
08:29:36 <drguildo> or a lot slow
08:30:27 <Saizan_> drguildo: since in haskell you can seamlessly partially apply functions, the difference between a function "that takes 2 arguments and returns a value" and a function "that takes 1 argument and returns another function that takes 1 argument and returns a value" is non-existant
08:30:55 <cnwdup> sjanssen: emitSignal :: SignalClass a => a -> (MonadIO m, MonadReader BotConfig m) => m () now gives "non type-variable argument" What does that mean? And do I have to use -XFlexibleContexts or can I do it without that extension?
08:31:43 <Saizan_> cnwdup: use that extension
08:32:03 <cnwdup> saizan_: Ok. But I'd like to know why I am violating Haskell 98 Standards. (-:
08:32:14 <Saizan_> also,  emitSignal :: (SignalClass a, MonadIO m, MonadReader BotConfig m) => a -> m ()
08:32:43 <cnwdup> Thank you.
08:33:06 <Saizan_> cnwdup: you're violating it because BotConfig is not a variable, haskell98 is pretty conservative on contexts, also you're violating it using MonadReader which is a MultiParameter Typeclass
08:33:19 <cnwdup> Ok
08:33:28 <Saizan_> but mtl takes the blame for that :)
08:34:15 <cnwdup> Still it complains about m doesn't match ReaderT BotConfig (StateT BotState IO).
08:34:57 <zeno_> I am trying to follow http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/index.html, but for some reason vim isnt seeing stuff in .vimfiles, e.g.E492: Not an editor command: GHCReload
08:34:59 <lambdabot> Title: Haskell mode for Vim, http://tinyurl.com/63smgv
08:35:15 <drguildo> Saizan_, right. so do i read type definitions like this: expand out all type definition that uses type "aliases", seperate the definition by " -> " and then apply the resulting parts to the parameters from left to right. if the parts left is > 1 then the function still needs more parameters before it can return the rightmost
08:35:43 <drguildo> left/remaining
08:36:02 <Saizan_> drguildo: exactly
08:36:20 <drguildo> yay
08:36:34 <Benigno> is there any squared matrix library in haskell?
08:36:40 <Saizan_> cnwdup: that means you've to generalize some of the actions it uses
08:36:40 <Benigno> :/
08:37:33 <cnwdup> saizan_: Of course! Thank you again.
08:42:19 <dmwit> Benigno: Not that I know of.
08:42:43 <dmwit> A lot of people have been asking about vector/matrix manipulations, though, so if you write one, publish it. ;-)
08:42:44 <Benigno> mmm
08:42:48 <Benigno> I found this
08:42:50 <Benigno> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
08:42:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
08:42:54 <vixey> ?dijnn [a] -> ListT (StateT x IO) a
08:42:55 <lambdabot> -- f cannot be realized.
08:43:11 <Benigno> it may work
08:43:22 <Saizan_> ?ty msum . map return
08:43:24 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
08:45:21 <vixey> weird
08:45:30 <vixey> I can get an error from ':t'
08:45:39 <vixey> "No instance for ..."
08:46:08 <Saizan_> :t show (id :: Int -> Int)
08:46:09 <lambdabot>     No instance for (Show (Int -> Int))
08:46:09 <lambdabot>       arising from a use of `show' at <interactive>:1:0-22
08:46:09 <lambdabot>     Possible fix: add an instance declaration for (Show (Int -> Int))
08:46:39 <vixey> > let foo = show (id :: Int -> Int) in 3
08:46:41 <lambdabot>  3
08:47:05 <vixey> oh I expected that to type error
08:47:07 * dmwit boggles
08:47:20 <Saizan_>  @run has an instance of Show for functions
08:47:28 <Saizan_> > (id :: Int -> Int)
08:47:29 <lambdabot>  <Int -> Int>
08:47:31 <dmwit> Oh yeah. heh
08:47:47 <dmwit> > let foo = 3 `mplus` 4 in 3
08:47:48 <lambdabot>  3
08:47:54 <dmwit> > 3 `mplus` 4
08:47:55 <lambdabot>   add an instance declaration for (Num (m a))
08:48:00 <dmwit> huh
08:48:27 <Saizan_> that's a bit scary instead
08:51:14 <dmhouse> For Typeable functions.
08:51:30 <FordCortina> Benigno: i dont know of a library but i did come accross this paper that you might find interesting http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#icfp99
08:51:31 <lambdabot> Title: Chris Okasaki's Publications
08:51:32 <dmhouse> > undefined :: a -> a
08:51:33 <lambdabot>  Add a type signature
08:52:01 <dolio> If you're not using 3 `mplus` 4, it's not going to error out.
08:52:02 <Benigno> I will check it FordCortina, thanks
08:52:22 <dolio> It won't preemptively check that there are no Num (m a) instances in scope.
08:52:34 <FordCortina> i think he does type safe square matrices there, so that might be useful
08:54:11 <dogbite> how do i raise a number to a non integral power, such as 2 ^ 2.5
08:54:33 <wjt> @ty (**)
08:54:34 <lambdabot> forall a. (Floating a) => a -> a -> a
08:54:36 <wjt> @ty (^^)
08:54:37 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
08:54:43 <FordCortina> Benigno: AFAIK hmatrix hooks into native libraries, giving you speed in haskell. but im not sure it gives you extra type-safety
08:54:48 <dmwit> > 2 ^^ 2.5
08:54:49 <lambdabot>  Add a type signature
08:54:56 <Saizan_> dolio: yeah, like top-level bindings
08:54:59 <dmwit> > 2 ** 2.5
08:55:00 <lambdabot>  5.656854249492381
08:55:09 <dogbite> dmwit: thanks
08:58:16 <dogbite> i just struggle so much with haskell numbers
08:58:18 <dogbite> df r t = 1 / ((1 + (r / 2)) **(2 * t))
08:58:22 <dogbite> how can i make that work
08:59:08 <dmwit> :t (**)
08:59:08 <dolio> @type \r t -> 1 / ((1 + (r/2)) ** (2 * t))
08:59:09 <lambdabot> forall a. (Floating a) => a -> a -> a
08:59:09 <lambdabot> forall a. (Floating a) => a -> a -> a
08:59:26 <dogbite> oh i isee i had added a type sig
08:59:29 <dogbite> and it was no longer valid
09:02:52 <ziman> :t (^^)
09:02:53 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
09:03:17 <ziman> :t (^)
09:03:18 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
09:03:36 <Cale> :t (**)
09:03:37 <lambdabot> forall a. (Floating a) => a -> a -> a
09:03:59 <dmwit> :t (*) -- the logical next guy in this sequence
09:04:00 <lambdabot> forall a. (Num a) => a -> a -> a
09:04:10 <wjt> :t ()
09:04:10 <lambdabot> ()
09:04:23 <painy> :t 4
09:04:23 <lambdabot> forall t. (Num t) => t
09:05:02 <painy> :t funct(int t) =< int t * funct (int t)
09:05:03 <lambdabot> Not in scope: `funct'
09:05:03 <lambdabot> Not in scope: `=<'
09:05:03 <lambdabot> Not in scope: `funct'
09:05:34 <dmwit> What language was that?
09:05:54 <painy> haskell i think
09:06:09 <dmwit> Where did it come from?
09:06:24 <painy> "haskell for c programmers"
09:06:44 <painy> hahaa no no i am just kidding
09:06:47 <vixey> lol
09:06:50 <painy> i was just mucking around with the bot
09:06:52 <dmwit> :t let funct int t = int t * funct (int t) in funct
09:06:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = t -> a
09:06:54 <lambdabot>     Probable cause: `funct' is applied to too few arguments
09:06:54 <lambdabot>     In the second argument of `(*)', namely `funct (int t)'
09:07:12 <dmwit> :t let funct int t = int t * funct int t in funct
09:07:13 <lambdabot> forall t a. (Num a) => (t -> a) -> t -> a
09:07:21 * edwardk waves hello.
09:07:30 <dmwit> Hiya, edwardk!
09:07:38 <painy> hey eddiee
09:08:25 <dmwit> How's Control.Category coming?
09:08:43 <vixey> oh yeah
09:08:45 <edwardk> not bad. i haven't touched it much lately. i need to go back through and add all the Mendler-style recursion schemes
09:08:52 <vixey> why is Comonad.Supply in IO ?
09:09:03 <edwardk> plus the one uustalu introduced at MSFP and its dual
09:09:09 <painy> i just installed haskell compiler, where abouts is "hugs"
09:09:20 <edwardk> vixey: you mean why does it cheat and use it?
09:09:32 <vixey> yeah :p
09:09:33 <edwardk> vixey: you can do a simpler one that doesn't but it is very wasteful of its supply
09:09:34 <dmwit> painy: If you installed GHC, hugs doesn't exist; use ghci instead.
09:09:51 <painy> ah k
09:09:55 <edwardk> i was going to make a pure supply comonad but i just never added it
09:10:06 <vixey> oh okk
09:10:15 <dmwit> painy: (GHC, Hugs, JHC, NHC are all Haskell compilers, so saying you installed "the haskell compiler" isn't specific enough. ;-)
09:10:21 <vixey> I have a supply monadt but I don't know why one would want it as a comonad
09:10:31 <edwardk> its kinda like how i was going to add an impure memoizing context comonad but never added it as well
09:10:42 <edwardk> well the supply monad's 'type
09:10:46 <edwardk>  is too large
09:11:47 <edwardk> if you implement a supply with say a state monad that carries around an int or something it can contain actions that you didn't intend. the only safety you get is because you can choose to have a closed world and not expose the properties of your monad or something.
09:12:08 <edwardk> its like how with the difference list representation of lists. [a] -> [a] contains more things that just functions that append the list you give them
09:12:27 <vixey> oh right
09:12:32 <edwardk> an action with the supply comonad can't cheat
09:12:47 <vixey> yeah that makes sense, I had to exploit that actually
09:13:15 <painy> what does ****exception Stack Overflow mean
09:13:25 <edwardk> this reminds me ineed to add the supply comonad transformer too
09:13:44 <dolio> You overflowed the stack. You need to buy new stacks.
09:13:56 <painy> what stacks
09:13:57 <dmwit> painy: You probably wrote a recursion with no base case.
09:14:08 <painy> i am using the tutorial
09:14:16 <painy> i did the factorial function for something like 29384729347
09:14:29 <dmwit> Okay, yeah, that would probably do it, too.
09:14:31 <dolio> Is it a naive recursive algorithm?
09:14:47 <dolio> Or a tail-recursive algorithm without strictness?
09:14:55 <painy> i entered 500000 about 2 minutes ago, its still computing :))
09:15:14 <dmwit> > foldl' (*) 1 [2..500000]
09:15:20 <lambdabot>  Exception: Time limit exceeded
09:15:23 <edwardk> vixey: anyways if you want to write a pure supply comonad, i'll happily take a submission ;)
09:15:34 <dmwit> painy: Anyway, have you programmed in any other languages?
09:15:41 <painy> yeah mirc script
09:15:46 <vixey> I am happy with my monad transformer :p
09:15:50 <dmwit> painy: (Or do you know what a "call stack" is?)
09:15:51 <edwardk> heh
09:15:51 <Cale> A stack overflow occurs when the distance between the expression to be evaluated and the leftmost outermost reducible subexpression in it gets too large.
09:16:01 <vixey> actually not really
09:16:10 <painy> is there a break function for haskell?
09:16:11 <vixey> it's very annoying that type synonyms can't be partially applied
09:16:18 <dmwit> painy: no
09:16:20 <painy> it still hasnt computed !500000
09:16:25 <dmwit> Ctrl-C
09:16:34 <Cale> For example, consider an expression like (...((1 + 1) + 1) + ...) + 1) + 1
09:16:35 <vixey> painy: ^C
09:16:43 <edwardk> vixey: if you are careful you can usually just make them higher kinded type aliases. (thanks cale!0
09:16:56 <painy> hmmm
09:16:59 <Cale> To begin evaluating that, you need to walk all the way down the expression to get to (1 + 1)
09:17:08 <painy> does not seem to be working... i stuffed it up, probably just have to terminate it manually
09:17:11 <dmwit> painy: What OS?
09:17:13 <dogbite> Cale: we went over that sort of expression yesterday, heh
09:17:21 <painy> Windows XP
09:17:27 <dmwit> okay, never mind
09:17:30 <dogbite> (although it came from the massive list, not that)
09:17:35 <Cale> painy: well, 500000! is rather large.
09:18:21 <painy> yeah, i did it for some numbers smaller than that and i liked watching the page suddenly fill up with numbers
09:18:34 <dmwit> > sum . map (logBase 10) $ [2..500000]
09:18:35 <lambdabot>  2632341.009791453
09:18:52 <dmwit> painy: 500000! has two and a half *million* digits. =P
09:18:57 <Cale> How are you trying to calculate it?  product [1..500000] ?
09:19:00 <edwardk> newtype Lift p f g a a = p (f a) (g a); type (:+:) = Lift Either; type (:*:) = Lift (,)  -- and so on, then (:+:) and (:*:) aren't partially applied
09:19:12 <byorgey> > length "guard foo >> bar" < length "do guard foo ; bar"
09:19:14 <Cale> That's not so large that it's unreasonable to calculate.
09:19:16 <edwardk> er Lift p f g a
09:19:16 <lambdabot>  True
09:19:22 <Cale> But it may take some time.
09:19:31 <painy> agh :o
09:19:41 <Cale> Mathematica does it on my machine in about 10 seconds or so.
09:19:50 <Cale> Naive algorithms will take longer.
09:19:58 <painy> really, what algorithm does mathematica use
09:20:01 <painy> i just used this one:
09:20:10 <painy> Prelude> let fac n = if n == 0 then 1 else n * fac (n-1)
09:20:21 <painy> haha so far nice, it reads like a sentence!
09:20:39 <Cale> fac n = product [1..n] is clearer, btw :)
09:20:48 <dmwit> Cale: GHCi does it in about 5 here. (!)
09:20:58 <Cale> dmwit: What CPU?
09:21:13 <dmwit> Pentium IV 2.8Ghz
09:21:15 <Cale> (and what algorithm?)
09:21:26 <dmwit> Clever algorithm. ;-)
09:21:43 <painy> 50, 000 just took me about 5 s
09:22:01 <dmwit> Nope, I can confirm that it is in fact 500,000.
09:22:24 <dmwit> I'll hpaste.
09:22:45 <olsner> Prelude> product [1..500000] \n*** Exception: stack overflow
09:23:08 <Cale> 1022801584651902 are the first few digits?
09:23:25 <dmwit> http://hpaste.org/9170
09:23:55 <painy> how do i paste that in ghci
09:24:03 <dmwit> Cale: yes
09:24:05 <Cale> painy: you don't
09:24:11 <olsner> put it in a file then load it
09:24:17 <dmwit> Cale: Then 36533091744057
09:24:18 <painy> ack, okay, i'll stop being "lazy" and compile it :p
09:24:31 <painy> but the language is lazy :(*
09:24:44 <painy> or so i'm told..
09:24:50 <Cale> painy: you don't have to compile it, you just have to put it in a text file
09:25:06 <olsner> you can still ghci foo.hs, no need to compile
09:25:32 <painy> k, so i just type foo.hs ?
09:25:41 <johnnowak> is this a limitation of ghci or of haskell's syntax?
09:25:47 <dmwit> painy: No, type "ghci foo.hs".
09:25:52 <painy> thanks
09:25:59 <dmwit> johnnowak: It's hard to say.
09:26:15 <dmwit> johnnowak: I'm of the opinion that ghci could use Python's method of waiting for a double-enter.
09:26:21 <johnnowak> seems like the syntax makes it hard for ghci to do "the right thing".
09:26:28 <Botje> ghci accepts multiline statements now
09:26:33 <dmwit> johnnowak: i.e. a blank line ends a block
09:26:36 <johnnowak> dmwit: aye, but even that's not really a great solution.
09:26:36 <olsner> 53s for a naive foldl'-based 500000!
09:26:52 <dmwit> johnnowak: Oh, well, I don't think you can do much better than that.
09:27:05 <dmwit> johnnowak: Unless you want to have to use {;} notation at the ghci prompt. =/
09:27:07 * johnnowak spews terminal characters
09:27:22 <johnnowak> dmwit: heh, well, not so much.
09:27:25 <dmwit> Botje: In HEAD?  What's the behavior?
09:27:27 * Botje resets johnnowak 
09:27:38 <Botje> dmwit: even 6.8.2 had it iirc
09:27:42 <dogbite> how do i split a string based on a character?
09:27:46 <dmwit> Botje: How do I enable it?
09:27:55 <Botje> dmwit: you can't really enable it, it's syntax
09:28:01 <Botje>    :{\n ..lines.. \n:}\n       multiline command
09:28:09 <Cale> dmwit: ah, you weren't including the IO in that timing
09:28:10 <dmwit> Botje: "let fold x = y where" gives me an error.
09:28:15 <dmwit> Cale: Ah, no.
09:28:27 <Cale> dmwit: It only takes mathematica 1.11s to just do the computation.
09:28:31 <dmwit> aha
09:28:41 <Cale> (and ghci 5.63)
09:28:46 <johnnowak> it would be nice if GHCI has a "paste mode" where you could enter things in as if they were in a file.
09:29:06 <johnnowak> and it would just wait until it got ^D or something.
09:29:22 <byorgey> the problem is that the ghci prompt is essentially a do-block in the IO monad.
09:29:25 <dmwit> Botje: Oh, neeeeat!
09:29:34 <dmwit> johnnowak: Try :{ as Botje suggested!
09:29:46 <olsner> dmwit: did you count the time to print the number in those 5s?
09:29:51 <dmwit> olsner: no
09:29:53 <vixey> Just put it in a file
09:29:55 <Botje> I enabled it by accident :)
09:29:56 <dmwit> olsner: Only the calculation.
09:29:58 <vixey> then use :l <filename>
09:30:00 <johnnowak> dmwit: ah!
09:30:07 <painy> okay fact 500 000 took about 5 seconds for me too, using that algorithm
09:30:09 <dmwit> Botje++
09:30:58 <Cale> I wonder if we can make it any better with regard to keeping the products balanced.
09:31:09 <painy> got any other small & fun programs to share dmwit?
09:31:10 <olsner> parallelise! :D
09:31:17 <Cale> You want the number of digits in the numbers you multiply to be about equal.
09:31:29 <dmwit> Cale: That was the idea of the binary fold there on hpaste. =P
09:31:33 <Cale> right
09:31:51 <Cale> But it's still somewhat unbalanced, is it not?
09:31:55 <dmwit> yeah
09:32:03 <painy> so how do you think Mathematica is performing the calc so quick
09:32:46 <Cale> painy: I think it's doing sort of what we're doing, but slightly more cleverly. That is, choosing a clever association of the products to be taken.
09:33:06 <dmwit> Mathematica probably has a lot less overhead, too, as far as thunks go.
09:33:16 <dmwit> I didn't really make any attempt to strictify things.
09:34:01 <painy> anyone else got any cool little things like that to share?
09:34:16 <Cale> Well, multiplication is strict
09:34:17 <dmwit> painy: You mean little algorithms like foldb, or what?
09:34:35 <painy> yes
09:34:41 <painy> or something graphical, with math?
09:35:51 <dmwit> http://hpaste.org/7572 -- the module I keep to make Haskell programming less boilerplatish
09:36:21 <Cale> Compiling with -O2 gets me down to 4.3s, and adding a strictness annotation to pairwise from there gets me down to 3.7s
09:37:51 <dmwit> That's like... 60% faster. O_o
09:38:45 <dmwit> painy: If you want something graphical, check out Gtk2Hs' L-tree demo, it's really neat!
09:39:15 <painy> okay cool thanks
09:39:37 <painy> what does this module do
09:39:50 <dmwit> Gtk2Hs is a binding to Gtk2.
09:40:06 <dmwit> Gtk2 is a library for creating good-looking, well-behaved GUIs.
09:40:11 <Cale> Or you could install nymphaea :)
09:40:20 <Cale> (it's on hackage somehow :)
09:40:22 <dmwit> ?go nymphaea
09:40:23 <lambdabot> http://en.wikipedia.org/wiki/Nymphaea
09:40:23 <lambdabot> Title: Nymphaea - Wikipedia, the free encyclopedia
09:40:39 <dmwit> ?go nymphaea haskell
09:40:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nymphaea
09:40:41 <lambdabot> Title: HackageDB: nymphaea-0.2
09:40:48 <painy> what does the module you pasted do, dmwit
09:41:02 <Zao> painy: Evaluate L-systems.
09:41:06 <dmwit> painy: Nothing, on its own.  It's just a list of functions I often find useful.
09:41:14 <painy> oh i see
09:41:18 <Zao> Oh, the paste.
09:41:29 <painy> :D
09:41:36 <olsner> I got 1.7s from plain ghci (take 30 . show . factorial $ 500000), 1.38 from ghc -O2, and 1.27 from ghc -O2 after throwing in a few seq's
09:41:41 <Cale> You can even cabal install nymphaea :)
09:42:01 <painy> i will see nymphaea
09:42:33 <Cale> It's a nondeterministic L-system generator that xerox and I wrote a while back :)
09:42:46 <dmwit> Cale: Do you have any screenshots?  I think this is actually the thing I was referring to, but I remember seeing some screenies.
09:42:56 <painy> ack - ".tar.gz"
09:43:08 <painy> oh you wrote it did you? cool
09:43:13 <Cale> I'll take one
09:43:40 <painy> where is the windows download
09:43:58 <Cale> http://cale.yi.org/autoshare/Screenshot-Nymphaea.png
09:44:04 <painy> oh nevermind
09:44:16 <Cale> painy: The .tar.gz is of source code.
09:44:31 <painy> oh
09:44:39 <Cale> painy: If you have cabal-install installed, you can just use  cabal --global install nymphaea
09:44:45 <chrisdone> heh, rails is suprisingly painful to figure out how to use
09:44:50 <painy> well, nope i do not
09:45:01 <Cale> But I don't know if that works on windows, since I don't use windows.
09:45:05 <painy> should i get it, or go find the compiled prog
09:45:10 <Cale> (but I don't see why it shouldn't)
09:45:34 <Cale> I very much recommend getting cabal-install
09:45:44 <dmwit> I will be mildly surprised if you find a Windows binary of nymphaea.
09:45:51 <Cale> It's very convenient -- it downloads and installs any of the packages from Hackage.
09:45:51 <dmwit> Cale: So pretty...
09:46:03 <painy> okay, thanks
09:46:49 <painy> wow yes very nice
09:47:02 <painy> and i can see my name sticking up behind the windows
09:47:17 <dmwit> Now you're famous! =)
09:47:30 <painy> ahah'
09:47:56 <Cale> Once you get it, note that you can click and drag in the drawing window to set the starting point and angle.
09:48:54 <Cale> It will cause the random choices to be made again, so you'll get a different plant every time :)
09:49:22 <painy> what algorithm did you use
09:49:31 <painy> ..if it's simple enough to phrase
09:49:33 <Cale> To expand the L-system?
09:49:39 <painy> what's an L system
09:49:46 <painy> ehh nevermind sounds beyond me
09:49:49 <dmwit> wikipedia to the rescue
09:49:55 <Cale> http://en.wikipedia.org/wiki/L-system
09:49:55 <lambdabot> Title: L-system - Wikipedia, the free encyclopedia
09:50:02 <Cale> It's pretty simple, actually
09:50:07 <dmwit> It is not beyond anybody, it's a very elegant fractal form.
09:50:31 <Cale> A basic L-system consists of a starting word, and a bunch of rules.
09:50:54 <Cale> The rules are of the form X -> Y, where X is some letter, and Y is a sequence of letters.
09:51:34 <painy> what is "->"
09:51:39 <Cale> Just an arrow
09:51:43 <painy> oh hah
09:51:54 <Cale> To expand the L-system, you use the rules to replace each letter of the starting word according to the rules
09:51:55 <painy> well.. it sounds like any other function then?
09:52:15 <Cale> For example, if you have the starting word "F"
09:52:26 <Cale> and rules F -> GFG, and G -> G
09:52:40 <Cale> then after one expansion, you have  "GFG"
09:52:48 <painy> mmm
09:52:49 <Cale> and after two, you have "GGFGG"
09:53:01 <painy> yes, pretty simple
09:53:06 <painy> and how do you now use this to draw a plant
09:53:29 <Cale> The idea is to have some letters which indicate drawing commands.
09:54:00 <Cale> and then use some rules to say how to transform drawing commands into sequences of drawing commands
09:54:20 <painy> eg?
09:54:30 <Cale> So instead of drawing a line forward, maybe draw a little branching shape.
09:54:55 <Cale> and then replace all the lines in that branching shape with little branching shapes over and over, and you'll get a tree :)
09:55:44 <johnnowak> painy: in other words, assign arbitrary tree-like drawing routines to a system and you'll end up with something rather tree-like :)
09:55:46 <Cale> Nymphaea adds a new feature to the basic idea of L-systems. Instead of rules having just one possible expansion, they can have many, each with a certain probability associated with it.
09:56:15 <Cale> So you can have many different kinds of branching shapes (in the screenshot, there were three possibilities)
09:56:31 <Cale> and every time it does the expansion, it picks one at random
09:57:04 <painy> wow i'm blown away
09:57:15 <painy> thanks
09:57:25 <painy> i am so going to make something with this
09:57:57 <Cale> btw, F is the command to draw a line segment forward from the current point in the current direction
09:57:58 <dmwit> http://citeseer.ist.psu.edu/dershowitz93taste.html # you may also like
09:57:59 <lambdabot> Title: A Taste of Rewrite Systems - Dershowitz (ResearchIndex)
09:58:03 <Cale> G skips some space
09:58:14 <Cale> (like drawing a line segment, but without drawing anything)
09:58:25 <Cale> + turns left, - turns right
09:58:38 <Cale> | turns a half-circle
09:58:47 <Cale> [ saves the current position on a stack
09:58:53 <Cale> ] restores the current position
09:59:05 <Cale> everything else is just ignored.
09:59:56 <Cale> @google The Algorithmic Beauty of Plants
09:59:58 <lambdabot> http://algorithmicbotany.org/papers/
09:59:58 <lambdabot> Title: Algorithmic Botany: Publications
10:00:22 <vixey> > f 0 = x ; f n = f (n-1) + x + f (n-1)
10:00:22 <lambdabot>  Parse error at "=" (column 5)
10:00:39 <Cale> near the bottom of that page, you'll find a whole free book about modelling plants realistically using L-systems and other mathematical structures.
10:00:49 <dmwit> > let f 0 = x; f n = f (n - 1) + x + f (n - x) in f 3
10:00:55 <lambdabot>  x + x + (Exception: Time limit exceeded
10:01:07 <dmwit> err... what?
10:01:08 <dmwit> oh
10:01:12 <dmwit> > let f 0 = x; f n = f (n - 1) + x + f (n - 1) in f 3
10:01:13 <lambdabot>  x + x + x + x + (x + x + x) + x + (x + x + x + x + (x + x + x))
10:01:33 <vixey> > let f 0 = x; f n = f (n - 1) + x - f (n - 1) in f 3
10:01:34 <lambdabot>  x + x - x + x - (x + x - x) + x - (x + x - x + x - (x + x - x))
10:02:30 <dmwit> > let f = const x in f 3 -- vixey ;-)
10:02:31 <lambdabot>  x
10:03:02 <dmwit> Well, really it's
10:03:16 <johnnowak> > x + y == y + x
10:03:17 <lambdabot>  False
10:03:26 <dmwit> > let f n = if n < 0 then f n else x in f 3
10:03:27 <lambdabot>  x
10:03:40 <vixey> @check x + y == y + x
10:03:41 <lambdabot>  Falsifiable, after 0 tests:
10:03:53 <dmwit> ?check \x y -> x + y == y + x
10:03:54 <lambdabot>  OK, passed 500 tests.
10:04:19 <vixey> @check \x -> x == reverse x
10:04:19 <dmwit> ?check \x -> liftM2 (==) (x+) (+x)
10:04:20 <lambdabot>  OK, passed 500 tests.
10:04:21 <lambdabot>  OK, passed 500 tests.
10:04:46 <dmwit> ?check \x -> x == reverse (x :: [Int])
10:04:48 <lambdabot>  Falsifiable, after 2 tests: [3,1,0]
10:05:03 <dmwit> vixey: Sneaky. () == ()
10:05:05 <geezusfreeek> i love it when GHC says "My brain just exploded."
10:10:54 <johnnowak> ?check \x -> sqrt x == sqrt x
10:10:55 <lambdabot>  Falsifiable, after 2 tests: -0.6666666666666666
10:12:56 <Cale> ?check \x -> x >= 0 ==> sqrt x == sqrt x
10:12:57 <lambdabot>  OK, passed 500 tests.
10:13:05 <johnnowak> there we are
10:14:51 <Beelsebob> @check \x -> x == mempty
10:14:52 <lambdabot>  OK, passed 500 tests.
10:14:55 <Beelsebob> :)
10:16:03 <edwardk> @check (==mzero)
10:16:04 <lambdabot>   add an instance declaration for (Eq (m a))
10:16:11 <edwardk> @check (==mempty)
10:16:12 <lambdabot>  OK, passed 500 tests.
10:16:17 <edwardk> strange
10:16:28 <edwardk> @type (==mempty)
10:16:29 <lambdabot> forall a. (Eq a, Monoid a) => a -> Bool
10:16:30 <Beelsebob> it's automatically chosing the unit type
10:16:33 <edwardk> ah
10:16:39 <edwardk> cheaty
10:18:00 <Nocta^> what is the best source for learning haskell?
10:18:08 <johnnowak> ?check \x -> x * (4 + 5) == x * 4 + x * 5
10:18:09 <lambdabot>  OK, passed 500 tests.
10:18:20 <johnnowak> how can I get that to consider the possibility of x as a floating point?
10:18:20 <Beelsebob> Nocta^: from what background?
10:18:30 <jeffwheeler> Nocta^: Depends on how you learn best; I like to Google for tutorials.
10:18:42 <Beelsebob> @check \(x :: Float) -> x * (4 + 5) == x * 4 + x * 5
10:18:42 <lambdabot>  Parse error in pattern at "->" (column 15)
10:18:45 <jeffwheeler> Some people like books.
10:18:50 <Heffalump> ?check \x -> (x :: Float) * (4 + 5) == x * 4 + x * 5
10:18:51 <lambdabot>  OK, passed 500 tests.
10:18:53 <Nocta^> Beelsebob: Python, and some C-like languages ..
10:18:58 <slarba> Nocta^: http://book.realworldhaskell.org/beta/index.html
10:19:01 <lambdabot> Title: Real World Haskell
10:19:07 <Heffalump> (you need -XPatternSignatures to make that work otherwise)
10:19:09 <slarba> that seems to be decent with some real examples
10:19:17 <Nocta^> slarba: okay, thx
10:19:23 <Beelsebob> Nocta^: well, your best start is to forget everything you think you know about programming, and then drive into a tutorial
10:19:46 <Nocta^> Beelsebob: i've heard this before ... let's see if it's true :)
10:19:51 <slarba> Nocta^: a very good book is paul hudak's the haskell school of expression
10:20:04 <johnnowak> ?check \x -> (x :: Float) * (4 + 5) == x * 4 + x * 5
10:20:05 <Beelsebob> slarba: tbh, I'd call that the *worst* book to start with
10:20:05 <lambdabot>  OK, passed 500 tests.
10:20:09 <Nocta^> slarba: do i have to buy that book?
10:20:11 <johnnowak> > (\x -> (x :: Float) * (4 + 5) == x * 4 + x * 5) 2.2
10:20:12 <lambdabot>  False
10:20:18 <slarba> Beelsebob: why's that?
10:20:25 <zachk> ok this is wrong: openFile "stuff.txt" writeMode,  is it WriteMode?
10:20:40 <Beelsebob> slarba: because it teaches something that isn't at all functional programming -- it teaches you have to write imperative programs in a functional language
10:21:03 <slarba> Beelsebob: uhm.
10:21:10 <Beelsebob> slarba: I'd go with either Simon J Thompson's book, or the more recent one by <insert name I can't remember>
10:21:25 <Heffalump> Graham Hutton
10:21:29 <Beelsebob> that's the one
10:21:42 <Nocta^> hm i think i'll start with some online tutorials
10:21:47 <zachk> yeap its WriteMode
10:21:49 <Beelsebob> tis a good plan
10:21:53 <dogbite> try real world haskell
10:22:09 <dogbite> also i actually think the haskell 98 report
10:22:16 <Beelsebob> heh
10:22:19 <dogbite> which most descriptions call too complex as an intro
10:22:21 <Beelsebob> I'm not sure that's a good beginner text
10:22:24 <dogbite> is actually a fine start
10:22:28 <slarba> Beelsebob: well, for beginners, good realworld examples are a good thing. It gets you somewhere
10:22:40 <Nocta^> dogbite: i'll start with real world haskell then
10:22:44 <slarba> Beelsebob: and that unfortunately requires some imperative programming.
10:22:56 <Beelsebob> slarba: no, for beginners, telling them things like "you have to do imperative programming to do functional programming" is both misleading and counterproductive
10:23:02 <Beelsebob> and no it doesn't
10:23:14 <Beelsebob> FRP manages to do plenty of real world stuff without getting imperative
10:23:42 <dogbite> well this whole imperative versus functional is abit
10:23:45 <Nocta^> so what now? :D
10:23:50 <dogbite> besides the point
10:23:53 <Beelsebob> Nocta^: get reading :D
10:23:56 <dogbite> there's so much to leran in terms of syntax
10:24:19 <dogbite> and just... understanding basics..
10:24:20 <Beelsebob> dogbite: indeed -- but it's a bad idea to start learning the syntax with a bunch of examples that essentially just do imperative programming
10:24:30 <Beelsebob> much better to have the functional paradigm sink in at the same time
10:24:51 <dogbite> Beelsebob: that may be.  maybe a good start is Alice in Wonderland
10:24:57 <dogbite> open up your mind a bit
10:25:22 <Beelsebob> dogbite: I'm not sure what you're asking me to open my mind to
10:25:33 <dogbite> no not you
10:25:36 <dogbite> i'm saying a beginner
10:25:42 <Beelsebob> oh yeh, sure
10:25:42 <dogbite> before they dive in
10:25:48 <Nocta^> i think i'll have no problems to change my programming style or what you're talking about later. actually you have to do this in _every_ language, so it's nothing you should be scared of
10:25:49 <Beelsebob> hehe, that sounds like a good plan
10:27:02 <Beelsebob> Nocta^: yeh, just a slight warning that you're in for a bigger shock with Python -> Haskell than with C -> Python
10:27:16 <slarba> Beelsebob: I'd be glad to see a good haskell tutorial that starts with the FRP approach.
10:27:20 <johnnowak> Nocta^: if you have no functional programming experience, you may want to learn something else before tackling haskell. Learning Scheme with the HTDP book is a nice way to approach it.
10:27:35 <Beelsebob> slarba: I believe a guy called David Sankel is working on exactly that
10:27:59 <johnnowak> Nocta^: having to pick up FP *and* the type system at the same time is a bit much
10:27:59 <FordCortina> Beelsebob: its not as if Hutton's book covers FRP does it though?
10:28:02 <zachk> Nocta^: scheme is good, breaks you away from syntax and loops
10:28:02 <Nocta^> johnnowak: but why should i first learn another language?
10:28:22 <zachk> Nocta^: are you good at math?
10:28:43 <Cale> johnnowak: Actually, I think learning the type system along with functional programming is really helpful.
10:28:48 <pejo> Beelsebob, doesn't the existing frp-implementations suffer from space leaks, and some other problems?
10:29:05 <Beelsebob> pejo: Reactive doesn't
10:29:09 <Beelsebob> Yampa certainly does
10:29:10 <Nocta^> zachk: i dont know very much mathematical stuff except the things i learned in school ... but yes, im not bad :p
10:29:31 <pejo> Beelsebob, is that conal's latest code?
10:29:51 <Cale> The type system acts like the nubs on lego blocks. It helps you put things together in ways that make sense.
10:30:03 <Beelsebob> pejo: yeh -- we've been using Reactive to code some really pretty serious UI stuffs at Anygma
10:30:10 <Beelsebob> it's been scaling fine
10:30:15 <pejo> Beelsebob, "Anygma"?
10:30:20 <johnnowak> Cale: I see them as largely separate. You can learn FP in Scheme without having to learn about types (and without having to learn Haskell's gnarly syntax). Sure, the type system stops you from making some errors, but then you have to learn how to interpret what it's telling you.
10:30:31 <Beelsebob> pejo: where conal's currently working -- a startup in antwerp
10:30:32 <geezusfreeek__> Beelsebob: have you not run into any deadlock problems with Reactive yet?
10:30:43 <slarba> Beelsebob: another thing to consider: a vast majority of haskell software written is NOT written in FRP style, because most problems don't require that
10:30:48 <geezusfreeek__> oh this is the rewritten one, isn't it?
10:30:50 <pejo> Beelsebob, that's really nice to hear though.
10:30:56 <Beelsebob> geezusfreeek__: we have actually -- found one bug that seemed to be affecting *lots* of programs  -- it's fixed now
10:31:18 <geezusfreeek> Beelsebob: aha. do you recall what it was?
10:31:25 <slarba> Beelsebob: just getting the
10:31:28 <slarba> oops
10:31:28 <Cale> johnnowak: Yeah, you can. I'm just saying that having the type system there is useful as a beginner. (At least I found it useful when I was a beginner.)
10:31:31 <Beelsebob> slarba: no, most programs don't *require* it -- but they would be a lot more nicely written in FRP styles
10:31:37 <slarba> (premature enter)
10:31:46 <pejo> slarba, adoption of frameworks and libraries is not necessary dependent on whether the probelm "needs" it or not.
10:31:49 <Beelsebob> geezusfreeek: it was an odd interaction with unsafePerformIO in the unambiguous choice function
10:32:01 <geezusfreeek> oh okay
10:32:03 <Beelsebob> an entirely new way for unsafePerformIO to be unsafe
10:32:35 <Nocta^> mh i didnt want to start such a big discussion about how to program haskell and what to learn first :o
10:32:44 <Cale> When you're writing scheme code, you still have to think about types, but there's no formalism handed to you on a silver platter. You just have to figure out your own way to make sure you get things straight.
10:32:51 <geezusfreeek> still working on my own frp stuff. tiny space leaks are still my main problem. very frustrating and hard to track down
10:33:06 <slarba> Beelsebob: I think the first step is to know basics how to do imperative style interfacing with the world, so you can attempt functional solutions to problems one has encountered before with another language.
10:33:22 <slarba> then go to FRP and learn more
10:33:39 <slarba> there's just too much to learn if you do one huge gulp
10:33:40 <johnnowak> Cale: That's true, but being able to run a program and see dynamically why it is incorrect (perhaps while stepping through the evaluation) is often very useful. That's something you can't do in Haskell if there's a type error.
10:33:41 <thaldyron> I'm trying out HSLogger but I get the error: "sendTo: protocol error (Protocol wrong type for socket)". I'm using syslog-ng-2.0.9, is the syslog handler compatible with it?
10:33:41 <Beelsebob> Nocta^: tbh, I'd just go for it on learning some really basic haskell from either tutorials or the online book
10:34:00 <Beelsebob> if you have problems -- come ask about them, and see if people have suitable answers, or recomendations to try something else
10:34:39 <ttt--> johnnowak, you could step through the type checker evaluation :)
10:34:45 <geezusfreeek> johnnowak: otoh, that's something that's not very simple to pick up on in haskell anyway (stepping through the evaluation)
10:34:54 <Nocta^> Beelsebob: yes, i will start now ;)
10:34:55 <johnnowak> geezusfreeek: even more reason to start with scheme. :)
10:35:10 <pejo> geezusfreeek, what about the debugger?
10:35:20 <geezusfreeek> pejo: easy to use, not so easy to understand for a beginner
10:35:31 <pejo> Beelsebob, is it a secret what they are doing, or can you tell?
10:35:34 <johnnowak> I'll admit I'm very biased towards the approach taken with HtDP. If someone similar existed for Haskell, I might not recommend Scheme so strongly as a means of learning FP.
10:35:40 <johnnowak> *something
10:35:56 <cnwdup> http://hpaste.org/9171 I have some trouble matching an existential type. Can anyone tell me what I am doing wrong?  http://hpaste.org/9171
10:36:03 <cnwdup> Uh, sorry for double posting.
10:36:28 <erikc> does anyone know of any research in the representation of 'time-sensitive' grammars and generation of parsers for them
10:36:56 <pejo> erikc, time sensitive in what way?
10:37:07 <erikc> by time sensitive, i would mean something like 'hold x for 5 seconds within 1 second of doing a quarter circle on the joystick'
10:37:08 <Cale> cnwdup: Do you understand what existential types mean?
10:37:45 <Cale> cnwdup: When you have a value of type Signal, you know that it's of the form  Signal x, where x is of *some* type which is an instance of SignalClass
10:37:59 <erikc> i can do it as a parser of input but that assumes a fixed time step
10:37:59 <Cale> cnwdup: You're not allowed to assume anything about what that type is.
10:38:16 <erikc> parser of input samples
10:38:17 <Cale> cnwdup: In particular, you have no way of telling whether or not it is a Foo
10:39:00 <Cale> cnwdup: You can apply info to the thing inside the Signal, and that's it.
10:39:05 <zachk> > "hi"
10:39:21 <lambdabot>  thread killed
10:39:26 <johnnowak> > "hi"
10:39:27 <lambdabot>  "hi"
10:39:27 <Cale> > "hi"
10:39:28 <lambdabot>  "hi"
10:39:37 <zachk> huh?
10:39:38 <Cale> Just random slowness on the server.
10:39:43 <zachk> ahhh
10:39:52 <cnwdup> cale: ok
10:40:02 <zachk> how do i get ctrl-b into a haskell string?
10:40:03 <johnnowak> zachk: lambdabot is actually written in php
10:40:19 <zachk> and php is actually written mips assembly, yes i know all about it
10:40:38 <johnnowak> hehe
10:41:27 <johnnowak> > "\^b"
10:41:27 <lambdabot>  Illegal control character at ""\^b"" (column 1)
10:41:39 <johnnowak> > "\^B"
10:41:40 <lambdabot>  "\STX"
10:41:55 <zachk> but ghci whines at me about \stx :-*(
10:42:11 <zachk> > "^B"
10:42:12 <lambdabot>  "^B"
10:42:20 <zachk> ohhhh
10:42:21 <johnnowak> zachk: what about "\STX" ?
10:42:31 <zachk> > "\^B"
10:42:32 <lambdabot>  "\STX"
10:44:47 <cnwdup> cale: What can I use if I want to queue abitrary data types in a list if I want to be able to unpack them?
10:46:55 <cnwdup> Are dynamic types what I am looking for?
10:47:31 <zachk> maybe you want a union
10:47:40 <zachk> but its still going to be probably not what you want
10:47:57 <cnwdup> Thanks. I'll read about them.
10:48:27 <Cale> cnwdup: see, if something could be anything at all, then there's nothing at all you can do with it.
10:48:58 <Cale> cnwdup: So you need to decide what things you want to be able to do with the items in the list. That is, what do they have in common.
10:49:12 <Cale> Once you know that, then an appropriate existential type might do the trick.
10:49:34 <cnwdup> cale: They have in common that they are sent to abitrary functions which do something with them if they know how or which do not. That's pretty much what I am looking for.
10:49:34 <erikc> or you build your own dynamic type system within haskell using unsafe/foreign facilities :)
10:50:41 <Cale> What do you mean "if they know how"?
10:51:40 <johnnowak> cnwdup: http://hpaste.org/9173 -- is this what you're looking for?
10:52:21 <cnwdup> I have signals which can be abitrary types. Some of them carry information, some do not. Once I receive such a signal I call all plugin functions which handle signals. If they registered upon that signal, they can handle it. They can process it if the function is written to operate on that signal which I wanted to accomplish using pattern matching. And they just return nothing (ignore that signal) if its unknown to them.
10:53:11 <cnwdup> Kind of. But I need Foo to be extensible to an abitrary amount which leads to classes (doesn't it?) which leads to existential types (doesn't it?) which isn't what I want.
10:53:32 <erikc> is it extensible at runtime?
10:53:44 <cnwdup> Not necessarily.
10:54:31 <Botje> cnwdup: Dynamic?
10:54:49 <Cale> You might want Data.Dynamic
10:56:17 <Cale> What are you eventually doing with this list?
10:56:54 <cnwdup> Yeah. I'll have to read about them. I encountered them once browsing a piece of code. But I don't know what they do exactly.
10:57:04 <Cale> Given that it's a list where each element could be absolutely anything at all, it's hard to imagine that you can do anything useful with it.
10:57:22 <cnwdup> cale: I am processing it piece by piece. I'll have a list functioning as a queue. I write some elemts to the end and process the first elemt from the top dropping it afterwards.
10:57:46 <erikc> is there a way to tell which base libraries required special compiler support and which are pure haskell? can you implement things like Control.Exception, Data.Typeable, Data.Dynamic in pure haskell?
10:57:53 <cnwdup> I am not quite sure if a list is the best thing to use for that. I implemented a queue using a list and MVars kinda like the SampleVar implementation.
10:57:57 <erikc> (or required dropping out to C)
10:58:14 <Cale> erikc: There's one little cheat involved in Dynamic/Typeable
10:58:28 <Cale> erikc: (which involves ignoring the type system)
10:58:37 <erikc> hehe
10:58:59 <erikc> what about Control.Exception's 'stack unwinding'?
10:59:34 <Cale> It's just part of the IO monad. It could conceivably be implemented in pure Haskell (as a syntactic thing which the facility that executes IO actions will interpret)
11:01:29 <Cale> By which I mean that IO could be a type defined something like:
11:01:33 <Cale> data IO a where
11:01:38 <Cale>    ReturnIO :: a -> IO a
11:01:48 <Cale>    BindIO :: IO a -> (a -> IO b) -> IO b
11:01:59 <Cale>    PutChar :: Char -> IO ()
11:02:41 <roconnor> that's a stupid data type
11:02:51 <Cale> roconnor: oh?
11:03:16 <roconnor> it captures very few properties of IO
11:03:30 <Cale> Basically just captures the syntax of IO.
11:03:33 <roconnor> in particular it doesn't capture the monad laws
11:03:42 <erikc> right, i guess im wondering how catch could work then, does catch work by doing an unsafePerformIO of its IO a then, then based on the result, chooses the result path?
11:04:15 <erikc> there is no stack unwinding in the imperative sense
11:04:25 <Heffalump> roconnor: non-canonical /= stupid :-)
11:04:55 <roconnor> Heffalump: I'll consider what you say
11:04:57 <Cale> Well, the thing which is presumably interpreting the IO action will see the catch, try to execute the IO action, and if it fails, will apply the exception it got to the function supplied.
11:05:08 <Cale> and then carry on with the result of that application
11:06:34 <Heffalump> roconnor: thank you
11:06:45 <Cale> roconnor: It's a 'bigger' datatype than IO is really supposed to be -- we'd want to quotient by the monad laws, but then we'd have something which isn't free.
11:06:53 <dolio> People who don't like free term algebras are stupid.
11:07:11 <roconnor> IO isn't free
11:07:24 <roconnor> is it?
11:07:59 <ahunter2> Does anyone know of a good ST implementation of disjoint-set union?  Ideally the Tarjan style?
11:08:23 <reilly> is anybody on familiar with Text.JSON?
11:08:33 <dolio> There aren't really many ST-using libraries out there.
11:08:49 <ahunter2> dolio: that's a pity.  disjoint set union is pretty damn useful
11:08:52 <dolio> At least, not algorithm libraries.
11:08:53 <ahunter2> maybe I should write one, it would be good practidce
11:10:41 <chessguy> reilly:  are you talking about a library, or the JSON standard?
11:10:50 <reilly> the library
11:10:57 <chessguy> oh, hadn't heard of it
11:11:02 <chessguy> @where TextJSON
11:11:03 <lambdabot> I know nothing about textjson.
11:11:06 <chessguy> @go textjson
11:11:07 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
11:11:14 <reilly> it looks like don stewart wrote it
11:11:51 <reilly> http://hackage.haskell.org/packages/archive/json/0.3.3/doc/html/Text-JSON.html
11:11:52 <lambdabot> Title: Text.JSON, http://tinyurl.com/5j5gdg
11:12:16 <mjrosenb> @hoogle ([a]->Bool)
11:12:16 <lambdabot> Prelude.null :: [a] -> Bool
11:12:16 <lambdabot> Data.List.null :: [a] -> Bool
11:12:16 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
11:12:19 <mjrosenb> gah
11:12:33 <mjrosenb> @hoogle ([a]->Bool) -> [a] -> [a]
11:12:34 <lambdabot> No matches, try a more general search
11:12:43 <roconnor> Heffalump: You are right; however in this particular case I don't see the advantage of the purely syntactic representation of IO.
11:12:44 <reilly> and I'm just not getting it ... I see the parts .... but it looks really clumsy ... but if dons wrote it I doubt it really is
11:12:48 <mjrosenb> blast
11:14:03 <Botje> reilly: 90% of everything is crap
11:14:19 <Botje> even dons has a non-zero chance of writing crap :)
11:14:52 <reilly> there are a few decisions in the library that look really weird to me ... JSObject is a Data constructor for the JSValue type.  But there's also a Type Constructor called JSObject
11:15:08 <reilly> Botje: probably true
11:15:26 <Cale> This is the JSON library?
11:15:33 <reilly> Cale: yes
11:15:47 <Cale> I used that a while back and it was rather nice
11:16:43 <reilly> It seems that the primary use case is serialization of haskell data.  unless I am missing something it looks like a pain in the ass for extracting values from arbitrary JSON
11:17:03 <mjrosenb> @pl \x -> product x < n
11:17:03 <lambdabot> (< n) . product
11:17:14 <Cale> Well, it's a bit of work, but shouldn't be too bad...
11:17:51 <Cale> You write a readJSON for your datatype
11:17:52 <reilly> which is a pretty typical use case for JSON.  you talk to a web service, get a result .. dig into the result for the part you want and ignore the rest (which may include data added since you wrote your program)
11:19:03 <Cale> Well, there might be some assumption here that you're going to attempt to represent all the stuff encoded in the JSON back on the Haskell side.
11:19:16 <reilly> Cale: that will be great for some use-cases I'e got later.  not for the one I am talking now.
11:19:27 <Cale> It's certainly much easier to write instances of JSON when you do that.
11:20:20 <Cale> However, I suppose you don't have to extract everything if you don't want to.
11:20:25 <reilly> Cale:  That seems to be the assumption.  I'm building a client to a web-service.  The results for some of the operations have only 1 item I am interested in.
11:21:45 <reilly> Cale: True.  I think I'm going to have to write something that walks the JSON structure looking for first matches.
11:22:23 <Cale> So I suppose you write a Maybe-valued function that pattern matches on the parsed JSON and extracts the part you're interested in.
11:24:17 <ddarius> @google first class patterns
11:24:19 <lambdabot> http://citeseer.ist.psu.edu/tullsen00first.html
11:24:19 <lambdabot> Title: First Class Patterns - Tullsen (ResearchIndex)
11:24:29 <Cale> oh, something important to note...
11:24:33 <Cale> (Ord a, JSON a, JSON b) => JSON (Map a b)
11:25:16 <Cale> oh, nm, that doesn't do what I'd hoped :/
11:26:59 <Cale> hmm
11:28:23 <Cale> I find the treatment of JSString as a separate type a bit surprising...
11:28:27 <Cale> newtype JSString   = JSONString { fromJSString :: String }
11:28:27 <Cale>     deriving (Eq, Ord, Show, Read)
11:28:34 <Cale> especially as that's the implementation
11:28:51 <Cale> Perhaps the intention is to replace String with something else at some point there.
11:33:51 <dmhouse> Gah, where the hell is httpd.conf
11:34:22 <johnnowak> wherever your vendor decided to put it obviously
11:34:53 <johnnowak> dmhouse: what platform?
11:35:02 <dmhouse> Ubuntu. It's not in /usr/share/apache2. Grr.
11:35:24 <johnnowak>  /etc/apache2 probably
11:35:40 <dmhouse> Oh, /etc. Wow. That was obvious.
11:35:45 * dmhouse wakes his brain up again.
11:39:03 <vixey> @hoogle liftM2 (,)
11:39:06 <lambdabot> Did you mean: LiftM2 (_, _)
11:39:06 <lambdabot> Control.Monad.Writer.Class.listen :: MonadWriter w m => m a -> m (a, w)
11:39:06 <lambdabot> Control.Monad.Writer.Lazy.runWriterT :: WriterT w m a -> m (a, w)
11:41:19 <vixey> how do you cut !/0 a ListT ?
11:43:33 <Baughn> vixey: ..what?
11:45:30 <dolio> @type ListT . runListT (\m -> m >>= \l -> return (case l of [] -> [] ; (x:_) -> [x]))
11:45:31 <lambdabot> Not in scope: data constructor `ListT'
11:45:31 <lambdabot> Not in scope: `runListT'
11:45:47 <Cale> btw, ListT is evil
11:45:57 <dolio> Yeah, don't use ListT.
11:45:59 <dolio> :)
11:46:08 <Cale> If you want an actual monad transformer, use LogicT. It's available on Hackage.
11:46:31 <vixey> I don't know how to do a cut on LogicT
11:46:42 <vixey> well I'll try to figure it out
11:46:50 <dolio> It's already written for logict.
11:46:53 <Cale> once
11:47:13 <vixey> once is weaker I think..
11:47:27 <Cale> hmm
11:47:42 * vixey &
11:49:02 <Cale> Remind me again what you want cut to do?
11:49:10 * Baughn gnashes his teeth at the inconsistent handling of head/tail between OSs, between platforms, and /on the same OS and platform/
11:49:12 <chrisdone> on the happs main page
11:49:12 <chrisdone> sp ghc -isrc src/Main.hs --make --run --http-port=5000
11:49:14 <chrisdone> what's sp?
11:49:34 <Cale> Something called searchpath, iirc.
11:50:05 <chrisdone> "HAppS does not come with a server-side templating system. We prefer the pattern of developing static web pages and using AJAX to populate them with dynamic content."
11:50:13 <chrisdone> do you have to write AJAX web pages?
11:50:21 <Botje> cut locks prolog to the current choice
11:50:25 <Botje> it prohibits backtracking
11:50:48 <dmwit> Baughn: eh?
11:50:58 <Baughn> dmwit: ../bin/tail and head, that is
11:51:02 <dmwit> oh
11:51:05 <dmwit> Yeah. =/
11:51:32 <dmwit> It's hard to get exactly the first 30 lines of a file, the switch to do it varies so wildly.
11:51:55 <Baughn> You should try getting all but the first line sometime
11:52:20 <Cale> That's roughly what once does. It restricts a computation to its first result.
11:53:20 <ddarius> ghc -e 'interact (unlines . drop 1 . lines)'
11:56:08 <dmwit> sed '2,$p'
11:56:30 <dmwit> sed 1d # actually, probably this
11:56:37 <dmwit> (@Baughn)
11:56:52 <Baughn> Oh, right.. sed...
11:57:15 <mauke> perl -pe 'BEGIN{<>}'
11:57:27 <Baughn> Still, this little emlx-to-mbox converter works fine as is. Hopefully I won't have to actually port it anywhere, it's just that my laptop runs a different os from the machine with the mail..
11:59:45 <ziman> (read;cat)
11:59:47 <ziman> :)
12:06:52 <dmwit> ziman: =)
12:18:56 <Botje> you can't read cats!
12:23:45 <ziman> > reverse "stackcats"
12:23:50 <lambdabot>  "stackcats"
12:24:12 <Deewiant> > read "cats"
12:24:13 <Baughn> ziman: Obviously didn't work. Try it again.
12:24:13 <lambdabot>  Exception: Prelude.read: no parse
12:24:14 <dmhouse> > reverse .
12:24:15 <lambdabot>   parse error on input `}'
12:24:23 <Deewiant> lambdabot can't read cats :-/
12:24:31 <dmhouse> > reverse . filter isAlpha $ "Rise to vote, sir"
12:24:32 <lambdabot>  "risetovotesiR"
12:25:06 <Deewiant> > reverse . filter isAlpha $ "Do geese see god?"
12:25:07 <lambdabot>  "dogeeseseegoD"
12:26:02 <shepheb> on (==) (sort . filter isAlpha) "dormitory" "dirty room"
12:26:05 <shepheb> > on (==) (sort . filter isAlpha) "dormitory" "dirty room"
12:26:07 <lambdabot>  True
12:26:26 <shepheb> breaking the pattern, I know, but it amuses me.
12:26:30 <mar77a> > null "dormitory" == null "dirty room"
12:26:31 <lambdabot>  True
12:27:46 <dmhouse> Heh, I do remember a programming contest at my school where task 1a was to write a program anagrams str1 str2. Looked over my shoulder and saw everyone struggling with complex C loops, and I wrote anagrams = equating sort and was done :)
12:28:04 <Deewiant> > reverse . filter isAlpha $ "Was it a car or a cat I saw?"
12:28:05 <lambdabot>  "wasItacaroracatisaW"
12:30:55 <vixey> :t equating
12:30:56 <lambdabot> Not in scope: `equating'
12:31:06 <ddarius> :t on (==)
12:31:06 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
12:31:43 <Saad_> :t on
12:31:44 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:32:05 <shepheb> @src on
12:32:05 <vixey> once(P) :- call(P), !.
12:32:06 <lambdabot> (*) `on` f = \x y -> f x * f y
12:32:35 <vixey> you can't really do much with once
12:32:42 <shepheb> whoa, you can pattern match an operator like that?
12:32:47 <ddarius> once(true) == call(true), ! == !
12:33:08 <vixey> once(true) = true
12:33:36 <ddarius> Indeed since ! is ugly
12:34:08 <Cale> vixey: Sorry, what's wrong with once?
12:34:17 <Twey> @src on
12:34:17 <lambdabot> (*) `on` f = \x y -> f x * f y
12:34:18 <vixey> nothing is wrong with it
12:34:24 <dolio> It isn't a non-local effect? :)
12:34:29 <Twey> What is this `on`?
12:34:33 * Twey is confused.
12:34:41 <vixey> Twey: a combinator ..
12:34:45 <ddarius> Twey: That's the source right there.  It's pretty self-explanatory.
12:35:05 <vixey> > ((==)`on`head) "tripe" "trout"
12:35:06 <Twey> Hm hm
12:35:06 <lambdabot>  True
12:35:10 <Twey> I see
12:35:11 <Deewiant> > ((==) `on` fst) (1,9) (1,3)
12:35:12 <lambdabot>  True
12:35:15 <oldsalt> how can i do something like "SELECT * FROM foo WHERE bar IN (1,2)" with Database.HDBC?
12:35:50 <vixey> > runListT (do x <- lift $ [1,2,3] ; y <- lift $ "abc" ; return (x,y))
12:35:51 <Cale> > groupBy ((==) `on` snd) (zip (words "hello there this is a test") [1,1,2,2,2,3])
12:35:51 <lambdabot>   Not in scope: `runListT'
12:35:52 <lambdabot>  [[("hello",1),("there",1)],[("this",2),("is",2),("a",2)],[("test",3)]]
12:36:05 <vixey> *Main> runListT (do x <- lift $ [1,2,3] ; y <- lift $ "abc" ; return (x,y))
12:36:05 <vixey> [[(1,'a')],[(1,'b')],[(1,'c')],[(2,'a')],[(2,'b')],[(2,'c')],[(3,'a')],[(3,'b')],[(3,'c')]]
12:36:30 <ddarius> > ((+) `on` join (*)) 3 4
12:36:30 <lambdabot>  25
12:36:44 <Twey> @src join
12:36:44 <lambdabot> join x =  x >>= id
12:36:53 <Cale> heh
12:37:01 <Twey> Err
12:37:03 <Cale> join in this context is  join f x = f x x
12:37:13 <Twey> Ah, OK
12:37:21 <Deewiant> join is one of those functions whose definition doesn't really tell you anything :-P
12:37:29 <vixey> :t join
12:37:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:37:31 <Twey> Yeah :-\
12:37:31 <Cale> Well, it tells you something...
12:37:38 <Cale> The type is more informative though
12:37:38 <FordCortina> in "foo :: p1 i1 -> p2 i2 -> p3 ir" p1,p2 and pr are type constructors that take one argument?
12:37:47 <vixey> FordCortina: yes
12:37:50 <Twey> Only if you understand it, Cale :)
12:38:04 <Cale> Here's a potentially easier to follow one...
12:38:14 <Cale> join x = do { y <- x; v <- y; return v }
12:38:27 <vixey> that doesn't make any sense :S
12:38:30 <Cale> So, for example...
12:38:36 <Deewiant> @undo  do { y <- x; v <- y; return v }
12:38:36 <lambdabot> x >>= \ y -> y >>= \ v -> return v
12:38:42 <vixey> hmmmmm
12:38:54 <vixey> :t (>>= (>>= return))
12:38:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:39:06 <Deewiant> :t (>>= return)
12:39:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
12:39:08 <vixey> :t ((>>= return) =<<)
12:39:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:39:11 <FordCortina> hmm
12:39:16 <Deewiant> >>= return is id
12:39:44 <Cale> Okay... so in order to understand what's going on in this specific case, you have to understand the ((->) e) monad
12:40:05 <ddarius> @src (->) (>>=)
12:40:05 <lambdabot> f >>= k = \ r -> k (f r) r
12:40:11 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
12:40:13 <lambdabot>  ("hello","olleh","HELLO")
12:40:21 <vixey> bleh understanding this stuff is too hard, just look at the types
12:40:26 <Deewiant> :-)
12:40:31 <Cale> The source of bind is a pretty bad way to understand this monad :)
12:40:45 <ddarius> It makes it trivial to understand what join does.
12:40:57 <Cale> That's true, you can just calculate it.
12:41:02 <ddarius> Just substitute id for k.
12:41:18 <Twey> I see...
12:41:19 <ddarius> Interestingly, (id >>=) is the same thing.
12:41:32 <Deewiant> ?ty (id >>=)
12:41:33 <lambdabot> forall a b. (a -> a -> b) -> a -> b
12:41:33 <rwbarton> How come "ghc -e 'interact $ unlines . tail . lines' imports.hs" messes with the terminal state, but not if I leave off imports.hs?  (imports.hs is empty)
12:41:39 <Deewiant> ?ty (>>= id)
12:41:39 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
12:41:42 <Twey> Why does that do block get coerced to ((->) e)?
12:41:49 <Deewiant> ?ty (>>= id) :: (a -> a -> b) -> a -> b
12:41:50 <lambdabot> forall a b. (a -> a -> b) -> a -> b
12:41:55 <Cale> Twey: which one?
12:41:59 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
12:42:00 <lambdabot>  ("hello","olleh","HELLO")
12:42:01 <Cale> That one?
12:42:11 <ddarius> There are no coercions in Haskell
12:42:16 <Twey> Aye
12:42:19 <Twey> Er
12:42:21 <Cale> It's because it's being applied to a value, as a function
12:42:23 <Twey> Not coerced
12:42:38 <Cale> Yeah, it simply must have that type
12:42:38 * Twey just woke up
12:42:47 <Twey> Mmkay
12:43:06 <Twey> Because no other monads are functions?
12:43:12 <Cale> So, just looking at the types, (->) String must be the monad involved here.
12:43:26 <Cale> Because the do block itself is being applied to a string as a function
12:43:41 <FordCortina> http://hpaste.org/9176
12:43:51 <dons_> this is nice, http://www.reddit.com/comments/6tl5n/solving_nonograms_picture_logic_puzzles_with_your/
12:43:52 <lambdabot> Title: Solving nonograms (picture logic puzzles) with your computer : reddit.com, http://tinyurl.com/6nk9oo
12:43:53 <Cale> (so it must be a function accepting a string as a parameter)
12:44:02 <FordCortina> is there a way to fix that class defintion?
12:44:11 <dmhouse> Cale: or the fact that you do "z <- map toUpper"
12:44:17 <Cale> right, that too
12:44:17 <vixey> FordCortina: you must indent seq
12:44:29 <vixey> it's not part of the class definition currently
12:44:30 <Cale> The actions inside the block also must be in the same monad.
12:44:41 <Cale> and map toUpper :: String -> String
12:44:41 <dmhouse> id tells you it must be (->) a, reverse that it must be (->) [a], and map toUpper that it must be (->) String.
12:44:43 <FordCortina> vixey: seq is not an instance method...yet
12:44:53 <FordCortina> vixey: class method i mean
12:44:57 <vixey> types default to kind *
12:44:58 <dmhouse> (So the first two are redundant insofar as type inference is concerned.)
12:45:10 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; w <- length; return (x,y,z,w)) "hello"
12:45:11 <lambdabot>  ("hello","olleh","HELLO",5)
12:45:13 <vixey> type varaibles
12:45:24 <dolio> > (,,,) <$> id <*> reverse <*> map toUpper <*> length $ "hello"
12:45:25 <lambdabot>  ("hello","olleh","HELLO",5)
12:45:25 <Cale> Just to extend the example a bit :)
12:45:34 <mar77a> :t <*>
12:45:35 <lambdabot> parse error on input `<*>'
12:45:38 <vixey> :t sequence [id,reverse,map toUpper, length]
12:45:39 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Int'
12:45:39 <lambdabot>       Expected type: [Char] -> [Char]
12:45:39 <lambdabot>       Inferred type: [Char] -> Int
12:45:41 <dmhouse> :t (<*>)
12:45:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:45:43 <dafra> tuple is a monad ?
12:46:03 <vixey> dafre ((,)e) is
12:46:06 <dmhouse> dafra: actually yes (Writer), but that's not what dolio was using.
12:46:06 <vixey> @src Reader
12:46:07 <lambdabot> Source not found. Take a stress pill and think things over.
12:46:07 <dafra> :info (,)
12:46:11 <vixey> opos
12:46:18 <dmhouse> ?type runWriter
12:46:18 <Twey> Cale: Yeeees... but doesn't that mean that there can be no other monad that acts as a function and accepts an argument?
12:46:19 <lambdabot> forall w a. Writer w a -> (a, w)
12:46:22 <dafra> :i (,)
12:46:25 * gwern finally returns online. huh. who'd've thought the problem was the kernel upgrade? strange, too - no error messages or anything
12:46:45 <Cale> Twey: Functions from any fixed type form a monad, in (as far as I know) exactly one way.
12:47:02 <dmhouse> Twey: well (->) String is enough to specify a monad, since monads must be universally quantified over the type they hold.
12:47:17 <dmhouse> And "(->) String a" only has one type variable.
12:47:26 <FordCortina> vixie: is there a way to change the kind of p back to * -> *?
12:47:37 <Cale> A monad is a type constructor, remember...
12:47:54 * Cale is unsure what Twey already knows about monads :)
12:47:56 <dmhouse> In principle you could declare different monads for (->) String, (->) Bool and so on, but in actual fact we have a generic definition of (->) a, so you can't do that without overlapping instances.
12:48:01 <chrisdone> ghc-6.8.3: panic! (the 'impossible' happened) http://hpaste.org/9177
12:48:04 <Twey> So I couldn't, for example, make a (->) String monad that did basically the same thing but reversed the case of all the strings inside it?
12:48:06 <chrisdone> =o
12:48:08 <Twey> Cale: You and me both
12:48:10 <rwbarton> FordCortina: I imagine it would infer it, if you had any class methods
12:48:11 <Cale> ah
12:48:27 <dmhouse> Twey: sure, as long as you don't import the instance of Monad ((->) a).
12:48:28 <dafra> > (do return (id, reverse)) "hello"
12:48:29 <lambdabot>  Add a type signature
12:48:41 <Cale> Would it be a monad though?
12:48:41 <FordCortina> rwbarton: hehe I'm always starting from the wrong end i think....
12:48:42 <FordCortina> :(
12:48:50 <Twey> Cale: I'm at a stage where I kind-of-get them, but can't really apply them to anything
12:48:58 <dafra> > (do return (id, reverse)) "hello" :: (String, String)
12:48:59 <lambdabot>  Couldn't match expected type `String'
12:49:09 <Deewiant> > (id >>= \i -> reverse >>= -> \r -> (i,r)) "hello"
12:49:10 <lambdabot>  Parse error at "->" (column 27)
12:49:10 <rwbarton> FordCortina: There probably is a way to declare it too, have you tried replacing p by (p :: * -> *) in the class declaration?  (just a guess)
12:49:12 <Cale> Well, you couldn't write the instance if the general ((->) e) one was in scope.
12:49:14 <dafra> > (do return (id, reverse)) "hello" :: ([Char],[Char])
12:49:15 <Deewiant> > (id >>= \i -> reverse >>= \r -> (i,r)) "hello"
12:49:15 <lambdabot>  Couldn't match expected type `[Char]'
12:49:16 <lambdabot>  Couldn't match expected type `[a] -> b'
12:49:19 <mauke> instance Monad ((->) String) isn't valid H98
12:49:19 <Deewiant> darn
12:49:22 <chrisdone> so yeah, I guess I should report this? http://hpaste.org/9177#a2
12:49:33 <dmhouse> mauke: yeah, newtypes ftw.
12:49:52 <FordCortina> rwbarton: I added a foo :: p i to the class declaration and that worked. that should give me enough of a sandbox to play with :)
12:49:53 <dafra> > (do x <- id, y <- reverse; return (x,y)) "hello"
12:49:54 <lambdabot>  Parse error at "," (column 12)
12:50:02 <Deewiant> > (id >>= \i -> reverse >>= \r -> return (i,r)) "hello"
12:50:03 <Cale> > (do x <- id; y <- reverse; return (x,y)) "hello"
12:50:03 <lambdabot>  ("hello","olleh")
12:50:04 <dafra> > (do x <- id; y <- reverse; return (x,y)) "hello"
12:50:04 <lambdabot>  ("hello","olleh")
12:50:05 <lambdabot>  ("hello","olleh")
12:50:19 <dmhouse> > (id &&& reverse) "hello"
12:50:20 <lambdabot>  ("hello","olleh")
12:50:28 <gwern> Cale, Cale! I got quickcheck working with mueval!
12:50:32 <Twey> Hmmm
12:50:35 <dafra> :type (do x <- id; y <- reverse; return (x,y)) "hello"
12:50:47 <dmhouse> Twey: why don't you try writing such a monad?
12:50:49 <Cale> gwern: neat!
12:50:50 <FordCortina> rwbarton: the kind declaration didnt seem to work :(
12:51:07 <rwbarton> ah well
12:51:13 <dafra> :t ((do x <- id; y <- reverse; return (x,y)) "hello")
12:51:13 <lambdabot> ([Char], [Char])
12:51:16 <Deewiant> > (,) <$> id <*> reverse $ "hello"
12:51:17 <lambdabot>  ("hello","olleh")
12:51:20 <dmhouse> Twey: if you get stuck, try looking at Control.Monad.Reader or wherever it is that the Monad ((->) e) instance declaration is. Or ask here. :)
12:51:25 <Twey> dmhouse: Because it's early morning and my head hurts.  Why am I even trying to do intellectual things?  *sits up and sways groggily*
12:51:31 <dmhouse> Heh.
12:51:42 <Cale> Twey: However, I'm fairly sure that if it reversed the case of the strings, you'd end up failing one of the monad laws, but I'm not 100% sure.
12:51:49 <dolio> > let ana g = In . fmap (ana g) . g in ana (fst &&& snd &&& uncurry (+))
12:51:50 <lambdabot>        add an instance declaration for (Typeable (Mu ((,) b)))
12:51:57 <dolio> > let ana g = In . fmap (ana g) . g in ana (fst &&& snd &&& uncurry (+)) (1,1)
12:51:57 <lambdabot>   add an instance declaration for (Show (Mu ((,) b)))
12:51:59 <Twey> Cale: Hm, I see.
12:52:02 <dolio> @yarr
12:52:02 <lambdabot> Shiver me timbers!
12:52:14 <gwern> Cale: I discovered my problems were due to the shell screwing up my input, and also because -fglasgow-exts doesn't enable the extended defaults, so Hint wasn't doing enough
12:52:27 <vixey> let p >>!= q = q (head . head . runListT $ p)
12:52:34 <vixey> *Main> runListT ((lift $ [1,2,3]) >>= \x -> lift $ "abc" >>= \y -> return (x,y))
12:52:34 <vixey> [[(1,'a')],[(1,'b')],[(1,'c')],[(2,'a')],[(2,'b')],[(2,'c')],[(3,'a')],[(3,'b')],[(3,'c')]]
12:52:34 <vixey> *Main> runListT ((lift $ [1,2,3]) >>!= \x -> lift $ "abc" >>= \y -> return (x,y))
12:52:34 <vixey> [[(1,'a')],[(1,'b')],[(1,'c')]]
12:52:48 <Deewiant> > ap (fmap (,) id) reverse "hello"
12:52:49 <lambdabot>  ("hello","olleh")
12:52:59 <Cale> vixey: What are you using ListT for?
12:53:25 <vixey> Cale, A Prolog interpreter
12:53:25 <vixey> a
12:53:26 <Cale> vixey: In my experience, most of the time I wanted a monad with nondeterminism, the nondet monad was at the bottom of the stack.
12:53:32 <Cale> Ah, okay
12:53:47 <Cale> So you probably really will want effects that don't backtrack.
12:54:01 <dmhouse> Wow, (global-set-key (kbd "RET") 'newline-and-indent) is really annoying in haskell-mode.
12:54:19 <vixey> hmmm
12:54:20 <Cale> vixey: However, you should be careful, ListT doesn't produce a valid monad most of the time.
12:54:34 <vixey> I just need a clever way to condition on >>= or >>!=
12:54:45 <Cale> (it fails the associative law unless the order of execution doesn't matter in the monad you're transforming)
12:55:24 <Cale> This means that the way that you break your program into definitions/do-blocks can matter.
12:56:19 * vixey actually has no idea how to do this :p
12:58:31 <vixey> it seems like I have got >>= and >>!= as low level primitives
12:58:34 <ddarius> To do the cut or to make the prolog interpreter?
12:58:57 <vixey> just the rule for cut
12:59:18 <vixey> I used foldM earlier
12:59:39 <vixey> if there was a cut within the foldM... I think it wont have any effect
13:00:08 <vixey> I hope I don't have to reimplement ListT except with data Stream a = Nil Bool | Cons Bool a (Stream a)
13:00:35 <Cale> Have you read the LogicT paper?
13:00:43 <ddarius> vixey: Personally, I would use a Tree monad (if not something better)
13:00:45 <vixey> yes
13:00:59 <Cale> What's wrong with using once to implement cut?
13:01:00 <dolio> Isn't cut, like, the most controversial part of Prolog?
13:01:05 <vixey> Cale, it's impossible
13:01:08 <Cale> how so?
13:01:15 <vixey> in Prolog,
13:01:19 <vixey> once(P) :- call(P), !.
13:01:32 <Cale> so?
13:01:41 <dolio> Cale: Cut is non-local, I think.
13:01:49 <vixey> the ! there cannot have any effect past the scope of once/1
13:02:08 <vixey> so there's no way to write ! using once
13:02:28 <Cale> Why not?
13:02:50 <Cale> Can't you just take the things before the ! and wrap a once around them?
13:03:13 <vixey> yes in same cases but not all
13:03:19 <Cale> example?
13:03:28 <vixey> not(P) :- call(P), !, fail.
13:03:33 <vixey> not(P).
13:03:42 <vixey> there's no way to rewrite that using once
13:04:12 <Cale> Oh, but you can write it with ifte
13:04:14 <xif> lack of side effects really helps with refactoring.
13:04:41 <xif> I'm refactoring a bunch of functions now in another language, and I don't know which names are safe to change.
13:05:15 <Cale> I have a strong feeling that everything is going to be expressible in some fashion using msplit.
13:05:25 <dolio> not m = ifte m (const mzero) (return ())
13:05:30 <dolio> Or something like that.
13:05:47 <Cale> right
13:05:48 <dolio> Maybe once m.
13:05:55 <ddarius> @google "A Semi-functional implementation of a higher-order logic programming language"
13:05:57 <lambdabot> http://citeseer.ist.psu.edu/83055.html
13:05:57 <lambdabot> Title: A Semi-Functional Implementation of a Higher-Order Logic Programming Language -  ...
13:05:57 <dolio> To avoid redundancy.
13:06:00 <Cale> yeah
13:06:12 <vixey> ifte should only do m once
13:06:34 <vixey> i.e. what you wrote was fine (I think)
13:06:42 <Cale> vixey: All the results of the 'if' part will be fed to the 'then' part
13:06:51 <Cale> (if there are any results)
13:07:03 <dolio> Well, yeah, but what I wrote you'll get like 'mzero `mplus` mzero `mplus` ...' for each time m succeeds, I think.
13:07:11 <dolio> Which is a slow version of mzero.
13:07:21 <Cale> yeah
13:08:32 <dolio> It's been a while since I worked on logict, so I'm a bit rusty.
13:09:10 * vixey is trying to figure out if cut can be written in terms of msplit
13:09:27 <dolio> Is there a not in there? I should probably add one if there isn't.
13:09:53 <dolio> Looks like no.
13:10:03 <vixey> how do you use logic t ?
13:10:13 <vixey> I mean ... you have to implement a whole language to use it
13:10:21 <Cale> vixey: what?
13:10:33 <vixey> have you written any?
13:10:36 <dolio> It's just like ListT, only it's a legitimate monad transformer, and has fancier operations.
13:11:05 <Cale> vixey: Implement a whole language? No, you can just use it directly.
13:11:19 <dolio> And it should be faster, too, I think.
13:11:30 <dolio> Since it's all continuations inside, instead of lists.
13:11:43 <vixey> I've only ever seen it used where a whole langauage was embedded in haskell
13:11:51 <dolio> Not that I've benchmarked it or anything.
13:12:04 <vixey> I mean I've never seen any other uses (except the examples in the paper)
13:12:05 <Cale> vixey: I've used Logic reasonably often on its own.
13:12:09 <vixey> sorry in the source cod
13:12:10 <Cale> It's rather like the list monad.
13:12:19 <Cale> hmm
13:12:23 <Cale> :t runLogic
13:12:23 <lambdabot> Not in scope: `runLogic'
13:12:27 <dolio> Cale wrote a sudoku solver in his own personal implementation of it.
13:12:28 <Cale> I should include it :)
13:12:40 <vixey> it would be cool to see that
13:12:49 <Cale> yeah, that was before LogicT was available :)
13:13:18 <Cale> http://www.haskell.org/haskellwiki/Sudoku#Monadic_non-deterministic_solver
13:13:19 <lambdabot> Title: Sudoku - HaskellWiki, http://tinyurl.com/y4lh72
13:15:31 <mar77a> > foldr (*) [1..6]
13:15:32 <lambdabot>   add an instance declaration for (Num [t])
13:15:40 <mar77a> > foldr (*) 1 [1..6]
13:15:41 <lambdabot>  720
13:15:48 <Cale> :t runLogic
13:15:48 <lambdabot> forall a r. Logic a -> (a -> r -> r) -> r -> r
13:15:51 <Cale> :)
13:15:59 <vixey> at the moment I have
13:16:06 <dmhouse> Cale: so Logic is Nondet? How exactly does it differ from the list monad?
13:16:08 <vixey> type Prolog m a = ListT (StateT (Identifier :--> Identifier,[Identifier]) m) a
13:16:17 <Cale> dmhouse: It's not quite the same
13:16:26 <vixey> but.. I think I must write my own StreamT for it really
13:16:26 <vixey> which sucks..
13:16:51 <dmhouse> Hmm, looks like a combination of Cont and State.
13:17:08 <dmhouse> (From runLogic's type, that is.)
13:17:23 <Cale> newtype Logic a = Logic { unLogic :: LogicT Identity a }
13:17:33 <Cale> newtype LogicT m a =
13:17:34 <Cale>     LogicT { unLogicT :: forall ans. SK (m ans) a -> FK (m ans) -> m ans }
13:17:38 <Cale> type SK r a = a -> r -> r
13:17:38 <Cale> type FK a = a
13:18:04 <Cale> hmm...
13:18:33 <Cale> actually, yeah, that is the same :)
13:18:46 <Cale> (As NondetT)
13:18:58 <vixey> :t option
13:18:59 <lambdabot> Not in scope: `option'
13:19:07 <Cale> option = msum . map return
13:19:21 <Cale> Yet another thing which ought to be in the libraries but isn't.
13:19:27 <vixey> > runLogic (do x <- msum . map return $ "wobble" ; return x)
13:19:28 <lambdabot>  Add a type signature
13:19:50 <Cale> > runLogic (do x <- msum . map return $ "wobble" ; return x) (:) []
13:19:51 <lambdabot>  "wobble"
13:20:13 <vixey> oh
13:21:21 <vixey> yeah
13:21:28 <vixey> I can't implement cut using msplit
13:21:37 <vixey> well I can implement >>!= with it
13:21:46 <jleedev> > join . sequence . words $ "this is my list of words"
13:21:47 <vixey> so I just have to the same problem as before
13:21:48 <lambdabot>  "timlowtimlootimlortimlodtimlostimlfwtimlfotimlfrtimlfdtimlfstimiowtimiootim...
13:23:11 <vixey> ddarius, is it naive of me to think all higher order unification gets you is search and replace on syntax trees?
13:23:53 <ddarius> vixey: I'm not quite sure what you mean, but I'd say yes.
13:24:30 <vixey> It's just I've never seen any other uses .. and I couldn't come up with any
13:26:30 <ddarius> While certainly doable with only a slight extension to first order unification, simply writing something like map technically uses higher order unification.
13:26:48 <dmhouse> Cale: btw, the uppercasing (String ->) monad breaks return x >>= f = f x.
13:26:48 <ddarius> Also, higher order unification is useful when you have higher order predicates.
13:26:49 <Heffalump> ddarius: uses higher order unification in what sense?
13:27:40 <ddarius> Heffalump: In so far as you are binding a lambda term to a variable, though as I said, that doesn't really use any actual higher order unification.
13:28:10 <erikc> i use higher order unification for stuff like assertz(rule(foo(X), bar(X)).
13:28:19 <Heffalump> ddarius: right, and since you don't need HO unification to implement (say) Haskell, it seems rather irrelevant
13:28:31 <ski> erikc : where ?
13:29:18 <Heffalump> higher-order unification is a bit more than just syntactic search-and-replace, because it can undo arbitrary levels of beta-reduction
13:29:53 <ddarius> Heffalump: Yes, but in a logic language it starts to lead that way.  You have the question of what does map(F,In,Out) mean when F is unbound.
13:30:07 <Heffalump> admittedly beta-reduction is just search-and-replace itself, but it's rather more complicated than that in terms of its expressive power
13:30:11 <ski> l-lambda unification is nice for matching under binders
13:30:21 <Heffalump> ddarius: sure. logic or functional logic languages will really use it
13:31:10 <Abraxas123> how do i convert a number into a list of digits?
13:31:33 <ski> > show 42
13:31:34 <lambdabot>  "42"
13:31:40 <ski> > show (-18)
13:31:41 <lambdabot>  "-18"
13:31:56 <vixey> do you mean rarely?
13:31:56 <vixey> Abraxas123: show
13:32:37 <roconnor> > show (0/0)
13:32:38 <lambdabot>  "NaN"
13:32:54 <Abraxas123> heh, hugs crashed
13:33:05 <Abraxas123> it was a really long number...
13:33:05 <ddarius> Heffalump: The context was vixey implementing a Prolog.
13:33:45 <Heffalump> ah, sorry, didn't read far enough back
13:34:35 <Heffalump> vixey asked a question earlier about partially applied type synonyms, which if they were allowed would require the type-checker to do HO unification IIRC, so I assumed this was a follow-on from that
13:34:42 <vixey> oh but I was reading about lambda prolog the other day and the examples of higher order unification
13:36:06 <ddarius> What is a compelling example of HOU as opposed to say higher order matching or higher order pattern unification?
13:38:03 <Abraxas123> how do i turn the char back into an integer?
13:38:13 <ddarius> @hoogle Char -> Int
13:38:13 <lambdabot> Data.Char.digitToInt :: Char -> Int
13:38:13 <lambdabot> Data.Char.ord :: Char -> Int
13:38:13 <lambdabot> Data.ByteString.Char8.count :: Char -> ByteString -> Int
13:38:40 <ddarius> > digitToInt 'a'
13:38:41 <lambdabot>  10
13:38:45 <ddarius> > digitToInt '?'
13:38:46 <lambdabot>  Exception: Char.digitToInt: not a digit '?'
13:38:58 <Heffalump> ddarius: I would expect that type-checking full dependent types would require it
13:39:00 <erikc> ski: prototyping a game engine that runs its rules + database out of prolog
13:39:34 <Abraxas123> mh, digitToInt does not exist in my version of hugs?
13:39:58 <ddarius> @src digitToInt
13:39:59 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:40:00 <dmhouse> Abraxas123: why are you using Hugs?
13:40:20 <Cale> Abraxas123: It's in the module Numeric
13:40:25 <Abraxas123> the recommended interpreter of the lecture
13:40:28 <Cale> Abraxas123: So make sure that module is loaded
13:40:46 <ddarius> @index digitToInt
13:40:47 <lambdabot> Data.Char
13:40:47 <Cale> If you're at a Hugs prompt, you can  :also Numeric
13:40:57 <Cale> mm... or Data.Char :)
13:41:07 <Abraxas123> alright, works now, thx =)
13:42:02 <Abraxas123> is there a difference between :load and :also ?
13:42:03 <ski> erikc : i wondered where more specifically you used higher-order unification
13:42:22 <ski> Abraxas123 : yes, `:also' adds to the modules loaded
13:42:31 <erikc> ah, for chaining context between rules as they fire
13:42:38 <Abraxas123> yes, i see, now the prompt says Numeric
13:42:38 <roconnor> > isDigit '?'
13:42:39 <lambdabot>  False
13:42:52 <ddarius> > isDigit 'a'
13:42:53 <lambdabot>  False
13:43:04 <roconnor> > isHexDigit '?'
13:43:05 <lambdabot>  False
13:43:15 <ski> erikc : in your assertz/1 call, would `X' be higher-order ?
13:43:45 <Abraxas123> strange, can't keep the old module it seems
13:43:53 <erikc> i thought it was, maybe im mistaken
13:44:11 <erikc> e.g. if i then run: rule(A, B), B
13:44:22 <erikc> rule(A, B), A, B. rather
13:44:39 <ddarius> erikc: Higher order unification is unifying lambda terms w.r.t. to beta reduction
13:45:03 <ddarius> There is also higher order logic which is adding to the set of rules (in a particular way) during evaluation.
13:45:19 <ddarius> er scratch the latter
13:46:12 <ddarius> There is higher order predicates which let you pass predicates around like higher order functions.
13:46:41 <ski> Abraxas123 : hugs will load additional modules with `:also', but for some reason, it seems to only have one in focus
13:46:49 <erikc> doesnt my example use higher order unification
13:47:05 <ddarius> erikc: Do you have any lambda terms anywhere?
13:47:41 <erikc> i guess i dont understand where the lambdas are in prolog
13:47:45 <ski> (ddarius : implication goals ?)
13:47:50 <ddarius> ski: Yes.
13:47:55 <Abraxas123> i imported it in the module, but now it doesn't work any more
13:48:04 <Abraxas123> are you telling me hugs is crap?
13:48:13 <vixey> erikc: there aren't any
13:48:22 <ski> Abraxas123 : imported what ?
13:48:25 <ddarius> Hugs is crap, though not so much for that reason.
13:48:39 <Abraxas123> ski: Numeric
13:49:44 <vixey> erikc: We don't need lambda since there's copy_term and suck
13:49:51 <vixey> such*
13:50:26 <ski> Abraxas123 : if you import `A' into module `B', and load `B', then hugs will only make the exported bindings of `B' in scope .. if you want to have the bindings of `A' in scope, too .. you have to reexport `A' from `B' (in hugs)
13:51:10 <ski> vixey : well, i would say we can simulate lambda, to some extent, with copy_term/2
13:52:59 <ddarius> erikc: Higher order unification would be like saying F a = a and getting F = \x.x and F = \x.a
13:54:56 <ski> (s/and/or/)
13:54:58 <drguildo> http://hpaste.org/9179
13:55:01 <drguildo> any thoughts?
13:55:41 <Abraxas123> ski: how does that work :D
13:55:57 <ski> er .. which ?
13:56:04 <Abraxas123> reimporting it
13:56:13 <ski> re*exporting*
13:56:22 <Abraxas123> uh right
13:56:31 <ski> module B (module A , ...) where
13:56:38 <ski> import A
13:56:39 <ski> ...
13:57:10 <ski> (so, maybe `A' would be `Numeric' in your case)
13:57:59 <Abraxas123> does not seem to work
13:58:24 <adiM> Are there any libraries for solving linear programs in Haskell?
13:59:57 <ski> Abraxas123 : elaborate ?
14:02:29 <Abraxas123> ski: still can't use digitToInt
14:02:44 <Abraxas123> i wrote it like you said
14:02:45 <Deewiant> ?index digitToInt
14:02:45 <lambdabot> Data.Char
14:03:47 <Abraxas123> it works if i :also Numeric
14:03:54 <Abraxas123> it is in Numeric, i mean
14:04:04 <ski> i thought you wanted to use some `Numeric' operation
14:04:10 <ski> (though maybe you want that, too)
14:04:27 <ski> as Deewiant showed, `digitToInt' is in `Data.Char', though
14:04:27 <Abraxas123> but i don't yet know how to import/load modules and can't keep the original one
14:04:46 <Abraxas123> but it works with Numeric, too
14:06:00 <Abraxas123> but not as import in the original module, Data.Char works that way :)
14:06:07 <Abraxas123> funny
14:06:31 <MyCatVerbs> Abraxas123: importing modules is easy.
14:06:57 <MyCatVerbs> Abraxas123: in source code, put "import Data.Char" in between the "module Something where" line and the rest of the code.
14:07:07 <Abraxas123> yes, it works now, but hold on
14:07:25 <MyCatVerbs> Abraxas123: to bring a module into ghci, use :m +Data.Char
14:07:28 <Abraxas123> i load the original, then i :also Numeric, and digitToInt works
14:07:41 <noecksit> hello, is there a way to write "func m = map (g m) ls" in point-free notation?
14:07:42 <Abraxas123> even though you say it's in Data.Char
14:07:50 <Deewiant> ?pl func m = map (g m) ls
14:07:50 <lambdabot> func = flip map ls . g
14:07:57 <Deewiant> noecksit: ^
14:07:57 <MyCatVerbs> Abraxas123: sometimes stuff is exposed in more than one place.
14:08:19 <Abraxas123> it must be imported in Numeric, but if import Numeric in the original module for some reason, it no longer works
14:08:48 <MyCatVerbs> hpaste the code and the error message, please? I'm sure it can't be anything too difficult to work out.
14:08:56 <MyCatVerbs> www.hpaste.org, by the way.
14:09:16 <noecksit> Deewiant : oh thanx, flip was what i was looking for
14:09:24 <noecksit> @src flip
14:09:24 <lambdabot> flip f x y = f y x
14:10:09 <Abraxas123> import seems to be complicated from what little i read on the haskell site :D
14:10:19 <ski> noecksit : alternatively as  func = (`map` ls) . g
14:10:53 <MyCatVerbs> Abraxas123: it isn't. Please hpaste the code and the error message for me?
14:12:01 <Abraxas123> it works already, just not the way i've done before
14:12:19 <Abraxas123> Numeric worked with :also, but not as an import
14:12:42 <Abraxas123> sth about scope like ski said, but i don't know enough about that, yet
14:14:26 <ahunter2> So, Haskell has a number of array types with different properties, but similar interfaces--hence we have a few generic array interfaces, to make life easier.
14:14:28 <ahunter2> Haskell *also* has a number of reference types (STRef, TVar, IORef...) with similar interfaces (all of these have newWhatever, readWhatever, writeWhatever...) I don't suppose anyone's written  a similar shared interface?  It'd be cool if you could write a library parameterized across the updatable reference type, so users could pick what they needed...
14:14:40 <dons> nice idea, ahunter2
14:14:41 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:14:44 <dons> MVar too.
14:14:53 <dons> ahunter2: i think we *could* have such a type class..
14:14:56 <ahunter2> dons: Knew I forgot something :)
14:15:12 <dons> some are thread safe, some are coposable, some don't have atomic modify
14:15:20 <dons> but they all have some notion of init, read, write
14:15:22 <painy> how do i use the lambdabot as a messenger
14:15:29 <Deewiant> ?help tell
14:15:30 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
14:15:43 <vixey> why would you want to though?
14:15:46 <ahunter2> dons: yeah...I think it'd need type families or something similar (I could be totally wrong...) since they're all in different monads
14:15:55 <vixey> @later tell painy like this
14:15:55 <vixey> ugh
14:15:55 <lambdabot> Unknown command, try @list
14:16:03 <vixey> @tell painy like this
14:16:04 <lambdabot> Consider it noted.
14:16:13 <dons> ahunter2: hmm. just start with the things in IO
14:16:16 <ski> class Monad m => MonadRef ref m where newRef :: a -> m (ref a); readRef :: ref a -> m a; writeRef :: ref a -> a -> m ()
14:16:21 <dons> adding STM or ST based ones can be done later.
14:16:45 <Saizan_> | ref -> m
14:16:49 <dons> are there useful derived operations that make sense now?
14:16:54 <dons> do we get safe modify for free?
14:17:07 <ahunter2> ski: I'm something of a novice, but doesn't that lead to problems without some way to determine dependency between m and ref?
14:17:07 <ski> Saizan_ : i'm not sure about that
14:17:35 <geezusfreeek> i know it's been brought up before, and i think i even participated in a discussion about this at one time, but i forgot everything that was said. what practical difference is there between Alternative and MonadPlus?
14:17:36 <ahunter2> dons: well, the question boils down to what we want the library to guarantee in terms of properties...
14:17:37 <ski> ahunter2 : it could, yes .. but i don't think we've agreed on what the Right Thing is
14:17:38 <vixey> it doesn't make sense to abstract this to me
14:17:54 <ahunter2> ski: just saying, I thouight we did need either a fundep or an associated type, that's all
14:17:54 <vixey> what is the point ?
14:18:04 <vixey> @src Alternative
14:18:04 <lambdabot> class Applicative f => Alternative f where
14:18:04 <lambdabot> 	empty :: f a
14:18:04 <lambdabot> 	(<|>) :: f a -> f a -> f a
14:18:08 <Saizan_> ski: are there instances that would break that?
14:18:27 <ski> ahunter2 : well, each member is mentioning both `ref' and `m', there ..
14:18:42 <ahunter2> ski: good point...like I said, not an expert
14:19:14 <ski> Saizan_ : it's is not clear to me that you'd not sometimes want to use a reference type in several (probably connected) monads
14:19:17 <vixey> geezusfreeek: I think MonadPlus doesn't care about Applicative
14:19:23 <geezusfreeek> related question: is it good or bad practice for the Alternative and MonadPlus instances for some type to be different?
14:19:25 <vixey> maybe they have different laws too
14:19:34 <vixey> @src MonadPlus
14:19:35 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:19:53 <Saizan_> ski: ah, right, autolifting instances
14:20:00 <ski> (also, i'm not sure `writeRef' should be in the base class ..)
14:20:08 <geezusfreeek> @src Control.Monad.MonadPlus
14:20:08 <lambdabot> Source not found. :(
14:20:13 <ahunter2> ski: what ref is interesting that doesn't allow writing?
14:20:24 <vixey> :(
14:20:45 <erikc> is there a library that implements the database relational algebra (over haskell data structures, not sql bindings)
14:20:48 <geezusfreeek> well, the main difference of course is that one is for Applicative and one is for Monad
14:20:49 <ski> ahunter2 : consider a reference type that is only used for "pointer equality", to be used e.g. for graph algorithms
14:21:21 <geezusfreeek> i was just wondering about practical differences for monads, since monads are also applicative functors
14:21:53 <ahunter2> ski: I'm not quite following
14:23:42 <ski> ahunter2 : say `cycle [0,1,2]', here you can't detect the cyclicity .. but with a list built on this kind of reference you could .. of course `STRef s' would also work, but then you lose guarrantee about no mutation
14:24:25 <ahunter2> ski: is there a simple way to implement a ref for pointer-equality?  I don't know of one, and it seems occaisonally useful?
14:24:54 <ski> ahunter2 : one way could be to make a newtype of `STRef s' or `IORef' ..
14:26:14 <ahunter2> ski: and then just do something akin to read -> change -> see if other changes -> put back old value?
14:26:31 <vixey> @hoogle unsafePointerEquality
14:26:31 <lambdabot> No matches found
14:26:39 <ski> (there's also dynamic environment variables that could be useful .. like `STRef s', but instead of equivalent to `get' and `put' you get equivalent to `ask' and `local' .. plus obviously you get `newRef')
14:27:24 <ski> ahunter2 : no, just using the `instance Eq (STRef s a)'
14:27:39 <Botje> unsafeCompareInfiniteDatastructures
14:27:48 <ahunter2> there's an Eq instance?  wasn't aware...good thing tho, I had been kind of hoping there was something like that
14:28:22 <ski> @instances-importing Data.STRef Eq
14:28:22 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, STRef s a, Sum a, [a]
14:28:27 <ahunter2> That raises the question...less of a should and more of a "wouldn't it be nice", but wouldn't it be nice if, say, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-STRef.html mentioned the Eq instance, or in general instances like that?
14:28:28 <lambdabot> Title: Data.STRef, http://tinyurl.com/6oug8m
14:28:51 <ski> (ahunter2 : note that it doesn't depend on `Eq a' ..)
14:29:16 <ahunter2> ski: yeah, I understand the instance, just didn't know it had one :)
14:30:13 <ski> ahunter2 : `Eq (STRef s a)' is mentioned on that page
14:31:05 <ahunter2> ...ah, I'm blind.  Just not very good at reading those tables.
14:31:45 <chrisdone> http://hackage.haskell.org/trac/ghc/ticket/2424 -- says this bug is fixed in "HEAD", what and where is that?
14:31:47 <lambdabot> Title: #2424 (Error compiling Crypto-4.1.0 on ghc-6.8.3) - GHC - Trac
14:32:02 * ski is leaving for sleep
14:32:05 <ski> good night
14:32:23 <ahunter2> night
14:36:10 <dons> chrisdone: ghc head.
14:36:16 <dons> chrisdone: i.e. the developer branch.
14:36:36 <dons> chrisdone: http://arcanux.org/lambdacats/fixed-in-head.jpg
14:37:35 <chrisdone> haha
14:41:52 <chrisdone> so I just get the unstable version?
14:43:05 <dons> or use ghc 6.8.2
14:43:15 <osfameron> you can normally substitute a foldr with a scanr to get a list containing the intermediate results of the fold... but that doesn't work when you're folding higher order functions (e.g. foldr (.) id [list,of,functions]
14:43:39 <ahunter2> @type foldr
14:43:40 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:43:40 <ahunter2> @type scanr
14:43:41 <dons> :t scanr (.) id
14:43:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
14:43:41 <lambdabot> forall a. [a -> a] -> [a -> a]
14:43:52 <chrisdone> okay
14:43:53 <dons> osfameron: don't you get a list of the intermediate compositions?
14:44:07 <osfameron> dons: I get a pretty haskell error
14:44:09 <dons> :t scanr (.) id [(+1), (*2), (`div` 3)]
14:44:10 <lambdabot> forall a. (Integral a) => [a -> a]
14:44:30 <dons> > let functions = scanr (.) id [(+1), (*2), (`div` 3)] in map ($7) functions
14:44:32 <osfameron> dons: oh, yes, I get that, sorry
14:44:33 <lambdabot>  [5,4,2,7]
14:44:39 <osfameron> but then I don't know what to do with it
14:44:52 <dons> well, you get a list of the intermediate functoins
14:44:54 <dons> so apply them!
14:45:07 <osfameron> $7 ?
14:45:22 <osfameron> ah ok
14:45:38 <dons> ($ 7)
14:45:40 * osfameron is not thinking this evening
14:45:47 <dons> its a cute idiom to remember.
14:45:54 <dons> the function that applies its argument to 7
14:46:01 --- mode: irc.freenode.net set +o ChanServ
14:46:11 <osfameron> presumably this is rather less efficient than yer usual scanr though, right?
14:46:23 <osfameron> in that each argument is getting a progressivfely more complicated composition applied to it
14:46:40 <osfameron> rather than working on the previously calculated value and just applying the next function to it
14:46:44 <dons> hmm, no, its still just an application at each point.
14:46:50 <dons> its not a fold, no.
14:47:26 <osfameron> so I'm starting with 7 for each application
14:50:42 <tromp> > ()
14:50:43 <lambdabot>  ()
14:53:46 <gwern> @help scheck
14:53:46 <lambdabot> scheck <expr>
14:53:46 <lambdabot> You have SmallCheck and 3 seconds. Test something.
14:54:02 <gwern> hum. does anyone ever actually use @scheck?
14:54:52 <roconnor> @scheck True
14:54:53 <lambdabot>     Failed to load interface for `SmallCheck':
14:54:53 <lambdabot>       Use -v to see a list of ...
14:55:14 <gwern> it's been broken for I don't know how long
14:55:30 * gwern wonders if that is evidence no one cares
14:58:08 <dons> the fact lambdabot sucks these days probably has a cultural effect on the channel, as we try out less things live.
14:58:46 <gwern> it has definitely had a chilling effect on the oleg facts
15:03:12 <Deewiant> gwern: I use scheck from time to time, only noticed that it was broken this or last week
15:05:01 <gwern> Deewiant: what does it actually do that quickcheck doesn't? I've never really seen real usage of it
15:08:53 <Cale> gwern: smallcheck does an exhaustive test of 'small' cases
15:09:32 <Cale> So it's like quickcheck, but instead of randomness, it supplies a bunch of things likely to be boundary cases.
15:09:36 <gwern> Cale: right, I've read the descriptions, but that doesn't give me any intuition as to what it actually does. is it just potentially more efficient than qc or what?
15:10:00 <Cale> Well, it just tests another space of inputs. It's complementary.
15:10:52 <dibblego> can't you just make it more likely to test boundaries with an adjusted Arbitrary?
15:11:52 <Cale> You can make it more likely, though that usually means that you'll end up repeating tests rather than exploring more inputs.
15:12:06 <Cale> and it doesn't guarantee that you'll test all the small cases
15:12:32 <gwern> I'm a little surprised qc doesn't avoid repeating tests; how hard would it be to store previous tests and do a lookup?
15:12:46 <Cale> actually, I'm not sure
15:12:50 <Cale> Maybe it does avoid that.
15:12:56 <dibblego> you'd need Eq
15:13:22 <gwern> sure, but how often does one not have eq?
15:13:27 <Cale> Ord if you want to be practical for large numbers of tests
15:14:42 <gwern> qc defaults to 100 tests; I don't think I've seen anyone but me use the lower-level tests to run more
15:15:06 * gwern goes to eat dinner
15:16:46 <Cale> btw, function arguments are a good example of a case where you don't have Eq
15:17:48 <Cale>  
15:20:02 <roconnor> > nub (repeat id)
15:20:17 <lambdabot>  thread killed
15:20:32 <roconnor> *sigh*
15:26:13 <Arnia> How common are 'unknown symbol error's at runtime in Haskell? I've never seen one before, so I'm not quite sure how to debug it
15:27:40 <dmwit> I've never seen one before, either.
15:27:47 <Cale> Arnia: I've never seen one.
15:27:48 <dmwit> Did you link against a library, then delete that library?
15:27:51 <dons> Arnia: that sounds like a serious runtime bug.
15:28:03 <dons> do you mean a compile time unknown symbol?
15:28:10 <Arnia> dons: nope, runtime
15:28:15 <dmhouse> It means you've got some code in your program that prints teh string "unknown symbol error".
15:28:18 <Arnia> dons: whilst trying to start Janus
15:28:18 <dmhouse> *the
15:28:24 <paczesiowa> agentzh: any luck with hxt?
15:28:28 <dons> Janus?
15:28:49 <Arnia> Application server that uses hs-plugins
15:29:11 <dmwit> Hayoo! uses it, no?
15:29:13 <dons> oh, i suppose if its loading code at runtime, it might not be able to resolve some symbols, so some debugging warnings will be printed.
15:30:21 <Arnia> The module it is loading is compiled on the same machine not thirty seconds before I start the system
15:31:11 <Arnia> I suspect the module being loaded is having problems connecting up with bytestring judging by the mangled symbol name
15:31:59 <Arnia> "loading shader creator 'request_shader' (object 'requestShader' in module 'Network.Server.Janus.Shader.HTTPShader')... janus:  unknown symbol `___stginit_bytestringzm0zi9zi1zi0_DataziByteString_' janus: user error (resolvedObjs failed.)"
15:33:32 <paczesiowa> Arnia: windows?
15:33:37 <Arnia> OS X
15:33:47 <Arnia> 10.5.4
15:34:41 <paczesiowa> I had that kind of errors on windows with hs-plugins code that worked on linux
15:35:45 <Shiruka> is lambda lifting the only way ghc can break the atomicity of a NOINLINE function?
15:35:47 <Arnia> Other numbers; GHC 6.8.2, bytestring-0.9.0.1, plugins-1.2
15:36:19 <dmwit> If you have BS0.9.0.1 installed, why is it looking for BS0.9.1.0?
15:36:37 <dmwit> preflex: zdec ___stginit_bytestringzm0zi9zi1zi0_DataziByteString_
15:36:37 <preflex>  ___stginit_bytestring-0.9.1.0_Data.ByteString_
15:36:57 <Arnia> dmead: that, I have no idea about :/
15:37:05 <Arnia> uh, dmwit
15:37:51 * Arnia realises just how little he knows about reading symbol names
15:38:00 <hexpuem> @search why dependent types matter
15:38:01 <lambdabot> Unknown command, try @list
15:39:29 <vixey> @go view from the left
15:39:30 <lambdabot> http://a-view-from-the-left.blogspot.com/
15:39:30 <lambdabot> Title: A View From The Left
15:39:34 <Arnia> dmwit: sorry, missed that I have *both* on the system
15:42:43 <paczesiowa> Arnia: try removing new bytestring package and leave only built into ghc one and rebuild all the packages
15:48:30 <gwern> @remember ab9rf a schmaser is what you get when you stimulate emissions by exciting crystallized jews
15:48:31 <lambdabot> Okay.
15:48:38 <gwern> @quote jews
15:48:38 <lambdabot> ab9rf says: a schmaser is what you get when you stimulate emissions by exciting crystallized jews
15:49:26 <mauke> preflex: quote
15:49:27 <preflex>  <hex> SEO! SEO! DAYLIGHT COME AND ME WAN GO HOME!  COME MISTER SEARCHY MAN OPTIMIZE ME KEYWORDS
15:49:53 <gwern> not too bad
15:49:56 <Arnia> paczesiowa: that worked. Thank you very much :)
15:50:51 <paczesiowa> Arnia: np, I remembered that I had those problems too but only in ghci, ghc-compiled was ok
15:57:31 <chrisdone> is there a way to write a split function String -> Char -> [String], without using explicit recursion?
15:57:51 <dons> chrisdone: using break, and recursion, yes.
15:58:01 <Shiruka> does it need to be efficient?
15:58:04 <dons> but you could always use a fold or unfold.
15:58:10 <mauke> everything can be written without explicit recursion
15:58:11 <vixey> preflex quote
15:58:11 <preflex>  <pizza> back when we had only 1 bit of memory we never had these organizational problems
15:58:14 <mauke> :t fix
15:58:16 <lambdabot> forall a. (a -> a) -> a
15:58:19 <gwern> oh noes, another split definition
15:58:51 <vixey> split ??
15:59:44 <gwern> there's a quote on #wikipedia's m:bash, to the effect that IRC has a corrupting influence on minds inasmuch as it leads them to think that 'split ??' is a coherent & sensible thing to say
16:01:49 <idnar> gwern: I was saying things like "split ??" long before I learned about IRC ;)
16:02:34 <gwern> idnar: how could you verbally say something like that?
16:03:01 <idnar> you utter the word "split" in a tone of extreme surprise
16:03:04 <Shiruka> "split question mark question mark"
16:03:14 <idnar> (or perhaps confusion, depending on what exactly was meant)
16:03:28 <gwern> extreme surprise.. thought that was 'split !!'
16:03:48 <idnar> 'split !!' sounds more like excitement to me
16:03:57 <idnar> oh well ;)
16:04:09 <idnar> perhaps 'split ?!'
16:04:13 <dmwit> "split ??" !!
16:04:26 <idnar> "Â¡Â¿split?!"
16:04:35 <gwern> idnar: besides, to the idea that you could pronounce split ??, I have only one link: http://www.qwantz.com/archive/000448.html
16:04:36 <lambdabot> Title: qwantz.com - dinosaur comics - December 20 2004
16:04:49 <idnar> gwern: that is a very good link
16:05:23 <vixey> what is split ???????????
16:05:23 <vixey> :p
16:05:26 <ahunter2> ...erm, is there a standard irc definition of "??" that I'm missing here?
16:05:32 <vixey> say you have a list
16:05:42 <vixey> [1,2,3] = 1 : 2 : 3 : []
16:05:46 <dmwit> split :: Eq a => a -> [a] -> [[a]]
16:05:47 <idnar> ahunter2: not that I know of
16:05:52 <dmwit> vixey: Is it clear now?
16:05:53 <vixey> how do you tag each node?
16:05:54 <dmwit> =)
16:06:04 <ahunter2> don't we love type signatures
16:06:12 <vixey> with a boolean so like
16:06:29 <dmwit> split ',' "for, example, really, simple, CSV parsing" --> ["for", " example", ...]
16:06:31 <vixey> 1^(True) : 2^(True) : 3^(False) : []^(True)
16:06:39 <vixey> yeah
16:07:05 <gwern> vixey: what dmwit said. the reason it's not in the standard libs is because everyone wants different edge-cases
16:07:12 <ahunter2> dmwit: that's a very incorrect definition of CSV :)  Of course, it's probably CSV's fault for being so silly when it comes to commas
16:07:23 <dibblego> actually, I've pondered writing split over Traversable
16:07:34 <dmwit> Well, yeah, CSV is way more annoying than (split ',') could cover.
16:07:45 <MyCatVerbs> CSV FTL.
16:08:03 <gwern> dibblego: it'd be interesting to see
16:08:14 <gwern> what would the benefits of split over traversable be?
16:08:16 <MyCatVerbs> Nobody should be allowed to design file formats who doesn't understand the concept of escaping, or why /etc/passwd's format is actually really, really elegant.
16:08:27 <ahunter2> I'm not even certain if it's defined how to have a field like, say, <begin>something "," else</end> (using tags to avoid the very problem I'm describing...)
16:09:06 <vixey> haskell is more annoying than split ',' :P
16:13:12 <roconnor> It seems there ought to be an optimally generic split
16:13:23 <osfameron> I tried to write a combinator based split toolkit at some point
16:13:34 <roconnor> that returns data : token : data : token : data : token ...
16:13:42 <roconnor> the result isn't a list
16:13:49 <roconnor> but could be converted to a list
16:13:56 <roconnor> ... in many different ways ;)
16:14:08 <roconnor> er
16:14:15 <dmwit> osfameron: ...like Parsec?
16:14:25 <roconnor> I guess split only returns data : token : data
16:14:30 <roconnor> but still
16:14:43 <osfameron> dmwit: that's pretty much the comment that I got when I tried :-)
16:14:46 <osfameron> http://osfameron.vox.com/library/post/haskell-words-and-perl-split.html
16:14:48 <lambdabot> http://tinyurl.com/2bz6am
16:14:57 <osfameron> but still fun to do
16:15:15 <gwern> osfameron: really? that's actually the approach I was going to take - I was going to write an ultra-general Either-based split, and then write the 4 variants as filters and drops of it
16:15:55 <dons> someone want to post a split library to hackage?
16:16:06 <dons> let's just do it already!
16:16:27 <gwern> dons: an entire library for 5 or 6 functions is kind of overkill
16:16:37 <dons> better than nothing.
16:16:43 <dons> and you might just get a sense of what people like.
16:16:48 <dmhouse> Proof of concept. Show it's useful, then get it into the libraries.
16:16:50 <dons> which we can then get into the platform set.
16:17:26 <dmhouse> Much easier to say "look, here's some working code, it's really useful, let's include it" than "I think we should do this".
16:18:40 <dons> history is made by those who turn up.
16:18:45 <gwern> dmhouse: we have plenty of working splits, that's not the problem
16:19:00 <dons> what's your plan then , gwern.
16:19:00 <gwern> I've collected 6 or 7 splits, not counting the 3 or 4 implementions on osfameron's post
16:19:10 <Saizan_> gwern: but none of them are somewhere to be used
16:19:18 <gwern> dons: I'm not sure. I was taking a break from split while I was hacking on mueval and lambdabot
16:19:29 * gwern was just a little frustrated
16:19:56 <gwern> @remember dons The difference is that Haskell refactoring proceeds by finding higher levels of abstraction for the computation ("oh, that's just a list monad", "oh, this is just an arrow on (-> a) space"), while perl refactoring relies on magic primitivies and switches.
16:19:57 <lambdabot> Okay.
16:20:15 <vixey> A lib for 5 or 6 is fine
16:20:31 <dons> fwiw, i think we need an entirely new lambdabot. a scalable bot built over transactional, persistant state.
16:20:58 <dons> i'm sketching an architecture, so we'll see how that goes in the next few months.
16:21:33 <vixey> cool
16:21:45 <gwern> dons: I think once we rip out hs-plugins, improvements will flow much more easily, and I'm nearing completion with that. if I don't do smallcheck, all I have to do is decide how to implement loading temporary definitions, and that'll be easy to do
16:21:54 <dmhouse> Gah. Why can't I upload anything to my FTP server.
16:21:57 <dons> i'm not convinced the core is stable enough.
16:22:13 <gwern> I am currently torn between loading an arbitrary local file, and insisting on passing a bunch of '--expression's
16:22:13 <dons> the plugins are fine, but the core architecture is ad hoc and ill considered.
16:22:46 <dons> so i can't see how that will address the instability issues.
16:23:18 <Saizan_> why is smallcheck harder than quickcheck?
16:23:24 <gwern> it would be nice if one could go 'mueval --expression 'let foo = \x -> x + 1' --expression 'foo 5''
16:24:08 <vixey> why not
16:24:09 <gwern> Saizan_: oh, it's an issue of the paramaters to the smallcheck function, and it was easier for me to modify the myquickcheck definition in the show package since I have push access to lambdabot. I'm not sure the smallcheck darcs repo is even maintained
16:24:15 <Saizan_> mueval --import Foo.hs --expression 'foo 5' looks saner
16:24:36 <vixey> mueval --let 'foo = \x -> x + 1' --expression 'foo 5'
16:24:41 <gwern> vixey: well, right now mueval needs complete expressions. if it were 'let foo = \x -> x + 1 in foo 5', it works fine
16:25:05 <vixey> I mean for future
16:25:10 <gwern> I'm not sure right now how to make temporary definitions using the GHC API
16:25:17 <vixey> like adding a --let flag
16:25:37 <vixey> it is possible?
16:25:45 <gwern> Saizan_: the problem with that approach is that it's unclear how to do it securely. the problem with the --let approach is it is unclear how to do qualified imports. problems both ways :)
16:26:12 <vixey> well where is the documentation for GHC API?
16:26:31 <gwern> vixey: there is none
16:26:50 <vixey> :/
16:26:54 <Saizan_> gwern: why? i'd just assume Foo.hs is trusted
16:27:53 <orbitz> fyi, if anyone cares, newnickbyme is doing a friendly little spam on entrance
16:28:01 <dons> hmm. i want to write something about haskell as a bet on hope and optimism for the future. the programming language for those who think the future will be better than the past.
16:28:04 <dons> orbitz: hmm ok.
16:28:21 <gwern> Saizan_: ah, but there's an issue. suppose a user issues 'let foo = unsafePerformIO $ evilness', or 'let foo = readFile something'. it fails evaluation, of course, but suppose it gets chucked into Foo.hs anyway. now, either Foo.hs gets checked again on every load - in which case it will fail and and block any fresh evalutions, or it will be trusted, in which case...
16:28:42 <gwern> Saizan_: *possibly* you could rig things so that one couldn't slip through the seams, but I'm not confident
16:29:03 <kryptiskt> dons: just copy an Obama speech
16:29:04 <Saizan_> gwern: avoid letting the user add imports to Foo.hs and you're safe
16:29:04 <Shiruka> dons: in what way better?
16:29:23 <Saizan_> gwern: where user is the remote one
16:29:29 <dons> Shiruka: programming should be easier, safer, less error prone than it is now.
16:30:05 <Saizan_> gwern: that's how it's done in lambdabot with L.hs, and security hasn't been a problem, no?
16:30:21 <Shiruka> dons: then explaining why haskell would bring hope of those things should be the way
16:30:24 <vixey> Saizan: iirc the purpose of it is for @let
16:30:26 <dons> code should be faster, advanced techniques more accessible. good results should be simpler.
16:30:30 <gwern> Saizan_: that may not work. I already had to have fixed a major security hole in the GHC API where imports didn't matter - you could still do 'Foreign.unsafePerformIO'
16:30:47 <vixey> why fp ?
16:30:55 <vixey> :p
16:31:08 <dons> Shiruka: right, i want to encourage optimistic people to make an investment in a better programming future, by helping us. shape the culture as optimistic and hopeful that we're not wasting our time .
16:31:18 <dons> shapr would love this
16:31:25 <kryptiskt> Haskell -- why not let your compiler do more of the work?
16:31:34 <Saizan_> gwern: that's because the GHC-API works like ghci, but if you compile Foo.hs ..
16:31:50 <gwern> Saizan_: how would I compile and load in Foo.hs?
16:31:52 <dons> haskell - because zippers of red black trees are for everyone!
16:32:04 <dons> haskell - because concurrency should be easy!
16:32:31 <osfameron> dons: ooo!  you have zipper on red-black tree?
16:32:37 <dolio> Hmm, zippers of red black trees.
16:32:40 <Saizan_> gwern: i think the ghc-api allows that
16:32:47 <dons> i don't think it exists yet.
16:32:58 <dons> but it sounds like something just on the edge of what we can do now. :)
16:33:03 <erikc> haskell - because otherwise you'll kill the guy with the non-threadsafe code
16:33:20 <Shiruka> dons: I just personally have seen way too many things that sing enticing abstract songs and have grown calluses in my ears; I think there are many others who have done the same :-) the more concrete you can make it the better, IMHO
16:33:48 <dons> yep.
16:33:56 <Saizan_> gwern: http://www.haskell.org/haskellwiki/GHC_API#Load_or_compile_modules ?
16:34:03 <lambdabot> Title: GHC/As a library - HaskellWiki, http://tinyurl.com/5k6rgx
16:34:15 <dolio> vixey: So, I thought about it a while during dinner and such, and I decided that I'm not entirely sure what the semantics of cut are, but I doubt you can implement them with msplit.
16:34:19 <dons> i want to convey the joy rolling a beautiful piece of code can produce.
16:34:30 <dons> and that that is how it *should* be.
16:34:53 <vixey> dolio: Yeah, I think it's not possible with msplit
16:34:59 <gwern> Saizan_: that page is outdated in places; again, I'm still not sure whether it would be safe
16:35:05 * gwern needs to think and investigate more
16:35:27 <vixey> dolio: I have it written in terms of streams in scheme.. I'm probably going to translate this
16:35:57 <vixey> so basically .. reimplement ListT, except with data Stream a = Nil Bool | Cons Bool a (Stream a)
16:36:33 <Saizan_> dolio: doesn't the logict paper argues that cut is a combination of ifte and once?
16:36:41 <vixey> Bool is whether or not the stream was cut at that point, appending streams is what takes account of the cut (drops everything after it off)
16:36:41 <dolio> vixey: I'm not entirely ashamed of the first part, either, because I've heard something to the effect that the semantics of cut has generated more papers than anything else in logic programming. :)
16:36:48 <dons> we should have a high performance, multicore ready light httpd server in haskell. i wonder why we don't have one yet, outside of happs.
16:36:56 <dons> tibbe: let's do it!
16:37:05 <gwern> Saizan_: also, one problem is that mueval still succeeds even when it shouldn't; for example, 'readFile "foo"' succeeds, and returns the String "<IO String>"
16:37:09 * vixey was trying to find a way to not rewriting ListT with minor changes but .. no luck
16:37:17 <gwern> Saizan_: so you can't conditionalize based on exit codes
16:37:22 <dons> Shiruka: you hacking any interesting haskell stuff, btw?
16:37:43 <vixey> ifte and once can be implemented using cut, not vice versoa
16:37:45 <dolio> Saizan_: I think you can do anything with them you can do with cut, but it's a non-local code transformation from code-with-cut to code-with-once/ifte.
16:37:45 <Saizan_> gwern: conditionalize what?
16:38:38 <gwern> Saizan_: well, suppose you wanted to add only 'good' functions to Foo.hs. 'if (exitCode process) == 0 then print "Foo.hs" expr else return ()'
16:38:47 <Saizan_> dolio: that looks right
16:38:49 * vixey is not sure about that ...
16:38:56 <Shiruka> dons: not at the moment.. and the one thing I've been thinking of doing is pretty heretic too :-)
16:39:18 <Shiruka> because I use a lot of python, I've been wanting to see how good haskell-python bridge you could build
16:39:20 <dons> oh?
16:39:31 <dons> ah. have you seen john goerzon's missingpy bridge?
16:39:38 <EvilTerran> ops, why is this "Im-a-bot-for-ads" still in the channel?
16:39:46 <gwern> Shiruka: have you looked into... ah, dons beat me to it
16:39:49 <dons> glguy used it to bind to pygments, was quite cool.
16:39:59 <Saizan_> gwern: as long as bad functions can't really be run i wouldn't worry, but this all depends on how much mueval wants to do
16:40:00 <Shiruka> yes, but it's not quite what I was thinking of :-)
16:40:36 <gwern> Saizan_: well, you're welcome to the darcs repo
16:40:38 <gwern> code.haskell.org/mubot, iirc
16:40:43 <Shiruka> particularly, it does not do the python->haskell direction
16:40:57 <Shiruka> (this is where the heresy lies - haskell's not on the top in that direction)
16:41:42 <dons> hmm, so it lets python call haskell?
16:42:07 <dons> that's a *good* thing, we want to mitigate the risk of needing to rewrite a project entirely in haskell, just to use a good haskell library
16:42:09 <Twey> But there's a reason that's not possible...
16:42:17 <dons> why?
16:42:23 <Twey> The types, no?
16:42:32 <Botje> dynamic! :)
16:42:33 <dons> well, C calls Haskell. Haskell calls Python.
16:42:36 <Twey> I mean, I guess you can add type gates for Python
16:42:39 <dons> i'm sure we can make it work.
16:42:47 <Twey> 'kay
16:42:54 <dolio> vixey: Something like [[ P1, P2, ... PN, ! PN+1, ... ; Q ]] = ifte (once (TupN <$> [[P1]] <*> [[P2]] ...)) (\<x> -> [[PN+1, ...]]) ([[Q]])
16:43:04 <Twey> @src <*>
16:43:04 <lambdabot> Source not found. You untyped fool!
16:43:19 <vixey> oh types don't make things impossible
16:43:26 <Twey> Where are <$> and <*> from?  Been seeing those a lot recently
16:43:29 <vixey> unless you -want- things to be impossible
16:43:38 <O_4> Blimey, how do I declare one of a data type's pieces of data to be of type IArray?
16:43:46 <mauke> IArray is not a type
16:44:00 <Saizan_> Twey: Control.Applicative
16:44:07 <Twey> Oh
16:44:49 <Botje> O_4: foo :: Array Int Int
16:45:20 <O_4> Why do I need two types?  On http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html#t%3AIArray it has just one param, I thought.
16:45:22 <lambdabot> Title: Data.Array.IArray, http://tinyurl.com/333ztl
16:45:36 <Botje> IArray is just an interface
16:45:44 <Botje> Array "implements" IArray
16:45:52 <Botje> it has a type for the key and for the value
16:46:18 <Botje> :t Data.Array.listArr (1,2) ["foo","bar"]
16:46:20 <lambdabot> Not in scope: `Data.Array.listArr'
16:46:26 <Shiruka> dons: the python interface in the C++ Boost library is pretty OK, and it's obviously horribly Wrong(TM) that C++ does that better than Haskell currently ;-)
16:46:35 <dons> agreed.
16:46:40 <Botje> :t Data.Array.listArray (1,2) ["foo","bar"]
16:46:41 <lambdabot> forall t. (Ix t, Num t) => Array t [Char]
16:46:45 <Saizan_> in IArray a e where ... 'a' must be a type that takes 2 parameters because of e.g. the type signature of bounds
16:46:46 <vixey> dolio: I can't really understand that
16:46:51 <O_4> Botje: so how come the "IArray Array e" line only has 'e' as a param?
16:46:53 <dolio> Which makes [[ not(P) :- call(P), !, fail ; true ]] = not p = ifte (once p) (\x -> mzero) (return ())
16:47:04 <O_4> I find the haskell docs quite hard to find my way around :-/
16:47:40 <Botje> look at the page for Data.Array instead
16:47:46 <Botje> which is a whole lot clearer :)
16:48:00 <dmwit> O_4: Dunno for sure, I'm not looking at the same thing you are.  But at a guess: it's actually IArray (Array e), right?
16:48:08 <O_4> Botje: that has even less info
16:48:23 <O_4> dmwit: that's not how it's written, no.
16:48:23 <dmwit> O_4: In that case, it doesn't have both parameters to Array because the class is contained-element-agnostic.
16:48:31 <dmwit> Okay, ignore me, then.
16:48:38 <dmwit> (Where are you looking, out of curiosity?)
16:48:39 <Saizan_> dmwit: it's more index-agnostic
16:48:42 <Botje> O_4: it has enough information for common use. what do you need to know?
16:48:56 <O_4> Botje: I'm looking at http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html
16:48:56 <lambdabot> Title: Data.Array, http://tinyurl.com/5d8233
16:49:04 <O_4> It just has a few identifiers
16:49:04 <dmwit> Saizan_: err, yeah, that
16:49:13 <O_4> I have no idea how to make use of any of those :-/
16:49:22 <Botje> uhh
16:49:25 <Botje> i was looking at http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Array.html
16:49:25 <lambdabot> Title: Data.Array
16:49:25 <Saizan_> O_4: it's not a problem of documentation however, it's just that you've to learn about constructor and multiparameter type classes to understand what IArray is
16:49:28 <dmwit> Whoa, that page is way wrong.
16:49:28 <dolio> vixey: I mean, P1 to PN are some predicates, after which you cut, and then have some other number of predicates PN+1 ..., and you have alternate clauses denoted Q...
16:50:21 <O_4> Saizan_: I'm pretty sure the docs on haskell.org *are* what you'd call "lacking" :-p
16:50:22 <dmwit> Saizan_: No, it really was the documentation.  Look at the link he gave, it's all mucked up.
16:50:33 <dmwit> Saizan_: haddock got broken or something
16:50:46 <O_4> Yeah, the cvs ones are much more useful.
16:50:55 <O_4> Thanks for the pointer Botje
16:51:07 <Saizan_> oh, i thought we were looking at IArray, sorry
16:51:38 <vixey> dolio, what about
16:51:53 <dolio> vixey: Translated to logict, you compute all tuples of P1 to PN, prune with 'once', and branch using ifte. In the success case, you match against the tuple to bind the appropriate variables for PN+1.., and the failure case is the interpretation of Q.
16:52:03 <vixey> p(1) :- A.
16:52:04 <dolio> But like I said, I'm not super clear on what all cut does.
16:52:13 <vixey> p(2) :- B, !, C.
16:52:23 <vixey> p(3) :- D.
16:54:47 <dons> does that look like the Haskell Workshop program to anyone else, http://www.haskell.org/haskell-symposium/2008/accepted.html
16:54:47 <lambdabot> Title: ACM SIGPLAN 2008 Haskell Symposium Accepted Papers
16:55:16 <dolio> vixey: I'm not sure what you're asking there.
16:57:03 <dons> http://www.reddit.com/comments/6tlrc/lightweight_monadic_regions_oleg_and_cc_shan/
16:57:04 <lambdabot> Title: Lightweight monadic regions. Oleg and CC Shan : reddit.com, http://tinyurl.com/69e3fr
16:57:11 <dons> let the new papers roll
16:57:11 <vixey> dolio, in my example, a call p(X) will try p(1) and A, redo would try p(2) and B then C, redo would not try p(3) due to the cut.. but if say B failed and the cut wasn't reached then it would try that.. ! in there doesn't escape or do anything to the caller(s)
16:57:30 <vixey> I'm not sure how to write it as ifte and once though
16:57:44 <dons> dolio: might be a new library in there for hackage.
16:57:54 <dolio> Hmm.
16:58:10 <vixey> and I don't think something with multiple cuts could be translated into single... so I'm still not certain the transform is always possible
17:00:51 <Shiruka> posting an oleg paper on reddit.. I can already hear the gigantic *whoosh*
17:01:10 <dolio> vixey: So, I think that turns into: p = (,) 1 <$> [[A]] `mplus` ifte (once ((,) 2 <$> [[B]])) (\(_, b) -> (,) 2 <$> [[C]]) ((,) 3 <$> [[D]])
17:01:41 <gwern> Shiruka: oleg has been well-received in the past
17:02:21 <Twey> How come I've never seen the famous Oleg on here?  :-)
17:02:48 <Shiruka> maybe there are more knowledgeable redditers than I thought, then
17:02:49 <gwern> Twey: he is far too busy to hang out here. and there'd be no point; we would not understand him, nor he us
17:03:05 <gwern> also, oleg is very ecumenical. he'd have to hang out in #scheme, #sml, etc.
17:03:22 <dolio> He'd have no time to do awesome type hackery if he did all that.
17:03:29 <dons> i'm glad we don't have guys like this in haskell land yet, http://tonyarcieri.org/articles/2008/07/26/the-single-assignment-cargo-cult
17:03:32 <paczesiowa> Twey: maybe he doesn't really exist, he is just an idea to make us believe
17:03:33 <lambdabot> Title: The single assignment cargo cult : The Art of Science, http://tinyurl.com/5qpzgg
17:03:36 <dons> the erlang guys are feeling the heat.
17:03:52 <dons> i'm not even sure what this guy's trying to do.
17:04:10 <Twey> gwern: Hahaha, ah :-P
17:04:15 <Twey> paczesiowa: I do sometimes wonder :-P
17:04:18 <dolio> How could you be against single assignment and also use haskell? :)
17:04:25 <Shiruka> oh, I first thought it was about SSA
17:04:41 * gwern takes a small bit of pleasure in using the elegant phrase 'nor he us'
17:06:29 <Twey> HAHAHA
17:06:47 <Twey> 'It is reason why once variable assignment is in Erlang and why it is good think'
17:06:57 <dolio> Well, he repeats the thing about 'x = foo(x) ; x = bar(x)' and inserting an 'x = baz(x)' in the middle of the two.
17:07:04 <gwern> sounds russian
17:07:06 <Shiruka> the quotations he has in that article are scary
17:07:15 <Shiruka> I hope they are made up..
17:07:32 <Twey> 'Are you saying Joe Armstrong is WRONGE?!?!?! *angryface*'
17:07:32 <dolio> Which is really just a complaint about the fact that you can't write 'foo . baz . bar' that easily in Erlang (I guess).
17:07:45 <dolio> Not something you need mutable variables for.
17:07:46 <vixey> I don't think that's very funny
17:07:54 <Twey> I very rarely use multiple-assignment any more
17:07:58 <Twey> Even in Python :-\
17:08:01 <Shiruka> though if they aren't, I've no idea why he isn't being sensible and just pretending he didn't hear them..
17:08:24 <Twey> Variables exist to make up for the shameful lack of 'let'
17:08:26 <dolio> (Of course, even haskell will shadow the variables on 'x <- foo x ; x <- baz x ; x <- bar x' in a do block.
17:08:29 <vixey> hmm everybody is programming in python today, it's kind of shame
17:08:40 <dons> he doesn't actually want mutable variables, as far as i can tell.
17:08:48 <dons> just hates needing fresh names.
17:08:58 <dons> so, yeah, missing a composition operator.
17:08:58 <Twey> vixey: Eh, imperative languages have their place.
17:09:00 <Twey> For now.
17:09:13 <dolio> He should write in Forth. Problem solved!
17:09:18 <vixey> haskell can be imperative
17:09:48 <Shiruka> the suggestion of using variables like x10, x20, ... sounds so BASIC-y to me that I feel dirty
17:09:56 <Twey> Heheh
17:10:09 <Twey> That was someone's reaction to Haskell
17:10:19 <Twey> 'It has LET?!  What is this, BASIC?!'
17:10:31 <dolio> Yeah, x10, x20 ... is a pretty poor solution.
17:10:45 * Twey nods.
17:11:02 <mauke> heh, it's a form of amortization
17:11:13 <ahunter2> dolio: amusingly, my research adviser was just telling me about an algorithm which does something quite similar for asymptotic gains yesterday
17:11:22 <vixey> you certainly want the right to name things which need not be names
17:11:25 <ahunter2> doing version stamping
17:11:27 <Twey> Hmnhmnhmn
17:11:36 <vixey> named*
17:11:46 <vixey> oops. to not do so
17:11:56 <ahunter2> where it's provably efficient asymptotically to just leave big gaps, stick things in the middle til you can't, then renumber everything to make more gaps :P
17:12:06 * dons suggests X' X'' X'''
17:12:32 <Twey> Haskell doesn't actually have multiple assignment
17:12:49 <ddarius> (x,y) = (1,30
17:13:01 <Shiruka> dons: does not solve the problem if you really want to insert a variable in between in the sequence.. but using x'''''''''''' with that long lists is silly anyway (what is this, unary? :-)
17:13:07 <dons> :)
17:13:10 <Twey> That's not do blocks, that's talking about (top-level): a = 3\na = 5
17:13:11 <geezusfreeek> yay for quickcheck, boo for bugs
17:13:38 <Twey> Which is stupid, because it breaks the 'defined anywhere' rule
17:13:52 <Shiruka> using . sounds like a good solution, it's best not to have to make up meaningless names anyway
17:14:04 <vixey> > do let x = 3 in let x = 4 in x
17:14:08 <lambdabot>   add an instance declaration for (Num (t t1))
17:14:21 <Shiruka> I mean, if the best you can come up with is "x1, x2, x3, ..." then better not to have names at all if you can (sanely) avoid it..
17:14:57 <dons> if the object doesn't have a meaningful name, just compose and hide it, i guess.
17:15:02 <dons> if it really isn't meaningful to name.
17:15:49 <Shiruka> as long as it does not give the reader pointless nightmares :-)
17:16:06 <dmhouse> x = func(x) -- isn't this considered bad style in imperative programs anyway? I rarely see it.
17:16:13 * Shiruka loves pointlessness, but only up to a point!
17:16:46 <dolio> The example in that blog is a prime example where pointlessness would be a win, though.
17:17:06 <dmhouse> Most of the time I see it is for flexible arguments, e.g. func($id) { if (is_object($id)) $id = $id->id; ... }, then you can pass either the id or the object. But of course that wouldn't work in a strictly typed language.
17:17:06 <Shiruka> dmhouse: reusing variable names is often considered bad style
17:17:10 <vixey> f(X) ->
17:17:15 <Saizan_> why do you write x = foo(arg); x = bar(x) .. even if you lack composition? x = bar(foo(arg))
17:17:27 <vixey>   X1 = foo(X),
17:17:36 <vixey>   X2 = fab(X1),
17:17:36 <vixey>   X3 = bar(X2),
17:18:36 <dons> so he's asking for what, X = foo(X) , X = fab(X), X = bar(X). ?
17:18:41 <dolio> Oh, there is no closing of handles in Oleg's scheme.
17:18:46 <vixey>   baz(X3).
17:18:52 <dolio> I guess I should have guessed that from the 'region' part of the title.
17:18:55 <vixey> is that erlang bit
17:19:02 <dons> dolio: yeah. its all scoped, no?
17:19:04 <vixey> f(X) -> baz(bar(fab(foo(X)))).
17:19:06 <dolio> Yeah.
17:19:14 <vixey> different to that one?
17:19:25 <vixey> I don't know erlang
17:19:51 <dolio> vixey: I imagine it's the same.
17:20:09 * vixey isn't the only one then lol
17:20:15 <Shiruka> Saizan_: the real names are probably longer, and splitting an expression over 10 lines is usually frowned upon in imperative languages
17:20:18 <vixey> it might not be ...
17:21:47 <Saizan_> Shiruka: you're essentially doing the same thing with multiple assignements
17:22:12 <dolio> dons: At first I was thinking of some kind of scheme for ensuring you can't use a handle after an explicit close. He actually talks about that at the end.
17:22:18 <Saizan_> Shiruka: the only thing i'd hate would be to keep the parentheses balanced, /me hugs (.)
17:22:23 <Shiruka> returnTheObjectWithTheCakeAttributeSetToEatenPleaseWillYou(makeAPartyObjectWhereEveryoneHasLotsOfFunWithMembers(MemberWho.....)) <--- besides, the verbosity level often looks like that in function names
17:22:24 <dmhouse> Shiruka: probably because they dont have the (.) operator.
17:22:50 <dmhouse> Saizan_: aww, c'mon, any decent editor can do paren balancing.
17:22:52 <dons> i've a goal this year to make sure the new research at icfp/hw ends up on hackage.
17:23:06 <vixey> dmhouse: is it impossible to add it to erlang?
17:23:26 <dmhouse> I meant imperative languages don't. I know nothing of Erland.
17:23:29 <dmhouse> *Erlang
17:23:51 <vixey> hm: /
17:25:00 <dolio> I don't think Erlang has definable operators. At least, I haven't seen much of it in the bits of Erlang I've come across.
17:25:35 <paczesiowa> it doesn't? they based it on prolog's syntax and they left the best feature?
17:25:44 <dolio> And 'compose(foo, compose(bar, baz))' isn't going to help much.
17:25:57 <dolio> I may well be wrong.
17:26:09 <Shiruka> say what? erlang doesn't have functions? :-O
17:26:18 <Twey> It doesn't, no
17:26:19 * Shiruka hasn't actually used erlang
17:26:29 <geezusfreeek> i have seen somebody do just that, dolio, so i imagine it doesn't have the ability to define new operators
17:26:38 <paczesiowa> you can use list of functions to compose and fold it
17:26:55 <vixey> I am sure erlang has functions
17:27:06 <vixey> that about all I know about erlang
17:27:08 <Twey> Functions yes, custom operators no.
17:28:26 <Shiruka> ah, _infix_ operators..
17:28:43 <Facedown> BASTARD
17:28:46 <Facedown> found you.
17:28:51 <Shiruka> sorry, I have lisp on my brain
17:28:53 <Facedown> running away from me
17:29:19 * Twey looks at Facedown.
17:29:23 <Twey> Yerwhat?
17:29:55 <Facedown> Oh nothing, wandering through freenode's 3rd world channels.
17:30:51 <Twey> I se
17:30:52 <Twey> e
17:30:57 * vixey adds an ignore ...
17:30:58 <Twey> Get back in ##javascript where you belong
17:31:07 <Facedown> How?
17:31:12 <Facedown> Lol
17:31:17 --- mode: ChanServ set +o dmhouse
17:31:31 <Twey> You invited makk, you put up with him :-P
17:31:39 <Facedown> wish i could join
17:31:50 <Facedown> i talked with makk for like 2 hours on efnet js though
17:31:58 <Facedown> had tons of questions
17:32:05 <Facedown> floating around in my head, been waiting to ask a guru for a week
17:32:34 <Twey> He's quite confrontational, has an 'anything goes' attitude, and refuses to ever admit he's wrong
17:32:43 --- mode: dmhouse set -o dmhouse
17:33:20 <Facedown> i just learned self, parent, top, the timer methods are dom 0 methods
17:33:27 <vixey> Twey maybe PM your friend or something?
17:38:35 <geezusfreeek>  /ignore Facedown
17:39:31 <dolio> vixey: Incidentally, there are probably other ways of translating that example you gave, depending on how you want to use the predicate. The translation changes depending on what mode you want to use it in.
17:39:58 <dolio> Which probably isn't true in the absense of cut.
17:40:07 <vixey> dolio: oh, hmm ..
17:40:45 <dolio> For instance, the translation I gave is for X as an out, I think.
17:41:01 * vixey just can't be bothered implementing StreamT yet
17:41:43 <vixey> yeah I think I understand it now
17:43:14 <dolio> You might be able to have one translation that subsumes both if you do more complicated things, like keep track of ground variables and such.
17:43:50 <dolio> But that's more than just using it as a fancy list monad.
17:46:56 <dolio> For instance [[ P(x,Y), Q ]] = do (x,y) <- p ; guard (x == [[x]]) ; [[Q]] is no longer true if P has cut in it.
17:47:23 <dolio> Since the value of x might avoid a cut.
17:49:11 <EvilTerran> !bot
17:49:38 <EvilTerran> :(
17:57:42 <ddarius> @bot
17:57:42 <lambdabot> :)
17:59:14 <EvilTerran> !yow
17:59:18 <EvilTerran> ?yow
17:59:18 <lambdabot> Couldn't find fortune file
17:59:21 <EvilTerran> doh
18:04:11 <Shiruka> unfortunate
18:24:55 <gnut> hi all
18:25:52 <vixey> hello
18:26:34 <gnut> good afternoon
18:32:33 <Shiruka> hm, syntax highlighting makes a surprising difference to core's readability..
18:45:02 <chrisdone> is there a word to describe the action of implementing something using a method where it is not suited? for example, object orientation is the proverbial hammer and everything looks like a nail
18:46:54 <Raevel> small scale anti pattern?
18:46:55 <vixey> can lambdabot print out the bind and return for a monad?
18:46:55 <Twey> chrisdone: 'The effects of a Java-based CS course'?
18:46:55 <vixey> like ... StateT Bool [] ()
18:47:02 <Raevel> ":-("
18:47:22 <Twey> vixey: Yes -- put @src typeclass method
18:47:42 <Twey> Er, not typeclass, type
18:47:44 <Twey> @src [] >>=
18:47:45 <lambdabot> Source not found.
18:47:47 <vixey> @src (StateT Bool [] ()) return
18:47:47 <lambdabot> Source not found. Where did you learn to type?
18:47:52 <Twey> Hmph
18:47:59 <Twey> I thought that was right, anyway
18:48:09 <Twey> :t [] return
18:48:11 <lambdabot>     Couldn't match expected type `(a -> m a) -> t'
18:48:11 <lambdabot>            against inferred type `[a1]'
18:48:23 <Twey> 'elp
18:48:52 <ddarius> @src StateT return
18:48:52 <lambdabot> Source not found. My pet ferret can type better than you!
18:48:58 <chrisdone> @help src
18:48:58 <lambdabot> src <id>. Display the implementation of a standard function
18:49:11 <vixey> I need a way to rewrite
18:49:16 <ddarius> @src [] mplus
18:49:16 <lambdabot> mplus = (++)
18:49:18 <vixey>           y <- Ï• ['a','b'] + (True ! Ï• ['c','d','e','f'])
18:49:18 <vixey> as
18:49:30 <chrisdone> unicode, nice
18:49:32 <vixey>            y <- Ï• ['a','b','c','d','e','f']            if y == 'c' then cut else return ()
18:49:53 <vixey> I think it's impossibly without mutation :/
18:51:05 <vixey> so maybe Stream can't work like this in haskell
18:51:29 <gwern> > let (Ï•) = (+) in Ï• 1 1
18:51:31 <lambdabot>  2
18:51:45 <gwern> ...I didn't actually expect that to work
18:51:47 <chrisdone> wait, what. when did utf-8 get added
18:52:25 <Raevel> code has never looked this cool
18:52:26 <vixey> gwern, does mueval support  nicode?
18:52:33 <chrisdone> Raevel: hehe
18:52:38 <vixey> > let (Ã—) = (,)
18:52:38 <lambdabot>  Illegal character ''\215''
18:52:38 <lambdabot>  at "×)" (column 6)
18:52:47 <vixey> > let (Ã—) = (,) in 3 Ã— 4
18:52:47 <lambdabot>  Illegal character ''\215''
18:52:47 <lambdabot>  at "×)" (column 6)
18:52:52 <vixey> is a way to test..
18:52:55 <gwern> vixey: I dunno. it seems to get in alright, but that same expression doesn't compile
18:53:02 <vixey> because that works in ghci
18:53:37 <sjanssen> gwern: you'll understand why that works if you look at the bytes in Ï•
18:53:51 <gwern> vixey: http://hpaste.org/9184
18:53:59 <sjanssen> it only works in lambdabot thanks to coincedence
18:54:04 <gwern> sjanssen: how would I do that?
18:54:04 <vixey> aw :(
18:54:06 <chrisdone> > 'Ï•'
18:54:07 <lambdabot>  '\981'
18:54:36 <sjanssen> gwern: find a UTF-8 decoder
18:54:47 * sjanssen fires up Data.Binary
18:54:47 <Arnia> Another silly question, but how do I get cabal-install to fetch a particular version of a package? Or should I just do that manually?
18:55:17 <gwern> sjanssen: so then why do Ï• and Ã— seem to work in ghci?
18:55:28 <sjanssen> gwern: ghci has UTF-8 support
18:55:33 <sjanssen> gwern: as does GHC
18:55:49 <gwern> hum. I wonder why mueval doesn't work then
18:56:03 <sjanssen> gwern: but lambdabot, and Language.Haskell (which lambdabot uses to pre-parse the input) doesn't
18:56:09 <dolio> GHC's IO routines don't have UTF-8 support.
18:56:29 <dolio> (I think.)
18:56:31 <sjanssen> gwern: because lambdabot communicates to GHC with pipes, while mueval uses the GHC API
18:56:35 <sjanssen> dolio: yes, you are correct
18:56:36 <gwern> let Ã—) = (,) in Ã— 3 4 <-- ah, there's the problem
18:56:48 <dolio> You'd need to use utf8-string.
18:56:59 <gwern> I added a flag to mueval to print out what it sees, and that's it. note it seems to be missing a (
18:57:11 <chrisdone> is there a library function f :: Bits a => a -> String where f 2 = "10" or something similar?
18:57:19 <gwern> read?
18:57:30 <O_4> Hmm, is there a convenient way to have case statements that match against ranges of values?
18:57:31 <chrisdone> read takes a String Â·â€”Â·
18:57:32 <gwern> I'd look at it first
18:57:38 <O_4> Or rather, clauses.
18:57:40 <sjanssen> chrisdone: you can write such a function with Numeric.showIntAtBase
18:57:47 <chrisdone> sjanssen: ohh, cool!
18:57:55 <sjanssen> @type Numeric.showIntAtBase
18:58:00 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
18:58:05 <Saizan_> sjanssen: i've added utf8 decoding to runplugs, the problem now is in the lexer of Language.Haskell.Parser
18:58:30 <sjanssen> > showIntAtBase 2 ("01"!!) 10 ""
18:58:31 <lambdabot>  "1010"
18:58:38 <chrisdone> sjanssen: yaaaay
18:58:58 <sjanssen> Saizan_: hmm, why would runplugs need to know UTF-8?  Can't it just stupidly pass the input to GHC?
18:59:24 <sjanssen> Saizan_: oh, hs-plugins uses the GHC API now, doesn't it
18:59:40 <chrisdone> > binary 981
18:59:41 <lambdabot>  "Exception: Prelude.(!!): index too large
18:59:49 <Saizan_> sjanssen: to GHC yes, but Language.Haskell.Parser needs Unicode, but it also has a weird definition of isSymbol in the lexer, so not everything works
19:00:24 <Raevel> what's the point of the last arg to showIntAtBase?
19:00:35 <sjanssen> Raevel: it is a String to append to the result
19:00:55 <sjanssen> Raevel: it's a little trick to efficiently string together long outputs
19:00:57 <Raevel> ok, that's what it seemed to do, but why? :-)
19:01:09 <Raevel> i see
19:01:10 <sjanssen> @src ShowS
19:01:10 <lambdabot> type ShowS = String -> String
19:01:23 <sjanssen> Raevel: this is called 'ShowS' in the standard Prelude
19:02:38 <gwern> shoot. there is no utf8-string getArgs?
19:03:17 <chrisdone> liftM (map encodeString) getArgs?
19:03:35 <gwern> chrisdone: I'm not sure that'd work. wouldn't the damage be already done?
19:04:16 <chrisdone> I don't think so
19:04:30 <sjanssen> gwern: nah, getArgs won't lose any information
19:06:13 <chrisdone> what does encodeString to do the bytes? does it say go from ['\x','\y'] to ['\z'] where z = utf8ize(x,y)? like lambda usually appears as two bytes unencoded, but one when encoded?
19:06:42 <chrisdone> well, not "bytes" as much as Chars
19:07:06 <mmorrow> internet's like water, you don't miss it until you don't have it
19:07:32 <gwern> or air
19:07:39 <mmorrow> or not-pain
19:08:05 <chrisdone> missing = not having and wanting Â·_Â·
19:08:25 <mmorrow> yesh
19:08:46 <Raevel> mmm not-pain
19:08:51 <mmorrow> well, phones don't count, because browsing anything on them is excrutiating
19:08:53 <chrisdone> sjanssen: do you know the answer to my question? ._.
19:08:53 <vixey> it's weird how lift and liftM are completely unrelated
19:09:03 <chrisdone> :t lift
19:09:04 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
19:09:44 <chrisdone> I can't remember what lift does @_@
19:09:49 <sjanssen> chrisdone: yes, by nature UTF-8 encoding turns one or more bytes into a single character
19:09:58 <chrisdone> sjanssen: gotcha
19:10:20 <gwern> oh wow. I obviously am doing utf wrong if my output is 'let (ÃƒÃ‚) = (,) in ÃƒÃ‚ 3 4'
19:10:34 <chrisdone> looks like it needs encodeString, there..
19:10:36 <Saizan_> encode actually goes from Unicode codepoints to UTF8
19:10:44 <chrisdone> right
19:11:01 <sjanssen> chrisdone: in which case my explanation is incorrect
19:11:07 <gwern> I dunno, I was doing 'input <- liftM (map Codec.encodeString) getArgs'
19:11:13 <gwern> which looks right to me
19:11:17 <chrisdone> sjanssen: how so?
19:11:17 <Saizan_> it's valid for decodeString :)
19:11:20 <sjanssen> encode turns one Char to one or more Chars
19:11:26 <gwern> and then 'mapM UTF.putStr input'
19:11:28 <sjanssen> decode turns one or more Chars to one Char
19:11:38 <Saizan_> gwern: use decodeString
19:11:50 <sjanssen> "encode" and "decode" are rather ambiguous here
19:12:03 <mmorrow> to and fro
19:12:08 * gwern has a brain asplosion. isn't that opposite what should be?
19:12:29 <sjanssen> gwern: yes, I would have chosen the other way
19:12:41 <gwern> hm. now it prints out 'let (Ã—) = (,) in Ã— 3 4', which is right, but it still doesn't compile
19:12:50 <gwern> I wonder whether there's a GHC API option I need to use?
19:13:00 <vixey> let (Ã—) = (,) in 3 Ã— 4
19:13:02 <vixey> Ã— is an operator
19:13:07 <Saizan_> well, if you think that uft8 is the encoding and Unicode the "real" representation it makes sense
19:13:28 <chrisdone> it does?
19:13:51 <Twey> Unicode is big map of numbers to characters.
19:13:54 <bwr_> you can use Ã— as an operator?
19:13:54 <chrisdone> utf8 is the encoding then "encode" to go from nbytes to 1byte..
19:13:58 <Twey> UTF-8 is a way of encoding those numbers.
19:14:06 <vixey> bwr_: yes
19:14:17 <bwr_> can you use other symbols?
19:14:25 <bwr_> i mean other than the ascii ones
19:14:27 <vixey> bwr_: yes
19:14:42 <chrisdone> > let (Î²)= (,) in Î² 3 4
19:14:43 <lambdabot>  (3,4)
19:14:51 <bwr_> that's awesome
19:14:53 * vixey often uses (â‰¡) is unification
19:15:44 <Raevel> so, you can use any utf8 characters that map to legal names when read ascii?
19:15:54 <Raevel> read as* ascii
19:15:56 <chrisdone> I love unicode but it bugs me that one day someone would have trouble viewing my code because of some encoding issue, or just refuse to help me because they can't type the symbols
19:16:02 <mar77a> > let Ã± = (+) in 5 Ã± 5
19:16:04 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
19:16:18 <chrisdone> mar77a: that's not declared infix
19:16:18 <mar77a> > let (Ã±) = (+) in 5 Ã± 5
19:16:19 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
19:16:22 <vixey> Ã± is a function, not an operator
19:16:30 <mar77a> > let (Ã±) = (+) in Ã± 5 5
19:16:31 <lambdabot>  10
19:16:38 <gwern> > let (Ã—) = (,) in 3 Ã— 4
19:16:38 <lambdabot>  Illegal character ''\215''
19:16:38 <lambdabot>  at "×)" (column 6)
19:16:57 <dons> it seems to me that fixing Language.Haskell to lex unicode is pretty trivial.
19:17:06 <gwern> hm
19:17:08 <chrisdone> what's your Ã— mapped as? mine's AltGr+9
19:17:17 <chrisdone> er, 8
19:17:26 <sjanssen> Saizan_: is it just a case of using Data.Char's isSymbol?
19:17:30 <Twey> Compose-x-x
19:17:32 <Twey> Ã—
19:17:57 <gwern> if this is a terminal problem, I shall be miffed, or possibly even irked
19:18:18 <sjanssen> gwern: what is your locale?
19:18:29 <gwern> no idea
19:18:32 <gwern> > let (Ã±) = (+) in Ã± 5 5
19:18:33 <lambdabot>  10
19:18:36 <Saizan_> -isSymbol c = elem c ":!#$%&*+./<=>?@\\^|-~"
19:18:38 <Saizan_> +isSymbol c = c `elem` "!#$%&*+./<=>?@" || Data.Char.isSymbol c && not (c `elem` "(),;[]`{}_:\"'")
19:19:01 <Saizan_> sjanssen: ^^^ that's it i think, but i'd have to test
19:19:26 <rwbarton> gwern: "locale" should tell you
19:19:29 <Saizan_> directly translating the BNFC from the report
19:19:31 <gwern> blast. so that worked after I pasted it, and didn't work in a script or shell, so obviously the problem is in mueval
19:19:43 <gwern> LC_ALL=en_US.utf8
19:21:16 <dons> woo http://www.reddit.com/comments/6tm2m/the_fibonacci_numbers_coalgebraicaly_finally/
19:21:17 <lambdabot> Title: The Fibonacci Numbers, Coalgebraicaly (Finally! :-) : reddit.com, http://tinyurl.com/6dwfw8
19:21:19 <gwern> hm. manually pasting it into the Hint example program, it seems to work, so probably not in hint...
19:21:24 <dons> sigfpe finally does a fibonacci post.
19:21:54 <mmorrow> if anyone happens to get motivated to add unicode support to Language.Haskell, imho that person should do it to haskell-src-exts's lexer instead :)
19:23:10 <gwern> > 'Ã±' == 'Ã±'
19:23:11 <lambdabot>  True
19:23:42 <Saizan_> mmorrow: i think it's the same patch.. but you have a point that -exts doesn't need to go through libraries@
19:24:02 <dons> haskell-src patches should be a no-brainer anyway
19:24:08 <dons> but more useful in the -exts lib
19:24:26 <sjanssen> technicaly Unicode operators aren't an extension
19:24:29 <mmorrow> Saizan_: i didn't even think of that benefit, but yesh! ;)
19:24:57 <mmorrow> dons: *way* more useful, as haskell-src-exts prety much can parse/has a rep for all ghc exts (including th)
19:25:38 <mmorrow> over the last few days i added to the TH parsing and as far as i can tell brought it in line with ghc's parser
19:25:59 <mmorrow> (^ haskell-src-exts's _)
19:26:39 <Shiruka> I think that if one would set out to read all the programming literature on computing the fibonacci numbers before implementing a function computing them, one would die of old age before writing a single line of code..
19:27:27 <dons> ensuring that we can parse and build a useful AST, in the style of Language.Haskell, using the ghc-api seems like a good project for someone.
19:27:31 <vixey> yeah I've written thousand line programs that only really compute fibs
19:27:42 <Twey> In C?
19:28:01 <dons> xmonad uses the classic fibonacci function, btw.
19:28:34 <mmorrow> dons: i get the part up to but not including "using the ghc-api". how do you mean?
19:29:04 <dons> bind to ghc-api, and use ghc's lexer and parser
19:29:34 <dons> i.e. wrap the ghc-api library, exposing a Language.Haskell-like interface
19:31:00 <mmorrow> dons: ah, yes. it seems to me it'd be even better if the lexing/parsing could be separated from the ghc-api beast (possibly by extending haskell-src-exts, or extracting ghc's lexer/parser)
19:32:05 <mmorrow> then it would be super lightweight
19:32:26 <dons> i've noticed the ghc-api bindings on hackage are actually pretty easy to build and install, so far. so i wouldn't be too worried about using them. but yes, on a system without ghc, that'll be a larger binary
19:32:49 <sjanssen> won't it be a larger binary with GHC too?
19:32:55 <sjanssen> libraries are statically linked
19:33:05 <mmorrow> that's my impression
19:33:14 <dons> well, stripped though.
19:33:23 <dons> not sure how big the result is. gwern might know.
19:33:31 <gwern> (arggghghhh wtf, why does unicode work fine in the hint examples and cause errors in mueval even when hardwried into the source)
19:34:35 <gwern> mueval is 18M, FWIW
19:34:51 <gwern> stripped
19:35:12 <mmorrow> here's plugs w/ the ghc-api plugins ...
19:35:14 <mmorrow> [m@ganon global]$ cp -f `which plugs` .
19:35:14 <mmorrow> [m@ganon global]$ ls -lh plugs
19:35:14 <mmorrow> -rwxr-xr-x 1 m m 22M 2008-07-26 21:07 plugs
19:35:14 <mmorrow> [m@ganon global]$ strip plugs
19:35:14 <mmorrow> [m@ganon global]$ ls -lh plugs
19:35:15 <mmorrow> -rwxr-xr-x 1 m m 13M 2008-07-26 21:08 plugs
19:35:37 <gwern> but these binaries compress very nicely with upx
19:37:48 <mmorrow> 22M -> 13M stripped
19:38:15 <mmorrow> that surprised me
19:39:37 <mmorrow> well, still.. a binary using haskell-src-exts for parsing is:
19:39:48 <mmorrow> 4.3M -> 2.3M stripped
19:41:34 <pejo> sjanssen, isn't dynamic linking about to show up in a stable ghc soon?
19:43:11 <bd_> pejo: how does that interact with inlining?
19:43:14 <O_4> Hmm, how does GHC know where to search for modules during an import?
19:43:52 <pejo> bd, why would that interact any differently than static linking?
19:44:01 <O_4> I have a module named "GOLBoard" in GOLBoard.hs, in the same dir as Main.hs, but main can't import GOLBoard
19:44:09 <O_4> As it can't be found
19:44:13 <bd_> pejo: because you can replace the dynamic library with one that has a different definition for various functions
19:44:30 <bd_> or indeed, different definitions of non-exported structures
19:44:40 <bd_> if the inlined code manipulated said structures, you have a problem
19:44:44 <gwern> thought ghc didn't do cross-module stuff
19:44:48 <Saizan_> ?where haskell98
19:44:49 <lambdabot> http://haskell.org/onlinereport/
19:44:57 <sjanssen> O_4: are you invoking GHC in the same directory as Main.hs?
19:45:09 <O_4> Yup, though it makes no difference.
19:45:10 <bd_> gwern: It does; that's how things like bytestring fusion are done (inlining + rewrite rules)
19:45:39 <mmorrow> bd_: but ghc doesn't do cross-module optimization, especially if it can't even see the source of one of those modules (ie it's in a dyn lib)
19:45:45 <pejo> bd, true, guess dynamic linking is a pain if you want cross module inlining.
19:45:54 <gwern> goddamnit! mueval was lying to me! the input *is* getting mangled!
19:46:07 <bd_> mmorrow: bytestrings are in a different module than their users; and yet they are inlined
19:46:43 <bd_> heck, try looking at the core for something that uses, say, Prelude.head. It'll be nicely inlined, even though Prelude is a different module
19:47:11 <gwern> may the fleas of a thousand chias infest your beard! May you grow 15 hairlips before your wedding! may your bed be filled with small obnoxious animals! May you know true love, marry, find happiness, and then see your beloved perish of an infected wart! may your favorite foodstuff be found infested by small wriggling white maggots!
19:47:22 <gwern> fscking mueval/ghc api/hint/haskell
19:47:25 <mmorrow> bd_: hmm, possibly i don't understand what you're saying then. what's a concrete example of this problem being a problem?
19:47:51 <bd_> mmorrow: say you have some function  f d = d { SomeInternalField = 42 }
19:47:55 <O_4> sjanssen: *should* it work if I'm in the same dir and it's named as I described?
19:48:02 <bd_> where said internal field is Integer type
19:48:08 <mmorrow> ok
19:48:12 <bd_> put this in a module, build a dynamic library, then link to it and use f
19:48:27 <bd_> now go back to the first module - change the internal field to use an Int
19:48:32 <bd_> rebuild and install this new library
19:48:46 <bd_> 'f' is a trivial function that's likely to be inlined - but it's using the wrong type for the internal field
19:49:18 <bd_> as a result, even though the public API for the module is unchanged, the library is no longer compatible with the executable you built
19:49:24 <mmorrow> well, that's the same as going in and changing all the (eg) readline.so functions to erase your disk or something, right?
19:49:35 <bd_> mmorrow: Not really - the semantics of the API are the same
19:49:40 <bd_> however the implementation changed
19:49:50 <bd_> the problem is that the executable is bound to the implementation - not the interface
19:50:13 <bd_> and thus the main selling point of a dynamic library - that is, the ability to replace the library with a new version without changing users - is no longer usable
19:50:47 <bd_> With C, this is less of a problem, because exactly what is exported to the user is very well defined (don't change existing functions or structures present in the header files)
19:50:55 <pejo> bd, heh, that was the main motivation by Sun. Lets write less buggy software than they did. :-)
19:50:57 <bd_> with C++, it's a bit trickier, but manageable
19:51:24 <bd_> but with functions being inlined unpredictably, this becomes dangerous
19:51:34 <mmorrow> bd_: hmm, i can't think of any retort, but i have to think about it. i'd be amazed though if that is really a problem and no one has thought of it
19:51:37 <bd_> for another example, consider a FFI library of some sort
19:51:44 <O_4> Ugh... sjanssen, I just forgot to use --make
19:51:53 <bd_> it has some function which does a bounds check on an argument - f n | n > something = explode
19:51:54 <O_4> Nevermind :-p
19:52:04 <bd_> but, oops, this is the wrong check, it needs to be >=
19:52:11 <bd_> too bad 'f' was inlined into its callers
19:52:28 <bd_> now some calling points are protected, but others aren't
19:52:46 <bd_> the real solution, of course, is to do the inlining at program load time ;)
19:52:49 <mmorrow> bd_: it seems to me that what you're describing would be an accepted possibility, though (but if i'm correct it's because i guessed right)
19:52:59 <bd_> mmorrow: It can cause random program crashes - that's accepted?
19:53:24 <mmorrow> well, it's "beyond control" and "something that must be taken into account" :)
19:54:00 <bd_> mmorrow: it's not beyond control - for example, you could hash the .hi and embed it into the soname
19:54:12 <mmorrow> "taken into account" :)
19:54:23 <bd_> it makes the dynamic libraries a lot less convenient though
19:54:43 <mmorrow> this is interesting, i'm gonna look at the ghc commentary dynlibs section (i bet this issue is discussed)
19:55:07 * bd_ looks too
19:56:21 <bd_> heh, replacing ld-linux.so is an interesting idea
19:56:26 <bd_> who needs the C library, right?
20:01:26 <gwern> this is driving me nuts. the same exact string to evaluate - and it works in a plain Hint binary, but not in Mueval, and I can't figure out why
20:04:19 <gwern> oh no. no, don't let it be setInstalledModsAreInScopeQualified False
20:05:02 <gwern> shit, it is
20:05:16 <gwern> doesn't that beat all. 'UTF support, or security. Choose 1.'
20:05:42 <vixey> Im' sorry gwern
20:06:00 <gwern> I know what it is - to work around the API bug, hint is writing a module out to a file with the expression embedded in it, and of course, Hint isn't using utf8-string
20:10:57 <vixey> this paper is awesome
20:10:58 <bwr> i am trying to do newton raphson in haskell. i have it working, but i need to tell it when to stop. so right now i am doing last $ take 3000 or so... how can i do something like takeWhile but i need to compare the previous and the current
20:11:03 <bwr> vixey: what paper
20:11:07 <vixey> about implementing logic languages
20:11:16 <bwr> link?
20:11:20 <dons> awesome, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Hipmunk-0.1
20:11:22 <lambdabot> Title: HackageDB: Hipmunk-0.1, http://tinyurl.com/6po7ok
20:11:42 <bwr> dons: that's sounds cool
20:11:44 <bwr> that
20:11:48 <bwr> sigh
20:12:03 <vixey> http://citeseer.ist.psu.edu/83055.html
20:12:03 <lambdabot> Title: A Semi-Functional Implementation of a Higher-Order Logic Programming Language -  ...
20:12:08 <vixey> I've not finished it yet
20:12:36 <O_4> dons: sweet, chipmunk is really neat.
20:13:24 <bwr> so is there something like takeWhile where i can use the previous value as well?
20:13:45 <O_4> Can't you use fold?
20:13:53 <vixey> bwr: there is not
20:14:37 <bwr> O_4: i don't think i can use fold ... because i can't tell it to stop
20:15:03 <O_4> True
20:15:06 <vixey> fold starts ot the wrong end
20:15:17 <O_4> It'll start at either, won't it?
20:15:33 <gnut> why does clean get better scores than haskell at the language shootout?
20:15:34 <bwr> i thought so... i thought that was the diff between foldr and foldl
20:15:40 <O_4> Yeah
20:16:07 <gwern> gnut: uniqueness types allow easier optimization, builtin bytestringalikes, and a decent backend, I think are the reasons
20:16:13 <O_4> In any case, you might just need to write takeWhile :-p
20:16:54 <bwr> yea, i can try that
20:18:08 <vixey> bwr: Are you into LP lang. implementation ?
20:18:11 <dons> gwern: "uniqueness types allow easier optimization" isn't necessarily true. the Clean programs do use a *lot* of unboxed ytpes though.
20:18:19 <dons> which are less common in haskell programs.
20:18:40 <hackage> Uploaded to hackage: HipmunkPlayground 0.1
20:18:40 <hackage> Uploaded to hackage: Hipmunk 0.1
20:18:40 <hackage> Uploaded to hackage: list-extras 0.2.0
20:18:41 <hackage> Uploaded to hackage: Pugs 6.2.13.10
20:18:43 <hackage> Uploaded to hackage: mueval 0.4.6
20:18:43 <gwern> dons: I had understood that monads took a lot of work compared to uniqueness types to optimize
20:19:05 <vixey> I read that somewhere too
20:19:18 <dons> hmm, that doesn't really make sense. uniqueness tells you when you can update things, which is useful, certainly.
20:19:28 <vixey> hackage: URL please?
20:19:50 <gnut> is there a way to cast monads into uniqueness types in the compiler?
20:20:06 <dons> but i think now, primarily, its the rather aggressive data structure transformations used in the clean programs, and their backend.
20:20:14 <bwr> vixey: I have never looked into it. but i am interested in programming languages
20:20:20 <dons> uniqueness isn't the silver bullet of clean, it just is a different bullet.
20:20:26 <vixey> bwr: ok cool
20:20:36 <gnut> ah
20:20:44 <gnut> so it's just that the clean programs were written really well?
20:21:01 <dons> hmm, no. they're lower level.
20:21:04 <dons> look at, say,
20:21:05 <dons>   count_flips :: !Int !*{#Int} !*{#Int} -> (!Int,!*{#Int},!*{#Int})
20:21:19 <dons> that's a pretty stunning amount of data representation annotations.
20:21:20 <gwern> I dunno. the readfile example is really impressive
20:21:25 <dons> we can't even do some of those things in haskell.
20:21:25 <gwern> cleaner and faster than the haskell
20:21:32 <dons> gwern: do you know how it works?
20:21:44 <dons> its quite interesting why it does as well as it does.
20:21:57 <gwern> dons: I once asked you, and you said something along the lines of uniqueness types and builtin bytestringalike
20:22:04 <gwern> *alike-stuff
20:22:05 <dons> hmm, nope.
20:22:14 <dons> :t Data.ByteString.Char8.readInt
20:22:16 <lambdabot> BSC.ByteString -> Maybe (Int, BSC.ByteString)
20:22:31 <dons> note it returns a sum type, maybe failure, or just a pair of the result and a tail.
20:22:56 <dons> the clean program instead does: freadi :: ByteString -> !(Bool, Int, ByteString)
20:23:00 <dons> essentially.
20:23:09 <dons> which exposes the components to the CPR transformation.
20:23:17 <dons> while ghc has to distringuish Nothing from Just
20:23:18 <pejo> dons, I spoke to Rinus about why the Clean compiler performs the way it does. He claimed it was a lot of optmizations possible due to the uniqueness typing.
20:23:55 <dons> maybe that's so. but i think types like, !Int !*{#Int} !*{#Int} -> (!Int,!*{#Int},!*{#Int}) and little "monomorphisations" like freadi :: ByteString -> !(Bool, Int, ByteString) are the main differences now.
20:24:52 <dons> gwern: rewriting bytestrings' readInt to not return a sum, but instead of a product with a Bool tag gives a similar speedup.
20:25:06 <dons> note there's no magic uniqueness in the sum-file program.
20:25:13 <pejo> (I wasn't asking in the context of the shootout, I started by asking whether they do any deforestation and we kind of drifted in to the reasons for the performance).
20:25:16 <dons> while uniqueness (and heavy strictness/unboxing) are common in the other programs.
20:25:32 <gwern> ok, so now Hint is fixed w/r/t utf, as is mueval now
20:25:37 <dons> yeah. a lot of the programs use uniquness to ensure they can get good cache locality, i suspect.
20:25:44 <gwern> now I just wait on Hint's guy to apply and upload
20:25:53 <dons> so not so much a compiler optimisation, but a programmer's ability to reuse space aggressively.
20:25:56 <pejo> dons, in-place updates.
20:28:23 * Saizan_ wonders if there's a testsuite for haskell-src somewhere
20:28:29 <dons> mm. the hipmunkplayground is *awesome*
20:28:57 <ddarius> cabal install hipmunkplayground
20:29:15 <dons> floating clouds, engines, blocks. gravity.
20:30:11 <gwern> does it come with a demo game or anything?
20:30:19 <dons> yeah.
20:30:26 <bwr> woot. takeWhile was a lot easier to extend to take two args than i thought. http://pastebin.com/d6d912b37
20:33:36 <O_4> Damn, I get a "ld: duplicate symbol _deRefStablePtr in /opt/local/lib/ghc-6.8.3/libHSrts.a(Stable.o) and .../.cabal/lib/Hipmunk-0.1/ghc-6.8.3/libHSHipmunk-0.1.a(Space_stub.o)" trying to install hipmunkplayground.
20:34:30 <dons> configure with --enable-split-objs
20:34:32 <dons> http://www.reddit.com/comments/6tm8g/hipmunk_lovely_2d_physics_engine_binding_for/
20:34:34 <lambdabot> Title: Hipmunk: lovely 2D physics engine binding for Haskell : reddit.com, http://tinyurl.com/5t47aj
20:36:02 <ddarius> cabal install worked for me
20:36:09 <ddarius> I need to read a readme or something though
20:36:54 <dons> just click randomly
20:37:10 <ddarius> I did.  I'm just wondering if there is anything else I don't know about.
20:37:28 <O_4> dons: can I just add that to my cabal install command, or do I need to do something more?
20:38:20 <dons> cabal install hipumkblahblha --enable-split-objs
20:38:22 <dons> i think
20:38:37 <dons> or use the arch linux package, http://aur.archlinux.org/packages.php?ID=18659 :)
20:38:38 <lambdabot> Title: AUR (en) - haskell-hipmunk
20:39:25 <ddarius> Looks like that's all there is.
20:40:15 <O_4> Well, I got hipmunk installed, it's hipmunkplayground that won't work (with or without the flag)
20:40:19 <Armored_Azrael> Hey, is there any show/read-like typeclass, only based on compressed storage formats rather than human readable ones?
20:40:28 <O_4> But I've played with chipmunk before, I can handle missing one dome :-p
20:40:30 <O_4> demo
20:41:01 <gwern> Armored_Azrael: data.binary maybe
20:41:13 <dons> O_4: with the flag, the linker error goes away for me, and it works.
20:42:09 <O_4> Hmm, it doesn't go away for me with the flag.
20:42:12 <Shiruka> in ghc core there are sometimes special characters not part of the syntax (i.e. they're just part of the identifiers), such as $
20:42:26 <Shiruka> do they have anything to do with operators? like $ with ($)
20:42:46 <geezusfreeek> yay, chipmunk bindings!
20:43:11 * geezusfreeek scratches it off his list of things to make bindings for
20:43:45 <dons> let's write some games!
20:44:00 <dons> actually, want i want to do is display a graph of library dependencies taken from hackage.
20:44:06 <dons> show what's using what, and what the core of hackage is.
20:44:35 <gwern> sounds like a job for tagsoup
20:44:40 <dons> bah.
20:44:51 <dons> download the tarball and read the dependencies with cabal
20:44:56 <dons> then render the graph to dot
20:45:04 <dons> we have a graphviz binding too, now, no?
20:45:21 <dons> a graph with cute 2D physics might be fun though..
20:45:28 <O_4> Heh
20:45:43 <ddarius> dons: Data.Graph.Inductive has been able to produce .dot output the whole time.
20:45:47 <dons> sweet, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/graphviz-2008.7.11
20:45:49 <lambdabot> Title: HackageDB: graphviz-2008.7.11, http://tinyurl.com/6eahrx
20:46:08 <gwern> it's a good idea. I'd look into doing it, but I'm really exhausted from mueval
20:46:12 <Shiruka> use the physics lib to simulate springs and that to implement graph layout algo :-P
20:46:21 <gwern> what a stupid bug, and it's all ghc's fault
20:46:22 <dons> gwern: i'll have a crack, as we say in .au
20:46:40 <dons> Shiruka: and weight the nodes by their lines of code :)
20:46:59 <gwern> if it didn't have IO routines broken with UTF, or if it didn't have broken imports in the GHC API, it wouldn't've happened
20:48:22 <dons> so traverse the package graph, and emit a hipmunk program
20:48:39 <dons> translate that to javascript and expose it through a web service built on happs.
20:48:48 <dons> == profit and awesome.
20:49:26 <Shiruka> with the profit part being somewhat questionable..
20:49:40 <geezusfreeek> but the awesome part being fairly certain
20:50:05 <Twey> Hehe
20:50:21 <Elly> a new Thoushaltnot EP is fine too
20:50:59 <Saizan_> anyone has an haskell module full of unicode so i can test it against my haskell-src?
20:51:08 * Saizan_ looks at vixey 
20:53:25 <Armored_Azrael> How does one make a typeclass derivable?
20:54:17 <vixey> yeah I got some
20:54:52 <dons> profit is a metaphor :)
20:55:31 <Elly> for huge piles of cash in the currency of your choice
20:55:34 <vixey> http://rascal-haskell.googlecode.com/ Infer and Typecheck use some unicode operators
20:55:35 <lambdabot> Title: rascal-haskell - Google Code
20:55:56 <Saizan_> vixey: thnaks
21:06:51 <Armored_Azrael> Or is it only possible with dark magic?
21:07:36 <ddarius> Hack GHC.
21:07:50 <ddarius> Or the implementation of your choice.
21:10:15 <Armored_Azrael> ddarius: So it is not possible to make a library that provides this? (even just to GHC)
21:11:38 <Armored_Azrael> (of course this would likely require C code and the like, but I'm mostly wondering if it's possible to make it work without having to give people a custom comiler)
21:11:47 <Armored_Azrael> ï»¿ddarius: Also, are there any plans to make this available in the language itself?
21:11:53 <mmorrow> Saizan_: i have a perfect toy unicode (short) module
21:11:58 * mmorrow gets it
21:12:29 <sjanssen> Armored_Azrael: you can make automatically write instances with TH
21:12:42 <sjanssen> the syntax is not as nice, and it isn't portable, but you can do it
21:13:04 <rwbarton> Armored_Azrael: see the "derive" package on hackage
21:15:07 <vixey> @hackage derive
21:15:08 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive
21:15:49 <Armored_Azrael> Oh awesome, they already did what I was going to (I was going to make a deriving clause work for the Binary typeclass)
21:16:04 <Saizan_> mmorrow: nice :), so far it works
21:16:08 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/Set.hs
21:17:40 <mmorrow> Saizan_: whoa, so you've *already* patched haskell-src's lexer for unicode!?
21:17:41 <vixey> wow f :: âˆ€a. a â†’ a is valid haskell? I didn't know that
21:18:06 <mmorrow> when that module actually loaded in ghci i was stunned
21:18:41 <mmorrow> oop, forgot the "where" after "module Set" (i just added the module line)
21:19:17 <mmorrow> ok, fixed (not that it wasn't trivial): http://code.haskell.org/~morrow/code/haskell/misc/Set.hs
21:21:37 <Saizan_> it doesn't support fancy things like  f :: âˆ€a. a â†’ a, only unicode symbols and letters in identifiers
21:22:09 <Saizan_> is âˆ€ haskell98 or an extension?
21:22:18 <mmorrow> cool.
21:22:22 <mmorrow> uh, i'm not sure
21:22:38 <mmorrow> does it handle type (â„¤) = Integer , etc
21:22:39 <mmorrow> ?
21:23:26 <mmorrow> also notice the â‡’ and â†’
21:23:51 <mmorrow> there are some pretty sweet unicode arrows
21:24:15 <Saizan_> btw, repo _> http://code.haskell.org/~Saizan/haskell-src
21:24:16 <lambdabot> Title: Index of /~Saizan/haskell-src
21:24:35 <mmorrow> Saizan_: awesome, nice work
21:24:39 * mmorrow darcs gets
21:26:36 <sjanssen> Saizan_: forall isn't even in Haskell '98
21:27:15 <Saizan_> sjanssen: right
21:27:32 <mmorrow> some unicode arrows:    â†º     â†    â†¯    â†·
21:27:46 <Saizan_> and in fact ghc doesn't parse it without -fglasgow-exts
21:28:05 <mmorrow> ah yeah, i have that in my .ghci
21:28:11 <mmorrow> i always forget that
21:31:01 <geezusfreeek> is there a reason that there is no monad instance for Monoid a => ((,) a) in standard libs? there is one for applicative.
21:33:03 * vixey tries to think of meanings for â†º
21:33:21 <chrisdone> haha
21:33:25 <glguy> fix!
21:33:26 <chrisdone> repeat?
21:33:27 <geezusfreeek> fix
21:33:29 <chrisdone> fix!
21:34:05 <geezusfreeek> go in circles!
21:34:35 <rwbarton> newtype â†º a = a â†’ a?
21:35:22 <vixey> (â†º) = mod
21:35:34 <Saizan_> geezusfreeek: i think there's a thread on libraries@ where conal proposed that addition, iirc
21:35:41 <chrisdone> is anyone else's âˆ€ pixelated on Monospace font? I need another font that supports as much unicode
21:36:03 <chrisdone> like, all my unicode chars are antialiased and lovely, and then âˆ€ isn't @_@
21:36:26 <chrisdone> :t mod
21:36:29 <geezusfreeek> newtype s â†º a = InF (s a (s â†º a)
21:36:31 <lambdabot> forall a. (Integral a) => a -> a -> a
21:36:45 <chrisdone> > mod 10 3
21:36:50 <lambdabot>  1
21:37:36 <geezusfreeek> Saizan_: conal always beats me to the chase!
21:40:40 <chrisdone> ah, looks okay on Monaco
21:40:56 <codacola> whats the ^M character meant to be?
21:41:06 <chrisdone> huh?
21:41:20 <shepheb> argh I can't have an IArray of lists? I thought they were boxed.
21:41:24 <Saizan_> geezusfreeek: but it was some time ago, so i think it ended with nothing done :\
21:42:05 <codacola> chrisdone: i saved something with gedit, now every line ends with "^M" (accoridng to vim)
21:42:22 <TSC> codacola: It's a carriage return
21:42:27 <chrisdone> codacola: is that \r?
21:43:12 <chrisdone> codacola: that is, \r is "return", \n is "line feed", windows typically has \r\n newlines, unix just \n
21:43:29 <Saizan_> shepheb: you should be able to, if you don't use UArray
21:43:54 <codacola> ah that explains it
21:44:00 <shepheb> I've got another type error, let me sort it first, maybe the other will go away.
21:44:05 <codacola> was wondering what m could stand for :P
21:44:35 <TSC> It doesn't stand for anything (except 13)
21:44:41 <chrisdone> codacola: yeah, I dunno about that
21:45:08 <TSC> Carriage return is ASCII 13; M is the 13th letter of the alphabet
21:45:08 <Saizan_> ?ty Data.Array.IArray.array (0,0) [(0,[1])] :: Array Int [Int]
21:45:09 <lambdabot> Array Int [Int]
21:45:44 <shepheb> yeah, I'm getting "No instance for (IArray a [Int]), so it seems it can't resolve the index type.
21:46:23 <chrisdone> Saizan_: you added unicode support to the haskell parser?
21:46:29 <shepheb> okay, specifying didn't help. odd.
21:46:30 <chrisdone> Saizan_: er, utf-8 support?
21:46:44 <rwbarton> shepheb: are you confusing Array and IArray?
21:46:48 <rwbarton> (IArray is a type class)
21:46:54 <shepheb> got it that time.
21:47:02 <shepheb> it was a combination of that, yes.
21:47:10 <mmorrow> vixey: and then you've got:  â†º    â†»      â†¶      â†·       â‡„       â‡†       â‡‰        â‡‡     â†«      â†¬      â†©    â†ª
21:47:19 <chrisdone> mmorrow: haha, win
21:47:29 <mmorrow> sweet!
21:48:10 <Saizan_> chrisdone: unicode support in operators for Language.Haskell.Parser
21:48:14 <b\6> is everything in hackage in darcs? i keep wanting to check out the sources instead of downloading some tgz.
21:48:39 <mmorrow> > ord 'âˆ€'
21:48:42 <lambdabot>  8704
21:48:58 <chrisdone> Saizan_: does that mean Î»b can support them now?
21:48:58 <Saizan_> chrisdone: you still have to decode utf8 separately and feed Unicode codepoints to parseModule
21:49:18 <mmorrow> chrisdone: hmm, i'm not sure, because:
21:49:20 <chrisdone> Saizan_: I see
21:49:22 <mmorrow> > ord '\8704'
21:49:23 <lambdabot>  8704
21:49:24 <Saizan_> chrisdone: if we rebuild against this version yes
21:49:26 <dolio> chrisdone: My unicode used to be nicely antialiased in emacs, but then an update caused âˆ€ and a bunch of others to look terrible.
21:49:43 <dolio> And I think I lost some characters, too (they're boxes now).
21:49:51 <Saizan_> now i've to mail teh patch libraries@ and get it accepted..
21:49:57 <chrisdone> dolio: right! my monospace is.. Dejavu Sans Mono?
21:49:57 <Saizan_> +to
21:49:59 <mmorrow> dolio: sucky
21:50:00 <chrisdone> Saizan_: cool!!
21:50:34 <dolio> chrisdone: Yeah, that's what I use in emacs. I don't know what it uses for those characters, but whatever it is, it's bad.
21:50:47 <chrisdone> dolio: did you switch to Monaco? doing that makes the forall âˆ€ look right
21:51:00 <dolio> I think it used to be pulling from multiple fonts, but isn't anymore.
21:51:00 <mmorrow> > let f :: âˆ€a. a â†’ a = id in (f id) 42
21:51:01 <lambdabot>  Illegal character ''\8704''
21:51:01 <lambdabot>  at "
21:51:04 <mmorrow> ahh!
21:51:23 <chrisdone> dolio: yeah, I use Emacs from gnome-terminal so mine's just one font Â·_Â·
21:52:06 <chrisdone> hey emma do I recognise you from #scheme a while back?
21:52:38 <chrisdone> mmorrow: should that have worked?
21:53:21 <dino-> b\6: Some things are here: http://darcs.haskell.org/
21:53:22 <lambdabot> Title: Index of /
21:53:49 <b\6> dino-: yeah, but seems incomplete.
21:54:10 <b\6> wish everything were there.
21:54:54 <dino-> I think it's just that some projects' darcs repos are hosted there. Somebody correct me if that's wrong.
21:55:47 <hml> is there anyway to permute a haskell list in O(k) time, where k is the number of 'steps' taken? i.e. 1, 2, 3, 4, 5 -> 2, 3, 4, 5, 1 is a single stpe
21:55:48 <b\6> seems that way.
21:58:09 <gwern> b\6: many things on hackage live on code.haskell.org, but many do not; many don't have even public darcs repos
22:00:57 <rwbarton> hml: depending on what you are really trying to do, you may find cycle and drop useful
22:02:50 <mmorrow> here's a simple start at translating symbols in (non-expression-context) hs source from unicode:
22:02:51 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/UnUnicode.hs
22:03:15 <mmorrow> chrisdone: i guess not ;)
22:03:31 <paczesiowa> why "let (x,y) = (id,id)" results in x of type GHC.Prim.Any -> GHC.Prim.Any but "let x = fst (id,id)" results in correct type?
22:05:37 <mmorrow> paczesiowa: maybe some sort of weird ghc defaulting?
22:06:14 <paczesiowa> doesn't defaulting work only for numbers?
22:07:01 <chrisdone> mmorrow: maybe [c] id (lookup c charMap) -- maybe you've heard of fromMaybe which = flip maybe id ^_<
22:07:36 <chrisdone> mmorrow: (yeah, I'm not sure why fromMaybe exists either)
22:08:34 <chrisdone> mmorrow: btw, that code -- supposed to be ran just before sending to ghc, like preprocessed?
22:09:46 <mmorrow> chrisdone: totally.,that's what i'm shooting for
22:10:06 <chrisdone> mmorrow: sounds like a good idea?
22:10:29 <mmorrow> i dunno. sounds possible though ;)
22:10:29 <codacola> im confused. Instance of Num [Char] required for definition of createWhiteLine, what exactly does it mean?
22:11:02 <sjanssen> codacola: you're attempting to perform math operations on a String
22:11:04 <dons> codacola: you're using a string where a number is expected.
22:11:06 <geezusfreeek> codacola: you are trying to apply a function to something of type [Char] that is defined for numbers
22:11:19 <mmorrow> chrisdone: yeah, i used fromMaybe briefly before i discovered how excellent maybe is
22:11:22 <chrisdone> mmorrow: I presume doing that, all you'd need to do is just ignore characters inside " and ', and that would safely do most files?
22:11:23 <dons> > "foo" + 1
22:11:24 <geezusfreeek> yay for overly helpful haskellers
22:11:28 <lambdabot>   add an instance declaration for (Num [Char])
22:11:40 <O_4> Does anyone know how to use the GHC profiler?  Adding -prof to the compile flags generates an error (can't find GLUT module... wtf??), and adding +RTS -p -RTS to my executable flags just prints out a help message and exits.
22:11:43 <rwbarton> Non-exactly, it means "Couldn't match [Char] against Integer"
22:11:50 <mmorrow> chrisdone: also, this is legal:
22:11:52 <dons> O_4: ghc -prof -auto-all
22:11:58 <mmorrow> (âˆ€) = "forall"
22:12:03 <dons> O_4: but you need the libraries to also have been compiled for profiling.
22:12:05 <geezusfreeek> O_4: all your libraries have to be compiled with profiling
22:12:07 <sjanssen> O_4: that means GLUT was not built for profiling (some Linux distros keep this in a separate package)
22:12:13 <O_4> Damn
22:12:20 <geezusfreeek> cabal install GLUT -p, i think
22:12:28 <mmorrow> chrisdone: you'd have to parse the source, then only do the substitution  in contexts where it's valid
22:12:37 <O_4> geezusfreeek: I'll try that
22:12:51 <chrisdone> mmorrow: oh, I see. is it easy to parse haskell source with the haskell-src library?
22:12:51 <sjanssen> dons, geezusfreeek, and I are on the same wavelength tonight :)
22:13:27 <O_4> Hmm, cabal didn't install anything
22:13:46 <sjanssen> O_4: configure with --enable-library-profiling, rebuild and reinstall
22:13:51 <mmorrow> chrisdone: yeah, even better (since it parses now-haskell, not just haskell98) is haskell-src-exts
22:14:00 <geezusfreeek> O_4: what did it do?
22:14:12 <chrisdone> mmorrow: is that a parser for ghc extensions?
22:14:20 <chrisdone> mmorrow: well, ghc-extended source code?
22:14:20 <O_4> geezusfreeek: printed "resolving dependencies" and quit
22:14:36 <mmorrow> it's haskell-src, but with extensions added to both the syntax tree and the parser
22:14:40 <codacola> http://mibbit.com/pb/GdfOxQ <- thats the function
22:14:41 <lambdabot> Title: Mibbit: PasteBin
22:14:44 <geezusfreeek> oh. it has done that to me before too. for some reason it consistently does that for some libs. i haven't bothered tracking it down yet
22:15:00 <geezusfreeek> you will just have to get the tarball and do it yourself i guess :\
22:15:02 <dons> sjanssen: and that wavelength is given by Î» = v / f
22:15:06 <mmorrow> chrisdone: (eg template-haskell, arrow notation, GADTs, implicit params, ...)
22:15:20 <chrisdone> mmorrow: omfg
22:15:32 <chrisdone> mmorrow: does ghc use this library to do its parsing?
22:16:08 <geezusfreeek> codacola: i supposed you actually meant to do createWhiteLine (n - 1)
22:16:15 <geezusfreeek> that would be your problem
22:16:27 <mmorrow> chrisdone: ghc uses its own parser, but haskell-src-exts is pretty much there
22:16:32 <geezusfreeek> what it is doing right now is applying createWhiteLine to n and then subtracting 1 from the result
22:16:47 <geezusfreeek> and since (-) is defined for Nums, there's your error
22:16:47 <chrisdone> mmorrow: well, let me bring my browser into this (XMonad--plugged!!) workspace, and actually look at the pages about these libraries â€œ._.
22:17:01 <chrisdone> mmorrow: ah, cools
22:17:02 <mmorrow> chrisdone: check out hstidy for an example: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hstidy
22:17:02 <lambdabot> Title: HackageDB: hstidy-0.2
22:17:13 <chrisdone> mmorrow: thankies ^_^
22:17:15 <codacola> oh heh, oops
22:18:49 <jberryman> trying to understand how to at least USE random numbers. when using 'generate' in Test.QuickCheck what generator could you supply instead of mkStdGen? I don't why the example given here is better/different than randomR:
22:18:53 <jberryman> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms#Using_QuickCheck_to_Generate_Random_Data
22:18:56 <lambdabot> http://tinyurl.com/2fpup7
22:19:47 <chrisdone> mmorrow: small code!
22:20:02 <mmorrow> chrisdone: also, here's a cgi program that uses haskell-src-exts's parser+AST and derive show for GADTs:
22:20:07 <mmorrow> http://morrow.jypsis.com/cgi-bin/gadtshow.cgi
22:20:12 <lambdabot> Title: GADT Show
22:20:13 <chrisdone> shibby
22:20:34 <mmorrow> chrisdone: yeah totally, imagine another hour of work put into hstidy
22:20:38 * mmorrow drools
22:20:54 <chrisdone> mmorrow: very clever
22:21:05 <mmorrow> s/and/to/
22:21:07 <mmorrow> :)
22:22:53 <chrisdone> looking at this hstidy code
22:24:30 <b\6> hstidy for ensuring compliance with formatting standards?
22:26:15 <mmorrow> i want to add the ability to specify the prettyprinting parameters for rendering the src
22:26:16 <chrisdone> assumedly for tidying up code after hacking on it quickly and messily
22:26:52 <mmorrow> then it could be used to ensure compliance with some predetermined formatting spec, to tidy jacked up code, whatever
22:27:04 <mmorrow> (well, it already can be used to tidy jacked up code)
22:27:20 <chrisdone> yeah that would be good
22:27:30 <gwern> does hstidy really clean up code?
22:27:49 <mmorrow> gwern: yeah, it parses it with haskell-src-exts, then prettyPrints it
22:27:50 <chrisdone> it uses import Language.Haskell.Exts.Pretty
22:27:54 <chrisdone> it MUST be pretty, at least
22:29:01 <gwern> mmorrow: no, I mean is there much aesthetic improvement, not whether it does what it claims to do
22:29:06 <chrisdone> using this haskell-src could be cool for â€œintellisenseâ€... !
22:29:32 <mmorrow> i've got a ton of related code in a package i've just about got hackage-ready that has a bunch more hstidyish things, as well as a haskell quasiquoter, a monad that's an instance of Quasi that uses hs-plugins to be able to dynamically reify stuff, and other random things
22:30:03 <chrisdone> what does â€œreifyâ€ mean?
22:30:37 <mmorrow> gwern: well, if you're tidying code that is already (subjectively) tidy, then it's subjective :). but if you're tidying obfuscated code, or a module all on one line (assuming this parses), then yes!
22:30:38 <gwern> 'cat .xmonad/xmonad.hs | hstidy' <-- this should work, right?
22:30:59 <mmorrow> one of my favorites is:
22:31:26 <mmorrow> cat A.hs | hstidy | HsColour -html > A.html && firefox A.html
22:31:46 <mmorrow> (it strips all comments and makes the formatting *uniform*)
22:32:03 <b\6> probably better to hstidy < blah.hs
22:32:08 <gwern> dunno, hstidy doesn't seem to work on my xmonad.hs
22:32:29 <gwern> b\6: I like my useless use of cat, thank you very much
22:32:34 <mmorrow> does it have #define s/etc in it
22:32:35 <mmorrow> ?
22:32:47 <mmorrow> (you've gotta cpp it if it does)
22:32:58 <mmorrow> or sed it or whatever
22:33:14 <gwern> no, no CPP
22:33:29 <mmorrow> hmm, can you paste your xmonad.hs?
22:33:30 <gwern> there are one or tw {- -} cmments, but that's the most exotic thing
22:33:34 <chrisdone> you know that bit that appears at the bottom in emacs when your caret is over a symbol and it shows the type; has anyone got that working for things defined in the file, or other modules, etc.?
22:33:35 <Shiruka> chrisdone: doesn't it just mean giving something a name to refer to it?
22:33:53 <chrisdone> shiruka: I don't know, never heard the word
22:34:12 <mmorrow> gwern: it spits out a line number with the parse error msg, does that narrow it down?
22:34:48 <gwern> looks like it doesn't like 'import Data.Map as M (M.fromList, M.union, Map())'
22:35:35 <mmorrow> hmm, if that's true i'll fix it in haskell-src-exts (i already have a couple of things i've fixed/added in it)
22:35:36 <sjanssen> mmorrow: hstidy uses the pretty printer from haskell-src-exts?
22:35:40 <mmorrow> yes
22:36:05 <sjanssen> it'd be nice to have newlines between top-level declarations
22:36:21 <chrisdone> sjanssen: agreed there!
22:36:21 <mmorrow> i want to add to hstidy the ability to specify the params that the prettyPrintWith_ function takes from the command line
22:36:45 <sjanssen> mmorrow: you should add the ability to format code the way I like it :)
22:37:03 <mmorrow> sjanssen: cool. also, maybe the pretty printer itself in haskell-src-exts should be hacked somewhat
22:37:28 <mmorrow> sjanssen: lol. but seriously, what would be ideal.
22:37:45 <sjanssen> mmorrow: I'm basically just whining
22:37:58 <sjanssen> it choses a reasonable style, but not one that I'd use
22:38:08 <chrisdone> personally I like my haskell code to read like one big-ass where clause; foo = bar where bar = mu where mu = ..., in a more top-down approach like a newsgroup, rather than this weird â€œreverse newsgroupâ€ where there is zot = ..., boo = zot, ... stuff, and certainly it is better than randomly placed declarations
22:38:36 <sjanssen> "c{modMask = mod1Mask}", is a bit weird though.  mmorrow, do you think there should be a space after c?
22:38:46 <chrisdone> actually the newsgroup analogy fails, ignore that
22:38:54 <mmorrow> sjanssen: whine away. i think with well chosen params to the prettyPrinter, it could cover 90% of (reasonable) formatting styles
22:38:58 * gwern is still waiting for hpaste to upload...
22:39:19 <mmorrow> yeah, i tried to paste something about 30min ago and it never finished pasting
22:39:25 <mmorrow> (so i killed it)
22:39:34 <chrisdone> http://paste.lisp.org/ with haskell highlighting?
22:40:06 <sjanssen> glguy: we have reports that uploads to hpaste are busted
22:40:42 <chrisdone> also reports that hpaste is not in here. I can confirm that
22:42:34 <mmorrow> sjanssen: ha, i have that crisis every time i use record syntax. i've just recently decided to go with no space (in my own code)
22:42:46 <pastorn> could someone dcc me all_about_monads.pdf?
22:43:17 <chrisdone> pastorn: http://horna.org.ua/books/All_About_Monads.pdf ???
22:43:19 <lambdabot> Title: cache:http://horna.org.ua/books/All_About_Monads.pdf - Google Search
22:43:37 <mmorrow> sjanssen: also, hstidy just uses the default prettyprinting params that whoever happened to code the defaults put in there
22:44:28 <gwern> mmorrow: well, the hstidy error is 'SrcLoc {srcFilename = "<unknown>.hs", srcLine = 4, srcColumn = 23}', and the file is http://haskell.org/haskellwiki/?title=Xmonad/Config_archive/Gwern's_Config.hs&oldid=21957
22:44:30 <lambdabot> Title: Xmonad/Config archive/Gwern's Config.hs - HaskellWiki, http://tinyurl.com/69tr2y
22:44:55 * mmorrow sees if he can figure it out
22:45:17 <barbaria2hero> can anyone tell me why I might be getting this error when trying to build a package
22:45:21 <barbaria2hero>    unknown flags in  {-# OPTIONS #-} pragma: -XTypeOperators -XRank2Types -XFlexibleContexts
22:45:43 <mmorrow> at first glance, i think it's that you do      import Data.Map as M (M.fromList, M.union, Map())          instead of           import Data.Map as M (fromList, union, Map())
22:45:50 <gwern> don't they need commas?
22:45:59 <mmorrow> (i didn't even know what you did was legal)
22:46:10 <mmorrow> i'll put that on the list of things to add the haskell-src-exts
22:46:10 <gwern> mmorrow: they seem to be equivalent in terms of functionality
22:46:15 * gwern shrugs. it compiles fine
22:46:30 <mmorrow> yeah, haskell-src-exts must just not handle that
22:47:22 <gwern> mmorrow: fwiw, the most recent one is http://haskell.org/haskellwiki/Xmonad/Config_archive/Gwern's_Config.hs which generates the error SrcLoc {srcFilename = "<unknown>.hs", srcLine = 15, srcColumn = 55}
22:47:23 <lambdabot> Title: Xmonad/Config archive/Gwern's Config.hs - HaskellWiki, http://tinyurl.com/5z3x88
22:49:31 <mmorrow> gwern: ok, i got it. weird, the (|||) seems to be giving it the problem
22:49:57 <mmorrow> change it to:     import XMonad.Layout (Full(..), Mirror(..), Tall(..)) --, (|||))          and it worked for me
22:50:05 <gwern> yay, I've uncovered two bugs in src-exts
22:50:11 <gwern> a productive day already!
22:50:13 <mmorrow> nice!
22:50:22 <chrisdone> anyone ever tried shared screen session? I was sharing an emacs session with jpcooper before, working on a simple FastCGI program. very very fun!
22:50:25 * gwern delegates reporting them to mmorrow 
22:50:38 <mmorrow> i accept, i'll even try to fix them
22:50:46 <gwern> chrisdone: I did once. was nice, although multiple cursors would've made it even better
22:50:52 <Saizan_> oh, so i'm not the only one that has noticed a problem with '|' in .Exts?
22:51:01 <chrisdone> gwern: haha, oh wow. that would rock
22:51:20 <pastorn> chrisdone: thanks for all_about_monads.pdf
22:51:26 <chrisdone> pastorn: sure
22:51:32 <barbaria2hero> might not ghc 6.6.1 support the -XTypeOperators -XRank2Types -XFlexibleContexts flags?
22:51:43 <gwern> chrisdone: unfortunately, I'm only aware of gobby in the shared-editor, multiple cursor department; there were some musings about making yi understand gobby
22:52:02 <gwern> barbaria2hero: I thought the split out extensions were 6.8, along with the LANGUAGE pragma
22:52:04 <barbaria2hero> (trying to build hmatrix 0.400 btw)
22:52:04 <chrisdone> gwern: gets kind of annoying saying "give me the cursor" (we were talking on Skype)
22:52:12 <barbaria2hero> gwern: ok that could be it then
22:52:16 <chrisdone> gwern: yeah, I remember that
22:53:14 <Saizan_> mmorrow: ahah, RPGuardOpen and RPGuardClose conflict with things like (||)
22:55:09 <gaze__> hey guys
22:55:12 <mmorrow> Saizan_: interesting. since you're into this i'll put my version of haskell-src-exts (w/ better TH support, basic QuasiQuote support) somewhere and link you to it, gimme a minute
22:55:13 <chrisdone> hai
23:02:06 <Saizan_> mmorrow: heh, ok, i've never used Harp, so i'm not well suited to fix this, but it also seems like most of harp code is commented out
23:02:54 <gaze__> is there a convenient way to duplicate data structures? memcpy style? Sorry I'm from a very imperative background...
23:03:15 <gaze__> data.bytestring's copy looks nice for that type
23:03:19 <bd_> gaze__: The data structure is immutable - why would you need to copy it?
23:04:24 <bd_> (if it's not immutable, then you're dealing with something too complex to be memcpy-style copied already)
23:04:49 <gaze__> alright I'm totally backwards...
23:05:03 <bd_> so, what are you really trying to do? :)
23:05:47 <gaze__> sudoku solver :-P. 9x9 grid of potential square value lists
23:06:12 <TSC> You want to duplicate the grid for branching?
23:06:20 <gaze__> right.
23:06:30 <TSC> Just "change" it
23:06:42 <TSC> And the old version will stick around
23:07:04 <gaze__> what do you mean?
23:07:06 <bd_> All haskell operations on ordinary data structures have copy semantics :)
23:07:12 <TSC> > let x = [1..10], y = delete 5 x in (x,y)
23:07:12 <lambdabot>  Parse error at "," (column 16)
23:07:23 <bd_> TSC: semicolon
23:07:26 <TSC> > let { x = [1..10];y = delete 5 x} in (x,y)
23:07:31 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,6,7,8,9,10])
23:07:46 <TSC> So, "deleting" 5 from x doesn't actually mutate x
23:08:01 <TSC> It creates a new list to construct y
23:08:26 <gaze__> ohhhh! hahah... so that's how they're immutable
23:08:37 <TSC> Right
23:08:58 <bd_> note that the compiler is free to secretly mutate it in-place if it can prove you can't possibly notice the fact
23:09:05 <bd_> eg:
23:09:08 <bd_> > delete 5 [1..10]
23:09:09 <lambdabot>  [1,2,3,4,6,7,8,9,10]
23:09:18 <bd_> Was [1..10] modified in place? That's an implementation detail :)
23:09:25 <bd_> (secretly, [1..10] never existed)
23:10:05 <mmorrow> Saizan_: yeah, i've just been ignoring all the harp/hsx stuff
23:10:21 <mmorrow> (almost up)
23:10:28 <gaze__> right... does haskell actually duplicate, or does y become sort of a thunk for [1..10]-5?
23:10:43 <TSC> At first it would be a thunk
23:10:50 <TSC> And it would probably be created on demand
23:11:08 <TSC> But the language leaves much of it free to the implementation
23:11:37 <gaze__> prolly makes garbage collection super effective
23:14:07 <chrisdone> wb dolio
23:14:07 <geezusfreeek> > delete 1000 [1..]
23:14:22 <lambdabot>  thread killed
23:14:32 <geezusfreeek> uh...
23:14:34 <TSC> > delete 1000 [1..]
23:14:36 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:14:44 <TSC> It gets confused sometimes
23:14:49 <geezusfreeek> i guess that was just one of those random screwups
23:15:16 <chrisdone> aftermath radiation from Y2K
23:15:18 <bd_> gaze__: The answer to your question is 'it depends' :)
23:15:45 <bd_> gaze__: If you just put 'delete 5 [1..10]' in a file, it's possible that [1..10] will never be constructed, and the delete would be folded right into the generation loop
23:16:08 <bd_> or rather, if you do something like print (delete 5 [1..10]) it'd become some kind of tight loop with just a term to skip 5
23:16:25 <bd_> (unless delete doesn't do list fusion, in which case ignore me)
23:16:46 <chrisdone> it'd be cool if there were postfix operators, hehe. then you could have 2Â² for "square 2"
23:16:50 <bd_> if it's unable to do this, then delete 5 [1..10] in general would produce a thunk,which can be forced to produce (1:thunk) etc
23:17:04 <chrisdone> 2!, etc.
23:17:09 <bd_> chrisdone: you can if you put parenthesis around ti
23:17:20 <bd_> > let (***) n = n * n in (2***)
23:17:28 * bd_ waits
23:17:36 <lambdabot>  thread killed
23:17:36 <bd_> @botsnack
23:17:36 <rwbarton> thread killed
23:17:36 <lambdabot> :)
23:17:43 <bd_> > let (***) n = n * n in (2***)
23:17:47 <lambdabot>  4
23:17:56 <chrisdone> > let n (Â²) = n * n in (2Â²)
23:17:56 <geezusfreeek> @yow
23:17:56 <lambdabot>  Illegal character ''\178''
23:17:56 <lambdabot>  at "²)" (column 8)
23:17:56 <lambdabot> Couldn't find fortune file
23:18:08 <chrisdone> > let (Â²) n = n * n in (2Â²)
23:18:08 <lambdabot>  Illegal character ''\178''
23:18:08 <lambdabot>  at "²)" (column 6)
23:18:09 <bd_> > take 10 (delete 9000000 [1..])
23:18:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:18:12 <chrisdone> ;___;
23:18:20 <codacola> curious for peoples opinions. do people here find working in haskell changes their approch to problems when they use another language?
23:18:20 <bd_> gaze__: ^^ an example of laziness in delete :)
23:18:36 <Zao> codacola: Somewhat for C++.
23:18:44 <gaze__> codacola: Yeah.
23:18:47 <codacola> Zao: as well as C?
23:18:53 <Zao> I don't code in C.
23:18:59 <Zao> It's pointless.
23:19:15 <chrisdone> yay works in ghci
23:19:16 <gaze__> codacola: lisp/scheme, verlog, and haskell have all been mindfucks, since I'm mostly a C/Assembly guy
23:19:16 <chrisdone> Prelude> let (Â²) n = n*n in (2Â²)
23:19:17 <chrisdone> 4
23:19:21 <gaze__> *verilog
23:19:27 <chrisdone> bd_: that's so cool ^_^
23:20:04 <codacola> gaze__: ah, im asking since when i started this class we were told using a functional language will do exactly that. though havent used any other languages in a few months now
23:20:21 <ddarius> gaze__: You need to learn some Prolog and Smalltalk and J.
23:20:32 <bd_> chrisdone: the () are needed though :/
23:20:35 <codacola> heh, prolog is the next one i have to learn
23:21:05 <chrisdone> bd_: is that fact likely to remain?
23:21:12 <codacola> and gotta use c# for the next few months :(
23:21:13 <mmorrow> Saizan_: ok, it's at http://code.haskell.org/~morrow/code/haskell/haskell-src-exts-metaquote/
23:21:14 <lambdabot> Title: Index of /~morrow/code/haskell/haskell-src-exts-metaquote, http://tinyurl.com/5dupna
23:21:15 <bd_> chrisdone: Probably.
23:21:18 <Twey> Heh, why J, ddarius?
23:21:26 <chrisdone> bd_: ah well. it's pretty cool anyway
23:21:28 <chrisdone> J is awesome
23:21:34 <gaze__> yes!! J is sick
23:21:43 <codacola> ive never heard of j
23:21:45 <mmorrow> Saizan_: so i've also put instances of Binary + misc stuff i generated with derive in there
23:21:45 <bd_> chrisdone: It's an abuse of operator slicing - if you were to allow it without parenthesis, what's to say + can't be a valid expression in and of itself?
23:21:52 <bd_> and if so what's the semantics of + + + + + + + ?
23:21:58 <Zao> J is for people who think golfed Perl is too readable.
23:21:59 <ddarius> Twey that reminds me. gaze__: Add one (or more) of Joy, Forth or Factor.
23:22:04 <Twey> J is write-only :-P
23:22:04 <mmorrow> Saizan_: also, i've exposed all the internals
23:22:34 <gaze__> forth is fun too, I forgot forth
23:23:00 <gaze__> learned it writing programs in 8th grade on my hp48g
23:23:01 <geezusfreeek> i have read forth material and stuff, but i have yet to actually try it out for anything
23:23:04 <Twey> You're going to recommend INTERCAL next
23:23:19 <gaze__> hahaha. comefrom is the greatest thing ever
23:23:20 <MyCatVerbs> you forth forgot ?
23:23:28 <mmorrow> Saizan_: (and added some more parsing functions in the toplevel module)
23:23:58 <Twey> gaze__: Someone implemented it for Python :-P
23:24:16 * bd_ wonders if comefrom can be implemented as a monad
23:24:18 <mmorrow> Saizan_: and docs are at: http://code.haskell.org/~morrow/code/haskell/haskell-src-exts-metaquote/docs/
23:24:19 <lambdabot> Title: haskell-src-exts-metaquote-0.1: MetaQuote - Haskell Meta Utilities, http://tinyurl.com/6j22tg
23:24:19 * codacola recommends pl/I
23:24:40 <chrisdone> there's a really esoteric language developed by some high up category theorest, L.O.L.CODE, it's called
23:24:59 <MyCatVerbs> "Oh, IMB had a PL/1 / Its syntax worse than JOSS / And everywhere this language went / it was a total loss."
23:26:21 <chrisdone> Twey: while we're talking about esoteric languages, I guess this is where we recommend lojban
23:26:35 <TSC> Or esperanto
23:26:51 <chrisdone> TSC: can you speak esperanto?
23:26:54 <Twey> .i je'u go'i
23:26:58 <TSC> No way
23:26:59 <Twey> Mi povas
23:27:07 <chrisdone> TSC: how can you recommend itâ€½
23:27:40 <TSC> It certainly meets the "esoteric" part
23:28:04 <ddarius> The Esperanto community is probably bigger than the Haskell community.
23:28:24 <chrisdone> and?
23:28:26 <Twey> E?  Esperanto ne estas fremda
23:28:32 <chrisdone> s/probably/definitely
23:28:41 <mmorrow> is esperanto actually spoken, or just written?
23:28:47 <Twey> Both, mmorrow
23:28:54 <mmorrow> cool
23:29:52 <chrisdone> so Ruby on Rails was too painful to get working so I'm using haskell+fastcgi
23:30:38 <Twey> When you could set up Haskell and FastCGI, why were you looking at RoR in the first place?  :-P
23:30:56 <chrisdone> I may have to learn Ruby for a job Â·â€”Â·
23:31:11 <Twey> Eh, get a book
23:31:29 <Twey> It's like Esperanto, you can pick it up in half a day
23:32:06 <chrisdone> right. they use Rails, too
23:32:53 <Twey> Rails is a monster, though, I guess that might take some practice.
23:33:43 <chrisdone> I couldn't find something to satisfy these predicates; (1) guide to using Rails (2) up-to-date with the latest version
23:34:29 <Saizan_> mmorrow: why exposing everything?
23:34:36 <ddarius> chrisdone: Read the source.
23:34:40 * Twey puts on 'Äˆu vi volas danci' :>
23:35:08 <mmorrow> Saizan_: just while hacking on it, makes things easier
23:35:33 <mmorrow> (lets haddock get at everything so you can look at it on a pretty webpage, etc)
23:35:35 <chrisdone> ddarius: maybe if I get the job, otherwise I don't care about Rails enough to bother
23:37:09 <codacola> is there anyway to get random access to a list? (not with !!)
23:37:22 <codacola> seems like itd be very veyr slow if you know the element you wanted, but had to keep dropping the head....
23:37:53 <smtms> codacola, sure, if lists are represented by linked lists
23:38:28 <codacola> youd still have to go through them 1 by 1....
23:38:33 <ddarius> codacola: What you're saying doesn't make sense.
23:38:45 <codacola> i mean like an array
23:38:51 <ddarius> Use an array.
23:38:57 <codacola> haskell has arrays?
23:39:07 <ddarius> Haskell has more arrays than most languages.
23:39:26 <chrisdone> checkout Data.Array
23:40:07 <gaze__> do the same storing of a copy thing apply with arrays too?
23:40:10 <gaze__> *does
23:40:32 <mmorrow> there are mutable arrays
23:40:40 <rwbarton> That question has to do with why there are so many different kinds of arrays
23:40:53 <gaze__> how about data.array
23:41:36 <mmorrow> there's Data.Array.IArray  and Data.Array.MArray  which provide the immutable and mutable array classes respectively
23:44:56 <aj_> How do I download a copy of HAppS?
23:45:06 <aj_> I can't find a link on happs.org
23:45:10 <ddarius> @hackage happs
23:45:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happs
23:45:11 <chrisdone> darcs get?
23:45:57 <aj_> there's no packaged distribution is it?
23:46:13 <bd_> why is half of the content on happs.org invisible without javascript :|
23:46:15 <aj_> I don't even have darcs
23:46:19 <ddarius> @hackage HAppS-Server
23:46:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HAppS-Server
23:46:55 <aj_> ddarius: got it! thanks
23:48:01 <aj_> I am going to try deploying happs on dreamhost using fastcgi.. Any pointers?
23:59:05 <chrisdone> anyone got a guide on using ghci on acid?
