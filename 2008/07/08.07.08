00:00:09 <_zenon_> astrolabe. true.
00:11:47 <ooxwo> Hi all, I'm getting an Exit Failure 1 when trying to install happs with cabal ---  ghc-6.8.2: could not execute: /usr/local/lib/ghc-6.8.2/ghc-asm
00:12:00 <ooxwo> Anybody have any idea what that's about?
00:13:36 <ooxwo> could not execute ghc-asm?  That seems like a vital part of the system.  I'm sure ghc has used this binary successfully before...
00:14:23 <ooxwo> What is the usual nature of a Cabal bug?
00:14:43 <ooxwo> This is the first I've tried to use it, and many other things are installing okay
00:15:00 <dons_> ooxwo: that isn't a good sign. it means ghc couldn't execute.
00:15:25 <ooxwo> dons_:  Yeah that's what I thought.  But I've been compiling stuff all day
00:16:15 <ooxwo> What is special about Happs-Util?
00:17:55 <pierre-> hi all
00:17:57 <pierre-> is haskell.org really down?
00:19:06 <_zenon_> pierre-: Not for me
00:19:12 <ooxwo> downforeverybodyorjustme.com
00:19:37 <ooxwo> downforeveryoneorjustme.com actually
00:21:11 <_zenon_> http://haskell.org/
00:21:11 <lambdabot> Title: Haskell - HaskellWiki
00:21:16 <_zenon_> I don't think so
00:21:31 <pierre-> thanks, seems that my isp's dns gone down
00:24:49 <_zenon_> sucks
00:25:47 <geezusfreeek> opendns is your friend :)
00:26:56 <_Dae_> google is your best friend....
00:27:58 <_zenon_> uh oh. you can't have 2 best friend:s , best implies there is no other as good as that friend?
00:28:58 <_zenon_> So, who is your best friend? Really?
00:29:05 <_zenon_> haskell is your best friend
00:29:18 <_Dae_> haskell, or ghc?
00:29:57 <_zenon_> haskell
00:31:10 * _Dae_ is not sure he would like using haskell without a compiler.
00:31:26 <Axman6> pancil and paper ftw!
00:31:32 <_zenon_> Axman6: :)
00:31:40 * araujo remembers a quote that read "Everyone is best than everyone"
00:31:45 <_zenon_> _Dae_: No haskell => No ghc
00:32:34 <Dzlk> fountain pen and paper if you're fancy and arrogant ;)
00:32:43 <_zenon_> Dzlk: No, take it back!
00:32:50 <Syzygy|de> Dzlk: That's not fancy nor arrogant. That's comfortable.
00:32:55 * _zenon_ shoves Dzlk
00:33:35 <Dzlk> Oh, nono, I approve of fountan pens! The arrogance is in writing code with something non-erasable.
00:33:42 <_Dae_> Wouldn't haskell written with pen and paer just be pseudocode?
00:34:14 <_Dae_> Dzlk: Coulnd't you just remove your delete and backspace buttons?
00:34:36 <_zenon_> Dzlk: Grasping for straws.
00:34:37 * _Dae_ needs to create a haskell program to automaticly fix his spelling
00:34:49 <Dzlk> You could but it's not as much fun.
00:35:51 <Dzlk> _zenon_: actually alluding to having done it and ended up with a lot of unsightly crossings-out when I saw what I did wrong.
00:36:54 <_Dae_> again, I insist on a compiler.... haskell is great but if I had to handcode directly, I'd just write assembler
00:37:41 <_zenon_> _Dae_: hugs, interpret it :)
00:37:58 <_zenon_> Dzlk: Okay, as long as fountain pen is okay, and not arrogant.
00:38:12 <_zenon_> Dzlk: I happen to have a parker pen
00:38:37 * _Dae_ hugs _zenon_ back.....
00:39:35 <_zenon_> _Dae_: Ehh. I was talking about hugs
00:39:37 <_zenon_> :)
00:39:54 <Dzlk> _zenon_: :) Definitely okay. (I feel obliged to point out that I generally approve of arrogance too, but that's orthogonal.)
00:40:11 <_zenon_> http://www.haskell.org/hugs/
00:40:11 <_Dae_> _zenon_: I know :p Is it still being develoed, or have they all moved on to yhc?
00:40:12 <lambdabot> Title: Hugs 98
00:40:28 <_Dae_> *developed
00:40:43 <_zenon_> _Dae_: Okay, you just seized the moment :D    hehe, no Idea about what's happening there, I abandoned it for ghci a while ago
00:41:19 <_Dae_> _zenon_: Yeah, only advantage I see is that it sometimes give you better error messages
00:41:32 <_zenon_> _Dae_: Exactly!
00:42:33 <kiris> I am abusing flip way too much
00:42:58 <wuxia> test.hs:2:0:
00:42:58 <wuxia>     Failed to load interface for `Graphics.X11.Xinerama':
00:42:58 <wuxia>       it was found in multiple packages: X11-extras-0.4 X11-1.4.1
00:43:14 <wuxia> how do I fix this? I'm trying to install xmonad with xinerama support
00:43:16 <Zao> I extras still needed?
00:43:19 <Zao> *Is
00:43:22 <wuxia> i guess not, how do i remove it?
00:43:29 <hpaste>  kiris pasted "flip omfg" at http://hpaste.org/8777
00:43:32 <Zao> How'd you install it?
00:43:41 <Zao> ghc unregister would probably work to get it out of the list.
00:43:45 <wuxia> sudo runhaskell Setup.lhs install
00:44:24 <wuxia> ui'm kind of new; can you give me a line to ecevute ?
00:45:17 <Zao> sudo ghc-pkg unregister X11-extras
00:46:42 <wuxia> thanks
00:47:34 <_zenon_> Is there a way to run haskell code in php?
00:47:50 <_zenon_> http://lukeplant.me.uk/blog.php?id=1107301645
00:47:51 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
00:47:53 <_zenon_> What is this?
00:48:08 <Syzygy|de> _zenon_: system("ghci -e \"$CODE\"");
00:48:16 <Syzygy|de> or something like that
00:48:49 <_zenon_> Syzygy|de: Nice :) So I wont need to learn much PHP :) I can hide in the lush haskell forest
00:48:52 <profmakx> *shiver*
00:49:15 <Syzygy|de> profmakx: You care to tell him why he should learn -some- PHP before blindly accepting code?
00:49:50 <Syzygy|de> Or should I?
00:50:04 <profmakx> I refuse to learn any php
00:50:35 <profmakx> sometimes i am forced to read it, but that suffices for a lifetime
00:50:36 <profmakx> twice
00:50:46 <Associat0r> same here
00:50:50 <_Dae_> because bad php code is one of the easiest ways known to man to run hostile code on a server?
00:51:00 <wuxia> anyone successfully run xmonad on two screens?
00:51:03 <Syzygy|de> And _Dae_ wins a prize! :)
00:51:46 <_Dae_> Woohoo!
00:52:03 <Syzygy|de> _zenon_: My code was not particularly seriously meant. It launches a GHC process of its own for each run, from scratch, and just dumps whatever haskell code into it. The whole thing runs through once, and you get access to stdout and hardly anything else. Doing it that way is bad bad BAD, and probably would compromise security.
00:52:20 <Syzygy|de> And on the other hand, it's the only way I can think of that doesn't require some serious hacking.
00:53:51 <_Dae_> I bet yhc will have a converter soon.....
00:54:00 <codacola> whats yhc?
00:54:11 <profmakx> @where yhc
00:54:11 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
00:54:17 <profmakx> yet another haskell compiler
00:54:19 <profmakx> iirc
00:54:24 <profmakx> no
00:54:29 <profmakx> york haskell compiler ;)
00:54:44 <codacola> ah
00:55:27 <_Dae_> It's mainly a preprocesser I think? Allows you to run haskell via javascript, python and erlang so far...
00:55:38 <_Dae_> and ghc
00:59:13 <_Dae_> it's odd how hanging out on #haskell qualifies as work in my mind....
00:59:39 <_Dae_> or as a legit reason not to work, rather
00:59:42 <codacola> doesnt in mine. though i barely look at it :P
01:00:20 <kiris> what's that function that forces the evaluation of something inside the IO monad?
01:00:58 <kiris> e.g. a <- foo; f a; ... where f forces evaluation of it
01:01:43 <_Dae_> Can't be done....
01:01:52 <_Dae_> or rather, can only be done in a hacking way
01:02:00 <_Dae_> I guess putStrLn (show a) qualifies?
01:03:09 <_Dae_> depending on the type of a there are various things you can do. I made one for lists at some point.....  If you're doing it right you shouldn't really need it
01:03:29 <quicksilver> kiris: "evaluate"
01:03:39 <_zenon_> kiris: I guess you want to avoid lazyness?
01:03:44 <quicksilver> but I don't think it's particularly useful.
01:03:48 <quicksilver> I think it just causes confusion.
01:03:56 <quicksilver> if you need to force something then use seq :)
01:04:14 <kiris> I used `return $!'
01:04:16 <kiris> I'll try evaluate
01:04:23 <_zenon_> seq
01:04:33 <_zenon_> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Aseq
01:04:34 <lambdabot> Title: Prelude, http://tinyurl.com/ovjef
01:04:39 <kiris> @srcevaluate
01:04:39 <lambdabot> Unknown command, try @list
01:04:42 <kiris> @src evaluate
01:04:42 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
01:04:47 <quicksilver> _Dae_: yhc is certainly not a preprocessor.
01:04:53 <quicksilver> _Dae_: it's a full compiler.
01:05:29 <kiris> I'm reading a file and I don't want it to be reading from disk as I'm working on the data, I want to read in the data, then work on it
01:05:35 <_Dae_> quicksilver: Really? I thought it compiled to some sort of semi code it then passed on? Guess I got that idea from the supero article
01:05:36 <kiris> hence evaluating it before doing the work
01:06:13 <quicksilver> kiris: use a strict read them
01:06:26 <quicksilver> it's permitted to curse the haskell library for only having stupid broken primitives
01:06:35 <quicksilver> and then import strict bytestring and use the readFile there.
01:07:21 <kiris> hm, okay
01:07:40 <quicksilver> _Dae_: it happens that yhc uses a Core format which is considered easier to work with than GHC's intermediate formats.
01:08:00 <quicksilver> _Dae_: that's why quite a few tools and/or code processors choose to use it.
01:08:26 <_zenon_> I must admit that I have _never_ used bytestring
01:08:30 <kiris> evaluate saved me 100 milliseconds. I'll try out ByteString. never used it before
01:08:50 <_zenon_> Where would you advice using ByteString?
01:08:53 <Smokey`_> I was under the impression yhc compiled into a bytecode, which was run in a yhc VM?
01:08:55 <_Dae_> _Dae_: Right... in supero they just talked about compiling yhc output via ghc.... But I dind't think yhc was ready for everyday use?
01:09:15 <_Dae_> VM? Ohh please no.....
01:09:40 <Smokey`_> well yhc 'does' compile into a bytecode, so what do you do with the bytecode?  tap your heels together 3 times?
01:09:58 <Smokey`_> well if yhc*
01:10:01 <quicksilver> yhc isn't particular useful for everyday use.
01:10:04 <_zenon_> Smokey`_: No, you dance naked
01:10:12 <quicksilver> it doesn't have any compelling advantages over ghc, say :)
01:10:58 <_Dae_> Kept supero.. :p
01:11:46 * _Dae_ is a known speedfreak, and gets excited by any benchmark that proves haskell can outperform c
01:12:48 <Smokey`> if you can give me an example where Haskell outperforms C in complex mathematical computations, using the same alg in both Haskell and C, without using the FFI - I'd very much be interested in it :)
01:16:16 <_zenon_> and so the silence fell over haskell land
01:16:19 <dons_> Smokey`: things often boil down to the same asm if you're careful.
01:16:45 <dons_> it's really not as hard as you think to match C using GHC's C backend.
01:16:46 <_Dae_> heh, that's not possible. C is just a fancy way to write assembler, so you can always make it outperform haskell. But it can get very very close, and it's often better than lazyliy written c
01:16:54 <dons_> right.
01:17:31 <dons_> some simple things, we get identical asm from gcc and ghc, http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast
01:17:49 <dons_> which goes carefully through the transformations, explaining why ghc and gcc produce the same results
01:18:37 <dons_> and if we look at http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=gcc we see gcc's got a good lead, but 4 benchmarks have haskell faster (sum-file, thread-ring, binary-trees and , interestingly, spectral-norm)
01:18:52 <dons_> that's less than a year ago, so the C entries have got better
01:19:04 <jsnx> _Dae_: yeah, i guess that's true
01:19:07 <dons_> and haskell wins on threads, lazy IO and data structure benchmarks
01:19:19 <_Dae_> but some of the haskell entries are pretty poor too
01:19:23 <jsnx> _Dae_: but can you get it as fast for the same number of programmer hours?
01:19:40 <dons_> nsive is the same speed as C, which is nice.
01:19:47 <_zenon_> what about memory leaks?
01:19:53 <_zenon_> I guess C is "better" there as well
01:19:54 <_zenon_> :)
01:19:59 <dons_> and there's 9 benchmarks within 2x C
01:19:59 <plutonas_> is the difference between foldl and foldr that foldl starts using the list from the left side, and foldr from the right side? i saw code for both of them in the tutorial i'm following, but i don't seem to understand the code for foldr very well...
01:20:02 <quicksilver> _Dae_: C is a terrible way to write mathematical ASM
01:20:13 <_Dae_> jsnx: nope, that's why people use high level languages at all. It's never about computation speed, it's about total time to completion
01:20:24 <_zenon_> I would use C++, it has everything C has
01:20:26 <quicksilver> _Dae_: it completely fails to support any interesting mathematical capabilities of your CPU.
01:20:32 <_zenon_> Why this C obsession?
01:20:34 <_Dae_> quicksilver: Mathematical asm? As opposed to?
01:20:34 <quicksilver> _Dae_: it doesn't even support the carry bit!
01:20:42 <dons_> Smokey`: so yeah, in summary, its entirely possible to generate faster code for some problems. for numerics, the state of the art is generating the same code as C.
01:20:44 <quicksilver> which has been in all chips, ever.
01:20:49 <Smokey`> dons_: what's the fastest 'array' (as in, contiguous block of memory - not that Haskell deals with such things) type in Haskell? (eg: something similar to an array in C)
01:20:59 <jsnx> _Dae_: well, in theory, you can write C that is faster than any FORTRAN
01:21:02 <codacola> _zenon_, because C is god
01:21:12 <dons_> the fastest array type is one of: STUArray or UVector
01:21:17 <_Dae_> quicksilver: Really? I was led to belive you could do a <-> transform between c and asm? or at least c++
01:21:18 <quicksilver> _Dae_: given almost any mathematical algorithm you can write hand-coded ASM which outperforms C.
01:21:21 <jsnx> _Dae_: but it goes without saying that C is not a good tool for writing matrix multiplications in
01:21:22 <Smokey`> I'm very much interested in using Haskell significantly in my applications, I've just yet to have the knowledge to get the speed I want
01:21:29 <quicksilver> _Dae_: No. The carry bit is the simplest example.
01:21:33 <_zenon_> codacola: Uhm, I don't know. Fortran will own your C code in matrix multiplication ?
01:21:39 <quicksilver> suppose you have a native 32 bit int
01:21:45 <quicksilver> and you want to implement 64 bit adding
01:21:47 <codacola> _zenon_, http://www.youtube.com/watch?v=J5LNTTGDKYo
01:21:55 <quicksilver> all chips make this easy, because they set a carry bit on overflow.
01:21:58 <kiris> dons_: cool post, thanks dons
01:22:04 <quicksilver> however, C compilers don't give you access to that.
01:22:18 <quicksilver> for more complex examples, consider vector instructions
01:22:21 <Smokey`> hmm, another question - GHC compiles Haskell to native binaries... how does it export symbols? (eg: so you can link to it from another app)
01:22:31 <_Dae_> kiris: for normal use, UArray is easiest
01:22:37 <quicksilver> Smokey`: you can choose to export symbols with foreign export...
01:22:39 <plutonas_> ok, will ask later again everyone seems busy with C :)
01:22:41 <quicksilver> Smokey`: (see the FFI docs)
01:22:49 <Smokey`> so it's part of the FFI specifically? cool :)
01:22:52 <quicksilver> plutonas_: yes, you're right.
01:22:55 <dons_> Smokey`: the arrays are continguous blocks of memory, btw.
01:22:56 <quicksilver> Smokey`: right.
01:23:11 <kiris> _Dae_: what are you talking about?
01:23:15 <dons_> STUArrays are continguous, raw memory with a type system guarantee that mutation can't escape
01:23:16 <_Dae_> quicksilver: hmm, right.... Guess my algorithm teacher was wrong then ;)
01:23:16 <quicksilver> plutonas_: if in doubt, visit foldr.com and foldl.com
01:23:24 <plutonas_> quicksilver: :P
01:23:26 <dons_> UVectors are contiguous blocks of memory that support loop fusion
01:23:32 <quicksilver> plutonas_: I'm absolutely serious.
01:23:43 <jsnx> plutonas_: so, if i remember right, foldr is just like reversing the list and applying foldl
01:23:43 <_Dae_> kiris: arff, sorry, wrong person
01:23:46 <quicksilver> plutonas_: foldr.com and foldl.com have demos which show the difference.
01:24:05 <jsnx> > foldr1 (:) [1..10]
01:24:08 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
01:24:08 <lambdabot>       Expected...
01:24:22 <jsnx> > foldr1 (+) [1..10]
01:24:23 <plutonas_> quicksilver: foldr.com just writes that 1+(...)=oo
01:24:24 <lambdabot>  55
01:24:27 <_zenon_> haha.. funny sites:)
01:24:28 <quicksilver> plutonas_: click on the ...
01:24:48 <plutonas_> lol
01:24:50 <plutonas_> nice!
01:24:56 <jsnx> > foldr (:) [] [1..10]
01:24:57 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
01:25:05 <jsnx> > foldl (:) [] [1..10]
01:25:05 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
01:25:05 <lambdabot>       Expected...
01:25:14 <quicksilver> you may also find the pictures at the bottom of http://www.haskell.org/haskellwiki/Fold interesting
01:25:22 <quicksilver> > foldr1 (+) [1..5] :: Expr
01:25:23 <lambdabot>  1 + (2 + (3 + (4 + 5)))
01:25:27 <quicksilver> > foldl1 (+) [1..5] :: Expr
01:25:28 <lambdabot>  1 + 2 + 3 + 4 + 5
01:25:39 <quicksilver> hmm. bad choice of operator
01:25:40 <jsnx> :t foldl
01:25:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:25:43 <quicksilver> > foldl1 (/) [1..5] :: Expr
01:25:44 <lambdabot>  1 / 2 / 3 / 4 / 5
01:25:47 <quicksilver> grr
01:26:05 <jsnx> > foldr (:) [] [1..10] :: Expr
01:26:05 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
01:26:27 <plutonas_> i still am confused though
01:26:35 <jsnx> plutonas_: so am i now
01:27:17 <plutonas_> quicksilver: when i call foldr step z lst
01:27:30 <plutonas_> z is the ending value?
01:27:32 <jsnx> i wrote some code once where i thought i was going to have to reverse an accumulator at the end, but because i used foldr i didn't have to
01:27:37 <jsnx> where is that code...
01:27:49 <plutonas_> not the initial as in foldl
01:27:50 <plutonas_> ?
01:27:54 <quicksilver> plutonas_: depending what you mean by 'ending'. Yes.
01:28:03 <quicksilver> > foldr (+) z [a,b,c]
01:28:04 <lambdabot>  a + (b + (c + z))
01:28:07 <quicksilver> see ?
01:28:27 <plutonas_> > foldl (+) z [a,b,c]
01:28:28 <lambdabot>  z + a + b + c
01:28:35 <jsnx> > foldr (:) [] [a,b,c] :: Expr
01:28:36 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
01:28:37 <plutonas_> hm
01:28:40 <codacola> _zenon_, did the song show you the light?
01:28:44 <Smokey`> memory consumption still worries me in Haskell - are there compile options for GHC that tell it how strict/lazy to be about freeing memory, or? :\
01:28:52 <jsnx> > foldr (+) x [a,b,c] :: Expr
01:28:53 <lambdabot>  a + (b + (c + x))
01:29:00 <jsnx> > foldl (+) x [a,b,c] :: Expr
01:29:01 <lambdabot>  x + a + b + c
01:29:09 <_zenon_> codacola: hehe., no, I didn't see it :)
01:29:14 <codacola> watch it :D
01:29:16 <jsnx> oh
01:29:21 <_zenon_> I have no speakers :)
01:29:24 <codacola> aww
01:29:26 <_Dae_> Smokey`: you can envoke the gc which helps some
01:29:43 <jsnx> so that's why foldr (:) [] [1,2,3] works but the foldl version doesn't
01:29:52 <codacola> write in c, write in c, youve just spent 30 hours debugging some assembly, soon you will be glad to write in C, write in C, write in C, yeah write in C
01:30:33 <quicksilver> Smokey`: there isn't really anything to tune in that respect.
01:30:34 <plutonas_> jsnx: quicksilver: so foldr gives z + c + b + a, and foldl z + a + b + c
01:30:41 <plutonas_> is that the difference in general?
01:30:46 <quicksilver> Smokey`: GHC always frees all un-needed memory (every time it GCs)
01:30:54 <quicksilver> Smokey`: and it never frees any needed memory ;)
01:30:59 <quicksilver> anything else woudl be daft!
01:31:14 <jsnx> plutonas_: you need the parentheses in there
01:31:25 <quicksilver> Smokey`: however you can tune the heap size
01:31:26 <codacola> ya know with all the time spent arguing about languages we could simply use assembly, could end up being faster with all the time saved
01:31:27 <quicksilver> plutonas_: No.
01:31:43 <quicksilver> foldr gives a + (b + (c + z)), not z + c + b + a
01:31:55 <quicksilver> just because you know order doesn't matter with (+)
01:32:00 <quicksilver> doesn't mean order always doesn't matter :)
01:32:21 <plutonas_> quicksilver: but the order is the same the way i wrote it
01:32:29 <plutonas_> first we add z + c
01:32:34 <plutonas_> then b to the result
01:32:34 <jsnx> plutonas_: yes, in that case it works
01:32:39 <plutonas_> etc, i din't change the order
01:32:46 <jsnx> plutonas_: but that is a little obfuscated
01:32:46 <quicksilver> plutonas_: but you wrote z + c
01:32:49 <quicksilver> it isn't z + c
01:32:52 <quicksilver> it's c + z
01:32:53 <_Dae_> quicksilver: order matters with +, doesn't it? I mean, not in theory but in the real world
01:32:54 <plutonas_> oh ok
01:32:55 <quicksilver> important difference!
01:33:22 <quicksilver> _Dae_: not in the hardware I'm familiar with, no.
01:33:22 <jsnx> _Dae_: well, why would it matter in the real world?
01:33:58 <jsnx> _Dae_: you can't do `gettime` + `gettime` in haskell :)
01:34:26 <_Dae_> quicksilver: (1e32+(-1e32))+1 = 1, (1e32+1)+(-1e32) = 0
01:34:35 <_Dae_> does with doubles
01:34:36 <jsnx> quicksilver: oh yeah, you are right c + z
01:35:13 <_Dae_> jsnx: sure I can.... via FFI ;)
01:35:15 <quicksilver> dancor: that's associativity
01:35:21 <quicksilver> _Dae_: that's associativity
01:35:25 <quicksilver> _Dae_: not commutativity.
01:35:43 <quicksilver> (1e32+(-1e32)) is the same as ((-1e32)+(1e32))
01:35:50 <quicksilver> that's what I'm saying.
01:36:00 <jsnx> so, the order of any two does not matter?
01:36:02 <_Dae_> Ohh, right, yeah
01:36:07 <quicksilver> you can certainly find examples where associativity fails, yes.
01:36:09 <jsnx> but the order of three or more does
01:36:24 <quicksilver> although only by small amounts
01:36:34 <quicksilver> (but you can then build up the small amounts if you have patience :)
01:37:43 <_Dae_> Small amounts can be enough to throw off your algorithms
01:38:05 <quicksilver> true.
01:38:18 <quicksilver> but if you're writing algorithms for floating point you're supposed to know that.
01:38:21 <_zenon_> here we go with "real world" again
01:38:26 <_Dae_> quicksilver: True that
01:38:27 <_zenon_> Please define "Real world"
01:38:30 <jsnx> it's not just floating point
01:38:38 <quicksilver> jsnx: ?
01:38:44 <_Dae_> Real World :: IO ()
01:38:45 <jsnx> any fixed size type should have this problem, right?
01:38:56 <_Dae_> jsnx: Int doesn't really
01:39:00 <quicksilver> well overflow feels like a 'different' problem.
01:39:06 <quicksilver> it's certainly a problem
01:39:17 <quicksilver> it doesn't break associativity or commutativity, as it happens.
01:39:30 <quicksilver> (+) modulo some number is still a group.
01:39:39 <jsnx> oh, yeah, now that i think about it, you are right
01:39:47 <jsnx> Ints are okay
01:39:50 <quicksilver> another example of where C sucks.
01:39:56 <quicksilver> C can't even detect int overflow.
01:39:56 <jsnx> ?
01:40:03 <quicksilver> I mean, FFS, what a useless language.
01:40:17 <jsnx> quicksilver: what does it matter?
01:40:26 <quicksilver> if you can efficiently detect overflow
01:40:34 <quicksilver> then you can write fast algorithms which ignore it
01:40:39 <_Dae_> quicksilver: For talking with hardware even? I mean for writing drivers and stuff
01:40:41 <quicksilver> and then take special steps when/if it does happen.
01:40:53 <quicksilver> if you can't efficiently detect it you have to pre-check all the time
01:40:59 <quicksilver> which is a real waste of cycles.
01:41:01 <jsnx> _Dae_: personally, I think Haskell would be better for that, too
01:41:08 <quicksilver> (or resign yourself to writing algorithms which break on overflow)
01:41:15 <jsnx> quicksilver: hmm
01:41:36 <jsnx> _Dae_: i wrote a huge chinese dictionary as an array of Ints
01:41:44 <jsnx> some ints were chinese characters
01:41:47 <quicksilver> on most CPUs "jump if overflow" is a single opcode
01:41:55 <quicksilver> which takes very few cycles (maybe even one) if it doesn't trigger.
01:42:01 <jsnx> some of them were pointers into the rest of the array (it was actually a trie)
01:42:22 <jsnx> so, first i wrote binary search in C
01:42:27 <quicksilver> anyhow this is just further example of how C really isn't as great a map to the hardware as its cracked up to be.
01:42:28 <jsnx> and everything else in C
01:42:36 <_zenon_> My PHP laughter number one:
01:42:43 <_Dae_> jsnx: Really? I guess I haven't used it enough in a real-time context, but setting bytes in haskell seems counter-intuitive to me
01:42:44 <jsnx> quicksilver: that's actually quite interesting
01:42:55 <_zenon_> To remove a cookie, you use the setCookie function but set the expiration time to the past
01:43:02 <jsnx> _Dae_: well, then i went ahead and did all the pointer arithmetic in haskell
01:43:13 <jsnx> on a C array (declared in a C header file)
01:43:27 <jsnx> it was a lot cleaner the second time around, let me tell you
01:43:32 <_zenon_> Ohh.. sorry, maybe this is the #C channel
01:44:10 <quicksilver> ;)
01:44:11 <Dzlk> _zenon_: PHP is scary.
01:44:20 <quicksilver> nah, we're much better at C here than they are in ##c
01:44:22 <quicksilver> :P
01:44:24 <jsnx> _Dae_: unlike say, Java, I don't think Haskell has any trouble modelling what is going on in C
01:44:25 <_zenon_> Dzlk: Indeed. I don't know if I dare continue
01:44:31 <_Dae_> jsnx: But..... that's somewhat different from writing drivers for hardware, isn't it?
01:44:42 <jsnx> _Dae_: well, what do drivers do?
01:45:17 <jsnx> _Dae_: it's substantially pointer arithmetic
01:45:19 <codacola> process data like any ohter program
01:45:22 <codacola> just in a special way
01:45:30 <jsnx> codacola: 2 points
01:45:31 <quicksilver> you're write that GHC would not currently be adequate to write hardware drivers
01:45:40 <quicksilver> because of timing issues
01:45:46 <jsnx> _Dae_: but it's GHC, not Haskell
01:45:49 <quicksilver> however that's not the same thing as haskell not being adequate
01:45:50 <codacola> jsnx, only 2?
01:45:56 <quicksilver> and it's not too hard to imagine some small changes
01:46:06 <quicksilver> ability to disable GC for a chunk of code etc
01:46:11 <jsnx> codacola: overbroad claims will kill your patents
01:46:51 <codacola> jsnx, true, but why would i describe it in a more narrow sense when you could patent it yourself? ;)
01:47:22 <_Dae_> jsnx: Currently ghc -is- haskell. I'm not saying you couldn't do it, I'm saying it's not the best tool for the ob
01:47:28 <jsnx> codacola: enough with the questions
01:47:29 <_Dae_> *ob
01:47:35 <jsnx> _Dae_: indeed
01:47:40 <quicksilver> there have been a few projects towards writing OSes in haskell.
01:47:49 <jsnx> _Dae_: but i'm just saying, think about the future
01:47:58 <Syzygy|de> _Dae_: Making friends with the yhc and the hugs crowd, I hear... :)
01:48:14 <Dzlk> @where house
01:48:14 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
01:48:20 <quicksilver> http://programatica.cs.pdx.edu/House/
01:48:22 <quicksilver> I think
01:48:29 <_Dae_> Syzygy|de: huh?
01:48:40 <Syzygy|de> (10:47) ( _Dae_) jsnx: Currently ghc -is- haskell. [...]
01:49:17 <jsnx> _Dae_: Haskell was a lot better at raw memory access then i gave it credit for
01:49:58 <jsnx> how do i do that "can haskell do..." thing?
01:50:27 <_Dae_> Syzygy|de: well....yeah.... I'm not saying it's gonna stay that way. Yhc looks promising, but right now you wouldn't use it for anything but developing yhc
01:50:39 <osfameron> @faq can haskell do that "can haskell do..." thing?
01:50:39 <lambdabot> The answer is: Yes! Haskell can do that.
01:51:02 <jsnx> @faq can haskell do device drivers?
01:51:03 <lambdabot> The answer is: Yes! Haskell can do that.
01:51:28 <Mr_Awesome> @faq can haskell think?
01:51:28 <lambdabot> The answer is: Yes! Haskell can do that.
01:51:30 <_zenon_> @faq can haskell do { can haskell  do { can haskell do ? ....
01:51:30 <lambdabot> The answer is: Yes! Haskell can do that.
01:51:37 <_Dae_> jsnx: Yeah sure, I think that eventually haskell will be able to pull that off.. Right now....
01:51:50 <jsnx> _Dae_: aye, granted
01:51:51 <electronx> @faq can haskell run fast
01:51:51 <lambdabot> The answer is: Yes! Haskell can do that.
01:51:59 <electronx> @faq can haskell fly
01:51:59 <lambdabot> The answer is: Yes! Haskell can do that.
01:52:02 <jsnx> _Dae_: but you give C entirely too much credit
01:52:08 <electronx> okay thats bs
01:52:12 <electronx> @faq can haskell talk
01:52:13 <lambdabot> The answer is: Yes! Haskell can do that.
01:52:36 <Mr_Awesome> @faq can haskell
01:52:36 <lambdabot> The answer is: Yes! Haskell can do that.
01:52:39 <_Dae_> @faq can haskell be used to write a constant time solution to "The traveling salesman" problem
01:52:39 <lambdabot> The answer is: Yes! Haskell can do that.
01:52:50 <jsnx> _Dae_: it was not until C++ and templates that C and friends could do numerics on par with FORTRAN
01:52:50 <_Dae_> Win!
01:53:00 <Mr_Awesome> @faq can haskell make you want to program nothing but visual basic for the rest of your life?
01:53:01 <lambdabot> The answer is: Yes! Haskell can do that.
01:53:29 <Mr_Awesome> thats unfortunate
01:53:29 <_zenon_> oh nooooooooooo
01:53:36 <_zenon_> What a curse.
01:53:39 <jsnx> (and that blitz++ stuff is just crazy, using multiple levels of template rewrites to get fast matrix multiplies)
01:53:42 <_zenon_> Programming VB ?
01:53:44 <Dzlk> Hm, lambdabot's link for House is stale, quicksilver's is correct. (Can|How does) one update it?
01:54:05 <quicksilver> @where+ house http://programatica.cs.pdx.edu/House/
01:54:05 <lambdabot> It is forever etched in my memory.
01:54:10 <_Dae_> jsnx: I guess I don't really distinguish between c and c++ :p But I'm not saying c or c++ is the best for writing device drivers. If I ust wanted to do it QaD, I would use labview (!!!!)
01:54:34 <Dzlk> Aha
01:54:41 <profmakx> labview is nice
01:54:44 <Vq^> _Dae_: whats labview?
01:54:48 <profmakx> for mouse junkies
01:55:19 <jsnx> C has been a great systems programming language for much of it's life
01:55:28 <_Dae_> Vq^: A programming language for mouse junkies. It sucks, but it's very very easy to write drivers in.
01:55:48 <_Dae_> Vq^: http://en.wikipedia.org/wiki/Labview
01:56:00 <_zenon_> @faq can haskell determine whether an arbitrary program will terminate?
01:56:00 <lambdabot> The answer is: Yes! Haskell can do that.
01:56:07 <Syzygy|de> o.O
01:56:10 <jsnx> but it's always hasd to contend with FORTRAN for the high performance cup
01:56:21 <jsnx> s/hasd/had/
01:56:37 <jsnx> well, up until templates and C++
01:56:39 <_Dae_> jsnx: I thouhgt c++ had outperformed Fortran?
01:56:46 <Dzlk> @faq is a constant function.
01:56:46 <lambdabot> The answer is: Yes! Haskell can do that.
01:57:00 <jsnx> c++ is, i think you will grant, a very different language
01:57:10 <Vq^> _Dae_: C++ is fairly slow if you don't write C in it
01:57:24 <MrFawkes> Enough to make most C coders hate it, yes.
01:57:38 <jsnx> Vq^: actually, to beat FORTRAN, they had to use very powerful templating mechanisms
01:57:43 <_Dae_> is anyone using fortran anyore? I mean kept insane physicist who do it cause that's what we've been writing for the last 3 decades
01:57:46 <_zenon_> How can that be? C is a subset of C++,
01:57:50 <profmakx> I think assembler outperformed C?
01:57:57 <jsnx> _Dae_: no, it is not
01:58:10 <jsnx> _zenon_: no, it is not
01:58:17 <jsnx> _Dae_: sorry
01:58:39 <quicksilver> C is close to a subset of C++ and it's convenient to pretend it is.
01:58:40 <profmakx> C++ has a subset that is not quite entirely unlike C
01:58:45 <jsnx> _Dae_: it's under the hood in BLAS and LAPACK to this day, i believe
01:59:00 <solrize> zenon the idea in c++ is you use templates to type-specialize functions instead of passing function pointers into them and taking the overhead of a bunch of extra calls
01:59:15 <_Dae_> jsnx: Sure, but they are slowly being outperformed I think?
01:59:21 <quicksilver> the C++ solution is basically overblown compile-time macros
01:59:30 <quicksilver> (admittedly very ingenious ones!)
01:59:36 <opqdonut> and specialisation
01:59:45 <jsnx> solrize: well, you also use templates to generate expressions that are then rewritten by the template machine until it's all done
01:59:52 <solrize> that too
02:00:05 <quicksilver> mind you the reasons that fortran "outperformed" C in the first place were quite subtle.
02:00:07 <Dzlk> _Dae_: I know a few people who still maintain fortran. New code I've no idea.
02:00:08 <solrize> although, gcc does a reasonable job of that kind of intra-procedure rewriting
02:00:09 <jsnx> solrize: you can do term rewriting to any level, basically
02:00:11 <_zenon_> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=icpp
02:00:18 <quicksilver> arguably more to do with the compiler than the language.
02:00:27 <solrize> fortran generally doesn't have to worry about possible aliasing
02:00:28 <quicksilver> fortran compiler-writers were very interested in fast maths code
02:00:31 <_Dae_> quicksilver: Isn't that always true?
02:00:51 <quicksilver> _Dae_: well, it's always true that there is a balance between what the compiler makes possible and what the language makes possible.
02:01:04 <jsnx> _Dae_: there was no way to do it with C
02:01:15 <jsnx> _Dae_: they had to add templates before it could happen
02:01:18 <_zenon_> I still argue that what you want to avoid is: Memory errors and bulk code
02:01:29 <electronx> quicksilver: you are the most active person in haskell channel i have ever seen
02:01:38 <quicksilver> jsnx: I don't think that's really quite true.
02:01:45 <jsnx> quicksilver: no?
02:01:49 <electronx> quicksilber: you must live a breath haskell
02:01:55 <jsnx> quicksilver: why not?
02:01:57 <quicksilver> jsnx: the underlying code generated after all those term-rewritings was more or less C
02:02:03 <quicksilver> so it *could* have been written in C.
02:02:08 <jsnx> heh
02:02:10 <quicksilver> the point was it was massively specialised.
02:02:28 <quicksilver> to write it in C you would have needed a ridiculously huge library of similarly named functions
02:02:29 <_Dae_> electronx: he's the proof that you can write an AI in haskell. Don Stewart wrote him as an IRC bot
02:02:34 <quicksilver> doing slightly different things, etc.
02:02:38 <jsnx> let me put it another way
02:02:44 <jsnx> no people could write it in C
02:02:51 <quicksilver> _Dae_: actually SPJ wrote me. And then I wrote dons. But you were close.
02:02:52 <electronx> _Dae_: lol
02:02:52 <solrize> http://adahome.com/Ammo/cpp2ada.html  is interesting, makes me want to try ada, does ada really suck?
02:02:56 <jsnx> so they had to make templates
02:03:18 <electronx>  _Dae_: i wish such an ai existed
02:03:21 <quicksilver> jsnx: you could probably have pulled it off in the C preprocessor if you were sufficiently twisted.
02:03:26 <_zenon_> solrize: No, Ada does not suck
02:03:39 <jsnx> quicksilver: how many passes does that do? only one, right?
02:03:49 <solrize> zenon why use c/c++?  that thing makes ada sound better
02:03:50 <_Dae_> quicksilver: Blast!
02:04:03 <quicksilver> jsnx: I think it can be told to expand recursively. Maybe not. Maybe you'd have needed m4.
02:04:43 <jsnx> okay, but at that point you are saying: to do it in C, i need to write a program in M4 that writes a C program that does it
02:04:47 * quicksilver nods
02:04:50 <jsnx> which is not quite the same thing
02:04:54 <quicksilver> I agree. It's a subtle point.
02:05:11 <quicksilver> what I'm trying to say is that, it's not actually the C++ compiler's code generator that enabled the increase
02:05:12 <_zenon_> solrize: I don't follow ?
02:05:13 <jsnx> quicksilver: from a software engineering standpoint, though, it's a big deal
02:05:17 <quicksilver> it was the abstraction.
02:05:21 <jsnx> quicksilver: right
02:05:25 <jsnx> i agree with that
02:05:27 <quicksilver> the C++ compiler's code gen is probably very similar to the C one.
02:05:32 <_Dae_> The problem with c++ is mainly that it's hard to get it to be both fast and maintainable
02:05:38 <quicksilver> whereas, I believe, fortran compilers actually have better code gens.
02:05:53 <jsnx> quicksilver: well, they actually have better abstraction, too
02:05:58 <quicksilver> i.e. fortran compilers actually give you a sensible way to access the advanced features of your CPU
02:06:04 <quicksilver> jsnx: I didn't mean to exclude that :)
02:06:05 <jsnx> quicksilver: they are protected from aliasing by the language
02:06:12 <quicksilver> jsnx: better abstraction *and* better code-gen.
02:06:16 <jsnx> and that was really the point i was trying to make
02:06:33 <quicksilver> gcc/g++ are now fairly good at detecting non-aliasing, too.
02:06:38 <quicksilver> but fortran sure makes it easier :)
02:06:40 <jsnx> so we agree, after a fashion
02:06:44 <jsnx> yeah
02:06:48 <MrFawkes> quicksilver: No. C is compiled to something nice, Fortran is probably nicer, but compiled C++ is, well, pure puke. ;)
02:07:05 <quicksilver> MrFawkes: well that does depend which bit you're looking at.
02:07:17 <quicksilver> MrFawkes: since we're maingly talking about numerical algorithms today
02:07:29 <quicksilver> MrFawkes: I think you'd find the compiled C++ quite similar in charcter to the compiled C.
02:07:40 <quicksilver> unless you were daft enough to put virtual dispatch into a numerical class :)
02:07:42 <solrize> gcc at least in the past did a terrible job of compilign c++ templates
02:07:47 <jsnx> really, the puke would be in the intermediate templates
02:08:00 <solrize> http://homepage.mac.com/sigfpe/Computing/opt.html
02:08:33 <_Dae_> half-serious question: where do I find deepSeq?
02:08:49 <jsnx> once upon a time i was so into templates -- i thought they were the greatest thing ever -- i should have tried LISP instead
02:09:13 <jsnx> i ended up writing Ruby to write templates for me
02:09:32 <solrize> _zenon_ to read that adahome piece, writing anything large in c/c++ just sounds crazy, if you want to write something low level and imperative ada just sounds plain better in almost all situations
02:09:55 <jsnx> solrize: and DARPA basically agreed
02:10:10 <quicksilver> solrize: would be quite interesting to retry sigfpe's test with a modern g++
02:10:20 <quicksilver> solrize: certainly things have changed a lot since 3.3.1
02:10:24 <jsnx> though admittedly, DARPA shipped VMS on their new $100e6 fighter
02:10:39 <_zenon_> solrize: Well, I am no C/C++ fan in anny way :)
02:10:52 <quicksilver> _Dae_: Control.Parallel.Strategies under the name 'rnf'.
02:13:17 <_Dae_> quicksilver: requiring a strategy, or? I never used them as they seemed poorly documented....
02:14:12 <Dzlk> Hm. Is there a straightforward way to take a TypeRep and a string and read the string as an instance of that type?
02:15:34 <_zenon_> DAMN. PHP SUCKS
02:15:49 <Zao> _zenon_: You must be the only person ever to have that revelation :P
02:15:58 <electronx> lol
02:16:15 <electronx> php rocks......................yeah.....
02:16:21 <_zenon_> hehe, just had to let off some steam, and I can't do it in the #php channel
02:16:24 <_zenon_> :P
02:16:30 <schme_> Huh.  Q here.   data Board = Board ANDHEREIWANTANARRAY     how do I do that?
02:16:43 <schme_> that's and here I want an array
02:16:47 <electronx> well thank god for ruby then i guess
02:17:48 <_Dae_> _zenon_: Why not?
02:18:17 <_zenon_> _Dae_: I am asking them for help. Can't badmouth them in front of them, that would be........ honest
02:18:25 <_Dae_> schme_: I think it would go like data Board = Board (Array Int Double) ?
02:18:26 <solrize> schme_ look at Data.Array
02:18:51 <solrize> maybe you really want Data.Map or something like that though
02:18:56 <schme_> solrize: I'm looking at http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html and it is very much lacking any information what so every.
02:19:00 <schme_> solrize: Why?
02:19:23 <solrize> Data.Map has fast functional updates
02:19:31 <_Dae_> _zenon_: I don't know... in #haskell people will immediatly prove you wrong if you say haskell sucks  ;)
02:19:52 <schme_> solrize: So?
02:20:12 <solrize> schme_ you're writing a game or something?
02:20:18 <schme_> _Dae_: Thanks there. That worked like a charm Board = Board (Array Int Pip)
02:20:21 <_zenon_> _Dae_: You dropped me. I am talking about PHP. And for all possible models, the constant PHP will suck
02:20:31 <schme_> solrize: Well a client for playing at fibs
02:20:46 <_Dae_> schme_: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays for more info
02:21:19 <schme_> solrize: So every turn I get a string representing the current board sent to me, and I just need to turn that into something usable for me to change the gtk mewang.
02:21:21 <_Dae_> _zenon_: Perhaps the php geeks will prove you wrong? ish? Maybe not....
02:21:30 <solrize> schme_ data.map lets you update the board in a functional style... with arrays you have to either use diffarays which get slow, or mutable arrays which are impure
02:21:46 <solrize> oh ic
02:21:50 <_zenon_> _Dae_: I am sure they will find all possible explanaitons for why PHP is better than everything
02:21:54 <quicksilver> Dzlk: No.
02:21:55 <solrize> yeah i've never programmed the hsgtk stuff
02:21:58 <schme_> solrize: Yeah. It don't really matter so much :)
02:22:03 <quicksilver> Dzlk: you have to "wait" until you know what type you want it to be
02:22:06 <quicksilver> Dzlk: and read it then.
02:22:14 <quicksilver> Dzlk: in many cases that's good enough.
02:22:42 <_zenon_> electronx: hehehehe
02:22:53 <Vq^> PHP is quite convenient when you want to write literal strings :o)
02:22:58 <_Dae_> schme_: if all you want is to know what's on the board perhaps Array (Int,Int) (Maybe Pip) would work?
02:23:37 <Vq^> Haskell requires these unnecessary quotationmarks
02:24:19 <schme_> _Dae_: That looks complicated.
02:24:22 <_zenon_> Vq^: Is that even worth considering ?
02:24:31 <Vq^> _zenon_: not really
02:24:33 <solrize> there is an array tutorial on the wiki somewhere that is better than the lib docs
02:24:42 <_Dae_> schme_: it might be.... perhaps maps are the safer bet
02:24:50 <Vq^> to tell the truth i have never even seen a real PHP program utilizing that fact
02:24:53 <schme_> solrize: I was looking at IntMap earlier today, and it seemed a very odd way to do what I was hoping to do. I'll take a look at maps.
02:25:10 <solrize> intmap is a special case of map, where the index is an int
02:25:17 <schme_> _Dae_: I'm just confused to as of why I'd want the Maybe Pip etc.
02:25:22 <schme_> Well I want ints as index.
02:25:42 <solrize> Array Int Pip seems ok   where pip is a color and count
02:25:47 <schme_> _Dae_: I used to have [Pip], but it was a pain to work with.
02:26:02 <schme_> Exactly.
02:26:18 <Dzlk> quicksilver: Ah, in this case I do know, though. Basically I've got pairs of (type name as string, value as string) that I want to deserialize into values, and throwing an exception if they don't parse is desirable.
02:26:28 <_Dae_> schme_: nothing is stopping you from using Arrays ya know. it'll just leak a bit
02:26:42 <schme_> _Dae_: How will it leak?
02:27:26 <kiris> I love how the haskell docs show the orders of growth
02:27:44 <_Dae_> schme_: Well, any change to an IArray (diffArray excluded) means copying the entire thing. So you'll have the old boards floating about The gc should handle ti though
02:28:07 <quicksilver> Dzlk: there isn't even a Read instance for TypeRep.
02:28:16 <quicksilver> Dzlk: you'll come unstuck there.
02:28:34 <schme_> _Dae_: I was trying IArray earlier today, and I was told to use Array :S
02:28:36 <Cale> You generally shouldn't worry too much about creating garbage. The GC is very good about collecting short-lived objects.
02:28:48 <Cale> IArray is a class, Array is a type (constructor)
02:29:02 <Cale> You might use both :)
02:29:17 <_Dae_> schme_: Array is an IArray
02:29:21 <quicksilver> Dzlk: you might find this message interesting : http://www.haskell.org/pipermail/haskell-cafe/2008-May/042809.html
02:29:35 <Cale> Leaks arise when you *hold on to* what should be garbage.
02:29:55 <Cale> That is, you maintain references to it in one way or another.
02:31:08 <_Dae_> just make sure you make your updates strict, or the gc won't be able to remove the old element
02:31:33 <schme_> Hoh.
02:31:35 <schme_> Right.
02:31:50 <schme_> I'll just use array. Maybe someday I'll change it.
02:31:59 <schme_> Issa not such a big deal to change it later really :)
02:32:15 <_Dae_> schme_: Chances are you can hide the changes in a monad later, so no worries
02:32:41 <schme_> _Dae_: Or just change the 2 or 3 functions that actually use the array ;)
02:33:06 <Toxaris> it seems that I
02:33:10 <_Dae_> schme_: Well...yes...
02:34:33 <_zenon_> Is it possible to create data structures in PHP?
02:34:42 <Toxaris> it seems that I'm reinventing category-extras here. Just wrote a function of type Functor f => (f a -> a) -> (Fix f -> a). Now I discovered Control.Functor.Algebra.Algebra f a = f a -> a, which is obviously strongly related.
02:34:56 <_zenon_> oops, wrong channel :)
02:34:58 <Dzlk> Oh, wait, I don't know why I'm thinking of type reps as strings, I don't actually need them.
02:35:19 <electronx> ah well i wanted to get banned from php by bagging the language but it didn't work
02:35:54 <_zenon_> electronx: Good try though
02:36:10 <_Dae_> electronx: all php writers are hippies.... just go in there and tell 'em ya voted for Bush
02:36:30 <Toxaris> What i really want are combinators for algebras, though, are there such things hidden in cat-extras? Or can I just use combinators for functions, since FAlgebras are represented as functions?
02:36:38 <electronx> lol
02:37:27 <Toxaris> I'm totally confused. Is there an introduction to this style of programming somewhere, are there papers related to category-extras, do I really need to go back to reading math books to understand this?
02:37:56 <electronx> <Jck_true> electronx: Obama for president!
02:38:40 <electronx> still not banned
02:39:16 <electronx> someone sugest something that will get me banned from #php without being rude
02:39:28 <electronx> or spamming
02:39:45 <_Dae_> Begin talking about the virtues of ASP?
02:39:53 <electronx> lol
02:40:01 <electronx> probably not
02:40:10 <electronx> need something better
02:41:21 <_Dae_> Start asking for help finding errors in phpBB so you can take down this forum you hate?
02:41:30 <_zenon_> :)
02:41:49 <MrFawkes> I'm not sure why do you care so much. PHP sucks, period.
02:41:50 <electronx> lol
02:42:01 <_Dae_> or just post a link to 4chan
02:42:01 <_zenon_> Proposing other languages? :)
02:42:02 <electronx> i started redirecting people to ruby on rials
02:42:06 <electronx> rails*
02:42:11 <_Dae_> ROFL
02:42:38 <profmakx> well
02:42:46 <profmakx> DON'T tell them to join haskell
02:42:52 <MrFawkes> Start advocating Python with pure CGI, maybe.
02:42:58 <electronx> lol
02:43:01 <profmakx> that everybody is welcome thingy has limits
02:43:12 <kiris> is there a `words' implementation lying about for ByteString?
02:43:49 <_zenon_> electronx: That last one there "then just stick to php" <-- priceless :)
02:45:13 <electronx> lol
02:45:29 <electronx> idits should stick to php
02:45:33 <electronx> idiots*
02:45:52 <Vq^> they really shouldn't
02:46:33 <electronx> if he had half a brain i would have suggested how much faster a better he could complete his site in another language but he struggles with html............
02:46:36 <MrFawkes> Wasn't PHP designed to allow everybody to write simple and wrong "programs", anyway?
02:46:41 <electronx> and*
02:46:41 <Vq^> we stupid people really need the help from a good type-system
02:46:59 <quicksilver> kiris: yes. In ByteString.
02:47:06 <quicksilver> kiris: but make sure you're using the Char version of ByteString.
02:47:22 <quicksilver> kiris: and, if you are using the Char version, spare a moment to think about encodings and what you're trying to acheive :)
02:47:22 <Dzlk> IIRC PHP was designed to allow the author to do some simple stuff for his homepage in a quick & dirty way.
02:47:28 <Toxaris> MrFawkes: php is about "progz", not "programs"
02:47:53 <Vq^> it makes me a bit sad when larger applications is written in it :(
02:48:06 <MrFawkes> I wouldn't know. I saw the docs once and decided not to touch it with a ten-foot pole.
02:48:08 <electronx> yup
02:48:16 <Vq^> like much blog and forum software
02:48:20 <solrize> php5 isn't as bad as the earlier versions
02:48:34 <Vq^> solrize: that doesn't really say much
02:48:34 <profmakx> they got rid of global!~
02:48:36 <profmakx> somwhat!
02:48:37 <electronx> solrize: its as bad as it always was
02:48:44 <MrFawkes> "PHP5 - better than pukes!" ;)
02:48:51 <electronx> no namespaces STILL
02:49:34 <Dzlk> Heh. I told someone once that I won't touch PHP even for money, their reply was "you *can* write good PHP, you know". I said "maybe someone can. *I* can't."
02:50:08 <profmakx> Dzlk, perhaps you could. I could. But I simply won't
02:50:31 <electronx> lol
02:50:33 <MrFawkes> Well, you can write good brainfuck if you try hard enough, too.
02:51:34 <electronx> i had to write a site for a company and they said please do it in php and i said why don't i do it it in ruby or pythong....there reply was whats that
02:51:51 <electronx> dumb shits
02:52:27 <Dzlk> Oh, I probably could if I tried, but I have limited time and brain capacity and I'm unwilling to dedicate a large volume of it to not shooting myself in the foot. :)
02:52:28 <electronx> guess what
02:52:56 <Vq^> electronx: what guess?
02:53:00 <electronx> 6 months later it was scrapped and they asked me to do it in ruby :)
02:53:32 <MrFawkes> heh
02:53:55 <electronx> worst php code i have ever seen
02:54:34 <Dzlk> (Not without good reason anyway. You can easily shoot yourself in the *eye* with Forth but when you do it's usually educational... )
02:56:35 <electronx> they should have to done there own research instead of saying hey everyone uses php so lets use that
03:00:51 <chr1s> electronx: still, php has also some huge advantages over haskell
03:01:25 <chr1s> first of all, if you transfer maintenance to another company, there are lots of people who'll (sort of) understand it
03:02:01 <chr1s> second, php deployment is easy. admins know how to efficiently deploy php sites.
03:02:35 <chr1s> thirdly: there is an enormous code base for web development, which makes it real easy to build new sites.
03:03:07 <chr1s> In some ways, that makes php superior to ruby or haskell for certain projects.
03:04:11 <chr1s> but the language itself and stdlib is extremely crappy, I agree.
03:04:18 <dibblego> I'm wondering what the punchline is
03:07:48 <kiris> quicksilver: ah, sorry. I was working in Emacs on a different workspace. I am using the Char8 version. I still doing the comparison function but trying it with ByteString instead
03:09:05 <kiris> quicksilver: the file may contain UTF-8 but will the encoding matter if I'm just doing pure comparison of what are essentially arrays of chars?
03:09:39 * kiris brings irssi to workspace 1
03:16:20 <quicksilver> kiris: well perhaps not.
03:16:27 <quicksilver> kiris: intuitively it's a bit wrong.
03:16:34 <quicksilver> kiris: but it may not matter for your application
03:16:48 <quicksilver> kiris: (the are arrays of bytes, not arrays of chars, if the encoding is not 1-byte-per-char :P)
03:17:08 <kiris> well, I meant char as in C
03:17:16 <kiris> otherwise I would say Char
03:17:34 <kiris> it turns out the ByteString version of my code is 5 times slower
03:18:44 <quicksilver> heh.
03:19:09 <quicksilver> when I was advising you to use a strict readFile from ByteString I didn' actually mean you to convert your code to ByteString
03:19:19 <quicksilver> just use the strict readFile and keep the rest of the code as-is.
03:20:09 <kiris> use the readFile :: FilePath -> IO ByteString and convert to a String?
03:20:59 <quicksilver> right.
03:21:02 <quicksilver> that is what I had meant.
03:25:58 <kiris> I'm using `show' to convert to a string. is this the proper way?
03:26:03 <kiris> er, String
03:27:01 <opqdonut> no
03:27:10 <opqdonut> > show "lol\"lol"
03:27:16 <lambdabot>  "\"lol\\\"lol\""
03:27:19 <opqdonut> you get all sorts of extra crap
03:27:41 <kiris> well, that's String's instance of Show
03:27:45 <kiris> is ByteString's the same?
03:28:24 <opqdonut> probably
03:28:37 <opqdonut> as show is intended to be pasteable into ghc
03:28:52 <opqdonut> it's more of a serialisation than a string conversion
03:31:03 <Dzlk> Aha!
03:31:14 <kiris> oh, unpack
03:31:28 <kiris> it takes an extra 2 seconds to do the unpacking
03:31:54 <wuxia> kinda OT: what are the interesting research problems in haskell / fuctinal languages these days ?n
03:35:07 <quicksilver> kiris: how much data, roughly?
03:35:41 <kiris> quicksilver: 1.2MB
03:36:28 <hpaste>  kiris pasted "program" at http://hpaste.org/8778
03:37:21 <quicksilver> kiris: 2 seconds to unpack 1.2M I find hard to believe. I suspect you are not measureing what you think you're measuring.
03:37:29 <kiris> ok, one sec
03:38:13 <quicksilver> how did you compile it?
03:38:23 <hpaste>  kiris annotated "program" with "with B.readFile" at http://hpaste.org/8778#a1
03:38:32 <kiris> just with ghc --make Histogram.hs
03:38:38 <quicksilver> kiris: ah well you want -O2
03:38:38 <kiris> -o histogram
03:38:50 <quicksilver> never make speed measurements without using optimisation.
03:38:59 <kiris> quicksilver: what will that do?
03:39:01 <kiris> I'll try it now
03:39:05 <quicksilver> optimise the program.
03:42:03 <hpaste>  kiris annotated "program" with "With -O2 for both versions" at http://hpaste.org/8778#a2
03:42:34 <kiris> so that's a 200ms increase, not bad at all
03:42:46 <kiris> (from String to ByteString readFile)
03:43:33 <quicksilver> kiris: did you run them both more than once, preferably interleaved?
03:43:43 <quicksilver> otherwise the second one probably has an advantage.
03:44:06 <kiris> I ran them a few times, that's about the average
03:44:21 * quicksilver nods
03:44:37 <kiris> do you know of a utility that will run them for me and take averages?
03:45:04 <Baughn> kiris: If the program is deterministic, you should probably be looking for the lowest time, not the average
03:45:41 <opqdonut> well, IO isn't deterministic
03:45:43 <opqdonut> not nowadays
03:45:54 <Baughn> Yes, well..
03:46:13 <Baughn> The purpose of looking for the lowest time is specifically to avoid nondeterminism due to IO or scheduling. ;)
03:47:33 <Philippa> opqdonut: it never has been
03:47:54 <kiris> okay, the readFile :: IO String one takes on average about 2.260, and the readFile :: IO ByteString one takes 2.055
03:48:01 <kiris> after about ten tries each
03:48:01 <Baughn> If you're trying to measure the benefit of async io or such, obviously you'll need the average (or some such).. for purely computational changes, lowest time is more reasonable
03:48:44 <Baughn> kiris: Of course, the main benefit of readFile :: IO ByteString is that aftewards you have a bytestring, not a string
03:48:56 <kiris> but then I convert it to a String
03:49:26 <Baughn> Could be the laziness at work, then?
03:49:52 <Baughn> readFile :: IO String is lazy; the bytestring version isn't (even the lazy bytestring version, really; the chunks are too large to be very noticable)
03:50:42 <kiris> that's what I have `return $! contents', to unlazy it. that gives me a 100ms speed up, IIRC
03:50:44 <quicksilver> Baughn: well not in this case.
03:50:46 <kiris> s/what/why
03:50:58 <quicksilver> Baughn: in this case the main reason to use it was to get a strict readFile
03:51:04 <quicksilver> Baughn: because that's what kiris asked for.
03:51:17 <quicksilver> I did the customary cusrsing that the prelude IO is braindead.
03:51:20 <Baughn> kiris: $! just delazies the very first char, though..
03:51:32 <quicksilver> and then told kiris about strict bytestring readFile
03:51:38 <kiris> Baughn: ah, maybe I should've done $! length foo
03:51:51 <Baughn> kiris: That'd work. Or rnf foo
03:53:09 <Baughn> quicksilver: $! length foo would have to pull all of it into memory, but.. the individual char pointers would still be thunks, wouldn't they?
03:54:40 <kiris> heh, with `return $! length $ contents' it seems to perform 10ms better than the ByteString version
03:55:09 <Baughn> kiris: Try it with return $! Control.Parallel.Strategies.rnf contents
03:55:16 <kiris> oki
03:55:47 <matthew-_> any parsec gurus here?
03:55:58 <Baughn> kiris: (I don't think the $! length foo version does /all/ the work that will get done; a little is still deferred to the actual use of the string)
03:56:09 <matthew-_> I'm doing parsec on stdin via hgetcontents. And using getInput seems to block unreasonably
03:56:14 <matthew-_> any ideas?
03:56:27 <ndmitchell> matthew-_: why not parsec via String?
03:56:37 <ndmitchell> matthew-_: I don't see why you'd need getInput
03:56:42 <Baughn> @hoogle getInput
03:56:44 <kiris> Baughn: performs about as well as ByteString, not better than $! length
03:56:51 <lambdabot> Network.CGI.getInput :: MonadCGI m => String -> m (Maybe String)
03:56:51 <lambdabot> Text.ParserCombinators.Parsec.Prim.getInput :: GenParser tok st [tok]
03:56:51 <lambdabot> Network.CGI.getInputFPS :: MonadCGI m => String -> m (Maybe ByteString)
03:56:58 <Baughn> kiris: No, I expected it to perform worse. I also suspect it's more realistic
03:57:11 <matthew-_> ndmitchell: it's a stream of tokens and I need to deal with tokens as they appear
03:57:19 <matthew-_> and you don't know in advance how long they are
03:57:24 <kiris> Baughn: what is more realistic?
03:57:33 <matthew-_> thus hgetcontents -> String then parsec -> [Foo]
03:57:35 <wuxia> from xmonad source doe:
03:57:37 <wuxia>     [((m .|. modMask, key), screenWorkspace sc >>= flip whenJust (windows . f))
03:57:37 <wuxia>         | (key, sc) <- zip [xK_w, xK_e, xK_r] [0..]
03:57:37 <wuxia>         , (f, m) <- [(W.view, 0), (W.shift, shiftMask)]]
03:57:39 <ndmitchell> matthew-_: i always use parsec directly on strings, without a lexer, it tends to be much more reliable
03:57:43 <Baughn> kiris: See above. I don't think the $! length version does quite all that needs to be done.
03:57:49 <matthew-_> yeah, I'm not using a lexer
03:57:57 <wuxia> how can i modify the following so that alt-y will cycle through my xinerama displays? xmonad source:     [((m .|. modMask, key), screenWorkspace sc >>= flip whenJust (windows . f)) | (key, sc) <- zip [xK_w, xK_e, xK_r] [0..] , (f, m) <- [(W.view, 0), (W.shift, shiftMask)]]
03:58:18 <matthew-_> the problem is knowing in advance how many bytes to block waiting for
03:58:22 <ndmitchell> matthew-_: do s <- hGetContents h; parse my_parser "stdin" s
03:58:45 <Baughn> kiris: In particular, while the entire string backbone does get constructed, the individual Chars probably aren't; they'll still be references to arrays read by the I/O system (which takes less space). Copying them into individual Chars will take some time.
03:58:45 <ndmitchell> matthew-_: use that fragment of code, an d don't use getInput - i don't think i've ever done parsec using it
03:58:57 <kiris> Baughn: I see. but the program is completing with results, and I am splitting up the file with `words', which I'd imagine is O(n)
03:59:16 <Baughn> kiris: Then again, if there's utf-8 parsing in there, they'll already be split up.. gah
03:59:46 <kiris> Baughn: I don't follow. UTF-8 parsing would make what split up?
03:59:50 <Baughn> kiris: Oh, I see. I was assuming you were forcing it into memory because you didn't proceed to use it
03:59:58 <kiris> Baughn: ah, I see
04:00:18 <matthew-_> ndmitchell: but the parser returns Either so that's not lazy
04:00:31 <kiris> it's just a simple program to make a histogram of the 20 words in a file: http://hpaste.org/8778
04:00:37 <Baughn> kiris: Well, if you're parsing utf-8 then, to figure out how many chars are in a file, you also need to split the bytes up into individual chars
04:00:40 <kiris> s/of the/of the top/
04:00:43 <matthew-_> so surely that would force the whole input to be evald
04:00:51 <ndmitchell> matthew-_: oh, yeah, i don't think you can get a lazy parser out of parsec, i'm afraid
04:00:53 <Baughn> kiris: Although, I think.. readFile might not do that. :/
04:00:54 <kiris> Baughn: ahhh, indeed
04:00:59 <matthew-_> GRRRRRR
04:01:00 <ndmitchell> or at least i've never managed it
04:01:12 <matthew-_> yeah, well ours is fine, right up to the getInput call
04:01:13 <ndmitchell> for Hoogle, i do lines, then parse each line individually with parsec
04:01:24 <matthew-_> yeah, we don't necessarily have lines
04:01:25 <ndmitchell> i don't think it was designed for that
04:01:35 <ndmitchell> have you read malcolm's lazy parsing paper?
04:01:49 <ndmitchell> that explains hwo to do it, and the library is included in polyparse
04:02:06 <matthew-_> ahh ok
04:02:15 <ndmitchell> @google malcolm walace lazy parsing
04:03:25 <ndmitchell> hmm, i can't find his paper online - but http://www.cs.york.ac.uk/fp/polyparse/ is the library
04:03:32 <ndmitchell> and i think PolyParse.Lazy is the module]
04:03:47 <kiris> Baughn, quicksilver: why specifically -O2? I'd imagine O1 is for compiling huge projects that would take ages to compile at higher... otherwise why would you ever want slower optimisation? unless GHC makes some dangerous optimisations..
04:04:00 <Baughn> kiris: -O2 is /considerably/ slower than -O1
04:04:09 <kiris> I see
04:04:10 <Baughn> kiris: When you're compiling a new version every thirty seconds, that matter
04:04:11 <Baughn> s
04:04:19 <kiris> Baughn: true
04:04:23 <Baughn> Actually I use -Onot half the time
04:04:38 <kiris> -Onot means don't bother optimising?
04:04:56 <Baughn> It means "Don't optimize, at all"
04:05:06 <Baughn> "Even things that are obvious and would take no time"
04:05:14 <kiris> hehe
04:05:33 <Baughn> The purpose of this is so I don't get potential space leaks that are plugged by the optimizer and then randomly show up in later versions
04:05:41 <ndmitchell> I use Hugs all the time
04:06:04 <_Dae_> why?
04:06:06 <ndmitchell> its got instant compile times, and as I'm always developing stuff that's very useful
04:06:22 <_Dae_> thus answered
04:06:39 <Baughn> Same goes for ghci, of course. Any other advantages to hugs?
04:06:53 * Baughn types :reload a lot
04:07:00 <kiris> I couldn't load ByteString in ghci for some odd error
04:07:06 <kiris> yeah, :r is lovely
04:07:22 <ndmitchell> plus auto-reload
04:07:32 <ndmitchell> in WinHugs, I never do :r, it does it automatically if the files change
04:08:03 <kiris> Prelude> :l Data.ByteString => <no location info>: module `Data.ByteString' is a package module \n Failed, modules loaded: none.
04:08:59 <kiris> when I'm in the middle of writing a program I'll just switch to whatever is easiest because I don't want to be concentrating on why Ghci has some issue and so I just used ghc --make instead v_v
04:09:10 <_Dae_> 'cos it's a packagemodule? you can use import instead
04:09:32 <kiris> wow
04:09:40 <kiris> I'm not sure how that one slipped over my head
04:10:21 <Baughn> kiris: Or :m +
04:10:21 <wuxia> can someone please cplain to me what the following means? :     [((m .|. modMask, key), screenWorkspace sc >>= flip whenJust (windows . f))
04:10:25 <wuxia>         | (key, sc) <- zip [xK_w, xK_e, xK_r] [0..]
04:10:27 <wuxia>         , (f, m) <- [(W.view, 0), (W.shift, shiftMask)]]
04:11:10 <kiris> Baughn: yeah, I usually do that. I guess I was just concentrating on how to use ByteString and used :l out of habbit. damn
04:11:29 <kiris> this is like when I was looking for my glasses for ages which were on my face
04:11:42 <kiris> I don't even know how I do it
04:11:58 <_Dae_> it's a side effect of geekiness....
04:13:13 <Botje> wuxia: what part don't you get?
04:13:23 <kiris> well, off to driving lessons. here's hoping I don't hit accelerate instead of break when stopping at a crossing
04:14:05 <_Dae_> > putStrLn "> putStrLn (show 3)"
04:14:06 <lambdabot>  <IO ()>
04:14:19 <wuxia> Botje: the flip whenJust part, also why is it that when i hold down shift, it moves a client to screen rather than switchin to the screen
04:14:31 <wuxia> Botje: can you pm me and I can paste you the comments as well?
04:15:43 <Botje> @unpl screenWorkspace sc >>= flip whenJust (windows . f))
04:15:44 <lambdabot> Unbalanced parentheses
04:15:44 <mjrosenb> _Dae_: did lambdabot just tell you the type of that or did something else just happen that made a whole lot less sense?
04:15:46 <Botje> @unpl screenWorkspace sc >>= flip whenJust (windows . f)
04:15:46 <lambdabot> ((screenWorkspace sc) >>= \ c -> whenJust c (\ g -> windows (f g)))
04:16:02 <Botje> wuxia: i don't really know anything about xmonad, sorry :)
04:16:07 <Botje> but maybe that @unpl helps
04:16:11 <wuxia> :t whenJust
04:16:12 <lambdabot> Not in scope: `whenJust'
04:16:28 <wuxia> Botje: np, thanks for help/effort
04:16:36 <_Dae_> mjrosenb: I have no idea.... I was trying to see if lambdabot evaluated its own expressions
04:16:56 <mjrosenb> _Dae_: it looked something like that
04:17:06 <_Dae_> > putStrLn (show 3)
04:17:07 <lambdabot>  <IO ()>
04:17:15 <mjrosenb> _Dae_: i should hope not, or a quine would make it really sad
04:17:22 <mjrosenb> _Dae_: i think that print works
04:17:24 <Baughn> _Dae_: Runplugs returns a String, not anything of type IO. It can't do impure computations
04:17:29 <mjrosenb> > print "hi"
04:17:30 <lambdabot>  <IO ()>
04:17:35 <mjrosenb> or not
04:17:42 <_Dae_> > "hi"
04:17:43 <lambdabot>  "hi"
04:17:44 <Baughn> It just converts anything of type IO to, well, that
04:17:50 <_Dae_> right...
04:17:50 <Baughn> > getLine
04:17:52 <lambdabot>  <IO [Char]>
04:18:13 <_Dae_> > show 3
04:18:13 <lambdabot>  "3"
04:18:15 <Feuerbach> Do I get it right, that file xxx uploaded to code.haskell.org:~ should be accessible as http://code.haskell.org/~feuerbach/xxx ?
04:18:46 <_Dae_> Feuerbach.... german atheist?
04:19:04 <Feuerbach> _Dae_: yeah, and his brother was mathematician
04:19:11 <quicksilver> Feuerbach: code.haskell.org:public_html/
04:19:16 <_Dae_> Feuerbach: Never know that
04:19:28 <quicksilver> Feuerbach: webservers don't make your whole home directory available, typically, that would be bad
04:19:53 <Feuerbach> quicksilver: thanks :)
04:20:26 <wuxia> in particular, that might open up stuff like .ssh
04:20:29 <wuxia> which would be doubly bad
04:20:44 <_Dae_> wuxia: lies.... everyone should have root access
04:20:57 <Baughn> wuxia: Don't you trust us?
04:21:21 <wuxia> of course I do; that is why my ip address is 127.0.0.1 and I have the same root password as u
04:21:58 <wuxia> auctually, i don't even run sshd
04:22:25 <wuxia> (to newbs out there: 127.0.0.1 is ur own cmputer)
04:22:44 <_Dae_> The only protection my computer needs is the glorious light of my awesomeness
04:22:58 <wuxia> i'm a haskell newb: how do I modify the following so taht when i hit alt-y, it will alternative between screen 0 and scren 1? the existing xmonad code has been simplified to:     [((modMask, key), screenWorkspace sc >>= flip whenJust (windows . W.view)) | (key, sc) <- [(xK_w, 0), (xK_e, 1)]]
04:23:18 <wuxia> i think there's a one line fix, but I don't understand haskell monads well eno7ugh to do it
04:23:25 <wuxia> so right now, when I hit alt-w, i get screen 0
04:23:31 <wuxia> when i hit alt0e, i get screen 1
04:23:44 <wuxia> i want a small change where when I hit alt-y, it alternates  between the 2
04:23:54 <wuxia> i.e. if i'm on screen 0, it puts me into screen 1; if i'm in screen 1, it puts me into screen 0
04:24:03 <wuxia> so i think i need a monad to keep track of some state here; but i don't know how to do that
04:24:07 <wuxia> can any oe you help me?
04:24:09 <quicksilver> little bit hard to distangle without knowing a bit more about the library you're using.
04:24:22 <Botje> it's xmonad
04:24:24 <quicksilver> ah.
04:24:31 <wuxia> it's xmonad; what cna I do to provide u more info?
04:24:37 <quicksilver> I'll defer to someone who knows xmona.d
04:24:39 <wuxia> i'm also willing to type in arbitrary code, with reason
04:24:44 <quicksilver> I bet there is a way to query current workspace
04:24:52 <quicksilver> in order to be able to flip to the other one.
04:24:57 <wuxia> no no, i just need some one with basic knowldge of moands
04:25:13 <wuxia> so the (modMask, key) part is for matching vs alt0w, alt-e
04:25:15 <quicksilver> ah, you'll have no luck wiht me. I only have advanced knowledge of monads.
04:25:28 <wuxia> the sreenWorkspace .... part ; I think, generatres the action taht does the flipping
04:25:34 <_Dae_> quicksilver is an IRC bot without access to his computers graphics drivers, so GUI programming is a bit hard for him
04:25:43 <wuxia> i just need a really small monad that keeps track of what the current screen is
04:26:02 <quicksilver> well I doubt you do, beause I imagine the xmonad monad already keeps track of that
04:26:09 <quicksilver> easier to access existing state than invent new
04:26:20 <wuxia> good point
04:26:22 <wuxia> time to grep
04:26:48 <wuxia> -- | Return workspace visible on screen 'sc', or Nothing.
04:26:48 <wuxia> screenWorkspace :: ScreenId -> X (Maybe WorkspaceId)
04:26:48 <wuxia> screenWorkspace sc = withWindowSet $ return . W.lookupWorkspace sc
04:26:55 <wuxia> does this look like it's setting state anywhere?
04:27:12 <quicksilver> what looks like it's getting state, to me.
04:27:19 <quicksilver> judging by the comment :)
04:27:39 <Botje> wuxia: check the definition of "view", rather
04:27:40 <wuxia> hmm, so it should be the flip whenJust thing that maybe sets the state
04:27:52 <quicksilver> what does the xmonad version of whenJust do?
04:28:02 <quicksilver> it looks like it ignores the actual value inside the Just
04:28:09 <quicksilver> this is not how I choose to define whenJust ;)
04:28:22 <quicksilver> I think it's calling screenWorkspace but ignoring the value
04:28:28 <quicksilver> (only accounting for if it's Nothing or Just)
04:28:37 <Botje> whenJust val bod =~ when (isJust val) bod ?
04:28:39 <wuxia> -- | Conditionally run an action, using a @Maybe a@ to decide.
04:28:39 <wuxia> whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
04:28:39 <wuxia> whenJust mg f = maybe (return ()) f mg
04:29:10 <wuxia> hmm, view is more than  5 lines :-(
04:29:29 <quicksilver> hmm. that is the way I define whenJust
04:29:32 <wuxia> -- /O(w)/. Set focus to the workspace with index \'i\'.
04:29:32 <wuxia> -- If the index is out of range, return the original StackSet.
04:29:39 <wuxia> atleast the vomment looks good (for view)
04:29:43 <quicksilver> I wonder where the parameter went
04:29:54 <wuxia> .paste
04:29:56 <quicksilver> oh, my bracketing was wrong.
04:30:00 <wuxia> ?paste
04:30:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:30:01 <quicksilver> parse failure!
04:30:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8780
04:30:41 <wuxia> http://hpaste.org/8780 <-- view
04:31:05 <wuxia> okay, so the state is being set there ... ahny idea how it's being read out?
04:32:24 <Botje> what do you mean read out?
04:32:40 <Botje> the "i == currentTag s" part checks if it's the current workspace
04:32:44 <wuxia> i want alt-y to figure out what the current screen is
04:32:51 <wuxia> then subtract it from 1, to get the new screen i want
04:32:56 <wuxia> i.e. 0 -> 1; 1 -> 0
04:33:04 <wuxia> question now is ... how do I read out what the current screen is
04:33:25 * Botje points to the currentTag function
04:33:49 <wuxia> great, let's see if I can  xmessage this out
04:37:24 <wuxia>     [((modMask, xK_r),  spawn $ "xmessage -default okay " ++ "hello world")]
04:37:28 <wuxia> that does an xmessagbe properly
04:37:39 <wuxia> what args to I pass to currentTag ?
04:38:28 <wuxia> view :: (Eq s, Eq i) => i -> StackSet i l a s sd -> StackSet i l a s sd -- how should this be interpreted; I don't understand what the => means since it's arg is an index \i\, not a tuple
04:38:57 <mjrosenb> wuxia: perhaps you should check in #xmonad
04:39:59 <wuxia> :t =>
04:40:00 <lambdabot> parse error on input `=>'
04:40:45 <mjrosenb> wuxia: that's not a function; it's part of the type
04:41:17 <wuxia> what does => mean? previous types i have seen only use ->
04:41:47 <wuxia> :t flip
04:41:48 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:42:29 <mjrosenb> wuxia: it has to do with typeclasses
04:42:34 <mjrosenb> :t (==)
04:42:35 <lambdabot> forall a. (Eq a) => a -> a -> Bool
04:43:02 <mjrosenb> see, (==) is something that only makes sense on values that have equality defined for them
04:43:11 <mjrosenb> so (==2) makes sense
04:43:18 <mjrosenb> :t (==2)
04:43:18 <lambdabot> forall a. (Num a) => a -> Bool
04:43:34 <mjrosenb> but there's no equality defined on functions
04:43:36 <mjrosenb> so
04:43:45 <mjrosenb> :t (==(\x ->x))
04:43:46 <lambdabot> forall t. (Eq (t -> t)) => (t -> t) -> Bool
04:44:12 <mjrosenb> will eventually fail when you try to actually instantiate all of the classes
04:44:20 <mjrosenb> > ((\x -> x)==(\x ->x))
04:44:21 <lambdabot>   add an instance declaration for (Eq (t -> t))
04:44:21 <lambdabot>     In the expression: ((\ x ...
04:44:34 <carl_> can someone explain why this is wrong M is Data.Map and m is of type (Map String (Word32, Word16))
04:44:38 <carl_> getCharacter :: String -> CharacterList -> (Word32, Word16)
04:44:40 <carl_> getCharacter name (CharacterList m) = M.lookup name m
04:44:59 <carl_>  Couldn't match expected type `Word16'
04:44:59 <carl_>            against inferred type `(Word32, Word16)'
04:44:59 <carl_>       Expected type: M.Map String Word16
04:44:59 <carl_>       Inferred type: M.Map String (Word32, Word16)
04:45:43 <Botje> carl_: uh, your type says you return (Word32, Word16)
04:45:51 <Botje> oh
04:46:14 <Botje> carl_: are you sure the type of the map is correct?
04:46:33 <rwbarton> is that error message coming from those lines, or somewhere else?
04:46:37 <Botje> carl_: also, lookup is of type m a
04:46:43 <Botje> what monad is that code supposed to work in?
04:46:44 <carl_> no its those lines
04:46:55 <wuxia> how do i get lambda bot to 'unpack' an ecpression for me?
04:47:02 <Botje> wuxia: like @unpl does?
04:47:17 <mjrosenb> wuxia: what do you mean by unpack?
04:47:23 <carl_> im not entirely sure all im trying to do is store tuples in a Map
04:47:27 <Botje> carl_: lookup has type m (Word32, Word16), whereas your function has return type (Word32,Word16)
04:47:54 <wuxia> @unpl screenWorkspace 0 >>= flip whenJust (windows . W.view)
04:47:54 <lambdabot> ((screenWorkspace 0) >>= \ c -> whenJust c (\ f -> windows (W.view f)))
04:47:57 <Botje> carl_: so the easy fix is fromJust $ M.lookup ...
04:47:59 <wuxia> Botje:  thanks
04:48:48 <rwbarton> carl_: If you just want to look something up, use M.!
04:48:54 <carl_> ok so you have to specify the monad
04:49:01 <quicksilver> Botje: the error message carl_ gave doesn't appear consistent with your answer.
04:49:12 <carl_> one sec ill check
04:49:25 <rwbarton> Maybe it thinks (,) Word32 is the monad or something
04:49:31 <Botje> yeah, that's what i figured
04:49:39 <rwbarton> In fact, that makes sense
04:49:42 <wuxia> how do I look up how ">>=" is defined (getting lots of false positive matches from grep)
04:50:01 <Botje> wuxia: >>= is defined for the X monad
04:50:03 <chr1s> wuxia: it depends on the monad.
04:50:08 <Botje> it just executes the action to the left
04:50:12 <Botje> and passes the result to the right
04:50:42 <wuxia> >>= is defined in the X11 monad?
04:50:56 <Botje> :t Data.Map.lookup "foo" (undefined :: Data.Map.Map String (Int,Int)) :: (Int,Int)
04:50:59 <lambdabot>     Couldn't match expected type `Int'
04:51:00 <lambdabot>            against inferred type `(Int, Int)'
04:51:00 <lambdabot>       Expected type: M.Map [Char] Int
04:51:04 <wuxia> so how would: screenWorkspace 0 >>= flip whenJust (windows . W.view) -- be rewritten?
04:51:17 <carl_> ok the justMaybe worked
04:51:18 <Botje> quicksilver: see above :)
04:51:18 <carl_> thx
04:51:33 <Botje> carl_: you might want to do something different if you get Nothing back, though
04:51:46 <Botje> carl_: check Data.Maybe and the maybe function for that
04:51:59 <carl_> yea
04:52:09 <carl_> no i know why it wasnt working now thx
04:52:34 <Botje> wuxia: probably get the current workspace ID and pass it to screenWrokspace
04:52:42 * Botje goes sourcediving
04:54:33 <rwbarton> @do screenWorkspace 0 >>= flip whenJust (windows . W.view) -- maybe you'd prefer that?
04:54:33 <lambdabot> screenWorkspace 0 >>= flip whenJust (windows . W.view) -- maybe you'd prefer that? not available
04:54:41 <rwbarton> Hmm, that didn't do what I wanted.
04:55:24 <Botje> carl_: gets windowsset >>= \ws -> screenWorkspace (1 - (currentTag ws)) >>= flip ...
04:55:25 <quicksilver> do {w <- screenWorkspace 0; whenJust w $ \ww -> windows (W.view w) }
04:55:28 <quicksilver> I think.
04:55:47 <Botje> untested but i think that should do the trick
04:55:55 <Botje> also, windowset not windowsset
04:56:09 <Botje> gets windowset >>= \ws -> screenWorkspace (1 - (currentTag ws)) >>= flip whenJust (windows . W.view)
04:56:16 <wuxia> let me test ikt out
04:57:30 <u_quark> is there a way to catch an error "msg" outside the IO monad ?
04:57:50 <SamB_XP> u_quark: from the "error" function? no.
04:57:52 <wuxia> not in scope: currentTag
04:58:00 <Botje> wuxia: W.currentTag, then
04:58:14 <SamB_XP> u_quark: you could of course use unsafePerformIO, but hopefully the name sounds scary to you?
04:58:37 <hpaste>  wuxia pasted "error message" at http://hpaste.org/8781
04:58:39 <quicksilver> u_quark: you should never catch 'error', neither inside nor outside the IO monad.
04:58:41 <u_quark> no its not scary ... lol... just i dont like it
04:58:45 <wuxia> Botje: http://hpaste.org/8781
04:58:51 <quicksilver> error is not for catching.
04:58:55 <Botje> unsafeEatBabiesAndMaybePerformIO
04:59:04 <u_quark> lol
04:59:06 <quicksilver> if you want something catchable use thrownDyn.
04:59:11 <SamB_XP> I catch it and add info to it in one of my programs ...
04:59:37 <SamB_XP> (it implements a VM, and I add the PC to the message)
04:59:52 <Botje> wuxia: hmm
05:00:11 <SamB_XP> also, occasionally you want to catch ANYTHING
05:00:22 <quicksilver> catch doesn't catch ANYTHING
05:00:29 <SamB_XP> say, when implementating lazy smallcheck
05:00:32 <quicksilver> it only catches ioErrors, doesn't it?
05:00:46 <SamB_XP> quicksilver: that entirely depends on which catch you mean ;-)
05:02:06 <Botje> sigh
05:02:13 <Botje> i'll just darcs get it :/
05:02:25 <Botje> i think you have to use the peek function
05:02:29 <wuxia> ur so awesome :-)
05:03:54 <u_quark> quicksilver: if i want to catch something i didn't throw myself ? like from read
05:04:20 <quicksilver> don't.
05:04:27 <quicksilver> error is a bug and shouldn't be caught.
05:04:41 <quicksilver> by extension, don't use read unless you can guarantee it will parse.
05:04:43 <quicksilver> use reads.
05:06:57 <quicksilver> > let readMaybe x = case reads x of [(xx,s)] | all isSpace s -> Just xx ; _ -> Nothing in map readMaybe ["123","abc","1.34"] :: [Maybe Int]
05:06:58 <lambdabot>  [Just 123,Nothing,Nothing]
05:07:04 <quicksilver> > let readMaybe x = case reads x of [(xx,s)] | all isSpace s -> Just xx ; _ -> Nothing in map readMaybe ["123","abc","1.34"] :: [Maybe Double]
05:07:09 <lambdabot>  [Just 123.0,Nothing,Just 1.34]
05:07:10 <u_quark> ok i am starting to understand ...
05:07:27 <quicksilver> some would argue that 'readMaybe' deserves to be in the standard lib.
05:07:57 <u_quark> where is readMaybe now ?
05:08:19 <quicksilver> 4 lines above your head
05:08:31 <u_quark> :P
05:08:31 <quicksilver> defined there in that lambdabot expression :P
05:08:41 <audreyt> @seen Lemmih
05:08:41 <lambdabot> I haven't seen Lemmih.
05:08:43 <quicksilver> it's a simple wrapper around reads
05:08:46 <quicksilver> but a more useful one
05:12:23 <u_quark> so there is nowhere in the prelude some error "" that might be interesting to catch ... ?
05:13:40 <quicksilver> there shouldn't be.
05:14:23 <quicksilver> u_quark: http://www.haskell.org/haskellwiki/Error
05:14:24 <lambdabot> Title: Error - HaskellWiki
05:14:41 <u_quark> ok tnx!
05:15:03 <quicksilver> it's not a hard and fast rule.
05:15:14 <quicksilver> SamB_XP gave a reasonable example of why you might want to catch an error
05:15:18 <quicksilver> but it's a pretty strong guideline
05:22:41 <wuxia> data XState = XState { windowset    :: !WindowSet           -- ^ workspace list
05:22:45 <wuxia> what does the ! mean?
05:22:57 <quicksilver> strict
05:23:32 <wuxia> what does strict mean?
05:25:12 <quicksilver> long story.
05:25:19 <quicksilver> the opposite of lazy, generally.
05:25:19 <Feuerbach> wuxia: it is evaluated to WHNF at the same time as data itself
05:25:21 <quicksilver> try http://www.haskell.org/haskellwiki/Non-strict_semantics
05:25:22 <lambdabot> Title: Non-strict semantics - HaskellWiki
05:25:23 <quicksilver> or a start.
05:25:37 <quicksilver> for a start, I mean.
05:26:29 <Feuerbach> wuxia: for data type, WHNF means that you know its constructor
05:29:33 <Philippa> wuxia: the literal meaning is a function that, if you pass in something that doesn't evaluate cleanly (technically, evaluates to _|_ or "undefined"), itself doesn't evaluate cleanly
05:30:14 <Philippa> in this particular case, that's the constructor. So what it actually /means/ is that it forcibly evaluates the parameter straight away rather than when the XState is pattern-matched on
05:30:38 <ski> well
05:32:00 <Philippa> yeah, okay, slight error there: after it's pattern-matched on and the component demanded again
05:32:13 <ski> it will evaluate the field when the whole state is evaluated .. which need not be anytime close to "encountering" the construction itself
05:32:13 <LordBr4in> hey
05:33:42 <wuxia> I havbe a : \ws, ws is of type: type WindowSet   = StackSet  WorkspaceId (Layout Window) Window ScreenId ScreenDetail -- now, how do I pull out the ScreenId ?
05:34:14 <LordBr4in> if i have a type Tree a, where a is arbitrary... how can i write the an Arbitrary instance for it so that i can use QuickCheck ?
05:34:48 <ski> \(StackSet wid lay win sid sdet) -> ..sid..
05:35:35 <wuxia> ski: thanks
05:35:49 <hpaste>  Botje pasted "switch for xmonad" at http://hpaste.org/8782
05:35:57 <Botje> there.
05:36:00 <Botje> it typechecks
05:36:04 <Botje> that's all i can do atm
05:36:13 <wuxia> Botje: awesome; thanks!
05:36:34 <Botje> put that switch = do ... somewhere
05:36:44 <Botje> and then just put switch in place of that screenWorkspace 0 >>= ...
05:36:58 <wuxia> testing it out right now
05:37:25 <Botje> it _WILL_ fail horribly if there's only one workspace
05:37:36 <Botje> but fixing that is left as an exercise for the interested reader
05:38:23 <LordBr4in> nvm.. i could just use arbitrary as the value for a
05:41:15 <wuxia> Botje: that does the same as: screenWorkspace 1 >>= flip whenJust (windows . W.view)
05:45:40 <Botje> bah
05:45:46 <Botje> back to the drawing board :[
05:45:46 <wuxia>     , ((modMask, xK_y), gets windowset >>= \(W.StackSet wid win sid sdet) -> screenWorkspace sid >>= flip whenJust (windows . W.view))
05:45:51 <wuxia> that is almost it I think
05:45:55 <wuxia> except I'm having typ errors
05:46:04 <wuxia> sid shoudl be a screenId, but somehow i'm getting:
05:46:12 <wuxia>     Couldn't match expected type `ScreenId'
05:46:12 <wuxia>            against inferred type `[W.Workspace
05:46:13 <wuxia>                                      WorkspaceId (Layout Window) Window]'
05:46:31 <wuxia> (this is based on the code you pasted me before getting xmonad over darcs)
05:49:55 <ski> wuxia : oh, sorry, mea culpa .. i glossed over your type definition as having been a `data' declaration
05:50:11 <chessguy> @hoogle [a] -> [[a]]
05:50:12 <lambdabot> Data.List.inits :: [a] -> [[a]]
05:50:12 <lambdabot> Data.List.tails :: [a] -> [[a]]
05:50:12 <lambdabot> Data.List.group :: Eq a => [a] -> [[a]]
05:50:13 <chessguy> @bot
05:50:13 <lambdabot> :)
05:50:20 <chessguy> @src group
05:50:20 <lambdabot> group = groupBy (==)
05:50:22 <wuxia> ski: huh? how should i  rewrite it?
05:50:27 <ski> so you have a value of type `StackSet  WorkspaceId (Layout Window) Window ScreenId ScreenDetail'
05:50:36 <ski> whatever that means, i don't know
05:50:40 <wuxia> yeah, it's opkay, i know that there ar eonly 4 arguments
05:50:56 <wuxia> the problem is taht my sid is not mathicng against ScreenId, but somehow having type: WorkspaceId (Layout Window) Window
05:51:00 <wuxia> it's raelly weird
05:51:00 <ski> presumably, there's operations regarding `StackSet', that can help you extract what you want
05:51:17 <wuxia> why can't I specify pattern match on the constrctor?u
05:51:24 <ski> you can
05:51:33 <ski> but you have to know what the constructor is
05:51:33 <wuxia> can you tell me the syntax to do that?
05:51:51 <ski> maybe you can provide the definition of the *type* `StackSet' ?
05:52:41 <hpaste>  wuxia pasted "stackset" at http://hpaste.org/8783
05:52:47 <hpaste>  chessguy pasted "brainteaser" at http://hpaste.org/8784
05:53:09 <ski> ok, so it's a record
05:53:41 <wuxia> \(W.StackSet i l a sid set) <---- from my erro rmessage seems like this is trying to call the constructor ra5ther than patterh match
05:53:53 <wuxia>    Constructor `W.StackSet' should have 4 arguments, but has been given 5
05:53:53 <wuxia>     In the pattern: W.StackSet i l a sid set
05:53:54 <wuxia>     In the second argument of `(>>=)', namely
05:54:20 <ski> wuxia: so, possibly there's `ScreenId's inside both the `current' and the `visible' field
05:54:39 <wuxia> okay
05:54:45 <wuxia> let's pull it out ofv the 'current' one
05:56:22 <wuxia> (W.current ws) <-- this gets me a Screen, a Screen is (Screen i l a sid sd)
05:56:26 <wuxia> how do I pull the sid ou tof it?
05:57:08 <quicksilver> let Screen i l a sid s = W.current ws in .... (use sid in here)
05:58:36 <kpreid> let Screen _ _ _ sid _ = W.current ws in ...
05:59:17 <kpreid> or see if there's a provided function (Screen -> Sid) (type variables as appropriate...)
05:59:30 <Botje> yeah
05:59:34 <Botje> there's a function screen
05:59:36 <Botje> to get the sid out
06:00:10 <wuxia> oh; guess what, it's named screen; doh; thanks
06:01:27 <wuxia> OMG
06:01:28 <wuxia> it
06:01:28 <wuxia> works
06:01:30 <wuxia>     , ((modMask, xK_y), gets windowset >>= \ws -> screenWorkspace (1 - (W.screen (W.current ws))) >>= flip whenJust (windows . W.view))
06:01:35 <Botje> yay
06:01:38 <wuxia> thansk for everyhone's help, especially Botje
06:01:51 <Botje> i figured out a rapper crappy way to do it :p
06:01:53 <wuxia> I think I averaged maybe 10 chars per hour for this line of code
06:02:06 <quicksilver> most haskell programmers would think that code obfuscated
06:02:18 <wuxia> okay, how shouuld i make it clearn?
06:02:18 <quicksilver> I'd write the do notation version I think.
06:02:29 <Botje> gets windowset >>= screenWorkspace . W.screen . head . W.visible >>= flip whenJust (windows . W.view)
06:03:02 <wuxia> it's gam here
06:03:05 <wuxia> err, 6 am
06:03:13 <wuxia> i'm going to copy taht line u suggsted, sleep, and read it when I wake up :-)
06:03:26 <quicksilver> do { ws <- gets windowset; sw <- screenWorkspace ( 1 - (W.screen (W.current ws))); whenJust sw (\sww -> windows (W.view sww)) }
06:03:30 <quicksilver> on three separate lines
06:03:36 <quicksilver> (newlines instead of ;)
06:03:41 <quicksilver> would be my preference.
06:03:54 <wuxia> got it; copied that down too
06:03:58 <wuxia> thanks again evberyhone; later
06:04:04 <Botje> good night :)
06:04:55 <smg> hello.
06:05:03 <smg> [("",Add 2 2)]
06:05:07 <quicksilver> I really feel sorry for people who are forced to learn the visitor pattern as part of their programming course.
06:05:19 <smg> how can i get Add 2 2 out of this?
06:05:26 <Botje> smg: snd . head ?
06:05:44 <Botje> quicksilver: people just look at me funny when i say "but it's just fold
06:05:47 <quicksilver> let [("",x)] = [("",Add 2 2)] in .... (now use x)
06:05:50 <Botje> *foldM!
06:06:01 <smg> jsut !! 0
06:07:11 <quicksilver> Botje: it's a bit more than that.
06:07:19 <quicksilver> Botje: it's the inversion of a class hierarchy into an interface
06:07:37 <smg> Botje: indeed, i messed up
06:07:41 <quicksilver> Botje: which, effectively becomes an interface representing the "case" elimination for that hierarchy viewed as an ADT.
06:09:37 <_zenon_> (\[(_,Add x y)] -> y) [("",Add 2 2)]
06:09:56 <smg> hehe
06:10:33 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8785
06:10:57 <smg> i need to extend the grammar to have any expression like "2*3+4*1"
06:11:02 <smg> should i use a shift reduce parser?
06:16:19 <Baughn> smg: I don't see why not. If your grammar fits, as that one would..
06:17:05 <Baughn> smg: A recursive-descent parser (okay, parsec) would /work/, but might be slower. This might not matter. It might also be harder to read, under the circumstances. This might.
06:17:20 <smg> okay
06:21:37 <quicksilver> I woudl personally stick to recdescent unless you know performance is the issue. Simpler tool.
06:24:00 <smg> recdescent? quicksilver?
06:24:10 <smg> quicksilver: i know LR(1) aka shift reduce parser
06:24:15 <smg> is there something in haskell already?
06:27:11 <ziman> happy
06:27:17 <smg> ah :)
06:27:33 <smg> i need to install first it with cabal?
06:28:28 <Philippa> smg: Parsec's LL(omega) with LL(1) as a default and some helpful combinators for handling things like left-recursion. The way it handles lookahead can be confusing, but otherwise it's pretty quick to learn
06:29:14 <ziman> i guess so (i'm a gentoo user, it works automagically for me)
06:29:24 <smg> erm, emerge happy?
06:29:27 <ziman> yes
06:29:41 <smg> ah okay i thought i would need cabal
06:30:22 <ziman> the good guys out there have made an ebuild for us :)
06:30:36 <smg> hehe
06:45:41 <mjrosenb> @src join
06:45:41 <lambdabot> join x =  x >>= id
06:46:55 <quicksilver> there is something rather unsatisfying about that definition I find :)
06:47:04 <Botje> yes
06:47:10 <Botje> the id confused me for a LONG time :)
06:47:35 <Botje> ooh
06:47:44 <Botje> I still have to implement a typechecker for my compiler
06:47:49 <Botje> it'll have to wait :)
06:48:02 <mapreduce> Is it equivalent to: join x y = x >>= id y ?
06:48:45 <Botje> (x >>= id) y
06:48:45 <Botje> sure :p
06:49:18 <Kristoffer> my code can't find Graphics.UI.Gtk on vista
06:51:15 <ddarius> quicksilver: What's unsatisfying?
06:51:48 <_Dae_> Kristoffer: and you have installed Gtk?
06:53:32 <Kristoffer> Yes, and run some gtk program called gconftool-2.exe
06:54:38 <quicksilver> ddarius: it makes join look harder than it is somehow.
06:55:18 <ddarius> It's nice and compact, and it meshes well with the definition of (>>=) in terms of join and fmap.
06:55:46 <opqdonut> yeah
06:55:58 <_Dae_> Kristoffer: no clue then....
06:56:19 <Kristoffer> Thanks anyway
06:57:42 <_Dae_> haven't really tried using haskell on vista, much less xmonad
06:58:31 <Kristoffer> I will install linux and try there
06:58:43 <Kristoffer> bye for now
07:08:15 * fiddlerwoaroof has discovered the joys of haskell with the discovery of >=>
07:08:41 <saml> :t (>=>)
07:08:44 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
07:09:19 <ddarius> :t readFile >=> print
07:09:24 <lambdabot> FilePath -> IO ()
07:09:53 <saml> > (getLine >=> putStrLn) "yay"
07:09:55 <lambdabot>  Couldn't match expected type `a -> m b'
07:10:00 <EvilTerran> fiddlerwoaroof, yeah, that one's really useful. don't know why we didn't think of it earlier
07:10:12 <EvilTerran> it makes the exioms really nice, too
07:10:15 <EvilTerran> *axioms
07:10:29 <EvilTerran> (f >=> return) = (return >=> f) = f
07:10:34 <quicksilver> treating IO as an arrow :)
07:10:46 <EvilTerran> f >=> (g >=> h) = (f >=> g) >=> h
07:10:53 <EvilTerran> and that's it :
07:10:53 <ddarius> quicksilver: >=> isn't an arrow combinator
07:10:54 <EvilTerran> )
07:11:05 <EvilTerran> ddarius, it's like >>>, tho
07:11:07 <EvilTerran> :t (>>>)
07:11:08 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
07:11:09 <quicksilver> ddarius: no, but it is a mixture of >>> and runKleisli
07:11:26 <quicksilver> it is >>> "up to newtypes"
07:11:36 <ddarius> Indeed. It is Kleisli composition, but there is no reason to bring arrows in to it.  So is (.).
07:11:36 <fiddlerwoaroof> EvilTerrain It simplified the in_ function here http://pastebin.com/m6b2a9209 drastically: http://pastebin.com/m1fe45547
07:11:37 <EvilTerran> IMO, those >=> versions of the axioms are much nicer than the >>= versions
07:12:12 <quicksilver> ddarius: well it was just intended as a reasonable description.
07:12:18 <EvilTerran> ?hpaste - do you know this, fiddlerwoaroof?
07:12:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:12:38 <fiddlerwoaroof> EvilTerran: no
07:12:39 <quicksilver> ddarius: I could have said "making use of the composition in  IO's Kleisli category"
07:12:59 <quicksilver> ddarius: but "treating IO as an arrow" seemed more concise, if slightly muddying the terminogoloy
07:13:22 <EvilTerran> really, tho, given a choice between "m >>= (\x -> k x >>= h) = (m >>= k) >>= h" and "f >=> (g >=> h) = (f >=> g) >=> h", i know which one *I* prefer :)
07:13:39 <ddarius> "monadic (reverse) composition" seems more concise and readily understandable
07:14:09 <quicksilver> well, I'm going to have to respectfully disagree with you there :)
07:14:44 <quicksilver> I think "treating IO as an arrow" was more concise, more understandable, and has the added benefit of shedding a little illumination on when you might want to use arrows.
07:14:48 * quicksilver shrugs.
07:14:53 <fiddlerwoaroof> EvilTerran well I think I like the second better as well, but maybe I'm missing some subtle haskellisms
07:15:27 <EvilTerran> fiddlerwoaroof, not really, it's just that >=> is a very new addition to the libraries (ghc 6.8, was it?), and we've had >>= since pre-report haskell
07:15:37 <fiddlerwoaroof> ok
07:15:55 <Botje> @src (>=>)
07:15:56 <lambdabot> Source not found. Take a stress pill and think things over.
07:15:58 <fiddlerwoaroof> I'm glad it was added before haskell 'clicked' with me :-)
07:16:01 <Botje> :(
07:16:58 <fiddlerwoaroof> @ho >=>
07:16:58 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
07:17:07 <fiddlerwoaroof> @hoogle >=>
07:17:07 <lambdabot> Control.Monad.(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:17:31 <fiddlerwoaroof> @src Control.Monad.(>=>)
07:17:31 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:17:38 <fiddlerwoaroof> :-(
07:18:39 <Saizan_> ?type \f g -> (g =<<) . f
07:18:40 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Functor f, Monad m) => f (m a) -> (a -> m b) -> f (m b)
07:18:40 <Axman6> Cale: yt?
07:22:59 <EvilTerran> (f >=> g) x = f x >>= g
07:23:21 <EvilTerran> (f <=< g) x = f =<< g x -- i think this one looks nicer
07:23:21 <ski> (called `>@>' in "The Craft")
07:23:42 <EvilTerran> looks more like (.)
07:23:44 <EvilTerran> ?src .
07:23:44 <Axman6> @tell Cale is it possible to turn off lambdabot's url announce on a per chan basis? people are whinging about it (i think it's one of the most useful features, but whatever...)
07:23:44 <lambdabot> (f . g) x = f (g x)
07:23:44 <lambdabot> -- In lambdabot, it's been generalised to:
07:23:44 <lambdabot> (.) = fmap
07:23:44 <lambdabot> Consider it noted.
07:24:24 <EvilTerran> (f . g) x = f $ g x; (f <=< g) x = f =<< g x
07:24:29 <EvilTerran> same shape, just different operators
07:25:40 <fiddlerwoaroof> is it possible to store an operation to be performed after every expression in a do block?
07:26:13 <quicksilver> well you can define a custom monad which has that behaviour
07:26:24 <quicksilver> may not be the most sane answer.
07:26:27 <quicksilver> what are you trying to do?
07:26:42 <quicksilver> (depending what "every expression" means)
07:26:47 <fiddlerwoaroof> so I could write something like > printSteps [ x+y | x <- [1..10] y<-[2..20] ]
07:27:09 <fiddlerwoaroof> and get printed 3, 4, 5, 6, etc..
07:27:21 <fiddlerwoaroof> > [ x+y | x <- [1..10] y<-[2..20] ]
07:27:21 <lambdabot>  Parse error at "<-[2...." (column 23)
07:27:28 <fiddlerwoaroof> > [ x+y | x <- [1..10], y<-[2..20] ]
07:27:29 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,4,5,6,7,8,9,10,11,12,13,1...
07:27:39 <quicksilver> that's what you already get, without printSteps :P
07:27:41 <_Dae_> forM_ [ x+y | x <- [1..10] y<-[2..20] ] $ \k -> putStrLn (show k)
07:27:44 <quicksilver> what would printSteps add?
07:28:00 <Choko> you are not guaranteed any particular ordering of the elements afaik
07:28:08 <fiddlerwoaroof> well eventually forEach printSteps ...
07:28:31 <fiddlerwoaroof> so I could mix debugging code into my program temporarily
07:29:11 <quicksilver> well I think the short answr to your question is "no", then :)
07:29:25 <quicksilver> however you can try Debug.Trace
07:29:34 <quicksilver> which I use very rarly myself
07:30:16 <_Dae_> Debugging can be a bit of a choore in haskell.... luckily there are usually less bugs to remove, but....
07:32:04 <fiddlerwoaroof> Is there a list of haskell idioms?
07:32:24 <ski> `ZipList' is an idiom
07:33:02 <quicksilver> I don't find debugging a chore in haskell.
07:33:04 <fiddlerwoaroof> .. I meant some reference text analogous to the Design Pattern book
07:33:15 <quicksilver> much of the time I find it much easier than in a conventional imperative language.
07:33:24 <quicksilver> I tend to debug by trying out pure functions in ghci
07:33:35 <quicksilver> looking for counterexamples which exhibit the bug
07:33:38 <quicksilver> (maybe using quickcheck)
07:33:47 <quicksilver> and 'burrowing down' to the actual function at fault
07:34:02 <quicksilver> (and maybe adding a quickcheck property to guard against regression/ better specify the funciton
07:34:09 <ski> fiddlerwoaroof : mayhaps <http://strictlypositive.org/Idiom.pdf> is what you want ?
07:34:20 <quicksilver> occasionally for a very very imperative problem
07:34:30 <quicksilver> e.g. one which relates intimately to IO with an external process
07:34:40 <EvilTerran> fiddlerwoaroof, we don't have many design patterns, as most of them can be encoded as libraries and combinators
07:34:41 <quicksilver> I use conventional scaterings of debug prints
07:34:53 <_Dae_> quicksilver: but compared to the class println debug style, it seems to be more work?
07:35:05 <quicksilver> _Dae_: I don't find it so, no.
07:35:10 <quicksilver> in most cases.
07:35:15 <fiddlerwoaroof> It'd be nice to know the code patterns which have prebuilt abstractions
07:35:59 <_Dae_> fiddlerwoaroof: a lot of code patterns make less sense in haskell, or rather you get them free with the language
07:36:25 <EvilTerran> what java calls "the visitor pattern" we call "\ ->"
07:36:36 <EvilTerran> what java calls "iterators" we call "laziness"
07:36:36 <EvilTerran> etc
07:36:40 <chr1s> fiddlerwoaroof: there is none (that I know of), but it would certainly a good idea to come up with some
07:36:44 <quicksilver> well.
07:36:46 <fiddlerwoaroof> e.g. I wrote a funtion using the do notation which simplified to concatMap ...
07:36:51 <quicksilver> I don't really agree with EvilTerran ;)
07:36:54 <chr1s> I was thinking of writing up a list of haskell design patterns
07:36:55 <quicksilver> iterators are lists.
07:37:00 <EvilTerran> the only design pattern i can think of is the encapsulated monad transformer stack
07:37:11 <EvilTerran> quicksilver, ok, s/laziness/lazy lists/
07:37:13 <quicksilver> visitor patterns are inversions of hierarchies into case statements
07:37:26 <quicksilver> haskell doesn't generally have the hierarchy to invert ;)
07:37:40 <EvilTerran> i was being very lax with my meanings
07:37:47 <_Dae_> I thouhgt it was "What java calls proxy pattern, we call laziness" ?
07:37:55 <quicksilver> I think that haskell has more patterns than we like to admit
07:37:57 * ski ponders the inverted cumulative hierarchy
07:38:05 <EvilTerran> i meant "we don't need the visitor pattern because we have lambdas (and such things as catamorphisms and fmaps)
07:38:09 <quicksilver> we've picked up too much from the anti-design-patterns false meme.
07:38:12 <chr1s> but there are other design patterns, like applicative style, folds, monads, etc.
07:38:15 <EvilTerran> "we don't need iterators because we have lazy lists"
07:38:15 <EvilTerran> etc
07:38:25 <quicksilver> there are plenty of patterns in haskell development
07:38:30 <quicksilver> and it would be nice if more was written about them
07:38:31 <_Dae_> There's nothing wrong with patterns, I've just not seen any in haskell
07:38:58 <chr1s> _Dae_: yes you have, but not maybe the imperative design patterns.
07:39:02 <quicksilver> custom monads are a pattern; struggling with lifts and combinators which translate from one monad to another are patterns
07:39:17 <fiddlerwoaroof> _Dae_ while there are certain code patterns the newbies write which others would write with a Prelude function
07:39:25 <chr1s> another (infamous) pattern is changing a set of functions to a datatype
07:39:33 <opqdonut> mhmm
07:39:43 <EvilTerran> quicksilver, i'd say encapsulating those lifts into an abstract monad that does everything you need is more the "design pattern" there
07:39:54 <ski> (worker-wrapper, accumulator, CPS)
07:40:04 <_Dae_>  Well, noone bothered to call them patterns. But it would be nice
07:40:27 <quicksilver> EvilTerran: I would say one abstract monad which does everything is an anti-pattern.
07:40:37 <quicksilver> you want to give precise types to your functions.
07:40:59 <quicksilver> "foo :: EverythingM Int" doesn't let me annotate that, actually, foo emits no log messages.
07:41:37 <EvilTerran> i mean, if you have a load of functions working over ContT StateT [] or something, wrapping that monad up and making pre-lifted versions of the appropriate methods
07:41:53 <fiddlerwoaroof> is it conventional to end monad types with 'M' ?
07:42:01 <rby> Hi, I'm trying to solve some problems with haskell on ProjectEuler, and I just figured out that maximum [1..999999] throws a stackoverflow exception (I'm using ghc 6.3 on windows) is this expected?
07:42:20 <EvilTerran> fiddlerwoaroof, no, not really. functions that work on monads, tho, yes that's fairly common
07:42:32 <EvilTerran> fiddlerwoaroof, see liftM, mapM, foldM, etcetc
07:43:25 <_Dae_> > maximum [1..999999]
07:43:26 <lambdabot>  999999
07:43:32 <_Dae_> no, works fine
07:43:42 <fiddlerwoaroof> EvilTerran: ok
07:44:02 <fiddlerwoaroof> _Dae_ it overflows in ghci on osx
07:44:07 <rby> _Dae_, I even get this error on my MacBook
07:44:23 <EvilTerran> ghci doesn't optimise - maybe try compiling it?
07:44:26 <rby> fiddlerwoaroof, on windows too?
07:44:26 <_Dae_> That's... odd
07:44:34 <kaol> > maximum [99999999..1]
07:44:35 <lambdabot>  Exception: Prelude.maximum: empty list
07:44:36 <fiddlerwoaroof> rby: I dont have windows
07:45:06 <EvilTerran> are you sure it's that expression alone that's causing the stack overflow?
07:45:11 <_Dae_> atually it overflows on linux as well
07:45:32 <fiddlerwoaroof> it overflows on Fedora Core 8
07:45:42 <zachk> fiddlerwoaroof: try writing your own recursive maximum, then just put $! in front of the parameter for the new maximum
07:46:03 <EvilTerran> ?src maximum
07:46:03 <lambdabot> maximum [] = undefined
07:46:03 <lambdabot> maximum xs = foldl1 max xs
07:46:26 <EvilTerran> maximum' xs = foldl1' max xs -- simple stricter version
07:46:37 <zachk> or that might work too :-)
07:46:38 <_Dae_> isn't it supposed to use foldr1?
07:47:24 <EvilTerran> _Dae_, no, as the whole list needs to be examined to find the maximum, foldr won't help
07:47:54 <EvilTerran> however, the optimiser can make the foldl strict enough easier than it can make the foldr strict enough, iirc
07:48:27 <_Dae_> EvilTerran: I thought foldr was supposed to be easier for the compiler to handle? Wasn't that the whole background for the whole fusion thing?
07:48:57 <EvilTerran> in some cases, but not all
07:49:04 <rby> it overflows on debian too
07:49:57 <EvilTerran> in order to evaluate (foldr1 max xs), it'll build an expression x0 `max` (x1 `max` (x2 `max` ...)))
07:50:20 <EvilTerran> and will have to go all the way along the list before it can start evaluating, in this case, as max is strict in both parameters
07:50:24 <EvilTerran> (in most cases)
07:50:50 <_Dae_> EvilTerran: Right. I thought it recompiled the thing to a loop, removing the list?
07:50:51 <EvilTerran> but, using foldl1, it can use cunning analysis to tell that it should be using foldl1' instead if it should be
07:51:14 <EvilTerran> _Dae_, list fusion doesn't work everywhere
07:51:26 <EvilTerran> it may not build the list, but it'll still build that O(n) thunk using foldr
07:51:28 <fiddlerwoaroof> it overflows when compiled
07:52:34 <hpaste>  fiddlerwoaroof pasted "(no title)" at http://hpaste.org/8786
07:52:50 <fiddlerwoaroof> ghc --make test1.hs
07:52:51 <EvilTerran> ?src print
07:52:51 <lambdabot> print x = putStrLn (show x)
07:53:04 <fiddlerwoaroof> thx
07:53:05 <EvilTerran> try ghc --make -O2 test1.hs
07:53:19 <EvilTerran> for moar optimisations
07:53:38 <_Dae_> I thought -O and -O2 were identical?
07:53:42 <quicksilver> nope.
07:53:44 <fiddlerwoaroof> it worked
07:54:31 <fiddlerwoaroof> ghc --make -O2 test1.hs
07:54:42 <EvilTerran> magick!
07:55:55 <QplQyer> anyone knows whether there is an ubuntu package to get Control.Parallel?  Import fails, but I can't seem to find a package through apt-cache search that works
07:56:20 <_Dae_> use cabal?
07:56:21 <EvilTerran> doesn't that come with 6.8* anyway?
07:58:06 <QplQyer> hmm ok, i'll use cabal then, just wondered whether I missed an ubuntu package or something
07:59:14 <fiddlerwoaroof> QplQyer I generally prefer to use cabal, gems, eastinstall rather than distro packages
07:59:24 <fiddlerwoaroof> it allows an easier upgrade
08:00:04 <quicksilver> QplQyer: yes, there is an ubuntu package for Control.Parallel.*
08:00:53 <QplQyer> quicksilver, happen to know the name? :)
08:01:11 <quicksilver> QplQyer: libghc6-parallel-dev in debian
08:01:15 <quicksilver> presumably the same in ubuntu
08:01:23 <quicksilver> http://packages.debian.org/search?searchon=contents&keywords=Strategies.hi&mode=exactfilename&suite=unstable&arch=any
08:01:25 <lambdabot> Title: Debian -- Package Contents Search Results -- Strategies.hi, http://tinyurl.com/6qqmg2
08:01:27 <noecksit> hello, im not sure if im eligable for this but who would i write to in order to request account for a public darcs repository like code.haskell.org or darcs.haskell.org?
08:01:32 <QplQyer> hmm should have come across that, let's see
08:01:46 <quicksilver> QplQyer: in 6.6.x it is a core library (it's in base)
08:01:50 <quicksilver> in 6.8.x it's split out
08:02:00 <Saizan_> noecksit: http://community.haskell.org
08:02:00 <lambdabot> Title: Haskell Community Server
08:02:09 <QplQyer> yes, I read that, but I'm using 6.8
08:02:14 * quicksilver nods
08:02:23 <quicksilver> libghc6-parallel-dev then
08:02:43 <QplQyer> doesn't appear to be in the ubuntu repos, i'll install the .deb then
08:03:02 <noecksit> allright thanx
08:03:53 <_Dae_> QplQyer: installing a debian .deb in ubuntu is the way of dark dark things and crashing desktops
08:04:07 <QplQyer> i know but I'm living on the edge ;)
08:04:36 <MrFawkes> _Dae_: Really? Always worked here.
08:04:49 <_Dae_> QplQyer: Why not ust use debian then??
08:04:54 <QplQyer> but it works now, thanks quicksilver
08:05:17 <_Dae_> MrFawkes: crashed my old ubuntu install....
08:05:40 <MrFawkes> _Dae_: That's not very general, then.
08:09:10 <_Dae_> MrFawkes: And the laptop of the computer science phd living next door? Don't really know what you want me to say to that. I wasn't claiming it would make QplQyer's computer blow up with a nice mushroom loud, ust that it's generally not a bad idea, as you're likely to get pacakge conflicts
08:13:31 <fiddlerwoaroof> _Dae_ its not as bad as compiling 3 or 4 versions of a library and scattering them around your fs like osx forces you to do
08:14:03 <MrFawkes> _Dae_: Calm down. We just have different opinions, that's all.
08:15:05 <_Dae_> fiddlerwoaroof: In ubuntu it's not a good idea, in Os X it's a rite of passage
08:15:35 <QplQyer> right, thanks for the help, off to home
08:15:45 <fiddlerwoaroof> _Dae_ I've done it in ubuntu and debian as well, osx forcing me to do it irritates me
08:16:10 <fiddlerwoaroof> but im somewhat of an efficiency freak
08:18:01 <_Dae_> Well, os X is made to be the one making the decisions. It merely takes suggestions from the user ;)
08:18:14 <fiddlerwoaroof> grrr..
08:18:16 <LordBr4in> is there an xor operator?
08:18:32 <LordBr4in> hmmm
08:18:43 <fiddlerwoaroof> :hoogle xor
08:18:50 <fiddlerwoaroof> @hoogle xor
08:18:51 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
08:18:51 <ski> for booleans or bits ?
08:19:16 <LordBr4in> i meant an infix one
08:19:25 <fiddlerwoaroof> a `xor` b
08:19:26 <LordBr4in> oh well
08:19:27 <ski> blah `xor`bleh
08:19:30 <_Dae_> fiddlerwoaroof: sorry, making fun of macs is a bad habbit....
08:19:33 <LordBr4in> yeah
08:19:34 <LordBr4in> ok
08:19:42 <fiddlerwoaroof> _Dae_ I have started to dislike my mac
08:19:50 <fiddlerwoaroof> so I dont care
08:20:06 <_Dae_> fiddlerwoaroof: you could install linux on it.... then they're not so bad...
08:20:18 <fiddlerwoaroof> _Dae_ I have too much data
08:20:34 <fiddlerwoaroof> and i{Tunes,Pod}
08:20:49 <fiddlerwoaroof> although I love amarok
08:20:53 <_Dae_> You know you want to..... turn away from the dark side, and come back to the light side of the unix
08:21:11 <_Dae_> fiddlerwoaroof: there are a ton of aps that will handle your iPod for ya. Songbird for one
08:21:21 <fiddlerwoaroof> _Dae_ they fail on Macpods
08:21:26 <fiddlerwoaroof> at least for me
08:21:45 <zachk> > do {i<-["Tunes","pod];return ("I"++i)}
08:21:45 <lambdabot>  Improperly terminated string at ""++i)..." (column 33)
08:21:51 <_Dae_> are you sure? even songbirds plugin? It's taken everything I've seen thrown at them
08:22:04 <fiddlerwoaroof> I have only tried amarok and cli utils
08:22:19 <fiddlerwoaroof> > do {i<-["Tunes","pod"];return ("I"++i)}
08:22:19 <_Dae_> you could install songbird on your mac to check?
08:22:20 <lambdabot>  ["ITunes","Ipod"]
08:22:24 <zachk> there we go
08:22:38 <fiddlerwoaroof> _Dae_ it might then use mac libs, I know it uses quicktime
08:22:43 <ski> > ("I" ++) <$> ["Tunes","pod"]
08:22:44 <lambdabot>  ["ITunes","Ipod"]
08:22:46 <fiddlerwoaroof> and crashes
08:22:55 <_Dae_> heh, right
08:22:56 <fiddlerwoaroof> :t <$>
08:22:56 <zachk> whoa what is that <$> thingie
08:22:56 <lambdabot> parse error on input `<$>'
08:23:04 <ski> @type (<$>)
08:23:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:23:06 <fiddlerwoaroof> @src <$>
08:23:06 <lambdabot> f <$> a = fmap f a
08:23:20 <fiddlerwoaroof> joy and happiness
08:23:22 <ski> just `map' in this case
08:23:36 * fiddlerwoaroof goes to note that
08:23:41 <_Dae_> anyway, I have a girlfriend who'll soon be back after walking 8km in he rain... I think I should at least have done the dishes before she returns
08:23:52 <ski> (though, beware that may be Caleskell)
08:23:55 <zachk> just take the dishes out into the rain
08:24:05 <zachk> the rain will cleanse them of evil food particles
08:24:15 <zachk> or if you have a dog let him lick the plates clean
08:24:24 <shepheb> ski: (<$>) = fmap in real Haskell too
08:24:26 <_Dae_> The thought had occured to me, but I don't like sleeping on the couh
08:24:29 <_Dae_> *couch
08:24:55 <fiddlerwoaroof> Calleskell?
08:25:41 <ski> shepheb : right .. (i'm not too fond of the actual operator choices in `Applcative')
08:26:27 <shepheb> fiddlerwoaroof: Cale, as lambdabot's current master, has changed the definitions and types of several functions. they expose some interesting and illuminating generalities, but they're not standard Haskell.
08:26:40 <fiddlerwoaroof> > (1 :: Int) `xor` (2 :: Int)
08:26:41 <lambdabot>  3
08:26:51 <fiddlerwoaroof> am I missing something?
08:27:09 <ski> what would that be ?
08:27:22 <fiddlerwoaroof> > 1 `xor` 2
08:27:22 <lambdabot>  Add a type signature
08:27:30 <fiddlerwoaroof> was what I expected
08:28:01 <ski> the latter is just ambiguous without context (or ascriptions)
08:28:02 <fiddlerwoaroof> > (1 `xor` 2) :: Int
08:28:03 <lambdabot>  3
08:28:04 <fiddlerwoaroof> better
08:28:20 <ski> > False `xor` True
08:28:20 <lambdabot>   add an instance declaration for (Bits Bool)
08:28:20 <lambdabot>     In the expression: False `x...
08:28:27 * ski smiles
08:28:50 <quicksilver> there is a different operator for Bool XOR
08:28:55 <quicksilver> it's called "/="
08:28:55 <ski> (/=)
08:29:07 <fiddlerwoaroof> > True /= False
08:29:08 <lambdabot>  True
08:29:09 <ski> yes, i'm aware
08:29:20 <PeakerWork> augustss: ping
08:29:36 <quicksilver> I didn't really think you were unaware ski :)
08:29:53 <ski> (:
08:34:28 <zachk> ok If I import module A into module B then import module B into Main, will Main contain module B and module A(if im not using any specifc exporting or importing)?
08:35:33 <ski> `Main' will *import* everything *defined* in `B' (but not `A')
08:36:42 <zachk> so if I want A to be in B and  A to be in Main then i must import A into B and A into Main, quiaff?
08:36:59 <ski> you may also reexport `A' from `B'
08:37:27 <ski> (so to `Main' it will appear as defined in `B')
08:37:45 <zachk> I dont know how to do that, and at this point in my Haskell life I would rather not
08:37:56 <zachk> but ty ski for the info
08:37:58 <ski> module B
08:37:59 <ski>   where
08:38:02 <ski> er
08:38:13 <ski> module B
08:38:17 <ski>   ( module A
08:38:19 <ski>   , ...
08:38:21 <ski>   ) where
08:38:24 <ski>   import A
08:38:28 <ski>   ...
08:38:43 <zachk> yea so i would have to specifically export everything in B, but I am lazy
08:39:09 <ski> well, i think you can replace the former `...' by `module B' to export everything defined directly in `B'
08:39:13 <ski> module B
08:39:21 <ski>   ( module A
08:39:21 <ski>   , module B
08:39:22 <ski>   ) where
08:39:23 <ski>   import A
08:39:24 <ski>   ...
08:39:55 <ski> (i may be misremembering, but this is what i seem to recall)
08:44:13 <pierre-> i have successfully installed scenegraph package, but when i try to compile samples i get: pierre@brightstar/opt/haskell/scenetest $ ghc --make -lblas -lgsl -package scenegraph main.hs
08:44:13 <pierre-> Linking main ...
08:44:13 <pierre-> /home/pierre/.cabal/lib/scenegraph-0.1/ghc-6.8.1/libHSscenegraph-0.1.a(Basic.o): In function `sc1S_info':
08:44:13 <pierre-> (.text+0x62b2): undefined reference to ...
08:45:10 <pierre-> how to deal with this type of error?
08:46:37 <scriptdevil> I feel like I have a grasp over the basic syntax and semantics of Haskell. Now, my project involves writing a compiler in Haskell. Is there a relevent book?
08:47:19 <Saizan_> pierre-: maybe the scenegraph package has forgotten to list some modules in other-modules?
08:49:02 <ski> (scriptdevil : .. "in", "for" or both ?)
08:56:29 <zachk> scriptdevil: try http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html ive heard its good, but I do not grasp haskell enough to tackle it
08:56:30 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
08:56:54 <zachk> scheme takes about 30 seconds to learn the syntax
08:56:56 <mapreduce> I've had that open in my browser for a week, nothing happened.
08:57:21 <Riastradh> ....yes, but the semantics will be nothing like Scheme.
08:58:06 <zachk> Riastradh: do you have any better suggestions for scriptdevil?
08:58:23 <Riastradh> So do perform a mental substitution of `not-Scheme' for `Scheme' if you read that tutorial, and try not to pay much attention to the Haskell code either, which is pretty poorly designed.
09:00:56 <quicksilver> scriptdevil: I'm not aware of a book which is both focussed on compiler-writing and illustrated in haskell.
09:01:04 <Riastradh> (I don't have a better suggestion for a specific tutorial.)
09:01:43 <quicksilver> scriptdevil: I have some personal loyalty to Bornat (Understanding and Writing Compilers: A Do It Yourself Guide)
09:02:37 <scriptdevil> Well. I did do the Ullman book at school. I need something like a book using functional languages to write compilers
09:03:00 <scriptdevil> Or better still a list of the haskell libs that i would need to know
09:03:20 <kaspyanand> hi
09:03:24 <quicksilver> there are no haskell libs which make compiler writing magically easy :)
09:03:33 <quicksilver> you might choose a parsing lib to do the parsing part.
09:03:35 <kaspyanand> anyone read http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
09:03:37 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
09:03:40 <quicksilver> after that you're on your own.
09:03:50 <scriptdevil> quicksilver: that never happens. A language is a tool not a solution..
09:03:57 <EvilTerran> yeah, parsing libs or alex/happy for parsing
09:04:25 <EvilTerran> stuff like pattern-matching makes writing compilers much nicer in haskell
09:04:44 <scriptdevil> Ok. alex/happy, noted...
09:05:46 <kaspyanand> i am reading http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html,and i have a question
09:05:47 <lambdabot> http://tinyurl.com/6kemco
09:05:48 <fiddlerwoaroof> @hoogle InF
09:05:49 <lambdabot> System.Info :: module
09:05:49 <lambdabot> Prelude.infix :: keyword
09:05:49 <lambdabot> Prelude.infixl :: keyword
09:06:03 <EvilTerran> fiddlerwoaroof, that's something Cale added for lambdabot
09:06:08 <EvilTerran> ?type InF
09:06:09 <lambdabot> Not in scope: data constructor `InF'
09:06:10 <EvilTerran> ?type outF
09:06:11 <lambdabot> Not in scope: `outF'
09:06:13 <EvilTerran> hm
09:06:26 <EvilTerran> ?type (In, out)
09:06:27 <lambdabot> forall (f :: * -> *) (f1 :: * -> *). (f (Mu f) -> Mu f, Mu f1 -> f1 (Mu f1))
09:06:44 <Saizan_> kaspyanand: ask :)
09:06:46 <EvilTerran> newtype Mu f = In { out :: f (Mu f) }
09:06:54 <scriptdevil> Btw, does anybody know which state parallel haskell is in?
09:07:12 <EvilTerran> fiddlerwoaroof, that sometimes appears as newtype FixF f = InF { outF :: f (FixF f) }
09:07:32 <kaspyanand> the author says
09:07:34 <kaspyanand> If we'd like f' and g' to produce strings as well as floating point numbers as output, then the only possible way is for these strings to be returned alongside the floating point numbers. In other words, we need f' and g' to be of type
09:07:35 <kaspyanand> f',g' :: Float -> (Float,String)
09:07:43 <kaspyanand> But we can't simply compose f' and g' because the return value of g' is not of the same type as the argument to f'.
09:07:49 <kaspyanand> i dont understand it
09:08:05 <fiddlerwoaroof> EvilTerran *click*
09:08:06 <kaspyanand> g' is not of the same type as the argument to f'.
09:08:14 <quicksilver> kaspyanand: do you know what he means by composing functions?
09:08:15 <EvilTerran> kaspyanand, exactly
09:08:23 <EvilTerran> kaspyanand, so you can't compose them together directly
09:08:25 <kaspyanand> not really
09:08:30 <quicksilver> kaspyanand: you can compose (Float -> Float) and (Float -> Float)
09:08:37 <quicksilver> because the output of one matches the input of the other
09:08:40 <EvilTerran> (f . g) x = f (g x) -- this is composing two functions together
09:08:43 <kaspyanand> ok
09:08:52 <quicksilver> in fact, you can compose (Float -> Int) with (Int -> String) if you like
09:08:52 <kaspyanand> right got it
09:08:58 <quicksilver> as long as output matches input it's OK.
09:09:02 <EvilTerran> kaspyanand, the point is you *can't* compose these with (.), you have to use something else
09:09:06 <quicksilver> his f and g were both Float -> Float
09:09:08 <EvilTerran> kaspyanand, which it goes on to define
09:09:10 <quicksilver> so they were composable
09:09:16 <quicksilver> but then when he added the ,String part
09:09:19 <quicksilver> they weren't any more.
09:09:24 <kaspyanand> hmm rite
09:09:31 <zachk> so you have to 'pipe' the string part around
09:09:39 <zachk> by hand when you compose those functions
09:10:00 <zachk> or you can "invent monads" and let them do the piping
09:10:05 * zachk is lost on monads 
09:10:06 <pierre-> Saizan_, thank you very much!
09:10:17 <pierre-> Other-modules worked
09:10:21 <kiris> or implement something which the state monad does
09:10:40 <Saizan_> pierre-: you're welcome :)
09:10:47 <pierre-> it seems that scenegraph on hackage needs to be updated
09:10:58 <zachk> kiris: do i always have to runState with the state monad?
09:11:01 <kaspyanand> ok i understood the composing part awsome
09:11:18 <kiris> zachk: mhm
09:11:33 * zachk the notion strikes him as odd
09:11:49 <kiris> have you looked at the implementation?
09:12:18 <kiris> http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html#State
09:12:18 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6fo2zn
09:12:24 <kaspyanand> next author gives this piece of code
09:12:26 <kaspyanand> let (y,s) = g' x
09:12:27 <kaspyanand>     (z,t) = f' y in (z,s++t)
09:12:27 <zachk> not really, monads kind of spin my head, i can handle list,IO, Maybe, and Data.Map atm
09:12:37 <EvilTerran> zachk, yes, you have to use runState to get the value out
09:12:39 <kaspyanand> so whats happening here?
09:12:40 <EvilTerran> ?src State
09:12:40 <lambdabot> Source not found. There are some things that I just don't know.
09:12:52 <EvilTerran> saccade, alternatively, you can pattern-match out the State constructor
09:13:01 <EvilTerran> er, s/saccade/zachk/
09:13:54 <EvilTerran> kaspyanand, if f and g were composable, you could write "(f . g) x = let { y = g x; z = f y } in z"
09:14:09 <EvilTerran> kaspyanand, he's adapting this for his not-quite-composable functions
09:14:33 <kiris> zachk: well the Monad class is just an abstraction of a common pattern. you could easily write the state monad as just a library. it's only a monad because it implements the necessary monadic functions and follows the laws allowing it to be used generically
09:14:51 <kiris> (and predictably)
09:14:59 <EvilTerran> zachk, think of runState for State being like "maybe" for the Maybe monad
09:15:06 <kaspyanand> evilterrain:what in z means?
09:15:15 <kaspyanand> "in z"
09:15:24 <EvilTerran> zachk, or foldr for the list monad - it takes the monadic computation, and reduces it to a value
09:15:25 <ski> > let x = 5 in x*x
09:15:26 <lambdabot>  25
09:15:50 <EvilTerran> kaspyanand, it's the let{...}in(...) notation
09:16:01 <kiris> zachk: do you know about the Scheme language?
09:16:27 <EvilTerran> let {bindings} in (expression using those bindings)
09:16:28 <zachk> yes, to a decent level, i dont get callcc or the y-combinator, but other then that i get it decently
09:16:37 <ski> (let ((x 5))
09:16:38 <ski>   (* x x))
09:17:18 <zachk> yea and let is just a macro for lambda's
09:17:34 <EvilTerran> fiddlerwoaroof, btw, category-extras defines a type-level fixed point like that here: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Fix.html
09:17:36 <lambdabot> Title: Control.Functor.Fix, http://tinyurl.com/6pes6j
09:18:08 <ski> (define ((compose f g) x)
09:18:12 <ski>   (let* ((y (g x))
09:18:15 <ski>          (z (f y)))
09:18:16 <ski>     z))
09:18:23 <EvilTerran> fiddlerwoaroof, it also defines useful things in Control.Functor.Composition and whatnot as well
09:18:31 <ski> is EvilTerran's `.' above, in Scheme
09:18:44 <kiris> zachk: well, you could implement the state monad as some library in that because it has closures. but you could only use the bind and return functions for the state library, you'd need separate functions for, say, the Reader monad. so it's not really a monad because Scheme doesn't have polymorphism (as standard), so you can't generalise the >>= and return functions. is that a good analogy or should I give up on this one? :p
09:19:01 <ski> (using a natural, but not standard extension to r5 in the syntax of definition ..)
09:20:07 <fiddlerwoaroof> EvilTerran I just remembered that and am installing it
09:20:10 <zachk> ski: so the State Monad is kinda like a closure?
09:20:33 <fiddlerwoaroof> Im trying to grok http://comonad.com/reader/2008/recursion-schemes/
09:20:36 <lambdabot> Title: The Comonad.Reader  Recursion Schemes: A Field Guide
09:20:37 <kiris> it's clever use of closures, if you have a gander at the implementation
09:21:05 <zachk> im browsing it atm. is there a simple difference between State and StateT?
09:21:08 <ski> zachk : a state monad *action* is internally a function, yes
09:22:11 <quicksilver> zachk: StateT is a way of layering state on top of another existing monad.
09:22:20 <zachk> oh
09:22:28 <ski> zachk : `StateT s m' adds the state `s' on top of the monad `m' .. `State s' just is the implicit state `s'
09:22:58 <zachk> so i can have StateT IO and then write "kinda imperative" code?
09:23:09 <EvilTerran> if you like
09:23:29 <EvilTerran> (StateT Int IO a) is like IO (State Int a)
09:23:30 <kiris> ~(a, _) <- runStateT m s
09:23:36 <kiris> what does this ~ lazy pattern mean?
09:23:37 <rwbarton> zachk: yes, though you can (more straightforwardly) use newIORef etc.
09:23:48 <EvilTerran> you've got IO, but you've also got an Int state
09:23:52 <quicksilver> EvilTerran: well, only sort of
09:23:53 <ski> or you can write `StateT s []' code, and have "kinda SNOBOL" code
09:24:31 <quicksilver> EvilTerran: Int -> IO (Int,a) is not the same as IO (Int -> (Int,a))
09:24:44 <ski> kiris : basically that when that action is run in the underlying monad, the pair won't be forced at that time
09:24:46 <kiris> does this lazy pattern mean try to apply the pattern later on?
09:24:48 <EvilTerran> quicksilver, well, true
09:24:50 <kiris> ah
09:24:55 <kiris> thanks
09:25:01 <ski> @unmtl StateT Int IO a
09:25:02 <lambdabot> Int -> IO (a, Int)
09:25:06 <zachk> ski: as of right now what i do with my state(variable)  is just pass it through all my functions that could modify it
09:25:08 <quicksilver> EvilTerran: but if all you were trying to is give an intuition then yes :)
09:25:12 <EvilTerran> better example: (StateT Int Maybe a) vs Maybe (State Int a)
09:25:21 <EvilTerran> is that better?
09:25:23 <ski> @unmtl StateT Int Maybe a
09:25:24 <lambdabot> Int -> Maybe (a, Int)
09:25:29 <EvilTerran> never mind, i'm confused now
09:25:32 <ski> @unmtl MaybeT (State Int) a
09:25:33 <lambdabot> Int -> (Maybe a, Int)
09:25:36 <EvilTerran> yes, i was just aiming for an intuition
09:25:39 <quicksilver> zachk: and to be honest that's exactly that the state monad does
09:25:45 <quicksilver> zachk: it just hides it to some extent.
09:25:46 <zachk> EvilTerran: is slightly confused
09:25:56 <quicksilver> it passes the state through all your functions "automatically"
09:26:01 <ski> zachk : ok
09:26:03 <quicksilver> without you having to thread it yourself.
09:27:04 <ski> (and making goof-ups by passing the wrong version of the state on)
09:27:21 <kiris> yeah. I actually did that recently
09:27:31 <kiris> I was recursing and returning (foo,bar)
09:27:35 <kiris> but got them in the wrong order
09:27:44 <ski> well, the state monad has come here to save you from that
09:27:53 <quicksilver> (ski's point in parentheses is actually the most important one)
09:28:00 <kiris> yeah, I implemented in the State monad straight away
09:28:07 <quicksilver> manual state handling makes it very easy to mess up with wrong versions of stat
09:28:31 * ski hands quicksilver an `e'
09:29:12 <quicksilver> thanks, I ran out.
09:29:16 <kiris> estat?
09:29:34 <quicksilver> a famous GHC bug made an optimisation not fire because the developers manually handled state and got it wrong :)
09:29:51 <quicksilver> returning s instead of s' from a function, or similar.
09:30:13 <sclv_> The worst thing about ghc is that parts of it aren't written in haskell.
09:30:16 <sclv_> Yay haskell!!!
09:30:16 <byorgey> @seen shepheb
09:30:16 <lambdabot> shepheb is in #xmonad and #haskell. I last heard shepheb speak 53m ago.
09:30:35 <shepheb> byorgey: yes?
09:30:46 <byorgey> shepheb: braincrater.wordpress.com is your blog, right?
09:30:46 <kiris> ( http://bash.org/?329292 )
09:30:47 <lambdabot> Title: QDB: Quote #329292
09:31:06 <shepheb> byorgey: yes it is. I haven't put up my About Me yet.
09:31:13 <sclv_> Actually, I take it back. I want GHC to be written in Epigram.
09:31:15 <quicksilver> sclv_: I don't blame them for the C--. C-- is a good idea.
09:31:22 <quicksilver> sclv_: I blame them for the Perl though ;)
09:31:50 <byorgey> shepheb: ok, cool.  I'm putting your latest post in the HWN and wanted to make sure I had the attribution right.
09:31:58 <kiris> Perl6 would have a nice ring to it
09:32:06 <kiris> (using the Pugs interpreter)
09:32:27 <kiris> compiling haskell in an interpreter written in haskell
09:32:37 <sclv_> quicksilver: of course you need to build up the primitives from something else. I'm just being a bit silly because I've been trying to grok stack handling and STM internals for a good while now and ouch.
09:33:09 <quicksilver> sclv_: it's reasonable to want to minimise the extent that the RTS is written in another language.
09:33:27 <quicksilver> sclv_: it's sensible to hope that a good chunk of the RTS could be in haskell.
09:33:36 <quicksilver> if you think haskell is a good language for writing RTSes in :)
09:33:39 <quicksilver> seems so to me.
09:33:56 <quicksilver> there is also that pseudo-haskell that GHC uses which is quite a bit lower level.
09:34:20 <kiris> Core?
09:34:32 <shepheb> byorgey: well, now I'm flattered but also performance-anxious :P
09:35:00 <quicksilver> kiris: no, it looks like haskell and smells like haskell but isn't.
09:35:05 <sclv_> I dunno. I just think that implementing efficient high-level concurrency primitives is brain-bending on the low level.
09:35:07 <quicksilver> @src evaluate
09:35:07 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
09:35:09 <byorgey> shepheb: hehe, don't worry, it'll just be in the list of blog posts, it's not like I'm writing a headline article about it or anything =)
09:35:16 <kiris> quicksilver: ah, I see
09:35:18 <quicksilver> ^^ that src for evaluate is an example of it.
09:35:37 <quicksilver> there is an imperative language behind the scenes which uses haskell syntax.
09:35:46 <quicksilver> and uses "case" on unboxed tuples to sequence
09:35:47 <sclv_> Haskell by itself probably wouldn't help much -- Haskell with lots of fancy type machinery for capabilities on the other hand...
09:35:48 <quicksilver> basically.
09:36:06 <quicksilver> sclv_: well STM would have been done before if it was trivial, I guess :)
09:36:19 <quicksilver> sclv_: the implementation of MVar is unsurprisingly simpler.
09:36:24 <kiris> I was actually just reading this post: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast
09:36:25 <lambdabot> Title: Haskell hacking
09:37:04 <sclv_> The concept of STM is simple enough -- you just let yourself in for a world of corner cases.
09:37:10 * fiddlerwoaroof wants to write haskell in eclipse
09:37:28 <quicksilver> there is a haskell plugin for eclipse
09:37:36 <quicksilver> I don't think its' well maintained or terrible useful
09:37:43 <Valodim> indeed
09:37:55 <sclv_> I tried it for maybe half a day.
09:37:58 <fiddlerwoaroof> I noticed it but it doesn't work with 3.4
09:38:02 * quicksilver nods
09:38:22 <fiddlerwoaroof> what is the best haskell editor/ide ?
09:38:25 <quicksilver> sclv_: the concept of the STG is simple enough :) but it's non-trivial to write GHC nonetheless.
09:38:29 <quicksilver> fiddlerwoaroof: emacs.
09:38:34 <fiddlerwoaroof> I've been using vim
09:38:37 <Valodim> haha
09:38:59 <sclv_> The main problem is that ghc has relatively slow compile times so you want to work with the ghci repl for basic stuff, but the eclipse plugin is, unsurprisingly, built around straightforward compiles.
09:39:17 * fiddlerwoaroof just realized he asked a dangerous question
09:39:22 <sclv_> plus eclipse eats so much of your processor its a wonder there's anything left to run ghc at all.
09:39:29 <Valodim> and here we go: clearly, vim is superior
09:39:38 <quicksilver> sclv_: ghc without optimisation is not all that slow, I don't think.
09:39:45 <quicksilver> sclv_: maybe I'm spoilt by having quite a fast machine :)
09:40:00 <quicksilver> sclv_: but ghci has other advantages
09:40:19 <quicksilver> and of course for really large projects and so on the speed of compilation becomes more of an issue.
09:40:22 <sclv_> quicksilver: on my new machine its fine. on my old one it was awful. its the linker that really takes the time though.
09:40:41 <shepheb> fiddlerwoaroof: haskell-mode for emacs is very tasty, I like it. but I already like emacs, so it's unsurprising that I like writing Haskell with it :P
09:40:47 <quicksilver> sclv_: yeah, but it doesn't seem too bad to me with optimisations off.
09:40:52 <quicksilver> (the linker)
09:40:56 <quicksilver> maybe I'm just wrong
09:41:00 <quicksilver> in where I believe the time is spent :)
09:41:13 <fiddlerwoaroof> shepheb:I like emacs when editing latex like documents
09:41:24 <fiddlerwoaroof> I just know vi better
09:41:28 <sclv_> on my new machine with quad-cores I can compile GHC in ~20 minutes, so yeah, I'm not complaining now :-)
09:41:29 <ski> http://www.dina.kvl.dk/~abraham/religion/ed-standard
09:41:30 <smg> lambdabot: reverse . reverse $ [1..10]
09:41:39 <smg> > reverse . reverse $ [1..10]
09:41:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
09:41:47 <ski> fiddlerwoaroof : there you go
09:42:10 <fiddlerwoaroof> ski: thanks, I've been looking for a consistent editor
09:42:16 * fiddlerwoaroof is going to lunch
09:44:17 <_zenon_> hmm... lookup is good, but is there an "update" function as well? Or do it yourself?
09:44:44 <EvilTerran> if you're regularly updating the nth item of a list, you may want to use a different data structure
09:44:55 <EvilTerran> as that's O(n) memory consumption
09:44:55 <quicksilver> yeah, there isn't an 'update' for [(a,b)]
09:45:00 <_zenon_> EvilTerran, yes, thank you :) I was not asking for other structures
09:45:03 <quicksilver> because it's probablya bad idea.
09:45:08 <EvilTerran> so they don't provide one
09:45:14 <quicksilver> as soon as you start wanting update, you want Map a b
09:45:22 <_zenon_> damn it, yes, I know.
09:45:24 <quicksilver> [(a,b)] is fine for small simple read-only maps.
09:45:47 <EvilTerran> maps of constant length, so the asymptotic complexities of the list functions don't matter ;)
09:45:55 <quicksilver> and, hey, M.fromList is only 10 characters ;)
09:47:47 <quicksilver> do not ask of #haskell that it not question your program; for through questioning alone comes enlightenment.
09:49:54 <_zenon_> filter (\x->not . selfrighteous x )
09:50:41 <kiris> filter (not . selfrighteous)
09:50:45 <EvilTerran> if selfrighteous only takes one parameter, that won't compile, _zenon_ :)
09:50:59 <EvilTerran> kiris' will, tho, as would filter (\x->not $ selfrighteous x)
09:51:24 <kiris> so ner
09:55:17 <_zenon_> I agree, that was ironic :)
09:55:27 <kiris> hmm I need a random monad or a reader monad with an infinite list of randoms
09:55:27 <_zenon_> however, I meant (.)
09:55:35 <kiris> seem to remember reading a Random monad on the wiki
09:55:52 <_zenon_> I did not mean (.)
09:55:56 <_zenon_> damnit, what a day
09:56:11 <_zenon_> first the koffe-pot at work was empty,
09:56:17 <byorgey> anyone know Gentoo here?  I'm wondering if you could read this: http://araujoluis.blogspot.com/2008/07/ghc-682-stable-himerge-0219-too.html and give me a two-sentence summary of what it is actually saying.
09:56:18 <_zenon_> then the lunch was too sal
09:56:18 <lambdabot> Title: araujo's blog: GHC 6.8.2 stable! (Himerge 0.21.9 too!), http://tinyurl.com/5t5csj
09:56:21 <_zenon_> and now this
09:56:26 <byorgey> it uses too many Gentoo-specific words.
09:56:28 <byorgey> =)
09:56:54 <byorgey> kiris: yes, there is a Random monad on the wiki
09:57:03 <Baughn> byorgey: "We are petitioning for a package update so "emerge ghc" will at last give ghc 6.8.2"
09:57:08 <Baughn> Meanwhile, in the real world...
09:57:17 <Baughn> *portage update
09:57:22 <Valodim> the #RealWorld?
09:57:32 <kiris> ah, it's on hacjage! :)
09:57:36 <kiris> er, hackage
09:57:40 <Baughn> Not yet.
09:57:44 <byorgey> Baughn: ok, thanks.  I want to put it in the HWN but wasn't even sure what to write =)
09:57:44 <araujo> byorgey, Hi there ... it just means, we have stabilized our packages in Gentoo :-]
09:57:48 <kiris> MonadRandom is
09:57:56 <Baughn> byorgey: Nothing to see here, move along
09:58:09 <Baughn> byorgey: You might want to wait until the stabilization request is /granted/. If it is.
09:58:20 <byorgey> ah! ok then, I'll wait =)
09:58:37 <araujo> Baughn, For Gentoo?
09:58:41 <Baughn> Yes
09:58:47 <araujo> It is already stabilized
09:58:55 <Baughn> 6.8.2?
09:58:57 <araujo> yeah
09:59:07 <byorgey> so what does 'stabilized' mean?
09:59:10 <Baughn> THat was fast. byorgey: Well, then..
09:59:16 <Baughn> byorgey: "Not marked as unstable", essentially
09:59:17 <araujo> The arch testers took care of the stabilization request fast
09:59:24 <byorgey> oh, ok, I see
09:59:27 <Baughn> It means emerge ghc will build it without any modifications to control files
09:59:29 <araujo> byorgey, yeah, it is not testing anymore
09:59:33 <byorgey> cool
09:59:40 <araujo> byorgey, it will be offered to the users as a stable package
09:59:42 <kolmodin_> Baughn: it means it'll be the default version installed if you say 'emerge ghc'
09:59:50 <Baughn> kolmodin_: That's what I was saying
09:59:50 <araujo> So they can upgrade to these latest versions
10:00:13 <araujo> Either of GHC, as of any of their extra-libs
10:00:17 <byorgey> nice.
10:00:19 <kolmodin_> Baughn: right, good :)
10:00:22 <araujo> So it is a good step for Haskell in Gentoo
10:00:24 <araujo> :-]
10:00:34 <kolmodin_> right. now we should arrange for ghc 6.8.3
10:01:11 <Baughn> And cabal-install.. actually, might that already be in there?
10:01:19 <smg> yeah mine ghc 6.8.2 is already build
10:01:19 <Baughn> I don't use gentoo anymore, so..
10:01:20 <byorgey> so I could say something like this: "GHC 6.8.2, and its accompanying libraries, have now been stabilized in the official Gentoo portage tree"?
10:01:36 <smg> but where is the ascii art in ghci 6.8.2?
10:01:38 <smg> i miss it!
10:01:58 <byorgey> smg: it was removed by default, I think there is a flag you can pass to ghci if you want it back
10:02:00 <Baughn> byorgey: "GHC 6.8.2, and its accompanying libraries, have now been marked as stable in the official gentoo portage tree"
10:02:08 <byorgey> Baughn: ok, thanks
10:02:13 <smg> byorgey: haha okay
10:02:14 <Baughn> "Stabilized" sounds like they actually /did/ anything
10:02:18 <araujo> Yeah byorgey
10:02:24 <araujo> byorgey, That'd be good
10:02:25 <byorgey> Baughn: ah, right, ok
10:03:01 <kolmodin_> yep
10:03:10 <smg> byorgey: i don't see anything, good bye ascii! :)
10:03:28 <zachk> :~(
10:04:43 <zachk> i can hardly wait for this fall semester of college to start, we are going to be doing data structures in Java, omfg hooray, im so excited i can hardly control my bladder, or my instinct to vomit
10:05:37 <byorgey> smg: ah, see section 1.4.3 on this page: http://haskell.org/ghc/docs/6.8.1/html/users_guide/release-6-8-1.html
10:05:38 <lambdabot> Title: 1.4. Release notes for version 6.8.1, http://tinyurl.com/3yjyhg
10:05:43 <byorgey> smg: you can make your own banner! =D
10:06:00 <Baughn> zachk: Realistically, java /is/ used a lot in the industry. Avoiding it is fine, but knowing how it works is fine too
10:06:14 <kiris> byorgey: this calls for a huge 
10:06:29 <byorgey> kiris: indeed! =)
10:06:49 <zachk> Baughn: yes i know, but i miss first class functions and things like map
10:07:11 <kiris> zachk: Java doesn't have first-class functions? @_O
10:07:42 <Botje> just have to wrap them in new Lambda(new Parameter[] {....}) *grin*
10:07:49 <Baughn> kiris: You're supposed to make subclasses f Runnable
10:07:53 <Baughn> Or something
10:07:59 <kiris> haha, ok
10:08:01 <Baughn> One class per function.
10:08:28 <Baughn> Nobody does, though. There's a huge per-object overhead; it'd totally ruin performance.
10:08:31 <kiris> this is cool: http://hackage.haskell.org/packages/archive/MonadRandom/0.1.1/doc/html/Control-Monad-Random.html#1
10:08:34 <lambdabot> Title: Control.Monad.Random, http://tinyurl.com/69km72
10:08:53 <smg> ty byorgey
10:17:30 <_zenon_> so, what's cooking?
10:17:49 <kiris> I'm working on that word cloud code. how to position them so they don't overlap. fun stuff
10:18:58 <_zenon_> ooh nice, I am working on something fun as well, using old irc logs for this
10:19:07 <_zenon_> nothing graphical thou
10:19:09 <kiris> cool ;)
10:19:17 <kiris> do you want my histogram code? :P
10:19:48 <_zenon_> hmm... I don't think so, in a "thank you" kind of way,
10:20:07 <kiris> I'll hpaste it anyway
10:20:09 <Baughn> _zenon_: "No, thank you". ;)
10:20:16 <kiris> haha
10:20:41 <_zenon_> Baughn: Yeah, but that sounds lame as well.
10:20:45 <hpaste>  kiris pasted "simple histogram code" at http://hpaste.org/8787
10:21:10 <Baughn> _zenon_: It's perfecetly ordinary english, but if you want you could say "No, thank thee"
10:21:41 <_zenon_> that was better
10:21:47 <_zenon_> kiris: No thank thee
10:22:05 <_zenon_> I shalt remember thou effort.
10:22:09 <_zenon_> thy?
10:22:14 <kiris> think not of it
10:23:12 <vixey> > map (head &&& length) . group . sort . words "flip flip concatMap"
10:23:14 <lambdabot>  [[('f',1),('i',1),('l',1),('p',1)],[('f',1),('i',1),('l',1),('p',1)],[('M',1...
10:23:17 <Baughn> _zenon_: Thy.
10:23:18 <vixey> > map (head &&& length) . group . sort . words $ "flip flip concatMap"
10:23:19 <lambdabot>  [("concatMap",1),("flip",2)]
10:25:36 <chr1s> so, except for the (&&&), are arrows still used today?
10:25:49 <Baughn> _zenon_: But note that "you" is simply the formal/respectful version of "thee".
10:25:51 <chr1s> I think only some xml library and some gui library uses them, right?
10:26:13 <vixey> there was some reversible programming using arrows I think
10:34:45 <kiris> actually that's not too shabby
10:34:59 <kiris> I compared using group to a hash table and it's 1.100 seconds slower
10:35:10 <kiris> which isn't so bad at all
10:35:33 <kiris> er, s/hash table/map
10:35:43 <dolio> @type \n f x -> f (n f x)
10:35:44 <lambdabot> forall t t1 t2. ((t1 -> t2) -> t -> t1) -> (t1 -> t2) -> t -> t2
10:35:51 <asdftimo> hey guys, i need to know how i can divide two integers that don't divide evenly. ghc gives me "No Instance for (Fractional Int)". Is there a way I can make this work?
10:36:04 <rwbarton> > 7 `div` 3 -- is that what you want?
10:36:05 <lambdabot>  2
10:36:12 <kiris> vixey: nice use of &&& ^_^
10:36:13 <Riastradh> Convert them to a type of number that is divisible, or use one of the integer division routines.
10:36:30 <asdftimo> riatradh: how can i convert them?
10:36:44 <Riastradh> `fromIntegral' will generally do what you want.
10:36:45 <asdftimo> rwbarton: no, because 7/3=2.3333 and i need 2.333 not 2
10:36:55 <Riastradh> Well, do you want 2.333, or do you want 7/3?
10:36:55 <sclv_> chr1s: Arrows are an area of active research still.
10:36:59 <vixey> > 7/3
10:37:00 <lambdabot>  2.3333333333333335
10:37:01 <kolmodin_> any haskell.org admins here? are there any plans to upgrade to darcs 2.0.2 on the server?
10:37:01 <rwbarton> asdftimo: fromIntegral then
10:37:04 <Riastradh> Those are two different numbers.
10:37:21 <vixey> > ((/)`on`fromIntegral) 7 3
10:37:22 <lambdabot>  2.3333333333333335
10:37:23 <asdftimo> indeed. i just need a decimal representation
10:37:31 <vixey> > show $ ((/)`on`fromIntegral) 7 3
10:37:32 <lambdabot>  "2.3333333333333335"
10:37:32 <Riastradh> That's different entirely!
10:37:35 <kiris> yeah. I use on
10:38:08 <Riastradh> asdftimo, now I'm less clear on what you want.  Do you want the exact value of 7/3, the approximate value 2.333, or a string of the text of the decimal representation of 2.333?
10:38:22 <sclv_> chr1s: I'll grant that HXT and Yampa are the two best-known uses of them, but I think Conal actually did some work with FRP an arrows as well before switching to Applicative.
10:38:27 <asdftimo> i need a decimal approximation
10:38:41 <vixey> asdftime: decimal implies base 10
10:38:44 <sclv_> And I think there's some other parser work besides HXT that uses arrows.
10:38:48 <vixey> asdftime: computers don't care about "10"
10:39:23 <asdftimo> right now i have (fromIntegral n/x) and that doesn't work, same error as before
10:39:53 <rwbarton> you want something like (fromIntegral n / fromIntegral x)
10:39:58 <vixey> asdftime: look at the examples I gave above for you
10:40:18 <chr1s> sclv_: my intuition is that arrows are too hard.
10:40:33 <chr1s> sclv_: I hardly know anyone who likes them (or likes to use them)
10:40:48 <asdftimo> vixey: not in scope: `on`
10:40:50 <Riastradh> asdftimo, `decimal approximation' doesn't tell me any more.
10:40:55 <vixey> @src on
10:40:56 <lambdabot> (*) `on` f = \x y -> f x * f y
10:40:57 <ziman> asdftimo, import Data.Function
10:41:01 <vixey> asdftime: add that to your source file
10:41:06 <vixey> the line:
10:41:06 <vixey> (*) `on` f = \x y -> f x * f y
10:41:09 <Riastradh> asdftimo, do you want a number, or a string of its decimal representation?
10:41:17 <vixey> is much more interesting and descriptive than the line
10:41:21 <vixey> import Data.Function
10:41:21 <asdftimo> Riastradh: number
10:41:30 <Riastradh> asdftimo, what does `decimal' have to do with it, then?
10:42:00 <sclv_> chr1s: The thing is that they're just *different* from monads. It's not like you get any magic power from using one thing where the other is more suitable.
10:42:17 <sclv_> And situations where one might actually need arrows are relatively more rare...
10:42:35 <asdftimo> Riastradh: guess that would be the wrong wording. i meant that i wanted the fractional part of the division as well as the integer part
10:42:48 <vixey> > 7 `divMod` 3
10:42:48 <lambdabot>  (2,1)
10:42:55 <vixey> (2,1/3)
10:43:07 <vixey> asdftimo
10:43:15 <asdftimo> ok thanks vixey
10:43:16 <EvilTerran> > 7 % 3
10:43:17 <lambdabot>  7%3
10:43:22 <EvilTerran> ?type 7 % 3
10:43:23 <lambdabot> forall t. (Integral t) => Ratio t
10:43:27 <chr1s> sclv_: yes, but that's a different thing. I'm not talking about differences in power
10:43:28 <sclv_> On the other hand, Control.Category, which takes just the composition element of arrows, is now split out, and useful for e.g., functional references.
10:43:29 <vixey> > numerator (7%3{
10:43:30 <lambdabot> Unbalanced parentheses
10:43:31 <vixey> > numerator (7%3)
10:43:32 <lambdabot>  7
10:43:35 <vixey> > denominator (7%3)
10:43:36 <lambdabot>  3
10:43:49 <kryptiskt_> > 14%6
10:43:50 <sclv_> chr1s: The question is rather if there's a better way to do what, e.g., Yampa does, that doesn't use arrows.
10:43:50 <lambdabot>  7%3
10:44:07 <chr1s> yeah
10:44:30 <sclv_> Or if there's a better way to do what hxt does. (And I think there is, but it would add complexity, not remove it).
10:44:40 <tromp> > gcd(4,6)
10:44:41 <lambdabot>   add an instance declaration for (Integral (t, t1))
10:44:51 <asdftimo> vixey: on a related note: is there a way to do somethign like (7 % ( 5 % 3) )
10:44:57 <tromp> > gcd 4 6
10:44:58 <lambdabot>  2
10:45:01 <vixey> asdftimo: what
10:45:04 <chr1s> sclv_: well, simplicity is very improtant imho
10:45:08 <sclv_> In particular, I'd like to use phantom types to nail down further whether subparsers return one, many, or maybe one.
10:45:11 <mauke> > 7 / (5 / 3)
10:45:11 <kiris> "wat"
10:45:12 <lambdabot>  4.2
10:45:12 <rwbarton> > 7 / (5 / 3) :: Rational
10:45:13 <lambdabot>  21%5
10:45:27 <asdftimo> rwbarton: cool. thanks
10:45:28 <chr1s> sclv_: have you read the power of pi?
10:45:29 <vixey> :t 7 % ( 5 % 3) )
10:45:30 <sclv_> arrowList is sort of a broken/confusing notion at the moment I think.
10:45:30 <lambdabot> parse error on input `)'
10:45:36 <vixey> doesn't work ....
10:45:47 <kiris> :t (7 % ( 5 % 3) )
10:45:48 <lambdabot> forall t. (Integral t, Integral (Ratio t)) => Ratio (Ratio t)
10:46:05 <vixey> that doesn't work much less obviously
10:46:09 <_zenon_> hm. why does update take (a -> Maybe a) as an argument?
10:46:19 <vixey> @src update
10:46:19 <lambdabot> Source not found. Just try something else.
10:46:24 <sclv_> chr1s: nope. what is it?
10:46:48 <_zenon_> Well, my real problem is: I have        Map a (Map b c) , and I wish to update the inner Map
10:46:55 <chr1s> sclv_: sclv_: http://www.cs.nott.ac.uk/~wss/Publications/ThePowerOfPi.pdf
10:47:09 <chr1s> parsing using dependent types, very interesting.
10:47:21 <_zenon_> map a new b , c pair,
10:47:28 <vixey> the stuff about structurally recursive ascent parsing is interesting too
10:48:13 <kiris> _zenon_: if it's (Just a) it takes the a value and inserts it. if it's Nothing, it deletes the entry entirely
10:48:14 <sclv_> thanks. looking now.
10:48:29 <kiris> _zenon_: The expression (update f k map) updates the value x  at k (if it is in the map). If (f x) is Nothing, the element is deleted. If it is (Just y), the key k is bound to the new value y.
10:48:54 <_zenon_> kiris: I can also find entries at hoogle :)
10:48:59 <rwbarton> _zenon_: If you don't want this Maybe business there's also adjust
10:49:35 <_zenon_> My problem is to conceptually wrap my head around this nested business :/
10:49:46 <kiris> nested business?
10:50:01 <vixey> _zenon_: You don't really have to think about anything
10:50:09 <vixey> _zenon_: Just let the types put the code together
10:50:14 <vixey> _zenon_: 'undefined' is useful
10:50:21 <sclv_> I was pretty disappointed by the pickler combinators in hxt too.
10:50:31 <_zenon_> Map a (Map b c) ::: and I wish to insert a new pair into the inner map
10:50:39 <_zenon_> update the first map
10:50:51 <sclv_> They didn't seem to be a real net win in terms of usability/keystrokes.
10:51:05 <vixey> _zenon_: What do you mean when you say "the" inner map?
10:51:13 <_zenon_> update :: (Ord k) => (a -> Maybe a) -> k -> Map k a -> Map k a
10:51:20 <vixey> _zenon_: There's not exactly one of them, there could be 0, 1  or more ..
10:51:43 <rwbarton> :t \a b c m -> M.adjust (M.insert b c) m
10:51:44 <lambdabot> forall t k a k1. (Ord k1, Ord k) => t -> k -> a -> k1 -> M.Map k1 (M.Map k a) -> M.Map k1 (M.Map k a)
10:51:50 <kiris> > Data.Map.empty
10:51:50 <sclv_> anway, you also get parsers and printers for free with Generics and without dependent typing.
10:51:50 <lambdabot>   Not in scope: `Data.Map.empty'
10:51:55 <kiris> :(
10:51:59 <sclv_> of course you don't get a guarantee they terminate though...
10:52:02 <rwbarton> I messed that up, seeing as I didn't use a...
10:52:14 <rwbarton> :t \a b c m -> M.adjust (M.insert b c) a m
10:52:14 <lambdabot> forall k a k1. (Ord k1, Ord k) => k1 -> k -> a -> M.Map k1 (M.Map k a) -> M.Map k1 (M.Map k a)
10:52:19 <kiris> ah, M
10:52:35 <_zenon_> adjust... hm
10:52:44 <vixey> _zenon_: Hello........... ?
10:53:14 <_zenon_> rwbarton: that looks nice
10:53:49 <_zenon_> vixey: yes, I wanted to update the Map a x , inserting a new entry in x = Map b c
10:53:58 <kiris> > "hello" ++ cycle "."
10:53:59 <lambdabot>  "hello.........................................................................
10:54:17 <_zenon_> kiris, you forgot the '?'
10:54:22 <vixey> _zenon_: Simple example:  Bool
10:54:33 <vixey> _zenon_: True *AND* False are Bools
10:55:14 <vixey> _zenon_: if you have a Map a x it's there could be many x's or one.. or zero
10:55:27 <vixey> _zenon_: is that clear ?
10:55:28 <_zenon_> rwbarton: Your example was great.
10:55:58 <rwbarton> vixey: the question is for an analogue of python "m[a][b] = c"
10:56:22 <schme_> segfault?
10:56:24 <vixey> I have this feeling that introducing python to explain haskell concepts isn't going to help
10:56:38 <_zenon_> vixey: I got it now. thank you.
10:56:59 <rwbarton> _zenon_: of course, you'll have to work a little harder if you want to create a new inner-map in the outer-map when there wasn't one before
10:57:01 <vixey> _zenon_: You got the code... I don't know if you understand the Map thing though ...
10:57:46 <_zenon_> rwbarton: that case is covered
10:59:57 <dolio> @yow!
10:59:57 <lambdabot> Couldn't find fortune file
11:00:17 <_zenon_> vixey: maybe I stated the question wrong, but I know what a map is, and you seem verry intent on making sure of it. so I got it covered. thank you.
11:01:18 <vixey> not what a map is ... the meaning of the type (you seemed to think there was only one 'x' for whatever that was)
11:02:16 <_zenon_> vixey, no, I stated it bluntly, I am sorry if it upset you.
11:06:35 <augustss> @seen Peaker
11:06:35 <lambdabot> I saw Peaker leaving #haskell 1d 19h 36m 54s ago, and .
11:10:18 <Sexpert> does haskell have a default gui?
11:10:53 <smg> what does this mean?
11:11:29 <Sexpert> *standard gui
11:11:42 <Sexpert> apart from 3rd parties
11:12:32 <saml> Sexpert: GHC comes with OpenGL library for many platforms
11:12:49 <saml> other than that, people use Gtk2Hs i think
11:13:56 <schme_> or maybe the xlib bindings. :)
11:14:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8789
11:14:27 <schme_> There's wxHaskell too :)
11:14:41 <Armored_Azrae1> Hey, I've encountered  a type error that I can't fully interpret. I'm probably just being an idiot, but if someone can look at that hpaste post, it'd be appreciated.
11:15:45 <vixey> just remove the fromJust's
11:15:49 <fiddlerwoaroof> and HOC
11:15:54 <fiddlerwoaroof> for mac
11:16:17 <rwbarton> Armored_Azrae1: my first reaction is that 99% of the time, "cannot construct the infinite type ..." means you made some simple error like getting arguments to a function in the wrong order.
11:16:43 <Armored_Azrae1> vixey: Thanks, that fixed it. How do I interpret those errors to figure that out in the future?
11:17:03 <rwbarton> Armored_Azrae1: If you try to interpret it, you'll get confused because you're thinking some function has a type that it doesn't.
11:17:35 <rwbarton> This one is not so bad, the error hints that you are off by a Maybe
11:17:40 <dolio> @remember qwe1234 transactional memory is mutex hell inside.
11:17:40 <lambdabot> Done.
11:18:19 <lament> that would make a cool logo
11:18:30 <lament> "mutex hell inside", in a little circle
11:18:37 <dolio> Heh.
11:19:41 <Riastradh> A padlock with horns contained in a flaming circle, perhaps?
11:19:54 <Armored_Azrae1> rwbarton: Also, just as a general question--I have a feeling that a MaybeT (as analogous to StateT, except for allowing failure) must be useless as nobody has written one. Why?
11:19:55 --- mode: ChanServ set +b palomer!*@*
11:19:55 --- kick: palomer was kicked by ChanServ (Banned:)
11:20:00 <catface> how is forall related to the logical symbol with the same name?
11:20:09 <tusho> who is palomer
11:20:56 <Armored_Azrae1> catface: It is the same.
11:21:21 <kiris> is that the upside down A?
11:22:24 * _zenon_ needs a cup o tea
11:22:53 <_zenon_> kiris: yes , I assume
11:23:05 <rwbarton> Armored_Azrae1: Interesting question.  I suppose one answer is that there is already a 'fail' method built into the Monad class
11:23:10 <_zenon_> kiris: if you mean the all-cuantifier
11:23:17 <_zenon_> quantifier*
11:23:31 <rwbarton> Armored_Azrae1: (Though of course that fail won't always a useful thing in the context of the surrounding computation)
11:23:32 <dolio> @hackage MaybeT
11:23:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT
11:23:40 <_zenon_> rwbarton: thanks again, I guess I was getting the types mixed up
11:23:44 <kiris> I wonder what it's called in xmodmap
11:24:38 <int-e> Armored_Azrae1: the MonadPlus requirement in your MonadPlus instance is a hint - if you have mzero already, you don't have to introduce a second representation (return Nothing) for it.
11:24:57 <rwbarton> Armored_Azrae1: I'm not really sure I believe your MonadPlus instance; I would probably have chosen the one at http://www.haskell.org/haskellwiki/New_monads/MaybeT instead
11:24:59 <lambdabot> Title: New monads/MaybeT - HaskellWiki
11:25:03 <rwbarton> (though I don't have any application in mind)
11:25:20 <Armored_Azrae1> Oh, I didn't see that.
11:25:39 <Armored_Azrae1> I was just annoyed at being unable to mix failing computation with other monads easily and figured a monad transformer was in order
11:26:01 <dolio> That hackage package lacks a MonadPlus instance. Kind of an oversight.
11:27:17 <int-e> the one on the wiki looks more useful to me, too
11:27:29 <Armored_Azrae1> Though I am glad at least that I derived somethings similar to what was derived on the wiki :P
11:27:33 <Armored_Azrae1> <- not very good at this yet
11:28:10 <kiris> yaay I have AltGr and a for 
11:28:31 <kiris> ew, it's lacking antialiasing
11:30:26 <_zenon_> kiris: Niice :)
11:30:33 <_zenon_> I get an 
11:30:53 <kiris> must be my font
11:31:00 <Armored_Azrae1> Oh, I did mean to have the fromJust, it was a different error
11:31:01 <Armored_Azrae1> onesec
11:31:13 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8789#a1
11:31:31 <Armored_Azrae1> Updated version expresses what I actually meant, namely if the computations didn't fail, passthrough to the underlying monad?
11:34:12 <dons> ?yow
11:34:13 <lambdabot> Couldn't find fortune file
11:34:16 <dons> boo
11:34:49 <kiris> @say v_v
11:34:49 <lambdabot> Maybe you meant: faq map slap src
11:35:29 <kiris> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
11:35:31 <lambdabot> http://tinyurl.com/zhxow
11:35:47 <kiris> aww
11:36:29 <kiris> *Lambdabot.Url> runWebReq (urlPageTitle "http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf") Nothing
11:36:29 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf"
11:36:32 <kiris> Just "Title: Monads for functional programming"
11:36:32 <kiris> ^_^
11:39:36 <_zenon_> Wadler's paper is gr8
11:39:57 <marcot> Are -r and -u options from ghc-pkg undocumented?
11:39:59 <marcot> I can't find documentation about it.
11:40:17 <mar77a> > Just "do it"
11:40:32 <lambdabot>  thread killed
11:40:34 <kiris> b rejects bad jokes
11:40:42 <mar77a> maybe it was laughing
11:40:47 <mar77a> didn't get to send to the irc channel
11:40:52 <kiris> laughing ironically
11:41:00 <mar77a> perhaps
11:41:20 * kiris chuckles
11:41:24 <mar77a> @faq did you like my joke
11:41:24 <lambdabot> The answer is: Yes! Haskell can do that.
11:42:31 <_zenon_> will the @faq feature be extended?
11:42:31 <kiris>  a. Doable a  a  a
11:43:16 <mar77a> :>
11:43:21 <kiris> _zenon_: extended with what?
11:43:39 <dolio> You need to get some Greek letters for the type variables in there.
11:43:43 <_zenon_> kiris: bells and whistles
11:43:53 <_zenon_> (TM)
11:44:34 <kiris>  . Doable     
11:44:43 <dolio> There you go.
11:44:47 <shachaf> > Just (do it)
11:44:48 <lambdabot>  Just "do it"
11:44:54 <kiris> :O
11:45:32 <kiris> > shachaf
11:45:41 <lambdabot>  "sneaky \172_\172"
11:46:05 <kiris> mmmkay unicode must be added
11:46:11 <vixey> I agree
11:46:18 <vixey> System.IO.UTF8 exists
11:46:26 <vixey> haven't been able to try it as a drop in replacement though
11:48:08 <fiddlerwoaroof> can haskell functions have unicode identifiers?
11:48:15 <kiris> yeah
11:48:28 <mauke> @faq
11:48:29 <lambdabot> The answer is: Yes! Haskell can do that.
11:48:40 <fiddlerwoaroof> so I could write a function dosomething  = *
11:48:48 <mar77a> no
11:48:50 <kiris> I had  for a beta reduction function
11:48:57 <vixey> fiddlerwoaroof: yes you can do that
11:48:59 <fiddlerwoaroof> or dsomething x = x*2
11:49:03 <kiris> () a b = ...
11:49:05 <vixey> fiddlerwoaroof: just put it in a file
11:51:18 <fiddlerwoaroof> Myfuncs.hs:35:8: lexical error (UTF-8 decoding error)
11:51:33 <fiddlerwoaroof> () x y = x+y
11:51:46 <dolio> vixey: You know off hand how type checking ala Agda is done? With a type for the whole function instead of on every formal parameter of a lambda?
11:51:57 <vixey> that works for me fiddler
11:52:06 <dolio> vixey: Is it Hindley-Milner style inference, followed by unification with the overall type at the end?
11:52:35 <kiris> fiddlerwoaroof: works for me too
11:52:35 <vixey> dolio: I think the collect up sets of constraints while type checking and try to resolve them as much as possible to get the term/type inferrence
11:53:11 <fiddlerwoaroof> vixey, kiris: not for me on mac in ghci
11:53:11 <kiris> vixey: what ghc version do you use?
11:53:25 <kiris> fiddlerwoaroof: doesn't work for me in ghci, but works when compiling
11:54:29 <fiddlerwoaroof> not on Mac with ghc 6.8.3
11:54:39 <vixey> fiddlerwoaroof: what does: return . map Data.Char.ord =<< System.IO.UTF8.readFile "tmp.hs"   print for you?
11:54:55 <vixey> tmp.hs should be the file with that single definition in it
11:54:57 <mar77a> :t (=<<)
11:54:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:55:14 <mar77a> is =<< like a reversed >>= ?
11:55:15 <kiris> :t flip (>>=)
11:55:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
11:55:20 <mar77a> flipped yeah
11:55:23 <mar77a> oooo
11:56:33 <fiddlerwoaroof> Failed to load interface for `System.IO.UTF8'
11:56:47 <kiris> cabal install utf8-string
11:57:24 <vixey> fiddlerwoaroof: oh maybe just try: return . map Data.Char.ord =<< readFile "tmp.hs"
11:58:46 <dolio> vixey: Have you done any checking of languages with strong sums? I was reading about the extended calculus of constructions yesterday and their pairing constructor is like 'pair_{Sigma x:A.B}(M,N)' which is kind of a pain to type (on the keyboard).
11:58:54 <fiddlerwoaroof> vixey: [40,195,184,41,32,120,32,121,32,61,32,120,43,121,10]
11:59:37 <vixey> odd that's what I get
12:00:04 <fiddlerwoaroof> I installed utf8-string and everything magically worked
12:00:23 <kiris> O_o
12:00:25 <fiddlerwoaroof> even in ghci
12:00:31 <mar77a> is the number 1 considered a prime
12:00:34 <kiris> does ghc use utf8-string or something?
12:00:39 <ziman> @oeis [61, 52, 63, 94, 46]
12:00:39 <lambdabot> Sequence not found.
12:01:11 <vixey> dolio: I've not written a type checker for, but there's an algorithmic presentation of UTT in Computation and Reasoning (possibly also Luos thesis as well then)
12:01:11 <fiddlerwoaroof> however, Terminal.app has lousy unicode support
12:03:51 <_zenon_> hmmm....
12:03:54 <_zenon_> which tea
12:04:32 <vixey> mar77a: No 1 is not a prime number
12:05:03 <vixey> mar77a: You can use the definition "Has exactly two factors" for a prime
12:05:26 <vixey> (this is not the usual definition)
12:05:46 <ahunter> mar77a: the reason it isn't is because mathematicians want every integer to have a unique prime factorization
12:06:00 <mar77a> what's the unique prime factorization for 1
12:06:05 <roconnor> a prime is an atom in the lattice of divisability
12:06:16 <roconnor> 1 is the bottom element in that lattice
12:06:29 <ahunter> mar77a: e.g 75 = 3*5*5; if we allow 1 as prime, then 75 = 3*5*5 = 3*5*5*1 = 3*5*5*1*1 =...
12:06:29 <_zenon_> > randomR (1,0) (mkStdGen 1238)
12:06:30 <lambdabot>  (1,49577346 40692)
12:06:37 <_zenon_> Roibos it is
12:06:40 <byorgey> mar77a: it's the empty factorization, with no prime factors =)
12:06:47 <byorgey> > product []
12:06:49 <lambdabot>  1
12:06:50 <roconnor> > product [3,5,5]
12:06:52 <lambdabot>  75
12:07:20 <ahunter> mar77a: if you want to get pedantic about it, "every natural number >1"...
12:07:31 <byorgey> roconnor: what's the definition of an atom in a lattice?
12:07:37 <byorgey> I haven't heard that term before
12:08:09 <roconnor> hmm
12:08:21 <byorgey> ahunter: it works for 1 too, if you allow the empty factorization
12:08:40 <ahunter> byorgey: true...at this point, we're getting into pretty much irrelevant details
12:08:42 <vixey> byergey neat empty factorization never thought of that
12:09:04 <roconnor> byorgey: I think I'll have to look it up to be sure to get the right definition
12:09:15 <byorgey> roconnor: heh, don't worry then, I can just look it up myself =)
12:10:37 <mar77a> interesting, thanks
12:10:42 <byorgey> roconnor: ah, makes sense, it is an element which is minimal among non-bottom elements
12:11:19 <roconnor> that's a classical definition
12:11:36 <byorgey> "classical"?
12:11:39 <gwern> data Color3 a = Color3 !a !a !a Cthulhu Fthagn!
12:11:45 <roconnor> as opposed to constructive
12:11:46 <gwern> (hee hee)
12:11:52 <vixey> heh
12:12:09 <byorgey> roconnor: oh, I see.  how would you give a constructive definition?
12:12:34 <roconnor> byorgey: that's what I was trying to think of. :)
12:12:42 <byorgey> ah =)
12:15:00 <roconnor> maybe there is no way to saying something is an atom without saying that it isn't bottom.
12:20:00 <roconnor> 3 and -3 are equivalent when it comes to divisability
12:20:20 <roconnor> > 3 `mod` (-3)
12:20:21 <lambdabot>  0
12:20:33 <roconnor> > (-3) `mod` 3
12:20:34 <lambdabot>  0
12:20:50 <Cale> -3 is also prime
12:20:51 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:21:05 <roconnor> it is the same prime as 3
12:21:12 <vixey> Cale: that ruins everything
12:21:17 <vixey> oh roconnor fixed it
12:21:18 <Cale> vixey: no it doesn't
12:21:34 <Cale> Well, it's part of the same prime ideal.
12:22:20 <Cale> A prime p is a nonzero nonunit which has the property that whenever p | ab, then p | a or p | b
12:22:53 <Cale> (where x | y means that y = k x for some k)
12:23:01 <roconnor> Cale: you don't need to say nonzero.
12:23:28 <Cale> Yes I do.
12:23:38 <roconnor> really?
12:23:43 <roconnor> oh right
12:24:16 <roconnor> that's really unfortunate.
12:24:43 <roconnor> now I don't like that definition anymore.
12:25:37 <rwbarton> roconnor: The ideal (0) of Z is still a prime ideal, though.  (which I think you were hinting at?)
12:26:03 <roconnor> It is a prime ideal?
12:26:16 <roconnor> interesting
12:26:44 <roconnor> yet 0 occurs at the top of the divisibility lattice.
12:28:21 <roconnor> > lcm [1..]
12:28:22 <lambdabot>   add an instance declaration for (Integral [t])
12:28:46 <Cale> <0> is a prime ideal iff the ring in question is an integral domain (which Z is)
12:32:39 <Cale> (An ideal is prime if and only if quotienting by it gives you an integral domain, and quotienting by <0> always produces an isomorphic ring.)
12:33:53 <rwbarton> A good picture to think about is the poset of prime ideals ordered by inclusion, with (0) at the bottom and all the primes (p) above it.
12:35:29 <Cale> Oh, I should be careful to say commutative ring :)
12:42:05 <weirdo> hi
12:42:18 <weirdo> what's the problem domain FPs like haskell or ml excel in?
12:43:42 <ibid> compilers
12:44:12 <ttfh> compilers for FPs like haskell or ml :-)
12:44:19 <ibid> for anything
12:44:21 <vixey> just about every program is a compiler :P
12:44:34 <schme_> window managers? ;)
12:44:34 <ibid> though fp people tend to write compilers for fp languages
12:44:45 * rwbarton expected someone to say "imperative programming"
12:45:14 <Botje> > scanr1 lcm [1..]
12:45:16 <lambdabot>  [Exception: stack overflow
12:45:20 <Botje> > scanl1 lcm [1..]
12:45:21 <lambdabot>  [1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720,12...
12:45:21 <ttfh> didn't someone say that haskell was also the best imperative language?
12:45:33 <weirdo> thought you'd say something along the lines of math or research
12:46:01 <shepheb> @quote first.class.*imperative.programming
12:46:01 <lambdabot> SamB says: Haskell is the only language I know with first-class support for imperative programming
12:46:39 <weirdo> the hindley-milner type checker looks pretty sophisticated, but for the problem domains i handle the tradeoff for dynamic programming isn't worth it
12:46:49 <weirdo> so i thought i'd tackle problems where FPs are more usable
12:47:13 <vixey> I don't know
12:47:22 <vixey> I have found it very hard to write type checkers in haskell
12:47:32 <vixey> but then I have seen others do it very well
12:47:44 <Botje> vixey: i'm still going to write one in an hour ;)
12:47:51 <Botje> after i come back from spain
12:48:04 <vixey> Botje: for the ML compiler ?
12:48:09 <Botje> yeah
12:48:09 <vixey> are you in spain now ?
12:48:13 <Botje> nah
12:48:14 <vixey> ok
12:48:16 <Botje> leaving in 12 hours
12:48:26 <vixey> huh????
12:48:43 <Botje> what?
12:48:47 <vixey> well anyway, I think it would be cool to see it Botje, please show me it once it's done
12:48:49 <Botje> i'm leaving for spain in 12 hours
12:48:57 <Botje> sure :)
12:49:05 <vixey> (I don't know how you could do it in one hour after you get back if you aren't even leaving for 12)
12:49:13 <vixey> > 1 > 12
12:49:14 <lambdabot>  False
12:49:21 <Botje> ah
12:49:27 <Botje> i'm going to write one in the timeframe of an hour :)
12:49:31 <vixey> ohh ok
12:50:14 <Botje> @quote deadline
12:50:15 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
12:50:17 <Botje> boo :(
12:54:07 <kiris> Cale: ping!?
12:54:24 <Botje> #quote
12:54:27 <Botje> gah
12:54:29 <Botje> @quote
12:54:29 <lambdabot> JonHarrop says: As Haskell has shown, laziness cannot be implemented efficient at all.
12:54:39 <vixey> lolo
12:54:42 <vixey> @quote harrop
12:54:43 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
12:54:43 <kiris> isn't he the F# nut?
12:54:56 <geezusfreeek> @quote qwe1234
12:54:56 <lambdabot> qwe1234 says: being garbage collected pretty much ensures that any and all multi-core implementation will get totally ruined and become unusable.
12:55:03 <vixey> @quote jdh
12:55:03 <lambdabot> No quotes match. My brain just exploded
12:55:09 <geezusfreeek> @quote qwe1234
12:55:10 <lambdabot> qwe1234 says: the statement that c++ is 'simpler' than assembly is so patently stupid i have doubts that you can program at all.
12:55:16 <kiris> walks into the Comp.Lang.Lisp newsgroup and says "ladies and gents I'm here to talk to you about a special language called F#"
12:55:39 <Botje> "special bus"-special?
12:55:44 <kiris> haha
12:56:24 * BMeph thought it was "short-bus" special, but whatever...
12:59:14 <_zenon_> Why do I always get console focus when typing Ctrl+s  ?
12:59:34 <_zenon_> just the moment before, I always accidentaly drift with the pointer
12:59:40 <mjrosenb> _zenon_: 'console focus'?
12:59:55 <_zenon_> then I spend 1 second on pressing Ctrl+q
13:00:28 <_zenon_> a lot of seconds in my life there...
13:01:07 <Associat0r> I like F#
13:01:47 <kiris> > cycle $ "Cale!! "
13:01:48 <lambdabot>  "Cale!! Cale!! Cale!! Cale!! Cale!! Cale!! Cale!! Cale!! Cale!! Cale!! Cale!...
13:05:54 <ziman> @quote qwe1234
13:05:54 <lambdabot> qwe1234 says: dynamic typing is *always* a compiler bug.
13:06:10 <vixey> @quote
13:06:11 <lambdabot> scodil says: you say sledgehammer like it's a bad thing
13:06:14 <vixey> hehe
13:06:24 <vixey> @quote jdh
13:06:25 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
13:06:26 <vixey> @quote
13:06:26 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
13:06:26 <lambdabot> regeneration."
13:06:51 <Heffalump> @quote jdh30
13:06:51 <lambdabot> No quotes match. It can only be attributed to human error.
13:08:20 <_zenon_> @quote lambdabot
13:08:20 <lambdabot> lambdabot says: I know everything hasn't been quite right with me, but I can assure you now, very confidentaly, that it's going to be all right again.  I feel much better now.  I really do.
13:08:38 <vixey> :)
13:08:44 <dolio> @quote JonHarrop
13:08:44 <lambdabot> JonHarrop says: As Haskell has shown, laziness cannot be implemented efficient at all.
13:10:56 <_zenon_> @quote vixey
13:10:56 <lambdabot> No quotes match.
13:12:01 <dolio> @type (\n f x -> f (n f x)) :: ((k -> l) -> i -> k) -> (k -> l) -> i -> l
13:12:03 <lambdabot> forall k l i. ((k -> l) -> i -> k) -> (k -> l) -> i -> l
13:12:11 <dolio> Woo.
13:13:33 * Beelsebob ponders if Cale is about
13:13:52 <Cale> I'm here
13:16:11 <Beelsebob> Cale: would it be possible to configure \bot to only print URL titles when the URL is on an black-list -- e.g. only when it's youtube/tinyurl -- dons said this is possible, and people in #macosx are saying they think it's an awesome bot, other than it spams the channel whenever someone posts a link
13:16:43 <Botje> _zenon_: you can disable scroll lock in inputrc
13:16:49 <Botje> uh
13:16:54 <Botje> or even just in your term settings
13:17:26 <_zenon_> Botje: hehe, thanks :) I've been meaning to fix this... soon.... any day now :)
13:17:31 <Cale> Beelsebob: Wait, only print titles for youtube urls? Wha?
13:17:48 <_zenon_> Botje: But "things" just keep coming in the way :)
13:17:54 <Cale> Beelsebob: It's possible to alter the URL module in various ways of course.
13:18:11 <Botje> zeno_: stty stop  ^-
13:18:12 <Botje> stty start ^-
13:18:20 <Botje> put that somewhere. be happy.
13:18:29 <vixey> oh this makes no sense http://www.math.uiuc.edu/People/pillay/lecturenotes_modeltheory.pdf
13:18:32 <Beelsebob> Cale: well, for a whitelist -- thing is, that people get irritated when it prints things like "Title: Test.com" for http://www.test.com
13:18:35 <lambdabot> http://tinyurl.com/58vjcn
13:18:39 <Beelsebob> which happens to be the bulk of URLs
13:18:46 <Beelsebob> on the other hand
13:18:57 <Beelsebob> it's really really useful for stuff like youtube/tinyurl to see what's on the other side
13:19:48 <Cale> Personally, I like it working for all URLs, but I can see how some people might only want less. If you send me a patch that makes it configurable on a per-channel basis, that would surely be accepted.
13:20:19 <Cale> It should be easy to tell which channel the messages are in...
13:20:22 <Beelsebob> okies, hmm -- this would involve getting working hsplugins
13:20:26 <byorgey> it seems to me that it's much more useful for the kinds of links that get posted in here (titles of papers, and so on...)
13:20:29 <Beelsebob> is there a current recommended way to do this?
13:20:43 <Cale> Beelsebob: lambdabot is (or at least should be) easier to install these days.
13:20:59 <Beelsebob> Cale: yeh, I tried going through the deps in cabal, but it fails at hsplugins
13:21:04 <Cale> Make sure that you have cabal-install installed, and then get the darcs repo from code.haskell.org
13:21:08 <Cale> oh
13:21:10 <Baughn> Beelsebob: You can build LB without hs-plugins easily enough; just disable building runplugs
13:21:13 <Cale> What platform?
13:21:21 <Beelsebob> Cale: OS X, Linux and Windows
13:21:23 <Baughn> (Which disables @eval, of course)
13:21:27 <Beelsebob> and ghc 6.8.2
13:21:30 <Cale> Beelsebob: It should be fine on linux.
13:21:42 <Beelsebob> hmm, failed on Ubuntu just a few days ago :/
13:21:43 <Cale> Beelsebob: *Don't* use the cabal lambdabot.
13:21:49 <Beelsebob> oh, okay
13:21:53 <Cale> (If it still exists.)
13:21:57 <Beelsebob> it does still exist
13:22:03 <Cale> er, hackage, rather
13:22:10 <Beelsebob> I'll just configure it for no hsplugins
13:22:16 <Cale> Lambdabot uses cabal, but the package on hackage is broken.
13:22:16 <Beelsebob> and hack the URL reporting module
13:22:27 <Cale> okay
13:23:01 * Beelsebob ponders exactly how much config one wants with it -- in that #haskell presumably wants a lot of reporting, while #macsox seems to want as little as possible
13:23:04 <Cale> It would be nice to fix it at some point, but at the moment, lambdabot is designed to run out of the directory in which you build it.
13:23:38 <Cale> You might just configure it such that it can be turned on or off on a per-channel basis.
13:23:53 <Cale> But if you want to go farther, that would be cool too :)
13:24:36 <kiris> my latest patches of the Url module would've shown the title of that PDF :P
13:24:46 <Beelsebob> hehe
13:24:50 <Cale> kiris: are they in my mailbox?
13:25:01 <Cale> Well, I can check :)
13:25:03 <kiris> I think I sent you a @tell a couple days ago
13:25:07 <Cale> oh
13:25:10 <Cale> hmm :)
13:25:21 <kiris> just to pull the patch. I guess I could try to e-mail you
13:25:30 <Cale> no, it's cool :)
13:25:39 <kiris> :D
13:25:54 <mar77a> > sum [1..100]
13:25:56 <lambdabot>  5050
13:26:05 <vixey> > 100*101/2
13:26:06 <lambdabot>  5050.0
13:26:40 <kiris> Cale: would you accept a patch for b for unicode support?
13:26:47 <roconnor> > 100*101 `div` 2
13:26:48 <lambdabot>  5050
13:27:00 <Cale> kiris: as it happens, I just got a patch for that, apparently
13:27:08 <kiris> Cale: oh, awesome ^_____^
13:27:31 <kiris> Cale: mine was just adding System.IO.UTF8 and an encodeString call. what's that patch like?
13:27:41 <Saizan_> kiris: the same :)
13:27:41 <vixey> > let () = (,) in 1  3
13:27:41 <lambdabot>  Illegal character ''\151''
13:27:41 <lambdabot>  at ")" (column 7)
13:27:47 <kiris> Saizan_: you!!
13:28:06 <Saizan_> (decodeString actually, iirc)
13:28:07 * kiris hugs
13:28:19 <kiris> interesting
13:28:44 <kiris> can you paste the patch?
13:28:55 * vixey wonders why lambdabot doesn't support unicode in the first place ...
13:28:58 <Saizan_> however i'm realizing that instead of putting it in runplugs one could add it to parseExpr since e.g. smallcheck suffer the same bug
13:29:15 <kiris> is utf8-string older than b?
13:29:25 <Saizan_> very much older
13:29:26 <kiris> flip (my_previous_sentence)
13:29:28 <kiris> oh
13:29:39 <Botje> when is \bot's birthday anyway? :)
13:30:06 <kiris> @vixen birthday?
13:30:07 <lambdabot> no
13:30:10 <Saizan_> oh, flip my answer too :)
13:30:10 <kiris> :(
13:30:14 * Cale rebuilds lambdabot with the new patches :)
13:30:16 <kiris> Saizan_: haha
13:30:22 <kiris> Cale: woo.
13:30:25 * kiris crosses fingers
13:30:28 <Saizan_> \bot is older than utf8-string :)
13:30:38 <kiris> right =]
13:30:41 <Cale> http://en.wikipedia.org/w/index.php?title=Comparison_of_file_systems&oldid=220529437#Features --- ahahaha, check out the last column.
13:30:42 <lambdabot> Title: Comparison of file systems - Wikipedia, the free encyclopedia, http://tinyurl.com/5gdlfm
13:30:55 <kiris> haha
13:32:01 <kiris> someone should add No[1]
13:32:24 <kiris> Cale: does it build?
13:33:00 <Cale> seems to :)
13:33:24 <vixey> > let () = (,) in 1  3
13:33:29 <lambdabot>  Illegal character ''\215''
13:33:35 <lambdabot>  at ")" (column 6)
13:33:41 <kiris> haha
13:33:44 <kiris> it's like half support
13:33:50 <vixey> that's an improvement :S
13:33:54 <kiris> we're getting there :p
13:34:03 <kiris> > ""
13:34:08 <Saizan_> > let  = 1 in 
13:34:09 <lambdabot>  "\955"
13:34:15 <lambdabot>  1
13:34:23 <kiris> that's a correct output (the )
13:34:32 <vixey> :(
13:34:58 <Beelsebob> > System.IO.UTF8.print "" -- won't work of course because of bot's IO restrictions
13:35:05 <lambdabot>   Not in scope: `System.IO.UTF8.print'
13:35:30 <kiris> > let () = (++) in "foo" `` "boo"
13:35:35 <lambdabot>  "fooboo"
13:35:39 <kiris> yaay
13:35:43 <mauke> > 
13:35:47 <lambdabot>  Illegal character ''\8364''
13:35:53 <lambdabot>  at "" (column 1)
13:35:56 <vixey> Prelude> let () = (,) in 1  3
13:35:56 <vixey> (1,3)
13:36:00 <mauke> > 
13:36:05 <lambdabot>   Not in scope: `'
13:36:08 <Heffalump> anyone familiar with QuickCheck 2?
13:36:09 <mauke> heh
13:36:10 <vixey> why it doesn't work in lambda bot :?
13:36:11 <kiris> oh dear
13:36:13 <Beelsebob> something I want is a "unicode prelude" in which things like Set.union are replaced with Set.
13:36:26 <Baughn> vixey: IRC supports only ASCII. Says so right there in the spec.
13:36:42 <vixey> UTF8
13:36:44 <Saizan_> Baughn: that's not the problem
13:37:02 <Cale> > let _ = 1 in _
13:37:02 <lambdabot>  Illegal character ''\9681''
13:37:02 <lambdabot>  at "_" (column 5)
13:37:04 <Baughn> vixey: IRC servers are not required to be 8-bit clean. Use utf7
13:37:04 <kiris> haha
13:37:08 <Baughn> Saizan_: I know. ;)
13:37:11 <Saizan_> vixey: the problem is that we've to parse the expression with Language.Haskell.Parser to avoid code injection, and it's quite buggy
13:37:25 <kiris> nez!!
13:37:31 <EvilTerran> can it not hook into the ghc parser somehow?
13:37:33 <Cale> Baughn: Freenode is UTF-8
13:37:52 <Baughn> Cale: Then it's not irc
13:37:52 <kiris> Saizan_: ahhh
13:37:53 <EvilTerran> or would you have to embed all of ghc into your binary to do that?
13:37:54 <Cale> Though I wish they'd allow UTF-8 chars in nicks and channel names :)
13:37:57 <Beelsebob> Cale: random thought, because I don't know \bot's architecture too well -- is there a better place to put a module's config than in Config.hs?
13:37:59 <vixey> IRC sucks
13:38:04 <Beelsebob> i.e. is there a config specifc to the module?
13:38:04 <Saizan_> so, my patch managed to pass proper Unicode to parseExpr, but it still fails with esotic characters
13:38:07 <vixey> Cale: and colors!!
13:38:13 <Cale> Beelsebob: Well, you can put it in the module state.
13:38:15 <kiris> Cale: yeah, like the reverse character v_v
13:38:24 <byorgey> hm, my mail to support@community.haskell.org has been 'delayed' due to a 'temporary failure'
13:38:26 <Riastradh> Baughn, the IRC protocol doesn't forbid UTF-8 in PRIVMSG content.  All it talks about is octets.
13:38:26 <Baughn> Cale: We need irc to support blinking and animation, too
13:38:37 <Cale> Baughn: hand-drawn images :)
13:38:39 <kiris> Baughn: blinking is a must
13:38:41 <Baughn> Riastradh: Hm? Pretty sure it stated "ascii" somewhere
13:38:50 <vixey> hand-drawn images would be great
13:38:59 <vixey> should be possible with CTCP though
13:39:00 <kiris> like Oekaki
13:39:02 <Beelsebob> Cale: hmm, so each time \bot crapped its pants (hopefully rare) you would have to do something like @url-mode blacklist
13:39:04 <Cale> :)
13:39:10 <Beelsebob> if I understand you right?
13:39:11 <vixey> It's just if one person implements it.. not everyone has suppport
13:39:19 <kiris> "monads are like this, whoops my hand slipped"
13:39:24 <Cale> Beelsebob: If the state got dropped on the floor somehow
13:39:26 <Riastradh> RFC 1459, Section 2.2 `Character codes':  No specific character set is specified.  The protocol is based on a set of codes which are composed of eight (8) bits, making up an octet....  Regardless of being an 8-bit protocol, the delimiters and keywords are such that the protocol is mostly usable from USASCII terminal and a telnet connection.
13:39:47 <Baughn> Oh. Well, that's half-assed.
13:39:57 <Riastradh> IRC is half-assed.
13:40:21 <Cale> We really need a well-designed new IRC protocol.
13:40:25 <bd_> It gets fun when you bring in asian languages into the mix.
13:40:25 <Riastradh> The trouble is that it caught on, and there's nothing else popular that does quite the same thing.
13:40:38 <Heffalump> IRC is nice and simple.
13:40:40 <bd_> Japanese has no less than three popular 8-bit (or in one case, 7-bit) character sets in wide use.
13:40:52 <wuxia> :t $
13:40:52 <lambdabot> parse error on input `$'
13:40:56 <wuxia> :t .
13:40:57 <lambdabot> parse error on input `.'
13:40:59 <roconnor> :t ($)
13:41:00 <lambdabot> forall a b. (a -> b) -> a -> b
13:41:00 <kiris> maybe if Freenode provided an alternative server with a new fresh protocol for people to transition onto slowly
13:41:02 <roconnor> :t (.)
13:41:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:41:05 <Baughn> bd_: utf-8 and utf-16 too, iirc
13:41:09 <EvilTerran> :t (Prelude..)
13:41:10 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:41:10 <roconnor> Cale!!!
13:41:13 <bd_> Baughn: I was counting UTF-8 :)
13:41:14 <roconnor> oh right
13:41:17 <bd_> UTF-16 isn't 8-bit
13:41:18 <EvilTerran> ?hoogle (.)
13:41:19 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
13:41:19 <lambdabot> Data.Function.(.) :: (b -> c) -> (a -> b) -> a -> c
13:41:19 <lambdabot> Data.Bits.(.&.) :: Bits a => a -> a -> a
13:41:30 <EvilTerran> that's the one to go for, i guess
13:41:30 <bd_> or rather, it uses NULs
13:41:35 <bd_> so you probably won't see it on IRC
13:41:57 * roconnor should write a new lambdabot
13:42:10 <roconnor> one that doesn't have (.) = fmap
13:42:17 <roconnor> or
13:42:18 <vixey> why not have (.) = fmap?
13:42:21 <Heffalump> roconnor++
13:42:27 <roconnor> I should write a new Haskell report
13:42:30 <vixey> yay
13:42:32 <roconnor> one that has (.) = fmap
13:42:39 <vixey> roconnor: do that!
13:42:46 <vixey> except don't even make it a haskell report
13:43:00 <roconnor> Caleskell report?
13:43:06 <Heffalump> don't forget to rename the channel too
13:43:10 <dibblego> roconnor, if you do, please support multiple languages :)
13:43:10 <kiris> Hascale
13:43:18 <roconnor> dibblego: in what way?
13:43:23 <dibblego> (new lambdabot that is)
13:43:37 <roconnor> dibblego: in what way?
13:43:40 <dibblego> roconnor, I have to use lambdabot over at #scala to demonstrate a concept to users
13:43:50 <dibblego> then of course, they ask "what language is that?"
13:43:57 <fons> hi all
13:44:03 <kiris> dibblego: clever
13:44:10 <EvilTerran> "haskell. mostly."
13:44:25 <fons> this one might be really simple but I'm stuck
13:44:31 <dibblego> "A trimmed down version of Scala"
13:44:34 <kiris> fons: go for it =]
13:44:44 <dolio> dibblego: You should tell them it's CAL. :)
13:44:52 <dibblego> hehe
13:45:56 <roconnor> dibblego: you mean you want lambdabot to support multiple programming languages.
13:46:05 <dibblego> roconnor, sorry for not being clear, yes
13:46:20 <_zenon_> and extend @faq  :)
13:46:22 <fons_> I want to code a parallel map, which given a list of lists all lists are processed in parallel lazily
13:46:29 <fons_> for example
13:46:49 <kiris> lambdabot: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
13:46:50 <Heffalump> 8hKbctDk
13:46:56 <Heffalump> gah, sorry
13:48:01 <fons_> parMap (+1) [[1,2,3][1,2][1]] = [[2],[2],[2]]
13:48:07 <kiris> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
13:48:08 <lambdabot> Title: Monads for functional programming, http://tinyurl.com/zhxow
13:48:12 <kiris> there we go! :)
13:48:23 <andun> how is ((->) r) defined as a Functor?
13:48:44 <shepheb> @src Functor ((->) r)
13:48:44 <lambdabot> Source not found.
13:48:47 <wuxia> @hoogle hPutStr
13:48:47 <lambdabot> System.IO.hPutStr :: Handle -> String -> IO ()
13:48:47 <lambdabot> Data.ByteString.hPutStr :: Handle -> ByteString -> IO ()
13:48:47 <lambdabot> Data.ByteString.Char8.hPutStr :: Handle -> ByteString -> IO ()
13:48:58 <quicksilver> andun: function composition
13:49:01 <Cale> andun: fmap = (.)
13:49:09 <quicksilver> andun: (r -> a) -> (a -> b) -> (r -> b)
13:49:20 <quicksilver> permute the first two args according to taste.
13:49:22 <Cale> That is,  fmap f g x = f (g x)
13:49:41 <fons_> parMap (+1) [[],[1..],[2..]] = [[],[],[]]
13:49:42 * Heffalump finishes changing his password :-)
13:49:49 <Cale> It really must be (a -> b) -> (r -> a) -> (r -> b)
13:50:23 <fons_> I coded it but I couldnt find a way to avoid traversing the lists more than once
13:51:27 <Saizan_> @where report
13:51:27 <lambdabot> http://www.haskell.org/onlinereport/
13:52:10 <andun> what kind of type is ((->) r) anyway?
13:52:31 <vixey> hmm
13:52:53 <dolio> 2/3 of a function type.
13:52:53 <Baughn> andun: A partially applied one
13:52:54 <mauke> the type constructor of functions from r
13:53:04 <dolio> Or 1/2, maybe, depending on how you look at it.
13:53:56 <vixey> is ((->) r) actually a type ?
13:53:58 <vixey> it's not a type
13:54:03 <rwbarton> @kind ((->) Int)
13:54:04 <lambdabot> ? -> *
13:54:06 <EvilTerran> it's a type expression
13:54:06 <vixey> it's a type constructor
13:54:07 <byorgey> andun: ((->) r) is not a type, it is a type constructor.  when applied to another type it yields the type of functions from r to that other type.  e.g. ((->) r) a  is  r -> a
13:54:26 <byorgey> just like ((+) 1) 2  is 1 + 2
13:54:49 <andun> i get it
13:54:56 <EvilTerran> are there any interesting properties (like (e->) = Reader e) for (->e)?
13:55:03 <EvilTerran> (i know you need a newtype to write that in haskell)
13:55:26 <andun> is instance ((->) r) Blabla Haskell98?
13:56:14 <EvilTerran> yeah
13:56:15 <byorgey> andun: I... think so
13:56:31 <dolio> It's of the form T a b c ...
13:56:33 <byorgey> (and btw, it's the other way around: instance Blabla ((->) r)
13:56:47 <andun> oh, yeah
13:59:53 <kiris> if you have (a -> b) -> f a -> f b
13:59:55 <wuxia> i want to put in a handle2 function that intercepts all calls to handle and prints out a msg; what i currently have does not work; how should I fix it? handle2 :: Event -> X()
13:59:58 <wuxia> handle2 _ = do putStr "handle2 interceptor\n" handle _
14:00:29 <kiris> and some type can be unified with it such at f a is unified with Maybe Int, would you say Maybe Int is unifiable with f a?
14:00:38 <kiris> s/such at/such that
14:01:03 <vixey> yes
14:01:15 <kiris> ok
14:01:29 <quicksilver> wuxia: handle2 e = do liftIO (putStr "interceptor\n"); handle e
14:01:30 <ronwalf> Is there a way to combine parsec GenParsers that have different state?
14:01:32 <quicksilver> wuxia: I think.
14:01:46 <quicksilver> wuxia: but I'm not an xmonad expert
14:01:49 <wuxia> quicksilver: will try it out; thanks
14:02:19 <kiris> sorry, I don't play pokemon
14:02:35 <EvilTerran> ronwalf, i think you have to tuple or use Either (whichever is appropriate)
14:02:51 <byorgey> quicksilver: that works, although idiomatic xmonad code uses the provided 'io' for convenience instead of 'liftIO' =)
14:02:59 <quicksilver> ;)
14:03:27 <ddarius> ganymede (putStrLn "Error foo")
14:03:33 <byorgey> hahaha
14:03:55 <EvilTerran> ronwalf, you can probably abstract that away entirely tho with a couple of worker functions
14:03:56 <byorgey> the next release of xmonad will use 'calliope'
14:04:03 <EvilTerran> ronwalf, alternatively, you can add a StateT
14:06:55 <EvilTerran> ronwalf, in the next version of Parsec, it's a monad transformer, iirc, and there's no state built-in - you have to use a StateT Parsec from the outset (or a ParsecT State, depending on what behaviour you want)
14:07:12 <EvilTerran> (the types may not be called Parsec(T))
14:08:16 <dolio> They are called Parsec(T)
14:08:32 <EvilTerran> glad my memory is functioning correctly :)
14:09:24 <dolio> It still has built-in state, though, I'm pretty sure.
14:10:27 <EvilTerran> ?where parsec
14:10:27 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
14:10:49 <ddarius> No.  The user state is still there.
14:11:02 <EvilTerran> oh right, i stand corrected
14:12:01 <EvilTerran> seems odd to leave it in, given you can get the same thing with transformers
14:12:50 <gwern> I wonder whether Roman's Hpysics project is cleverly named, or a spelling error?
14:13:29 <Saizan_> http://www.haskell.org/onlinereport/lexemes.html <- in the definition of symbol, uniSymbol< special | _ | : | * | ' > means uniSymbol excluding the chars inside < .. > ?
14:13:29 <lambdabot> Title: Haskell 98 Lexical Structure
14:14:29 <EvilTerran> Saizan_, i think it say something to that effect somewhere, yeah
14:15:46 <Saizan_> EvilTerran: yeah, at the top of the page, d'oh
14:15:51 <macondo> > map (\x -> (length x, nub x !! 0)) (groupBy (\x y -> (x==y)) (sort a)) in "I'm starting to love Haskell"
14:15:51 <lambdabot>  Parse error at "in" (column 72)
14:16:14 <vixey> > let x & y = x**(-1) * y**(-1) * x * y ; x ^ y = y**(-1) * x * y in [ ((x & y) & z ^ x) * ((y & z) & x ^ y) * ((z & x) & y ^ z) | x <- [1..] , y <- [1..x] , z <- [1..y] ] :: [CReal]
14:16:20 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,Exception: Time limit exceeded
14:16:22 <kiris> @_@
14:16:25 <EvilTerran> what
14:16:25 <vixey> > fix (1:)
14:16:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:16:44 <EvilTerran> that's impressively inefficient
14:17:36 <macondo> > let countChars xs = map (\x -> (length x, nub x !! 0)) (groupBy (\x y -> (x==y)) (sort xs)) in countChars "do you think this is a good approach?"
14:17:37 <lambdabot>  [(7,' '),(1,'?'),(3,'a'),(1,'c'),(2,'d'),(1,'g'),(3,'h'),(3,'i'),(1,'k'),(1,...
14:17:59 <vixey> countChars = (length && head) . group . sort
14:18:18 <vixey> > (length &&& head) . group . sort $ "nshtaouenstaeuotnhs"
14:18:19 <lambdabot>  (8,"aa")
14:18:30 <EvilTerran> (\x y -> (x==y)) = (==)
14:18:32 <vixey> huh that's not what I meant
14:18:34 <vixey> > map (length &&& head) . group . sort $ "nshtaouenstaeuotnhs"
14:18:35 <EvilTerran> groupBy (==) = group
14:18:35 <lambdabot>  [(2,'a'),(2,'e'),(2,'h'),(3,'n'),(2,'o'),(3,'s'),(3,'t'),(2,'u')]
14:18:56 <ddarius> gwern: It's intentionally written that way.
14:19:10 <macondo> EvilTerran: ah, didn't know that
14:19:12 <EvilTerran> nub applied to an element of (group xs) won't change it
14:19:18 <mjrosenb> let f = ($grabModSign)
14:19:18 <mjrosenb> quad <- (f.f.f.f $ liftM4 (,,,)) quad
14:19:18 <EvilTerran> (!!0) = head
14:19:32 <mjrosenb> can anyone think of a better way to do that?
14:19:45 <rwbarton> also isn't nub x !! 0 the same as head?
14:20:07 <EvilTerran> so countChars  = map (\xs -> (length xs, head xs)) . group . sort
14:20:11 <roconnor> mjrosenb: what does it do?
14:20:15 <EvilTerran> rwbarton, <EvilTerran> (!!0) = head
14:20:27 <ddarius> EvilTerran: What he meant was head x
14:20:28 <EvilTerran> and the line above
14:20:37 <rwbarton> EvilTerran: Yes, but moreover nub doesn't change the first element of the list.
14:20:52 <EvilTerran> rwbarton, yeah, that's my line immediately above the (!!0) one :)
14:20:56 <rwbarton> EvilTerran: (True, especially not when the list has no duplicates already)
14:21:08 <ddarius> EvilTerran: It applies generally.
14:21:11 <mjrosenb> roconnor: it's sort of like mapM, but specificaly for a 4-uple
14:21:15 <EvilTerran> ddarius, ah, true
14:21:53 <roconnor> mjrosenb: what's with the f.f.f.f ?
14:22:18 <macondo> > [1..] == [1..]
14:22:21 <lambdabot>  Tried to use too much memory
14:22:21 <ddarius> mjrosenb: (,,,) <$> f <*> f <*> f <*> f
14:22:54 <mar77a> if haskell were trully lazy like me
14:22:55 <macondo> How can I compare infinite lists?
14:22:59 <mar77a> he wouldn't even evaluate those expressions
14:23:07 <mjrosenb> roconnor: it seems that while that statement typechecks, it's infact not what i want
14:23:09 <EvilTerran> macondo, you can't, in general
14:23:10 <mar77a> and say they are equal just cause they have the same characters
14:23:10 <kiris> with exceptional difficulty and magic
14:23:21 <EvilTerran> macondo, however, they will short-circuit at the first difference
14:23:22 <roconnor> > compare [0..] [1..]
14:23:22 <lambdabot>  LT
14:23:23 <tromp> you can if they diffwe
14:23:24 <vixey> macondo: which lists?
14:23:27 <tromp> you can if they differ
14:23:41 <Beelsebob> @hoogle readMS
14:23:41 <lambdabot> No matches found
14:23:44 <mjrosenb> roconnor: it's supposed to feed grabModSign in for all of the arguments to liftM4
14:24:20 <macondo> vixey: nothing in particular, I'm just curious. Since [n..] == [n..] is true, even if you don't "physically" compare them
14:24:34 <vixey> > Nothing == Nothing
14:24:35 <lambdabot>  True
14:24:37 <EvilTerran> macondo, how do you intend to implement this?
14:24:38 <ddarius> \(x,y,z,w) -> liftM4 (,,,) (f x) (f y) (f z) (f w)
14:25:06 <macondo> EvilTerran: no implementation yet: I'm learning Haskell and I want to understand more how it works
14:25:12 <bd_> macondo: Proving equality on a truly infinite list is not possible on a turing machine :)
14:25:14 <EvilTerran> macondo, you could deal with as many special cases as you like, there will still always be lists your comparison either gets wrong or doesn't terminate on
14:25:22 <mjrosenb> ddarius: yeah, that's sort of like what i had initially.  o was hoping to not bind all of the variables
14:25:34 <ddarius> @pl \(x,y,z,w) -> liftM4 (,,,) (f x) (f y) (f z) (f w)
14:25:34 <lambdabot> (line 1, column 6):
14:25:34 <lambdabot> unexpected ","
14:25:34 <lambdabot> expecting letter or digit, operator or ")"
14:25:34 <lambdabot> ambiguous use of a non associative operator
14:25:40 <ddarius> Curses.
14:25:42 <bd_> macondo: Since your list can the result of f rules = 0:(computing the final state of the turing machine defined by rules)
14:25:50 <EvilTerran> ddarius, er, what just happened?
14:25:54 <ddarius> @pl \(x,y) -> liftM2 (,,,) (f x) (f y)
14:25:56 <lambdabot> uncurry ((. f) . liftM2 (,,,) . f)
14:25:57 <vixey> macondo: the definition of == on lists is like, \x y -> and (zipWith (==) x y)
14:25:58 <macondo> bd_: not even a truly infinite but periodic list?
14:25:58 <ddarius> @pl \(x,y) -> liftM2 (,) (f x) (f y)
14:25:59 <lambdabot> uncurry ((. f) . liftM2 (,) . f)
14:26:03 <bd_> macondo: Given such a list, computing equality implies determining if f halts
14:26:10 <ddarius> EvilTerran: @pl doesn't handle n-tuples for n>2
14:26:15 <bd_> macondo: The representation of lists does not allow you to know whether a list is perioidic
14:26:16 <EvilTerran> ah, yes
14:26:33 <wuxia> :t ask
14:26:33 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
14:26:46 <EvilTerran> see, if we represented tuples as heterogeneous lists built of (,) and (), pl could manage n-tuples >:D
14:27:16 <mjrosenb> vixey: that does'nt typecheck
14:27:23 <ddarius> @pl \(x,(y,(z,w))) -> liftM4 t (f x) (f y) (f z) (f w)
14:27:24 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip f . ((flip . ((.) .)) .) . flip flip f . ((.) .) . (. f) . liftM4 t . f)
14:27:29 <macondo> bd_: But couldn't Haskell know that [n..] and [n..] are equivalent just like I do? How does Haskell compare lists?
14:27:36 <vixey> mjrosenb: something like it anyway
14:27:39 <wuxia> @hoogle grabKey
14:27:40 <lambdabot> No matches found
14:27:45 <wuxia> :t grabKeyu
14:27:46 <lambdabot> Not in scope: `grabKeyu'
14:27:46 <vixey> macondo: haskell isn't AI
14:27:47 <mjrosenb> ddarius: ow.
14:27:47 <wuxia> :t grabKey
14:27:48 <lambdabot> Not in scope: `grabKey'
14:27:48 <ddarius> macondo: Extensionally.
14:27:52 <EvilTerran> ?pl \(x,(y,(z,(w,())))) -> liftM4 (\a b c d -> (a,(b,(c,(d,()))))) (f x) (f y) (f z) (f w)
14:27:53 <kiris> > fmap id (1,2)
14:27:54 <lambdabot>  (1,2)
14:27:55 <lambdabot> ap (flip ap snd . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip flip f . ((flip . ((.) .)) .) . ((
14:27:55 <lambdabot> flip .) .) . flip flip f . ((.) .) . (flip .) . (. f) . flip . flip (liftM4 . flip ((.) . (.) . (.) . (,)) . flip ((.) . (.) . (,)) . flip ((.) . (,)) . flip (,)) . f . fst) snd
14:27:55 <lambdabot> optimization suspended, use @pl-resume to continue.
14:28:03 <EvilTerran> bahahahaha
14:28:04 <kiris> > fmap (+2) (1,2)
14:28:05 <lambdabot>  (1,4)
14:28:06 <bd_> macondo: [n..] becomes enumFrom n
14:28:07 <EvilTerran> i have wrought a monster!
14:28:08 <bd_> @src enumFrom
14:28:08 <ddarius> EvilTerran: Way to improve the situation.
14:28:08 <lambdabot> Source not found. My brain just exploded
14:28:11 <lament> "optimization" :D
14:28:13 <bd_> @src enumFrom Int
14:28:13 <lambdabot> Source not found. There are some things that I just don't know.
14:28:15 <bd_> bah
14:28:16 <kiris> > fmap (+2) (1,(3,4))
14:28:16 <lambdabot>   add an instance declaration for (Num (t, t1))
14:28:36 <bd_> macondo: essentially it does enumFrom n = n:(enumFrom (n+1))
14:28:38 <EvilTerran> ddarius, i think that approach would have better uses in other places
14:28:40 <bd_> @src Int enumFrom
14:28:40 <lambdabot> Source not found. Are you on drugs?
14:29:01 <kiris> bd `on` drugs
14:29:05 <wuxia> how can i print out the current time HH:MM:SS in haskell?
14:29:07 <bd_> macondo: so, there's no way to inspect that second clause, besides evaluating it and taking out the integer
14:29:25 <EvilTerran> altho it might be better to do (((),x),y) than (x,(y,())) so you can partially apply it nicely
14:29:26 <bd_> macondo: Now, at the implementation level, that tail portion of the list is basically a function pointer and context pointer
14:29:52 <bd_> macondo: those two equivalent lists may have different context pointers (then again, they may not, and it may transition from one of those states to the other at arbitrary times)
14:30:21 <bd_> macondo: of course, this is all an implementation detail :)
14:30:37 <macondo> bd_: ok, I understand. But that happens at an implementation layer: mathematically both lists are identical
14:30:55 <EvilTerran> yes
14:30:57 <bd_> macondo: Sure, but you can't write a general l1 == l2 function to evaluate if two lists are identical.
14:31:10 <vixey> macondo: you can prove stuff about haskell programs
14:31:14 <EvilTerran> but infinite list equality is theoretically undecidable
14:31:16 <bd_> This is an artifact of the fact that turing machines cannot evaluate all mathematical statements :)
14:31:20 <vixey> macondo: you can't do it in haskell though
14:31:39 <EvilTerran> in haskell, we obey the laws of computer science over the laws of mathematics
14:31:47 <vixey> well you can't prove -this- in haskell
14:32:05 <bd_> macondo: heck, even in mathematics there are lists which may or may not be identical, but we can't prove it. For example, the list of [P == NP] and [true]
14:32:05 * EvilTerran blinks at vixey
14:32:13 <vixey> why?
14:32:18 <bd_> macondo: haskell just doesn't have the ability to prove equality of infinite lists either: )
14:32:18 <lament> bd_: haha
14:32:50 <roconnor> @faq can Haskell decide equality on infinite lists?
14:32:50 <lambdabot> The answer is: Yes! Haskell can do that.
14:32:54 <bd_> :o!
14:33:12 <dons_> haskell can do induction. it can also make coffee
14:33:24 <roconnor> @faq can Haskell make me some tea?
14:33:25 <lambdabot> The answer is: Yes! Haskell can do that.
14:33:32 <tromp> > repeat () == repeat ()
14:33:36 <mar77a> @faq how old are you?
14:33:36 <lambdabot> The answer is: Yes! Haskell can do that.
14:33:39 <lambdabot> Terminated
14:33:47 <vixey> > 0/0 == 0/0
14:33:48 <tromp> even on single valued types it cant:(
14:33:50 <lambdabot>  False
14:33:56 <kiris> I like that
14:33:58 <macondo> @faq can haskell do impossible things?
14:33:58 <lambdabot> The answer is: Yes! Haskell can do that.
14:33:59 <wuxia> @faq can haskell convert lead into gold?
14:34:00 <lambdabot> The answer is: Yes! Haskell can do that.
14:34:15 <wuxia> @faq can haskell prove p = np?
14:34:15 <lambdabot> The answer is: Yes! Haskell can do that.
14:34:29 <vixey> @faq Is the answer "The answer is: Yes! Haskell can do that."?
14:34:29 <lambdabot> The answer is: Yes! Haskell can do that.
14:34:48 <kiris> @vixen Can Haskell do all those things?
14:34:48 <lambdabot> church is my favourite computer scientist.
14:34:51 <wuxia> @faw can haskell generate a faq question haskell not answer?
14:34:52 <lambdabot> The answer is: Yes! Haskell can do that.
14:35:08 <lament> faw!
14:35:14 <idnar> love the spellchecker
14:35:21 <roconnor> > compare (0/0) (0/)
14:35:22 <lambdabot>   add an instance declaration for (Fractional (t -> t))
14:35:23 <macondo> f-f-f-aq breaker!
14:35:24 <roconnor> > compare (0/0) (0/0)
14:35:25 <lambdabot>  GT
14:35:25 <idnar> hrm
14:35:33 <ahunter> @seen dons
14:35:35 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
14:35:44 <kiris> @_@
14:35:49 <idnar> @faq "Yields falsehood when preceeded by its quotation."
14:35:49 <lambdabot> The answer is: Yes! Haskell can do that.
14:35:53 <idnar> except wait, that totally won't work
14:36:03 <ahunter> Gah, is seen still broken?  Any idea what's up with that?
14:36:04 <EvilTerran> preflex: seen dons
14:36:04 <preflex>  dons was last seen on #xmonad 2 hours, 50 minutes and 10 seconds ago, saying: boring, noisy discussions remind people to unsubscribe, i guess
14:36:13 <kiris> @id quine
14:36:14 <lambdabot>  quine
14:36:23 <roconnor> I think compare (0/0) (0/0) should return an error.
14:36:26 <quicksilver> preflex: seen dons_
14:36:27 <preflex>  dons_ was last seen on #haskell 3 minutes and 14 seconds ago, saying: haskell can do induction. it can also make coffee
14:36:39 <roconnor> @quote quine
14:36:39 <lambdabot> No quotes match. My brain just exploded
14:36:41 <ahunter> well, that's nice :P
14:36:50 <vixey> the whole number stuff in haskell is odd
14:36:53 <quicksilver> roconnor: what does IEEE think?
14:36:56 <vixey> and - is awful
14:37:04 <roconnor> quicksilver: good question
14:37:08 <ahunter> dons_: got a second to answer a nobench question or two?
14:37:10 <idnar> > (0/0)
14:37:11 <lambdabot>  NaN
14:37:12 <bd_> > compare (0/0 :: Rational) (0/0)
14:37:12 <lambdabot>  Exception: Ratio.%: zero denominator
14:37:22 <vixey> it's good that you can make numbers yourself so easily
14:37:27 <wuxia> in ghci, how do i imprt data.time.clock?
14:37:37 <vixey> :m + Data.Time.Clock
14:37:37 <kiris> :m + Data.Time.Clock
14:37:44 <kiris> v_v
14:37:49 <quicksilver> roconnor: I suspect NaN < NaN is undefined, meaning any answer is permissible. I don't think it's supposed to give an exception though.
14:37:51 <wuxia> got it ; thanks
14:37:59 <quicksilver> but thats only a guess
14:38:14 <wuxia> how do IK print out the current time? I get:
14:38:15 <wuxia> Prelude Data.Time.Clock> getCurrentTime
14:38:15 <wuxia> Prelude Data.Time.Clock>
14:38:23 <roconnor> quicksilver: I'm talking about the compare function, not the < function
14:38:26 <EvilTerran> ?hoogle getCurrentTime
14:38:27 <lambdabot> Data.Time.Clock.getCurrentTime :: IO UTCTime
14:38:27 <lambdabot> Data.Time.LocalTime.getCurrentTimeZone :: IO TimeZone
14:38:31 <vixey> it's nice to be able to rely on some things like a < b = b > a
14:38:33 <rwbarton> quicksilver: ISTR that NaN /= Nan is required by some standard...
14:38:34 <roconnor> quicksilver: I suspect IEEE doesn't have an opinion about compare
14:38:39 <EvilTerran> wuxia, try print =<< getCurrentTime
14:38:42 <quicksilver> roconnor: I know but I think < is as close as IEEE will come to compare.
14:38:47 <natv_> ieee says all comapares with nans are false
14:38:53 <quicksilver> EvilTerran: the problem is the show instance isn't avaialble
14:38:59 <wuxia> Prelude Data.Time.Clock> print =<< getCurrentTime
14:38:59 <wuxia> <interactive>:1:0:
14:38:59 <wuxia>     No instance for (Show UTCTime)
14:38:59 <wuxia>       arising from a use of `print' at <interactive>:1:0-4
14:38:59 <wuxia>     Possible fix: add an instance declaration for (Show UTCTime)
14:39:03 <EvilTerran> oh, right
14:39:04 <roconnor> quicksilver:  I'm fine with (0/0) < (0/0) returning False.
14:39:07 <quicksilver> you need Data.Time.Format I think?
14:39:15 <EvilTerran> i see
14:39:26 <roconnor> > (0/0) > (0/0)
14:39:27 <lambdabot>  False
14:39:29 <EvilTerran> forgot it was abstrac
14:39:31 <EvilTerran> t
14:39:34 <roconnor> > compare (0/0) (0/0)
14:39:35 <lambdabot>  GT
14:39:40 <roconnor> I think that is just wrong.
14:39:44 <macondo> Another question: just like I can compare data (not infinite lists, of course..), can I compare functions? Say head == !! 0
14:39:52 <EvilTerran> no
14:39:53 <roconnor> if compare a b returns GT, then a > b should return True.
14:40:01 <lament> macondo: what if your functions generate infinite lists?
14:40:08 <monochrom> hello
14:40:09 <wuxia> formatTime getCurrentTime
14:40:09 <wuxia> <interactive>:1:11:
14:40:09 <wuxia>     Couldn't match expected type `System.Locale.TimeLocale'
14:40:09 <wuxia>            against inferred type `IO UTCTime'
14:40:16 <bd_> macondo: That's theoretically impossible :)
14:40:22 <macondo> lament: I'm sure that's not the only reason
14:40:23 <EvilTerran> is repeat 0 = repeat 0 ++ [1]?
14:40:23 <lament> macondo: look at it this way: a function from a countable datatype is equivalent to an infinite list
14:40:23 <Beelsebob> who knows where abouts one configures \bot to join IRC channels these days?
14:40:24 <vixey> you can define an eq instance on functions
14:40:32 <rwbarton> macondo: You could define an instance of Eq for a -> b, but not a useful one...
14:40:36 <monochrom> functions are even harder than infinite lists
14:40:42 <ahunter> lament: no need, even for functions of N -> N equivalence is undecidable
14:40:46 <vixey> hi monochrom :D
14:40:56 <EvilTerran> rwbarton, it could use constructive logic and only return false ;)
14:41:13 <vixey> that's not constructive
14:41:16 <EvilTerran> sorry, (not True)
14:41:31 <ahunter> lament: well, putting aside N -> N being isomorphic to an infinite list of N
14:41:41 <monochrom> If you write your own compiler or interpreter, you may choose to store and compare code.
14:41:42 <Saizan_> Beelsebob: see online.rc
14:41:43 <EvilTerran> never mind, this doesn't work :P
14:42:17 <Beelsebob> ah, chers Saizan_ -- irronically, that's exactly the command I use to open the file, using "SubEthaEdit"
14:42:29 <lament> macondo: alternatively, consider that comparing functions is exactly equivalent to solving the halting problem
14:42:29 <ahunter> monochrom: that's a really silly equivalence relation :)
14:42:43 <vixey> which equivalence ?
14:42:47 <bd_> monochrom: however you can easily have functions which return the same values for the same inputs, but compile to different code
14:42:59 <macondo> wow I'm really starting to like Haskell
14:43:09 <ahunter> bd_: well, that's still an eq. relation...just not a very useful one
14:43:15 <bd_> ahunter: I... suppose :)
14:43:20 <bd_> useful for the JIT I suppsoe
14:43:22 <monochrom> Yes, when people say "compare functions" they tend to mean "compare code".
14:43:40 <vixey> yeah alpha convertability is a very useful equivalence
14:43:48 <monochrom> I can try to explain why it's usually so.
14:43:49 <lament> monochrom: i think most people would say f = 1 and f = 1 + 0 are the same value
14:43:55 <vixey> and alpha-beta if you have typed lambda expressions
14:44:06 <ahunter> Have you guys seen Appel's paper on extensional equality?
14:44:08 <bd_> lament: Well, f isn't a function there, it's an integer, and we can compare finite integers :)
14:44:30 <vixey> There are many many equivalences for different purposes
14:44:39 <monochrom> Beware of the polymorphism underlying 1 and 1+0.
14:44:45 <lament> bd_: this only goes to show that even for integers, monochrom's equivalence relationship is useless :)
14:44:54 <lament> bd_: and if you want a function, add 'const' before the expression
14:45:02 <ahunter> bd_: hey, it's total, reflexive, transitive, and commutative
14:45:03 <vixey> 7 == 2      ...... (mod
14:45:05 <vixey> 5)
14:45:17 <ahunter> bd_: therefore it's a equiv. relation
14:45:37 <bd_> ahunter: fair enough. But haskell doesn't expose it :)
14:45:57 <rwbarton> Another equivalence relation is  instance Eq (a -> b) where x == y = True
14:46:03 <ahunter> bd_: something something unsafeCoerce# foreign call memcmp?
14:46:05 <kiris> Linking dist/build/runplugs/runplugs ...
14:46:06 <kiris> /usr/local/lib/ghc-6.8.2/libHSghc.a(RtClosureInspect.o): In function `ghczm6zi8zi2_RtClosureInspect_a73_info':
14:46:09 <kiris> (.text+0xee1e): undefined reference to `containerszm0zi1zi0zi1_DataziSequence_a26_info'
14:46:12 <kiris> anyone else get this?
14:46:14 <vixey> rwbarton: that's an infinite loop though
14:46:20 <bd_> ahunter: what about the function's environment?
14:46:20 <Beelsebob> Saizan_: further to that -- how does one start \bot in 'online' mode?
14:46:21 <lament> rwbarton: useful!
14:46:33 <kiris> Beelsebob: see the README file
14:46:56 <bd_> ahunter: and, since function objects can be GC'd and moved around, if you do compare the environment, you might find (a == b) /= (b == c), depending on evaluation order
14:47:01 <ahunter> bd_: what about?  Can't we just read the free variables out of the closure, if I remember my STG right?
14:47:15 <kiris> Beelsebob: ./lambdabot -e 'rc online.rc'
14:47:39 <rwbarton> Maybe this is common knowledge around here, but for something more interesting, you can implement Eq for (Integer -> Bool) -> Bool
14:47:42 <rwbarton> See http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
14:47:44 <lambdabot> Title: Mathematics and Computation  Seemingly impossible functional programs, http://tinyurl.com/2umqwh
14:48:32 <roconnor> http://hackage.haskell.org/trac/haskell-prime/ticket/123
14:48:34 <lambdabot> Title: #123 (Fix Ord so Ord Double and Ord Float make sense) - Haskell Prime - Trac
14:48:44 <dolio> rwbarton: That's only for total functions of that type.
14:49:12 <rwbarton> Well, sure.  It's hard to imagine what it would mean to be able to compare functions that were not total.
14:49:28 <ahunter> bd_: suppose so; worst case, we just check the text and ignore the environment.  Still an ER then, even if it's totally useless. :P
14:49:30 <roconnor> Hmm, perhaps H98 doesn't prevent compare (0/0) (0/0) from returning an error.
14:49:31 <rwbarton> (I mean, in the denotation semantics there are no problems, but...)
14:49:37 <roconnor> so this is maybe a bug in GHC.
14:49:40 <bd_> ahunter: Quite :)
14:49:48 <kiris> anyone know how to debug that link error above? I'm just lost really
14:49:56 <bd_> ahunter: Of course, a haskell implementation with a JIT might decide to re-jit in between your accesses...
14:49:57 <vixey> instance (Inhabitants p, Eq q) => Eq (p -> q) where
14:49:58 <vixey>   x == y = and $ zipWith (==) (map x inhabitants) (map y inhabitants)
14:50:12 <Beelsebob> @tell Cale I've 'darcs sen[t]' you a patch to stop \bot being annoying in channels that don't like URL reporting, could you yell if/when you roll it into your live bot?
14:50:12 <lambdabot> Consider it noted.
14:50:13 <vixey> oh
14:50:20 <vixey>   x == y = map x inhabitants == map y inhabitants
14:50:38 <ahunter> bd_: use STM to verify the old instance is still valid :P
14:50:51 <vixey> *Main> not == id --> False
14:50:51 <vixey> *Main> not == not --> True
14:50:51 <vixey> *Main> not.not == id --> True
14:50:57 <bd_> ahunter: Who says the JIT cares about STM :)
14:51:10 <kiris> vixey: wow cool
14:51:16 <bd_> of course, things became unportable the moment of unsafeCoerce#
14:51:23 <ahunter> bd_: the spec for STM ?  We verify the memory is still accurate or retry
14:51:37 <ahunter> well, we wouldn't be able to use the standard STM library, but the techniques are applicable, if stupid
14:52:18 <bd_> ahunter: the old memory might still be valid - you're just in the middle of (a == b) == (b == a), and the JIT decides to change the implementation of b when you've finished evaluating the first clause.
14:52:35 <bd_> 'a' is still bound to the old code; the JIT (for whatever reason) hasn't gotten to it yet
14:52:39 <ahunter> bd_: hmm
14:52:52 <ahunter> bd_: can we rely on the JIT's correctness to claim the functions are still equivalent?
14:53:27 <monochrom> Are a and b bindings to values and thunks?
14:53:40 <bd_> ahunter: hmm. I don't know, maybe :)
14:53:51 <bd_> depends on the JIT I guess
14:54:05 <bd_> could be the JIT doesn't keep a pointer back to the original function bytecode from the JIT'd stuff
14:54:09 <bd_> afk a bit
14:54:30 <ahunter> bd_: no, more saying that if the JIT turns b into b', then b x = b' x \forall x
14:54:37 <vixey> anyway if you want to try and prove/disprove that functions are equal you are best to do this on paper
14:54:47 <ahunter> yeah, yeah, t's fun :P
14:54:47 <vixey> or in a computer theorem prover
14:55:06 <monochrom> or a word processor and do it by hand
14:55:12 <monochrom> saves paper :)
14:55:17 <vixey> :p
14:55:32 <dolio> Yes. Word is the ultimate proof environment.
14:55:47 <monochrom> I sometimes do some short proofs in the line buffer of my irc client.
14:55:51 <vixey> "4 color theorem proved in MS Word"
14:56:15 <ahunter> bah, math is easier by hand
14:56:32 <ahunter> a nice pen and real paper adds five points to my math exams compared to a text editor :P
14:57:19 <monochrom> nice pen is key.
14:57:47 <monochrom> I have a fountain pen. The feeling of watery ink flowing out is very satisfying.
14:58:49 <ahunter> monochrom: I like...I'm not sure what they're called, actually.  Gel pens?  They have really thin metal tips, write kind of scratchily, and produce bold strokes of very liquid-y ink
14:59:45 <monochrom> Yeah gel pens. Next best thing.
15:00:03 <monochrom> I bought a gel pen in red for marking student assignments.
15:05:22 <vixey> I don't understand model theory...
15:05:46 <wuxia> now <- getCurrentTime; putStr (show now) -- this works ;;; putStr (show getCurrenTime) -- this doesn't work ... why?
15:06:04 <vixey> wuxia: getCurrentTime has the wrong type
15:06:10 <wagle_> not a bucket of red paint, and a roller?
15:06:13 <wuxia> how can i fit this on one line?
15:06:28 <vixey> putStr . show =<< getCurrentTime
15:06:31 <vixey> :t putStr . show =<< getCurrentTime
15:06:31 <lambdabot> Not in scope: `getCurrentTime'
15:06:37 <wuxia> :t =<<
15:06:37 <lambdabot> parse error on input `=<<'
15:06:39 <vixey> :t putStr . show =<< (return "foo")
15:06:40 <lambdabot> IO ()
15:06:48 <wuxia> :t (=<<)
15:06:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:06:59 <vixey> wuxia: You know what . means here?
15:07:12 <roconnor> @src print
15:07:12 <wuxia> :t (.)
15:07:12 <lambdabot> print x = putStrLn (show x)
15:07:13 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:07:24 <wuxia> to avoid ()'s ?
15:07:35 <wuxia> functionnn concat
15:07:43 <vixey> yes
15:08:02 <monochrom> wuxia: it's the same reason "putChar (getChar)" is wrong, you need getChar >>= putChar.
15:08:03 <roconnor> heh, function concat.  That's a nice way of describing it.
15:08:19 <vixey> wuxia: and f =<< x will run create the action that runs x and feeds the value(s) into f
15:09:07 <wuxia> is =<< and >>= releated at all?
15:09:13 <wuxia> i.e. can i implement one in terms of the otemr?
15:09:13 <vixey> fus
15:09:14 <vixey> yes
15:09:20 <wuxia> please show me how
15:09:24 <vixey> x =<< f = f >>= x
15:09:26 <vixey> in general
15:09:28 <wuxia> oh
15:09:30 <wuxia> cool
15:09:40 <vixey> x 'operator' f = f 'rotarepo' x
15:09:46 <wuxia> so that could have been written as: getCurrenTime >>= putStr . show ?
15:09:57 <monochrom> x =<< v = v >>= x   (more symmetric :) )
15:10:29 <wuxia>  getCurrentTime >>= putStr . show
15:10:29 <wuxia> <interactive>:1:28:
15:10:29 <wuxia>     No instance for (Show UTCTime)
15:10:29 <wuxia>       arising from a use of `show' at <interactive>:1:28-31
15:10:29 <wuxia>     Possible fix: add an instance declaration for (Show UTCTime)
15:10:50 <mar77a> (putStr . show) i think
15:10:55 <mauke> no
15:11:03 <vixey> how did now <- getCurrentTime; putStr (show now)  work then ?
15:11:20 <Apocalisp> ?type (>>=)
15:11:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:11:22 <monochrom> do notation is translated to >>=
15:11:23 <Apocalisp> ?type flip (>>=)
15:11:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
15:11:37 <Apocalisp> ?type (=<<)
15:11:38 <roconnor> @src (=<<)
15:11:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:11:38 <lambdabot> f =<< x = x >>= f
15:11:47 <monochrom> Example. do {x <- v; blah} becomes v >>= \x -> blah
15:11:53 <wuxia> hmm, i'm not sure, but it did work
15:12:00 <wuxia> but now it doesn't work in this new ghci session
15:12:08 <vixey> maybe you have to load the module again
15:12:47 <wuxia> okayh, it works now; the probelm is that I needc to lload in     Data.Time.Format
15:13:01 <monochrom> @undo do { x <- v; blah }
15:13:01 <lambdabot> v >>= \ x -> blah
15:13:11 <monochrom> enjoy!
15:13:11 <wuxia> the line "import Data.Time.Clock" gives me the following error; how do I fix it?
15:13:14 <wuxia> XMonad/Main.hsc:25:7:
15:13:17 <wuxia>     Could not find module `Data.Time.Clock':
15:13:20 <wuxia>       it is a member of package time-1.1.2.0, which is hidden
15:13:28 <vixey> import Data.Time
15:13:34 <mauke> you need to add 'time' to the cabal file
15:13:39 <saml> wuxia: are you using cabal?
15:13:42 <saml> what mauke said
15:13:42 <vixey> oh
15:13:50 <wuxia> I don't know if I am
15:13:55 <wuxia> i'm compiling with runhaskell Setup.lhs build
15:14:10 <wuxia> cabal
15:14:10 <wuxia> bash: cabal: command not found
15:14:12 <wuxia> i guess not then?
15:14:14 <saml> yah find projename.cabal file and edit it
15:14:32 <wuxia> found it
15:14:38 <wuxia> what do I have to add into xmonad.cabal
15:14:39 <saml> Build-Depends: ... , time
15:15:23 <wuxia> that solved that, thanks !
15:16:23 <wuxia>  forever_ $ handle =<< io (hPutStr stderr . show =<< getCurrentTime >>  hPutStr stderr "event passing by\n" >> nextEvent dpy e >> getEvent e) -- is giving me error: cannot mix `(=<<)' [infixr 1] and `(>>)' [infixl 1] in the same infix expression ... do I put in *('s ?
15:16:52 <monochrom> yeah add more ( ) s
15:16:55 <mauke> what the hell
15:17:12 <wuxia> ? is my code obfuscated?
15:17:24 <fiddlerwoaroof> is there a better prelude data type than [[],[],[]] for representing a Tic-Tac-Toe board?
15:17:33 <monochrom> Not obfuscated. It's cool.
15:17:44 <vixey> [[],[],[]] is not a data type
15:17:53 <gwern> 'A thousand pointers of the C++ empire descend upon you. Our memory leaks will blot out your RAM!'
15:17:57 <fiddlerwoaroof> data Board = Board [[],[],[]]
15:18:03 <gwern> 'Good. Then we shall program in the shade.'
15:18:08 <vixey> that's a syntax error
15:18:11 <bd_> vixey: [[], [], []] is data, and has a type :)
15:18:14 <ahunter> Then we will compute in constant space.
15:18:15 <monochrom> I prefer Data.Array.array but you ask for prelude. [[XO]].
15:18:20 <vixey> bd_: It's not a datatype
15:18:28 <vixey> fiddlerwoaroof: You could define data XO = X | O
15:18:34 <roconnor> data Row x = Row x x x
15:18:36 <monochrom> @type [[True], [], [False, True]]
15:18:36 <lambdabot> [[Bool]]
15:18:47 <ahunter> gwern: ....was that apropos of anything?
15:18:47 <roconnor> data Board x = Row (Row x)
15:18:47 <wagle_> need empty too
15:18:48 <vixey> Row (Row XO)
15:18:57 <saml> wuxia: try to put parnes after show =<< like:  io (... . show =<< ( ... ) )
15:19:03 <bd_> vixey: oh, er, right XD not enough sleep I guess
15:19:15 <roconnor> type TicTacToe = Board XO
15:19:23 <roconnor> type TicTacToe = Board (Maybe XO)
15:19:30 <wuxia> ls
15:19:48 <bd_> roconnor: needs some more [] i think :)
15:19:51 <lament> hugs and kisses!
15:19:51 <saml> alt+tab ownage
15:20:03 <roconnor> bd_: lists are inappropriate
15:20:11 <fiddlerwoaroof> and if I wanted to generalize the board would data Row x = Row [x] be a good idea?
15:20:16 <vixey> no
15:20:18 <bd_> roconnor: A single element is also inappropriate :)
15:20:31 <roconnor> bd_: what single element?
15:20:52 <gwern> ahunter: no, not really. it just amused me
15:21:01 <ahunter> Ah, just curious
15:21:08 <bd_> roconnor: data Board = Row (Row x)  type TicTacToe = Board XO   - your data type is inhabited by Row (Row X) and Row (Row Y), plus various bottoms
15:21:14 * gwern needs no justification! I am not a monad, I am a free variable!
15:21:34 <monochrom> You still need indentation.
15:21:55 <roconnor> bd_: Row (Row X) and Row (Row X) do not have type Board XO
15:21:58 <fiddlerwoaroof> when are types used as opposed to datas ?
15:22:10 <vixey> type makes synonyms
15:22:20 <bd_> ... wow, I really need sleep XD
15:22:24 <vixey> data defines totally new types for new names
15:22:35 <roconnor> bd_: :D
15:22:42 <saml> newtype does similar but it has restrictions
15:22:51 <saml> i think type is similar to typedef in C
15:22:57 <saml> or was it deftype
15:23:03 <monochrom> typedef
15:23:12 * vixey thinks introducing concepts from C is not a useful teaching aid...
15:23:15 <fiddlerwoaroof> what are newtypes restrictions?
15:23:26 <fiddlerwoaroof> I dont really know C...
15:23:41 <fiddlerwoaroof> but I know what youre talking about
15:23:46 <Armored_Azrael> Is there any way to instruct cabal-install to do a global install instead of into one's homedir?
15:23:56 <dons_> --global
15:23:58 <Armored_Azrael> Thanks
15:24:33 <gwern> Armored_Azrael: yes
15:24:46 <monochrom> Ha
15:26:20 <hpaste>  fiddlerwoaroof pasted "Board.hs" at http://hpaste.org/8791
15:27:01 <fiddlerwoaroof> here is what I managed to get, but its unfinished
15:33:57 <augustss> yo
15:34:54 <tusho> OOOOOOOOOOOOO
15:38:18 <dolio> Wow, a 33 year old bug in yacc.
15:39:28 <fiddlerwoaroof> why does this: show (Row x y z) = (show x) ++ " " ++ (show y) ++ " " ++ (show z) ++ "\n"
15:39:54 <fiddlerwoaroof> generate the spaces after the newline? "X O O\n X X X\n O O O\n\n"
15:40:05 <fiddlerwoaroof> show $ Row (Row X O O) (Row X X X) (Row O O O)
15:40:07 <tusho> dolio: Awesome
15:40:20 <roconnor> because when you show a Row of rows, it places paces between the rows, like you say
15:40:30 <fiddlerwoaroof> aha
15:40:36 * fiddlerwoaroof is ashamed
15:40:42 <roconnor> fiddlerwoaroof: np
15:40:43 <tusho> dolio: What is it
15:41:07 <roconnor> computers usually do what they are told, and yet we still often have no idea why they do what they do.
15:41:32 <mapreduce> My Spectrum 48 manual told me that when computers go wrong, it is my fault.
15:41:43 <augustss> and it was right!
15:41:53 <vixey> software is so full of bugs most computer users don't think about it in terms of computation ..
15:42:07 <jre2> is it possible to convert hAppS state to a new schema?
15:42:16 <kiris> more like seeking patterns in chaos
15:42:28 <tusho> dolio: Mmmm?
15:43:31 <drguildo> does anyone else get this when installing haxml using cabal: http://hpaste.org/8792
15:44:27 <tusho> dolio: STOP BEING SUSPENSEFUL
15:44:48 <dons_> drguildo: missing --user ?
15:45:44 <drguildo> dons_, nah, it seems to put use that by default when you're not root
15:46:15 <dons_> i don't think it does, does it? it's a common xmonad user complaint
15:46:25 <dons_> they'll install as --user, but fail to build things, due to missing --user
15:46:28 <kiris> when I'm not root it complains about lack of write access
15:46:31 <dons_> check where bytestring is installed
15:46:52 <drguildo> oh, i'm probably wrong then
15:46:59 <drguildo> i assumed it did cause everything gets put in my homedir
15:47:52 <fiddlerwoaroof> bye
15:47:59 <drguildo> silly question but how do i do that, is there an easier way than trying to use find?
15:48:39 <mauke> ghc-pkg list bytestring
15:48:40 <drguildo> i can autocomplete that module in ghci but i get the same error when i actually try to import it
15:48:42 <drguildo> weird
15:49:25 <drguildo> there's two copies, a system-wide one and another in my home dir
15:54:44 <drguildo> anyone?
15:57:10 <Cale> drguildo: hmm
15:57:10 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
15:57:33 <Cale> drguildo: that looks like it requires bytestring, but doesn't have that dependency perhaps
15:57:43 <Cale> drguildo: Installing the bytestring package should help.
15:58:21 <drguildo> well
15:58:29 <drguildo> i have it installed already
15:58:33 <drguildo> two copies
15:58:34 <drguildo> :-)
15:59:01 <drguildo> the one that comes with ghc
15:59:06 <Cale> mm
15:59:10 <drguildo> and a newer one installed in my homedir
15:59:27 <drguildo> however
15:59:42 <drguildo> doesn't cabal "hide" packages that aren't specified in the .cabal file as dependencies?
15:59:57 <dons> yes
16:00:02 <vixey> > let x  y = not x || x && y in liftM2 () [True,False] [True,False]
16:00:03 <lambdabot>  Illegal character ''\8594''
16:00:03 <lambdabot>  at "" (column 7)
16:00:06 <vixey> useless
16:00:18 <dons> vixey: lambdabot uses a conservative parser
16:00:40 <drguildo> maybe that's the problem?
16:01:42 <jre2> does SearchPath do anything cabal install can't?
16:02:45 <dons> builds from darcs repos.
16:03:30 <jre2> sounds useful
16:04:02 <dons> as long as all you're doing is building from darcs, maybe
16:05:01 <drguildo> Warning: No 'build-type' specified. If you do not need a custom Setup.hs or
16:05:01 <drguildo> ./configure script then use 'build-type: Simple'.
16:05:16 <drguildo> it looks like this needs updating
16:07:48 <drguildo> ugh
16:07:52 <drguildo> the build craps out anyway
16:07:57 <Saizan_> drguildo: where did you get that package?
16:08:14 <drguildo> http://www.cs.york.ac.uk/fp/HaXml/
16:08:15 <lambdabot> Title: HaXml: Haskell and XML
16:09:04 <Saizan_> drguildo: http://hackage.haskell.org/packages/archive/HaXml/1.19.4/HaXml-1.19.4.tar.gz <- try this, its .cabal looks better, e.g. it has build-type
16:09:05 <lambdabot> http://tinyurl.com/6e4oms
16:09:27 <Saizan_> and is reported to build on 6.8
16:09:36 <drguildo> thanks
16:09:47 <drguildo> well the version is higher so it must be better ;-)
16:09:53 <mwc> Anybody tried using http://www.gccxml.org/HTML/Index.html to generate bindings to C/C++ libs?
16:09:54 <lambdabot> Title: GCC-XML
16:10:06 <Saizan_> Building HaXml-1.19.4...
16:10:15 <Saizan_> looks the same to me ^^^
16:10:48 <drguildo> oh, yeah but the one on that site is much older
16:10:56 <drguildo> HaXml-1.13.3
16:12:29 <drguildo> it's still having a problem with bytestring, hmm
16:12:30 <mjrosenb> @hoogle (a -> Maybe b) -> (a -> Maybe b) -> a -> Maybe b
16:12:31 <lambdabot> No matches, try a more general search
16:12:43 <mjrosenb> @djinn (a -> Maybe b) -> (a -> Maybe b) -> a -> Maybe b
16:12:50 <lambdabot> f a b c =
16:12:50 <lambdabot>     case b c of
16:12:50 <lambdabot>     Nothing -> a c
16:12:50 <lambdabot>     Just d -> Just d
16:12:53 <vixey> @hoogle Maybe a -> Maybe a -> Maybe a
16:12:54 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
16:13:25 <vixey> :t liftM2 Data.Generics.Aliases.orElse
16:13:26 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a) -> m (Maybe a) -> m (Maybe a)
16:13:30 <mjrosenb> vixey: for that, i'd just use mplus
16:13:39 <EvilTerran> :t liftM2 mplus
16:13:40 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 (m a) -> m1 (m a) -> m1 (m a)
16:13:48 <vixey> :t mplus
16:13:49 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
16:13:56 <vixey> :t (mplus`on`)
16:13:57 <lambdabot> Not in scope: `on'
16:14:07 <vixey> @src on
16:14:07 <lambdabot> (*) `on` f = \x y -> f x * f y
16:14:13 <vixey> @let (*) `on` f = \x y -> f x * f y
16:14:16 <lambdabot> Defined.
16:14:17 <vixey> :t (mplus`on`)
16:14:18 <lambdabot>     Ambiguous occurrence `on'
16:14:18 <lambdabot>     It could refer to either `L.on', defined at <local>:4:4
16:14:18 <lambdabot>                           or `Data.Function.on', imported from Data.Function at State/imports.h:15:0-32
16:14:22 <vixey> ....
16:14:28 <vixey> what is going on
16:14:33 <EvilTerran> @undef
16:14:34 <lambdabot> Undefined.
16:14:41 <EvilTerran> ?type (mplus `on`)
16:14:41 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> a1 -> a1 -> m a
16:14:53 <EvilTerran> weird
16:15:13 <drguildo> can't you do that in ghci or something?
16:16:30 <vixey> ?djinn (p -> q -> x) -> (a -> p) -> (a -> q) -> (a -> x)
16:16:30 <lambdabot> f a b c d = a (b d) (c d)
16:16:49 <EvilTerran> ?pl f a b c d = a (b d) (c d)
16:16:49 <lambdabot> f = liftM2
16:17:01 <vixey> :t mplus
16:17:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
16:17:10 <vixey> :t liftM2 mplus
16:17:10 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 (m a) -> m1 (m a) -> m1 (m a)
16:17:16 <vixey> that doesn't make sense
16:17:20 <vixey> oh it does
16:17:31 <vixey> :t liftM2 mplus :: (a -> Maybe b) -> (a -> Maybe b) -> a -> Maybe b
16:17:31 <lambdabot> forall a b. (a -> Maybe b) -> (a -> Maybe b) -> a -> Maybe b
16:17:42 <EvilTerran> > liftM2 f g h x :: Expr
16:17:42 <lambdabot>  Add a type signature
16:17:47 <EvilTerran> blargh
16:18:47 <EvilTerran> ?bot
16:19:19 <chessguy>  cool little brainteaser online today. can anyone beat my haskell solution? http://www.dustindiaz.com/programming-brain-teaser/
16:24:35 <chessguy> my solution is here, by the way: http://hpaste.org/8784
16:25:15 <roconnor> woah
16:25:17 <mjrosenb> chessguy: you want it in haskell?
16:25:19 <roconnor> hpaste has hyperlinks
16:25:45 <chessguy> mjrosenb:  well, this is #haskell, but i'd be interested in seeing other solutions too
16:25:51 <chessguy> @pl \s -> l s > 2
16:26:21 <Saizan_> chessguy: your solution is buggy :)
16:26:23 <glguy> chessguy: is that solution correct?
16:26:31 <roconnor> chessguy: bzzt
16:26:36 <roconnor> oh
16:26:42 <roconnor> what other people said
16:27:01 <chessguy> hm, i type-checked it, but didn't actually run it
16:27:26 <glguy> if you were a Ruby programmer you'd have written the test first ;)
16:27:55 <Saizan_> String's are not very strictly typed
16:28:10 <chessguy> looks ok to me
16:28:24 <glguy> do a == on the expected output
16:29:11 <chessguy> i'm assuming that the spaces are simply for looks
16:29:22 <glguy> there's more
16:29:26 <chessguy> oh
16:29:51 <chessguy> well, that's silly
16:30:13 <glguy> You should make your own blog post with a modified problem statement, then submit your solution to it!
16:30:18 <chessguy> haha
16:30:22 <roconnor> you are going to have to increase your code size by 50%
16:30:25 <chessguy> anyway, this is easly fixed
16:30:25 <BMeph> chessguy: You should translate it using the Functional JS library. :)
16:30:57 <chessguy> yeah, i don't know why everyone wanted to solve it in JS
16:31:14 <roconnor> This is the first program that I have seen that uses group, but doesn't call head on each group.
16:32:18 <chessguy> you can hardly call it a "program"
16:32:34 <vixey> yes you can
16:32:55 <vixey> programs in haskell are usually  f = g . h
16:33:02 <vixey> not 10000 lines of code
16:33:22 <glguy> because there are few major applications written in Haskell?
16:33:53 <saml> haskell is hard for slow people like me.
16:34:00 <mjrosenb> roconnor: i've seen len called on the output of group
16:34:09 <chessguy> i'm with you on that one, saml
16:34:12 <saml> but i bet it'll influence programming a lot
16:34:14 <roconnor> mjrosenb: without also calling head?
16:34:32 <dons> programming's hard. but its ok, we can do it half-arsed.
16:34:36 <saml> ph.d students love haskell. that's a good sign for haskell, i think.
16:34:40 <dons> most people won't notice.
16:34:41 <vixey> noo dons
16:34:51 <dons> oh, An error occurred while processing your request.
16:34:51 <dons> Reference #97.c7af6d8.1215560037.8ad175e
16:35:00 <dons> looks like reddit thought programming was too hard too
16:38:26 <mjrosenb> roconnor: map length $ group foo
16:38:50 <roconnor> hmm
16:39:10 <mjrosenb> http://rafb.net/p/FmAKgC37.html
16:39:10 <roconnor> seems unusual
16:39:34 <mjrosenb> this is the first time in a LONG time that my first thought was 'oh, i can do this in C'
16:46:39 <BMeph> mjrosenb: With any luck, it'll be your last, too. ;)
16:47:04 <BMeph> mjrosenb: Last time, not last thought. :)
16:47:53 <macondo> Reference #97.34c13e40.1215560838.8236913 here
16:48:37 <mjrosenb> BMeph: alas, no.  i now have a job writing C code
16:48:48 <vixey> mjrosenb: it prints "bccdee<span>eee</span>fefefaa<span>a</span>ff<span>f</span>"
16:49:19 <BMeph> But Saizan_ hit the issue right on the head: the output does not meet the specs.
16:49:19 <vixey> a b c c d e e <span>e e e</span> f e f e f a a <span>a</span> f f <span>f</span>
16:49:24 <vixey> was supposed to be the answer
16:50:07 <mjrosenb> vixey: you want me to fix the formatting?
16:50:30 <vixey> more worrying is that your one didn't print the first a
16:50:41 <mjrosenb> wait, what now?
16:50:50 <vixey> I tried running your code
16:51:03 <mjrosenb> aah indeed
16:51:12 <vixey> @let span' x = "<span>" ++ x ++ "</span>"
16:51:18 <vixey> @let proccess list = if length list >= 3 then take 2 list ++ span' (drop 2 list) else list
16:51:36 <vixey> > proccess =<< group "abccdeeeeefefefaaafff" -- if you don't care about formatting
16:51:38 <mjrosenb> copy line 24 to  line 9
16:51:51 <mauke> is there a non-blocking version of threadWaitRead?
16:57:17 <macondo> vixey: what do you do for a living?, if I can ask
16:59:40 <matthew-_> any gtk2hs folk awake?
17:00:07 <matthew-_> I'm using cairo to draw stuff and I need a path with an arrow head on the end of it
17:00:18 <matthew-_> any ideas anyone? can't seem to find it in the api
17:01:36 <vixey> macondo: why o_o
17:02:50 <macondo> vixey: I just want to know what a person that knows Haskell does
17:04:47 <lxuser> ?pl \(x,(y,(z,(w,())))) -> liftM4 (\a b c d -> (a,(b,(c,(d,()))))) (f x) (f y) (f z) (f w)
17:05:43 <hpaste>  Bmeph pasted "brainteaser, take 2 (heh-heh)" at http://hpaste.org/8793
17:07:08 <wuxia> :t M.Map
17:07:22 <wuxia> what happened to l.ambdabot?
17:11:50 <hcube> hi
17:12:35 <hcube> which is the most simple haskell compiler ? i'd like to learn how a functional language compiler works.
17:13:20 <vixey> hcube: I'd say read Compiling With Continuations by Appel instead of analyzing an existing compilerao
17:15:40 <TomMD> all is quiet on the Haskell front.  I'm curious if there is a graph of lines of conversation over time for #haskell.
17:16:00 <mauke> http://www.heise.de/security/news/foren/S-Voellig-OT-Kennt-wer-Quellen-zum-Lernen-von-Haskell/forum-140315/msg-15193241/read/ :-)
17:16:04 <stevan> hcube: you might want to take a look at http://andrej.com/plzoo/ , there is a "minihaskell".
17:16:05 <dons> http://www.cse.unsw.edu.au/~dons/irc/haskell-08.html
17:16:30 <dons> http://ircbrowse.com/cdates.html?channel=haskell
17:16:52 <vixey> steven, hey I've seen those
17:17:00 <vixey> steven, they're really neat
17:17:17 <vixey> It's an interpreter though.. I guess that a lot of the stuff is shared
17:20:28 <hcube> is minihaskell satisfies haskell 98 standard ?
17:20:31 <hcube> *does
17:21:26 <dons> i'd be surprised.
17:21:40 <dons> probably a valid subset
17:21:43 <stevan> no, it's just an example to show how lazy functional languages work
17:22:10 <catface> was haskell the first lazy functional language?
17:22:38 <hcube> never mind. it is a good starting point to understand.
17:22:49 <byorgey> @go implementation of functional programming languages
17:23:01 <byorgey> oh, no \bot?
17:23:24 <byorgey> http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/index.htm
17:23:29 <vixey> catface: no
17:23:34 <byorgey> hcube: you might be interested in that too
17:25:45 <hcube> byorgey: i'm checking
17:27:42 <solrize> mauke, that person is asking for good sites about haskell written in german
17:32:21 <solrize> hcube, if you just want to know how a functional language compiler (i.e. not necessarily lazy evaluation) works, there are some very small ML implementations around, much simpler than haskell.  for that matter if untyped is ok, you could look at hedgehog lisp
17:32:39 <solrize> if you want to know how haskell works look at that SPJ book that byorgey linked
17:33:28 <solrize> hey byorgey, why is the recent blog posts box in HWN unchanged from 3 months ago?
17:33:39 <byorgey> solrize: eh?
17:34:04 <byorgey> solrize: where is this?
17:35:01 <hcube> solrize: i'm interested in lazy languages now. i'm currently learn about playstation 3 and cell architecture, and i'm curious if is it possible to make an implicit parallellizer compiler.
17:35:20 <hcube> i have much freetime now :)
17:36:43 * edwardk waves hello.
17:37:12 <edwardk> @seen ddarius
17:37:16 <vixey> hi
17:37:17 * byorgey waves back
17:37:36 * byorgey wonders what happened to solrize 
17:37:44 * edwardk just got back from the MSFP. It was nice getting a chance to actually meet a bunch of folks there.
17:38:18 <byorgey> edwardk: cool
17:38:28 <edwardk> and more importantly sitting down and picking tarmo uustalu's brain for a few hours afterwards ;)
17:38:51 <wuxia> the following code grabs a few keys, those in M.keys -- I want to grab all keys; how do I do that?
17:38:55 <wuxia>     forM_ (M.keys ks) $ \(mask,sym) -> do
17:38:57 <wuxia>          kc <- io $ keysymToKeycode dpy sym
17:39:00 <wuxia>          when (kc /= '\0') $ mapM_ (grab kc . (mask .|.)) =<< extraModifiers
17:39:03 <vixey> oh about what ?
17:39:07 <edwardk> though now i need to add a couple more recursion schemes to category extras
17:39:10 <esimp> newbie question -- how do I go about adding a "Char" to the end of a "[Char]" list?
17:39:33 <mauke> esimp: ++
17:39:47 <vixey> > let char = '!' in "[Char]" ++ [char]
17:39:53 <johnnowak> @pl \x y z -> x + y + z
17:40:06 * johnnowak weeps
17:40:11 <esimp> mauke: ahh, excellent thanks.
17:40:16 <idnar> @bot
17:40:19 <edwardk> well we both had some tricks to speed up various operations on (co)free data structures and sat down and started mashing them together to show they were the same thing (modulo how many times redundant the revised representation was)
17:40:23 <mauke> preflex: seen lambdabot
17:40:23 <preflex>  lambdabot was last seen on #haskell 1 hour, 22 minutes and 40 seconds ago, saying:  Add a type signature
17:40:23 <roconnor> :)
17:40:56 <idnar> damnit! why didn't you add that type signature?!
17:41:22 <vixey> yeah lambdabot is broken
17:41:39 <byorgey> edwardk: very cool!  I look forward to hearing about the new recursion schemes =)
17:42:05 <edwardk> byorgey: he presented one at the conference, and the other is just its dual. unfortunately the dual is harder to motivate ;)
17:42:17 <wuxia> who broke lambda bot?
17:43:08 <dobblego> > let char = '!' in "[Char]" ++ [char]
17:43:10 <lambdac>  "[Char]!"
17:43:38 <saml> @pl \x y z -> z + y + x
17:43:39 <lambdac> flip (flip . ((+) .) . (+))
17:43:47 <saml> @pl \x y z -> x + y + z
17:43:48 <byorgey> lambdac++
17:43:49 <lambdac> ((+) .) . (+)
17:44:00 <edwardk> actually i'll admit the biggest thing i got out of the conference was something he mentioned in passing about the fact that if you have a recursion scheme for the cofree comonad (i.e. g_histo) it is 'complete' in that if you have a recursion scheme for another comonad (g_cata) and use it with a distributive law that respects the structure of the comonad, that is enough to require that g_histo will compute the same answer as g_cata.
17:44:01 <dobblego> lambdac has no hoogle though
17:44:27 <edwardk> so the complete power of g_cata is not needed (except for speed)
17:44:53 <ddarius> edwardk: Had Tarmo been following your blog?
17:45:01 <byorgey> yeah, I was going to ask that too =)
17:45:12 <edwardk> ddarius: actually, no. but I think I fixed that ;)
17:45:18 <byorgey> sweet =)
17:46:02 <edwardk> I think of the people in the room, other than him and one or two guys who were there to present some generic programming tricks everyone was actually familiar with it. that was a nice ego boost ;)
17:46:46 <hpaste>  esimp  pasted "basic problem with adding Char to end of [Char]" at http://hpaste.org/8794
17:46:51 <esimp> I'm having a basic syntax/type problem -- can someone take a look at the code snippet I'm posting?
17:46:59 <edwardk> dan gave a very nice talk mostly covering generating function tricks without using the name generating function.
17:47:08 <vixey> esimp put []'s around it
17:48:02 <esimp> vixey: excellent thanks!  (obviously about the first 10 lines of Haskell I've written)
17:48:27 <edwardk> mostly i just made a pain in the ass out of myself ;)
17:48:52 <Cale> @bot
17:48:52 <lambdac> :)
17:48:58 <lambdabot> :)
17:49:03 <vixey> :)
17:49:04 <Cale> aha, good
17:49:11 <Cale> dobblego: ^^
17:49:27 <dobblego> @part #haskell
17:49:34 <lambdabot> Not enough privileges
17:50:24 <rwbarton> :t (++)
17:50:27 <edwardk> I was able to work the codensity monad in as relevant to one of the presentations though, and abuse rank-2 types to solve a problem with another one though, so its all good.
17:50:32 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:50:33 <Cale> esimp: The problem is that calc_crc '0' x is a Char, but (++) is going to want two lists
17:50:40 <edwardk> I was kind of disappointed by the arrow calculus stuff though =(
17:50:42 <vixey> codensity?!
17:50:53 <vixey> oh!
17:51:08 <rwbarton> more caleskell?
17:51:15 <edwardk> vixey: think 'big scary name for universally quantified ContT'
17:51:29 <esimp> Cale: is there a better way to put a Char at the end of a [Char]?
17:51:49 <Cale> esimp: If you have to do that a lot, lists are a bad datatype
17:52:11 <Cale> esimp: xs ++ ys takes O(length xs) steps to evaluate.
17:52:40 <vixey> doesn't xs ++ ys takes exactl length xs steps
17:52:52 <esimp> Cale: gotcha -- is there another operator/way to accomplish the same thing?
17:53:07 <ddarius> edwardk: In an article I'm working on, I'm working with categories functors between which are continuous functions so density should work out to the topological concept (presumably.)
17:53:13 <EvilTerran> vixey, depending on how much of the resulting list you consume
17:53:35 <EvilTerran> vixey, clearly [1..] ++ [0::Integer] doesn't take O(Inf) steps
17:53:35 <edwardk> ddarius: nice. =)
17:53:53 <vixey> yeah everything in haskell is O(0)
17:54:11 <Cale> esimp: That's the simplest way with lists.
17:54:47 <Cale> esimp: Sometimes if you're building a big list by concatenating small bits together, it's more effective to represent things using functions which append to the beginning of a list
17:54:52 <shepheb> sometimes working backwards and then reversing makes it cleaner.
17:54:57 <Cale> esimp: Then concatenation becomes composition (.)
17:55:09 <EvilTerran> vixey, i mean, if, in xs++ys, length xs = n and you force up to the k'th cell, it'll be O(n `min` k) memory consumption
17:55:44 <esimp> Cale: it's actually going to end up as VHDL code, so software performance isn't the end goal :)
17:57:02 <Cale> vixey: and it's actually length xs + 1 anyway, since you have the empty-list step :)
17:57:08 <rwbarton> :t asTypeOf
17:57:08 <lambdabot> forall a. a -> a -> a
17:57:18 <vixey> @src asTypeOf
17:57:18 <lambdabot> asTypeOf = const
17:57:19 <rwbarton> Should be a -> b -> a, in keeping with fmap and ++ :)
17:57:28 <rwbarton> . rather
17:57:53 <vixey> I don't think fmap or ++ have anything to do with asTypeOf
17:58:05 <ddarius> vixey: He's making a joke.
17:58:07 <EvilTerran> vixey, i think he means the more general types
17:58:56 <Cale> The point of asTypeOf is to force the type of the first thing to be the same as the second though.
18:01:55 <edwardk> cale: methinks you just found yourself as the butt of a joke and didn't notice ;)
18:02:14 <edwardk> @type (++)
18:02:16 <lambdabot> forall m. (Monoid m) => m -> m -> m
18:02:49 <edwardk> monoid even, not just MonadPlus, brave ;)
18:03:22 * vixey so confused ..
18:07:38 <Cale> > sortBy (comparing length ++ compare) (words "this is a list of words")
18:07:39 <lambdabot>  ["a","is","of","list","this","words"]
18:07:58 <Cale> edwardk: ^^ :)
18:09:03 <ddarius> > sortBy (comparing length `mappend` compare) (words "this is a list of words")
18:09:04 <lambdabot>  ["a","is","of","list","this","words"]
18:09:29 <vixey> hey wait a second
18:10:00 <Cale> ++ is so much nicer a name than mappend :)
18:10:03 <vixey> > dlist list = (list ++) ; undlist dlist = dlist [] in undlist (dlist "foo" ++ dlist "bar")
18:10:03 <lambdabot>  Parse error at "=" (column 12)
18:10:07 <vixey> > let dlist list = (list ++) ; undlist dlist = dlist [] in undlist (dlist "foo" ++ dlist "bar")
18:10:08 <lambdabot>  "foobar"
18:10:13 <vixey> perfect!
18:10:40 <rwbarton> Yes, mappend is kind of bizarre
18:10:52 <EvilTerran> ?instances-importing Data.Monoid Monoid
18:10:53 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:11:59 <EvilTerran> ah, there's an instance Monoid b => Monoid (a -> b) where mzero _ = mzero; mappend f g x = mappend (f x) (g x), i take it
18:12:11 <Cale> yeah
18:12:19 <vixey> > mzero 7
18:12:23 <lambdabot>   add an instance declaration for (MonadPlus ((->) t))
18:12:24 <lambdabot>     In the expression:...
18:12:31 <vixey> > mzero () 7
18:12:32 <lambdabot>   add an instance declaration for (MonadPlus ((->) ()))
18:12:32 <lambdabot>     In the expression...
18:12:32 <Cale> mempty
18:12:37 <Cale> > mempty 7
18:12:38 <EvilTerran> er, s/mzero/mempty/
18:12:38 <lambdabot>  ()
18:12:41 <vixey> oh
18:12:42 <ddarius> We write liftM2 mappend in these here parts
18:12:45 <EvilTerran> i always get those two the wrong way round
18:12:45 <Cale> > mempty 7 :: [Char]
18:12:46 <lambdabot>  ""
18:12:54 <EvilTerran> ddarius, yeah, i saw that after i hit enter
18:13:02 <ddarius> ()
18:13:35 <Cale> > mempty 1 2 3 4 5 :: [Char]
18:13:36 <lambdabot>  ""
18:13:54 <Cale> > zero 1 2 3 4 5 :: [Char]
18:13:55 <lambdabot>  ""
18:14:07 <mcnster> hi.  can someone advise on an approach to use to make "fn [0,1,2,3,...] = [[0,1],[2,3],...]
18:14:18 <vixey> hehe
18:14:26 <vixey> chunks
18:14:27 <Cale> map (take 2) . iterate (drop 2)
18:14:27 <mcnster> (this is not homework)
18:14:29 <EvilTerran> ah, this is a popular one
18:14:36 <roconnor> do we have chunks in the standard libs yet?
18:14:42 <Cale> map (take 2) . takeWhile (not . null) . iterate (drop 2)
18:14:42 <vixey> roconnor: of course not
18:14:47 <EvilTerran> > map (take 2) . takeWhile (not.null) . iterate (drop 2) $ [0..]
18:14:48 <lambdabot>  [[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,2...
18:15:13 <vixey> hey I have an idea for a hackage thing
18:15:20 <vixey> Data.List.Chunks
18:15:46 <wuxia> ls
18:15:47 <wuxia> alpine
18:15:53 <EvilTerran> > unfoldr ((>>) <$> guard.not.null <*> return.splitAt 2) [0..]
18:15:54 <lambdabot>  [[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,2...
18:16:09 <mcnster> > map ((take 2) . iterate (drop 2)) [0,1,2,3,4,5,6,7]
18:16:10 <lambdabot>   add an instance declaration for (Num [a])
18:16:24 <EvilTerran> brackets in the wrong place
18:16:31 <ddarius> vixey: I was seriously considering a Data.List.Extras the other day
18:16:38 <mcnster> > map (take 2) . iterate (drop 2) [0,1,2,3,4,5,6,7]
18:16:39 <lambdabot>   add an instance declaration for (Num [a])
18:16:47 <rwbarton> > ((take 2) . iterate (drop 2)) [0,1,2,3,4,5,6,7]
18:16:48 <lambdabot>  [[0,1,2,3,4,5,6,7],[2,3,4,5,6,7]]
18:16:52 * vixey has a very fast implementation of chunks
18:16:56 <EvilTerran> > map (take 2) . iterate (drop 2) $ [0,1,2,3,4,5,6,7]
18:16:57 <lambdabot>  [[0,1],[2,3],[4,5],[6,7],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
18:17:19 <Cale> > map (take 2) . iterate (drop 2) $ [0..]
18:17:20 <lambdabot>  [[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,2...
18:17:33 <ddarius> vixey: Does it use Galois theory?
18:17:48 <Cale> Inverse Galois theory :)
18:17:51 <EvilTerran> > [[x,x+1] | x <- [0,2..]]
18:17:53 <lambdabot>  [[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,2...
18:18:24 <mcnster> actually, the numbers are arbitrary and unordered
18:18:26 <EvilTerran> (probably not what was wanted, but still)
18:18:32 <vixey> I haven't used Galois theory lol
18:18:38 <vixey> continuation passing
18:19:13 <vixey> is there really application of Galois theory to list operations ?
18:19:15 <Cale> I give you a group, you give me a field extension having that group as its group of automorphisms :)
18:19:16 <roconnor> if I can get partitionEithers added to the libs, someone should be able to get chunks added.
18:19:29 <vixey> partitionEithers is very useful I call it seive
18:19:44 <vixey> I can't spell though...
18:19:49 <Cale> Perhaps what we really want is a more general shaping thing which takes a list of chunk lengths
18:19:57 <mcnster> > map (take 2) . takeWhile (not.null) .iterate (drop 2) $ [0..7]
18:19:58 <lambdabot>  [[0,1],[2,3],[4,5],[6,7]]
18:20:00 <vixey> Cale, why ...?
18:20:03 <mcnster> > map (take 2) . takeWhile (not.null) .iterate (drop 2) $ [0..6]
18:20:04 <lambdabot>  [[0,1],[2,3],[4,5],[6]]
18:20:04 <roconnor> vixey: that's not a bad name
18:20:17 <mcnster> that's really nifty :)
18:20:33 <vixey> > takeWhile (not.null) .iterate (drop 2) $ [0..6]
18:20:34 <lambdabot>  [[0,1,2,3,4,5,6],[2,3,4,5,6],[4,5,6],[6]]
18:20:37 <vixey> > iterate (drop 2) $ [0..6]
18:20:38 <lambdabot>  [[0,1,2,3,4,5,6],[2,3,4,5,6],[4,5,6],[6],[],[],[],[],[],[],[],[],[],[],[],[]...
18:20:39 <Cale> vixey: because then the simple chunks is just a combination of that with repeat
18:20:55 <EvilTerran> mcnster, the unfoldr version has the same properties, even tho it's much more arcane
18:20:57 <vixey> Cale: I don't see that as a good thing
18:21:02 <Cale> vixey: hm?
18:21:14 <Cale> vixey: I've seen people ask for the more general one too.
18:21:34 <ddarius> There's nothing wrong with having both...
18:21:34 <mcnster> EvilTerran, i take it the operator . has precedence over $, right?
18:21:46 <EvilTerran> yes
18:22:13 <EvilTerran> you can check fixities in ghci with :i(nfo)
18:22:31 <mcnster> EvilTerran, thanks :)
18:22:51 <EvilTerran> if it doesn't say, it's infixl 9, iirc
18:23:13 <EvilTerran> ghci> :i .
18:23:15 <EvilTerran> (.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in GHC.Base
18:23:15 <EvilTerran> infixr 9 .
18:23:15 <EvilTerran> ghci> :i $
18:23:15 <EvilTerran> ($) :: (a -> b) -> a -> b       -- Defined in GHC.Base
18:23:15 <EvilTerran> infixr 0 $
18:23:24 <mcnster> !hoogle iterate
18:23:41 <mcnster> @hoogle iterate
18:23:41 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
18:23:41 <lambdabot> Data.List.iterate :: (a -> a) -> a -> [a]
18:23:41 <lambdabot> Data.ByteString.Lazy.iterate :: (Word8 -> Word8) -> Word8 -> ByteString
18:25:51 <mcnster> iterate (drop 2) $ [0..7]
18:25:59 <mcnster> > iterate (drop 2) $ [0..7]
18:26:00 <lambdabot>  [[0,1,2,3,4,5,6,7],[2,3,4,5,6,7],[4,5,6,7],[6,7],[],[],[],[],[],[],[],[],[],...
18:26:39 <mcnster> > takeWhile (not.null) . iterate (drop 2) $ [0..7]
18:26:40 <lambdabot>  [[0,1,2,3,4,5,6,7],[2,3,4,5,6,7],[4,5,6,7],[6,7]]
18:27:47 <mcnster> god, i love haskell.  thanks guys :)
18:35:21 <BMeph> Sory, I was surfing the past half-hour, but to resurrect an old topic: I especially dislike 'mappend,' because I keep breaking it up as "map-pend," then have to go back and remind myself, no, it's 'mAppend." I still hate it, though. :|
18:37:21 <mauke> just use ++
18:39:04 <dobblego> I read it as "em-append" or "monoid-append"
18:39:29 * vixey just reads it as "mappend"
18:40:14 <mauke> 
18:40:31 <BMeph> dobblego: I (interpret) it as "monoid-append" but I still Read it first off as "map-pend".
18:40:44 <BMeph> mauke: You're evil. Evil!!! o.O
18:40:52 <BMeph> mauke: Don't ever change. ;)
18:42:15 * BMeph smirks at mauke and his "" 
18:42:25 <fiddlerwoaroof> how can I make a function that defines a step of a recursive algorithm recursive?
18:42:42 <vixey> that doesn't make sense
18:42:47 <roconnor> GHC's scoped type variables work the opposite way than I'd expect.
18:43:04 <fiddlerwoaroof> vixey: fibstep c@(x:y:xs) = (x+y):c
18:43:11 <fiddlerwoaroof> > let fibstep c@(x:y:xs) = (x+y):c
18:43:12 <lambdabot>  Parse error at end of input
18:43:13 <roconnor> I'd expect forall x. [x] -> [x] to limit the scope to the expression
18:43:38 <fiddlerwoaroof> > fibstep c@(x:y:xs) = (x+y):c
18:43:38 <lambdabot>  Parse error at "=" (column 20)
18:43:38 <vixey> I don't know what that is
18:43:39 <roconnor> while [x] -> [x] would allow x to be used anywhere in the declairation
18:43:56 <mauke> roconnor: that would be incompatible with H98
18:44:13 <vixey> > let fibstep c@(x:y:xs) = (x+y):c in iterate fibstep [1..]
18:44:14 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:44:24 <vixey> > let fibstep c@(x:y:xs) = (x+y):c in map head . iterate fibstep $ [1..]
18:44:24 <fiddlerwoaroof> - fibstep [1,1]
18:44:25 <lambdabot>  [1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127,2...
18:44:30 <fiddlerwoaroof> [2,1,1]
18:44:31 <vixey> doesn'tlook like fibs
18:44:38 <vixey> oh I see
18:44:45 <vixey> define fib n
18:44:51 <roconnor> mauke: in what way?
18:45:32 <vixey> > let fib 0 = [1,1] ; fib n = fibstep (fib (n-1)) ; fibstep c@(x:y:xs) = (x+y):c in map fib [1..]
18:45:34 <lambdabot>  [[2,1,1],[3,2,1,1],[5,3,2,1,1],[8,5,3,2,1,1],[13,8,5,3,2,1,1],[21,13,8,5,3,2...
18:45:42 <mauke> roconnor: H98 requires unforall'd type variables to be limited to their type declaration
18:45:43 <vixey> > let fib 0 = [1,1] ; fib n = fibstep (fib (n-1)) ; fibstep c@(x:y:xs) = (x+y):c in map (head.fib) [1..]
18:45:43 <lambdabot>  [2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,...
18:45:54 <roconnor> mauke: and removing that restriction breaks what?
18:46:30 <roconnor> mauke: okay, I can think of some stupid programs that might break
18:46:33 <electronx> can hakell do unicode
18:46:38 <electronx> haskell*
18:46:47 <dobblego> @faq can haskell do unicode
18:46:48 <lambdabot> The answer is: Yes! Haskell can do that.
18:46:57 <vixey> electronx: it can .. lambdabot can't though :
18:47:07 <roconnor> mauke: but since they are stupid, I think my proposal would be reasonable for haskell prime
18:47:08 <mauke> depends on your definition of "unicode"
18:47:22 <vixey> roconnor: forget haskell prime...
18:47:33 <mauke> > toUpper '\xe4'
18:47:33 <lambdabot>  '\196'
18:47:40 <electronx> lol @faq swim
18:47:45 <roconnor> vixey: why?
18:47:47 <electronx> @faq swim
18:47:47 <lambdabot> The answer is: Yes! Haskell can do that.
18:49:09 <BMeph> @faq barbecue yaks?
18:49:13 <lambdabot> The answer is: Yes! Haskell can do that.
18:49:28 <BMeph> Mmm... barbecue! ;)
18:49:29 <vixey> @faq quantifier elimination
18:49:32 <lambdabot> The answer is: Yes! Haskell can do that.
18:49:34 <vixey> -_-
18:49:40 <BMeph> ^_^
18:50:24 <BMeph> Oops, speaking of leaving... see y'all tomorrow!
18:53:45 <ddarius> roconnor: There are perfectly reasonable programs that that would break.  Pretty much anything that had an annotation on a polymorphic local value.
18:54:29 <roconnor> only if the type variable in the annotation coflicts with the variable in the toplevel type decl
18:54:46 <roconnor> which would be bad programming practice and confusing for the reader
19:00:50 <lxuser> ?pl \(x,(y,(z,(w,())))) -> liftM4 (\a b c d -> (a,(b,(c,(d,()))))) (f x) (f y) (f z) (f w)
19:00:54 <lambdabot> ap (flip ap snd . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip flip f . ((flip . (((.) . flip) .)) .)
19:00:54 <lambdabot>  . flip flip f . ((.) .) . (flip .) . (. f) . flip . flip (liftM4 . flip ((.) . (.) . (.) . (,)) . flip ((.) . (.) . (,)) . flip ((.) . (,)) . flip (,)) . f . fst) snd
19:00:54 <lambdabot> optimization suspended, use @pl-resume to continue.
19:01:19 <shepheb> "optimization"...
19:03:20 <lxuser> @pl-resume
19:03:26 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip flip f . ((flip . (((.) . flip) .)
19:03:26 <lambdabot> ) .) . flip flip f . (((.) . flip) .) . (. f) . flip . flip (liftM4 . flip ((.) . (.) . (.) . (,)) . flip ((.) . (.) . (,)) . flip ((.) . (,)) . flip (,)) . f)
19:07:30 <atp> that's much clearer.
19:07:38 <atp> i'd definitely go with the point-free version.
19:08:21 <vixey> lol
19:12:01 <lxuser> :t \(x,(y,(z,(w,())))) -> liftM4 (\a b c d -> (a,(b,(c,(d,()))))) (f x) (f y) (f z) (f w)
19:12:03 <lambdabot> forall t t1 t2 t3 a1 a2 a3 a4 (m :: * -> *). (Monad m, SimpleReflect.FromExpr (m a4), Show t3, SimpleReflect.FromExpr (m a3), Show t2, SimpleReflect.FromExpr (m a2), Show t1, SimpleReflect.FromExpr (
19:12:03 <lambdabot> m a1), Show t) => (t, (t1, (t2, (t3, ())))) -> m (a1, (a2, (a3, (a4, ()))))
19:12:17 <atp> wow
19:12:28 <vixey> what does   |=     .  mean?
19:12:29 <atp> did you crash lambdabot?
19:12:45 <dmwit> heh
19:12:46 <atp> vixey: in APL?
19:12:48 <atp> hehe
19:12:51 <atp> (joke)
19:12:57 <rwbarton> it might have been me; I was messing with @pl-resume...
19:13:07 <rwbarton> I can't figure out exactly what it does
19:13:10 <atp> shame on you rwbarton
19:13:31 <dmwit> rwbarton: ?pl is iterative; ?pl-resume runs a few more iterations
19:13:39 <dmwit> (From what I understand.)
19:14:30 <rwbarton> dmwit: That was my vague impression, but I would only really understand that if the output of the ?pl contained lambda-expressions
19:14:51 <dmwit> It first strips lambdas, then "optimizes" the expression to make it shorter.
19:14:52 <dmwit> Usually.
19:14:57 <ddarius> vixey: It depends on the context.  In logical context |= is usually satisfaction given a model.
19:15:18 <dmwit> Stripping is easy; optimization is hard; so the optimization time is what gets limited.
19:15:19 <vixey> thank you
19:15:45 * dmwit notes that "stripping is easy" can be interpreted in many ways, all of them correct
19:16:03 <rwbarton> I see
19:16:26 * shepheb submits stripping a small wire using a knife as a counterexample
19:16:36 <ddarius> vixey: The statement you gave is a statement of completeness of a theory.
19:18:29 <rwbarton> vixey: roughly "If \phi holds in every model (of some fixed theory) satisfying \Gamma, then \phi can be proved syntactically from \Gamma"
19:18:48 <vixey> what's a proof syntactically?
19:19:07 <vixey> like a finite sequent derivation ?
19:20:38 <rwbarton> Yeah
19:21:20 <vixey> is there anything I could read about quantifier elimination online?
19:21:34 <vixey> I didn't find anything..
19:21:43 <rwbarton> for any particular theory?
19:22:29 <ddarius> vixey: Look up Skolemization?
19:23:09 <vixey> I was trying to do a problem with a dense ordered sets but I want to know in general
19:23:25 <vixey> oh yeah I want to do Skolemization
19:26:04 <rwbarton> here are the notes from a course I took on model theory: http://www.ma.huji.ac.il/~kazhdan/Notes/motivic/b.pdf
19:26:15 <lambdabot> Title: LOGIC January 14, 2006 1. Introduction In this course we will discuss applicatio ...
19:26:20 <vixey> oh thank you
19:26:37 <rwbarton> they're pretty sketchy.  You probably want to ignore many of the applications.  Section 8 (p. 37) introduces quantifier elimination
19:26:37 <vixey> I am reading about model theory
19:35:00 <dobblego> is there a lift for a contra-variant functor?
19:35:37 <dobblego> comonad lift?
19:35:55 <dobblego> I get the hunch that I need a monoid to do it
19:38:32 <rwbarton> dobblego: what do you mean by lift here?
19:40:35 <dobblego> I can Fx -> (y -> x) -> Fy
19:40:45 <dobblego> but I want to Fx -> Fy -> (z -> y -> x) -> Fz
19:41:03 <dmwit> uh
19:41:06 <dobblego> similar to liftM2
19:41:10 <dmwit> Fx -> (y -> x) -> Fy?
19:41:11 <dmwit> Really?
19:41:16 <dobblego> yes,
19:41:50 <dobblego> ?type comap
19:41:50 <lambdabot> Not in scope: `comap'
19:41:57 <rwbarton> Do you really want (z -> y -> x) and not (z -> (x, y))?
19:42:14 <mauke> Fx -> (z -> y -> z) -> (Fy, Fz)
19:42:20 <wuxia> anyone else having prlb.em reading haskell.org? i can reach google fine, but can't get to haskell.org
19:43:23 <dmwit> http://downforeveryoneorjustme.com/haskell.org
19:43:32 <lambdabot> Title: It's just you.
19:43:33 <dobblego> not sure
19:43:41 <wuxia> lol.
19:43:44 <wuxia> IK can't reach that site either
19:43:51 <dmwit> WFM
19:44:05 <wuxia> fyuck, i can't go to google.com either
19:44:08 <wuxia> why is irc still working
19:44:20 <rwbarton> Well if you have something that eats x's and something that eats y's, and you have a z, you need to produce both an x and a y
19:44:25 <dobblego> because your browser is screwed
19:44:49 <wuxia> google and reddit just loaded up
19:44:53 <wuxia>  ping www.haskell.org
19:44:53 <wuxia> PING bugs.haskell.org (128.36.229.215) 56(84) bytes of data.
19:44:53 <wuxia> 64 bytes from bugs.haskell.org (128.36.229.215): icmp_seq=4 ttl=48 time=146 ms
19:45:07 <wuxia> ping www.haskell.org
19:45:07 <wuxia> PING bugs.haskell.org (128.36.229.215) 56(84) bytes of data.
19:45:07 <wuxia> 64 bytes from bugs.haskell.org (128.36.229.215): icmp_seq=4 ttl=48 time=146 ms
19:45:07 <wuxia> 64 bytes from bugs.haskell.org (128.36.229.215): icmp_seq=5 ttl=48 time=163 ms
19:45:11 <wuxia> wow, this looks bad?
19:45:57 <dobblego> I would settle for Fx -> Fy -> ? -> F (x, y)
19:46:21 <dobblego> can I have one of those?
19:46:30 <rwbarton> Yes, I think that's the crux of it
19:47:25 <rwbarton> Well, maybe not...
19:47:34 <dobblego> if we assume comap :: Fx -> (y -> x) -> Fy then it is not clear to me how I can get that function
19:48:03 <rwbarton> I think it's very likely that you cannot, seeing as Control.Applicative is different from Functor.
19:48:06 <dobblego> yes it feels like I should be able to
19:48:23 <dobblego> actually, it feels like I could, if I had a monoid
19:48:36 <rwbarton> Well, you have too many choices really...
19:48:39 <dobblego> yes agreed
19:48:49 <rwbarton> You can write f x -> f y -> f (x, y)
19:49:03 <rwbarton> Let's say f = (-> z) in "pretend haskell"
19:49:12 <rwbarton> @djinn (x -> z) -> (y -> z) -> ((x, y) -> z)
19:49:13 <lambdabot> f a _ (b, _) = a b
19:49:43 <rwbarton> that just used the first argument and threw away y entirely.
19:49:52 <ddarius> dobblego: It be a bit clearer to write it (y -> x) -> (Fx -> Fy)
19:50:00 <dobblego> ddarius, indeed
19:50:43 <rwbarton> If z is a monoid, you could use both x and y and multiply the results, but I don't know whether that's what you want to do.
19:50:51 <rwbarton> Another option is
19:51:05 <rwbarton> @djinn (x -> z) -> (y -> z) -> (Either x y -> z) --- I guess this is called either
19:51:05 <lambdabot> Cannot parse command
19:51:05 <Cale> It's somewhat surprising that we don't have a standard Cofunctor class.
19:51:07 <dmwit> :t (((==) . (= ==)) .) . mod
19:51:08 <lambdabot> parse error on input `='
19:51:10 <rwbarton> @djinn (x -> z) -> (y -> z) -> (Either x y -> z)
19:51:10 <lambdabot> f a b c =
19:51:10 <lambdabot>     case c of
19:51:10 <lambdabot>     Left d -> a d
19:51:10 <lambdabot>     Right e -> b e
19:51:14 <dmwit> :t (((==) . (0 ==)) .) . mod
19:51:15 <lambdabot> forall a. (Integral a) => a -> a -> Bool -> Bool
19:52:02 <dobblego> rwbarton, I will have to do some mental gymnastics and figure out exactly what I want; thanks for your help
19:55:41 <dobblego> Cale, I assume there is a Cofunctor in one of the libraries on hackage
19:56:00 <dobblego> (and InvFunctor perhaps?)
19:56:13 <ddarius> Presumably there is one in category-extras somewhere.
19:56:26 <ddarius> class InvFunctor f where {}
19:56:26 <dobblego> I'd forgotten its name; that's what I was thinking of
19:57:19 <dobblego> are you saying the InvFunctor type-class would not be useful?
20:01:46 <wuxia> anyone else have a really slow internet connection sudeenly?
20:01:54 <wuxia> i can load various sites, but  it's just veeeeeeeeeeeeeeeeeeeery slow
20:02:35 <dobblego> yes, the television is reporting that someone unplugged the main internet machine and the backup is running now
20:02:58 <wuxia> i'm almost willing to believe you given how slolw it is right now
20:04:54 <mwolak> is there a clean way to uninstall ghc if you've installed it from source?
20:08:52 <vixey> yes http://en.wikipedia.org/wiki/List_of_first-order_theories
20:08:53 <lambdabot> Title: List of first-order theories - Wikipedia, the free encyclopedia
20:12:27 <ddarius> dobblego: An invariant functor has no action on arrows.
20:15:43 <wuxia> http://it.slashdot.org/it/08/07/08/195225.shtml <-- anyone think this might be slowing down the internet?
20:15:43 <lambdabot> Title: Slashdot | Massive, Coordinated Patch To the DNS Released
20:23:52 <SamB> dibblego: I was almost willing to believe you based on how bad the TV news is lately
20:24:44 <SamB> I mean, clearly it's utter nonsense but that wouldn't necessarily stop them from broadcasting it on national TV
20:25:20 <SamB> how the heck do you work in secret with a large number of people?
20:25:30 <SamB> (or other entities)
20:25:43 <vixey> NDAs
20:26:04 <SamB> secrecy is still inversely proportional to the number of people you tell
20:26:06 <SamB> NDA or no
20:26:17 <gwern> SamB: cellular structure? need to know?
20:26:25 <vixey> it's more complex than number of people
20:26:39 <gwern> cryptographic sharing protocols distributing a secret over k fragments...
20:27:00 <SamB> gwern: dude, we aren't talking about a resistance
20:27:40 * gwern begins raving about darknets and plausible deniability against rubberhose crypto
20:28:38 * vixey wants to go to the library :/
20:29:15 <ddarius> vixey: Then go.
20:29:25 * wuxia is wondering why his internet is suddenly so slow
20:29:44 <vixey> I have to wait hours before it opens
20:29:46 <ddarius> wuxia: Maybe it ate too much last night.
20:29:53 <ddarius> vixey: You could break in.
20:30:02 <ddarius> Moin, of sorts, shapr
20:30:16 <vixey> hmm
20:30:20 <vixey> hi shapr
20:30:32 <shapr> yarr!
20:30:34 <Axman6> and when they open the doors and the hot librarian asks what you're doing, you just reply "i needed to read!" and she'll be yours for life
20:30:40 <shapr> I just got home from work. argh
20:30:55 <shapr> Um
20:30:56 <dmwit> Axman6: ...?
20:31:01 <shapr> Yeah, hot Haskell librarian.
20:31:07 <shapr> @users
20:31:07 <lambdabot> Maximum users seen in #haskell: 418, currently: 413 (98.8%), active: 13 (3.1%)
20:31:09 <vixey> Axman6 is fantasizing :P
20:31:12 <Axman6> @ vixey
20:31:13 <SamB> rubberhose crypto?
20:31:23 <SamB> is that crypto that doesn't leave bruises?
20:31:28 <Axman6> i already have a hot girlfriend
20:31:39 <shapr> Does she write Haskell?
20:31:45 <shepheb> SamB: get hold of someone who knows the access info, and apply a rubber hose.
20:31:51 <dmwit> Mine writes labview!  And C++!
20:31:51 <Axman6> no.. and she uses vista :(
20:31:53 * ddarius suspects vixey doesn't want a hot girlfriend, but he could be wrong about her.
20:31:55 <Axman6> but! she hates it
20:31:56 <dmwit> That's a pretty good start, I think.
20:32:08 <vixey> I just want books not relationships
20:32:10 <SamB> vixey's a her?
20:32:19 <ddarius> vixey: Probably a good idea.
20:32:20 <vixey> SamB: yes
20:32:26 <vixey> shapr, I got an idea for something I started to do..
20:32:31 <shapr> vixey: What's that?
20:32:39 <Cale> My girlfriend picked up Haskell rather quickly. She claims to have invented functional programming as a child. :)
20:32:44 <SamB> huh, in retrosopect the name should does seem somewhat female
20:32:44 <Axman6> s/she/he
20:32:49 <SamB> Cale: WOW
20:32:51 <Axman6> Cale!
20:32:55 <SamB> it's believable
20:33:06 <SamB> but she must be smart
20:33:15 <SamB> and lucky
20:33:16 <ddarius> Cale: Is your girlfriend 80+ years old.
20:33:26 <vixey> shapr, I'm writing a really simple lazy language with a type system & either a compiler or interpreter..
20:33:32 <Axman6> Cale: is there any chance of turning off lambdabot's url announce for #macosx?
20:33:35 <shapr> vixey: Sounds nifty.
20:33:36 <vixey> so if I did in a good way it could be useful example
20:33:38 <SamB> ddarius: you never heard of reinvention?
20:33:40 <Cale> ddarius: Heh, no, she's 26.
20:33:47 <shapr> vixey: Yeah, that would be especially cool.
20:33:57 <Cale> (Yes, independently of course ;)
20:33:57 <ddarius> SamB: Cale didn't say she reinvented it.
20:34:19 <SamB> ddarius: despite the widespread advice not to reinvent the wheel?
20:34:32 <Axman6> any girl who even thought about programming as a child is worth keeping
20:34:37 <SamB> reinvention  invention
20:34:48 <Cale> Axman6: Beelsebob was working on it.
20:35:05 <Axman6> eh? how?
20:35:23 <Cale> Axman6: By implementing a patch to allow it to be turned on and off on a per-channel basis.
20:35:28 <SamB> Axman6: presumably hacking lambdabot ...
20:35:29 <shapr> vixey: You could write it as literate Haskell.
20:35:31 <SamB> duh
20:35:31 <Axman6> oh, excellent
20:35:38 <shapr> vixey: And then put the documentation inline with the code.
20:35:58 <vixey> would that mean writing lots of TeX ?
20:36:03 <SamB> vixey: are you going to finish it before you figure out whether it's a compiler or an interpreter?
20:36:08 <SamB> vixey: not necessarily
20:36:17 <Cale> BeelsebobWork_: Uh, actually, you sent me a @tell which said that you darcs sent me something, but I didn't get anything.
20:36:21 <SamB> oleg writes them in plaintext with birdfeet
20:36:23 <SamB> right?
20:36:56 <shapr> vixey: Nah, literate Haskell could just be text.
20:37:19 <SamB> or it could be rfc 2822
20:39:34 <Axman6> do notmal comments work in literate haskell
20:39:35 <Axman6> ?
20:39:45 <dmwit> yes
20:40:09 <SamB> see http://okmij.org/ftp/Haskell/zip-folds.lhs ?
20:40:34 <shapr> vixey: Do you have source?
20:40:41 <vixey> what's that?
20:40:55 <SamB> vixey: a .lhs file in rfc 2822
20:41:10 <SamB> (one of oleg's)
20:41:14 <shapr> rfc 2822 is the 'email rfc'
20:41:20 <SamB> alse news
20:41:49 <SamB> which saves one the trouble of figuring out whether one is using a mailing list or a newsgroup ;-)
20:45:02 <shapr> vixey: Is any of your simple lazy language source online?
20:45:28 <shapr> hiya andyjgill
20:45:32 <vixey> shapr: oh I only just started so I've only wrote the parser so far
20:45:37 <noecksit> @hoogle yield
20:45:38 <lambdabot> GHC.Conc.yield :: IO ()
20:45:38 <lambdabot> Control.Concurrent.yield :: IO ()
20:45:40 <andyjgill> hi!
20:45:48 <shapr> vixey: That's cool. Do you have a darcs repo online?
20:45:49 <vixey> I'm doing pattern matching now
20:45:57 <vixey> no
20:46:02 <shapr> Think you will?
20:46:04 <vixey> I don't have anywhere to put that stuff
20:46:12 <shapr> Do you want a place to put that stuff?
20:46:34 <ddarius> vixey hasn't discovered the meaning of the word "community" yet.
20:47:11 <shapr> #haskell does have an unusual community.
20:47:20 <shapr> vixey: Would you like an account on my server?
20:47:26 <sbahra> I would
20:47:38 <Zao> shapr: In that it's reasonably competent compared to the communities of other languages? :)
20:47:43 <shapr> sbahra: Yes, but I haven't seen any Haskell code that you've written :-)
20:47:51 <shapr> Zao: precis!
20:47:54 <sbahra> shapr, that's because I don't.
20:48:02 <Axman6> sbahra: did that cpuid info help at all yesterday?
20:48:06 <sbahra> shapr, I'm still in very early stages of haskell. :]
20:48:11 <shapr> sbahra: Then, how would it contribute to the #haskell community if I gave you an account?
20:48:14 <sbahra> Axman6, hey! Yeah. That tool is wrong in many cases.
20:48:22 <sbahra> Axman6, I wrote a replacement.
20:48:23 <Axman6> heh, ok
20:48:28 <Axman6> want me to test?
20:48:29 <sbahra> Axman6, that is fully standards compliant, etc...
20:48:40 <shapr> sbahra: If you write cool Haskell code, I'll give you an account for darcs repo hosting.
20:48:43 <sbahra> Axman6, sure. I'll let you know once I'm done with it.
20:48:43 <vixey> shapr, I guess so.. that would kind of you
20:48:50 <Axman6> ok :)
20:48:56 <sbahra> shapr, thanks :-) I have servers.
20:49:07 <shapr> I've been giving out accounts to encourage sharing of Haskell code for several years.
20:49:20 <shapr> hpaste is hosted on my server for that reason. lambdabot ran on my server for a bunch of years.
20:50:06 <shapr> I'm sure I've hosted other stuff... oh I hosted lemmih's code for awhile.
20:50:37 <shapr> sbahra: Well, if you write some cool Haskell code, and you want a place to put up a darcs repo... ;-)
20:51:31 <sbahra> I use git
20:51:32 <sbahra> ;p
20:51:55 <ddarius> That's a solveable problem.
20:52:04 <sbahra> What's wrong with git?
20:52:15 <shapr> Nothing wrong with it...
20:52:18 <sbahra> Or, better, why is darcs better than git?
20:52:26 * sbahra busts a beat for shapr 
20:52:29 <Zao> A better question would be "what's right with git?".
20:52:29 <shapr> Well, darcs is written in Haskell.
20:52:39 <Zao> sbahra: No proper Windows support, for one.
20:52:46 <sbahra> That isn't a problem for me.
20:52:51 <shapr> So it seems to me that offering Haskell project hosting with darcs encourages use of Haskell... right?
20:52:55 <noecksit> shapr : r u the primary admin on community.haskell.org?
20:53:02 <Zao> sbahra: It'd alienate any Windows users of your code.
20:53:05 <sbahra> shapr, yes, cool :-)
20:53:06 <shapr> noecksit: No, though I am one of the admins.
20:53:24 <sbahra> Zao, actually, there are win32 ports. I'm not sure how usable they are to the average user.
20:53:38 <ddarius> shapr: You are?
20:53:44 <sbahra> Zao, and that isn't a problem for me either (and no, this isn't due to some Windows/Microsoft hatred).
20:53:46 <noecksit> shapr : ah cool, i wrote a request for an account today
20:53:51 <shapr> ddarius: Yeah
20:53:57 <shapr> ddarius: Not that I've done anything for it recently :-)
20:54:03 <Zao> sbahra: From what I've gathered, they depend on you having half an unix system in the form of cygwin and whatnot around.
20:54:10 <sbahra> Zao, do you have another reason that is relevant to me?
20:55:56 <noecksit> i discovered today that gtk2hs's onExpose function is supposed to be called every periodically every few seconds, but it doesnt do that in haskell
20:56:46 <noecksit> apparently because of the thread issue, so you need to have "timeoutAdd (widgetQueueDraw widget >> return True) 1000" in order for it to work properly
20:57:42 <roconnor> every few seconds/
20:57:43 <roconnor> ?
20:58:22 <noecksit> or every few milliseconds, that is controlled through the second parameter in timeoutAdd function
20:58:26 <shapr> Man, I just noticed that andyjgill has unsafeperformio.com ... and edwardk has comonad.com and lots of other people have Haskelly domain names, I want one too!
20:58:41 * cjb == monad.printf.net.
20:58:47 <shapr> see!
20:58:49 <cjb> not exactly a haskelly domain name, but :)
20:58:55 <shapr> It's pretty cool..
20:59:06 <shapr> I mean, ScannedInAvian.com is not bad... but it's not Haskelly!
20:59:25 <sbahra> .io is available, no?
20:59:33 <sbahra> Around $70 a year, iirc.
20:59:50 <Axman6> onlymonad.io
21:00:15 <shapr> ooh
21:00:16 <Axman6> or, justmonad.io
21:00:17 <cjb> looks like more, ~$120
21:00:33 <sbahra> cjb, try cmydomain.com
21:00:36 <roconnor> maybemonad.io
21:00:50 <sbahra> cjb, they resell, I'm not sure from who.
21:00:56 <sbahra> cjb, but they have some nice prices for some tlds
21:01:43 <ddarius_> shapr: unicycle.com/org/net is presumably already taken
21:02:08 <shapr> ddarius: yup
21:02:13 <mrsolo> cygwin eeww
21:04:40 <Associat0r> Smokey`
21:09:22 <vixey> SamB: well what do you think would be more useful ?
21:20:25 <ddarius> shapr: Does ScannedInAvian support gopher?
21:35:17 <roconnor> bizzare
21:36:01 <roconnor> when you scale a text field negative in ooimpress, the text becomes upsided down ... and backwards.
21:36:13 <roconnor> ... that makes no sense
21:36:24 * roconnor shakes his head
21:36:30 <roconnor> if only it was written in haskell
21:38:47 <b\6> what should happen?
21:41:59 <dmwit> b\6: Logically, or from a UI perspective?
21:42:17 <dmwit> Logically, the text should become either upside down or backwards, depending on which way you scaled it negative.
21:42:32 <dmwit> From a UI perspective, it should always be right-side-up and right-to-left.
21:43:01 <dmwit> (i.e. becoming both upside down *and* backwards, just by scaling negative in one direction, is neither logical nor humane.)
21:43:32 <b\6> i guess i don't agree with two flips, but .. maybe i think the idea of negative scaling itself is weird.
21:44:03 <b\6> the text is basically entering the warp zone.
21:44:04 <dmwit> Agreed, the right thing to do is to always stay right-way-round.
21:44:28 <dmwit> You should only be able to get weird behavior like that explicitly, say, by rotating the text.
21:44:57 <b\6> yeah, guess so.
21:45:17 <b\6> last time i had to do a presentation, i used vim and did :n for the next slide.
21:45:27 <b\6> or html and css is fine.
21:45:34 <b\6> scared of whatever ooimpress is doing.
21:46:05 <dmwit> You might like beamer.
21:46:32 <b\6> ok, i see its page.
21:46:36 <b\6> thanks.
22:13:15 <mmorrow> hahah http://www.promotinglinux.com/truth/
22:13:16 <lambdabot> Title: The Truth" | PromotingLinux.com
22:16:14 <b\6> i can't handle the gigahertz wave, either.
22:16:36 <mmorrow> whoever wrote that page is a comic genius
22:19:46 <mmorrow> hahahalol
22:19:53 <mmorrow> best site i've seen in a long time
22:19:54 <mmorrow> http://www.promotinglinux.com/celebrity/jack-nicholson/
22:19:55 <lambdabot> Title: Jack Nicholson | PromotingLinux.com
22:22:09 <mmorrow> @remember jack-nicholson You only lie to two people in your life, Linux fanboys and the police. Neither can handle the truth.
22:22:09 <lambdabot> Good to know.
22:25:20 <shepheb> mmorrow: I should've stopped reading when I read "Responses to...", three words of the first comment was enough to kill my smile.
22:26:02 <mmorrow> shepheb: huh?
22:26:30 <mmorrow> some of the best jokes are those told with a straight face
22:26:47 <shepheb> mmorrow: I lol'd at the main article, it's awesome.
22:26:55 <shepheb> but the comments are sad
22:27:01 <mmorrow> oh. yeah
22:27:06 <mmorrow> i see what you're saying
22:30:57 <shepheb> I've tried a couple of times to make a YouTube comment so spectacuarly, over-the-top stupid that people realized I was joking. I believe it to be impossible,
22:31:28 <Pseudonym> Poe's Law
22:32:03 <Pseudonym> http://rationalwiki.com/wiki/Poe%27s_Law
22:32:04 <lambdabot> Title: Poe's Law - RationalWiki
22:32:11 <mmorrow> shepheb: totally.
22:35:10 <dmwit> "The likes of Li*us, R*S [masked for legal reasons]"
22:36:17 <roconnor> mmorrow: That truth page reminds me of Dijkstra, only less critical.
22:37:07 <roconnor> As some of you might know, America is the greatest country that has ever existed
22:37:22 <Pseudonym> By which measure of greatness?
22:37:35 <roconnor> Pseudonym: how American you are I guess.
22:37:45 <dmwit> By how much I live there.
22:37:53 <dmwit> I live in America much more than I live in any other country.
22:37:54 <mmorrow> roconnor: ha.
22:37:56 <dmwit> therefore...
22:38:11 <Pseudonym> "Great" literally means large, significant or out of the ordinary.
22:38:19 <Pseudonym> America fails on only one of those.
22:38:37 <shepheb> Pseudonym: I'm thoroughly entertained by the Internet Laws section of RationalWiki
22:38:40 <Pseudonym> It 's a few down the list of largest nations that have ever existed.
22:38:47 <Pseudonym> Yes. :-)
22:39:36 <roconnor> Back in Nam, some of the guys in my squad tried using linux. How hard can it be? they asked. What happened? Charlie got them. Each and every one of them. While they were trying to find the start menu, BAM! All gone.
22:39:51 <roconnor> I'm convinced
22:40:08 <mmorrow> "We're all ears."
22:40:58 <mmorrow> gratuitous use of dolph lundgren is one of my favorite parts about the site
22:41:21 <joed> A site that only says Huh?
22:42:08 <_zenon_> shepheb: Could you post the comments?
22:42:46 <roconnor> Dont let anyone tell you differently, the victory over Saddama and his massive sand armies was the product of the Microsoft Corporation.
22:42:51 <_zenon_> Dolph Lundgren has black belt in Kyokushin
22:43:05 <Pseudonym> I have a black belt in Chi' Ting.
22:43:21 <joed> I have a black belt in Ninjitsu
22:43:24 <vixey> @hoogle Monoid
22:43:24 <lambdabot> Data.Monoid :: module
22:43:25 <lambdabot> Data.Monoid.Monoid :: class Monoid a
22:43:41 <mmorrow> i'm a fifth degree black belt in streetfighter two (arcade version)
22:43:56 <vixey> @hoogle msum
22:43:56 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
22:43:56 <lambdabot> Data.Foldable.msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
22:43:57 <roconnor> Server: Apache/2.0.52 (CentOS)
22:44:53 <_zenon_> Since it's a matter of buying your way to the top in "Ninjutsu" , that's hardly impressive. $$
22:45:45 <hpaste>  111 pasted "(no title)" at http://hpaste.org/8796
22:45:49 <joed> Oh, I got mine in Japan in the late 90's most americans at that time were buying 5-6th dans.
22:47:23 <_zenon_> joed: Okay, I withdraw that statement then. But you can not deny that the whole Bujinkan thing has gone into a dark spiral.
22:48:18 <stepcut> cpphs sucks.
22:48:45 <mmorrow> stepcut: why?
22:49:14 <stepcut> mmorrow: well, today it sucks because after processing the document it left the #endif in the code
22:49:55 <mmorrow> "oops"
22:50:07 <stepcut> the first #ifdef #endif worked fine, but the second one was all funny. In fact, if I deleted the second #endif, it still worked fine. Though GHCi did not like it then.
22:50:26 <stepcut> I think everything I try to use cpphs, something like this happens
22:51:00 <mmorrow> did the #endif that it left in have a matching #if*
22:51:18 <joed> _zenon_: Bujinkan turned into a very very said affair of money and I do not know what.
22:51:32 <stepcut> yes
22:51:34 <joed> _zenon_: Main reason I left.
22:51:56 <mmorrow> stepcut: ooh, crappy
22:52:08 <_zenon_> joed: I agree, I have a friend who still is in Bujinkan, he is instructor now, but he also agrees of the tragic state of affairs.
22:53:07 <mmorrow> i totally thought everyone was joking about the black belts
22:53:57 <joed> _zenon_: I see it as a cool thing, I can say I lived and practiced with Hatsumi and nagato et al for a while, I came home with all my money gone and went back to programming.
22:55:13 <_zenon_> mmorrow: No, a lot of americans (and others with no sense of budo) have bought their belts and stars, or in a way or another started fake schools and inclusively whined their way thru the ranks.
22:55:31 <_zenon_> joed: Saviour it.
22:56:28 <joed> _zenon_: I'd see it as no more of an acheivemnt than climbing a mountain, at that time a blackbelt took about 10 years.
22:56:32 <joed> :)
22:56:42 <mmorrow> _zenon_: interesting. i like this phrase "no sense of budo" because although i don't have any idea what it means, i know what it means
22:57:24 <stepcut> mmorrow: it appears to happen becase I did, #ifdef Thing, #include otherfile, #endif. And otherfile had an odd number of '
22:57:49 <_zenon_> mmorrow: Those who have no sense of budo, can't start to comprehend, they believe it's all a matter of your belt/stripes/whatnot. Every intellectual being of course realises the erroneous part in it.
22:58:13 <_zenon_> joed: Well, do some fancy ninja haskell then ;(
22:58:15 <_zenon_> ;)
22:58:15 * stepcut goes to eat delicious cake
22:58:37 <joed> mmorrow: Martial arts should be a very explorative excersise.
22:59:00 <joed> _zenon_: I wish, I timed out at billing 260 hours last month.
22:59:12 <mmorrow> stepcut: ah, those ' s are sly like foxes at night!@
22:59:39 <mmorrow> _zenon_: that can be applied to so many things in this world
22:59:48 <_zenon_> mmorrow: Including haskell :)
22:59:52 * joed nods....
23:00:14 <mmorrow> yes indeed
23:00:28 * _zenon_ throws a ninja function at joed          ninjaFun :: a -> ()
23:00:59 <_zenon_> ;) I _have_ to do these ninja jokes, always embarrase my friend with them :)
23:01:06 <vixey> O_o
23:01:09 <vixey> :t Data.List.sum
23:01:12 <lambdabot> forall a. (Num a) => [a] -> a
23:01:16 <vixey> why Data.List.sum exports sum .......................?
23:01:39 <joed> _zenon_: Who in Sweden? You are in Gothenburg? Larry?
23:02:26 <_zenon_> joed: Yes, I am in Gothenburg; his name is Mats Carlsson, he was over to Japan this year and completed the "saki"?  test.
23:02:52 <joed> Oh, Yeah, good for him, you mean the 5th dan?
23:03:05 <_zenon_> joed: Yes, I found this :::  Carlsson, Mats	5 Dan	2007	 Bujinkan Dojo Gteborg	Gteborg
23:03:10 <_zenon_> http://www.bujinkan.nu/index.php?cat_id=6
23:03:12 <lambdabot> Title: Bujinkan Sweden --- Bujinkan Sweden Shidoshi-kai
23:04:18 <joed> Yeah, have no idea, I think Honbu came after I left Sweden.
23:04:46 <_zenon_> the ninja monad!! Everything disappears in it :)         newtype NinjaM a = NinjaM ()
23:04:47 <joed> They also lack php skillz : http://www.bujinkan.nu/index.php?cat_id=6'
23:04:48 <lambdabot> Title: Bujinkan Sweden ---
23:05:06 <_zenon_> joed: Hehe, well, they are ninjas, not haXxors
23:05:19 <joed> What is the difference?
23:05:21 <_zenon_> sorry, let me rephrase that
23:05:33 <_zenon_> |-|/-\xXoRz
23:05:40 <joed> Hahah
23:05:53 <_zenon_> They are building their "buddha stomachs"
23:06:01 <_zenon_> To fill out the Gi properly
23:06:13 <_zenon_> :(
23:06:38 <mmorrow> hehe, SELECT * FROM bujinkan_main WHERE (cat_id = 6\') AND (sub_cat_id = 0) AND (firstpage = 'T') ORDER BY id DESC
23:06:57 <joed> Now now now...
23:07:44 <_zenon_> mmorrow: They will come to your home and ninja you :P
23:07:52 <_zenon_> flip out
23:10:19 <_zenon_> luckily, when can unflip them
23:10:25 <_zenon_> flip . flip
23:10:38 <_zenon_> then we lift them up into the air
23:10:41 <_zenon_> liftM
23:10:49 <_zenon_> and we return them to where they came from
23:10:50 <_zenon_> return
23:13:23 <joed> _zenon_: Unless you read chinese Mythology, Go rin no sho and can tune into shintoism, most of these things apart from 'Mommy it hurts' usually are lost on western minds.
23:14:43 <b\6> wonder what inspired them to name that host arkansas.
23:14:44 <_zenon_> joed: Of course, most western ar in it for the action, only. :/ Which is sad.
23:16:13 <joed> _zenon_: Which is really fun to watch : - Sensei - why do you water the plant? A: I'm here twice a week, my wife would kill me if all the plants die.
23:17:15 <_zenon_> joed: My friend told me that the old one also could get those "moments" where he pours salt into your tea, just to watch your reaction. ?
23:18:09 <joed> _zenon_: I never saw that, I saw him breaking the arm of a 'Karateka'
23:18:45 <joed> He said, punch as I say, otherwise break.
23:19:01 <joed> Then he said, oh, it broke.
23:20:13 <joed> I think those are pretty common things. He actually did succed.,
23:20:21 <joed> He has more students.
23:20:54 <_zenon_> joed: and he makes $$$$$$$
23:21:46 <joed> Yeah, and a very very old art survived. Who cares what S.K.H ever knew?
23:22:16 <joed> So he turned it into a museum.
23:23:02 <_zenon_> hehe
23:23:19 <joed> Anyways, I need some sleep, enjoy the swedish cold.
23:25:07 <_zenon_> joed: sleep well
23:45:48 <vixey> is there a common operator people use for zip ?
23:46:56 <roconnor> `zip`
23:47:29 <roconnor> you mean symbol?
23:47:35 <vixey> yes
23:47:36 <roconnor> unicode?
23:47:38 <dobblego> ||======================================|-----|
23:47:46 <dobblego> looks like a zip to me :)
23:47:50 <glguy> (,) <$>
23:48:14 <Beelsebob> lol dobblego -- I'm pretty tempted to use that one in my code now
23:48:20 <roconnor> what would Conor use?
23:48:44 <dobblego> some unicode character(s) in a research paper of course!
23:49:22 <glguy> > getZipList $ (,) <$> ZipList [1,2] <*> ZipList [3,4]
23:49:23 <lambdabot>  [(1,3),(2,4)]
23:49:27 <glguy> whee
23:50:47 <Beelsebob> o.O wow, overcomplicated way round or what?
23:52:13 <roconnor> I haven't found any Conor notation.
23:52:28 <vixey> then I will go without
23:53:53 <vixey> class Display a where display :: a -> String
23:53:53 <vixey> instance Display String where display = id
23:53:53 <vixey> instance Display Int where display = show
23:53:53 <vixey> x ^ y = display x ++ display y
23:54:02 <vixey> I am pretty keen on this thing
23:54:17 <vixey> for formatting stuff
