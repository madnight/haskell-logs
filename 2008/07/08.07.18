00:00:20 <vixey> hi
00:00:30 <vixey> what's going on ?
00:04:54 <^Someone^> vixey:  <vixey> is there a place to put haskell code?
00:04:55 <^Someone^> What?
00:05:15 <vixey> @w80 What
00:05:16 <lambdabot> No match for "What".
00:05:36 <^Someone^> Lol
00:06:00 <^Someone^> What were you asking?
00:06:07 <vixey> is there a place to put haskell code?
00:06:13 <^Someone^> Lol
00:06:22 <vixey> what?
00:06:32 <^Someone^> More context
00:06:51 <^Someone^> I mean, you can put Haskell code almost anywhere, but for what purpose do you mean?
00:07:12 <vixey> I have written this mini haskell langauge
00:07:25 <^Someone^> Oh : o
00:07:29 <vixey> in haskell
00:07:33 <vixey> A few people wanted to see it
00:07:44 <vixey> and it could be useful to... me a few years ago
00:08:07 <^Someone^> Ah
00:08:19 <^Someone^> Haskell Wiki? :D
00:08:34 <vixey> it's multiple files though
00:09:01 <quicksilver> hackage then?
00:10:46 <^Someone^> I mean couldn't you make an entry in HaskellWiki for it, like the lambdabot project?
00:10:54 <^Someone^> And upload the code in a repository somewhere and link it
00:11:21 <vixey> does hackage want toy implementations of languages?
00:12:25 <vixey> ^Someone^: I don't know where somewhere is
00:13:10 <^Someone^> Somewhere is where I live :D
00:13:27 <leadnose> lol
00:13:47 <vixey> ^Someone^: want to host a darcs repo for me :P
00:13:49 <vixey> ?
00:14:12 <^Someone^> If I could, I would do that, vixey, it seems interesting
00:15:24 <_zenon_> I'm getting a new server in a few days
00:15:31 * _zenon_ could maybe host some code
00:15:56 <_zenon_> Well, to be honest, it's a chicken from an old render-farm
00:16:04 <vixey> cool
00:16:12 <vixey> do you knowwhat it rendered?
00:16:48 <quicksilver> or you could get an account and a home page at community.haskell.org perhaps
00:17:07 <quicksilver> but perhaps code on the wiki is the simplest answer?
00:17:11 <vixey> I tried that but there is an error in the form
00:17:25 <_zenon_> vixey, It belonged to renderplanet, which was an online-rendering plugin to Maya
00:17:33 <Axman6> yay, "Data abstraction and problem solving in Java"
00:17:34 <vixey> oh
00:19:57 <Axman6> is it wrong that i don't actually hate java, after being taught haskell first? (both taught by a lecturer who loved haskell)
00:20:00 <Axman6> loves even
00:21:49 <_zenon_> Axman6, No. The more different ways you can reason about a problem. the better.
00:22:45 <chylli`> when I run cabal install regex-tdfa, I got error:Text/Regex/TDFA/RunMutState.hs:13:32: parse error on input `#'
00:23:07 <Axman6> i think that being taught how you can make java as much like haskell as possible helped a lot too
00:25:43 <_zenon_> But will it run efficiently?
00:28:26 <Pseudonym> quit
00:29:32 <DrSyzygy> DRMacIver: See my nick.
00:33:05 <Axman6> _zenon_: runs fairly effectively. my cellular automata program ran about as fast in java as haskell. the haskell made more sense to me though
00:34:20 <_zenon_> Axman6, I mean, simulating the behaviour of another paradigm with a language might lower the efficiency considerably.
00:34:41 <leadnose> what ways  do you use to make java programs more like haskell?
00:35:17 <Axman6> yeah, from what i've read, the way we emulated list recursion/map is one of the slowest ways to work with arrays in java (using a for-each loop)
00:35:34 <Axman6> leadnose: for-each loops mainly :P
00:35:55 <vixey> yeah for-each is not like hasklel
00:36:28 <Axman6> but it can be used sort of like f (x:xs) = ...; f [] = ...;
00:36:42 <leadnose> isn't it quite trivial to implement map and reduce in java? of course you have to use reflection to get the methods you pass to them but still
00:36:50 <Axman6> has sort of similar syntax, which confuses people, since it looks the same, but means something different
00:38:07 <lament> leadnose: but why on earth would you?
00:38:26 <leadnose> i did it just for the fun of it :P
00:38:31 <hoyret> pl \ xs f -> concat $ map f xs
00:38:36 <lament> Writing Haskell in Java is just as bad as writing Java in Haskell
00:38:53 <vixey> f =<< xs
00:38:53 <hoyret> >pl \ xs f -> concat $ map f xs
00:38:56 <vixey> (>>=)
00:39:12 <lament> (or "C in any language")
00:39:20 <hoyret> > pl \ xs f -> concat $ map f xs
00:39:21 <lambdabot>  Parse error at "\" (column 4)
00:39:28 <vixey> hoyret: (>>=)
00:39:31 <_zenon_> @pl \xs -> concat $map f xs
00:39:32 <lambdabot> (f =<<)
00:40:16 <_zenon_> Axioplase_, annyway, I guess it's fun trying to simulate different paradigms
00:40:29 <_zenon_> Axman6, annyway, I guess it's fun trying to simulate different paradigms
00:40:35 <_zenon_> Hehe, wrong there
00:40:35 <hoyret> ooh, a monad
00:44:16 <Cale> The list monad :)
00:50:56 <quicksilver> DrSyzygy: congrats :)
00:51:07 * quicksilver wonders if he should renick to DrQuicksilver
00:52:37 <DrSyzygy> quicksilver: I made a point of changing the nick immediately after my defense. I'll go  back to Syzygy in a while. :-)
00:53:07 <_zenon_> DrSyzygy,  congrats!
00:53:13 <DrSyzygy> Thanks
00:58:11 <_zenon_> DrSyzygy, where you nervous?
01:03:47 <vixey> @keal
01:03:49 <lambdabot> better be atleast 16x16 color with extended ascii set
01:03:57 <vixey> @keal
01:03:58 <lambdabot> i lack in verbal and social expression
01:24:02 <_zenon_> Somehow my xchat channel popped out of the window
01:24:20 <Cale> _zenon_: they do that :)
01:24:29 <dibblego> you hit Detach Tab (Alt+I)
01:25:00 <Cale> Alternately XChat -> Attach Window
01:26:56 <_zenon_> Hmm, I can't reproduce the problem with Alt+I
01:27:25 <dibblego> sorry, Ctrl+I
01:27:32 <_zenon_> jEPP
01:27:36 <_zenon_> That's it
01:27:41 <_zenon_> how do you merge them now? :)
01:27:50 <_zenon_> Ahhh
01:27:55 <_zenon_> repeat :)
01:28:21 <_zenon_> Hehe
01:28:23 <_zenon_> Got a bit carried away there
01:28:34 <_zenon_> I pressed Ctr + I several times,
01:28:43 <_zenon_> Had to analyze the behaviour
01:30:13 <_zenon_> Btw on a side note
01:30:27 * _zenon_ wonders if annyone knows how old Tuvok is?
01:51:46 <sjanssen> _zenon_: old enough to have served with Sulu
01:52:55 <_zenon_> sjanssen, which means? Hehe, I am not especially schooled on ST, but I do love the Voyager seasons :)
02:01:01 <BeelsebobWork_> @docs Array
02:01:02 <lambdabot> Array not available
02:01:07 <BeelsebobWork_> @docs Data.Array
02:01:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
02:07:00 <zx]treads> where can i find this paper from Peyton-Jones about STM in Haskell?
02:08:12 <Vq^> http://research.microsoft.com/Users/simonpj/papers/stm/index.htm
02:08:13 <lambdabot> Title: Papers on transactional memory
02:09:37 <zx]treads> ty
02:23:14 <_Dae_> is there a way to store datastructures in haskell? So I could save it on the disk and load it for later use?
02:23:22 <vixey> yes
02:23:31 <sjanssen> _Dae_: yes, see Show and Read
02:23:57 <Quadrescence> vixey: woah woah, I didn't even notice you were a math person too. D:
02:24:26 <_Dae_> sjanssen: right.... I was thinking more of a binary thing, but I suppose show and read will have to do
02:24:48 <quicksilver> there is also Data.Binary
02:25:00 <quicksilver> show/read is slightly simpler to use and easier to debug I guess :)
02:25:18 <sjanssen> _Dae_: Data.Binary can also work
02:25:36 <Quadrescence> quicksilver is the only word that rhymes with silver. D:
02:25:48 <sjanssen> Show/Read is automatic (therefore convenient), text based, and slightly slow
02:26:05 <sjanssen> Data.Binary is not automatic (less convenient), binary, and blazingly fast
02:26:48 <_Dae_> sjanssen: well, it wouldn't matter much really, I'm not gonna do it a lot, I just don't have read and show instances for all my data ;)
02:26:48 <quicksilver> Quadrescence: I wouldn't describe it as a rhyme personally.
02:27:04 <quicksilver> Quadrescence: it shares the last two syllables precisely :)
02:27:12 <Quadrescence> quicksilver: I wouldn't either.
02:27:21 <quicksilver> _Dae_: deriving (Read,Show) is not very hard to type :)
02:27:23 <Quadrescence> But hey, you seem smart if you say that.
02:27:30 <sjanssen> _Dae_: writing Read/Show instances should be simpler than writing Binary instances, I would assume
02:28:08 <_Dae_> quicksilver: is (Read.Show a == a) always true?
02:28:23 <_Dae_> or read.show a == a rather...
02:28:31 <vixey> hi conal
02:28:37 <sjanssen> _Dae_: nope (due to a technicality)
02:28:42 <conal> vixey: hi
02:28:46 <sjanssen> _Dae_: you mean read (show a) == a
02:28:46 <_zenon_> Quadrescence, I don't know if I would say that quicksilver `rhymes` with silver.
02:29:09 <quicksilver> _Dae_: if you use GHC derived instances it works nicely, yes.
02:29:17 <quicksilver> _Dae_: if you define your owen instances you can break it in arbitrary ways.
02:29:20 <_Dae_> sjanssen: heh, yes.... though I think you may have to tell me why my implementation didn't work?
02:29:40 <quicksilver> (read.show) a == a woudl have been fine
02:29:43 <_Dae_> quicksilver: Allright, well it shouldn't be a problem then.... it's mainly tuples of arrays
02:29:49 <quicksilver> but read.show a is read . (show a)
02:29:56 <quicksilver> which doesn't type check
02:30:00 <conal> or read.show == id
02:30:28 <Axman6> don't you have to tell read which type to read?
02:30:33 <conal> (where (==) is semantic/existential equality)
02:30:33 <_Dae_> ahh, right...
02:30:51 <quicksilver> Axman6: maybe, maybe not.
02:30:51 <Axman6> since 1 could be a float or an int no?
02:30:56 <quicksilver> Axman6: maybe the compiler can infer it.
02:30:58 <sjanssen> Axman6: that is inferred in this case
02:31:18 <sjanssen> @type read . show
02:31:24 <Axman6> so read would use the type of a ?
02:31:28 <lambdabot> forall a a1. (Show a1, Read a) => a1 -> a
02:31:40 <sjanssen> Axman6: yes, due to (==)
02:31:45 <quicksilver> Axman6: read will use the type inferred by the context around it, yes
02:31:45 <Axman6> ok
02:31:48 <quicksilver> in this case by the == a
02:31:56 <Axman6> thought so
02:33:00 <BeelsebobWork_> @hoogle (a->b,c ->d) -> (a,b) -> (c,d)
02:33:16 <lambdabot> thread killed
02:33:42 <mauke> BeelsebobWork_: impossible
02:33:52 <BeelsebobWork_> oh yeh
02:33:56 <BeelsebobWork_> I'm just being a morning moron
02:34:07 <mauke> :t uncurry (***)
02:34:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
02:34:25 <BeelsebobWork_> that works
02:34:56 <masak> mauke: why is BeelsebobWork_'s signature impossible?
02:35:17 <mauke> masak: where's the c in the result coming from?
02:35:33 <BeelsebobWork_> actually mauke I can think of a function with that type
02:35:55 <vixey> :t undefined :: (a->b,c ->d) -> (a,b) -> (c,d)
02:35:57 <lambdabot> forall a b c d. (a -> b, c -> d) -> (a, b) -> (c, d)
02:36:05 <masak> mauke: ah, c is on one end on the left side, and on the other on the right side
02:50:29 <bobobobo> http://tinyurl.com/ads912
02:50:31 <lambdabot> Title: Immoral Attack
02:50:45 <bobobobo> Curse you lambda, XD
02:50:57 <vixey> bobobobo: wrong channel
02:51:08 <bobobobo> right channel?
02:51:14 <mornfall> Left channel!
02:51:17 <mauke> sigh. spam.
02:51:55 <mornfall> mauke: There are worse kinds, mind you.
02:52:11 <bobobobo> I am nice, I just paste one thing, then I am rather done.
02:52:18 <vixey> bobobobo: wrong channel
02:52:24 <mornfall> Eh.
02:52:27 <mornfall> Okey, that was silly.
02:52:49 <mornfall> I think it's not written in Haskell. Bummer.
02:52:51 <quicksilver> people are silly.
02:56:44 <_zenon_> I have grown more and more fond of fixpoint
02:56:58 <_zenon_> It's even usefull IRL
02:57:19 <_zenon_> Eg:   "And now stirr the tea until fixpoint"
02:58:45 <roconnor> @src putStr
02:58:46 <lambdabot> putStr s  = hPutStr stdout s
02:58:51 <roconnor> @src hPutStr
02:58:52 <lambdabot> Source not found. Maybe you made a typo?
03:09:45 <roconnor> I've made a wiki page for IO semantics: http://haskell.org/haskellwiki/IO_Semantics
03:09:46 <lambdabot> Title: IO Semantics - HaskellWiki
03:09:57 <roconnor> feel free to edit it to improve it.
03:11:15 <Quadrescence> Ugh, <immature> my client had to linewrap at an inappropriate time: /haskellwiki/IO_Seman </immature>
03:11:19 <Quadrescence> :)
03:11:49 <roconnor> :)
03:13:52 * _zenon_ goes for lunch
03:21:03 <vixey> who can make hackage accounts
03:21:13 <matthew-_> Ross Pattinson
03:21:26 <mauke> er
03:21:44 <matthew-_> *Patterson
03:21:50 <matthew-_> sorry, cricket on the brain
03:26:46 <Asgaroth> is there already a combination of take and drop to defined to get a substring-like function or do I have to define one myself?
03:27:05 <roconnor> I've always defined it myself
03:28:01 <_zenon_> Maybe should be implemented
03:29:50 <hml> anyone know of a x86_64 assemlber written in haskell?
03:32:57 <chylli`> how to get code of one character ?
03:33:10 <vixey> Data.Char.ord
03:33:11 <mauke> @hoogle Char -> Int
03:33:12 <lambdabot> Data.Char.digitToInt :: Char -> Int
03:33:12 <lambdabot> Data.Char.ord :: Char -> Int
03:33:12 <lambdabot> Data.ByteString.Char8.count :: Char -> ByteString -> Int
03:33:18 <chylli`> thanks
03:35:59 <Asgaroth> Why does my hoogle output lots of functions with the wrong type if I do a 'hoogle "Char -> Int"'
03:37:03 <mauke> heh, it finds unsafeCoerce
03:38:49 <chylli`> where can I report a bug about package irc ?
03:38:59 <hml> http://www.haskell.org/onlinereport/array.html ; from this; i can't tell ... does array havbe constant time random access?
03:39:00 <lambdabot> Title: The Haskell 98 Library Report: Arrays
03:42:18 <chylli`> hi, I want to report a bug about Network.IRC, where should I go ?
03:46:45 <byorgey> chylli`: who is listed as the maintainer?
03:49:02 <byorgey> chylli`: the maintainer is listed here, I suggest you email him: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/irc
03:49:06 <lambdabot> Title: HackageDB: irc-0.4.3
03:59:43 <Quadrescence> Okay, the coast is clear... Two bytes are talking to each other. One says to the other, "I think I have a parity error," to which the other byte responds, "Yeah, you do look a bit off."
04:05:00 <quicksilver> *rimshot*
04:05:37 * _Dae_ has a terrible sense of humour, and laugs out loud
04:05:53 <Quadrescence> :D
04:07:16 <olsner> @quote parity
04:07:17 <lambdabot> No quotes match. Where did you learn to type?
04:07:22 <mapreduce> quicksilver: That word doesn't mean what you think it means.
04:07:42 <_Dae_> on a more lambdarific note: any way to make ghc dump some relevant data when you get a segmentation fault? I'm running a randomized algortihm, and I get a segmentation fault like once in every 5 runs... problem is it takes an hour or so to complete, so...
04:07:59 <olsner> @remember Quadrescence Two bytes are talking to each other. One says to the other, "I think I have a parity error," to which the other byte responds, "Yeah, you do look a bit off."
04:08:00 <lambdabot> Good to know.
04:08:12 <olsner> awesome pun :D
04:08:31 <olsner> and I'm not even being sarcastic
04:09:14 <_Dae_> Only on IRC :p
04:10:04 <quicksilver> mapreduce: eh?
04:10:33 <quicksilver> mapreduce: it's a widely accepted slight miscoin, yes.
04:10:36 <quicksilver> I don't think that matters.
04:10:41 <quicksilver> language evolves.
04:11:35 <quicksilver> _Dae_: well since GHC is supposed to never segfault :P
04:11:37 <osfameron> which word? rimshot?
04:12:06 <_Dae_> from which we can deduce that language is not static, and thus must be lzayly evaluated
04:12:06 <olsner> _Dae_: got any unsafePerformIO's or unsafeCoerce's or other dangerous hacks?
04:12:15 <quicksilver> _Dae_: however, you can do what you would do in any other language: load a core into gdb and look at the stack trace
04:12:25 <olsner> static != not lazily evaluated
04:12:57 <_Dae_> olsner: I have an unsafeFreeze somewhere, but I got the error before that...
04:13:08 <_Dae_> as in, before I put in the unsafeFreeze
04:13:53 <_Dae_> quicksilver: main experience is debugging in windows, where the lovely "debug" button just jumps up and helps you ;)
04:15:02 <quicksilver> well a segfault is never a bug in haskell code
04:15:12 <quicksilver> it's either a bug in non-haskell code you're calling directly or indirectly
04:15:15 <quicksilver> or it's a bug in GHC
04:15:44 <olsner> well, as mentioned, you could try running it through gdb - it'll break when the program segfaults allowing you to investigate the current state at that point
04:16:35 <_Dae_> quicksilver: well, I'm not calling FFI, and the only library I'm uisng is stream-fusion, which I think is pure haskell
04:17:46 <quicksilver> stream-fusion is far from pure haskell
04:17:52 <quicksilver> it's haskell + RULES
04:17:56 <pastorn> haha
04:18:05 <pastorn> OH NOES
04:18:10 <quicksilver> however I don't *think* RULES should be able to cause segfaults?
04:18:13 <olsner> rules allow breaking the type system?
04:18:24 <quicksilver> they can cause pretty arbitrary rewrites
04:18:30 <quicksilver> but I wouldn't have thought segfaults?
04:18:31 <quicksilver> not sure though.
04:19:19 <Baughn> _Dae_: Try compiling with -dcore-lint, just in case?
04:19:30 <_Dae_> Isn't rules just rewriting haskell code to other haskell code? I thought it still had to follow all the normal rules?
04:20:25 <_Dae_> Baughn:  what does it do?
04:20:28 <dcoutts> right, rules have to be type correct
04:20:39 <dcoutts> they do not necessarily preserve meaning of course
04:21:44 <_Dae_> Baughn: nm, found it
04:22:21 <Baughn> _Dae_: Extra sanity checks.
04:22:25 <_Dae_> dcoutts: Right, but if haskell without unsafe can't make a seqfault, then haskell + rules couldn't either, right?
04:22:46 <dcoutts> _Dae_: right
04:23:14 <dcoutts> _Dae_: however if one rewrites to incorrect unsafe stuff then...
04:23:17 <Baughn> _Dae_: In theory. There have been bugs.
04:23:40 <Baughn> For that matter, just plain old haskell with no rules /or/ unsafe can /still/ segfault
04:23:51 <quicksilver> Baughn: can it?
04:23:54 <olsner> whut, how?
04:24:01 <dcoutts> only if there are bugs in the compiler/rts
04:24:06 <Baughn> Bugs, as I said
04:24:15 <quicksilver> but, criticially, not bugs in the user's code
04:24:17 <quicksilver> bugs in GHC
04:24:18 <dcoutts> the point is, it's never your fault
04:24:20 <quicksilver> (which was my point)
04:24:21 <jaj> talking about segfaults... http://hpaste.org/9003 I can reproduce this 100%, I don't know why it does that however
04:24:26 <Baughn> Right, which half the time get caught with -dcore-lint
04:24:29 <Baughn> Which was /my/ point
04:24:31 <olsner> ah, yes, bugs... haskell has those? :P
04:24:44 <_Dae_> Baughn: exactly.... figured I would try and find the bug, and help the ghc guys :)
04:25:46 <_Dae_> olsner: I think someone is working on a library to eliminate all bugs in all haskell code. Supposed to be an advanced form of quicksilver
04:26:27 * olsner does cabal install bugfixes
04:26:45 <olsner> ah well, seems it's not on hackage yet...
04:26:45 <dcoutts> olsner: you're hacking on cabal-install?
04:26:53 <dcoutts> oh, I see
04:27:04 <olsner> dcoutts: I made a funny
04:27:20 * dcoutts was hoping olsner was fixing bugs in cabal-install, which would be most welcome
04:27:35 <_Dae_> jaj: you're running a fairly old version of ghci. Updating might help?
04:27:37 <quicksilver> jokes? in #haskell? preposterous! inconthievable!
04:28:02 <olsner> @faq can Haskell make jokes?
04:28:03 <lambdabot> The answer is: Yes! Haskell can do that.
04:28:32 <O_4> Heh
04:28:41 <_Dae_> Lambdabot is pretty good at jokes....
04:29:04 <Baughn> @faq Can haskell compile a program so complex it can't compile it?
04:29:04 <jaj> _Dae_: I'd love to update but unfortunately that's the current version in the openbsd ports
04:29:04 <lambdabot> The answer is: Yes! Haskell can do that.
04:29:20 <olsner> someone should rewrite @faq with an english parser so that it rewrites your question into the corresponding affirmative statement
04:29:32 <Baughn> olsner: "English parser"?
04:29:32 <_Dae_> jaj: ohh...
04:29:34 <Baughn> You mean AI?
04:30:16 <O_4> Well, Haskell can do that, right?
04:30:26 <Baughn> Well, sure. Haskell can.
04:30:31 <Baughn> The *programmer*, not so much
04:30:35 <olsner> hmm, maybe just let it handle questions like "can haskell X?" and rewrite into "yes! haskell can X."
04:30:42 <_Dae_> Baughn: is it proven that you need AI for that? I thought it was just too complex for anyone to actually have -done- it?
04:31:06 <b\6> english is ambiguous.
04:31:15 <b\6> time flies like an arrow, etc.
04:31:15 <_Dae_> lies
04:31:22 <quicksilver> jaj: I think it's a 64bit problem.
04:31:36 <Baughn> _Dae_: You need at least half an AI -  common sense, qnd a huge amount of experience with the language
04:31:36 <quicksilver> jaj: there certasinly have been problems with 64bit BSD and ghc.
04:31:48 <quicksilver> b\6: fruit flies like a banana!
04:32:04 <_Dae_> Baughn: huge amount of experience -> let it parse the internet :p
04:32:29 <O_4> _Dae_: I think that would only succeed in teaching it nonsens
04:33:00 <Baughn> _Dae_: You still need to bootstrap it
04:33:03 <_Dae_> common sense -> if it ain't on 4chan......
04:33:03 <olsner> the key is to limit the range of sentences and topics of discourse you want to handle
04:33:16 <jaj> quicksilver: it used to work for me but some more or less recent change broke it. I'll take a look at compiling 6.8
04:33:33 <olsner> it wouldn't be inconcievable to build @faq to work fine for those kinds of jokes we usually feed it
04:34:20 <olsner> i.e. parsing most of the set of puns about solving the halting problem should be tractable
04:34:49 <_Dae_> olsner: parsing grammar is at least doable.  A computer scientist I know is writing his thesis on that subject.....
04:34:56 <olsner> "most"? well, a subset :P
04:35:34 <byorgey> "can haskell X a Y so Z it can't X it?" -> "don't be daft! of course it can't."
04:36:26 <vixey> hi
04:36:43 <RayNbow> @faq Are pepperoni-lambdas more delicious than ordinary lambdas?
04:36:44 <lambdabot> The answer is: Yes! Haskell can do that.
04:36:56 <Asgaroth> I'm trying to import a package, but GHC says that the package is 'hidden', how do I import it anyway?
04:37:01 <olsner> "can haskell solve the halting problem?" -> "Not yet, but X is working on a library/type system extension that does it.", X `elem` nicks in #haskell
04:37:01 <_zenon_> _Dae_  : Harald HammarskjÃ¶ld is working on a way to automatically extract a grammar from a language.
04:37:21 <vixey> what am I meant to do now?
04:37:33 <olsner> vixey: good question!
04:37:57 <_zenon_> _Dae_, hammarstrÃ¶m
04:38:05 <O_4> vixey: what would you *like* to do now?
04:38:13 <quicksilver> Asgaroth: meta-Q why do you want to important a hidden package? normally you don't...
04:38:29 <quicksilver> Asgaroth: are you for example compiling from cabal?
04:38:35 <Asgaroth> quicksilver: I'm writing a plugin for xmobar, which need some stuff from Xmonad
04:38:46 <Asgaroth> *needs
04:39:00 <quicksilver> ghc -package foo
04:39:05 <quicksilver> I think.
04:39:19 <Asgaroth> quicksilver: thanks, I'll give it a try
04:39:50 <_Dae_> _zenon_: think I've heard of his supervisor... but it's pretty far from my own field, so I haven't heard of him ;)
04:40:01 <_zenon_> _Dae_, http://www.cs.chalmers.se/~harald2/
04:40:04 <lambdabot> Title: Homepage of Harald Hammarström
04:40:19 <Asgaroth> quicksilver: Or is there already a function which captures the output of a program?
04:40:21 <_Dae_> _zenon_: Already there :p
04:40:29 <Asgaroth> s/program/command/
04:40:53 <_zenon_> _Dae_, I had it since 30 minutes ago :P   no, I didn't,        or did I?
04:41:02 <quicksilver> the stuff in System.Process, Asgaroth
04:41:08 <quicksilver> but it all reaturns handles not strings.
04:41:10 <_zenon_> _Dae_, regretfully, he is a pythoner
04:41:22 <quicksilver> JaffaCake is working on a new Api which will have the string option.
04:43:34 <_Dae_> _zenon_: We must pray that he will soon discover the light that is haskell, and repent from the vile serpent
04:43:50 <vixey> O_4: I don't know
04:44:28 <_zenon_> _Dae_, Yes brother _Dae_, let us pray for his soul. It is yet not too late.
04:45:23 <_Dae_> _zenon_: I shall light a lambda-shaped candle for him this eve....
04:45:55 <_zenon_> _Dae_, hahaha :)
04:46:06 <WeDneS> (:
04:46:53 * RayNbow actually needs to improve his Python skills for a project...
04:47:06 <RayNbow> I doubt I can convince them to rewrite everything to Haskell :p
04:47:09 <johnnowak> forget that; improve our project instead
04:47:15 <johnnowak> our.. er.. your.
04:48:09 <_Dae_> RayNbow: write a Python2Haskell parser in haskell.... much easier
04:48:20 <_Dae_> or cleaner at least......
04:48:22 <olsner> or a haskell-to-python compiler
04:49:23 <_zenon_> A python -> lambda -> haskell
04:49:25 <_Dae_> olsner: Heathen!
04:51:15 <_Dae_> _zenon_: we might actually need an AI for that....
04:51:33 <_zenon_> _Dae_, to convert Harald?
04:52:00 <MyCatVerbs> _Dae_: nonsense. Now, python -> lambada -> Haskell, on the other hand...
04:52:15 <vixey> hey verbs
04:52:34 <vixey> @w80 lambada
04:52:35 <lambdabot> No match for "lambada".
04:52:39 <MyCatVerbs> (Would merely take a very clever Shi-Tomasi tracker+Kalman filter and a pile of cameras to decode the dance moves back into combinators.)
04:52:39 <olsner> python seems built by people who started out as imperative programmers, read about smalltalk, then found lisp and thought they had found enlightenment (but missed the fact that functional programming has evolved since the 50's) ... so python is lisp+self/smalltalk/javascript and a new syntax
04:52:48 <MyCatVerbs> vixey: 'lo there. How's you?
04:53:00 * RayNbow does a wordcount...
04:53:11 <vixey> :[
04:53:25 <RayNbow> .py files: 88 KLOC
04:53:38 <MyCatVerbs> vixey: Bummer. Hope things get better soon, aye?
04:54:02 <vixey> I'm trying to think of something worthwhile to do
04:54:06 <RayNbow> _Dae_: has no one else written a py2hs before?
04:54:11 <_zenon_> olsner, there there.... nothing bad about lisp
04:54:13 <_Dae_> _zenon_:  yes... and possible take over the world
04:54:30 <_Dae_> RayNbow: Well, I'm not sure, but I don't think so...
04:54:36 <Peaker> olsner: Python mixes and matches nice features from various languages..
04:54:38 <Philippa> olsner: there's very little lisp in python, it's pretty much a few bolted-on bits and pieces
04:54:41 <vixey> hello sbahra
04:55:10 <Philippa> which is part of the problem, once you look at anything deep it's a cargo cult "nice language"
04:55:20 <sbahra> Hey vixey ;]
04:55:26 <sbahra> and Peaker
04:55:32 <Peaker> hey sbahra
04:56:27 <_zenon_> hey Speaker
04:56:30 <_zenon_> hey vixey
04:56:43 <_Dae_> RayNbow: actually... http://www.ohloh.net/projects/missingpy
04:56:45 <lambdabot> Title: MissingPy - Ohloh
04:57:10 <_Dae_> or rather http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MissingPy
04:57:16 <lambdabot> Title: HackageDB: MissingPy-0.10.0, http://tinyurl.com/58bhds
04:59:03 <vixey> hmmm
04:59:07 <RayNbow> btw, http://www.reddit.com/info/6sdot/comments/ <-- the project I need Python for :p
04:59:07 <lambdabot> Title: reddit.com: Major EU P2P research project hopes to kill traditional TV
04:59:21 <_zenon_> _Dae_, Great times!
04:59:41 <_zenon_> _Dae_, I talked to Harald and this is what he said
04:59:47 <_zenon_> _Dae_, "Hehe! Man kanske borde sluta med python Ã¤ndÃ¥ :-9"
05:00:30 <_Dae_> _zenon_: "borde"?  I get the rest
05:00:34 <vixey> what's everyone coding ?
05:01:17 * _Dae_ is implementing the stochastic variational method for quantum mechanical systems using spherical gaussians...........
05:01:31 <Baughn> _Dae_: "One should perhaps stop using python already"
05:01:49 <_Dae_> :D
05:01:55 <_zenon_> :)
05:02:15 <_Dae_> Another glorious victory for the heralds of lambda
05:03:05 <olsner> hmm... weird... someone says something in swedish and you don't get "wth, what language was that?" but "oh, I missed one of the words there"
05:03:25 <Baughn> Perhaps he's danish
05:03:39 <b\6> i ate a danish one time.
05:03:57 <Baughn> ..well, that's not very nice of you
05:05:00 <olsner> danishes probably aren't sentient... a dane otoh would probably be quite angry if you attempted to eat one :P
05:05:14 <schme_> None of the danes I've eaten have complained.
05:05:22 <_zenon_> _Dae_, let us relish the moment by a reciting of ye ancient lambda scrolls
05:05:38 <Baughn> Oh father, thou who art in eta..
05:05:55 <_Dae_> I will complain if you eat me.... and give you cancer....
05:06:05 <_zenon_> may your free variables stay unbound
05:06:40 <Baughn> May your heap space be infinite
05:06:52 <schme_> :( It's not.
05:07:08 <_zenon_> beta-reduce the enemies of your lambas,
05:07:23 <_zenon_> lambdas*
05:08:09 <_zenon_> the fixpoint combinator in all eternity. amen.
05:09:33 <RayNbow> _zenon_, are the ancient lambda scrolls on the Haskell wiki?
05:09:38 <Baughn> The C prayer made more sense. At least there there's something to ask delivery from. :/
05:09:39 <schme_> Anyway, I have some data in a file. What do I look for to get some smooth parsing action going?
05:09:54 <Baughn> Parsec? Polyparse? splitBy?
05:10:06 <_zenon_> RayNbow, now, it's just here. in this moment
05:10:10 <schme_> I'll look up parsec.
05:10:13 <_zenon_> maybe we should add an entry?
05:10:19 <schme_> splitBy seems complicated.
05:10:34 <_Dae_> schme_: how about "words" ?
05:10:41 <Peaker> would it make sense to say the difference between a "value" and an "object" -- is that an object has identity and in-place changes?
05:10:46 * vixey waits on email
05:11:05 <RayNbow> _zenon_: please do
05:11:07 * Peaker wonders about terminology for some funny code
05:11:08 <_zenon_> Baughn, yes, we will have to make it better
05:11:22 <schme_> _Dae_: I'm not sure that will work out so well :S
05:11:27 <Baughn> Peaker: Nope.
05:11:29 <vixey> Peaker: that's sensibe
05:11:32 <_Dae_> schme_: Ohh?
05:11:34 <vixey> sensible
05:13:00 <schme_> _Dae_: Nope. They're in (foo "fofofo" "fofofofo") and (foo 1332 bar 232 g)  format
05:13:02 <Peaker> Baughn: why not?
05:13:19 <_zenon_> Which verse should be the base for the Haskell prayer?
05:13:21 <_Dae_> schme_: Ahh, right
05:13:30 <quicksilver> Peaker: that's certainly one meaning of object, yes.
05:13:42 <quicksilver> Peaker: one of the confusions is that different people mean different things by 'object'
05:13:44 <Baughn> Peaker: That would imply that haskell has no objects, a concept I have issues with
05:13:56 <Peaker> Baughn: IORefs?
05:14:03 <schme_> and (foo (foo . "12.23") foo 123 foo) too.
05:14:06 <Baughn> Peaker: Never had to use one yet
05:14:21 <Peaker> Baughn: MVars?
05:14:32 <Baughn> Peaker: Communication channels only
05:14:46 <Peaker> Baughn: or objects can be implemented as infinite lists (the list values are the "revisions" of the object)
05:14:51 <Baughn> I use them to pass around orders, not to mutate data
05:15:06 <Baughn> Peaker: That's an.. interesting viewpoint
05:15:07 <quicksilver> but MVars *are* identities of mutable boxes.
05:15:14 <quicksilver> so you can use them for that if you want.
05:15:23 <Baughn> Peaker: It would imply each object only has one future revision, though
05:15:32 <Baughn> Sure. I /could/. ;;)
05:19:02 <roconnor> wtf?
05:19:11 <roconnor> Maybe is not a commutative monad is it?
05:19:44 <Baughn> Sure it is. If /anything/ returns Nothing, the result is Nothing
05:19:50 <roconnor> hmm
05:19:55 <roconnor> wow
05:19:56 <roconnor> it is
05:20:03 <Baughn> Unless you start doing side-channel attacks, I guess
05:20:03 <roconnor> crazy
05:20:26 <roconnor> `mplus` is not commutative... but I guess that has nothing to do with Maybe as a Monad.
05:20:26 <Peaker> side channel attacks?
05:20:33 <roconnor> crazy
05:20:47 <Baughn> Peaker: Figuring out details of a system based on information the designer never expected you to use
05:20:47 <quicksilver> well the only effect maybe has is possibly terminating early.
05:20:55 <quicksilver> and possibly terminating early commutes :)
05:21:11 <Baughn> Peaker: Like cracking RSA keys by measuring the exact power usage of the machine using it
05:21:14 <quicksilver> you could view it as multiplication with Just = 1 and Nothing = 0
05:21:20 <Peaker> (Just a >> Just b) != (Just b >> Just a) ?
05:21:23 <quicksilver> 1*1*0*1*1 = 0*1*1*1*1
05:21:32 <quicksilver> Peaker: that's not what commutative means
05:21:39 <roconnor> > do {x <- Nothing; y <- undefined; return (x,y)}
05:21:40 <Baughn> Peaker: Or, worse, the timing of context switches in software. Which is, oddly enough, possible  - there have been a few demonstrated attacks
05:21:52 <lambdabot>  Nothing
05:22:01 <roconnor> > do {y <- undefined; x <- Nothing; return (x,y)}
05:22:02 <lambdabot>  Exception: Prelude.undefined
05:22:08 <Peaker> Baughn: ah
05:22:08 <roconnor> that is a side channel attack
05:22:10 <quicksilver> (that couldn't work for any monad, return a >> return b is never the same as return b >> return a
05:22:11 <Baughn> roconnor: That doesn't count! -_-
05:22:17 <roconnor> Baughn: I agree
05:22:30 <roconnor> Baughn: I consider it a side channel attack :)
05:22:42 <RayNbow> bottoms are evil :p
05:22:44 <_zenon_> On a side note
05:22:57 <_zenon_> Do we note have a HaskellWiki tracker ?
05:23:01 <roconnor> Peaker: http://haskell.org/haskellwiki/Monad#Commutative_monads
05:23:02 <lambdabot> Title: Monad - HaskellWiki
05:23:05 <RayNbow> yet everyone has a bottom... thus, humans are evil?
05:24:04 <Baughn> roconnor: Being commutative kinda removes the /point/ of being a monad, but.. any other examples than those two?
05:24:26 <_Dae_> RayNbow: Haskell was originally made by Nietzsche, thus it is beyond good and evil.....
05:24:26 <Peaker> Twisted's Deferred is almost a monad, but since it is changed in-place, and does not separate the deferred/action from the actual running of the computation, I guess it isn't
05:24:36 <Peaker> (Just referring to its listing on that page)
05:25:13 <Baughn> > (do a <- [1..3]; b <- [4..6]; return (a,b), do b <- [4..6]; a <- [1..3]; return (a,b))
05:25:18 <lambdabot>  ([(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)],[(1,4),(2,4),(3,4),...
05:26:07 <roconnor> Baughn: MonadRandom ... assuming reasonable semantics of random numbers
05:26:27 <vixey> > do a <- words "heads tails" ; b <- [1..6] ; return (a,b)
05:26:29 <lambdabot>  [("heads",1),("heads",2),("heads",3),("heads",4),("heads",5),("heads",6),("t...
05:27:25 <quicksilver> Baughn: reader, random, supply, list
05:27:36 <roconnor> quicksilver: list isn't commutative
05:27:39 <quicksilver> are all commutative 'up to some interpretation of their effects'
05:27:49 <quicksilver> roconnor: it is 'up to ordering'
05:27:49 <roconnor> although set is commutative
05:27:57 <quicksilver> and if you view the list monad as a model for sets of results
05:28:03 <quicksilver> then it's sensibly commutative.
05:28:16 <quicksilver> random isn't technically commutative with any concrete PRNG either.
05:28:21 <quicksilver> it's the same thing
05:28:29 <quicksilver> commutative up-to-what-I-care-about
05:28:43 <roconnor> quicksilver: some people care about the order of elements in lists
05:28:47 <quicksilver> indeed
05:28:53 <quicksilver> then they're not using the list monad in a commutative way
05:28:54 <quicksilver> which is fine :)
05:28:59 <roconnor> very few people care about the order that data is retrieved from a PRNG
05:29:23 <quicksilver> I find very few people care about the order of the lists produced by the list monad.
05:29:27 <Cale> Unless that order is malicious :)
05:29:29 * quicksilver shrugs
05:29:47 <quicksilver> supply isn't really commutative in that you get different concrete numbers
05:29:49 * roconnor has used sortBy when working with the list monad
05:30:00 <Cale> Like, for example, chop the results from the PNRG into chunks of size 100 and sort each of them ;)
05:30:03 <quicksilver> but it's commutative enough in the sense that all you should care about is the supply is unique.
05:30:09 <roconnor> Granted I considered sortBy the identity function from my semenatical point of view :)
05:30:10 <_zenon_> Baughn, RayNbow , _Dae_  http://haskell.org/haskellwiki/Scrolls_of_lambda
05:30:11 <lambdabot> Title: Scrolls of lambda - HaskellWiki
05:30:13 <vixey> if you are dealing with infinities, it matters a great deal
05:30:13 <RayNbow> <quicksilver> random isn't technically commutative with any concrete PRNG either. <-- http://xkcd.com/221/ ? :p
05:30:14 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
05:30:14 <_zenon_> At least it's a start
05:30:26 <quicksilver> RayNbow: ah, true. It's commutative with that one :)
05:30:50 <_zenon_> RayNbow, haha, funny :)
05:31:01 <_Dae_> _zenon_: The warrior prayer is great :D
05:33:31 <_Dae_> RayNbow: heh, I think that one is older than xkcd. Thought it was originally written by a freshman in the early 90's?
05:34:18 <RayNbow> _Dae_: that's possible
05:34:34 <RayNbow> I've seen several comics using a similar random number joke
05:35:05 <roconnor> quicksilver: is a random number generated with bits generated from a nuclear decay considered commutative?
05:35:12 <roconnor> *generator
05:35:33 <Baughn> roconnor: That wouldn't be pure
05:35:41 <roconnor> Baughn: is IO pure?
05:36:02 <Baughn> roconnor: Not so much. And once you turn it into a list of random numbers, it'll be just as non-commutative as any other list
05:36:17 <quicksilver> roconnor: when calculating commutativity for monads which dont' have pure haskell representations
05:36:26 <quicksilver> roconnor: you need to decide what equivalence you're choosing
05:36:31 <quicksilver> bisimulation, for IO, perhaps.
05:36:47 <quicksilver> so the answer is "given a probabilistic definition of equivalent, yes"
05:37:10 <quicksilver> even when you *do* have pure haskell representations I personally argue it's appropriate to decide on an equivalence.
05:37:58 <Baughn> Sure. Is it still equivalent if changing the rder of execution leads to a program taking a hudnred years to complete?
05:39:42 <lilachaze> Baughn: execution time isn't really part of the semantics of haskell anyway :)
05:39:59 <quicksilver> Baughn: definitely.
05:40:46 <lilachaze> however, if reordering changes it between termination and non-termination, that's non-equivalent. do x <- [1,2]; y <- [1..]; guard (x == 2); return y
05:41:04 <Dr_Zooix> Hello all :)
05:41:08 <quicksilver> indeed. but infinite lists "break" the list monad
05:41:10 <schme_> @src Dr_Zooix
05:41:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:41:22 <quicksilver> most reasoning about monads is in the domain of total computation
05:41:45 <quicksilver> if it happens that something which works in the total framework extends neatly to infinte lists that's a bonus but not guaranteed ;)
05:43:05 <Dr_Zooix> I've a little question: I want to import only the !, loopkup and size functions from Data.Map but this: import Data.Map (!) doesn't work. Does someone have an idea ?
05:43:38 <quicksilver> import Data.Map ((!))
05:44:16 <lilachaze> quicksilver: fair enough. i'd say a reasonable definition of commutative should include (&&), so it makes sense to restrict to total computations.
05:44:58 <quicksilver> (&&) isn't a monad ?
05:45:00 <lilachaze> actually, it seems like two separate definitions would be in order
05:45:37 <Dr_Zooix> Ok thanks, but I don't understand why this http://rafb.net/p/D3QfXv65.html is making errors !
05:45:38 <lambdabot> Title: Nopaste - No description
05:45:48 <lilachaze> i'm assuming our definition of a commutative monad is roughly one with a commutative (>>)
05:46:06 <lilachaze> ish
05:46:24 <_Dae_> Dr_Zooix: www.hpaste.org
05:47:17 <_Dae_> makes it much easier to read :)
05:47:40 <Dr_Zooix> Ok :) Here is it
05:47:42 <Dr_Zooix> module Collection where
05:47:42 <Dr_Zooix> import Data.Map (lookup, (!), insert, size)
05:47:42 <Dr_Zooix> -- Algorithme qui va tier les élements dans l'ordre croissant.
05:47:42 <Dr_Zooix> my_sort [] = []
05:47:42 <Dr_Zooix> my_sort (x:xs) = my_sort (filter (<x) xs) ++
05:47:43 <Dr_Zooix>                  [x] ++
05:47:45 <Dr_Zooix> 				 my_sort (filter (>=x) xs)
05:47:47 <Dr_Zooix> -- Algotithme de compression de	chaînes. 			
05:47:49 <Dr_Zooix> zwLike::String->String->Map String Int->[Int]
05:47:50 <_Dae_> no!
05:47:51 <Dr_Zooix> lzwLike []  []      _     = []
05:47:53 <roconnor> @src parition
05:47:53 <Dr_Zooix> -- Si le buffer est vide, on charge un caractere et on reprend la compression.
05:47:53 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:47:55 <Dr_Zooix> lzwLike []  (hd:tl) dico = lzwLike [hd] tl dico
05:47:58 <roconnor> @src partition
05:47:59 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
05:47:59 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
05:47:59 <lambdabot>                               | otherwise = (ts, x:fs)
05:47:59 <Dr_Zooix> -- Si le contenu du buffer est dans le dico, on charge 1 caractère de plus dans
05:48:01 <Dr_Zooix> -- le buffer et on continue. Sinon, on sort le code dico du début du buffer et
05:48:03 <Dr_Zooix> -- on ajoute le buffer au dico.
05:48:05 <Dr_Zooix> lzwLike mot (hd:tl) dico = case Data.Map.lookup mot dico of
05:48:07 <Dr_Zooix>         Just x  -> lzwLike (hd:mot) tl dico
05:48:08 <_zenon_> Stop!!
05:48:09 <Dr_Zooix>         Nothing -> dico ! (tail mot) :  lzwLike [head mot] (hd:tl) nouvoDico
05:48:10 <Zao> Yay, moonspeak comments too.
05:48:11 <Dr_Zooix>     where nouvoDico = insert mot (size dico + 1)  dico
05:48:13 <Dr_Zooix> -- S'il ne reste plus rien après le buffer, on compresse ce dernier cara par
05:48:15 <_Dae_> Dr_Zooix: don't paste code directly into #haskell
05:48:15 <Dr_Zooix> -- cara. Ne devrait pas arriver, mais on sait jamais.
05:48:16 <Zao> _zenon_: Too late, his client is at it.
05:48:17 <Dr_Zooix> lzwLike mot []      dico = case Data.Map.lookup mot dico of
05:48:19 <Dr_Zooix>                               Just x -> [x]
05:48:21 <Dr_Zooix>                               Nothing -> dico ! [head mot] : lzwLike (tail mot) [] dico		
05:48:23 <Dr_Zooix> Oups sorry
05:48:25 <Dr_Zooix> http://hpaste.org/9004
05:48:43 <Dr_Zooix> _Dae_: Yeah I'm really sorry. I've paste it here: http://hpaste.org/9004
05:48:52 <vixey> don't worry
05:48:55 <roconnor> lilachaze: http://haskell.org/haskellwiki/Monad#Commutative_monads
05:48:56 <lambdabot> Title: Monad - HaskellWiki
05:49:00 <_zenon_> Zao, moonspeak :) ahaha
05:49:11 <Zao> _zenon_: That's why I like the "You're going to paste N lines into the channel, abort?" warning in irssi.
05:49:19 <quicksilver> lilachaze: intuitively yes, accurately no.
05:49:28 <quicksilver> lilachaze: (>>) can never commute in values
05:49:34 <_zenon_> Zao, seems nice.
05:49:36 <quicksilver> what you care about is it if commutes in effects.
05:49:55 <quicksilver> Dr_Zooix: but what's the error?
05:50:01 <Dr_Zooix> _Dae_: Do you havre an idea for my problem ? I've corrected the 'l' that miss
05:50:20 <_Dae_> Dr_Zooix: well, you're not importing "map" which might be a problem
05:50:41 <quicksilver> oh, that's true.
05:51:20 <_Dae_> Dr_Zooix: import Data.Map (lookup, (!), insert, size, map, Map)
05:51:56 <vixey> I didn't get a hackage account
05:52:01 <roconnor> :(
05:52:10 <vixey> I sent the guy my code
05:52:16 <lilachaze> quicksilver: yeah, (>>) can't ever commute because it's m a -> m b -> m b. i guess i meant more that if you have "foldl (>>) (ms ++ [m])" then you should get equivalent results from any permutation of ms.
05:52:17 <Lemmih> dcoutts: Up for more hacking this evening?
05:52:18 <_zenon_> vixey, you where denied?
05:52:19 <Dr_Zooix> _Dae_: Ok thanks very much :)
05:52:32 <lilachaze> (assuming that expression were even well-typed) :)
05:52:41 <vixey> I don't think it was the right sort of thing for hackage
05:52:53 <_Dae_> Dr_Zooix: That will at leat make it compile ;)
05:53:12 <Dr_Zooix> _Dae_: Yes ok, thanks
05:53:32 <vixey> I'm at a loss
05:54:01 <quicksilver> lilachaze: you could say that (>>) commutes on the type "m () -> m() -> m()"
05:54:10 <quicksilver> lilachaze: it's not obivous that this is a sufficient condition
05:54:14 <quicksilver> it's certainly necessary
05:54:17 <quicksilver> and perhaps it's intuitive
05:54:23 <quicksilver> it's the effects that you want to commute
05:55:59 <dcoutts> Lemmih: not today or this weekend probably, but I'll be free on Monday and through next week
05:56:09 <dcoutts> Lemmih: I pushed some tar changes
05:57:00 <dcoutts> Lemmih: I've done the bit that generates the tarball and caches it in the server state (though not tested) but I've not hooked it up to an external url yet
05:57:26 <Lemmih> dcoutts: Okay. I'll do some offline hacking, then.
05:58:02 <dcoutts> @arr!
05:58:03 <lambdabot> Yeh scurvy dog...
05:58:58 <_zenon_> vixey, is there no other site where you can put it?
05:59:17 <_zenon_> Is there in fact other sites similar to hackage which can host things rejected by hackage?
06:02:10 <lilachaze> quicksilver: i don't think that condition is sufficient; it holds for the list monad (which i guess is not considered to be commutative), and for (->) a (likewise).
06:05:12 <lilachaze> quicksilver: except that (->) a clearly is commutative ;-)
06:13:15 <quicksilver> lilachaze: the list monad is commutative in my opinion.
06:14:04 <Peaker> The set monad is commutative? :)
06:19:07 <RayNbow> Peaker: is Data.Set.Set a monad? :p
06:19:33 <Peaker> it makes sense for it to be a monad like list, but unordered
06:20:29 <quicksilver> the set monad is commutative, and so is the multiset monad
06:20:38 <quicksilver> unfortunately Data.Set can't be a monad in haskell.
06:20:41 <quicksilver> well, not easily.
06:20:50 <RayNbow> because of the Ord constraint, right?
06:24:19 <lilachaze> RayNbow: yes.
06:24:24 <Peaker> why is "a multiset" not simple a "histogram"?
06:25:13 <lilachaze> histogram usually implies buckets of more than one element
06:25:25 <lilachaze> or at least, it can do :)
06:25:53 <Saul_> A histogram is a graphical representation, not really a data type as is
06:26:21 <Peaker> its a different interpretation to the same datatype, it seems
06:27:33 <Saul_> I don't think they are really different in how they look at data
06:27:35 <Zao> Couldn't a histogram have buckets wider than one element?
06:27:58 <Zao> Much like how FFT buckets contain frequency ranges.
06:28:37 <Saul_> Zao: I think you can do the same with multisets
06:29:25 <Zao> I may be biased by using the C++ multiset though.
06:29:32 <Saul_> Well maybe not directly
06:30:12 <quicksilver> Peaker: why is a "histogram" not a simple "multiset" ?
06:30:13 <quicksilver> :P
06:30:21 <quicksilver> in my mind multiset is the primitive concept.
06:30:25 <Peaker> so multisets are discrete and histograms are allowed to speak of ranges..
06:30:34 <quicksilver> I agree with everyone else who says that histograms in general have buckets
06:31:28 <idnar> that question reads sort of like "why is a quaternion not simply a 4-tuple?"
06:32:48 <Saul_> a histogram is a multiset with classes instead of values
06:34:45 <SamB> a histogram is a partitioned multiset?
06:39:19 <lilachaze> SamB: "is" is subjective :)
06:40:18 <SamB> I'm fairly certain that if I said "a histogram is a digraph", that would be wrong
06:56:49 <Peaker> why is that: http://hpaste.org/9005
07:03:56 <Peaker> anyone can help deciphering that error? why did the inference make up a new name for a type in there? All the types already have proper type variable names?
07:04:49 <allbery_b> it's telling you the result type isn't necessarily the one you think it is
07:05:27 <ADEpt> Peaker: it is confused with "dt" and 'dt'"
07:05:32 <allbery_b> because classes are open, and d doesn't uniquely specify dt (you said the opposite in the fundeps)
07:06:00 <Quadrescence> Is there a way to monitor my program's memory usage at certain points? Or time spent at certain parts? (for debugging)
07:06:27 <Peaker> allbery_b: thanks
07:06:48 <ADEpt> Quadrescence: browse docs for "ghc -prof -auto-all"
07:07:26 <Quadrescence> ADEpt: Alright, thanks.
07:07:36 <lilachaze> Peaker: it doesn't know whoch Delta instance to use in the call to makeConst.
07:07:43 <allbery_b> also +RTS -hT
07:08:09 <Peaker> lilachaze: it will know in context - when it is used?
07:08:12 <Quadrescence> THAT'S what it's called. Profiling.
07:09:07 <Quadrescence> If I store an integer "1" (not a string, just identifying the integer), will it only take 1 byte?
07:09:34 <lilachaze> Peaker: makeConst is parameterised over two dt types; the type of the instance and the type of the result. it knows the latter but not the former
07:09:42 <Quadrescence> (or more generally, is memory allocated as needed?)
07:09:54 <lilachaze> Peaker: it should probablye be just makeConst :: d -> dt
07:10:04 <quicksilver> Quadrescence: nothign takes only one byte :)
07:10:08 <Peaker> lilachaze: but it doesn't use the former?
07:10:26 <quicksilver> Quadrescence: the Integer 1 is probably 8 bytes, I think.
07:10:27 <Peaker> lilachaze: yeah - you're right, thanks!
07:10:30 <quicksilver> (on a 32 bt system)
07:10:41 <Quadrescence> quicksilver: 8 bytes. D:
07:10:50 <quicksilver> well i think gmp is compiled with 32 bit limbs
07:10:56 <quicksilver> and there is a 32bit overhead for the thunk
07:11:39 <quicksilver> it might be more in fact :)
07:11:45 <quicksilver> I'm not sure how GHC stores gmp integers.
07:12:27 <Quadrescence> So there is no way I can just store a byte worth of data? I am going to have loooooots of values.
07:12:43 <Quadrescence> And if I can cut the size by 8 or even 4, it'd help...
07:13:14 <taruti> yes, that is possible. e.g. STU/IOUArray of Word8/Int8
07:13:59 <quicksilver> doesn' thave to be ST or IO
07:14:02 <quicksilver> can just be UArray
07:14:17 <quicksilver> and there is also bytestring, vector, uvector, Ptr
07:15:35 * _zenon_ goes for food
07:15:41 <_zenon_> So hungry
07:15:50 <_zenon_> Is there a way to store text inside lambdabot?
07:16:12 <Quadrescence> Could someone lead me to some documentation please? (as to avoid LOTZ MOAR CUESTIONZZ)
07:16:26 <Zao> > let pie = "pie"
07:16:26 <lambdabot>  Parse error at end of input
07:16:31 <Asgaroth> is there a map-variant which takes a two-argument function and two lists?
07:16:42 <Zao> _zenon_: It has some @tell command.
07:16:48 <tromp> use zip
07:16:53 <Asgaroth> thanks
07:18:09 <quicksilver> Asgaroth: zipWith, rather
07:18:19 <Asgaroth> quicksilver: thanks, I know.
07:18:27 <quicksilver> ;)
07:18:44 * quicksilver hates seeing clumsy code with zip when there is zipWith! 
07:18:56 <lilachaze> @let important_message_for_zenon = "use @let"
07:19:04 <lambdabot> Defined.
07:19:09 <quicksilver> Quadrescence: well Data.Bytestring is in extralibs and odcced in the normal place
07:19:15 <quicksilver> @tell lilachaze there is also this method
07:19:16 <lambdabot> Consider it noted.
07:19:32 <lilachaze> @messages
07:19:33 <lambdabot> quicksilver said 18s ago: there is also this method
07:19:43 <quicksilver> Quadrescence: vector/uvector are a bit more experimental, although see recent postings to the -cafe
07:19:54 <quicksilver> Ptr is in the standard libs but pretty dangerous
07:20:02 <Asgaroth> @tell Asgaroth Can i leave notes to myself
07:20:03 <lambdabot> You can tell yourself!
07:20:07 <MyCatVerbs> Heh.
07:20:16 <MyCatVerbs> Seen on reddit: peyton `simon` jones
07:20:19 <quicksilver> the Ptr solution is only recommended when your objective is to interface with C code.
07:21:22 <MyCatVerbs> @quota Fallacy peyton `simon` jones
07:21:22 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
07:21:41 <MyCatVerbs> @remember Fallacy peyton `simon` jones
07:21:42 <lambdabot> Good to know.
07:22:06 <lilachaze> > 42 `id`
07:22:11 <lambdabot>   parse error on input `}'
07:22:18 <MyCatVerbs> This reminds me. What's the most common way libraries use of passing around chunks of (more or less unstructured) memory (like, say, bitmaps)?
07:22:21 <Deewiant> '}'? O_o
07:22:32 <quicksilver> MyCatVerbs: ByteString, if it's a haskell lib.
07:22:40 <quicksilver> MyCatVerbs: Ptr if the objective is to interface with C
07:22:45 <MyCatVerbs> At the moment I'm using StorableArray Int Word8, on account of wanting to pass things through C so often.
07:22:46 <nominolo> > (1+)
07:22:52 <lambdabot>  <Integer -> Integer>
07:23:00 <Asgaroth> Is it considered good style to use something like somefunc arg1 arg2 where arg1 = ....?
07:23:22 <nominolo> Asgaroth: depends, but mostly yes
07:23:24 <awarring> does anyone have any good resources that cover the theory behind monads :o
07:23:31 <quicksilver> MyCatVerbs: I wish ByteString had a 'withPtr' method.
07:23:42 <quicksilver> s/method/function/
07:23:51 <MyCatVerbs> quicksilver: yeah, I'm looking at the API docs now and that's the first thing that popped into my head.
07:23:59 <nominolo> awarring: relly, the whole theory?  well, there're category theory books
07:24:10 <quicksilver> dcoutts: why doesn't ByteString ahve something like 'withPtr' for easy interface with C libs?
07:24:23 <MyCatVerbs> quicksilver: "where's the (Ptr Word8 -> Int -> IO a) -> ByteString -> IO a"
07:24:27 <ksandstr> am I the only one who's bothered by how "hip" ByteStrings are in a language like Haskell?
07:24:39 <MyCatVerbs> Er, that should have a question mark on it, but y'know?
07:24:42 <MyCatVerbs> ksandstr: nope.
07:24:59 <Deewiant> "a language like Haskell"?
07:25:04 <awarring> nominolo: i dunno...i keep feeling stupid, every time i read a tutorial, or document on monads, it always says something along the lines of "there is theory behind this, just trust us"
07:25:05 <nominolo> ksandstr: what's bothering you?
07:25:08 <ksandstr> Deewiant: sorry, meant language community like that of Haskell
07:25:12 <MyCatVerbs> ksandstr: IMO, [Char] is a much nicer solution because it actually deals nicely with unicode.
07:25:23 <Deewiant> ksandstr: still, what exactly do you mean by it
07:25:47 <ksandstr> nominolo: it's like... wow, we've just found this nice tool that lets us program without thinking about lowlevel considerations. now let's find a way to micro-optimize with it
07:26:23 <nominolo> awarring: i don't think you need to understand this.
07:26:34 <vixey> ksandstr: "micro"?
07:26:36 <nominolo> ksandstr: but some people need performance
07:26:43 <MyCatVerbs> However, in cases where encodings don't actually matter to you (like, say you're not actually doing individual-characters string manipulation and hence don't care about encodings), it's certainly nice to have the faster implementation.
07:26:44 <vixey> ksandstr: Have you done any serious comparisons?
07:27:04 <vixey> ksandstr: it's a bit more advanced that "micro"
07:27:23 <nominolo> ksandstr: and, for example http is unusable with large inputs.  it *needs* bytestrings
07:27:24 <ksandstr> vixey: of course not. I'm just commenting on how disproportionate the attention to ByteStrings seems
07:27:41 <quicksilver> well bytestrings are not for use with characters
07:27:48 <quicksilver> HTTP is not a text protocol
07:27:58 <quicksilver> (it has an ascii header portion, but the body can be anything)
07:28:06 <Deewiant> bytestrings are for strings of bytes. :-P
07:28:13 <quicksilver> MyCatVerbs and I were talking about things like bitmaps, images
07:28:17 <MyCatVerbs> Right. What really *ought* to be done is to delete Data.ByteString.Char8 and Data.ByteString.Lazy.Char8, and then deny that they ever existed.
07:28:17 <quicksilver> which are just chunks of memory
07:28:22 <quicksilver> bytestring is great for that.
07:28:33 <ksandstr> ah, so that's the source of my unease. the "string" part.
07:28:36 <MyCatVerbs> To give people the hint that, no, ByteStrings are not for working with text. They are for working on bytes.
07:28:44 <quicksilver> there is a "byte" part though ksandstr ;)
07:28:48 <quicksilver> which is supposed to mitigate against that.
07:28:57 <Deewiant> but .Char8 is handy for stuff like the ASCII header portion of HTTP. :-P
07:28:58 <MyCatVerbs> There's a good reason why unpack returns [Word8], not [Char].
07:29:09 <Asgaroth> another style question: Is there any guideline on when to use parens and when to use $?
07:29:24 <vixey> Asgaroth: your own judgement
07:29:30 <SamB> Asgaroth: well, you should use . more than $
07:29:43 <Asgaroth> okay
07:29:43 <ksandstr> quicksilver: well yes, but looking at it another way (i.e. "ByteStrings are real fast!"), the Byte leaves a racing stripes sort of impression
07:29:55 <MyCatVerbs> Deewiant: hush you, use w2c/c2w. ;P
07:30:16 <nominolo> Asgaroth: just always make sure to write your code as clear as possible, not as clever as possible
07:30:33 <nominolo> Asgaroth: ie, don't just use pointfree style for the sake of it
07:30:38 <dcoutts> quicksilver: it does have things like that
07:30:40 <Asgaroth> nominolo: I'm trying ;)
07:30:43 <SamB> ksandstr: compare with the overhead of a cons AND a Word8
07:30:52 <quicksilver> dcoutts: does it? did I miss them?
07:31:08 <Asgaroth> nominolo: and often $ seems to make things clearer than endless parentheses
07:31:12 <Deewiant> MyCatVerbs: oh, handy! Never knew about that
07:31:19 <SamB> that's 2x object overhead + 3 words
07:31:28 <Deewiant> since it's apparently only in .Internals
07:31:30 <nominolo> Asgaroth: yep. especially if the closing paren would be on another line
07:31:32 <dcoutts> quicksilver: useAsCString :: ByteString -> (CString -> IO a) -> IO a
07:31:35 <MyCatVerbs> Deewiant: I'm not quite sure why they're in D.B.Internal instead of D.B, but yeah.
07:31:35 <ksandstr> SamB: that's a very good point there
07:32:11 <MyCatVerbs> Deewiant: probably because it'd be preferrable to not get people started on using ByteStrings as if they were character strings. ;)
07:32:13 <dcoutts> quicksilver: there are also unsafe non-copying versions
07:32:24 <Deewiant> MyCatVerbs: :-P
07:32:34 <quicksilver> dcoutts: hmm. why CString and not Ptr a ? or Ptr Word8 ?
07:32:45 <dcoutts> @type CString
07:32:47 <lambdabot> Not in scope: data constructor `CString'
07:32:53 <dcoutts> @src CString
07:32:54 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:32:56 <dcoutts> bah
07:33:00 <MyCatVerbs> The one thing that *does* irritate me about Data.ByteString.* is that there are two mutually incompatible implementations with the same name.
07:33:04 <dcoutts> quicksilver: CString is Ptr CChar
07:33:08 <SamB> CString is Ptr CChar, isn't it?
07:33:17 <quicksilver> yes, but that's not Ptr Word8 or Ptr a
07:33:18 <SamB> MyCatVerbs: same name?
07:33:23 <MyCatVerbs> I mean, people, why do we have to have ByteString and ByteString? What'd be wrong with just having ByteString and ByteStringL?
07:33:25 <quicksilver> 'CChar' feels like a strange type to choose
07:33:29 <quicksilver> for 'Byte'strings
07:33:34 <dcoutts> quicksilver: a CChar is a Word8
07:33:46 <quicksilver> @source CChar
07:33:46 <lambdabot> CChar not available
07:33:49 <MyCatVerbs> SamB: Data.ByteString and Data.ByteString.Lazy aren't the same thing. Vide toChunks/fromChunks.
07:34:00 <dcoutts> quicksilver: it's always presented a byte and 8bit char interface
07:34:01 <SamB> quicksilver: you DO realize that the C standard defines char == byte
07:34:12 <quicksilver> SamB: I do.
07:34:19 <quicksilver> but this isn't C, it's haskell
07:34:20 <MyCatVerbs> SamB: it's only really a pain when you have things like Data.Binary.Put emitting lazy bytestrings and some other piece of code you've written that wants strict bytestrings.
07:34:23 <nominolo> SamB: no it doesn't
07:34:28 <dcoutts> MyCatVerbs: that's what module names are for
07:34:30 <SamB> nominolo: how so?
07:34:32 <quicksilver> and Ptr a and Ptr Word8 both feel like better matches here.
07:34:36 <ksandstr> SamB: char is just what produces 1 from sizeof
07:34:51 <nominolo> SamB: well, at least the C++ standard only defines sizeof(char) = 1
07:35:02 <nominolo> SamB: not that this unit is a byte
07:35:14 <SamB> a char also holds all of the data in that byte
07:35:15 <dcoutts> quicksilver: it's certainly not Ptr a, it's either Ptr Word8 or Ptr CChar
07:35:17 <nominolo> SamB: and then some relations between sizeof's
07:35:23 <SamB> there is NO PADDING
07:35:29 <ksandstr> it's just that char being the same as a byte is very convenient in a 8/16/32/64 machine
07:35:54 <dcoutts> quicksilver: probably the right thing is for the ByteString.Char8.useAsCString to use Ptr CChar, and ByteString.useAsCString to use Ptr Word8
07:35:56 * _zenon_ is nomming his sandwich
07:36:01 <MyCatVerbs> dcoutts: yeah, but it feels a bit... crazy, when the API documentation has two different functions putByteString and putLazyByteString, both of whose type declarations look like :: ByteString -> Put ().
07:36:04 <SamB> nominolo, ksandstr: you clearly haven't READ the C standard
07:36:07 <quicksilver> dcoutts: yeah that makes more sense to me.
07:36:29 <dcoutts> MyCatVerbs: that's an issue with the haddock docs not showing enough detail to disambiguate
07:36:32 <MyCatVerbs> dcoutts: and it's not always clear when you're looking at the docs for e.g. Data.Binary whether a particular function outputs a lazy or strict string.
07:36:41 <MyCatVerbs> Er, ByteString.
07:36:47 <_zenon_> Assume lazy?
07:36:50 <quicksilver> dcoutts: althouhg I don't really think there is anything wrong with Ptr a. A string of bytes is a repreentation of Ptr a, whatever the 'a' is.
07:36:56 <ksandstr> SamB: wait. are you saying that the C standard has a separate definition for "byte", which is different from the usual "one X-teenth of a word"?
07:37:07 <SamB> ksandstr: yes.
07:37:11 <dcoutts> MyCatVerbs: the source makes it clear by using qualified names and haddock should do so to where it's necessary
07:37:31 <SamB> it defines "byte" to be virtually synonymous with char
07:37:41 <MyCatVerbs> And besides, CChar is an Int8, not a Word8. CUChar is a Word8. ;)
07:37:51 <dcoutts> quicksilver: no, because Ptr a has different sized elemenets depending on the type
07:38:18 <MyCatVerbs> SamB: what's hilarious is that it's legal to have 9 bit bytes. :D
07:38:22 <ksandstr> SamB: wow. did this change with c99? because I'm pretty sure me and nominolo remembered the other way due to some old usenet wisdom or something
07:38:37 <olsner> isn't it rather that char is defined as a byt than a byte being defined as a char?
07:38:48 * nominolo is just reading the C99 standard
07:38:54 <mauke> MyCatVerbs: er, what?
07:39:05 <ksandstr> olsner: nah, they likely wanted to retain compatibility with c89 :D
07:39:11 <SamB> olsner: I don't remember which way around it is, however it works out the exact same way
07:39:26 <mauke> how can you discuss obscure details of C without me?
07:39:44 <SamB> mauke: what? you're here aren't you?
07:39:52 <nominolo> SamB: ah it defines it the other way around
07:39:53 <MyCatVerbs> mauke: UNIVAC 1100/2200 had a C implementation with 9-bit bytes. :D
07:39:58 <SamB> also -- there are now obscure bits of C?
07:40:04 <nominolo> ie 1 byte = sizeof(char)
07:40:08 <MyCatVerbs> mauke: 36-bit words, 18 bit halfwords, etc.
07:40:12 <quicksilver> dcoutts: well yes, but you don't know how many it points to anyway
07:40:16 <nominolo> but it doesn't say how many bits a byte is
07:40:18 <mauke> MyCatVerbs: ok, C doesn't define the signedness of char
07:40:22 <SamB> nominolo: indeed!
07:40:23 <quicksilver> dcoutts: since we don't distinguish, so therefore...
07:40:25 <olsner> SamB: isn't all of C obscure bits? :P
07:40:26 <MyCatVerbs> mauke: also, *retch* one's-complement arithmetic.
07:40:31 <SamB> did I neglect to mention that?
07:40:34 <ksandstr> it rather seems that C is too small to really have any bits that're obscure
07:40:38 <MyCatVerbs> mauke: oh, blast. I was hoping no one would notice that. ;)
07:41:20 <nominolo> SamB: but there's no guarantee that Char8 = CChar
07:41:27 <MyCatVerbs> mauke: yeah, true. Handy that Foreign.C.Types exports CSChar as well as CUChar, eh?
07:41:35 <mauke> yep
07:41:46 <dcoutts> quicksilver: we do, we have a version that passes the length
07:42:23 <mauke> in C terms: if uint8_t exists, it's equal to unsigned char
07:42:28 <quicksilver> dcoutts: well yes. But that's not quite what I'm trying to say.
07:42:44 <quicksilver> dcoutts: you're saying that it can't be "Ptr a" because you don't know if it poitns to 'enough bytes' to be a Ptr a
07:42:51 <quicksilver> dcoutts: but that's equally true for Word8
07:42:59 <quicksilver> dcoutts: it might point to 0 bytes...
07:43:24 <dcoutts> quicksilver: huh? useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
07:43:35 <dcoutts> it says exactly how many elements the Ptr CChar points to
07:43:41 <ksandstr> mauke: does this also imply that the target architecture's byte size is 8 bits?
07:44:01 <mauke> ksandstr: yes, otherwise you can't have uint8_t
07:44:04 <dcoutts> (the useAsCString gives a null terminated C string without a length)
07:44:11 <quicksilver> dcoutts: Yes. I know. That's not my point.
07:44:13 <SamB> ksandstr: well, not the architecture per-se
07:44:17 <SamB> but the ABI
07:44:18 <SamB> yes
07:44:18 <quicksilver> My point is: is it Ptr Word8 or Ptr a?
07:44:37 <quicksilver> you said it couldn't be Ptr a because Ptr a has different sized elements depending on the type
07:44:42 <quicksilver> I don't see the relevance of that?
07:44:46 <dcoutts> quicksilver: and I think it's quite clearly Ptr Word8/CChar, there's no other type it can be
07:45:11 <ksandstr> mauke: so it wouldn't be standard compliant to have a non-standard ___compat_u8 type that's typedeffed into uint8_t, while chars would remain at a weird bit length?
07:45:28 <mauke> ksandstr: what would sizeof (uint8_t) be then?
07:45:34 <dcoutts> quicksilver: you could explicitly cast and reinterpret the bytes, but that's up to you, you can keep the pieces :-)
07:45:35 <mauke> 0.892?
07:45:36 <SamB> ksandstr: such as 4?
07:46:10 <quicksilver> dcoutts: I don't understand why you think it's any more true that it points to Word8 than that it points to "a".
07:46:17 <quicksilver> all we know is it points to something.
07:46:30 <dcoutts> no, we know the type of the content too
07:46:31 <quicksilver> those bytes might be anything...
07:46:34 <quicksilver> how?
07:46:51 <dcoutts> they're bytes because bytestring is an abstraction of a sequence of bytes
07:47:04 <dcoutts> (and we provide a view as 8bit chars)
07:47:24 <ksandstr> mauke: hm. thanks. now I'm a little less scared of the compiler
07:47:52 <mauke> pÇÊÉÇÊÇp ÉÄ±ouÉÉ¹Éd ÊuÇÄ±ÉÄ±ÉÉnsuÄ±
07:48:51 <quicksilver> dcoutts: but everything is bytes, in a computer :)
07:49:04 <quicksilver> dcoutts: it's surely equally valid to interpret those bytes as Word8 as anything else...
07:49:07 <ksandstr> mauke: well the trust-once strategy seems to work fairly ok so far
07:49:09 <dcoutts> quicksilver: what is a Ptr a? it's the location of a sequence of (unknown length) (of a representation of) values of type a.
07:49:09 <mauke> (but in C, functions aren't bytes)
07:49:12 <quicksilver> they're not "Structured" when they're in a bytestring
07:49:19 <quicksilver> dcoutts: agreed.
07:49:40 <dcoutts> and a bytestring is a sequence of bytes
07:49:44 <quicksilver> agreed.
07:50:02 <Asgaroth> If I use let foo=cpu_heavy_func, will this still be lazily evaluated only when accessing foo?
07:50:39 <quicksilver> yes.
07:50:43 <quicksilver> everything is lazily evaluated.
07:50:43 <Asgaroth> thanks
07:51:03 <Asgaroth> except a do block..
07:51:21 <dcoutts> quicksilver: we cannot directly produce a sequence of any old type, we only have access to a sequence of bytes. It would not be true to return Ptr a.
07:51:48 <quicksilver> Asgaroth: no. do blocks are also lazily evaluated.
07:52:14 <nominolo> Asgaroth: it's just that some monads enforce more or less strictness
07:52:16 <quicksilver> dcoutts: OK, I think your argument boils down to "Ptr Word8 is safe because every conceivable chunk of memory is a sequence of Word8s"
07:52:24 <Asgaroth> ah. thanks
07:52:25 <quicksilver> dcoutts: I think that makes sense, yes.
07:52:57 <dcoutts> quicksilver: and if people want to do unsafe things then they can castPtr, but that makes it explicit.
07:52:58 <nominolo> Asgaroth: remember that do blocks just get tranlated into calls to (>>=) and return
07:53:27 <dcoutts> quicksilver: it means the bytestring lib is not making a promise it cannot keep
07:53:34 <quicksilver> dcoutts: ok, fair enough.
07:56:43 <olsner> Maybe a -> (a -> m b) -> m (Maybe b)
07:56:47 <olsner> bleh
07:58:42 <RayNbow> @src (->) (>>=)
07:58:42 <lambdabot> f >>= k = \ r -> k (f r) r
07:58:56 <_zenon_> I just got a thought; why not define a function  Â¥ k = "if you already told me k then say it again, or say k if it is the first time you say it"
07:59:26 <_zenon_> Like when you Maybe have forgot something that someone said, XOR  the person never said it, but you want to know about it.
07:59:46 <olsner> hmm... that's sounds like it's not only AI, but telepathy
08:00:33 <_zenon_> To avoid saying "when where we supposed to meet?" <--- although you have never talked about it.
08:01:04 <_zenon_> Instead you say "Â¥  time to meet"
08:01:41 <_zenon_> Because saying "when where we supposed to meet" almost implies you HAVE talked about it, but you haven't, XOR you have.
08:01:53 <_zenon_> Are you following?
08:02:31 * RayNbow has a hard time visualizing/understanding the (a ->) monad...
08:03:23 <mauke> do you know Reader?
08:03:58 <RayNbow> I don't :p
08:04:02 <byorgey> RayNbow: it's the environment monad.  that is, computations which can refer to a read-only environment while being computed
08:04:17 <byorgey> in order to "run" it, you have to supply an environment, i.e. argument to the function
08:04:25 <quicksilver> RayNbow: alternatively, it's just the practice of passing the same parameter to a whole load of functions.
08:04:34 <quicksilver> with the 'plumbing' of repassing the parameter hidden.
08:04:52 <quicksilver> like if all you functions require something called GraphicsContext and you keep passing 'gc' to everything
08:05:00 <quicksilver> the Reader monad encapsulates that pattern.
08:05:45 <RayNbow> ah
08:05:54 <byorgey> btw, "the (a ->) monad" and "the Reader monad" are the same thing, Reader is just a newtype
08:06:07 <byorgey> @src Reader
08:06:07 <lambdabot> Source not found.
08:06:08 <mauke> Reader may be easier to understand/use at first
08:06:19 * RayNbow adds http://www.haskell.org/haskellwiki/Monads_as_containers to the reading list
08:06:19 <lambdabot> Title: Monads as containers - HaskellWiki
08:06:25 <mauke> after you've become familiar with it you can simply omit the "Reader" :-)
08:06:29 <byorgey> newtype Reader e a = Reader (e -> a)
08:06:46 <quicksilver> also the reader monad on its own wouldn't be useful in the example I just gave
08:06:57 <quicksilver> because 'running a whole bunch of functions' doesn't do anything
08:07:00 <_zenon_> RayNbow, http://www.haskell.org/all_about_monads/html/readermonad.html
08:07:00 <quicksilver> no side-effects
08:07:01 <lambdabot> Title: The Reader monad
08:07:07 <quicksilver> so my example is more properly ReaderT IO
08:07:10 <quicksilver> but the idea is there.
08:07:32 <RayNbow> _zenon_: thanks :)
08:08:05 <_zenon_> RayNbow, no problem. All About Monads is aqtually a great monad resource
08:08:25 <mauke> Reader gives you a hidden pseudoglobal readonly variable
08:08:40 <fophillips> What provides HsModule?
08:08:49 <mauke> RayNbow: hmm, do you know C++ or Java?
08:09:03 <RayNbow> yeah
08:09:25 <mauke> if you're in a class method, you have implicit access to all member variables
08:09:48 <mauke> you can use them like they're global, but they're actually part of your instance/object
08:10:21 <mauke> but under the hood, C++ compilers will pass a hidden 'this' argument to methods
08:10:45 <RayNbow> so the Reader monad represents implicit parameters?
08:10:46 <luite> you mean instance method?
08:11:04 <mauke> RayNbow: yes, sort of
08:11:05 <luite> class method (at least in java terminology) usually refers to a static method
08:11:15 <mauke> oh, right
08:11:28 <byorgey> I think mauke just meant 'method of the class'
08:11:39 <RayNbow> luite: static methods are evil anyway, they're not worth mentioning :p
08:11:56 <byorgey> java terminology sucks anyway
08:12:00 <byorgey> ;)
08:12:03 <luite> :)
08:12:12 <mauke> the difference is that Reader only gives you a single implicit parameter (but you can make it a record)
08:13:49 <paolino> and that haskell compiler is not making magic for that
08:14:10 <mauke> yeah, the magic is in the library :-)
08:14:48 <quicksilver> GHC does have magic for implicit parameters, too.
08:14:56 <quicksilver> it's somewhat frowned upon though.
08:14:59 <quicksilver> I can't remember why :P
08:15:33 <_zenon_> :hoogle (Int -> [a] -> Maybe a)
08:15:44 <ndmitchell> @hoogle Int -> [a] -> Maybe a
08:15:44 <MyCatVerbs> quicksilver: because their interaction with the monomorphism restriction is akin to a Trabant's interaction with a freight train at full speed.
08:15:45 <lambdabot> No matches, try a more general search
08:15:51 <MyCatVerbs> quicksilver: I think, anyway.
08:16:06 <_zenon_> @hoogle b -> [a] -> Maybe a
08:16:07 <lambdabot> No matches, try a more general search
08:16:12 <paolino> @hoogle findIndex
08:16:13 <lambdabot> Data.List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
08:16:13 <lambdabot> Data.ByteString.findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
08:16:13 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
08:16:35 <ndmitchell> _zenon_: elemIndex, the web Hoogle gets it as the 6th result
08:16:48 <_zenon_> @src elemIndex
08:16:48 <lambdabot> elemIndex x     = findIndex (x==)
08:17:19 <MyCatVerbs> quicksilver: That's the main problem I noted, anyway. Reader gives you a nice civilised "local", while when using implicit parameters it's quite possible for the presence or absence of type declarations to alter your program's semantics in surprising ways.
08:17:37 * quicksilver nods
08:17:59 * _zenon_ goes to see Hancock now
08:18:19 <Valodim> He's an alien
08:18:21 <Valodim> hah, spoilered
08:18:30 <_zenon_> Valodim, damn you
08:18:57 <Valodim> (he's not)
08:18:59 <Baughn> No, he's actually french
08:19:09 <mauke> http://www.haskell.org/pipermail/haskell/2003-August/012412.html
08:19:10 <lambdabot> Title: Solution to the monomorphism restriction/implicit parameter problem
08:19:14 <Valodim> yeah that's why he's a bum even with superpowers
08:19:17 <MyCatVerbs> That's the main issue that I'm aware of, anyway. Plus, it all gets compiled down to functions-taking-arguments anyway, so it's not actually (AFAIK) more efficient at the machine-code level than using Reader (I believe, anyway - at least, once GHC has gone and eliminated all the newtypes, anyway.)
08:19:26 <byorgey> isn't the MR going away in the next release of GHC anyway?
08:19:36 <Baughn> "Runtiem error: Random number generation failure: Please enter a unique 16-digit prime number when prompted."
08:19:47 <MyCatVerbs> byorgey: is it?
08:19:54 <byorgey> IIUC
08:20:00 <quicksilver> I don't think it's decided
08:20:03 <quicksilver> it's been discussed
08:20:08 <MyCatVerbs> byorgey: I haven't been following closely, but where'd you hear that?
08:20:20 <quicksilver> long thread on haskell-prime I think?
08:20:23 <quicksilver> somewhere, anyway.
08:21:01 <MyCatVerbs> Oh, k.
08:21:25 <MyCatVerbs> Haven't been able to read the mailing lists lately, and even then I'm only actually subscribed to haskell@.
08:21:32 <byorgey> hm, maybe it just for Haskell'
08:21:37 <MyCatVerbs> haskell-cafe's nice, but waaaay high volume.
08:21:44 <MyCatVerbs> byorgey: that would be sensible, I guess.
08:21:50 <quicksilver> I think taking off the monomorphism restriction will have painful results for numerical code.
08:22:00 <quicksilver> I thought it was a really good idea to start with
08:22:11 <quicksilver> but then I got worried when I saw how much my numerical code relies on it.
08:22:18 <byorgey> hm, interesting
08:22:54 <byorgey> MyCatVerbs: that's what the HWN is for!  at least, that's the intention
08:25:08 <MyCatVerbs> byorgey: it's posted to haskell@, right?
08:25:17 * MyCatVerbs checks. Yep.
08:25:19 <byorgey> MyCatVerbs: yup
08:25:33 <MyCatVerbs> byorgey: that's handy, but not much use when I'm unable to read haskell@ too. ;)
08:25:44 <byorgey> MyCatVerbs: well, hehe, indeed
08:26:06 <byorgey> but yeah, I try to pull out interesting stuff from the various lists (announcements, interesting discussions, etc.) and summarize them
08:26:24 <byorgey> so you can know what's going on without having to follow everything yourself
08:26:28 * MyCatVerbs nodnod.
08:26:31 <MyCatVerbs> Thanks, by the way. :)
08:26:37 <byorgey> you're welcome =)
08:34:34 <BeelsebobWork_> what would people think would be a good symbol for an operator of type Gen a -> Gen b -> (Gen a,Gen b) -- ideally I want <,>, but that's illegal ofc
08:34:53 <Baughn> Rather depends on what it /does/
08:35:07 <Baughn> Based on the type - is it just (,)?
08:35:19 <BeelsebobWork_> sorry, moron
08:35:24 <BeelsebobWork_> Gen a -> Gen b -> Gen (a,b)
08:35:29 <BeelsebobWork_> so higher order (,)
08:36:42 <Baughn> I'd probably just go for fmap (,)
08:36:50 <BeelsebobWork_> Gen isn't  a functor
08:36:57 <Baughn> Make it one?
08:37:14 <BeelsebobWork_> so it's acttually liftM (,), but I don't want to populate my code with that
08:37:23 <BeelsebobWork_> or liftM2
08:37:24 <Baughn> If it's a monad, it should also be a functor
08:37:28 <roconnor> liftA2 (,)
08:37:42 <Baughn> (;).. no, also illegal
08:38:00 <BeelsebobWork_> again... I don't want to populate code with liftM2 (,) it's a lot less clear than a nice operator that looks like it means "tuple these things"
08:38:03 <roconnor> <*>
08:38:08 <Baughn> BeelsebobWork_: Anyway, instance Monad m => Functor m where fmap = liftM
08:38:10 <BeelsebobWork_> that's what I'd considered
08:38:21 <roconnor> <.> ?
08:38:23 <Baughn> Though that isn't actually in code anywhere, for some reason
08:38:49 <quicksilver> BeelsebobWork_: `commma`
08:38:51 <quicksilver> ;)
08:39:01 <BeelsebobWork_> quicksilver: heh, it's not horrific
08:39:03 <Philippa> BeelsebobWork_: I'm pretty sure one of the arrow combinators does that already?
08:39:05 <BeelsebobWork_> but also not ideal
08:39:12 <MyCatVerbs> <*> will conflict with Control.Applicative's <*>, `comma` is pretty decent.
08:39:19 <BeelsebobWork_> Philippa: that's a really good point
08:39:57 <Philippa> unfortunately the relationship between arrows and monads is a little awkward, but hey
08:40:02 <BeelsebobWork_> yep
08:40:19 <BeelsebobWork_> quickcheck could be nicer in terms of not just defining instances of Monad for Gen
08:40:33 <Philippa> yeah, you're looking at the applicative version of ***
08:40:38 <BeelsebobWork_> exactly
08:41:10 <quicksilver> some combination of runKleisli, (***) and Kleisli
08:41:11 <quicksilver> I guess ;)
08:41:41 <Philippa> quicksilver: that's less useful for naming
08:41:47 <quicksilver> certainly is.
08:41:59 <quicksilver> for values of 'less useful' approaching 'horrific'
08:42:03 <MyCatVerbs> Still thinking `comma` FTW.
08:42:28 <Philippa> that or just (,) `liftM2` ... or similar
08:42:39 <roconnor> how about â
08:42:50 <roconnor> not to be confused with *
08:43:27 <BeelsebobWork_> Philippa: yeh, I don't regard that as clear, or clean
08:44:06 <Philippa> BeelsebobWork_: it's no worse than inventing a non-standard name, tbh. It's about as clear as you can get unless you have a problem with infix
08:44:18 <Philippa> (I find the infix versions a lot more readable because they work much like $)
08:44:25 <BeelsebobWork_> Philippa: well, I'm trying to get it as close to (x,y) as possible
08:44:39 <BeelsebobWork_> so something infix is good
08:44:46 <Philippa> what's the context?
08:44:46 <BeelsebobWork_> ideally I wanted x <,> y
08:45:06 <roconnor> hug :: (m a, m b) -> m (a,b);  ... hug (x,y)
08:45:26 <Philippa> (I have to admit I'm actually starting to like monadic style in its own right, on account of it helping highlight change-the-monad refactorings)
08:45:43 <BeelsebobWork_> quickcheck generators -- I'm working on getting a nice applicative library for sticking them together
08:45:45 <MyCatVerbs> BeelsebobWork_: then define <,> and you're done.
08:45:54 <BeelsebobWork_> MyCatVerbs: <,> is an illegal infix operator
08:46:13 <MyCatVerbs> Is it? Oh well. Pick some other punctuation.
08:46:27 <Philippa> you've got a bit of a problem in <***> being way too confusing
08:46:33 <Philippa> as otherwise it'd be a natural
08:46:44 <MyCatVerbs> <*+> just to confuse people. ;)
08:47:01 <roconnor> I say use <*> and screw applicative functors for using the wrong symbol.
08:47:02 <BeelsebobWork_> so a generator for non-empty lists of tuples containing positivie integers paired with non empty lists of maybe integers would look like nonEmpty (positiveInt <,> nonEmpty (maybeGen arbitrary))
08:47:12 <BeelsebobWork_> Philippa: <***> wouldn't be too bad
08:47:35 <Philippa> BeelsebobWork_: it's *awful* in code that's got <*> and <**> and relatives meaning something utterly unrelated
08:47:51 <BeelsebobWork_> although actually, ideally I want one with only one char in it -- because then I need the one for 3 tupples to be <,,>, and for 4 tuples <,,,>
08:47:52 <BeelsebobWork_> etc
08:47:58 <Philippa> tbh, if you're looking to work with Applicatives anyway you're probably best off not bothering here
08:48:11 <Philippa> because Applicatives already are the general case
08:48:38 <MyCatVerbs> Ooh, I know. `mcomma`. ;)
08:48:41 <BeelsebobWork_> yep, but what would an applicative instance for Gen a look like
08:48:51 <quicksilver> (,) <$> a <*> b
08:48:56 <BeelsebobWork_> puri is pretty obvious
08:48:58 <BeelsebobWork_> pure*
08:49:06 <BeelsebobWork_> but <*> is less so
08:49:11 <quicksilver> <*>=ap
08:49:14 <quicksilver> since it's a monad ;)
08:49:19 <BeelsebobWork_> oh, duh
09:02:38 <Quadrescence> quicksilver: You must be an anthropomorphic robot or something.
09:06:07 <Asgaroth> Would it increase the performance significantly to use a list of pairs instead a list of two-element list if that list is accessed often(backtracking algorithm for the knight's tour)?
09:06:23 <quicksilver> Quadrescence: you're not the first person to accuse me of that.
09:06:37 <quicksilver> Asgaroth: I doubt it would be significat.
09:06:41 <quicksilver> it ought to be slightly better.
09:06:48 <Quadrescence> quicksilver: It just so happens that I am being robotic too. D: No sleep ftl.
09:06:59 <quicksilver> of course with agressive compiler optimisations it might compiler to almost the same code.
09:13:43 * robyonrails si Ã¨ sparato una dormita eccezionale
09:14:21 <roconnor> @wiki IO Semantics
09:14:22 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
09:15:08 <roconnor> I wrote that today.  Feel free to edit it to improve it.  Comments welcome
09:20:58 <Philippa> roconnor: I'm not sure I see the continuation part as a big deal, but maybe that's just me
09:21:13 <Philippa> I guess I'm more inclined to just chuck bind and return into the AST type
09:24:47 <roconnor> Philippa: as it stands IOTree is the standard co-inductive-inductive representation of continuous stream transfomers
09:25:28 <roconnor> (although the co-inductive-inductive type is hard to see because it has been simplified in haskell which as no notion of codata vs data
09:25:50 <roconnor> If we put Bind and Return into the AST, then we wouldn't have this
09:26:08 <roconnor> and I don't immediately see how we would get semantics
09:27:01 <roconnor> (not that I consider IOTree an AST)
09:27:59 <roconnor> as it stands, two programs are equal if they produce the same IOTree when run
09:28:15 <roconnor> If Bind and Return were part of the AST, and equivalence relation would be needed.
09:30:37 <quicksilver> is that really any worse?
09:30:48 <quicksilver> there are probably other equivalences your ADT doesn't know about
09:30:57 <quicksilver> like PutStrLn "" === return ()
09:31:47 <roconnor> ... PutStrLn "" == mapM_ putChar "" == sequence_ (map putChar "") == sequence_ [] == return ()
09:31:54 <roconnor> @src sequence_
09:31:55 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
09:32:20 <roconnor> so PutStrLn "" really is return ()
09:32:22 <DRMacIver> DrSyzygy: Congratulations. :)
09:33:21 <quicksilver> roconnor: ok, maybe not the best example.
09:33:42 <roconnor> if you were to add an equivalence relation to ans AST with Bind and Return, I think you would effectively end up with what I wrote.
09:33:46 <quicksilver> roconnor: writeMVar mv () >> writeMVar mv () == writeMVar mv ()
09:34:06 <roconnor> quicksilver: for teletype IO, the data type exactly captures the semantics
09:34:18 <roconnor> quicksilver: other IO effects may be somewhat more difficult to capture.
09:34:42 <quicksilver> ah, ok.
09:34:54 <quicksilver> yes I can belive you could model teletype IO perfectly.
09:34:55 <quicksilver> nice.
09:35:02 <roconnor> quicksilver: are MVars subject to concurency?
09:35:15 <quicksilver> well in theory they are. but the example I used doesn't rely on that
09:35:19 <quicksilver> it might as well be writeIORef
09:35:23 <quicksilver> its' just the idempotency of write
09:35:29 <roconnor> quicksilver: it would be good to expand on these semantics to capture more effects.
09:35:33 * quicksilver nods
09:35:40 <quicksilver> have you seen the IO test harness on hackage?
09:35:52 <roconnor> quicksilver: nope
09:36:14 <roconnor> quicksilver: I'm sure what I wrote is similar to what other people have written on the subject
09:36:30 <roconnor> quicksilver: It sort of form in my mind after talking and reading losts of different papers
09:36:38 <roconnor> including wouter's work
09:38:34 <quicksilver> http://www.cs.nott.ac.uk/~wss/repos/IOSpec/
09:38:35 <lambdabot> Title: IOSpec
09:38:39 <quicksilver> yes, it's wouter
09:39:09 <roconnor> I think these semantics, even if grossly incomplete, may be something helpful to point people asking "what is IO?"
09:39:31 <quicksilver> "The IOSpec library is not restricted to IORefs. There are also pure specifications of concurrency, STM, and teletype primitives"
09:39:37 <quicksilver> type Concurrent a = IOSpec (MVarS :+: ForkS) a
09:39:42 <quicksilver> it's quite cute.
09:39:48 <quicksilver> I'm not sure if it's the same under the hood as yours though.
09:39:58 <quicksilver> probably not; it works by execution in a VM
09:40:06 <quicksilver> it doesn't need equational equivalence to do the work
09:40:10 <quicksilver> it does executional equivalence
09:40:25 <sclv_> Which lets it handle different scheduling algorithms...
09:40:55 <quicksilver> right, because and equational model of concurrency is fairly hard
09:41:05 <quicksilver> well you consider all interleavings I suppose
09:41:10 <quicksilver> not to much hard as 'infeasible'
09:41:23 <roconnor> well, we are just talking about semantics
09:42:24 <quicksilver> fundamentally different ways to solve it though, isn't it?
09:42:33 <quicksilver> your way is equational, his way is by execution on a VM?
09:43:11 <roconnor> ah right
09:43:23 <roconnor> I suppose I would need to use a "set" datatype
09:43:26 <roconnor> which is list modulo
09:43:49 <roconnor> permuations
09:44:17 <roconnor> I mean, I guess I don't mind working with equivalence relations on datatypes
09:44:43 <roconnor> but if we reify everything including Bind and Return ... It feels like we haven't explained anything.
09:49:43 <ski> PutStrLn ""  ~=  PutChar '\n'
09:49:57 <roconnor> oops
09:50:05 <roconnor> s/PutStrLn/PutStr
09:51:39 <quicksilver> yeah, my mistake :)
09:51:42 <quicksilver> not the main point though.
09:53:20 <ski> `<*>' in `Applicative' is a bad name anyway
09:54:33 <roconnor> it should be <@>
09:54:55 <ski> i don't want the `<' and `>' there
09:55:39 <ski> it suggests the operator being symmetric (or mostly so) .. (though maybe slightly less with `@' rather than `*')
09:57:36 <ski> what are we going to name the `\x f -> pure (flip ($)) <@> x <@> f' one ?
09:57:37 <quicksilver> it makes more sense if you compare it to <* and *>
09:57:39 <quicksilver> doesn't it?
09:58:50 <roconnor> >@<
09:59:44 <byorgey> the TIE fighter operator
09:59:51 <byorgey> mm, sort of
10:00:27 <gwern> }o{ <-- closer?
10:00:42 <byorgey> |-o-| ?
10:00:43 <ski> `<@' and `@>' could work for the basic operators .. then maybe `<@|', `<|@', `|@>', `@|>' for the "half-pure" versions, if you think you need them .. hmm
10:00:43 <Zao> |-o-|
10:01:46 <zachk> > logBase 3 (9*(9^(1/5)))
10:01:46 <byorgey> picking good operator symbols is hard.  let's go shopping!
10:01:48 <lambdabot>  Add a type signature
10:01:53 <gwern> byorgey: that would get you the basic TIE fighter, yes. now do darth vader's tie fighter!
10:01:58 <zachk> how do i get that work?
10:02:05 <zachk> <-o->
10:02:13 <mauke> > logBase 3 (9*(9**(1/5)))
10:02:14 <lambdabot>  2.4
10:02:27 <zachk> thank you mauke
10:02:29 <byorgey> zachk: ^ is only for positive integer exponents
10:02:41 <mauke> > 0^0
10:02:44 <lambdabot>  1
10:02:49 <quicksilver> ski: the return one side ones are very useful
10:02:51 <byorgey> er, nonnegative integer exponents =)
10:02:53 <quicksilver> ski: e.g. in parsers
10:03:07 <quicksilver> bracketedexpr = char '(' <* expr *> char ')'
10:03:21 <mauke> *> <*
10:03:25 <roconnor> > logBase 1 pi
10:03:26 <lambdabot>  Infinity
10:03:31 <ski> quicksilver : i suppose .. hm, i should go dig up some old laboration i had with such parser operators
10:03:36 <roconnor> > logBase 1 0
10:03:38 <quicksilver> more generally, this is a common idiom IMO : do { stuff; ret <- action; morestuff; return ret }
10:03:39 <lambdabot>  -Infinity
10:03:56 <dons> hehe,, http://www.reddit.com/info/6sfed/comments/
10:03:56 <lambdabot> Title: reddit.com: Go easy on the maintainance programmer: "eschew side effects and var ...
10:04:10 * ski would like to use some kind of reflection notation for this, though, instead ..
10:04:13 <quicksilver> preservingMatrix a = pushMatrix *> a <* popMatrix
10:04:17 <quicksilver> mauke: yes, thank you :)
10:04:28 <quicksilver> reflection notation?
10:04:55 <ski> quicksilver : an idea of mine that i should develop more, sometime
10:06:13 <ski> quicksilver : basically, locally side-effecting expressions, with notation for passing between pure and impure expressions
10:06:29 <quicksilver> hrm
10:06:46 <quicksilver> sounds a bit like the holy grail of applicative notation for side effects
10:06:57 <quicksilver> like the $( ) idea that was so roundly hated.
10:07:00 <quicksilver> (including by me!)
10:07:19 <dons> http://lalithsuresh.wordpress.com/2008/07/18/the-longest-twenty-days-of-my-life-comes-to-an-end/ ha
10:07:20 <lambdabot> Title: The longest twenty days of my life comes to an end& « LOL, ROTFL, WTF and my lif ..., http://tinyurl.com/5uxkvs
10:08:54 <mauke> empty page :(
10:10:15 <dons> awesome !  http://www.reddit.com/info/6sffn/comments/
10:10:17 <lambdabot> Title: reddit.com: Switching from CVS to darcs: a detailed analysis
10:10:44 <byorgey> "Haskell is the God of languages."
10:10:49 <dons> :)
10:11:01 <ski> quicksilver : hm, reference ?
10:11:15 <ski> (is that the one luqui was working on ?)
10:12:31 <lilachaze> :t <*>
10:12:32 <lambdabot> parse error on input `<*>'
10:12:37 <lilachaze> :t (<*>)
10:12:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:13:10 <dons> http://www.reddit.com/info/6sfg6/comments/
10:13:11 <lambdabot> Title: reddit.com: Chasing bottoms: writing tests for partial, non-terminating and infi ...
10:13:33 <byorgey> dons: going on a reddit spree?
10:13:44 <roconnor> Is <**> really used?  Can't we just remove it?
10:13:49 <quicksilver> ski: the one SPJ mentioned in a thread.
10:13:56 <quicksilver> ski: and everyone roundly pounced in
10:13:57 <dons> byorgey: i read my rss feeds in the morning :)
10:14:01 <quicksilver> ski: "monadic expressions" it was called.
10:14:10 <ski> quicksilver : i've missed that, i think
10:14:11 <dons> heh, is it just me, or is that darcs/cvs page in the same css style as my blog?
10:14:13 <DRMacIver> Gng. Again with that bloody "quicksort" example. :)
10:14:20 <byorgey> dons: but it's a quarter past one!  ;)
10:14:24 <dons> ?time
10:14:28 <lambdabot> Local time for dons is Fri Jul 18 10:14:25 2008
10:14:31 <quicksilver> ski: basically "foo bar $(baz) bam" as short hand for do x <- baz; foo bar x bam;
10:14:33 <dons> we are more civilised on the west coast :)
10:14:39 <byorgey> hehe
10:14:40 <dons> also , more barefoot at work.
10:14:48 <quicksilver> ski: but, allowing the $(...) to be nested arbitrarily in the expression.
10:14:52 <dons> and our coffee is better :)
10:15:00 <byorgey> dons: I am currently barefoot at work =)
10:15:04 <dons> hah
10:15:14 <byorgey> but I can't argue about the coffee.
10:15:23 <ski> roconnor : i've used it .. but i think the name is horrible
10:15:59 <ski> quicksilver : well, if it's just that, then it seems bad
10:16:00 <quicksilver> ski: http://www.haskell.org/pipermail/haskell-cafe/2007-August/029908.html
10:16:01 <lambdabot> Title: [Haskell-cafe] monad subexpressions, http://tinyurl.com/5bs3q9
10:16:05 <ski> ty
10:16:13 <quicksilver> ski:  it is bad, yes. But the underlying *desire* is there.
10:16:19 <quicksilver> applicative syntax is elegant.
10:16:41 <quicksilver> over-linearising a nested function application as part of the 'monadification' process is ugly.
10:17:00 <quicksilver> :t <**>
10:17:00 <lambdabot> parse error on input `<**>'
10:17:05 <quicksilver> :t (<**>)
10:17:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
10:17:08 <ski> quicksilver : or maybe i should say that is would be _incomplete_ with just that part
10:17:27 <quicksilver> the worst thing about it was choosing which 'do' block to hoist the monadic part into
10:17:35 <ski> exactly
10:17:38 <quicksilver> the answer given was 'closest syntactic do'
10:17:41 <quicksilver> which is ugly
10:17:44 <ski> this is bad
10:17:49 <quicksilver> because it breaks natural code rewriting
10:17:54 <ski> *nod*
10:17:57 <quicksilver> (or makes rewrites have surprising non-local effects)
10:18:17 <quicksilver> <**> is flip <*> ?
10:18:31 <FunctorSalad> hey... is there some existing todo-list project for haskell?
10:18:47 <ski> (i don't care about commuting "$(...)" not being a refactoring, though)
10:18:56 <roconnor> @src (<**>)
10:18:57 <lambdabot> (<**>) = liftA2 (flip ($))
10:19:39 <roconnor> liftA2 (flip f) =/= flip (liftA2 f)
10:19:40 <ski> given a commutative idiom, it is `flip (<*>)', yes
10:20:32 <quicksilver> ah good point.
10:20:38 <sclv_> FunctorSalad: http://www.haskell.org/haskellwiki/Wanted_libraries
10:20:39 <lambdabot> Title: Wanted libraries - HaskellWiki
10:20:44 <sclv_> But I think it could use quite a bit of updating.
10:20:47 <quicksilver> flip <*> without reordering the effects.
10:21:06 <quicksilver> so easy to make stupid errors :)
10:21:10 * quicksilver slaps quicksilver 
10:21:11 <sclv_> or oh... did you mean a program that handled todo lists, rather than a todo list of programs?
10:23:13 <lilachaze> > let (<*) = (>>); (*>) a b = a >>= ((b >>) . return) in Just 1 <* Just 2 *> Just 3
10:23:15 <lambdabot>  Just 2
10:23:48 <mauke> > 1 *> 2
10:23:50 <FunctorSalad> sclv_: yes :)
10:23:50 <lambdabot>        add an instance declaration for (Num (f b), Num (f a))
10:24:05 <mar77a> > _ <
10:24:05 <lambdabot>  Parse error in expression at end of input
10:24:28 <mauke> > Just 2 <* Just 3
10:24:30 <lambdabot>  Just 2
10:24:33 <mauke> > Just 2 <* Nothing
10:24:34 <lambdabot>  Nothing
10:25:03 <mauke> > Nothing <* undefined
10:25:04 <lambdabot>  Nothing
10:25:34 <lilachaze> @src <*
10:25:35 <lambdabot> (<*) = liftA2 const
10:25:40 <lilachaze> @src *>
10:25:41 <lambdabot> (*>) = liftA2 (const id)
10:26:56 <roconnor> > runIdentity $ 1 *> 2
10:26:57 <lambdabot>   add an instance declaration for (Num (Identity a1))
10:27:25 <roconnor> > runIdentity $ return 1 *> return 2
10:27:26 <lambdabot>        add an instance declaration for (Applicative Identity)
10:27:41 <roconnor> lambdabot: good idea
10:27:53 <lilachaze> hehe
10:28:26 <lilachaze> haskell really needs a way to say "instance Monad m => Applicative m" without overlapping everything :/
10:29:57 <FunctorSalad> lilachaze: what was the issue there, again? (forgot)
10:30:01 * lilachaze supposes that doesn't play well with dictionary-passing implementations
10:30:22 <lilachaze> FunctorSalad: the trouble is, the context isn't used when determining whether instances overlap
10:30:22 <Quadrescence> What might a multi-way tree be used for?
10:30:28 <ski> lilachaze : or something like the "superclass" proposal ..
10:30:50 <maltem> instance Monad m => Applicative (MonadA m) -- but newtypes are a hassle
10:31:49 <FunctorSalad> wasn't there some flag that allows overlapping instances?
10:32:00 <byorgey> Quadrescence: implementing a trie, perhaps?
10:32:15 <maltem> FunctorSalad: The issue was that with that declaration, there cannot be an instance Applicative m for any m other than this one
10:32:54 <maltem> right, -XOverlappingInstances iirc
10:33:07 <FunctorSalad> maltem: oh, so you can't instantiate any other applicatives whatsoever then?
10:34:00 <Quadrescence> byorgey: It's just a higher-order tree, right? e.g., a tree that branches off in 5 directions
10:34:18 <maltem> quite so. see, that m on the right-hand side matches any type, and the constraint will be checked only afterwards
10:34:39 <FunctorSalad> hmm that's strange
10:36:00 <shepheb> is there a reason why Data.Set.Set is not a Functor? It seems like it should even be an Applicative.
10:36:25 <lilachaze> FunctorSalad: ISTR that if you don't have that restriction, dictionary-passing implementations can use the wrong dictionary in some cases
10:37:02 <ski> shepheb : the `Ord' constraint
10:37:09 <FunctorSalad> lilachaze: sorry I don't know about dictionary-passing at all, but I think I vaguely understand ;)
10:37:23 <byorgey> or more generally implementing any sort of tree-like structure where the number of children is variable
10:38:05 <shepheb> ski: ah, I see. Thanks.
10:41:07 <FunctorSalad> so we need something like constrained_fmap :: (c a, c b) => a -> b -> f a -> f b ?
10:41:24 <FunctorSalad> hope I didn't get that horribly wrong
10:41:47 <FunctorSalad> (for the Set thing)
10:43:18 <maltem> Hm... Do we have a class variable extension?
10:45:02 <ski> constrained_fmap :: forall (f :: k -> *) . (a -> b) -> (f a -> f b)
10:45:14 <ski> maltem : meaning ?
10:45:50 <ski> (er .. of course that shouldn't be a `forall' there)
10:46:33 <ski> class FooFunctor (foo :< *) (f :: foo -> *) where foo_fmap :: (a -> b) -> (f a -> f b)
10:47:38 <ski> (where subkinding would include constrained types like `{ a :: * | Ord a }')
10:47:53 <FunctorSalad> can't you do FooFunctor (c :: * -> *) where foo_fmap :: (c a, c b) => (a -> b) -> (f a -> f b) ?
10:48:05 <ski> where is `c' bound ?
10:48:29 <ski> oh
10:48:30 <mcoram> @hoogle hashtable
10:48:32 <lambdabot> Data.HashTable :: module
10:48:32 <lambdabot> Data.HashTable.HashTable :: data HashTable key val
10:48:33 <FunctorSalad> hmm, I was thinking type OrdFunctor = FooFunctor Ord
10:48:38 <maltem> ski: see? c would be class variable
10:48:49 <ski> FunctorSalad : a constraint is not of kind `* -> *'
10:49:13 <ski> s/constraint/constraint predicate/
10:49:50 <lispy> This paper says that Haskell type equality is syntatic...But that seems weird to me.
10:50:00 * ski feels more confused by FunctorSalad's `type OrdFunctor = FooFunctor Ord'
10:50:30 <lispy> they say, t1 = t1' follows from t1 x t2 = t1' x t2' but that Haskell provides no way to prove this
10:50:33 <FunctorSalad> ski: sorry, I'm a bit of a newbie to haskell's advanced type features
10:51:12 <FunctorSalad> how do you parameterize over a constraint then?
10:51:48 <ski> you don't
10:52:18 <ski> this is something that could be useful, but i'm not aware of a proposal for it
10:52:48 <lispy> parameterize over a constraint?
10:53:03 <ski> *nod*
10:53:09 <lispy> data Foo = forall a. Show a => Foo a, like that?
10:53:15 <FunctorSalad> the idea is that functors should be able to have any "category" as domain, not necessarily the cat of *all* haskell types
10:53:25 <FunctorSalad> the constraint would define the domain
10:53:37 <ski> lispy : more like `data Foo foo = forall a. foo a => MkFoo a'
10:53:47 <ski> FunctorSalad : yes
10:53:47 <lispy> ski: ah
10:54:06 <lispy> I think you'd use witness types
10:54:15 <lispy> At least to approximate what you want
10:54:41 <ski> FunctorSalad : here, we're mostly thinking of subcategories .. but there's been applications of other categories as well (i.e. `* -> *' and higher ones)
10:54:55 <ski> s/subcategories/subcategories of `*'/
10:55:12 <ski> lispy : hm ? .. elaborate ?
10:55:28 <lispy> data Foo witness = Foo, then bar :: Show a => Foo a -> Int
10:56:03 <lispy> So then bar can only be called with showable Foos
10:58:08 <ski> i was wanting a type constructor `Foo' so that `MkFoo x :: Foo Show' would require the type of `x' to be in `Show'
10:58:34 <lispy> ski: no problem
10:59:00 <FunctorSalad> I'm really not enough of a language theorists to know which extensions of the type system would be sensible; it was just a thought
10:59:04 <lispy> ski: rename bar to mkFoo and export it from the Foo module but not the Foo constructor
10:59:27 <lispy> ski: You may also be able to do this directly with GADTs but I'm not sure
10:59:28 <ski> and matching ?
10:59:46 <lispy> data Foo a where MkFoo :: Show a => a -> Foo a -- would this do it?
11:00:11 <ski> (FunctorSalad : yes, we'd like "something" like this ..)
11:00:20 <ski> lispy : no
11:00:28 <ski> that doesn't abstract over `Show'
11:00:49 <lispy> ski: hehe, oh right.  I keep forgetting that Show should be the parameter
11:00:53 <ski> the point was that both `Foo Show', `Foo Ord', `Foo NotYetInventedClass' should be usable
11:01:19 * ski wonders what the "trinary" form of "both" is
11:01:48 <lispy> ski: 'each of' ;)
11:02:25 <lispy> ski: Have you considered Derive or DRiFT or whatever it's called?
11:03:15 <lispy> ski: if you think of a type class as a constraint, how do you type check something that has an arbitrary constraint?  How would you use this?
11:03:27 <ski> ("each of" is too unspecific)
11:04:24 <FunctorSalad> "for any of"?
11:04:32 <Quadrescence> data Foo = Bar1 | Bar2 | Bar3 |
11:04:32 <Quadrescence> 	Baz1 | Baz2 | Baz3
11:04:38 <FunctorSalad> maybe that just looks like natural language for us types though ;)
11:04:39 <Quadrescence> Is that legal syntax?
11:04:52 <Quadrescence> (if 2nd line is indented)
11:05:47 <lispy> Quadrescence: tabs are allowed in Haskell code, but they typically lead to issues with the layout rules
11:05:58 <lispy> Quadrescence: try replacing the tab with spaces
11:06:23 <Quadrescence> No, I mean, is that code actually valid?
11:06:25 <lispy> Quadrescence: but yeah, I don't really see a problem with that, what error are you getting?
11:06:30 <Quadrescence> None. :}
11:06:37 <Quadrescence> I didn't try compiling
11:06:39 <Quadrescence> My code's a mess.
11:07:11 <lispy> Quadrescence: what do you expect that code above to do?
11:07:12 <ski> lispy : that's part of the question, yes
11:07:33 <ski> (FunctorSalad : it should be specific to "three")
11:08:09 <lispy> ski: I say we coin the word, throth
11:08:15 <lispy> ?all-dicts throth
11:08:15 <lambdabot> No match for "throth".
11:08:19 <Quadrescence> lispy: create ... I don't know how they're called. Something of type Foo can be any of the types Bar1-3 or Baz1-3, like a subtype. I forgot the correct terminology.
11:08:27 <lispy> ski: or threeth
11:08:47 <ski> lispy : of course we'd like versions for "one" and "zero", too :)
11:09:12 <lispy> Quadrescence: okay, you're clearly new to Haskell but I think your understanding sounds close enough :)  No more quizzes, you may go play now ;)
11:09:32 <Quadrescence> lispy: Indeed I am new. :P
11:09:33 <lispy> (and by play I mean, write some code)
11:09:36 * ski wondered some time ago what comes before "once","twice","thrice"
11:09:37 <Quadrescence> Haha
11:10:01 <lispy> ski: nonece :)
11:10:23 <byorgey> Quadrescence: just fyi, the correct terminology is that Foo is a type, and Bar1..3 and Baz1..3 are its constructors
11:10:34 <Quadrescence> Yes, yes, that's it.
11:10:42 <byorgey> so a value of type Foo can be constructed using any one of those six constructors
11:10:49 <byorgey> =)
11:10:58 <Quadrescence> Yes. I was more unsure about splitting lines.
11:10:59 <Quadrescence> :P
11:11:13 <byorgey> fair enough =)
11:11:20 <ski> Quadrescence : if you'd like, we can publicly castigate your code .. just @hpaste it
11:11:34 <tibbe> I'm having with the GHCi debugger, it's printing *** Exception : Prelude.head: empty list all the time. I don't use head in my program and the problem only shows up during debugging
11:11:40 <Quadrescence> ski: It may come to that. :D But not yet, hehe.
11:11:40 <lispy> Quadrescence: ah, well in that case, the typical way to write it is data Foo = Bar1<RET><space over till the '=' sign>| Bar2.
11:11:48 <ski> lispy : and pronounciation ?
11:11:55 <hackage> Uploaded to hackage: sessions 2008.7.18
11:11:55 <hackage> Uploaded to hackage: OpenAFP-Utils 1.2
11:11:55 <hackage> Uploaded to hackage: feed 0.3.2.1
11:11:56 <hackage> Uploaded to hackage: network-multicast 0.0.3
11:11:58 <hackage> Uploaded to hackage: network-multicast 0.0.2
11:12:08 <lispy> ski: Well, since I just made it up...."once"-ce
11:12:12 <lispy> ski: gah
11:12:16 <lispy> ski: I meant "none"-ce
11:12:24 <Quadrescence> lispy: I still don't understand tabs and spaces and all that (for indentation/layout)
11:12:27 <Quadrescence> :\
11:12:28 <ski> "nonce" ?
11:12:44 <lispy> ski: yeah, but I was worried without the e that it would become "non"-ce
11:12:49 <ski> just don't mix tabs and spaces for indentation
11:13:21 <FunctorSalad> alternatively, just use the non-layout syntax ;)
11:13:35 <Quadrescence> FunctorSalad: If that means {}, no.
11:13:39 <Quadrescence> :D
11:14:48 <ski> you don't like curly brackets and semis ?
11:15:37 <Quadrescence> Well, they are good, I guess. But I prefer a little cleaner code.
11:16:40 <Quadrescence> So can I indent 10 spaces, for example, inside
11:16:45 <Quadrescence> inside one data
11:16:51 <Quadrescence> and ten 20 inside another?
11:17:11 <Quadrescence> (not the actual line saying "data", but the lines after which are apart of the type)
11:17:29 <Quadrescence> (and then*)
11:17:51 <ski> yes
11:18:03 <Quadrescence> mmmmm, okay.
11:18:09 <ski> each block is independent of other, non-nested ones
11:18:14 <byorgey> Quadrescence: yes, in haskell people tend to indent things so they look nice and line up locally, as opposed to always indenting n spaces
11:18:39 <mauke> not me!
11:18:57 <byorgey> *(except mauke)
11:18:57 <Quadrescence> Ah. I read something and I interpreted it as "the first indentation must stay constant through the rest of the code." I guess I see what they mean there.
11:19:19 <byorgey> Quadrescence: the first indented line at the beginning of a block must stay constant through the rest of the block.
11:19:23 <kaspyanand> hi
11:19:29 <kaspyanand> sum $ filter (\n -> n `mod` 3 == 0 || n `mod` 5 == 0) $ [1..999]
11:19:32 <chrisdone> evening
11:19:34 <Quadrescence> Right, right. Just local indenting matters. :}
11:19:40 <mauke> the first non-{ token determines the base indentation for the following block
11:19:42 <kaspyanand> what does $ do?
11:19:45 <byorgey> well, technically: the first line which is indented *less* than the opening line of a block, closes the block.
11:19:48 <mauke> kaspyanand: nothing :-)
11:19:59 <mauke> @src ($)
11:20:00 <lambdabot> f $ x = f x
11:20:14 <FunctorSalad> kaspyanand: enclose everything to the right of it in parentheses, more or less
11:20:18 <byorgey> kaspyanand: it is just function application with a low precedence, used to avoid writing too many parentheses
11:20:28 <byorgey> so f $ x y z  is the same as f (x y z)
11:20:38 <kaspyanand> k
11:20:45 <byorgey> because otherwise, f x y z is parsed as (((f x) y) z)
11:21:25 <chrisdone> does Î»b have factoids? this question pops up ten times a day, maybe it could be added as a factoid
11:22:00 <FunctorSalad> @quote
11:22:01 <lambdabot> sorear says: (after someone complains of ghc using much memory) Only 500M?  encode for lists is strict, I would have expected around 80GB usage...
11:22:07 <ski> @factoid-add factoid see @list factoid
11:22:08 <lambdabot> Unknown command, try @list
11:22:22 <byorgey> Quadrescence: just remember to put 'then' and 'else' on separate indented lines after an if  (like  'if foo\n  then blah\n  else bar') and you should be fine =)
11:22:33 <byorgey> if statements inside do-blocks are what trip up the most people
11:22:42 <byorgey> better yet, just don't use if statements at all =D
11:22:47 <byorgey> use guards instead
11:22:52 <Quadrescence> byorgey: Yep, thanks for the reminder. :)
11:22:56 <Quadrescence> I have been using guards.
11:22:57 <Quadrescence> :))
11:22:59 <ski> s/statements/expressions/
11:23:00 <byorgey> excellent =)
11:23:07 <chrisdone> if statements should be an extension
11:23:27 <byorgey> ski: yes, good catch
11:23:32 <FunctorSalad> byorgey: I'm guilty of using if's in "sanity checks"... is there some nicer way?
11:23:36 <Quadrescence> Complete the sentence: _________ come after 'do' statements.
11:23:50 <mauke> "pain and suffering"
11:23:55 <Quadrescence> :D
11:23:56 <byorgey> 're' statements?
11:23:57 <ski> byorgey : i'm just a bit pedantic with terms, sometimes
11:23:58 <chrisdone> the horsemen
11:24:13 <byorgey> ski: heh, so am I, I was about to correct myself ;)
11:24:13 <bd_> Quadrescence: lexical tokens!
11:24:15 <Quadrescence> I don't know the answer. I just don't know what can and can't come after do.
11:24:33 <Apocalisp> imperatives
11:24:48 <byorgey> Quadrescence: well, a do-block is just an expression
11:24:51 * ski 's heard "statements" in programming would better be called "commands"
11:24:52 <mauke> Quadrescence: "do" itself is not a do statement
11:24:59 <FunctorSalad> "do statements"
11:25:00 <FunctorSalad> ?
11:25:03 <Apocalisp> oh, you mean in Haskell!
11:25:11 <Quadrescence> Sowwie. :{
11:25:31 <Quadrescence> Please pardon my vocabulary usage.
11:25:37 <chrisdone> @help fact-set $ is just function application with a low precedence, used to avoid writing too many parentheses. also, see @src ($)
11:25:37 <lambdabot> Define a new fact, guard if exists
11:25:41 <chrisdone> @fact-set $ is just function application with a low precedence, used to avoid writing too many parentheses. also, see @src ($)
11:25:41 <lambdabot> Fact recorded.
11:25:46 <chrisdone> @fact $
11:25:46 <lambdabot> $: is just function application with a low precedence, used to avoid writing too many parentheses. also, see @src ($)
11:25:54 <ski> ooh
11:26:03 <byorgey> Quadrescence: the only place 'after' makes sense (i.e. the only place you have a 'sequence' of 'statements') is inside a do-block
11:26:16 <byorgey> Quadrescence: so in some sense it doesn't make sense to ask what can come 'after' a do block
11:26:22 <ski> @fact @fact
11:26:22 <lambdabot> I know nothing about @fact
11:26:30 <FunctorSalad> @fact cat
11:26:31 <lambdabot> I know nothing about cat
11:26:31 * chrisdone chortles
11:26:36 <FunctorSalad> no cat memes?
11:26:43 <byorgey> a do-block can be used anywhere an expression of its type (m a   for some monad m and type a) can be used
11:26:54 <ski> @fact-set @fact @fact tells you about facts
11:26:55 <lambdabot> Fact recorded.
11:27:02 <mauke> preflex: store $ $ is just function application with low precedence, used to avoid writing parentheses: f $ x = f x
11:27:03 <chrisdone> cat watch.txt | ceiling
11:27:12 <FunctorSalad> hehe
11:28:03 <DrSyzygy> Yo FunctorSalad
11:28:39 <FunctorSalad> hmm, is there some way to *search* the fact database?
11:28:49 <FunctorSalad> hi DrSyzygy :)
11:28:57 <chrisdone> I wonder if Î»b plugins can have state. if it's true, it might be a good idea to ignore repeated facts within a certain time frame. I envisage âwhat's $?â and then three people typing â@fact $â and spamming the channel
11:28:58 <ski> @list fact
11:28:58 <lambdabot> fact provides: fact fact-set fact-delete fact-cons fact-snoc fact-update
11:29:12 <byorgey> Quadrescence: don't worry about the vocabulary, sometimes we can be a bit pedantic in here but it's never intended to ostracize newbies =)
11:29:27 <Quadrescence> Haha, :))
11:29:51 <byorgey> DrSyzygy: hey, your nick is very similar to this other guy who used to hang out in here... ;)
11:29:53 <ski> chrisdone : well, it should call `@quote stereo' automatically, at least
11:30:08 <chrisdone> @quote stereo
11:30:09 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
11:30:17 <Quadrescence> Are Words slower than Ints?
11:30:18 <chrisdone> ski: ah :)
11:30:19 <mauke> @quote fugu
11:30:19 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:30:23 <byorgey> wasn't that 'majestic' stereo?
11:30:35 <ski> istr so, too
11:30:47 <byorgey> it's like @quote telephone
11:30:58 <Quadrescence> Since a Word of size n performes a mod 2^n each time...?
11:31:13 <byorgey> hm, is that just an american game?  or have other people played Telephone too?
11:31:19 <mauke> so do ints
11:31:23 <ski> > (-1) :: Word
11:31:24 <lambdabot>  4294967295
11:31:35 <mauke> > 100000000000000 :: Int32
11:31:39 <lambdabot>  276447232
11:32:06 <byorgey> Quadrescence may have a point, though, since the mod for Int is presumably done in hardware
11:32:16 <byorgey> but I doubt it really makes any appreciable difference
11:32:18 <Quadrescence> Okay, so their range is just translated.
11:32:43 <Quadrescence> (translated, like, rolled over to the + axis) :D
11:32:57 <byorgey> Quadrescence: but unless you really really really care about performance, or are doing some sort of low-level bit twiddling, you should be using Integer anyway =)
11:33:15 <mauke> anyone remember MegaMonad?
11:33:18 <Quadrescence> byorgey: I care about memory.
11:33:19 <chrisdone> @users
11:33:19 <lambdabot> Maximum users seen in #haskell: 473, currently: 450 (95.1%), active: 15 (3.3%)
11:33:22 <ski> mauke : yes
11:33:32 <mauke> there's a megahal on twitter now: http://twitter.com/GumbyBRAIN
11:33:33 <lambdabot> Title: Twitter / GumbyBRAIN
11:33:41 <byorgey> Quadrescence: ok, well, that falls under performance I guess
11:34:39 <Quadrescence> Why can't there be a Word4 or Int4. /me sniffles and complains.
11:35:13 <Botje> mauke: gumby + twitter = utter and complete <3
11:35:29 <FunctorSalad> 4 bit? isn't that called a "nibble"?
11:35:50 <Quadrescence> Yes
11:35:51 <Quadrescence> :D
11:35:59 <chrisdone> quatet?
11:36:01 <lament> nybble
11:36:06 <Botje> import Data.Nipple already
11:36:13 <ski> `Int19' ftw
11:36:14 <Quadrescence> nibble or nybble
11:36:17 <Quadrescence> :O
11:36:38 <mauke> Int21 please
11:36:48 <ski> `21' is not prime
11:37:07 <mauke> but I need it for unicode
11:37:19 <ndmitchell> mauke: Char = Int21
11:37:39 <mauke> but Char is not a Num!
11:37:42 <ndmitchell> > fromEnum $ maxBound :: Char
11:37:43 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
11:37:52 <mauke> > ord maxBound
11:37:53 <lambdabot>  1114111
11:38:13 <ndmitchell> the make Char an instance of Num
11:38:33 <mauke> also, Int0x80 for system calls
11:40:08 <humasect> hello friends. i am having multiple declaration warning/error when using pattern matching
11:40:10 <FunctorSalad> (nom (nom (nom ...)))
11:40:28 <ndmitchell> humasect: hpaste the code?
11:40:30 <ndmitchell> @hpaste
11:40:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:40:32 <humasect> ok
11:40:51 <byorgey> humasect: just a guess without seeing your code, you can't use pattern matching to test whether two arguments are the same, like  foo x x = ...
11:40:54 <ndmitchell> and the error message as well, if you can
11:40:57 <byorgey> but if that's not it, yes, paste the code =)
11:41:09 <humasect> byorgey: thanks=) i think its much simpler even than this
11:41:26 * ndmitchell is going to guess at redundant final case, which is possibly not actually redundant
11:41:34 <ndmitchell> (but only guesses until the code comes up)
11:42:38 <humasect> hm, it hasn't announced. here it is : http://hpaste.org/9010
11:43:00 <Quadrescence> Someone (WEASLE WORD) told me that Haskell has very very poor memory management/uses a lot of memory at runtime, and that I should switch to Python. :O
11:43:03 <humasect> i am thinking because the definitions are seperated by some code in between for other definitons.
11:43:06 <ski> the `]' should be indented more
11:43:28 <mauke> Quadrescence: I give it 1/10
11:43:33 <humasect> ski: oh, and if it is the only level of [] ?
11:43:41 <BMeph> s/"Cube"/Resource "Cube"/
11:43:50 <ski> humasect : sorry ?
11:43:58 <dons> Quadrescence: hah.
11:43:59 <humasect> ski: wouldn't that create scope and not have definition conflicts ?
11:44:02 <ndmitchell> humasect: is teh warning "incomplete patterns" ?
11:44:04 <humasect> BMeph: hm interesting =)
11:44:08 <dons> Quadrescence: that's really funny :)
11:44:30 <ndmitchell> humasect: in which case its just GHC grumbling, and you can happily ignore it
11:44:32 <humasect> ndmitchell: "Multiple declarations of `Room00.vertices'" - showing those two locations (not the first :: decl)
11:44:36 <Quadrescence> I personally really wouldn't know. I haven't run anything yet seriously.
11:44:41 <dons> Quadrescence: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=python
11:44:42 <ski> BMeph : ?
11:44:42 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel® Pentium® 4 Computer Language Benchmarks ..., http://tinyurl.com/2deng4
11:44:45 <Botje> humasect: yeah, don't put code in between?
11:44:50 <Botje> that confuses ghc.
11:44:55 <BMeph> Someone told me that Haskell has very dense and hard-to-read code, and that I should switch to Lisp... ROFL!
11:44:56 <dons> Quadrescence: the black lines are memory use, the white lines cpu time.
11:44:59 <ndmitchell> humasect: try putting the close bracket ] one space in
11:45:10 <humasect> Botje: hmm that is difficult for how the file is generated. i am hoping to track it down for sure and see if the work needs to be put into that
11:45:10 <lament> haskell is very dense and hard to read, you should switch to J
11:45:14 <Quadrescence> dons: AHhahahahahah :D :D
11:45:20 <humasect> ndmitchell: k
11:45:22 <dons> Quadrescence: so haskell's on  average usinng about 3x less memory, while being 20x faster.
11:45:36 <Quadrescence> lament: I was thinking about J before I decided on Haskell. :O
11:46:13 <humasect> ndmitchell: hmm nope.
11:46:22 <Quadrescence> Haskell seems to have my money so far. :))
11:46:43 <ski> BMeph : you should switch to Lazy-K
11:46:44 <ndmitchell> humasect: can you hpaste the exact error message?
11:46:55 <BMeph> humasect: Never mind, I'm looking at the wrong kind of problem. :)
11:47:06 <ski> (BMeph : or Unlambda, if you like side-effects)
11:47:09 <humasect> BMeph: it's ok, thanks=) i was going to ask if i should use 'resource a' this way
11:47:19 <BMeph> humasect: ...oh, never mind my never mind, too. :)
11:47:23 <BMeph> ski: Huh?
11:47:27 <humasect> BMeph: =)
11:47:42 <BMeph> ski: Ah, the Lisp joke. :)
11:48:18 <ndmitchell> humasect: are you really sure you added a single space character before each ]? I just tried the file, it didn't work, adding the spaces made it work
11:48:21 <humasect> ok great, it seems to work when the vertices 'String' definitions are cuddled together. this is a lot of work now .. in python script which i was hoping to avoid
11:48:40 <humasect> ndmitchell: oh, before them? sorry my misunderstanding
11:48:44 <ski> BMeph : though if you can't decide between Haskell and Lisps, then Liskell might be for you
11:48:52 <ski> @where liskell
11:48:52 <ndmitchell> humasect: yeah
11:48:52 <lambdabot> http://clemens.endorphin.org/liskell
11:48:59 <ndmitchell> i've hpasted a working version http://hpaste.org/9010#a1
11:49:34 <BMeph> ski: I'd honestly be more impressed with an EDSL in Lisp that used Haskell syntax. >:)
11:49:58 <humasect> ndmitchell: oh i see, my bad. the hpaste has the ] aligned with the definitions. they are aligned with the "Vertex3..." indents
11:50:17 <ski> BMeph : including macros for haskell ?
11:50:28 <humasect> ndmitchell: i will fix this.
11:50:35 <ndmitchell> humasect: so do you have it working now, or not? if not, could you paste the entire file
11:50:38 <FunctorSalad> that benchmark diagram is ridiculously confusing ;)
11:51:05 <BMeph> ski: (Shrugs) It's Lisp - it's not fit for human consumption without macros... ;)
11:51:35 <BMeph> FunctorSalad: Eh? The shoot-out?
11:51:37 <humasect> ndmitchell: http://hpaste.org/9010#a2
11:52:14 <FunctorSalad> BMeph: yes. why not just put "python better" on the left and "ghc better" on the right ;)
11:52:35 <FunctorSalad> I took quite a while to notice that "better" and "worse" are inverted on top/bottom
11:52:37 <ski> maybe haskell (implementations ?) should have something like prolog's `discontiguous'
11:52:51 <ndmitchell> humasect: you can't do that, you have to merge it up
11:52:59 <humasect> ndmitchell: okay, i thought so=)
11:53:13 <humasect> you guys are awesome, thank you so much. each and every one of you generous souls =)
11:54:19 <ndmitchell> humasect: http://hpaste.org/9010#a3 - a way you can do something similar
11:55:06 <humasect> ndmitchell: interesting, is there much overhead ?
11:55:24 <ndmitchell> humasect: assume none, probably virtually none and in some cases actually none
11:55:57 <humasect> =D fantastic then. thank you~
11:56:04 <ndmitchell> i.e. the compiler may remove it entirely, but even if it doesn't you are talking a handful of instructions at most
11:56:09 <ski> hm .. `(vertices &&& normals) "Cube" = (,) [...] [...]' ..
11:57:14 <humasect> over 400 people here ... wasn't it 100 only perhaps a year or so ago ?
11:57:17 <ndmitchell> you are likely to get a bigger speedup, and nicer code, from data Shape = Cube | Sphere ...
11:57:31 <FunctorSalad> ski: that works?
11:57:32 <ndmitchell> @google haskell irc channel statistics
11:57:41 <ski> humasect : maybe 300 .. not 100 i think
11:57:41 <humasect> ah &&& and (,) are new to me
11:57:42 <lambdabot> No Result Found.
11:58:07 <ski> humasect,FunctorSalad : note that my "hm ..." doesn't actually work in haskell :/
11:58:10 <humasect> ndmitchell: instead of string constant ? it can be done
11:58:21 <humasect> heh
11:58:25 <ndmitchell> humasect: yep, just standard data types
11:58:34 <Quadrescence> humasect: Well, the nice population here attracts people. Unlike other pla_C_es. How'd those underscores get there?
11:58:35 * ski was just pondering aloud
11:58:39 <ndmitchell> in Haskell you have data Bool = False | True, its just normal
11:58:43 <humasect> Quadrescence: =) =)
11:59:03 <FunctorSalad> humasect: (f &&& g) x = (f x, g x)
11:59:08 <roconnor> @src Bool
11:59:09 <lambdabot> data Bool = False | True deriving (Eq, Ord)
11:59:10 <ndmitchell> ski, i've seen programming extensions to things like Haskell proposing them - and concluded they are a really really bad idea
11:59:28 <ski> ndmitchell : "them" specifically being ?
11:59:28 <humasect> ndmitchell=)
11:59:37 <sutats_> Is there any way to have yi not depend on any GUI libraries and just run on the terminal?
11:59:39 <FunctorSalad> (for f and g functions, &&& is a bit more general)
11:59:57 <byorgey> @remember Quadrescence [on #haskell] Well, the nice population here attracts people. Unlike other pla_C_es. How'd those underscores get there?
11:59:58 <lambdabot> I will remember.
12:00:01 <byorgey> hehehe
12:00:10 <humasect> FunctorSalad: i haven't got this smart yet. =)
12:00:15 <ndmitchell> ski, function patterns, invertable LHS's - basically running functions on the LHS of an =
12:00:27 <Quadrescence> byorgey: ahahha :]]]
12:00:35 <FunctorSalad> (subst my comma there by a period)
12:00:47 <ski> ndmitchell : i suspect that, done right, they could be quite handy
12:00:49 <ndmitchell> they usually go crazy around the time that:  f (a ++ "es") = ...
12:01:06 <ndmitchell> i.e. so a pattern that matches "neiles" etc
12:01:14 <FunctorSalad> humasect: I was just trying to say how &&& is defined if f and g are some functions :)
12:01:26 <ski> ndmitchell : if i'm not mistaken, something like that is possible in Mercury
12:01:28 <byorgey> Quadrescence: you have just earned yourself a place in the quotes section of the next issue of the Haskell Weekly News, my friend ;)
12:01:53 <ndmitchell> byorgey: i passed my PhD viva, subject to minor corrections this week
12:01:53 <eao08g> @pl addNeg a b = negate (a + b)
12:01:54 <lambdabot> addNeg = (negate .) . (+)
12:01:56 <eao08g> Why does the pointful version have type Num a => a -> a -> a
12:01:56 <eao08g> but the point-free version has type Integer -> Integer -> Integer?
12:01:56 <eao08g> I've verified this in GHCi and WinHugs
12:01:58 <ndmitchell> is that a HWN style thing?
12:02:05 <humasect> FunctorSalad: yes i know=) oh wait .. i understand &&& now. thanks=)
12:02:10 <byorgey> ndmitchell: congrats!
12:02:13 <ndmitchell> eao08g: its defaulting rules
12:02:15 <ski> (ndmitchell : and beware, i have some *quite* more strange pattern ideas than that :)
12:02:19 <byorgey> ndmitchell: indeed it is
12:02:24 <Quadrescence> byorgey: Heheheh. I think I made it in the quotes twice today. :O :/
12:02:26 <ndmitchell> eao08g: fairly complex rules
12:02:42 <byorgey> Quadrescence: ah, so you did =)
12:02:50 <Quadrescence> Maybe. I don't really remember.
12:02:50 <ndmitchell> ski: its a place people like to innovate :)
12:02:56 <byorgey> Quadrescence: I don't always include every single thing that was @remembered in the HWN though
12:03:06 <Quadrescence> Oh, I see. :}
12:03:26 <Quadrescence> What is this HWN? (recall I started Haskell about < 1 week ago.)
12:03:33 <ski> ndmitchell : the two main problems are declarativity and implicit quantification, as i see it ..
12:03:35 <Quadrescence> s/what/where/
12:03:48 <ndmitchell> @remember byorgey I don't always include every single thing that was @remembered in the HWN
12:03:48 <lambdabot> Nice!
12:04:02 <ski> @where hwn
12:04:02 <lambdabot> http://sequence.complete.org/
12:04:10 <byorgey> Quadrescence: it's posted to the haskell@haskell.org and haskell-cafe@haskell.org lists, and also to sequence.complete.org
12:04:12 <ndmitchell> ski, i find predictability quite important for patterns
12:04:20 <ski> *nod*
12:05:05 <ndmitchell> but really love pattern guards - the new SPJ ones
12:05:22 <ndmitchell> however, i would love to do $ on the LHS
12:05:50 <FunctorSalad> @type \x -> ((negate .) . (+)) x
12:05:56 <lambdabot> forall a. (Num a) => a -> a -> a
12:06:01 <ski> ndmitchell : i'm not claiming any of the proposed extensions are well-designed (i haven't seen that many, though), i'm not claiming these ideas will lead to any useful things .. i'm just not convinced they must be bad, if Done Right [tm]
12:06:02 <FunctorSalad> eta (?) expansion ftw ;)
12:06:39 <ski> @type ((negate .) . (+))
12:06:40 <lambdabot> forall a. (Num a) => a -> a -> a
12:06:47 <ndmitchell> ski, perhaps - I'll wait to see a well designed one :)
12:07:03 * ski smiles
12:07:11 <FunctorSalad> ski: hmm, eao08g said it was Integer -> Integer -> Integer
12:08:16 <byorgey> eao08g: the difference is because of the Dreaded Monomorphism Restriction
12:08:17 <ski> FunctorSalad : eao08g presumably bound a variable to this expression, which the DMR then happily attacked
12:08:35 <ski> @type let foo = ((negate .) . (+)) in foo
12:08:35 <lambdabot> forall a. (Num a) => a -> a -> a
12:08:50 <byorgey> ski: maybe it's turned off in \bot
12:08:51 * ski ponders
12:09:23 <chr1s> hey all, we wrote this binding to libstemmer. all of our code resides in the IO monad, so we were thinking of using unsafePerformIO
12:09:25 <byorgey> eao08g: suffice it to say that for various obscure reasons, by default bindings with no parameters (like foo = ...,  not foo x y = ...) cannot be given polymorphic types
12:09:26 <ski> i'm not sure
12:09:42 <byorgey> eao08g: you can always solve this by giving an explicit type signature, or adding a parameter
12:09:51 <chr1s> that's perfectly legal for this cause, because our functions are referentially transparent, so no problem.
12:09:51 <byorgey> you can also turn off the monomorphism restriction.
12:09:52 <ski> byorgey : s/polymorphic/constrained/
12:09:59 <byorgey> er, right, thanks ski
12:10:28 <chr1s> however, at the end we need to free a pointer. is there a way we can still do this without exposing it to the user?
12:10:54 <eao08g> I'll read up on the defaulting rules and DMR, I just found it very strange
12:10:56 <eao08g> thanks
12:11:57 <hackage> Uploaded to hackage: line2pdf 0.0.6
12:12:10 <chrisdone> haha, this is how much quicksilver eclipses everyone else in #haskell, with quicksilver, http://chrisdone.com/haskell.png and without: http://chrisdone.com/haskell-sans-quicksilver.png
12:12:22 <RayNbow> > sequence [even,odd] 3
12:12:26 <lambdabot>  [False,True]
12:12:59 * RayNbow is slowly starting to understand that :p
12:13:42 <chrisdone> > (even &&& odd) 3
12:13:44 <lambdabot>  (False,True)
12:14:09 <humasect> hey i can do (,,) as well. is there a third for fst, snd ?
12:14:26 <shepheb> @hoogle thrd
12:14:39 <lambdabot> No matches found
12:14:53 <shepheb> I thought some Data. library defined frst, scnd, thrd?
12:16:57 <Deewiant> Data.Tuple is to have them in the next release, I think?
12:17:08 <ski> chrisdone : <http://www.cse.unsw.edu.au/~dons/irc/haskell-08.html>
12:17:15 <RayNbow> @djinn (a,b,c) -> c
12:17:15 <lambdabot> f (_, _, a) = a
12:18:06 <ski> chrisdone : how long timespan is you pics for ?
12:18:08 <chrisdone> ski: yeah, mine was just today
12:18:14 <ski> s/you/your/
12:18:19 <ski> ok
12:18:29 <dolio> Whoa, I've been talking too much. I'm on the list.
12:18:51 <chrisdone> nice to see Ubuntu's reflects what you'd expect: http://chrisdone.com/ubuntu.png
12:19:18 <chrisdone> "my" "me" "how" me, me, me!
12:19:23 <Deewiant> "monad" is the 8th-most used word? O_o
12:19:25 <byorgey> humasect: no, there isn't
12:19:37 <byorgey> humasect: you can write your own though.
12:19:52 <humasect> byorgey: ok, thanks. it looks like i have to do it another way anyway ^_^
12:19:52 <sclv_> ?ty \(f,g) -> (. g) *** fmap f
12:19:54 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *). (Functor f1, Functor f) => (a1 -> b1, f a) -> (a -> b, f1 a1) -> (f b, f1 b1)
12:19:54 <ski> "lambdabot has quite a potty mouth. 0.0% words were foul language."
12:20:00 <chrisdone> Deewiant: disregarding boring words like "the", "a", "there", etc.
12:20:08 <sclv_> any nice idea how to describe the above function?
12:20:22 <Deewiant> chrisdone: sure, but I still find it a bit surprising
12:20:33 <Deewiant> I guess it's just all the newbies coming here, asking "what's a monad" and leaving :-P
12:20:51 <byorgey> chrisdone: cool, is this the cloud-layout stuff you've been working on?
12:21:11 <dolio> We need to get "pimpmobile" higher up on that list.
12:21:28 <dolio> And "daffodil".
12:21:28 <chrisdone> byorgey: yep!
12:22:29 <byorgey> chrisdone: nice.  how does it work?  is it just a greedy biggest-to-smallest layout?  or does it try to do any global analysis?
12:22:51 <chrisdone> byorgey: just biggest to smallest, I would think
12:23:27 <byorgey> chrisdone: 'I would think'?  I thought you wrote the code that did the layout
12:23:47 <dolio> So people say flannel a lot?
12:23:49 <chrisdone> byorgey: yeah, I did. I'm not too sure about what you mean by global analysis
12:23:50 <ski> hm .. "think" is the most used word, it claims
12:23:50 <sclv_> it really has an operational signature of (a -> b, c -> d) -> (d -> e, f -> a) -> (c -> e, f -> b)
12:24:17 <sclv_> also, pimpmobile
12:24:31 <byorgey> chrisdone: oh, I just meant does it try to somehow take into consideration the sizes of all the items before deciding where to place anything
12:24:36 <b\6> flannel? it seems strange to say flannel a lot. flannel is not such a common word. i had a dog once named flannel. i made him wear flannel shirts. flannel.
12:24:41 <sclv_> I have something that doesn't quite fit arrow or bifunctor here...
12:24:48 <byorgey> but a greedy biggest-to-smallest approach sounds quite reasonable to me =)
12:25:03 <Quadrescence> b\6: http://www.google.com/search?q=flannel+ubuntu&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:en-US:official&client=firefox-a
12:25:04 <lambdabot> Title: flannel ubuntu - Google Search, http://tinyurl.com/5hj4ra
12:25:09 <chrisdone> byorgey: it places from largest to smallest. on each word, it tries to place it around the biggest word, if it can't, it tries the next largest word, until it will eventually get to the "outer edge" and have space
12:25:26 <ski> sclv_ : looks almost like composition in an `C^op * C' category
12:25:28 <byorgey> chrisdone: I see, cool
12:25:41 <byorgey> pimpmobile?
12:25:42 <chrisdone> byorgey: then I have a small variation of that where it chooses words to sit next to depending on distance from the centre, creating a circular cloud, let me find an example..
12:26:00 <chrisdone> byorgey: http://img525.imageshack.us/img525/9571/cloudsba1.png
12:26:01 <FunctorSalad> sclv_: isn't that just a crossed over (in two ways) composition?
12:26:28 <sclv_> yeah, its a special sort of composition. i'm just trying to think how to generalize it...
12:26:38 <ski> (well, `C^op * D' ..)
12:26:41 <dolio> @djinn (a -> b, c -> d) -> (d -> e, f -> a) -> (c -> e, f -> b)
12:26:47 <lambdabot> f (a, b) (c, d) = (\ e -> c (b e), \ f -> a (d f))
12:26:56 <chrisdone> byorgey: you sound like you've done some stuff like this before? *interest*
12:27:08 <ski> @. pl djinn (a -> b, c -> d) -> (d -> e, f -> a) -> (c -> e, f -> b)
12:27:09 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip (flip . (((.) . (,)) .) . flip (.)) . (.))
12:27:15 <byorgey> chrisdone: uh, not really =)
12:27:17 <ski> there you go
12:27:21 <chrisdone> byorgey: oki :P
12:27:32 <sclv_> I have things of type (a -> (b->b), b-> a) and want to compose them with things of type (a->b,b->a) and end up with that...
12:27:40 <byorgey> chrisdone: I thought about it some when writing a C-to-Befunge compiler once
12:27:41 <FunctorSalad> lambda (f1, f2) (g1, g2) -> (g1 . f2, g2 . f1), it seems
12:27:50 <byorgey> but didn't really end up doing anything sophisticated =)
12:27:59 <chrisdone> byorgey: hehe, cool
12:28:38 <dolio> byorgey: It's from Bender's top 10 most commonly said words.
12:29:15 <humasect> @hpaste
12:29:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:29:22 <ski> FunctorSalad : rather `\(f1, f2) (g1, g2) -> (g1 . f2,f1 . g2)'
12:29:39 <FunctorSalad> ski: right
12:29:46 <sclv_> It would be nice to fit what I'm doing into an idiom from Control.Arrow or TypeCompose or the like.
12:30:00 <humasect> http://hpaste.org/9011
12:30:44 <chrisdone> > arr (++"!") "test"
12:30:57 <lambdabot>  "test!"
12:30:58 <ski> simple. we just first need to implement kind-arguments to type classes, so we can instantiate `Control.Arrow' over `(*,*)' .. and maybe a few more things
12:33:01 <sclv_> I'm sure it relates to http://hackage.haskell.org/packages/archive/TypeCompose/0.5/doc/html/Data-Bijection.html
12:33:07 <lambdabot> Title: Data.Bijection, http://tinyurl.com/6kldz4
12:33:09 <sclv_> But thinking through just how makes my head hurt.
12:33:32 <FunctorSalad> it's a bit like division of fractions of functions : (g1/g2) / (f1/f2) = (g1*f2) / (f1*g2)
12:33:35 <FunctorSalad> *g*
12:33:47 <FunctorSalad> (now find an argument for the order of multiplication)
12:34:16 <sclv_> The bimap at least is the same...
12:34:51 <dolio> Is it?
12:35:19 <sclv_> well, I'm composing a bijection with a funny other arrow.
12:35:51 <sclv_> so working with bijections is the same -- its just I think that I then end up with the function I just posted as a funny generalized version of inBi
12:36:26 * sclv_ goes off to read "Arrows for Invertible Programming" more carefully
12:36:37 <FunctorSalad> (group of fractions for non-commutative monoids, anyone? ;))
12:37:44 <ski> FunctorSalad : elaborate
12:38:06 <FunctorSalad> ski: like constructing Z from N x N
12:38:27 <FunctorSalad> ski: I think the non-commutative case is more complicated than just taking pairs, though
12:38:32 <dolio> A bijection is supposed to express some sort of relation between a and b, isn't it?
12:39:03 <FunctorSalad> ski: just got the idea because sclv_'s function is formally like division of fractions
12:42:28 <dolio> @type \(f, f') (g, g') -> (f . g, g' . f')
12:42:28 <sclv_> hmm... maybe I should just move to a uniform structure with a fancy composition op...
12:42:29 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *). (Functor f1, Functor f) => (a -> b, f1 a1) -> (f a, a1 -> b1) -> (f b, f1 b1)
12:42:33 <humasect> http://hpaste.org/9011#a1 <<-- this isn't possible ? maybe i have had too much coffee.
12:42:42 <dolio> @type \(f, f') (g, g') -> (id . f . g, id . g' . f')
12:42:42 <lambdabot> forall a a1 (f :: * -> *) a2 a3 (f1 :: * -> *). (Functor f1, Functor f) => (a1 -> a, f1 a3) -> (f a1, a3 -> a2) -> (f a, f1 a2)
12:42:56 <dolio> Bah.
12:43:14 <sclv_> @type \(f, f') (g, g') -> (f P.. g, g' P.. f')
12:43:16 <lambdabot> forall b c a b1 c1 a1. (b -> c, a1 -> b1) -> (a -> b, b1 -> c1) -> (a -> c, a1 -> c1)
12:43:35 <chrisdone> :t flip (\(g1,g2) -> first g1 >> second g2)
12:43:36 <lambdabot> forall b c b1 c1. (b, b1) -> (b -> c, b1 -> c1) -> (b, c1)
12:43:47 <dolio> @type \(f, f') (g, g') -> (f . g . id, g' . f' . id)
12:43:48 <lambdabot> forall a b a1 a2 b1 a3. (a -> b, a3 -> a2) -> (a1 -> a, a2 -> b1) -> (a1 -> b, a3 -> b1)
12:44:44 <dolio> Now that's composition in some C*D^op.
12:44:53 <dolio> Or something of the sort.
12:45:16 <ski> yes (as noted :)
12:45:50 <dolio> Yeah. I just wanted to see the arguments in the right order.
12:46:03 <ski> FunctorSalad : given a monoid `M' (with unit `1',combination `(*)') you want the quotient of `M * M' defined by the finest equivalence relation `(~)' satisfying `forall n,d,k. (n,d) ~ (n*k,d*k)' ?
12:50:43 <FunctorSalad> ski: I don't think that yields a group though... I think you'd need to take the set of all words in M and a copy of M, say M', and factor out a*a' ~ 1, a'*a ~ 1 for all a in M and corresponding a' in M'
12:52:03 <FunctorSalad> (and factor out the multiplication table of M, of course)
12:52:47 <FunctorSalad> that seems to be the universal way to get a group from a monoid, anyway
12:53:11 <FunctorSalad> sorry for drifting off-topic
12:53:34 <ski> hm, is this the grothendieck construction ?
12:53:51 <FunctorSalad> heh, I vaguely remember something like that too
12:53:59 <ski> (FunctorSalad : nothing more on-topic at the moment ..)
12:54:04 <Quadrescence> Where have I heard that name before...
12:54:06 <humasect> thanks everyone=)
12:54:11 <Quadrescence> Grothendieck
12:54:18 <FunctorSalad> (I just thought that one up from the general term-structure thing though, not from grothendieck)
12:54:29 <ski> alexander grothendieck
12:55:35 <ski> hm .. "the functor that sends a commutative monoid M to its Grothendieck group N is left adjoint to the forgetful functor from the category of abelian groups to the category of commutative monoids."
12:55:43 <zachk> are there Cocoa bindings for haskell?
12:56:09 <chrisdone> > uncurry (***) ((+1),(+2)) (1,2)
12:56:09 <lambdabot>  (2,4)
12:56:32 <chrisdone> @type uncurry (***)
12:56:33 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
12:57:04 <FunctorSalad> ski: I think the thing I described is left adjoint to the forgetful functor from Group to Monoid
12:57:19 * ski str hearing some discussion of cocoa not many days ago .. though not knowing which nicks participated
12:58:02 <byorgey> zachk: there are.
12:58:07 <byorgey> I am not familiar with them though.
12:58:19 <FunctorSalad> given a monoid homo f: M -> U(G) for G some group, f can be uniquely extended to that word construction via F(m) = f(m), F(m') = f(m)^-1, and multiplicativity, no?
12:58:28 <byorgey> but they are used e.g. by the mac version of Yi.
12:58:48 <ski> FunctorSalad : looks like it could work
12:59:28 <nominolo> byorgey: which is still experimental, i think
12:59:39 <byorgey> oh, perhaps it is
13:00:16 <byorgey> yeah, there's nothing on hackage
13:01:01 <byorgey> zachk: well, there's this: http://hoc.sourceforge.net/
13:01:02 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
13:01:28 <byorgey> not quite what you asked, I guess, but maybe...
13:01:41 <ski> @where hoc
13:01:41 <lambdabot> http://hoc.sourceforge.net/
13:02:05 <nominolo> zachk: take a look at the Readme in Yi, which describes how to get the latest hoc
13:03:09 <nominolo> zachk: http://code.haskell.org/yi/README, apparantly hoc is now on googlecode
13:08:55 <Quadrescence> In C or C++, what does this mean?: Foo = array[1..5] of Bar
13:09:25 <allbery_b> that's not C.  doesn't look like C++ either
13:09:30 <LordSuper> <<-Quadrescence->> Ccùcù
13:09:49 <Quadrescence> Maybe pseudocode, I don't know. That wasn't my reeeeaaaaalllll question
13:10:22 <Quadrescence> what I meant to ask: if Foo and Bar are types, what would that look like in Haskell?
13:10:38 <Zao> Quadrescence: It's nonsensical in both C and C++.
13:10:47 <ski> maybe Pascal or Ada ?
13:10:55 <Zao> newtype Foo = [Bar] or something?
13:11:09 <Quadrescence> That's what I was thinking.
13:11:16 <byorgey> Quadrescence: if you really really want an array, there are array libraries
13:11:24 <ski> type Foo = Array Int Bar
13:11:34 <Quadrescence> byorgey: No, no, I don't want an array.
13:11:50 <FunctorSalad> @type Array [1..5] Bar
13:11:51 <byorgey> but  type Foo = [Bar] is how you would make Foo a list of Bar's
13:11:56 <lambdabot> Not in scope: data constructor `Array'
13:11:56 <lambdabot> Not in scope: data constructor `Bar'
13:12:17 <FunctorSalad> wait, [1..5] isn't a type ;)
13:12:20 <Quadrescence> byorgey: Yeah. I just wasn't sure with the 1..5 thing.
13:12:21 <Quadrescence> Ueaj
13:12:22 <Quadrescence> Yeah*
13:12:33 <Quadrescence> http://kociemba.org/math/CubeDefs.htm#faceturns
13:12:33 <byorgey> Quadrescence: well, it depends what you want exactly
13:12:35 <lambdabot> Title: CubeDefs.html
13:12:36 <FunctorSalad> I want a type-level five-leton
13:12:43 <Quadrescence> r3d block
13:12:47 <byorgey> FunctorSalad: good luck with that =)
13:12:55 <Quadrescence> 3rd* :P
13:13:41 <BMeph> Quadrescence: Definitely looks Pascalesque to me. I haven't looked at Ada in about 20 years, though. :)
13:13:42 <ski> > array (1,5) [(x,x) | x <- [1..5]]
13:13:44 <lambdabot>  array (1,5) [(1,1),(2,2),(3,3),(4,4),(5,5)]
13:13:46 <byorgey> Quadrescence: sorry, what am I supposed to be looking at on that page?
13:13:52 <FunctorSalad> byorgey: hmm, is it that hard? data Five = Foo | Bar | Baz | Qux | Gazonk
13:14:00 <Quadrescence> What SingleFace = array[1..9] of ColorIndex; means
13:14:05 <dolio> > listArray (1,5) [1..5]
13:14:06 <lambdabot>  array (1,5) [(1,1),(2,2),(3,3),(4,4),(5,5)]
13:14:30 <byorgey> FunctorSalad: oh, does the suffix -leton indicate coproduct?
13:14:49 <BMeph> FunctorSalad: You mean a quintuple? :)
13:14:56 <visq> nominolo: will the ghc package eventually have internal copies of bytestring, unix, etc. ?
13:14:56 <FunctorSalad> byorgey: I made that up, but I was trying an analogy to "singleton"
13:15:04 <ski> quinvariant
13:15:17 <byorgey> Quadrescence: yeah, in Haskell I would just say  type SingleFace = [ColorIndex]
13:15:25 <byorgey> Quadrescence: with a comment saying there should always be nine elements
13:15:31 <FunctorSalad> BMeph: a quintuple would seem to be an element of some A*B*C*D*E to me
13:15:39 <Quadrescence> byorgey: That was my original plan. :D Thanks.
13:15:48 <byorgey> Quadrescence: you can use  !!  to get elements by index
13:15:55 <byorgey> > [1,2,3] !! 1
13:15:56 <lambdabot>  2
13:16:01 <byorgey> (zero-indexed)
13:16:03 <Quadrescence> Right. I was not going to use arrays.
13:16:26 <visq> yi fails to build with ghc 6.8.3 because of a bytestring 0.9.0.1.1 /= bytestring 0.9.0.1...
13:16:46 <nominolo> visq: possibly, but not exported
13:17:07 <nominolo> visq: did you try with the latest cabal?
13:17:11 <byorgey> FunctorSalad: makes sense to me.  a quintuple is in A*B*C*D*E and a fivleton is in A+B+C+D+E =)
13:17:18 <nominolo> the problems occur when things are reexported
13:17:28 <stepcut> is there anyway to get HsColour to show the qualified name of a function when you hover the mouse over it in -html mode? for example, hovering over 'head' would show, 'Data.List.head'
13:17:33 <FunctorSalad> :)
13:17:51 <ski> fiftleton ?
13:18:01 <visq> package X depends on Y-1 and Z depends on Y-2 isn't always an error ?
13:18:02 <byorgey> ski: now let's not be silly
13:18:40 <visq> nominolo: cabal-install 0.5.1, Cabal 1.4.0.1 (recent, but not latest)
13:18:49 <nominolo> visq: cabal can rebuild
13:18:54 * ski >$ sleep
13:18:56 <nominolo> visq: try the released version
13:19:05 <visq> cabal can rebuild the ghc package ?
13:19:23 <nominolo> visq, oh, no
13:19:41 <visq> you can't update bytestring if you depend on ghc-api afaik
13:19:59 <nominolo> but cabal can figure out to use the same bytestring for yi that was used for ghc
13:20:28 <nominolo> visq: no, you'd need to have some kind of wrapper, i guess, dunno
13:20:57 <visq> therefore it would be great if ghc wouldn't depend on bytestring
13:21:40 <nominolo> visq: i'm not sure why it does
13:22:09 <FunctorSalad> maybe try to build anyway and hope the extra .1 doesn't matter?
13:22:12 <nominolo> at least it should be possible to avoid
13:22:32 <nominolo> FunctorSalad: it will if things are re-exported
13:22:50 <nominolo> because ghc does not guarantee any ABI compatibility, atm
13:23:09 <nominolo> the plan is to have that between minor releases beginning with 6.12
13:23:24 <visq> it is hard to fix if you have module A build with bytestring X, and ghc build with bytestring Y, and your program depending on both
13:23:26 <FunctorSalad> hmm, ok
13:24:13 <nominolo> FunctorSalad: therefore it considers Foo-1.2.3:Bar different from Foo-1.2.3.1:Bar, even if defined exactly the same way
13:25:31 <FunctorSalad> nominolo: thanks, didn't know that
13:26:08 <nominolo> visq: the workaround is to use X for both
13:26:16 <nominolo> which i believe cabal can do
13:27:26 <visq> I'll try if the latest cabal-install handles this
13:30:12 <nominolo> visq: hm, i think 0.5.1 is indeed the latest version
13:30:41 <nominolo> visq: are you going to this year's icfp?
13:30:44 <visq> yes, i was only missing 3 patches
13:31:02 <visq> oh no, to far away I'm afraid. You will ?
13:32:07 <nominolo> no, too expensive
13:32:39 <nominolo> next year it should be in europe again
13:32:55 <visq> yes :)
13:33:19 <visq> you're working on the ghc-api, right ?
13:33:39 <nominolo> yep
13:34:00 <visq> what do you think about ghc depending on bytestring and unix then ?
13:34:25 <visq> i always had troubles with incompatibilities
13:34:38 <nominolo> yes, there are many issues with compatibility
13:34:51 <nominolo> we're aware of them, but there's not always a good solution, yet
13:35:41 <visq> ok
13:36:08 <visq> it is a pity cabal install can't resolve this problems, though (for the user)
13:37:18 <visq> did you add any documentation yet ?
13:40:15 <Mitar> how can i show float in all digits (not in exponential form)?
13:43:05 <dolio> @hoogle showFFloat
13:43:06 <lambdabot> Numeric.showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
13:43:16 <nominolo> visq: no.  atm, i'm fighting with darcs to get some patches in
13:43:56 <dolio> One of those, at least.
13:44:06 <dolio> > showFFloat 1834.18395 ""
13:44:16 <lambdabot>        add an instance declaration for (Fractional (Maybe Int))
13:44:20 <dolio> > showFFloat Nothing 1834.18395 ""
13:44:20 <byorgey> visq: I think Saizan's GSoC project will make cabal-install resolve that problem =)
13:44:23 <lambdabot>  "1834.18395"
13:44:57 <nominolo> byorgey: i don't think so
13:45:10 <nominolo> byorgey: but maybe he's doing more than he is supposed to :)
13:45:29 <byorgey> no?  maybe I misunderstood the problem and/or Saizan's project =)
13:45:55 <visq> byorgey: in this case, it would have been neccessary to rebuild ghc
13:46:07 <byorgey> oh, yuck
13:46:15 <nominolo> his goal is mostly concerned with cabal not cabal install
13:46:31 <nominolo> visq: you could add a compatibility layer
13:46:32 <byorgey> yes, but cabal is what creates the install plans
13:46:46 <nominolo> byorgey: no, cabal-install does
13:46:54 <byorgey> oh, ok
13:46:56 <nominolo> the cabal library does not
13:47:28 <nominolo> what Saizan is doing is to figure out how to process files in one project (and subprojects)
13:47:44 <nominolo> ie, a clever version of ghc --make
13:47:57 <nominolo> which also knows about preprocessors and such
13:48:01 <byorgey> oh, I see!
13:48:09 <byorgey> yes, I misunderstood his project then =)
13:48:59 <byorgey> hm, this will solve the problem with being able to have an executable which depends on a library in the same package?
13:49:06 <byorgey> the same project I mean
13:49:07 <dons> if find this surprising, http://dysinger.net/2008/07/17/scala-is-a-ghetto/
13:49:09 <lambdabot> Title: c Tim Dysinger 1a » Scala is a Ghetto 34
13:49:50 <nominolo> visq: the workaround is to have a smallish library that defines the core functionality using the ghc api, then you use this library in your front-end code.  if you're careful about what you export this could be fairly portable
13:50:28 <nominolo> byorgey: yes. among other things.  for example, one goal is to be able to build ghc and gtk2hs using Cabal
13:52:06 <byorgey> cool
13:54:35 <visq> nominolo: I do not fully understand. Isn't this about linking packages ?
13:54:57 <nominolo> yes
13:55:23 <nominolo> say yi wants to use the ghc-api, but also bytestring-4.23
13:55:27 <visq> with a few changes for gtk-0.9.13, yi builds and runs now
13:55:36 <visq> ok
13:55:52 <nominolo> while ghc-api uses bytestring-1.337
13:56:23 <nominolo> then you can write a wrapper  yi-ghc-stuff
13:56:36 <nominolo> and yi uses this wrapper
13:56:50 <bos> it's not bytestring-1.31337? shame.
13:57:20 <nominolo> bos: read without the dot
13:57:27 <bos> ok.
13:57:52 <nominolo> visq: oh, hm ... maybe that doesn't work
13:57:58 <visq> but don't I still have to link both bytestring libs ?
13:58:14 <nominolo> yes, but you can link them independently
13:58:33 <nominolo> if yi-ghc-stuff does not reexport anything of bytestring
13:59:18 <nominolo> but things get even more complicated if you want different versions of other libraries
13:59:44 <nominolo> visq: i think the solution is to have two ghc packages.  atm, the ghc package exports almost everything
14:00:21 <nominolo> there will still be such a package, but there will be another package which will only export the "official api", which will have some stability guarantees
14:00:33 <nominolo> while the other package will be "use at your own risk"
14:00:53 <visq> sounds like a good idea
14:01:05 <nominolo> the official api package could possibly be made independent of unix and bytestring
14:12:17 <Baughn> Cale: Does LB do anything unusual/ghc/profiler-breaking I should know about?
14:15:33 <chrisdone> I'm not tusho if there are any other puns
14:15:39 <Cale> Baughn: Not that I'm aware of. Of course, it used to rely more heavily on hs-plugins, but I'm not sure how much of that is left...
14:15:49 <tusho> That's already been done.
14:15:51 <tusho> OH HO HO
14:15:57 <chrisdone> not by me
14:16:32 <Dr_Foo> Bah... sometimes I dislike not living alone. It's very distracting when you're trying to code and someone comes in and starts watching Big Brother.
14:16:49 <chrisdone> dr: head phones + bach
14:17:04 <mauke> s/bach/oakenfold/
14:17:07 <lament> or earplugs + silence
14:17:17 <znutar> s/oakenfold/kraftwerk/
14:17:31 <Dr_Foo> i've gone for MC Frontalot
14:17:33 <b\6> s/earplugs/icepicks
14:17:35 <tusho> chrisdone: dude.
14:17:36 <chrisdone> s/s\/[^\/]\///
14:17:38 <tusho> you missed it
14:17:39 <Dr_Foo> he's practically bach
14:17:41 <tusho> "That's already been DONE"
14:17:54 <Cale> Frank Zappa ;)
14:17:55 <lament> if you can listen to Bach and code at the same time, that just means you don't know how to listen to Bach properly.
14:18:08 <mar77a> "by people with wigs and stuff"
14:18:11 <chrisdone> tusho: I didn't miss it, apart from you already using that one, the statement is false. so your message was best ignored
14:18:21 <Cale> But yeah, when I'm programming, I usually go with silence.
14:18:24 <tusho> chrisdone: you had already used tusho=too sure.
14:18:26 <tusho> so hah.
14:18:29 <Baughn> Cale: LB itself compiles fine without hs-plugins; it isn't profilable with it in, see
14:18:39 <chrisdone> tusho: no, I did "to show"
14:18:53 <tusho> bah
14:19:38 <Baughn> Cale: The problem is, profiling options don't work very well at all. Biographical profiling, not at all. If you could take a look at that.. I can't figure it out at all
14:20:19 <chrisdone> lament: or I don't know how to code properly
14:20:26 <Cale> Is there at least a reasonable error message? Or does it compile and then just not produce any profiling output?
14:21:43 <Baughn> Compiles, produces no profiling output
14:21:54 <Baughn> Just a moment..
14:22:23 <Baughn> Cale: http://brage.info/~svein/lambdabot.hp <-- Have a look at this
14:22:41 <Baughn> Unless I'm doing something obviously wrong.. it works fine on test programs, though
14:22:41 <Cale> beautiful.
14:22:51 <Cale> hmm
14:23:17 <Cale> Of course, the obvious... it was compiled with -prof -auto-all or some such?
14:24:28 <Cale> Actually, I've never used cabal to compile things for profiling... is the best way simply to add the appropriate GHC options to the .cabal?
14:24:50 <Baughn> Theoretically, cabal is supposed to have an option to enable profiling
14:25:10 <Baughn> That seemed to interfere with the already-set ghc-options, though. I just added -prof -auto-all to the end
14:25:25 <Cale> hmm, I can't ssh to code.h.o
14:25:32 <Baughn> (And cabal doesn't add -auto-all.. would that matter for -hm, though?)
14:25:44 <Cale> Maybe it's just router flakiness on my end though...
14:27:19 <Cale> Hm, I don't know. It seems like it might not matter.
14:28:08 <Baughn> In any case, I did add it, so that's not the issue
14:32:31 <Cale> Baughn: What do you get with -hc instead of -hm?
14:34:56 <Baughn> Cale: Nothing. Er, I actually get quite a bit with just -hc or -hm; it's -hb that's killing me
14:35:34 <Baughn> Even -hbdrag,void,lag,use has empty output, and that should be a no-op
14:37:55 <Baughn> ..I suppose it'll do. I was hoping not to have to wait for two days for each profiling run, but it'll do.
14:38:03 <ahunter> Out of curiosity, can anyone give me a bit of help with ticky-ticky profiling?
14:38:35 <Baughn> Only by way of telling you how not to use it. What did you want it for?
14:39:15 <Cale> I imagine that it's probably a bug in GHC, but isolating a small test case might be hard.
14:39:42 <Baughn> Suppose I'll start removing modules until it goes away, first..
14:39:52 <ahunter> Baughn: heh.  I need to do measurements on updates in the rts, which I know ticky-ticky keeps track of.  I just want to make sure I know how to do it right--the docs say it's important (which makes sense) that the libs are compiled with ticky-ticky, which I...um...am not sure how to do.
14:40:17 <ahunter> Baughn: I tried adding "t" to GhcLibWays, which is compiling now, but that was a bare guess and I have no idea if it will work.
14:40:53 <grahamhutton> @users
14:40:54 <lambdabot> Maximum users seen in #haskell: 473, currently: 443 (93.7%), active: 20 (4.5%)
14:42:30 <zachk> is there a builtin function that takes [a]->Int->a->[a]  takes a list a position in the list the new element you want and returns a new list modified with a at Int?
14:42:57 <grahamhutton> @hoogle [a] -> Int -> a -> [a]
14:43:00 <lambdabot> No matches, try a more general search
14:43:05 <mauke> zachk: I don't think so
14:43:05 <Cale> zachk: no
14:43:13 <mauke> but see splitAt
14:44:20 <Baughn> zachk: If you do that a lot, you probably don't want a list, so..
14:44:21 <Cale> > let replaceAt k r xs = [if k == n then r else v | (n,v) <- zip [0..] xs] in replaceAt 4 'p' "Hello, world!"
14:44:23 <lambdabot>  "Hellp, world!"
14:45:06 <Cale> Of course, that way adds a constant cost to every cell :)
14:46:38 <tusho> > nub "Hello world I am new to internets"
14:46:40 <lambdabot>  "Helo wrdIamntis"
14:46:46 <tusho> I want a nub that preserves spaces.
14:47:00 <tusho> @src nub
14:47:01 <lambdabot> nub = nubBy (==)
14:47:05 <tusho> @src nubBy
14:47:05 <lambdabot> nubBy eq []             =  []
14:47:05 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:47:16 <Cale> > unwords . map nub . words $ "Hello world I am new to internets"
14:47:19 <lambdabot>  "Helo world I am new to inters"
14:47:22 <tusho> Cale: no
14:47:24 <tusho> for the whole thing
14:47:57 <tusho> @let noob [] = []; noob (' ':xs) = ' ' : noob xs; noob (x:xs) = x : noob (filter (\y -> not (x == y)) xs)
14:48:02 <lambdabot> Defined.
14:48:03 <mauke> > nubBy (\x y -> x /= ' ' && x == y) "Hello world I am new to internets"
14:48:04 <lambdabot>  "Helo wrd I am n t is"
14:48:05 <tusho> > noob "Hello world I am new to internets"
14:48:06 <lambdabot>  "Helo wrd I am n t is"
14:48:11 <mauke> I WIN
14:48:12 <tusho> hah, that could work too mauke
14:48:12 <tusho> :)
14:48:20 <tusho> @let noob = nubBy (\x y -> x /= ' ' && x == y)
14:48:21 <lambdabot> <local>:5:0:     Equations for `noob' have different numbers of arguments    ...
14:48:25 <tusho> ...
14:48:27 <tusho> shut up lambdabot
14:48:28 <Cale> @undefine
14:48:29 <tusho> @unlet noob
14:48:29 <lambdabot> Undefined.
14:48:29 <lambdabot>  Parse error
14:48:34 <tusho> @undefine noob
14:48:35 <lambdabot> Undefined.
14:48:35 <Baughn> Cale: Oh, this /is/ amusing. Removing modules from LB makes even profiling with just -h[cm], which previously worked, break.
14:48:39 <tusho> @let noob = nubBy (\x y -> x /= ' ' && x == y)
14:48:40 <lambdabot> Defined.
14:48:42 <tusho> there we go
14:48:44 <Cale> tusho: @undefine doesn't take an argument
14:48:51 <Cale> tusho: it simply resets all the definitions
14:49:06 <dublpaws> is there a "continue line" character?
14:49:07 <Cale> Baughn: strange
14:49:08 <Baughn> Does the profiler sample based on elapsed real time, or cpu time?
14:49:18 <Cale> dublpaws: Just indent the following line more
14:49:26 <dublpaws> ok, thanks Cale
14:49:49 <titusg> I just installed Network.HTTP and tried to use it and get: Loading package HTTP-3001.0.4 ... linking ... <interactive>: /usr/local/lib/HTTP-3001.0.4/ghc-6.8.2/HSHTTP-3001.0.4.o: unknown symbol `networkzm2zi1zi0zi0_NetworkziSocket_a286_info' ?
14:52:11 <mauke> preflex: zdec networkzm2zi1zi0zi0_NetworkziSocket_a286_info
14:52:12 <preflex>  network-2.1.0.0_Network.Socket_a286_info
14:53:06 <titusg> mauke: I'm missing network.socket?
14:56:33 <RayNbow> hmm, what is the best/correct way to write an interactive Haskell program that responds to key presses? (as opposed to character/line based input)
14:56:49 <titusg> socket is a base library, not cabal, isn't it?
14:57:28 <schme_> RayNbow: I'm guessing that depends on what interface you are using for yar program.
14:58:02 <dons> rocking the web'o'sphere http://www.reddit.com/info/6sgqr/comments/
14:58:02 <lambdabot> Title: reddit.com: HTML Templating for Haskell in HAppS using HSP
14:58:04 <dons> go stepcut.
14:58:51 <RayNbow> schme_: well, so far I've seen programs using GLUT or Gtk
14:59:10 <schme_> RayNbow: Right. No idea with those :)
15:00:32 <Baughn> RayNbow: It depends on the library, not haskell. You can use whatever mechanism you normally would.
15:00:48 <Baughn> (And don't be afraid of creating threads)
15:00:58 <schme_> RayNbow: GLUT is quite good at grabbing keypresses though, innit?
15:02:25 <Baughn> Cale: Ah. I do believe I found it.
15:02:32 <Baughn> Cale: "     -- this kills profiling output:
15:02:33 <Baughn>             io $ exitImmediately (ExitFailure 1))"
15:03:00 <titusg> I get a different error outside of ghci, still relating to libHSHHTP tho, lots of these -- /usr/local/lib/HTTP-3001.0.4/ghc-6.8.2/libHSHTTP-3001.0.4.a(HTTP.o): In function `skXk_info':
15:03:00 <titusg> (.text+0x56f8): undefined reference to `networkzm2zi1zi0zi0_NetworkziURI_a64_closure'
15:03:00 <titusg>  
15:07:19 <dcoutts> Cale: cabal configure with -p or --enable-library-profiling
15:07:51 <dcoutts> Cale: and if you want -auto-all too use --ghc-option=-auto-all
15:08:40 <Baughn> dcoutts: Does that add to options in .cabal, or replace them?
15:09:23 <Cale> Baughn: aha! That's interesting :)
15:09:49 <dcoutts> Baughn: add
15:12:09 <hackage> Uploaded to hackage: opml 0.4
15:12:19 <mauke> preflex: seen glguy_
15:12:19 <preflex>  Sorry, I haven't seen glguy_
15:13:06 <Baughn> Cale: Calling posix _exit directly, at that. This can't /possibly/ be a good idea
15:14:00 <Baughn> But it does explain why the profiling data doesn't get written
15:14:25 <Cale> yeah
15:14:41 <Baughn> Removing it has no obvious ill effects, and gives me a beautiful profiling diagram. :D
15:16:41 <zachk> wheres my hpaste :-/
15:16:51 <zachk> http://hpaste.org/9013
15:17:18 <Zao> hpaste seems awol.
15:18:03 <Zao> zachk: May I suggest splitAt or genericSplitAt instead of the take/drop combo?
15:18:16 <mauke> @src splitAt
15:18:16 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
15:18:34 <zachk> splitAt n xs is equivalent to (take n xs, drop n xs)
15:19:20 <zachk> i am trying to teach my lil bro haskell, via implementing tic tac toe, he knows a tiny bit of scheme
15:20:06 <chrisdone> splitAt is just more obvious
15:20:10 <chrisdone> just like using fromMaybe as opposed to flip maybe id
15:21:24 <schme_> tic tac toe :(
15:21:39 <chrisdone> putStrLn vs putStr . (++"\n"), etc...
15:22:29 <mauke> (btw, gcc compiles printf("%s\n", str) to puts(str))
15:23:16 <chrisdone> puts considered inconsistent
15:23:19 <Cale> mauke: special case of course?
15:23:29 <mauke> yep
15:24:19 <jsnx> where is NDP right now?
15:24:34 <schme_> Speaking of scheme, is there anything like call/cc in haskell?
15:24:42 <chrisdone> puts("hello") /= fputs(stdout,"hello")
15:24:51 <chrisdone> schme_: there's a continuation monad
15:25:13 <chrisdone> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
15:25:14 <lambdabot> Title: Control.Monad.Cont, http://tinyurl.com/gnsuu
15:25:31 <mauke> chrisdone: obviously, but it's not even fputs("hello", stdout) :-)
15:25:35 <schme_> Rightyo. I'll take a looksy
15:25:35 <Baughn> schme_: And of course, half the time laziness does what you want from continuations
15:25:55 <jsnx> do i understand right that NDP works by taking each operation on a vector and putting it in a separate thread?
15:25:55 <Cale> schme_: Of course, call/cc isn't first class, because it breaks referential transparency.
15:26:07 <dons> jsnx: darcs.haskell.org/packages/ndp
15:26:10 <Cale> jsnx: It's more subtle than that
15:26:12 <dons> jsnx: darcs.haskell.org/packages/dph one of the two
15:26:39 <Cale> jsnx: It flattens out compositions of operations on the parallel arrays and divides the work between available processors in a balanced way.
15:26:51 <chrisdone> mauke: yes, that was a mistake. well done
15:27:44 <jsnx> Cale: oh, intersting
15:27:59 <jsnx> so it does *not* rely on the RTS scheduler?
15:28:56 <Cale> jsnx: I don't really know all the details of the way the current implementation works.
15:29:02 <jsnx> and the millions of thread benchmark is bascially not germane to it?
15:29:03 <sclv_> @seen conal
15:29:04 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
15:29:16 <jsnx> Cale: okay, well i will go read the paper anyways
15:29:51 <Cale> jsnx: It might make use of the existing parallelism architecture to some extent, but there's a lot of code rewriting which goes on before anything like that.
15:31:23 <sclv_> @tell conal While you're updating packages to work with Control.Category, any plans to do so for TypeCompose as well?
15:31:24 <lambdabot> Consider it noted.
15:32:51 <schme_> Also I am looking for quartz bindings for ghc. I can't seem to find any.. where should I go look?
15:34:39 <schme_> I'd hate having to use python :(
15:34:58 <jsnx> Cale: is there maybe someone on this channel who would talk about it a little bit? i'm writing a paper for usenix, that surveys different techniques for concurrent programming
15:36:33 <Cale> jsnx: Well, there's a nice little video of a talk that SPJ gave
15:36:55 <Cale> also see the links from http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
15:36:56 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
15:37:14 <Cale> (I'll find the talk)
15:37:36 <Cale> http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
15:37:38 <lambdabot> Title: Î»ondon HUG » Blog Archive » Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
15:38:10 <jsnx> great, thanks
15:40:05 <roconnor> @pl IO (\k -> runIO x (\a -> runIO (f a) (\b -> k b)))
15:40:06 <lambdabot> IO (runIO x . flip (runIO . f))
15:40:17 <roconnor> flip
15:40:20 <roconnor> that sucks
15:41:51 <conal> sclv_: hi
15:41:52 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
15:42:25 <sclv_> conal -- that's just me asking if/when you're adding Control.Category support to Typecompose
15:43:02 <conal> sclv_: i've done it and pushed but haven't made a new package yet
15:43:11 <conal> sclv_: are you using ghc 6.9?
15:43:16 <sclv_> oh, nice, I'll just grab it from the repo!
15:43:43 <sclv_> conal: yeah, I had to start digging around in internals a bit because of some rts bugs.
15:44:26 <conal> sclv_: great.  i test for ghc >= 6.9.  please let me know if it works for you.
15:46:06 <lispy> What is the name of that function that takes a starting value, an update function and generates the infinite list of results?
15:46:10 <lispy> :t interate
15:46:11 <sclv_> Will do. I think your Bijections are just what the doctor ordered to simplify a bit of my code. Have you played much with the invertible arrow stuff yourself, or is it mainly there as proof of concept?
15:46:12 <lambdabot> Not in scope: `interate'
15:46:13 <lispy> :t iterate
15:46:16 <lambdabot> forall a. (a -> a) -> a -> [a]
15:47:33 <sclv_> (btw, just ran a cabal instal --global in the repo, built like a dream)
15:48:21 <luite> I'm trying to pass a random generator (from getStdGen) as an argument to a function, using the type RandomGen. but now GHC says that I'm using class RandomGen as a type. what is the correct type?
15:48:29 <dons> StdGen
15:48:41 <dons> that's the actual generator most people use.
15:48:55 <dons> ?hoogle getStdGen
15:48:57 <lambdabot> System.Random.getStdGen :: IO StdGen
15:49:08 <dons> gives you an object of type StdGen to play with.
15:49:16 <dons> you can all the RandomGen methods on it.
15:49:21 <dons> OO-style :)
15:49:24 <luite> ah, but suppose I wanted it to accept all instances of RandomGen?
15:49:33 <roconnor> @src StdGen
15:49:34 <lambdabot> Source not found.
15:49:35 <dons> then it'd be polymorphic in RandomGen
15:49:43 <dons> RandomGen g => g -> (a, g)
15:49:45 <dons> for example
15:49:49 <dons> would be the type.
15:51:27 <lispy> ?src fix
15:51:28 <lambdabot> fix f = let x = f x in x
15:54:11 <mjrosenb> what's the difference between quot and div?
15:54:19 * BMeph loves Swierstra's "NO UNSAFE PERFORM IO" picture on the IOSpec page...
15:54:34 * mjrosenb checks negative numbers
15:54:37 <luite> dons: thanks, it works now
15:57:20 <RayNbow> mjrosenb
15:57:22 <RayNbow> @check \x y -> y == 0 || (div x y == quot x y)
15:57:23 <lambdabot>  Falsifiable, after 16 tests: -2, 8
15:58:00 <conal> does anyone know about haddock and ghc-6.9?  the .cabal says ghc >= 6.8.2 && < 6.9,
15:58:14 <BMeph> Just curious, but does anyone use Attr Grammars much, and UUAG in particular?
15:58:37 <BMeph> s/anyone/anyone here/
15:58:40 <Asgaroth> If I have an arithmetic expression with a division in it, but am sure that it'll always return Ints, how do i convince the haskell type checker of that?
15:58:49 <dcoutts> conal: probably api changes in the ghc package
15:58:55 <dcoutts> conal: only a guess
15:58:58 <BMeph> (In case you know of someone, but don't use it yourself.)
15:59:15 <O_4> Asgaroth: can't you use a rounding function?
15:59:20 <conal> dcoutts: i bet you're right
15:59:39 <BMeph> dcoutts/conal: For that matter, does haddock compile in 6.8.3 now? :)
15:59:40 <Asgaroth> O_4: good idea. thanks
16:00:31 * BMeph tries `cabal install haddock --global` and watches...
16:01:23 <conal> BMeph: dunno.  i haven't compiled haddock in a while.  since at least 6.8.2.
16:01:43 <conal> i just emailed dwaern to ask about plans for haddock & 6.9
16:02:36 <BMeph> Found out - it still bombs out on Typecheck.hs
16:04:39 <BMeph> I wonder: why is it called "rounding," when it's more like shaving/padding...
16:07:13 <O_4> Have any of you succeeded in installing the SOE graphics package on OS X?
16:08:14 <O_4> I can't install GLFW so far, as it doesn't think I have OpenGL >= 2.1 installed.
16:08:53 <mjrosenb> i want to do something in haskell
16:08:58 <mjrosenb> that feels rather OOP-ish
16:09:03 <mjrosenb> am i a bad person?
16:09:39 <schme_> Yes.
16:09:47 <Zao> Datatypes never killed anyone.
16:10:06 <O_4> Indeed not.
16:10:19 <sclv_> mjrosenb: depends...
16:10:33 <O_4> I don't see how any real program can not be OO in some regard.
16:10:48 <O_4> Objects are just data, with methods for manipulating them.
16:11:03 <mjrosenb> so i have a datatype defined with labeled arguments
16:11:05 <O_4> And that sounds like something you'd use in *any* program :-p
16:11:09 <lament> objects are just methods, with data to be manipulated by them :)
16:11:28 <mjrosenb> which will bind a bunch of functions foo :: F -> Int
16:11:45 <mjrosenb> i want another function that has type F -> int
16:11:51 <mjrosenb> that's a real function
16:12:04 <mjrosenb> whose outputs are memoized
16:12:09 <sclv_> @djinn (a->b->b) -> (b->c->c) -> (a->c->c)
16:12:10 <hackage> Uploaded to hackage: iconv 0.4.0.2
16:12:14 <lambdabot> f _ _ _ a = a
16:12:33 <sclv_> hmm... not what I suspect I wanted...
16:12:39 <sclv_> but I guess the best that can be done.
16:13:12 <bwr> what's the best way to debug haskell code?
16:13:18 <sclv_> (since obv. I need to get a b from somewhere...)
16:13:33 <sclv_> maybe if I restricted b to monoids...
16:13:39 <Zao> bwr: ghci has an integrated debugger or something nowadays.
16:13:53 <sclv_> bwr: try Debug.Trace for the easy stuff...
16:14:02 <bwr> Zao: sclv_: thanks
16:15:11 <sclv_> mjrosenb: not sure I follow...
16:15:57 <mjrosenb> so if i have
16:16:35 <mjrosenb> data F = Foo { a : Int, b : Char}
16:16:48 <mjrosenb> err s/:/::/
16:17:10 <mjrosenb> which wil bind a :: F -> Int and b :: F -> Char
16:17:34 <sclv_> right.
16:17:56 <mjrosenb> i want to define c x = a x + fromEnum (b x)
16:18:08 <mjrosenb> which will have type c :: F -> Int
16:18:31 <sclv_> Gotcha -- and you want to memoize that... are you sure it isn't premature optimization?
16:19:13 <mjrosenb> i mean, yes
16:19:23 <mjrosenb> but in a more general context
16:19:30 <mjrosenb> this is useful
16:20:03 <mjrosenb> i guess what would be more useful is if this could also be part of the definition of the datatype
16:20:06 <mjrosenb> so i can also say
16:20:24 <mjrosenb> case x of F a b c ->
16:20:26 <sclv_> Yeah, it doesn't seem evil -- the hard part is memoization is really case by case, so you have to really know you need it and how you want to do it...
16:20:27 <mjrosenb> err
16:20:39 <mjrosenb> case x of Foo a b c ->
16:21:00 <mjrosenb> so that it looks and feels like the extra field is there
16:21:24 <sclv_> ok, now that does feel OO and wrong to me :-)
16:21:52 <hml> what's the hype about stream fusion; and why do i want it in my arrays?
16:21:55 <chrisdone> can one declare multiple type synonyms for the same type?
16:22:03 <chrisdone> like `type FirstName,SecondName = String'
16:22:05 <sclv_> chrisdone: yep
16:22:13 <chrisdone> sclv_: how?
16:22:13 <tusho> type FirstName = String
16:22:15 <tusho> type SecondName = String
16:22:16 <sclv_> think you might need different lines though.
16:22:20 <sclv_> ^^
16:22:20 <tusho> dur :p
16:22:34 <chrisdone> ~_~
16:22:38 <tusho> insert pun on 'chris' and 'done'.
16:23:11 <chrisdone> you're tusho of yourself
16:23:25 <tusho> ow
16:24:00 <sclv_> mjrosenb: its not really a field because, unless you get really fancy, e.g., you can't update it...
16:24:25 <sclv_> its a function of your datatype, and its better to think of it as that...
16:24:32 <ikeda> not  as that guy who redefined . so that you could write a.func
16:24:35 <sclv_> even if you shim in some fancy memo stuff for efficiency.
16:25:12 <sclv_> "that guy who redefined ." = cale ? :P
16:26:25 <ikeda> can't remember it was a parralel map reduce post on reddit
16:26:50 <jsnx> Cale: so, in this talk there is some mention of running huge programs on distributed memory systems with parallel array operations
16:27:05 <jsnx> but isn't there a conceptual problem there?
16:27:34 <jsnx> i mean, distributed memory operations should be in IO
16:28:28 <sclv_> jsnx: all operations in haskell use memory. does that mean everything should be in IO?
16:28:47 <jsnx> sclv_: distributed memory means clustering
16:28:53 <jsnx> it means network communication
16:29:29 <sclv_> but if it doesn't effect the denotational semantics of the code, it isn't an issue.
16:29:57 <jsnx> sclv_: yeah, i guess if you allow a single failure to fail the whole program
16:30:03 <jsnx> it makes no difference
16:30:28 <jsnx> up to a certain network size, you probably can allow single failures to fail the whole thing
16:30:33 <sclv_> jsnx: who says that failures can't be handled by the rts behind the scenes too?
16:31:43 <jsnx> sclv_: well, there is no one RTS, is there?
16:31:59 <jsnx> sclv_: so they can feel to coordinate their fail recovery and fail anyways
16:32:06 <jsnx> s/feel/fail/
16:33:08 <hml> ls
16:33:59 <edwardk> @seen shapr
16:34:00 <lambdabot> Last time I saw shapr was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
16:34:00 <lambdabot> haskell-hac4, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #
16:34:00 <lambdabot> haskell.se, #haskell_ru, #japanese, #jhc, #jtiger, #macosx, #parrot, #perl6, #rosettacode, #scala, #scannedinavian, #thunks, #unicycling and #xmonad 2d 2h 36m 38s ago, and .
16:34:07 <jsnx> i think single failures could be handled by the RTS
16:34:15 <jsnx> by the RTSes
16:34:23 <edwardk> damn, and i thought vixey logged into a lot of channels.
16:35:11 <jsnx> i'll have to think about it a little bit to see if i can come up with a way for the RTSen to confuse aone another and fail
16:35:21 <jsnx> s/aone/one/
16:38:08 <hml> does jitting haskell make any sense at all; or does it's static typing and laziness make it pointless?
16:38:32 <tusho> @seen tusho
16:38:32 <lambdabot> You are in #haskell. I last heard you speak just now.
16:38:40 <tusho> lies
16:38:48 <xif> Hey, how do you do "a" * 2 in Haskell?
16:38:51 <jsnx> sclv_: now that i think about, cross cluster NDP failure could amount to data loss
16:38:52 <xif> to produce "aa"
16:39:19 <jsnx> i guess the RTSen could stripe across one another
16:39:41 <sclv_> My impression was that there would be a master/slave system.
16:40:04 <wjt> > replicate 2 'a'
16:40:19 <jsnx> sclv_: even with that, if you lost part of computation in the middle, you might have to totally start over
16:40:20 <lambdabot>  thread killed
16:40:53 <Cale> > concat . replicate 2 $ "a"
16:40:55 <sclv_> jsnx: good heavens!
16:40:56 <lambdabot>  "aa"
16:41:03 <jsnx> anyways, i can't think of a way for the RTS to recover from general NDP failure
16:41:13 <xif> Cale: thanks
16:41:17 <jsnx> striping would be too slow
16:41:41 <LordBrain> what's wrong with replicate 2 'a' ?
16:41:51 <jsnx> so, we're still in the situation where there is no graceful failure handling
16:41:51 <Cale> jsnx: NDP failure?
16:41:59 <LordBrain> or why can't lambdabot handle it
16:42:02 <sclv_> I think for the moment we're talking possibly local clusters of 10ish boxes, not the amazon cloud.
16:42:13 <Cale> jsnx: If there's an error in any element of a parallel array, the whole array is an error.
16:42:17 <sclv_> LordBrain: lambabot gets easily tired these days. she needs some spa time.
16:42:19 <jsnx> Cale: i'm past the part in the talk where SPJ has mentioned distributed memory
16:42:23 <Cale> jsnx: There are no thunks in parallel arrays
16:42:24 <Cale> oh
16:42:38 <jsnx> i'm thinking, wow
16:42:44 <jsnx> that is a mess
16:42:46 <Cale> So you're talking about switching off a machine while the program is running?
16:43:06 <jsnx> sclv_: i think you are right about the numbers, but i think you are wrong about the RTS handling failures
16:43:09 <Cale> I think the details of how that would really work have yet to be considered.
16:43:19 <SibeST> how do u do for i = 1 to 10 a = a*i in haskell?
16:43:22 <jsnx> Cale: well, if it were Erlang....
16:43:24 <chrisdone> what's a nice way to check a list is a certain length without checking the whole list?
16:43:27 <Cale> All of this work so far has been concentrated on getting things to work on SMP machines.
16:43:32 <jsnx> right
16:43:41 <xif> Cale: what does the $ in `concat . replicate 2 $ "a"` stand for?
16:43:43 <Cale> SibeST: product [1..10]
16:43:45 <chrisdone> ie, one that stop if it exceeds the limit
16:43:50 <jsnx> distributed memory could just be fail fast, though
16:44:03 <Cale> SibeST: Or  foldr (*) 1 [1..10]
16:44:04 <LordBrain> xif, appication
16:44:05 <jsnx> e.g. if we don't hear back from all the servers in the cloud, die
16:44:11 <SibeST> hm
16:44:15 <jsnx> rerun, maybe
16:44:21 <LordBrain> xif, it obviates the need for parenthesis
16:44:26 <Cale> xif: That's the same as  concat (replicate 2 "a")
16:44:26 <xif> LordBrain: `replicate 2 "a"` creates a list, not a string
16:44:34 <xif> oic, thanks.
16:44:51 <LordBrain> [Char] is the same as String
16:44:54 <Cale> xif: I could also have written (concat . replicate 2) "a"
16:44:55 <LordBrain> and i said 'a'
16:45:27 <xif> LordBrain: right, but I'm looking to replicate arbitrary strings :)
16:45:39 <xif> i.e. what you use * for in the evil languages ;)
16:45:45 <jsnx> as long as you had physical access to the machines, and there were only a few of them, yeah, distributed NDP without any IO in the type signatures would work
16:45:51 <LordBrain> oh... well i came in after your question
16:45:59 <LordBrain> i was just wondering why lamdabot didn't like it
16:46:40 <xif> LordBrain: could you explain what the . there does?
16:46:55 <xif> is it combination?
16:47:01 <xif> (function combination)
16:47:01 <LordBrain> xian, function composition
16:47:06 * xif nods
16:47:13 <xif> aye, that's the fancy word
16:47:15 <LordBrain> @src (.)
16:47:15 <lambdabot> (f . g) x = f (g x)
16:47:15 <lambdabot> -- In lambdabot, it's been generalised to:
16:47:15 <lambdabot> (.) = fmap
16:47:16 <Cale> (f . g) x = f (g x)
16:47:21 <Cale> heh
16:47:37 <xif> hey, that's pretty awesome
16:48:04 <xif> guess extracting the definition of something like that is one of the many neat things you can do in Haskell
16:48:16 <chrisdone> > let lengthMin n = length . take n in lengthMin 100 [0..] > 100
16:48:17 <lambdabot>  False
16:48:19 <chrisdone> lovely jubbly
16:48:24 <LordBrain> (.) is just a regular function since in haskell functions are first order values
16:48:24 <Cale> xif: Oh, @src just reads from a text file :)
16:48:38 <xif> Cale: oh, another Haskell myth broken then ;)
16:48:42 <Cale> Unless you're talking about the fact that (.) is defined as an ordinary function.
16:48:42 <chrisdone> > let lengthMin n = length . take n in lengthMin 100 [0..] > 99
16:48:43 <lambdabot>  True
16:48:45 <idnar> h.h
16:48:45 <idnar> heh
16:48:52 <Cale> In which case, yes, that's true :)
16:49:00 <LordBrain> well there is djinn
16:49:23 <Cale> xif: Haskell doesn't have much capacity for reflection built into it.
16:49:58 <LordBrain> @djinn (a->b)->(c->a)->(c->b)
16:49:58 <xif> well, it's pretty cool that I can get the type inference in ghci
16:50:00 <lambdabot> f a b c = a (b c)
16:50:03 <LordBrain> hmm
16:50:10 <xif> but I guess ghci isn't Haskell, and that might be the end of it
16:50:28 <LordBrain> @type (.)
16:50:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:50:50 <LordBrain> you get type inference in any haskell tho
16:50:52 <SibeST> can u plz make a call of duty 2 clone in haskell ty
16:51:02 <LordBrain> it's standardized
16:51:11 <jsnx> SibeST: hall of duty
16:51:13 <Cale> xif: Right, there's no function in Haskell to tell you the type of another function. Well, that's not entirely true, there is a typeclass called Typeable which lets you do that somewhat.
16:51:25 <joey__> > concatMap (replicate 2) "a"
16:51:27 <lambdabot>  "aa"
16:51:51 <Cale> SibeST: Well, you might start with looking at Frag, if you're interested in writing such a thing.
16:52:10 <Cale> SibeST: It was written in a couple weeks by a Haskell beginner :)
16:52:20 <SibeST> ^^
16:52:23 <Cale> SibeST: It's a small Quake 3 clone.
16:52:48 <SibeST> i like q3
16:52:56 <Cale> (Of course not something you'd sit and play for hours or anything, but it's a useful proof of concept)
16:52:56 <joey__> > "blah" >>= replicate 2
16:52:57 <lambdabot>  "bbllaahh"
16:52:58 <lispy> frag is pretty cool
16:53:30 <lispy> The frame rates seemed a bit jumpy and the AI is not right, but otherwise it plays correctly I think
16:53:51 <lispy> Sometimes the frame rate was awesome and other times it would seem to plumet, I guess it coincided with major GCs
16:53:57 <titusg> are there any examples of using the curl bindings for simple posts etc around?
16:54:10 <lispy> simple posts?
16:54:19 <Cale> lispy: I think someone looked into that and ruled out the GC.
16:54:24 <Cale> lispy: But I'm not sure.
16:54:25 <titusg> well, posts
16:54:36 <Cale> lispy: An easy way to check is to turn on GC beeps :)
16:55:16 <lispy> titusg: sorry, still not following you.  But, I know darcs has code around curl, and probably isn't all that complex...
16:55:37 <xif> is it even possibly to write a high-end game in a language with builtin GC?
16:55:44 <lispy> titusg: some parts of darcs are really complex, but I don't think the http wrapers are part of that
16:56:14 <lispy> xif: the game company that makes unreal engine uses GC
16:56:36 <mdmkolbe> Hey all, this code (http://hpaste.org/9020) takes 3 seconds to run, but I think it should take less than that (it only does ~30,000 loops).  I've never really learned how to optimize haskell code.  Any tips?
16:56:37 <xif> lispy: some kind of a GC library for C++, I assume?
16:56:43 <titusg> lispy: I'm thinking of network.curl -- I didn't know that was related to darcs. I want examples of setting the headers for a request, posting some data and parsing the response
16:56:46 <LordBrain> anyway you don't have to write the whole game in haskell... high level languages are used in games these days all the time...
16:57:23 <Cale> Garbage collection isn't inherently slow. You just need an appropriately smart garbage collector.
16:57:26 <lispy> xif: The trick seems to be controling where/when you create garbage or where/when you use the GC
16:57:47 <lispy> titusg: oh, sorry I was unware of that library.  I'm probably not very helpful.
16:57:51 <Cale> The GC in GHC is really really good at collecting short-lived values efficiently.
16:57:57 <xif> lispy: yeah, I would assume if you have fine grained control over the GC runs, it would be fine
16:58:14 <xif> it's still a sort of a compromise about the "automatic, built-in, out of the box" part of the GC thing.
16:58:17 <mdmkolbe> Cale: is the GHC GC generational or what?
16:58:28 <Cale> mdmkolbe: Yeah, it's a hybrid actually, iirc.
16:58:38 <xif> it's "or what", a new exciting technology.
16:58:58 <Cale> http://hackage.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
16:59:00 <lambdabot> Title: GarbageCollectorNotes - GHC - Trac
16:59:34 <lispy> xif: Well, in the same way that people used in-line assembly to write games in the beginning.  That practice is pretty much gone from modern commercial games.
16:59:36 <Cale> mm... I'm not sure if that's quite up to date though
17:00:05 <mdmkolbe> heh, the author of that page is at my school.  I guess I'll have to ask him about it when get gets back from summer
17:00:20 <xif> lispy: yeah, not a bad perspective there, I guess
17:00:49 <xif> lispy: although... afaik, they still use inline-assembly in the most cutting edge, squeeze-every-cycle engines,
17:01:13 <xif> so maybe if you want to save every cycle, there's no alternative to Assembly :)
17:01:14 <lispy> xif: perhaps, and probably also on consoles
17:01:44 <bos> there's just about no assembly in any modern game.
17:02:03 <bos> you might find perhaps fifty lines of it in a 1-million-line engine.
17:02:04 <mdmkolbe> bos: the physics engine and rendering engine will have assembly
17:02:06 <xif> bos: are you sure?  I recall reading about assembly in graphic engines.
17:02:09 <chrisdone> is there a âmaybeâ kind of function for Either?
17:02:16 <mdmkolbe> @type maybe
17:02:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:02:23 <mdmkolbe> @type either
17:02:24 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
17:02:30 <mdmkolbe> @index either
17:02:30 <lambdabot> Data.Either, Prelude
17:02:34 <lispy> ?hoogle maybeM
17:02:36 <chrisdone> ah, thanks :)
17:02:39 <lambdabot> No matches found
17:03:05 <mdmkolbe> @type maybe mzero return
17:03:07 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
17:03:11 <lispy> Wasn't there a functor or monad equivalent of maybe?
17:03:39 <mdmkolbe> lispy: like "maybe mzero return"? ;-)
17:03:57 <chessguy> @type maybe mzero return
17:03:58 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
17:04:19 <lispy> But, that's just Maybe a -> m a, not b -> (a -> b) -> m a -> b
17:04:28 <bwr> http://hpaste.org/9015  how would i have done the input here better
17:04:56 <lispy> :t (>>=)
17:04:57 <SibeST> Maybe is an haskell keyword?
17:04:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:05:21 <augustss> lispy: there can't be a general function of the type you mentioned
17:05:27 <mdmkolbe> SibeST: "Maybe" is the name of a haskell type (technically it is a type constructor not a type)
17:05:30 <augustss> Except the trivial one
17:05:34 <lispy> augustss: not for monads, what about functors?
17:06:06 <augustss> lispy: you can't get out of a monad, nor a function.  In a general way, I mean
17:06:14 <mdmkolbe> @type liftM
17:06:16 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:06:20 <augustss> s/function/functor/
17:06:59 <LordBrain> since all monads are functors, it's absence for monads would imply its absence for functors
17:07:02 <mdmkolbe> lispy: is liftM closer to what you want?
17:07:10 <chessguy> what's the trivial one? undefined?
17:07:41 <lispy> mdmkolbe: bind, (>>=) is about as close as monad can get
17:08:42 <lispy> mdmkolbe: actually, yeah liftM is equally close, maybe closer
17:09:30 <mdmkolbe> @src liftM
17:09:31 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:10:35 <lispy> One of the coolest thing about Haskell types is that they can specify a relationship between values.
17:11:15 <lispy> In that type for liftM, the function parameter isn't just a function parameter, the type also says how the result of the function is related to the result of liftM
17:11:31 <chrisdone> :t bool
17:11:32 <lambdabot> Not in scope: `bool'
17:12:09 <augustss> There should have been a 'bool' function
17:12:10 <hackage> Uploaded to hackage: Pugs 6.2.13.8
17:12:10 <mdmkolbe> Any haskell optimization wizards around here? This code (http://hpaste.org/9020) takes 3 seconds to run, but I think it should take less than that (it only does ~30,000 loops).  I've never really learned how to optimize haskell code, but I guess it's about time I do.  Any takers?
17:12:22 <lispy> The type of liftM could be just, (->) -> m a -> m r, but then we wouldn't know as much about liftM as we do now
17:12:24 <mdmkolbe> @ iff
17:12:29 <mdmkolbe> @type iff
17:12:31 <lambdabot> Not in scope: `iff'
17:12:43 <lispy> mdmkolbe: iff p t e = if p then t else e
17:13:11 <mdmkolbe> iff == bool ?
17:13:25 <lispy> mdmkolbe: you can optimize with ghc pretty easily using the profiler.  It has high quality output and spending some time now learning to use it will likely save time later
17:13:41 <lispy> > let iff p t e = if p then t else e in iff True 1 0
17:13:43 <lambdabot>  1
17:13:49 <lispy> > let iff p t e = if p then t else e in iff False 1 0
17:13:51 <lambdabot>  0
17:13:54 <lispy> Is that whan you are thinki ngof?
17:14:06 <sjanssen> 'bool' would probably have the arguments flipped
17:14:10 <sjanssen> @src Bool
17:14:11 <lambdabot> data Bool = False | True deriving (Eq, Ord)
17:14:18 <chrisdone> sjanssen: good point
17:14:24 <lispy> Normally, in english math, iff is "if and only if"
17:14:55 <LordBrain> yeah it's a confusing name
17:14:59 <chrisdone> > let bool s e p = if p then s else e in map (bool 1 2) [True,False]
17:15:00 <lispy> ?src bool
17:15:00 <lambdabot> Source not found. There are some things that I just don't know.
17:15:02 <lambdabot>  [1,2]
17:15:13 <LordBrain> some people use if'
17:15:49 <lispy> It's really too bad the Prelude didn't include a first class "if" from the beginning.
17:16:27 <chrisdone> I suppose it doesn't make sense because of the argument order
17:16:35 <mdmkolbe> lispy: for learning the profile do you recomend the GHC manual or something else?
17:16:50 <LordBrain> you could call it when
17:17:10 <lispy> mdmkolbe: I found the manual + #haskell to be adequate, YMMV.  There is a chapter on it in the manual and they talk about cost centers
17:17:13 <LordBrain> or is that already in the prelude?
17:17:16 <LordBrain> @src when
17:17:17 <lambdabot> when p s = if p then s else return ()
17:17:17 <lispy> :t when
17:17:18 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:17:25 <chrisdone> :t whenM
17:17:26 <lambdabot> Not in scope: `whenM'
17:17:31 <chrisdone> ;_;
17:17:41 <lispy> "when" doesn't really inspire an 'else' branch to me
17:17:47 <lispy> So, I still prefer "if"
17:17:51 <chrisdone> lispy: you would say that :P
17:18:06 <chrisdone> nah, lisp jokes aside, me too
17:18:16 <lispy> :)
17:18:40 * chrisdone listening to the Shawshank Redemption soundtrack
17:19:03 <LordBrain> hmmm, could call it yesno
17:19:09 <LordBrain> or something
17:19:31 <lispy> darcs has a UI prompting function called yorn actually :)
17:19:35 <LordBrain> we could have our own terary operator
17:20:02 <lispy> Hm...what would the type be
17:20:07 <lispy> It would be two operators, right?
17:20:09 <LordBrain> same as if
17:20:15 <LordBrain> oh
17:20:28 <LordBrain> well we want it to be first order
17:20:43 <lispy> let (?) :: Bool -> ??; (:) :: a -> b -> Either a b
17:21:05 <lispy> Oh wait, we restrict a and b to the same type
17:21:08 <LordBrain> i suppose it could be bool -> (a,a)
17:21:16 <chrisdone> O_o
17:21:25 <LordBrain> hmmm no
17:21:35 <LordBrain> lol
17:21:55 <lispy> We can't use (:), so I propose, (:')
17:22:10 <lispy> or, <:>
17:22:12 <LordBrain> Bool -> (a,a) -> a
17:22:53 <chrisdone> <=>, less than, equal to, or greater than
17:22:59 <LordBrain> lol
17:24:47 <LordBrain> (:') a b = (a,b) :: (a,a)
17:25:30 <LordBrain> (?) b (x,y) = if b then x else y
17:25:41 <LordBrain> give the : higher precedence
17:26:46 <chessguy> hm? what are we doing?
17:26:59 <dolio> :' isn't a valid operator name, is it?
17:27:23 <SibeST> how can i do if (a > b) c = a; else c = b; in haskell plz
17:27:29 <mdmkolbe> dolio: it would be a valid constructor name but not operator name
17:27:33 <dolio> ' is part of the prefix identifier syntax.
17:27:51 <dibblego> let c = max a b
17:27:54 <dibblego> ?type max
17:27:58 <lambdabot> forall a. (Ord a) => a -> a -> a
17:28:03 <dolio> > let (<') a b = (a,b) in a <' b
17:28:03 <lambdabot> Unbalanced parentheses
17:28:16 <Zao> SibeST: if predicate then true_value else false_value
17:28:32 <LordBrain> SibeST, let c = if a>b then a else b
17:28:43 <mdmkolbe> dolio: let me take that back.  IIRC ' is a "lower case letter" in haskell so :' would be as invalid as :a
17:28:46 <Zao> I didn't want to give him the whole solution, since it reeks of homework.
17:28:47 <SibeST> cool
17:28:50 <LordBrain> or use the max function like dibblego suggested
17:28:57 <dolio> mdmkolbe: Right.
17:30:07 <LordBrain> are we allowed to start things with : ?
17:30:19 <LordBrain> things being identifiers
17:30:41 <mdmkolbe> LordBrain: ":" is allowed to start constructor names
17:30:49 <LordBrain> > let a :' b = a in 1 :' 2
17:30:50 <lambdabot>  Improperly terminated character constant at "'" (column 8)
17:30:53 <mdmkolbe> @type (:)
17:30:54 <lambdabot> forall a. a -> [a] -> [a]
17:31:25 <LordBrain> > let (:') a b = a in 1 :' 2
17:31:26 <lambdabot> Unbalanced parentheses
17:31:35 <mdmkolbe> > data MyList a = a :+ b
17:31:36 <lambdabot>  Parse error at "data" (column 1)
17:31:52 <mdmkolbe> LordBrain: ":" can't start operator names
17:56:22 <mdmkolbe> well I've profiled the code, the only thing that stand out to me is that it is doing a *lot* of allocation (e.g. 1GB if I run it on 50,000).  But I'm not sure where the cost is coming from.  I do make about 200,000 updates to the Data.Map.Map, could it be that or maybe too many thunks?  (This code should be able to run strictly)
17:57:49 <dolio> Where does it allocate?
17:58:09 <dolio> Also, how much does it allocate when you're not profiling? Profiling increases allocation a lot.
17:58:27 <mdmkolbe> dolio: how do I found out how much it allocates when not profiling?
17:58:37 <dolio> +RTS -sstderr
18:00:01 <mdmkolbe> 25% of the allocation comes from the call to DoubleMap.insert, another 19% from the length function
18:01:24 <mdmkolbe> Non-profiling run:
18:01:24 <mdmkolbe> 1,174,555,836 bytes allocated in the heap
18:01:24 <mdmkolbe> 821,338,036 bytes copied during GC (scavenged)
18:01:24 <mdmkolbe>  30,408,656 bytes copied during GC (not scavenged)
18:01:24 <mdmkolbe> 142,983,168 bytes maximum residency (11 sample(s))
18:01:46 <dolio> Hmm.
18:02:07 <dolio> I guess profiling doesn't increse it that much in your case. :)
18:02:56 <mdmkolbe> (it would be nice if I could figure out how much of that is in the "closed" DoubleMap object)
18:03:33 <dolio> Is DoubleMap something you wrote?
18:03:42 <mdmkolbe> though I'll note that without profiling it runs twice as fast
18:04:04 <dolio> Heh, that's not too surprising.
18:04:07 <mdmkolbe> dolio: yes, it combines two data.maps together.
18:04:33 <mdmkolbe> it models a set of (k1,k2,v) were each k1 or k2 uniquely determines the tuple
18:05:02 <mdmkolbe> It's about ten lines of code (see the bottom of http://hpaste.org/9020)
18:05:18 <mdmkolbe> (err ... maybe twenty)
18:05:38 <mdmkolbe> (thirty tops)
18:05:41 <mdmkolbe> ;-)
18:05:47 <dolio> :)
18:06:04 <mdmkolbe> it feels like ten lines
18:07:12 <dolio> This is the code in question?
18:07:20 <dolio> That allocates 1 GB?
18:08:09 <mdmkolbe> yes except that the constant 9999 was changed to 50,000 to make profiling easier
18:08:18 <mdmkolbe> (see the "main" line)
18:08:31 <dolio> Okay.
18:11:38 <dolio> At a guess, I'd say length allocates a lot because that list comprehension doesn't get deforested.
18:12:57 <mdmkolbe> so do "sum (map (word_widths!) [start..end-1]" instead?
18:13:12 <dolio> I don't know if that will fix it or not.
18:13:37 <dolio> If worse comes to worst, you could probably precompute partial sums or something.
18:13:48 <mdmkolbe> dolio: how do I find out if it is deforested?
18:14:00 <dolio> So that instead of sum [...] you'd have 'sums ! end - sums ! start'
18:14:25 <dolio> Well, looking at the core would tell you, I think.
18:14:26 <mdmkolbe> that would be a 2d matrix of order 50,000
18:14:36 <mdmkolbe> (not good)
18:15:10 <dolio> Eh? It'd be the same as word_widths.
18:15:25 <mdmkolbe> word_widths is a 1d matrix
18:15:36 <mdmkolbe> (err array)
18:15:53 <dolio> sums ! i = sum [ word_widths ! x | x <- [0..end-1] ] or something like that.
18:16:26 <dolio> Then sums ! i - sums ! j = sum [ word_widths ! x | x <- [i .. j - 1] ]
18:17:30 <mdmkolbe> dolio: oh (sums ! i) - (sums ! j), I thought you meant (sums ! (i - sums)) ! j
18:17:57 <mdmkolbe> (FYI, map didn't work, I'll try sums trick now)
18:19:58 <dolio> I messed that up a little.
18:20:19 <dolio> sums ! j - sums ! i = sum [ word_widths ! x | x <- [i .. j - 1] ]
18:20:22 <dolio> I think that's right.
18:20:52 <dolio> Of course, you also have to ensure that j > i.
18:24:35 <dolio> Another thought is making the Map components of DoubleMap strict. You may be allocating thunks in insert due to that.
18:25:01 <dolio> So '... DoubleMap { firstMap :: !Map.Map ... }'
18:25:42 <mdmkolbe> dolio: that gives "DoubleMap.hs:6:4:
18:25:42 <mdmkolbe>     Unexpected strictness annotation: !Map.Map
18:25:42 <mdmkolbe>     In the data type declaration for `DoubleMap'
18:25:42 <mdmkolbe> " which I don't understand
18:25:58 <dolio> Hmm...
18:26:31 <dolio> Oh, you might need parentheses around the type (since Map is just a constructor).
18:26:40 <dolio> !(Map.Map k1 (k2,v))
18:26:54 <dolio> If that doesn't work I'm going to have to do some looking up.
18:26:57 <mdmkolbe> ah, that works
18:30:20 <dolio> foldl' may be appropriate in loop, as well, since the maps are strict.
18:30:31 <mdmkolbe> strictness cuts the run time down by 66% (though allocation stays mostly the same less is scavanged)
18:30:39 <mdmkolbe> @type foldl'
18:30:55 <lambdabot> thread killed
18:31:03 <mdmkolbe> @type foldl
18:31:04 <dolio> foldl' is the same as foldl, but it forces the accumulator at each step.
18:31:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:31:15 <dolio> It's in Data.List.
18:32:08 <dolio> The allocation may not be the cause of the slowness.
18:32:18 <dolio> The problem may just require that much allocation.
18:32:49 <dolio> Although, length probably doesn't need to allocate that much.
18:45:02 <elaforge> anyone around?  anyone know if there's a way to get the effect of concatMapAccumL on a ByteString?
18:46:39 <dolio> @hoogle concatMapAccumL
18:46:39 <lambdabot> No matches found
18:47:00 <elaforge> yeah, it doesn't exist, that's the thing :
18:47:01 <elaforge> :)
18:47:44 <elaforge> I wound up doing a foldl accumulated with ++, and then repacking the list
18:47:49 <elaforge> but I might as well be working with lists then
18:47:54 <dolio> So that'd be... (a -> Word8 -> (ByteString, a)) -> a -> ByteString -> ByteString?
18:47:58 <dolio> Or something like that?
18:48:51 <elaforge> yeah
18:49:05 <elaforge> basically, each element can produce zero or more elements in the output
18:49:16 <elaforge> which is concatMap, but then I want to carry state from left to right
18:49:55 <dolio> I think a fold is the best you'll accomplish with that.
18:50:24 <elaforge> yeah, but it's unpacking the entire bytestring to a list, then repacking :/
18:51:08 <dolio> Well, I mean you can fold over a byte string...
18:51:26 <dolio> I'd have to think about which one you'd want to use.
18:51:40 <elaforge> seems like there should be a way to use a foldr and then oh... and then foldr chunks maybe
18:52:11 <elaforge> yeah, but only foldl carries state from the left
18:52:50 <dolio> Yeah. I was thinking doing a foldl with a (DList ByteString, a) as the accumulator.
18:52:58 <dolio> Since DList can fast snoc.
18:53:09 <mdmkolbe> dolio: FYI, the sums trick shaves off another 30%
18:53:13 <dolio> And then at the end you call concat.
18:53:23 <elaforge> hmm, oh or if I use lazy bytestring, append has good complexity
18:53:37 <dolio> mdmkolbe: Cool. How's the overall performance now.
18:53:42 <elaforge> unfortunately I lied, I'm actually using StorableVector, whose lazy version is inocmplete
18:53:50 <dolio> elaforge: Does it? I don't think repeatedly appending at the end would be good.
18:54:33 <elaforge> it says append is "O(n\c)/", whatever that means
18:54:53 <dolio> That's basically O(n) I think.
18:54:55 <elaforge> I guess it's less than n, because the module doc says "... append ... has better complexity" :)
18:55:07 <dolio> c is the chunk size, I think.
18:55:11 <hml> ask >>= \w -> doF . W.float w . snd =<< liftX (floatLocation w) ;  how can i rewrite this using >>= ?
18:55:40 <elaforge> I'd imagine it would only have to copy the last chunk, which would be much better than copying the whole array
18:55:44 <dolio> Or n\c is probably number of chunks.
18:56:11 <elaforge> ah right, so copy the chunk list, and then the last one
18:56:19 <dolio> Right.
18:56:42 <elaforge> yeah, I guess DList sounds like the best option still
18:57:07 <elaforge> kinda frustrating that concatMap is there, and is *almost* right
18:58:30 <mdmkolbe> dolio: well 4 seconds (down from 15) to line-break 50,000 words isn't too bad (It's exploring 200,000 points in the search space), but it's borderline whether this is fast enough (interactive program with several other (similar) things too do as well)
18:59:06 <mdmkolbe> dolio: if there are no other obvious things to squese out of the haskell it may be time to start exploring the algorithm space
18:59:25 <dolio> mdmkolbe: I'd profile again.
19:03:06 <mdmkolbe> dolio: insert takes 35%/45% of time and alloc, but the other numbers seem whacky (e.g. solve takes 20% of the time but none of it's subexpressions account for it.  also the profile takes 20 sec when non-profile takes 4 sec so I'm not sure how reliable it is
19:03:35 <dolio> Well, profiling is guaranteed to slow things down.
19:04:17 <mdmkolbe> but are the numbers still meaning full (e.g. maybe that 20% is the profiling code and not the true code costs)
19:05:04 <dolio> Well, it's possible it screws things up, but it's typically representative, I think.
19:05:44 <elaforge> dolio, it seems like it would be possible as a new primitive to bytestring
19:05:56 <elaforge> possible to avoid the unpack -> pack I mean
19:06:15 <dolio> elaforge: Where do you have to unpack?
19:06:39 <elaforge> well, if we accumulate in a DList, it all gets unpacked into the DList
19:07:17 <elaforge> then the chunks have to get repacked into the array again
19:08:12 <dolio> Yeah, there is some intermediate structure that could be avoided, I suppose.
19:08:26 <elaforge> if there were an ST interface maybe I could do it imperative style by passing a pointer to copy into
19:09:13 <elaforge> or presumably inside the unsafe internals
19:10:24 <dolio> elaforge: It's only possible to do better for Data.ByteString.Lazy, though.
19:10:40 <dolio> The DList is about as good as you'll get for strict byte strings.
19:11:02 <mdmkolbe> BTW how do I annotate a function argument as strick?
19:11:06 <mdmkolbe> **strict
19:11:19 <dolio> foo !strict = ...
19:11:27 <dolio> With {-# LANGUAGE BangPatterns #-}
19:12:01 <elaforge> well, couldn't I theoretically do imperative style array append where I resize when I hit the end?
19:12:03 <dolio> Otherwise you have to use seq.
19:12:15 <elaforge> granted, chunks would fit more naturally because then I don't have to realloc
19:12:55 <dolio> You could, but with the DList you only reallocate once.
19:13:23 <elaforge> hmm, I wonder if I could use some kind of unfold for this
19:13:24 <dolio> You get all the chunks, figure out their total size, allocate a single chunk, and copy in.
19:13:44 <mae1> hi
19:14:09 <mdmkolbe> mae1: hi
19:14:35 <mae1> if haskell were a person
19:14:38 <elaforge> yeah, not so lazy that way :)
19:14:50 <mae1> would it be able to relate to the dark knight or the joker more intimately?
19:15:35 <dolio> There's no reallocation of memory chunks at all for the lazy way. Just reallocation of the lazy list structure.
19:16:03 <mdmkolbe> dolio: hmm, when I put SCC around the inner insert calls those SCC's don't show much cost.  So perhaps I should use unboxed tuples and a newtype on the assumption that the allocation cost is for the wrapper object?
19:16:28 <elaforge> idealy I'd write to the last chunk until it's full, then "emit" it, and start on the next chunk
19:16:59 <dolio> mdmkolbe: I'm not sure. I've not had much luck pinpointing cost of subexpressions with manual SCC annotation.
19:17:51 <dolio> I don't think the lazy strings consolidate chunks like that. concatMap doesn't, at least.
19:18:17 <elaforge> dolio, err, by "lazy way" do you mean DList, or some kind of foldr + chunks constructor thing?
19:19:07 <dolio> I mean if you're implementing concatMap... for lazy strings, you don't have to reallocate chunks at all.
19:19:55 <dolio> You just have to go from intermediate DList/List structure to Chunk c1 (Chunk c2 ... (Chunk cN Empty)).
19:19:57 <elaforge> don't you wind up with a lot of small chunks then (assuming the function emits say 0-10 elts)
19:20:41 <elaforge> I mean, if you have 1 size chunks then you're back to a boxed list, right?
19:21:14 <dolio> Yes, but that's how concatMap is currently.
19:22:49 <elaforge> hmm, yeah so either I try to go all low level inside the library, or I just live with the list :)  actually in my case list is probably ok, I'm just theoretically interested
19:23:08 <mdmkolbe> dolio:
19:23:21 <mdmkolbe> (ignore last line, \n on wrong window)
19:26:11 <elaforge> hmm, so [1] ++ ([2]++[3]) copies the 2 and then the 1, i.e. O(n)
19:26:30 <elaforge> while ([1]++[2]) ++ [3] winds up copying 1 twice and 2 once
19:26:54 <elaforge> hence foldr (++) is nicer than foldl (++)?
19:27:49 <dolio> Yes.
19:28:11 <elaforge> cool, it took me surprisingly long to notice that basic fact :)
19:28:16 <elaforge> dolio, thanks for all your help
19:28:29 <dolio> No problem.
19:28:37 <dolio> > BSLC.toChunks (BSLC.concatMap (\c -> BSLC.pack [c]) (BSLC.pack "abcde"))
19:28:39 <lambdabot>  ["a","b","c","d","e"]
19:29:55 <lispy> what is BSLC?
19:30:00 <lispy> ByteString Lazy?
19:30:02 <elaforge> hmm, I wonder if that means a unpack->pack could actually be more efficient
19:30:05 <dolio> ByteStringLazyChar
19:30:21 <elaforge> because you wind up repacking the chucks into their ideally cacheable size
19:31:01 <dolio> > BSLC.toChunks (BSLC.pack . PSLC.unpack $ BSLC.concatMap (\c -> BSLC.pack [c]) (BSLC.pack "abcde"))
19:31:02 <lambdabot>   Not in scope: `PSLC.unpack'
19:31:08 <dolio> > BSLC.toChunks (BSLC.pack . BSLC.unpack $ BSLC.concatMap (\c -> BSLC.pack [c]) (BSLC.pack "abcde"))
19:31:10 <lambdabot>  ["abcde"]
19:31:17 <elaforge> err, I guess I'm assuming the next consumer down the line won't repack them... I don't really understand the fusion thing too well
19:31:47 <dolio> Yes, well, in ideal fusion, there wouldn't be any chunks, I guess.
19:32:33 <dolio> Or, no chunks besides the ones that get read from disk.
19:32:59 <elaforge> yeah, but then if we get to the data parallel stuff we're back to chunks again :)
19:40:35 <dolio> I must admit I'm not entirely clear on how data parallel stuff interacts with stream fusion.
19:40:54 <dolio> Data parallelism is about operating on pieces of the data structure in parallel...
19:41:15 <dolio> And stream fusion is about eliminating the data structure entirely to produce a tight loop.
19:41:45 <Trinithis> is there a point to asTypeOf when there is the GHC (x :: Type)?
19:41:53 <dolio> I guess together you get tight loops that you can run on each chunk.
19:42:52 <elaforge> well, I remember the paper stressing the importance of fusing *after* you flatten and divide up the work
19:42:56 <dolio> Trinithis: There are probably uses that are obviated by ScopedTypeVariables.
19:43:11 <Trinithis> ScopedTypeVariables?
19:43:12 <elaforge> since they kind of work at cross purposes
19:43:47 <dolio> Trinithis: Like 'foo :: a -> b ; foo a = ... where x :: a ; x = ...'
19:43:54 <dolio> Where a and x are supposed to have the same type.
19:44:21 <Trinithis> didn't know you could have a function with type a -> b
19:44:41 <dolio> Well, pretend the type makes sense. :)
19:45:03 <dolio> But a is some kind of polymorphic.
19:45:20 <Trinithis> ok
19:45:38 <thoughtpolice> since ndp arrays are strict I would think fusion would kick in after vectorisation; after the work is divided, you take the components and fuse them aggresively so each parallel operation has as few intermediates as possible
19:45:58 <thoughtpolice> then again i wouldn't know, i'm still just trying to get a copy of the GHC head so I can try NDP, but still to no avail.
19:46:04 <thoughtpolice> darcs.haskell.org has forsaken me i guess.
19:46:06 <dolio> And you need x to be the particular type that a is, but it's not any particular concrete type.
19:46:20 <elaforge> thoughtpolice, yeah, that's the gist of what the paper says
19:46:32 <Trinithis> dolio: thx.. makes sense
19:46:36 <dolio> That snippet I wrote above doesn't cut it, because 'x :: a' is take to mean that x is forall a. a, not the particular a given in the type signature for foo.
19:47:07 <dolio> So, scoped type variables let you write instead: 'foo :: forall a. a -> b ; foo a = ... where x :: a ; x = ...'
19:47:40 <dolio> Where the forall a. is required in the type of foo to indictate that you want it scoped. Then the type signature for x indicates that it's that particular a.
19:47:41 <thoughtpolice> elaforge: i'm not sure where the vectorisation pass in the compiler happens in relation to the others, but i'd think vectorisation then fusion would be a lot easier than the inverse.
19:47:49 <thoughtpolice> elaforge: what paper?
19:48:07 <dolio> But you could instead do 'foo :: a -> b ; foo a = ... where x = (...) `asTypeOf` a'.
19:48:34 <dolio> Granted, there aren't many situations where this is all strictly necessary.
19:48:45 <elaforge> data parallel haskell: a status report
19:49:18 <bwr> i have much refactored my IO after reading some stuff on the net http://hpaste.org/9022  is it possible to do something like   "x <- read $ getLine"
19:49:56 <elaforge> bwr, maybe x <- readIO =<< getLine
19:49:58 <Trinithis> k
19:50:08 <elaforge> or x <- fmap read getLine
19:50:11 <thoughtpolice> bwr: x <- liftM read getLine
19:50:19 <bwr> cool, thanks a lot guys
19:51:16 <Cale> liftM read getLine = readLn
19:51:38 <bwr> oh jeez... there is just a plain function that is what i need?
19:53:01 <bwr> sure enough
19:53:03 <bwr> that works perfect
20:06:45 <chrisdone> I'm messing about with higher order functions
20:07:00 <chrisdone> I have this: *HTML> html $ b "Hello, " . (b ! "foo") "World!" => "<b>Hello, </b><b foo>World!</b>"
20:07:13 <chrisdone> but I'd like not to have to use parentheses there, is this possible?
20:09:28 <johnnowak> yes, wouldn't want my tree-assembling code to look like a tree
20:10:20 <b7j0c> is there a way in haskell to have a path (directory) delimiter that is platform independent? i.e. a haskell symbolic constant resolved to be the path delimiter on any platform running the code?
20:10:41 <chrisdone> if that is some subtle comment it is quite boring, I am afraid
20:11:23 <chrisdone> b7j0c: hm, I have seen something like that in the hackage source, although I'm not sure how recommended the method is. let me look...
20:11:25 <lament> @hoogle Path
20:11:26 <lambdabot> Test.HUnit.Base.Path :: type Path
20:11:26 <lambdabot> Data.Graph.path :: Graph -> Vertex -> Vertex -> Bool
20:11:26 <lambdabot> Test.HUnit.Base.path :: State -> Path
20:11:30 <lament> nein
20:11:34 <lament> @hoogle FilePath
20:11:34 <lambdabot> System.FilePath :: module
20:11:34 <lambdabot> Prelude.FilePath :: type FilePath
20:11:34 <lambdabot> System.IO.FilePath :: type FilePath
20:11:59 <b7j0c> as far as i know, FilePaths are just Strings (?)
20:12:11 <chrisdone> yes, it's a synonym
20:12:13 <chrisdone> @src FilePath
20:12:14 <lambdabot> type FilePath = String
20:12:28 <lament> you made me do it
20:12:52 <chrisdone> pardon?
20:13:11 <b7j0c> hmmm, sounds like i am out of luck. is there at least a platform-detection mechanism?
20:13:21 <b7j0c> like #IF WINDOWS etc etc
20:13:28 <allbery_b> System.FilePath is the approved way to do it
20:13:41 <allbery_b> note the first return from hoogle
20:13:41 <golubovsky> Hi everybody, Dimitry here.
20:13:58 <jsnx> golubovsky: howdy
20:14:08 <b7j0c> allbery_b - as far as i can tell, they have no platform checks? no checks of any kind
20:14:14 <b7j0c> just Strings
20:14:23 <allbery_b> that's just the basic type
20:14:23 <jsnx> so, now we have millions of threads
20:14:33 <b7j0c> ah, sorry, i see
20:14:39 <lament> > pathSeparator
20:14:41 <b7j0c> there are two FilePaths
20:14:45 <jsnx> what if we had 'FileURL' and open and all that worked in terms of URLs?
20:14:45 <allbery_b> the *module* System.FilePath exports System.FielPath.Windows or System.FilePath.Posix according to platform
20:14:54 <lambdabot>  thread killed
20:14:57 <allbery_b> http://www.haskell.org/ghc/docs/latest/html/libraries/filepath/System-FilePath-Windows.html
20:14:59 <lament> > pathSeparator
20:14:59 <lambdabot>   Not in scope: `pathSeparator'
20:15:00 <lambdabot> Title: System.FilePath.Windows, http://tinyurl.com/6afgzh
20:15:21 <allbery_b> @index pathSeparator
20:15:21 <lambdabot> Distribution.Compat.FilePath
20:15:31 <jsnx> b7j0c: you want to be able to detect which platform you're on, or you just want to use the right FilePath?
20:15:48 <lament> the right FilePath gets imported automatically
20:15:54 <jsnx> so, we have millions of threads, i was saying
20:16:00 <jsnx> and i wonder, what is that good for?
20:16:00 <b7j0c> jsnx - just use the right one. sounds like i was confusing Prelude.FilePath with System.FilePath
20:16:05 <lament> observe: http://www.haskell.org/ghc/docs/latest/html/libraries/filepath/src/System-FilePath.html
20:16:06 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5grgqo
20:16:14 <jsnx> i mean, it's cool
20:16:15 <allbery_b> import System.FilePath, the right thing happens
20:16:26 <b7j0c> thanks allbery_b!
20:16:36 <jsnx> are there any plans to exploit it for parallelism?
20:16:54 <golubovsky> I have a Cabal-related question: given an installed package name, and name of an data file within a package, is it possible to obtain a full path to the file?
20:16:54 <b7j0c> thanks to all and have a great evening
20:17:10 <lament> #if defined(mingw32_HOST_OS) || defined(__MINGW32__)
20:17:13 <lament> looks so ugly
20:17:18 <lament> like C, not Haskell :(
20:17:45 <lament> does haskell really have a preprocessor?
20:17:51 <lament> *GHC
20:17:53 <jsnx> golubovsky: http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
20:17:54 <lambdabot> Title: Neil Mitchell's Haskell Blog: Adding data files using Cabal, http://tinyurl.com/364awx
20:18:00 <chrisdone> GHC has rules
20:18:13 <jsnx> it also uses the C preprocessor
20:18:16 <chrisdone> I don't know about other stuff
20:18:19 <lament> jsnx: it does?
20:18:27 <jsnx> yeah
20:18:30 <lament> that's what parses the #ifdefs?
20:18:36 <jsnx> yeah
20:18:45 <lament> ugly :)
20:18:58 <lament> (but works)
20:19:17 <jsnx> well, honestly, it probably wasn't so important to have a nice pre-processor
20:19:26 <jsnx> and now we have Template Haskell
20:19:56 <jsnx> I guess we have three macro languages in Haskell -- RULES, CPP, and TH
20:20:46 <golubovsky> jsnx: Thanks, I just have looked at this page: but I have a feeling that this has to do with the future support for Hoogle: is there anything in the existing Cabal?
20:21:30 <andyjgill_> http://www.haskell.org/haskell-symposium/2008/accepted.html
20:21:31 <lambdabot> Title: ACM SIGPLAN 2008 Haskell Symposium Accepted Papers
20:21:52 <jsnx> golubovsky: oh, you are right
20:21:53 <golubovsky> OK, to simplify the questions: given a package name, how to tell where it is installed?
20:22:10 <jsnx> golubovsky: i wonder if that is even possible
20:22:42 <golubovsky> ghc-pkg describe <package> outputs something, but is this available as a library?
20:23:17 <jsnx> it might be easier to just stick all the data in a ByteString literal and put it in <project root>/Data/Foo.hs
20:24:31 <golubovsky> jsnx: I'm afraid this is not sufficient just to encode data in my case. To put it simple: I am writing a backend for Yhc Core say to Erlang. The package carries some Erlang module(s)
20:25:22 <golubovsky> which have to be installed with package. These modules should be available to Erlang runtime, Haskell runtime will not even be involved at that time.
20:25:47 <jsnx> hmmmm
20:25:59 <jsnx> no idea
20:26:09 <golubovsky> So, I might as an option just run ghc-pkg as external command, and them grep its output for what I need, but I am looking for a more elegant solution.
20:27:17 <golubovsky> In Yhc/Javascript I just located the Javascript runtime to put on web page relatively to installed Yhc. Now I am splitting that stuff across packages of different kinds:
20:27:55 <golubovsky> front-ends, back-ends, central Core, and drivers (to integrate everything together). So some independence is needed.
20:31:28 <jsnx> hmmm
20:31:46 <jsnx> what is this system you are building?
20:32:02 <jsnx> there's javascript, Yhc, GHC and Erlang?
20:32:21 <jsnx> don't mean to change the subject, i'm just curious
20:32:42 <golubovsky> This was mentioned periodically, I use Ndm's Yhc Core library to translate Haskell to various runtimes. I had some success with Javascript, and Erlang.
20:33:05 <jsnx> interesting
20:33:23 <TomMD> andyjgill_: Nice list.  Not sure if I'll make it, but I am curious what others think about using Information Flow techniques in high reliability software - it isn't sound but perhaps sufficient for some people.
20:33:26 <jsnx> golubovsky: may i ask, what does your translation to erlang do?
20:33:46 <golubovsky> Now I am just putting things in order. I have somewhat working Hugs front-end, and am currently massaging the experimental Erlang back-end.
20:33:54 <jsnx> golubovsky: does each function run as its own erlang process?
20:34:15 <uLTRAMMMAGNUSS> HI
20:34:23 <jsnx> uLTRAMMMAGNUSS: hello
20:34:26 <uLTRAMMMAGNUSS> ANY PEOPLE HERE?
20:34:31 <uLTRAMMMAGNUSS> HELLO
20:34:31 <jsnx> uLTRAMMMAGNUSS: all bots
20:34:35 <golubovsky> jsnx: translation to erlang takes Yhc Core (from file or memory) and produces Core Erlang. The latter is pretty close to the former, except that Erlang is all strict.
20:34:51 <uLTRAMMMAGNUSS> WHERE ARE MOST OF YOU FROM?
20:35:07 <jsnx> uLTRAMMMAGNUSS: stop with the all caps
20:35:15 <uLTRAMMMAGNUSS> ok
20:35:32 <uLTRAMMMAGNUSS> where are most of you from?
20:35:40 <uLTRAMMMAGNUSS> which countries
20:35:41 <jsnx> uLTRAMMMAGNUSS: you first
20:35:43 <TomMD> uLTRAMMAGNUSS: Also, if you are interested in haskell you found the right place.  More general chat belongs in #haskell-blah
20:35:46 <uLTRAMMMAGNUSS> from Chile
20:35:52 <uLTRAMMMAGNUSS> and you?
20:36:06 <jsnx> uLTRAMMMAGNUSS: please take this conversation to #haskell-blah
20:36:13 <golubovsky> So I have to take care of thunks and such. I wrote about this here: http://yhc06.blogspot.com/2008/05/haskell-on-beams.html and here: http://yhc06.blogspot.com/2008/03/yhcjavascript-backend.html
20:36:15 <lambdabot> Title: York Haskell Compiler: Haskell on BEAMs
20:36:22 <jsnx> golubovsky: so, the net effect is a single erlang function/process?
20:36:29 <jsnx> oh
20:36:31 <jsnx> thank you
20:36:40 <mdmkolbe> it appears that Data.Map is using binary trees, is there a version somewhere that uses a higher fan-out (e.g. B-trees)
20:36:42 <golubovsky> the net effect is a large BEAM file produced from linked Core.
20:37:17 <bd_> mdmkolbe: Hm, does higher fanout help with an in-memory structure? I was under the impression higher fanout traded increased cpu for less seeks
20:38:23 <mdmkolbe> bd_: I'm not sure, but since I am doing a lot of inserts and deletes to this structure >100,000, a higher fan-out may reduce allocation costs which seem to be the limiting factor right now
20:39:01 <bd_> mdmkolbe: ah, true... though it might also increase pressure on the nursery generation (since the objects it's allocating are larger)
20:39:21 <golubovsky> jsnx: so far, this has been producing BEAM files that one can load into Erlang shell and call functions from command line with some precautions as types are not checked ;)
20:40:17 <mdmkolbe> well lets see, if k is the fan-out, then adding one element incurs log_k n objects that are k each.  So given a fixed n, what is the optimal value of k?
20:40:31 * mdmkolbe tries to remember his calculus
20:40:51 <jsnx> golubovsky: well, this is very interesting
20:41:00 <bd_> mdmkolbe: remember that sorting the items within a node has a cost too ... :)
20:41:12 <mdmkolbe> bd_: computation cost but not allocation cost
20:41:17 <jsnx> i wish i could help you -- you've just helped me
20:41:50 <mdmkolbe> ok, so log_k n = ln k/ln n and ln n is a constant so we need to take the differential of "k * log k"
20:41:54 <golubovsky> jsnx: indeed, and I believe this may have some future, if Haskell may piggyback on some other language's runtime. Someone wrote Python converter, maybe  a Google app will evantually be written in Haskell ;)
20:42:32 <mdmkolbe> now iirc that should be log k + k / log k
20:42:33 <golubovsky> jsnx: if you are in any way interested feel free to write me at golubovsky at gmail dot com.
20:44:06 <mdmkolbe> setting that to zero and solving I get: (ln k)^2 = - k ... which is never satisfied :-(
20:44:25 <golubovsky> OK, looks like my question does not have simple answer ...
20:44:35 <golubovsky> Thanks anyway jsnx
20:44:36 <mdmkolbe> also note that this equation was independant of "n" so there must be one universal solution for all n
20:45:55 <golubovsky> Perhaps I have to dig into ghc-pkg sources, how it finds out about package locations.
20:45:57 <golubovsky> Bye
20:46:22 <mdmkolbe> all right from another angle compare a 2-tree to a 4-tree.  the 4-tree will be (about) half as tall so an update allocates half as many nodes, but each node requires twice as much space so it is a was (this generalizes)
20:46:38 <bd_> it's been way too long since I did calc :|
20:47:31 <mdmkolbe> conclusion: high fan-out doesn't help allocation costs in a functional language except in so far as the cost of header words are amatorized over more data and that there are fewer pointer dereferences
22:07:40 <chrisdone> dons: are you there?
22:27:28 <dolio> log_k n = ln n/ln k
22:27:33 <dolio> If k is meant to be the base.
22:29:46 <mdmkolbe> dolio: d'oh
22:30:08 <dolio> That might give you more promising results. :)
22:31:45 <dolio> "just how many times are you intending to multi-post and cross-post this message about your lame-ass conference?"
22:32:52 <mdmkolbe> I also have now realized that the program is implementing the DoubleMap completely wrongly.  What I want is a set of tuples (priority, key, value) where "key" uniquely determines the other two and for which querying what tuple has the lowest priority is fast as well as updating the priority and value of a key
22:33:03 <mdmkolbe> dolio: which conference
22:33:04 <mdmkolbe> ?
22:33:23 <dolio> "International Conference on Signal Processing and Imaging Engineering"
22:33:43 <dolio> There are actually several fairly recent announcements that all look very similar, but have different conference names.
22:34:02 <dolio> Is it possible someone is sending out fake conference announcement spam?
22:34:23 <mdmkolbe> oooh, a pretty pictures conference ;-)
22:34:50 <dolio> There's also the "International Conference on Computational Biology ICCB 2008"
22:36:05 <dolio> Oh, I see, it's like 15 smaller conferences that are part of one large conference.
22:36:43 <dolio> And someone isn't happy that comp.lang.java.programmer is getting announcements for several of the individual conferences.
22:36:45 <mdmkolbe> what lists are they posting to?
22:37:06 <dolio> comp.compression, comp.lang.functional, comp.ai.edu, comp.lang.java.programmer, comp.distributed
22:40:01 <dolio> So, you want a key -> priority map and a key -> value map?
22:40:31 <mdmkolbe> dolio: yes, except I need to also find the key with lowest priority
22:40:42 <dolio> Hmm.
22:40:49 <mdmkolbe> (lowest priority = best)
22:41:23 <dolio> But there can be multiple keys with the same priority?
22:41:29 <mdmkolbe> dolio: yes
22:42:09 <mdmkolbe> it's almost like I need a Data.Map priority [key] and Data.Map key (priority, value)
22:44:21 <dolio> And you need the keys?
22:45:51 <mdmkolbe> well, the keys are the only things that are unique
22:46:05 <mdmkolbe> so I don't understand how it would be done without the keys
22:46:49 <dolio> Well, I mean, if you could just have a priority queue for values, would that work?
22:48:27 <mdmkolbe> no, because I need to be able to update the priority and value associated with a particular key (i.e. at that time, I know the key but not the priority or value)
22:48:47 <dolio> Okay.
22:48:56 <mdmkolbe> (though, I'm sleep happy enough that I might be missing something)
23:07:08 <dublpaws> ["Value" | x <- [1..]]  -- is there a better way to make an infinite list of "Value"?
23:08:23 <stepcut> > repeat "Value"
23:08:31 <dublpaws> excellent, thanks
23:08:33 <lambdabot>  ["Value","Value","Value","Value","Value","Value","Value","Value","Value","Va...
23:18:56 <kaspyanand> hi
23:19:48 <kaspyanand> haskell supports lazy evaluation
23:20:00 <kaspyanand> how evaluation happens for this statement
23:20:02 <kaspyanand> print $ take 10 $ filter odd [1..]
23:20:17 <kaspyanand> does filter return one element at a time to take?
23:21:36 <Cale> kaspyanand: effectively.
23:21:58 <Cale> kaspyanand: Lazy evaluation just means that things are evaluated outermost-first.
23:22:00 <pjdelport> kaspyanand: one way to think of it is that print and take "pull" values out of filter
23:22:20 <Cale> So print is evaluated with (take 10 $ filter odd [1..]) as its parameter
23:22:39 <Cale> print = putStrLn . show
23:23:32 <Cale> so we have  putStrLn (show (take 10 (filter odd [1..])))
23:23:33 <Cale> putStrLn then needs to know the first character of the string to start printing
23:24:20 <Cale> (and will continue to demand them as it goes, until it reaches the end of the first line)
23:25:21 <Cale> So after the initial '[', show will need to evaluate the elements of the list to know what characters to produce
23:25:25 <newsham> print is very demanding
23:26:10 <Cale> anyway, if you can be convinced that demand propagates to take 10 (filter odd [1..]), then it's pretty easy to evaluate this step-by-step by hand
23:26:16 <Cale> @src take
23:26:16 <lambdabot> take n _      | n <= 0 =  []
23:26:16 <lambdabot> take _ []              =  []
23:26:16 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
23:26:58 <Cale> n > 0, so the first guard doesn't match, and then to finish pattern matching we need to know if  filter odd [1..] is [] or (x:xs)
23:27:04 <Cale> @src filter
23:27:04 <lambdabot> filter _ []     = []
23:27:04 <lambdabot> filter p (x:xs)
23:27:04 <lambdabot>     | p x       = x : filter p xs
23:27:04 <lambdabot>     | otherwise = filter p xs
23:27:25 <Cale> filter odd (1:[2..]) = 1 : filter odd [2..]
23:27:37 <Cale> (because the p x guard succeeds)
23:28:09 <Cale> So, take 10 (1 : filter odd [2..]) = 1 : take (10 - 1) (filter odd [2..])
23:28:26 <Cale> and then show will be able to show the 1 :)
23:28:49 <Cale> and as it keeps pattern matching, more and more of the list will get evaluated
23:29:50 <stepcut> > take 10 $ filter odd [1,2,3,undefined]
23:29:56 <lambdabot>  [1,3Exception: Prelude.undefined
23:30:44 <Cale> > take 10 $ filter odd [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,undefined]
23:30:45 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
23:31:44 <pjdelport> > filter undefined []
23:31:46 <lambdabot>  []
23:32:37 <newsham> cale: did you do icfp contest?
23:33:11 <kaspyanand> cale:thks
23:33:48 <Trinithis> Is Haskell pronounced like Has-kell or Has-cull?
23:36:57 <Cale> Trinithis: you can hear SPJ pronounce it in just about any of his talk videos
23:37:18 <jsnx> i think it's haskl
23:37:22 <Cale> newsham: Yeah, though I'm not sure we got submitted.
23:37:32 <Cale> jsnx: That's a good approximation :)
23:37:44 <Quadrescence> Trinithis: Considering its full name is Haskelleton, has 'kell seems right to me. :>
23:37:51 <Cale> Maybe stick a schwa in there :)
23:37:59 <Trinithis> ha
23:38:27 <dons> here's sometihng to think about, http://www.reddit.com/info/6si5p/comments/
23:38:27 <lambdabot> Title: reddit.com: Are you an experienced functional programmer? If so, Microsoft wants ...
23:39:15 <newsham> hmm.. no submission?  :(
23:39:45 <jsnx> interesting
23:40:31 <Cale> newsham: I should check to see if vincenz straightened things out... we had some network trouble near the deadline, and were something like 9 seconds late. :)
23:40:57 <newsham> oh wow..  bummer.
23:41:06 <dons> Cale, likely if you asked the organisers, that could be rectified.
23:41:18 <Cale> dons: vincenz said he would
23:41:42 <newsham> what approach did you guys take?
23:41:52 <Quadrescence> Prelude Data.List> sum [1..20]
23:41:52 <Quadrescence>  
23:41:52 <Quadrescence> <interactive>:1:0: Not in scope: `gum'
23:41:55 <Cale> But I'm sure that some other people's bots worked better :)
23:41:56 <Quadrescence> Weird. :>
23:42:32 <Cale> We had some geometry for steering between coordinates, plus a quadtree/A* search for the large scale stuff to generate waypoints to steer between.
23:43:05 <Cale> In the end, the two weren't integrated very well though, there were some strange problems.
23:43:13 <jsnx> Quadrescence: `gum` ?
23:43:24 <Quadrescence> jsnx: I know, I don't get it.
23:43:46 <Trinithis> anyone know what the difference between a parse tree and an AST is?
23:44:15 <jsnx> Trinithis: a parse tree is normalized to an AST?
23:44:19 <Cale> Trinithis: a parse tree reflects the structure of how the concrete syntax was parsed
23:44:56 <Trinithis> so the parse tree would contain source code elements in it?
23:45:12 <Trinithis> such as ; in a C type language?
23:45:16 <newsham> the parse tree might have strange shapes due to limitations in your parsing technology
23:45:40 <jsnx> Trinithis: the parse tree is reorganized to form the AST
23:45:43 <newsham> yah, it could have some extra punctuation marks that arent needed semantically
23:45:44 <Cale> The stuff that the parse tree has in it depends on your particular parser and concrete syntax for your language.
23:45:55 <Cale> The AST is totally independent of the concrete syntax, in a sense.
23:46:26 <jsnx> ( 1 + 2 ) + 3  is different from  1 + ( 2 + 3 )  in the parse tree
23:46:33 <Cale> It's an ideal representation of the syntax of your language that is optimised for doing structural manipulation.
23:46:33 <jsnx> but not in the AST?
23:46:39 <Trinithis> sometimes, is it easier to skip the parse tree and go straight from tokens to an AST?
23:46:42 <Cale> jsnx: possibly
23:46:52 <newsham> jsnx: those would normally be two different shaped AST's too
23:47:02 <jsnx> oh, hmmm
23:47:27 <Cale> Well, if (+) was a language primitive, and was always associative, you could choose to have that become a single node at the AST level
23:47:51 <Trinithis> jsnx: I bet multiple ASTs exist for the same code, but they would be isomorphic nonetheless
23:48:03 <Cale> Trinithis: yeah... the parse tree is more a representation of how the parser carried out its task
23:49:19 <Trinithis> one more question: are zippers trees that in which you can easily move up and down in?
23:49:33 <newsham> jsnx: have you learned about left factoring grammars, and manipulating them to enforce precedence?
23:49:47 <newsham> ie for:   Expr -> Expr + Expr | Expr * Expr | Num  ?
23:49:51 <jsnx> newsham: no, what's that?
23:50:22 <jsnx> left factoring is ensuring the largest match first?
23:50:40 <newsham> well, for example, if you're doing an LL(1) parser (ie. recursive descent) you cant have Expr -> Expr ... ;   as a production
23:50:52 <newsham> so you have to use a different grammar which parses the same language
23:51:00 <newsham> and so as you result you get a different shaped parse tree
23:51:10 <newsham> but your end goal is to get the same AST which represents your expressions
23:52:18 <jsnx> so where does the left factoring come in?
23:52:52 <newsham> like:  Expr -> Factor moreFactor;  moreFactor = nothing | * Factor;  Factor = Num moreNum; moreNum = nothing | + moreNum;
23:53:13 <newsham> (dont know if i did that right, its been a while)
23:53:32 <jsnx> and the net effect is that you can use a recursive descent parser?
23:53:41 <mdmkolbe> is it better to have a pair of maps or a map of pairs (e.g. Data.Map.Map Int (Double,Int) or (Data.Map.Map Int Double, Data.Map.Map Int))?
23:53:43 <newsham> yah.
23:54:31 <newsham> you parse with the grammar you have, not that grammar you want :)
23:55:19 <Trinithis> mdmkolbe: I prefer maps of pairs because it enforces a 1-1 correspondence
23:55:22 <scook0> mdmkolbe: it really depends on what you'll use them for
23:55:40 <scook0> a single map of pairs ensures coherency
23:55:41 <mdmkolbe> I mean from a performance and allocation cost perspective
23:56:18 <mdmkolbe> I am building an abstraction that will handle the coherency anyway, but the abstraction must be fast
23:56:50 <scook0> ah, that's much more sensible, yes
23:56:51 <mdmkolbe> e.g. a single run of the program allocates 12 GB in this data structure
23:57:49 <Trinithis> If I'm not mistaken, a map of pairs would consume less memory because you would only have 1 tree rather than 2
23:58:40 <newsham> 1 tree and lots of pairs, vs 2 trees and no pairs
23:59:07 <Trinithis> 2 trees means double lookup
23:59:38 <mdmkolbe> and size of tree is probably approximatly the same cost as all the pairs (in general tree branches equal number of leaves)
23:59:50 <Trinithis> oh.. right
