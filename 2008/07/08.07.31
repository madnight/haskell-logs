00:00:07 <mjrosenb> what does ^C do in vim?
00:02:54 <glguy> mjrosenb: try:     :help ^C
00:04:20 <pejo> mjrosenb, I had to try it - apparently the same thing as ESC.
00:05:30 <_zenon_> saves you hand-moving distance
00:05:59 <dons> glguy: pong?
00:06:06 <mjrosenb> _zenon_: ^[
00:06:07 <glguy> hi
00:06:14 <dons> ho.
00:06:27 <dons> off to work we go?
00:07:22 <glguy> dons: are all of the uvector operations on MUArrays intended to be manual via read and writeMU?
00:07:50 <dons> i plan to have some nice imperative loops for them, but currently there's only read and write.
00:08:12 * dolio coughs.
00:08:18 <glguy> I think I'm just using the library against the grain since I need efficient MUArrays and not UArrays
00:08:18 <dons> dolio also.
00:08:32 <humasect> are multiple let statements impossible ?
00:08:33 <dolio> :)
00:08:37 <dons> so you can use it as an efficient array type, might beat STUArray for some things.
00:08:45 <dons> and it has the same interface :)
00:08:52 <dolio> It beats STUArray in my experience.
00:08:54 <dons> so there is an intent to allow access to the mutable stuff
00:09:00 <dons> but the goal is to use pure arrays
00:09:15 <dons> dolio: hmm. its a little simpler type, and its way more aggressive, so plausible
00:09:21 <Saizan> humasect: you can define multiple bindings in a single let expression, and you can nest them
00:09:23 <dolio> Yeah.
00:09:37 <chylli> where can I find a tutorial about keyword 'forall'
00:09:45 <dons> chylli: the ghc user's guide.
00:09:54 <chylli> dons: thanks
00:09:57 <glguy> dons: http://hpaste.org/9283
00:10:01 <dolio> Search for rank-2/n polymorphism.
00:10:03 <dons> chylli: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification
00:10:05 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
00:10:27 <humasect> Saizan: hm, i end up often using where statement for this very purpose. it needs do syntax at the least ?
00:10:58 <dons> glguy: ok. interesting.
00:11:10 <Saizan> humasect: no, but you've to indent each binding at the same level, and use 'in' at the end of them all
00:11:22 <glguy> going to be putting that into a backtracking monad
00:11:29 <dons> pretty wild stuff :)
00:11:30 <glguy> for efficient union find operations
00:11:36 <dons> yeah, that sounds really cool.
00:11:43 <dons> you know who'll be impressed? yav.
00:11:59 <humasect> Saizan: hm ok thanks, i continue efforts=)
00:12:10 <dons> is performance working out?
00:12:17 <dons> i guess so , looking at that code.
00:12:25 <glguy> dons: I have no idea ;)
00:12:32 <glguy> I haven't used it beyond the "test" value
00:12:35 <glguy> just did it
00:12:47 <dons> there's not much to go wrong, representation-wise.
00:13:16 <dons> ok. bed time for sleep programmers. night.
00:13:20 <glguy> good night
00:13:30 <Saizan> humasect: like "let\n  x = foo\n  y = bar\nin <expression>"
00:15:43 <humasect> Saizan: ahh, to have let on its own line .. multiple lines seem to work sometimes too. it explains why 'in' is required for when there is no do-expression ... i think
00:18:09 <Saizan> humasect: you don't need it on its own line, but the bindings must be all at the same level, are you mixing tabs and spaces perhaps?
00:20:07 <humasect> all tabs -- so far when mixing sometimes using do syntax and sometimes not, it seems almost always the case that 'in' is needed for non-do and seems to confuse things when using it in do-syntax. it is a familiarising of nuances
00:20:20 <humasect> (until it collectively makes sense 'why')
00:20:40 <Saizan> yes, 'in' is required outside of do-syntax
00:20:59 <humasect> ok =) it makes sense.
00:21:31 <Twey> How does printf decide when to do IO and when to return a string?
00:21:55 <chrisdone> :t printf
00:21:57 <lambdabot> forall r. (PrintfType r) => String -> r
00:22:00 <Saizan> Twey: from the type you ask it to be
00:22:11 <chrisdone> @src PrintfType
00:22:11 <lambdabot> Source not found. You speak an infinite deal of nothing
00:22:15 <chrisdone> lame
00:22:16 <Twey> Oh, thanks
00:27:03 <bos> @seen dons
00:27:03 <lambdabot> dons is in #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 13m 47s ago.
00:43:49 <BeelsebobWork> anyone know if there's a lazy version of http://hackage.haskell.org/packages/archive/bytestring-lexing/0.1.2/doc/html/Data-ByteString-Lex-Double.html
00:43:51 <lambdabot> Title: Data.ByteString.Lex.Double, http://tinyurl.com/6qmka6
00:46:11 * BeelsebobWork ponders if dons is about
00:47:58 <telexicon> anyone know of a good article discussing prime factorization of large numbers?
00:50:58 <pjdelport>  http://en.wikipedia.org/wiki/Integer_factorization ?
00:50:58 <lambdabot> Title: Integer factorization - Wikipedia, the free encyclopedia
00:52:16 <mjrosenb> telexicon: wikipedia even has pages on dixon's methods, and the quadratic sieve.
00:52:32 <telexicon> interesting, ok
00:52:45 <telexicon> ill read that then
00:53:17 <mjrosenb> is there any way that i can have ghci tag every constructor that's brought into existence?
00:53:53 <mjrosenb> i basically want to see where the result of a function is actually being created
00:55:13 <BeelsebobWork> where?  as in where in memory?
00:55:23 <mjrosenb> where in my code
00:55:32 <mjrosenb> assuming that it's created in my code
00:56:33 <BeelsebobWork> oh, I see -- are you using something very close to Haskell 98 + adendums?
00:57:33 <mjrosenb> i'm currently using ghc-6.8.3 with all of the default options
00:57:51 <mjrosenb> i don't really care about this for much other than debugging purposes
00:58:09 <BeelsebobWork> okay, then you may want to try Hat
00:58:27 <BeelsebobWork> but you do need very close to H98 to get hat's program transformation to work
00:58:41 <mjrosenb> you have a link for Hat?
00:58:53 <BeelsebobWork> http://www.haskell.org/hat
00:58:54 <lambdabot> Title: Hat - the Haskell Tracer
01:00:48 <mjrosenb> this looks rather sexy
01:02:02 <mjrosenb> strange, i was single stepping
01:02:10 <mjrosenb> and now ghci seems to be hung
01:02:20 <mjrosenb> it's cpu usage is 0 though
01:02:26 <BeelsebobWork> it's not so sexy -- in that it's not the most stable piece of software -- but it is on the other hand rather shinily useful when it works
01:03:51 <shepheb> mjrosenb: is this inside haskell-mode's ghci buffer? the release version dies if you try to reload while it's debugging.
01:04:37 <mjrosenb> shepheb: nope, ghci run from bash in an xterm
01:19:19 <hackage> Uploaded to hackage: Pugs 6.2.13.11
01:27:01 <O_4> Hmm, what does "They should return one sheep selected from all sheep matching the description" mean in Ex. 2 on http://www.haskell.org/all_about_monads/html/exercises.html
01:27:01 <lambdabot> Title: Exercises
01:28:34 <mjrosenb> O_4: the descriptions are parent and grandparent
01:29:10 <mjrosenb> i think
01:29:49 <O_4> It doesn't make sense.
01:29:54 <O_4> What is 'all sheep'?
01:30:00 <O_4> There is no global list of sheep.
01:30:43 <O_4> And a sheep hardly qualifies as a description...  If anything, I should just return that sheep
01:30:59 <O_4> I could look at the solution I suppose, but then writing it would be too easy :-p
01:31:05 <mjrosenb> a sheep should'nt be it's own parent
01:31:14 <mjrosenb> nor it's own grandparent
01:31:30 <mjrosenb> no matter what the they might be giants' song says
01:31:42 <Saizan> O_4: have you seen Example 2?
01:31:55 <O_4> Oh, I see.
01:32:17 <O_4> Saizan: yeah
01:33:59 <Saizan> O_4: so, e.g. a sheep can have both a mother and a father, but parent must return only one of those
01:34:25 <O_4> So just return the first which is available.
01:34:29 <mjrosenb> hrmm, hat is not in portage?
01:34:38 <mjrosenb> O_4: or the second one :-p
01:35:52 <mjrosenb> O_4: that was mostly meant to point out that there is no well defined ordering to the computation-
01:35:58 <mjrosenb> s/-/s/
01:36:01 <O_4> Yeah
01:36:22 <O_4> I'll just check mother first :-)
01:36:29 <Saizan> pay attention to the hint
01:38:27 <O_4> I guess I can't assume mplus x y = x when both x and y are not Nothing
01:38:36 <O_4> Is that what you were referring to?
01:38:45 <mjrosenb> O_4: perhaps
01:39:04 <Saizan> Nothing == Nothing no matter where they came from
01:39:21 <mjrosenb> Saizan: not nothing
01:39:33 <Saizan> ah
01:39:45 <Saizan> then yes, you can assume that for Maybe
01:41:53 <mjrosenb> Saizan: is that part of the spec?
01:42:34 <BeelsebobWork> anyone know of a way of reading a float out of a lazy bytestring?
01:45:56 <BeelsebobWork> there must be something more efficient than just read . CBS.unpack
01:47:27 <_zenon_> have you checked hoogle?
01:47:34 <_zenon_> search by signature
01:48:11 <rwbarton> @hackage bytestring-lexing
01:48:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-lexing
01:48:25 <rwbarton> (or is Float /= Double for this purpose?)
01:48:49 <BeelsebobWork> rwbarton: that's strict bytstrings only
01:49:22 <rwbarton> oh, sorry, I missed that part of the question
01:51:23 <Saizan> BeelsebobWork: write a parser in the Get monad?
01:51:51 <BeelsebobWork> that could work... not entirely sure it'd be very efficient, but I'll give it a go
01:52:25 <rwbarton> you probably can't get both super-fast performance and optimal laziness
01:55:45 <BeelsebobWork> I don't really want optimal laziness -- I just have to use lazy bytestrings, because Binary only provides interfaces to get lazy bytestrings
01:59:35 <Saizan> BeelsebobWork: you don't know the length of the representation, right? you could use getBytes in that case
01:59:42 <rwbarton> a somewhat ugly suggestion is to start with (BS.concat . BSL.toChunks . BSL.take 32)
01:59:44 <BeelsebobWork> fraid not, no
02:00:05 <BeelsebobWork> rwbarton: no reason to have the BSL.take -- it's already a really short string containing only the float
02:00:15 <BeelsebobWork> so that may work
02:00:17 * BeelsebobWork tries it
02:00:21 <rwbarton> oh, in that case toChunks may help you
02:00:33 <rwbarton> (it's probably already one chunk I guess)
02:01:13 <mjrosenb> oh god, the interaction of the debugger with monads is strange
02:01:37 <mjrosenb> or at least with monads that are using do-notation
02:01:45 <mjrosenb> and dealing with lambdas internally
02:01:54 <BeelsebobWork> mjrosenb: is that hat interacting with monads?
02:02:01 <zachk> im pretty sure do notation is just sugar coated syntax
02:02:03 <mjrosenb> BeelsebobWork: not using hat
02:02:11 <BeelsebobWork> zachk: it is
02:02:12 <mjrosenb> zachk: it is
02:02:17 <mjrosenb> efb
02:02:31 <BeelsebobWork> do x; y == x >> y, do a <- x; y == x >>= \a -> y
02:03:21 <mjrosenb> BeelsebobWork: there's also special syntax for let
02:03:27 <BeelsebobWork> yeh
02:04:41 <forkbomb> whats the next step after ./darcs-all get? im using http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources
02:04:43 <lambdabot> Title: Building/GettingTheSources - GHC - Trac, http://tinyurl.com/y3nvjj
02:07:57 <dolio> @tell dons ghc-core seems to be broken on 6.8.3. Language.Haskell.HsColour.hscolour changed type, maybe?
02:07:57 <lambdabot> Consider it noted.
02:08:39 <BeelsebobWork> hmm, no, converting to a strict bytestring is slower than read . BS.unpack
02:11:12 <mjrosenb> gah, hmake requires ghc
02:11:13 <dolio> You could just ask dons to add a lazy bytestring parser to the lexing package.
02:11:17 <mjrosenb> -6.6?
02:11:20 <BeelsebobWork> mjrosenb: no
02:11:26 <dolio> Assuming alex works on lazy byte strings.
02:11:35 <mjrosenb> portage seems to think so :(
02:11:38 <BeelsebobWork> hmake works fine with ghc-6.8.3... or nhc or yhc for that matter
02:11:45 <BeelsebobWork> mjrosenb: portage is wrong -- download the source
02:11:49 <mjrosenb> i'll have to poke someone about that
02:11:53 <BeelsebobWork> mjrosenb: I'm using hmake with 6.8.3
02:12:17 <mjrosenb> BeelsebobWork: i *really* don't like having executables installed on my system that a package manager doesn't know about
02:12:26 <dolio> Since it copies to a new strict bytestring anyway for the call out to C, it shouldn't be that much worse.
02:15:33 <Baughn> mjrosenb: But that's what /usr/local is /for/
02:16:07 <forkbomb> “Today’s lecture will be about Lazy Evaluation”, he paused for a moment then concluded with, “Are there any questions?”
02:16:34 <mjrosenb> Baughn: true.  i've still shot myself in the foot by removing something that belonged to a package other than what i thought it was for.
02:16:39 <Baughn> @remember forkbomb “Today’s lecture will be about Lazy Evaluation”, he paused for a moment then concluded with, “Are there any questions?”
02:16:40 <lambdabot> I will never forget.
02:16:43 <mjrosenb> Baughn: i usually litter it with scripts
02:16:44 <dolio> Then someone asked one and he said "Stack overflow!"
02:16:55 <mjrosenb> Baughn: and ebuilds that i am testing
02:17:19 <mjrosenb> dolio: someone asked him how long the lecture was going to be
02:17:19 <Saizan> @quote Today
02:17:19 <lambdabot> roconnor says: life lesson from today: 1 closure is nice, 500 000 closures sucks
02:17:36 <Baughn> mjrosenb: To aid in that, my normal method to remove something from /usr/local/ is to rm-rf /usr/local and run regen-usr-local.sh
02:18:05 <Baughn> Of course, /opt/local is also handy
02:18:16 <mjrosenb> Baughn: i'd most likely forget and put regen-usr-local.sh in /usr/local
02:20:38 <ketil> HPC: yay!
02:21:32 <Baughn> @quote lazy
02:21:32 <lambdabot> forkbomb says: “Today’s lecture will be about Lazy Evaluation”, he paused for a moment then concluded with, “Are there any questions?”
02:21:36 <Baughn> @quote lazy
02:21:37 <lambdabot> PaulGraham says: An algorithm for lazy evaluation of research papers: Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers
02:21:37 <lambdabot> you should have cited.
02:21:40 <ketil> http://malde.org/~ketil/biohaskell/biolib/hpc_index.html
02:21:43 <ketil> Whee!
02:22:20 <zachk> larry wall says in the perl bible that being lazy is a virtue
02:23:27 <telexicon> i think im doing something wrong v_v
02:23:35 <telexicon> factoring this 12 digit number takes 7 seconds
02:23:47 <Baughn> ..yep, most likely.
02:23:57 <vixey> telexicon: How do you factor it?
02:23:58 <zachk> you need a prime generator
02:24:12 <telexicon> i wrote a sieve of eratosthenes
02:24:32 <telexicon> that parts fast
02:25:44 <telexicon> well.. i dont know
02:25:48 <telexicon> how fast is it supposed to be?
02:25:53 <Baughn> Instant
02:25:56 <telexicon> it can generate all the primes up to 1 million in 2 seconds
02:26:13 <Baughn> telexicon: Well, the factoring code should be small. Could you just hpaste it?
02:26:31 <pejo> (Considering yesterdays discussions) Does anyone know the current state of GHC head?
02:27:59 <telexicon> is it going to announce? >.>
02:28:08 <telexicon> Baughn, http://hpaste.org/9284
02:30:37 <trinisoftinc> anyone home
02:30:41 <Baughn> telexicon: Hang on. primes ns evaluates to a list of primes, right?
02:30:49 <telexicon> Baughn, right
02:30:54 <Baughn> telexicon: Then why do you pass those to isPrime?
02:31:19 <Baughn> A function that is, I might add, quite slow
02:31:20 <telexicon> i think thats redundant from before
02:31:49 <telexicon> i just rewrote the sieve and made it a lot faster
02:32:02 <telexicon> i was using a different algorithm before, i guess i forgot about it
02:32:13 <telexicon> ok, that brings it down to 1.4s
02:32:40 <Baughn> What does it return, by the way?
02:32:51 <telexicon> primeFactorize?
02:32:54 <telexicon> a list of all factors
02:32:58 <telexicon> er prime factors
02:33:13 <Baughn> Yes, but I mean, /which/ factors does it think 600851475143 has?
02:33:22 <telexicon> [71,839,1471,6857]
02:33:23 <dolio> Your algorithm checks for divisibility by all primes from 2 to n.
02:33:45 <dolio> Or, is it 2 to sqrt n?
02:33:52 <Baughn> telexicon: And what's the highest m it triest to divide it by?
02:34:08 <zachk> that can give you almost all the factors maybe all
02:34:17 <dolio> Anyhow, dividing out right away may be a good idea.
02:34:19 <telexicon> dolio, square root
02:34:37 <Baughn> > sqrt 600851475143
02:34:41 <lambdabot>  775146.0992245268
02:34:59 <Baughn> Well, if nothing else, that'd be about a hundred times more primes to check against than is actually needed
02:36:05 <telexicon> ok, ill read the algorithm again..
02:36:25 <dolio> Also, the list won't include p for, say, 2*p for large prime p, will it?
02:36:49 <Baughn> Nope. It's a list of factors, but only one of each
02:39:23 <dolio> I'm relatively sure I've found trial division to be faster than the filter-out-modulo method of generating prime lists, too.
02:39:28 <telexicon> Baughn, why is that 100 times more?
02:39:51 <dolio> But I haven't done it recently.
02:39:59 <Baughn> telexicon: Your factorizing function doesn't bail out after finding the last factor
02:40:10 <telexicon> oh
02:40:25 <telexicon> how does it know thats the last factor?
02:40:29 <Baughn> telexicon: Probably you should also divide the number, and keep that around for the next test
02:40:46 <Baughn> telexicon: You'll want to use iterate, I guess
02:41:23 <telexicon> dolio, im using the sieve to generate primes
02:41:45 <dolio> Yeah, for instance, your function will test a lot more primes than necessary for 2^1000, for instance.
02:42:05 <dolio> Which may be slower than dividing by 2 1000 times.
02:42:26 <MikeHub> hey guys a little problem from a newbie
02:42:28 <MikeHub> http://hpaste.org/9285
02:42:59 <vixey> weird spelling
02:43:03 <Baughn> telexicon: Oh, and not iterate, of course. Hm..
02:43:07 <Baughn> foldl?
02:43:08 <Baughn> :t foldl
02:43:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:43:10 <humasect> vixey: canadian/british
02:43:13 * Baughn nods. foldl.
02:43:20 <MikeHub> i need to add together multipul wins for marbels of a certain colour
02:43:23 * Baughn backpedals. foldr.
02:43:26 <telexicon> that doesnt make sense
02:43:33 <Baughn> ..foldl'?
02:43:48 <telexicon> they may be in pairs
02:44:05 <telexicon> but that doesnt mean the number i get from dividing by the first successful prime, is going to contain the rest of the factors
02:44:12 <__pao__> I'm looking at Ord class definition
02:44:22 <Baughn> telexicon: Er, yes. Yes, it does.
02:44:26 <humasect> MikeHub: so, how are you going to do it?=)
02:44:33 <Baughn> telexicon: That's more or less the definition of factorizing a number.
02:44:43 <telexicon> but i only have the prime factors
02:44:43 <__pao__> I wonder where the default ordering based on data definition is implemented
02:44:49 <Baughn> 600851475143 = 71 * 839 * 1471 * 6857
02:44:59 <__pao__> *based on data definition order
02:45:03 <Baughn> Divide by 71, and the result is still divisible by 839, 1471 and 6857
02:45:46 <MikeHub> well i was going to recursively call it but but im not sure how to keep the total and the marbels i havnt search through
02:45:49 <Saizan> __pao__: the one you get by deriving Ord ? it's specified by the haskell98 report, and implemented by compiler magic
02:46:08 <__pao__> Saizan: thanks ;-)
02:46:11 <Baughn> > foldl (/) 600851475143 [71,839,1471,6857]
02:46:12 <lambdabot>  1.0
02:46:23 <telexicon> Baughn, how did they manage that relationship
02:46:25 <zachk> mikehub: http://hpaste.org/9285#a2
02:46:26 <humasect> MikeHub: so, where will you start to find out how to keep the total?
02:46:39 <Baughn> telexicon: Now you just have to replace (/) with a function that does nothing if it doesn't divide cleanly
02:47:12 <telexicon> oh i see
02:47:19 <telexicon> duh.. these are primes
02:47:22 <Baughn> telexicon: This being math, they didn't; it couldn't possibly be any other way
02:47:27 <telexicon> all the other factors are built off of these
02:47:28 <Baughn> And, yes. They're primes. ^^;
02:47:41 <MikeHub> well id search using find
02:47:44 <zachk> primes 0wn m3 2
02:47:55 <humasect> MikeHub: how will you keep state?
02:47:57 <telexicon> everything has been sneaky past me lately
02:48:00 <MikeHub> get the first entry take the wins plus it to a total
02:48:02 <telexicon> its rather frustrating
02:48:06 <Baughn> :t scanl
02:48:07 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
02:48:24 <MikeHub> im not sure to be honest
02:48:40 <humasect> MikeHub: hm, so first thing to do, is how to become sure=)
02:48:42 <zachk> mikehub: pass state around inside a data structure, recursively passing it as an argument to your main function and other functions that modify state
02:49:33 <MikeHub> ok so pass the list of marbels and a total within a tuple?
02:49:43 <zachk> MARBLES
02:49:46 * zachk apologizes
02:49:51 <MikeHub> deleting a marbel as i go
02:49:55 <MikeHub> lol
02:50:01 <telexicon> Baughn, well that makes sense now, thanks
02:50:20 <Baughn> > foldl' (\(n,l) d -> if n `mod` d == 0 then (n `div` d,d:l) else (n,l)) 600851475143 [1..8000]
02:50:20 <vixey> @W80 marbel
02:50:20 <lambdabot>   add an instance declaration for (Num (b, [b]))
02:50:21 <lambdabot> Unknown command, try @list
02:51:42 <Baughn> > foldl' (\(n,l) d -> if n `mod` d == 0 then (n `div` d,d:l) else (n,l)) (600851475143,[]) [1..8000]
02:51:43 <lambdabot>  (1,[6857,1471,839,71,1])
02:52:06 <Baughn> telexicon: You could improve on that, but there's not even any particular need for generating primes other than efficiency
03:00:49 <chylli> data Unpacker = forall a . Eq a => AnyUnpacker (LispVal -> ThrowsError a)
03:01:04 <chylli> when compile : parser.hs:303:16: Not a constructor: `forall'
03:01:27 <dolio> Do you have ExistentialTypes enabled?
03:01:28 <chylli> what's the problem ?
03:01:39 <chylli> dolio: i think not, but how ?
03:01:51 <dolio> {-# LANGUAGE ExistentialTypes #-}
03:01:56 <chylli> thanks
03:02:14 <chylli> at the first of line of program ?
03:02:21 <dolio> Yeah.
03:02:39 <vixey> chylli: What are you programming?
03:02:56 <chylli> ghc --make parser.hs
03:02:56 <chylli> parser.hs:1:13: unsupported extension: ExistentialTypes
03:03:14 <vixey> RankNTypes
03:03:15 <chylli> vixey: write scheme in 48 hours
03:03:38 <vixey> hmmm :/
03:03:44 <vixey> maybe I should rewrite that tutorial
03:03:47 <vixey> it sucks
03:04:08 <telexicon> Baughn, but see that doesnt work
03:04:26 <chylli> vixey: are you author of that ?
03:04:29 <telexicon> Baughn, it returns things like 25 and 4
03:04:36 <vixey> chylli: no
03:04:53 <mjrosenb> 25 or 6 to 4?
03:05:06 <chylli> dolio: what to do then, now ?
03:05:06 <telexicon> 25
03:05:44 <dolio> chylli: Run 'ghc --supported-languages' and look for something similar. :)
03:06:22 <dolio> It's ExistentialQuantification, my bad.
03:06:41 <chylli> ExistentialQuantification
03:06:44 <chylli> dolio: thanks
03:07:35 <chylli> dolio: still complain: parser.hs:304:16: Not a constructor: `forall'
03:07:36 <chylli>  
03:07:45 <vixey> RankNTypes
03:07:56 <chylli> vixey: saying to me ?
03:08:29 <vixey> :t divMod
03:08:32 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
03:08:36 <vixey> :t quotRem
03:08:37 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
03:09:11 <vixey> @src div
03:09:12 <lambdabot> Source not found.
03:09:18 <dolio> That declaration works here with ExistentialQuantification.
03:09:35 <chylli> I use ghc --make parser.hs
03:09:37 <chylli> is it right ?
03:10:21 <chylli> dolio: {-# ExistentialQuantification #-}
03:11:02 <dolio> {-# LANGUAGE ExistentialQuantification #-}
03:11:51 <humasect> @source Integral Int
03:11:51 <lambdabot> Integral Int not available
03:12:06 <chylli> dolio: thanks
03:12:16 <dolio> Does it work now?
03:13:39 <chylli> dolio: work now
03:13:45 <vixey> @src divMod
03:13:46 <dolio> Okay.
03:13:46 <lambdabot> Source not found. :(
03:14:40 <pozic> The charts library can display one chart in one GTK window. I would like to display more than one chart in a window with automatic scrollbars if needed. Is something like that possible?
03:14:52 <vixey> factorize 1 _ = []
03:14:53 <vixey> factorize n (p:ps) = case n `divMod` p of
03:14:53 <vixey>                        (remainder,0) -> p : factorize (n `div` p) (p:ps)
03:14:53 <vixey>                        _             -> factorize n ps
03:14:58 <Toxaris> the syntax is @src <instance type> <method name>
03:14:59 <vixey> can that be improved much ?
03:15:03 <Toxaris> @src [] mplus
03:15:03 <lambdabot> mplus = (++)
03:15:13 <vixey> oops
03:15:21 <vixey> (n `div` p) should be remainder
03:18:11 <Toxaris> vixey: maybe pps@(p:ps) and then factorize remainder pps
03:18:36 <vixey> nice, ty
03:18:50 <vixey> factorize n pps@(p:ps) = case n `divMod` p of
03:18:51 <vixey>   (0,1)         -> []
03:18:51 <vixey>   (remainder,0) -> p : factorize remainder pps
03:18:51 <vixey>   _             -> factorize n ps
03:19:03 <dieJana> what (lambda-like-) calculus models parallel computation?
03:19:24 <Saizan> pi-
03:19:50 <dieJana> pi- and derivatives of it only?
03:20:33 <dieJana> and the logic behind pi- is first order?
03:20:37 <pejo> dieJana, check CCS/CSP too. They're more limited, but might be sufficient for whatever you have in mind.
03:21:04 <dieJana> aye, I forgot about CCS, pejo, thanks
03:21:49 <Spark> an actual use for a process calculus?
03:21:49 <chylli> :t catchError
03:21:50 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
03:22:20 <dieJana> Spark: asking me?
03:22:32 <Spark> i'm just trolling really
03:22:50 <dieJana> I'm not against brainstorming, on the contrary
03:23:21 <Spark> do you actually want to model parallel computation
03:23:37 <Spark> or do just you want pre-emptive interleaving
03:24:12 <pejo> Spark, check "The semantic layers of Timber" for one use.
03:24:31 <dieJana> well, what I want is to reflect the parallel computations in the proofs
03:24:51 <Spark> most concurrent calculi don't have any notion of two things happening at the same time
03:25:08 <dieJana> pejo, any clean intro into CCS available online that you recommend?
03:25:12 <Spark> they just express the interleavings as nondeterminism
03:25:25 <chylli> I find an error in "scheme in 48"
03:25:34 <Spark> what is the proof?
03:25:47 <vixey> chylli: yeah
03:25:47 <Spark> you have some kind of parallel algorithm?
03:25:59 <Spark> or is it algorithm that operates on parallel programs or something
03:26:05 <dieJana> well, I have a proof, and an associated algorithm
03:26:07 <vixey> chylli: would a tutorial on how to write an interpreter for a mini haskell be better?
03:26:11 <pejo> dieJana, the best on intro Pi calculus that I've seen is the book by Sangiorgi and Walker. For CCS I'm only aware of Milner's book, but I haven't read that one.
03:26:11 <vixey> i.e. a typed lazy language
03:26:24 <chylli> vixey: thats FINE
03:26:26 <dieJana> the algorithm as such is not optimal, so I want to alter the proof to get a sort of parallel algorithm
03:26:38 <vixey> chylli: why are you shouting
03:26:52 <dieJana> I've seen Sangiorgi talking...
03:26:54 <chylli> vixey: but I think I has find one before.
03:27:02 <Spark> so you want to parallelise the algorithm and extend the proof to make sure it's still sound?
03:27:17 <Spark> what thread model does the parallel algorithm use?
03:27:19 <chylli> vixey: excited by you
03:27:27 <vixey> chylli, oh
03:27:32 <vixey> chylli, do you think I should write it?
03:27:48 <dieJana> Spark, I don't have the parallel algorithm, I want to get it :)
03:27:49 <vixey> (I don't think such a thing exists already)
03:27:51 <chylli> vixey: I want to be your first reader :p
03:28:05 <Spark> dieJana: you don't need the pi calculus for that then :)
03:28:13 <chylli> vixey: maybe I can translate to chinese
03:28:17 <dieJana> what do I need the, Spark?
03:28:26 <Spark> just figure out the dependencies and split the work up into threads
03:28:27 <dieJana> then*
03:28:29 <pejo> Spark, for your earlier comment, do you mean that they lack an evaluation rule P | Q -> P' | Q' if P -> P' and Q -> Q'?
03:28:58 <Spark> pejo: pretty much, and extending pi with that is non-trivial unless you get rid of the actions
03:29:00 <dieJana> how do you model threads in lambda calculus, Spark?
03:29:30 <pejo> Spark, "the actions"?
03:29:46 <Spark> tau, etc
03:30:08 <Spark> dieJana: why do you want to do that?  it sounds like first you need to write an algorithm
03:30:49 <Spark> you can write the algorithm in haskell or java or whatever you feel like, then work out what formal tools you need when you're done
03:31:16 <dieJana> it needs to be in a functional programming language
03:32:23 <pejo> Spark, what is it that breaks down more exactly?
03:32:41 <bluestorm> hi
03:32:43 <vixey> dieJana: Not sure if it's actually been released yet but I think the YNot project are doing some concurrency
03:33:18 <bluestorm> when creating a program, i came to a structure wich i first thought may be a monad, but it seems it itsn't, do you Haskellers have a name for it ?
03:33:46 <Spark> pejo: what if P -> P' and Q -> Q' do α and β respectively, then you'd need something like  P | Q -> P' | Q' doing αβ
03:33:52 <bluestorm> it's based on a functor  m, along with a   nothing : a -> m a   and   sum : m a -> m a -> m a
03:33:58 <bluestorm> i suppose it's something of a monoid
03:34:19 <Spark> but then how does αβ work, is it the same as βα?
03:34:20 <pejo> Spark, sorry, only iso-8859-1 here.
03:34:24 <bluestorm> hm
03:34:28 <Spark> alpha beta
03:34:40 <Spark> pejo: it doesn't necessarily break down but i think it gets unpleasant
03:34:50 <bluestorm> actually nothing is   m a
03:34:57 <Spark> and it's unnecessary since pre-emptive interleaving usually suffices to model parallelism
03:35:07 <Saizan> bluestorm: so it's a monoid.
03:35:18 <bluestorm> yes
03:35:23 <bluestorm> sorry for the noise :-'
03:36:12 <chylli> vixey: will you write that one tutorial ?
03:36:15 <bluestorm> ah
03:36:18 <bluestorm> and m is not a functor
03:36:23 <bluestorm> so i was quite wrong :D
03:36:28 <Cale> bluestorm: er, oh :)
03:36:39 <vixey> chylli: I may, If I do I will tell you
03:36:49 <Cale> bluestorm: I suppose there's not likely a decent name for that already.
03:36:58 <bluestorm> hm
03:36:59 <Saizan> Spark: the parallel evaluation is an implementation detail of the interpreter, no? not that CCS is particulary interesting to run
03:37:00 <chylli> vixey: thanks
03:38:03 <bluestorm> Cale: i think it a monoid, even when m is not a functor
03:38:06 <chylli> vixey: if you do I hope I can translate it to Chinese.
03:38:41 <vixey> chylli: that would be fantastic
03:38:41 <bluestorm> for example  m a = (a -> a)  gives a natural monoid structure (my structure is actually an enchancement of that, wich a simili writer monad)
03:39:29 <Spark> Saizan: when you model a subset of real behaviours, you can always say the rest are implementation details
03:40:00 <Spark> Saizan: i think what you mean to say is that there's no reason to model parallel execution over interleaved execution because the end result is the same, it's just faster
03:40:13 <Deewiant> does someone here know if there's anything like const :: a -> b -> a in the C++ standard library?
03:40:15 <Cale> bluestorm: If m is a functor, then it's a monoid object in the category of endofunctors on Hask, with pairing as the monoidal category operation rather than composition.
03:40:26 <Cale> (with composition, that would be a monad)
03:41:34 <qebab> I think my head just tried to explode.
03:41:36 <dieJana> I wonder if I'll ever get to know what a monad is
03:42:20 <Cale> dieJana: Have you read my "Monads as Computation" and "Monads as Containers"?
03:42:41 <Spark> Deewiant: you want a function that returns its first argument and discards its second? or you just want a function with that type
03:42:49 <Cale> They attempt to explain it in the specific case of Haskell programming :)
03:42:56 <qebab> dieJana: monads are not that bad, but when these guys starting talking about 'monoid objects in the category of endofunctors or Hask' I get a bit confused
03:42:58 <Saizan> Spark: i was starting from the pov of the model and stating that there's nothing that prevents you from executing the transitions in parallel
03:43:13 <dieJana> Cale, pls give me the link again
03:43:24 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
03:43:27 <lambdabot> Title: Monads as computation - HaskellWiki
03:43:31 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
03:43:34 <lambdabot> Title: Monads as containers - HaskellWiki
03:43:38 <Deewiant> Spark: the former.
03:43:46 <pozic> Anyone familiar with Cairo, GTK2hs and Charts and who understands how they fit together?
03:43:47 <dieJana> thanks alot, Cale!
03:43:50 <Cale> no problem
03:43:57 <Cale> Let me know if you have questions :)
03:43:58 <Deewiant> Spark: or something equivalent. It's easy to write, I'm just wondering if there's something in the STL.
03:44:07 <dieJana> I will ;)
03:44:11 <dieJana> need to go now
03:45:12 <Spark> Deewiant: i doubt it but there might be, ask in ##c++ but say stdlib instead of STL or you will be faced with snobbery
03:45:16 <bluestorm> Cale:
03:45:30 <Deewiant> Spark: :-)
03:45:36 <bluestorm> actually, what you call "monoidal category operation", in this context, is functor composition, isn't it ?
03:46:42 <Cale> bluestorm: usually, but I didn't want it to be that. However, I think I made a mistake -- if pairing is the operation, then the identity becomes a different, more trivial functor.
03:47:06 <Cale> So the natural transformation isn't  a -> m a, but () -> m a instead.
03:47:17 <Cale> (the unit)
03:47:18 <lilachaze> Deewiant: if you're using libstdc++, there's select1st
03:47:27 <bluestorm> i actually have a  nothing :: m a , so that would make sense
03:47:27 <Cale> So yeah, that doesn't quite work.
03:47:34 <bluestorm> (my version  a -> m a  version was wrong)
03:47:34 <lilachaze> Deewiant: if you're using boost lambda library, there's _1
03:47:40 <Cale> ah, okay
03:48:36 <bluestorm> by pairing you mean   a b -> (a, b) ?
03:48:45 <Cale> roughly, yeah
03:49:16 <paolino> @ty \x ->(`Data.Map.unionWith (+)` x)
03:49:17 <Cale> F (x) G  would be the functor which sends a type t to (F t, G t)
03:49:18 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
03:49:31 <bluestorm> haha
03:49:41 <bluestorm> i see :   sum :: (m o m) -> m  is a join operation for a monad
03:50:00 <bluestorm> that's definitely cool :-'
03:50:12 <Deewiant> lilachaze: select1st looks like an extension
03:50:38 <Cale> So you have what isn't quite a monad, but is a monoid object on the same base category, but with different monoidal category structure :)
03:50:39 <lilachaze> Deewiant: yes, libstdc++, but not ISO C++.
03:51:17 <lilachaze> Deewiant: also, it's (a,b) -> a, not a -> b -> a.
03:51:36 <lilachaze> (if you see what i mean)
03:51:46 <paolino> mmhh, is it a syntax error `f x` ?
03:51:49 <Cale> Category theory: describing simple things with fancy words since 1942.
03:52:23 <Cale> ;)
03:52:46 <paolino> only a token is allowed inside `` ?
03:52:54 <lilachaze> paolino: sadly, i think the answer is yes.
03:53:05 <paolino> shame
03:53:17 <lilachaze> > [1,2,3] `zipWith (+)` [4,5,6]
03:53:17 <lambdabot>  Parse error at "(+)`" (column 18)
03:53:50 <ivanm> is there a 3D plotting library for haskell?
03:53:57 <ivanm> by the looks of things chart can't do 3D yet :s
03:54:13 <bluestorm> hm
03:54:38 <bluestorm> i think i know what i thought it would be a monad
03:54:52 <lilachaze> paolino: one possible justification is, how do you parse a`b`c`d`e? is it a `(b `c` d)` e, or (a `b` c) `d` e
03:54:58 <bluestorm> instead of   m a = (a -> a),  i use   m a = (a -> w a), where w is a Writer monad
03:55:28 <bluestorm> so my sum can be rewritten as   sum (f :: a -> w a) (g :: a -> w a) =  \x -> f x >>= g
03:55:29 <Cale> actually, this appears to be exactly the structure needed to make a MonadPlus, only without the Monad part, isn't it? ;)
03:55:42 <Cale> oh
03:56:24 <Cale> sum = (>=>)
03:56:40 <bluestorm> hmm
03:56:45 <bluestorm> does a >=> operator exists ?
03:56:51 <Cale> :t (>=>)
03:56:51 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
03:56:53 <bluestorm> that would be fun, it's the name i choose for mine :-'
03:56:57 <EvilTerran> it's in Control.Monad
03:57:00 <EvilTerran> in ghc 6.8
03:57:05 <EvilTerran> as is <=<
03:57:21 <EvilTerran> i primarily like 'em 'cos they make the monad laws much cleaner
03:57:28 <bluestorm> i actually don't use Haskell, but that's good to know
03:57:31 <EvilTerran> (return >=> x) = (x >=> return) = x
03:57:46 <EvilTerran> x >=> (y >=> z) = (x >=> y) >=> z
03:57:50 <paolino> lilachaze: ok, it would be nice anyway, now that I tried I don't want to live without
03:57:54 <Cale> :)
03:57:55 <bluestorm> EvilTerran: nice
03:58:16 <EvilTerran> instead of that last one being "m >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h"
03:58:45 <EvilTerran> alternatively, expressing those in prose: "return is a left- and right identity of >=>. >=> is transitive."
03:58:46 <bluestorm> i have the intuition that someone is gonna say three times "Kleisli" in a sentence about right now
03:58:46 <Cale> It's much clearer why we call it an associative law like that :)
03:58:55 <Cale> EvilTerran: associative!
03:58:58 <EvilTerran> yes
03:59:12 <EvilTerran> sorry, i wandered in here between getting up and getting coffe
03:59:23 <EvilTerran> and then wound up typing instead of just reading
03:59:26 <EvilTerran> recipe for disaster
03:59:27 <bluestorm> hm
03:59:30 <Cale> Hehe, you are forgiven :)
03:59:43 <yitz> however, it's less clear what that thing is supposed to do (unless you already understand >>=)
03:59:51 <bluestorm> >=> is actually composition in the Kleisli category
04:00:01 <Cale> bluestorm: right
04:00:07 <yitz> bluestorm: that's one
04:00:09 <EvilTerran> it's like >>>
04:00:26 <EvilTerran> except without all the Kleisli/runKleisli necessary
04:00:32 <EvilTerran> ...
04:00:35 * EvilTerran -> coffee
04:01:13 <bluestorm> that's because your type wrapper/unwrapper syntax tends to be verbose :-'
04:01:48 <Cale> bluestorm: yeah, it's required in that case to identify which Arrow instance to apply.
04:01:54 <yitz> bluestorm: EvilTerran made it two and three. You were right!!
04:02:00 <dancor> @pl (-1) ^ n
04:02:02 <lambdabot> -1 ^ n
04:02:04 <dancor> lol
04:02:30 <lilachaze> > (-1) ^ n
04:02:30 <Cale> haha, bug :)
04:02:38 <lambdabot>  Tried to use too much memory
04:02:47 <dancor> > n
04:02:48 <lambdabot>  n
04:02:51 <lilachaze> SimpleReflect FAIL
04:03:11 <Cale> I can has base case?
04:03:25 <lilachaze> > n == 0
04:03:26 <lambdabot>  False
04:03:31 <Cale> > 0^0
04:03:32 <lambdabot>  1
04:03:34 <Cale> > 0^n
04:03:38 <lambdabot>  Tried to use too much memory
04:03:44 <dancor> what is it even doing
04:03:47 <lilachaze> > 1 ^ n
04:03:51 <lambdabot>  Tried to use too much memory
04:03:53 <EvilTerran> it's broooken
04:03:59 <rwbarton> > n `div` 2
04:04:00 <lambdabot>  n `div` 2
04:04:01 <dancor> > id n
04:04:02 <lambdabot>  n
04:04:06 <yitz> > 2 ^ 3
04:04:07 <lambdabot>  8
04:04:09 <Cale> dancor: It's producing new expressions from n and hoping that one of them will be 0 so that it can stop recursive
04:04:09 <lilachaze> @goog SimpleReflect
04:04:11 <lambdabot> http://hackage.haskell.org/packages/archive/show/0.1/doc/html/SimpleReflect.html
04:04:11 <lambdabot> Title: SimpleReflect
04:04:13 <Cale> recursing*
04:04:14 <EvilTerran> > n == n
04:04:15 <lambdabot>  True
04:04:17 <Cale> @src (^)
04:04:17 <lambdabot> Source not found. You type like i drive.
04:04:18 <EvilTerran> > n == x
04:04:20 <lambdabot>  False
04:04:23 <EvilTerran> > n == 1
04:04:24 <lambdabot>  False
04:04:28 <EvilTerran> i think i know the problem
04:04:31 <Cale> > n^5
04:04:32 <lambdabot>  n * n * (n * n) * n
04:04:37 <Cale> > n^10
04:04:39 <lambdabot>  n * n * (n * n) * (n * n * (n * n)) * (n * n)
04:04:46 <EvilTerran> 2^n will be halving n repeatedly
04:04:49 <EvilTerran> until it reaches 0
04:04:51 <EvilTerran> which it won't
04:04:53 <Cale> right
04:04:58 <Cale> > n^m
04:05:02 <lambdabot>  Tried to use too much memory
04:05:03 <lilachaze> > n * n == n ^ 2
04:05:03 <EvilTerran> halving and/or subtracting one
04:05:04 <lambdabot>  True
04:05:08 <EvilTerran> ?src (^)
04:05:08 <lambdabot> Source not found. My mind is going. I can feel it.
04:05:16 <EvilTerran> is it a method?
04:05:30 <Cale> I don't think so... I think it's just missing...
04:05:30 <EvilTerran> no. doh.
04:05:50 <EvilTerran> you'll need to make it a method of Num in caleskell or something :P
04:06:07 <EvilTerran> a method of the exponent type, actually, so that'd be a method of Integral
04:06:19 <Saizan> we could upgrade to the version of reflect which reports sharing :)
04:08:34 <Cale> @src (^)
04:08:40 <lambdabot> Source not found. You speak an infinite deal of nothing
04:08:43 <Cale> ...
04:08:49 <Cale> oh right, duh :)
04:09:01 <dancor> compiling got you down?
04:09:26 <ivanm> does this mean that no-one knows of a 3D plotting library for haskell?
04:09:48 <Cale> ivanm: There's the OpenGL library. That's the closest thing I can think of.
04:09:55 <Cale> @src (^)
04:09:59 <lambdabot> x ^ 0            =  1
04:10:05 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
04:10:15 <lambdabot> Plugin `source' failed with: thread killed
04:10:16 <vixey> o_o
04:10:18 <Cale> heh, slow
04:10:35 <Cale> maybe wait for it to finish joining the 18 million channels it's in
04:10:54 <dancor> O(chan)
04:11:20 <ivanm> Cale: hmmm..
04:12:07 <Cale> @src (^)
04:12:07 <lambdabot> x ^ 0            =  1
04:12:09 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
04:12:11 <lambdabot>   where f _ 0 y = y
04:12:13 <lambdabot>         f x n y = g x n
04:12:15 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
04:12:17 <lambdabot>                       | otherwise = f x (n-1) (x*y)
04:12:19 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
04:12:54 <ivanm> Cale: you mean these bindings? http://www.haskell.org/haskellwiki/Opengl
04:12:55 <lambdabot> Title: OpenGL - HaskellWiki
04:13:04 <ivanm> if so, which bit of it exactly would do plotting?
04:13:14 <ivanm> or would I be better off just calling gnuplot or something?
04:13:53 <pozic> ivanm: extend the Charts library or use gnuplot.
04:13:57 <Cale> ivanm: Well, I'm thinking you'd have to write a function plotter yourself in terms of it, but it does 3D.
04:14:00 <shapr> @yow !
04:14:00 <lambdabot> Couldn't find fortune file
04:14:17 <dancor> @yarr is the closest we've got
04:14:18 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
04:14:25 <Saizan> ?ty () ()
04:14:26 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
04:14:48 <vixey> ?quote
04:14:48 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
04:14:50 <Saizan> that's weird ^^^
04:14:54 <ivanm> pozic: this is a quick little thing for an assignment due next week... I think extending the chart library myself would be a bit much (especially since I can't get it to compile here since haddock-0.9 fails on it :s )
04:15:11 <pozic> ivanm: the library compiles.
04:15:22 <ivanm> pozic: well, yes, but documentation is also nice ;-)
04:15:22 <pozic> ivanm: cabal install chart works
04:15:33 <Cale> ivanm: Oh, in that case, I recommend just generating data and using another program which does 3D plotting :)
04:15:35 <pozic> ivanm: there is documentation for the 0.6 version on the website.
04:15:41 <pozic> ivanm: other than that, I agre.
04:15:46 <pozic> ivanm: agree*
04:16:01 <pozic> ivanm: yes, just call gnuplot.
04:16:08 <ivanm> and dammit, I just uninstalled the darcs version of chart thinking that 0.8 would compile and work :(
04:16:14 <ivanm> is there any haskell bindings for gnuplot?
04:16:40 <pozic> Learning gnuplot also takes work, btw.
04:16:53 <pozic> gnuplot is not that smart by nature.
04:17:27 <pozic> I had to hack it so that the legend would not be positioned above the data.
04:17:42 <ivanm> or I could just use matlab for plotting, whatever
04:17:46 <ivanm> I've done that before
04:17:59 <pozic> Writing a plot library from scratch is faster than learning gnuplot, I guess.
04:18:08 <ivanm> dammit, xmonad takes too long to switch screens :s
04:18:15 <Cale> Yeah, I'd probably go with generating mathematica expressions here :)
04:18:32 * ivanm wanted to close a firefox tab but ended up closing the #haskell tab in xchat instead :s
04:22:11 <Zao> ivanm: See, that's why you shouldn't IRC in a web browser.
04:22:26 <Zao> Oh, nvm. Reading comprehension is overrated.
04:24:26 <ivanm> heh
04:25:44 <pozic> ivant: what's the assignment?
04:26:02 <ivant> pozic, pardon?
04:26:22 <pozic> ivant: "assignment due next week"
04:26:33 <ivanm> pozic: me, not ivant
04:26:34 <ivanm> ;-)
04:26:39 <ivanm> notice the difference?
04:26:42 <ivant> :-)
04:26:51 <pozic> yes, I do.
04:26:56 <pozic> ivant: sorry about that.
04:27:00 <ivant> np
04:27:07 <ivanm> and it's a computational physics assignment comparing different prngs, which we'll then be using for monte carlo methods later on
04:27:11 <Zao> I'm sorry, one of you have to change your name, preferably in real life.
04:27:26 <ivanm> so we're meant to "find out" that when we plot dodgy pseudo-random numbers, there's patterns...
04:27:28 <pozic> One of you change your name to yyyyyyyyyyyyyyyyyyyyy.
04:27:32 <ivanm> lol
04:27:41 <ivanm> hmmm.... which one of us was here first?
04:27:43 <vixey> oh no
04:27:45 <ivany> hi again everyone
04:27:47 <bluestorm> pozic: is that lojban ?
04:27:49 <ivant> Zao, can you suggest some good ones? (oh, we should move to -blah)
04:28:22 <ivanm> ivany: that's not really that funny you know...
04:28:22 <bluestorm> ivant:  tivan ?
04:28:27 <ivany> ok, ok
04:28:29 <ivant> ivanm, I'm here since 2006 something :-)
04:28:44 <ivanm> hmmm.... same here...
04:28:51 <ivanm> obviously we need to have a fight to the death!
04:29:09 <ivant> > let ivanm = undefined in ivanm
04:29:14 <lambdabot>  Exception: Prelude.undefined
04:29:25 <ivanm> lol
04:31:29 <osfameron> how do you do a fight to the death without sideeffects?
04:32:08 <ivant> osfameron, the only chance we have to resolve this is to wait till one of us gets garbage collected
04:32:20 <ivanm> heh
04:33:05 <pozic> osfameron: you fry the CPU and start a fire.
04:34:01 <pozic> Leaky abstractions
04:38:01 <pozic> How do I convert a chart into something that can be placed in a window?
04:38:25 <pozic> It seems that it only exports a way to show one chart or to export it to a file.
04:38:43 <pozic> There should be a way to place it in a container.
04:43:56 <AlexK> df
04:44:14 <ivanm> hmmmm.... this page lists haskell, but only wrt getting a shell tool from ghc's soon-to-be-extinct darcs repo...
04:44:15 <ivanm> http://www-128.ibm.com/developerworks/aix/library/au-badunixhabits.html?ca=lnxw01GoodUnixHabits
04:44:16 <lambdabot> Title: UNIX tips: Learn 10 good UNIX usage habits, http://tinyurl.com/vof3r
04:48:32 <BeelsebobWork> what does it mean if a profile shows a function as having been entered 0 times, but used 30% of your run time?
04:49:58 <pozic> BeelsebobWork: that the profiler is broken?
04:50:23 <pozic> BeelsebobWork: or you are reading it incorrectly.
04:50:46 <BeelsebobWork>    removeComments        Graphics.Formats.Obj.Parse                           519           0  32.0    8.8    32.0    8.8
04:50:57 <pozic> BeelsebobWork: one line says nothing.
04:51:22 <BeelsebobWork> hang on then, I'll pastebin a slightly smaller one
04:52:05 <BeelsebobWork> http://hpaste.org/9286#a1
04:52:10 <BeelsebobWork> it uses 19% in this one
04:52:13 <BeelsebobWork> but still -- 0 entries
04:53:42 <pozic> BeelsebobWork: I don't have a profile here, post the column names too.
04:53:58 <BeelsebobWork> the column names are at the top of the original paste
04:54:02 <pozic> BeelsebobWork: I see.
04:54:06 <BeelsebobWork> the anotation is merely a continuation
04:54:09 <sal23> http://www.hpaste.org/9275 - how can I tell if the rules are being fired and applied?
04:54:26 <BeelsebobWork> oh, woops -- the left hand time/alloc is individual
04:54:29 <BeelsebobWork> right hand is inherited
04:56:02 <pozic> BeelsebobWork: if it doesn't get called, it should be zero individual.
04:56:15 <BeelsebobWork> pozic: exactly
04:56:20 <BeelsebobWork> wierd, huh?
04:56:34 <BeelsebobWork> it in fact, surely shouldn't appear in the profile at all
04:56:58 <pozic> BeelsebobWork: what version of GHC?
04:57:11 <BeelsebobWork> 6.9.20080615
04:57:50 <BeelsebobWork> can't use 6.8.3 unfortunately, conal has some libraries we're using that need 6.9 to compile
04:57:51 <pozic> BeelsebobWork: report a bug, but it will only get fixed if you can reproduce it.
04:58:19 <pozic> BeelsebobWork: or... fix it wherever you may work.
05:06:22 <_zenon_> Hm
05:06:47 <_zenon_> Is there a way to "unbreak" an n-tuple? Like the inverse to constructing them with ','
05:07:29 <dancor> _zenon_: well there's fst and snd..
05:07:45 <dancor> you'd have to make your own like get1of3
05:07:51 <dancor> or do crazy template haskell maybe
05:08:12 <dancor> but once you're doing that maybe it's time for like actual records or some such
05:09:02 <_zenon_> No, no code here :) Just thinking with a cup 'o coffee
05:09:41 <dancor> also about "deconstructing" if you actually want a function to return _all_ the tuple parts
05:09:58 <dancor> the only real way to return many things is as a tuple :)
05:10:16 <_zenon_> or a list
05:10:22 <_zenon_> which is what I was thinking on
05:10:30 <dancor> could do in template haskell
05:10:37 <dancor> or one func for each n
05:10:48 <_zenon_> (a_0, ... , a_n) -> [a_0, ... , a_n]
05:11:09 <dancor> > let tup3ToList (a, b, c) = [a, b, c] in tup3ToList (4, 5, 6)
05:11:13 <lambdabot>  [4,5,6]
05:11:18 <dancor> bear in mind, lists are homogenous
05:12:08 <dancor> > let tup3ToList (a, b, c) = [a, b, c] in tup3ToList (4, 5, "6")
05:12:09 <lambdabot>   add an instance declaration for (Num [Char])
05:12:09 <lambdabot>     In the expression: 4
05:12:12 <oldsalt> @seen chrisdone
05:12:12 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
05:12:23 <dancor> more like lolbot lately..
05:12:40 <_zenon_> mmm
05:13:13 <dancor> so maybe i should have said: the only real way to return many _different_ things..
05:15:01 <naradapuri> Hi, I'm completely new to Haskell. As a mathematician a I'd really like to learn and use sp,e stronly typed, fuctional language such as Haskell or OCaml. However, I need to combine it with my current work in Java, i.e. to compile Haskell (or other similar language) program into Java bytecode and interface with Java classes. Is that possible and does anybody have experience with that?
05:15:54 <dancor> @go compiling haskell to java
05:15:55 <lambdabot> http://www.cs.yale.edu/~tullsen/haskell-to-java.ps
05:16:31 <dancor> naradapuri: have you checked out some of these google hits
05:18:16 <naradapuri> dancor: yes, I was looking around, but since I'm new to Haskell I wasn't able to distinguish which projects are just mere ideas and which are ready to be practically used
05:18:37 <Zao> YHC runs on the JVM, doesn't it?
05:20:39 <BeelsebobWork> it can do I believe
05:20:46 <BeelsebobWork> but usually it runs in it's own VM
05:21:19 <conal> does anyone here know how it is that the haskell wiki understands <haskell> and <hask>?  i'd like to tweak another mediawiki to do the same.
05:22:27 <dancor> also looks like lambdavm can at least do somethings
05:23:15 <dancor> conal: hm who runs the wiki
05:24:04 <dancor> ashley yang maybe, given http://www.haskell.org/haskellwiki/HaskellWiki:Community#Spammers
05:24:05 <lambdabot> Title: HaskellWiki:Community - HaskellWiki
05:24:20 <dancor> s/yang/yakeley
05:24:38 <dancor> score: http://www.haskell.org/haskellwiki/Special:Listusers%26group%3Dsysop
05:24:39 <lambdabot> Title: User list - HaskellWiki, http://tinyurl.com/5vb4zl
05:29:08 <gwern> I'm not sure ashley is active
05:29:32 <gwern> I haven't seen any editsfrom him in months, since the euler answers fuss
05:29:38 <naradapuri> I'll have a look at YHC. It looks like that it can construct JavaScript code. Maybe this would be a solution too, to generate Java code from Haskell programs.
05:29:46 <naradapuri> LambdaVM looks interesting too
05:30:14 <jeffz> ashley posted on -cafe a day ago about haskell.org slowness
05:31:29 <dancor> naradapuri: java != javascript..
05:31:35 <yitz> naradapuri: the standard place for info about this topic ought to be here: http://www.haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages
05:31:36 <lambdabot> Title: Applications and libraries/Interfacing other languages - HaskellWiki, http://tinyurl.com/66ubno
05:32:05 <yitz> however, neither of those two options is mentioned. so please update that page with whatever you find out, if even just a link.
05:32:46 <yitz> some of the java stuff there is definitely obsolete, such as GCJNI.
05:33:03 <yitz> however there is another option mentioned there which looks interesting: CAL.
05:33:32 <yitz> it's a haskell-like language that compiles to jvm and supports java objects.
05:33:54 <naradapuri> dancor: java != javascript: Sure, what I meant was that one might take the same approach and write a library to construct Java programs using Haskell.
05:35:05 <pozic> naradapuri: and what makes you think that you need to have java objects and haskell objects in the same address space?
05:35:48 <mmorrow> how does one go about allocaing in a Data.Binary.get (or how would the equivalent be accomplished)? http://hpaste.org/9287
05:37:41 <taruti> mmorrow: there was a monad transformer version of Get somewhere that could be used
05:38:24 <naradapuri> pozic: Well, maybe it won't be necessary, but I'm using various Java libraries and I like the possibility to run programs almost anywhere without recompiling etc.
05:39:46 <mmorrow> taruti: cool, is it included in the binary package?
05:40:52 * mmorrow searches hackage
05:41:24 <taruti> I don't remember where it is available, dons probably knows.
05:41:52 <taruti> the dirty alternative is unsafePerformIO and be careful with inlining and cse.
05:42:18 <mmorrow> heh, i though of that, chuckled, and decided against it...
05:42:42 <BeelsebobWork> hmm, interesting
05:42:48 <mmorrow> it seems to me allocating would be at least somewhat of a common thing to want to do in a get
05:43:09 <mmorrow> is there another fundamental strategy to achieve the equiv that i'm not thinking of?
05:43:14 <BeelsebobWork> removeComments bs = case CBS.split '#' bs of {[]     -> BS.empty; (x:xs) -> x} runs a lot faster than CBS.takeWhile (/='#')
05:44:18 <mmorrow> hmm, maybe i will try unsafePerformIO...
05:44:35 <mmorrow> @seen dons
05:44:35 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
05:49:12 <qebab> O.o
05:49:29 <qebab> is lambdabot out of shape today?
05:49:42 <ski> @botsnack
05:49:42 <lambdabot> :)
05:52:10 <ivanm> no wonder lambdabot is out of shape, if ski keeps feeding her snacks!
05:52:31 <ski> @botsmack
05:52:32 <lambdabot> :)
05:58:44 <mandork_x> SCIENCENODE from FREENODE is now online guys!!  visit SCIENCENODE.COM
05:58:48 <mandork_x>  SCIENCENODE from FREENODE is now online guys!!  visit SCIENCENODE.COM
05:58:52 <mandork_x>   SCIENCENODE from FREENODE is now online guys!!  visit SCIENCENODE.COM
06:03:49 * ivanm thinks someone needs to be kicked and banned...
06:03:54 <pejo> @where ops
06:03:54 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
06:04:10 <ivanm> :o didn't know about that one...
06:04:10 --- mode: ChanServ set +o dcoutts
06:04:14 --- kick: mandork_x was kicked by dcoutts (dcoutts)
06:04:35 <tusho> SCIENCENODE!
06:04:56 <tusho> what is it actually
06:05:05 <yitz> spam
06:05:15 <tusho> ah
06:05:16 <tusho> a lame forum
06:05:59 * Shiruka wonders what the "from freenode" was supposed to mean..
06:06:33 <Shiruka> etymological relation maybe..?
06:08:34 --- mode: ChanServ set -o dcoutts
06:09:48 <allbery_b> truying to pretend it's an official freenode service so people won't ban them?
06:09:55 <tusho> allbery_b: yep
06:10:07 <allbery_b> (of course freenoders would use notify like they normally do)
06:10:08 <tusho> in actuality, freenode spam would look like this
06:10:19 <Zao> I assume it's originally a channel on freenode that has got a website nowadays.
06:10:23 <tusho> <staffer> help we can't afford to eat can you buy our 5 old domains?????????? SUPPORT US GUYS
06:12:45 <tibbe> quick, I need some interesting but not too heavy papers to read on the plane :)
06:13:14 <ivanm> tibbe: if they're too heavy, trying using thinner paper
06:13:16 * Shiruka prepares to google for deep category theory
06:13:16 <ivanm> or print two pages to a side
06:13:21 <ivanm> that will make them lighter for you!
06:13:22 <tibbe> ivanm: :p
06:13:48 * tibbe enjoyed light weight monadic regions by Oleg and the BigTable paper he read the other week.
06:14:04 <tibbe> Something on fast web server implementation would be interesting.
06:14:48 <ivanm> tibbe: so you make excuses to fly just so that you can read more papers?
06:14:53 <pejo> tibbe, have you read the stream fusion/constructor specialisation stuff? Or the concurrent GC paper?
06:15:49 <pejo> (Looking at SPJ's homepage and grabbing whatever is from the current year is always a nice way to get something nice :-)
06:17:13 <tibbe> pejo: yes, I think I have read all of his papers more or less
06:17:38 <Shiruka> tibbe, you've read the classic simon paper on haskell web server, right?
06:18:07 <Shiruka> (just checking :-)
06:19:16 <pejo> tibbe, icfp/hw/ml'08 all have the accepted papers lists up.
06:21:59 <_zenon_> This is odd
06:22:04 <_zenon_> I was writing my code in vim
06:22:08 <_zenon_> now I opened it in gedit
06:22:18 <_zenon_> and some hidden formatting must have gotten all kukoo
06:22:34 <_zenon_> cause ghci is whining about "last statement in do..."
06:23:40 <Shiruka> tab width..?
06:24:08 <_zenon_> set to 4 (spaces) in both
06:24:45 <Shiruka> hopefully without mixing tabs and spaces.. IIRC ghc assumes 8, and with tab/space mixtures that could matter
06:25:50 <_zenon_> hmm.. just ol'e good hand indenting will save me now
06:26:16 <_zenon_> Maybe I should practice more monogamy with my editors
06:26:39 <ulfdoz> _zenon_: try tr for replacement of tabs/spaces.
06:26:41 <BONUS> search replace
06:26:42 <BONUS> yeah
06:26:48 <BONUS> replace \t with four spaces
06:26:51 <smtms> _zenon_, vim has a mode which makes tab characters visible
06:27:09 <_zenon_> fixed it :)
06:27:29 <_zenon_> yeah but I set vim to insert 4 spaces instead of tabs
06:27:42 <_zenon_> so there ought not to be any hard tabs there
06:28:53 <Shiruka> you can set that in gedit too
06:30:14 <_zenon_> Shiruka, both have 4 spaces
06:30:24 <_zenon_> "<_zenon_> set to 4 (spaces) in both"
06:31:39 <_zenon_> anyway
06:31:42 <Shiruka> oh, I thought you meant set to display as 4 spaces
06:31:57 <Shiruka> the setting of how many spaces to display and to "insert spaces instead of tabs" is usually separate
06:31:58 <_zenon_> nah, however, I will go see Batman today
06:33:51 <_zenon_> Is there no function  base64encode :: String -> String ?
06:34:04 <Botje> @hoogle base64
06:34:05 <lambdabot> No matches found
06:34:33 <Botje> there's a base64-string package on hackage
06:34:45 <_zenon_> Botje, I'll check that out
06:35:25 <_zenon_> Nice
06:35:30 <_zenon_> encode :: String -> String
06:35:30 <_zenon_> decode :: String -> String
06:35:33 <_zenon_> Purrrr-fect
06:37:53 <yitz> _zenon_: the dataenc package - also on hackage - provides a standard interface to many data encodings - base64 and others
06:38:21 <_zenon_> yitz, thanks for the tip
06:38:46 <osfameron> would it be easy to embed ghc in another language?
06:38:52 <osfameron> e.g. to write Inline::GHC for Perl ?
06:40:57 <Shiruka> you could just invoke ghc itself
06:41:16 <Shiruka> even hs-plugins does that, and it's written in haskell
06:41:41 <osfameron> invoke the executable you mean?
06:41:51 <Shiruka> yes
06:42:13 <osfameron> ah ok.  I think that's how audreyt's Language::Haskell speaks to hugs
06:42:57 <osfameron> nothingmuch was (if I understood correctly) suggesting ghc might provide a more sophisticated interface that it would be more elegant to use
06:43:20 <ddarius> There's the GHC API and wrappers around it.
06:44:29 <osfameron> oki
06:44:53 * osfameron adds ghc api to his tuits list...
06:48:03 <osfameron> http://haskell.org/haskellwiki/GHC/As_a_library suggests using GHC api from within haskell itself
06:48:04 <lambdabot> Title: GHC/As a library - HaskellWiki
06:48:24 <osfameron> can it be used from C (and consequently Perl/XS) ?
06:48:33 <jeffersonheard> erm...  I just tried to use hSetFileSize from the IO library, and GHC 6.8.3 reports that it's not there
06:48:42 <jeffersonheard> and yes, I have a good reason to be using the h* set of functions
06:49:47 <FordCortina> what is kind '??' ?
06:51:45 * Botje is three problems away from having solved the first 100 problems on projectuler
06:52:04 <osfameron> Botje: congrats!
06:52:37 <Botje> it's a shame haskell is so low on the statistics
06:52:56 * osfameron has only done about 40
06:54:10 <yitz> jeffersonheard: hmm. its still there in http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
06:54:11 <lambdabot> Title: System.IO, http://tinyurl.com/y9dfge
06:54:25 * Botje continues hacking on ASP.NET code
06:54:50 <Shiruka> osfameron: you could just implement the stuff you need and then call wrap it using FFI
06:55:14 <osfameron> Botje: it's 5th!  that's pretty good, no?
06:55:43 <Shiruka> hs-plugins has similar functionality and a few C wrappers; I'm not sure how much they overlap (and the pre-existing C wrappers in hs-plugins are unlikely to be sufficient for you anyway :-)
06:55:48 <Botje> ah?
06:55:55 <Botje> last time i checked it was 12th or something
06:56:11 <yitz> jeffersonheard: it's even there in the current darcs: http://darcs.haskell.org/packages/base/System/IO.hs
06:56:40 <Shiruka> also, you may need to compile a new perl executable, wrapping perl in haskell, as ghc does not support compiling loadable libraries on all platforms
06:56:48 <Shiruka> s/wrapping/embedding/
06:57:14 <osfameron> Shiruka: oh I have no idea what I'm doing.  When I get tuits I'll have a look at the api and wrapper scripts.  Of course I dont really know enough C, or the Perl XS API... but that should be fun, right? ;-P
06:57:28 <Shiruka> heh :-)
06:57:45 <yitz> jeffersonheard: are you using the old haskell98 IO instead of System.IO?
06:58:00 <Shiruka> I've been thinking of building a python<->haskell bridge, so I've looked a bit into it (but only just a bit so far)
06:58:07 <jeffersonheard> yitz, Grr... yes...  System.IO fixed it
06:58:16 <osfameron> hmmm, it would be (ideally) possible not to have to recompile Perl inside haskell - the other Inline:: modules usually support being loaded from within a normal Perl, transparently
06:58:30 <yitz> jeffersonheard: ok, glad it's fixed :)
06:58:43 * jeffersonheard rolls eyes at self
07:00:08 <jeffersonheard> Heh.  And that seems to fix everything...  yay.  I now have an image viewer capable of displaying images of literally unlimited size, with wikified annotations.
07:00:18 <jeffersonheard> Now for security and a little code cleanup, and voila
07:01:09 <Shiruka> osfameron: at least on linux ghc does not support producing position-independent code, so it can't compile haskell into .so which could be loaded.. dunno about other platforms
07:01:15 <jeffersonheard> Question for the world.  I still have a little pythong code that accesses objects in C++.  The way I've seen for accessing objects in haskell is hideous, involving finding the mangled name.
07:01:42 <jeffersonheard> Is there a better way?  My preference would be to write a wrapper that makes C like functions out of all the public methods and a constructor
07:01:46 <jeffersonheard> and write the FFI wrapper around that
07:03:50 <Shiruka> um, the standard practice for accessing C++ from any other language is to use export "C" on the C++ side
07:04:02 <Shiruka> C++ doesn't have a stable ABI
07:04:21 <Shiruka> it can vary from platform to platform, from compiler to compiler, and from compiler _version_ to version..
07:04:31 <guenni> hi is there a DateTime type in the lib?
07:04:33 <jeffersonheard> That was my general impression, yes
07:05:13 <osfameron> Shiruka: so I could perhaps create a ghc program that uses the GHC api to compile and run functions, and then communicate from the Perl program with that through some IPC mechanism ?
07:05:15 <jeffersonheard> which was why I suggested writing C-like functions out of all the public methods.
07:05:43 <bluestorm> hm
07:05:53 <jeffersonheard> Meaning writing functions that take the object pointer as the first parameter, and all the rest of the parameters afterwards, then declaring those "export C"
07:05:58 <jeffersonheard> sorry for being unclear
07:06:09 <Shiruka> (uh, s/export/extern/, of course..)
07:06:10 <bluestorm> that (a -> w a) story seems to have more to say
07:06:14 <jeffersonheard> yes
07:06:51 <jeffersonheard> It's horrible, but at least it's portable
07:07:51 <Shiruka> something like that.. if you have lots of templates in the C++ code, then you have lots of more fun :-)
07:07:57 <bluestorm> (quick summary : i have (nothing :: a -> m a) and (sum :: (a -> m a) -> (a -> m a) -> (a -> m a)) , wich is a specialization of kleisli composition >=> , and that is a monoid)
07:08:23 <jeffersonheard> I realize that, but no; mostly this is library code that my coworkers have written.  Legacy stuff, and it's fairly basic C++
07:08:24 <Shiruka> osfameron: you could do that, but then you get a performance hit
07:08:43 <bluestorm> in my case, what  a -> m a   does is  "modify a stack (a) while possibily doing some output (m as a writer monad)"
07:08:48 <jeffersonheard> I've managed to sell my boss on the virtues of haskell, but not the rest of my colleagues
07:08:50 <jeffersonheard> :P
07:08:51 <Shiruka> osfameron: as an extreme case of that, you could just run ghci and pipe I/O between that and perl ;-)
07:08:58 <osfameron> yeah true
07:09:51 <bluestorm> so i naturally came up with two functions (this is post-writing refactorisation, so the declaration of function is motivated by real in-code use)
07:10:21 <bluestorm> one of them is    set_stack stack = fun _ -> nothing stack
07:10:33 <bluestorm> wich does not output and set the stack to the given value
07:11:07 <Shiruka> jeffersonheard: another case where you need to do manual "mangling" of names is overloading; you might be able to do much of the work automatically, if there's a tool for that (I haven't searched for one)
07:11:22 <Shiruka> on the Haskell side, maybe you could use Template Haskell
07:11:49 <jeffersonheard> On the haskell side, I was planning to, although I'm not terribly familiar with it.  Seemed like a good excuse
07:11:50 <bluestorm> and the other one is motivated by function wich need to look at the stack before choosing  a transformation :
07:12:07 <bluestorm> inspect :: a -> (a -> m a) -> (a -> m a)
07:12:32 <bluestorm> it seems that inspect can be generalized to hm
07:12:48 <bluestorm> with_output_inspect :: (a -> m (a -> m a)) -> (a -> m a)
07:12:58 <bluestorm> wich is the point of my long rant
07:13:18 <bluestorm> it seems that    set_stack and inspect   form a monad
07:13:50 <bluestorm> so the question is : is that a known monad, and do you know other uses ?
07:14:30 <bluestorm> (or maybe it actually isn't, but the type are ok and maths are nice)
07:15:37 <jeffersonheard> Oh hey, Shiruka...  What's wrong with MissingPy as a pythonbinding?
07:15:49 <Shiruka> jeffersonheard: if the C++ API is big, you could even consider writing a custom API converter that tries to parse the relevant bits of C++ code :-) should be more fun than grunt work of doing it manually
07:16:04 <Shiruka> missingpy is one direction only, haskell->python
07:16:22 <jeffersonheard> ah, you want to call haskell from python
07:16:25 <jeffersonheard> right
07:16:31 <Shiruka> and it's gpl :-/
07:16:50 <jeffersonheard> right.  that's painful
07:17:45 <jeffersonheard> Shiruka, if I ever get around to porting OpenSceneGraph to haskell, that'd be the only way to go.
07:18:07 <osfameron> you could write a python to haskell compiler
07:18:52 <OceanSpray> I was trying to do an SICP exercise in Haskell.
07:19:09 <mar77a> is there a guide on install cabal in windows
07:19:16 <OceanSpray> and ghci gave me some error about "unable to construct infinite type"
07:19:19 <mar77a> s/install/installing
07:19:46 <dcoutts> mar77a: it's not really any different to installing it on any other OS
07:20:04 <OceanSpray> I don't have the book with me right now, but the exercise had something to do with writing a factorial function using a function:
07:20:45 <Deewiant> OceanSpray: SICP is on the 'Net, you know. :-) http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start
07:20:46 <lambdabot> Title: Structure and Interpretation of Computer Programs, http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start
07:20:54 <OceanSpray> (lambda (f) (f f n)) where n is the input
07:22:06 <OceanSpray> Exercise 4.21, then.
07:22:25 <OceanSpray> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.21
07:22:26 <lambdabot> Title: Structure and Interpretation of Computer Programs, http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_thm_4.21
07:22:39 <Deewiant> looks like the y combinator
07:22:43 <Deewiant> ?ty fix
07:22:44 <lambdabot> forall a. (a -> a) -> a
07:22:44 <OceanSpray> how would you translate that into Haskell without making the compiler angry?
07:23:00 <OceanSpray> :t fix
07:23:00 <lambdabot> forall a. (a -> a) -> a
07:23:10 <OceanSpray> @src fix
07:23:10 <lambdabot> fix f = let x = f x in x
07:23:19 <OceanSpray> you use a let.
07:23:23 <OceanSpray> I see now.
07:23:28 <bluestorm> :D
07:23:40 <bluestorm> OceanSpray: it may be possible to express fix without a let
07:23:43 <drigz> OceanSpray: I think the wikipedia article on Y combinators has something on how to make the type checker accept the standard form
07:23:46 <Deewiant> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5
07:23:48 <lambdabot>  120
07:23:58 <Deewiant> bluestorm: yes, with a where. ;-)
07:24:05 <bluestorm> you cheater
07:24:10 <pgavin> type families are available in 6
07:24:13 <pgavin> 6.8.3?
07:24:20 <pgavin> err, 6.8.2, even?
07:24:27 <bluestorm> i mean, without explicit recursion Deewiant
07:24:55 <Deewiant> I think you need a newtype though
07:25:10 <Deewiant> s/newtype/recursive newtype/
07:25:17 <Deewiant> i.e. you have the explicit recursion but at the type level
07:25:57 <mar77a> er well i just followed the steps but i've no idea where it installed it to
07:26:02 <OceanSpray> "In some other systems, for example the simply typed lambda calculus, a well-typed fixed-point combinator cannot be written. In those systems any support for recursion must be explicitly added to the language."
07:26:04 <OceanSpray> Huh.
07:27:46 <bluestorm> OceanSpray: actually, other features imply support for recursion
07:28:04 <bluestorm> as Deewiant said, iirc type-level recursion can be used to provide value-level recursion
07:28:45 <OceanSpray> I have another question.
07:28:52 <bluestorm> in OCaml there are weird use of the exception mechanism that allows that too (and some other magic things)
07:29:00 <OceanSpray> Is lazy pattern-matching really "necessary"?
07:29:16 <bluestorm> useful in some cases
07:29:16 <Deewiant> rarely
07:29:26 <bluestorm> eg. if you want to emulate I/O with lazy lists
07:29:36 <OceanSpray> In the Haskell history, I read something about lazy pattern-matching being added because of tuples' lifted semantics.
07:29:37 <Deewiant> it's explicit even in Haskell, where pretty much everything is lazy by default ;-)
07:29:41 <OceanSpray> I didn't really get that part.
07:30:06 <bluestorm> OceanSpray: probably means that
07:30:07 <yitz> you need it to construct a loopy data structure
07:30:11 <bluestorm> let (_, _) = bottom
07:30:14 <bluestorm> would fail
07:30:25 <OceanSpray> huh?
07:30:27 <yitz> e.g., a circular linked list
07:33:18 <nominolo_> @users
07:33:18 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
07:33:22 <bluestorm> OceanSpray:  do you now what  bottom (sometimes written _|_) is ?
07:34:14 <dino-> I'm about to use WriterT for logging. Ideally this would be a long long running piece of code that may actually log quite a bit.
07:34:34 <dino-> I'm fearful of the mappend on, say, a [String] being a major problem when this bad boy gets long.
07:34:43 <OceanSpray> bluestorm, non-termination?
07:35:07 <bluestorm> yes, and can be used as a haskell value
07:35:08 <DrSyzygy> Stupid question.
07:35:12 <nominolo_> dino-: you can use a StateT and cons to the head, then reverse at the ned
07:35:21 <DrSyzygy> I downloaded a package from Hackage, I untared it, configured, built and installed it.
07:35:27 <nominolo_> dino-: alternatively, you can use Seq
07:35:32 <DrSyzygy> What more do I need to do to actually play with it?
07:35:50 <nominolo_> DrSyzygy: does it contain an executable?
07:36:06 <DrSyzygy> No, it's a library.
07:36:11 <DrSyzygy> Hipmunk, to be exact.
07:36:27 <dino-> Not sure what 'at the end' means in this context. I mean, this runs for a long time and we'd like logging messages to be arriving in a log file somewhere. Like lazily I guess as they're tell'd
07:36:52 <OceanSpray> Last question:
07:36:56 <DrSyzygy> And specifically, what annoys me is that I cannot load the modules it exposes into GHCi
07:37:00 <nominolo_> DrSyzygy: ok, then type ghc-pkg list hipmunk to check it's installed, then read documentation and use the modules in your code
07:37:03 <Shiruka> I'm still shaky on much of the more academic terminology, but at least in some ghc texts lifted types were boxed ones (can contain thunks and hence _|_) and unlifted types the unboxed ones (not thunks, no _|_ inside)..
07:37:21 <nominolo_> DrSyzygy: what's the error message?
07:37:31 <OceanSpray> I read something about GHC moving from being stack-based to eval/apply.
07:37:41 <dino-> It's almost like a queue would be nicer. log message producing code puts messages on one and and log output is trying to take them off the other.
07:37:47 <DrSyzygy> module main:Physics.Hipmunk is not loaded
07:37:50 <OceanSpray> Where can I find the research paper about that?
07:37:58 <DrSyzygy> I notice, now, that it tab-completes it - so some parts know about it.
07:38:10 <OceanSpray> My google-fu is weak today.
07:38:15 <Shiruka> OceanSpray: just guessing, but maybe http://research.microsoft.com/~simonpj/papers/papers.html
07:38:17 <lambdabot> Title: Simon Peyton Jones: papers
07:38:19 <Shiruka> (often a good guess)
07:38:23 <pejo> OceanSpray, one of the Simon's homepages.
07:38:35 <dino-> What is Seq?
07:38:46 <OceanSpray> Huh.
07:38:46 <dieJana> what are the "continuity principles"?
07:38:53 <Shiruka> "How to make a fast curry: push/enter vs eval/apply" <-- that one looks likely
07:38:54 <OceanSpray> Thanks.
07:38:58 <nominolo_> DrSyzygy: you may have to start ghci with -package hipmunk
07:39:08 <nominolo_> dino-: Data.Sequence
07:39:09 <bluestorm> OceanSpray: http://pastebin.be/13100 (for the lifting thing)
07:39:26 <nominolo_> dino-: it has O(1) cons and snoc (cons at the end)
07:39:31 <OceanSpray> Holy shit, that site's the mother lode.
07:39:36 <dino-> hm, finite sequences
07:39:39 <nominolo_> ond O(log N) append
07:39:55 <DrSyzygy> DOH!
07:40:15 <DrSyzygy> I was still standing in the distribution directory. It grabbed the pre-build sources instead of the installed module.
07:40:28 <dieJana> I got it
07:40:30 <sence> hi
07:40:30 <Shiruka> OceanSpray: some of the newer ones are in other pages @ http://research.microsoft.com/~simonpj/
07:40:30 <lambdabot> Title: Simon Peyton Jones
07:40:32 <dino-> And it's a Monoid, hm
07:40:55 <sence> can i find any one speak arabic?
07:40:58 <dino-> nominolo_: Thank you
07:40:59 <OceanSpray>     *  How to make a fast curry: push/enter vs eval/apply, Simon Marlow and Simon Peyton Jones, Proc International Conference on Functional Programming, Snowbird, Sept 2004, pp4-15.
07:41:03 <OceanSpray> this seems to be it.
07:41:22 <sence> can i find any one speak arabic?
07:41:43 <dieJana> sence: if you search hard enough, you could
07:57:22 <dino-> Another thing that I'm curious about is what does pass in MonadWriter do?
07:58:25 <dino-> dolio: Yes, it's me again. Still lurking around Writer.
08:17:45 * Lemmih kicks lambdabot.
08:17:55 <BeelsebobWork> @botsnack
08:17:56 <lambdabot> :)
08:18:01 <BeelsebobWork> good lambdabot
08:18:02 <DrSyzygy> @botsnack
08:18:02 <lambdabot> :)
08:18:08 <DrSyzygy> @botpat
08:18:09 <lambdabot> Unknown command, try @list
08:18:11 <DrSyzygy> Awwww.
08:18:37 <Jedai> dino-: Did you understand "pass" yet ?
08:19:44 <dino-> Jedai: no
08:20:12 <Jedai> dino-: All about monads explains it pretty well
08:20:55 <Lemmih> @seen Lemmih
08:20:55 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
08:21:06 <Jedai> In fact, pass has a slighly twisted type, censor which cover the same functionality (and use pass underneath) has a much more pleasant type
08:21:28 <Jedai> @where All about monads
08:21:28 <lambdabot> I know nothing about all.
08:21:37 <Jedai> @where "All about monads"
08:21:37 <lambdabot> I know nothing about "all.
08:22:30 <dino-> Maybe it's me, but I'm having problems understanding those explanations of listen and pass (and censor) in All About
08:22:38 <dino-> Until dolio explained listen, last night.
08:23:00 <dino-> Anyway, thanks
08:24:27 <Jedai> dino-: Ok, let's start with censor : you give it a function from w to w (w being the type of the log of your Writer, typically a list) and a computation and it gives you the same computation but whose log has been modified by the function you passed
08:24:34 <dino-> I'm gathering that you don't use pass directly, instead censor
08:25:26 <Jedai> A simple example, you could filter all the swear words from your log with "censor delSwearWords action"
08:25:47 <dino-> So, the log that the passed computation may write is what gets modified?
08:26:00 <Jedai> dino-: Yes
08:26:17 <dino-> Or the other way around, augment a log. Maybe add date/time stamps, who knows.
08:26:47 <Jedai> dino-: Yep :)
08:27:01 <chrisdone> @botsmack
08:27:02 <lambdabot> :)
08:27:07 <chrisdone> kinkeh
08:27:10 <dino-> Ok, I'm glad I persistenly barked about this. Because now that sounds like something I may have a use for.
08:29:21 <adekoba> I'm trying to understand how monads work, but I keep running into an error. What am I doing incorrectly? http://hpaste.org/9290
08:30:40 <Botje> I think you just need to do instance Monad Rand
08:31:13 <Botje> but i could be (and probably am) wrong
08:31:13 <adekoba> Botje: when I do that, ghc gives me an error: "Type synonym `Rand' should have 1 argument, but has been given 0"
08:33:05 <Botje> hmm
08:33:23 <Botje> anyway, instance Monad (Rand a) means you have a type Rand a b where the Rand a part is a monad
08:33:29 <Jedai> Type synonym aren't allowed in instances (at least in Haskell 98)
08:33:33 <Botje> so that's why you get a kind error
08:33:56 <Jedai> You should use a newtype or a datatype
08:34:00 <adekoba> thanks guys. I'll try it with newtype
08:37:57 <adekoba> I've updated it, but I still get an error (that I don't quite understand): http://hpaste.org/9290#a1
08:39:36 <dino-> Jedai: Got pulled away for real work. Thank you!
08:41:11 <Jedai> adekoba: runRand (b a) appears to be the guilty part, you probably meant runRand (b val1)
08:41:46 <adekoba> Jedai: haha, that was it
08:41:59 <adekoba> thanks!
08:46:24 <monochrom> <3 haskell
08:46:50 <monochrom> haskell is the language of the 21st Century.
08:47:43 <kaol> @where haskell_jobs
08:47:43 <lambdabot> I know nothing about haskell_jobs.
08:50:20 <OceanSpray> what what
08:52:13 <chrisdone> dons: hey that formlets post is awesome!
09:01:41 <roconnor> What can I do with view patterns that I can't do with pattern guards?
09:01:58 <mjrosenb> view patterns?
09:02:19 <roconnor> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
09:02:23 <lambdabot> Title: ViewPatterns - GHC - Trac
09:02:52 <roconnor> *L* ``Data.Sequence already defines the views from the left...''
09:03:46 <mjrosenb> i assume that that's been implemented using some sort of code transformation
09:05:10 <roconnor> that something can be some sort of elegant something or other
09:05:56 <lispy> Someone said my name here again, but my scroll back is too small :(
09:06:21 <mjrosenb> lispy: logs?
09:06:26 <Deewiant> lispy: lambdabot did it
09:06:39 <Deewiant> looks like someone did @where ops
09:06:55 <lispy> Ah
09:07:44 * Shiruka writes a note: once in a while, use the adjective "lispy" of some random haskell code here
09:08:02 <lispy> Shiruka: yeah
09:08:19 <lispy> vincenz is notorious for that :)
09:08:44 <lispy> How is code this morning?
09:08:49 <roconnor> > let {lispy = 2:filter lisp [3..]; lisp n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) lispy)} in lispy
09:08:50 <lispy> What are people working on today?
09:08:54 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:09:19 <lispy> If you're going to define lispy, I have a better definition, just a sec
09:09:54 <lispy> ?let init . map snd . filter fst . zip (fix ([True, False]
09:09:54 <lambdabot>  Parse error
09:09:55 <lispy> oops
09:10:16 <lispy> ?let lispy = init . map snd . filter fst . zip (fix ([True, False]++)) . ap (zipWith (+)) tail . map length . group . fix $ show
09:10:25 <lambdabot> Defined.
09:10:28 <lispy> > lispy
09:10:32 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
09:10:35 <Shiruka> > let lispy = cycle "(" ++ cycle ")" in lispy
09:10:36 <lambdabot>  "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
09:10:43 <roconnor> *L*
09:10:51 <mauke> > let lispy = repeat ')' in lispy
09:10:52 <lambdabot>  ")))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))...
09:11:08 <lispy> Note that, lispy generates the powers of 2 by counting quote characters generated by "fix show"
09:11:54 <lispy> How's that for obsfuscated :)
09:11:59 <roconnor> sounds like something lispy would do :)
09:12:07 <monochrom> haha
09:12:27 <monochrom> @let monochrom = monochrom
09:12:27 <lambdabot> Defined.
09:12:33 <lispy> hehe
09:12:33 * monochrom defines monochrom
09:12:37 <lispy> > monochrom
09:12:44 <lispy> black hole!
09:12:51 <mauke> > map length . groupBy (<) . fix $ show
09:12:52 <lambdabot>  thread killed
09:12:54 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
09:13:01 <mauke> OPTIMIZED
09:13:02 <monochrom> How to remove it?
09:13:04 <lispy> mauke: interesting
09:13:19 <mauke> @define
09:13:20 <lambdabot> Undefined.
09:13:41 <lispy> mauke: that's really cool
09:13:53 <mjrosenb> .... wow
09:14:00 <lispy> > groupBy (<) . fix $ show
09:14:01 <lambdabot>  ["\"\\","\"\\\\\\","\"\\\\\\\\\\\\\\","\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\","\"...
09:14:03 <monochrom> > monochrom  {- testing -}
09:14:04 <lambdabot>   Not in scope: `monochrom'
09:14:08 <monochrom> good
09:14:13 <mauke> lispy: blame Cale
09:14:20 <lispy> mauke: hehe, I will
09:14:34 <mjrosenb> i've never seen such total disregard for the underlying architecture
09:14:35 <lispy> I don't really get how groupBy (<) works
09:15:19 <lispy> > "\"" < "\"\""
09:15:22 <lambdabot>  True
09:15:33 <lispy> so it's sorting them
09:15:43 <lispy> That is clever
09:15:47 <lispy> Cale++
09:15:52 <maltem> > groupBy (<) [1,1,2,2,3,3,0,0]
09:15:53 <lambdabot>  [[1],[1,2,2,3,3],[0],[0]]
09:16:03 <monochrom> That is what you mean by blaming Cale? :)
09:16:56 <lispy> Well, I was the one that started playing with (fix show) and proposed the challenge of generating powers of 2...and the old solution made it into HWN and was cool.  But, damn this optimized one is slick.
09:17:06 <MyCatVerbs> So groupBy (<=) extracts monotonically increasing sequences.
09:17:24 <lispy> MyCatVerbs: yes, well put
09:18:06 <maltem> While groupBy (<) rejects those where the first two elements are equal?
09:18:07 <MyCatVerbs> Using groupBy or nubBy with predicates that aren't equivalence relations still always makes me nervous.
09:18:33 <lispy> MyCatVerbs: right
09:18:42 <Shiruka> I like them :-(
09:18:48 <MyCatVerbs> @src groupBy
09:18:49 <lambdabot> groupBy _  []       =  []
09:18:49 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:18:49 <lambdabot>     where (ys,zs) = span (eq x) xs
09:19:00 <lispy> > groupBy (<=) [1,1,2,2,3,3,0,0]
09:19:01 <lambdabot>  [[1,1,2,2,3,3],[0,0]]
09:19:32 * Shiruka tends to think operationally though
09:19:38 <maltem> right, it always "compares" against the first element of the subsequence
09:19:41 <lispy> Yeah, why is it that it groupBy (<) didn't split the 2,2 or the 3,3 parts?
09:19:54 <MyCatVerbs> @src span
09:19:54 <lambdabot> Source not found. Maybe you made a typo?
09:20:19 <mauke> > groupBy ((==) `on` (==) ';') "foo;bar;;baz"
09:20:20 <BMeph> MyCatVerbs: Are you the one that encourages those "Federal Law prohibits using this product in ways other than as specified" labels? ;)
09:20:22 <lambdabot>  ["foo",";","bar",";;","baz"]
09:20:27 <lispy> > groupBy [1,1,2,2,3,3,0,0] -- the splitting is not consistent
09:20:28 <lambdabot>  Couldn't match expected type `a -> a -> Bool'
09:20:36 <lispy> > groupBy (<) [1,1,2,2,3,3,0,0] -- the splitting is not consistent
09:20:37 <lambdabot>  [[1],[1,2,2,3,3],[0],[0]]
09:20:42 <Jedai> lispy: Because it don't compare an element to the next
09:20:44 <Shiruka> maybe groupBy just uses the first one in the sequence
09:20:50 <Shiruka> as a reference point
09:20:52 <dcoutts_> audreyt: http://svn.pugscode.org/pugs/INSTALL  nice :-)
09:21:07 <lispy> > groupBy (<) [0,1,1,2,2,3,3,0,0] -- the splitting is not consistent
09:21:08 <lambdabot>  [[0,1,1,2,2,3,3],[0],[0]]
09:21:11 <maltem> lispy: 1<2 and 1<3 makes [1,2,2,3,3] valid, but not (1<1) splits off the first 1
09:21:12 <MyCatVerbs> BMeph: I'm one of these people who likes reasonable invariants.
09:21:15 <dcoutts_> audreyt: now all we need is cabal-install bundled in the Haskell Platform
09:21:28 <lispy> > groupBy (<) [5,1,1,2,2,3,3,0,0]
09:21:29 <lambdabot>  [[5],[1],[1,2,2,3,3],[0],[0]]
09:21:35 <Jedai> lispy: It just happens that if the argument is an equivalence relation, both semantics gives the same result
09:21:44 <maltem> huh, logic without parens makes for confusing explanations
09:21:59 <MyCatVerbs> BMeph: and also doesn't like the idea of making use of things that fall out as a result of the particular way a given function is defined, rather than intrinsic properties of the job it's doing.
09:22:14 <monochrom> Yes maltem, verily.
09:22:20 <Jedai> > groupBy (<) [1, 4, 2, 3]
09:22:21 <lambdabot>  [[1,4,2,3]]
09:22:31 <Shiruka> unless the function is defined so that doing it in a particular way is part of its job :-)
09:22:36 <lispy> > groupBy (<=) . fix $ show
09:22:37 <lambdabot>  ["\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
09:22:59 <lispy> > map length . groupBy (<=) . fix $ show
09:23:00 <Jedai> @src span
09:23:00 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:23:02 <lambdabot>  [
09:23:09 <Jedai> @src Data.List.span
09:23:10 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:23:18 <lispy> Why did lambdabot say [?
09:23:20 <lispy> > map length . groupBy (<=) . fix $ show
09:23:27 <MyCatVerbs> BMeph: e.g. there are formulations of groupBy that're equivalent to the one given in Data.List but only if the predicate is required to be an equivalence.
09:23:27 <lambdabot>  [
09:23:38 <mauke> lispy: because that's how lists start
09:23:52 <MyCatVerbs> BMeph: for one thing, just flipping the arguments to eq! Doesn't that strike you as a little bit brittle?
09:24:14 <lispy> mauke: huh, so lambdabot is choking on that?
09:24:26 <mauke> lispy: er, you're trying to compute the length of an infinite string
09:25:16 <MyCatVerbs> BMeph: (moreso because groupBy is _documented_ in terms of group, which certainly requires an equivalence relation).
09:28:49 <MyCatVerbs> > let mySpan p l = case l of { [] -> ([],[]); aa@(a:as) -> if p a then let (front,back) = mySpan p as in (a:front,back) else ([],aa) } in mySpan isUpper "FOOBArbazFLEEP"
09:28:58 <ptolomy2> Wow. I was completely unaware of the upcoming Quasiquoting extension to GHC, but I just read the paper, and I'm pretty psyched.
09:29:00 <lambdabot>  ("FOOBA","rbazFLEEP")
09:29:31 <MyCatVerbs> oO
09:29:37 <lilachaze> oops, my bad :(
09:29:45 <MyCatVerbs> lilachaze: how did you achieve that?
09:30:10 <lilachaze> just running commands in /privmsg
09:30:23 <MyCatVerbs> Commands which dump like 40 lines of text each?
09:30:39 <lilachaze> well, i got the first 6 lines of each :/
09:30:58 <lilachaze> > groupBy (\a b -> b `mod` a /= 0) [1..]
09:31:07 <lambdabot>  [[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15],[16,17,18,19,20,21,22,23,24,25,...
09:31:53 <lispy> mauke: Okay, but I thought lambdabot usually dies without printing anything when that happens, so I was suprised to get just "["
09:32:04 <MyCatVerbs> That's an interesting one. Successive coprimes.
09:33:00 <lispy> > map length . groupBy (/=) . fix $ show
09:33:03 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
09:33:31 <mjrosenb> isn't group == groupBy (/=)
09:33:34 <lispy> > groupBy (/=) [1,1,2,2,3,3,0,0]
09:33:35 <lambdabot>  [[1],[1,2,2,3,3,0,0]]
09:33:36 * ptolomy2 wishes they'd have gone with the "[:re|(foo)|]" syntax for quasiquotations instead of "[$re|(foo)|]", but only sorta.
09:33:48 <lilachaze> mjrosenb: group == groupBy (==)
09:34:19 <mjrosenb> eruh, but the output that lispy was getting seems to indicate otherwise
09:34:34 <lispy> ?src group
09:34:35 <lambdabot> group = groupBy (==)
09:34:43 <lilachaze> > map length . groupBy (==) . fix $ show
09:34:46 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
09:35:00 <lispy> > map length . fix $ show
09:35:01 <xerox> ?oeis 1,1,1,3,1,7,1,15,1,31,1,63
09:35:01 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
09:35:02 <lambdabot> Expansion of (1+2x)/((1+x)(1-2x^2)).
09:35:02 <lambdabot> [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,1...
09:35:19 <mjrosenb> oh, i see
09:35:25 <lispy> lilachaze: so that groupBy (==) seems to be identity for this context
09:35:31 <MyCatVerbs> > let { takeDrop 0 l = ([],l); takeDrop n (l:ls) = if n < 0 then [] else let (f,b) = takeDrop (n-1) ls in (l:f,b); recTake _ 0 _ = []; recTake _ _ [] = []; recTake f n l = let (f,b) = takeDrop n l in f : recTake f (f n) l; } in recTake (*2) 1 [1..]
09:35:31 <lambdabot>  Couldn't match expected type `([a], [t])'
09:35:46 <DrSyzygy> > groupBy (==) [1,2,3,4]
09:35:47 <lambdabot>  [[1],[2],[3],[4]]
09:35:58 <DrSyzygy> > map (:[]) [1,2,3,4]
09:35:59 <lambdabot>  [[1],[2],[3],[4]]
09:36:20 <lispy> > groupBy (/=) [1,1,2,2,3,3,0,0]
09:36:21 <lambdabot>  [[1],[1,2,2,3,3,0,0]]
09:36:26 <lispy> > groupBy (/=) [3,1,2,2,3,3,0,0]
09:36:26 <lambdabot>  [[3,1,2,2],[3],[3,0,0]]
09:36:39 <MyCatVerbs> > let { takeDrop 0 l = ([],l); takeDrop n (l:ls) = let (f,b) = takeDrop (n-1) ls in (l:f,b); recTake _ 0 _ = []; recTake _ _ [] = []; recTake f n l = if n < 0 then [] else let (f,b) = takeDrop n l in f : recTake f (f n) l; } in recTake (*2) 1 [1..]
09:36:40 <lambdabot>  Couldn't match expected type `t -> t1' against inferred type `[t2]'
09:36:45 <MyCatVerbs> Oh, blast.
09:37:13 <lispy> > groupBy (/=) [2,1,2,2,3,3,0,0]
09:37:14 <lambdabot>  [[2,1],[2],[2,3,3,0,0]]
09:37:36 <lispy> so, groupBy (/=) splits at things equal to the first one?
09:38:28 <lispy> > groupBy (/=) [0,0,1,2,2,3,3,0,0]
09:38:29 <lambdabot>  [[0],[0,1,2,2,3,3],[0],[0]]
09:38:46 <lispy> I think I'm starting to understand it now
09:38:52 <lispy> > groupBy (<) [0,0,1,2,2,3,3,0,0]
09:38:54 <lambdabot>  [[0],[0,1,2,2,3,3],[0],[0]]
09:39:18 <lispy> ?check \xs -> groupBy (/=) xs == groupBy (<) xs
09:39:19 <lambdabot>  OK, passed 500 tests.
09:39:23 <lispy> Interesting
09:39:28 <lispy> ?check \xs -> groupBy (/=) xs == groupBy (>) xs
09:39:29 <lambdabot>  OK, passed 500 tests.
09:39:32 <MyCatVerbs> > let { takeDrop 0 l = ([],l); takeDrop n (l:ls) = let (f,b) = takeDrop (n-1) ls in (l:f,b); recTake _ 0 _ = []; recTake _ _ [] = []; recTake f n l = if n < 0 then [] else let (a,b) = takeDrop n l in a : recTake f (f n) l; } in recTake (*2) 1 [1..]
09:39:33 <lambdabot>  [[1],[1,2],[1,2,3,4],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,...
09:39:47 * MyCatVerbs should be shot for name-shadowing, it seems.
09:39:51 <xerox> ?check \xs -> groupBy (/=) xs == groupBy (>) (xs :: [Int])
09:39:52 <lambdabot>  Falsifiable, after 3 tests: [-2,1,3,-2]
09:40:05 <lispy> xerox: ah, thanks
09:40:09 <MyCatVerbs> Aka "whoops, foiled by obvious lexical scoping".
09:40:09 <xerox> np
09:40:16 <Jedai> ?src span
09:40:16 <lambdabot> Source not found. :(
09:40:25 <Deewiant> ?src break
09:40:25 <lambdabot> break p =  span (not . p)
09:40:28 <Deewiant> meh
09:40:48 <lilachaze> > splitAt 6 "Hello, world"
09:40:49 <lambdabot>  ("Hello,"," world")
09:41:19 <mauke> > groupBy ((==) `on` (==) ',') "Hello, world"
09:41:23 <lambdabot>  ["Hello",","," world"]
09:41:50 <MyCatVerbs> > let { recTake _ 0 _ = []; recTake _ _ [] = []; recTake f n l = if n < 0 then [] else let (a,b) = splitAt n l in a : recTake f (f n) l; } in recTake (*2) 1 [1..]
09:41:51 <lambdabot>  [[1],[1,2],[1,2,3,4],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,...
09:42:02 <MyCatVerbs> Hah, I forgot about splitAt? Failllll. :/
09:42:12 <lispy> ?check \xs -> groupBy (/=) xs == groupBy (<) (xs :: [Int])
09:42:13 <lambdabot>  Falsifiable, after 2 tests: [1,0]
09:42:21 <sal23> is there any fast random-access list in Haskell with O(1) access?
09:42:38 <Deewiant> > map (`take` [1..]) (iterate (*2) 1)
09:42:42 <lambdabot>  [[1],[1,2],[1,2,3,4],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,...
09:42:47 <mauke> sal23: you mean an array?
09:43:04 <sal23> mauke: no, array won't grow
09:43:13 <Deewiant> MyCatVerbs: eschew defining functions when the Prelude will do. :-)
09:43:28 <sal23> more like a vector
09:43:31 <mauke> sal23: sure it will, just create a new one
09:44:11 <sal23> mauke: well, array  is not as elegant as a list, like concatenation operations, is it?
09:44:23 <mauke> yes
09:44:32 <mauke> that's the price you pay for O(1) random access
09:44:40 <roconnor> sal23: I'd stick with O(log n)
09:44:44 <sal23> haha, yes, true
09:44:50 <MyCatVerbs> Deewiant: I insist that I just plum forgot. :(
09:45:01 <roconnor> O(leg n)
09:45:03 <geezusfreeek> to be fair, concatenation is not very efficient for lists either
09:45:11 <Deewiant> MyCatVerbs: no worries, it happens. :-)
09:45:11 <sal23> roconnor: I thought list access was O(n)
09:45:21 <Deewiant> sal23: Data.Sequence
09:45:23 <mauke> sal23: lists aren't the only non-array structure
09:45:29 <roconnor> sal23: Dat.Sequene has O(log n) access
09:45:55 <sal23> well, I see
09:45:57 <geezusfreeek> many list types, many array types
09:45:59 <geezusfreeek> choice is good
09:46:09 <sal23> haha....tyranny of choices
09:47:08 <roconnor> Data.Sequence makes a very good generic choice for non-lazy  ... um ... sequences.
09:47:36 <sal23> what choices do we have for lazy ones?
09:47:38 * ptolomy2 looks forward to the goodness that view patterns will give things like Sequence.
09:47:45 <roconnor> sal23: list :)
09:47:57 <mjrosenb> lispy: what have you done to me
09:47:59 <bd_> hmm
09:48:03 <roconnor> What can I do with view patterns that I can't do with pattern guards?
09:48:23 <bd_> is there a lazy sequence that allows access from both ends, even if it's infinite in length?
09:48:29 <bd_> not sure if that makes sense :)
09:48:37 <mauke> bd_: two lists
09:48:39 <roconnor> bd_:two lists
09:48:48 <mauke> one cup
09:48:59 <Deewiant> one tuple
09:49:05 <bd_> mauke: that won't let you consume from both ends for arbitrarily long without hitting the bottom
09:49:22 <mauke> why not?
09:49:24 <bd_> not sure if it'd be useful though
09:49:27 <bd_> hm
09:49:31 <bd_> actually you have a point there
09:49:43 <bd_> since the 'midpoint' would never be reached if both ends are infinite
09:49:51 <mjrosenb> let fact 0 _ = length . filter(==',') .show $ x; fact n x = fact (n-1) (replicate n x) in map fact [1..6]
09:49:59 <mjrosenb> >let fact 0 _ = length . filter(==',') .show $ x; fact n x = fact (n-1) (replicate n x) in map fact [1..6]
09:50:06 <Deewiant> mjrosenb: s/>/> /
09:50:12 <mjrosenb> bit better
09:50:13 <mjrosenb> oh
09:50:17 <mjrosenb> > let fact 0 _ = length . filter(==',') .show $ x; fact n x = fact (n-1) (replicate n x) in map fact [1..6]
09:50:18 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
09:50:18 <lambdabot>       Expected...
09:50:33 <mjrosenb> right, i needed to explicitly type that one
09:50:58 <mjrosenb> how on earth do i do that here?
09:51:11 <bd_> mjrosenb: (expression :: type)
09:51:31 <Deewiant> > let fact 0 x = length . filter(==',') .show $ x; fact n x = fact (n-1) (concat $ replicate n x) in map fact [1..6]
09:51:32 <lambdabot>  [<[()] -> Int>,<[()] -> Int>,<[()] -> Int>,<[()] -> Int>,<[()] -> Int>,<[()]...
09:51:35 <Deewiant> darn
09:52:56 <mjrosenb> whoops, forgot something in there
09:53:31 <mjrosenb> s/fact/(flip fact ())
09:54:12 <Deewiant> > let fact 0 x = length . filter(==',') .show $ x; fact n x = fact (n-1) (concat $ replicate n x) in map (flip fact [()]) [1..6]
09:54:12 <lambdabot>  [0,1,5,23,119,719]
09:54:18 <Deewiant> hmm
09:54:25 <Deewiant> @oeis [0,1,5,23,119,719]
09:54:25 <lambdabot> Sequence not found.
09:54:50 <Deewiant> hm, fail
09:54:54 <Deewiant> > let fact 0 x = 1 + length . filter(==',') .show $ x; fact n x = fact (n-1) (concat $ replicate n x) in map (flip fact [()]) [1..6]
09:54:55 <lambdabot>   add an instance declaration for (Num ([()] -> Int))
09:55:03 <Deewiant> > let fact 0 x = (1+) . length . filter(==',') .show $ x; fact n x = fact (n-1) (concat $ replicate n x) in map (flip fact [()]) [1..6]
09:55:04 <lambdabot>  [1,2,6,24,120,720]
09:55:09 <Deewiant> there we go
09:56:35 <lispy> mjrosenb: haha, why do you say that?
09:56:49 <nathanic> does anyone know if there is a standard function equal to (\(a, b) -> (b, a))  ?
09:57:03 <maltem> yes
09:57:05 <lispy> mjrosenb: trying to define well known math functions in terms of fix show?
09:57:06 <maltem> that is, yes, I know
09:57:19 <sal23> why not implement sequence using a data structure that allows O(1) insertion/deletion? any paper that explains the complications with that approach?
09:57:20 <nathanic> maltem: care to share? ;-)
09:57:21 <lispy> ?google (a, b) -> (b, a)
09:57:22 <lambdabot> http://www.bedandbreakfast.com/
09:57:22 <lambdabot> Title: Find Bed and Breakfast Inns and Book Online. Over 6,500 B&B's for vacation tra ...
09:57:23 <mjrosenb> lispy: perhaps
09:57:24 <lispy> er
09:57:29 <lispy> ?hoogle (a, b) -> (b, a)
09:57:29 <maltem> nathanic: there isn't
09:57:29 <mjrosenb> lispy: or fix foo
09:57:29 <lambdabot> No matches, try a more general search
09:57:49 <roconnor> lispy: It isn't in the standard lib. :(
09:57:50 <mjrosenb> lispy: or in this case a polymorphic function
09:57:54 <roconnor> lispy: I call it swap
09:58:00 <nathanic> maltem: thanks
09:58:20 <lispy> mjrosenb: fix is a pretty cool.  For more interesting applications of fix check out Oleg's paper on implementing OO in Haskell
09:58:22 <roconnor> @djinn swap :: (a,b) -> (b,a)
09:58:22 <lambdabot> Cannot parse command
09:58:30 <roconnor> @djinn (a,b) -> (b,a)
09:58:30 <lambdabot> f (a, b) = (b, a)
09:58:42 <mjrosenb> :t head . zipWith flip . unzip . (:[])
09:58:44 <lispy> mjrosenb: they implement method invocation via fix!
09:58:53 <maltem> "swap" is a pretty common name for \(a,b) -> (b,a)
09:58:53 <chrisdone> I think fix is a pretty cool guy, eh computes fixpoint and doesn't afraid of anything
09:59:01 <nathanic> maltem: yeah, i called mine swap
09:59:17 <lispy> To match fst and snd it should be swp ;)
09:59:28 <Deewiant> I went the verbose way and called it tupleFlip
09:59:33 <ziman> > map (truncate . (/ log 2) . log . genericLength) . groupBy (<) . fix $ show
09:59:48 <lambdabot>  thread killed
09:59:51 <Deewiant> ?ty truncate
09:59:52 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
09:59:52 <nathanic> :t snd &&& fst
09:59:53 <lambdabot> forall a b. (a, b) -> (b, a)
10:00:21 <roconnor> Deewiant: you should have gone all the way and called it uncurryFlipPair :)
10:00:33 <mjrosenb> adios, work
10:00:48 <Deewiant> > length "\(a,b)->(b,a)" <= length "uncurryFlipPair"
10:00:49 <lambdabot>  Illegal escape sequence at ""\(a,..." (column 8)
10:00:51 <lispy> snd &&& fst is a cool way to implement swap, but it's a bit conceptually heavy :)
10:00:53 <Deewiant> > length "\\(a,b)->(b,a)" <= length "uncurryFlipPair"
10:00:56 <lambdabot>  True
10:01:01 <Deewiant> roconnor: and that's why not. :-P
10:01:08 <roconnor> :D
10:01:12 <mauke> :t uncurry (flip (,))
10:01:14 <lambdabot> forall b a. (a, b) -> (b, a)
10:01:40 <lispy> such pretty bike sheds today
10:01:43 <roconnor> actually, there are two possible implemenations of swap.
10:01:52 <nathanic> \(a,b) -> (b,a) is probably the clearest way to write it, but the (&&&) method just occurred to me
10:02:10 <Deewiant> and then there's the uncurry (flip (,))
10:02:33 <roconnor> > (\(a,b) -> (b,a)) undefined
10:02:34 <lambdabot>  Exception: Prelude.undefined
10:02:44 <roconnor> > (snd &&& fst) undefined
10:02:46 <lambdabot>  (Exception: Prelude.undefined
10:02:56 <roconnor> notice the different results
10:02:57 <Deewiant> oo
10:03:02 <mauke> > (\~ (a,b) -> (b,a)) undefined
10:03:03 <lambdabot>  Parse error at "->" (column 11)
10:03:03 <lispy> > (uncurry (flip (,))) undefined
10:03:04 <lambdabot>  (Exception: Prelude.undefined
10:03:08 <mauke> > (\ ~(a,b) -> (b,a)) undefined
10:03:09 <lambdabot>  (Exception: Prelude.undefined
10:03:19 <Deewiant> ?pl \(a,b) -> (b,a)
10:03:19 <lambdabot> uncurry (flip (,))
10:03:33 <Deewiant> oh noes, ?pl is changing the laziness of a function
10:03:43 <chrisdone> (snd && fst) is lovely
10:03:47 <roconnor> (uncurry (flip (,))) undefined
10:03:54 <roconnor> > (uncurry (flip (,))) undefined
10:03:56 <maltem> Now, where is the philosopher to tell use which is the correct implementation?
10:03:57 <lambdabot>  (Exception: Prelude.undefined
10:04:02 <maltem> s/use/us
10:04:14 <roconnor> maltem: maybe this is why it isn't in the standard :)
10:04:18 <lispy> There should be something similar to (snd &&& fst) using Reader (->)
10:04:56 <maltem> roconnor, probably :)
10:04:59 <lispy> maltem: hence my comment about the pretty bike sheds today :)
10:05:31 <mauke> :t liftM2 (,) (asks snd) (asks fst)
10:05:32 <lambdabot> forall (m :: * -> *) a b. (MonadReader (a, b) m) => m (b, a)
10:05:32 * nathanic just read that piece about bike sheds yesterday, and is perhaps a bit too pleased to get the reference
10:05:36 <roconnor> > (\x -> let (a,b) = x in (b,a)) undefined
10:05:37 <lambdabot>  (Exception: Prelude.undefined
10:05:50 <mauke> > liftM2 (,) (asks snd) (asks fst) (1,'2')
10:05:51 <lambdabot>  ('2',1)
10:05:59 <mauke> lispy: happy? :-)
10:06:03 <Deewiant> > liftM2 (,) (asks snd) (asks fst) undefined
10:06:04 <lambdabot>  (Exception: Prelude.undefined
10:06:09 <maltem> lispy: um, sorry, how did that joke work?
10:07:29 <lispy> maltem: ah, let me see if I can find the story
10:08:21 <lispy> maltem: http://www.freebsd.org/doc/en_US.ISO8859-1/books/faq/misc.html#BIKESHED-PAINTING
10:08:22 <lambdabot> Title: Miscellaneous Questions, http://tinyurl.com/5ewb4
10:08:42 <lilachaze> > let swap = on (&&&) uncurry =<< flip $ const in swap (42,123)
10:08:43 <lambdabot>  (123,42)
10:08:57 <Deewiant> > let swap = on (&&&) uncurry =<< flip $ const in swap undefined
10:08:58 <lambdabot>  (Exception: Prelude.undefined
10:10:26 <lispy> mauke: always
10:10:51 <lispy> Is anyone working on a type check/inference visualizer?
10:11:13 <lispy> That would be a really valuable tool for the stuff I'm working on
10:11:29 <maltem> lispy: ah, having read that, I now remember already having read/heard this metaphor somewhere :)
10:11:48 <roconnor> @type on (&&&) uncurry
10:11:48 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b -> c) -> (a, b) -> (c, c)
10:15:31 <ddarius> If you want swap . swap = id then you want the strict version.
10:16:45 <lispy> ?check \p -> ((snd &&& fst) . (snd &&& pst)) p == id p
10:16:46 <lambdabot>   Not in scope: `pst'
10:16:53 <lispy> ?check \p -> ((snd &&& fst) . (snd &&& fst)) p == id p
10:16:55 <lambdabot>  OK, passed 500 tests.
10:18:38 <ziman> ?check \p -> ((), ()) == p
10:18:40 <lambdabot>  OK, passed 500 tests.
10:18:43 <ziman> :)
10:19:34 <roconnor> ?check \p -> (snd &&& fst) p == id p
10:19:34 <lambdabot>  OK, passed 500 tests.
10:19:45 <Deewiant> ?check \p -> ((snd &&& fst) . (snd &&& fst)) p == id (p :: (Int,Char))
10:19:47 <lambdabot>  OK, passed 500 tests.
10:19:55 <EvilTerran> @check uncurry (==)
10:19:56 <lambdabot>  OK, passed 500 tests.
10:20:16 <Deewiant> @check (==())
10:20:17 <lambdabot>  OK, passed 500 tests.
10:20:32 <lispy> :t uncurry (==)
10:20:32 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
10:20:36 <mauke> @check (==)
10:20:37 <lambdabot>  OK, passed 500 tests.
10:20:46 <lispy> Wait
10:20:49 <lispy> Really?
10:20:57 <lispy> That's just messed up
10:21:06 <roconnor> someone turn off extended defaulting for @check
10:21:11 <roconnor> please
10:21:11 <lispy> :(
10:21:17 <mauke> @check (==) `asTypeOf` (+)
10:21:18 <lambdabot>   add an instance declaration for (Num Bool)
10:21:22 <Deewiant> someone fix \bot in general
10:21:24 <mauke> oh, right
10:21:27 <Deewiant> @scheck (==)
10:21:27 <lambdabot>     Failed to load interface for `SmallCheck':
10:21:27 <lambdabot>       Use -v to see a list of ...
10:21:32 <lispy> ?check \a b -> a == b
10:21:33 <lambdabot>  OK, passed 500 tests.
10:21:36 <Deewiant> ?ty \f n -> f f n
10:21:37 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
10:22:24 <ziman> ?check \x y -> !(x && y) == (!x || y)
10:22:24 <lambdabot>  Parse error at "!(x" (column 9)
10:22:26 <lispy> ?scheck (==)
10:22:26 <lambdabot>     Failed to load interface for `SmallCheck':
10:22:26 <lambdabot>       Use -v to see a list of ...
10:22:33 <ziman> ?check \x y -> not (x && y) == (not x || y)
10:22:34 <lambdabot>  Falsifiable, after 0 tests: True, True
10:23:57 <lilachaze> @check \x y -> not (x && y) == not x || not y
10:23:58 <lambdabot>  OK, passed 500 tests.
10:24:28 <Deewiant> @check \x y -> (not (x && y) == not x) || not y
10:24:29 <lambdabot>  OK, passed 500 tests.
10:25:25 <ziman> @check (==0)
10:25:26 <lambdabot>  Falsifiable, after 0 tests: -2
10:26:29 <EvilTerran> as roconnor said, it's the extended defaulting that makes stuff like @check (==) work
10:26:49 <EvilTerran> (==) :: Eq a => a -> a -> Bool -- a is defaulting to (), which is baaaad
10:26:54 <Deewiant> defaulting Eq a => a to () is crap
10:27:06 <bd_> Deewiant: what should it default to?
10:27:10 <EvilTerran> Deewiant, indeed, seeing as it's possibly the worst possible example of Eq
10:27:10 <bd_> @check (==)
10:27:11 <lambdabot>  OK, passed 500 tests.
10:27:13 <EvilTerran> defaulting to Int(eger) would probably make more sense
10:27:27 <Deewiant> bd_: well, something for which _ == _ = True does not hold :-P
10:27:27 * lispy agrees with EvilTerran 
10:27:43 <EvilTerran> Deewiant, i suspect (==) for () is at least strict
10:27:46 <EvilTerran> i may be wrong, though
10:27:50 <EvilTerran> ?src () (==)
10:27:50 <lambdabot> () == () = True
10:27:53 <EvilTerran> yeah
10:27:57 <mauke> > () == undefined
10:28:07 <Deewiant> meh, I just typed _ because it's shorter
10:28:09 <lambdabot>  Exception: Prelude.undefined
10:28:15 <EvilTerran> Deewiant, heh, fair enough :P
10:28:35 <EvilTerran> Deewiant, yours is a refinement of the report definition, it's still correct! :P
10:28:40 <Deewiant> :-P
10:40:24 * ronwalf blows the context stack
10:40:42 * lispy pushes fuzzy bunnies on the context stack
10:45:36 <ronwalf> lispy: These are more like were-rabbits
10:45:53 <ihope> Haskell: The only language (that I know of) where you can break out of a loop while not inside it, despite not actually having a loop construct.
10:46:08 * ronwalf is haskell-newby-way-out-of-his-league-man
10:46:11 <ihope> Ello ello.
10:46:14 <lispy> ihope: example?
10:46:49 <ihope> lispy: well, with continuations, you can implement a loop function. Let me try to come up with it...
10:46:58 <Toxaris> breaking out of something you're not inside in sounds like continuations
10:47:06 <Toxaris> so scheme should be easily up to the task
10:47:13 <Deewiant> and can this not be done in... yeah, lisp
10:47:25 <Deewiant> or any language with continuations
10:47:27 <ihope> Yeah, I guess any language with continuations is likely to be able to do it.
10:47:54 <Toxaris> imho Haskell is not a "language with continuations"
10:48:04 <ihope> You can certainly implement them in Haskell.
10:48:15 <pozic> They are not the same.
10:48:28 <Toxaris> you can implement state monads in Haskell, but Haskell is not a language with mutable state, is it?
10:48:50 <pozic> Toxaris: Haskell + ST can be considered that.
10:49:28 <mmorrow> Toxaris: it depends if you mean "Haskell is not a language with mutable state", or Haskell is not a language with mutable state
10:49:31 <Toxaris> imho "language with continuations" means that you can capture the "current continuation" as a first-class value and pass it around at will, maybe calling it later, maybe not
10:50:02 <ihope> Let me think, the type would be ((a -> m b) -> (a -> m b) -> m a) -> a -> m a, "b" actually meaning "forall b. b", I think.
10:50:30 <pozic> Toxaris: you are aware of callCC in Haskell, right?
10:50:37 <ihope> The first argument is the inside of the loop, the second argument is the initial value the loop starts on. The first argument to the inside is break, the second is continue.
10:50:50 <Toxaris> pozic: I'm only aware of callCC in the Cont monad, is there a general callCC in Haskell?
10:51:00 <pozic> Toxaris: no, there isn't. Just checking.
10:51:09 <puusorsa> haskell needs please...come from
10:51:14 <puusorsa> like intercal
10:51:25 <puusorsa> especially nice in the threaded version
10:51:39 <osfameron> just write a nice comefrom monad and everyone will be happy
10:51:50 <ihope> Oh, the inside also needs to take the loopy value, of course.
10:52:17 <ihope> Eh, I'd rather leave that out, actually. (m b -> m b -> m a) -> m a.
10:52:57 <Toxaris> pozic: supporting continuations through a global transformation is easy in a language with first-class functions. CPS transform and you're done. I see transforming my code into monadic form to allow it to run in the Cont monad as similiar to a manual CPS
10:53:25 <Toxaris> pozic: imho clearly, a language with real support for continuations is something else as "you can CPS transform manually if you wish"
10:53:31 <glguy_> What is the extension to use GADT syntax with regular data-types?
10:53:48 <pozic> glguy_: where
10:53:56 <ihope> Try this, then: loop inside = callCC (\break -> callCC (\continue -> inside break continue) >> loop inside)
10:54:26 <pozic> Toxaris: yes, so why do you use Haskell?
10:54:50 <Toxaris> pozic: because it is the best language I know for many problems
10:55:19 <Toxaris> pozic: who needs callCC? It's a all-too-powerful feature destroying all your reasoning about what's going on
10:55:53 <Toxaris> pozic: but still, ihope claiming that Haskell is cool because of it's special support for continuations, when there isn't any, seems not correct to me
10:56:47 <ihope> What I said was that in Haskell, you can break out of a loop while not inside of it, despite Haskell not having certain built-in facilities for doing so.
10:57:44 <Toxaris> ihope: yeah i paraphrased for pozic, to make it clear that I disagree with a single statement of yours, not you in general, or Haskell, or static typing or whatever
10:57:56 * ptololmy2 needs to get intimate with Cont
10:58:10 * ihope shrugs
10:59:05 <Toxaris> bla bla bla, but I agree that Haskell is cool.
10:59:09 <ihope> Well, that loop function has kind of an unexpected type: ((a -> m b) -> (a1 -> m b1) -> m a1) -> m a. The break function causes the loop to exit immediately, so its type makes sense; the continue function goes back to the beginning, so I guess I'm actually surprised that it should take an argument at all.
10:59:12 <pozic> How I have a GTK2HS hello world application that can be closed with a button, instead of the cross in the right top?
10:59:41 <pozic> This page shows example code, but the quit button does not work in ghci: http://home.telfort.nl/sp969709/gtk2hs/chap3-3.html
10:59:42 <lambdabot> Title: Gtk2Hs Tutorial: Packing Using Tables
11:00:15 <soduko> does anyone know of a haskell module to parse .ini config files? similar in funciton to ConfigObj of python?
11:00:46 <ihope> It does make sense given the implementation, I guess, but that value will never go anywhere. So replace "inside break continue" with "inside break (continue undefined)" and everyone will be happy, I think.
11:01:08 <dcoutts_> pozic: in ghci, the issue can be that control returns to ghci before the command to the X system has flushed, so you don't see the window close
11:01:12 <olsner> soduko: I rolled my own in a few lines with parsec... wait a bit and I can hpaste it
11:01:24 <soduko> olsner, thanks a lot
11:01:35 <pozic> dcoutts_: Gnome says "the window does not respond".
11:01:42 <olsner> (or wait a possibly unbounded time while I extract a module for it and put it on hackage)
11:01:51 <dcoutts_> pozic: yes because gtk+ is no longer running, ghci is
11:01:51 <Toxaris> ihope: you could provide an initial value, and use >>= instead of >>
11:02:00 <pozic> dcoutts_: the cross does work, so they don't do the same thing.
11:02:01 <olsner> (there could also be a module for that on hackage already)
11:02:10 <ihope> Toxaris: there's already a monad to do that, but yes, that would be useful.
11:02:11 <Toxaris> ihope: so that with continue, on would "assign to" the threaded-through value
11:02:16 <pozic> dcoutts_: is there a solution?
11:02:24 <soduko> olsner, i couldnt find any
11:02:29 <Toxaris> ihope: so you would implement more like for then a while loop
11:02:35 <dcoutts_> pozic: try using flush after mainGUI
11:02:57 <dcoutts_> pozic: you're using something like onClicked button mainQuit right?
11:03:19 <pozic> dcoutts_: yes, just trying to get the example working completely first, before I modify it.
11:03:53 <pozic> dcoutts_: I still have the previous version installed. Is there any point in upgrading?
11:04:19 <pozic> dcoutts_: and why isn't it on Cabal?
11:04:24 <dcoutts_> pozic: not unless you're hitting bugs that are fixed in the later version
11:04:43 <dcoutts_> pozic: it's a complex package, we need more Cabal features to be able to use Cabal for gtk2hs
11:05:13 <ihope> loopS inside val = callCC (\break -> callCC (\continue -> inside break continue val) >>= loopS inside); loopS :: ((a -> m b) -> (a1 -> m b1) -> a1 -> m a1) -> a1 -> m a
11:05:14 <pozic> dcoutts_: is there a configuration file for cabal install?
11:05:57 <dcoutts_> pozic: see, the issue is, graphics actions are not synchronous. Gtk+ functions get turned into commands that get sent to the X server over a pipe. So we often build up a buffer of actions and send them in batches. So what you're seeing is that Gtk+ returns to ghci before all the X commands have been flushed and sent to the X server.
11:06:05 <dcoutts_> pozic: yes, ~/.cabal/config
11:07:03 <monochrom> asynchrony fun
11:08:27 <pozic> dcoutts_: why doesn
11:08:35 <pozic> dcoutts_: 't mainQuit do that already?
11:08:55 <dcoutts_> pozic: I'm actually just adding it to mainGUI
11:09:07 <dcoutts_> pozic: it's only a problem in ghci, not for a main prog
11:09:41 <dcoutts_> pozic: so does that work for you now?
11:11:15 <pozic> dcoutts_: still doesn't seem to work.
11:11:43 <pozic> dcoutts_: onClicked button3 (do mainQuit;flush)
11:11:43 <ihope> Have a proper for loop, even: forLoop inside (x:xs) = callCC (\break -> callCC (\continue -> inside break continue (x:xs) >> return xs) >> forLoop inside xs); forLoop :: ((a -> m b) -> ([t] -> m b1) -> [t] -> m a1) -> [t] -> m a
11:11:53 <dcoutts_> pozic: no, after mainGUI
11:12:00 <pozic> dcoutts_: I already tried that before.
11:12:07 <pozic> dcoutts_: that was my first idea.
11:12:18 <ihope> Except the argument to the inside is the entire remaining list, not just the head, and the only way to stop looping is with break.
11:12:31 <dcoutts_> pozic: in that case I don't know
11:12:31 <pozic> dcoutts_: in fact, both statements where still there.
11:12:39 <pozic> were*
11:12:48 <olsner> @seen hpaste
11:12:48 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
11:12:58 <olsner> soduko: http://hpaste.org/9291
11:13:01 <dcoutts_> pozic: wait, you're not actually closing the window are you, just quitting main
11:13:08 <dcoutts_> pozic: that's the problem
11:13:10 <olsner> it has a few quirks, but you'll notice those eventually :D
11:14:00 <pozic> dcoutts_: yes, I am just pressing the button to call mainQuit.
11:14:08 <olsner> for example, it uses '#' for comments rather than ';'
11:14:12 <dcoutts_> pozic: right and that does not close any windows
11:14:51 <mmorrow> ihope: somewhat related: http://hpaste.org/9292
11:15:07 <pozic> dcoutts_: ok, I will look in the API to see whether I can find something that does that. In the meanwhile, how can I put a Chart (c.f. chart library) in a gtk window?
11:15:37 <ihope> Looks complicated. :-)
11:15:53 <dcoutts_> pozic: use widgetDestroy or widgetHide
11:15:54 <pozic> dcoutts_: chart uses the Render monad, so there must be some way to convert a Render monad into something that can be attacked to a window.
11:16:18 <dcoutts_> pozic: yes, see the demo/cairo/CairoGhci.hs
11:16:52 <pozic> dcoutts_: other than these problems GTK2HS seems fairly straightforward to use.
11:17:01 <mmorrow> ihope: yeah, that's about revision 10 and +2 months from first understanding shift enough to do anything with it
11:17:11 <pozic> dcoutts_: the tutorial is great (the one on telford.nl)
11:17:37 <soduko> olsner: thanks, i will go through this example and see what i can use from it.
11:17:40 <soduko> thanks a lot
11:18:44 <olsner> soduko: fix the bugs and put it on hackage :D
11:19:42 <pozic> dcoutts_: doesn't widgetHide only hide it, so that some process is still running?
11:20:18 <pozic> dcoutts_: never mind
11:20:26 <dcoutts_> pozic: it hides it without destroying it, yes. Nothing is still running however.
11:20:50 <mmorrow> ihope: this is really all that's happening, and once i realized this i "got" it: http://hpaste.org/9292#a1
11:20:54 <dcoutts_> pozic: it lets you re-use the same window without re-constructing it. So it depends what you want/need.
11:21:40 <pozic> dcoutts_: I am not following you.
11:22:04 <pozic> dcoutts_: hiding would seem to be flipping a bit so that you cannot see it anymore, but is still in memory.
11:22:12 <dcoutts_> pozic: if you have a reference to the window then you can still use it, even if the gtk+ main loop finishes, since you can always start it up again.
11:22:21 <olsner> isn't (return . (+1) =<<) just fmap (+1)?
11:22:27 <dcoutts_> pozic: yes exactly, hiding does not destroy it
11:22:35 <olsner> or (add 1 <$>)
11:22:49 <Deewiant> ?ty (return . (+1) =<<)
11:22:50 <lambdabot> forall (m :: * -> *) a. (Num a, Monad m) => m a -> m a
11:22:54 <mmorrow> olsner: 6 or half a dozen
11:22:56 <Deewiant> apparently so
11:23:01 <pozic> dcoutts_: but how would hiding make the application completely end then?
11:23:18 <olsner> mmorrow: surely it's sum [1,2,3]!
11:23:43 <dcoutts_> pozic: it would not, but your application is not ending completely, you've still got ghci running and may have references to objects you created earlier, which you can then re-use.
11:24:10 <mmorrow> olsner: if you told a baker that, he'd probably assault you with icing
11:24:20 <mmorrow> shift (\k -> return x) === callCC (\k -> k x) === callCC (\k -> return x)
11:24:21 <dcoutts_> pozic: the thing to realise is, the main loop running just relates to responding to user input, it has nothing to do with windows or other widgets being created or destroyed.
11:24:57 <mmorrow> shift (\k -> k x) >>= f     ===   f x
11:25:12 <olsner> mmmm, icing :)
11:25:12 <mmorrow> shift (\k -> k x >>= k) >>= f     ===   f x >>= f
11:25:32 <dcoutts_> pozic: widgets are created when you use fooNew, and they're destroyed when they're no longer needed by anything else (ie garbage collected). The one exception is top level windows which must be destroyed explicitly when you no longer want them.
11:26:02 <dcoutts_> pozic: does that make any sense?
11:26:29 <dcoutts_> pozic: just because mainGUI finishes doesn't mean your application has terminated.
11:27:11 <pozic> dcoutts_: I would expect that when mainGUI finishes that there are no more windows on the screen.
11:27:28 <dcoutts_> pozic: you'll have to change your expectations.
11:27:37 <monochrom> haha
11:28:28 <monochrom> There are two kinds of people, those who expect synchrony and those who expect asynchrony.
11:28:54 <monochrom> Do not think that the latter is in the minority. Actually I think they are in the majority.
11:30:51 <monochrom> Dad and Mom tell kid: "take this bag of garbage outside".  Dad and Mom are so not waiting for kid to finish; they attend their own matters meanwhile.  Asynchrony is real-world and intuitive.
11:30:53 <dcoutts_> pozic: you're thinking about it as if it were like main, really it's just play/pause on the gtk+ system.
11:32:00 <dcoutts_> pozic: when you start up, gtk+ is paused, when you use mainGUI it's playing, when that finishes it's paused again. If you run mainGUI again then it plays again.
11:32:05 <monochrom> Only a minority, who become programmers, think like while the kid is still working the "next statement" must not begin.
11:32:17 <pozic> dcoutts_: yes, completely clear.
11:32:24 <pozic> dcoutts_: thanks, you should post this somewhere.
11:33:20 <olsner> but asynchronous software is a pain to write
11:33:50 <RayNbow> @seen conal
11:33:50 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
11:33:56 <dcoutts_> one can write somewhat asynchronous code in Haskell in what looks like a single threaded style
11:33:59 <monochrom> That's a self-fulfilling prophecy, as implied by what I said.
11:34:31 <dcoutts_> eg with XCB you can do: result <- command; somethingElse; use result
11:34:44 <dcoutts_> and it only blocks waiting for the result when it gets used
11:34:47 <olsner> yeah, if you have continuations or something equivalent you can write synchronous code that runs asynchronously
11:35:18 <monochrom> There is a minority of people who can't stand asynchrony.  Since the real world is asynchonous they take refuge in computing, inventing exclusively synchronous languages and indulging in it.  Now suddenly you ask them to do asynchrony?  Of course they say it's painful.
11:36:15 <EvilTerran> i don't think that's entirely the fault of the minority who can't stand asynchrony
11:36:39 <soduko> olsner: if i get it to work,  i will try to fix any bugs i can identify.
11:36:40 <EvilTerran> even folk who don't mind asynchrony will tend to find synchony easier to reason about
11:36:41 <monochrom> I am not saying fault either.
11:36:57 <EvilTerran> i mean the "inventing exclusively synchronous languages" bit
11:37:09 <pozic> monochrom: do you happen to know this minority and does this give you a bias to bring up this point? ;)
11:37:11 <monochrom> Dad and Mom clearly finds asynchrony easier to reason about.
11:37:19 <soduko> i will need to write more parsers etc,, and falling back on python is the easy way for me. but if i get this working, i will have something to start with :)
11:37:40 <EvilTerran> monochrom, not easier, just easy enough in that one circumstance to be worth the extra effort
11:38:07 <mauke> preflex: seen conal -- RayNbow
11:38:07 <preflex>  conal was last seen on #haskell 6 hours, 16 minutes and 48 seconds ago, saying: does anyone here know how it is that the haskell wiki understands <haskell> and <hask>?  i'd like to tweak another mediawiki to do the same.
11:38:10 <EvilTerran> (namely, the effort of remembering roughly where their kid is
11:38:12 <monochrom> Dad and Mom says asynchrony is dead easy.  Just tell the kid to do stuff.  If the kid doesn't do it in good time, just beat him/her up.
11:39:03 <EvilTerran> compare everyone sitting in a room, only one leaving at a time to do anything. you only ever need to pay attention to the location of one person at any one  time
11:39:22 <mauke> also, preflex++
11:39:22 <monochrom> Now bring Dad and Mom's method to computing. Since computers are so much more reliable and obedient, you can even skip the "if not in good time, beat up" part.  Just tell the computer to do stuff, end of story.  Asynchony is that easy.
11:39:28 <EvilTerran> making it easier to reason about, eg, the possibility of communication between differen family members
11:39:45 <EvilTerran> but much more tedious
11:40:13 <EvilTerran> only thinking about one thing at a time is invariably simpler. just more time consuming.
11:40:22 <Gwern-away> @tell conal I don't know if anyone told you, but mediawiki uses a plugin for Geshi http://www.mediawiki.org/wiki/Extension:SyntaxHighlight_GeSHi
11:40:22 <lambdabot> Consider it noted.
11:40:31 <EvilTerran> people don't want their computers to do things concurrently, they want them to do them instantaneously
11:41:12 <EvilTerran> and i find people tend to think of their computer as working instantaneously
11:41:17 <EvilTerran> and get frustrated quickly when it doesn't
11:41:21 <monochrom> EvilTerran: What you say is what the minority, the nerds, think.  Ask an "average person on the street" and he/she will say, "why would several people sit around waiting for just one? this is weird."
11:41:44 <EvilTerran> monochrom, ok, i stretched the analogy too far
11:41:50 <Gwern-away> several people waiting for one person is a very common thing in real life
11:42:03 <EvilTerran> ... anyway, interfaces try to give the impression of acting instantly by acting concurrently with waiting for more input
11:42:22 <EvilTerran> but that doesn't mean anyone, including the user, wants to think about this concurrent aspect
11:42:24 <Toxaris> I know a number of people (all girls, actually), who think of computers as being completely occupied in the time between user interaction and user interface response, but completely unoccupied after the user interface response
11:42:56 <EvilTerran> Toxaris, that's a simple model, and works most of the time
11:43:07 <Philippa_> Gwern-away: but normally in the sense that you get bottlenecks anyway
11:43:20 <EvilTerran> as long as you know it's not actually true, it's a useful approximation
11:43:27 <Toxaris> I do now, they don't :)
11:43:35 <EvilTerran> aye, there's the rub
11:43:54 <Philippa_> Toxaris: you almost certainly know guys who think that way too, y'know. It's also not a bad approximation if your use model is a bunch of low-intensity background stuff plus one 'real application'
11:44:23 <EvilTerran> a good interface would try to maintain that illusion as far as possible, i think
11:44:57 <EvilTerran> although "interface response" would be better stated as "the interface indicating completeness" for that
11:45:55 <jkff> Hi people. I've got a category theory question: We all know the Set category. Now consider the Val category, where objects are all elements of all sets and arrows between x and y are facts 'f(x) = y where x::A, y::B', A and B being sets and f being a function A -> B. Does the relationship between Set and Val have a special name?
11:46:18 <EvilTerran> seeing as progress bars and hourglasses and things may be involved occasionally
11:47:35 <Toxaris> Philippa_: I'm not actually sure why I inserted the comments about girls, but anyway, I consider that a good model in contrast to "people want computers to do things instantaneously" as observed by EvilTerran
11:48:12 <EvilTerran> Toxaris, i was speaking of what people want rather than what people imagine to be reality
11:48:27 <EvilTerran> either way, both our approaches are single-threaded
11:48:41 <Toxaris> Philippa_: so it was not meant to be against girls or whatever. nonetheless, that is exactly how it reads :(
11:49:31 <mmorrow> jkff: i'm not clear what the "Val" category is
11:49:49 <Toxaris> EvilTerran: In my experience, that is closely related with respect to computers, because of the "computers are allmighty"-marketing hype
11:50:02 <jkff> For example, it has an object '2' and an object '4', and one of the arrows between them is 'square(2) = 4'
11:50:02 <EvilTerran> Toxaris, yeah, true
11:50:17 <jkff> One more is '2 + 2 = 4'
11:50:32 <EvilTerran> Toxaris, although they only say that because it's what people want.  i guess it's kinda circular in that respect.
11:50:33 <jkff> It may be seen as 'exploding' the Set category
11:50:42 <monochrom> I want to remind you to be aware of self-fulfilling prophecies and vicious cycles, using Toxaris's model as an example.  It's a successful model.  But why is it a successful model and why do people expect it?
11:50:55 <jkff> One more is '(const 4) 2 = 4', etc.
11:51:09 <jkff> Also, 2 :: Int and 2 :: Real are considered to be different objects
11:51:19 <ksandstr> jkff: ... besides A being the domain and B being the codomain, both of function f?
11:51:42 <jkff> ksandstr: Sorry, I don't quite understand your question
11:51:50 <mmorrow> jkff: is there an arrow like f({x,{{y,x},{,z,{{a,b},b,c}}}) = f({p,q})  for instance ?
11:51:59 <monochrom> Existing computers behave that way more or less, that is why people who have experienced computers also expect it more or less.  But again, why do existing computers behave that way?  I say it's because some nerd made it that way to begin with.
11:52:08 <jkff> Emm.. I think not
11:52:29 <jkff> Val is the category of values and functions that take one value to an other
11:52:39 <mmorrow> jkff: because i don't know what to think given the "where objects are all elements of all sets"
11:52:42 <jkff> Set is the category of sets as a whole, whereas Val is the category of their elements
11:52:43 <monochrom> Suppose you take a clean slate, who hasn't experienced existing computers, and ask him/her what should be expected of computers.  It is unclear he/she expects the same model.
11:52:48 <ksandstr> jkff: it just sounded like a very basic question, so I figured... sorry, I stopped reading that ct book when it started talking about foomorphisms
11:52:51 <jkff> Objects are simply all values
11:52:54 <mmorrow> jkff: because sets can have as elements other sets
11:53:00 <monochrom> Or would want to invent a computer under that model.
11:53:04 <jkff> All values, including sets, too.
11:53:22 <halberd> is it good practice to rename types that you use in your program, like type Min = Int, type Max = Int, so that your functions have more descriptive type signatures?
11:53:24 <mmorrow> jkff: but the there could exists an f like f({x,{{y,x},{,z,{{a,b},b,c}}}) = f({p,q}
11:53:28 <mmorrow> s/the/then
11:53:52 <jkff> There could exist such an f for which this equation is true, but this equation is not an arrow of the Val category
11:54:07 <jkff> An arrow in Val between x and y is a function f such that f(x) = y
11:54:14 <Gwern-away> I think if you presented a single computer, synchronous is most natural
11:54:33 <Toxaris> I think the obvious model for computers is the human brain
11:54:34 <maltem> halberd: That should probably type Bound = Int, because otherwise you have opposite vocabulary referencing the same thing
11:54:51 <Gwern-away> 'of course it's synchronous, it's just one computer running by itself. the processor is determinitic and mechanical, you've explained to me in detail'
11:54:55 <halberd> yes maltem I just mean to name the arguments
11:54:58 <jkff> I introduced extra syntax only to distinguish 2::Int and 2::Real
11:54:59 <Toxaris> consider e.g. early ideas about robots in science fiction
11:55:13 <halberd> so that if you have a function f :: [Int] -> Min -> Max -> [Int] then you know which is the min and which is the max
11:55:13 <ksandstr> halberd: I haven't an opinion on simple types, but for parameterized types and tuples and the like aliases do add to readability
11:55:24 <Gwern-away> but if you present it as a network where you are bound to one computer, then nondeterminism makes more sense. 'Well, how do I know what's going on over there? that other computer could be doing anything'
11:55:41 <maltem> halberd: I must admit I haven't anyone use type synonyms like that
11:55:43 <jkff> Now I see that it would be better to say that an object of Val is a pair (S, x) where x is an element of S
11:55:50 <maltem> halberd: More common are things like type Name = String
11:55:51 <halberd> self-documents itself more than f :: [Int] -> Int -> Int -> [Int] or f :: [Int] -> Bound -> Bound -> [Int]
11:56:06 <Toxaris> Gwern-away: how leads mechanical to synchronous?
11:56:06 <Philippa_> Gwern-away: deterministic concurrency actually makes good sense on a single, single-core computer too
11:56:13 <ksandstr> halberd: just types alone aren't very good for documenting many-parameter functions
11:56:13 <mmorrow> jkff: ok, but since the x and y there don't really have any inherent structure w/in themselves, the morphisms seem like they then don't have any structure other than they "exists"
11:56:17 <jkff> And an arrow between (A, a) and (B, b) is a function f :: A -> B such that f(a) = b
11:56:27 <ksandstr> halberd: I can't imagine that situation would change even if some of those types were renamed.
11:56:43 <jkff> Did I make it more clear?
11:57:13 <Philippa_> Gwern-away: basically that lets you think about doing two things in sync still without doing your head in, which is useful when you want to do exactly that for eg performance and storage reasons
11:57:21 <ksandstr> halberd: also that use conceals the true type of the min and max parameters. (also shouldn't min and max be in a tuple?)
11:57:21 <jkff> The composition of 'f(x) = y' and 'g(y) = z' is '(g.f) x = z'
11:57:29 <mmorrow> jkff: oh, i just saw you prev comment. so then it'd be the category pSet (pointed sets) or some such thing
11:57:48 <jkff> The identities are 'id(x) = x'
11:58:02 <jkff> Well, it is certainly similar to the category pSet, but they are different
11:58:32 <jkff> Val is more similar to the category of one-element sets
11:58:40 <jkff> But I am not sure whether they are the same or even isomorphic
11:59:02 <jkff> There can be only one {1} but there can be both {1::Int} and {1::Real}
11:59:47 <maltem> halberd: Fwiw in dependently-typed languages one can write f :: [Int] -> (min : Int) -> (max : Int) -> [Int]. That is, one tends to differentiate between the name of the argument and its type
12:00:07 <jkff> Consider another example: the category Sp of linear vector spaces and affine transforms, and the category Pt of points in these spaces and motions that take one point to another
12:00:17 <Toxaris> jkff: is overloading of names (!) really that important? I would consider the 1 in 1 :: Int and the 1 in 1 :: Real to be different symbols denoting different concepts written by the same glyph (at least for some purposes, e.g., if I don't want to talk about polymorphism)
12:00:32 <jkff> 1::Int is a pair (1, Int)
12:00:47 * Toxaris catching up ...
12:00:50 <EvilTerran> halberd, sometimes people use synonyms for that, but only if you need lots of mentions of a type with the same alias
12:00:52 <jkff> We take the Set category and explode each set object into a bunch of objects in Val
12:01:02 <jkff> A set is exploded into its elements
12:01:02 <EvilTerran> halberd, or if you might want to change which type it is later
12:01:14 <EvilTerran> (although that's ugly, and you could do it nicer with polymorphism in most cases)
12:01:15 <Toxaris> jkff: yeah ok, but you could say that each value has a unique type associated
12:01:17 <jkff> An arrow is exploded into the individual mappings of elements of its domain
12:01:19 <jkff> Yes
12:01:55 <Toxaris> jkff: so two arrows between the same values differ in how they treat other values of the same type?
12:01:58 <jkff> I want to distinguish 1::Int and 1::Real because 1::Int has been exploded from Int and 1::Real has been exploded from Real
12:02:13 <jkff> Otherwise it would be hard to formulate the process of explosion
12:02:17 <EvilTerran> halberd, for instance, the standard libraries have "type FilePath = String" in there somewhere
12:02:25 <mmorrow> jkff: it seems to me that that's what arrows usually are. eg  the category of vector spaces over some field w/ morphisms linear maps
12:02:31 <halberd> yes I know about that one EvilTerran
12:02:38 <Apocalisp> is there a datastructure for a fixed-size matrix?
12:02:52 <EvilTerran> Apocalisp, as in, fixed at compile-time?
12:03:00 <Apocalisp> yes
12:03:07 <EvilTerran> there isn't, short of some stuff Oleg's written
12:03:13 <EvilTerran> because you need to encode the size in the type
12:03:32 <Apocalisp> As in... Succ Succ Succ Zero ?
12:03:35 <Apocalisp> :)
12:03:48 <mauke> D4
12:03:57 <Toxaris> :t (('a', 'b', 'c'), ('d', 'e', 'f'), ('g', 'h', 'i')) -- :)
12:03:59 <jkff> Well... Let us put the Pt and Sp example aside; Set and Val suffice for the discussion and Pt and SP are a spaciel case.
12:03:59 <lambdabot> ((Char, Char, Char), (Char, Char, Char), (Char, Char, Char))
12:04:14 <Apocalisp> Toxaris: There's always that.
12:04:15 * BMeph runs for covers from jkff's exploding sets
12:04:32 <jkff> *special
12:04:48 <Toxaris> Apocalisp: but for many uses, arrays are ok, even without static bound checking
12:05:02 <soduko> but tuples dont enforce type consistency among elements
12:05:05 <Apocalisp> absolutely. Just curious.
12:05:19 <soduko> :t ( 'a' , 3.14)
12:05:19 <lambdabot> forall t. (Fractional t) => (Char, t)
12:05:22 <Toxaris> type Matrix3 a = ((a, a, a), (a, a, a), (a, a, a))
12:05:43 <mmorrow> jkff: gotta run, but keep with it
12:06:16 <jkff> Ok; in the meantime, is there an *even* better place than here to ask CT questions?
12:06:38 <jkff> (not sure I'll be here for much longer; probably tomorrow)
12:07:59 <dmhouse> Toxaris: that type, read aloud, sounds like laughter.
12:08:25 <Toxaris> monochrom: I see two main views of computers: (1) as persons and (2) as tools. (1) assumes that a computer may need some time to accomplish a task I tell him/her to do, and will tell me if he/she is ready. (2) assumes that everything I do with the computer is done at once.
12:08:25 <EvilTerran> Apocalisp, ITYM Succ (Succ (Succ Zero)), but yes
12:09:25 <halberd> is there a simple idiomatic way to say you want the partial sums of another list?
12:09:26 <EvilTerran> Apocalisp, or D1 (D1 END), using binary
12:09:28 <EvilTerran> :P
12:09:44 <dmhouse> > scanl (+) 0 [1..10]
12:09:45 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
12:09:45 <Toxaris> halberd: what are partial sums? maybe you search for scanl?
12:09:54 <halberd> oh thanks dmhouse
12:09:55 <EvilTerran> (the binary version gives you better complexities to do arithmetic, so is less likely to blow your typechecker stack)
12:10:10 <camio> Anyone know of a built in function = :[]?
12:10:20 <dmhouse> camio: how about (:[])?
12:10:38 <EvilTerran> halberd, scanl f e xs = map (foldl f e) (inits xs)
12:10:42 <Toxaris> camio: that are two functions, (:) constructs a list out of a single element and a list, and [] is the empty list
12:10:42 <dons> camio: 'return'
12:10:53 <camio> dons: Thanks, you got it.
12:10:53 <EvilTerran> halberd, and scanr f e xs = map (foldr f e) (tails xs)
12:10:55 <dmhouse> The monster operator. (:[ {- munch -}])
12:10:57 <Toxaris> camio: hmm, oh you search it, sorry
12:11:18 <ksandstr> dmhouse: I was about to call it the robot operator
12:11:20 <camio> Actually, my real preference is pure.
12:11:34 <dmhouse> camio: why?
12:11:35 <halberd> except using map and tails is inefficient
12:11:38 <Toxaris> dmhouse is that one related to the greedy operator ((<$>) . (<$>)) ?
12:11:53 * dmhouse thinks using return is obfuscating things a bit anyway
12:11:57 <EvilTerran> ?type  ((<$>) P.. (<$>))
12:12:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:12:04 <dmhouse> Unless you're writing in the list monad, of course.
12:12:08 <camio> dmhouse: I like applicative a lot better than monads.
12:12:23 * EvilTerran tends to use return or (:[]), whichever looks better in context
12:12:26 <dmhouse> camio: oh, sorry, I thought you meant you'd prefer a pure (as in, non-monadic) function to do the job.
12:12:27 <Toxaris> EvilTerran: it's mapping into a nested functor, e.g. over the values in a assocation list
12:12:45 <EvilTerran> although i have been known to write "enlist x = [x]" when i'm using it a lot in one program
12:12:52 <Toxaris> singleton x = [x]
12:13:05 <dmhouse> I've seen "box". But I don't think there's any reason to name it.
12:13:10 <EvilTerran> or that, though that clashes with one in Data.Map and Data.Set
12:13:22 <Toxaris> I see that as a good thing
12:13:24 <EvilTerran> i like "box"
12:13:42 <Toxaris> List.singleton is like Set.singleton, just like List.map is like Set.map and so on
12:13:45 <EvilTerran> altho it's a bit of an abuse of the word in the context of (un)boxed values
12:13:45 <maltem> EvilTerran: That clash just establishes consistency
12:13:48 <EvilTerran> Toxaris, yeah, that works
12:14:00 <EvilTerran> it's not like i ever import Data.Map unqualified anyway
12:14:13 <EvilTerran> aside from the type and (!)
12:18:09 <roconnor> @bab nl en wijzigen
12:18:09 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
12:22:00 <BCoppens> roconnor: point?
12:22:02 <BCoppens> erm
12:22:04 <BCoppens> roconnor: change
12:22:11 <BCoppens> modify, etc
12:22:43 <BCoppens> (I first misread)
12:24:45 <roconnor> BCoppens: thanks
12:25:18 <roconnor> BCoppens: how would you describe the difference between ruilen and wijzigen?
12:25:46 <roconnor> I guess ruilen might be translated as exchange
12:27:37 <BCoppens> roconnor: indeed
12:28:05 <BCoppens> roconnor: although I'm not quite sure 'exchange' really captures it
12:28:52 <BCoppens> (that is to say, exchange seems to have more meanings)
12:29:43 <sal23> if I have a function with type a->b->a, can it match a function of type say a'->b' to first argument?
12:29:57 <roconnor> nope
12:30:03 <roconnor> sal23: that would be (a -> b) -> a
12:30:08 <sal23> what about (const id) then?
12:30:10 <sal23> it works...
12:30:20 <jkff> a -> b -> a matches a' -> b' with a'=a and b'=b->a
12:30:45 <roconnor> sal23: ah sorry
12:30:47 <sal23> > :t const
12:30:48 <lambdabot>   parse error on input `:'
12:30:50 <Botje> sal23: yes. but you'll have to alpharename
12:30:55 <roconnor> sal23: I didn't see your ticks in your question
12:31:03 <roconnor> sal23: yes, it can
12:31:20 <roconnor> > const id 5 6
12:31:21 <lambdabot>  6
12:31:22 <jkff> Well, does anyone know which frequent visitors of #haskell are CT gurus? Maybe they are simply sleeping at the moment and I have a chance to catch them later?
12:31:31 <sal23> right....
12:31:57 <Cale> a = a' -> b', then you have b -> (a' -> b')
12:31:58 <roconnor> jkff: Church's thesis?
12:32:05 <Cale> (as result)
12:32:18 <sal23>  Cale: yes, that is what I thought
12:32:33 <Cale> assuming that a' and b' are completely unrelated to a and b :)
12:32:46 <jkff> roconnor: ehm? What do you mean?
12:32:56 <roconnor> jkff: what is CT?
12:33:04 <Cale> category theory?
12:33:09 <roconnor> oh right
12:33:16 <jkff> Yep, category theory
12:33:17 <monochrom> jkff: try dolio and ddarius
12:33:25 <Cale> and occasionally me :)
12:33:29 <roconnor> I always read that as Church-Turing, or Churh's thesis.
12:34:04 <jkff> Well, now I know this abbreviation, too :) Cale, btw, did you see my question above about Set/Val ?
12:34:13 <jkff> roconnor, thanks for pointing to the guys
12:34:13 <Cale> no
12:34:36 <sal23> roconnor: Church's thesis in what context? not related to my question, is it?
12:35:16 <sal23> roconnor: never mind
12:35:48 <jkff> Ok, then here it is. Consider the Set category. Now let us make the Val category by exploding Set: an object S goes to a set of objects in Val of the form (x, S) where x is an element of S. A function f :: A -> B goes to a bunch of arrows a -> b where a `in` A and b `in` B. Does the relationship between Set and Val have a special name?
12:36:01 <roconnor> sal23: :)
12:36:21 <jkff> *f goes to a bunch of arrows a --f--> b where f(a) = b
12:37:26 <Cale> jkff: well, you can think of an element x of a set S as being an arrow 1 -> S
12:38:01 <jkff> Yes, I can
12:38:02 <Cale> So perhaps it's the category of objects under 1?
12:38:08 <dylan> I don't suppose anyone has some haskell code for parsing/formatting ISO 8583 messages?
12:38:38 <jkff> You mean, the category of subobjects of 1?
12:39:21 <Cale> Or the coslice category with respect to 1.
12:39:31 <Cale> http://en.wikipedia.org/wiki/Comma_category#Category_of_objects_under_A
12:39:32 <lambdabot> http://tinyurl.com/5zkmfa
12:40:19 <jkff> Oh, yes, coslice. That seems to be true.
12:40:58 <BMeph> Don't leave out edwardk.
12:42:05 <Cale> Oh, it's also the category of pointed sets, of course.
12:42:36 <jkff> Oh! It really is, you are right.
12:43:05 <jkff> It seems to me that coslice with respect to 1 must have some very important applications. Let me call such a category for C 'the explosion of C', and the inverse be 'the implosion of C'. What other illuminating examples of explisions and implosions are there?
12:43:26 <Cale> inverse?
12:43:27 <jkff> For example, what is the *implosion* of Set?
12:43:53 <jkff> Set is an implosion of Val, Val is an explosion of Set
12:44:06 <Cale> It's not clear to me that Set has an implosion.
12:46:53 <jkff> To me, too.. Maybe any other examples, not being simply subcategories of Set?
12:47:31 <jkff> It seems to me that such exploded categories should have applications in programming language semantics and optimization, but I can't imagine which ones exactly
12:48:10 * monochrom can't help but giggle at that.  ghc optimizer says "my brain has exploded"...
12:48:48 <Cale> Well, they're pointed... so if there's a terminal object, there is exactly one map from that *terminal* object to everything else. (Because it must preserve the point)
12:49:37 <Cale> That might be wrong, but it's my intuition about it anywya
12:49:58 <jkff> Could you clarify a bit?
12:50:51 <Cale> Well, look at the case for Set
12:51:02 <Cale> We get the category of pointed sets.
12:51:06 <jkff> Yep
12:51:20 <Cale> That category still has a terminal object 1
12:51:44 <Cale> (pick a one element set, with the point being chosen in the only way possible)
12:52:19 <jkff> Yep, I understand your statement but I don't understand what larger thing you were saying
12:52:24 <Cale> Ordinarily, in Set, the arrows 1 -> S give you the elements of S.
12:52:47 <Cale> But here, there will only be one arrow 1 -> S for any object S in the category of pointed sets.
12:53:00 <Cale> Because the point must be preserves.
12:53:04 <Cale> preserved*
12:53:13 <jkff> Yes
12:54:08 <Cale> So, suppose we take a category with a terminal object 1, and construct the coslice with respect to 1.
12:54:42 <jkff> ..And we get the exploded category
12:54:48 <Cale> right
12:55:22 <jkff> ...And? :)
12:55:42 <Cale> We're not assuming anything extra about the category we're working with here, so if we determine some properties, they will be characteristic of exploded categories.
12:56:02 <Cale> So look at this exploded category, it has a terminal object as well...
12:56:51 <jkff> Do you mean that all properties of a category are preserved by explosion?
12:56:54 <Cale> being essentially the unique arrow 1 -> 1 in the original
12:57:01 <Cale> no
12:57:10 <Cale> There's something very special going on here :)
12:57:30 <Cale> Now, consider what the arrows are going to look like which go from 1 -> 1  to  1 -> A
12:58:36 <Cale> I should say, to some arrow f : 1 -> A
12:58:53 <jkff> Seems like they are essentially the same as the very arrows 1 -> A
12:59:25 <Cale> The only arrow from 1 -> 1 to  f: 1 -> A is essentially f itself, yeah?
12:59:33 <jkff> Yes
12:59:47 <Cale> So in an exploded category, objects have only one element.
12:59:53 <Cale> "element"
13:00:09 <Cale> Meaning that there's only one map 1 -> A for any object A.
13:00:29 <jkff> So the terminal object is also the initial object?
13:00:40 <Cale> Indeed :)
13:00:46 <jkff> Yes, that's already cool
13:00:50 <Cale> It's a zero object. :)
13:01:03 <Cale> So right away, we know that Set is not exploded.
13:01:10 <Cale> Because it doesn't have a zero object :)
13:01:19 <jkff> Really
13:01:57 <Cale> The initial object in Set is the empty set, and the terminal objects are the one-element sets.
13:02:10 <jkff> Yes, I understand that
13:02:16 <SimonRC> I wouldn't normally put this here, but if I put it on a mailing list it might expire by the time people read it...
13:02:30 <SimonRC> type "glasgow" into that Cuil search engine
13:02:42 <SimonRC> second link is to the glasgow haskell compiler...
13:02:56 <SimonRC> with a pic of Osama Bin Laden as its illustration
13:03:02 <Cale> ahahahaha!
13:03:07 <SimonRC> oh no, the ghc team are terrorists!
13:03:12 <SimonRC> (try it)
13:03:18 <blarz> and bin laden :D
13:03:20 <Cale> yeah, I'm seeing that :)
13:03:21 <blarz> ah
13:04:09 <Cale> http://cale.yi.org/autoshare/Screenshot-glasgow.png
13:04:31 <r3m0t> LOL
13:04:47 <adekoba> wtf
13:04:48 <SimonRC> ah, in case it changes
13:05:13 <SimonRC> that should go on the Wiki, maybe
13:05:14 <r3m0t> I'm surprised they don't disable the image functionality after all the embarrassment it's caused them
13:05:15 <roconnor> A Gentle Introduction to Haskell, Version 98, brought to you by mastercard
13:05:27 <Gwern-away> 'Guido! Why have you forsaken me?' http://google-code-updates.blogspot.com/2008/07/looks-good-to-me-source-code-review.html
13:05:28 <lambdabot> Title: Google Code Blog: Looks Good To Me - Source Code Review Tools, http://tinyurl.com/57oobj
13:05:35 <SimonRC> r3m0t: all publicit is good publicity
13:06:20 <jkff> Cale: OK, thanks a lot for the interesting discussion, now I must go to sleep but I guess I'll return and torture you some more :) Would you recommend any exceptionally good non-introductory CT literature, by the way? I'm reading Barr+Wells 'CT for computing science'
13:06:44 <Cale> Well, there's the yellow book "Categories for the working mathematician"
13:06:57 <Cale> And then there's everything by Eugenia Cheng :)
13:07:12 <jkff> Are they available online?
13:07:15 <Cale> Including some rather nice notes...
13:07:21 <Cale> Let me get a link to those
13:07:36 <BMeph> Cale: If you have that search page up, click on the Rangers tab...
13:07:43 <Cale> CFTWM isn't online as far as I know... though you might find a pirate copy
13:07:46 <dolio> Look up the catsters on youtube.
13:08:09 <dolio> They're fun.
13:08:22 <Cale> yeah, Eugenia is the person in most of them :)
13:08:36 <Cale> http://www.math.uchicago.edu/~eugenia/catnotes/categorynotes-cheng.pdf
13:08:38 <lambdabot> Title: CATEGORY THEORY, http://tinyurl.com/28sclm
13:08:49 <jkff> (I think I need something that gives an overview of as many as possible of the existing tools of category theory, those buzzwords like toposes, fibrations, sheafs etc. of which presently I am completely ignorant, so that I would know what could be more fruitful for my particular needs)
13:08:52 <Cale> http://www.cheng.staff.shef.ac.uk/ is her homepage, there are some decent things from there
13:08:53 <lambdabot> Title: Eugenia Cheng
13:08:54 <jkff> Thanks
13:09:30 <jkff> I'll look at them most probably tomorrow and I'll buy the CTFWM
13:11:27 <jkff> dolio, thanks, I now found out that I already came across them but forgot to actually have a look
13:12:06 <jkff> Are they accessible to someone who has read Barr&Wells only up to the Yoneda lemma yet? :)
13:13:08 <dolio> The only 'text' I've ever read is Basic Category Theory for Computer Scientists, and I can watch most of them.
13:13:31 <BMeph> Cale: How about Dan (sigfpe)'s blog? ;)
13:13:47 <dolio> I should really get some better books.
13:13:49 <jkff> Ok, thanks, I've read it too. Now gotta go to sleep, so bye to everyone!
13:17:12 <newsham> are there any IO functions that go directly to ByteStrings?
13:17:25 <dons> newsham: yeah.
13:17:34 <newsham> which lib?
13:17:49 <dons> you mean like readFile :: FilePath -> IO ByteString ?
13:18:00 <mauke> network-bytestring
13:18:06 <newsham> sure, but for myself, socket related.
13:18:10 <newsham> or handle related.
13:18:34 * BMeph wonders if haskell leaves #dylan, when dylan leaves #haskell...
13:18:44 <newsham> i'm writing a small server that reads requests, decodes them, processes them, encodes the response, and writes them back out
13:19:12 <newsham> right now I am using Data.Binary which uses ByteStrings (although my messages are usually pretty small so its probably not that much of a win,  though not sure)
13:19:58 <newsham> also it seems that I need a record layer because otherwise it hangs reading the request either in the binary decode or in the bytestring encode (I havent tested to see where).
13:20:36 <newsham> so basically I have a record layer which reads a two-byte integer, then that many bytes as a record, converts to byte string, then does the binary decode, processes request to get response, encodes response, converts to byte string, converts to string, then writes out the length and the data
13:20:47 <newsham> and I'm looking for ways to make this more efficient and/or simpler.
13:20:59 <mauke> heh, I have a program that does exactly that
13:21:20 <newsham> what kind of performance does it get?
13:21:25 <mauke> I have no idea
13:21:40 <mauke> it's good enough to run preflex :-)
13:22:32 <newsham> to localhost it seems I do just under 4k requests/second (where there is negligible processing per request)
13:23:06 <newsham> and a dummy server that does nothing but write out one byte for each connection gets something like 10k/sec
13:24:24 <newsham> i was hoping -threaded and -N2 would go a bit better with multiple clients running at once (dual core cpu)
13:24:33 <newsham> but it doesnt seem to help, and turning that on hurts slightly
13:26:11 <hexpuem> you using show / read for conversions?
13:30:21 <newsham> no, i'm using Data.Binary
13:31:05 <newsham> code is all here:  http://www.thenewsh.com/%7Enewsham/store/  {Server3,DummyClient3,Utils,Proto,Db}.hs
13:31:06 <lambdabot> Title: Directory /~newsham/store/
13:31:38 <newsham> its more of an exercise than something useful, but the idea is to have a data store for stock ticker data.  the goal is to see how well it can perform.
13:35:24 <newsham> mauke:  i'd love to see your code.  is it sharable?
13:36:52 <mauke> http://mauke.ath.cx/dserve/
13:36:53 <lambdabot> Title: Index of /dserve
13:39:05 <thaldyron> t3r8911ppm
13:40:08 <newsham> mauke: ty
13:44:02 <newsham> will ghc optimize mul/div/mod/divMod by powers of 2?
13:45:55 <mmorrow> newsham: that's probably a matter of whether gmp optimizes them
13:46:19 <newsham> is gmp used for Int?
13:46:53 <mmorrow> newsham: oh. i've seen most of those implem at one time or another, i'll find em real quick
13:50:16 <newsham> Int should be boxed up version of native machine integer, no?
13:50:38 * byorgey bakes lambda-shaped peanut butter cookies
13:51:19 <hexpuem> i think ghc can magically remove boxing in certain situations
13:51:21 <hexpuem> not entirely sure though
13:58:43 <mmorrow> newsham: i unlitted and HsColoured all the base ghc num-related modules: http://code.haskell.org/~morrow/code/haskell/ghc/html/
13:58:43 <lambdabot> Title: Index of /~morrow/code/haskell/ghc/html
14:00:10 <newsham> danke.
14:00:11 <newsham> bbl.
14:00:47 <Trinithis> is there an extension for mutually recursive modules?
14:01:44 <mjrosenb> Trinithis: iirc, those are already handled by ghc
14:01:52 <Trinithis> oh
14:02:31 <mjrosenb> Trinithis: there's a dance that you need to do where you compile them in an ABA order
14:02:32 <Trinithis> well, I'm getting an error "imports from a cycle of modules"
14:02:41 <mjrosenb> or ghc --make handles it correctly
14:02:47 <mjrosenb> i *believe*
14:03:03 <mauke> Trinithis: you need to break the cycle semi-manually
14:03:10 <mauke> .hs-boot, etc
14:03:11 <mjrosenb> Trinithis: what command are you using?
14:03:18 <Trinithis> ghci
14:03:29 <mjrosenb> try compiling them with ghc --make
14:03:32 <Trinithis> k
14:03:39 <mjrosenb> you can then load the pre-compiled files with ghci
14:04:03 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
14:04:03 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
14:04:14 <Trinithis> --make didnt work. Guess I'll have to refractor my modules
14:04:25 <Trinithis> refactor*
14:04:32 <mjrosenb> --make *really* should handle that
14:04:47 <mjrosenb> Trinithis: i wouldn't say this is a good reason to refactor
14:05:02 <Trinithis> juggle them around then
14:08:41 <tromp> :t fix
14:08:42 <lambdabot> forall a. (a -> a) -> a
14:08:56 <tromp> @where fix
14:08:57 <lambdabot> I know nothing about fix.
14:09:19 <r3m0t> > fix (+0)
14:09:20 <mauke> @index fix
14:09:20 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
14:09:35 <lambdabot>  thread killed
14:09:37 <r3m0t> > fix (+(0::Int))
14:09:47 <tromp> fix error is funny indeed:)
14:09:52 <lambdabot>  thread killed
14:10:08 <r3m0t> > fix ((*2).(+3))
14:10:23 <lambdabot>  thread killed
14:10:37 <camio> > fix error
14:10:47 <mauke> camio: it's more fun in ghci
14:10:52 <lambdabot>  thread killed
14:10:57 <mjrosenb> r3m0t: you might want to try something that can be lazily evaluated
14:11:07 <camio> mauke: Where is fix defined?
14:11:17 <Cale> Control.Monad.Fix
14:11:18 <mjrosenb> camio: Data.Function
14:11:21 <r3m0t> camio: fix x = let x = f x in x
14:11:21 <Cale> oh
14:11:38 <mmorrow> @tell newsham http://hpaste.org/9293
14:11:39 <lambdabot> Consider it noted.
14:11:41 <Cale> Has it moved? Data.Function would be a more appropriate place for it.
14:11:50 <newsham> danke
14:11:50 <lambdabot> newsham: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:12:07 <mjrosenb> *Main Monad> :browse Data.Function
14:12:07 <mjrosenb> fix :: (a -> a) -> a
14:12:15 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
14:12:17 <tromp> what's monadic about fix?
14:12:18 <lambdabot>  3628800
14:12:22 <Cale> tromp: nothing
14:12:31 <Cale> tromp: however, mfix is monadic
14:12:34 <newsham> *lambdabot* dmwit said 2m 22d 22h 38m 13s ago: hey
14:12:36 <newsham> hey!
14:12:36 <Cale> :t mfix
14:12:37 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:12:43 <tromp> i'd expect fix in Prelude
14:12:57 <Cale> So would I, but it's strangely not there.
14:14:21 <Cale> > fix (\map f l -> case l of [] -> []; (x:xs) -> f x : map f xs) (+1) [1..10]
14:14:22 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
14:15:05 <mercury^> btw: are head and tail not of type :: (Monad m) => [a] -> m a, respective :: (Monad m) => [a] -> m [a] for historical reasons or would that be a bad choice?
14:15:12 <monochrom> Whee, Haskell Thursday News is out!
14:15:18 <newsham> > fix whitehouse
14:15:19 <lambdabot>   Not in scope: `whitehouse'
14:15:32 <monochrom> fix whiteelephant :)
14:15:33 <Cale> mercury^: MonadZero would make a better choice
14:15:45 <Cale> mercury^: But MonadZero no longer exists due to stupidity
14:16:09 <newsham> byorgey: you shoulda asked to buy the work laptop
14:16:10 <rwbarton> mercury^: That would be reasonable if there was an Identity monad where Identity a unified with a
14:16:15 <Cale> mercury^: failure isn't guaranteed to be meaningful in all monads. It's really silly that fail got included in the definition of the monad class.
14:17:16 <BMeph> I say get advanced, and put loeb in the relude! ;)
14:17:18 <Cale> Of course, if there were such an Identity monad, every application of the monad operations would be ambiguous.
14:17:26 <BMeph> s/relude/Prelude/
14:18:04 <jethr0> @source zipWith'
14:18:04 <lambdabot> zipWith' not available
14:18:11 <Cale> s/Prelude/Quaalude/
14:18:30 <newsham> import Quaalude hiding (reality)
14:18:39 <jethr0> hmm, what was the zipwith called that also continued when one list was empty?
14:18:51 <newsham> there's one in the std lib?
14:18:53 <jethr0> import qualified Prelude as Quaalude
14:18:54 <Cale> jethr0: doesn't exist?
14:18:59 <jethr0> i thought...
14:19:01 <hexpuem> do wireless network cards need a hub/switch ?
14:19:02 <mercury^> how should it work?
14:19:10 <mercury^> what elements would it continue with?
14:19:10 <newsham> it could work in several ways :)
14:19:22 <jethr0> mercury^: that's what i was thinking, but i had this idea that it existed...
14:19:26 <newsham> it could take the element from the existing list, it could provide a dummy value for the other list, ...
14:19:34 <jethr0> could pass it an "empty" element
14:19:52 <Cale> zipWith' :: (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c]
14:19:52 <dolio> Could require the function to be c -> c -> c
14:20:02 <BMeph> jethr0: 'longZipWith,' you mean? :)
14:20:07 <mjrosenb> right, there we go
14:20:31 <newsham> | length xs > length ys = zipWith f xs (ys ++ repeat default)   ?
14:20:48 <mjrosenb> :t head . zipWith (flip (,)) . unzip . (:[])
14:21:00 <jethr0> mjrosenb: aaahhh
14:21:02 <mjrosenb> or not
14:21:10 <BMeph> It seems there are many functions considered "too simple" to go in the Prelude... :|
14:21:23 <newsham> import TooSexyForPrelude
14:21:25 <jethr0> BMeph: some would even use the infamous "trivial"
14:21:34 <jethr0> import * from future
14:22:06 <mercury^> a cycle function for all tuples would be nice imo
14:22:19 <mjrosenb> right, haskell likes things to be curried
14:22:24 <BMeph> jethr0: Hey! We'll have none of that Python in here! This is #haskell, where programming is pure... ;)
14:22:26 <mjrosenb> mercury^: i don't think that's possible
14:23:10 <mercury^> mjrosenb: cycleN :: (T1,T2,...,TN) -> (TN,T1,...) ?
14:23:20 <jethr0> BMeph: importing everything from the future might also come in handy with haskell. unless of course the current state of haskell + libs is the pinnacle of computer science ;)
14:23:36 <mercury^> at least a swap should be there
14:23:45 <HairyDude> hmm, Either e has no Applicative instance
14:24:08 <rwbarton> @hoogle swap
14:24:08 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
14:24:08 <lambdabot> Control.Concurrent.STM.TMVar.swapTMVar :: TMVar a -> a -> STM a
14:24:08 <mjrosenb> BMeph: so as long as nothing in the futur reffers to what we define based on the future, we should be fine
14:24:23 <mjrosenb> BMeph: lazy evaluation will just wait for now to be the future
14:24:25 <newsham> bmeph: you can purify your pythons
14:24:36 <mercury^> also, why isn't << defined as a << b = b >> a?
14:24:50 <mjrosenb> :t <<
14:24:52 <newsham> in python "import * from future" imports last year's ghc.
14:24:54 <jethr0> maybe something like "fix future" would resolve any paradoxes, ironcally
14:25:16 <mjrosenb> jethr0: might take a while to run.
14:25:20 <jethr0> newsham: how very diplomatic
14:25:33 <HairyDude> :t (<<)
14:25:52 <mercury^> HairyDude: it is not defined by default
14:25:56 <mercury^> my suggestion was that it should be :)
14:26:04 <jethr0> mjrosenb: i thought fix point calculation were more or less instantaneous, unless of couse diverging
14:26:07 <HairyDude> ah
14:26:32 <mercury^> jethr0: depends
14:26:35 <mercury^> usually it is fast :>
14:26:44 <mercury^> but you can construct examples where it will be slow
14:27:04 <mjrosenb> jethr0: well if future is a thunk whose computation will be finished 'in the future'
14:27:07 <roconnor> how can I comment out a section of latex?
14:27:21 <mjrosenb> jethr0: then in a couple of seconds
14:27:21 <mauke> %
14:27:25 <roconnor> @src (<<)
14:27:25 <lambdabot> Source not found. :(
14:27:30 <mjrosenb> jethr0: you still need to wait for the future
14:27:32 <jethr0> personally, i thing mixing data direction within functions/lines can be extremely confusing especially concerning precedence. as nice as it can be sometimes to mix directions
14:27:43 <mauke> mercury^: because that's the wrong definition for <<
14:27:45 <mjrosenb> :t (>>)
14:27:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:27:47 <roconnor> mauke: a several lines
14:27:48 <newsham> > fix (\f n -> if n < 2 then 1 else f (n - 1) + f (n - 2)) 500
14:27:50 <pozic> roconnor: do you know what HA_Bottom does in chart?
14:27:51 <jethr0> a << b >> c
14:27:54 <lambdabot>  Exception: Time limit exceeded
14:27:57 <mauke> roconnor: several %'s
14:28:03 <roconnor> mauke: ok
14:28:31 <pozic> roconnor: HA_Top and HA_Bottom don't seem to have any different behaviour.
14:28:33 <roconnor> pozic: It a value that "the bottom axis"
14:28:35 <newsham> http://conal.net/blog/posts/future-values/
14:28:36 <lambdabot> Title: Conal Elliott  Future values
14:28:52 <mercury^> mauke: what would be the correct one?
14:28:59 <mauke> mercury^: <*
14:29:05 <roconnor> pozic: if you are using linked axes, HA_Top and HA_Bottom will give you the same result.
14:29:06 <pozic> roconnor: "the bottom axis" does what?
14:29:14 <mauke> which is effectively a << b = do { x <- a; b; return x }
14:29:25 <pozic> roconnor: ok, and when I am not?
14:29:52 <mercury^> mauke: I don't understand why << lends itself better to that definition. Why not keep things symmetrical, as with >>= and =<<?
14:30:03 <mauke> because it looks awesome in parsers
14:30:09 <roconnor> pozic: then you can have different values for the top and bottom axes.
14:30:15 <mauke> term = char '(' >> expr << char ')'
14:30:22 <newsham> was =<< around when << was invented?
14:30:31 <roconnor> pozic: I have a patch underconsideration that will remove HA_Foo
14:31:06 <dolio> That's what *> and <* are for, though.
14:31:22 <dolio> << is, presumably, for writing monadic code in a right to left order.
14:31:27 <pozic> roconnor: I read the source, but the author has quite an odd style.
14:31:30 <mauke> when I first invented <<, I didn't know about Applicative
14:31:31 <HairyDude> hmm, what happened to the hpaste bot?
14:31:39 <mauke> preflex: seen hpaste
14:31:39 <preflex>  hpaste was last seen on #haskell 20 days, 5 hours, 33 minutes and 1 second ago, saying:  Mitar pasted "Hot to indent?" at http://hpaste.org/8869
14:31:50 <pozic> roconnor: the HA_Foo behaviour is indirect in the AxitT stuff.
14:31:51 <newsham> *hugs* applicative
14:32:03 <pozic> roconnor: AxisT*
14:32:09 <Trinithis> mauke: What is .hs-boot file?
14:32:12 <HairyDude> preflex? that's a new oen, what sort of bot is that?
14:32:12 <preflex>  factoid not found
14:32:12 <HairyDude> s/oen/one/
14:32:20 <RayNbow> hmm, could Haskell be considered a mental drug? :p
14:32:27 <roconnor> pozic: that is why I changed it :)
14:32:28 <mauke> Trinithis: dude, read my link
14:32:46 <mauke> HairyDude: generic irc bot :-)
14:32:49 <Trinithis> whoops. missed it :D
14:32:49 * RayNbow is getting addicted to watching talks and reading papers... :p
14:32:53 <pozic> roconnor: do you think the library can be used already?
14:33:00 <mauke> my first attempt at writing an IRC client from scratch
14:33:14 <roconnor> pozic: what do you mean?
14:33:26 <mercury^> mauke: for the fun of it or because you want something current clients don't provide?
14:33:31 <pozic> roconnor: I mean in an actual 2d data visualiser.
14:33:43 <roconnor> I use it for that.
14:33:52 <roconnor> with my patch, now you would write:
14:33:54 <mauke> mercury^: mostly for fun, but also because lambdabot loses state all the time
14:33:54 <roconnor> layout1_plots = [("price 1", Left (toPlot price1)),
14:33:54 <roconnor>                          ("price 2", Right (toPlot price2))],
14:33:55 <HairyDude> anyway, I think I managed to post it, though I haven't seen it yet http://hpaste.org/9294
14:34:07 <newsham> get = Constructor <$> get <*> get <*> get <*> get <*> get
14:34:08 <newsham> *hug*
14:34:10 <dino-> Is there an alt paste we've been using?
14:34:10 <roconnor> and there is no top and bottom
14:34:20 <roconnor> You are only allowed one independent axis.
14:34:38 <mauke> so far, preflex manages to keep track of "seen" state, karma, and factoids
14:34:39 <pozic> roconnor: but some graphs of the kind I don't use do have that property.
14:35:02 <roconnor> pozic: you have examples of graphs with two independent axes?
14:35:28 <RayNbow> newsham: what does get do?
14:35:37 <pozic> roconnor: some people use it to plot two functions in one graph.
14:35:50 <roconnor> pozic: you can have 2 dependent axes
14:35:57 <roconnor> pozic: that is what the Left and Right specify
14:36:11 <roconnor> whether this plot is ploted against the Left axis or the Right axis.
14:36:13 <newsham> http://hackage.haskell.org/packages/archive/binary/0.4.2/doc/html/Data-Binary.html#v%3Aget
14:36:14 <lambdabot> Title: Data.Binary, http://tinyurl.com/6gry8x
14:36:48 <newsham> put (Constructor a b c d) = put a >> put b >> put c >> put d
14:37:04 <roconnor> pozic: Charts has some very signifigant layout issues for the auto axes if you deviate from the standard sized plots.
14:37:20 <roconnor> pozic: I've been thinking about fixing that sometime.
14:37:37 <roconnor> so in that sense, it isn't ready yet
14:37:46 <HairyDude> ah, I see, it doesn't think one "Left e" can be Either e a as well as Either e b
14:37:51 <roconnor> but that is the only major issue that I'm aware of.
14:38:00 <RayNbow> newsham: ah
14:38:12 <pozic> roconnor: can you give an example of that?
14:38:18 <HairyDude> or indeed Either e (a -> b) and Either e b
14:38:54 <roconnor> pozic: all the examples use 640 x 480
14:39:13 <roconnor> pozic: I haven't really tried, but if you change those dimentions by a lot, you should see the problem.
14:39:23 <roconnor> pozic: I've only read the code, not actually tried it. ;)
14:39:47 <pozic> roconnor: the price example is broken too
14:39:53 <pozic> roconnor: with 0.8
14:41:10 <pozic> roconnor: isn't there some C library that solves this problem in a good way?
14:41:36 <roconnor> pozic: broken how?
14:41:42 <dons> go HWN! http://www.reddit.com/comments/6udi2/haskell_weekly_news_binary_parsing_linear_algebra/
14:41:43 <lambdabot> Title: Haskell Weekly News: binary parsing, linear algebra, 2D physics, library platfor ..., http://tinyurl.com/6m5n5t
14:41:46 <roconnor> pozic: solves what problem?
14:42:20 <dons> shapr: did you see we passed the 500 mark?
14:42:22 <roconnor> dons: should that be in haskellit
14:42:41 <dons> haskellit?
14:42:47 <dons> oh, the subreddit?
14:42:55 <pozic> roconnor: copy pasting the code does not work.
14:42:56 <dons> we don't live in a ghetto.
14:43:03 <roconnor> dons: http://www.reddit.com/r/haskell/
14:43:03 <lambdabot> Title: Haskell
14:43:09 <dons> shrug.
14:43:21 <pozic> roconnor: it does work for the coin example.
14:43:22 <roconnor> ok
14:44:08 <roconnor> pozic: on you mean the examples on the wiki?
14:44:12 <roconnor> they don't work?
14:44:12 <pozic> roconnor: yes
14:44:17 <roconnor> pozic: yep
14:44:36 <roconnor> look in tests/test.hs
14:44:41 <roconnor> those examples all work
14:45:03 <roconnor> [16:41] <pozic> roconnor: isn't there some C library that solves this problem in a good way?
14:45:09 <roconnor> what do you mean by this?
14:45:35 <pozic> roconnor: binding a library that already works is better than duplicating effort.
14:45:50 <pozic> roconnor: test.hs:232:24: Not in scope: `symErrPoint'
14:45:50 <roconnor> binding a library for making charts?
14:45:54 <pozic> roconnor: yes
14:46:21 <roconnor> pozic: oh maybe.  I think all the charting libraries suck. ... but I've only tried gnuplot.
14:46:42 <pozic> roconnor: yes, I also tried gnuplot and with lots of work you can make it work.
14:47:10 <roconnor> pozic: Haskell Charts is something I think I can mold into a thing of typeful beauty.
14:47:18 * HairyDude notes that pattern matching in the definition of <*> has to be done in applicative order...
14:48:04 <roconnor> pozic: Sure, we can put a beautiful interface onto some C program
14:48:15 <roconnor> pozic: but I think that is almost as much work, and less flexible.
14:48:38 <pozic> roconnor: haddock also should get an update.
14:48:59 <pozic> roconnor: the documentation for chart doesn't build even with 2.2.
14:48:59 <roconnor> pozic: Tim appears to be aware of the haddock issue. :)
14:49:11 <pozic> roconnor: yes, I know.
14:49:30 <pozic> roconnor: does the maintainer of haddock also know that?
14:49:36 <roconnor> I don't know.
14:50:29 <byorgey> newsham: I did ask, they said that was unfortunately not possible =(
14:51:01 <byorgey> this is a several-thousand-employee behemoth we're talking about here
14:52:23 <roconnor> pozic: I was working on my own Haskell charting library, but I wasn't getting very far.
14:52:33 <roconnor> pozic: then Tim released his.
14:52:46 <roconnor> pozic: so I decided to work on his library rather than my own.
14:53:48 <pozic> roconnor: I wrote some code to call the gnuplot binary with intelligent legend placing.
14:54:44 <roconnor> I consider my auto-logorithmic axis one of the best that I have seen, IMHO.
14:54:58 <roconnor> and I looked at 3 or 4
14:55:19 <roconnor> That is almost good enough reason to write our own library.
14:55:48 <pozic> roconnor: did you look at plplot?
14:56:00 <roconnor> pozic: nope.
14:56:05 <roconnor> pozic: I'll have a look
14:56:08 <dino-> @paste
14:56:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:57:16 <roconnor> pozic: what should I get, python-plplot?
14:58:20 <pozic> roconnor: I only saw the website.
14:59:52 <Gwern-away> @help scheck
14:59:53 <lambdabot> scheck <expr>
14:59:53 <lambdabot> You have SmallCheck and 3 seconds. Test something.
14:59:56 <pozic> roconnor: it's ancient, but it doesn't look that good.
15:00:02 <roconnor> pozic: they have an online demo
15:00:26 <ddarius> byorgey: "most friendliest" ...
15:01:02 <roconnor> pozic: but I don't see a way to get log plots on their web interface
15:01:40 <monochrom> I like mostest friendliest :)
15:01:59 <monochrom> Anyway, I entered "fix error" into ghci and I like the result. :)
15:03:00 <gwern> :t fix error
15:03:00 <lambdabot> [Char]
15:04:06 <lispy> > map length . groupBy (<) . fix $ error
15:04:06 <pozic> roconnor: yes, I think you can ignore plplot. I figured that it would be something giving its age.
15:04:21 <lambdabot>  thread killed
15:04:41 <lispy> gwern: weird about the split directory stuff
15:04:55 <lispy> gwern: I'm not seeing those errors on 6.8.2 here, but I maybe I'm missing a patch
15:05:04 <Philippa_> @scheck fix fix
15:05:05 <lambdabot>     Failed to load interface for `SmallCheck':
15:05:05 <lambdabot>       Use -v to see a list of ...
15:06:02 <lispy> ?check fix fix
15:06:04 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a     Probabl...
15:06:47 <ihope> It's nice how fix error and error (fix error) have different types despite the former being defined as the latter.
15:08:38 <gwern> @check \x -> (x :: String) == x
15:08:41 <lambdabot>  OK, passed 500 tests.
15:09:11 <eu-prleu-peupeu1> hello
15:09:18 <lispy> ?check \x y -> (x :: String) == y
15:09:20 <ihope> @check \x -> const False (x :: String)
15:09:22 <lambdabot>  Falsifiable, after 0 tests: "\978068\752985", "\851602\104340"
15:09:22 <eu-prleu-peupeu1> are there any bindings to gpgpu libraries in haskell ?
15:09:23 <lambdabot>  Falsifiable, after 0 tests: ""
15:10:02 <ihope> General/generic programming/processing with graphics processing units?
15:10:30 <ihope> All I know about GPGPU is that some people try to do genetic programming with it.
15:11:42 <eu-prleu-peupeu1> there are some gpgpu programming languages, mostly extensions to C/C++
15:11:59 <ddarius> ihope: Make the type abstractions explicit and they'll no longer be identical.
15:12:11 <eu-prleu-peupeu1> brook gpu, sh, CUDA, brook+ and probably more
15:12:32 <pozic> eu-prleu-peupeu1: you said the same thing 4 months ago.
15:12:51 <pozic> eu-prleu-peupeu1: http://tuukka.iki.fi/tmp/haskell-2008-04-28.html
15:12:52 <eu-prleu-peupeu1> well, i have a lot of glsl code, that is hard to maintain :P
15:12:52 <lambdabot> Title: haskell-2008-04-28
15:13:11 <pozic> eu-prleu-peupeu1: start a library yourself :)
15:13:37 <eu-prleu-peupeu1> haskell library ? :P
15:13:41 <roconnor> pozic: bah, too  much effort to test their log axes.
15:13:56 <pozic> eu-prleu-peupeu1: I doubt many Haskell users have such a GPGPU card.
15:14:33 <dino-> If anyone has a few minutes, I'm having some confusion with WriterT: http://hpaste.org/9296
15:14:51 <dolio> @type (error :: String -> String) (fix error)
15:14:51 <lambdabot> String
15:14:54 * Beelsebob giggles at enormous storm of doom
15:14:57 <dolio> @type fix error
15:14:57 <lambdabot> [Char]
15:15:44 <dino-> This code runs. It's not doing anything with that dateStamp :: IO String, but that's the problem. What if I'd like the logMsg actions to each also log the date stamp.
15:16:27 <roconnor> pozic: But I see plplot also has a stateful interface, which is one of the things that pisses me off about gnuplot
15:16:52 <roconnor> pozic: putting a non-stateful interface on top of a stateful one is always annoying.
15:16:54 <newsham> byorgey: too bad.  thats always the most disruptive thing about changing jobs :)
15:18:28 <Cale> dino-: Well, you can do something like  liftIO (show . getClockTime)  and prepend that to the log string.
15:18:48 <Cale> er
15:18:50 <dino-> Cale: But that would be down in the Log () actions..?
15:19:06 <dino-> I'd love to make it so that each time logMsg is called, it can attach the time then.
15:19:12 <Cale> fmap show (liftIO getClockTime)  rather
15:19:25 <Cale> modify logMsg to do it
15:19:26 <monochrom> dino-: I'm guessing you could try: logMsg s = do { t <- liftIO dateStamp; tell (t : [s]) }
15:19:38 <rwbarton> Well, you'd need to change the type of logMsg of course, to something like String -> Log ()
15:19:43 <newsham> show <$> liftIO getClockTime ?
15:20:52 <dino-> Wow, I thought I had done that with the liftIO
15:21:00 <ddarius> liftIO getClockTime >>= fmap pure show
15:21:11 <dino-> Ah, left the type sig there for logMsg
15:21:22 <dino-> Which it very much does not like
15:21:25 <monochrom> Yes it's too general.
15:21:42 <roconnor> wow
15:21:47 <roconnor> fix error is pretty scary
15:21:52 <monochrom> hehe
15:22:01 <ddarius> :t \getClockTime -> liftIO getClockTime >>= fmap pure show
15:22:01 <lambdabot> forall a (m :: * -> *). (Show a, Applicative m, MonadIO m) => IO a -> m String
15:22:13 <newsham> ?type fix error
15:22:14 <lambdabot> [Char]
15:22:18 <newsham> > fix error
15:22:25 <mauke> newsham: do it in ghci
15:22:25 <tromp> :t error
15:22:26 <lambdabot> forall a. [Char] -> a
15:22:33 <lambdabot>  thread killed
15:22:37 <newsham> which module has fix?
15:22:41 <monochrom> You have to do it in your own ghci to marvel at the magnificience.
15:22:42 <mauke> Data.Function
15:22:44 <roconnor> Control.Monad.Fix
15:22:46 <ddarius> @index fix
15:22:46 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
15:22:54 <dino-> I wonder if I won't need that FlexibleContexts after making it :: (MonadIO t, MonadWriter [String] t) => String -> t ()
15:23:14 <dino-> Thank you very much. I was seriously confused by the inability to lift earlier. :/
15:23:19 <ddarius> :t \getClockTime -> lift getClockTime >>= fmap pure show
15:23:20 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad (t m), Show a, Applicative (t m), Monad m, MonadTrans t) => m a -> t m String
15:24:08 <roconnor> ;( someone has been sending me a piece of spam every 5 minutes.
15:24:17 <newsham> filter
15:24:19 <monochrom> use spam filter
15:24:29 <ddarius> Hunt them down and kill them.
15:24:32 <newsham> > filter spam
15:24:33 <lambdabot>   Not in scope: `spam'
15:24:38 <mauke> ``··´´
15:24:41 <byorgey> once you get a read on the period you can use a timed filter
15:24:44 <monochrom> bayesian filter is great for repetitive spams.
15:24:48 <roconnor> One spam filter marks it as possible spam so that the next spam filter doesn't see it as spam
15:24:51 <roconnor> *sigh*
15:24:57 <roconnor> I'm going to stop using email.
15:25:19 <newsham> just write a manual filter
15:25:48 <newsham> we have the technology
15:26:11 <ddarius> Just use a whitelist and ignore everyone else.
15:29:05 <lilachaze> > filter (not . spam) fetchEmail
15:29:05 <lambdabot>   Not in scope: `fetchEmail'
15:29:06 <roconnor> ddarius: I've been thinking of that
15:29:27 <monochrom> Milder is use a whiltelist and quarantine everyone else.
15:30:39 <dino-> I use spamassassin and have pretty excellent results. I have to train it maybe for a few days or a week on some problematic spam, But eventually it gets it.
15:30:51 <roconnor> dino-: what interface do you use to train it?
15:31:01 <monochrom> Add a bayesian filter to that to reduce manual work, i.e., ignore those clearly spams.
15:31:34 <dino-> just a sec..visitor at desk
15:31:57 <roconnor> some of these filters seem to "auto-learn" which I find to be a frightening concept, but maybe I simply don't understand it.
15:33:15 <monochrom> It is not frightening if you get to say "you learned wrong about this email, unlearn it"
15:34:15 <vovik> but you have to digg through your spam folder for that
15:34:28 <mauke> -g
15:35:23 <r3m0t> > map (read::String->Int) . words $ "1 2 3 4" -- what's a faster version of this
15:35:27 <lambdabot>  [1,2,3,4]
15:35:37 <roconnor> I've never seen an interface to train spamassassin
15:35:44 <roconnor> where are they?
15:35:44 <monochrom> If you set the threshold right you never look at the spam folder.
15:35:54 <ddarius> > map digitToInt . filter isDigit $ "1 2 3 4"
15:36:01 <lambdabot>  [1,2,3,4]
15:36:23 <roconnor> > [1,2,3,4]
15:36:24 <lambdabot>  [1,2,3,4]
15:36:25 <gwern> hum. this is strange. so the package smallcheck exports a module SmallCheck, and if I use import SmallCheck, I get cabal messages about SmallCheck being hidden. but if I edit smallcheck to export Test.SmallCheck and import that, things work. hum
15:36:56 <r3m0t> roconnor: ha ha ha, nice
15:37:54 <monochrom> "10 20 30 40" will do wonder
15:38:20 <Philippa_> r3m0t: OOI, what do you need it for?
15:38:22 <dino-> roconnor: What I do is move all spam I see in my inbox daily to a folder called 'learn'
15:38:46 <dino-> I have a cron job running a small sh script that does some awk trickery I found on the web somewhere to prep that for sa-learn --spam
15:38:46 <monochrom> (On The Sorry State of Affair Of Exposition By Examples)
15:38:47 <rwbarton> r3m0t: The faster version is probably to have used ByteString for your IO
15:38:52 <Philippa_> you can probably improve it using reads
15:38:59 <roconnor> dino-: ok
15:39:07 <dino-> Which is a tool that comes with sa for training it
15:39:24 <easytige`> how would i improve the following line to combine the flip functions better:
15:39:25 <dino-> sa also marks each email that it thinks is some kind of spam with a header like: X-Spam-Level: *****
15:39:33 <Philippa_> rwbarton: that doesn't do masses for the parsing problem, and loses you read
15:39:35 * ddarius just uses GMail and has only ever had one false positive and a handful of false negatives.
15:39:36 <dino-> More stars, more spammy
15:39:50 <dino-> So I have some procmail filtering on like 8+ stars -> right to /dev/null, you bastard
15:39:53 <easytige`> > horse_check_3 = above (sideBySide horse white_horse) (flipV (flipH(((sideBySide horse white_horse)))))
15:39:53 <lambdabot>  Parse error at "=" (column 15)
15:40:03 <rwbarton> Then I usually build something out of readInt and unfoldr
15:40:29 <monochrom> Of course the regex is not going to read "********", it should be "\*\*\*\*\*\*\*\*" :)
15:40:34 <dino-> Sorry, that cron job takes the entire contents of that learn mail folder, trains with it and removes the mail from it.
15:40:39 <dino-> So every morning, learn is empty and waiting for more
15:41:02 <dino-> That's what the awk trickery is, I have to learn the first email for [al]pine I think
15:41:10 <mauke> \*{8}
15:41:26 <dino-> monochrom: yes, have to escape those
15:42:12 <dino-> It seemed like a good idea to make training as easy (for me) as moving to another folder. Since I'm in the mail client reading this crap.
15:42:23 <monochrom> Yes absolutely.
15:43:18 <Nafai> dino-: I do a similar thing, but my shell script uses fetchmail to get the mail from the local IMAP server and then pipes it to sa-learn
15:43:19 <vincenz> lispy: :)
15:44:38 <dino-> Nafai: I use fetchmail too but do the sa step in procmail. Which I use for a pile of other filtering to various places.
15:44:47 <lispy> vincenz :)
15:44:48 <dino-> procmail is neat, you can do a lot of cool things with it
15:45:12 <dino-> But I do use fetchmail to get from my POP, ya
15:45:15 <monochrom> formail is great for forging mail  *duck* :)
15:45:19 <lispy> When I used procmail I wrote my own language embedded in Haskell to generate the recipes...
15:45:25 <dino-> :D
15:45:26 <Nafai> I use procmail too
15:45:36 <lispy> ?where autoproc
15:45:36 <lambdabot> I know nothing about autoproc.
15:45:41 <lispy> lambdabot: you're amnesic
15:46:12 <lispy> ?google autoproc _darcs
15:46:13 <lambdabot> No Result Found.
15:46:17 <monochrom> lispy you're clever :)
15:46:49 <lispy> monochrom: not really, I just got sick of screwing up my procmail receipes with their infernal syntax of obfuscation
15:47:37 <lispy> ?where+ autoproc http://projects.codersbase.com/repos/autoproc/
15:47:37 <lambdabot> It is forever etched in my memory.
15:47:42 <dino-> lispy: It really is, too. There's a group of things I modify so infrequently that I need to read man pages every time. procmail, fetchmail too, sudoers
15:47:46 <gwern> oh, I suddenly realized why ghci was being screwed up for me
15:47:52 <gwern> I was using ':m + SmallCheck'
15:47:54 <lispy> lambdabot: s/forever/until I reboot/
15:48:03 <gwern> but :m apparently now expands to :main, not :module
15:48:05 <gwern> duh
15:49:50 <hml> is there an IO function for equiv of C's exit()
15:50:30 <monochrom> System.exit IIRC
15:50:43 <mauke> @index exit
15:50:43 <lambdabot> bzzt
15:50:46 <mauke> @index exitWith
15:50:46 <lambdabot> System.Exit
15:50:48 <vincenz> lispy: saw your comment earlier
15:50:53 <gwern> I wonder whether 'error' has an exit status of 1
15:50:56 <hml> <interactive>:1:0: Not in scope: `exit'
15:50:56 <hml> Prelude System>
15:51:00 <lilachaze> @index exitWith
15:51:00 <lambdabot> System.Exit
15:51:10 <hml> exitWith 0
15:51:11 <lispy> vincenz: I figured :)
15:51:11 <lilachaze> hmm, too late ;-)
15:51:58 <dino-> roconnor: At the risk of adding to your bad email pile, I could send you an email with the script I was talking about, and some other info like what I have in my crontab and .procmailrc and yada
15:53:26 <lilachaze> > runST . unsafeIOToST . exitWith $ ExitSuccess
15:53:27 <lambdabot>   Not in scope: data constructor `ExitSuccess'
15:57:15 <EvilTerran> i don't know if you're even allowed ST
15:57:20 <EvilTerran> > runST (return True)
15:57:21 <lambdabot>  True
15:57:24 <EvilTerran> ah, k
15:57:43 <lilachaze> looks like that \bot loophole's been fixed
15:58:40 <gwern> hm. if I forkIO and in the thread cd to /tmp, does the whole program cd?
16:01:10 <ihope> @type runST . unsafeIOToST . exitWith
16:01:10 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
16:01:25 <ihope> > runST . unsafeIOToST . exitWith
16:01:26 <lambdabot>   Not in scope: `exitWith'
16:02:10 <lilachaze> gwern: probably. haskell threads /= os threads. try it ;-)
16:02:33 <lilachaze> and the cwd might well be per-process anyway
16:02:52 <ihope> > runST . unsafeIOToST
16:02:54 <lambdabot>   Not in scope: `unsafeIOToST'
16:02:58 <ihope> Yay.
16:03:04 <gwern> I ask because I'm wondering how slow cding to /tmp is; would it be faster to fork it off?
16:03:52 <gwern> (argh, so frustrating waiting on darcs push before I upload a mueval which supports smallcheck)
16:04:19 <gwern> ok, so that's done. excellent
16:04:24 <gwern> mueval now does smallcheck
16:04:54 <gwern> (the last step is just qualified imports & persistent state, but I've no idea how to do those, so it's time to take a break and watch some simpsons)
16:04:55 <dcoutts_> gwern: good job
16:05:31 <dcoutts_> where as I've been hacking on making cabal-install put binaries somewhere sensible by default
16:05:40 <dcoutts_> without overwriting anything precious
16:05:49 <dcoutts_> and also the new hackage-server prototype
16:06:32 <dcoutts_> which now does pretty much everything the existing hackage does, except let you upload or download package tarballs :-)
16:08:39 <bwr> hopefully soon i'll know haskell well enough to actually do something useful
16:08:40 <bwr> :P
16:08:52 <bwr> i am trying to implement force directed layout currently
16:09:23 <lowki> can i accept a list of functions as an argument?
16:09:47 <bwr> lowki: i would think so, but i think all the functions will probably have to be of the same type?
16:09:52 <bwr> let me try this
16:10:04 <lowki> k
16:10:31 <bwr> @type [(+x)|x<[1..10]]
16:10:32 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
16:10:44 <bwr> oops
16:10:48 <bwr> @type [(+x)|x<-[1..10]]
16:10:51 <lowki> yea they can all be the same type. something like String -> [String] -> String
16:10:55 <lambdabot> forall a. (Enum a, Num a) => [a -> a]
16:11:08 <RayNbow> "Plus Erlang has the benefit of (Mr. Kite, there will be a show tonight) actually being used in a real world scenario vs Haskell's theoretical usage." <-- ugh...
16:11:34 <bwr> is that what you need?
16:11:40 <BMeph> RayNbow: Just one? ;)
16:11:52 <r3m0t> that reminds me, I still haven't listened to "For the benefit of Mr Kite" today
16:11:56 <r3m0t> err, anyway.
16:12:06 <lowki> well what would be the type of a function that accepts a list of functions?
16:12:10 <lowki> [t] ?
16:12:28 <RayNbow> BMeph: it probably depends on the definition of real world scenario :p
16:12:31 <mauke> [a -> b] -> c
16:12:32 <r3m0t> lowki: [a -> b] -> Outputtype
16:12:41 <rwbarton> @type foldr (.) id -- for example
16:12:42 <lambdabot> forall a. [a -> a] -> a -> a
16:12:44 <lowki> o okay
16:12:46 <r3m0t> lowki: or maybe a -> a if you want
16:12:49 <BMeph> ...and mauke wins by a nose! ;)
16:13:00 <dons> RayNbow: where was that?
16:13:03 <lowki> alright wonderful thanks i'll go try it out
16:13:06 <lowki> :)
16:13:09 <RayNbow> dons: http://www.reddit.com/r/programming/comments/6u3ii/paranoia_over_parallelization_in_c_and_thoughts/c04vgj9
16:13:11 <lambdabot> Title: duckfoo comments on Paranoia over Parallelization in C# and thoughts on 4.0, http://tinyurl.com/56vn8h
16:13:26 <mauke> [list -> function] -> arrow
16:15:35 <stepcut> anyone know why plugins is giving me this error when calling 'load' after 'makeAll'
16:15:37 <stepcut> <interactive>: Template1.o: unknown symbol `Dep1_f_closure'
16:15:37 <stepcut> *** Exception: user error (resolvedObjs failed.)
16:16:03 <stepcut> Template1 depends on 'f' which is defined in Dep1. Both files are in the same directory.
16:16:59 <erikc> "We all need to improve our skills..." is the only relevant sentence fragment in the article
16:19:08 <lowki> can main declare a global variable?
16:19:29 <stepcut> lowki: no
16:19:32 <hackage> Uploaded to hackage: mueval 0.5.1
16:19:32 <hackage> Uploaded to hackage: show 0.3
16:19:58 <lowki> hmmm
16:20:14 <stepcut> lowki: I don't think you can in C either, right ?
16:21:17 * stepcut figures out that 'load' does not looking in . unless you explicitly tell it to
16:21:27 <Shiruka> hm? "CPU speed no longer increases" <-- is this true?
16:21:39 <erikc> nope
16:22:21 <erikc> unless he is only referring to clock rate
16:22:28 <EvilTerran> he is, i think
16:22:34 <erikc> in which case, its been pretty stagnant
16:22:40 <EvilTerran> individual cores aren't gonna get much faster
16:22:51 <Shiruka> clock speed != individual core speed
16:22:58 <RayNbow> I recently watched a talk by Joe Armstrong that included a slide on the CPU clock rate
16:23:07 <RayNbow> and that it kinda stopped around 2002
16:23:23 <RayNbow> (or well, the increase of speed changed)
16:23:44 <erikc> they can always add better instructions, bigger caches, branch prediction tables
16:23:46 <RayNbow> http://www.infoq.com/presentations/erlang-software-for-a-concurrent-world <-- this talk
16:23:48 <lambdabot> Title: InfoQ: Erlang - software for a concurrent world, http://tinyurl.com/5wafvr
16:23:49 <monochrom> Ha, "the clock stopped in 2002", great news headline :)
16:23:54 <Cale> Moore's law has been holding up.
16:24:17 <RayNbow> the problem is that the you can't always reach the whole chip within a single clock cycle
16:24:18 <Shiruka> speed of single-threaded execution has increased for quite a while since the clock rate stopped increasing, but it can't hold on forever.. I haven't been following, so I wouldn't know if we already hit a barrier there :-)
16:24:18 <erikc> today's 2.5 ghz wolfdale will smoke 2004's 3 ghz p4
16:24:46 <erikc> the 3 ghz wolfdale's also overclock to 4 ghz pretty easily
16:24:56 <Shiruka> but moore's law is about the transistor count, and you can use that for more cores and cache, too
16:25:41 * Cale wants to see 1024-core processors. :)
16:25:51 <erikc> and theres always specialist areas you can use more transistors to innovate
16:25:56 <erikc> power6's hardware decimal floating point
16:25:59 <erikc> for example
16:26:00 <Cale> Or how about a billion cores? :)
16:26:15 <ddarius> Cale: Get a connection machine and use a 64th of it.
16:26:30 <dolio> Psshh. Billion isn't a power of two.
16:26:47 <luite> neither is 3, and you can buy triple core cpu's :)
16:26:49 <Shiruka> it's a power-of-two billion of course!
16:26:54 <Stinger> 2^30
16:27:01 <Cale> dolio: Of course by billion I mean 2^30
16:27:09 <dolio> Ah. Of course. :)
16:27:11 <luite> but those are quad cores with one disabled
16:27:48 <Cale> CPU meter programs will look rather different by then
16:28:09 <luite> either that, or you'll need huge monitors ;)
16:28:21 <dolio> I don't actually see much reason why you couldn't have billion-core chips.
16:28:28 <Shiruka> the "not quite power of two" situation is likely to become more common when you have more cores
16:28:43 <dolio> You don't have to have a power-of-2 x power-of-2 layout.
16:29:05 <Shiruka> or at least you'd think so.. because surely the probability of some of them being defective must be higher
16:29:18 <RayNbow> it kinda depends on the interconnection network
16:29:54 <dolio> Does that mean that yield of overall usable chips increases?
16:30:00 <luite> Shiruka: why? I'd think that disabling non-functional cores in such a huge/complex chip could increase the yields dramaticallly. you could sell the chips by number of working cores instead of clock frequency
16:30:06 <Cale> Well, up to around about a million or so cores, you could display something which used a pixel to display the usage on each core :) (of course, perhaps display technologies will get better too ;)
16:30:13 <dolio> Since a defect can be fixed by turning off a portion of the chip, instead of scrapping it?
16:30:32 <Shiruka> luite: why what?
16:30:57 <Shiruka> seems like what you wrote is exactly what I had in mind :-/
16:31:05 <luite> Shiruka: oh sorry, my mistake
16:31:28 <Shiruka> dolio: yeah
16:31:49 <dolio> That's handy, I guess.
16:32:13 <lispy> When GHC cannot deduce a type class instance is it also possible that the instance doesn't exist?
16:32:20 <lispy>    Could not deduce (Patchy (PatchInfoAnd p),
16:32:27 <Cale> lispy: yes
16:32:29 <dolio> Of course, I don't know how much stuff chip companies throw away in that way.
16:32:49 <adu> hi shapr
16:32:53 <erikc> ps3s ship with one disabled spu for yield purposes
16:32:54 <lispy> Cale: okay...this problem is interesting
16:32:58 <Cale> lispy: but usually it means that your explicit type signature is not constrained enough
16:33:11 <Shiruka> if it's cheaper to produce them with a higher defect rate, then it would make sense to do so if you have such a recovery method :-)
16:33:17 <lispy> Cale: Yeah, in this case I can't find the instance it's asking for, so I'm left wondering
16:33:25 <adu> erikc: "yield purposes"
16:33:27 <adu> ?
16:33:40 <erikc> if one spu is bad, the chip is still good
16:33:41 <Cale> lispy: Apparently the code you've provided makes use of that instance somehow?
16:34:22 <lispy> Cale: hmm..and I improved my grep and now I see that the type class I request should imply the instance that can't be deduced...
16:34:46 <lispy> Cale: Well I'm calling a function which requests two type classes, neither of which actually appear in the error message
16:35:15 <Shiruka> Cale: btw, funny of you to mention making a correspondence between pixels on a screen and cores
16:35:25 <Shiruka> since screens these days have dead pixels too :-)
16:35:41 <Shiruka> very similar to the idea of allowing dead cores..
16:35:58 <Cale> Shiruka: I was thinking that :)
16:36:07 <Cale> lispy: hmm
16:37:31 * Shiruka would like a zillion-core processor too.. would be a very hackable toy
16:38:24 <lispy> Cale: it's hard to show you an example
16:38:58 <Cale> Shiruka: If everyone had such processors, there would be no choice but functional programming :)
16:39:11 <lispy> Cale: I have this: src/Darcs/HopefullyPrivate.lhs:instance RepoPatch (p C(x y)) => Patchy (PatchInfoAnd (p C(x y)))
16:39:16 <Cale> (well, at least imperative wouldn't get you very far)
16:39:19 * stepcut wonders if storm is functional..
16:39:21 <dons> there'd be no choice but map and fold :)
16:39:35 <lispy> Cale: so, RepoPatch should imply Patchy (PatchInfoAnd p ...), right?
16:41:33 <ddarius> Instead of a billion cores, why not a billion chips?
16:41:48 <RayNbow> Cale: why? what if I wanted to run a zillion old single-threaded applications simultaneously? :p
16:41:54 <Cale> RayNbow: heh
16:42:01 <bfrog> so learning haskell, it seems like an amazing way to program coming from the land of OO and procedural. I've heard functional does well with multicore stuff, whats the reasoning behind that?
16:42:20 <lispy> bfrog: purity
16:42:30 <Trinithis> What's the syntax for importing a module defined in a lower directory?
16:42:40 <bfrog> lispy: and what do you mean by that?
16:42:53 <lispy> bfrog: purity is the opposite of mutability
16:42:57 <bfrog> ah
16:43:22 <Cale> bfrog: It's because updates to state going on in parallel make the behaviour of programs nondeterministic -- the order in which updates occur suddenly can drastically affect the path that the code takes.
16:43:30 <lispy> bfrog: that principle also allows the run-time to do optimizations based on sharing values
16:43:58 <bfrog> that makes a lot of sense
16:44:02 <Shiruka> the way I see it, it's not that mutability makes parallelism impossible, it just makes it more difficult than necessary in many cases
16:44:04 <sal23> lispy: wouldn't using say, monads for continuation, force sequential execution, and make the program hard to scale....I am thinking Amdahl's law
16:44:21 <Shiruka> functional programming could be seen as a sort of extension of the unix pipes approach to parallelism
16:44:36 <lispy> sal23: I'm not very good with continuations and I also, don't know amdahl's law so I can't comment
16:44:45 <Cale> So if you start with a language that initially has no state and gradually add restricted forms of state where needed, you're in a much better position than starting out from lots of state updates and having to prove to yourself that there's really no way they could interfere with one another.
16:45:14 <RayNbow> lispy: Amdahl's law basically says the speedup of a program is determined by the sequential fraction of your program
16:45:17 <bfrog> with that in mind... functional programming lends itself well to the road ahead in terms of hardware
16:45:25 <RayNbow> s/determined/limited
16:45:27 <ddarius> Shiruka: Mutability makes programming in general more difficult than necessary in many cases.
16:45:27 <bfrog> or well seems to
16:46:25 <ddarius> @google butera paintable computing
16:46:26 <Cale> bfrog: yeah
16:46:26 <roconnor> @free swap :: (a,b) -> (b,a)
16:46:26 <lambdabot> http://www.media.mit.edu/resenv/pushpin/paintable.html
16:46:26 <lambdabot> Title: Pushpin Computing
16:46:26 <lambdabot> $map_Pair g f . swap = swap . $map_Pair f g
16:46:27 <lispy> sal23: but you could still take any maps in the program and do them in parallel :)
16:46:30 <sal23> lispy: Amdahl's law is 1/( (1-P) + P/S)), P =%age program spends in parallel execution, S = %age in sequential execution ..
16:46:34 <Cale> bfrog: personally, I think it's inevitable.
16:46:55 <sal23> so, 1/(1-0.12) = 1.136 => parallelizing program will give speedup of 1.136 at max
16:47:14 <Trinithis> Is there any way do do something like : import ../Instruction
16:47:16 <bfrog> well in my brief, several hours to a day looking at haskell, it seems like a new way of thinking about certain problems may be necessary, but it also seems like it'd be harder to screw stuff up
16:48:01 <Cale> sal23: Amdahl's law says more, I think, about why it's not smart to try to take a program and just automatically discover code paths which are independent and run them in parallel.
16:48:19 <Shiruka> Cale: in a sense, I think that we will never (where never is, say, 100 years - a computing-time "never" :-P) get completely rid of imperative programming
16:48:36 <Shiruka> simply because you get so good single-threaded performance with it
16:48:57 <Shiruka> but you can use it to make easier to use (pure/monadic) primitives
16:49:02 <Cale> Shiruka: there's no reason that you can't get such good single threaded performance with functional programming.
16:49:15 <sal23> Cale: hmm....interesting
16:49:24 <Pseudonym> Imperative programming _may_ be relegated to being a niche tool, like assembler today.
16:49:28 <lispy> imperative is a useful way to think though
16:49:47 <lispy> So, I find it hard to believe people will abandon an entire way of thinking
16:50:02 <Pseudonym> There's precedent for abandoning entire ways of thinking.
16:50:30 <lispy> Pseudonym: but isn't it usually based on what is useful?
16:50:41 <bfrog> is there a widget toolkit that uses functional programming though? that seems to lend itself well to OO
16:50:58 <dolio> There are many.
16:50:59 <lispy> Like, the earth being flat or the center of the universe isn't useful, so I can see why they were replaced by ideas that are
16:51:02 <bfrog> I saw there was a wrapper for gtk+
16:51:11 <johnnowak> the future might be in languages that can be viewed as both imperative and functional, like concatenative languages
16:51:27 <roconnor> oh gawd, MetaOCaml!
16:51:34 <roconnor> so many meta levels.
16:51:36 <Cale> bfrog: That's probably the most practical thing to go with for the time being, unfortunately.
16:51:37 <Pseudonym> bfrog brings up an important point with OO.
16:51:42 <lispy> bfrog: Haskell can embbed OO concepts, though we usually only borrow the most tame.
16:51:55 <Pseudonym> I _hope_ that some day people rediscover OO languages rather than the mostly procedural OO hybrids we have today.
16:52:08 <Pseudonym> It'd be nice to have a modern Smalltalk or Eiffel.
16:52:14 <Cale> bfrog: There were/are some interesting functions approaches to user interfaces, but nothing so comprehensive and well-maintained.
16:52:16 <Pseudonym> Or a strongly-typed Erlang. :-)
16:52:19 <Cale> functional*
16:52:36 <lispy> Pseudonym: how do you feel about dylan?
16:52:41 <Pseudonym> With my futurist hat on, though, I think that the future is muti-language.
16:52:47 <Pseudonym> lispy: I like his early stuff.
16:52:56 <johnnowak> oi
16:53:00 <lispy> Pseudonym: haah, I meant the language and probably mispelt it
16:53:12 <Pseudonym> To be honest, I haven't played with it.
16:53:22 <Pseudonym> The last OO language that I liked was Modula-3.
16:53:29 <Pseudonym> Though I've heard nice things about Delphi.
16:53:31 <lispy> Pseudonym: I was given the impression it's a very dynamic OO for the thinking programmer
16:53:56 <ddarius> Amorphous computing produces such pretty pictures.
16:54:05 <Shiruka> it's interestC[C[C[C[C[C[C[C[C[C[C[C[C[C[Cing that even now there's so much that is no longer performance-critical.. that limits the usefulness of parallel programming somewhat (if it's fast enough, no need to parallelise)
16:54:14 <bfrog> Pseudonym: well, multi-paradigm languages seem to win often, especially if they have a bridge to something most people know...
16:54:15 <Philippa_> ddarius: molten cases?
16:54:17 <stepcut> is there is more idiomatic way to express this with out using case: maybe (return ()) print (Just "hello")
16:54:18 <Shiruka> :-O where did that C[C[C.. thing come from
16:54:41 <bfrog> not that I've been around that long with an interest in this stuff to know, but looking at whats popular...
16:54:46 <Pseudonym> bfrog: Indeed.  The problem is that multi-paradigmness seems to be discovered rather than planned.
16:54:54 <Philippa_> Pseudonym: I take it Squeak isn't your idea of a modern Smalltalk?
16:55:18 <Pseudonym> Philippa_: Only in the same sense that Scheme is a modern Lisp.
16:55:35 <bfrog> Pseudonym: python seems to do a decent job of covering them
16:55:51 <bfrog> from what I've seen of things anyway, which is minimal as I said
16:55:58 <Pseudonym> Hardly.
16:56:06 <Pseudonym> Python is very much not typeful.
16:56:08 <lispy> bfrog: python is very weak in the FP category, I can't comment on the OO aspects
16:56:24 <Pseudonym> Python has the standard "scripting OO" model.
16:56:30 <Pseudonym> Like Perl only built-in.
16:56:56 <Pseudonym> But it doesn't have generic, generative or functional programming support worth much.
16:56:58 <lispy> This word we use, "scripting" I don't know what it means anymore.
16:57:10 <Shiruka> lispy: why "very weak"?
16:57:33 <Pseudonym> lispy: I think that "scripting" is essentially a synonym for RAD these days.
16:57:41 <Pseudonym> With an EDSL flavour.
16:57:43 <ddarius> Philippa_: See the link I googled earlier.
16:58:12 <ddarius> stepcut: print "hello"
16:58:14 * Shiruka usually doesn't try to twist programming languages to patterns unnatural in the language
16:58:15 <bfrog> Pseudonym: well it is considered a scripting language, but it also does do byte code compiles. And if an llvm frontend for it shows up...
16:58:25 <stepcut> ddarius: :(
16:58:31 <lispy> Shiruka: Well, It's hard to write a program in python that is a series of transformations involving functions and higher order functions
16:58:56 * stepcut ponders
16:58:58 <hml> what's the intuition behind Left to indicate error and Right to indicate normal execution?
16:59:22 <dolio> Right is the right answer.
16:59:27 <lispy> hml: if it was the other way around, how would you make the instance for MonadError?
16:59:28 <Cale> hml: Well, it's somewhat forced by limitations of the type system, but if you want a mnemonic, ^^
16:59:38 <dolio> Also, the Functor/Monad/etc. instances wouldn't work right if it were the other way.
16:59:48 <ddarius> It actually has to be that way unless you want Left :: a -> Either b a
16:59:54 <Pseudonym> hml: Yes, dolio's explanation is te way that I remember it.
17:00:08 <gwern> well, actually, I've been wondering about erlang/haskell - how would you migrate threads around in haskell?
17:00:10 <Pseudonym> fmap :: (a -> b) -> (Either c a -> Either c b)
17:00:37 <lispy> As a lefty I'm offended by dolio's mnemonic and english's root for synonims of Correct/Incorrect :)
17:00:45 <Shiruka> lispy: I don't see what's more difficult in it in that respect than in, say, lisp, but it does have a high function call penalty, which may be a problem
17:00:49 <BMeph> Has anyone here ever used Attribute Grammars?
17:01:06 <Shiruka> but trying monads in it would be decidedly clunky.. maybe you could do those in lisp using macros
17:01:12 <EvilTerran> BMeph, er, briefly
17:01:15 <hml> why canit 't be named like the Maybe nomad, i.e. "Just" instead of "Right" and "Erro" instead of "Left" ?
17:01:34 <lispy> hml: that I think is the better question
17:01:35 <EvilTerran> well, you can't have two constructors with the same name of different types
17:01:35 <Botje> because Either isn't always used to flag errors :)
17:01:40 <BMeph> EvilTerran: Briefly by choice, or because you had to concentrate elsewhere? :)
17:01:44 <EvilTerran> and because Either is used for other stuff
17:01:59 <EvilTerran> BMeph, briefly as in they threw it at us in the compilers course at uni
17:01:59 <Cale> hml: also, because Just is taken.
17:02:03 <dolio> lispy: You'd prefer a Picard bifunctor for this use?
17:02:05 <Botje> data Either a b = One a | TheOtherOne b
17:02:25 <lispy> Shiruka: Well, if you want to go that route, there is the issue that a lambda in python, iirc doesn't have the full generality of a normal def
17:02:26 <EvilTerran> but i haven't got round to reading up on them in more depth
17:02:29 <EvilTerran> (although i intend to)
17:02:35 <Cale> data Sum a b = Inl a | Inr b
17:02:47 <Cale> We could have that ;)
17:03:05 <Pseudonym> I'm glad I'm not the only one who thinks that Left and Right are dumb names.
17:03:14 <Shiruka> lispy: true, it allows only expressions, not statements.. but it's just syntactic sugar anyway
17:03:21 <Cale> Pseudonym: what would you pick?
17:03:29 <Pseudonym> Inl and Inr are good.
17:03:32 <Shiruka> (although syntax does matter..)
17:03:33 <lispy> Pseudonym: took me a while to even figure out which type went with which construtor, but then maybe I'm dense
17:03:34 <dcoutts_> data Well a b = OnTheOneHand a | OnTheOtherHand b
17:03:34 <EvilTerran> data Either a b = Either { either :: (a -> c) -> (b -> c) -> c } :P
17:03:38 <Pseudonym> However, I'd question whether we need it at all.
17:04:02 <Cale> EvilTerran: forall c?
17:04:12 <Pseudonym> In my experience, about 80% of the uses of Either are better expressed with a custom type.
17:04:25 <BMeph> lispy: At least the prejudice is on the side of "Right is good" versus "left is bad," e.g. 'Dexter/Sinister'
17:04:26 <Pseudonym> The next 15% are better expressed with a catchable exception type.
17:04:28 <EvilTerran> Cale, yes. i'd need an extension for that type, wouldn't i? =/
17:04:52 <dcoutts_> data MergeResult a b = OnlyInLeft a | InBoth a b | OnlyInRight b
17:05:04 <Pseudonym> And the other 5% are because a generic coproduct seems sensible in a language which relies on category theory so much.
17:05:13 <Shiruka> BMeph: but by the assumption that there's a good/evil dichotomy (standard assumption!), left can be proven evil
17:05:22 <erikc> how do dependently typed languages address handling runtime coercions? exceptions?
17:05:25 <EvilTerran> left = sinister :P
17:05:28 <dcoutts_> Pseudonym: got a better representation for my merge result?
17:05:34 <dcoutts_> mergeBy :: (a -> b -> Ordering) -> [a] -> [b] -> [MergeResult a b]
17:05:44 <dolio> Runtime coercions?
17:05:55 <BMeph> Shiruka: Ah, but you're forgetting the Barbie Hypothesis:
17:06:10 <Pseudonym> dcoutts_: I suspect it depends on what you want it for.
17:06:12 <lispy> dcoutts_: heh, I instinctivly thought that was a darcs merge you were discussing and perked up :)
17:06:13 <EvilTerran> dcoutts_, i don't see a nice simplification for (a + ab + b)
17:06:18 <EvilTerran> thinking about it algebraically
17:06:22 <BMeph> "The more thought is required, the greater the chances of quitting to 'go shopping'" ;)
17:06:29 <dcoutts_> EvilTerran: pity
17:06:36 <Pseudonym> I can't imagine any situations where I'd want that generic mergeBy, though they must exist.
17:06:38 <erikc> dolio: if you have a dependent type like foo(int n, [int > n] x); (pardon the syntax)
17:06:40 <EvilTerran> (a(1 + b) + b) isn't really any nicer
17:06:45 <EvilTerran> and loses the symmetry
17:06:49 <dcoutts_> Pseudonym: oh I find it comes up all the time
17:06:49 <Shiruka> I hope even barbie would able to reason that much (^^;
17:06:55 <Shiruka> +be
17:06:56 <erikc> and the compiler cant statically prove that for all cases
17:07:11 <dcoutts_> Pseudonym: combining data sources, sort both inputs and merge
17:07:24 <dcoutts_> one then usually does a fold over the merge result list
17:08:02 <dolio> erikc: Generally, you'd need to supply the function with a proof of 'x > n', which has to come from somewhere.
17:08:53 <BMeph> Shiruka: willing /= able
17:08:55 <dolio> erikc: At runtime, you'd have something like '[x > n] or [x <= n] test (int n, int x)'.
17:09:03 <erikc> k
17:09:13 <dolio> So you call test, branch on the result, and in one case, you can use foo.
17:09:20 <erikc> right
17:09:39 <Shiruka> BMeph: those who are unable to do math pretend to just be unwilling to do it
17:09:51 <dolio> Of course, if the compiler is sufficiently smart, it can erase all (most?) of the proof shuffling.
17:09:55 <EvilTerran> dolio, you mean writing something like "if x < n then foo(n,x) else <errors>"?
17:09:58 <erikc> right
17:10:32 <BMeph> Shiruka: Pretend? I'm pretty sure that those unwilling to do things (esp. math) aren't "pretending." ;)
17:10:37 <dolio> Sure, although it's not that simple in, say, Agda.
17:10:56 <dolio> Since 'x < n' doesn't refine the types right.
17:11:03 <Shiruka> BMeph: ah, the part being pretended is the "just" part - they pretend to be able to, yet unwilling ;-)
17:11:49 <Shiruka> "I could prove Fermat's Last Theorem if I really wanted to, but it's so tedious that I won't" <-- self-deception
17:11:52 <BMeph> Shiruka: There are plenty of Real-World examples of folks unable to do things, but still willing to try (think "casting call for American Idol," for starters). :)
17:13:07 <ddarius> BMeph: Those people don't realize that they are unable.
17:13:37 <Shiruka> or they really like being laughed at
17:13:42 <ddarius> Dunning-Kruger
17:16:29 <lament> Strong Dunning-Kruger: You need to be able to realize that you're unable.
17:19:15 <Shiruka> is D-K one of the "when you become more skilled, you realize how little skill you have" results?
17:19:34 <ddarius> Shiruka: That's a part of it, but not the main mpart.
17:21:24 <Shiruka> I recall reading about some study where people who suck think they are one of the best and grade their superiors' work as being bad, so I thought it might refer to that :-)
17:22:37 * Shiruka stops being lazy and goes to ask the Holy Internet Oracle
17:23:40 <lament> ZOT!
17:23:44 <heatsink> Is there a guide to communicating with people who don't know haskell?
17:23:49 <BMeph> ddarius: So, are you going to collaborate with edwardk to write a comonadic version of "All About Monads"? Or are you planning on saving yourself for a more "interesting" topic? ;)
17:24:09 <monochrom> "Nothing About Co-Monads"
17:24:13 <dons> heatsink: hmm.
17:24:16 <sw17ch> heatsink, move the parenthesis one word to the right, and sprinkle in commas
17:24:32 <dons> heatsink: there's a "elevator pitch"
17:24:48 <dons> remember, haskell is your secret weapon.
17:24:57 <Shiruka> heatsink: interpret what they say strictly and be lazy about your own answers
17:25:54 <ddarius> BMeph: sigfpe would probably be the best person to do that
17:26:26 <ddarius> heatsink: I usually use English and that works well.
17:26:50 <heatsink> Hmm.
17:27:05 <ddarius> Shiruka: You've probably found it by now, but wikipedia has a decent article with references.
17:27:58 <heatsink> I think the issue goes deeper than that.  Haskell has changed the way I think about programming, independently of the language I'm using.
17:28:23 <lispy> heatsink: grunt once for yes, twice for no
17:28:27 <vixey> heatsink: this is good an expected, but it shouldn't make you worse at progamming in other languages
17:28:39 <Shiruka> ddarius: indeed.. I asked the Holy Internet Oracle, i.e. Google, and its first result was the Holy Interweb Encyclopedia article about it :-)
17:28:40 <heatsink> When you try to explain an algorithm in terms of recursive curried functions, it seems like C programmers try to think about execution order and get hopelessly lost.
17:29:07 <monochrom> I am a C programmer and I don't get lost.
17:29:31 <heatsink> monochrom, but you're also a haskell programmer.
17:29:35 <monochrom> So the real question is how to communicate to someone who haven't raised their own level.
17:29:38 <EvilTerran> nothing-but-C programmers would tend to get a bit lost, i can imagine
17:29:41 * BMeph thinks about telling monochrom... naugh, too easy
17:29:51 <Shiruka> I was most surprised that they got the ig nobel prize..
17:30:05 <Shiruka> I thought that was for silly research only
17:30:16 <monochrom> I already grokked complicated recursions before I learned Haskell. Even before I learned Lisp, SML, Prolog,...
17:30:43 <monochrom> At that time I only had basic and Pascal and C.
17:31:09 <BMeph> "Everything I Needed to Know about Complicated Recursion I Learned in BASIC" ;p
17:31:20 <heatsink> BMeph: GOTO solves all!
17:31:34 <Shiruka> yeah, many newbie programmers don't get recursion
17:31:43 <Shiruka> you need to talk with people who have a bit more experience :-)
17:31:46 * BMeph digs through his papers to re-read "Lambda: The Ultimate GOTO"
17:32:06 <monochrom> Actually it was Pascal for me. But anyway when the class taught recursion in Pascal I was joyful and enlightened. Not confused at all.
17:33:11 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/f2b477068bfc05aa is my account of my encounter with recursion.
17:33:12 <lambdabot> Title: Defence of recursive programming - comp.lang.functional | Google Groups, http://tinyurl.com/59jro6
17:33:28 <BMeph> monochrom: Did you find that being introduced to recursion so early made it tougher to see what the big deal was about continuations?
17:34:03 * lispy imagines Sinfield asking what's the deal with continuations?
17:34:12 * Shiruka was about to ask
17:34:14 <monochrom> So, I still say, the real question is how to communicate with someone who haven't been enlightened.  (And the answer is you likely can't, you have to wait for their own experience to grow.)
17:34:21 <vixey> hehe
17:34:44 <Shiruka> I don't see how understanding recursion would make understanding continuations harder :-/
17:34:59 <dolio> He's saying it makes it easier.
17:35:04 <dolio> But I'm not sure I agree with that.
17:35:05 <lament> the Jesuits have a very different strategy for communicating with heathens.
17:35:17 <Shiruka> ... ah
17:35:38 <dolio> Actually, I don't think understanding what continuations are is too hard.
17:35:44 <monochrom> No, BMeph, when I finally encountered continuation a few years ago it was not a big deal, exciting but not confusing. Caveat: by that time I had already grokked monads, so it was "oh! cont is like monad..."
17:35:49 <dolio> It's understanding what code that uses continuations does that's hard.
17:35:57 <vixey> I do, I think learning about contiunations is extremely hard
17:36:22 * Shiruka learned about continuations with scheme's call/cc and thought they were pretty neat
17:36:34 <EvilTerran> i'm a little confused by the specifics of delimited continuations
17:36:41 * heatsink learned about continuations in... unlambda...
17:36:47 <vixey> I still don't have any practical tools for understanding programs that use reified continuations
17:36:52 <dcoutts_> I still don't understand call cc and I've written several cont monad style things
17:36:54 <heatsink> Actually, maybe it was scheme first.  I forget.
17:36:55 <EvilTerran> and how they differ from passing a callback function
17:37:01 <vixey> you convert to CPS and it's just another confusing mess
17:37:37 <dolio> I don't think working out the CPS conversion is a good way to see what's going on in a program with continuations. :)
17:37:44 <vixey> is there some theory that you can understand them by? Like induction for recursion
17:37:45 <Shiruka> .. CPS is a mess
17:37:58 <EvilTerran> i see the point of CPS
17:38:46 <dolio> Anyhow, my point is that saying "continuations are a first-class representation of 'the rest of the program'" isn't hard.
17:38:58 <monochrom> Normally I suggest "don't think about execution" for other matters, but when it comes to continuations (especially delimited continuations) I suggest thinking about execution (of toy examples), including "let's put away that stack frame, let's re-instate this other previously saved stack frame". I have certainly had much success with it.
17:39:15 <monochrom> In any case, translating to lambda terms certainly doesn't work.
17:39:22 <dolio> But working out what happens in a program that uses them is like figuring out a program with gotos everywhere.
17:39:34 <dolio> Or, it can be.
17:39:35 * Shiruka thinks about execution a lot of the time anyway
17:40:33 <Shiruka> invariants and equational reasoning are nice and all, but in the end there's a machine under all that, executing things in a more-or-less well-specified way :-)
17:40:41 <heatsink> monochrom: Well, your remarks are reassuring in a way. I guess there are no concise answers to the question of how to communicate.
17:41:03 * lispy does a dance as he finally gets tentativelyMergePatches_ to compile after roughly 10 hours of type errors
17:41:15 <lament> heatsink: have a natural talent for teaching.
17:41:23 <monochrom> My strategy is: use cont to implement "break out", understand that it works; use cont to implement "throw and catch exception", understand that it works; use cont to implement python's "yield", understand that it works; use delimited cont to implement ref cells, understand that it works; ...
17:41:56 <lament> monochrom: that's too slow, can i just skip those "understand how it works" bits?
17:41:57 <heatsink> lament: easy to say.
17:42:04 <monochrom> Don't hope for reasoning about arbitrary cont code.  But do understand how it can implement all the constructs you like.
17:42:17 <dolio> You probably want to do that last bit in Scheme.
17:42:25 <Shiruka> without primitives you can get a godawful mess, true.. like misuse of gotos, but gets hairy faster
17:42:27 <monochrom> Oh, I assure you the ref cell part is exciting! :)
17:42:42 <lispy> When I think of how to explain CPS to someone I want to start with, "Well, it should really be called..." Then I think about it and want to answer, "Continuation Passing Style because that's...doh!"
17:42:51 <Shiruka> s/primitives/well-defined simple primitives built on top of cont/
17:43:18 <dolio> If you try implementing ref cells in Haskell, you have to do backflips to fix up the types in addition to just getting the ref cells right.
17:43:33 <lispy> do zippers use CPS?
17:43:36 <lament> CPS is best explained in Basic or Assembly.
17:43:50 * EvilTerran would feel silly doing ref cells by CPS in scheme, seeing as it has mutable structures built in
17:43:52 <lament> or some other language without complicated control structures
17:43:58 <vixey> ref cells.. in terms of letrec ?
17:44:02 <vixey> you can't do that in haskell...
17:44:08 <vixey> can you?
17:44:20 <EvilTerran> ST could be written using only pure code, i believe
17:44:21 <monochrom> Oleg's general zippers use delimited cont too. Try to understand that it works, too.
17:44:22 <lament> then the current continuation is just "the next line in the program"
17:44:26 <EvilTerran> it just wouldn't be as efficient
17:45:07 <dolio> You can implement ST without using unsafeCoerce using multi-prompt delimited continuations in Haskell.
17:45:15 <vixey> I thought a very nice book could be The Little Continuation Passer
17:45:23 <dolio> (Although, that sort of continuation monad uses unsafeCoerce internally.)
17:45:53 <monochrom> (Although, it maintains invariants to make sure unsafeCoerce calls are safe.)
17:45:58 <lispy> grrrr...."Tell GHC HQ if you'd like this to unify the context"
17:45:58 <vixey> dolio: Has anybody done this?
17:46:01 <dolio> Right.
17:46:11 <dolio> Yes, CC-delcont has such a module.
17:46:16 <vixey> great
17:46:19 <dolio> Lifted from Oleg's paper on the subject.
17:46:19 <vixey> thank you
17:46:34 <dolio> Delimited Dynamic Binding, I believe.
17:47:44 <dolio> That paper's probably better if you just want to understand how to implement the mutable cells, since it does it in Scheme as well.
17:47:56 <dolio> In Haskell, you need extra prompts to work the types out.
17:50:11 <dolio> Same with OCaml.
17:51:01 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/51df24fbf33b7059  is my theory of why recursion *seems* hard.
17:51:01 <lambdabot> Title: local variables don't cause side effects - comp.lang.functional | Google Groups, http://tinyurl.com/5brrqc
17:51:03 <ddarius> Moral of the story: types are bad.
17:51:26 <ddarius> recursion seems hard?
17:52:07 <monochrom> Summary is if you're a control freak (you're obsessed with control flow) you'll find it hard.
17:52:08 <infrared> hello, is a function like groupInFives (http://hpaste.org/9297) in the Prelude. maybe except for the 5, it could be any number ;)
17:52:29 <vixey> infrared: we call it chunks
17:52:41 <Shiruka> recursion isn't hard
17:52:50 <Shiruka> it's just that simple iteration is easier (for many)
17:53:01 <ddarius> monochrom: At the assembly level it is completely obvious whether or not you are obsessed with control flow.
17:53:01 <Shiruka> for more complex stuff, iteration gets hairy
17:53:24 <lament> monochrom: "Writing a working loop is swim-or-sink in education and dark magic in practice." almost made me laugh.
17:53:56 <infrared> vixey: chunks? hoogle gives me only some functions on ByteStrings
17:54:22 <vixey> infrared: oh, it's not in any standard library yet :(
17:54:40 <vixey> it should be in Data.List..
17:55:15 <infrared> i see, so should go with the version I have or is there a nicer way?
17:55:24 <vixey> your one is fine
17:55:35 <infrared> ok, thanks
17:55:38 <vixey> I woudl add a parameter so that the function doesn't care about 5 but that's up to you
17:56:04 <infrared> yeah, this way i'd probably get your chunks function :)
17:56:37 <lament> monochrom: and I disagree with "
17:56:44 <lament> (oops, linebreak) Recursion is more handy in solving problems"
17:56:57 <vixey> dolio: did you mean Dynvar?
17:57:04 <lament> monochrom: some problems are naturally recursive, and require recursive solutions; some are iterative and require iterative solutions
17:57:08 <dolio> Yep.
17:57:31 <ddarius> Recursion is more expressive than looping, therefore it most likely is more difficult.
17:57:57 <lament> also that.
17:57:59 <Shiruka> they are equally expressive..
17:58:02 <vixey> recursion has a foundation in mathematics, looping has foundation in flow charts
17:58:23 <monochrom> looping has foundation in recursion.
17:58:23 <Shiruka> the iteration just gets more complex, like a main loop in an interpreter
17:58:27 <lament> looping has foundation in reality.
17:58:53 <lament> consider Earth going around the Sun
17:59:00 <ddarius> Shiruka: In a Turing-complete way yes, in a macro-expressible way, no.
17:59:27 <lispy> lament: er, you mean the othre way around right?
18:00:08 <monochrom> Consider Earth and Sun dancing around satisfying a differential equation.
18:00:42 <monochrom> Differential equation is the analysis analogue to recursion.
18:00:49 <newsham> to iterate is illiterate
18:00:59 <newsham> to recurse is worse
18:01:23 <Shiruka> consider earth and sun staying in a fixed relation except for distance, and the rest of the world dancing around both in a mad way
18:01:41 <Apocalisp> to fold is divine
18:01:54 <newsham> foldr?  i hardly knowr!
18:02:24 <Apocalisp> foldM? Damn near killedM!
18:02:32 * heatsink laughs
18:02:37 <newsham> ?karma+ apocalisp
18:02:37 <lambdabot> apocalisp's karma raised to 1.
18:02:41 <Apocalisp> or was that mapM
18:03:40 <lispy> hrm, I thought an explicit forall made type variables lexically scoped?
18:04:04 <lament> A real-world problem: take all cookies out of a jar. Would you describe its solution recursively or iteratively?
18:04:11 <ddarius> With the appropriate extension, yes.
18:04:36 <ddarius> lament: I describe it in aggregate.  "Take all the cookies out of the jar."
18:05:16 <vixey> do cookie <- jar
18:05:20 <Shiruka> one primitive operation: turn the cookie jar upside down
18:05:24 <Apocalisp> lament: I think the optimal solution is massively parallel.
18:05:26 <vixey>   return cookio
18:05:40 <heatsink> lament: "Take cookies out of the jar until the jar is empty."  I read the "until" clause as a HOF.
18:05:43 <ddarius> vixey's solution is id.
18:05:48 <MyCatVerbs> Apocalisp: it can't be, there's a bottleneck at the opening of the cookie jar.
18:05:58 <Stinger> literally
18:06:06 <lispy> MyCatVerbs: technically it's a jarneck though, right?
18:06:11 <Apocalisp> shatter the jar
18:06:15 <newsham> I have a weird perf question.  i tried out some servers and clients using Socket directly and using Handle (converted from Socket) and the Socket is a little bit faster..  except for my client I just tried out.. its way way way slower with raw Socket.
18:06:23 <newsham> I was wondering if anyone had some insight into why
18:06:31 <ddarius> newsham: Buffering?
18:06:34 <Stinger> IO Error, cookies become corrupted
18:06:41 <newsham> http://www.thenewsh.com/%7Enewsham/store/DummyClient3s.hs is the socket version,  without the "s" is the normal
18:06:41 <Stinger> with glass shards
18:06:43 <heatsink> Put ants in the jar.  The ants will eat the cookies and then crawl away.
18:07:13 <MyCatVerbs> Apocalisp: unsafeSmashJar, which violates the cookies' encapsulation. ;)
18:07:20 <MyCatVerbs> lispy: right, right.
18:07:22 <newsham> ddarius: buffering in terms of?  setsockopt options?  Handle buffering?
18:07:39 <newsham> ddarius: the code is record based so i dont think Handle buffering should matter much
18:07:51 <Shiruka> unsafeEatCookie, which violates the cookie :-)
18:08:01 <monochrom> lament: I don't think anyone really explains it in elaboration in real life.
18:08:23 <Apocalisp> mmm... oatmeal chocolate chip and glass shard
18:08:57 <ddarius> monochrom: Indeed.  Learning to break such things down is one of the early skills one learns when becoming a programmer and not something many people "naturally" have.
18:09:02 <monochrom> Let's say I'm a kid and I hear "take out all cookies" for the first time.  Let's say so far I have known "take out cookie(s)" but not the all part.  So I stare at my mom who has just told me to "take out all cookies".
18:09:26 <monochrom> My mom then says, "yes, honey, take one out first". So I do.
18:09:38 <monochrom> Then my mom says, "continue".
18:09:46 <MyCatVerbs> Shiruka: no, that's perfectly well-defined, eatCookie :: Cookie -> IO Mmmmm. The only time it's unsafe is if you use it with unsafePerformIO, or apply it after someone has done withCookie_ (\cookie -> poison cookie)
18:09:52 <monochrom> Now it's completely ambiguous whether that's recursion or iteration.
18:10:09 <ddarius> monochrom: I think most "moms" would elaborate on the meaning of "all" rather than the process.
18:10:12 <newsham> the weird thing is that my client and server are sharing a lot of the same socket code
18:10:24 <monochrom> Or alternatively if I don't even know "continue", my mom will start exemplifying by action, not by words.
18:10:24 <newsham> but the server seems to run fairly fast in the socket version
18:10:29 <newsham> just the client seems really slow
18:10:33 <lispy> oh, the reason I wasn't getting the lexcal scoping was because I had a nested forall (well, I mean the type sig in the where clause had a forall that was causing problems)
18:11:05 <Shiruka> MyCatVerbs: you wouldn't say that if you were a cookie!
18:11:05 <ddarius> lispy: You were shadowing type variables?
18:11:22 <lispy> ddarius: I think so yes
18:11:26 <ddarius> withCookie_ poison
18:11:28 <monochrom> I think in the end the kid's neural network inclines to recursion or iteration depending on a lot of irrelevant factors and luck.
18:11:29 <lament> monochrom: if you're saying all that in good faith, i'll need several days to rework my argument somehow.
18:11:43 <monochrom> Yes I'm saying that in good faith.
18:12:20 <lament> to me, iteration is entirely natural and recursion is entirely unnatural and i don't see how it could possibly be seen otherwise - primarily because recursion is defined in terms of functions, which are also entirely unnatural
18:12:36 <lispy> To answer the original question of communicating to non-haskell literates, I would recommend body language ;)
18:12:40 <heatsink> lament: How about goals and subgoals?
18:12:45 <ddarius> I think both proponents of iterative programming and proponents of recursive programming can agree that people tend to think in terms of aggregate operations when they are reasonably obvious.
18:12:54 <Shiruka> anyway, the kid is probably iterating instead of recursing.. cursing even once won't be approved by the mom
18:12:57 <monochrom> Mom may also impatiently say "take one", "good, now take one more", "good, now take one more", ....  Again it's still ambiguous whether that's recursion or iteration.  It's recursion if you're already biased towards recursion.  It's iteration if you're already biased towards iteration.
18:13:00 <dmwit> ddarius: yes
18:13:23 <lament> monochrom: that sounds like iteration to me.
18:13:50 <Philippa_> it's just plain sequencing with some repetition in it
18:13:50 <dmwit> lament: sounds like a map to md
18:13:56 <monochrom> It's completely unfolded so whether it was originally recursion or iteration is lost.
18:13:59 <ddarius> What Philippa said.
18:14:15 <dmwit> (i.e. could be done iteratively *or* recursively)
18:14:28 <lament> (going home, later)
18:14:41 <monochrom> What you do as a kid is you try to generalize, reverse-engineer, the unfolded back to a more abstract thing.  So it's you who decide what it is in general.
18:14:47 <newsham> ahh, i found my problem.
18:14:55 <newsham> was doing two sends when i could have done just one.
18:15:11 <monochrom> And what Philippa_ says. :)
18:15:19 <Shiruka> maybe it's a superposition state of iteration and recursion
18:15:27 <lispy> newsham: ah, doing twice the work could certainly change performance :)
18:15:40 <Shiruka> and which one it will eventually be is decided by your religion in later life
18:15:44 <lispy> Are iteration and recursion even different?
18:15:44 <dmwit> Maybe it is a stupid thing to argue about.
18:15:45 <newsham> but the thing that is odd is that the perf really really really went down hill
18:15:56 <newsham> more so than an extra kernel/user crossing should have caused
18:15:57 <newsham> *shrug*
18:16:27 <roconnor> dino-: thanks!
18:16:43 <ddarius> Iteration is a special case of recursion.
18:17:27 <newsham> recursion is just iteration with a stack :)
18:17:53 <monochrom> or a graph of thunks
18:17:56 <ddarius> newsham: True.
18:18:05 <vixey> I don't think so
18:18:14 <dmwit> nornagon: Any news on the libCairo front?
18:18:15 <vixey> how do you translate fibs (double recursion)?
18:18:29 <monochrom> graph reduction. repeat.
18:18:31 <vixey> It'll take a bit more work than one stack
18:18:37 <dmwit> nonsense
18:18:41 <ddarius> vixey: What are you talking about?
18:18:52 <newsham> vixey: same way your computer does it.
18:19:30 <monochrom> f(3) -> f(2)+f(1) -> f(1)+f(1)+f(1) -> 1+1+1 -> 2+1 -> 3   where is my stack?
18:19:56 <monochrom> (there is a typo, some f(1) should be f(0).)
18:20:09 * vixey tries ..
18:20:22 <dmwit> push 3, fib -> push 2, push 1, fib -> etc
18:20:23 <ddarius> monochrom: If you put the parentheses, the stack would be in the terms itself.
18:20:26 <newsham> push 2, jump to f, push 1, jump to f, pop twice, add
18:20:52 <monochrom> No, there is no need for a stack, if my single step says "look for something to reduce once".
18:20:54 <newsham> replace "jump to" with "loop" if you like
18:21:01 <ddarius> newsham: The problem is that to turn recursive code into iterative code + stack is a non-local change and relies on mutation.
18:21:11 <monochrom> But you say, real implementations have stacks.
18:21:22 <newsham> i didnt say it was ideal.  just addressing "iteration is a special case of recursion"
18:21:39 <monochrom> Yes, real implementations don't want to re-search "where is something to reduce".
18:21:57 <MyCatVerbs> monochrom: not necessarily. A number of Schemes don't use stacks at all and use the heap instead.
18:22:03 <ddarius> newsham: But that's -why- I say iteration is a special case of recursion.  It requires no such non-local change to express iteration using recursion.
18:22:10 <monochrom> The stack says "last time you reduce this subexpr so it's a good idea to look for more there again".
18:22:31 <monochrom> The stack is an optimization.
18:22:40 <MyCatVerbs> (Since storing your current continuation on the stack makes it a pain in the arse to implement call/cc, naturally.)
18:22:51 <newsham> ddarius: ok. i get your drift.
18:22:59 <MyCatVerbs> monochrom: not to an old-school assembly programmer. :)
18:23:32 <newsham> you dont need to be old school to assemble
18:23:53 <vixey> http://hpaste.org/9298
18:24:13 <vixey> newsham, how would you write that? (such that it works)
18:25:12 <Shiruka> but with iteration (assuming we have mutation too), you can keep the stack in memory as an object, and reason about the process as a transition rule + time
18:25:21 <adu> monochrom: whats your definition of iteration?
18:25:38 <Shiruka> it's not necessarily unnatural way to think (depending on the problem)
18:25:48 <vixey> is the suggestion that recursion is iteration with a stack actually the claim:  It's possible to write an interpreter for a language with iteration using recursion
18:25:54 <vixey> ?
18:25:56 <monochrom> I am not sure I am understood and convincing, so let me take some time to exemplify with 1+(2+(3+4)).
18:25:57 <ddarius> vixey: Have you learned a (real) assembly language?
18:26:03 <vixey> ddarius: No
18:26:10 <adu> monochrom: and by the way, have you heard of the Ackermann function?
18:26:26 <monochrom> I look for something to reduce.  E.g., I look at "1", and say "that's already reduced", and I keep looking.
18:26:33 <ddarius> vixey: Learn one.
18:26:40 <vixey> ddarius: Why?
18:26:58 <monochrom> I look at "1+(...)" and I say "that has to be reduced, but I need to dive into the (...) first".
18:26:58 <ddarius> vixey: It's a beneficial perspective for any programmer.  (and it is fun)
18:27:18 <monochrom> Now, you think I need a stack to "remember where I was", but I won't do it.
18:27:35 <newsham> vixey: make your stack differentiate betwen calls and returns (ie. push a 0 for calls then the args,  or a 1 for returns then the return value)
18:27:39 <ddarius> monochrom: As I said, essentially the "stack" is the term itself.
18:27:43 <newsham> then have your code do what it is doing now for the call
18:27:51 <monochrom> OK cool, then I can stop.
18:27:57 <adu> monochrom: that is neither recursion nor iteration, but evaluation
18:28:00 <newsham> and for the return case, have it pop two numbers, add them, and push 1 and a result
18:28:07 <vixey> newsham, ok, so really the claim that an iterative interpreter exists which runs recursive programs
18:28:09 <MyCatVerbs> newsham: no, but only oldschoolers would think of the hardware stack as an abstraction. ;P
18:28:47 <ddarius> vixey: Or ignore newsham and think about how function calls (recursive or otherwise) work.  They push a return address, jump to the code, and pop the return address on return and jump to it.
18:28:52 <newsham> mycat: struct ActivationFrame { .. }
18:29:39 <ddarius> You could (vaguely related to what newsham was suggesting) encode the return addresses into some numbers.
18:29:50 <monochrom> adu: The question of interest is "is your evaluator iterative or recursive?"
18:29:54 <newsham> or an enum, or whatever
18:30:11 <ddarius> (This actually corresponds almost exactly to defunctionalizing the CPS'd version of the code...)
18:31:00 <adu> hmm interesting, I can't find a Stack anywhere in the haskell libraries...
18:31:13 <adu> except in XMonad.StackSet
18:31:22 <monochrom> [a] is stack, too :)
18:31:27 <newsham> adu: not even (:) ?
18:31:29 <Apocalisp> what's wrong with []?
18:31:46 <adu> thats only for FIFO stacks what about LIFO?
18:31:49 <monochrom> XMonad.StackSet uses [a] internally for the stack :)
18:32:03 <monochrom> FIFO is not stack.
18:32:05 <adu> oops other way
18:32:15 <newsham> fifo is a q
18:32:24 <adu> o ok
18:32:28 <monochrom> FIFO is queue. You can find Data.Sequence.
18:32:53 <newsham> data.sequence is smarter than you (for most you in here, including me)
18:33:20 <vixey> adu, ([a],[a])
18:33:50 <monochrom> onoes, that's another long story :)
18:34:12 <adu> nice
18:35:12 <newsham> stack + stack =
18:35:17 <adu> I remember some paper talking about views, i never knew it would be in Data.Sequence... or thats where I could find something like a Queue, ack what's in a name?
18:36:27 <newsham> ?go finger trees
18:36:29 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
18:36:29 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
18:37:08 <monochrom> A View For A Kill.
18:37:22 <dolio> > let fib [Right n] = n ; fib (Right n:Right m:stk) = fib (Right (n+m):stk) ; fib (Right n:Left m:stk) = fib (Left m:Right n:stk) ; fib (Left m:stk) | m < 2 = fib (Right 1:stk) | otherwise = fib (Left (m-1):Left (m-2):stk) in map (fib . return . Left) [0..20]
18:37:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946]
18:38:06 <vixey> hehe
18:38:19 <vixey> cool
18:38:36 <dmwit> dolio: Translating recursion to recursion, are we?
18:39:00 <dolio> I think my function qualifies as iterative.
18:39:06 <dolio> As iterative as you get in Haskell.
18:39:22 <newsham> ?type iterate
18:39:23 <lambdabot> forall a. (a -> a) -> a -> [a]
18:39:36 <dolio> I could rewrite it to use until.
18:40:11 <newsham> how about foldr?
18:40:13 <ddarius> fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2); fibCPS 0 k = k 0; fibCPS 1 k = k 1; fibCPS n k = fibCPS (n-1) $ \a -> fibCPS (n-2) $ \b -> k (a + b); fibCPS' n = fibCPS n id;
18:40:37 <dolio> You mean foldl?
18:41:10 <newsham> foldl \subset foldr
18:42:57 <dolio> Anyhow, I don't think either foldr or foldl is really appropriate. The input to fib isn't a list.
18:43:21 <dolio> I was just showing that you can implement fib using a stack and iteration.
18:43:43 <newsham> fold models iteration with an accumulator.
18:43:46 <newsham> sounds about right to me
18:43:58 <dolio> fold is primitive recursion.
18:44:21 <ddarius> data K = K0 | K1 Integer K | K2 Integer K; applyK K0 x = x; applyK (K1 n k) a = fibDefunc (n-2) (K2 a k); applyK (K2 a k) b = applyK k (a + b); fibDefunc 0 k = applyK k 0; fibDefunc 1 k = applyK k 1; fibDefunc n k = fibDefunc (n-1) (K1 n k); fibDefunc' n = fibDefunc n K0
18:44:21 <mxc> i hate to ask, but is anyone here familiar with f#?
18:44:50 <newsham> err.. i take that back..
18:44:54 <ddarius> K ~ [Either Integer Integer]
18:44:56 <newsham> fold doesnt sound about right to me
18:45:38 <ddarius> With a little bit of inlining we should end up with dolio's code.
18:45:38 <newsham> bbl
18:46:34 <mmorrow> darius: haskell needs data decls in lets
18:47:09 <mmorrow> darius: at the very least, it would open a new world of oneliner posibilities
18:47:33 <mmorrow> poss..
18:47:34 <ddarius> (Note that I produced fibDefunc from fib completely mechanically.
18:47:35 <ddarius> )
18:47:45 <dancor> haskperl
18:47:50 <dons> mxc, hmm, i'd doubt it. it's pretty obscure. Heffalump might be.
18:47:53 <ddarius> @where haskerl
18:47:54 <lambdabot> I know nothing about haskerl.
18:47:57 <ddarius> wtf?!
18:48:06 <dolio> > let fibStep (Right n:Right m:stk) = Right (n+m) : stk ; fibStep (Right n:Left m:stk) = Left m : Right n : stk ; fibStep (Left m:stk) | m < 2 = Right 1 : stk | otherwise = Left (m-1) : Left (m-2) : stk ; p [Right n] = True ; p _ = False in map (until p fibStep . return . Left) [1..10]
18:48:07 <lambdabot>  [[Right 1],[Right 2],[Right 3],[Right 5],[Right 8],[Right 13],[Right 21],[Ri...
18:48:09 <ddarius> @google haskerl
18:48:10 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
18:48:10 <lambdabot> Title: The Haskerl index
18:48:14 <dons> better.
18:48:31 <ddarius> @where+ haskerl http://www.dcs.gla.ac.uk/~partain/haskerl.html
18:48:31 <lambdabot> Okay.
18:48:40 <mxc> wld kill for an h# implementation
18:48:47 <dons> haskell for .NET runtime ?
18:48:51 <mxc> yeah
18:48:59 <ddarius> mxc: Writing one yourself would be far more legal.
18:48:59 <dolio> Doesn't YHC have support for .net bytecode?
18:49:04 <dons> yeah, there's a .NET bridge that needs to be released.
18:49:07 <dons> that's a start.
18:49:09 <mxc> although, i guess it would be much more difficult
18:49:26 <mxc> the ocaml oop model probably makes it easier
18:49:31 <mxc> hm
18:49:41 <dons> well, the impurity makes it easier.
18:49:44 <mxc> yeah
18:49:52 <dons> i don't know if F# uses the oo stuff. but it sure uses the arbitrary effects.
18:50:01 <mxc> i used ocaml exclusively before learning haskell and loved it, but now it just seems inelegant
18:50:18 <mxc> dons - i dont know much about it, but i've heard that thats hwo it accesses the .net libs
18:50:43 <Shiruka> jvm would be more useful than .net..
18:51:03 <mxc> well, my new office is a .net ecosystem world
18:51:05 <dons> does anyone use the jvm?
18:51:32 <vixey> why .net instead of JVM?
18:51:33 <mxc> my old firm was a huge ocaml shop
18:51:35 <sioraiocht> are there any major performance differences between ST arrays and IO arrays?
18:51:40 <dons> mxc, where was that?
18:51:51 <dons> sioraiocht: no, though occasional inlining differences are reported.
18:51:53 <mxc> jane street, you might know yaron
18:51:59 <dons> sioraiocht: IO is in terms of ST.
18:52:02 <mxc> yaron minsky, he was a partner there
18:52:05 <dons> mxc, right *the* major ocaml shop.
18:52:11 <mxc> hehe
18:52:17 <dons> mxc, i work at galois, fwiw.
18:52:49 <dons> oh, yaron's not a janet st anymore?
18:52:49 <sioraiocht> dons: thought so.  the problem i that I go through some array operations and have a parameter that accumulates at the same time.  I need to get it outside of the monad, and there is no unsafeState function, is there?
18:53:07 <Shiruka> minsky.. too confusing a name for someone in computing, causes hash collisions.. ;-)
18:53:18 <dons> sioraiocht: unsafePerform. unsafeSTToIO ?
18:53:21 <mxc> no, he's still there, i'm not
18:53:27 <dons> ah :)
18:53:38 <sioraiocht> dons: that's not erm..slow..is it?
18:53:58 <dons> sioraiocht: well, its a no-op, but i'm not sure what you're doing.
18:54:05 <sioraiocht> okay
18:54:20 <sioraiocht> dons: it involves array fusion...heh
18:54:28 <sioraiocht> this is in the unstreaming function
18:54:41 <dons> oh, then it should just be in ST.
18:54:54 <dons> runST (do ... some stuff ; return done)
18:54:56 <Shiruka> AFAIK the only difference between IO and ST is in the mind of the type checker
18:55:05 <dons> basically.
18:55:40 <sioraiocht> dons: right, but the data type I'm unstreaming to has a field, and the information I use for that field is computed during the writing of the array
18:55:58 <sioraiocht> oh wait, i see what you mean
18:56:38 <sioraiocht> dons: will runST copy the array, though? or does it use unsafeFreeze
18:58:19 <sioraiocht> wait, nevermind, ignore me..
18:59:10 <Shiruka> if you mean runSTArray, it uses unsafeFreezeSTArray
18:59:14 <Shiruka> http://www.haskell.org/ghc/docs/6.8.3/html/libraries/array/src/Data-Array-ST.html
18:59:16 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/62vjr5
18:59:30 <vixey> ST is super cool
19:00:04 <dolio> Oh, dons, did you get my message about hscolour and that (one never knows with lambdabot these days)?
19:00:58 <mmorrow> > let fib n = go (0,1,undefined,n) where go regs = case runState (get >>= \(eax,ebx,ecx,edx) -> put (ebx,eax+ebx,ebx,edx-1) >> get >>= \(_,_,_,edx) -> return (edx==0)) regs of (True,(eax,_,_,_)) -> eax ; (_,regs') -> go regs'
19:00:58 <lambdabot>  Parse error at end of input
19:02:39 <performance> > dropWhile (\x->x  == ' ') "    adfasdfasdf"
19:02:40 <lambdabot>  "adfasdfasdf"
19:02:55 <ddarius> mmorrow: You aren't using the recursive algorithm anymore.
19:02:57 <mmorrow> > let fib n = let go regs = case runState (get >>= \(eax,ebx,ecx,edx) -> put (ebx,eax+ebx,ebx,edx-1) >> get >>= \(_,_,_,edx) -> return (edx==0)) regs of { (True,(eax,_,_,_)) -> eax ; (_,regs') -> go regs' } in go (0,1,undefined,n) in fmap fib [1..]
19:02:58 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:03:04 <vixey> > dropWhile (== ' ') "    adfasdfasdf"
19:03:05 <lambdabot>  "adfasdfasdf"
19:03:07 <performance> is there a library function to do this? string.lstrip()
19:03:12 <vixey> > dropWhile isSpace "    adfasdfasdf"
19:03:13 <lambdabot>  "adfasdfasdf"
19:03:19 <vixey> lstrip = dropWhile isSpace
19:03:29 <performance> thnkas
19:03:32 <performance> thanks
19:03:40 <lispy> > words "    aoeuaoeuaoeu"
19:03:41 <lambdabot>  ["aoeuaoeuaoeu"]
19:03:47 <mmorrow> ddarius: ha
19:04:05 <performance> lispy:  but it returned a list when passed a string
19:04:39 <lispy> ?scheck \s -> dropWhile isSpace s == (concat . words) s
19:04:39 <lambdabot>     Failed to load interface for `SmallCheck':
19:04:39 <lambdabot>       Use -v to see a list of ...
19:04:42 <lispy> ?check \s -> dropWhile isSpace s == (concat . words) s
19:04:44 <lambdabot>  OK, passed 500 tests.
19:04:44 <performance> > words. head  "     afasdf"
19:04:45 <lambdabot>  Couldn't match expected type `f String'
19:05:00 <performance> > head $ words  "     afasdf"
19:05:01 <lambdabot>  "afasdf"
19:05:11 <lispy> ?check \s -> dropWhile isSpace s == (head . words) s
19:05:12 <lambdabot>  Exception: Prelude.head: empty list
19:05:26 <vixey> > unwords . words $ "    haoeud  hda oeuhd hao  gonana  "
19:05:26 <lambdabot>  "haoeud hda oeuhd hao gonana"
19:05:27 <lispy> as you can see, concat will be safer :)
19:05:39 <performance> > head $ words  "     "
19:05:40 <lambdabot>  "Exception: Prelude.head: empty list
19:06:01 <vixey> > reverse . dropWhile isSpace reverse . dropWhile isSpace $ "    haoeud  hda oeuhd hao  gonana "
19:06:02 <lambdabot>  Couldn't match expected type `[Char]'
19:06:05 <vixey> :/a
19:06:05 <lispy> vixey: it's sad that quickcheck doesn't find that counter example
19:06:18 <vixey> lispy, I am against testing
19:06:25 <performance> lispy:  which counter example?
19:06:30 <vixey> @check \x y -> x*y \= 13*7
19:06:31 <lambdabot>   Not in scope: `\='
19:06:34 <vixey> @check \x y -> x*y /= 13*7
19:06:34 <lambdabot>  OK, passed 500 tests.
19:06:36 <vixey> @check \x y -> x*y /= 13*7
19:06:36 <lambdabot>  OK, passed 500 tests.
19:06:37 <vixey> @check \x y -> x*y /= 13*7
19:06:38 <lambdabot>  OK, passed 500 tests.
19:06:42 <vixey> testing is useless :)
19:06:44 <Shiruka> how could anyone be against testing? :-O
19:07:05 <luqui> performance, well there's one with infinite strings...
19:07:14 <heatsink> > sqrt 500
19:07:14 <luqui> oh wait
19:07:15 <lambdabot>  22.360679774997898
19:07:15 <luqui> no
19:07:20 <luqui> I was looking at the reverse thing
19:07:36 <lispy> vixey: testing is important even when you're doing proofs, both are needed for different types of validation/verification
19:08:01 <nornagon> dmwit: my binding works great, and i'm using it, but the gtk2hs people have asked me not to release a package :)
19:08:10 <heatsink> vixey: Testing finds "obvious" bugs, much like typechecking does.
19:08:13 * Shiruka agrees with lispy
19:08:14 <vixey> lispy, by testing I meant, things like @check or unit tests
19:08:55 <monochrom> Do everything to prevent and find and eliminate errors. Redundancy is good.
19:09:18 <vixey> the problem is that testing is good enough
19:09:18 <dolio> They aren't useless, either. You just have to know what they're useful for (and what they aren't).
19:09:27 <Shiruka> proofs could even been seen as a form of testing
19:09:48 <Shiruka> since you can't prove stuff like "this program works exactly as I want it to work"
19:10:08 <monochrom> Quote from Hoare: If only there a fairy can wave a wand and remove all bugs, and the only condition is you enter your code three times!
19:10:17 <monochrom> s/there//
19:12:46 <Shiruka> (and tests could be seen as proofs of rather weak statements of the program, trading off strength for speed :-)
19:12:48 <performance> > dropWhile ( == '#') $ dropWhile isSpace "     #   commented_out   =  1234 \n"
19:12:49 <lambdabot>  "   commented_out   =  1234 \n"
19:12:59 <vixey> tests are not proofs
19:13:03 <vixey> they are data
19:13:18 <vixey> as n -> infinity my program -> correct
19:13:23 <telexicon> its difficult to read other people's haskell v_v
19:13:36 <monochrom> oh?
19:13:56 <Shiruka> I don't see why exhaustive testing isn't a proof technique
19:14:08 <vixey> exhaustive testing is impossible
19:14:11 <monochrom> model checking is exhaustive testing :)
19:14:13 <telexicon> how do you know you've tested everything?
19:14:53 <Shiruka> it's not impossible if you define the set of tested things to be small enough..
19:15:39 <monochrom> Example 1. You want to verify a finite state machine. It has only 10000 states. You can do exhaustive testing.
19:16:05 <telexicon> thats a subset
19:16:07 <lispy> monochrom: an Intel employee gave a talk at my university and said that they test the processors like that actually
19:16:16 <monochrom> Example 2. You have an adder to verify, "oh, but I only need it to work for 1+2, 5+3, and 7+4". You can also do exhaustive testing. :)
19:16:21 <shapr[> @yow !
19:16:22 <lambdabot> Couldn't find fortune file
19:16:29 <Shiruka> besides, probabilistic testing is useful too
19:16:31 <vixey> where do the 10000 tests come from? that data is misused, you should derive the program from that data instead of using it to test
19:17:15 <monochrom> There is a short temporal specification to verify the 10000 states against, vixey.
19:17:18 <shapr> @yow !
19:17:18 <lambdabot> Couldn't find fortune file
19:17:45 <Nafai> Hi shapr!
19:17:52 <shapr> hiya Nafai!
19:18:26 <Nafai> How are you?
19:18:36 <Shiruka> the probability of proof correctness and probability of sufficiency of the property proven isn't 1 anyway
19:18:46 <lispy> vixey: one form of testing is to take an easy to verify implementation and use it to verify the answers given by a clever implementation (usualy an optimized one)
19:19:00 <monochrom> Yes that too.
19:19:18 <vixey> and is it impossible to derive the fast program from the simple one?
19:19:30 <vixey> if yes why do you trust that this program works?
19:19:34 <monochrom> It is possible but people don't do it.
19:20:00 <vixey> monochrom: I think that it's not done because testing seems good enough
19:20:12 <Shiruka> depends on what you mean "derive"
19:20:16 <vixey> (and this stuff is hard)
19:20:21 <vixey> (programming)
19:20:37 <roconnor> circit opmization is NP hard?
19:20:39 <Philippa_> and because testing has been good enough for engineering for a very long time
19:20:53 <vixey> Shiruka: unfolding definitions, equational reasoning and so forth
19:20:58 <Philippa_> and because doing things the Right Way is still slow
19:20:59 <Shiruka> if you mean "derive in a reasonable time so that the computer can automatically verify that the algorithm is equal using a trusted proof system X", then ..
19:21:04 <Philippa_> = more expensive to get things done
19:21:14 <vixey> Shiruka: proof checking is easy
19:21:15 <Philippa_> people are willing to make price/trustworthiness tradeoffs
19:21:24 <vixey> Shiruka: I'm not suggesting a computer write proofs
19:21:39 <lispy> vixey: but assumption gathering isn't
19:21:49 <Shiruka> you need an accurate model of the systems
19:21:54 <vixey> lispy, I'm not sure what that means
19:22:15 <lispy> vixey: see the fiasco that google milked for PR when they found a bug in a java library that was due to a flawed assumption about integer sizes
19:22:17 <Shiruka> and I wouldn't trust a model of C, the OS, the underlying CPU, etc. very much
19:22:18 <Philippa_> vixey: how many applications have you developed in Coq or a similar system?
19:22:39 <vixey> lispy, oh right, yeah
19:22:44 <monochrom> Genius programmers don't feel they need verification, and they don't need it.
19:22:48 <Shiruka> (if the fast algo is in C and the simple one in Haskell as in, say, dons's paper about MCMC)
19:22:52 <vixey> Philippa_: none
19:23:05 <monochrom> Idiot programmers don't feel they need verification, and they can't do it anyway.
19:23:09 <Philippa_> additionally: how many applications can you see yourself developing in such systems in the not-too-distant future?
19:23:18 <vixey> Philippa_: I would very much like to though
19:23:40 <vixey> I am a beginner though
19:23:44 <Philippa_> trust me, you wouldn't. You might like to develop them in a more suitable future development of such systems...
19:24:53 <Philippa_> but right now it's a pain in the arse to such an extent that doing so for a wide range of applications constitutes research
19:25:02 <monochrom> (Programmers caught in the middle listen to opinion leaders. Since opinion leaders come from the above two groups...)
19:26:23 <luqui> monochrom, that is a very good assessment :-)
19:26:38 <Shiruka> I was reading some paper about a proof system for programs, and in the authors' experiences they found bugs in the program by proofs and bugs in the proofs by testing the program..
19:27:09 <Shiruka> where "bugs in the proof" = not proving quite what they wanted
19:27:22 <lispy> and haskell programs use proofs from the type system + proofs from the developer, often
19:27:36 <cwacsu_> ?
19:27:40 <lispy> er sorry not proofs from the developer, but tests
19:27:43 <monochrom> So, the only people who believe in formal methods is a minority. We are smart enough to be able to do proofs, but not smart enough to be geniuses free of mistakes. So we actually benefit from proofs as a check by redundancy. But as said, we are a minority.
19:28:29 <Philippa_> see, I believe in formal methods - but not in heavyweight formal methods as an appropriate approach to my problems
19:28:35 <Shiruka> nobody is genius enough to completely avoid mistakes
19:29:26 <Shiruka> practically usable formal methods would be nice, but for most applications in software development the practicality is just not there yet
19:29:28 <mmorrow> whoa, this is crazy. if you run (map fib [1..]) in an xterm w/ 146 columns and size set to "Tiny" (i don't know if it is for any # of columns and/or sizes), and just let it print for a while and look at it you can see these arches in the txt formed by the spaces the commas cause
19:29:43 <monochrom> Yes, but a genius needs just a few test cases to get rid of those few mistakes, and he/she knows how to make them.
19:29:45 <mmorrow> i don't really know how to describe it, but you'll know it when you see it
19:29:48 <vixey> mmorrow: yeah it's pretty
19:29:51 <mmorrow> heh
19:30:02 <mmorrow> totally
19:30:27 <roconnor> "Bugs in proofs" are probably hundreds or thousands of times rarer than bugs in programs, and are always eventually caught when something that ought to be provable isn't.
19:30:49 <mmorrow> oh nice, it's for any # of cols. i was afraid to resize my window in case i'd lose it
19:30:53 <roconnor> I remember one case when Isabelle? had an incorrect definition of primes
19:31:00 <roconnor> such that there were no primes
19:31:02 <ddarius> roconnor: "Bugs in ''proofs''" == Bugs in specs and they aren't rare at all
19:31:06 <Shiruka> I don't believe that
19:31:06 <monochrom> Oh cool! :)
19:31:25 <Shiruka> maths has simple enough definitions, but software doesn't
19:31:32 <roconnor> they mostly proved statements universially quantified over primes
19:31:34 <vixey> Shiruka: Why does it not?
19:31:36 <roconnor> which still worked
19:31:45 <vixey> Shiruka: decompress . compress = id
19:31:46 <roconnor> acutally, the proofs still worked when they fixed the definition.
19:31:50 <Shiruka> things are often not specced correctly even informally
19:31:57 <ddarius> decompress = id; compress = id
19:32:15 <heatsink> monochrom: That argument might hold if idiots and geniuses are solving tasks on the same level.  But more competent programmers will end up working on more difficult problems.
19:32:17 <dmwit> vixey: mp3, jpg, etc. ;-)
19:32:25 <lispy> This error message has improved significantly:
19:32:26 <lispy>     My brain just exploded.
19:32:26 <lispy>     I can't handle pattern bindings for existentially-quantified constructors.
19:32:26 <lispy>     Instead, use a case-expression, or do-notation, to unpack the constructor.
19:32:29 <mmorrow> lol, i just computed fib up to 959685722022489361611011173995655283543794045421347833532408903323724673181583826150602160523339232297797304878676266241509744796126023586587221326684160214407200940825791832935794568642465742820711900718036172187816911566125563512406893431856597959146693430935097268783794542672800767419170251894049602313073829528510326209197792475163716766356715986568533141793685877183435688057744146711587560895402241
19:32:29 <mmorrow> 0363384360058349039259410245374009189792295468783749829300485150628134724239368753051014185584548139360116805297640825998099115049977853135018327258703251752593020739963701650716029722113065917
19:32:36 <Shiruka> and formal specs do have mistakes too (not conforming to the informal spec, i.e. the intention)
19:32:36 <lispy> It now tells you want to do to fix it
19:32:51 <roconnor> ddarius: if by proofs, you mean specs, then okay, but those bugs are uncovered by doing proofs.
19:33:06 <dmwit> lispy: Yeah, a key ingredient in uncommon errors.
19:33:36 <lispy> dmwit: it's common for me of late :(
19:33:55 <vixey> Shiruka: also sound and complete is usually expressed: P x <-> Q x
19:34:02 <Philippa_> roconnor: not always - some properties are "garbage", if you miss-spec them you're going to have to test to catch them
19:34:03 <vixey> Shiruka: I think specifications are very simple.
19:34:08 <lispy> I get a lot of brain exploded, inferred type is less polymorphic than expected, and that the GADT can't be unified (wobbly type)
19:34:13 <Philippa_> well, really they're roots
19:34:24 <ddarius> roconnor: You were using the word "proof" when you meant something like "theorem" or "axiom" or "specification" otherwise the rest of your earlier sentence made no senes.
19:34:28 <mmorrow> lispy: are you on 6.8?
19:35:00 <monochrom> heatsink: There is a difference between what the middle programmers should do and what they believe they should do.
19:35:01 <Shiruka> I would like to see a simple spec for how any commonly used OS is supposed to work..
19:35:03 <Philippa_> ddarius: I imagine roconnor means proofs composed from proofs of the dodgy specs
19:35:12 <lispy> mmorrow: 6.8.2, at the moment
19:35:27 <roconnor> ddarius: there is the function, there are a list of properties for this function (the spec) and then there are the proofs which show that specifications are true.
19:35:39 <Shiruka> or even a simple spec for GHC
19:35:43 <roconnor> acutall there are possibly several functions
19:35:49 <lispy> mmorrow: why do you ask?
19:35:50 <vixey> Shiruka: meaning input = meaning output
19:36:04 <roconnor> like push, pop, empty
19:36:25 <mmorrow> lispy: from what i understand, the gadt machinery has been hugely improved in 6.9
19:37:12 <lispy> mmorrow: Perhaps.  I know it was flawed in 6.6 and to fix it wobbly type checking was redone in 6.8 and it caused some things that used to type check to start failing
19:37:13 <roconnor> Shiruka: why do you think that an OS would have a simple spec?
19:37:21 <Shiruka> I don't
19:37:29 <mmorrow> lispy: if you're interested, i was reading about it in darcs changes from a ghc-HEAD darcs copy
19:37:30 <ddarius> Philippa_: That still falls back to a buggy spec.
19:37:32 <lispy> mmorrow: but, I got the impression from SimonM that what I do in 6.8 should be fine in 6.8+...I hope so anyway
19:37:43 <heatsink> monochrom: Doesn't address the point.  Smarter programmers might not need verification for solving easy problems, but for hard enough problems (or sufficiently failure-intolerant problems) they will have a use for verification.
19:37:49 <lispy> mmorrow: Er, actually SPJ not SimonM
19:38:18 <lispy> mmorrow: what sort of things were improved? error reporting?  I'm not excited about maintaing my own ghc install
19:38:27 <Shiruka> my point is just that for much of production software (instead of toy examples), spcs aren't simple
19:38:33 <mmorrow> lispy: oh i'm sure it will, i got the impression that all changes made were nothing but for the better
19:39:12 <lispy> mmorrow: hehe, well the changes from 6.6 to 6.8 where for the better too, but it wasn't compatible so broke some code of ours :)
19:39:24 <roconnor> Specs aren
19:39:28 <mmorrow> lispy: darcs get --partial http://darcs.haskell.org/ghc && darcs changes | grep -i gadt
19:39:29 <lambdabot> Title: Index of /ghc
19:39:35 <roconnor> Specs aren't an all or nothing affair.  They are typically progressive
19:39:45 <roconnor> because they are a collection of properties
19:39:57 <monochrom> heatsink: Yes. But you are not an opinion leader. How many people listen to you?
19:40:02 <mmorrow> lispy: i always find it a very informative read
19:40:17 <roconnor> specs of mid-level function often can specify a function uniquely
19:40:29 <roconnor> specs of high-level functions are often partial
19:40:47 <mmorrow> lispy: out of curiosity, what was the particular thing that broke?
19:40:48 <lispy> mmorrow: interesitng, I doubt I'll take a look at it though.  I'm sort of in a crunch to get this done
19:40:49 <roconnor> specs of low-level functions typically involve several of the functions together.
19:40:58 <roconnor> and how they interact
19:41:08 <lispy> mmorrow: type checking in case expressions requires far more rigid types now
19:41:11 <chylli> is there a haskell compiler written by haskell ?
19:41:15 <monochrom> I am an independent thinker and I listen to you, or even better, I figured it out before I listened to you.  How many people are independent thinkers, even if they're somewhat smart programmers?
19:41:19 <ddarius> chylli: GHC
19:41:20 <ddarius> YHC
19:41:22 <ddarius> NHC
19:41:33 <chylli> ddarius: are they all written by haskell ?
19:41:34 <ddarius> HBC too, I'm pretty sure
19:41:42 <lispy> mmorrow: I get a lot of this now:
19:41:43 <lispy>    GADT pattern match in non-rigid context for `NilRL'
19:41:43 <lispy>       Tell GHC HQ if you'd like this to unify the context
19:41:44 <roconnor> is there a haskell compiler not written in haskell?
19:41:45 <ddarius> chylli: Oh, you mean by Haskell Curry, no.
19:41:51 <mmorrow> lispy: yeah, but i always include type signatures everywhere, so i haven't even noticed ;)
19:41:52 <ddarius> roconnor: HBC
19:41:59 <lispy> mmorrow: So do we
19:42:00 <chylli> ddarius: i mean, by haskell language
19:42:00 <Shiruka> if they don't cover everything and be certainly correct, then they don't make testing useless
19:42:01 <ddarius> roconnor: And some other one that was in CL.
19:42:22 <lispy> mmorrow: But, some of the places that GHC wants rigid types you can't give a signature
19:42:27 <ddarius> chylli: All the ones I listed (and then some) are all written in Haskell.
19:42:36 <lispy> mmorrow: using (.) won't work in some places now
19:42:37 <mmorrow> lispy: can you give me an example?
19:42:46 <ddarius> The most notable counter-example is Hugs, but Hugs isn't a compiler.
19:42:57 <lispy> mmorrow: I had one on a pastebin the other day
19:43:21 <heatsink> monochrom: I was going by an observation that I've seen somewhere.  In any field, the more competent people also better know their abilities and limits.
19:43:24 <mmorrow> lispy: oh, actually i had that happen (w/ (.)) the other day, and was fully perplexed  (don't remember if it was invlving gadts)
19:43:32 <lispy> mmorrow: I think it was on Monday or Tuesday if you want to cehck the logs
19:43:36 <mmorrow> cool
19:43:44 <dmwit> chylli: There's also Pugs, a Perl 6 interpreter, written in Haskell.
19:44:01 <heatsink> monochrom: From that, I'm postulating that good programmers know when they need verification.
19:44:09 <ddarius> dmwit: There are quite a few non-Haskell languages written in Haskell.
19:44:10 <lispy> mmorrow: Well, I think you need rank-n polymorphism or gadts to experience the wobbly types
19:44:14 <chylli> dmwit: thanks, but I think syntax of perl6 too complex
19:44:16 <dmwit> ...and, apparently, also a perl compiler. (?)
19:44:28 <lispy> mmorrow: but, INATT (i'm not a type theorist)
19:44:34 <ddarius> dmwit: It's been a compiler (only) for quite a while now.
19:44:40 <heatsink> monochrom: I'm certainly not trying to give advice to the world here :)
19:44:46 <dmwit> chylli: Incidentally, does it really matter what language a Haskell compiler is written in?
19:44:53 <dons> chylli: a selection of compilers written in haskell, http://haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
19:44:55 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2dt77g
19:45:02 <vixey> oh dons
19:45:32 <vixey> is http://code.google.com/p/rascal-haskell/  any good? like worth putting on that page?
19:45:33 <lambdabot> Title: rascal-haskell - Google Code
19:45:44 <vixey> (it's an interpreter)
19:45:46 <dons> probably.
19:45:48 <chylli> dmwit: I just want to study haskell by study haskell compiler written by haskell language :p
19:45:56 <dmwit> chylli: Oh, okay. =)
19:46:01 <lispy> chylli: good idea
19:46:07 <dons> chylli: that's how jhc started.
19:46:11 <dmwit> chylli: I hear JHC is nice for reading.
19:46:17 <lispy> chylli: there are some research papers along those lines.  Like typing haskell in haskell
19:46:30 <roconnor> JHC might be perfect for that job
19:46:51 <mmorrow> lispy: yeah, i think it's the same general "problem" as that with polymorphic references ... in order to extract a val you have to perform the equivalent of unsafeCoerce (whether the programmer or the compiler is doing it explicitly)
19:46:59 <lispy> Ugh, I don't want to deal with anymore type errors today.  Maybe I should call it a night.
19:47:01 * vixey thinks it fits in Small langugase probably
19:47:12 * lispy realizes he's been at the office 13 hours
19:47:20 * ddarius sees an infinite regress of people looking at compilers written in Haskell by people looking at compilers written in Haskell by ...
19:47:30 <mmorrow> so, if it's the programmer and they mess up .. crashj
19:47:32 <ddarius> lispy: Go home.
19:47:46 * Elly sees an infinite regress of people looking at people looking at people looking at compilers written in haskell...
19:47:47 <vixey> oh well I don't know what to do
19:47:58 <dons> well, if someone writes on based on jhc, we're off and away.
19:48:17 <lispy> That would be pretty cool actually
19:48:23 <dons> but probably we need other things that yet more compilers
19:48:33 <vixey> like what do we need?
19:48:33 <dons> a few more web servers. hey, why not a jabber server?
19:48:35 <dons> stuff like that.
19:48:37 <vixey> oh
19:48:50 <dons> more *stuff* in general
19:48:53 <lispy> dons: I want a new feature in the compiler actually
19:48:54 <Shiruka> looking at least at parts of GHC sources is fun :->
19:49:06 <dcoutts> dons: have you noticed the exception patches going into the base libs? I have to say I'm more than a little concerned. There seems to be significant changes required in packages besides base to adjust to this new api
19:49:12 <dcoutts> eg see the Cabal changes
19:49:31 <lispy> I want to see my source code annotated with types.  The rigid types are in one color, inferred types in another color and when they don't agree it's in RED
19:49:32 * dcoutts worries about ghc-6.10 breaking every package again
19:49:39 <dons> dcoutts: hmm..
19:49:41 <Shiruka> and besides, it's the most practical compiler, so someone who studies it might develop it further instead of starting a Yet Yet Another Haskell Compiler
19:49:54 <dons> dcoutts: i didn't know they were going *in*
19:50:01 <vixey> does anyone edit the wiki? any thoughts about that
19:50:01 <vixey> ?
19:50:13 <ddarius> vixey: Wtf?
19:50:20 <roconnor> lispy: wasn't there a project that did that a while back?
19:50:34 <vixey> ddarius: what are you asking?
19:50:38 <lispy> roconnor: I dunno, but I would try using it probably if I could find it
19:50:39 <dons> dcoutts: so the proposed exception stack got pushed?
19:50:49 <lispy> roconnor: it would have to use GHC's type checker though
19:50:50 <roconnor> I remember reading about it
19:50:51 <ddarius> vixey: Of course people edit the wiki.
19:51:06 <dobblego> I edit it occasionally
19:51:06 <dcoutts> dons: see the cvs-libraries mailing list
19:51:35 <andyjgill> dcoutts: have you a pointer to the exception patches you are talking about?
19:51:38 <lispy> roconnor: perhaps this? http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=44291
19:51:39 <Shiruka> if you mean the dynamic exception stuff described in a marlow paper, at least the ghc wiki claimed that it's going to be in 6.10 (IIRC)
19:51:42 <lambdabot> Title: CJO - Abstract - A visualisation of polymorphic type checking, http://tinyurl.com/583bdz
19:51:59 <Shiruka> er, user-defined exception stuff
19:52:05 <dcoutts> andyjgill: see the cvs-libraries archive, eg "Make Cabal compatible with extensible exceptions"
19:52:22 <dcoutts> and similar for some other core libs
19:52:28 * lispy >>= home
19:52:37 <ddarius> lispy: You may also like type error slicing and Chameleon's type debugger.
19:52:42 * dcoutts is especially displeased with the need for CPP
19:52:45 <roconnor> lispy: nope, but that sounds cook
19:52:47 <andyjgill> Oxford must be a great school; I mean, you answered my question right *before* I asked it :-)
19:52:48 <roconnor> cool
19:53:04 <dons> dcoutts: if base apis are changing without going via libraries@ then yeah, something's wrong.
19:53:25 <dcoutts> dons: well the proposal was sent to libraries
19:53:33 <dcoutts> I don't recall seeing an outcome
19:53:55 <dons> right.
19:54:27 <dcoutts> though the deadline was set for a few days ago
19:54:57 <dcoutts> there were no real objections, but otoh, not much review afaiks
19:55:21 <dcoutts> I thought users would for the most part not be affected
19:55:57 <dons> i can't find the thread.
19:56:07 <chylli> thanks
19:56:42 <dcoutts> dons: 4th july Proposal: Extensible exceptions
19:56:47 <Shiruka> wasn't the haskell platform thing supposed to deal with ghc changes, and let ghc change at its pace?-)
19:56:52 <dcoutts> dons: libraries list
19:59:32 <dons> http://thread.gmane.org/gmane.comp.lang.haskell.libraries/9481
19:59:33 <lambdabot> Title: Gmane Loom
19:59:54 <dons> but something's been comitted?
20:00:08 <dons> i see.
20:00:47 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cvs.ghc/28955
20:00:48 <lambdabot> Title: Gmane -- Mail To News And Back Again
20:01:28 <andyjgill> dons: http://www.haskell.org/pipermail/libraries/2008-July/010095.html
20:01:28 <lambdabot> Title: Proposal: Extensible exceptions
20:01:39 <andyjgill> dons: http://www.haskell.org/pipermail/libraries/2008-July/date.html
20:01:39 <lambdabot> Title: The Libraries July 2008 Archive by date
20:01:45 <dons> right, and some code has gone in.
20:02:22 <dons> but i've not found the patch yet.
20:06:19 <hml> has anyone written a 3d modeler in haslell yet?
20:06:29 <EvilTerran> well, there's Frag...
20:06:37 <hml> tha's like quake
20:06:38 <EvilTerran> but not a modeler per se
20:06:58 <EvilTerran> it can render, that's half the job
20:07:15 <hml> rendering's mostly reading
20:07:20 <andyjgill> hml: what are you looking for?
20:07:20 <hml> modeling has lots of destructive operations
20:07:21 <EvilTerran> i suspect it does the file reading, too
20:07:28 <hml> which i'm curious about for how haskell would handle it
20:07:30 <dons> a 3d physics engine?
20:07:44 <hml> no, a 3d modeling engine
20:07:45 <dons> like say http://haskell.org/haskellwiki/Hpysics
20:07:46 <lambdabot> Title: Hpysics - HaskellWiki
20:07:47 <hml> like blender or wings3d
20:08:01 * heatsink adds "does not allow contravariant template parameters" to the list of things it hates about C
20:08:04 <dons> hmm, not that i know of.
20:08:10 <heatsink> err... C++
20:08:39 <andyjgill> There is fieldtirip in the works.
20:08:51 <EvilTerran> hml, i'm sure there are plenty of ways you could store a 3d model immutably so modifications had good complexity
20:09:19 <Shiruka> contravariant template parameters? but don't C++ templates just ignore subclass relations?
20:09:50 * Shiruka hasn't used C++ in a long while
20:10:25 <dons> yeah, some guy by the unlikely name of andyjgill is doing something here, iirc.
20:10:47 <EvilTerran> ... unlikely?
20:11:00 <dons> ok, highly likely.
20:11:23 <monochrom> heh
20:11:51 <heatsink> Shiruka: It's checking the use of the templated type, I think...
20:12:03 <vixey> hml: What sort of 3D modeller?
20:12:14 <vixey> hml: this is quite a complex program by the way
20:12:33 <Shiruka> for large values of "quite"
20:12:48 <dons> this kind of thing? http://uk.youtube.com/watch?v=bp8Tz63lTsA
20:12:48 <lambdabot> Title: YouTube - Spining yellow blob
20:13:07 <dons> i think that's fieldtrip, not sure. (and in real time?)
20:13:27 <dons> http://haskell.org/haskellwiki/FieldTrip
20:13:28 <lambdabot> Title: FieldTrip - HaskellWiki
20:14:09 <dons> needs some images on the wiki page, andyjgill
20:14:27 <andyjgill> http://uk.youtube.com/watch?v=wke8JfE1M1k
20:14:28 <lambdabot> Title: YouTube - Moon rotating
20:14:32 <dolio> GHC is no longer associated with Osama bin Laden.
20:14:42 <dolio> Now he's with the Glasgow Centre for the Child & Society.
20:14:47 <Shiruka> hwat (O_o;
20:14:54 <dolio> On cuil.
20:14:57 <heatsink> Shiruka: Ah.  This is a template class parameter, and C++ forces them to be covariant.  So if B is a subclass of A, then B<T> is a subclass of A<T>.  So that's where covariance comes in -- not in the template parameter, but in the templated class.
20:15:16 <dons> yo gwern, is yampa spaceinvaders on hackage? http://uk.youtube.com/watch?v=mwge13bX9W8
20:15:16 <lambdabot> Title: YouTube - Yampa Space Invaders
20:15:43 <EvilTerran> heatsink, that sounds like one of those really stupid decisions that indicates that whoever made it had no grasp of type theory
20:15:45 <dolio> Shiruka: From a few hours ago: http://img262.imageshack.us/my.php?image=glasgowmn6.png
20:15:58 <EvilTerran> like java array types being covariant in their parameter
20:16:03 <Shiruka> heatsink: ah.. I was thinking the other side of the template, inside <> :-)
20:16:16 <EvilTerran> altho that's even more broken, seeing as it can lead to run-time type errors with no explicit casts
20:16:17 <heatsink> EvilTerran, Indeed it does.
20:16:47 <EvilTerran> (array types should be neither covariant nor contravariant in their parameter)
20:16:48 <Shiruka> dolio: (O.o;
20:17:24 <EvilTerran> becase, in haskell terms, int[] is like (Array Int (IORef Int))
20:17:27 <Shiruka> secret terrorist connections of #haskell revealed
20:17:49 <EvilTerran> and blah blah blah reading writing etc. i'll find a url or something.
20:18:00 <heatsink> EvilTerran, yeah, the JVM explicitly typechecks every single array access (every read or every write, I forget which)
20:18:19 <EvilTerran> ghastly, isn't it?
20:18:44 <heatsink> yeah.  And generics -- lots of generic code desugars to... explicit typechecking!
20:19:50 <EvilTerran> lessee.... arrays declared "final" could be covariant
20:20:20 <EvilTerran> but there's no "write-only" adjective in java that you'd need to use arrays contravariantly
20:20:24 <heatsink> What is a final array?
20:20:36 <dolio> Immutable.
20:20:43 <lispy> heatsink: it's not just something regis asks programmers
20:20:47 <EvilTerran> *i* mean arrays where you can't change the elements
20:21:01 <EvilTerran> in java, it may just mean that you can't replace the array object with a new one
20:21:13 <lispy> But, you can of course ask the elements to mutate themselves because Java doesn't have C++'s notion of const
20:21:15 <EvilTerran> but you might still be able to change the elemtns
20:23:52 <theshadow> I'm reading the yaht tutorial... and it makes mention "When presented with a list of the form (x:xs), we need to decide whether or not to keep the value of x. To do this, we use an if statement and the predicate 'p'. if p x is true, then we return a list that begins with x..." the function is defined as my_filter p (x:xs) = if p x then x : my_filter p xs else my_filter p xs . My question is what does "if p x" mean?
20:24:16 <dobblego> Java arrays are covariant
20:24:26 <dobblego> and a final array could not covariant; you mean the elements
20:24:34 <vixey> theshadow: if p of x is True
20:24:40 <EvilTerran> if (p x) then (x :my_filter p xs) else (my_filter p xs)
20:24:44 <dobblego> a write a covariant array fails at runtime
20:24:51 <dobblego> but they are otherwise assignable
20:24:55 <EvilTerran> dobblego, i mean the type of the array could be covariant in the type of its elements
20:25:00 <vixey> > let p = even in if p 7 then "it is even" else "it is not even" -- for example
20:25:01 <dobblego> EvilTerran, it is
20:25:03 <lambdabot>  "it is not even"
20:25:04 <theshadow> Ok ... I'm still missing it. does that mean equality?
20:25:23 <vixey> theshadow: p could be anything
20:25:33 <dobblego> if S <: T then S[] <: T[] (but a write fails at runtime)
20:25:40 <erikc> c++'s notion of const is pretty worthless anyway except as documentation and supplication that others behave
20:25:45 <EvilTerran> dobblego, but the covariance can lead to run-time type errors if it works on arrays with writable cells
20:25:49 <vixey> theshadow: that is, anything which takes a single element and returns True or False (a boolean)
20:25:53 <dobblego> EvilTerran, yes
20:26:01 <vixey> oops
20:26:04 <vixey> (a Bool)
20:26:12 <dobblego> it will fail at the point of the write
20:26:13 <dmwit> theshadow: Function calls are written without any extra symbols in Haskell.  So C's "f(x)" is written "f x" in Haskell.
20:26:15 <EvilTerran> so i was saying that it's broken except on arrays with "final" elements
20:26:21 <EvilTerran> (if such a thing is possible)
20:26:42 <dobblego> you mean an array without write?
20:26:47 <EvilTerran> yes
20:27:04 <rwbarton> theshadow: and "p" is a function that's passed in as the first argument of my_filter
20:27:06 <dmwit> theshadow: So when they say "if p x is true", they mean, if the value of "p x" (i.e. the function "p" applied to the value "x") is True...
20:27:11 <dobblego> it's "possible" in some of the work I have done
20:27:21 <dobblego> http://projects.workingmouse.com/public/functionaljava/artifacts/2.8/javadoc/fj/data/Array.ImmutableProjection.html
20:27:23 <lambdabot> Title: Array.ImmutableProjection (Functional Java 2.8), http://tinyurl.com/6l7vur
20:27:43 <dobblego> but then you lose the covariance anyway (since invariance is inherent and arrays are special-cased)
20:27:47 <theshadow> Oooh right ... sorry... I completely forgot that filter requires a function for the first parameter
20:28:00 <dobblego> stoopid Java
20:28:13 <EvilTerran> quite
20:28:26 <EvilTerran> i'm also frequently frustrated by how arrays don't play nice with generics
20:28:35 <mmorrow> HDBC is on the "Popular Projects" list at http://directory.fsf.org/
20:28:36 <lambdabot> Title: Welcome! - Free Software Directory - Free Software Foundation
20:28:38 <chylli>  dons: dmwit lispy: I think ehc is more appropriate to study
20:28:43 <dobblego> I'm frequently frustrated with how... generics
20:28:44 <EvilTerran> this particularly gets in the way when trying to use varargs, and ISTR the error message sucks
20:29:02 <dobblego> ha, I remember when that was a JSR and I was on the Java development team and I raised that exact issue :)
20:29:04 <dons> mmorrow: cool.
20:29:28 <dobblego> the pre-JLS3 prior to release changed about 4 times before it became what it is today
20:29:46 <mmorrow> dons: i did a double-take
20:29:57 <dons> hdbc rocks.
20:30:32 <mmorrow> i'm an hsql fellow myself
20:30:52 <dmwit> mmorrow: Yeah,  well, Dope Wars is in the Popular Projects, too. =P
20:30:59 <Shiruka> hasqell
20:31:19 <dobblego> Shiruka, nice one ;)
20:31:31 <mmorrow> dmwit: i'm pretty sure i had that game on my TI-83 at some point in high school
20:31:41 <dmwit> yep
20:31:51 <dmwit> It's massively cross-platform. ;-)
20:32:30 <mmorrow> holy shit, i thought you were kidding
20:32:40 <mmorrow> it *really* is the same game
20:32:43 <mmorrow> lol
20:33:30 <dmwit> TI-83, TI-89, *doze, *nix, Mac
20:33:35 <dmwit> What more could you want?
20:33:45 * dmwit blinks
20:34:01 <dmwit> I wonder if even a corner of GHC would fit on one of the new TI-89 Titanium.
20:34:36 <dmwit> I guess there's no M68k port of GHC, anyway. =P
20:34:38 <mmorrow> i think i programmed my first code on a TI-83
20:34:54 <Nafai> mmorrow: I did a lot on the TI-81
20:35:06 <mmorrow> didn't program on an actual computer until right before i went to college
20:40:57 <Pseudonym> Is anyone else watching the Berkeley SICP lectures?
20:41:31 <Shiruka> they still teach SICP?
20:41:42 <Pseudonym> http://www.youtube.com/watch?v=hkLWcvkXXAk <- Yes.
20:41:42 <lambdabot> Title: YouTube - CS 61A Lecture 44: Review II
20:41:49 <Pseudonym> Spring 2008, it says.
20:41:59 <Shiruka> I thought all univs were corrupted and use Java these days
20:42:06 <Pseudonym> I also love the use of a text editor instead of powerpoint.
20:43:39 <Shiruka> by Jove, it is true!
20:44:10 <Pseudonym> Zeus be praised!
20:44:31 <Pseudonym> Anyway, if you're not watching them, you probably are now.
20:45:09 <Shiruka> your last comment made me take a peek :-)
20:46:23 <lispy> THanks to Norvig I can't watch a PP presentation or hear about one without thinking about the Getty's Berg address
20:46:35 <Shiruka> hahaha
20:46:52 <Pseudonym> :-)
20:47:00 <Shiruka> I had forgotten it, thanks for reminding me
20:52:27 <hml> @src liftM
20:52:27 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:52:48 <hml> in general, should x == liftM $ return x ?
20:53:12 <vixey> :t liftM . return
20:53:12 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => a -> m a1 -> m a
20:53:36 <vixey> :t \x -> liftM $ return x
20:53:36 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => r -> m a1 -> m r
20:53:41 <vixey> no
20:53:44 <hml> that looks like a 'no'
20:53:44 <dmwit> :t liftM . return
20:53:45 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => a -> m a1 -> m a
20:53:56 <Pseudonym> "Domain" and "range" are the two most important words in the English language.
20:54:02 <Pseudonym> I'm not sure I agree with that.
20:54:14 <Pseudonym> Or does "codomain" not count as a separate word?
20:54:16 <hml> I thought they were 0 and 1
20:54:30 <dmwit> hml: x = liftM id x -- for x :: Monad m => m a
20:54:58 <hml> dmwit: hmm; thank
20:55:15 <lispy> ?pl liftM . return
20:55:15 <lambdabot> fmap . return
20:55:16 <dmwit> Or, return x = liftM id (return x) -- for all x, but less interesting
20:58:14 <Trinithis> (liftM . (return :: Int -> [Int])) 3
20:58:17 <Trinithis> > (liftM . (return :: Int -> [Int])) 3
20:58:18 <lambdabot>  Couldn't match expected type `a1 -> r'
20:58:51 <lispy> > (liftM . return) 3 :: [Int]
20:58:52 <lambdabot>  Couldn't match expected type `[Int]'
20:59:03 <dmwit> > (liftM . return) 3 [5]
20:59:04 <lambdabot>  [3]
20:59:34 <Trinithis> > (liftM . return) 3 [1..5]
20:59:35 <lambdabot>  [3,3,3,3,3]
20:59:50 <dmwit> > (liftM . const) 3 [5] -- ;-)
20:59:51 <lambdabot>  [3]
21:00:09 <dmwit> liftM = map -- for [] monad
21:00:14 <Trinithis> oh, right. forgot liftM was just fmap for a moment
21:00:31 <Trinithis> never liked using liftM
21:00:51 <Trinithis> (.) ftw!
21:01:06 <dmwit> (.) ft confusing for a while!
21:09:22 <hml> @src liftM
21:09:22 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:10:02 <vixey> @src dropM
21:10:02 <lambdabot> Source not found. Maybe you made a typo?
21:10:02 <dmwit> liftM f m = m >>= return . f -- I like this one better
21:10:08 <vixey> :t liftM
21:10:14 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:10:17 <butt-head> uh huh-huh-huh, huh-huh-huh, you said 'monad'
21:10:34 <glguy> Anyone know if GHC reorders pattern matches?
21:10:42 <vixey> ?djinn (m a -> m b) -> (a -> b)
21:10:43 <lambdabot> -- f cannot be realized.
21:10:46 <dmwit> monad
21:10:47 <glguy> simple case: case x of True -> _ ; False -> _
21:10:52 <glguy> does it always check for True first?
21:10:59 <dmwit> glguy: Yes.
21:11:09 <dmwit> ...yes, it does not reorder matches
21:11:16 <chrisdone> glguy: hey, how come you decided to use fastcgi for hpaste2 instead of darcs?
21:11:22 <sjanssen> glguy: can you come up with a case where it actually matters?
21:11:38 <dmwit> sjanssen: sure
21:11:50 <sjanssen> dmwit: while preserving semantics
21:11:51 <dmwit> case xs of ('x':xs) -> _; (x:xs) -> _
21:12:07 <sjanssen> it obviously can't reorder that
21:12:08 <butt-head> uh huh-huh-huh, huh-huh-huh, you said 'come'
21:12:25 <vixey> sjanssen: maybe it's for speed :S
21:12:27 <sjanssen> is that what glguy wanted to know?
21:12:30 <vixey> two == checks instead of one
21:13:58 <glguy> sjanssen: I'm wondering if it matters to put the least common cases last in a case
21:14:04 <sjanssen> glguy: I think it can sometimes re-order matches
21:15:32 * lispy wonders if butt-head is a bot
21:15:35 <butt-head> uh huh-huh-huh, huh-huh-huh, you said 'butt'
21:15:43 <dmwit> Almost certainly.
21:15:49 * lispy sighs
21:15:50 <sjanssen> butt-head: are you a bot?
21:15:51 <butt-head> uh huh-huh-huh, huh-huh-huh, you said 'butt'
21:15:54 --- mode: ChanServ set +o glguy
21:15:57 <dolio> Heh.
21:15:57 --- mode: ChanServ set +o sjanssen
21:15:58 --- kick: butt-head was kicked by glguy (glguy)
21:16:16 --- mode: ChanServ set -o sjanssen
21:16:43 --- mode: glguy set -o glguy
21:16:56 <dmwit> lispy: It's actually why I said "monad" all on its own a bit ago, to see if I could expose butt-head. =P
21:16:56 <thetallguy> what's amazing is that the bot was programmed to snicker at monad
21:17:29 <chrisdone> thetallguy: he who smelt it dealt it
21:17:49 <Shiruka> maybe it wasn't
21:17:49 <thetallguy> perhaps we should make lambdabot snicker at 'object-oriented'
21:18:11 <Shiruka> it could snicker at things that are a short edit distance of certain words
21:18:12 <dmwit> It wasn't thetallguy, the netmasks don't match.
21:18:13 <chrisdone> yeah, and say, "what the hell does it mean?"
21:18:24 <thetallguy> dmwit: ?
21:18:37 <dmwit> butt-head (n=butt-hea@c-75-72-220-197.hsd1.mn.comcast.net)
21:18:44 <thetallguy> Oh, chrisdone thinks I made the bot?  Nah.
21:18:52 <dmwit> thetallguy (n=beshers@cpe-66-27-75-31.san.res.rr.com)
21:19:10 <dmwit> All we have to do is find the other people coming from comcast...
21:19:37 <thetallguy> I suspect a reddit reader...
21:19:54 <dolio> Obviously dmwit is a thetallguy sock puppet trying to trick us into the latter's innocence.
21:19:55 <chrisdone> dmwit: well, thetallguy could just have another connection, hijacked or however his evil ways afford him
21:20:09 <dmwit> ousted
21:20:15 <chrisdone> dolio: that's what my done sense tells me
21:20:17 <thetallguy> chrisdone: makes me tired just thinking about it.
21:20:28 <thetallguy> @type fix
21:20:30 <lambdabot> forall a. (a -> a) -> a
21:20:33 <dmwit> thetallguy: It's easy with ssh. ;-)
21:20:44 <hml> how do i get lambda bot to tell me the operateor precedence level of \x -> ?
21:20:54 <dmwit> hml: It's not an operator.
21:21:00 <vixey> \x -> isn't an operator
21:21:04 <thetallguy> dmwit: but then I'd have to figure out how to use a command line chat
21:21:17 <dmwit> hml: ... but I think it has precedence over all operators.
21:21:31 <dmwit> thetallguy: ssh -X
21:21:32 <hml> are \ and -> operators?
21:21:35 <thetallguy> dmwit: because gettin an x client from another machine has been a total pain ever since the advent of xauth...
21:21:38 <dmwit> hml: no
21:21:47 <hml> so they're hacked somewhere deep in the bowels of ghc?
21:21:51 <dmwit> thetallguy: Totally false, I do it every day from work.
21:21:52 <thetallguy> dmwit: yes, I know.   Such things bore me.
21:22:01 <dolio> It's syntax.
21:22:12 <dolio> Perhaps you've heard of it. :)
21:22:31 <dolio> (Unless you're a lisp guy. :))
21:22:33 <thetallguy> @type error
21:22:34 <lambdabot> forall a. [Char] -> a
21:22:42 <hml> the only syntax I know of are ( and T
21:22:44 <hml> err )
21:22:48 <thetallguy> #t
21:23:46 <thetallguy> Oh look, I'm running an emacs from my server with ssh -X.
21:23:50 <thetallguy> D'oh.
21:23:54 <dmwit> ?type error is not a typ error
21:23:55 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
21:24:08 <thetallguy> @type fix fix
21:24:09 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
21:24:14 <dmwit> ?undefine
21:24:14 <lambdabot> Undefined.
21:24:18 <dmwit> ?type fix fix
21:24:18 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
21:24:21 <thetallguy> @type fix
21:24:21 <dmwit> bah
21:24:22 <lambdabot> forall a. (a -> a) -> a
21:24:30 <thetallguy> @type fix fix
21:24:31 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
21:24:44 <int-e> > fix fix
21:24:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
21:24:45 <lambdabot>     Probabl...
21:25:01 <thetallguy> oh, right.
21:25:36 <dmwit> hml: Haskell has lots of syntax. [, ], [], type, data, |, _, =, \, ->, ::, =>, ...
21:25:43 <thetallguy> @type fix sin
21:25:44 <lambdabot> forall a. (Floating a) => a
21:25:55 <dmwit> ?type undefined :: Floating a => a
21:25:56 <lambdabot> forall a. (Floating a) => a
21:26:21 <dmwit> Even though 0 is a fixed-point, it's not the least fixed-point.
21:27:05 <thetallguy> someone had a really nice use of fix recently and I can't remember it
21:27:47 <dmwit> > fix (1:)
21:27:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:27:56 <dmwit> that's my favorite
21:31:47 <thetallguy> >fix (x * x)
21:32:14 <theshadow> is there an or operator? like if x == 1 || x == 2?
21:32:29 <rwbarton> theshadow: yep, just like that.
21:32:29 <chrisdone> you just used it
21:32:51 <dmwit> > join (*) 3 -- thetallguy: are you thinking of this?
21:32:52 <lambdabot>  9
21:32:54 <theshadow> doh... I couldn't find it in my documentation so I wanted to check <_<
21:33:09 <thetallguy> dmwit: doesn't seem familiar
21:33:20 <thetallguy> dmwit: what's interesting about that?
21:33:33 <thetallguy> @type join
21:33:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:33:42 <chrisdone> @type flip (flip join))
21:33:43 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
21:33:44 <thetallguy> what monad is in play there?
21:33:44 <chrisdone> @type flip (flip join)
21:33:45 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
21:33:49 <dmwit> thetallguy: "join f x", for functions f, is equivalent to "f x x".
21:33:53 <chrisdone> (->)
21:33:58 <thetallguy> Ah, the reader.
21:34:01 <dmwit> thetallguy: The Reader monad, i.e. ((->) e).
21:34:18 <thetallguy> Interesting, but not what I was thining of.
21:34:23 <dmwit> ok
21:34:41 <thetallguy> My problem is, I don't remember who said this nor where I saw it nor what it was
21:34:49 <Trinithis> lol
21:34:55 <thetallguy> I just remember 'something cool with fix'
21:34:57 <vixey> thetallguy: so basically, something cool exists
21:35:12 <Trinithis> > fix (1:) . fmap (+6)
21:35:13 <Shiruka> good guess about the redditer :-)
21:35:13 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[t]'
21:35:18 <Trinithis> > fix $ (1:) . fmap (+6)
21:35:21 <lambdabot>  [1,7,13,19,25,31,37,43,49,55,61,67,73,79,85,91,97,103,109,115,121,127,133,13...
21:35:22 <thetallguy> vixey: not necessarily.  All we know is that I have a memory of something cool existing
21:35:23 <Shiruka> http://paste.pocoo.org/show/80901/ <-- found on reddit
21:35:26 <Trinithis> was that it?
21:35:28 <dmwit> :t fix fmap return
21:35:45 <thetallguy> it's like the single black sheep in scotland
21:35:58 <Shiruka> the ones black on at least one side?
21:36:07 <Shiruka> *one
21:36:31 * Heffalump was in Scotland last week and didn't see a single black sheep.
21:36:38 <thetallguy> http://www.cs.northwestern.edu/~riesbeck/mathphyseng.html
21:36:39 <lambdabot> Title: Math Phys Eng
21:36:40 <roconnor> > fix error
21:36:41 <thetallguy> Yes.
21:36:43 <Trinithis> I remember when I was really new to HS, someone showed an extremely small primes function. Anyone know it?
21:36:46 <roconnor> that still amuses
21:36:55 <lambdabot>  thread killed
21:36:59 <vixey> nubBy gcd >1 ...[1..]....
21:37:17 <vixey> > nubBy(((>1) .) . gcd) [2..]
21:37:18 <dmwit> > nubBy (\x y -> y `mod` x == 0) [2..] -- the readable version
21:37:18 <thetallguy> I remember!
21:37:21 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:37:21 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:37:41 <Trinithis> :t nubBy
21:37:42 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
21:37:53 <thetallguy> who and maybe where.  dones had a fix example
21:38:00 <thetallguy> s/dones/dons
21:38:19 <thetallguy> I love that nubBy/primes function
21:38:52 <Trinithis> @src nubBy
21:38:52 <lambdabot> nubBy eq []             =  []
21:38:52 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:38:56 <thetallguy> You can explain that to almost anyone
21:39:01 <vixey> no you can't
21:39:04 <dmwit> > fix error
21:39:14 <vixey> it uses .
21:39:20 <lambdabot>  thread killed
21:39:22 <thetallguy> well, anyone with a science background
21:39:24 <vixey> (>1) .) .
21:39:27 <vixey> that is very confusing
21:39:39 <dmwit> vixey: You can explain the expansion in short order.
21:39:42 <thetallguy> oh, I don't make it so ugly
21:39:46 <vixey> ok
21:40:08 <thetallguy> I forget how I cleaned it up,maybe the lambda
21:40:25 <dmwit> > let fib = fix (\f n -> if n < 2 then 1 else f (n - 1) + f (n - 2)) in map fib [0..10] -- thetallguy, this, maybe?
21:40:27 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89]
21:40:31 <Trinithis> perhaps mod . (==-) ?
21:40:32 * dmwit is grepping for "fix" in his Haskell logs
21:40:41 <Trinithis> (==0*)
21:40:47 <dmwit> Trinithis: (((== 0) .) . mod)
21:40:51 <thetallguy> but I also love it because it looks like a perl example, but it's so much nicer.
21:40:57 <dmwit> Trinithis: Might need a flip in there, too.
21:41:03 <Trinithis> yeah it does
21:41:17 <dmwit> ?pl \x y -> y `mod` x == 0
21:41:17 <lambdabot> flip flip 0 . ((==) .) . flip mod
21:41:17 <thetallguy> dmwit: that's getting into the ballpark.
21:41:32 <thetallguy> not sure if that's it, but it was very much like that
21:41:45 <Trinithis> :t flip flip
21:41:46 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
21:42:05 <dmwit> thetallguy: Basically, all recursion can be expressed with fix.
21:42:06 <Trinithis> double flip is quite unreadable imo
21:42:20 <mmorrow> > fix ((0:) .  scanl (+) 1)
21:42:21 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:42:27 <thetallguy> Trinithis: I wrote a blog saying I don't even like single flip. ;-)
21:42:35 <mmorrow> that's my favorite fib
21:42:37 <Trinithis> link?
21:42:41 <thetallguy> dmwit: yes, I get that.  Sort of.
21:43:01 <thetallguy> http://cliffordbeshers.blogspot.com/2008/05/eschewing-flip.html
21:43:01 <lambdabot> Title: RuMiNaTiOnS: Eschewing flip
21:43:15 <thetallguy> I'm not saying it's a bad thing, just that my brain doesn't like it.
21:43:33 <dmwit> > map length . groupBy (/=) . fix $ show -- the only other cool thing I see in my log
21:43:33 <Trinithis> single flip  is fine for me :D
21:43:37 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
21:43:38 <thetallguy> Being a bear of very little brain and all that.
21:44:06 <thetallguy> dmwit: but I would never use fix in anger, which means I really don't.
21:45:19 <mmorrow> > fix (scanl (+) 1)
21:45:20 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
21:45:38 <hansfbaier> @source lift
21:45:42 <lambdabot> lift not available
21:45:50 <hansfbaier> @source liftM
21:45:50 <lambdabot> liftM not available
21:45:56 <dmwit> mmorrow: Now *that* is pretty cool.
21:46:26 <mmorrow> dmwit: i happened upon it while trying to remember that fib with fix in ghci
21:46:32 <mmorrow> (just now)
21:46:37 <thetallguy> scanl calculates all the successive applications, right?
21:46:43 <hansfbaier> @source fix
21:46:43 <lambdabot> fix not available
21:46:57 <dolio> > scanl (*) 1 [1..]
21:46:58 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
21:46:59 <hansfbaier> @source map
21:47:00 <lambdabot> map not available
21:47:03 <dmwit> thetallguy: Applications of foldl on all the inits, I guess.
21:47:22 <Trinithis> > scanr (*) 1 [1..]
21:47:24 <lambdabot>  [Exception: stack overflow
21:47:32 <dmwit> > scanl (*) 1 [1..]
21:47:34 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
21:48:41 <thetallguy> so scanl (*) 1 [1..] is map (foldl (*) 1) (inits [1..])  ?
21:48:45 <dmwit> Ah, and maybe you can get the triangle numbers, too!
21:49:01 <dmwit> > fix (scanl (+) 2)
21:49:02 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
21:49:25 <dmwit> > fix ((1:) . scanl (+) 2)
21:49:26 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
21:49:37 <dmwit> huh
21:49:40 <dolio> > scanl (+) 1 [2..]
21:49:41 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
21:50:02 * dmwit understands fix only at the head level, never the heart
21:50:37 <dmwit> thetallguy: Kind of, but more efficient.
21:50:48 <thetallguy> Kind of?
21:51:00 <dmwit> Not kind of.
21:51:15 <thetallguy> DId I see a new smallcheck plugin?
21:51:16 <dmwit> But foldl might stack overflow before scanl does.
21:51:25 <dmwit> (if you have a good consumer)
21:51:31 <thetallguy> dmwit: but semantically identical?
21:51:39 <dmwit> yeah
21:52:03 * thetallguy channels conal across an ocean and continent
21:52:31 <thetallguy> > sc
21:52:32 <lambdabot>   Not in scope: `sc'
21:52:37 <thetallguy> @sc
21:52:37 <lambdabot> smallcheck: <stdin>: hGetLine: end of file
21:53:18 <thetallguy> @sc scanl (*) 1 [1..] == ﻿map (foldl (*) 1) (inits [1..])
21:53:18 <lambdabot>  Illegal character ''\187''
21:53:18 <lambdabot>  at "map" (column 23)
21:53:28 <thetallguy> Oops
21:53:36 <thetallguy> oops
21:54:29 <dmwit> ?scheck \xs -> scanl (*) 1 xs == map (foldl' (*) 1) (inits xs)
21:54:30 <lambdabot>     Failed to load interface for `SmallCheck':
21:54:30 <lambdabot>       Use -v to see a list of ...
21:54:30 <thetallguy> ﻿@sc \x  -> ﻿scanl (*) x ﻿[1..] == ﻿map (foldl (*) x ﻿) (inits [1..])
21:54:46 <dolio> @check \f z l -> scanl f z l = map (foldl f z) (inits l)
21:54:47 <lambdabot>  Parse error at "=" (column 23)
21:54:51 <dmwit> thetallguy: You're not going to get very far, comparing infinite lists like that. ;-)
21:54:52 <dolio> @check \f z l -> scanl f z l == map (foldl f z) (inits l)
21:54:54 <lambdabot>  OK, passed 500 tests.
21:55:18 <thetallguy> dmwit: you take all the fun out of things. ;-)
21:55:21 <dolio> @check \f z l -> scanl (f :: Int -> Int -> Int) z l == map (foldl f z) (inits l)
21:55:27 <lambdabot> Terminated
21:55:38 <dolio> @check \f z l -> scanl (f :: Int -> Int -> Int) z l == map (foldl f z) (inits l)
21:55:45 <lambdabot> Terminated
21:55:47 <dolio> Huh.
21:55:55 <dmwit> long lists?
21:56:41 <dmwit> ?check \l -> scanl (+) 0 l == map (foldl (+) 0) (inits l)
21:56:41 <lambdabot>  OK, passed 500 tests.
21:56:55 <dolio> Doubtful. Maybe it can't generate 500 fs fast enough?
21:57:02 <dmwit> ?check \l -> scanl div 10000 l == map (foldl div 10000) (inits l)
21:57:03 <lambdabot>  Exception: divide by zero
21:57:09 <dmwit> dolio: Yeah, that's more likely.
21:57:22 <thetallguy> check is qc, scheck is smallcheck?
21:57:25 <dolio> I don't know how much work goes into generating functions in quickcheck.
21:57:28 <dmwit> thetallguy: yes
21:57:54 <dmwit> :t scanl
21:57:54 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
21:58:26 <dmwit> ?check \f z l -> scanl (f :: Int -> Bool -> Int) z l == map (foldl f z) (inits l)
21:58:32 <lambdabot> Terminated
21:58:37 <dmwit> oh bother
21:58:54 <thetallguy> heheh
21:58:58 <dmwit> Int -> () -> Int is just too boring to even try
21:59:01 <dolio> @check \f z l -> scanl (f :: Bool -> Bool -> Bool) z l == map (foldl f z) (inits l)
21:59:03 <lambdabot>  OK, passed 500 tests.
21:59:38 <dmwit> ?check \f -> f :: Int -> Bool
21:59:39 <lambdabot>  Falsifiable, after 3 tests: <Int -> Bool>, 0
22:00:01 <dmwit> ?check \f -> const True . (f :: Int -> Bool)
22:00:02 <lambdabot>  OK, passed 500 tests.
22:00:11 <dmwit> ?check \f -> const True . (f :: Int -> Int)
22:00:12 <lambdabot>  OK, passed 500 tests.
22:00:17 <dmwit> ?check \f -> const True . (f :: Int -> Int -> Int)
22:00:19 <lambdabot>  OK, passed 500 tests.
22:00:23 <dolio> Hmm.
22:00:25 <dmwit> *blink*
22:00:37 <dmwit> I guess it doesn't evaluate "f" in those cases.
22:01:06 <dolio> @check \f -> (f :: Int -> Int -> Int) `seq` True
22:01:07 <lambdabot>  OK, passed 500 tests.
22:01:15 <dolio> @check \f -> (f :: Int -> Int -> Int) 4 10 `seq` True
22:01:15 <lambdabot>  OK, passed 500 tests.
22:01:25 <_zenon_> Good morning
22:01:34 <dolio> @check \f -> foldl (f :: Int -> Int -> Int) 5 [1..3] `seq` True
22:01:35 <lambdabot>  OK, passed 500 tests.
22:01:39 <vixey> @check \f -> f 3 == 4
22:01:40 <lambdabot>  Falsifiable, after 0 tests: <Integer -> Integer>
22:01:59 <dmwit> dolio: Oh, well, foldl + inits + evaluating the entire list = slow, I guess.
22:02:07 <dolio> I guess.
22:02:11 <vixey> what functions does it generate?
22:02:21 <dmwit> vixey: Take a look at the source. ;-)
22:02:35 <dolio> @check \f -> map (foldl (f :: Int -> Int -> Int) 5) (inits [1..3]) `seq` True
22:02:36 <lambdabot>  OK, passed 500 tests.
22:03:01 <dmwit> dolio: ...that just gets to (:) on each list.
22:03:12 <dolio> @check \f -> rnf (map (foldl (f :: Int -> Int -> Int) 5) (inits [1..3])) `seq` True
22:03:17 <lambdabot>  OK, passed 500 tests.
22:04:00 <dpn``> hey is there something like  erlang's OTP for hs?
22:04:10 <dpn``> seems a lot of people don't like erl's syntax
22:04:19 <vixey> what's OTP
22:05:26 <dpn``> i'll find a good desc
22:05:47 <dmwit> ?check \f z -> rnf (map (foldl (f :: Int -> Int -> Int) 5) (inits z)) `seq` True
22:05:56 <dpn``> Distribution of the language together with libraries and the real-time distributed database Mnesia is the Open Telecom Platform (OTP).
22:05:56 <lambdabot> Terminated
22:06:08 <dpn``> vixey, allows native calls to other nodes over the network
22:09:20 <hml> where's the pdf guide for parsec? the webpage at: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html states that the manual comes in pdf and ps; ... but on that page, i only see the HTML, and on the hackage download, I don't see any documnentation; where can i get the ps / pdf
22:09:21 <lambdabot> Title: Parsec, a fast combinator parser
22:10:00 <prb> hml: http://research.microsoft.com/users/daan/parsec.html
22:10:01 <lambdabot> Title: Parsec
22:10:47 <mmorrow> dpn``: i take it you mean function calls (?), what
22:10:47 <hml> prb: cool; thanks
22:10:56 <mmorrow> dpn``: i take it you mean function calls (?), what's the protocol like ?
22:11:21 <mmorrow> dpn``: (or phone calls?)
22:11:35 <dpn``> mmorrow, more like - you can send the code you want processed and have it execute remotely
22:12:03 <vixey> dpn``: Oz can do that
22:12:04 <dpn``> as for the protocol, i'm not that familiar with it... there are other node servers in other languages though
22:12:11 <vixey> I don't know about haskelll...
22:12:15 <mmorrow> dpn``: cool. what is the security in place? pre-trusted/need-to-be-sandboxed/?
22:12:36 <dpn``> mmorrow, not sure entirely, it is very secure though
22:12:40 <thetallguy> There was a research system that did something like that.
22:12:40 <dpn``> i've not set this up yet
22:12:44 <dpn``> just looking into erlang myself
22:12:54 <dpn``> was wondering if there was something similar in hs
22:12:56 <thetallguy> but I don't think there's anything close to a production system.
22:13:01 <dpn``> i much prefer the syntax of hs
22:13:08 <dpn``> fair enough
22:13:09 <vixey> dpn``: if you don't like erlang syntax though oz you will probably not like
22:13:15 <dpn``> i guess the local equiv would be forkIO
22:13:28 <thetallguy> http://www.informatik.uni-kiel.de/~fhu/PUBLICATIONS/1999/ifl.ps.gz
22:13:29 <lambdabot> http://tinyurl.com/2ke3y7
22:13:50 <dpn``> thanks
22:14:25 <prb> dpn``: Haskell, AFAIK, lacks code mobility.  Compare, e.g., Gambit Scheme.
22:14:48 <prb> dpn``: And that's a reasonable thing to lack for a language that compiles to native versus running on a VM.
22:15:12 <dpn``> prb, sure - erlang has a native compiler too.
22:15:17 <dpn``> but i understand your point
22:15:22 <thetallguy> http://dikini.net/15.11.2007/learning_to_speak_erlang_style_concurrency_in_haskell
22:15:24 <lambdabot> Title: Learning to speak - erlang style concurrency in haskell | dikini.net, http://tinyurl.com/yoxmwa
22:15:51 <dpn``> i just think that people don't like erlang the language, but would like the supporting concept of highly distributed applications with something prettier on top :)
22:16:11 <vixey> dpn``: I think that lots of people like erlang
22:16:18 <mmorrow> http://www.erlang-consulting.com/training/courses/otp.html
22:16:18 <prb> thetallguy: As I understand OTP, the magic is that the Chan that connects your processes doesn't need to be explicitly local or remote; that's just figured out for you.
22:16:19 <lambdabot> Title: Erlang Training: OTP Course
22:17:29 <dpn``> vixey, yeah, they do... :)
22:17:34 <dpn``> the people i'm talking about are lazy
22:17:40 <thetallguy> http://www.springerlink.com/content/unbk3b9weaw29pwb/
22:17:41 <dpn``> ;)
22:17:41 <lambdabot> Title: SpringerLink - Book Chapter
22:17:46 <thetallguy> D'oh.
22:18:25 <dpn``> hehe
22:18:29 <thetallguy> http://www.macs.hw.ac.uk/~dsg/gdh/
22:18:30 <lambdabot> Title: Glasgow Distributed Haskell
22:18:34 <thetallguy> That's better
22:19:11 <chrisdone> :t ifM
22:19:30 <mmorrow> mnemosyne's an awesome database name
22:20:22 <mmorrow> memory
22:20:58 <mmorrow> μνημοσυνη
22:21:24 <thetallguy> > reverse ""μνημοσυνη"
22:21:24 <lambdabot>  Improperly terminated string at """ (column 20)
22:21:37 <thetallguy> ﻿> reverse "﻿μνημοσυνη"
22:21:43 <chrisdone> @hoogle ifM
22:21:43 <lambdabot> System.Directory.createDirectoryIfMissing :: Bool -> FilePath -> IO ()
22:21:43 <lambdabot> Foreign.C.Error.throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
22:21:43 <lambdabot> Foreign.C.Error.throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()
22:22:00 <mmorrow> i can't wait til ghc handles unicode easily
22:22:19 <thetallguy> Hmm.
22:22:28 <vixey> I hope lambdabot will too
22:22:30 <chrisdone> @hoogle Monad m => m Bool -> m a -> m a -> m a
22:22:30 <lambdabot> No matches, try a more general search
22:22:47 <thetallguy> works in ghci
22:23:14 <mxc> @hoogle Monad m => m Bool -> m a -> m a
22:23:15 <lambdabot> Prelude.asTypeOf :: a -> a -> a
22:23:15 <lambdabot> Prelude.const :: a -> b -> a
22:23:15 <lambdabot> Prelude.seq :: a -> b -> b
22:23:21 <mmorrow> > "\956\957\951\956\959\963\965\957\951"
22:23:22 <lambdabot>  "\956\957\951\956\959\963\965\957\951"
22:23:29 <mxc> isn't the last  -> m a incorrect?
22:23:40 <mxc> oh, no, nevermind, sorry
22:23:45 <mxc> my bad
22:23:57 <mmorrow> thetallguy: it works with System.IO.UTF8 for me
22:24:37 <chrisdone> :t whenM
22:24:46 <mmorrow> mmorrow: oh sweet, i take back that unicode in ghc isn't easy (enough)
22:25:41 <thetallguy> mmorrow: I think the problem is more that most of us don't deal with it properly
22:25:47 <mmorrow> the only gripe i have is that i can't figure out how to *input* unicode into ghci (int xterm)
22:26:01 <mmorrow> thetallguy: yeah, me too
22:26:20 <Trinithis> @hoogle (a -> c) -> (a, b) -> (c, b)
22:26:20 <lambdabot> No matches, try a more general search
22:26:22 <chrisdone> mmorrow: use xmodmap?
22:26:29 <thetallguy> mmorrow: stepcut spent a week or two ironing out unicode bugs in HAppS and other libraries so that we could put chinese characters in web pages
22:26:31 <mmorrow> i need to learn that
22:26:40 <chrisdone> :t first
22:26:40 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
22:26:44 <mmorrow> thetallguy: cool!
22:26:49 <chrisdone> > first (+1) (1,2)
22:26:50 <lambdabot>  (2,2)
22:27:07 <Trinithis> ty
22:27:14 <chrisdone> mmorrow: there is xkeycaps which is like an old gui front end
22:27:20 <thetallguy> mmorrow: well, the result was.  The process was exasperating.
22:27:41 <thetallguy> fix (encode . decode)
22:28:05 <vixey> what
22:28:17 <thetallguy> who
22:28:20 <mmorrow> chrisdone: nice, i was just tab-complete-fishing for an easy way out ;)
22:28:22 <chrisdone> @check (\s -> s == encode . decode $ s)
22:28:22 <lambdabot>   Not in scope: `decode'
22:28:30 <chrisdone> mmorrow: hehe
22:28:32 <thetallguy> that was pseudo code
22:28:56 <mmorrow> thetallguy: ha, what was the crux?
22:29:06 <thetallguy> passing strings around was ill-typed
22:29:25 <thetallguy> it was unclear when things were expected to be encoded or not
22:29:43 <thetallguy> and things were being decoded that were not encoded and vice-versa
22:29:48 <chrisdone> is there a GHC extension to make case monadic?
22:30:02 <jsnx> chrisdone: what does that mean?
22:30:04 <mmorrow> thetallguy: ahh, sounds nightmarish
22:30:17 <thetallguy> sometimes you couldn't get there fro here
22:30:40 <chrisdone> jsnx: like case f of b -> ... = f >>= \b -> ...
22:30:45 <thetallguy> that is, you couldn't get a string to appear in the output because it would get re-encoded into something else.
22:30:59 <Trinithis> Is there a function : \f (x:y:_) -> f x y
22:31:09 <thetallguy> but it's a lovely example of how phantom typing can help your code.
22:31:33 <chrisdone> jsnx: I don't like saying "foo <- monad; case foo of Just foo' -> ", so much
22:31:49 <mmorrow> thetallguy: heh, "output chinese with phantom types today!"
22:32:10 <thetallguy> mmorrow: sounds spooky, doesn't it?
22:33:04 <mmorrow> at the very least, a good story to tell people when you want them to think you're crazy :)
22:33:06 <_zenon_> What is the intended use of coarbitrary in QuickCheck?
22:33:10 <_zenon_> I have never used it
22:33:28 <dolio> It's for making functions.
22:33:29 <Trinithis> I think it is so it can create functions using tha ttype
22:33:30 <mmorrow> thetallguy: (non-haskell people that is)
22:33:42 <_zenon_> dolio, oh, thanks.
22:33:49 <_zenon_> Trinithis, thanks to you to
22:34:34 <thetallguy> mmorrow: I have no trouble making anything think I'm insane.
22:34:44 <thetallguy> don't need more methods.
22:35:21 <mmorrow> yeah, then there'd be method to your madness
22:35:42 <jsnx> @seen Philippa
22:35:42 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
22:35:47 <thetallguy> heh heh-heh-heh heh-heh-heh  you said method
22:35:53 <Trinithis> _zenon_: Do you want a pdf that explains a bit on QC?
22:36:18 <thetallguy> Oh, now I feel better.
22:36:19 <_zenon_> Trinithis, I have skimmed through the papers from Hughes and Coen, if it's not one of those
22:36:42 <_zenon_> Trinithis, If it's not one of those, I'd be glad to have them
22:37:03 <Trinithis> Hughes and Claessen
22:37:37 <Trinithis> http://citeseer.ist.psu.edu/claessen00quickcheck.html
22:37:38 <lambdabot> Title: QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs - Claessen ...
22:38:19 <_zenon_> Seems like a good paper
22:38:24 <hml> for parsec, in the following code, why is it that when i remove the type declaration, i get an error; but if i put in the type declaration , i don't have an error
22:38:27 <hml> testOr :: CharParser st String
22:38:29 <hml> testOr = string "(a)" <|> string "(b)"
22:38:41 <_zenon_> the one's available through the quickcheck page are horrible to read, the typesetting and too narrow
22:39:38 <Trinithis> poor page design
22:40:00 <luqui> hml, that looks like it should be fine without the sig.  what's the error?
22:40:49 <hml> No instance for (Text.Parsec.Prim.Stream s m Char) arising from a use of `string' at test.hs:32:9-2
22:40:52 <hml> 0 Possible fix: add an instance declaration for (Text.P...n the first argument of `(<|>)', namely `string "(a)"' In
22:40:56 <hml> the expression: string "(a)" <|> string "(b)" In the definition of `testOr': testOr = string "(a)" <|> string "(b)"
22:42:52 <ddarius> hml: That's the monomorphism restriction.
22:43:01 <hml> ddarius: please enlighten me
22:43:18 <luqui> ah right that blasted thing!
22:43:30 <luqui> when you have a definition of the form:
22:43:33 <luqui> f = ...
22:43:38 <luqui> i.e. no arguments on the left
22:43:46 <ddarius> @wiki Monomorphism restriction
22:43:47 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
22:43:56 <luqui> yeah I got stumped at that point, just read :-)
22:44:48 <Trinithis> @pl stackAt n = lookAt n . ss
22:44:48 <lambdabot> stackAt = (. ss) . lookAt
22:45:44 <Shiruka> poor monomorphism restriction, unloved and shunned
22:46:04 <jsnx> @seen Cale
22:46:04 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
22:46:15 <ddarius> preflex: seen Cale
22:46:15 <preflex>  Cale was last seen on #haskell 5 hours, 42 minutes and 13 seconds ago, saying: EvilTerran: forall c?
22:46:40 <jsnx> ddarius: thanks, thanks
22:47:47 <jsnx> ddarius: Consider the adjunction where the left adjoint is the co-product functor and the right adjoint is the diagonal functor
22:47:47 <mxc> shiruka - no one likes mono
22:48:05 <jsnx> ddarius: demonstrating the unit is easy
22:48:16 <jsnx> ddarius: but the co-unit confounds me
22:48:25 <hml> i was suspecting all this time that haskell had some ugliness to it; loks like it's finaly relvealed itself; thanks ddarius , luqui for the molnomorphism link
22:48:57 <Twey> You can disable it
22:49:03 <ddarius> hml: Just do -fno-monomorphism-restriction or some such or an equivalent -X flag or LANGUAGE pragma
22:49:09 <vixey> hml: if you consider it ugly just remove it from the lanugage
22:49:11 <luqui> yeah, you can turn off the ugliness (in exchange for some 'performance ugliness' if you don't know what you're doing) with {-# LANGUAGE NoMonomorphismRestriction #-}
22:49:16 <ddarius> jsnx: What would the "type" of the counit be?
22:49:29 <vixey> hml: it exists to help though (at least that was the intention of adding it)
22:50:35 <jsnx> ddarius: C+C -> C at C
22:50:46 <dolio> It's a tradeoff. There's plenty of ugliness in Haskell, though.
22:50:49 <ddarius> conal: Have you done anything with the continuous behaviours in the reactive library?
22:50:51 <hml> wait wait; how does "f1 x = show x" differ form "f2 = \x -> show x"
22:50:51 <rwbarton> jsnx: It's just the "fold" map that sends each copy of C to C by the identity
22:51:28 <jsnx> what i should say, is that i'm having trouble with the co-unit diagram
22:51:39 <ddarius> What is the equation?
22:51:43 <vixey> hml: let and lambda have different typing rules
22:51:55 <ddarius> :t either id id
22:51:56 <lambdabot> forall b. Either b b -> b
22:52:04 <Twey> I don't care too much about the monomorphism restriction, I think... always try to give explicit type signatures anyway
22:52:05 <vixey> hml: for example  let f = id in (f 1, f "foo) is fine but (\f -> (f 1, f "foo")) id  will not type check
22:52:57 <vixey> hml: does that make sense?
22:53:46 * luqui has inexplicably started leaving off type signatures
22:53:55 <jsnx> the tough part is ∐((A,B)) → ∐(Δ(C))
22:53:55 <hml> not quite
22:54:12 <vixey> why?
22:54:51 <dolio> The difference between 'f x = show x' and 'f = \x -> show x' is the monomorphism restriction.
22:55:00 <jsnx> the arrow is supposed to ∐(g*) where g* is unique
22:55:22 <jsnx> (is that upside down pi coming across right for you guys?)
22:55:37 <hml> vixey: I don't undersxtand why the l;atter one has type problems?
22:55:51 <chrisdone> for those of us living in the 2000's, yeah
22:56:15 <vixey> hml: the typing rules
22:56:23 <ddarius> jsnx: Have you heard of Skolemization?
22:56:50 <jsnx> ddarius:
22:56:51 <jsnx> no
22:56:59 <luqui> hml, that's good intuition, it "shouldn't"
22:57:21 <luqui> hml, unfortunately if you allow it, type inference becomes undecidable...
22:57:32 <hml> wow
22:57:44 <hml> i thought type inference was only exponential time worst case
22:57:45 <vixey> luqui: what?
22:57:53 <hml> how does this make it undecidable?
22:57:53 <jsnx> ddarius: okay, i am at the wiki page
22:59:05 <dolio> hml: Higher-rank polymorphism is undecidable in general.
22:59:18 <jsnx> as far as g* goes, i don't see how it can be unique
22:59:26 <dolio> And you lose principal types unless you get fancy.
22:59:44 <hml> I like this quote: ---    Oversimplifying the debate somewhat: Those in favour tend to be those who have written Haskell Implementations and those against tend to be those who have written complex combinator libraries
23:00:19 <jsnx> i can combine some f : A -> C and g : B -> C with the injectors i_1, i_2 : C -> C+C in four different ways, and it will work just as well
23:00:33 <hml> OMG; I hate this quote: --- In a few very rare cases, however, you may need to supply a type signa
23:00:40 <hml> ture which is not valid Haskell.
23:03:24 <ddarius> jsnx: You have your diagram wrong.
23:03:41 <jsnx> oh?
23:03:54 <jsnx> okay, i will put it up on hpaste, just a second
23:04:42 <dag22110> is haskell in any way related to haxe?
23:04:52 <dag22110> I'm kinda a newb
23:05:11 <Twey> No, dag22110
23:05:21 <dag22110> k
23:05:23 <hml> it'd be awesome if it were; i'd love to write flash code in haskell
23:05:32 <dag22110> yeah
23:05:39 <Twey> « The name haXe was chosen because it is short, easy, cool, and "has an X inside", which the author claims is necessary to make any new technology a success. » *laughs*
23:05:43 <dag22110> I got excited when I found out about haxe and thought it might be related
23:05:48 <dag22110> didn't really look too much further
23:05:58 <Twey> It's much cooler than haXe.  :-)
23:06:11 <Twey> hml: Well, Yhc has a Javascript backend
23:06:30 <Twey> I'm sure it wouldn't be too difficult to adjust it for other varieties of ECMAScript
23:07:02 <_zenon_> Trinithis, thanks, was quite a short paper, but perfectly understandable (and readable)
23:07:15 <hml> so i read http://www.haskell.org/haskellwiki/Monomorphism_restriction ... and don't understand any of it
23:07:16 <lambdabot> Title: Monomorphism restriction - HaskellWiki
23:07:24 <Trinithis> np
23:07:27 <hml> so maybe i should write a haskell implementation, and all of this will be clear?
23:07:35 * Twey laughs.
23:08:26 <vixey> hml: You'd be better off reading TAPL
23:08:29 <dag22110> I'm assessing haskell as a web app platform
23:08:49 <dag22110> seems better for other kinds of dev work
23:08:49 <Twey> dag22110: You probably want to check out HAppS, then
23:09:00 <Twey> http://happs.org/
23:09:03 <lambdabot> Title: HAppS  The Haskell Application Server
23:09:08 <dag22110> oo
23:09:08 <dag22110> nice
23:09:10 <dag22110> thx
23:09:31 <dag22110> I'm going to try to port http://politicalbloopers.com over
23:09:32 <dag22110> :)
23:09:33 * Twey gives a slight wince at « Write web services really easy »
23:09:33 <lambdabot> Title: Politicalbloopers.com - Politicalbloopers Resources and Information. This websit ...
23:09:55 <dag22110> I did that last night on nothing but caffeine and the daily show
23:10:10 <dag22110> um
23:10:13 <dag22110> wrong address though
23:10:15 <dag22110> hehe
23:10:22 <Twey> Hahaha, dag22110
23:10:23 <dag22110> http://congressbloopers.com
23:10:25 <lambdabot> Title: Congress Bloopers!
23:10:28 <dag22110> thats it
23:10:57 <dag22110> I guess caffeine and lack of sleep has an impact on short term memory
23:11:42 <_zenon_> dag22110, No! Not caffeine :)
23:11:53 <dag22110> haha
23:11:59 <_zenon_> What impacts your memory is the _loss_ if caffeine
23:12:03 <_zenon_> of*
23:12:16 <dag22110> yes
23:12:22 <Trinithis> Good thing I hate the smell of coffee
23:12:28 <mxc> vixey - i've read TAPL, i took bcpierce's course, doesn't make much of haskell clear at all
23:12:38 <olsner> caffeine makes normal people temporarily have ADD
23:12:44 <mxc> well, the course does, but the book doesn't really
23:12:45 <_zenon_> Therefore, keeping a steady gut-knifing supply of coffee keeps you on edge (and later on it keeps you on edge of the toilet seat) :D
23:12:49 <dag22110> I already have ADD
23:12:50 <mxc> cool covere though
23:12:53 <jsnx> damn, it ruined all my unicode
23:12:53 <mxc> cover
23:13:07 <dag22110> aw
23:13:15 <dag22110> well thanks on the HAppS
23:13:33 <dag22110> I've got some numerical simulations to run too
23:13:39 <conal`> ddarius: just noticed your question.  yes.  i've filled them out in the new lib version.
23:13:43 <conal`> ddarius: (continuous behaviors, that is)
23:13:45 <dag22110> haxe + c looks like an awesome combination
23:14:14 <oter> @type map
23:14:14 <ddarius> jsnx: Anyway, just write out the equations the diagrams represent and solve.  You'll find that you aren't able to choose any combination of injections you please to make the equality hold.
23:14:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:14:35 <jsnx> http://hpaste.org/9303
23:14:44 <jsnx> ddarius: oh
23:14:51 <jsnx> okay, i will look into that
23:16:56 <mmorrow> machine epsilon on my computer
23:16:58 <conal`> ddarius: btw, i really like your ReactiveIRC bot, once i could see the FRP part.
23:17:00 <mmorrow> > length . takeWhile (not . isInfinite) $ fix (scanl (+) (1e-323))
23:17:15 <lambdabot>  thread killed
23:17:20 <mmorrow> > length . takeWhile (not . isInfinite) $ fix (scanl (+) (1e-200))
23:17:21 <lambdabot>  1689
23:17:21 <ddarius> conal`: Ah, the wiki page points at the wrong darcs repo
23:17:30 <mmorrow> > length . takeWhile (not . isInfinite) $ fix (scanl (+) (1e-300))
23:17:31 <lambdabot>  2021
23:18:15 <hml> why does this not work?
23:18:16 <hml> Prelude Text.ParserCombinators.Parsec> :t Parser
23:18:17 <hml> <interactive>:1:0: Not in scope: data constructor `Parser'
23:18:21 <vixey> where is that bot?
23:18:22 <conal`> ddarius: i haven't release the new version.  it's under active development.
23:19:54 <Twey> @src isInfinite
23:19:54 <lambdabot> Source not found. The more you drive -- the dumber you get.
23:19:55 <conal`> ddarius: i'll update the wiki page now to explain about the old vs new version.
23:19:56 <Twey> :<
23:20:10 <luqui> hml, because Parser is a type, not a term
23:20:30 <hml> ./Parsec/String.hs:type Parser = Parsec String ()
23:20:58 <ddarius> Yeah, I just updated it to reflect the newer repo, but I was going to add in a comment with links to both repos.
23:21:13 <glguy> :( MonadLib doesn't have a BaseM instance for ST
23:22:52 <sjanssen> glguy: ST seems like one of the few monads you'd actually need an instance for
23:22:55 * Twey winces again at « HAppS does not come with a server-side templating system. We prefer the pattern of developing static web pages and using AJAX to populate them with dynamic content. »
23:23:06 <glguy> instance BaseM (ST s) (ST s) where inBase = id
23:23:08 * Twey turns JS off on happs.org and see what breaks.
23:23:11 <glguy> Apparently it was in there at one time
23:23:18 <Twey> to**
23:23:37 <glguy> Mon Dec 15 10:10:11 PST 2003  diatchki
23:23:37 <glguy>   * add instances for inBase for the ST monad
23:23:38 <Twey> Oh bloody hell
23:23:42 <glguy> but I don't see it in the current code..
23:23:55 <Twey> That's horrible
23:24:07 * Twey decides *not* to use HAppS for his next web project...
23:24:29 <ddarius> Twey: There is something that combines HSP with, I think, HAppS
23:24:36 * conal` heads to the office.  back online soon.
23:24:48 <Twey> ddarius: I don't think I trust code that takes that approach... :-\
23:25:13 <ddarius> Twey: HAppS doesn't -require- you to use AJAX
23:25:21 <jeffz> Twey: do you vehemently oppose flash also?
23:25:50 <Twey> jeffz: I don't vehemently oppose either, I'm a long-time Javascript developer
23:25:57 <glguy> How do I ask darcs to find the patch that removed that line/
23:26:06 <Twey> And as such I'm very much aware that sites shouldn't be built such that they break without it
23:26:10 <Twey> Ditto with Flash
23:26:31 <Twey> (except for the long-time developer part, I don't work with Flash)
23:26:46 <mmorrow> what's flash?
23:27:05 <vixey> mmorrow: flash is what you make swf's with
23:27:13 <mmorrow> ;)
23:27:21 <Twey> You can use whatever you like, so long as you understand the bandwidth issues and are careful to provide fallbacks.
23:28:11 <Twey> ddarius: Yes, but it also doesn't exactly make it easy to do anything without it.  Combining HSP and HAppS doesn't sound like my ideal framework, really.
23:28:23 * Twey would rather write his own.
23:28:34 <vixey> your own what?
23:28:50 <Twey> Web framework.
23:29:00 <vixey> I don't know what that is
23:29:41 <Twey> vixey: An app that takes care of the glue for web applications
23:30:01 <vixey> what is the glue?
23:30:58 <Twey> vixey: Well, you need a webserver, usually a templating system, a nice interface to the information provided to the webserver, a way of routing URLs to specific modules, &c.
23:31:11 <chrisdone> anyone got an emacs script to send things like `cabal configure`, `cabal build`, `sudo cabal install`, `cabal haddock`, etc. to *shell* and pop it up in a separate buffer like inferior-haskell-mode?
23:31:13 <vixey> why make it so complicated?
23:31:26 <Twey> vixey: As opposed to what?
23:31:36 <vixey> simple
23:31:45 <Twey> How do you propose making it simple?
23:32:18 <chrisdone> glguy: how come you chose to use fastcgi over happs for hpaste2?
23:33:05 <glguy> happs had been a moving target for a while and I didn't want a repeat of hpaste1
23:33:05 <Twey> Hi Chris
23:33:06 <glguy> and
23:33:34 <glguy> I felt like there was too much magic in the happs api at that point with the template haskell and typeclasses with such a range of instances
23:33:42 <glguy> and I didn't want to deal with that either
23:33:56 <chrisdone> hi twey
23:34:11 <chrisdone> glguy: ah, I see
23:36:58 <Twey> vixey: There's a lot of bookkeeping involved in any web app of a decent size
23:37:24 <vixey> what sort of bookkeeping?
23:38:19 <Twey> Forgetting, for a moment, the issues of making a webserver (say you're using FastCGI with Apache or something), having bits of HTML scattered through your program really isn't a neat way of doing things, and it becomes completely unmanageable very fast for applications of any appreciable size
23:38:59 <vixey> ok so you need lisp macros
23:39:07 * Twey laughs.
23:39:21 <vixey> am I wrong?
23:39:23 <vixey> what's funny
23:39:57 <Twey> vixey: Do it and show me.
23:40:15 <vixey> Twey: I still don't know what's funny
23:40:20 <Twey> If you tried it, you would.
23:40:40 <vixey> Twey: exactly what is it I have not tried?
23:41:05 <Twey> Apparently, designing any kind of large web application :-)
23:41:32 * Shiruka thinks about digging out eliza and psaikowanalizing the channel
23:41:43 * Trinithis senses a battle of wits!
23:41:44 <vixey> Twey: that is the problem right there, you are complicating things
23:41:46 * Twey laughs.
23:42:00 <vixey> Twey: Why would anybody write a large program instead of a small simple one?
23:42:48 <Twey> Er, because as great as the UNIX philosophy may be, sometimes people need an application that does more than a single string transformation.
23:43:02 <Twey> I direct you, for example, to http://www.amazon.com/
23:43:19 <vixey> Twey: Right, and there is the false assumption, there's no reason a program that does more than a single string transform has to be complicated
23:43:55 <Twey> I see
23:44:13 <Twey> So how do you propose offering the features of Amazon without the program being complicated?
23:45:23 <vixey> Twey: You're only asking me that so you can laugh again
23:45:36 <Twey> Of course.
23:45:49 <Twey> That would be why you didn't answer this question last time, either?  :-)
23:46:48 <Shiruka> a web framework that does templating stuff, url routing, etc. isn't really overly complicated solution to the problem..
23:47:11 <telexicon> Shiruka, oh?
23:47:19 <Twey> A framework is something that ties the various parts of an application together so that the applications themselves can be simple.
23:47:40 <Twey> If the applications are cat and grep, the framework is UNIX.
23:48:06 <Shiruka> besides, the framework is usable in many web apps
23:48:15 * Twey nods.
23:49:11 <Shiruka> for implementing a program that computes fibonacci numbers, implementing GHC would be over the top too.. but GHC is generally useful, so it's ok to use it for the fibonacci thing everyone loves so much
23:49:50 * Shiruka does not have any pet peeves or anything, really! ;-)
23:49:54 <chrisdone> twey: I am actually writing a web framework called kibro
23:50:03 <Twey> Hehe, nice, chrisdone
23:50:08 <Twey> May I see?
23:50:28 <chrisdone> I say framework, I just mean I'm going to plug together fastcgi, lighttpd, sqlite
23:50:31 <chrisdone> not yet
23:50:53 <Twey> Shiruka: We only love Fibonacci numbers so much because main = putStrLn "Hello, world!" is distinctly underwhelming :-P
23:51:06 <Trinithis> lol
23:51:41 <chrisdone> it doesn't whelm me so much
23:51:54 <Trinithis> oh. I misread underwhelming with overwhelming
23:52:12 <Twey> Hahaha
23:52:15 * Shiruka likes hello world better
23:52:27 <Shiruka> it's nicely wide-eyed and optimistic
23:52:49 * Trinithis thought Twey were nagging people who say, "What's a monad??"
23:52:50 <Twey> We should write an extremely complex program to generate "Hello, world!" that can be expressed in one short line of Haskell
23:52:53 <dons> we should come up with a new hello world for haskell people.
23:53:07 <vixey> fibs
23:53:10 <dons> a fun program, implementable in many ways
23:53:15 <dons> but also short.
23:53:21 * Twey nods.
23:53:24 <vixey> *in your own language implemented in haskell
23:53:29 <dons> i know, a web server!
23:53:38 <dons> ok. scratch taht.
23:53:44 <vixey> lol why do you want somebody to write a webserver
23:53:46 <vixey> ?
23:53:50 <jeffz> people always do it wrong
23:54:03 <dons> i want more network stuff. the world runs on the interwebs, not more generalised zipper tries.
23:54:05 * Twey nods.
23:54:21 <Twey> I find network apps terribly exciting for some reason.
23:54:35 <dons> the kids love network apps.
23:54:42 <Shiruka> a DDOS program you can sic at your enemies!
23:54:44 <Shiruka> .. or maybe not
23:55:13 <Shiruka> we might earn that bin laden cuil reputation..
23:55:17 <dons> pulling down or putting up content, lots of concurrency, parsing. pretty printing.
23:55:18 <Twey> Hahaha
23:55:28 <chrisdone> I'd personally like to see shit-loads of haskell web apps
23:55:29 <Twey> Distribution
23:55:34 <dons> should be easy to use haskell as the language for solid web stuff. all just parsing, concurrency and pretty printing.
23:55:40 <dons> i.e. right in the hitting zone.
23:55:43 <Twey> Aye
23:55:53 <Twey> Anyone familiar with Genshi?
23:56:03 <dons> the wiki markup thing?
23:56:17 <luqui> but it's all imperative.  oh so imperative...
23:56:19 <Twey> dons: No, it's a whole smart XML-based templating system
23:56:22 <dons> ah no.
23:56:23 <dons> right.
23:56:28 <dons> yeah, that kind of thing.
23:56:30 <Twey> It seems so ideal for Haskell.
23:56:36 * dons thought "Geshi"
23:56:40 * luqui refers to the state-of-the-art, not anything fundamental about the medium
23:56:49 <dons> right. parsing, templating, its language stuff.
23:56:50 <Trinithis> Geshi a programming language?
23:56:59 <dons> Geshi the wiki thing.
23:57:22 <dons> the tupil guys are doing good things with happs, which is nice.
23:57:37 <dons> use that as our platform for tossing out quick web apps.
23:57:52 <slava> hi dons
23:57:59 <dons> heya slava.
23:58:02 <Shiruka> a web crawler would satisfy most of the requirements, but it's rather boring as such..
23:58:16 <vixey> hi conal :)
23:58:48 <conal> vixey: hi
23:58:48 <lambdabot> conal: You have 3 new messages. '/msg lambdabot @messages' to read them.
23:58:51 <Shiruka> it should do something more interesting, like count the moron editor index of a wikipedia page or something
23:59:14 <Twey> dons: This whole discussion sprang from me being hugely underwhelmed with HAppS' philosophy :-)
23:59:26 <Shiruka> (with tunable definition of "moron")
23:59:31 <telexicon> genshi?
23:59:34 <telexicon> Twey, ive used genshi
23:59:35 <dons> heh. i've noticed a growth in happs posts the last 3 or 4 months.
23:59:39 <dons> so i think its on its way back.
