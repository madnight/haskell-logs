00:02:01 <hpaste>  Euler_ pasted "Website Search Engine (very inefficient) -- comments please!" at http://hpaste.org/8699
00:03:40 <povman> Euler_: what kind of feedback are you after?
00:04:43 <kiris> Cale: I'm still working on it, btw. :P learning a lot about building λb and the cabal dependancies. give me a minute
00:04:58 <Euler_> I'm curious as to how I can make it more efficient. It takes about 6 seconds to return the data.
00:06:01 <Euler_> I know It's because I'm doing a string comparison with "isInfixOf" .. but is there anything else
00:06:25 <atp> Euler_: have you profiled it?
00:06:35 <Euler_> what other methods can I use that don't use isInfixOf
00:06:59 <vixey> KMP
00:07:15 <Cale> Plenty of linear algebra? ;)
00:07:29 <Euler_> atp, what does it mean to "profile it"  ..I'm not up on the lingo
00:08:04 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
00:08:06 <lambdabot> Title: Chapter 6. Profiling, http://tinyurl.com/kwh6c
00:08:38 <Mr_Awesome> Euler_: if youve never heard of profiling, you might want to consult a more general introduction
00:09:54 <Euler_> oooOooOo that looks important
00:10:10 <Cale> Basically, GHC provides you with a way to compile your program such that it can output data about how long it spent evaluating various functions, or how much allocation was done
00:12:02 <Euler_> WOW ! i can't believe I never knew about this..
00:12:18 <Euler_> that's so cool!
00:12:32 <Cale> Yeah, it's quite handy :)
00:13:42 <Cale> You can also generate and display data about which code was used in a given run or set of runs of the program, which is useful as a first approximation to determine if your tests are testing everything.
00:14:37 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/hpc.html
00:14:37 <lambdabot> Title: 6.6. Observing Code Coverage
00:14:54 <proqesi> how do I set up to build ghc on win32? I have ghc installed, and when I build from source I get the error: checking for path to top of build tree... ghc.exe: Can't find package.conf as c:\WIN\driver\package.conf.inplace
00:15:26 <Cale> proqesi: are you making changes to ghc?
00:16:06 <Cale> (this is just always the first question that I ask, because if you're not, there's no real point in compiling it :)
00:16:29 <proqesi> Cale: no, but I get the same error when I build Monadius
00:17:03 <proqesi> Cale: which would make it seem that my system is pretty badly borked
00:17:22 <Cale> package.conf is the file that stores information about which Cabal packages are installed.
00:17:45 <kiris> Cale: what version of cabal do you use?
00:17:50 <Cale> One should get installed when you install GHC.
00:17:59 <Cale> kiris: The one which comes with GHC.
00:18:18 <kiris> mine is 1.4.0.1 and it doesn't seem to support the "--global" parameter
00:18:32 <Cale> Here, it seems to be 1.2.4.0
00:18:39 <kiris> ah
00:18:41 <Cale> Which is the version that comes with GHC 6.8.3
00:19:25 <kiris> should I just remove cabal and update go ghc 6.8.3?
00:19:29 <kiris> s/go/to
00:19:53 <Cale> kiris: You can try it without --global, but I found that if the packages are installed as user, hs-plugins seems to have trouble finding them.
00:20:07 <Cale> I'm not sure why that is, or what can be done about it.
00:20:38 <Cale> But it won't matter if you're just building lambdabot to see if it builds.
00:20:41 <kiris> mmkay
00:20:53 <Cale> It's a problem that only shows up when you go to evaluate an expression, like
00:20:55 <Cale> > 1 + 1
00:20:56 <lambdabot>  2
00:21:15 <kiris> heh
00:21:42 <Cale> (or when you run runplugs)
00:22:57 <kiris> I'm trying this ./build out
00:23:36 <kiris> 'tis downloading and installation lots of stuff
00:23:52 <kiris> haha, what the hell
00:24:09 <kiris> Resolving dependencies...
00:24:09 <kiris> nonsense.
00:24:10 <kiris> blah
00:24:16 <Cale> uhh...
00:24:21 <kiris> (end quote) who wrote that?
00:24:30 <Cale> No idea.
00:24:35 <Cale> I've never seen that :)
00:24:45 <kiris> curious george
00:26:21 <kiris> great stuff, it built lambdabot. fails with a strange link error for runplugs but I don't need that right now
00:28:05 <Cale> cool
00:28:45 <kiris> I can't believe we're going to have to wait even longer for more BSG
00:29:55 <Cale> Yeah, what's going on with that?
00:30:51 <kiris> I think we're going to have to wait until '09 for the next season. did you see the final ep of this season?
00:31:38 <Cale> The last I watched was S4E10
00:34:10 <Cale> Ah, okay, I thought that lacked finality. Technically it's that the second half of the season will continue in 2009.
00:34:15 <kiris> ah, that's right. it seemed like a final episode because it was so strange and
00:34:18 <kiris> right
00:35:03 <Cale> This is the last season too.
00:35:30 <kiris> who do you think the final Cylon is? :p
00:37:49 <kiris> how can I get Plugin/Url.hs to recognise the changes in lambdabot-utils/Url.hs? I keep getting Not in scope: `runWebReq' even though I have clearly exported it from lambdabot-utils/Url.hs
00:37:51 <Cale> I'm not sure.
00:37:53 <Cale> oh
00:38:07 <Cale> huh
00:38:24 <Cale> and lambdabot-utils got rebuilt?
00:39:08 <kiris> hm, maybe it didn't
00:39:59 <Cale> are my commands to  runghc ./Setup.hs clean  in the build script?
00:40:12 <Cale> I don't remember whether I've pushed that yet :P
00:40:20 <kiris> yes they are indeed
00:40:30 <kiris> runghc Setup.hs clean
00:41:04 <kiris> oh...
00:41:12 <kiris> haha, oh god
00:41:36 <Cale> what?
00:42:05 <kiris> I think I changed runghc a while ago when trying to do a sort of web script execution thing for lighttpd
00:42:19 <kiris> very silly, I kno
00:42:32 <Cale> heh
00:43:48 <kiris> okay, I have the old version
00:43:53 <kiris> I swear this patch is worth it
00:44:55 <kiris> hey ndm
00:45:08 <ndm> hi kiris
00:45:13 <kiris> right, it has rebuilt utils
00:45:29 <ndm> @seen vincenz
00:45:29 <lambdabot> vincenz is in #haskell. I don't know when vincenz last spoke.
00:45:57 <kiris> ndm: I put tagsoup to good use in λb's Title grabber :D
00:46:16 <ndm> kiris: cool :)
00:46:19 * kiris worship, etc.
00:46:42 <osfameron> what's the funny backwards 'h' character?
00:46:52 <Zao> osfameron: Lambda?
00:47:07 <povman> osfameron: it's the most important character in haskell
00:47:14 <kiris> how do you do that backwards `b'?
00:47:19 <osfameron> oh!  I usually see that written as more diagonal, like ,\
00:47:21 <povman> it's what \ tries to be
00:47:26 <kiris> hehe
00:47:44 <Cale> osfameron: perhaps you're using a strange font :)
00:47:46 <Zao> osfameron: This may be a shock to you, but there's different fonts out there.
00:47:57 <osfameron> could be
00:48:28 <osfameron> this looks like an oversize backwards "h" with the top line flopping over onto itself
00:48:32 <osfameron> rather unimpressive
00:48:55 <Zao> http://zao.se/~zao/lambda.png
00:49:08 <vixey> the properties assigned to it are what's interesting
00:49:35 <osfameron> Zao: yeah, that's the version of it I know and love
00:50:05 * osfameron makes a note to change his rxvt config as soon as, er, he works out how to change his rxvt config...
00:50:24 <Zao> osfameron: Fiddle with your X resource DB?
00:50:30 <osfameron> (yes, gnome terminal wasn't very good, but at least even a numpty like me could work out how to change font...)
00:50:47 <Zao> The resources available are listed in the man page.
00:51:00 <Cale> Apparently Church wanted to use a hat over the bound variable, but due to typographical constraints ended up settling for lambda.
00:51:17 <osfameron> Zao: well, I know which config file to edit.  But writing the xfontspec in a way that rxvt a) accepts it and b) doesn't do something horrid to it with insane double-spacing seems to be beyond me...
00:51:49 <osfameron> oh, no, that was xterm font config
00:51:57 <osfameron> rxvt is the lovely: urxvt*font: xft:Bitstream Vera Sans Mono:pixelsize=11
00:52:01 <Cale> Now, due to further typographical constraints, we end up settling for a backslash... you'd think things would be headed in the other direction wouldn't you? :)
00:52:02 <kiris> Cale: right-o! it built! good stuff: pull? http://chrisdone.com/lambdabot
00:52:04 <lambdabot> Title: Index of /lambdabot/
00:52:37 <osfameron> Cale: oh, so the greek letter "lambda" doesn't have any particular meaning mathematically, he just wanted a pretty character?
00:53:03 <kiris> well, it does now
00:54:25 <Cale> osfameron: Well, it sort of looks like the hat that he wanted.
00:54:31 <kiris> Zao: your font made me lean forward and squint. :P do you have a hueg screen?
00:54:54 <Zao> kiris: 20" wide at 1680x1050
00:55:03 <kiris> Zao: nice!
00:55:10 <Zao> I run X at 72DPI, just to fit more.
00:55:22 <Cale> osfameron: Other than that, it's an arbitrary decision.
00:55:38 <osfameron> interesting
00:55:39 <kiris> Zao: “Tiling Window Mangers: I've got to fit it ALL"
00:57:19 <kiris> test: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader-Class.html
00:57:22 <Zao> kiris: http://zao.se/~zao/72.png
00:57:26 <lambdabot> Title: Control.Monad.Reader.Class, http://tinyurl.com/6n4hrl
00:57:29 <kiris> good stuff
00:57:39 <kiris> Cale: thanks :)
00:58:19 <kiris> Zao: what WM is that?
00:58:26 <Zao> I haven't even bothered re-enabling my secondary monitor after reinstalling, got enough room on a single one.
00:58:30 <Zao> kiris: xmonad
00:58:58 <kiris> very nace... makes me want to try it out again
00:59:08 <Zao> With gnome-terminal and gnome-panel for convenience.
00:59:24 <Cale> Tiling window managers are great if all you ever run are terminals (and possibly some panels :)
00:59:34 <ejt> xmonad is great
01:00:19 <Cale> I would love to run a Haskell windowmanager, but I just can't stand tiling for some reason.
01:01:28 <kiris> Zao: is the sauce for that Pong game available for download? :P
01:01:49 <mercury^> Cale: xmonad supports non-tiling workspaces too
01:01:51 <mercury^> afaik
01:02:08 <ejt> y, you can have floating windows
01:02:09 <Cale> mercury^: yeah, but not all that well currently
01:02:20 <ejt> I very rarely use them though
01:02:41 <ejt> only useful for little dialogs eg, the firefox download window
01:02:48 <kiris> and GIMP
01:02:58 <ejt> y
01:03:31 <Zao> kiris: No, since I just started it :)
01:03:55 <Zao> kiris: I got a bit sidetracked getting my head wrapped around how to shovel a StateT into a GLUT callback.
01:05:10 * dolio is totally baffled by his profiling results.
01:05:21 <kiris> Zao: ah, oki :)
01:09:51 <cheng> Does any use haskell to verify some C/C++ code? If it is please give me a small example about this verifed process.
01:10:50 <Vq^> what do you mean by verify?
01:13:22 <cheng> For example if i implement a protocol with C/C++ code and i want to know there are some bugs in this code. I want to use Haskell to verify this code.
01:13:59 <Vq^> ah, then you just need to reimplement it in Haskell and then recompile it to C
01:14:18 <vixey> cheng: You probably use hoare triples etc.. I don't think introducing Haskell will help prove properties about C
01:14:22 <Vq^> thought i would probably go for some lint-like program (splint) and test-cases
01:15:10 <ejt> cheng: do you want the Haskell program to analyse the C code, or just call it
01:15:29 <ejt> if the latter then try starting with: http://www.haskell.org/haskellwiki/FFI_Introduction
01:15:30 <lambdabot> Title: FFI Introduction - HaskellWiki
01:15:57 <cheng> vixey: But hoare triples can't verify the code easily. I mean if there are some source code lines we coule reimplement the same mechansim with Haskell and monads but hoare triples is not a good choice.
01:16:26 <vixey> cheng: if you say so ...
01:16:27 <cheng> ejt: analyze the c code not call it.
01:17:09 <ejt> cheng: ok, ignore me then :)
01:17:29 <povman> cheng: it's not clear what you actually want
01:18:16 <povman> but I agree with Vq^ - your first bug is that you wrote it in C ;)
01:18:58 <cheng> povman: I know there should be buggy in the c code but i try to use Haskell to prove it.
01:19:01 <ejt> perhaps you're looking for the Haskell equivalent of ocaml's CIL library /
01:19:02 <ejt> ?
01:19:52 <cheng> ejt: Ocaml. I really hope the haskell could help me to prove the codes.
01:19:52 <mmorrow> do you want to analyze it to determine that it correctly executes the protocol (so have the haskell talk to it via whatever), or (for instance) parse it and check for the possibility of dereferencing nullpointers, or ...?
01:20:01 <mmorrow> cheng: ^
01:20:07 <vixey> cheng: What gives you the impression this is a valid or useful method?
01:20:22 <koninkje> @hoogle whenever
01:20:22 <lambdabot> No matches found
01:20:36 <cheng> mmorrow: yes, What i want do you is like what you said.
01:20:50 <mmorrow> cheng: which one? both?
01:20:55 <ejt> cheng: that was an 'or' question
01:21:14 <cheng> mmorrow: the first one.
01:22:14 <cheng> I want to know how to verify the code not the model. I think the Haskell and mondas could implement most of the functions originally by C/C++ so I think it is possible.
01:22:32 <mmorrow> cheng: QuickCheck may be helpful to you then
01:23:34 <mmorrow> cheng: You would write a function which randomly generates some requests/whatever and then see if the C program handles them correctly
01:23:59 <cheng> mmorrow: It seems that QuickCheck could test the Haskell.
01:24:00 <Vq^> thats just ordinary testing, isn't it?
01:24:11 <mmorrow> cheng: that too
01:24:29 <cheng> Vq^: more or less. I think
01:24:48 <mmorrow> Vq^: i guess. i had in my generating random conversations within the protocol
01:25:13 <mmorrow> ...had in mind...
01:25:39 <Vq^> thats a good idea, i know i've seen random code-generators before to try parsers in compilers
01:26:20 <cheng> mmorrow: I hope if i could use Hasekll to implement all the sub functions and then if I know the Haskell code is definitely correct. I could know at least the sub fucntions level of the C/C++ is correct.
01:26:24 <mmorrow> Vq^: totally, seeing one such example of that's what gave me that idea
01:26:45 <ejt> cheng: how do you know that the Haskell code doesn't have the same bug as the C code ?
01:26:55 <cheng> to VQ^: it is good idea . But it is not my aim.
01:26:57 <Vq^> thats also a good idea, two implementations that you can test the random data against
01:27:02 <mmorrow> cheng: well, if you're going that far, you chould either write the end product in haskell, or have haskell *generate* the C
01:27:12 <ejt> y, generate is the way to go
01:27:18 <dolio> You translate the Haskell code to Coq and prove that it's correct there. :)
01:27:34 <vixey> cheng: no answer.. ?
01:27:35 <ejt> must save up for the Coq book
01:27:35 <cheng> mmorrow: I am not going so far. so i want to know the possibility.
01:27:47 <Vq^> cheng: well, i don't see how you can analyze the C source itself in a usefull way
01:28:08 <ejt> I've used haskell to generate test cases for C code
01:28:13 <cheng> mmorrwow: using haskell to implement some products, the performance is a problem.
01:28:21 <Vq^> cheng: problem is that you specify so much more than a programs behaviour in C
01:28:48 <vixey> and the languages have different syntax.. different semantics ...
01:28:56 <mmorrow> cheng: what is a specific example of one area of your implementation where the haskell would be too slow?
01:30:19 <cheng> mmorrow: :) I don't like to discuss with you about the performance problem. I implemented a small algorithm with Haskell, it is definitely slower than C implementation.
01:30:57 <ndm> cheng, improving the performance of Haskell programs is fairly well understood, with a lot of expertise on this channel, verifying C is still an open research problem
01:31:09 <cheng> mmorrow: It is not my point. I only want to know how to use Haskell to enhance the correctness of C code. Maybe using Haskell to generate C is good idea.
01:31:46 <Vq^> cheng: then it's probably better to optimize the Haskell-code
01:32:16 <flux> although, it's not easy to write code that has static guarantees about the _generated_ code
01:32:39 <cheng> ndm: Thanks. verifying C is possible now.  http://ertos.nicta.com.au/research/l4.verified/
01:32:41 <Vq^> one way might be to write a code-generator
01:32:42 <lambdabot> Title: NICTA | ERTOS - http://www.ertos.nicta.com.au/research/l4.verified/home.pml
01:32:42 <mmorrow> cheng: ok. well, if you want to get the benefit of the safety you get in haskell *and* want the speed of C where it matters, in my opinion the only three options are (1) use haskell to generate the C (2) write the critical parts in C and the reasoning in haskell and use the FFI to interface them (3) write the whole thing in haskell
01:32:57 <Vq^> i know there was some C or C++ library that was generated by an ocaml-program
01:33:06 <ndm> cheng, they verified a small part of a small system an it took an insane amount of effort
01:33:06 <Vq^> can't remember which :/
01:33:17 <flux> there are many C code analyzers around. cyclone is another approach to the problem; change the language in a way that can (?) be compiled back to C
01:33:33 <cheng> lambodabot: Are you from ERTOS?
01:33:39 <flux> vq^, the fft library
01:33:47 <Vq^> flux: yeah, thats the one
01:34:00 <ndm> (its incredibly cool, but not a tool yet, more a research direction)
01:34:36 <Vq^> to tell the story short, you overspecify so much in C that analyzing becomes hard and almost everyone just uses automated testing instead
01:34:45 <cheng> They claimed they will finish in the near future.  maybe in the end of this year.
01:35:03 <Vq^> and if you want proofs i recomend changing language
01:35:10 <ndm> its an important step towards verifying C, not an easy way to go
01:36:41 <mmorrow> cheng: in that link you gave, they are *generating* the C/asm from a Haskell specification (i'm not clear if they are using Haskell of another such lang to generate the code, but that doesn't matter)
01:36:53 <vixey> if you want proofs don't say hoare triples are too hard
01:37:00 <vixey> proving things about code is *hard*
01:37:03 <mmorrow> ...Haskell or another such ...
01:37:13 <vixey> regardless of language
01:37:30 <dolio> Just give ndm a grant to work on -O11 for a couple years, then you can write in Haskell.
01:37:34 <cheng> I think the mmorrow's conclusion is perfect. But we still have another way like ERTOS. Write the whole thing with C/C++ and then Verify these code in Hasekll.  Then we could get the benefit from both C and Haskell.  Do you agree?
01:37:36 <dolio> That's the easy solution. :)
01:37:44 <cheng> dolio: ?
01:37:57 <ndm> dolio, or give me a grant to work on Catch, and I'll prove the Haskell - i'm not fussed
01:38:07 <dolio> Either way. :)
01:38:43 <mmorrow> cheng: i know that it's common practice to verify circuits, maybe the general way the attack that problem will be helpful to you? (i don't know the specifics)
01:38:47 <ndm> cheng: -O11 is a supercompiler, really fast code with no programmer effort - which can make Haskell competetive with C in some cases
01:39:06 <ndm> i think people have had great success with model checkers for verifying C
01:39:19 <ndm> and I think the circuit people have use the same approach
01:39:29 <ndm> certainly Lava integrates with one of them
01:40:33 <swiert> cheng: you may also want to look at Caduceus: http://caduceus.lri.fr/
01:40:34 <lambdabot> Title: Caduceus: a verification tool for C programs
01:42:17 <cheng> somehow I think the advantage of Haskell is the Mondas. It could cover the side effect of many IO operation but in the low level the IO operation is not ignored. So I would like to use Haskell not any others.
01:43:03 <swiert> To be honest, I don't think Haskell's monads make verifying C programs any easier.
01:43:34 <mmorrow> i think he means if he were to use haskell for the entire implem
01:44:36 <flux> an extension for C adding monads would be interesting :-)
01:44:51 <flux> especially paired with no support for closures.. hmm..
01:47:49 <FordCortina> anybody know why this isnt valid agda? "  isReturnPlus (returnPlus _ _) = True"
01:47:59 <FordCortina> i get
01:48:12 <kiris> returnPlus should be ReturnPlus? maybe?
01:48:28 <FordCortina> not according to the rest of this code
01:48:31 <kiris> ok
01:48:34 <FordCortina> its agda not haskell
01:48:41 <kiris> I saw
01:48:44 <vixey> um no.. Agda doesn't care about casing
01:48:47 <FordCortina> presumable constructors dont need capitals
01:49:02 <kiris> yeah, I don't know Agda. I took a wild guess like a maniac
01:49:13 <FordCortina> :) thanks anyway
01:49:50 <mmorrow> "...like a maniac" lol
01:53:33 <swiert> FordCortina: hpaste your code and I'd be happy to have a look.
01:54:08 <dolio> Yeah, it's hard to make any judgments just from that snippet.
01:54:31 * vixey was waiting for the end of the "i get" sentence..
01:54:41 <kosmikus> FordCortina: what's the error message?
01:54:53 <FordCortina> hang on
01:55:44 <FordCortina> ill explain a bit
01:56:15 <FordCortina> the code is not mine, the whole lot can be found here. I'm just trying to get it to work in the latest version of agda
01:56:17 <FordCortina> http://www.cs.nott.ac.uk/~nad/repos/parser-combinators.code
01:56:19 <lambdabot> Title: Index of /~nad/repos/parser-combinators.code
01:56:28 <FordCortina> (its a darcs repo)
01:56:38 <FordCortina> there is a function
01:56:44 <kosmikus> oh yes, I'm familiar with that
01:56:53 <FordCortina> in Parrallel.agda
01:57:00 <dolio> Since Agda folks are here, I'll ask something I was wondering earlier: is there some way of working with existential types in Agda (or languages like it)?
01:57:03 <FordCortina> that uses @ patterns
01:57:23 <FordCortina> i think they've been removed from Agda
01:57:27 <dolio> I was fooling with it earlier, and at first blush, it seems like it would at least move all my types into Set1, which is rather undesirable.
01:57:33 <kosmikus> dolio: sure, dependent pairs (Sigma-types)
01:57:36 <dolio> Either that, or restrict me to a custom universe.
01:58:06 <FordCortina> now i was trying to get rid of them (the @ patterns) by making a Parser -> Bool function
01:58:33 <FordCortina> hence the snippet "isReturnPlus (returnPlus _ _) = True"
01:58:42 <FordCortina> that's all i added in
01:59:01 <FordCortina> i commented out _|_ and stuck in "isReturnPlus"
02:00:26 <kosmikus> you still haven't told me what the error is
02:00:46 <FordCortina> oh ok
02:00:48 <FordCortina> !paste
02:00:49 <hpaste> Haskell paste bin: http://hpaste.org/
02:01:04 <swiert> dolio: you can also use the -type-in-type flag...
02:01:11 <swiert> dolio: but that's cheating a bit.
02:01:13 <dolio> kosmikus: Dependent pairs seemed different to me for some reason. Perhaps due to their not hiding the type?
02:01:53 <swiert> dolio: I think the technical term is "strong" vs "weak" existentials.
02:02:00 <vixey> exists x : T, P x is weak
02:02:01 <dolio> Ah.
02:02:25 <swiert> I always forget which one is which.
02:02:36 <vixey> you can take both projections of a strong sum
02:02:51 <hpaste>  FordCortina pasted "syntax error?" at http://hpaste.org/8700
02:03:15 <Dae_> morning.... *yawns*
02:03:51 <kosmikus> FordCortina: first of all, I think you have to give a type signature
02:04:03 <FordCortina> kosmikus: ^there's my error
02:04:03 <mattam> Is it possible to have weak sums in Agda?
02:04:45 <kosmikus> FordCortina: also, True should probably be true
02:04:52 <vixey> I think so.. if you encode it as the eliminator (can't try it at the moment..)
02:04:54 <swiert> mattam: I don't know - maybe if you cleverly hide the projections in a different module.
02:05:04 <kosmikus> FordCortina: and you'll need a case that returns "false" as well to make the function total
02:05:34 * kosmikus has to leave now
02:05:55 <vixey> FordCortina: Do you know that _|_ denotes the infix function named '|' ?
02:06:26 <cnwdup> clad|away: ping
02:06:44 <FordCortina> vixey: yes
02:07:02 <FordCortina> did i miss something?
02:07:45 <vixey> FordCortina: Well I have no idea what cast is, did you mean to write it like <space><space>isReturnPlus .. rather than without spaces?a
02:08:43 <FordCortina> Daniellson seems to have written it with two spaces before every definition
02:08:51 <FordCortina> so i did the same
02:09:58 <FordCortina> oh hang on
02:10:02 <FordCortina> that's not quite true
02:10:32 <FordCortina> that group of functions is covered by a "private" keyword
02:10:41 <FordCortina> that's why they are indented with two spaces
02:11:25 <FordCortina> but it think my function is still in the right scope
02:12:08 <FordCortina> ill paste the whole file
02:13:09 <hpaste>  FordCortina pasted "Parallel.agda" at http://hpaste.org/8701
02:14:05 <FordCortina> ive got a different error now...
02:14:18 <FordCortina> i added in a type and a false case
02:14:37 <FordCortina> (its in what i just pasted)
02:15:31 <FordCortina> ah i think this might be working now
02:18:27 <dibblego> is it possible to write something like: data Monad' m = Monad' (forall a. a -> m a) (forall a. forall b. m a -> (a -> m b) -> m b)
02:20:04 <quicksilver> yes.
02:20:18 <quicksilver> in GHC obviously, not in haskell.
02:20:58 <dibblego> ghc tells me I need -XTypeOperators, but it seems to still not compile
02:23:32 <quicksilver> can't imagine why it thinks you need type operators
02:23:37 <quicksilver> you need RankNTypes though
02:25:08 <dibblego> is that the correct syntax? I just invented it
02:26:41 <quicksilver> I would write the second one forall a b .
02:26:42 <quicksilver> I think
02:26:56 <quicksilver> I don't use RankNTypes in practice, so I've not really tied.
02:27:57 <quicksilver> dibblego: what you wrote compiles for me with -fglasgow-exts
02:28:07 <quicksilver> what error did you get with RankNTypes?
02:28:09 <dibblego> {-# OPTIONS_GHC RankNTypes #-}
02:28:12 <dibblego> I'm using a pragma
02:28:17 <quicksilver> {-# LANGUAGE
02:28:20 <quicksilver> not OPTIONS GHC
02:28:32 <dibblego> oh thanks :)
02:28:53 <hpaste>  dolio pasted "Existentials in Agda" at http://hpaste.org/8702
02:30:45 <dolio> Anyhow, I suppose I get the reason why that happens.
02:32:12 <dolio> Why Stream gets bumped up to Set1, that is.
02:33:23 <dolio> Since it's storing the type s. But it seems like there's a sort of data that GHC can represent but Agda can't.
02:35:32 <_zenon_> Where do all the haskell docs go ? I assume /usr/share/doc ?
02:41:18 <hpaste>  dibblego pasted "(no title)" at http://hpaste.org/8703
03:00:21 <FordCortina> do you need an MTA on your machine for "darcs send" to work?
03:03:35 <therp> FordCortina: sendmail should work I guess
03:05:12 <vincenz> ndmitchell: what's up
03:07:42 <quicksilver> FordCortina: well you can use darc send in offline mode.
03:08:18 <FordCortina> yeh i found the -o switch
03:08:24 <FordCortina> thanks
03:08:30 <vincenz> @tell ndm Just @tell me :)
03:08:30 <lambdabot> Consider it noted.
03:08:41 <quicksilver> FordCortina: technically it's an MSA you need.
03:26:08 <kiris> :t join
03:26:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:30:33 <hpaste>  dibblego pasted "(no title)" at http://hpaste.org/8704
03:49:36 <mmorrow> hmm    http://thefutureofthings.com/column/1004/what-is-adiabatic-computation.html
03:49:37 <lambdabot> Title: What is Adiabatic Computation? - TFOT, http://tinyurl.com/6dc54q
03:54:09 <_zenon_> How do I read the libghc docs?
03:54:59 <_zenon_> /usr/share/doc/libghc6-mtl-doc  only has a changelog
03:57:11 <_zenon_> I would really want to know how to use them
04:00:49 <_zenon_> No one?
04:04:04 <Zao> _zenon_: Are they installed at all?
04:04:35 <_zenon_> Zao: I did an apt-get install
04:04:43 <_zenon_> Zao: So I sure hope so
04:04:58 <Zao> It seems they are in /u/s/doc/ghc6-doc/libraries
04:06:22 <_zenon_> Zao: Thank you :)
04:06:25 <_zenon_> They where :)
04:12:41 <Dae_> mmorrow: Yeah...its a nice idea, but it wouldn't be worth it on first generation quantum computers
04:14:33 <mmorrow> hmm, i don't really know anything nonbasic about quantum computers
04:16:09 <mmorrow> that article struck me as interesting because it reminded me of thinking about how you could solve an integral by mapping the problem onto a circuit and using an oscilloscope
04:16:17 <mmorrow> a so-called analog computer
04:16:52 <lilachaze> mmorrow: i've only got a couple of paragraphs through it, and i'm already unimpressed. "suppose we're looking for the value of x which minimizes this *cubic* in x".
04:17:29 <mmorrow> that entire site doesn't appear to be at the forefront of rigor
04:21:25 * Dae_ is doing a simultion of the exact principle he's talking about, in the background.....
04:23:49 <dolio> @remember qwe1234 all turing-complete languages are infinitely composable, otherwise they wouldn't be turing-complete.
04:23:50 <lambdabot> It is forever etched in my memory.
04:25:18 <dibblego> lol
04:25:25 <Eelis> question about parsec: if i do   parse (string "abc") "" "abd"   , i get the error "column 1: unexpected d. expecting abc". i don't like this error, as it seems to suggest that there is a 'd' at column 1 of the input (which there isn't).
04:25:29 <Eelis> i can get a better error by replacing    string "abc"   with   char 'a' >> char 'b' >> char 'c'   which turns the error into "column 3: unexpected d. expecting c". this solution works, but it seems silly to have to do this. is there a better way?
04:26:53 <ADEpt> Eelis: "mystring str = sequence $ mapM char str" :)
04:27:22 <Eelis> ADEpt: yes, i know i can automate it, but still.. isn't it wildly inefficient or something like that?
04:27:43 <Eelis> i'm hoping i'm overlooking a regular solution
04:27:51 <ADEpt> Eelis: i dont think that it would be very unefficient
04:28:38 <Eelis> frankly, i'm sort of surprised that   string "abc"   isn't simply equivalent to   char 'a' >> char 'b' >> char 'c'
04:28:39 <mmorrow> ha, somehow in my tomboy notes program (gnome toolbar applet) all occurences of the word "a" have been mysteriously replaced by the word "objdump"
04:28:39 <ADEpt> Eelis: the whole point of the error report is to give you the point where the parser was when error occured (excluding lookahead). So you might rethink your requirement re error reporting
04:28:58 <mmorrow> for a second i thought i was losing my mind
04:29:22 <mmorrow> (all occurences of "a" in *all* notes)
04:29:37 <Eelis> ADEpt: but that's exactly what i want: to have it report where the error occurred. the problem is that using   string "abc", i don't get that behavior
04:29:53 <Dae_> mmorrow: Ohh, that's not a bug. It happens to everyone today. It's official day of the objdump....
04:30:43 <ADEpt> Eelis: i'm 100% sure that in the long run you would be better off with error reports like they are, but i am not sure that I would be able to convince you of this :)
04:31:30 <mmorrow> heres what a lambdabot quotes has become in my "Quotes" note:
04:31:35 <mmorrow> <lambdabot> I'm RELIGIOUS!!  I love objdump man with objdump HAIRPIECE!!  Equip me with MISSILES!!
04:31:48 <Eelis> ADEpt: i just foresee users bugging me about these strange errors that don't appear to make sense :/
04:32:20 <Eelis> and i'm not looking forward to having to tell them "yes, it's parsec quirkyness" all the time
04:32:37 <Dae_> mmorrow: Right.... that -is- weird.....
04:32:39 <ADEpt> Eelis: in the long run you will have a complex parser with lots of rules and error "expected 'a', got 'x' in the position ..." would leave you with couple dozens of suspect parsers and no clue as to where it all crashed
04:32:52 <quicksilver> error messages for parsing are HARD to get right.
04:33:09 <quicksilver> play with parsec's error combinators to improve messages for your users though.
04:33:36 <Eelis> i am.
04:33:58 <Eelis> ADEpt: anyway, thanks for your response :)
04:34:31 <mmorrow> Dae_: there isn't even an option to search-and-replace words in a *single* note, let alone 100
04:35:24 <Toxaris> is there something like Arrow but without arr?
04:35:42 <Dae_> mmorrow: Well... are you sure it's not the rendering so to speak? That it has actually saved the notes correctly, but is just showing them weirdly?
04:36:23 <mmorrow> i'm baffled and amused, i'll eventually figure out what happened
04:36:29 <mmorrow> just probably not soon
04:37:36 <Dae_> mmorrow: Could be a friend messing with your comp? I have friends who would find such a prank infinitely amusing
04:38:50 <mmorrow> if someone managed this that would be amazing in so many ways
04:38:58 <mmorrow> (and infinitely amusing)
04:40:43 <RayNbow> @bots
04:40:43 <lambdabot> :)
04:41:38 * Dae_ remembers replacing www.thepiratebay.org with www.cia.gov in a friends hostfile....
04:41:52 <mmorrow> heh
04:42:10 <fooblya_monad> :)
04:42:11 <mmorrow> finding all sorts of notes i've forgotten about, here's a link: http://www.ctheory.net/articles.aspx?id=500
04:42:11 <lambdabot> Title: CTheory.net
04:42:47 <Dae_> Yeah, he was freaking out..... a lot.... and then we replace www.eve-online.com with the french world of warcraft page and he figure it out....
04:44:09 <mmorrow> he was probably like "wuh??! waaaaiiiiiiit a secondddd!!"
04:44:52 <mmorrow> from that article: "This relationship makes all organisms parasites in that they gain their existence from the surrounding environment to which they are functionally and organizationally coupled."
04:45:13 <Dae_> doesn't that make them symbiots?
04:45:21 <Dae_> rather than parasites?
04:45:22 <mmorrow> the article at that link's a pretty good read at the least
04:45:41 <Dae_> yeah, seems like it... will probably read it later :)
04:45:50 <quicksilver> depends if you think they give something back to the environment or not
04:45:53 <mmorrow> it's written by a journalist "reinterpreting" research by a computer scientist
04:46:09 <quicksilver> some people define symbiotic as mutual dependency, some people just as mutual helpfulness
04:46:18 <quicksilver> in either case parasitism is one-sided in contrast
04:46:26 <Dae_> btw, does anyone have the the source code for gph? It seems such a shame that it got killed by bitrot....
04:46:34 <mmorrow> a lot of fluff and pandering, but a few nice insights imo
04:47:32 <mmorrow> quicksilver: yes, pandering
04:47:47 <quicksilver> Dae_: didn't it just get folded into GHC?
04:48:14 <Dae_> quicksilver: only the parallel part... I want the distributed part using pvm.....
04:48:37 <quicksilver> that's gdh, IIRC
04:49:28 <Dae_> quicksilver: nope -> http://www.macs.hw.ac.uk/~dsg/gph/
04:49:35 <lambdabot> Title: Glasgow Parallel Haskell
04:49:36 <Dae_> but the ftp server is down...
04:50:30 <quicksilver> http://www.macs.hw.ac.uk/~dsg/gdh/
04:50:30 <lambdabot> Title: Glasgow Distributed Haskell
04:50:33 <quicksilver> is the gdh site.
04:50:42 <Dae_> ohh...right...just noticed that as well....
04:51:01 <quicksilver> I'm pretty sure gph doesn't do distribution.
04:51:05 <_zenon_> Hm.. I really like the arrows
04:52:05 <mmorrow> i love the virus pseudo code in that article:
04:52:07 <mmorrow> main-program:=
04:52:07 <mmorrow> {infect-executable;
04:52:07 <mmorrow> if trigger-pulled then do-damage;
04:52:07 <mmorrow> goto next;}
04:54:50 <quicksilver> I used to think that OpenGL's state machine was a rather elegant computational model.
04:55:04 <quicksilver> having spent a few weeks on ##opengl I now understand the problems with such models
04:55:18 <mmorrow> do tell
04:56:52 <quicksilver> massive non-locality of effects.
04:56:59 <quicksilver> someone will try to help with his code
04:57:15 <quicksilver> and it will turn out that a single isolated call "many functions away" can completely change behaviour
04:57:39 <quicksilver> so code which, in isolation, is sensible, actually depends on a the state of a a very long list of state variables.
04:58:06 <quicksilver> e.g. glEnable(GL_LIGHTING); in a different file will completely destroy certain rendering techniques.
04:58:44 <Dae_> quicksilver: you wouldn't happen to know if someone's still working on gdh, would you?  Hacking ghc sources scare me a bit....
04:58:55 <mmorrow> quicksilver: everyday i like haskell more and more
04:59:49 <quicksilver> mmorrow: to be fair, it's quite possible to model such non-locality in haskell.
04:59:59 <mmorrow> exactly!
05:00:07 <mmorrow> :)
05:00:12 <quicksilver> an arbtrirarily complex monad can embed an arbitrary amount of non-local data and lead to the same error
05:00:19 <mmorrow> oh, i thought you said *im*possible
05:00:24 <quicksilver> so we can get the same kind of bug.
05:00:25 <mmorrow> yeah, true
05:00:35 <quicksilver> haskell might make us thinking harder abut doing so
05:00:46 <mmorrow> yeah, i was just typing that
05:00:50 <quicksilver> of course, the openGL guys are not stupid. The *reason* for doing it that way is that state changes are expensive.
05:01:06 <quicksilver> and bracketing every single primitive with all the state it depends on would be too expensive.
05:01:22 <quicksilver> but still, I now perceive the shortcoming as well as the benefit.
05:01:40 <mmorrow> it's essentially the same model as that of modern computers
05:01:51 <quicksilver> right.
05:01:55 <quicksilver> and, in particular graphics cards.
05:02:02 <quicksilver> which is why :)
05:02:06 <mmorrow> heh
05:02:17 <quicksilver> graphics cards have loads and loads of registers holding this state
05:02:23 <quicksilver> setting a register takes time
05:02:32 <quicksilver> so minimising register sets is a good ida.
05:02:34 <quicksilver> idea.
05:03:34 <mmorrow> i've programmed opengl in C a fair amount, but never in haskell
05:04:00 <mmorrow> i'm now curious how exactly the haskell interface is structured
05:04:09 <matthew-_> lack of isolation then?
05:04:29 <Peaker> I am trying to create a trivial arrow datatype looking like: data C a@(a1,a2) b@(b1,b2) = Pure | Bind (C a x) (C x b) | First (C a1 b1) | Parallel (C a1 b1) (C a2 b2) -- but obviously I cannot use "pattern matching" on the types themselves. Hopefully it conveys what I'm trying to do though
05:05:00 <quicksilver> mmorrow: by and large the haskell mapping is a straight map of the C
05:05:14 <quicksilver> mmorrow: but it tidies up constants into ADTs
05:05:20 <quicksilver> merges related functions into one function
05:05:33 <quicksilver> and pairs up the push/pop pairs into 'preserving' combinators
05:06:06 <quicksilver> it's pretty much a monotonic improvement on C
05:06:16 <quicksilver> "tidy up all the bits where type safety helps, without changing structure"
05:06:24 <mmorrow> ah. yeah, i've been meaning to take it for a spin, it seems to me higher order funcs would make it a dream
05:06:28 <mmorrow> (wrt C)
05:06:30 <quicksilver> it does.
05:06:39 <mapreduce> I'm not sure it's possible to use OpenGL without wanting to wrap it.
05:06:54 <mmorrow> heh
05:07:15 <quicksilver> forM_ [(1,1,x) | x <- [1..5]] \x y z -> vertex $ Vertex3 x y z
05:07:25 <quicksilver> is so much more pleasant than the C equivalent.
05:07:31 <Peaker> the "global state machine" paradigm of OpenGL is also annoying (they're finally replacing that with OO style in the new OpenGL
05:07:39 <quicksilver> actually that's not a great example on reflection.
05:07:42 <quicksilver> but that kind of thing.
05:07:45 <mmorrow> haha
05:07:55 <Spark> i thought opengl had contexts
05:08:06 <Peaker> Spark: global contexts
05:08:06 <quicksilver> it does, I'm slightly abusing the sense 'global'
05:08:14 <quicksilver> global-per-context
05:08:17 <quicksilver> the issues are the same
05:08:23 <Spark> sounds like "object" to me :)
05:08:30 <mapreduce> It reminds me of Logo.
05:08:44 <Spark> it's an opaque structure
05:08:52 <quicksilver> Peaker: I don't think openGL 3 is OO
05:08:57 <Peaker> anyone has any idea how to define the above datatype? The idea is that this will be possible: instance Arrow C where { pure f = Pure ; a >>> b = Bind a b ; first a = First a ; a *** b = Parallel a b }
05:09:13 <quicksilver> they use the word "object" to make C++ programmers feel warm and safe.
05:09:25 <quicksilver> but actually openGL 3 "object"s are immutable.
05:09:28 <mmorrow> i hope hope hope OpenGL is not moving to OO
05:09:34 <quicksilver> they're much more like haskell values than C++ objects.
05:09:50 <Peaker> quicksilver: Well, I hope glBegin(GL_TRIANGLE); ... ; glEnd(); is replaced by a gl.makeTriangle(parameters)
05:10:07 <quicksilver> why?
05:10:13 <quicksilver> in what way is that better?
05:10:15 <Peaker> quicksilver: because I dislike the idea of "current globals"
05:10:17 <telexicon> whoa
05:10:25 <Peaker> quicksilver: a global "current state" that is
05:10:37 <telexicon> nobody is really supposed to be rendering primitives that way anymore anyways
05:10:38 <Peaker> quicksilver: GL state should be encapsulated
05:11:05 <quicksilver> it has already been, essentially, replaced by drawElements
05:11:10 <quicksilver> as telexicon is pointing out.
05:11:24 <telexicon> well there are 3 better mechanisms
05:11:41 <telexicon> you can use display lists so it remembers the sequence of render calls
05:11:42 <Peaker> What do you mean by essentially replaced?  A couple of years ago when skimming a lot of OpenGL tutorials, I saw a lot of glBegin... and no glDrawElements..
05:11:54 <quicksilver> Peaker: you were reading tutorials from the 17th century.
05:11:55 <Peaker> telexicon: even a "display list" is a "global current state"
05:12:03 <telexicon> Peaker, glDrawArrays
05:12:07 <quicksilver> which is not surprising, because most of the tutorials are old.
05:12:12 <telexicon> still global current state
05:12:22 <quicksilver> immediate mode is a nice way to learn.
05:12:25 <telexicon> then there are vertex buffer objects
05:13:33 <Peaker> quicksilver: some global state is inevitable in GL, but the structures you build with GL calls do not have to be.  When making a GL list it would be more elegant to make such a structure as a value and convert it to a list with another non-global function
05:13:48 <quicksilver> true.
05:13:56 <quicksilver> but I don't think that's a big wart compared to the others.
05:14:07 <quicksilver> the underlying "structure" of display lists is very complex
05:14:13 <quicksilver> they can contain almost any kind of state change.
05:14:24 <quicksilver> the C language is totally unequipped to cope with that kind of structure
05:14:34 <Peaker> anyone has any idea about my arrow question?
05:14:36 <quicksilver> the begin() end() idiom is the most elegant way.
05:14:49 <quicksilver> Peaker: you didn't really get as far as saying what the problem was?
05:14:57 <quicksilver> with your arrow question.
05:15:13 <Peaker> I want a datatype C that makes this code possible: instance Arrow C where { pure f = Pure ; a >>> b = Bind a b ; first a = First a ; a *** b = Parallel a b }
05:15:19 <Peaker> and I am not sure if that is possible
05:15:37 <quicksilver> why are you discarding "f" ?
05:15:58 <quicksilver> should be possible wit GADTs, anyhow.
05:16:15 <Peaker> quicksilver: Because I don't want an executable arrow, just something that can present the arrow as a graph. Since (a->b) is not an instance of Show, there's nothing I can do with that a->b yet. I will figure out how to show a->b later and not discard it
05:16:42 * quicksilver nods
05:17:04 <quicksilver> well you need GADTs to have a range on constructors which work at different types
05:17:12 <quicksilver> which I guess was the problem you were driving at with teh Parallel question
05:17:23 <quicksilver> with GADTs you can more or less rewrite a class into a data
05:17:55 <Peaker> I am not sure what a GADT is
05:18:20 <quicksilver> http://www.haskell.org/haskellwiki/GADT
05:18:22 <lambdabot> Title: Generalised algebraic datatype - HaskellWiki
05:18:58 <Peaker> it seems like I need something like: data C a@(a1,a2) b@(b1,b2) = Pure | Bind (C a x) (C x b) | First (C a1 b1) | Parallel (C a1 b1) (C a2 b2) -- which ofcourse doesn't work
05:19:33 <quicksilver> which is the problem that GADTs solve.
05:19:47 * Peaker reads
05:20:05 <quicksilver> data C a b where Pure :: (a ->b) -> C a b, Bind :: C a x -> C x b -> C a b
05:20:07 <quicksilver> etc.
05:20:37 <mmorrow> Peaker: you could always show Con (a -> b)  as "Con (a -> b)"
05:20:56 <Peaker> mmorrow: Con?
05:21:03 <mmorrow> constructor
05:21:14 <Peaker> mmorrow: yeah, I'll show "Pure a->b", that's still discarding f
05:21:19 <mmorrow> yes
05:21:35 <Peaker> quicksilver: thanks, I'll toy around with that approach
05:22:05 <Toxaris> to rephrase my question: would there be room for Arrow without arr?
05:22:38 <mmorrow> Peaker: on the topic of GADTs and Show instances, i wrote an deriver of Show for GADTs which is currently in a cgi program until i clean it up
05:22:42 * mmorrow gets link
05:23:26 <quicksilver> Toxaris: definitely.
05:23:34 <quicksilver> Toxaris: (I didn't see you ask that question)
05:23:46 <Toxaris> quicksilver: well I asked whether it exists
05:23:52 <quicksilver> Toxaris: it does.
05:23:54 <quicksilver> Control.Category
05:24:06 <quicksilver> it's a very useful thing.
05:24:08 <mmorrow> http://morrow.jypsis.com/cgi-bin/gadtshow.cgi
05:24:09 <lambdabot> Title: GADT Show
05:24:12 <quicksilver> well not Control.Category per se
05:24:19 <quicksilver> but hte idea of composable things without pure
05:24:30 <quicksilver> I quite often come across abstract representations of functions
05:24:38 <quicksilver> they have the exact *opposite* of pure
05:24:47 <quicksilver> they have "interpret :: A a b -> (a -> b)"
05:25:04 <mmorrow> Peaker: the only way to avoid the tedium of writing your own Show for a GADT as far as I know
05:25:29 <Toxaris> quicksilver: interesting idea.
05:26:10 <quicksilver> Toxaris: I have an ADT for rendering functional textures (procedural textures) which has at least two examples
05:26:19 <quicksilver> textures themselves and colormaps
05:26:27 <quicksilver> both ADTs which can be interpreted as functions
05:28:26 <Toxaris> well, but for my use case, I need the other arrow combinators, too, not just >>> and id.
05:29:22 <Toxaris> maybe what i want is hidden in category-extras, how am I to find out?
05:30:49 <Peaker> mmorrow: thanks
05:31:02 <mmorrow> Peaker: no prob :)
05:31:59 <Toxaris> quicksilver: basically, I want to define combinators on folds of an ADT, which I reify as a product of functions mirroring the sum of products which define the ADT. now I can do a lot of stuff "constructor-wise" on these reified folds, including everything from Arrow except arr/pure
05:32:28 <Toxaris> (maybe I'm scared by my own words)
05:32:34 <Toxaris> no, sometimes, not maybe
05:33:35 <mmorrow> Toxaris: look into the categorical definition of Product and CoProduct (Sum)
05:34:02 <mmorrow> what you just said would become much more manageable
05:34:16 <mmorrow> both to "see" and to implement
05:34:44 <quicksilver> Toxaris: should be in cat-extras I think
05:35:21 <mmorrow> Product := P (p -> a) (p -> b)        CoProduct :=  S (a -> s) (b -> s)
05:36:54 <quicksilver> Toxaris: I even think Control.Category has some of the sum/product stuff
05:36:59 <quicksilver> but I can't see the haddock
05:37:31 <Toxaris> quicksilver: aren't you talking about category-extras Control.Category: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category.html
05:37:33 <lambdabot> Title: Control.Category, http://tinyurl.com/6qx7vs
05:38:10 <Peaker> inside a GADT "data C a b where", am I allowed to define: "Bind :: C a x -> C x b -> C a b" ? (e.g use of x)
05:38:16 <Peaker> s/e.g/i.e
05:38:22 <mmorrow> yes
05:38:38 <Peaker> great, thanks
05:38:48 <mmorrow> the variables     data GADT <here> where   are dummies
05:38:49 <quicksilver> Toxaris: no, I wasn't.
05:39:08 <Toxaris> quicksilver: oh there is another?
05:39:13 <quicksilver> Toxaris: I was talking about the C.C in the unreleased darcs library bundle
05:39:20 <quicksilver> Toxaris: for which, strangely, I can't find the docs.
05:39:21 <mmorrow> all they serve to convey is the kind of that gadt
05:39:47 <quicksilver> I thought it would show up at http://www.haskell.org/ghc/docs/latest/html/libraries/ but they don't
05:39:48 <lambdabot> Title: Haskell Hierarchical Libraries
05:39:57 <mmorrow> so these are equiv:    data A a b z where      and     data A a :: * -> * -> *
05:40:12 <mmorrow> and  data A :: * -> * -> * -> *
05:40:37 <quicksilver> mmorrow: does GADT imply KindAnnotations ?
05:40:54 <Peaker> mmorrow: cool
05:41:14 <mmorrow> no, but kind annotations can be used interchangeably with type vars in the "data _ where" part
05:41:21 * quicksilver nods
05:42:56 <peti> How reliable is throwTo under Windows? I have a forkIO'ed thread in waitForInput, and I throw it an exception to abort it, but that exception appears to be blocked. It isn't delivered.
05:44:26 <Dae_> is there a monadic version of par?
05:45:20 <Peaker> Dae_: I don't think normal monads can have that
05:45:33 <Peaker> I think  you need cumutative monads to specify parallelization there
05:46:33 <Dae_> hmm... just seemed sorta natural to me... but I guess not
05:48:25 <Zao> @pl \s a -> \i j k l -> runReaderT (a i j k l) s
05:48:25 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (runReaderT .)) .)) .)) .))
05:48:36 <quicksilver> peti: waitForInput?
05:49:54 <Zao> For some reason, the pointful version feels a bit more readable.
05:50:56 <quicksilver> peti: throwTo is reliable, but there are some things you have to understand about threaded/nonthreaded RTS, foreign calls, and so on.
05:52:18 <Toxaris> mmorrow: Now that I think about CT, I don't understand my own idea anymore :( It seems that I cannot implement >>> in my design
05:53:48 <Toxaris> mmorrow: instead I can compose with a regular function, both to the left and to the right
05:54:03 <mmorrow> Toxaris: hmm, i have to reread your design. >>> should be easy since it's just (flip (.)) and (.) is pretty natural for functions/morphisms/arrows/functions/whatever
05:54:36 <Peaker> mmorrow: your show deriver is cool, but its yelling at me that it cannot derive Show on the stuff contained in the Data constructors
05:54:54 <Peaker> mmorrow: (ghc is yelling that is)
05:55:17 <mmorrow> Peaker: well then you have to find a way to derive show for those too :)
05:55:51 <Toxaris> mmorrow: my idea is to define for each data T = C1 T T | C2 | ... a data TFold a b = TFold {c1 :: a -> a -> b; c2 :: b; ...}
05:56:15 <Toxaris> mmorrow: and foldT :: T -> TFold a a -> a
05:56:20 <mmorrow> Toxaris: ooh, you may have something there with right/left composition.
05:56:46 <Peaker> mmorrow: this the data constructor: Bind :: C a x -> C x b -> C a b -- C is the containing datatype, how do I derive show there?
05:57:15 <mmorrow> Peaker: ah, i hate those. GHC doesn't allow it :(
05:57:47 <mmorrow> Toxaris: that is known by various names depending on situation and a few other details. An "action", a "multiplication", etc
05:58:24 <mmorrow> a real vector space is actually and action (a multiplication) of R on R^n
05:59:04 <mmorrow> this just isn't apparent because the R *happens* to be the same as the R in R^n
05:59:36 <quicksilver> Toxaris: here, http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Category.html
05:59:37 <lambdabot> Title: Control.Category, http://tinyurl.com/6nk4lo
05:59:39 <quicksilver> Toxaris: and, I was wrong :)
05:59:46 <quicksilver> Toxaris: I *thought* that had more methods in than it does.
06:00:08 <Peaker> mmorrow: so its impossible to make it an instance of Show?
06:00:25 <Toxaris> quicksilver: thanks for digging that up.
06:00:35 <mmorrow> Peaker: is it saying something like "Can't determine that x is an instance of Show" ?
06:00:57 <Peaker> mmorrow: yeah
06:01:12 <Peaker> "Could not deduce (Show x2) from the context ()"
06:01:18 <quicksilver> Toxaris: I didn't properly appreciate there are two docs URLs, one for darcs and one for released :)
06:01:25 <Toxaris> quicksilver: unfortunately, it seems that i'm in some different terroritory with my idea, if I understand mmorrow correctly
06:01:28 <mmorrow> Peaker: if so, i can't seem to figure it out either, and it's looking more and more like ghc won't allow it or isn't sufficiently capable of infering it
06:01:56 <mmorrow> well, if the latter then the former but not vice-versa
06:01:58 <Saizan> Peaker: remove the (Show a,Show b) context in the instance head, since you don't care about it, you're just going to print the contructors, no?
06:02:19 <Peaker> Saizan: In case of Pure yeah, but in the other constructors, maybe not
06:02:25 <Peaker> Saizan: Well I guess I could do that
06:02:26 <mar77a> @where error handling
06:02:26 <lambdabot> I know nothing about error.
06:02:30 <mmorrow> Peaker: yeah, as Saizan says, you could always just make the show instance not depend on that x
06:02:51 <mmorrow> (or that _)
06:02:52 <Saizan> mmorrow: how can it infer (Show x)? x there is existentially quantified with no typeclass context
06:03:04 <mmorrow> it can't
06:03:59 <mmorrow> so i guess i meant...in the cases where it *is* an instance of show, it's not possible to convey this
06:04:50 <mmorrow> (i don't know if this desire makes sense)
06:05:18 <Toxaris> mmorrow: that I have a multiplication or whatever means that I have composeLeft :: (a -> b) -> (b ~> c) -> (a ~> c) and composeRight :: (a ~> b) -> (b -> c) -> (a ~> c), yes?
06:05:39 <mmorrow> Toxaris: yes!
06:06:22 <mmorrow> Toxaris: so in the commutative case, they'll coincide
06:06:27 <Peaker> mmorrow: there is probably no way to properly convey this, I think.  Because the pattern-match will only be known at runtime, and different pattern matches place differing demands on the type of the input arguments
06:07:05 <mmorrow> Peaker: that is very true
06:07:08 <mmorrow> hmm
06:07:59 <Peaker> mmorrow: there are useful cases (like Show), where   (Show (a,b) means that Show a AND Show b) so one can prove there isn't a problem, but the compiler probably can't prove this in a general way
06:08:25 <Peaker> (in this case, (Show (C a b)) means that Show a and Show b
06:08:31 <quicksilver> you can add contexts to individual constructors
06:08:35 <quicksilver> in GADTs
06:08:40 <quicksilver> I haven't been following, does that help? :)
06:08:42 <Toxaris> Peaker: couldnt the compiler follow the instances backward?
06:08:57 <mmorrow> Peaker: yeah, with the current form of typeclass and gadts i agree this isn't possible
06:09:18 <Peaker> quicksilver: as in: You can only use the constructor on those types at all?  That could help, but its not perfect, as you want to place that limitation on the constructor only if Show is going to be used on the type
06:10:07 <Peaker> quicksilver: e.g the context has to be in a specific constructor in a specific instance
06:10:18 <gwern> hm. 1/2:half :: 1/4:?
06:10:27 <quicksilver> the problem is Bind :: C a x -> C x b -> C a b ?
06:10:37 <Peaker> quicksilver: in the instance of Show yeah
06:10:43 <quicksilver> what show instance did you try to write for it?
06:10:51 <quicksilver> are you requiring Show a,b or not?
06:10:57 <Toxaris> mmorrow: ok that's cool enough for a start, but I also have (and need) (&&&) and (***) with the types from Control.Arrow,
06:11:10 <Peaker> quicksilver: Yeah,I want to use show on the two C's given
06:11:27 <quicksilver> but does that require Show for a,x,b ?
06:11:29 <Toxaris> mmorrow: commutative case? how can a binary function on different types be commutative?
06:11:32 <quicksilver> that's the question as far as I can tell.
06:11:32 <Peaker> quicksilver: yeah
06:11:36 <mmorrow> Toxaris: could you paste some code? i'm having trouble following exactly what you're doing
06:11:37 <quicksilver> why?
06:11:46 <quicksilver> you don't have specific values anyway, it's an arrow
06:11:49 <Peaker> quicksilver: because Show (C a x) requires show on a and x
06:11:52 <quicksilver> but why?
06:11:56 <quicksilver> how is it going to use them?
06:11:58 <mmorrow> Toxaris: heh, i should have put an * there
06:12:27 <Toxaris> mmorrow: ?
06:12:31 <Peaker> quicksilver: I want to treat them as values, I don't see any other way of showing which entities depend on which
06:12:43 <mmorrow> Toxaris: so,   7 * (1,1,1) = (7,7,7)     where R is acting on R^3
06:12:58 <mmorrow> (1,1,1) * 7  = (7,7,7)     where R is acting on R^3 on the left
06:13:03 <quicksilver> Peaker: I don't see that.
06:13:15 <quicksilver> Peaker: surely none of the constructors of C a b actualy takes values ?
06:13:24 <Peaker> quicksilver: a >>> b = Bind a b
06:13:26 <quicksilver> (of types a,b)
06:13:38 <mmorrow> Toxaris: so it's in a slightly different sense than for binary ops
06:13:45 <Peaker> quicksilver: like that you mean?
06:13:56 <quicksilver> in that example a :: C x y and b :: C y z
06:13:56 <Toxaris> mmorrow: ok now I see, as a Haskell programmer, I would use different symboles for these two *, because they have different type
06:14:04 <quicksilver> there are no 'values' of type x, y or z
06:14:23 <Peaker> quicksilver: why? They are values of some (C a b) type?
06:14:31 <quicksilver> (and Bind a b :: C x z)
06:14:37 <quicksilver> you are totally confusing types and values.
06:14:49 <mmorrow> Toxaris: heh, but what about polymorphism? ;)
06:14:51 <quicksilver> "a" is a value of your arrow type. Its type is C x y
06:14:54 <quicksilver> for some types x,y
06:15:09 <quicksilver> "Bind a b" is a value of type C x z
06:15:22 <quicksilver> "C a b" would be meaningless here because 'a' and 'b' are values not types.
06:15:41 <Peaker> quicksilver: I just wrote "a b" to denote that C :: * -> * -> *
06:15:52 <mmorrow> Toxaris: oops, this doesn't change anything, but above i meant  "(1,1,1)*7=(7,7,7) where R ... on the *right*"
06:16:11 <quicksilver> Peaker: yes. But I'm saying you don't need show instances for "a" and "b"
06:16:14 <quicksilver> you won't use that.
06:16:30 <quicksilver> you're being very inconsistent in your terminology and that is, in my opinion, causing you unnecesary confusion.
06:16:47 <quicksilver> if you want to call your type "C a b" then let's agree to use x,y,z for values, or the other way around.
06:16:53 <Peaker> quicksilver: ok
06:17:00 <EvilTerran> greek letters for type variables! :P
06:17:05 <mmorrow> all the trouble with GADTs and deriving class instances for them stems from the fact that you can choose arbitrary types for the different constructors, regardless of what's actually in them
06:17:12 <quicksilver> x >>> y = Bind x y
06:17:24 <quicksilver> here "x" takes type "C a b"
06:17:30 <quicksilver> "y" takes type "C b d"
06:17:37 <quicksilver> and "Bind x y" has type "C a d"
06:17:47 <mmorrow> so the way that instance decs are set up doesn't lend itself well to GADTs
06:17:53 <quicksilver> if you want a show instance here
06:17:56 <quicksilver> then it's no problem at all
06:18:10 <Peaker> quicksilver: I finally see what you're saying. Sorry it took so long :)  I don't want a and b to be shown, true
06:18:19 <quicksilver> instance Show (C a b) where show (Bind x y) = "Bind " ++ show x ++ " " ++ show y
06:18:22 <quicksilver> roughly.
06:18:27 <quicksilver> no need for a Show a,b context
06:18:34 <quicksilver> and thus no problem writing the Bind instance :)
06:18:48 <EvilTerran> couldn't it try writing something like the usual derived instance, then see if it can infer a class context that'd make it typecheck?
06:19:00 <quicksilver> EvilTerran: yes, I think it could do that in most cases.
06:19:12 <quicksilver> EvilTerran: although I suspect that's not quite how it looks behind the scenes.
06:19:20 <EvilTerran> naturally, it'd barf on things like "data Foo where Bar :: a -> Foo"
06:19:31 <mmorrow> (oh yeah, i welcome feedback/pointing out of gross oversights on my part wrt the gadtshow.cgi :))
06:19:35 <quicksilver> it wouldn't barf.
06:19:36 <kiris> afternoon
06:19:39 <quicksilver> it would just flick up a Show a context
06:19:40 <quicksilver> surely?
06:19:47 <EvilTerran> altho it could work on things like "data Foo where Bar :: Show a => a -> Foo"
06:19:54 <quicksilver> no need.
06:20:13 <quicksilver> oh.
06:20:14 <quicksilver> sorry
06:20:16 <EvilTerran> quicksilver, the a is implicitly forall'd, though, so you can't constrain it in the instance head
06:20:18 <quicksilver> "a" not mentioned in type
06:20:22 <quicksilver> right, you win :)
06:20:25 <EvilTerran> :P
06:20:27 <quicksilver> I wasn't reading carefully.
06:20:35 <Peaker> Isn't (blah . id) === blah ?
06:20:48 <quicksilver> Peaker: yes, FSOV "==="
06:20:55 <EvilTerran> Peaker, perhaps the LHS has a more specific type, but otherwise yes
06:21:25 <EvilTerran> blah.id [= blah
06:21:40 <Peaker> I see, wondering why mmorrow's code generator uses dot-id
06:21:56 <EvilTerran> (that's "refines", like reverse.reverse [= id)
06:22:05 <EvilTerran> (except it refines by being a more general type instead of more defined)
06:22:26 <mmorrow> foldr [|(.)|] [|id|] [[|....|],[|....|]]
06:22:28 <EvilTerran> er, "is refined by", even
06:22:35 <mmorrow> template haskell is so cool
06:22:40 <quicksilver> EvilTerran: yes, so really it's a quite different refine :)
06:22:45 <EvilTerran> yeah...
06:22:50 <EvilTerran> it's still refinement
06:22:57 <quicksilver> EvilTerran: normally when we compare terms we imagine unifying their types first f all and then comparing at that fixed type
06:23:00 <EvilTerran> mmorrow, er, what does that do?
06:23:06 <quicksilver> of course the other thing is quite meaningful too.
06:23:44 <EvilTerran> i was just defining [= as "refines to" 'cos i've only seen it written that way in machine-readable CSP, and folks might not recognise it :)
06:23:45 <mmorrow> EvilTerran: that's how i made the function bodies here: http://morrow.jypsis.com/cgi-bin/gadtshow.cgi
06:23:46 <lambdabot> Title: GADT Show
06:24:58 <quicksilver> even ignoring the TH parts
06:25:07 <EvilTerran> mmorrow, how can you use [|(.)|] as the function in a foldr? its type's wrong
06:25:08 <quicksilver> I often thing foldr (.) id needs a name
06:25:35 <EvilTerran> wouldn't it be (\x y -> [|$x . $y|])?
06:26:01 <mmorrow> EvilTerran: heh, but not if everything's and ExpQ   (everything's eventually checked at compile time)
06:26:27 <EvilTerran> i don't follow
06:26:44 <mmorrow> oh, actually it should always work
06:26:52 <EvilTerran> [|(.)|] :: ExpQ, doesn't unify with (a -> b -> b)
06:27:11 <mmorrow> wait, i just confused myself, but i have a good explanation
06:27:16 <mmorrow> gimme a sec
06:27:20 <EvilTerran> ghci> :t foldr [|(.)|] [|id|]
06:27:29 <EvilTerran> Couldn't match expected type `a -> b -> b' against inferred type `Language.Haskell.TH.Lib.ExpQ'
06:27:46 <EvilTerran> or is this some weird overloaded foldr?
06:27:46 <mmorrow> well, obviously it works :)
06:27:48 <hpaste>  Toxaris pasted "operations" at http://hpaste.org/8706
06:28:15 <mmorrow> wait, i may not be remembering exactly the code, i'll get it and paste
06:28:41 <EvilTerran> i could imagine a foldrTH f = foldr (\x y -> [|$f $x $y|])
06:28:44 <Toxaris> mmorrow: some code exemplifzing my idea
06:29:15 <Toxaris> mmorrow: s/z/y
06:29:23 <EvilTerran> \f -> foldr (\x y -> [|$f $x $y|]) :: ExpQ -> ExpQ -> [ExpQ] -> ExpQ
06:29:49 <mmorrow> EvilTerran: all i remember is being amazed when it did work
06:29:58 <EvilTerran> ... naughty ghci, you need more parentheses than that!
06:33:43 <hpaste>  morrow pasted "gadt show derive fragment" at http://hpaste.org/8707
06:33:55 <peti> Hi. Can someone help me explain this phenomenon with GHC 6.8.2 on Windows? I run a GUI process using runInteractiveCommand, i.e. "notepad". Then I call "terminateProcess" for the process handle that was returned. It doesn't work, i.e. the notepad window is never closed and the notepad process still exists. Is that normal?
06:34:16 <quicksilver> it seems surprising.
06:34:22 <mmorrow> EvilTerran: that's equiv to the example we were talking about, i had to change it to have it print without A.B.C.show
06:34:31 <quicksilver> I note the docs for terminateProcess do say "This function should not be used under normal circumstances"
06:34:54 <EvilTerran> mmorrow, can't you write (appE (varE (mkName "showChar")) (litE . charL $ ' ')) as just [|showChar ' '|]?
06:35:23 <EvilTerran> no, wait, that's ::Q Exp, not Exp
06:35:52 <mmorrow> ExpQ
06:35:58 <mmorrow> == Q Exp
06:36:00 <peti> quicksilver: Well, I understand that Haskell cannot guarantee that process termination is clean. Not every OS has resource tracking, for example. Anyway, I'd assume that the process would be, like, gone. But it isn't.
06:36:03 <EvilTerran> might be worth lifting some of those out to the do block, tho, for clarity
06:36:08 <mmorrow> (a type syn)
06:36:09 <EvilTerran> just imo
06:36:24 <quicksilver> peti: well someone who uses windows woudl be able to help you better than I can.
06:36:36 <mmorrow> EvilTerran: heh, yeah i've gotta clean it up a bunch before i put it on hackage
06:36:48 <peti> quicksilver: Yeah, I've heard that a couple of times. It's just that no-one seems to use Windows. :-)
06:36:49 <mmorrow> EvilTerran: i was in hackmode12 when i wrote it
06:37:15 <mmorrow> EvilTerran: "get it working as fast as possible"
06:37:16 <EvilTerran> i try to work with [||]s and $(...)s as much as possible when i'm fiddling with TH
06:37:26 <EvilTerran> 'cos munging the syntax tree manually is horrific
06:37:32 <quicksilver> peti: there is a reason for that :)
06:37:36 <mmorrow> EvilTerran: i had it *so so* pretty with all the [|(.)|] etc
06:37:58 <mmorrow> but because i wanted to prettyprint it in such a way that the output is then valid haskell syntax
06:38:05 <mmorrow> i had to resort to ugly hackishness
06:38:07 <mmorrow> :(
06:38:31 <mmorrow> (otherwise you'd get    GHC.Show.showChar     GHC.Base.(.)
06:39:02 <mmorrow> and then those modules obviously aren't imported by the module one's pasting into, so...
06:39:43 <mmorrow> "output is then valid haskell syntax" i think also there was some situation where th printed a qualified varname where it's not legal to use one
06:40:57 * mmorrow tries to get to past darcs revisions
06:45:13 <BeelsebobWork> who runs the specific \bot in here btw?
06:45:22 <EvilTerran> lambdabot? i think that's Cale
06:45:48 <BeelsebobWork> Cale: would it be possible for her to /join #macosx too?
06:46:03 <mar77a> > length "coolrobotthingtodo"
06:46:05 <lambdabot>  18
06:47:26 <hpaste>  morrow annotated "gadt show derive fragment" with "the cleaner version" at http://hpaste.org/8707#a1
06:49:06 * Axman6 seconds BeelsebobWork's request to Cale 
06:50:15 <mauke> @join #macosx
06:54:59 <EvilTerran> mmorrow, flip mapM = forM
06:55:19 <mmorrow> EvilTerran: "mmorrow, can't you write (appE (varE (mkName "showChar")) (litE . charL $ ' ')) as just [|showChar ' '|]?"
06:55:29 <mmorrow> you were correct
06:55:43 <mmorrow> (but it suffers from GHC.Show.showChar)
06:56:52 <mmorrow> EvilTerran: heh, just noticed that and about 20 other things now that i'm looking that code over
06:57:42 <leoncamel> is there any online reference about haskell and its library ?
06:57:50 <quicksilver> leoncamel: yes, lts.
06:57:51 <quicksilver> lots.
06:58:00 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/
06:58:00 <lambdabot> Title: Haskell Hierarchical Libraries
06:58:03 <quicksilver> for the libraries
06:58:26 <dmwit> ?where report for the language spec
06:58:26 <lambdabot> http://www.haskell.org/onlinereport/
06:58:52 <EvilTerran> mmorrow, ... hey, the lowercase versions of the Exp constructors give back ExpQs as well
06:59:02 <mmorrow> yeah :)
06:59:08 <leoncamel> quicksilver: thanks. but is there any reference with examples ?
06:59:35 <mmorrow> EvilTerran: pprint them though, and you'll see the key difference
06:59:54 <dmwit> leoncamel: Which library in particular?
06:59:57 <mmorrow> EvilTerran: (well, key for my situation)
07:00:43 <EvilTerran> i mean, so you *can* just replace (appE (varE (mkName "showChar")) (litE . charL $ ' ')) with [|showChar ' '|]
07:00:50 <leoncamel> dmwit: Arrow fro now .
07:00:58 <leoncamel> s/fro/for
07:01:03 <EvilTerran> should be exactly equivalent
07:01:10 <hpaste>  morrow annotated "gadt show derive fragment" with "explanation for all the ugly" at http://hpaste.org/8707#a3
07:01:27 <mmorrow> http://hpaste.org/8707#a3
07:01:37 <dmwit> leoncamel: The person most active in that area that I know of is conal... if he's still playing with arrows.  Maybe take a look at his blog?
07:01:42 <EvilTerran> doh
07:01:42 <mmorrow> EvilTerran: until you prettyprint it they are
07:01:45 <EvilTerran> that sucks
07:01:51 <ejt> leoncamel: the library documentation pages often link to good papers that have examples
07:01:54 <mmorrow> yeah *totally*
07:02:31 <EvilTerran> wouldn't it be better, then, to get people to import the TH module and splice in the result?
07:02:39 <leoncamel> dmwit: where is conal's blog ?
07:02:47 <EvilTerran> rather than copypasting prettyprinted output
07:03:04 <mmorrow> EvilTerran: yeah, totally, *but* i gadts aren't supported by TH
07:03:06 <dmwit> ?go conal elliott blog
07:03:08 <lambdabot> http://conal-elliott.blogspot.com/
07:03:08 <lambdabot> Title: ConalBlog
07:03:21 <EvilTerran> mmorrow, so you can't use TH and GADTs in the same file? =/
07:03:43 <EvilTerran> mmorrow, btw, you can write that pattern as d@HsGDataDecl{} if you like
07:03:48 <leoncamel> thanks ..
07:03:54 <dmwit> leoncamel: See also conal.net/blog
07:03:59 <mmorrow> EvilTerran: ....so... i had to parse a module to haskell-src-exts AST, pick that module apart to get all all the GADT decls, then use TH to gen the instance dec for Show
07:04:04 <dmwit> leoncamel: A good keyword to start with is "functional reactive".
07:04:11 <EvilTerran> eugh
07:04:32 <EvilTerran> mmorrow, might it be easier to mung together source code as a string?
07:04:40 <EvilTerran> mmorrow, it wouldn't be as theoretically tidy, but it might be easier
07:05:22 <mmorrow> so to have a function that one imports into their module to do that, you'd have to have a TH function that gets the filepath of the caller's module via location :: Q Loc, then parses the module, extracts the gadts decls, and finally derives the instances
07:05:33 <EvilTerran> crikey
07:05:40 <mmorrow> i have all the pieces to do that, just have to assemble them :)
07:05:46 <mmorrow> crikey is right!
07:07:23 <mmorrow> i wonder what would happen if you called reify on a GADT
07:07:38 <mmorrow> (since they have no rep in the TH AST)
07:07:48 <EvilTerran> ?hoogle reify
07:07:48 <lambdabot> Language.Haskell.TH.reify :: Name -> Q Info
07:07:48 <lambdabot> Language.Haskell.TH.Syntax.reify :: Name -> Q Info
07:07:48 <lambdabot> Language.Haskell.TH.Syntax.qReify :: Quasi m => Name -> m Info
07:08:52 <EvilTerran> i'd think it could express the GADT constructors in terms of ForallC
07:09:00 <EvilTerran> but i doubt it does, you probably just get an error or something
07:09:53 <quicksilver> conal's TVs aren't actually arrows though :P
07:10:00 <quicksilver> I don't think there are many really good examples of arrows.
07:10:04 <quicksilver> HXT perhaps.
07:11:07 <hpaste>  morrow annotated "gadt show derive fragment" with "reify a gadt" at http://hpaste.org/8707#a4
07:11:36 <mmorrow> EvilTerran: whoa, so when you reify a GADT it shows up as a regular data declaration
07:11:45 <ejt> doesn't Hughes' paper have lots of examples of Arrows ?
07:11:54 <EvilTerran> mmorrow, i speculated as much
07:12:08 <EvilTerran> mmorrow, but what about if it wouldn't be expressible as a regular data decl without forall?
07:12:10 <mmorrow> EvilTerran: maybe that has everything i need, i never even tried that
07:12:41 <mmorrow> EvilTerran: i think you're right.
07:12:46 <vincenz> ndmitchell: ping
07:13:32 <ndmitchell> vincenz: pong
07:13:41 <vincenz> ndmitchell: you called?
07:13:49 <ndmitchell> vincenz: was just messaging about the ICFP team, i can't make it this year :(
07:14:01 <vincenz> oh yeah, but I thought you had told me before
07:14:11 <vincenz> shame ):
07:14:15 <ndmitchell> i had, but only via @tell, so was checking you got the message
07:14:29 <mmorrow> EvilTerran: oh. reifying GADTs that are *actually* using the added generality fails
07:14:32 <ndmitchell> yep, will have been internet-less for 3 ICFP contents in a row after this one
07:14:40 <vincenz> ouch, that sucks
07:14:59 <ndmitchell> i kind of suspect something to crop up, just to repeat history
07:15:04 <hpaste>  morrow annotated "gadt show derive fragment" with "but on a "real" GADT, failure" at http://hpaste.org/8707#a5
07:15:34 <EvilTerran> "Can't reify a non-Haskell-98 data constructor: `Bar'"
07:15:41 <EvilTerran> yeah =/
07:16:07 <mmorrow> EvilTerran: so jumping through hoops it is
07:16:10 <mmorrow> yay!
07:16:36 <EvilTerran> :(
07:17:12 <mmorrow> heh
07:17:29 <Saul__> Does anyone know where I can find some info on designing a simple database engine?
07:17:44 <EvilTerran> see, if we were using s-expressions instead of haskell syntax, i'm sure this'd be a lot easier
07:17:58 <EvilTerran> (and i'm not even a lisp weenie, i hate lisp)
07:18:29 <mmorrow> Saul__: how simple? sqlite's source is good for what it's worth
07:19:01 <Saul__> mmorrow: That will probably do well
07:19:08 <mmorrow> EvilTerran: yeah, but then we'd be wishing for the opposite most likely
07:19:12 <Saul__> mmorrow: thanks
07:19:23 <mmorrow> Saul__: no prob, good luck
07:20:02 <mmorrow> EvilTerran: the grass is always greener...
07:20:08 <Saul__> thanks
07:20:17 <mmorrow> you welcome
07:20:20 <mmorrow> your
07:20:22 <mmorrow> e
07:21:47 <dmwit> e
07:24:53 <hpaste>  morrow annotated "gadt show derive fragment" with "link to working" at http://hpaste.org/8707#a6
07:24:57 <chr1s> dcoutts_: ping
07:30:56 <Igloo> Is there some way I can write this (or something equivalent): http://hpaste.org/8709 (GADTs and FDs)
07:33:27 <mmorrow> Igloo: hmm, that's an interesting problem. i'm not sure
07:34:06 <Heffalump> no, because the compiler doesn't know that the two 'b's are equal
07:34:22 <Heffalump> I asked about a very similar problem several months ago, I think on ghc-users
07:34:25 <chr1s> I've got a package hsql-1.7 installed
07:34:38 <monochrom> <3 you
07:34:53 <chr1s> but when I try to install hsql-mysql, cabal seems to think I haven't got it installed
07:35:06 <Heffalump> If/when FDs are rewritten in terms of type equalities, then it'll be possible.
07:35:08 <chr1s> and it tries to download the broken version from hackage.
07:35:24 <Igloo> Heffalump: Did you find any workaround or anything?
07:35:30 <Heffalump> unsafeCoerce
07:35:33 <Heffalump> or type families
07:36:07 <mmorrow> well definitely unsafeCoerce
07:36:13 <Heffalump> I wrote a utility function with type (C a b1, C a b2) => b1 -> b2 and body unsafeCoerce
07:38:16 <Igloo> Neither of those help, because I was trying to disprove http://hackage.haskell.org/trac/ghc/ticket/2356#comment:3  :-)
07:38:23 <EvilTerran> yeah, the ~ thing in type families would do it
07:38:27 <Saizan> chr1s: is hsql installed as --user and you're trying to install hsql-mysql as --global?
07:38:52 <shepheb> Any GHC folk know where I went wrong in the build attempt documented at http://hackage.haskell.org/trac/ghc/wiki/ArmLinuxGhc ? (the problem is near the bottom of the upper section, right above "Original Page")
07:38:54 <lambdabot> Title: ArmLinuxGhc - GHC - Trac
07:39:36 <chr1s> Saizan: no, both as --user
07:39:53 <Igloo> shepheb: If you're trying to port 6.8 then it won't work
07:40:10 <shepheb> Igloo: 6.9.20080614
07:40:15 <Igloo> That won't work yet either
07:40:22 <shepheb> oh?
07:40:29 <chr1s> Saizan: it just tries to recompile it everytime I install hsql-mysql
07:40:37 <Igloo> We need to update the scripts, and haven't got there yet
07:40:39 <Heffalump> even if your example worked, how would it disprove chak's comment?
07:41:11 <Heffalump> anywhere you could use your function, both instances would have to be in scope for there to be a problem
07:41:24 <shepheb> Igloo: nuts. so only platforms with an existing older GHC can have a newer GHC right now?
07:41:28 <Igloo> Heffalump: Both instances can be in scope, that's what the ticket is about
07:41:37 <Igloo> shepheb: Right
07:41:42 <Heffalump> but they can't be used
07:42:28 <Igloo> Heffalump: Yes they can, as Main does in that ticket
07:42:44 <SamB_XP> huh, so you need to port TWO versions atm?
07:43:05 <Igloo> Heffalump: You replace one of the B's with a function to make an X, and the other one with a function that unpacks it
07:43:09 <Heffalump> oh, right.
07:43:30 <Heffalump> doesn't this mean that type instance families are broken?
07:43:49 <Igloo> SPJ says "For indexed-type instances, overlap is unsound, so there's an eager check."
07:44:05 <Igloo> Or are TIFs something else?
07:44:06 <Heffalump> so he does
07:44:11 <Heffalump> no, you're right
07:45:25 <mmorrow> wow, i see that as a feature, i'm gonna go write all the Monoid instances i've always wanted without newtypes!
07:45:33 <SamB> for a minute there, I misread instances as images and was about to say "don't you mean TIFF?"
07:45:43 <SamB> mmorrow: hah
07:45:49 <mmorrow> heh
07:45:50 <SamB> mmorrow: save it for Coq ;-P
07:46:03 <SamB> where you can actually do that in a meaningful way
07:46:15 <mmorrow> i've gotta learn Coq
07:46:43 <dmwit> Why couldn't they pick a better name?
07:46:44 <mmorrow> Igloo: what is an instance of this where it is (clearly?) unsound?
07:46:53 <SamB> dmwit: it means Cock, i.e. Rooster
07:46:59 <dmwit> I know it's a bit juvenile, but I can't help mentally snickering every time I read it.
07:47:02 <dmwit> SamB: I know.
07:47:11 <Heffalump> mmorrow: may you burn in hell :-)
07:47:18 <SamB> you know -- the farmer's alarm clock?
07:47:23 <mmorrow> Heffalump: i like the beach!
07:47:30 <shepheb> Igloo: I found #1346 about the problem. if it really isn't going to be fixed until 6.10.1, is porting a 6.6, and then using it to build a 6.8 (or 6.9) practical?
07:47:35 <dmwit> SamB: My complaint stands.
07:48:12 <SamB> don't tell me even "the farmer's alarm clock" sounds like "penis" to you!
07:48:16 <Heffalump> Igloo: could editline get installed on the machine that builds the GHC snapshots?
07:49:13 <dmwit> SamB: Of course not.  But nobody writes "The Farmer's Alarm Cloq", they write "Coq."
07:49:15 <monochrom> farmer's alarm coq
07:49:20 <mmorrow> Igloo: ah, upon actually rtfcomments my question is (mostly) answered
07:49:50 <SamB> dmwit: but Coq doesn't really look like Cock
07:49:58 <SamB> it just sounds similar
07:50:12 <dmwit> It sounds as similar to "cock" as it does to "cock". ;-)
07:50:30 <monochrom> coq doesn't look like clock either
07:50:46 <SamB> monochrom: true, but I wasn't suggesting that it did
07:50:53 <dmwit> (And I read "by sound", so to speak; I'm constantly saying the words silently.  I realize not everybody reads this way.)
07:50:56 <smtms> coq is the french word for cock
07:51:01 <saml> i read Coq "kwoughque"
07:51:02 <smtms> for meanings of cock, check the dictionary
07:51:12 <SamB> smtms: you are *NOT* helping
07:51:15 <Igloo> shepheb: fixing that is separate from an actual release; 6.10.1 just means "soon", really
07:51:27 <Igloo> Heffalump: Which platform?
07:51:45 <Heffalump> linux-i386
07:52:10 <Peaker> dmwit: I think our brains are kind hard-wired to process either "visual" or "audio" data. Some people remember the same information much better if they see it, others if they hear it
07:52:14 <SamB> my sister has a cool job right now
07:52:15 <Heffalump> at least that's what I would like, but in general any platform where line-editing is broken now
07:52:16 <EvilTerran> I pronounce "coq" "cee-oh-queue"
07:52:23 <monochrom> Caq is a theorem prover for OO people. It sounds like a duck.
07:52:30 <dmwit> EvilTerran: That is a great idea.
07:52:33 <SamB> they pay her to ... get this ... play with dogs
07:52:54 <Peaker> my sister makes cake sculptures
07:53:00 <QtPlatypus> SamB: Kinky.
07:53:01 <EvilTerran> SamB, that's funny, *my* sister's looking into dogsitting as well
07:53:21 <Peaker> cute: http://thecake.co.il/templates/sharon_templates/gallery_frame.html
07:53:23 <lambdabot> Title: אשת הסוכר - עוגה לכל חלום, סד אות לעיצוב עוגו ..., http://tinyurl.com/6f7x6x
07:53:25 <Igloo> Heffalump: OK, I've forwarded the request to SM
07:53:28 <Peaker> (all edible)
07:53:29 <SamB> she's working in the PetSmart Pet Hotel
07:53:31 <EvilTerran> lambdabot, er, pardon?
07:53:34 <Heffalump> ta
07:53:37 <smtms> dmwit, it's time a coq equivalent with a better name got written in Haskell
07:53:44 <EvilTerran> ah, hebrew
07:53:49 <EvilTerran> smtms, how about Agda?
07:53:51 <SamB> Peaker: something is VERY VERY WRONG
07:54:08 <SamB> smtms: why should it be?
07:54:10 <Peaker> SamB: that we speak Hebrew here in Israel? :)
07:54:11 * ndmitchell prefers the ESC/Haskell approach to the Agda/Coq one
07:54:33 <mapreduce> smtms: Just pronounce it Coke and you'll be fine.
07:54:45 <SamB> Peaker: probably the way lambdabot handles non-ASCII in TITLE elements
07:54:46 <Saizan> ESC?
07:54:54 <smtms> mapreduce, I have no problem with the meaning or the pronunciation. you are mistaken
07:55:06 <ndmitchell> Saizan, Google it, or Sound Haskell (it got renamed half way through)
07:55:07 <Peaker> SamB: I didn't even notice, yeah its probably reading the wrong encoding
07:55:12 <ndmitchell> @google ESC Haskell Dana Xu
07:55:13 <lambdabot> http://www.cl.cam.ac.uk/~nx200/research/escH-hw.ps
07:55:31 <shepheb> Igloo: is that "quick hack" diff a workable interim solution?
07:55:47 <monochrom> Cow is farmer's G-machine
07:55:47 <Igloo> shepheb: I don't know
07:56:55 <Heffalump> ndmitchell: is ESC/Haskell likely to appear in a usable form?
07:57:31 <Heffalump> it's nice in one way, but a clear specification of what is and isn't "acceptable" is also nice
07:58:12 <ndmitchell> Heffalump: i hope so, but doubt it :(
07:58:26 <ndmitchell> or at least have yet to see any evidence of an "end-product"
07:58:53 <ndmitchell> I'm half hoping Catch can get tweaked and move up to do what ESC/Haskell wants to
07:59:53 <EvilTerran> ndmitchell, you mean you want to tweak catch to detect potential non-termination as well or something?
08:00:20 <ndmitchell> EvilTerran: ESC/Haskell doesn't do that, and non-termination is a fairly solved issue, and secondary to correctness
08:00:37 <EvilTerran> ah, ok. i'll have to have a look at esc/haskell to know what you mean, i gues, then
08:00:42 <ndmitchell> EvilTerran: i mean allow Catch to verify arbitrary predicates, using induction where necesssary
08:00:51 <EvilTerran> ahh, i see
08:00:53 <ndmitchell> think of ESC/Haskell as quickcheck proofs
08:01:10 <mapreduce> @go esc/haskell
08:01:11 <lambdabot> http://www.cl.cam.ac.uk/~nx200/research/escH-hw.ps
08:01:11 <EvilTerran> that'd be rather good
08:01:15 * Heffalump is still waiting for a generally usable Catch, let alone a souped-up one :-)
08:01:38 <ndmitchell> Heffalump: the lacking bit isn't Catch, its the fact that Yhc has "issues" with "compiling things"
08:01:47 <Heffalump> I know.
08:02:08 <ndmitchell> it works perfectly on the intersection of Haskell98 and uses libraries Yhc works with (i.e. HsColour)
08:02:24 <Heffalump> But which tool is to blame is of no real importance :-)
08:02:33 <ndmitchell> there is a Hugs front-end to Catch in the works, which will be the answer
08:02:34 <ndmitchell> i know :)
08:02:56 <ndmitchell> i have it on my list to flesh out the entire tool chain to production quality
08:02:56 <Heffalump> how much work would it be to make it work with anything GHC can compile?
08:03:13 <ndmitchell> trivial, just convert GHC Core -> Yhc.Core (2 seconds work, and already done)
08:03:20 <Heffalump> why not do that, then?
08:03:26 <ndmitchell> its untyped, so all of GHC's extensions are no issue
08:03:36 <ndmitchell> because GHC Core isn't something that really exists
08:03:41 <ndmitchell> certainly not for a whole program
08:03:41 <mmorrow> ndmitchell: do you mean "quickcheck proofs" in a loose sense, or an actual sense? ie does ETC/Haskell seek to randomly test a given module/whatever a (large) number of times, or to verify it (according to whatever) 100% or not at all?
08:03:49 <Heffalump> so is it trivial or not? :-)
08:03:52 <ndmitchell> mmorrow: verify
08:04:04 <mmorrow> ndmitchell: interesting
08:04:19 <ndmitchell> Heffalump: trivial after you have a working and supported GHC Core, otherwise non-trivial
08:05:04 <Heffalump> fair enough
08:05:09 <Heffalump> I had the impression we were inching towards that.
08:05:21 <Heffalump> (I take it you mean External Core)
08:05:25 <ndmitchell> we are, but think baby steps papered with plenty of hacks
08:05:48 <ndmitchell> i need Core for all the libraries and the program, internal Core never has all the info available
08:06:08 <ndmitchell> but if it did - say by putting --inline-everything in the interface files, then that would be doable
08:06:28 <nominolo> @seen dons
08:06:28 <lambdabot> I haven't seen dons.
08:06:30 <ndmitchell> however, one of my extensions to Catch will require less information from libraries, so that may reduce the pain a bit
08:07:02 * zachk finds Coq mildly amusing as well
08:07:20 <zachk> oops <apologizes>
08:08:29 <mmorrow> ndmitchell: what is the reason that catch chooses to operate on the output of ghc rather than on the source program before it goes in to ghc? (i'm not familiar with catch other than it's description, so perhaps this is obvious)
08:08:42 <shepheb> Igloo: thanks for the explanation. I'll keep an eye on #1346 then.
08:09:08 <ndmitchell> mmorrow: the Core language has 5 different constructs in Catch, the Haskell source language has 100's - its for simplicity
08:09:43 <ndmitchell> mmorrow: i would end up reimplementing the front-end of GHC, which would be very hard
08:09:44 <mmorrow> ndmitchell: fair enough and very true
08:10:05 <SamB> ndmitchell: so do you do it with or without the optimizer on?
08:10:13 <mmorrow> ndmitchell: well, wouldn't you only have to "catch" things which ghc won't later in the compilation?
08:10:31 <SamB> mmorrow: just traversing is a PITA
08:10:36 <SamB> and parsing
08:10:46 <SamB> and resolving typeclasses...
08:10:57 <mmorrow> ndmitchell: haskell-src-exts handles 99% of all haskell syntax
08:10:58 <ndmitchell> SamB: without
08:11:04 <mmorrow> that was @ SamB
08:11:08 <SamB> ndmitchell: I thought probably
08:11:12 <ndmitchell> mmorrow: but you still have to type check the program
08:11:15 <SamB> mmorrow: but only the syntax
08:11:34 <ndmitchell> SamB, after the program is longer and the error messages to the user will be worse
08:11:41 <SamB> you really do need to typecheck before you can say what instance is used where
08:11:54 <mmorrow> ndmitchell: hmm, i had in mind that catch caught things like (head []) and such, and relied on ghc/insert compiler to typecheck
08:12:01 <SamB> ndmitchell: plus what if GHC is buggy ;-P
08:12:12 <SamB> mmorrow: it does ;-)
08:12:28 <SamB> but it also needs instances resolved, does it not?
08:12:37 <ndmitchell> mmorrow: yes, but you have to type check to know which == function you are calling etc
08:12:48 <mmorrow> ndmitchell: ah, true
08:13:42 <mmorrow> ndmitchell: that is truly the hurdle insurmountable without reimplem the typechecker
08:16:39 <SamB> mmorrow: and truly, it would be a PITA to traverse all of the complicated Haskell syntax constructs even if haskell-src-exts offered typechecking
08:17:33 <monochrom> O MacDonald had a farm, E I E I O. The Coq goes "coq coq coq", and coqs out algebraic types. The Caq goes "caq caq caq", and caqs out co-algebraic types. ...
08:18:11 <mapreduce> What a load of caq.
08:19:03 <SamB> huh, I don't get djinn as hit 4 today :-( it's now hit 7
08:20:08 <SamB> does a co-algebraic type differ from a co-inductive type?
08:20:17 <monochrom> No.
08:20:30 <SamB> so ... is there REALLY a caq?
08:20:34 <SamB> and where is it if so?
08:20:40 <mauke> one contains "coal", the other "coin"
08:21:01 <SamB> mauke: wrong level!
08:21:07 <monochrom> No, but it would be a good name for a theorem prover geared towards OO programming.
08:21:33 <SamB> that would explain why I haven't seen any journal articles about it yet ;-)
08:21:34 <monochrom> "Coq is farmer's clock. Caq is farmer's duck."
08:22:12 <SamB> (I'd been looking for papers with anything useful about coinduction)
08:22:59 <mmorrow> SamB: what is a PITA, other than a delicious breadlike food?
08:23:13 <mmorrow> hheh
08:23:16 <mmorrow> i just realized
08:23:23 <Gilly> *g*
08:23:27 <SamB> PITA is pain in the ass
08:23:30 <mmorrow> yeah
08:23:33 <SamB> pita is delicous breadlike food
08:23:54 <SamB> which is best stuffed with cheese or tuna salad
08:24:08 <monochrom> programming insanely tedious assembler is a PITA
08:24:17 <mmorrow> it wouldn't be a pita relative the the pita you'd already have wrapped yourself in by setting out to catch various errors
08:24:31 <mmorrow> in fact, that parsing/traversal would prob be the *easy* part
08:24:40 <SamB> the boring part
08:24:41 <Peaker> Saizan: http://hpaste.org/8710 -- I think this tackles the reverse-dependencies of computations in arrows
08:24:52 <SamB> which would tend to be a maintenance nightmare
08:24:55 <mmorrow> SamB: yes, boring is true
08:25:01 <Peaker> Saizan: You can ask what outputs of an arrow will be affected when an input changes. You have to identify which sub-part of the input changes
08:25:14 <Peaker> Saizan: and it tells you which sub-part of the output changes
08:25:23 <mmorrow> SamB: perhaps
08:25:41 <SamB> because it would always be changing in ways mostly irrelevant to the goal
08:25:46 <Peaker> Saizan: Parallel represents (***) and Bind represents (>>>)
08:25:58 * Peaker has to go
08:26:20 <mmorrow> SamB: but if you properly abstracted the AST's rep from how you operate on it, the important part of the code would always be fine and dandy
08:26:34 <mmorrow> i meant that vice-versa
08:27:01 <mmorrow> ...abstracted the interface through which you operate on an/the AST...
08:27:10 <SamB> well, using GHC output instead of Haskell does that nicely
08:27:17 <mmorrow> yes it does
08:27:35 <mmorrow> unfortunately it's for all intensive purposes nonexistent :(
08:27:45 <SamB> hmm?
08:27:49 <mmorrow> external core
08:28:02 <mmorrow> someone's actually making it usable though
08:28:43 <mmorrow> http://darcs.haskell.org/ghc/utils/ext-core/Language/Core/Core.hs
08:29:01 <mmorrow> it looks to be coming along nicely actually!
08:29:10 <mmorrow> http://darcs.haskell.org/ghc/utils/ext-core/
08:29:11 <lambdabot> Title: Index of /ghc/utils/ext-core
08:29:16 <mmorrow> it's even caballed
08:30:01 <mmorrow> unfortunately the happy parser in there is for the old version of ext-core
08:31:06 <BSP_> quick question: is there anything like a monadic functor in the standard libraries? with a method like "fmapM :: Monad m => (a -> m b) -> f a -> m (f b)"
08:31:45 <Baughn> Functor f, Monad m?
08:31:47 <SamB> hmm...
08:32:22 <BSP_> Baughn: well, something like FunctorM f, but yes
08:32:38 <quicksilver> :t Data.Traversable.sequence
08:32:40 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
08:32:58 <Baughn> BSP_: Monad is already a subclass of Functor. I'm not sure exactly what a FunctorM would be, so..
08:33:00 <quicksilver> Data.Traversable is, in a sense, the new name for FunctrM
08:33:08 <Baughn> Or, okay, it /should/ be
08:33:36 <BSP_> Baughn: i think you've missed the point. the functor and monad do not have to be for the same datatype
08:33:40 <Peaker> Saizan: did you take a look?
08:33:44 <BSP_> quicksilver: cheers, i'll take a look
08:33:57 <quicksilver> you need a fmap on top to get what you wanted.
08:34:04 <Saizan> Peaker: yes, the input describes what has changed?
08:34:29 <Saul__> Does anyone have a tutorial on how the sqlite backend works?
08:34:43 <mmorrow> SamB: ooh wow, he's even got a typechecker in there http://darcs.haskell.org/ghc/utils/ext-core/Language/Core/Check.hs
08:34:44 <lambdabot> http://tinyurl.com/645cx7
08:34:48 <quicksilver> :t \z y -> Data.Traversable.sequence (fmap z y)
08:34:49 <Peaker> Saizan: yeah. If the whole input changes, the "path" is []. If the first changed, its [TupleFirst]. If c changed in ((a,b),(c,d)), its [TupleSecond,TupleFirst]
08:34:49 <lambdabot> forall a (m :: * -> *) a1 (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m a1) -> t a -> m (t a1)
08:35:00 <quicksilver> BSP_: that's what you asked for, I think.
08:35:15 <Peaker> Saizan: as arrows use recursive tuple composition for inputs/outputs and separating the effects on them
08:35:17 <Saul__> so I don't mean how to use sqlite, but how it works under the hood with serializing, file management and looking up and updating data
08:35:19 <quicksilver> you can weaken the Monad to Applicative if you prefer.
08:35:29 * mmorrow put ext-core on his list of things to get to know
08:35:37 <SamB> mmorrow: it isn't THAT hard to typecheck IRs -- especially if they aren't dependantly typed ;-)
08:35:49 <BSP_> quicksilver: that's it exactly, thanks. do you know happen to know which GHC versions have Data.Traversable available?
08:36:10 <BSP_> quicksilver: like, was it present in 6.2?
08:36:13 <mmorrow> SamB: not that it's hard or easy, just that it exists, it's clean/new code, and i get to read it
08:36:18 <mmorrow> yay
08:36:18 <SamB> BSP_: huh?
08:36:27 <SamB> BSP_: there was a GHC 6.2?
08:36:37 <SamB> oh, I guess 6.2.2 was one ;-)
08:37:04 <quicksilver> BSP_: no, but I think it was called FunctorM back then
08:37:05 <BSP_> SamB: well, yeah. i think we release on every even minor version
08:37:07 <quicksilver> BSP_: or something :)
08:37:16 <BSP_> quicksilver: right, I can't use it then. damn. thanks anyway!
08:37:35 <quicksilver> well you can just import the stuff wholesale :)
08:37:41 <quicksilver> Traversable is a very small piece of code.
08:37:43 <SamB> BSP_: my point is that that was a long time ago
08:38:16 <BSP_> SamB: i want to use it in GHC itself, and we have certain requirements about supporting old GHCs for bootstrapping purposes
08:38:36 <Saizan> Peaker: shouldn't effect (First x) (TupleFirst:rest) = TupleFirst: effect x rest, ?
08:38:46 <BSP_> SamB: I think ATM we require GHC to be buildable with 6.2 or 6.4, can't remember whic
08:39:15 <Peaker> Saizan: yeap, my bad
08:39:16 <quicksilver> 6.2 currently but it rises to 6.4 for the 6.10 branch
08:39:23 <Peaker> Saizan: Do you think this kind of scheme works, though?
08:39:24 <SamB> BSP_: OH
08:39:31 <SamB> that does make a difference, yes ;-)
08:40:15 <SamB> however there is nothing to prevent using the same ideas in GHC itself with a different module name ...
08:40:44 <SamB> well, possibly coding style guidelines
08:40:58 <SamB> but those are made for man, man isn't made for those
08:42:41 <Peaker> Saizan: seems to work well now
08:42:57 <BSP_> SamB: it's true i could just copy and paste but I actually only want it in one place so I'll do the grungy thing for now until we can bootstrap from a more civilized compiler :)
08:42:59 <Peaker> Saizan: probably need to generalize support for Loop, maybe even ArrowApply?
08:43:08 <ski> @type Data.Traversable.traverseM
08:43:09 <lambdabot> Not in scope: `Data.Traversable.traverseM'
08:43:12 <ski> @type Data.Traversable.traverse
08:43:14 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
08:43:24 * Peaker is gone! please @tell me things
08:43:45 <ski> @type Data.Traversable.mapM
08:43:45 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m b) -> t a -> m (t b)
08:43:51 <ski> that's the one
08:43:51 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
08:44:02 <ski> @messages
08:44:02 <lambdabot> Kamina said 2m 2d 3h 55m 45s ago: I don't agree: Having something of type Maybe (exists a. a) would be useful, you can typecast it to anything, because it can be every type. (Like you can convert
08:44:02 <lambdabot> read "5" to every type being of the "Read" class)
08:44:13 <ski> erf ?
08:44:41 <ski> (i distinctly recall i already have been given this message .. maybe one need to clear them somehow ?)
08:45:22 <SamB> ski: maybe lambdabot needs to do journaling
08:45:28 <SamB> contributions welcome
08:45:39 <ski> BSP_ : anyway, i think that could be the one you were looking for
08:46:00 <BSP_> ski: yeah, that looks like just the thing. thanks!
08:46:39 <EvilTerran> ski, @clear-messages?
08:47:24 <EvilTerran> that doesn't sound accurate, anyway... he seems to be thinking of Maybe (forall a. a)
08:47:32 <ski> @messages?
08:47:32 <lambdabot> Sorry, no messages today.
08:47:47 <ski> EvilTerran : neither works for what he wanted ..
08:48:16 <EvilTerran> indeed. Maybe (forall a. a) is Maybe (_|_), isn't it?
08:48:36 <ski> if by `_|_' you mean the least type, yes
08:49:25 <EvilTerran> yeah, the empty type
08:51:20 <mmorrow> the "1" of integers (up to (*-1))
08:52:24 <mmorrow> err, the equiv of 1 `elem` integers
08:52:36 <EvilTerran> what?
08:53:08 <mmorrow> do    `type isA` --> *
08:53:18 <mmorrow> er, ignore that
08:53:21 <EvilTerran> what?
08:53:27 <mmorrow> gcd
08:53:37 <mmorrow> the greatest lower bound
08:53:41 <ski> what is `*-1' ?
08:53:44 <EvilTerran> glb, you mean?
08:53:48 <EvilTerran> not gcd :P
08:53:56 <mmorrow> yes, _|_ is that
08:54:34 <mmorrow> completely mathematically analogous to 1 in the integers with (*)
08:55:02 <ski> ideal theory ?
08:55:06 <mmorrow> well, with rigor, the prim
08:55:08 <mmorrow> yes!
08:55:30 <mmorrow> Spec(Z)
08:55:58 <ski> `Spec' meaning ?
08:56:05 <mmorrow> the prime spectrum of Z
08:56:13 <mmorrow> so, the collection of prime ideals
08:56:32 <ski> ok
08:57:10 <mmorrow> this is the generalization of the zeros of polynomials over an algebraically closed field (an algebraic variety)
08:57:37 <ski> `this' being ?
08:57:39 <mmorrow> so you can do algebraic geometry over Z
08:57:47 <ski> `algebraically closed' being ?
08:58:01 <ski> (sorry .. i don't really know much about ideal theory)
08:58:06 <mmorrow> oh, sorrt
08:58:08 <mmorrow> sorry
08:59:12 <mmorrow> interesting stuff
08:59:38 <ski> mmorrow : if you feel like explaining a little, i'd gladly listen awhile
09:00:03 <mmorrow> i was just getting a link
09:00:07 <mmorrow> http://hpaste.org/6515
09:00:44 <mmorrow> what this is really doing mapping (lcm,gcd) -> (union,intersect) of prime ideals of Z
09:00:55 <mmorrow> ...doing is...
09:01:06 <mmorrow> well, that's wrong
09:01:32 <mmorrow> it's taking the product and sum of prime ideals of Z
09:02:08 <visq> @seen yav
09:02:08 <lambdabot> I haven't seen yav.
09:02:43 <mmorrow> then you can map them via a contravariant functor to a space that's the analog of the geometric space of solution sets polynomials over the complex numbers
09:03:40 <whurlpuddle> hmmmmm
09:04:03 <dmwit> Wait, there's no isLeft/isRight function?
09:04:07 <dmwit> ?hoogle Either a b -> Bool
09:04:07 <lambdabot> No matches, try a more general search
09:04:11 <dmwit> =/
09:04:14 <mmorrow> under this functor (there's actually an adjunction) the prod and sum of prime ideals corresponds to the union and intersection of these "geometric" objects
09:04:28 <dmwit> isLeft = either (const False) (const True) -- how to get something like this into the libraries?
09:05:21 <dmwit> :t join either id
09:05:22 <lambdabot> forall c. Either c c -> c
09:05:33 <ski> istr seeing something like that being discussed on mailing list
09:05:59 <mmorrow> mmorrow: "these geometric objects" being known at various levels of generality as algebraic varieties ... schemes
09:06:37 <mmorrow> ski: ?
09:06:57 <ski> ski : well what do these geometric objects look like ?
09:07:08 <quicksilver> dmwit: make a library proposal. In practice I never seem to need it though.
09:07:34 <dmwit> I need it right now. =)
09:08:07 <roconnor> dmwit: you must be doing something wrong :P
09:08:12 <dmwit> heh
09:08:25 <roconnor> pattern match FTW!
09:08:26 <ski> ski : my very rough (and possibly wrong) feeling for ideals is that they are some kind of "predicates" over the ring .. is this in any way sensible ?
09:08:30 <mmorrow> they're the generalization of solution sets (zeros) of polynomials over an algebraically closed field (eg Complex nums)
09:08:37 <dmwit> roconnor: Well, what do people normally do if they want to check whether something parses without using the (parsed) result?
09:08:57 <mmorrow> so, over the complex nums, these varieties/schemes would be pretty curves or some such
09:08:58 <dmwit> I'm using isRight . runParser, but would be happy to use something better if it exists...
09:09:13 <roconnor> dmwit: bind?
09:09:25 <dmwit> That leaves me with another Either, when I really want a Bool.
09:10:02 <roconnor> ah
09:10:03 <roconnor> >>
09:10:14 <mmorrow> but wrt the "curves" in Spec(Z) i'm not sure have a canonical visualization
09:10:21 <ski> mmorrow : algebraically closed means that given polynomials with coeff. taken from the field, then an `n'th degree polynomial have `n' solutions ??
09:10:31 <mmorrow> ski: yes
09:10:56 <roconnor> > Left "error" >> "It succeeded!"
09:11:08 <mmorrow> but Z isn't even a field, let alone algebraically closed, so a different method is needed
09:11:11 <lambdabot>  thread killed
09:11:14 * ski kicks lambdabot
09:11:22 <dmwit> roconnor: ...that doesn't type-check.
09:11:42 <ski> mmorrow : method for what ?
09:11:47 <dmwit> :t (>>)
09:11:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:11:49 <mmorrow> with algebraically closed fields, the maximal ideals correspond to "points"
09:11:52 <roconnor> > (Left "error" :: Either String ()) >> "It succeeded!"
09:11:53 <lambdabot>  Couldn't match expected type `Either String b'
09:12:00 <dmwit> (>>) :: Either e a -> Either e b -> Either e b
09:12:11 <dmwit> "It succeeded!" :/: Either e b
09:12:15 <roconnor> oh oops
09:12:21 <mmorrow> but in order to recover this notion with Z, you have to restrict yourself to the prime ideals
09:12:28 <roconnor> > Left "error" >> return "It succeeded!"
09:12:30 <ski> mmorrow : was my "predicate" idea in any sense right ?
09:12:36 <mmorrow> prime ideal => maximal ideal
09:12:43 <lambdabot>  thread killed
09:12:44 <dmwit> roconnor: That *still* leaves me with an Either, not a Bool. ;-)
09:13:00 <mmorrow> ski: oh oops, i missed it
09:13:24 <roconnor> dmwit: what do you want to do if it succeeds, what do you want to do if it fails?
09:13:28 <mmorrow> so consider C[x] , which is polynomials over the complex numers in one variable
09:14:17 <ski> e.g. `{5 * n | n : Z}' could be thought of as `m |-> exists n : Z. m = 5 * n'
09:14:47 <mmorrow> hmm, thinking...
09:15:00 <dmwit> roconnor: It is the first stage in a sanity check; if any part of the sanity check fails, I want the program to die a flaming death.
09:15:13 <mmorrow> ski: i'm not sure, but think of this
09:15:39 <Saizan> @tell Peaker how do you express that only 'a' and 'c' changed in ((a,b),(c,d))? also from the output you can't see if the arrow needs to be rerun or not
09:15:39 <lambdabot> Consider it noted.
09:15:41 <dmwit> roconnor: ...so I'm imagining a function shouldIDieAFlamingDeath :: Bool
09:16:03 <mmorrow> maximal ideals in C[x] are *exactly* subrings of C[x] generated by polynomials of the form (x - c), for c in C
09:16:25 <ski> (dmwit : .. that's a `Bool' not a function ..)
09:16:32 <dmwit> ...quite
09:16:36 <mmorrow> the zeros of such polynomials are exactly single points
09:16:41 <dmwit> shouldIDieAFlamingDeath :: [Module] -> Bool
09:17:07 <dmwit> Ideally, shouldIDieAFlamingDeath would in fact be a compile-time check... but I don't quite feel up to that. =P
09:17:13 <mmorrow> now, moving to the integers, "points" now become prime ideals
09:18:00 <roconnor> how about shouldIDieAFlamingDeath :: Monad m => [Modules] -> m ()
09:18:22 <roconnor> in the case m = Maybe, then Maybe () is isomorphic to Bool
09:18:45 <ski> mmorrow : hm, definition of `prime' in this context ?
09:18:55 <roconnor> but with this version, you get to leave a message about why you should die a flaming death
09:19:01 <mmorrow> ski: it's kinda weird to think about and i'm surely making small but significant errors in some of my statements
09:19:07 <mmorrow> ski: oh, excellent point
09:19:49 <blakkino> FastCGI.hsc:59:21:  error: fcgiapp.h: No such file or directory <- any idea?
09:20:04 <blakkino> (while installing FastCGI last version from darcs)
09:20:19 <dmwit> roconnor: Well, I'll consider floating the Either higher and higher in my function call stack.
09:20:25 <dmwit> roconnor: But I need to consume it eventually.
09:20:35 <EvilTerran> blakkino, have you installed fastCGI?
09:21:01 <EvilTerran> (not the haskell module, what you'd use if you were using it in, say, C)
09:21:01 <blakkino> EvilTerran, no, i'm trying to install it. The error come from ./Setup.hs build of FastCGI itself
09:21:02 <mmorrow> ski: for an ideal I, if for ideals J and K, I = J*K, then J or K = 1
09:21:07 <ski> MonadException m E => [Modules] -> m ()
09:21:10 <blakkino> aaah :D
09:21:11 <blakkino> correct
09:21:14 <blakkino> shame on me :)
09:21:19 <EvilTerran> seeing as it seems to be looking for a C header
09:21:34 <mmorrow> ski: so, essentially a straighforward generalization from single elements of the integers
09:21:40 <ski> mmorrow : so `irreducible' really, then ?
09:21:41 <blakkino> yes, it is obvious
09:21:48 <mmorrow> ski: there's a distinction
09:22:13 <roconnor> dmwit: you can consume it in main, when you write either (throw . userError) print
09:22:23 <mmorrow> ski: before i go any further i'd want to look up the exact defs to make sure i'm being correct
09:22:48 <mmorrow> it's been a little while
09:22:55 <ski> mmorrow : yes .. but iirc, `irreducibility' is the one with no nontrivial decomposition, while `primality' is the one with primes dividing at least one factor
09:23:43 <ski> s/primes //
09:23:48 <roconnor> dmwit: or you can just print it in main, and have m instantiated with IO
09:24:39 <mmorrow> ski: yeah, i think i flipped them, but it's not clear to me because there are many equiv defs
09:25:04 <ski> ok
09:25:49 <mmorrow> ski: http://en.wikipedia.org/wiki/List_of_commutative_algebra_topics
09:25:49 <lambdabot> Title: List of commutative algebra topics - Wikipedia, the free encyclopedia
09:25:55 <mmorrow> ski: http://en.wikipedia.org/wiki/Algebraic_geometry
09:25:55 <lambdabot> Title: Algebraic geometry - Wikipedia, the free encyclopedia
09:26:16 <mmorrow> ski: ah, here we are http://en.wikipedia.org/wiki/Prime_ideal
09:26:17 <lambdabot> Title: Prime ideal - Wikipedia, the free encyclopedia
09:26:40 <mmorrow> oh that page is perfect for what we were discussing
09:26:56 <Lemmih> Igloo: ping.
09:26:56 <ski> mmorrow : hm, that first page seems to be about rings ..
09:27:20 <ski> shouldn't it be called something like `List_of_commutative_ring_topics' ?
09:27:43 <mmorrow> ski: commutative algebra (about commutative rings) is the basis for everything we're discussing
09:27:58 <mmorrow> there is an adjunction between the algebra and the geometry
09:28:39 <mmorrow> Ideals <-> "sets of zeros of them thought of as polynomial rings"/Varieties/Schemes
09:28:41 <ski> (or i suppose this is another of those braindead misnomers when people think `algebra' means "the special kind of algebra we're considering here" ..)
09:29:52 <SamB> ski: what did you think commutative algebra meant?
09:30:11 <masak> I must be a bit tired, I can't see why the compiler rejects http://paste2.org/p/45013 -- could someone have a look at it and give me a push in the right direction?
09:30:37 <quicksilver> masak: x appears twice in line 13
09:30:44 <mmorrow> ski: check out the section "Affine varieties" here: http://en.wikipedia.org/wiki/Algebraic_geometry
09:30:45 <lambdabot> Title: Algebraic geometry - Wikipedia, the free encyclopedia
09:30:47 <ski> SamB : any algebraic structure at all, which some binary operation (at least) that happens to be commutative .. e.g. `commutative magmas' would be included
09:30:51 <masak> yes -- I thought I could do that
09:30:56 <quicksilver> masak: is your intention to require the same value in both places?
09:31:01 <masak> yes it is
09:31:08 <benny99> helper (x:xs) x
09:31:11 <quicksilver> (x:xs) y zs | x == y
09:31:14 <quicksilver> is the way to do that
09:31:16 <mmorrow> the V(-) they refer to is the functor from Algebra -> Geometry
09:31:17 <ski> s/which/with/
09:31:20 <benny99> msakthere
09:31:21 <masak> quicksilver: thank you
09:31:22 <quicksilver> (x:xs) y zs | x == y  = "SX"
09:31:25 <therp> before I start looking at these wiki pages, is there any personal recommendation for category theory books/tutorials/introductions/textbooks? The title "Basic Category Theory for Computer Scientists" sound appealing
09:31:33 <masak> ah, using guards for that. I see
09:31:40 <benny99> yep
09:31:53 <ski> (and `abelian groups' of course)
09:32:15 <therp> oh basic category theory for c.s. is from B.J. pierce
09:32:24 <therp> that's certainly a plus
09:32:41 <mmorrow> a commutative ring's addition is not only commutative, but its multiplication as well
09:33:02 <ski> (anyway, i suppose this is a pet peave of mine .. so let's drop it for now)
09:33:10 <ski> yes
09:33:26 <monochrom> I recommend both that and Fokkinga's calculational approach: http://wwwhome.cs.utwente.nl/~fokkinga/#detail_0000003536
09:33:27 <lambdabot> Title: Maarten Fokkinga's Home Page
09:33:29 <ski> (s/peave/peeve/)
09:34:13 <dmwit> "No instance for Monad (Either ParseError)" =/
09:34:28 <dmwit> isRight would have been a lot easier, if not quite as principled. =P
09:34:46 <mmorrow> ski: phew, i've gotta run, but we should talk about this again. now i'm motivated to brush up having realized how many particulars i've forgotten :)
09:35:08 <therp> monochrom: was that a suggestions for me?
09:35:13 <monochrom> Yes! :)
09:35:16 <ski> mmorrow : ok
09:35:21 <therp> monochrom: thanks :)
09:37:01 <augustss> yo!
09:37:20 <TomMD> yo
09:37:27 <Heffalump> yo!
09:37:39 <ski> ?oy
09:37:39 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn yow
09:37:49 <TomMD> ?yow
09:37:50 <lambdabot> Couldn't find fortune file
09:38:56 <therp> hmm.. why hasn't my local university a lecture on category theory?
09:38:59 <roconnor> dmwit: I guess you are going to need an (either show id) adaptor
09:39:34 <dmwit> yep =/
09:40:14 <roconnor> ParseError isn't an instance of Error, I guess because every ParseError is supposed to have a SourcePos.
09:40:36 <monochrom> very few schools have category theory, therp.
09:41:19 <ski> (imnsho `MonadError' should be scrapped or changed)
09:42:13 <roconnor> @instances Monad
09:42:14 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:42:20 <dmwit> :t runParser
09:42:21 <lambdabot> Not in scope: `runParser'
09:42:30 <dmwit> :t Text.ParserCombinators.Parsec.runParser
09:42:31 <lambdabot> forall tok st a. Text.Parsec.String.GenParser tok st a -> st -> Text.Parsec.Pos.SourceName -> [tok] -> Either Text.Parsec.Error.ParseError a
09:43:51 <therp> monochrom: but seems to be something that ever interesting papers references... I really feel like I have to cover that gap of knowledge
09:44:09 <ski> (er .. no, i misremembered .. it was only `Error', specifically the `Error e => MonadError e (Either e)' instance that was bad ..)
09:45:08 * edwardk finally got around to adding another recursion scheme to the field guide. anyone feel like checking it over before it makes it to planet haskell?
09:45:27 <roconnor> edwardk: I will
09:45:49 <monochrom> It seems that everyone learns category theory by self-studying. Except for those who use it for algebraic topology or homology or something, since category theory originated from there and is an integral part.
09:45:54 <edwardk> ski: yes Either should be a monad unconstrained by Error. Its that pesky MonadFail instance
09:46:17 <edwardk> er rather that pesky lack of a MonadFail class :)
09:46:33 <SamB> therp: just be glad they don't have a BAD lecture on category theory
09:46:37 <roconnor> edwardk: what do I do?
09:46:49 <dmwit> roconnor: Actually, either show id --> left show
09:46:54 <quicksilver> the good treatments of CT I know are very dry.
09:47:02 <edwardk> roconnor: its at http://comonad.com/reader/ lemme know if there is anything obviously wrong I guess ;)
09:47:03 <quicksilver> I've never seen one that contained what I would call "motivation"
09:47:04 <roconnor> dmwit: oh, I didn't know that
09:47:10 <SamB> that is VERY sad
09:47:13 <roconnor> @type left
09:47:14 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
09:47:17 <lambdabot> Title: The Comonad.Reader
09:47:17 <SamB> :-(
09:47:26 <roconnor> oh, they are arrow things
09:47:36 <noecksit_> is there something like readChar? something that takes Char as first argument rather than String?
09:47:51 <SamB> roconnor: not mere arrow things
09:47:56 <SamB> they also work on functions
09:47:58 <dmwit> roconnor: I mean, "either show id" and "left show" have different types... and "left show" is the right one here. =)
09:48:11 <edwardk> i think i'll do apomorphism next so i can finish out a pair of dual morphisms, then do generalized anamorphisms so i can bring in monads
09:48:13 <SamB> dmwit: oh?
09:48:21 <dmwit> left f = either (Left . f) Right
09:48:27 <dmwit> (for the (->) Arrow)
09:48:32 <roconnor> oh yes
09:48:34 <ski> @type [either show id,left show]
09:48:35 <lambdabot>     Couldn't match expected type `String'
09:48:35 <lambdabot>            against inferred type `Either String String'
09:48:35 <lambdabot>       Expected type: Either a String -> String
09:48:49 <dmwit> :t (either show id, left show)
09:48:50 <lambdabot> forall a a1 d. (Show a1, Show a) => (Either a String -> String, Either a1 d -> Either String d)
09:49:33 <noecksit_> @type read
09:49:34 <lambdabot> forall a. (Read a) => String -> a
09:49:35 <quicksilver> yes, either is a projection
09:49:39 <dmwit> What module do I have to import to get instance Monad (Either e)?
09:49:46 <quicksilver> dmwit: Cntrol.Monad.Error
09:49:54 <ski> dmwit : for what `e' ?
09:49:54 <quicksilver> although you won't get it
09:49:56 <dmwit> Why isn't it in Control.Monad.Instances??
09:50:02 <quicksilver> you'll get Error e => Monad (Either e)
09:50:15 <dmwit> quicksilver: Yeah, I was just abbreviating.
09:50:16 <edwardk> dmwit: use category-extras and import Control.Monad.Either
09:50:32 <edwardk> dmwit: that gives a real instance for (Either e) with no error cruft if its what you want
09:50:41 <dmwit> Oh?
09:50:45 <dmwit> What does fail do?
09:50:52 <edwardk> fail fails with an error
09:51:02 <dmwit> Sounds nice. =)
09:51:24 <dmwit> ?hackage category-extras
09:51:24 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
09:51:40 <edwardk> Either a is a monad in the category theoretic sense. I needed it so i could make apomorphisms work in terms of generalized anamorphisms (which expect a monad)
09:51:43 <roconnor> edwardk: looks fine
09:51:44 <dmwit> As a side note: I now have more lines of imports than I do of code. =/
09:51:52 <edwardk> dmwit: heh
09:51:55 <roconnor> edwardk: your catamorphism link in http://comonad.com/reader/2008/paramorphism/ is broken
09:51:58 <lambdabot> Title: The Comonad.Reader  Paramorphism
09:52:01 <edwardk> ack fixing
09:52:31 <edwardk> fixed
09:52:58 <noecksit_> so is there a way I could do that or would i first need to convert Char to String before I can read it?
09:53:14 <dmwit> noecksit_: Do what?
09:53:16 <roconnor> edwardk: your comment for the type of para should be a GAlgebra
09:53:22 <noecksit_> is there something like readChar? something that takes Char as first argument rather than String?
09:53:35 <dmwit> noecksit_: ...with what return type?
09:53:54 <noecksit_> dmwit: with return type of int
09:53:55 <edwardk> good catch
09:53:56 <edwardk> fixed
09:54:02 <dmwit> noecksit_: digitToInt
09:54:17 <dmwit> noecksit_: (Or "ord", if that's what you want.)
09:54:27 <noecksit_> such as ((\a-> read a :: Int) <$> (Just '3'))
09:54:40 <dmwit> > digitToInt <$> Just '3'
09:54:41 <noecksit_> > ((\a-> read a :: Int) <$> (Just '3'))
09:54:43 <lambdabot>  Just 3
09:54:43 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
09:54:51 <noecksit_> > ((\a-> read a :: Int) <$> (Just "3"))
09:54:51 <SamB> edwardk: is it just me or is Control.Monad.Categorical severely underdocumented?
09:54:52 <lambdabot>  Just 3
09:55:07 <edwardk> samb: mostly because i haven't been willing to bring myself to use it =(
09:55:14 <roconnor> @type readChar
09:55:15 <lambdabot> Not in scope: `readChar'
09:55:21 <edwardk> samb: i'd have to give up support for the standard prelude almost entirely
09:55:25 <SamB> edwardk: you should at least put SOMETHING in there
09:55:31 <edwardk> samb: heh fair nuff
09:55:32 <dmwit> :t read . return -- if you *really* don't like digitToInt for some reason
09:55:33 <lambdabot> forall a. (Read a) => Char -> a
09:55:39 <SamB> like what you would do if you weren't afraid to use it
09:56:03 <SamB> how am I supposed to steal your ideas if you don't document them, after all?
09:56:10 <edwardk> =)
09:56:30 <edwardk> if it was hard to write it should be ... er ok, well those were fairly simple to write... so i guess they should be simple to read...
09:56:36 <noecksit_> dmwit : oh ok thanx
09:57:06 <dmwit> edwardk: Whoa, 100 modules!
09:57:13 <edwardk> dmwit: heh
09:57:24 <edwardk> dmwit: its a little large for a single instance i'll admit ;)
09:58:42 <SamB> hmm, IxMonad...
09:58:56 <dmwit> edwardk: It would be cool if the Control.Monad.* modules you give re-exported Control.Monad... just for consistency with the "base" package.
09:59:00 <edwardk> samb: there are indexed parameterized and higher-order in there.
09:59:12 <SamB> again, a severe lack of comments
09:59:31 <edwardk> dmwit: the problem there is i was thinking about switching them over to Control.Monad.Categorical which would break that.
09:59:40 <dmwit> ah
09:59:40 <edwardk> samb: i'll accept patches ;)
09:59:52 <ski> hm, `Histo' is course-of-values ?
10:00:17 <edwardk> ski: yeah histo is course of value, futu is cocourse of argument or whatever you want to call it ;)
10:01:07 <dmwit> edwardk: Splendid, this saves a bit of ugliness. Thanks!
10:01:23 <SamB> edwardk: you need to make it easier to find the repository from comonad.com
10:01:29 <edwardk> dmwit: glad i could help. anything i can do to actually promote the use of this stuff in real code
10:01:43 <edwardk> samb: heh well, there is a link in just about every post on the topic ;)
10:01:56 <SamB> edwardk: I was looking for one in the sidebar
10:02:18 <edwardk> samb: yeah one of these days i need to spend some time cleaning up the layout of the menus on the top, etc.
10:04:13 <edwardk> I also probably need to eliminate the tag cloud since it only indexes into my (very) old wiki content
10:08:39 <byorgey> dmwit: whatcha writing?
10:08:57 <dmwit> Yet Another IRC Bot
10:09:03 <byorgey> ah, cool
10:09:22 <dmwit> I want to play with the idea of an un-quinable bot.
10:09:38 <byorgey> oh, ok, so this is just to play around, not as the Next Lambdabot
10:10:08 <dmwit> Maybe both. ;-)
10:10:16 <byorgey> heh, fair enough =)
10:10:18 <monochrom> As the Next 700 Lambdabots.
10:10:26 <dmwit> I figure it's a race between me and about 450 other people in here.
10:10:33 <dmwit> Whoever writes fastest wins.
10:10:42 <dmwit> Some people have a head start...
10:13:43 <byorgey> dmwit: 449, I'm not writing a lambdabot clone =)
10:14:11 <dmwit> Oh no, I'm not *that* gullible.  I'm not writing you off just yet. ;-)
10:14:57 <mauke> unquinable?
10:15:13 <dmwit> No matter how many copies are in the room, it will never get into an infinite loop.
10:15:27 <mauke> preflex does that
10:15:46 <edwardk> dmwit: now for your next trick make sure that no two of them will respond to the same message ;)
10:16:02 <dmwit> mauke: Yep, but I'd like it to be a bit more flexible.
10:16:18 <mauke> just use NOTICEs for replies
10:16:19 <dmwit> mauke: For example, I don't require a "nick: " prefix on the input or a " " prefix on the output.
10:16:24 <dmwit> mauke: Nobody likes that.
10:16:24 <mauke> as god intended
10:16:29 <mauke> I do!
10:16:32 <dmwit> So do I.
10:16:37 <SamB> clients don't
10:16:41 <dmwit> When I said "nobody", I meant "somebody".
10:16:56 <dmwit> (I've been told that \bot used to use NOTICE, and got lots of complaints.)
10:17:11 <SamB> for a fairly short period of time
10:17:19 <SamB> it was HORRIBLE
10:17:26 <dmwit> mauke: See? ;-)
10:17:40 <SamB> apparantly, nobody implements notice the way you wish they did
10:17:42 <mauke> s/HORRIBLE/AWESOME/
10:17:49 <roconnor> lambdabot'
10:17:56 <SamB> (where by nobody, I too mean somebody)
10:18:13 <dmwit> ?hoogle (a -> b -> m c) -> [a] -> [b] -> m [c]
10:18:14 <lambdabot> No matches, try a more general search
10:18:18 <SamB> anyway, there's no challange in using NOTICE to make an unquinable bot ;-)
10:19:02 <dons> cool stuff, http://www.reddit.com/info/6qah5/comments/
10:19:03 <lambdabot> Title: reddit.com: Lost and found: tracing a Haskell puzzle
10:19:10 <mauke> dmwit: tag all bot output with 4 trailing spaces
10:19:24 <SamB> that's sorta like saying you're going to avoid the possibility of quines being written in a programming language by saying that all source files in that language will begin with "SOURCE "
10:19:29 <dmwit> mauke: -- HACK
10:19:39 <SamB> and all output from programs in that language will begin with "DATA "
10:19:48 <mauke> AWESOME HACK
10:19:50 <dmwit> mauke: I *already* have a solution.  I'm implementing it now. =)
10:20:04 <dmwit> mauke: If you have a different solution, great!  I'll race you to a working bot. =)
10:20:07 <SamB> you know what I mean?
10:20:17 <mauke> what's your solution?
10:21:16 <dmwit> Associate each command with two regexes telling what input it accepts and output it creates.
10:21:46 <dmwit> Form a graph of commands, with an edge a -> b when the output of a intersects with the input of b.
10:21:53 <mauke> omgwtf
10:21:55 <dmwit> If there are cycles in the graph, don't start. =)
10:22:29 <shepheb> can I use GHC 6.8.2 to compile 6.6.1, or should I install 6.6.1 too?
10:23:44 <dmwit> Since regular languages are closed under intersection, and it's easy to test a regular language for emptiness, all the algorithmic stuff is pretty straightforward.
10:24:02 <shepheb> or, to rephrase the question, what version of GHC, with what extra libraries, should I use to compile 6.6.1?
10:24:05 <mauke> what's the regex for @quote?
10:24:24 <dmwit> in: "(?|@)quote .*" out: ".*"
10:24:36 <mauke> yeah, that intersects
10:24:41 <dmwit> Right.
10:24:47 <dmwit> So you have to narrow it down.
10:24:53 <mauke> how do you make a non-intersecting @quote?
10:24:57 <dmwit> But you get *automatically told* which things intersect.
10:25:07 <dmwit> out: "[a-z].*"
10:25:16 <dmwit> (For example.)
10:25:31 <dmwit> Or, as you do with preflex, you could do out: " .*".
10:25:48 <dmwit> (Note that all these regexes have an implicit starting '^' and ending '$'.)
10:26:06 <mauke> I noticed
10:26:16 <mauke> also, ? is not a metacharacter :-)
10:26:39 <dmwit> I know.
10:27:09 <dmwit> Actually, in the source I have rxPrefix = "[?@]" instead.
10:27:19 <dmwit> So meta-ness of '?' is not an issue.
10:27:25 <shepheb> what version of GHC, with what extra libraries, should I use to compile 6.6.1?
10:33:18 <FordCortina> @help slap
10:33:18 <lambdabot> slap <nick>. Slap someone amusingly.
10:33:36 <FordCortina> @karama
10:33:37 <lambdabot> You have a karma of 0
10:33:42 <FordCortina> @karma
10:33:43 <lambdabot> You have a karma of 0
10:34:06 <FordCortina> @help fresh
10:34:07 <lambdabot> fresh provides: freshname
10:34:11 <FordCortina> @help freshname
10:34:11 <lambdabot> freshname. Return a unique Haskell project name.
10:34:19 <FordCortina> @freshname
10:34:19 <lambdabot> Hal
10:34:22 <FordCortina> @freshname
10:34:22 <lambdabot> Ham
10:34:25 <FordCortina> @freshname
10:34:25 <lambdabot> Han
10:34:27 <FordCortina> @freshname
10:34:27 <lambdabot> Hao
10:34:29 <FordCortina> @freshname
10:34:29 <lambdabot> Hap
10:34:31 <FordCortina> @freshname
10:34:32 <lambdabot> Haq
10:34:39 <FordCortina> @freshname
10:34:40 <lambdabot> Har
10:34:43 <FordCortina> @freshname
10:34:44 <lambdabot> Has
10:34:53 <dmwit> Please.
10:34:54 <FordCortina> @freshname Foo
10:34:55 <lambdabot> Hat
10:35:52 <FordCortina> oop
10:35:55 <FordCortina> oops
10:36:08 <FordCortina> sry ah i though that was private chat
10:36:14 <FordCortina> god i feel stupid
10:36:16 <Heffalump> whose silly idea was that command? :-)
10:36:42 <dmwit> One of the *guy's.
10:36:44 <SamB> it's kinda broken
10:36:58 <SamB> Hat does not look fresh to me ;-)
10:37:05 <idnar> heh
10:37:06 <FordCortina> yes i thought so too
10:37:25 <idnar> you're using up all the project names!@$
10:37:47 <FordCortina> zomg! now i feel even worse :$ :P
10:38:14 <FordCortina> @slap FordCortina
10:38:14 * lambdabot smashes a lamp on FordCortina's head
10:38:44 <slarba> why not Mondeo?
10:39:00 <mauke> preflex: version
10:39:00 <preflex>  0.108
10:39:22 <mauke> preflex: version
10:39:22 <preflex>  1.778
10:39:38 <dmwit> slarba: Uh, what?
10:41:43 <slarba> dmwit: heh, never mind. just playing with FordCortina's nick
10:44:24 <FordCortina> hmm Mondeo doesnt sound like someone's name ;)
10:45:42 <Frederick> folks which is the best book/resource to learn haskell now a days/
10:46:41 <FordCortina> I like "The Haskell School of Expression" by P Hudak
10:47:26 <lament> Frederick: Real World Haskell and YAHT.
10:47:49 <Baughn> Frederick: Gentle introduction to haskell, the spec and references
10:48:13 <Baughn> Also FordPrefect's bok
10:48:45 <lament> just keep in mind "Gentle" stands for "You might live through this"
10:49:28 <FordCortina> hah
10:49:35 <Baughn> At first you will think the name is a cruel joke, that's true
10:49:48 <Baughn> But once you /understand/ haskell, you realize that the book is very gentle and, in fact, too slow.
10:50:13 <lament> yes, the book only makes sense once you already know Haskell :)
10:50:29 <newsham> 6th ed, 7th ed and plan9?
10:50:33 <byorgey> Frederick: the wikibook is also very good.
10:50:55 <newsham> err.blah, caught in a scrollback warp
10:51:02 <byorgey> Frederick: the meta-point here is that there is no One True Resource for Learning Haskell
10:51:16 <lament> but do look at real world haskell :)
10:51:18 <newsham> byorgey: sure there is, she's called lambdabot
10:51:23 <Baughn> Frederick: Except #haskell
10:51:32 <lament> :t map
10:51:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:51:35 <byorgey> ah, good point.
10:51:37 <lament> newsham: oh? :)
10:51:46 <Baughn> lament: That is not the true map
10:51:56 <lament> the map which can be mapped is not the true map
10:51:57 <dmwit> Haskell is pretty concise.
10:51:58 <lament> :t map map
10:51:59 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
10:52:00 <Frederick> point is ive taken a formal semantics class thissemester so I want to follow the idea and learna functional language
10:52:04 <mauke> :t P.map
10:52:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:52:14 <byorgey> Frederick: well, you've come to the right place! =)
10:52:24 <mauke> Frederick: what programming languages do you know?
10:52:32 <lament> Frederick: approaching from a more theoretical perspective, gentle intro is probably the best
10:52:58 <newsham> if you see the monad on the road, kill the monad.
10:53:01 <newsham> for it is not the true monad
10:53:03 <Frederick> C and Java
10:53:04 * lament looks at the signature of map map until his brain explodes
10:53:16 <mauke> good
10:53:52 <byorgey> @type map map map
10:53:53 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:53:59 <mattam> :t map map map map
10:53:59 <Frederick> and some c++ but no onereally programs in c++ i just know a bit of a subset of the language I use
10:54:00 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
10:54:03 <Baughn> > map [5] (map map [const 4])
10:54:04 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
10:54:49 <Baughn> @type map map [const 4]
10:54:50 <lambdabot> forall a b (f :: * -> *). (Num b, Functor f) => [f a -> f b]
10:55:05 <lament> some people program in C++, pray that you never meet them
10:55:25 <Giblaz> hey
10:55:31 <newsham> > map map [(+1), (+2), (+3)] <$> [Just 10]
10:55:32 <lambdabot>  Couldn't match expected type `a -> a1 -> b'
10:55:35 <Baughn> > map map [const 4] ($2)
10:55:36 <lambdabot>  Couldn't match expected type `((a -> b) -> b) -> t'
10:55:41 <newsham> > map map [(+1), (+2), (+3)] <*> [Just 10]
10:55:42 <mattam> :t ([5] .)
10:55:44 <lambdabot>  [Just 11,Just 12,Just 13]
10:55:44 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
10:55:44 <lambdabot>     In the first argument of `(.)', namely `[5]'
10:55:50 <Baughn> > map map [const 4] (map ($2))
10:55:52 <lambdabot>  Couldn't match expected type `(f (a -> b) -> f b) -> t'
10:55:54 <Giblaz> hey
10:56:13 <Giblaz> i'm trying to pick up haskell and i was told this is a good place to go...
10:56:19 <byorgey> hey Giblaz
10:56:21 <byorgey> it is indeed!
10:56:25 <mattam> :t (flip apply [5])
10:56:25 <Giblaz> hi byorgey
10:56:26 <lambdabot> Not in scope: `apply'
10:56:39 <Giblaz> unfortunately, i don't have a *nix box handy
10:56:43 <Baughn> Giblaz: Don't worry, it doesn't normally look like this
10:56:45 <Giblaz> and i was trying out hugs
10:56:50 <Giblaz> hehehe no, haskell isn't that scary
10:56:55 <Baughn> GHC works perfectly on windows, thoguh. -_-
10:56:59 <Giblaz> its a different paradigm, i want to get good at it
10:57:00 <Giblaz> oh?
10:57:02 <mattam> :t (<$> [5])
10:57:03 <lambdabot> forall a b. (Num a) => (a -> b) -> [b]
10:57:13 <Deewiant> > map ($ Just 2) $ map map [const 4]
10:57:14 <lambdabot>  [Just 4]
10:57:17 <Giblaz> what does HuGs use as its compiler, i'm guessing it doesn't use GHC
10:57:26 <Baughn> Hugs is an interpreter
10:57:31 <mattam> :t <$>
10:57:32 <lambdabot> parse error on input `<$>'
10:57:34 <Giblaz> yeah
10:57:37 <mattam> :t (<$>)
10:57:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:57:41 <Giblaz> wow my mind slipped there for a second XD
10:57:48 <Giblaz> i knew that too >_>
10:57:50 <Baughn> Giblaz: http://haskell.org/ghc/dist/6.8.3/ghc-6.8.3-i386-windows.exe <-- Here, have ghc
10:58:00 <Giblaz> rawr!
10:58:02 <Giblaz> thanks dood
10:58:14 <Giblaz> i'm actually getting into haskell because erlang pisses me off O_O
10:58:30 <newsham> > map map [(+1), (+2), (+3)] <*> [Just 10, Just 50]
10:58:32 <lambdabot>  [Just 11,Just 51,Just 12,Just 52,Just 13,Just 53]
10:58:35 <Baughn> Erlang's one big idea isn't as powerful as haskell's one big idea, I guess
10:58:46 <Giblaz> haskells syntax doesn't look like garbage to me, and plus i have read that it does multi-core stuff great, which is why i got into erlang
10:59:06 <Giblaz> yeah you're probably right
10:59:10 <Baughn> Erlang does multi-computer great. It isn't optimized for SMP
10:59:14 <Baughn> GHC, otoh, is
10:59:17 <Frederick> I thinkI willprint YAHT
10:59:23 <newsham> it does multi-core stuff great?
10:59:23 <Giblaz> yeah, Erlang is *slightly* faster in multicore stuff
10:59:39 <Giblaz> yeah excuse my english right now, i just woke up
10:59:49 <Giblaz> i haven't had any coffee yet
10:59:54 <Giblaz> :)
10:59:58 <EvilTerran> c|_|
11:01:11 <Giblaz> so whats this lambdabot do
11:01:30 <newsham> lots of things
11:01:30 <Giblaz> > 2 + 2
11:01:33 <lambdabot>  4
11:01:37 <Giblaz> oh sweet
11:01:38 <Baughn> @hoogle a -> b
11:01:40 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
11:01:40 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
11:01:40 <lambdabot> Control.Arrow.Transformer.lift :: ArrowTransformer f a => a b c -> f a b c
11:01:50 <Giblaz> its a fancy interpreter it looks like
11:01:57 <dmwit> Not very fancy.
11:02:02 <Giblaz> heh
11:02:04 <Baughn> Compiler, actually. It feeds it through ghc
11:02:07 <dmwit> The interpreter is just GHC in the background.
11:02:13 <newsham> > foldr (+) z [a,b,c]
11:02:15 <Giblaz> oh nice
11:02:15 <lambdabot>  a + (b + (c + z))
11:02:22 <dmwit> But it does a lot of things other than code-compilation, that's what's neat about it.
11:02:29 <newsham> ?tell giblaz something
11:02:29 <lambdabot> Consider it noted.
11:02:40 <Frederick> folks thanks for now I will reada bit of the tuto and pop if I have some doubts
11:02:40 <Giblaz> :)
11:02:41 <lambdabot> Giblaz: You have 1 new message. '/msg lambdabot @messages' to read it.
11:03:04 <Baughn> Giblaz: Mostly, it's used to crash code.haskell.org
11:03:22 <Giblaz> ah
11:03:25 <newsham> hash code.haskell.org crashed because of lbot?
11:03:30 <Baughn> > let x = [1..] in last x -- Don't try this at home
11:03:34 <lambdabot>  Tried to use too much memory
11:03:50 <Baughn> ..that's not supposed to happen
11:03:56 <ski> > last [0..]
11:04:00 <lambdabot>  Tried to use too much memory
11:04:21 * ski wonders why that isn't iterative ..
11:04:26 <Baughn> ski: Bug.
11:04:33 <Giblaz> hehe lazy evaluation is cool
11:04:35 <Baughn> *Normally* that would be a constant-space infinite loop
11:04:42 <Baughn> But not in LB, apparently
11:05:04 <Deewiant> or is LB just misreporting it
11:05:19 <Baughn> I wrote that code, though. It isn't. -_-
11:05:20 <EvilTerran> > last (repeat 1)
11:05:26 <ski> possibly somehow the list gets kept around until `last' returns ?
11:05:33 <lambdabot> Terminated
11:05:35 <ski> Deewiant : could be
11:05:42 <EvilTerran> i'd've expected that to've <<loop>>ed
11:05:47 <FordCortina> Baugh: i tried running that on my machine. my memory usage certainly shot up
11:05:50 <ski> > fix id
11:05:51 <EvilTerran> > let loop = loop in loop
11:05:58 <idnar> looooooooooop
11:05:59 <FordCortina> Baughn:
11:06:01 <EvilTerran> let's stop stressing the poor girl...
11:06:05 <lambdabot>  thread killed
11:06:06 <lambdabot>  thread killed
11:06:11 <Baughn> EvilTerran: Eh, it should be fine now
11:06:13 <newsham> its building a list of [0, succ 0, succ $ succ 0, ....]
11:06:13 <ski> EvilTerran :)
11:06:19 <newsham> and then you're asking fo rthe last one
11:06:30 <EvilTerran> newsham, isn't it just that it's building 0, succ 0, succ (succ 0), ...?
11:06:32 <ski> > [0..]
11:06:33 <Deewiant> > last (repeat 1)
11:06:34 <Baughn> ..doh!
11:06:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:06:37 <EvilTerran> it won't be keeping the head of the list around
11:06:37 <ski> > iterate succ 0
11:06:38 <Baughn> newsham: Right you are
11:06:42 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:06:48 <lambdabot>  thread killed
11:06:54 <Baughn> Well, there was some other bug where it was promoting things to CAFs that shouldn't be
11:06:55 <EvilTerran> @let last' [x] = x; last' (x:xs) = x `seq` last' xs
11:06:59 <ski> > iterate succ x
11:07:00 <lambdabot> Defined.
11:07:02 <lambdabot>  [x,succ x,succ (succ x),succ (succ (succ x)),succ (succ (succ (succ x))),suc...
11:07:02 <idnar> > last [0,0..]
11:07:02 <EvilTerran> > last' [1..]
11:07:08 <newsham> evilterrain: perhaps.
11:07:08 <lambdabot>  Tried to use too much memory
11:07:09 <lambdabot>  Tried to use too much memory
11:07:09 <idnar> heh
11:07:18 <EvilTerran> oh, apparently not
11:07:22 <idnar> > [0,0..]
11:07:24 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
11:07:28 <idnar> hmm
11:07:32 <idnar> why is that different to repeat 0?
11:07:44 <idnar> I guess it's doing 0 + 0 + 0 + ... or something?
11:07:46 <EvilTerran> because it creates a new list cell for every item in the list
11:07:51 <newsham> because its  [0, 0+0, 0+0+0, ... ]  ?
11:07:53 <Baughn> idnar: repeat 0 explicitly creates a circular list
11:08:02 <Baughn> [0,0..] /could/, but doesn't
11:08:05 <EvilTerran> > [x,y..]
11:08:05 <idnar> okay, right
11:08:06 <lambdabot>  [Exception: not a number
11:08:10 <EvilTerran> poo
11:08:15 <idnar> heh
11:09:18 <newsham> > [x,(x+1)..]
11:09:20 <lambdabot>  [Exception: not a number
11:09:36 <Baughn> @type x
11:09:37 <lambdabot> Expr
11:10:11 <newsham> > enumFromThen x (x+1)
11:10:13 <lambdabot>  [Exception: not a number
11:10:37 <newsham> > iter succ x
11:10:38 <lambdabot>   Not in scope: `iter'
11:10:56 <newsham> > iterate succ x
11:11:00 <lambdabot>  [x,succ x,succ (succ x),succ (succ (succ x)),succ (succ (succ (succ x))),suc...
11:11:12 <Baughn> > toEnum x
11:11:13 <lambdabot>  Couldn't match expected type `Int' against inferred type `Expr'
11:11:19 <Baughn> > fromEnum x
11:11:21 <lambdabot>  Exception: not a number
11:11:35 <monochrom> > (x+1 :: Expr) == x+1
11:11:37 <lambdabot>  True
11:12:01 <Baughn> @src Enum
11:12:01 <lambdabot> class  Enum a   where
11:12:01 <lambdabot>     succ                     :: a -> a
11:12:01 <lambdabot>     pred                     :: a -> a
11:12:01 <lambdabot>     toEnum                   :: Int -> a
11:12:01 <lambdabot>     fromEnum                 :: a -> Int
11:12:03 <lambdabot> [3 @more lines]
11:12:19 <Baughn> So, instance Enum Expr where ... fronEnum = error "not a number!"
11:25:45 <vixey> what's it called if forall x, ~x R x ?
11:26:01 <vixey> oh it actually IS called irreflexivity.
11:26:27 * shapr feel his irreflexes kicking in...
11:29:45 <idnar> > [x..]
11:29:47 <lambdabot>  [Exception: not a number
11:29:50 <idnar> meh
11:29:54 <mauke> @babel de en irre
11:29:55 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
11:30:12 <mauke> :-(
11:33:57 <dmwit> > map var ['x'..]
11:34:00 <EvilTerran> http://dict.leo.org/ende?search=irre
11:34:00 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
11:34:01 <lambdabot> Title: LEO Ergebnisse fr "irre"
11:34:05 <asdftimo> hey guys, i have  this list [ z | x<-[1..], y<-[1..] , let z = (5^x)*(7^y)+1, isprime z], and im running it to find primes of the form shown (obviously). the only problem is the way haskell is running the search. it is doing one X and then
11:34:05 <asdftimo> all Y's, ie it is checking x=1 against y=[1..] before moving to the next X. thus, i will never get to see x=2 against y=[1..]. how can i fix this?
11:34:12 <dmwit> > map (var . return) ['x'..]
11:34:18 <lambdabot>  [x,y,z,{,|,},~,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,...
11:34:38 <EvilTerran> asdftimo, you need to re-phrase it so that only the first list in the comprehension is finite
11:34:56 <EvilTerran> asdftimo, for instance, you could only consider ys <= x
11:35:13 <EvilTerran> [z | x <- [1..], y <- [1..x], let z = (5^x)*(7^y)+1, isprime z]
11:35:29 <EvilTerran> but then you'd want to consider them with the two flipped, as well
11:35:31 <dmwit> Or you can use a better cartesian product function.
11:35:31 <asdftimo> yes i could, but then i would have to run it twice to get all possibilities
11:35:40 <asdftimo> dmwit: ??
11:35:49 <EvilTerran> diagonals!
11:35:59 <zachk> does pattern matching occur in checking order of function occurence in source
11:36:19 <monochrom> Bad wording, but yes.
11:36:19 <asdftimo> dmwit and Evilterran, i don't understand
11:36:21 <EvilTerran> [z | w <- [2..], x <- [1..w-1], let y = w-x, let z = (5^x)*(7^y)+1, isprime z]
11:36:34 <EvilTerran> > [(x,y) | w <- [2..], x <- [1..w-1], let y = w-x]
11:36:34 <byorgey> you could use the Omega monad ;)
11:36:42 <byorgey> but that's probably overkill =)
11:36:44 <lambdabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3,...
11:36:45 <zachk> monochrom: thank you
11:36:53 * monochrom cringes. What is the Omega monad?!
11:37:20 <zachk> im actually trying to diagonlize some stuff atm
11:37:21 <EvilTerran> asdftimo, that contains all pairs adding to 2, then all pairs adding to 3, then all adding to 4, etcetc
11:37:25 <byorgey> monochrom: it's actually pretty cool, I'll find you a link
11:37:36 <asdftimo> lemme think about that EvilTerran, thanks.
11:37:55 <byorgey> http://hackage.haskell.org/packages/archive/control-monad-omega/0.2/doc/html/Control-Monad-Omega.html
11:37:58 <lambdabot> Title: Control.Monad.Omega, http://tinyurl.com/5crxz4
11:38:20 <byorgey> monochrom: diagonal traversal of infinitely branching search spaces
11:39:25 <byorgey> @type runOmega
11:39:30 <asdftimo> EvilTerran: that's genius! i think it covers all of the pairs! thanks a lot.
11:39:37 <lambdabot> Not in scope: `runOmega'
11:39:49 <byorgey> someone should import Omega into \bot, it would be neat
11:40:02 <byorgey> where is the canonical lambdabot darcs repo these days?
11:40:04 <monochrom> Neato, the traversal order we're all taught for traversing NxN.
11:40:05 <EvilTerran> asdftimo, indeed it does. proof is left as an exercise to the reader, mind
11:40:09 <byorgey> monochrom: indeed.
11:40:32 <asdftimo> EvilTerran: i went through it and im fairly certain it does
11:41:12 <EvilTerran> well, given any (x,y), that pair will appear after O((x+y)^2) steps, won't it?
11:41:17 <shapr> @yow
11:41:17 <lambdabot> Couldn't find fortune file
11:41:19 * shapr cries
11:41:49 <dmwit> Those fortune files ought to be in the \bot repository.
11:42:14 <byorgey> monochrom: http://luqui.org/blog/archives/2008/05/02/enumerating-a-context-free-language/
11:42:16 <lambdabot> Title: Enumerating a context-free language @ The dreams that stuff is made of, http://tinyurl.com/5hqrad
11:42:23 <byorgey> that's Luke's original blog article about Omega
11:42:27 <byorgey> pretty neat
11:42:52 <byorgey> @version
11:42:52 <lambdabot> lambdabot 4.1
11:42:52 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:43:46 <asdftimo> EvilTerran: I think it is ((x+y)^2-(x+y))/2 steps, but im not sure.
11:45:19 <EvilTerran> that's inside the O(), it's fine :P
11:45:24 <EvilTerran> but, yes, something like that
11:46:08 <ski> hm .. does `Omega' satisfy the `associative' property ?
11:52:27 <ski> right, it doesn't (ty apfelmus)
11:52:56 <byorgey> yeah, I guess it is not technically a monad
11:53:13 <hpaste>  zachk pasted "silly parse error" at http://hpaste.org/8712
11:53:50 * byorgey builds lambdabot
11:53:52 <ski> byorgey : if `runOmega' gave a set (or bag), it would be a monad
11:54:11 <monochrom> zachk: the line before has unmatched {
11:54:12 <byorgey> ski: yes, I see what you mean
11:54:37 <Deewiant> zachk: as well as (
11:55:03 <scodil_> does anyone know if single-method classes are treated differently than multi-method classes by ghc?
11:55:15 <scodil_> wrt optimization, inlining, specialization
12:03:05 <zachk> thankyou Deewiant and monochrom
12:11:55 <dons> scodil_: they are, yes.
12:12:30 <hpaste>  zachk annotated "silly parse error" with "cartesian product of infinite lists" at http://hpaste.org/8712#a1
12:21:33 * byorgey bakes lambdawaffles with coblueberry cosyrup
12:22:14 <scodil_> dons: like what? I'm in the middle of writing a bug report, so let me know if I shouldn't
12:22:24 <dons> hmm. let me see if i can find my notes
12:22:28 <scodil_> i'll paste... hold on..
12:22:48 <dons> all i have is:
12:22:50 <dons> "  -- This makes GHC's optimiser happier; it sometimes produces really bad
12:22:50 <dons>   -- code for single-method dictionaries
12:22:50 <dons> "
12:23:01 <dons> in a little class that adds a second dummy method to a class
12:23:09 <dons> so that we can defeat the single-method dictionary bad code.
12:23:19 <dons> that was 1 year ago so might not still be relevant
12:23:35 <dons> i just added
12:23:36 <dons>   unlifted_dummy :: a
12:23:36 <dons>   unlifted_dummy = error "unlifted_dummy"
12:23:38 <dons> to the class
12:25:39 <hpaste>  scodil_ pasted "single-method class" at http://hpaste.org/8713
12:26:07 <scodil_> I would say the single-method class produces better code than the multi-method one
12:26:39 <scodil_> in that context anyway. If that gets inlined elsewhere then maybe not
12:27:47 <tusho> @faq
12:27:48 <lambdabot> The answer is: Yes! Haskell can do that.
12:29:17 <Botje> yay
12:29:28 <Botje> two more euler problems and i'm back at 50%!
12:29:40 <dons> scodil_: awesome. that looks like a good bug report
12:29:51 <scodil_> so this is not a feature then?
12:29:55 <dons> scodil_: does -fdicts-strict help?
12:30:15 <dons> hmm, maybe that flag is gone
12:30:21 <dons> -fdicts-cheap
12:30:33 <dons> or -fno-method-sharing
12:33:31 <scodil_> fdicts-cheap does nothing, fno-method-sharing changes the call from GHC.Float.timesDouble to GHC.Num.*, but still not inlined
12:34:43 <scodil_> fdicts-strict does nothing either
12:35:10 <scodil_> so report this then?
12:35:26 <dons> dictionaries eh
12:35:27 <SamB> edwardk: you should write better documentation for the Monad class of Control.Monad
12:35:45 <dons> scodil_: i wonder
12:36:30 <dons> scodil_: yeah, seems like something worth clarifying
12:36:34 <scodil_> if it were the other way around I could just add dummy methods, but the single method class is doing better
12:36:48 <dons> yep
12:40:40 <dmwit> :t uncurry (liftM2 (,))
12:40:41 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
12:41:34 <scodil_> dons: is there any chance of turning Data.Array.Vector.Prim.BUArr into its own library? A thin wrapper onto raw GHC arrays that does depend on Ix, IArray or MArray, nor exporting any prim ops?
12:41:44 <scodil_> that would be really awesome
12:42:30 <dons> woot, http://www.reddit.com/info/6qb1w/comments/
12:42:30 <lambdabot> Title: reddit.com: Language.C: manipulating and generating C abstract syntax from Haske ...
12:42:46 <dons> scodil_: well, i inteded MUArr to be exported
12:43:25 <dons> so you can get the type class instances
12:45:37 <scodil_> you still need ghc source to compile uvector, do you not?
12:46:14 <dons> no?
12:46:24 <dons> its just a library, cabal install uvector
12:46:29 <dons> nothing magic about it
12:46:34 <scodil_> oh. i must be thinking of something else
12:46:44 <dons> ghc-api maybe?
12:47:21 <scodil_> I'm getting "no available version of ghc-prim that satisfies -any"
12:49:07 <dons> oh, are you using ghc head?
12:49:10 <dons> but slightly older?
12:49:19 <dons> or 6.8.3...
12:49:28 <dons> yes, my fault.
12:49:38 <dons> change the .cabal file line to:
12:49:39 <dons>       if impl(ghc >= 6.10)
12:50:32 <stepcut> dons: yay for C! Maybe I can finally finish my unlambda compiler
12:51:26 <SamB> @index Functor
12:51:26 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:54:02 <dons> scodil: i just uploaded a fix.
12:54:21 <scodil> cool thanks
12:54:41 <vixey> 6.10 is out?!
12:54:48 <dons> no no no
12:55:30 <Liempt> @quote Liempt
12:55:30 <lambdabot> No quotes match. :(
12:55:37 <Liempt> SHUT UP
12:55:40 <Liempt> I HATE YOU
12:55:41 <Liempt> =(
12:55:42 <vixey> @quote
12:55:42 <lambdabot> Anonymous says: The alien rulers of the galaxy must surely use a statically typed language with type inference
12:56:03 <Liempt> What does it mean that no quotes match?  That quote is clearly about me.
12:56:26 <dmwit> ?quote .Liempt
12:56:26 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
12:56:33 <ikegami--> I try to make lambdabot using GHC 6.8.3, but, the '> 1+1' doesn't works: otherwise says "terminated."
12:56:44 <ikegami--> Something was wrong, but, i don't know
12:56:46 <vixey> @quote
12:56:46 <lambdabot> bos says: * bos is 6 months old, and can lift small buildings (after a bottle of milk) // Botje> bos: .. into what monad?
12:56:50 <dmwit> ?quote .is
12:56:50 <lambdabot> Saizan says: the problem is that we still have a silicon chip under us
13:12:15 <Saul__> I'm making a CGI application with HSQL for connecting to a database
13:12:30 <Saul__> how should I make updates to the database thread safe?
13:12:54 <Saul__> I heard good things about STM, but I'm not sure if that works well with the database
13:15:54 <Korollary> Saul__: In STM transactions IO is not allowed iirc.
13:16:08 <SamB> it is VERY UNSAFE, yes
13:16:46 <stepcut> Saul__: wouldn't you just use database transactions ?
13:17:00 <SamB> you CAN do it, but the ONLY TIME IT WOULD EVER MAKE SENSE would be for debugging/profiling
13:17:20 * stepcut can unlaunch missles
13:17:21 <SamB> and if you DO do it, you have to be VERY careful not to do any more STM ...
13:18:32 <dmwit> ?src unlines
13:18:33 <lambdabot> unlines = concatMap (++ "\n")
13:18:41 * dmwit sighs
13:18:57 <byorgey> dmwit: what's wrong?
13:19:24 <Saul__> stepcut: I think that might be best then
13:19:35 <dmwit> byorgey: In my head, I had 'unlines = intercalate "\n"', and was very confused about where all these extra newlines could have been coming from. =)
13:19:42 <byorgey> ah, hehe
13:19:58 <Saul__> stepcut: Can I do that in steps?
13:20:03 <stepcut> Saul__: with CGI, your problem isn't so much threads, but the fact that you will have multiple copies of your CGI programming running
13:20:04 <SamB> dmwit: do you know what happens if you cat files like that?
13:20:21 <Saul__> stepcut: like first query some data, then do something, then update some data, then commit?
13:20:36 <SamB> (hint: it depends on your shell)
13:20:42 <dmwit> SamB: I'm not sure what you're asking.  If you're asking what happens when you cat a file with no newline at the end, then yes, I know what happens.
13:20:47 <stepcut> Saul__: yes, though if you spend too long doing something you wil start getting database contention
13:20:55 <Saul__> stepcut: you're right
13:21:02 <SamB> dmwit: well, that's why unlines is the way it is ;-)
13:21:13 <stepcut> Saul__: the database will hold read or write locks on rows/tables while you are doing stuff (depends on the particular database how much gets held)
13:21:53 <Saul__> stepcut: It won't be long, just checking the new data for consistency
13:22:15 <stepcut> Saul__: ok, just don't doing some raytracing or anything ;)
13:22:28 <dmwit> SamB: That argument is missing a few pieces, I think.
13:22:33 <Saul__> :D
13:22:45 <dmwit> SamB: Why should I have to use "putStrLn . show", but "putStr . unlines"?
13:22:46 <Saul__> stepcut: I won't, thanks for your help
13:22:49 <stepcut> Saul__: what database, btw ?
13:22:54 <Saul__> mysql
13:23:20 <SamB> dmwit: I never said I was totally satisfied with the result of the reasoning
13:23:20 <dmwit> (And yes, I know that print = putStrLn . show)
13:23:27 <stepcut> Saul__: mysql does not support transactions out of the box, btw
13:23:43 <stepcut> Saul__: or at least it did not in 4.0
13:24:10 <Saul__> I'll look into that
13:24:58 <dons> dmwit: btw, print = putStrLn . show :)
13:25:25 * SamB elbows dons in the ribs. *hard*
13:25:29 <Heffalump> are you considering integrating STM with MySQL then?
13:25:34 <dmwit> =)
13:25:53 <bd_> stepcut: innodb supports transactions
13:26:37 <stepcut> Saul__: I believe MyISAM does not support transactions at all, so you have to configure it to use innodb and stuff
13:26:42 --- mode: ChanServ set +o dons
13:26:47 --- topic: set to '["print = putStrLn . show", "Haskell: precision engineering for programmers", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
13:26:54 --- mode: ChanServ set -o dons
13:26:58 <bd_> I don't know if it supports two-phase commit (which would seem to be necessary if you use STM plus two mysql connections...)
13:27:12 <stepcut> Saul__: but, it will *pretend* like it does -- you don't get any explicit errors
13:27:24 * dons starts thinking of cool things to do with Language.C
13:27:29 <dons> http://www.reddit.com/r/programming/info/6qb1w/comments/ for those who didn't see.
13:27:29 <lambdabot> Title: programming: Language.C: manipulating and generating C abstract syntax from Hask ...
13:27:43 <dons> this could be a new killer app, if we do a good job with it.
13:27:48 <dons> docs, examples.
13:27:52 <Saul__> stepcut: ok thanks
13:28:31 <Heffalump> dons: C compiler stress tests
13:28:34 <dmwit> dons: 'print = putStrLn . show' is all well and good until you want 'putStrLn . either show unlines' ;-)
13:28:35 <vixey> do what with it ?
13:28:40 <bd_> ooh, neat
13:28:52 <vixey> write compilers that generate high level C ?
13:29:25 <dons> the polymer simulator via generation gets a lot easier
13:29:38 * stepcut crosses his fingers for Language.C++ next GSoC ;)
13:30:26 <Saul__> stepcut: I switched one of my tables to innodb, but now phpmyadmin says "InnoDB free: 222208 kB" on the top of the page, does that mean that the table won't be able to contain more than 222 mb?
13:30:51 * bd_ has a project which uses a horrible perl script to generate C++ - it'd be nice to be able to use something more structured
13:30:58 <stepcut> Saul__: beats me, I just use HAppS these days. SQL makes me sad.
13:31:37 <Saul__> stepcut: It makes me sad too, but less than happs' lack of documentation (at least a year ago)
13:31:49 <Heffalump> does Language.C have a parser?
13:32:13 <stepcut> Saul__: I wrote a tiny bit of HAppS documentation yesterday, http://nhlab.blogspot.com/2008/07/extending-asterisk-with-happs.html
13:32:14 <lambdabot> Title: n-heptane lab: Extending Asterisk with HAppS, http://tinyurl.com/6nxvv7
13:32:14 <stepcut> ;)
13:33:05 <dons> Heffalump: yeah, the c2hs parser
13:33:14 <Heffalump> doing that for C++ would be infeasible
13:33:33 <stepcut> Heffalump: ;)
13:52:24 <shepheb> stepcut: can't build 6.8 or 6.9, bootstrapping from hc-files has been broken since 6.8
13:53:50 <stepcut> shepheb: suck
13:54:57 <shepheb> stepcut: I'm trying to build 6.6.1 in the interim (ie. until bootstrapping gets fixed for 6.9/6.10), but I'm busy with other things at least for a while today.
13:55:09 <stepcut> ok
13:55:31 <stepcut> so you would use 6.6.1 to get a unregisterised build, and then build 6.8 with that ?
13:57:24 <shepheb> stepcut: dont know. first step is to see if I can build a 6.6 that runs in the dev environment and whose binaries run on the device. then perhaps I will try to build a 6.8 with it (if you can do that with an unregisterised GHC?), and maybe even 6.9 with that 6.8.2, since there have been changes to the low-level parts that will affect any effort to create a properly registerised build, let alone NCG
13:59:34 <stepcut> shepheb: I have done that for the OS2006 and 6.6 I think, but not 2007 or 2008
14:02:04 <tapas_> hi
14:02:56 <saml> hey tapas_
14:03:08 <tapas_> in hugs haskell interpreter how can i define a function and reuse it later by reffering to its "name"?
14:03:16 <dmwit> let f x = x
14:03:36 <shepheb> odd. I'm awash in errors about an undefined reference to __DISCARD__ trying to build 6.6.1 using 6.6.1.
14:03:52 <tapas_> dmwit: hmm
14:03:53 <mauke> tapas_: you can't
14:04:02 <tapas_> mauke: okay!
14:04:03 <mauke> tapas_: you have to put it in a file and load it into hugs
14:04:10 <tapas_> that's terrible
14:04:19 <mauke> get ghci
14:04:27 <newsham> use ":e" in hugs
14:09:15 <jre2> if I have a large number of records who all share the same values in quite a few fields, will ghc optimize the memory usage (like hardlinks)?
14:10:05 <blakkino> jre2, why don't create a new datatype? in that way it would probably do it
14:10:07 <Cale> tapas_: It's not so bad. Just keep an editor window open alongside your ghci/hugs. :re will reload the file.
14:10:15 <mauke> only if you initialized them with the same values
14:10:30 <mauke> which is a bit like an explicit link() call
14:10:49 <tapas_> Cale: ok
14:11:36 <Cale> jre2: Sharing takes place automatically. Records never (unless you're using something like unbox strict fields) contain the actual data values for their fields, always pointers to them.
14:11:53 <Cale> (or pointers to code for computing them)
14:12:03 <shepheb> argh it looks like 6.6.1 has issues with my gcc version. this is becoming rather a mess.
14:12:17 <Zao> 3.3?
14:12:30 <shepheb> Zao: 4.3
14:12:35 <SamB> shepheb: try another
14:13:27 <shepheb> well, clearly. I'm just saying that this "oh, 6.6.1 can bootstrap so I'll just build it" is becoming expensive enough that I'm leaning more towards trying the patch that might fix the bootstrapping for 6.9.20080614
14:13:49 <Cale> jre2: So when you 'update' a record, constructing a new one with just one of the fields modified, the only thing which is copied from the other fields are the pointers to their contents.
14:14:54 <SamB> I meant "try another gcc version", btw
14:15:54 <shepheb> SamB: yes, I understand. I'm just not sure which way to go now. it would be a lot easier if 6.9 would bootstrap, so I didn't need an old GHC and now an old gcc. do I need an old libc too? it gets harder and harder to have them all coexist.
14:15:54 <jre2> Cale: so as long as I construct them all from some base record, it should work?
14:16:22 <Cale> jre2: yeah, pretty much
14:16:38 <SamB> shepheb: er, well you wouldn't on i386 ... but I dunno if they change ABI more often on ARM or not
14:16:56 <SamB> kind of doubt it though, for C
14:17:14 <Cale> jre2: or simply ensure that the components came from the same place
14:17:27 <shepheb> true. I think I'll probably try the patch that might fix bootstrapping 6.9 first, though
14:22:32 <stepcut`> cool
14:24:13 <catface> is there any way of mixing run-time and compile-time polymorphism in haskell?
14:24:32 <vixey> what
14:24:40 <mauke> like typeclasses?
14:24:57 <Heffalump> what do you mean by run-time polymorphism?
14:24:58 <catface> i guess
14:25:09 <vixey> typeclasses are not dispatched at runtim
14:25:19 <Heffalump> they can be, if you use polymorphic recursion
14:25:24 <Heffalump> or existential types
14:25:27 <catface> like virtual functions in c
14:25:34 <catface> ok
14:25:47 <vixey> C doesn't have virtual functions
14:25:49 <dons> ?faq
14:25:49 <lambdabot> The answer is: Yes! Haskell can do that.
14:25:50 <SamB> vixey: they can perform almost as badly as if they were ;-)
14:26:12 <catface> c++
14:26:28 <reubenf> if i have data Flush = Suit | False, why does Hand -> Suit not match Hand -> Flush?   http://codepad.org/AXDeXBzu
14:26:28 <lambdabot> Title: Haskell code - 15 lines - codepad
14:26:48 <dons> reubenf: is Hand a type or a value?
14:26:51 <dons> or both?
14:26:57 <newsham> http://codepad.org/users/haskell   login: haskell,  password: haskell
14:26:58 <lambdabot> Title: haskell - codepad
14:27:06 <reubenf> sorry
14:27:10 <mauke> reubenf: you have two different "Suit"s there
14:27:36 <reubenf> oh
14:27:49 <mauke> maybe you want isFlush :: Hand -> Maybe Suit
14:27:51 <jre2> reubenf: http://hpaste.org/
14:28:05 <catface> polymorphic recursion?
14:28:24 <reubenf> what is Maybe?
14:28:32 <newsham> ?src Maybe
14:28:32 <lambdabot> data Maybe a = Nothing | Just a
14:28:46 <reubenf> neat
14:29:14 <newsham> reu: your isFlush is returning the suit (of type Suit) not a value of type Flush
14:29:35 <newsham> you probably want flush:   data Flush = Flush Suit | NoFlush
14:29:52 <newsham> and ie: isFlush [ (rank,suit) ] = Flush suit
14:30:10 <mauke> http://codepad.org/qj0UQA6C
14:30:11 <lambdabot> Title: Haskell code - 15 lines - codepad
14:31:11 <reubenf> thanks mauke
14:31:17 <reubenf> and others :)
14:31:19 <Heffalump> catface: data Foo x = Foo [x] for example
14:31:49 <macondo> > let a x = x : a (x+1)
14:31:49 <lambdabot>  Parse error at end of input
14:32:15 <mauke> > let waffle :: (Show a) => Int -> a -> String; waffle 0 x = show x; waffle n x = waffle (n-1) (x,x) in waffle 4 'x'
14:32:16 <dmwit> > let a x = x : a (x+1) in a 0
14:32:16 <lambdabot>  "(((('x','x'),('x','x')),(('x','x'),('x','x'))),((('x','x'),('x','x')),(('x'...
14:32:18 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:32:26 <macondo> > a x = x : a (x+1) in take 10 (a 1)
14:32:26 <dmwit> macondo: Needs an "in" clause. ;-)
14:32:26 <lambdabot>  Parse error at "=" (column 5)
14:32:31 <dmwit> > enumFrom 0
14:32:33 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:32:44 <dmwit> macondo: But use that unless there's a good reason not to.
14:32:53 <dmwit> > [0..] -- desugars to enumFrom 0
14:32:55 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:33:26 <macondo> dmwit: yeah I know, but I'm learning Haskell so I want to re-invent the built-in functions :)
14:33:46 <vixey> learning haskell is as good a time as any to revinvent built ins
14:33:56 <dmwit> macondo: I consider that a good reason. =)
14:34:08 <vixey> they often have got excruciatingly specific types
14:34:15 <vixey> :t length
14:34:16 <lambdabot> forall a. [a] -> Int
14:34:24 <Botje> @pl \(a,b) -> not (null a || null b)
14:34:24 <lambdabot> uncurry ((not .) . (. null) . (||) . null)
14:34:29 <Botje> brr. scary.
14:34:50 <macondo> I started with Haskell a couple of months ago but I think I'm ready now.. I didn't actually understand it before
14:34:58 <byorgey> @type \(a,b) -> not (null a || null b)
14:34:59 <lambdabot> forall a a1. ([a], [a1]) -> Bool
14:35:02 <dmwit> Botje: (not . null .) . (++)
14:35:04 <newsham> macondo: thats what I say every year.
14:35:12 <dmwit> Botje: Although that restricts the type a bit.
14:35:15 <vixey> :t not . ((||)`on`null)
14:35:19 <SamB> vixey: and often it's easier to reinvent them than to find them in the library ;-)
14:35:20 <lambdabot>     Couldn't match expected type `Bool'
14:35:20 <lambdabot>            against inferred type `[a] -> Bool'
14:35:20 <lambdabot>     Probable cause: `on' is applied to too few arguments
14:35:26 <mauke> :t (not .) . join liftM2 (||) null
14:35:27 <lambdabot>     Couldn't match expected type `a2 -> f Bool'
14:35:27 <lambdabot>            against inferred type `Bool'
14:35:27 <lambdabot>       Expected type: (a2 -> f Bool) -> a2 -> f Bool
14:35:31 <byorgey> @type not . uncurry (||) . join null
14:35:32 <lambdabot>     Couldn't match expected type `[a] -> (Bool, Bool)'
14:35:32 <lambdabot>            against inferred type `Bool'
14:35:32 <lambdabot>     Probable cause: `null' is applied to too many arguments
14:35:33 <macondo> newsham: no no, really :)
14:35:37 <Botje> dmwit: that's not exactly the same, is it?
14:35:37 <mauke> :t (not .) . join (liftM2 (||)) null
14:35:37 <dmwit> :t (not .) . ((||) `on` null)
14:35:38 <lambdabot>     Couldn't match expected type `f Bool' against inferred type `Bool'
14:35:38 <lambdabot>       Expected type: m Bool -> m Bool -> m (f Bool)
14:35:38 <lambdabot>       Inferred type: m Bool -> m Bool -> m Bool
14:35:39 <lambdabot> forall a. [a] -> [a] -> Bool
14:35:40 <vixey> :t ((&&)`on`(not.null))
14:35:41 <lambdabot> forall a. [a] -> [a] -> Bool
14:35:43 <dmwit> Botje: No, it's not.
14:35:44 <byorgey> macondo: well, welcome =)
14:35:53 <dmwit> Botje: As I said, it restricts the types a bit.
14:35:56 <Botje> i want to check if both are non-null :)
14:35:58 <newsham> btw, happy fourth of july everyone
14:36:00 <newsham> go team america
14:36:11 <Botje> yours simply checks if any of them is non-null
14:36:13 <stepcut> yay america!
14:36:16 <dmwit> Botje: ...err, quite
14:36:16 <macondo> remember remember the fourth of july
14:36:29 <dmwit> :t liftM2 (&&) (not . null) (not . null)
14:36:30 <lambdabot> forall a. [a] -> Bool
14:36:36 <mauke> oh fk
14:36:38 <dmwit> oh
14:36:46 <mauke> liftM2 is for single argument, double function
14:36:47 <Japsu> @hoogle (Num a, Num b) => a -> b
14:36:48 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
14:36:48 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
14:36:48 <lambdabot> Control.Arrow.Transformer.lift :: ArrowTransformer f a => a b c -> f a b c
14:36:50 <dmwit> :t ap
14:36:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:36:58 <Japsu> @djinn (Num a, Num b) => a -> b
14:37:05 <Japsu> ...
14:37:24 <reubenf> if i had haskell on my computer would i be able to type "?src Just" to get the definition like lambdabot does?
14:37:28 <byorgey> @type not . uncurry (||) . (null *** null)
14:37:29 <lambdabot> forall a a1. ([a], [a1]) -> Bool
14:37:30 <dmwit> uncurry (&&) . (not . null *** not . null)
14:37:40 <dmwit> Yes!
14:37:41 <mauke> reubenf: no
14:37:42 <Japsu> gah
14:37:43 <dmwit> :t uncurry (&&) . (not . null *** not . null)
14:37:44 <lambdabot> forall a a1. ([a], [a1]) -> Bool
14:37:49 <byorgey> that works too
14:37:52 <Japsu> what's the function for generic coercion between numeric types
14:37:57 <dmwit> DeMorgan's
14:38:02 <byorgey> De Morgan ftw!
14:38:10 <mauke> Japsu: toEnum . fromEnum
14:38:21 <dmwit> :t fromEnum
14:38:23 <lambdabot> forall a. (Enum a) => a -> Int
14:38:25 <Japsu> betweenum? erm
14:38:27 <dmwit> Looks dangerous.
14:38:32 <mauke> hax
14:38:39 <Japsu> bah, wrong question
14:38:45 <mauke> it's for when you really need to convert a CChar to a Double or whatever
14:38:46 <Japsu> @djinn Num a => a -> Double
14:38:47 <lambdabot> Cannot parse command
14:38:49 <dmwit> ?hoogle toInteger
14:38:49 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
14:38:49 <newsham> ?djinn Either (a -> n, b -> n) -> (a,b) -> n
14:38:58 <dmwit> :t fromInteger . toInteger
14:38:59 <lambdabot> forall a a1. (Integral a1, Num a) => a1 -> a
14:39:08 <mauke> :t fromIntegral
14:39:09 <vixey> LIMITATIONS
14:39:09 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:39:12 <vixey> * Nesting of & and ! goals are limited to 2^27-2.
14:39:12 <Japsu> I want Ratio Integer -> Double
14:39:19 <dmwit> newsham: Not possible, in general.
14:39:20 <mauke> :t fromRational
14:39:21 <lambdabot> forall a. (Fractional a) => Rational -> a
14:39:27 <vixey> > 2^27-2
14:39:28 <kryptiskt> reubenf: you can do .t though to find the type, and the source for the functions are linked in the library documentation
14:39:28 <lambdabot>  134217726
14:39:28 <Japsu> oh, cool
14:39:33 <mauke> > fromRational (2%3)
14:39:33 <Japsu> but
14:39:34 <lambdabot>  0.6666666666666666
14:39:39 <newsham> dmwit:  uh,  I just take left and apply it to fst
14:39:40 <Japsu> Rational != Ratio Integer?!
14:39:42 <vixey> :t realtoFrac :: Ratio Integer -> Double
14:39:43 <mar77a> @bot
14:39:44 <lambdabot> :)
14:39:44 <lambdabot> Not in scope: `realtoFrac'
14:39:45 <Japsu> or is it
14:39:47 <mauke> Japsu: why not?
14:39:50 <vixey> :t realToFrac :: Ratio Integer -> Double
14:39:51 <lambdabot> Ratio Integer -> Double
14:39:59 <mauke> @src Rational
14:39:59 <lambdabot> type Rational = Ratio Integer
14:40:02 <Japsu> Ahh
14:40:02 <Japsu> ok
14:40:03 <dmwit> newsham: Either doesn't give you both a Right and a Left, only one of the two.
14:40:03 <byorgey> newsham: Maybe you meant Either (a->n) (b->n) ?
14:40:04 <Japsu> thanks
14:40:15 <dmwit> newsham: This one is possible: (a -> n, b -> n) -> (a, b) -> n
14:40:21 <newsham> byorgey: yes
14:40:31 <newsham> ?djinn Either (a -> n)  (b -> n) -> (a,b) -> n
14:40:31 <lambdabot> f a =
14:40:31 <lambdabot>     case a of
14:40:31 <lambdabot>     Left b -> \ (c, _) -> b c
14:40:31 <lambdabot>     Right d -> \ (_, e) -> d e
14:40:34 <byorgey> ?djinn Either (a->n) (b->n) -> (a,b) -> n
14:40:34 <lambdabot> f a =
14:40:34 <lambdabot>     case a of
14:40:35 <lambdabot>     Left b -> \ (c, _) -> b c
14:40:37 <lambdabot>     Right d -> \ (_, e) -> d e
14:40:44 <byorgey> oops =)
14:40:49 <newsham> btw, what "djinn" is lambdabot using now?
14:40:52 <vixey> :t either
14:40:53 <dmwit> err... oh
14:40:53 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:40:55 <newsham> its not in lambdabot's src tree anymore
14:40:56 * dmwit feels silly
14:41:00 <newsham> and the one I found seems to not be the one
14:41:06 * byorgey pats dmwit on the head
14:41:17 <Japsu> gah
14:41:28 <vixey> :t \x -> either (($) . fst x) (($) . snd x) ?e
14:41:29 <lambdabot> forall a a1 b b1. (?e::Either a b1) => (a -> a1 -> b, b1 -> a1 -> b) -> a1 -> b
14:41:47 * Japsu writes the following a hundred times on a blackboard: "I WILL NOT COMPARE FLOATING POINT VALUES WITH (==)."
14:41:53 <vixey> :t \x -> either ($ fst x) ($ snd x) ?e
14:41:54 <lambdabot> forall a b b1. (?e::Either (a -> b1) (b -> b1)) => (a, b) -> b1
14:42:15 * dmhouse wonders how else you'd compare them. 
14:42:23 <dmhouse> abs (x - y) < eps or something?
14:42:23 <dmwit> :t either (($) . fst) (($) . snd)
14:42:24 <lambdabot> forall b a b1 a1. Either (a -> b1, b) (a1, a -> b1) -> a -> b1
14:42:42 <dmwit> :t either (flip ($) . fst) (flip ($) . snd)
14:42:43 <lambdabot> forall b b1 a b2. Either (b2, b) (a, b2) -> (b2 -> b1) -> b1
14:42:44 <byorgey> ok, off to consume lightly charred foodstuffs
14:42:48 <dmwit> abh
14:43:01 <newsham> ?seen gwern
14:43:02 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 8h 32m 43s ago.
14:43:06 <Japsu> dmwit: abs(x - y) < epsilon
14:43:17 <Japsu> *dmhouse
14:43:20 <Japsu> gah
14:43:27 * Japsu skips the scrollback, as usual
14:43:30 <Japsu> 404 multifail
14:43:33 <Japsu> >_>
14:43:35 <Japsu> sleepy-time!
14:43:40 <dmwit> :t either ((fst .) . first ($)) ((snd .) . second ($))
14:43:41 <lambdabot>     Couldn't match expected type `(a, b)'
14:43:41 <lambdabot>            against inferred type `a1 -> b1'
14:43:41 <lambdabot>       Expected type: (a2 -> b2, a1 -> b1) -> (a2 -> b2, (a, b))
14:44:10 <masak> any suggestions how to make this code more elegant? http://paste2.org/p/45114 it already works, I'm just looking for ways to be brief.
14:45:51 <dons> i'd probably leave off the type signature for the worker functoin
14:45:51 <Beelsebob> masak: what is it meant to be doing?
14:45:59 <kryptiskt> x ~= y = abs (x-y) < epsilon
14:46:00 <dmwit> Beelsebob: See the comment at the bottom.
14:46:02 <masak> Beelsebob: says in the paste comment
14:46:17 <newsham> masak: "to iterate is illiterate, to recurse is worse"
14:46:20 <dons> otherwise, looks fine.
14:46:23 <masak> :)
14:46:36 <masak> newsham: how does that apply to me?
14:46:49 <newsham> you could use higher order functions to walk your data
14:46:50 <ivant> are haskell strings utf-16 or utf-32?
14:46:56 <dmwit> utf-8
14:46:57 <ivant> or is it ucs2/ucs4?
14:47:09 <dmwit> errr... wait
14:47:10 <ivant> dmwit, no way
14:47:12 <mauke> ivant: neither
14:47:13 <dons> ivant: 32 bit abstract unicode points.
14:47:17 <newsham> ivant: they're a list of 32-bit characters.
14:47:18 <masak> newsham: I'd be happy to receive more clues about how in this case
14:47:19 <dons> ivant: so then pick your encoding.
14:47:21 <mauke> they're linked lists of code points
14:47:50 <vinicius> !
14:48:02 <newsham> masak: digesting this.
14:48:03 <roconnor> masak: you ought to be able to remove the reverse.
14:48:15 <ivant> dons, newsham, thanks
14:48:18 <masak> roconnor: yes, probably
14:48:36 <newsham> ivant: utf-8/16/32 etc are encodings that come into play when you're doing things like IO
14:48:49 <mauke> or memory access
14:48:55 <newsham> unfortunately the standard IO functions just read in bytes as characters
14:48:57 <roconnor> doing ('S':) >>= (helper (x:xs) (n+1) [n] r)  would be my guess
14:48:57 <mauke> serialization to bytes, etc
14:49:04 <roconnor> and of course, Just r
14:49:08 <roconnor> er
14:49:13 <roconnor> Just []
14:49:15 <vinicius> guys, 7 days for ICPF contest
14:49:18 <newsham> and write out characters as bytes through truncation
14:49:20 <roconnor> get rid of the r parameter
14:49:30 <vinicius> are we ready to make Haskell the language of indiscriminated hacker again?
14:49:51 <mauke> "indiscriminated"?
14:49:55 <newsham> vinicius: ddarius suggested sed.
14:49:58 <roconnor> vinicius: I'm at a conference.  Haskell is doomed without me :P
14:50:06 <masak> roconnor: the r is just an accumulator. I started out without it, but realized I wanted to bail out of some calculations
14:50:07 <vinicius> discriminating =P
14:50:26 <vixey> what will ICPF be/
14:50:26 <mauke> Haskell: the language of indiscriminate hackers
14:50:27 <vixey> ?
14:51:05 <dmwit> vixey: It's a programming competition.
14:51:16 <dmwit> ...and I think it's actually ICFP.
14:51:16 <vinicius> *icfp *discriminating
14:51:17 <jre2> anyone know the status of extensible records / static duck typing for ghc?
14:51:19 <dmwit> ?go icfp
14:51:20 <lambdabot> http://www.icfpconference.org/
14:51:20 <lambdabot> Title: The ACM SIGPLAN International Conference on Functional Programming (ICFP)
14:51:21 <roconnor> masak: that's okay, use my code
14:51:24 <Japsu> did you know
14:51:27 <SamB> dmwit: quite so
14:51:35 <roconnor> masak: replace Just with Nothing
14:51:37 <roconnor> er
14:51:40 <roconnor> masak: replace Just with return
14:51:43 <SamB> and actually the ICFP is a conference
14:51:45 <Japsu> ...that if you roll 645 300000-sided dice, the probability of getting at least one pair is roughly 0,5?
14:51:45 <roconnor> and replace Nothing with ...
14:52:08 <SamB> which has an annual competition
14:52:11 <dmwit> Japsu: Pair?  As in, pair showing the same number?
14:52:16 <Japsu> dmwit: yep
14:52:18 <vixey> @dice 645d300000
14:52:18 <lambdabot> 645d300000 => 95960089
14:52:18 <SamB> held prior to the conference
14:52:27 <SamB> which they announce the results of at the conference
14:52:38 <Japsu> Ummm no, you're not supposed to sum them
14:52:42 <vinicius> wow, it's hard to get your point across here =P
14:52:45 <Japsu> so @dice won't do!
14:52:58 <vixey> @dice 645d300000
14:52:58 <lambdabot> 645d300000 => 97726311
14:53:05 <masak> roconnor: I'll try. not too comfortable with monads yet, though
14:53:16 <Japsu> ...but rolling 645d300000 is quite funny in itself
14:53:21 <Japsu> now that you come to think of it
14:53:27 <Japsu> @dice 645d300000
14:53:27 <lambdabot> 645d300000 => 94486806
14:53:35 <Japsu> \:D/
14:53:35 <roconnor> masak: well, keep Nothing as Nothing for now.
14:53:47 <roconnor> Where is our CPS style Exit Monad?
14:53:58 <dmwit> > 1 - (product [300000..300000-645] % (product . replicate 645) 300000)
14:54:00 <lambdabot>  5536168426744474969056605767077275545903010474061201280187469375477066817845...
14:54:00 <roconnor> http://www.haskell.org/haskellwiki/New_monads/MonadExit looks just like MonadError
14:54:01 <newsham> masak: sorry, your code hurt my brain. :(
14:54:01 <lambdabot> Title: New monads/MonadExit - HaskellWiki
14:54:15 <masak> newsham: then I apologise :/
14:54:16 <Japsu> dmwit: oh wow
14:54:25 <dmwit> > let x = 1 - (product [300000..300000-645] % (product . replicate 645) 300000) in numerator x / denominator x
14:54:27 <lambdabot>  Add a type signature
14:54:29 <Japsu> dmwit: did I paste that here, or did you just make it up?
14:54:31 <dmwit> > let x = 1 - (product [300000..300000-645] % (product . replicate 645) 300000) in numerator x / denominator x :: Double
14:54:33 <lambdabot>   add an instance declaration for (Integral Double)
14:54:33 <Japsu> I didn't
14:54:37 <Japsu> cool
14:54:49 <ddarius> jre2: The status of what?  There is no proposal to add anything like that to GHC.
14:54:58 <dmwit> > let x = 1 - (product [300000..300000-645] % (product . replicate 645) 300000) in numerator (fromInteger x) / denominator (fromInteger x) :: Double
14:55:00 <lambdabot>  Couldn't match expected type `Integer'
14:55:04 <dmwit> bah
14:55:10 <dmwit> What do you want out of me, lambdabot?
14:55:23 <jre2> ddarius: well, there's a ticket for extensible records.
14:55:26 <newsham> i wonder how icfp contest is gonna handle thousands of contestants simultaneously trying to download a livecd
14:55:28 <Japsu> > let p_ :: Integer -> Integer -> Ratio Integer; p_ n m = 1 - (product [m - n + 1 .. m]) % (m^n) in p_ 645 300000
14:55:30 <lambdabot>  5731686378216876675562835919812888096310805658255354113794005134154482876047...
14:55:38 <Japsu> > let p_ :: Integer -> Integer -> Ratio Integer; p_ n m = 1 - (product [m - n + 1 .. m]) % (m^n) in fromRational $ p_ 645 300000
14:55:40 <lambdabot>  0.4998245274076913
14:55:45 <Japsu> ^___________^
14:55:46 <jre2> ddarius: although it's been open for 8months without any further comment
14:55:47 <dmwit> Ooo, fromRational. =)
14:56:21 <vixey> newsham: huh livecd?
14:56:24 <dmwit> Also, I need to stop Haskelling for the day, my first try was *seriously* buggy.
14:56:34 <roconnor> boy, we desparately need CPS monad implementations.
14:56:37 <Japsu> dmwit: It was _really_ close to mine
14:56:47 <Japsu> and it took me a long time and an A4 of paper to figure it out ;D
14:56:50 <newsham> > sqrt 300000
14:56:52 <lambdabot>  547.7225575051662
14:56:53 <ddarius> newsham: Bittorrent?
14:57:24 <newsham> vixey: http://www.icfpcontest.org/rules.html mentions livecd
14:57:24 <lambdabot> Title: ICFP Programming Contest 2008: Rules
14:57:57 <newsham> if you have 548 values chosen uniformly over 300k possibles, odds are two of them match
14:58:01 <macondo> I love the Rational data type
14:58:27 <macondo> > 0.00123123123 :: Rational
14:58:29 <lambdabot>  123123123%100000000000
14:58:34 <roconnor> mauke: sorry, I should have said liftM ('S':) (helper (x:xs) (n+1) [n] r)
14:58:43 <vixey> I don't know about that
14:58:43 <roconnor> and the r is gone
14:58:46 <roconnor> mauke: sorry, I should have said liftM ('S':) (helper (x:xs) (n+1) [n])
14:58:47 <mauke> roconnor: ?
14:58:52 <roconnor> ah
14:58:55 <roconnor> sorry mauke
14:58:57 <mauke> tabwned
14:59:07 <newsham> http://en.wikipedia.org/wiki/Birthday_paradox
14:59:08 <roconnor> masak: sorry, I should have said liftM ('S':) (helper (x:xs) (n+1) [n])
14:59:20 <masak> roconnor: that does make more sense
14:59:30 <vixey> > 2%4
14:59:32 <lambdabot>  1%2
14:59:43 <masak> roconnor: I think I can work that in. thanks!
15:00:05 <newsham> > 1 - exp (negate (645*645)/(2*300000))
15:00:08 <lambdabot>  0.5001138967455883
15:00:48 <masak> roconnor: it bothers me that lines 5 and 8 are basically the same, but I suppose there's no way around that...
15:00:52 <augustss> > 1 - exp (negate (645*645)/(2*300000)) :: CReal
15:00:53 <lambdabot>  0.500113896745588323765974701004427773199
15:01:08 <newsham> > let f n m = 1 - exp (negate (n*n)/(2*m)) in map (flip f 300000) [550,600,650]
15:01:10 <lambdabot>  [0.3959912936513359,0.4511883639059736,0.5054794969855008]
15:01:34 <roconnor> masak: you could make a pattern just for that
15:01:47 <roconnor> helper (x:xs) n    _ | x >= n    = ...
15:02:02 <masak> roconnor: good idea :)
15:02:11 <hpaste>  Japsu pasted "codegolfing ORE" at http://hpaste.org/8716
15:02:21 <roconnor> masak: We can use continuations to get the short-circut on failure that you wanted
15:02:36 <Japsu> dmwit: http://hpaste.org/8716
15:02:38 <masak> cool
15:02:39 <roconnor> masak: unfortunately it isn't as easy as it should be at the momment. :(
15:02:52 <newsham> roconnor: you cant just lift into Maybe for short circuits?
15:03:11 <masak> roconnor: ...but will be in the future?
15:03:16 <roconnor> masak: after the Nothing, the stack still needs to unwind.
15:04:11 <roconnor> masak: I hope it will be in the future. ... we could write one right now, but it'd be a little advanced. :)
15:04:13 <augustss> we all need to unwind
15:04:26 <masak> roconnor: heh. better not
15:04:30 <newsham> augustss: in prep for nextweek?
15:04:54 <roconnor> masak: unless you have a bottle neck here, I wouldn't bother with CPS.
15:04:55 <augustss> newsham: are you referring to the icfp contest or the iphone launch?
15:04:56 <vixey> mmmmm
15:05:02 <newsham> augustss: is your darcs the definitely home for djinn these days?
15:05:05 <Peaker> Saizan: ping
15:05:05 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
15:05:06 <masak> roconnor: gotcha
15:05:15 <newsham> augustss: prob icfp, i dont like cell phones
15:05:22 <vixey> what is good about htis Heap Lambda Machine?
15:05:36 <vixey> there are a lot of VMs for lambda
15:05:37 <augustss> newsham: i consider it the home of djinn, but nothing much has happened
15:05:48 <roconnor> masak: one day it will be as simple as replacing Maybe with Control.Monad.Maybe.CPS.MaybeCPS
15:05:59 <roconnor> masak: and then it will be fast.
15:06:07 <newsham> i'm wondering because it used to be in lambdabot's src tree, but got removed, and i installed yours and now my lambdabot has extra output thats filtered out of the normal lambdabot's output
15:06:08 <masak> roconnor: brave new world :)
15:06:21 <vixey> roconnor: how would MaybeCPS look ?
15:06:29 <vixey> return = id ?
15:06:49 <vixey> or more like taking just and nothing continuations?
15:07:00 <augustss> newsham: the one in lambdabot was probably hacked
15:07:04 <ddarius> vixey: ContT Maybe
15:07:23 <vixey> @unmtl ContT Maybe
15:07:24 <lambdabot> err: `ContT Maybe' is not applied to enough arguments, giving `/\A B. (B -> A Maybe) -> A Maybe'
15:07:27 <newsham> yah thats what i'm thinking.  its odd they took it out
15:07:37 <vixey> @unmtl ContT Maybe x
15:07:37 <lambdabot> err: `ContT Maybe x' is not applied to enough arguments, giving `/\A. (A -> x Maybe) -> x Maybe'
15:07:41 <ddarius> vixey: Probably ContT r Maybe
15:07:47 <vixey> @unmtl ContT r Maybe
15:07:47 <lambdabot> err: `ContT r Maybe' is not applied to enough arguments, giving `/\A. (A -> Maybe r) -> Maybe r'
15:08:08 <ddmnshs> =<<
15:08:40 <ddmnshs> @ =<<
15:08:44 <roconnor> something like MaybeCPS a := forall r. ((Maybe a -> r) -> r)
15:08:54 <roconnor> or
15:09:13 <roconnor> something like MaybeCPS a := forall r. ((a -> r,r) -> r)
15:09:15 <masak> roconnor: I bioled it down a bit; it looks nicer now: http://paste2.org/p/45121
15:09:16 <roconnor> or
15:09:22 <masak> unfortunately, it doesn't compile :/
15:09:25 <roconnor> something like MaybeCPS a := forall r. ((a -> r) -> r -> r)
15:09:45 <ddarius> roconnor: That would just be Cont r (Maybe a) and wouldn't actually do anything.
15:10:05 <roconnor> ddarius: what do you mean?
15:11:08 <roconnor> masak: need parenthesis around (n:zs).
15:11:15 <masak> oh
15:11:23 <masak> I'm in a phase where I do that a lot
15:11:42 <roconnor> masak: no one out grows that phase :(
15:11:49 <masak> :/
15:11:58 <masak> roconnor: works better now :)
15:12:16 <roconnor> ddarius: why wouldn't it do anything.  presumably >>= wouldn't have the pattern match.
15:12:31 <ddarius> roconnor: Your first example is exactly Cont r (Maybe a), and would just be a computation that returned a Maybe value.
15:12:55 <roconnor> oh right
15:13:01 <roconnor> I did this deduction wrong.
15:13:26 <roconnor> MaybeCPS a := forall r. (a -> Maybe r) -> Maybe r
15:13:38 <ddarius> Yep.  That one is ContT r Maybe a
15:13:55 <mmorrow> Cont (Maybe r) a  :)
15:13:57 <roconnor> masak: good thing we are not trying to do the CPS.
15:14:07 <ddarius> mmorrow: Yes.
15:14:10 <ddarius> @src ContT
15:14:10 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
15:14:17 <mmorrow> oh, but he's got a forall a. there
15:14:30 <mmorrow> i mean r
15:14:32 <masak> roconnor: :D
15:15:11 <roconnor> ddarius: it seems we ought to be able to simplify the maybe away somehow, but I don't see how to do it.
15:15:30 <vixey> hey how would this look in Haskell? http://bach.istc.kobe-u.ac.jp/llp/papers/asc97/node9.html#SECTION00043000000000000000
15:15:32 <lambdabot> http://tinyurl.com/5gwrrn
15:15:43 <mmorrow> roconnor: use callCC?
15:16:07 <roconnor> mmorrow: that's what i want.
15:16:21 <mmorrow> yay!!CC
15:16:55 <ddarius> roconnor: You can, it's just not going to change much and takes more effort than simply using ContT r Maybe.
15:17:36 <saml> why 7 days?
15:17:44 <mmorrow> but with callCC you can return a value on "abort" instead of Nothing
15:17:55 <mmorrow> and many levels deep
15:18:46 <ddarius> mmorrow: That's what ContT r Maybe will do only it returns Nothing, but it's easy to use 'maybe' to turn that nothing into a value.
15:18:58 <ddarius> Which is effectively all that "getting rid of" the Maybe type would do.
15:19:09 <ddarius> mmorrow: Also, callCC wouldn't work (pleasantly).
15:19:12 <roconnor> ddarius: right, we would want to fold maybe into the run command.
15:19:37 <mmorrow> i suppose, but i don't think you'd be able to recover callCC's ability to return from arbitrary nesting
15:20:39 <ddmnshs> @:t (=<<)
15:20:39 <roconnor> how about maybCPS a := forall r. (a -> r) -> r -> r
15:20:40 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
15:20:40 <lambdabot>  Press `:help' for help or `:quit' to quit.
15:20:40 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
15:20:40 <lambdabot>  > >
15:20:50 <roconnor> oh
15:20:53 <roconnor> that's what I said before
15:20:57 <roconnor> :/
15:21:06 <mmorrow> \f -> callCC $ \k -> forever (f k)
15:21:19 <roconnor> CPS makes my head hurt
15:21:25 <mmorrow> would returning nothing allow you to break from the forever?
15:21:30 <roconnor> that's why someone else ought to write the CPS monad implementations.
15:21:31 <mjrosenb> roconnor: why?
15:21:51 <roconnor> mjrosenb: I find it hard to see the run-time implications.
15:22:15 <ddarius> mmorrow: ContT r Maybe a is not the same as Cont r (Maybe a).  You wouldn't be "returning" Nothing.  You'd use mzero which is like control (\_ -> Nothing)
15:22:19 <mjrosenb> run time implications?
15:22:36 <roconnor> ddarius: ah right
15:22:48 <ddarius> mmorrow: With callCC you couldn't even write that as callCC still "returns" the value if the continuation isn't used rather than aborting.
15:22:57 <roconnor> masak: you can replace Nothing with "mzero"
15:23:01 <ddarius> mmorrow: To get callCC to work you'd have to additionally pass around an "abort" continuation.
15:23:08 <masak> roconnor: how is that better_
15:23:10 <masak> ?
15:23:12 <mmorrow> ddarius: well, that's what the k is
15:23:16 <roconnor> masak: then you will be ready for the magical drop in replaced from the future.
15:23:31 <ddarius> mmorrow: No, the k is the rest of the continuation, not the "outermost" continuation.
15:23:32 <mmorrow> the wormhole back to the furture
15:23:36 <masak> roconnor: ah
15:23:59 <mmorrow> the "rest of the continuation" returns you to where callCC was called
15:24:07 <ddarius> mmorrow: Which is not what you want.
15:24:27 <mmorrow> oh, i guess i don't know what you're going for then
15:24:47 <ddarius> mmorrow: It's fine if you want -named- places to escape to, but if you just want to "abort" the "whole" computation, then you don't need a name.
15:25:29 <ddarius> mmorrow: With ContT r Maybe a I can write: divide x y | y == 0 = fail "crud" | otherwise = return (x / y)
15:25:57 <mmorrow> sure
15:26:02 <ddarius> mmorrow: Using callCC I'd have to write: callCC (\escape ->  .... divide x y escape .... )
15:26:26 <ddarius> And write divide x y escape | y == 0 = escape "crud" | otherwise = return (x/y)
15:26:37 <ddarius> I.e. I'd have to pass around this "escape" continuation everywhere.
15:26:54 <mmorrow> but what if at divide you're 20 levels deep in some computation which you want to abort all the way back to the start upon some condition?
15:27:26 <mmorrow> ddarius: so, i agree Maybe is enough as long as you only care about aborting one level up
15:27:46 <tchakkazulu> Store the continuation to abort to in a Reader?
15:27:49 <ddarius> mmorrow: I wasn't talking about -Maybe- in the first example, I wast talking about ContT r Maybe a
15:27:58 <mmorrow> (i shortened it :))
15:28:07 <ddarius> mmorrow: They are not equivalent.
15:28:24 <mmorrow> (i know)
15:28:26 <ddarius> tchakkazulu: Yes, that's one wasteful approach.  A better approach is to use 'control' instead of 'callCC' which allows aborting the whole computation.
15:28:41 <ddarius> tchakkazulu, mmorrow: which is what the ContT r Maybe version does.
15:29:00 <tchakkazulu> Ah, okay.
15:29:18 <tchakkazulu> Sorry if I just interrupted the discussion, then :)
15:29:26 <ddarius> mmorrow: mzero for ContT r Maybe a is mzero ContT (\_ -> Nothing) or (equivalently) control (\_ -> Nothing).
15:29:47 <ddarius> + and = after the second mzero
15:29:52 <ddarius> s/and/an
15:30:11 <mmorrow> ddarius: ah, now you pull the rabbit out of the hat ;)
15:30:31 <ddarius> [17:22] <ddarius> mmorrow: ContT r Maybe a is not the same as Cont r (Maybe a).  You wouldn't be "returning" Nothing.  You'd use mzero which is like control (\_ -> Nothing)
15:30:37 <ddarius> That's what I said earlier.
15:31:02 <mmorrow> ddarius: i wasn't taking that into account in my argument, but now i'm curious
15:31:29 <mmorrow> ddarius: yeh, *now* i realize that's what you were saying
15:32:02 <mmorrow> ddarius: but i have to do some experimenting in ghci to sort this out in my head :)
15:32:40 <vixey> what are eigen-variables of a proof?
15:32:59 <ddarius> callCC is usually what you want, but control makes a better primitive because it's easy to write callCC given control, but not the other way.
15:33:27 <mmorrow> ohhhhh, control as in the "control" operator
15:34:03 <mmorrow> oops
15:34:18 <mmorrow> damn my history's gone
15:34:42 <mmorrow> logs FTW
15:36:05 <mmorrow> ddarius: out of curiosity, are you getting this particular way to define control from 'shift to control'?
15:37:10 <ddarius> I haven't given a definition of control, but it's a (the) standard one.
15:37:40 <ddarius> @src ContT callCC
15:37:40 <lambdabot> callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \_ -> c a)) c
15:37:55 <mmorrow> well, you've implied one at the very least then
15:38:04 <ddarius> Take that definition of callCC and simply replace the second use of 'c' with 'return'
15:39:16 <mmorrow> i just remember him using Maybes in the types of his functions in that paper, but haven't looked at it in a while. was just curious if the Maybe connection was actual
15:39:37 <ddarius> mmorrow: There is no connection to maybe
15:40:17 <ddarius> This is a generic continuation monad transformer and you can make an instance of MonadPlus also generically if the underlying monad is itself an instance of MonadPlus.
15:40:21 <mmorrow> (connection in the sense that he used the Maybe concept in his typedef(s) and you are talking about control and Maybe in the same sentence)
15:40:57 <mmorrow> wait, are we talking about the same thing?
15:41:08 <mmorrow> the control operator known as "control"?
15:41:28 <mmorrow> (well, in haskell it's a function and not syntax)
15:42:14 <ddarius> I am talking about a control operator named "control".  There are different versions, but one is more common/accepted than the others.  I've given you a definition.
15:42:23 <mmorrow> interesting
15:43:02 <ddarius> @src ContT MonadPlus
15:43:03 <lambdabot> Source not found.
15:43:09 <ddarius> @src ContT mzero
15:43:09 <lambdabot> Source not found. Sorry.
15:43:23 <ddarius> I don't think the instance is in the libraries.
15:43:55 <ddarius> mzero = ContT (mzero >>=)
15:44:24 <mmorrow> hmm
15:44:30 <hpaste>  Peaker pasted "Arrow reverse dependencies" at http://hpaste.org/8719
15:44:48 <Peaker> I have computation of reverse dependencies in simple arrows working
15:44:51 <Peaker> Yay me
15:45:16 * mmorrow goes "back to the drawing board"
15:45:29 * mmorrow means ghci of course
15:45:43 <Peaker> mmorrow: I need a nice way to show pure functions
15:46:13 <Peaker> DebugShow ftw
15:46:23 <mmorrow> Peaker: exhilarating
15:46:41 <mmorrow> i just saw your paste
15:46:56 <mmorrow> is this related to what you now want to do?
15:47:25 <Peaker> mmorrow: Showing pure functions? Yeah it could be nice to show the actual function rather than just "pure"
15:47:51 <ddarius> Peaker: s/Bind/Compose
15:47:52 <mmorrow> hmm. ok, so what exactly is your goal?
15:48:04 <Peaker> the SArrow class comment is accidental
15:48:33 <mmorrow> oh. i just saw your *newest* paste just now
15:48:38 * mmorrow looks
15:48:39 <Peaker> mmorrow: I want to represent an incremental computation with an arrow instead of a monad (similar to the paper "Monads for incremental computation") and I want it to do updates properly
15:49:05 <hpaste>  Peaker pasted "without the accidental comment" at http://hpaste.org/8720
15:49:15 <mmorrow> so something like a "state arrow"?
15:49:36 <Peaker> mmorrow: what's a state arrow?
15:50:21 <Peaker> like the state monad, but allows parallelizing computations on differing subsets of the state?
15:50:26 <mmorrow> whatever the analog, loosely speaking, of the state monad but an arrow?
15:50:36 <Peaker> well I can think of different analogs, I think
15:50:59 <mmorrow> i was speaking loosely of course, i don't have any one partic implem in mind
15:50:59 <Peaker> either it runs it in parallel, or according to the arrow bind order
15:51:03 <mmorrow> just the general concept
15:51:12 <Peaker> ddarius: fixed
15:51:36 <hpaste>  Peaker pasted "Use Compose" at http://hpaste.org/8721
15:51:39 <mmorrow> Peaker: lemme look at your most recent paste for a bit
15:52:17 <Peaker> mmorrow: the output of "putStrLn $ show $ effects x [[TupleSecond, TupleFirst, TupleSecond]]" is "[[TupleFirst],[TupleSecond,TupleSecond,TupleFirst,TupleSecond]]"
15:52:32 <Peaker> mmorrow: where x is "((pure id) &&& (first (pure id)))"
15:53:06 <mmorrow> noted.
15:53:29 <Peaker> mmorrow: [TupleSecond, TupleFirst, TupleSecond] refers to: (_,((_,c),_))
15:54:24 <Peaker> so if that element is changed in the x-arrow's input, it changes the whole first element of the result tuple, and in the second tuple, it only changes the same subpath (because first "passes it through" as is)
15:54:29 <vixey> cdadr
15:56:18 <Peaker> I couldn't pattern-match against an argument of the function, which required me to use an explicit if-equality, and duplicate the catch-all case in the if's "else" clause
15:56:23 <SamB> vixey: you've been lisping again, haven't you?
15:56:27 <Peaker> I wonder if there's a more elegant way
15:56:34 <SamB> vixey: how many times do I have to tell you to stop doing that?
15:56:42 <mmorrow> Peaker: so what is the end goal of this exercise in your mind? because i'm unclear.
15:56:44 <Peaker> vixey: ah, now I know what you're talking about ;)
15:56:56 <Peaker> mmorrow: did you read the "monads for incremental computing" paper?
15:57:28 <mmorrow> ah, i got to the page but then taskswitched
15:57:32 <mmorrow> looking...
15:57:39 * vixey is read about linear logic actually
15:58:23 <Peaker> mmorrow: he does something along the lines of:  mySlot = do { a <- read aSlot ; b <- read bSlot ; write (a*b) } -- then each time aSlot or bSlot are updated, it will rerun the "rest of the computation" after that read
15:58:27 <mmorrow> Peaker: do you have a link, i can't seem to find a working one
15:59:16 <Peaker> mmorrow: Do you have ACM subscription?
15:59:22 <mmorrow> no :(
15:59:54 <mmorrow> ok, so it looks like from where i'm standing that it's essentially a "state-monad-ish" computation
16:00:28 <Peaker> mmorrow: think Spreadsheet. Each such computation represents a cell
16:00:40 <shepheb> GHC build failure count ++, I'm up to 3 now. the patch in #1346 atop 6.8.2 didn't work :(
16:00:52 <saadahmad> Hey guys, what is the difference between array and listArray?, I looked at the code and it seems it just assigns indexes. Would I be correct?
16:00:53 <Peaker> mmorrow: the user edits a cell, it knows which other cells need to be updated and resumes their computation as of after the read that read the changed cell
16:01:39 <mmorrow> hmm, ok
16:01:58 <Peaker> mmorrow: I found that very cool, except I didn't like how the computation had to be "flattened out" to a monad sequence, and thus some of the "continuation" code after the read is irrelevant but stil has to be run
16:02:09 <Peaker> mmorrow: it also had some hacks to work around problems that caused
16:02:16 * Peaker needs to re-read it to remember exactly which :)
16:02:30 <mmorrow> do you happen to have a live link to the paper?
16:02:42 <phas> hi, i compiled (seems successfully) yi on macosx but i can get the executable installed. i can't also find it in the "dist" folder
16:03:20 <Peaker> mmorrow: I can't find one either now :(  I am looking
16:03:20 <mmorrow> Peaker: that sounds like an interesting idea
16:03:25 <mmorrow> Peaker: heh
16:04:13 <mmorrow> the mention of spreadsheet makes me think of mdo and/or mfix
16:04:14 <dibblego> ?Type mapM
16:04:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:04:27 <jsnx> ddarius: i realize now that i was confusing objects with types yesterday
16:04:35 <mmorrow> rwbarton pasted a cool example of mdo recently, i'll find it
16:04:36 <Peaker> mmorrow: So I think an arrow makes more sense here, but am not completely sure.  This "effects" function is an exercise to see if I can figure out, according to changes in input of the arrow, which outputs have to be updated
16:04:56 <Peaker> mfix? I don't see how spreadsheets and mfix are related? :)
16:05:19 <mmorrow> because you have to solve a mutually recursive problem
16:05:49 <mmorrow> (for each group of cell that form a strongly-connected-component of the dependency graph)
16:05:56 <mmorrow> cell*s*
16:06:49 <mmorrow> Cale had some function he was talking about where he gave "solving a spreadsheet" as an example
16:06:52 <mmorrow> :t loeb
16:06:54 <lambdabot> Not in scope: `loeb'
16:07:00 <mmorrow> ah, it's gone
16:07:41 <SamB> mmorrow: spreadsheets are allowed to have mutual recursion since when???
16:08:24 <mmorrow> well, their depency graphs have nontrivial sccs (i think? or something along these lines?)
16:08:55 <gigamonkey> Does anyone know of any Go software written in Haskell? (Go is annoyingly hard to Google)
16:09:13 <SamB> er, I don't think I've EVER seen a spreedsheet with cyclic dependencies
16:09:19 <vixey> @w80 gokuban
16:09:20 <lambdabot> No match for "gokuban".
16:09:24 <SamB> and have no clue what the semantics of such a thing would be
16:09:30 <mmorrow> hmm, then i don't know how to express the situation then
16:09:42 <vixey> Go isn't short for something else ...?
16:10:12 <gigamonkey> vixey: Not that I know of. There are of course other names for the game in other languages.
16:10:31 <ziman> lazy spredsheets? :)
16:10:50 <ziman> that'd be cool :)
16:10:53 <gigamonkey> Actually, never mind Go; how about any board game implemented in Haskell?
16:10:55 <SamB> reminds me of the old haskell enron joke...
16:10:57 <ziman> *a
16:11:04 <Peaker> mmorrow: What happens in Excel when you have cyclic dependencies?
16:11:44 <Peaker> gigamonkey: by "game implemented" do you mean an AI or a UI that allows playing?
16:11:50 <mmorrow> SamB: ok, you're right. not mutual dependency, but you have to "find the intial (wrt dependency) cell(s) given a cell that's been changed, then propogate the recalcuation forward back through the dependency graph"
16:12:12 <kryptiskt> gigamonkey: it's even worse than that, there's a composition called "A Game of Go" by Haskell Small :-)
16:12:29 <gigamonkey> kryptiskt: Yeah. Saw that.
16:12:40 <SamB> we must force him to change his name to Perl
16:12:45 <mmorrow> or some variation thereof (i'm not sure the proper graph-lingo way to say that)
16:13:00 <gigamonkey> Peaker: actually I'm more interested in seeing how someone who knows what they're doing would represent the state of a board game.
16:13:18 <kryptiskt> We should encourage him to write music about monads
16:13:22 <SamB> gigamonkey: might depend on the game
16:13:38 <SamB> and the application
16:13:39 <gigamonkey> SamB: okay. So Go is what I actually care about.
16:13:46 <ToRA> anybody know if "any id" has an alias in the prelude?
16:14:09 <SamB> well, you won't be fitting an entire go board into registers I guess
16:14:28 <mmorrow> gigamonkey: chess guy made a (large) class that provided him all the info he needed to write his logic, thus avoiding actually having to work out a particular representation ahead of time
16:14:39 <mmorrow> (i vaguely remember)
16:14:40 <gigamonkey> I'm mostly interested in implementing an engine that groks the rules of go so can accept moves and give you the new state of the board or an indication that it's an illegal move.
16:14:57 <SamB> ah. not too demanding ;-)
16:15:00 <vixey> @src all
16:15:00 <lambdabot> all p =  and . map p
16:15:00 <tchakkazulu> ToRA: "any id" is called "or". ("all id" is called "and").
16:15:10 <Peaker> I think the AI for go is rather different from AI's for most other board games
16:15:15 <Peaker> (if it is to be effective)
16:15:33 <kryptiskt> They have artificial stupidity in Go
16:15:35 <gigamonkey> Yeah, I'm not worried about the AI part. (I've got my own demented ideas on that front.)
16:16:08 <gigamonkey> Mostly I'm just trying to wrap my head around the functional approach to something that (to me) screams "stateful"
16:17:04 <Peaker> gigamonkey: functional programs represent state, it just tends not to be changed "in-place":)
16:17:09 <Botje> @pl (\e _ -> e + 1)
16:17:09 <lambdabot> const . (1 +)
16:17:14 <Botje> yay
16:17:19 <Botje> another correct @pl guess
16:18:00 <gigamonkey> Right. But I care about efficiency too and since the state of a Go board tends to change in small increments it seems a pity to do the naive thing of copying large chunks of state to make a representation of the new state.
16:19:01 <roconnor> diffarray?
16:19:07 <kryptiskt> I wouldn't worry about that, just make something that works with an array and optimize later.
16:19:42 <gigamonkey> Basically it seems like checking color stone (if any) is at a particular point should be O(1) and adding or removing stones from the board should be O(N) in the number of stones.
16:19:49 <blakkino> gigamonkey, if you dislike the idea of having multiple copies of the same data you can use a monad :)
16:19:51 <Cale> go is short for igo
16:19:53 <Peaker> gigamonkey: I think that the AI would need to look at the board so many times that at extra (lazy) copy of it should not be so bad
16:20:00 <gigamonkey> kryptiskt: but the question I care about is how I would do the optimization.
16:20:06 <Cale> 囲碁
16:20:12 <hpaste>  morrow pasted "ghc/compiler/cmm/DataFlow.hs" at http://hpaste.org/8722
16:20:27 <Peaker> gigamonkey: do you iterate positions and look if they have stones or do you look for stones around a position?
16:20:30 <gigamonkey> blakkino: I thought of that. Would that actually be considered a rightous use of a monad?
16:20:38 <mmorrow> Peaker: i found this gem of a module in ghc while perusing
16:20:48 <Cale> The Kanji for surrounding is so appropriate there :) Almost looks like a very small goban :)
16:20:48 <SamB> gigamonkey: hmm? how much state does go have?
16:20:52 <mmorrow> i think it's directly related to what you're trying to do
16:20:56 <gigamonkey> Peaker: the latter, I think.
16:21:10 <gigamonkey> SamB: 19x19 board with three possible states at each position.
16:21:15 <SamB> hmm.
16:21:15 <vixey> hehe
16:21:18 <gigamonkey> i.e. 19x19x3 bits.
16:21:30 <gigamonkey> In it's most compressed form.
16:21:38 <SamB> that's just too many possible states to be an easy application of UArray :-(
16:21:39 <roconnor> 19*19*logBase 2 3 bits
16:21:48 <mmorrow> Peaker: that module is also *self-contained* and only uses the Prelude
16:21:48 <Peaker> gigamonkey: then O(1) pos->stone is not the lookup you want, and perhaps a simple array mapping positions to stones is not the best data structure.
16:22:07 <SamB> roconnor: it's usually more efficient to just give up that last fraction of a bit
16:22:14 <Peaker> mmorrow: which is it?
16:22:18 <roconnor> 19*19*2 bits
16:22:32 <gigamonkey> roconnor: right.
16:22:41 <Peaker> > 19*19*logBase 2 3
16:22:42 <lambdabot>  572.1714627603375
16:22:47 <gigamonkey> Peaker: maybe I misunderstood your two alternatives. Anyway, I know that asking, what's at this position is an extremely common op.
16:23:15 <SamB> unfortunately there is no IArray UArray Word4 instance  :-(
16:23:17 <blakkino> gigamonkey, i don't know really :) it seem to me yes
16:23:37 <blakkino> if you want to explicitly express the idea of "don't copy that state" then you should use a monad
16:23:57 <Peaker> gigamonkey: if you can use a binary search tree to map positions to stones, then you get O(logN) lookup and O(logN) addition to the board.  Then you can use "naive" looking copies, which will not copy much of the tree
16:23:58 <blakkino> (or somethings similar)
16:24:11 <Peaker> gigamonkey: these naive copies make implementing "undo" trivial :)
16:24:32 <Cale> (and efficient!)
16:24:45 <Peaker> gigamonkey: that's how I represent a chess board in a chess UI I wrote: a Data.Map.Map of positions to pieces
16:25:25 <blakkino> ... and i was writing an hex prog.. hex being the stupid cousin of Go,, :)
16:26:18 <mmorrow> Peaker: uh...
16:26:23 <mmorrow> http://hpaste.org/8722
16:26:46 <grahamhutton> I'm not sure if it's OK to post job adverts here, but here goes anyway...
16:26:46 <Peaker> mmorrow: I haven't given a lot of deep thought to my idea, btw, so I am not at all sure that what I wrote is applicable, but it was an interesting exercise at the worst :)
16:27:08 <solrize_> go for it grahamhutton :)
16:27:23 <gigamonkey> Peaker: was that for a UI for a human too play with?
16:27:26 <grahamhutton> We are currently advertising a new Lectureship in Functional Programming: http://jobs.nottingham.ac.uk/CJ24461S
16:27:27 <lambdabot> Title: CJ24461S Lecturer in Computer Science - Vacancies - Human Resources Department - ...
16:27:32 <mmorrow> Peaker: it is interesting. now you've got me thinking about how to solve a spreadsheet ;)
16:27:39 <Peaker> gigamonkey: for human vs human
16:27:40 <ddarius> gigamonkey: A DiffArray would be appropriate, but I'd probably just use a Map and call it a day or perhaps multiple representations for different aspects.  Or maybe just a mutable array.  It depends on what I'm doing.
16:27:49 <grahamhutton> Haskell folks are of course very welcome to apply!
16:27:50 <RayNbow> <dons> cool stuff, http://www.reddit.com/info/6qah5/comments/ <-- reddit definitely needs a "Subscribe" feature like YouTube :p
16:27:51 <lambdabot> Title: reddit.com: Lost and found: tracing a Haskell puzzle
16:27:53 <Peaker> @hoogle DiffArray
16:27:53 <lambdabot> Data.Array.Diff.DiffArray :: type DiffArray
16:27:53 <lambdabot> Data.Array.Diff.IOToDiffArray :: data IOToDiffArray a i e
16:27:53 <lambdabot> Data.Array.Diff.newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
16:27:54 <gigamonkey> Yeah. For something like that I wouldn't be worrying about micro efficiencies.
16:28:07 <vixey> grahamhutton: "Candidates must hold a PhD or equivalent" :(
16:28:12 <Peaker> What's a DiffArray?
16:28:14 <vixey> I guess that I wont be doing it then
16:28:28 <grahamhutton> Vixey: yes, this is a prerequisite --- it's an academic position.
16:28:42 <gigamonkey> I'm (in theory) writing this for a genetic programming system so the faster the engine runs the more generations of evolution I get.
16:29:04 <gigamonkey> grahamhutton: so what's equivalent to a Ph.D.?
16:29:07 <solrize_> simon pj would be "equivalent" then :)
16:29:24 <grahamhutton> But I thought I'd mention it here as there are not too many lectureships (assistant professorships) in FP out there :-)
16:29:31 <vixey> grahamhutton: I am kind of wondering, It's possible to get a PhD or equivalent by studying functional programmer and simiar in notts, I wonder if that would be a good idea?
16:29:36 <Peaker> mmorrow: looks interesting, a bit over my head there though.. Probably relevant to arrow loop support
16:29:52 <vixey> programming or*
16:30:00 <grahamhutton> gigamonkey: this would be an established record of research publications, for example.
16:30:09 <SamB> edwinb: have you discovered the importance of setoids yet?
16:30:11 <gigamonkey> ah.
16:30:44 <grahamhutton> vixey: we have more than 10 PhD students in FP here in Nottingham.
16:30:56 <SamB> grahamhutton: so something like what SPJ has
16:31:19 <grahamhutton> yes, indeed, --- SPJ is an extreme example of someone who doesn't have a PhD!
16:31:27 <SamB> they say he has no PhD only because he doesn't want to be known as Dr. Jones ;-)
16:31:39 <grahamhutton> Prof Jones :-)
16:31:44 <SamB> oh, was that it?
16:32:02 <solrize_> bob floyd also
16:32:05 <SamB> certainly seems qualified enough
16:32:27 <Peaker> I think what separates a PhD from the vast majority of Haskell programmers is just a lot of time-wasting uninteresting problem-solving..
16:32:41 <grahamhutton> anyway, I thought I'd mention that there was an explicit FP opportunity for anyone that may be interested in applying.
16:33:17 <roconnor> Peaker: if only more people got PhD, they could avoid all that time-wasting.
16:33:18 <SamB> Peaker: and writing papers
16:33:28 <grahamhutton> Peaker: wasting time isn't the point of a PhD at all -- it's much more interesting than that!
16:33:43 <joey__> grahamhutton: I take it you can't wait 4/5 years before filling the placement? :)
16:34:04 <grahamhutton> hi joey --- no, but there will be more positions in the future; we are expanding!
16:34:07 <roconnor> I'm pretty sure Peaker means that people who don't get a PhD waist their time rewriting the same code over and over again and fail to see the abstractions.
16:34:10 <Peaker> roconnor: my point is that it is not a very strong "signal" of intelligence, skill, or ability to solve interesting problems
16:34:19 <SamB> er.
16:34:25 <augustss> Peaker: thanks for reminding me to blog :)
16:34:37 <SamB> edwinb: hmm, I actually meant to ask that question of edwardk but he's missing...
16:34:37 <roconnor> and solving the same uninteresting problems over and over again
16:34:47 <Peaker> augustss: sure :) Checking the blog now..
16:35:02 <vixey> SamB: edwinb will probably know a thing or two about setoids....
16:35:06 <SamB> roconnor: you're being overly optimistic ;-)
16:35:44 <grahamhutton> roconnor --- sorry, i misread the previous comment; indeed a PhD avoids lots of time wasting in the end..
16:35:55 <roconnor> SamB: are people without PhDs even worse than I think?
16:35:58 <SamB> vixey: yes but I was hoping for someone who would have some ideas how to get Cont to work in a framework where structures are expected to work with arbitrary setoids
16:36:11 <mmorrow> Peaker: i don't think it's over your head at all. it's just a foldr with scary comments :)
16:36:18 <SamB> roconnor: no, about what Peaker meant
16:36:32 <roconnor> SamB :)
16:36:41 <vixey> grahamhutton: Is there people still working on Epigram there ?
16:36:46 <SamB> roconnor: and we were talking about Haskell users
16:36:48 <qwr> how PhD avoids time wasting?
16:36:59 <SamB> Haskell users generally try to find the abstractions regardless of PhD status
16:37:14 <roconnor> if you have a PhD, you can invent applicative functors, for example.
16:37:17 <grahamhutton> vixey: yes, but there is also a considerable agda presence now too.
16:37:17 <SamB> ... the PhDs may or may not have an edge
16:37:22 <solrize_> hey grahamhutton how difficult would it be for a programmer who has been out of school for a while to enter a ph.d. program?
16:37:24 <Peaker> mmorrow: I meant that in the sense of not even knowing what the terminology means, so having to read some before being capable of understanding that :)
16:37:32 <grahamhutton> sl
16:37:44 <kryptiskt> people who thinks getting a phd wastes time should try being a corporate drone like me :-)
16:37:54 <solrize_> kryptiskt :)
16:38:10 <augustss> kryptonit
16:38:14 <koninkje> How good is GHC about specializing functions instead of doing dictionary passing when -O2 is turned on, i.e. under what conditions does it fail?
16:38:17 <SamB> kryptiskt: those obviously waste more time
16:38:34 <mmorrow> Peaker: do what i do....skip the part you're like "wtf!@" on and pretend it made sense, because it surely will at *some* point in the future (heh)
16:38:34 <SamB> the trouble is that they don't put "corporate drone" in the job description
16:38:36 <SamB> EVER
16:38:58 <grahamhutton> oops.  solrize_: the main prerequisite for a PhD is a good first degree, and some kind of evidence of interest in the subject (such as a good project completed in the area).
16:39:07 <mmorrow> Peaker: interestingly, that strategy mirrors the exact problem we're thinking about
16:39:51 <roconnor> koninkje: SPECIALIZE pragmas can help
16:39:55 <grahamhutton> solrize_ all sorts of different kinds of people make great PhD students; there is no "standard path".
16:40:31 <solrize_> grahamhutton thanks, that makes sense
16:40:46 <grahamhutton> solrize_ i know of quite a few instances of people returning after a period in industry who make great PhD students.
16:41:29 <gigamonkey> grahamhutton: have you seen this paper http://www.cs.cmu.edu/~harchol/gradschooltalk.pdf ?
16:42:05 <gigamonkey> If so, do you have an opinion about it?
16:42:14 <koninkje> roconnor: I'm wondering in part because I'd like to use more restrictive classes in my type signatures, but the functions only really require a prerequisite class (i.e. class A t => B t... ; f :: B t =>... where f only uses methods from A)
16:42:26 <gigamonkey> solrize_: you might want to look at it if you're considering a Ph.D.
16:42:33 <solrize_> looking
16:42:52 <gigamonkey> It seemed to make good sense to me. (Though it mostly convinced me that I don't want to do it. ;-))
16:43:00 <solrize_> i asked the question on general principles, it's probably not a wise idea for me personally
16:43:24 <roconnor> koninkje: presumably unused dictionaries are optimized away. ... Not entirely sure.
16:43:32 <grahamhutton> gigamonkey: no, i haven't seen this one, but there are a number of such things around.
16:43:44 <solrize_> how competitive are these programs to get into?
16:44:38 <gigamonkey> Peaker: maybe the trick for me would be to use something like your Data.Map.Map solution for the engine itself and then provide a function the spits out an array for my genetic algorithm critters to deal with since they're the ones who really need O(1) lookups.
16:45:01 <gigamonkey> grahamhutton: any that you think are particularly worthwhile?
16:45:16 <Peaker> gigamonkey: if you have a "static board" for a significant while then generating an array for it sounds like a good idea
16:45:28 <grahamhutton> solrize_ it depends upon where you apply; if you apply to a leading place it will be very competative and essentially a buyers marker, but there are lots of opportunities in the market.
16:45:32 <roconnor> gigamonkey: have you considered DiffArrays yet?
16:45:45 <saadahmad> Sorry about bumping in, but are the standard arrays lazy?
16:45:46 <solrize_> nottingham is a leading place, i presume :)
16:45:54 <gigamonkey> roconnor: a bit. That's still not O(1) though, right.
16:46:30 <roconnor> gigamonkey: it's O(1) for the most recent update.
16:46:34 <gigamonkey> Oh, sorry. Right.
16:46:39 <gigamonkey> it's updates that are slower, right?
16:46:49 <roconnor> updates are O(1)
16:47:05 <gigamonkey> Uh, something has to be slower, no?
16:47:05 <grahamhutton> gigamonkey: a like "a phd is not enough", but this is about a career in science once you have a PhD.  it contains all sorts of really useful advice about the kind of things that people who have successful careers in science do.
16:47:29 <roconnor> accessing an old copy is O(m) where m is the number of updates since then.
16:48:01 <kpreid> saadahmad: they are lazy in that each element may be a thunk, but the shape of the array itself is strict
16:48:05 <grahamhutton> http://www.amazon.com/PhD-Not-Enough-Survival-Science/dp/0201626632
16:48:08 <lambdabot> http://tinyurl.com/5uqqnk
16:48:26 <kpreid> saadahmad: that's assuming you mean Data.Array
16:48:34 <saadahmad> kpreid, Yes and Thank you, that was what was puzzling me for a bit :)
16:48:45 <gigamonkey> grahamhutton: Yeah. I think the thing I figured out reading that paper I linked to is I don't really want to be a scientist. I just like thinking about programming and writing about it. Basically I'm a hack. ;-)
16:49:47 <roconnor> gigamonkey: accessing an old copy is O(m) where m is the number of updates since then.
16:50:00 <vixey> it seems like there is a really strong type theory presence in notts
16:50:31 <grahamhutton> anyway, back to the shameless advertsing: anyone interested in an FP lectureship in encouraged to apply to Nottingham: http://jobs.nottingham.ac.uk/CJ24461S
16:50:31 <vixey> is that true /
16:50:32 <lambdabot> Title: CJ24461S Lecturer in Computer Science - Vacancies - Human Resources Department - ...
16:50:35 <grahamhutton> <end of advert>
16:51:01 <roconnor> grahamhutton: can I telecommute :)
16:51:08 <Peaker> augustss: "It's not available because Haskell wants to make our lives difficult, quite the contrary."
16:51:37 <augustss> Hmmmm
16:52:21 <solrize_> i'm interested but i don't have any cs degrees and am still trying to figure out haskell ;-)
16:52:48 <Peaker> augustss: missing a negation somewhere in there
16:52:57 <augustss> Not anymore
16:54:26 <grahamhutton> vixey: yes
16:55:05 <augustss> nottingham is the new hotbed for FP
16:55:33 <augustss> well, not that new
16:55:41 <solrize_> does anyone use types to prove complexity assertions?
16:55:49 <kryptiskt> then they should get their own haskell compiler
16:56:34 <augustss> solrize: yes, in nottingham :)
16:56:37 <grahamhutton> augustss: we've been at it for 15 years :-)
16:56:53 <newsham> ?pl tingham -> n
16:56:53 <lambdabot> (line 1, column 9):
16:56:53 <lambdabot> unexpected ">" or "-"
16:56:53 <lambdabot> expecting variable, "(", operator or end of input
16:57:01 <newsham> ?djinn tingham -> n
16:57:01 <lambdabot> -- f cannot be realized.
16:57:26 <augustss> grahamhutton: yes, but in the last few year you've gain a lot of momentum
16:58:47 <augustss> solrize: check the second paper: http://www.cs.nott.ac.uk/~nad/publications/
16:58:48 <lambdabot> Title: Publications and Talks
16:58:59 <solrize_> augustss looking
16:59:05 <Peaker> augustss: why is it not nice to have a separate showAsExp?
16:59:19 <Peaker> augustss: I think its nicer than overloading the Show class for that
16:59:25 <solrize_> nice
16:59:33 <augustss> Peaker: then you can have it :)
16:59:54 <augustss> Peaker: I just liked this better today
17:00:10 <augustss> because it's a gruesome hack
17:02:03 <solrize_> augustss this paper is cool, thanks
17:02:04 <Peaker> augustss: cool post! could be so much nicer to debug stuff with these :)
17:02:10 <Peaker> augustss: reminds me of Subtext
17:02:44 <augustss> Subtext?
17:03:12 <Ben`> does Haskell have a Rails-like web framework?
17:03:30 <newsham> http://www.subtextual.org/
17:03:31 <lambdabot> Title: Subtext home
17:03:39 <Peaker> augustss: www.subtextual.org -- a UI that edits code in a functional language while the code is running.. he can "Expand" subtrees of the computation showing things like the trace result
17:03:58 <vixey> grahamhutton: (sorry for bombarding you with so many questions), Agda isn't used by students is it.. just people working on projects ? I think they teach an intro to Coq as well but what is there much kind of thing relating to dependent types/type theory that someone could start there?
17:04:19 <Peaker> augustss: he reinvented monads in there (Only he doesn't have a typeclass for them, only the IO monad specifically), but doesn't know it :-)
17:04:54 <augustss> interesting
17:05:02 <newsham> the world needs a few type theory video lectures
17:05:12 <newsham> i wish universities releasing video lectures was more widespread
17:05:25 <grahamhutton> vixey: we don't teach agda to undergrad students yet, but we do teach a couple of courses using Coq (a first year discrete maths course, and a final year option on computer assisted reasoning)
17:05:30 <ddarius> newsham: If I had a blackboard I could make some (probably relatively poor) ones.
17:05:42 <Peaker> he has a really cool visualization of the IO monad. The current state is shown normally, and IO actions look like functions that show their "RealWorld" output, which can be expanded to show hypothetical futures (with a different color to denote they are hypothetical)
17:06:02 <solrize_> ben` look at www.happs.org
17:06:05 <newsham> ddarius: i think a full semester course would be ideal.  one or two video sessions would be nice, but the depth of a whole semester is better.
17:06:09 <grahamhutton> newsham: we are planning some youtube videos on interesting topics in FP.  watch this space...
17:06:19 <vixey> if something is final year it means that one couldn't just sign up and do that without several years of doing something else ?
17:06:30 <newsham> MIT has some great video lectures, unfort i havent seen any on type theory
17:06:53 <grahamhutton> most university courses are restricted to registered students
17:06:57 <Ben`> solrize_: thanks
17:07:16 <vixey> hmm
17:07:19 <newsham> i really really wish there were videos for http://www.cse.unsw.edu.au/~cs4181/
17:07:20 <lambdabot> Title: COMP4181/9181: Language-based Software Safety
17:07:29 <grahamhutton> but the odd gatecrasher doesn't cause any problems...
17:07:30 <newsham> the topics they posted online are awesome
17:07:41 <solrize_> there's a video about twelf on bayfp.org
17:08:14 <newsham> (notably slides and references here: https://cgi.cse.unsw.edu.au/~cs4181/07s2/cgi-bin/moin.cgi/Schedule)
17:08:17 <lambdabot> http://tinyurl.com/2kt7qz
17:12:13 <Peaker> all the links to at least some of ICFP2002's papers are broken
17:12:17 <solrize_> is agda more difficult to use than coq?
17:12:32 <vixey> solrize: they are totally different
17:12:45 <lxuser> solrize_, arguably so
17:12:54 <vixey> solrize: ...I don't think anyones proved the fundamental theorem of calculus in Agda
17:13:00 <solrize_> hee
17:13:36 <solrize_> the "power of pi" paper made it look easy to write certain types of parsers in agda
17:14:12 <augustss> solrize_: which is easier depends on what you want to do, i'd say
17:14:27 <solrize_> does agda have haskell code extraction like coq does?
17:14:34 <augustss> kinda
17:14:35 <vixey> yeah it does
17:14:39 <solrize_> cool
17:14:44 <newsham> solrize: coq will do some of the work for you automatically.  agda requires you to write your programs/proofs line by line as you would in haskell
17:15:14 <lxuser> solrize_, agda gets more attention from programmers, but this will change since Coq has recently added some programming-specific features.
17:15:45 <vixey> to put it simply, its' really hard to prove programs correct.. whatever you use :)
17:16:39 <newsham> its only hard if you define correct precisely
17:16:47 <newsham> ;-)
17:18:07 <asdftimo> @powMod
17:18:07 <lambdabot> Unknown command, try @list
17:18:13 <asdftimo> @hoggle powMod
17:18:14 <lambdabot> No matches found
17:18:17 <lxuser> vixey, all well-typed programs are "correct" in a sense. things get harder as type systems become more and more expressive
17:19:09 <vixey> lxuser: I've got a McBride quote.. "Find the type error in if null xs then head xs else []"
17:22:57 <roconnor> vixey: found it
17:23:14 * EvilTerran too
17:23:17 <vixey> what did you find ?
17:23:24 <roconnor> the type error
17:23:31 <vixey> :t \xs -> if null xs then head xs else []
17:23:33 <lambdabot> forall a. [[a]] -> [a]
17:24:00 <roconnor> -> head <- this isn't well typed
17:24:05 <vixey> the point is that it's well typed but clearly broken
17:24:46 <roconnor> @src head
17:24:47 <lambdabot> head (x:_) = x
17:24:47 <lambdabot> head []    = undefined
17:25:00 <roconnor> -> undefined <- this isn't well typed
17:25:06 <vixey> yes it is
17:25:18 <roconnor> it shouldn't be
17:25:24 <vixey> yes it should be
17:25:27 <vixey> this is haskell
17:25:33 <roconnor> @src undefined
17:25:33 <lambdabot> undefined =  error "Prelude.undefined"
17:25:47 <roconnor> -> error <- this isn't well typed
17:25:55 <roconnor> @src error
17:25:56 <lambdabot> error s = throw (ErrorCall s)
17:26:10 <roconnor> @type throw
17:26:11 <lambdabot> Not in scope: `throw'
17:26:21 <vixey> throw = turtles all the way down
17:26:23 <roconnor> @type ErrorCall
17:26:24 <lambdabot> Not in scope: data constructor `ErrorCall'
17:26:32 <roconnor> I assume throw isn't well typed
17:26:44 <vixey> throw is an axiom :P
17:26:44 <roconnor> @src throw
17:26:44 <lambdabot> throw exception = raise# exception
17:26:46 <codacola> fun, 9 days until my first haskell class :D
17:26:59 <roconnor> @src raise#
17:26:59 <lambdabot> Source not found. Where did you learn to type?
17:26:59 <EvilTerran> the point is, in a language with a more refined type system, that program would have a type error
17:27:11 <augustss> roconnor: you could have had undefined=undefined
17:27:25 <vixey> EvilTerran: no my point is that a type system doesn't ensure correctness
17:27:28 <EvilTerran> types can be as detailed or relaxed as you like
17:27:38 <roconnor> augustss: if you are going to allow general recursion, why bother have a type system at all? :P
17:27:55 <vixey> EvilTerran: You may encode your definition of corectness into types, very often though
17:28:02 <EvilTerran> vixey, indeed, "well-typed programs do not go wrong" only applies for a very strict definition of "go wrong"
17:28:13 <augustss> roconnor: yeah, types are just a nuisance
17:28:23 <vixey> they certainly don't go wrong, but that doesn't prove that  f . f' = id
17:28:41 <EvilTerran> as in, excluding accessing the head of an empty list, dividing by zero, falling through a pattern-match...
17:28:46 <roconnor> augustss: why not throw side-effects into functions while we are at it?
17:28:52 <vixey> or that the meaning of some code is equal to the meaning of the compiled code
17:29:33 <vixey> it's hard to prove these things about C programs just as it is hard to prove it about dependently typed programs
17:30:32 <vixey> (maybe I should have picked scheme instead of C, since C is sort of half-typed)
17:31:49 <roconnor> we have relegated side effects to the IO monad.  I don't see why we shouldn't relegate non-terminaton to there as well.
17:32:14 <vixey> I do roconnor
17:32:17 <augustss> roconnor: i think it should be a different monad.  there's too much in IO already
17:32:32 <vixey> code written in that style is not nice
17:32:39 <roconnor> well, IO needs to be carved up in any case.
17:32:47 <vixey> instead of f x + f y
17:33:00 <vixey> you must write,  do fx <- f x ; fy <- f y ; fx + fy
17:33:03 <vixey> or something like this..
17:33:08 <augustss> vixey: that's not true
17:33:24 <roconnor> vixey: you can write iI f x + f y Ii
17:33:29 <EvilTerran> roconnor, total languages have something like that
17:33:40 <roconnor> EvilTerran: yep
17:33:46 <augustss> vixey: you just need to design your language right
17:33:58 <lxuser> roconnor, does that mean you'd have to prove non-termination in order to write non-monadic code?
17:34:03 <EvilTerran> where there is/you can write a "non-termination monad"
17:34:13 <vixey> augustss: oh.. so f x + f y would be implicit for that do block?
17:34:14 <EvilTerran> lxuser, yes, but that's trivial in most cases
17:34:16 <roconnor> lxuser: more or less
17:34:35 <EvilTerran> lxuser, as in, straightforward structural recursion, or non-recursive functions
17:34:38 <vixey> you probably wouldn't prove nontermination
17:34:42 <roconnor> @go idiom brackets
17:34:43 <lambdabot> http://www.haskell.org/haskellwiki/Idiom_brackets
17:34:43 <lambdabot> Title: Idiom brackets - HaskellWiki
17:34:50 <lxuser>  maybe you could just embed a total-FP language into haskell and get the same guarantees
17:34:55 <EvilTerran> actually, wait
17:35:05 <EvilTerran> you have to prove *termination* to write non-monadic code
17:35:23 <EvilTerran> in haskell, you can't stop folks writing "let x = x in x"
17:35:34 <augustss> vixey: non-termination could be relecate to only show up in the types.  I don't know the right design, but Haskell sure doesn't have it.
17:35:40 <lxuser> EvilTerran, yes of course. sorry
17:35:40 <roconnor> we have to prove side-effect free code to write non-monaic code in Haskell at the moment.
17:36:17 <augustss> s/relecate/relegated/
17:36:28 <ddarius> It's not so much that we have to "prove" it, but rather we can't use side-effecting operations in non-monadic code whether we can prove the overall result would be side-effect free or not.
17:36:43 <ddarius> You could easily do the same for a "NonTermination" monad.
17:36:53 <roconnor> of course without a reasonable type system, we'd have to make use of unsafeFixpoint at times.
17:36:53 <ddarius> Simply give fix a type in that monad.
17:37:23 <vixey> proofs on paper or in your head are still meaningful
17:38:27 <vixey> just shoving everything into the typesystem because it's possible doesn't seem worthwhile to me
17:38:53 <Peaker> vixey: isn't it nice to be able to ship it once it compiles? :)
17:39:56 <vixey> I'm not sure
17:40:19 <newsham> ?type StreamArrow
17:40:20 <lambdabot> Not in scope: data constructor `StreamArrow'
17:40:53 <dmwit> Peaker: I found several bugs today (in code that passed the type-checker).
17:40:58 <vixey> Peaker: I want to be sure that $program does exactly what I think it does, I don't care if the compiler tells me that or something else
17:40:59 <dmwit> Just sayin'.
17:41:26 <Peaker> dmwit: yeah, but would these bugs exist if you had dependent types and proved the program correct?
17:41:48 <dmwit> I couldn't possibly say, having never used dependent types before.
17:41:54 <vixey> whether you had dependent types or not, if you proved the program correct there are no bugs in it
17:42:05 <dmwit> But I doubt that it could slip past a proof of correctness.
17:42:07 <roconnor> the answer is, Yes, dependent types can prove that.
17:42:09 <newsham> depends on your defintion of "correct"
17:42:12 <Kinks> dependant types makes it a tad easier.
17:42:13 <dmwit> ...as vixey points out. =)
17:42:14 <Peaker> vixey: if you proved it without dependent types, you may have had a mistake in your proof
17:42:18 <vixey> roconnor: lol :D
17:42:29 <vixey> Peaker: likewise with dependent types
17:42:29 <Peaker> vixey: and you have no practical way to maintain the proof's correctness as the program changes
17:42:43 <newsham> dmwit wrote some code that was proven to be correct according to the specifications of hte types
17:42:51 <Peaker> vixey: how can you have an error in a proof that is verified?
17:42:51 <newsham> but had bugs according to his notion of correctness
17:43:02 <lxuser> Peaker, proving programs correct is still >hard< and not worth it for most applications.  dependent types just make it slightly easier than using mainstream formal methods
17:43:13 <newsham> you could use similar types in a dependently typed system and get similar results
17:43:16 <vixey> Peaker: if my proof is machine checkable, I might have a bogus statement of correctness, used a dodgy dependent typed formalism, bugs can creep in anywhere
17:43:17 <kryptiskt> peaker: a bug in the type definitions+
17:43:19 <augustss> but just because you've proved a program correct (by any means) doesn't mean it does what it was intended to do
17:43:41 <Peaker> lxuser: ok - still not a worthless feature.  Also, maybe with some nice heuristics and a UI, proving correctness can become easier
17:44:11 <Peaker> vixey: if your specification is wrong, you're screwed anyhow. But at least with d-types, your proof isn't wrong
17:44:28 <Peaker> kryptiskt: that's an error in the specifications, not in the proof
17:44:35 <newsham> dependently typed system gives you the opportunity to be more detailed in your statements, but it doesnt require you to be omre precise
17:44:36 <Kinks> as I said, it makes it easier - it doesn't do everything for you.
17:45:06 <vixey> hmm
17:45:09 <kryptiskt> no, it might be a bug in your mapping from spec to type defs
17:45:11 <Kinks> "my program will never crash" does not say "my program will do what you expect it to", however you can take advantage of typing to also prove it will do what you expect it to do
17:45:18 <Kinks> with a much smaller margin for error
17:45:24 <lxuser> Peaker, we're going to find out soon. coq already provides the nice heuristics part, and they're working on  programming-language support
17:45:54 <vixey> a good UI too (proof general)
17:45:57 <newsham> if all your specification says is that  Int -> Int -> Int,  then both (+) and (*) are correct.
17:46:00 <ddarius> The hard part is usually going from informal to formal.  Formal methods can only help so much with that.
17:46:03 <newsham> using dependent types doesnt fix that
17:46:16 <vixey> newsham: My specification is that it *adds numbers*
17:46:26 <vixey> newsham: But you don't have to write that in the type system
17:46:46 <newsham> vixey: sure, but if you dont write it in the type system, then its proof isnt checked for you
17:47:20 <newsham> using agda, for example, doesnt change that.
17:47:28 <newsham> you can still underspecify
17:47:34 <Peaker> vixey: If you're going to encode that information anyhow (comments, names, etc), why not encode it in a uniform way as a type?
17:47:40 <vixey> it's the same issue with all semantics.. the meaning you know is not the same as the object/list of symbols you use to portray it
17:47:45 <ddarius> you can still -mis-specify
17:49:50 <newsham> anyone familiar with arrow transformers?
17:50:06 <saml> not i
17:50:15 <newsham> if you have an arrow like (->)  how do you make a StreamArrow (->)   out of it?
17:50:16 <lxuser> ddarius, yes, but a spec is vastly less complex than the corresponding program, so it's much easier to debug informally
17:54:15 <ddarius> lxuser: It depends.
17:56:39 <povman> has anyone thought about implementing concurrency with arrows?
17:56:50 <ddarius> povman: Why would one?
17:57:13 <povman> just a hunch
17:57:34 <povman> well they can represent a sequence of things that splits into two
17:58:35 <ddarius> povman: I don't think the question you actually asked is the question you wanted to ask.
17:58:44 <povman> likely
17:59:23 <povman> maybe i meant 'use arrows as an abstraction for concurrency'
17:59:51 <roconnor> @type (.)(.)
17:59:52 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
18:00:06 <roconnor> @type (Prelude..)(Prelude..)
18:00:07 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
18:00:14 <ddarius> povman: What do you expect/think you'd gain by doing so?
18:00:33 <povman> forkIO doesn't feel haskelly enough
18:00:46 <povman> no other real reason
18:01:53 <lxuser> povman, arrows _have_been used to abstract non-deterministic parallel computations. wikipedia provides some refs
18:04:47 <Cale> roconnor: heh, I actually think it might be easier to understand that in terms of fmap fmap :)
18:04:59 <Saizan> Peaker: pong
18:08:26 <roconnor> has anyone used MonadUndo?
18:13:18 <dolio> What's it do? State with automatic history?
18:27:26 <idnar> (a:[b]) is the same as [a, b] right?
18:28:30 <mar77a> > a:[b] == [a,b]
18:28:32 <lambdabot>  True
18:28:55 <vixey> yes
18:30:05 <idnar> @check \(a, b) -> a:[b] == [a,b]
18:30:07 <lambdabot>  OK, passed 500 tests.
18:30:32 <idnar> hmm
18:30:35 <idnar> @type \(a, b) -> a:[b] == [a,b]
18:30:36 <lambdabot> forall t. (Eq t) => (t, t) -> Bool
18:30:38 <ddarius> > a:[b]
18:30:39 <lambdabot>  [a,b]
18:31:00 <idnar> what does quickcheck generate for a function typed like that?
18:31:02 <ddarius> [a,b] is syntactic sugar for a:b:[].
18:31:42 <idnar> what I'm really wondering is why this code uses the "blah:[bleh]" form
18:31:53 <idnar> it seems a bit odd
18:31:54 <ddarius> idnar: Which code?
18:31:54 <Saizan> @type \a b -> a == b
18:31:55 <lambdabot> forall a. (Eq a) => a -> a -> Bool
18:31:59 <ddarius> idnar: It is a bit odd.
18:32:05 <idnar> the definition of simpleEscapes at http://farm1.static.flickr.com/250/452679328_ad5e1b98b0_o.gif
18:32:08 <idnar> er
18:32:10 <idnar> no, at http://book.realworldhaskell.org/beta/library.html
18:32:12 <lambdabot> Title: Chapter 6. Writing a library: working with JSON data
18:33:36 <dolio> In that case, it will default to '((), ()) -> Bool', so quickcheck just generates ()s.
18:33:54 <idnar> ah
18:44:19 <dolio> Wow, the quickcheck properties for uvector use incoherent instances.
19:02:58 <dmwit> Oh, and by the way, Americans: Happy 4th!
19:09:27 <lxuser> dmwit: support our civilians
19:30:10 <allbery_b> http://d33ann.livejournal.com/520127.html?thread=1383871#t1383871 (re ID4)
19:32:52 <dolio> We just have to send a virus to the alien mothership! I'll upload it with my mac.
19:37:44 <Korollary> By 'sending a virus' you mean pwning the alien computer.
19:38:05 <Korollary> Sending a virus seems a bit indirect.
19:38:19 <dolio> I didn't write the movie.
19:38:20 <jsnx> we need to send them a trojan
19:38:35 <dmwit> What, are they having unsafe sex?
19:38:38 <Korollary> I am fully aware that there are no screenwriters here
19:38:45 <jsnx> well, we should send lots
19:38:52 <allbery_b> would aliens know what to do with a human-form condom?
19:38:59 <jsnx> to break down their morality and end the jihad
19:39:05 <dmwit> allbery_b: It goes on the tentacles. ;-)
19:39:07 <roconnor> @type \f x -> (=<<) (\g -> liftM g x) f
19:39:08 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m (a1 -> b) -> m a1 -> m b
19:40:20 <dmwit> ?type ap
19:40:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:41:10 <dmwit> :t \m x -> m >>= flip liftM x
19:41:10 <gwern> worms might be more effective
19:41:11 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m (a1 -> r) -> m a1 -> m r
19:41:15 <jsnx> to be euphonious, i ought to have written "... 'n end ..."
19:41:45 <dmwit> :t flip liftM
19:41:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
19:42:37 <dmwit> Okay, yeah, I think it really is ap. =)
19:42:48 <dmwit> ?pl \f x -> (=<<) (\g -> liftM g x) f
19:42:48 <lambdabot> (. flip fmap) . (>>=)
19:43:14 <dolio> It's pretty clearly ap if you just expand it a bit.
19:43:19 <dmwit> yeah
19:43:33 <idnar> @do \f x -> (=<<) (\g -> liftM g x) f
19:43:33 <lambdabot> \f x -> (=<<) (\g -> liftM g x) f not available
19:43:42 <idnar> bah
19:44:23 <dolio> \f x -> f >>= \g -> liftM g x =expand liftM=> \f x -> f >>= \g -> x >>= \a -> return (g x)
19:45:50 <dolio> @pl \f x -> f >>= \g -> x >>= \a -> return (g a)
19:45:51 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
19:46:07 <idnar> heh
19:51:11 <roconnor> I suppose a monad forms an applicative functor in two different ways
19:51:24 <dibblego> why two?
19:51:40 <dibblego> pure = return; <*> = ap; what other way is there?
19:52:19 <roconnor> <*> = liftM2 (flip <$>)
19:52:28 <roconnor> <*> = flip liftM2 (flip <$>)
19:52:38 <roconnor> @type flip liftM2 (flip <$>)
19:52:39 <lambdabot> forall a2 r a b c (f :: * -> *). (Functor f) => (f (b -> a -> c) -> a2 -> r) -> (f (a -> b -> c) -> a2) -> f (a -> b -> c) -> r
19:52:49 <roconnor> @type flip (liftM2 (flip <$>))
19:52:50 <lambdabot> forall a b c a2 (m :: * -> *). (Monad m) => m a2 -> m (a2 -> a -> b -> c) -> m (b -> a -> c)
19:53:00 <roconnor> mm
19:53:08 <roconnor> @type flip (liftM2 (flip ($)))
19:53:09 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
19:53:12 <roconnor> there
19:53:18 <roconnor> <*> = flip (liftM2 (flip ($)))
19:54:38 <dibblego> doesn
19:54:44 <ddarius> Yes, there are two different implementations of liftM2
19:54:45 <dibblego> 't is also need to satisfy 4 laws?
19:55:19 <ddarius> dibblego: That alternative definition should not break any of the laws.
19:55:29 <dibblego> I guess not (thinking)
19:56:14 <idnar> @type ap
19:56:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:56:28 <idnar> @src ap
19:56:28 <lambdabot> ap = liftM2 id
19:57:13 <idnar> @type flip ($)
19:57:14 <lambdabot> forall a b. a -> (a -> b) -> b
19:57:19 <mmorrow> Peaker: ping
19:57:22 <roconnor> I guess any applicative functor yields another applicative functior.
19:57:28 <roconnor> <*> = flip (liftA2 (flip ($)))
19:59:20 <mmorrow> @tell Peaker somewhat related to earlier: http://code.haskell.org/~morrow/code/haskell/misc/SS.hs.html
19:59:21 <lambdabot> Consider it noted.
19:59:27 <newsham> what does 'deriving Monoid' do for the defs?
19:59:28 <dolio> @type flip . liftA2 . flip
19:59:29 <lambdabot> forall (f :: * -> *) a b c. (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
20:00:10 <roconnor> @type flip . liftA2 . flip $ id
20:00:11 <lambdabot> forall (f :: * -> *) b c. (Applicative f) => f (b -> c) -> f b -> f c
20:00:23 <dolio> I doubt you can derive monoid unless it's a newtype (with generalized newtype deriving).
20:00:37 <mmorrow> an amusing "spreadsheet" toy that renders the sheet/cell dep graph to dot/png with graphviz (weee) http://code.haskell.org/~morrow/code/haskell/misc/SS.hs.html
20:01:00 <newsham> newtype a :-> b = Follows { unFollows :: Follow a [b] } deriving Monoid
20:01:32 <dolio> In that case, it uses the monoid instance for Follow a [b].
20:01:56 <mmorrow> i know that derive (the package) derives monoid, but the template is limited
20:02:21 <newsham> hmm..  so conal's blog mentions some more deriving Monoids, but the sampel code in darcs doesnt use them, so I imagine its an expermental feature in some variants?
20:02:47 <dolio> I'm not sure anything but GHC has generalized newtype deriving.
20:02:54 <newsham> err.. hmm. maybe not, these are all simple newtypes
20:02:58 <dmwit> newtypes can derive anything that the wrapped type is an instance of.
20:03:20 <mmorrow> don't forget the "cunning" part!
20:04:16 <dmwit> ?
20:04:39 <mmorrow> there's that one message "...even with cunning newtype deriving...."
20:07:33 <mmorrow> GHC: where the impossible happens every day, even with cunning newtype deriving.
20:08:54 <newsham> in the type system
20:38:43 <wuxia> what does   renderPrimitive Points $ mapM_ (\(x, y, z) -> vertex $ Vertex3 x y z) myPoints  mean, in the contxt of http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/ (in particular, I do not understand $)
20:38:44 <lambdabot> Title: Michis blog  Blog Archive  OpenGL programming in Haskell - a tutorial (part 1 ..., http://tinyurl.com/ea6tc
20:38:58 <kpreid> wuxia: which part of it do you want to know about?
20:39:11 <slava> @src $
20:39:11 <lambdabot> f $ x = f x
20:39:43 <slava> i don't like $ myself, i think it is superfluous syntax sugar, but then i'm not a haskell hacker
20:40:01 <slava> it's just that an extra set of parens don't seem so bad, and with $ you have to think harder to see what's being applied to what
20:40:26 <kpreid> (oh, sorry, I missed where you said what you asked about)
20:40:37 <kpreid> without $ it is:
20:40:48 <kpreid> renderPrimitive Points (mapM_ (\(x, y, z) -> vertex (Vertex3 x y z)) myPoints)
20:40:59 <slava> yup
20:41:26 <kpreid> we could split the mapM_ to separate out the data-structure-conversion part:
20:41:39 <Axman6> can $ only be used with functions that take a single argument?
20:41:43 <kpreid> renderPrimitive Points (mapM_ vertex (map (\(x, y, z) -> Vertex3 x y z)) myPoints)
20:41:50 <slava> all functions take a single argument
20:42:08 <kpreid> > ((+) $ 1) 2
20:42:09 <lambdabot>  3
20:42:27 <slava> gross
20:42:38 <Axman6> yes indeed
20:42:43 <reubenf> re: topic, i am supposed to use hpaste.org rather than codepad?
20:42:55 <ddarius> That use of ($) is completely superfluous
20:42:56 <Axman6> aye
20:42:56 <kpreid> reubenf: no
20:43:00 <ddarius> Also, ($) isn't syntax.
20:43:01 <dmwit> reubenf: Either is fine, but hpaste.org announces your paste here.
20:43:13 <kpreid> ddarius: so it is; I was demonstrating for Axman6
20:43:36 <Axman6> kpreid: if it was clearer, it might help me understand
20:43:40 <slava> ddarius: i'm used to languages where technically nothing is syntax, so i use 'syntax' to mean 'stuff'
20:43:47 <koninkje> @hoogle (...)
20:43:47 <lambdabot> No matches found
20:44:09 <kpreid> slava: I prefer the technical definitions under which it is layered syntax, not no syntax :)
20:44:11 <Kinks> "hoogle"?
20:44:28 <kpreid> Kinks: http://www.haskell.org/hoogle/
20:44:28 <lambdabot> Title: Hoogle
20:44:29 <Kinks> hm, nevermind, heh
20:44:30 <dmwit> ?hoogle (a -> b) -> [a] -> [b]
20:44:30 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
20:44:30 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
20:44:30 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
20:44:33 <ddarius> Also, the rule for ($) is simple.  Everything to the right of $ is being applied to everything to the left (within an expression).
20:44:42 <dmwit> Kinks: It searches for functions by type or name.
20:44:55 <reubenf> okay, so in http://codepad.org/ATgy9ZaY i don't understand how the inferred type of countSuit matches my function definition.    i meant to type countSuit :: [ (Hand, Suit ) ] -> Integer, but made a typo and was surprised it worked
20:44:56 <lambdabot> Title: Haskell code by Skeletor - 25 lines - codepad
20:45:43 <dmwit> reubenf: Well, you've written a tuple as your first pattern match.
20:45:43 <ddarius> reubenf: You're matching on tuples not lists.
20:45:53 <dmwit> reubenf: Why should you be surprised that the type is therefore a tuple-type?
20:46:23 <reubenf> oh.  haha, okay i guess i just got confused re-reading my code
20:46:40 <dmwit> reubenf: Also, it is preferred to write functions without tupling.
20:47:09 <reubenf> i don't know how i would do that
20:47:23 <dmwit> countSuit [(rank, suit)] match | ...
20:47:34 <dmwit> countSuit ((rank, suit):rest) match | ...
20:47:44 <dmwit> Then, to call it, use
20:47:51 <dmwit> countSuit hand Spades
20:48:02 <dmwit> (instead of countSuit(hand, Spades))
20:48:05 <reubenf> oh, alright.  why is that preferred?
20:48:20 <dmwit> There's a couple reasons, but mainly for the beauty of partial application.
20:48:34 <mmorrow> > let f (a,b) = a*b in f (2,8)
20:48:35 <lambdabot>  16
20:48:54 <mmorrow> > let f a b = a*b in map (f 2) [0..10]
20:48:56 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20]
20:48:56 <dmwit> (countSuit hand) would then be a function, so your "hasFlush" function could use
20:49:09 <dmwit> map (countSuit hand) [Spades, Diamonds, Clubs, Hearts]
20:49:23 <dmwit> Which saves you a lot of typing, and saves the reader a lot of thinking. =)
20:49:40 <saadahmad> kpreid, Yes and Thank you, that was what was puzzling me for a bit :)
20:49:49 <saadahmad> Err, sorry about that
20:49:54 <reubenf> i think the reason i did it as a tuple was because i don't understand how you define the type of the function then
20:50:02 <saadahmad> Seems I had that in the buffer and accidently pased it :)
20:50:06 <dmwit> reubenf: Ah!
20:50:11 <mmorrow> :t \(x,y) -> x*y
20:50:12 <lambdabot> forall t. (Num t) => (t, t) -> t
20:50:17 <mmorrow> :t \x y -> x*y
20:50:17 <kpreid>  reubenf: don't define it, ask for it!
20:50:18 <lambdabot> forall a. (Num a) => a -> a -> a
20:50:24 <dmwit> reubenf: countSuit :: Hand -> (Suit -> Integer)
20:50:37 <kpreid> reubenf: ask ghci what the type of your function is, then if you like c&p that back into your code
20:50:42 <reubenf> so it's a function that gives me a Suit -> Integer function?
20:50:44 <dmwit> reubenf: As a bonus, (->) is right-associative, so you can even drop those parentheses.
20:50:47 <dmwit> reubenf: Exactly!
20:50:54 <dmwit> reubenf: Isn't it stupefyingly great?
20:50:59 <reubenf> yes
20:51:01 <reubenf> that is amazing
20:51:05 <reubenf> that syntax baffled me before
20:51:07 <kpreid> reubenf: you might or might not prefer countSuit :: Suit -> (Hand -> Integer)
20:51:22 <reubenf> krepid: ghc does not build on my mac so i am learning exclusively in codepad :/
20:51:35 <dmwit> !
20:51:39 <kpreid> huh
20:51:44 <dmwit> Why not grab one of the binaries?
20:51:47 <kpreid> okay, I had not heard of 'codepad' before yesterday
20:51:53 <mmorrow> reubenf: AWESOME.
20:51:57 <kpreid> and I didn't know until just now that it was an online evaluator...
20:52:01 <mmorrow> reubenf: that's desire.
20:52:36 <reubenf> dmwit: i wasn't able to find binaries for os x
20:52:49 <dmwit> reubenf: haskell.org/ghc has binaries for MacOSX PowerPC and Intel.
20:52:57 <dmwit> reubenf: It's under the "download" link. ;-)
20:53:04 <reubenf> weird that i didn't see it
20:54:00 <reubenf> if this works i will be very happy, sorry to disappoint you mmorrow :)
20:57:06 <dmwit> ?where hackage
20:57:06 <lambdabot> http://hackage.haskell.org/
20:57:57 <proqesi> I'm trying to build ghc and I get an error: "checking for path to top of build tree... c:\mingw\bin\..\lib\gcc\mingw32\3.4.5\..\..\..\..\mingw32\bin\ld.exe: cannot find -lHSrts".  does anyone know of a fix?
20:59:56 <dmwit> Install ld?
21:00:28 <mmorrow> proqesi: why are those slashes the wrong way!??! :)
21:00:30 <dmwit> Also: is it really necessary to build GHC under mingw/at all?
21:00:47 <dmwit> Would a binary suffice?  If so, I strongly recommend it.
21:00:48 <mmorrow> dmwit: i think so
21:00:51 <mmorrow> oh
21:01:43 <ddarius> Dedication would be learning SML with pencil and paper and a copy of the formal semantics.
21:01:45 <proqesi> because it's windows
21:02:04 <dmwit> proqesi: There are binaries for Windows.
21:02:11 <mmorrow> ddarius: speaking from personal experience, i presume.
21:03:01 <ddarius> mmorrow: I don't know SML except insofar as it is similar to most statically typed functional languages.  SML is ugly.
21:03:09 <slava> i like SML
21:03:10 <ddarius> Unfortunately, Haskell doesn't have a formal semantics.
21:03:26 <mmorrow> ddarius: i agree. *ml makes my eyes bleed.
21:03:55 <mmorrow> ddarius: surely you mean the language known as "ghc"
21:04:05 <ddarius> No, I mean Haskell.
21:04:06 <slava> http://images.wikia.com/uncyclopedia/images/a/ad/Longcatlegs.jpg
21:04:07 <mmorrow> (not that haskell *does* have a formal semantics)
21:04:10 <ddarius> Specifically Haskell 98.
21:04:17 <mmorrow> but we do not program in it
21:04:33 <mmorrow> yes, sadly that's the casre
21:04:47 <mmorrow> (wrt H98)
21:05:52 <mmorrow> > foldl (.) id (repeat read) $ fix show
21:05:54 <wuxia_> can anyone pooooint me at good urls to read for $ and $= ? I don't know what they mean, and googling for $ and $= isn't exactlu helpful
21:05:57 <lambdabot>  "
21:06:09 <kpreid> wuxia: $ and $= are completely unrelated
21:06:12 <slava> @src $=
21:06:12 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:06:14 <Zao> @src ($)
21:06:14 <lambdabot> f $ x = f x
21:06:23 <mmorrow> wuxia: where did you see $= ??
21:06:26 <kpreid> wuxia: $= is an assignment operation defined in the GL binding
21:06:31 <mmorrow> ah
21:06:34 <wuxia_> f $ x = f x --> this makes me think it does nothing
21:06:42 <slava> you'd be right
21:06:49 <Axman6> wuxia_: means less prackets
21:06:51 <ddarius> $= is, roughly, a synonym for writeIORef
21:06:51 <slava> but $ has a differnt precedence than
21:06:52 <Zao> wuxia_: It has a different precedence.
21:06:55 <Axman6> brackets*
21:07:14 <ddarius> wuxia_: Another definition for ($) is: ($) = id.
21:07:23 <kpreid> wuxia_: $= can be found in http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html
21:07:24 <lambdabot> Title: Graphics.Rendering.OpenGL.GL.StateVar, http://tinyurl.com/2fcodm
21:07:44 <mmorrow> > let ($) = (flip . flip) id in (*2) $ 8
21:07:46 <lambdabot>  16
21:08:00 <kpreid> ($=) :: s a -> a -> IO ()
21:08:35 <kpreid> given a "variable" and a value it is replacing the value
21:08:37 <proqesi> dmwit: I get this problem when I build other things as well.  In other words, because of this problem I can't build anything
21:09:11 <dmwit> proqesi: Well, do you have ld anywhere?
21:09:21 <dmwit> proqesi: If so, why not make sure that it's in your $PATH?
21:09:29 <dmwit> proqesi: If not, why not figure out how to get it? ;-)
21:09:33 <proqesi> dmwit: yes, that problem is output from ld when ld runs
21:09:58 <newsham> how do you do:  Stream [a] -> Stream a   ?
21:10:03 <dmwit> proqesi: Oh, I misread, sorry.
21:10:04 <newsham> (sort of line concat)
21:10:33 <ddarius> newsham: wtf is Stream?
21:10:43 <newsham> http://hackage.haskell.org/packages/archive/Stream/0.2.3/doc/html/Data-Stream.html
21:10:45 <lambdabot> Title: Data.Stream, http://tinyurl.com/64j2hz
21:10:57 <wuxia_> so, in : displayCallback $= display ... displayCallback is kind of like a variable that has stae?
21:10:57 <newsham> infinite lists
21:10:59 <dmwit> proqesi: *shrug* Maybe make sure that libHSrts is in the -L option you pass to ld?
21:11:00 <wuxia_> *state*
21:11:40 <kpreid> wuxia_: well, it's something-which-can-be-assigned-to
21:11:50 <kpreid> in this case it's part of GLUT
21:12:00 <kpreid> you're setting what the current display callback is
21:12:13 <dmwit> newsham: flatten (Cons xs rest) = foldr Cons (flatten rest) xs -- something like this?
21:12:24 <dmwit> ?src concat
21:12:24 <lambdabot> concat = foldr (++) []
21:12:36 <dmwit> ?src (++)
21:12:36 <lambdabot> []     ++ ys = ys
21:12:36 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
21:12:36 <lambdabot> -- OR
21:12:36 <lambdabot> xs ++ ys = foldr (:) ys xs
21:12:36 <lambdabot> -- In lambdabot, this is generalised to:
21:12:38 <lambdabot> (++) = mappend
21:13:03 <newsham> i think i'll just avoid the issue.  i'm converting to list later, so I'll just use list join
21:15:25 <proqesi> how do files get installed to /WIN on Win32?  I'm thinking my problem is with missing files there, but I don't know how the haskell files get installed to /WIN in the first place
21:15:40 <dmwit> I wonder...
21:15:46 <dmwit> ?let data Foo a = Foo a
21:15:46 <lambdabot> Invalid declaration
21:15:51 <reubenf> dmwit, is this how you were thinking i would use map in hasFlush? http://codepad.org/p2Xc87OT
21:15:52 <lambdabot> Title: Haskell code by Skeletor - 25 lines - codepad
21:16:27 <dmwit> reubenf: That can work.
21:16:30 <ddarius> newsham: There should be a listToStream function and there should be a streamConcat so it should just be streamConcat . map listToStream. (functions that do what those names suggest, not necessarily with those names)
21:16:39 <dmwit> reubenf: You could also do something like this:
21:17:03 <newsham> there is listToStream
21:17:12 <dmwit> [suit | suit <- [Spades, Diamonds, Clubs, Hearts], countSuit hand suit >= 5]
21:17:39 <dmwit> reubenf: Then, if you're really excited about (Maybe Suit) (as opposed to [Suit]), you could use listToMaybe:
21:17:41 <dmwit> :t listToMaybe
21:17:42 <lambdabot> forall a. [a] -> Maybe a
21:18:03 <dolio> @type let f (x:xs,xss) = (x, (xs,xss)) ; f ([], (x:xs):xss) = (x, (xs,xss)) ; f ([], []:xss) = f ([], xss) in unfoldr (Just . f)
21:18:04 <lambdabot> forall a. ([a], [[a]]) -> [a]
21:18:07 <ddarius> This is a different Stream library than I was expecting.
21:18:30 <dolio> @type let f (x:xs,xss) = (x, (xs,xss)) ; f ([], (x:xs):xss) = (x, (xs,xss)) ; f ([], []:xss) = f ([], xss) in \sl -> unfoldr (Just . f) ([], sl)
21:18:31 <lambdabot> forall a. [[a]] -> [a]
21:18:36 <reubenf> thanks dmwit :)
21:18:41 <newsham> woo!  it lives!
21:18:44 <dmwit> reubenf: If you haven't seen list comprehensions yet, then that comprehension boils down to "filter (>= 5) . map (countSuit hand) $ [Spades..Hearts]".
21:19:07 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/MyBot.hs
21:19:31 <newsham> the arrow stuff takes a while to sink in, but seems nifty
21:35:11 <nolrai_East> I would like a contanier data type that has fast random insert and replace, as well as fast random access. Do any exist? They do not need to be able to be infinite.
21:35:21 <dmwit> Data.Map
21:36:05 <ddarius> Define "fast"
21:36:53 <nolrai_East> faster is better.
21:37:10 <nolrai_East> better then O(n) time?
21:37:16 <dmwit> Congratulations, cabal, you just spewed all your output to stderr. *sigh*
21:37:46 <dmwit> Data.Map should be O(log n) at insert, replace, and access
21:39:21 <mmorrow> Data.Map is fast
21:39:35 <mmorrow> > foldl' (\m n -> M.insertWith (+) n 1 m) M.empty (take 100000 . randomRs (0,7) . mkStdGen $ 42)
21:39:40 <lambdabot>  fromList [(0,12506),(1,12425),(2,12479),(3,12412),(4,12489),(5,12631),(6,125...
21:41:09 <nolrai_East> Yeah, i need to a way to impose an next element concept too. but maybe just useing Data.Map and Data.Array and converting between the too would work. hmm no that would suck.
21:41:31 <mmorrow> yeah that would
21:41:43 <mmorrow> i'd pick one and stick to my guns
21:41:48 <dmwit> nolrai_East: ...use keys with an Enum instance?
21:42:04 <nolrai_East> yeah thats the best option i think.
21:42:41 <nolrai_East> thanks!
21:42:46 <nolrai_East> dmwit++
21:45:02 <nolrai_East> hmm, whats the best way to implement a map with two sets of keys? is a Map key1 d and a Bimap key2 key1 the way to go?
21:45:25 <mmorrow> explain more
21:45:27 <dmwit> Tell us more about the behavior.
21:45:33 <mmorrow> (heh)
21:48:35 <nolrai_East> err, im writing a genetic agorithem that opperates on a simple assembly language for a virtual machine.  One key (an instance of Enum) i use to get the next instruction, the other key is used by jumps.  The idea is that i can add instructions in the middle without the jumps all geting messed up.
21:49:20 <nolrai_East> in case it wasnt clear the map is supposed to be a program in the assembly.
21:50:07 <newsham> breeding superior code?
21:50:27 <dmwit> I can already tell you assembly is going to be too low-level to breed anything very interesting.
21:50:38 <dmwit> (Especially for go. =)
21:50:40 <dmwit> But!
21:51:12 <dmwit> Yes, a Map key1 instruction and a Map key2 key1 would probably suit nicely.
21:51:47 <nolrai_East> Yeah. I'm just looking for square roots and such nothing major.
21:52:06 <dmwit> Oh.  Why was I thinking of go?
21:52:06 <mmorrow> dmwit: Bah! http://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif
21:52:07 <lambdabot> http://tinyurl.com/5v4dya
21:52:13 <mmorrow> :)
21:52:19 <SamB_XP> dmwit: someone mentioned it earlier
21:52:24 <SamB_XP> by which I mean yesterday
21:52:50 <nolrai_East> (If i get this working then I'll try somthing more impressive).
21:54:24 <nolrai_East> Go is insainly hard though.
21:55:48 <nolrai_East> I find it too dificalt to be fun as a human playing.
21:58:53 <Axman6> go isn't also known as othello is it?
21:59:06 <dmwit> Um, I'm about to try something interesting.  If an hpaste appears here, feel free to ignore it.
21:59:07 <Axman6> or was that a card game...
21:59:07 <dmwit> Axman6: no
21:59:31 <nolrai_East> on both counts.
22:00:56 <Axman6> i made a very nice othello game for a comp assignment this semester in haskell. had the computer play against you too, and didn't use the naive game over function that most people did
22:02:09 <bd_> Axman6: go is much, much more complex than othello
22:02:15 <nolrai_East> ubuntu has an othello game that comes with it. A ai too.
22:02:19 <Axman6> fair enough
22:02:30 <wuxia_> yeah; othello is a game where if you can beat ur program, ur program sucks; go iks a game where if ur program beats the average human, you should write a research paper
22:02:32 <bd_> heck, even deciding who won given a final board state is a decently hard problem in AI
22:02:47 <cjb> Axman6: An average human Go player can beat the current best Go program.
22:02:57 <cjb> Axman6: Stark contrast to Othello and Chess.
22:03:00 <Axman6> heh, fair enough
22:04:01 <cjb> (where average == been playing for a year or so)
22:04:27 <bd_> the main problems are a huge space of possible moves (average ~200 fanout) and that most moves have no easily mesurable value (a human player will put pieces in places because it 'feels right', and a few dozen moves later it'll come in handy)
22:04:33 <cjb> somewhat talented players who've been playing for ~3 years can give the computer maximum handicap and still destroy it.  It's just very weak strategically.
22:04:47 <cjb> Yes, in chess you can say "a queen is worth 10 points and a rook is worth 5"
22:04:54 <newsham> [18:45] < dmwit> I can already tell you assembly is going to be too low-level to breed anything very interesting.
22:05:12 <cjb> with Go, you don't have an evaluation function for a stone.  it depends what group is in.  it depends whether that group is alive.  it depends whether it's going to kill another group later.
22:05:22 <newsham> i'm not sure about genetic algorithm searches, but there's at least one really cool paper that has interestin results doing searches on assembly
22:05:39 <newsham> http://portal.acm.org/citation.cfm?id=36194
22:05:41 <lambdabot> Title: Superoptimizer: a look at the smallest program
22:05:43 <bd_> in go you put down a piece, and a pro says "Oh, that's worth about 40 points", but not even the pro knowshow they came to that :)
22:06:06 <newsham> super cool paper
22:06:26 <cjb> bd_: ponnuki in the center?  :)
22:06:32 <bd_> cjb: hah
22:07:17 <dmwit> :t modify succ >> get :: Enum a => State a a
22:07:18 <lambdabot> forall a. (Enum a) => State a a
22:07:19 <bd_> I was more thinking of traditional openings, where putting a stone too far or too close is worth a lot, but nobody can really give a specific, logical reason as to /why/, apart from the voice of experience :)
22:07:41 <nolrai_East> the very very end game (that realy isnt even worth playing because one player will have won already most of the time) is a nice aplication of combinatory games. Its what what they were invented for.
22:08:36 <cjb> bd_: yeah.  I think people say 20pts for an opening (corner) move, though.
22:08:54 <bd_> mhm
22:09:20 <bd_> though, if a move destroys a ko threat, and later down the line you have a ko oworth 40pt, and would run out of threats without that one...
22:09:33 <cjb> The main help I got from reading the combinatorial go stuff was the idea of a point value that is the "temperature" of the board, that decreases slowly.
22:20:42 <koninkje> is there a canonical pair of names for accesors and 'mutators' on OOP-style datatypes, akin to get/put for MonadState?
22:21:09 <ddarius> What is an "OOP-style datatype"?
22:21:44 <koninkje> A record is pretty close, though I'm being a bit more generic about it
22:22:15 <bd_> argh, I used to know this one :|
22:22:19 <koninkje> e.g. having a class Foo with accessors and constructors rather than using the record syntax (so as to separate the interface and implementation)
22:22:36 <koninkje> ...no existential type nonsense though
22:22:57 <mmorrow> ddarius: cubicles and the phrase abandon all hope ye who enter here?
22:23:09 <koninkje> these objects are primarily used in MonadState, but I want analogous methods for the non-stateful manipulators
22:23:44 <jre2> koninkje: are you talking about getters/setters?
22:23:50 <koninkje> jre2: yeah
22:24:26 <jre2> I'm calling them get, set, and update for what I'm doing
22:25:25 <koninkje> I'm using getFoo/putFoo for when the object is the state of a MonadState, but i'm looking for versions when the object is explicitly passed in instead of implicitly read from the monad
22:25:51 <mmorrow> > runState (get >>= \(a,f) -> put a >> modify f >> return "9") (8,(*2))
22:25:53 <lambdabot>  <Plugins.Eval>:1:6:
22:25:53 <lambdabot>     Occurs check: cannot construct the infinite type: t ...
22:26:00 <mmorrow> crap
22:26:07 <koninkje> heh heh :)
22:26:31 <dmwit> You can't put just a, you have to also put a function.
22:26:51 <mmorrow> why
22:26:53 <dmwit> ...and you can't modify f, you have to modify (first f) or so.
22:27:05 <dmwit> mmorrow: Because the type of the state is constant throughout the computation.
22:27:17 <dmwit> Only the type of the contained value (not the state) may vary.
22:27:17 <mmorrow> ah, "my bad"
22:27:42 <mmorrow> the ethanol seeps *to t3h bone*
22:28:24 <dmwit> ?go functional references
22:28:26 <lambdabot> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
22:28:26 <lambdabot> Title: Overloading functional references - 21 thoughts
22:28:31 <dmwit> koninkje: Maybe that?
22:29:11 <shapr> @seen aheller
22:29:12 <lambdabot> I haven't seen aheller.
22:29:12 <gwern> mmorrow: trying to ripen yourself?
22:29:43 <mmorrow> gwern: that is one way to put it, yes.
22:29:49 <mmorrow> @!
22:29:50 <lambdabot> Maybe you meant: . ? @ v
22:30:09 <gwern> @@
22:30:16 <mmorrow> @botsmack
22:30:16 <lambdabot> :)
22:30:39 <gwern> lambdabot needs her drugs?
22:30:55 <mmorrow> more than life itself
22:31:15 <jre2> koninkje: I'm using get/set for explicitly passed stuff actually. (using the functional reference implementation linked above)
22:32:51 <newsham> ?type modifys
22:32:52 <lambdabot> Not in scope: `modifys'
22:33:02 <mmorrow> :t modify
22:33:03 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
22:34:21 <koninkje> jre2: For me the primary use is with the state monad and they use get/put so I shouldn't break from that tradition. I'm thinking I'll use theFoo/setFoo for the explicitly passed versions
22:35:13 <jre2> koninkje: hmm, "the" isn't half bad
22:35:30 <koninkje> dankje :)
22:35:41 <wuxia> in the following, what does @ mean? code: reshape s@(Size w h) = do viewport $= (Position 0 0, s)  postRedisplay Nothing
22:35:49 <jre2> although if you're using them alot you might as well make a nice infix operator
22:35:53 <Zao> wuxia: s refers to the whole thing on the right.
22:35:56 <jre2> wuxia: that's an as pattern
22:36:03 <newsham> > let a@(b,c) = ('x', 5) in (a,b,c)
22:36:05 <lambdabot>  (('x',5),'x',5)
22:36:21 <wuxia> Zao, jre2: got it, thanks
22:36:24 <gwern> I always find those so hard to read
22:36:52 <jre2> gwern: I agree that they're ugly, but they're also pretty handy
22:37:01 <newsham> hey gwern.  djinn isnt in lambdabot src anymore, but i think the lambdabot version was nonstandard (at least different than agustss' darcs).   is the lbot version somewhere else now?
22:37:23 <newsham> ?yow
22:37:24 <lambdabot> Couldn't find fortune file
22:38:04 <gwern> newsham: so far as I know, it was split out to a separate executable, wasn't it? I didn't know that they differed asides from anything necessary for cabalizing and hackaging
22:38:14 <jre2> @vixen
22:38:14 <lambdabot> You think this is a botiecall??
22:38:27 <newsham> it was already a seperate executable, but now its not in the lambdabot darcs tree
22:38:29 <jre2> well at least the important modules are working
22:38:41 <newsham> i dont see it on hackage.  gotta url?
22:39:07 * gwern doesn't, no
22:39:12 <newsham> arg, it is on hackage
22:39:15 <newsham> i missed it earlier.
22:39:57 <newsham> also looks like fortune got broken ?
22:40:10 <nolrai_East> @vixen
22:40:10 <lambdabot> What do you think of Foucault's theory of binary constructs as an imprisoning limitation on power imposed by arbiters?
22:40:32 <dmwit> ARGH!
22:40:38 <gwern> pretty sound based on historical practice with eg. american slavery. why do you ask?
22:41:03 <mmorrow> omg for a second i thought lb was some real person saying that, and i was like oh yeah the party has started!
22:41:19 <dmwit> I have "a, b, c :: ByteString; (a, b, c, [args]) = ...".  It complains that a, b, and c are unused in the function body.
22:41:49 <dmwit> But if I replace it with "(_, _, _, [args]) = ...", then it won't type-check due to ambiguous instances.
22:41:52 <dmwit> =((
22:42:33 <nolrai_East> yikes
22:42:50 <newsham> gwern: the djinn on hackage has extra info thats not filtered out by lambdabot
22:42:56 <newsham> thats not shown by the real lambdabot
22:43:11 <newsham> ie:  /msg lambdabot ?djinn a -> b   and  /msg nobote ?djinn a -> b
22:43:20 <newsham> I think the versions in lambdabot tree were modified some
22:44:13 <gwern> is extra info bad?
22:44:39 <dmwit> This extra info is.
22:44:41 <newsham> it means more output
22:45:09 <dmwit> gwern: "Welcome to Djinn/n:h for help" (paraphrased from memory)
22:45:32 <newsham> its ok to not have a custom built djinn
22:45:41 <newsham> but the Djinn.hs should probably compensate with more filtering
22:46:26 <gwern> newsham: no, I'd do this in Djin. add a --quiet flag
22:46:39 <gwern> the less in lambdabot the better, and this helps out other bots
22:46:49 <newsham> sure, thats reasonable too
22:47:08 <nolrai_East> :t liftM2
22:47:09 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:47:16 <cinimod> @seen igloo
22:47:16 <lambdabot> igloo is in #darcs, #ghc and #haskell. I last heard igloo speak 9h 47m 53s ago.
22:48:31 <nolrai_East> :t M.lookup
22:48:32 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
22:48:34 <gwern> newsham: so are you going to handle it?
22:48:38 <newsham> ?yow -- fortunePath in Config.hs needs update
22:48:38 <lambdabot> Couldn't find fortune file
22:49:02 <newsham> gwern: I dont have access to modify djinn package
22:49:32 <gwern> ...I sort of meant go to the djinn darcs repo
22:49:41 <gwern> http://www.augustsson.net/Darcs/Djinn/ apparently
22:49:43 <lambdabot> Title: Index of /Darcs/Djinn
22:49:52 <gwern> @where djinn
22:49:52 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
22:50:17 * gwern nods
22:51:49 * gwern nap nao
22:52:31 <jre2> anyone know if there are plans to move fail to MonadPlus (and change libraries like Data.Map)
22:53:30 <dolio> In what time frame?
22:53:47 <dolio> As long as we're worried about H98 compatibility, it won't happen.
22:54:09 <jre2> dunno, does haskell' have a time frame?
22:54:16 <dolio> Not really.
22:54:30 <dolio> Its time frame is several years ago. :)
22:55:16 <dolio> It might happen for H'. Or something like it.
22:56:52 <dolio> At least, I hope it will, although people seem to be more opposed to library changes in H' than I would have expected.
22:57:04 <cinimod> @src rawSystemPath
22:57:04 <lambdabot> Source not found. You untyped fool!
22:57:18 <^Someone^> Haha
22:57:19 <newsham> augustsson djinn doenst build w/ 6.8.2 as-is (package stuff)
22:58:29 <wuxia> what is the 'haskell' way to solve the following: in a glut application, when I press the wasd keys, it changes the location of the camera ... this is clearly state , what is the 'right' way to do this in haskell?
22:58:51 <dmwit> State
22:59:03 <cinimod> @hoogle Int -> String -> [String] -> IO ExitCode
22:59:03 <lambdabot> No matches, try a more general search
22:59:11 <newsham> glut is gtk stuff?
22:59:20 <ddarius> newsham: OpenGL
22:59:28 <wuxia> dmwit: can you give me something to google for or a url?
22:59:39 <dmwit> ?hoogle Data.State
22:59:40 <lambdabot> No matches, try a more general search
22:59:45 <dmwit> ?go meet the monads state
22:59:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Lazy.html
22:59:46 <lambdabot> Title: Control.Monad.State.Lazy
22:59:52 <dmwit> ...what.
23:00:13 <jre2> either toss it into a state monad or thread it through all relevant functions (messy if done with more than a handful of functions)
23:00:22 <dmwit> wuxia: http://www.haskell.org/all_about_monads/html/statemonad.html
23:00:22 <lambdabot> Title: The State monad
23:00:57 <ddarius> wuxia: The way HOpenGL is structured, the simplest way is to use mutable state.
23:02:06 <cinimod> @src Distribution.Simple.DefaultMainWithHooks
23:02:07 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:04:04 <mmorrow> wuxia: you should bring up OpenGL with quicksilver
23:04:11 <nolrai_East> > const 2 3
23:04:13 <lambdabot>  2
23:04:45 <wuxia> quicksilver? the microsoft competitor to flash?
23:05:01 <mmorrow> wuxia: he has experience with haskell interface
23:05:23 <wuxia> oh, quicksilver ... is an irc nick?
23:05:28 <mmorrow> heh, yeh
23:05:33 <wuxia> gotcha
23:05:59 <mmorrow> whois him, he appears to be on now
23:06:08 <mmorrow> oh man i can barely type
23:06:17 <mmorrow> goodnight
23:15:27 <shapr> Is there a good tutorial for using fgl?
23:15:44 <shapr> wuxia: I think microsoft's thingy is called silverlight.
23:16:36 <shapr> hxt takes looong to build.
23:17:51 <jre2> shapr: and it adds like 10mb to your binary...
23:19:05 <shapr> I'm trying hard to stay away from silverlight. I don't see where it has any benefits over flash.
23:19:11 <shapr> Except that it's possible silverlight will run on Mono.
23:19:14 <gwern> newsham: you're right, there's something odd about the darcs djinn. hackage djinn is version 2008, but darcs says 2005-something
23:19:33 <shapr> Some MS guys presented silverlight to our group at work, I asked them about silverlight, they said it should run on mono if mono were .net compatible.
23:19:47 <shapr> Personally, I think they don't know their _|_ from a hole in the ground when it comes to Linux.
23:19:50 <gwern> and hackage one has no split-base issues, hm
23:19:56 * gwern wonders where it came from
23:20:43 <gwern> but it was uploaded by augustsson
23:20:56 <ddarius> Is it just me or is the GUI chapter of RWH completely missing a code box containing the code for guiAdd?
23:20:56 <gwern> strange. did augustsson start ignoring his own repo?
23:21:16 <atp> ooo edwardk posted a new recursion scheme field guide!
23:21:25 <shapr> yes!
23:21:29 <shapr> And then he went to the airport!
23:21:46 <shapr> With my spare XO battery even...
23:22:13 <gwern> shapr: at least he didn't leave his stuff like his toothbrush behind?
23:22:25 <shapr> He probably got his toothbrush.
23:23:28 <gwern> newsham: so I think you need to ask augustsson what is up with djinn. it looks like he's no longer using the public darcs repo
23:24:11 <shapr> Hm, I haven't used HXT in years...
23:26:13 <dmwit> Does darcs have a way to list the files it is *not* tracking?
23:26:29 <dmwit> (i.e. as a check to see if you forgot to add any to the repository by accident?)
23:26:30 <shapr> There's darcs add -somethin
23:26:48 <gwern> dmwit: there's a whatsnew -sl, I think
23:27:05 <gwern> there is some option to recurse down and list all 'interesting'but not controlled files
23:27:22 <gwern> -l? --look-for-adds?
23:27:30 <shapr> whatsnew -sl looks pretty good at first glance.
23:28:11 * gwern remembers that invocation from some bug reports complaining about slowness :)
23:28:13 <shapr> @seen nolrai_West
23:28:13 <lambdabot> I haven't seen nolrai_West.
23:28:14 <nolrai_East> :t maybe
23:28:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:28:25 <nolrai_East> doesnt exist yet
23:28:38 <gwern> funny thing was, guy had hundreds of megs of non-controlled binary files, and darcs using to examine each and every byte of a file to determine whether it was a text or binary file
23:28:46 <gwern> so you could see the problem
23:28:53 <nolrai_East> nolrai_ does. (and is me i just couldnt remember my password).
23:28:54 <dmwit> gwern: Thanks! gwern++
23:29:58 <nolrai_East> :t fromMaybe
23:29:59 <lambdabot> forall a. a -> Maybe a -> a
23:32:13 <nolrai_East> @hoogle (m a -> m a) -> m ()
23:32:13 <lambdabot> Control.Monad.State.Class.modify :: MonadState s m => (s -> s) -> m ()
23:32:13 <lambdabot> Data.Function.fix :: (a -> a) -> a
23:32:13 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
23:33:17 <shapr> Is there something that builds an index of all the packages I have installed with cabal?
23:33:24 <nolrai_East> I want a modifyM. How would i do that? (for a monad that is from stacked tranformers)
23:33:25 <shapr> @index NTree
23:33:25 <lambdabot> bzzt
23:33:56 <shapr> Alternatively, does lambdabot's standard @index include everything from hackage?
23:34:58 <gwern> doubt it
23:35:04 <shapr> I wish it did!
23:35:46 <gwern> it would be nice, but let's get lambdabot cleaned up and stable before we add even more features
23:36:02 <gwern> shapr: or better yet, this is something hoogle is supposed to be able to do eventually
23:36:06 <shapr> I'm sure I'm partially to blame for the mess in the first place :-)
23:36:15 <shapr> Good point!
23:36:23 <gwern> oh neat, my mueval is finally secure
23:36:41 <stepcut> :)
23:36:41 * gwern thanks the Hint author, and tosses some poo in the direction of the GHC API guys
23:36:47 <stepcut> :p
23:36:51 * shapr hugs stepcut
23:36:55 <dmwit> ?go haskell hint
23:36:56 <lambdabot> http://www.cs.uwm.edu/classes/cs431/cs431-boyland/final-questions.html
23:36:56 <lambdabot> Title: Final: Sample Questions (v0.9)
23:37:00 * stepcut gofers shapr
23:37:06 * shapr grins
23:37:16 * stepcut jhcs
23:37:22 <ddarius> gwern: Come Hoogle 4, that should not be necessary.
23:37:23 <dmwit> gwern: Hint?
23:37:50 <gwern> ddarius: right, exactly
23:37:58 * stepcut goes to bed
23:38:00 <shapr> stepcut: haha
23:38:04 <gwern> dmwit: wrapper around GHC API, intended to make evaluation easy
23:38:06 * shapr Cores?
23:38:15 <shapr> If you really cored for me...
23:38:27 <gwern> dmwit: but the GHC API guys screwed up with qualified function names... so the Hint guy had to do a lot of work
23:39:25 <dmwit> Neat.
23:39:31 * dmwit notes it down
23:40:19 <gwern> srsly, I dunno what they were thinking in making the *default* to allow foo = System.Unsafe.unsafePerformIO $... work
23:40:31 <gwern> even when you've imported no modules whatsoever!
23:42:25 <osfameron> isn't it a building block for various safe functionality?
23:42:40 <osfameron> hmm, don't suppose that means it has to be visible without declaration though
23:42:40 * gwern finds this annoying on a level similar to that of profiled binaries *always* generating a .prof
23:43:00 <gwern> osfameron: how so? all I see is a giant, gaping anus right through all my elaborate security measures
23:43:12 <gwern> with no mention in the docs or comments and no way to fix it
23:43:43 <sieni> gwern: thanks for the mental image
23:43:51 <osfameron> how does it break your security measures?
23:44:12 <mauke> unrestricted side effects, anywhere
23:44:20 <nolrai_East> @pl f x y z a = g (x a) (y a) z
23:44:20 <lambdabot> f = (flip .) . liftM2 g
23:45:00 <ddarius> :t handle
23:45:00 <osfameron> yes, but only if you actually type unsafePerformIO, that's a policy/practice problem isn't it, rather than security?  Am I misunderstanding?
23:45:01 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
23:45:02 <ddarius> :t catch
23:45:03 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
23:45:17 <ddarius> :t Control.Exception.handle
23:45:19 <lambdabot> forall a. (GHC.IOBase.Exception -> IO a) -> IO a -> IO a
23:45:22 <gwern> osfameron: how doesn't it? I whitelist the list of modules you can import, I have special Show IO instances to neuter any supplied IO actions, I have resource limits out the wazoo - and with all of that, this function still prints out my password file: "mueval --expression "Foreign.unsafePerformIO $ readFile \"/etc/passwd\""
23:45:28 <ddarius> :t Control.Exception.catch
23:45:29 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
23:45:32 <dmwit> osfameron: Imagine lambdabot.
23:45:55 <gwern> osfameron: no, the issue is I specifically eliminate unsafe functions by having a module whitelist! and this unrestricted qualified nonsense RENDERS IT USELESS
23:47:01 <osfameron> ok, I see it for lambdabot and the other (few?) applications that need to process user supplied code.
23:47:27 <osfameron> heh, fair enough.  You're right, it does seem like a bad default
23:48:22 <gwern> yeah. I have no issue for insecure apps like ghci specifically enabling it (if it still makes sense there), but security should be by default
23:48:28 <audreyt>   
23:50:06 <reubenf> i have lists a and b and i want a list of everything that is in exactly one of the two lists, what is the best way to do this?
23:50:17 <gwern> audreyt: ?
23:50:24 <gwern> @hoogle (//)
23:50:25 <lambdabot> Data.Array.IArray.(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
23:51:01 <gwern> hm. I know there was a list difference operator
23:51:46 <audreyt> gwern: nvm, typo.
23:52:03 <gwern> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3A\\ maybe
23:52:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3A\\
23:52:28 <gwern> since reubenf doesn't want union or intersect, difference must be it
23:52:34 <jbapple> Did 6.8.2 -> 6.8.3 break anyone else's Cabal build?
23:52:46 <jbapple> src/Haddock/GHC/Typecheck.hs:82:4:
23:52:46 <jbapple>     Constructor `HsModule' should have 7 arguments, but has been given 8
23:52:54 <jbapple> sorry, Haddock build
23:52:58 <jbapple> Cabal seems fine
23:53:09 <reubenf> i think i want a \\ b intersect b \\ a
23:53:27 <reubenf> ?src \\
23:53:27 <lambdabot> (\\) = foldl (flip delete)
23:53:30 <dmwit> union
23:53:34 <reubenf> er yeah, union
23:53:42 <mauke> symmetric difference
23:53:49 <gwern> jbapple: I have heard a lot of people complaining about haddock building, yeah
23:54:49 <shapr> y0 jbapple, wassup?
23:55:07 <shapr> Does HXT handle HTML 4.01 Transitional?
23:55:13 <jbapple> shapr: hi.
23:55:22 <jbapple> (\\) takes too long
23:55:53 <jbapple> a \\ b takes |a| lg |b|, but it should take |a| lg (|b|/|a|)
23:55:59 <jbapple> And it does on finger trees
23:56:10 <nolrai_East> :t M.findAndDeleteMax
23:56:11 <gwern> jbapple: lists are not known for speed... altho I hear Data.Set is faster?
23:56:11 <lambdabot> Couldn't find qualified module.
23:56:13 <dmwit> Use Data.Set
23:56:31 <nolrai_East> :t M.insert
23:56:32 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
23:56:34 <jbapple> I was referring to Data.Set
23:56:38 <gwern> fromList . union . toList, or something I guess
23:57:56 <jbapple> ?src Data.Set.(\\)
23:57:56 <lambdabot> Source not found.
23:58:08 <mauke> syntax error
